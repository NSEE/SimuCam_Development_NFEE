
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x00050bc0 memsz 0x0006ae34 flags rwx
    LOAD off    0x00052000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00052000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         000492b4  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000058dc  81149510  81149510  0004a510  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114edec  8114edec  0004fdec  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a274  81150be0  81150be0  00051be0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  8116ae54  8116ae54  00052000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00052000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00052000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  00052028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0007033f  00000000  00000000  00053d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 000167d9  00000000  00000000  000c40bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   000227c7  00000000  00000000  000da898  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  0000993c  00000000  00000000  000fd060  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000ca00  00000000  00000000  0010699c  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0011339c  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  0013a268  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  0013a2a8  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  001489f5  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  001489fb  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00148a07  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00148a08  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00148a09  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00148a0d  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00148a11  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00148a15  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00148a20  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00148a2a  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00148a34  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  00148a45  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     00226f57  00000000  00000000  00148a84  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
81149510 l    d  .rodata	00000000 .rodata
8114edec l    d  .rwdata	00000000 .rwdata
81150be0 l    d  .bss	00000000 .bss
8116ae54 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
811047c8 l     F .text	00000050 uliCommReadReg
81104774 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81105008 l     F .text	00000050 uliDpktReadReg
81104fb4 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
81150c04 l     O .bss	00000004 viCh1HoldContext
81150c08 l     O .bss	00000004 viCh2HoldContext
81150c0c l     O .bss	00000004 viCh3HoldContext
81150c10 l     O .bss	00000004 viCh4HoldContext
81150c14 l     O .bss	00000004 viCh5HoldContext
81150c18 l     O .bss	00000004 viCh6HoldContext
81150c1c l     O .bss	00000004 viCh7HoldContext
81150c20 l     O .bss	00000004 viCh8HoldContext
81106b78 l     F .text	00000054 vFeebWriteReg
81106bcc l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
81150c24 l     O .bss	00000004 viCh1HoldContext
81150c28 l     O .bss	00000004 viCh2HoldContext
81150c2c l     O .bss	00000004 viCh3HoldContext
81150c30 l     O .bss	00000004 viCh4HoldContext
81150c34 l     O .bss	00000004 viCh5HoldContext
81150c38 l     O .bss	00000004 viCh6HoldContext
81150c3c l     O .bss	00000004 viCh7HoldContext
81150c40 l     O .bss	00000004 viCh8HoldContext
81109968 l     F .text	00000054 vRmapWriteReg
81109a0c l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110a340 l     F .text	00000050 uliSpwcReadReg
8110a2ec l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
81150b08 l     O .rwdata	00000001 ucIoValue
8110a540 l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110ae30 l     F .text	0000013c msgdma_write_extended_descriptor
8110af6c l     F .text	00000164 msgdma_construct_extended_descriptor
8110b0d0 l     F .text	00000318 msgdma_descriptor_async_transfer
8110b3e8 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110bf64 l     F .text	00000054 vRstcWriteReg
8110bfb8 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
81150c48 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
81150c50 l     O .bss	00000004 pxNFee.5660
81150c54 l     O .bss	00000004 tCodFeeTask.5663
81150c58 l     O .bss	00000004 incrementador.5665
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
81150c5c l     O .bss	00000004 xRAckLocal.5595
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
81150c60 l     O .bss	00000004 bDmaBack.5636
81150c64 l     O .bss	00000001 ucWhoGetDMA.5637
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
81150c66 l     O .bss	00000004 xSAckLocal.5580
00000000 l    df *ABS*	00000000 parser_comm_task.c
81150de0 l     O .bss	0000004c PreParsedLocal.5633
81150e2c l     O .bss	00000054 xTcPusL.5632
00000000 l    df *ABS*	00000000 receiver_uart_task.c
81150e80 l     O .bss	0000004c xPreParsedReader.5625
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
81150ecc l     O .bss	00000054 xPusLocal.5867
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114c737 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114e22d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114edec l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
81120c5c l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114e3fa l     O .rodata	00000010 zeroes.4389
8114e40a l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114e41a l     O .rodata	00000010 zeroes.4404
811258d4 l     F .text	000000c4 __sbprintf
8114e42a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114e442 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
811275bc l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
8112910c l     F .text	00000008 __fp_unlock
81129120 l     F .text	000001a4 __sinit.part.1
811292c4 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114f638 l     O .rwdata	00000020 lc_ctype_charset
8114f618 l     O .rwdata	00000020 lc_message_charset
8114f658 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114e480 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
8112c134 l     F .text	0000006c sulp
8114e5c8 l     O .rodata	00000014 fpi.2737
8114e5dc l     O .rodata	00000028 tinytens
8114e5b4 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114e614 l     O .rodata	00000010 blanks.4332
8114e604 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112f7a4 l     F .text	00000104 __sprint_r.part.0
8114e634 l     O .rodata	00000010 blanks.4348
8114e624 l     O .rodata	00000010 zeroes.4349
81130d40 l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
811311f4 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
811343d0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
81134514 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81134548 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
811347cc l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
811348c4 l       .text	00000000 tx_next_char
811348ec l       .text	00000000 end_tx
811348cc l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
811353c8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81135644 l     F .text	00000044 alt_get_errno
81135688 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
811358b0 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
81150b50 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81135e50 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
81150b5c l     O .rwdata	00000004 lockid
81150d28 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
81150b60 l     O .rwdata	00000004 lockid
81150d30 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
811378dc l     F .text	00000050 OS_InitMisc
8113792c l     F .text	00000074 OS_InitRdyList
81137ab0 l     F .text	000000ec OS_InitTCBList
811377f4 l     F .text	000000e8 OS_InitEventList
811379a0 l     F .text	00000088 OS_InitTaskIdle
81137a28 l     F .text	00000088 OS_InitTaskStat
81137d40 l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81139b58 l     F .text	000000fc OS_FlagTaskRdy
81139908 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
8113b444 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113fe74 l     F .text	00000044 OSTmr_Lock
8113f914 l     F .text	00000074 OSTmr_Alloc
8113feb8 l     F .text	0000003c OSTmr_Unlock
8113fd78 l     F .text	000000fc OSTmr_Unlink
8113f988 l     F .text	000000a4 OSTmr_Free
8113fc28 l     F .text	00000150 OSTmr_Link
8113fba0 l     F .text	00000088 OSTmr_InitTask
8113fef4 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
81140004 l     F .text	0000003c alt_dev_reg
8114f8d4 l     O .rwdata	0000106c jtag_uart_0
81150940 l     O .rwdata	000000d0 rs232_uart
81150a10 l     O .rwdata	00000064 dma_DDR_M1
81150a74 l     O .rwdata	00000064 dma_DDR_M2
81150ad8 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81144894 l     F .text	000002bc altera_avalon_jtag_uart_irq
81144b50 l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81145354 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811456ec l     F .text	000000a4 altera_avalon_uart_irq
81145790 l     F .text	00000140 altera_avalon_uart_rxirq
811458d0 l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81145ad8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81145d8c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81146010 l     F .text	00000044 alt_get_errno
81146054 l     F .text	0000009c alt_msgdma_write_standard_descriptor
811460f0 l     F .text	00000134 alt_msgdma_write_extended_descriptor
81146224 l     F .text	0000018c alt_msgdma_irq
811463b0 l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81146444 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
811465a0 l     F .text	00000340 alt_msgdma_descriptor_async_transfer
811468e0 l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81146fe8 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81147094 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
81148260 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
811488a4 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
81150dd8 l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
81150ddc g     O .bss	00000004 alt_instruction_exception_handler
81107038 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
81151678 g     O .bss	00001000 vFeeTask0_stk
81119f90 g     F .text	0000004c vFailDeleteInitialization
81118bb4 g     F .text	00000bc4 vLoadDebugConfs
81150dac g     O .bss	00000004 aux_status_register
81152678 g     O .bss	00001000 vInAckHandlerTask_stk
8114801c g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
81107380 g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110c604 g     F .text	0000004c vSyncInitIrq
81115594 g     F .text	00000284 vCheckRetransmission128
8112b7b8 g     F .text	0000007c _mprec_log10
8110c80c g     F .text	00000040 bSyncSetMbt
8111b554 g     F .text	00000054 vFailRequestDMAFromIRQ
8110a724 g     F .text	00000108 I2C_Read
81150bae g     O .rwdata	00000002 OSTaskNameSize
81150c70 g     O .bss	00000004 xWaitSyncQFee
81153678 g     O .bss	00000260 xBuffer64
8112b8ac g     F .text	0000008c __any_on
8112a280 g     F .text	0000005c _isatty_r
8114e48c g     O .rodata	00000028 __mprec_tinytens
81107328 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811354e8 g     F .text	0000015c alt_main
81106434 g     F .text	00000078 bFeebGetRightBufferEmpty
81120b80 g     F .text	000000c8 _puts_r
8110567c g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
81150d38 g     O .bss	00000004 OSTmrFreeList
8116ad54 g     O .bss	00000100 alt_irq
8112a3f0 g     F .text	00000068 _lseek_r
8111c77c g     F .text	00000030 vChangeDefaultAutoResetSync
8113a3b8 g     F .text	000000d4 OS_MemInit
8111b500 g     F .text	00000054 vFailRequestDMA
811064ac g     F .text	00000068 bFeebGetCh1LeftBufferEmpty
81117ff8 g     F .text	0000088c vLoadDefaultETHConf
81110a04 g     F .text	0000014c bCheckInAck64
811538d8 g     O .bss	00000150 xPus
8113ee54 g     F .text	00000068 OSTimeSet
81114240 g     F .text	0000008c vPusType250run
811294c4 g     F .text	000000ac __sflags
8111aed4 g     F .text	00000068 vCoudlNotCreateNFee2Task
8111b2c0 g     F .text	0000004c vCouldNotGetMutexMebPus
81134074 g     F .text	00000088 .hidden __eqdf2
8111490c g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111c668 g     F .text	00000034 vLoadDefaultSyncSource
81119a28 g     F .text	0000004c vFailCreateMutexDMA
81140504 g     F .text	000001ac Check_for_Master_Boot_Record
81164768 g     O .bss	00000010 OSTmrWheelTbl
81107420 g     F .text	00000050 uliRmapCh3WriteCmdAddress
81146da8 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
81153a28 g     O .bss	00000020 xFeeQueueTBL3
81136540 g     F .text	00000594 OSEventPendMulti
81150c74 g     O .bss	00000004 xNfeeSchedule
8116ae54 g       *ABS*	00000000 __alt_heap_start
81148edc g     F .text	0000002c OSTaskCreateHook
8114437c g     F .text	000001c4 alt_up_sd_card_fclose
81150c78 g     O .bss	00000004 xSemCountBuffer64
8110452c g     F .text	0000016c bCommSetGlobalIrqEn
81107824 g     F .text	00000088 bRmapGetIrqControl
811209c4 g     F .text	00000044 printf
81150c45 g     O .bss	00000001 SspdConfigControl
8110cc28 g     F .text	00000054 bSyncCtrReset
81150b86 g     O .rwdata	00000002 OSMboxEn
8110f604 g     F .text	00000260 vQCmdFeeRMAPWaitingSync
8111d2f0 g     F .text	000000a4 aatoh
81136b38 g     F .text	00000054 OSIntEnter
81131e60 g     F .text	000000a4 _wcrtomb_r
81105588 g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81119ef8 g     F .text	0000004c vFailReceiverCreate
81150c7c g     O .bss	00000004 xQMaskDataCtrl
81105098 g     F .text	00000084 vFeebCh2HandleIrq
811210e8 g     F .text	00000064 __sseek
81129474 g     F .text	00000010 __sinit
8110b8a4 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
8112723c g     F .text	00000148 __swbuf_r
81115d6c g     F .text	00000470 bResourcesInitRTOS
81109e8c g     F .text	000000f4 bSpwcGetLinkError
81150b96 g     O .rwdata	00000002 OSQEn
8110eef4 g     F .text	000004a8 vQCmdFeeRMAPinStandBy
81106d60 g     F .text	00000040 vRmapCh4HandleIrq
8112a30c g     F .text	00000084 _setlocale_r
81153a48 g     O .bss	00000020 SyncTBL2
81150b0c g     O .rwdata	00000004 LedsPainelControl
81150f48 g     O .bss	00000100 cDebugBuffer
811292cc g     F .text	00000070 __sfmoreglue
8112f78c g     F .text	00000018 ungetc
8110588c g     F .text	000000d4 bFeebCh1SetBufferSize
811361fc g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
81148f5c g     F .text	00000028 OSTaskStatHook
81114768 g     F .text	00000088 vSendCmdQToNFeeCTRL
8111c6d8 g     F .text	00000030 vChangeDefaultSyncSource
81150d3c g     O .bss	00000001 OSLockNesting
81150d40 g     O .bss	00000004 OSTmrSemSignal
8111b980 g     F .text	00000178 vNFeeStructureInit
81150c80 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
8112c1a0 g     F .text	00001600 _strtod_r
81150c84 g     O .bss	00000004 xSemCountSenderACK
8111d4a8 g     F .text	00000448 .hidden __divsf3
81150dd0 g     O .bss	00000004 current_sector_modified
81150bd4 g     O .rwdata	00000002 OSDataSize
81150d44 g     O .bss	00000001 OSRunning
8110a168 g     F .text	00000184 bSpwcInitCh
811351b0 g     F .text	00000064 alt_log_jtag_uart_isr_proc
81153a68 g     O .bss	00001000 senderTask_stk
81108318 g     F .text	00000094 bRmapGetMemConfigStat
81150c88 g     O .bss	00000004 fp
81154a68 g     O .bss	00000048 xNfeeScheduleTBL
811108bc g     F .text	00000148 bCheckInAck128
8112a780 g     F .text	0000015c memmove
81148fd8 g     F .text	0000002c OSInitHookBegin
8110d0c4 g     F .text	00000074 bSyncCtrCh8OutEnable
8110f9d0 g     F .text	00000088 bEnableDbBuffer
81150bcc g     O .rwdata	00000002 OSTmrSize
8112945c g     F .text	00000018 _cleanup
8111cba4 g     F .text	00000040 siCloseFile
811069f4 g     F .text	00000184 bFeebInitCh
8112a8dc g     F .text	000000b0 _Balloc
8111c708 g     F .text	00000038 vLoadDefaultAutoResetSync
81107934 g     F .text	000000d8 bRmapSetCodecConfig
81142f58 g     F .text	000000cc alt_up_sd_card_is_Present
81146ce8 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
81150be8 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8114022c g     F .text	00000054 Save_Modified_Sector
811057dc g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
81150d48 g     O .bss	00000004 OSIdleCtr
81150d04 g     O .bss	00000001 alt_log_write_on_flag
8110a390 g     F .text	0000003c bEnableIsoDrivers
8111df18 g     F .text	000000dc .hidden __gtdf2
81148c6c g     F .text	0000002c altera_nios2_gen2_irq_init
81148d54 g       .text	00000000 OSStartTsk
8110c980 g     F .text	00000070 bSyncSetNCycles
811380b0 g     F .text	000002dc OS_TCBInit
81150d07 g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111c2f0 g     F .text	00000078 vInitSimucamBasicHW
81154ab0 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110cfdc g     F .text	00000074 bSyncCtrCh6OutEnable
8110aaa0 g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
81150dc8 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
81150d4c g     O .bss	00000002 OSTmrUsed
81150c8c g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
8110777c g     F .text	000000a8 bRmapSetIrqControl
81105bdc g     F .text	000000d4 bFeebCh5SetBufferSize
81155ab0 g     O .bss	00001000 vDataControlTask_stk
811051a0 g     F .text	00000084 vFeebCh4HandleIrq
81150bd2 g     O .rwdata	00000002 OSTmrWheelTblSize
8111bf98 g     F .text	0000002c cFeeSpwChannelDisable
81150b72 g     O .rwdata	00000002 OSEventSize
81150d4e g     O .bss	00000001 OSPrioHighRdy
8111fb60 g     F .text	00000064 _fstat_r
81148f08 g     F .text	0000002c OSTaskDelHook
81150ce0 g     O .bss	00000004 errno
8110d3b8 g     F .text	0000003c uliSyncGetCtr
811271cc g     F .text	0000001c __svfscanf
8112105c g     F .text	00000008 __seofread
81148d34 g       .text	00000000 OSStartHighRdy
8111b8e0 g     F .text	00000028 vEvtChangeFeeControllerMode
8110fc04 g     F .text	00000968 vPrintConsoleNFee
81111834 g     F .text	000000c8 bSendCmdQToNFeeInst
81106e20 g     F .text	00000040 vRmapCh7HandleIrq
8113d884 g     F .text	000001ec OSTaskCreateExt
8116473c g     O .bss	00000011 alt_log_write_buf
81104a44 g     F .text	0000012c bDpktGetPacketConfig
811075b0 g     F .text	00000050 uliRmapCh8WriteCmdAddress
8111a2b4 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112e2d0 g     F .text	00001244 ___svfiprintf_internal_r
811133d0 g     F .text	00000364 bPreParserV2
81139438 g     F .text	00000068 OSFlagPendGetFlagsRdy
81150bb2 g     O .rwdata	00000002 OSTaskStatStkSize
811065e4 g     F .text	00000068 bFeebGetCh2RightBufferEmpty
81138584 g     F .text	00000310 OSFlagAccept
8113bb60 g     F .text	000000c0 OSQFlush
81151448 g     O .bss	00000118 xRmap
8113b5dc g     F .text	00000148 OSQAccept
81150d18 g     O .bss	00000004 alt_argv
81158b04 g       *ABS*	00000000 _gp
81119bc0 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81135d14 g     F .text	0000013c usleep
81143530 g     F .text	00000384 alt_up_sd_card_fopen
8111ca10 g     F .text	00000030 bSDcardIsPresent
81113734 g     F .text	00000178 vSenderComTask
81143098 g     F .text	000000d8 alt_up_sd_card_find_first
8113d6d0 g     F .text	000001b4 OSTaskCreate
8111a454 g     F .text	00000068 vFailSendNack
81150dbc g     O .bss	00000004 command_argument_register
8113d1d8 g     F .text	000004f8 OSTaskChangePrio
81113e04 g     F .text	000000ac vPusMebInTaskConfigMode
8111abcc g     F .text	00000088 vCouldNotSendTMPusCommand
81150d34 g     O .bss	00000004 alt_heapsem
8111be38 g     F .text	000000b0 vResetMemCCDFEE
8110ad38 g     F .text	00000080 bSetBoardLeds
8113838c g     F .text	000001f8 OSDebugInit
8113da70 g     F .text	0000034c OSTaskDel
8113a48c g     F .text	000001ac OSMutexAccept
81156ab0 g     O .bss	000002b8 xSimMeb
8111c1d4 g     F .text	00000040 vSetTimeCode
81147890 g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
81150c90 g     O .bss	00000004 xSemCountPreParsed
8114f6b8 g     O .rwdata	00000180 alt_fd_list
8110572c g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114f854 g     O .rwdata	0000001d alt_log_msg_alt_main
81164778 g     O .bss	00000840 OSFlagTbl
811070c0 g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81119d28 g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811074c0 g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111c5c0 g     F .text	0000003c vLoadDefaultRTValue
811375bc g     F .text	000000c0 OS_EventTaskRemove
81156d68 g     O .bss	00001000 vFeeTask5_stk
81150d06 g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
811427ac g     F .text	00000134 find_first_empty_record_in_root_directory
81148350 g     F .text	00000098 alt_find_dev
811206ac g     F .text	00000150 memcpy
81131b2c g     F .text	00000264 __hexnan
81104e40 g     F .text	00000174 bDpktInitCh
81157d68 g     O .bss	00000160 xBuffer32
81150b9c g     O .rwdata	00000002 OSRdyTblSize
81164fb8 g     O .bss	000001a0 OSTmrTbl
81129114 g     F .text	0000000c _cleanup_r
8111f098 g     F .text	000000e4 .hidden __floatsidf
81117c20 g     F .text	000001a8 vSendPusTM64
8110c77c g     F .text	0000004c ucSyncStatusErrorCode
81114878 g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111c094 g     F .text	00000034 cFeeRMAPLogDisable
81111cbc g     F .text	00000df0 vParserCommTask
81148970 g     F .text	00000084 alt_io_redirect
8111c028 g     F .text	00000034 cFeeRMAPEchoingDisable
811340fc g     F .text	000000f4 .hidden __ltdf2
8111b20c g     F .text	0000004c vFailSendPUStoMebTask
811072d0 g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811060a8 g     F .text	000000d4 bFeebSetIrqControl
8111a9c4 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
81150c94 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
81150c00 g     O .bss	00000004 EDpktMode
81147d18 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
81148060 g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110ccd0 g     F .text	00000054 bSyncCtrErrInj
81147fc0 g     F .text	0000005c alt_msgdma_register_callback
81118884 g     F .text	00000330 vShowEthConfig
8111c368 g     F .text	00000030 bLogWriteSDCard
8111a044 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
81120c48 g     F .text	00000014 puts
8111cc24 g     F .text	00000284 bInitSync
81149080 g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110c4b0 g     F .text	00000128 vSyncHandleIrq
811362d0 g     F .text	00000128 OSEventNameGet
811053f0 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
81150b80 g     O .rwdata	00000002 OSFlagMax
8112a50c g     F .text	000000e0 mbrtowc
811423a4 g     F .text	000001b4 find_first_empty_cluster
81114994 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110cf68 g     F .text	00000074 bSyncCtrCh5OutEnable
81150c4c g     O .bss	00000001 vucN
8112bf0c g     F .text	00000074 __fpclassifyd
8110c6dc g     F .text	00000054 bSyncStatusExtnIrq
811271e8 g     F .text	00000054 _vfscanf_r
8113ab0c g     F .text	000005a4 OSMutexPend
8112b70c g     F .text	000000ac __ratio
81142e94 g     F .text	000000c4 alt_up_sd_card_open_dev
8111ac54 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81136b8c g     F .text	00000100 OSIntExit
8110c84c g     F .text	00000040 bSyncSetBt
81130d24 g     F .text	0000001c __vfiprintf_internal
8111b30c g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
81150bba g     O .rwdata	00000002 OSTCBSize
811053ac g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
81150d4f g     O .bss	00000001 OSPrioCur
81144dc4 g     F .text	000002c4 altera_avalon_jtag_uart_read
81147558 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8112098c g     F .text	00000038 _printf_r
81132c18 g     F .text	00000064 .hidden __udivsi3
81134810 g     F .text	000000ac isatty
81150c44 g     O .bss	00000001 LedsBoardControl
81150c98 g     O .bss	00000004 xSemCountReceivedACK
81150ba0 g     O .rwdata	00000002 OSStkWidth
8112a2dc g     F .text	00000030 iswspace
8114e4dc g     O .rodata	000000c8 __mprec_tens
81150b94 g     O .rwdata	00000002 OSPtrSize
8111b5a8 g     F .text	00000054 vFailSendRMAPFromIRQ
8111b074 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
8112a390 g     F .text	0000000c __locale_charset
8110ce80 g     F .text	00000074 bSyncCtrCh3OutEnable
81132e08 g     F .text	000000c8 .hidden __lesf2
81150b74 g     O .rwdata	00000002 OSEventTblSize
8111d42c g     F .text	0000007c .hidden __fixunsdfsi
81148c98 g       .text	00000000 OSCtxSw
8110a82c g     F .text	00000160 I2C_MultipleRead
81135354 g     F .text	00000074 alt_log_system_clock
81150cec g     O .bss	00000004 __malloc_top_pad
81150d50 g     O .bss	00000004 OSTCBList
8113f8d4 g     F .text	00000040 OSTmrSignal
81150cfc g     O .bss	00000004 alt_fd_list_lock
8112ddfc g     F .text	0000001c strtoul
81150b24 g     O .rwdata	00000004 __mb_cur_max
8112a3c0 g     F .text	0000000c _localeconv_r
8112de18 g     F .text	000002e0 _strtoull_r
8110bef4 g     F .text	00000070 vRstcHoldDeviceReset
8112ad00 g     F .text	00000044 __i2b
81129c24 g     F .text	000004c4 __sfvwrite_r
81141684 g     F .text	000000c0 get_dir_divider_location
81106f6c g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81165158 g     O .bss	00000c30 OSMemTbl
81150d54 g     O .bss	00000001 OSTickStepState
81134f64 g     F .text	00000060 alt_log_printf_proc
81104d7c g     F .text	000000c4 bDpktGetPixelDelay
81157ec8 g     O .bss	00001800 vReceiverUartTask_stk
81120e54 g     F .text	0000005c _sbrk_r
81150c9c g     O .bss	00000004 xSemTimeoutChecker
81141344 g     F .text	000000cc filename_to_upper_case
81150d08 g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
81150b98 g     O .rwdata	00000002 OSQMax
811438b4 g     F .text	00000090 alt_up_sd_card_set_attributes
8113a808 g     F .text	00000304 OSMutexDel
81165d88 g     O .bss	00001000 OSTaskStatStk
8111ca40 g     F .text	00000030 bSDcardFAT16Check
81139fd4 g     F .text	000000f8 OSMemNameGet
811199c8 g     F .text	00000060 vFailCreateMutexSResources
811406b0 g     F .text	00000284 Read_File_Record_At_Offset
811596c8 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
81150b78 g     O .rwdata	00000002 OSFlagEn
8112b938 g     F .text	00000068 _read_r
81150bbe g     O .rwdata	00000002 OSTimeTickHookEn
81139c54 g     F .text	000000ac OS_FlagUnlink
8113c028 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
81150b40 g     O .rwdata	00000004 alt_max_fd
8111a770 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
81137bf8 g     F .text	00000070 OS_MemCopy
81137c68 g     F .text	000000d8 OS_Sched
81141f28 g     F .text	0000047c find_file_in_directory
81130ed0 g     F .text	000000f8 _fclose_r
81139edc g     F .text	000000f8 OSMemGet
8113e0b4 g     F .text	000001bc OSTaskNameSet
811290dc g     F .text	00000030 fflush
81150ce8 g     O .bss	00000004 __malloc_max_sbrked_mem
81150d58 g     O .bss	00000004 OSCtxSwCtr
81105cb0 g     F .text	000000d4 bFeebCh6SetBufferSize
81148f84 g     F .text	00000054 OSTimeTickHook
81159708 g     O .bss	00001000 vOutAckHandlerTask_stk
81134644 g     F .text	00000188 alt_irq_register
81150b82 g     O .rwdata	00000002 OSFlagNameSize
8111f17c g     F .text	00000118 .hidden __extendsfdf2
8113767c g     F .text	00000108 OS_EventTaskRemoveMulti
8111ad94 g     F .text	00000070 vFailCreateNFEESyncQueue
81143024 g     F .text	00000074 alt_up_sd_card_is_FAT16
8110a5bc g     F .text	00000088 I2C_TestAdress
81132ed0 g     F .text	000008b4 .hidden __adddf3
81164750 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
81132cd4 g     F .text	00000078 .hidden __nesf2
81106f28 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
81137464 g     F .text	00000158 OS_EventTaskWaitMulti
8115a708 g     O .bss	00000020 SyncTBL4
8112b4a4 g     F .text	00000114 __b2d
81147290 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
81150b9a g     O .rwdata	00000002 OSQSize
811325e0 g     F .text	00000540 .hidden __umoddi3
8113540c g     F .text	000000dc lseek
8113cb18 g     F .text	00000214 OSSemPend
8111b258 g     F .text	00000068 vCouldNotGetCmdQueueMeb
81107a98 g     F .text	00000160 bRmapGetCodecStatus
81109f80 g     F .text	000000d0 bSpwcGetLinkStatus
811067d4 g     F .text	00000088 bFeebGetWindowing
81150b14 g     O .rwdata	00000004 _global_impure_ptr
8110c464 g     F .text	0000004c bSSDisplayUpdate
811419e8 g     F .text	00000540 get_home_directory_cluster_for_file
8112b9a0 g     F .text	0000056c _realloc_r
81150b84 g     O .rwdata	00000002 OSLowestPrio
8116ae54 g       *ABS*	00000000 __bss_end
811487ac g     F .text	000000f8 alt_iic_isr_register
81149054 g     F .text	0000002c OSTCBInitHook
81150bca g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81135c04 g     F .text	00000110 alt_tick
81107600 g     F .text	0000017c vRmapInitIrq
81119cc0 g     F .text	00000068 vFailGetMutexSenderTask
8110be14 g     F .text	0000006c vRstcSimucamReset
8110fabc g     F .text	000000a4 bSendRequestNFeeCtrl
8114e644 g     O .rodata	00000100 __hexdig
81147e0c g     F .text	000001b4 alt_msgdma_init
81132060 g     F .text	00000580 .hidden __udivdi3
811130b8 g     F .text	0000017c setPreAckSenderFreePos
81131148 g     F .text	00000024 _fputwc_r
81150b6c g     O .rwdata	00000002 OSEventEn
8114e4b4 g     O .rodata	00000028 __mprec_bigtens
8112aadc g     F .text	0000010c __s2b
81150bc6 g     O .rwdata	00000002 OSTmrCfgNameSize
8115a728 g     O .bss	00000020 xFeeQueueTBL4
8110c90c g     F .text	00000074 bSyncSetPolarity
81115818 g     F .text	0000028c vCheckRetransmission64
811341f0 g     F .text	000000b0 .hidden __floatunsidf
81150d0c g     O .bss	00000004 alt_system_clock_in_sec
8113515c g     F .text	00000054 alt_log_jtag_uart_startup_info
8111a24c g     F .text	00000068 vFailFoundBufferRetransmission
8112b1dc g     F .text	00000060 __mcmp
81150dd4 g     O .bss	00000004 current_sector_index
81145584 g     F .text	00000168 altera_avalon_uart_init
811480e8 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
81104118 g     F .text	00000414 bSdmaDmaM2Transfer
8111c214 g     F .text	00000034 vResetTimeCode
8111bf6c g     F .text	0000002c cFeeSpwChannelEnable
81129494 g     F .text	00000018 __fp_lock_all
8111b73c g     F .text	0000004c vFailSendMsgDataCTRL
81148758 g     F .text	00000054 alt_ic_irq_enabled
8110a644 g     F .text	000000e0 I2C_Write
81107170 g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
81150d5c g     O .bss	00000002 OSTmrFree
81139a70 g     F .text	000000e8 OS_FlagInit
81135b60 g     F .text	000000a4 alt_alarm_stop
811214bc g     F .text	0000001c strtol
81150d05 g     O .bss	00000001 alt_log_sys_clk_on_flag
8113f080 g     F .text	00000140 OSTmrDel
8114041c g     F .text	000000e8 mark_cluster
81150ba8 g     O .rwdata	00000002 OSTaskIdleStkSize
81150d00 g     O .bss	00000004 alt_irq_active
8113c738 g     F .text	000000b8 OSSemAccept
8111f6f8 g     F .text	0000044c _fseeko_r
811166b0 g     F .text	00000260 vFillMemmoryPattern
81121238 g     F .text	00000044 strnlen
8113a1e8 g     F .text	000000e0 OSMemPut
81139d00 g     F .text	000001dc OSMemCreate
81150d60 g     O .bss	00000004 OSIdleCtrMax
81117dc8 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
811349ac g     F .text	000005b8 alt_log_private_printf
8114f690 g     O .rwdata	00000028 alt_dev_null
81146ea0 g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110c8cc g     F .text	00000040 bSyncSetOst
81150bbc g     O .rwdata	00000002 OSTicksPerSec
8114f838 g     O .rwdata	00000019 alt_log_msg_bss
811428e0 g     F .text	00000194 convert_filename_to_name_extension
811083ac g     F .text	00000c4c bRmapSetRmapMemHKArea
8110664c g     F .text	000000e0 bFeebSetBufferSize
811138ac g     F .text	000003fc vSimMebTask
8110a98c g     F .text	00000094 i2c_start
81148c98 g       .text	00000000 OSIntCtxSw
8111b5fc g     F .text	00000054 vFailSendMsgSync
8110cef4 g     F .text	00000074 bSyncCtrCh4OutEnable
81147c84 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811344ec g     F .text	00000028 alt_dcache_flush_all
8112abe8 g     F .text	00000068 __hi0bits
811142cc g     F .text	00000114 vPusType251run
81107510 g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111c5fc g     F .text	0000003c vChangeRTValue
81150da8 g     O .bss	00000004 is_sd_card_formated_as_FAT16
81115410 g     F .text	00000184 vCheck
8111b930 g     F .text	00000050 vNFeeNotInUse
8111f018 g     F .text	00000080 .hidden __fixdfsi
811118fc g     F .text	000000c8 bSendCmdQToNFeeInst_Prio
81105e58 g     F .text	000000d4 bFeebCh8SetBufferSize
811068e4 g     F .text	00000088 bFeebStopCh
8110d4e4 g     F .text	00000084 uliPerCalcPeriodMs
81111220 g     F .text	00000424 vNFeeControlTask
8115a748 g     O .bss	00001000 vInitialTask_stk
81150ca0 g     O .bss	00000002 usiIdCMD
8115b748 g     O .bss	00000020 SyncTBL3
8110cbd4 g     F .text	00000054 bSyncCtrStart
81142558 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112d7a0 g     F .text	00000018 strtod
8110696c g     F .text	00000088 bFeebClrCh
81150d64 g     O .bss	00000004 OSTCBFreeList
81107278 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113cd2c g     F .text	00000174 OSSemPendAbort
81119e60 g     F .text	0000004c vFailGetMacRTC
81107470 g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111a6d8 g     F .text	0000004c vFailCreateTimerRetransmisison
8111a1e4 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
81116c90 g     F .text	000002f0 bSendUART128v2
8111c430 g     F .text	000000ec vSimucamStructureInit
81150b38 g     O .rwdata	00000008 alt_dev_list
8111f628 g     F .text	0000004c _fputc_r
81135e94 g     F .text	0000010c write
81120a08 g     F .text	000000a8 _putc_r
81150dcc g     O .bss	00000004 device_pointer
81150bc0 g     O .rwdata	00000002 OSVersionNbr
81132d4c g     F .text	000000bc .hidden __gtsf2
8111b820 g     F .text	0000004c vFailFlushMEBQueue
81112aac g     F .text	00000118 getPreParsedPacket
8110f970 g     F .text	00000060 bEnableSPWChannel
8113458c g     F .text	000000b8 fstat
8111c27c g     F .text	00000040 vChangeIdNFEEMaster
8111f5fc g     F .text	0000002c fprintf
8111c05c g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105784 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
8111a824 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111cfd0 g     F .text	00000058 _reg_write
8111c2bc g     F .text	00000034 vChangeDefaultIdNFEEMaster
811340fc g     F .text	000000f4 .hidden __ledf2
81106da0 g     F .text	00000040 vRmapCh5HandleIrq
8110f864 g     F .text	00000054 bDisableRmapIRQ
8115b768 g     O .bss	00001000 vStackMonitor_stk
8111ab64 g     F .text	00000068 vCouldNotSendLog
8113f300 g     F .text	000001b8 OSTmrRemainGet
81150b68 g     O .rwdata	00000004 OSEndiannessTest
8110c008 g     F .text	00000058 v_spi_start
8112af44 g     F .text	00000148 __pow5mult
811073d0 g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112f8c0 g     F .text	00001464 ___vfiprintf_internal_r
81150cf8 g     O .bss	00000004 __nlocale_changed
81132c7c g     F .text	00000058 .hidden __umodsi3
8110cd24 g     F .text	00000074 bSyncCtrSyncOutEnable
8111ca70 g     F .text	000000f8 bInitializeSDCard
8111a5f4 g     F .text	0000004c vFailParserCommTaskCreate
8111aafc g     F .text	00000068 vCouldNotSendReset
81120ef4 g     F .text	00000038 _scanf_r
8111a68c g     F .text	0000004c vFailOutAckHandlerTaskCreate
81150b7a g     O .rwdata	00000002 OSFlagGrpSize
81113eb0 g     F .text	0000008c vPusType250conf
8115c768 g     O .bss	00000058 xInUseRetrans
8110c68c g     F .text	00000050 bSyncIrqFlagSync
811472f0 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113f4b8 g     F .text	000000ec OSTmrStateGet
8116ae54 g       *ABS*	00000000 end
811052a8 g     F .text	00000084 vFeebCh6HandleIrq
81116910 g     F .text	00000260 vPrintMemmoryPattern
8111a384 g     F .text	00000068 vNoContentInPreParsedBuffer
8111fb44 g     F .text	0000001c fseeko
81112bc4 g     F .text	00000168 bSendMessagePUStoMebTask
8111ad24 g     F .text	00000070 vFailCreateNFEEQueue
8111f4ac g     F .text	0000000c _atoi_r
81145dd0 g     F .text	00000240 altera_avalon_uart_write
811348f0 g     F .text	00000054 alt_log_txchar
8111f6dc g     F .text	0000001c fseek
81116c00 g     F .text	00000090 vCCDChangeValues
811446c4 g     F .text	000001d0 altera_avalon_jtag_uart_init
81137ef8 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81119ac0 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
811453d8 g     F .text	00000084 alt_avalon_timer_sc_init
8110672c g     F .text	000000a8 bFeebSetWindowing
811454c4 g     F .text	00000068 altera_avalon_uart_write_fd
8111f43c g     F .text	00000064 .hidden __clzsi2
8114552c g     F .text	00000058 altera_avalon_uart_close_fd
8115c7c0 g     O .bss	00000020 xMebQTBL
81145088 g     F .text	000002cc altera_avalon_jtag_uart_write
8113fa2c g     F .text	00000174 OSTmr_Init
8115c7e0 g     O .bss	00000348 xBuffer128
81129484 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
8112a69c g     F .text	000000e4 memchr
81137b9c g     F .text	0000005c OS_MemClr
811236b8 g     F .text	00002200 ___vfprintf_internal_r
81148d78 g     F .text	00000164 OSTaskStkInit
81120f2c g     F .text	00000060 _sprintf_r
81108044 g     F .text	000002d4 bRmapGetMemConfigArea
81150ca2 g     O .bss	00000001 SemCount32
8112990c g     F .text	00000318 _free_r
811489f4 g     F .text	00000234 alt_printf
81117bd0 g     F .text	00000050 vTimeoutCheck
8111d080 g     F .text	000001fc _print_codec_status
8112a39c g     F .text	00000010 __locale_mb_cur_max
811371ac g     F .text	000001a0 OS_EventTaskRdy
811078ac g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
811492cc g     F .text	00000188 __call_exitprocs
8111170c g     F .text	00000128 vPerformActionNFCRunning
81150d68 g     O .bss	00000001 OSCPUUsage
8111afa4 g     F .text	00000068 vCoudlNotCreateNFee4Task
81150cf4 g     O .bss	00000004 __mlocale_changed
81111644 g     F .text	000000c8 vPerformActionNFCConfig
8110cc7c g     F .text	00000054 bSyncCtrOneShot
81150b1c g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110d3f4 g     F .text	0000003c uliSyncReadStatus
81150d20 g     O .bss	00000004 _alt_tick_rate
8113bc20 g     F .text	00000294 OSQPend
8112d8c0 g     F .text	000002e8 _strtoll_r
8115cb28 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
811646f0 g     O .bss	00000030 xDefaults
8113e9a4 g     F .text	0000010c OSTimeDly
81114194 g     F .text	000000ac vPusMebInTaskRunningMode
8110c650 g     F .text	0000003c vSyncIrqFlagClrSync
8112b08c g     F .text	00000150 __lshift
811119c4 g     F .text	000002f8 vOutAckHandlerTask
81146d48 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
81150d24 g     O .bss	00000004 _alt_nticks
811358f4 g     F .text	00000104 read
81140080 g     F .text	000000f0 alt_sys_init
8111dcf4 g     F .text	0000012c .hidden __floatsisf
81106ee4 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112e0f8 g     F .text	000001d8 __ssprint_r
81120924 g     F .text	00000068 _open_r
8111cf48 g     F .text	00000088 bTestSimucamCriticalHW
811062b0 g     F .text	0000010c bFeebGetBuffersStatus
81119778 g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
81150d69 g     O .bss	00000001 OSTaskCtr
811348bc g       .text	00000000 tx_log_str
81113ca8 g     F .text	0000015c vPusMebTask
81117b80 g     F .text	00000050 siPosStr
811147f0 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
81131d90 g     F .text	000000d0 strncmp
8110d430 g     F .text	0000005c bSyncWriteReg
81107220 g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113eab0 g     F .text	00000164 OSTimeDlyHMSM
8112ad44 g     F .text	00000200 __multiply
81144c5c g     F .text	00000070 altera_avalon_jtag_uart_close
8110c1d8 g     F .text	00000058 v_spi_end
8111cbe4 g     F .text	00000040 cGetNextChar
811491e0 g     F .text	000000ec strncpy
81150f20 g     O .bss	00000028 __malloc_current_mallinfo
81150b6e g     O .rwdata	00000002 OSEventMax
81132cd4 g     F .text	00000078 .hidden __eqsf2
8112b5b8 g     F .text	00000154 __d2b
8113cea0 g     F .text	00000118 OSSemPost
81105478 g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111c638 g     F .text	00000030 vChangeDefaultRTValue
8110536c g     F .text	00000040 vFeebCh8HandleIrq
81150da4 g     O .bss	00000004 initialized
81117a30 g     F .text	00000100 vSendLog
81136d20 g     F .text	000000e4 OSSchedUnlock
8110c230 g     F .text	00000164 RTCC_SPI_R_MAC
81150b4c g     O .rwdata	00000004 alt_log_boot_on_flag
81144540 g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112dba8 g     F .text	00000254 _strtoul_r
8115cb68 g     O .bss	00000020 xFeeQueueTBL5
811484f8 g     F .text	000000e4 alt_get_fd
81150d6c g     O .bss	00000004 OSMemFreeList
81136e7c g     F .text	000000b8 OSStatInit
8111cf14 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
8116a7ec g     O .bss	00000014 search_data
81109c74 g     F .text	00000134 bSpwcSetLink
811342a0 g     F .text	00000130 alt_busy_sleep
8113983c g     F .text	000000cc OSFlagQuery
8110cd98 g     F .text	00000074 bSyncCtrCh1OutEnable
81150ba4 g     O .rwdata	00000002 OSTaskCreateExtEn
8111d27c g     F .text	00000074 _split_codec_status
81127560 g     F .text	0000005c _close_r
8111a3ec g     F .text	00000068 vCouldNotSendEthConfUART
81110c9c g     F .text	00000584 vInitialTask
81135064 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
81147230 g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81149164 g     F .text	0000007c memcmp
81137184 g     F .text	00000028 OS_Dummy
81144610 g     F .text	00000058 altera_avalon_jtag_uart_close_fd
8116ae54 g       *ABS*	00000000 __alt_stack_base
81105d84 g     F .text	000000d4 bFeebCh7SetBufferSize
81144668 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
811054bc g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111fbc4 g     F .text	000000d4 _fwrite_r
81114b24 g     F .text	000000a4 vReleaseSyncMessages
81147350 g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
811055cc g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81127404 g     F .text	0000015c __swsetup_r
81166d88 g     O .bss	00000300 OSQTbl
8111b3dc g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
81164720 g     O .bss	0000001c xConfEth
81133784 g     F .text	000008f0 .hidden __divdf3
8111c69c g     F .text	0000003c vChangeSyncSource
8112933c g     F .text	00000120 __sfp
8116a800 g     O .bss	00000054 boot_sector_data
8111b374 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
8110a0e0 g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
8112b834 g     F .text	00000078 __copybits
8114f210 g     O .rwdata	00000408 __malloc_av_
81129490 g     F .text	00000004 __sinit_lock_release
81150be0 g     O .bss	00000004 uliInitialState
8110aa20 g     F .text	00000080 i2c_stop
8111d394 g     F .text	00000064 Verif_Error
8111d3f8 g     F .text	00000034 toInt
81119c0c g     F .text	0000004c vFailSendPreAckSenderSemaphore
81150d70 g     O .bss	00000004 OSTCBHighRdy
8111dff4 g     F .text	00000720 .hidden __muldf3
81121000 g     F .text	0000005c __sread
811297a4 g     F .text	0000003c fread
81150d74 g     O .bss	00000004 OSQFreeList
811483e8 g     F .text	00000110 alt_find_file
811482a4 g     F .text	000000ac alt_dev_llist_insert
811360d4 g     F .text	00000128 __malloc_lock
8111f5cc g     F .text	00000030 _fprintf_r
81135a64 g     F .text	000000fc sbrk
8111bee8 g     F .text	0000002c vFeeSpwRMAPLoadDefault
8111a17c g     F .text	00000068 vFailGetCountSemaphorexBuffer64
811214d8 g     F .text	000021e0 ___svfprintf_internal_r
81117f70 g     F .text	00000088 vTMPusTestConnection
81150ca4 g     O .bss	00000004 xMebQ
811363f8 g     F .text	00000148 OSEventNameSet
81129078 g     F .text	00000064 _fflush_r
81130e04 g     F .text	000000cc _calloc_r
81150d78 g     O .bss	00000001 OSRdyGrp
8111b6f0 g     F .text	0000004c vFailSendMsgFeeCTRL
8110c7c8 g     F .text	00000044 ucSyncStatusCycleNumber
81107a0c g     F .text	0000008c bRmapGetCodecConfig
8113f5a4 g     F .text	00000148 OSTmrStart
81105224 g     F .text	00000084 vFeebCh5HandleIrq
8111f5b4 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
81150be0 g       *ABS*	00000000 __bss_start
81105b08 g     F .text	000000d4 bFeebCh4SetBufferSize
811207fc g     F .text	00000128 memset
81112f7c g     F .text	0000013c setPreParsedFreePos
8110eac8 g     F .text	000001fc vQCmdFEEinStandBy
81147dac g     F .text	00000060 alt_msgdma_open
8111c7f4 g     F .text	0000021c pattern_createPattern
811164f0 g     F .text	000001c0 main
81119d90 g     F .text	00000068 vFailGetMutexReceiverTask
8115cb88 g     O .bss	00001000 vNFeeControlTask_stk
8110707c g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111c554 g     F .text	0000003c vChangeEPValue
811071c8 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
81150d1c g     O .bss	00000004 alt_envp
8111b788 g     F .text	0000004c vFailFlushQueue
81150ce4 g     O .bss	00000004 __malloc_max_total_mem
81147650 g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
8111981c g     F .text	0000005c ucCrc8wInit
8111a724 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
811445a8 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110abd8 g     F .text	00000160 i2c_read
8115db88 g     O .bss	00000020 SyncTBL5
81127384 g     F .text	00000018 __swbuf
8114e944 g     O .rodata	00000100 OSUnMapTbl
81132e08 g     F .text	000000c8 .hidden __ltsf2
81143944 g     F .text	00000090 alt_up_sd_card_get_attributes
81129570 g     F .text	00000234 _fread_r
81119c58 g     F .text	00000068 vFailGetCountSemaphoreSenderTask
8110a3cc g     F .text	0000003c bDisableIsoDrivers
81150b9e g     O .rwdata	00000002 OSSemEn
81140170 g     F .text	000000bc Write_Sector_Data
81143d54 g     F .text	00000628 alt_up_sd_card_write
81150ca8 g     O .bss	00000004 xFeeQ
81106514 g     F .text	00000068 bFeebGetCh1RightBufferEmpty
811394a0 g     F .text	0000039c OSFlagPost
8112114c g     F .text	00000008 __sclose
8111aa2c g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
81130fc8 g     F .text	00000014 fclose
8113734c g     F .text	00000118 OS_EventTaskWait
8111a8f4 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8112127c g     F .text	00000240 _strtol_r
8111f294 g     F .text	000001a8 .hidden __truncdfsf2
8115dba8 g     O .bss	00000020 xFeeQueueTBL2
81137fdc g     F .text	000000d4 OS_TaskStatStkChk
8113ddbc g     F .text	00000158 OSTaskDelReq
81104b70 g     F .text	000000c4 bDpktGetPacketHeader
81106c1c g     F .text	000000c4 vRmapCh1HandleIrq
811277c4 g     F .text	00001690 _dtoa_r
8114796c g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111fe98 g     F .text	00000814 _malloc_r
8115dbc8 g     O .bss	00000020 SyncTBL0
81131fcc g     F .text	00000030 __ascii_wctomb
8113a638 g     F .text	000001d0 OSMutexCreate
8111a88c g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
81110b50 g     F .text	0000014c bCheckInAck32
81150b44 g     O .rwdata	00000004 alt_errno
81147498 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81136e04 g     F .text	00000078 OSStart
81109da8 g     F .text	000000e4 bSpwcGetLink
8110b92c g     F .text	000004e8 POWER_SPI_RW
8112f514 g     F .text	000000dc __submore
81134fc4 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
8113606c g     F .text	00000068 __env_unlock
8111ae6c g     F .text	00000068 vCoudlNotCreateNFee1Task
8112a0e8 g     F .text	000000cc _fwalk
8113e270 g     F .text	000001dc OSTaskResume
8113a2c8 g     F .text	000000f0 OSMemQuery
81150bb0 g     O .rwdata	00000002 OSTaskStatEn
8116ae54 g       *ABS*	00000000 __alt_stack_limit
81150bf0 g     O .bss	00000004 ECommSpwCh
8111c740 g     F .text	0000003c vChangeAutoResetSync
8112a638 g     F .text	00000064 _mbtowc_r
8111056c g     F .text	00000350 vInAckHandlerTaskV2
81150b8a g     O .rwdata	00000002 OSMemMax
8113c198 g     F .text	00000178 OSQPostFront
81120ab0 g     F .text	000000d0 putc
81132b20 g     F .text	00000084 .hidden __divsi3
81150d79 g     O .bss	00000006 OSRdyTbl
81150b64 g     O .rwdata	00000002 OSDebugEn
8114f8a8 g     O .rwdata	0000002a alt_log_msg_cache
811297e0 g     F .text	0000012c _malloc_trim_r
811097c4 g     F .text	000001a4 bRmapInitCh
81150cd8 g     O .bss	00000008 xSdHandle
8111d8f0 g     F .text	00000404 .hidden __mulsf3
81150b7c g     O .rwdata	00000002 OSFlagNodeSize
81150be4 g     O .bss	00000004 pnt_memory
8111c7ac g     F .text	00000048 vSyncReset
8110c88c g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
81150db0 g     O .bss	00000004 status_register
81150bc4 g     O .rwdata	00000002 OSTmrCfgMax
8110d220 g     F .text	00000074 bSyncIrqFlagClrError
8111a4bc g     F .text	00000068 vFailSetPreAckSenderBuffer
8112c058 g     F .text	000000dc strcmp
81150db8 g     O .bss	00000004 command_register
8113b724 g     F .text	000001b4 OSQCreate
8113df14 g     F .text	000001a0 OSTaskNameGet
8115dbe8 g     O .bss	00001000 vFeeTask4_stk
8115ebe8 g     O .bss	00000018 xReceivedACK
8113c310 g     F .text	00000214 OSQPostOpt
81136f34 g     F .text	00000228 OSTimeTick
81150bac g     O .rwdata	00000002 OSTaskMax
8113c7f0 g     F .text	000000e0 OSSemCreate
81150bd0 g     O .rwdata	00000002 OSTmrWheelSize
8111acbc g     F .text	00000068 vFailCreateScheduleQueue
8111d028 g     F .text	00000058 _reg_read
8113b2d0 g     F .text	00000174 OSMutexQuery
8110fb60 g     F .text	000000a4 bSendGiveBackNFeeCtrl
81134074 g     F .text	00000088 .hidden __nedf2
81150ba6 g     O .rwdata	00000002 OSTaskDelEn
8111c51c g     F .text	00000038 vLoadDefaultEPValue
8115ec00 g     O .bss	00001000 vFeeTask1_stk
8110d050 g     F .text	00000074 bSyncCtrCh7OutEnable
8113cfb8 g     F .text	00000118 OSSemQuery
8113b8d8 g     F .text	00000288 OSQDel
8113beb4 g     F .text	00000174 OSQPendAbort
81150cac g     O .bss	00000004 xMutexPreParsed
81140040 g     F .text	00000040 alt_irq_init
811359f8 g     F .text	0000006c alt_release_fd
81140360 g     F .text	000000bc get_cluster_flag
8110d294 g     F .text	00000074 bSyncIrqFlagClrBlank
811480a4 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110c5d8 g     F .text	0000002c vSyncClearCounter
8114f874 g     O .rwdata	00000031 alt_log_msg_stackpointer
81120f8c g     F .text	00000074 sprintf
8114e02c g     O .rodata	00000100 .hidden __clz_tab
81140934 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
81119df8 g     F .text	00000068 vFailGetMutexTxUARTSenderTask
81150cf0 g     O .bss	00000004 _PathLocale
8110d360 g     F .text	00000058 bSyncIrqFlagBlank
8110b7e4 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113f6ec g     F .text	000001e8 OSTmrStop
811099bc g     F .text	00000050 uliRmapReadReg
81117b30 g     F .text	00000050 usiGetIdCMD
8110d48c g     F .text	00000058 uliSyncReadReg
8112d7b8 g     F .text	00000108 strtof
8110511c g     F .text	00000084 vFeebCh3HandleIrq
81132d4c g     F .text	000000bc .hidden __gesf2
81121154 g     F .text	0000004c strcspn
8112739c g     F .text	00000068 _write_r
8110be80 g     F .text	00000074 vRstcReleaseDeviceReset
8111a640 g     F .text	0000004c vFailInAckHandlerTaskCreate
81136c8c g     F .text	00000094 OSSchedLock
8111af3c g     F .text	00000068 vCoudlNotCreateNFee3Task
8112a3cc g     F .text	00000018 setlocale
811473f8 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81167088 g     O .bss	00000800 OSTmrTaskStk
81120eb0 g     F .text	00000044 scanf
8111b1ac g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
81138894 g     F .text	00000110 OSFlagCreate
81140bc8 g     F .text	00000688 Check_for_DOS_FAT
81114a1c g     F .text	00000064 vMebInit
81142a74 g     F .text	000002d0 create_file
8112c050 g     F .text	00000008 nanf
81150b18 g     O .rwdata	00000004 _impure_ptr
81150db4 g     O .bss	00000004 CSD_register_w0
81150d14 g     O .bss	00000004 alt_argc
8111a114 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
81128e54 g     F .text	00000224 __sflush_r
8112a458 g     F .text	000000b4 _mbrtowc_r
8110a050 g     F .text	00000090 bSpwcGetTimecode
8112a3b8 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
81150bf4 g     O .bss	00000004 ESdmaBufferSide
81150b76 g     O .rwdata	00000002 OSEventMultiEn
8111f6d8 g     F .text	00000004 _fseek_r
8115fc00 g     O .bss	00001800 vParserCommTask_stk
81119958 g     F .text	00000070 printErrorTask
8111c590 g     F .text	00000030 vChangeDefaultEPValue
81115aa4 g     F .text	000002c8 vCheckRetransmission32
8113eebc g     F .text	000001c4 OSTmrCreate
81114bc8 g     F .text	000007dc vStackMonitor
81120c78 g     F .text	000001dc __srefill_r
8110a408 g     F .text	0000003c bEnableLvdsBoard
81150cb0 g     O .bss	00000004 xMutexBuffer32
81106ce0 g     F .text	00000040 vRmapCh2HandleIrq
811389a4 g     F .text	00000250 OSFlagDel
81150d80 g     O .bss	00000004 OSEventFreeList
8110a480 g     F .text	000000c0 bSetPreEmphasys
8110e904 g     F .text	000001c4 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
8112a5ec g     F .text	0000004c __ascii_mbtowc
8110cb5c g     F .text	00000078 bSyncCtrExtnIrq
8110657c g     F .text	00000068 bFeebGetCh2LeftBufferEmpty
8112b440 g     F .text	00000064 __ulp
8111c0c8 g     F .text	0000010c vNFeeControlInit
81114a80 g     F .text	000000a4 vSwapMemmory
81138e78 g     F .text	000005c0 OSFlagPend
81150bc2 g     O .rwdata	00000002 OSTmrEn
811294ac g     F .text	00000018 __fp_unlock_all
81161400 g     O .bss	00000010 xDma
8111f674 g     F .text	00000064 fputc
8110f8b8 g     F .text	00000058 bEnableRmapIRQ
81117278 g     F .text	000002f8 bSendUART32v2
81113234 g     F .text	0000019c setPreAckReceiverFreePos
8110cb1c g     F .text	00000040 bSyncErrInj
81150b30 g     O .rwdata	00000008 alt_fs_list
81161410 g     O .bss	00001000 vSimMebTask_stk
8111b144 g     F .text	00000068 vCoudlNotCreateMebTask
81141410 g     F .text	00000274 check_file_name_for_FAT16_compliance
81162410 g     O .bss	00001000 vFeeTask3_stk
8113f1c0 g     F .text	00000140 OSTmrNameGet
81151048 g     O .bss	00000400 xSZData
8110ecc4 g     F .text	00000230 vQCmdFEEinFullPattern
81137dbc g     F .text	0000007c OS_StrCopy
81150dc0 g     O .bss	00000004 buffer_memory
8111a31c g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111c398 g     F .text	00000098 vLogWriteNUC
81150b8c g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110d1ac g     F .text	00000074 bSyncIrqEnableBlank
81149004 g     F .text	00000028 OSInitHookEnd
8111baf8 g     F .text	00000340 vUpdateMemMapFEE
8111a58c g     F .text	00000068 vFailSetPreAckReceiverBuffer
81105834 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
81150bb8 g     O .rwdata	00000002 OSTCBPrioTblMax
8112a3e4 g     F .text	0000000c localeconv
8111b0dc g     F .text	00000068 vCoudlNotCreateDataControllerTask
81150cb4 g     O .bss	00000004 xTimerRetransmission
81112d2c g     F .text	00000250 vReceiverUartTask
81150d10 g     O .bss	00000004 alt_log_sys_clk_count
81150bb4 g     O .rwdata	00000002 OSTaskStatStkChkEn
81135214 g     F .text	00000140 alt_log_write
81163410 g     O .bss	00001000 vFeeTask2_stk
81150cb8 g     O .bss	00000004 xMutexBuffer128
81105058 g     F .text	00000040 vFeebCh1HandleIrq
8111cea8 g     F .text	0000003c bStartSync
8110532c g     F .text	00000040 vFeebCh7HandleIrq
8111cee4 g     F .text	00000030 bStopSync
81150bf8 g     O .bss	00000004 ECommBufferSide
811485dc g     F .text	00000058 alt_ic_isr_register
81150b88 g     O .rwdata	00000002 OSMemEn
81106d20 g     F .text	00000040 vRmapCh3HandleIrq
81150b04 g     O .rwdata	00000004 alt_stack_limit_value
811143e0 g     F .text	00000388 vPusType252run
8111b6a4 g     F .text	0000004c vFailSendMsgMasterSyncMeb
8111fc98 g     F .text	0000003c fwrite
81150dc4 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
81150b92 g     O .rwdata	00000002 OSMutexEn
8111b444 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
81150be0 g       *ABS*	00000000 _edata
8114545c g     F .text	00000068 altera_avalon_uart_read_fd
8111c248 g     F .text	00000034 vLoadDefaultIdNFEEMaster
8116ae54 g       *ABS*	00000000 _end
8116a854 g     O .bss	00000500 active_files
81150d84 g     O .bss	00000001 OSIntNesting
81119eac g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
8111bfc4 g     F .text	0000002c cFeeRMAPDump
81105a34 g     F .text	000000d4 bFeebCh3SetBufferSize
81150cbc g     O .bss	00000004 xSemCountBuffer32
81130fdc g     F .text	0000016c __fputwc
81150cc0 g     O .bss	00000004 xQMaskFeeCtrl
8111bf14 g     F .text	0000002c vFeeSpwRMAPChangeConfig
8112715c g     F .text	00000070 vfscanf
81142d44 g     F .text	00000150 copy_file_record_name_to_string
81144ccc g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113ec14 g     F .text	000001dc OSTimeDlyResume
81141250 g     F .text	000000f4 Look_for_FAT16
8110f910 g     F .text	00000060 bDisableSPWChannel
81138d24 g     F .text	00000154 OSFlagNameSet
8110fa58 g     F .text	00000064 bDisAndClrDbBuffer
81150cc4 g     O .bss	00000004 xMutexBuffer64
81107bf8 g     F .text	00000160 bRmapGetCodecError
8113e44c g     F .text	000001c8 OSTaskStkChk
811486c4 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	00000488 bSdmaDmaM1Transfer
81150b8e g     O .rwdata	00000002 OSMemSize
81113f90 g     F .text	00000204 vPusType252conf
81119fdc g     F .text	00000068 vFailSetCountSemaphorexBuffer32
81121064 g     F .text	00000084 __swrite
81150b20 g     O .rwdata	00000004 __malloc_trim_threshold
8112a3ac g     F .text	0000000c __locale_msgcharset
81164410 g     O .bss	00000020 xFeeQueueTBL1
81150d88 g     O .bss	00000004 OSTCBCur
8111a95c g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110b8e8 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81149124 g     F .text	00000040 exit
8113b0b0 g     F .text	00000220 OSMutexPost
8110d308 g     F .text	00000058 bSyncIrqFlagError
81143170 g     F .text	000003c0 alt_up_sd_card_find_next
81150b90 g     O .rwdata	00000002 OSMemTblSize
8112a1b4 g     F .text	000000cc _fwalk_reent
811477f0 g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111de20 g     F .text	000000f8 .hidden __floatunsisf
8112b23c g     F .text	00000204 __mdiff
8111ae04 g     F .text	00000068 vCoudlNotCreateNFee0Task
81105f2c g     F .text	0000017c vFeebInitIrq
81104818 g     F .text	0000022c bDpktSetPacketConfig
81119f44 g     F .text	0000004c vFailSenderCreate
81132ba4 g     F .text	00000074 .hidden __modsi3
8111b00c g     F .text	00000068 vCoudlNotCreateNFee5Task
8110ca68 g     F .text	0000003c uliSyncGetPer
81106de0 g     F .text	00000040 vRmapCh6HandleIrq
81150cc8 g     O .bss	00000004 xMutexSenderACK
8111a7bc g     F .text	00000068 vFailGetBlockingSemTimeoutTask
81150b10 g     O .rwdata	00000004 __ctype_ptr__
8111a524 g     F .text	00000068 vFailSetPreParsedBuffer
81140280 g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
81129488 g     F .text	00000004 __sfp_lock_release
8110617c g     F .text	000000ac bFeebGetIrqControl
8111aa94 g     F .text	00000068 vCouldNotSendTurnOff
81136ad4 g     F .text	00000064 OSInit
8110adb8 g     F .text	00000078 bSetPainelLeds
81146f38 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
81150d8c g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107d58 g     F .text	000002ec bRmapSetMemConfigArea
8113e800 g     F .text	0000012c OSTaskQuery
8110d138 g     F .text	00000074 bSyncIrqEnableError
81150ccc g     O .bss	00000004 xMutexPus
8113c688 g     F .text	000000b0 OS_QInit
8112bf80 g     F .text	000000d0 __sccl
8111f4a0 g     F .text	0000000c atoi
8110d608 g     F .text	00001114 vFeeTask
81137e38 g     F .text	0000005c OS_StrLen
8111b86c g     F .text	0000004c vFailFlushNFEEQueue
81105624 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
81119878 g     F .text	000000e0 vDataControllerInit
8113a0cc g     F .text	0000011c OSMemNameSet
8114e12c g     O .rodata	00000101 _ctype_
8110ca2c g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
8111a0ac g     F .text	00000068 vFailSetCountSemaphorexBuffer128
81150baa g     O .rwdata	00000002 OSTaskProfileEn
8111b8b8 g     F .text	00000028 vEvtChangeMebMode
81146e08 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
81150cd0 g     O .bss	00000004 xTxUARTMutex
81150d90 g     O .bss	00000004 OSTime
81150b28 g     O .rwdata	00000004 __mbtowc
81145a7c g     F .text	0000005c altera_avalon_uart_close
8110e71c g     F .text	000001e8 vQCmdFEEinWaitingSync
81150d94 g     O .bss	00000004 OSTmrSem
81113f3c g     F .text	00000054 vPusType251conf
81167888 g     O .bss	00001000 OSTaskIdleStk
8111f4b8 g     F .text	000000fc _fopen_r
81150c6c g     O .bss	00000004 pdata
81149454 g     F .text	000000bc _exit
811063bc g     F .text	00000078 bFeebGetLeftBufferEmpty
8114812c g     F .text	00000134 alt_alarm_start
81138bf4 g     F .text	00000130 OSFlagNameGet
8113edf0 g     F .text	00000064 OSTimeGet
81150bfc g     O .bss	00000004 ESdmaChBufferId
811439d4 g     F .text	00000380 alt_up_sd_card_read
81106fb0 g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111fcd4 g     F .text	000001c4 __smakebuf_r
81150cd4 g     O .bss	00000001 SemCount64
81116f80 g     F .text	000002f8 bSendUART64v2
8111b7d4 g     F .text	0000004c vFailFlushQueueData
811056d4 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
81150bd8 g     O .rwdata	00000008 alt_msgdma_list
811211a0 g     F .text	00000098 strlen
8110c124 g     F .text	000000b4 uc_spi_get_byte
81106ff4 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
8111b4ac g     F .text	00000054 vFailSendMsgAccessDMA
81148f34 g     F .text	00000028 OSTaskSwHook
81135754 g     F .text	0000015c open
81108ff8 g     F .text	000007cc bRmapGetRmapMemHKArea
81168888 g     O .bss	00000d00 OSEventTbl
8111bf40 g     F .text	0000002c vFeeSpwRMAPChangeDefault
8111df18 g     F .text	000000dc .hidden __gedf2
8111b650 g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
81164430 g     O .bss	00000020 xSenderACK
81148c28 g     F .text	00000044 alt_putchar
81169588 g     O .bss	000011b8 OSTCBTbl
811312f4 g     F .text	00000838 __gethex
8113d0d0 g     F .text	00000108 OSSemSet
811153a4 g     F .text	0000006c vTimeoutCheckerTaskv2
8111bff0 g     F .text	00000038 cFeeRMAPEchoingEnable
81150b2c g     O .rwdata	00000004 __wctomb
811161dc g     F .text	00000314 vVariablesInitialization
8112f8a8 g     F .text	00000018 __sprint_r
8110f39c g     F .text	00000268 vQCmdFeeRMAPinFullPattern
81106228 g     F .text	00000088 bFeebGetIrqFlags
81150bec g     O .bss	00000004 pxDmaM2Dev
81119a74 g     F .text	0000004c vFailCreateSemaphoreResources
81150b48 g     O .rwdata	00000004 alt_priority_mask
8110a444 g     F .text	0000003c bDisableLvdsBoard
8113c8d0 g     F .text	00000248 OSSemDel
81105960 g     F .text	000000d4 bFeebCh2SetBufferSize
81150d98 g     O .bss	00000004 OSFlagFreeList
8110c060 g     F .text	000000c4 v_spi_send_byte
8110c394 g     F .text	000000d0 bSSDisplayConfig
81148634 g     F .text	00000090 alt_ic_irq_enable
81150b70 g     O .rwdata	00000002 OSEventNameSize
811258b8 g     F .text	0000001c __vfprintf_internal
81150d9c g     O .bss	00000001 OSStatRdy
8110ce0c g     F .text	00000074 bSyncCtrCh2OutEnable
8116a740 g     O .bss	000000ac OSTCBPrioTbl
81145b1c g     F .text	00000270 altera_avalon_uart_read
81131ffc g     F .text	00000064 _wctomb_r
81135fa0 g     F .text	000000cc __env_lock
81150bb6 g     O .rwdata	00000002 OSTaskSwHookEn
81105434 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
8111e714 g     F .text	00000904 .hidden __subdf3
81164450 g     O .bss	00000260 xPreParsed
8110caa4 g     F .text	0000003c uliSyncGetOst
81151560 g     O .bss	00000118 RmapConfAreaL
81150cd5 g     O .bss	00000001 SemCount128
81106e60 g     F .text	00000040 vRmapCh8HandleIrq
81105500 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81117570 g     F .text	00000290 vSendEthConf
81104698 g     F .text	000000dc bCommInitCh
8112ac50 g     F .text	000000b0 __lo0bits
81125998 g     F .text	000017c4 __svfscanf_r
81150b54 g     O .rwdata	00000008 alt_alarm_list
8112f5f0 g     F .text	0000019c _ungetc_r
81150b7e g     O .rwdata	00000002 OSFlagWidth
81106ea0 g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
81131f04 g     F .text	000000c8 wcrtomb
81104c34 g     F .text	00000148 bDpktSetPixelDelay
81116b70 g     F .text	00000090 vCCDLoadDefaultValues
81134414 g     F .text	000000d8 close
8110cae0 g     F .text	0000003c uliSyncGetGeneral
8111b908 g     F .text	00000028 vEvtChangeDataControllerMode
81150d2c g     O .bss	00000004 alt_envsem
81134944 g     F .text	00000068 alt_log_repchar
81150da0 g     O .bss	00000004 OSIdleCtrRun
8113715c g     F .text	00000028 OSVersion
81150bc8 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113e92c g     F .text	00000078 OS_TaskStkClr
8111cb68 g     F .text	0000003c siOpenFile
8110d568 g     F .text	000000a0 vDataControlTask
81150ba2 g     O .rwdata	00000002 OSTaskCreateEn
81107118 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81107560 g     F .text	00000050 uliRmapCh7WriteCmdAddress
8110685c g     F .text	00000088 bFeebStartCh
81117800 g     F .text	00000118 vSendTurnOff
81119b74 g     F .text	0000004c vFailSendPreParsedSemaphore
81141744 g     F .text	000002a4 match_file_record_to_name_ext
81137784 g     F .text	00000070 OS_EventWaitListInit
8113116c g     F .text	00000088 fputwc
811646b0 g     O .bss	00000020 xFeeQueueTBL0
81119b0c g     F .text	00000068 vFailSendxSemCommInit
8114902c g     F .text	00000028 OSTaskIdleHook
81117918 g     F .text	00000118 vSendReset
8112948c g     F .text	00000004 __sinit_lock_acquire
8112a9b4 g     F .text	00000128 __multadd
811646d0 g     O .bss	00000020 SyncTBL1
81105544 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110c730 g     F .text	0000004c ucSyncStatusState
8113e614 g     F .text	000001ec OSTaskSuspend
8112a98c g     F .text	00000028 _Bfree
8110c9f0 g     F .text	0000003c uliSyncGetMbt
81137e94 g     F .text	00000064 OS_TaskIdle
81150bce g     O .rwdata	00000002 OSTmrTblSize
8113c524 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1136b380 	call	81136b38 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10ab5504 	addi	r2,r2,-21164
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10ab5504 	addi	r2,r2,-21164
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1136b8c0 	call	81136b8c <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b617 	ldw	r2,-32040(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b617 	ldw	r2,-32040(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	2102d304 	addi	r4,r4,2892
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	213e2a04 	addi	r4,r4,-1880
81100274:	11348bc0 	call	811348bc <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	2102d304 	addi	r4,r4,2892
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	213e1d04 	addi	r4,r4,-1932
81100290:	11348bc0 	call	811348bc <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d6a2c114 	ori	gp,gp,35588
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	2102d304 	addi	r4,r4,2892
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	213e0e04 	addi	r4,r4,-1992
811002bc:	11348bc0 	call	811348bc <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04574 	movhi	r2,33045
    ori r2, r2, %lo(__bss_start)
811002c4:	1082f814 	ori	r2,r2,3040

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18eb9514 	ori	r3,r3,44628

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	2102d304 	addi	r4,r4,2892
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	213e1504 	addi	r4,r4,-1964
811002fc:	11348bc0 	call	811348bc <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11354e80 	call	811354e8 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18c3d204 	addi	r3,r3,3912
81100330:	00a04574 	movhi	r2,33045
81100334:	10a54404 	addi	r2,r2,-27376
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a06117 	ldw	r2,-32380(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	2943d204 	addi	r5,r5,3912
8110035c:	1009883a 	mov	r4,r2
81100360:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18c3d204 	addi	r3,r3,3912
811003cc:	00a04574 	movhi	r2,33045
811003d0:	10a54d04 	addi	r2,r2,-27340
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a06117 	ldw	r2,-32380(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	2943d204 	addi	r5,r5,3912
811003f8:	1009883a 	mov	r4,r2
811003fc:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18c3d204 	addi	r3,r3,3912
81100410:	00a04574 	movhi	r2,33045
81100414:	10a55904 	addi	r2,r2,-27292
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a06117 	ldw	r2,-32380(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	2943d204 	addi	r5,r5,3912
8110043c:	1009883a 	mov	r4,r2
81100440:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1135d140 	call	81135d14 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	110a7240 	call	8110a724 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604574 	movhi	r5,33045
811004b0:	29655f04 	addi	r5,r5,-27268
811004b4:	01204574 	movhi	r4,33045
811004b8:	2103d204 	addi	r4,r4,3912
811004bc:	1120f8c0 	call	81120f8c <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a06117 	ldw	r2,-32380(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	2943d204 	addi	r5,r5,3912
811004cc:	1009883a 	mov	r4,r2
811004d0:	111f5fc0 	call	8111f5fc <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18c3d204 	addi	r3,r3,3912
811004e0:	00a04574 	movhi	r2,33045
811004e4:	10a56404 	addi	r2,r2,-27248
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	11206ac0 	call	811206ac <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a06117 	ldw	r2,-32380(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	2943d204 	addi	r5,r5,3912
8110050c:	1009883a 	mov	r4,r2
81100510:	111f5fc0 	call	8111f5fc <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18c3d204 	addi	r3,r3,3912
81100544:	00a04574 	movhi	r2,33045
81100548:	10a56a04 	addi	r2,r2,-27224
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a06117 	ldw	r2,-32380(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	2943d204 	addi	r5,r5,3912
81100570:	1009883a 	mov	r4,r2
81100574:	111f5fc0 	call	8111f5fc <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18c3d204 	addi	r3,r3,3912
81100584:	00a04574 	movhi	r2,33045
81100588:	10a57304 	addi	r2,r2,-27188
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a06117 	ldw	r2,-32380(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	2943d204 	addi	r5,r5,3912
811005b0:	1009883a 	mov	r4,r2
811005b4:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18c3d204 	addi	r3,r3,3912
811005c0:	00a04574 	movhi	r2,33045
811005c4:	10a57b04 	addi	r2,r2,-27156
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a06117 	ldw	r2,-32380(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	2943d204 	addi	r5,r5,3912
811005ec:	1009883a 	mov	r4,r2
811005f0:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1135d140 	call	81135d14 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	110a6440 	call	8110a644 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18c3d204 	addi	r3,r3,3912
81100650:	00a04574 	movhi	r2,33045
81100654:	10a58104 	addi	r2,r2,-27132
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a06117 	ldw	r2,-32380(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	2943d204 	addi	r5,r5,3912
8110067c:	1009883a 	mov	r4,r2
81100680:	111f5fc0 	call	8111f5fc <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	110a7240 	call	8110a724 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18c3d204 	addi	r3,r3,3912
811006cc:	00a04574 	movhi	r2,33045
811006d0:	10a58704 	addi	r2,r2,-27108
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	11206ac0 	call	811206ac <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a06117 	ldw	r2,-32380(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	2943d204 	addi	r5,r5,3912
811006f8:	1009883a 	mov	r4,r2
811006fc:	111f5fc0 	call	8111f5fc <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604574 	movhi	r5,33045
81100730:	29659004 	addi	r5,r5,-27072
81100734:	01204574 	movhi	r4,33045
81100738:	2103d204 	addi	r4,r4,3912
8110073c:	1120f8c0 	call	81120f8c <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a06117 	ldw	r2,-32380(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	2943d204 	addi	r5,r5,3912
8110074c:	1009883a 	mov	r4,r2
81100750:	111f5fc0 	call	8111f5fc <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18c3d204 	addi	r3,r3,3912
81100764:	00a04574 	movhi	r2,33045
81100768:	10a59f04 	addi	r2,r2,-27012
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a06117 	ldw	r2,-32380(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	2943d204 	addi	r5,r5,3912
81100790:	1009883a 	mov	r4,r2
81100794:	111f5fc0 	call	8111f5fc <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18c3d204 	addi	r3,r3,3912
811007a4:	00a04574 	movhi	r2,33045
811007a8:	10a5a804 	addi	r2,r2,-26976
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a06117 	ldw	r2,-32380(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	2943d204 	addi	r5,r5,3912
811007d0:	1009883a 	mov	r4,r2
811007d4:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	1083d204 	addi	r2,r2,3912
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a06117 	ldw	r2,-32380(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	2943d204 	addi	r5,r5,3912
811007f8:	1009883a 	mov	r4,r2
811007fc:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18c3d204 	addi	r3,r3,3912
81100840:	00a04574 	movhi	r2,33045
81100844:	10a5b004 	addi	r2,r2,-26944
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a06117 	ldw	r2,-32380(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	2943d204 	addi	r5,r5,3912
8110086c:	1009883a 	mov	r4,r2
81100870:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18c3d204 	addi	r3,r3,3912
811008dc:	00a04574 	movhi	r2,33045
811008e0:	10a5b904 	addi	r2,r2,-26908
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a06117 	ldw	r2,-32380(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	2943d204 	addi	r5,r5,3912
81100908:	1009883a 	mov	r4,r2
8110090c:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	110a82c0 	call	8110a82c <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604574 	movhi	r5,33045
81100984:	2965c504 	addi	r5,r5,-26860
81100988:	01204574 	movhi	r4,33045
8110098c:	2103d204 	addi	r4,r4,3912
81100990:	1120f8c0 	call	81120f8c <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a06117 	ldw	r2,-32380(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	2943d204 	addi	r5,r5,3912
811009a0:	1009883a 	mov	r4,r2
811009a4:	111f5fc0 	call	8111f5fc <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18c3d204 	addi	r3,r3,3912
811009c0:	00a04574 	movhi	r2,33045
811009c4:	10a5d104 	addi	r2,r2,-26812
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	11206ac0 	call	811206ac <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a06117 	ldw	r2,-32380(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	2943d204 	addi	r5,r5,3912
811009ec:	1009883a 	mov	r4,r2
811009f0:	111f5fc0 	call	8111f5fc <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18c3d204 	addi	r3,r3,3912
81100a0c:	00a04574 	movhi	r2,33045
81100a10:	10a5dd04 	addi	r2,r2,-26764
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a06117 	ldw	r2,-32380(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	2943d204 	addi	r5,r5,3912
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111f5fc0 	call	8111f5fc <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18c3d204 	addi	r3,r3,3912
81100a58:	00a04574 	movhi	r2,33045
81100a5c:	10a5e504 	addi	r2,r2,-26732
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	11206ac0 	call	811206ac <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a06117 	ldw	r2,-32380(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	2943d204 	addi	r5,r5,3912
81100a84:	1009883a 	mov	r4,r2
81100a88:	111f5fc0 	call	8111f5fc <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18c3d204 	addi	r3,r3,3912
81100aa4:	00a04574 	movhi	r2,33045
81100aa8:	10a5ef04 	addi	r2,r2,-26692
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	11206ac0 	call	811206ac <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a06117 	ldw	r2,-32380(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	2943d204 	addi	r5,r5,3912
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111f5fc0 	call	8111f5fc <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18c3d204 	addi	r3,r3,3912
81100af0:	00a04574 	movhi	r2,33045
81100af4:	10a5fa04 	addi	r2,r2,-26648
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	11206ac0 	call	811206ac <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a06117 	ldw	r2,-32380(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	2943d204 	addi	r5,r5,3912
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111f5fc0 	call	8111f5fc <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18c3d204 	addi	r3,r3,3912
81100b3c:	00a04574 	movhi	r2,33045
81100b40:	10a60604 	addi	r2,r2,-26600
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a06117 	ldw	r2,-32380(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	2943d204 	addi	r5,r5,3912
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111f5fc0 	call	8111f5fc <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18c3d204 	addi	r3,r3,3912
81100b88:	00a04574 	movhi	r2,33045
81100b8c:	10a60c04 	addi	r2,r2,-26576
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a06117 	ldw	r2,-32380(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	2943d204 	addi	r5,r5,3912
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111f5fc0 	call	8111f5fc <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18c3d204 	addi	r3,r3,3912
81100bd4:	00a04574 	movhi	r2,33045
81100bd8:	10a61404 	addi	r2,r2,-26544
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	11206ac0 	call	811206ac <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a06117 	ldw	r2,-32380(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	2943d204 	addi	r5,r5,3912
81100c00:	1009883a 	mov	r4,r2
81100c04:	111f5fc0 	call	8111f5fc <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18c3d204 	addi	r3,r3,3912
81100c20:	00a04574 	movhi	r2,33045
81100c24:	10a62104 	addi	r2,r2,-26492
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a06117 	ldw	r2,-32380(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	2943d204 	addi	r5,r5,3912
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111f5fc0 	call	8111f5fc <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18c3d204 	addi	r3,r3,3912
81100c6c:	00a04574 	movhi	r2,33045
81100c70:	10a62704 	addi	r2,r2,-26468
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a06117 	ldw	r2,-32380(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	2943d204 	addi	r5,r5,3912
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111f5fc0 	call	8111f5fc <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18c3d204 	addi	r3,r3,3912
81100cb8:	00a04574 	movhi	r2,33045
81100cbc:	10a62c04 	addi	r2,r2,-26448
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a06117 	ldw	r2,-32380(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	2943d204 	addi	r5,r5,3912
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111f5fc0 	call	8111f5fc <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18c3d204 	addi	r3,r3,3912
81100d04:	00a04574 	movhi	r2,33045
81100d08:	10a63304 	addi	r2,r2,-26420
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	11206ac0 	call	811206ac <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a06117 	ldw	r2,-32380(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	2943d204 	addi	r5,r5,3912
81100d30:	1009883a 	mov	r4,r2
81100d34:	111f5fc0 	call	8111f5fc <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18c3d204 	addi	r3,r3,3912
81100d50:	00a04574 	movhi	r2,33045
81100d54:	10a64104 	addi	r2,r2,-26364
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	11206ac0 	call	811206ac <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a06117 	ldw	r2,-32380(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	2943d204 	addi	r5,r5,3912
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111f5fc0 	call	8111f5fc <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18c3d204 	addi	r3,r3,3912
81100d9c:	00a04574 	movhi	r2,33045
81100da0:	10a65304 	addi	r2,r2,-26292
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a06117 	ldw	r2,-32380(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	2943d204 	addi	r5,r5,3912
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111f5fc0 	call	8111f5fc <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18c3d204 	addi	r3,r3,3912
81100de8:	00a04574 	movhi	r2,33045
81100dec:	10a65b04 	addi	r2,r2,-26260
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	11206ac0 	call	811206ac <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a06117 	ldw	r2,-32380(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	2943d204 	addi	r5,r5,3912
81100e14:	1009883a 	mov	r4,r2
81100e18:	111f5fc0 	call	8111f5fc <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18c3d204 	addi	r3,r3,3912
81100e34:	00a04574 	movhi	r2,33045
81100e38:	10a66504 	addi	r2,r2,-26220
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	11206ac0 	call	811206ac <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a06117 	ldw	r2,-32380(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	2943d204 	addi	r5,r5,3912
81100e60:	1009883a 	mov	r4,r2
81100e64:	111f5fc0 	call	8111f5fc <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18c3d204 	addi	r3,r3,3912
81100e80:	00a04574 	movhi	r2,33045
81100e84:	10a67204 	addi	r2,r2,-26168
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	11206ac0 	call	811206ac <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a06117 	ldw	r2,-32380(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	2943d204 	addi	r5,r5,3912
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111f5fc0 	call	8111f5fc <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18c3d204 	addi	r3,r3,3912
81100ecc:	00a04574 	movhi	r2,33045
81100ed0:	10a67c04 	addi	r2,r2,-26128
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	11206ac0 	call	811206ac <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a06117 	ldw	r2,-32380(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	2943d204 	addi	r5,r5,3912
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111f5fc0 	call	8111f5fc <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18c3d204 	addi	r3,r3,3912
81100f18:	00a04574 	movhi	r2,33045
81100f1c:	10a68704 	addi	r2,r2,-26084
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	11206ac0 	call	811206ac <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a06117 	ldw	r2,-32380(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	2943d204 	addi	r5,r5,3912
81100f44:	1009883a 	mov	r4,r2
81100f48:	111f5fc0 	call	8111f5fc <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18c3d204 	addi	r3,r3,3912
81100f64:	00a04574 	movhi	r2,33045
81100f68:	10a69804 	addi	r2,r2,-26016
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	11206ac0 	call	811206ac <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a06117 	ldw	r2,-32380(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	2943d204 	addi	r5,r5,3912
81100f90:	1009883a 	mov	r4,r2
81100f94:	111f5fc0 	call	8111f5fc <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18c3d204 	addi	r3,r3,3912
81100fb0:	00a04574 	movhi	r2,33045
81100fb4:	10a6a304 	addi	r2,r2,-25972
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	11206ac0 	call	811206ac <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a06117 	ldw	r2,-32380(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	2943d204 	addi	r5,r5,3912
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111f5fc0 	call	8111f5fc <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18c3d204 	addi	r3,r3,3912
81100ffc:	00a04574 	movhi	r2,33045
81101000:	10a6b004 	addi	r2,r2,-25920
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	11206ac0 	call	811206ac <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a06117 	ldw	r2,-32380(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	2943d204 	addi	r5,r5,3912
81101028:	1009883a 	mov	r4,r2
8110102c:	111f5fc0 	call	8111f5fc <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18c3d204 	addi	r3,r3,3912
81101048:	00a04574 	movhi	r2,33045
8110104c:	10a6be04 	addi	r2,r2,-25864
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	11206ac0 	call	811206ac <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a06117 	ldw	r2,-32380(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	2943d204 	addi	r5,r5,3912
81101074:	1009883a 	mov	r4,r2
81101078:	111f5fc0 	call	8111f5fc <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18c3d204 	addi	r3,r3,3912
81101094:	00a04574 	movhi	r2,33045
81101098:	10a6cb04 	addi	r2,r2,-25812
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	11206ac0 	call	811206ac <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a06117 	ldw	r2,-32380(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	2943d204 	addi	r5,r5,3912
811010c0:	1009883a 	mov	r4,r2
811010c4:	111f5fc0 	call	8111f5fc <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18c3d204 	addi	r3,r3,3912
811010e0:	00a04574 	movhi	r2,33045
811010e4:	10a6d804 	addi	r2,r2,-25760
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a06117 	ldw	r2,-32380(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	2943d204 	addi	r5,r5,3912
8110110c:	1009883a 	mov	r4,r2
81101110:	111f5fc0 	call	8111f5fc <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	1083d204 	addi	r2,r2,3912
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a06117 	ldw	r2,-32380(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	2943d204 	addi	r5,r5,3912
81101194:	1009883a 	mov	r4,r2
81101198:	111f5fc0 	call	8111f5fc <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18c3d204 	addi	r3,r3,3912
811011b4:	00a04574 	movhi	r2,33045
811011b8:	10a6dc04 	addi	r2,r2,-25744
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a06117 	ldw	r2,-32380(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	2943d204 	addi	r5,r5,3912
811011e0:	1009883a 	mov	r4,r2
811011e4:	111f5fc0 	call	8111f5fc <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18c3d204 	addi	r3,r3,3912
81101200:	00a04574 	movhi	r2,33045
81101204:	10a6e404 	addi	r2,r2,-25712
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	11206ac0 	call	811206ac <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a06117 	ldw	r2,-32380(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	2943d204 	addi	r5,r5,3912
8110122c:	1009883a 	mov	r4,r2
81101230:	111f5fc0 	call	8111f5fc <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18c3d204 	addi	r3,r3,3912
8110124c:	00a04574 	movhi	r2,33045
81101250:	10a6f204 	addi	r2,r2,-25656
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a06117 	ldw	r2,-32380(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	2943d204 	addi	r5,r5,3912
81101278:	1009883a 	mov	r4,r2
8110127c:	111f5fc0 	call	8111f5fc <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18c3d204 	addi	r3,r3,3912
81101298:	00a04574 	movhi	r2,33045
8110129c:	10a6fa04 	addi	r2,r2,-25624
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a06117 	ldw	r2,-32380(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	2943d204 	addi	r5,r5,3912
811012c4:	1009883a 	mov	r4,r2
811012c8:	111f5fc0 	call	8111f5fc <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18c3d204 	addi	r3,r3,3912
811012e4:	00a04574 	movhi	r2,33045
811012e8:	10a70204 	addi	r2,r2,-25592
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	11206ac0 	call	811206ac <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a06117 	ldw	r2,-32380(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	2943d204 	addi	r5,r5,3912
81101310:	1009883a 	mov	r4,r2
81101314:	111f5fc0 	call	8111f5fc <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18c3d204 	addi	r3,r3,3912
81101330:	00a04574 	movhi	r2,33045
81101334:	10a70c04 	addi	r2,r2,-25552
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a06117 	ldw	r2,-32380(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	2943d204 	addi	r5,r5,3912
8110135c:	1009883a 	mov	r4,r2
81101360:	111f5fc0 	call	8111f5fc <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18c3d204 	addi	r3,r3,3912
8110137c:	00a04574 	movhi	r2,33045
81101380:	10a71304 	addi	r2,r2,-25524
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	11206ac0 	call	811206ac <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a06117 	ldw	r2,-32380(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	2943d204 	addi	r5,r5,3912
811013a8:	1009883a 	mov	r4,r2
811013ac:	111f5fc0 	call	8111f5fc <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18c3d204 	addi	r3,r3,3912
811013c8:	00a04574 	movhi	r2,33045
811013cc:	10a71d04 	addi	r2,r2,-25484
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a06117 	ldw	r2,-32380(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	2943d204 	addi	r5,r5,3912
811013f4:	1009883a 	mov	r4,r2
811013f8:	111f5fc0 	call	8111f5fc <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	1083d204 	addi	r2,r2,3912
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a06117 	ldw	r2,-32380(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	2943d204 	addi	r5,r5,3912
81101420:	1009883a 	mov	r4,r2
81101424:	111f5fc0 	call	8111f5fc <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18c3d204 	addi	r3,r3,3912
81101454:	00a04574 	movhi	r2,33045
81101458:	10a72704 	addi	r2,r2,-25444
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a06117 	ldw	r2,-32380(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	2943d204 	addi	r5,r5,3912
81101480:	1009883a 	mov	r4,r2
81101484:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	1083d204 	addi	r2,r2,3912
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a06117 	ldw	r2,-32380(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	2943d204 	addi	r5,r5,3912
811014a8:	1009883a 	mov	r4,r2
811014ac:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18c3d204 	addi	r3,r3,3912
81101538:	00a04574 	movhi	r2,33045
8110153c:	10a72d04 	addi	r2,r2,-25420
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a06117 	ldw	r2,-32380(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	2943d204 	addi	r5,r5,3912
81101564:	1009883a 	mov	r4,r2
81101568:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18c3d204 	addi	r3,r3,3912
811015b4:	00a04574 	movhi	r2,33045
811015b8:	10a73c04 	addi	r2,r2,-25360
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a06117 	ldw	r2,-32380(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	2943d204 	addi	r5,r5,3912
811015e0:	1009883a 	mov	r4,r2
811015e4:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18c3d204 	addi	r3,r3,3912
81101648:	00a04574 	movhi	r2,33045
8110164c:	10a54d04 	addi	r2,r2,-27340
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a06117 	ldw	r2,-32380(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	2943d204 	addi	r5,r5,3912
81101674:	1009883a 	mov	r4,r2
81101678:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604574 	movhi	r5,33045
81101694:	29674604 	addi	r5,r5,-25320
81101698:	01204574 	movhi	r4,33045
8110169c:	2103d204 	addi	r4,r4,3912
811016a0:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a06117 	ldw	r2,-32380(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	2943d204 	addi	r5,r5,3912
811016b0:	1009883a 	mov	r4,r2
811016b4:	111f5fc0 	call	8111f5fc <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08817 	ldw	r2,-32224(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10841204 	addi	r2,r2,4168
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10841204 	addi	r2,r2,4168
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10841204 	addi	r2,r2,4168
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10841204 	addi	r2,r2,4168
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10841204 	addi	r2,r2,4168
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10841204 	addi	r2,r2,4168
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10841204 	addi	r2,r2,4168
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18c3d204 	addi	r3,r3,3912
81101868:	00a04574 	movhi	r2,33045
8110186c:	10a74c04 	addi	r2,r2,-25296
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a06117 	ldw	r2,-32380(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	2943d204 	addi	r5,r5,3912
81101894:	1009883a 	mov	r4,r2
81101898:	111f5fc0 	call	8111f5fc <fprintf>
8110189c:	d0a08817 	ldw	r2,-32224(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	29441204 	addi	r5,r5,4168
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	11206ac0 	call	811206ac <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604574 	movhi	r5,33045
81101990:	29675104 	addi	r5,r5,-25276
81101994:	01204574 	movhi	r4,33045
81101998:	2103d204 	addi	r4,r4,3912
8110199c:	1120f8c0 	call	81120f8c <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a06117 	ldw	r2,-32380(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	2943d204 	addi	r5,r5,3912
811019ac:	1009883a 	mov	r4,r2
811019b0:	111f5fc0 	call	8111f5fc <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11344ec0 	call	811344ec <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	1083d204 	addi	r2,r2,3912
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a06117 	ldw	r2,-32380(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	2943d204 	addi	r5,r5,3912
811019e4:	1009883a 	mov	r4,r2
811019e8:	111f5fc0 	call	8111f5fc <fprintf>
811019ec:	d0e08817 	ldw	r3,-32224(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111dcf40 	call	8111dcf4 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08717 	ldw	r2,-32228(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111de200 	call	8111de20 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111d4a80 	call	8111d4a8 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111f17c0 	call	8111f17c <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604574 	movhi	r5,33045
81101a54:	29675304 	addi	r5,r5,-25268
81101a58:	01204574 	movhi	r4,33045
81101a5c:	2103d204 	addi	r4,r4,3912
81101a60:	1120f8c0 	call	81120f8c <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a06117 	ldw	r2,-32380(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	2943d204 	addi	r5,r5,3912
81101a70:	1009883a 	mov	r4,r2
81101a74:	111f5fc0 	call	8111f5fc <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18c3d204 	addi	r3,r3,3912
81101a84:	00a04574 	movhi	r2,33045
81101a88:	10a75f04 	addi	r2,r2,-25220
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a06117 	ldw	r2,-32380(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	2943d204 	addi	r5,r5,3912
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	1083d204 	addi	r2,r2,3912
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a06117 	ldw	r2,-32380(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	2943d204 	addi	r5,r5,3912
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18c3d204 	addi	r3,r3,3912
81101b30:	00a04574 	movhi	r2,33045
81101b34:	10a76504 	addi	r2,r2,-25196
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a06117 	ldw	r2,-32380(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	2943d204 	addi	r5,r5,3912
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18c3d204 	addi	r3,r3,3912
81101bc4:	00a04574 	movhi	r2,33045
81101bc8:	10a54d04 	addi	r2,r2,-27340
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a06117 	ldw	r2,-32380(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	2943d204 	addi	r5,r5,3912
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604574 	movhi	r5,33045
81101c10:	29676f04 	addi	r5,r5,-25156
81101c14:	01204574 	movhi	r4,33045
81101c18:	2103d204 	addi	r4,r4,3912
81101c1c:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a06117 	ldw	r2,-32380(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	2943d204 	addi	r5,r5,3912
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18c3d204 	addi	r3,r3,3912
81101cd0:	00a04574 	movhi	r2,33045
81101cd4:	10a77504 	addi	r2,r2,-25132
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a06117 	ldw	r2,-32380(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	2943d204 	addi	r5,r5,3912
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111f5fc0 	call	8111f5fc <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08817 	ldw	r2,-32224(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10841204 	addi	r2,r2,4168
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10841204 	addi	r2,r2,4168
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604574 	movhi	r5,33045
81101df4:	29677c04 	addi	r5,r5,-25104
81101df8:	01204574 	movhi	r4,33045
81101dfc:	2103d204 	addi	r4,r4,3912
81101e00:	1120f8c0 	call	81120f8c <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a06117 	ldw	r2,-32380(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	2943d204 	addi	r5,r5,3912
81101e10:	1009883a 	mov	r4,r2
81101e14:	111f5fc0 	call	8111f5fc <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604574 	movhi	r5,33045
81101e98:	29675104 	addi	r5,r5,-25276
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	2103d204 	addi	r4,r4,3912
81101ea4:	1120f8c0 	call	81120f8c <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a06117 	ldw	r2,-32380(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	2943d204 	addi	r5,r5,3912
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111f5fc0 	call	8111f5fc <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	1083d204 	addi	r2,r2,3912
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a06117 	ldw	r2,-32380(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	2943d204 	addi	r5,r5,3912
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111f5fc0 	call	8111f5fc <fprintf>
81101ef8:	d0e08817 	ldw	r3,-32224(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111dcf40 	call	8111dcf4 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08717 	ldw	r2,-32228(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111de200 	call	8111de20 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111d4a80 	call	8111d4a8 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111f17c0 	call	8111f17c <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604574 	movhi	r5,33045
81101f60:	29678a04 	addi	r5,r5,-25048
81101f64:	01204574 	movhi	r4,33045
81101f68:	2103d204 	addi	r4,r4,3912
81101f6c:	1120f8c0 	call	81120f8c <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a06117 	ldw	r2,-32380(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	2943d204 	addi	r5,r5,3912
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111f5fc0 	call	8111f5fc <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18c3d204 	addi	r3,r3,3912
81101f90:	00a04574 	movhi	r2,33045
81101f94:	10a79604 	addi	r2,r2,-25000
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a06117 	ldw	r2,-32380(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	2943d204 	addi	r5,r5,3912
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	1083d204 	addi	r2,r2,3912
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a06117 	ldw	r2,-32380(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	2943d204 	addi	r5,r5,3912
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18c3d204 	addi	r3,r3,3912
8110204c:	00a04574 	movhi	r2,33045
81102050:	10a79c04 	addi	r2,r2,-24976
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a06117 	ldw	r2,-32380(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	2943d204 	addi	r5,r5,3912
81102078:	1009883a 	mov	r4,r2
8110207c:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18c3d204 	addi	r3,r3,3912
811020e0:	00a04574 	movhi	r2,33045
811020e4:	10a54d04 	addi	r2,r2,-27340
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a06117 	ldw	r2,-32380(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	2943d204 	addi	r5,r5,3912
8110210c:	1009883a 	mov	r4,r2
81102110:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604574 	movhi	r5,33045
8110212c:	29674604 	addi	r5,r5,-25320
81102130:	01204574 	movhi	r4,33045
81102134:	2103d204 	addi	r4,r4,3912
81102138:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a06117 	ldw	r2,-32380(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	2943d204 	addi	r5,r5,3912
81102148:	1009883a 	mov	r4,r2
8110214c:	111f5fc0 	call	8111f5fc <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08817 	ldw	r2,-32224(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18c3d204 	addi	r3,r3,3912
811021ac:	00a04574 	movhi	r2,33045
811021b0:	10a7a804 	addi	r2,r2,-24928
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a06117 	ldw	r2,-32380(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	2943d204 	addi	r5,r5,3912
811021d8:	1009883a 	mov	r4,r2
811021dc:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604574 	movhi	r5,33045
811021f0:	2967ae04 	addi	r5,r5,-24904
811021f4:	01204574 	movhi	r4,33045
811021f8:	2103d204 	addi	r4,r4,3912
811021fc:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a06117 	ldw	r2,-32380(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	2943d204 	addi	r5,r5,3912
8110220c:	1009883a 	mov	r4,r2
81102210:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604574 	movhi	r5,33045
81102274:	2967b004 	addi	r5,r5,-24896
81102278:	01204574 	movhi	r4,33045
8110227c:	2103d204 	addi	r4,r4,3912
81102280:	1120f8c0 	call	81120f8c <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a06117 	ldw	r2,-32380(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	2943d204 	addi	r5,r5,3912
81102290:	1009883a 	mov	r4,r2
81102294:	111f5fc0 	call	8111f5fc <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11344ec0 	call	811344ec <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604574 	movhi	r5,33045
811022fc:	2967b304 	addi	r5,r5,-24884
81102300:	01204574 	movhi	r4,33045
81102304:	2103d204 	addi	r4,r4,3912
81102308:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a06117 	ldw	r2,-32380(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	2943d204 	addi	r5,r5,3912
81102318:	1009883a 	mov	r4,r2
8110231c:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111dcf40 	call	8111dcf4 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08717 	ldw	r2,-32228(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111de200 	call	8111de20 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111d4a80 	call	8111d4a8 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111f17c0 	call	8111f17c <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604574 	movhi	r5,33045
81102394:	2967b604 	addi	r5,r5,-24872
81102398:	01204574 	movhi	r4,33045
8110239c:	2103d204 	addi	r4,r4,3912
811023a0:	1120f8c0 	call	81120f8c <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a06117 	ldw	r2,-32380(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	2943d204 	addi	r5,r5,3912
811023b0:	1009883a 	mov	r4,r2
811023b4:	111f5fc0 	call	8111f5fc <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604574 	movhi	r5,33045
811023c4:	2967c204 	addi	r5,r5,-24824
811023c8:	01204574 	movhi	r4,33045
811023cc:	2103d204 	addi	r4,r4,3912
811023d0:	1120f8c0 	call	81120f8c <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a06117 	ldw	r2,-32380(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	2943d204 	addi	r5,r5,3912
811023e0:	1009883a 	mov	r4,r2
811023e4:	111f5fc0 	call	8111f5fc <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18c3d204 	addi	r3,r3,3912
811023f4:	00a04574 	movhi	r2,33045
811023f8:	10a75f04 	addi	r2,r2,-25220
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a06117 	ldw	r2,-32380(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	2943d204 	addi	r5,r5,3912
81102420:	1009883a 	mov	r4,r2
81102424:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	1083d204 	addi	r2,r2,3912
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a06117 	ldw	r2,-32380(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	2943d204 	addi	r5,r5,3912
81102448:	1009883a 	mov	r4,r2
8110244c:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18c3d204 	addi	r3,r3,3912
811024b8:	00a04574 	movhi	r2,33045
811024bc:	10a7cc04 	addi	r2,r2,-24784
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a06117 	ldw	r2,-32380(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	2943d204 	addi	r5,r5,3912
811024e4:	1009883a 	mov	r4,r2
811024e8:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18c3d204 	addi	r3,r3,3912
8110254c:	00a04574 	movhi	r2,33045
81102550:	10a54d04 	addi	r2,r2,-27340
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	11206ac0 	call	811206ac <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a06117 	ldw	r2,-32380(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	2943d204 	addi	r5,r5,3912
81102578:	1009883a 	mov	r4,r2
8110257c:	111f5fc0 	call	8111f5fc <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604574 	movhi	r5,33045
81102598:	29674604 	addi	r5,r5,-25320
8110259c:	01204574 	movhi	r4,33045
811025a0:	2103d204 	addi	r4,r4,3912
811025a4:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a06117 	ldw	r2,-32380(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	2943d204 	addi	r5,r5,3912
811025b4:	1009883a 	mov	r4,r2
811025b8:	111f5fc0 	call	8111f5fc <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18c3d204 	addi	r3,r3,3912
81102610:	00a04574 	movhi	r2,33045
81102614:	10a7d804 	addi	r2,r2,-24736
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a06117 	ldw	r2,-32380(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	2943d204 	addi	r5,r5,3912
8110263c:	1009883a 	mov	r4,r2
81102640:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604574 	movhi	r5,33045
81102654:	2967ae04 	addi	r5,r5,-24904
81102658:	01204574 	movhi	r4,33045
8110265c:	2103d204 	addi	r4,r4,3912
81102660:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a06117 	ldw	r2,-32380(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	2943d204 	addi	r5,r5,3912
81102670:	1009883a 	mov	r4,r2
81102674:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08817 	ldw	r2,-32224(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604574 	movhi	r5,33045
811026c8:	2967de04 	addi	r5,r5,-24712
811026cc:	01204574 	movhi	r4,33045
811026d0:	2103d204 	addi	r4,r4,3912
811026d4:	1120f8c0 	call	81120f8c <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a06117 	ldw	r2,-32380(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	2943d204 	addi	r5,r5,3912
811026e4:	1009883a 	mov	r4,r2
811026e8:	111f5fc0 	call	8111f5fc <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604574 	movhi	r5,33045
81102710:	2967b004 	addi	r5,r5,-24896
81102714:	01204574 	movhi	r4,33045
81102718:	2103d204 	addi	r4,r4,3912
8110271c:	1120f8c0 	call	81120f8c <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a06117 	ldw	r2,-32380(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	2943d204 	addi	r5,r5,3912
8110272c:	1009883a 	mov	r4,r2
81102730:	111f5fc0 	call	8111f5fc <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604574 	movhi	r5,33045
81102794:	2967b304 	addi	r5,r5,-24884
81102798:	01204574 	movhi	r4,33045
8110279c:	2103d204 	addi	r4,r4,3912
811027a0:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a06117 	ldw	r2,-32380(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	2943d204 	addi	r5,r5,3912
811027b0:	1009883a 	mov	r4,r2
811027b4:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08817 	ldw	r3,-32224(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111dcf40 	call	8111dcf4 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08717 	ldw	r2,-32228(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111de200 	call	8111de20 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111d4a80 	call	8111d4a8 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111f17c0 	call	8111f17c <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604574 	movhi	r5,33045
8110282c:	2967e604 	addi	r5,r5,-24680
81102830:	01204574 	movhi	r4,33045
81102834:	2103d204 	addi	r4,r4,3912
81102838:	1120f8c0 	call	81120f8c <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a06117 	ldw	r2,-32380(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	2943d204 	addi	r5,r5,3912
81102848:	1009883a 	mov	r4,r2
8110284c:	111f5fc0 	call	8111f5fc <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604574 	movhi	r5,33045
8110285c:	2967f204 	addi	r5,r5,-24632
81102860:	01204574 	movhi	r4,33045
81102864:	2103d204 	addi	r4,r4,3912
81102868:	1120f8c0 	call	81120f8c <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a06117 	ldw	r2,-32380(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	2943d204 	addi	r5,r5,3912
81102878:	1009883a 	mov	r4,r2
8110287c:	111f5fc0 	call	8111f5fc <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18c3d204 	addi	r3,r3,3912
8110288c:	00a04574 	movhi	r2,33045
81102890:	10a79604 	addi	r2,r2,-25000
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	11206ac0 	call	811206ac <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a06117 	ldw	r2,-32380(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	2943d204 	addi	r5,r5,3912
811028b8:	1009883a 	mov	r4,r2
811028bc:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	1083d204 	addi	r2,r2,3912
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a06117 	ldw	r2,-32380(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	2943d204 	addi	r5,r5,3912
811028e0:	1009883a 	mov	r4,r2
811028e4:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1147dac0 	call	81147dac <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1135d140 	call	81135d14 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1135d140 	call	81135d14 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1135d140 	call	81135d14 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1135d140 	call	81135d14 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	1146da80 	call	81146da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	114801c0 	call	8114801c <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1135d140 	call	81135d14 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1135d140 	call	81135d14 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	1146da80 	call	81146da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	114801c0 	call	8114801c <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	1146da80 	call	81146da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	114801c0 	call	8114801c <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1135d140 	call	81135d14 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1135d140 	call	81135d14 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110b92c0 	call	8110b92c <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110b92c0 	call	8110b92c <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604574 	movhi	r5,33045
811030d0:	2967fc04 	addi	r5,r5,-24592
811030d4:	01204574 	movhi	r4,33045
811030d8:	2103d204 	addi	r4,r4,3912
811030dc:	1120f8c0 	call	81120f8c <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a06117 	ldw	r2,-32380(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	2943d204 	addi	r5,r5,3912
811030ec:	1009883a 	mov	r4,r2
811030f0:	111f5fc0 	call	8111f5fc <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604574 	movhi	r5,33045
8110311c:	29680204 	addi	r5,r5,-24568
81103120:	01204574 	movhi	r4,33045
81103124:	2103d204 	addi	r4,r4,3912
81103128:	1120f8c0 	call	81120f8c <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a06117 	ldw	r2,-32380(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	2943d204 	addi	r5,r5,3912
81103138:	1009883a 	mov	r4,r2
8110313c:	111f5fc0 	call	8111f5fc <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	29680e04 	addi	r5,r5,-24520
81103160:	01204574 	movhi	r4,33045
81103164:	2103d204 	addi	r4,r4,3912
81103168:	1120f8c0 	call	81120f8c <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a06117 	ldw	r2,-32380(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	2943d204 	addi	r5,r5,3912
81103178:	1009883a 	mov	r4,r2
8110317c:	111f5fc0 	call	8111f5fc <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18c3d204 	addi	r3,r3,3912
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10a81404 	addi	r2,r2,-24496
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	11206ac0 	call	811206ac <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a06117 	ldw	r2,-32380(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	2943d204 	addi	r5,r5,3912
811031ec:	1009883a 	mov	r4,r2
811031f0:	111f5fc0 	call	8111f5fc <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	110a7240 	call	8110a724 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	110a7240 	call	8110a724 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10a84b04 	addi	r2,r2,-24276
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	11206ac0 	call	811206ac <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111de200 	call	8111de20 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111d4a80 	call	8111d4a8 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111d8f00 	call	8111d8f0 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	111f17c0 	call	8111f17c <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	29681904 	addi	r5,r5,-24476
8110365c:	01204574 	movhi	r4,33045
81103660:	2103d204 	addi	r4,r4,3912
81103664:	1120f8c0 	call	81120f8c <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a06117 	ldw	r2,-32380(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	2943d204 	addi	r5,r5,3912
81103674:	1009883a 	mov	r4,r2
81103678:	111f5fc0 	call	8111f5fc <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	111f17c0 	call	8111f17c <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111dff40 	call	8111dff4 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	111f17c0 	call	8111f17c <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111dff40 	call	8111dff4 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	111f2940 	call	8111f294 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111d4a80 	call	8111d4a8 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111d8f00 	call	8111d8f0 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	111f17c0 	call	8111f17c <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	111f17c0 	call	8111f17c <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	111f17c0 	call	8111f17c <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	29682204 	addi	r5,r5,-24440
811037f4:	01204574 	movhi	r4,33045
811037f8:	2103d204 	addi	r4,r4,3912
811037fc:	1120f8c0 	call	81120f8c <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a06117 	ldw	r2,-32380(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	2943d204 	addi	r5,r5,3912
8110380c:	1009883a 	mov	r4,r2
81103810:	111f5fc0 	call	8111f5fc <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	111f17c0 	call	8111f17c <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111dff40 	call	8111dff4 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	111f17c0 	call	8111f17c <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111dff40 	call	8111dff4 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	111f2940 	call	8111f294 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111d4a80 	call	8111d4a8 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111d8f00 	call	8111d8f0 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	111f17c0 	call	8111f17c <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	111f17c0 	call	8111f17c <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	111f17c0 	call	8111f17c <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	29683204 	addi	r5,r5,-24376
8110398c:	01204574 	movhi	r4,33045
81103990:	2103d204 	addi	r4,r4,3912
81103994:	1120f8c0 	call	81120f8c <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a06117 	ldw	r2,-32380(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	2943d204 	addi	r5,r5,3912
811039a4:	1009883a 	mov	r4,r2
811039a8:	111f5fc0 	call	8111f5fc <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111d8f00 	call	8111d8f0 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	111f17c0 	call	8111f17c <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	29684204 	addi	r5,r5,-24312
81103a34:	01204574 	movhi	r4,33045
81103a38:	2103d204 	addi	r4,r4,3912
81103a3c:	1120f8c0 	call	81120f8c <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a06117 	ldw	r2,-32380(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	2943d204 	addi	r5,r5,3912
81103a4c:	1009883a 	mov	r4,r2
81103a50:	111f5fc0 	call	8111f5fc <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	1083d204 	addi	r2,r2,3912
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a06117 	ldw	r2,-32380(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	2943d204 	addi	r5,r5,3912
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	111f5fc0 	call	8111f5fc <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	1083d204 	addi	r2,r2,3912
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a06117 	ldw	r2,-32380(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	2943d204 	addi	r5,r5,3912
81103af8:	1009883a 	mov	r4,r2
81103afc:	111f5fc0 	call	8111f5fc <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	21290b04 	addi	r4,r4,-23508
81103b5c:	1147dac0 	call	81147dac <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	1135d140 	call	81135d14 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	21291004 	addi	r4,r4,-23488
81103c0c:	1147dac0 	call	81147dac <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	1135d140 	call	81135d14 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe804 	addi	sp,sp,-96
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01715 	stw	ra,92(sp)
81103ca0:	df001615 	stw	fp,88(sp)
81103ca4:	dc001515 	stw	r16,84(sp)
81103ca8:	df001604 	addi	fp,sp,88
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff315 	stw	r2,-52(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff40d 	sth	zero,-48(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff515 	stw	zero,-44(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff615 	stw	zero,-40(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff715 	stw	zero,-36(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff815 	stw	zero,-32(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	bool bBufferEmptyFlag = FALSE;
81103cfc:	e03ff915 	stw	zero,-28(fp)

	switch (ucChBufferId) {
81103d00:	e0bffe03 	ldbu	r2,-8(fp)
81103d04:	10c00228 	cmpgeui	r3,r2,8
81103d08:	1800b81e 	bne	r3,zero,81103fec <bSdmaDmaM1Transfer+0x35c>
81103d0c:	100690ba 	slli	r3,r2,2
81103d10:	00a04434 	movhi	r2,33040
81103d14:	108f4904 	addi	r2,r2,15652
81103d18:	1885883a 	add	r2,r3,r2
81103d1c:	10800017 	ldw	r2,0(r2)
81103d20:	1000683a 	jmp	r2
81103d24:	81103d44 	addi	r4,r16,16629
81103d28:	81103d98 	cmpnei	r4,r16,16630
81103d2c:	81103df4 	orhi	r4,r16,16631
81103d30:	81103e48 	cmpgei	r4,r16,16633
81103d34:	81103e9c 	xori	r4,r16,16634
81103d38:	81103ef0 	cmpltui	r4,r16,16635
81103d3c:	81103f44 	addi	r4,r16,16637
81103d40:	81103f98 	cmpnei	r4,r16,16638
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d44:	e0bffd03 	ldbu	r2,-12(fp)
81103d48:	10000826 	beq	r2,zero,81103d6c <bSdmaDmaM1Transfer+0xdc>
81103d4c:	10800060 	cmpeqi	r2,r2,1
81103d50:	10000d26 	beq	r2,zero,81103d88 <bSdmaDmaM1Transfer+0xf8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d54:	e03ff515 	stw	zero,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d58:	00800044 	movi	r2,1
81103d5c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh1RightBufferEmpty();
81103d60:	11065140 	call	81106514 <bFeebGetCh1RightBufferEmpty>
81103d64:	e0bff915 	stw	r2,-28(fp)
			break;
81103d68:	00000a06 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d6c:	00800074 	movhi	r2,1
81103d70:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d74:	00800044 	movi	r2,1
81103d78:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh1LeftBufferEmpty();
81103d7c:	11064ac0 	call	811064ac <bFeebGetCh1LeftBufferEmpty>
81103d80:	e0bff915 	stw	r2,-28(fp)
			break;
81103d84:	00000306 	br	81103d94 <bSdmaDmaM1Transfer+0x104>
		default:
			bStatus = FALSE;
81103d88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103d8c:	e03ff915 	stw	zero,-28(fp)
			break;
81103d90:	0001883a 	nop
		}
		break;
81103d94:	00009706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d98:	e0bffd03 	ldbu	r2,-12(fp)
81103d9c:	10000926 	beq	r2,zero,81103dc4 <bSdmaDmaM1Transfer+0x134>
81103da0:	10800060 	cmpeqi	r2,r2,1
81103da4:	10000f26 	beq	r2,zero,81103de4 <bSdmaDmaM1Transfer+0x154>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103da8:	00880004 	movi	r2,8192
81103dac:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh2RightBufferEmpty();
81103db8:	11065e40 	call	811065e4 <bFeebGetCh2RightBufferEmpty>
81103dbc:	e0bff915 	stw	r2,-28(fp)
			break;
81103dc0:	00000b06 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103dc4:	00800074 	movhi	r2,1
81103dc8:	10880004 	addi	r2,r2,8192
81103dcc:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103dd0:	00800044 	movi	r2,1
81103dd4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = bFeebGetCh2LeftBufferEmpty();
81103dd8:	110657c0 	call	8110657c <bFeebGetCh2LeftBufferEmpty>
81103ddc:	e0bff915 	stw	r2,-28(fp)
			break;
81103de0:	00000306 	br	81103df0 <bSdmaDmaM1Transfer+0x160>
		default:
			bStatus = FALSE;
81103de4:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103de8:	e03ff915 	stw	zero,-28(fp)
			break;
81103dec:	0001883a 	nop
		}
		break;
81103df0:	00008006 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103df4:	e0bffd03 	ldbu	r2,-12(fp)
81103df8:	10000826 	beq	r2,zero,81103e1c <bSdmaDmaM1Transfer+0x18c>
81103dfc:	10800060 	cmpeqi	r2,r2,1
81103e00:	10000d26 	beq	r2,zero,81103e38 <bSdmaDmaM1Transfer+0x1a8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103e04:	00900004 	movi	r2,16384
81103e08:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103e0c:	00800044 	movi	r2,1
81103e10:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e14:	e03ff915 	stw	zero,-28(fp)
			break;
81103e18:	00000a06 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103e1c:	00800074 	movhi	r2,1
81103e20:	10900004 	addi	r2,r2,16384
81103e24:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e30:	e03ff915 	stw	zero,-28(fp)
			break;
81103e34:	00000306 	br	81103e44 <bSdmaDmaM1Transfer+0x1b4>
		default:
			bStatus = FALSE;
81103e38:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e3c:	e03ff915 	stw	zero,-28(fp)
			break;
81103e40:	0001883a 	nop
		}
		break;
81103e44:	00006b06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e48:	e0bffd03 	ldbu	r2,-12(fp)
81103e4c:	10000826 	beq	r2,zero,81103e70 <bSdmaDmaM1Transfer+0x1e0>
81103e50:	10800060 	cmpeqi	r2,r2,1
81103e54:	10000d26 	beq	r2,zero,81103e8c <bSdmaDmaM1Transfer+0x1fc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e58:	00980004 	movi	r2,24576
81103e5c:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e60:	00800044 	movi	r2,1
81103e64:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e68:	e03ff915 	stw	zero,-28(fp)
			break;
81103e6c:	00000a06 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e70:	00800074 	movhi	r2,1
81103e74:	10980004 	addi	r2,r2,24576
81103e78:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e7c:	00800044 	movi	r2,1
81103e80:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103e84:	e03ff915 	stw	zero,-28(fp)
			break;
81103e88:	00000306 	br	81103e98 <bSdmaDmaM1Transfer+0x208>
		default:
			bStatus = FALSE;
81103e8c:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103e90:	e03ff915 	stw	zero,-28(fp)
			break;
81103e94:	0001883a 	nop
		}
		break;
81103e98:	00005606 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e9c:	e0bffd03 	ldbu	r2,-12(fp)
81103ea0:	10000826 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea4:	10800060 	cmpeqi	r2,r2,1
81103ea8:	10000d26 	beq	r2,zero,81103ee0 <bSdmaDmaM1Transfer+0x250>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103eac:	00a00014 	movui	r2,32768
81103eb0:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103eb4:	00800044 	movi	r2,1
81103eb8:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103ebc:	e03ff915 	stw	zero,-28(fp)
			break;
81103ec0:	00000a06 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a00004 	addi	r2,r2,-32768
81103ecc:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103ed8:	e03ff915 	stw	zero,-28(fp)
			break;
81103edc:	00000306 	br	81103eec <bSdmaDmaM1Transfer+0x25c>
		default:
			bStatus = FALSE;
81103ee0:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103ee4:	e03ff915 	stw	zero,-28(fp)
			break;
81103ee8:	0001883a 	nop
		}
		break;
81103eec:	00004106 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ef0:	e0bffd03 	ldbu	r2,-12(fp)
81103ef4:	10000826 	beq	r2,zero,81103f18 <bSdmaDmaM1Transfer+0x288>
81103ef8:	10800060 	cmpeqi	r2,r2,1
81103efc:	10000d26 	beq	r2,zero,81103f34 <bSdmaDmaM1Transfer+0x2a4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103f00:	00a80014 	movui	r2,40960
81103f04:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103f08:	00800044 	movi	r2,1
81103f0c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f10:	e03ff915 	stw	zero,-28(fp)
			break;
81103f14:	00000a06 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103f18:	008000b4 	movhi	r2,2
81103f1c:	10a80004 	addi	r2,r2,-24576
81103f20:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103f24:	00800044 	movi	r2,1
81103f28:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f2c:	e03ff915 	stw	zero,-28(fp)
			break;
81103f30:	00000306 	br	81103f40 <bSdmaDmaM1Transfer+0x2b0>
		default:
			bStatus = FALSE;
81103f34:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f38:	e03ff915 	stw	zero,-28(fp)
			break;
81103f3c:	0001883a 	nop
		}
		break;
81103f40:	00002c06 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103f44:	e0bffd03 	ldbu	r2,-12(fp)
81103f48:	10000826 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
81103f4c:	10800060 	cmpeqi	r2,r2,1
81103f50:	10000d26 	beq	r2,zero,81103f88 <bSdmaDmaM1Transfer+0x2f8>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103f54:	00b00014 	movui	r2,49152
81103f58:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f5c:	00800044 	movi	r2,1
81103f60:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f64:	e03ff915 	stw	zero,-28(fp)
			break;
81103f68:	00000a06 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f6c:	008000b4 	movhi	r2,2
81103f70:	10b00004 	addi	r2,r2,-16384
81103f74:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f78:	00800044 	movi	r2,1
81103f7c:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103f80:	e03ff915 	stw	zero,-28(fp)
			break;
81103f84:	00000306 	br	81103f94 <bSdmaDmaM1Transfer+0x304>
		default:
			bStatus = FALSE;
81103f88:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103f8c:	e03ff915 	stw	zero,-28(fp)
			break;
81103f90:	0001883a 	nop
		}
		break;
81103f94:	00001706 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f98:	e0bffd03 	ldbu	r2,-12(fp)
81103f9c:	10000826 	beq	r2,zero,81103fc0 <bSdmaDmaM1Transfer+0x330>
81103fa0:	10800060 	cmpeqi	r2,r2,1
81103fa4:	10000d26 	beq	r2,zero,81103fdc <bSdmaDmaM1Transfer+0x34c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103fa8:	00b80014 	movui	r2,57344
81103fac:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103fb0:	00800044 	movi	r2,1
81103fb4:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103fb8:	e03ff915 	stw	zero,-28(fp)
			break;
81103fbc:	00000a06 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103fc0:	008000b4 	movhi	r2,2
81103fc4:	10b80004 	addi	r2,r2,-8192
81103fc8:	e0bff515 	stw	r2,-44(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103fcc:	00800044 	movi	r2,1
81103fd0:	e0bff615 	stw	r2,-40(fp)
			bBufferEmptyFlag = FALSE;
81103fd4:	e03ff915 	stw	zero,-28(fp)
			break;
81103fd8:	00000306 	br	81103fe8 <bSdmaDmaM1Transfer+0x358>
		default:
			bStatus = FALSE;
81103fdc:	e03ff315 	stw	zero,-52(fp)
			bBufferEmptyFlag = FALSE;
81103fe0:	e03ff915 	stw	zero,-28(fp)
			break;
81103fe4:	0001883a 	nop
		}
		break;
81103fe8:	00000206 	br	81103ff4 <bSdmaDmaM1Transfer+0x364>
	default:
		bStatus = FALSE;
81103fec:	e03ff315 	stw	zero,-52(fp)
		break;
81103ff0:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103ff4:	e0bffb17 	ldw	r2,-20(fp)
81103ff8:	e0bff715 	stw	r2,-36(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103ffc:	e03ff815 	stw	zero,-32(fp)

	if ((bStatus) && (bBufferEmptyFlag)) {
81104000:	e0bff317 	ldw	r2,-52(fp)
81104004:	10003d26 	beq	r2,zero,811040fc <bSdmaDmaM1Transfer+0x46c>
81104008:	e0bff917 	ldw	r2,-28(fp)
8110400c:	10003b26 	beq	r2,zero,811040fc <bSdmaDmaM1Transfer+0x46c>
		if (pxDmaM1Dev == NULL) {
81104010:	d0a03917 	ldw	r2,-32540(gp)
81104014:	1000021e 	bne	r2,zero,81104020 <bSdmaDmaM1Transfer+0x390>
			bStatus = FALSE;
81104018:	e03ff315 	stw	zero,-52(fp)
8110401c:	00003706 	br	811040fc <bSdmaDmaM1Transfer+0x46c>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104020:	e03ff40d 	sth	zero,-48(fp)
81104024:	00003206 	br	811040f0 <bSdmaDmaM1Transfer+0x460>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81104028:	01000044 	movi	r4,1
8110402c:	11342a00 	call	811342a0 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81104030:	d0a03917 	ldw	r2,-32540(gp)
81104034:	10800317 	ldw	r2,12(r2)
81104038:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
8110403c:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104040:	103ff91e 	bne	r2,zero,81104028 <__reset+0xfb0e4028>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81104044:	d2203917 	ldw	r8,-32540(gp)
81104048:	e17ff717 	ldw	r5,-36(fp)
8110404c:	e1bff517 	ldw	r6,-44(fp)
81104050:	e0bff817 	ldw	r2,-32(fp)
81104054:	e0fff617 	ldw	r3,-40(fp)
81104058:	01000044 	movi	r4,1
8110405c:	d9000815 	stw	r4,32(sp)
81104060:	01000044 	movi	r4,1
81104064:	d9000715 	stw	r4,28(sp)
81104068:	01000044 	movi	r4,1
8110406c:	d9000615 	stw	r4,24(sp)
81104070:	01000044 	movi	r4,1
81104074:	d9000515 	stw	r4,20(sp)
81104078:	01000044 	movi	r4,1
8110407c:	d9000415 	stw	r4,16(sp)
81104080:	d8c00315 	stw	r3,12(sp)
81104084:	d8800215 	stw	r2,8(sp)
81104088:	e0bffa17 	ldw	r2,-24(fp)
8110408c:	d8800115 	stw	r2,4(sp)
81104090:	00802204 	movi	r2,136
81104094:	d8800015 	stw	r2,0(sp)
81104098:	300f883a 	mov	r7,r6
8110409c:	280d883a 	mov	r6,r5
811040a0:	800b883a 	mov	r5,r16
811040a4:	4009883a 	mov	r4,r8
811040a8:	110b7e40 	call	8110b7e4 <iMsgdmaConstructExtendedMmToMmDescriptor>
811040ac:	10000226 	beq	r2,zero,811040b8 <bSdmaDmaM1Transfer+0x428>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
811040b0:	e03ff315 	stw	zero,-52(fp)
					break;
811040b4:	00001106 	br	811040fc <bSdmaDmaM1Transfer+0x46c>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
811040b8:	d0a03917 	ldw	r2,-32540(gp)
811040bc:	800b883a 	mov	r5,r16
811040c0:	1009883a 	mov	r4,r2
811040c4:	110b8e80 	call	8110b8e8 <iMsgdmaExtendedDescriptorSyncTransfer>
811040c8:	10000226 	beq	r2,zero,811040d4 <bSdmaDmaM1Transfer+0x444>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811040cc:	e03ff315 	stw	zero,-52(fp)
						break;
811040d0:	00000a06 	br	811040fc <bSdmaDmaM1Transfer+0x46c>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
811040d4:	e0bff717 	ldw	r2,-36(fp)
811040d8:	10802204 	addi	r2,r2,136
811040dc:	e0bff715 	stw	r2,-36(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
811040e0:	e03ff815 	stw	zero,-32(fp)

	if ((bStatus) && (bBufferEmptyFlag)) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811040e4:	e0bff40b 	ldhu	r2,-48(fp)
811040e8:	10800044 	addi	r2,r2,1
811040ec:	e0bff40d 	sth	r2,-48(fp)
811040f0:	e0fff40b 	ldhu	r3,-48(fp)
811040f4:	e0bffc0b 	ldhu	r2,-16(fp)
811040f8:	18bfcd36 	bltu	r3,r2,81104030 <__reset+0xfb0e4030>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
811040fc:	e0bff317 	ldw	r2,-52(fp)
}
81104100:	e6ffff04 	addi	sp,fp,-4
81104104:	dfc00217 	ldw	ra,8(sp)
81104108:	df000117 	ldw	fp,4(sp)
8110410c:	dc000017 	ldw	r16,0(sp)
81104110:	dec00304 	addi	sp,sp,12
81104114:	f800283a 	ret

81104118 <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81104118:	deffe904 	addi	sp,sp,-92
8110411c:	de00012e 	bgeu	sp,et,81104124 <bSdmaDmaM2Transfer+0xc>
81104120:	003b68fa 	trap	3
81104124:	dfc01615 	stw	ra,88(sp)
81104128:	df001515 	stw	fp,84(sp)
8110412c:	dc001415 	stw	r16,80(sp)
81104130:	df001504 	addi	fp,sp,84
81104134:	e13ffb15 	stw	r4,-20(fp)
81104138:	2809883a 	mov	r4,r5
8110413c:	3007883a 	mov	r3,r6
81104140:	3805883a 	mov	r2,r7
81104144:	e13ffc0d 	sth	r4,-16(fp)
81104148:	e0fffd05 	stb	r3,-12(fp)
8110414c:	e0bffe05 	stb	r2,-8(fp)
81104150:	defff004 	addi	sp,sp,-64
81104154:	d8800904 	addi	r2,sp,36
81104158:	108007c4 	addi	r2,r2,31
8110415c:	1004d17a 	srli	r2,r2,5
81104160:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81104164:	00800044 	movi	r2,1
81104168:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
8110416c:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81104170:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81104174:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81104178:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
8110417c:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104180:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104184:	e0bffe03 	ldbu	r2,-8(fp)
81104188:	10c00228 	cmpgeui	r3,r2,8
8110418c:	18009c1e 	bne	r3,zero,81104400 <bSdmaDmaM2Transfer+0x2e8>
81104190:	100690ba 	slli	r3,r2,2
81104194:	00a04434 	movhi	r2,33040
81104198:	10906a04 	addi	r2,r2,16808
8110419c:	1885883a 	add	r2,r3,r2
811041a0:	10800017 	ldw	r2,0(r2)
811041a4:	1000683a 	jmp	r2
811041a8:	811041c8 	cmpgei	r4,r16,16647
811041ac:	81104208 	cmpgei	r4,r16,16648
811041b0:	81104250 	cmplti	r4,r16,16649
811041b4:	81104298 	cmpnei	r4,r16,16650
811041b8:	811042e0 	cmpeqi	r4,r16,16651
811041bc:	81104328 	cmpgeui	r4,r16,16652
811041c0:	81104370 	cmpltui	r4,r16,16653
811041c4:	811043b8 	rdprs	r4,r16,16654
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
811041c8:	e0bffd03 	ldbu	r2,-12(fp)
811041cc:	10000626 	beq	r2,zero,811041e8 <bSdmaDmaM2Transfer+0xd0>
811041d0:	10800060 	cmpeqi	r2,r2,1
811041d4:	10000926 	beq	r2,zero,811041fc <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
811041d8:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
811041dc:	00800044 	movi	r2,1
811041e0:	e0bff715 	stw	r2,-36(fp)
			break;
811041e4:	00000706 	br	81104204 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
811041e8:	00800074 	movhi	r2,1
811041ec:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
811041f0:	00800044 	movi	r2,1
811041f4:	e0bff715 	stw	r2,-36(fp)
			break;
811041f8:	00000206 	br	81104204 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
811041fc:	e03ff415 	stw	zero,-48(fp)
			break;
81104200:	0001883a 	nop
		}
		break;
81104204:	00008006 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81104208:	e0bffd03 	ldbu	r2,-12(fp)
8110420c:	10000726 	beq	r2,zero,8110422c <bSdmaDmaM2Transfer+0x114>
81104210:	10800060 	cmpeqi	r2,r2,1
81104214:	10000b26 	beq	r2,zero,81104244 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81104218:	00880004 	movi	r2,8192
8110421c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81104220:	00800044 	movi	r2,1
81104224:	e0bff715 	stw	r2,-36(fp)
			break;
81104228:	00000806 	br	8110424c <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
8110422c:	00800074 	movhi	r2,1
81104230:	10880004 	addi	r2,r2,8192
81104234:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81104238:	00800044 	movi	r2,1
8110423c:	e0bff715 	stw	r2,-36(fp)
			break;
81104240:	00000206 	br	8110424c <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
81104244:	e03ff415 	stw	zero,-48(fp)
			break;
81104248:	0001883a 	nop
		}
		break;
8110424c:	00006e06 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81104250:	e0bffd03 	ldbu	r2,-12(fp)
81104254:	10000726 	beq	r2,zero,81104274 <bSdmaDmaM2Transfer+0x15c>
81104258:	10800060 	cmpeqi	r2,r2,1
8110425c:	10000b26 	beq	r2,zero,8110428c <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81104260:	00900004 	movi	r2,16384
81104264:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81104268:	00800044 	movi	r2,1
8110426c:	e0bff715 	stw	r2,-36(fp)
			break;
81104270:	00000806 	br	81104294 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81104274:	00800074 	movhi	r2,1
81104278:	10900004 	addi	r2,r2,16384
8110427c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104280:	00800044 	movi	r2,1
81104284:	e0bff715 	stw	r2,-36(fp)
			break;
81104288:	00000206 	br	81104294 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
8110428c:	e03ff415 	stw	zero,-48(fp)
			break;
81104290:	0001883a 	nop
		}
		break;
81104294:	00005c06 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81104298:	e0bffd03 	ldbu	r2,-12(fp)
8110429c:	10000726 	beq	r2,zero,811042bc <bSdmaDmaM2Transfer+0x1a4>
811042a0:	10800060 	cmpeqi	r2,r2,1
811042a4:	10000b26 	beq	r2,zero,811042d4 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
811042a8:	00980004 	movi	r2,24576
811042ac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
811042b0:	00800044 	movi	r2,1
811042b4:	e0bff715 	stw	r2,-36(fp)
			break;
811042b8:	00000806 	br	811042dc <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
811042bc:	00800074 	movhi	r2,1
811042c0:	10980004 	addi	r2,r2,24576
811042c4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
811042c8:	00800044 	movi	r2,1
811042cc:	e0bff715 	stw	r2,-36(fp)
			break;
811042d0:	00000206 	br	811042dc <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
811042d4:	e03ff415 	stw	zero,-48(fp)
			break;
811042d8:	0001883a 	nop
		}
		break;
811042dc:	00004a06 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
811042e0:	e0bffd03 	ldbu	r2,-12(fp)
811042e4:	10000726 	beq	r2,zero,81104304 <bSdmaDmaM2Transfer+0x1ec>
811042e8:	10800060 	cmpeqi	r2,r2,1
811042ec:	10000b26 	beq	r2,zero,8110431c <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
811042f0:	00a00014 	movui	r2,32768
811042f4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
811042f8:	00800044 	movi	r2,1
811042fc:	e0bff715 	stw	r2,-36(fp)
			break;
81104300:	00000806 	br	81104324 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104304:	008000b4 	movhi	r2,2
81104308:	10a00004 	addi	r2,r2,-32768
8110430c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104310:	00800044 	movi	r2,1
81104314:	e0bff715 	stw	r2,-36(fp)
			break;
81104318:	00000206 	br	81104324 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
8110431c:	e03ff415 	stw	zero,-48(fp)
			break;
81104320:	0001883a 	nop
		}
		break;
81104324:	00003806 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81104328:	e0bffd03 	ldbu	r2,-12(fp)
8110432c:	10000726 	beq	r2,zero,8110434c <bSdmaDmaM2Transfer+0x234>
81104330:	10800060 	cmpeqi	r2,r2,1
81104334:	10000b26 	beq	r2,zero,81104364 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81104338:	00a80014 	movui	r2,40960
8110433c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81104340:	00800044 	movi	r2,1
81104344:	e0bff715 	stw	r2,-36(fp)
			break;
81104348:	00000806 	br	8110436c <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
8110434c:	008000b4 	movhi	r2,2
81104350:	10a80004 	addi	r2,r2,-24576
81104354:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81104358:	00800044 	movi	r2,1
8110435c:	e0bff715 	stw	r2,-36(fp)
			break;
81104360:	00000206 	br	8110436c <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
81104364:	e03ff415 	stw	zero,-48(fp)
			break;
81104368:	0001883a 	nop
		}
		break;
8110436c:	00002606 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81104370:	e0bffd03 	ldbu	r2,-12(fp)
81104374:	10000726 	beq	r2,zero,81104394 <bSdmaDmaM2Transfer+0x27c>
81104378:	10800060 	cmpeqi	r2,r2,1
8110437c:	10000b26 	beq	r2,zero,811043ac <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104380:	00b00014 	movui	r2,49152
81104384:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81104388:	00800044 	movi	r2,1
8110438c:	e0bff715 	stw	r2,-36(fp)
			break;
81104390:	00000806 	br	811043b4 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104394:	008000b4 	movhi	r2,2
81104398:	10b00004 	addi	r2,r2,-16384
8110439c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
811043a0:	00800044 	movi	r2,1
811043a4:	e0bff715 	stw	r2,-36(fp)
			break;
811043a8:	00000206 	br	811043b4 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
811043ac:	e03ff415 	stw	zero,-48(fp)
			break;
811043b0:	0001883a 	nop
		}
		break;
811043b4:	00001406 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
811043b8:	e0bffd03 	ldbu	r2,-12(fp)
811043bc:	10000726 	beq	r2,zero,811043dc <bSdmaDmaM2Transfer+0x2c4>
811043c0:	10800060 	cmpeqi	r2,r2,1
811043c4:	10000b26 	beq	r2,zero,811043f4 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
811043c8:	00b80014 	movui	r2,57344
811043cc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
811043d0:	00800044 	movi	r2,1
811043d4:	e0bff715 	stw	r2,-36(fp)
			break;
811043d8:	00000806 	br	811043fc <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
811043dc:	008000b4 	movhi	r2,2
811043e0:	10b80004 	addi	r2,r2,-8192
811043e4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
811043e8:	00800044 	movi	r2,1
811043ec:	e0bff715 	stw	r2,-36(fp)
			break;
811043f0:	00000206 	br	811043fc <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
811043f4:	e03ff415 	stw	zero,-48(fp)
			break;
811043f8:	0001883a 	nop
		}
		break;
811043fc:	00000206 	br	81104408 <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104400:	e03ff415 	stw	zero,-48(fp)
		break;
81104404:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
81104408:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
8110440c:	00a00034 	movhi	r2,32768
81104410:	1885883a 	add	r2,r3,r2
81104414:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104418:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
8110441c:	e0bff417 	ldw	r2,-48(fp)
81104420:	10003b26 	beq	r2,zero,81104510 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
81104424:	d0a03a17 	ldw	r2,-32536(gp)
81104428:	1000021e 	bne	r2,zero,81104434 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
8110442c:	e03ff415 	stw	zero,-48(fp)
81104430:	00003706 	br	81104510 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104434:	e03ff50d 	sth	zero,-44(fp)
81104438:	00003206 	br	81104504 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
8110443c:	01000044 	movi	r4,1
81104440:	11342a00 	call	811342a0 <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81104444:	d0a03a17 	ldw	r2,-32536(gp)
81104448:	10800317 	ldw	r2,12(r2)
8110444c:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81104450:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81104454:	103ff91e 	bne	r2,zero,8110443c <__reset+0xfb0e443c>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
81104458:	d2203a17 	ldw	r8,-32536(gp)
8110445c:	e17ff817 	ldw	r5,-32(fp)
81104460:	e1bff617 	ldw	r6,-40(fp)
81104464:	e0bff917 	ldw	r2,-28(fp)
81104468:	e0fff717 	ldw	r3,-36(fp)
8110446c:	01000044 	movi	r4,1
81104470:	d9000815 	stw	r4,32(sp)
81104474:	01000044 	movi	r4,1
81104478:	d9000715 	stw	r4,28(sp)
8110447c:	01000044 	movi	r4,1
81104480:	d9000615 	stw	r4,24(sp)
81104484:	01000044 	movi	r4,1
81104488:	d9000515 	stw	r4,20(sp)
8110448c:	01000044 	movi	r4,1
81104490:	d9000415 	stw	r4,16(sp)
81104494:	d8c00315 	stw	r3,12(sp)
81104498:	d8800215 	stw	r2,8(sp)
8110449c:	e0bffa17 	ldw	r2,-24(fp)
811044a0:	d8800115 	stw	r2,4(sp)
811044a4:	00802204 	movi	r2,136
811044a8:	d8800015 	stw	r2,0(sp)
811044ac:	300f883a 	mov	r7,r6
811044b0:	280d883a 	mov	r6,r5
811044b4:	800b883a 	mov	r5,r16
811044b8:	4009883a 	mov	r4,r8
811044bc:	110b7e40 	call	8110b7e4 <iMsgdmaConstructExtendedMmToMmDescriptor>
811044c0:	10000226 	beq	r2,zero,811044cc <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
811044c4:	e03ff415 	stw	zero,-48(fp)
					break;
811044c8:	00001106 	br	81104510 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
811044cc:	d0a03a17 	ldw	r2,-32536(gp)
811044d0:	800b883a 	mov	r5,r16
811044d4:	1009883a 	mov	r4,r2
811044d8:	110b8e80 	call	8110b8e8 <iMsgdmaExtendedDescriptorSyncTransfer>
811044dc:	10000226 	beq	r2,zero,811044e8 <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
811044e0:	e03ff415 	stw	zero,-48(fp)
						break;
811044e4:	00000a06 	br	81104510 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
811044e8:	e0bff817 	ldw	r2,-32(fp)
811044ec:	10802204 	addi	r2,r2,136
811044f0:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
811044f4:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811044f8:	e0bff50b 	ldhu	r2,-44(fp)
811044fc:	10800044 	addi	r2,r2,1
81104500:	e0bff50d 	sth	r2,-44(fp)
81104504:	e0fff50b 	ldhu	r3,-44(fp)
81104508:	e0bffc0b 	ldhu	r2,-16(fp)
8110450c:	18bfcd36 	bltu	r3,r2,81104444 <__reset+0xfb0e4444>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104510:	e0bff417 	ldw	r2,-48(fp)
}
81104514:	e6ffff04 	addi	sp,fp,-4
81104518:	dfc00217 	ldw	ra,8(sp)
8110451c:	df000117 	ldw	fp,4(sp)
81104520:	dc000017 	ldw	r16,0(sp)
81104524:	dec00304 	addi	sp,sp,12
81104528:	f800283a 	ret

8110452c <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
8110452c:	defff904 	addi	sp,sp,-28
81104530:	de00012e 	bgeu	sp,et,81104538 <bCommSetGlobalIrqEn+0xc>
81104534:	003b68fa 	trap	3
81104538:	dfc00615 	stw	ra,24(sp)
8110453c:	df000515 	stw	fp,20(sp)
81104540:	df000504 	addi	fp,sp,20
81104544:	e13ffe15 	stw	r4,-8(fp)
81104548:	2805883a 	mov	r2,r5
8110454c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104550:	00800044 	movi	r2,1
81104554:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
81104558:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
8110455c:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
81104560:	e0bfff03 	ldbu	r2,-4(fp)
81104564:	10c00228 	cmpgeui	r3,r2,8
81104568:	18002e1e 	bne	r3,zero,81104624 <bCommSetGlobalIrqEn+0xf8>
8110456c:	100690ba 	slli	r3,r2,2
81104570:	00a04434 	movhi	r2,33040
81104574:	10916104 	addi	r2,r2,17796
81104578:	1885883a 	add	r2,r3,r2
8110457c:	10800017 	ldw	r2,0(r2)
81104580:	1000683a 	jmp	r2
81104584:	811045a4 	muli	r4,r16,16662
81104588:	811045b4 	orhi	r4,r16,16662
8110458c:	811045c4 	addi	r4,r16,16663
81104590:	811045d4 	ori	r4,r16,16663
81104594:	811045e4 	muli	r4,r16,16663
81104598:	811045f4 	orhi	r4,r16,16663
8110459c:	81104604 	addi	r4,r16,16664
811045a0:	81104614 	ori	r4,r16,16664
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
811045a4:	00a04834 	movhi	r2,33056
811045a8:	108b0004 	addi	r2,r2,11264
811045ac:	e0bffd15 	stw	r2,-12(fp)
		break;
811045b0:	00001e06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
811045b4:	00a04834 	movhi	r2,33056
811045b8:	108a0004 	addi	r2,r2,10240
811045bc:	e0bffd15 	stw	r2,-12(fp)
		break;
811045c0:	00001a06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
811045c4:	00a04834 	movhi	r2,33056
811045c8:	108b0004 	addi	r2,r2,11264
811045cc:	e0bffd15 	stw	r2,-12(fp)
		break;
811045d0:	00001606 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
811045d4:	00a04834 	movhi	r2,33056
811045d8:	108a0004 	addi	r2,r2,10240
811045dc:	e0bffd15 	stw	r2,-12(fp)
		break;
811045e0:	00001206 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
811045e4:	00a04834 	movhi	r2,33056
811045e8:	108b0004 	addi	r2,r2,11264
811045ec:	e0bffd15 	stw	r2,-12(fp)
		break;
811045f0:	00000e06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811045f4:	00a04834 	movhi	r2,33056
811045f8:	108a0004 	addi	r2,r2,10240
811045fc:	e0bffd15 	stw	r2,-12(fp)
		break;
81104600:	00000a06 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104604:	00a04834 	movhi	r2,33056
81104608:	108b0004 	addi	r2,r2,11264
8110460c:	e0bffd15 	stw	r2,-12(fp)
		break;
81104610:	00000606 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104614:	00a04834 	movhi	r2,33056
81104618:	108a0004 	addi	r2,r2,10240
8110461c:	e0bffd15 	stw	r2,-12(fp)
		break;
81104620:	00000206 	br	8110462c <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
81104624:	e03ffb15 	stw	zero,-20(fp)
		break;
81104628:	0001883a 	nop
	}

	if (bStatus) {
8110462c:	e0bffb17 	ldw	r2,-20(fp)
81104630:	10001326 	beq	r2,zero,81104680 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
81104634:	01400444 	movi	r5,17
81104638:	e13ffd17 	ldw	r4,-12(fp)
8110463c:	11047c80 	call	811047c8 <uliCommReadReg>
81104640:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
81104644:	e0bffe17 	ldw	r2,-8(fp)
81104648:	10000426 	beq	r2,zero,8110465c <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
8110464c:	e0bffc17 	ldw	r2,-16(fp)
81104650:	10800074 	orhi	r2,r2,1
81104654:	e0bffc15 	stw	r2,-16(fp)
81104658:	00000506 	br	81104670 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
8110465c:	e0fffc17 	ldw	r3,-16(fp)
81104660:	00bffff4 	movhi	r2,65535
81104664:	10bfffc4 	addi	r2,r2,-1
81104668:	1884703a 	and	r2,r3,r2
8110466c:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
81104670:	e1bffc17 	ldw	r6,-16(fp)
81104674:	01400444 	movi	r5,17
81104678:	e13ffd17 	ldw	r4,-12(fp)
8110467c:	11047740 	call	81104774 <vCommWriteReg>
	}

	return bStatus;
81104680:	e0bffb17 	ldw	r2,-20(fp)
}
81104684:	e037883a 	mov	sp,fp
81104688:	dfc00117 	ldw	ra,4(sp)
8110468c:	df000017 	ldw	fp,0(sp)
81104690:	dec00204 	addi	sp,sp,8
81104694:	f800283a 	ret

81104698 <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
81104698:	defffb04 	addi	sp,sp,-20
8110469c:	de00012e 	bgeu	sp,et,811046a4 <bCommInitCh+0xc>
811046a0:	003b68fa 	trap	3
811046a4:	dfc00415 	stw	ra,16(sp)
811046a8:	df000315 	stw	fp,12(sp)
811046ac:	df000304 	addi	fp,sp,12
811046b0:	e13ffe15 	stw	r4,-8(fp)
811046b4:	2805883a 	mov	r2,r5
811046b8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811046bc:	00800044 	movi	r2,1
811046c0:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
811046c4:	e0bffe17 	ldw	r2,-8(fp)
811046c8:	10805704 	addi	r2,r2,348
811046cc:	e0ffff03 	ldbu	r3,-4(fp)
811046d0:	180b883a 	mov	r5,r3
811046d4:	1009883a 	mov	r4,r2
811046d8:	110a1680 	call	8110a168 <bSpwcInitCh>
811046dc:	1000011e 	bne	r2,zero,811046e4 <bCommInitCh+0x4c>
		bStatus = FALSE;
811046e0:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
811046e4:	e0bfff03 	ldbu	r2,-4(fp)
811046e8:	1009883a 	mov	r4,r2
811046ec:	1105f2c0 	call	81105f2c <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
811046f0:	e0bffe17 	ldw	r2,-8(fp)
811046f4:	10800904 	addi	r2,r2,36
811046f8:	e0ffff03 	ldbu	r3,-4(fp)
811046fc:	180b883a 	mov	r5,r3
81104700:	1009883a 	mov	r4,r2
81104704:	11069f40 	call	811069f4 <bFeebInitCh>
81104708:	1000011e 	bne	r2,zero,81104710 <bCommInitCh+0x78>
		bStatus = FALSE;
8110470c:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104710:	e0bffe17 	ldw	r2,-8(fp)
81104714:	10801104 	addi	r2,r2,68
81104718:	e0ffff03 	ldbu	r3,-4(fp)
8110471c:	180b883a 	mov	r5,r3
81104720:	1009883a 	mov	r4,r2
81104724:	11097c40 	call	811097c4 <bRmapInitCh>
81104728:	1000011e 	bne	r2,zero,81104730 <bCommInitCh+0x98>
		bStatus = FALSE;
8110472c:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
81104730:	e0bfff03 	ldbu	r2,-4(fp)
81104734:	1009883a 	mov	r4,r2
81104738:	11076000 	call	81107600 <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
8110473c:	e0bffe17 	ldw	r2,-8(fp)
81104740:	10800104 	addi	r2,r2,4
81104744:	e0ffff03 	ldbu	r3,-4(fp)
81104748:	180b883a 	mov	r5,r3
8110474c:	1009883a 	mov	r4,r2
81104750:	1104e400 	call	81104e40 <bDpktInitCh>
81104754:	1000011e 	bne	r2,zero,8110475c <bCommInitCh+0xc4>
		bStatus = FALSE;
81104758:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
8110475c:	e0bffd17 	ldw	r2,-12(fp)
}
81104760:	e037883a 	mov	sp,fp
81104764:	dfc00117 	ldw	ra,4(sp)
81104768:	df000017 	ldw	fp,0(sp)
8110476c:	dec00204 	addi	sp,sp,8
81104770:	f800283a 	ret

81104774 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104774:	defffc04 	addi	sp,sp,-16
81104778:	de00012e 	bgeu	sp,et,81104780 <vCommWriteReg+0xc>
8110477c:	003b68fa 	trap	3
81104780:	df000315 	stw	fp,12(sp)
81104784:	df000304 	addi	fp,sp,12
81104788:	e13ffd15 	stw	r4,-12(fp)
8110478c:	e17ffe15 	stw	r5,-8(fp)
81104790:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104794:	e0bffe17 	ldw	r2,-8(fp)
81104798:	1085883a 	add	r2,r2,r2
8110479c:	1085883a 	add	r2,r2,r2
811047a0:	1007883a 	mov	r3,r2
811047a4:	e0bffd17 	ldw	r2,-12(fp)
811047a8:	10c5883a 	add	r2,r2,r3
811047ac:	e0ffff17 	ldw	r3,-4(fp)
811047b0:	10c00015 	stw	r3,0(r2)
}
811047b4:	0001883a 	nop
811047b8:	e037883a 	mov	sp,fp
811047bc:	df000017 	ldw	fp,0(sp)
811047c0:	dec00104 	addi	sp,sp,4
811047c4:	f800283a 	ret

811047c8 <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811047c8:	defffc04 	addi	sp,sp,-16
811047cc:	de00012e 	bgeu	sp,et,811047d4 <uliCommReadReg+0xc>
811047d0:	003b68fa 	trap	3
811047d4:	df000315 	stw	fp,12(sp)
811047d8:	df000304 	addi	fp,sp,12
811047dc:	e13ffe15 	stw	r4,-8(fp)
811047e0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811047e4:	e0bfff17 	ldw	r2,-4(fp)
811047e8:	1085883a 	add	r2,r2,r2
811047ec:	1085883a 	add	r2,r2,r2
811047f0:	1007883a 	mov	r3,r2
811047f4:	e0bffe17 	ldw	r2,-8(fp)
811047f8:	10c5883a 	add	r2,r2,r3
811047fc:	10800017 	ldw	r2,0(r2)
81104800:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104804:	e0bffd17 	ldw	r2,-12(fp)
}
81104808:	e037883a 	mov	sp,fp
8110480c:	df000017 	ldw	fp,0(sp)
81104810:	dec00104 	addi	sp,sp,4
81104814:	f800283a 	ret

81104818 <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
81104818:	defffb04 	addi	sp,sp,-20
8110481c:	de00012e 	bgeu	sp,et,81104824 <bDpktSetPacketConfig+0xc>
81104820:	003b68fa 	trap	3
81104824:	dfc00415 	stw	ra,16(sp)
81104828:	df000315 	stw	fp,12(sp)
8110482c:	df000304 	addi	fp,sp,12
81104830:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104834:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104838:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
8110483c:	e0bfff17 	ldw	r2,-4(fp)
81104840:	10007a26 	beq	r2,zero,81104a2c <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104844:	e0bfff17 	ldw	r2,-4(fp)
81104848:	10800017 	ldw	r2,0(r2)
8110484c:	01400204 	movi	r5,8
81104850:	1009883a 	mov	r4,r2
81104854:	11050080 	call	81105008 <uliDpktReadReg>
81104858:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
8110485c:	e0bffe17 	ldw	r2,-8(fp)
81104860:	10bfffec 	andhi	r2,r2,65535
81104864:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
81104868:	e0bfff17 	ldw	r2,-4(fp)
8110486c:	1080010b 	ldhu	r2,4(r2)
81104870:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
81104874:	e0fffe17 	ldw	r3,-8(fp)
81104878:	1884b03a 	or	r2,r3,r2
8110487c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104880:	e0bffe17 	ldw	r2,-8(fp)
81104884:	10bfffcc 	andi	r2,r2,65535
81104888:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
8110488c:	e0bfff17 	ldw	r2,-4(fp)
81104890:	1080018b 	ldhu	r2,6(r2)
81104894:	10bfffcc 	andi	r2,r2,65535
81104898:	1004943a 	slli	r2,r2,16
8110489c:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
811048a0:	e0bffe17 	ldw	r2,-8(fp)
811048a4:	10c4b03a 	or	r2,r2,r3
811048a8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
811048ac:	e0bfff17 	ldw	r2,-4(fp)
811048b0:	10800017 	ldw	r2,0(r2)
811048b4:	e1bffe17 	ldw	r6,-8(fp)
811048b8:	01400204 	movi	r5,8
811048bc:	1009883a 	mov	r4,r2
811048c0:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048c4:	e0bfff17 	ldw	r2,-4(fp)
811048c8:	10800017 	ldw	r2,0(r2)
811048cc:	01400244 	movi	r5,9
811048d0:	1009883a 	mov	r4,r2
811048d4:	11050080 	call	81105008 <uliDpktReadReg>
811048d8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
811048dc:	e0bffe17 	ldw	r2,-8(fp)
811048e0:	10bfffec 	andhi	r2,r2,65535
811048e4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
811048e8:	e0bfff17 	ldw	r2,-4(fp)
811048ec:	1080020b 	ldhu	r2,8(r2)
811048f0:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
811048f4:	e0fffe17 	ldw	r3,-8(fp)
811048f8:	1884b03a 	or	r2,r3,r2
811048fc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104900:	e0bffe17 	ldw	r2,-8(fp)
81104904:	10bfffcc 	andi	r2,r2,65535
81104908:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
8110490c:	e0bfff17 	ldw	r2,-4(fp)
81104910:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104914:	10bfffcc 	andi	r2,r2,65535
81104918:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
8110491c:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
81104920:	e0bffe17 	ldw	r2,-8(fp)
81104924:	10c4b03a 	or	r2,r2,r3
81104928:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
8110492c:	e0bfff17 	ldw	r2,-4(fp)
81104930:	10800017 	ldw	r2,0(r2)
81104934:	e1bffe17 	ldw	r6,-8(fp)
81104938:	01400244 	movi	r5,9
8110493c:	1009883a 	mov	r4,r2
81104940:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10800017 	ldw	r2,0(r2)
8110494c:	01400284 	movi	r5,10
81104950:	1009883a 	mov	r4,r2
81104954:	11050080 	call	81105008 <uliDpktReadReg>
81104958:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
8110495c:	e0bffe17 	ldw	r2,-8(fp)
81104960:	10bfffec 	andhi	r2,r2,65535
81104964:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
81104968:	e0bfff17 	ldw	r2,-4(fp)
8110496c:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
81104970:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
81104974:	e0fffe17 	ldw	r3,-8(fp)
81104978:	1884b03a 	or	r2,r3,r2
8110497c:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104980:	e0bfff17 	ldw	r2,-4(fp)
81104984:	10800017 	ldw	r2,0(r2)
81104988:	e1bffe17 	ldw	r6,-8(fp)
8110498c:	01400284 	movi	r5,10
81104990:	1009883a 	mov	r4,r2
81104994:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104998:	e0bfff17 	ldw	r2,-4(fp)
8110499c:	10800017 	ldw	r2,0(r2)
811049a0:	014002c4 	movi	r5,11
811049a4:	1009883a 	mov	r4,r2
811049a8:	11050080 	call	81105008 <uliDpktReadReg>
811049ac:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
811049b0:	e0fffe17 	ldw	r3,-8(fp)
811049b4:	00bfc004 	movi	r2,-256
811049b8:	1884703a 	and	r2,r3,r2
811049bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
811049c0:	e0bfff17 	ldw	r2,-4(fp)
811049c4:	10800383 	ldbu	r2,14(r2)
811049c8:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
811049cc:	e0fffe17 	ldw	r3,-8(fp)
811049d0:	1884b03a 	or	r2,r3,r2
811049d4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
811049d8:	e0fffe17 	ldw	r3,-8(fp)
811049dc:	00bffff4 	movhi	r2,65535
811049e0:	10803fc4 	addi	r2,r2,255
811049e4:	1884703a 	and	r2,r3,r2
811049e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
811049ec:	e0bfff17 	ldw	r2,-4(fp)
811049f0:	108003c3 	ldbu	r2,15(r2)
811049f4:	10803fcc 	andi	r2,r2,255
811049f8:	1004923a 	slli	r2,r2,8
811049fc:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104a00:	e0fffe17 	ldw	r3,-8(fp)
81104a04:	1884b03a 	or	r2,r3,r2
81104a08:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104a0c:	e0bfff17 	ldw	r2,-4(fp)
81104a10:	10800017 	ldw	r2,0(r2)
81104a14:	e1bffe17 	ldw	r6,-8(fp)
81104a18:	014002c4 	movi	r5,11
81104a1c:	1009883a 	mov	r4,r2
81104a20:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104a24:	00800044 	movi	r2,1
81104a28:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81104a30:	e037883a 	mov	sp,fp
81104a34:	dfc00117 	ldw	ra,4(sp)
81104a38:	df000017 	ldw	fp,0(sp)
81104a3c:	dec00204 	addi	sp,sp,8
81104a40:	f800283a 	ret

81104a44 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
81104a44:	defffb04 	addi	sp,sp,-20
81104a48:	de00012e 	bgeu	sp,et,81104a50 <bDpktGetPacketConfig+0xc>
81104a4c:	003b68fa 	trap	3
81104a50:	dfc00415 	stw	ra,16(sp)
81104a54:	df000315 	stw	fp,12(sp)
81104a58:	df000304 	addi	fp,sp,12
81104a5c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104a60:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104a64:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104a68:	e0bfff17 	ldw	r2,-4(fp)
81104a6c:	10003a26 	beq	r2,zero,81104b58 <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a70:	e0bfff17 	ldw	r2,-4(fp)
81104a74:	10800017 	ldw	r2,0(r2)
81104a78:	01400204 	movi	r5,8
81104a7c:	1009883a 	mov	r4,r2
81104a80:	11050080 	call	81105008 <uliDpktReadReg>
81104a84:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104a88:	e0bffe17 	ldw	r2,-8(fp)
81104a8c:	1007883a 	mov	r3,r2
81104a90:	e0bfff17 	ldw	r2,-4(fp)
81104a94:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104a98:	e0bffe17 	ldw	r2,-8(fp)
81104a9c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104aa0:	1007883a 	mov	r3,r2
81104aa4:	e0bfff17 	ldw	r2,-4(fp)
81104aa8:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104aac:	e0bfff17 	ldw	r2,-4(fp)
81104ab0:	10800017 	ldw	r2,0(r2)
81104ab4:	01400244 	movi	r5,9
81104ab8:	1009883a 	mov	r4,r2
81104abc:	11050080 	call	81105008 <uliDpktReadReg>
81104ac0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104ac4:	e0bffe17 	ldw	r2,-8(fp)
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104ad4:	e0bffe17 	ldw	r2,-8(fp)
81104ad8:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104adc:	1007883a 	mov	r3,r2
81104ae0:	e0bfff17 	ldw	r2,-4(fp)
81104ae4:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104ae8:	e0bfff17 	ldw	r2,-4(fp)
81104aec:	10800017 	ldw	r2,0(r2)
81104af0:	01400284 	movi	r5,10
81104af4:	1009883a 	mov	r4,r2
81104af8:	11050080 	call	81105008 <uliDpktReadReg>
81104afc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104b00:	e0bffe17 	ldw	r2,-8(fp)
81104b04:	1007883a 	mov	r3,r2
81104b08:	e0bfff17 	ldw	r2,-4(fp)
81104b0c:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b10:	e0bfff17 	ldw	r2,-4(fp)
81104b14:	10800017 	ldw	r2,0(r2)
81104b18:	014002c4 	movi	r5,11
81104b1c:	1009883a 	mov	r4,r2
81104b20:	11050080 	call	81105008 <uliDpktReadReg>
81104b24:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104b28:	e0bffe17 	ldw	r2,-8(fp)
81104b2c:	1007883a 	mov	r3,r2
81104b30:	e0bfff17 	ldw	r2,-4(fp)
81104b34:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104b38:	e0bffe17 	ldw	r2,-8(fp)
81104b3c:	10bfc00c 	andi	r2,r2,65280
81104b40:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104b44:	1007883a 	mov	r3,r2
81104b48:	e0bfff17 	ldw	r2,-4(fp)
81104b4c:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104b50:	00800044 	movi	r2,1
81104b54:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104b58:	e0bffd17 	ldw	r2,-12(fp)
}
81104b5c:	e037883a 	mov	sp,fp
81104b60:	dfc00117 	ldw	ra,4(sp)
81104b64:	df000017 	ldw	fp,0(sp)
81104b68:	dec00204 	addi	sp,sp,8
81104b6c:	f800283a 	ret

81104b70 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104b70:	defffb04 	addi	sp,sp,-20
81104b74:	de00012e 	bgeu	sp,et,81104b7c <bDpktGetPacketHeader+0xc>
81104b78:	003b68fa 	trap	3
81104b7c:	dfc00415 	stw	ra,16(sp)
81104b80:	df000315 	stw	fp,12(sp)
81104b84:	df000304 	addi	fp,sp,12
81104b88:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b8c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b90:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b94:	e0bfff17 	ldw	r2,-4(fp)
81104b98:	10002026 	beq	r2,zero,81104c1c <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b9c:	e0bfff17 	ldw	r2,-4(fp)
81104ba0:	10800017 	ldw	r2,0(r2)
81104ba4:	01400304 	movi	r5,12
81104ba8:	1009883a 	mov	r4,r2
81104bac:	11050080 	call	81105008 <uliDpktReadReg>
81104bb0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104bb4:	e0bffe17 	ldw	r2,-8(fp)
81104bb8:	1007883a 	mov	r3,r2
81104bbc:	e0bfff17 	ldw	r2,-4(fp)
81104bc0:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104bc4:	e0bffe17 	ldw	r2,-8(fp)
81104bc8:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104bcc:	1007883a 	mov	r3,r2
81104bd0:	e0bfff17 	ldw	r2,-4(fp)
81104bd4:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104bd8:	e0bfff17 	ldw	r2,-4(fp)
81104bdc:	10800017 	ldw	r2,0(r2)
81104be0:	01400344 	movi	r5,13
81104be4:	1009883a 	mov	r4,r2
81104be8:	11050080 	call	81105008 <uliDpktReadReg>
81104bec:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104bf0:	e0bffe17 	ldw	r2,-8(fp)
81104bf4:	1007883a 	mov	r3,r2
81104bf8:	e0bfff17 	ldw	r2,-4(fp)
81104bfc:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104c00:	e0bffe17 	ldw	r2,-8(fp)
81104c04:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104c08:	1007883a 	mov	r3,r2
81104c0c:	e0bfff17 	ldw	r2,-4(fp)
81104c10:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104c14:	00800044 	movi	r2,1
81104c18:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104c1c:	e0bffd17 	ldw	r2,-12(fp)
}
81104c20:	e037883a 	mov	sp,fp
81104c24:	dfc00117 	ldw	ra,4(sp)
81104c28:	df000017 	ldw	fp,0(sp)
81104c2c:	dec00204 	addi	sp,sp,8
81104c30:	f800283a 	ret

81104c34 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104c34:	defffb04 	addi	sp,sp,-20
81104c38:	de00012e 	bgeu	sp,et,81104c40 <bDpktSetPixelDelay+0xc>
81104c3c:	003b68fa 	trap	3
81104c40:	dfc00415 	stw	ra,16(sp)
81104c44:	df000315 	stw	fp,12(sp)
81104c48:	df000304 	addi	fp,sp,12
81104c4c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104c50:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104c54:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104c58:	e0bfff17 	ldw	r2,-4(fp)
81104c5c:	10004126 	beq	r2,zero,81104d64 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c60:	e0bfff17 	ldw	r2,-4(fp)
81104c64:	10800017 	ldw	r2,0(r2)
81104c68:	01400384 	movi	r5,14
81104c6c:	1009883a 	mov	r4,r2
81104c70:	11050080 	call	81105008 <uliDpktReadReg>
81104c74:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104c78:	e0bffe17 	ldw	r2,-8(fp)
81104c7c:	10bfffec 	andhi	r2,r2,65535
81104c80:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104c84:	e0bfff17 	ldw	r2,-4(fp)
81104c88:	1080060b 	ldhu	r2,24(r2)
81104c8c:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104c90:	e0fffe17 	ldw	r3,-8(fp)
81104c94:	1884b03a 	or	r2,r3,r2
81104c98:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104c9c:	e0bfff17 	ldw	r2,-4(fp)
81104ca0:	10800017 	ldw	r2,0(r2)
81104ca4:	e1bffe17 	ldw	r6,-8(fp)
81104ca8:	01400384 	movi	r5,14
81104cac:	1009883a 	mov	r4,r2
81104cb0:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104cb4:	e0bfff17 	ldw	r2,-4(fp)
81104cb8:	10800017 	ldw	r2,0(r2)
81104cbc:	014003c4 	movi	r5,15
81104cc0:	1009883a 	mov	r4,r2
81104cc4:	11050080 	call	81105008 <uliDpktReadReg>
81104cc8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104ccc:	e0bffe17 	ldw	r2,-8(fp)
81104cd0:	10bfffec 	andhi	r2,r2,65535
81104cd4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104cd8:	e0bfff17 	ldw	r2,-4(fp)
81104cdc:	1080068b 	ldhu	r2,26(r2)
81104ce0:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104ce4:	e0fffe17 	ldw	r3,-8(fp)
81104ce8:	1884b03a 	or	r2,r3,r2
81104cec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104cf0:	e0bfff17 	ldw	r2,-4(fp)
81104cf4:	10800017 	ldw	r2,0(r2)
81104cf8:	e1bffe17 	ldw	r6,-8(fp)
81104cfc:	014003c4 	movi	r5,15
81104d00:	1009883a 	mov	r4,r2
81104d04:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d08:	e0bfff17 	ldw	r2,-4(fp)
81104d0c:	10800017 	ldw	r2,0(r2)
81104d10:	01400404 	movi	r5,16
81104d14:	1009883a 	mov	r4,r2
81104d18:	11050080 	call	81105008 <uliDpktReadReg>
81104d1c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104d20:	e0bffe17 	ldw	r2,-8(fp)
81104d24:	10bfffec 	andhi	r2,r2,65535
81104d28:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	1080070b 	ldhu	r2,28(r2)
81104d34:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104d38:	e0fffe17 	ldw	r3,-8(fp)
81104d3c:	1884b03a 	or	r2,r3,r2
81104d40:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104d44:	e0bfff17 	ldw	r2,-4(fp)
81104d48:	10800017 	ldw	r2,0(r2)
81104d4c:	e1bffe17 	ldw	r6,-8(fp)
81104d50:	01400404 	movi	r5,16
81104d54:	1009883a 	mov	r4,r2
81104d58:	1104fb40 	call	81104fb4 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104d5c:	00800044 	movi	r2,1
81104d60:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104d64:	e0bffd17 	ldw	r2,-12(fp)
}
81104d68:	e037883a 	mov	sp,fp
81104d6c:	dfc00117 	ldw	ra,4(sp)
81104d70:	df000017 	ldw	fp,0(sp)
81104d74:	dec00204 	addi	sp,sp,8
81104d78:	f800283a 	ret

81104d7c <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104d7c:	defffb04 	addi	sp,sp,-20
81104d80:	de00012e 	bgeu	sp,et,81104d88 <bDpktGetPixelDelay+0xc>
81104d84:	003b68fa 	trap	3
81104d88:	dfc00415 	stw	ra,16(sp)
81104d8c:	df000315 	stw	fp,12(sp)
81104d90:	df000304 	addi	fp,sp,12
81104d94:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d98:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d9c:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104da0:	e0bfff17 	ldw	r2,-4(fp)
81104da4:	10002026 	beq	r2,zero,81104e28 <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104da8:	e0bfff17 	ldw	r2,-4(fp)
81104dac:	10800017 	ldw	r2,0(r2)
81104db0:	01400384 	movi	r5,14
81104db4:	1009883a 	mov	r4,r2
81104db8:	11050080 	call	81105008 <uliDpktReadReg>
81104dbc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104dc0:	e0bffe17 	ldw	r2,-8(fp)
81104dc4:	1007883a 	mov	r3,r2
81104dc8:	e0bfff17 	ldw	r2,-4(fp)
81104dcc:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104dd0:	e0bfff17 	ldw	r2,-4(fp)
81104dd4:	10800017 	ldw	r2,0(r2)
81104dd8:	014003c4 	movi	r5,15
81104ddc:	1009883a 	mov	r4,r2
81104de0:	11050080 	call	81105008 <uliDpktReadReg>
81104de4:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104de8:	e0bffe17 	ldw	r2,-8(fp)
81104dec:	1007883a 	mov	r3,r2
81104df0:	e0bfff17 	ldw	r2,-4(fp)
81104df4:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104df8:	e0bfff17 	ldw	r2,-4(fp)
81104dfc:	10800017 	ldw	r2,0(r2)
81104e00:	01400404 	movi	r5,16
81104e04:	1009883a 	mov	r4,r2
81104e08:	11050080 	call	81105008 <uliDpktReadReg>
81104e0c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104e10:	e0bffe17 	ldw	r2,-8(fp)
81104e14:	1007883a 	mov	r3,r2
81104e18:	e0bfff17 	ldw	r2,-4(fp)
81104e1c:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104e20:	00800044 	movi	r2,1
81104e24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104e28:	e0bffd17 	ldw	r2,-12(fp)
}
81104e2c:	e037883a 	mov	sp,fp
81104e30:	dfc00117 	ldw	ra,4(sp)
81104e34:	df000017 	ldw	fp,0(sp)
81104e38:	dec00204 	addi	sp,sp,8
81104e3c:	f800283a 	ret

81104e40 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104e40:	defffb04 	addi	sp,sp,-20
81104e44:	de00012e 	bgeu	sp,et,81104e4c <bDpktInitCh+0xc>
81104e48:	003b68fa 	trap	3
81104e4c:	dfc00415 	stw	ra,16(sp)
81104e50:	df000315 	stw	fp,12(sp)
81104e54:	df000304 	addi	fp,sp,12
81104e58:	e13ffe15 	stw	r4,-8(fp)
81104e5c:	2805883a 	mov	r2,r5
81104e60:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104e64:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104e68:	e0bffe17 	ldw	r2,-8(fp)
81104e6c:	10004b26 	beq	r2,zero,81104f9c <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104e70:	00800044 	movi	r2,1
81104e74:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104e78:	e0bfff03 	ldbu	r2,-4(fp)
81104e7c:	10c00228 	cmpgeui	r3,r2,8
81104e80:	1800361e 	bne	r3,zero,81104f5c <bDpktInitCh+0x11c>
81104e84:	100690ba 	slli	r3,r2,2
81104e88:	00a04434 	movhi	r2,33040
81104e8c:	1093a704 	addi	r2,r2,20124
81104e90:	1885883a 	add	r2,r3,r2
81104e94:	10800017 	ldw	r2,0(r2)
81104e98:	1000683a 	jmp	r2
81104e9c:	81104ebc 	xorhi	r4,r16,16698
81104ea0:	81104ed0 	cmplti	r4,r16,16699
81104ea4:	81104ee4 	muli	r4,r16,16699
81104ea8:	81104ef8 	rdprs	r4,r16,16699
81104eac:	81104f0c 	andi	r4,r16,16700
81104eb0:	81104f20 	cmpeqi	r4,r16,16700
81104eb4:	81104f34 	orhi	r4,r16,16700
81104eb8:	81104f48 	cmpgei	r4,r16,16701
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104ebc:	e0fffe17 	ldw	r3,-8(fp)
81104ec0:	00a04834 	movhi	r2,33056
81104ec4:	108b0004 	addi	r2,r2,11264
81104ec8:	18800015 	stw	r2,0(r3)
			break;
81104ecc:	00002506 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104ed0:	e0fffe17 	ldw	r3,-8(fp)
81104ed4:	00a04834 	movhi	r2,33056
81104ed8:	108a0004 	addi	r2,r2,10240
81104edc:	18800015 	stw	r2,0(r3)
			break;
81104ee0:	00002006 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104ee4:	e0fffe17 	ldw	r3,-8(fp)
81104ee8:	00a04834 	movhi	r2,33056
81104eec:	108b0004 	addi	r2,r2,11264
81104ef0:	18800015 	stw	r2,0(r3)
			break;
81104ef4:	00001b06 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104ef8:	e0fffe17 	ldw	r3,-8(fp)
81104efc:	00a04834 	movhi	r2,33056
81104f00:	108a0004 	addi	r2,r2,10240
81104f04:	18800015 	stw	r2,0(r3)
			break;
81104f08:	00001606 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104f0c:	e0fffe17 	ldw	r3,-8(fp)
81104f10:	00a04834 	movhi	r2,33056
81104f14:	108b0004 	addi	r2,r2,11264
81104f18:	18800015 	stw	r2,0(r3)
			break;
81104f1c:	00001106 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104f20:	e0fffe17 	ldw	r3,-8(fp)
81104f24:	00a04834 	movhi	r2,33056
81104f28:	108a0004 	addi	r2,r2,10240
81104f2c:	18800015 	stw	r2,0(r3)
			break;
81104f30:	00000c06 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104f34:	e0fffe17 	ldw	r3,-8(fp)
81104f38:	00a04834 	movhi	r2,33056
81104f3c:	108b0004 	addi	r2,r2,11264
81104f40:	18800015 	stw	r2,0(r3)
			break;
81104f44:	00000706 	br	81104f64 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104f48:	e0fffe17 	ldw	r3,-8(fp)
81104f4c:	00a04834 	movhi	r2,33056
81104f50:	108a0004 	addi	r2,r2,10240
81104f54:	18800015 	stw	r2,0(r3)
			break;
81104f58:	00000206 	br	81104f64 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104f5c:	e03ffd15 	stw	zero,-12(fp)
			break;
81104f60:	0001883a 	nop
		}

		if (bStatus) {
81104f64:	e0bffd17 	ldw	r2,-12(fp)
81104f68:	10000c26 	beq	r2,zero,81104f9c <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104f6c:	e13ffe17 	ldw	r4,-8(fp)
81104f70:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
81104f74:	1000011e 	bne	r2,zero,81104f7c <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104f78:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104f7c:	e13ffe17 	ldw	r4,-8(fp)
81104f80:	1104b700 	call	81104b70 <bDpktGetPacketHeader>
81104f84:	1000011e 	bne	r2,zero,81104f8c <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104f88:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104f8c:	e13ffe17 	ldw	r4,-8(fp)
81104f90:	1104d7c0 	call	81104d7c <bDpktGetPixelDelay>
81104f94:	1000011e 	bne	r2,zero,81104f9c <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104f98:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104f9c:	e0bffd17 	ldw	r2,-12(fp)
}
81104fa0:	e037883a 	mov	sp,fp
81104fa4:	dfc00117 	ldw	ra,4(sp)
81104fa8:	df000017 	ldw	fp,0(sp)
81104fac:	dec00204 	addi	sp,sp,8
81104fb0:	f800283a 	ret

81104fb4 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104fb4:	defffc04 	addi	sp,sp,-16
81104fb8:	de00012e 	bgeu	sp,et,81104fc0 <vDpktWriteReg+0xc>
81104fbc:	003b68fa 	trap	3
81104fc0:	df000315 	stw	fp,12(sp)
81104fc4:	df000304 	addi	fp,sp,12
81104fc8:	e13ffd15 	stw	r4,-12(fp)
81104fcc:	e17ffe15 	stw	r5,-8(fp)
81104fd0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104fd4:	e0bffe17 	ldw	r2,-8(fp)
81104fd8:	1085883a 	add	r2,r2,r2
81104fdc:	1085883a 	add	r2,r2,r2
81104fe0:	1007883a 	mov	r3,r2
81104fe4:	e0bffd17 	ldw	r2,-12(fp)
81104fe8:	10c5883a 	add	r2,r2,r3
81104fec:	e0ffff17 	ldw	r3,-4(fp)
81104ff0:	10c00015 	stw	r3,0(r2)
}
81104ff4:	0001883a 	nop
81104ff8:	e037883a 	mov	sp,fp
81104ffc:	df000017 	ldw	fp,0(sp)
81105000:	dec00104 	addi	sp,sp,4
81105004:	f800283a 	ret

81105008 <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81105008:	defffc04 	addi	sp,sp,-16
8110500c:	de00012e 	bgeu	sp,et,81105014 <uliDpktReadReg+0xc>
81105010:	003b68fa 	trap	3
81105014:	df000315 	stw	fp,12(sp)
81105018:	df000304 	addi	fp,sp,12
8110501c:	e13ffe15 	stw	r4,-8(fp)
81105020:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81105024:	e0bfff17 	ldw	r2,-4(fp)
81105028:	1085883a 	add	r2,r2,r2
8110502c:	1085883a 	add	r2,r2,r2
81105030:	1007883a 	mov	r3,r2
81105034:	e0bffe17 	ldw	r2,-8(fp)
81105038:	10c5883a 	add	r2,r2,r3
8110503c:	10800017 	ldw	r2,0(r2)
81105040:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81105044:	e0bffd17 	ldw	r2,-12(fp)
}
81105048:	e037883a 	mov	sp,fp
8110504c:	df000017 	ldw	fp,0(sp)
81105050:	dec00104 	addi	sp,sp,4
81105054:	f800283a 	ret

81105058 <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81105058:	defffb04 	addi	sp,sp,-20
8110505c:	de00012e 	bgeu	sp,et,81105064 <vFeebCh1HandleIrq+0xc>
81105060:	003b68fa 	trap	3
81105064:	dfc00415 	stw	ra,16(sp)
81105068:	df000315 	stw	fp,12(sp)
8110506c:	df000304 	addi	fp,sp,12
81105070:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105074:	e0bfff17 	ldw	r2,-4(fp)
81105078:	e0bffd15 	stw	r2,-12(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	vFeebCh1IrqFlagClrBufferEmpty();
8110507c:	11053ac0 	call	811053ac <vFeebCh1IrqFlagClrBufferEmpty>
	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */



}
81105080:	0001883a 	nop
81105084:	e037883a 	mov	sp,fp
81105088:	dfc00117 	ldw	ra,4(sp)
8110508c:	df000017 	ldw	fp,0(sp)
81105090:	dec00204 	addi	sp,sp,8
81105094:	f800283a 	ret

81105098 <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
81105098:	defffa04 	addi	sp,sp,-24
8110509c:	de00012e 	bgeu	sp,et,811050a4 <vFeebCh2HandleIrq+0xc>
811050a0:	003b68fa 	trap	3
811050a4:	dfc00515 	stw	ra,20(sp)
811050a8:	df000415 	stw	fp,16(sp)
811050ac:	df000404 	addi	fp,sp,16
811050b0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811050b4:	e0bfff17 	ldw	r2,-4(fp)
811050b8:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811050bc:	00800404 	movi	r2,16
811050c0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811050c4:	00bfe004 	movi	r2,-128
811050c8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811050cc:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
811050d0:	00800044 	movi	r2,1
811050d4:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811050d8:	d0a05c17 	ldw	r2,-32400(gp)
811050dc:	e0fffe17 	ldw	r3,-8(fp)
811050e0:	180b883a 	mov	r5,r3
811050e4:	1009883a 	mov	r4,r2
811050e8:	113c0280 	call	8113c028 <OSQPost>
811050ec:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811050f0:	e0bffd03 	ldbu	r2,-12(fp)
811050f4:	10000226 	beq	r2,zero,81105100 <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
811050f8:	01000044 	movi	r4,1
811050fc:	111b5540 	call	8111b554 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
81105100:	11053f00 	call	811053f0 <vFeebCh2IrqFlagClrBufferEmpty>
}
81105104:	0001883a 	nop
81105108:	e037883a 	mov	sp,fp
8110510c:	dfc00117 	ldw	ra,4(sp)
81105110:	df000017 	ldw	fp,0(sp)
81105114:	dec00204 	addi	sp,sp,8
81105118:	f800283a 	ret

8110511c <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
8110511c:	defffa04 	addi	sp,sp,-24
81105120:	de00012e 	bgeu	sp,et,81105128 <vFeebCh3HandleIrq+0xc>
81105124:	003b68fa 	trap	3
81105128:	dfc00515 	stw	ra,20(sp)
8110512c:	df000415 	stw	fp,16(sp)
81105130:	df000404 	addi	fp,sp,16
81105134:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105138:	e0bfff17 	ldw	r2,-4(fp)
8110513c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105140:	00800404 	movi	r2,16
81105144:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105148:	00bfe004 	movi	r2,-128
8110514c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105150:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81105154:	00800084 	movi	r2,2
81105158:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110515c:	d0a05c17 	ldw	r2,-32400(gp)
81105160:	e0fffe17 	ldw	r3,-8(fp)
81105164:	180b883a 	mov	r5,r3
81105168:	1009883a 	mov	r4,r2
8110516c:	113c0280 	call	8113c028 <OSQPost>
81105170:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105174:	e0bffd03 	ldbu	r2,-12(fp)
81105178:	10000226 	beq	r2,zero,81105184 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
8110517c:	01000084 	movi	r4,2
81105180:	111b5540 	call	8111b554 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105184:	11054340 	call	81105434 <vFeebCh3IrqFlagClrBufferEmpty>
}
81105188:	0001883a 	nop
8110518c:	e037883a 	mov	sp,fp
81105190:	dfc00117 	ldw	ra,4(sp)
81105194:	df000017 	ldw	fp,0(sp)
81105198:	dec00204 	addi	sp,sp,8
8110519c:	f800283a 	ret

811051a0 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
811051a0:	defffa04 	addi	sp,sp,-24
811051a4:	de00012e 	bgeu	sp,et,811051ac <vFeebCh4HandleIrq+0xc>
811051a8:	003b68fa 	trap	3
811051ac:	dfc00515 	stw	ra,20(sp)
811051b0:	df000415 	stw	fp,16(sp)
811051b4:	df000404 	addi	fp,sp,16
811051b8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811051bc:	e0bfff17 	ldw	r2,-4(fp)
811051c0:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811051c4:	00800404 	movi	r2,16
811051c8:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811051cc:	00bfe004 	movi	r2,-128
811051d0:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811051d4:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
811051d8:	008000c4 	movi	r2,3
811051dc:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811051e0:	d0a05c17 	ldw	r2,-32400(gp)
811051e4:	e0fffe17 	ldw	r3,-8(fp)
811051e8:	180b883a 	mov	r5,r3
811051ec:	1009883a 	mov	r4,r2
811051f0:	113c0280 	call	8113c028 <OSQPost>
811051f4:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811051f8:	e0bffd03 	ldbu	r2,-12(fp)
811051fc:	10000226 	beq	r2,zero,81105208 <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
81105200:	010000c4 	movi	r4,3
81105204:	111b5540 	call	8111b554 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
81105208:	11054780 	call	81105478 <vFeebCh4IrqFlagClrBufferEmpty>
}
8110520c:	0001883a 	nop
81105210:	e037883a 	mov	sp,fp
81105214:	dfc00117 	ldw	ra,4(sp)
81105218:	df000017 	ldw	fp,0(sp)
8110521c:	dec00204 	addi	sp,sp,8
81105220:	f800283a 	ret

81105224 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
81105224:	defffa04 	addi	sp,sp,-24
81105228:	de00012e 	bgeu	sp,et,81105230 <vFeebCh5HandleIrq+0xc>
8110522c:	003b68fa 	trap	3
81105230:	dfc00515 	stw	ra,20(sp)
81105234:	df000415 	stw	fp,16(sp)
81105238:	df000404 	addi	fp,sp,16
8110523c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105240:	e0bfff17 	ldw	r2,-4(fp)
81105244:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105248:	00800404 	movi	r2,16
8110524c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105250:	00bfe004 	movi	r2,-128
81105254:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105258:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
8110525c:	00800104 	movi	r2,4
81105260:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105264:	d0a05c17 	ldw	r2,-32400(gp)
81105268:	e0fffe17 	ldw	r3,-8(fp)
8110526c:	180b883a 	mov	r5,r3
81105270:	1009883a 	mov	r4,r2
81105274:	113c0280 	call	8113c028 <OSQPost>
81105278:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110527c:	e0bffd03 	ldbu	r2,-12(fp)
81105280:	10000226 	beq	r2,zero,8110528c <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105284:	01000104 	movi	r4,4
81105288:	111b5540 	call	8111b554 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
8110528c:	11054bc0 	call	811054bc <vFeebCh5IrqFlagClrBufferEmpty>
}
81105290:	0001883a 	nop
81105294:	e037883a 	mov	sp,fp
81105298:	dfc00117 	ldw	ra,4(sp)
8110529c:	df000017 	ldw	fp,0(sp)
811052a0:	dec00204 	addi	sp,sp,8
811052a4:	f800283a 	ret

811052a8 <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
811052a8:	defffa04 	addi	sp,sp,-24
811052ac:	de00012e 	bgeu	sp,et,811052b4 <vFeebCh6HandleIrq+0xc>
811052b0:	003b68fa 	trap	3
811052b4:	dfc00515 	stw	ra,20(sp)
811052b8:	df000415 	stw	fp,16(sp)
811052bc:	df000404 	addi	fp,sp,16
811052c0:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811052c4:	e0bfff17 	ldw	r2,-4(fp)
811052c8:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811052cc:	00800404 	movi	r2,16
811052d0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
811052d4:	00bfe004 	movi	r2,-128
811052d8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811052dc:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
811052e0:	00800144 	movi	r2,5
811052e4:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811052e8:	d0a05c17 	ldw	r2,-32400(gp)
811052ec:	e0fffe17 	ldw	r3,-8(fp)
811052f0:	180b883a 	mov	r5,r3
811052f4:	1009883a 	mov	r4,r2
811052f8:	113c0280 	call	8113c028 <OSQPost>
811052fc:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105300:	e0bffd03 	ldbu	r2,-12(fp)
81105304:	10000226 	beq	r2,zero,81105310 <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
81105308:	01000144 	movi	r4,5
8110530c:	111b5540 	call	8111b554 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
81105310:	11055000 	call	81105500 <vFeebCh6IrqFlagClrBufferEmpty>
}
81105314:	0001883a 	nop
81105318:	e037883a 	mov	sp,fp
8110531c:	dfc00117 	ldw	ra,4(sp)
81105320:	df000017 	ldw	fp,0(sp)
81105324:	dec00204 	addi	sp,sp,8
81105328:	f800283a 	ret

8110532c <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
8110532c:	defffc04 	addi	sp,sp,-16
81105330:	de00012e 	bgeu	sp,et,81105338 <vFeebCh7HandleIrq+0xc>
81105334:	003b68fa 	trap	3
81105338:	dfc00315 	stw	ra,12(sp)
8110533c:	df000215 	stw	fp,8(sp)
81105340:	df000204 	addi	fp,sp,8
81105344:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105348:	e0bfff17 	ldw	r2,-4(fp)
8110534c:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
81105350:	11055440 	call	81105544 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105354:	0001883a 	nop
81105358:	e037883a 	mov	sp,fp
8110535c:	dfc00117 	ldw	ra,4(sp)
81105360:	df000017 	ldw	fp,0(sp)
81105364:	dec00204 	addi	sp,sp,8
81105368:	f800283a 	ret

8110536c <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
8110536c:	defffc04 	addi	sp,sp,-16
81105370:	de00012e 	bgeu	sp,et,81105378 <vFeebCh8HandleIrq+0xc>
81105374:	003b68fa 	trap	3
81105378:	dfc00315 	stw	ra,12(sp)
8110537c:	df000215 	stw	fp,8(sp)
81105380:	df000204 	addi	fp,sp,8
81105384:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105388:	e0bfff17 	ldw	r2,-4(fp)
8110538c:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
81105390:	11055880 	call	81105588 <vFeebCh8IrqFlagClrBufferEmpty>
}
81105394:	0001883a 	nop
81105398:	e037883a 	mov	sp,fp
8110539c:	dfc00117 	ldw	ra,4(sp)
811053a0:	df000017 	ldw	fp,0(sp)
811053a4:	dec00204 	addi	sp,sp,8
811053a8:	f800283a 	ret

811053ac <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
811053ac:	defffe04 	addi	sp,sp,-8
811053b0:	de00012e 	bgeu	sp,et,811053b8 <vFeebCh1IrqFlagClrBufferEmpty+0xc>
811053b4:	003b68fa 	trap	3
811053b8:	dfc00115 	stw	ra,4(sp)
811053bc:	df000015 	stw	fp,0(sp)
811053c0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811053c4:	01804004 	movi	r6,256
811053c8:	014004c4 	movi	r5,19
811053cc:	01204834 	movhi	r4,33056
811053d0:	210b0004 	addi	r4,r4,11264
811053d4:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053d8:	0001883a 	nop
811053dc:	e037883a 	mov	sp,fp
811053e0:	dfc00117 	ldw	ra,4(sp)
811053e4:	df000017 	ldw	fp,0(sp)
811053e8:	dec00204 	addi	sp,sp,8
811053ec:	f800283a 	ret

811053f0 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
811053f0:	defffe04 	addi	sp,sp,-8
811053f4:	de00012e 	bgeu	sp,et,811053fc <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811053f8:	003b68fa 	trap	3
811053fc:	dfc00115 	stw	ra,4(sp)
81105400:	df000015 	stw	fp,0(sp)
81105404:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105408:	01804004 	movi	r6,256
8110540c:	014004c4 	movi	r5,19
81105410:	01204834 	movhi	r4,33056
81105414:	210a0004 	addi	r4,r4,10240
81105418:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110541c:	0001883a 	nop
81105420:	e037883a 	mov	sp,fp
81105424:	dfc00117 	ldw	ra,4(sp)
81105428:	df000017 	ldw	fp,0(sp)
8110542c:	dec00204 	addi	sp,sp,8
81105430:	f800283a 	ret

81105434 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
81105434:	defffe04 	addi	sp,sp,-8
81105438:	de00012e 	bgeu	sp,et,81105440 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
8110543c:	003b68fa 	trap	3
81105440:	dfc00115 	stw	ra,4(sp)
81105444:	df000015 	stw	fp,0(sp)
81105448:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110544c:	01804004 	movi	r6,256
81105450:	014004c4 	movi	r5,19
81105454:	01204834 	movhi	r4,33056
81105458:	210b0004 	addi	r4,r4,11264
8110545c:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105460:	0001883a 	nop
81105464:	e037883a 	mov	sp,fp
81105468:	dfc00117 	ldw	ra,4(sp)
8110546c:	df000017 	ldw	fp,0(sp)
81105470:	dec00204 	addi	sp,sp,8
81105474:	f800283a 	ret

81105478 <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
81105478:	defffe04 	addi	sp,sp,-8
8110547c:	de00012e 	bgeu	sp,et,81105484 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105480:	003b68fa 	trap	3
81105484:	dfc00115 	stw	ra,4(sp)
81105488:	df000015 	stw	fp,0(sp)
8110548c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105490:	01804004 	movi	r6,256
81105494:	014004c4 	movi	r5,19
81105498:	01204834 	movhi	r4,33056
8110549c:	210a0004 	addi	r4,r4,10240
811054a0:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054a4:	0001883a 	nop
811054a8:	e037883a 	mov	sp,fp
811054ac:	dfc00117 	ldw	ra,4(sp)
811054b0:	df000017 	ldw	fp,0(sp)
811054b4:	dec00204 	addi	sp,sp,8
811054b8:	f800283a 	ret

811054bc <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
811054bc:	defffe04 	addi	sp,sp,-8
811054c0:	de00012e 	bgeu	sp,et,811054c8 <vFeebCh5IrqFlagClrBufferEmpty+0xc>
811054c4:	003b68fa 	trap	3
811054c8:	dfc00115 	stw	ra,4(sp)
811054cc:	df000015 	stw	fp,0(sp)
811054d0:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811054d4:	01804004 	movi	r6,256
811054d8:	014004c4 	movi	r5,19
811054dc:	01204834 	movhi	r4,33056
811054e0:	210b0004 	addi	r4,r4,11264
811054e4:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054e8:	0001883a 	nop
811054ec:	e037883a 	mov	sp,fp
811054f0:	dfc00117 	ldw	ra,4(sp)
811054f4:	df000017 	ldw	fp,0(sp)
811054f8:	dec00204 	addi	sp,sp,8
811054fc:	f800283a 	ret

81105500 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
81105500:	defffe04 	addi	sp,sp,-8
81105504:	de00012e 	bgeu	sp,et,8110550c <vFeebCh6IrqFlagClrBufferEmpty+0xc>
81105508:	003b68fa 	trap	3
8110550c:	dfc00115 	stw	ra,4(sp)
81105510:	df000015 	stw	fp,0(sp)
81105514:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105518:	01804004 	movi	r6,256
8110551c:	014004c4 	movi	r5,19
81105520:	01204834 	movhi	r4,33056
81105524:	210a0004 	addi	r4,r4,10240
81105528:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110552c:	0001883a 	nop
81105530:	e037883a 	mov	sp,fp
81105534:	dfc00117 	ldw	ra,4(sp)
81105538:	df000017 	ldw	fp,0(sp)
8110553c:	dec00204 	addi	sp,sp,8
81105540:	f800283a 	ret

81105544 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105544:	defffe04 	addi	sp,sp,-8
81105548:	de00012e 	bgeu	sp,et,81105550 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
8110554c:	003b68fa 	trap	3
81105550:	dfc00115 	stw	ra,4(sp)
81105554:	df000015 	stw	fp,0(sp)
81105558:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110555c:	01804004 	movi	r6,256
81105560:	014004c4 	movi	r5,19
81105564:	01204834 	movhi	r4,33056
81105568:	210b0004 	addi	r4,r4,11264
8110556c:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105570:	0001883a 	nop
81105574:	e037883a 	mov	sp,fp
81105578:	dfc00117 	ldw	ra,4(sp)
8110557c:	df000017 	ldw	fp,0(sp)
81105580:	dec00204 	addi	sp,sp,8
81105584:	f800283a 	ret

81105588 <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
81105588:	defffe04 	addi	sp,sp,-8
8110558c:	de00012e 	bgeu	sp,et,81105594 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105590:	003b68fa 	trap	3
81105594:	dfc00115 	stw	ra,4(sp)
81105598:	df000015 	stw	fp,0(sp)
8110559c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811055a0:	01804004 	movi	r6,256
811055a4:	014004c4 	movi	r5,19
811055a8:	01204834 	movhi	r4,33056
811055ac:	210a0004 	addi	r4,r4,10240
811055b0:	1106b780 	call	81106b78 <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811055b4:	0001883a 	nop
811055b8:	e037883a 	mov	sp,fp
811055bc:	dfc00117 	ldw	ra,4(sp)
811055c0:	df000017 	ldw	fp,0(sp)
811055c4:	dec00204 	addi	sp,sp,8
811055c8:	f800283a 	ret

811055cc <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
811055cc:	defffd04 	addi	sp,sp,-12
811055d0:	de00012e 	bgeu	sp,et,811055d8 <bFeebCh1IrqFlagBufferEmpty+0xc>
811055d4:	003b68fa 	trap	3
811055d8:	dfc00215 	stw	ra,8(sp)
811055dc:	df000115 	stw	fp,4(sp)
811055e0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811055e4:	01400484 	movi	r5,18
811055e8:	01204834 	movhi	r4,33056
811055ec:	210b0004 	addi	r4,r4,11264
811055f0:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055f4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811055f8:	10000326 	beq	r2,zero,81105608 <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055fc:	00800044 	movi	r2,1
81105600:	e0bfff15 	stw	r2,-4(fp)
81105604:	00000106 	br	8110560c <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105608:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110560c:	e0bfff17 	ldw	r2,-4(fp)
}
81105610:	e037883a 	mov	sp,fp
81105614:	dfc00117 	ldw	ra,4(sp)
81105618:	df000017 	ldw	fp,0(sp)
8110561c:	dec00204 	addi	sp,sp,8
81105620:	f800283a 	ret

81105624 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
81105624:	defffd04 	addi	sp,sp,-12
81105628:	de00012e 	bgeu	sp,et,81105630 <bFeebCh2IrqFlagBufferEmpty+0xc>
8110562c:	003b68fa 	trap	3
81105630:	dfc00215 	stw	ra,8(sp)
81105634:	df000115 	stw	fp,4(sp)
81105638:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110563c:	01400484 	movi	r5,18
81105640:	01204834 	movhi	r4,33056
81105644:	210a0004 	addi	r4,r4,10240
81105648:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110564c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105650:	10000326 	beq	r2,zero,81105660 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105654:	00800044 	movi	r2,1
81105658:	e0bfff15 	stw	r2,-4(fp)
8110565c:	00000106 	br	81105664 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105660:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105664:	e0bfff17 	ldw	r2,-4(fp)
}
81105668:	e037883a 	mov	sp,fp
8110566c:	dfc00117 	ldw	ra,4(sp)
81105670:	df000017 	ldw	fp,0(sp)
81105674:	dec00204 	addi	sp,sp,8
81105678:	f800283a 	ret

8110567c <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
8110567c:	defffd04 	addi	sp,sp,-12
81105680:	de00012e 	bgeu	sp,et,81105688 <bFeebCh3IrqFlagBufferEmpty+0xc>
81105684:	003b68fa 	trap	3
81105688:	dfc00215 	stw	ra,8(sp)
8110568c:	df000115 	stw	fp,4(sp)
81105690:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105694:	01400484 	movi	r5,18
81105698:	01204834 	movhi	r4,33056
8110569c:	210b0004 	addi	r4,r4,11264
811056a0:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056a4:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811056a8:	10000326 	beq	r2,zero,811056b8 <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056ac:	00800044 	movi	r2,1
811056b0:	e0bfff15 	stw	r2,-4(fp)
811056b4:	00000106 	br	811056bc <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056b8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056bc:	e0bfff17 	ldw	r2,-4(fp)
}
811056c0:	e037883a 	mov	sp,fp
811056c4:	dfc00117 	ldw	ra,4(sp)
811056c8:	df000017 	ldw	fp,0(sp)
811056cc:	dec00204 	addi	sp,sp,8
811056d0:	f800283a 	ret

811056d4 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
811056d4:	defffd04 	addi	sp,sp,-12
811056d8:	de00012e 	bgeu	sp,et,811056e0 <bFeebCh4IrqFlagBufferEmpty+0xc>
811056dc:	003b68fa 	trap	3
811056e0:	dfc00215 	stw	ra,8(sp)
811056e4:	df000115 	stw	fp,4(sp)
811056e8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811056ec:	01400484 	movi	r5,18
811056f0:	01204834 	movhi	r4,33056
811056f4:	210a0004 	addi	r4,r4,10240
811056f8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056fc:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105700:	10000326 	beq	r2,zero,81105710 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105704:	00800044 	movi	r2,1
81105708:	e0bfff15 	stw	r2,-4(fp)
8110570c:	00000106 	br	81105714 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105710:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105714:	e0bfff17 	ldw	r2,-4(fp)
}
81105718:	e037883a 	mov	sp,fp
8110571c:	dfc00117 	ldw	ra,4(sp)
81105720:	df000017 	ldw	fp,0(sp)
81105724:	dec00204 	addi	sp,sp,8
81105728:	f800283a 	ret

8110572c <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
8110572c:	defffd04 	addi	sp,sp,-12
81105730:	de00012e 	bgeu	sp,et,81105738 <bFeebCh5IrqFlagBufferEmpty+0xc>
81105734:	003b68fa 	trap	3
81105738:	dfc00215 	stw	ra,8(sp)
8110573c:	df000115 	stw	fp,4(sp)
81105740:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105744:	01400484 	movi	r5,18
81105748:	01204834 	movhi	r4,33056
8110574c:	210b0004 	addi	r4,r4,11264
81105750:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105754:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105758:	10000326 	beq	r2,zero,81105768 <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110575c:	00800044 	movi	r2,1
81105760:	e0bfff15 	stw	r2,-4(fp)
81105764:	00000106 	br	8110576c <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105768:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110576c:	e0bfff17 	ldw	r2,-4(fp)
}
81105770:	e037883a 	mov	sp,fp
81105774:	dfc00117 	ldw	ra,4(sp)
81105778:	df000017 	ldw	fp,0(sp)
8110577c:	dec00204 	addi	sp,sp,8
81105780:	f800283a 	ret

81105784 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105784:	defffd04 	addi	sp,sp,-12
81105788:	de00012e 	bgeu	sp,et,81105790 <bFeebCh6IrqFlagBufferEmpty+0xc>
8110578c:	003b68fa 	trap	3
81105790:	dfc00215 	stw	ra,8(sp)
81105794:	df000115 	stw	fp,4(sp)
81105798:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110579c:	01400484 	movi	r5,18
811057a0:	01204834 	movhi	r4,33056
811057a4:	210a0004 	addi	r4,r4,10240
811057a8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057ac:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811057b0:	10000326 	beq	r2,zero,811057c0 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057b4:	00800044 	movi	r2,1
811057b8:	e0bfff15 	stw	r2,-4(fp)
811057bc:	00000106 	br	811057c4 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057c0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057c4:	e0bfff17 	ldw	r2,-4(fp)
}
811057c8:	e037883a 	mov	sp,fp
811057cc:	dfc00117 	ldw	ra,4(sp)
811057d0:	df000017 	ldw	fp,0(sp)
811057d4:	dec00204 	addi	sp,sp,8
811057d8:	f800283a 	ret

811057dc <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
811057dc:	defffd04 	addi	sp,sp,-12
811057e0:	de00012e 	bgeu	sp,et,811057e8 <bFeebCh7IrqFlagBufferEmpty+0xc>
811057e4:	003b68fa 	trap	3
811057e8:	dfc00215 	stw	ra,8(sp)
811057ec:	df000115 	stw	fp,4(sp)
811057f0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057f4:	01400484 	movi	r5,18
811057f8:	01204834 	movhi	r4,33056
811057fc:	210b0004 	addi	r4,r4,11264
81105800:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105804:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105808:	10000326 	beq	r2,zero,81105818 <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
8110580c:	00800044 	movi	r2,1
81105810:	e0bfff15 	stw	r2,-4(fp)
81105814:	00000106 	br	8110581c <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105818:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110581c:	e0bfff17 	ldw	r2,-4(fp)
}
81105820:	e037883a 	mov	sp,fp
81105824:	dfc00117 	ldw	ra,4(sp)
81105828:	df000017 	ldw	fp,0(sp)
8110582c:	dec00204 	addi	sp,sp,8
81105830:	f800283a 	ret

81105834 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
81105834:	defffd04 	addi	sp,sp,-12
81105838:	de00012e 	bgeu	sp,et,81105840 <bFeebCh8IrqFlagBufferEmpty+0xc>
8110583c:	003b68fa 	trap	3
81105840:	dfc00215 	stw	ra,8(sp)
81105844:	df000115 	stw	fp,4(sp)
81105848:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110584c:	01400484 	movi	r5,18
81105850:	01204834 	movhi	r4,33056
81105854:	210a0004 	addi	r4,r4,10240
81105858:	1106bcc0 	call	81106bcc <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110585c:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105860:	10000326 	beq	r2,zero,81105870 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105864:	00800044 	movi	r2,1
81105868:	e0bfff15 	stw	r2,-4(fp)
8110586c:	00000106 	br	81105874 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105870:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105874:	e0bfff17 	ldw	r2,-4(fp)
}
81105878:	e037883a 	mov	sp,fp
8110587c:	dfc00117 	ldw	ra,4(sp)
81105880:	df000017 	ldw	fp,0(sp)
81105884:	dec00204 	addi	sp,sp,8
81105888:	f800283a 	ret

8110588c <bFeebCh1SetBufferSize>:

bool bFeebCh1SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
8110588c:	defffa04 	addi	sp,sp,-24
81105890:	de00012e 	bgeu	sp,et,81105898 <bFeebCh1SetBufferSize+0xc>
81105894:	003b68fa 	trap	3
81105898:	dfc00515 	stw	ra,20(sp)
8110589c:	df000415 	stw	fp,16(sp)
811058a0:	df000404 	addi	fp,sp,16
811058a4:	2007883a 	mov	r3,r4
811058a8:	2805883a 	mov	r2,r5
811058ac:	e0fffe05 	stb	r3,-8(fp)
811058b0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811058b4:	00800044 	movi	r2,1
811058b8:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
811058bc:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
811058c0:	e0bffe03 	ldbu	r2,-8(fp)
811058c4:	10001f26 	beq	r2,zero,81105944 <bFeebCh1SetBufferSize+0xb8>
811058c8:	e0bffe03 	ldbu	r2,-8(fp)
811058cc:	10800468 	cmpgeui	r2,r2,17
811058d0:	10001c1e 	bne	r2,zero,81105944 <bFeebCh1SetBufferSize+0xb8>
		switch (ucBufferSide) {
811058d4:	e0bfff03 	ldbu	r2,-4(fp)
811058d8:	10000326 	beq	r2,zero,811058e8 <bFeebCh1SetBufferSize+0x5c>
811058dc:	10800060 	cmpeqi	r2,r2,1
811058e0:	10000b1e 	bne	r2,zero,81105910 <bFeebCh1SetBufferSize+0x84>
811058e4:	00001406 	br	81105938 <bFeebCh1SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811058e8:	e0bffe03 	ldbu	r2,-8(fp)
811058ec:	10bfffc4 	addi	r2,r2,-1
811058f0:	108003cc 	andi	r2,r2,15
811058f4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811058f8:	e1bffd17 	ldw	r6,-12(fp)
811058fc:	01400544 	movi	r5,21
81105900:	01204834 	movhi	r4,33056
81105904:	210b0004 	addi	r4,r4,11264
81105908:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
8110590c:	00000c06 	br	81105940 <bFeebCh1SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105910:	e0bffe03 	ldbu	r2,-8(fp)
81105914:	10bfffc4 	addi	r2,r2,-1
81105918:	108003cc 	andi	r2,r2,15
8110591c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105920:	e1bffd17 	ldw	r6,-12(fp)
81105924:	01400504 	movi	r5,20
81105928:	01204834 	movhi	r4,33056
8110592c:	210b0004 	addi	r4,r4,11264
81105930:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105934:	00000206 	br	81105940 <bFeebCh1SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105938:	e03ffc15 	stw	zero,-16(fp)
			break;
8110593c:	0001883a 	nop
		}
	} else {
81105940:	00000106 	br	81105948 <bFeebCh1SetBufferSize+0xbc>
		bStatus = FALSE;
81105944:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105948:	e0bffc17 	ldw	r2,-16(fp)
}
8110594c:	e037883a 	mov	sp,fp
81105950:	dfc00117 	ldw	ra,4(sp)
81105954:	df000017 	ldw	fp,0(sp)
81105958:	dec00204 	addi	sp,sp,8
8110595c:	f800283a 	ret

81105960 <bFeebCh2SetBufferSize>:

bool bFeebCh2SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105960:	defffa04 	addi	sp,sp,-24
81105964:	de00012e 	bgeu	sp,et,8110596c <bFeebCh2SetBufferSize+0xc>
81105968:	003b68fa 	trap	3
8110596c:	dfc00515 	stw	ra,20(sp)
81105970:	df000415 	stw	fp,16(sp)
81105974:	df000404 	addi	fp,sp,16
81105978:	2007883a 	mov	r3,r4
8110597c:	2805883a 	mov	r2,r5
81105980:	e0fffe05 	stb	r3,-8(fp)
81105984:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105988:	00800044 	movi	r2,1
8110598c:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105990:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105994:	e0bffe03 	ldbu	r2,-8(fp)
81105998:	10001f26 	beq	r2,zero,81105a18 <bFeebCh2SetBufferSize+0xb8>
8110599c:	e0bffe03 	ldbu	r2,-8(fp)
811059a0:	10800468 	cmpgeui	r2,r2,17
811059a4:	10001c1e 	bne	r2,zero,81105a18 <bFeebCh2SetBufferSize+0xb8>
		switch (ucBufferSide) {
811059a8:	e0bfff03 	ldbu	r2,-4(fp)
811059ac:	10000326 	beq	r2,zero,811059bc <bFeebCh2SetBufferSize+0x5c>
811059b0:	10800060 	cmpeqi	r2,r2,1
811059b4:	10000b1e 	bne	r2,zero,811059e4 <bFeebCh2SetBufferSize+0x84>
811059b8:	00001406 	br	81105a0c <bFeebCh2SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811059bc:	e0bffe03 	ldbu	r2,-8(fp)
811059c0:	10bfffc4 	addi	r2,r2,-1
811059c4:	108003cc 	andi	r2,r2,15
811059c8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811059cc:	e1bffd17 	ldw	r6,-12(fp)
811059d0:	01400544 	movi	r5,21
811059d4:	01204834 	movhi	r4,33056
811059d8:	210a0004 	addi	r4,r4,10240
811059dc:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811059e0:	00000c06 	br	81105a14 <bFeebCh2SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811059e4:	e0bffe03 	ldbu	r2,-8(fp)
811059e8:	10bfffc4 	addi	r2,r2,-1
811059ec:	108003cc 	andi	r2,r2,15
811059f0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811059f4:	e1bffd17 	ldw	r6,-12(fp)
811059f8:	01400504 	movi	r5,20
811059fc:	01204834 	movhi	r4,33056
81105a00:	210a0004 	addi	r4,r4,10240
81105a04:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105a08:	00000206 	br	81105a14 <bFeebCh2SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105a0c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105a10:	0001883a 	nop
		}
	} else {
81105a14:	00000106 	br	81105a1c <bFeebCh2SetBufferSize+0xbc>
		bStatus = FALSE;
81105a18:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105a1c:	e0bffc17 	ldw	r2,-16(fp)
}
81105a20:	e037883a 	mov	sp,fp
81105a24:	dfc00117 	ldw	ra,4(sp)
81105a28:	df000017 	ldw	fp,0(sp)
81105a2c:	dec00204 	addi	sp,sp,8
81105a30:	f800283a 	ret

81105a34 <bFeebCh3SetBufferSize>:

bool bFeebCh3SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105a34:	defffa04 	addi	sp,sp,-24
81105a38:	de00012e 	bgeu	sp,et,81105a40 <bFeebCh3SetBufferSize+0xc>
81105a3c:	003b68fa 	trap	3
81105a40:	dfc00515 	stw	ra,20(sp)
81105a44:	df000415 	stw	fp,16(sp)
81105a48:	df000404 	addi	fp,sp,16
81105a4c:	2007883a 	mov	r3,r4
81105a50:	2805883a 	mov	r2,r5
81105a54:	e0fffe05 	stb	r3,-8(fp)
81105a58:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105a5c:	00800044 	movi	r2,1
81105a60:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105a64:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105a68:	e0bffe03 	ldbu	r2,-8(fp)
81105a6c:	10001f26 	beq	r2,zero,81105aec <bFeebCh3SetBufferSize+0xb8>
81105a70:	e0bffe03 	ldbu	r2,-8(fp)
81105a74:	10800468 	cmpgeui	r2,r2,17
81105a78:	10001c1e 	bne	r2,zero,81105aec <bFeebCh3SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105a7c:	e0bfff03 	ldbu	r2,-4(fp)
81105a80:	10000326 	beq	r2,zero,81105a90 <bFeebCh3SetBufferSize+0x5c>
81105a84:	10800060 	cmpeqi	r2,r2,1
81105a88:	10000b1e 	bne	r2,zero,81105ab8 <bFeebCh3SetBufferSize+0x84>
81105a8c:	00001406 	br	81105ae0 <bFeebCh3SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105a90:	e0bffe03 	ldbu	r2,-8(fp)
81105a94:	10bfffc4 	addi	r2,r2,-1
81105a98:	108003cc 	andi	r2,r2,15
81105a9c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105aa0:	e1bffd17 	ldw	r6,-12(fp)
81105aa4:	01400544 	movi	r5,21
81105aa8:	01204834 	movhi	r4,33056
81105aac:	210b0004 	addi	r4,r4,11264
81105ab0:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ab4:	00000c06 	br	81105ae8 <bFeebCh3SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105ab8:	e0bffe03 	ldbu	r2,-8(fp)
81105abc:	10bfffc4 	addi	r2,r2,-1
81105ac0:	108003cc 	andi	r2,r2,15
81105ac4:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105ac8:	e1bffd17 	ldw	r6,-12(fp)
81105acc:	01400504 	movi	r5,20
81105ad0:	01204834 	movhi	r4,33056
81105ad4:	210b0004 	addi	r4,r4,11264
81105ad8:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105adc:	00000206 	br	81105ae8 <bFeebCh3SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105ae0:	e03ffc15 	stw	zero,-16(fp)
			break;
81105ae4:	0001883a 	nop
		}
	} else {
81105ae8:	00000106 	br	81105af0 <bFeebCh3SetBufferSize+0xbc>
		bStatus = FALSE;
81105aec:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105af0:	e0bffc17 	ldw	r2,-16(fp)
}
81105af4:	e037883a 	mov	sp,fp
81105af8:	dfc00117 	ldw	ra,4(sp)
81105afc:	df000017 	ldw	fp,0(sp)
81105b00:	dec00204 	addi	sp,sp,8
81105b04:	f800283a 	ret

81105b08 <bFeebCh4SetBufferSize>:

bool bFeebCh4SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105b08:	defffa04 	addi	sp,sp,-24
81105b0c:	de00012e 	bgeu	sp,et,81105b14 <bFeebCh4SetBufferSize+0xc>
81105b10:	003b68fa 	trap	3
81105b14:	dfc00515 	stw	ra,20(sp)
81105b18:	df000415 	stw	fp,16(sp)
81105b1c:	df000404 	addi	fp,sp,16
81105b20:	2007883a 	mov	r3,r4
81105b24:	2805883a 	mov	r2,r5
81105b28:	e0fffe05 	stb	r3,-8(fp)
81105b2c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105b30:	00800044 	movi	r2,1
81105b34:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105b38:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105b3c:	e0bffe03 	ldbu	r2,-8(fp)
81105b40:	10001f26 	beq	r2,zero,81105bc0 <bFeebCh4SetBufferSize+0xb8>
81105b44:	e0bffe03 	ldbu	r2,-8(fp)
81105b48:	10800468 	cmpgeui	r2,r2,17
81105b4c:	10001c1e 	bne	r2,zero,81105bc0 <bFeebCh4SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105b50:	e0bfff03 	ldbu	r2,-4(fp)
81105b54:	10000326 	beq	r2,zero,81105b64 <bFeebCh4SetBufferSize+0x5c>
81105b58:	10800060 	cmpeqi	r2,r2,1
81105b5c:	10000b1e 	bne	r2,zero,81105b8c <bFeebCh4SetBufferSize+0x84>
81105b60:	00001406 	br	81105bb4 <bFeebCh4SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b64:	e0bffe03 	ldbu	r2,-8(fp)
81105b68:	10bfffc4 	addi	r2,r2,-1
81105b6c:	108003cc 	andi	r2,r2,15
81105b70:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b74:	e1bffd17 	ldw	r6,-12(fp)
81105b78:	01400544 	movi	r5,21
81105b7c:	01204834 	movhi	r4,33056
81105b80:	210a0004 	addi	r4,r4,10240
81105b84:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105b88:	00000c06 	br	81105bbc <bFeebCh4SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105b8c:	e0bffe03 	ldbu	r2,-8(fp)
81105b90:	10bfffc4 	addi	r2,r2,-1
81105b94:	108003cc 	andi	r2,r2,15
81105b98:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105b9c:	e1bffd17 	ldw	r6,-12(fp)
81105ba0:	01400504 	movi	r5,20
81105ba4:	01204834 	movhi	r4,33056
81105ba8:	210a0004 	addi	r4,r4,10240
81105bac:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105bb0:	00000206 	br	81105bbc <bFeebCh4SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105bb4:	e03ffc15 	stw	zero,-16(fp)
			break;
81105bb8:	0001883a 	nop
		}
	} else {
81105bbc:	00000106 	br	81105bc4 <bFeebCh4SetBufferSize+0xbc>
		bStatus = FALSE;
81105bc0:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105bc4:	e0bffc17 	ldw	r2,-16(fp)
}
81105bc8:	e037883a 	mov	sp,fp
81105bcc:	dfc00117 	ldw	ra,4(sp)
81105bd0:	df000017 	ldw	fp,0(sp)
81105bd4:	dec00204 	addi	sp,sp,8
81105bd8:	f800283a 	ret

81105bdc <bFeebCh5SetBufferSize>:

bool bFeebCh5SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105bdc:	defffa04 	addi	sp,sp,-24
81105be0:	de00012e 	bgeu	sp,et,81105be8 <bFeebCh5SetBufferSize+0xc>
81105be4:	003b68fa 	trap	3
81105be8:	dfc00515 	stw	ra,20(sp)
81105bec:	df000415 	stw	fp,16(sp)
81105bf0:	df000404 	addi	fp,sp,16
81105bf4:	2007883a 	mov	r3,r4
81105bf8:	2805883a 	mov	r2,r5
81105bfc:	e0fffe05 	stb	r3,-8(fp)
81105c00:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105c04:	00800044 	movi	r2,1
81105c08:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105c0c:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105c10:	e0bffe03 	ldbu	r2,-8(fp)
81105c14:	10001f26 	beq	r2,zero,81105c94 <bFeebCh5SetBufferSize+0xb8>
81105c18:	e0bffe03 	ldbu	r2,-8(fp)
81105c1c:	10800468 	cmpgeui	r2,r2,17
81105c20:	10001c1e 	bne	r2,zero,81105c94 <bFeebCh5SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105c24:	e0bfff03 	ldbu	r2,-4(fp)
81105c28:	10000326 	beq	r2,zero,81105c38 <bFeebCh5SetBufferSize+0x5c>
81105c2c:	10800060 	cmpeqi	r2,r2,1
81105c30:	10000b1e 	bne	r2,zero,81105c60 <bFeebCh5SetBufferSize+0x84>
81105c34:	00001406 	br	81105c88 <bFeebCh5SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c38:	e0bffe03 	ldbu	r2,-8(fp)
81105c3c:	10bfffc4 	addi	r2,r2,-1
81105c40:	108003cc 	andi	r2,r2,15
81105c44:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105c48:	e1bffd17 	ldw	r6,-12(fp)
81105c4c:	01400544 	movi	r5,21
81105c50:	01204834 	movhi	r4,33056
81105c54:	210b0004 	addi	r4,r4,11264
81105c58:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c5c:	00000c06 	br	81105c90 <bFeebCh5SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105c60:	e0bffe03 	ldbu	r2,-8(fp)
81105c64:	10bfffc4 	addi	r2,r2,-1
81105c68:	108003cc 	andi	r2,r2,15
81105c6c:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105c70:	e1bffd17 	ldw	r6,-12(fp)
81105c74:	01400504 	movi	r5,20
81105c78:	01204834 	movhi	r4,33056
81105c7c:	210b0004 	addi	r4,r4,11264
81105c80:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105c84:	00000206 	br	81105c90 <bFeebCh5SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105c88:	e03ffc15 	stw	zero,-16(fp)
			break;
81105c8c:	0001883a 	nop
		}
	} else {
81105c90:	00000106 	br	81105c98 <bFeebCh5SetBufferSize+0xbc>
		bStatus = FALSE;
81105c94:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105c98:	e0bffc17 	ldw	r2,-16(fp)
}
81105c9c:	e037883a 	mov	sp,fp
81105ca0:	dfc00117 	ldw	ra,4(sp)
81105ca4:	df000017 	ldw	fp,0(sp)
81105ca8:	dec00204 	addi	sp,sp,8
81105cac:	f800283a 	ret

81105cb0 <bFeebCh6SetBufferSize>:

bool bFeebCh6SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105cb0:	defffa04 	addi	sp,sp,-24
81105cb4:	de00012e 	bgeu	sp,et,81105cbc <bFeebCh6SetBufferSize+0xc>
81105cb8:	003b68fa 	trap	3
81105cbc:	dfc00515 	stw	ra,20(sp)
81105cc0:	df000415 	stw	fp,16(sp)
81105cc4:	df000404 	addi	fp,sp,16
81105cc8:	2007883a 	mov	r3,r4
81105ccc:	2805883a 	mov	r2,r5
81105cd0:	e0fffe05 	stb	r3,-8(fp)
81105cd4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105cd8:	00800044 	movi	r2,1
81105cdc:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105ce0:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105ce4:	e0bffe03 	ldbu	r2,-8(fp)
81105ce8:	10001f26 	beq	r2,zero,81105d68 <bFeebCh6SetBufferSize+0xb8>
81105cec:	e0bffe03 	ldbu	r2,-8(fp)
81105cf0:	10800468 	cmpgeui	r2,r2,17
81105cf4:	10001c1e 	bne	r2,zero,81105d68 <bFeebCh6SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105cf8:	e0bfff03 	ldbu	r2,-4(fp)
81105cfc:	10000326 	beq	r2,zero,81105d0c <bFeebCh6SetBufferSize+0x5c>
81105d00:	10800060 	cmpeqi	r2,r2,1
81105d04:	10000b1e 	bne	r2,zero,81105d34 <bFeebCh6SetBufferSize+0x84>
81105d08:	00001406 	br	81105d5c <bFeebCh6SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d0c:	e0bffe03 	ldbu	r2,-8(fp)
81105d10:	10bfffc4 	addi	r2,r2,-1
81105d14:	108003cc 	andi	r2,r2,15
81105d18:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105d1c:	e1bffd17 	ldw	r6,-12(fp)
81105d20:	01400544 	movi	r5,21
81105d24:	01204834 	movhi	r4,33056
81105d28:	210a0004 	addi	r4,r4,10240
81105d2c:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d30:	00000c06 	br	81105d64 <bFeebCh6SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105d34:	e0bffe03 	ldbu	r2,-8(fp)
81105d38:	10bfffc4 	addi	r2,r2,-1
81105d3c:	108003cc 	andi	r2,r2,15
81105d40:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105d44:	e1bffd17 	ldw	r6,-12(fp)
81105d48:	01400504 	movi	r5,20
81105d4c:	01204834 	movhi	r4,33056
81105d50:	210a0004 	addi	r4,r4,10240
81105d54:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105d58:	00000206 	br	81105d64 <bFeebCh6SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105d5c:	e03ffc15 	stw	zero,-16(fp)
			break;
81105d60:	0001883a 	nop
		}
	} else {
81105d64:	00000106 	br	81105d6c <bFeebCh6SetBufferSize+0xbc>
		bStatus = FALSE;
81105d68:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105d6c:	e0bffc17 	ldw	r2,-16(fp)
}
81105d70:	e037883a 	mov	sp,fp
81105d74:	dfc00117 	ldw	ra,4(sp)
81105d78:	df000017 	ldw	fp,0(sp)
81105d7c:	dec00204 	addi	sp,sp,8
81105d80:	f800283a 	ret

81105d84 <bFeebCh7SetBufferSize>:

bool bFeebCh7SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105d84:	defffa04 	addi	sp,sp,-24
81105d88:	de00012e 	bgeu	sp,et,81105d90 <bFeebCh7SetBufferSize+0xc>
81105d8c:	003b68fa 	trap	3
81105d90:	dfc00515 	stw	ra,20(sp)
81105d94:	df000415 	stw	fp,16(sp)
81105d98:	df000404 	addi	fp,sp,16
81105d9c:	2007883a 	mov	r3,r4
81105da0:	2805883a 	mov	r2,r5
81105da4:	e0fffe05 	stb	r3,-8(fp)
81105da8:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105dac:	00800044 	movi	r2,1
81105db0:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105db4:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105db8:	e0bffe03 	ldbu	r2,-8(fp)
81105dbc:	10001f26 	beq	r2,zero,81105e3c <bFeebCh7SetBufferSize+0xb8>
81105dc0:	e0bffe03 	ldbu	r2,-8(fp)
81105dc4:	10800468 	cmpgeui	r2,r2,17
81105dc8:	10001c1e 	bne	r2,zero,81105e3c <bFeebCh7SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105dcc:	e0bfff03 	ldbu	r2,-4(fp)
81105dd0:	10000326 	beq	r2,zero,81105de0 <bFeebCh7SetBufferSize+0x5c>
81105dd4:	10800060 	cmpeqi	r2,r2,1
81105dd8:	10000b1e 	bne	r2,zero,81105e08 <bFeebCh7SetBufferSize+0x84>
81105ddc:	00001406 	br	81105e30 <bFeebCh7SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105de0:	e0bffe03 	ldbu	r2,-8(fp)
81105de4:	10bfffc4 	addi	r2,r2,-1
81105de8:	108003cc 	andi	r2,r2,15
81105dec:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105df0:	e1bffd17 	ldw	r6,-12(fp)
81105df4:	01400544 	movi	r5,21
81105df8:	01204834 	movhi	r4,33056
81105dfc:	210b0004 	addi	r4,r4,11264
81105e00:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e04:	00000c06 	br	81105e38 <bFeebCh7SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105e08:	e0bffe03 	ldbu	r2,-8(fp)
81105e0c:	10bfffc4 	addi	r2,r2,-1
81105e10:	108003cc 	andi	r2,r2,15
81105e14:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105e18:	e1bffd17 	ldw	r6,-12(fp)
81105e1c:	01400504 	movi	r5,20
81105e20:	01204834 	movhi	r4,33056
81105e24:	210b0004 	addi	r4,r4,11264
81105e28:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105e2c:	00000206 	br	81105e38 <bFeebCh7SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105e30:	e03ffc15 	stw	zero,-16(fp)
			break;
81105e34:	0001883a 	nop
		}
	} else {
81105e38:	00000106 	br	81105e40 <bFeebCh7SetBufferSize+0xbc>
		bStatus = FALSE;
81105e3c:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105e40:	e0bffc17 	ldw	r2,-16(fp)
}
81105e44:	e037883a 	mov	sp,fp
81105e48:	dfc00117 	ldw	ra,4(sp)
81105e4c:	df000017 	ldw	fp,0(sp)
81105e50:	dec00204 	addi	sp,sp,8
81105e54:	f800283a 	ret

81105e58 <bFeebCh8SetBufferSize>:

bool bFeebCh8SetBufferSize(alt_u8 ucBufferSizeInBlocks, alt_u8 ucBufferSide) {
81105e58:	defffa04 	addi	sp,sp,-24
81105e5c:	de00012e 	bgeu	sp,et,81105e64 <bFeebCh8SetBufferSize+0xc>
81105e60:	003b68fa 	trap	3
81105e64:	dfc00515 	stw	ra,20(sp)
81105e68:	df000415 	stw	fp,16(sp)
81105e6c:	df000404 	addi	fp,sp,16
81105e70:	2007883a 	mov	r3,r4
81105e74:	2805883a 	mov	r2,r5
81105e78:	e0fffe05 	stb	r3,-8(fp)
81105e7c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81105e80:	00800044 	movi	r2,1
81105e84:	e0bffc15 	stw	r2,-16(fp)
	alt_u32 uliReg = 0;
81105e88:	e03ffd15 	stw	zero,-12(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81105e8c:	e0bffe03 	ldbu	r2,-8(fp)
81105e90:	10001f26 	beq	r2,zero,81105f10 <bFeebCh8SetBufferSize+0xb8>
81105e94:	e0bffe03 	ldbu	r2,-8(fp)
81105e98:	10800468 	cmpgeui	r2,r2,17
81105e9c:	10001c1e 	bne	r2,zero,81105f10 <bFeebCh8SetBufferSize+0xb8>
		switch (ucBufferSide) {
81105ea0:	e0bfff03 	ldbu	r2,-4(fp)
81105ea4:	10000326 	beq	r2,zero,81105eb4 <bFeebCh8SetBufferSize+0x5c>
81105ea8:	10800060 	cmpeqi	r2,r2,1
81105eac:	10000b1e 	bne	r2,zero,81105edc <bFeebCh8SetBufferSize+0x84>
81105eb0:	00001406 	br	81105f04 <bFeebCh8SetBufferSize+0xac>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105eb4:	e0bffe03 	ldbu	r2,-8(fp)
81105eb8:	10bfffc4 	addi	r2,r2,-1
81105ebc:	108003cc 	andi	r2,r2,15
81105ec0:	e0bffd15 	stw	r2,-12(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105ec4:	e1bffd17 	ldw	r6,-12(fp)
81105ec8:	01400544 	movi	r5,21
81105ecc:	01204834 	movhi	r4,33056
81105ed0:	210a0004 	addi	r4,r4,10240
81105ed4:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105ed8:	00000c06 	br	81105f0c <bFeebCh8SetBufferSize+0xb4>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
81105edc:	e0bffe03 	ldbu	r2,-8(fp)
81105ee0:	10bfffc4 	addi	r2,r2,-1
81105ee4:	108003cc 	andi	r2,r2,15
81105ee8:	e0bffd15 	stw	r2,-12(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105eec:	e1bffd17 	ldw	r6,-12(fp)
81105ef0:	01400504 	movi	r5,20
81105ef4:	01204834 	movhi	r4,33056
81105ef8:	210a0004 	addi	r4,r4,10240
81105efc:	1106b780 	call	81106b78 <vFeebWriteReg>
			COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81105f00:	00000206 	br	81105f0c <bFeebCh8SetBufferSize+0xb4>
		default:
			bStatus = FALSE;
81105f04:	e03ffc15 	stw	zero,-16(fp)
			break;
81105f08:	0001883a 	nop
		}
	} else {
81105f0c:	00000106 	br	81105f14 <bFeebCh8SetBufferSize+0xbc>
		bStatus = FALSE;
81105f10:	e03ffc15 	stw	zero,-16(fp)
	}

	return bStatus;
81105f14:	e0bffc17 	ldw	r2,-16(fp)
}
81105f18:	e037883a 	mov	sp,fp
81105f1c:	dfc00117 	ldw	ra,4(sp)
81105f20:	df000017 	ldw	fp,0(sp)
81105f24:	dec00204 	addi	sp,sp,8
81105f28:	f800283a 	ret

81105f2c <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81105f2c:	defffc04 	addi	sp,sp,-16
81105f30:	de00012e 	bgeu	sp,et,81105f38 <vFeebInitIrq+0xc>
81105f34:	003b68fa 	trap	3
81105f38:	dfc00315 	stw	ra,12(sp)
81105f3c:	df000215 	stw	fp,8(sp)
81105f40:	df000204 	addi	fp,sp,8
81105f44:	2005883a 	mov	r2,r4
81105f48:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105f4c:	e0bfff03 	ldbu	r2,-4(fp)
81105f50:	10c00228 	cmpgeui	r3,r2,8
81105f54:	18004e1e 	bne	r3,zero,81106090 <vFeebInitIrq+0x164>
81105f58:	100690ba 	slli	r3,r2,2
81105f5c:	00a04434 	movhi	r2,33040
81105f60:	1097dc04 	addi	r2,r2,24432
81105f64:	1885883a 	add	r2,r3,r2
81105f68:	10800017 	ldw	r2,0(r2)
81105f6c:	1000683a 	jmp	r2
81105f70:	81105f90 	cmplti	r4,r16,16766
81105f74:	81105fb0 	cmpltui	r4,r16,16766
81105f78:	81105fd0 	cmplti	r4,r16,16767
81105f7c:	81105ff0 	cmpltui	r4,r16,16767
81105f80:	81106010 	cmplti	r4,r16,16768
81105f84:	81106030 	cmpltui	r4,r16,16768
81105f88:	81106050 	cmplti	r4,r16,16769
81105f8c:	81106070 	cmpltui	r4,r16,16769
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81105f90:	d0a04004 	addi	r2,gp,-32512
81105f94:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
81105f98:	01a04434 	movhi	r6,33040
81105f9c:	31941604 	addi	r6,r6,20568
81105fa0:	e17ffe17 	ldw	r5,-8(fp)
81105fa4:	01000584 	movi	r4,22
81105fa8:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
81105fac:	00003806 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81105fb0:	d0a04104 	addi	r2,gp,-32508
81105fb4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
81105fb8:	01a04434 	movhi	r6,33040
81105fbc:	31942604 	addi	r6,r6,20632
81105fc0:	e17ffe17 	ldw	r5,-8(fp)
81105fc4:	01000504 	movi	r4,20
81105fc8:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
81105fcc:	00003006 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81105fd0:	d0a04204 	addi	r2,gp,-32504
81105fd4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
81105fd8:	01a04434 	movhi	r6,33040
81105fdc:	31944704 	addi	r6,r6,20764
81105fe0:	e17ffe17 	ldw	r5,-8(fp)
81105fe4:	01000484 	movi	r4,18
81105fe8:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105fec:	00002806 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105ff0:	d0a04304 	addi	r2,gp,-32500
81105ff4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
81105ff8:	01a04434 	movhi	r6,33040
81105ffc:	31946804 	addi	r6,r6,20896
81106000:	e17ffe17 	ldw	r5,-8(fp)
81106004:	01000404 	movi	r4,16
81106008:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
8110600c:	00002006 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81106010:	d0a04404 	addi	r2,gp,-32496
81106014:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
81106018:	01a04434 	movhi	r6,33040
8110601c:	31948904 	addi	r6,r6,21028
81106020:	e17ffe17 	ldw	r5,-8(fp)
81106024:	01000204 	movi	r4,8
81106028:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
8110602c:	00001806 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106030:	d0a04504 	addi	r2,gp,-32492
81106034:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
81106038:	01a04434 	movhi	r6,33040
8110603c:	3194aa04 	addi	r6,r6,21160
81106040:	e17ffe17 	ldw	r5,-8(fp)
81106044:	01000184 	movi	r4,6
81106048:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
8110604c:	00001006 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81106050:	d0a04604 	addi	r2,gp,-32488
81106054:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
81106058:	01a04434 	movhi	r6,33040
8110605c:	3194cb04 	addi	r6,r6,21292
81106060:	e17ffe17 	ldw	r5,-8(fp)
81106064:	01000144 	movi	r4,5
81106068:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
8110606c:	00000806 	br	81106090 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106070:	d0a04704 	addi	r2,gp,-32484
81106074:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
81106078:	01a04434 	movhi	r6,33040
8110607c:	3194db04 	addi	r6,r6,21356
81106080:	e17ffe17 	ldw	r5,-8(fp)
81106084:	01000084 	movi	r4,2
81106088:	11346440 	call	81134644 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
8110608c:	0001883a 	nop
	}
}
81106090:	0001883a 	nop
81106094:	e037883a 	mov	sp,fp
81106098:	dfc00117 	ldw	ra,4(sp)
8110609c:	df000017 	ldw	fp,0(sp)
811060a0:	dec00204 	addi	sp,sp,8
811060a4:	f800283a 	ret

811060a8 <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811060a8:	defffb04 	addi	sp,sp,-20
811060ac:	de00012e 	bgeu	sp,et,811060b4 <bFeebSetIrqControl+0xc>
811060b0:	003b68fa 	trap	3
811060b4:	dfc00415 	stw	ra,16(sp)
811060b8:	df000315 	stw	fp,12(sp)
811060bc:	df000304 	addi	fp,sp,12
811060c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811060c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811060c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811060cc:	e0bfff17 	ldw	r2,-4(fp)
811060d0:	10002426 	beq	r2,zero,81106164 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811060d4:	e0bfff17 	ldw	r2,-4(fp)
811060d8:	10800017 	ldw	r2,0(r2)
811060dc:	01400444 	movi	r5,17
811060e0:	1009883a 	mov	r4,r2
811060e4:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811060e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
811060ec:	e0bfff17 	ldw	r2,-4(fp)
811060f0:	10800217 	ldw	r2,8(r2)
811060f4:	10000426 	beq	r2,zero,81106108 <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
811060f8:	e0bffe17 	ldw	r2,-8(fp)
811060fc:	10808014 	ori	r2,r2,512
81106100:	e0bffe15 	stw	r2,-8(fp)
81106104:	00000406 	br	81106118 <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81106108:	e0fffe17 	ldw	r3,-8(fp)
8110610c:	00bf7fc4 	movi	r2,-513
81106110:	1884703a 	and	r2,r3,r2
81106114:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81106118:	e0bfff17 	ldw	r2,-4(fp)
8110611c:	10800317 	ldw	r2,12(r2)
81106120:	10000426 	beq	r2,zero,81106134 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81106124:	e0bffe17 	ldw	r2,-8(fp)
81106128:	10804014 	ori	r2,r2,256
8110612c:	e0bffe15 	stw	r2,-8(fp)
81106130:	00000406 	br	81106144 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81106134:	e0fffe17 	ldw	r3,-8(fp)
81106138:	00bfbfc4 	movi	r2,-257
8110613c:	1884703a 	and	r2,r3,r2
81106140:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106144:	e0bfff17 	ldw	r2,-4(fp)
81106148:	10800017 	ldw	r2,0(r2)
8110614c:	e1bffe17 	ldw	r6,-8(fp)
81106150:	01400444 	movi	r5,17
81106154:	1009883a 	mov	r4,r2
81106158:	1106b780 	call	81106b78 <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
8110615c:	00800044 	movi	r2,1
81106160:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106164:	e0bffd17 	ldw	r2,-12(fp)
}
81106168:	e037883a 	mov	sp,fp
8110616c:	dfc00117 	ldw	ra,4(sp)
81106170:	df000017 	ldw	fp,0(sp)
81106174:	dec00204 	addi	sp,sp,8
81106178:	f800283a 	ret

8110617c <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
8110617c:	defffb04 	addi	sp,sp,-20
81106180:	de00012e 	bgeu	sp,et,81106188 <bFeebGetIrqControl+0xc>
81106184:	003b68fa 	trap	3
81106188:	dfc00415 	stw	ra,16(sp)
8110618c:	df000315 	stw	fp,12(sp)
81106190:	df000304 	addi	fp,sp,12
81106194:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106198:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110619c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811061a0:	e0bfff17 	ldw	r2,-4(fp)
811061a4:	10001a26 	beq	r2,zero,81106210 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811061a8:	e0bfff17 	ldw	r2,-4(fp)
811061ac:	10800017 	ldw	r2,0(r2)
811061b0:	01400444 	movi	r5,17
811061b4:	1009883a 	mov	r4,r2
811061b8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811061bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
811061c0:	e0bffe17 	ldw	r2,-8(fp)
811061c4:	1080800c 	andi	r2,r2,512
811061c8:	10000426 	beq	r2,zero,811061dc <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
811061cc:	e0bfff17 	ldw	r2,-4(fp)
811061d0:	00c00044 	movi	r3,1
811061d4:	10c00215 	stw	r3,8(r2)
811061d8:	00000206 	br	811061e4 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
811061dc:	e0bfff17 	ldw	r2,-4(fp)
811061e0:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
811061e4:	e0bffe17 	ldw	r2,-8(fp)
811061e8:	1080400c 	andi	r2,r2,256
811061ec:	10000426 	beq	r2,zero,81106200 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
811061f0:	e0bfff17 	ldw	r2,-4(fp)
811061f4:	00c00044 	movi	r3,1
811061f8:	10c00315 	stw	r3,12(r2)
811061fc:	00000206 	br	81106208 <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81106200:	e0bfff17 	ldw	r2,-4(fp)
81106204:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81106208:	00800044 	movi	r2,1
8110620c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106210:	e0bffd17 	ldw	r2,-12(fp)
}
81106214:	e037883a 	mov	sp,fp
81106218:	dfc00117 	ldw	ra,4(sp)
8110621c:	df000017 	ldw	fp,0(sp)
81106220:	dec00204 	addi	sp,sp,8
81106224:	f800283a 	ret

81106228 <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81106228:	defffb04 	addi	sp,sp,-20
8110622c:	de00012e 	bgeu	sp,et,81106234 <bFeebGetIrqFlags+0xc>
81106230:	003b68fa 	trap	3
81106234:	dfc00415 	stw	ra,16(sp)
81106238:	df000315 	stw	fp,12(sp)
8110623c:	df000304 	addi	fp,sp,12
81106240:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106244:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106248:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
8110624c:	e0bfff17 	ldw	r2,-4(fp)
81106250:	10001126 	beq	r2,zero,81106298 <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106254:	e0bfff17 	ldw	r2,-4(fp)
81106258:	10800017 	ldw	r2,0(r2)
8110625c:	01400484 	movi	r5,18
81106260:	1009883a 	mov	r4,r2
81106264:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106268:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
8110626c:	e0bffe17 	ldw	r2,-8(fp)
81106270:	1080400c 	andi	r2,r2,256
81106274:	10000426 	beq	r2,zero,81106288 <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81106278:	e0bfff17 	ldw	r2,-4(fp)
8110627c:	00c00044 	movi	r3,1
81106280:	10c00415 	stw	r3,16(r2)
81106284:	00000206 	br	81106290 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81106288:	e0bfff17 	ldw	r2,-4(fp)
8110628c:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81106290:	00800044 	movi	r2,1
81106294:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106298:	e0bffd17 	ldw	r2,-12(fp)
}
8110629c:	e037883a 	mov	sp,fp
811062a0:	dfc00117 	ldw	ra,4(sp)
811062a4:	df000017 	ldw	fp,0(sp)
811062a8:	dec00204 	addi	sp,sp,8
811062ac:	f800283a 	ret

811062b0 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
811062b0:	defffb04 	addi	sp,sp,-20
811062b4:	de00012e 	bgeu	sp,et,811062bc <bFeebGetBuffersStatus+0xc>
811062b8:	003b68fa 	trap	3
811062bc:	dfc00415 	stw	ra,16(sp)
811062c0:	df000315 	stw	fp,12(sp)
811062c4:	df000304 	addi	fp,sp,12
811062c8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811062cc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811062d0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811062d4:	e0bfff17 	ldw	r2,-4(fp)
811062d8:	10003226 	beq	r2,zero,811063a4 <bFeebGetBuffersStatus+0xf4>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811062dc:	e0bfff17 	ldw	r2,-4(fp)
811062e0:	10800017 	ldw	r2,0(r2)
811062e4:	014000c4 	movi	r5,3
811062e8:	1009883a 	mov	r4,r2
811062ec:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811062f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811062f4:	e0bffe17 	ldw	r2,-8(fp)
811062f8:	1080008c 	andi	r2,r2,2
811062fc:	10000426 	beq	r2,zero,81106310 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81106300:	e0bfff17 	ldw	r2,-4(fp)
81106304:	00c00044 	movi	r3,1
81106308:	10c00515 	stw	r3,20(r2)
8110630c:	00000206 	br	81106318 <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81106310:	e0bfff17 	ldw	r2,-4(fp)
81106314:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106318:	e0bffe17 	ldw	r2,-8(fp)
8110631c:	1080004c 	andi	r2,r2,1
81106320:	10000426 	beq	r2,zero,81106334 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81106324:	e0bfff17 	ldw	r2,-4(fp)
81106328:	00c00044 	movi	r3,1
8110632c:	10c00615 	stw	r3,24(r2)
81106330:	00000206 	br	8110633c <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81106334:	e0bfff17 	ldw	r2,-4(fp)
81106338:	10000615 	stw	zero,24(r2)
		}

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110633c:	e0bfff17 	ldw	r2,-4(fp)
81106340:	10800017 	ldw	r2,0(r2)
81106344:	01400504 	movi	r5,20
81106348:	1009883a 	mov	r4,r2
8110634c:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106350:	e0bffe15 	stw	r2,-8(fp)
		COMM_RIGT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106354:	e0bffe17 	ldw	r2,-8(fp)
81106358:	108003cc 	andi	r2,r2,15
8110635c:	10800044 	addi	r2,r2,1
81106360:	1007883a 	mov	r3,r2
81106364:	e0bfff17 	ldw	r2,-4(fp)
81106368:	10c00745 	stb	r3,29(r2)
				& COMM_RIGT_FEEBUFF_SIZE_MSK) + 1;

		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
8110636c:	e0bfff17 	ldw	r2,-4(fp)
81106370:	10800017 	ldw	r2,0(r2)
81106374:	01400544 	movi	r5,21
81106378:	1009883a 	mov	r4,r2
8110637c:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106380:	e0bffe15 	stw	r2,-8(fp)
		COMM_LEFT_FEEBUFF_SIZE_REG_OFST);
		pxFeebCh->xBufferStatus.ucRightBufferSize = (alt_u8) (uliReg
81106384:	e0bffe17 	ldw	r2,-8(fp)
81106388:	108003cc 	andi	r2,r2,15
8110638c:	10800044 	addi	r2,r2,1
81106390:	1007883a 	mov	r3,r2
81106394:	e0bfff17 	ldw	r2,-4(fp)
81106398:	10c00745 	stb	r3,29(r2)
				& COMM_LEFT_FEEBUFF_SIZE_MSK) + 1;

		bStatus = TRUE;
8110639c:	00800044 	movi	r2,1
811063a0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811063a4:	e0bffd17 	ldw	r2,-12(fp)
}
811063a8:	e037883a 	mov	sp,fp
811063ac:	dfc00117 	ldw	ra,4(sp)
811063b0:	df000017 	ldw	fp,0(sp)
811063b4:	dec00204 	addi	sp,sp,8
811063b8:	f800283a 	ret

811063bc <bFeebGetLeftBufferEmpty>:

bool bFeebGetLeftBufferEmpty(TFeebChannel *pxFeebCh){
811063bc:	defffb04 	addi	sp,sp,-20
811063c0:	de00012e 	bgeu	sp,et,811063c8 <bFeebGetLeftBufferEmpty+0xc>
811063c4:	003b68fa 	trap	3
811063c8:	dfc00415 	stw	ra,16(sp)
811063cc:	df000315 	stw	fp,12(sp)
811063d0:	df000304 	addi	fp,sp,12
811063d4:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
811063d8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811063dc:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811063e0:	e0bfff17 	ldw	r2,-4(fp)
811063e4:	10000d26 	beq	r2,zero,8110641c <bFeebGetLeftBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811063e8:	e0bfff17 	ldw	r2,-4(fp)
811063ec:	10800017 	ldw	r2,0(r2)
811063f0:	014000c4 	movi	r5,3
811063f4:	1009883a 	mov	r4,r2
811063f8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811063fc:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81106400:	e0bffe17 	ldw	r2,-8(fp)
81106404:	1080008c 	andi	r2,r2,2
81106408:	10000326 	beq	r2,zero,81106418 <bFeebGetLeftBufferEmpty+0x5c>
			bFlag = TRUE;
8110640c:	00800044 	movi	r2,1
81106410:	e0bffd15 	stw	r2,-12(fp)
81106414:	00000106 	br	8110641c <bFeebGetLeftBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106418:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
8110641c:	e0bffd17 	ldw	r2,-12(fp)
}
81106420:	e037883a 	mov	sp,fp
81106424:	dfc00117 	ldw	ra,4(sp)
81106428:	df000017 	ldw	fp,0(sp)
8110642c:	dec00204 	addi	sp,sp,8
81106430:	f800283a 	ret

81106434 <bFeebGetRightBufferEmpty>:

bool bFeebGetRightBufferEmpty(TFeebChannel *pxFeebCh){
81106434:	defffb04 	addi	sp,sp,-20
81106438:	de00012e 	bgeu	sp,et,81106440 <bFeebGetRightBufferEmpty+0xc>
8110643c:	003b68fa 	trap	3
81106440:	dfc00415 	stw	ra,16(sp)
81106444:	df000315 	stw	fp,12(sp)
81106448:	df000304 	addi	fp,sp,12
8110644c:	e13fff15 	stw	r4,-4(fp)
	bool bFlag = FALSE;
81106450:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106454:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106458:	e0bfff17 	ldw	r2,-4(fp)
8110645c:	10000d26 	beq	r2,zero,81106494 <bFeebGetRightBufferEmpty+0x60>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106460:	e0bfff17 	ldw	r2,-4(fp)
81106464:	10800017 	ldw	r2,0(r2)
81106468:	014000c4 	movi	r5,3
8110646c:	1009883a 	mov	r4,r2
81106470:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106474:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106478:	e0bffe17 	ldw	r2,-8(fp)
8110647c:	1080004c 	andi	r2,r2,1
81106480:	10000326 	beq	r2,zero,81106490 <bFeebGetRightBufferEmpty+0x5c>
			bFlag = TRUE;
81106484:	00800044 	movi	r2,1
81106488:	e0bffd15 	stw	r2,-12(fp)
8110648c:	00000106 	br	81106494 <bFeebGetRightBufferEmpty+0x60>
		} else {
			bFlag = FALSE;
81106490:	e03ffd15 	stw	zero,-12(fp)
		}

	}

	return bFlag;
81106494:	e0bffd17 	ldw	r2,-12(fp)
}
81106498:	e037883a 	mov	sp,fp
8110649c:	dfc00117 	ldw	ra,4(sp)
811064a0:	df000017 	ldw	fp,0(sp)
811064a4:	dec00204 	addi	sp,sp,8
811064a8:	f800283a 	ret

811064ac <bFeebGetCh1LeftBufferEmpty>:

bool bFeebGetCh1LeftBufferEmpty(void){
811064ac:	defffc04 	addi	sp,sp,-16
811064b0:	de00012e 	bgeu	sp,et,811064b8 <bFeebGetCh1LeftBufferEmpty+0xc>
811064b4:	003b68fa 	trap	3
811064b8:	dfc00315 	stw	ra,12(sp)
811064bc:	df000215 	stw	fp,8(sp)
811064c0:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811064c4:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
811064c8:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
811064cc:	014000c4 	movi	r5,3
811064d0:	01204834 	movhi	r4,33056
811064d4:	210b0004 	addi	r4,r4,11264
811064d8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811064dc:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811064e0:	e0bfff17 	ldw	r2,-4(fp)
811064e4:	1080008c 	andi	r2,r2,2
811064e8:	10000326 	beq	r2,zero,811064f8 <bFeebGetCh1LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811064ec:	00800044 	movi	r2,1
811064f0:	e0bffe15 	stw	r2,-8(fp)
811064f4:	00000106 	br	811064fc <bFeebGetCh1LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811064f8:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811064fc:	e0bffe17 	ldw	r2,-8(fp)
}
81106500:	e037883a 	mov	sp,fp
81106504:	dfc00117 	ldw	ra,4(sp)
81106508:	df000017 	ldw	fp,0(sp)
8110650c:	dec00204 	addi	sp,sp,8
81106510:	f800283a 	ret

81106514 <bFeebGetCh1RightBufferEmpty>:

bool bFeebGetCh1RightBufferEmpty(void){
81106514:	defffc04 	addi	sp,sp,-16
81106518:	de00012e 	bgeu	sp,et,81106520 <bFeebGetCh1RightBufferEmpty+0xc>
8110651c:	003b68fa 	trap	3
81106520:	dfc00315 	stw	ra,12(sp)
81106524:	df000215 	stw	fp,8(sp)
81106528:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
8110652c:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106530:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_1_BASE_ADDR,
81106534:	014000c4 	movi	r5,3
81106538:	01204834 	movhi	r4,33056
8110653c:	210b0004 	addi	r4,r4,11264
81106540:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106544:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106548:	e0bfff17 	ldw	r2,-4(fp)
8110654c:	1080004c 	andi	r2,r2,1
81106550:	10000326 	beq	r2,zero,81106560 <bFeebGetCh1RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106554:	00800044 	movi	r2,1
81106558:	e0bffe15 	stw	r2,-8(fp)
8110655c:	00000106 	br	81106564 <bFeebGetCh1RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106560:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106564:	e0bffe17 	ldw	r2,-8(fp)
}
81106568:	e037883a 	mov	sp,fp
8110656c:	dfc00117 	ldw	ra,4(sp)
81106570:	df000017 	ldw	fp,0(sp)
81106574:	dec00204 	addi	sp,sp,8
81106578:	f800283a 	ret

8110657c <bFeebGetCh2LeftBufferEmpty>:

bool bFeebGetCh2LeftBufferEmpty(void){
8110657c:	defffc04 	addi	sp,sp,-16
81106580:	de00012e 	bgeu	sp,et,81106588 <bFeebGetCh2LeftBufferEmpty+0xc>
81106584:	003b68fa 	trap	3
81106588:	dfc00315 	stw	ra,12(sp)
8110658c:	df000215 	stw	fp,8(sp)
81106590:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
81106594:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106598:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
8110659c:	014000c4 	movi	r5,3
811065a0:	01204834 	movhi	r4,33056
811065a4:	210a0004 	addi	r4,r4,10240
811065a8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811065ac:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
811065b0:	e0bfff17 	ldw	r2,-4(fp)
811065b4:	1080008c 	andi	r2,r2,2
811065b8:	10000326 	beq	r2,zero,811065c8 <bFeebGetCh2LeftBufferEmpty+0x4c>
			bFlag = TRUE;
811065bc:	00800044 	movi	r2,1
811065c0:	e0bffe15 	stw	r2,-8(fp)
811065c4:	00000106 	br	811065cc <bFeebGetCh2LeftBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
811065c8:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
811065cc:	e0bffe17 	ldw	r2,-8(fp)
}
811065d0:	e037883a 	mov	sp,fp
811065d4:	dfc00117 	ldw	ra,4(sp)
811065d8:	df000017 	ldw	fp,0(sp)
811065dc:	dec00204 	addi	sp,sp,8
811065e0:	f800283a 	ret

811065e4 <bFeebGetCh2RightBufferEmpty>:

bool bFeebGetCh2RightBufferEmpty(void){
811065e4:	defffc04 	addi	sp,sp,-16
811065e8:	de00012e 	bgeu	sp,et,811065f0 <bFeebGetCh2RightBufferEmpty+0xc>
811065ec:	003b68fa 	trap	3
811065f0:	dfc00315 	stw	ra,12(sp)
811065f4:	df000215 	stw	fp,8(sp)
811065f8:	df000204 	addi	fp,sp,8
	bool bFlag = FALSE;
811065fc:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 uliReg = 0;
81106600:	e03fff15 	stw	zero,-4(fp)

		uliReg = uliFeebReadReg((alt_u32 *) COMM_CHANNEL_2_BASE_ADDR,
81106604:	014000c4 	movi	r5,3
81106608:	01204834 	movhi	r4,33056
8110660c:	210a0004 	addi	r4,r4,10240
81106610:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106614:	e0bfff15 	stw	r2,-4(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81106618:	e0bfff17 	ldw	r2,-4(fp)
8110661c:	1080004c 	andi	r2,r2,1
81106620:	10000326 	beq	r2,zero,81106630 <bFeebGetCh2RightBufferEmpty+0x4c>
			bFlag = TRUE;
81106624:	00800044 	movi	r2,1
81106628:	e0bffe15 	stw	r2,-8(fp)
8110662c:	00000106 	br	81106634 <bFeebGetCh2RightBufferEmpty+0x50>
		} else {
			bFlag = FALSE;
81106630:	e03ffe15 	stw	zero,-8(fp)

	}

		return bFlag;
81106634:	e0bffe17 	ldw	r2,-8(fp)
}
81106638:	e037883a 	mov	sp,fp
8110663c:	dfc00117 	ldw	ra,4(sp)
81106640:	df000017 	ldw	fp,0(sp)
81106644:	dec00204 	addi	sp,sp,8
81106648:	f800283a 	ret

8110664c <bFeebSetBufferSize>:

bool bFeebSetBufferSize(TFeebChannel *pxFeebCh, alt_u8 ucBufferSizeInBlocks,
		alt_u8 ucBufferSide) {
8110664c:	defff904 	addi	sp,sp,-28
81106650:	de00012e 	bgeu	sp,et,81106658 <bFeebSetBufferSize+0xc>
81106654:	003b68fa 	trap	3
81106658:	dfc00615 	stw	ra,24(sp)
8110665c:	df000515 	stw	fp,20(sp)
81106660:	df000504 	addi	fp,sp,20
81106664:	e13ffd15 	stw	r4,-12(fp)
81106668:	2807883a 	mov	r3,r5
8110666c:	3005883a 	mov	r2,r6
81106670:	e0fffe05 	stb	r3,-8(fp)
81106674:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81106678:	00800044 	movi	r2,1
8110667c:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
81106680:	e03ffc15 	stw	zero,-16(fp)

	if ((0 < ucBufferSizeInBlocks) && (16 >= ucBufferSizeInBlocks)) {
81106684:	e0bffe03 	ldbu	r2,-8(fp)
81106688:	10002126 	beq	r2,zero,81106710 <bFeebSetBufferSize+0xc4>
8110668c:	e0bffe03 	ldbu	r2,-8(fp)
81106690:	10800468 	cmpgeui	r2,r2,17
81106694:	10001e1e 	bne	r2,zero,81106710 <bFeebSetBufferSize+0xc4>
		switch (ucBufferSide) {
81106698:	e0bfff03 	ldbu	r2,-4(fp)
8110669c:	10000326 	beq	r2,zero,811066ac <bFeebSetBufferSize+0x60>
811066a0:	10800060 	cmpeqi	r2,r2,1
811066a4:	10000c1e 	bne	r2,zero,811066d8 <bFeebSetBufferSize+0x8c>
811066a8:	00001606 	br	81106704 <bFeebSetBufferSize+0xb8>
		case eCommLeftBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811066ac:	e0bffe03 	ldbu	r2,-8(fp)
811066b0:	10bfffc4 	addi	r2,r2,-1
811066b4:	108003cc 	andi	r2,r2,15
811066b8:	e0bffc15 	stw	r2,-16(fp)
					& COMM_LEFT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
811066bc:	e0bffd17 	ldw	r2,-12(fp)
811066c0:	10800017 	ldw	r2,0(r2)
811066c4:	e1bffc17 	ldw	r6,-16(fp)
811066c8:	01400544 	movi	r5,21
811066cc:	1009883a 	mov	r4,r2
811066d0:	1106b780 	call	81106b78 <vFeebWriteReg>
					COMM_LEFT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
811066d4:	00000d06 	br	8110670c <bFeebSetBufferSize+0xc0>
		case eCommRightBuffer:
			uliReg = (alt_u32) ((ucBufferSizeInBlocks - 1)
811066d8:	e0bffe03 	ldbu	r2,-8(fp)
811066dc:	10bfffc4 	addi	r2,r2,-1
811066e0:	108003cc 	andi	r2,r2,15
811066e4:	e0bffc15 	stw	r2,-16(fp)
					& COMM_RIGT_FEEBUFF_SIZE_MSK);
			vFeebWriteReg(pxFeebCh->puliFeebChAddr,
811066e8:	e0bffd17 	ldw	r2,-12(fp)
811066ec:	10800017 	ldw	r2,0(r2)
811066f0:	e1bffc17 	ldw	r6,-16(fp)
811066f4:	01400504 	movi	r5,20
811066f8:	1009883a 	mov	r4,r2
811066fc:	1106b780 	call	81106b78 <vFeebWriteReg>
					COMM_RIGT_FEEBUFF_SIZE_REG_OFST, uliReg);
			break;
81106700:	00000206 	br	8110670c <bFeebSetBufferSize+0xc0>
		default:
			bStatus = FALSE;
81106704:	e03ffb15 	stw	zero,-20(fp)
			break;
81106708:	0001883a 	nop
		}
	} else {
8110670c:	00000106 	br	81106714 <bFeebSetBufferSize+0xc8>
		bStatus = FALSE;
81106710:	e03ffb15 	stw	zero,-20(fp)
	}

	return bStatus;
81106714:	e0bffb17 	ldw	r2,-20(fp)
}
81106718:	e037883a 	mov	sp,fp
8110671c:	dfc00117 	ldw	ra,4(sp)
81106720:	df000017 	ldw	fp,0(sp)
81106724:	dec00204 	addi	sp,sp,8
81106728:	f800283a 	ret

8110672c <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
8110672c:	defffb04 	addi	sp,sp,-20
81106730:	de00012e 	bgeu	sp,et,81106738 <bFeebSetWindowing+0xc>
81106734:	003b68fa 	trap	3
81106738:	dfc00415 	stw	ra,16(sp)
8110673c:	df000315 	stw	fp,12(sp)
81106740:	df000304 	addi	fp,sp,12
81106744:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106748:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110674c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106750:	e0bfff17 	ldw	r2,-4(fp)
81106754:	10001926 	beq	r2,zero,811067bc <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106758:	e0bfff17 	ldw	r2,-4(fp)
8110675c:	10800017 	ldw	r2,0(r2)
81106760:	01400084 	movi	r5,2
81106764:	1009883a 	mov	r4,r2
81106768:	1106bcc0 	call	81106bcc <uliFeebReadReg>
8110676c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81106770:	e0bfff17 	ldw	r2,-4(fp)
81106774:	10800117 	ldw	r2,4(r2)
81106778:	10000426 	beq	r2,zero,8110678c <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
8110677c:	e0bffe17 	ldw	r2,-8(fp)
81106780:	10800214 	ori	r2,r2,8
81106784:	e0bffe15 	stw	r2,-8(fp)
81106788:	00000406 	br	8110679c <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
8110678c:	e0fffe17 	ldw	r3,-8(fp)
81106790:	00bffdc4 	movi	r2,-9
81106794:	1884703a 	and	r2,r3,r2
81106798:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
8110679c:	e0bfff17 	ldw	r2,-4(fp)
811067a0:	10800017 	ldw	r2,0(r2)
811067a4:	e1bffe17 	ldw	r6,-8(fp)
811067a8:	01400084 	movi	r5,2
811067ac:	1009883a 	mov	r4,r2
811067b0:	1106b780 	call	81106b78 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811067b4:	00800044 	movi	r2,1
811067b8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811067bc:	e0bffd17 	ldw	r2,-12(fp)
}
811067c0:	e037883a 	mov	sp,fp
811067c4:	dfc00117 	ldw	ra,4(sp)
811067c8:	df000017 	ldw	fp,0(sp)
811067cc:	dec00204 	addi	sp,sp,8
811067d0:	f800283a 	ret

811067d4 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
811067d4:	defffb04 	addi	sp,sp,-20
811067d8:	de00012e 	bgeu	sp,et,811067e0 <bFeebGetWindowing+0xc>
811067dc:	003b68fa 	trap	3
811067e0:	dfc00415 	stw	ra,16(sp)
811067e4:	df000315 	stw	fp,12(sp)
811067e8:	df000304 	addi	fp,sp,12
811067ec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811067f0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811067f4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811067f8:	e0bfff17 	ldw	r2,-4(fp)
811067fc:	10001126 	beq	r2,zero,81106844 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106800:	e0bfff17 	ldw	r2,-4(fp)
81106804:	10800017 	ldw	r2,0(r2)
81106808:	01400084 	movi	r5,2
8110680c:	1009883a 	mov	r4,r2
81106810:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106814:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81106818:	e0bffe17 	ldw	r2,-8(fp)
8110681c:	1080020c 	andi	r2,r2,8
81106820:	10000426 	beq	r2,zero,81106834 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81106824:	e0bfff17 	ldw	r2,-4(fp)
81106828:	00c00044 	movi	r3,1
8110682c:	10c00115 	stw	r3,4(r2)
81106830:	00000206 	br	8110683c <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81106834:	e0bfff17 	ldw	r2,-4(fp)
81106838:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
8110683c:	00800044 	movi	r2,1
81106840:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106844:	e0bffd17 	ldw	r2,-12(fp)
}
81106848:	e037883a 	mov	sp,fp
8110684c:	dfc00117 	ldw	ra,4(sp)
81106850:	df000017 	ldw	fp,0(sp)
81106854:	dec00204 	addi	sp,sp,8
81106858:	f800283a 	ret

8110685c <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
8110685c:	defffb04 	addi	sp,sp,-20
81106860:	de00012e 	bgeu	sp,et,81106868 <bFeebStartCh+0xc>
81106864:	003b68fa 	trap	3
81106868:	dfc00415 	stw	ra,16(sp)
8110686c:	df000315 	stw	fp,12(sp)
81106870:	df000304 	addi	fp,sp,12
81106874:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106878:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110687c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106880:	e0bfff17 	ldw	r2,-4(fp)
81106884:	10001126 	beq	r2,zero,811068cc <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106888:	e0bfff17 	ldw	r2,-4(fp)
8110688c:	10800017 	ldw	r2,0(r2)
81106890:	01400084 	movi	r5,2
81106894:	1009883a 	mov	r4,r2
81106898:	1106bcc0 	call	81106bcc <uliFeebReadReg>
8110689c:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
811068a0:	e0bffe17 	ldw	r2,-8(fp)
811068a4:	10800114 	ori	r2,r2,4
811068a8:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811068ac:	e0bfff17 	ldw	r2,-4(fp)
811068b0:	10800017 	ldw	r2,0(r2)
811068b4:	e1bffe17 	ldw	r6,-8(fp)
811068b8:	01400084 	movi	r5,2
811068bc:	1009883a 	mov	r4,r2
811068c0:	1106b780 	call	81106b78 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811068c4:	00800044 	movi	r2,1
811068c8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811068cc:	e0bffd17 	ldw	r2,-12(fp)
}
811068d0:	e037883a 	mov	sp,fp
811068d4:	dfc00117 	ldw	ra,4(sp)
811068d8:	df000017 	ldw	fp,0(sp)
811068dc:	dec00204 	addi	sp,sp,8
811068e0:	f800283a 	ret

811068e4 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
811068e4:	defffb04 	addi	sp,sp,-20
811068e8:	de00012e 	bgeu	sp,et,811068f0 <bFeebStopCh+0xc>
811068ec:	003b68fa 	trap	3
811068f0:	dfc00415 	stw	ra,16(sp)
811068f4:	df000315 	stw	fp,12(sp)
811068f8:	df000304 	addi	fp,sp,12
811068fc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106900:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106904:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106908:	e0bfff17 	ldw	r2,-4(fp)
8110690c:	10001126 	beq	r2,zero,81106954 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106910:	e0bfff17 	ldw	r2,-4(fp)
81106914:	10800017 	ldw	r2,0(r2)
81106918:	01400084 	movi	r5,2
8110691c:	1009883a 	mov	r4,r2
81106920:	1106bcc0 	call	81106bcc <uliFeebReadReg>
81106924:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81106928:	e0bffe17 	ldw	r2,-8(fp)
8110692c:	10800094 	ori	r2,r2,2
81106930:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81106934:	e0bfff17 	ldw	r2,-4(fp)
81106938:	10800017 	ldw	r2,0(r2)
8110693c:	e1bffe17 	ldw	r6,-8(fp)
81106940:	01400084 	movi	r5,2
81106944:	1009883a 	mov	r4,r2
81106948:	1106b780 	call	81106b78 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
8110694c:	00800044 	movi	r2,1
81106950:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106954:	e0bffd17 	ldw	r2,-12(fp)
}
81106958:	e037883a 	mov	sp,fp
8110695c:	dfc00117 	ldw	ra,4(sp)
81106960:	df000017 	ldw	fp,0(sp)
81106964:	dec00204 	addi	sp,sp,8
81106968:	f800283a 	ret

8110696c <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
8110696c:	defffb04 	addi	sp,sp,-20
81106970:	de00012e 	bgeu	sp,et,81106978 <bFeebClrCh+0xc>
81106974:	003b68fa 	trap	3
81106978:	dfc00415 	stw	ra,16(sp)
8110697c:	df000315 	stw	fp,12(sp)
81106980:	df000304 	addi	fp,sp,12
81106984:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106988:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110698c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81106990:	e0bfff17 	ldw	r2,-4(fp)
81106994:	10001126 	beq	r2,zero,811069dc <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81106998:	e0bfff17 	ldw	r2,-4(fp)
8110699c:	10800017 	ldw	r2,0(r2)
811069a0:	01400084 	movi	r5,2
811069a4:	1009883a 	mov	r4,r2
811069a8:	1106bcc0 	call	81106bcc <uliFeebReadReg>
811069ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
811069b0:	e0bffe17 	ldw	r2,-8(fp)
811069b4:	10800054 	ori	r2,r2,1
811069b8:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
811069bc:	e0bfff17 	ldw	r2,-4(fp)
811069c0:	10800017 	ldw	r2,0(r2)
811069c4:	e1bffe17 	ldw	r6,-8(fp)
811069c8:	01400084 	movi	r5,2
811069cc:	1009883a 	mov	r4,r2
811069d0:	1106b780 	call	81106b78 <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
811069d4:	00800044 	movi	r2,1
811069d8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811069dc:	e0bffd17 	ldw	r2,-12(fp)
}
811069e0:	e037883a 	mov	sp,fp
811069e4:	dfc00117 	ldw	ra,4(sp)
811069e8:	df000017 	ldw	fp,0(sp)
811069ec:	dec00204 	addi	sp,sp,8
811069f0:	f800283a 	ret

811069f4 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
811069f4:	defffb04 	addi	sp,sp,-20
811069f8:	de00012e 	bgeu	sp,et,81106a00 <bFeebInitCh+0xc>
811069fc:	003b68fa 	trap	3
81106a00:	dfc00415 	stw	ra,16(sp)
81106a04:	df000315 	stw	fp,12(sp)
81106a08:	df000304 	addi	fp,sp,12
81106a0c:	e13ffe15 	stw	r4,-8(fp)
81106a10:	2805883a 	mov	r2,r5
81106a14:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81106a18:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81106a1c:	e0bffe17 	ldw	r2,-8(fp)
81106a20:	10004f26 	beq	r2,zero,81106b60 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81106a24:	00800044 	movi	r2,1
81106a28:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81106a2c:	e0bfff03 	ldbu	r2,-4(fp)
81106a30:	10c00228 	cmpgeui	r3,r2,8
81106a34:	1800361e 	bne	r3,zero,81106b10 <bFeebInitCh+0x11c>
81106a38:	100690ba 	slli	r3,r2,2
81106a3c:	00a04434 	movhi	r2,33040
81106a40:	109a9404 	addi	r2,r2,27216
81106a44:	1885883a 	add	r2,r3,r2
81106a48:	10800017 	ldw	r2,0(r2)
81106a4c:	1000683a 	jmp	r2
81106a50:	81106a70 	cmpltui	r4,r16,16809
81106a54:	81106a84 	addi	r4,r16,16810
81106a58:	81106a98 	cmpnei	r4,r16,16810
81106a5c:	81106aac 	andhi	r4,r16,16810
81106a60:	81106ac0 	call	881106ac <__reset+0x20f06ac>
81106a64:	81106ad4 	ori	r4,r16,16811
81106a68:	81106ae8 	cmpgeui	r4,r16,16811
81106a6c:	81106afc 	xorhi	r4,r16,16811
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81106a70:	e0fffe17 	ldw	r3,-8(fp)
81106a74:	00a04834 	movhi	r2,33056
81106a78:	108b0004 	addi	r2,r2,11264
81106a7c:	18800015 	stw	r2,0(r3)
			break;
81106a80:	00002506 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81106a84:	e0fffe17 	ldw	r3,-8(fp)
81106a88:	00a04834 	movhi	r2,33056
81106a8c:	108a0004 	addi	r2,r2,10240
81106a90:	18800015 	stw	r2,0(r3)
			break;
81106a94:	00002006 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81106a98:	e0fffe17 	ldw	r3,-8(fp)
81106a9c:	00a04834 	movhi	r2,33056
81106aa0:	108b0004 	addi	r2,r2,11264
81106aa4:	18800015 	stw	r2,0(r3)
			break;
81106aa8:	00001b06 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106aac:	e0fffe17 	ldw	r3,-8(fp)
81106ab0:	00a04834 	movhi	r2,33056
81106ab4:	108a0004 	addi	r2,r2,10240
81106ab8:	18800015 	stw	r2,0(r3)
			break;
81106abc:	00001606 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106ac0:	e0fffe17 	ldw	r3,-8(fp)
81106ac4:	00a04834 	movhi	r2,33056
81106ac8:	108b0004 	addi	r2,r2,11264
81106acc:	18800015 	stw	r2,0(r3)
			break;
81106ad0:	00001106 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106ad4:	e0fffe17 	ldw	r3,-8(fp)
81106ad8:	00a04834 	movhi	r2,33056
81106adc:	108a0004 	addi	r2,r2,10240
81106ae0:	18800015 	stw	r2,0(r3)
			break;
81106ae4:	00000c06 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81106ae8:	e0fffe17 	ldw	r3,-8(fp)
81106aec:	00a04834 	movhi	r2,33056
81106af0:	108b0004 	addi	r2,r2,11264
81106af4:	18800015 	stw	r2,0(r3)
			break;
81106af8:	00000706 	br	81106b18 <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106afc:	e0fffe17 	ldw	r3,-8(fp)
81106b00:	00a04834 	movhi	r2,33056
81106b04:	108a0004 	addi	r2,r2,10240
81106b08:	18800015 	stw	r2,0(r3)
			break;
81106b0c:	00000206 	br	81106b18 <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106b10:	e03ffd15 	stw	zero,-12(fp)
			break;
81106b14:	0001883a 	nop
		}

		if (bStatus) {
81106b18:	e0bffd17 	ldw	r2,-12(fp)
81106b1c:	10001026 	beq	r2,zero,81106b60 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106b20:	e13ffe17 	ldw	r4,-8(fp)
81106b24:	110617c0 	call	8110617c <bFeebGetIrqControl>
81106b28:	1000011e 	bne	r2,zero,81106b30 <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106b2c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106b30:	e13ffe17 	ldw	r4,-8(fp)
81106b34:	11062280 	call	81106228 <bFeebGetIrqFlags>
81106b38:	1000011e 	bne	r2,zero,81106b40 <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106b3c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106b40:	e13ffe17 	ldw	r4,-8(fp)
81106b44:	11062b00 	call	811062b0 <bFeebGetBuffersStatus>
81106b48:	1000011e 	bne	r2,zero,81106b50 <bFeebInitCh+0x15c>
				bStatus = FALSE;
81106b4c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
81106b50:	e13ffe17 	ldw	r4,-8(fp)
81106b54:	11067d40 	call	811067d4 <bFeebGetWindowing>
81106b58:	1000011e 	bne	r2,zero,81106b60 <bFeebInitCh+0x16c>
				bStatus = FALSE;
81106b5c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81106b60:	e0bffd17 	ldw	r2,-12(fp)
}
81106b64:	e037883a 	mov	sp,fp
81106b68:	dfc00117 	ldw	ra,4(sp)
81106b6c:	df000017 	ldw	fp,0(sp)
81106b70:	dec00204 	addi	sp,sp,8
81106b74:	f800283a 	ret

81106b78 <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81106b78:	defffc04 	addi	sp,sp,-16
81106b7c:	de00012e 	bgeu	sp,et,81106b84 <vFeebWriteReg+0xc>
81106b80:	003b68fa 	trap	3
81106b84:	df000315 	stw	fp,12(sp)
81106b88:	df000304 	addi	fp,sp,12
81106b8c:	e13ffd15 	stw	r4,-12(fp)
81106b90:	e17ffe15 	stw	r5,-8(fp)
81106b94:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81106b98:	e0bffe17 	ldw	r2,-8(fp)
81106b9c:	1085883a 	add	r2,r2,r2
81106ba0:	1085883a 	add	r2,r2,r2
81106ba4:	1007883a 	mov	r3,r2
81106ba8:	e0bffd17 	ldw	r2,-12(fp)
81106bac:	10c5883a 	add	r2,r2,r3
81106bb0:	e0ffff17 	ldw	r3,-4(fp)
81106bb4:	10c00015 	stw	r3,0(r2)
}
81106bb8:	0001883a 	nop
81106bbc:	e037883a 	mov	sp,fp
81106bc0:	df000017 	ldw	fp,0(sp)
81106bc4:	dec00104 	addi	sp,sp,4
81106bc8:	f800283a 	ret

81106bcc <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106bcc:	defffc04 	addi	sp,sp,-16
81106bd0:	de00012e 	bgeu	sp,et,81106bd8 <uliFeebReadReg+0xc>
81106bd4:	003b68fa 	trap	3
81106bd8:	df000315 	stw	fp,12(sp)
81106bdc:	df000304 	addi	fp,sp,12
81106be0:	e13ffe15 	stw	r4,-8(fp)
81106be4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81106be8:	e0bfff17 	ldw	r2,-4(fp)
81106bec:	1085883a 	add	r2,r2,r2
81106bf0:	1085883a 	add	r2,r2,r2
81106bf4:	1007883a 	mov	r3,r2
81106bf8:	e0bffe17 	ldw	r2,-8(fp)
81106bfc:	10c5883a 	add	r2,r2,r3
81106c00:	10800017 	ldw	r2,0(r2)
81106c04:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81106c08:	e0bffd17 	ldw	r2,-12(fp)
}
81106c0c:	e037883a 	mov	sp,fp
81106c10:	df000017 	ldw	fp,0(sp)
81106c14:	dec00104 	addi	sp,sp,4
81106c18:	f800283a 	ret

81106c1c <vRmapCh1HandleIrq>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
/* todo:Trigger not working right */
void vRmapCh1HandleIrq(void* pvContext) {
81106c1c:	defffa04 	addi	sp,sp,-24
81106c20:	de00012e 	bgeu	sp,et,81106c28 <vRmapCh1HandleIrq+0xc>
81106c24:	003b68fa 	trap	3
81106c28:	dfc00515 	stw	ra,20(sp)
81106c2c:	df000415 	stw	fp,16(sp)
81106c30:	df000404 	addi	fp,sp,16
81106c34:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106c38:	e0bfff17 	ldw	r2,-4(fp)
81106c3c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */

#ifdef DEBUG_ON
	fprintf(fp,"IRQ RMAP.\n");
81106c40:	d0a06117 	ldw	r2,-32380(gp)
81106c44:	100f883a 	mov	r7,r2
81106c48:	01800284 	movi	r6,10
81106c4c:	01400044 	movi	r5,1
81106c50:	01204574 	movhi	r4,33045
81106c54:	21291504 	addi	r4,r4,-23468
81106c58:	111fc980 	call	8111fc98 <fwrite>
#endif

	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106c5c:	11073800 	call	81107380 <uliRmapCh1WriteCmdAddress>
81106c60:	e0bffd05 	stb	r2,-12(fp)

	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
81106c64:	00800444 	movi	r2,17
81106c68:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
81106c6c:	00bffc04 	movi	r2,-16
81106c70:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
81106c74:	e0bffd03 	ldbu	r2,-12(fp)
81106c78:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
81106c7c:	e03ffe05 	stb	zero,-8(fp)

#ifdef DEBUG_ON
	fprintf(fp,"IucADDRReg: %u\n", ucADDRReg);
81106c80:	d0a06117 	ldw	r2,-32380(gp)
81106c84:	e0fffd03 	ldbu	r3,-12(fp)
81106c88:	180d883a 	mov	r6,r3
81106c8c:	01604574 	movhi	r5,33045
81106c90:	29691804 	addi	r5,r5,-23456
81106c94:	1009883a 	mov	r4,r2
81106c98:	111f5fc0 	call	8111f5fc <fprintf>
#endif

	error_codel = OSQPostFront(xFeeQ[0], (void *)uiCmdRmap.ulWord);
81106c9c:	d0a06917 	ldw	r2,-32348(gp)
81106ca0:	e0fffe17 	ldw	r3,-8(fp)
81106ca4:	180b883a 	mov	r5,r3
81106ca8:	1009883a 	mov	r4,r2
81106cac:	113c1980 	call	8113c198 <OSQPostFront>
81106cb0:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
81106cb4:	e0bffd43 	ldbu	r2,-11(fp)
81106cb8:	10000226 	beq	r2,zero,81106cc4 <vRmapCh1HandleIrq+0xa8>
		vFailSendRMAPFromIRQ( 0 );
81106cbc:	0009883a 	mov	r4,zero
81106cc0:	111b5a80 	call	8111b5a8 <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
81106cc4:	1106ea00 	call	81106ea0 <vRmapCh1IrqFlagClrWriteCmd>
}
81106cc8:	0001883a 	nop
81106ccc:	e037883a 	mov	sp,fp
81106cd0:	dfc00117 	ldw	ra,4(sp)
81106cd4:	df000017 	ldw	fp,0(sp)
81106cd8:	dec00204 	addi	sp,sp,8
81106cdc:	f800283a 	ret

81106ce0 <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
81106ce0:	defffc04 	addi	sp,sp,-16
81106ce4:	de00012e 	bgeu	sp,et,81106cec <vRmapCh2HandleIrq+0xc>
81106ce8:	003b68fa 	trap	3
81106cec:	dfc00315 	stw	ra,12(sp)
81106cf0:	df000215 	stw	fp,8(sp)
81106cf4:	df000204 	addi	fp,sp,8
81106cf8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106cfc:	e0bfff17 	ldw	r2,-4(fp)
81106d00:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81106d04:	1106ee40 	call	81106ee4 <vRmapCh2IrqFlagClrWriteCmd>
}
81106d08:	0001883a 	nop
81106d0c:	e037883a 	mov	sp,fp
81106d10:	dfc00117 	ldw	ra,4(sp)
81106d14:	df000017 	ldw	fp,0(sp)
81106d18:	dec00204 	addi	sp,sp,8
81106d1c:	f800283a 	ret

81106d20 <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
81106d20:	defffc04 	addi	sp,sp,-16
81106d24:	de00012e 	bgeu	sp,et,81106d2c <vRmapCh3HandleIrq+0xc>
81106d28:	003b68fa 	trap	3
81106d2c:	dfc00315 	stw	ra,12(sp)
81106d30:	df000215 	stw	fp,8(sp)
81106d34:	df000204 	addi	fp,sp,8
81106d38:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106d3c:	e0bfff17 	ldw	r2,-4(fp)
81106d40:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106d44:	1106f280 	call	81106f28 <vRmapCh3IrqFlagClrWriteCmd>
}
81106d48:	0001883a 	nop
81106d4c:	e037883a 	mov	sp,fp
81106d50:	dfc00117 	ldw	ra,4(sp)
81106d54:	df000017 	ldw	fp,0(sp)
81106d58:	dec00204 	addi	sp,sp,8
81106d5c:	f800283a 	ret

81106d60 <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
81106d60:	defffc04 	addi	sp,sp,-16
81106d64:	de00012e 	bgeu	sp,et,81106d6c <vRmapCh4HandleIrq+0xc>
81106d68:	003b68fa 	trap	3
81106d6c:	dfc00315 	stw	ra,12(sp)
81106d70:	df000215 	stw	fp,8(sp)
81106d74:	df000204 	addi	fp,sp,8
81106d78:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106d7c:	e0bfff17 	ldw	r2,-4(fp)
81106d80:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
81106d84:	1106f6c0 	call	81106f6c <vRmapCh4IrqFlagClrWriteCmd>
}
81106d88:	0001883a 	nop
81106d8c:	e037883a 	mov	sp,fp
81106d90:	dfc00117 	ldw	ra,4(sp)
81106d94:	df000017 	ldw	fp,0(sp)
81106d98:	dec00204 	addi	sp,sp,8
81106d9c:	f800283a 	ret

81106da0 <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
81106da0:	defffc04 	addi	sp,sp,-16
81106da4:	de00012e 	bgeu	sp,et,81106dac <vRmapCh5HandleIrq+0xc>
81106da8:	003b68fa 	trap	3
81106dac:	dfc00315 	stw	ra,12(sp)
81106db0:	df000215 	stw	fp,8(sp)
81106db4:	df000204 	addi	fp,sp,8
81106db8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106dbc:	e0bfff17 	ldw	r2,-4(fp)
81106dc0:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
81106dc4:	1106fb00 	call	81106fb0 <vRmapCh5IrqFlagClrWriteCmd>
}
81106dc8:	0001883a 	nop
81106dcc:	e037883a 	mov	sp,fp
81106dd0:	dfc00117 	ldw	ra,4(sp)
81106dd4:	df000017 	ldw	fp,0(sp)
81106dd8:	dec00204 	addi	sp,sp,8
81106ddc:	f800283a 	ret

81106de0 <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
81106de0:	defffc04 	addi	sp,sp,-16
81106de4:	de00012e 	bgeu	sp,et,81106dec <vRmapCh6HandleIrq+0xc>
81106de8:	003b68fa 	trap	3
81106dec:	dfc00315 	stw	ra,12(sp)
81106df0:	df000215 	stw	fp,8(sp)
81106df4:	df000204 	addi	fp,sp,8
81106df8:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106dfc:	e0bfff17 	ldw	r2,-4(fp)
81106e00:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106e04:	1106ff40 	call	81106ff4 <vRmapCh6IrqFlagClrWriteCmd>
}
81106e08:	0001883a 	nop
81106e0c:	e037883a 	mov	sp,fp
81106e10:	dfc00117 	ldw	ra,4(sp)
81106e14:	df000017 	ldw	fp,0(sp)
81106e18:	dec00204 	addi	sp,sp,8
81106e1c:	f800283a 	ret

81106e20 <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
81106e20:	defffc04 	addi	sp,sp,-16
81106e24:	de00012e 	bgeu	sp,et,81106e2c <vRmapCh7HandleIrq+0xc>
81106e28:	003b68fa 	trap	3
81106e2c:	dfc00315 	stw	ra,12(sp)
81106e30:	df000215 	stw	fp,8(sp)
81106e34:	df000204 	addi	fp,sp,8
81106e38:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e3c:	e0bfff17 	ldw	r2,-4(fp)
81106e40:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106e44:	11070380 	call	81107038 <vRmapCh7IrqFlagClrWriteCmd>
}
81106e48:	0001883a 	nop
81106e4c:	e037883a 	mov	sp,fp
81106e50:	dfc00117 	ldw	ra,4(sp)
81106e54:	df000017 	ldw	fp,0(sp)
81106e58:	dec00204 	addi	sp,sp,8
81106e5c:	f800283a 	ret

81106e60 <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
81106e60:	defffc04 	addi	sp,sp,-16
81106e64:	de00012e 	bgeu	sp,et,81106e6c <vRmapCh8HandleIrq+0xc>
81106e68:	003b68fa 	trap	3
81106e6c:	dfc00315 	stw	ra,12(sp)
81106e70:	df000215 	stw	fp,8(sp)
81106e74:	df000204 	addi	fp,sp,8
81106e78:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106e7c:	e0bfff17 	ldw	r2,-4(fp)
81106e80:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
81106e84:	110707c0 	call	8110707c <vRmapCh8IrqFlagClrWriteCmd>
}
81106e88:	0001883a 	nop
81106e8c:	e037883a 	mov	sp,fp
81106e90:	dfc00117 	ldw	ra,4(sp)
81106e94:	df000017 	ldw	fp,0(sp)
81106e98:	dec00204 	addi	sp,sp,8
81106e9c:	f800283a 	ret

81106ea0 <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
81106ea0:	defffe04 	addi	sp,sp,-8
81106ea4:	de00012e 	bgeu	sp,et,81106eac <vRmapCh1IrqFlagClrWriteCmd+0xc>
81106ea8:	003b68fa 	trap	3
81106eac:	dfc00115 	stw	ra,4(sp)
81106eb0:	df000015 	stw	fp,0(sp)
81106eb4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106eb8:	01800044 	movi	r6,1
81106ebc:	014004c4 	movi	r5,19
81106ec0:	01204834 	movhi	r4,33056
81106ec4:	210b0004 	addi	r4,r4,11264
81106ec8:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106ecc:	0001883a 	nop
81106ed0:	e037883a 	mov	sp,fp
81106ed4:	dfc00117 	ldw	ra,4(sp)
81106ed8:	df000017 	ldw	fp,0(sp)
81106edc:	dec00204 	addi	sp,sp,8
81106ee0:	f800283a 	ret

81106ee4 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106ee4:	defffe04 	addi	sp,sp,-8
81106ee8:	de00012e 	bgeu	sp,et,81106ef0 <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106eec:	003b68fa 	trap	3
81106ef0:	dfc00115 	stw	ra,4(sp)
81106ef4:	df000015 	stw	fp,0(sp)
81106ef8:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106efc:	01800044 	movi	r6,1
81106f00:	014004c4 	movi	r5,19
81106f04:	01204834 	movhi	r4,33056
81106f08:	210a0004 	addi	r4,r4,10240
81106f0c:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f10:	0001883a 	nop
81106f14:	e037883a 	mov	sp,fp
81106f18:	dfc00117 	ldw	ra,4(sp)
81106f1c:	df000017 	ldw	fp,0(sp)
81106f20:	dec00204 	addi	sp,sp,8
81106f24:	f800283a 	ret

81106f28 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106f28:	defffe04 	addi	sp,sp,-8
81106f2c:	de00012e 	bgeu	sp,et,81106f34 <vRmapCh3IrqFlagClrWriteCmd+0xc>
81106f30:	003b68fa 	trap	3
81106f34:	dfc00115 	stw	ra,4(sp)
81106f38:	df000015 	stw	fp,0(sp)
81106f3c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81106f40:	01800044 	movi	r6,1
81106f44:	014004c4 	movi	r5,19
81106f48:	01204834 	movhi	r4,33056
81106f4c:	210b0004 	addi	r4,r4,11264
81106f50:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f54:	0001883a 	nop
81106f58:	e037883a 	mov	sp,fp
81106f5c:	dfc00117 	ldw	ra,4(sp)
81106f60:	df000017 	ldw	fp,0(sp)
81106f64:	dec00204 	addi	sp,sp,8
81106f68:	f800283a 	ret

81106f6c <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106f6c:	defffe04 	addi	sp,sp,-8
81106f70:	de00012e 	bgeu	sp,et,81106f78 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106f74:	003b68fa 	trap	3
81106f78:	dfc00115 	stw	ra,4(sp)
81106f7c:	df000015 	stw	fp,0(sp)
81106f80:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106f84:	01800044 	movi	r6,1
81106f88:	014004c4 	movi	r5,19
81106f8c:	01204834 	movhi	r4,33056
81106f90:	210a0004 	addi	r4,r4,10240
81106f94:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106f98:	0001883a 	nop
81106f9c:	e037883a 	mov	sp,fp
81106fa0:	dfc00117 	ldw	ra,4(sp)
81106fa4:	df000017 	ldw	fp,0(sp)
81106fa8:	dec00204 	addi	sp,sp,8
81106fac:	f800283a 	ret

81106fb0 <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
81106fb0:	defffe04 	addi	sp,sp,-8
81106fb4:	de00012e 	bgeu	sp,et,81106fbc <vRmapCh5IrqFlagClrWriteCmd+0xc>
81106fb8:	003b68fa 	trap	3
81106fbc:	dfc00115 	stw	ra,4(sp)
81106fc0:	df000015 	stw	fp,0(sp)
81106fc4:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106fc8:	01800044 	movi	r6,1
81106fcc:	014004c4 	movi	r5,19
81106fd0:	01204834 	movhi	r4,33056
81106fd4:	210b0004 	addi	r4,r4,11264
81106fd8:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106fdc:	0001883a 	nop
81106fe0:	e037883a 	mov	sp,fp
81106fe4:	dfc00117 	ldw	ra,4(sp)
81106fe8:	df000017 	ldw	fp,0(sp)
81106fec:	dec00204 	addi	sp,sp,8
81106ff0:	f800283a 	ret

81106ff4 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81106ff4:	defffe04 	addi	sp,sp,-8
81106ff8:	de00012e 	bgeu	sp,et,81107000 <vRmapCh6IrqFlagClrWriteCmd+0xc>
81106ffc:	003b68fa 	trap	3
81107000:	dfc00115 	stw	ra,4(sp)
81107004:	df000015 	stw	fp,0(sp)
81107008:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
8110700c:	01800044 	movi	r6,1
81107010:	014004c4 	movi	r5,19
81107014:	01204834 	movhi	r4,33056
81107018:	210a0004 	addi	r4,r4,10240
8110701c:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107020:	0001883a 	nop
81107024:	e037883a 	mov	sp,fp
81107028:	dfc00117 	ldw	ra,4(sp)
8110702c:	df000017 	ldw	fp,0(sp)
81107030:	dec00204 	addi	sp,sp,8
81107034:	f800283a 	ret

81107038 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81107038:	defffe04 	addi	sp,sp,-8
8110703c:	de00012e 	bgeu	sp,et,81107044 <vRmapCh7IrqFlagClrWriteCmd+0xc>
81107040:	003b68fa 	trap	3
81107044:	dfc00115 	stw	ra,4(sp)
81107048:	df000015 	stw	fp,0(sp)
8110704c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81107050:	01800044 	movi	r6,1
81107054:	014004c4 	movi	r5,19
81107058:	01204834 	movhi	r4,33056
8110705c:	210b0004 	addi	r4,r4,11264
81107060:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81107064:	0001883a 	nop
81107068:	e037883a 	mov	sp,fp
8110706c:	dfc00117 	ldw	ra,4(sp)
81107070:	df000017 	ldw	fp,0(sp)
81107074:	dec00204 	addi	sp,sp,8
81107078:	f800283a 	ret

8110707c <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
8110707c:	defffe04 	addi	sp,sp,-8
81107080:	de00012e 	bgeu	sp,et,81107088 <vRmapCh8IrqFlagClrWriteCmd+0xc>
81107084:	003b68fa 	trap	3
81107088:	dfc00115 	stw	ra,4(sp)
8110708c:	df000015 	stw	fp,0(sp)
81107090:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107094:	01800044 	movi	r6,1
81107098:	014004c4 	movi	r5,19
8110709c:	01204834 	movhi	r4,33056
811070a0:	210a0004 	addi	r4,r4,10240
811070a4:	11099680 	call	81109968 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811070a8:	0001883a 	nop
811070ac:	e037883a 	mov	sp,fp
811070b0:	dfc00117 	ldw	ra,4(sp)
811070b4:	df000017 	ldw	fp,0(sp)
811070b8:	dec00204 	addi	sp,sp,8
811070bc:	f800283a 	ret

811070c0 <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811070c0:	defffd04 	addi	sp,sp,-12
811070c4:	de00012e 	bgeu	sp,et,811070cc <bRmapCh1IrqFlagWriteCmd+0xc>
811070c8:	003b68fa 	trap	3
811070cc:	dfc00215 	stw	ra,8(sp)
811070d0:	df000115 	stw	fp,4(sp)
811070d4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811070d8:	01400484 	movi	r5,18
811070dc:	01204834 	movhi	r4,33056
811070e0:	210b0004 	addi	r4,r4,11264
811070e4:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811070e8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811070ec:	10000326 	beq	r2,zero,811070fc <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811070f0:	00800044 	movi	r2,1
811070f4:	e0bfff15 	stw	r2,-4(fp)
811070f8:	00000106 	br	81107100 <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811070fc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107100:	e0bfff17 	ldw	r2,-4(fp)
}
81107104:	e037883a 	mov	sp,fp
81107108:	dfc00117 	ldw	ra,4(sp)
8110710c:	df000017 	ldw	fp,0(sp)
81107110:	dec00204 	addi	sp,sp,8
81107114:	f800283a 	ret

81107118 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81107118:	defffd04 	addi	sp,sp,-12
8110711c:	de00012e 	bgeu	sp,et,81107124 <bRmapCh2IrqFlagWriteCmd+0xc>
81107120:	003b68fa 	trap	3
81107124:	dfc00215 	stw	ra,8(sp)
81107128:	df000115 	stw	fp,4(sp)
8110712c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107130:	01400484 	movi	r5,18
81107134:	01204834 	movhi	r4,33056
81107138:	210a0004 	addi	r4,r4,10240
8110713c:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107140:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81107144:	10000326 	beq	r2,zero,81107154 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107148:	00800044 	movi	r2,1
8110714c:	e0bfff15 	stw	r2,-4(fp)
81107150:	00000106 	br	81107158 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107154:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107158:	e0bfff17 	ldw	r2,-4(fp)
}
8110715c:	e037883a 	mov	sp,fp
81107160:	dfc00117 	ldw	ra,4(sp)
81107164:	df000017 	ldw	fp,0(sp)
81107168:	dec00204 	addi	sp,sp,8
8110716c:	f800283a 	ret

81107170 <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
81107170:	defffd04 	addi	sp,sp,-12
81107174:	de00012e 	bgeu	sp,et,8110717c <bRmapCh3IrqFlagWriteCmd+0xc>
81107178:	003b68fa 	trap	3
8110717c:	dfc00215 	stw	ra,8(sp)
81107180:	df000115 	stw	fp,4(sp)
81107184:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81107188:	01400484 	movi	r5,18
8110718c:	01204834 	movhi	r4,33056
81107190:	210b0004 	addi	r4,r4,11264
81107194:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107198:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110719c:	10000326 	beq	r2,zero,811071ac <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811071a0:	00800044 	movi	r2,1
811071a4:	e0bfff15 	stw	r2,-4(fp)
811071a8:	00000106 	br	811071b0 <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811071ac:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811071b0:	e0bfff17 	ldw	r2,-4(fp)
}
811071b4:	e037883a 	mov	sp,fp
811071b8:	dfc00117 	ldw	ra,4(sp)
811071bc:	df000017 	ldw	fp,0(sp)
811071c0:	dec00204 	addi	sp,sp,8
811071c4:	f800283a 	ret

811071c8 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
811071c8:	defffd04 	addi	sp,sp,-12
811071cc:	de00012e 	bgeu	sp,et,811071d4 <bRmapCh4IrqFlagWriteCmd+0xc>
811071d0:	003b68fa 	trap	3
811071d4:	dfc00215 	stw	ra,8(sp)
811071d8:	df000115 	stw	fp,4(sp)
811071dc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811071e0:	01400484 	movi	r5,18
811071e4:	01204834 	movhi	r4,33056
811071e8:	210a0004 	addi	r4,r4,10240
811071ec:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811071f0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811071f4:	10000326 	beq	r2,zero,81107204 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811071f8:	00800044 	movi	r2,1
811071fc:	e0bfff15 	stw	r2,-4(fp)
81107200:	00000106 	br	81107208 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107204:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107208:	e0bfff17 	ldw	r2,-4(fp)
}
8110720c:	e037883a 	mov	sp,fp
81107210:	dfc00117 	ldw	ra,4(sp)
81107214:	df000017 	ldw	fp,0(sp)
81107218:	dec00204 	addi	sp,sp,8
8110721c:	f800283a 	ret

81107220 <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
81107220:	defffd04 	addi	sp,sp,-12
81107224:	de00012e 	bgeu	sp,et,8110722c <bRmapCh5IrqFlagWriteCmd+0xc>
81107228:	003b68fa 	trap	3
8110722c:	dfc00215 	stw	ra,8(sp)
81107230:	df000115 	stw	fp,4(sp)
81107234:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81107238:	01400484 	movi	r5,18
8110723c:	01204834 	movhi	r4,33056
81107240:	210b0004 	addi	r4,r4,11264
81107244:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107248:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110724c:	10000326 	beq	r2,zero,8110725c <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107250:	00800044 	movi	r2,1
81107254:	e0bfff15 	stw	r2,-4(fp)
81107258:	00000106 	br	81107260 <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110725c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107260:	e0bfff17 	ldw	r2,-4(fp)
}
81107264:	e037883a 	mov	sp,fp
81107268:	dfc00117 	ldw	ra,4(sp)
8110726c:	df000017 	ldw	fp,0(sp)
81107270:	dec00204 	addi	sp,sp,8
81107274:	f800283a 	ret

81107278 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81107278:	defffd04 	addi	sp,sp,-12
8110727c:	de00012e 	bgeu	sp,et,81107284 <bRmapCh6IrqFlagWriteCmd+0xc>
81107280:	003b68fa 	trap	3
81107284:	dfc00215 	stw	ra,8(sp)
81107288:	df000115 	stw	fp,4(sp)
8110728c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81107290:	01400484 	movi	r5,18
81107294:	01204834 	movhi	r4,33056
81107298:	210a0004 	addi	r4,r4,10240
8110729c:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072a0:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811072a4:	10000326 	beq	r2,zero,811072b4 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811072a8:	00800044 	movi	r2,1
811072ac:	e0bfff15 	stw	r2,-4(fp)
811072b0:	00000106 	br	811072b8 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811072b4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811072b8:	e0bfff17 	ldw	r2,-4(fp)
}
811072bc:	e037883a 	mov	sp,fp
811072c0:	dfc00117 	ldw	ra,4(sp)
811072c4:	df000017 	ldw	fp,0(sp)
811072c8:	dec00204 	addi	sp,sp,8
811072cc:	f800283a 	ret

811072d0 <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
811072d0:	defffd04 	addi	sp,sp,-12
811072d4:	de00012e 	bgeu	sp,et,811072dc <bRmapCh7IrqFlagWriteCmd+0xc>
811072d8:	003b68fa 	trap	3
811072dc:	dfc00215 	stw	ra,8(sp)
811072e0:	df000115 	stw	fp,4(sp)
811072e4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811072e8:	01400484 	movi	r5,18
811072ec:	01204834 	movhi	r4,33056
811072f0:	210b0004 	addi	r4,r4,11264
811072f4:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811072f8:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811072fc:	10000326 	beq	r2,zero,8110730c <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107300:	00800044 	movi	r2,1
81107304:	e0bfff15 	stw	r2,-4(fp)
81107308:	00000106 	br	81107310 <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
8110730c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107310:	e0bfff17 	ldw	r2,-4(fp)
}
81107314:	e037883a 	mov	sp,fp
81107318:	dfc00117 	ldw	ra,4(sp)
8110731c:	df000017 	ldw	fp,0(sp)
81107320:	dec00204 	addi	sp,sp,8
81107324:	f800283a 	ret

81107328 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81107328:	defffd04 	addi	sp,sp,-12
8110732c:	de00012e 	bgeu	sp,et,81107334 <bRmapCh8IrqFlagWriteCmd+0xc>
81107330:	003b68fa 	trap	3
81107334:	dfc00215 	stw	ra,8(sp)
81107338:	df000115 	stw	fp,4(sp)
8110733c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107340:	01400484 	movi	r5,18
81107344:	01204834 	movhi	r4,33056
81107348:	210a0004 	addi	r4,r4,10240
8110734c:	11099bc0 	call	811099bc <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81107350:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81107354:	10000326 	beq	r2,zero,81107364 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81107358:	00800044 	movi	r2,1
8110735c:	e0bfff15 	stw	r2,-4(fp)
81107360:	00000106 	br	81107368 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81107364:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81107368:	e0bfff17 	ldw	r2,-4(fp)
}
8110736c:	e037883a 	mov	sp,fp
81107370:	dfc00117 	ldw	ra,4(sp)
81107374:	df000017 	ldw	fp,0(sp)
81107378:	dec00204 	addi	sp,sp,8
8110737c:	f800283a 	ret

81107380 <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
81107380:	defffd04 	addi	sp,sp,-12
81107384:	de00012e 	bgeu	sp,et,8110738c <uliRmapCh1WriteCmdAddress+0xc>
81107388:	003b68fa 	trap	3
8110738c:	dfc00215 	stw	ra,8(sp)
81107390:	df000115 	stw	fp,4(sp)
81107394:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107398:	01400184 	movi	r5,6
8110739c:	01204834 	movhi	r4,33056
811073a0:	210b0004 	addi	r4,r4,11264
811073a4:	11099bc0 	call	811099bc <uliRmapReadReg>
811073a8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);


	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811073ac:	e13fff17 	ldw	r4,-4(fp)
811073b0:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
811073b4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811073b8:	e0bfff17 	ldw	r2,-4(fp)
}
811073bc:	e037883a 	mov	sp,fp
811073c0:	dfc00117 	ldw	ra,4(sp)
811073c4:	df000017 	ldw	fp,0(sp)
811073c8:	dec00204 	addi	sp,sp,8
811073cc:	f800283a 	ret

811073d0 <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
811073d0:	defffd04 	addi	sp,sp,-12
811073d4:	de00012e 	bgeu	sp,et,811073dc <uliRmapCh2WriteCmdAddress+0xc>
811073d8:	003b68fa 	trap	3
811073dc:	dfc00215 	stw	ra,8(sp)
811073e0:	df000115 	stw	fp,4(sp)
811073e4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811073e8:	01400184 	movi	r5,6
811073ec:	01204834 	movhi	r4,33056
811073f0:	210a0004 	addi	r4,r4,10240
811073f4:	11099bc0 	call	811099bc <uliRmapReadReg>
811073f8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811073fc:	e13fff17 	ldw	r4,-4(fp)
81107400:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
81107404:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107408:	e0bfff17 	ldw	r2,-4(fp)
}
8110740c:	e037883a 	mov	sp,fp
81107410:	dfc00117 	ldw	ra,4(sp)
81107414:	df000017 	ldw	fp,0(sp)
81107418:	dec00204 	addi	sp,sp,8
8110741c:	f800283a 	ret

81107420 <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
81107420:	defffd04 	addi	sp,sp,-12
81107424:	de00012e 	bgeu	sp,et,8110742c <uliRmapCh3WriteCmdAddress+0xc>
81107428:	003b68fa 	trap	3
8110742c:	dfc00215 	stw	ra,8(sp)
81107430:	df000115 	stw	fp,4(sp)
81107434:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107438:	01400184 	movi	r5,6
8110743c:	01204834 	movhi	r4,33056
81107440:	210b0004 	addi	r4,r4,11264
81107444:	11099bc0 	call	811099bc <uliRmapReadReg>
81107448:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110744c:	e13fff17 	ldw	r4,-4(fp)
81107450:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
81107454:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107458:	e0bfff17 	ldw	r2,-4(fp)
}
8110745c:	e037883a 	mov	sp,fp
81107460:	dfc00117 	ldw	ra,4(sp)
81107464:	df000017 	ldw	fp,0(sp)
81107468:	dec00204 	addi	sp,sp,8
8110746c:	f800283a 	ret

81107470 <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
81107470:	defffd04 	addi	sp,sp,-12
81107474:	de00012e 	bgeu	sp,et,8110747c <uliRmapCh4WriteCmdAddress+0xc>
81107478:	003b68fa 	trap	3
8110747c:	dfc00215 	stw	ra,8(sp)
81107480:	df000115 	stw	fp,4(sp)
81107484:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107488:	01400184 	movi	r5,6
8110748c:	01204834 	movhi	r4,33056
81107490:	210a0004 	addi	r4,r4,10240
81107494:	11099bc0 	call	811099bc <uliRmapReadReg>
81107498:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110749c:	e13fff17 	ldw	r4,-4(fp)
811074a0:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
811074a4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074a8:	e0bfff17 	ldw	r2,-4(fp)
}
811074ac:	e037883a 	mov	sp,fp
811074b0:	dfc00117 	ldw	ra,4(sp)
811074b4:	df000017 	ldw	fp,0(sp)
811074b8:	dec00204 	addi	sp,sp,8
811074bc:	f800283a 	ret

811074c0 <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811074c0:	defffd04 	addi	sp,sp,-12
811074c4:	de00012e 	bgeu	sp,et,811074cc <uliRmapCh5WriteCmdAddress+0xc>
811074c8:	003b68fa 	trap	3
811074cc:	dfc00215 	stw	ra,8(sp)
811074d0:	df000115 	stw	fp,4(sp)
811074d4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811074d8:	01400184 	movi	r5,6
811074dc:	01204834 	movhi	r4,33056
811074e0:	210b0004 	addi	r4,r4,11264
811074e4:	11099bc0 	call	811099bc <uliRmapReadReg>
811074e8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811074ec:	e13fff17 	ldw	r4,-4(fp)
811074f0:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
811074f4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811074f8:	e0bfff17 	ldw	r2,-4(fp)
}
811074fc:	e037883a 	mov	sp,fp
81107500:	dfc00117 	ldw	ra,4(sp)
81107504:	df000017 	ldw	fp,0(sp)
81107508:	dec00204 	addi	sp,sp,8
8110750c:	f800283a 	ret

81107510 <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81107510:	defffd04 	addi	sp,sp,-12
81107514:	de00012e 	bgeu	sp,et,8110751c <uliRmapCh6WriteCmdAddress+0xc>
81107518:	003b68fa 	trap	3
8110751c:	dfc00215 	stw	ra,8(sp)
81107520:	df000115 	stw	fp,4(sp)
81107524:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107528:	01400184 	movi	r5,6
8110752c:	01204834 	movhi	r4,33056
81107530:	210a0004 	addi	r4,r4,10240
81107534:	11099bc0 	call	811099bc <uliRmapReadReg>
81107538:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110753c:	e13fff17 	ldw	r4,-4(fp)
81107540:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
81107544:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107548:	e0bfff17 	ldw	r2,-4(fp)
}
8110754c:	e037883a 	mov	sp,fp
81107550:	dfc00117 	ldw	ra,4(sp)
81107554:	df000017 	ldw	fp,0(sp)
81107558:	dec00204 	addi	sp,sp,8
8110755c:	f800283a 	ret

81107560 <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81107560:	defffd04 	addi	sp,sp,-12
81107564:	de00012e 	bgeu	sp,et,8110756c <uliRmapCh7WriteCmdAddress+0xc>
81107568:	003b68fa 	trap	3
8110756c:	dfc00215 	stw	ra,8(sp)
81107570:	df000115 	stw	fp,4(sp)
81107574:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81107578:	01400184 	movi	r5,6
8110757c:	01204834 	movhi	r4,33056
81107580:	210b0004 	addi	r4,r4,11264
81107584:	11099bc0 	call	811099bc <uliRmapReadReg>
81107588:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
8110758c:	e13fff17 	ldw	r4,-4(fp)
81107590:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
81107594:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81107598:	e0bfff17 	ldw	r2,-4(fp)
}
8110759c:	e037883a 	mov	sp,fp
811075a0:	dfc00117 	ldw	ra,4(sp)
811075a4:	df000017 	ldw	fp,0(sp)
811075a8:	dec00204 	addi	sp,sp,8
811075ac:	f800283a 	ret

811075b0 <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
811075b0:	defffd04 	addi	sp,sp,-12
811075b4:	de00012e 	bgeu	sp,et,811075bc <uliRmapCh8WriteCmdAddress+0xc>
811075b8:	003b68fa 	trap	3
811075bc:	dfc00215 	stw	ra,8(sp)
811075c0:	df000115 	stw	fp,4(sp)
811075c4:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811075c8:	01400184 	movi	r5,6
811075cc:	01204834 	movhi	r4,33056
811075d0:	210a0004 	addi	r4,r4,10240
811075d4:	11099bc0 	call	811099bc <uliRmapReadReg>
811075d8:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811075dc:	e13fff17 	ldw	r4,-4(fp)
811075e0:	1109a0c0 	call	81109a0c <uliConvRmapCfgAddr>
811075e4:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811075e8:	e0bfff17 	ldw	r2,-4(fp)
}
811075ec:	e037883a 	mov	sp,fp
811075f0:	dfc00117 	ldw	ra,4(sp)
811075f4:	df000017 	ldw	fp,0(sp)
811075f8:	dec00204 	addi	sp,sp,8
811075fc:	f800283a 	ret

81107600 <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81107600:	defffc04 	addi	sp,sp,-16
81107604:	de00012e 	bgeu	sp,et,8110760c <vRmapInitIrq+0xc>
81107608:	003b68fa 	trap	3
8110760c:	dfc00315 	stw	ra,12(sp)
81107610:	df000215 	stw	fp,8(sp)
81107614:	df000204 	addi	fp,sp,8
81107618:	2005883a 	mov	r2,r4
8110761c:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81107620:	e0bfff03 	ldbu	r2,-4(fp)
81107624:	10c00228 	cmpgeui	r3,r2,8
81107628:	18004e1e 	bne	r3,zero,81107764 <vRmapInitIrq+0x164>
8110762c:	100690ba 	slli	r3,r2,2
81107630:	00a04434 	movhi	r2,33040
81107634:	109d9104 	addi	r2,r2,30276
81107638:	1885883a 	add	r2,r3,r2
8110763c:	10800017 	ldw	r2,0(r2)
81107640:	1000683a 	jmp	r2
81107644:	81107664 	muli	r4,r16,16857
81107648:	81107684 	addi	r4,r16,16858
8110764c:	811076a4 	muli	r4,r16,16858
81107650:	811076c4 	addi	r4,r16,16859
81107654:	811076e4 	muli	r4,r16,16859
81107658:	81107704 	addi	r4,r16,16860
8110765c:	81107724 	muli	r4,r16,16860
81107660:	81107744 	addi	r4,r16,16861
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81107664:	d0a04804 	addi	r2,gp,-32480
81107668:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
8110766c:	01a04434 	movhi	r6,33040
81107670:	319b0704 	addi	r6,r6,27676
81107674:	e17ffe17 	ldw	r5,-8(fp)
81107678:	010005c4 	movi	r4,23
8110767c:	11346440 	call	81134644 <alt_irq_register>
		break;
81107680:	00003806 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81107684:	d0a04904 	addi	r2,gp,-32476
81107688:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
8110768c:	01a04434 	movhi	r6,33040
81107690:	319b3804 	addi	r6,r6,27872
81107694:	e17ffe17 	ldw	r5,-8(fp)
81107698:	01000544 	movi	r4,21
8110769c:	11346440 	call	81134644 <alt_irq_register>
		break;
811076a0:	00003006 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811076a4:	d0a04a04 	addi	r2,gp,-32472
811076a8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
811076ac:	01a04434 	movhi	r6,33040
811076b0:	319b4804 	addi	r6,r6,27936
811076b4:	e17ffe17 	ldw	r5,-8(fp)
811076b8:	010004c4 	movi	r4,19
811076bc:	11346440 	call	81134644 <alt_irq_register>
		break;
811076c0:	00002806 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
811076c4:	d0a04b04 	addi	r2,gp,-32468
811076c8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
811076cc:	01a04434 	movhi	r6,33040
811076d0:	319b5804 	addi	r6,r6,28000
811076d4:	e17ffe17 	ldw	r5,-8(fp)
811076d8:	01000444 	movi	r4,17
811076dc:	11346440 	call	81134644 <alt_irq_register>
		break;
811076e0:	00002006 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
811076e4:	d0a04c04 	addi	r2,gp,-32464
811076e8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
811076ec:	01a04434 	movhi	r6,33040
811076f0:	319b6804 	addi	r6,r6,28064
811076f4:	e17ffe17 	ldw	r5,-8(fp)
811076f8:	01000244 	movi	r4,9
811076fc:	11346440 	call	81134644 <alt_irq_register>
		break;
81107700:	00001806 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81107704:	d0a04d04 	addi	r2,gp,-32460
81107708:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
8110770c:	01a04434 	movhi	r6,33040
81107710:	319b7804 	addi	r6,r6,28128
81107714:	e17ffe17 	ldw	r5,-8(fp)
81107718:	010001c4 	movi	r4,7
8110771c:	11346440 	call	81134644 <alt_irq_register>
		break;
81107720:	00001006 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81107724:	d0a04e04 	addi	r2,gp,-32456
81107728:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
8110772c:	01a04434 	movhi	r6,33040
81107730:	319b8804 	addi	r6,r6,28192
81107734:	e17ffe17 	ldw	r5,-8(fp)
81107738:	01000104 	movi	r4,4
8110773c:	11346440 	call	81134644 <alt_irq_register>
		break;
81107740:	00000806 	br	81107764 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81107744:	d0a04f04 	addi	r2,gp,-32452
81107748:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
8110774c:	01a04434 	movhi	r6,33040
81107750:	319b9804 	addi	r6,r6,28256
81107754:	e17ffe17 	ldw	r5,-8(fp)
81107758:	010000c4 	movi	r4,3
8110775c:	11346440 	call	81134644 <alt_irq_register>
		break;
81107760:	0001883a 	nop
	}
}
81107764:	0001883a 	nop
81107768:	e037883a 	mov	sp,fp
8110776c:	dfc00117 	ldw	ra,4(sp)
81107770:	df000017 	ldw	fp,0(sp)
81107774:	dec00204 	addi	sp,sp,8
81107778:	f800283a 	ret

8110777c <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
8110777c:	defffb04 	addi	sp,sp,-20
81107780:	de00012e 	bgeu	sp,et,81107788 <bRmapSetIrqControl+0xc>
81107784:	003b68fa 	trap	3
81107788:	dfc00415 	stw	ra,16(sp)
8110778c:	df000315 	stw	fp,12(sp)
81107790:	df000304 	addi	fp,sp,12
81107794:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107798:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110779c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811077a0:	e0bfff17 	ldw	r2,-4(fp)
811077a4:	10001926 	beq	r2,zero,8110780c <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077a8:	e0bfff17 	ldw	r2,-4(fp)
811077ac:	10800017 	ldw	r2,0(r2)
811077b0:	01400444 	movi	r5,17
811077b4:	1009883a 	mov	r4,r2
811077b8:	11099bc0 	call	811099bc <uliRmapReadReg>
811077bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
811077c0:	e0bfff17 	ldw	r2,-4(fp)
811077c4:	10801017 	ldw	r2,64(r2)
811077c8:	10000426 	beq	r2,zero,811077dc <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
811077cc:	e0bffe17 	ldw	r2,-8(fp)
811077d0:	10800054 	ori	r2,r2,1
811077d4:	e0bffe15 	stw	r2,-8(fp)
811077d8:	00000406 	br	811077ec <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
811077dc:	e0fffe17 	ldw	r3,-8(fp)
811077e0:	00bfff84 	movi	r2,-2
811077e4:	1884703a 	and	r2,r3,r2
811077e8:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
811077ec:	e0bfff17 	ldw	r2,-4(fp)
811077f0:	10800017 	ldw	r2,0(r2)
811077f4:	e1bffe17 	ldw	r6,-8(fp)
811077f8:	01400444 	movi	r5,17
811077fc:	1009883a 	mov	r4,r2
81107800:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81107804:	00800044 	movi	r2,1
81107808:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110780c:	e0bffd17 	ldw	r2,-12(fp)
}
81107810:	e037883a 	mov	sp,fp
81107814:	dfc00117 	ldw	ra,4(sp)
81107818:	df000017 	ldw	fp,0(sp)
8110781c:	dec00204 	addi	sp,sp,8
81107820:	f800283a 	ret

81107824 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81107824:	defffb04 	addi	sp,sp,-20
81107828:	de00012e 	bgeu	sp,et,81107830 <bRmapGetIrqControl+0xc>
8110782c:	003b68fa 	trap	3
81107830:	dfc00415 	stw	ra,16(sp)
81107834:	df000315 	stw	fp,12(sp)
81107838:	df000304 	addi	fp,sp,12
8110783c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107840:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107844:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107848:	e0bfff17 	ldw	r2,-4(fp)
8110784c:	10001126 	beq	r2,zero,81107894 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107850:	e0bfff17 	ldw	r2,-4(fp)
81107854:	10800017 	ldw	r2,0(r2)
81107858:	01400444 	movi	r5,17
8110785c:	1009883a 	mov	r4,r2
81107860:	11099bc0 	call	811099bc <uliRmapReadReg>
81107864:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81107868:	e0bffe17 	ldw	r2,-8(fp)
8110786c:	1080004c 	andi	r2,r2,1
81107870:	10000426 	beq	r2,zero,81107884 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81107874:	e0bfff17 	ldw	r2,-4(fp)
81107878:	00c00044 	movi	r3,1
8110787c:	10c01015 	stw	r3,64(r2)
81107880:	00000206 	br	8110788c <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81107884:	e0bfff17 	ldw	r2,-4(fp)
81107888:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
8110788c:	00800044 	movi	r2,1
81107890:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107894:	e0bffd17 	ldw	r2,-12(fp)
}
81107898:	e037883a 	mov	sp,fp
8110789c:	dfc00117 	ldw	ra,4(sp)
811078a0:	df000017 	ldw	fp,0(sp)
811078a4:	dec00204 	addi	sp,sp,8
811078a8:	f800283a 	ret

811078ac <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
811078ac:	defffb04 	addi	sp,sp,-20
811078b0:	de00012e 	bgeu	sp,et,811078b8 <bRmapGetIrqFlags+0xc>
811078b4:	003b68fa 	trap	3
811078b8:	dfc00415 	stw	ra,16(sp)
811078bc:	df000315 	stw	fp,12(sp)
811078c0:	df000304 	addi	fp,sp,12
811078c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811078c8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811078cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811078d0:	e0bfff17 	ldw	r2,-4(fp)
811078d4:	10001126 	beq	r2,zero,8110791c <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078d8:	e0bfff17 	ldw	r2,-4(fp)
811078dc:	10800017 	ldw	r2,0(r2)
811078e0:	01400484 	movi	r5,18
811078e4:	1009883a 	mov	r4,r2
811078e8:	11099bc0 	call	811099bc <uliRmapReadReg>
811078ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811078f0:	e0bffe17 	ldw	r2,-8(fp)
811078f4:	1080004c 	andi	r2,r2,1
811078f8:	10000426 	beq	r2,zero,8110790c <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
811078fc:	e0bfff17 	ldw	r2,-4(fp)
81107900:	00c00044 	movi	r3,1
81107904:	10c01115 	stw	r3,68(r2)
81107908:	00000206 	br	81107914 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
8110790c:	e0bfff17 	ldw	r2,-4(fp)
81107910:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81107914:	00800044 	movi	r2,1
81107918:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110791c:	e0bffd17 	ldw	r2,-12(fp)
}
81107920:	e037883a 	mov	sp,fp
81107924:	dfc00117 	ldw	ra,4(sp)
81107928:	df000017 	ldw	fp,0(sp)
8110792c:	dec00204 	addi	sp,sp,8
81107930:	f800283a 	ret

81107934 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81107934:	defffb04 	addi	sp,sp,-20
81107938:	de00012e 	bgeu	sp,et,81107940 <bRmapSetCodecConfig+0xc>
8110793c:	003b68fa 	trap	3
81107940:	dfc00415 	stw	ra,16(sp)
81107944:	df000315 	stw	fp,12(sp)
81107948:	df000304 	addi	fp,sp,12
8110794c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107950:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107954:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107958:	e0bfff17 	ldw	r2,-4(fp)
8110795c:	10002526 	beq	r2,zero,811079f4 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107960:	e0bfff17 	ldw	r2,-4(fp)
81107964:	10800017 	ldw	r2,0(r2)
81107968:	01400104 	movi	r5,4
8110796c:	1009883a 	mov	r4,r2
81107970:	11099bc0 	call	811099bc <uliRmapReadReg>
81107974:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81107978:	e0fffe17 	ldw	r3,-8(fp)
8110797c:	00bfc004 	movi	r2,-256
81107980:	1884703a 	and	r2,r3,r2
81107984:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81107988:	e0bfff17 	ldw	r2,-4(fp)
8110798c:	10800143 	ldbu	r2,5(r2)
81107990:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81107994:	e0fffe17 	ldw	r3,-8(fp)
81107998:	1884b03a 	or	r2,r3,r2
8110799c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
811079a0:	e0fffe17 	ldw	r3,-8(fp)
811079a4:	00bffff4 	movhi	r2,65535
811079a8:	10803fc4 	addi	r2,r2,255
811079ac:	1884703a 	and	r2,r3,r2
811079b0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
811079b4:	e0bfff17 	ldw	r2,-4(fp)
811079b8:	10800103 	ldbu	r2,4(r2)
811079bc:	10803fcc 	andi	r2,r2,255
811079c0:	1004923a 	slli	r2,r2,8
811079c4:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
811079c8:	e0fffe17 	ldw	r3,-8(fp)
811079cc:	1884b03a 	or	r2,r3,r2
811079d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
811079d4:	e0bfff17 	ldw	r2,-4(fp)
811079d8:	10800017 	ldw	r2,0(r2)
811079dc:	e1bffe17 	ldw	r6,-8(fp)
811079e0:	01400104 	movi	r5,4
811079e4:	1009883a 	mov	r4,r2
811079e8:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811079ec:	00800044 	movi	r2,1
811079f0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811079f4:	e0bffd17 	ldw	r2,-12(fp)
}
811079f8:	e037883a 	mov	sp,fp
811079fc:	dfc00117 	ldw	ra,4(sp)
81107a00:	df000017 	ldw	fp,0(sp)
81107a04:	dec00204 	addi	sp,sp,8
81107a08:	f800283a 	ret

81107a0c <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81107a0c:	defffb04 	addi	sp,sp,-20
81107a10:	de00012e 	bgeu	sp,et,81107a18 <bRmapGetCodecConfig+0xc>
81107a14:	003b68fa 	trap	3
81107a18:	dfc00415 	stw	ra,16(sp)
81107a1c:	df000315 	stw	fp,12(sp)
81107a20:	df000304 	addi	fp,sp,12
81107a24:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107a28:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107a2c:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107a30:	e0bfff17 	ldw	r2,-4(fp)
81107a34:	10001226 	beq	r2,zero,81107a80 <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a38:	e0bfff17 	ldw	r2,-4(fp)
81107a3c:	10800017 	ldw	r2,0(r2)
81107a40:	01400104 	movi	r5,4
81107a44:	1009883a 	mov	r4,r2
81107a48:	11099bc0 	call	811099bc <uliRmapReadReg>
81107a4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81107a50:	e0bffe17 	ldw	r2,-8(fp)
81107a54:	1007883a 	mov	r3,r2
81107a58:	e0bfff17 	ldw	r2,-4(fp)
81107a5c:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81107a60:	e0bffe17 	ldw	r2,-8(fp)
81107a64:	10bfc00c 	andi	r2,r2,65280
81107a68:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81107a6c:	1007883a 	mov	r3,r2
81107a70:	e0bfff17 	ldw	r2,-4(fp)
81107a74:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81107a78:	00800044 	movi	r2,1
81107a7c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107a80:	e0bffd17 	ldw	r2,-12(fp)
}
81107a84:	e037883a 	mov	sp,fp
81107a88:	dfc00117 	ldw	ra,4(sp)
81107a8c:	df000017 	ldw	fp,0(sp)
81107a90:	dec00204 	addi	sp,sp,8
81107a94:	f800283a 	ret

81107a98 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81107a98:	defffb04 	addi	sp,sp,-20
81107a9c:	de00012e 	bgeu	sp,et,81107aa4 <bRmapGetCodecStatus+0xc>
81107aa0:	003b68fa 	trap	3
81107aa4:	dfc00415 	stw	ra,16(sp)
81107aa8:	df000315 	stw	fp,12(sp)
81107aac:	df000304 	addi	fp,sp,12
81107ab0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107ab4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107ab8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107abc:	e0bfff17 	ldw	r2,-4(fp)
81107ac0:	10004726 	beq	r2,zero,81107be0 <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ac4:	e0bfff17 	ldw	r2,-4(fp)
81107ac8:	10800017 	ldw	r2,0(r2)
81107acc:	01400144 	movi	r5,5
81107ad0:	1009883a 	mov	r4,r2
81107ad4:	11099bc0 	call	811099bc <uliRmapReadReg>
81107ad8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81107adc:	e0bffe17 	ldw	r2,-8(fp)
81107ae0:	1080004c 	andi	r2,r2,1
81107ae4:	10000426 	beq	r2,zero,81107af8 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107ae8:	e0bfff17 	ldw	r2,-4(fp)
81107aec:	00c00044 	movi	r3,1
81107af0:	10c00215 	stw	r3,8(r2)
81107af4:	00000206 	br	81107b00 <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107af8:	e0bfff17 	ldw	r2,-4(fp)
81107afc:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
81107b00:	e0bffe17 	ldw	r2,-8(fp)
81107b04:	1080008c 	andi	r2,r2,2
81107b08:	10000426 	beq	r2,zero,81107b1c <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107b0c:	e0bfff17 	ldw	r2,-4(fp)
81107b10:	00c00044 	movi	r3,1
81107b14:	10c00315 	stw	r3,12(r2)
81107b18:	00000206 	br	81107b24 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107b1c:	e0bfff17 	ldw	r2,-4(fp)
81107b20:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107b24:	e0bffe17 	ldw	r2,-8(fp)
81107b28:	1080010c 	andi	r2,r2,4
81107b2c:	10000426 	beq	r2,zero,81107b40 <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
81107b30:	e0bfff17 	ldw	r2,-4(fp)
81107b34:	00c00044 	movi	r3,1
81107b38:	10c00415 	stw	r3,16(r2)
81107b3c:	00000206 	br	81107b48 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
81107b40:	e0bfff17 	ldw	r2,-4(fp)
81107b44:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107b48:	e0bffe17 	ldw	r2,-8(fp)
81107b4c:	1080020c 	andi	r2,r2,8
81107b50:	10000426 	beq	r2,zero,81107b64 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107b54:	e0bfff17 	ldw	r2,-4(fp)
81107b58:	00c00044 	movi	r3,1
81107b5c:	10c00515 	stw	r3,20(r2)
81107b60:	00000206 	br	81107b6c <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107b64:	e0bfff17 	ldw	r2,-4(fp)
81107b68:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107b6c:	e0bffe17 	ldw	r2,-8(fp)
81107b70:	1080040c 	andi	r2,r2,16
81107b74:	10000426 	beq	r2,zero,81107b88 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107b78:	e0bfff17 	ldw	r2,-4(fp)
81107b7c:	00c00044 	movi	r3,1
81107b80:	10c00615 	stw	r3,24(r2)
81107b84:	00000206 	br	81107b90 <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
81107b88:	e0bfff17 	ldw	r2,-4(fp)
81107b8c:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
81107b90:	e0bffe17 	ldw	r2,-8(fp)
81107b94:	1080080c 	andi	r2,r2,32
81107b98:	10000426 	beq	r2,zero,81107bac <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
81107b9c:	e0bfff17 	ldw	r2,-4(fp)
81107ba0:	00c00044 	movi	r3,1
81107ba4:	10c00715 	stw	r3,28(r2)
81107ba8:	00000206 	br	81107bb4 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
81107bac:	e0bfff17 	ldw	r2,-4(fp)
81107bb0:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
81107bb4:	e0bffe17 	ldw	r2,-8(fp)
81107bb8:	1080100c 	andi	r2,r2,64
81107bbc:	10000426 	beq	r2,zero,81107bd0 <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
81107bc0:	e0bfff17 	ldw	r2,-4(fp)
81107bc4:	00c00044 	movi	r3,1
81107bc8:	10c00815 	stw	r3,32(r2)
81107bcc:	00000206 	br	81107bd8 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107bd0:	e0bfff17 	ldw	r2,-4(fp)
81107bd4:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
81107bd8:	00800044 	movi	r2,1
81107bdc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107be0:	e0bffd17 	ldw	r2,-12(fp)
}
81107be4:	e037883a 	mov	sp,fp
81107be8:	dfc00117 	ldw	ra,4(sp)
81107bec:	df000017 	ldw	fp,0(sp)
81107bf0:	dec00204 	addi	sp,sp,8
81107bf4:	f800283a 	ret

81107bf8 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107bf8:	defffb04 	addi	sp,sp,-20
81107bfc:	de00012e 	bgeu	sp,et,81107c04 <bRmapGetCodecError+0xc>
81107c00:	003b68fa 	trap	3
81107c04:	dfc00415 	stw	ra,16(sp)
81107c08:	df000315 	stw	fp,12(sp)
81107c0c:	df000304 	addi	fp,sp,12
81107c10:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107c14:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107c18:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107c1c:	e0bfff17 	ldw	r2,-4(fp)
81107c20:	10004726 	beq	r2,zero,81107d40 <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c24:	e0bfff17 	ldw	r2,-4(fp)
81107c28:	10800017 	ldw	r2,0(r2)
81107c2c:	01400144 	movi	r5,5
81107c30:	1009883a 	mov	r4,r2
81107c34:	11099bc0 	call	811099bc <uliRmapReadReg>
81107c38:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107c3c:	e0bffe17 	ldw	r2,-8(fp)
81107c40:	1080006c 	andhi	r2,r2,1
81107c44:	10000426 	beq	r2,zero,81107c58 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107c48:	e0bfff17 	ldw	r2,-4(fp)
81107c4c:	00c00044 	movi	r3,1
81107c50:	10c00915 	stw	r3,36(r2)
81107c54:	00000206 	br	81107c60 <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107c58:	e0bfff17 	ldw	r2,-4(fp)
81107c5c:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
81107c60:	e0bffe17 	ldw	r2,-8(fp)
81107c64:	108000ac 	andhi	r2,r2,2
81107c68:	10000426 	beq	r2,zero,81107c7c <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107c6c:	e0bfff17 	ldw	r2,-4(fp)
81107c70:	00c00044 	movi	r3,1
81107c74:	10c00a15 	stw	r3,40(r2)
81107c78:	00000206 	br	81107c84 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107c7c:	e0bfff17 	ldw	r2,-4(fp)
81107c80:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
81107c84:	e0bffe17 	ldw	r2,-8(fp)
81107c88:	1080012c 	andhi	r2,r2,4
81107c8c:	10000426 	beq	r2,zero,81107ca0 <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
81107c90:	e0bfff17 	ldw	r2,-4(fp)
81107c94:	00c00044 	movi	r3,1
81107c98:	10c00b15 	stw	r3,44(r2)
81107c9c:	00000206 	br	81107ca8 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
81107ca0:	e0bfff17 	ldw	r2,-4(fp)
81107ca4:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
81107ca8:	e0bffe17 	ldw	r2,-8(fp)
81107cac:	1080022c 	andhi	r2,r2,8
81107cb0:	10000426 	beq	r2,zero,81107cc4 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
81107cb4:	e0bfff17 	ldw	r2,-4(fp)
81107cb8:	00c00044 	movi	r3,1
81107cbc:	10c00c15 	stw	r3,48(r2)
81107cc0:	00000206 	br	81107ccc <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
81107cc4:	e0bfff17 	ldw	r2,-4(fp)
81107cc8:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
81107ccc:	e0bffe17 	ldw	r2,-8(fp)
81107cd0:	1080042c 	andhi	r2,r2,16
81107cd4:	10000426 	beq	r2,zero,81107ce8 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
81107cd8:	e0bfff17 	ldw	r2,-4(fp)
81107cdc:	00c00044 	movi	r3,1
81107ce0:	10c00d15 	stw	r3,52(r2)
81107ce4:	00000206 	br	81107cf0 <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107ce8:	e0bfff17 	ldw	r2,-4(fp)
81107cec:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
81107cf0:	e0bffe17 	ldw	r2,-8(fp)
81107cf4:	1080082c 	andhi	r2,r2,32
81107cf8:	10000426 	beq	r2,zero,81107d0c <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107cfc:	e0bfff17 	ldw	r2,-4(fp)
81107d00:	00c00044 	movi	r3,1
81107d04:	10c00e15 	stw	r3,56(r2)
81107d08:	00000206 	br	81107d14 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107d0c:	e0bfff17 	ldw	r2,-4(fp)
81107d10:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107d14:	e0bffe17 	ldw	r2,-8(fp)
81107d18:	1080102c 	andhi	r2,r2,64
81107d1c:	10000426 	beq	r2,zero,81107d30 <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
81107d20:	e0bfff17 	ldw	r2,-4(fp)
81107d24:	00c00044 	movi	r3,1
81107d28:	10c00f15 	stw	r3,60(r2)
81107d2c:	00000206 	br	81107d38 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
81107d30:	e0bfff17 	ldw	r2,-4(fp)
81107d34:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107d38:	00800044 	movi	r2,1
81107d3c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107d40:	e0bffd17 	ldw	r2,-12(fp)
}
81107d44:	e037883a 	mov	sp,fp
81107d48:	dfc00117 	ldw	ra,4(sp)
81107d4c:	df000017 	ldw	fp,0(sp)
81107d50:	dec00204 	addi	sp,sp,8
81107d54:	f800283a 	ret

81107d58 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107d58:	defffb04 	addi	sp,sp,-20
81107d5c:	de00012e 	bgeu	sp,et,81107d64 <bRmapSetMemConfigArea+0xc>
81107d60:	003b68fa 	trap	3
81107d64:	dfc00415 	stw	ra,16(sp)
81107d68:	df000315 	stw	fp,12(sp)
81107d6c:	df000304 	addi	fp,sp,12
81107d70:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107d74:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107d78:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107d7c:	e0bfff17 	ldw	r2,-4(fp)
81107d80:	1000aa26 	beq	r2,zero,8110802c <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
81107d84:	e0bfff17 	ldw	r2,-4(fp)
81107d88:	10801217 	ldw	r2,72(r2)
81107d8c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107d90:	e0bfff17 	ldw	r2,-4(fp)
81107d94:	10800017 	ldw	r2,0(r2)
81107d98:	e1bffe17 	ldw	r6,-8(fp)
81107d9c:	01401004 	movi	r5,64
81107da0:	1009883a 	mov	r4,r2
81107da4:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
81107da8:	e0bfff17 	ldw	r2,-4(fp)
81107dac:	10801317 	ldw	r2,76(r2)
81107db0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107db4:	e0bfff17 	ldw	r2,-4(fp)
81107db8:	10800017 	ldw	r2,0(r2)
81107dbc:	e1bffe17 	ldw	r6,-8(fp)
81107dc0:	01401044 	movi	r5,65
81107dc4:	1009883a 	mov	r4,r2
81107dc8:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
81107dcc:	e0bfff17 	ldw	r2,-4(fp)
81107dd0:	10801417 	ldw	r2,80(r2)
81107dd4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107dd8:	e0bfff17 	ldw	r2,-4(fp)
81107ddc:	10800017 	ldw	r2,0(r2)
81107de0:	e1bffe17 	ldw	r6,-8(fp)
81107de4:	01401084 	movi	r5,66
81107de8:	1009883a 	mov	r4,r2
81107dec:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
81107df0:	e0bfff17 	ldw	r2,-4(fp)
81107df4:	10801517 	ldw	r2,84(r2)
81107df8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107dfc:	e0bfff17 	ldw	r2,-4(fp)
81107e00:	10800017 	ldw	r2,0(r2)
81107e04:	e1bffe17 	ldw	r6,-8(fp)
81107e08:	014010c4 	movi	r5,67
81107e0c:	1009883a 	mov	r4,r2
81107e10:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107e14:	e0bfff17 	ldw	r2,-4(fp)
81107e18:	10802217 	ldw	r2,136(r2)
81107e1c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e20:	e0bfff17 	ldw	r2,-4(fp)
81107e24:	10800017 	ldw	r2,0(r2)
81107e28:	e1bffe17 	ldw	r6,-8(fp)
81107e2c:	01401104 	movi	r5,68
81107e30:	1009883a 	mov	r4,r2
81107e34:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107e38:	e0bfff17 	ldw	r2,-4(fp)
81107e3c:	10801717 	ldw	r2,92(r2)
81107e40:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e44:	e0bfff17 	ldw	r2,-4(fp)
81107e48:	10800017 	ldw	r2,0(r2)
81107e4c:	e1bffe17 	ldw	r6,-8(fp)
81107e50:	01401144 	movi	r5,69
81107e54:	1009883a 	mov	r4,r2
81107e58:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107e5c:	e0bfff17 	ldw	r2,-4(fp)
81107e60:	10801817 	ldw	r2,96(r2)
81107e64:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e68:	e0bfff17 	ldw	r2,-4(fp)
81107e6c:	10800017 	ldw	r2,0(r2)
81107e70:	e1bffe17 	ldw	r6,-8(fp)
81107e74:	01401184 	movi	r5,70
81107e78:	1009883a 	mov	r4,r2
81107e7c:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
81107e80:	e0bfff17 	ldw	r2,-4(fp)
81107e84:	10801917 	ldw	r2,100(r2)
81107e88:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107e8c:	e0bfff17 	ldw	r2,-4(fp)
81107e90:	10800017 	ldw	r2,0(r2)
81107e94:	e1bffe17 	ldw	r6,-8(fp)
81107e98:	014011c4 	movi	r5,71
81107e9c:	1009883a 	mov	r4,r2
81107ea0:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
81107ea4:	e0bfff17 	ldw	r2,-4(fp)
81107ea8:	10801a17 	ldw	r2,104(r2)
81107eac:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107eb0:	e0bfff17 	ldw	r2,-4(fp)
81107eb4:	10800017 	ldw	r2,0(r2)
81107eb8:	e1bffe17 	ldw	r6,-8(fp)
81107ebc:	01401204 	movi	r5,72
81107ec0:	1009883a 	mov	r4,r2
81107ec4:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
81107ec8:	e0bfff17 	ldw	r2,-4(fp)
81107ecc:	10801b17 	ldw	r2,108(r2)
81107ed0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107ed4:	e0bfff17 	ldw	r2,-4(fp)
81107ed8:	10800017 	ldw	r2,0(r2)
81107edc:	e1bffe17 	ldw	r6,-8(fp)
81107ee0:	01401244 	movi	r5,73
81107ee4:	1009883a 	mov	r4,r2
81107ee8:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107eec:	e0bfff17 	ldw	r2,-4(fp)
81107ef0:	10800017 	ldw	r2,0(r2)
81107ef4:	01401284 	movi	r5,74
81107ef8:	1009883a 	mov	r4,r2
81107efc:	11099bc0 	call	811099bc <uliRmapReadReg>
81107f00:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81107f04:	e0bfff17 	ldw	r2,-4(fp)
81107f08:	10801c17 	ldw	r2,112(r2)
81107f0c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f10:	e0bfff17 	ldw	r2,-4(fp)
81107f14:	10800017 	ldw	r2,0(r2)
81107f18:	e1bffe17 	ldw	r6,-8(fp)
81107f1c:	01401284 	movi	r5,74
81107f20:	1009883a 	mov	r4,r2
81107f24:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107f28:	e0bfff17 	ldw	r2,-4(fp)
81107f2c:	10801d17 	ldw	r2,116(r2)
81107f30:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107f34:	e0bfff17 	ldw	r2,-4(fp)
81107f38:	10800017 	ldw	r2,0(r2)
81107f3c:	e1bffe17 	ldw	r6,-8(fp)
81107f40:	014012c4 	movi	r5,75
81107f44:	1009883a 	mov	r4,r2
81107f48:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81107f4c:	e0bfff17 	ldw	r2,-4(fp)
81107f50:	10801e17 	ldw	r2,120(r2)
81107f54:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107f58:	e0bfff17 	ldw	r2,-4(fp)
81107f5c:	10800017 	ldw	r2,0(r2)
81107f60:	e1bffe17 	ldw	r6,-8(fp)
81107f64:	01401304 	movi	r5,76
81107f68:	1009883a 	mov	r4,r2
81107f6c:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
81107f70:	e0bfff17 	ldw	r2,-4(fp)
81107f74:	10801f17 	ldw	r2,124(r2)
81107f78:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81107f7c:	e0bfff17 	ldw	r2,-4(fp)
81107f80:	10800017 	ldw	r2,0(r2)
81107f84:	e1bffe17 	ldw	r6,-8(fp)
81107f88:	01401344 	movi	r5,77
81107f8c:	1009883a 	mov	r4,r2
81107f90:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
81107f94:	e0bfff17 	ldw	r2,-4(fp)
81107f98:	10802017 	ldw	r2,128(r2)
81107f9c:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
81107fa0:	e0bfff17 	ldw	r2,-4(fp)
81107fa4:	10800017 	ldw	r2,0(r2)
81107fa8:	e1bffe17 	ldw	r6,-8(fp)
81107fac:	01401384 	movi	r5,78
81107fb0:	1009883a 	mov	r4,r2
81107fb4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107fb8:	e0bfff17 	ldw	r2,-4(fp)
81107fbc:	10802217 	ldw	r2,136(r2)
81107fc0:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107fc4:	e0bfff17 	ldw	r2,-4(fp)
81107fc8:	10800017 	ldw	r2,0(r2)
81107fcc:	e1bffe17 	ldw	r6,-8(fp)
81107fd0:	014013c4 	movi	r5,79
81107fd4:	1009883a 	mov	r4,r2
81107fd8:	11099680 	call	81109968 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107fdc:	e0bfff17 	ldw	r2,-4(fp)
81107fe0:	10802217 	ldw	r2,136(r2)
81107fe4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81107fe8:	e0bfff17 	ldw	r2,-4(fp)
81107fec:	10800017 	ldw	r2,0(r2)
81107ff0:	e1bffe17 	ldw	r6,-8(fp)
81107ff4:	01401404 	movi	r5,80
81107ff8:	1009883a 	mov	r4,r2
81107ffc:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
81108000:	e0bfff17 	ldw	r2,-4(fp)
81108004:	10802317 	ldw	r2,140(r2)
81108008:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
8110800c:	e0bfff17 	ldw	r2,-4(fp)
81108010:	10800017 	ldw	r2,0(r2)
81108014:	e1bffe17 	ldw	r6,-8(fp)
81108018:	01401444 	movi	r5,81
8110801c:	1009883a 	mov	r4,r2
81108020:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108024:	00800044 	movi	r2,1
81108028:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110802c:	e0bffd17 	ldw	r2,-12(fp)
}
81108030:	e037883a 	mov	sp,fp
81108034:	dfc00117 	ldw	ra,4(sp)
81108038:	df000017 	ldw	fp,0(sp)
8110803c:	dec00204 	addi	sp,sp,8
81108040:	f800283a 	ret

81108044 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81108044:	defffb04 	addi	sp,sp,-20
81108048:	de00012e 	bgeu	sp,et,81108050 <bRmapGetMemConfigArea+0xc>
8110804c:	003b68fa 	trap	3
81108050:	dfc00415 	stw	ra,16(sp)
81108054:	df000315 	stw	fp,12(sp)
81108058:	df000304 	addi	fp,sp,12
8110805c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108060:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108064:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108068:	e0bfff17 	ldw	r2,-4(fp)
8110806c:	1000a426 	beq	r2,zero,81108300 <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108070:	e0bfff17 	ldw	r2,-4(fp)
81108074:	10800017 	ldw	r2,0(r2)
81108078:	01401004 	movi	r5,64
8110807c:	1009883a 	mov	r4,r2
81108080:	11099bc0 	call	811099bc <uliRmapReadReg>
81108084:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
81108088:	e0bfff17 	ldw	r2,-4(fp)
8110808c:	e0fffe17 	ldw	r3,-8(fp)
81108090:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108094:	e0bfff17 	ldw	r2,-4(fp)
81108098:	10800017 	ldw	r2,0(r2)
8110809c:	01401044 	movi	r5,65
811080a0:	1009883a 	mov	r4,r2
811080a4:	11099bc0 	call	811099bc <uliRmapReadReg>
811080a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811080ac:	e0bfff17 	ldw	r2,-4(fp)
811080b0:	e0fffe17 	ldw	r3,-8(fp)
811080b4:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080b8:	e0bfff17 	ldw	r2,-4(fp)
811080bc:	10800017 	ldw	r2,0(r2)
811080c0:	01401084 	movi	r5,66
811080c4:	1009883a 	mov	r4,r2
811080c8:	11099bc0 	call	811099bc <uliRmapReadReg>
811080cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811080d0:	e0bfff17 	ldw	r2,-4(fp)
811080d4:	e0fffe17 	ldw	r3,-8(fp)
811080d8:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080dc:	e0bfff17 	ldw	r2,-4(fp)
811080e0:	10800017 	ldw	r2,0(r2)
811080e4:	014010c4 	movi	r5,67
811080e8:	1009883a 	mov	r4,r2
811080ec:	11099bc0 	call	811099bc <uliRmapReadReg>
811080f0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
811080f4:	e0bfff17 	ldw	r2,-4(fp)
811080f8:	e0fffe17 	ldw	r3,-8(fp)
811080fc:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108100:	e0bfff17 	ldw	r2,-4(fp)
81108104:	10800017 	ldw	r2,0(r2)
81108108:	01401104 	movi	r5,68
8110810c:	1009883a 	mov	r4,r2
81108110:	11099bc0 	call	811099bc <uliRmapReadReg>
81108114:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81108118:	e0bfff17 	ldw	r2,-4(fp)
8110811c:	e0fffe17 	ldw	r3,-8(fp)
81108120:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108124:	e0bfff17 	ldw	r2,-4(fp)
81108128:	10800017 	ldw	r2,0(r2)
8110812c:	01401144 	movi	r5,69
81108130:	1009883a 	mov	r4,r2
81108134:	11099bc0 	call	811099bc <uliRmapReadReg>
81108138:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
8110813c:	e0bfff17 	ldw	r2,-4(fp)
81108140:	e0fffe17 	ldw	r3,-8(fp)
81108144:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108148:	e0bfff17 	ldw	r2,-4(fp)
8110814c:	10800017 	ldw	r2,0(r2)
81108150:	01401184 	movi	r5,70
81108154:	1009883a 	mov	r4,r2
81108158:	11099bc0 	call	811099bc <uliRmapReadReg>
8110815c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
81108160:	e0bfff17 	ldw	r2,-4(fp)
81108164:	e0fffe17 	ldw	r3,-8(fp)
81108168:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110816c:	e0bfff17 	ldw	r2,-4(fp)
81108170:	10800017 	ldw	r2,0(r2)
81108174:	014011c4 	movi	r5,71
81108178:	1009883a 	mov	r4,r2
8110817c:	11099bc0 	call	811099bc <uliRmapReadReg>
81108180:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
81108184:	e0bfff17 	ldw	r2,-4(fp)
81108188:	e0fffe17 	ldw	r3,-8(fp)
8110818c:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108190:	e0bfff17 	ldw	r2,-4(fp)
81108194:	10800017 	ldw	r2,0(r2)
81108198:	01401204 	movi	r5,72
8110819c:	1009883a 	mov	r4,r2
811081a0:	11099bc0 	call	811099bc <uliRmapReadReg>
811081a4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811081a8:	e0bfff17 	ldw	r2,-4(fp)
811081ac:	e0fffe17 	ldw	r3,-8(fp)
811081b0:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081b4:	e0bfff17 	ldw	r2,-4(fp)
811081b8:	10800017 	ldw	r2,0(r2)
811081bc:	01401244 	movi	r5,73
811081c0:	1009883a 	mov	r4,r2
811081c4:	11099bc0 	call	811099bc <uliRmapReadReg>
811081c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811081cc:	e0bfff17 	ldw	r2,-4(fp)
811081d0:	e0fffe17 	ldw	r3,-8(fp)
811081d4:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081d8:	e0bfff17 	ldw	r2,-4(fp)
811081dc:	10800017 	ldw	r2,0(r2)
811081e0:	01401284 	movi	r5,74
811081e4:	1009883a 	mov	r4,r2
811081e8:	11099bc0 	call	811099bc <uliRmapReadReg>
811081ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
811081f0:	e0bfff17 	ldw	r2,-4(fp)
811081f4:	e0fffe17 	ldw	r3,-8(fp)
811081f8:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081fc:	e0bfff17 	ldw	r2,-4(fp)
81108200:	10800017 	ldw	r2,0(r2)
81108204:	014012c4 	movi	r5,75
81108208:	1009883a 	mov	r4,r2
8110820c:	11099bc0 	call	811099bc <uliRmapReadReg>
81108210:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81108214:	e0bfff17 	ldw	r2,-4(fp)
81108218:	e0fffe17 	ldw	r3,-8(fp)
8110821c:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108220:	e0bfff17 	ldw	r2,-4(fp)
81108224:	10800017 	ldw	r2,0(r2)
81108228:	01401304 	movi	r5,76
8110822c:	1009883a 	mov	r4,r2
81108230:	11099bc0 	call	811099bc <uliRmapReadReg>
81108234:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81108238:	e0bfff17 	ldw	r2,-4(fp)
8110823c:	e0fffe17 	ldw	r3,-8(fp)
81108240:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108244:	e0bfff17 	ldw	r2,-4(fp)
81108248:	10800017 	ldw	r2,0(r2)
8110824c:	01401344 	movi	r5,77
81108250:	1009883a 	mov	r4,r2
81108254:	11099bc0 	call	811099bc <uliRmapReadReg>
81108258:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
8110825c:	e0bfff17 	ldw	r2,-4(fp)
81108260:	e0fffe17 	ldw	r3,-8(fp)
81108264:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108268:	e0bfff17 	ldw	r2,-4(fp)
8110826c:	10800017 	ldw	r2,0(r2)
81108270:	01401384 	movi	r5,78
81108274:	1009883a 	mov	r4,r2
81108278:	11099bc0 	call	811099bc <uliRmapReadReg>
8110827c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
81108280:	e0bfff17 	ldw	r2,-4(fp)
81108284:	e0fffe17 	ldw	r3,-8(fp)
81108288:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110828c:	e0bfff17 	ldw	r2,-4(fp)
81108290:	10800017 	ldw	r2,0(r2)
81108294:	014013c4 	movi	r5,79
81108298:	1009883a 	mov	r4,r2
8110829c:	11099bc0 	call	811099bc <uliRmapReadReg>
811082a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811082a4:	e0bfff17 	ldw	r2,-4(fp)
811082a8:	e0fffe17 	ldw	r3,-8(fp)
811082ac:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082b0:	e0bfff17 	ldw	r2,-4(fp)
811082b4:	10800017 	ldw	r2,0(r2)
811082b8:	01401404 	movi	r5,80
811082bc:	1009883a 	mov	r4,r2
811082c0:	11099bc0 	call	811099bc <uliRmapReadReg>
811082c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811082c8:	e0bfff17 	ldw	r2,-4(fp)
811082cc:	e0fffe17 	ldw	r3,-8(fp)
811082d0:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082d4:	e0bfff17 	ldw	r2,-4(fp)
811082d8:	10800017 	ldw	r2,0(r2)
811082dc:	01401444 	movi	r5,81
811082e0:	1009883a 	mov	r4,r2
811082e4:	11099bc0 	call	811099bc <uliRmapReadReg>
811082e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
811082ec:	e0bfff17 	ldw	r2,-4(fp)
811082f0:	e0fffe17 	ldw	r3,-8(fp)
811082f4:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
811082f8:	00800044 	movi	r2,1
811082fc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108300:	e0bffd17 	ldw	r2,-12(fp)
}
81108304:	e037883a 	mov	sp,fp
81108308:	dfc00117 	ldw	ra,4(sp)
8110830c:	df000017 	ldw	fp,0(sp)
81108310:	dec00204 	addi	sp,sp,8
81108314:	f800283a 	ret

81108318 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81108318:	defffb04 	addi	sp,sp,-20
8110831c:	de00012e 	bgeu	sp,et,81108324 <bRmapGetMemConfigStat+0xc>
81108320:	003b68fa 	trap	3
81108324:	dfc00415 	stw	ra,16(sp)
81108328:	df000315 	stw	fp,12(sp)
8110832c:	df000304 	addi	fp,sp,12
81108330:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108334:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108338:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110833c:	e0bfff17 	ldw	r2,-4(fp)
81108340:	10001426 	beq	r2,zero,81108394 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108344:	e0bfff17 	ldw	r2,-4(fp)
81108348:	10800017 	ldw	r2,0(r2)
8110834c:	014001c4 	movi	r5,7
81108350:	1009883a 	mov	r4,r2
81108354:	11099bc0 	call	811099bc <uliRmapReadReg>
81108358:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	e0fffe17 	ldw	r3,-8(fp)
81108364:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108368:	e0bfff17 	ldw	r2,-4(fp)
8110836c:	10800017 	ldw	r2,0(r2)
81108370:	01400184 	movi	r5,6
81108374:	1009883a 	mov	r4,r2
81108378:	11099bc0 	call	811099bc <uliRmapReadReg>
8110837c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
81108380:	e0bfff17 	ldw	r2,-4(fp)
81108384:	e0fffe17 	ldw	r3,-8(fp)
81108388:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
8110838c:	00800044 	movi	r2,1
81108390:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108394:	e0bffd17 	ldw	r2,-12(fp)
}
81108398:	e037883a 	mov	sp,fp
8110839c:	dfc00117 	ldw	ra,4(sp)
811083a0:	df000017 	ldw	fp,0(sp)
811083a4:	dec00204 	addi	sp,sp,8
811083a8:	f800283a 	ret

811083ac <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811083ac:	defffb04 	addi	sp,sp,-20
811083b0:	de00012e 	bgeu	sp,et,811083b8 <bRmapSetRmapMemHKArea+0xc>
811083b4:	003b68fa 	trap	3
811083b8:	dfc00415 	stw	ra,16(sp)
811083bc:	df000315 	stw	fp,12(sp)
811083c0:	df000304 	addi	fp,sp,12
811083c4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811083c8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811083cc:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811083d0:	e0bfff17 	ldw	r2,-4(fp)
811083d4:	10030226 	beq	r2,zero,81108fe0 <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083d8:	e0bfff17 	ldw	r2,-4(fp)
811083dc:	10800017 	ldw	r2,0(r2)
811083e0:	01402804 	movi	r5,160
811083e4:	1009883a 	mov	r4,r2
811083e8:	11099bc0 	call	811099bc <uliRmapReadReg>
811083ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
811083f0:	e0bffe17 	ldw	r2,-8(fp)
811083f4:	10bfffec 	andhi	r2,r2,65535
811083f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
811083fc:	e0bfff17 	ldw	r2,-4(fp)
81108400:	1080260b 	ldhu	r2,152(r2)
81108404:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81108408:	e0fffe17 	ldw	r3,-8(fp)
8110840c:	1884b03a 	or	r2,r3,r2
81108410:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81108414:	e0bffe17 	ldw	r2,-8(fp)
81108418:	10bfffcc 	andi	r2,r2,65535
8110841c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
81108420:	e0bfff17 	ldw	r2,-4(fp)
81108424:	10800017 	ldw	r2,0(r2)
81108428:	e1bffe17 	ldw	r6,-8(fp)
8110842c:	01402804 	movi	r5,160
81108430:	1009883a 	mov	r4,r2
81108434:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108438:	e0bfff17 	ldw	r2,-4(fp)
8110843c:	10800017 	ldw	r2,0(r2)
81108440:	01402844 	movi	r5,161
81108444:	1009883a 	mov	r4,r2
81108448:	11099bc0 	call	811099bc <uliRmapReadReg>
8110844c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
81108450:	e0bffe17 	ldw	r2,-8(fp)
81108454:	10bfffec 	andhi	r2,r2,65535
81108458:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
8110845c:	e0bfff17 	ldw	r2,-4(fp)
81108460:	1080270b 	ldhu	r2,156(r2)
81108464:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81108468:	e0fffe17 	ldw	r3,-8(fp)
8110846c:	1884b03a 	or	r2,r3,r2
81108470:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81108474:	e0bffe17 	ldw	r2,-8(fp)
81108478:	10bfffcc 	andi	r2,r2,65535
8110847c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
81108480:	e0bfff17 	ldw	r2,-4(fp)
81108484:	10800017 	ldw	r2,0(r2)
81108488:	e1bffe17 	ldw	r6,-8(fp)
8110848c:	01402844 	movi	r5,161
81108490:	1009883a 	mov	r4,r2
81108494:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108498:	e0bfff17 	ldw	r2,-4(fp)
8110849c:	10800017 	ldw	r2,0(r2)
811084a0:	01402884 	movi	r5,162
811084a4:	1009883a 	mov	r4,r2
811084a8:	11099bc0 	call	811099bc <uliRmapReadReg>
811084ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
811084b0:	e0bffe17 	ldw	r2,-8(fp)
811084b4:	10bfffec 	andhi	r2,r2,65535
811084b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
811084bc:	e0bfff17 	ldw	r2,-4(fp)
811084c0:	1080280b 	ldhu	r2,160(r2)
811084c4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
811084c8:	e0fffe17 	ldw	r3,-8(fp)
811084cc:	1884b03a 	or	r2,r3,r2
811084d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
811084d4:	e0bffe17 	ldw	r2,-8(fp)
811084d8:	10bfffcc 	andi	r2,r2,65535
811084dc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
811084e0:	e0bfff17 	ldw	r2,-4(fp)
811084e4:	10800017 	ldw	r2,0(r2)
811084e8:	e1bffe17 	ldw	r6,-8(fp)
811084ec:	01402884 	movi	r5,162
811084f0:	1009883a 	mov	r4,r2
811084f4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811084f8:	e0bfff17 	ldw	r2,-4(fp)
811084fc:	10800017 	ldw	r2,0(r2)
81108500:	014028c4 	movi	r5,163
81108504:	1009883a 	mov	r4,r2
81108508:	11099bc0 	call	811099bc <uliRmapReadReg>
8110850c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81108510:	e0bffe17 	ldw	r2,-8(fp)
81108514:	10bfffec 	andhi	r2,r2,65535
81108518:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
8110851c:	e0bfff17 	ldw	r2,-4(fp)
81108520:	1080290b 	ldhu	r2,164(r2)
81108524:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81108528:	e0fffe17 	ldw	r3,-8(fp)
8110852c:	1884b03a 	or	r2,r3,r2
81108530:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81108534:	e0bffe17 	ldw	r2,-8(fp)
81108538:	10bfffcc 	andi	r2,r2,65535
8110853c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81108540:	e0bfff17 	ldw	r2,-4(fp)
81108544:	10800017 	ldw	r2,0(r2)
81108548:	e1bffe17 	ldw	r6,-8(fp)
8110854c:	014028c4 	movi	r5,163
81108550:	1009883a 	mov	r4,r2
81108554:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108558:	e0bfff17 	ldw	r2,-4(fp)
8110855c:	10800017 	ldw	r2,0(r2)
81108560:	01402904 	movi	r5,164
81108564:	1009883a 	mov	r4,r2
81108568:	11099bc0 	call	811099bc <uliRmapReadReg>
8110856c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81108570:	e0bffe17 	ldw	r2,-8(fp)
81108574:	10bfffec 	andhi	r2,r2,65535
81108578:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
8110857c:	e0bfff17 	ldw	r2,-4(fp)
81108580:	10802a0b 	ldhu	r2,168(r2)
81108584:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81108588:	e0fffe17 	ldw	r3,-8(fp)
8110858c:	1884b03a 	or	r2,r3,r2
81108590:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81108594:	e0bffe17 	ldw	r2,-8(fp)
81108598:	10bfffcc 	andi	r2,r2,65535
8110859c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
811085a0:	e0bfff17 	ldw	r2,-4(fp)
811085a4:	10800017 	ldw	r2,0(r2)
811085a8:	e1bffe17 	ldw	r6,-8(fp)
811085ac:	01402904 	movi	r5,164
811085b0:	1009883a 	mov	r4,r2
811085b4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085b8:	e0bfff17 	ldw	r2,-4(fp)
811085bc:	10800017 	ldw	r2,0(r2)
811085c0:	01402944 	movi	r5,165
811085c4:	1009883a 	mov	r4,r2
811085c8:	11099bc0 	call	811099bc <uliRmapReadReg>
811085cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
811085d0:	e0bffe17 	ldw	r2,-8(fp)
811085d4:	10bfffec 	andhi	r2,r2,65535
811085d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
811085dc:	e0bfff17 	ldw	r2,-4(fp)
811085e0:	10802b0b 	ldhu	r2,172(r2)
811085e4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
811085e8:	e0fffe17 	ldw	r3,-8(fp)
811085ec:	1884b03a 	or	r2,r3,r2
811085f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
811085f4:	e0bffe17 	ldw	r2,-8(fp)
811085f8:	10bfffcc 	andi	r2,r2,65535
811085fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81108600:	e0bfff17 	ldw	r2,-4(fp)
81108604:	10800017 	ldw	r2,0(r2)
81108608:	e1bffe17 	ldw	r6,-8(fp)
8110860c:	01402944 	movi	r5,165
81108610:	1009883a 	mov	r4,r2
81108614:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108618:	e0bfff17 	ldw	r2,-4(fp)
8110861c:	10800017 	ldw	r2,0(r2)
81108620:	01402984 	movi	r5,166
81108624:	1009883a 	mov	r4,r2
81108628:	11099bc0 	call	811099bc <uliRmapReadReg>
8110862c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81108630:	e0bffe17 	ldw	r2,-8(fp)
81108634:	10bfffec 	andhi	r2,r2,65535
81108638:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
8110863c:	e0bfff17 	ldw	r2,-4(fp)
81108640:	10802c0b 	ldhu	r2,176(r2)
81108644:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81108648:	e0fffe17 	ldw	r3,-8(fp)
8110864c:	1884b03a 	or	r2,r3,r2
81108650:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81108654:	e0bffe17 	ldw	r2,-8(fp)
81108658:	10bfffcc 	andi	r2,r2,65535
8110865c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81108660:	e0bfff17 	ldw	r2,-4(fp)
81108664:	10800017 	ldw	r2,0(r2)
81108668:	e1bffe17 	ldw	r6,-8(fp)
8110866c:	01402984 	movi	r5,166
81108670:	1009883a 	mov	r4,r2
81108674:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108678:	e0bfff17 	ldw	r2,-4(fp)
8110867c:	10800017 	ldw	r2,0(r2)
81108680:	014029c4 	movi	r5,167
81108684:	1009883a 	mov	r4,r2
81108688:	11099bc0 	call	811099bc <uliRmapReadReg>
8110868c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81108690:	e0bffe17 	ldw	r2,-8(fp)
81108694:	10bfffec 	andhi	r2,r2,65535
81108698:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
8110869c:	e0bfff17 	ldw	r2,-4(fp)
811086a0:	10802d0b 	ldhu	r2,180(r2)
811086a4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
811086a8:	e0fffe17 	ldw	r3,-8(fp)
811086ac:	1884b03a 	or	r2,r3,r2
811086b0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
811086b4:	e0bffe17 	ldw	r2,-8(fp)
811086b8:	10bfffcc 	andi	r2,r2,65535
811086bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
811086c0:	e0bfff17 	ldw	r2,-4(fp)
811086c4:	10800017 	ldw	r2,0(r2)
811086c8:	e1bffe17 	ldw	r6,-8(fp)
811086cc:	014029c4 	movi	r5,167
811086d0:	1009883a 	mov	r4,r2
811086d4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086d8:	e0bfff17 	ldw	r2,-4(fp)
811086dc:	10800017 	ldw	r2,0(r2)
811086e0:	01402a04 	movi	r5,168
811086e4:	1009883a 	mov	r4,r2
811086e8:	11099bc0 	call	811099bc <uliRmapReadReg>
811086ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
811086f0:	e0bffe17 	ldw	r2,-8(fp)
811086f4:	10bfffec 	andhi	r2,r2,65535
811086f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
811086fc:	e0bfff17 	ldw	r2,-4(fp)
81108700:	10802e0b 	ldhu	r2,184(r2)
81108704:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81108708:	e0fffe17 	ldw	r3,-8(fp)
8110870c:	1884b03a 	or	r2,r3,r2
81108710:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81108714:	e0bffe17 	ldw	r2,-8(fp)
81108718:	10bfffcc 	andi	r2,r2,65535
8110871c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81108720:	e0bfff17 	ldw	r2,-4(fp)
81108724:	10800017 	ldw	r2,0(r2)
81108728:	e1bffe17 	ldw	r6,-8(fp)
8110872c:	01402a04 	movi	r5,168
81108730:	1009883a 	mov	r4,r2
81108734:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108738:	e0bfff17 	ldw	r2,-4(fp)
8110873c:	10800017 	ldw	r2,0(r2)
81108740:	01402a44 	movi	r5,169
81108744:	1009883a 	mov	r4,r2
81108748:	11099bc0 	call	811099bc <uliRmapReadReg>
8110874c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81108750:	e0bffe17 	ldw	r2,-8(fp)
81108754:	10bfffec 	andhi	r2,r2,65535
81108758:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
8110875c:	e0bfff17 	ldw	r2,-4(fp)
81108760:	10802f0b 	ldhu	r2,188(r2)
81108764:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81108768:	e0fffe17 	ldw	r3,-8(fp)
8110876c:	1884b03a 	or	r2,r3,r2
81108770:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81108774:	e0bffe17 	ldw	r2,-8(fp)
81108778:	10bfffcc 	andi	r2,r2,65535
8110877c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81108780:	e0bfff17 	ldw	r2,-4(fp)
81108784:	10800017 	ldw	r2,0(r2)
81108788:	e1bffe17 	ldw	r6,-8(fp)
8110878c:	01402a44 	movi	r5,169
81108790:	1009883a 	mov	r4,r2
81108794:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108798:	e0bfff17 	ldw	r2,-4(fp)
8110879c:	10800017 	ldw	r2,0(r2)
811087a0:	01402a84 	movi	r5,170
811087a4:	1009883a 	mov	r4,r2
811087a8:	11099bc0 	call	811099bc <uliRmapReadReg>
811087ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
811087b0:	e0bffe17 	ldw	r2,-8(fp)
811087b4:	10bfffec 	andhi	r2,r2,65535
811087b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
811087bc:	e0bfff17 	ldw	r2,-4(fp)
811087c0:	1080300b 	ldhu	r2,192(r2)
811087c4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
811087c8:	e0fffe17 	ldw	r3,-8(fp)
811087cc:	1884b03a 	or	r2,r3,r2
811087d0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
811087d4:	e0bffe17 	ldw	r2,-8(fp)
811087d8:	10bfffcc 	andi	r2,r2,65535
811087dc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
811087e0:	e0bfff17 	ldw	r2,-4(fp)
811087e4:	10800017 	ldw	r2,0(r2)
811087e8:	e1bffe17 	ldw	r6,-8(fp)
811087ec:	01402a84 	movi	r5,170
811087f0:	1009883a 	mov	r4,r2
811087f4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087f8:	e0bfff17 	ldw	r2,-4(fp)
811087fc:	10800017 	ldw	r2,0(r2)
81108800:	01402ac4 	movi	r5,171
81108804:	1009883a 	mov	r4,r2
81108808:	11099bc0 	call	811099bc <uliRmapReadReg>
8110880c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81108810:	e0bffe17 	ldw	r2,-8(fp)
81108814:	10bfffec 	andhi	r2,r2,65535
81108818:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
8110881c:	e0bfff17 	ldw	r2,-4(fp)
81108820:	1080310b 	ldhu	r2,196(r2)
81108824:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81108828:	e0fffe17 	ldw	r3,-8(fp)
8110882c:	1884b03a 	or	r2,r3,r2
81108830:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81108834:	e0bffe17 	ldw	r2,-8(fp)
81108838:	10bfffcc 	andi	r2,r2,65535
8110883c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81108840:	e0bfff17 	ldw	r2,-4(fp)
81108844:	10800017 	ldw	r2,0(r2)
81108848:	e1bffe17 	ldw	r6,-8(fp)
8110884c:	01402ac4 	movi	r5,171
81108850:	1009883a 	mov	r4,r2
81108854:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108858:	e0bfff17 	ldw	r2,-4(fp)
8110885c:	10800017 	ldw	r2,0(r2)
81108860:	01402b04 	movi	r5,172
81108864:	1009883a 	mov	r4,r2
81108868:	11099bc0 	call	811099bc <uliRmapReadReg>
8110886c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81108870:	e0bffe17 	ldw	r2,-8(fp)
81108874:	10bfffec 	andhi	r2,r2,65535
81108878:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
8110887c:	e0bfff17 	ldw	r2,-4(fp)
81108880:	1080320b 	ldhu	r2,200(r2)
81108884:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81108888:	e0fffe17 	ldw	r3,-8(fp)
8110888c:	1884b03a 	or	r2,r3,r2
81108890:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81108894:	e0bffe17 	ldw	r2,-8(fp)
81108898:	10bfffcc 	andi	r2,r2,65535
8110889c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
811088a0:	e0bfff17 	ldw	r2,-4(fp)
811088a4:	10800017 	ldw	r2,0(r2)
811088a8:	e1bffe17 	ldw	r6,-8(fp)
811088ac:	01402b04 	movi	r5,172
811088b0:	1009883a 	mov	r4,r2
811088b4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088b8:	e0bfff17 	ldw	r2,-4(fp)
811088bc:	10800017 	ldw	r2,0(r2)
811088c0:	01402b44 	movi	r5,173
811088c4:	1009883a 	mov	r4,r2
811088c8:	11099bc0 	call	811099bc <uliRmapReadReg>
811088cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
811088d0:	e0bffe17 	ldw	r2,-8(fp)
811088d4:	10bfffec 	andhi	r2,r2,65535
811088d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
811088dc:	e0bfff17 	ldw	r2,-4(fp)
811088e0:	1080330b 	ldhu	r2,204(r2)
811088e4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
811088e8:	e0fffe17 	ldw	r3,-8(fp)
811088ec:	1884b03a 	or	r2,r3,r2
811088f0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
811088f4:	e0bffe17 	ldw	r2,-8(fp)
811088f8:	10bfffcc 	andi	r2,r2,65535
811088fc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81108900:	e0bfff17 	ldw	r2,-4(fp)
81108904:	10800017 	ldw	r2,0(r2)
81108908:	e1bffe17 	ldw	r6,-8(fp)
8110890c:	01402b44 	movi	r5,173
81108910:	1009883a 	mov	r4,r2
81108914:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108918:	e0bfff17 	ldw	r2,-4(fp)
8110891c:	10800017 	ldw	r2,0(r2)
81108920:	01402b84 	movi	r5,174
81108924:	1009883a 	mov	r4,r2
81108928:	11099bc0 	call	811099bc <uliRmapReadReg>
8110892c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81108930:	e0bffe17 	ldw	r2,-8(fp)
81108934:	10bfffec 	andhi	r2,r2,65535
81108938:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
8110893c:	e0bfff17 	ldw	r2,-4(fp)
81108940:	1080340b 	ldhu	r2,208(r2)
81108944:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81108948:	e0fffe17 	ldw	r3,-8(fp)
8110894c:	1884b03a 	or	r2,r3,r2
81108950:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81108954:	e0bffe17 	ldw	r2,-8(fp)
81108958:	10bfffcc 	andi	r2,r2,65535
8110895c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81108960:	e0bfff17 	ldw	r2,-4(fp)
81108964:	10800017 	ldw	r2,0(r2)
81108968:	e1bffe17 	ldw	r6,-8(fp)
8110896c:	01402b84 	movi	r5,174
81108970:	1009883a 	mov	r4,r2
81108974:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108978:	e0bfff17 	ldw	r2,-4(fp)
8110897c:	10800017 	ldw	r2,0(r2)
81108980:	01402bc4 	movi	r5,175
81108984:	1009883a 	mov	r4,r2
81108988:	11099bc0 	call	811099bc <uliRmapReadReg>
8110898c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81108990:	e0bffe17 	ldw	r2,-8(fp)
81108994:	10bfffec 	andhi	r2,r2,65535
81108998:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
8110899c:	e0bfff17 	ldw	r2,-4(fp)
811089a0:	1080350b 	ldhu	r2,212(r2)
811089a4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
811089a8:	e0fffe17 	ldw	r3,-8(fp)
811089ac:	1884b03a 	or	r2,r3,r2
811089b0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
811089b4:	e0bffe17 	ldw	r2,-8(fp)
811089b8:	10bfffcc 	andi	r2,r2,65535
811089bc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
811089c0:	e0bfff17 	ldw	r2,-4(fp)
811089c4:	10800017 	ldw	r2,0(r2)
811089c8:	e1bffe17 	ldw	r6,-8(fp)
811089cc:	01402bc4 	movi	r5,175
811089d0:	1009883a 	mov	r4,r2
811089d4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089d8:	e0bfff17 	ldw	r2,-4(fp)
811089dc:	10800017 	ldw	r2,0(r2)
811089e0:	01402c04 	movi	r5,176
811089e4:	1009883a 	mov	r4,r2
811089e8:	11099bc0 	call	811099bc <uliRmapReadReg>
811089ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
811089f0:	e0bffe17 	ldw	r2,-8(fp)
811089f4:	10bfffec 	andhi	r2,r2,65535
811089f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
811089fc:	e0bfff17 	ldw	r2,-4(fp)
81108a00:	1080360b 	ldhu	r2,216(r2)
81108a04:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81108a08:	e0fffe17 	ldw	r3,-8(fp)
81108a0c:	1884b03a 	or	r2,r3,r2
81108a10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81108a14:	e0bffe17 	ldw	r2,-8(fp)
81108a18:	10bfffcc 	andi	r2,r2,65535
81108a1c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81108a20:	e0bfff17 	ldw	r2,-4(fp)
81108a24:	10800017 	ldw	r2,0(r2)
81108a28:	e1bffe17 	ldw	r6,-8(fp)
81108a2c:	01402c04 	movi	r5,176
81108a30:	1009883a 	mov	r4,r2
81108a34:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a38:	e0bfff17 	ldw	r2,-4(fp)
81108a3c:	10800017 	ldw	r2,0(r2)
81108a40:	01402c44 	movi	r5,177
81108a44:	1009883a 	mov	r4,r2
81108a48:	11099bc0 	call	811099bc <uliRmapReadReg>
81108a4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81108a50:	e0bffe17 	ldw	r2,-8(fp)
81108a54:	10bfffec 	andhi	r2,r2,65535
81108a58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81108a5c:	e0bfff17 	ldw	r2,-4(fp)
81108a60:	1080370b 	ldhu	r2,220(r2)
81108a64:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81108a68:	e0fffe17 	ldw	r3,-8(fp)
81108a6c:	1884b03a 	or	r2,r3,r2
81108a70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81108a74:	e0bffe17 	ldw	r2,-8(fp)
81108a78:	10bfffcc 	andi	r2,r2,65535
81108a7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81108a80:	e0bfff17 	ldw	r2,-4(fp)
81108a84:	10800017 	ldw	r2,0(r2)
81108a88:	e1bffe17 	ldw	r6,-8(fp)
81108a8c:	01402c44 	movi	r5,177
81108a90:	1009883a 	mov	r4,r2
81108a94:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a98:	e0bfff17 	ldw	r2,-4(fp)
81108a9c:	10800017 	ldw	r2,0(r2)
81108aa0:	01402c84 	movi	r5,178
81108aa4:	1009883a 	mov	r4,r2
81108aa8:	11099bc0 	call	811099bc <uliRmapReadReg>
81108aac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81108ab0:	e0bffe17 	ldw	r2,-8(fp)
81108ab4:	10bfffec 	andhi	r2,r2,65535
81108ab8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81108abc:	e0bfff17 	ldw	r2,-4(fp)
81108ac0:	1080380b 	ldhu	r2,224(r2)
81108ac4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81108ac8:	e0fffe17 	ldw	r3,-8(fp)
81108acc:	1884b03a 	or	r2,r3,r2
81108ad0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81108ad4:	e0bffe17 	ldw	r2,-8(fp)
81108ad8:	10bfffcc 	andi	r2,r2,65535
81108adc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81108ae0:	e0bfff17 	ldw	r2,-4(fp)
81108ae4:	10800017 	ldw	r2,0(r2)
81108ae8:	e1bffe17 	ldw	r6,-8(fp)
81108aec:	01402c84 	movi	r5,178
81108af0:	1009883a 	mov	r4,r2
81108af4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108af8:	e0bfff17 	ldw	r2,-4(fp)
81108afc:	10800017 	ldw	r2,0(r2)
81108b00:	01402cc4 	movi	r5,179
81108b04:	1009883a 	mov	r4,r2
81108b08:	11099bc0 	call	811099bc <uliRmapReadReg>
81108b0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
81108b10:	e0bffe17 	ldw	r2,-8(fp)
81108b14:	10bfffec 	andhi	r2,r2,65535
81108b18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108b1c:	e0bfff17 	ldw	r2,-4(fp)
81108b20:	1080390b 	ldhu	r2,228(r2)
81108b24:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108b28:	e0fffe17 	ldw	r3,-8(fp)
81108b2c:	1884b03a 	or	r2,r3,r2
81108b30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108b34:	e0bffe17 	ldw	r2,-8(fp)
81108b38:	10bfffcc 	andi	r2,r2,65535
81108b3c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
81108b40:	e0bfff17 	ldw	r2,-4(fp)
81108b44:	10800017 	ldw	r2,0(r2)
81108b48:	e1bffe17 	ldw	r6,-8(fp)
81108b4c:	01402cc4 	movi	r5,179
81108b50:	1009883a 	mov	r4,r2
81108b54:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b58:	e0bfff17 	ldw	r2,-4(fp)
81108b5c:	10800017 	ldw	r2,0(r2)
81108b60:	01402d04 	movi	r5,180
81108b64:	1009883a 	mov	r4,r2
81108b68:	11099bc0 	call	811099bc <uliRmapReadReg>
81108b6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
81108b70:	e0bffe17 	ldw	r2,-8(fp)
81108b74:	10bfffec 	andhi	r2,r2,65535
81108b78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108b7c:	e0bfff17 	ldw	r2,-4(fp)
81108b80:	10803a0b 	ldhu	r2,232(r2)
81108b84:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
81108b88:	e0fffe17 	ldw	r3,-8(fp)
81108b8c:	1884b03a 	or	r2,r3,r2
81108b90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
81108b94:	e0bffe17 	ldw	r2,-8(fp)
81108b98:	10bfffcc 	andi	r2,r2,65535
81108b9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
81108ba0:	e0bfff17 	ldw	r2,-4(fp)
81108ba4:	10800017 	ldw	r2,0(r2)
81108ba8:	e1bffe17 	ldw	r6,-8(fp)
81108bac:	01402d04 	movi	r5,180
81108bb0:	1009883a 	mov	r4,r2
81108bb4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bb8:	e0bfff17 	ldw	r2,-4(fp)
81108bbc:	10800017 	ldw	r2,0(r2)
81108bc0:	01402d44 	movi	r5,181
81108bc4:	1009883a 	mov	r4,r2
81108bc8:	11099bc0 	call	811099bc <uliRmapReadReg>
81108bcc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
81108bd0:	e0bffe17 	ldw	r2,-8(fp)
81108bd4:	10bfffec 	andhi	r2,r2,65535
81108bd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
81108bdc:	e0bfff17 	ldw	r2,-4(fp)
81108be0:	10803b0b 	ldhu	r2,236(r2)
81108be4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108be8:	e0fffe17 	ldw	r3,-8(fp)
81108bec:	1884b03a 	or	r2,r3,r2
81108bf0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108bf4:	e0bffe17 	ldw	r2,-8(fp)
81108bf8:	10bfffcc 	andi	r2,r2,65535
81108bfc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
81108c00:	e0bfff17 	ldw	r2,-4(fp)
81108c04:	10800017 	ldw	r2,0(r2)
81108c08:	e1bffe17 	ldw	r6,-8(fp)
81108c0c:	01402d44 	movi	r5,181
81108c10:	1009883a 	mov	r4,r2
81108c14:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c18:	e0bfff17 	ldw	r2,-4(fp)
81108c1c:	10800017 	ldw	r2,0(r2)
81108c20:	01402d84 	movi	r5,182
81108c24:	1009883a 	mov	r4,r2
81108c28:	11099bc0 	call	811099bc <uliRmapReadReg>
81108c2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
81108c30:	e0bffe17 	ldw	r2,-8(fp)
81108c34:	10bfffec 	andhi	r2,r2,65535
81108c38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81108c3c:	e0bfff17 	ldw	r2,-4(fp)
81108c40:	10803c0b 	ldhu	r2,240(r2)
81108c44:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81108c48:	e0fffe17 	ldw	r3,-8(fp)
81108c4c:	1884b03a 	or	r2,r3,r2
81108c50:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81108c54:	e0bffe17 	ldw	r2,-8(fp)
81108c58:	10bfffcc 	andi	r2,r2,65535
81108c5c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
81108c60:	e0bfff17 	ldw	r2,-4(fp)
81108c64:	10800017 	ldw	r2,0(r2)
81108c68:	e1bffe17 	ldw	r6,-8(fp)
81108c6c:	01402d84 	movi	r5,182
81108c70:	1009883a 	mov	r4,r2
81108c74:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c78:	e0bfff17 	ldw	r2,-4(fp)
81108c7c:	10800017 	ldw	r2,0(r2)
81108c80:	01402dc4 	movi	r5,183
81108c84:	1009883a 	mov	r4,r2
81108c88:	11099bc0 	call	811099bc <uliRmapReadReg>
81108c8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
81108c90:	e0bffe17 	ldw	r2,-8(fp)
81108c94:	10bfffec 	andhi	r2,r2,65535
81108c98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
81108c9c:	e0bfff17 	ldw	r2,-4(fp)
81108ca0:	10803d0b 	ldhu	r2,244(r2)
81108ca4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
81108ca8:	e0fffe17 	ldw	r3,-8(fp)
81108cac:	1884b03a 	or	r2,r3,r2
81108cb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
81108cb4:	e0bffe17 	ldw	r2,-8(fp)
81108cb8:	10bfffcc 	andi	r2,r2,65535
81108cbc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
81108cc0:	e0bfff17 	ldw	r2,-4(fp)
81108cc4:	10800017 	ldw	r2,0(r2)
81108cc8:	e1bffe17 	ldw	r6,-8(fp)
81108ccc:	01402dc4 	movi	r5,183
81108cd0:	1009883a 	mov	r4,r2
81108cd4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108cd8:	e0bfff17 	ldw	r2,-4(fp)
81108cdc:	10800017 	ldw	r2,0(r2)
81108ce0:	01402e04 	movi	r5,184
81108ce4:	1009883a 	mov	r4,r2
81108ce8:	11099bc0 	call	811099bc <uliRmapReadReg>
81108cec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
81108cf0:	e0bffe17 	ldw	r2,-8(fp)
81108cf4:	10bfffec 	andhi	r2,r2,65535
81108cf8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81108cfc:	e0bfff17 	ldw	r2,-4(fp)
81108d00:	10803e0b 	ldhu	r2,248(r2)
81108d04:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81108d08:	e0fffe17 	ldw	r3,-8(fp)
81108d0c:	1884b03a 	or	r2,r3,r2
81108d10:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81108d14:	e0bffe17 	ldw	r2,-8(fp)
81108d18:	10bfffcc 	andi	r2,r2,65535
81108d1c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
81108d20:	e0bfff17 	ldw	r2,-4(fp)
81108d24:	10800017 	ldw	r2,0(r2)
81108d28:	e1bffe17 	ldw	r6,-8(fp)
81108d2c:	01402e04 	movi	r5,184
81108d30:	1009883a 	mov	r4,r2
81108d34:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d38:	e0bfff17 	ldw	r2,-4(fp)
81108d3c:	10800017 	ldw	r2,0(r2)
81108d40:	01402e44 	movi	r5,185
81108d44:	1009883a 	mov	r4,r2
81108d48:	11099bc0 	call	811099bc <uliRmapReadReg>
81108d4c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
81108d50:	e0bffe17 	ldw	r2,-8(fp)
81108d54:	10bfffec 	andhi	r2,r2,65535
81108d58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81108d5c:	e0bfff17 	ldw	r2,-4(fp)
81108d60:	10803f0b 	ldhu	r2,252(r2)
81108d64:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81108d68:	e0fffe17 	ldw	r3,-8(fp)
81108d6c:	1884b03a 	or	r2,r3,r2
81108d70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81108d74:	e0bffe17 	ldw	r2,-8(fp)
81108d78:	10bfffcc 	andi	r2,r2,65535
81108d7c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
81108d80:	e0bfff17 	ldw	r2,-4(fp)
81108d84:	10800017 	ldw	r2,0(r2)
81108d88:	e1bffe17 	ldw	r6,-8(fp)
81108d8c:	01402e44 	movi	r5,185
81108d90:	1009883a 	mov	r4,r2
81108d94:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108d98:	e0bfff17 	ldw	r2,-4(fp)
81108d9c:	10800017 	ldw	r2,0(r2)
81108da0:	01402e84 	movi	r5,186
81108da4:	1009883a 	mov	r4,r2
81108da8:	11099bc0 	call	811099bc <uliRmapReadReg>
81108dac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
81108db0:	e0bffe17 	ldw	r2,-8(fp)
81108db4:	10bfffec 	andhi	r2,r2,65535
81108db8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
81108dbc:	e0bfff17 	ldw	r2,-4(fp)
81108dc0:	1080400b 	ldhu	r2,256(r2)
81108dc4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
81108dc8:	e0fffe17 	ldw	r3,-8(fp)
81108dcc:	1884b03a 	or	r2,r3,r2
81108dd0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
81108dd4:	e0bffe17 	ldw	r2,-8(fp)
81108dd8:	10bfffcc 	andi	r2,r2,65535
81108ddc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
81108de0:	e0bfff17 	ldw	r2,-4(fp)
81108de4:	10800017 	ldw	r2,0(r2)
81108de8:	e1bffe17 	ldw	r6,-8(fp)
81108dec:	01402e84 	movi	r5,186
81108df0:	1009883a 	mov	r4,r2
81108df4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108df8:	e0bfff17 	ldw	r2,-4(fp)
81108dfc:	10800017 	ldw	r2,0(r2)
81108e00:	01402ec4 	movi	r5,187
81108e04:	1009883a 	mov	r4,r2
81108e08:	11099bc0 	call	811099bc <uliRmapReadReg>
81108e0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
81108e10:	e0bffe17 	ldw	r2,-8(fp)
81108e14:	10bfffec 	andhi	r2,r2,65535
81108e18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81108e1c:	e0bfff17 	ldw	r2,-4(fp)
81108e20:	1080410b 	ldhu	r2,260(r2)
81108e24:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81108e28:	e0fffe17 	ldw	r3,-8(fp)
81108e2c:	1884b03a 	or	r2,r3,r2
81108e30:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81108e34:	e0bffe17 	ldw	r2,-8(fp)
81108e38:	10bfffcc 	andi	r2,r2,65535
81108e3c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
81108e40:	e0bfff17 	ldw	r2,-4(fp)
81108e44:	10800017 	ldw	r2,0(r2)
81108e48:	e1bffe17 	ldw	r6,-8(fp)
81108e4c:	01402ec4 	movi	r5,187
81108e50:	1009883a 	mov	r4,r2
81108e54:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108e58:	e0bfff17 	ldw	r2,-4(fp)
81108e5c:	10800017 	ldw	r2,0(r2)
81108e60:	01402f04 	movi	r5,188
81108e64:	1009883a 	mov	r4,r2
81108e68:	11099bc0 	call	811099bc <uliRmapReadReg>
81108e6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
81108e70:	e0bffe17 	ldw	r2,-8(fp)
81108e74:	10bfffec 	andhi	r2,r2,65535
81108e78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81108e7c:	e0bfff17 	ldw	r2,-4(fp)
81108e80:	1080420b 	ldhu	r2,264(r2)
81108e84:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
81108e88:	e0fffe17 	ldw	r3,-8(fp)
81108e8c:	1884b03a 	or	r2,r3,r2
81108e90:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
81108e94:	e0bffe17 	ldw	r2,-8(fp)
81108e98:	10bfffcc 	andi	r2,r2,65535
81108e9c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
81108ea0:	e0bfff17 	ldw	r2,-4(fp)
81108ea4:	10800017 	ldw	r2,0(r2)
81108ea8:	e1bffe17 	ldw	r6,-8(fp)
81108eac:	01402f04 	movi	r5,188
81108eb0:	1009883a 	mov	r4,r2
81108eb4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108eb8:	e0bfff17 	ldw	r2,-4(fp)
81108ebc:	10800017 	ldw	r2,0(r2)
81108ec0:	01402f44 	movi	r5,189
81108ec4:	1009883a 	mov	r4,r2
81108ec8:	11099bc0 	call	811099bc <uliRmapReadReg>
81108ecc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
81108ed0:	e0bffe17 	ldw	r2,-8(fp)
81108ed4:	10bfffec 	andhi	r2,r2,65535
81108ed8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
81108edc:	e0bfff17 	ldw	r2,-4(fp)
81108ee0:	1080430b 	ldhu	r2,268(r2)
81108ee4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81108ee8:	e0fffe17 	ldw	r3,-8(fp)
81108eec:	1884b03a 	or	r2,r3,r2
81108ef0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81108ef4:	e0bffe17 	ldw	r2,-8(fp)
81108ef8:	10bfffcc 	andi	r2,r2,65535
81108efc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
81108f00:	e0bfff17 	ldw	r2,-4(fp)
81108f04:	10800017 	ldw	r2,0(r2)
81108f08:	e1bffe17 	ldw	r6,-8(fp)
81108f0c:	01402f44 	movi	r5,189
81108f10:	1009883a 	mov	r4,r2
81108f14:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f18:	e0bfff17 	ldw	r2,-4(fp)
81108f1c:	10800017 	ldw	r2,0(r2)
81108f20:	01402f84 	movi	r5,190
81108f24:	1009883a 	mov	r4,r2
81108f28:	11099bc0 	call	811099bc <uliRmapReadReg>
81108f2c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
81108f30:	e0bffe17 	ldw	r2,-8(fp)
81108f34:	10bfffec 	andhi	r2,r2,65535
81108f38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81108f3c:	e0bfff17 	ldw	r2,-4(fp)
81108f40:	1080440b 	ldhu	r2,272(r2)
81108f44:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81108f48:	e0fffe17 	ldw	r3,-8(fp)
81108f4c:	1884b03a 	or	r2,r3,r2
81108f50:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81108f54:	e0bffe17 	ldw	r2,-8(fp)
81108f58:	10bfffcc 	andi	r2,r2,65535
81108f5c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
81108f60:	e0bfff17 	ldw	r2,-4(fp)
81108f64:	10800017 	ldw	r2,0(r2)
81108f68:	e1bffe17 	ldw	r6,-8(fp)
81108f6c:	01402f84 	movi	r5,190
81108f70:	1009883a 	mov	r4,r2
81108f74:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108f78:	e0bfff17 	ldw	r2,-4(fp)
81108f7c:	10800017 	ldw	r2,0(r2)
81108f80:	01402fc4 	movi	r5,191
81108f84:	1009883a 	mov	r4,r2
81108f88:	11099bc0 	call	811099bc <uliRmapReadReg>
81108f8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
81108f90:	e0bffe17 	ldw	r2,-8(fp)
81108f94:	10bfffec 	andhi	r2,r2,65535
81108f98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
81108f9c:	e0bfff17 	ldw	r2,-4(fp)
81108fa0:	1080450b 	ldhu	r2,276(r2)
81108fa4:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
81108fa8:	e0fffe17 	ldw	r3,-8(fp)
81108fac:	1884b03a 	or	r2,r3,r2
81108fb0:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
81108fb4:	e0bffe17 	ldw	r2,-8(fp)
81108fb8:	10bfffcc 	andi	r2,r2,65535
81108fbc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
81108fc0:	e0bfff17 	ldw	r2,-4(fp)
81108fc4:	10800017 	ldw	r2,0(r2)
81108fc8:	e1bffe17 	ldw	r6,-8(fp)
81108fcc:	01402fc4 	movi	r5,191
81108fd0:	1009883a 	mov	r4,r2
81108fd4:	11099680 	call	81109968 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81108fd8:	00800044 	movi	r2,1
81108fdc:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108fe0:	e0bffd17 	ldw	r2,-12(fp)
}
81108fe4:	e037883a 	mov	sp,fp
81108fe8:	dfc00117 	ldw	ra,4(sp)
81108fec:	df000017 	ldw	fp,0(sp)
81108ff0:	dec00204 	addi	sp,sp,8
81108ff4:	f800283a 	ret

81108ff8 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108ff8:	defffb04 	addi	sp,sp,-20
81108ffc:	de00012e 	bgeu	sp,et,81109004 <bRmapGetRmapMemHKArea+0xc>
81109000:	003b68fa 	trap	3
81109004:	dfc00415 	stw	ra,16(sp)
81109008:	df000315 	stw	fp,12(sp)
8110900c:	df000304 	addi	fp,sp,12
81109010:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109014:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109018:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
8110901c:	e0bfff17 	ldw	r2,-4(fp)
81109020:	1001e226 	beq	r2,zero,811097ac <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109024:	e0bfff17 	ldw	r2,-4(fp)
81109028:	10800017 	ldw	r2,0(r2)
8110902c:	01402804 	movi	r5,160
81109030:	1009883a 	mov	r4,r2
81109034:	11099bc0 	call	811099bc <uliRmapReadReg>
81109038:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
8110903c:	e0bffe17 	ldw	r2,-8(fp)
81109040:	1007883a 	mov	r3,r2
81109044:	e0bfff17 	ldw	r2,-4(fp)
81109048:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
8110904c:	e0bffe17 	ldw	r2,-8(fp)
81109050:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81109054:	1007883a 	mov	r3,r2
81109058:	e0bfff17 	ldw	r2,-4(fp)
8110905c:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109060:	e0bfff17 	ldw	r2,-4(fp)
81109064:	10800017 	ldw	r2,0(r2)
81109068:	01402844 	movi	r5,161
8110906c:	1009883a 	mov	r4,r2
81109070:	11099bc0 	call	811099bc <uliRmapReadReg>
81109074:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81109078:	e0bffe17 	ldw	r2,-8(fp)
8110907c:	1007883a 	mov	r3,r2
81109080:	e0bfff17 	ldw	r2,-4(fp)
81109084:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
81109088:	e0bffe17 	ldw	r2,-8(fp)
8110908c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
81109090:	1007883a 	mov	r3,r2
81109094:	e0bfff17 	ldw	r2,-4(fp)
81109098:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110909c:	e0bfff17 	ldw	r2,-4(fp)
811090a0:	10800017 	ldw	r2,0(r2)
811090a4:	01402884 	movi	r5,162
811090a8:	1009883a 	mov	r4,r2
811090ac:	11099bc0 	call	811099bc <uliRmapReadReg>
811090b0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811090b4:	e0bffe17 	ldw	r2,-8(fp)
811090b8:	1007883a 	mov	r3,r2
811090bc:	e0bfff17 	ldw	r2,-4(fp)
811090c0:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
811090c4:	e0bffe17 	ldw	r2,-8(fp)
811090c8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
811090cc:	1007883a 	mov	r3,r2
811090d0:	e0bfff17 	ldw	r2,-4(fp)
811090d4:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811090d8:	e0bfff17 	ldw	r2,-4(fp)
811090dc:	10800017 	ldw	r2,0(r2)
811090e0:	014028c4 	movi	r5,163
811090e4:	1009883a 	mov	r4,r2
811090e8:	11099bc0 	call	811099bc <uliRmapReadReg>
811090ec:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
811090f0:	e0bffe17 	ldw	r2,-8(fp)
811090f4:	1007883a 	mov	r3,r2
811090f8:	e0bfff17 	ldw	r2,-4(fp)
811090fc:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
81109100:	e0bffe17 	ldw	r2,-8(fp)
81109104:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81109108:	1007883a 	mov	r3,r2
8110910c:	e0bfff17 	ldw	r2,-4(fp)
81109110:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109114:	e0bfff17 	ldw	r2,-4(fp)
81109118:	10800017 	ldw	r2,0(r2)
8110911c:	01402904 	movi	r5,164
81109120:	1009883a 	mov	r4,r2
81109124:	11099bc0 	call	811099bc <uliRmapReadReg>
81109128:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
8110912c:	e0bffe17 	ldw	r2,-8(fp)
81109130:	1007883a 	mov	r3,r2
81109134:	e0bfff17 	ldw	r2,-4(fp)
81109138:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
8110913c:	e0bffe17 	ldw	r2,-8(fp)
81109140:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81109144:	1007883a 	mov	r3,r2
81109148:	e0bfff17 	ldw	r2,-4(fp)
8110914c:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109150:	e0bfff17 	ldw	r2,-4(fp)
81109154:	10800017 	ldw	r2,0(r2)
81109158:	01402944 	movi	r5,165
8110915c:	1009883a 	mov	r4,r2
81109160:	11099bc0 	call	811099bc <uliRmapReadReg>
81109164:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81109168:	e0bffe17 	ldw	r2,-8(fp)
8110916c:	1007883a 	mov	r3,r2
81109170:	e0bfff17 	ldw	r2,-4(fp)
81109174:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81109178:	e0bffe17 	ldw	r2,-8(fp)
8110917c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
81109180:	1007883a 	mov	r3,r2
81109184:	e0bfff17 	ldw	r2,-4(fp)
81109188:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110918c:	e0bfff17 	ldw	r2,-4(fp)
81109190:	10800017 	ldw	r2,0(r2)
81109194:	01402984 	movi	r5,166
81109198:	1009883a 	mov	r4,r2
8110919c:	11099bc0 	call	811099bc <uliRmapReadReg>
811091a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811091a4:	e0bffe17 	ldw	r2,-8(fp)
811091a8:	1007883a 	mov	r3,r2
811091ac:	e0bfff17 	ldw	r2,-4(fp)
811091b0:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811091b4:	e0bffe17 	ldw	r2,-8(fp)
811091b8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811091bc:	1007883a 	mov	r3,r2
811091c0:	e0bfff17 	ldw	r2,-4(fp)
811091c4:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811091c8:	e0bfff17 	ldw	r2,-4(fp)
811091cc:	10800017 	ldw	r2,0(r2)
811091d0:	014029c4 	movi	r5,167
811091d4:	1009883a 	mov	r4,r2
811091d8:	11099bc0 	call	811099bc <uliRmapReadReg>
811091dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
811091e0:	e0bffe17 	ldw	r2,-8(fp)
811091e4:	1007883a 	mov	r3,r2
811091e8:	e0bfff17 	ldw	r2,-4(fp)
811091ec:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
811091f0:	e0bffe17 	ldw	r2,-8(fp)
811091f4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
811091f8:	1007883a 	mov	r3,r2
811091fc:	e0bfff17 	ldw	r2,-4(fp)
81109200:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109204:	e0bfff17 	ldw	r2,-4(fp)
81109208:	10800017 	ldw	r2,0(r2)
8110920c:	01402a04 	movi	r5,168
81109210:	1009883a 	mov	r4,r2
81109214:	11099bc0 	call	811099bc <uliRmapReadReg>
81109218:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
8110921c:	e0bffe17 	ldw	r2,-8(fp)
81109220:	1007883a 	mov	r3,r2
81109224:	e0bfff17 	ldw	r2,-4(fp)
81109228:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
8110922c:	e0bffe17 	ldw	r2,-8(fp)
81109230:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81109234:	1007883a 	mov	r3,r2
81109238:	e0bfff17 	ldw	r2,-4(fp)
8110923c:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109240:	e0bfff17 	ldw	r2,-4(fp)
81109244:	10800017 	ldw	r2,0(r2)
81109248:	01402a44 	movi	r5,169
8110924c:	1009883a 	mov	r4,r2
81109250:	11099bc0 	call	811099bc <uliRmapReadReg>
81109254:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81109258:	e0bffe17 	ldw	r2,-8(fp)
8110925c:	1007883a 	mov	r3,r2
81109260:	e0bfff17 	ldw	r2,-4(fp)
81109264:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81109268:	e0bffe17 	ldw	r2,-8(fp)
8110926c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
81109270:	1007883a 	mov	r3,r2
81109274:	e0bfff17 	ldw	r2,-4(fp)
81109278:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110927c:	e0bfff17 	ldw	r2,-4(fp)
81109280:	10800017 	ldw	r2,0(r2)
81109284:	01402a84 	movi	r5,170
81109288:	1009883a 	mov	r4,r2
8110928c:	11099bc0 	call	811099bc <uliRmapReadReg>
81109290:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
81109294:	e0bffe17 	ldw	r2,-8(fp)
81109298:	1007883a 	mov	r3,r2
8110929c:	e0bfff17 	ldw	r2,-4(fp)
811092a0:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811092a4:	e0bffe17 	ldw	r2,-8(fp)
811092a8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811092ac:	1007883a 	mov	r3,r2
811092b0:	e0bfff17 	ldw	r2,-4(fp)
811092b4:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092b8:	e0bfff17 	ldw	r2,-4(fp)
811092bc:	10800017 	ldw	r2,0(r2)
811092c0:	01402ac4 	movi	r5,171
811092c4:	1009883a 	mov	r4,r2
811092c8:	11099bc0 	call	811099bc <uliRmapReadReg>
811092cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
811092d0:	e0bffe17 	ldw	r2,-8(fp)
811092d4:	1007883a 	mov	r3,r2
811092d8:	e0bfff17 	ldw	r2,-4(fp)
811092dc:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
811092e0:	e0bffe17 	ldw	r2,-8(fp)
811092e4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
811092e8:	1007883a 	mov	r3,r2
811092ec:	e0bfff17 	ldw	r2,-4(fp)
811092f0:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811092f4:	e0bfff17 	ldw	r2,-4(fp)
811092f8:	10800017 	ldw	r2,0(r2)
811092fc:	01402b04 	movi	r5,172
81109300:	1009883a 	mov	r4,r2
81109304:	11099bc0 	call	811099bc <uliRmapReadReg>
81109308:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
8110930c:	e0bffe17 	ldw	r2,-8(fp)
81109310:	1007883a 	mov	r3,r2
81109314:	e0bfff17 	ldw	r2,-4(fp)
81109318:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
8110931c:	e0bffe17 	ldw	r2,-8(fp)
81109320:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81109324:	1007883a 	mov	r3,r2
81109328:	e0bfff17 	ldw	r2,-4(fp)
8110932c:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109330:	e0bfff17 	ldw	r2,-4(fp)
81109334:	10800017 	ldw	r2,0(r2)
81109338:	01402b44 	movi	r5,173
8110933c:	1009883a 	mov	r4,r2
81109340:	11099bc0 	call	811099bc <uliRmapReadReg>
81109344:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81109348:	e0bffe17 	ldw	r2,-8(fp)
8110934c:	1007883a 	mov	r3,r2
81109350:	e0bfff17 	ldw	r2,-4(fp)
81109354:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81109358:	e0bffe17 	ldw	r2,-8(fp)
8110935c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
81109360:	1007883a 	mov	r3,r2
81109364:	e0bfff17 	ldw	r2,-4(fp)
81109368:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110936c:	e0bfff17 	ldw	r2,-4(fp)
81109370:	10800017 	ldw	r2,0(r2)
81109374:	01402b84 	movi	r5,174
81109378:	1009883a 	mov	r4,r2
8110937c:	11099bc0 	call	811099bc <uliRmapReadReg>
81109380:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
81109384:	e0bffe17 	ldw	r2,-8(fp)
81109388:	1007883a 	mov	r3,r2
8110938c:	e0bfff17 	ldw	r2,-4(fp)
81109390:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
81109394:	e0bffe17 	ldw	r2,-8(fp)
81109398:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
8110939c:	1007883a 	mov	r3,r2
811093a0:	e0bfff17 	ldw	r2,-4(fp)
811093a4:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093a8:	e0bfff17 	ldw	r2,-4(fp)
811093ac:	10800017 	ldw	r2,0(r2)
811093b0:	01402bc4 	movi	r5,175
811093b4:	1009883a 	mov	r4,r2
811093b8:	11099bc0 	call	811099bc <uliRmapReadReg>
811093bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
811093c0:	e0bffe17 	ldw	r2,-8(fp)
811093c4:	1007883a 	mov	r3,r2
811093c8:	e0bfff17 	ldw	r2,-4(fp)
811093cc:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
811093d0:	e0bffe17 	ldw	r2,-8(fp)
811093d4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
811093d8:	1007883a 	mov	r3,r2
811093dc:	e0bfff17 	ldw	r2,-4(fp)
811093e0:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811093e4:	e0bfff17 	ldw	r2,-4(fp)
811093e8:	10800017 	ldw	r2,0(r2)
811093ec:	01402c04 	movi	r5,176
811093f0:	1009883a 	mov	r4,r2
811093f4:	11099bc0 	call	811099bc <uliRmapReadReg>
811093f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
811093fc:	e0bffe17 	ldw	r2,-8(fp)
81109400:	1007883a 	mov	r3,r2
81109404:	e0bfff17 	ldw	r2,-4(fp)
81109408:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
8110940c:	e0bffe17 	ldw	r2,-8(fp)
81109410:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81109414:	1007883a 	mov	r3,r2
81109418:	e0bfff17 	ldw	r2,-4(fp)
8110941c:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109420:	e0bfff17 	ldw	r2,-4(fp)
81109424:	10800017 	ldw	r2,0(r2)
81109428:	01402c44 	movi	r5,177
8110942c:	1009883a 	mov	r4,r2
81109430:	11099bc0 	call	811099bc <uliRmapReadReg>
81109434:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81109438:	e0bffe17 	ldw	r2,-8(fp)
8110943c:	1007883a 	mov	r3,r2
81109440:	e0bfff17 	ldw	r2,-4(fp)
81109444:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81109448:	e0bffe17 	ldw	r2,-8(fp)
8110944c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
81109450:	1007883a 	mov	r3,r2
81109454:	e0bfff17 	ldw	r2,-4(fp)
81109458:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110945c:	e0bfff17 	ldw	r2,-4(fp)
81109460:	10800017 	ldw	r2,0(r2)
81109464:	01402c84 	movi	r5,178
81109468:	1009883a 	mov	r4,r2
8110946c:	11099bc0 	call	811099bc <uliRmapReadReg>
81109470:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81109474:	e0bffe17 	ldw	r2,-8(fp)
81109478:	1007883a 	mov	r3,r2
8110947c:	e0bfff17 	ldw	r2,-4(fp)
81109480:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
81109484:	e0bffe17 	ldw	r2,-8(fp)
81109488:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
8110948c:	1007883a 	mov	r3,r2
81109490:	e0bfff17 	ldw	r2,-4(fp)
81109494:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109498:	e0bfff17 	ldw	r2,-4(fp)
8110949c:	10800017 	ldw	r2,0(r2)
811094a0:	01402cc4 	movi	r5,179
811094a4:	1009883a 	mov	r4,r2
811094a8:	11099bc0 	call	811099bc <uliRmapReadReg>
811094ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
811094b0:	e0bffe17 	ldw	r2,-8(fp)
811094b4:	1007883a 	mov	r3,r2
811094b8:	e0bfff17 	ldw	r2,-4(fp)
811094bc:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
811094c0:	e0bffe17 	ldw	r2,-8(fp)
811094c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
811094c8:	1007883a 	mov	r3,r2
811094cc:	e0bfff17 	ldw	r2,-4(fp)
811094d0:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811094d4:	e0bfff17 	ldw	r2,-4(fp)
811094d8:	10800017 	ldw	r2,0(r2)
811094dc:	01402d04 	movi	r5,180
811094e0:	1009883a 	mov	r4,r2
811094e4:	11099bc0 	call	811099bc <uliRmapReadReg>
811094e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
811094ec:	e0bffe17 	ldw	r2,-8(fp)
811094f0:	1007883a 	mov	r3,r2
811094f4:	e0bfff17 	ldw	r2,-4(fp)
811094f8:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
811094fc:	e0bffe17 	ldw	r2,-8(fp)
81109500:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81109504:	1007883a 	mov	r3,r2
81109508:	e0bfff17 	ldw	r2,-4(fp)
8110950c:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109510:	e0bfff17 	ldw	r2,-4(fp)
81109514:	10800017 	ldw	r2,0(r2)
81109518:	01402d44 	movi	r5,181
8110951c:	1009883a 	mov	r4,r2
81109520:	11099bc0 	call	811099bc <uliRmapReadReg>
81109524:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81109528:	e0bffe17 	ldw	r2,-8(fp)
8110952c:	1007883a 	mov	r3,r2
81109530:	e0bfff17 	ldw	r2,-4(fp)
81109534:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81109538:	e0bffe17 	ldw	r2,-8(fp)
8110953c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81109540:	1007883a 	mov	r3,r2
81109544:	e0bfff17 	ldw	r2,-4(fp)
81109548:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110954c:	e0bfff17 	ldw	r2,-4(fp)
81109550:	10800017 	ldw	r2,0(r2)
81109554:	01402d84 	movi	r5,182
81109558:	1009883a 	mov	r4,r2
8110955c:	11099bc0 	call	811099bc <uliRmapReadReg>
81109560:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81109564:	e0bffe17 	ldw	r2,-8(fp)
81109568:	1007883a 	mov	r3,r2
8110956c:	e0bfff17 	ldw	r2,-4(fp)
81109570:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81109574:	e0bffe17 	ldw	r2,-8(fp)
81109578:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
8110957c:	1007883a 	mov	r3,r2
81109580:	e0bfff17 	ldw	r2,-4(fp)
81109584:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109588:	e0bfff17 	ldw	r2,-4(fp)
8110958c:	10800017 	ldw	r2,0(r2)
81109590:	01402dc4 	movi	r5,183
81109594:	1009883a 	mov	r4,r2
81109598:	11099bc0 	call	811099bc <uliRmapReadReg>
8110959c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
811095a0:	e0bffe17 	ldw	r2,-8(fp)
811095a4:	1007883a 	mov	r3,r2
811095a8:	e0bfff17 	ldw	r2,-4(fp)
811095ac:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
811095b0:	e0bffe17 	ldw	r2,-8(fp)
811095b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
811095b8:	1007883a 	mov	r3,r2
811095bc:	e0bfff17 	ldw	r2,-4(fp)
811095c0:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811095c4:	e0bfff17 	ldw	r2,-4(fp)
811095c8:	10800017 	ldw	r2,0(r2)
811095cc:	01402e04 	movi	r5,184
811095d0:	1009883a 	mov	r4,r2
811095d4:	11099bc0 	call	811099bc <uliRmapReadReg>
811095d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
811095dc:	e0bffe17 	ldw	r2,-8(fp)
811095e0:	1007883a 	mov	r3,r2
811095e4:	e0bfff17 	ldw	r2,-4(fp)
811095e8:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
811095ec:	e0bffe17 	ldw	r2,-8(fp)
811095f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
811095f4:	1007883a 	mov	r3,r2
811095f8:	e0bfff17 	ldw	r2,-4(fp)
811095fc:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109600:	e0bfff17 	ldw	r2,-4(fp)
81109604:	10800017 	ldw	r2,0(r2)
81109608:	01402e44 	movi	r5,185
8110960c:	1009883a 	mov	r4,r2
81109610:	11099bc0 	call	811099bc <uliRmapReadReg>
81109614:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81109618:	e0bffe17 	ldw	r2,-8(fp)
8110961c:	1007883a 	mov	r3,r2
81109620:	e0bfff17 	ldw	r2,-4(fp)
81109624:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81109628:	e0bffe17 	ldw	r2,-8(fp)
8110962c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81109630:	1007883a 	mov	r3,r2
81109634:	e0bfff17 	ldw	r2,-4(fp)
81109638:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110963c:	e0bfff17 	ldw	r2,-4(fp)
81109640:	10800017 	ldw	r2,0(r2)
81109644:	01402e84 	movi	r5,186
81109648:	1009883a 	mov	r4,r2
8110964c:	11099bc0 	call	811099bc <uliRmapReadReg>
81109650:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81109654:	e0bffe17 	ldw	r2,-8(fp)
81109658:	1007883a 	mov	r3,r2
8110965c:	e0bfff17 	ldw	r2,-4(fp)
81109660:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81109664:	e0bffe17 	ldw	r2,-8(fp)
81109668:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
8110966c:	1007883a 	mov	r3,r2
81109670:	e0bfff17 	ldw	r2,-4(fp)
81109674:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109678:	e0bfff17 	ldw	r2,-4(fp)
8110967c:	10800017 	ldw	r2,0(r2)
81109680:	01402ec4 	movi	r5,187
81109684:	1009883a 	mov	r4,r2
81109688:	11099bc0 	call	811099bc <uliRmapReadReg>
8110968c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81109690:	e0bffe17 	ldw	r2,-8(fp)
81109694:	1007883a 	mov	r3,r2
81109698:	e0bfff17 	ldw	r2,-4(fp)
8110969c:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
811096a0:	e0bffe17 	ldw	r2,-8(fp)
811096a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
811096a8:	1007883a 	mov	r3,r2
811096ac:	e0bfff17 	ldw	r2,-4(fp)
811096b0:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096b4:	e0bfff17 	ldw	r2,-4(fp)
811096b8:	10800017 	ldw	r2,0(r2)
811096bc:	01402f04 	movi	r5,188
811096c0:	1009883a 	mov	r4,r2
811096c4:	11099bc0 	call	811099bc <uliRmapReadReg>
811096c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
811096cc:	e0bffe17 	ldw	r2,-8(fp)
811096d0:	1007883a 	mov	r3,r2
811096d4:	e0bfff17 	ldw	r2,-4(fp)
811096d8:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
811096dc:	e0bffe17 	ldw	r2,-8(fp)
811096e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
811096e4:	1007883a 	mov	r3,r2
811096e8:	e0bfff17 	ldw	r2,-4(fp)
811096ec:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811096f0:	e0bfff17 	ldw	r2,-4(fp)
811096f4:	10800017 	ldw	r2,0(r2)
811096f8:	01402f44 	movi	r5,189
811096fc:	1009883a 	mov	r4,r2
81109700:	11099bc0 	call	811099bc <uliRmapReadReg>
81109704:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81109708:	e0bffe17 	ldw	r2,-8(fp)
8110970c:	1007883a 	mov	r3,r2
81109710:	e0bfff17 	ldw	r2,-4(fp)
81109714:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81109718:	e0bffe17 	ldw	r2,-8(fp)
8110971c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81109720:	1007883a 	mov	r3,r2
81109724:	e0bfff17 	ldw	r2,-4(fp)
81109728:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110972c:	e0bfff17 	ldw	r2,-4(fp)
81109730:	10800017 	ldw	r2,0(r2)
81109734:	01402f84 	movi	r5,190
81109738:	1009883a 	mov	r4,r2
8110973c:	11099bc0 	call	811099bc <uliRmapReadReg>
81109740:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81109744:	e0bffe17 	ldw	r2,-8(fp)
81109748:	1007883a 	mov	r3,r2
8110974c:	e0bfff17 	ldw	r2,-4(fp)
81109750:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81109754:	e0bffe17 	ldw	r2,-8(fp)
81109758:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
8110975c:	1007883a 	mov	r3,r2
81109760:	e0bfff17 	ldw	r2,-4(fp)
81109764:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81109768:	e0bfff17 	ldw	r2,-4(fp)
8110976c:	10800017 	ldw	r2,0(r2)
81109770:	01402fc4 	movi	r5,191
81109774:	1009883a 	mov	r4,r2
81109778:	11099bc0 	call	811099bc <uliRmapReadReg>
8110977c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81109780:	e0bffe17 	ldw	r2,-8(fp)
81109784:	1007883a 	mov	r3,r2
81109788:	e0bfff17 	ldw	r2,-4(fp)
8110978c:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81109790:	e0bffe17 	ldw	r2,-8(fp)
81109794:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81109798:	1007883a 	mov	r3,r2
8110979c:	e0bfff17 	ldw	r2,-4(fp)
811097a0:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
811097a4:	00800044 	movi	r2,1
811097a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811097ac:	e0bffd17 	ldw	r2,-12(fp)
}
811097b0:	e037883a 	mov	sp,fp
811097b4:	dfc00117 	ldw	ra,4(sp)
811097b8:	df000017 	ldw	fp,0(sp)
811097bc:	dec00204 	addi	sp,sp,8
811097c0:	f800283a 	ret

811097c4 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
811097c4:	defffb04 	addi	sp,sp,-20
811097c8:	de00012e 	bgeu	sp,et,811097d0 <bRmapInitCh+0xc>
811097cc:	003b68fa 	trap	3
811097d0:	dfc00415 	stw	ra,16(sp)
811097d4:	df000315 	stw	fp,12(sp)
811097d8:	df000304 	addi	fp,sp,12
811097dc:	e13ffe15 	stw	r4,-8(fp)
811097e0:	2805883a 	mov	r2,r5
811097e4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811097e8:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
811097ec:	e0bffe17 	ldw	r2,-8(fp)
811097f0:	10005726 	beq	r2,zero,81109950 <bRmapInitCh+0x18c>
		bStatus = TRUE;
811097f4:	00800044 	movi	r2,1
811097f8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811097fc:	e0bfff03 	ldbu	r2,-4(fp)
81109800:	10c00228 	cmpgeui	r3,r2,8
81109804:	1800361e 	bne	r3,zero,811098e0 <bRmapInitCh+0x11c>
81109808:	100690ba 	slli	r3,r2,2
8110980c:	00a04474 	movhi	r2,33041
81109810:	10a60804 	addi	r2,r2,-26592
81109814:	1885883a 	add	r2,r3,r2
81109818:	10800017 	ldw	r2,0(r2)
8110981c:	1000683a 	jmp	r2
81109820:	81109840 	call	88110984 <__reset+0x20f0984>
81109824:	81109854 	ori	r4,r16,16993
81109828:	81109868 	cmpgeui	r4,r16,16993
8110982c:	8110987c 	xorhi	r4,r16,16993
81109830:	81109890 	cmplti	r4,r16,16994
81109834:	811098a4 	muli	r4,r16,16994
81109838:	811098b8 	rdprs	r4,r16,16994
8110983c:	811098cc 	andi	r4,r16,16995
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109840:	e0fffe17 	ldw	r3,-8(fp)
81109844:	00a04834 	movhi	r2,33056
81109848:	108b0004 	addi	r2,r2,11264
8110984c:	18800015 	stw	r2,0(r3)
			break;
81109850:	00002506 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109854:	e0fffe17 	ldw	r3,-8(fp)
81109858:	00a04834 	movhi	r2,33056
8110985c:	108a0004 	addi	r2,r2,10240
81109860:	18800015 	stw	r2,0(r3)
			break;
81109864:	00002006 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109868:	e0fffe17 	ldw	r3,-8(fp)
8110986c:	00a04834 	movhi	r2,33056
81109870:	108b0004 	addi	r2,r2,11264
81109874:	18800015 	stw	r2,0(r3)
			break;
81109878:	00001b06 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110987c:	e0fffe17 	ldw	r3,-8(fp)
81109880:	00a04834 	movhi	r2,33056
81109884:	108a0004 	addi	r2,r2,10240
81109888:	18800015 	stw	r2,0(r3)
			break;
8110988c:	00001606 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109890:	e0fffe17 	ldw	r3,-8(fp)
81109894:	00a04834 	movhi	r2,33056
81109898:	108b0004 	addi	r2,r2,11264
8110989c:	18800015 	stw	r2,0(r3)
			break;
811098a0:	00001106 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
811098a4:	e0fffe17 	ldw	r3,-8(fp)
811098a8:	00a04834 	movhi	r2,33056
811098ac:	108a0004 	addi	r2,r2,10240
811098b0:	18800015 	stw	r2,0(r3)
			break;
811098b4:	00000c06 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
811098b8:	e0fffe17 	ldw	r3,-8(fp)
811098bc:	00a04834 	movhi	r2,33056
811098c0:	108b0004 	addi	r2,r2,11264
811098c4:	18800015 	stw	r2,0(r3)
			break;
811098c8:	00000706 	br	811098e8 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
811098cc:	e0fffe17 	ldw	r3,-8(fp)
811098d0:	00a04834 	movhi	r2,33056
811098d4:	108a0004 	addi	r2,r2,10240
811098d8:	18800015 	stw	r2,0(r3)
			break;
811098dc:	00000206 	br	811098e8 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
811098e0:	e03ffd15 	stw	zero,-12(fp)
			break;
811098e4:	0001883a 	nop
		}

		if (bStatus) {
811098e8:	e0bffd17 	ldw	r2,-12(fp)
811098ec:	10001826 	beq	r2,zero,81109950 <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
811098f0:	e13ffe17 	ldw	r4,-8(fp)
811098f4:	11078240 	call	81107824 <bRmapGetIrqControl>
811098f8:	1000011e 	bne	r2,zero,81109900 <bRmapInitCh+0x13c>
				bStatus = FALSE;
811098fc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81109900:	e13ffe17 	ldw	r4,-8(fp)
81109904:	1107a0c0 	call	81107a0c <bRmapGetCodecConfig>
81109908:	1000011e 	bne	r2,zero,81109910 <bRmapInitCh+0x14c>
				bStatus = FALSE;
8110990c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81109910:	e13ffe17 	ldw	r4,-8(fp)
81109914:	1107a980 	call	81107a98 <bRmapGetCodecStatus>
81109918:	1000011e 	bne	r2,zero,81109920 <bRmapInitCh+0x15c>
				bStatus = FALSE;
8110991c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81109920:	e13ffe17 	ldw	r4,-8(fp)
81109924:	11080440 	call	81108044 <bRmapGetMemConfigArea>
81109928:	1000011e 	bne	r2,zero,81109930 <bRmapInitCh+0x16c>
				bStatus = FALSE;
8110992c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81109930:	e13ffe17 	ldw	r4,-8(fp)
81109934:	11083180 	call	81108318 <bRmapGetMemConfigStat>
81109938:	1000011e 	bne	r2,zero,81109940 <bRmapInitCh+0x17c>
				bStatus = FALSE;
8110993c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81109940:	e13ffe17 	ldw	r4,-8(fp)
81109944:	1108ff80 	call	81108ff8 <bRmapGetRmapMemHKArea>
81109948:	1000011e 	bne	r2,zero,81109950 <bRmapInitCh+0x18c>
				bStatus = FALSE;
8110994c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81109950:	e0bffd17 	ldw	r2,-12(fp)
}
81109954:	e037883a 	mov	sp,fp
81109958:	dfc00117 	ldw	ra,4(sp)
8110995c:	df000017 	ldw	fp,0(sp)
81109960:	dec00204 	addi	sp,sp,8
81109964:	f800283a 	ret

81109968 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109968:	defffc04 	addi	sp,sp,-16
8110996c:	de00012e 	bgeu	sp,et,81109974 <vRmapWriteReg+0xc>
81109970:	003b68fa 	trap	3
81109974:	df000315 	stw	fp,12(sp)
81109978:	df000304 	addi	fp,sp,12
8110997c:	e13ffd15 	stw	r4,-12(fp)
81109980:	e17ffe15 	stw	r5,-8(fp)
81109984:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109988:	e0bffe17 	ldw	r2,-8(fp)
8110998c:	1085883a 	add	r2,r2,r2
81109990:	1085883a 	add	r2,r2,r2
81109994:	1007883a 	mov	r3,r2
81109998:	e0bffd17 	ldw	r2,-12(fp)
8110999c:	10c5883a 	add	r2,r2,r3
811099a0:	e0ffff17 	ldw	r3,-4(fp)
811099a4:	10c00015 	stw	r3,0(r2)
}
811099a8:	0001883a 	nop
811099ac:	e037883a 	mov	sp,fp
811099b0:	df000017 	ldw	fp,0(sp)
811099b4:	dec00104 	addi	sp,sp,4
811099b8:	f800283a 	ret

811099bc <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
811099bc:	defffc04 	addi	sp,sp,-16
811099c0:	de00012e 	bgeu	sp,et,811099c8 <uliRmapReadReg+0xc>
811099c4:	003b68fa 	trap	3
811099c8:	df000315 	stw	fp,12(sp)
811099cc:	df000304 	addi	fp,sp,12
811099d0:	e13ffe15 	stw	r4,-8(fp)
811099d4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
811099d8:	e0bfff17 	ldw	r2,-4(fp)
811099dc:	1085883a 	add	r2,r2,r2
811099e0:	1085883a 	add	r2,r2,r2
811099e4:	1007883a 	mov	r3,r2
811099e8:	e0bffe17 	ldw	r2,-8(fp)
811099ec:	10c5883a 	add	r2,r2,r3
811099f0:	10800017 	ldw	r2,0(r2)
811099f4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
811099f8:	e0bffd17 	ldw	r2,-12(fp)
}
811099fc:	e037883a 	mov	sp,fp
81109a00:	df000017 	ldw	fp,0(sp)
81109a04:	dec00104 	addi	sp,sp,4
81109a08:	f800283a 	ret

81109a0c <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81109a0c:	defffd04 	addi	sp,sp,-12
81109a10:	de00012e 	bgeu	sp,et,81109a18 <uliConvRmapCfgAddr+0xc>
81109a14:	003b68fa 	trap	3
81109a18:	df000215 	stw	fp,8(sp)
81109a1c:	df000204 	addi	fp,sp,8
81109a20:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81109a24:	e0bfff17 	ldw	r2,-4(fp)
81109a28:	10801368 	cmpgeui	r2,r2,77
81109a2c:	10008a1e 	bne	r2,zero,81109c58 <uliConvRmapCfgAddr+0x24c>
81109a30:	e0bfff17 	ldw	r2,-4(fp)
81109a34:	100690ba 	slli	r3,r2,2
81109a38:	00a04474 	movhi	r2,33041
81109a3c:	10a69304 	addi	r2,r2,-26036
81109a40:	1885883a 	add	r2,r3,r2
81109a44:	10800017 	ldw	r2,0(r2)
81109a48:	1000683a 	jmp	r2
81109a4c:	81109b80 	call	881109b8 <__reset+0x20f09b8>
81109a50:	81109c58 	cmpnei	r4,r16,17009
81109a54:	81109c58 	cmpnei	r4,r16,17009
81109a58:	81109c58 	cmpnei	r4,r16,17009
81109a5c:	81109b8c 	andi	r4,r16,17006
81109a60:	81109c58 	cmpnei	r4,r16,17009
81109a64:	81109c58 	cmpnei	r4,r16,17009
81109a68:	81109c58 	cmpnei	r4,r16,17009
81109a6c:	81109b98 	cmpnei	r4,r16,17006
81109a70:	81109c58 	cmpnei	r4,r16,17009
81109a74:	81109c58 	cmpnei	r4,r16,17009
81109a78:	81109c58 	cmpnei	r4,r16,17009
81109a7c:	81109ba4 	muli	r4,r16,17006
81109a80:	81109c58 	cmpnei	r4,r16,17009
81109a84:	81109c58 	cmpnei	r4,r16,17009
81109a88:	81109c58 	cmpnei	r4,r16,17009
81109a8c:	81109bb0 	cmpltui	r4,r16,17006
81109a90:	81109c58 	cmpnei	r4,r16,17009
81109a94:	81109c58 	cmpnei	r4,r16,17009
81109a98:	81109c58 	cmpnei	r4,r16,17009
81109a9c:	81109bbc 	xorhi	r4,r16,17006
81109aa0:	81109c58 	cmpnei	r4,r16,17009
81109aa4:	81109c58 	cmpnei	r4,r16,17009
81109aa8:	81109c58 	cmpnei	r4,r16,17009
81109aac:	81109bc8 	cmpgei	r4,r16,17007
81109ab0:	81109c58 	cmpnei	r4,r16,17009
81109ab4:	81109c58 	cmpnei	r4,r16,17009
81109ab8:	81109c58 	cmpnei	r4,r16,17009
81109abc:	81109bd4 	ori	r4,r16,17007
81109ac0:	81109c58 	cmpnei	r4,r16,17009
81109ac4:	81109c58 	cmpnei	r4,r16,17009
81109ac8:	81109c58 	cmpnei	r4,r16,17009
81109acc:	81109be0 	cmpeqi	r4,r16,17007
81109ad0:	81109c58 	cmpnei	r4,r16,17009
81109ad4:	81109c58 	cmpnei	r4,r16,17009
81109ad8:	81109c58 	cmpnei	r4,r16,17009
81109adc:	81109bec 	andhi	r4,r16,17007
81109ae0:	81109c58 	cmpnei	r4,r16,17009
81109ae4:	81109c58 	cmpnei	r4,r16,17009
81109ae8:	81109c58 	cmpnei	r4,r16,17009
81109aec:	81109bf8 	rdprs	r4,r16,17007
81109af0:	81109c58 	cmpnei	r4,r16,17009
81109af4:	81109c58 	cmpnei	r4,r16,17009
81109af8:	81109c58 	cmpnei	r4,r16,17009
81109afc:	81109c04 	addi	r4,r16,17008
81109b00:	81109c58 	cmpnei	r4,r16,17009
81109b04:	81109c58 	cmpnei	r4,r16,17009
81109b08:	81109c58 	cmpnei	r4,r16,17009
81109b0c:	81109c58 	cmpnei	r4,r16,17009
81109b10:	81109c58 	cmpnei	r4,r16,17009
81109b14:	81109c58 	cmpnei	r4,r16,17009
81109b18:	81109c58 	cmpnei	r4,r16,17009
81109b1c:	81109c58 	cmpnei	r4,r16,17009
81109b20:	81109c58 	cmpnei	r4,r16,17009
81109b24:	81109c58 	cmpnei	r4,r16,17009
81109b28:	81109c58 	cmpnei	r4,r16,17009
81109b2c:	81109c10 	cmplti	r4,r16,17008
81109b30:	81109c58 	cmpnei	r4,r16,17009
81109b34:	81109c58 	cmpnei	r4,r16,17009
81109b38:	81109c58 	cmpnei	r4,r16,17009
81109b3c:	81109c1c 	xori	r4,r16,17008
81109b40:	81109c58 	cmpnei	r4,r16,17009
81109b44:	81109c58 	cmpnei	r4,r16,17009
81109b48:	81109c58 	cmpnei	r4,r16,17009
81109b4c:	81109c28 	cmpgeui	r4,r16,17008
81109b50:	81109c58 	cmpnei	r4,r16,17009
81109b54:	81109c58 	cmpnei	r4,r16,17009
81109b58:	81109c58 	cmpnei	r4,r16,17009
81109b5c:	81109c34 	orhi	r4,r16,17008
81109b60:	81109c58 	cmpnei	r4,r16,17009
81109b64:	81109c58 	cmpnei	r4,r16,17009
81109b68:	81109c58 	cmpnei	r4,r16,17009
81109b6c:	81109c40 	call	881109c4 <__reset+0x20f09c4>
81109b70:	81109c58 	cmpnei	r4,r16,17009
81109b74:	81109c58 	cmpnei	r4,r16,17009
81109b78:	81109c58 	cmpnei	r4,r16,17009
81109b7c:	81109c4c 	andi	r4,r16,17009
	case 0x00000000:
		uliValue = 0x00000040;
81109b80:	00801004 	movi	r2,64
81109b84:	e0bffe15 	stw	r2,-8(fp)
		break;
81109b88:	00003506 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
81109b8c:	00801044 	movi	r2,65
81109b90:	e0bffe15 	stw	r2,-8(fp)
		break;
81109b94:	00003206 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
81109b98:	00801084 	movi	r2,66
81109b9c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109ba0:	00002f06 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
81109ba4:	008010c4 	movi	r2,67
81109ba8:	e0bffe15 	stw	r2,-8(fp)
		break;
81109bac:	00002c06 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
81109bb0:	00801104 	movi	r2,68
81109bb4:	e0bffe15 	stw	r2,-8(fp)
		break;
81109bb8:	00002906 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
81109bbc:	00801144 	movi	r2,69
81109bc0:	e0bffe15 	stw	r2,-8(fp)
		break;
81109bc4:	00002606 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
81109bc8:	00801184 	movi	r2,70
81109bcc:	e0bffe15 	stw	r2,-8(fp)
		break;
81109bd0:	00002306 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
81109bd4:	008011c4 	movi	r2,71
81109bd8:	e0bffe15 	stw	r2,-8(fp)
		break;
81109bdc:	00002006 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
81109be0:	00801204 	movi	r2,72
81109be4:	e0bffe15 	stw	r2,-8(fp)
		break;
81109be8:	00001d06 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81109bec:	00801244 	movi	r2,73
81109bf0:	e0bffe15 	stw	r2,-8(fp)
		break;
81109bf4:	00001a06 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
81109bf8:	00801284 	movi	r2,74
81109bfc:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c00:	00001706 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
81109c04:	008012c4 	movi	r2,75
81109c08:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c0c:	00001406 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
81109c10:	00801304 	movi	r2,76
81109c14:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c18:	00001106 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
81109c1c:	00801344 	movi	r2,77
81109c20:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c24:	00000e06 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
81109c28:	00801384 	movi	r2,78
81109c2c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c30:	00000b06 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
81109c34:	008013c4 	movi	r2,79
81109c38:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c3c:	00000806 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
81109c40:	00801404 	movi	r2,80
81109c44:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c48:	00000506 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
81109c4c:	00801444 	movi	r2,81
81109c50:	e0bffe15 	stw	r2,-8(fp)
		break;
81109c54:	00000206 	br	81109c60 <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81109c58:	e03ffe15 	stw	zero,-8(fp)
		break;
81109c5c:	0001883a 	nop
	}

	return uliValue;
81109c60:	e0bffe17 	ldw	r2,-8(fp)
}
81109c64:	e037883a 	mov	sp,fp
81109c68:	df000017 	ldw	fp,0(sp)
81109c6c:	dec00104 	addi	sp,sp,4
81109c70:	f800283a 	ret

81109c74 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81109c74:	defffb04 	addi	sp,sp,-20
81109c78:	de00012e 	bgeu	sp,et,81109c80 <bSpwcSetLink+0xc>
81109c7c:	003b68fa 	trap	3
81109c80:	dfc00415 	stw	ra,16(sp)
81109c84:	df000315 	stw	fp,12(sp)
81109c88:	df000304 	addi	fp,sp,12
81109c8c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109c90:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109c94:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109c98:	e0bfff17 	ldw	r2,-4(fp)
81109c9c:	10003c26 	beq	r2,zero,81109d90 <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109ca0:	e0bfff17 	ldw	r2,-4(fp)
81109ca4:	10800017 	ldw	r2,0(r2)
81109ca8:	000b883a 	mov	r5,zero
81109cac:	1009883a 	mov	r4,r2
81109cb0:	110a3400 	call	8110a340 <uliSpwcReadReg>
81109cb4:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
81109cb8:	e0bfff17 	ldw	r2,-4(fp)
81109cbc:	10800117 	ldw	r2,4(r2)
81109cc0:	10000426 	beq	r2,zero,81109cd4 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
81109cc4:	e0bffe17 	ldw	r2,-8(fp)
81109cc8:	10800114 	ori	r2,r2,4
81109ccc:	e0bffe15 	stw	r2,-8(fp)
81109cd0:	00000406 	br	81109ce4 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
81109cd4:	e0fffe17 	ldw	r3,-8(fp)
81109cd8:	00bffec4 	movi	r2,-5
81109cdc:	1884703a 	and	r2,r3,r2
81109ce0:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
81109ce4:	e0bfff17 	ldw	r2,-4(fp)
81109ce8:	10800217 	ldw	r2,8(r2)
81109cec:	10000426 	beq	r2,zero,81109d00 <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
81109cf0:	e0bffe17 	ldw	r2,-8(fp)
81109cf4:	10800094 	ori	r2,r2,2
81109cf8:	e0bffe15 	stw	r2,-8(fp)
81109cfc:	00000406 	br	81109d10 <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
81109d00:	e0fffe17 	ldw	r3,-8(fp)
81109d04:	00bfff44 	movi	r2,-3
81109d08:	1884703a 	and	r2,r3,r2
81109d0c:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
81109d10:	e0bfff17 	ldw	r2,-4(fp)
81109d14:	10800317 	ldw	r2,12(r2)
81109d18:	10000426 	beq	r2,zero,81109d2c <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
81109d1c:	e0bffe17 	ldw	r2,-8(fp)
81109d20:	10800054 	ori	r2,r2,1
81109d24:	e0bffe15 	stw	r2,-8(fp)
81109d28:	00000406 	br	81109d3c <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
81109d2c:	e0fffe17 	ldw	r3,-8(fp)
81109d30:	00bfff84 	movi	r2,-2
81109d34:	1884703a 	and	r2,r3,r2
81109d38:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
81109d3c:	e0fffe17 	ldw	r3,-8(fp)
81109d40:	00804034 	movhi	r2,256
81109d44:	10bfffc4 	addi	r2,r2,-1
81109d48:	1884703a 	and	r2,r3,r2
81109d4c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
81109d50:	e0bfff17 	ldw	r2,-4(fp)
81109d54:	10800403 	ldbu	r2,16(r2)
81109d58:	10803fcc 	andi	r2,r2,255
81109d5c:	1004963a 	slli	r2,r2,24
81109d60:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81109d64:	e0bffe17 	ldw	r2,-8(fp)
81109d68:	10c4b03a 	or	r2,r2,r3
81109d6c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
81109d70:	e0bfff17 	ldw	r2,-4(fp)
81109d74:	10800017 	ldw	r2,0(r2)
81109d78:	e1bffe17 	ldw	r6,-8(fp)
81109d7c:	000b883a 	mov	r5,zero
81109d80:	1009883a 	mov	r4,r2
81109d84:	110a2ec0 	call	8110a2ec <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
81109d88:	00800044 	movi	r2,1
81109d8c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109d90:	e0bffd17 	ldw	r2,-12(fp)
}
81109d94:	e037883a 	mov	sp,fp
81109d98:	dfc00117 	ldw	ra,4(sp)
81109d9c:	df000017 	ldw	fp,0(sp)
81109da0:	dec00204 	addi	sp,sp,8
81109da4:	f800283a 	ret

81109da8 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
81109da8:	defffb04 	addi	sp,sp,-20
81109dac:	de00012e 	bgeu	sp,et,81109db4 <bSpwcGetLink+0xc>
81109db0:	003b68fa 	trap	3
81109db4:	dfc00415 	stw	ra,16(sp)
81109db8:	df000315 	stw	fp,12(sp)
81109dbc:	df000304 	addi	fp,sp,12
81109dc0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109dc4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109dc8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109dcc:	e0bfff17 	ldw	r2,-4(fp)
81109dd0:	10002826 	beq	r2,zero,81109e74 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109dd4:	e0bfff17 	ldw	r2,-4(fp)
81109dd8:	10800017 	ldw	r2,0(r2)
81109ddc:	000b883a 	mov	r5,zero
81109de0:	1009883a 	mov	r4,r2
81109de4:	110a3400 	call	8110a340 <uliSpwcReadReg>
81109de8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
81109dec:	e0bffe17 	ldw	r2,-8(fp)
81109df0:	1080010c 	andi	r2,r2,4
81109df4:	10000426 	beq	r2,zero,81109e08 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
81109df8:	e0bfff17 	ldw	r2,-4(fp)
81109dfc:	00c00044 	movi	r3,1
81109e00:	10c00115 	stw	r3,4(r2)
81109e04:	00000206 	br	81109e10 <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
81109e08:	e0bfff17 	ldw	r2,-4(fp)
81109e0c:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
81109e10:	e0bffe17 	ldw	r2,-8(fp)
81109e14:	1080008c 	andi	r2,r2,2
81109e18:	10000426 	beq	r2,zero,81109e2c <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
81109e1c:	e0bfff17 	ldw	r2,-4(fp)
81109e20:	00c00044 	movi	r3,1
81109e24:	10c00215 	stw	r3,8(r2)
81109e28:	00000206 	br	81109e34 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
81109e2c:	e0bfff17 	ldw	r2,-4(fp)
81109e30:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
81109e34:	e0bffe17 	ldw	r2,-8(fp)
81109e38:	1080004c 	andi	r2,r2,1
81109e3c:	10000426 	beq	r2,zero,81109e50 <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
81109e40:	e0bfff17 	ldw	r2,-4(fp)
81109e44:	00c00044 	movi	r3,1
81109e48:	10c00315 	stw	r3,12(r2)
81109e4c:	00000206 	br	81109e58 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
81109e50:	e0bfff17 	ldw	r2,-4(fp)
81109e54:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81109e58:	e0bffe17 	ldw	r2,-8(fp)
81109e5c:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
81109e60:	1007883a 	mov	r3,r2
81109e64:	e0bfff17 	ldw	r2,-4(fp)
81109e68:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
81109e6c:	00800044 	movi	r2,1
81109e70:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109e74:	e0bffd17 	ldw	r2,-12(fp)
}
81109e78:	e037883a 	mov	sp,fp
81109e7c:	dfc00117 	ldw	ra,4(sp)
81109e80:	df000017 	ldw	fp,0(sp)
81109e84:	dec00204 	addi	sp,sp,8
81109e88:	f800283a 	ret

81109e8c <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
81109e8c:	defffb04 	addi	sp,sp,-20
81109e90:	de00012e 	bgeu	sp,et,81109e98 <bSpwcGetLinkError+0xc>
81109e94:	003b68fa 	trap	3
81109e98:	dfc00415 	stw	ra,16(sp)
81109e9c:	df000315 	stw	fp,12(sp)
81109ea0:	df000304 	addi	fp,sp,12
81109ea4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109ea8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109eac:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109eb0:	e0bfff17 	ldw	r2,-4(fp)
81109eb4:	10002c26 	beq	r2,zero,81109f68 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109eb8:	e0bfff17 	ldw	r2,-4(fp)
81109ebc:	10800017 	ldw	r2,0(r2)
81109ec0:	000b883a 	mov	r5,zero
81109ec4:	1009883a 	mov	r4,r2
81109ec8:	110a3400 	call	8110a340 <uliSpwcReadReg>
81109ecc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
81109ed0:	e0bffe17 	ldw	r2,-8(fp)
81109ed4:	1080006c 	andhi	r2,r2,1
81109ed8:	10000426 	beq	r2,zero,81109eec <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
81109edc:	e0bfff17 	ldw	r2,-4(fp)
81109ee0:	00c00044 	movi	r3,1
81109ee4:	10c00515 	stw	r3,20(r2)
81109ee8:	00000206 	br	81109ef4 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
81109eec:	e0bfff17 	ldw	r2,-4(fp)
81109ef0:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
81109ef4:	e0bffe17 	ldw	r2,-8(fp)
81109ef8:	108000ac 	andhi	r2,r2,2
81109efc:	10000426 	beq	r2,zero,81109f10 <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
81109f00:	e0bfff17 	ldw	r2,-4(fp)
81109f04:	00c00044 	movi	r3,1
81109f08:	10c00615 	stw	r3,24(r2)
81109f0c:	00000206 	br	81109f18 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
81109f10:	e0bfff17 	ldw	r2,-4(fp)
81109f14:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
81109f18:	e0bffe17 	ldw	r2,-8(fp)
81109f1c:	1080012c 	andhi	r2,r2,4
81109f20:	10000426 	beq	r2,zero,81109f34 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81109f24:	e0bfff17 	ldw	r2,-4(fp)
81109f28:	00c00044 	movi	r3,1
81109f2c:	10c00715 	stw	r3,28(r2)
81109f30:	00000206 	br	81109f3c <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81109f34:	e0bfff17 	ldw	r2,-4(fp)
81109f38:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
81109f3c:	e0bffe17 	ldw	r2,-8(fp)
81109f40:	1080022c 	andhi	r2,r2,8
81109f44:	10000426 	beq	r2,zero,81109f58 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81109f48:	e0bfff17 	ldw	r2,-4(fp)
81109f4c:	00c00044 	movi	r3,1
81109f50:	10c00815 	stw	r3,32(r2)
81109f54:	00000206 	br	81109f60 <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81109f58:	e0bfff17 	ldw	r2,-4(fp)
81109f5c:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
81109f60:	00800044 	movi	r2,1
81109f64:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109f68:	e0bffd17 	ldw	r2,-12(fp)
}
81109f6c:	e037883a 	mov	sp,fp
81109f70:	dfc00117 	ldw	ra,4(sp)
81109f74:	df000017 	ldw	fp,0(sp)
81109f78:	dec00204 	addi	sp,sp,8
81109f7c:	f800283a 	ret

81109f80 <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
81109f80:	defffb04 	addi	sp,sp,-20
81109f84:	de00012e 	bgeu	sp,et,81109f8c <bSpwcGetLinkStatus+0xc>
81109f88:	003b68fa 	trap	3
81109f8c:	dfc00415 	stw	ra,16(sp)
81109f90:	df000315 	stw	fp,12(sp)
81109f94:	df000304 	addi	fp,sp,12
81109f98:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109f9c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81109fa0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109fa4:	e0bfff17 	ldw	r2,-4(fp)
81109fa8:	10002326 	beq	r2,zero,8110a038 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109fac:	e0bfff17 	ldw	r2,-4(fp)
81109fb0:	10800017 	ldw	r2,0(r2)
81109fb4:	000b883a 	mov	r5,zero
81109fb8:	1009883a 	mov	r4,r2
81109fbc:	110a3400 	call	8110a340 <uliSpwcReadReg>
81109fc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
81109fc4:	e0bffe17 	ldw	r2,-8(fp)
81109fc8:	1081000c 	andi	r2,r2,1024
81109fcc:	10000426 	beq	r2,zero,81109fe0 <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
81109fd0:	e0bfff17 	ldw	r2,-4(fp)
81109fd4:	00c00044 	movi	r3,1
81109fd8:	10c00915 	stw	r3,36(r2)
81109fdc:	00000206 	br	81109fe8 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
81109fe0:	e0bfff17 	ldw	r2,-4(fp)
81109fe4:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
81109fe8:	e0bffe17 	ldw	r2,-8(fp)
81109fec:	1080800c 	andi	r2,r2,512
81109ff0:	10000426 	beq	r2,zero,8110a004 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
81109ff4:	e0bfff17 	ldw	r2,-4(fp)
81109ff8:	00c00044 	movi	r3,1
81109ffc:	10c00a15 	stw	r3,40(r2)
8110a000:	00000206 	br	8110a00c <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
8110a004:	e0bfff17 	ldw	r2,-4(fp)
8110a008:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
8110a00c:	e0bffe17 	ldw	r2,-8(fp)
8110a010:	1080400c 	andi	r2,r2,256
8110a014:	10000426 	beq	r2,zero,8110a028 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
8110a018:	e0bfff17 	ldw	r2,-4(fp)
8110a01c:	00c00044 	movi	r3,1
8110a020:	10c00b15 	stw	r3,44(r2)
8110a024:	00000206 	br	8110a030 <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
8110a028:	e0bfff17 	ldw	r2,-4(fp)
8110a02c:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110a030:	00800044 	movi	r2,1
8110a034:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a038:	e0bffd17 	ldw	r2,-12(fp)
}
8110a03c:	e037883a 	mov	sp,fp
8110a040:	dfc00117 	ldw	ra,4(sp)
8110a044:	df000017 	ldw	fp,0(sp)
8110a048:	dec00204 	addi	sp,sp,8
8110a04c:	f800283a 	ret

8110a050 <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110a050:	defffb04 	addi	sp,sp,-20
8110a054:	de00012e 	bgeu	sp,et,8110a05c <bSpwcGetTimecode+0xc>
8110a058:	003b68fa 	trap	3
8110a05c:	dfc00415 	stw	ra,16(sp)
8110a060:	df000315 	stw	fp,12(sp)
8110a064:	df000304 	addi	fp,sp,12
8110a068:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a06c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a070:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a074:	e0bfff17 	ldw	r2,-4(fp)
8110a078:	10001326 	beq	r2,zero,8110a0c8 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a07c:	e0bfff17 	ldw	r2,-4(fp)
8110a080:	10800017 	ldw	r2,0(r2)
8110a084:	01400044 	movi	r5,1
8110a088:	1009883a 	mov	r4,r2
8110a08c:	110a3400 	call	8110a340 <uliSpwcReadReg>
8110a090:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
8110a094:	e0bffe17 	ldw	r2,-8(fp)
8110a098:	1080300c 	andi	r2,r2,192
8110a09c:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
8110a0a0:	1007883a 	mov	r3,r2
8110a0a4:	e0bfff17 	ldw	r2,-4(fp)
8110a0a8:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
8110a0ac:	e0bffe17 	ldw	r2,-8(fp)
8110a0b0:	10800fcc 	andi	r2,r2,63
8110a0b4:	1007883a 	mov	r3,r2
8110a0b8:	e0bfff17 	ldw	r2,-4(fp)
8110a0bc:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
8110a0c0:	00800044 	movi	r2,1
8110a0c4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a0c8:	e0bffd17 	ldw	r2,-12(fp)
}
8110a0cc:	e037883a 	mov	sp,fp
8110a0d0:	dfc00117 	ldw	ra,4(sp)
8110a0d4:	df000017 	ldw	fp,0(sp)
8110a0d8:	dec00204 	addi	sp,sp,8
8110a0dc:	f800283a 	ret

8110a0e0 <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
8110a0e0:	defffb04 	addi	sp,sp,-20
8110a0e4:	de00012e 	bgeu	sp,et,8110a0ec <bSpwcClearTimecode+0xc>
8110a0e8:	003b68fa 	trap	3
8110a0ec:	dfc00415 	stw	ra,16(sp)
8110a0f0:	df000315 	stw	fp,12(sp)
8110a0f4:	df000304 	addi	fp,sp,12
8110a0f8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110a0fc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110a100:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
8110a104:	e0bfff17 	ldw	r2,-4(fp)
8110a108:	10001126 	beq	r2,zero,8110a150 <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
8110a10c:	e0bfff17 	ldw	r2,-4(fp)
8110a110:	10800017 	ldw	r2,0(r2)
8110a114:	01400044 	movi	r5,1
8110a118:	1009883a 	mov	r4,r2
8110a11c:	110a3400 	call	8110a340 <uliSpwcReadReg>
8110a120:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
8110a124:	e0bffe17 	ldw	r2,-8(fp)
8110a128:	10804014 	ori	r2,r2,256
8110a12c:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110a130:	e0bfff17 	ldw	r2,-4(fp)
8110a134:	10800017 	ldw	r2,0(r2)
8110a138:	e1bffe17 	ldw	r6,-8(fp)
8110a13c:	01400044 	movi	r5,1
8110a140:	1009883a 	mov	r4,r2
8110a144:	110a2ec0 	call	8110a2ec <vSpwcWriteReg>
		bStatus = TRUE;
8110a148:	00800044 	movi	r2,1
8110a14c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110a150:	e0bffd17 	ldw	r2,-12(fp)
}
8110a154:	e037883a 	mov	sp,fp
8110a158:	dfc00117 	ldw	ra,4(sp)
8110a15c:	df000017 	ldw	fp,0(sp)
8110a160:	dec00204 	addi	sp,sp,8
8110a164:	f800283a 	ret

8110a168 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
8110a168:	defffb04 	addi	sp,sp,-20
8110a16c:	de00012e 	bgeu	sp,et,8110a174 <bSpwcInitCh+0xc>
8110a170:	003b68fa 	trap	3
8110a174:	dfc00415 	stw	ra,16(sp)
8110a178:	df000315 	stw	fp,12(sp)
8110a17c:	df000304 	addi	fp,sp,12
8110a180:	e13ffe15 	stw	r4,-8(fp)
8110a184:	2805883a 	mov	r2,r5
8110a188:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
8110a18c:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
8110a190:	e0bffe17 	ldw	r2,-8(fp)
8110a194:	10004f26 	beq	r2,zero,8110a2d4 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
8110a198:	00800044 	movi	r2,1
8110a19c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
8110a1a0:	e0bfff03 	ldbu	r2,-4(fp)
8110a1a4:	10c00228 	cmpgeui	r3,r2,8
8110a1a8:	1800361e 	bne	r3,zero,8110a284 <bSpwcInitCh+0x11c>
8110a1ac:	100690ba 	slli	r3,r2,2
8110a1b0:	00a04474 	movhi	r2,33041
8110a1b4:	10a87104 	addi	r2,r2,-24124
8110a1b8:	1885883a 	add	r2,r3,r2
8110a1bc:	10800017 	ldw	r2,0(r2)
8110a1c0:	1000683a 	jmp	r2
8110a1c4:	8110a1e4 	muli	r4,r16,17031
8110a1c8:	8110a1f8 	rdprs	r4,r16,17031
8110a1cc:	8110a20c 	andi	r4,r16,17032
8110a1d0:	8110a220 	cmpeqi	r4,r16,17032
8110a1d4:	8110a234 	orhi	r4,r16,17032
8110a1d8:	8110a248 	cmpgei	r4,r16,17033
8110a1dc:	8110a25c 	xori	r4,r16,17033
8110a1e0:	8110a270 	cmpltui	r4,r16,17033
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
8110a1e4:	e0fffe17 	ldw	r3,-8(fp)
8110a1e8:	00a04834 	movhi	r2,33056
8110a1ec:	108b0004 	addi	r2,r2,11264
8110a1f0:	18800015 	stw	r2,0(r3)
			break;
8110a1f4:	00002506 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
8110a1f8:	e0fffe17 	ldw	r3,-8(fp)
8110a1fc:	00a04834 	movhi	r2,33056
8110a200:	108a0004 	addi	r2,r2,10240
8110a204:	18800015 	stw	r2,0(r3)
			break;
8110a208:	00002006 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
8110a20c:	e0fffe17 	ldw	r3,-8(fp)
8110a210:	00a04834 	movhi	r2,33056
8110a214:	108b0004 	addi	r2,r2,11264
8110a218:	18800015 	stw	r2,0(r3)
			break;
8110a21c:	00001b06 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110a220:	e0fffe17 	ldw	r3,-8(fp)
8110a224:	00a04834 	movhi	r2,33056
8110a228:	108a0004 	addi	r2,r2,10240
8110a22c:	18800015 	stw	r2,0(r3)
			break;
8110a230:	00001606 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
8110a234:	e0fffe17 	ldw	r3,-8(fp)
8110a238:	00a04834 	movhi	r2,33056
8110a23c:	108b0004 	addi	r2,r2,11264
8110a240:	18800015 	stw	r2,0(r3)
			break;
8110a244:	00001106 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
8110a248:	e0fffe17 	ldw	r3,-8(fp)
8110a24c:	00a04834 	movhi	r2,33056
8110a250:	108a0004 	addi	r2,r2,10240
8110a254:	18800015 	stw	r2,0(r3)
			break;
8110a258:	00000c06 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110a25c:	e0fffe17 	ldw	r3,-8(fp)
8110a260:	00a04834 	movhi	r2,33056
8110a264:	108b0004 	addi	r2,r2,11264
8110a268:	18800015 	stw	r2,0(r3)
			break;
8110a26c:	00000706 	br	8110a28c <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110a270:	e0fffe17 	ldw	r3,-8(fp)
8110a274:	00a04834 	movhi	r2,33056
8110a278:	108a0004 	addi	r2,r2,10240
8110a27c:	18800015 	stw	r2,0(r3)
			break;
8110a280:	00000206 	br	8110a28c <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
8110a284:	e03ffd15 	stw	zero,-12(fp)
			break;
8110a288:	0001883a 	nop
		}

		if (bStatus) {
8110a28c:	e0bffd17 	ldw	r2,-12(fp)
8110a290:	10001026 	beq	r2,zero,8110a2d4 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
8110a294:	e13ffe17 	ldw	r4,-8(fp)
8110a298:	1109da80 	call	81109da8 <bSpwcGetLink>
8110a29c:	1000011e 	bne	r2,zero,8110a2a4 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
8110a2a0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
8110a2a4:	e13ffe17 	ldw	r4,-8(fp)
8110a2a8:	1109e8c0 	call	81109e8c <bSpwcGetLinkError>
8110a2ac:	1000011e 	bne	r2,zero,8110a2b4 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
8110a2b0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
8110a2b4:	e13ffe17 	ldw	r4,-8(fp)
8110a2b8:	1109f800 	call	81109f80 <bSpwcGetLinkStatus>
8110a2bc:	1000011e 	bne	r2,zero,8110a2c4 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
8110a2c0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
8110a2c4:	e13ffe17 	ldw	r4,-8(fp)
8110a2c8:	110a0500 	call	8110a050 <bSpwcGetTimecode>
8110a2cc:	1000011e 	bne	r2,zero,8110a2d4 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
8110a2d0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
8110a2d4:	e0bffd17 	ldw	r2,-12(fp)
}
8110a2d8:	e037883a 	mov	sp,fp
8110a2dc:	dfc00117 	ldw	ra,4(sp)
8110a2e0:	df000017 	ldw	fp,0(sp)
8110a2e4:	dec00204 	addi	sp,sp,8
8110a2e8:	f800283a 	ret

8110a2ec <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110a2ec:	defffc04 	addi	sp,sp,-16
8110a2f0:	de00012e 	bgeu	sp,et,8110a2f8 <vSpwcWriteReg+0xc>
8110a2f4:	003b68fa 	trap	3
8110a2f8:	df000315 	stw	fp,12(sp)
8110a2fc:	df000304 	addi	fp,sp,12
8110a300:	e13ffd15 	stw	r4,-12(fp)
8110a304:	e17ffe15 	stw	r5,-8(fp)
8110a308:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110a30c:	e0bffe17 	ldw	r2,-8(fp)
8110a310:	1085883a 	add	r2,r2,r2
8110a314:	1085883a 	add	r2,r2,r2
8110a318:	1007883a 	mov	r3,r2
8110a31c:	e0bffd17 	ldw	r2,-12(fp)
8110a320:	10c5883a 	add	r2,r2,r3
8110a324:	e0ffff17 	ldw	r3,-4(fp)
8110a328:	10c00015 	stw	r3,0(r2)
}
8110a32c:	0001883a 	nop
8110a330:	e037883a 	mov	sp,fp
8110a334:	df000017 	ldw	fp,0(sp)
8110a338:	dec00104 	addi	sp,sp,4
8110a33c:	f800283a 	ret

8110a340 <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110a340:	defffc04 	addi	sp,sp,-16
8110a344:	de00012e 	bgeu	sp,et,8110a34c <uliSpwcReadReg+0xc>
8110a348:	003b68fa 	trap	3
8110a34c:	df000315 	stw	fp,12(sp)
8110a350:	df000304 	addi	fp,sp,12
8110a354:	e13ffe15 	stw	r4,-8(fp)
8110a358:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110a35c:	e0bfff17 	ldw	r2,-4(fp)
8110a360:	1085883a 	add	r2,r2,r2
8110a364:	1085883a 	add	r2,r2,r2
8110a368:	1007883a 	mov	r3,r2
8110a36c:	e0bffe17 	ldw	r2,-8(fp)
8110a370:	10c5883a 	add	r2,r2,r3
8110a374:	10800017 	ldw	r2,0(r2)
8110a378:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110a37c:	e0bffd17 	ldw	r2,-12(fp)
}
8110a380:	e037883a 	mov	sp,fp
8110a384:	df000017 	ldw	fp,0(sp)
8110a388:	dec00104 	addi	sp,sp,4
8110a38c:	f800283a 	ret

8110a390 <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
8110a390:	defffe04 	addi	sp,sp,-8
8110a394:	de00012e 	bgeu	sp,et,8110a39c <bEnableIsoDrivers+0xc>
8110a398:	003b68fa 	trap	3
8110a39c:	dfc00115 	stw	ra,4(sp)
8110a3a0:	df000015 	stw	fp,0(sp)
8110a3a4:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
8110a3a8:	01400204 	movi	r5,8
8110a3ac:	01000044 	movi	r4,1
8110a3b0:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a3b4:	00800044 	movi	r2,1
}
8110a3b8:	e037883a 	mov	sp,fp
8110a3bc:	dfc00117 	ldw	ra,4(sp)
8110a3c0:	df000017 	ldw	fp,0(sp)
8110a3c4:	dec00204 	addi	sp,sp,8
8110a3c8:	f800283a 	ret

8110a3cc <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
8110a3cc:	defffe04 	addi	sp,sp,-8
8110a3d0:	de00012e 	bgeu	sp,et,8110a3d8 <bDisableIsoDrivers+0xc>
8110a3d4:	003b68fa 	trap	3
8110a3d8:	dfc00115 	stw	ra,4(sp)
8110a3dc:	df000015 	stw	fp,0(sp)
8110a3e0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
8110a3e4:	01400204 	movi	r5,8
8110a3e8:	0009883a 	mov	r4,zero
8110a3ec:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a3f0:	00800044 	movi	r2,1
}
8110a3f4:	e037883a 	mov	sp,fp
8110a3f8:	dfc00117 	ldw	ra,4(sp)
8110a3fc:	df000017 	ldw	fp,0(sp)
8110a400:	dec00204 	addi	sp,sp,8
8110a404:	f800283a 	ret

8110a408 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
8110a408:	defffe04 	addi	sp,sp,-8
8110a40c:	de00012e 	bgeu	sp,et,8110a414 <bEnableLvdsBoard+0xc>
8110a410:	003b68fa 	trap	3
8110a414:	dfc00115 	stw	ra,4(sp)
8110a418:	df000015 	stw	fp,0(sp)
8110a41c:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110a420:	01400104 	movi	r5,4
8110a424:	01000044 	movi	r4,1
8110a428:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a42c:	00800044 	movi	r2,1
}
8110a430:	e037883a 	mov	sp,fp
8110a434:	dfc00117 	ldw	ra,4(sp)
8110a438:	df000017 	ldw	fp,0(sp)
8110a43c:	dec00204 	addi	sp,sp,8
8110a440:	f800283a 	ret

8110a444 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
8110a444:	defffe04 	addi	sp,sp,-8
8110a448:	de00012e 	bgeu	sp,et,8110a450 <bDisableLvdsBoard+0xc>
8110a44c:	003b68fa 	trap	3
8110a450:	dfc00115 	stw	ra,4(sp)
8110a454:	df000015 	stw	fp,0(sp)
8110a458:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
8110a45c:	01400104 	movi	r5,4
8110a460:	0009883a 	mov	r4,zero
8110a464:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
  return  TRUE;
8110a468:	00800044 	movi	r2,1
}
8110a46c:	e037883a 	mov	sp,fp
8110a470:	dfc00117 	ldw	ra,4(sp)
8110a474:	df000017 	ldw	fp,0(sp)
8110a478:	dec00204 	addi	sp,sp,8
8110a47c:	f800283a 	ret

8110a480 <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110a480:	defffd04 	addi	sp,sp,-12
8110a484:	de00012e 	bgeu	sp,et,8110a48c <bSetPreEmphasys+0xc>
8110a488:	003b68fa 	trap	3
8110a48c:	dfc00215 	stw	ra,8(sp)
8110a490:	df000115 	stw	fp,4(sp)
8110a494:	df000104 	addi	fp,sp,4
8110a498:	2005883a 	mov	r2,r4
8110a49c:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
8110a4a0:	e0bfff03 	ldbu	r2,-4(fp)
8110a4a4:	10c00060 	cmpeqi	r3,r2,1
8110a4a8:	18000d1e 	bne	r3,zero,8110a4e0 <bSetPreEmphasys+0x60>
8110a4ac:	10c00088 	cmpgei	r3,r2,2
8110a4b0:	1800021e 	bne	r3,zero,8110a4bc <bSetPreEmphasys+0x3c>
8110a4b4:	10000626 	beq	r2,zero,8110a4d0 <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a4b8:	00001b06 	br	8110a528 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
8110a4bc:	10c000a0 	cmpeqi	r3,r2,2
8110a4c0:	18000e1e 	bne	r3,zero,8110a4fc <bSetPreEmphasys+0x7c>
8110a4c4:	108000e0 	cmpeqi	r2,r2,3
8110a4c8:	1000131e 	bne	r2,zero,8110a518 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
8110a4cc:	00001606 	br	8110a528 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a4d0:	014000c4 	movi	r5,3
8110a4d4:	0009883a 	mov	r4,zero
8110a4d8:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
      break;
8110a4dc:	00001206 	br	8110a528 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
8110a4e0:	01400084 	movi	r5,2
8110a4e4:	0009883a 	mov	r4,zero
8110a4e8:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
8110a4ec:	01400044 	movi	r5,1
8110a4f0:	01000044 	movi	r4,1
8110a4f4:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
      break;
8110a4f8:	00000b06 	br	8110a528 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
8110a4fc:	01400044 	movi	r5,1
8110a500:	0009883a 	mov	r4,zero
8110a504:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
8110a508:	01400084 	movi	r5,2
8110a50c:	01000044 	movi	r4,1
8110a510:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
      break;
8110a514:	00000406 	br	8110a528 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
8110a518:	014000c4 	movi	r5,3
8110a51c:	01000044 	movi	r4,1
8110a520:	110a5400 	call	8110a540 <bCtrlIoLvdsDrive>
      break;
8110a524:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
8110a528:	00800044 	movi	r2,1
}
8110a52c:	e037883a 	mov	sp,fp
8110a530:	dfc00117 	ldw	ra,4(sp)
8110a534:	df000017 	ldw	fp,0(sp)
8110a538:	dec00204 	addi	sp,sp,8
8110a53c:	f800283a 	ret

8110a540 <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
8110a540:	defffd04 	addi	sp,sp,-12
8110a544:	de00012e 	bgeu	sp,et,8110a54c <bCtrlIoLvdsDrive+0xc>
8110a548:	003b68fa 	trap	3
8110a54c:	df000215 	stw	fp,8(sp)
8110a550:	df000204 	addi	fp,sp,8
8110a554:	e13ffe15 	stw	r4,-8(fp)
8110a558:	2805883a 	mov	r2,r5
8110a55c:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
8110a560:	e0bffe17 	ldw	r2,-8(fp)
8110a564:	1000071e 	bne	r2,zero,8110a584 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
8110a568:	e0bfff03 	ldbu	r2,-4(fp)
8110a56c:	0084303a 	nor	r2,zero,r2
8110a570:	1007883a 	mov	r3,r2
8110a574:	d0a00103 	ldbu	r2,-32764(gp)
8110a578:	1884703a 	and	r2,r3,r2
8110a57c:	d0a00105 	stb	r2,-32764(gp)
8110a580:	00000406 	br	8110a594 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
8110a584:	d0e00103 	ldbu	r3,-32764(gp)
8110a588:	e0bfff03 	ldbu	r2,-4(fp)
8110a58c:	1884b03a 	or	r2,r3,r2
8110a590:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
8110a594:	d0a00103 	ldbu	r2,-32764(gp)
8110a598:	10c03fcc 	andi	r3,r2,255
8110a59c:	00a00034 	movhi	r2,32768
8110a5a0:	10822804 	addi	r2,r2,2208
8110a5a4:	10c00035 	stwio	r3,0(r2)
  return TRUE;
8110a5a8:	00800044 	movi	r2,1
}
8110a5ac:	e037883a 	mov	sp,fp
8110a5b0:	df000017 	ldw	fp,0(sp)
8110a5b4:	dec00104 	addi	sp,sp,4
8110a5b8:	f800283a 	ret

8110a5bc <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
8110a5bc:	defffa04 	addi	sp,sp,-24
8110a5c0:	de00012e 	bgeu	sp,et,8110a5c8 <I2C_TestAdress+0xc>
8110a5c4:	003b68fa 	trap	3
8110a5c8:	dfc00515 	stw	ra,20(sp)
8110a5cc:	df000415 	stw	fp,16(sp)
8110a5d0:	df000404 	addi	fp,sp,16
8110a5d4:	e13ffd15 	stw	r4,-12(fp)
8110a5d8:	e17ffe15 	stw	r5,-8(fp)
8110a5dc:	3005883a 	mov	r2,r6
8110a5e0:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110a5e4:	00800044 	movi	r2,1
8110a5e8:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a5ec:	e17ffe17 	ldw	r5,-8(fp)
8110a5f0:	e13ffd17 	ldw	r4,-12(fp)
8110a5f4:	110a98c0 	call	8110a98c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a5f8:	e0bfff03 	ldbu	r2,-4(fp)
8110a5fc:	10803fcc 	andi	r2,r2,255
8110a600:	100d883a 	mov	r6,r2
8110a604:	e17ffe17 	ldw	r5,-8(fp)
8110a608:	e13ffd17 	ldw	r4,-12(fp)
8110a60c:	110aaa00 	call	8110aaa0 <i2c_write>
8110a610:	1000011e 	bne	r2,zero,8110a618 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
8110a614:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110a618:	e17ffe17 	ldw	r5,-8(fp)
8110a61c:	e13ffd17 	ldw	r4,-12(fp)
8110a620:	110aa200 	call	8110aa20 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110a624:	0106d604 	movi	r4,7000
8110a628:	1135d140 	call	81135d14 <usleep>
    
    return bSuccess;
8110a62c:	e0bffc17 	ldw	r2,-16(fp)

}
8110a630:	e037883a 	mov	sp,fp
8110a634:	dfc00117 	ldw	ra,4(sp)
8110a638:	df000017 	ldw	fp,0(sp)
8110a63c:	dec00204 	addi	sp,sp,8
8110a640:	f800283a 	ret

8110a644 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
8110a644:	defff804 	addi	sp,sp,-32
8110a648:	de00012e 	bgeu	sp,et,8110a650 <I2C_Write+0xc>
8110a64c:	003b68fa 	trap	3
8110a650:	dfc00715 	stw	ra,28(sp)
8110a654:	df000615 	stw	fp,24(sp)
8110a658:	df000604 	addi	fp,sp,24
8110a65c:	e13ffb15 	stw	r4,-20(fp)
8110a660:	e17ffc15 	stw	r5,-16(fp)
8110a664:	3009883a 	mov	r4,r6
8110a668:	3807883a 	mov	r3,r7
8110a66c:	e0800217 	ldw	r2,8(fp)
8110a670:	e13ffd05 	stb	r4,-12(fp)
8110a674:	e0fffe05 	stb	r3,-8(fp)
8110a678:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110a67c:	00800044 	movi	r2,1
8110a680:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a684:	e17ffc17 	ldw	r5,-16(fp)
8110a688:	e13ffb17 	ldw	r4,-20(fp)
8110a68c:	110a98c0 	call	8110a98c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a690:	e0bffd03 	ldbu	r2,-12(fp)
8110a694:	10803fcc 	andi	r2,r2,255
8110a698:	100d883a 	mov	r6,r2
8110a69c:	e17ffc17 	ldw	r5,-16(fp)
8110a6a0:	e13ffb17 	ldw	r4,-20(fp)
8110a6a4:	110aaa00 	call	8110aaa0 <i2c_write>
8110a6a8:	1000011e 	bne	r2,zero,8110a6b0 <I2C_Write+0x6c>
        bSuccess = FALSE;
8110a6ac:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110a6b0:	e0bffa17 	ldw	r2,-24(fp)
8110a6b4:	10000726 	beq	r2,zero,8110a6d4 <I2C_Write+0x90>
8110a6b8:	e0bffe03 	ldbu	r2,-8(fp)
8110a6bc:	100d883a 	mov	r6,r2
8110a6c0:	e17ffc17 	ldw	r5,-16(fp)
8110a6c4:	e13ffb17 	ldw	r4,-20(fp)
8110a6c8:	110aaa00 	call	8110aaa0 <i2c_write>
8110a6cc:	1000011e 	bne	r2,zero,8110a6d4 <I2C_Write+0x90>
        bSuccess = FALSE;
8110a6d0:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
8110a6d4:	e0bffa17 	ldw	r2,-24(fp)
8110a6d8:	10000726 	beq	r2,zero,8110a6f8 <I2C_Write+0xb4>
8110a6dc:	e0bfff03 	ldbu	r2,-4(fp)
8110a6e0:	100d883a 	mov	r6,r2
8110a6e4:	e17ffc17 	ldw	r5,-16(fp)
8110a6e8:	e13ffb17 	ldw	r4,-20(fp)
8110a6ec:	110aaa00 	call	8110aaa0 <i2c_write>
8110a6f0:	1000011e 	bne	r2,zero,8110a6f8 <I2C_Write+0xb4>
        bSuccess = FALSE;
8110a6f4:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
8110a6f8:	e17ffc17 	ldw	r5,-16(fp)
8110a6fc:	e13ffb17 	ldw	r4,-20(fp)
8110a700:	110aa200 	call	8110aa20 <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
8110a704:	0106d604 	movi	r4,7000
8110a708:	1135d140 	call	81135d14 <usleep>
    
    return bSuccess;
8110a70c:	e0bffa17 	ldw	r2,-24(fp)

}
8110a710:	e037883a 	mov	sp,fp
8110a714:	dfc00117 	ldw	ra,4(sp)
8110a718:	df000017 	ldw	fp,0(sp)
8110a71c:	dec00204 	addi	sp,sp,8
8110a720:	f800283a 	ret

8110a724 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
8110a724:	defff904 	addi	sp,sp,-28
8110a728:	de00012e 	bgeu	sp,et,8110a730 <I2C_Read+0xc>
8110a72c:	003b68fa 	trap	3
8110a730:	dfc00615 	stw	ra,24(sp)
8110a734:	df000515 	stw	fp,20(sp)
8110a738:	df000504 	addi	fp,sp,20
8110a73c:	e13ffc15 	stw	r4,-16(fp)
8110a740:	e17ffd15 	stw	r5,-12(fp)
8110a744:	3007883a 	mov	r3,r6
8110a748:	3805883a 	mov	r2,r7
8110a74c:	e0fffe05 	stb	r3,-8(fp)
8110a750:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
8110a754:	00800044 	movi	r2,1
8110a758:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a75c:	e17ffd17 	ldw	r5,-12(fp)
8110a760:	e13ffc17 	ldw	r4,-16(fp)
8110a764:	110a98c0 	call	8110a98c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a768:	e0bffe03 	ldbu	r2,-8(fp)
8110a76c:	10803fcc 	andi	r2,r2,255
8110a770:	100d883a 	mov	r6,r2
8110a774:	e17ffd17 	ldw	r5,-12(fp)
8110a778:	e13ffc17 	ldw	r4,-16(fp)
8110a77c:	110aaa00 	call	8110aaa0 <i2c_write>
8110a780:	1000011e 	bne	r2,zero,8110a788 <I2C_Read+0x64>
        bSuccess = FALSE;
8110a784:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110a788:	e0bffb17 	ldw	r2,-20(fp)
8110a78c:	10000726 	beq	r2,zero,8110a7ac <I2C_Read+0x88>
8110a790:	e0bfff03 	ldbu	r2,-4(fp)
8110a794:	100d883a 	mov	r6,r2
8110a798:	e17ffd17 	ldw	r5,-12(fp)
8110a79c:	e13ffc17 	ldw	r4,-16(fp)
8110a7a0:	110aaa00 	call	8110aaa0 <i2c_write>
8110a7a4:	1000011e 	bne	r2,zero,8110a7ac <I2C_Read+0x88>
        bSuccess = FALSE;
8110a7a8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
8110a7ac:	e17ffd17 	ldw	r5,-12(fp)
8110a7b0:	e13ffc17 	ldw	r4,-16(fp)
8110a7b4:	110a98c0 	call	8110a98c <i2c_start>
    DeviceAddr |= 1; // Read
8110a7b8:	e0bffe03 	ldbu	r2,-8(fp)
8110a7bc:	10800054 	ori	r2,r2,1
8110a7c0:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110a7c4:	e0bffb17 	ldw	r2,-20(fp)
8110a7c8:	10000826 	beq	r2,zero,8110a7ec <I2C_Read+0xc8>
8110a7cc:	e0bffe03 	ldbu	r2,-8(fp)
8110a7d0:	10803fcc 	andi	r2,r2,255
8110a7d4:	100d883a 	mov	r6,r2
8110a7d8:	e17ffd17 	ldw	r5,-12(fp)
8110a7dc:	e13ffc17 	ldw	r4,-16(fp)
8110a7e0:	110aaa00 	call	8110aaa0 <i2c_write>
8110a7e4:	1000011e 	bne	r2,zero,8110a7ec <I2C_Read+0xc8>
        bSuccess = FALSE;
8110a7e8:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110a7ec:	e0bffb17 	ldw	r2,-20(fp)
8110a7f0:	10000526 	beq	r2,zero,8110a808 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
8110a7f4:	000f883a 	mov	r7,zero
8110a7f8:	e1800217 	ldw	r6,8(fp)
8110a7fc:	e17ffd17 	ldw	r5,-12(fp)
8110a800:	e13ffc17 	ldw	r4,-16(fp)
8110a804:	110abd80 	call	8110abd8 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
8110a808:	e17ffd17 	ldw	r5,-12(fp)
8110a80c:	e13ffc17 	ldw	r4,-16(fp)
8110a810:	110aa200 	call	8110aa20 <i2c_stop>
    
    return bSuccess;
8110a814:	e0bffb17 	ldw	r2,-20(fp)
}
8110a818:	e037883a 	mov	sp,fp
8110a81c:	dfc00117 	ldw	ra,4(sp)
8110a820:	df000017 	ldw	fp,0(sp)
8110a824:	dec00204 	addi	sp,sp,8
8110a828:	f800283a 	ret

8110a82c <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
8110a82c:	defff604 	addi	sp,sp,-40
8110a830:	de00012e 	bgeu	sp,et,8110a838 <I2C_MultipleRead+0xc>
8110a834:	003b68fa 	trap	3
8110a838:	dfc00915 	stw	ra,36(sp)
8110a83c:	df000815 	stw	fp,32(sp)
8110a840:	df000804 	addi	fp,sp,32
8110a844:	e13ffb15 	stw	r4,-20(fp)
8110a848:	e17ffc15 	stw	r5,-16(fp)
8110a84c:	3007883a 	mov	r3,r6
8110a850:	e1fffe15 	stw	r7,-8(fp)
8110a854:	e0800217 	ldw	r2,8(fp)
8110a858:	e0fffd05 	stb	r3,-12(fp)
8110a85c:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
8110a860:	00800044 	movi	r2,1
8110a864:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
8110a868:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
8110a86c:	e17ffc17 	ldw	r5,-16(fp)
8110a870:	e13ffb17 	ldw	r4,-20(fp)
8110a874:	110a98c0 	call	8110a98c <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
8110a878:	e0bffd03 	ldbu	r2,-12(fp)
8110a87c:	10803fcc 	andi	r2,r2,255
8110a880:	100d883a 	mov	r6,r2
8110a884:	e17ffc17 	ldw	r5,-16(fp)
8110a888:	e13ffb17 	ldw	r4,-20(fp)
8110a88c:	110aaa00 	call	8110aaa0 <i2c_write>
8110a890:	1000011e 	bne	r2,zero,8110a898 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
8110a894:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
8110a898:	e0bff917 	ldw	r2,-28(fp)
8110a89c:	10000726 	beq	r2,zero,8110a8bc <I2C_MultipleRead+0x90>
8110a8a0:	e0bffa03 	ldbu	r2,-24(fp)
8110a8a4:	100d883a 	mov	r6,r2
8110a8a8:	e17ffc17 	ldw	r5,-16(fp)
8110a8ac:	e13ffb17 	ldw	r4,-20(fp)
8110a8b0:	110aaa00 	call	8110aaa0 <i2c_write>
8110a8b4:	1000011e 	bne	r2,zero,8110a8bc <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
8110a8b8:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
8110a8bc:	e0bff917 	ldw	r2,-28(fp)
8110a8c0:	10000326 	beq	r2,zero,8110a8d0 <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
8110a8c4:	e17ffc17 	ldw	r5,-16(fp)
8110a8c8:	e13ffb17 	ldw	r4,-20(fp)
8110a8cc:	110a98c0 	call	8110a98c <i2c_start>
    DeviceAddr |= 1; // Read
8110a8d0:	e0bffd03 	ldbu	r2,-12(fp)
8110a8d4:	10800054 	ori	r2,r2,1
8110a8d8:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
8110a8dc:	e0bff917 	ldw	r2,-28(fp)
8110a8e0:	10000826 	beq	r2,zero,8110a904 <I2C_MultipleRead+0xd8>
8110a8e4:	e0bffd03 	ldbu	r2,-12(fp)
8110a8e8:	10803fcc 	andi	r2,r2,255
8110a8ec:	100d883a 	mov	r6,r2
8110a8f0:	e17ffc17 	ldw	r5,-16(fp)
8110a8f4:	e13ffb17 	ldw	r4,-20(fp)
8110a8f8:	110aaa00 	call	8110aaa0 <i2c_write>
8110a8fc:	1000011e 	bne	r2,zero,8110a904 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
8110a900:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
8110a904:	e0bff917 	ldw	r2,-28(fp)
8110a908:	10001726 	beq	r2,zero,8110a968 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
8110a90c:	e03ff815 	stw	zero,-32(fp)
8110a910:	00001006 	br	8110a954 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
8110a914:	e0bff817 	ldw	r2,-32(fp)
8110a918:	e0fffe17 	ldw	r3,-8(fp)
8110a91c:	1889883a 	add	r4,r3,r2
8110a920:	e0bfff0b 	ldhu	r2,-4(fp)
8110a924:	10ffffc4 	addi	r3,r2,-1
8110a928:	e0bff817 	ldw	r2,-32(fp)
8110a92c:	1884c03a 	cmpne	r2,r3,r2
8110a930:	10803fcc 	andi	r2,r2,255
8110a934:	100f883a 	mov	r7,r2
8110a938:	200d883a 	mov	r6,r4
8110a93c:	e17ffc17 	ldw	r5,-16(fp)
8110a940:	e13ffb17 	ldw	r4,-20(fp)
8110a944:	110abd80 	call	8110abd8 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
8110a948:	e0bff817 	ldw	r2,-32(fp)
8110a94c:	10800044 	addi	r2,r2,1
8110a950:	e0bff815 	stw	r2,-32(fp)
8110a954:	e0bfff0b 	ldhu	r2,-4(fp)
8110a958:	e0fff817 	ldw	r3,-32(fp)
8110a95c:	1880020e 	bge	r3,r2,8110a968 <I2C_MultipleRead+0x13c>
8110a960:	e0bff917 	ldw	r2,-28(fp)
8110a964:	103feb1e 	bne	r2,zero,8110a914 <__reset+0xfb0ea914>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
8110a968:	e17ffc17 	ldw	r5,-16(fp)
8110a96c:	e13ffb17 	ldw	r4,-20(fp)
8110a970:	110aa200 	call	8110aa20 <i2c_stop>
    
    return bSuccess;    
8110a974:	e0bff917 	ldw	r2,-28(fp)
    
}
8110a978:	e037883a 	mov	sp,fp
8110a97c:	dfc00117 	ldw	ra,4(sp)
8110a980:	df000017 	ldw	fp,0(sp)
8110a984:	dec00204 	addi	sp,sp,8
8110a988:	f800283a 	ret

8110a98c <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
8110a98c:	defffc04 	addi	sp,sp,-16
8110a990:	de00012e 	bgeu	sp,et,8110a998 <i2c_start+0xc>
8110a994:	003b68fa 	trap	3
8110a998:	dfc00315 	stw	ra,12(sp)
8110a99c:	df000215 	stw	fp,8(sp)
8110a9a0:	df000204 	addi	fp,sp,8
8110a9a4:	e13ffe15 	stw	r4,-8(fp)
8110a9a8:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
8110a9ac:	e0bfff17 	ldw	r2,-4(fp)
8110a9b0:	10800104 	addi	r2,r2,4
8110a9b4:	1007883a 	mov	r3,r2
8110a9b8:	00800044 	movi	r2,1
8110a9bc:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
8110a9c0:	e0bfff17 	ldw	r2,-4(fp)
8110a9c4:	00c00044 	movi	r3,1
8110a9c8:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
8110a9cc:	e0bffe17 	ldw	r2,-8(fp)
8110a9d0:	00c00044 	movi	r3,1
8110a9d4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110a9d8:	01000044 	movi	r4,1
8110a9dc:	1135d140 	call	81135d14 <usleep>
     
    SDA_LOW(data_base); // data low
8110a9e0:	e0bfff17 	ldw	r2,-4(fp)
8110a9e4:	0007883a 	mov	r3,zero
8110a9e8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
8110a9ec:	01000044 	movi	r4,1
8110a9f0:	1135d140 	call	81135d14 <usleep>
    SCL_LOW(clk_base); // clock low
8110a9f4:	e0bffe17 	ldw	r2,-8(fp)
8110a9f8:	0007883a 	mov	r3,zero
8110a9fc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
8110aa00:	01000044 	movi	r4,1
8110aa04:	1135d140 	call	81135d14 <usleep>
}
8110aa08:	0001883a 	nop
8110aa0c:	e037883a 	mov	sp,fp
8110aa10:	dfc00117 	ldw	ra,4(sp)
8110aa14:	df000017 	ldw	fp,0(sp)
8110aa18:	dec00204 	addi	sp,sp,8
8110aa1c:	f800283a 	ret

8110aa20 <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
8110aa20:	defffc04 	addi	sp,sp,-16
8110aa24:	de00012e 	bgeu	sp,et,8110aa2c <i2c_stop+0xc>
8110aa28:	003b68fa 	trap	3
8110aa2c:	dfc00315 	stw	ra,12(sp)
8110aa30:	df000215 	stw	fp,8(sp)
8110aa34:	df000204 	addi	fp,sp,8
8110aa38:	e13ffe15 	stw	r4,-8(fp)
8110aa3c:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
8110aa40:	e0bfff17 	ldw	r2,-4(fp)
8110aa44:	10800104 	addi	r2,r2,4
8110aa48:	1007883a 	mov	r3,r2
8110aa4c:	00800044 	movi	r2,1
8110aa50:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
8110aa54:	e0bfff17 	ldw	r2,-4(fp)
8110aa58:	0007883a 	mov	r3,zero
8110aa5c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
8110aa60:	e0bffe17 	ldw	r2,-8(fp)
8110aa64:	00c00044 	movi	r3,1
8110aa68:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
8110aa6c:	01000044 	movi	r4,1
8110aa70:	1135d140 	call	81135d14 <usleep>
    SDA_HIGH(data_base); // data high
8110aa74:	e0bfff17 	ldw	r2,-4(fp)
8110aa78:	00c00044 	movi	r3,1
8110aa7c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
8110aa80:	01000044 	movi	r4,1
8110aa84:	1135d140 	call	81135d14 <usleep>
    

    
}
8110aa88:	0001883a 	nop
8110aa8c:	e037883a 	mov	sp,fp
8110aa90:	dfc00117 	ldw	ra,4(sp)
8110aa94:	df000017 	ldw	fp,0(sp)
8110aa98:	dec00204 	addi	sp,sp,8
8110aa9c:	f800283a 	ret

8110aaa0 <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
8110aaa0:	defff804 	addi	sp,sp,-32
8110aaa4:	de00012e 	bgeu	sp,et,8110aaac <i2c_write+0xc>
8110aaa8:	003b68fa 	trap	3
8110aaac:	dfc00715 	stw	ra,28(sp)
8110aab0:	df000615 	stw	fp,24(sp)
8110aab4:	df000604 	addi	fp,sp,24
8110aab8:	e13ffd15 	stw	r4,-12(fp)
8110aabc:	e17ffe15 	stw	r5,-8(fp)
8110aac0:	3005883a 	mov	r2,r6
8110aac4:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
8110aac8:	00bfe004 	movi	r2,-128
8110aacc:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
8110aad0:	e0bffe17 	ldw	r2,-8(fp)
8110aad4:	10800104 	addi	r2,r2,4
8110aad8:	1007883a 	mov	r3,r2
8110aadc:	00800044 	movi	r2,1
8110aae0:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110aae4:	e03ffb15 	stw	zero,-20(fp)
8110aae8:	00001f06 	br	8110ab68 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110aaec:	e0bffd17 	ldw	r2,-12(fp)
8110aaf0:	0007883a 	mov	r3,zero
8110aaf4:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110aaf8:	e0ffff03 	ldbu	r3,-4(fp)
8110aafc:	e0bffa03 	ldbu	r2,-24(fp)
8110ab00:	1884703a 	and	r2,r3,r2
8110ab04:	10803fcc 	andi	r2,r2,255
8110ab08:	10000426 	beq	r2,zero,8110ab1c <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110ab0c:	e0bffe17 	ldw	r2,-8(fp)
8110ab10:	00c00044 	movi	r3,1
8110ab14:	10c00035 	stwio	r3,0(r2)
8110ab18:	00000306 	br	8110ab28 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110ab1c:	e0bffe17 	ldw	r2,-8(fp)
8110ab20:	0007883a 	mov	r3,zero
8110ab24:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110ab28:	e0bffa03 	ldbu	r2,-24(fp)
8110ab2c:	1004d07a 	srli	r2,r2,1
8110ab30:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110ab34:	e0bffd17 	ldw	r2,-12(fp)
8110ab38:	00c00044 	movi	r3,1
8110ab3c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110ab40:	01000044 	movi	r4,1
8110ab44:	1135d140 	call	81135d14 <usleep>
        SCL_LOW(clk_base);
8110ab48:	e0bffd17 	ldw	r2,-12(fp)
8110ab4c:	0007883a 	mov	r3,zero
8110ab50:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110ab54:	01000044 	movi	r4,1
8110ab58:	1135d140 	call	81135d14 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110ab5c:	e0bffb17 	ldw	r2,-20(fp)
8110ab60:	10800044 	addi	r2,r2,1
8110ab64:	e0bffb15 	stw	r2,-20(fp)
8110ab68:	e0bffb17 	ldw	r2,-20(fp)
8110ab6c:	10800210 	cmplti	r2,r2,8
8110ab70:	103fde1e 	bne	r2,zero,8110aaec <__reset+0xfb0eaaec>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110ab74:	e0bffe17 	ldw	r2,-8(fp)
8110ab78:	10800104 	addi	r2,r2,4
8110ab7c:	0007883a 	mov	r3,zero
8110ab80:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110ab84:	e0bffd17 	ldw	r2,-12(fp)
8110ab88:	00c00044 	movi	r3,1
8110ab8c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110ab90:	01000044 	movi	r4,1
8110ab94:	1135d140 	call	81135d14 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110ab98:	e0bffe17 	ldw	r2,-8(fp)
8110ab9c:	10800037 	ldwio	r2,0(r2)
8110aba0:	1005003a 	cmpeq	r2,r2,zero
8110aba4:	10803fcc 	andi	r2,r2,255
8110aba8:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110abac:	e0bffd17 	ldw	r2,-12(fp)
8110abb0:	0007883a 	mov	r3,zero
8110abb4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110abb8:	01000044 	movi	r4,1
8110abbc:	1135d140 	call	81135d14 <usleep>
    return bAck;
8110abc0:	e0bffc17 	ldw	r2,-16(fp)
}    
8110abc4:	e037883a 	mov	sp,fp
8110abc8:	dfc00117 	ldw	ra,4(sp)
8110abcc:	df000017 	ldw	fp,0(sp)
8110abd0:	dec00204 	addi	sp,sp,8
8110abd4:	f800283a 	ret

8110abd8 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110abd8:	defff804 	addi	sp,sp,-32
8110abdc:	de00012e 	bgeu	sp,et,8110abe4 <i2c_read+0xc>
8110abe0:	003b68fa 	trap	3
8110abe4:	dfc00715 	stw	ra,28(sp)
8110abe8:	df000615 	stw	fp,24(sp)
8110abec:	df000604 	addi	fp,sp,24
8110abf0:	e13ffc15 	stw	r4,-16(fp)
8110abf4:	e17ffd15 	stw	r5,-12(fp)
8110abf8:	e1bffe15 	stw	r6,-8(fp)
8110abfc:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110ac00:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110ac04:	e0bffd17 	ldw	r2,-12(fp)
8110ac08:	10800104 	addi	r2,r2,4
8110ac0c:	0007883a 	mov	r3,zero
8110ac10:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110ac14:	e0bffc17 	ldw	r2,-16(fp)
8110ac18:	0007883a 	mov	r3,zero
8110ac1c:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110ac20:	01000044 	movi	r4,1
8110ac24:	1135d140 	call	81135d14 <usleep>

    for(i=0;i<8;i++){
8110ac28:	e03ffb15 	stw	zero,-20(fp)
8110ac2c:	00001606 	br	8110ac88 <i2c_read+0xb0>
        Data <<= 1;
8110ac30:	e0bffa03 	ldbu	r2,-24(fp)
8110ac34:	1085883a 	add	r2,r2,r2
8110ac38:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110ac3c:	e0bffc17 	ldw	r2,-16(fp)
8110ac40:	00c00044 	movi	r3,1
8110ac44:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110ac48:	01000044 	movi	r4,1
8110ac4c:	1135d140 	call	81135d14 <usleep>
        if (SDA_READ(data_base))  // read data   
8110ac50:	e0bffd17 	ldw	r2,-12(fp)
8110ac54:	10800037 	ldwio	r2,0(r2)
8110ac58:	10000326 	beq	r2,zero,8110ac68 <i2c_read+0x90>
            Data |= 0x01;
8110ac5c:	e0bffa03 	ldbu	r2,-24(fp)
8110ac60:	10800054 	ori	r2,r2,1
8110ac64:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110ac68:	e0bffc17 	ldw	r2,-16(fp)
8110ac6c:	0007883a 	mov	r3,zero
8110ac70:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110ac74:	01000044 	movi	r4,1
8110ac78:	1135d140 	call	81135d14 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110ac7c:	e0bffb17 	ldw	r2,-20(fp)
8110ac80:	10800044 	addi	r2,r2,1
8110ac84:	e0bffb15 	stw	r2,-20(fp)
8110ac88:	e0bffb17 	ldw	r2,-20(fp)
8110ac8c:	10800210 	cmplti	r2,r2,8
8110ac90:	103fe71e 	bne	r2,zero,8110ac30 <__reset+0xfb0eac30>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110ac94:	e0bffc17 	ldw	r2,-16(fp)
8110ac98:	0007883a 	mov	r3,zero
8110ac9c:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110aca0:	e0bffd17 	ldw	r2,-12(fp)
8110aca4:	10800104 	addi	r2,r2,4
8110aca8:	1007883a 	mov	r3,r2
8110acac:	00800044 	movi	r2,1
8110acb0:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110acb4:	e0bfff17 	ldw	r2,-4(fp)
8110acb8:	10000426 	beq	r2,zero,8110accc <i2c_read+0xf4>
        SDA_LOW(data_base);
8110acbc:	e0bffd17 	ldw	r2,-12(fp)
8110acc0:	0007883a 	mov	r3,zero
8110acc4:	10c00035 	stwio	r3,0(r2)
8110acc8:	00000306 	br	8110acd8 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110accc:	e0bffd17 	ldw	r2,-12(fp)
8110acd0:	00c00044 	movi	r3,1
8110acd4:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110acd8:	e0bffc17 	ldw	r2,-16(fp)
8110acdc:	00c00044 	movi	r3,1
8110ace0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110ace4:	01000044 	movi	r4,1
8110ace8:	1135d140 	call	81135d14 <usleep>
    SCL_LOW(clk_base); // clock low
8110acec:	e0bffc17 	ldw	r2,-16(fp)
8110acf0:	0007883a 	mov	r3,zero
8110acf4:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110acf8:	01000044 	movi	r4,1
8110acfc:	1135d140 	call	81135d14 <usleep>
    SDA_LOW(data_base);  // data low
8110ad00:	e0bffd17 	ldw	r2,-12(fp)
8110ad04:	0007883a 	mov	r3,zero
8110ad08:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110ad0c:	01000044 	movi	r4,1
8110ad10:	1135d140 	call	81135d14 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110ad14:	e0bffe17 	ldw	r2,-8(fp)
8110ad18:	e0fffa03 	ldbu	r3,-24(fp)
8110ad1c:	10c00005 	stb	r3,0(r2)
}
8110ad20:	0001883a 	nop
8110ad24:	e037883a 	mov	sp,fp
8110ad28:	dfc00117 	ldw	ra,4(sp)
8110ad2c:	df000017 	ldw	fp,0(sp)
8110ad30:	dec00204 	addi	sp,sp,8
8110ad34:	f800283a 	ret

8110ad38 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110ad38:	defffd04 	addi	sp,sp,-12
8110ad3c:	de00012e 	bgeu	sp,et,8110ad44 <bSetBoardLeds+0xc>
8110ad40:	003b68fa 	trap	3
8110ad44:	df000215 	stw	fp,8(sp)
8110ad48:	df000204 	addi	fp,sp,8
8110ad4c:	e13ffe15 	stw	r4,-8(fp)
8110ad50:	2805883a 	mov	r2,r5
8110ad54:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110ad58:	e0bffe17 	ldw	r2,-8(fp)
8110ad5c:	10800058 	cmpnei	r2,r2,1
8110ad60:	1000071e 	bne	r2,zero,8110ad80 <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110ad64:	e0bfff03 	ldbu	r2,-4(fp)
8110ad68:	0084303a 	nor	r2,zero,r2
8110ad6c:	1007883a 	mov	r3,r2
8110ad70:	d0a05003 	ldbu	r2,-32448(gp)
8110ad74:	1884703a 	and	r2,r3,r2
8110ad78:	d0a05005 	stb	r2,-32448(gp)
8110ad7c:	00000406 	br	8110ad90 <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110ad80:	d0e05003 	ldbu	r3,-32448(gp)
8110ad84:	e0bfff03 	ldbu	r2,-4(fp)
8110ad88:	1884b03a 	or	r2,r3,r2
8110ad8c:	d0a05005 	stb	r2,-32448(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110ad90:	d0a05003 	ldbu	r2,-32448(gp)
8110ad94:	10c03fcc 	andi	r3,r2,255
8110ad98:	00a00034 	movhi	r2,32768
8110ad9c:	10827404 	addi	r2,r2,2512
8110ada0:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110ada4:	00800044 	movi	r2,1
}
8110ada8:	e037883a 	mov	sp,fp
8110adac:	df000017 	ldw	fp,0(sp)
8110adb0:	dec00104 	addi	sp,sp,4
8110adb4:	f800283a 	ret

8110adb8 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110adb8:	defffd04 	addi	sp,sp,-12
8110adbc:	de00012e 	bgeu	sp,et,8110adc4 <bSetPainelLeds+0xc>
8110adc0:	003b68fa 	trap	3
8110adc4:	df000215 	stw	fp,8(sp)
8110adc8:	df000204 	addi	fp,sp,8
8110adcc:	e13ffe15 	stw	r4,-8(fp)
8110add0:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110add4:	e0bffe17 	ldw	r2,-8(fp)
8110add8:	10800058 	cmpnei	r2,r2,1
8110addc:	1000051e 	bne	r2,zero,8110adf4 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110ade0:	d0e00217 	ldw	r3,-32760(gp)
8110ade4:	e0bfff17 	ldw	r2,-4(fp)
8110ade8:	1884b03a 	or	r2,r3,r2
8110adec:	d0a00215 	stw	r2,-32760(gp)
8110adf0:	00000506 	br	8110ae08 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110adf4:	e0bfff17 	ldw	r2,-4(fp)
8110adf8:	0086303a 	nor	r3,zero,r2
8110adfc:	d0a00217 	ldw	r2,-32760(gp)
8110ae00:	1884703a 	and	r2,r3,r2
8110ae04:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110ae08:	d0a00217 	ldw	r2,-32760(gp)
8110ae0c:	1007883a 	mov	r3,r2
8110ae10:	00a00034 	movhi	r2,32768
8110ae14:	10824004 	addi	r2,r2,2304
8110ae18:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110ae1c:	00800044 	movi	r2,1
}
8110ae20:	e037883a 	mov	sp,fp
8110ae24:	df000017 	ldw	fp,0(sp)
8110ae28:	dec00104 	addi	sp,sp,4
8110ae2c:	f800283a 	ret

8110ae30 <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110ae30:	defffc04 	addi	sp,sp,-16
8110ae34:	de00012e 	bgeu	sp,et,8110ae3c <msgdma_write_extended_descriptor+0xc>
8110ae38:	003b68fa 	trap	3
8110ae3c:	df000315 	stw	fp,12(sp)
8110ae40:	df000304 	addi	fp,sp,12
8110ae44:	e13ffd15 	stw	r4,-12(fp)
8110ae48:	e17ffe15 	stw	r5,-8(fp)
8110ae4c:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110ae50:	e0bffd17 	ldw	r2,-12(fp)
8110ae54:	10800037 	ldwio	r2,0(r2)
8110ae58:	1080010c 	andi	r2,r2,4
8110ae5c:	10000226 	beq	r2,zero,8110ae68 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110ae60:	00bff904 	movi	r2,-28
8110ae64:	00003d06 	br	8110af5c <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110ae68:	e0bfff17 	ldw	r2,-4(fp)
8110ae6c:	10800017 	ldw	r2,0(r2)
8110ae70:	1007883a 	mov	r3,r2
8110ae74:	e0bffe17 	ldw	r2,-8(fp)
8110ae78:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110ae7c:	e0bffe17 	ldw	r2,-8(fp)
8110ae80:	10800104 	addi	r2,r2,4
8110ae84:	e0ffff17 	ldw	r3,-4(fp)
8110ae88:	18c00117 	ldw	r3,4(r3)
8110ae8c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110ae90:	e0bffe17 	ldw	r2,-8(fp)
8110ae94:	10800204 	addi	r2,r2,8
8110ae98:	e0ffff17 	ldw	r3,-4(fp)
8110ae9c:	18c00217 	ldw	r3,8(r3)
8110aea0:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110aea4:	e0bffe17 	ldw	r2,-8(fp)
8110aea8:	10800304 	addi	r2,r2,12
8110aeac:	e0ffff17 	ldw	r3,-4(fp)
8110aeb0:	18c0030b 	ldhu	r3,12(r3)
8110aeb4:	18ffffcc 	andi	r3,r3,65535
8110aeb8:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110aebc:	e0bffe17 	ldw	r2,-8(fp)
8110aec0:	10800384 	addi	r2,r2,14
8110aec4:	e0ffff17 	ldw	r3,-4(fp)
8110aec8:	18c00383 	ldbu	r3,14(r3)
8110aecc:	18c03fcc 	andi	r3,r3,255
8110aed0:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110aed4:	e0bffe17 	ldw	r2,-8(fp)
8110aed8:	108003c4 	addi	r2,r2,15
8110aedc:	e0ffff17 	ldw	r3,-4(fp)
8110aee0:	18c003c3 	ldbu	r3,15(r3)
8110aee4:	18c03fcc 	andi	r3,r3,255
8110aee8:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110aeec:	e0bffe17 	ldw	r2,-8(fp)
8110aef0:	10800404 	addi	r2,r2,16
8110aef4:	e0ffff17 	ldw	r3,-4(fp)
8110aef8:	18c0040b 	ldhu	r3,16(r3)
8110aefc:	18ffffcc 	andi	r3,r3,65535
8110af00:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110af04:	e0bffe17 	ldw	r2,-8(fp)
8110af08:	10800484 	addi	r2,r2,18
8110af0c:	e0ffff17 	ldw	r3,-4(fp)
8110af10:	18c0048b 	ldhu	r3,18(r3)
8110af14:	18ffffcc 	andi	r3,r3,65535
8110af18:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110af1c:	e0bffe17 	ldw	r2,-8(fp)
8110af20:	10800504 	addi	r2,r2,20
8110af24:	e0ffff17 	ldw	r3,-4(fp)
8110af28:	18c00517 	ldw	r3,20(r3)
8110af2c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110af30:	e0bffe17 	ldw	r2,-8(fp)
8110af34:	10800604 	addi	r2,r2,24
8110af38:	e0ffff17 	ldw	r3,-4(fp)
8110af3c:	18c00617 	ldw	r3,24(r3)
8110af40:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110af44:	e0bffe17 	ldw	r2,-8(fp)
8110af48:	10800704 	addi	r2,r2,28
8110af4c:	e0ffff17 	ldw	r3,-4(fp)
8110af50:	18c00717 	ldw	r3,28(r3)
8110af54:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110af58:	0005883a 	mov	r2,zero
}
8110af5c:	e037883a 	mov	sp,fp
8110af60:	df000017 	ldw	fp,0(sp)
8110af64:	dec00104 	addi	sp,sp,4
8110af68:	f800283a 	ret

8110af6c <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110af6c:	defff604 	addi	sp,sp,-40
8110af70:	de00012e 	bgeu	sp,et,8110af78 <msgdma_construct_extended_descriptor+0xc>
8110af74:	003b68fa 	trap	3
8110af78:	df000915 	stw	fp,36(sp)
8110af7c:	df000904 	addi	fp,sp,36
8110af80:	e13ff715 	stw	r4,-36(fp)
8110af84:	e17ff815 	stw	r5,-32(fp)
8110af88:	e1bff915 	stw	r6,-28(fp)
8110af8c:	e1fffa15 	stw	r7,-24(fp)
8110af90:	e1800517 	ldw	r6,20(fp)
8110af94:	e1400617 	ldw	r5,24(fp)
8110af98:	e1000717 	ldw	r4,28(fp)
8110af9c:	e0c00817 	ldw	r3,32(fp)
8110afa0:	e0800917 	ldw	r2,36(fp)
8110afa4:	e1bffb0d 	sth	r6,-20(fp)
8110afa8:	e17ffc05 	stb	r5,-16(fp)
8110afac:	e13ffd05 	stb	r4,-12(fp)
8110afb0:	e0fffe0d 	sth	r3,-8(fp)
8110afb4:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110afb8:	e0bff717 	ldw	r2,-36(fp)
8110afbc:	10c01217 	ldw	r3,72(r2)
8110afc0:	e0800117 	ldw	r2,4(fp)
8110afc4:	18801936 	bltu	r3,r2,8110b02c <msgdma_construct_extended_descriptor+0xc0>
8110afc8:	e13ff717 	ldw	r4,-36(fp)
8110afcc:	20801317 	ldw	r2,76(r4)
8110afd0:	20c01417 	ldw	r3,80(r4)
8110afd4:	e13ffe0b 	ldhu	r4,-8(fp)
8110afd8:	213fffcc 	andi	r4,r4,65535
8110afdc:	2015883a 	mov	r10,r4
8110afe0:	0017883a 	mov	r11,zero
8110afe4:	1ac01136 	bltu	r3,r11,8110b02c <msgdma_construct_extended_descriptor+0xc0>
8110afe8:	58c0011e 	bne	r11,r3,8110aff0 <msgdma_construct_extended_descriptor+0x84>
8110afec:	12800f36 	bltu	r2,r10,8110b02c <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110aff0:	e13ff717 	ldw	r4,-36(fp)
8110aff4:	20801317 	ldw	r2,76(r4)
8110aff8:	20c01417 	ldw	r3,80(r4)
8110affc:	e13fff0b 	ldhu	r4,-4(fp)
8110b000:	213fffcc 	andi	r4,r4,65535
8110b004:	2011883a 	mov	r8,r4
8110b008:	0013883a 	mov	r9,zero
8110b00c:	1a400736 	bltu	r3,r9,8110b02c <msgdma_construct_extended_descriptor+0xc0>
8110b010:	48c0011e 	bne	r9,r3,8110b018 <msgdma_construct_extended_descriptor+0xac>
8110b014:	12000536 	bltu	r2,r8,8110b02c <msgdma_construct_extended_descriptor+0xc0>
8110b018:	e0bff717 	ldw	r2,-36(fp)
8110b01c:	10801703 	ldbu	r2,92(r2)
8110b020:	10803fcc 	andi	r2,r2,255
8110b024:	10800060 	cmpeqi	r2,r2,1
8110b028:	1000021e 	bne	r2,zero,8110b034 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110b02c:	00bffa84 	movi	r2,-22
8110b030:	00002306 	br	8110b0c0 <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110b034:	e0bff817 	ldw	r2,-32(fp)
8110b038:	e0fff917 	ldw	r3,-28(fp)
8110b03c:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110b040:	e0bff817 	ldw	r2,-32(fp)
8110b044:	e0fffa17 	ldw	r3,-24(fp)
8110b048:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110b04c:	e0bff817 	ldw	r2,-32(fp)
8110b050:	e0c00117 	ldw	r3,4(fp)
8110b054:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110b058:	e0bff817 	ldw	r2,-32(fp)
8110b05c:	e0fffb0b 	ldhu	r3,-20(fp)
8110b060:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110b064:	e0bff817 	ldw	r2,-32(fp)
8110b068:	e0fffc03 	ldbu	r3,-16(fp)
8110b06c:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110b070:	e0bff817 	ldw	r2,-32(fp)
8110b074:	e0fffd03 	ldbu	r3,-12(fp)
8110b078:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110b07c:	e0bff817 	ldw	r2,-32(fp)
8110b080:	e0fffe0b 	ldhu	r3,-8(fp)
8110b084:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110b088:	e0bff817 	ldw	r2,-32(fp)
8110b08c:	e0ffff0b 	ldhu	r3,-4(fp)
8110b090:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110b094:	e0bff817 	ldw	r2,-32(fp)
8110b098:	e0c00317 	ldw	r3,12(fp)
8110b09c:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110b0a0:	e0bff817 	ldw	r2,-32(fp)
8110b0a4:	e0c00417 	ldw	r3,16(fp)
8110b0a8:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110b0ac:	e0800217 	ldw	r2,8(fp)
8110b0b0:	10e00034 	orhi	r3,r2,32768
8110b0b4:	e0bff817 	ldw	r2,-32(fp)
8110b0b8:	10c00715 	stw	r3,28(r2)

	return 0;
8110b0bc:	0005883a 	mov	r2,zero

}
8110b0c0:	e037883a 	mov	sp,fp
8110b0c4:	df000017 	ldw	fp,0(sp)
8110b0c8:	dec00104 	addi	sp,sp,4
8110b0cc:	f800283a 	ret

8110b0d0 <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b0d0:	deffee04 	addi	sp,sp,-72
8110b0d4:	de00012e 	bgeu	sp,et,8110b0dc <msgdma_descriptor_async_transfer+0xc>
8110b0d8:	003b68fa 	trap	3
8110b0dc:	dfc01115 	stw	ra,68(sp)
8110b0e0:	df001015 	stw	fp,64(sp)
8110b0e4:	df001004 	addi	fp,sp,64
8110b0e8:	e13ffd15 	stw	r4,-12(fp)
8110b0ec:	e17ffe15 	stw	r5,-8(fp)
8110b0f0:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b0f4:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110b0f8:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110b0fc:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b100:	e0bffd17 	ldw	r2,-12(fp)
8110b104:	10800317 	ldw	r2,12(r2)
8110b108:	10800204 	addi	r2,r2,8
8110b10c:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b110:	10bfffcc 	andi	r2,r2,65535
8110b114:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b118:	e0bffd17 	ldw	r2,-12(fp)
8110b11c:	10800317 	ldw	r2,12(r2)
8110b120:	10800204 	addi	r2,r2,8
8110b124:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b128:	1004d43a 	srli	r2,r2,16
8110b12c:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b130:	e0bffd17 	ldw	r2,-12(fp)
8110b134:	10800917 	ldw	r2,36(r2)
8110b138:	e0fff417 	ldw	r3,-48(fp)
8110b13c:	1880042e 	bgeu	r3,r2,8110b150 <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b140:	e0bffd17 	ldw	r2,-12(fp)
8110b144:	10800917 	ldw	r2,36(r2)
8110b148:	e0fff317 	ldw	r3,-52(fp)
8110b14c:	18800236 	bltu	r3,r2,8110b158 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110b150:	00bff904 	movi	r2,-28
8110b154:	00009f06 	br	8110b3d4 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b158:	e0bffd17 	ldw	r2,-12(fp)
8110b15c:	10801817 	ldw	r2,96(r2)
8110b160:	e0bff615 	stw	r2,-40(fp)
8110b164:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110b168:	e0bffc0b 	ldhu	r2,-16(fp)
8110b16c:	e0fffc84 	addi	r3,fp,-14
8110b170:	180d883a 	mov	r6,r3
8110b174:	100b883a 	mov	r5,r2
8110b178:	e13ff617 	ldw	r4,-40(fp)
8110b17c:	113cb180 	call	8113cb18 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110b180:	00800804 	movi	r2,32
8110b184:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b188:	0005303a 	rdctl	r2,status
8110b18c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b190:	e0fff717 	ldw	r3,-36(fp)
8110b194:	00bfff84 	movi	r2,-2
8110b198:	1884703a 	and	r2,r3,r2
8110b19c:	1001703a 	wrctl	status,r2
  
  return context;
8110b1a0:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b1a4:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b1a8:	e0bffd17 	ldw	r2,-12(fp)
8110b1ac:	10800317 	ldw	r2,12(r2)
8110b1b0:	10800104 	addi	r2,r2,4
8110b1b4:	e0fff117 	ldw	r3,-60(fp)
8110b1b8:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b1bc:	e0bffd17 	ldw	r2,-12(fp)
8110b1c0:	10800317 	ldw	r2,12(r2)
8110b1c4:	e0fffd17 	ldw	r3,-12(fp)
8110b1c8:	18c00317 	ldw	r3,12(r3)
8110b1cc:	18c00037 	ldwio	r3,0(r3)
8110b1d0:	10c00035 	stwio	r3,0(r2)
8110b1d4:	e0bff217 	ldw	r2,-56(fp)
8110b1d8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b1dc:	e0bffb17 	ldw	r2,-20(fp)
8110b1e0:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110b1e4:	e0bffe17 	ldw	r2,-8(fp)
8110b1e8:	10001026 	beq	r2,zero,8110b22c <msgdma_descriptor_async_transfer+0x15c>
8110b1ec:	e0bfff17 	ldw	r2,-4(fp)
8110b1f0:	10000e1e 	bne	r2,zero,8110b22c <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110b1f4:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b1f8:	d0a06117 	ldw	r2,-32380(gp)
8110b1fc:	100f883a 	mov	r7,r2
8110b200:	01800784 	movi	r6,30
8110b204:	01400044 	movi	r5,1
8110b208:	01204574 	movhi	r4,33045
8110b20c:	21291c04 	addi	r4,r4,-23440
8110b210:	111fc980 	call	8111fc98 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b214:	e0bffd17 	ldw	r2,-12(fp)
8110b218:	10801817 	ldw	r2,96(r2)
8110b21c:	1009883a 	mov	r4,r2
8110b220:	113cea00 	call	8113cea0 <OSSemPost>

		return -ETIME;
8110b224:	00bff084 	movi	r2,-62
8110b228:	00006a06 	br	8110b3d4 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b22c:	e0bffe17 	ldw	r2,-8(fp)
8110b230:	1000231e 	bne	r2,zero,8110b2c0 <msgdma_descriptor_async_transfer+0x1f0>
8110b234:	e0bfff17 	ldw	r2,-4(fp)
8110b238:	10002126 	beq	r2,zero,8110b2c0 <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110b23c:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b240:	00001506 	br	8110b298 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b244:	01000044 	movi	r4,1
8110b248:	11342a00 	call	811342a0 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b24c:	e0bff00b 	ldhu	r2,-64(fp)
8110b250:	1084e230 	cmpltui	r2,r2,5000
8110b254:	10000d1e 	bne	r2,zero,8110b28c <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b258:	d0a06117 	ldw	r2,-32380(gp)
8110b25c:	100f883a 	mov	r7,r2
8110b260:	01801544 	movi	r6,85
8110b264:	01400044 	movi	r5,1
8110b268:	01204574 	movhi	r4,33045
8110b26c:	21292404 	addi	r4,r4,-23408
8110b270:	111fc980 	call	8111fc98 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b274:	e0bffd17 	ldw	r2,-12(fp)
8110b278:	10801817 	ldw	r2,96(r2)
8110b27c:	1009883a 	mov	r4,r2
8110b280:	113cea00 	call	8113cea0 <OSSemPost>

				return -ETIME;
8110b284:	00bff084 	movi	r2,-62
8110b288:	00005206 	br	8110b3d4 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110b28c:	e0bff00b 	ldhu	r2,-64(fp)
8110b290:	10800044 	addi	r2,r2,1
8110b294:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b298:	e0bffd17 	ldw	r2,-12(fp)
8110b29c:	10c00317 	ldw	r3,12(r2)
8110b2a0:	e0bffd17 	ldw	r2,-12(fp)
8110b2a4:	10800417 	ldw	r2,16(r2)
8110b2a8:	e1bfff17 	ldw	r6,-4(fp)
8110b2ac:	100b883a 	mov	r5,r2
8110b2b0:	1809883a 	mov	r4,r3
8110b2b4:	110ae300 	call	8110ae30 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b2b8:	103fe21e 	bne	r2,zero,8110b244 <__reset+0xfb0eb244>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b2bc:	00000606 	br	8110b2d8 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b2c0:	e0bffd17 	ldw	r2,-12(fp)
8110b2c4:	10801817 	ldw	r2,96(r2)
8110b2c8:	1009883a 	mov	r4,r2
8110b2cc:	113cea00 	call	8113cea0 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b2d0:	00bfffc4 	movi	r2,-1
8110b2d4:	00003f06 	br	8110b3d4 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110b2d8:	e0bffd17 	ldw	r2,-12(fp)
8110b2dc:	10800b17 	ldw	r2,44(r2)
8110b2e0:	10001c26 	beq	r2,zero,8110b354 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110b2e4:	e0bffd17 	ldw	r2,-12(fp)
8110b2e8:	10c00d17 	ldw	r3,52(r2)
8110b2ec:	e0bff117 	ldw	r2,-60(fp)
8110b2f0:	1884b03a 	or	r2,r3,r2
8110b2f4:	10800514 	ori	r2,r2,20
8110b2f8:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110b2fc:	e0fff117 	ldw	r3,-60(fp)
8110b300:	00bff7c4 	movi	r2,-33
8110b304:	1884703a 	and	r2,r3,r2
8110b308:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b30c:	0005303a 	rdctl	r2,status
8110b310:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b314:	e0fff917 	ldw	r3,-28(fp)
8110b318:	00bfff84 	movi	r2,-2
8110b31c:	1884703a 	and	r2,r3,r2
8110b320:	1001703a 	wrctl	status,r2
  
  return context;
8110b324:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b328:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b32c:	e0bffd17 	ldw	r2,-12(fp)
8110b330:	10800317 	ldw	r2,12(r2)
8110b334:	10800104 	addi	r2,r2,4
8110b338:	e0fff117 	ldw	r3,-60(fp)
8110b33c:	10c00035 	stwio	r3,0(r2)
8110b340:	e0bff217 	ldw	r2,-56(fp)
8110b344:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b348:	e0bff517 	ldw	r2,-44(fp)
8110b34c:	1001703a 	wrctl	status,r2
8110b350:	00001b06 	br	8110b3c0 <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110b354:	e0bffd17 	ldw	r2,-12(fp)
8110b358:	10c00d17 	ldw	r3,52(r2)
8110b35c:	e0bff117 	ldw	r2,-60(fp)
8110b360:	1884b03a 	or	r2,r3,r2
8110b364:	10800114 	ori	r2,r2,4
8110b368:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110b36c:	e0fff117 	ldw	r3,-60(fp)
8110b370:	00bff3c4 	movi	r2,-49
8110b374:	1884703a 	and	r2,r3,r2
8110b378:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b37c:	0005303a 	rdctl	r2,status
8110b380:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b384:	e0fffa17 	ldw	r3,-24(fp)
8110b388:	00bfff84 	movi	r2,-2
8110b38c:	1884703a 	and	r2,r3,r2
8110b390:	1001703a 	wrctl	status,r2
  
  return context;
8110b394:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110b398:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b39c:	e0bffd17 	ldw	r2,-12(fp)
8110b3a0:	10800317 	ldw	r2,12(r2)
8110b3a4:	10800104 	addi	r2,r2,4
8110b3a8:	e0fff117 	ldw	r3,-60(fp)
8110b3ac:	10c00035 	stwio	r3,0(r2)
8110b3b0:	e0bff217 	ldw	r2,-56(fp)
8110b3b4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b3b8:	e0bff817 	ldw	r2,-32(fp)
8110b3bc:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b3c0:	e0bffd17 	ldw	r2,-12(fp)
8110b3c4:	10801817 	ldw	r2,96(r2)
8110b3c8:	1009883a 	mov	r4,r2
8110b3cc:	113cea00 	call	8113cea0 <OSSemPost>

	return 0;
8110b3d0:	0005883a 	mov	r2,zero
}
8110b3d4:	e037883a 	mov	sp,fp
8110b3d8:	dfc00117 	ldw	ra,4(sp)
8110b3dc:	df000017 	ldw	fp,0(sp)
8110b3e0:	dec00204 	addi	sp,sp,8
8110b3e4:	f800283a 	ret

8110b3e8 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110b3e8:	deffee04 	addi	sp,sp,-72
8110b3ec:	de00012e 	bgeu	sp,et,8110b3f4 <msgdma_descriptor_sync_transfer+0xc>
8110b3f0:	003b68fa 	trap	3
8110b3f4:	dfc01115 	stw	ra,68(sp)
8110b3f8:	df001015 	stw	fp,64(sp)
8110b3fc:	df001004 	addi	fp,sp,64
8110b400:	e13ffd15 	stw	r4,-12(fp)
8110b404:	e17ffe15 	stw	r5,-8(fp)
8110b408:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110b40c:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110b410:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110b414:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110b418:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b41c:	e0bffd17 	ldw	r2,-12(fp)
8110b420:	10800317 	ldw	r2,12(r2)
8110b424:	10800204 	addi	r2,r2,8
8110b428:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110b42c:	10bfffcc 	andi	r2,r2,65535
8110b430:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b434:	e0bffd17 	ldw	r2,-12(fp)
8110b438:	10800317 	ldw	r2,12(r2)
8110b43c:	10800204 	addi	r2,r2,8
8110b440:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110b444:	1004d43a 	srli	r2,r2,16
8110b448:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110b44c:	00807804 	movi	r2,480
8110b450:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b454:	00001d06 	br	8110b4cc <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110b458:	01000044 	movi	r4,1
8110b45c:	11342a00 	call	811342a0 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b460:	e0bff10b 	ldhu	r2,-60(fp)
8110b464:	1084e230 	cmpltui	r2,r2,5000
8110b468:	1000091e 	bne	r2,zero,8110b490 <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b46c:	d0a06117 	ldw	r2,-32380(gp)
8110b470:	100f883a 	mov	r7,r2
8110b474:	01801304 	movi	r6,76
8110b478:	01400044 	movi	r5,1
8110b47c:	01204574 	movhi	r4,33045
8110b480:	21293a04 	addi	r4,r4,-23320
8110b484:	111fc980 	call	8111fc98 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110b488:	00bff084 	movi	r2,-62
8110b48c:	0000d006 	br	8110b7d0 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110b490:	e0bff10b 	ldhu	r2,-60(fp)
8110b494:	10800044 	addi	r2,r2,1
8110b498:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b49c:	e0bffd17 	ldw	r2,-12(fp)
8110b4a0:	10800317 	ldw	r2,12(r2)
8110b4a4:	10800204 	addi	r2,r2,8
8110b4a8:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110b4ac:	10bfffcc 	andi	r2,r2,65535
8110b4b0:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110b4b4:	e0bffd17 	ldw	r2,-12(fp)
8110b4b8:	10800317 	ldw	r2,12(r2)
8110b4bc:	10800204 	addi	r2,r2,8
8110b4c0:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110b4c4:	1004d43a 	srli	r2,r2,16
8110b4c8:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110b4cc:	e0bffd17 	ldw	r2,-12(fp)
8110b4d0:	10800917 	ldw	r2,36(r2)
8110b4d4:	e0fff317 	ldw	r3,-52(fp)
8110b4d8:	18bfdf2e 	bgeu	r3,r2,8110b458 <__reset+0xfb0eb458>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110b4dc:	e0bffd17 	ldw	r2,-12(fp)
8110b4e0:	10800917 	ldw	r2,36(r2)
8110b4e4:	e0fff217 	ldw	r3,-56(fp)
8110b4e8:	18bfdb2e 	bgeu	r3,r2,8110b458 <__reset+0xfb0eb458>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110b4ec:	e0bffd17 	ldw	r2,-12(fp)
8110b4f0:	10801817 	ldw	r2,96(r2)
8110b4f4:	e0bff815 	stw	r2,-32(fp)
8110b4f8:	e03ffc0d 	sth	zero,-16(fp)
8110b4fc:	e0bffc0b 	ldhu	r2,-16(fp)
8110b500:	e0fffc84 	addi	r3,fp,-14
8110b504:	180d883a 	mov	r6,r3
8110b508:	100b883a 	mov	r5,r2
8110b50c:	e13ff817 	ldw	r4,-32(fp)
8110b510:	113cb180 	call	8113cb18 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b514:	0005303a 	rdctl	r2,status
8110b518:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b51c:	e0fffb17 	ldw	r3,-20(fp)
8110b520:	00bfff84 	movi	r2,-2
8110b524:	1884703a 	and	r2,r3,r2
8110b528:	1001703a 	wrctl	status,r2
  
  return context;
8110b52c:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b530:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110b534:	e0bffd17 	ldw	r2,-12(fp)
8110b538:	10800317 	ldw	r2,12(r2)
8110b53c:	10800104 	addi	r2,r2,4
8110b540:	00c00804 	movi	r3,32
8110b544:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b548:	e0bffd17 	ldw	r2,-12(fp)
8110b54c:	10800317 	ldw	r2,12(r2)
8110b550:	e0fffd17 	ldw	r3,-12(fp)
8110b554:	18c00317 	ldw	r3,12(r3)
8110b558:	18c00037 	ldwio	r3,0(r3)
8110b55c:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110b560:	e0bffe17 	ldw	r2,-8(fp)
8110b564:	10001026 	beq	r2,zero,8110b5a8 <msgdma_descriptor_sync_transfer+0x1c0>
8110b568:	e0bfff17 	ldw	r2,-4(fp)
8110b56c:	10000e1e 	bne	r2,zero,8110b5a8 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110b570:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110b574:	d0a06117 	ldw	r2,-32380(gp)
8110b578:	100f883a 	mov	r7,r2
8110b57c:	01800784 	movi	r6,30
8110b580:	01400044 	movi	r5,1
8110b584:	01204574 	movhi	r4,33045
8110b588:	21291c04 	addi	r4,r4,-23440
8110b58c:	111fc980 	call	8111fc98 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b590:	e0bffd17 	ldw	r2,-12(fp)
8110b594:	10801817 	ldw	r2,96(r2)
8110b598:	1009883a 	mov	r4,r2
8110b59c:	113cea00 	call	8113cea0 <OSSemPost>

		return -ETIME;
8110b5a0:	00bff084 	movi	r2,-62
8110b5a4:	00008a06 	br	8110b7d0 <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b5a8:	e0bffe17 	ldw	r2,-8(fp)
8110b5ac:	1000231e 	bne	r2,zero,8110b63c <msgdma_descriptor_sync_transfer+0x254>
8110b5b0:	e0bfff17 	ldw	r2,-4(fp)
8110b5b4:	10002126 	beq	r2,zero,8110b63c <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110b5b8:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b5bc:	00001506 	br	8110b614 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110b5c0:	01000044 	movi	r4,1
8110b5c4:	11342a00 	call	811342a0 <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b5c8:	e0bff10b 	ldhu	r2,-60(fp)
8110b5cc:	1084e230 	cmpltui	r2,r2,5000
8110b5d0:	10000d1e 	bne	r2,zero,8110b608 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110b5d4:	d0a06117 	ldw	r2,-32380(gp)
8110b5d8:	100f883a 	mov	r7,r2
8110b5dc:	01801004 	movi	r6,64
8110b5e0:	01400044 	movi	r5,1
8110b5e4:	01204574 	movhi	r4,33045
8110b5e8:	21294e04 	addi	r4,r4,-23240
8110b5ec:	111fc980 	call	8111fc98 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110b5f0:	e0bffd17 	ldw	r2,-12(fp)
8110b5f4:	10801817 	ldw	r2,96(r2)
8110b5f8:	1009883a 	mov	r4,r2
8110b5fc:	113cea00 	call	8113cea0 <OSSemPost>

				return -ETIME;
8110b600:	00bff084 	movi	r2,-62
8110b604:	00007206 	br	8110b7d0 <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110b608:	e0bff10b 	ldhu	r2,-60(fp)
8110b60c:	10800044 	addi	r2,r2,1
8110b610:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110b614:	e0bffd17 	ldw	r2,-12(fp)
8110b618:	10c00317 	ldw	r3,12(r2)
8110b61c:	e0bffd17 	ldw	r2,-12(fp)
8110b620:	10800417 	ldw	r2,16(r2)
8110b624:	e1bfff17 	ldw	r6,-4(fp)
8110b628:	100b883a 	mov	r5,r2
8110b62c:	1809883a 	mov	r4,r3
8110b630:	110ae300 	call	8110ae30 <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110b634:	103fe21e 	bne	r2,zero,8110b5c0 <__reset+0xfb0eb5c0>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110b638:	00000606 	br	8110b654 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b63c:	e0bffd17 	ldw	r2,-12(fp)
8110b640:	10801817 	ldw	r2,96(r2)
8110b644:	1009883a 	mov	r4,r2
8110b648:	113cea00 	call	8113cea0 <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110b64c:	00bfffc4 	movi	r2,-1
8110b650:	00005f06 	br	8110b7d0 <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110b654:	e0bffd17 	ldw	r2,-12(fp)
8110b658:	10800317 	ldw	r2,12(r2)
8110b65c:	10800104 	addi	r2,r2,4
8110b660:	e0fffd17 	ldw	r3,-12(fp)
8110b664:	19000d17 	ldw	r4,52(r3)
8110b668:	00fff2c4 	movi	r3,-53
8110b66c:	20c6703a 	and	r3,r4,r3
8110b670:	18c00114 	ori	r3,r3,4
8110b674:	10c00035 	stwio	r3,0(r2)
8110b678:	e0bff517 	ldw	r2,-44(fp)
8110b67c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b680:	e0bff717 	ldw	r2,-36(fp)
8110b684:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110b688:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110b68c:	e0bffd17 	ldw	r2,-12(fp)
8110b690:	10800317 	ldw	r2,12(r2)
8110b694:	10800037 	ldwio	r2,0(r2)
8110b698:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110b69c:	00001906 	br	8110b704 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110b6a0:	01000044 	movi	r4,1
8110b6a4:	11342a00 	call	811342a0 <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110b6a8:	e0bff10b 	ldhu	r2,-60(fp)
8110b6ac:	1084e230 	cmpltui	r2,r2,5000
8110b6b0:	10000d1e 	bne	r2,zero,8110b6e8 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110b6b4:	d0a06117 	ldw	r2,-32380(gp)
8110b6b8:	100f883a 	mov	r7,r2
8110b6bc:	01801184 	movi	r6,70
8110b6c0:	01400044 	movi	r5,1
8110b6c4:	01204574 	movhi	r4,33045
8110b6c8:	21295f04 	addi	r4,r4,-23172
8110b6cc:	111fc980 	call	8111fc98 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110b6d0:	e0bffd17 	ldw	r2,-12(fp)
8110b6d4:	10801817 	ldw	r2,96(r2)
8110b6d8:	1009883a 	mov	r4,r2
8110b6dc:	113cea00 	call	8113cea0 <OSSemPost>

			return -ETIME;
8110b6e0:	00bff084 	movi	r2,-62
8110b6e4:	00003a06 	br	8110b7d0 <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110b6e8:	e0bff10b 	ldhu	r2,-60(fp)
8110b6ec:	10800044 	addi	r2,r2,1
8110b6f0:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110b6f4:	e0bffd17 	ldw	r2,-12(fp)
8110b6f8:	10800317 	ldw	r2,12(r2)
8110b6fc:	10800037 	ldwio	r2,0(r2)
8110b700:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110b704:	e0fff017 	ldw	r3,-64(fp)
8110b708:	e0bff617 	ldw	r2,-40(fp)
8110b70c:	1884703a 	and	r2,r3,r2
8110b710:	1000031e 	bne	r2,zero,8110b720 <msgdma_descriptor_sync_transfer+0x338>
8110b714:	e0bff017 	ldw	r2,-64(fp)
8110b718:	1080004c 	andi	r2,r2,1
8110b71c:	103fe01e 	bne	r2,zero,8110b6a0 <__reset+0xfb0eb6a0>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110b720:	e0fff017 	ldw	r3,-64(fp)
8110b724:	e0bff617 	ldw	r2,-40(fp)
8110b728:	1884703a 	and	r2,r3,r2
8110b72c:	10000626 	beq	r2,zero,8110b748 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110b730:	e0bffd17 	ldw	r2,-12(fp)
8110b734:	10801817 	ldw	r2,96(r2)
8110b738:	1009883a 	mov	r4,r2
8110b73c:	113cea00 	call	8113cea0 <OSSemPost>

		return error;
8110b740:	e0bff617 	ldw	r2,-40(fp)
8110b744:	00002206 	br	8110b7d0 <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110b748:	e0bffd17 	ldw	r2,-12(fp)
8110b74c:	10800317 	ldw	r2,12(r2)
8110b750:	10800104 	addi	r2,r2,4
8110b754:	10800037 	ldwio	r2,0(r2)
8110b758:	10800814 	ori	r2,r2,32
8110b75c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110b760:	0005303a 	rdctl	r2,status
8110b764:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110b768:	e0fffa17 	ldw	r3,-24(fp)
8110b76c:	00bfff84 	movi	r2,-2
8110b770:	1884703a 	and	r2,r3,r2
8110b774:	1001703a 	wrctl	status,r2
  
  return context;
8110b778:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110b77c:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110b780:	e0bffd17 	ldw	r2,-12(fp)
8110b784:	10800317 	ldw	r2,12(r2)
8110b788:	10800104 	addi	r2,r2,4
8110b78c:	e0fff417 	ldw	r3,-48(fp)
8110b790:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110b794:	e0bffd17 	ldw	r2,-12(fp)
8110b798:	10800317 	ldw	r2,12(r2)
8110b79c:	e0fffd17 	ldw	r3,-12(fp)
8110b7a0:	18c00317 	ldw	r3,12(r3)
8110b7a4:	18c00037 	ldwio	r3,0(r3)
8110b7a8:	10c00035 	stwio	r3,0(r2)
8110b7ac:	e0bff517 	ldw	r2,-44(fp)
8110b7b0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110b7b4:	e0bff917 	ldw	r2,-28(fp)
8110b7b8:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110b7bc:	e0bffd17 	ldw	r2,-12(fp)
8110b7c0:	10801817 	ldw	r2,96(r2)
8110b7c4:	1009883a 	mov	r4,r2
8110b7c8:	113cea00 	call	8113cea0 <OSSemPost>

	return 0;
8110b7cc:	0005883a 	mov	r2,zero

}
8110b7d0:	e037883a 	mov	sp,fp
8110b7d4:	dfc00117 	ldw	ra,4(sp)
8110b7d8:	df000017 	ldw	fp,0(sp)
8110b7dc:	dec00204 	addi	sp,sp,8
8110b7e0:	f800283a 	ret

8110b7e4 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110b7e4:	deffec04 	addi	sp,sp,-80
8110b7e8:	de00012e 	bgeu	sp,et,8110b7f0 <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110b7ec:	003b68fa 	trap	3
8110b7f0:	dfc01315 	stw	ra,76(sp)
8110b7f4:	df001215 	stw	fp,72(sp)
8110b7f8:	df001204 	addi	fp,sp,72
8110b7fc:	e13ff715 	stw	r4,-36(fp)
8110b800:	e17ff815 	stw	r5,-32(fp)
8110b804:	e1bff915 	stw	r6,-28(fp)
8110b808:	e1fffa15 	stw	r7,-24(fp)
8110b80c:	e1800617 	ldw	r6,24(fp)
8110b810:	e1400717 	ldw	r5,28(fp)
8110b814:	e1000817 	ldw	r4,32(fp)
8110b818:	e0c00917 	ldw	r3,36(fp)
8110b81c:	e0800a17 	ldw	r2,40(fp)
8110b820:	e1bffb0d 	sth	r6,-20(fp)
8110b824:	e17ffc05 	stb	r5,-16(fp)
8110b828:	e13ffd05 	stb	r4,-12(fp)
8110b82c:	e0fffe0d 	sth	r3,-8(fp)
8110b830:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110b834:	e0bffb0b 	ldhu	r2,-20(fp)
8110b838:	e0fffc03 	ldbu	r3,-16(fp)
8110b83c:	e13ffd03 	ldbu	r4,-12(fp)
8110b840:	e17ffe0b 	ldhu	r5,-8(fp)
8110b844:	e1bfff0b 	ldhu	r6,-4(fp)
8110b848:	d9800815 	stw	r6,32(sp)
8110b84c:	d9400715 	stw	r5,28(sp)
8110b850:	d9000615 	stw	r4,24(sp)
8110b854:	d8c00515 	stw	r3,20(sp)
8110b858:	d8800415 	stw	r2,16(sp)
8110b85c:	e0800517 	ldw	r2,20(fp)
8110b860:	d8800315 	stw	r2,12(sp)
8110b864:	e0800417 	ldw	r2,16(fp)
8110b868:	d8800215 	stw	r2,8(sp)
8110b86c:	e0800317 	ldw	r2,12(fp)
8110b870:	d8800115 	stw	r2,4(sp)
8110b874:	e0800217 	ldw	r2,8(fp)
8110b878:	d8800015 	stw	r2,0(sp)
8110b87c:	e1fffa17 	ldw	r7,-24(fp)
8110b880:	e1bff917 	ldw	r6,-28(fp)
8110b884:	e17ff817 	ldw	r5,-32(fp)
8110b888:	e13ff717 	ldw	r4,-36(fp)
8110b88c:	110af6c0 	call	8110af6c <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110b890:	e037883a 	mov	sp,fp
8110b894:	dfc00117 	ldw	ra,4(sp)
8110b898:	df000017 	ldw	fp,0(sp)
8110b89c:	dec00204 	addi	sp,sp,8
8110b8a0:	f800283a 	ret

8110b8a4 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110b8a4:	defffc04 	addi	sp,sp,-16
8110b8a8:	de00012e 	bgeu	sp,et,8110b8b0 <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110b8ac:	003b68fa 	trap	3
8110b8b0:	dfc00315 	stw	ra,12(sp)
8110b8b4:	df000215 	stw	fp,8(sp)
8110b8b8:	df000204 	addi	fp,sp,8
8110b8bc:	e13ffe15 	stw	r4,-8(fp)
8110b8c0:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110b8c4:	e1bfff17 	ldw	r6,-4(fp)
8110b8c8:	000b883a 	mov	r5,zero
8110b8cc:	e13ffe17 	ldw	r4,-8(fp)
8110b8d0:	110b0d00 	call	8110b0d0 <msgdma_descriptor_async_transfer>
}
8110b8d4:	e037883a 	mov	sp,fp
8110b8d8:	dfc00117 	ldw	ra,4(sp)
8110b8dc:	df000017 	ldw	fp,0(sp)
8110b8e0:	dec00204 	addi	sp,sp,8
8110b8e4:	f800283a 	ret

8110b8e8 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110b8e8:	defffc04 	addi	sp,sp,-16
8110b8ec:	de00012e 	bgeu	sp,et,8110b8f4 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110b8f0:	003b68fa 	trap	3
8110b8f4:	dfc00315 	stw	ra,12(sp)
8110b8f8:	df000215 	stw	fp,8(sp)
8110b8fc:	df000204 	addi	fp,sp,8
8110b900:	e13ffe15 	stw	r4,-8(fp)
8110b904:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110b908:	e1bfff17 	ldw	r6,-4(fp)
8110b90c:	000b883a 	mov	r5,zero
8110b910:	e13ffe17 	ldw	r4,-8(fp)
8110b914:	110b3e80 	call	8110b3e8 <msgdma_descriptor_sync_transfer>
}
8110b918:	e037883a 	mov	sp,fp
8110b91c:	dfc00117 	ldw	ra,4(sp)
8110b920:	df000017 	ldw	fp,0(sp)
8110b924:	dec00204 	addi	sp,sp,8
8110b928:	f800283a 	ret

8110b92c <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110b92c:	defff204 	addi	sp,sp,-56
8110b930:	de00012e 	bgeu	sp,et,8110b938 <POWER_SPI_RW+0xc>
8110b934:	003b68fa 	trap	3
8110b938:	dfc00d15 	stw	ra,52(sp)
8110b93c:	df000c15 	stw	fp,48(sp)
8110b940:	df000c04 	addi	fp,sp,48
8110b944:	2007883a 	mov	r3,r4
8110b948:	2805883a 	mov	r2,r5
8110b94c:	e1bffe15 	stw	r6,-8(fp)
8110b950:	e1ffff15 	stw	r7,-4(fp)
8110b954:	e0fffc05 	stb	r3,-16(fp)
8110b958:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110b95c:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110b960:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110b964:	008003f4 	movhi	r2,15
8110b968:	10909004 	addi	r2,r2,16960
8110b96c:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110b970:	00bfe004 	movi	r2,-128
8110b974:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110b978:	e0bffe17 	ldw	r2,-8(fp)
8110b97c:	10000226 	beq	r2,zero,8110b988 <POWER_SPI_RW+0x5c>
8110b980:	00800804 	movi	r2,32
8110b984:	00000106 	br	8110b98c <POWER_SPI_RW+0x60>
8110b988:	0005883a 	mov	r2,zero
8110b98c:	e0fff403 	ldbu	r3,-48(fp)
8110b990:	10c4b03a 	or	r2,r2,r3
8110b994:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110b998:	e0800217 	ldw	r2,8(fp)
8110b99c:	10000226 	beq	r2,zero,8110b9a8 <POWER_SPI_RW+0x7c>
8110b9a0:	00800404 	movi	r2,16
8110b9a4:	00000106 	br	8110b9ac <POWER_SPI_RW+0x80>
8110b9a8:	0005883a 	mov	r2,zero
8110b9ac:	e0fff403 	ldbu	r3,-48(fp)
8110b9b0:	10c4b03a 	or	r2,r2,r3
8110b9b4:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110b9b8:	e0bfff17 	ldw	r2,-4(fp)
8110b9bc:	10000226 	beq	r2,zero,8110b9c8 <POWER_SPI_RW+0x9c>
8110b9c0:	00800204 	movi	r2,8
8110b9c4:	00000106 	br	8110b9cc <POWER_SPI_RW+0xa0>
8110b9c8:	0005883a 	mov	r2,zero
8110b9cc:	e0fff403 	ldbu	r3,-48(fp)
8110b9d0:	10c4b03a 	or	r2,r2,r3
8110b9d4:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110b9d8:	e0bffd03 	ldbu	r2,-12(fp)
8110b9dc:	108001cc 	andi	r2,r2,7
8110b9e0:	1007883a 	mov	r3,r2
8110b9e4:	e0bff403 	ldbu	r2,-48(fp)
8110b9e8:	1884b03a 	or	r2,r3,r2
8110b9ec:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110b9f0:	0007883a 	mov	r3,zero
8110b9f4:	00a00034 	movhi	r2,32768
8110b9f8:	10824404 	addi	r2,r2,2320
8110b9fc:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110ba00:	0007883a 	mov	r3,zero
8110ba04:	00a00034 	movhi	r2,32768
8110ba08:	10824c04 	addi	r2,r2,2352
8110ba0c:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110ba10:	e0bffc03 	ldbu	r2,-16(fp)
8110ba14:	1000021e 	bne	r2,zero,8110ba20 <POWER_SPI_RW+0xf4>
8110ba18:	00c00084 	movi	r3,2
8110ba1c:	00000106 	br	8110ba24 <POWER_SPI_RW+0xf8>
8110ba20:	00c00044 	movi	r3,1
8110ba24:	00a00034 	movhi	r2,32768
8110ba28:	10824804 	addi	r2,r2,2336
8110ba2c:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110ba30:	010003c4 	movi	r4,15
8110ba34:	1135d140 	call	81135d14 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ba38:	00000306 	br	8110ba48 <POWER_SPI_RW+0x11c>
		nWait++;
8110ba3c:	e0bff817 	ldw	r2,-32(fp)
8110ba40:	10800044 	addi	r2,r2,1
8110ba44:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110ba48:	00a00034 	movhi	r2,32768
8110ba4c:	10825404 	addi	r2,r2,2384
8110ba50:	10800037 	ldwio	r2,0(r2)
8110ba54:	1080004c 	andi	r2,r2,1
8110ba58:	10000326 	beq	r2,zero,8110ba68 <POWER_SPI_RW+0x13c>
8110ba5c:	e0fff817 	ldw	r3,-32(fp)
8110ba60:	e0bffa17 	ldw	r2,-24(fp)
8110ba64:	18bff516 	blt	r3,r2,8110ba3c <__reset+0xfb0eba3c>
		nWait++;
	}

	if (SPI_SDO) {
8110ba68:	00a00034 	movhi	r2,32768
8110ba6c:	10825404 	addi	r2,r2,2384
8110ba70:	10800037 	ldwio	r2,0(r2)
8110ba74:	1080004c 	andi	r2,r2,1
8110ba78:	10000626 	beq	r2,zero,8110ba94 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110ba7c:	00c000c4 	movi	r3,3
8110ba80:	00a00034 	movhi	r2,32768
8110ba84:	10824804 	addi	r2,r2,2336
8110ba88:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110ba8c:	0005883a 	mov	r2,zero
8110ba90:	0000db06 	br	8110be00 <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110ba94:	e03ff715 	stw	zero,-36(fp)
8110ba98:	00002406 	br	8110bb2c <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110ba9c:	e0bff403 	ldbu	r2,-48(fp)
8110baa0:	10803fcc 	andi	r2,r2,255
8110baa4:	1004d1fa 	srli	r2,r2,7
8110baa8:	10c03fcc 	andi	r3,r2,255
8110baac:	00a00034 	movhi	r2,32768
8110bab0:	10825004 	addi	r2,r2,2368
8110bab4:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110bab8:	e0bff403 	ldbu	r2,-48(fp)
8110babc:	1085883a 	add	r2,r2,r2
8110bac0:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110bac4:	e0bff517 	ldw	r2,-44(fp)
8110bac8:	1085883a 	add	r2,r2,r2
8110bacc:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110bad0:	00a00034 	movhi	r2,32768
8110bad4:	10825404 	addi	r2,r2,2384
8110bad8:	10800037 	ldwio	r2,0(r2)
8110badc:	1080004c 	andi	r2,r2,1
8110bae0:	1007883a 	mov	r3,r2
8110bae4:	e0bff517 	ldw	r2,-44(fp)
8110bae8:	10c4b03a 	or	r2,r2,r3
8110baec:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110baf0:	00c00044 	movi	r3,1
8110baf4:	00a00034 	movhi	r2,32768
8110baf8:	10824c04 	addi	r2,r2,2352
8110bafc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bb00:	010003c4 	movi	r4,15
8110bb04:	1135d140 	call	81135d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bb08:	0007883a 	mov	r3,zero
8110bb0c:	00a00034 	movhi	r2,32768
8110bb10:	10824c04 	addi	r2,r2,2352
8110bb14:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bb18:	010003c4 	movi	r4,15
8110bb1c:	1135d140 	call	81135d14 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110bb20:	e0bff717 	ldw	r2,-36(fp)
8110bb24:	10800044 	addi	r2,r2,1
8110bb28:	e0bff715 	stw	r2,-36(fp)
8110bb2c:	e0bff717 	ldw	r2,-36(fp)
8110bb30:	10800090 	cmplti	r2,r2,2
8110bb34:	103fd91e 	bne	r2,zero,8110ba9c <__reset+0xfb0eba9c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110bb38:	e03ff715 	stw	zero,-36(fp)
8110bb3c:	00002406 	br	8110bbd0 <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110bb40:	e0bff403 	ldbu	r2,-48(fp)
8110bb44:	10803fcc 	andi	r2,r2,255
8110bb48:	1004d1fa 	srli	r2,r2,7
8110bb4c:	10c03fcc 	andi	r3,r2,255
8110bb50:	00a00034 	movhi	r2,32768
8110bb54:	10825004 	addi	r2,r2,2368
8110bb58:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110bb5c:	e0bff403 	ldbu	r2,-48(fp)
8110bb60:	1085883a 	add	r2,r2,r2
8110bb64:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110bb68:	e0bff517 	ldw	r2,-44(fp)
8110bb6c:	1085883a 	add	r2,r2,r2
8110bb70:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110bb74:	00a00034 	movhi	r2,32768
8110bb78:	10825404 	addi	r2,r2,2384
8110bb7c:	10800037 	ldwio	r2,0(r2)
8110bb80:	1080004c 	andi	r2,r2,1
8110bb84:	1007883a 	mov	r3,r2
8110bb88:	e0bff517 	ldw	r2,-44(fp)
8110bb8c:	10c4b03a 	or	r2,r2,r3
8110bb90:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110bb94:	00c00044 	movi	r3,1
8110bb98:	00a00034 	movhi	r2,32768
8110bb9c:	10824c04 	addi	r2,r2,2352
8110bba0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bba4:	010003c4 	movi	r4,15
8110bba8:	1135d140 	call	81135d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bbac:	0007883a 	mov	r3,zero
8110bbb0:	00a00034 	movhi	r2,32768
8110bbb4:	10824c04 	addi	r2,r2,2352
8110bbb8:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bbbc:	010003c4 	movi	r4,15
8110bbc0:	1135d140 	call	81135d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110bbc4:	e0bff717 	ldw	r2,-36(fp)
8110bbc8:	10800044 	addi	r2,r2,1
8110bbcc:	e0bff715 	stw	r2,-36(fp)
8110bbd0:	e0bff717 	ldw	r2,-36(fp)
8110bbd4:	10800210 	cmplti	r2,r2,8
8110bbd8:	103fd91e 	bne	r2,zero,8110bb40 <__reset+0xfb0ebb40>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110bbdc:	e03ff715 	stw	zero,-36(fp)
8110bbe0:	00001a06 	br	8110bc4c <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110bbe4:	e0bff517 	ldw	r2,-44(fp)
8110bbe8:	1085883a 	add	r2,r2,r2
8110bbec:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110bbf0:	00a00034 	movhi	r2,32768
8110bbf4:	10825404 	addi	r2,r2,2384
8110bbf8:	10800037 	ldwio	r2,0(r2)
8110bbfc:	1080004c 	andi	r2,r2,1
8110bc00:	1007883a 	mov	r3,r2
8110bc04:	e0bff517 	ldw	r2,-44(fp)
8110bc08:	10c4b03a 	or	r2,r2,r3
8110bc0c:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110bc10:	00c00044 	movi	r3,1
8110bc14:	00a00034 	movhi	r2,32768
8110bc18:	10824c04 	addi	r2,r2,2352
8110bc1c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bc20:	010003c4 	movi	r4,15
8110bc24:	1135d140 	call	81135d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bc28:	0007883a 	mov	r3,zero
8110bc2c:	00a00034 	movhi	r2,32768
8110bc30:	10824c04 	addi	r2,r2,2352
8110bc34:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bc38:	010003c4 	movi	r4,15
8110bc3c:	1135d140 	call	81135d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110bc40:	e0bff717 	ldw	r2,-36(fp)
8110bc44:	10800044 	addi	r2,r2,1
8110bc48:	e0bff715 	stw	r2,-36(fp)
8110bc4c:	e0bff717 	ldw	r2,-36(fp)
8110bc50:	10800210 	cmplti	r2,r2,8
8110bc54:	103fe31e 	bne	r2,zero,8110bbe4 <__reset+0xfb0ebbe4>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110bc58:	e03ff715 	stw	zero,-36(fp)
8110bc5c:	00001a06 	br	8110bcc8 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110bc60:	e0bff517 	ldw	r2,-44(fp)
8110bc64:	1085883a 	add	r2,r2,r2
8110bc68:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110bc6c:	00a00034 	movhi	r2,32768
8110bc70:	10825404 	addi	r2,r2,2384
8110bc74:	10800037 	ldwio	r2,0(r2)
8110bc78:	1080004c 	andi	r2,r2,1
8110bc7c:	1007883a 	mov	r3,r2
8110bc80:	e0bff517 	ldw	r2,-44(fp)
8110bc84:	10c4b03a 	or	r2,r2,r3
8110bc88:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110bc8c:	00c00044 	movi	r3,1
8110bc90:	00a00034 	movhi	r2,32768
8110bc94:	10824c04 	addi	r2,r2,2352
8110bc98:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bc9c:	010003c4 	movi	r4,15
8110bca0:	1135d140 	call	81135d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bca4:	0007883a 	mov	r3,zero
8110bca8:	00a00034 	movhi	r2,32768
8110bcac:	10824c04 	addi	r2,r2,2352
8110bcb0:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bcb4:	010003c4 	movi	r4,15
8110bcb8:	1135d140 	call	81135d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110bcbc:	e0bff717 	ldw	r2,-36(fp)
8110bcc0:	10800044 	addi	r2,r2,1
8110bcc4:	e0bff715 	stw	r2,-36(fp)
8110bcc8:	e0bff717 	ldw	r2,-36(fp)
8110bccc:	10800210 	cmplti	r2,r2,8
8110bcd0:	103fe31e 	bne	r2,zero,8110bc60 <__reset+0xfb0ebc60>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110bcd4:	e03ff715 	stw	zero,-36(fp)
8110bcd8:	00001a06 	br	8110bd44 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110bcdc:	e0bff517 	ldw	r2,-44(fp)
8110bce0:	1085883a 	add	r2,r2,r2
8110bce4:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110bce8:	00a00034 	movhi	r2,32768
8110bcec:	10825404 	addi	r2,r2,2384
8110bcf0:	10800037 	ldwio	r2,0(r2)
8110bcf4:	1080004c 	andi	r2,r2,1
8110bcf8:	1007883a 	mov	r3,r2
8110bcfc:	e0bff517 	ldw	r2,-44(fp)
8110bd00:	10c4b03a 	or	r2,r2,r3
8110bd04:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110bd08:	00c00044 	movi	r3,1
8110bd0c:	00a00034 	movhi	r2,32768
8110bd10:	10824c04 	addi	r2,r2,2352
8110bd14:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bd18:	010003c4 	movi	r4,15
8110bd1c:	1135d140 	call	81135d14 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110bd20:	0007883a 	mov	r3,zero
8110bd24:	00a00034 	movhi	r2,32768
8110bd28:	10824c04 	addi	r2,r2,2352
8110bd2c:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110bd30:	010003c4 	movi	r4,15
8110bd34:	1135d140 	call	81135d14 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110bd38:	e0bff717 	ldw	r2,-36(fp)
8110bd3c:	10800044 	addi	r2,r2,1
8110bd40:	e0bff715 	stw	r2,-36(fp)
8110bd44:	e0bff717 	ldw	r2,-36(fp)
8110bd48:	10800190 	cmplti	r2,r2,6
8110bd4c:	103fe31e 	bne	r2,zero,8110bcdc <__reset+0xfb0ebcdc>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110bd50:	00c00044 	movi	r3,1
8110bd54:	00a00034 	movhi	r2,32768
8110bd58:	10824c04 	addi	r2,r2,2352
8110bd5c:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110bd60:	010003c4 	movi	r4,15
8110bd64:	1135d140 	call	81135d14 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110bd68:	00c000c4 	movi	r3,3
8110bd6c:	00a00034 	movhi	r2,32768
8110bd70:	10824804 	addi	r2,r2,2336
8110bd74:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110bd78:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110bd7c:	00800044 	movi	r2,1
8110bd80:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110bd84:	e03ff715 	stw	zero,-36(fp)
8110bd88:	00000d06 	br	8110bdc0 <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110bd8c:	e0fff517 	ldw	r3,-44(fp)
8110bd90:	e0bff617 	ldw	r2,-40(fp)
8110bd94:	1884703a 	and	r2,r3,r2
8110bd98:	1000031e 	bne	r2,zero,8110bda8 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110bd9c:	e0bff917 	ldw	r2,-28(fp)
8110bda0:	10800044 	addi	r2,r2,1
8110bda4:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110bda8:	e0bff617 	ldw	r2,-40(fp)
8110bdac:	1085883a 	add	r2,r2,r2
8110bdb0:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110bdb4:	e0bff717 	ldw	r2,-36(fp)
8110bdb8:	10800044 	addi	r2,r2,1
8110bdbc:	e0bff715 	stw	r2,-36(fp)
8110bdc0:	e0bff717 	ldw	r2,-36(fp)
8110bdc4:	10800810 	cmplti	r2,r2,32
8110bdc8:	103ff01e 	bne	r2,zero,8110bd8c <__reset+0xfb0ebd8c>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110bdcc:	e0bff917 	ldw	r2,-28(fp)
8110bdd0:	1080004c 	andi	r2,r2,1
8110bdd4:	1005003a 	cmpeq	r2,r2,zero
8110bdd8:	10803fcc 	andi	r2,r2,255
8110bddc:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110bde0:	e0bffb17 	ldw	r2,-20(fp)
8110bde4:	1000021e 	bne	r2,zero,8110bdf0 <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110bde8:	0005883a 	mov	r2,zero
8110bdec:	00000406 	br	8110be00 <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110bdf0:	e0800317 	ldw	r2,12(fp)
8110bdf4:	e0fff517 	ldw	r3,-44(fp)
8110bdf8:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110bdfc:	e0bffb17 	ldw	r2,-20(fp)
}
8110be00:	e037883a 	mov	sp,fp
8110be04:	dfc00117 	ldw	ra,4(sp)
8110be08:	df000017 	ldw	fp,0(sp)
8110be0c:	dec00204 	addi	sp,sp,8
8110be10:	f800283a 	ret

8110be14 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110be14:	defffc04 	addi	sp,sp,-16
8110be18:	de00012e 	bgeu	sp,et,8110be20 <vRstcSimucamReset+0xc>
8110be1c:	003b68fa 	trap	3
8110be20:	dfc00315 	stw	ra,12(sp)
8110be24:	df000215 	stw	fp,8(sp)
8110be28:	df000204 	addi	fp,sp,8
8110be2c:	2005883a 	mov	r2,r4
8110be30:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110be34:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110be38:	e0bfff0b 	ldhu	r2,-4(fp)
8110be3c:	e0fffe17 	ldw	r3,-8(fp)
8110be40:	1884b03a 	or	r2,r3,r2
8110be44:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110be48:	e0bffe17 	ldw	r2,-8(fp)
8110be4c:	10800074 	orhi	r2,r2,1
8110be50:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110be54:	e1bffe17 	ldw	r6,-8(fp)
8110be58:	000b883a 	mov	r5,zero
8110be5c:	01200034 	movhi	r4,32768
8110be60:	21020004 	addi	r4,r4,2048
8110be64:	110bf640 	call	8110bf64 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110be68:	0001883a 	nop
8110be6c:	e037883a 	mov	sp,fp
8110be70:	dfc00117 	ldw	ra,4(sp)
8110be74:	df000017 	ldw	fp,0(sp)
8110be78:	dec00204 	addi	sp,sp,8
8110be7c:	f800283a 	ret

8110be80 <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110be80:	defffc04 	addi	sp,sp,-16
8110be84:	de00012e 	bgeu	sp,et,8110be8c <vRstcReleaseDeviceReset+0xc>
8110be88:	003b68fa 	trap	3
8110be8c:	dfc00315 	stw	ra,12(sp)
8110be90:	df000215 	stw	fp,8(sp)
8110be94:	df000204 	addi	fp,sp,8
8110be98:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110be9c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bea0:	01400044 	movi	r5,1
8110bea4:	01200034 	movhi	r4,32768
8110bea8:	21020004 	addi	r4,r4,2048
8110beac:	110bfb80 	call	8110bfb8 <uliRstReadReg>
8110beb0:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110beb4:	e0bfff17 	ldw	r2,-4(fp)
8110beb8:	0084303a 	nor	r2,zero,r2
8110bebc:	e0fffe17 	ldw	r3,-8(fp)
8110bec0:	1884703a 	and	r2,r3,r2
8110bec4:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bec8:	e1bffe17 	ldw	r6,-8(fp)
8110becc:	01400044 	movi	r5,1
8110bed0:	01200034 	movhi	r4,32768
8110bed4:	21020004 	addi	r4,r4,2048
8110bed8:	110bf640 	call	8110bf64 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110bedc:	0001883a 	nop
8110bee0:	e037883a 	mov	sp,fp
8110bee4:	dfc00117 	ldw	ra,4(sp)
8110bee8:	df000017 	ldw	fp,0(sp)
8110beec:	dec00204 	addi	sp,sp,8
8110bef0:	f800283a 	ret

8110bef4 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110bef4:	defffc04 	addi	sp,sp,-16
8110bef8:	de00012e 	bgeu	sp,et,8110bf00 <vRstcHoldDeviceReset+0xc>
8110befc:	003b68fa 	trap	3
8110bf00:	dfc00315 	stw	ra,12(sp)
8110bf04:	df000215 	stw	fp,8(sp)
8110bf08:	df000204 	addi	fp,sp,8
8110bf0c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110bf10:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bf14:	01400044 	movi	r5,1
8110bf18:	01200034 	movhi	r4,32768
8110bf1c:	21020004 	addi	r4,r4,2048
8110bf20:	110bfb80 	call	8110bfb8 <uliRstReadReg>
8110bf24:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110bf28:	e0fffe17 	ldw	r3,-8(fp)
8110bf2c:	e0bfff17 	ldw	r2,-4(fp)
8110bf30:	1884b03a 	or	r2,r3,r2
8110bf34:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110bf38:	e1bffe17 	ldw	r6,-8(fp)
8110bf3c:	01400044 	movi	r5,1
8110bf40:	01200034 	movhi	r4,32768
8110bf44:	21020004 	addi	r4,r4,2048
8110bf48:	110bf640 	call	8110bf64 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110bf4c:	0001883a 	nop
8110bf50:	e037883a 	mov	sp,fp
8110bf54:	dfc00117 	ldw	ra,4(sp)
8110bf58:	df000017 	ldw	fp,0(sp)
8110bf5c:	dec00204 	addi	sp,sp,8
8110bf60:	f800283a 	ret

8110bf64 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110bf64:	defffc04 	addi	sp,sp,-16
8110bf68:	de00012e 	bgeu	sp,et,8110bf70 <vRstcWriteReg+0xc>
8110bf6c:	003b68fa 	trap	3
8110bf70:	df000315 	stw	fp,12(sp)
8110bf74:	df000304 	addi	fp,sp,12
8110bf78:	e13ffd15 	stw	r4,-12(fp)
8110bf7c:	e17ffe15 	stw	r5,-8(fp)
8110bf80:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110bf84:	e0bffe17 	ldw	r2,-8(fp)
8110bf88:	1085883a 	add	r2,r2,r2
8110bf8c:	1085883a 	add	r2,r2,r2
8110bf90:	1007883a 	mov	r3,r2
8110bf94:	e0bffd17 	ldw	r2,-12(fp)
8110bf98:	10c5883a 	add	r2,r2,r3
8110bf9c:	e0ffff17 	ldw	r3,-4(fp)
8110bfa0:	10c00015 	stw	r3,0(r2)
}
8110bfa4:	0001883a 	nop
8110bfa8:	e037883a 	mov	sp,fp
8110bfac:	df000017 	ldw	fp,0(sp)
8110bfb0:	dec00104 	addi	sp,sp,4
8110bfb4:	f800283a 	ret

8110bfb8 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110bfb8:	defffc04 	addi	sp,sp,-16
8110bfbc:	de00012e 	bgeu	sp,et,8110bfc4 <uliRstReadReg+0xc>
8110bfc0:	003b68fa 	trap	3
8110bfc4:	df000315 	stw	fp,12(sp)
8110bfc8:	df000304 	addi	fp,sp,12
8110bfcc:	e13ffe15 	stw	r4,-8(fp)
8110bfd0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110bfd4:	e0bfff17 	ldw	r2,-4(fp)
8110bfd8:	1085883a 	add	r2,r2,r2
8110bfdc:	1085883a 	add	r2,r2,r2
8110bfe0:	1007883a 	mov	r3,r2
8110bfe4:	e0bffe17 	ldw	r2,-8(fp)
8110bfe8:	10c5883a 	add	r2,r2,r3
8110bfec:	10800017 	ldw	r2,0(r2)
8110bff0:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110bff4:	e0bffd17 	ldw	r2,-12(fp)
}
8110bff8:	e037883a 	mov	sp,fp
8110bffc:	df000017 	ldw	fp,0(sp)
8110c000:	dec00104 	addi	sp,sp,4
8110c004:	f800283a 	ret

8110c008 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110c008:	defffe04 	addi	sp,sp,-8
8110c00c:	de00012e 	bgeu	sp,et,8110c014 <v_spi_start+0xc>
8110c010:	003b68fa 	trap	3
8110c014:	dfc00115 	stw	ra,4(sp)
8110c018:	df000015 	stw	fp,0(sp)
8110c01c:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110c020:	0007883a 	mov	r3,zero
8110c024:	00a00034 	movhi	r2,32768
8110c028:	10823004 	addi	r2,r2,2240
8110c02c:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110c030:	0007883a 	mov	r3,zero
8110c034:	00a00034 	movhi	r2,32768
8110c038:	10822c04 	addi	r2,r2,2224
8110c03c:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c040:	01002584 	movi	r4,150
8110c044:	1135d140 	call	81135d14 <usleep>
}
8110c048:	0001883a 	nop
8110c04c:	e037883a 	mov	sp,fp
8110c050:	dfc00117 	ldw	ra,4(sp)
8110c054:	df000017 	ldw	fp,0(sp)
8110c058:	dec00204 	addi	sp,sp,8
8110c05c:	f800283a 	ret

8110c060 <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110c060:	defffc04 	addi	sp,sp,-16
8110c064:	de00012e 	bgeu	sp,et,8110c06c <v_spi_send_byte+0xc>
8110c068:	003b68fa 	trap	3
8110c06c:	dfc00315 	stw	ra,12(sp)
8110c070:	df000215 	stw	fp,8(sp)
8110c074:	df000204 	addi	fp,sp,8
8110c078:	2005883a 	mov	r2,r4
8110c07c:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110c080:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110c084:	00bfe004 	movi	r2,-128
8110c088:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110c08c:	e03ffe05 	stb	zero,-8(fp)
8110c090:	00001b06 	br	8110c100 <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110c094:	e0ffff03 	ldbu	r3,-4(fp)
8110c098:	e0bffe43 	ldbu	r2,-7(fp)
8110c09c:	1884703a 	and	r2,r3,r2
8110c0a0:	10803fcc 	andi	r2,r2,255
8110c0a4:	1004c03a 	cmpne	r2,r2,zero
8110c0a8:	10c03fcc 	andi	r3,r2,255
8110c0ac:	00a00034 	movhi	r2,32768
8110c0b0:	10823404 	addi	r2,r2,2256
8110c0b4:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110c0b8:	e0bffe43 	ldbu	r2,-7(fp)
8110c0bc:	1004d07a 	srli	r2,r2,1
8110c0c0:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c0c4:	00c00044 	movi	r3,1
8110c0c8:	00a00034 	movhi	r2,32768
8110c0cc:	10823004 	addi	r2,r2,2240
8110c0d0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c0d4:	01002584 	movi	r4,150
8110c0d8:	1135d140 	call	81135d14 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c0dc:	0007883a 	mov	r3,zero
8110c0e0:	00a00034 	movhi	r2,32768
8110c0e4:	10823004 	addi	r2,r2,2240
8110c0e8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c0ec:	01002584 	movi	r4,150
8110c0f0:	1135d140 	call	81135d14 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110c0f4:	e0bffe03 	ldbu	r2,-8(fp)
8110c0f8:	10800044 	addi	r2,r2,1
8110c0fc:	e0bffe05 	stb	r2,-8(fp)
8110c100:	e0bffe03 	ldbu	r2,-8(fp)
8110c104:	10800230 	cmpltui	r2,r2,8
8110c108:	103fe21e 	bne	r2,zero,8110c094 <__reset+0xfb0ec094>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110c10c:	0001883a 	nop
8110c110:	e037883a 	mov	sp,fp
8110c114:	dfc00117 	ldw	ra,4(sp)
8110c118:	df000017 	ldw	fp,0(sp)
8110c11c:	dec00204 	addi	sp,sp,8
8110c120:	f800283a 	ret

8110c124 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110c124:	defffd04 	addi	sp,sp,-12
8110c128:	de00012e 	bgeu	sp,et,8110c130 <uc_spi_get_byte+0xc>
8110c12c:	003b68fa 	trap	3
8110c130:	dfc00215 	stw	ra,8(sp)
8110c134:	df000115 	stw	fp,4(sp)
8110c138:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110c13c:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110c140:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110c144:	e03fff05 	stb	zero,-4(fp)
8110c148:	00001a06 	br	8110c1b4 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110c14c:	e0bfff43 	ldbu	r2,-3(fp)
8110c150:	1085883a 	add	r2,r2,r2
8110c154:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110c158:	00a00034 	movhi	r2,32768
8110c15c:	10823804 	addi	r2,r2,2272
8110c160:	10800037 	ldwio	r2,0(r2)
8110c164:	1080004c 	andi	r2,r2,1
8110c168:	1007883a 	mov	r3,r2
8110c16c:	e0bfff43 	ldbu	r2,-3(fp)
8110c170:	1884b03a 	or	r2,r3,r2
8110c174:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110c178:	00c00044 	movi	r3,1
8110c17c:	00a00034 	movhi	r2,32768
8110c180:	10823004 	addi	r2,r2,2240
8110c184:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c188:	01002584 	movi	r4,150
8110c18c:	1135d140 	call	81135d14 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110c190:	0007883a 	mov	r3,zero
8110c194:	00a00034 	movhi	r2,32768
8110c198:	10823004 	addi	r2,r2,2240
8110c19c:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110c1a0:	01002584 	movi	r4,150
8110c1a4:	1135d140 	call	81135d14 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110c1a8:	e0bfff03 	ldbu	r2,-4(fp)
8110c1ac:	10800044 	addi	r2,r2,1
8110c1b0:	e0bfff05 	stb	r2,-4(fp)
8110c1b4:	e0bfff03 	ldbu	r2,-4(fp)
8110c1b8:	10800230 	cmpltui	r2,r2,8
8110c1bc:	103fe31e 	bne	r2,zero,8110c14c <__reset+0xfb0ec14c>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110c1c0:	e0bfff43 	ldbu	r2,-3(fp)
}
8110c1c4:	e037883a 	mov	sp,fp
8110c1c8:	dfc00117 	ldw	ra,4(sp)
8110c1cc:	df000017 	ldw	fp,0(sp)
8110c1d0:	dec00204 	addi	sp,sp,8
8110c1d4:	f800283a 	ret

8110c1d8 <v_spi_end>:

void v_spi_end(void){
8110c1d8:	defffe04 	addi	sp,sp,-8
8110c1dc:	de00012e 	bgeu	sp,et,8110c1e4 <v_spi_end+0xc>
8110c1e0:	003b68fa 	trap	3
8110c1e4:	dfc00115 	stw	ra,4(sp)
8110c1e8:	df000015 	stw	fp,0(sp)
8110c1ec:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110c1f0:	0007883a 	mov	r3,zero
8110c1f4:	00a00034 	movhi	r2,32768
8110c1f8:	10823004 	addi	r2,r2,2240
8110c1fc:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110c200:	01002584 	movi	r4,150
8110c204:	1135d140 	call	81135d14 <usleep>
    SPI_CS_N(1);
8110c208:	00c00044 	movi	r3,1
8110c20c:	00a00034 	movhi	r2,32768
8110c210:	10822c04 	addi	r2,r2,2224
8110c214:	10c00035 	stwio	r3,0(r2)
}
8110c218:	0001883a 	nop
8110c21c:	e037883a 	mov	sp,fp
8110c220:	dfc00117 	ldw	ra,4(sp)
8110c224:	df000017 	ldw	fp,0(sp)
8110c228:	dec00204 	addi	sp,sp,8
8110c22c:	f800283a 	ret

8110c230 <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110c230:	defff604 	addi	sp,sp,-40
8110c234:	de00012e 	bgeu	sp,et,8110c23c <RTCC_SPI_R_MAC+0xc>
8110c238:	003b68fa 	trap	3
8110c23c:	dfc00915 	stw	ra,36(sp)
8110c240:	df000815 	stw	fp,32(sp)
8110c244:	df000804 	addi	fp,sp,32
8110c248:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110c24c:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110c250:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110c254:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110c258:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110c25c:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110c260:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110c264:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110c268:	00800084 	movi	r2,2
8110c26c:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110c270:	00800cc4 	movi	r2,51
8110c274:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110c278:	110c0080 	call	8110c008 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110c27c:	e0bffec3 	ldbu	r2,-5(fp)
8110c280:	1009883a 	mov	r4,r2
8110c284:	110c0600 	call	8110c060 <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110c288:	e0bffe83 	ldbu	r2,-6(fp)
8110c28c:	1009883a 	mov	r4,r2
8110c290:	110c0600 	call	8110c060 <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110c294:	110c1240 	call	8110c124 <uc_spi_get_byte>
8110c298:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110c29c:	110c1240 	call	8110c124 <uc_spi_get_byte>
8110c2a0:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110c2a4:	110c1240 	call	8110c124 <uc_spi_get_byte>
8110c2a8:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110c2ac:	110c1240 	call	8110c124 <uc_spi_get_byte>
8110c2b0:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110c2b4:	110c1240 	call	8110c124 <uc_spi_get_byte>
8110c2b8:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110c2bc:	110c1240 	call	8110c124 <uc_spi_get_byte>
8110c2c0:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110c2c4:	110c1d80 	call	8110c1d8 <v_spi_end>

    bSuccess = TRUE;
8110c2c8:	00800044 	movi	r2,1
8110c2cc:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110c2d0:	e0bfff17 	ldw	r2,-4(fp)
8110c2d4:	e0fffd03 	ldbu	r3,-12(fp)
8110c2d8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110c2dc:	e0bfff17 	ldw	r2,-4(fp)
8110c2e0:	10800044 	addi	r2,r2,1
8110c2e4:	e0fffd43 	ldbu	r3,-11(fp)
8110c2e8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110c2ec:	e0bfff17 	ldw	r2,-4(fp)
8110c2f0:	10800084 	addi	r2,r2,2
8110c2f4:	e0fffd83 	ldbu	r3,-10(fp)
8110c2f8:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110c2fc:	e0bfff17 	ldw	r2,-4(fp)
8110c300:	108000c4 	addi	r2,r2,3
8110c304:	e0fffdc3 	ldbu	r3,-9(fp)
8110c308:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110c30c:	e0bfff17 	ldw	r2,-4(fp)
8110c310:	10800104 	addi	r2,r2,4
8110c314:	e0fffe03 	ldbu	r3,-8(fp)
8110c318:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110c31c:	e0bfff17 	ldw	r2,-4(fp)
8110c320:	10800144 	addi	r2,r2,5
8110c324:	e0fffe43 	ldbu	r3,-7(fp)
8110c328:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110c32c:	e1bffd03 	ldbu	r6,-12(fp)
8110c330:	e1fffd43 	ldbu	r7,-11(fp)
8110c334:	e0bffd83 	ldbu	r2,-10(fp)
8110c338:	e0fffdc3 	ldbu	r3,-9(fp)
8110c33c:	e13ffe03 	ldbu	r4,-8(fp)
8110c340:	e17ffe43 	ldbu	r5,-7(fp)
8110c344:	d9400315 	stw	r5,12(sp)
8110c348:	d9000215 	stw	r4,8(sp)
8110c34c:	d8c00115 	stw	r3,4(sp)
8110c350:	d8800015 	stw	r2,0(sp)
8110c354:	01604574 	movhi	r5,33045
8110c358:	29697104 	addi	r5,r5,-23100
8110c35c:	01204574 	movhi	r4,33045
8110c360:	2103d204 	addi	r4,r4,3912
8110c364:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
8110c368:	d0a06117 	ldw	r2,-32380(gp)
8110c36c:	01604574 	movhi	r5,33045
8110c370:	2943d204 	addi	r5,r5,3912
8110c374:	1009883a 	mov	r4,r2
8110c378:	111f5fc0 	call	8111f5fc <fprintf>
#endif

    return bSuccess;
8110c37c:	e0bffc17 	ldw	r2,-16(fp)
}
8110c380:	e037883a 	mov	sp,fp
8110c384:	dfc00117 	ldw	ra,4(sp)
8110c388:	df000017 	ldw	fp,0(sp)
8110c38c:	dec00204 	addi	sp,sp,8
8110c390:	f800283a 	ret

8110c394 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110c394:	defffd04 	addi	sp,sp,-12
8110c398:	de00012e 	bgeu	sp,et,8110c3a0 <bSSDisplayConfig+0xc>
8110c39c:	003b68fa 	trap	3
8110c3a0:	df000215 	stw	fp,8(sp)
8110c3a4:	df000204 	addi	fp,sp,8
8110c3a8:	2005883a 	mov	r2,r4
8110c3ac:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110c3b0:	e0bfff03 	ldbu	r2,-4(fp)
8110c3b4:	10c00168 	cmpgeui	r3,r2,5
8110c3b8:	18001c1e 	bne	r3,zero,8110c42c <bSSDisplayConfig+0x98>
8110c3bc:	100690ba 	slli	r3,r2,2
8110c3c0:	00a04474 	movhi	r2,33041
8110c3c4:	10b0f504 	addi	r2,r2,-15404
8110c3c8:	1885883a 	add	r2,r3,r2
8110c3cc:	10800017 	ldw	r2,0(r2)
8110c3d0:	1000683a 	jmp	r2
8110c3d4:	8110c3e8 	cmpgeui	r4,r16,17167
8110c3d8:	8110c3f4 	orhi	r4,r16,17167
8110c3dc:	8110c400 	call	88110c40 <__reset+0x20f0c40>
8110c3e0:	8110c414 	ori	r4,r16,17168
8110c3e4:	8110c424 	muli	r4,r16,17168
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110c3e8:	00800cc4 	movi	r2,51
8110c3ec:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c3f0:	00001006 	br	8110c434 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110c3f4:	00801544 	movi	r2,85
8110c3f8:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c3fc:	00000d06 	br	8110c434 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110c400:	d0e05043 	ldbu	r3,-32447(gp)
8110c404:	00bff744 	movi	r2,-35
8110c408:	1884703a 	and	r2,r3,r2
8110c40c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c410:	00000806 	br	8110c434 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110c414:	d0a05043 	ldbu	r2,-32447(gp)
8110c418:	10800894 	ori	r2,r2,34
8110c41c:	d0a05045 	stb	r2,-32447(gp)
	    break;
8110c420:	00000406 	br	8110c434 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110c424:	d0205045 	stb	zero,-32447(gp)
	    break;
8110c428:	00000206 	br	8110c434 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110c42c:	0005883a 	mov	r2,zero
8110c430:	00000806 	br	8110c454 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c434:	00a00034 	movhi	r2,32768
8110c438:	10828404 	addi	r2,r2,2576
8110c43c:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110c440:	d0a05043 	ldbu	r2,-32447(gp)
8110c444:	10c03fcc 	andi	r3,r2,255
8110c448:	e0bffe17 	ldw	r2,-8(fp)
8110c44c:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c450:	00800044 	movi	r2,1
}
8110c454:	e037883a 	mov	sp,fp
8110c458:	df000017 	ldw	fp,0(sp)
8110c45c:	dec00104 	addi	sp,sp,4
8110c460:	f800283a 	ret

8110c464 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110c464:	defffd04 	addi	sp,sp,-12
8110c468:	de00012e 	bgeu	sp,et,8110c470 <bSSDisplayUpdate+0xc>
8110c46c:	003b68fa 	trap	3
8110c470:	df000215 	stw	fp,8(sp)
8110c474:	df000204 	addi	fp,sp,8
8110c478:	2005883a 	mov	r2,r4
8110c47c:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110c480:	00a00034 	movhi	r2,32768
8110c484:	10828404 	addi	r2,r2,2576
8110c488:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110c48c:	e0bffe17 	ldw	r2,-8(fp)
8110c490:	10800104 	addi	r2,r2,4
8110c494:	e0ffff03 	ldbu	r3,-4(fp)
8110c498:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110c49c:	00800044 	movi	r2,1
}
8110c4a0:	e037883a 	mov	sp,fp
8110c4a4:	df000017 	ldw	fp,0(sp)
8110c4a8:	dec00104 	addi	sp,sp,4
8110c4ac:	f800283a 	ret

8110c4b0 <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110c4b0:	defff904 	addi	sp,sp,-28
8110c4b4:	de00012e 	bgeu	sp,et,8110c4bc <vSyncHandleIrq+0xc>
8110c4b8:	003b68fa 	trap	3
8110c4bc:	dfc00615 	stw	ra,24(sp)
8110c4c0:	df000515 	stw	fp,20(sp)
8110c4c4:	df000504 	addi	fp,sp,20
8110c4c8:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110c4cc:	e0bfff17 	ldw	r2,-4(fp)
8110c4d0:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110c4d4:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110c4d8:	d0a05203 	ldbu	r2,-32440(gp)
8110c4dc:	108000cc 	andi	r2,r2,3
8110c4e0:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 )
8110c4e4:	e0bffd03 	ldbu	r2,-12(fp)
8110c4e8:	1000031e 	bne	r2,zero,8110c4f8 <vSyncHandleIrq+0x48>
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110c4ec:	00bff804 	movi	r2,-32
8110c4f0:	e0bffe85 	stb	r2,-6(fp)
8110c4f4:	00000206 	br	8110c500 <vSyncHandleIrq+0x50>
	else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110c4f8:	00bff844 	movi	r2,-31
8110c4fc:	e0bffe85 	stb	r2,-6(fp)

	uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110c500:	00800044 	movi	r2,1
8110c504:	e0bffec5 	stb	r2,-5(fp)

	/* Send Priority message to the Meb Task to indicate the Master Sync */
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110c508:	d0a06817 	ldw	r2,-32352(gp)
8110c50c:	e0fffe17 	ldw	r3,-8(fp)
8110c510:	180b883a 	mov	r5,r3
8110c514:	1009883a 	mov	r4,r2
8110c518:	113c1980 	call	8113c198 <OSQPostFront>
8110c51c:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110c520:	e0bffd43 	ldbu	r2,-11(fp)
8110c524:	10000126 	beq	r2,zero,8110c52c <vSyncHandleIrq+0x7c>
		vFailSendMsgMasterSyncMeb( );
8110c528:	111b6a40 	call	8111b6a4 <vFailSendMsgMasterSyncMeb>
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110c52c:	e03ffb05 	stb	zero,-20(fp)
8110c530:	00001606 	br	8110c58c <vSyncHandleIrq+0xdc>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110c534:	e0bffb03 	ldbu	r2,-20(fp)
8110c538:	10800444 	addi	r2,r2,17
8110c53c:	e0bffec5 	stb	r2,-5(fp)
		error_codel = OSQPostFront(xFeeQ[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110c540:	e0bffb03 	ldbu	r2,-20(fp)
8110c544:	1085883a 	add	r2,r2,r2
8110c548:	1087883a 	add	r3,r2,r2
8110c54c:	d0a06904 	addi	r2,gp,-32348
8110c550:	1885883a 	add	r2,r3,r2
8110c554:	10800017 	ldw	r2,0(r2)
8110c558:	e0fffe17 	ldw	r3,-8(fp)
8110c55c:	180b883a 	mov	r5,r3
8110c560:	1009883a 	mov	r4,r2
8110c564:	113c1980 	call	8113c198 <OSQPostFront>
8110c568:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110c56c:	e0bffd43 	ldbu	r2,-11(fp)
8110c570:	10000326 	beq	r2,zero,8110c580 <vSyncHandleIrq+0xd0>
			vFailSendMsgSync( ucIL );
8110c574:	e0bffb03 	ldbu	r2,-20(fp)
8110c578:	1009883a 	mov	r4,r2
8110c57c:	111b5fc0 	call	8111b5fc <vFailSendMsgSync>
	error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
	if ( error_codel != OS_ERR_NONE ) {
		vFailSendMsgMasterSyncMeb( );
	}

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110c580:	e0bffb03 	ldbu	r2,-20(fp)
8110c584:	10800044 	addi	r2,r2,1
8110c588:	e0bffb05 	stb	r2,-20(fp)
8110c58c:	e0bffb03 	ldbu	r2,-20(fp)
8110c590:	103fe826 	beq	r2,zero,8110c534 <__reset+0xfb0ec534>
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}

	vucN += 1;
8110c594:	d0a05203 	ldbu	r2,-32440(gp)
8110c598:	10800044 	addi	r2,r2,1
8110c59c:	d0a05205 	stb	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110c5a0:	d0a06117 	ldw	r2,-32380(gp)
8110c5a4:	e0fffd03 	ldbu	r3,-12(fp)
8110c5a8:	180d883a 	mov	r6,r3
8110c5ac:	01604574 	movhi	r5,33045
8110c5b0:	29698004 	addi	r5,r5,-23040
8110c5b4:	1009883a 	mov	r4,r2
8110c5b8:	111f5fc0 	call	8111f5fc <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110c5bc:	110c6500 	call	8110c650 <vSyncIrqFlagClrSync>
}
8110c5c0:	0001883a 	nop
8110c5c4:	e037883a 	mov	sp,fp
8110c5c8:	dfc00117 	ldw	ra,4(sp)
8110c5cc:	df000017 	ldw	fp,0(sp)
8110c5d0:	dec00204 	addi	sp,sp,8
8110c5d4:	f800283a 	ret

8110c5d8 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110c5d8:	deffff04 	addi	sp,sp,-4
8110c5dc:	de00012e 	bgeu	sp,et,8110c5e4 <vSyncClearCounter+0xc>
8110c5e0:	003b68fa 	trap	3
8110c5e4:	df000015 	stw	fp,0(sp)
8110c5e8:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110c5ec:	d0205205 	stb	zero,-32440(gp)
}
8110c5f0:	0001883a 	nop
8110c5f4:	e037883a 	mov	sp,fp
8110c5f8:	df000017 	ldw	fp,0(sp)
8110c5fc:	dec00104 	addi	sp,sp,4
8110c600:	f800283a 	ret

8110c604 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110c604:	defffd04 	addi	sp,sp,-12
8110c608:	de00012e 	bgeu	sp,et,8110c610 <vSyncInitIrq+0xc>
8110c60c:	003b68fa 	trap	3
8110c610:	dfc00215 	stw	ra,8(sp)
8110c614:	df000115 	stw	fp,4(sp)
8110c618:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110c61c:	d0a05104 	addi	r2,gp,-32444
8110c620:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110c624:	01a04474 	movhi	r6,33041
8110c628:	31b12c04 	addi	r6,r6,-15184
8110c62c:	e17fff17 	ldw	r5,-4(fp)
8110c630:	01000284 	movi	r4,10
8110c634:	11346440 	call	81134644 <alt_irq_register>
}
8110c638:	0001883a 	nop
8110c63c:	e037883a 	mov	sp,fp
8110c640:	dfc00117 	ldw	ra,4(sp)
8110c644:	df000017 	ldw	fp,0(sp)
8110c648:	dec00204 	addi	sp,sp,8
8110c64c:	f800283a 	ret

8110c650 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110c650:	defffe04 	addi	sp,sp,-8
8110c654:	de00012e 	bgeu	sp,et,8110c65c <vSyncIrqFlagClrSync+0xc>
8110c658:	003b68fa 	trap	3
8110c65c:	dfc00115 	stw	ra,4(sp)
8110c660:	df000015 	stw	fp,0(sp)
8110c664:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110c668:	01400044 	movi	r5,1
8110c66c:	010002c4 	movi	r4,11
8110c670:	110d4300 	call	8110d430 <bSyncWriteReg>
}
8110c674:	0001883a 	nop
8110c678:	e037883a 	mov	sp,fp
8110c67c:	dfc00117 	ldw	ra,4(sp)
8110c680:	df000017 	ldw	fp,0(sp)
8110c684:	dec00204 	addi	sp,sp,8
8110c688:	f800283a 	ret

8110c68c <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110c68c:	defffd04 	addi	sp,sp,-12
8110c690:	de00012e 	bgeu	sp,et,8110c698 <bSyncIrqFlagSync+0xc>
8110c694:	003b68fa 	trap	3
8110c698:	dfc00215 	stw	ra,8(sp)
8110c69c:	df000115 	stw	fp,4(sp)
8110c6a0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110c6a4:	01000304 	movi	r4,12
8110c6a8:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c6ac:	1080004c 	andi	r2,r2,1
8110c6b0:	10000326 	beq	r2,zero,8110c6c0 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110c6b4:	00800044 	movi	r2,1
8110c6b8:	e0bfff15 	stw	r2,-4(fp)
8110c6bc:	00000106 	br	8110c6c4 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110c6c0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110c6c4:	e0bfff17 	ldw	r2,-4(fp)
}
8110c6c8:	e037883a 	mov	sp,fp
8110c6cc:	dfc00117 	ldw	ra,4(sp)
8110c6d0:	df000017 	ldw	fp,0(sp)
8110c6d4:	dec00204 	addi	sp,sp,8
8110c6d8:	f800283a 	ret

8110c6dc <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110c6dc:	defffc04 	addi	sp,sp,-16
8110c6e0:	de00012e 	bgeu	sp,et,8110c6e8 <bSyncStatusExtnIrq+0xc>
8110c6e4:	003b68fa 	trap	3
8110c6e8:	dfc00315 	stw	ra,12(sp)
8110c6ec:	df000215 	stw	fp,8(sp)
8110c6f0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c6f4:	0009883a 	mov	r4,zero
8110c6f8:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c6fc:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110c700:	e0bfff17 	ldw	r2,-4(fp)
8110c704:	1000030e 	bge	r2,zero,8110c714 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110c708:	00800044 	movi	r2,1
8110c70c:	e0bffe15 	stw	r2,-8(fp)
8110c710:	00000106 	br	8110c718 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110c714:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c718:	e0bffe17 	ldw	r2,-8(fp)
}
8110c71c:	e037883a 	mov	sp,fp
8110c720:	dfc00117 	ldw	ra,4(sp)
8110c724:	df000017 	ldw	fp,0(sp)
8110c728:	dec00204 	addi	sp,sp,8
8110c72c:	f800283a 	ret

8110c730 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110c730:	defffc04 	addi	sp,sp,-16
8110c734:	de00012e 	bgeu	sp,et,8110c73c <ucSyncStatusState+0xc>
8110c738:	003b68fa 	trap	3
8110c73c:	dfc00315 	stw	ra,12(sp)
8110c740:	df000215 	stw	fp,8(sp)
8110c744:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c748:	0009883a 	mov	r4,zero
8110c74c:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c750:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110c754:	e0bffe17 	ldw	r2,-8(fp)
8110c758:	10803fec 	andhi	r2,r2,255
8110c75c:	1004d43a 	srli	r2,r2,16
8110c760:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110c764:	e0bfff03 	ldbu	r2,-4(fp)
}
8110c768:	e037883a 	mov	sp,fp
8110c76c:	dfc00117 	ldw	ra,4(sp)
8110c770:	df000017 	ldw	fp,0(sp)
8110c774:	dec00204 	addi	sp,sp,8
8110c778:	f800283a 	ret

8110c77c <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110c77c:	defffc04 	addi	sp,sp,-16
8110c780:	de00012e 	bgeu	sp,et,8110c788 <ucSyncStatusErrorCode+0xc>
8110c784:	003b68fa 	trap	3
8110c788:	dfc00315 	stw	ra,12(sp)
8110c78c:	df000215 	stw	fp,8(sp)
8110c790:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c794:	0009883a 	mov	r4,zero
8110c798:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c79c:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110c7a0:	e0bffe17 	ldw	r2,-8(fp)
8110c7a4:	10bfc00c 	andi	r2,r2,65280
8110c7a8:	1004d23a 	srli	r2,r2,8
8110c7ac:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110c7b0:	e0bfff03 	ldbu	r2,-4(fp)
}
8110c7b4:	e037883a 	mov	sp,fp
8110c7b8:	dfc00117 	ldw	ra,4(sp)
8110c7bc:	df000017 	ldw	fp,0(sp)
8110c7c0:	dec00204 	addi	sp,sp,8
8110c7c4:	f800283a 	ret

8110c7c8 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110c7c8:	defffc04 	addi	sp,sp,-16
8110c7cc:	de00012e 	bgeu	sp,et,8110c7d4 <ucSyncStatusCycleNumber+0xc>
8110c7d0:	003b68fa 	trap	3
8110c7d4:	dfc00315 	stw	ra,12(sp)
8110c7d8:	df000215 	stw	fp,8(sp)
8110c7dc:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c7e0:	0009883a 	mov	r4,zero
8110c7e4:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c7e8:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110c7ec:	e0bffe17 	ldw	r2,-8(fp)
8110c7f0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110c7f4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110c7f8:	e037883a 	mov	sp,fp
8110c7fc:	dfc00117 	ldw	ra,4(sp)
8110c800:	df000017 	ldw	fp,0(sp)
8110c804:	dec00204 	addi	sp,sp,8
8110c808:	f800283a 	ret

8110c80c <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110c80c:	defffd04 	addi	sp,sp,-12
8110c810:	de00012e 	bgeu	sp,et,8110c818 <bSyncSetMbt+0xc>
8110c814:	003b68fa 	trap	3
8110c818:	dfc00215 	stw	ra,8(sp)
8110c81c:	df000115 	stw	fp,4(sp)
8110c820:	df000104 	addi	fp,sp,4
8110c824:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110c828:	e17fff17 	ldw	r5,-4(fp)
8110c82c:	01000104 	movi	r4,4
8110c830:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110c834:	00800044 	movi	r2,1
}
8110c838:	e037883a 	mov	sp,fp
8110c83c:	dfc00117 	ldw	ra,4(sp)
8110c840:	df000017 	ldw	fp,0(sp)
8110c844:	dec00204 	addi	sp,sp,8
8110c848:	f800283a 	ret

8110c84c <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110c84c:	defffd04 	addi	sp,sp,-12
8110c850:	de00012e 	bgeu	sp,et,8110c858 <bSyncSetBt+0xc>
8110c854:	003b68fa 	trap	3
8110c858:	dfc00215 	stw	ra,8(sp)
8110c85c:	df000115 	stw	fp,4(sp)
8110c860:	df000104 	addi	fp,sp,4
8110c864:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110c868:	e17fff17 	ldw	r5,-4(fp)
8110c86c:	01000144 	movi	r4,5
8110c870:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110c874:	00800044 	movi	r2,1
}
8110c878:	e037883a 	mov	sp,fp
8110c87c:	dfc00117 	ldw	ra,4(sp)
8110c880:	df000017 	ldw	fp,0(sp)
8110c884:	dec00204 	addi	sp,sp,8
8110c888:	f800283a 	ret

8110c88c <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110c88c:	defffd04 	addi	sp,sp,-12
8110c890:	de00012e 	bgeu	sp,et,8110c898 <bSyncSetPer+0xc>
8110c894:	003b68fa 	trap	3
8110c898:	dfc00215 	stw	ra,8(sp)
8110c89c:	df000115 	stw	fp,4(sp)
8110c8a0:	df000104 	addi	fp,sp,4
8110c8a4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110c8a8:	e17fff17 	ldw	r5,-4(fp)
8110c8ac:	01000184 	movi	r4,6
8110c8b0:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110c8b4:	00800044 	movi	r2,1
}
8110c8b8:	e037883a 	mov	sp,fp
8110c8bc:	dfc00117 	ldw	ra,4(sp)
8110c8c0:	df000017 	ldw	fp,0(sp)
8110c8c4:	dec00204 	addi	sp,sp,8
8110c8c8:	f800283a 	ret

8110c8cc <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110c8cc:	defffd04 	addi	sp,sp,-12
8110c8d0:	de00012e 	bgeu	sp,et,8110c8d8 <bSyncSetOst+0xc>
8110c8d4:	003b68fa 	trap	3
8110c8d8:	dfc00215 	stw	ra,8(sp)
8110c8dc:	df000115 	stw	fp,4(sp)
8110c8e0:	df000104 	addi	fp,sp,4
8110c8e4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110c8e8:	e17fff17 	ldw	r5,-4(fp)
8110c8ec:	010001c4 	movi	r4,7
8110c8f0:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110c8f4:	00800044 	movi	r2,1
}
8110c8f8:	e037883a 	mov	sp,fp
8110c8fc:	dfc00117 	ldw	ra,4(sp)
8110c900:	df000017 	ldw	fp,0(sp)
8110c904:	dec00204 	addi	sp,sp,8
8110c908:	f800283a 	ret

8110c90c <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110c90c:	defffc04 	addi	sp,sp,-16
8110c910:	de00012e 	bgeu	sp,et,8110c918 <bSyncSetPolarity+0xc>
8110c914:	003b68fa 	trap	3
8110c918:	dfc00315 	stw	ra,12(sp)
8110c91c:	df000215 	stw	fp,8(sp)
8110c920:	df000204 	addi	fp,sp,8
8110c924:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110c928:	01000204 	movi	r4,8
8110c92c:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c930:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c934:	e0bfff17 	ldw	r2,-4(fp)
8110c938:	1000051e 	bne	r2,zero,8110c950 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110c93c:	e0fffe17 	ldw	r3,-8(fp)
8110c940:	00bfbfc4 	movi	r2,-257
8110c944:	1884703a 	and	r2,r3,r2
8110c948:	e0bffe15 	stw	r2,-8(fp)
8110c94c:	00000306 	br	8110c95c <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110c950:	e0bffe17 	ldw	r2,-8(fp)
8110c954:	10804014 	ori	r2,r2,256
8110c958:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110c95c:	e17ffe17 	ldw	r5,-8(fp)
8110c960:	01000204 	movi	r4,8
8110c964:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110c968:	00800044 	movi	r2,1
}
8110c96c:	e037883a 	mov	sp,fp
8110c970:	dfc00117 	ldw	ra,4(sp)
8110c974:	df000017 	ldw	fp,0(sp)
8110c978:	dec00204 	addi	sp,sp,8
8110c97c:	f800283a 	ret

8110c980 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110c980:	defffc04 	addi	sp,sp,-16
8110c984:	de00012e 	bgeu	sp,et,8110c98c <bSyncSetNCycles+0xc>
8110c988:	003b68fa 	trap	3
8110c98c:	dfc00315 	stw	ra,12(sp)
8110c990:	df000215 	stw	fp,8(sp)
8110c994:	df000204 	addi	fp,sp,8
8110c998:	2005883a 	mov	r2,r4
8110c99c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110c9a0:	01000204 	movi	r4,8
8110c9a4:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110c9a8:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110c9ac:	e0fffe17 	ldw	r3,-8(fp)
8110c9b0:	00bfc004 	movi	r2,-256
8110c9b4:	1884703a 	and	r2,r3,r2
8110c9b8:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110c9bc:	e0bfff03 	ldbu	r2,-4(fp)
8110c9c0:	e0fffe17 	ldw	r3,-8(fp)
8110c9c4:	1884b03a 	or	r2,r3,r2
8110c9c8:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110c9cc:	e17ffe17 	ldw	r5,-8(fp)
8110c9d0:	01000204 	movi	r4,8
8110c9d4:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110c9d8:	00800044 	movi	r2,1
}
8110c9dc:	e037883a 	mov	sp,fp
8110c9e0:	dfc00117 	ldw	ra,4(sp)
8110c9e4:	df000017 	ldw	fp,0(sp)
8110c9e8:	dec00204 	addi	sp,sp,8
8110c9ec:	f800283a 	ret

8110c9f0 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110c9f0:	defffd04 	addi	sp,sp,-12
8110c9f4:	de00012e 	bgeu	sp,et,8110c9fc <uliSyncGetMbt+0xc>
8110c9f8:	003b68fa 	trap	3
8110c9fc:	dfc00215 	stw	ra,8(sp)
8110ca00:	df000115 	stw	fp,4(sp)
8110ca04:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110ca08:	01000104 	movi	r4,4
8110ca0c:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110ca10:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110ca14:	e0bfff17 	ldw	r2,-4(fp)
}
8110ca18:	e037883a 	mov	sp,fp
8110ca1c:	dfc00117 	ldw	ra,4(sp)
8110ca20:	df000017 	ldw	fp,0(sp)
8110ca24:	dec00204 	addi	sp,sp,8
8110ca28:	f800283a 	ret

8110ca2c <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110ca2c:	defffd04 	addi	sp,sp,-12
8110ca30:	de00012e 	bgeu	sp,et,8110ca38 <uliSyncGetBt+0xc>
8110ca34:	003b68fa 	trap	3
8110ca38:	dfc00215 	stw	ra,8(sp)
8110ca3c:	df000115 	stw	fp,4(sp)
8110ca40:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110ca44:	01000144 	movi	r4,5
8110ca48:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110ca4c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110ca50:	e0bfff17 	ldw	r2,-4(fp)
}
8110ca54:	e037883a 	mov	sp,fp
8110ca58:	dfc00117 	ldw	ra,4(sp)
8110ca5c:	df000017 	ldw	fp,0(sp)
8110ca60:	dec00204 	addi	sp,sp,8
8110ca64:	f800283a 	ret

8110ca68 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110ca68:	defffd04 	addi	sp,sp,-12
8110ca6c:	de00012e 	bgeu	sp,et,8110ca74 <uliSyncGetPer+0xc>
8110ca70:	003b68fa 	trap	3
8110ca74:	dfc00215 	stw	ra,8(sp)
8110ca78:	df000115 	stw	fp,4(sp)
8110ca7c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110ca80:	01000184 	movi	r4,6
8110ca84:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110ca88:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110ca8c:	e0bfff17 	ldw	r2,-4(fp)
}
8110ca90:	e037883a 	mov	sp,fp
8110ca94:	dfc00117 	ldw	ra,4(sp)
8110ca98:	df000017 	ldw	fp,0(sp)
8110ca9c:	dec00204 	addi	sp,sp,8
8110caa0:	f800283a 	ret

8110caa4 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110caa4:	defffd04 	addi	sp,sp,-12
8110caa8:	de00012e 	bgeu	sp,et,8110cab0 <uliSyncGetOst+0xc>
8110caac:	003b68fa 	trap	3
8110cab0:	dfc00215 	stw	ra,8(sp)
8110cab4:	df000115 	stw	fp,4(sp)
8110cab8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110cabc:	010001c4 	movi	r4,7
8110cac0:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cac4:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cac8:	e0bfff17 	ldw	r2,-4(fp)
}
8110cacc:	e037883a 	mov	sp,fp
8110cad0:	dfc00117 	ldw	ra,4(sp)
8110cad4:	df000017 	ldw	fp,0(sp)
8110cad8:	dec00204 	addi	sp,sp,8
8110cadc:	f800283a 	ret

8110cae0 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110cae0:	defffd04 	addi	sp,sp,-12
8110cae4:	de00012e 	bgeu	sp,et,8110caec <uliSyncGetGeneral+0xc>
8110cae8:	003b68fa 	trap	3
8110caec:	dfc00215 	stw	ra,8(sp)
8110caf0:	df000115 	stw	fp,4(sp)
8110caf4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110caf8:	01000204 	movi	r4,8
8110cafc:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cb00:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110cb04:	e0bfff17 	ldw	r2,-4(fp)
}
8110cb08:	e037883a 	mov	sp,fp
8110cb0c:	dfc00117 	ldw	ra,4(sp)
8110cb10:	df000017 	ldw	fp,0(sp)
8110cb14:	dec00204 	addi	sp,sp,8
8110cb18:	f800283a 	ret

8110cb1c <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110cb1c:	defffd04 	addi	sp,sp,-12
8110cb20:	de00012e 	bgeu	sp,et,8110cb28 <bSyncErrInj+0xc>
8110cb24:	003b68fa 	trap	3
8110cb28:	dfc00215 	stw	ra,8(sp)
8110cb2c:	df000115 	stw	fp,4(sp)
8110cb30:	df000104 	addi	fp,sp,4
8110cb34:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110cb38:	e17fff17 	ldw	r5,-4(fp)
8110cb3c:	01000244 	movi	r4,9
8110cb40:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cb44:	00800044 	movi	r2,1
}
8110cb48:	e037883a 	mov	sp,fp
8110cb4c:	dfc00117 	ldw	ra,4(sp)
8110cb50:	df000017 	ldw	fp,0(sp)
8110cb54:	dec00204 	addi	sp,sp,8
8110cb58:	f800283a 	ret

8110cb5c <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110cb5c:	defffc04 	addi	sp,sp,-16
8110cb60:	de00012e 	bgeu	sp,et,8110cb68 <bSyncCtrExtnIrq+0xc>
8110cb64:	003b68fa 	trap	3
8110cb68:	dfc00315 	stw	ra,12(sp)
8110cb6c:	df000215 	stw	fp,8(sp)
8110cb70:	df000204 	addi	fp,sp,8
8110cb74:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cb78:	01000284 	movi	r4,10
8110cb7c:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cb80:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cb84:	e0bfff17 	ldw	r2,-4(fp)
8110cb88:	1000061e 	bne	r2,zero,8110cba4 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110cb8c:	e0fffe17 	ldw	r3,-8(fp)
8110cb90:	00a00034 	movhi	r2,32768
8110cb94:	10bfffc4 	addi	r2,r2,-1
8110cb98:	1884703a 	and	r2,r3,r2
8110cb9c:	e0bffe15 	stw	r2,-8(fp)
8110cba0:	00000306 	br	8110cbb0 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110cba4:	e0bffe17 	ldw	r2,-8(fp)
8110cba8:	10a00034 	orhi	r2,r2,32768
8110cbac:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cbb0:	e17ffe17 	ldw	r5,-8(fp)
8110cbb4:	01000284 	movi	r4,10
8110cbb8:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cbbc:	00800044 	movi	r2,1
}
8110cbc0:	e037883a 	mov	sp,fp
8110cbc4:	dfc00117 	ldw	ra,4(sp)
8110cbc8:	df000017 	ldw	fp,0(sp)
8110cbcc:	dec00204 	addi	sp,sp,8
8110cbd0:	f800283a 	ret

8110cbd4 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110cbd4:	defffd04 	addi	sp,sp,-12
8110cbd8:	de00012e 	bgeu	sp,et,8110cbe0 <bSyncCtrStart+0xc>
8110cbdc:	003b68fa 	trap	3
8110cbe0:	dfc00215 	stw	ra,8(sp)
8110cbe4:	df000115 	stw	fp,4(sp)
8110cbe8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cbec:	01000284 	movi	r4,10
8110cbf0:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cbf4:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110cbf8:	e0bfff17 	ldw	r2,-4(fp)
8110cbfc:	10800234 	orhi	r2,r2,8
8110cc00:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cc04:	e17fff17 	ldw	r5,-4(fp)
8110cc08:	01000284 	movi	r4,10
8110cc0c:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cc10:	00800044 	movi	r2,1
}
8110cc14:	e037883a 	mov	sp,fp
8110cc18:	dfc00117 	ldw	ra,4(sp)
8110cc1c:	df000017 	ldw	fp,0(sp)
8110cc20:	dec00204 	addi	sp,sp,8
8110cc24:	f800283a 	ret

8110cc28 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110cc28:	defffd04 	addi	sp,sp,-12
8110cc2c:	de00012e 	bgeu	sp,et,8110cc34 <bSyncCtrReset+0xc>
8110cc30:	003b68fa 	trap	3
8110cc34:	dfc00215 	stw	ra,8(sp)
8110cc38:	df000115 	stw	fp,4(sp)
8110cc3c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cc40:	01000284 	movi	r4,10
8110cc44:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cc48:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110cc4c:	e0bfff17 	ldw	r2,-4(fp)
8110cc50:	10800134 	orhi	r2,r2,4
8110cc54:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cc58:	e17fff17 	ldw	r5,-4(fp)
8110cc5c:	01000284 	movi	r4,10
8110cc60:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cc64:	00800044 	movi	r2,1
}
8110cc68:	e037883a 	mov	sp,fp
8110cc6c:	dfc00117 	ldw	ra,4(sp)
8110cc70:	df000017 	ldw	fp,0(sp)
8110cc74:	dec00204 	addi	sp,sp,8
8110cc78:	f800283a 	ret

8110cc7c <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110cc7c:	defffd04 	addi	sp,sp,-12
8110cc80:	de00012e 	bgeu	sp,et,8110cc88 <bSyncCtrOneShot+0xc>
8110cc84:	003b68fa 	trap	3
8110cc88:	dfc00215 	stw	ra,8(sp)
8110cc8c:	df000115 	stw	fp,4(sp)
8110cc90:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cc94:	01000284 	movi	r4,10
8110cc98:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cc9c:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110cca0:	e0bfff17 	ldw	r2,-4(fp)
8110cca4:	108000b4 	orhi	r2,r2,2
8110cca8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110ccac:	e17fff17 	ldw	r5,-4(fp)
8110ccb0:	01000284 	movi	r4,10
8110ccb4:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110ccb8:	00800044 	movi	r2,1
}
8110ccbc:	e037883a 	mov	sp,fp
8110ccc0:	dfc00117 	ldw	ra,4(sp)
8110ccc4:	df000017 	ldw	fp,0(sp)
8110ccc8:	dec00204 	addi	sp,sp,8
8110cccc:	f800283a 	ret

8110ccd0 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110ccd0:	defffd04 	addi	sp,sp,-12
8110ccd4:	de00012e 	bgeu	sp,et,8110ccdc <bSyncCtrErrInj+0xc>
8110ccd8:	003b68fa 	trap	3
8110ccdc:	dfc00215 	stw	ra,8(sp)
8110cce0:	df000115 	stw	fp,4(sp)
8110cce4:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cce8:	01000284 	movi	r4,10
8110ccec:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110ccf0:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110ccf4:	e0bfff17 	ldw	r2,-4(fp)
8110ccf8:	10800074 	orhi	r2,r2,1
8110ccfc:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cd00:	e17fff17 	ldw	r5,-4(fp)
8110cd04:	01000284 	movi	r4,10
8110cd08:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cd0c:	00800044 	movi	r2,1
}
8110cd10:	e037883a 	mov	sp,fp
8110cd14:	dfc00117 	ldw	ra,4(sp)
8110cd18:	df000017 	ldw	fp,0(sp)
8110cd1c:	dec00204 	addi	sp,sp,8
8110cd20:	f800283a 	ret

8110cd24 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110cd24:	defffc04 	addi	sp,sp,-16
8110cd28:	de00012e 	bgeu	sp,et,8110cd30 <bSyncCtrSyncOutEnable+0xc>
8110cd2c:	003b68fa 	trap	3
8110cd30:	dfc00315 	stw	ra,12(sp)
8110cd34:	df000215 	stw	fp,8(sp)
8110cd38:	df000204 	addi	fp,sp,8
8110cd3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cd40:	01000284 	movi	r4,10
8110cd44:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cd48:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cd4c:	e0bfff17 	ldw	r2,-4(fp)
8110cd50:	1000051e 	bne	r2,zero,8110cd68 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110cd54:	e0fffe17 	ldw	r3,-8(fp)
8110cd58:	00bfbfc4 	movi	r2,-257
8110cd5c:	1884703a 	and	r2,r3,r2
8110cd60:	e0bffe15 	stw	r2,-8(fp)
8110cd64:	00000306 	br	8110cd74 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110cd68:	e0bffe17 	ldw	r2,-8(fp)
8110cd6c:	10804014 	ori	r2,r2,256
8110cd70:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cd74:	e17ffe17 	ldw	r5,-8(fp)
8110cd78:	01000284 	movi	r4,10
8110cd7c:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cd80:	00800044 	movi	r2,1
}
8110cd84:	e037883a 	mov	sp,fp
8110cd88:	dfc00117 	ldw	ra,4(sp)
8110cd8c:	df000017 	ldw	fp,0(sp)
8110cd90:	dec00204 	addi	sp,sp,8
8110cd94:	f800283a 	ret

8110cd98 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110cd98:	defffc04 	addi	sp,sp,-16
8110cd9c:	de00012e 	bgeu	sp,et,8110cda4 <bSyncCtrCh1OutEnable+0xc>
8110cda0:	003b68fa 	trap	3
8110cda4:	dfc00315 	stw	ra,12(sp)
8110cda8:	df000215 	stw	fp,8(sp)
8110cdac:	df000204 	addi	fp,sp,8
8110cdb0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cdb4:	01000284 	movi	r4,10
8110cdb8:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cdbc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cdc0:	e0bfff17 	ldw	r2,-4(fp)
8110cdc4:	1000051e 	bne	r2,zero,8110cddc <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110cdc8:	e0fffe17 	ldw	r3,-8(fp)
8110cdcc:	00bfff84 	movi	r2,-2
8110cdd0:	1884703a 	and	r2,r3,r2
8110cdd4:	e0bffe15 	stw	r2,-8(fp)
8110cdd8:	00000306 	br	8110cde8 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110cddc:	e0bffe17 	ldw	r2,-8(fp)
8110cde0:	10800054 	ori	r2,r2,1
8110cde4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cde8:	e17ffe17 	ldw	r5,-8(fp)
8110cdec:	01000284 	movi	r4,10
8110cdf0:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cdf4:	00800044 	movi	r2,1
}
8110cdf8:	e037883a 	mov	sp,fp
8110cdfc:	dfc00117 	ldw	ra,4(sp)
8110ce00:	df000017 	ldw	fp,0(sp)
8110ce04:	dec00204 	addi	sp,sp,8
8110ce08:	f800283a 	ret

8110ce0c <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110ce0c:	defffc04 	addi	sp,sp,-16
8110ce10:	de00012e 	bgeu	sp,et,8110ce18 <bSyncCtrCh2OutEnable+0xc>
8110ce14:	003b68fa 	trap	3
8110ce18:	dfc00315 	stw	ra,12(sp)
8110ce1c:	df000215 	stw	fp,8(sp)
8110ce20:	df000204 	addi	fp,sp,8
8110ce24:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110ce28:	01000284 	movi	r4,10
8110ce2c:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110ce30:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110ce34:	e0bfff17 	ldw	r2,-4(fp)
8110ce38:	1000051e 	bne	r2,zero,8110ce50 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110ce3c:	e0fffe17 	ldw	r3,-8(fp)
8110ce40:	00bfff44 	movi	r2,-3
8110ce44:	1884703a 	and	r2,r3,r2
8110ce48:	e0bffe15 	stw	r2,-8(fp)
8110ce4c:	00000306 	br	8110ce5c <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110ce50:	e0bffe17 	ldw	r2,-8(fp)
8110ce54:	10800094 	ori	r2,r2,2
8110ce58:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110ce5c:	e17ffe17 	ldw	r5,-8(fp)
8110ce60:	01000284 	movi	r4,10
8110ce64:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110ce68:	00800044 	movi	r2,1
}
8110ce6c:	e037883a 	mov	sp,fp
8110ce70:	dfc00117 	ldw	ra,4(sp)
8110ce74:	df000017 	ldw	fp,0(sp)
8110ce78:	dec00204 	addi	sp,sp,8
8110ce7c:	f800283a 	ret

8110ce80 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110ce80:	defffc04 	addi	sp,sp,-16
8110ce84:	de00012e 	bgeu	sp,et,8110ce8c <bSyncCtrCh3OutEnable+0xc>
8110ce88:	003b68fa 	trap	3
8110ce8c:	dfc00315 	stw	ra,12(sp)
8110ce90:	df000215 	stw	fp,8(sp)
8110ce94:	df000204 	addi	fp,sp,8
8110ce98:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110ce9c:	01000284 	movi	r4,10
8110cea0:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cea4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cea8:	e0bfff17 	ldw	r2,-4(fp)
8110ceac:	1000051e 	bne	r2,zero,8110cec4 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110ceb0:	e0fffe17 	ldw	r3,-8(fp)
8110ceb4:	00bffec4 	movi	r2,-5
8110ceb8:	1884703a 	and	r2,r3,r2
8110cebc:	e0bffe15 	stw	r2,-8(fp)
8110cec0:	00000306 	br	8110ced0 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110cec4:	e0bffe17 	ldw	r2,-8(fp)
8110cec8:	10800114 	ori	r2,r2,4
8110cecc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110ced0:	e17ffe17 	ldw	r5,-8(fp)
8110ced4:	01000284 	movi	r4,10
8110ced8:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cedc:	00800044 	movi	r2,1
}
8110cee0:	e037883a 	mov	sp,fp
8110cee4:	dfc00117 	ldw	ra,4(sp)
8110cee8:	df000017 	ldw	fp,0(sp)
8110ceec:	dec00204 	addi	sp,sp,8
8110cef0:	f800283a 	ret

8110cef4 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110cef4:	defffc04 	addi	sp,sp,-16
8110cef8:	de00012e 	bgeu	sp,et,8110cf00 <bSyncCtrCh4OutEnable+0xc>
8110cefc:	003b68fa 	trap	3
8110cf00:	dfc00315 	stw	ra,12(sp)
8110cf04:	df000215 	stw	fp,8(sp)
8110cf08:	df000204 	addi	fp,sp,8
8110cf0c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cf10:	01000284 	movi	r4,10
8110cf14:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cf18:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cf1c:	e0bfff17 	ldw	r2,-4(fp)
8110cf20:	1000051e 	bne	r2,zero,8110cf38 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110cf24:	e0fffe17 	ldw	r3,-8(fp)
8110cf28:	00bffdc4 	movi	r2,-9
8110cf2c:	1884703a 	and	r2,r3,r2
8110cf30:	e0bffe15 	stw	r2,-8(fp)
8110cf34:	00000306 	br	8110cf44 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110cf38:	e0bffe17 	ldw	r2,-8(fp)
8110cf3c:	10800214 	ori	r2,r2,8
8110cf40:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cf44:	e17ffe17 	ldw	r5,-8(fp)
8110cf48:	01000284 	movi	r4,10
8110cf4c:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cf50:	00800044 	movi	r2,1
}
8110cf54:	e037883a 	mov	sp,fp
8110cf58:	dfc00117 	ldw	ra,4(sp)
8110cf5c:	df000017 	ldw	fp,0(sp)
8110cf60:	dec00204 	addi	sp,sp,8
8110cf64:	f800283a 	ret

8110cf68 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110cf68:	defffc04 	addi	sp,sp,-16
8110cf6c:	de00012e 	bgeu	sp,et,8110cf74 <bSyncCtrCh5OutEnable+0xc>
8110cf70:	003b68fa 	trap	3
8110cf74:	dfc00315 	stw	ra,12(sp)
8110cf78:	df000215 	stw	fp,8(sp)
8110cf7c:	df000204 	addi	fp,sp,8
8110cf80:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cf84:	01000284 	movi	r4,10
8110cf88:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110cf8c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110cf90:	e0bfff17 	ldw	r2,-4(fp)
8110cf94:	1000051e 	bne	r2,zero,8110cfac <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110cf98:	e0fffe17 	ldw	r3,-8(fp)
8110cf9c:	00bffbc4 	movi	r2,-17
8110cfa0:	1884703a 	and	r2,r3,r2
8110cfa4:	e0bffe15 	stw	r2,-8(fp)
8110cfa8:	00000306 	br	8110cfb8 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110cfac:	e0bffe17 	ldw	r2,-8(fp)
8110cfb0:	10800414 	ori	r2,r2,16
8110cfb4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110cfb8:	e17ffe17 	ldw	r5,-8(fp)
8110cfbc:	01000284 	movi	r4,10
8110cfc0:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110cfc4:	00800044 	movi	r2,1
}
8110cfc8:	e037883a 	mov	sp,fp
8110cfcc:	dfc00117 	ldw	ra,4(sp)
8110cfd0:	df000017 	ldw	fp,0(sp)
8110cfd4:	dec00204 	addi	sp,sp,8
8110cfd8:	f800283a 	ret

8110cfdc <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110cfdc:	defffc04 	addi	sp,sp,-16
8110cfe0:	de00012e 	bgeu	sp,et,8110cfe8 <bSyncCtrCh6OutEnable+0xc>
8110cfe4:	003b68fa 	trap	3
8110cfe8:	dfc00315 	stw	ra,12(sp)
8110cfec:	df000215 	stw	fp,8(sp)
8110cff0:	df000204 	addi	fp,sp,8
8110cff4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110cff8:	01000284 	movi	r4,10
8110cffc:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d000:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d004:	e0bfff17 	ldw	r2,-4(fp)
8110d008:	1000051e 	bne	r2,zero,8110d020 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110d00c:	e0fffe17 	ldw	r3,-8(fp)
8110d010:	00bff7c4 	movi	r2,-33
8110d014:	1884703a 	and	r2,r3,r2
8110d018:	e0bffe15 	stw	r2,-8(fp)
8110d01c:	00000306 	br	8110d02c <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110d020:	e0bffe17 	ldw	r2,-8(fp)
8110d024:	10800814 	ori	r2,r2,32
8110d028:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d02c:	e17ffe17 	ldw	r5,-8(fp)
8110d030:	01000284 	movi	r4,10
8110d034:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d038:	00800044 	movi	r2,1
}
8110d03c:	e037883a 	mov	sp,fp
8110d040:	dfc00117 	ldw	ra,4(sp)
8110d044:	df000017 	ldw	fp,0(sp)
8110d048:	dec00204 	addi	sp,sp,8
8110d04c:	f800283a 	ret

8110d050 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110d050:	defffc04 	addi	sp,sp,-16
8110d054:	de00012e 	bgeu	sp,et,8110d05c <bSyncCtrCh7OutEnable+0xc>
8110d058:	003b68fa 	trap	3
8110d05c:	dfc00315 	stw	ra,12(sp)
8110d060:	df000215 	stw	fp,8(sp)
8110d064:	df000204 	addi	fp,sp,8
8110d068:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d06c:	01000284 	movi	r4,10
8110d070:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d074:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d078:	e0bfff17 	ldw	r2,-4(fp)
8110d07c:	1000051e 	bne	r2,zero,8110d094 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110d080:	e0fffe17 	ldw	r3,-8(fp)
8110d084:	00bfefc4 	movi	r2,-65
8110d088:	1884703a 	and	r2,r3,r2
8110d08c:	e0bffe15 	stw	r2,-8(fp)
8110d090:	00000306 	br	8110d0a0 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110d094:	e0bffe17 	ldw	r2,-8(fp)
8110d098:	10801014 	ori	r2,r2,64
8110d09c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d0a0:	e17ffe17 	ldw	r5,-8(fp)
8110d0a4:	01000284 	movi	r4,10
8110d0a8:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d0ac:	00800044 	movi	r2,1
}
8110d0b0:	e037883a 	mov	sp,fp
8110d0b4:	dfc00117 	ldw	ra,4(sp)
8110d0b8:	df000017 	ldw	fp,0(sp)
8110d0bc:	dec00204 	addi	sp,sp,8
8110d0c0:	f800283a 	ret

8110d0c4 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110d0c4:	defffc04 	addi	sp,sp,-16
8110d0c8:	de00012e 	bgeu	sp,et,8110d0d0 <bSyncCtrCh8OutEnable+0xc>
8110d0cc:	003b68fa 	trap	3
8110d0d0:	dfc00315 	stw	ra,12(sp)
8110d0d4:	df000215 	stw	fp,8(sp)
8110d0d8:	df000204 	addi	fp,sp,8
8110d0dc:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d0e0:	01000284 	movi	r4,10
8110d0e4:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d0e8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d0ec:	e0bfff17 	ldw	r2,-4(fp)
8110d0f0:	1000051e 	bne	r2,zero,8110d108 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110d0f4:	e0fffe17 	ldw	r3,-8(fp)
8110d0f8:	00bfdfc4 	movi	r2,-129
8110d0fc:	1884703a 	and	r2,r3,r2
8110d100:	e0bffe15 	stw	r2,-8(fp)
8110d104:	00000306 	br	8110d114 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110d108:	e0bffe17 	ldw	r2,-8(fp)
8110d10c:	10802014 	ori	r2,r2,128
8110d110:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110d114:	e17ffe17 	ldw	r5,-8(fp)
8110d118:	01000284 	movi	r4,10
8110d11c:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d120:	00800044 	movi	r2,1
}
8110d124:	e037883a 	mov	sp,fp
8110d128:	dfc00117 	ldw	ra,4(sp)
8110d12c:	df000017 	ldw	fp,0(sp)
8110d130:	dec00204 	addi	sp,sp,8
8110d134:	f800283a 	ret

8110d138 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110d138:	defffc04 	addi	sp,sp,-16
8110d13c:	de00012e 	bgeu	sp,et,8110d144 <bSyncIrqEnableError+0xc>
8110d140:	003b68fa 	trap	3
8110d144:	dfc00315 	stw	ra,12(sp)
8110d148:	df000215 	stw	fp,8(sp)
8110d14c:	df000204 	addi	fp,sp,8
8110d150:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d154:	01000044 	movi	r4,1
8110d158:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d15c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d160:	e0bfff17 	ldw	r2,-4(fp)
8110d164:	1000051e 	bne	r2,zero,8110d17c <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110d168:	e0fffe17 	ldw	r3,-8(fp)
8110d16c:	00bfff44 	movi	r2,-3
8110d170:	1884703a 	and	r2,r3,r2
8110d174:	e0bffe15 	stw	r2,-8(fp)
8110d178:	00000306 	br	8110d188 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110d17c:	e0bffe17 	ldw	r2,-8(fp)
8110d180:	10800094 	ori	r2,r2,2
8110d184:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d188:	e17ffe17 	ldw	r5,-8(fp)
8110d18c:	01000044 	movi	r4,1
8110d190:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d194:	00800044 	movi	r2,1
}
8110d198:	e037883a 	mov	sp,fp
8110d19c:	dfc00117 	ldw	ra,4(sp)
8110d1a0:	df000017 	ldw	fp,0(sp)
8110d1a4:	dec00204 	addi	sp,sp,8
8110d1a8:	f800283a 	ret

8110d1ac <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110d1ac:	defffc04 	addi	sp,sp,-16
8110d1b0:	de00012e 	bgeu	sp,et,8110d1b8 <bSyncIrqEnableBlank+0xc>
8110d1b4:	003b68fa 	trap	3
8110d1b8:	dfc00315 	stw	ra,12(sp)
8110d1bc:	df000215 	stw	fp,8(sp)
8110d1c0:	df000204 	addi	fp,sp,8
8110d1c4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110d1c8:	01000044 	movi	r4,1
8110d1cc:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d1d0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d1d4:	e0bfff17 	ldw	r2,-4(fp)
8110d1d8:	1000051e 	bne	r2,zero,8110d1f0 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110d1dc:	e0fffe17 	ldw	r3,-8(fp)
8110d1e0:	00bfff84 	movi	r2,-2
8110d1e4:	1884703a 	and	r2,r3,r2
8110d1e8:	e0bffe15 	stw	r2,-8(fp)
8110d1ec:	00000306 	br	8110d1fc <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110d1f0:	e0bffe17 	ldw	r2,-8(fp)
8110d1f4:	10800054 	ori	r2,r2,1
8110d1f8:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110d1fc:	e17ffe17 	ldw	r5,-8(fp)
8110d200:	01000044 	movi	r4,1
8110d204:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d208:	00800044 	movi	r2,1
}
8110d20c:	e037883a 	mov	sp,fp
8110d210:	dfc00117 	ldw	ra,4(sp)
8110d214:	df000017 	ldw	fp,0(sp)
8110d218:	dec00204 	addi	sp,sp,8
8110d21c:	f800283a 	ret

8110d220 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110d220:	defffc04 	addi	sp,sp,-16
8110d224:	de00012e 	bgeu	sp,et,8110d22c <bSyncIrqFlagClrError+0xc>
8110d228:	003b68fa 	trap	3
8110d22c:	dfc00315 	stw	ra,12(sp)
8110d230:	df000215 	stw	fp,8(sp)
8110d234:	df000204 	addi	fp,sp,8
8110d238:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d23c:	01000084 	movi	r4,2
8110d240:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d244:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d248:	e0bfff17 	ldw	r2,-4(fp)
8110d24c:	1000051e 	bne	r2,zero,8110d264 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d250:	e0fffe17 	ldw	r3,-8(fp)
8110d254:	00bfff44 	movi	r2,-3
8110d258:	1884703a 	and	r2,r3,r2
8110d25c:	e0bffe15 	stw	r2,-8(fp)
8110d260:	00000306 	br	8110d270 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110d264:	e0bffe17 	ldw	r2,-8(fp)
8110d268:	10800094 	ori	r2,r2,2
8110d26c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d270:	e17ffe17 	ldw	r5,-8(fp)
8110d274:	01000084 	movi	r4,2
8110d278:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d27c:	00800044 	movi	r2,1
}
8110d280:	e037883a 	mov	sp,fp
8110d284:	dfc00117 	ldw	ra,4(sp)
8110d288:	df000017 	ldw	fp,0(sp)
8110d28c:	dec00204 	addi	sp,sp,8
8110d290:	f800283a 	ret

8110d294 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110d294:	defffc04 	addi	sp,sp,-16
8110d298:	de00012e 	bgeu	sp,et,8110d2a0 <bSyncIrqFlagClrBlank+0xc>
8110d29c:	003b68fa 	trap	3
8110d2a0:	dfc00315 	stw	ra,12(sp)
8110d2a4:	df000215 	stw	fp,8(sp)
8110d2a8:	df000204 	addi	fp,sp,8
8110d2ac:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110d2b0:	01000084 	movi	r4,2
8110d2b4:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d2b8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110d2bc:	e0bfff17 	ldw	r2,-4(fp)
8110d2c0:	1000051e 	bne	r2,zero,8110d2d8 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d2c4:	e0fffe17 	ldw	r3,-8(fp)
8110d2c8:	00bfff84 	movi	r2,-2
8110d2cc:	1884703a 	and	r2,r3,r2
8110d2d0:	e0bffe15 	stw	r2,-8(fp)
8110d2d4:	00000306 	br	8110d2e4 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110d2d8:	e0bffe17 	ldw	r2,-8(fp)
8110d2dc:	10800054 	ori	r2,r2,1
8110d2e0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110d2e4:	e17ffe17 	ldw	r5,-8(fp)
8110d2e8:	01000084 	movi	r4,2
8110d2ec:	110d4300 	call	8110d430 <bSyncWriteReg>
	return TRUE;
8110d2f0:	00800044 	movi	r2,1
}
8110d2f4:	e037883a 	mov	sp,fp
8110d2f8:	dfc00117 	ldw	ra,4(sp)
8110d2fc:	df000017 	ldw	fp,0(sp)
8110d300:	dec00204 	addi	sp,sp,8
8110d304:	f800283a 	ret

8110d308 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110d308:	defffc04 	addi	sp,sp,-16
8110d30c:	de00012e 	bgeu	sp,et,8110d314 <bSyncIrqFlagError+0xc>
8110d310:	003b68fa 	trap	3
8110d314:	dfc00315 	stw	ra,12(sp)
8110d318:	df000215 	stw	fp,8(sp)
8110d31c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d320:	010000c4 	movi	r4,3
8110d324:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d328:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110d32c:	e0bfff17 	ldw	r2,-4(fp)
8110d330:	1080008c 	andi	r2,r2,2
8110d334:	10000326 	beq	r2,zero,8110d344 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110d338:	00800044 	movi	r2,1
8110d33c:	e0bffe15 	stw	r2,-8(fp)
8110d340:	00000106 	br	8110d348 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110d344:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d348:	e0bffe17 	ldw	r2,-8(fp)
}
8110d34c:	e037883a 	mov	sp,fp
8110d350:	dfc00117 	ldw	ra,4(sp)
8110d354:	df000017 	ldw	fp,0(sp)
8110d358:	dec00204 	addi	sp,sp,8
8110d35c:	f800283a 	ret

8110d360 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110d360:	defffc04 	addi	sp,sp,-16
8110d364:	de00012e 	bgeu	sp,et,8110d36c <bSyncIrqFlagBlank+0xc>
8110d368:	003b68fa 	trap	3
8110d36c:	dfc00315 	stw	ra,12(sp)
8110d370:	df000215 	stw	fp,8(sp)
8110d374:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110d378:	010000c4 	movi	r4,3
8110d37c:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d380:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110d384:	e0bfff17 	ldw	r2,-4(fp)
8110d388:	1080004c 	andi	r2,r2,1
8110d38c:	10000326 	beq	r2,zero,8110d39c <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110d390:	00800044 	movi	r2,1
8110d394:	e0bffe15 	stw	r2,-8(fp)
8110d398:	00000106 	br	8110d3a0 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110d39c:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110d3a0:	e0bffe17 	ldw	r2,-8(fp)
}
8110d3a4:	e037883a 	mov	sp,fp
8110d3a8:	dfc00117 	ldw	ra,4(sp)
8110d3ac:	df000017 	ldw	fp,0(sp)
8110d3b0:	dec00204 	addi	sp,sp,8
8110d3b4:	f800283a 	ret

8110d3b8 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110d3b8:	defffd04 	addi	sp,sp,-12
8110d3bc:	de00012e 	bgeu	sp,et,8110d3c4 <uliSyncGetCtr+0xc>
8110d3c0:	003b68fa 	trap	3
8110d3c4:	dfc00215 	stw	ra,8(sp)
8110d3c8:	df000115 	stw	fp,4(sp)
8110d3cc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110d3d0:	01000284 	movi	r4,10
8110d3d4:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d3d8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110d3dc:	e0bfff17 	ldw	r2,-4(fp)
}
8110d3e0:	e037883a 	mov	sp,fp
8110d3e4:	dfc00117 	ldw	ra,4(sp)
8110d3e8:	df000017 	ldw	fp,0(sp)
8110d3ec:	dec00204 	addi	sp,sp,8
8110d3f0:	f800283a 	ret

8110d3f4 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110d3f4:	defffd04 	addi	sp,sp,-12
8110d3f8:	de00012e 	bgeu	sp,et,8110d400 <uliSyncReadStatus+0xc>
8110d3fc:	003b68fa 	trap	3
8110d400:	dfc00215 	stw	ra,8(sp)
8110d404:	df000115 	stw	fp,4(sp)
8110d408:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110d40c:	0009883a 	mov	r4,zero
8110d410:	110d48c0 	call	8110d48c <uliSyncReadReg>
8110d414:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110d418:	e0bfff17 	ldw	r2,-4(fp)
}
8110d41c:	e037883a 	mov	sp,fp
8110d420:	dfc00117 	ldw	ra,4(sp)
8110d424:	df000017 	ldw	fp,0(sp)
8110d428:	dec00204 	addi	sp,sp,8
8110d42c:	f800283a 	ret

8110d430 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110d430:	defffc04 	addi	sp,sp,-16
8110d434:	de00012e 	bgeu	sp,et,8110d43c <bSyncWriteReg+0xc>
8110d438:	003b68fa 	trap	3
8110d43c:	df000315 	stw	fp,12(sp)
8110d440:	df000304 	addi	fp,sp,12
8110d444:	e13ffe15 	stw	r4,-8(fp)
8110d448:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d44c:	00a00034 	movhi	r2,32768
8110d450:	10810004 	addi	r2,r2,1024
8110d454:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110d458:	e0bffe17 	ldw	r2,-8(fp)
8110d45c:	1085883a 	add	r2,r2,r2
8110d460:	1085883a 	add	r2,r2,r2
8110d464:	1007883a 	mov	r3,r2
8110d468:	e0bffd17 	ldw	r2,-12(fp)
8110d46c:	10c5883a 	add	r2,r2,r3
8110d470:	e0ffff17 	ldw	r3,-4(fp)
8110d474:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110d478:	00800044 	movi	r2,1
}
8110d47c:	e037883a 	mov	sp,fp
8110d480:	df000017 	ldw	fp,0(sp)
8110d484:	dec00104 	addi	sp,sp,4
8110d488:	f800283a 	ret

8110d48c <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110d48c:	defffc04 	addi	sp,sp,-16
8110d490:	de00012e 	bgeu	sp,et,8110d498 <uliSyncReadReg+0xc>
8110d494:	003b68fa 	trap	3
8110d498:	df000315 	stw	fp,12(sp)
8110d49c:	df000304 	addi	fp,sp,12
8110d4a0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110d4a4:	00a00034 	movhi	r2,32768
8110d4a8:	10810004 	addi	r2,r2,1024
8110d4ac:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110d4b0:	e0bfff17 	ldw	r2,-4(fp)
8110d4b4:	1085883a 	add	r2,r2,r2
8110d4b8:	1085883a 	add	r2,r2,r2
8110d4bc:	1007883a 	mov	r3,r2
8110d4c0:	e0bffd17 	ldw	r2,-12(fp)
8110d4c4:	10c5883a 	add	r2,r2,r3
8110d4c8:	10800017 	ldw	r2,0(r2)
8110d4cc:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110d4d0:	e0bffe17 	ldw	r2,-8(fp)
}
8110d4d4:	e037883a 	mov	sp,fp
8110d4d8:	df000017 	ldw	fp,0(sp)
8110d4dc:	dec00104 	addi	sp,sp,4
8110d4e0:	f800283a 	ret

8110d4e4 <uliPerCalcPeriodMs>:

/*
 * Return the necessary PER value for a
 * Sync Signal period in usiPeriodMs ms.
 */
alt_u32 uliPerCalcPeriodMs(alt_u16 usiPeriodMs) {
8110d4e4:	defffc04 	addi	sp,sp,-16
8110d4e8:	de00012e 	bgeu	sp,et,8110d4f0 <uliPerCalcPeriodMs+0xc>
8110d4ec:	003b68fa 	trap	3
8110d4f0:	dfc00315 	stw	ra,12(sp)
8110d4f4:	df000215 	stw	fp,8(sp)
8110d4f8:	df000204 	addi	fp,sp,8
8110d4fc:	2005883a 	mov	r2,r4
8110d500:	e0bfff0d 	sth	r2,-4(fp)
	 * Period[ms] / 20e-6 = Period[ms] * 5e+4
	 * PER = Period[ms] * 5e+4
	 */

	alt_u32 uliPer;
	uliPer = usiPeriodMs * 5e+4;
8110d504:	e0bfff0b 	ldhu	r2,-4(fp)
8110d508:	1009883a 	mov	r4,r2
8110d50c:	111f0980 	call	8111f098 <__floatsidf>
8110d510:	1011883a 	mov	r8,r2
8110d514:	1813883a 	mov	r9,r3
8110d518:	000d883a 	mov	r6,zero
8110d51c:	01d03a34 	movhi	r7,16616
8110d520:	39da8004 	addi	r7,r7,27136
8110d524:	4009883a 	mov	r4,r8
8110d528:	480b883a 	mov	r5,r9
8110d52c:	111dff40 	call	8111dff4 <__muldf3>
8110d530:	1009883a 	mov	r4,r2
8110d534:	180b883a 	mov	r5,r3
8110d538:	2005883a 	mov	r2,r4
8110d53c:	2807883a 	mov	r3,r5
8110d540:	1009883a 	mov	r4,r2
8110d544:	180b883a 	mov	r5,r3
8110d548:	111d42c0 	call	8111d42c <__fixunsdfsi>
8110d54c:	e0bffe15 	stw	r2,-8(fp)

	return uliPer;
8110d550:	e0bffe17 	ldw	r2,-8(fp)
}
8110d554:	e037883a 	mov	sp,fp
8110d558:	dfc00117 	ldw	ra,4(sp)
8110d55c:	df000017 	ldw	fp,0(sp)
8110d560:	dec00204 	addi	sp,sp,8
8110d564:	f800283a 	ret

8110d568 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110d568:	defff804 	addi	sp,sp,-32
8110d56c:	de00012e 	bgeu	sp,et,8110d574 <vDataControlTask+0xc>
8110d570:	003b68fa 	trap	3
8110d574:	dfc00715 	stw	ra,28(sp)
8110d578:	df000615 	stw	fp,24(sp)
8110d57c:	df000604 	addi	fp,sp,24
8110d580:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110d584:	e0bffd17 	ldw	r2,-12(fp)
8110d588:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110d58c:	d0a06117 	ldw	r2,-32380(gp)
8110d590:	100f883a 	mov	r7,r2
8110d594:	01800804 	movi	r6,32
8110d598:	01400044 	movi	r5,1
8110d59c:	01204574 	movhi	r4,33045
8110d5a0:	21298304 	addi	r4,r4,-23028
8110d5a4:	111fc980 	call	8111fc98 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110d5a8:	e0bffa17 	ldw	r2,-24(fp)
8110d5ac:	00c00044 	movi	r3,1
8110d5b0:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110d5b4:	d0a05e17 	ldw	r2,-32392(gp)
8110d5b8:	1009883a 	mov	r4,r2
8110d5bc:	113bb600 	call	8113bb60 <OSQFlush>
8110d5c0:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110d5c4:	e0bffc03 	ldbu	r2,-16(fp)
8110d5c8:	10803fcc 	andi	r2,r2,255
8110d5cc:	10000126 	beq	r2,zero,8110d5d4 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110d5d0:	111b7d40 	call	8111b7d4 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110d5d4:	e0bffc04 	addi	r2,fp,-16
8110d5d8:	100d883a 	mov	r6,r2
8110d5dc:	000b883a 	mov	r5,zero
8110d5e0:	012045b4 	movhi	r4,33046
8110d5e4:	2125b204 	addi	r4,r4,-26936
8110d5e8:	113bc200 	call	8113bc20 <OSQPend>
8110d5ec:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110d5f0:	000f883a 	mov	r7,zero
8110d5f4:	01800144 	movi	r6,5
8110d5f8:	000b883a 	mov	r5,zero
8110d5fc:	0009883a 	mov	r4,zero
8110d600:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
	}
8110d604:	003ff306 	br	8110d5d4 <__reset+0xfb0ed5d4>

8110d608 <vFeeTask>:

#include "fee_task.h"

TRmapChannel RmapConfAreaL;

void vFeeTask(void *task_data) {
8110d608:	defff104 	addi	sp,sp,-60
8110d60c:	de00012e 	bgeu	sp,et,8110d614 <vFeeTask+0xc>
8110d610:	003b68fa 	trap	3
8110d614:	dfc00e15 	stw	ra,56(sp)
8110d618:	df000d15 	stw	fp,52(sp)
8110d61c:	df000d04 	addi	fp,sp,52
8110d620:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110d624:	e03ffb15 	stw	zero,-20(fp)
	bool bFinal;
	alt_u16 *pusiHK;
	unsigned char ucIL;


	pxNFee = ( TNFee * ) task_data;
8110d628:	e0bfff17 	ldw	r2,-4(fp)
8110d62c:	d0a05315 	stw	r2,-32436(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110d630:	d0e06117 	ldw	r3,-32380(gp)
8110d634:	d0a05317 	ldw	r2,-32436(gp)
8110d638:	10800003 	ldbu	r2,0(r2)
8110d63c:	10803fcc 	andi	r2,r2,255
8110d640:	100d883a 	mov	r6,r2
8110d644:	01604574 	movhi	r5,33045
8110d648:	29698c04 	addi	r5,r5,-22992
8110d64c:	1809883a 	mov	r4,r3
8110d650:	111f5fc0 	call	8111f5fc <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110d654:	d0a05317 	ldw	r2,-32436(gp)
8110d658:	1009883a 	mov	r4,r2
8110d65c:	110fc040 	call	8110fc04 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110d660:	d0a05317 	ldw	r2,-32436(gp)
8110d664:	10802c17 	ldw	r2,176(r2)
8110d668:	10c00368 	cmpgeui	r3,r2,13
8110d66c:	18041a1e 	bne	r3,zero,8110e6d8 <vFeeTask+0x10d0>
8110d670:	100690ba 	slli	r3,r2,2
8110d674:	00a04474 	movhi	r2,33041
8110d678:	10b5a204 	addi	r2,r2,-10616
8110d67c:	1885883a 	add	r2,r3,r2
8110d680:	10800017 	ldw	r2,0(r2)
8110d684:	1000683a 	jmp	r2
8110d688:	8110d6bc 	xorhi	r4,r16,17242
8110d68c:	8110d9f8 	rdprs	r4,r16,17255
8110d690:	8110da7c 	xorhi	r4,r16,17257
8110d694:	8110dbcc 	andi	r4,r16,17263
8110d698:	8110e268 	cmpgeui	r4,r16,17289
8110d69c:	8110d83c 	xorhi	r4,r16,17248
8110d6a0:	8110da8c 	andi	r4,r16,17258
8110d6a4:	8110e1ac 	andhi	r4,r16,17286
8110d6a8:	8110e6d8 	cmpnei	r4,r16,17307
8110d6ac:	8110e6d8 	cmpnei	r4,r16,17307
8110d6b0:	8110dc50 	cmplti	r4,r16,17265
8110d6b4:	8110e5d4 	ori	r4,r16,17303
8110d6b8:	8110e630 	cmpltui	r4,r16,17304
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110d6bc:	d0a05317 	ldw	r2,-32436(gp)
8110d6c0:	10800003 	ldbu	r2,0(r2)
8110d6c4:	10803fcc 	andi	r2,r2,255
8110d6c8:	1085883a 	add	r2,r2,r2
8110d6cc:	1087883a 	add	r3,r2,r2
8110d6d0:	d0a06904 	addi	r2,gp,-32348
8110d6d4:	1885883a 	add	r2,r3,r2
8110d6d8:	10800017 	ldw	r2,0(r2)
8110d6dc:	1009883a 	mov	r4,r2
8110d6e0:	113bb600 	call	8113bb60 <OSQFlush>
8110d6e4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d6e8:	e0bffd03 	ldbu	r2,-12(fp)
8110d6ec:	10803fcc 	andi	r2,r2,255
8110d6f0:	10000126 	beq	r2,zero,8110d6f8 <vFeeTask+0xf0>
					vFailFlushNFEEQueue();
8110d6f4:	111b86c0 	call	8111b86c <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d6f8:	d0a05317 	ldw	r2,-32436(gp)
8110d6fc:	10800003 	ldbu	r2,0(r2)
8110d700:	10803fcc 	andi	r2,r2,255
8110d704:	1085883a 	add	r2,r2,r2
8110d708:	1087883a 	add	r3,r2,r2
8110d70c:	d0a05b04 	addi	r2,gp,-32404
8110d710:	1885883a 	add	r2,r3,r2
8110d714:	10800017 	ldw	r2,0(r2)
8110d718:	1009883a 	mov	r4,r2
8110d71c:	113bb600 	call	8113bb60 <OSQFlush>
8110d720:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d724:	e0bffd03 	ldbu	r2,-12(fp)
8110d728:	10803fcc 	andi	r2,r2,255
8110d72c:	10000126 	beq	r2,zero,8110d734 <vFeeTask+0x12c>
					vFailFlushNFEEQueue();
8110d730:	111b86c0 	call	8111b86c <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d734:	d0a05317 	ldw	r2,-32436(gp)
8110d738:	10803304 	addi	r2,r2,204
8110d73c:	1009883a 	mov	r4,r2
8110d740:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth;
8110d744:	d0a05317 	ldw	r2,-32436(gp)
8110d748:	d0e05317 	ldw	r3,-32436(gp)
8110d74c:	18c0308b 	ldhu	r3,194(r3)
8110d750:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight;
8110d754:	d0a05317 	ldw	r2,-32436(gp)
8110d758:	d0e05317 	ldw	r3,-32436(gp)
8110d75c:	18c0310b 	ldhu	r3,196(r3)
8110d760:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight - pxNFee->xCcdInfo.usiOLN;
8110d764:	d0a05317 	ldw	r2,-32436(gp)
8110d768:	d0e05317 	ldw	r3,-32436(gp)
8110d76c:	1900310b 	ldhu	r4,196(r3)
8110d770:	d0e05317 	ldw	r3,-32436(gp)
8110d774:	18c0300b 	ldhu	r3,192(r3)
8110d778:	20c7c83a 	sub	r3,r4,r3
8110d77c:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110d780:	d0a05317 	ldw	r2,-32436(gp)
8110d784:	d0e05317 	ldw	r3,-32436(gp)
8110d788:	18c0300b 	ldhu	r3,192(r3)
8110d78c:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110d790:	d0a05317 	ldw	r2,-32436(gp)
8110d794:	00e00004 	movi	r3,-32768
8110d798:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110d79c:	d0a05317 	ldw	r2,-32436(gp)
8110d7a0:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110d7a4:	d0a05317 	ldw	r2,-32436(gp)
8110d7a8:	00c00044 	movi	r3,1
8110d7ac:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d7b0:	d0a05317 	ldw	r2,-32436(gp)
8110d7b4:	10803304 	addi	r2,r2,204
8110d7b8:	1009883a 	mov	r4,r2
8110d7bc:	11048180 	call	81104818 <bDpktSetPacketConfig>

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110d7c0:	d0a05317 	ldw	r2,-32436(gp)
8110d7c4:	10804304 	addi	r2,r2,268
8110d7c8:	1009883a 	mov	r4,r2
8110d7cc:	1108ff80 	call	81108ff8 <bRmapGetRmapMemHKArea>
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
8110d7d0:	d0a05317 	ldw	r2,-32436(gp)
8110d7d4:	10806904 	addi	r2,r2,420
8110d7d8:	e0bff915 	stw	r2,-28(fp)
				for (ucIL = 0; ucIL < 128; ++ucIL) {
8110d7dc:	e03ffa05 	stb	zero,-24(fp)
8110d7e0:	00000906 	br	8110d808 <vFeeTask+0x200>
					*pusiHK = ucIL;
8110d7e4:	e0fffa03 	ldbu	r3,-24(fp)
8110d7e8:	e0bff917 	ldw	r2,-28(fp)
8110d7ec:	10c0000d 	sth	r3,0(r2)
					pusiHK++;
8110d7f0:	e0bff917 	ldw	r2,-28(fp)
8110d7f4:	10800084 	addi	r2,r2,2
8110d7f8:	e0bff915 	stw	r2,-28(fp)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);

				bRmapGetRmapMemHKArea(&pxNFee->xChannel.xRmap);
				pusiHK = &pxNFee->xChannel.xRmap.xRmapMemHKArea.usiHkCcd1VodE;
				for (ucIL = 0; ucIL < 128; ++ucIL) {
8110d7fc:	e0bffa03 	ldbu	r2,-24(fp)
8110d800:	10800044 	addi	r2,r2,1
8110d804:	e0bffa05 	stb	r2,-24(fp)
8110d808:	e0bffa03 	ldbu	r2,-24(fp)
8110d80c:	10803fcc 	andi	r2,r2,255
8110d810:	1080201c 	xori	r2,r2,128
8110d814:	10bfe004 	addi	r2,r2,-128
8110d818:	103ff20e 	bge	r2,zero,8110d7e4 <__reset+0xfb0ed7e4>
					*pusiHK = ucIL;
					pusiHK++;
				}

				bRmapSetRmapMemHKArea(&pxNFee->xChannel.xRmap);
8110d81c:	d0a05317 	ldw	r2,-32436(gp)
8110d820:	10804304 	addi	r2,r2,268
8110d824:	1009883a 	mov	r4,r2
8110d828:	11083ac0 	call	811083ac <bRmapSetRmapMemHKArea>


				pxNFee->xControl.eMode = sToFeeConfig;
8110d82c:	d0a05317 	ldw	r2,-32436(gp)
8110d830:	00c00144 	movi	r3,5
8110d834:	10c02c15 	stw	r3,176(r2)

				break;
8110d838:	0003b706 	br	8110e718 <vFeeTask+0x1110>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d83c:	d0a05317 	ldw	r2,-32436(gp)
8110d840:	10804304 	addi	r2,r2,268
8110d844:	1009883a 	mov	r4,r2
8110d848:	11080440 	call	81108044 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110d84c:	d0a05317 	ldw	r2,-32436(gp)
8110d850:	00c00184 	movi	r3,6
8110d854:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d858:	d0a05317 	ldw	r2,-32436(gp)
8110d85c:	10804304 	addi	r2,r2,268
8110d860:	1009883a 	mov	r4,r2
8110d864:	1107d580 	call	81107d58 <bRmapSetMemConfigArea>

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110d868:	d0a05317 	ldw	r2,-32436(gp)
8110d86c:	10808904 	addi	r2,r2,548
8110d870:	1009883a 	mov	r4,r2
8110d874:	110f9100 	call	8110f910 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110d878:	d0a05317 	ldw	r2,-32436(gp)
8110d87c:	10002615 	stw	zero,152(r2)

				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110d880:	d0a05317 	ldw	r2,-32436(gp)
8110d884:	10c04304 	addi	r3,r2,268
8110d888:	d0a05317 	ldw	r2,-32436(gp)
8110d88c:	10800003 	ldbu	r2,0(r2)
8110d890:	10803fcc 	andi	r2,r2,255
8110d894:	100b883a 	mov	r5,r2
8110d898:	1809883a 	mov	r4,r3
8110d89c:	110f8640 	call	8110f864 <bDisableRmapIRQ>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110d8a0:	d0a05317 	ldw	r2,-32436(gp)
8110d8a4:	10803b04 	addi	r2,r2,236
8110d8a8:	1009883a 	mov	r4,r2
8110d8ac:	110fa580 	call	8110fa58 <bDisAndClrDbBuffer>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110d8b0:	d0e06117 	ldw	r3,-32380(gp)
8110d8b4:	d0a05317 	ldw	r2,-32436(gp)
8110d8b8:	10800003 	ldbu	r2,0(r2)
8110d8bc:	10803fcc 	andi	r2,r2,255
8110d8c0:	100d883a 	mov	r6,r2
8110d8c4:	01604574 	movhi	r5,33045
8110d8c8:	29699304 	addi	r5,r5,-22964
8110d8cc:	1809883a 	mov	r4,r3
8110d8d0:	111f5fc0 	call	8111f5fc <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110d8d4:	d0a05317 	ldw	r2,-32436(gp)
8110d8d8:	10802217 	ldw	r2,136(r2)
8110d8dc:	10800058 	cmpnei	r2,r2,1
8110d8e0:	10000a1e 	bne	r2,zero,8110d90c <vFeeTask+0x304>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d8e4:	e0fff403 	ldbu	r3,-48(fp)
8110d8e8:	00a045b4 	movhi	r2,33046
8110d8ec:	10850004 	addi	r2,r2,5120
8110d8f0:	180690fa 	slli	r3,r3,3
8110d8f4:	10c5883a 	add	r2,r2,r3
8110d8f8:	10800017 	ldw	r2,0(r2)
8110d8fc:	1009883a 	mov	r4,r2
8110d900:	113b0b00 	call	8113b0b0 <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110d904:	d0a05317 	ldw	r2,-32436(gp)
8110d908:	10002215 	stw	zero,136(r2)
				}

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110d90c:	d0a05317 	ldw	r2,-32436(gp)
8110d910:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110d914:	d0a05317 	ldw	r2,-32436(gp)
8110d918:	10800003 	ldbu	r2,0(r2)
8110d91c:	10803fcc 	andi	r2,r2,255
8110d920:	1085883a 	add	r2,r2,r2
8110d924:	1087883a 	add	r3,r2,r2
8110d928:	d0a05b04 	addi	r2,gp,-32404
8110d92c:	1885883a 	add	r2,r3,r2
8110d930:	10800017 	ldw	r2,0(r2)
8110d934:	1009883a 	mov	r4,r2
8110d938:	113bb600 	call	8113bb60 <OSQFlush>
8110d93c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d940:	e0bffd03 	ldbu	r2,-12(fp)
8110d944:	10803fcc 	andi	r2,r2,255
8110d948:	10000126 	beq	r2,zero,8110d950 <vFeeTask+0x348>
					vFailFlushNFEEQueue();
8110d94c:	111b86c0 	call	8111b86c <vFailFlushNFEEQueue>
				}

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d950:	d0a05317 	ldw	r2,-32436(gp)
8110d954:	10800003 	ldbu	r2,0(r2)
8110d958:	10803fcc 	andi	r2,r2,255
8110d95c:	100d883a 	mov	r6,r2
8110d960:	000b883a 	mov	r5,zero
8110d964:	01002044 	movi	r4,129
8110d968:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110d96c:	d0a05317 	ldw	r2,-32436(gp)
8110d970:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110d974:	d0a05317 	ldw	r2,-32436(gp)
8110d978:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110d97c:	d0a05317 	ldw	r2,-32436(gp)
8110d980:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110d984:	d0a05317 	ldw	r2,-32436(gp)
8110d988:	00c00044 	movi	r3,1
8110d98c:	10c02115 	stw	r3,132(r2)

				vResetMemCCDFEE(pxNFee);
8110d990:	d0a05317 	ldw	r2,-32436(gp)
8110d994:	1009883a 	mov	r4,r2
8110d998:	111be380 	call	8111be38 <vResetMemCCDFEE>

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110d99c:	d0a05317 	ldw	r2,-32436(gp)
8110d9a0:	10800003 	ldbu	r2,0(r2)
8110d9a4:	10803fcc 	andi	r2,r2,255
8110d9a8:	1085883a 	add	r2,r2,r2
8110d9ac:	1087883a 	add	r3,r2,r2
8110d9b0:	d0a06904 	addi	r2,gp,-32348
8110d9b4:	1885883a 	add	r2,r3,r2
8110d9b8:	10800017 	ldw	r2,0(r2)
8110d9bc:	1009883a 	mov	r4,r2
8110d9c0:	113bb600 	call	8113bb60 <OSQFlush>
8110d9c4:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110d9c8:	e0bffd03 	ldbu	r2,-12(fp)
8110d9cc:	10803fcc 	andi	r2,r2,255
8110d9d0:	10000126 	beq	r2,zero,8110d9d8 <vFeeTask+0x3d0>
					vFailFlushNFEEQueue();
8110d9d4:	111b86c0 	call	8111b86c <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bWatingSync = TRUE;
8110d9d8:	d0a05317 	ldw	r2,-32436(gp)
8110d9dc:	00c00044 	movi	r3,1
8110d9e0:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeConfig;
8110d9e4:	d0a05317 	ldw	r2,-32436(gp)
8110d9e8:	00c00044 	movi	r3,1
8110d9ec:	10c02c15 	stw	r3,176(r2)
				bFinal = FALSE;
8110d9f0:	e03ff815 	stw	zero,-32(fp)
				break;
8110d9f4:	00034806 	br	8110e718 <vFeeTask+0x1110>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d9f8:	d0a05317 	ldw	r2,-32436(gp)
8110d9fc:	10800003 	ldbu	r2,0(r2)
8110da00:	10803fcc 	andi	r2,r2,255
8110da04:	1085883a 	add	r2,r2,r2
8110da08:	1087883a 	add	r3,r2,r2
8110da0c:	d0a06904 	addi	r2,gp,-32348
8110da10:	1885883a 	add	r2,r3,r2
8110da14:	10800017 	ldw	r2,0(r2)
8110da18:	e0fffd04 	addi	r3,fp,-12
8110da1c:	180d883a 	mov	r6,r3
8110da20:	000b883a 	mov	r5,zero
8110da24:	1009883a 	mov	r4,r2
8110da28:	113bc200 	call	8113bc20 <OSQPend>
8110da2c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110da30:	e0bffd03 	ldbu	r2,-12(fp)
8110da34:	10803fcc 	andi	r2,r2,255
8110da38:	1000061e 	bne	r2,zero,8110da54 <vFeeTask+0x44c>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110da3c:	d0a05317 	ldw	r2,-32436(gp)
8110da40:	e0fffe17 	ldw	r3,-8(fp)
8110da44:	180b883a 	mov	r5,r3
8110da48:	1009883a 	mov	r4,r2
8110da4c:	110e9040 	call	8110e904 <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110da50:	00033106 	br	8110e718 <vFeeTask+0x1110>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110da54:	d0e06117 	ldw	r3,-32380(gp)
8110da58:	d0a05317 	ldw	r2,-32436(gp)
8110da5c:	10800003 	ldbu	r2,0(r2)
8110da60:	10803fcc 	andi	r2,r2,255
8110da64:	100d883a 	mov	r6,r2
8110da68:	01604574 	movhi	r5,33045
8110da6c:	29699a04 	addi	r5,r5,-22936
8110da70:	1809883a 	mov	r4,r3
8110da74:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
				}

				break;
8110da78:	00032706 	br	8110e718 <vFeeTask+0x1110>
			case sFeeOn: /* Not implemented yet */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110da7c:	d0a05317 	ldw	r2,-32436(gp)
8110da80:	00c00184 	movi	r3,6
8110da84:	10c02c15 	stw	r3,176(r2)
				break;
8110da88:	00032306 	br	8110e718 <vFeeTask+0x1110>
			case sToFeeStandBy: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110da8c:	d0a05317 	ldw	r2,-32436(gp)
8110da90:	10804304 	addi	r2,r2,268
8110da94:	1009883a 	mov	r4,r2
8110da98:	11080440 	call	81108044 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110da9c:	d0a05317 	ldw	r2,-32436(gp)
8110daa0:	10006615 	stw	zero,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110daa4:	d0a05317 	ldw	r2,-32436(gp)
8110daa8:	10804304 	addi	r2,r2,268
8110daac:	1009883a 	mov	r4,r2
8110dab0:	1107d580 	call	81107d58 <bRmapSetMemConfigArea>

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110dab4:	d0a05317 	ldw	r2,-32436(gp)
8110dab8:	10803b04 	addi	r2,r2,236
8110dabc:	1009883a 	mov	r4,r2
8110dac0:	110fa580 	call	8110fa58 <bDisAndClrDbBuffer>

				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap, pxNFee->ucId);
8110dac4:	d0a05317 	ldw	r2,-32436(gp)
8110dac8:	10c04304 	addi	r3,r2,268
8110dacc:	d0a05317 	ldw	r2,-32436(gp)
8110dad0:	10800003 	ldbu	r2,0(r2)
8110dad4:	10803fcc 	andi	r2,r2,255
8110dad8:	100b883a 	mov	r5,r2
8110dadc:	1809883a 	mov	r4,r3
8110dae0:	110f8b80 	call	8110f8b8 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110dae4:	d0a05317 	ldw	r2,-32436(gp)
8110dae8:	10808904 	addi	r2,r2,548
8110daec:	1009883a 	mov	r4,r2
8110daf0:	110f9700 	call	8110f970 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110daf4:	d0a05317 	ldw	r2,-32436(gp)
8110daf8:	00c00044 	movi	r3,1
8110dafc:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.bSimulating = TRUE;
8110db00:	d0a05317 	ldw	r2,-32436(gp)
8110db04:	00c00044 	movi	r3,1
8110db08:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110db0c:	d0a05317 	ldw	r2,-32436(gp)
8110db10:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110db14:	d0a05317 	ldw	r2,-32436(gp)
8110db18:	00c00044 	movi	r3,1
8110db1c:	10c02115 	stw	r3,132(r2)

				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110db20:	d0a05317 	ldw	r2,-32436(gp)
8110db24:	10800003 	ldbu	r2,0(r2)
8110db28:	10803fcc 	andi	r2,r2,255
8110db2c:	100d883a 	mov	r6,r2
8110db30:	000b883a 	mov	r5,zero
8110db34:	01002044 	movi	r4,129
8110db38:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>

				/* Cleaning other syncs that maybe in the queue */
				pxNFee->xControl.bWatingSync = FALSE;
8110db3c:	d0a05317 	ldw	r2,-32436(gp)
8110db40:	10002815 	stw	zero,160(r2)
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110db44:	d0a05317 	ldw	r2,-32436(gp)
8110db48:	10800003 	ldbu	r2,0(r2)
8110db4c:	10803fcc 	andi	r2,r2,255
8110db50:	1085883a 	add	r2,r2,r2
8110db54:	1087883a 	add	r3,r2,r2
8110db58:	d0a05b04 	addi	r2,gp,-32404
8110db5c:	1885883a 	add	r2,r3,r2
8110db60:	10800017 	ldw	r2,0(r2)
8110db64:	1009883a 	mov	r4,r2
8110db68:	113bb600 	call	8113bb60 <OSQFlush>
8110db6c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110db70:	e0bffd03 	ldbu	r2,-12(fp)
8110db74:	10803fcc 	andi	r2,r2,255
8110db78:	10000126 	beq	r2,zero,8110db80 <vFeeTask+0x578>
					vFailFlushNFEEQueue();
8110db7c:	111b86c0 	call	8111b86c <vFailFlushNFEEQueue>
				}

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110db80:	d0e06117 	ldw	r3,-32380(gp)
8110db84:	d0a05317 	ldw	r2,-32436(gp)
8110db88:	10800003 	ldbu	r2,0(r2)
8110db8c:	10803fcc 	andi	r2,r2,255
8110db90:	100d883a 	mov	r6,r2
8110db94:	01604574 	movhi	r5,33045
8110db98:	2969a604 	addi	r5,r5,-22888
8110db9c:	1809883a 	mov	r4,r3
8110dba0:	111f5fc0 	call	8111f5fc <fprintf>
				#endif

				/* Reset the memory addr variables thats is used in the transmission*/
				vResetMemCCDFEE(pxNFee);
8110dba4:	d0a05317 	ldw	r2,-32436(gp)
8110dba8:	1009883a 	mov	r4,r2
8110dbac:	111be380 	call	8111be38 <vResetMemCCDFEE>

				pxNFee->xControl.bWatingSync = TRUE;
8110dbb0:	d0a05317 	ldw	r2,-32436(gp)
8110dbb4:	00c00044 	movi	r3,1
8110dbb8:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.eMode = sFeeStandBy;
8110dbbc:	d0a05317 	ldw	r2,-32436(gp)
8110dbc0:	00c000c4 	movi	r3,3
8110dbc4:	10c02c15 	stw	r3,176(r2)
				break;
8110dbc8:	0002d306 	br	8110e718 <vFeeTask+0x1110>


			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110dbcc:	d0a05317 	ldw	r2,-32436(gp)
8110dbd0:	10800003 	ldbu	r2,0(r2)
8110dbd4:	10803fcc 	andi	r2,r2,255
8110dbd8:	1085883a 	add	r2,r2,r2
8110dbdc:	1087883a 	add	r3,r2,r2
8110dbe0:	d0a06904 	addi	r2,gp,-32348
8110dbe4:	1885883a 	add	r2,r3,r2
8110dbe8:	10800017 	ldw	r2,0(r2)
8110dbec:	e0fffd04 	addi	r3,fp,-12
8110dbf0:	180d883a 	mov	r6,r3
8110dbf4:	000b883a 	mov	r5,zero
8110dbf8:	1009883a 	mov	r4,r2
8110dbfc:	113bc200 	call	8113bc20 <OSQPend>
8110dc00:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110dc04:	e0bffd03 	ldbu	r2,-12(fp)
8110dc08:	10803fcc 	andi	r2,r2,255
8110dc0c:	1000061e 	bne	r2,zero,8110dc28 <vFeeTask+0x620>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110dc10:	d0a05317 	ldw	r2,-32436(gp)
8110dc14:	e0fffe17 	ldw	r3,-8(fp)
8110dc18:	180b883a 	mov	r5,r3
8110dc1c:	1009883a 	mov	r4,r2
8110dc20:	110eac80 	call	8110eac8 <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110dc24:	0002bc06 	br	8110e718 <vFeeTask+0x1110>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110dc28:	d0e06117 	ldw	r3,-32380(gp)
8110dc2c:	d0a05317 	ldw	r2,-32436(gp)
8110dc30:	10800003 	ldbu	r2,0(r2)
8110dc34:	10803fcc 	andi	r2,r2,255
8110dc38:	100d883a 	mov	r6,r2
8110dc3c:	01604574 	movhi	r5,33045
8110dc40:	29699a04 	addi	r5,r5,-22936
8110dc44:	1809883a 	mov	r4,r3
8110dc48:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
				}

				break;
8110dc4c:	0002b206 	br	8110e718 <vFeeTask+0x1110>


			case sNextPatternIteration:


				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110dc50:	d0a05317 	ldw	r2,-32436(gp)
8110dc54:	10800003 	ldbu	r2,0(r2)
8110dc58:	10803fcc 	andi	r2,r2,255
8110dc5c:	1085883a 	add	r2,r2,r2
8110dc60:	1087883a 	add	r3,r2,r2
8110dc64:	d0a05b04 	addi	r2,gp,-32404
8110dc68:	1885883a 	add	r2,r3,r2
8110dc6c:	10800017 	ldw	r2,0(r2)
8110dc70:	1009883a 	mov	r4,r2
8110dc74:	113bb600 	call	8113bb60 <OSQFlush>
8110dc78:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110dc7c:	e0bffd03 	ldbu	r2,-12(fp)
8110dc80:	10803fcc 	andi	r2,r2,255
8110dc84:	10000126 	beq	r2,zero,8110dc8c <vFeeTask+0x684>
					vFailFlushNFEEQueue();
8110dc88:	111b86c0 	call	8111b86c <vFailFlushNFEEQueue>
				}

				pxNFee->xControl.bUsingDMA = TRUE;
8110dc8c:	d0a05317 	ldw	r2,-32436(gp)
8110dc90:	00c00044 	movi	r3,1
8110dc94:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110dc98:	d0a05317 	ldw	r2,-32436(gp)
8110dc9c:	00c00044 	movi	r3,1
8110dca0:	10c02715 	stw	r3,156(r2)

				vResetMemCCDFEE(pxNFee);
8110dca4:	d0a05317 	ldw	r2,-32436(gp)
8110dca8:	1009883a 	mov	r4,r2
8110dcac:	111be380 	call	8111be38 <vResetMemCCDFEE>

				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,0);
8110dcb0:	000b883a 	mov	r5,zero
8110dcb4:	01000404 	movi	r4,16
8110dcb8:	110588c0 	call	8110588c <bFeebCh1SetBufferSize>
				bFeebCh1SetBufferSize(SDMA_MAX_BLOCKS,1);
8110dcbc:	01400044 	movi	r5,1
8110dcc0:	01000404 	movi	r4,16
8110dcc4:	110588c0 	call	8110588c <bFeebCh1SetBufferSize>

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110dcc8:	d0a05317 	ldw	r2,-32436(gp)
8110dccc:	10803b04 	addi	r2,r2,236
8110dcd0:	1009883a 	mov	r4,r2
8110dcd4:	110f9d00 	call	8110f9d0 <bEnableDbBuffer>


				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110dcd8:	d0a05317 	ldw	r2,-32436(gp)
8110dcdc:	10808904 	addi	r2,r2,548
8110dce0:	1009883a 	mov	r4,r2
8110dce4:	110a0500 	call	8110a050 <bSpwcGetTimecode>
				tCodFeeTask = pxNFee->xChannel.xSpacewire.xTimecode.ucCounter;
8110dce8:	d0a05317 	ldw	r2,-32436(gp)
8110dcec:	10809543 	ldbu	r2,597(r2)
8110dcf0:	10803fcc 	andi	r2,r2,255
8110dcf4:	d0a05415 	stw	r2,-32432(gp)
				tCodeNext = ( tCodFeeTask + 1) % 4;
8110dcf8:	d0a05417 	ldw	r2,-32432(gp)
8110dcfc:	10800044 	addi	r2,r2,1
8110dd00:	108000cc 	andi	r2,r2,3
8110dd04:	e0bffc15 	stw	r2,-16(fp)
				if ( tCodeNext == 0 ) {
8110dd08:	e0bffc17 	ldw	r2,-16(fp)
8110dd0c:	10000f1e 	bne	r2,zero,8110dd4c <vFeeTask+0x744>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110dd10:	d0a05317 	ldw	r2,-32436(gp)
8110dd14:	10802917 	ldw	r2,164(r2)
8110dd18:	10800003 	ldbu	r2,0(r2)
8110dd1c:	10803fcc 	andi	r2,r2,255
8110dd20:	10c00044 	addi	r3,r2,1
8110dd24:	00a00034 	movhi	r2,32768
8110dd28:	10800044 	addi	r2,r2,1
8110dd2c:	1884703a 	and	r2,r3,r2
8110dd30:	1000040e 	bge	r2,zero,8110dd44 <vFeeTask+0x73c>
8110dd34:	10bfffc4 	addi	r2,r2,-1
8110dd38:	00ffff84 	movi	r3,-2
8110dd3c:	10c4b03a 	or	r2,r2,r3
8110dd40:	10800044 	addi	r2,r2,1
8110dd44:	e0bff405 	stb	r2,-48(fp)
8110dd48:	00000406 	br	8110dd5c <vFeeTask+0x754>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110dd4c:	d0a05317 	ldw	r2,-32436(gp)
8110dd50:	10802917 	ldw	r2,164(r2)
8110dd54:	10800003 	ldbu	r2,0(r2)
8110dd58:	e0bff405 	stb	r2,-48(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110dd5c:	d0e05317 	ldw	r3,-32436(gp)
8110dd60:	e0bffc17 	ldw	r2,-16(fp)
8110dd64:	1885883a 	add	r2,r3,r2
8110dd68:	10802a44 	addi	r2,r2,169
8110dd6c:	10800003 	ldbu	r2,0(r2)
8110dd70:	e0bff605 	stb	r2,-40(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110dd74:	d0a05317 	ldw	r2,-32436(gp)
8110dd78:	10802e17 	ldw	r2,184(r2)
8110dd7c:	1000071e 	bne	r2,zero,8110dd9c <vFeeTask+0x794>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110dd80:	d0e05317 	ldw	r3,-32436(gp)
8110dd84:	e0bff603 	ldbu	r2,-40(fp)
8110dd88:	10800624 	muli	r2,r2,24
8110dd8c:	10800904 	addi	r2,r2,36
8110dd90:	1885883a 	add	r2,r3,r2
8110dd94:	e0bff515 	stw	r2,-44(fp)
8110dd98:	00000606 	br	8110ddb4 <vFeeTask+0x7ac>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110dd9c:	d0e05317 	ldw	r3,-32436(gp)
8110dda0:	e0bff603 	ldbu	r2,-40(fp)
8110dda4:	10800624 	muli	r2,r2,24
8110dda8:	10800c04 	addi	r2,r2,48
8110ddac:	1885883a 	add	r2,r3,r2
8110ddb0:	e0bff515 	stw	r2,-44(fp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110ddb4:	d0a05317 	ldw	r2,-32436(gp)
8110ddb8:	10803304 	addi	r2,r2,204
8110ddbc:	1009883a 	mov	r4,r2
8110ddc0:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110ddc4:	d0a05317 	ldw	r2,-32436(gp)
8110ddc8:	e0fff603 	ldbu	r3,-40(fp)
8110ddcc:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110ddd0:	d0a05317 	ldw	r2,-32436(gp)
8110ddd4:	00c00044 	movi	r3,1
8110ddd8:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110dddc:	d0a05317 	ldw	r2,-32436(gp)
8110dde0:	10803304 	addi	r2,r2,204
8110dde4:	1009883a 	mov	r4,r2
8110dde8:	11048180 	call	81104818 <bDpktSetPacketConfig>


				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110ddec:	d0a05317 	ldw	r2,-32436(gp)
8110ddf0:	10800003 	ldbu	r2,0(r2)
8110ddf4:	10803fcc 	andi	r2,r2,255
8110ddf8:	100d883a 	mov	r6,r2
8110ddfc:	000b883a 	mov	r5,zero
8110de00:	01002004 	movi	r4,128
8110de04:	110fabc0 	call	8110fabc <bSendRequestNFeeCtrl>
				bDmaReturn = FALSE;
8110de08:	e03ff715 	stw	zero,-36(fp)
				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110de0c:	d0a05317 	ldw	r2,-32436(gp)
8110de10:	10800003 	ldbu	r2,0(r2)
8110de14:	10803fcc 	andi	r2,r2,255
8110de18:	1085883a 	add	r2,r2,r2
8110de1c:	1087883a 	add	r3,r2,r2
8110de20:	d0a06904 	addi	r2,gp,-32348
8110de24:	1885883a 	add	r2,r3,r2
8110de28:	10800017 	ldw	r2,0(r2)
8110de2c:	e0fffd04 	addi	r3,fp,-12
8110de30:	180d883a 	mov	r6,r3
8110de34:	000b883a 	mov	r5,zero
8110de38:	1009883a 	mov	r4,r2
8110de3c:	113bc200 	call	8113bc20 <OSQPend>
8110de40:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110de44:	e0bffd03 	ldbu	r2,-12(fp)
8110de48:	10803fcc 	andi	r2,r2,255
8110de4c:	1000cd1e 	bne	r2,zero,8110e184 <vFeeTask+0xb7c>

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110de50:	e0bffe83 	ldbu	r2,-6(fp)
8110de54:	10803fcc 	andi	r2,r2,255
8110de58:	108023d8 	cmpnei	r2,r2,143
8110de5c:	1000c31e 	bne	r2,zero,8110e16c <vFeeTask+0xb64>

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110de60:	e0fff403 	ldbu	r3,-48(fp)
8110de64:	00a045b4 	movhi	r2,33046
8110de68:	10850004 	addi	r2,r2,5120
8110de6c:	180690fa 	slli	r3,r3,3
8110de70:	10c5883a 	add	r2,r2,r3
8110de74:	10800017 	ldw	r2,0(r2)
8110de78:	e0fffd04 	addi	r3,fp,-12
8110de7c:	180d883a 	mov	r6,r3
8110de80:	000b883a 	mov	r5,zero
8110de84:	1009883a 	mov	r4,r2
8110de88:	113ab0c0 	call	8113ab0c <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110de8c:	e0bffd03 	ldbu	r2,-12(fp)
8110de90:	10803fcc 	andi	r2,r2,255
8110de94:	10021d1e 	bne	r2,zero,8110e70c <vFeeTask+0x1104>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110de98:	d0a05317 	ldw	r2,-32436(gp)
8110de9c:	00c00044 	movi	r3,1
8110dea0:	10c02215 	stw	r3,136(r2)

							if (  ucMemUsing == 0  ) {
8110dea4:	e0bff403 	ldbu	r2,-48(fp)
8110dea8:	1000471e 	bne	r2,zero,8110dfc8 <vFeeTask+0x9c0>
								/* Initializing the addr */
								xCcdMapLocal->ulBlockI = 0;
8110deac:	e0bff517 	ldw	r2,-44(fp)
8110deb0:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110deb4:	e0bff517 	ldw	r2,-44(fp)
8110deb8:	10c00017 	ldw	r3,0(r2)
8110debc:	e0bff517 	ldw	r2,-44(fp)
8110dec0:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110dec4:	e0bff517 	ldw	r2,-44(fp)
8110dec8:	10800217 	ldw	r2,8(r2)
8110decc:	1009883a 	mov	r4,r2
8110ded0:	d0a05317 	ldw	r2,-32436(gp)
8110ded4:	10802e17 	ldw	r2,184(r2)
8110ded8:	10c03fcc 	andi	r3,r2,255
8110dedc:	d0a05317 	ldw	r2,-32436(gp)
8110dee0:	10800003 	ldbu	r2,0(r2)
8110dee4:	10803fcc 	andi	r2,r2,255
8110dee8:	100f883a 	mov	r7,r2
8110deec:	180d883a 	mov	r6,r3
8110def0:	01400404 	movi	r5,16
8110def4:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110def8:	e0bff715 	stw	r2,-36(fp)
								if ( bDmaReturn == TRUE ) {
8110defc:	e0bff717 	ldw	r2,-36(fp)
8110df00:	10800058 	cmpnei	r2,r2,1
8110df04:	1000251e 	bne	r2,zero,8110df9c <vFeeTask+0x994>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110df08:	e0bff517 	ldw	r2,-44(fp)
8110df0c:	10800217 	ldw	r2,8(r2)
8110df10:	10c22004 	addi	r3,r2,2176
8110df14:	e0bff517 	ldw	r2,-44(fp)
8110df18:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110df1c:	e0bff517 	ldw	r2,-44(fp)
8110df20:	10800117 	ldw	r2,4(r2)
8110df24:	10c00404 	addi	r3,r2,16
8110df28:	e0bff517 	ldw	r2,-44(fp)
8110df2c:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110df30:	e0bff517 	ldw	r2,-44(fp)
8110df34:	10800217 	ldw	r2,8(r2)
8110df38:	1009883a 	mov	r4,r2
8110df3c:	d0a05317 	ldw	r2,-32436(gp)
8110df40:	10802e17 	ldw	r2,184(r2)
8110df44:	10c03fcc 	andi	r3,r2,255
8110df48:	d0a05317 	ldw	r2,-32436(gp)
8110df4c:	10800003 	ldbu	r2,0(r2)
8110df50:	10803fcc 	andi	r2,r2,255
8110df54:	100f883a 	mov	r7,r2
8110df58:	180d883a 	mov	r6,r3
8110df5c:	01400404 	movi	r5,16
8110df60:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110df64:	e0bff715 	stw	r2,-36(fp)
									if ( bDmaReturn == TRUE ) {
8110df68:	e0bff717 	ldw	r2,-36(fp)
8110df6c:	10800058 	cmpnei	r2,r2,1
8110df70:	10000a1e 	bne	r2,zero,8110df9c <vFeeTask+0x994>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110df74:	e0bff517 	ldw	r2,-44(fp)
8110df78:	10800217 	ldw	r2,8(r2)
8110df7c:	10c22004 	addi	r3,r2,2176
8110df80:	e0bff517 	ldw	r2,-44(fp)
8110df84:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110df88:	e0bff517 	ldw	r2,-44(fp)
8110df8c:	10800117 	ldw	r2,4(r2)
8110df90:	10c00404 	addi	r3,r2,16
8110df94:	e0bff517 	ldw	r2,-44(fp)
8110df98:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110df9c:	e0fff403 	ldbu	r3,-48(fp)
8110dfa0:	00a045b4 	movhi	r2,33046
8110dfa4:	10850004 	addi	r2,r2,5120
8110dfa8:	180690fa 	slli	r3,r3,3
8110dfac:	10c5883a 	add	r2,r2,r3
8110dfb0:	10800017 	ldw	r2,0(r2)
8110dfb4:	1009883a 	mov	r4,r2
8110dfb8:	113b0b00 	call	8113b0b0 <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110dfbc:	d0a05317 	ldw	r2,-32436(gp)
8110dfc0:	10002215 	stw	zero,136(r2)
8110dfc4:	00004606 	br	8110e0e0 <vFeeTask+0xad8>
							} else {
								xCcdMapLocal->ulBlockI = 0;
8110dfc8:	e0bff517 	ldw	r2,-44(fp)
8110dfcc:	10000115 	stw	zero,4(r2)
								xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110dfd0:	e0bff517 	ldw	r2,-44(fp)
8110dfd4:	10c00017 	ldw	r3,0(r2)
8110dfd8:	e0bff517 	ldw	r2,-44(fp)
8110dfdc:	10c00215 	stw	r3,8(r2)
								bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110dfe0:	e0bff517 	ldw	r2,-44(fp)
8110dfe4:	10800217 	ldw	r2,8(r2)
8110dfe8:	1009883a 	mov	r4,r2
8110dfec:	d0a05317 	ldw	r2,-32436(gp)
8110dff0:	10802e17 	ldw	r2,184(r2)
8110dff4:	10c03fcc 	andi	r3,r2,255
8110dff8:	d0a05317 	ldw	r2,-32436(gp)
8110dffc:	10800003 	ldbu	r2,0(r2)
8110e000:	10803fcc 	andi	r2,r2,255
8110e004:	100f883a 	mov	r7,r2
8110e008:	180d883a 	mov	r6,r3
8110e00c:	01400404 	movi	r5,16
8110e010:	11041180 	call	81104118 <bSdmaDmaM2Transfer>
8110e014:	e0bff715 	stw	r2,-36(fp)
								if ( bDmaReturn == TRUE ) {
8110e018:	e0bff717 	ldw	r2,-36(fp)
8110e01c:	10800058 	cmpnei	r2,r2,1
8110e020:	1000251e 	bne	r2,zero,8110e0b8 <vFeeTask+0xab0>
									//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e024:	e0bff517 	ldw	r2,-44(fp)
8110e028:	10800217 	ldw	r2,8(r2)
8110e02c:	10c22004 	addi	r3,r2,2176
8110e030:	e0bff517 	ldw	r2,-44(fp)
8110e034:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e038:	e0bff517 	ldw	r2,-44(fp)
8110e03c:	10800117 	ldw	r2,4(r2)
8110e040:	10c00404 	addi	r3,r2,16
8110e044:	e0bff517 	ldw	r2,-44(fp)
8110e048:	10c00115 	stw	r3,4(r2)
									bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110e04c:	e0bff517 	ldw	r2,-44(fp)
8110e050:	10800217 	ldw	r2,8(r2)
8110e054:	1009883a 	mov	r4,r2
8110e058:	d0a05317 	ldw	r2,-32436(gp)
8110e05c:	10802e17 	ldw	r2,184(r2)
8110e060:	10c03fcc 	andi	r3,r2,255
8110e064:	d0a05317 	ldw	r2,-32436(gp)
8110e068:	10800003 	ldbu	r2,0(r2)
8110e06c:	10803fcc 	andi	r2,r2,255
8110e070:	100f883a 	mov	r7,r2
8110e074:	180d883a 	mov	r6,r3
8110e078:	01400404 	movi	r5,16
8110e07c:	11041180 	call	81104118 <bSdmaDmaM2Transfer>
8110e080:	e0bff715 	stw	r2,-36(fp)
									if ( bDmaReturn == TRUE ) {
8110e084:	e0bff717 	ldw	r2,-36(fp)
8110e088:	10800058 	cmpnei	r2,r2,1
8110e08c:	10000a1e 	bne	r2,zero,8110e0b8 <vFeeTask+0xab0>
										//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
										xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e090:	e0bff517 	ldw	r2,-44(fp)
8110e094:	10800217 	ldw	r2,8(r2)
8110e098:	10c22004 	addi	r3,r2,2176
8110e09c:	e0bff517 	ldw	r2,-44(fp)
8110e0a0:	10c00215 	stw	r3,8(r2)
										xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e0a4:	e0bff517 	ldw	r2,-44(fp)
8110e0a8:	10800117 	ldw	r2,4(r2)
8110e0ac:	10c00404 	addi	r3,r2,16
8110e0b0:	e0bff517 	ldw	r2,-44(fp)
8110e0b4:	10c00115 	stw	r3,4(r2)

									}
								}
								OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e0b8:	e0fff403 	ldbu	r3,-48(fp)
8110e0bc:	00a045b4 	movhi	r2,33046
8110e0c0:	10850004 	addi	r2,r2,5120
8110e0c4:	180690fa 	slli	r3,r3,3
8110e0c8:	10c5883a 	add	r2,r2,r3
8110e0cc:	10800017 	ldw	r2,0(r2)
8110e0d0:	1009883a 	mov	r4,r2
8110e0d4:	113b0b00 	call	8113b0b0 <OSMutexPost>
								pxNFee->xControl.bDMALocked = FALSE;
8110e0d8:	d0a05317 	ldw	r2,-32436(gp)
8110e0dc:	10002215 	stw	zero,136(r2)
							}
	                        /* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);							
8110e0e0:	d0a05317 	ldw	r2,-32436(gp)
8110e0e4:	10800003 	ldbu	r2,0(r2)
8110e0e8:	10803fcc 	andi	r2,r2,255
8110e0ec:	100d883a 	mov	r6,r2
8110e0f0:	000b883a 	mov	r5,zero
8110e0f4:	01002044 	movi	r4,129
8110e0f8:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>

							if ( bDmaReturn == TRUE ) {
8110e0fc:	e0bff717 	ldw	r2,-36(fp)
8110e100:	10800058 	cmpnei	r2,r2,1
8110e104:	1000111e 	bne	r2,zero,8110e14c <vFeeTask+0xb44>
								if (pxNFee->xControl.bWatingSync==TRUE) {
8110e108:	d0a05317 	ldw	r2,-32436(gp)
8110e10c:	10802817 	ldw	r2,160(r2)
8110e110:	10800058 	cmpnei	r2,r2,1
8110e114:	1000071e 	bne	r2,zero,8110e134 <vFeeTask+0xb2c>
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110e118:	d0a05317 	ldw	r2,-32436(gp)
8110e11c:	00c001c4 	movi	r3,7
8110e120:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sFeeWaitingSync;
8110e124:	d0a05317 	ldw	r2,-32436(gp)
8110e128:	00c00304 	movi	r3,12
8110e12c:	10c02c15 	stw	r3,176(r2)
8110e130:	00000606 	br	8110e14c <vFeeTask+0xb44>
								} else {
									pxNFee->xControl.eNextMode = sToTestFullPattern;
8110e134:	d0a05317 	ldw	r2,-32436(gp)
8110e138:	00c001c4 	movi	r3,7
8110e13c:	10c02d15 	stw	r3,180(r2)
									pxNFee->xControl.eMode = sToTestFullPattern;
8110e140:	d0a05317 	ldw	r2,-32436(gp)
8110e144:	00c001c4 	movi	r3,7
8110e148:	10c02c15 	stw	r3,176(r2)
								}
							}


							#ifdef DEBUG_ON
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
8110e14c:	d0a06117 	ldw	r2,-32380(gp)
8110e150:	100f883a 	mov	r7,r2
8110e154:	01800904 	movi	r6,36
8110e158:	01400044 	movi	r5,1
8110e15c:	01204574 	movhi	r4,33045
8110e160:	2129ae04 	addi	r4,r4,-22856
8110e164:	111fc980 	call	8111fc98 <fwrite>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e168:	00016806 	br	8110e70c <vFeeTask+0x1104>
								fprintf(fp,"\nFEE TASK:  Double buffer prepared\n ");
							#endif							
	                    }
					} else {

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110e16c:	d0a05317 	ldw	r2,-32436(gp)
8110e170:	e0fffe17 	ldw	r3,-8(fp)
8110e174:	180b883a 	mov	r5,r3
8110e178:	1009883a 	mov	r4,r2
8110e17c:	110ecc40 	call	8110ecc4 <vQCmdFEEinFullPattern>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e180:	00016206 	br	8110e70c <vFeeTask+0x1104>

						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e184:	d0e06117 	ldw	r3,-32380(gp)
8110e188:	d0a05317 	ldw	r2,-32436(gp)
8110e18c:	10800003 	ldbu	r2,0(r2)
8110e190:	10803fcc 	andi	r2,r2,255
8110e194:	100d883a 	mov	r6,r2
8110e198:	01604574 	movhi	r5,33045
8110e19c:	29699a04 	addi	r5,r5,-22936
8110e1a0:	1809883a 	mov	r4,r3
8110e1a4:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
				}

				break;
8110e1a8:	00015806 	br	8110e70c <vFeeTask+0x1104>


			case sToTestFullPattern: /* Transition */
				bFinal = FALSE;
8110e1ac:	e03ff815 	stw	zero,-32(fp)

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e1b0:	d0a05317 	ldw	r2,-32436(gp)
8110e1b4:	10804304 	addi	r2,r2,268
8110e1b8:	1009883a 	mov	r4,r2
8110e1bc:	11080440 	call	81108044 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110e1c0:	d0a05317 	ldw	r2,-32436(gp)
8110e1c4:	00c00084 	movi	r3,2
8110e1c8:	10c06615 	stw	r3,408(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110e1cc:	d0a05317 	ldw	r2,-32436(gp)
8110e1d0:	10804304 	addi	r2,r2,268
8110e1d4:	1009883a 	mov	r4,r2
8110e1d8:	1107d580 	call	81107d58 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110e1dc:	d0e06117 	ldw	r3,-32380(gp)
8110e1e0:	d0a05317 	ldw	r2,-32436(gp)
8110e1e4:	10800003 	ldbu	r2,0(r2)
8110e1e8:	10803fcc 	andi	r2,r2,255
8110e1ec:	100d883a 	mov	r6,r2
8110e1f0:	01604574 	movhi	r5,33045
8110e1f4:	2969b804 	addi	r5,r5,-22816
8110e1f8:	1809883a 	mov	r4,r3
8110e1fc:	111f5fc0 	call	8111f5fc <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110e200:	d0a05317 	ldw	r2,-32436(gp)
8110e204:	00c00044 	movi	r3,1
8110e208:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110e20c:	d0a05317 	ldw	r2,-32436(gp)
8110e210:	00c00104 	movi	r3,4
8110e214:	10c02c15 	stw	r3,176(r2)
				pxNFee->xControl.eNextMode = sFeeTestFullPattern;
8110e218:	d0a05317 	ldw	r2,-32436(gp)
8110e21c:	00c00104 	movi	r3,4
8110e220:	10c02d15 	stw	r3,180(r2)
				pxNFee->xControl.bWatingSync = TRUE;
8110e224:	d0a05317 	ldw	r2,-32436(gp)
8110e228:	00c00044 	movi	r3,1
8110e22c:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110e230:	d0a05317 	ldw	r2,-32436(gp)
8110e234:	00c00044 	movi	r3,1
8110e238:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110e23c:	d0a05317 	ldw	r2,-32436(gp)
8110e240:	00c00044 	movi	r3,1
8110e244:	10c02115 	stw	r3,132(r2)
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110e248:	d0a05317 	ldw	r2,-32436(gp)
8110e24c:	10800003 	ldbu	r2,0(r2)
8110e250:	10803fcc 	andi	r2,r2,255
8110e254:	100d883a 	mov	r6,r2
8110e258:	000b883a 	mov	r5,zero
8110e25c:	01002004 	movi	r4,128
8110e260:	110fabc0 	call	8110fabc <bSendRequestNFeeCtrl>

				break;
8110e264:	00012c06 	br	8110e718 <vFeeTask+0x1110>


			case sFeeTestFullPattern: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e268:	d0a05317 	ldw	r2,-32436(gp)
8110e26c:	10800003 	ldbu	r2,0(r2)
8110e270:	10803fcc 	andi	r2,r2,255
8110e274:	1085883a 	add	r2,r2,r2
8110e278:	1087883a 	add	r3,r2,r2
8110e27c:	d0a06904 	addi	r2,gp,-32348
8110e280:	1885883a 	add	r2,r3,r2
8110e284:	10800017 	ldw	r2,0(r2)
8110e288:	e0fffd04 	addi	r3,fp,-12
8110e28c:	180d883a 	mov	r6,r3
8110e290:	000b883a 	mov	r5,zero
8110e294:	1009883a 	mov	r4,r2
8110e298:	113bc200 	call	8113bc20 <OSQPend>
8110e29c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110e2a0:	e0bffd03 	ldbu	r2,-12(fp)
8110e2a4:	10803fcc 	andi	r2,r2,255
8110e2a8:	1000c01e 	bne	r2,zero,8110e5ac <vFeeTask+0xfa4>

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110e2ac:	e0bffe83 	ldbu	r2,-6(fp)
8110e2b0:	10803fcc 	andi	r2,r2,255
8110e2b4:	108023d8 	cmpnei	r2,r2,143
8110e2b8:	1000af1e 	bne	r2,zero,8110e578 <vFeeTask+0xf70>

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110e2bc:	e0fff403 	ldbu	r3,-48(fp)
8110e2c0:	00a045b4 	movhi	r2,33046
8110e2c4:	10850004 	addi	r2,r2,5120
8110e2c8:	180690fa 	slli	r3,r3,3
8110e2cc:	10c5883a 	add	r2,r2,r3
8110e2d0:	10800017 	ldw	r2,0(r2)
8110e2d4:	e0fffd04 	addi	r3,fp,-12
8110e2d8:	180d883a 	mov	r6,r3
8110e2dc:	000b883a 	mov	r5,zero
8110e2e0:	1009883a 	mov	r4,r2
8110e2e4:	113ab0c0 	call	8113ab0c <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110e2e8:	e0bffd03 	ldbu	r2,-12(fp)
8110e2ec:	10803fcc 	andi	r2,r2,255
8110e2f0:	1001081e 	bne	r2,zero,8110e714 <vFeeTask+0x110c>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110e2f4:	d0a05317 	ldw	r2,-32436(gp)
8110e2f8:	00c00044 	movi	r3,1
8110e2fc:	10c02215 	stw	r3,136(r2)

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI + SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110e300:	e0bff517 	ldw	r2,-44(fp)
8110e304:	10800117 	ldw	r2,4(r2)
8110e308:	10c00404 	addi	r3,r2,16
8110e30c:	d0a05317 	ldw	r2,-32436(gp)
8110e310:	10800417 	ldw	r2,16(r2)
8110e314:	18803a36 	bltu	r3,r2,8110e400 <vFeeTask+0xdf8>

									#ifdef DEBUG_ON
										//fprintf(fp,"\n    i: %u ",incrementador);
										fprintf(fp,"\nEnd of transmission NFEE-%hhu -> CCD %hhu  -> Time Code Ref. used -> %hu  \n", pxNFee->ucId, ucReadout, tCodFeeTask);
8110e318:	d0e06117 	ldw	r3,-32380(gp)
8110e31c:	d0a05317 	ldw	r2,-32436(gp)
8110e320:	10800003 	ldbu	r2,0(r2)
8110e324:	11003fcc 	andi	r4,r2,255
8110e328:	e17ff603 	ldbu	r5,-40(fp)
8110e32c:	d0a05417 	ldw	r2,-32432(gp)
8110e330:	d8800015 	stw	r2,0(sp)
8110e334:	280f883a 	mov	r7,r5
8110e338:	200d883a 	mov	r6,r4
8110e33c:	01604574 	movhi	r5,33045
8110e340:	2969c204 	addi	r5,r5,-22776
8110e344:	1809883a 	mov	r4,r3
8110e348:	111f5fc0 	call	8111f5fc <fprintf>
										fprintf(fp,"\nMemory used: %u ", ucMemUsing);
8110e34c:	d0a06117 	ldw	r2,-32380(gp)
8110e350:	e0fff403 	ldbu	r3,-48(fp)
8110e354:	180d883a 	mov	r6,r3
8110e358:	01604574 	movhi	r5,33045
8110e35c:	2969d604 	addi	r5,r5,-22696
8110e360:	1009883a 	mov	r4,r2
8110e364:	111f5fc0 	call	8111f5fc <fprintf>
										fprintf(fp,"\nTotal blocks transmited: %u ",xCcdMapLocal->ulBlockI);
8110e368:	d0e06117 	ldw	r3,-32380(gp)
8110e36c:	e0bff517 	ldw	r2,-44(fp)
8110e370:	10800117 	ldw	r2,4(r2)
8110e374:	100d883a 	mov	r6,r2
8110e378:	01604574 	movhi	r5,33045
8110e37c:	2969db04 	addi	r5,r5,-22676
8110e380:	1809883a 	mov	r4,r3
8110e384:	111f5fc0 	call	8111f5fc <fprintf>
									#endif

		                    		/*Define the size of the data in the double buffer (need this to create the interrupt riht)*/
		                    		bFeebCh1SetBufferSize( (pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI), 0 );
8110e388:	d0a05317 	ldw	r2,-32436(gp)
8110e38c:	10800417 	ldw	r2,16(r2)
8110e390:	1007883a 	mov	r3,r2
8110e394:	e0bff517 	ldw	r2,-44(fp)
8110e398:	10800117 	ldw	r2,4(r2)
8110e39c:	1885c83a 	sub	r2,r3,r2
8110e3a0:	10803fcc 	andi	r2,r2,255
8110e3a4:	000b883a 	mov	r5,zero
8110e3a8:	1009883a 	mov	r4,r2
8110e3ac:	110588c0 	call	8110588c <bFeebCh1SetBufferSize>
		                    		bFeebCh1SetBufferSize( (pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI), 1 );
8110e3b0:	d0a05317 	ldw	r2,-32436(gp)
8110e3b4:	10800417 	ldw	r2,16(r2)
8110e3b8:	1007883a 	mov	r3,r2
8110e3bc:	e0bff517 	ldw	r2,-44(fp)
8110e3c0:	10800117 	ldw	r2,4(r2)
8110e3c4:	1885c83a 	sub	r2,r3,r2
8110e3c8:	10803fcc 	andi	r2,r2,255
8110e3cc:	01400044 	movi	r5,1
8110e3d0:	1009883a 	mov	r4,r2
8110e3d4:	110588c0 	call	8110588c <bFeebCh1SetBufferSize>

		                    		usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110e3d8:	d0a05317 	ldw	r2,-32436(gp)
8110e3dc:	10800417 	ldw	r2,16(r2)
8110e3e0:	1007883a 	mov	r3,r2
8110e3e4:	e0bff517 	ldw	r2,-44(fp)
8110e3e8:	10800117 	ldw	r2,4(r2)
8110e3ec:	1885c83a 	sub	r2,r3,r2
8110e3f0:	e0bff68d 	sth	r2,-38(fp)
		                    		bFinal = TRUE;
8110e3f4:	00800044 	movi	r2,1
8110e3f8:	e0bff815 	stw	r2,-32(fp)
8110e3fc:	00000306 	br	8110e40c <vFeeTask+0xe04>

		                    	} else {

		                    		bFinal = FALSE;
8110e400:	e03ff815 	stw	zero,-32(fp)
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110e404:	00800404 	movi	r2,16
8110e408:	e0bff68d 	sth	r2,-38(fp)
		                    	}

		                    	if ( ucMemUsing == 0  ) {
8110e40c:	e0bff403 	ldbu	r2,-48(fp)
8110e410:	1000111e 	bne	r2,zero,8110e458 <vFeeTask+0xe50>
		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, pxNFee->xControl.eSide, pxNFee->ucId);
8110e414:	e0bff517 	ldw	r2,-44(fp)
8110e418:	10800217 	ldw	r2,8(r2)
8110e41c:	1011883a 	mov	r8,r2
8110e420:	e0fff68b 	ldhu	r3,-38(fp)
8110e424:	d0a05317 	ldw	r2,-32436(gp)
8110e428:	10802e17 	ldw	r2,184(r2)
8110e42c:	11003fcc 	andi	r4,r2,255
8110e430:	d0a05317 	ldw	r2,-32436(gp)
8110e434:	10800003 	ldbu	r2,0(r2)
8110e438:	10803fcc 	andi	r2,r2,255
8110e43c:	100f883a 	mov	r7,r2
8110e440:	200d883a 	mov	r6,r4
8110e444:	180b883a 	mov	r5,r3
8110e448:	4009883a 	mov	r4,r8
8110e44c:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110e450:	e0bff715 	stw	r2,-36(fp)
8110e454:	00001006 	br	8110e498 <vFeeTask+0xe90>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bDmaReturn = bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI, usiLengthBlocks, pxNFee->xControl.eSide, pxNFee->ucId);
8110e458:	e0bff517 	ldw	r2,-44(fp)
8110e45c:	10800217 	ldw	r2,8(r2)
8110e460:	1011883a 	mov	r8,r2
8110e464:	e0fff68b 	ldhu	r3,-38(fp)
8110e468:	d0a05317 	ldw	r2,-32436(gp)
8110e46c:	10802e17 	ldw	r2,184(r2)
8110e470:	11003fcc 	andi	r4,r2,255
8110e474:	d0a05317 	ldw	r2,-32436(gp)
8110e478:	10800003 	ldbu	r2,0(r2)
8110e47c:	10803fcc 	andi	r2,r2,255
8110e480:	100f883a 	mov	r7,r2
8110e484:	200d883a 	mov	r6,r4
8110e488:	180b883a 	mov	r5,r3
8110e48c:	4009883a 	mov	r4,r8
8110e490:	11041180 	call	81104118 <bSdmaDmaM2Transfer>
8110e494:	e0bff715 	stw	r2,-36(fp)
		                    	}


		                    	if ( bDmaReturn = TRUE ) {
8110e498:	00800044 	movi	r2,1
8110e49c:	e0bff715 	stw	r2,-36(fp)
									/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */
									xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110e4a0:	e0bff517 	ldw	r2,-44(fp)
8110e4a4:	10800217 	ldw	r2,8(r2)
8110e4a8:	10c22004 	addi	r3,r2,2176
8110e4ac:	e0bff517 	ldw	r2,-44(fp)
8110e4b0:	10c00215 	stw	r3,8(r2)
									xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110e4b4:	e0bff517 	ldw	r2,-44(fp)
8110e4b8:	10800117 	ldw	r2,4(r2)
8110e4bc:	10c00404 	addi	r3,r2,16
8110e4c0:	e0bff517 	ldw	r2,-44(fp)
8110e4c4:	10c00115 	stw	r3,4(r2)
										fprintf(fp,"\n--\n ");
									#endif
									bFinal = FALSE;
		                    	}

		                    	OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110e4c8:	e0fff403 	ldbu	r3,-48(fp)
8110e4cc:	00a045b4 	movhi	r2,33046
8110e4d0:	10850004 	addi	r2,r2,5120
8110e4d4:	180690fa 	slli	r3,r3,3
8110e4d8:	10c5883a 	add	r2,r2,r3
8110e4dc:	10800017 	ldw	r2,0(r2)
8110e4e0:	1009883a 	mov	r4,r2
8110e4e4:	113b0b00 	call	8113b0b0 <OSMutexPost>
		                    	pxNFee->xControl.bDMALocked = FALSE;
8110e4e8:	d0a05317 	ldw	r2,-32436(gp)
8110e4ec:	10002215 	stw	zero,136(r2)
		                        /* Send message telling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110e4f0:	d0a05317 	ldw	r2,-32436(gp)
8110e4f4:	10800003 	ldbu	r2,0(r2)
8110e4f8:	10803fcc 	andi	r2,r2,255
8110e4fc:	100d883a 	mov	r6,r2
8110e500:	000b883a 	mov	r5,zero
8110e504:	01002044 	movi	r4,129
8110e508:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>

								/* Just to see the progress */
								if ( ((xCcdMapLocal->ulBlockI) % 4096 == 0) ) {
8110e50c:	e0bff517 	ldw	r2,-44(fp)
8110e510:	10800117 	ldw	r2,4(r2)
8110e514:	1083ffcc 	andi	r2,r2,4095
8110e518:	1000081e 	bne	r2,zero,8110e53c <vFeeTask+0xf34>

									#ifdef DEBUG_ON
										fprintf(fp,"\nblock: %u ", xCcdMapLocal->ulBlockI);
8110e51c:	d0e06117 	ldw	r3,-32380(gp)
8110e520:	e0bff517 	ldw	r2,-44(fp)
8110e524:	10800117 	ldw	r2,4(r2)
8110e528:	100d883a 	mov	r6,r2
8110e52c:	01604574 	movhi	r5,33045
8110e530:	2969e304 	addi	r5,r5,-22644
8110e534:	1809883a 	mov	r4,r3
8110e538:	111f5fc0 	call	8111f5fc <fprintf>
									#endif
								}


								if ( bFinal == TRUE ) {
8110e53c:	e0bff817 	ldw	r2,-32(fp)
8110e540:	10800058 	cmpnei	r2,r2,1
8110e544:	1000041e 	bne	r2,zero,8110e558 <vFeeTask+0xf50>
									pxNFee->xControl.eMode = sEndTransmission;
8110e548:	d0a05317 	ldw	r2,-32436(gp)
8110e54c:	00c002c4 	movi	r3,11
8110e550:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e554:	00006f06 	br	8110e714 <vFeeTask+0x110c>


								if ( bFinal == TRUE ) {
									pxNFee->xControl.eMode = sEndTransmission;
								} else {
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
8110e558:	d0a05317 	ldw	r2,-32436(gp)
8110e55c:	10800003 	ldbu	r2,0(r2)
8110e560:	10803fcc 	andi	r2,r2,255
8110e564:	100d883a 	mov	r6,r2
8110e568:	000b883a 	mov	r5,zero
8110e56c:	01002004 	movi	r4,128
8110e570:	110fabc0 	call	8110fabc <bSendRequestNFeeCtrl>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e574:	00006706 	br	8110e714 <vFeeTask+0x110c>
									bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
								}

		                    }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110e578:	d0a05317 	ldw	r2,-32436(gp)
8110e57c:	e0fffe17 	ldw	r3,-8(fp)
8110e580:	180b883a 	mov	r5,r3
8110e584:	1009883a 	mov	r4,r2
8110e588:	110ecc40 	call	8110ecc4 <vQCmdFEEinFullPattern>

							if ( pxNFee->xControl.bWatingSync == FALSE ) {
8110e58c:	d0a05317 	ldw	r2,-32436(gp)
8110e590:	10802817 	ldw	r2,160(r2)
8110e594:	10005f1e 	bne	r2,zero,8110e714 <vFeeTask+0x110c>
								pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110e598:	d0a05317 	ldw	r2,-32436(gp)
8110e59c:	d0e05317 	ldw	r3,-32436(gp)
8110e5a0:	18c02d17 	ldw	r3,180(r3)
8110e5a4:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e5a8:	00005a06 	br	8110e714 <vFeeTask+0x110c>
							}
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110e5ac:	d0e06117 	ldw	r3,-32380(gp)
8110e5b0:	d0a05317 	ldw	r2,-32436(gp)
8110e5b4:	10800003 	ldbu	r2,0(r2)
8110e5b8:	10803fcc 	andi	r2,r2,255
8110e5bc:	100d883a 	mov	r6,r2
8110e5c0:	01604574 	movhi	r5,33045
8110e5c4:	29699a04 	addi	r5,r5,-22936
8110e5c8:	1809883a 	mov	r4,r3
8110e5cc:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
				}

				break;
8110e5d0:	00005006 	br	8110e714 <vFeeTask+0x110c>

			case sEndTransmission:

				pxNFee->xControl.bWatingSync = TRUE;
8110e5d4:	d0a05317 	ldw	r2,-32436(gp)
8110e5d8:	00c00044 	movi	r3,1
8110e5dc:	10c02815 	stw	r3,160(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110e5e0:	d0a05317 	ldw	r2,-32436(gp)
8110e5e4:	10002315 	stw	zero,140(r2)

				if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
8110e5e8:	d0a05317 	ldw	r2,-32436(gp)
8110e5ec:	10802d17 	ldw	r2,180(r2)
8110e5f0:	10800198 	cmpnei	r2,r2,6
8110e5f4:	1000071e 	bne	r2,zero,8110e614 <vFeeTask+0x100c>
					pxNFee->xControl.eMode =  sFeeWaitingSync;
8110e5f8:	d0a05317 	ldw	r2,-32436(gp)
8110e5fc:	00c00304 	movi	r3,12
8110e600:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
8110e604:	d0a05317 	ldw	r2,-32436(gp)
8110e608:	00c00184 	movi	r3,6
8110e60c:	10c02d15 	stw	r3,180(r2)
				} else {
					pxNFee->xControl.eMode =  sNextPatternIteration;
					pxNFee->xControl.eNextMode =  sFeeWaitingSync;
				}

				break;
8110e610:	00004106 	br	8110e718 <vFeeTask+0x1110>

				if ( pxNFee->xControl.eNextMode == sToFeeStandBy ) {
					pxNFee->xControl.eMode =  sFeeWaitingSync;
					pxNFee->xControl.eNextMode =  sToFeeStandBy;
				} else {
					pxNFee->xControl.eMode =  sNextPatternIteration;
8110e614:	d0a05317 	ldw	r2,-32436(gp)
8110e618:	00c00284 	movi	r3,10
8110e61c:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eNextMode =  sFeeWaitingSync;
8110e620:	d0a05317 	ldw	r2,-32436(gp)
8110e624:	00c00304 	movi	r3,12
8110e628:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110e62c:	00003a06 	br	8110e718 <vFeeTask+0x1110>

			case sFeeWaitingSync:

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: (sFeeWaitingSync)\n", pxNFee->ucId);
8110e630:	d0e06117 	ldw	r3,-32380(gp)
8110e634:	d0a05317 	ldw	r2,-32436(gp)
8110e638:	10800003 	ldbu	r2,0(r2)
8110e63c:	10803fcc 	andi	r2,r2,255
8110e640:	100d883a 	mov	r6,r2
8110e644:	01604574 	movhi	r5,33045
8110e648:	2969e604 	addi	r5,r5,-22632
8110e64c:	1809883a 	mov	r4,r3
8110e650:	111f5fc0 	call	8111f5fc <fprintf>
				#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110e654:	d0a05317 	ldw	r2,-32436(gp)
8110e658:	10800003 	ldbu	r2,0(r2)
8110e65c:	10803fcc 	andi	r2,r2,255
8110e660:	1085883a 	add	r2,r2,r2
8110e664:	1087883a 	add	r3,r2,r2
8110e668:	d0a06904 	addi	r2,gp,-32348
8110e66c:	1885883a 	add	r2,r3,r2
8110e670:	10800017 	ldw	r2,0(r2)
8110e674:	e0fffd04 	addi	r3,fp,-12
8110e678:	180d883a 	mov	r6,r3
8110e67c:	000b883a 	mov	r5,zero
8110e680:	1009883a 	mov	r4,r2
8110e684:	113bc200 	call	8113bc20 <OSQPend>
8110e688:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110e68c:	e0bffd03 	ldbu	r2,-12(fp)
8110e690:	10803fcc 	andi	r2,r2,255
8110e694:	10000a26 	beq	r2,zero,8110e6c0 <vFeeTask+0x10b8>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
8110e698:	d0e06117 	ldw	r3,-32380(gp)
8110e69c:	d0a05317 	ldw	r2,-32436(gp)
8110e6a0:	10800003 	ldbu	r2,0(r2)
8110e6a4:	10803fcc 	andi	r2,r2,255
8110e6a8:	100d883a 	mov	r6,r2
8110e6ac:	01604574 	movhi	r5,33045
8110e6b0:	2969ef04 	addi	r5,r5,-22596
8110e6b4:	1809883a 	mov	r4,r3
8110e6b8:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
				}

				break;
8110e6bc:	00001606 	br	8110e718 <vFeeTask+0x1110>
				if ( error_code != OS_ERR_NONE ) {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ (sFeeWaitingSync)\n", pxNFee->ucId);
					#endif
				} else {
					vQCmdFEEinWaitingSync( pxNFee, uiCmdFEE.ulWord  );
8110e6c0:	d0a05317 	ldw	r2,-32436(gp)
8110e6c4:	e0fffe17 	ldw	r3,-8(fp)
8110e6c8:	180b883a 	mov	r5,r3
8110e6cc:	1009883a 	mov	r4,r2
8110e6d0:	110e71c0 	call	8110e71c <vQCmdFEEinWaitingSync>
				}

				break;
8110e6d4:	00001006 	br	8110e718 <vFeeTask+0x1110>


			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110e6d8:	d0a05317 	ldw	r2,-32436(gp)
8110e6dc:	00c00144 	movi	r3,5
8110e6e0:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110e6e4:	d0e06117 	ldw	r3,-32380(gp)
8110e6e8:	d0a05317 	ldw	r2,-32436(gp)
8110e6ec:	10800003 	ldbu	r2,0(r2)
8110e6f0:	10803fcc 	andi	r2,r2,255
8110e6f4:	100d883a 	mov	r6,r2
8110e6f8:	01604574 	movhi	r5,33045
8110e6fc:	296a0004 	addi	r5,r5,-22528
8110e700:	1809883a 	mov	r4,r3
8110e704:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110e708:	00000306 	br	8110e718 <vFeeTask+0x1110>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e70c:	0001883a 	nop
8110e710:	003bd306 	br	8110d660 <__reset+0xfb0ed660>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110e714:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110e718:	003bd106 	br	8110d660 <__reset+0xfb0ed660>

8110e71c <vQCmdFEEinWaitingSync>:

}

void vQCmdFEEinWaitingSync( TNFee *pxNFeeP, unsigned int cmd ) {
8110e71c:	defffb04 	addi	sp,sp,-20
8110e720:	de00012e 	bgeu	sp,et,8110e728 <vQCmdFEEinWaitingSync+0xc>
8110e724:	003b68fa 	trap	3
8110e728:	dfc00415 	stw	ra,16(sp)
8110e72c:	df000315 	stw	fp,12(sp)
8110e730:	df000304 	addi	fp,sp,12
8110e734:	e13ffe15 	stw	r4,-8(fp)
8110e738:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110e73c:	e0bfff17 	ldw	r2,-4(fp)
8110e740:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110e744:	e0bffdc3 	ldbu	r2,-9(fp)
8110e748:	10c03fcc 	andi	r3,r2,255
8110e74c:	e0bffe17 	ldw	r2,-8(fp)
8110e750:	10800003 	ldbu	r2,0(r2)
8110e754:	10803fcc 	andi	r2,r2,255
8110e758:	10800444 	addi	r2,r2,17
8110e75c:	1880631e 	bne	r3,r2,8110e8ec <vQCmdFEEinWaitingSync+0x1d0>

		switch (uiCmdFEEL.ucByte[2]) {
8110e760:	e0bffd83 	ldbu	r2,-10(fp)
8110e764:	10803fcc 	andi	r2,r2,255
8110e768:	10c02860 	cmpeqi	r3,r2,161
8110e76c:	18001a1e 	bne	r3,zero,8110e7d8 <vQCmdFEEinWaitingSync+0xbc>
8110e770:	10c02888 	cmpgei	r3,r2,162
8110e774:	18000c1e 	bne	r3,zero,8110e7a8 <vQCmdFEEinWaitingSync+0x8c>
8110e778:	10c00120 	cmpeqi	r3,r2,4
8110e77c:	18001f1e 	bne	r3,zero,8110e7fc <vQCmdFEEinWaitingSync+0xe0>
8110e780:	10c00148 	cmpgei	r3,r2,5
8110e784:	1800031e 	bne	r3,zero,8110e794 <vQCmdFEEinWaitingSync+0x78>
8110e788:	10800060 	cmpeqi	r2,r2,1
8110e78c:	1000121e 	bne	r2,zero,8110e7d8 <vQCmdFEEinWaitingSync+0xbc>
8110e790:	00004c06 	br	8110e8c4 <vQCmdFEEinWaitingSync+0x1a8>
8110e794:	10c00220 	cmpeqi	r3,r2,8
8110e798:	1800221e 	bne	r3,zero,8110e824 <vQCmdFEEinWaitingSync+0x108>
8110e79c:	108023e0 	cmpeqi	r2,r2,143
8110e7a0:	10003e1e 	bne	r2,zero,8110e89c <vQCmdFEEinWaitingSync+0x180>
8110e7a4:	00004706 	br	8110e8c4 <vQCmdFEEinWaitingSync+0x1a8>
8110e7a8:	10c03888 	cmpgei	r3,r2,226
8110e7ac:	1800071e 	bne	r3,zero,8110e7cc <vQCmdFEEinWaitingSync+0xb0>
8110e7b0:	10c03808 	cmpgei	r3,r2,224
8110e7b4:	1800321e 	bne	r3,zero,8110e880 <vQCmdFEEinWaitingSync+0x164>
8110e7b8:	10c02920 	cmpeqi	r3,r2,164
8110e7bc:	18000f1e 	bne	r3,zero,8110e7fc <vQCmdFEEinWaitingSync+0xe0>
8110e7c0:	10802a20 	cmpeqi	r2,r2,168
8110e7c4:	1000171e 	bne	r2,zero,8110e824 <vQCmdFEEinWaitingSync+0x108>
8110e7c8:	00003e06 	br	8110e8c4 <vQCmdFEEinWaitingSync+0x1a8>
8110e7cc:	10803c20 	cmpeqi	r2,r2,240
8110e7d0:	10001e1e 	bne	r2,zero,8110e84c <vQCmdFEEinWaitingSync+0x130>
8110e7d4:	00003b06 	br	8110e8c4 <vQCmdFEEinWaitingSync+0x1a8>
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110e7d8:	e0bffe17 	ldw	r2,-8(fp)
8110e7dc:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110e7e0:	e0bffe17 	ldw	r2,-8(fp)
8110e7e4:	00c00144 	movi	r3,5
8110e7e8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110e7ec:	e0bffe17 	ldw	r2,-8(fp)
8110e7f0:	00c00144 	movi	r3,5
8110e7f4:	10c02d15 	stw	r3,180(r2)
				break;
8110e7f8:	00003c06 	br	8110e8ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110e7fc:	e0bffe17 	ldw	r2,-8(fp)
8110e800:	00c00044 	movi	r3,1
8110e804:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110e808:	e0bffe17 	ldw	r2,-8(fp)
8110e80c:	00c00304 	movi	r3,12
8110e810:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110e814:	e0bffe17 	ldw	r2,-8(fp)
8110e818:	00c00184 	movi	r3,6
8110e81c:	10c02d15 	stw	r3,180(r2)
				break;
8110e820:	00003206 	br	8110e8ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110e824:	e0bffe17 	ldw	r2,-8(fp)
8110e828:	00c00044 	movi	r3,1
8110e82c:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110e830:	e0bffe17 	ldw	r2,-8(fp)
8110e834:	00c00284 	movi	r3,10
8110e838:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110e83c:	e0bffe17 	ldw	r2,-8(fp)
8110e840:	00c00304 	movi	r3,12
8110e844:	10c02d15 	stw	r3,180(r2)
				break;
8110e848:	00002806 	br	8110e8ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110e84c:	d0e06117 	ldw	r3,-32380(gp)
8110e850:	e0bffe17 	ldw	r2,-8(fp)
8110e854:	10800003 	ldbu	r2,0(r2)
8110e858:	10803fcc 	andi	r2,r2,255
8110e85c:	100d883a 	mov	r6,r2
8110e860:	01604574 	movhi	r5,33045
8110e864:	296a0b04 	addi	r5,r5,-22484
8110e868:	1809883a 	mov	r4,r3
8110e86c:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPWaitingSync( pxNFeeP, cmd );
8110e870:	e17fff17 	ldw	r5,-4(fp)
8110e874:	e13ffe17 	ldw	r4,-8(fp)
8110e878:	110f6040 	call	8110f604 <vQCmdFeeRMAPWaitingSync>
				break;
8110e87c:	00001b06 	br	8110e8ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110e880:	e0bffe17 	ldw	r2,-8(fp)
8110e884:	10c02d17 	ldw	r3,180(r2)
8110e888:	e0bffe17 	ldw	r2,-8(fp)
8110e88c:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110e890:	e0bffe17 	ldw	r2,-8(fp)
8110e894:	10002815 	stw	zero,160(r2)

				break;
8110e898:	00001406 	br	8110e8ec <vQCmdFEEinWaitingSync+0x1d0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110e89c:	e0bffe17 	ldw	r2,-8(fp)
8110e8a0:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110e8a4:	e0bffe17 	ldw	r2,-8(fp)
8110e8a8:	10800003 	ldbu	r2,0(r2)
8110e8ac:	10803fcc 	andi	r2,r2,255
8110e8b0:	100d883a 	mov	r6,r2
8110e8b4:	000b883a 	mov	r5,zero
8110e8b8:	01002044 	movi	r4,129
8110e8bc:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>
				break;
8110e8c0:	00000a06 	br	8110e8ec <vQCmdFEEinWaitingSync+0x1d0>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110e8c4:	d0e06117 	ldw	r3,-32380(gp)
8110e8c8:	e0bffe17 	ldw	r2,-8(fp)
8110e8cc:	10800003 	ldbu	r2,0(r2)
8110e8d0:	10803fcc 	andi	r2,r2,255
8110e8d4:	100d883a 	mov	r6,r2
8110e8d8:	01604574 	movhi	r5,33045
8110e8dc:	296a1504 	addi	r5,r5,-22444
8110e8e0:	1809883a 	mov	r4,r3
8110e8e4:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110e8e8:	0001883a 	nop
		}
	}
}
8110e8ec:	0001883a 	nop
8110e8f0:	e037883a 	mov	sp,fp
8110e8f4:	dfc00117 	ldw	ra,4(sp)
8110e8f8:	df000017 	ldw	fp,0(sp)
8110e8fc:	dec00204 	addi	sp,sp,8
8110e900:	f800283a 	ret

8110e904 <vQCmdFEEinConfig>:


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110e904:	defffb04 	addi	sp,sp,-20
8110e908:	de00012e 	bgeu	sp,et,8110e910 <vQCmdFEEinConfig+0xc>
8110e90c:	003b68fa 	trap	3
8110e910:	dfc00415 	stw	ra,16(sp)
8110e914:	df000315 	stw	fp,12(sp)
8110e918:	df000304 	addi	fp,sp,12
8110e91c:	e13ffe15 	stw	r4,-8(fp)
8110e920:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110e924:	e0bfff17 	ldw	r2,-4(fp)
8110e928:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110e92c:	e0bffdc3 	ldbu	r2,-9(fp)
8110e930:	10c03fcc 	andi	r3,r2,255
8110e934:	e0bffe17 	ldw	r2,-8(fp)
8110e938:	10800003 	ldbu	r2,0(r2)
8110e93c:	10803fcc 	andi	r2,r2,255
8110e940:	10800444 	addi	r2,r2,17
8110e944:	18805a1e 	bne	r3,r2,8110eab0 <vQCmdFEEinConfig+0x1ac>

		switch (uiCmdFEEL.ucByte[2]) {
8110e948:	e0bffd83 	ldbu	r2,-10(fp)
8110e94c:	10803fcc 	andi	r2,r2,255
8110e950:	10c02860 	cmpeqi	r3,r2,161
8110e954:	18001a1e 	bne	r3,zero,8110e9c0 <vQCmdFEEinConfig+0xbc>
8110e958:	10c02888 	cmpgei	r3,r2,162
8110e95c:	18000c1e 	bne	r3,zero,8110e990 <vQCmdFEEinConfig+0x8c>
8110e960:	10c00120 	cmpeqi	r3,r2,4
8110e964:	1800201e 	bne	r3,zero,8110e9e8 <vQCmdFEEinConfig+0xe4>
8110e968:	10c00148 	cmpgei	r3,r2,5
8110e96c:	1800031e 	bne	r3,zero,8110e97c <vQCmdFEEinConfig+0x78>
8110e970:	10800060 	cmpeqi	r2,r2,1
8110e974:	1000121e 	bne	r2,zero,8110e9c0 <vQCmdFEEinConfig+0xbc>
8110e978:	00004206 	br	8110ea84 <vQCmdFEEinConfig+0x180>
8110e97c:	10c00220 	cmpeqi	r3,r2,8
8110e980:	1800221e 	bne	r3,zero,8110ea0c <vQCmdFEEinConfig+0x108>
8110e984:	108023e0 	cmpeqi	r2,r2,143
8110e988:	1000341e 	bne	r2,zero,8110ea5c <vQCmdFEEinConfig+0x158>
8110e98c:	00003d06 	br	8110ea84 <vQCmdFEEinConfig+0x180>
8110e990:	10c03888 	cmpgei	r3,r2,226
8110e994:	1800071e 	bne	r3,zero,8110e9b4 <vQCmdFEEinConfig+0xb0>
8110e998:	10c03808 	cmpgei	r3,r2,224
8110e99c:	1800431e 	bne	r3,zero,8110eaac <vQCmdFEEinConfig+0x1a8>
8110e9a0:	10c02920 	cmpeqi	r3,r2,164
8110e9a4:	1800101e 	bne	r3,zero,8110e9e8 <vQCmdFEEinConfig+0xe4>
8110e9a8:	10802a20 	cmpeqi	r2,r2,168
8110e9ac:	1000171e 	bne	r2,zero,8110ea0c <vQCmdFEEinConfig+0x108>
8110e9b0:	00003406 	br	8110ea84 <vQCmdFEEinConfig+0x180>
8110e9b4:	10803c20 	cmpeqi	r2,r2,240
8110e9b8:	10001e1e 	bne	r2,zero,8110ea34 <vQCmdFEEinConfig+0x130>
8110e9bc:	00003106 	br	8110ea84 <vQCmdFEEinConfig+0x180>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110e9c0:	d0e06117 	ldw	r3,-32380(gp)
8110e9c4:	e0bffe17 	ldw	r2,-8(fp)
8110e9c8:	10800003 	ldbu	r2,0(r2)
8110e9cc:	10803fcc 	andi	r2,r2,255
8110e9d0:	100d883a 	mov	r6,r2
8110e9d4:	01604574 	movhi	r5,33045
8110e9d8:	296a2604 	addi	r5,r5,-22376
8110e9dc:	1809883a 	mov	r4,r3
8110e9e0:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110e9e4:	00003206 	br	8110eab0 <vQCmdFEEinConfig+0x1ac>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				break;*/
			case M_FEE_STANDBY: /* Config -> StandBy is always forced mode (don't need sync) */
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110e9e8:	e0bffe17 	ldw	r2,-8(fp)
8110e9ec:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110e9f0:	e0bffe17 	ldw	r2,-8(fp)
8110e9f4:	00c00184 	movi	r3,6
8110e9f8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110e9fc:	e0bffe17 	ldw	r2,-8(fp)
8110ea00:	00c00184 	movi	r3,6
8110ea04:	10c02d15 	stw	r3,180(r2)
				break;				
8110ea08:	00002906 	br	8110eab0 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110ea0c:	d0e06117 	ldw	r3,-32380(gp)
8110ea10:	e0bffe17 	ldw	r2,-8(fp)
8110ea14:	10800003 	ldbu	r2,0(r2)
8110ea18:	10803fcc 	andi	r2,r2,255
8110ea1c:	100d883a 	mov	r6,r2
8110ea20:	01604574 	movhi	r5,33045
8110ea24:	296a3104 	addi	r5,r5,-22332
8110ea28:	1809883a 	mov	r4,r3
8110ea2c:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110ea30:	00001f06 	br	8110eab0 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110ea34:	d0e06117 	ldw	r3,-32380(gp)
8110ea38:	e0bffe17 	ldw	r2,-8(fp)
8110ea3c:	10800003 	ldbu	r2,0(r2)
8110ea40:	10803fcc 	andi	r2,r2,255
8110ea44:	100d883a 	mov	r6,r2
8110ea48:	01604574 	movhi	r5,33045
8110ea4c:	296a4204 	addi	r5,r5,-22264
8110ea50:	1809883a 	mov	r4,r3
8110ea54:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110ea58:	00001506 	br	8110eab0 <vQCmdFEEinConfig+0x1ac>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110ea5c:	e0bffe17 	ldw	r2,-8(fp)
8110ea60:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110ea64:	e0bffe17 	ldw	r2,-8(fp)
8110ea68:	10800003 	ldbu	r2,0(r2)
8110ea6c:	10803fcc 	andi	r2,r2,255
8110ea70:	100d883a 	mov	r6,r2
8110ea74:	000b883a 	mov	r5,zero
8110ea78:	01002044 	movi	r4,129
8110ea7c:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>
				break;
8110ea80:	00000b06 	br	8110eab0 <vQCmdFEEinConfig+0x1ac>
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110ea84:	d0e06117 	ldw	r3,-32380(gp)
8110ea88:	e0bffe17 	ldw	r2,-8(fp)
8110ea8c:	10800003 	ldbu	r2,0(r2)
8110ea90:	10803fcc 	andi	r2,r2,255
8110ea94:	100d883a 	mov	r6,r2
8110ea98:	01604574 	movhi	r5,33045
8110ea9c:	296a5504 	addi	r5,r5,-22188
8110eaa0:	1809883a 	mov	r4,r3
8110eaa4:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110eaa8:	00000106 	br	8110eab0 <vQCmdFEEinConfig+0x1ac>
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
				break;
			case M_SYNC:
			case M_MASTER_SYNC:
				break;
8110eaac:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110eab0:	0001883a 	nop
8110eab4:	e037883a 	mov	sp,fp
8110eab8:	dfc00117 	ldw	ra,4(sp)
8110eabc:	df000017 	ldw	fp,0(sp)
8110eac0:	dec00204 	addi	sp,sp,8
8110eac4:	f800283a 	ret

8110eac8 <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110eac8:	defffb04 	addi	sp,sp,-20
8110eacc:	de00012e 	bgeu	sp,et,8110ead4 <vQCmdFEEinStandBy+0xc>
8110ead0:	003b68fa 	trap	3
8110ead4:	dfc00415 	stw	ra,16(sp)
8110ead8:	df000315 	stw	fp,12(sp)
8110eadc:	df000304 	addi	fp,sp,12
8110eae0:	e13ffe15 	stw	r4,-8(fp)
8110eae4:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110eae8:	e0bfff17 	ldw	r2,-4(fp)
8110eaec:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110eaf0:	e0bffdc3 	ldbu	r2,-9(fp)
8110eaf4:	10c03fcc 	andi	r3,r2,255
8110eaf8:	e0bffe17 	ldw	r2,-8(fp)
8110eafc:	10800003 	ldbu	r2,0(r2)
8110eb00:	10803fcc 	andi	r2,r2,255
8110eb04:	10800444 	addi	r2,r2,17
8110eb08:	1880681e 	bne	r3,r2,8110ecac <vQCmdFEEinStandBy+0x1e4>

		switch (uiCmdFEEL.ucByte[2]) {
8110eb0c:	e0bffd83 	ldbu	r2,-10(fp)
8110eb10:	10803fcc 	andi	r2,r2,255
8110eb14:	10c02860 	cmpeqi	r3,r2,161
8110eb18:	18001a1e 	bne	r3,zero,8110eb84 <vQCmdFEEinStandBy+0xbc>
8110eb1c:	10c02888 	cmpgei	r3,r2,162
8110eb20:	18000c1e 	bne	r3,zero,8110eb54 <vQCmdFEEinStandBy+0x8c>
8110eb24:	10c00120 	cmpeqi	r3,r2,4
8110eb28:	18001f1e 	bne	r3,zero,8110eba8 <vQCmdFEEinStandBy+0xe0>
8110eb2c:	10c00148 	cmpgei	r3,r2,5
8110eb30:	1800031e 	bne	r3,zero,8110eb40 <vQCmdFEEinStandBy+0x78>
8110eb34:	10800060 	cmpeqi	r2,r2,1
8110eb38:	1000121e 	bne	r2,zero,8110eb84 <vQCmdFEEinStandBy+0xbc>
8110eb3c:	00005006 	br	8110ec80 <vQCmdFEEinStandBy+0x1b8>
8110eb40:	10c00220 	cmpeqi	r3,r2,8
8110eb44:	1800221e 	bne	r3,zero,8110ebd0 <vQCmdFEEinStandBy+0x108>
8110eb48:	108023e0 	cmpeqi	r2,r2,143
8110eb4c:	1000421e 	bne	r2,zero,8110ec58 <vQCmdFEEinStandBy+0x190>
8110eb50:	00004b06 	br	8110ec80 <vQCmdFEEinStandBy+0x1b8>
8110eb54:	10c03888 	cmpgei	r3,r2,226
8110eb58:	1800071e 	bne	r3,zero,8110eb78 <vQCmdFEEinStandBy+0xb0>
8110eb5c:	10c03808 	cmpgei	r3,r2,224
8110eb60:	1800321e 	bne	r3,zero,8110ec2c <vQCmdFEEinStandBy+0x164>
8110eb64:	10c02920 	cmpeqi	r3,r2,164
8110eb68:	18000f1e 	bne	r3,zero,8110eba8 <vQCmdFEEinStandBy+0xe0>
8110eb6c:	10802a20 	cmpeqi	r2,r2,168
8110eb70:	1000171e 	bne	r2,zero,8110ebd0 <vQCmdFEEinStandBy+0x108>
8110eb74:	00004206 	br	8110ec80 <vQCmdFEEinStandBy+0x1b8>
8110eb78:	10803c20 	cmpeqi	r2,r2,240
8110eb7c:	10001e1e 	bne	r2,zero,8110ebf8 <vQCmdFEEinStandBy+0x130>
8110eb80:	00003f06 	br	8110ec80 <vQCmdFEEinStandBy+0x1b8>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED: /* Standby to Config is always forced mode */
				pxNFeeP->xControl.bWatingSync = FALSE;
8110eb84:	e0bffe17 	ldw	r2,-8(fp)
8110eb88:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110eb8c:	e0bffe17 	ldw	r2,-8(fp)
8110eb90:	00c00144 	movi	r3,5
8110eb94:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110eb98:	e0bffe17 	ldw	r2,-8(fp)
8110eb9c:	00c00144 	movi	r3,5
8110eba0:	10c02d15 	stw	r3,180(r2)
				break;				
8110eba4:	00004106 	br	8110ecac <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110eba8:	d0e06117 	ldw	r3,-32380(gp)
8110ebac:	e0bffe17 	ldw	r2,-8(fp)
8110ebb0:	10800003 	ldbu	r2,0(r2)
8110ebb4:	10803fcc 	andi	r2,r2,255
8110ebb8:	100d883a 	mov	r6,r2
8110ebbc:	01604574 	movhi	r5,33045
8110ebc0:	296a6604 	addi	r5,r5,-22120
8110ebc4:	1809883a 	mov	r4,r3
8110ebc8:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110ebcc:	00003706 	br	8110ecac <vQCmdFEEinStandBy+0x1e4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED: /* There are no forced mode to go to the Pattern Mode */
				pxNFeeP->xControl.bWatingSync = TRUE;
8110ebd0:	e0bffe17 	ldw	r2,-8(fp)
8110ebd4:	00c00044 	movi	r3,1
8110ebd8:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110ebdc:	e0bffe17 	ldw	r2,-8(fp)
8110ebe0:	00c00284 	movi	r3,10
8110ebe4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110ebe8:	e0bffe17 	ldw	r2,-8(fp)
8110ebec:	00c00304 	movi	r3,12
8110ebf0:	10c02d15 	stw	r3,180(r2)
				break;
8110ebf4:	00002d06 	br	8110ecac <vQCmdFEEinStandBy+0x1e4>

			case M_FEE_RMAP:
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110ebf8:	e17fff17 	ldw	r5,-4(fp)
8110ebfc:	e13ffe17 	ldw	r4,-8(fp)
8110ec00:	110eef40 	call	8110eef4 <vQCmdFeeRMAPinStandBy>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110ec04:	d0e06117 	ldw	r3,-32380(gp)
8110ec08:	e0bffe17 	ldw	r2,-8(fp)
8110ec0c:	10800003 	ldbu	r2,0(r2)
8110ec10:	10803fcc 	andi	r2,r2,255
8110ec14:	100d883a 	mov	r6,r2
8110ec18:	01604574 	movhi	r5,33045
8110ec1c:	296a0b04 	addi	r5,r5,-22484
8110ec20:	1809883a 	mov	r4,r3
8110ec24:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				/* Perform some actions, check if is a valid command for this mode of operation  */

				break;
8110ec28:	00002006 	br	8110ecac <vQCmdFEEinStandBy+0x1e4>


			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110ec2c:	e0bffe17 	ldw	r2,-8(fp)
8110ec30:	10802c17 	ldw	r2,176(r2)
8110ec34:	10800318 	cmpnei	r2,r2,12
8110ec38:	10001b1e 	bne	r2,zero,8110eca8 <vQCmdFEEinStandBy+0x1e0>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110ec3c:	e0bffe17 	ldw	r2,-8(fp)
8110ec40:	10c02d17 	ldw	r3,180(r2)
8110ec44:	e0bffe17 	ldw	r2,-8(fp)
8110ec48:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110ec4c:	e0bffe17 	ldw	r2,-8(fp)
8110ec50:	10002815 	stw	zero,160(r2)
				}
				break;
8110ec54:	00001406 	br	8110eca8 <vQCmdFEEinStandBy+0x1e0>
			case M_FEE_DMA_ACCESS:
				pxNFeeP->xControl.bUsingDMA = FALSE;
8110ec58:	e0bffe17 	ldw	r2,-8(fp)
8110ec5c:	10002315 	stw	zero,140(r2)
				/* Send message telling to controller that is not using the DMA any more */
				bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFeeP->ucId);
8110ec60:	e0bffe17 	ldw	r2,-8(fp)
8110ec64:	10800003 	ldbu	r2,0(r2)
8110ec68:	10803fcc 	andi	r2,r2,255
8110ec6c:	100d883a 	mov	r6,r2
8110ec70:	000b883a 	mov	r5,zero
8110ec74:	01002044 	movi	r4,129
8110ec78:	110fb600 	call	8110fb60 <bSendGiveBackNFeeCtrl>
				break;
8110ec7c:	00000b06 	br	8110ecac <vQCmdFEEinStandBy+0x1e4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110ec80:	d0e06117 	ldw	r3,-32380(gp)
8110ec84:	e0bffe17 	ldw	r2,-8(fp)
8110ec88:	10800003 	ldbu	r2,0(r2)
8110ec8c:	10803fcc 	andi	r2,r2,255
8110ec90:	100d883a 	mov	r6,r2
8110ec94:	01604574 	movhi	r5,33045
8110ec98:	296a1504 	addi	r5,r5,-22444
8110ec9c:	1809883a 	mov	r4,r3
8110eca0:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110eca4:	00000106 	br	8110ecac <vQCmdFEEinStandBy+0x1e4>
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}
				break;
8110eca8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110ecac:	0001883a 	nop
8110ecb0:	e037883a 	mov	sp,fp
8110ecb4:	dfc00117 	ldw	ra,4(sp)
8110ecb8:	df000017 	ldw	fp,0(sp)
8110ecbc:	dec00204 	addi	sp,sp,8
8110ecc0:	f800283a 	ret

8110ecc4 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110ecc4:	defffb04 	addi	sp,sp,-20
8110ecc8:	de00012e 	bgeu	sp,et,8110ecd0 <vQCmdFEEinFullPattern+0xc>
8110eccc:	003b68fa 	trap	3
8110ecd0:	dfc00415 	stw	ra,16(sp)
8110ecd4:	df000315 	stw	fp,12(sp)
8110ecd8:	df000304 	addi	fp,sp,12
8110ecdc:	e13ffe15 	stw	r4,-8(fp)
8110ece0:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110ece4:	e0bfff17 	ldw	r2,-4(fp)
8110ece8:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110ecec:	e0bffdc3 	ldbu	r2,-9(fp)
8110ecf0:	10c03fcc 	andi	r3,r2,255
8110ecf4:	e0bffe17 	ldw	r2,-8(fp)
8110ecf8:	10800003 	ldbu	r2,0(r2)
8110ecfc:	10803fcc 	andi	r2,r2,255
8110ed00:	10800444 	addi	r2,r2,17
8110ed04:	1880751e 	bne	r3,r2,8110eedc <vQCmdFEEinFullPattern+0x218>

		switch (uiCmdFEEL.ucByte[2]) {
8110ed08:	e0bffd83 	ldbu	r2,-10(fp)
8110ed0c:	10803fcc 	andi	r2,r2,255
8110ed10:	10c02860 	cmpeqi	r3,r2,161
8110ed14:	1800181e 	bne	r3,zero,8110ed78 <vQCmdFEEinFullPattern+0xb4>
8110ed18:	10c02888 	cmpgei	r3,r2,162
8110ed1c:	18000c1e 	bne	r3,zero,8110ed50 <vQCmdFEEinFullPattern+0x8c>
8110ed20:	10c000a0 	cmpeqi	r3,r2,2
8110ed24:	18006a1e 	bne	r3,zero,8110eed0 <vQCmdFEEinFullPattern+0x20c>
8110ed28:	10c000c8 	cmpgei	r3,r2,3
8110ed2c:	1800031e 	bne	r3,zero,8110ed3c <vQCmdFEEinFullPattern+0x78>
8110ed30:	10800060 	cmpeqi	r2,r2,1
8110ed34:	1000101e 	bne	r2,zero,8110ed78 <vQCmdFEEinFullPattern+0xb4>
8110ed38:	00005b06 	br	8110eea8 <vQCmdFEEinFullPattern+0x1e4>
8110ed3c:	10c00120 	cmpeqi	r3,r2,4
8110ed40:	1800161e 	bne	r3,zero,8110ed9c <vQCmdFEEinFullPattern+0xd8>
8110ed44:	10800220 	cmpeqi	r2,r2,8
8110ed48:	1000351e 	bne	r2,zero,8110ee20 <vQCmdFEEinFullPattern+0x15c>
8110ed4c:	00005606 	br	8110eea8 <vQCmdFEEinFullPattern+0x1e4>
8110ed50:	10c03888 	cmpgei	r3,r2,226
8110ed54:	1800051e 	bne	r3,zero,8110ed6c <vQCmdFEEinFullPattern+0xa8>
8110ed58:	10c03808 	cmpgei	r3,r2,224
8110ed5c:	1800471e 	bne	r3,zero,8110ee7c <vQCmdFEEinFullPattern+0x1b8>
8110ed60:	10802920 	cmpeqi	r2,r2,164
8110ed64:	1000251e 	bne	r2,zero,8110edfc <vQCmdFEEinFullPattern+0x138>
8110ed68:	00004f06 	br	8110eea8 <vQCmdFEEinFullPattern+0x1e4>
8110ed6c:	10803c20 	cmpeqi	r2,r2,240
8110ed70:	1000351e 	bne	r2,zero,8110ee48 <vQCmdFEEinFullPattern+0x184>
8110ed74:	00004c06 	br	8110eea8 <vQCmdFEEinFullPattern+0x1e4>
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
				break;*/
			case M_FEE_CONFIG:
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ed78:	e0bffe17 	ldw	r2,-8(fp)
8110ed7c:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110ed80:	e0bffe17 	ldw	r2,-8(fp)
8110ed84:	00c00144 	movi	r3,5
8110ed88:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ed8c:	e0bffe17 	ldw	r2,-8(fp)
8110ed90:	00c00144 	movi	r3,5
8110ed94:	10c02d15 	stw	r3,180(r2)
				break;				
8110ed98:	00005006 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
				break;
			case M_FEE_STANDBY:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;*/ /* To finish the actual transfer only when sync comes */
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110ed9c:	e0bffe17 	ldw	r2,-8(fp)
8110eda0:	10802c17 	ldw	r2,176(r2)
8110eda4:	10800298 	cmpnei	r2,r2,10
8110eda8:	10000a1e 	bne	r2,zero,8110edd4 <vQCmdFEEinFullPattern+0x110>
					pxNFeeP->xControl.bWatingSync = TRUE;
8110edac:	e0bffe17 	ldw	r2,-8(fp)
8110edb0:	00c00044 	movi	r3,1
8110edb4:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110edb8:	e0bffe17 	ldw	r2,-8(fp)
8110edbc:	00c00304 	movi	r3,12
8110edc0:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110edc4:	e0bffe17 	ldw	r2,-8(fp)
8110edc8:	00c00184 	movi	r3,6
8110edcc:	10c02d15 	stw	r3,180(r2)
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				}

				break;
8110edd0:	00004206 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
					pxNFeeP->xControl.bWatingSync = TRUE;
					pxNFeeP->xControl.eMode = sFeeWaitingSync;
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
				} else {
					pxNFeeP->xControl.bWatingSync = TRUE;
8110edd4:	e0bffe17 	ldw	r2,-8(fp)
8110edd8:	00c00044 	movi	r3,1
8110eddc:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110ede0:	e0bffe17 	ldw	r2,-8(fp)
8110ede4:	00c00104 	movi	r3,4
8110ede8:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110edec:	e0bffe17 	ldw	r2,-8(fp)
8110edf0:	00c00184 	movi	r3,6
8110edf4:	10c02d15 	stw	r3,180(r2)
				}

				break;
8110edf8:	00003806 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110edfc:	e0bffe17 	ldw	r2,-8(fp)
8110ee00:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110ee04:	e0bffe17 	ldw	r2,-8(fp)
8110ee08:	00c00184 	movi	r3,6
8110ee0c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110ee10:	e0bffe17 	ldw	r2,-8(fp)
8110ee14:	00c00184 	movi	r3,6
8110ee18:	10c02d15 	stw	r3,180(r2)
				break;				
8110ee1c:	00002f06 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110ee20:	d0e06117 	ldw	r3,-32380(gp)
8110ee24:	e0bffe17 	ldw	r2,-8(fp)
8110ee28:	10800003 	ldbu	r2,0(r2)
8110ee2c:	10803fcc 	andi	r2,r2,255
8110ee30:	100d883a 	mov	r6,r2
8110ee34:	01604574 	movhi	r5,33045
8110ee38:	296a7104 	addi	r5,r5,-22076
8110ee3c:	1809883a 	mov	r4,r3
8110ee40:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110ee44:	00002506 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110ee48:	d0e06117 	ldw	r3,-32380(gp)
8110ee4c:	e0bffe17 	ldw	r2,-8(fp)
8110ee50:	10800003 	ldbu	r2,0(r2)
8110ee54:	10803fcc 	andi	r2,r2,255
8110ee58:	100d883a 	mov	r6,r2
8110ee5c:	01604574 	movhi	r5,33045
8110ee60:	296a0b04 	addi	r5,r5,-22484
8110ee64:	1809883a 	mov	r4,r3
8110ee68:	111f5fc0 	call	8111f5fc <fprintf>
				#endif

				/* Perform some actions, check if is a valid command for this mode of operation  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110ee6c:	e17fff17 	ldw	r5,-4(fp)
8110ee70:	e13ffe17 	ldw	r4,-8(fp)
8110ee74:	110f39c0 	call	8110f39c <vQCmdFeeRMAPinFullPattern>

				break;
8110ee78:	00001806 	br	8110eedc <vQCmdFEEinFullPattern+0x218>

			case M_SYNC:
			case M_MASTER_SYNC:
				/* Warning */
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
8110ee7c:	e0bffe17 	ldw	r2,-8(fp)
8110ee80:	10802c17 	ldw	r2,176(r2)
8110ee84:	10800318 	cmpnei	r2,r2,12
8110ee88:	1000131e 	bne	r2,zero,8110eed8 <vQCmdFEEinFullPattern+0x214>
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110ee8c:	e0bffe17 	ldw	r2,-8(fp)
8110ee90:	10c02d17 	ldw	r3,180(r2)
8110ee94:	e0bffe17 	ldw	r2,-8(fp)
8110ee98:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.bWatingSync = FALSE;
8110ee9c:	e0bffe17 	ldw	r2,-8(fp)
8110eea0:	10002815 	stw	zero,160(r2)
				}

				break;
8110eea4:	00000c06 	br	8110eed8 <vQCmdFEEinFullPattern+0x214>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110eea8:	d0e06117 	ldw	r3,-32380(gp)
8110eeac:	e0bffe17 	ldw	r2,-8(fp)
8110eeb0:	10800003 	ldbu	r2,0(r2)
8110eeb4:	10803fcc 	andi	r2,r2,255
8110eeb8:	100d883a 	mov	r6,r2
8110eebc:	01604574 	movhi	r5,33045
8110eec0:	296a5504 	addi	r5,r5,-22188
8110eec4:	1809883a 	mov	r4,r3
8110eec8:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110eecc:	00000306 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110eed0:	0001883a 	nop
8110eed4:	00000106 	br	8110eedc <vQCmdFEEinFullPattern+0x218>
				if ( pxNFeeP->xControl.eMode == sFeeWaitingSync ) {
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
					pxNFeeP->xControl.bWatingSync = FALSE;
				}

				break;
8110eed8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110eedc:	0001883a 	nop
8110eee0:	e037883a 	mov	sp,fp
8110eee4:	dfc00117 	ldw	ra,4(sp)
8110eee8:	df000017 	ldw	fp,0(sp)
8110eeec:	dec00204 	addi	sp,sp,8
8110eef0:	f800283a 	ret

8110eef4 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110eef4:	defff704 	addi	sp,sp,-36
8110eef8:	de00012e 	bgeu	sp,et,8110ef00 <vQCmdFeeRMAPinStandBy+0xc>
8110eefc:	003b68fa 	trap	3
8110ef00:	dfc00815 	stw	ra,32(sp)
8110ef04:	df000715 	stw	fp,28(sp)
8110ef08:	df000704 	addi	fp,sp,28
8110ef0c:	e13ffe15 	stw	r4,-8(fp)
8110ef10:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueMasked;
	INT32U ucValueMasked2;


#ifdef DEBUG_ON
	fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (StandBy)\n", pxNFeeP->ucId);
8110ef14:	d0e06117 	ldw	r3,-32380(gp)
8110ef18:	e0bffe17 	ldw	r2,-8(fp)
8110ef1c:	10800003 	ldbu	r2,0(r2)
8110ef20:	10803fcc 	andi	r2,r2,255
8110ef24:	100d883a 	mov	r6,r2
8110ef28:	01604574 	movhi	r5,33045
8110ef2c:	296a7f04 	addi	r5,r5,-22020
8110ef30:	1809883a 	mov	r4,r3
8110ef34:	111f5fc0 	call	8111f5fc <fprintf>
#endif


	uiCmdFEEL.ulWord = cmd;
8110ef38:	e0bfff17 	ldw	r2,-4(fp)
8110ef3c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110ef40:	e0bffd43 	ldbu	r2,-11(fp)
8110ef44:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110ef48:	e0bffe17 	ldw	r2,-8(fp)
8110ef4c:	10804317 	ldw	r2,268(r2)
8110ef50:	e0fff903 	ldbu	r3,-28(fp)
8110ef54:	180b883a 	mov	r5,r3
8110ef58:	1009883a 	mov	r4,r2
8110ef5c:	11099bc0 	call	811099bc <uliRmapReadReg>
8110ef60:	e0bffa15 	stw	r2,-24(fp)

	switch (ucADDRReg) {
8110ef64:	e0bff903 	ldbu	r2,-28(fp)
8110ef68:	10bff004 	addi	r2,r2,-64
8110ef6c:	10c003a8 	cmpgeui	r3,r2,14
8110ef70:	1800f91e 	bne	r3,zero,8110f358 <vQCmdFeeRMAPinStandBy+0x464>
8110ef74:	100690ba 	slli	r3,r2,2
8110ef78:	00a04474 	movhi	r2,33041
8110ef7c:	10bbe304 	addi	r2,r2,-4212
8110ef80:	1885883a 	add	r2,r3,r2
8110ef84:	10800017 	ldw	r2,0(r2)
8110ef88:	1000683a 	jmp	r2
8110ef8c:	8110efc4 	addi	r4,r16,17343
8110ef90:	8110f378 	rdprs	r4,r16,17357
8110ef94:	8110f090 	cmplti	r4,r16,17346
8110ef98:	8110f1f8 	rdprs	r4,r16,17351
8110ef9c:	8110f1f8 	rdprs	r4,r16,17351
8110efa0:	8110f1f8 	rdprs	r4,r16,17351
8110efa4:	8110f1f8 	rdprs	r4,r16,17351
8110efa8:	8110f1f8 	rdprs	r4,r16,17351
8110efac:	8110f1f8 	rdprs	r4,r16,17351
8110efb0:	8110f1f8 	rdprs	r4,r16,17351
8110efb4:	8110f1f8 	rdprs	r4,r16,17351
8110efb8:	8110f1f8 	rdprs	r4,r16,17351
8110efbc:	8110f214 	ori	r4,r16,17352
8110efc0:	8110f2e8 	cmpgeui	r4,r16,17355
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110efc4:	e0fffa17 	ldw	r3,-24(fp)
8110efc8:	00800434 	movhi	r2,16
8110efcc:	10bffc04 	addi	r2,r2,-16
8110efd0:	1884703a 	and	r2,r3,r2
8110efd4:	1004d13a 	srli	r2,r2,4
8110efd8:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110efdc:	e0bffa17 	ldw	r2,-24(fp)
8110efe0:	1004d53a 	srli	r2,r2,20
8110efe4:	e0bffc15 	stw	r2,-16(fp)

			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked;
8110efe8:	e0bffb17 	ldw	r2,-20(fp)
8110efec:	1007883a 	mov	r3,r2
8110eff0:	e0bffe17 	ldw	r2,-8(fp)
8110eff4:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2;
8110eff8:	e0bffc17 	ldw	r2,-16(fp)
8110effc:	1007883a 	mov	r3,r2
8110f000:	e0bffe17 	ldw	r2,-8(fp)
8110f004:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110f008:	e13ffe17 	ldw	r4,-8(fp)
8110f00c:	111baf80 	call	8111baf8 <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f010:	e0bffe17 	ldw	r2,-8(fp)
8110f014:	10803304 	addi	r2,r2,204
8110f018:	1009883a 	mov	r4,r2
8110f01c:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFeeP->xCcdInfo.usiHalfWidth;
8110f020:	e0bffe17 	ldw	r2,-8(fp)
8110f024:	10c0308b 	ldhu	r3,194(r2)
8110f028:	e0bffe17 	ldw	r2,-8(fp)
8110f02c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFeeP->xCcdInfo.usiHeight;
8110f030:	e0bffe17 	ldw	r2,-8(fp)
8110f034:	10c0310b 	ldhu	r3,196(r2)
8110f038:	e0bffe17 	ldw	r2,-8(fp)
8110f03c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFeeP->xCcdInfo.usiHeight - pxNFeeP->xCcdInfo.usiOLN;
8110f040:	e0bffe17 	ldw	r2,-8(fp)
8110f044:	10c0310b 	ldhu	r3,196(r2)
8110f048:	e0bffe17 	ldw	r2,-8(fp)
8110f04c:	1080300b 	ldhu	r2,192(r2)
8110f050:	1885c83a 	sub	r2,r3,r2
8110f054:	1007883a 	mov	r3,r2
8110f058:	e0bffe17 	ldw	r2,-8(fp)
8110f05c:	10c0350d 	sth	r3,212(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f060:	e0bffe17 	ldw	r2,-8(fp)
8110f064:	10803304 	addi	r2,r2,204
8110f068:	1009883a 	mov	r4,r2
8110f06c:	11048180 	call	81104818 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110f070:	d0a06117 	ldw	r2,-32380(gp)
8110f074:	e1fffc17 	ldw	r7,-16(fp)
8110f078:	e1bffb17 	ldw	r6,-20(fp)
8110f07c:	01604574 	movhi	r5,33045
8110f080:	296a8b04 	addi	r5,r5,-21972
8110f084:	1009883a 	mov	r4,r2
8110f088:	111f5fc0 	call	8111f5fc <fprintf>
			#endif

			break;
8110f08c:	0000bd06 	br	8110f384 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110f090:	e0fffa17 	ldw	r3,-24(fp)
8110f094:	00800434 	movhi	r2,16
8110f098:	10bffc04 	addi	r2,r2,-16
8110f09c:	1884703a 	and	r2,r3,r2
8110f0a0:	1004d13a 	srli	r2,r2,4
8110f0a4:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f0a8:	e0bffe17 	ldw	r2,-8(fp)
8110f0ac:	10803304 	addi	r2,r2,204
8110f0b0:	1009883a 	mov	r4,r2
8110f0b4:	1104a440 	call	81104a44 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110f0b8:	e0bffb17 	ldw	r2,-20(fp)
8110f0bc:	1007883a 	mov	r3,r2
8110f0c0:	e0bffe17 	ldw	r2,-8(fp)
8110f0c4:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110f0c8:	e0bffe17 	ldw	r2,-8(fp)
8110f0cc:	10803304 	addi	r2,r2,204
8110f0d0:	1009883a 	mov	r4,r2
8110f0d4:	11048180 	call	81104818 <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp,"- Pckt Length: %u\n", ucValueMasked);
8110f0d8:	d0a06117 	ldw	r2,-32380(gp)
8110f0dc:	e1bffb17 	ldw	r6,-20(fp)
8110f0e0:	01604574 	movhi	r5,33045
8110f0e4:	296a9204 	addi	r5,r5,-21944
8110f0e8:	1009883a 	mov	r4,r2
8110f0ec:	111f5fc0 	call	8111f5fc <fprintf>
			#endif

			ucValueMasked2 = (ucValueReg & COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK) >> 2;
8110f0f0:	e0bffa17 	ldw	r2,-24(fp)
8110f0f4:	1080030c 	andi	r2,r2,12
8110f0f8:	1004d0ba 	srli	r2,r2,2
8110f0fc:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked2) {
8110f100:	e0bffc17 	ldw	r2,-16(fp)
8110f104:	10c000a0 	cmpeqi	r3,r2,2
8110f108:	18000e1e 	bne	r3,zero,8110f144 <vQCmdFeeRMAPinStandBy+0x250>
8110f10c:	10c000e0 	cmpeqi	r3,r2,3
8110f110:	1800171e 	bne	r3,zero,8110f170 <vQCmdFeeRMAPinStandBy+0x27c>
8110f114:	10800060 	cmpeqi	r2,r2,1
8110f118:	10001e26 	beq	r2,zero,8110f194 <vQCmdFeeRMAPinStandBy+0x2a0>
				case 0b01:
					pxNFeeP->xControl.eSide = sLeft;
8110f11c:	e0bffe17 	ldw	r2,-8(fp)
8110f120:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Left side\n");
8110f124:	d0a06117 	ldw	r2,-32380(gp)
8110f128:	100f883a 	mov	r7,r2
8110f12c:	01800344 	movi	r6,13
8110f130:	01400044 	movi	r5,1
8110f134:	01204574 	movhi	r4,33045
8110f138:	212a9704 	addi	r4,r4,-21924
8110f13c:	111fc980 	call	8111fc98 <fwrite>
					#endif
					break;
8110f140:	00002c06 	br	8110f1f4 <vQCmdFeeRMAPinStandBy+0x300>
				case 0b10:
					pxNFeeP->xControl.eSide = sRight;
8110f144:	e0bffe17 	ldw	r2,-8(fp)
8110f148:	00c00044 	movi	r3,1
8110f14c:	10c02e15 	stw	r3,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Right side\n");
8110f150:	d0a06117 	ldw	r2,-32380(gp)
8110f154:	100f883a 	mov	r7,r2
8110f158:	01800384 	movi	r6,14
8110f15c:	01400044 	movi	r5,1
8110f160:	01204574 	movhi	r4,33045
8110f164:	212a9b04 	addi	r4,r4,-21908
8110f168:	111fc980 	call	8111fc98 <fwrite>
					#endif
					break;
8110f16c:	00002106 	br	8110f1f4 <vQCmdFeeRMAPinStandBy+0x300>
				case 0b11:
					pxNFeeP->xControl.eSide = sLeft;
8110f170:	e0bffe17 	ldw	r2,-8(fp)
8110f174:	10002e15 	stw	zero,184(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Both sides, but not supported yet. Switching to Left side\n");
8110f178:	d0a06117 	ldw	r2,-32380(gp)
8110f17c:	100f883a 	mov	r7,r2
8110f180:	01800f44 	movi	r6,61
8110f184:	01400044 	movi	r5,1
8110f188:	01204574 	movhi	r4,33045
8110f18c:	212a9f04 	addi	r4,r4,-21892
8110f190:	111fc980 	call	8111fc98 <fwrite>
					#endif
				default:
					pxNFeeP->xControl.eSide = sLeft;
8110f194:	e0bffe17 	ldw	r2,-8(fp)
8110f198:	10002e15 	stw	zero,184(r2)

					bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110f19c:	e0bffe17 	ldw	r2,-8(fp)
8110f1a0:	10804304 	addi	r2,r2,268
8110f1a4:	1009883a 	mov	r4,r2
8110f1a8:	11080440 	call	81108044 <bRmapGetMemConfigArea>
					pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSpwPacket1Config & 0xFFFFFFF7);
8110f1ac:	e0bffe17 	ldw	r2,-8(fp)
8110f1b0:	10c05717 	ldw	r3,348(r2)
8110f1b4:	00bffdc4 	movi	r2,-9
8110f1b8:	1886703a 	and	r3,r3,r2
8110f1bc:	e0bffe17 	ldw	r2,-8(fp)
8110f1c0:	10c05715 	stw	r3,348(r2)
					bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110f1c4:	e0bffe17 	ldw	r2,-8(fp)
8110f1c8:	10804304 	addi	r2,r2,268
8110f1cc:	1009883a 	mov	r4,r2
8110f1d0:	1107d580 	call	81107d58 <bRmapSetMemConfigArea>
					#ifdef DEBUG_ON
						fprintf(fp," - Switching to Left side\n");
8110f1d4:	d0a06117 	ldw	r2,-32380(gp)
8110f1d8:	100f883a 	mov	r7,r2
8110f1dc:	01800684 	movi	r6,26
8110f1e0:	01400044 	movi	r5,1
8110f1e4:	01204574 	movhi	r4,33045
8110f1e8:	212aaf04 	addi	r4,r4,-21828
8110f1ec:	111fc980 	call	8111fc98 <fwrite>
					#endif
					break;
8110f1f0:	0001883a 	nop
			}
			break;
8110f1f4:	00006306 	br	8110f384 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp,"Command not allowed yet ( %hhu )\n", ucValueMasked);
8110f1f8:	d0a06117 	ldw	r2,-32380(gp)
8110f1fc:	e1bffb17 	ldw	r6,-20(fp)
8110f200:	01604574 	movhi	r5,33045
8110f204:	296ab604 	addi	r5,r5,-21800
8110f208:	1009883a 	mov	r4,r2
8110f20c:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
				break;
8110f210:	00005c06 	br	8110f384 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110f214:	e0bffa17 	ldw	r2,-24(fp)
8110f218:	10803c0c 	andi	r2,r2,240
8110f21c:	1004d13a 	srli	r2,r2,4
8110f220:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110f224:	e0bffb17 	ldw	r2,-20(fp)
8110f228:	10c000a0 	cmpeqi	r3,r2,2
8110f22c:	18000d1e 	bne	r3,zero,8110f264 <vQCmdFeeRMAPinStandBy+0x370>
8110f230:	10c001a0 	cmpeqi	r3,r2,6
8110f234:	18001c1e 	bne	r3,zero,8110f2a8 <vQCmdFeeRMAPinStandBy+0x3b4>
8110f238:	1000231e 	bne	r2,zero,8110f2c8 <vQCmdFeeRMAPinStandBy+0x3d4>
				case 0: /* Standby */

				#ifdef DEBUG_ON
					fprintf(fp,"- already in Stand by mode\n", pxNFeeP->ucId);
8110f23c:	d0e06117 	ldw	r3,-32380(gp)
8110f240:	e0bffe17 	ldw	r2,-8(fp)
8110f244:	10800003 	ldbu	r2,0(r2)
8110f248:	10803fcc 	andi	r2,r2,255
8110f24c:	100d883a 	mov	r6,r2
8110f250:	01604574 	movhi	r5,33045
8110f254:	296abf04 	addi	r5,r5,-21764
8110f258:	1809883a 	mov	r4,r3
8110f25c:	111f5fc0 	call	8111f5fc <fprintf>
				#endif

					break;
8110f260:	00002006 	br	8110f2e4 <vQCmdFeeRMAPinStandBy+0x3f0>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110f264:	d0a06117 	ldw	r2,-32380(gp)
8110f268:	100f883a 	mov	r7,r2
8110f26c:	01800604 	movi	r6,24
8110f270:	01400044 	movi	r5,1
8110f274:	01204574 	movhi	r4,33045
8110f278:	212ac604 	addi	r4,r4,-21736
8110f27c:	111fc980 	call	8111fc98 <fwrite>
				#endif

					pxNFeeP->xControl.bWatingSync = TRUE;
8110f280:	e0bffe17 	ldw	r2,-8(fp)
8110f284:	00c00044 	movi	r3,1
8110f288:	10c02815 	stw	r3,160(r2)
					pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f28c:	e0bffe17 	ldw	r2,-8(fp)
8110f290:	00c00284 	movi	r3,10
8110f294:	10c02c15 	stw	r3,176(r2)
					pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f298:	e0bffe17 	ldw	r2,-8(fp)
8110f29c:	00c00304 	movi	r3,12
8110f2a0:	10c02d15 	stw	r3,180(r2)

					break;
8110f2a4:	00000f06 	br	8110f2e4 <vQCmdFeeRMAPinStandBy+0x3f0>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp,"- Off-Mode not allowed.\n");
8110f2a8:	d0a06117 	ldw	r2,-32380(gp)
8110f2ac:	100f883a 	mov	r7,r2
8110f2b0:	01800604 	movi	r6,24
8110f2b4:	01400044 	movi	r5,1
8110f2b8:	01204574 	movhi	r4,33045
8110f2bc:	212acd04 	addi	r4,r4,-21708
8110f2c0:	111fc980 	call	8111fc98 <fwrite>
				#endif
					break;
8110f2c4:	00000706 	br	8110f2e4 <vQCmdFeeRMAPinStandBy+0x3f0>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp,"- mode not allowed yet ( %hhu )\n", ucValueMasked);
8110f2c8:	d0a06117 	ldw	r2,-32380(gp)
8110f2cc:	e1bffb17 	ldw	r6,-20(fp)
8110f2d0:	01604574 	movhi	r5,33045
8110f2d4:	296ad404 	addi	r5,r5,-21680
8110f2d8:	1009883a 	mov	r4,r2
8110f2dc:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
					break;
8110f2e0:	0001883a 	nop
			}

			break;
8110f2e4:	00002706 	br	8110f384 <vQCmdFeeRMAPinStandBy+0x490>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110f2e8:	e0bffa17 	ldw	r2,-24(fp)
8110f2ec:	1080010c 	andi	r2,r2,4
8110f2f0:	1004d0ba 	srli	r2,r2,2
8110f2f4:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110f2f8:	e0bffb17 	ldw	r2,-20(fp)
8110f2fc:	10002026 	beq	r2,zero,8110f380 <vQCmdFeeRMAPinStandBy+0x48c>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110f300:	d0a06117 	ldw	r2,-32380(gp)
8110f304:	100f883a 	mov	r7,r2
8110f308:	01800a04 	movi	r6,40
8110f30c:	01400044 	movi	r5,1
8110f310:	01204574 	movhi	r4,33045
8110f314:	212add04 	addi	r4,r4,-21644
8110f318:	111fc980 	call	8111fc98 <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110f31c:	e0bffe17 	ldw	r2,-8(fp)
8110f320:	10804304 	addi	r2,r2,268
8110f324:	1009883a 	mov	r4,r2
8110f328:	11080440 	call	81108044 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110f32c:	e0bffe17 	ldw	r2,-8(fp)
8110f330:	10c06217 	ldw	r3,392(r2)
8110f334:	00bffec4 	movi	r2,-5
8110f338:	1886703a 	and	r3,r3,r2
8110f33c:	e0bffe17 	ldw	r2,-8(fp)
8110f340:	10c06215 	stw	r3,392(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110f344:	e0bffe17 	ldw	r2,-8(fp)
8110f348:	10804304 	addi	r2,r2,268
8110f34c:	1009883a 	mov	r4,r2
8110f350:	1107d580 	call	81107d58 <bRmapSetMemConfigArea>
			}

			break;
8110f354:	00000a06 	br	8110f380 <vQCmdFeeRMAPinStandBy+0x48c>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110f358:	d0a06117 	ldw	r2,-32380(gp)
8110f35c:	e0fff903 	ldbu	r3,-28(fp)
8110f360:	180d883a 	mov	r6,r3
8110f364:	01604574 	movhi	r5,33045
8110f368:	296ae804 	addi	r5,r5,-21600
8110f36c:	1009883a 	mov	r4,r2
8110f370:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
			break;
8110f374:	00000306 	br	8110f384 <vQCmdFeeRMAPinStandBy+0x490>
				fprintf(fp,"- Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110f378:	0001883a 	nop
8110f37c:	00000106 	br	8110f384 <vQCmdFeeRMAPinStandBy+0x490>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110f380:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110f384:	0001883a 	nop
8110f388:	e037883a 	mov	sp,fp
8110f38c:	dfc00117 	ldw	ra,4(sp)
8110f390:	df000017 	ldw	fp,0(sp)
8110f394:	dec00204 	addi	sp,sp,8
8110f398:	f800283a 	ret

8110f39c <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ) {
8110f39c:	defff904 	addi	sp,sp,-28
8110f3a0:	de00012e 	bgeu	sp,et,8110f3a8 <vQCmdFeeRMAPinFullPattern+0xc>
8110f3a4:	003b68fa 	trap	3
8110f3a8:	dfc00615 	stw	ra,24(sp)
8110f3ac:	df000515 	stw	fp,20(sp)
8110f3b0:	df000504 	addi	fp,sp,20
8110f3b4:	e13ffe15 	stw	r4,-8(fp)
8110f3b8:	e17fff15 	stw	r5,-4(fp)
	INT8U ucADDRReg;
	INT8U ucValueReg;
	INT32U ucValueMasked;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (FullPattern)\n", pxNFeeP->ucId);
8110f3bc:	d0e06117 	ldw	r3,-32380(gp)
8110f3c0:	e0bffe17 	ldw	r2,-8(fp)
8110f3c4:	10800003 	ldbu	r2,0(r2)
8110f3c8:	10803fcc 	andi	r2,r2,255
8110f3cc:	100d883a 	mov	r6,r2
8110f3d0:	01604574 	movhi	r5,33045
8110f3d4:	296af104 	addi	r5,r5,-21564
8110f3d8:	1809883a 	mov	r4,r3
8110f3dc:	111f5fc0 	call	8111f5fc <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110f3e0:	e0bfff17 	ldw	r2,-4(fp)
8110f3e4:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110f3e8:	e0bffd43 	ldbu	r2,-11(fp)
8110f3ec:	e0bffb05 	stb	r2,-20(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110f3f0:	e0bffe17 	ldw	r2,-8(fp)
8110f3f4:	10804317 	ldw	r2,268(r2)
8110f3f8:	e0fffb03 	ldbu	r3,-20(fp)
8110f3fc:	180b883a 	mov	r5,r3
8110f400:	1009883a 	mov	r4,r2
8110f404:	11099bc0 	call	811099bc <uliRmapReadReg>
8110f408:	e0bffb45 	stb	r2,-19(fp)


	switch (ucADDRReg) {
8110f40c:	e0bffb03 	ldbu	r2,-20(fp)
8110f410:	10c01320 	cmpeqi	r3,r2,76
8110f414:	18000f1e 	bne	r3,zero,8110f454 <vQCmdFeeRMAPinFullPattern+0xb8>
8110f418:	10c01348 	cmpgei	r3,r2,77
8110f41c:	1800031e 	bne	r3,zero,8110f42c <vQCmdFeeRMAPinFullPattern+0x90>
8110f420:	10801010 	cmplti	r2,r2,64
8110f424:	1000681e 	bne	r2,zero,8110f5c8 <vQCmdFeeRMAPinFullPattern+0x22c>
8110f428:	00000306 	br	8110f438 <vQCmdFeeRMAPinFullPattern+0x9c>
8110f42c:	10801360 	cmpeqi	r2,r2,77
8110f430:	10004b1e 	bne	r2,zero,8110f560 <vQCmdFeeRMAPinFullPattern+0x1c4>
8110f434:	00006406 	br	8110f5c8 <vQCmdFeeRMAPinFullPattern+0x22c>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
8110f438:	d0a06117 	ldw	r2,-32380(gp)
8110f43c:	e1bffc17 	ldw	r6,-16(fp)
8110f440:	01604574 	movhi	r5,33045
8110f444:	296ae804 	addi	r5,r5,-21600
8110f448:	1009883a 	mov	r4,r2
8110f44c:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
				break;
8110f450:	00006606 	br	8110f5ec <vQCmdFeeRMAPinFullPattern+0x250>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110f454:	e0bffb43 	ldbu	r2,-19(fp)
8110f458:	1004d13a 	srli	r2,r2,4
8110f45c:	10803fcc 	andi	r2,r2,255
8110f460:	e0bffc15 	stw	r2,-16(fp)

			switch (ucValueMasked) {
8110f464:	e0bffc17 	ldw	r2,-16(fp)
8110f468:	10c000a0 	cmpeqi	r3,r2,2
8110f46c:	1800221e 	bne	r3,zero,8110f4f8 <vQCmdFeeRMAPinFullPattern+0x15c>
8110f470:	10c001a0 	cmpeqi	r3,r2,6
8110f474:	18002a1e 	bne	r3,zero,8110f520 <vQCmdFeeRMAPinFullPattern+0x184>
8110f478:	1000311e 	bne	r2,zero,8110f540 <vQCmdFeeRMAPinFullPattern+0x1a4>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8110f47c:	d0a06117 	ldw	r2,-32380(gp)
8110f480:	100f883a 	mov	r7,r2
8110f484:	01800384 	movi	r6,14
8110f488:	01400044 	movi	r5,1
8110f48c:	01204574 	movhi	r4,33045
8110f490:	212afe04 	addi	r4,r4,-21512
8110f494:	111fc980 	call	8111fc98 <fwrite>
				#endif

					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
8110f498:	e0bffe17 	ldw	r2,-8(fp)
8110f49c:	10802c17 	ldw	r2,176(r2)
8110f4a0:	10800298 	cmpnei	r2,r2,10
8110f4a4:	10000a1e 	bne	r2,zero,8110f4d0 <vQCmdFeeRMAPinFullPattern+0x134>
						pxNFeeP->xControl.bWatingSync = TRUE;
8110f4a8:	e0bffe17 	ldw	r2,-8(fp)
8110f4ac:	00c00044 	movi	r3,1
8110f4b0:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110f4b4:	e0bffe17 	ldw	r2,-8(fp)
8110f4b8:	00c00304 	movi	r3,12
8110f4bc:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f4c0:	e0bffe17 	ldw	r2,-8(fp)
8110f4c4:	00c00184 	movi	r3,6
8110f4c8:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8110f4cc:	00002306 	br	8110f55c <vQCmdFeeRMAPinFullPattern+0x1c0>
					if ( pxNFeeP->xControl.eMode == sNextPatternIteration ) {
						pxNFeeP->xControl.bWatingSync = TRUE;
						pxNFeeP->xControl.eMode = sFeeWaitingSync;
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
					} else {
						pxNFeeP->xControl.bWatingSync = TRUE;
8110f4d0:	e0bffe17 	ldw	r2,-8(fp)
8110f4d4:	00c00044 	movi	r3,1
8110f4d8:	10c02815 	stw	r3,160(r2)
						pxNFeeP->xControl.eMode = sFeeTestFullPattern;
8110f4dc:	e0bffe17 	ldw	r2,-8(fp)
8110f4e0:	00c00104 	movi	r3,4
8110f4e4:	10c02c15 	stw	r3,176(r2)
						pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f4e8:	e0bffe17 	ldw	r2,-8(fp)
8110f4ec:	00c00184 	movi	r3,6
8110f4f0:	10c02d15 	stw	r3,180(r2)

					//pxNFeeP->xControl.bWatingSync = TRUE;
					//pxNFeeP->xControl.eMode = sFeeTestFullPattern;
					//pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */

					break;
8110f4f4:	00001906 	br	8110f55c <vQCmdFeeRMAPinFullPattern+0x1c0>
				case 2: /* PAttern Full image */
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110f4f8:	d0e06117 	ldw	r3,-32380(gp)
8110f4fc:	e0bffe17 	ldw	r2,-8(fp)
8110f500:	10800003 	ldbu	r2,0(r2)
8110f504:	10803fcc 	andi	r2,r2,255
8110f508:	100d883a 	mov	r6,r2
8110f50c:	01604574 	movhi	r5,33045
8110f510:	296a7104 	addi	r5,r5,-22076
8110f514:	1809883a 	mov	r4,r3
8110f518:	111f5fc0 	call	8111f5fc <fprintf>
					#endif

					break;
8110f51c:	00000f06 	br	8110f55c <vQCmdFeeRMAPinFullPattern+0x1c0>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8110f520:	d0a06117 	ldw	r2,-32380(gp)
8110f524:	100f883a 	mov	r7,r2
8110f528:	018005c4 	movi	r6,23
8110f52c:	01400044 	movi	r5,1
8110f530:	01204574 	movhi	r4,33045
8110f534:	212b0204 	addi	r4,r4,-21496
8110f538:	111fc980 	call	8111fc98 <fwrite>
				#endif
					break;
8110f53c:	00000706 	br	8110f55c <vQCmdFeeRMAPinFullPattern+0x1c0>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110f540:	d0a06117 	ldw	r2,-32380(gp)
8110f544:	e1bffc17 	ldw	r6,-16(fp)
8110f548:	01604574 	movhi	r5,33045
8110f54c:	296b0804 	addi	r5,r5,-21472
8110f550:	1009883a 	mov	r4,r2
8110f554:	111f5fc0 	call	8111f5fc <fprintf>
					#endif
					break;
8110f558:	0001883a 	nop
			}

			break;
8110f55c:	00002306 	br	8110f5ec <vQCmdFeeRMAPinFullPattern+0x250>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110f560:	e0bffb43 	ldbu	r2,-19(fp)
8110f564:	1080010c 	andi	r2,r2,4
8110f568:	10803fcc 	andi	r2,r2,255
8110f56c:	1004d0ba 	srli	r2,r2,2
8110f570:	10803fcc 	andi	r2,r2,255
8110f574:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8110f578:	e0bffc17 	ldw	r2,-16(fp)
8110f57c:	10001a26 	beq	r2,zero,8110f5e8 <vQCmdFeeRMAPinFullPattern+0x24c>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8110f580:	e0bffe17 	ldw	r2,-8(fp)
8110f584:	10802d17 	ldw	r2,180(r2)
8110f588:	10800198 	cmpnei	r2,r2,6
8110f58c:	1000161e 	bne	r2,zero,8110f5e8 <vQCmdFeeRMAPinFullPattern+0x24c>
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f590:	e0bffe17 	ldw	r2,-8(fp)
8110f594:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f598:	e0bffe17 	ldw	r2,-8(fp)
8110f59c:	10c02d17 	ldw	r3,180(r2)
8110f5a0:	e0bffe17 	ldw	r2,-8(fp)
8110f5a4:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8110f5a8:	d0a06117 	ldw	r2,-32380(gp)
8110f5ac:	100f883a 	mov	r7,r2
8110f5b0:	01800404 	movi	r6,16
8110f5b4:	01400044 	movi	r5,1
8110f5b8:	01204574 	movhi	r4,33045
8110f5bc:	212b1004 	addi	r4,r4,-21440
8110f5c0:	111fc980 	call	8111fc98 <fwrite>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8110f5c4:	00000806 	br	8110f5e8 <vQCmdFeeRMAPinFullPattern+0x24c>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110f5c8:	d0a06117 	ldw	r2,-32380(gp)
8110f5cc:	e0fffb03 	ldbu	r3,-20(fp)
8110f5d0:	180d883a 	mov	r6,r3
8110f5d4:	01604574 	movhi	r5,33045
8110f5d8:	296ae804 	addi	r5,r5,-21600
8110f5dc:	1009883a 	mov	r4,r2
8110f5e0:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
			break;
8110f5e4:	00000106 	br	8110f5ec <vQCmdFeeRMAPinFullPattern+0x250>
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);

			}

			break;
8110f5e8:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110f5ec:	0001883a 	nop
8110f5f0:	e037883a 	mov	sp,fp
8110f5f4:	dfc00117 	ldw	ra,4(sp)
8110f5f8:	df000017 	ldw	fp,0(sp)
8110f5fc:	dec00204 	addi	sp,sp,8
8110f600:	f800283a 	ret

8110f604 <vQCmdFeeRMAPWaitingSync>:


void vQCmdFeeRMAPWaitingSync( TNFee *pxNFeeP, unsigned int cmd ){
8110f604:	defff904 	addi	sp,sp,-28
8110f608:	de00012e 	bgeu	sp,et,8110f610 <vQCmdFeeRMAPWaitingSync+0xc>
8110f60c:	003b68fa 	trap	3
8110f610:	dfc00615 	stw	ra,24(sp)
8110f614:	df000515 	stw	fp,20(sp)
8110f618:	df000504 	addi	fp,sp,20
8110f61c:	e13ffe15 	stw	r4,-8(fp)
8110f620:	e17fff15 	stw	r5,-4(fp)
	INT8U ucADDRReg;
	INT8U ucValueReg;
	INT32U ucValueMasked;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received (WaitingSync)\n", pxNFeeP->ucId);
8110f624:	d0e06117 	ldw	r3,-32380(gp)
8110f628:	e0bffe17 	ldw	r2,-8(fp)
8110f62c:	10800003 	ldbu	r2,0(r2)
8110f630:	10803fcc 	andi	r2,r2,255
8110f634:	100d883a 	mov	r6,r2
8110f638:	01604574 	movhi	r5,33045
8110f63c:	296b1504 	addi	r5,r5,-21420
8110f640:	1809883a 	mov	r4,r3
8110f644:	111f5fc0 	call	8111f5fc <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110f648:	e0bfff17 	ldw	r2,-4(fp)
8110f64c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110f650:	e0bffd43 	ldbu	r2,-11(fp)
8110f654:	e0bffb05 	stb	r2,-20(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110f658:	e0bffe17 	ldw	r2,-8(fp)
8110f65c:	10804317 	ldw	r2,268(r2)
8110f660:	e0fffb03 	ldbu	r3,-20(fp)
8110f664:	180b883a 	mov	r5,r3
8110f668:	1009883a 	mov	r4,r2
8110f66c:	11099bc0 	call	811099bc <uliRmapReadReg>
8110f670:	e0bffb45 	stb	r2,-19(fp)


	switch (ucADDRReg) {
8110f674:	e0bffb03 	ldbu	r2,-20(fp)
8110f678:	10c01348 	cmpgei	r3,r2,77
8110f67c:	1800051e 	bne	r3,zero,8110f694 <vQCmdFeeRMAPWaitingSync+0x90>
8110f680:	10c01008 	cmpgei	r3,r2,64
8110f684:	1800061e 	bne	r3,zero,8110f6a0 <vQCmdFeeRMAPWaitingSync+0x9c>
8110f688:	108000a0 	cmpeqi	r2,r2,2
8110f68c:	1000391e 	bne	r2,zero,8110f774 <vQCmdFeeRMAPWaitingSync+0x170>
8110f690:	00006506 	br	8110f828 <vQCmdFeeRMAPWaitingSync+0x224>
8110f694:	10801360 	cmpeqi	r2,r2,77
8110f698:	1000491e 	bne	r2,zero,8110f7c0 <vQCmdFeeRMAPWaitingSync+0x1bc>
8110f69c:	00006206 	br	8110f828 <vQCmdFeeRMAPWaitingSync+0x224>
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
		case 0x0000004C://0x00000038:operation_mode_config

		ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110f6a0:	e0bffb43 	ldbu	r2,-19(fp)
8110f6a4:	1004d13a 	srli	r2,r2,4
8110f6a8:	10803fcc 	andi	r2,r2,255
8110f6ac:	e0bffc15 	stw	r2,-16(fp)

		switch (ucValueMasked) {
8110f6b0:	e0bffc17 	ldw	r2,-16(fp)
8110f6b4:	10c000a0 	cmpeqi	r3,r2,2
8110f6b8:	1800141e 	bne	r3,zero,8110f70c <vQCmdFeeRMAPWaitingSync+0x108>
8110f6bc:	10c001a0 	cmpeqi	r3,r2,6
8110f6c0:	18001c1e 	bne	r3,zero,8110f734 <vQCmdFeeRMAPWaitingSync+0x130>
8110f6c4:	1000231e 	bne	r2,zero,8110f754 <vQCmdFeeRMAPWaitingSync+0x150>
			case 0: /* Standby */
			#ifdef DEBUG_ON
				fprintf(fp,"- to Stand-By\n");
8110f6c8:	d0a06117 	ldw	r2,-32380(gp)
8110f6cc:	100f883a 	mov	r7,r2
8110f6d0:	01800384 	movi	r6,14
8110f6d4:	01400044 	movi	r5,1
8110f6d8:	01204574 	movhi	r4,33045
8110f6dc:	212afe04 	addi	r4,r4,-21512
8110f6e0:	111fc980 	call	8111fc98 <fwrite>
			#endif

				pxNFeeP->xControl.bWatingSync = TRUE;
8110f6e4:	e0bffe17 	ldw	r2,-8(fp)
8110f6e8:	00c00044 	movi	r3,1
8110f6ec:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110f6f0:	e0bffe17 	ldw	r2,-8(fp)
8110f6f4:	00c00304 	movi	r3,12
8110f6f8:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110f6fc:	e0bffe17 	ldw	r2,-8(fp)
8110f700:	00c00184 	movi	r3,6
8110f704:	10c02d15 	stw	r3,180(r2)


				break;
8110f708:	00001906 	br	8110f770 <vQCmdFeeRMAPWaitingSync+0x16c>
			case 2: /* PAttern Full image */

				pxNFeeP->xControl.bWatingSync = TRUE;
8110f70c:	e0bffe17 	ldw	r2,-8(fp)
8110f710:	00c00044 	movi	r3,1
8110f714:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync; /*sSIMTestFullPattern*/
8110f718:	e0bffe17 	ldw	r2,-8(fp)
8110f71c:	00c00304 	movi	r3,12
8110f720:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sNextPatternIteration;
8110f724:	e0bffe17 	ldw	r2,-8(fp)
8110f728:	00c00284 	movi	r3,10
8110f72c:	10c02d15 	stw	r3,180(r2)

				break;
8110f730:	00000f06 	br	8110f770 <vQCmdFeeRMAPWaitingSync+0x16c>
			case 6:
			#ifdef DEBUG_ON
				fprintf(fp," Off-Mode not allowed.\n");
8110f734:	d0a06117 	ldw	r2,-32380(gp)
8110f738:	100f883a 	mov	r7,r2
8110f73c:	018005c4 	movi	r6,23
8110f740:	01400044 	movi	r5,1
8110f744:	01204574 	movhi	r4,33045
8110f748:	212b0204 	addi	r4,r4,-21496
8110f74c:	111fc980 	call	8111fc98 <fwrite>
			#endif
				break;
8110f750:	00000706 	br	8110f770 <vQCmdFeeRMAPWaitingSync+0x16c>
			case 3:
			case 4:
			case 5:
			default:
				#ifdef DEBUG_ON
					fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110f754:	d0a06117 	ldw	r2,-32380(gp)
8110f758:	e1bffc17 	ldw	r6,-16(fp)
8110f75c:	01604574 	movhi	r5,33045
8110f760:	296b0804 	addi	r5,r5,-21472
8110f764:	1009883a 	mov	r4,r2
8110f768:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
				break;
8110f76c:	0001883a 	nop
		}

			break;
8110f770:	00003606 	br	8110f84c <vQCmdFeeRMAPWaitingSync+0x248>
		case 2: /* PAttern Full image */
			#ifdef DEBUG_ON
				fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110f774:	d0e06117 	ldw	r3,-32380(gp)
8110f778:	e0bffe17 	ldw	r2,-8(fp)
8110f77c:	10800003 	ldbu	r2,0(r2)
8110f780:	10803fcc 	andi	r2,r2,255
8110f784:	100d883a 	mov	r6,r2
8110f788:	01604574 	movhi	r5,33045
8110f78c:	296a7104 	addi	r5,r5,-22076
8110f790:	1809883a 	mov	r4,r3
8110f794:	111f5fc0 	call	8111f5fc <fprintf>
			#endif

			pxNFeeP->xControl.bWatingSync = TRUE;
8110f798:	e0bffe17 	ldw	r2,-8(fp)
8110f79c:	00c00044 	movi	r3,1
8110f7a0:	10c02815 	stw	r3,160(r2)
			pxNFeeP->xControl.eMode = sNextPatternIteration; /*sSIMTestFullPattern*/
8110f7a4:	e0bffe17 	ldw	r2,-8(fp)
8110f7a8:	00c00284 	movi	r3,10
8110f7ac:	10c02c15 	stw	r3,176(r2)
			pxNFeeP->xControl.eNextMode = sFeeWaitingSync;
8110f7b0:	e0bffe17 	ldw	r2,-8(fp)
8110f7b4:	00c00304 	movi	r3,12
8110f7b8:	10c02d15 	stw	r3,180(r2)

			break;
8110f7bc:	00002306 	br	8110f84c <vQCmdFeeRMAPWaitingSync+0x248>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110f7c0:	e0bffb43 	ldbu	r2,-19(fp)
8110f7c4:	1080010c 	andi	r2,r2,4
8110f7c8:	10803fcc 	andi	r2,r2,255
8110f7cc:	1004d0ba 	srli	r2,r2,2
8110f7d0:	10803fcc 	andi	r2,r2,255
8110f7d4:	e0bffc15 	stw	r2,-16(fp)

			if ( ucValueMasked ) {
8110f7d8:	e0bffc17 	ldw	r2,-16(fp)
8110f7dc:	10001a26 	beq	r2,zero,8110f848 <vQCmdFeeRMAPWaitingSync+0x244>

				if ( pxNFeeP->xControl.eNextMode == sToFeeStandBy ) {
8110f7e0:	e0bffe17 	ldw	r2,-8(fp)
8110f7e4:	10802d17 	ldw	r2,180(r2)
8110f7e8:	10800198 	cmpnei	r2,r2,6
8110f7ec:	1000161e 	bne	r2,zero,8110f848 <vQCmdFeeRMAPWaitingSync+0x244>
					pxNFeeP->xControl.bWatingSync = FALSE;
8110f7f0:	e0bffe17 	ldw	r2,-8(fp)
8110f7f4:	10002815 	stw	zero,160(r2)
					pxNFeeP->xControl.eMode = pxNFeeP->xControl.eNextMode;
8110f7f8:	e0bffe17 	ldw	r2,-8(fp)
8110f7fc:	10c02d17 	ldw	r3,180(r2)
8110f800:	e0bffe17 	ldw	r2,-8(fp)
8110f804:	10c02c15 	stw	r3,176(r2)
					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8110f808:	d0a06117 	ldw	r2,-32380(gp)
8110f80c:	100f883a 	mov	r7,r2
8110f810:	01800404 	movi	r6,16
8110f814:	01400044 	movi	r5,1
8110f818:	01204574 	movhi	r4,33045
8110f81c:	212b1004 	addi	r4,r4,-21440
8110f820:	111fc980 	call	8111fc98 <fwrite>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110f824:	00000806 	br	8110f848 <vQCmdFeeRMAPWaitingSync+0x244>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110f828:	d0a06117 	ldw	r2,-32380(gp)
8110f82c:	e0fffb03 	ldbu	r3,-20(fp)
8110f830:	180d883a 	mov	r6,r3
8110f834:	01604574 	movhi	r5,33045
8110f838:	296ae804 	addi	r5,r5,-21600
8110f83c:	1009883a 	mov	r4,r2
8110f840:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
			break;
8110f844:	00000106 	br	8110f84c <vQCmdFeeRMAPWaitingSync+0x248>
//				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
//				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
//				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110f848:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110f84c:	0001883a 	nop
8110f850:	e037883a 	mov	sp,fp
8110f854:	dfc00117 	ldw	ra,4(sp)
8110f858:	df000017 	ldw	fp,0(sp)
8110f85c:	dec00204 	addi	sp,sp,8
8110f860:	f800283a 	ret

8110f864 <bDisableRmapIRQ>:


bool bDisableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8110f864:	defffc04 	addi	sp,sp,-16
8110f868:	de00012e 	bgeu	sp,et,8110f870 <bDisableRmapIRQ+0xc>
8110f86c:	003b68fa 	trap	3
8110f870:	dfc00315 	stw	ra,12(sp)
8110f874:	df000215 	stw	fp,8(sp)
8110f878:	df000204 	addi	fp,sp,8
8110f87c:	e13ffe15 	stw	r4,-8(fp)
8110f880:	2805883a 	mov	r2,r5
8110f884:	e0bfff05 	stb	r2,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
8110f888:	e13ffe17 	ldw	r4,-8(fp)
8110f88c:	11078240 	call	81107824 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110f890:	e0bffe17 	ldw	r2,-8(fp)
8110f894:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110f898:	e13ffe17 	ldw	r4,-8(fp)
8110f89c:	110777c0 	call	8110777c <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110f8a0:	00800044 	movi	r2,1
}
8110f8a4:	e037883a 	mov	sp,fp
8110f8a8:	dfc00117 	ldw	ra,4(sp)
8110f8ac:	df000017 	ldw	fp,0(sp)
8110f8b0:	dec00204 	addi	sp,sp,8
8110f8b4:	f800283a 	ret

8110f8b8 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh, unsigned char ucId ) {
8110f8b8:	defffc04 	addi	sp,sp,-16
8110f8bc:	de00012e 	bgeu	sp,et,8110f8c4 <bEnableRmapIRQ+0xc>
8110f8c0:	003b68fa 	trap	3
8110f8c4:	dfc00315 	stw	ra,12(sp)
8110f8c8:	df000215 	stw	fp,8(sp)
8110f8cc:	df000204 	addi	fp,sp,8
8110f8d0:	e13ffe15 	stw	r4,-8(fp)
8110f8d4:	2805883a 	mov	r2,r5
8110f8d8:	e0bfff05 	stb	r2,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	//bRmapGetMemConfigArea(&xRmap[ucId]);

	bRmapGetIrqControl(pxRmapCh);
8110f8dc:	e13ffe17 	ldw	r4,-8(fp)
8110f8e0:	11078240 	call	81107824 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110f8e4:	e0bffe17 	ldw	r2,-8(fp)
8110f8e8:	00c00044 	movi	r3,1
8110f8ec:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110f8f0:	e13ffe17 	ldw	r4,-8(fp)
8110f8f4:	110777c0 	call	8110777c <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110f8f8:	00800044 	movi	r2,1
}
8110f8fc:	e037883a 	mov	sp,fp
8110f900:	dfc00117 	ldw	ra,4(sp)
8110f904:	df000017 	ldw	fp,0(sp)
8110f908:	dec00204 	addi	sp,sp,8
8110f90c:	f800283a 	ret

8110f910 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110f910:	defffd04 	addi	sp,sp,-12
8110f914:	de00012e 	bgeu	sp,et,8110f91c <bDisableSPWChannel+0xc>
8110f918:	003b68fa 	trap	3
8110f91c:	dfc00215 	stw	ra,8(sp)
8110f920:	df000115 	stw	fp,4(sp)
8110f924:	df000104 	addi	fp,sp,4
8110f928:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110f92c:	e13fff17 	ldw	r4,-4(fp)
8110f930:	1109da80 	call	81109da8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110f934:	e0bfff17 	ldw	r2,-4(fp)
8110f938:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110f93c:	e0bfff17 	ldw	r2,-4(fp)
8110f940:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110f944:	e0bfff17 	ldw	r2,-4(fp)
8110f948:	00c00044 	movi	r3,1
8110f94c:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110f950:	e13fff17 	ldw	r4,-4(fp)
8110f954:	1109c740 	call	81109c74 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110f958:	00800044 	movi	r2,1
}
8110f95c:	e037883a 	mov	sp,fp
8110f960:	dfc00117 	ldw	ra,4(sp)
8110f964:	df000017 	ldw	fp,0(sp)
8110f968:	dec00204 	addi	sp,sp,8
8110f96c:	f800283a 	ret

8110f970 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110f970:	defffd04 	addi	sp,sp,-12
8110f974:	de00012e 	bgeu	sp,et,8110f97c <bEnableSPWChannel+0xc>
8110f978:	003b68fa 	trap	3
8110f97c:	dfc00215 	stw	ra,8(sp)
8110f980:	df000115 	stw	fp,4(sp)
8110f984:	df000104 	addi	fp,sp,4
8110f988:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110f98c:	e13fff17 	ldw	r4,-4(fp)
8110f990:	1109da80 	call	81109da8 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110f994:	e0bfff17 	ldw	r2,-4(fp)
8110f998:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110f99c:	e0bfff17 	ldw	r2,-4(fp)
8110f9a0:	00c00044 	movi	r3,1
8110f9a4:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110f9a8:	e0bfff17 	ldw	r2,-4(fp)
8110f9ac:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110f9b0:	e13fff17 	ldw	r4,-4(fp)
8110f9b4:	1109c740 	call	81109c74 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110f9b8:	00800044 	movi	r2,1
}
8110f9bc:	e037883a 	mov	sp,fp
8110f9c0:	dfc00117 	ldw	ra,4(sp)
8110f9c4:	df000017 	ldw	fp,0(sp)
8110f9c8:	dec00204 	addi	sp,sp,8
8110f9cc:	f800283a 	ret

8110f9d0 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110f9d0:	defffd04 	addi	sp,sp,-12
8110f9d4:	de00012e 	bgeu	sp,et,8110f9dc <bEnableDbBuffer+0xc>
8110f9d8:	003b68fa 	trap	3
8110f9dc:	dfc00215 	stw	ra,8(sp)
8110f9e0:	df000115 	stw	fp,4(sp)
8110f9e4:	df000104 	addi	fp,sp,4
8110f9e8:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110f9ec:	e13fff17 	ldw	r4,-4(fp)
8110f9f0:	110696c0 	call	8110696c <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110f9f4:	e13fff17 	ldw	r4,-4(fp)
8110f9f8:	110685c0 	call	8110685c <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
8110f9fc:	e13fff17 	ldw	r4,-4(fp)
8110fa00:	11067d40 	call	811067d4 <bFeebGetWindowing>
	pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
8110fa04:	e0bfff17 	ldw	r2,-4(fp)
8110fa08:	00c00044 	movi	r3,1
8110fa0c:	10c00115 	stw	r3,4(r2)
	bFeebSetWindowing(pxFeebCh);
8110fa10:	e13fff17 	ldw	r4,-4(fp)
8110fa14:	110672c0 	call	8110672c <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110fa18:	e13fff17 	ldw	r4,-4(fp)
8110fa1c:	110617c0 	call	8110617c <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110fa20:	e0bfff17 	ldw	r2,-4(fp)
8110fa24:	00c00044 	movi	r3,1
8110fa28:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110fa2c:	e0bfff17 	ldw	r2,-4(fp)
8110fa30:	00c00044 	movi	r3,1
8110fa34:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110fa38:	e13fff17 	ldw	r4,-4(fp)
8110fa3c:	11060a80 	call	811060a8 <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110fa40:	00800044 	movi	r2,1
}
8110fa44:	e037883a 	mov	sp,fp
8110fa48:	dfc00117 	ldw	ra,4(sp)
8110fa4c:	df000017 	ldw	fp,0(sp)
8110fa50:	dec00204 	addi	sp,sp,8
8110fa54:	f800283a 	ret

8110fa58 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110fa58:	defffd04 	addi	sp,sp,-12
8110fa5c:	de00012e 	bgeu	sp,et,8110fa64 <bDisAndClrDbBuffer+0xc>
8110fa60:	003b68fa 	trap	3
8110fa64:	dfc00215 	stw	ra,8(sp)
8110fa68:	df000115 	stw	fp,4(sp)
8110fa6c:	df000104 	addi	fp,sp,4
8110fa70:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110fa74:	e13fff17 	ldw	r4,-4(fp)
8110fa78:	110617c0 	call	8110617c <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110fa7c:	e0bfff17 	ldw	r2,-4(fp)
8110fa80:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110fa84:	e0bfff17 	ldw	r2,-4(fp)
8110fa88:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110fa8c:	e13fff17 	ldw	r4,-4(fp)
8110fa90:	11060a80 	call	811060a8 <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110fa94:	e13fff17 	ldw	r4,-4(fp)
8110fa98:	11068e40 	call	811068e4 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110fa9c:	e13fff17 	ldw	r4,-4(fp)
8110faa0:	110696c0 	call	8110696c <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
8110faa4:	00800044 	movi	r2,1
}
8110faa8:	e037883a 	mov	sp,fp
8110faac:	dfc00117 	ldw	ra,4(sp)
8110fab0:	df000017 	ldw	fp,0(sp)
8110fab4:	dec00204 	addi	sp,sp,8
8110fab8:	f800283a 	ret

8110fabc <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110fabc:	defff804 	addi	sp,sp,-32
8110fac0:	de00012e 	bgeu	sp,et,8110fac8 <bSendRequestNFeeCtrl+0xc>
8110fac4:	003b68fa 	trap	3
8110fac8:	dfc00715 	stw	ra,28(sp)
8110facc:	df000615 	stw	fp,24(sp)
8110fad0:	df000604 	addi	fp,sp,24
8110fad4:	2807883a 	mov	r3,r5
8110fad8:	3005883a 	mov	r2,r6
8110fadc:	e13ffd05 	stb	r4,-12(fp)
8110fae0:	e0fffe05 	stb	r3,-8(fp)
8110fae4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110fae8:	00800404 	movi	r2,16
8110faec:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110faf0:	e0bffd03 	ldbu	r2,-12(fp)
8110faf4:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110faf8:	e0bffe03 	ldbu	r2,-8(fp)
8110fafc:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110fb00:	e0bfff03 	ldbu	r2,-4(fp)
8110fb04:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110fb08:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110fb0c:	d0a05c17 	ldw	r2,-32400(gp)
8110fb10:	e0fffc17 	ldw	r3,-16(fp)
8110fb14:	180b883a 	mov	r5,r3
8110fb18:	1009883a 	mov	r4,r2
8110fb1c:	113c0280 	call	8113c028 <OSQPost>
8110fb20:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110fb24:	e0bffb03 	ldbu	r2,-20(fp)
8110fb28:	10000526 	beq	r2,zero,8110fb40 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110fb2c:	e0bfff03 	ldbu	r2,-4(fp)
8110fb30:	1009883a 	mov	r4,r2
8110fb34:	111b5000 	call	8111b500 <vFailRequestDMA>
		bSuccesL = FALSE;
8110fb38:	e03ffa15 	stw	zero,-24(fp)
8110fb3c:	00000206 	br	8110fb48 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110fb40:	00800044 	movi	r2,1
8110fb44:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110fb48:	e0bffa17 	ldw	r2,-24(fp)
}
8110fb4c:	e037883a 	mov	sp,fp
8110fb50:	dfc00117 	ldw	ra,4(sp)
8110fb54:	df000017 	ldw	fp,0(sp)
8110fb58:	dec00204 	addi	sp,sp,8
8110fb5c:	f800283a 	ret

8110fb60 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110fb60:	defff804 	addi	sp,sp,-32
8110fb64:	de00012e 	bgeu	sp,et,8110fb6c <bSendGiveBackNFeeCtrl+0xc>
8110fb68:	003b68fa 	trap	3
8110fb6c:	dfc00715 	stw	ra,28(sp)
8110fb70:	df000615 	stw	fp,24(sp)
8110fb74:	df000604 	addi	fp,sp,24
8110fb78:	2807883a 	mov	r3,r5
8110fb7c:	3005883a 	mov	r2,r6
8110fb80:	e13ffd05 	stb	r4,-12(fp)
8110fb84:	e0fffe05 	stb	r3,-8(fp)
8110fb88:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110fb8c:	00800404 	movi	r2,16
8110fb90:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110fb94:	e0bffd03 	ldbu	r2,-12(fp)
8110fb98:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110fb9c:	e0bffe03 	ldbu	r2,-8(fp)
8110fba0:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110fba4:	e0bfff03 	ldbu	r2,-4(fp)
8110fba8:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110fbac:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110fbb0:	d0a06f17 	ldw	r2,-32324(gp)
8110fbb4:	e0fffc17 	ldw	r3,-16(fp)
8110fbb8:	180b883a 	mov	r5,r3
8110fbbc:	1009883a 	mov	r4,r2
8110fbc0:	113c0280 	call	8113c028 <OSQPost>
8110fbc4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110fbc8:	e0bffb03 	ldbu	r2,-20(fp)
8110fbcc:	10000526 	beq	r2,zero,8110fbe4 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110fbd0:	e0bfff03 	ldbu	r2,-4(fp)
8110fbd4:	1009883a 	mov	r4,r2
8110fbd8:	111b5000 	call	8111b500 <vFailRequestDMA>
		bSuccesL = FALSE;
8110fbdc:	e03ffa15 	stw	zero,-24(fp)
8110fbe0:	00000206 	br	8110fbec <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110fbe4:	00800044 	movi	r2,1
8110fbe8:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110fbec:	e0bffa17 	ldw	r2,-24(fp)
}
8110fbf0:	e037883a 	mov	sp,fp
8110fbf4:	dfc00117 	ldw	ra,4(sp)
8110fbf8:	df000017 	ldw	fp,0(sp)
8110fbfc:	dec00204 	addi	sp,sp,8
8110fc00:	f800283a 	ret

8110fc04 <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110fc04:	defffa04 	addi	sp,sp,-24
8110fc08:	de00012e 	bgeu	sp,et,8110fc10 <vPrintConsoleNFee+0xc>
8110fc0c:	003b68fa 	trap	3
8110fc10:	dfc00515 	stw	ra,20(sp)
8110fc14:	df000415 	stw	fp,16(sp)
8110fc18:	df000404 	addi	fp,sp,16
8110fc1c:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110fc20:	e0bfff17 	ldw	r2,-4(fp)
8110fc24:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110fc28:	d0e06117 	ldw	r3,-32380(gp)
8110fc2c:	e0bffe17 	ldw	r2,-8(fp)
8110fc30:	10800003 	ldbu	r2,0(r2)
8110fc34:	10803fcc 	andi	r2,r2,255
8110fc38:	100d883a 	mov	r6,r2
8110fc3c:	01604574 	movhi	r5,33045
8110fc40:	296b2204 	addi	r5,r5,-21368
8110fc44:	1809883a 	mov	r4,r3
8110fc48:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
8110fc4c:	d0a06117 	ldw	r2,-32380(gp)
8110fc50:	100b883a 	mov	r5,r2
8110fc54:	01000284 	movi	r4,10
8110fc58:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110fc5c:	d0e06117 	ldw	r3,-32380(gp)
8110fc60:	e0bffe17 	ldw	r2,-8(fp)
8110fc64:	10800003 	ldbu	r2,0(r2)
8110fc68:	10803fcc 	andi	r2,r2,255
8110fc6c:	100d883a 	mov	r6,r2
8110fc70:	01604574 	movhi	r5,33045
8110fc74:	296b3704 	addi	r5,r5,-21284
8110fc78:	1809883a 	mov	r4,r3
8110fc7c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110fc80:	d0e06117 	ldw	r3,-32380(gp)
8110fc84:	e0bffe17 	ldw	r2,-8(fp)
8110fc88:	10802f0b 	ldhu	r2,188(r2)
8110fc8c:	10bfffcc 	andi	r2,r2,65535
8110fc90:	100d883a 	mov	r6,r2
8110fc94:	01604574 	movhi	r5,33045
8110fc98:	296b3d04 	addi	r5,r5,-21260
8110fc9c:	1809883a 	mov	r4,r3
8110fca0:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110fca4:	d0e06117 	ldw	r3,-32380(gp)
8110fca8:	e0bffe17 	ldw	r2,-8(fp)
8110fcac:	10802f8b 	ldhu	r2,190(r2)
8110fcb0:	10bfffcc 	andi	r2,r2,65535
8110fcb4:	100d883a 	mov	r6,r2
8110fcb8:	01604574 	movhi	r5,33045
8110fcbc:	296b4204 	addi	r5,r5,-21240
8110fcc0:	1809883a 	mov	r4,r3
8110fcc4:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110fcc8:	d0e06117 	ldw	r3,-32380(gp)
8110fccc:	e0bffe17 	ldw	r2,-8(fp)
8110fcd0:	1080300b 	ldhu	r2,192(r2)
8110fcd4:	10bfffcc 	andi	r2,r2,65535
8110fcd8:	100d883a 	mov	r6,r2
8110fcdc:	01604574 	movhi	r5,33045
8110fce0:	296b4804 	addi	r5,r5,-21216
8110fce4:	1809883a 	mov	r4,r3
8110fce8:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110fcec:	d0e06117 	ldw	r3,-32380(gp)
8110fcf0:	e0bffe17 	ldw	r2,-8(fp)
8110fcf4:	1080308b 	ldhu	r2,194(r2)
8110fcf8:	10bfffcc 	andi	r2,r2,65535
8110fcfc:	100d883a 	mov	r6,r2
8110fd00:	01604574 	movhi	r5,33045
8110fd04:	296b4c04 	addi	r5,r5,-21200
8110fd08:	1809883a 	mov	r4,r3
8110fd0c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110fd10:	d0e06117 	ldw	r3,-32380(gp)
8110fd14:	e0bffe17 	ldw	r2,-8(fp)
8110fd18:	1080310b 	ldhu	r2,196(r2)
8110fd1c:	10bfffcc 	andi	r2,r2,65535
8110fd20:	100d883a 	mov	r6,r2
8110fd24:	01604574 	movhi	r5,33045
8110fd28:	296b5204 	addi	r5,r5,-21176
8110fd2c:	1809883a 	mov	r4,r3
8110fd30:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
8110fd34:	d0a06117 	ldw	r2,-32380(gp)
8110fd38:	100b883a 	mov	r5,r2
8110fd3c:	01000284 	movi	r4,10
8110fd40:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110fd44:	d0e06117 	ldw	r3,-32380(gp)
8110fd48:	e0bffe17 	ldw	r2,-8(fp)
8110fd4c:	10800003 	ldbu	r2,0(r2)
8110fd50:	10803fcc 	andi	r2,r2,255
8110fd54:	100d883a 	mov	r6,r2
8110fd58:	01604574 	movhi	r5,33045
8110fd5c:	296b5704 	addi	r5,r5,-21156
8110fd60:	1809883a 	mov	r4,r3
8110fd64:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110fd68:	d0e06117 	ldw	r3,-32380(gp)
8110fd6c:	e0bffe17 	ldw	r2,-8(fp)
8110fd70:	10802c17 	ldw	r2,176(r2)
8110fd74:	100d883a 	mov	r6,r2
8110fd78:	01604574 	movhi	r5,33045
8110fd7c:	296b5d04 	addi	r5,r5,-21132
8110fd80:	1809883a 	mov	r4,r3
8110fd84:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110fd88:	d0e06117 	ldw	r3,-32380(gp)
8110fd8c:	e0bffe17 	ldw	r2,-8(fp)
8110fd90:	10802117 	ldw	r2,132(r2)
8110fd94:	100d883a 	mov	r6,r2
8110fd98:	01604574 	movhi	r5,33045
8110fd9c:	296b6304 	addi	r5,r5,-21108
8110fda0:	1809883a 	mov	r4,r3
8110fda4:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110fda8:	d0e06117 	ldw	r3,-32380(gp)
8110fdac:	e0bffe17 	ldw	r2,-8(fp)
8110fdb0:	10802317 	ldw	r2,140(r2)
8110fdb4:	100d883a 	mov	r6,r2
8110fdb8:	01604574 	movhi	r5,33045
8110fdbc:	296b6a04 	addi	r5,r5,-21080
8110fdc0:	1809883a 	mov	r4,r3
8110fdc4:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110fdc8:	d0e06117 	ldw	r3,-32380(gp)
8110fdcc:	e0bffe17 	ldw	r2,-8(fp)
8110fdd0:	10802417 	ldw	r2,144(r2)
8110fdd4:	100d883a 	mov	r6,r2
8110fdd8:	01604574 	movhi	r5,33045
8110fddc:	296b7104 	addi	r5,r5,-21052
8110fde0:	1809883a 	mov	r4,r3
8110fde4:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110fde8:	d0e06117 	ldw	r3,-32380(gp)
8110fdec:	e0bffe17 	ldw	r2,-8(fp)
8110fdf0:	10802517 	ldw	r2,148(r2)
8110fdf4:	100d883a 	mov	r6,r2
8110fdf8:	01604574 	movhi	r5,33045
8110fdfc:	296b7804 	addi	r5,r5,-21024
8110fe00:	1809883a 	mov	r4,r3
8110fe04:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110fe08:	d0e06117 	ldw	r3,-32380(gp)
8110fe0c:	e0bffe17 	ldw	r2,-8(fp)
8110fe10:	10802617 	ldw	r2,152(r2)
8110fe14:	100d883a 	mov	r6,r2
8110fe18:	01604574 	movhi	r5,33045
8110fe1c:	296b7f04 	addi	r5,r5,-20996
8110fe20:	1809883a 	mov	r4,r3
8110fe24:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110fe28:	d1206117 	ldw	r4,-32380(gp)
8110fe2c:	e0bffe17 	ldw	r2,-8(fp)
8110fe30:	10802a43 	ldbu	r2,169(r2)
8110fe34:	11403fcc 	andi	r5,r2,255
8110fe38:	e0bffe17 	ldw	r2,-8(fp)
8110fe3c:	10802a83 	ldbu	r2,170(r2)
8110fe40:	11803fcc 	andi	r6,r2,255
8110fe44:	e0bffe17 	ldw	r2,-8(fp)
8110fe48:	10802ac3 	ldbu	r2,171(r2)
8110fe4c:	10803fcc 	andi	r2,r2,255
8110fe50:	e0fffe17 	ldw	r3,-8(fp)
8110fe54:	18c02b03 	ldbu	r3,172(r3)
8110fe58:	18c03fcc 	andi	r3,r3,255
8110fe5c:	d8c00115 	stw	r3,4(sp)
8110fe60:	d8800015 	stw	r2,0(sp)
8110fe64:	300f883a 	mov	r7,r6
8110fe68:	280d883a 	mov	r6,r5
8110fe6c:	01604574 	movhi	r5,33045
8110fe70:	296b8604 	addi	r5,r5,-20968
8110fe74:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110fe78:	d0e06117 	ldw	r3,-32380(gp)
8110fe7c:	e0bffe17 	ldw	r2,-8(fp)
8110fe80:	10802e17 	ldw	r2,184(r2)
8110fe84:	100d883a 	mov	r6,r2
8110fe88:	01604574 	movhi	r5,33045
8110fe8c:	296b9304 	addi	r5,r5,-20916
8110fe90:	1809883a 	mov	r4,r3
8110fe94:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n\n");
8110fe98:	d0a06117 	ldw	r2,-32380(gp)
8110fe9c:	100f883a 	mov	r7,r2
8110fea0:	01800084 	movi	r6,2
8110fea4:	01400044 	movi	r5,1
8110fea8:	01204574 	movhi	r4,33045
8110feac:	212b9904 	addi	r4,r4,-20892
8110feb0:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110feb4:	d0e06117 	ldw	r3,-32380(gp)
8110feb8:	e0bffe17 	ldw	r2,-8(fp)
8110febc:	10800003 	ldbu	r2,0(r2)
8110fec0:	10803fcc 	andi	r2,r2,255
8110fec4:	100d883a 	mov	r6,r2
8110fec8:	01604574 	movhi	r5,33045
8110fecc:	296b9a04 	addi	r5,r5,-20888
8110fed0:	1809883a 	mov	r4,r3
8110fed4:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    General Info: \n");
8110fed8:	d0a06117 	ldw	r2,-32380(gp)
8110fedc:	100f883a 	mov	r7,r2
8110fee0:	018004c4 	movi	r6,19
8110fee4:	01400044 	movi	r5,1
8110fee8:	01204574 	movhi	r4,33045
8110feec:	212ba004 	addi	r4,r4,-20864
8110fef0:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110fef4:	d0e06117 	ldw	r3,-32380(gp)
8110fef8:	e0bffe17 	ldw	r2,-8(fp)
8110fefc:	10800117 	ldw	r2,4(r2)
8110ff00:	100d883a 	mov	r6,r2
8110ff04:	01604574 	movhi	r5,33045
8110ff08:	296ba504 	addi	r5,r5,-20844
8110ff0c:	1809883a 	mov	r4,r3
8110ff10:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110ff14:	d0e06117 	ldw	r3,-32380(gp)
8110ff18:	e0bffe17 	ldw	r2,-8(fp)
8110ff1c:	10800217 	ldw	r2,8(r2)
8110ff20:	100d883a 	mov	r6,r2
8110ff24:	01604574 	movhi	r5,33045
8110ff28:	296bad04 	addi	r5,r5,-20812
8110ff2c:	1809883a 	mov	r4,r3
8110ff30:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110ff34:	d0e06117 	ldw	r3,-32380(gp)
8110ff38:	e0bffe17 	ldw	r2,-8(fp)
8110ff3c:	10800317 	ldw	r2,12(r2)
8110ff40:	100d883a 	mov	r6,r2
8110ff44:	01604574 	movhi	r5,33045
8110ff48:	296bb504 	addi	r5,r5,-20780
8110ff4c:	1809883a 	mov	r4,r3
8110ff50:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110ff54:	d0a06117 	ldw	r2,-32380(gp)
8110ff58:	100f883a 	mov	r7,r2
8110ff5c:	01800644 	movi	r6,25
8110ff60:	01400044 	movi	r5,1
8110ff64:	01204574 	movhi	r4,33045
8110ff68:	212bbc04 	addi	r4,r4,-20752
8110ff6c:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110ff70:	d0e06117 	ldw	r3,-32380(gp)
8110ff74:	e0bffe17 	ldw	r2,-8(fp)
8110ff78:	10800517 	ldw	r2,20(r2)
8110ff7c:	100d883a 	mov	r6,r2
8110ff80:	01604574 	movhi	r5,33045
8110ff84:	296bc304 	addi	r5,r5,-20724
8110ff88:	1809883a 	mov	r4,r3
8110ff8c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110ff90:	d0e06117 	ldw	r3,-32380(gp)
8110ff94:	e0bffe17 	ldw	r2,-8(fp)
8110ff98:	10800417 	ldw	r2,16(r2)
8110ff9c:	100d883a 	mov	r6,r2
8110ffa0:	01604574 	movhi	r5,33045
8110ffa4:	296bcb04 	addi	r5,r5,-20692
8110ffa8:	1809883a 	mov	r4,r3
8110ffac:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110ffb0:	d0e06117 	ldw	r3,-32380(gp)
8110ffb4:	e0bffe17 	ldw	r2,-8(fp)
8110ffb8:	10800603 	ldbu	r2,24(r2)
8110ffbc:	10803fcc 	andi	r2,r2,255
8110ffc0:	100d883a 	mov	r6,r2
8110ffc4:	01604574 	movhi	r5,33045
8110ffc8:	296bd304 	addi	r5,r5,-20660
8110ffcc:	1809883a 	mov	r4,r3
8110ffd0:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110ffd4:	d2206117 	ldw	r8,-32380(gp)
8110ffd8:	e13ffe17 	ldw	r4,-8(fp)
8110ffdc:	20800717 	ldw	r2,28(r4)
8110ffe0:	20c00817 	ldw	r3,32(r4)
8110ffe4:	100d883a 	mov	r6,r2
8110ffe8:	180f883a 	mov	r7,r3
8110ffec:	01604574 	movhi	r5,33045
8110fff0:	296bdb04 	addi	r5,r5,-20628
8110fff4:	4009883a 	mov	r4,r8
8110fff8:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
8110fffc:	d0a06117 	ldw	r2,-32380(gp)
81110000:	100b883a 	mov	r5,r2
81110004:	01000284 	movi	r4,10
81110008:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8111000c:	d0e06117 	ldw	r3,-32380(gp)
81110010:	e0bffe17 	ldw	r2,-8(fp)
81110014:	10800003 	ldbu	r2,0(r2)
81110018:	10803fcc 	andi	r2,r2,255
8111001c:	100f883a 	mov	r7,r2
81110020:	000d883a 	mov	r6,zero
81110024:	01604574 	movhi	r5,33045
81110028:	296be304 	addi	r5,r5,-20596
8111002c:	1809883a 	mov	r4,r3
81110030:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Left side \n");
81110034:	d0a06117 	ldw	r2,-32380(gp)
81110038:	100f883a 	mov	r7,r2
8111003c:	018004c4 	movi	r6,19
81110040:	01400044 	movi	r5,1
81110044:	01204574 	movhi	r4,33045
81110048:	212bed04 	addi	r4,r4,-20556
8111004c:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
81110050:	d0e06117 	ldw	r3,-32380(gp)
81110054:	e0bffe17 	ldw	r2,-8(fp)
81110058:	10800917 	ldw	r2,36(r2)
8111005c:	100d883a 	mov	r6,r2
81110060:	01604574 	movhi	r5,33045
81110064:	296bf204 	addi	r5,r5,-20536
81110068:	1809883a 	mov	r4,r3
8111006c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
81110070:	d0e06117 	ldw	r3,-32380(gp)
81110074:	e0bffe17 	ldw	r2,-8(fp)
81110078:	10800a17 	ldw	r2,40(r2)
8111007c:	100d883a 	mov	r6,r2
81110080:	01604574 	movhi	r5,33045
81110084:	296bfb04 	addi	r5,r5,-20500
81110088:	1809883a 	mov	r4,r3
8111008c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
81110090:	d0e06117 	ldw	r3,-32380(gp)
81110094:	e0bffe17 	ldw	r2,-8(fp)
81110098:	10800b17 	ldw	r2,44(r2)
8111009c:	100d883a 	mov	r6,r2
811100a0:	01604574 	movhi	r5,33045
811100a4:	296c0604 	addi	r5,r5,-20456
811100a8:	1809883a 	mov	r4,r3
811100ac:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Right side \n");
811100b0:	d0a06117 	ldw	r2,-32380(gp)
811100b4:	100f883a 	mov	r7,r2
811100b8:	01800504 	movi	r6,20
811100bc:	01400044 	movi	r5,1
811100c0:	01204574 	movhi	r4,33045
811100c4:	212c1204 	addi	r4,r4,-20408
811100c8:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
811100cc:	d0e06117 	ldw	r3,-32380(gp)
811100d0:	e0bffe17 	ldw	r2,-8(fp)
811100d4:	10800c17 	ldw	r2,48(r2)
811100d8:	100d883a 	mov	r6,r2
811100dc:	01604574 	movhi	r5,33045
811100e0:	296bf204 	addi	r5,r5,-20536
811100e4:	1809883a 	mov	r4,r3
811100e8:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
811100ec:	d0e06117 	ldw	r3,-32380(gp)
811100f0:	e0bffe17 	ldw	r2,-8(fp)
811100f4:	10800d17 	ldw	r2,52(r2)
811100f8:	100d883a 	mov	r6,r2
811100fc:	01604574 	movhi	r5,33045
81110100:	296bfb04 	addi	r5,r5,-20500
81110104:	1809883a 	mov	r4,r3
81110108:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8111010c:	d0e06117 	ldw	r3,-32380(gp)
81110110:	e0bffe17 	ldw	r2,-8(fp)
81110114:	10800e17 	ldw	r2,56(r2)
81110118:	100d883a 	mov	r6,r2
8111011c:	01604574 	movhi	r5,33045
81110120:	296c0604 	addi	r5,r5,-20456
81110124:	1809883a 	mov	r4,r3
81110128:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
8111012c:	d0a06117 	ldw	r2,-32380(gp)
81110130:	100b883a 	mov	r5,r2
81110134:	01000284 	movi	r4,10
81110138:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8111013c:	d0e06117 	ldw	r3,-32380(gp)
81110140:	e0bffe17 	ldw	r2,-8(fp)
81110144:	10800003 	ldbu	r2,0(r2)
81110148:	10803fcc 	andi	r2,r2,255
8111014c:	100f883a 	mov	r7,r2
81110150:	01800044 	movi	r6,1
81110154:	01604574 	movhi	r5,33045
81110158:	296be304 	addi	r5,r5,-20596
8111015c:	1809883a 	mov	r4,r3
81110160:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Left side \n");
81110164:	d0a06117 	ldw	r2,-32380(gp)
81110168:	100f883a 	mov	r7,r2
8111016c:	018004c4 	movi	r6,19
81110170:	01400044 	movi	r5,1
81110174:	01204574 	movhi	r4,33045
81110178:	212bed04 	addi	r4,r4,-20556
8111017c:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
81110180:	d0e06117 	ldw	r3,-32380(gp)
81110184:	e0bffe17 	ldw	r2,-8(fp)
81110188:	10800f17 	ldw	r2,60(r2)
8111018c:	100d883a 	mov	r6,r2
81110190:	01604574 	movhi	r5,33045
81110194:	296bf204 	addi	r5,r5,-20536
81110198:	1809883a 	mov	r4,r3
8111019c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
811101a0:	d0e06117 	ldw	r3,-32380(gp)
811101a4:	e0bffe17 	ldw	r2,-8(fp)
811101a8:	10801017 	ldw	r2,64(r2)
811101ac:	100d883a 	mov	r6,r2
811101b0:	01604574 	movhi	r5,33045
811101b4:	296bfb04 	addi	r5,r5,-20500
811101b8:	1809883a 	mov	r4,r3
811101bc:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
811101c0:	d0e06117 	ldw	r3,-32380(gp)
811101c4:	e0bffe17 	ldw	r2,-8(fp)
811101c8:	10801117 	ldw	r2,68(r2)
811101cc:	100d883a 	mov	r6,r2
811101d0:	01604574 	movhi	r5,33045
811101d4:	296c0604 	addi	r5,r5,-20456
811101d8:	1809883a 	mov	r4,r3
811101dc:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Right side \n");
811101e0:	d0a06117 	ldw	r2,-32380(gp)
811101e4:	100f883a 	mov	r7,r2
811101e8:	01800504 	movi	r6,20
811101ec:	01400044 	movi	r5,1
811101f0:	01204574 	movhi	r4,33045
811101f4:	212c1204 	addi	r4,r4,-20408
811101f8:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
811101fc:	d0e06117 	ldw	r3,-32380(gp)
81110200:	e0bffe17 	ldw	r2,-8(fp)
81110204:	10801217 	ldw	r2,72(r2)
81110208:	100d883a 	mov	r6,r2
8111020c:	01604574 	movhi	r5,33045
81110210:	296bf204 	addi	r5,r5,-20536
81110214:	1809883a 	mov	r4,r3
81110218:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8111021c:	d0e06117 	ldw	r3,-32380(gp)
81110220:	e0bffe17 	ldw	r2,-8(fp)
81110224:	10801317 	ldw	r2,76(r2)
81110228:	100d883a 	mov	r6,r2
8111022c:	01604574 	movhi	r5,33045
81110230:	296bfb04 	addi	r5,r5,-20500
81110234:	1809883a 	mov	r4,r3
81110238:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8111023c:	d0e06117 	ldw	r3,-32380(gp)
81110240:	e0bffe17 	ldw	r2,-8(fp)
81110244:	10801417 	ldw	r2,80(r2)
81110248:	100d883a 	mov	r6,r2
8111024c:	01604574 	movhi	r5,33045
81110250:	296c0604 	addi	r5,r5,-20456
81110254:	1809883a 	mov	r4,r3
81110258:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
8111025c:	d0a06117 	ldw	r2,-32380(gp)
81110260:	100b883a 	mov	r5,r2
81110264:	01000284 	movi	r4,10
81110268:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8111026c:	d0e06117 	ldw	r3,-32380(gp)
81110270:	e0bffe17 	ldw	r2,-8(fp)
81110274:	10800003 	ldbu	r2,0(r2)
81110278:	10803fcc 	andi	r2,r2,255
8111027c:	100f883a 	mov	r7,r2
81110280:	01800084 	movi	r6,2
81110284:	01604574 	movhi	r5,33045
81110288:	296be304 	addi	r5,r5,-20596
8111028c:	1809883a 	mov	r4,r3
81110290:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Left side \n");
81110294:	d0a06117 	ldw	r2,-32380(gp)
81110298:	100f883a 	mov	r7,r2
8111029c:	018004c4 	movi	r6,19
811102a0:	01400044 	movi	r5,1
811102a4:	01204574 	movhi	r4,33045
811102a8:	212bed04 	addi	r4,r4,-20556
811102ac:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
811102b0:	d0e06117 	ldw	r3,-32380(gp)
811102b4:	e0bffe17 	ldw	r2,-8(fp)
811102b8:	10801517 	ldw	r2,84(r2)
811102bc:	100d883a 	mov	r6,r2
811102c0:	01604574 	movhi	r5,33045
811102c4:	296bf204 	addi	r5,r5,-20536
811102c8:	1809883a 	mov	r4,r3
811102cc:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
811102d0:	d0e06117 	ldw	r3,-32380(gp)
811102d4:	e0bffe17 	ldw	r2,-8(fp)
811102d8:	10801617 	ldw	r2,88(r2)
811102dc:	100d883a 	mov	r6,r2
811102e0:	01604574 	movhi	r5,33045
811102e4:	296bfb04 	addi	r5,r5,-20500
811102e8:	1809883a 	mov	r4,r3
811102ec:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
811102f0:	d0e06117 	ldw	r3,-32380(gp)
811102f4:	e0bffe17 	ldw	r2,-8(fp)
811102f8:	10801717 	ldw	r2,92(r2)
811102fc:	100d883a 	mov	r6,r2
81110300:	01604574 	movhi	r5,33045
81110304:	296c0604 	addi	r5,r5,-20456
81110308:	1809883a 	mov	r4,r3
8111030c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Right side \n");
81110310:	d0a06117 	ldw	r2,-32380(gp)
81110314:	100f883a 	mov	r7,r2
81110318:	01800504 	movi	r6,20
8111031c:	01400044 	movi	r5,1
81110320:	01204574 	movhi	r4,33045
81110324:	212c1204 	addi	r4,r4,-20408
81110328:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8111032c:	d0e06117 	ldw	r3,-32380(gp)
81110330:	e0bffe17 	ldw	r2,-8(fp)
81110334:	10801817 	ldw	r2,96(r2)
81110338:	100d883a 	mov	r6,r2
8111033c:	01604574 	movhi	r5,33045
81110340:	296bf204 	addi	r5,r5,-20536
81110344:	1809883a 	mov	r4,r3
81110348:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8111034c:	d0e06117 	ldw	r3,-32380(gp)
81110350:	e0bffe17 	ldw	r2,-8(fp)
81110354:	10801917 	ldw	r2,100(r2)
81110358:	100d883a 	mov	r6,r2
8111035c:	01604574 	movhi	r5,33045
81110360:	296bfb04 	addi	r5,r5,-20500
81110364:	1809883a 	mov	r4,r3
81110368:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8111036c:	d0e06117 	ldw	r3,-32380(gp)
81110370:	e0bffe17 	ldw	r2,-8(fp)
81110374:	10801a17 	ldw	r2,104(r2)
81110378:	100d883a 	mov	r6,r2
8111037c:	01604574 	movhi	r5,33045
81110380:	296c0604 	addi	r5,r5,-20456
81110384:	1809883a 	mov	r4,r3
81110388:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
8111038c:	d0a06117 	ldw	r2,-32380(gp)
81110390:	100b883a 	mov	r5,r2
81110394:	01000284 	movi	r4,10
81110398:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8111039c:	d0e06117 	ldw	r3,-32380(gp)
811103a0:	e0bffe17 	ldw	r2,-8(fp)
811103a4:	10800003 	ldbu	r2,0(r2)
811103a8:	10803fcc 	andi	r2,r2,255
811103ac:	100f883a 	mov	r7,r2
811103b0:	018000c4 	movi	r6,3
811103b4:	01604574 	movhi	r5,33045
811103b8:	296be304 	addi	r5,r5,-20596
811103bc:	1809883a 	mov	r4,r3
811103c0:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Left side \n");
811103c4:	d0a06117 	ldw	r2,-32380(gp)
811103c8:	100f883a 	mov	r7,r2
811103cc:	018004c4 	movi	r6,19
811103d0:	01400044 	movi	r5,1
811103d4:	01204574 	movhi	r4,33045
811103d8:	212bed04 	addi	r4,r4,-20556
811103dc:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
811103e0:	d0e06117 	ldw	r3,-32380(gp)
811103e4:	e0bffe17 	ldw	r2,-8(fp)
811103e8:	10801b17 	ldw	r2,108(r2)
811103ec:	100d883a 	mov	r6,r2
811103f0:	01604574 	movhi	r5,33045
811103f4:	296bf204 	addi	r5,r5,-20536
811103f8:	1809883a 	mov	r4,r3
811103fc:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
81110400:	d0e06117 	ldw	r3,-32380(gp)
81110404:	e0bffe17 	ldw	r2,-8(fp)
81110408:	10801c17 	ldw	r2,112(r2)
8111040c:	100d883a 	mov	r6,r2
81110410:	01604574 	movhi	r5,33045
81110414:	296bfb04 	addi	r5,r5,-20500
81110418:	1809883a 	mov	r4,r3
8111041c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
81110420:	d0e06117 	ldw	r3,-32380(gp)
81110424:	e0bffe17 	ldw	r2,-8(fp)
81110428:	10801d17 	ldw	r2,116(r2)
8111042c:	100d883a 	mov	r6,r2
81110430:	01604574 	movhi	r5,33045
81110434:	296c0604 	addi	r5,r5,-20456
81110438:	1809883a 	mov	r4,r3
8111043c:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"        Right side \n");
81110440:	d0a06117 	ldw	r2,-32380(gp)
81110444:	100f883a 	mov	r7,r2
81110448:	01800504 	movi	r6,20
8111044c:	01400044 	movi	r5,1
81110450:	01204574 	movhi	r4,33045
81110454:	212c1204 	addi	r4,r4,-20408
81110458:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8111045c:	d0e06117 	ldw	r3,-32380(gp)
81110460:	e0bffe17 	ldw	r2,-8(fp)
81110464:	10801e17 	ldw	r2,120(r2)
81110468:	100d883a 	mov	r6,r2
8111046c:	01604574 	movhi	r5,33045
81110470:	296bf204 	addi	r5,r5,-20536
81110474:	1809883a 	mov	r4,r3
81110478:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8111047c:	d0e06117 	ldw	r3,-32380(gp)
81110480:	e0bffe17 	ldw	r2,-8(fp)
81110484:	10801f17 	ldw	r2,124(r2)
81110488:	100d883a 	mov	r6,r2
8111048c:	01604574 	movhi	r5,33045
81110490:	296bfb04 	addi	r5,r5,-20500
81110494:	1809883a 	mov	r4,r3
81110498:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8111049c:	d0e06117 	ldw	r3,-32380(gp)
811104a0:	e0bffe17 	ldw	r2,-8(fp)
811104a4:	10802017 	ldw	r2,128(r2)
811104a8:	100d883a 	mov	r6,r2
811104ac:	01604574 	movhi	r5,33045
811104b0:	296c0604 	addi	r5,r5,-20456
811104b4:	1809883a 	mov	r4,r3
811104b8:	111f5fc0 	call	8111f5fc <fprintf>
		fprintf(fp,"\n");
811104bc:	d0a06117 	ldw	r2,-32380(gp)
811104c0:	100b883a 	mov	r5,r2
811104c4:	01000284 	movi	r4,10
811104c8:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"==============================================================================\n");
811104cc:	d0a06117 	ldw	r2,-32380(gp)
811104d0:	100f883a 	mov	r7,r2
811104d4:	018013c4 	movi	r6,79
811104d8:	01400044 	movi	r5,1
811104dc:	01204574 	movhi	r4,33045
811104e0:	212c1804 	addi	r4,r4,-20384
811104e4:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"==============================================================================\n");
811104e8:	d0a06117 	ldw	r2,-32380(gp)
811104ec:	100f883a 	mov	r7,r2
811104f0:	018013c4 	movi	r6,79
811104f4:	01400044 	movi	r5,1
811104f8:	01204574 	movhi	r4,33045
811104fc:	212c1804 	addi	r4,r4,-20384
81110500:	111fc980 	call	8111fc98 <fwrite>
		fprintf(fp,"\n");
81110504:	d0a06117 	ldw	r2,-32380(gp)
81110508:	100b883a 	mov	r5,r2
8111050c:	01000284 	movi	r4,10
81110510:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"\n");
81110514:	d0a06117 	ldw	r2,-32380(gp)
81110518:	100b883a 	mov	r5,r2
8111051c:	01000284 	movi	r4,10
81110520:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"\n");
81110524:	d0a06117 	ldw	r2,-32380(gp)
81110528:	100b883a 	mov	r5,r2
8111052c:	01000284 	movi	r4,10
81110530:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"\n");
81110534:	d0a06117 	ldw	r2,-32380(gp)
81110538:	100b883a 	mov	r5,r2
8111053c:	01000284 	movi	r4,10
81110540:	111f6740 	call	8111f674 <fputc>
		fprintf(fp,"\n");
81110544:	d0a06117 	ldw	r2,-32380(gp)
81110548:	100b883a 	mov	r5,r2
8111054c:	01000284 	movi	r4,10
81110550:	111f6740 	call	8111f674 <fputc>
	}
81110554:	0001883a 	nop
81110558:	e037883a 	mov	sp,fp
8111055c:	dfc00117 	ldw	ra,4(sp)
81110560:	df000017 	ldw	fp,0(sp)
81110564:	dec00204 	addi	sp,sp,8
81110568:	f800283a 	ret

8111056c <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8111056c:	defff604 	addi	sp,sp,-40
81110570:	de00012e 	bgeu	sp,et,81110578 <vInAckHandlerTaskV2+0xc>
81110574:	003b68fa 	trap	3
81110578:	dfc00915 	stw	ra,36(sp)
8111057c:	df000815 	stw	fp,32(sp)
81110580:	df000804 	addi	fp,sp,32
81110584:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
81110588:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8111058c:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
81110590:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
81110594:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
81110598:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8111059c:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
811105a0:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
811105a4:	d0a06117 	ldw	r2,-32380(gp)
811105a8:	100f883a 	mov	r7,r2
811105ac:	018007c4 	movi	r6,31
811105b0:	01400044 	movi	r5,1
811105b4:	01204574 	movhi	r4,33045
811105b8:	212c2c04 	addi	r4,r4,-20304
811105bc:	111fc980 	call	8111fc98 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
811105c0:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
811105c4:	e0bff917 	ldw	r2,-28(fp)
811105c8:	10c00060 	cmpeqi	r3,r2,1
811105cc:	1800071e 	bne	r3,zero,811105ec <vInAckHandlerTaskV2+0x80>
811105d0:	0080032e 	bgeu	zero,r2,811105e0 <vInAckHandlerTaskV2+0x74>
811105d4:	108000a0 	cmpeqi	r2,r2,2
811105d8:	10004a1e 	bne	r2,zero,81110704 <vInAckHandlerTaskV2+0x198>
811105dc:	0000ac06 	br	81110890 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
811105e0:	00800044 	movi	r2,1
811105e4:	e0bff915 	stw	r2,-28(fp)
				break;
811105e8:	0000b306 	br	811108b8 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
811105ec:	00800044 	movi	r2,1
811105f0:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
811105f4:	d0a06517 	ldw	r2,-32364(gp)
811105f8:	e0fffe04 	addi	r3,fp,-8
811105fc:	180d883a 	mov	r6,r3
81110600:	000b883a 	mov	r5,zero
81110604:	1009883a 	mov	r4,r2
81110608:	113cb180 	call	8113cb18 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8111060c:	e0bffe03 	ldbu	r2,-8(fp)
81110610:	10803fcc 	andi	r2,r2,255
81110614:	1000391e 	bne	r2,zero,811106fc <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
81110618:	d0a06417 	ldw	r2,-32368(gp)
8111061c:	e0fffe04 	addi	r3,fp,-8
81110620:	180d883a 	mov	r6,r3
81110624:	000b883a 	mov	r5,zero
81110628:	1009883a 	mov	r4,r2
8111062c:	113ab0c0 	call	8113ab0c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81110630:	e0bffe03 	ldbu	r2,-8(fp)
81110634:	10803fcc 	andi	r2,r2,255
81110638:	10002b1e 	bne	r2,zero,811106e8 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8111063c:	e03ffa45 	stb	zero,-23(fp)
81110640:	00002206 	br	811106cc <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
81110644:	e0fffa43 	ldbu	r3,-23(fp)
81110648:	00a045b4 	movhi	r2,33046
8111064c:	10bafa04 	addi	r2,r2,-5144
81110650:	18c7883a 	add	r3,r3,r3
81110654:	18c7883a 	add	r3,r3,r3
81110658:	10c5883a 	add	r2,r2,r3
8111065c:	10800003 	ldbu	r2,0(r2)
81110660:	10803fcc 	andi	r2,r2,255
81110664:	1080201c 	xori	r2,r2,128
81110668:	10bfe004 	addi	r2,r2,-128
8111066c:	10001426 	beq	r2,zero,811106c0 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
81110670:	e0fffa43 	ldbu	r3,-23(fp)
81110674:	00a045b4 	movhi	r2,33046
81110678:	10bafa04 	addi	r2,r2,-5144
8111067c:	18c7883a 	add	r3,r3,r3
81110680:	18c7883a 	add	r3,r3,r3
81110684:	10c5883a 	add	r2,r2,r3
81110688:	10c0000b 	ldhu	r3,0(r2)
8111068c:	d0e0560d 	sth	r3,-32424(gp)
81110690:	1080008b 	ldhu	r2,2(r2)
81110694:	d0a0568d 	sth	r2,-32422(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81110698:	e0fffa43 	ldbu	r3,-23(fp)
8111069c:	00a045b4 	movhi	r2,33046
811106a0:	10bafa04 	addi	r2,r2,-5144
811106a4:	18c7883a 	add	r3,r3,r3
811106a8:	18c7883a 	add	r3,r3,r3
811106ac:	10c5883a 	add	r2,r2,r3
811106b0:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
811106b4:	00800084 	movi	r2,2
811106b8:	e0bff915 	stw	r2,-28(fp)
                                break;                                
811106bc:	00000606 	br	811106d8 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
811106c0:	e0bffa43 	ldbu	r2,-23(fp)
811106c4:	10800044 	addi	r2,r2,1
811106c8:	e0bffa45 	stb	r2,-23(fp)
811106cc:	e0bffa43 	ldbu	r2,-23(fp)
811106d0:	108001b0 	cmpltui	r2,r2,6
811106d4:	103fdb1e 	bne	r2,zero,81110644 <__reset+0xfb0f0644>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
811106d8:	d0a06417 	ldw	r2,-32368(gp)
811106dc:	1009883a 	mov	r4,r2
811106e0:	113b0b00 	call	8113b0b0 <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811106e4:	00007406 	br	811108b8 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
811106e8:	d0a06517 	ldw	r2,-32364(gp)
811106ec:	1009883a 	mov	r4,r2
811106f0:	113cea00 	call	8113cea0 <OSSemPost>
                    	vFailGetMutexReceiverTask();
811106f4:	1119d900 	call	81119d90 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
811106f8:	00006f06 	br	811108b8 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
811106fc:	1119d280 	call	81119d28 <vFailGetCountSemaphoreReceiverTask>
                }
                break;
81110700:	00006d06 	br	811108b8 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
81110704:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81110708:	d0a06783 	ldbu	r2,-32354(gp)
8111070c:	10803fcc 	andi	r2,r2,255
81110710:	10800218 	cmpnei	r2,r2,8
81110714:	1000021e 	bne	r2,zero,81110720 <vInAckHandlerTaskV2+0x1b4>
81110718:	00c00104 	movi	r3,4
8111071c:	00000106 	br	81110724 <vInAckHandlerTaskV2+0x1b8>
81110720:	0007883a 	mov	r3,zero
81110724:	d0a07403 	ldbu	r2,-32304(gp)
81110728:	10803fcc 	andi	r2,r2,255
8111072c:	10800218 	cmpnei	r2,r2,8
81110730:	1000021e 	bne	r2,zero,8111073c <vInAckHandlerTaskV2+0x1d0>
81110734:	00800084 	movi	r2,2
81110738:	00000106 	br	81110740 <vInAckHandlerTaskV2+0x1d4>
8111073c:	0005883a 	mov	r2,zero
81110740:	1884b03a 	or	r2,r3,r2
81110744:	1007883a 	mov	r3,r2
81110748:	d0a07443 	ldbu	r2,-32303(gp)
8111074c:	10803fcc 	andi	r2,r2,255
81110750:	108001a0 	cmpeqi	r2,r2,6
81110754:	1884b03a 	or	r2,r3,r2
81110758:	1007883a 	mov	r3,r2
8111075c:	e0bffa83 	ldbu	r2,-22(fp)
81110760:	1884b03a 	or	r2,r3,r2
81110764:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
81110768:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8111076c:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
81110770:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
81110774:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
81110778:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8111077c:	e0bffa03 	ldbu	r2,-24(fp)
81110780:	10800044 	addi	r2,r2,1
81110784:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81110788:	e0bffa83 	ldbu	r2,-22(fp)
8111078c:	1080004c 	andi	r2,r2,1
81110790:	10803fcc 	andi	r2,r2,255
81110794:	1000061e 	bne	r2,zero,811107b0 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
81110798:	e0bffd04 	addi	r2,fp,-12
8111079c:	100b883a 	mov	r5,r2
811107a0:	d1205604 	addi	r4,gp,-32424
811107a4:	11108bc0 	call	811108bc <bCheckInAck128>
811107a8:	e0bff815 	stw	r2,-32(fp)
811107ac:	00000206 	br	811107b8 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
811107b0:	00800044 	movi	r2,1
811107b4:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
811107b8:	e0bffa83 	ldbu	r2,-22(fp)
811107bc:	1080008c 	andi	r2,r2,2
811107c0:	10803fcc 	andi	r2,r2,255
811107c4:	1000081e 	bne	r2,zero,811107e8 <vInAckHandlerTaskV2+0x27c>
811107c8:	e0bff817 	ldw	r2,-32(fp)
811107cc:	1000061e 	bne	r2,zero,811107e8 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
811107d0:	e0bffc04 	addi	r2,fp,-16
811107d4:	100b883a 	mov	r5,r2
811107d8:	d1205604 	addi	r4,gp,-32424
811107dc:	1110a040 	call	81110a04 <bCheckInAck64>
811107e0:	e0bff815 	stw	r2,-32(fp)
811107e4:	00000206 	br	811107f0 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
811107e8:	00800044 	movi	r2,1
811107ec:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
811107f0:	e0bffa83 	ldbu	r2,-22(fp)
811107f4:	1080010c 	andi	r2,r2,4
811107f8:	10803fcc 	andi	r2,r2,255
811107fc:	1000081e 	bne	r2,zero,81110820 <vInAckHandlerTaskV2+0x2b4>
81110800:	e0bff817 	ldw	r2,-32(fp)
81110804:	1000061e 	bne	r2,zero,81110820 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
81110808:	e0bffb04 	addi	r2,fp,-20
8111080c:	100b883a 	mov	r5,r2
81110810:	d1205604 	addi	r4,gp,-32424
81110814:	1110b500 	call	81110b50 <bCheckInAck32>
81110818:	e0bff815 	stw	r2,-32(fp)
8111081c:	00000206 	br	81110828 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
81110820:	00800044 	movi	r2,1
81110824:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
81110828:	e0bffa03 	ldbu	r2,-24(fp)
8111082c:	10c00044 	addi	r3,r2,1
81110830:	e0fffa05 	stb	r3,-24(fp)
81110834:	10803fcc 	andi	r2,r2,255
81110838:	10800ca8 	cmpgeui	r2,r2,50
8111083c:	10000e1e 	bne	r2,zero,81110878 <vInAckHandlerTaskV2+0x30c>
81110840:	e0bff817 	ldw	r2,-32(fp)
81110844:	10000c1e 	bne	r2,zero,81110878 <vInAckHandlerTaskV2+0x30c>
81110848:	e0bffb17 	ldw	r2,-20(fp)
8111084c:	1005003a 	cmpeq	r2,r2,zero
81110850:	1007883a 	mov	r3,r2
81110854:	e0bffc17 	ldw	r2,-16(fp)
81110858:	1005003a 	cmpeq	r2,r2,zero
8111085c:	1884b03a 	or	r2,r3,r2
81110860:	10c03fcc 	andi	r3,r2,255
81110864:	e0bffd17 	ldw	r2,-12(fp)
81110868:	1005003a 	cmpeq	r2,r2,zero
8111086c:	10803fcc 	andi	r2,r2,255
81110870:	1884b03a 	or	r2,r3,r2
81110874:	103fc11e 	bne	r2,zero,8111077c <__reset+0xfb0f077c>
                
                if (bFound == FALSE) {
81110878:	e0bff817 	ldw	r2,-32(fp)
8111087c:	1000011e 	bne	r2,zero,81110884 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
81110880:	111a24c0 	call	8111a24c <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
81110884:	00800044 	movi	r2,1
81110888:	e0bff915 	stw	r2,-28(fp)
				break;
8111088c:	00000a06 	br	811108b8 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
81110890:	d0a06117 	ldw	r2,-32380(gp)
81110894:	100f883a 	mov	r7,r2
81110898:	01801144 	movi	r6,69
8111089c:	01400044 	movi	r5,1
811108a0:	01204574 	movhi	r4,33045
811108a4:	212c3404 	addi	r4,r4,-20272
811108a8:	111fc980 	call	8111fc98 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
811108ac:	00800044 	movi	r2,1
811108b0:	e0bff915 	stw	r2,-28(fp)
				break;
811108b4:	0001883a 	nop
		}
	}
811108b8:	003f4206 	br	811105c4 <__reset+0xfb0f05c4>

811108bc <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
811108bc:	defffa04 	addi	sp,sp,-24
811108c0:	de00012e 	bgeu	sp,et,811108c8 <bCheckInAck128+0xc>
811108c4:	003b68fa 	trap	3
811108c8:	dfc00515 	stw	ra,20(sp)
811108cc:	df000415 	stw	fp,16(sp)
811108d0:	df000404 	addi	fp,sp,16
811108d4:	e13ffe15 	stw	r4,-8(fp)
811108d8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
811108dc:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
811108e0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
811108e4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
811108e8:	e0bfff17 	ldw	r2,-4(fp)
811108ec:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
811108f0:	d0a06d17 	ldw	r2,-32332(gp)
811108f4:	e0fffd44 	addi	r3,fp,-11
811108f8:	180d883a 	mov	r6,r3
811108fc:	01400144 	movi	r5,5
81110900:	1009883a 	mov	r4,r2
81110904:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81110908:	e0bffd43 	ldbu	r2,-11(fp)
8111090c:	10803fcc 	andi	r2,r2,255
81110910:	10000226 	beq	r2,zero,8111091c <bCheckInAck128+0x60>
        return bFound;
81110914:	e0bffc17 	ldw	r2,-16(fp)
81110918:	00003506 	br	811109f0 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8111091c:	e03ffd05 	stb	zero,-12(fp)
81110920:	00002706 	br	811109c0 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
81110924:	e0fffd03 	ldbu	r3,-12(fp)
81110928:	00a045b4 	movhi	r2,33046
8111092c:	10b1f804 	addi	r2,r2,-14368
81110930:	18c02324 	muli	r3,r3,140
81110934:	10c5883a 	add	r2,r2,r3
81110938:	10802104 	addi	r2,r2,132
8111093c:	10c0000b 	ldhu	r3,0(r2)
81110940:	e0bffe17 	ldw	r2,-8(fp)
81110944:	1080008b 	ldhu	r2,2(r2)
81110948:	18ffffcc 	andi	r3,r3,65535
8111094c:	10bfffcc 	andi	r2,r2,65535
81110950:	1880181e 	bne	r3,r2,811109b4 <bCheckInAck128+0xf8>
            bFound = TRUE;
81110954:	00800044 	movi	r2,1
81110958:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8111095c:	e0fffd03 	ldbu	r3,-12(fp)
81110960:	00a045b4 	movhi	r2,33046
81110964:	10b1da04 	addi	r2,r2,-14488
81110968:	18c7883a 	add	r3,r3,r3
8111096c:	18c7883a 	add	r3,r3,r3
81110970:	10c5883a 	add	r2,r2,r3
81110974:	10000015 	stw	zero,0(r2)
            SemCount128++;
81110978:	d0a07443 	ldbu	r2,-32303(gp)
8111097c:	10800044 	addi	r2,r2,1
81110980:	d0a07445 	stb	r2,-32303(gp)
            error_code = OSSemPost(xSemCountBuffer128);
81110984:	d0a06217 	ldw	r2,-32376(gp)
81110988:	1009883a 	mov	r4,r2
8111098c:	113cea00 	call	8113cea0 <OSSemPost>
81110990:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81110994:	e0bffd43 	ldbu	r2,-11(fp)
81110998:	10803fcc 	andi	r2,r2,255
8111099c:	10000c26 	beq	r2,zero,811109d0 <bCheckInAck128+0x114>
                SemCount128--;
811109a0:	d0a07443 	ldbu	r2,-32303(gp)
811109a4:	10bfffc4 	addi	r2,r2,-1
811109a8:	d0a07445 	stb	r2,-32303(gp)
                vFailSetCountSemaphorexBuffer128();
811109ac:	111a0ac0 	call	8111a0ac <vFailSetCountSemaphorexBuffer128>
            }
            break;
811109b0:	00000706 	br	811109d0 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
811109b4:	e0bffd03 	ldbu	r2,-12(fp)
811109b8:	10800044 	addi	r2,r2,1
811109bc:	e0bffd05 	stb	r2,-12(fp)
811109c0:	e0bffd03 	ldbu	r2,-12(fp)
811109c4:	108001b0 	cmpltui	r2,r2,6
811109c8:	103fd61e 	bne	r2,zero,81110924 <__reset+0xfb0f0924>
811109cc:	00000106 	br	811109d4 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
811109d0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
811109d4:	d0a06d17 	ldw	r2,-32332(gp)
811109d8:	1009883a 	mov	r4,r2
811109dc:	113b0b00 	call	8113b0b0 <OSMutexPost>
    (*bFinished) = TRUE;
811109e0:	e0bfff17 	ldw	r2,-4(fp)
811109e4:	00c00044 	movi	r3,1
811109e8:	10c00015 	stw	r3,0(r2)

    return bFound;
811109ec:	e0bffc17 	ldw	r2,-16(fp)
}
811109f0:	e037883a 	mov	sp,fp
811109f4:	dfc00117 	ldw	ra,4(sp)
811109f8:	df000017 	ldw	fp,0(sp)
811109fc:	dec00204 	addi	sp,sp,8
81110a00:	f800283a 	ret

81110a04 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
81110a04:	defffa04 	addi	sp,sp,-24
81110a08:	de00012e 	bgeu	sp,et,81110a10 <bCheckInAck64+0xc>
81110a0c:	003b68fa 	trap	3
81110a10:	dfc00515 	stw	ra,20(sp)
81110a14:	df000415 	stw	fp,16(sp)
81110a18:	df000404 	addi	fp,sp,16
81110a1c:	e13ffe15 	stw	r4,-8(fp)
81110a20:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81110a24:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81110a28:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81110a2c:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81110a30:	e0bfff17 	ldw	r2,-4(fp)
81110a34:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81110a38:	d0a07017 	ldw	r2,-32320(gp)
81110a3c:	e0fffd44 	addi	r3,fp,-11
81110a40:	180d883a 	mov	r6,r3
81110a44:	01400044 	movi	r5,1
81110a48:	1009883a 	mov	r4,r2
81110a4c:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81110a50:	e0bffd43 	ldbu	r2,-11(fp)
81110a54:	10803fcc 	andi	r2,r2,255
81110a58:	10000226 	beq	r2,zero,81110a64 <bCheckInAck64+0x60>
        return bFound;
81110a5c:	e0bffc17 	ldw	r2,-16(fp)
81110a60:	00003606 	br	81110b3c <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81110a64:	e03ffd05 	stb	zero,-12(fp)
81110a68:	00002806 	br	81110b0c <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
81110a6c:	e0fffd03 	ldbu	r3,-12(fp)
81110a70:	00a04574 	movhi	r2,33045
81110a74:	108d9e04 	addi	r2,r2,13944
81110a78:	18c01324 	muli	r3,r3,76
81110a7c:	10c5883a 	add	r2,r2,r3
81110a80:	10801104 	addi	r2,r2,68
81110a84:	10c0000b 	ldhu	r3,0(r2)
81110a88:	e0bffe17 	ldw	r2,-8(fp)
81110a8c:	1080008b 	ldhu	r2,2(r2)
81110a90:	18ffffcc 	andi	r3,r3,65535
81110a94:	10bfffcc 	andi	r2,r2,65535
81110a98:	1880191e 	bne	r3,r2,81110b00 <bCheckInAck64+0xfc>
            bFound = TRUE;
81110a9c:	00800044 	movi	r2,1
81110aa0:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
81110aa4:	e0fffd03 	ldbu	r3,-12(fp)
81110aa8:	00a045b4 	movhi	r2,33046
81110aac:	10b1da04 	addi	r2,r2,-14488
81110ab0:	18c00184 	addi	r3,r3,6
81110ab4:	18c7883a 	add	r3,r3,r3
81110ab8:	18c7883a 	add	r3,r3,r3
81110abc:	10c5883a 	add	r2,r2,r3
81110ac0:	10000015 	stw	zero,0(r2)
            SemCount64++;
81110ac4:	d0a07403 	ldbu	r2,-32304(gp)
81110ac8:	10800044 	addi	r2,r2,1
81110acc:	d0a07405 	stb	r2,-32304(gp)
            error_code = OSSemPost(xSemCountBuffer64);
81110ad0:	d0a05d17 	ldw	r2,-32396(gp)
81110ad4:	1009883a 	mov	r4,r2
81110ad8:	113cea00 	call	8113cea0 <OSSemPost>
81110adc:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81110ae0:	e0bffd43 	ldbu	r2,-11(fp)
81110ae4:	10803fcc 	andi	r2,r2,255
81110ae8:	10000c26 	beq	r2,zero,81110b1c <bCheckInAck64+0x118>
                SemCount64--;
81110aec:	d0a07403 	ldbu	r2,-32304(gp)
81110af0:	10bfffc4 	addi	r2,r2,-1
81110af4:	d0a07405 	stb	r2,-32304(gp)
                vFailSetCountSemaphorexBuffer64();
81110af8:	111a0440 	call	8111a044 <vFailSetCountSemaphorexBuffer64>
            }
            break;
81110afc:	00000706 	br	81110b1c <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
81110b00:	e0bffd03 	ldbu	r2,-12(fp)
81110b04:	10800044 	addi	r2,r2,1
81110b08:	e0bffd05 	stb	r2,-12(fp)
81110b0c:	e0bffd03 	ldbu	r2,-12(fp)
81110b10:	10800230 	cmpltui	r2,r2,8
81110b14:	103fd51e 	bne	r2,zero,81110a6c <__reset+0xfb0f0a6c>
81110b18:	00000106 	br	81110b20 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
81110b1c:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
81110b20:	d0a07017 	ldw	r2,-32320(gp)
81110b24:	1009883a 	mov	r4,r2
81110b28:	113b0b00 	call	8113b0b0 <OSMutexPost>
    (*bFinished) = TRUE;
81110b2c:	e0bfff17 	ldw	r2,-4(fp)
81110b30:	00c00044 	movi	r3,1
81110b34:	10c00015 	stw	r3,0(r2)

    return bFound;
81110b38:	e0bffc17 	ldw	r2,-16(fp)
}
81110b3c:	e037883a 	mov	sp,fp
81110b40:	dfc00117 	ldw	ra,4(sp)
81110b44:	df000017 	ldw	fp,0(sp)
81110b48:	dec00204 	addi	sp,sp,8
81110b4c:	f800283a 	ret

81110b50 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
81110b50:	defffa04 	addi	sp,sp,-24
81110b54:	de00012e 	bgeu	sp,et,81110b5c <bCheckInAck32+0xc>
81110b58:	003b68fa 	trap	3
81110b5c:	dfc00515 	stw	ra,20(sp)
81110b60:	df000415 	stw	fp,16(sp)
81110b64:	df000404 	addi	fp,sp,16
81110b68:	e13ffe15 	stw	r4,-8(fp)
81110b6c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
81110b70:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
81110b74:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
81110b78:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
81110b7c:	e0bfff17 	ldw	r2,-4(fp)
81110b80:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
81110b84:	d0a06b17 	ldw	r2,-32340(gp)
81110b88:	e0fffd44 	addi	r3,fp,-11
81110b8c:	180d883a 	mov	r6,r3
81110b90:	01400044 	movi	r5,1
81110b94:	1009883a 	mov	r4,r2
81110b98:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code != OS_NO_ERR )
81110b9c:	e0bffd43 	ldbu	r2,-11(fp)
81110ba0:	10803fcc 	andi	r2,r2,255
81110ba4:	10000226 	beq	r2,zero,81110bb0 <bCheckInAck32+0x60>
        return bFound;
81110ba8:	e0bffc17 	ldw	r2,-16(fp)
81110bac:	00003606 	br	81110c88 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81110bb0:	e03ffd05 	stb	zero,-12(fp)
81110bb4:	00002806 	br	81110c58 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
81110bb8:	e0fffd03 	ldbu	r3,-12(fp)
81110bbc:	00a04574 	movhi	r2,33045
81110bc0:	109f5a04 	addi	r2,r2,32104
81110bc4:	18c00b24 	muli	r3,r3,44
81110bc8:	10c5883a 	add	r2,r2,r3
81110bcc:	10800904 	addi	r2,r2,36
81110bd0:	10c0000b 	ldhu	r3,0(r2)
81110bd4:	e0bffe17 	ldw	r2,-8(fp)
81110bd8:	1080008b 	ldhu	r2,2(r2)
81110bdc:	18ffffcc 	andi	r3,r3,65535
81110be0:	10bfffcc 	andi	r2,r2,65535
81110be4:	1880191e 	bne	r3,r2,81110c4c <bCheckInAck32+0xfc>
            bFound = TRUE;
81110be8:	00800044 	movi	r2,1
81110bec:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
81110bf0:	e0fffd03 	ldbu	r3,-12(fp)
81110bf4:	00a045b4 	movhi	r2,33046
81110bf8:	10b1da04 	addi	r2,r2,-14488
81110bfc:	18c00384 	addi	r3,r3,14
81110c00:	18c7883a 	add	r3,r3,r3
81110c04:	18c7883a 	add	r3,r3,r3
81110c08:	10c5883a 	add	r2,r2,r3
81110c0c:	10000015 	stw	zero,0(r2)
            SemCount32++;
81110c10:	d0a06783 	ldbu	r2,-32354(gp)
81110c14:	10800044 	addi	r2,r2,1
81110c18:	d0a06785 	stb	r2,-32354(gp)
            error_code = OSSemPost(xSemCountBuffer32);
81110c1c:	d0a06e17 	ldw	r2,-32328(gp)
81110c20:	1009883a 	mov	r4,r2
81110c24:	113cea00 	call	8113cea0 <OSSemPost>
81110c28:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
81110c2c:	e0bffd43 	ldbu	r2,-11(fp)
81110c30:	10803fcc 	andi	r2,r2,255
81110c34:	10000c26 	beq	r2,zero,81110c68 <bCheckInAck32+0x118>
                SemCount32--;
81110c38:	d0a06783 	ldbu	r2,-32354(gp)
81110c3c:	10bfffc4 	addi	r2,r2,-1
81110c40:	d0a06785 	stb	r2,-32354(gp)
                vFailSetCountSemaphorexBuffer32();
81110c44:	1119fdc0 	call	81119fdc <vFailSetCountSemaphorexBuffer32>
            }
            break;
81110c48:	00000706 	br	81110c68 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
81110c4c:	e0bffd03 	ldbu	r2,-12(fp)
81110c50:	10800044 	addi	r2,r2,1
81110c54:	e0bffd05 	stb	r2,-12(fp)
81110c58:	e0bffd03 	ldbu	r2,-12(fp)
81110c5c:	10800230 	cmpltui	r2,r2,8
81110c60:	103fd51e 	bne	r2,zero,81110bb8 <__reset+0xfb0f0bb8>
81110c64:	00000106 	br	81110c6c <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
81110c68:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
81110c6c:	d0a06b17 	ldw	r2,-32340(gp)
81110c70:	1009883a 	mov	r4,r2
81110c74:	113b0b00 	call	8113b0b0 <OSMutexPost>
    (*bFinished) = TRUE;
81110c78:	e0bfff17 	ldw	r2,-4(fp)
81110c7c:	00c00044 	movi	r3,1
81110c80:	10c00015 	stw	r3,0(r2)

    return bFound;
81110c84:	e0bffc17 	ldw	r2,-16(fp)
}
81110c88:	e037883a 	mov	sp,fp
81110c8c:	dfc00117 	ldw	ra,4(sp)
81110c90:	df000017 	ldw	fp,0(sp)
81110c94:	dec00204 	addi	sp,sp,8
81110c98:	f800283a 	ret

81110c9c <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
81110c9c:	defff704 	addi	sp,sp,-36
81110ca0:	de00012e 	bgeu	sp,et,81110ca8 <vInitialTask+0xc>
81110ca4:	003b68fa 	trap	3
81110ca8:	dfc00815 	stw	ra,32(sp)
81110cac:	df000715 	stw	fp,28(sp)
81110cb0:	df000704 	addi	fp,sp,28
81110cb4:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
81110cb8:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
81110cbc:	d8000415 	stw	zero,16(sp)
81110cc0:	d8000315 	stw	zero,12(sp)
81110cc4:	00810004 	movi	r2,1024
81110cc8:	d8800215 	stw	r2,8(sp)
81110ccc:	00a04574 	movhi	r2,33045
81110cd0:	10859e04 	addi	r2,r2,5752
81110cd4:	d8800115 	stw	r2,4(sp)
81110cd8:	008002c4 	movi	r2,11
81110cdc:	d8800015 	stw	r2,0(sp)
81110ce0:	01c002c4 	movi	r7,11
81110ce4:	01a04574 	movhi	r6,33045
81110ce8:	31899d04 	addi	r6,r6,9844
81110cec:	01604574 	movhi	r5,33045
81110cf0:	295abe04 	addi	r5,r5,27384
81110cf4:	01204474 	movhi	r4,33041
81110cf8:	21358204 	addi	r4,r4,-10744
81110cfc:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110d00:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110d04:	e0bffe03 	ldbu	r2,-8(fp)
81110d08:	10803fcc 	andi	r2,r2,255
81110d0c:	10000526 	beq	r2,zero,81110d24 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110d10:	e0bffe03 	ldbu	r2,-8(fp)
81110d14:	10803fcc 	andi	r2,r2,255
81110d18:	1009883a 	mov	r4,r2
81110d1c:	11199580 	call	81119958 <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
81110d20:	111ae040 	call	8111ae04 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110d24:	01c17704 	movi	r7,1500
81110d28:	000d883a 	mov	r6,zero
81110d2c:	000b883a 	mov	r5,zero
81110d30:	0009883a 	mov	r4,zero
81110d34:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
81110d38:	d8000415 	stw	zero,16(sp)
81110d3c:	d8000315 	stw	zero,12(sp)
81110d40:	00810004 	movi	r2,1024
81110d44:	d8800215 	stw	r2,8(sp)
81110d48:	00a04574 	movhi	r2,33045
81110d4c:	1096ac04 	addi	r2,r2,23216
81110d50:	d8800115 	stw	r2,4(sp)
81110d54:	00800284 	movi	r2,10
81110d58:	d8800015 	stw	r2,0(sp)
81110d5c:	01c00284 	movi	r7,10
81110d60:	01a04574 	movhi	r6,33045
81110d64:	319aab04 	addi	r6,r6,27308
81110d68:	01604574 	movhi	r5,33045
81110d6c:	295ab604 	addi	r5,r5,27352
81110d70:	01204474 	movhi	r4,33041
81110d74:	21355a04 	addi	r4,r4,-10904
81110d78:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110d7c:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110d80:	e0bffe03 	ldbu	r2,-8(fp)
81110d84:	10803fcc 	andi	r2,r2,255
81110d88:	10000526 	beq	r2,zero,81110da0 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110d8c:	e0bffe03 	ldbu	r2,-8(fp)
81110d90:	10803fcc 	andi	r2,r2,255
81110d94:	1009883a 	mov	r4,r2
81110d98:	11199580 	call	81119958 <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
81110d9c:	111b0dc0 	call	8111b0dc <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110da0:	01c17704 	movi	r7,1500
81110da4:	000d883a 	mov	r6,zero
81110da8:	000b883a 	mov	r5,zero
81110dac:	0009883a 	mov	r4,zero
81110db0:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
81110db4:	d8000415 	stw	zero,16(sp)
81110db8:	d8000315 	stw	zero,12(sp)
81110dbc:	00810004 	movi	r2,1024
81110dc0:	d8800215 	stw	r2,8(sp)
81110dc4:	00a045b4 	movhi	r2,33046
81110dc8:	10b2e204 	addi	r2,r2,-13432
81110dcc:	d8800115 	stw	r2,4(sp)
81110dd0:	00800244 	movi	r2,9
81110dd4:	d8800015 	stw	r2,0(sp)
81110dd8:	01c00244 	movi	r7,9
81110ddc:	01a045b4 	movhi	r6,33046
81110de0:	31b6e104 	addi	r6,r6,-9340
81110de4:	01604574 	movhi	r5,33045
81110de8:	295abe04 	addi	r5,r5,27384
81110dec:	01204474 	movhi	r4,33041
81110df0:	21048804 	addi	r4,r4,4640
81110df4:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110df8:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110dfc:	e0bffe03 	ldbu	r2,-8(fp)
81110e00:	10803fcc 	andi	r2,r2,255
81110e04:	10000526 	beq	r2,zero,81110e1c <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110e08:	e0bffe03 	ldbu	r2,-8(fp)
81110e0c:	10803fcc 	andi	r2,r2,255
81110e10:	1009883a 	mov	r4,r2
81110e14:	11199580 	call	81119958 <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
81110e18:	111b0740 	call	8111b074 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110e1c:	01c17704 	movi	r7,1500
81110e20:	000d883a 	mov	r6,zero
81110e24:	000b883a 	mov	r5,zero
81110e28:	0009883a 	mov	r4,zero
81110e2c:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
81110e30:	d8000415 	stw	zero,16(sp)
81110e34:	d8000315 	stw	zero,12(sp)
81110e38:	00810004 	movi	r2,1024
81110e3c:	d8800215 	stw	r2,8(sp)
81110e40:	00a045b4 	movhi	r2,33046
81110e44:	10850404 	addi	r2,r2,5136
81110e48:	d8800115 	stw	r2,4(sp)
81110e4c:	00800204 	movi	r2,8
81110e50:	d8800015 	stw	r2,0(sp)
81110e54:	01c00204 	movi	r7,8
81110e58:	01a045b4 	movhi	r6,33046
81110e5c:	31890304 	addi	r6,r6,9228
81110e60:	01604574 	movhi	r5,33045
81110e64:	295aac04 	addi	r5,r5,27312
81110e68:	01204474 	movhi	r4,33041
81110e6c:	210e2b04 	addi	r4,r4,14508
81110e70:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110e74:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110e78:	e0bffe03 	ldbu	r2,-8(fp)
81110e7c:	10803fcc 	andi	r2,r2,255
81110e80:	10000526 	beq	r2,zero,81110e98 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110e84:	e0bffe03 	ldbu	r2,-8(fp)
81110e88:	10803fcc 	andi	r2,r2,255
81110e8c:	1009883a 	mov	r4,r2
81110e90:	11199580 	call	81119958 <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
81110e94:	111b1440 	call	8111b144 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
81110e98:	01c17704 	movi	r7,1500
81110e9c:	000d883a 	mov	r6,zero
81110ea0:	000b883a 	mov	r5,zero
81110ea4:	0009883a 	mov	r4,zero
81110ea8:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
81110eac:	d8000415 	stw	zero,16(sp)
81110eb0:	d8000315 	stw	zero,12(sp)
81110eb4:	00810004 	movi	r2,1024
81110eb8:	d8800215 	stw	r2,8(sp)
81110ebc:	00a04574 	movhi	r2,33045
81110ec0:	1092ac04 	addi	r2,r2,19120
81110ec4:	d8800115 	stw	r2,4(sp)
81110ec8:	00800784 	movi	r2,30
81110ecc:	d8800015 	stw	r2,0(sp)
81110ed0:	01c00784 	movi	r7,30
81110ed4:	01a04574 	movhi	r6,33045
81110ed8:	3196ab04 	addi	r6,r6,23212
81110edc:	000b883a 	mov	r5,zero
81110ee0:	01204474 	movhi	r4,33041
81110ee4:	2114e904 	addi	r4,r4,21412
81110ee8:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110eec:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110ef0:	e0bffe03 	ldbu	r2,-8(fp)
81110ef4:	10803fcc 	andi	r2,r2,255
81110ef8:	10000526 	beq	r2,zero,81110f10 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110efc:	e0bffe03 	ldbu	r2,-8(fp)
81110f00:	10803fcc 	andi	r2,r2,255
81110f04:	1009883a 	mov	r4,r2
81110f08:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
81110f0c:	111a7700 	call	8111a770 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81110f10:	01c03204 	movi	r7,200
81110f14:	000d883a 	mov	r6,zero
81110f18:	000b883a 	mov	r5,zero
81110f1c:	0009883a 	mov	r4,zero
81110f20:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
81110f24:	d8000415 	stw	zero,16(sp)
81110f28:	d8000315 	stw	zero,12(sp)
81110f2c:	00810004 	movi	r2,1024
81110f30:	d8800215 	stw	r2,8(sp)
81110f34:	00a045b4 	movhi	r2,33046
81110f38:	10a5c204 	addi	r2,r2,-26872
81110f3c:	d8800115 	stw	r2,4(sp)
81110f40:	008006c4 	movi	r2,27
81110f44:	d8800015 	stw	r2,0(sp)
81110f48:	01c006c4 	movi	r7,27
81110f4c:	01a045b4 	movhi	r6,33046
81110f50:	31a9c104 	addi	r6,r6,-22780
81110f54:	000b883a 	mov	r5,zero
81110f58:	01204474 	movhi	r4,33041
81110f5c:	21067104 	addi	r4,r4,6596
81110f60:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110f64:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110f68:	e0bffe03 	ldbu	r2,-8(fp)
81110f6c:	10803fcc 	andi	r2,r2,255
81110f70:	10000526 	beq	r2,zero,81110f88 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110f74:	e0bffe03 	ldbu	r2,-8(fp)
81110f78:	10803fcc 	andi	r2,r2,255
81110f7c:	1009883a 	mov	r4,r2
81110f80:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
81110f84:	111a68c0 	call	8111a68c <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81110f88:	01c03204 	movi	r7,200
81110f8c:	000d883a 	mov	r6,zero
81110f90:	000b883a 	mov	r5,zero
81110f94:	0009883a 	mov	r4,zero
81110f98:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
81110f9c:	d8000415 	stw	zero,16(sp)
81110fa0:	d8000315 	stw	zero,12(sp)
81110fa4:	00810004 	movi	r2,1024
81110fa8:	d8800215 	stw	r2,8(sp)
81110fac:	00a04574 	movhi	r2,33045
81110fb0:	10899e04 	addi	r2,r2,9848
81110fb4:	d8800115 	stw	r2,4(sp)
81110fb8:	00800644 	movi	r2,25
81110fbc:	d8800015 	stw	r2,0(sp)
81110fc0:	01c00644 	movi	r7,25
81110fc4:	01a04574 	movhi	r6,33045
81110fc8:	318d9d04 	addi	r6,r6,13940
81110fcc:	000b883a 	mov	r5,zero
81110fd0:	01204474 	movhi	r4,33041
81110fd4:	21015b04 	addi	r4,r4,1388
81110fd8:	113d8840 	call	8113d884 <OSTaskCreateExt>
81110fdc:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81110fe0:	e0bffe03 	ldbu	r2,-8(fp)
81110fe4:	10803fcc 	andi	r2,r2,255
81110fe8:	10000526 	beq	r2,zero,81111000 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81110fec:	e0bffe03 	ldbu	r2,-8(fp)
81110ff0:	10803fcc 	andi	r2,r2,255
81110ff4:	1009883a 	mov	r4,r2
81110ff8:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
81110ffc:	111a6400 	call	8111a640 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111000:	01c03204 	movi	r7,200
81111004:	000d883a 	mov	r6,zero
81111008:	000b883a 	mov	r5,zero
8111100c:	0009883a 	mov	r4,zero
81111010:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
81111014:	d8000415 	stw	zero,16(sp)
81111018:	d8000315 	stw	zero,12(sp)
8111101c:	00818004 	movi	r2,1536
81111020:	d8800215 	stw	r2,8(sp)
81111024:	00a045b4 	movhi	r2,33046
81111028:	10bf0004 	addi	r2,r2,-1024
8111102c:	d8800115 	stw	r2,4(sp)
81111030:	00800704 	movi	r2,28
81111034:	d8800015 	stw	r2,0(sp)
81111038:	01c00704 	movi	r7,28
8111103c:	01a045b4 	movhi	r6,33046
81111040:	3184ff04 	addi	r6,r6,5116
81111044:	000b883a 	mov	r5,zero
81111048:	01204474 	movhi	r4,33041
8111104c:	21072f04 	addi	r4,r4,7356
81111050:	113d8840 	call	8113d884 <OSTaskCreateExt>
81111054:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
81111058:	e0bffe03 	ldbu	r2,-8(fp)
8111105c:	10803fcc 	andi	r2,r2,255
81111060:	10000526 	beq	r2,zero,81111078 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
81111064:	e0bffe03 	ldbu	r2,-8(fp)
81111068:	10803fcc 	andi	r2,r2,255
8111106c:	1009883a 	mov	r4,r2
81111070:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
81111074:	111a5f40 	call	8111a5f4 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
81111078:	01c03204 	movi	r7,200
8111107c:	000d883a 	mov	r6,zero
81111080:	000b883a 	mov	r5,zero
81111084:	0009883a 	mov	r4,zero
81111088:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8111108c:	d8000415 	stw	zero,16(sp)
81111090:	d8000315 	stw	zero,12(sp)
81111094:	00818004 	movi	r2,1536
81111098:	d8800215 	stw	r2,8(sp)
8111109c:	00a04574 	movhi	r2,33045
811110a0:	109fb204 	addi	r2,r2,32456
811110a4:	d8800115 	stw	r2,4(sp)
811110a8:	00800804 	movi	r2,32
811110ac:	d8800015 	stw	r2,0(sp)
811110b0:	01c00804 	movi	r7,32
811110b4:	01a045b4 	movhi	r6,33046
811110b8:	31a5b104 	addi	r6,r6,-26940
811110bc:	000b883a 	mov	r5,zero
811110c0:	01204474 	movhi	r4,33041
811110c4:	210b4b04 	addi	r4,r4,11564
811110c8:	113d8840 	call	8113d884 <OSTaskCreateExt>
811110cc:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
811110d0:	e0bffe03 	ldbu	r2,-8(fp)
811110d4:	10803fcc 	andi	r2,r2,255
811110d8:	10000526 	beq	r2,zero,811110f0 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811110dc:	e0bffe03 	ldbu	r2,-8(fp)
811110e0:	10803fcc 	andi	r2,r2,255
811110e4:	1009883a 	mov	r4,r2
811110e8:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailReceiverCreate();
811110ec:	1119ef80 	call	81119ef8 <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
811110f0:	01c03204 	movi	r7,200
811110f4:	000d883a 	mov	r6,zero
811110f8:	000b883a 	mov	r5,zero
811110fc:	0009883a 	mov	r4,zero
81111100:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
81111104:	d8000415 	stw	zero,16(sp)
81111108:	d8000315 	stw	zero,12(sp)
8111110c:	00810004 	movi	r2,1024
81111110:	d8800215 	stw	r2,8(sp)
81111114:	00a04574 	movhi	r2,33045
81111118:	108e9a04 	addi	r2,r2,14952
8111111c:	d8800115 	stw	r2,4(sp)
81111120:	00800684 	movi	r2,26
81111124:	d8800015 	stw	r2,0(sp)
81111128:	01c00684 	movi	r7,26
8111112c:	01a04574 	movhi	r6,33045
81111130:	31929904 	addi	r6,r6,19044
81111134:	000b883a 	mov	r5,zero
81111138:	01204474 	movhi	r4,33041
8111113c:	210dcd04 	addi	r4,r4,14132
81111140:	113d8840 	call	8113d884 <OSTaskCreateExt>
81111144:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
81111148:	01c03204 	movi	r7,200
8111114c:	000d883a 	mov	r6,zero
81111150:	000b883a 	mov	r5,zero
81111154:	0009883a 	mov	r4,zero
81111158:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8111115c:	e0bffe03 	ldbu	r2,-8(fp)
81111160:	10803fcc 	andi	r2,r2,255
81111164:	10000526 	beq	r2,zero,8111117c <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
81111168:	e0bffe03 	ldbu	r2,-8(fp)
8111116c:	10803fcc 	andi	r2,r2,255
81111170:	1009883a 	mov	r4,r2
81111174:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailSenderCreate();
81111178:	1119f440 	call	81119f44 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8111117c:	d0a06c17 	ldw	r2,-32336(gp)
81111180:	e17ffe04 	addi	r5,fp,-8
81111184:	1009883a 	mov	r4,r2
81111188:	113f5a40 	call	8113f5a4 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8111118c:	e0bffe03 	ldbu	r2,-8(fp)
81111190:	10803fcc 	andi	r2,r2,255
81111194:	10000126 	beq	r2,zero,8111119c <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
81111198:	111aa2c0 	call	8111aa2c <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8111119c:	01c00084 	movi	r7,2
811111a0:	01800784 	movi	r6,30
811111a4:	000b883a 	mov	r5,zero
811111a8:	0009883a 	mov	r4,zero
811111ac:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
811111b0:	01003fc4 	movi	r4,255
811111b4:	113da700 	call	8113da70 <OSTaskDel>
811111b8:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
811111bc:	e0bffe03 	ldbu	r2,-8(fp)
811111c0:	10803fcc 	andi	r2,r2,255
811111c4:	10001026 	beq	r2,zero,81111208 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
811111c8:	e0bffe03 	ldbu	r2,-8(fp)
811111cc:	10803fcc 	andi	r2,r2,255
811111d0:	1009883a 	mov	r4,r2
811111d4:	11199580 	call	81119958 <printErrorTask>
		#endif
		vFailDeleteInitialization();
811111d8:	1119f900 	call	81119f90 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
811111dc:	014009c4 	movi	r5,39
811111e0:	01000044 	movi	r4,1
811111e4:	113d1d80 	call	8113d1d8 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
811111e8:	01003fc4 	movi	r4,255
811111ec:	113da700 	call	8113da70 <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
811111f0:	000f883a 	mov	r7,zero
811111f4:	01800284 	movi	r6,10
811111f8:	000b883a 	mov	r5,zero
811111fc:	0009883a 	mov	r4,zero
81111200:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
		}
81111204:	003ff806 	br	811111e8 <__reset+0xfb0f11e8>
	}

}
81111208:	0001883a 	nop
8111120c:	e037883a 	mov	sp,fp
81111210:	dfc00117 	ldw	ra,4(sp)
81111214:	df000017 	ldw	fp,0(sp)
81111218:	dec00204 	addi	sp,sp,8
8111121c:	f800283a 	ret

81111220 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
81111220:	defff804 	addi	sp,sp,-32
81111224:	de00012e 	bgeu	sp,et,8111122c <vNFeeControlTask+0xc>
81111228:	003b68fa 	trap	3
8111122c:	dfc00715 	stw	ra,28(sp)
81111230:	df000615 	stw	fp,24(sp)
81111234:	df000604 	addi	fp,sp,24
81111238:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	static unsigned char ucWhoGetDMA;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8111123c:	e0bfff17 	ldw	r2,-4(fp)
81111240:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
81111244:	d0a06117 	ldw	r2,-32380(gp)
81111248:	100f883a 	mov	r7,r2
8111124c:	01800804 	movi	r6,32
81111250:	01400044 	movi	r5,1
81111254:	01204574 	movhi	r4,33045
81111258:	212c4604 	addi	r4,r4,-20200
8111125c:	111fc980 	call	8111fc98 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
81111260:	e0bffb17 	ldw	r2,-20(fp)
81111264:	10809a17 	ldw	r2,616(r2)
81111268:	10c00168 	cmpgeui	r3,r2,5
8111126c:	1800e81e 	bne	r3,zero,81111610 <vNFeeControlTask+0x3f0>
81111270:	100690ba 	slli	r3,r2,2
81111274:	00a04474 	movhi	r2,33041
81111278:	1084a204 	addi	r2,r2,4744
8111127c:	1885883a 	add	r2,r3,r2
81111280:	10800017 	ldw	r2,0(r2)
81111284:	1000683a 	jmp	r2
81111288:	8111129c 	xori	r4,r16,17482
8111128c:	811112cc 	andi	r4,r16,17483
81111290:	8111132c 	andhi	r4,r16,17484
81111294:	811113e0 	cmpeqi	r4,r16,17487
81111298:	81111440 	call	88111144 <__reset+0x20f1144>
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
8111129c:	d0a06f17 	ldw	r2,-32324(gp)
811112a0:	1009883a 	mov	r4,r2
811112a4:	113bb600 	call	8113bb60 <OSQFlush>
811112a8:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811112ac:	e0bffe03 	ldbu	r2,-8(fp)
811112b0:	10803fcc 	andi	r2,r2,255
811112b4:	10000126 	beq	r2,zero,811112bc <vNFeeControlTask+0x9c>
					vFailFlushQueue();
811112b8:	111b7880 	call	8111b788 <vFailFlushQueue>
				}

				pxFeeC->sMode = sMebToConfig;
811112bc:	e0bffb17 	ldw	r2,-20(fp)
811112c0:	00c00044 	movi	r3,1
811112c4:	10c09a15 	stw	r3,616(r2)
				break;
811112c8:	0000dd06 	br	81111640 <vNFeeControlTask+0x420>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
811112cc:	d0a06117 	ldw	r2,-32380(gp)
811112d0:	100f883a 	mov	r7,r2
811112d4:	018008c4 	movi	r6,35
811112d8:	01400044 	movi	r5,1
811112dc:	01204574 	movhi	r4,33045
811112e0:	212c4f04 	addi	r4,r4,-20164
811112e4:	111fc980 	call	8111fc98 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
811112e8:	d0a05c17 	ldw	r2,-32400(gp)
811112ec:	1009883a 	mov	r4,r2
811112f0:	113bb600 	call	8113bb60 <OSQFlush>
811112f4:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
811112f8:	e0bffe03 	ldbu	r2,-8(fp)
811112fc:	10803fcc 	andi	r2,r2,255
81111300:	10000126 	beq	r2,zero,81111308 <vNFeeControlTask+0xe8>
					vFailFlushQueue();
81111304:	111b7880 	call	8111b788 <vFailFlushQueue>
				}

				bCmdSent = FALSE;
81111308:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
8111130c:	00800044 	movi	r2,1
81111310:	d0a05715 	stw	r2,-32420(gp)
				ucWhoGetDMA = 255;
81111314:	00bfffc4 	movi	r2,-1
81111318:	d0a05805 	stb	r2,-32416(gp)
				pxFeeC->sMode = sMebConfig;
8111131c:	e0bffb17 	ldw	r2,-20(fp)
81111320:	00c000c4 	movi	r3,3
81111324:	10c09a15 	stw	r3,616(r2)
				break;
81111328:	0000c506 	br	81111640 <vNFeeControlTask+0x420>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8111132c:	111b8e00 	call	8111b8e0 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
81111330:	d0a06117 	ldw	r2,-32380(gp)
81111334:	100f883a 	mov	r7,r2
81111338:	01800804 	movi	r6,32
8111133c:	01400044 	movi	r5,1
81111340:	01204574 	movhi	r4,33045
81111344:	212c5804 	addi	r4,r4,-20128
81111348:	111fc980 	call	8111fc98 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8111134c:	d0a05c17 	ldw	r2,-32400(gp)
81111350:	1009883a 	mov	r4,r2
81111354:	113bb600 	call	8113bb60 <OSQFlush>
81111358:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8111135c:	e0bffe03 	ldbu	r2,-8(fp)
81111360:	10803fcc 	andi	r2,r2,255
81111364:	10000126 	beq	r2,zero,8111136c <vNFeeControlTask+0x14c>
					vFailFlushQueue();
81111368:	111b7880 	call	8111b788 <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8111136c:	e03ffa45 	stb	zero,-23(fp)
81111370:	00001006 	br	811113b4 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81111374:	e0bffa43 	ldbu	r2,-23(fp)
81111378:	1085883a 	add	r2,r2,r2
8111137c:	1087883a 	add	r3,r2,r2
81111380:	d0a06904 	addi	r2,gp,-32348
81111384:	1885883a 	add	r2,r3,r2
81111388:	10800017 	ldw	r2,0(r2)
8111138c:	1009883a 	mov	r4,r2
81111390:	113bb600 	call	8113bb60 <OSQFlush>
81111394:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
81111398:	e0bffe03 	ldbu	r2,-8(fp)
8111139c:	10803fcc 	andi	r2,r2,255
811113a0:	10000126 	beq	r2,zero,811113a8 <vNFeeControlTask+0x188>
						vFailFlushQueue();
811113a4:	111b7880 	call	8111b788 <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
811113a8:	e0bffa43 	ldbu	r2,-23(fp)
811113ac:	10800044 	addi	r2,r2,1
811113b0:	e0bffa45 	stb	r2,-23(fp)
811113b4:	e0bffa43 	ldbu	r2,-23(fp)
811113b8:	103fee26 	beq	r2,zero,81111374 <__reset+0xfb0f1374>
					if ( error_codeCtrl != OS_NO_ERR ) {
						vFailFlushQueue();
					}
				}

				bCmdSent = FALSE;
811113bc:	e03ffc15 	stw	zero,-16(fp)
				bDmaBack = TRUE;
811113c0:	00800044 	movi	r2,1
811113c4:	d0a05715 	stw	r2,-32420(gp)
				ucWhoGetDMA = 255;
811113c8:	00bfffc4 	movi	r2,-1
811113cc:	d0a05805 	stb	r2,-32416(gp)
				pxFeeC->sMode = sMebRun;
811113d0:	e0bffb17 	ldw	r2,-20(fp)
811113d4:	00c00104 	movi	r3,4
811113d8:	10c09a15 	stw	r3,616(r2)
				break;
811113dc:	00009806 	br	81111640 <vNFeeControlTask+0x420>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
811113e0:	d0a06f17 	ldw	r2,-32324(gp)
811113e4:	e0fffe04 	addi	r3,fp,-8
811113e8:	180d883a 	mov	r6,r3
811113ec:	000b883a 	mov	r5,zero
811113f0:	1009883a 	mov	r4,r2
811113f4:	113bc200 	call	8113bc20 <OSQPend>
811113f8:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
811113fc:	e0bffe03 	ldbu	r2,-8(fp)
81111400:	10803fcc 	andi	r2,r2,255
81111404:	10000c1e 	bne	r2,zero,81111438 <vNFeeControlTask+0x218>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81111408:	e0bffdc3 	ldbu	r2,-9(fp)
8111140c:	10803fcc 	andi	r2,r2,255
81111410:	10800418 	cmpnei	r2,r2,16
81111414:	1000041e 	bne	r2,zero,81111428 <vNFeeControlTask+0x208>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
81111418:	e0bffd17 	ldw	r2,-12(fp)
8111141c:	e17ffb17 	ldw	r5,-20(fp)
81111420:	1009883a 	mov	r4,r2
81111424:	11116440 	call	81111644 <vPerformActionNFCConfig>

					};
					bCmdSent = FALSE;
81111428:	e03ffc15 	stw	zero,-16(fp)
					bDmaBack = TRUE;
8111142c:	00800044 	movi	r2,1
81111430:	d0a05715 	stw	r2,-32420(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81111434:	00008206 	br	81111640 <vNFeeControlTask+0x420>
					};
					bCmdSent = FALSE;
					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81111438:	111b3dc0 	call	8111b3dc <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
8111143c:	00008006 	br	81111640 <vNFeeControlTask+0x420>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
81111440:	d0a05717 	ldw	r2,-32420(gp)
81111444:	10800058 	cmpnei	r2,r2,1
81111448:	1000221e 	bne	r2,zero,811114d4 <vNFeeControlTask+0x2b4>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
8111144c:	d0a05c17 	ldw	r2,-32400(gp)
81111450:	e0fffe04 	addi	r3,fp,-8
81111454:	180d883a 	mov	r6,r3
81111458:	01400104 	movi	r5,4
8111145c:	1009883a 	mov	r4,r2
81111460:	113bc200 	call	8113bc20 <OSQPend>
81111464:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81111468:	e0bffe03 	ldbu	r2,-8(fp)
8111146c:	10803fcc 	andi	r2,r2,255
81111470:	1000181e 	bne	r2,zero,811114d4 <vNFeeControlTask+0x2b4>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81111474:	e0bffd03 	ldbu	r2,-12(fp)
81111478:	e0bffa05 	stb	r2,-24(fp)


						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
8111147c:	e0bffa03 	ldbu	r2,-24(fp)
81111480:	e0fffb17 	ldw	r3,-20(fp)
81111484:	10809624 	muli	r2,r2,600
81111488:	1885883a 	add	r2,r3,r2
8111148c:	10802304 	addi	r2,r2,140
81111490:	10800017 	ldw	r2,0(r2)
81111494:	10800058 	cmpnei	r2,r2,1
81111498:	10000e1e 	bne	r2,zero,811114d4 <vNFeeControlTask+0x2b4>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
8111149c:	e0bffa03 	ldbu	r2,-24(fp)
811114a0:	e0fffa03 	ldbu	r3,-24(fp)
811114a4:	180f883a 	mov	r7,r3
811114a8:	000d883a 	mov	r6,zero
811114ac:	014023c4 	movi	r5,143
811114b0:	1009883a 	mov	r4,r2
811114b4:	11118340 	call	81111834 <bSendCmdQToNFeeInst>
811114b8:	e0bffc15 	stw	r2,-16(fp)
							if ( bCmdSent == TRUE ) {
811114bc:	e0bffc17 	ldw	r2,-16(fp)
811114c0:	10800058 	cmpnei	r2,r2,1
811114c4:	1000031e 	bne	r2,zero,811114d4 <vNFeeControlTask+0x2b4>
								bDmaBack = FALSE;
811114c8:	d0205715 	stw	zero,-32420(gp)
								ucWhoGetDMA = ucFeeInstL;
811114cc:	e0bffa03 	ldbu	r2,-24(fp)
811114d0:	d0a05805 	stb	r2,-32416(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
811114d4:	d0a05717 	ldw	r2,-32420(gp)
811114d8:	1000081e 	bne	r2,zero,811114fc <vNFeeControlTask+0x2dc>

					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
811114dc:	d0a06f17 	ldw	r2,-32324(gp)
811114e0:	e0fffe04 	addi	r3,fp,-8
811114e4:	180d883a 	mov	r6,r3
811114e8:	000b883a 	mov	r5,zero
811114ec:	1009883a 	mov	r4,r2
811114f0:	113bc200 	call	8113bc20 <OSQPend>
811114f4:	e0bffd15 	stw	r2,-12(fp)
811114f8:	00000706 	br	81111518 <vNFeeControlTask+0x2f8>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
811114fc:	d0a06f17 	ldw	r2,-32324(gp)
81111500:	e0fffe04 	addi	r3,fp,-8
81111504:	180d883a 	mov	r6,r3
81111508:	01400104 	movi	r5,4
8111150c:	1009883a 	mov	r4,r2
81111510:	113bc200 	call	8113bc20 <OSQPend>
81111514:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
81111518:	e0bffe03 	ldbu	r2,-8(fp)
8111151c:	10803fcc 	andi	r2,r2,255
81111520:	10002c1e 	bne	r2,zero,811115d4 <vNFeeControlTask+0x3b4>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81111524:	e0bffd83 	ldbu	r2,-10(fp)
81111528:	10803fcc 	andi	r2,r2,255
8111152c:	10802058 	cmpnei	r2,r2,129
81111530:	1000091e 	bne	r2,zero,81111558 <vNFeeControlTask+0x338>
						if ( uiCmdNFC.ucByte[0] == ucFeeInstL ){
81111534:	e0bffd03 	ldbu	r2,-12(fp)
81111538:	10c03fcc 	andi	r3,r2,255
8111153c:	e0bffa03 	ldbu	r2,-24(fp)
81111540:	1880241e 	bne	r3,r2,811115d4 <vNFeeControlTask+0x3b4>
							bDmaBack = TRUE;
81111544:	00800044 	movi	r2,1
81111548:	d0a05715 	stw	r2,-32420(gp)
							ucFeeInstL = 255;
8111154c:	00bfffc4 	movi	r2,-1
81111550:	e0bffa05 	stb	r2,-24(fp)
81111554:	00001f06 	br	811115d4 <vNFeeControlTask+0x3b4>
						}

					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81111558:	e0bffdc3 	ldbu	r2,-9(fp)
8111155c:	10803fcc 	andi	r2,r2,255
81111560:	10800418 	cmpnei	r2,r2,16
81111564:	1000051e 	bne	r2,zero,8111157c <vNFeeControlTask+0x35c>
							
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81111568:	e0bffd17 	ldw	r2,-12(fp)
8111156c:	e17ffb17 	ldw	r5,-20(fp)
81111570:	1009883a 	mov	r4,r2
81111574:	111170c0 	call	8111170c <vPerformActionNFCRunning>
81111578:	00001606 	br	811115d4 <vNFeeControlTask+0x3b4>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
8111157c:	e0bffdc3 	ldbu	r2,-9(fp)
81111580:	10803fcc 	andi	r2,r2,255
81111584:	10800470 	cmpltui	r2,r2,17
81111588:	1000121e 	bne	r2,zero,811115d4 <vNFeeControlTask+0x3b4>
8111158c:	e0bffdc3 	ldbu	r2,-9(fp)
81111590:	10803fcc 	andi	r2,r2,255
81111594:	108004e8 	cmpgeui	r2,r2,19
81111598:	10000e1e 	bne	r2,zero,811115d4 <vNFeeControlTask+0x3b4>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
8111159c:	e0bffdc3 	ldbu	r2,-9(fp)
811115a0:	10bffbc4 	addi	r2,r2,-17
811115a4:	10803fcc 	andi	r2,r2,255
811115a8:	e0fffd83 	ldbu	r3,-10(fp)
811115ac:	18c03fcc 	andi	r3,r3,255
811115b0:	e13ffd43 	ldbu	r4,-11(fp)
811115b4:	21003fcc 	andi	r4,r4,255
811115b8:	e17ffd03 	ldbu	r5,-12(fp)
811115bc:	29403fcc 	andi	r5,r5,255
811115c0:	280f883a 	mov	r7,r5
811115c4:	200d883a 	mov	r6,r4
811115c8:	180b883a 	mov	r5,r3
811115cc:	1009883a 	mov	r4,r2
811115d0:	11118340 	call	81111834 <bSendCmdQToNFeeInst>

							}
						}
					}
				}
				if ( xDefaults.usiDelay == 0 ) {
811115d4:	00a045b4 	movhi	r2,33046
811115d8:	1091bc04 	addi	r2,r2,18160
811115dc:	1080070b 	ldhu	r2,28(r2)
811115e0:	10bfffcc 	andi	r2,r2,65535
811115e4:	1000151e 	bne	r2,zero,8111163c <vNFeeControlTask+0x41c>
					OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
811115e8:	00a045b4 	movhi	r2,33046
811115ec:	1091bc04 	addi	r2,r2,18160
811115f0:	1080070b 	ldhu	r2,28(r2)
811115f4:	10bfffcc 	andi	r2,r2,65535
811115f8:	100f883a 	mov	r7,r2
811115fc:	000d883a 	mov	r6,zero
81111600:	000b883a 	mov	r5,zero
81111604:	0009883a 	mov	r4,zero
81111608:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
				}
				
				break;		
8111160c:	00000b06 	br	8111163c <vNFeeControlTask+0x41c>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
81111610:	d0a06117 	ldw	r2,-32380(gp)
81111614:	100f883a 	mov	r7,r2
81111618:	01800f44 	movi	r6,61
8111161c:	01400044 	movi	r5,1
81111620:	01204574 	movhi	r4,33045
81111624:	212c6104 	addi	r4,r4,-20092
81111628:	111fc980 	call	8111fc98 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
8111162c:	e0bffb17 	ldw	r2,-20(fp)
81111630:	00c000c4 	movi	r3,3
81111634:	10c09a15 	stw	r3,616(r2)
				break;
81111638:	00000106 	br	81111640 <vNFeeControlTask+0x420>
				}
				if ( xDefaults.usiDelay == 0 ) {
					OSTimeDlyHMSM(0,0,0,xDefaults.usiDelay); /*remover depois dos testes !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				}
				
				break;		
8111163c:	0001883a 	nop
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
				break;
		}
	}
81111640:	003f0706 	br	81111260 <__reset+0xfb0f1260>

81111644 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
81111644:	defffb04 	addi	sp,sp,-20
81111648:	de00012e 	bgeu	sp,et,81111650 <vPerformActionNFCConfig+0xc>
8111164c:	003b68fa 	trap	3
81111650:	dfc00415 	stw	ra,16(sp)
81111654:	df000315 	stw	fp,12(sp)
81111658:	df000304 	addi	fp,sp,12
8111165c:	e13ffe15 	stw	r4,-8(fp)
81111660:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81111664:	e0bffe17 	ldw	r2,-8(fp)
81111668:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
8111166c:	e0bffd83 	ldbu	r2,-10(fp)
81111670:	10803fcc 	andi	r2,r2,255
81111674:	10c000a0 	cmpeqi	r3,r2,2
81111678:	1800121e 	bne	r3,zero,811116c4 <vPerformActionNFCConfig+0x80>
8111167c:	10c000c8 	cmpgei	r3,r2,3
81111680:	1800031e 	bne	r3,zero,81111690 <vPerformActionNFCConfig+0x4c>
81111684:	10800060 	cmpeqi	r2,r2,1
81111688:	1000061e 	bne	r2,zero,811116a4 <vPerformActionNFCConfig+0x60>
8111168c:	00001106 	br	811116d4 <vPerformActionNFCConfig+0x90>
81111690:	10c02860 	cmpeqi	r3,r2,161
81111694:	1800031e 	bne	r3,zero,811116a4 <vPerformActionNFCConfig+0x60>
81111698:	108028a0 	cmpeqi	r2,r2,162
8111169c:	1000091e 	bne	r2,zero,811116c4 <vPerformActionNFCConfig+0x80>
811116a0:	00000c06 	br	811116d4 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
811116a4:	d0a06117 	ldw	r2,-32380(gp)
811116a8:	100f883a 	mov	r7,r2
811116ac:	01800d44 	movi	r6,53
811116b0:	01400044 	movi	r5,1
811116b4:	01204574 	movhi	r4,33045
811116b8:	212c7104 	addi	r4,r4,-20028
811116bc:	111fc980 	call	8111fc98 <fwrite>
			#endif
			/* Do nothing for now */
			break;
811116c0:	00000c06 	br	811116f4 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
811116c4:	e0bfff17 	ldw	r2,-4(fp)
811116c8:	00c00084 	movi	r3,2
811116cc:	10c09a15 	stw	r3,616(r2)
			break;
811116d0:	00000806 	br	811116f4 <vPerformActionNFCConfig+0xb0>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
811116d4:	d0a06117 	ldw	r2,-32380(gp)
811116d8:	100f883a 	mov	r7,r2
811116dc:	018009c4 	movi	r6,39
811116e0:	01400044 	movi	r5,1
811116e4:	01204574 	movhi	r4,33045
811116e8:	212c7f04 	addi	r4,r4,-19972
811116ec:	111fc980 	call	8111fc98 <fwrite>
			#endif	
			break;
811116f0:	0001883a 	nop
	}

}
811116f4:	0001883a 	nop
811116f8:	e037883a 	mov	sp,fp
811116fc:	dfc00117 	ldw	ra,4(sp)
81111700:	df000017 	ldw	fp,0(sp)
81111704:	dec00204 	addi	sp,sp,8
81111708:	f800283a 	ret

8111170c <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
8111170c:	defffa04 	addi	sp,sp,-24
81111710:	de00012e 	bgeu	sp,et,81111718 <vPerformActionNFCRunning+0xc>
81111714:	003b68fa 	trap	3
81111718:	dfc00515 	stw	ra,20(sp)
8111171c:	df000415 	stw	fp,16(sp)
81111720:	df000404 	addi	fp,sp,16
81111724:	e13ffe15 	stw	r4,-8(fp)
81111728:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
8111172c:	e0bffe17 	ldw	r2,-8(fp)
81111730:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81111734:	e0bffd83 	ldbu	r2,-10(fp)
81111738:	10803fcc 	andi	r2,r2,255
8111173c:	10c02088 	cmpgei	r3,r2,130
81111740:	1800071e 	bne	r3,zero,81111760 <vPerformActionNFCRunning+0x54>
81111744:	10c02008 	cmpgei	r3,r2,128
81111748:	1800331e 	bne	r3,zero,81111818 <vPerformActionNFCRunning+0x10c>
8111174c:	10c00060 	cmpeqi	r3,r2,1
81111750:	1800051e 	bne	r3,zero,81111768 <vPerformActionNFCRunning+0x5c>
81111754:	108000a0 	cmpeqi	r2,r2,2
81111758:	10001f1e 	bne	r2,zero,811117d8 <vPerformActionNFCRunning+0xcc>
8111175c:	00002606 	br	811117f8 <vPerformActionNFCRunning+0xec>
81111760:	10802860 	cmpeqi	r2,r2,161
81111764:	10002426 	beq	r2,zero,811117f8 <vPerformActionNFCRunning+0xec>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;
81111768:	e0bfff17 	ldw	r2,-4(fp)
8111176c:	00c00044 	movi	r3,1
81111770:	10c09a15 	stw	r3,616(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81111774:	e03ffc05 	stb	zero,-16(fp)
81111778:	00001406 	br	811117cc <vPerformActionNFCRunning+0xc0>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
8111177c:	e0bffc03 	ldbu	r2,-16(fp)
81111780:	e0ffff17 	ldw	r3,-4(fp)
81111784:	108025c4 	addi	r2,r2,151
81111788:	1085883a 	add	r2,r2,r2
8111178c:	1085883a 	add	r2,r2,r2
81111790:	1885883a 	add	r2,r3,r2
81111794:	10800017 	ldw	r2,0(r2)
81111798:	10800017 	ldw	r2,0(r2)
8111179c:	10800058 	cmpnei	r2,r2,1
811117a0:	1000071e 	bne	r2,zero,811117c0 <vPerformActionNFCRunning+0xb4>
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
811117a4:	e0bffc03 	ldbu	r2,-16(fp)
811117a8:	e0fffc03 	ldbu	r3,-16(fp)
811117ac:	180f883a 	mov	r7,r3
811117b0:	000d883a 	mov	r6,zero
811117b4:	01402844 	movi	r5,161
811117b8:	1009883a 	mov	r4,r2
811117bc:	11118fc0 	call	811118fc <bSendCmdQToNFeeInst_Prio>
		case M_NFC_CONFIG_FORCED:

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
811117c0:	e0bffc03 	ldbu	r2,-16(fp)
811117c4:	10800044 	addi	r2,r2,1
811117c8:	e0bffc05 	stb	r2,-16(fp)
811117cc:	e0bffc03 	ldbu	r2,-16(fp)
811117d0:	103fea26 	beq	r2,zero,8111177c <__reset+0xfb0f177c>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst_Prio( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
811117d4:	00001106 	br	8111181c <vPerformActionNFCRunning+0x110>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
811117d8:	d0a06117 	ldw	r2,-32380(gp)
811117dc:	100f883a 	mov	r7,r2
811117e0:	01800d84 	movi	r6,54
811117e4:	01400044 	movi	r5,1
811117e8:	01204574 	movhi	r4,33045
811117ec:	212c8904 	addi	r4,r4,-19932
811117f0:	111fc980 	call	8111fc98 <fwrite>
			#endif		
			/* Do nothing for now */

			break;
811117f4:	00000906 	br	8111181c <vPerformActionNFCRunning+0x110>
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
811117f8:	d0a06117 	ldw	r2,-32380(gp)
811117fc:	100f883a 	mov	r7,r2
81111800:	018009c4 	movi	r6,39
81111804:	01400044 	movi	r5,1
81111808:	01204574 	movhi	r4,33045
8111180c:	212c7f04 	addi	r4,r4,-19972
81111810:	111fc980 	call	8111fc98 <fwrite>
			#endif	
			break;
81111814:	00000106 	br	8111181c <vPerformActionNFCRunning+0x110>
			/* Do nothing for now */

			break;
		case M_NFC_DMA_GIVEBACK:
		case M_NFC_DMA_REQUEST:
			break;
81111818:	0001883a 	nop
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
			#endif	
			break;
	}
}
8111181c:	0001883a 	nop
81111820:	e037883a 	mov	sp,fp
81111824:	dfc00117 	ldw	ra,4(sp)
81111828:	df000017 	ldw	fp,0(sp)
8111182c:	dec00204 	addi	sp,sp,8
81111830:	f800283a 	ret

81111834 <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81111834:	defff704 	addi	sp,sp,-36
81111838:	de00012e 	bgeu	sp,et,81111840 <bSendCmdQToNFeeInst+0xc>
8111183c:	003b68fa 	trap	3
81111840:	dfc00815 	stw	ra,32(sp)
81111844:	df000715 	stw	fp,28(sp)
81111848:	df000704 	addi	fp,sp,28
8111184c:	2011883a 	mov	r8,r4
81111850:	2809883a 	mov	r4,r5
81111854:	3007883a 	mov	r3,r6
81111858:	3805883a 	mov	r2,r7
8111185c:	e23ffc05 	stb	r8,-16(fp)
81111860:	e13ffd05 	stb	r4,-12(fp)
81111864:	e0fffe05 	stb	r3,-8(fp)
81111868:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
8111186c:	e0bffc03 	ldbu	r2,-16(fp)
81111870:	10800444 	addi	r2,r2,17
81111874:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111878:	e0bffd03 	ldbu	r2,-12(fp)
8111187c:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111880:	e0bffe03 	ldbu	r2,-8(fp)
81111884:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111888:	e0bfff03 	ldbu	r2,-4(fp)
8111188c:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111890:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
81111894:	e0bffc03 	ldbu	r2,-16(fp)
81111898:	1085883a 	add	r2,r2,r2
8111189c:	1087883a 	add	r3,r2,r2
811118a0:	d0a06904 	addi	r2,gp,-32348
811118a4:	1885883a 	add	r2,r3,r2
811118a8:	10800017 	ldw	r2,0(r2)
811118ac:	e0fffb17 	ldw	r3,-20(fp)
811118b0:	180b883a 	mov	r5,r3
811118b4:	1009883a 	mov	r4,r2
811118b8:	113c0280 	call	8113c028 <OSQPost>
811118bc:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811118c0:	e0bffa03 	ldbu	r2,-24(fp)
811118c4:	10000526 	beq	r2,zero,811118dc <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
811118c8:	e0bffc03 	ldbu	r2,-16(fp)
811118cc:	1009883a 	mov	r4,r2
811118d0:	111b4ac0 	call	8111b4ac <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
811118d4:	e03ff915 	stw	zero,-28(fp)
811118d8:	00000206 	br	811118e4 <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
811118dc:	00800044 	movi	r2,1
811118e0:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
811118e4:	e0bff917 	ldw	r2,-28(fp)
}
811118e8:	e037883a 	mov	sp,fp
811118ec:	dfc00117 	ldw	ra,4(sp)
811118f0:	df000017 	ldw	fp,0(sp)
811118f4:	dec00204 	addi	sp,sp,8
811118f8:	f800283a 	ret

811118fc <bSendCmdQToNFeeInst_Prio>:


bool bSendCmdQToNFeeInst_Prio( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811118fc:	defff704 	addi	sp,sp,-36
81111900:	de00012e 	bgeu	sp,et,81111908 <bSendCmdQToNFeeInst_Prio+0xc>
81111904:	003b68fa 	trap	3
81111908:	dfc00815 	stw	ra,32(sp)
8111190c:	df000715 	stw	fp,28(sp)
81111910:	df000704 	addi	fp,sp,28
81111914:	2011883a 	mov	r8,r4
81111918:	2809883a 	mov	r4,r5
8111191c:	3007883a 	mov	r3,r6
81111920:	3805883a 	mov	r2,r7
81111924:	e23ffc05 	stb	r8,-16(fp)
81111928:	e13ffd05 	stb	r4,-12(fp)
8111192c:	e0fffe05 	stb	r3,-8(fp)
81111930:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81111934:	e0bffc03 	ldbu	r2,-16(fp)
81111938:	10800444 	addi	r2,r2,17
8111193c:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81111940:	e0bffd03 	ldbu	r2,-12(fp)
81111944:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81111948:	e0bffe03 	ldbu	r2,-8(fp)
8111194c:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81111950:	e0bfff03 	ldbu	r2,-4(fp)
81111954:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81111958:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPostFront(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8111195c:	e0bffc03 	ldbu	r2,-16(fp)
81111960:	1085883a 	add	r2,r2,r2
81111964:	1087883a 	add	r3,r2,r2
81111968:	d0a06904 	addi	r2,gp,-32348
8111196c:	1885883a 	add	r2,r3,r2
81111970:	10800017 	ldw	r2,0(r2)
81111974:	e0fffb17 	ldw	r3,-20(fp)
81111978:	180b883a 	mov	r5,r3
8111197c:	1009883a 	mov	r4,r2
81111980:	113c1980 	call	8113c198 <OSQPostFront>
81111984:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81111988:	e0bffa03 	ldbu	r2,-24(fp)
8111198c:	10000526 	beq	r2,zero,811119a4 <bSendCmdQToNFeeInst_Prio+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81111990:	e0bffc03 	ldbu	r2,-16(fp)
81111994:	1009883a 	mov	r4,r2
81111998:	111b4ac0 	call	8111b4ac <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8111199c:	e03ff915 	stw	zero,-28(fp)
811119a0:	00000206 	br	811119ac <bSendCmdQToNFeeInst_Prio+0xb0>
	} else {
		bSuccesL =  TRUE;
811119a4:	00800044 	movi	r2,1
811119a8:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
811119ac:	e0bff917 	ldw	r2,-28(fp)
}
811119b0:	e037883a 	mov	sp,fp
811119b4:	dfc00117 	ldw	ra,4(sp)
811119b8:	df000017 	ldw	fp,0(sp)
811119bc:	dec00204 	addi	sp,sp,8
811119c0:	f800283a 	ret

811119c4 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
811119c4:	defff704 	addi	sp,sp,-36
811119c8:	de00012e 	bgeu	sp,et,811119d0 <vOutAckHandlerTask+0xc>
811119cc:	003b68fa 	trap	3
811119d0:	dfc00815 	stw	ra,32(sp)
811119d4:	df000715 	stw	fp,28(sp)
811119d8:	df000704 	addi	fp,sp,28
811119dc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
811119e0:	e03ffac5 	stb	zero,-21(fp)
811119e4:	e03ffb05 	stb	zero,-20(fp)
811119e8:	e03ffb45 	stb	zero,-19(fp)
811119ec:	e03ffb85 	stb	zero,-18(fp)
811119f0:	e03ffbc5 	stb	zero,-17(fp)
811119f4:	e03ffc05 	stb	zero,-16(fp)
811119f8:	e03ffc45 	stb	zero,-15(fp)
811119fc:	e03ffc85 	stb	zero,-14(fp)
81111a00:	e03ffcc5 	stb	zero,-13(fp)
81111a04:	e03ffd05 	stb	zero,-12(fp)
81111a08:	e03ffd45 	stb	zero,-11(fp)
81111a0c:	e03ffd85 	stb	zero,-10(fp)
81111a10:	e03ffdc5 	stb	zero,-9(fp)
81111a14:	e03ffe05 	stb	zero,-8(fp)
81111a18:	e03ffe45 	stb	zero,-7(fp)
81111a1c:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
81111a20:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81111a24:	d0a06117 	ldw	r2,-32380(gp)
81111a28:	100f883a 	mov	r7,r2
81111a2c:	01800804 	movi	r6,32
81111a30:	01400044 	movi	r5,1
81111a34:	01204574 	movhi	r4,33045
81111a38:	212c9704 	addi	r4,r4,-19876
81111a3c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
81111a40:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81111a44:	e0bff917 	ldw	r2,-28(fp)
81111a48:	10c00060 	cmpeqi	r3,r2,1
81111a4c:	1800071e 	bne	r3,zero,81111a6c <vOutAckHandlerTask+0xa8>
81111a50:	0080032e 	bgeu	zero,r2,81111a60 <vOutAckHandlerTask+0x9c>
81111a54:	108000a0 	cmpeqi	r2,r2,2
81111a58:	1000471e 	bne	r2,zero,81111b78 <vOutAckHandlerTask+0x1b4>
81111a5c:	00008c06 	br	81111c90 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81111a60:	00800044 	movi	r2,1
81111a64:	e0bff915 	stw	r2,-28(fp)
				break;
81111a68:	00009306 	br	81111cb8 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
81111a6c:	00800044 	movi	r2,1
81111a70:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81111a74:	d0a06017 	ldw	r2,-32384(gp)
81111a78:	e0fffa84 	addi	r3,fp,-22
81111a7c:	180d883a 	mov	r6,r3
81111a80:	000b883a 	mov	r5,zero
81111a84:	1009883a 	mov	r4,r2
81111a88:	113cb180 	call	8113cb18 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
81111a8c:	e0bffa83 	ldbu	r2,-22(fp)
81111a90:	10803fcc 	andi	r2,r2,255
81111a94:	1000361e 	bne	r2,zero,81111b70 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
81111a98:	d0a07117 	ldw	r2,-32316(gp)
81111a9c:	e0fffa84 	addi	r3,fp,-22
81111aa0:	180d883a 	mov	r6,r3
81111aa4:	000b883a 	mov	r5,zero
81111aa8:	1009883a 	mov	r4,r2
81111aac:	113ab0c0 	call	8113ab0c <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81111ab0:	e0bffa83 	ldbu	r2,-22(fp)
81111ab4:	10803fcc 	andi	r2,r2,255
81111ab8:	10002b1e 	bne	r2,zero,81111b68 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81111abc:	e03ffa05 	stb	zero,-24(fp)
81111ac0:	00002206 	br	81111b4c <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
81111ac4:	e0fffa03 	ldbu	r3,-24(fp)
81111ac8:	00a045b4 	movhi	r2,33046
81111acc:	10910c04 	addi	r2,r2,17456
81111ad0:	18c7883a 	add	r3,r3,r3
81111ad4:	18c7883a 	add	r3,r3,r3
81111ad8:	10c5883a 	add	r2,r2,r3
81111adc:	10800003 	ldbu	r2,0(r2)
81111ae0:	10803fcc 	andi	r2,r2,255
81111ae4:	1080201c 	xori	r2,r2,128
81111ae8:	10bfe004 	addi	r2,r2,-128
81111aec:	10001426 	beq	r2,zero,81111b40 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
81111af0:	e0fffa03 	ldbu	r3,-24(fp)
81111af4:	00a045b4 	movhi	r2,33046
81111af8:	10910c04 	addi	r2,r2,17456
81111afc:	18c7883a 	add	r3,r3,r3
81111b00:	18c7883a 	add	r3,r3,r3
81111b04:	10c5883a 	add	r2,r2,r3
81111b08:	10c0000b 	ldhu	r3,0(r2)
81111b0c:	d0e0588d 	sth	r3,-32414(gp)
81111b10:	1080008b 	ldhu	r2,2(r2)
81111b14:	d0a0590d 	sth	r2,-32412(gp)
                                eSenderAckState = sSASending;
81111b18:	00800084 	movi	r2,2
81111b1c:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81111b20:	e0fffa03 	ldbu	r3,-24(fp)
81111b24:	00a045b4 	movhi	r2,33046
81111b28:	10910c04 	addi	r2,r2,17456
81111b2c:	18c7883a 	add	r3,r3,r3
81111b30:	18c7883a 	add	r3,r3,r3
81111b34:	10c5883a 	add	r2,r2,r3
81111b38:	10000005 	stb	zero,0(r2)
                                break;
81111b3c:	00000606 	br	81111b58 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81111b40:	e0bffa03 	ldbu	r2,-24(fp)
81111b44:	10800044 	addi	r2,r2,1
81111b48:	e0bffa05 	stb	r2,-24(fp)
81111b4c:	e0bffa03 	ldbu	r2,-24(fp)
81111b50:	10800230 	cmpltui	r2,r2,8
81111b54:	103fdb1e 	bne	r2,zero,81111ac4 <__reset+0xfb0f1ac4>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81111b58:	d0a07117 	ldw	r2,-32316(gp)
81111b5c:	1009883a 	mov	r4,r2
81111b60:	113b0b00 	call	8113b0b0 <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81111b64:	00005406 	br	81111cb8 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81111b68:	1119cc00 	call	81119cc0 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81111b6c:	00005206 	br	81111cb8 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81111b70:	1119c580 	call	81119c58 <vFailGetCountSemaphoreSenderTask>
                }

                break;
81111b74:	00005006 	br	81111cb8 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81111b78:	d0a05883 	ldbu	r2,-32414(gp)
81111b7c:	10803fcc 	andi	r2,r2,255
81111b80:	1080201c 	xori	r2,r2,128
81111b84:	10bfe004 	addi	r2,r2,-128
81111b88:	108008e0 	cmpeqi	r2,r2,35
81111b8c:	1000201e 	bne	r2,zero,81111c10 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
81111b90:	d0a058c3 	ldbu	r2,-32413(gp)
81111b94:	10c03fcc 	andi	r3,r2,255
81111b98:	18c0201c 	xori	r3,r3,128
81111b9c:	18ffe004 	addi	r3,r3,-128
81111ba0:	d0a0590b 	ldhu	r2,-32412(gp)
81111ba4:	113fffcc 	andi	r4,r2,65535
81111ba8:	e0bffac4 	addi	r2,fp,-21
81111bac:	200f883a 	mov	r7,r4
81111bb0:	180d883a 	mov	r6,r3
81111bb4:	01604574 	movhi	r5,33045
81111bb8:	296ca004 	addi	r5,r5,-19840
81111bbc:	1009883a 	mov	r4,r2
81111bc0:	1120f8c0 	call	81120f8c <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
81111bc4:	e0bffac4 	addi	r2,fp,-21
81111bc8:	1009883a 	mov	r4,r2
81111bcc:	11211a00 	call	811211a0 <strlen>
81111bd0:	1007883a 	mov	r3,r2
81111bd4:	e0bffac4 	addi	r2,fp,-21
81111bd8:	180b883a 	mov	r5,r3
81111bdc:	1009883a 	mov	r4,r2
81111be0:	111981c0 	call	8111981c <ucCrc8wInit>
81111be4:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
81111be8:	e13ffa43 	ldbu	r4,-23(fp)
81111bec:	e0fffac4 	addi	r3,fp,-21
81111bf0:	e0bffac4 	addi	r2,fp,-21
81111bf4:	200f883a 	mov	r7,r4
81111bf8:	180d883a 	mov	r6,r3
81111bfc:	01604574 	movhi	r5,33045
81111c00:	296ca204 	addi	r5,r5,-19832
81111c04:	1009883a 	mov	r4,r2
81111c08:	1120f8c0 	call	81120f8c <sprintf>
81111c0c:	00000c06 	br	81111c40 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
81111c10:	e0bffac4 	addi	r2,fp,-21
81111c14:	00c008c4 	movi	r3,35
81111c18:	10c00005 	stb	r3,0(r2)
81111c1c:	00c01f04 	movi	r3,124
81111c20:	10c00045 	stb	r3,1(r2)
81111c24:	00c00d44 	movi	r3,53
81111c28:	10c00085 	stb	r3,2(r2)
81111c2c:	00c00d04 	movi	r3,52
81111c30:	10c000c5 	stb	r3,3(r2)
81111c34:	00c00ec4 	movi	r3,59
81111c38:	10c00105 	stb	r3,4(r2)
81111c3c:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81111c40:	d0a07317 	ldw	r2,-32308(gp)
81111c44:	e0fffa84 	addi	r3,fp,-22
81111c48:	180d883a 	mov	r6,r3
81111c4c:	01401904 	movi	r5,100
81111c50:	1009883a 	mov	r4,r2
81111c54:	113ab0c0 	call	8113ab0c <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81111c58:	e0bffa83 	ldbu	r2,-22(fp)
81111c5c:	10803fcc 	andi	r2,r2,255
81111c60:	1000071e 	bne	r2,zero,81111c80 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81111c64:	e0bffac4 	addi	r2,fp,-21
81111c68:	1009883a 	mov	r4,r2
81111c6c:	1120c480 	call	81120c48 <puts>
                    OSMutexPost(xTxUARTMutex);
81111c70:	d0a07317 	ldw	r2,-32308(gp)
81111c74:	1009883a 	mov	r4,r2
81111c78:	113b0b00 	call	8113b0b0 <OSMutexPost>
81111c7c:	00000106 	br	81111c84 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81111c80:	1119df80 	call	81119df8 <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81111c84:	00800044 	movi	r2,1
81111c88:	e0bff915 	stw	r2,-28(fp)
                
				break;
81111c8c:	00000a06 	br	81111cb8 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81111c90:	d0a06117 	ldw	r2,-32380(gp)
81111c94:	100f883a 	mov	r7,r2
81111c98:	01801104 	movi	r6,68
81111c9c:	01400044 	movi	r5,1
81111ca0:	01204574 	movhi	r4,33045
81111ca4:	212ca504 	addi	r4,r4,-19820
81111ca8:	111fc980 	call	8111fc98 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
81111cac:	00800044 	movi	r2,1
81111cb0:	e0bff915 	stw	r2,-28(fp)
				break;
81111cb4:	0001883a 	nop
		}
	}
81111cb8:	003f6206 	br	81111a44 <__reset+0xfb0f1a44>

81111cbc <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
81111cbc:	deffd704 	addi	sp,sp,-164
81111cc0:	de00012e 	bgeu	sp,et,81111cc8 <vParserCommTask+0xc>
81111cc4:	003b68fa 	trap	3
81111cc8:	dfc02815 	stw	ra,160(sp)
81111ccc:	df002715 	stw	fp,156(sp)
81111cd0:	df002704 	addi	fp,sp,156
81111cd4:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
81111cd8:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
81111cdc:	d0a06117 	ldw	r2,-32380(gp)
81111ce0:	100f883a 	mov	r7,r2
81111ce4:	01800704 	movi	r6,28
81111ce8:	01400044 	movi	r5,1
81111cec:	01204574 	movhi	r4,33045
81111cf0:	212cb704 	addi	r4,r4,-19748
81111cf4:	111fc980 	call	8111fc98 <fwrite>
    #endif

	eParserMode = sConfiguring;
81111cf8:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
81111cfc:	e0bfdc17 	ldw	r2,-144(fp)
81111d00:	10800168 	cmpgeui	r2,r2,5
81111d04:	1003651e 	bne	r2,zero,81112a9c <vParserCommTask+0xde0>
81111d08:	e0bfdc17 	ldw	r2,-144(fp)
81111d0c:	100690ba 	slli	r3,r2,2
81111d10:	00a04474 	movhi	r2,33041
81111d14:	10874904 	addi	r2,r2,7460
81111d18:	1885883a 	add	r2,r3,r2
81111d1c:	10800017 	ldw	r2,0(r2)
81111d20:	1000683a 	jmp	r2
81111d24:	81111d38 	rdprs	r4,r16,17524
81111d28:	81111d44 	addi	r4,r16,17525
81111d2c:	81111dd8 	cmpnei	r4,r16,17527
81111d30:	81111f3c 	xorhi	r4,r16,17532
81111d34:	81111f80 	call	881111f8 <__reset+0x20f11f8>
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81111d38:	00800044 	movi	r2,1
81111d3c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81111d40:	00035906 	br	81112aa8 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
81111d44:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81111d48:	00800044 	movi	r2,1
81111d4c:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81111d50:	d0a06317 	ldw	r2,-32372(gp)
81111d54:	e0ffde84 	addi	r3,fp,-134
81111d58:	180d883a 	mov	r6,r3
81111d5c:	000b883a 	mov	r5,zero
81111d60:	1009883a 	mov	r4,r2
81111d64:	113cb180 	call	8113cb18 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81111d68:	e0bfde83 	ldbu	r2,-134(fp)
81111d6c:	10803fcc 	andi	r2,r2,255
81111d70:	1000171e 	bne	r2,zero,81111dd0 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81111d74:	01204574 	movhi	r4,33045
81111d78:	21037804 	addi	r4,r4,3552
81111d7c:	1112aac0 	call	81112aac <getPreParsedPacket>
81111d80:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81111d84:	e0bfdd17 	ldw	r2,-140(fp)
81111d88:	10800058 	cmpnei	r2,r2,1
81111d8c:	10000e1e 	bne	r2,zero,81111dc8 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
81111d90:	00a04574 	movhi	r2,33045
81111d94:	10837804 	addi	r2,r2,3552
81111d98:	10800103 	ldbu	r2,4(r2)
81111d9c:	10803fcc 	andi	r2,r2,255
81111da0:	1080201c 	xori	r2,r2,128
81111da4:	10bfe004 	addi	r2,r2,-128
81111da8:	10800858 	cmpnei	r2,r2,33
81111dac:	1000031e 	bne	r2,zero,81111dbc <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
81111db0:	008000c4 	movi	r2,3
81111db4:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81111db8:	00033b06 	br	81112aa8 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
81111dbc:	00800084 	movi	r2,2
81111dc0:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81111dc4:	00033806 	br	81112aa8 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
81111dc8:	111a3840 	call	8111a384 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81111dcc:	00033606 	br	81112aa8 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
81111dd0:	111a2b40 	call	8111a2b4 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
81111dd4:	00033406 	br	81112aa8 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
81111dd8:	00a04574 	movhi	r2,33045
81111ddc:	10837804 	addi	r2,r2,3552
81111de0:	10800143 	ldbu	r2,5(r2)
81111de4:	10803fcc 	andi	r2,r2,255
81111de8:	1080201c 	xori	r2,r2,128
81111dec:	10bfe004 	addi	r2,r2,-128
81111df0:	10c010e0 	cmpeqi	r3,r2,67
81111df4:	1800031e 	bne	r3,zero,81111e04 <vParserCommTask+0x148>
81111df8:	10801420 	cmpeqi	r2,r2,80
81111dfc:	1000051e 	bne	r2,zero,81111e14 <vParserCommTask+0x158>
81111e00:	00004a06 	br	81111f2c <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
81111e04:	11175700 	call	81117570 <vSendEthConf>
						eParserMode = sWaitingMessage;
81111e08:	00800044 	movi	r2,1
81111e0c:	e0bfdc15 	stw	r2,-144(fp)
						break;
81111e10:	00004906 	br	81111f38 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
81111e14:	e0bfdec4 	addi	r2,fp,-133
81111e18:	01802004 	movi	r6,128
81111e1c:	000b883a 	mov	r5,zero
81111e20:	1009883a 	mov	r4,r2
81111e24:	11207fc0 	call	811207fc <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81111e28:	00a04574 	movhi	r2,33045
81111e2c:	10837804 	addi	r2,r2,3552
81111e30:	1080028b 	ldhu	r2,10(r2)
81111e34:	117fffcc 	andi	r5,r2,65535
81111e38:	00a04574 	movhi	r2,33045
81111e3c:	10837804 	addi	r2,r2,3552
81111e40:	1080030b 	ldhu	r2,12(r2)
81111e44:	11bfffcc 	andi	r6,r2,65535
81111e48:	00a04574 	movhi	r2,33045
81111e4c:	10837804 	addi	r2,r2,3552
81111e50:	1080038b 	ldhu	r2,14(r2)
81111e54:	10ffffcc 	andi	r3,r2,65535
81111e58:	00a04574 	movhi	r2,33045
81111e5c:	10837804 	addi	r2,r2,3552
81111e60:	1080040b 	ldhu	r2,16(r2)
81111e64:	113fffcc 	andi	r4,r2,65535
81111e68:	00a04574 	movhi	r2,33045
81111e6c:	10837804 	addi	r2,r2,3552
81111e70:	1080048b 	ldhu	r2,18(r2)
81111e74:	10bfffcc 	andi	r2,r2,65535
81111e78:	e23fdec4 	addi	r8,fp,-133
81111e7c:	d8800215 	stw	r2,8(sp)
81111e80:	d9000115 	stw	r4,4(sp)
81111e84:	d8c00015 	stw	r3,0(sp)
81111e88:	300f883a 	mov	r7,r6
81111e8c:	280d883a 	mov	r6,r5
81111e90:	01604574 	movhi	r5,33045
81111e94:	296cbf04 	addi	r5,r5,-19716
81111e98:	4009883a 	mov	r4,r8
81111e9c:	1120f8c0 	call	81120f8c <sprintf>
							debug(fp, cPUSDebug );
81111ea0:	d0a06117 	ldw	r2,-32380(gp)
81111ea4:	e0ffdec4 	addi	r3,fp,-133
81111ea8:	180b883a 	mov	r5,r3
81111eac:	1009883a 	mov	r4,r2
81111eb0:	111f5fc0 	call	8111f5fc <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81111eb4:	00a04574 	movhi	r2,33045
81111eb8:	10837804 	addi	r2,r2,3552
81111ebc:	10c0030b 	ldhu	r3,12(r2)
81111ec0:	00a04574 	movhi	r2,33045
81111ec4:	10838b04 	addi	r2,r2,3628
81111ec8:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81111ecc:	00a04574 	movhi	r2,33045
81111ed0:	10837804 	addi	r2,r2,3552
81111ed4:	10c0038b 	ldhu	r3,14(r2)
81111ed8:	00a04574 	movhi	r2,33045
81111edc:	10838b04 	addi	r2,r2,3628
81111ee0:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81111ee4:	00a04574 	movhi	r2,33045
81111ee8:	10837804 	addi	r2,r2,3552
81111eec:	10c0040b 	ldhu	r3,16(r2)
81111ef0:	00a04574 	movhi	r2,33045
81111ef4:	10838b04 	addi	r2,r2,3628
81111ef8:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81111efc:	00a04574 	movhi	r2,33045
81111f00:	10837804 	addi	r2,r2,3552
81111f04:	10c0048b 	ldhu	r3,18(r2)
81111f08:	00a04574 	movhi	r2,33045
81111f0c:	10838b04 	addi	r2,r2,3628
81111f10:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81111f14:	00a04574 	movhi	r2,33045
81111f18:	10838b04 	addi	r2,r2,3628
81111f1c:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81111f20:	00800104 	movi	r2,4
81111f24:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81111f28:	00000306 	br	81111f38 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
81111f2c:	00800044 	movi	r2,1
81111f30:	e0bfdc15 	stw	r2,-144(fp)
						break;
81111f34:	0001883a 	nop
				}
				break;
81111f38:	0002db06 	br	81112aa8 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81111f3c:	00800044 	movi	r2,1
81111f40:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81111f44:	00a04574 	movhi	r2,33045
81111f48:	10838b04 	addi	r2,r2,3628
81111f4c:	1080030b 	ldhu	r2,12(r2)
81111f50:	10bfffcc 	andi	r2,r2,65535
81111f54:	10c01220 	cmpeqi	r3,r2,72
81111f58:	1800051e 	bne	r3,zero,81111f70 <vParserCommTask+0x2b4>
81111f5c:	108014e0 	cmpeqi	r2,r2,83
81111f60:	1000051e 	bne	r2,zero,81111f78 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81111f64:	00800044 	movi	r2,1
81111f68:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81111f6c:	00000306 	br	81111f7c <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81111f70:	0001883a 	nop
81111f74:	0002cc06 	br	81112aa8 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81111f78:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81111f7c:	0002ca06 	br	81112aa8 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81111f80:	00800044 	movi	r2,1
81111f84:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
81111f88:	00a04574 	movhi	r2,33045
81111f8c:	10838b04 	addi	r2,r2,3628
81111f90:	1080030b 	ldhu	r2,12(r2)
81111f94:	10bfffcc 	andi	r2,r2,65535
81111f98:	10c03ea0 	cmpeqi	r3,r2,250
81111f9c:	1800401e 	bne	r3,zero,811120a0 <vParserCommTask+0x3e4>
81111fa0:	10c03ec8 	cmpgei	r3,r2,251
81111fa4:	1800031e 	bne	r3,zero,81111fb4 <vParserCommTask+0x2f8>
81111fa8:	10800460 	cmpeqi	r2,r2,17
81111fac:	1000061e 	bne	r2,zero,81111fc8 <vParserCommTask+0x30c>
81111fb0:	0002b606 	br	81112a8c <vParserCommTask+0xdd0>
81111fb4:	10c03ee0 	cmpeqi	r3,r2,251
81111fb8:	18009d1e 	bne	r3,zero,81112230 <vParserCommTask+0x574>
81111fbc:	10803f20 	cmpeqi	r2,r2,252
81111fc0:	1001321e 	bne	r2,zero,8111248c <vParserCommTask+0x7d0>
81111fc4:	0002b106 	br	81112a8c <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81111fc8:	00a04574 	movhi	r2,33045
81111fcc:	10838b04 	addi	r2,r2,3628
81111fd0:	1080038b 	ldhu	r2,14(r2)
81111fd4:	10bfffcc 	andi	r2,r2,65535
81111fd8:	10800060 	cmpeqi	r2,r2,1
81111fdc:	10000e26 	beq	r2,zero,81112018 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81111fe0:	d0a06117 	ldw	r2,-32380(gp)
81111fe4:	100f883a 	mov	r7,r2
81111fe8:	01800944 	movi	r6,37
81111fec:	01400044 	movi	r5,1
81111ff0:	01204574 	movhi	r4,33045
81111ff4:	212cd504 	addi	r4,r4,-19628
81111ff8:	111fc980 	call	8111fc98 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81111ffc:	00a04574 	movhi	r2,33045
81112000:	10838b04 	addi	r2,r2,3628
81112004:	1080040b 	ldhu	r2,16(r2)
81112008:	10bfffcc 	andi	r2,r2,65535
8111200c:	1009883a 	mov	r4,r2
81112010:	1117f700 	call	81117f70 <vTMPusTestConnection>

								break;
81112014:	00002106 	br	8111209c <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81112018:	e0bfdec4 	addi	r2,fp,-133
8111201c:	01802004 	movi	r6,128
81112020:	000b883a 	mov	r5,zero
81112024:	1009883a 	mov	r4,r2
81112028:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
8111202c:	00a04574 	movhi	r2,33045
81112030:	10838b04 	addi	r2,r2,3628
81112034:	1080030b 	ldhu	r2,12(r2)
81112038:	113fffcc 	andi	r4,r2,65535
8111203c:	00a04574 	movhi	r2,33045
81112040:	10838b04 	addi	r2,r2,3628
81112044:	1080038b 	ldhu	r2,14(r2)
81112048:	117fffcc 	andi	r5,r2,65535
8111204c:	00a04574 	movhi	r2,33045
81112050:	10838b04 	addi	r2,r2,3628
81112054:	1080040b 	ldhu	r2,16(r2)
81112058:	10bfffcc 	andi	r2,r2,65535
8111205c:	e0ffdec4 	addi	r3,fp,-133
81112060:	d8800015 	stw	r2,0(sp)
81112064:	280f883a 	mov	r7,r5
81112068:	200d883a 	mov	r6,r4
8111206c:	01604574 	movhi	r5,33045
81112070:	296cdf04 	addi	r5,r5,-19588
81112074:	1809883a 	mov	r4,r3
81112078:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
8111207c:	d0a06117 	ldw	r2,-32380(gp)
81112080:	e0ffdec4 	addi	r3,fp,-133
81112084:	180b883a 	mov	r5,r3
81112088:	1009883a 	mov	r4,r2
8111208c:	111f5fc0 	call	8111f5fc <fprintf>
								#endif
								eParserMode = sWaitingMessage;
81112090:	00800044 	movi	r2,1
81112094:	e0bfdc15 	stw	r2,-144(fp)
								break;
81112098:	0001883a 	nop
						}
                        break;
8111209c:	00027e06 	br	81112a98 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
811120a0:	00a04574 	movhi	r2,33045
811120a4:	10838b04 	addi	r2,r2,3628
811120a8:	1080038b 	ldhu	r2,14(r2)
811120ac:	10bfffcc 	andi	r2,r2,65535
811120b0:	10c00f20 	cmpeqi	r3,r2,60
811120b4:	18001a1e 	bne	r3,zero,81112120 <vParserCommTask+0x464>
811120b8:	10c00f48 	cmpgei	r3,r2,61
811120bc:	1800031e 	bne	r3,zero,811120cc <vParserCommTask+0x410>
811120c0:	10800ee0 	cmpeqi	r2,r2,59
811120c4:	1000061e 	bne	r2,zero,811120e0 <vParserCommTask+0x424>
811120c8:	00003706 	br	811121a8 <vParserCommTask+0x4ec>
811120cc:	10c00f60 	cmpeqi	r3,r2,61
811120d0:	18001e1e 	bne	r3,zero,8111214c <vParserCommTask+0x490>
811120d4:	10800fa0 	cmpeqi	r2,r2,62
811120d8:	1000271e 	bne	r2,zero,81112178 <vParserCommTask+0x4bc>
811120dc:	00003206 	br	811121a8 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
811120e0:	d0a06117 	ldw	r2,-32380(gp)
811120e4:	100f883a 	mov	r7,r2
811120e8:	018006c4 	movi	r6,27
811120ec:	01400044 	movi	r5,1
811120f0:	01204574 	movhi	r4,33045
811120f4:	212cf204 	addi	r4,r4,-19512
811120f8:	111fc980 	call	8111fc98 <fwrite>
								#endif
								vSendReset();
811120fc:	11179180 	call	81117918 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
81112100:	000f883a 	mov	r7,zero
81112104:	018000c4 	movi	r6,3
81112108:	000b883a 	mov	r5,zero
8111210c:	0009883a 	mov	r4,zero
81112110:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81112114:	0104e204 	movi	r4,5000
81112118:	110be140 	call	8110be14 <vRstcSimucamReset>

								break;
8111211c:	00004306 	br	8111222c <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81112120:	d0a06117 	ldw	r2,-32380(gp)
81112124:	100f883a 	mov	r7,r2
81112128:	01800704 	movi	r6,28
8111212c:	01400044 	movi	r5,1
81112130:	01204574 	movhi	r4,33045
81112134:	212cf904 	addi	r4,r4,-19484
81112138:	111fc980 	call	8111fc98 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111213c:	01204574 	movhi	r4,33045
81112140:	21038b04 	addi	r4,r4,3628
81112144:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

								break;
81112148:	00003806 	br	8111222c <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
8111214c:	d0a06117 	ldw	r2,-32380(gp)
81112150:	100f883a 	mov	r7,r2
81112154:	01800644 	movi	r6,25
81112158:	01400044 	movi	r5,1
8111215c:	01204574 	movhi	r4,33045
81112160:	212d0104 	addi	r4,r4,-19452
81112164:	111fc980 	call	8111fc98 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81112168:	01204574 	movhi	r4,33045
8111216c:	21038b04 	addi	r4,r4,3628
81112170:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

								break;
81112174:	00002d06 	br	8111222c <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81112178:	d0a06117 	ldw	r2,-32380(gp)
8111217c:	100f883a 	mov	r7,r2
81112180:	01800744 	movi	r6,29
81112184:	01400044 	movi	r5,1
81112188:	01204574 	movhi	r4,33045
8111218c:	212d0804 	addi	r4,r4,-19424
81112190:	111fc980 	call	8111fc98 <fwrite>
								#endif
								vSendTurnOff();
81112194:	11178000 	call	81117800 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81112198:	01204574 	movhi	r4,33045
8111219c:	21038b04 	addi	r4,r4,3628
811121a0:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

								break;
811121a4:	00002106 	br	8111222c <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811121a8:	e0bfdec4 	addi	r2,fp,-133
811121ac:	01802004 	movi	r6,128
811121b0:	000b883a 	mov	r5,zero
811121b4:	1009883a 	mov	r4,r2
811121b8:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811121bc:	00a04574 	movhi	r2,33045
811121c0:	10838b04 	addi	r2,r2,3628
811121c4:	1080030b 	ldhu	r2,12(r2)
811121c8:	113fffcc 	andi	r4,r2,65535
811121cc:	00a04574 	movhi	r2,33045
811121d0:	10838b04 	addi	r2,r2,3628
811121d4:	1080038b 	ldhu	r2,14(r2)
811121d8:	117fffcc 	andi	r5,r2,65535
811121dc:	00a04574 	movhi	r2,33045
811121e0:	10838b04 	addi	r2,r2,3628
811121e4:	1080040b 	ldhu	r2,16(r2)
811121e8:	10bfffcc 	andi	r2,r2,65535
811121ec:	e0ffdec4 	addi	r3,fp,-133
811121f0:	d8800015 	stw	r2,0(sp)
811121f4:	280f883a 	mov	r7,r5
811121f8:	200d883a 	mov	r6,r4
811121fc:	01604574 	movhi	r5,33045
81112200:	296cdf04 	addi	r5,r5,-19588
81112204:	1809883a 	mov	r4,r3
81112208:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
8111220c:	d0a06117 	ldw	r2,-32380(gp)
81112210:	e0ffdec4 	addi	r3,fp,-133
81112214:	180b883a 	mov	r5,r3
81112218:	1009883a 	mov	r4,r2
8111221c:	111f5fc0 	call	8111f5fc <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81112220:	00800044 	movi	r2,1
81112224:	e0bfdc15 	stw	r2,-144(fp)
								break;
81112228:	0001883a 	nop
						}
                        break;
8111222c:	00021a06 	br	81112a98 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81112230:	00a04574 	movhi	r2,33045
81112234:	10837804 	addi	r2,r2,3552
81112238:	1080050b 	ldhu	r2,20(r2)
8111223c:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
81112240:	e0bfde0b 	ldhu	r2,-136(fp)
81112244:	108000b0 	cmpltui	r2,r2,2
81112248:	1000121e 	bne	r2,zero,81112294 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
8111224c:	e0bfdec4 	addi	r2,fp,-133
81112250:	01802004 	movi	r6,128
81112254:	000b883a 	mov	r5,zero
81112258:	1009883a 	mov	r4,r2
8111225c:	11207fc0 	call	811207fc <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81112260:	e0ffde0b 	ldhu	r3,-136(fp)
81112264:	e0bfdec4 	addi	r2,fp,-133
81112268:	180d883a 	mov	r6,r3
8111226c:	01604574 	movhi	r5,33045
81112270:	296d1004 	addi	r5,r5,-19392
81112274:	1009883a 	mov	r4,r2
81112278:	1120f8c0 	call	81120f8c <sprintf>
								debug(fp, cPUSDebug );
8111227c:	d0a06117 	ldw	r2,-32380(gp)
81112280:	e0ffdec4 	addi	r3,fp,-133
81112284:	180b883a 	mov	r5,r3
81112288:	1009883a 	mov	r4,r2
8111228c:	111f5fc0 	call	8111f5fc <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81112290:	00020106 	br	81112a98 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81112294:	00a04574 	movhi	r2,33045
81112298:	10838b04 	addi	r2,r2,3628
8111229c:	10800483 	ldbu	r2,18(r2)
811122a0:	10c03fcc 	andi	r3,r2,255
811122a4:	00a04574 	movhi	r2,33045
811122a8:	10838b04 	addi	r2,r2,3628
811122ac:	18c00284 	addi	r3,r3,10
811122b0:	18c7883a 	add	r3,r3,r3
811122b4:	10c5883a 	add	r2,r2,r3
811122b8:	e0ffde0b 	ldhu	r3,-136(fp)
811122bc:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
811122c0:	00a04574 	movhi	r2,33045
811122c4:	10838b04 	addi	r2,r2,3628
811122c8:	10800483 	ldbu	r2,18(r2)
811122cc:	10800044 	addi	r2,r2,1
811122d0:	1007883a 	mov	r3,r2
811122d4:	00a04574 	movhi	r2,33045
811122d8:	10838b04 	addi	r2,r2,3628
811122dc:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
811122e0:	00a04574 	movhi	r2,33045
811122e4:	10838b04 	addi	r2,r2,3628
811122e8:	1080038b 	ldhu	r2,14(r2)
811122ec:	10bfffcc 	andi	r2,r2,65535
811122f0:	10c000a0 	cmpeqi	r3,r2,2
811122f4:	1800191e 	bne	r3,zero,8111235c <vParserCommTask+0x6a0>
811122f8:	10c00160 	cmpeqi	r3,r2,5
811122fc:	18002c1e 	bne	r3,zero,811123b0 <vParserCommTask+0x6f4>
81112300:	10800060 	cmpeqi	r2,r2,1
81112304:	10003f26 	beq	r2,zero,81112404 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81112308:	e0bfdec4 	addi	r2,fp,-133
8111230c:	01802004 	movi	r6,128
81112310:	000b883a 	mov	r5,zero
81112314:	1009883a 	mov	r4,r2
81112318:	11207fc0 	call	811207fc <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111231c:	e0ffde0b 	ldhu	r3,-136(fp)
81112320:	e0bfdec4 	addi	r2,fp,-133
81112324:	180d883a 	mov	r6,r3
81112328:	01604574 	movhi	r5,33045
8111232c:	296d1f04 	addi	r5,r5,-19332
81112330:	1009883a 	mov	r4,r2
81112334:	1120f8c0 	call	81120f8c <sprintf>
										debug(fp, cPUSDebug );
81112338:	d0a06117 	ldw	r2,-32380(gp)
8111233c:	e0ffdec4 	addi	r3,fp,-133
81112340:	180b883a 	mov	r5,r3
81112344:	1009883a 	mov	r4,r2
81112348:	111f5fc0 	call	8111f5fc <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
8111234c:	01204574 	movhi	r4,33045
81112350:	21038b04 	addi	r4,r4,3628
81112354:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

									break;
81112358:	00004b06 	br	81112488 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
8111235c:	e0bfdec4 	addi	r2,fp,-133
81112360:	01802004 	movi	r6,128
81112364:	000b883a 	mov	r5,zero
81112368:	1009883a 	mov	r4,r2
8111236c:	11207fc0 	call	811207fc <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81112370:	e0ffde0b 	ldhu	r3,-136(fp)
81112374:	e0bfdec4 	addi	r2,fp,-133
81112378:	180d883a 	mov	r6,r3
8111237c:	01604574 	movhi	r5,33045
81112380:	296d2f04 	addi	r5,r5,-19268
81112384:	1009883a 	mov	r4,r2
81112388:	1120f8c0 	call	81120f8c <sprintf>
										debug(fp, cPUSDebug );
8111238c:	d0a06117 	ldw	r2,-32380(gp)
81112390:	e0ffdec4 	addi	r3,fp,-133
81112394:	180b883a 	mov	r5,r3
81112398:	1009883a 	mov	r4,r2
8111239c:	111f5fc0 	call	8111f5fc <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811123a0:	01204574 	movhi	r4,33045
811123a4:	21038b04 	addi	r4,r4,3628
811123a8:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

									break;
811123ac:	00003606 	br	81112488 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
811123b0:	e0bfdec4 	addi	r2,fp,-133
811123b4:	01802004 	movi	r6,128
811123b8:	000b883a 	mov	r5,zero
811123bc:	1009883a 	mov	r4,r2
811123c0:	11207fc0 	call	811207fc <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811123c4:	e0ffde0b 	ldhu	r3,-136(fp)
811123c8:	e0bfdec4 	addi	r2,fp,-133
811123cc:	180d883a 	mov	r6,r3
811123d0:	01604574 	movhi	r5,33045
811123d4:	296d3f04 	addi	r5,r5,-19204
811123d8:	1009883a 	mov	r4,r2
811123dc:	1120f8c0 	call	81120f8c <sprintf>
										debug(fp, cPUSDebug );
811123e0:	d0a06117 	ldw	r2,-32380(gp)
811123e4:	e0ffdec4 	addi	r3,fp,-133
811123e8:	180b883a 	mov	r5,r3
811123ec:	1009883a 	mov	r4,r2
811123f0:	111f5fc0 	call	8111f5fc <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
811123f4:	01204574 	movhi	r4,33045
811123f8:	21038b04 	addi	r4,r4,3628
811123fc:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

									break;
81112400:	00002106 	br	81112488 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81112404:	e0bfdec4 	addi	r2,fp,-133
81112408:	01802004 	movi	r6,128
8111240c:	000b883a 	mov	r5,zero
81112410:	1009883a 	mov	r4,r2
81112414:	11207fc0 	call	811207fc <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81112418:	00a04574 	movhi	r2,33045
8111241c:	10838b04 	addi	r2,r2,3628
81112420:	1080030b 	ldhu	r2,12(r2)
81112424:	113fffcc 	andi	r4,r2,65535
81112428:	00a04574 	movhi	r2,33045
8111242c:	10838b04 	addi	r2,r2,3628
81112430:	1080038b 	ldhu	r2,14(r2)
81112434:	117fffcc 	andi	r5,r2,65535
81112438:	00a04574 	movhi	r2,33045
8111243c:	10838b04 	addi	r2,r2,3628
81112440:	1080040b 	ldhu	r2,16(r2)
81112444:	10bfffcc 	andi	r2,r2,65535
81112448:	e0ffdec4 	addi	r3,fp,-133
8111244c:	d8800015 	stw	r2,0(sp)
81112450:	280f883a 	mov	r7,r5
81112454:	200d883a 	mov	r6,r4
81112458:	01604574 	movhi	r5,33045
8111245c:	296cdf04 	addi	r5,r5,-19588
81112460:	1809883a 	mov	r4,r3
81112464:	1120f8c0 	call	81120f8c <sprintf>
										debug(fp, cPUSDebug );
81112468:	d0a06117 	ldw	r2,-32380(gp)
8111246c:	e0ffdec4 	addi	r3,fp,-133
81112470:	180b883a 	mov	r5,r3
81112474:	1009883a 	mov	r4,r2
81112478:	111f5fc0 	call	8111f5fc <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
8111247c:	00800044 	movi	r2,1
81112480:	e0bfdc15 	stw	r2,-144(fp)
									break;
81112484:	0001883a 	nop
							}
						}
                        break;
81112488:	00018306 	br	81112a98 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8111248c:	00a04574 	movhi	r2,33045
81112490:	10837804 	addi	r2,r2,3552
81112494:	1080050b 	ldhu	r2,20(r2)
81112498:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8111249c:	00a04574 	movhi	r2,33045
811124a0:	10838b04 	addi	r2,r2,3628
811124a4:	10800483 	ldbu	r2,18(r2)
811124a8:	10c03fcc 	andi	r3,r2,255
811124ac:	00a04574 	movhi	r2,33045
811124b0:	10838b04 	addi	r2,r2,3628
811124b4:	18c00284 	addi	r3,r3,10
811124b8:	18c7883a 	add	r3,r3,r3
811124bc:	10c5883a 	add	r2,r2,r3
811124c0:	e0ffde0b 	ldhu	r3,-136(fp)
811124c4:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
811124c8:	00a04574 	movhi	r2,33045
811124cc:	10838b04 	addi	r2,r2,3628
811124d0:	10800483 	ldbu	r2,18(r2)
811124d4:	10800044 	addi	r2,r2,1
811124d8:	1007883a 	mov	r3,r2
811124dc:	00a04574 	movhi	r2,33045
811124e0:	10838b04 	addi	r2,r2,3628
811124e4:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811124e8:	00a04574 	movhi	r2,33045
811124ec:	10838b04 	addi	r2,r2,3628
811124f0:	1080038b 	ldhu	r2,14(r2)
811124f4:	10bfffcc 	andi	r2,r2,65535
811124f8:	10c000e0 	cmpeqi	r3,r2,3
811124fc:	18000a1e 	bne	r3,zero,81112528 <vParserCommTask+0x86c>
81112500:	10c00108 	cmpgei	r3,r2,4
81112504:	1800031e 	bne	r3,zero,81112514 <vParserCommTask+0x858>
81112508:	108000a0 	cmpeqi	r2,r2,2
8111250c:	1000451e 	bne	r2,zero,81112624 <vParserCommTask+0x968>
81112510:	00013c06 	br	81112a04 <vParserCommTask+0xd48>
81112514:	10c00120 	cmpeqi	r3,r2,4
81112518:	1800181e 	bne	r3,zero,8111257c <vParserCommTask+0x8c0>
8111251c:	10800160 	cmpeqi	r2,r2,5
81112520:	10002b1e 	bne	r2,zero,811125d0 <vParserCommTask+0x914>
81112524:	00013706 	br	81112a04 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81112528:	e0bfdec4 	addi	r2,fp,-133
8111252c:	01802004 	movi	r6,128
81112530:	000b883a 	mov	r5,zero
81112534:	1009883a 	mov	r4,r2
81112538:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111253c:	e0ffde0b 	ldhu	r3,-136(fp)
81112540:	e0bfdec4 	addi	r2,fp,-133
81112544:	180d883a 	mov	r6,r3
81112548:	01604574 	movhi	r5,33045
8111254c:	296d5104 	addi	r5,r5,-19132
81112550:	1009883a 	mov	r4,r2
81112554:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
81112558:	d0a06117 	ldw	r2,-32380(gp)
8111255c:	e0ffdec4 	addi	r3,fp,-133
81112560:	180b883a 	mov	r5,r3
81112564:	1009883a 	mov	r4,r2
81112568:	111f5fc0 	call	8111f5fc <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111256c:	01204574 	movhi	r4,33045
81112570:	21038b04 	addi	r4,r4,3628
81112574:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

								break;
81112578:	00014306 	br	81112a88 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8111257c:	e0bfdec4 	addi	r2,fp,-133
81112580:	01802004 	movi	r6,128
81112584:	000b883a 	mov	r5,zero
81112588:	1009883a 	mov	r4,r2
8111258c:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81112590:	e0ffde0b 	ldhu	r3,-136(fp)
81112594:	e0bfdec4 	addi	r2,fp,-133
81112598:	180d883a 	mov	r6,r3
8111259c:	01604574 	movhi	r5,33045
811125a0:	296d6104 	addi	r5,r5,-19068
811125a4:	1009883a 	mov	r4,r2
811125a8:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
811125ac:	d0a06117 	ldw	r2,-32380(gp)
811125b0:	e0ffdec4 	addi	r3,fp,-133
811125b4:	180b883a 	mov	r5,r3
811125b8:	1009883a 	mov	r4,r2
811125bc:	111f5fc0 	call	8111f5fc <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811125c0:	01204574 	movhi	r4,33045
811125c4:	21038b04 	addi	r4,r4,3628
811125c8:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

								break;
811125cc:	00012e06 	br	81112a88 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811125d0:	e0bfdec4 	addi	r2,fp,-133
811125d4:	01802004 	movi	r6,128
811125d8:	000b883a 	mov	r5,zero
811125dc:	1009883a 	mov	r4,r2
811125e0:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811125e4:	e0ffde0b 	ldhu	r3,-136(fp)
811125e8:	e0bfdec4 	addi	r2,fp,-133
811125ec:	180d883a 	mov	r6,r3
811125f0:	01604574 	movhi	r5,33045
811125f4:	296d7104 	addi	r5,r5,-19004
811125f8:	1009883a 	mov	r4,r2
811125fc:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
81112600:	d0a06117 	ldw	r2,-32380(gp)
81112604:	e0ffdec4 	addi	r3,fp,-133
81112608:	180b883a 	mov	r5,r3
8111260c:	1009883a 	mov	r4,r2
81112610:	111f5fc0 	call	8111f5fc <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81112614:	01204574 	movhi	r4,33045
81112618:	21038b04 	addi	r4,r4,3628
8111261c:	1112bc40 	call	81112bc4 <bSendMessagePUStoMebTask>

								break;
81112620:	00011906 	br	81112a88 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81112624:	00a04574 	movhi	r2,33045
81112628:	10838b04 	addi	r2,r2,3628
8111262c:	10800483 	ldbu	r2,18(r2)
81112630:	10c03fcc 	andi	r3,r2,255
81112634:	00a04574 	movhi	r2,33045
81112638:	10837804 	addi	r2,r2,3552
8111263c:	1100058b 	ldhu	r4,22(r2)
81112640:	00a04574 	movhi	r2,33045
81112644:	10838b04 	addi	r2,r2,3628
81112648:	18c00284 	addi	r3,r3,10
8111264c:	18c7883a 	add	r3,r3,r3
81112650:	10c5883a 	add	r2,r2,r3
81112654:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81112658:	00a04574 	movhi	r2,33045
8111265c:	10838b04 	addi	r2,r2,3628
81112660:	10800483 	ldbu	r2,18(r2)
81112664:	10800044 	addi	r2,r2,1
81112668:	1007883a 	mov	r3,r2
8111266c:	00a04574 	movhi	r2,33045
81112670:	10838b04 	addi	r2,r2,3628
81112674:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81112678:	00a04574 	movhi	r2,33045
8111267c:	10838b04 	addi	r2,r2,3628
81112680:	10800483 	ldbu	r2,18(r2)
81112684:	10c03fcc 	andi	r3,r2,255
81112688:	00a04574 	movhi	r2,33045
8111268c:	10837804 	addi	r2,r2,3552
81112690:	1100060b 	ldhu	r4,24(r2)
81112694:	00a04574 	movhi	r2,33045
81112698:	10838b04 	addi	r2,r2,3628
8111269c:	18c00284 	addi	r3,r3,10
811126a0:	18c7883a 	add	r3,r3,r3
811126a4:	10c5883a 	add	r2,r2,r3
811126a8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811126ac:	00a04574 	movhi	r2,33045
811126b0:	10838b04 	addi	r2,r2,3628
811126b4:	10800483 	ldbu	r2,18(r2)
811126b8:	10800044 	addi	r2,r2,1
811126bc:	1007883a 	mov	r3,r2
811126c0:	00a04574 	movhi	r2,33045
811126c4:	10838b04 	addi	r2,r2,3628
811126c8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
811126cc:	00a04574 	movhi	r2,33045
811126d0:	10838b04 	addi	r2,r2,3628
811126d4:	10800483 	ldbu	r2,18(r2)
811126d8:	10c03fcc 	andi	r3,r2,255
811126dc:	00a04574 	movhi	r2,33045
811126e0:	10837804 	addi	r2,r2,3552
811126e4:	1100068b 	ldhu	r4,26(r2)
811126e8:	00a04574 	movhi	r2,33045
811126ec:	10838b04 	addi	r2,r2,3628
811126f0:	18c00284 	addi	r3,r3,10
811126f4:	18c7883a 	add	r3,r3,r3
811126f8:	10c5883a 	add	r2,r2,r3
811126fc:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81112700:	00a04574 	movhi	r2,33045
81112704:	10838b04 	addi	r2,r2,3628
81112708:	10800483 	ldbu	r2,18(r2)
8111270c:	10800044 	addi	r2,r2,1
81112710:	1007883a 	mov	r3,r2
81112714:	00a04574 	movhi	r2,33045
81112718:	10838b04 	addi	r2,r2,3628
8111271c:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81112720:	00a04574 	movhi	r2,33045
81112724:	10838b04 	addi	r2,r2,3628
81112728:	10800483 	ldbu	r2,18(r2)
8111272c:	10c03fcc 	andi	r3,r2,255
81112730:	00a04574 	movhi	r2,33045
81112734:	10837804 	addi	r2,r2,3552
81112738:	1100070b 	ldhu	r4,28(r2)
8111273c:	00a04574 	movhi	r2,33045
81112740:	10838b04 	addi	r2,r2,3628
81112744:	18c00284 	addi	r3,r3,10
81112748:	18c7883a 	add	r3,r3,r3
8111274c:	10c5883a 	add	r2,r2,r3
81112750:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81112754:	00a04574 	movhi	r2,33045
81112758:	10838b04 	addi	r2,r2,3628
8111275c:	10800483 	ldbu	r2,18(r2)
81112760:	10800044 	addi	r2,r2,1
81112764:	1007883a 	mov	r3,r2
81112768:	00a04574 	movhi	r2,33045
8111276c:	10838b04 	addi	r2,r2,3628
81112770:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81112774:	00a04574 	movhi	r2,33045
81112778:	10838b04 	addi	r2,r2,3628
8111277c:	10800483 	ldbu	r2,18(r2)
81112780:	10c03fcc 	andi	r3,r2,255
81112784:	00a04574 	movhi	r2,33045
81112788:	10837804 	addi	r2,r2,3552
8111278c:	1100078b 	ldhu	r4,30(r2)
81112790:	00a04574 	movhi	r2,33045
81112794:	10838b04 	addi	r2,r2,3628
81112798:	18c00284 	addi	r3,r3,10
8111279c:	18c7883a 	add	r3,r3,r3
811127a0:	10c5883a 	add	r2,r2,r3
811127a4:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811127a8:	00a04574 	movhi	r2,33045
811127ac:	10838b04 	addi	r2,r2,3628
811127b0:	10800483 	ldbu	r2,18(r2)
811127b4:	10800044 	addi	r2,r2,1
811127b8:	1007883a 	mov	r3,r2
811127bc:	00a04574 	movhi	r2,33045
811127c0:	10838b04 	addi	r2,r2,3628
811127c4:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
811127c8:	00a04574 	movhi	r2,33045
811127cc:	10838b04 	addi	r2,r2,3628
811127d0:	10800483 	ldbu	r2,18(r2)
811127d4:	10c03fcc 	andi	r3,r2,255
811127d8:	00a04574 	movhi	r2,33045
811127dc:	10837804 	addi	r2,r2,3552
811127e0:	1100080b 	ldhu	r4,32(r2)
811127e4:	00a04574 	movhi	r2,33045
811127e8:	10838b04 	addi	r2,r2,3628
811127ec:	18c00284 	addi	r3,r3,10
811127f0:	18c7883a 	add	r3,r3,r3
811127f4:	10c5883a 	add	r2,r2,r3
811127f8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811127fc:	00a04574 	movhi	r2,33045
81112800:	10838b04 	addi	r2,r2,3628
81112804:	10800483 	ldbu	r2,18(r2)
81112808:	10800044 	addi	r2,r2,1
8111280c:	1007883a 	mov	r3,r2
81112810:	00a04574 	movhi	r2,33045
81112814:	10838b04 	addi	r2,r2,3628
81112818:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8111281c:	e0bfdec4 	addi	r2,fp,-133
81112820:	01802004 	movi	r6,128
81112824:	000b883a 	mov	r5,zero
81112828:	1009883a 	mov	r4,r2
8111282c:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81112830:	e0ffdec4 	addi	r3,fp,-133
81112834:	00a04574 	movhi	r2,33045
81112838:	10ad8004 	addi	r2,r2,-18944
8111283c:	1009883a 	mov	r4,r2
81112840:	00800b84 	movi	r2,46
81112844:	100d883a 	mov	r6,r2
81112848:	200b883a 	mov	r5,r4
8111284c:	1809883a 	mov	r4,r3
81112850:	11206ac0 	call	811206ac <memcpy>
									debug(fp, cPUSDebug );
81112854:	d0a06117 	ldw	r2,-32380(gp)
81112858:	e0ffdec4 	addi	r3,fp,-133
8111285c:	180b883a 	mov	r5,r3
81112860:	1009883a 	mov	r4,r2
81112864:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81112868:	e0ffde0b 	ldhu	r3,-136(fp)
8111286c:	e0bfdec4 	addi	r2,fp,-133
81112870:	180d883a 	mov	r6,r3
81112874:	01604574 	movhi	r5,33045
81112878:	296d8c04 	addi	r5,r5,-18896
8111287c:	1009883a 	mov	r4,r2
81112880:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
81112884:	d0a06117 	ldw	r2,-32380(gp)
81112888:	e0ffdec4 	addi	r3,fp,-133
8111288c:	180b883a 	mov	r5,r3
81112890:	1009883a 	mov	r4,r2
81112894:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81112898:	00a04574 	movhi	r2,33045
8111289c:	10837804 	addi	r2,r2,3552
811128a0:	1080058b 	ldhu	r2,22(r2)
811128a4:	10ffffcc 	andi	r3,r2,65535
811128a8:	e0bfdec4 	addi	r2,fp,-133
811128ac:	180d883a 	mov	r6,r3
811128b0:	01604574 	movhi	r5,33045
811128b4:	296d9304 	addi	r5,r5,-18868
811128b8:	1009883a 	mov	r4,r2
811128bc:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
811128c0:	d0a06117 	ldw	r2,-32380(gp)
811128c4:	e0ffdec4 	addi	r3,fp,-133
811128c8:	180b883a 	mov	r5,r3
811128cc:	1009883a 	mov	r4,r2
811128d0:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
811128d4:	00a04574 	movhi	r2,33045
811128d8:	10837804 	addi	r2,r2,3552
811128dc:	1080060b 	ldhu	r2,24(r2)
811128e0:	10ffffcc 	andi	r3,r2,65535
811128e4:	e0bfdec4 	addi	r2,fp,-133
811128e8:	180d883a 	mov	r6,r3
811128ec:	01604574 	movhi	r5,33045
811128f0:	296d9704 	addi	r5,r5,-18852
811128f4:	1009883a 	mov	r4,r2
811128f8:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
811128fc:	d0a06117 	ldw	r2,-32380(gp)
81112900:	e0ffdec4 	addi	r3,fp,-133
81112904:	180b883a 	mov	r5,r3
81112908:	1009883a 	mov	r4,r2
8111290c:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
81112910:	00a04574 	movhi	r2,33045
81112914:	10837804 	addi	r2,r2,3552
81112918:	1080068b 	ldhu	r2,26(r2)
8111291c:	10ffffcc 	andi	r3,r2,65535
81112920:	e0bfdec4 	addi	r2,fp,-133
81112924:	180d883a 	mov	r6,r3
81112928:	01604574 	movhi	r5,33045
8111292c:	296d9c04 	addi	r5,r5,-18832
81112930:	1009883a 	mov	r4,r2
81112934:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
81112938:	d0a06117 	ldw	r2,-32380(gp)
8111293c:	e0ffdec4 	addi	r3,fp,-133
81112940:	180b883a 	mov	r5,r3
81112944:	1009883a 	mov	r4,r2
81112948:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
8111294c:	00a04574 	movhi	r2,33045
81112950:	10837804 	addi	r2,r2,3552
81112954:	1080070b 	ldhu	r2,28(r2)
81112958:	10ffffcc 	andi	r3,r2,65535
8111295c:	e0bfdec4 	addi	r2,fp,-133
81112960:	180d883a 	mov	r6,r3
81112964:	01604574 	movhi	r5,33045
81112968:	296da304 	addi	r5,r5,-18804
8111296c:	1009883a 	mov	r4,r2
81112970:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
81112974:	d0a06117 	ldw	r2,-32380(gp)
81112978:	e0ffdec4 	addi	r3,fp,-133
8111297c:	180b883a 	mov	r5,r3
81112980:	1009883a 	mov	r4,r2
81112984:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81112988:	00a04574 	movhi	r2,33045
8111298c:	10837804 	addi	r2,r2,3552
81112990:	1080078b 	ldhu	r2,30(r2)
81112994:	10ffffcc 	andi	r3,r2,65535
81112998:	e0bfdec4 	addi	r2,fp,-133
8111299c:	180d883a 	mov	r6,r3
811129a0:	01604574 	movhi	r5,33045
811129a4:	296daa04 	addi	r5,r5,-18776
811129a8:	1009883a 	mov	r4,r2
811129ac:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
811129b0:	d0a06117 	ldw	r2,-32380(gp)
811129b4:	e0ffdec4 	addi	r3,fp,-133
811129b8:	180b883a 	mov	r5,r3
811129bc:	1009883a 	mov	r4,r2
811129c0:	111f5fc0 	call	8111f5fc <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
811129c4:	00a04574 	movhi	r2,33045
811129c8:	10837804 	addi	r2,r2,3552
811129cc:	1080080b 	ldhu	r2,32(r2)
811129d0:	10ffffcc 	andi	r3,r2,65535
811129d4:	e0bfdec4 	addi	r2,fp,-133
811129d8:	180d883a 	mov	r6,r3
811129dc:	01604574 	movhi	r5,33045
811129e0:	296db004 	addi	r5,r5,-18752
811129e4:	1009883a 	mov	r4,r2
811129e8:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
811129ec:	d0a06117 	ldw	r2,-32380(gp)
811129f0:	e0ffdec4 	addi	r3,fp,-133
811129f4:	180b883a 	mov	r5,r3
811129f8:	1009883a 	mov	r4,r2
811129fc:	111f5fc0 	call	8111f5fc <fprintf>
								#endif

								break;
81112a00:	00002106 	br	81112a88 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81112a04:	e0bfdec4 	addi	r2,fp,-133
81112a08:	01802004 	movi	r6,128
81112a0c:	000b883a 	mov	r5,zero
81112a10:	1009883a 	mov	r4,r2
81112a14:	11207fc0 	call	811207fc <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81112a18:	00a04574 	movhi	r2,33045
81112a1c:	10838b04 	addi	r2,r2,3628
81112a20:	1080030b 	ldhu	r2,12(r2)
81112a24:	113fffcc 	andi	r4,r2,65535
81112a28:	00a04574 	movhi	r2,33045
81112a2c:	10838b04 	addi	r2,r2,3628
81112a30:	1080038b 	ldhu	r2,14(r2)
81112a34:	117fffcc 	andi	r5,r2,65535
81112a38:	00a04574 	movhi	r2,33045
81112a3c:	10838b04 	addi	r2,r2,3628
81112a40:	1080040b 	ldhu	r2,16(r2)
81112a44:	10bfffcc 	andi	r2,r2,65535
81112a48:	e0ffdec4 	addi	r3,fp,-133
81112a4c:	d8800015 	stw	r2,0(sp)
81112a50:	280f883a 	mov	r7,r5
81112a54:	200d883a 	mov	r6,r4
81112a58:	01604574 	movhi	r5,33045
81112a5c:	296cdf04 	addi	r5,r5,-19588
81112a60:	1809883a 	mov	r4,r3
81112a64:	1120f8c0 	call	81120f8c <sprintf>
									debug(fp, cPUSDebug );
81112a68:	d0a06117 	ldw	r2,-32380(gp)
81112a6c:	e0ffdec4 	addi	r3,fp,-133
81112a70:	180b883a 	mov	r5,r3
81112a74:	1009883a 	mov	r4,r2
81112a78:	111f5fc0 	call	8111f5fc <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81112a7c:	00800044 	movi	r2,1
81112a80:	e0bfdc15 	stw	r2,-144(fp)
								break;
81112a84:	0001883a 	nop
						}
                        break;
81112a88:	00000306 	br	81112a98 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
81112a8c:	00800044 	movi	r2,1
81112a90:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81112a94:	0001883a 	nop
                }
				break;				
81112a98:	00000306 	br	81112aa8 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
81112a9c:	00800044 	movi	r2,1
81112aa0:	e0bfdc15 	stw	r2,-144(fp)
				break;
81112aa4:	0001883a 	nop
		}
	}
81112aa8:	003c9406 	br	81111cfc <__reset+0xfb0f1cfc>

81112aac <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
81112aac:	defffb04 	addi	sp,sp,-20
81112ab0:	de00012e 	bgeu	sp,et,81112ab8 <getPreParsedPacket+0xc>
81112ab4:	003b68fa 	trap	3
81112ab8:	dfc00415 	stw	ra,16(sp)
81112abc:	df000315 	stw	fp,12(sp)
81112ac0:	df000304 	addi	fp,sp,12
81112ac4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112ac8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
81112acc:	d0a06a17 	ldw	r2,-32344(gp)
81112ad0:	e0fffe44 	addi	r3,fp,-7
81112ad4:	180d883a 	mov	r6,r3
81112ad8:	000b883a 	mov	r5,zero
81112adc:	1009883a 	mov	r4,r2
81112ae0:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
81112ae4:	e0bffe43 	ldbu	r2,-7(fp)
81112ae8:	10803fcc 	andi	r2,r2,255
81112aec:	10002e1e 	bne	r2,zero,81112ba8 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81112af0:	e03ffe05 	stb	zero,-8(fp)
81112af4:	00002506 	br	81112b8c <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
81112af8:	e0fffe03 	ldbu	r3,-8(fp)
81112afc:	00a045b4 	movhi	r2,33046
81112b00:	10911404 	addi	r2,r2,17488
81112b04:	18c01324 	muli	r3,r3,76
81112b08:	10c5883a 	add	r2,r2,r3
81112b0c:	10800104 	addi	r2,r2,4
81112b10:	10800003 	ldbu	r2,0(r2)
81112b14:	10803fcc 	andi	r2,r2,255
81112b18:	1080201c 	xori	r2,r2,128
81112b1c:	10bfe004 	addi	r2,r2,-128
81112b20:	10001726 	beq	r2,zero,81112b80 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81112b24:	e0fffe03 	ldbu	r3,-8(fp)
81112b28:	e13fff17 	ldw	r4,-4(fp)
81112b2c:	00a045b4 	movhi	r2,33046
81112b30:	10911404 	addi	r2,r2,17488
81112b34:	18c01324 	muli	r3,r3,76
81112b38:	10c5883a 	add	r2,r2,r3
81112b3c:	2007883a 	mov	r3,r4
81112b40:	1009883a 	mov	r4,r2
81112b44:	00801304 	movi	r2,76
81112b48:	100d883a 	mov	r6,r2
81112b4c:	200b883a 	mov	r5,r4
81112b50:	1809883a 	mov	r4,r3
81112b54:	11206ac0 	call	811206ac <memcpy>
                bSuccess = TRUE;
81112b58:	00800044 	movi	r2,1
81112b5c:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81112b60:	e0fffe03 	ldbu	r3,-8(fp)
81112b64:	00a045b4 	movhi	r2,33046
81112b68:	10911404 	addi	r2,r2,17488
81112b6c:	18c01324 	muli	r3,r3,76
81112b70:	10c5883a 	add	r2,r2,r3
81112b74:	10800104 	addi	r2,r2,4
81112b78:	10000005 	stb	zero,0(r2)
                break;
81112b7c:	00000606 	br	81112b98 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81112b80:	e0bffe03 	ldbu	r2,-8(fp)
81112b84:	10800044 	addi	r2,r2,1
81112b88:	e0bffe05 	stb	r2,-8(fp)
81112b8c:	e0bffe03 	ldbu	r2,-8(fp)
81112b90:	10800230 	cmpltui	r2,r2,8
81112b94:	103fd81e 	bne	r2,zero,81112af8 <__reset+0xfb0f2af8>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81112b98:	d0a06a17 	ldw	r2,-32344(gp)
81112b9c:	1009883a 	mov	r4,r2
81112ba0:	113b0b00 	call	8113b0b0 <OSMutexPost>
81112ba4:	00000106 	br	81112bac <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81112ba8:	111a31c0 	call	8111a31c <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
81112bac:	e0bffd17 	ldw	r2,-12(fp)
}
81112bb0:	e037883a 	mov	sp,fp
81112bb4:	dfc00117 	ldw	ra,4(sp)
81112bb8:	df000017 	ldw	fp,0(sp)
81112bbc:	dec00204 	addi	sp,sp,8
81112bc0:	f800283a 	ret

81112bc4 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
81112bc4:	defffa04 	addi	sp,sp,-24
81112bc8:	de00012e 	bgeu	sp,et,81112bd0 <bSendMessagePUStoMebTask+0xc>
81112bcc:	003b68fa 	trap	3
81112bd0:	dfc00515 	stw	ra,20(sp)
81112bd4:	df000415 	stw	fp,16(sp)
81112bd8:	df000404 	addi	fp,sp,16
81112bdc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112be0:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
81112be4:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
81112be8:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
81112bec:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
81112bf0:	d0a07217 	ldw	r2,-32312(gp)
81112bf4:	e0fffd44 	addi	r3,fp,-11
81112bf8:	180d883a 	mov	r6,r3
81112bfc:	01400284 	movi	r5,10
81112c00:	1009883a 	mov	r4,r2
81112c04:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81112c08:	e0bffd43 	ldbu	r2,-11(fp)
81112c0c:	10803fcc 	andi	r2,r2,255
81112c10:	1000401e 	bne	r2,zero,81112d14 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
81112c14:	e03ffd05 	stb	zero,-12(fp)
81112c18:	00003806 	br	81112cfc <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
81112c1c:	e0fffd03 	ldbu	r3,-12(fp)
81112c20:	00a04574 	movhi	r2,33045
81112c24:	108e3604 	addi	r2,r2,14552
81112c28:	18c01524 	muli	r3,r3,84
81112c2c:	10c5883a 	add	r2,r2,r3
81112c30:	10800104 	addi	r2,r2,4
81112c34:	10800017 	ldw	r2,0(r2)
81112c38:	10002d1e 	bne	r2,zero,81112cf0 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
81112c3c:	e0fffd03 	ldbu	r3,-12(fp)
81112c40:	00a04574 	movhi	r2,33045
81112c44:	108e3604 	addi	r2,r2,14552
81112c48:	18c01524 	muli	r3,r3,84
81112c4c:	10c7883a 	add	r3,r2,r3
81112c50:	e0bfff17 	ldw	r2,-4(fp)
81112c54:	1009883a 	mov	r4,r2
81112c58:	00801504 	movi	r2,84
81112c5c:	100d883a 	mov	r6,r2
81112c60:	200b883a 	mov	r5,r4
81112c64:	1809883a 	mov	r4,r3
81112c68:	11206ac0 	call	811206ac <memcpy>
            	xPus[i].bInUse = TRUE;
81112c6c:	e0fffd03 	ldbu	r3,-12(fp)
81112c70:	00a04574 	movhi	r2,33045
81112c74:	108e3604 	addi	r2,r2,14552
81112c78:	18c01524 	muli	r3,r3,84
81112c7c:	10c5883a 	add	r2,r2,r3
81112c80:	10800104 	addi	r2,r2,4
81112c84:	00c00044 	movi	r3,1
81112c88:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
81112c8c:	00800044 	movi	r2,1
81112c90:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81112c94:	00800044 	movi	r2,1
81112c98:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
81112c9c:	d0a06817 	ldw	r2,-32352(gp)
81112ca0:	e0fffe17 	ldw	r3,-8(fp)
81112ca4:	180b883a 	mov	r5,r3
81112ca8:	1009883a 	mov	r4,r2
81112cac:	113c0280 	call	8113c028 <OSQPost>
81112cb0:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81112cb4:	e0bffd43 	ldbu	r2,-11(fp)
81112cb8:	10803fcc 	andi	r2,r2,255
81112cbc:	10000926 	beq	r2,zero,81112ce4 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
81112cc0:	111b20c0 	call	8111b20c <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
81112cc4:	e0fffd03 	ldbu	r3,-12(fp)
81112cc8:	00a04574 	movhi	r2,33045
81112ccc:	108e3604 	addi	r2,r2,14552
81112cd0:	18c01524 	muli	r3,r3,84
81112cd4:	10c5883a 	add	r2,r2,r3
81112cd8:	10800104 	addi	r2,r2,4
81112cdc:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81112ce0:	00000906 	br	81112d08 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
81112ce4:	00800044 	movi	r2,1
81112ce8:	e0bffc15 	stw	r2,-16(fp)
                break;
81112cec:	00000606 	br	81112d08 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
81112cf0:	e0bffd03 	ldbu	r2,-12(fp)
81112cf4:	10800044 	addi	r2,r2,1
81112cf8:	e0bffd05 	stb	r2,-12(fp)
81112cfc:	e0bffd03 	ldbu	r2,-12(fp)
81112d00:	10800130 	cmpltui	r2,r2,4
81112d04:	103fc51e 	bne	r2,zero,81112c1c <__reset+0xfb0f2c1c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
81112d08:	d0a07217 	ldw	r2,-32312(gp)
81112d0c:	1009883a 	mov	r4,r2
81112d10:	113b0b00 	call	8113b0b0 <OSMutexPost>
    }

    return bSuccess;
81112d14:	e0bffc17 	ldw	r2,-16(fp)
}
81112d18:	e037883a 	mov	sp,fp
81112d1c:	dfc00117 	ldw	ra,4(sp)
81112d20:	df000017 	ldw	fp,0(sp)
81112d24:	dec00204 	addi	sp,sp,8
81112d28:	f800283a 	ret

81112d2c <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
81112d2c:	deffab04 	addi	sp,sp,-340
81112d30:	de00012e 	bgeu	sp,et,81112d38 <vReceiverUartTask+0xc>
81112d34:	003b68fa 	trap	3
81112d38:	dfc05415 	stw	ra,336(sp)
81112d3c:	df005315 	stw	fp,332(sp)
81112d40:	df005304 	addi	fp,sp,332
81112d44:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112d48:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
81112d4c:	d0a06117 	ldw	r2,-32380(gp)
81112d50:	100f883a 	mov	r7,r2
81112d54:	01800784 	movi	r6,30
81112d58:	01400044 	movi	r5,1
81112d5c:	01204574 	movhi	r4,33045
81112d60:	212db604 	addi	r4,r4,-18728
81112d64:	111fc980 	call	8111fc98 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81112d68:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
81112d6c:	e0bfad17 	ldw	r2,-332(fp)
81112d70:	10c00060 	cmpeqi	r3,r2,1
81112d74:	1800091e 	bne	r3,zero,81112d9c <vReceiverUartTask+0x70>
81112d78:	0080052e 	bgeu	zero,r2,81112d90 <vReceiverUartTask+0x64>
81112d7c:	10c000a0 	cmpeqi	r3,r2,2
81112d80:	18005d1e 	bne	r3,zero,81112ef8 <vReceiverUartTask+0x1cc>
81112d84:	108000e0 	cmpeqi	r2,r2,3
81112d88:	10006e1e 	bne	r2,zero,81112f44 <vReceiverUartTask+0x218>
81112d8c:	00007706 	br	81112f6c <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81112d90:	00800044 	movi	r2,1
81112d94:	e0bfad15 	stw	r2,-332(fp)
                break;
81112d98:	00007706 	br	81112f78 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
81112d9c:	e0bfaf04 	addi	r2,fp,-324
81112da0:	01802004 	movi	r6,128
81112da4:	000b883a 	mov	r5,zero
81112da8:	1009883a 	mov	r4,r2
81112dac:	11207fc0 	call	811207fc <memset>
                scanf("%s", cReceive);
81112db0:	e0bfcf04 	addi	r2,fp,-196
81112db4:	100b883a 	mov	r5,r2
81112db8:	01204574 	movhi	r4,33045
81112dbc:	212dbe04 	addi	r4,r4,-18696
81112dc0:	1120eb00 	call	81120eb0 <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
81112dc4:	e0ffcf04 	addi	r3,fp,-196
81112dc8:	e0bfaf04 	addi	r2,fp,-324
81112dcc:	01801fc4 	movi	r6,127
81112dd0:	180b883a 	mov	r5,r3
81112dd4:	1009883a 	mov	r4,r2
81112dd8:	11206ac0 	call	811206ac <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
81112ddc:	e0bfaf04 	addi	r2,fp,-324
81112de0:	01604574 	movhi	r5,33045
81112de4:	2943a004 	addi	r5,r5,3712
81112de8:	1009883a 	mov	r4,r2
81112dec:	11133d00 	call	811133d0 <bPreParserV2>
81112df0:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
81112df4:	e0bfae17 	ldw	r2,-328(fp)
81112df8:	10800058 	cmpnei	r2,r2,1
81112dfc:	1000281e 	bne	r2,zero,81112ea0 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
81112e00:	00a04574 	movhi	r2,33045
81112e04:	1083a004 	addi	r2,r2,3712
81112e08:	10800103 	ldbu	r2,4(r2)
81112e0c:	10803fcc 	andi	r2,r2,255
81112e10:	1080201c 	xori	r2,r2,128
81112e14:	10bfe004 	addi	r2,r2,-128
81112e18:	10800fe0 	cmpeqi	r2,r2,63
81112e1c:	1000081e 	bne	r2,zero,81112e40 <vReceiverUartTask+0x114>
81112e20:	00a04574 	movhi	r2,33045
81112e24:	1083a004 	addi	r2,r2,3712
81112e28:	10800103 	ldbu	r2,4(r2)
81112e2c:	10803fcc 	andi	r2,r2,255
81112e30:	1080201c 	xori	r2,r2,128
81112e34:	10bfe004 	addi	r2,r2,-128
81112e38:	10800858 	cmpnei	r2,r2,33
81112e3c:	1000031e 	bne	r2,zero,81112e4c <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81112e40:	00800084 	movi	r2,2
81112e44:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81112e48:	00004b06 	br	81112f78 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81112e4c:	00a04574 	movhi	r2,33045
81112e50:	1083a004 	addi	r2,r2,3712
81112e54:	10800103 	ldbu	r2,4(r2)
81112e58:	10803fcc 	andi	r2,r2,255
81112e5c:	1080201c 	xori	r2,r2,128
81112e60:	10bfe004 	addi	r2,r2,-128
81112e64:	108008d8 	cmpnei	r2,r2,35
81112e68:	10000a1e 	bne	r2,zero,81112e94 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81112e6c:	00800044 	movi	r2,1
81112e70:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81112e74:	d0a06117 	ldw	r2,-32380(gp)
81112e78:	100f883a 	mov	r7,r2
81112e7c:	018006c4 	movi	r6,27
81112e80:	01400044 	movi	r5,1
81112e84:	01204574 	movhi	r4,33045
81112e88:	212dbf04 	addi	r4,r4,-18692
81112e8c:	111fc980 	call	8111fc98 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81112e90:	00003906 	br	81112f78 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81112e94:	008000c4 	movi	r2,3
81112e98:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81112e9c:	00003606 	br	81112f78 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81112ea0:	00a04574 	movhi	r2,33045
81112ea4:	1083a004 	addi	r2,r2,3712
81112ea8:	00c008c4 	movi	r3,35
81112eac:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81112eb0:	00a04574 	movhi	r2,33045
81112eb4:	1083a004 	addi	r2,r2,3712
81112eb8:	00c00b84 	movi	r3,46
81112ebc:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81112ec0:	00a04574 	movhi	r2,33045
81112ec4:	1083a004 	addi	r2,r2,3712
81112ec8:	00c00044 	movi	r3,1
81112ecc:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81112ed0:	01204574 	movhi	r4,33045
81112ed4:	2103a004 	addi	r4,r4,3712
81112ed8:	11130b80 	call	811130b8 <setPreAckSenderFreePos>
81112edc:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81112ee0:	e0bfae17 	ldw	r2,-328(fp)
81112ee4:	1000011e 	bne	r2,zero,81112eec <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81112ee8:	111a4540 	call	8111a454 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81112eec:	00800044 	movi	r2,1
81112ef0:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81112ef4:	00002006 	br	81112f78 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81112ef8:	01204574 	movhi	r4,33045
81112efc:	2103a004 	addi	r4,r4,3712
81112f00:	11130b80 	call	811130b8 <setPreAckSenderFreePos>
81112f04:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81112f08:	e0bfae17 	ldw	r2,-328(fp)
81112f0c:	10800058 	cmpnei	r2,r2,1
81112f10:	1000081e 	bne	r2,zero,81112f34 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81112f14:	01204574 	movhi	r4,33045
81112f18:	2103a004 	addi	r4,r4,3712
81112f1c:	1112f7c0 	call	81112f7c <setPreParsedFreePos>
81112f20:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81112f24:	e0bfae17 	ldw	r2,-328(fp)
81112f28:	1000031e 	bne	r2,zero,81112f38 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81112f2c:	111a5240 	call	8111a524 <vFailSetPreParsedBuffer>
81112f30:	00000106 	br	81112f38 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81112f34:	111a4bc0 	call	8111a4bc <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81112f38:	00800044 	movi	r2,1
81112f3c:	e0bfad15 	stw	r2,-332(fp)
                break;
81112f40:	00000d06 	br	81112f78 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81112f44:	01204574 	movhi	r4,33045
81112f48:	2103a004 	addi	r4,r4,3712
81112f4c:	11132340 	call	81113234 <setPreAckReceiverFreePos>
81112f50:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81112f54:	e0bfae17 	ldw	r2,-328(fp)
81112f58:	1000011e 	bne	r2,zero,81112f60 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81112f5c:	111a58c0 	call	8111a58c <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81112f60:	00800044 	movi	r2,1
81112f64:	e0bfad15 	stw	r2,-332(fp)
                break;
81112f68:	00000306 	br	81112f78 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81112f6c:	00800044 	movi	r2,1
81112f70:	e0bfad15 	stw	r2,-332(fp)
                break;
81112f74:	0001883a 	nop
        }

    }
81112f78:	003f7c06 	br	81112d6c <__reset+0xfb0f2d6c>

81112f7c <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81112f7c:	defffb04 	addi	sp,sp,-20
81112f80:	de00012e 	bgeu	sp,et,81112f88 <setPreParsedFreePos+0xc>
81112f84:	003b68fa 	trap	3
81112f88:	dfc00415 	stw	ra,16(sp)
81112f8c:	df000315 	stw	fp,12(sp)
81112f90:	df000304 	addi	fp,sp,12
81112f94:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81112f98:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81112f9c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81112fa0:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81112fa4:	d0a06a17 	ldw	r2,-32344(gp)
81112fa8:	e0fffe44 	addi	r3,fp,-7
81112fac:	180d883a 	mov	r6,r3
81112fb0:	01400284 	movi	r5,10
81112fb4:	1009883a 	mov	r4,r2
81112fb8:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81112fbc:	e0bffe43 	ldbu	r2,-7(fp)
81112fc0:	10803fcc 	andi	r2,r2,255
81112fc4:	1000361e 	bne	r2,zero,811130a0 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81112fc8:	e03ffe05 	stb	zero,-8(fp)
81112fcc:	00002e06 	br	81113088 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81112fd0:	e0fffe03 	ldbu	r3,-8(fp)
81112fd4:	00a045b4 	movhi	r2,33046
81112fd8:	10911404 	addi	r2,r2,17488
81112fdc:	18c01324 	muli	r3,r3,76
81112fe0:	10c5883a 	add	r2,r2,r3
81112fe4:	10800104 	addi	r2,r2,4
81112fe8:	10800003 	ldbu	r2,0(r2)
81112fec:	10803fcc 	andi	r2,r2,255
81112ff0:	1080201c 	xori	r2,r2,128
81112ff4:	10bfe004 	addi	r2,r2,-128
81112ff8:	1000201e 	bne	r2,zero,8111307c <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81112ffc:	e0fffe03 	ldbu	r3,-8(fp)
81113000:	00a045b4 	movhi	r2,33046
81113004:	10911404 	addi	r2,r2,17488
81113008:	18c01324 	muli	r3,r3,76
8111300c:	10c7883a 	add	r3,r2,r3
81113010:	e0bfff17 	ldw	r2,-4(fp)
81113014:	1009883a 	mov	r4,r2
81113018:	00801304 	movi	r2,76
8111301c:	100d883a 	mov	r6,r2
81113020:	200b883a 	mov	r5,r4
81113024:	1809883a 	mov	r4,r3
81113028:	11206ac0 	call	811206ac <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
8111302c:	d0a06317 	ldw	r2,-32372(gp)
81113030:	1009883a 	mov	r4,r2
81113034:	113cea00 	call	8113cea0 <OSSemPost>
81113038:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
8111303c:	e0bffe43 	ldbu	r2,-7(fp)
81113040:	10803fcc 	andi	r2,r2,255
81113044:	1000031e 	bne	r2,zero,81113054 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81113048:	00800044 	movi	r2,1
8111304c:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81113050:	00001006 	br	81113094 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81113054:	1119b740 	call	81119b74 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81113058:	e0fffe03 	ldbu	r3,-8(fp)
8111305c:	00a045b4 	movhi	r2,33046
81113060:	10911404 	addi	r2,r2,17488
81113064:	18c01324 	muli	r3,r3,76
81113068:	10c5883a 	add	r2,r2,r3
8111306c:	10800104 	addi	r2,r2,4
81113070:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81113074:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81113078:	00000606 	br	81113094 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
8111307c:	e0bffe03 	ldbu	r2,-8(fp)
81113080:	10800044 	addi	r2,r2,1
81113084:	e0bffe05 	stb	r2,-8(fp)
81113088:	e0bffe03 	ldbu	r2,-8(fp)
8111308c:	10800230 	cmpltui	r2,r2,8
81113090:	103fcf1e 	bne	r2,zero,81112fd0 <__reset+0xfb0f2fd0>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81113094:	d0a06a17 	ldw	r2,-32344(gp)
81113098:	1009883a 	mov	r4,r2
8111309c:	113b0b00 	call	8113b0b0 <OSMutexPost>
    }
    return bSuccess;
811130a0:	e0bffd17 	ldw	r2,-12(fp)
}
811130a4:	e037883a 	mov	sp,fp
811130a8:	dfc00117 	ldw	ra,4(sp)
811130ac:	df000017 	ldw	fp,0(sp)
811130b0:	dec00204 	addi	sp,sp,8
811130b4:	f800283a 	ret

811130b8 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
811130b8:	defffb04 	addi	sp,sp,-20
811130bc:	de00012e 	bgeu	sp,et,811130c4 <setPreAckSenderFreePos+0xc>
811130c0:	003b68fa 	trap	3
811130c4:	dfc00415 	stw	ra,16(sp)
811130c8:	df000315 	stw	fp,12(sp)
811130cc:	df000304 	addi	fp,sp,12
811130d0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811130d4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
811130d8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
811130dc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
811130e0:	d0a07117 	ldw	r2,-32316(gp)
811130e4:	e0fffe44 	addi	r3,fp,-7
811130e8:	180d883a 	mov	r6,r3
811130ec:	01400284 	movi	r5,10
811130f0:	1009883a 	mov	r4,r2
811130f4:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811130f8:	e0bffe43 	ldbu	r2,-7(fp)
811130fc:	10803fcc 	andi	r2,r2,255
81113100:	1000461e 	bne	r2,zero,8111321c <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81113104:	e03ffe05 	stb	zero,-8(fp)
81113108:	00003e06 	br	81113204 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
8111310c:	e0fffe03 	ldbu	r3,-8(fp)
81113110:	00a045b4 	movhi	r2,33046
81113114:	10910c04 	addi	r2,r2,17456
81113118:	18c7883a 	add	r3,r3,r3
8111311c:	18c7883a 	add	r3,r3,r3
81113120:	10c5883a 	add	r2,r2,r3
81113124:	10800003 	ldbu	r2,0(r2)
81113128:	10803fcc 	andi	r2,r2,255
8111312c:	1080201c 	xori	r2,r2,128
81113130:	10bfe004 	addi	r2,r2,-128
81113134:	1000301e 	bne	r2,zero,811131f8 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81113138:	e0fffe03 	ldbu	r3,-8(fp)
8111313c:	e0bfff17 	ldw	r2,-4(fp)
81113140:	11000103 	ldbu	r4,4(r2)
81113144:	00a045b4 	movhi	r2,33046
81113148:	10910c04 	addi	r2,r2,17456
8111314c:	18c7883a 	add	r3,r3,r3
81113150:	18c7883a 	add	r3,r3,r3
81113154:	10c5883a 	add	r2,r2,r3
81113158:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
8111315c:	e0fffe03 	ldbu	r3,-8(fp)
81113160:	e0bfff17 	ldw	r2,-4(fp)
81113164:	11000143 	ldbu	r4,5(r2)
81113168:	00a045b4 	movhi	r2,33046
8111316c:	10910c04 	addi	r2,r2,17456
81113170:	18c7883a 	add	r3,r3,r3
81113174:	18c7883a 	add	r3,r3,r3
81113178:	10c5883a 	add	r2,r2,r3
8111317c:	10800044 	addi	r2,r2,1
81113180:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81113184:	e0fffe03 	ldbu	r3,-8(fp)
81113188:	e0bfff17 	ldw	r2,-4(fp)
8111318c:	1100020b 	ldhu	r4,8(r2)
81113190:	00a045b4 	movhi	r2,33046
81113194:	10910c04 	addi	r2,r2,17456
81113198:	18c7883a 	add	r3,r3,r3
8111319c:	18c7883a 	add	r3,r3,r3
811131a0:	10c5883a 	add	r2,r2,r3
811131a4:	10800084 	addi	r2,r2,2
811131a8:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
811131ac:	d0a06017 	ldw	r2,-32384(gp)
811131b0:	1009883a 	mov	r4,r2
811131b4:	113cea00 	call	8113cea0 <OSSemPost>
811131b8:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
811131bc:	e0bffe43 	ldbu	r2,-7(fp)
811131c0:	10803fcc 	andi	r2,r2,255
811131c4:	10000926 	beq	r2,zero,811131ec <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
811131c8:	1119c0c0 	call	81119c0c <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
811131cc:	e0fffe03 	ldbu	r3,-8(fp)
811131d0:	00a045b4 	movhi	r2,33046
811131d4:	10910c04 	addi	r2,r2,17456
811131d8:	18c7883a 	add	r3,r3,r3
811131dc:	18c7883a 	add	r3,r3,r3
811131e0:	10c5883a 	add	r2,r2,r3
811131e4:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811131e8:	00000906 	br	81113210 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
811131ec:	00800044 	movi	r2,1
811131f0:	e0bffd15 	stw	r2,-12(fp)
                break;
811131f4:	00000606 	br	81113210 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
811131f8:	e0bffe03 	ldbu	r2,-8(fp)
811131fc:	10800044 	addi	r2,r2,1
81113200:	e0bffe05 	stb	r2,-8(fp)
81113204:	e0bffe03 	ldbu	r2,-8(fp)
81113208:	10800230 	cmpltui	r2,r2,8
8111320c:	103fbf1e 	bne	r2,zero,8111310c <__reset+0xfb0f310c>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81113210:	d0a07117 	ldw	r2,-32316(gp)
81113214:	1009883a 	mov	r4,r2
81113218:	113b0b00 	call	8113b0b0 <OSMutexPost>
    }

    return bSuccess;
8111321c:	e0bffd17 	ldw	r2,-12(fp)
}
81113220:	e037883a 	mov	sp,fp
81113224:	dfc00117 	ldw	ra,4(sp)
81113228:	df000017 	ldw	fp,0(sp)
8111322c:	dec00204 	addi	sp,sp,8
81113230:	f800283a 	ret

81113234 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81113234:	defffb04 	addi	sp,sp,-20
81113238:	de00012e 	bgeu	sp,et,81113240 <setPreAckReceiverFreePos+0xc>
8111323c:	003b68fa 	trap	3
81113240:	dfc00415 	stw	ra,16(sp)
81113244:	df000315 	stw	fp,12(sp)
81113248:	df000304 	addi	fp,sp,12
8111324c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81113250:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81113254:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81113258:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
8111325c:	d0a06417 	ldw	r2,-32368(gp)
81113260:	e0fffe44 	addi	r3,fp,-7
81113264:	180d883a 	mov	r6,r3
81113268:	01400504 	movi	r5,20
8111326c:	1009883a 	mov	r4,r2
81113270:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81113274:	e0bffe43 	ldbu	r2,-7(fp)
81113278:	10803fcc 	andi	r2,r2,255
8111327c:	1000471e 	bne	r2,zero,8111339c <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81113280:	e03ffe05 	stb	zero,-8(fp)
81113284:	00003e06 	br	81113380 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81113288:	e0fffe03 	ldbu	r3,-8(fp)
8111328c:	00a045b4 	movhi	r2,33046
81113290:	10bafa04 	addi	r2,r2,-5144
81113294:	18c7883a 	add	r3,r3,r3
81113298:	18c7883a 	add	r3,r3,r3
8111329c:	10c5883a 	add	r2,r2,r3
811132a0:	10800003 	ldbu	r2,0(r2)
811132a4:	10803fcc 	andi	r2,r2,255
811132a8:	1080201c 	xori	r2,r2,128
811132ac:	10bfe004 	addi	r2,r2,-128
811132b0:	1000301e 	bne	r2,zero,81113374 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
811132b4:	e0fffe03 	ldbu	r3,-8(fp)
811132b8:	e0bfff17 	ldw	r2,-4(fp)
811132bc:	11000103 	ldbu	r4,4(r2)
811132c0:	00a045b4 	movhi	r2,33046
811132c4:	10bafa04 	addi	r2,r2,-5144
811132c8:	18c7883a 	add	r3,r3,r3
811132cc:	18c7883a 	add	r3,r3,r3
811132d0:	10c5883a 	add	r2,r2,r3
811132d4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
811132d8:	e0fffe03 	ldbu	r3,-8(fp)
811132dc:	e0bfff17 	ldw	r2,-4(fp)
811132e0:	11000143 	ldbu	r4,5(r2)
811132e4:	00a045b4 	movhi	r2,33046
811132e8:	10bafa04 	addi	r2,r2,-5144
811132ec:	18c7883a 	add	r3,r3,r3
811132f0:	18c7883a 	add	r3,r3,r3
811132f4:	10c5883a 	add	r2,r2,r3
811132f8:	10800044 	addi	r2,r2,1
811132fc:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81113300:	e0fffe03 	ldbu	r3,-8(fp)
81113304:	e0bfff17 	ldw	r2,-4(fp)
81113308:	1100020b 	ldhu	r4,8(r2)
8111330c:	00a045b4 	movhi	r2,33046
81113310:	10bafa04 	addi	r2,r2,-5144
81113314:	18c7883a 	add	r3,r3,r3
81113318:	18c7883a 	add	r3,r3,r3
8111331c:	10c5883a 	add	r2,r2,r3
81113320:	10800084 	addi	r2,r2,2
81113324:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81113328:	d0a06517 	ldw	r2,-32364(gp)
8111332c:	1009883a 	mov	r4,r2
81113330:	113cea00 	call	8113cea0 <OSSemPost>
81113334:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81113338:	e0bffe43 	ldbu	r2,-7(fp)
8111333c:	10803fcc 	andi	r2,r2,255
81113340:	1000031e 	bne	r2,zero,81113350 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81113344:	00800044 	movi	r2,1
81113348:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
8111334c:	00000f06 	br	8111338c <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81113350:	1119bc00 	call	81119bc0 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81113354:	e0fffe03 	ldbu	r3,-8(fp)
81113358:	00a045b4 	movhi	r2,33046
8111335c:	10bafa04 	addi	r2,r2,-5144
81113360:	18c7883a 	add	r3,r3,r3
81113364:	18c7883a 	add	r3,r3,r3
81113368:	10c5883a 	add	r2,r2,r3
8111336c:	10000005 	stb	zero,0(r2)
                }
                break;
81113370:	00000606 	br	8111338c <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81113374:	e0bffe03 	ldbu	r2,-8(fp)
81113378:	10800044 	addi	r2,r2,1
8111337c:	e0bffe05 	stb	r2,-8(fp)
81113380:	e0bffe03 	ldbu	r2,-8(fp)
81113384:	108001b0 	cmpltui	r2,r2,6
81113388:	103fbf1e 	bne	r2,zero,81113288 <__reset+0xfb0f3288>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
8111338c:	d0a06417 	ldw	r2,-32368(gp)
81113390:	1009883a 	mov	r4,r2
81113394:	113b0b00 	call	8113b0b0 <OSMutexPost>
81113398:	00000706 	br	811133b8 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
8111339c:	d0a06117 	ldw	r2,-32380(gp)
811133a0:	100f883a 	mov	r7,r2
811133a4:	01801404 	movi	r6,80
811133a8:	01400044 	movi	r5,1
811133ac:	01204574 	movhi	r4,33045
811133b0:	212dc604 	addi	r4,r4,-18664
811133b4:	111fc980 	call	8111fc98 <fwrite>
        #endif
    }

    return bSuccess;
811133b8:	e0bffd17 	ldw	r2,-12(fp)
}
811133bc:	e037883a 	mov	sp,fp
811133c0:	dfc00117 	ldw	ra,4(sp)
811133c4:	df000017 	ldw	fp,0(sp)
811133c8:	dec00204 	addi	sp,sp,8
811133cc:	f800283a 	ret

811133d0 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
811133d0:	defff404 	addi	sp,sp,-48
811133d4:	de00012e 	bgeu	sp,et,811133dc <bPreParserV2+0xc>
811133d8:	003b68fa 	trap	3
811133dc:	dfc00b15 	stw	ra,44(sp)
811133e0:	df000a15 	stw	fp,40(sp)
811133e4:	dc000915 	stw	r16,36(sp)
811133e8:	df000a04 	addi	fp,sp,40
811133ec:	e13ffd15 	stw	r4,-12(fp)
811133f0:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
811133f4:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
811133f8:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
811133fc:	01402004 	movi	r5,128
81113400:	e13ffd17 	ldw	r4,-12(fp)
81113404:	11212380 	call	81121238 <strnlen>
81113408:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
8111340c:	01400ec4 	movi	r5,59
81113410:	e13ffd17 	ldw	r4,-12(fp)
81113414:	1117b800 	call	81117b80 <siPosStr>
81113418:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
8111341c:	e0fff98f 	ldh	r3,-26(fp)
81113420:	e0bff90f 	ldh	r2,-28(fp)
81113424:	10bfffc4 	addi	r2,r2,-1
81113428:	18800226 	beq	r3,r2,81113434 <bPreParserV2+0x64>
        return bSuccess;
8111342c:	e0bff617 	ldw	r2,-40(fp)
81113430:	0000ba06 	br	8111371c <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81113434:	01401f04 	movi	r5,124
81113438:	e13ffd17 	ldw	r4,-12(fp)
8111343c:	1117b800 	call	81117b80 <siPosStr>
81113440:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81113444:	e0bffa0f 	ldh	r2,-24(fp)
81113448:	e0fff98f 	ldh	r3,-26(fp)
8111344c:	1880020e 	bge	r3,r2,81113458 <bPreParserV2+0x88>
        return bSuccess;
81113450:	e0bff617 	ldw	r2,-40(fp)
81113454:	0000b106 	br	8111371c <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81113458:	01604574 	movhi	r5,33045
8111345c:	296ddb04 	addi	r5,r5,-18580
81113460:	e13ffd17 	ldw	r4,-12(fp)
81113464:	11211540 	call	81121154 <strcspn>
81113468:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8111346c:	e0bffa8f 	ldh	r2,-22(fp)
81113470:	e0fffa0f 	ldh	r3,-24(fp)
81113474:	1880020e 	bge	r3,r2,81113480 <bPreParserV2+0xb0>
        return bSuccess;
81113478:	e0bff617 	ldw	r2,-40(fp)
8111347c:	0000a706 	br	8111371c <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81113480:	e0bffa8f 	ldh	r2,-22(fp)
81113484:	e0fffd17 	ldw	r3,-12(fp)
81113488:	1885883a 	add	r2,r3,r2
8111348c:	10c00003 	ldbu	r3,0(r2)
81113490:	e0bffe17 	ldw	r2,-8(fp)
81113494:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81113498:	e0bffe17 	ldw	r2,-8(fp)
8111349c:	10800103 	ldbu	r2,4(r2)
811134a0:	10803fcc 	andi	r2,r2,255
811134a4:	1080201c 	xori	r2,r2,128
811134a8:	10bfe004 	addi	r2,r2,-128
811134ac:	108008d8 	cmpnei	r2,r2,35
811134b0:	1000041e 	bne	r2,zero,811134c4 <bPreParserV2+0xf4>
        bSuccess = TRUE;
811134b4:	00800044 	movi	r2,1
811134b8:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
811134bc:	e0bff617 	ldw	r2,-40(fp)
811134c0:	00009606 	br	8111371c <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
811134c4:	e0bffa8f 	ldh	r2,-22(fp)
811134c8:	e0fffd17 	ldw	r3,-12(fp)
811134cc:	1889883a 	add	r4,r3,r2
811134d0:	e0fffa0f 	ldh	r3,-24(fp)
811134d4:	e0bffa8f 	ldh	r2,-22(fp)
811134d8:	1885c83a 	sub	r2,r3,r2
811134dc:	100b883a 	mov	r5,r2
811134e0:	111981c0 	call	8111981c <ucCrc8wInit>
811134e4:	1007883a 	mov	r3,r2
811134e8:	e0bffe17 	ldw	r2,-8(fp)
811134ec:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
811134f0:	e0bffa8f 	ldh	r2,-22(fp)
811134f4:	10800044 	addi	r2,r2,1
811134f8:	e0fffd17 	ldw	r3,-12(fp)
811134fc:	1885883a 	add	r2,r3,r2
81113500:	10c00003 	ldbu	r3,0(r2)
81113504:	e0bffe17 	ldw	r2,-8(fp)
81113508:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
8111350c:	e0bffe17 	ldw	r2,-8(fp)
81113510:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
81113514:	e0bffe17 	ldw	r2,-8(fp)
81113518:	10800204 	addi	r2,r2,8
8111351c:	01801004 	movi	r6,64
81113520:	000b883a 	mov	r5,zero
81113524:	1009883a 	mov	r4,r2
81113528:	11207fc0 	call	811207fc <memset>

    i = siIni + 3; /* "?C:i..." */
8111352c:	e0bffa8b 	ldhu	r2,-22(fp)
81113530:	108000c4 	addi	r2,r2,3
81113534:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81113538:	e0bffb44 	addi	r2,fp,-19
8111353c:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81113540:	e0bffb44 	addi	r2,fp,-19
81113544:	01800184 	movi	r6,6
81113548:	000b883a 	mov	r5,zero
8111354c:	1009883a 	mov	r4,r2
81113550:	11207fc0 	call	811207fc <memset>
        do {
            c = buffer[i];
81113554:	e0bff703 	ldbu	r2,-36(fp)
81113558:	e0fffd17 	ldw	r3,-12(fp)
8111355c:	1885883a 	add	r2,r3,r2
81113560:	10800003 	ldbu	r2,0(r2)
81113564:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81113568:	d0e00317 	ldw	r3,-32756(gp)
8111356c:	e0bffb07 	ldb	r2,-20(fp)
81113570:	10800044 	addi	r2,r2,1
81113574:	1885883a 	add	r2,r3,r2
81113578:	10800003 	ldbu	r2,0(r2)
8111357c:	10803fcc 	andi	r2,r2,255
81113580:	1080010c 	andi	r2,r2,4
81113584:	10000626 	beq	r2,zero,811135a0 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81113588:	e0bff817 	ldw	r2,-32(fp)
8111358c:	e0fffb03 	ldbu	r3,-20(fp)
81113590:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81113594:	e0bff817 	ldw	r2,-32(fp)
81113598:	10800044 	addi	r2,r2,1
8111359c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
811135a0:	e0bff703 	ldbu	r2,-36(fp)
811135a4:	10800044 	addi	r2,r2,1
811135a8:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
811135ac:	e0bff90f 	ldh	r2,-28(fp)
811135b0:	e0fff703 	ldbu	r3,-36(fp)
811135b4:	1880090e 	bge	r3,r2,811135dc <bPreParserV2+0x20c>
811135b8:	e0bffb07 	ldb	r2,-20(fp)
811135bc:	10800ea0 	cmpeqi	r2,r2,58
811135c0:	1000061e 	bne	r2,zero,811135dc <bPreParserV2+0x20c>
811135c4:	e0bffb07 	ldb	r2,-20(fp)
811135c8:	10800ee0 	cmpeqi	r2,r2,59
811135cc:	1000031e 	bne	r2,zero,811135dc <bPreParserV2+0x20c>
811135d0:	e0bffb07 	ldb	r2,-20(fp)
811135d4:	10801f18 	cmpnei	r2,r2,124
811135d8:	103fde1e 	bne	r2,zero,81113554 <__reset+0xfb0f3554>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811135dc:	e0bff817 	ldw	r2,-32(fp)
811135e0:	00c00284 	movi	r3,10
811135e4:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
811135e8:	e0bffb07 	ldb	r2,-20(fp)
811135ec:	10800ea0 	cmpeqi	r2,r2,58
811135f0:	1000031e 	bne	r2,zero,81113600 <bPreParserV2+0x230>
811135f4:	e0bffb07 	ldb	r2,-20(fp)
811135f8:	10801f18 	cmpnei	r2,r2,124
811135fc:	10001a1e 	bne	r2,zero,81113668 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
81113600:	e0bffe17 	ldw	r2,-8(fp)
81113604:	10800183 	ldbu	r2,6(r2)
81113608:	10803fcc 	andi	r2,r2,255
8111360c:	10800828 	cmpgeui	r2,r2,32
81113610:	1000041e 	bne	r2,zero,81113624 <bPreParserV2+0x254>
81113614:	e0bffe17 	ldw	r2,-8(fp)
81113618:	10800183 	ldbu	r2,6(r2)
8111361c:	14003fcc 	andi	r16,r2,255
81113620:	00000106 	br	81113628 <bPreParserV2+0x258>
81113624:	04000804 	movi	r16,32
81113628:	e0bffb44 	addi	r2,fp,-19
8111362c:	1009883a 	mov	r4,r2
81113630:	111f4a00 	call	8111f4a0 <atoi>
81113634:	1009883a 	mov	r4,r2
81113638:	e0fffe17 	ldw	r3,-8(fp)
8111363c:	80800104 	addi	r2,r16,4
81113640:	1085883a 	add	r2,r2,r2
81113644:	1885883a 	add	r2,r3,r2
81113648:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8111364c:	e0bffe17 	ldw	r2,-8(fp)
81113650:	10800183 	ldbu	r2,6(r2)
81113654:	10800044 	addi	r2,r2,1
81113658:	1007883a 	mov	r3,r2
8111365c:	e0bffe17 	ldw	r2,-8(fp)
81113660:	10c00185 	stb	r3,6(r2)
81113664:	00000906 	br	8111368c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81113668:	e0bffb07 	ldb	r2,-20(fp)
8111366c:	10800ed8 	cmpnei	r2,r2,59
81113670:	1000061e 	bne	r2,zero,8111368c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81113674:	e0bffb44 	addi	r2,fp,-19
81113678:	1009883a 	mov	r4,r2
8111367c:	111f4a00 	call	8111f4a0 <atoi>
81113680:	1007883a 	mov	r3,r2
81113684:	e0bffe17 	ldw	r2,-8(fp)
81113688:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8111368c:	e0bffb07 	ldb	r2,-20(fp)
81113690:	10800ee0 	cmpeqi	r2,r2,59
81113694:	1000031e 	bne	r2,zero,811136a4 <bPreParserV2+0x2d4>
81113698:	e0bff90f 	ldh	r2,-28(fp)
8111369c:	e0fff703 	ldbu	r3,-36(fp)
811136a0:	18bfa516 	blt	r3,r2,81113538 <__reset+0xfb0f3538>


    if ( c == FINAL_CHAR )
811136a4:	e0bffb07 	ldb	r2,-20(fp)
811136a8:	10800ed8 	cmpnei	r2,r2,59
811136ac:	1000191e 	bne	r2,zero,81113714 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
811136b0:	e0bffe17 	ldw	r2,-8(fp)
811136b4:	10c01243 	ldbu	r3,73(r2)
811136b8:	e0bffe17 	ldw	r2,-8(fp)
811136bc:	10801203 	ldbu	r2,72(r2)
811136c0:	18c03fcc 	andi	r3,r3,255
811136c4:	10803fcc 	andi	r2,r2,255
811136c8:	1880031e 	bne	r3,r2,811136d8 <bPreParserV2+0x308>
            bSuccess = TRUE;
811136cc:	00800044 	movi	r2,1
811136d0:	e0bff615 	stw	r2,-40(fp)
811136d4:	00001006 	br	81113718 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
811136d8:	d0e06117 	ldw	r3,-32380(gp)
811136dc:	e0bffe17 	ldw	r2,-8(fp)
811136e0:	10801203 	ldbu	r2,72(r2)
811136e4:	11003fcc 	andi	r4,r2,255
811136e8:	e0bffe17 	ldw	r2,-8(fp)
811136ec:	10801243 	ldbu	r2,73(r2)
811136f0:	10803fcc 	andi	r2,r2,255
811136f4:	100f883a 	mov	r7,r2
811136f8:	200d883a 	mov	r6,r4
811136fc:	01604574 	movhi	r5,33045
81113700:	296ddd04 	addi	r5,r5,-18572
81113704:	1809883a 	mov	r4,r3
81113708:	111f5fc0 	call	8111f5fc <fprintf>
            #endif
            bSuccess = FALSE;
8111370c:	e03ff615 	stw	zero,-40(fp)
81113710:	00000106 	br	81113718 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
81113714:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
81113718:	e0bff617 	ldw	r2,-40(fp)
}
8111371c:	e6ffff04 	addi	sp,fp,-4
81113720:	dfc00217 	ldw	ra,8(sp)
81113724:	df000117 	ldw	fp,4(sp)
81113728:	dc000017 	ldw	r16,0(sp)
8111372c:	dec00304 	addi	sp,sp,12
81113730:	f800283a 	ret

81113734 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81113734:	defffb04 	addi	sp,sp,-20
81113738:	de00012e 	bgeu	sp,et,81113740 <vSenderComTask+0xc>
8111373c:	003b68fa 	trap	3
81113740:	dfc00415 	stw	ra,16(sp)
81113744:	df000315 	stw	fp,12(sp)
81113748:	df000304 	addi	fp,sp,12
8111374c:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81113750:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81113754:	d0a06117 	ldw	r2,-32380(gp)
81113758:	100f883a 	mov	r7,r2
8111375c:	01800704 	movi	r6,28
81113760:	01400044 	movi	r5,1
81113764:	01204574 	movhi	r4,33045
81113768:	212de904 	addi	r4,r4,-18524
8111376c:	111fc980 	call	8111fc98 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81113770:	e0bffd17 	ldw	r2,-12(fp)
81113774:	10c00060 	cmpeqi	r3,r2,1
81113778:	1800091e 	bne	r3,zero,811137a0 <vSenderComTask+0x6c>
8111377c:	0080052e 	bgeu	zero,r2,81113794 <vSenderComTask+0x60>
81113780:	10c000a0 	cmpeqi	r3,r2,2
81113784:	1800471e 	bne	r3,zero,811138a4 <vSenderComTask+0x170>
81113788:	10800160 	cmpeqi	r2,r2,5
8111378c:	10002c1e 	bne	r2,zero,81113840 <vSenderComTask+0x10c>
81113790:	00003a06 	br	8111387c <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81113794:	00800044 	movi	r2,1
81113798:	e0bffd15 	stw	r2,-12(fp)
                break;
8111379c:	00004206 	br	811138a8 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
811137a0:	d0a06117 	ldw	r2,-32380(gp)
811137a4:	100f883a 	mov	r7,r2
811137a8:	01800784 	movi	r6,30
811137ac:	01400044 	movi	r5,1
811137b0:	01204574 	movhi	r4,33045
811137b4:	212df104 	addi	r4,r4,-18492
811137b8:	111fc980 	call	8111fc98 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
811137bc:	01400044 	movi	r5,1
811137c0:	01204574 	movhi	r4,33045
811137c4:	212df904 	addi	r4,r4,-18460
811137c8:	11172780 	call	81117278 <bSendUART32v2>
811137cc:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
811137d0:	e0bffe17 	ldw	r2,-8(fp)
811137d4:	10800058 	cmpnei	r2,r2,1
811137d8:	10000a1e 	bne	r2,zero,81113804 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
811137dc:	00800144 	movi	r2,5
811137e0:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
811137e4:	d0a06117 	ldw	r2,-32380(gp)
811137e8:	100f883a 	mov	r7,r2
811137ec:	01800d44 	movi	r6,53
811137f0:	01400044 	movi	r5,1
811137f4:	01204574 	movhi	r4,33045
811137f8:	212dfc04 	addi	r4,r4,-18448
811137fc:	111fc980 	call	8111fc98 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
81113800:	00002906 	br	811138a8 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
81113804:	d0a06117 	ldw	r2,-32380(gp)
81113808:	100f883a 	mov	r7,r2
8111380c:	01800784 	movi	r6,30
81113810:	01400044 	movi	r5,1
81113814:	01204574 	movhi	r4,33045
81113818:	212e0a04 	addi	r4,r4,-18392
8111381c:	111fc980 	call	8111fc98 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81113820:	00800044 	movi	r2,1
81113824:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81113828:	000f883a 	mov	r7,zero
8111382c:	01800144 	movi	r6,5
81113830:	000b883a 	mov	r5,zero
81113834:	0009883a 	mov	r4,zero
81113838:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
                }
                break;
8111383c:	00001a06 	br	811138a8 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81113840:	00800144 	movi	r2,5
81113844:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81113848:	d0a06117 	ldw	r2,-32380(gp)
8111384c:	100f883a 	mov	r7,r2
81113850:	018002c4 	movi	r6,11
81113854:	01400044 	movi	r5,1
81113858:	01204574 	movhi	r4,33045
8111385c:	212e1204 	addi	r4,r4,-18360
81113860:	111fc980 	call	8111fc98 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81113864:	000f883a 	mov	r7,zero
81113868:	01800644 	movi	r6,25
8111386c:	000b883a 	mov	r5,zero
81113870:	0009883a 	mov	r4,zero
81113874:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>

                break;
81113878:	00000b06 	br	811138a8 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
8111387c:	d0a06117 	ldw	r2,-32380(gp)
81113880:	100f883a 	mov	r7,r2
81113884:	018003c4 	movi	r6,15
81113888:	01400044 	movi	r5,1
8111388c:	01204574 	movhi	r4,33045
81113890:	212e1504 	addi	r4,r4,-18348
81113894:	111fc980 	call	8111fc98 <fwrite>
                #endif
                eSenderMode = sDummySender;
81113898:	00800144 	movi	r2,5
8111389c:	e0bffd15 	stw	r2,-12(fp)
                break;
811138a0:	00000106 	br	811138a8 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
811138a4:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
811138a8:	003fb106 	br	81113770 <__reset+0xfb0f3770>

811138ac <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
811138ac:	defff804 	addi	sp,sp,-32
811138b0:	de00012e 	bgeu	sp,et,811138b8 <vSimMebTask+0xc>
811138b4:	003b68fa 	trap	3
811138b8:	dfc00715 	stw	ra,28(sp)
811138bc:	df000615 	stw	fp,24(sp)
811138c0:	df000604 	addi	fp,sp,24
811138c4:	e13fff15 	stw	r4,-4(fp)
	unsigned char tCodeNext;
	unsigned char ucIL;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
811138c8:	e0bfff17 	ldw	r2,-4(fp)
811138cc:	e0bffb15 	stw	r2,-20(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
811138d0:	d0a06117 	ldw	r2,-32380(gp)
811138d4:	100f883a 	mov	r7,r2
811138d8:	018008c4 	movi	r6,35
811138dc:	01400044 	movi	r5,1
811138e0:	01204574 	movhi	r4,33045
811138e4:	212e1904 	addi	r4,r4,-18332
811138e8:	111fc980 	call	8111fc98 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
811138ec:	e0bffb17 	ldw	r2,-20(fp)
811138f0:	10800117 	ldw	r2,4(r2)
811138f4:	10c00168 	cmpgeui	r3,r2,5
811138f8:	1800df1e 	bne	r3,zero,81113c78 <vSimMebTask+0x3cc>
811138fc:	100690ba 	slli	r3,r2,2
81113900:	00a04474 	movhi	r2,33041
81113904:	108e4504 	addi	r2,r2,14612
81113908:	1885883a 	add	r2,r3,r2
8111390c:	10800017 	ldw	r2,0(r2)
81113910:	1000683a 	jmp	r2
81113914:	81113928 	cmpgeui	r4,r16,17636
81113918:	81113940 	call	88111394 <__reset+0x20f1394>
8111391c:	811139c0 	call	8811139c <__reset+0x20f139c>
81113920:	81113a8c 	andi	r4,r16,17642
81113924:	81113b64 	muli	r4,r16,17645
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81113928:	e13ffb17 	ldw	r4,-20(fp)
8111392c:	1114a1c0 	call	81114a1c <vMebInit>
				pxMebC->eMode = sMebToConfig;
81113930:	e0bffb17 	ldw	r2,-20(fp)
81113934:	00c00044 	movi	r3,1
81113938:	10c00115 	stw	r3,4(r2)
				break;
8111393c:	0000d906 	br	81113ca4 <vSimMebTask+0x3f8>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
81113940:	d0a06117 	ldw	r2,-32380(gp)
81113944:	100f883a 	mov	r7,r2
81113948:	01800584 	movi	r6,22
8111394c:	01400044 	movi	r5,1
81113950:	01204574 	movhi	r4,33045
81113954:	212e2204 	addi	r4,r4,-18296
81113958:	111fc980 	call	8111fc98 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
8111395c:	111cee40 	call	8111cee4 <bStopSync>
				vSyncClearCounter();
81113960:	110c5d80 	call	8110c5d8 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81113964:	1114b240 	call	81114b24 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81113968:	01c00284 	movi	r7,10
8111396c:	000d883a 	mov	r6,zero
81113970:	000b883a 	mov	r5,zero
81113974:	0009883a 	mov	r4,zero
81113978:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
8111397c:	000d883a 	mov	r6,zero
81113980:	000b883a 	mov	r5,zero
81113984:	01002844 	movi	r4,161
81113988:	11147f00 	call	811147f0 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
8111398c:	000d883a 	mov	r6,zero
81113990:	000b883a 	mov	r5,zero
81113994:	01002844 	movi	r4,161
81113998:	11149940 	call	81114994 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
8111399c:	01c03e84 	movi	r7,250
811139a0:	000d883a 	mov	r6,zero
811139a4:	000b883a 	mov	r5,zero
811139a8:	0009883a 	mov	r4,zero
811139ac:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
811139b0:	e0bffb17 	ldw	r2,-20(fp)
811139b4:	00c000c4 	movi	r3,3
811139b8:	10c00115 	stw	r3,4(r2)
				break;
811139bc:	0000b906 	br	81113ca4 <vSimMebTask+0x3f8>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
811139c0:	d0a06117 	ldw	r2,-32380(gp)
811139c4:	100f883a 	mov	r7,r2
811139c8:	018004c4 	movi	r6,19
811139cc:	01400044 	movi	r5,1
811139d0:	01204574 	movhi	r4,33045
811139d4:	212e2804 	addi	r4,r4,-18272
811139d8:	111fc980 	call	8111fc98 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
811139dc:	000d883a 	mov	r6,zero
811139e0:	000b883a 	mov	r5,zero
811139e4:	01002884 	movi	r4,162
811139e8:	11147f00 	call	811147f0 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
811139ec:	000d883a 	mov	r6,zero
811139f0:	000b883a 	mov	r5,zero
811139f4:	01002884 	movi	r4,162
811139f8:	11149940 	call	81114994 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811139fc:	e0bffb17 	ldw	r2,-20(fp)
81113a00:	1080050b 	ldhu	r2,20(r2)
81113a04:	10bfffcc 	andi	r2,r2,65535
81113a08:	100f883a 	mov	r7,r2
81113a0c:	000d883a 	mov	r6,zero
81113a10:	000b883a 	mov	r5,zero
81113a14:	0009883a 	mov	r4,zero
81113a18:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81113a1c:	e03ffa05 	stb	zero,-24(fp)
81113a20:	00001006 	br	81113a64 <vSimMebTask+0x1b8>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
81113a24:	e0bffa03 	ldbu	r2,-24(fp)
81113a28:	10809624 	muli	r2,r2,600
81113a2c:	10809b04 	addi	r2,r2,620
81113a30:	e0fffb17 	ldw	r3,-20(fp)
81113a34:	1885883a 	add	r2,r3,r2
81113a38:	1009883a 	mov	r4,r2
81113a3c:	110a0e00 	call	8110a0e0 <bSpwcClearTimecode>
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
81113a40:	e0bffa03 	ldbu	r2,-24(fp)
81113a44:	e0fffb17 	ldw	r3,-20(fp)
81113a48:	10809624 	muli	r2,r2,600
81113a4c:	1885883a 	add	r2,r3,r2
81113a50:	10803c04 	addi	r2,r2,240
81113a54:	10000005 	stb	zero,0(r2)
				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				for (ucIL = 0; ucIL < N_OF_NFEE; ++ucIL) {
81113a58:	e0bffa03 	ldbu	r2,-24(fp)
81113a5c:	10800044 	addi	r2,r2,1
81113a60:	e0bffa05 	stb	r2,-24(fp)
81113a64:	e0bffa03 	ldbu	r2,-24(fp)
81113a68:	103fee26 	beq	r2,zero,81113a24 <__reset+0xfb0f3a24>
					bSpwcClearTimecode(&pxMebC->xFeeControl.xNfee[ucIL].xChannel.xSpacewire);
					pxMebC->xFeeControl.xNfee[ucIL].xControl.ucTimeCode = 0;
				}

				bSyncCtrReset();
81113a6c:	110cc280 	call	8110cc28 <bSyncCtrReset>
				vSyncClearCounter();
81113a70:	110c5d80 	call	8110c5d8 <vSyncClearCounter>
				bStartSync();
81113a74:	111cea80 	call	8111cea8 <bStartSync>

				vEvtChangeMebMode();
81113a78:	111b8b80 	call	8111b8b8 <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81113a7c:	e0bffb17 	ldw	r2,-20(fp)
81113a80:	00c00104 	movi	r3,4
81113a84:	10c00115 	stw	r3,4(r2)
				break;
81113a88:	00008606 	br	81113ca4 <vSimMebTask+0x3f8>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81113a8c:	d0a06817 	ldw	r2,-32352(gp)
81113a90:	e0fffe04 	addi	r3,fp,-8
81113a94:	180d883a 	mov	r6,r3
81113a98:	000b883a 	mov	r5,zero
81113a9c:	1009883a 	mov	r4,r2
81113aa0:	113bc200 	call	8113bc20 <OSQPend>
81113aa4:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81113aa8:	e0bffe03 	ldbu	r2,-8(fp)
81113aac:	10803fcc 	andi	r2,r2,255
81113ab0:	1000291e 	bne	r2,zero,81113b58 <vSimMebTask+0x2ac>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81113ab4:	e0bffdc3 	ldbu	r2,-9(fp)
81113ab8:	10803fcc 	andi	r2,r2,255
81113abc:	10800058 	cmpnei	r2,r2,1
81113ac0:	10001c1e 	bne	r2,zero,81113b34 <vSimMebTask+0x288>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81113ac4:	e0bffd83 	ldbu	r2,-10(fp)
81113ac8:	10803fcc 	andi	r2,r2,255
81113acc:	10c00060 	cmpeqi	r3,r2,1
81113ad0:	1800031e 	bne	r3,zero,81113ae0 <vSimMebTask+0x234>
81113ad4:	10803820 	cmpeqi	r2,r2,224
81113ad8:	1000041e 	bne	r2,zero,81113aec <vSimMebTask+0x240>
81113adc:	00000b06 	br	81113b0c <vSimMebTask+0x260>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81113ae0:	e13ffb17 	ldw	r4,-20(fp)
81113ae4:	1113ca80 	call	81113ca8 <vPusMebTask>
								break;
81113ae8:	00001d06 	br	81113b60 <vSimMebTask+0x2b4>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81113aec:	d0a06117 	ldw	r2,-32380(gp)
81113af0:	100f883a 	mov	r7,r2
81113af4:	018012c4 	movi	r6,75
81113af8:	01400044 	movi	r5,1
81113afc:	01204574 	movhi	r4,33045
81113b00:	212e2d04 	addi	r4,r4,-18252
81113b04:	111fc980 	call	8111fc98 <fwrite>
								#endif
								break;
81113b08:	00001506 	br	81113b60 <vSimMebTask+0x2b4>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81113b0c:	d0a06117 	ldw	r2,-32380(gp)
81113b10:	e0fffd83 	ldbu	r3,-10(fp)
81113b14:	18c03fcc 	andi	r3,r3,255
81113b18:	180d883a 	mov	r6,r3
81113b1c:	01604574 	movhi	r5,33045
81113b20:	296e4004 	addi	r5,r5,-18176
81113b24:	1009883a 	mov	r4,r2
81113b28:	111f5fc0 	call	8111f5fc <fprintf>
								#endif
								break;
81113b2c:	0001883a 	nop
81113b30:	00000b06 	br	81113b60 <vSimMebTask+0x2b4>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81113b34:	d0a06117 	ldw	r2,-32380(gp)
81113b38:	e0fffdc3 	ldbu	r3,-9(fp)
81113b3c:	18c03fcc 	andi	r3,r3,255
81113b40:	180d883a 	mov	r6,r3
81113b44:	01604574 	movhi	r5,33045
81113b48:	296e5204 	addi	r5,r5,-18104
81113b4c:	1009883a 	mov	r4,r2
81113b50:	111f5fc0 	call	8111f5fc <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
81113b54:	00005306 	br	81113ca4 <vSimMebTask+0x3f8>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81113b58:	111b2580 	call	8111b258 <vCouldNotGetCmdQueueMeb>
				}

				break;
81113b5c:	00005106 	br	81113ca4 <vSimMebTask+0x3f8>
81113b60:	00005006 	br	81113ca4 <vSimMebTask+0x3f8>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81113b64:	d0a06817 	ldw	r2,-32352(gp)
81113b68:	e0fffe04 	addi	r3,fp,-8
81113b6c:	180d883a 	mov	r6,r3
81113b70:	000b883a 	mov	r5,zero
81113b74:	1009883a 	mov	r4,r2
81113b78:	113bc200 	call	8113bc20 <OSQPend>
81113b7c:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81113b80:	e0bffe03 	ldbu	r2,-8(fp)
81113b84:	10803fcc 	andi	r2,r2,255
81113b88:	1000381e 	bne	r2,zero,81113c6c <vSimMebTask+0x3c0>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81113b8c:	e0bffdc3 	ldbu	r2,-9(fp)
81113b90:	10803fcc 	andi	r2,r2,255
81113b94:	10800058 	cmpnei	r2,r2,1
81113b98:	10002b1e 	bne	r2,zero,81113c48 <vSimMebTask+0x39c>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81113b9c:	e0bffd83 	ldbu	r2,-10(fp)
81113ba0:	10803fcc 	andi	r2,r2,255
81113ba4:	10c03820 	cmpeqi	r3,r2,224
81113ba8:	1800071e 	bne	r3,zero,81113bc8 <vSimMebTask+0x31c>
81113bac:	10c03860 	cmpeqi	r3,r2,225
81113bb0:	1800071e 	bne	r3,zero,81113bd0 <vSimMebTask+0x324>
81113bb4:	10800060 	cmpeqi	r2,r2,1
81113bb8:	10001926 	beq	r2,zero,81113c20 <vSimMebTask+0x374>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81113bbc:	e13ffb17 	ldw	r4,-20(fp)
81113bc0:	1113ca80 	call	81113ca8 <vPusMebTask>
								break;
81113bc4:	00002b06 	br	81113c74 <vSimMebTask+0x3c8>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81113bc8:	e13ffb17 	ldw	r4,-20(fp)
81113bcc:	1114a800 	call	81114a80 <vSwapMemmory>
							case M_SYNC:
								#ifdef DEBUG_ON
									bSpwcGetTimecode(&pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire);
81113bd0:	e0bffb17 	ldw	r2,-20(fp)
81113bd4:	10809b04 	addi	r2,r2,620
81113bd8:	1009883a 	mov	r4,r2
81113bdc:	110a0500 	call	8110a050 <bSpwcGetTimecode>
									tCode = ( pxMebC->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
81113be0:	e0bffb17 	ldw	r2,-20(fp)
81113be4:	1080a743 	ldbu	r2,669(r2)
81113be8:	e0bffc05 	stb	r2,-16(fp)
									tCodeNext = ( tCode ) % 4;
81113bec:	e0bffc03 	ldbu	r2,-16(fp)
81113bf0:	108000cc 	andi	r2,r2,3
81113bf4:	e0bffc45 	stb	r2,-15(fp)

									fprintf(fp,"\n\nMEB TASK:  TC: %hhu ( %hhu ) \n\n ", tCode, tCodeNext);
81113bf8:	d0a06117 	ldw	r2,-32380(gp)
81113bfc:	e0fffc03 	ldbu	r3,-16(fp)
81113c00:	e13ffc43 	ldbu	r4,-15(fp)
81113c04:	200f883a 	mov	r7,r4
81113c08:	180d883a 	mov	r6,r3
81113c0c:	01604574 	movhi	r5,33045
81113c10:	296e6004 	addi	r5,r5,-18048
81113c14:	1009883a 	mov	r4,r2
81113c18:	111f5fc0 	call	8111f5fc <fprintf>

								#endif

								break;
81113c1c:	00001506 	br	81113c74 <vSimMebTask+0x3c8>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command (%hhu)\n", uiCmdMeb.ucByte[2]);
81113c20:	d0a06117 	ldw	r2,-32380(gp)
81113c24:	e0fffd83 	ldbu	r3,-10(fp)
81113c28:	18c03fcc 	andi	r3,r3,255
81113c2c:	180d883a 	mov	r6,r3
81113c30:	01604574 	movhi	r5,33045
81113c34:	296e6904 	addi	r5,r5,-18012
81113c38:	1009883a 	mov	r4,r2
81113c3c:	111f5fc0 	call	8111f5fc <fprintf>
								#endif
								break;
81113c40:	0001883a 	nop
81113c44:	00000b06 	br	81113c74 <vSimMebTask+0x3c8>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
81113c48:	d0a06117 	ldw	r2,-32380(gp)
81113c4c:	e0fffdc3 	ldbu	r3,-9(fp)
81113c50:	18c03fcc 	andi	r3,r3,255
81113c54:	180d883a 	mov	r6,r3
81113c58:	01604574 	movhi	r5,33045
81113c5c:	296e5204 	addi	r5,r5,-18104
81113c60:	1009883a 	mov	r4,r2
81113c64:	111f5fc0 	call	8111f5fc <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
81113c68:	00000e06 	br	81113ca4 <vSimMebTask+0x3f8>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81113c6c:	111b2580 	call	8111b258 <vCouldNotGetCmdQueueMeb>
				}			
				break;
81113c70:	00000c06 	br	81113ca4 <vSimMebTask+0x3f8>
81113c74:	00000b06 	br	81113ca4 <vSimMebTask+0x3f8>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
81113c78:	d0a06117 	ldw	r2,-32380(gp)
81113c7c:	100f883a 	mov	r7,r2
81113c80:	01800bc4 	movi	r6,47
81113c84:	01400044 	movi	r5,1
81113c88:	01204574 	movhi	r4,33045
81113c8c:	212e7204 	addi	r4,r4,-17976
81113c90:	111fc980 	call	8111fc98 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
81113c94:	e0bffb17 	ldw	r2,-20(fp)
81113c98:	00c00044 	movi	r3,1
81113c9c:	10c00115 	stw	r3,4(r2)
				break;
81113ca0:	0001883a 	nop
		}
	}
81113ca4:	003f1106 	br	811138ec <__reset+0xfb0f38ec>

81113ca8 <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
81113ca8:	defffb04 	addi	sp,sp,-20
81113cac:	de00012e 	bgeu	sp,et,81113cb4 <vPusMebTask+0xc>
81113cb0:	003b68fa 	trap	3
81113cb4:	dfc00415 	stw	ra,16(sp)
81113cb8:	df000315 	stw	fp,12(sp)
81113cbc:	df000304 	addi	fp,sp,12
81113cc0:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
81113cc4:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
81113cc8:	d0a07217 	ldw	r2,-32312(gp)
81113ccc:	e0fffe44 	addi	r3,fp,-7
81113cd0:	180d883a 	mov	r6,r3
81113cd4:	01400084 	movi	r5,2
81113cd8:	1009883a 	mov	r4,r2
81113cdc:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
81113ce0:	e0bffe43 	ldbu	r2,-7(fp)
81113ce4:	10803fcc 	andi	r2,r2,255
81113ce8:	10002c1e 	bne	r2,zero,81113d9c <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81113cec:	e03ffe05 	stb	zero,-8(fp)
81113cf0:	00002306 	br	81113d80 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81113cf4:	e0fffe03 	ldbu	r3,-8(fp)
81113cf8:	00a04574 	movhi	r2,33045
81113cfc:	108e3604 	addi	r2,r2,14552
81113d00:	18c01524 	muli	r3,r3,84
81113d04:	10c5883a 	add	r2,r2,r3
81113d08:	10800104 	addi	r2,r2,4
81113d0c:	10800017 	ldw	r2,0(r2)
81113d10:	10800058 	cmpnei	r2,r2,1
81113d14:	1000171e 	bne	r2,zero,81113d74 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
81113d18:	e13ffe03 	ldbu	r4,-8(fp)
81113d1c:	00e04574 	movhi	r3,33045
81113d20:	18c3b304 	addi	r3,r3,3788
81113d24:	00a04574 	movhi	r2,33045
81113d28:	108e3604 	addi	r2,r2,14552
81113d2c:	21001524 	muli	r4,r4,84
81113d30:	1105883a 	add	r2,r2,r4
81113d34:	1009883a 	mov	r4,r2
81113d38:	00801504 	movi	r2,84
81113d3c:	100d883a 	mov	r6,r2
81113d40:	200b883a 	mov	r5,r4
81113d44:	1809883a 	mov	r4,r3
81113d48:	11206ac0 	call	811206ac <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81113d4c:	e0fffe03 	ldbu	r3,-8(fp)
81113d50:	00a04574 	movhi	r2,33045
81113d54:	108e3604 	addi	r2,r2,14552
81113d58:	18c01524 	muli	r3,r3,84
81113d5c:	10c5883a 	add	r2,r2,r3
81113d60:	10800104 	addi	r2,r2,4
81113d64:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
81113d68:	00800044 	movi	r2,1
81113d6c:	e0bffd15 	stw	r2,-12(fp)
                break;
81113d70:	00000606 	br	81113d8c <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81113d74:	e0bffe03 	ldbu	r2,-8(fp)
81113d78:	10800044 	addi	r2,r2,1
81113d7c:	e0bffe05 	stb	r2,-8(fp)
81113d80:	e0bffe03 	ldbu	r2,-8(fp)
81113d84:	10800130 	cmpltui	r2,r2,4
81113d88:	103fda1e 	bne	r2,zero,81113cf4 <__reset+0xfb0f3cf4>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
81113d8c:	d0a07217 	ldw	r2,-32312(gp)
81113d90:	1009883a 	mov	r4,r2
81113d94:	113b0b00 	call	8113b0b0 <OSMutexPost>
81113d98:	00000106 	br	81113da0 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
81113d9c:	111b2c00 	call	8111b2c0 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
81113da0:	e0bffd17 	ldw	r2,-12(fp)
81113da4:	10001126 	beq	r2,zero,81113dec <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
81113da8:	e0bfff17 	ldw	r2,-4(fp)
81113dac:	10800117 	ldw	r2,4(r2)
81113db0:	10c000e0 	cmpeqi	r3,r2,3
81113db4:	1800031e 	bne	r3,zero,81113dc4 <vPusMebTask+0x11c>
81113db8:	10800120 	cmpeqi	r2,r2,4
81113dbc:	1000061e 	bne	r2,zero,81113dd8 <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
81113dc0:	00000a06 	br	81113dec <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
81113dc4:	01604574 	movhi	r5,33045
81113dc8:	2943b304 	addi	r5,r5,3788
81113dcc:	e13fff17 	ldw	r4,-4(fp)
81113dd0:	1113e040 	call	81113e04 <vPusMebInTaskConfigMode>
				break;
81113dd4:	00000506 	br	81113dec <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
81113dd8:	01604574 	movhi	r5,33045
81113ddc:	2943b304 	addi	r5,r5,3788
81113de0:	e13fff17 	ldw	r4,-4(fp)
81113de4:	11141940 	call	81114194 <vPusMebInTaskRunningMode>
				break;
81113de8:	0001883a 	nop
			default:
				break;
		}
	}
}
81113dec:	0001883a 	nop
81113df0:	e037883a 	mov	sp,fp
81113df4:	dfc00117 	ldw	ra,4(sp)
81113df8:	df000017 	ldw	fp,0(sp)
81113dfc:	dec00204 	addi	sp,sp,8
81113e00:	f800283a 	ret

81113e04 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113e04:	defffc04 	addi	sp,sp,-16
81113e08:	de00012e 	bgeu	sp,et,81113e10 <vPusMebInTaskConfigMode+0xc>
81113e0c:	003b68fa 	trap	3
81113e10:	dfc00315 	stw	ra,12(sp)
81113e14:	df000215 	stw	fp,8(sp)
81113e18:	df000204 	addi	fp,sp,8
81113e1c:	e13ffe15 	stw	r4,-8(fp)
81113e20:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81113e24:	e0bfff17 	ldw	r2,-4(fp)
81113e28:	1080030b 	ldhu	r2,12(r2)
81113e2c:	10bfffcc 	andi	r2,r2,65535
81113e30:	10c03ee0 	cmpeqi	r3,r2,251
81113e34:	1800081e 	bne	r3,zero,81113e58 <vPusMebInTaskConfigMode+0x54>
81113e38:	10c03f20 	cmpeqi	r3,r2,252
81113e3c:	18000a1e 	bne	r3,zero,81113e68 <vPusMebInTaskConfigMode+0x64>
81113e40:	10803ea0 	cmpeqi	r2,r2,250
81113e44:	10000c26 	beq	r2,zero,81113e78 <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
81113e48:	e17fff17 	ldw	r5,-4(fp)
81113e4c:	e13ffe17 	ldw	r4,-8(fp)
81113e50:	1113eb00 	call	81113eb0 <vPusType250conf>
			break;
81113e54:	00001006 	br	81113e98 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
81113e58:	e17fff17 	ldw	r5,-4(fp)
81113e5c:	e13ffe17 	ldw	r4,-8(fp)
81113e60:	1113f3c0 	call	81113f3c <vPusType251conf>
			break;
81113e64:	00000c06 	br	81113e98 <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
81113e68:	e17fff17 	ldw	r5,-4(fp)
81113e6c:	e13ffe17 	ldw	r4,-8(fp)
81113e70:	1113f900 	call	81113f90 <vPusType252conf>
			break;
81113e74:	00000806 	br	81113e98 <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
81113e78:	d0a06117 	ldw	r2,-32380(gp)
81113e7c:	100f883a 	mov	r7,r2
81113e80:	01800d84 	movi	r6,54
81113e84:	01400044 	movi	r5,1
81113e88:	01204574 	movhi	r4,33045
81113e8c:	212e7e04 	addi	r4,r4,-17928
81113e90:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
81113e94:	0001883a 	nop
	}
}
81113e98:	0001883a 	nop
81113e9c:	e037883a 	mov	sp,fp
81113ea0:	dfc00117 	ldw	ra,4(sp)
81113ea4:	df000017 	ldw	fp,0(sp)
81113ea8:	dec00204 	addi	sp,sp,8
81113eac:	f800283a 	ret

81113eb0 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113eb0:	defffc04 	addi	sp,sp,-16
81113eb4:	de00012e 	bgeu	sp,et,81113ebc <vPusType250conf+0xc>
81113eb8:	003b68fa 	trap	3
81113ebc:	dfc00315 	stw	ra,12(sp)
81113ec0:	df000215 	stw	fp,8(sp)
81113ec4:	df000204 	addi	fp,sp,8
81113ec8:	e13ffe15 	stw	r4,-8(fp)
81113ecc:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81113ed0:	e0bfff17 	ldw	r2,-4(fp)
81113ed4:	1080038b 	ldhu	r2,14(r2)
81113ed8:	10bfffcc 	andi	r2,r2,65535
81113edc:	10c00f60 	cmpeqi	r3,r2,61
81113ee0:	1800031e 	bne	r3,zero,81113ef0 <vPusType250conf+0x40>
81113ee4:	10800fa0 	cmpeqi	r2,r2,62
81113ee8:	10000d1e 	bne	r2,zero,81113f20 <vPusType250conf+0x70>
81113eec:	00000406 	br	81113f00 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81113ef0:	e0bffe17 	ldw	r2,-8(fp)
81113ef4:	00c00084 	movi	r3,2
81113ef8:	10c00115 	stw	r3,4(r2)
			break;
81113efc:	00000906 	br	81113f24 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81113f00:	d0a06117 	ldw	r2,-32380(gp)
81113f04:	100f883a 	mov	r7,r2
81113f08:	01800b04 	movi	r6,44
81113f0c:	01400044 	movi	r5,1
81113f10:	01204574 	movhi	r4,33045
81113f14:	212e8c04 	addi	r4,r4,-17872
81113f18:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
81113f1c:	00000106 	br	81113f24 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81113f20:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81113f24:	0001883a 	nop
81113f28:	e037883a 	mov	sp,fp
81113f2c:	dfc00117 	ldw	ra,4(sp)
81113f30:	df000017 	ldw	fp,0(sp)
81113f34:	dec00204 	addi	sp,sp,8
81113f38:	f800283a 	ret

81113f3c <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113f3c:	defffc04 	addi	sp,sp,-16
81113f40:	de00012e 	bgeu	sp,et,81113f48 <vPusType251conf+0xc>
81113f44:	003b68fa 	trap	3
81113f48:	dfc00315 	stw	ra,12(sp)
81113f4c:	df000215 	stw	fp,8(sp)
81113f50:	df000204 	addi	fp,sp,8
81113f54:	e13ffe15 	stw	r4,-8(fp)
81113f58:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81113f5c:	d0a06117 	ldw	r2,-32380(gp)
81113f60:	100f883a 	mov	r7,r2
81113f64:	01801184 	movi	r6,70
81113f68:	01400044 	movi	r5,1
81113f6c:	01204574 	movhi	r4,33045
81113f70:	212e9804 	addi	r4,r4,-17824
81113f74:	111fc980 	call	8111fc98 <fwrite>
	#endif
}
81113f78:	0001883a 	nop
81113f7c:	e037883a 	mov	sp,fp
81113f80:	dfc00117 	ldw	ra,4(sp)
81113f84:	df000017 	ldw	fp,0(sp)
81113f88:	dec00204 	addi	sp,sp,8
81113f8c:	f800283a 	ret

81113f90 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81113f90:	defffb04 	addi	sp,sp,-20
81113f94:	de00012e 	bgeu	sp,et,81113f9c <vPusType252conf+0xc>
81113f98:	003b68fa 	trap	3
81113f9c:	dfc00415 	stw	ra,16(sp)
81113fa0:	df000315 	stw	fp,12(sp)
81113fa4:	df000304 	addi	fp,sp,12
81113fa8:	e13ffe15 	stw	r4,-8(fp)
81113fac:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81113fb0:	e0bfff17 	ldw	r2,-4(fp)
81113fb4:	1080050b 	ldhu	r2,20(r2)
81113fb8:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81113fbc:	e0bfff17 	ldw	r2,-4(fp)
81113fc0:	1080038b 	ldhu	r2,14(r2)
81113fc4:	10bfffcc 	andi	r2,r2,65535
81113fc8:	10c000a0 	cmpeqi	r3,r2,2
81113fcc:	18000c1e 	bne	r3,zero,81114000 <vPusType252conf+0x70>
81113fd0:	10c00090 	cmplti	r3,r2,2
81113fd4:	1800611e 	bne	r3,zero,8111415c <vPusType252conf+0x1cc>
81113fd8:	10800188 	cmpgei	r2,r2,6
81113fdc:	10005f1e 	bne	r2,zero,8111415c <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81113fe0:	d0a06117 	ldw	r2,-32380(gp)
81113fe4:	100f883a 	mov	r7,r2
81113fe8:	01801384 	movi	r6,78
81113fec:	01400044 	movi	r5,1
81113ff0:	01204574 	movhi	r4,33045
81113ff4:	212eaa04 	addi	r4,r4,-17752
81113ff8:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
81113ffc:	00005f06 	br	8111417c <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114000:	e0bffd0b 	ldhu	r2,-12(fp)
81114004:	10809624 	muli	r2,r2,600
81114008:	10805504 	addi	r2,r2,340
8111400c:	e0fffe17 	ldw	r3,-8(fp)
81114010:	1885883a 	add	r2,r3,r2
81114014:	1009883a 	mov	r4,r2
81114018:	11078240 	call	81107824 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
8111401c:	e0bffd0b 	ldhu	r2,-12(fp)
81114020:	e0fffe17 	ldw	r3,-8(fp)
81114024:	10809624 	muli	r2,r2,600
81114028:	1885883a 	add	r2,r3,r2
8111402c:	10806504 	addi	r2,r2,404
81114030:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114034:	e0bffd0b 	ldhu	r2,-12(fp)
81114038:	10809624 	muli	r2,r2,600
8111403c:	10805504 	addi	r2,r2,340
81114040:	e0fffe17 	ldw	r3,-8(fp)
81114044:	1885883a 	add	r2,r3,r2
81114048:	1009883a 	mov	r4,r2
8111404c:	110777c0 	call	8110777c <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81114050:	e0bffd0b 	ldhu	r2,-12(fp)
81114054:	10809624 	muli	r2,r2,600
81114058:	10805504 	addi	r2,r2,340
8111405c:	e0fffe17 	ldw	r3,-8(fp)
81114060:	1885883a 	add	r2,r3,r2
81114064:	1009883a 	mov	r4,r2
81114068:	1107a0c0 	call	81107a0c <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
8111406c:	e0bffd0b 	ldhu	r2,-12(fp)
81114070:	e0ffff17 	ldw	r3,-4(fp)
81114074:	18c00b0b 	ldhu	r3,44(r3)
81114078:	1809883a 	mov	r4,r3
8111407c:	e0fffe17 	ldw	r3,-8(fp)
81114080:	10809624 	muli	r2,r2,600
81114084:	1885883a 	add	r2,r3,r2
81114088:	10805604 	addi	r2,r2,344
8111408c:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81114090:	e0bffd0b 	ldhu	r2,-12(fp)
81114094:	e0ffff17 	ldw	r3,-4(fp)
81114098:	18c0098b 	ldhu	r3,38(r3)
8111409c:	1809883a 	mov	r4,r3
811140a0:	e0fffe17 	ldw	r3,-8(fp)
811140a4:	10809624 	muli	r2,r2,600
811140a8:	1885883a 	add	r2,r3,r2
811140ac:	10805644 	addi	r2,r2,345
811140b0:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
811140b4:	e0bffd0b 	ldhu	r2,-12(fp)
811140b8:	10809624 	muli	r2,r2,600
811140bc:	10805504 	addi	r2,r2,340
811140c0:	e0fffe17 	ldw	r3,-8(fp)
811140c4:	1885883a 	add	r2,r3,r2
811140c8:	1009883a 	mov	r4,r2
811140cc:	11079340 	call	81107934 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811140d0:	e0bffd0b 	ldhu	r2,-12(fp)
811140d4:	10809624 	muli	r2,r2,600
811140d8:	10805504 	addi	r2,r2,340
811140dc:	e0fffe17 	ldw	r3,-8(fp)
811140e0:	1885883a 	add	r2,r3,r2
811140e4:	1009883a 	mov	r4,r2
811140e8:	11078240 	call	81107824 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811140ec:	e0bffd0b 	ldhu	r2,-12(fp)
811140f0:	e0fffe17 	ldw	r3,-8(fp)
811140f4:	10809624 	muli	r2,r2,600
811140f8:	1885883a 	add	r2,r3,r2
811140fc:	10806504 	addi	r2,r2,404
81114100:	00c00044 	movi	r3,1
81114104:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114108:	e0bffd0b 	ldhu	r2,-12(fp)
8111410c:	10809624 	muli	r2,r2,600
81114110:	10805504 	addi	r2,r2,340
81114114:	e0fffe17 	ldw	r3,-8(fp)
81114118:	1885883a 	add	r2,r3,r2
8111411c:	1009883a 	mov	r4,r2
81114120:	110777c0 	call	8110777c <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81114124:	d0e06117 	ldw	r3,-32380(gp)
81114128:	e0bfff17 	ldw	r2,-4(fp)
8111412c:	10800b0b 	ldhu	r2,44(r2)
81114130:	113fffcc 	andi	r4,r2,65535
81114134:	e0bfff17 	ldw	r2,-4(fp)
81114138:	1080098b 	ldhu	r2,38(r2)
8111413c:	10bfffcc 	andi	r2,r2,65535
81114140:	100f883a 	mov	r7,r2
81114144:	200d883a 	mov	r6,r4
81114148:	01604574 	movhi	r5,33045
8111414c:	296ebe04 	addi	r5,r5,-17672
81114150:	1809883a 	mov	r4,r3
81114154:	111f5fc0 	call	8111f5fc <fprintf>
			#endif

			break;
81114158:	00000806 	br	8111417c <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
8111415c:	d0a06117 	ldw	r2,-32380(gp)
81114160:	100f883a 	mov	r7,r2
81114164:	01800b04 	movi	r6,44
81114168:	01400044 	movi	r5,1
8111416c:	01204574 	movhi	r4,33045
81114170:	212e8c04 	addi	r4,r4,-17872
81114174:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
81114178:	0001883a 	nop
	}
}
8111417c:	0001883a 	nop
81114180:	e037883a 	mov	sp,fp
81114184:	dfc00117 	ldw	ra,4(sp)
81114188:	df000017 	ldw	fp,0(sp)
8111418c:	dec00204 	addi	sp,sp,8
81114190:	f800283a 	ret

81114194 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81114194:	defffc04 	addi	sp,sp,-16
81114198:	de00012e 	bgeu	sp,et,811141a0 <vPusMebInTaskRunningMode+0xc>
8111419c:	003b68fa 	trap	3
811141a0:	dfc00315 	stw	ra,12(sp)
811141a4:	df000215 	stw	fp,8(sp)
811141a8:	df000204 	addi	fp,sp,8
811141ac:	e13ffe15 	stw	r4,-8(fp)
811141b0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
811141b4:	e0bfff17 	ldw	r2,-4(fp)
811141b8:	1080030b 	ldhu	r2,12(r2)
811141bc:	10bfffcc 	andi	r2,r2,65535
811141c0:	10c03ee0 	cmpeqi	r3,r2,251
811141c4:	1800081e 	bne	r3,zero,811141e8 <vPusMebInTaskRunningMode+0x54>
811141c8:	10c03f20 	cmpeqi	r3,r2,252
811141cc:	18000a1e 	bne	r3,zero,811141f8 <vPusMebInTaskRunningMode+0x64>
811141d0:	10803ea0 	cmpeqi	r2,r2,250
811141d4:	10000c26 	beq	r2,zero,81114208 <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
811141d8:	e17fff17 	ldw	r5,-4(fp)
811141dc:	e13ffe17 	ldw	r4,-8(fp)
811141e0:	11142400 	call	81114240 <vPusType250run>
			break;
811141e4:	00001006 	br	81114228 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
811141e8:	e17fff17 	ldw	r5,-4(fp)
811141ec:	e13ffe17 	ldw	r4,-8(fp)
811141f0:	11142cc0 	call	811142cc <vPusType251run>
			break;
811141f4:	00000c06 	br	81114228 <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
811141f8:	e17fff17 	ldw	r5,-4(fp)
811141fc:	e13ffe17 	ldw	r4,-8(fp)
81114200:	11143e00 	call	811143e0 <vPusType252run>
			break;
81114204:	00000806 	br	81114228 <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81114208:	d0a06117 	ldw	r2,-32380(gp)
8111420c:	100f883a 	mov	r7,r2
81114210:	01800cc4 	movi	r6,51
81114214:	01400044 	movi	r5,1
81114218:	01204574 	movhi	r4,33045
8111421c:	212ece04 	addi	r4,r4,-17608
81114220:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
81114224:	0001883a 	nop
	}
}
81114228:	0001883a 	nop
8111422c:	e037883a 	mov	sp,fp
81114230:	dfc00117 	ldw	ra,4(sp)
81114234:	df000017 	ldw	fp,0(sp)
81114238:	dec00204 	addi	sp,sp,8
8111423c:	f800283a 	ret

81114240 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81114240:	defffc04 	addi	sp,sp,-16
81114244:	de00012e 	bgeu	sp,et,8111424c <vPusType250run+0xc>
81114248:	003b68fa 	trap	3
8111424c:	dfc00315 	stw	ra,12(sp)
81114250:	df000215 	stw	fp,8(sp)
81114254:	df000204 	addi	fp,sp,8
81114258:	e13ffe15 	stw	r4,-8(fp)
8111425c:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81114260:	e0bfff17 	ldw	r2,-4(fp)
81114264:	1080038b 	ldhu	r2,14(r2)
81114268:	10bfffcc 	andi	r2,r2,65535
8111426c:	10c00f20 	cmpeqi	r3,r2,60
81114270:	1800031e 	bne	r3,zero,81114280 <vPusType250run+0x40>
81114274:	10800fa0 	cmpeqi	r2,r2,62
81114278:	10000d1e 	bne	r2,zero,811142b0 <vPusType250run+0x70>
8111427c:	00000406 	br	81114290 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81114280:	e0bffe17 	ldw	r2,-8(fp)
81114284:	00c00044 	movi	r3,1
81114288:	10c00115 	stw	r3,4(r2)
			break;
8111428c:	00000906 	br	811142b4 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81114290:	d0a06117 	ldw	r2,-32380(gp)
81114294:	100f883a 	mov	r7,r2
81114298:	01800c84 	movi	r6,50
8111429c:	01400044 	movi	r5,1
811142a0:	01204574 	movhi	r4,33045
811142a4:	212edb04 	addi	r4,r4,-17556
811142a8:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
811142ac:	00000106 	br	811142b4 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
811142b0:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
811142b4:	0001883a 	nop
811142b8:	e037883a 	mov	sp,fp
811142bc:	dfc00117 	ldw	ra,4(sp)
811142c0:	df000017 	ldw	fp,0(sp)
811142c4:	dec00204 	addi	sp,sp,8
811142c8:	f800283a 	ret

811142cc <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811142cc:	defffb04 	addi	sp,sp,-20
811142d0:	de00012e 	bgeu	sp,et,811142d8 <vPusType251run+0xc>
811142d4:	003b68fa 	trap	3
811142d8:	dfc00415 	stw	ra,16(sp)
811142dc:	df000315 	stw	fp,12(sp)
811142e0:	df000304 	addi	fp,sp,12
811142e4:	e13ffe15 	stw	r4,-8(fp)
811142e8:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
811142ec:	e0bfff17 	ldw	r2,-4(fp)
811142f0:	1080050b 	ldhu	r2,20(r2)
811142f4:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
811142f8:	e0bfff17 	ldw	r2,-4(fp)
811142fc:	1080038b 	ldhu	r2,14(r2)
81114300:	10bfffcc 	andi	r2,r2,65535
81114304:	10c000a0 	cmpeqi	r3,r2,2
81114308:	18000f1e 	bne	r3,zero,81114348 <vPusType251run+0x7c>
8111430c:	10c00160 	cmpeqi	r3,r2,5
81114310:	1800181e 	bne	r3,zero,81114374 <vPusType251run+0xa8>
81114314:	10800060 	cmpeqi	r2,r2,1
81114318:	10002126 	beq	r2,zero,811143a0 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
8111431c:	e0bffd0b 	ldhu	r2,-12(fp)
81114320:	10800444 	addi	r2,r2,17
81114324:	10803fcc 	andi	r2,r2,255
81114328:	e0fffd0b 	ldhu	r3,-12(fp)
8111432c:	18c03fcc 	andi	r3,r3,255
81114330:	180f883a 	mov	r7,r3
81114334:	000d883a 	mov	r6,zero
81114338:	01400044 	movi	r5,1
8111433c:	1009883a 	mov	r4,r2
81114340:	11148780 	call	81114878 <vSendCmdQToNFeeCTRL_GEN>
			break;
81114344:	00002006 	br	811143c8 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81114348:	e0bffd0b 	ldhu	r2,-12(fp)
8111434c:	10800444 	addi	r2,r2,17
81114350:	10803fcc 	andi	r2,r2,255
81114354:	e0fffd0b 	ldhu	r3,-12(fp)
81114358:	18c03fcc 	andi	r3,r3,255
8111435c:	180f883a 	mov	r7,r3
81114360:	000d883a 	mov	r6,zero
81114364:	01400104 	movi	r5,4
81114368:	1009883a 	mov	r4,r2
8111436c:	11148780 	call	81114878 <vSendCmdQToNFeeCTRL_GEN>
			break;
81114370:	00001506 	br	811143c8 <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81114374:	e0bffd0b 	ldhu	r2,-12(fp)
81114378:	10800444 	addi	r2,r2,17
8111437c:	10803fcc 	andi	r2,r2,255
81114380:	e0fffd0b 	ldhu	r3,-12(fp)
81114384:	18c03fcc 	andi	r3,r3,255
81114388:	180f883a 	mov	r7,r3
8111438c:	000d883a 	mov	r6,zero
81114390:	01400204 	movi	r5,8
81114394:	1009883a 	mov	r4,r2
81114398:	11148780 	call	81114878 <vSendCmdQToNFeeCTRL_GEN>
			break;
8111439c:	00000a06 	br	811143c8 <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
811143a0:	d0e06117 	ldw	r3,-32380(gp)
811143a4:	e0bfff17 	ldw	r2,-4(fp)
811143a8:	1080038b 	ldhu	r2,14(r2)
811143ac:	10bfffcc 	andi	r2,r2,65535
811143b0:	100d883a 	mov	r6,r2
811143b4:	01604574 	movhi	r5,33045
811143b8:	296ee804 	addi	r5,r5,-17504
811143bc:	1809883a 	mov	r4,r3
811143c0:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
			break;
811143c4:	0001883a 	nop
	}
}
811143c8:	0001883a 	nop
811143cc:	e037883a 	mov	sp,fp
811143d0:	dfc00117 	ldw	ra,4(sp)
811143d4:	df000017 	ldw	fp,0(sp)
811143d8:	dec00204 	addi	sp,sp,8
811143dc:	f800283a 	ret

811143e0 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811143e0:	defffb04 	addi	sp,sp,-20
811143e4:	de00012e 	bgeu	sp,et,811143ec <vPusType252run+0xc>
811143e8:	003b68fa 	trap	3
811143ec:	dfc00415 	stw	ra,16(sp)
811143f0:	df000315 	stw	fp,12(sp)
811143f4:	df000304 	addi	fp,sp,12
811143f8:	e13ffe15 	stw	r4,-8(fp)
811143fc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81114400:	e0bfff17 	ldw	r2,-4(fp)
81114404:	1080050b 	ldhu	r2,20(r2)
81114408:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
8111440c:	e0bfff17 	ldw	r2,-4(fp)
81114410:	1080038b 	ldhu	r2,14(r2)
81114414:	10bfffcc 	andi	r2,r2,65535
81114418:	10c000e0 	cmpeqi	r3,r2,3
8111441c:	18000a1e 	bne	r3,zero,81114448 <vPusType252run+0x68>
81114420:	10c00108 	cmpgei	r3,r2,4
81114424:	1800031e 	bne	r3,zero,81114434 <vPusType252run+0x54>
81114428:	108000a0 	cmpeqi	r2,r2,2
8111442c:	1000581e 	bne	r2,zero,81114590 <vPusType252run+0x1b0>
81114430:	0000be06 	br	8111472c <vPusType252run+0x34c>
81114434:	10c00120 	cmpeqi	r3,r2,4
81114438:	18002c1e 	bne	r3,zero,811144ec <vPusType252run+0x10c>
8111443c:	10800160 	cmpeqi	r2,r2,5
81114440:	1000c21e 	bne	r2,zero,8111474c <vPusType252run+0x36c>
81114444:	0000b906 	br	8111472c <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81114448:	e0bffd0b 	ldhu	r2,-12(fp)
8111444c:	10809624 	muli	r2,r2,600
81114450:	10809b04 	addi	r2,r2,620
81114454:	e0fffe17 	ldw	r3,-8(fp)
81114458:	1885883a 	add	r2,r3,r2
8111445c:	1009883a 	mov	r4,r2
81114460:	1109da80 	call	81109da8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81114464:	e0bffd0b 	ldhu	r2,-12(fp)
81114468:	e0fffe17 	ldw	r3,-8(fp)
8111446c:	10809624 	muli	r2,r2,600
81114470:	1885883a 	add	r2,r3,r2
81114474:	10809d04 	addi	r2,r2,628
81114478:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
8111447c:	e0bffd0b 	ldhu	r2,-12(fp)
81114480:	e0fffe17 	ldw	r3,-8(fp)
81114484:	10809624 	muli	r2,r2,600
81114488:	1885883a 	add	r2,r3,r2
8111448c:	10809c04 	addi	r2,r2,624
81114490:	00c00044 	movi	r3,1
81114494:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81114498:	e0bffd0b 	ldhu	r2,-12(fp)
8111449c:	e0fffe17 	ldw	r3,-8(fp)
811144a0:	10809624 	muli	r2,r2,600
811144a4:	1885883a 	add	r2,r3,r2
811144a8:	10809e04 	addi	r2,r2,632
811144ac:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811144b0:	e0bffd0b 	ldhu	r2,-12(fp)
811144b4:	10809624 	muli	r2,r2,600
811144b8:	10809b04 	addi	r2,r2,620
811144bc:	e0fffe17 	ldw	r3,-8(fp)
811144c0:	1885883a 	add	r2,r3,r2
811144c4:	1009883a 	mov	r4,r2
811144c8:	1109c740 	call	81109c74 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
811144cc:	d0a06117 	ldw	r2,-32380(gp)
811144d0:	e0fffd0b 	ldhu	r3,-12(fp)
811144d4:	180d883a 	mov	r6,r3
811144d8:	01604574 	movhi	r5,33045
811144dc:	296ef604 	addi	r5,r5,-17448
811144e0:	1009883a 	mov	r4,r2
811144e4:	111f5fc0 	call	8111f5fc <fprintf>
			#endif

			break;
811144e8:	00009906 	br	81114750 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
811144ec:	e0bffd0b 	ldhu	r2,-12(fp)
811144f0:	10809624 	muli	r2,r2,600
811144f4:	10809b04 	addi	r2,r2,620
811144f8:	e0fffe17 	ldw	r3,-8(fp)
811144fc:	1885883a 	add	r2,r3,r2
81114500:	1009883a 	mov	r4,r2
81114504:	1109da80 	call	81109da8 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81114508:	e0bffd0b 	ldhu	r2,-12(fp)
8111450c:	e0fffe17 	ldw	r3,-8(fp)
81114510:	10809624 	muli	r2,r2,600
81114514:	1885883a 	add	r2,r3,r2
81114518:	10809d04 	addi	r2,r2,628
8111451c:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81114520:	e0bffd0b 	ldhu	r2,-12(fp)
81114524:	e0fffe17 	ldw	r3,-8(fp)
81114528:	10809624 	muli	r2,r2,600
8111452c:	1885883a 	add	r2,r3,r2
81114530:	10809c04 	addi	r2,r2,624
81114534:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
81114538:	e0bffd0b 	ldhu	r2,-12(fp)
8111453c:	e0fffe17 	ldw	r3,-8(fp)
81114540:	10809624 	muli	r2,r2,600
81114544:	1885883a 	add	r2,r3,r2
81114548:	10809e04 	addi	r2,r2,632
8111454c:	00c00044 	movi	r3,1
81114550:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81114554:	e0bffd0b 	ldhu	r2,-12(fp)
81114558:	10809624 	muli	r2,r2,600
8111455c:	10809b04 	addi	r2,r2,620
81114560:	e0fffe17 	ldw	r3,-8(fp)
81114564:	1885883a 	add	r2,r3,r2
81114568:	1009883a 	mov	r4,r2
8111456c:	1109c740 	call	81109c74 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81114570:	d0a06117 	ldw	r2,-32380(gp)
81114574:	e0fffd0b 	ldhu	r3,-12(fp)
81114578:	180d883a 	mov	r6,r3
8111457c:	01604574 	movhi	r5,33045
81114580:	296eff04 	addi	r5,r5,-17412
81114584:	1009883a 	mov	r4,r2
81114588:	111f5fc0 	call	8111f5fc <fprintf>
			#endif

			break;
8111458c:	00007006 	br	81114750 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
81114590:	e0bffd0b 	ldhu	r2,-12(fp)
81114594:	e0fffe17 	ldw	r3,-8(fp)
81114598:	10809624 	muli	r2,r2,600
8111459c:	1885883a 	add	r2,r3,r2
811145a0:	10803e04 	addi	r2,r2,248
811145a4:	10800017 	ldw	r2,0(r2)
811145a8:	10800058 	cmpnei	r2,r2,1
811145ac:	10004a1e 	bne	r2,zero,811146d8 <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811145b0:	e0bffd0b 	ldhu	r2,-12(fp)
811145b4:	10809624 	muli	r2,r2,600
811145b8:	10805504 	addi	r2,r2,340
811145bc:	e0fffe17 	ldw	r3,-8(fp)
811145c0:	1885883a 	add	r2,r3,r2
811145c4:	1009883a 	mov	r4,r2
811145c8:	11078240 	call	81107824 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
811145cc:	e0bffd0b 	ldhu	r2,-12(fp)
811145d0:	e0fffe17 	ldw	r3,-8(fp)
811145d4:	10809624 	muli	r2,r2,600
811145d8:	1885883a 	add	r2,r3,r2
811145dc:	10806504 	addi	r2,r2,404
811145e0:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811145e4:	e0bffd0b 	ldhu	r2,-12(fp)
811145e8:	10809624 	muli	r2,r2,600
811145ec:	10805504 	addi	r2,r2,340
811145f0:	e0fffe17 	ldw	r3,-8(fp)
811145f4:	1885883a 	add	r2,r3,r2
811145f8:	1009883a 	mov	r4,r2
811145fc:	110777c0 	call	8110777c <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81114600:	e0bffd0b 	ldhu	r2,-12(fp)
81114604:	10809624 	muli	r2,r2,600
81114608:	10805504 	addi	r2,r2,340
8111460c:	e0fffe17 	ldw	r3,-8(fp)
81114610:	1885883a 	add	r2,r3,r2
81114614:	1009883a 	mov	r4,r2
81114618:	1107a0c0 	call	81107a0c <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
8111461c:	e0bffd0b 	ldhu	r2,-12(fp)
81114620:	e0ffff17 	ldw	r3,-4(fp)
81114624:	18c00b0b 	ldhu	r3,44(r3)
81114628:	1809883a 	mov	r4,r3
8111462c:	e0fffe17 	ldw	r3,-8(fp)
81114630:	10809624 	muli	r2,r2,600
81114634:	1885883a 	add	r2,r3,r2
81114638:	10805604 	addi	r2,r2,344
8111463c:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81114640:	e0bffd0b 	ldhu	r2,-12(fp)
81114644:	e0ffff17 	ldw	r3,-4(fp)
81114648:	18c0098b 	ldhu	r3,38(r3)
8111464c:	1809883a 	mov	r4,r3
81114650:	e0fffe17 	ldw	r3,-8(fp)
81114654:	10809624 	muli	r2,r2,600
81114658:	1885883a 	add	r2,r3,r2
8111465c:	10805644 	addi	r2,r2,345
81114660:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81114664:	e0bffd0b 	ldhu	r2,-12(fp)
81114668:	10809624 	muli	r2,r2,600
8111466c:	10805504 	addi	r2,r2,340
81114670:	e0fffe17 	ldw	r3,-8(fp)
81114674:	1885883a 	add	r2,r3,r2
81114678:	1009883a 	mov	r4,r2
8111467c:	11079340 	call	81107934 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81114680:	e0bffd0b 	ldhu	r2,-12(fp)
81114684:	10809624 	muli	r2,r2,600
81114688:	10805504 	addi	r2,r2,340
8111468c:	e0fffe17 	ldw	r3,-8(fp)
81114690:	1885883a 	add	r2,r3,r2
81114694:	1009883a 	mov	r4,r2
81114698:	11078240 	call	81107824 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
8111469c:	e0bffd0b 	ldhu	r2,-12(fp)
811146a0:	e0fffe17 	ldw	r3,-8(fp)
811146a4:	10809624 	muli	r2,r2,600
811146a8:	1885883a 	add	r2,r3,r2
811146ac:	10806504 	addi	r2,r2,404
811146b0:	00c00044 	movi	r3,1
811146b4:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811146b8:	e0bffd0b 	ldhu	r2,-12(fp)
811146bc:	10809624 	muli	r2,r2,600
811146c0:	10805504 	addi	r2,r2,340
811146c4:	e0fffe17 	ldw	r3,-8(fp)
811146c8:	1885883a 	add	r2,r3,r2
811146cc:	1009883a 	mov	r4,r2
811146d0:	110777c0 	call	8110777c <bRmapSetIrqControl>
811146d4:	00000706 	br	811146f4 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
811146d8:	d0a06117 	ldw	r2,-32380(gp)
811146dc:	e0fffd0b 	ldhu	r3,-12(fp)
811146e0:	180d883a 	mov	r6,r3
811146e4:	01604574 	movhi	r5,33045
811146e8:	296f0804 	addi	r5,r5,-17376
811146ec:	1009883a 	mov	r4,r2
811146f0:	111f5fc0 	call	8111f5fc <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
811146f4:	d0e06117 	ldw	r3,-32380(gp)
811146f8:	e0bfff17 	ldw	r2,-4(fp)
811146fc:	10800b0b 	ldhu	r2,44(r2)
81114700:	113fffcc 	andi	r4,r2,65535
81114704:	e0bfff17 	ldw	r2,-4(fp)
81114708:	1080098b 	ldhu	r2,38(r2)
8111470c:	10bfffcc 	andi	r2,r2,65535
81114710:	100f883a 	mov	r7,r2
81114714:	200d883a 	mov	r6,r4
81114718:	01604574 	movhi	r5,33045
8111471c:	296ebe04 	addi	r5,r5,-17672
81114720:	1809883a 	mov	r4,r3
81114724:	111f5fc0 	call	8111f5fc <fprintf>
			#endif
			break;
81114728:	00000906 	br	81114750 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
8111472c:	d0a06117 	ldw	r2,-32380(gp)
81114730:	100f883a 	mov	r7,r2
81114734:	01800c84 	movi	r6,50
81114738:	01400044 	movi	r5,1
8111473c:	01204574 	movhi	r4,33045
81114740:	212edb04 	addi	r4,r4,-17556
81114744:	111fc980 	call	8111fc98 <fwrite>
			#endif
			break;
81114748:	00000106 	br	81114750 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
8111474c:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81114750:	0001883a 	nop
81114754:	e037883a 	mov	sp,fp
81114758:	dfc00117 	ldw	ra,4(sp)
8111475c:	df000017 	ldw	fp,0(sp)
81114760:	dec00204 	addi	sp,sp,8
81114764:	f800283a 	ret

81114768 <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81114768:	defff904 	addi	sp,sp,-28
8111476c:	de00012e 	bgeu	sp,et,81114774 <vSendCmdQToNFeeCTRL+0xc>
81114770:	003b68fa 	trap	3
81114774:	dfc00615 	stw	ra,24(sp)
81114778:	df000515 	stw	fp,20(sp)
8111477c:	df000504 	addi	fp,sp,20
81114780:	2807883a 	mov	r3,r5
81114784:	3005883a 	mov	r2,r6
81114788:	e13ffd05 	stb	r4,-12(fp)
8111478c:	e0fffe05 	stb	r3,-8(fp)
81114790:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81114794:	00800404 	movi	r2,16
81114798:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8111479c:	e0bffd03 	ldbu	r2,-12(fp)
811147a0:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811147a4:	e0bffe03 	ldbu	r2,-8(fp)
811147a8:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811147ac:	e0bfff03 	ldbu	r2,-4(fp)
811147b0:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811147b4:	d0a06f17 	ldw	r2,-32324(gp)
811147b8:	e0fffc17 	ldw	r3,-16(fp)
811147bc:	180b883a 	mov	r5,r3
811147c0:	1009883a 	mov	r4,r2
811147c4:	113c0280 	call	8113c028 <OSQPost>
811147c8:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811147cc:	e0bffb03 	ldbu	r2,-20(fp)
811147d0:	10000126 	beq	r2,zero,811147d8 <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
811147d4:	111b6f00 	call	8111b6f0 <vFailSendMsgFeeCTRL>
	}
}
811147d8:	0001883a 	nop
811147dc:	e037883a 	mov	sp,fp
811147e0:	dfc00117 	ldw	ra,4(sp)
811147e4:	df000017 	ldw	fp,0(sp)
811147e8:	dec00204 	addi	sp,sp,8
811147ec:	f800283a 	ret

811147f0 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811147f0:	defff904 	addi	sp,sp,-28
811147f4:	de00012e 	bgeu	sp,et,811147fc <vSendCmdQToNFeeCTRL_PRIO+0xc>
811147f8:	003b68fa 	trap	3
811147fc:	dfc00615 	stw	ra,24(sp)
81114800:	df000515 	stw	fp,20(sp)
81114804:	df000504 	addi	fp,sp,20
81114808:	2807883a 	mov	r3,r5
8111480c:	3005883a 	mov	r2,r6
81114810:	e13ffd05 	stb	r4,-12(fp)
81114814:	e0fffe05 	stb	r3,-8(fp)
81114818:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8111481c:	00800404 	movi	r2,16
81114820:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81114824:	e0bffd03 	ldbu	r2,-12(fp)
81114828:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111482c:	e0bffe03 	ldbu	r2,-8(fp)
81114830:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81114834:	e0bfff03 	ldbu	r2,-4(fp)
81114838:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8111483c:	d0a06f17 	ldw	r2,-32324(gp)
81114840:	e0fffc17 	ldw	r3,-16(fp)
81114844:	180b883a 	mov	r5,r3
81114848:	1009883a 	mov	r4,r2
8111484c:	113c1980 	call	8113c198 <OSQPostFront>
81114850:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81114854:	e0bffb03 	ldbu	r2,-20(fp)
81114858:	10000126 	beq	r2,zero,81114860 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
8111485c:	111b6f00 	call	8111b6f0 <vFailSendMsgFeeCTRL>
	}
}
81114860:	0001883a 	nop
81114864:	e037883a 	mov	sp,fp
81114868:	dfc00117 	ldw	ra,4(sp)
8111486c:	df000017 	ldw	fp,0(sp)
81114870:	dec00204 	addi	sp,sp,8
81114874:	f800283a 	ret

81114878 <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81114878:	defff804 	addi	sp,sp,-32
8111487c:	de00012e 	bgeu	sp,et,81114884 <vSendCmdQToNFeeCTRL_GEN+0xc>
81114880:	003b68fa 	trap	3
81114884:	dfc00715 	stw	ra,28(sp)
81114888:	df000615 	stw	fp,24(sp)
8111488c:	df000604 	addi	fp,sp,24
81114890:	2011883a 	mov	r8,r4
81114894:	2809883a 	mov	r4,r5
81114898:	3007883a 	mov	r3,r6
8111489c:	3805883a 	mov	r2,r7
811148a0:	e23ffc05 	stb	r8,-16(fp)
811148a4:	e13ffd05 	stb	r4,-12(fp)
811148a8:	e0fffe05 	stb	r3,-8(fp)
811148ac:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
811148b0:	e0bffc03 	ldbu	r2,-16(fp)
811148b4:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811148b8:	e0bffd03 	ldbu	r2,-12(fp)
811148bc:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811148c0:	e0bffe03 	ldbu	r2,-8(fp)
811148c4:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811148c8:	e0bfff03 	ldbu	r2,-4(fp)
811148cc:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811148d0:	d0a06f17 	ldw	r2,-32324(gp)
811148d4:	e0fffb17 	ldw	r3,-20(fp)
811148d8:	180b883a 	mov	r5,r3
811148dc:	1009883a 	mov	r4,r2
811148e0:	113c0280 	call	8113c028 <OSQPost>
811148e4:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811148e8:	e0bffa03 	ldbu	r2,-24(fp)
811148ec:	10000126 	beq	r2,zero,811148f4 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
811148f0:	111b6f00 	call	8111b6f0 <vFailSendMsgFeeCTRL>
	}
}
811148f4:	0001883a 	nop
811148f8:	e037883a 	mov	sp,fp
811148fc:	dfc00117 	ldw	ra,4(sp)
81114900:	df000017 	ldw	fp,0(sp)
81114904:	dec00204 	addi	sp,sp,8
81114908:	f800283a 	ret

8111490c <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111490c:	defff904 	addi	sp,sp,-28
81114910:	de00012e 	bgeu	sp,et,81114918 <vSendCmdQToDataCTRL+0xc>
81114914:	003b68fa 	trap	3
81114918:	dfc00615 	stw	ra,24(sp)
8111491c:	df000515 	stw	fp,20(sp)
81114920:	df000504 	addi	fp,sp,20
81114924:	2807883a 	mov	r3,r5
81114928:	3005883a 	mov	r2,r6
8111492c:	e13ffd05 	stb	r4,-12(fp)
81114930:	e0fffe05 	stb	r3,-8(fp)
81114934:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
81114938:	00800804 	movi	r2,32
8111493c:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81114940:	e0bffd03 	ldbu	r2,-12(fp)
81114944:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81114948:	e0bffe03 	ldbu	r2,-8(fp)
8111494c:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81114950:	e0bfff03 	ldbu	r2,-4(fp)
81114954:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
81114958:	d0a05e17 	ldw	r2,-32392(gp)
8111495c:	e0fffc17 	ldw	r3,-16(fp)
81114960:	180b883a 	mov	r5,r3
81114964:	1009883a 	mov	r4,r2
81114968:	113c0280 	call	8113c028 <OSQPost>
8111496c:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81114970:	e0bffb03 	ldbu	r2,-20(fp)
81114974:	10000126 	beq	r2,zero,8111497c <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
81114978:	111b73c0 	call	8111b73c <vFailSendMsgDataCTRL>
	}
}
8111497c:	0001883a 	nop
81114980:	e037883a 	mov	sp,fp
81114984:	dfc00117 	ldw	ra,4(sp)
81114988:	df000017 	ldw	fp,0(sp)
8111498c:	dec00204 	addi	sp,sp,8
81114990:	f800283a 	ret

81114994 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81114994:	defff904 	addi	sp,sp,-28
81114998:	de00012e 	bgeu	sp,et,811149a0 <vSendCmdQToDataCTRL_PRIO+0xc>
8111499c:	003b68fa 	trap	3
811149a0:	dfc00615 	stw	ra,24(sp)
811149a4:	df000515 	stw	fp,20(sp)
811149a8:	df000504 	addi	fp,sp,20
811149ac:	2807883a 	mov	r3,r5
811149b0:	3005883a 	mov	r2,r6
811149b4:	e13ffd05 	stb	r4,-12(fp)
811149b8:	e0fffe05 	stb	r3,-8(fp)
811149bc:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811149c0:	00800404 	movi	r2,16
811149c4:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811149c8:	e0bffd03 	ldbu	r2,-12(fp)
811149cc:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811149d0:	e0bffe03 	ldbu	r2,-8(fp)
811149d4:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811149d8:	e0bfff03 	ldbu	r2,-4(fp)
811149dc:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811149e0:	d0a05e17 	ldw	r2,-32392(gp)
811149e4:	e0fffc17 	ldw	r3,-16(fp)
811149e8:	180b883a 	mov	r5,r3
811149ec:	1009883a 	mov	r4,r2
811149f0:	113c1980 	call	8113c198 <OSQPostFront>
811149f4:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811149f8:	e0bffb03 	ldbu	r2,-20(fp)
811149fc:	10000126 	beq	r2,zero,81114a04 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81114a00:	111b6f00 	call	8111b6f0 <vFailSendMsgFeeCTRL>
	}
}
81114a04:	0001883a 	nop
81114a08:	e037883a 	mov	sp,fp
81114a0c:	dfc00117 	ldw	ra,4(sp)
81114a10:	df000017 	ldw	fp,0(sp)
81114a14:	dec00204 	addi	sp,sp,8
81114a18:	f800283a 	ret

81114a1c <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81114a1c:	defffc04 	addi	sp,sp,-16
81114a20:	de00012e 	bgeu	sp,et,81114a28 <vMebInit+0xc>
81114a24:	003b68fa 	trap	3
81114a28:	dfc00315 	stw	ra,12(sp)
81114a2c:	df000215 	stw	fp,8(sp)
81114a30:	df000204 	addi	fp,sp,8
81114a34:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
81114a38:	e0bfff17 	ldw	r2,-4(fp)
81114a3c:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81114a40:	e0bfff17 	ldw	r2,-4(fp)
81114a44:	00c00044 	movi	r3,1
81114a48:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81114a4c:	d0a06817 	ldw	r2,-32352(gp)
81114a50:	1009883a 	mov	r4,r2
81114a54:	113bb600 	call	8113bb60 <OSQFlush>
81114a58:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81114a5c:	e0bffe03 	ldbu	r2,-8(fp)
81114a60:	10000126 	beq	r2,zero,81114a68 <vMebInit+0x4c>
		vFailFlushMEBQueue();
81114a64:	111b8200 	call	8111b820 <vFailFlushMEBQueue>
	}
}
81114a68:	0001883a 	nop
81114a6c:	e037883a 	mov	sp,fp
81114a70:	dfc00117 	ldw	ra,4(sp)
81114a74:	df000017 	ldw	fp,0(sp)
81114a78:	dec00204 	addi	sp,sp,8
81114a7c:	f800283a 	ret

81114a80 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81114a80:	defffe04 	addi	sp,sp,-8
81114a84:	de00012e 	bgeu	sp,et,81114a8c <vSwapMemmory+0xc>
81114a88:	003b68fa 	trap	3
81114a8c:	df000115 	stw	fp,4(sp)
81114a90:	df000104 	addi	fp,sp,4
81114a94:	e13fff15 	stw	r4,-4(fp)

	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81114a98:	e0bfff17 	ldw	r2,-4(fp)
81114a9c:	10800203 	ldbu	r2,8(r2)
81114aa0:	10803fcc 	andi	r2,r2,255
81114aa4:	10c00044 	addi	r3,r2,1
81114aa8:	00a00034 	movhi	r2,32768
81114aac:	10800044 	addi	r2,r2,1
81114ab0:	1884703a 	and	r2,r3,r2
81114ab4:	1000040e 	bge	r2,zero,81114ac8 <vSwapMemmory+0x48>
81114ab8:	10bfffc4 	addi	r2,r2,-1
81114abc:	00ffff84 	movi	r3,-2
81114ac0:	10c4b03a 	or	r2,r2,r3
81114ac4:	10800044 	addi	r2,r2,1
81114ac8:	1007883a 	mov	r3,r2
81114acc:	e0bfff17 	ldw	r2,-4(fp)
81114ad0:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
81114ad4:	e0bfff17 	ldw	r2,-4(fp)
81114ad8:	10800243 	ldbu	r2,9(r2)
81114adc:	10803fcc 	andi	r2,r2,255
81114ae0:	10c00044 	addi	r3,r2,1
81114ae4:	00a00034 	movhi	r2,32768
81114ae8:	10800044 	addi	r2,r2,1
81114aec:	1884703a 	and	r2,r3,r2
81114af0:	1000040e 	bge	r2,zero,81114b04 <vSwapMemmory+0x84>
81114af4:	10bfffc4 	addi	r2,r2,-1
81114af8:	00ffff84 	movi	r3,-2
81114afc:	10c4b03a 	or	r2,r2,r3
81114b00:	10800044 	addi	r2,r2,1
81114b04:	1007883a 	mov	r3,r2
81114b08:	e0bfff17 	ldw	r2,-4(fp)
81114b0c:	10c00245 	stb	r3,9(r2)

}
81114b10:	0001883a 	nop
81114b14:	e037883a 	mov	sp,fp
81114b18:	df000017 	ldw	fp,0(sp)
81114b1c:	dec00104 	addi	sp,sp,4
81114b20:	f800283a 	ret

81114b24 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
81114b24:	defffc04 	addi	sp,sp,-16
81114b28:	de00012e 	bgeu	sp,et,81114b30 <vReleaseSyncMessages+0xc>
81114b2c:	003b68fa 	trap	3
81114b30:	dfc00315 	stw	ra,12(sp)
81114b34:	df000215 	stw	fp,8(sp)
81114b38:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
81114b3c:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
81114b40:	00bff844 	movi	r2,-31
81114b44:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81114b48:	e03ffe05 	stb	zero,-8(fp)
81114b4c:	00001606 	br	81114ba8 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
81114b50:	e0bffe03 	ldbu	r2,-8(fp)
81114b54:	10800444 	addi	r2,r2,17
81114b58:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
81114b5c:	e0bffe03 	ldbu	r2,-8(fp)
81114b60:	1085883a 	add	r2,r2,r2
81114b64:	1087883a 	add	r3,r2,r2
81114b68:	d0a05b04 	addi	r2,gp,-32404
81114b6c:	1885883a 	add	r2,r3,r2
81114b70:	10800017 	ldw	r2,0(r2)
81114b74:	e0ffff17 	ldw	r3,-4(fp)
81114b78:	180b883a 	mov	r5,r3
81114b7c:	1009883a 	mov	r4,r2
81114b80:	113c0280 	call	8113c028 <OSQPost>
81114b84:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81114b88:	e0bffe43 	ldbu	r2,-7(fp)
81114b8c:	10000326 	beq	r2,zero,81114b9c <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
81114b90:	e0bffe03 	ldbu	r2,-8(fp)
81114b94:	1009883a 	mov	r4,r2
81114b98:	111b5fc0 	call	8111b5fc <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81114b9c:	e0bffe03 	ldbu	r2,-8(fp)
81114ba0:	10800044 	addi	r2,r2,1
81114ba4:	e0bffe05 	stb	r2,-8(fp)
81114ba8:	e0bffe03 	ldbu	r2,-8(fp)
81114bac:	103fe826 	beq	r2,zero,81114b50 <__reset+0xfb0f4b50>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
81114bb0:	0001883a 	nop
81114bb4:	e037883a 	mov	sp,fp
81114bb8:	dfc00117 	ldw	ra,4(sp)
81114bbc:	df000017 	ldw	fp,0(sp)
81114bc0:	dec00204 	addi	sp,sp,8
81114bc4:	f800283a 	ret

81114bc8 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
81114bc8:	defff804 	addi	sp,sp,-32
81114bcc:	de00012e 	bgeu	sp,et,81114bd4 <vStackMonitor+0xc>
81114bd0:	003b68fa 	trap	3
81114bd4:	dfc00715 	stw	ra,28(sp)
81114bd8:	df000615 	stw	fp,24(sp)
81114bdc:	df000604 	addi	fp,sp,24
81114be0:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81114be4:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81114be8:	d0a06117 	ldw	r2,-32380(gp)
81114bec:	100f883a 	mov	r7,r2
81114bf0:	018006c4 	movi	r6,27
81114bf4:	01400044 	movi	r5,1
81114bf8:	01204574 	movhi	r4,33045
81114bfc:	212f1b04 	addi	r4,r4,-17300
81114c00:	111fc980 	call	8111fc98 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81114c04:	d0a06117 	ldw	r2,-32380(gp)
81114c08:	100f883a 	mov	r7,r2
81114c0c:	01800b04 	movi	r6,44
81114c10:	01400044 	movi	r5,1
81114c14:	01204574 	movhi	r4,33045
81114c18:	212f2204 	addi	r4,r4,-17272
81114c1c:	111fc980 	call	8111fc98 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
81114c20:	d0a06117 	ldw	r2,-32380(gp)
81114c24:	100f883a 	mov	r7,r2
81114c28:	01800f84 	movi	r6,62
81114c2c:	01400044 	movi	r5,1
81114c30:	01204574 	movhi	r4,33045
81114c34:	212f2e04 	addi	r4,r4,-17224
81114c38:	111fc980 	call	8111fc98 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
81114c3c:	e0bffd04 	addi	r2,fp,-12
81114c40:	100b883a 	mov	r5,r2
81114c44:	01000804 	movi	r4,32
81114c48:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114c4c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
81114c50:	e0bffc03 	ldbu	r2,-16(fp)
81114c54:	10000f1e 	bne	r2,zero,81114c94 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114c58:	d1206117 	ldw	r4,-32380(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
81114c5c:	e0fffd17 	ldw	r3,-12(fp)
81114c60:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114c64:	188b883a 	add	r5,r3,r2
81114c68:	e0bffd17 	ldw	r2,-12(fp)
81114c6c:	e0fffe17 	ldw	r3,-8(fp)
81114c70:	d8c00115 	stw	r3,4(sp)
81114c74:	d8800015 	stw	r2,0(sp)
81114c78:	280f883a 	mov	r7,r5
81114c7c:	01a04574 	movhi	r6,33045
81114c80:	31af3e04 	addi	r6,r6,-17160
81114c84:	01604574 	movhi	r5,33045
81114c88:	296f4204 	addi	r5,r5,-17144
81114c8c:	111f5fc0 	call	8111f5fc <fprintf>
81114c90:	00000706 	br	81114cb0 <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81114c94:	d0a06117 	ldw	r2,-32380(gp)
81114c98:	100f883a 	mov	r7,r2
81114c9c:	01800904 	movi	r6,36
81114ca0:	01400044 	movi	r5,1
81114ca4:	01204574 	movhi	r4,33045
81114ca8:	212f5104 	addi	r4,r4,-17084
81114cac:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
81114cb0:	e0bffd04 	addi	r2,fp,-12
81114cb4:	100b883a 	mov	r5,r2
81114cb8:	01000784 	movi	r4,30
81114cbc:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114cc0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114cc4:	e0bffc03 	ldbu	r2,-16(fp)
81114cc8:	10000f1e 	bne	r2,zero,81114d08 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114ccc:	d1206117 	ldw	r4,-32380(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
81114cd0:	e0fffd17 	ldw	r3,-12(fp)
81114cd4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114cd8:	188b883a 	add	r5,r3,r2
81114cdc:	e0bffd17 	ldw	r2,-12(fp)
81114ce0:	e0fffe17 	ldw	r3,-8(fp)
81114ce4:	d8c00115 	stw	r3,4(sp)
81114ce8:	d8800015 	stw	r2,0(sp)
81114cec:	280f883a 	mov	r7,r5
81114cf0:	01a04574 	movhi	r6,33045
81114cf4:	31af5b04 	addi	r6,r6,-17044
81114cf8:	01604574 	movhi	r5,33045
81114cfc:	296f4204 	addi	r5,r5,-17144
81114d00:	111f5fc0 	call	8111f5fc <fprintf>
81114d04:	00000706 	br	81114d24 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81114d08:	d0a06117 	ldw	r2,-32380(gp)
81114d0c:	100f883a 	mov	r7,r2
81114d10:	01800984 	movi	r6,38
81114d14:	01400044 	movi	r5,1
81114d18:	01204574 	movhi	r4,33045
81114d1c:	212f5f04 	addi	r4,r4,-17028
81114d20:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
81114d24:	e0bffd04 	addi	r2,fp,-12
81114d28:	100b883a 	mov	r5,r2
81114d2c:	01000704 	movi	r4,28
81114d30:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114d34:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114d38:	e0bffc03 	ldbu	r2,-16(fp)
81114d3c:	10000f1e 	bne	r2,zero,81114d7c <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114d40:	d1206117 	ldw	r4,-32380(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
81114d44:	e0fffd17 	ldw	r3,-12(fp)
81114d48:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114d4c:	188b883a 	add	r5,r3,r2
81114d50:	e0bffd17 	ldw	r2,-12(fp)
81114d54:	e0fffe17 	ldw	r3,-8(fp)
81114d58:	d8c00115 	stw	r3,4(sp)
81114d5c:	d8800015 	stw	r2,0(sp)
81114d60:	280f883a 	mov	r7,r5
81114d64:	01a04574 	movhi	r6,33045
81114d68:	31af6904 	addi	r6,r6,-16988
81114d6c:	01604574 	movhi	r5,33045
81114d70:	296f4204 	addi	r5,r5,-17144
81114d74:	111f5fc0 	call	8111f5fc <fprintf>
81114d78:	00000706 	br	81114d98 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
81114d7c:	d0a06117 	ldw	r2,-32380(gp)
81114d80:	100f883a 	mov	r7,r2
81114d84:	01800884 	movi	r6,34
81114d88:	01400044 	movi	r5,1
81114d8c:	01204574 	movhi	r4,33045
81114d90:	212f6c04 	addi	r4,r4,-16976
81114d94:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81114d98:	e0bffd04 	addi	r2,fp,-12
81114d9c:	100b883a 	mov	r5,r2
81114da0:	010006c4 	movi	r4,27
81114da4:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114da8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114dac:	e0bffc03 	ldbu	r2,-16(fp)
81114db0:	10000f1e 	bne	r2,zero,81114df0 <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114db4:	d1206117 	ldw	r4,-32380(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81114db8:	e0fffd17 	ldw	r3,-12(fp)
81114dbc:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114dc0:	188b883a 	add	r5,r3,r2
81114dc4:	e0bffd17 	ldw	r2,-12(fp)
81114dc8:	e0fffe17 	ldw	r3,-8(fp)
81114dcc:	d8c00115 	stw	r3,4(sp)
81114dd0:	d8800015 	stw	r2,0(sp)
81114dd4:	280f883a 	mov	r7,r5
81114dd8:	01a04574 	movhi	r6,33045
81114ddc:	31af7504 	addi	r6,r6,-16940
81114de0:	01604574 	movhi	r5,33045
81114de4:	296f4204 	addi	r5,r5,-17144
81114de8:	111f5fc0 	call	8111f5fc <fprintf>
81114dec:	00000706 	br	81114e0c <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
81114df0:	d0a06117 	ldw	r2,-32380(gp)
81114df4:	100f883a 	mov	r7,r2
81114df8:	018008c4 	movi	r6,35
81114dfc:	01400044 	movi	r5,1
81114e00:	01204574 	movhi	r4,33045
81114e04:	212f7904 	addi	r4,r4,-16924
81114e08:	111fc980 	call	8111fc98 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81114e0c:	e0bffd04 	addi	r2,fp,-12
81114e10:	100b883a 	mov	r5,r2
81114e14:	01000684 	movi	r4,26
81114e18:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114e1c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114e20:	e0bffc03 	ldbu	r2,-16(fp)
81114e24:	10000f1e 	bne	r2,zero,81114e64 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114e28:	d1206117 	ldw	r4,-32380(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
81114e2c:	e0fffd17 	ldw	r3,-12(fp)
81114e30:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114e34:	188b883a 	add	r5,r3,r2
81114e38:	e0bffd17 	ldw	r2,-12(fp)
81114e3c:	e0fffe17 	ldw	r3,-8(fp)
81114e40:	d8c00115 	stw	r3,4(sp)
81114e44:	d8800015 	stw	r2,0(sp)
81114e48:	280f883a 	mov	r7,r5
81114e4c:	01a04574 	movhi	r6,33045
81114e50:	31af8204 	addi	r6,r6,-16888
81114e54:	01604574 	movhi	r5,33045
81114e58:	296f4204 	addi	r5,r5,-17144
81114e5c:	111f5fc0 	call	8111f5fc <fprintf>
81114e60:	00000706 	br	81114e80 <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
81114e64:	d0a06117 	ldw	r2,-32380(gp)
81114e68:	100f883a 	mov	r7,r2
81114e6c:	01800884 	movi	r6,34
81114e70:	01400044 	movi	r5,1
81114e74:	01204574 	movhi	r4,33045
81114e78:	212f8504 	addi	r4,r4,-16876
81114e7c:	111fc980 	call	8111fc98 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
81114e80:	e0bffd04 	addi	r2,fp,-12
81114e84:	100b883a 	mov	r5,r2
81114e88:	01000644 	movi	r4,25
81114e8c:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114e90:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114e94:	e0bffc03 	ldbu	r2,-16(fp)
81114e98:	10000f1e 	bne	r2,zero,81114ed8 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114e9c:	d1206117 	ldw	r4,-32380(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81114ea0:	e0fffd17 	ldw	r3,-12(fp)
81114ea4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114ea8:	188b883a 	add	r5,r3,r2
81114eac:	e0bffd17 	ldw	r2,-12(fp)
81114eb0:	e0fffe17 	ldw	r3,-8(fp)
81114eb4:	d8c00115 	stw	r3,4(sp)
81114eb8:	d8800015 	stw	r2,0(sp)
81114ebc:	280f883a 	mov	r7,r5
81114ec0:	01a04574 	movhi	r6,33045
81114ec4:	31af8e04 	addi	r6,r6,-16840
81114ec8:	01604574 	movhi	r5,33045
81114ecc:	296f4204 	addi	r5,r5,-17144
81114ed0:	111f5fc0 	call	8111f5fc <fprintf>
81114ed4:	00000706 	br	81114ef4 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81114ed8:	d0a06117 	ldw	r2,-32380(gp)
81114edc:	100f883a 	mov	r7,r2
81114ee0:	01800884 	movi	r6,34
81114ee4:	01400044 	movi	r5,1
81114ee8:	01204574 	movhi	r4,33045
81114eec:	212f9104 	addi	r4,r4,-16828
81114ef0:	111fc980 	call	8111fc98 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81114ef4:	e0bffd04 	addi	r2,fp,-12
81114ef8:	100b883a 	mov	r5,r2
81114efc:	01000044 	movi	r4,1
81114f00:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114f04:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114f08:	e0bffc03 	ldbu	r2,-16(fp)
81114f0c:	10000f1e 	bne	r2,zero,81114f4c <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114f10:	d1206117 	ldw	r4,-32380(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81114f14:	e0fffd17 	ldw	r3,-12(fp)
81114f18:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114f1c:	188b883a 	add	r5,r3,r2
81114f20:	e0bffd17 	ldw	r2,-12(fp)
81114f24:	e0fffe17 	ldw	r3,-8(fp)
81114f28:	d8c00115 	stw	r3,4(sp)
81114f2c:	d8800015 	stw	r2,0(sp)
81114f30:	280f883a 	mov	r7,r5
81114f34:	01a04574 	movhi	r6,33045
81114f38:	31af9a04 	addi	r6,r6,-16792
81114f3c:	01604574 	movhi	r5,33045
81114f40:	296f4204 	addi	r5,r5,-17144
81114f44:	111f5fc0 	call	8111f5fc <fprintf>
81114f48:	00000706 	br	81114f68 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81114f4c:	d0a06117 	ldw	r2,-32380(gp)
81114f50:	100f883a 	mov	r7,r2
81114f54:	01800804 	movi	r6,32
81114f58:	01400044 	movi	r5,1
81114f5c:	01204574 	movhi	r4,33045
81114f60:	212f9d04 	addi	r4,r4,-16780
81114f64:	111fc980 	call	8111fc98 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81114f68:	e0bffd04 	addi	r2,fp,-12
81114f6c:	100b883a 	mov	r5,r2
81114f70:	010002c4 	movi	r4,11
81114f74:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114f78:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114f7c:	e0bffc03 	ldbu	r2,-16(fp)
81114f80:	10000f1e 	bne	r2,zero,81114fc0 <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114f84:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81114f88:	e0fffd17 	ldw	r3,-12(fp)
81114f8c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114f90:	188b883a 	add	r5,r3,r2
81114f94:	e0bffd17 	ldw	r2,-12(fp)
81114f98:	e0fffe17 	ldw	r3,-8(fp)
81114f9c:	d8c00115 	stw	r3,4(sp)
81114fa0:	d8800015 	stw	r2,0(sp)
81114fa4:	280f883a 	mov	r7,r5
81114fa8:	01a04574 	movhi	r6,33045
81114fac:	31afa604 	addi	r6,r6,-16744
81114fb0:	01604574 	movhi	r5,33045
81114fb4:	296f4204 	addi	r5,r5,-17144
81114fb8:	111f5fc0 	call	8111f5fc <fprintf>
81114fbc:	00000706 	br	81114fdc <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81114fc0:	d0a06117 	ldw	r2,-32380(gp)
81114fc4:	100f883a 	mov	r7,r2
81114fc8:	018008c4 	movi	r6,35
81114fcc:	01400044 	movi	r5,1
81114fd0:	01204574 	movhi	r4,33045
81114fd4:	212fa904 	addi	r4,r4,-16732
81114fd8:	111fc980 	call	8111fc98 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81114fdc:	e0bffd04 	addi	r2,fp,-12
81114fe0:	100b883a 	mov	r5,r2
81114fe4:	01000304 	movi	r4,12
81114fe8:	113e44c0 	call	8113e44c <OSTaskStkChk>
81114fec:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81114ff0:	e0bffc03 	ldbu	r2,-16(fp)
81114ff4:	10000f1e 	bne	r2,zero,81115034 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81114ff8:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81114ffc:	e0fffd17 	ldw	r3,-12(fp)
81115000:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115004:	188b883a 	add	r5,r3,r2
81115008:	e0bffd17 	ldw	r2,-12(fp)
8111500c:	e0fffe17 	ldw	r3,-8(fp)
81115010:	d8c00115 	stw	r3,4(sp)
81115014:	d8800015 	stw	r2,0(sp)
81115018:	280f883a 	mov	r7,r5
8111501c:	01a04574 	movhi	r6,33045
81115020:	31afb204 	addi	r6,r6,-16696
81115024:	01604574 	movhi	r5,33045
81115028:	296f4204 	addi	r5,r5,-17144
8111502c:	111f5fc0 	call	8111f5fc <fprintf>
81115030:	00000706 	br	81115050 <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81115034:	d0a06117 	ldw	r2,-32380(gp)
81115038:	100f883a 	mov	r7,r2
8111503c:	018008c4 	movi	r6,35
81115040:	01400044 	movi	r5,1
81115044:	01204574 	movhi	r4,33045
81115048:	212fb504 	addi	r4,r4,-16684
8111504c:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81115050:	e0bffd04 	addi	r2,fp,-12
81115054:	100b883a 	mov	r5,r2
81115058:	01000344 	movi	r4,13
8111505c:	113e44c0 	call	8113e44c <OSTaskStkChk>
81115060:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115064:	e0bffc03 	ldbu	r2,-16(fp)
81115068:	10000f1e 	bne	r2,zero,811150a8 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111506c:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81115070:	e0fffd17 	ldw	r3,-12(fp)
81115074:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115078:	188b883a 	add	r5,r3,r2
8111507c:	e0bffd17 	ldw	r2,-12(fp)
81115080:	e0fffe17 	ldw	r3,-8(fp)
81115084:	d8c00115 	stw	r3,4(sp)
81115088:	d8800015 	stw	r2,0(sp)
8111508c:	280f883a 	mov	r7,r5
81115090:	01a04574 	movhi	r6,33045
81115094:	31afbe04 	addi	r6,r6,-16648
81115098:	01604574 	movhi	r5,33045
8111509c:	296f4204 	addi	r5,r5,-17144
811150a0:	111f5fc0 	call	8111f5fc <fprintf>
811150a4:	00000706 	br	811150c4 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
811150a8:	d0a06117 	ldw	r2,-32380(gp)
811150ac:	100f883a 	mov	r7,r2
811150b0:	018008c4 	movi	r6,35
811150b4:	01400044 	movi	r5,1
811150b8:	01204574 	movhi	r4,33045
811150bc:	212fc104 	addi	r4,r4,-16636
811150c0:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
811150c4:	e0bffd04 	addi	r2,fp,-12
811150c8:	100b883a 	mov	r5,r2
811150cc:	01000384 	movi	r4,14
811150d0:	113e44c0 	call	8113e44c <OSTaskStkChk>
811150d4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811150d8:	e0bffc03 	ldbu	r2,-16(fp)
811150dc:	10000f1e 	bne	r2,zero,8111511c <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811150e0:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
811150e4:	e0fffd17 	ldw	r3,-12(fp)
811150e8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811150ec:	188b883a 	add	r5,r3,r2
811150f0:	e0bffd17 	ldw	r2,-12(fp)
811150f4:	e0fffe17 	ldw	r3,-8(fp)
811150f8:	d8c00115 	stw	r3,4(sp)
811150fc:	d8800015 	stw	r2,0(sp)
81115100:	280f883a 	mov	r7,r5
81115104:	01a04574 	movhi	r6,33045
81115108:	31afca04 	addi	r6,r6,-16600
8111510c:	01604574 	movhi	r5,33045
81115110:	296f4204 	addi	r5,r5,-17144
81115114:	111f5fc0 	call	8111f5fc <fprintf>
81115118:	00000706 	br	81115138 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
8111511c:	d0a06117 	ldw	r2,-32380(gp)
81115120:	100f883a 	mov	r7,r2
81115124:	018008c4 	movi	r6,35
81115128:	01400044 	movi	r5,1
8111512c:	01204574 	movhi	r4,33045
81115130:	212fcd04 	addi	r4,r4,-16588
81115134:	111fc980 	call	8111fc98 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81115138:	e0bffd04 	addi	r2,fp,-12
8111513c:	100b883a 	mov	r5,r2
81115140:	010003c4 	movi	r4,15
81115144:	113e44c0 	call	8113e44c <OSTaskStkChk>
81115148:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111514c:	e0bffc03 	ldbu	r2,-16(fp)
81115150:	10000f1e 	bne	r2,zero,81115190 <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115154:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81115158:	e0fffd17 	ldw	r3,-12(fp)
8111515c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115160:	188b883a 	add	r5,r3,r2
81115164:	e0bffd17 	ldw	r2,-12(fp)
81115168:	e0fffe17 	ldw	r3,-8(fp)
8111516c:	d8c00115 	stw	r3,4(sp)
81115170:	d8800015 	stw	r2,0(sp)
81115174:	280f883a 	mov	r7,r5
81115178:	01a04574 	movhi	r6,33045
8111517c:	31afd604 	addi	r6,r6,-16552
81115180:	01604574 	movhi	r5,33045
81115184:	296f4204 	addi	r5,r5,-17144
81115188:	111f5fc0 	call	8111f5fc <fprintf>
8111518c:	00000706 	br	811151ac <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81115190:	d0a06117 	ldw	r2,-32380(gp)
81115194:	100f883a 	mov	r7,r2
81115198:	018008c4 	movi	r6,35
8111519c:	01400044 	movi	r5,1
811151a0:	01204574 	movhi	r4,33045
811151a4:	212fd904 	addi	r4,r4,-16540
811151a8:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
811151ac:	e0bffd04 	addi	r2,fp,-12
811151b0:	100b883a 	mov	r5,r2
811151b4:	01000404 	movi	r4,16
811151b8:	113e44c0 	call	8113e44c <OSTaskStkChk>
811151bc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811151c0:	e0bffc03 	ldbu	r2,-16(fp)
811151c4:	10000f1e 	bne	r2,zero,81115204 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811151c8:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
811151cc:	e0fffd17 	ldw	r3,-12(fp)
811151d0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811151d4:	188b883a 	add	r5,r3,r2
811151d8:	e0bffd17 	ldw	r2,-12(fp)
811151dc:	e0fffe17 	ldw	r3,-8(fp)
811151e0:	d8c00115 	stw	r3,4(sp)
811151e4:	d8800015 	stw	r2,0(sp)
811151e8:	280f883a 	mov	r7,r5
811151ec:	01a04574 	movhi	r6,33045
811151f0:	31afe204 	addi	r6,r6,-16504
811151f4:	01604574 	movhi	r5,33045
811151f8:	296f4204 	addi	r5,r5,-17144
811151fc:	111f5fc0 	call	8111f5fc <fprintf>
81115200:	00000706 	br	81115220 <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81115204:	d0a06117 	ldw	r2,-32380(gp)
81115208:	100f883a 	mov	r7,r2
8111520c:	018008c4 	movi	r6,35
81115210:	01400044 	movi	r5,1
81115214:	01204574 	movhi	r4,33045
81115218:	212fe504 	addi	r4,r4,-16492
8111521c:	111fc980 	call	8111fc98 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81115220:	e0bffd04 	addi	r2,fp,-12
81115224:	100b883a 	mov	r5,r2
81115228:	01000284 	movi	r4,10
8111522c:	113e44c0 	call	8113e44c <OSTaskStkChk>
81115230:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81115234:	e0bffc03 	ldbu	r2,-16(fp)
81115238:	10000f1e 	bne	r2,zero,81115278 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111523c:	d1206117 	ldw	r4,-32380(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81115240:	e0fffd17 	ldw	r3,-12(fp)
81115244:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115248:	188b883a 	add	r5,r3,r2
8111524c:	e0bffd17 	ldw	r2,-12(fp)
81115250:	e0fffe17 	ldw	r3,-8(fp)
81115254:	d8c00115 	stw	r3,4(sp)
81115258:	d8800015 	stw	r2,0(sp)
8111525c:	280f883a 	mov	r7,r5
81115260:	01a04574 	movhi	r6,33045
81115264:	31afee04 	addi	r6,r6,-16456
81115268:	01604574 	movhi	r5,33045
8111526c:	296f4204 	addi	r5,r5,-17144
81115270:	111f5fc0 	call	8111f5fc <fprintf>
81115274:	00000706 	br	81115294 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81115278:	d0a06117 	ldw	r2,-32380(gp)
8111527c:	100f883a 	mov	r7,r2
81115280:	01800884 	movi	r6,34
81115284:	01400044 	movi	r5,1
81115288:	01204574 	movhi	r4,33045
8111528c:	212ff104 	addi	r4,r4,-16444
81115290:	111fc980 	call	8111fc98 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81115294:	e0bffd04 	addi	r2,fp,-12
81115298:	100b883a 	mov	r5,r2
8111529c:	01000244 	movi	r4,9
811152a0:	113e44c0 	call	8113e44c <OSTaskStkChk>
811152a4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811152a8:	e0bffc03 	ldbu	r2,-16(fp)
811152ac:	10000f1e 	bne	r2,zero,811152ec <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811152b0:	d1206117 	ldw	r4,-32380(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
811152b4:	e0fffd17 	ldw	r3,-12(fp)
811152b8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811152bc:	188b883a 	add	r5,r3,r2
811152c0:	e0bffd17 	ldw	r2,-12(fp)
811152c4:	e0fffe17 	ldw	r3,-8(fp)
811152c8:	d8c00115 	stw	r3,4(sp)
811152cc:	d8800015 	stw	r2,0(sp)
811152d0:	280f883a 	mov	r7,r5
811152d4:	01a04574 	movhi	r6,33045
811152d8:	31affa04 	addi	r6,r6,-16408
811152dc:	01604574 	movhi	r5,33045
811152e0:	296f4204 	addi	r5,r5,-17144
811152e4:	111f5fc0 	call	8111f5fc <fprintf>
811152e8:	00000706 	br	81115308 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
811152ec:	d0a06117 	ldw	r2,-32380(gp)
811152f0:	100f883a 	mov	r7,r2
811152f4:	01800844 	movi	r6,33
811152f8:	01400044 	movi	r5,1
811152fc:	01204574 	movhi	r4,33045
81115300:	212ffd04 	addi	r4,r4,-16396
81115304:	111fc980 	call	8111fc98 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81115308:	e0bffd04 	addi	r2,fp,-12
8111530c:	100b883a 	mov	r5,r2
81115310:	01000204 	movi	r4,8
81115314:	113e44c0 	call	8113e44c <OSTaskStkChk>
81115318:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111531c:	e0bffc03 	ldbu	r2,-16(fp)
81115320:	10000f1e 	bne	r2,zero,81115360 <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115324:	d1206117 	ldw	r4,-32380(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81115328:	e0fffd17 	ldw	r3,-12(fp)
8111532c:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81115330:	188b883a 	add	r5,r3,r2
81115334:	e0bffd17 	ldw	r2,-12(fp)
81115338:	e0fffe17 	ldw	r3,-8(fp)
8111533c:	d8c00115 	stw	r3,4(sp)
81115340:	d8800015 	stw	r2,0(sp)
81115344:	280f883a 	mov	r7,r5
81115348:	01a04574 	movhi	r6,33045
8111534c:	31b00604 	addi	r6,r6,-16360
81115350:	01604574 	movhi	r5,33045
81115354:	296f4204 	addi	r5,r5,-17144
81115358:	111f5fc0 	call	8111f5fc <fprintf>
8111535c:	00000706 	br	8111537c <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81115360:	d0a06117 	ldw	r2,-32380(gp)
81115364:	100f883a 	mov	r7,r2
81115368:	018007c4 	movi	r6,31
8111536c:	01400044 	movi	r5,1
81115370:	01204574 	movhi	r4,33045
81115374:	21300904 	addi	r4,r4,-16348
81115378:	111fc980 	call	8111fc98 <fwrite>
    	}		


    	fprintf(fp, "\n" );
8111537c:	d0a06117 	ldw	r2,-32380(gp)
81115380:	100b883a 	mov	r5,r2
81115384:	01000284 	movi	r4,10
81115388:	111f6740 	call	8111f674 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
8111538c:	000f883a 	mov	r7,zero
81115390:	01800284 	movi	r6,10
81115394:	000b883a 	mov	r5,zero
81115398:	0009883a 	mov	r4,zero
8111539c:	113eab00 	call	8113eab0 <OSTimeDlyHMSM>
    }
811153a0:	003e1806 	br	81114c04 <__reset+0xfb0f4c04>

811153a4 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
811153a4:	defffc04 	addi	sp,sp,-16
811153a8:	de00012e 	bgeu	sp,et,811153b0 <vTimeoutCheckerTaskv2+0xc>
811153ac:	003b68fa 	trap	3
811153b0:	dfc00315 	stw	ra,12(sp)
811153b4:	df000215 	stw	fp,8(sp)
811153b8:	df000204 	addi	fp,sp,8
811153bc:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
811153c0:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
811153c4:	d0a06117 	ldw	r2,-32380(gp)
811153c8:	100f883a 	mov	r7,r2
811153cc:	01800844 	movi	r6,33
811153d0:	01400044 	movi	r5,1
811153d4:	01204574 	movhi	r4,33045
811153d8:	21301104 	addi	r4,r4,-16316
811153dc:	111fc980 	call	8111fc98 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
811153e0:	d0a06617 	ldw	r2,-32360(gp)
811153e4:	e1bffe04 	addi	r6,fp,-8
811153e8:	000b883a 	mov	r5,zero
811153ec:	1009883a 	mov	r4,r2
811153f0:	113cb180 	call	8113cb18 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
811153f4:	e0bffe03 	ldbu	r2,-8(fp)
811153f8:	10803fcc 	andi	r2,r2,255
811153fc:	1000021e 	bne	r2,zero,81115408 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81115400:	11154100 	call	81115410 <vCheck>
81115404:	003ff606 	br	811153e0 <__reset+0xfb0f53e0>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81115408:	111a7bc0 	call	8111a7bc <vFailGetBlockingSemTimeoutTask>
        }
    }
8111540c:	003ff406 	br	811153e0 <__reset+0xfb0f53e0>

81115410 <vCheck>:
}


void vCheck( void ) {
81115410:	defffd04 	addi	sp,sp,-12
81115414:	de00012e 	bgeu	sp,et,8111541c <vCheck+0xc>
81115418:	003b68fa 	trap	3
8111541c:	dfc00215 	stw	ra,8(sp)
81115420:	df000115 	stw	fp,4(sp)
81115424:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81115428:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
8111542c:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81115430:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81115434:	d0a06783 	ldbu	r2,-32354(gp)
81115438:	10803fcc 	andi	r2,r2,255
8111543c:	10800218 	cmpnei	r2,r2,8
81115440:	1000021e 	bne	r2,zero,8111544c <vCheck+0x3c>
81115444:	00c00104 	movi	r3,4
81115448:	00000106 	br	81115450 <vCheck+0x40>
8111544c:	0007883a 	mov	r3,zero
81115450:	d0a07403 	ldbu	r2,-32304(gp)
81115454:	10803fcc 	andi	r2,r2,255
81115458:	10800218 	cmpnei	r2,r2,8
8111545c:	1000021e 	bne	r2,zero,81115468 <vCheck+0x58>
81115460:	00800084 	movi	r2,2
81115464:	00000106 	br	8111546c <vCheck+0x5c>
81115468:	0005883a 	mov	r2,zero
8111546c:	1884b03a 	or	r2,r3,r2
81115470:	1007883a 	mov	r3,r2
81115474:	d0a07443 	ldbu	r2,-32303(gp)
81115478:	10803fcc 	andi	r2,r2,255
8111547c:	108001a0 	cmpeqi	r2,r2,6
81115480:	1884b03a 	or	r2,r3,r2
81115484:	1007883a 	mov	r3,r2
81115488:	e0bfff03 	ldbu	r2,-4(fp)
8111548c:	1884b03a 	or	r2,r3,r2
81115490:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81115494:	e0bfff03 	ldbu	r2,-4(fp)
81115498:	108001d8 	cmpnei	r2,r2,7
8111549c:	10003726 	beq	r2,zero,8111557c <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
811154a0:	d0a07317 	ldw	r2,-32308(gp)
811154a4:	e0ffff44 	addi	r3,fp,-3
811154a8:	180d883a 	mov	r6,r3
811154ac:	000b883a 	mov	r5,zero
811154b0:	1009883a 	mov	r4,r2
811154b4:	113ab0c0 	call	8113ab0c <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
811154b8:	e0bfff43 	ldbu	r2,-3(fp)
811154bc:	10803fcc 	andi	r2,r2,255
811154c0:	10000826 	beq	r2,zero,811154e4 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
811154c4:	d0a06117 	ldw	r2,-32380(gp)
811154c8:	100f883a 	mov	r7,r2
811154cc:	01800f04 	movi	r6,60
811154d0:	01400044 	movi	r5,1
811154d4:	01204574 	movhi	r4,33045
811154d8:	21301a04 	addi	r4,r4,-16280
811154dc:	111fc980 	call	8111fc98 <fwrite>
		#endif
        return;
811154e0:	00002706 	br	81115580 <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
811154e4:	e0bfff03 	ldbu	r2,-4(fp)
811154e8:	1080004c 	andi	r2,r2,1
811154ec:	10803fcc 	andi	r2,r2,255
811154f0:	1000021e 	bne	r2,zero,811154fc <vCheck+0xec>
        vCheckRetransmission128();
811154f4:	11155940 	call	81115594 <vCheckRetransmission128>
811154f8:	00000506 	br	81115510 <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
811154fc:	01800604 	movi	r6,24
81115500:	000b883a 	mov	r5,zero
81115504:	012045b4 	movhi	r4,33046
81115508:	2131da04 	addi	r4,r4,-14488
8111550c:	11207fc0 	call	811207fc <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
81115510:	e0bfff03 	ldbu	r2,-4(fp)
81115514:	1080008c 	andi	r2,r2,2
81115518:	10803fcc 	andi	r2,r2,255
8111551c:	1000021e 	bne	r2,zero,81115528 <vCheck+0x118>
        vCheckRetransmission64();
81115520:	11158180 	call	81115818 <vCheckRetransmission64>
81115524:	00000506 	br	8111553c <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
81115528:	01800804 	movi	r6,32
8111552c:	000b883a 	mov	r5,zero
81115530:	012045b4 	movhi	r4,33046
81115534:	2131e004 	addi	r4,r4,-14464
81115538:	11207fc0 	call	811207fc <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
8111553c:	e0bfff03 	ldbu	r2,-4(fp)
81115540:	1080010c 	andi	r2,r2,4
81115544:	10803fcc 	andi	r2,r2,255
81115548:	1000021e 	bne	r2,zero,81115554 <vCheck+0x144>
        vCheckRetransmission32();
8111554c:	1115aa40 	call	81115aa4 <vCheckRetransmission32>
81115550:	00000506 	br	81115568 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
81115554:	01800804 	movi	r6,32
81115558:	000b883a 	mov	r5,zero
8111555c:	012045b4 	movhi	r4,33046
81115560:	2131e804 	addi	r4,r4,-14432
81115564:	11207fc0 	call	811207fc <memset>


    OSMutexPost(xTxUARTMutex);
81115568:	d0a07317 	ldw	r2,-32308(gp)
8111556c:	1009883a 	mov	r4,r2
81115570:	113b0b00 	call	8113b0b0 <OSMutexPost>

    return;
81115574:	0001883a 	nop
81115578:	00000106 	br	81115580 <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
8111557c:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
81115580:	e037883a 	mov	sp,fp
81115584:	dfc00117 	ldw	ra,4(sp)
81115588:	df000017 	ldw	fp,0(sp)
8111558c:	dec00204 	addi	sp,sp,8
81115590:	f800283a 	ret

81115594 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81115594:	defffd04 	addi	sp,sp,-12
81115598:	de00012e 	bgeu	sp,et,811155a0 <vCheckRetransmission128+0xc>
8111559c:	003b68fa 	trap	3
811155a0:	dfc00215 	stw	ra,8(sp)
811155a4:	df000115 	stw	fp,4(sp)
811155a8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811155ac:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811155b0:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811155b4:	d0a06d17 	ldw	r2,-32332(gp)
811155b8:	e0ffff44 	addi	r3,fp,-3
811155bc:	180b883a 	mov	r5,r3
811155c0:	1009883a 	mov	r4,r2
811155c4:	113a48c0 	call	8113a48c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811155c8:	e0bfff43 	ldbu	r2,-3(fp)
811155cc:	10803fcc 	andi	r2,r2,255
811155d0:	10008b1e 	bne	r2,zero,81115800 <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811155d4:	e03fff05 	stb	zero,-4(fp)
811155d8:	00008106 	br	811157e0 <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
811155dc:	e0ffff03 	ldbu	r3,-4(fp)
811155e0:	00a045b4 	movhi	r2,33046
811155e4:	10b1da04 	addi	r2,r2,-14488
811155e8:	18c7883a 	add	r3,r3,r3
811155ec:	18c7883a 	add	r3,r3,r3
811155f0:	10c5883a 	add	r2,r2,r3
811155f4:	10800017 	ldw	r2,0(r2)
811155f8:	10800058 	cmpnei	r2,r2,1
811155fc:	1000751e 	bne	r2,zero,811157d4 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
81115600:	e0ffff03 	ldbu	r3,-4(fp)
81115604:	00a045b4 	movhi	r2,33046
81115608:	10b1f804 	addi	r2,r2,-14368
8111560c:	18c02324 	muli	r3,r3,140
81115610:	10c5883a 	add	r2,r2,r3
81115614:	10802004 	addi	r2,r2,128
81115618:	10800017 	ldw	r2,0(r2)
8111561c:	10800058 	cmpnei	r2,r2,1
81115620:	1000211e 	bne	r2,zero,811156a8 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
81115624:	e0ffff03 	ldbu	r3,-4(fp)
81115628:	00a045b4 	movhi	r2,33046
8111562c:	10b1f804 	addi	r2,r2,-14368
81115630:	19002324 	muli	r4,r3,140
81115634:	1105883a 	add	r2,r2,r4
81115638:	10802184 	addi	r2,r2,134
8111563c:	1080000b 	ldhu	r2,0(r2)
81115640:	10800044 	addi	r2,r2,1
81115644:	100b883a 	mov	r5,r2
81115648:	00a045b4 	movhi	r2,33046
8111564c:	10b1f804 	addi	r2,r2,-14368
81115650:	19002324 	muli	r4,r3,140
81115654:	1105883a 	add	r2,r2,r4
81115658:	10802184 	addi	r2,r2,134
8111565c:	1140000d 	sth	r5,0(r2)
81115660:	00a045b4 	movhi	r2,33046
81115664:	10b1f804 	addi	r2,r2,-14368
81115668:	18c02324 	muli	r3,r3,140
8111566c:	10c5883a 	add	r2,r2,r3
81115670:	10802184 	addi	r2,r2,134
81115674:	1080000b 	ldhu	r2,0(r2)
81115678:	10bfffcc 	andi	r2,r2,65535
8111567c:	10a0001c 	xori	r2,r2,32768
81115680:	10a00004 	addi	r2,r2,-32768
81115684:	10800090 	cmplti	r2,r2,2
81115688:	1000071e 	bne	r2,zero,811156a8 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
8111568c:	e0ffff03 	ldbu	r3,-4(fp)
81115690:	00a045b4 	movhi	r2,33046
81115694:	10b1f804 	addi	r2,r2,-14368
81115698:	18c02324 	muli	r3,r3,140
8111569c:	10c5883a 	add	r2,r2,r3
811156a0:	10802004 	addi	r2,r2,128
811156a4:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
811156a8:	e0ffff03 	ldbu	r3,-4(fp)
811156ac:	00a045b4 	movhi	r2,33046
811156b0:	10b1f804 	addi	r2,r2,-14368
811156b4:	18c02324 	muli	r3,r3,140
811156b8:	10c5883a 	add	r2,r2,r3
811156bc:	10802004 	addi	r2,r2,128
811156c0:	10800017 	ldw	r2,0(r2)
811156c4:	1000431e 	bne	r2,zero,811157d4 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
811156c8:	e0bfff03 	ldbu	r2,-4(fp)
811156cc:	10c02324 	muli	r3,r2,140
811156d0:	00a045b4 	movhi	r2,33046
811156d4:	10b1f804 	addi	r2,r2,-14368
811156d8:	1885883a 	add	r2,r3,r2
811156dc:	1009883a 	mov	r4,r2
811156e0:	1120c480 	call	81120c48 <puts>
                xBuffer128[ucIL].bSent = TRUE;
811156e4:	e0ffff03 	ldbu	r3,-4(fp)
811156e8:	00a045b4 	movhi	r2,33046
811156ec:	10b1f804 	addi	r2,r2,-14368
811156f0:	18c02324 	muli	r3,r3,140
811156f4:	10c5883a 	add	r2,r2,r3
811156f8:	10802004 	addi	r2,r2,128
811156fc:	00c00044 	movi	r3,1
81115700:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81115704:	e0ffff03 	ldbu	r3,-4(fp)
81115708:	00a045b4 	movhi	r2,33046
8111570c:	10b1f804 	addi	r2,r2,-14368
81115710:	18c02324 	muli	r3,r3,140
81115714:	10c5883a 	add	r2,r2,r3
81115718:	10802184 	addi	r2,r2,134
8111571c:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81115720:	e0ffff03 	ldbu	r3,-4(fp)
81115724:	00a045b4 	movhi	r2,33046
81115728:	10b1f804 	addi	r2,r2,-14368
8111572c:	19002324 	muli	r4,r3,140
81115730:	1105883a 	add	r2,r2,r4
81115734:	10802204 	addi	r2,r2,136
81115738:	10800003 	ldbu	r2,0(r2)
8111573c:	10800044 	addi	r2,r2,1
81115740:	100b883a 	mov	r5,r2
81115744:	00a045b4 	movhi	r2,33046
81115748:	10b1f804 	addi	r2,r2,-14368
8111574c:	19002324 	muli	r4,r3,140
81115750:	1105883a 	add	r2,r2,r4
81115754:	10802204 	addi	r2,r2,136
81115758:	11400005 	stb	r5,0(r2)
8111575c:	00a045b4 	movhi	r2,33046
81115760:	10b1f804 	addi	r2,r2,-14368
81115764:	18c02324 	muli	r3,r3,140
81115768:	10c5883a 	add	r2,r2,r3
8111576c:	10802204 	addi	r2,r2,136
81115770:	10800003 	ldbu	r2,0(r2)
81115774:	10803fcc 	andi	r2,r2,255
81115778:	108000b0 	cmpltui	r2,r2,2
8111577c:	1000151e 	bne	r2,zero,811157d4 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
81115780:	e0ffff03 	ldbu	r3,-4(fp)
81115784:	00a045b4 	movhi	r2,33046
81115788:	10b1da04 	addi	r2,r2,-14488
8111578c:	18c7883a 	add	r3,r3,r3
81115790:	18c7883a 	add	r3,r3,r3
81115794:	10c5883a 	add	r2,r2,r3
81115798:	10000015 	stw	zero,0(r2)
                    SemCount128++;
8111579c:	d0a07443 	ldbu	r2,-32303(gp)
811157a0:	10800044 	addi	r2,r2,1
811157a4:	d0a07445 	stb	r2,-32303(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
811157a8:	d0a06217 	ldw	r2,-32376(gp)
811157ac:	1009883a 	mov	r4,r2
811157b0:	113cea00 	call	8113cea0 <OSSemPost>
811157b4:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811157b8:	e0bfff43 	ldbu	r2,-3(fp)
811157bc:	10803fcc 	andi	r2,r2,255
811157c0:	10000426 	beq	r2,zero,811157d4 <vCheckRetransmission128+0x240>
                        SemCount128--;
811157c4:	d0a07443 	ldbu	r2,-32303(gp)
811157c8:	10bfffc4 	addi	r2,r2,-1
811157cc:	d0a07445 	stb	r2,-32303(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
811157d0:	111a0ac0 	call	8111a0ac <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
811157d4:	e0bfff03 	ldbu	r2,-4(fp)
811157d8:	10800044 	addi	r2,r2,1
811157dc:	e0bfff05 	stb	r2,-4(fp)
811157e0:	e0bfff03 	ldbu	r2,-4(fp)
811157e4:	108001b0 	cmpltui	r2,r2,6
811157e8:	103f7c1e 	bne	r2,zero,811155dc <__reset+0xfb0f55dc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
811157ec:	d0a06d17 	ldw	r2,-32332(gp)
811157f0:	1009883a 	mov	r4,r2
811157f4:	113b0b00 	call	8113b0b0 <OSMutexPost>

    return;
811157f8:	0001883a 	nop
811157fc:	00000106 	br	81115804 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81115800:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81115804:	e037883a 	mov	sp,fp
81115808:	dfc00117 	ldw	ra,4(sp)
8111580c:	df000017 	ldw	fp,0(sp)
81115810:	dec00204 	addi	sp,sp,8
81115814:	f800283a 	ret

81115818 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81115818:	defffd04 	addi	sp,sp,-12
8111581c:	de00012e 	bgeu	sp,et,81115824 <vCheckRetransmission64+0xc>
81115820:	003b68fa 	trap	3
81115824:	dfc00215 	stw	ra,8(sp)
81115828:	df000115 	stw	fp,4(sp)
8111582c:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81115830:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
81115834:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81115838:	d0a07017 	ldw	r2,-32320(gp)
8111583c:	e0ffff44 	addi	r3,fp,-3
81115840:	180b883a 	mov	r5,r3
81115844:	1009883a 	mov	r4,r2
81115848:	113a48c0 	call	8113a48c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
8111584c:	e0bfff43 	ldbu	r2,-3(fp)
81115850:	10803fcc 	andi	r2,r2,255
81115854:	10008d1e 	bne	r2,zero,81115a8c <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81115858:	e03fff05 	stb	zero,-4(fp)
8111585c:	00008306 	br	81115a6c <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
81115860:	e0ffff03 	ldbu	r3,-4(fp)
81115864:	00a045b4 	movhi	r2,33046
81115868:	10b1da04 	addi	r2,r2,-14488
8111586c:	18c00184 	addi	r3,r3,6
81115870:	18c7883a 	add	r3,r3,r3
81115874:	18c7883a 	add	r3,r3,r3
81115878:	10c5883a 	add	r2,r2,r3
8111587c:	10800017 	ldw	r2,0(r2)
81115880:	10800058 	cmpnei	r2,r2,1
81115884:	1000761e 	bne	r2,zero,81115a60 <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81115888:	e0ffff03 	ldbu	r3,-4(fp)
8111588c:	00a04574 	movhi	r2,33045
81115890:	108d9e04 	addi	r2,r2,13944
81115894:	18c01324 	muli	r3,r3,76
81115898:	10c5883a 	add	r2,r2,r3
8111589c:	10801004 	addi	r2,r2,64
811158a0:	10800017 	ldw	r2,0(r2)
811158a4:	10800058 	cmpnei	r2,r2,1
811158a8:	1000211e 	bne	r2,zero,81115930 <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
811158ac:	e0ffff03 	ldbu	r3,-4(fp)
811158b0:	00a04574 	movhi	r2,33045
811158b4:	108d9e04 	addi	r2,r2,13944
811158b8:	19001324 	muli	r4,r3,76
811158bc:	1105883a 	add	r2,r2,r4
811158c0:	10801184 	addi	r2,r2,70
811158c4:	1080000b 	ldhu	r2,0(r2)
811158c8:	10800044 	addi	r2,r2,1
811158cc:	100b883a 	mov	r5,r2
811158d0:	00a04574 	movhi	r2,33045
811158d4:	108d9e04 	addi	r2,r2,13944
811158d8:	19001324 	muli	r4,r3,76
811158dc:	1105883a 	add	r2,r2,r4
811158e0:	10801184 	addi	r2,r2,70
811158e4:	1140000d 	sth	r5,0(r2)
811158e8:	00a04574 	movhi	r2,33045
811158ec:	108d9e04 	addi	r2,r2,13944
811158f0:	18c01324 	muli	r3,r3,76
811158f4:	10c5883a 	add	r2,r2,r3
811158f8:	10801184 	addi	r2,r2,70
811158fc:	1080000b 	ldhu	r2,0(r2)
81115900:	10bfffcc 	andi	r2,r2,65535
81115904:	10a0001c 	xori	r2,r2,32768
81115908:	10a00004 	addi	r2,r2,-32768
8111590c:	10800090 	cmplti	r2,r2,2
81115910:	1000071e 	bne	r2,zero,81115930 <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81115914:	e0ffff03 	ldbu	r3,-4(fp)
81115918:	00a04574 	movhi	r2,33045
8111591c:	108d9e04 	addi	r2,r2,13944
81115920:	18c01324 	muli	r3,r3,76
81115924:	10c5883a 	add	r2,r2,r3
81115928:	10801004 	addi	r2,r2,64
8111592c:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
81115930:	e0ffff03 	ldbu	r3,-4(fp)
81115934:	00a04574 	movhi	r2,33045
81115938:	108d9e04 	addi	r2,r2,13944
8111593c:	18c01324 	muli	r3,r3,76
81115940:	10c5883a 	add	r2,r2,r3
81115944:	10801004 	addi	r2,r2,64
81115948:	10800017 	ldw	r2,0(r2)
8111594c:	1000441e 	bne	r2,zero,81115a60 <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
81115950:	e0bfff03 	ldbu	r2,-4(fp)
81115954:	10c01324 	muli	r3,r2,76
81115958:	00a04574 	movhi	r2,33045
8111595c:	108d9e04 	addi	r2,r2,13944
81115960:	1885883a 	add	r2,r3,r2
81115964:	1009883a 	mov	r4,r2
81115968:	1120c480 	call	81120c48 <puts>
                xBuffer64[ucIL].bSent = TRUE;
8111596c:	e0ffff03 	ldbu	r3,-4(fp)
81115970:	00a04574 	movhi	r2,33045
81115974:	108d9e04 	addi	r2,r2,13944
81115978:	18c01324 	muli	r3,r3,76
8111597c:	10c5883a 	add	r2,r2,r3
81115980:	10801004 	addi	r2,r2,64
81115984:	00c00044 	movi	r3,1
81115988:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
8111598c:	e0ffff03 	ldbu	r3,-4(fp)
81115990:	00a04574 	movhi	r2,33045
81115994:	108d9e04 	addi	r2,r2,13944
81115998:	18c01324 	muli	r3,r3,76
8111599c:	10c5883a 	add	r2,r2,r3
811159a0:	10801184 	addi	r2,r2,70
811159a4:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
811159a8:	e0ffff03 	ldbu	r3,-4(fp)
811159ac:	00a04574 	movhi	r2,33045
811159b0:	108d9e04 	addi	r2,r2,13944
811159b4:	19001324 	muli	r4,r3,76
811159b8:	1105883a 	add	r2,r2,r4
811159bc:	10801204 	addi	r2,r2,72
811159c0:	10800003 	ldbu	r2,0(r2)
811159c4:	10800044 	addi	r2,r2,1
811159c8:	100b883a 	mov	r5,r2
811159cc:	00a04574 	movhi	r2,33045
811159d0:	108d9e04 	addi	r2,r2,13944
811159d4:	19001324 	muli	r4,r3,76
811159d8:	1105883a 	add	r2,r2,r4
811159dc:	10801204 	addi	r2,r2,72
811159e0:	11400005 	stb	r5,0(r2)
811159e4:	00a04574 	movhi	r2,33045
811159e8:	108d9e04 	addi	r2,r2,13944
811159ec:	18c01324 	muli	r3,r3,76
811159f0:	10c5883a 	add	r2,r2,r3
811159f4:	10801204 	addi	r2,r2,72
811159f8:	10800003 	ldbu	r2,0(r2)
811159fc:	10803fcc 	andi	r2,r2,255
81115a00:	108000b0 	cmpltui	r2,r2,2
81115a04:	1000161e 	bne	r2,zero,81115a60 <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
81115a08:	e0ffff03 	ldbu	r3,-4(fp)
81115a0c:	00a045b4 	movhi	r2,33046
81115a10:	10b1da04 	addi	r2,r2,-14488
81115a14:	18c00184 	addi	r3,r3,6
81115a18:	18c7883a 	add	r3,r3,r3
81115a1c:	18c7883a 	add	r3,r3,r3
81115a20:	10c5883a 	add	r2,r2,r3
81115a24:	10000015 	stw	zero,0(r2)
                    SemCount64++;
81115a28:	d0a07403 	ldbu	r2,-32304(gp)
81115a2c:	10800044 	addi	r2,r2,1
81115a30:	d0a07405 	stb	r2,-32304(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
81115a34:	d0a05d17 	ldw	r2,-32396(gp)
81115a38:	1009883a 	mov	r4,r2
81115a3c:	113cea00 	call	8113cea0 <OSSemPost>
81115a40:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81115a44:	e0bfff43 	ldbu	r2,-3(fp)
81115a48:	10803fcc 	andi	r2,r2,255
81115a4c:	10000426 	beq	r2,zero,81115a60 <vCheckRetransmission64+0x248>
                        SemCount64--;
81115a50:	d0a07403 	ldbu	r2,-32304(gp)
81115a54:	10bfffc4 	addi	r2,r2,-1
81115a58:	d0a07405 	stb	r2,-32304(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81115a5c:	111a0440 	call	8111a044 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
81115a60:	e0bfff03 	ldbu	r2,-4(fp)
81115a64:	10800044 	addi	r2,r2,1
81115a68:	e0bfff05 	stb	r2,-4(fp)
81115a6c:	e0bfff03 	ldbu	r2,-4(fp)
81115a70:	10800230 	cmpltui	r2,r2,8
81115a74:	103f7a1e 	bne	r2,zero,81115860 <__reset+0xfb0f5860>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
81115a78:	d0a07017 	ldw	r2,-32320(gp)
81115a7c:	1009883a 	mov	r4,r2
81115a80:	113b0b00 	call	8113b0b0 <OSMutexPost>

    return;
81115a84:	0001883a 	nop
81115a88:	00000106 	br	81115a90 <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81115a8c:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
81115a90:	e037883a 	mov	sp,fp
81115a94:	dfc00117 	ldw	ra,4(sp)
81115a98:	df000017 	ldw	fp,0(sp)
81115a9c:	dec00204 	addi	sp,sp,8
81115aa0:	f800283a 	ret

81115aa4 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81115aa4:	defffd04 	addi	sp,sp,-12
81115aa8:	de00012e 	bgeu	sp,et,81115ab0 <vCheckRetransmission32+0xc>
81115aac:	003b68fa 	trap	3
81115ab0:	dfc00215 	stw	ra,8(sp)
81115ab4:	df000115 	stw	fp,4(sp)
81115ab8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81115abc:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
81115ac0:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81115ac4:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81115ac8:	d0a06b17 	ldw	r2,-32340(gp)
81115acc:	e0ffff84 	addi	r3,fp,-2
81115ad0:	180b883a 	mov	r5,r3
81115ad4:	1009883a 	mov	r4,r2
81115ad8:	113a48c0 	call	8113a48c <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81115adc:	e0bfff83 	ldbu	r2,-2(fp)
81115ae0:	10803fcc 	andi	r2,r2,255
81115ae4:	10009b1e 	bne	r2,zero,81115d54 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81115ae8:	e03fff05 	stb	zero,-4(fp)
81115aec:	00009106 	br	81115d34 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
81115af0:	e0ffff03 	ldbu	r3,-4(fp)
81115af4:	00a045b4 	movhi	r2,33046
81115af8:	10b1da04 	addi	r2,r2,-14488
81115afc:	18c00384 	addi	r3,r3,14
81115b00:	18c7883a 	add	r3,r3,r3
81115b04:	18c7883a 	add	r3,r3,r3
81115b08:	10c5883a 	add	r2,r2,r3
81115b0c:	10800017 	ldw	r2,0(r2)
81115b10:	10800058 	cmpnei	r2,r2,1
81115b14:	1000841e 	bne	r2,zero,81115d28 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81115b18:	e0ffff03 	ldbu	r3,-4(fp)
81115b1c:	00a04574 	movhi	r2,33045
81115b20:	109f5a04 	addi	r2,r2,32104
81115b24:	18c00b24 	muli	r3,r3,44
81115b28:	10c5883a 	add	r2,r2,r3
81115b2c:	10800804 	addi	r2,r2,32
81115b30:	10800017 	ldw	r2,0(r2)
81115b34:	10800058 	cmpnei	r2,r2,1
81115b38:	1000211e 	bne	r2,zero,81115bc0 <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
81115b3c:	e0ffff03 	ldbu	r3,-4(fp)
81115b40:	00a04574 	movhi	r2,33045
81115b44:	109f5a04 	addi	r2,r2,32104
81115b48:	19000b24 	muli	r4,r3,44
81115b4c:	1105883a 	add	r2,r2,r4
81115b50:	10800984 	addi	r2,r2,38
81115b54:	1080000b 	ldhu	r2,0(r2)
81115b58:	10800044 	addi	r2,r2,1
81115b5c:	100b883a 	mov	r5,r2
81115b60:	00a04574 	movhi	r2,33045
81115b64:	109f5a04 	addi	r2,r2,32104
81115b68:	19000b24 	muli	r4,r3,44
81115b6c:	1105883a 	add	r2,r2,r4
81115b70:	10800984 	addi	r2,r2,38
81115b74:	1140000d 	sth	r5,0(r2)
81115b78:	00a04574 	movhi	r2,33045
81115b7c:	109f5a04 	addi	r2,r2,32104
81115b80:	18c00b24 	muli	r3,r3,44
81115b84:	10c5883a 	add	r2,r2,r3
81115b88:	10800984 	addi	r2,r2,38
81115b8c:	1080000b 	ldhu	r2,0(r2)
81115b90:	10bfffcc 	andi	r2,r2,65535
81115b94:	10a0001c 	xori	r2,r2,32768
81115b98:	10a00004 	addi	r2,r2,-32768
81115b9c:	10800090 	cmplti	r2,r2,2
81115ba0:	1000071e 	bne	r2,zero,81115bc0 <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81115ba4:	e0ffff03 	ldbu	r3,-4(fp)
81115ba8:	00a04574 	movhi	r2,33045
81115bac:	109f5a04 	addi	r2,r2,32104
81115bb0:	18c00b24 	muli	r3,r3,44
81115bb4:	10c5883a 	add	r2,r2,r3
81115bb8:	10800804 	addi	r2,r2,32
81115bbc:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
81115bc0:	e0ffff03 	ldbu	r3,-4(fp)
81115bc4:	00a04574 	movhi	r2,33045
81115bc8:	109f5a04 	addi	r2,r2,32104
81115bcc:	18c00b24 	muli	r3,r3,44
81115bd0:	10c5883a 	add	r2,r2,r3
81115bd4:	10800804 	addi	r2,r2,32
81115bd8:	10800017 	ldw	r2,0(r2)
81115bdc:	1000521e 	bne	r2,zero,81115d28 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
81115be0:	e0bfff03 	ldbu	r2,-4(fp)
81115be4:	10c00b24 	muli	r3,r2,44
81115be8:	00a04574 	movhi	r2,33045
81115bec:	109f5a04 	addi	r2,r2,32104
81115bf0:	1885883a 	add	r2,r3,r2
81115bf4:	1009883a 	mov	r4,r2
81115bf8:	1120c480 	call	81120c48 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81115bfc:	e0ffff03 	ldbu	r3,-4(fp)
81115c00:	00a04574 	movhi	r2,33045
81115c04:	109f5a04 	addi	r2,r2,32104
81115c08:	18c00b24 	muli	r3,r3,44
81115c0c:	10c5883a 	add	r2,r2,r3
81115c10:	10800804 	addi	r2,r2,32
81115c14:	00c00044 	movi	r3,1
81115c18:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81115c1c:	e0ffff03 	ldbu	r3,-4(fp)
81115c20:	00a04574 	movhi	r2,33045
81115c24:	109f5a04 	addi	r2,r2,32104
81115c28:	18c00b24 	muli	r3,r3,44
81115c2c:	10c5883a 	add	r2,r2,r3
81115c30:	10800984 	addi	r2,r2,38
81115c34:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
81115c38:	e0ffff03 	ldbu	r3,-4(fp)
81115c3c:	00a04574 	movhi	r2,33045
81115c40:	109f5a04 	addi	r2,r2,32104
81115c44:	18c00b24 	muli	r3,r3,44
81115c48:	10c5883a 	add	r2,r2,r3
81115c4c:	10800904 	addi	r2,r2,36
81115c50:	1080000b 	ldhu	r2,0(r2)
81115c54:	10bfffcc 	andi	r2,r2,65535
81115c58:	10800058 	cmpnei	r2,r2,1
81115c5c:	1000021e 	bne	r2,zero,81115c68 <vCheckRetransmission32+0x1c4>
81115c60:	00bffe84 	movi	r2,-6
81115c64:	00000106 	br	81115c6c <vCheckRetransmission32+0x1c8>
81115c68:	00800044 	movi	r2,1
81115c6c:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
81115c70:	e0ffff03 	ldbu	r3,-4(fp)
81115c74:	00a04574 	movhi	r2,33045
81115c78:	109f5a04 	addi	r2,r2,32104
81115c7c:	19000b24 	muli	r4,r3,44
81115c80:	1105883a 	add	r2,r2,r4
81115c84:	10800a04 	addi	r2,r2,40
81115c88:	10800003 	ldbu	r2,0(r2)
81115c8c:	10800044 	addi	r2,r2,1
81115c90:	100b883a 	mov	r5,r2
81115c94:	00a04574 	movhi	r2,33045
81115c98:	109f5a04 	addi	r2,r2,32104
81115c9c:	19000b24 	muli	r4,r3,44
81115ca0:	1105883a 	add	r2,r2,r4
81115ca4:	10800a04 	addi	r2,r2,40
81115ca8:	11400005 	stb	r5,0(r2)
81115cac:	00a04574 	movhi	r2,33045
81115cb0:	109f5a04 	addi	r2,r2,32104
81115cb4:	18c00b24 	muli	r3,r3,44
81115cb8:	10c5883a 	add	r2,r2,r3
81115cbc:	10800a04 	addi	r2,r2,40
81115cc0:	10800003 	ldbu	r2,0(r2)
81115cc4:	10803fcc 	andi	r2,r2,255
81115cc8:	e0ffff43 	ldbu	r3,-3(fp)
81115ccc:	1880162e 	bgeu	r3,r2,81115d28 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
81115cd0:	e0ffff03 	ldbu	r3,-4(fp)
81115cd4:	00a045b4 	movhi	r2,33046
81115cd8:	10b1da04 	addi	r2,r2,-14488
81115cdc:	18c00384 	addi	r3,r3,14
81115ce0:	18c7883a 	add	r3,r3,r3
81115ce4:	18c7883a 	add	r3,r3,r3
81115ce8:	10c5883a 	add	r2,r2,r3
81115cec:	10000015 	stw	zero,0(r2)
                    SemCount32++;
81115cf0:	d0a06783 	ldbu	r2,-32354(gp)
81115cf4:	10800044 	addi	r2,r2,1
81115cf8:	d0a06785 	stb	r2,-32354(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81115cfc:	d0a06e17 	ldw	r2,-32328(gp)
81115d00:	1009883a 	mov	r4,r2
81115d04:	113cea00 	call	8113cea0 <OSSemPost>
81115d08:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81115d0c:	e0bfff83 	ldbu	r2,-2(fp)
81115d10:	10803fcc 	andi	r2,r2,255
81115d14:	10000426 	beq	r2,zero,81115d28 <vCheckRetransmission32+0x284>
                        SemCount32--;
81115d18:	d0a06783 	ldbu	r2,-32354(gp)
81115d1c:	10bfffc4 	addi	r2,r2,-1
81115d20:	d0a06785 	stb	r2,-32354(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81115d24:	1119fdc0 	call	81119fdc <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81115d28:	e0bfff03 	ldbu	r2,-4(fp)
81115d2c:	10800044 	addi	r2,r2,1
81115d30:	e0bfff05 	stb	r2,-4(fp)
81115d34:	e0bfff03 	ldbu	r2,-4(fp)
81115d38:	10800230 	cmpltui	r2,r2,8
81115d3c:	103f6c1e 	bne	r2,zero,81115af0 <__reset+0xfb0f5af0>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
81115d40:	d0a06b17 	ldw	r2,-32340(gp)
81115d44:	1009883a 	mov	r4,r2
81115d48:	113b0b00 	call	8113b0b0 <OSMutexPost>

    return;
81115d4c:	0001883a 	nop
81115d50:	00000106 	br	81115d58 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81115d54:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
81115d58:	e037883a 	mov	sp,fp
81115d5c:	dfc00117 	ldw	ra,4(sp)
81115d60:	df000017 	ldw	fp,0(sp)
81115d64:	dec00204 	addi	sp,sp,8
81115d68:	f800283a 	ret

81115d6c <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
81115d6c:	defff904 	addi	sp,sp,-28
81115d70:	de00012e 	bgeu	sp,et,81115d78 <bResourcesInitRTOS+0xc>
81115d74:	003b68fa 	trap	3
81115d78:	dfc00615 	stw	ra,24(sp)
81115d7c:	df000515 	stw	fp,20(sp)
81115d80:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81115d84:	00800044 	movi	r2,1
81115d88:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81115d8c:	0009883a 	mov	r4,zero
81115d90:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115d94:	d0a05f15 	stw	r2,-32388(gp)
	if (!xSemCommInit) {
81115d98:	d0a05f17 	ldw	r2,-32388(gp)
81115d9c:	1000021e 	bne	r2,zero,81115da8 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
81115da0:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115da4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81115da8:	e0bfff04 	addi	r2,fp,-4
81115dac:	100b883a 	mov	r5,r2
81115db0:	01000444 	movi	r4,17
81115db4:	113a6380 	call	8113a638 <OSMutexCreate>
81115db8:	d0a07315 	stw	r2,-32308(gp)
	if ( err != OS_ERR_NONE ) {
81115dbc:	e0bfff03 	ldbu	r2,-4(fp)
81115dc0:	10803fcc 	andi	r2,r2,255
81115dc4:	10000526 	beq	r2,zero,81115ddc <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81115dc8:	e0bfff03 	ldbu	r2,-4(fp)
81115dcc:	10803fcc 	andi	r2,r2,255
81115dd0:	1009883a 	mov	r4,r2
81115dd4:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115dd8:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81115ddc:	e0bfff04 	addi	r2,fp,-4
81115de0:	100b883a 	mov	r5,r2
81115de4:	01000504 	movi	r4,20
81115de8:	113a6380 	call	8113a638 <OSMutexCreate>
81115dec:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
81115df0:	e0bfff03 	ldbu	r2,-4(fp)
81115df4:	10803fcc 	andi	r2,r2,255
81115df8:	10000526 	beq	r2,zero,81115e10 <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81115dfc:	e0bfff03 	ldbu	r2,-4(fp)
81115e00:	10803fcc 	andi	r2,r2,255
81115e04:	1009883a 	mov	r4,r2
81115e08:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115e0c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
81115e10:	e0bfff04 	addi	r2,fp,-4
81115e14:	100b883a 	mov	r5,r2
81115e18:	01000544 	movi	r4,21
81115e1c:	113a6380 	call	8113a638 <OSMutexCreate>
81115e20:	d0a07015 	stw	r2,-32320(gp)
	if ( err != OS_ERR_NONE ) {
81115e24:	e0bfff03 	ldbu	r2,-4(fp)
81115e28:	10803fcc 	andi	r2,r2,255
81115e2c:	10000526 	beq	r2,zero,81115e44 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
81115e30:	e0bfff03 	ldbu	r2,-4(fp)
81115e34:	10803fcc 	andi	r2,r2,255
81115e38:	1009883a 	mov	r4,r2
81115e3c:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115e40:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
81115e44:	e0bfff04 	addi	r2,fp,-4
81115e48:	100b883a 	mov	r5,r2
81115e4c:	01000584 	movi	r4,22
81115e50:	113a6380 	call	8113a638 <OSMutexCreate>
81115e54:	d0a06b15 	stw	r2,-32340(gp)
	if ( err != OS_ERR_NONE ) {
81115e58:	e0bfff03 	ldbu	r2,-4(fp)
81115e5c:	10803fcc 	andi	r2,r2,255
81115e60:	10000526 	beq	r2,zero,81115e78 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
81115e64:	e0bfff03 	ldbu	r2,-4(fp)
81115e68:	10803fcc 	andi	r2,r2,255
81115e6c:	1009883a 	mov	r4,r2
81115e70:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115e74:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
81115e78:	00800184 	movi	r2,6
81115e7c:	d0a07445 	stb	r2,-32303(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
81115e80:	01000184 	movi	r4,6
81115e84:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115e88:	d0a06215 	stw	r2,-32376(gp)
	if (!xSemCountBuffer128) {
81115e8c:	d0a06217 	ldw	r2,-32376(gp)
81115e90:	1000031e 	bne	r2,zero,81115ea0 <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81115e94:	d0207445 	stb	zero,-32303(gp)
		vFailCreateSemaphoreResources();
81115e98:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115e9c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81115ea0:	00800204 	movi	r2,8
81115ea4:	d0a07405 	stb	r2,-32304(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81115ea8:	01000204 	movi	r4,8
81115eac:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115eb0:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCountBuffer64) {
81115eb4:	d0a05d17 	ldw	r2,-32396(gp)
81115eb8:	1000031e 	bne	r2,zero,81115ec8 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81115ebc:	d0207405 	stb	zero,-32304(gp)
		vFailCreateSemaphoreResources();
81115ec0:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115ec4:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81115ec8:	00800204 	movi	r2,8
81115ecc:	d0a06785 	stb	r2,-32354(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81115ed0:	01000204 	movi	r4,8
81115ed4:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115ed8:	d0a06e15 	stw	r2,-32328(gp)
	if (!xSemCountBuffer32) {
81115edc:	d0a06e17 	ldw	r2,-32328(gp)
81115ee0:	1000031e 	bne	r2,zero,81115ef0 <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81115ee4:	d0206785 	stb	zero,-32354(gp)
		vFailCreateSemaphoreResources();
81115ee8:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115eec:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81115ef0:	e0bfff04 	addi	r2,fp,-4
81115ef4:	100b883a 	mov	r5,r2
81115ef8:	010004c4 	movi	r4,19
81115efc:	113a6380 	call	8113a638 <OSMutexCreate>
81115f00:	d0a06415 	stw	r2,-32368(gp)
	if ( err != OS_ERR_NONE ) {
81115f04:	e0bfff03 	ldbu	r2,-4(fp)
81115f08:	10803fcc 	andi	r2,r2,255
81115f0c:	10000526 	beq	r2,zero,81115f24 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81115f10:	e0bfff03 	ldbu	r2,-4(fp)
81115f14:	10803fcc 	andi	r2,r2,255
81115f18:	1009883a 	mov	r4,r2
81115f1c:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115f20:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81115f24:	e0bfff04 	addi	r2,fp,-4
81115f28:	100b883a 	mov	r5,r2
81115f2c:	010005c4 	movi	r4,23
81115f30:	113a6380 	call	8113a638 <OSMutexCreate>
81115f34:	d0a06a15 	stw	r2,-32344(gp)
	if ( err != OS_ERR_NONE ) {
81115f38:	e0bfff03 	ldbu	r2,-4(fp)
81115f3c:	10803fcc 	andi	r2,r2,255
81115f40:	10000526 	beq	r2,zero,81115f58 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81115f44:	e0bfff03 	ldbu	r2,-4(fp)
81115f48:	10803fcc 	andi	r2,r2,255
81115f4c:	1009883a 	mov	r4,r2
81115f50:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115f54:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81115f58:	0009883a 	mov	r4,zero
81115f5c:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115f60:	d0a06515 	stw	r2,-32364(gp)
	if (!xSemCountReceivedACK) {
81115f64:	d0a06517 	ldw	r2,-32364(gp)
81115f68:	1000021e 	bne	r2,zero,81115f74 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81115f6c:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115f70:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81115f74:	0009883a 	mov	r4,zero
81115f78:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115f7c:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemCountPreParsed) {
81115f80:	d0a06317 	ldw	r2,-32372(gp)
81115f84:	1000021e 	bne	r2,zero,81115f90 <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81115f88:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115f8c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81115f90:	0009883a 	mov	r4,zero
81115f94:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115f98:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountSenderACK) {
81115f9c:	d0a06017 	ldw	r2,-32384(gp)
81115fa0:	1000021e 	bne	r2,zero,81115fac <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81115fa4:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115fa8:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81115fac:	e0bfff04 	addi	r2,fp,-4
81115fb0:	100b883a 	mov	r5,r2
81115fb4:	01000484 	movi	r4,18
81115fb8:	113a6380 	call	8113a638 <OSMutexCreate>
81115fbc:	d0a07115 	stw	r2,-32316(gp)
	if ( err != OS_ERR_NONE ) {
81115fc0:	e0bfff03 	ldbu	r2,-4(fp)
81115fc4:	10803fcc 	andi	r2,r2,255
81115fc8:	10000526 	beq	r2,zero,81115fe0 <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81115fcc:	e0bfff03 	ldbu	r2,-4(fp)
81115fd0:	10803fcc 	andi	r2,r2,255
81115fd4:	1009883a 	mov	r4,r2
81115fd8:	11199c80 	call	811199c8 <vFailCreateMutexSResources>
		bSuccess = FALSE;
81115fdc:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81115fe0:	0009883a 	mov	r4,zero
81115fe4:	113c7f00 	call	8113c7f0 <OSSemCreate>
81115fe8:	d0a06615 	stw	r2,-32360(gp)
	if (!xSemTimeoutChecker) {
81115fec:	d0a06617 	ldw	r2,-32360(gp)
81115ff0:	1000021e 	bne	r2,zero,81115ffc <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81115ff4:	1119a740 	call	81119a74 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81115ff8:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81115ffc:	e0bfff04 	addi	r2,fp,-4
81116000:	d8800215 	stw	r2,8(sp)
81116004:	00a04574 	movhi	r2,33045
81116008:	10b02a04 	addi	r2,r2,-16216
8111600c:	d8800115 	stw	r2,4(sp)
81116010:	d8000015 	stw	zero,0(sp)
81116014:	01e04474 	movhi	r7,33041
81116018:	39def404 	addi	r7,r7,31696
8111601c:	01800084 	movi	r6,2
81116020:	01400104 	movi	r5,4
81116024:	01000284 	movi	r4,10
81116028:	113eebc0 	call	8113eebc <OSTmrCreate>
8111602c:	d0a06c15 	stw	r2,-32336(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81116030:	e0bfff03 	ldbu	r2,-4(fp)
81116034:	10803fcc 	andi	r2,r2,255
81116038:	10000226 	beq	r2,zero,81116044 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
8111603c:	111a6d80 	call	8111a6d8 <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81116040:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81116044:	01400484 	movi	r5,18
81116048:	01204574 	movhi	r4,33045
8111604c:	21129a04 	addi	r4,r4,19048
81116050:	113b7240 	call	8113b724 <OSQCreate>
81116054:	d0a05c15 	stw	r2,-32400(gp)
	if ( xNfeeSchedule == NULL ) {
81116058:	d0a05c17 	ldw	r2,-32400(gp)
8111605c:	1000021e 	bne	r2,zero,81116068 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81116060:	111acbc0 	call	8111acbc <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81116064:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81116068:	01400204 	movi	r5,8
8111606c:	012045b4 	movhi	r4,33046
81116070:	2111ac04 	addi	r4,r4,18096
81116074:	113b7240 	call	8113b724 <OSQCreate>
81116078:	d0a06915 	stw	r2,-32348(gp)
	if ( xFeeQ[0] == NULL ) {
8111607c:	d0a06917 	ldw	r2,-32348(gp)
81116080:	1000031e 	bne	r2,zero,81116090 <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81116084:	0009883a 	mov	r4,zero
81116088:	111ad240 	call	8111ad24 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
8111608c:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
81116090:	01400204 	movi	r5,8
81116094:	012045b4 	movhi	r4,33046
81116098:	2136f204 	addi	r4,r4,-9272
8111609c:	113b7240 	call	8113b724 <OSQCreate>
811160a0:	d0a05b15 	stw	r2,-32404(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
811160a4:	d0a05b17 	ldw	r2,-32404(gp)
811160a8:	1000031e 	bne	r2,zero,811160b8 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
811160ac:	0009883a 	mov	r4,zero
811160b0:	111ad940 	call	8111ad94 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
811160b4:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
811160b8:	01400204 	movi	r5,8
811160bc:	012045b4 	movhi	r4,33046
811160c0:	2131f004 	addi	r4,r4,-14400
811160c4:	113b7240 	call	8113b724 <OSQCreate>
811160c8:	d0a06815 	stw	r2,-32352(gp)
	if ( xMebQ == NULL ) {
811160cc:	d0a06817 	ldw	r2,-32352(gp)
811160d0:	1000031e 	bne	r2,zero,811160e0 <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
811160d4:	01000144 	movi	r4,5
811160d8:	111ad240 	call	8111ad24 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
811160dc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
811160e0:	e0bfff04 	addi	r2,fp,-4
811160e4:	100b883a 	mov	r5,r2
811160e8:	010001c4 	movi	r4,7
811160ec:	113a6380 	call	8113a638 <OSMutexCreate>
811160f0:	d0a07215 	stw	r2,-32312(gp)
	if ( err != OS_ERR_NONE ) {
811160f4:	e0bfff03 	ldbu	r2,-4(fp)
811160f8:	10803fcc 	andi	r2,r2,255
811160fc:	10000526 	beq	r2,zero,81116114 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81116100:	e0bfff03 	ldbu	r2,-4(fp)
81116104:	10803fcc 	andi	r2,r2,255
81116108:	1009883a 	mov	r4,r2
8111610c:	111b1ac0 	call	8111b1ac <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81116110:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81116114:	01400404 	movi	r5,16
81116118:	012045b4 	movhi	r4,33046
8111611c:	2132ca04 	addi	r4,r4,-13528
81116120:	113b7240 	call	8113b724 <OSQCreate>
81116124:	d0a06f15 	stw	r2,-32324(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81116128:	d0a06f17 	ldw	r2,-32324(gp)
8111612c:	1000021e 	bne	r2,zero,81116138 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81116130:	111b30c0 	call	8111b30c <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81116134:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81116138:	01400404 	movi	r5,16
8111613c:	012045b4 	movhi	r4,33046
81116140:	2125b204 	addi	r4,r4,-26936
81116144:	113b7240 	call	8113b724 <OSQCreate>
81116148:	d0a05e15 	stw	r2,-32392(gp)
	if ( xQMaskDataCtrl == NULL ) {
8111614c:	d0a05e17 	ldw	r2,-32392(gp)
81116150:	1000021e 	bne	r2,zero,8111615c <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81116154:	111b3740 	call	8111b374 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81116158:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
8111615c:	e0bfff04 	addi	r2,fp,-4
81116160:	100b883a 	mov	r5,r2
81116164:	01000104 	movi	r4,4
81116168:	113a6380 	call	8113a638 <OSMutexCreate>
8111616c:	1007883a 	mov	r3,r2
81116170:	00a045b4 	movhi	r2,33046
81116174:	10850004 	addi	r2,r2,5120
81116178:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
8111617c:	e0bfff03 	ldbu	r2,-4(fp)
81116180:	10803fcc 	andi	r2,r2,255
81116184:	10000226 	beq	r2,zero,81116190 <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81116188:	1119a280 	call	81119a28 <vFailCreateMutexDMA>
		bSuccess = FALSE;
8111618c:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81116190:	e0bfff04 	addi	r2,fp,-4
81116194:	100b883a 	mov	r5,r2
81116198:	01000184 	movi	r4,6
8111619c:	113a6380 	call	8113a638 <OSMutexCreate>
811161a0:	1007883a 	mov	r3,r2
811161a4:	00a045b4 	movhi	r2,33046
811161a8:	10850004 	addi	r2,r2,5120
811161ac:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
811161b0:	e0bfff03 	ldbu	r2,-4(fp)
811161b4:	10803fcc 	andi	r2,r2,255
811161b8:	10000226 	beq	r2,zero,811161c4 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
811161bc:	1119a280 	call	81119a28 <vFailCreateMutexDMA>
		bSuccess = FALSE;
811161c0:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
811161c4:	e0bffe17 	ldw	r2,-8(fp)
}
811161c8:	e037883a 	mov	sp,fp
811161cc:	dfc00117 	ldw	ra,4(sp)
811161d0:	df000017 	ldw	fp,0(sp)
811161d4:	dec00204 	addi	sp,sp,8
811161d8:	f800283a 	ret

811161dc <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
811161dc:	defffd04 	addi	sp,sp,-12
811161e0:	de00012e 	bgeu	sp,et,811161e8 <vVariablesInitialization+0xc>
811161e4:	003b68fa 	trap	3
811161e8:	dfc00215 	stw	ra,8(sp)
811161ec:	df000115 	stw	fp,4(sp)
811161f0:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
811161f4:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
811161f8:	00800084 	movi	r2,2
811161fc:	d0a0670d 	sth	r2,-32356(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81116200:	01800604 	movi	r6,24
81116204:	000b883a 	mov	r5,zero
81116208:	012045b4 	movhi	r4,33046
8111620c:	2131da04 	addi	r4,r4,-14488
81116210:	11207fc0 	call	811207fc <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81116214:	01800804 	movi	r6,32
81116218:	000b883a 	mov	r5,zero
8111621c:	012045b4 	movhi	r4,33046
81116220:	2131e004 	addi	r4,r4,-14464
81116224:	11207fc0 	call	811207fc <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81116228:	01800804 	movi	r6,32
8111622c:	000b883a 	mov	r5,zero
81116230:	012045b4 	movhi	r4,33046
81116234:	2131e804 	addi	r4,r4,-14432
81116238:	11207fc0 	call	811207fc <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111623c:	e03fff05 	stb	zero,-4(fp)
81116240:	00002806 	br	811162e4 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81116244:	e0bfff03 	ldbu	r2,-4(fp)
81116248:	10c02324 	muli	r3,r2,140
8111624c:	00a045b4 	movhi	r2,33046
81116250:	10b1f804 	addi	r2,r2,-14368
81116254:	1885883a 	add	r2,r3,r2
81116258:	01802004 	movi	r6,128
8111625c:	000b883a 	mov	r5,zero
81116260:	1009883a 	mov	r4,r2
81116264:	11207fc0 	call	811207fc <memset>
		xBuffer128[ucIL].bSent = FALSE;
81116268:	e0ffff03 	ldbu	r3,-4(fp)
8111626c:	00a045b4 	movhi	r2,33046
81116270:	10b1f804 	addi	r2,r2,-14368
81116274:	18c02324 	muli	r3,r3,140
81116278:	10c5883a 	add	r2,r2,r3
8111627c:	10802004 	addi	r2,r2,128
81116280:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81116284:	e0ffff03 	ldbu	r3,-4(fp)
81116288:	00a045b4 	movhi	r2,33046
8111628c:	10b1f804 	addi	r2,r2,-14368
81116290:	18c02324 	muli	r3,r3,140
81116294:	10c5883a 	add	r2,r2,r3
81116298:	10802104 	addi	r2,r2,132
8111629c:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
811162a0:	e0ffff03 	ldbu	r3,-4(fp)
811162a4:	00a045b4 	movhi	r2,33046
811162a8:	10b1f804 	addi	r2,r2,-14368
811162ac:	18c02324 	muli	r3,r3,140
811162b0:	10c5883a 	add	r2,r2,r3
811162b4:	10802184 	addi	r2,r2,134
811162b8:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
811162bc:	e0ffff03 	ldbu	r3,-4(fp)
811162c0:	00a045b4 	movhi	r2,33046
811162c4:	10b1f804 	addi	r2,r2,-14368
811162c8:	18c02324 	muli	r3,r3,140
811162cc:	10c5883a 	add	r2,r2,r3
811162d0:	10802204 	addi	r2,r2,136
811162d4:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
811162d8:	e0bfff03 	ldbu	r2,-4(fp)
811162dc:	10800044 	addi	r2,r2,1
811162e0:	e0bfff05 	stb	r2,-4(fp)
811162e4:	e0bfff03 	ldbu	r2,-4(fp)
811162e8:	108001b0 	cmpltui	r2,r2,6
811162ec:	103fd51e 	bne	r2,zero,81116244 <__reset+0xfb0f6244>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
811162f0:	e03fff05 	stb	zero,-4(fp)
811162f4:	00002806 	br	81116398 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
811162f8:	e0bfff03 	ldbu	r2,-4(fp)
811162fc:	10c01324 	muli	r3,r2,76
81116300:	00a04574 	movhi	r2,33045
81116304:	108d9e04 	addi	r2,r2,13944
81116308:	1885883a 	add	r2,r3,r2
8111630c:	01801004 	movi	r6,64
81116310:	000b883a 	mov	r5,zero
81116314:	1009883a 	mov	r4,r2
81116318:	11207fc0 	call	811207fc <memset>
		xBuffer64[ucIL].bSent = FALSE;
8111631c:	e0ffff03 	ldbu	r3,-4(fp)
81116320:	00a04574 	movhi	r2,33045
81116324:	108d9e04 	addi	r2,r2,13944
81116328:	18c01324 	muli	r3,r3,76
8111632c:	10c5883a 	add	r2,r2,r3
81116330:	10801004 	addi	r2,r2,64
81116334:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81116338:	e0ffff03 	ldbu	r3,-4(fp)
8111633c:	00a04574 	movhi	r2,33045
81116340:	108d9e04 	addi	r2,r2,13944
81116344:	18c01324 	muli	r3,r3,76
81116348:	10c5883a 	add	r2,r2,r3
8111634c:	10801104 	addi	r2,r2,68
81116350:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81116354:	e0ffff03 	ldbu	r3,-4(fp)
81116358:	00a04574 	movhi	r2,33045
8111635c:	108d9e04 	addi	r2,r2,13944
81116360:	18c01324 	muli	r3,r3,76
81116364:	10c5883a 	add	r2,r2,r3
81116368:	10801184 	addi	r2,r2,70
8111636c:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81116370:	e0ffff03 	ldbu	r3,-4(fp)
81116374:	00a04574 	movhi	r2,33045
81116378:	108d9e04 	addi	r2,r2,13944
8111637c:	18c01324 	muli	r3,r3,76
81116380:	10c5883a 	add	r2,r2,r3
81116384:	10801204 	addi	r2,r2,72
81116388:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
8111638c:	e0bfff03 	ldbu	r2,-4(fp)
81116390:	10800044 	addi	r2,r2,1
81116394:	e0bfff05 	stb	r2,-4(fp)
81116398:	e0bfff03 	ldbu	r2,-4(fp)
8111639c:	10800230 	cmpltui	r2,r2,8
811163a0:	103fd51e 	bne	r2,zero,811162f8 <__reset+0xfb0f62f8>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
811163a4:	e03fff05 	stb	zero,-4(fp)
811163a8:	00002806 	br	8111644c <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
811163ac:	e0bfff03 	ldbu	r2,-4(fp)
811163b0:	10c00b24 	muli	r3,r2,44
811163b4:	00a04574 	movhi	r2,33045
811163b8:	109f5a04 	addi	r2,r2,32104
811163bc:	1885883a 	add	r2,r3,r2
811163c0:	01800804 	movi	r6,32
811163c4:	000b883a 	mov	r5,zero
811163c8:	1009883a 	mov	r4,r2
811163cc:	11207fc0 	call	811207fc <memset>
		xBuffer32[ucIL].bSent = FALSE;
811163d0:	e0ffff03 	ldbu	r3,-4(fp)
811163d4:	00a04574 	movhi	r2,33045
811163d8:	109f5a04 	addi	r2,r2,32104
811163dc:	18c00b24 	muli	r3,r3,44
811163e0:	10c5883a 	add	r2,r2,r3
811163e4:	10800804 	addi	r2,r2,32
811163e8:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
811163ec:	e0ffff03 	ldbu	r3,-4(fp)
811163f0:	00a04574 	movhi	r2,33045
811163f4:	109f5a04 	addi	r2,r2,32104
811163f8:	18c00b24 	muli	r3,r3,44
811163fc:	10c5883a 	add	r2,r2,r3
81116400:	10800904 	addi	r2,r2,36
81116404:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81116408:	e0ffff03 	ldbu	r3,-4(fp)
8111640c:	00a04574 	movhi	r2,33045
81116410:	109f5a04 	addi	r2,r2,32104
81116414:	18c00b24 	muli	r3,r3,44
81116418:	10c5883a 	add	r2,r2,r3
8111641c:	10800984 	addi	r2,r2,38
81116420:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81116424:	e0ffff03 	ldbu	r3,-4(fp)
81116428:	00a04574 	movhi	r2,33045
8111642c:	109f5a04 	addi	r2,r2,32104
81116430:	18c00b24 	muli	r3,r3,44
81116434:	10c5883a 	add	r2,r2,r3
81116438:	10800a04 	addi	r2,r2,40
8111643c:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81116440:	e0bfff03 	ldbu	r2,-4(fp)
81116444:	10800044 	addi	r2,r2,1
81116448:	e0bfff05 	stb	r2,-4(fp)
8111644c:	e0bfff03 	ldbu	r2,-4(fp)
81116450:	10800230 	cmpltui	r2,r2,8
81116454:	103fd51e 	bne	r2,zero,811163ac <__reset+0xfb0f63ac>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81116458:	e03fff05 	stb	zero,-4(fp)
8111645c:	00001b06 	br	811164cc <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81116460:	e0ffff03 	ldbu	r3,-4(fp)
81116464:	00a04574 	movhi	r2,33045
81116468:	108e3604 	addi	r2,r2,14552
8111646c:	18c01524 	muli	r3,r3,84
81116470:	10c5883a 	add	r2,r2,r3
81116474:	10800104 	addi	r2,r2,4
81116478:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
8111647c:	e0ffff03 	ldbu	r3,-4(fp)
81116480:	00a04574 	movhi	r2,33045
81116484:	108e3604 	addi	r2,r2,14552
81116488:	18c01524 	muli	r3,r3,84
8111648c:	10c5883a 	add	r2,r2,r3
81116490:	10800484 	addi	r2,r2,18
81116494:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81116498:	e0bfff03 	ldbu	r2,-4(fp)
8111649c:	10801524 	muli	r2,r2,84
811164a0:	10c00504 	addi	r3,r2,20
811164a4:	00a04574 	movhi	r2,33045
811164a8:	108e3604 	addi	r2,r2,14552
811164ac:	1885883a 	add	r2,r3,r2
811164b0:	01801004 	movi	r6,64
811164b4:	000b883a 	mov	r5,zero
811164b8:	1009883a 	mov	r4,r2
811164bc:	11207fc0 	call	811207fc <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
811164c0:	e0bfff03 	ldbu	r2,-4(fp)
811164c4:	10800044 	addi	r2,r2,1
811164c8:	e0bfff05 	stb	r2,-4(fp)
811164cc:	e0bfff03 	ldbu	r2,-4(fp)
811164d0:	10800130 	cmpltui	r2,r2,4
811164d4:	103fe21e 	bne	r2,zero,81116460 <__reset+0xfb0f6460>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
811164d8:	0001883a 	nop
811164dc:	e037883a 	mov	sp,fp
811164e0:	dfc00117 	ldw	ra,4(sp)
811164e4:	df000017 	ldw	fp,0(sp)
811164e8:	dec00204 	addi	sp,sp,8
811164ec:	f800283a 	ret

811164f0 <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
811164f0:	defff704 	addi	sp,sp,-36
811164f4:	de00012e 	bgeu	sp,et,811164fc <main+0xc>
811164f8:	003b68fa 	trap	3
811164fc:	dfc00815 	stw	ra,32(sp)
81116500:	df000715 	stw	fp,28(sp)
81116504:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81116508:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
8111650c:	1136ad40 	call	81136ad4 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
81116510:	01604574 	movhi	r5,33045
81116514:	29702e04 	addi	r5,r5,-16200
81116518:	01204574 	movhi	r4,33045
8111651c:	21302f04 	addi	r4,r4,-16196
81116520:	111f5b40 	call	8111f5b4 <fopen>
81116524:	d0a06115 	stw	r2,-32380(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
81116528:	d0a06117 	ldw	r2,-32380(gp)
8111652c:	100f883a 	mov	r7,r2
81116530:	01800484 	movi	r6,18
81116534:	01400044 	movi	r5,1
81116538:	01204574 	movhi	r4,33045
8111653c:	21303404 	addi	r4,r4,-16176
81116540:	111fc980 	call	8111fc98 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
81116544:	111c2f00 	call	8111c2f0 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
81116548:	111cf480 	call	8111cf48 <bTestSimucamCriticalHW>
8111654c:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81116550:	e0bffe17 	ldw	r2,-8(fp)
81116554:	1000031e 	bne	r2,zero,81116564 <main+0x74>
		vFailTestCriticasParts();
81116558:	1119ac00 	call	81119ac0 <vFailTestCriticasParts>
		return -1;
8111655c:	00bfffc4 	movi	r2,-1
81116560:	00004e06 	br	8111669c <main+0x1ac>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
81116564:	111ca700 	call	8111ca70 <bInitializeSDCard>
81116568:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8111656c:	e0bffe17 	ldw	r2,-8(fp)
81116570:	1000031e 	bne	r2,zero,81116580 <main+0x90>
		vFailTestCriticasParts();
81116574:	1119ac00 	call	81119ac0 <vFailTestCriticasParts>
		return -1;
81116578:	00bfffc4 	movi	r2,-1
8111657c:	00004706 	br	8111669c <main+0x1ac>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
81116580:	1117ff80 	call	81117ff8 <vLoadDefaultETHConf>
81116584:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81116588:	e0bffe17 	ldw	r2,-8(fp)
8111658c:	1000091e 	bne	r2,zero,811165b4 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. \n");
81116590:	d0a06117 	ldw	r2,-32380(gp)
81116594:	100f883a 	mov	r7,r2
81116598:	01801484 	movi	r6,82
8111659c:	01400044 	movi	r5,1
811165a0:	01204574 	movhi	r4,33045
811165a4:	21303904 	addi	r4,r4,-16156
811165a8:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return -1;
811165ac:	00bfffc4 	movi	r2,-1
811165b0:	00003a06 	br	8111669c <main+0x1ac>
	}

	bIniSimucamStatus = vLoadDebugConfs();
811165b4:	1118bb40 	call	81118bb4 <vLoadDebugConfs>
811165b8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811165bc:	e0bffe17 	ldw	r2,-8(fp)
811165c0:	1000091e 	bne	r2,zero,811165e8 <main+0xf8>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load DEBUG configuration from SDCard. Default configuration will be loaded. \n");
811165c4:	d0a06117 	ldw	r2,-32380(gp)
811165c8:	100f883a 	mov	r7,r2
811165cc:	01801504 	movi	r6,84
811165d0:	01400044 	movi	r5,1
811165d4:	01204574 	movhi	r4,33045
811165d8:	21304e04 	addi	r4,r4,-16072
811165dc:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return -1;
811165e0:	00bfffc4 	movi	r2,-1
811165e4:	00002d06 	br	8111669c <main+0x1ac>
	}


	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
811165e8:	11188840 	call	81118884 <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
811165ec:	1115d6c0 	call	81115d6c <bResourcesInitRTOS>
811165f0:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811165f4:	e0bffe17 	ldw	r2,-8(fp)
811165f8:	1000091e 	bne	r2,zero,81116620 <main+0x130>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
811165fc:	d0a06117 	ldw	r2,-32380(gp)
81116600:	100f883a 	mov	r7,r2
81116604:	01800ac4 	movi	r6,43
81116608:	01400044 	movi	r5,1
8111660c:	01204574 	movhi	r4,33045
81116610:	21306404 	addi	r4,r4,-15984
81116614:	111fc980 	call	8111fc98 <fwrite>
		return -1;
81116618:	00bfffc4 	movi	r2,-1
8111661c:	00001f06 	br	8111669c <main+0x1ac>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81116620:	01204574 	movhi	r4,33045
81116624:	211aac04 	addi	r4,r4,27312
81116628:	111c4300 	call	8111c430 <vSimucamStructureInit>

	vVariablesInitialization();
8111662c:	11161dc0 	call	811161dc <vVariablesInitialization>

	bInitSync();
81116630:	111cc240 	call	8111cc24 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
81116634:	01204574 	movhi	r4,33045
81116638:	211aac04 	addi	r4,r4,27312
8111663c:	11166b00 	call	811166b0 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81116640:	d8000415 	stw	zero,16(sp)
81116644:	d8000315 	stw	zero,12(sp)
81116648:	00810004 	movi	r2,1024
8111664c:	d8800215 	stw	r2,8(sp)
81116650:	00a045b4 	movhi	r2,33046
81116654:	10a9d204 	addi	r2,r2,-22712
81116658:	d8800115 	stw	r2,4(sp)
8111665c:	00800044 	movi	r2,1
81116660:	d8800015 	stw	r2,0(sp)
81116664:	01c00044 	movi	r7,1
81116668:	01a045b4 	movhi	r6,33046
8111666c:	31add104 	addi	r6,r6,-18620
81116670:	000b883a 	mov	r5,zero
81116674:	01204474 	movhi	r4,33041
81116678:	21032704 	addi	r4,r4,3228
8111667c:	113d8840 	call	8113d884 <OSTaskCreateExt>
81116680:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
81116684:	e0bfff03 	ldbu	r2,-4(fp)
81116688:	1000021e 	bne	r2,zero,81116694 <main+0x1a4>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
8111668c:	1136e040 	call	81136e04 <OSStart>
81116690:	00000106 	br	81116698 <main+0x1a8>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
81116694:	1119eac0 	call	81119eac <vFailInitialization>
	}
  
	return 0;
81116698:	0005883a 	mov	r2,zero
}
8111669c:	e037883a 	mov	sp,fp
811166a0:	dfc00117 	ldw	ra,4(sp)
811166a4:	df000017 	ldw	fp,0(sp)
811166a8:	dec00204 	addi	sp,sp,8
811166ac:	f800283a 	ret

811166b0 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
811166b0:	defff604 	addi	sp,sp,-40
811166b4:	de00012e 	bgeu	sp,et,811166bc <vFillMemmoryPattern+0xc>
811166b8:	003b68fa 	trap	3
811166bc:	dfc00915 	stw	ra,36(sp)
811166c0:	df000815 	stw	fp,32(sp)
811166c4:	df000804 	addi	fp,sp,32
811166c8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
811166cc:	00800044 	movi	r2,1
811166d0:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
811166d4:	d0a06117 	ldw	r2,-32380(gp)
811166d8:	100f883a 	mov	r7,r2
811166dc:	018009c4 	movi	r6,39
811166e0:	01400044 	movi	r5,1
811166e4:	01204574 	movhi	r4,33045
811166e8:	21306f04 	addi	r4,r4,-15940
811166ec:	111fc980 	call	8111fc98 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811166f0:	e03ffa05 	stb	zero,-24(fp)
811166f4:	00007606 	br	811168d0 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811166f8:	e03ffc85 	stb	zero,-14(fp)
811166fc:	00006706 	br	8111689c <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81116700:	e0bffc83 	ldbu	r2,-14(fp)
81116704:	e0ffff17 	ldw	r3,-4(fp)
81116708:	10809624 	muli	r2,r2,600
8111670c:	1885883a 	add	r2,r3,r2
81116710:	10804304 	addi	r2,r2,268
81116714:	1080000b 	ldhu	r2,0(r2)
81116718:	10ffffcc 	andi	r3,r2,65535
8111671c:	e0bffc83 	ldbu	r2,-14(fp)
81116720:	e13fff17 	ldw	r4,-4(fp)
81116724:	10809624 	muli	r2,r2,600
81116728:	2085883a 	add	r2,r4,r2
8111672c:	10804204 	addi	r2,r2,264
81116730:	1080000b 	ldhu	r2,0(r2)
81116734:	10bfffcc 	andi	r2,r2,65535
81116738:	1885883a 	add	r2,r3,r2
8111673c:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81116740:	e0bffc83 	ldbu	r2,-14(fp)
81116744:	e0ffff17 	ldw	r3,-4(fp)
81116748:	10809624 	muli	r2,r2,600
8111674c:	1885883a 	add	r2,r3,r2
81116750:	10804284 	addi	r2,r2,266
81116754:	1080000b 	ldhu	r2,0(r2)
81116758:	10ffffcc 	andi	r3,r2,65535
8111675c:	e0bffc83 	ldbu	r2,-14(fp)
81116760:	e13fff17 	ldw	r4,-4(fp)
81116764:	10809624 	muli	r2,r2,600
81116768:	2085883a 	add	r2,r4,r2
8111676c:	10804184 	addi	r2,r2,262
81116770:	1080000b 	ldhu	r2,0(r2)
81116774:	10bfffcc 	andi	r2,r2,65535
81116778:	1887883a 	add	r3,r3,r2
8111677c:	e0bffc83 	ldbu	r2,-14(fp)
81116780:	e13fff17 	ldw	r4,-4(fp)
81116784:	10809624 	muli	r2,r2,600
81116788:	2085883a 	add	r2,r4,r2
8111678c:	10804104 	addi	r2,r2,260
81116790:	1080000b 	ldhu	r2,0(r2)
81116794:	10bfffcc 	andi	r2,r2,65535
81116798:	1885883a 	add	r2,r3,r2
8111679c:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811167a0:	e03ffc05 	stb	zero,-16(fp)
811167a4:	00003706 	br	81116884 <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811167a8:	e03ffc45 	stb	zero,-15(fp)
811167ac:	00002606 	br	81116848 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
811167b0:	e0bffc43 	ldbu	r2,-15(fp)
811167b4:	10000b1e 	bne	r2,zero,811167e4 <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
811167b8:	e0bffc83 	ldbu	r2,-14(fp)
811167bc:	e13ffc03 	ldbu	r4,-16(fp)
811167c0:	e0ffff17 	ldw	r3,-4(fp)
811167c4:	21000624 	muli	r4,r4,24
811167c8:	10809624 	muli	r2,r2,600
811167cc:	2085883a 	add	r2,r4,r2
811167d0:	1885883a 	add	r2,r3,r2
811167d4:	10801b04 	addi	r2,r2,108
811167d8:	10800017 	ldw	r2,0(r2)
811167dc:	e0bffb15 	stw	r2,-20(fp)
811167e0:	00000a06 	br	8111680c <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
811167e4:	e0bffc83 	ldbu	r2,-14(fp)
811167e8:	e13ffc03 	ldbu	r4,-16(fp)
811167ec:	e0ffff17 	ldw	r3,-4(fp)
811167f0:	21000624 	muli	r4,r4,24
811167f4:	10809624 	muli	r2,r2,600
811167f8:	2085883a 	add	r2,r4,r2
811167fc:	1885883a 	add	r2,r3,r2
81116800:	10801e04 	addi	r2,r2,120
81116804:	10800017 	ldw	r2,0(r2)
81116808:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
8111680c:	e0fffa03 	ldbu	r3,-24(fp)
81116810:	e13ffc03 	ldbu	r4,-16(fp)
81116814:	e17ffc43 	ldbu	r5,-15(fp)
81116818:	e0bffd17 	ldw	r2,-12(fp)
8111681c:	d8800115 	stw	r2,4(sp)
81116820:	e0bffe17 	ldw	r2,-8(fp)
81116824:	d8800015 	stw	r2,0(sp)
81116828:	280f883a 	mov	r7,r5
8111682c:	200d883a 	mov	r6,r4
81116830:	e17ffb17 	ldw	r5,-20(fp)
81116834:	1809883a 	mov	r4,r3
81116838:	111c7f40 	call	8111c7f4 <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
8111683c:	e0bffc43 	ldbu	r2,-15(fp)
81116840:	10800044 	addi	r2,r2,1
81116844:	e0bffc45 	stb	r2,-15(fp)
81116848:	e0bffc43 	ldbu	r2,-15(fp)
8111684c:	108000b0 	cmpltui	r2,r2,2
81116850:	103fd71e 	bne	r2,zero,811167b0 <__reset+0xfb0f67b0>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81116854:	d0a06117 	ldw	r2,-32380(gp)
81116858:	e0fffc83 	ldbu	r3,-14(fp)
8111685c:	e13ffc03 	ldbu	r4,-16(fp)
81116860:	200f883a 	mov	r7,r4
81116864:	180d883a 	mov	r6,r3
81116868:	01604574 	movhi	r5,33045
8111686c:	29707904 	addi	r5,r5,-15900
81116870:	1009883a 	mov	r4,r2
81116874:	111f5fc0 	call	8111f5fc <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81116878:	e0bffc03 	ldbu	r2,-16(fp)
8111687c:	10800044 	addi	r2,r2,1
81116880:	e0bffc05 	stb	r2,-16(fp)
81116884:	e0bffc03 	ldbu	r2,-16(fp)
81116888:	10800130 	cmpltui	r2,r2,4
8111688c:	103fc61e 	bne	r2,zero,811167a8 <__reset+0xfb0f67a8>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81116890:	e0bffc83 	ldbu	r2,-14(fp)
81116894:	10800044 	addi	r2,r2,1
81116898:	e0bffc85 	stb	r2,-14(fp)
8111689c:	e0fffc83 	ldbu	r3,-14(fp)
811168a0:	e0bffcc3 	ldbu	r2,-13(fp)
811168a4:	18bf9636 	bltu	r3,r2,81116700 <__reset+0xfb0f6700>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
811168a8:	d0a06117 	ldw	r2,-32380(gp)
811168ac:	e0fffa03 	ldbu	r3,-24(fp)
811168b0:	180d883a 	mov	r6,r3
811168b4:	01604574 	movhi	r5,33045
811168b8:	29707e04 	addi	r5,r5,-15880
811168bc:	1009883a 	mov	r4,r2
811168c0:	111f5fc0 	call	8111f5fc <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
811168c4:	e0bffa03 	ldbu	r2,-24(fp)
811168c8:	10800044 	addi	r2,r2,1
811168cc:	e0bffa05 	stb	r2,-24(fp)
811168d0:	e0bffa03 	ldbu	r2,-24(fp)
811168d4:	108000b0 	cmpltui	r2,r2,2
811168d8:	103f871e 	bne	r2,zero,811166f8 <__reset+0xfb0f66f8>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
811168dc:	d0a06117 	ldw	r2,-32380(gp)
811168e0:	100f883a 	mov	r7,r2
811168e4:	01800404 	movi	r6,16
811168e8:	01400044 	movi	r5,1
811168ec:	01204574 	movhi	r4,33045
811168f0:	21308204 	addi	r4,r4,-15864
811168f4:	111fc980 	call	8111fc98 <fwrite>
#endif


}
811168f8:	0001883a 	nop
811168fc:	e037883a 	mov	sp,fp
81116900:	dfc00117 	ldw	ra,4(sp)
81116904:	df000017 	ldw	fp,0(sp)
81116908:	dec00204 	addi	sp,sp,8
8111690c:	f800283a 	ret

81116910 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81116910:	defff604 	addi	sp,sp,-40
81116914:	de00012e 	bgeu	sp,et,8111691c <vPrintMemmoryPattern+0xc>
81116918:	003b68fa 	trap	3
8111691c:	dfc00915 	stw	ra,36(sp)
81116920:	df000815 	stw	fp,32(sp)
81116924:	df000804 	addi	fp,sp,32
81116928:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
8111692c:	00800044 	movi	r2,1
81116930:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
81116934:	d0a06117 	ldw	r2,-32380(gp)
81116938:	100f883a 	mov	r7,r2
8111693c:	018009c4 	movi	r6,39
81116940:	01400044 	movi	r5,1
81116944:	01204574 	movhi	r4,33045
81116948:	21306f04 	addi	r4,r4,-15940
8111694c:	111fc980 	call	8111fc98 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81116950:	e03ffa05 	stb	zero,-24(fp)
81116954:	00007606 	br	81116b30 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81116958:	e03ffc85 	stb	zero,-14(fp)
8111695c:	00006706 	br	81116afc <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81116960:	e0bffc83 	ldbu	r2,-14(fp)
81116964:	e0ffff17 	ldw	r3,-4(fp)
81116968:	10809624 	muli	r2,r2,600
8111696c:	1885883a 	add	r2,r3,r2
81116970:	10804304 	addi	r2,r2,268
81116974:	1080000b 	ldhu	r2,0(r2)
81116978:	10ffffcc 	andi	r3,r2,65535
8111697c:	e0bffc83 	ldbu	r2,-14(fp)
81116980:	e13fff17 	ldw	r4,-4(fp)
81116984:	10809624 	muli	r2,r2,600
81116988:	2085883a 	add	r2,r4,r2
8111698c:	10804204 	addi	r2,r2,264
81116990:	1080000b 	ldhu	r2,0(r2)
81116994:	10bfffcc 	andi	r2,r2,65535
81116998:	1885883a 	add	r2,r3,r2
8111699c:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811169a0:	e0bffc83 	ldbu	r2,-14(fp)
811169a4:	e0ffff17 	ldw	r3,-4(fp)
811169a8:	10809624 	muli	r2,r2,600
811169ac:	1885883a 	add	r2,r3,r2
811169b0:	10804284 	addi	r2,r2,266
811169b4:	1080000b 	ldhu	r2,0(r2)
811169b8:	10ffffcc 	andi	r3,r2,65535
811169bc:	e0bffc83 	ldbu	r2,-14(fp)
811169c0:	e13fff17 	ldw	r4,-4(fp)
811169c4:	10809624 	muli	r2,r2,600
811169c8:	2085883a 	add	r2,r4,r2
811169cc:	10804184 	addi	r2,r2,262
811169d0:	1080000b 	ldhu	r2,0(r2)
811169d4:	10bfffcc 	andi	r2,r2,65535
811169d8:	1887883a 	add	r3,r3,r2
811169dc:	e0bffc83 	ldbu	r2,-14(fp)
811169e0:	e13fff17 	ldw	r4,-4(fp)
811169e4:	10809624 	muli	r2,r2,600
811169e8:	2085883a 	add	r2,r4,r2
811169ec:	10804104 	addi	r2,r2,260
811169f0:	1080000b 	ldhu	r2,0(r2)
811169f4:	10bfffcc 	andi	r2,r2,65535
811169f8:	1885883a 	add	r2,r3,r2
811169fc:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81116a00:	e03ffc05 	stb	zero,-16(fp)
81116a04:	00003706 	br	81116ae4 <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81116a08:	e03ffc45 	stb	zero,-15(fp)
81116a0c:	00002606 	br	81116aa8 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81116a10:	e0bffc43 	ldbu	r2,-15(fp)
81116a14:	10000b1e 	bne	r2,zero,81116a44 <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81116a18:	e0bffc83 	ldbu	r2,-14(fp)
81116a1c:	e13ffc03 	ldbu	r4,-16(fp)
81116a20:	e0ffff17 	ldw	r3,-4(fp)
81116a24:	21000624 	muli	r4,r4,24
81116a28:	10809624 	muli	r2,r2,600
81116a2c:	2085883a 	add	r2,r4,r2
81116a30:	1885883a 	add	r2,r3,r2
81116a34:	10801b04 	addi	r2,r2,108
81116a38:	10800017 	ldw	r2,0(r2)
81116a3c:	e0bffb15 	stw	r2,-20(fp)
81116a40:	00000a06 	br	81116a6c <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
81116a44:	e0bffc83 	ldbu	r2,-14(fp)
81116a48:	e13ffc03 	ldbu	r4,-16(fp)
81116a4c:	e0ffff17 	ldw	r3,-4(fp)
81116a50:	21000624 	muli	r4,r4,24
81116a54:	10809624 	muli	r2,r2,600
81116a58:	2085883a 	add	r2,r4,r2
81116a5c:	1885883a 	add	r2,r3,r2
81116a60:	10801e04 	addi	r2,r2,120
81116a64:	10800017 	ldw	r2,0(r2)
81116a68:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81116a6c:	e0fffa03 	ldbu	r3,-24(fp)
81116a70:	e13ffc03 	ldbu	r4,-16(fp)
81116a74:	e17ffc43 	ldbu	r5,-15(fp)
81116a78:	e0bffe17 	ldw	r2,-8(fp)
81116a7c:	d8800115 	stw	r2,4(sp)
81116a80:	e0bffd17 	ldw	r2,-12(fp)
81116a84:	d8800015 	stw	r2,0(sp)
81116a88:	280f883a 	mov	r7,r5
81116a8c:	200d883a 	mov	r6,r4
81116a90:	e17ffb17 	ldw	r5,-20(fp)
81116a94:	1809883a 	mov	r4,r3
81116a98:	111c7f40 	call	8111c7f4 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81116a9c:	e0bffc43 	ldbu	r2,-15(fp)
81116aa0:	10800044 	addi	r2,r2,1
81116aa4:	e0bffc45 	stb	r2,-15(fp)
81116aa8:	e0bffc43 	ldbu	r2,-15(fp)
81116aac:	108000b0 	cmpltui	r2,r2,2
81116ab0:	103fd71e 	bne	r2,zero,81116a10 <__reset+0xfb0f6a10>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
81116ab4:	d0a06117 	ldw	r2,-32380(gp)
81116ab8:	e0fffc83 	ldbu	r3,-14(fp)
81116abc:	e13ffc03 	ldbu	r4,-16(fp)
81116ac0:	200f883a 	mov	r7,r4
81116ac4:	180d883a 	mov	r6,r3
81116ac8:	01604574 	movhi	r5,33045
81116acc:	29707904 	addi	r5,r5,-15900
81116ad0:	1009883a 	mov	r4,r2
81116ad4:	111f5fc0 	call	8111f5fc <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81116ad8:	e0bffc03 	ldbu	r2,-16(fp)
81116adc:	10800044 	addi	r2,r2,1
81116ae0:	e0bffc05 	stb	r2,-16(fp)
81116ae4:	e0bffc03 	ldbu	r2,-16(fp)
81116ae8:	10800130 	cmpltui	r2,r2,4
81116aec:	103fc61e 	bne	r2,zero,81116a08 <__reset+0xfb0f6a08>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81116af0:	e0bffc83 	ldbu	r2,-14(fp)
81116af4:	10800044 	addi	r2,r2,1
81116af8:	e0bffc85 	stb	r2,-14(fp)
81116afc:	e0fffc83 	ldbu	r3,-14(fp)
81116b00:	e0bffcc3 	ldbu	r2,-13(fp)
81116b04:	18bf9636 	bltu	r3,r2,81116960 <__reset+0xfb0f6960>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81116b08:	d0a06117 	ldw	r2,-32380(gp)
81116b0c:	e0fffa03 	ldbu	r3,-24(fp)
81116b10:	180d883a 	mov	r6,r3
81116b14:	01604574 	movhi	r5,33045
81116b18:	29707e04 	addi	r5,r5,-15880
81116b1c:	1009883a 	mov	r4,r2
81116b20:	111f5fc0 	call	8111f5fc <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81116b24:	e0bffa03 	ldbu	r2,-24(fp)
81116b28:	10800044 	addi	r2,r2,1
81116b2c:	e0bffa05 	stb	r2,-24(fp)
81116b30:	e0bffa03 	ldbu	r2,-24(fp)
81116b34:	108000b0 	cmpltui	r2,r2,2
81116b38:	103f871e 	bne	r2,zero,81116958 <__reset+0xfb0f6958>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81116b3c:	d0a06117 	ldw	r2,-32380(gp)
81116b40:	100f883a 	mov	r7,r2
81116b44:	01800404 	movi	r6,16
81116b48:	01400044 	movi	r5,1
81116b4c:	01204574 	movhi	r4,33045
81116b50:	21308204 	addi	r4,r4,-15864
81116b54:	111fc980 	call	8111fc98 <fwrite>
#endif


}
81116b58:	0001883a 	nop
81116b5c:	e037883a 	mov	sp,fp
81116b60:	dfc00117 	ldw	ra,4(sp)
81116b64:	df000017 	ldw	fp,0(sp)
81116b68:	dec00204 	addi	sp,sp,8
81116b6c:	f800283a 	ret

81116b70 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
81116b70:	defffe04 	addi	sp,sp,-8
81116b74:	de00012e 	bgeu	sp,et,81116b7c <vCCDLoadDefaultValues+0xc>
81116b78:	003b68fa 	trap	3
81116b7c:	df000115 	stw	fp,4(sp)
81116b80:	df000104 	addi	fp,sp,4
81116b84:	e13fff15 	stw	r4,-4(fp)
	ccdDef->usiHalfWidth = 2255;
	ccdDef->usiSOverscanN = 15;
	ccdDef->usiSPrescanN = 25;
*/

	ccdDef->usiHeight = xDefaults.usiRows;
81116b88:	00a045b4 	movhi	r2,33046
81116b8c:	1091bc04 	addi	r2,r2,18160
81116b90:	10c0060b 	ldhu	r3,24(r2)
81116b94:	e0bfff17 	ldw	r2,-4(fp)
81116b98:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = xDefaults.usiOLN;
81116b9c:	00a045b4 	movhi	r2,33046
81116ba0:	1091bc04 	addi	r2,r2,18160
81116ba4:	10c0050b 	ldhu	r3,20(r2)
81116ba8:	e0bfff17 	ldw	r2,-4(fp)
81116bac:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = xDefaults.usiCols;
81116bb0:	00a045b4 	movhi	r2,33046
81116bb4:	1091bc04 	addi	r2,r2,18160
81116bb8:	10c0058b 	ldhu	r3,22(r2)
81116bbc:	e0bfff17 	ldw	r2,-4(fp)
81116bc0:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = xDefaults.usiOverScanSerial;
81116bc4:	00a045b4 	movhi	r2,33046
81116bc8:	1091bc04 	addi	r2,r2,18160
81116bcc:	10c0040b 	ldhu	r3,16(r2)
81116bd0:	e0bfff17 	ldw	r2,-4(fp)
81116bd4:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = xDefaults.usiPreScanSerial;
81116bd8:	00a045b4 	movhi	r2,33046
81116bdc:	1091bc04 	addi	r2,r2,18160
81116be0:	10c0048b 	ldhu	r3,18(r2)
81116be4:	e0bfff17 	ldw	r2,-4(fp)
81116be8:	10c0000d 	sth	r3,0(r2)

}
81116bec:	0001883a 	nop
81116bf0:	e037883a 	mov	sp,fp
81116bf4:	df000017 	ldw	fp,0(sp)
81116bf8:	dec00104 	addi	sp,sp,4
81116bfc:	f800283a 	ret

81116c00 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81116c00:	defff904 	addi	sp,sp,-28
81116c04:	de00012e 	bgeu	sp,et,81116c0c <vCCDChangeValues+0xc>
81116c08:	003b68fa 	trap	3
81116c0c:	df000615 	stw	fp,24(sp)
81116c10:	df000604 	addi	fp,sp,24
81116c14:	e13ffa15 	stw	r4,-24(fp)
81116c18:	2811883a 	mov	r8,r5
81116c1c:	300b883a 	mov	r5,r6
81116c20:	3809883a 	mov	r4,r7
81116c24:	e0c00117 	ldw	r3,4(fp)
81116c28:	e0800217 	ldw	r2,8(fp)
81116c2c:	e23ffb0d 	sth	r8,-20(fp)
81116c30:	e17ffc0d 	sth	r5,-16(fp)
81116c34:	e13ffd0d 	sth	r4,-12(fp)
81116c38:	e0fffe0d 	sth	r3,-8(fp)
81116c3c:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81116c40:	e0bffa17 	ldw	r2,-24(fp)
81116c44:	e0fffb0b 	ldhu	r3,-20(fp)
81116c48:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
81116c4c:	e0bffa17 	ldw	r2,-24(fp)
81116c50:	e0fffc0b 	ldhu	r3,-16(fp)
81116c54:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81116c58:	e0bffa17 	ldw	r2,-24(fp)
81116c5c:	e0fffd0b 	ldhu	r3,-12(fp)
81116c60:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81116c64:	e0bffa17 	ldw	r2,-24(fp)
81116c68:	e0fffe0b 	ldhu	r3,-8(fp)
81116c6c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81116c70:	e0bffa17 	ldw	r2,-24(fp)
81116c74:	e0ffff0b 	ldhu	r3,-4(fp)
81116c78:	10c0000d 	sth	r3,0(r2)
}
81116c7c:	0001883a 	nop
81116c80:	e037883a 	mov	sp,fp
81116c84:	df000017 	ldw	fp,0(sp)
81116c88:	dec00104 	addi	sp,sp,4
81116c8c:	f800283a 	ret

81116c90 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
81116c90:	defff904 	addi	sp,sp,-28
81116c94:	de00012e 	bgeu	sp,et,81116c9c <bSendUART128v2+0xc>
81116c98:	003b68fa 	trap	3
81116c9c:	dfc00615 	stw	ra,24(sp)
81116ca0:	df000515 	stw	fp,20(sp)
81116ca4:	df000504 	addi	fp,sp,20
81116ca8:	e13ffe15 	stw	r4,-8(fp)
81116cac:	2805883a 	mov	r2,r5
81116cb0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
81116cb4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81116cb8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81116cbc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81116cc0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81116cc4:	d0a06217 	ldw	r2,-32376(gp)
81116cc8:	e0fffd04 	addi	r3,fp,-12
81116ccc:	180d883a 	mov	r6,r3
81116cd0:	01400504 	movi	r5,20
81116cd4:	1009883a 	mov	r4,r2
81116cd8:	113cb180 	call	8113cb18 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81116cdc:	e0bffd03 	ldbu	r2,-12(fp)
81116ce0:	10803fcc 	andi	r2,r2,255
81116ce4:	10000326 	beq	r2,zero,81116cf4 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81116ce8:	111a1140 	call	8111a114 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
81116cec:	e0bffc17 	ldw	r2,-16(fp)
81116cf0:	00009e06 	br	81116f6c <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81116cf4:	d0a06d17 	ldw	r2,-32332(gp)
81116cf8:	e0fffd04 	addi	r3,fp,-12
81116cfc:	180d883a 	mov	r6,r3
81116d00:	01400104 	movi	r5,4
81116d04:	1009883a 	mov	r4,r2
81116d08:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116d0c:	e0bffd03 	ldbu	r2,-12(fp)
81116d10:	10803fcc 	andi	r2,r2,255
81116d14:	10001126 	beq	r2,zero,81116d5c <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81116d18:	d0a06117 	ldw	r2,-32380(gp)
81116d1c:	100f883a 	mov	r7,r2
81116d20:	01801484 	movi	r6,82
81116d24:	01400044 	movi	r5,1
81116d28:	01204574 	movhi	r4,33045
81116d2c:	21308704 	addi	r4,r4,-15844
81116d30:	111fc980 	call	8111fc98 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81116d34:	d0a06217 	ldw	r2,-32376(gp)
81116d38:	1009883a 	mov	r4,r2
81116d3c:	113cea00 	call	8113cea0 <OSSemPost>
81116d40:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81116d44:	e0bffd03 	ldbu	r2,-12(fp)
81116d48:	10803fcc 	andi	r2,r2,255
81116d4c:	10000126 	beq	r2,zero,81116d54 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81116d50:	111a0ac0 	call	8111a0ac <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81116d54:	e0bffc17 	ldw	r2,-16(fp)
81116d58:	00008406 	br	81116f6c <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81116d5c:	e03ffb05 	stb	zero,-20(fp)
81116d60:	00004306 	br	81116e70 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81116d64:	e0fffb03 	ldbu	r3,-20(fp)
81116d68:	00a045b4 	movhi	r2,33046
81116d6c:	10b1da04 	addi	r2,r2,-14488
81116d70:	18c7883a 	add	r3,r3,r3
81116d74:	18c7883a 	add	r3,r3,r3
81116d78:	10c5883a 	add	r2,r2,r3
81116d7c:	10800017 	ldw	r2,0(r2)
81116d80:	1000381e 	bne	r2,zero,81116e64 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
81116d84:	e0bffb03 	ldbu	r2,-20(fp)
81116d88:	10c02324 	muli	r3,r2,140
81116d8c:	00a045b4 	movhi	r2,33046
81116d90:	10b1f804 	addi	r2,r2,-14368
81116d94:	1885883a 	add	r2,r3,r2
81116d98:	01802004 	movi	r6,128
81116d9c:	000b883a 	mov	r5,zero
81116da0:	1009883a 	mov	r4,r2
81116da4:	11207fc0 	call	811207fc <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
81116da8:	e0bffb03 	ldbu	r2,-20(fp)
81116dac:	10c02324 	muli	r3,r2,140
81116db0:	00a045b4 	movhi	r2,33046
81116db4:	10b1f804 	addi	r2,r2,-14368
81116db8:	1885883a 	add	r2,r3,r2
81116dbc:	01801fc4 	movi	r6,127
81116dc0:	e17ffe17 	ldw	r5,-8(fp)
81116dc4:	1009883a 	mov	r4,r2
81116dc8:	11206ac0 	call	811206ac <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
81116dcc:	e13ffb03 	ldbu	r4,-20(fp)
81116dd0:	e0ffff0b 	ldhu	r3,-4(fp)
81116dd4:	00a045b4 	movhi	r2,33046
81116dd8:	10b1f804 	addi	r2,r2,-14368
81116ddc:	21002324 	muli	r4,r4,140
81116de0:	1105883a 	add	r2,r2,r4
81116de4:	10802104 	addi	r2,r2,132
81116de8:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
81116dec:	e0fffb03 	ldbu	r3,-20(fp)
81116df0:	00a045b4 	movhi	r2,33046
81116df4:	10b1f804 	addi	r2,r2,-14368
81116df8:	18c02324 	muli	r3,r3,140
81116dfc:	10c5883a 	add	r2,r2,r3
81116e00:	10802204 	addi	r2,r2,136
81116e04:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81116e08:	e0fffb03 	ldbu	r3,-20(fp)
81116e0c:	00a045b4 	movhi	r2,33046
81116e10:	10b1f804 	addi	r2,r2,-14368
81116e14:	18c02324 	muli	r3,r3,140
81116e18:	10c5883a 	add	r2,r2,r3
81116e1c:	10802184 	addi	r2,r2,134
81116e20:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81116e24:	e0fffb03 	ldbu	r3,-20(fp)
81116e28:	00a045b4 	movhi	r2,33046
81116e2c:	10b1f804 	addi	r2,r2,-14368
81116e30:	18c02324 	muli	r3,r3,140
81116e34:	10c5883a 	add	r2,r2,r3
81116e38:	10802004 	addi	r2,r2,128
81116e3c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81116e40:	e0fffb03 	ldbu	r3,-20(fp)
81116e44:	00a045b4 	movhi	r2,33046
81116e48:	10b1da04 	addi	r2,r2,-14488
81116e4c:	18c7883a 	add	r3,r3,r3
81116e50:	18c7883a 	add	r3,r3,r3
81116e54:	10c5883a 	add	r2,r2,r3
81116e58:	00c00044 	movi	r3,1
81116e5c:	10c00015 	stw	r3,0(r2)
			break;
81116e60:	00000606 	br	81116e7c <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81116e64:	e0bffb03 	ldbu	r2,-20(fp)
81116e68:	10800044 	addi	r2,r2,1
81116e6c:	e0bffb05 	stb	r2,-20(fp)
81116e70:	e0bffb03 	ldbu	r2,-20(fp)
81116e74:	108001b0 	cmpltui	r2,r2,6
81116e78:	103fba1e 	bne	r2,zero,81116d64 <__reset+0xfb0f6d64>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
81116e7c:	e0bffb03 	ldbu	r2,-20(fp)
81116e80:	108001b0 	cmpltui	r2,r2,6
81116e84:	1000091e 	bne	r2,zero,81116eac <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81116e88:	d0a06217 	ldw	r2,-32376(gp)
81116e8c:	1009883a 	mov	r4,r2
81116e90:	113cea00 	call	8113cea0 <OSSemPost>
81116e94:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
81116e98:	d0a06d17 	ldw	r2,-32332(gp)
81116e9c:	1009883a 	mov	r4,r2
81116ea0:	113b0b00 	call	8113b0b0 <OSMutexPost>
		return bSuccessL;
81116ea4:	e0bffc17 	ldw	r2,-16(fp)
81116ea8:	00003006 	br	81116f6c <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
81116eac:	00800044 	movi	r2,1
81116eb0:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
81116eb4:	d0a07443 	ldbu	r2,-32303(gp)
81116eb8:	10bfffc4 	addi	r2,r2,-1
81116ebc:	d0a07445 	stb	r2,-32303(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81116ec0:	d0a07317 	ldw	r2,-32308(gp)
81116ec4:	e0fffd04 	addi	r3,fp,-12
81116ec8:	180d883a 	mov	r6,r3
81116ecc:	01400084 	movi	r5,2
81116ed0:	1009883a 	mov	r4,r2
81116ed4:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116ed8:	e0bffd03 	ldbu	r2,-12(fp)
81116edc:	10803fcc 	andi	r2,r2,255
81116ee0:	10000c26 	beq	r2,zero,81116f14 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81116ee4:	d0a06117 	ldw	r2,-32380(gp)
81116ee8:	100f883a 	mov	r7,r2
81116eec:	01801c04 	movi	r6,112
81116ef0:	01400044 	movi	r5,1
81116ef4:	01204574 	movhi	r4,33045
81116ef8:	21309c04 	addi	r4,r4,-15760
81116efc:	111fc980 	call	8111fc98 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81116f00:	d0a06d17 	ldw	r2,-32332(gp)
81116f04:	1009883a 	mov	r4,r2
81116f08:	113b0b00 	call	8113b0b0 <OSMutexPost>
		return bSuccessL;
81116f0c:	e0bffc17 	ldw	r2,-16(fp)
81116f10:	00001606 	br	81116f6c <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81116f14:	e0bffb03 	ldbu	r2,-20(fp)
81116f18:	10c02324 	muli	r3,r2,140
81116f1c:	00a045b4 	movhi	r2,33046
81116f20:	10b1f804 	addi	r2,r2,-14368
81116f24:	1885883a 	add	r2,r3,r2
81116f28:	1009883a 	mov	r4,r2
81116f2c:	1120c480 	call	81120c48 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81116f30:	e0fffb03 	ldbu	r3,-20(fp)
81116f34:	00a045b4 	movhi	r2,33046
81116f38:	10b1f804 	addi	r2,r2,-14368
81116f3c:	18c02324 	muli	r3,r3,140
81116f40:	10c5883a 	add	r2,r2,r3
81116f44:	10802004 	addi	r2,r2,128
81116f48:	00c00044 	movi	r3,1
81116f4c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81116f50:	d0a07317 	ldw	r2,-32308(gp)
81116f54:	1009883a 	mov	r4,r2
81116f58:	113b0b00 	call	8113b0b0 <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81116f5c:	d0a06d17 	ldw	r2,-32332(gp)
81116f60:	1009883a 	mov	r4,r2
81116f64:	113b0b00 	call	8113b0b0 <OSMutexPost>

	return bSuccessL;
81116f68:	e0bffc17 	ldw	r2,-16(fp)
}
81116f6c:	e037883a 	mov	sp,fp
81116f70:	dfc00117 	ldw	ra,4(sp)
81116f74:	df000017 	ldw	fp,0(sp)
81116f78:	dec00204 	addi	sp,sp,8
81116f7c:	f800283a 	ret

81116f80 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81116f80:	defff904 	addi	sp,sp,-28
81116f84:	de00012e 	bgeu	sp,et,81116f8c <bSendUART64v2+0xc>
81116f88:	003b68fa 	trap	3
81116f8c:	dfc00615 	stw	ra,24(sp)
81116f90:	df000515 	stw	fp,20(sp)
81116f94:	df000504 	addi	fp,sp,20
81116f98:	e13ffe15 	stw	r4,-8(fp)
81116f9c:	2805883a 	mov	r2,r5
81116fa0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81116fa4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81116fa8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81116fac:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81116fb0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81116fb4:	d0a05d17 	ldw	r2,-32396(gp)
81116fb8:	e0fffd04 	addi	r3,fp,-12
81116fbc:	180d883a 	mov	r6,r3
81116fc0:	01400504 	movi	r5,20
81116fc4:	1009883a 	mov	r4,r2
81116fc8:	113cb180 	call	8113cb18 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81116fcc:	e0bffd03 	ldbu	r2,-12(fp)
81116fd0:	10803fcc 	andi	r2,r2,255
81116fd4:	10000326 	beq	r2,zero,81116fe4 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81116fd8:	111a17c0 	call	8111a17c <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81116fdc:	e0bffc17 	ldw	r2,-16(fp)
81116fe0:	0000a006 	br	81117264 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81116fe4:	d0a07017 	ldw	r2,-32320(gp)
81116fe8:	e0fffd04 	addi	r3,fp,-12
81116fec:	180d883a 	mov	r6,r3
81116ff0:	01400104 	movi	r5,4
81116ff4:	1009883a 	mov	r4,r2
81116ff8:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81116ffc:	e0bffd03 	ldbu	r2,-12(fp)
81117000:	10803fcc 	andi	r2,r2,255
81117004:	10001126 	beq	r2,zero,8111704c <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81117008:	d0a06117 	ldw	r2,-32380(gp)
8111700c:	100f883a 	mov	r7,r2
81117010:	018013c4 	movi	r6,79
81117014:	01400044 	movi	r5,1
81117018:	01204574 	movhi	r4,33045
8111701c:	2130b904 	addi	r4,r4,-15644
81117020:	111fc980 	call	8111fc98 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81117024:	d0a05d17 	ldw	r2,-32396(gp)
81117028:	1009883a 	mov	r4,r2
8111702c:	113cea00 	call	8113cea0 <OSSemPost>
81117030:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81117034:	e0bffd03 	ldbu	r2,-12(fp)
81117038:	10803fcc 	andi	r2,r2,255
8111703c:	10000126 	beq	r2,zero,81117044 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81117040:	111a0440 	call	8111a044 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81117044:	e0bffc17 	ldw	r2,-16(fp)
81117048:	00008606 	br	81117264 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111704c:	e03ffb05 	stb	zero,-20(fp)
81117050:	00004506 	br	81117168 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81117054:	e0fffb03 	ldbu	r3,-20(fp)
81117058:	00a045b4 	movhi	r2,33046
8111705c:	10b1da04 	addi	r2,r2,-14488
81117060:	18c00184 	addi	r3,r3,6
81117064:	18c7883a 	add	r3,r3,r3
81117068:	18c7883a 	add	r3,r3,r3
8111706c:	10c5883a 	add	r2,r2,r3
81117070:	10800017 	ldw	r2,0(r2)
81117074:	1000391e 	bne	r2,zero,8111715c <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81117078:	e0bffb03 	ldbu	r2,-20(fp)
8111707c:	10c01324 	muli	r3,r2,76
81117080:	00a04574 	movhi	r2,33045
81117084:	108d9e04 	addi	r2,r2,13944
81117088:	1885883a 	add	r2,r3,r2
8111708c:	01801004 	movi	r6,64
81117090:	000b883a 	mov	r5,zero
81117094:	1009883a 	mov	r4,r2
81117098:	11207fc0 	call	811207fc <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
8111709c:	e0bffb03 	ldbu	r2,-20(fp)
811170a0:	10c01324 	muli	r3,r2,76
811170a4:	00a04574 	movhi	r2,33045
811170a8:	108d9e04 	addi	r2,r2,13944
811170ac:	1885883a 	add	r2,r3,r2
811170b0:	01800fc4 	movi	r6,63
811170b4:	e17ffe17 	ldw	r5,-8(fp)
811170b8:	1009883a 	mov	r4,r2
811170bc:	11206ac0 	call	811206ac <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
811170c0:	e13ffb03 	ldbu	r4,-20(fp)
811170c4:	e0ffff0b 	ldhu	r3,-4(fp)
811170c8:	00a04574 	movhi	r2,33045
811170cc:	108d9e04 	addi	r2,r2,13944
811170d0:	21001324 	muli	r4,r4,76
811170d4:	1105883a 	add	r2,r2,r4
811170d8:	10801104 	addi	r2,r2,68
811170dc:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
811170e0:	e0fffb03 	ldbu	r3,-20(fp)
811170e4:	00a04574 	movhi	r2,33045
811170e8:	108d9e04 	addi	r2,r2,13944
811170ec:	18c01324 	muli	r3,r3,76
811170f0:	10c5883a 	add	r2,r2,r3
811170f4:	10801204 	addi	r2,r2,72
811170f8:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
811170fc:	e0fffb03 	ldbu	r3,-20(fp)
81117100:	00a04574 	movhi	r2,33045
81117104:	108d9e04 	addi	r2,r2,13944
81117108:	18c01324 	muli	r3,r3,76
8111710c:	10c5883a 	add	r2,r2,r3
81117110:	10801184 	addi	r2,r2,70
81117114:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81117118:	e0fffb03 	ldbu	r3,-20(fp)
8111711c:	00a04574 	movhi	r2,33045
81117120:	108d9e04 	addi	r2,r2,13944
81117124:	18c01324 	muli	r3,r3,76
81117128:	10c5883a 	add	r2,r2,r3
8111712c:	10801004 	addi	r2,r2,64
81117130:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81117134:	e0fffb03 	ldbu	r3,-20(fp)
81117138:	00a045b4 	movhi	r2,33046
8111713c:	10b1da04 	addi	r2,r2,-14488
81117140:	18c00184 	addi	r3,r3,6
81117144:	18c7883a 	add	r3,r3,r3
81117148:	18c7883a 	add	r3,r3,r3
8111714c:	10c5883a 	add	r2,r2,r3
81117150:	00c00044 	movi	r3,1
81117154:	10c00015 	stw	r3,0(r2)
			break;
81117158:	00000606 	br	81117174 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
8111715c:	e0bffb03 	ldbu	r2,-20(fp)
81117160:	10800044 	addi	r2,r2,1
81117164:	e0bffb05 	stb	r2,-20(fp)
81117168:	e0bffb03 	ldbu	r2,-20(fp)
8111716c:	10800230 	cmpltui	r2,r2,8
81117170:	103fb81e 	bne	r2,zero,81117054 <__reset+0xfb0f7054>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81117174:	e0bffb03 	ldbu	r2,-20(fp)
81117178:	10800230 	cmpltui	r2,r2,8
8111717c:	1000091e 	bne	r2,zero,811171a4 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81117180:	d0a05d17 	ldw	r2,-32396(gp)
81117184:	1009883a 	mov	r4,r2
81117188:	113cea00 	call	8113cea0 <OSSemPost>
8111718c:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81117190:	d0a07017 	ldw	r2,-32320(gp)
81117194:	1009883a 	mov	r4,r2
81117198:	113b0b00 	call	8113b0b0 <OSMutexPost>
		return bSuccessL;
8111719c:	e0bffc17 	ldw	r2,-16(fp)
811171a0:	00003006 	br	81117264 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
811171a4:	00800044 	movi	r2,1
811171a8:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
811171ac:	d0a07403 	ldbu	r2,-32304(gp)
811171b0:	10bfffc4 	addi	r2,r2,-1
811171b4:	d0a07405 	stb	r2,-32304(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811171b8:	d0a07317 	ldw	r2,-32308(gp)
811171bc:	e0fffd04 	addi	r3,fp,-12
811171c0:	180d883a 	mov	r6,r3
811171c4:	01400084 	movi	r5,2
811171c8:	1009883a 	mov	r4,r2
811171cc:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811171d0:	e0bffd03 	ldbu	r2,-12(fp)
811171d4:	10803fcc 	andi	r2,r2,255
811171d8:	10000c26 	beq	r2,zero,8111720c <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
811171dc:	d0a06117 	ldw	r2,-32380(gp)
811171e0:	100f883a 	mov	r7,r2
811171e4:	01801bc4 	movi	r6,111
811171e8:	01400044 	movi	r5,1
811171ec:	01204574 	movhi	r4,33045
811171f0:	2130cd04 	addi	r4,r4,-15564
811171f4:	111fc980 	call	8111fc98 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
811171f8:	d0a07017 	ldw	r2,-32320(gp)
811171fc:	1009883a 	mov	r4,r2
81117200:	113b0b00 	call	8113b0b0 <OSMutexPost>
		return bSuccessL;
81117204:	e0bffc17 	ldw	r2,-16(fp)
81117208:	00001606 	br	81117264 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
8111720c:	e0bffb03 	ldbu	r2,-20(fp)
81117210:	10c01324 	muli	r3,r2,76
81117214:	00a04574 	movhi	r2,33045
81117218:	108d9e04 	addi	r2,r2,13944
8111721c:	1885883a 	add	r2,r3,r2
81117220:	1009883a 	mov	r4,r2
81117224:	1120c480 	call	81120c48 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81117228:	e0fffb03 	ldbu	r3,-20(fp)
8111722c:	00a04574 	movhi	r2,33045
81117230:	108d9e04 	addi	r2,r2,13944
81117234:	18c01324 	muli	r3,r3,76
81117238:	10c5883a 	add	r2,r2,r3
8111723c:	10801004 	addi	r2,r2,64
81117240:	00c00044 	movi	r3,1
81117244:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81117248:	d0a07317 	ldw	r2,-32308(gp)
8111724c:	1009883a 	mov	r4,r2
81117250:	113b0b00 	call	8113b0b0 <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81117254:	d0a07017 	ldw	r2,-32320(gp)
81117258:	1009883a 	mov	r4,r2
8111725c:	113b0b00 	call	8113b0b0 <OSMutexPost>

	return bSuccessL;
81117260:	e0bffc17 	ldw	r2,-16(fp)
}
81117264:	e037883a 	mov	sp,fp
81117268:	dfc00117 	ldw	ra,4(sp)
8111726c:	df000017 	ldw	fp,0(sp)
81117270:	dec00204 	addi	sp,sp,8
81117274:	f800283a 	ret

81117278 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81117278:	defff904 	addi	sp,sp,-28
8111727c:	de00012e 	bgeu	sp,et,81117284 <bSendUART32v2+0xc>
81117280:	003b68fa 	trap	3
81117284:	dfc00615 	stw	ra,24(sp)
81117288:	df000515 	stw	fp,20(sp)
8111728c:	df000504 	addi	fp,sp,20
81117290:	e13ffe15 	stw	r4,-8(fp)
81117294:	2805883a 	mov	r2,r5
81117298:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
8111729c:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811172a0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811172a4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811172a8:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811172ac:	d0a06e17 	ldw	r2,-32328(gp)
811172b0:	e0fffd04 	addi	r3,fp,-12
811172b4:	180d883a 	mov	r6,r3
811172b8:	01400504 	movi	r5,20
811172bc:	1009883a 	mov	r4,r2
811172c0:	113cb180 	call	8113cb18 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811172c4:	e0bffd03 	ldbu	r2,-12(fp)
811172c8:	10803fcc 	andi	r2,r2,255
811172cc:	10000326 	beq	r2,zero,811172dc <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811172d0:	111a1e40 	call	8111a1e4 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
811172d4:	e0bffc17 	ldw	r2,-16(fp)
811172d8:	0000a006 	br	8111755c <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
811172dc:	d0a06b17 	ldw	r2,-32340(gp)
811172e0:	e0fffd04 	addi	r3,fp,-12
811172e4:	180d883a 	mov	r6,r3
811172e8:	01400104 	movi	r5,4
811172ec:	1009883a 	mov	r4,r2
811172f0:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811172f4:	e0bffd03 	ldbu	r2,-12(fp)
811172f8:	10803fcc 	andi	r2,r2,255
811172fc:	10001126 	beq	r2,zero,81117344 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81117300:	d0a06117 	ldw	r2,-32380(gp)
81117304:	100f883a 	mov	r7,r2
81117308:	018013c4 	movi	r6,79
8111730c:	01400044 	movi	r5,1
81117310:	01204574 	movhi	r4,33045
81117314:	2130e904 	addi	r4,r4,-15452
81117318:	111fc980 	call	8111fc98 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
8111731c:	d0a06e17 	ldw	r2,-32328(gp)
81117320:	1009883a 	mov	r4,r2
81117324:	113cea00 	call	8113cea0 <OSSemPost>
81117328:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
8111732c:	e0bffd03 	ldbu	r2,-12(fp)
81117330:	10803fcc 	andi	r2,r2,255
81117334:	10000126 	beq	r2,zero,8111733c <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81117338:	1119fdc0 	call	81119fdc <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
8111733c:	e0bffc17 	ldw	r2,-16(fp)
81117340:	00008606 	br	8111755c <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81117344:	e03ffb05 	stb	zero,-20(fp)
81117348:	00004506 	br	81117460 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
8111734c:	e0fffb03 	ldbu	r3,-20(fp)
81117350:	00a045b4 	movhi	r2,33046
81117354:	10b1da04 	addi	r2,r2,-14488
81117358:	18c00384 	addi	r3,r3,14
8111735c:	18c7883a 	add	r3,r3,r3
81117360:	18c7883a 	add	r3,r3,r3
81117364:	10c5883a 	add	r2,r2,r3
81117368:	10800017 	ldw	r2,0(r2)
8111736c:	1000391e 	bne	r2,zero,81117454 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81117370:	e0bffb03 	ldbu	r2,-20(fp)
81117374:	10c00b24 	muli	r3,r2,44
81117378:	00a04574 	movhi	r2,33045
8111737c:	109f5a04 	addi	r2,r2,32104
81117380:	1885883a 	add	r2,r3,r2
81117384:	01800804 	movi	r6,32
81117388:	000b883a 	mov	r5,zero
8111738c:	1009883a 	mov	r4,r2
81117390:	11207fc0 	call	811207fc <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81117394:	e0bffb03 	ldbu	r2,-20(fp)
81117398:	10c00b24 	muli	r3,r2,44
8111739c:	00a04574 	movhi	r2,33045
811173a0:	109f5a04 	addi	r2,r2,32104
811173a4:	1885883a 	add	r2,r3,r2
811173a8:	018007c4 	movi	r6,31
811173ac:	e17ffe17 	ldw	r5,-8(fp)
811173b0:	1009883a 	mov	r4,r2
811173b4:	11206ac0 	call	811206ac <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
811173b8:	e13ffb03 	ldbu	r4,-20(fp)
811173bc:	e0ffff0b 	ldhu	r3,-4(fp)
811173c0:	00a04574 	movhi	r2,33045
811173c4:	109f5a04 	addi	r2,r2,32104
811173c8:	21000b24 	muli	r4,r4,44
811173cc:	1105883a 	add	r2,r2,r4
811173d0:	10800904 	addi	r2,r2,36
811173d4:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
811173d8:	e0fffb03 	ldbu	r3,-20(fp)
811173dc:	00a04574 	movhi	r2,33045
811173e0:	109f5a04 	addi	r2,r2,32104
811173e4:	18c00b24 	muli	r3,r3,44
811173e8:	10c5883a 	add	r2,r2,r3
811173ec:	10800a04 	addi	r2,r2,40
811173f0:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
811173f4:	e0fffb03 	ldbu	r3,-20(fp)
811173f8:	00a04574 	movhi	r2,33045
811173fc:	109f5a04 	addi	r2,r2,32104
81117400:	18c00b24 	muli	r3,r3,44
81117404:	10c5883a 	add	r2,r2,r3
81117408:	10800984 	addi	r2,r2,38
8111740c:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81117410:	e0fffb03 	ldbu	r3,-20(fp)
81117414:	00a04574 	movhi	r2,33045
81117418:	109f5a04 	addi	r2,r2,32104
8111741c:	18c00b24 	muli	r3,r3,44
81117420:	10c5883a 	add	r2,r2,r3
81117424:	10800804 	addi	r2,r2,32
81117428:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
8111742c:	e0fffb03 	ldbu	r3,-20(fp)
81117430:	00a045b4 	movhi	r2,33046
81117434:	10b1da04 	addi	r2,r2,-14488
81117438:	18c00384 	addi	r3,r3,14
8111743c:	18c7883a 	add	r3,r3,r3
81117440:	18c7883a 	add	r3,r3,r3
81117444:	10c5883a 	add	r2,r2,r3
81117448:	00c00044 	movi	r3,1
8111744c:	10c00015 	stw	r3,0(r2)
			break;
81117450:	00000606 	br	8111746c <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81117454:	e0bffb03 	ldbu	r2,-20(fp)
81117458:	10800044 	addi	r2,r2,1
8111745c:	e0bffb05 	stb	r2,-20(fp)
81117460:	e0bffb03 	ldbu	r2,-20(fp)
81117464:	10800230 	cmpltui	r2,r2,8
81117468:	103fb81e 	bne	r2,zero,8111734c <__reset+0xfb0f734c>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
8111746c:	e0bffb03 	ldbu	r2,-20(fp)
81117470:	10800230 	cmpltui	r2,r2,8
81117474:	1000091e 	bne	r2,zero,8111749c <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81117478:	d0a06e17 	ldw	r2,-32328(gp)
8111747c:	1009883a 	mov	r4,r2
81117480:	113cea00 	call	8113cea0 <OSSemPost>
81117484:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81117488:	d0a06b17 	ldw	r2,-32340(gp)
8111748c:	1009883a 	mov	r4,r2
81117490:	113b0b00 	call	8113b0b0 <OSMutexPost>
		return bSuccessL;
81117494:	e0bffc17 	ldw	r2,-16(fp)
81117498:	00003006 	br	8111755c <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
8111749c:	00800044 	movi	r2,1
811174a0:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
811174a4:	d0a06783 	ldbu	r2,-32354(gp)
811174a8:	10bfffc4 	addi	r2,r2,-1
811174ac:	d0a06785 	stb	r2,-32354(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811174b0:	d0a07317 	ldw	r2,-32308(gp)
811174b4:	e0fffd04 	addi	r3,fp,-12
811174b8:	180d883a 	mov	r6,r3
811174bc:	01400084 	movi	r5,2
811174c0:	1009883a 	mov	r4,r2
811174c4:	113ab0c0 	call	8113ab0c <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811174c8:	e0bffd03 	ldbu	r2,-12(fp)
811174cc:	10803fcc 	andi	r2,r2,255
811174d0:	10000c26 	beq	r2,zero,81117504 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
811174d4:	d0a06117 	ldw	r2,-32380(gp)
811174d8:	100f883a 	mov	r7,r2
811174dc:	01801bc4 	movi	r6,111
811174e0:	01400044 	movi	r5,1
811174e4:	01204574 	movhi	r4,33045
811174e8:	2130fd04 	addi	r4,r4,-15372
811174ec:	111fc980 	call	8111fc98 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
811174f0:	d0a06b17 	ldw	r2,-32340(gp)
811174f4:	1009883a 	mov	r4,r2
811174f8:	113b0b00 	call	8113b0b0 <OSMutexPost>
		return bSuccessL;
811174fc:	e0bffc17 	ldw	r2,-16(fp)
81117500:	00001606 	br	8111755c <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81117504:	e0bffb03 	ldbu	r2,-20(fp)
81117508:	10c00b24 	muli	r3,r2,44
8111750c:	00a04574 	movhi	r2,33045
81117510:	109f5a04 	addi	r2,r2,32104
81117514:	1885883a 	add	r2,r3,r2
81117518:	1009883a 	mov	r4,r2
8111751c:	1120c480 	call	81120c48 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81117520:	e0fffb03 	ldbu	r3,-20(fp)
81117524:	00a04574 	movhi	r2,33045
81117528:	109f5a04 	addi	r2,r2,32104
8111752c:	18c00b24 	muli	r3,r3,44
81117530:	10c5883a 	add	r2,r2,r3
81117534:	10800804 	addi	r2,r2,32
81117538:	00c00044 	movi	r3,1
8111753c:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81117540:	d0a07317 	ldw	r2,-32308(gp)
81117544:	1009883a 	mov	r4,r2
81117548:	113b0b00 	call	8113b0b0 <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8111754c:	d0a06b17 	ldw	r2,-32340(gp)
81117550:	1009883a 	mov	r4,r2
81117554:	113b0b00 	call	8113b0b0 <OSMutexPost>

	return bSuccessL;
81117558:	e0bffc17 	ldw	r2,-16(fp)
}
8111755c:	e037883a 	mov	sp,fp
81117560:	dfc00117 	ldw	ra,4(sp)
81117564:	df000017 	ldw	fp,0(sp)
81117568:	dec00204 	addi	sp,sp,8
8111756c:	f800283a 	ret

81117570 <vSendEthConf>:


void vSendEthConf ( void ) {
81117570:	deffc304 	addi	sp,sp,-244
81117574:	de00012e 	bgeu	sp,et,8111757c <vSendEthConf+0xc>
81117578:	003b68fa 	trap	3
8111757c:	dfc03c15 	stw	ra,240(sp)
81117580:	df003b15 	stw	fp,236(sp)
81117584:	dd403a15 	stw	r21,232(sp)
81117588:	dd003915 	stw	r20,228(sp)
8111758c:	dcc03815 	stw	r19,224(sp)
81117590:	dc803715 	stw	r18,220(sp)
81117594:	dc403615 	stw	r17,216(sp)
81117598:	dc003515 	stw	r16,212(sp)
8111759c:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
811175a0:	e03fd98d 	sth	zero,-154(fp)
811175a4:	e03fda0d 	sth	zero,-152(fp)
811175a8:	e0bfda84 	addi	r2,fp,-150
811175ac:	00c01f04 	movi	r3,124
811175b0:	180d883a 	mov	r6,r3
811175b4:	000b883a 	mov	r5,zero
811175b8:	1009883a 	mov	r4,r2
811175bc:	11207fc0 	call	811207fc <memset>
    unsigned char crc = 0;
811175c0:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811175c4:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
811175c8:	1117b300 	call	81117b30 <usiGetIdCMD>
811175cc:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811175d0:	e57fd90b 	ldhu	r21,-156(fp)
811175d4:	00a045b4 	movhi	r2,33046
811175d8:	1091c804 	addi	r2,r2,18208
811175dc:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811175e0:	00a045b4 	movhi	r2,33046
811175e4:	1091c804 	addi	r2,r2,18208
811175e8:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811175ec:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
811175f0:	00a045b4 	movhi	r2,33046
811175f4:	1091c804 	addi	r2,r2,18208
811175f8:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811175fc:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81117600:	00a045b4 	movhi	r2,33046
81117604:	1091c804 	addi	r2,r2,18208
81117608:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111760c:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81117610:	00a045b4 	movhi	r2,33046
81117614:	1091c804 	addi	r2,r2,18208
81117618:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111761c:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81117620:	00a045b4 	movhi	r2,33046
81117624:	1091c804 	addi	r2,r2,18208
81117628:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111762c:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81117630:	00a045b4 	movhi	r2,33046
81117634:	1091c804 	addi	r2,r2,18208
81117638:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111763c:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81117640:	00a045b4 	movhi	r2,33046
81117644:	1091c804 	addi	r2,r2,18208
81117648:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111764c:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81117650:	00a045b4 	movhi	r2,33046
81117654:	1091c804 	addi	r2,r2,18208
81117658:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111765c:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81117660:	00a045b4 	movhi	r2,33046
81117664:	1091c804 	addi	r2,r2,18208
81117668:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111766c:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81117670:	00a045b4 	movhi	r2,33046
81117674:	1091c804 	addi	r2,r2,18208
81117678:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111767c:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81117680:	00a045b4 	movhi	r2,33046
81117684:	1091c804 	addi	r2,r2,18208
81117688:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111768c:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81117690:	00a045b4 	movhi	r2,33046
81117694:	1091c804 	addi	r2,r2,18208
81117698:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111769c:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811176a0:	00a045b4 	movhi	r2,33046
811176a4:	1091c804 	addi	r2,r2,18208
811176a8:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811176ac:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811176b0:	00a045b4 	movhi	r2,33046
811176b4:	1091c804 	addi	r2,r2,18208
811176b8:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811176bc:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811176c0:	00a045b4 	movhi	r2,33046
811176c4:	1091c804 	addi	r2,r2,18208
811176c8:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811176cc:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811176d0:	00a045b4 	movhi	r2,33046
811176d4:	1091c804 	addi	r2,r2,18208
811176d8:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811176dc:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
811176e0:	00a045b4 	movhi	r2,33046
811176e4:	1091c804 	addi	r2,r2,18208
811176e8:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811176ec:	10bfffcc 	andi	r2,r2,65535
811176f0:	e53fd984 	addi	r20,fp,-154
811176f4:	d8801115 	stw	r2,68(sp)
811176f8:	dcc01015 	stw	r19,64(sp)
811176fc:	dc800f15 	stw	r18,60(sp)
81117700:	dc400e15 	stw	r17,56(sp)
81117704:	dc000d15 	stw	r16,52(sp)
81117708:	dbc00c15 	stw	r15,48(sp)
8111770c:	db800b15 	stw	r14,44(sp)
81117710:	db400a15 	stw	r13,40(sp)
81117714:	db000915 	stw	r12,36(sp)
81117718:	dac00815 	stw	r11,32(sp)
8111771c:	da800715 	stw	r10,28(sp)
81117720:	da400615 	stw	r9,24(sp)
81117724:	da000515 	stw	r8,20(sp)
81117728:	d9c00415 	stw	r7,16(sp)
8111772c:	d9800315 	stw	r6,12(sp)
81117730:	d9400215 	stw	r5,8(sp)
81117734:	d9000115 	stw	r4,4(sp)
81117738:	d8c00015 	stw	r3,0(sp)
8111773c:	a80f883a 	mov	r7,r21
81117740:	018010c4 	movi	r6,67
81117744:	01604574 	movhi	r5,33045
81117748:	29711904 	addi	r5,r5,-15260
8111774c:	a009883a 	mov	r4,r20
81117750:	1120f8c0 	call	81120f8c <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81117754:	e0bfd984 	addi	r2,fp,-154
81117758:	1009883a 	mov	r4,r2
8111775c:	11211a00 	call	811211a0 <strlen>
81117760:	1007883a 	mov	r3,r2
81117764:	e0bfd984 	addi	r2,fp,-154
81117768:	180b883a 	mov	r5,r3
8111776c:	1009883a 	mov	r4,r2
81117770:	111981c0 	call	8111981c <ucCrc8wInit>
81117774:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81117778:	e13fd703 	ldbu	r4,-164(fp)
8111777c:	e0ffd984 	addi	r3,fp,-154
81117780:	e0bfd984 	addi	r2,fp,-154
81117784:	200f883a 	mov	r7,r4
81117788:	180d883a 	mov	r6,r3
8111778c:	01604574 	movhi	r5,33045
81117790:	29713104 	addi	r5,r5,-15164
81117794:	1009883a 	mov	r4,r2
81117798:	1120f8c0 	call	81120f8c <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
8111779c:	e0bfd90b 	ldhu	r2,-156(fp)
811177a0:	10ffffcc 	andi	r3,r2,65535
811177a4:	18e0001c 	xori	r3,r3,32768
811177a8:	18e00004 	addi	r3,r3,-32768
811177ac:	e0bfd984 	addi	r2,fp,-154
811177b0:	180b883a 	mov	r5,r3
811177b4:	1009883a 	mov	r4,r2
811177b8:	1116c900 	call	81116c90 <bSendUART128v2>
811177bc:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
811177c0:	e0bfd817 	ldw	r2,-160(fp)
811177c4:	10800060 	cmpeqi	r2,r2,1
811177c8:	1000011e 	bne	r2,zero,811177d0 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
811177cc:	111a3ec0 	call	8111a3ec <vCouldNotSendEthConfUART>
	}
}
811177d0:	0001883a 	nop
811177d4:	e6fffa04 	addi	sp,fp,-24
811177d8:	dfc00717 	ldw	ra,28(sp)
811177dc:	df000617 	ldw	fp,24(sp)
811177e0:	dd400517 	ldw	r21,20(sp)
811177e4:	dd000417 	ldw	r20,16(sp)
811177e8:	dcc00317 	ldw	r19,12(sp)
811177ec:	dc800217 	ldw	r18,8(sp)
811177f0:	dc400117 	ldw	r17,4(sp)
811177f4:	dc000017 	ldw	r16,0(sp)
811177f8:	dec00804 	addi	sp,sp,32
811177fc:	f800283a 	ret

81117800 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81117800:	defff304 	addi	sp,sp,-52
81117804:	de00012e 	bgeu	sp,et,8111780c <vSendTurnOff+0xc>
81117808:	003b68fa 	trap	3
8111780c:	dfc00c15 	stw	ra,48(sp)
81117810:	df000b15 	stw	fp,44(sp)
81117814:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81117818:	e03ff78d 	sth	zero,-34(fp)
8111781c:	e03ff80d 	sth	zero,-32(fp)
81117820:	e03ff88d 	sth	zero,-30(fp)
81117824:	e03ff90d 	sth	zero,-28(fp)
81117828:	e03ff98d 	sth	zero,-26(fp)
8111782c:	e03ffa0d 	sth	zero,-24(fp)
81117830:	e03ffa8d 	sth	zero,-22(fp)
81117834:	e03ffb0d 	sth	zero,-20(fp)
81117838:	e03ffb8d 	sth	zero,-18(fp)
8111783c:	e03ffc0d 	sth	zero,-16(fp)
81117840:	e03ffc8d 	sth	zero,-14(fp)
81117844:	e03ffd0d 	sth	zero,-12(fp)
81117848:	e03ffd8d 	sth	zero,-10(fp)
8111784c:	e03ffe0d 	sth	zero,-8(fp)
81117850:	e03ffe8d 	sth	zero,-6(fp)
81117854:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81117858:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111785c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81117860:	1117b300 	call	81117b30 <usiGetIdCMD>
81117864:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81117868:	e0fff70b 	ldhu	r3,-36(fp)
8111786c:	e0bff784 	addi	r2,fp,-34
81117870:	180d883a 	mov	r6,r3
81117874:	01604574 	movhi	r5,33045
81117878:	29713404 	addi	r5,r5,-15152
8111787c:	1009883a 	mov	r4,r2
81117880:	1120f8c0 	call	81120f8c <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
81117884:	e0bff784 	addi	r2,fp,-34
81117888:	1009883a 	mov	r4,r2
8111788c:	11211a00 	call	811211a0 <strlen>
81117890:	1007883a 	mov	r3,r2
81117894:	e0bff784 	addi	r2,fp,-34
81117898:	180b883a 	mov	r5,r3
8111789c:	1009883a 	mov	r4,r2
811178a0:	111981c0 	call	8111981c <ucCrc8wInit>
811178a4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811178a8:	e13ff503 	ldbu	r4,-44(fp)
811178ac:	e0fff784 	addi	r3,fp,-34
811178b0:	e0bff784 	addi	r2,fp,-34
811178b4:	200f883a 	mov	r7,r4
811178b8:	180d883a 	mov	r6,r3
811178bc:	01604574 	movhi	r5,33045
811178c0:	29713104 	addi	r5,r5,-15164
811178c4:	1009883a 	mov	r4,r2
811178c8:	1120f8c0 	call	81120f8c <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811178cc:	e0bff70b 	ldhu	r2,-36(fp)
811178d0:	10ffffcc 	andi	r3,r2,65535
811178d4:	18e0001c 	xori	r3,r3,32768
811178d8:	18e00004 	addi	r3,r3,-32768
811178dc:	e0bff784 	addi	r2,fp,-34
811178e0:	180b883a 	mov	r5,r3
811178e4:	1009883a 	mov	r4,r2
811178e8:	11172780 	call	81117278 <bSendUART32v2>
811178ec:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
811178f0:	e0bff617 	ldw	r2,-40(fp)
811178f4:	10800060 	cmpeqi	r2,r2,1
811178f8:	1000011e 	bne	r2,zero,81117900 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
811178fc:	111aa940 	call	8111aa94 <vCouldNotSendTurnOff>
	}
}
81117900:	0001883a 	nop
81117904:	e037883a 	mov	sp,fp
81117908:	dfc00117 	ldw	ra,4(sp)
8111790c:	df000017 	ldw	fp,0(sp)
81117910:	dec00204 	addi	sp,sp,8
81117914:	f800283a 	ret

81117918 <vSendReset>:

void vSendReset ( void ) {
81117918:	defff304 	addi	sp,sp,-52
8111791c:	de00012e 	bgeu	sp,et,81117924 <vSendReset+0xc>
81117920:	003b68fa 	trap	3
81117924:	dfc00c15 	stw	ra,48(sp)
81117928:	df000b15 	stw	fp,44(sp)
8111792c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81117930:	e03ff78d 	sth	zero,-34(fp)
81117934:	e03ff80d 	sth	zero,-32(fp)
81117938:	e03ff88d 	sth	zero,-30(fp)
8111793c:	e03ff90d 	sth	zero,-28(fp)
81117940:	e03ff98d 	sth	zero,-26(fp)
81117944:	e03ffa0d 	sth	zero,-24(fp)
81117948:	e03ffa8d 	sth	zero,-22(fp)
8111794c:	e03ffb0d 	sth	zero,-20(fp)
81117950:	e03ffb8d 	sth	zero,-18(fp)
81117954:	e03ffc0d 	sth	zero,-16(fp)
81117958:	e03ffc8d 	sth	zero,-14(fp)
8111795c:	e03ffd0d 	sth	zero,-12(fp)
81117960:	e03ffd8d 	sth	zero,-10(fp)
81117964:	e03ffe0d 	sth	zero,-8(fp)
81117968:	e03ffe8d 	sth	zero,-6(fp)
8111796c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81117970:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81117974:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81117978:	1117b300 	call	81117b30 <usiGetIdCMD>
8111797c:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
81117980:	e0fff70b 	ldhu	r3,-36(fp)
81117984:	e0bff784 	addi	r2,fp,-34
81117988:	180d883a 	mov	r6,r3
8111798c:	01604574 	movhi	r5,33045
81117990:	29713604 	addi	r5,r5,-15144
81117994:	1009883a 	mov	r4,r2
81117998:	1120f8c0 	call	81120f8c <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
8111799c:	e0bff784 	addi	r2,fp,-34
811179a0:	1009883a 	mov	r4,r2
811179a4:	11211a00 	call	811211a0 <strlen>
811179a8:	1007883a 	mov	r3,r2
811179ac:	e0bff784 	addi	r2,fp,-34
811179b0:	180b883a 	mov	r5,r3
811179b4:	1009883a 	mov	r4,r2
811179b8:	111981c0 	call	8111981c <ucCrc8wInit>
811179bc:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811179c0:	e13ff503 	ldbu	r4,-44(fp)
811179c4:	e0fff784 	addi	r3,fp,-34
811179c8:	e0bff784 	addi	r2,fp,-34
811179cc:	200f883a 	mov	r7,r4
811179d0:	180d883a 	mov	r6,r3
811179d4:	01604574 	movhi	r5,33045
811179d8:	29713104 	addi	r5,r5,-15164
811179dc:	1009883a 	mov	r4,r2
811179e0:	1120f8c0 	call	81120f8c <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811179e4:	e0bff70b 	ldhu	r2,-36(fp)
811179e8:	10ffffcc 	andi	r3,r2,65535
811179ec:	18e0001c 	xori	r3,r3,32768
811179f0:	18e00004 	addi	r3,r3,-32768
811179f4:	e0bff784 	addi	r2,fp,-34
811179f8:	180b883a 	mov	r5,r3
811179fc:	1009883a 	mov	r4,r2
81117a00:	11172780 	call	81117278 <bSendUART32v2>
81117a04:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81117a08:	e0bff617 	ldw	r2,-40(fp)
81117a0c:	10800060 	cmpeqi	r2,r2,1
81117a10:	1000011e 	bne	r2,zero,81117a18 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81117a14:	111aa940 	call	8111aa94 <vCouldNotSendTurnOff>
	}
}
81117a18:	0001883a 	nop
81117a1c:	e037883a 	mov	sp,fp
81117a20:	dfc00117 	ldw	ra,4(sp)
81117a24:	df000017 	ldw	fp,0(sp)
81117a28:	dec00204 	addi	sp,sp,8
81117a2c:	f800283a 	ret

81117a30 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81117a30:	deffda04 	addi	sp,sp,-152
81117a34:	de00012e 	bgeu	sp,et,81117a3c <vSendLog+0xc>
81117a38:	003b68fa 	trap	3
81117a3c:	dfc02515 	stw	ra,148(sp)
81117a40:	df002415 	stw	fp,144(sp)
81117a44:	df002404 	addi	fp,sp,144
81117a48:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
81117a4c:	e03fde8d 	sth	zero,-134(fp)
81117a50:	e03fdf0d 	sth	zero,-132(fp)
81117a54:	e0bfdf84 	addi	r2,fp,-130
81117a58:	00c01f04 	movi	r3,124
81117a5c:	180d883a 	mov	r6,r3
81117a60:	000b883a 	mov	r5,zero
81117a64:	1009883a 	mov	r4,r2
81117a68:	11207fc0 	call	811207fc <memset>
    unsigned char crc = 0;
81117a6c:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81117a70:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81117a74:	1117b300 	call	81117b30 <usiGetIdCMD>
81117a78:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
81117a7c:	e0ffde0b 	ldhu	r3,-136(fp)
81117a80:	e0bfde84 	addi	r2,fp,-134
81117a84:	e1ffff17 	ldw	r7,-4(fp)
81117a88:	180d883a 	mov	r6,r3
81117a8c:	01604574 	movhi	r5,33045
81117a90:	29713804 	addi	r5,r5,-15136
81117a94:	1009883a 	mov	r4,r2
81117a98:	1120f8c0 	call	81120f8c <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
81117a9c:	e0bfde84 	addi	r2,fp,-134
81117aa0:	1009883a 	mov	r4,r2
81117aa4:	11211a00 	call	811211a0 <strlen>
81117aa8:	1007883a 	mov	r3,r2
81117aac:	e0bfde84 	addi	r2,fp,-134
81117ab0:	180b883a 	mov	r5,r3
81117ab4:	1009883a 	mov	r4,r2
81117ab8:	111981c0 	call	8111981c <ucCrc8wInit>
81117abc:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
81117ac0:	e13fdc03 	ldbu	r4,-144(fp)
81117ac4:	e0ffde84 	addi	r3,fp,-134
81117ac8:	e0bfde84 	addi	r2,fp,-134
81117acc:	200f883a 	mov	r7,r4
81117ad0:	180d883a 	mov	r6,r3
81117ad4:	01604574 	movhi	r5,33045
81117ad8:	29713104 	addi	r5,r5,-15164
81117adc:	1009883a 	mov	r4,r2
81117ae0:	1120f8c0 	call	81120f8c <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
81117ae4:	e0bfde0b 	ldhu	r2,-136(fp)
81117ae8:	10ffffcc 	andi	r3,r2,65535
81117aec:	18e0001c 	xori	r3,r3,32768
81117af0:	18e00004 	addi	r3,r3,-32768
81117af4:	e0bfde84 	addi	r2,fp,-134
81117af8:	180b883a 	mov	r5,r3
81117afc:	1009883a 	mov	r4,r2
81117b00:	1116c900 	call	81116c90 <bSendUART128v2>
81117b04:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81117b08:	e0bfdd17 	ldw	r2,-140(fp)
81117b0c:	10800060 	cmpeqi	r2,r2,1
81117b10:	1000011e 	bne	r2,zero,81117b18 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
81117b14:	111ab640 	call	8111ab64 <vCouldNotSendLog>
	}
}
81117b18:	0001883a 	nop
81117b1c:	e037883a 	mov	sp,fp
81117b20:	dfc00117 	ldw	ra,4(sp)
81117b24:	df000017 	ldw	fp,0(sp)
81117b28:	dec00204 	addi	sp,sp,8
81117b2c:	f800283a 	ret

81117b30 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81117b30:	deffff04 	addi	sp,sp,-4
81117b34:	de00012e 	bgeu	sp,et,81117b3c <usiGetIdCMD+0xc>
81117b38:	003b68fa 	trap	3
81117b3c:	df000015 	stw	fp,0(sp)
81117b40:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81117b44:	d0a0670b 	ldhu	r2,-32356(gp)
81117b48:	10ffffcc 	andi	r3,r2,65535
81117b4c:	00bfffd4 	movui	r2,65535
81117b50:	1880031e 	bne	r3,r2,81117b60 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81117b54:	00800084 	movi	r2,2
81117b58:	d0a0670d 	sth	r2,-32356(gp)
81117b5c:	00000306 	br	81117b6c <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81117b60:	d0a0670b 	ldhu	r2,-32356(gp)
81117b64:	10800044 	addi	r2,r2,1
81117b68:	d0a0670d 	sth	r2,-32356(gp)

    return usiIdCMD;
81117b6c:	d0a0670b 	ldhu	r2,-32356(gp)
}
81117b70:	e037883a 	mov	sp,fp
81117b74:	df000017 	ldw	fp,0(sp)
81117b78:	dec00104 	addi	sp,sp,4
81117b7c:	f800283a 	ret

81117b80 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
81117b80:	defffb04 	addi	sp,sp,-20
81117b84:	de00012e 	bgeu	sp,et,81117b8c <siPosStr+0xc>
81117b88:	003b68fa 	trap	3
81117b8c:	dfc00415 	stw	ra,16(sp)
81117b90:	df000315 	stw	fp,12(sp)
81117b94:	df000304 	addi	fp,sp,12
81117b98:	e13ffe15 	stw	r4,-8(fp)
81117b9c:	2805883a 	mov	r2,r5
81117ba0:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
81117ba4:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
81117ba8:	e0bfff03 	ldbu	r2,-4(fp)
81117bac:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
81117bb0:	e17ffd04 	addi	r5,fp,-12
81117bb4:	e13ffe17 	ldw	r4,-8(fp)
81117bb8:	11211540 	call	81121154 <strcspn>
}
81117bbc:	e037883a 	mov	sp,fp
81117bc0:	dfc00117 	ldw	ra,4(sp)
81117bc4:	df000017 	ldw	fp,0(sp)
81117bc8:	dec00204 	addi	sp,sp,8
81117bcc:	f800283a 	ret

81117bd0 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
81117bd0:	defffc04 	addi	sp,sp,-16
81117bd4:	de00012e 	bgeu	sp,et,81117bdc <vTimeoutCheck+0xc>
81117bd8:	003b68fa 	trap	3
81117bdc:	dfc00315 	stw	ra,12(sp)
81117be0:	df000215 	stw	fp,8(sp)
81117be4:	df000204 	addi	fp,sp,8
81117be8:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
81117bec:	d0a06617 	ldw	r2,-32360(gp)
81117bf0:	1009883a 	mov	r4,r2
81117bf4:	113cea00 	call	8113cea0 <OSSemPost>
81117bf8:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
81117bfc:	e0bffe03 	ldbu	r2,-8(fp)
81117c00:	10000126 	beq	r2,zero,81117c08 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81117c04:	111a8240 	call	8111a824 <vFailPostBlockingSemTimeoutTask>
	}
}
81117c08:	0001883a 	nop
81117c0c:	e037883a 	mov	sp,fp
81117c10:	dfc00117 	ldw	ra,4(sp)
81117c14:	df000017 	ldw	fp,0(sp)
81117c18:	dec00204 	addi	sp,sp,8
81117c1c:	f800283a 	ret

81117c20 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81117c20:	deffe304 	addi	sp,sp,-116
81117c24:	de00012e 	bgeu	sp,et,81117c2c <vSendPusTM64+0xc>
81117c28:	003b68fa 	trap	3
81117c2c:	dfc01815 	stw	ra,96(sp)
81117c30:	df001715 	stw	fp,92(sp)
81117c34:	df001704 	addi	fp,sp,92
81117c38:	e1000215 	stw	r4,8(fp)
81117c3c:	e1400315 	stw	r5,12(fp)
81117c40:	e1800415 	stw	r6,16(fp)
81117c44:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81117c48:	e03fef8d 	sth	zero,-66(fp)
81117c4c:	e03ff00d 	sth	zero,-64(fp)
81117c50:	e0bff084 	addi	r2,fp,-62
81117c54:	00c00f04 	movi	r3,60
81117c58:	180d883a 	mov	r6,r3
81117c5c:	000b883a 	mov	r5,zero
81117c60:	1009883a 	mov	r4,r2
81117c64:	11207fc0 	call	811207fc <memset>
    unsigned char crc = 0;
81117c68:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
81117c6c:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81117c70:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81117c74:	1117b300 	call	81117b30 <usiGetIdCMD>
81117c78:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81117c7c:	e1bfef0b 	ldhu	r6,-68(fp)
81117c80:	e080040b 	ldhu	r2,16(fp)
81117c84:	11ffffcc 	andi	r7,r2,65535
81117c88:	e080048b 	ldhu	r2,18(fp)
81117c8c:	10bfffcc 	andi	r2,r2,65535
81117c90:	e0c0050b 	ldhu	r3,20(fp)
81117c94:	18ffffcc 	andi	r3,r3,65535
81117c98:	e100058b 	ldhu	r4,22(fp)
81117c9c:	213fffcc 	andi	r4,r4,65535
81117ca0:	e140060b 	ldhu	r5,24(fp)
81117ca4:	297fffcc 	andi	r5,r5,65535
81117ca8:	e23fef84 	addi	r8,fp,-66
81117cac:	d9400315 	stw	r5,12(sp)
81117cb0:	d9000215 	stw	r4,8(sp)
81117cb4:	d8c00115 	stw	r3,4(sp)
81117cb8:	d8800015 	stw	r2,0(sp)
81117cbc:	01604574 	movhi	r5,33045
81117cc0:	29713b04 	addi	r5,r5,-15124
81117cc4:	4009883a 	mov	r4,r8
81117cc8:	1120f8c0 	call	81120f8c <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117ccc:	e03fed05 	stb	zero,-76(fp)
81117cd0:	00001206 	br	81117d1c <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81117cd4:	e0bfed03 	ldbu	r2,-76(fp)
81117cd8:	10800284 	addi	r2,r2,10
81117cdc:	1085883a 	add	r2,r2,r2
81117ce0:	e0c00204 	addi	r3,fp,8
81117ce4:	1885883a 	add	r2,r3,r2
81117ce8:	1080000b 	ldhu	r2,0(r2)
81117cec:	113fffcc 	andi	r4,r2,65535
81117cf0:	e0ffef84 	addi	r3,fp,-66
81117cf4:	e0bfef84 	addi	r2,fp,-66
81117cf8:	200f883a 	mov	r7,r4
81117cfc:	180d883a 	mov	r6,r3
81117d00:	01604574 	movhi	r5,33045
81117d04:	29714204 	addi	r5,r5,-15096
81117d08:	1009883a 	mov	r4,r2
81117d0c:	1120f8c0 	call	81120f8c <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117d10:	e0bfed03 	ldbu	r2,-76(fp)
81117d14:	10800044 	addi	r2,r2,1
81117d18:	e0bfed05 	stb	r2,-76(fp)
81117d1c:	e0800683 	ldbu	r2,26(fp)
81117d20:	10803fcc 	andi	r2,r2,255
81117d24:	e0ffed03 	ldbu	r3,-76(fp)
81117d28:	18bfea36 	bltu	r3,r2,81117cd4 <__reset+0xfb0f7cd4>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81117d2c:	e0bfef84 	addi	r2,fp,-66
81117d30:	1009883a 	mov	r4,r2
81117d34:	11211a00 	call	811211a0 <strlen>
81117d38:	1007883a 	mov	r3,r2
81117d3c:	e0bfef84 	addi	r2,fp,-66
81117d40:	180b883a 	mov	r5,r3
81117d44:	1009883a 	mov	r4,r2
81117d48:	111981c0 	call	8111981c <ucCrc8wInit>
81117d4c:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81117d50:	e13fed43 	ldbu	r4,-75(fp)
81117d54:	e0ffef84 	addi	r3,fp,-66
81117d58:	e0bfef84 	addi	r2,fp,-66
81117d5c:	200f883a 	mov	r7,r4
81117d60:	180d883a 	mov	r6,r3
81117d64:	01604574 	movhi	r5,33045
81117d68:	29713104 	addi	r5,r5,-15164
81117d6c:	1009883a 	mov	r4,r2
81117d70:	1120f8c0 	call	81120f8c <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81117d74:	e0bfef0b 	ldhu	r2,-68(fp)
81117d78:	10ffffcc 	andi	r3,r2,65535
81117d7c:	18e0001c 	xori	r3,r3,32768
81117d80:	18e00004 	addi	r3,r3,-32768
81117d84:	e0bfef84 	addi	r2,fp,-66
81117d88:	180b883a 	mov	r5,r3
81117d8c:	1009883a 	mov	r4,r2
81117d90:	1116f800 	call	81116f80 <bSendUART64v2>
81117d94:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
81117d98:	e0bfee17 	ldw	r2,-72(fp)
81117d9c:	10800060 	cmpeqi	r2,r2,1
81117da0:	1000031e 	bne	r2,zero,81117db0 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81117da4:	e0bfef84 	addi	r2,fp,-66
81117da8:	1009883a 	mov	r4,r2
81117dac:	111abcc0 	call	8111abcc <vCouldNotSendTMPusCommand>
	}
}
81117db0:	0001883a 	nop
81117db4:	e037883a 	mov	sp,fp
81117db8:	dfc00117 	ldw	ra,4(sp)
81117dbc:	df000017 	ldw	fp,0(sp)
81117dc0:	dec00604 	addi	sp,sp,24
81117dc4:	f800283a 	ret

81117dc8 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
81117dc8:	deffd304 	addi	sp,sp,-180
81117dcc:	de00012e 	bgeu	sp,et,81117dd4 <vSendPusTM128+0xc>
81117dd0:	003b68fa 	trap	3
81117dd4:	dfc02815 	stw	ra,160(sp)
81117dd8:	df002715 	stw	fp,156(sp)
81117ddc:	df002704 	addi	fp,sp,156
81117de0:	e1000215 	stw	r4,8(fp)
81117de4:	e1400315 	stw	r5,12(fp)
81117de8:	e1800415 	stw	r6,16(fp)
81117dec:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81117df0:	e03fdf8d 	sth	zero,-130(fp)
81117df4:	e03fe00d 	sth	zero,-128(fp)
81117df8:	e0bfe084 	addi	r2,fp,-126
81117dfc:	00c01f04 	movi	r3,124
81117e00:	180d883a 	mov	r6,r3
81117e04:	000b883a 	mov	r5,zero
81117e08:	1009883a 	mov	r4,r2
81117e0c:	11207fc0 	call	811207fc <memset>
    unsigned char crc = 0;
81117e10:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81117e14:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81117e18:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
81117e1c:	1117b300 	call	81117b30 <usiGetIdCMD>
81117e20:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81117e24:	e1bfdf0b 	ldhu	r6,-132(fp)
81117e28:	e080040b 	ldhu	r2,16(fp)
81117e2c:	11ffffcc 	andi	r7,r2,65535
81117e30:	e080048b 	ldhu	r2,18(fp)
81117e34:	10bfffcc 	andi	r2,r2,65535
81117e38:	e0c0050b 	ldhu	r3,20(fp)
81117e3c:	18ffffcc 	andi	r3,r3,65535
81117e40:	e100058b 	ldhu	r4,22(fp)
81117e44:	213fffcc 	andi	r4,r4,65535
81117e48:	e140060b 	ldhu	r5,24(fp)
81117e4c:	297fffcc 	andi	r5,r5,65535
81117e50:	e23fdf84 	addi	r8,fp,-130
81117e54:	d9400315 	stw	r5,12(sp)
81117e58:	d9000215 	stw	r4,8(sp)
81117e5c:	d8c00115 	stw	r3,4(sp)
81117e60:	d8800015 	stw	r2,0(sp)
81117e64:	01604574 	movhi	r5,33045
81117e68:	29713b04 	addi	r5,r5,-15124
81117e6c:	4009883a 	mov	r4,r8
81117e70:	1120f8c0 	call	81120f8c <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117e74:	e03fdd05 	stb	zero,-140(fp)
81117e78:	00001206 	br	81117ec4 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
81117e7c:	e0bfdd03 	ldbu	r2,-140(fp)
81117e80:	10800284 	addi	r2,r2,10
81117e84:	1085883a 	add	r2,r2,r2
81117e88:	e0c00204 	addi	r3,fp,8
81117e8c:	1885883a 	add	r2,r3,r2
81117e90:	1080000b 	ldhu	r2,0(r2)
81117e94:	113fffcc 	andi	r4,r2,65535
81117e98:	e0ffdf84 	addi	r3,fp,-130
81117e9c:	e0bfdf84 	addi	r2,fp,-130
81117ea0:	200f883a 	mov	r7,r4
81117ea4:	180d883a 	mov	r6,r3
81117ea8:	01604574 	movhi	r5,33045
81117eac:	29714204 	addi	r5,r5,-15096
81117eb0:	1009883a 	mov	r4,r2
81117eb4:	1120f8c0 	call	81120f8c <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81117eb8:	e0bfdd03 	ldbu	r2,-140(fp)
81117ebc:	10800044 	addi	r2,r2,1
81117ec0:	e0bfdd05 	stb	r2,-140(fp)
81117ec4:	e0800683 	ldbu	r2,26(fp)
81117ec8:	10803fcc 	andi	r2,r2,255
81117ecc:	e0ffdd03 	ldbu	r3,-140(fp)
81117ed0:	18bfea36 	bltu	r3,r2,81117e7c <__reset+0xfb0f7e7c>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
81117ed4:	e0bfdf84 	addi	r2,fp,-130
81117ed8:	1009883a 	mov	r4,r2
81117edc:	11211a00 	call	811211a0 <strlen>
81117ee0:	1007883a 	mov	r3,r2
81117ee4:	e0bfdf84 	addi	r2,fp,-130
81117ee8:	180b883a 	mov	r5,r3
81117eec:	1009883a 	mov	r4,r2
81117ef0:	111981c0 	call	8111981c <ucCrc8wInit>
81117ef4:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81117ef8:	e13fdd43 	ldbu	r4,-139(fp)
81117efc:	e0ffdf84 	addi	r3,fp,-130
81117f00:	e0bfdf84 	addi	r2,fp,-130
81117f04:	200f883a 	mov	r7,r4
81117f08:	180d883a 	mov	r6,r3
81117f0c:	01604574 	movhi	r5,33045
81117f10:	29713104 	addi	r5,r5,-15164
81117f14:	1009883a 	mov	r4,r2
81117f18:	1120f8c0 	call	81120f8c <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81117f1c:	e0bfdf0b 	ldhu	r2,-132(fp)
81117f20:	10ffffcc 	andi	r3,r2,65535
81117f24:	18e0001c 	xori	r3,r3,32768
81117f28:	18e00004 	addi	r3,r3,-32768
81117f2c:	e0bfdf84 	addi	r2,fp,-130
81117f30:	180b883a 	mov	r5,r3
81117f34:	1009883a 	mov	r4,r2
81117f38:	1116c900 	call	81116c90 <bSendUART128v2>
81117f3c:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81117f40:	e0bfde17 	ldw	r2,-136(fp)
81117f44:	10800060 	cmpeqi	r2,r2,1
81117f48:	1000031e 	bne	r2,zero,81117f58 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81117f4c:	e0bfdf84 	addi	r2,fp,-130
81117f50:	1009883a 	mov	r4,r2
81117f54:	111abcc0 	call	8111abcc <vCouldNotSendTMPusCommand>
	}
}
81117f58:	0001883a 	nop
81117f5c:	e037883a 	mov	sp,fp
81117f60:	dfc00117 	ldw	ra,4(sp)
81117f64:	df000017 	ldw	fp,0(sp)
81117f68:	dec00604 	addi	sp,sp,24
81117f6c:	f800283a 	ret

81117f70 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81117f70:	deffd704 	addi	sp,sp,-164
81117f74:	de00012e 	bgeu	sp,et,81117f7c <vTMPusTestConnection+0xc>
81117f78:	003b68fa 	trap	3
81117f7c:	dfc02815 	stw	ra,160(sp)
81117f80:	df002715 	stw	fp,156(sp)
81117f84:	df002704 	addi	fp,sp,156
81117f88:	2005883a 	mov	r2,r4
81117f8c:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81117f90:	e0bfff0b 	ldhu	r2,-4(fp)
81117f94:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81117f98:	00801c04 	movi	r2,112
81117f9c:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81117fa0:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81117fa4:	00800444 	movi	r2,17
81117fa8:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81117fac:	00800084 	movi	r2,2
81117fb0:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81117fb4:	d809883a 	mov	r4,sp
81117fb8:	e0bfee04 	addi	r2,fp,-72
81117fbc:	00c01104 	movi	r3,68
81117fc0:	180d883a 	mov	r6,r3
81117fc4:	100b883a 	mov	r5,r2
81117fc8:	11206ac0 	call	811206ac <memcpy>
81117fcc:	e13fea17 	ldw	r4,-88(fp)
81117fd0:	e17feb17 	ldw	r5,-84(fp)
81117fd4:	e1bfec17 	ldw	r6,-80(fp)
81117fd8:	e1ffed17 	ldw	r7,-76(fp)
81117fdc:	1117c200 	call	81117c20 <vSendPusTM64>
}
81117fe0:	0001883a 	nop
81117fe4:	e037883a 	mov	sp,fp
81117fe8:	dfc00117 	ldw	ra,4(sp)
81117fec:	df000017 	ldw	fp,0(sp)
81117ff0:	dec00204 	addi	sp,sp,8
81117ff4:	f800283a 	ret

81117ff8 <vLoadDefaultETHConf>:
/*Configuration related to the eth connection*/
TConfEth xConfEth;
TDefaults xDefaults;


bool vLoadDefaultETHConf( void ){
81117ff8:	defff504 	addi	sp,sp,-44
81117ffc:	de00012e 	bgeu	sp,et,81118004 <vLoadDefaultETHConf+0xc>
81118000:	003b68fa 	trap	3
81118004:	dfc00a15 	stw	ra,40(sp)
81118008:	df000915 	stw	fp,36(sp)
8111800c:	dc000815 	stw	r16,32(sp)
81118010:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81118014:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81118018:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
8111801c:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81118020:	d0a07517 	ldw	r2,-32300(gp)
81118024:	10800058 	cmpnei	r2,r2,1
81118028:	1001b21e 	bne	r2,zero,811186f4 <vLoadDefaultETHConf+0x6fc>
8111802c:	111ca100 	call	8111ca10 <bSDcardIsPresent>
81118030:	1001b026 	beq	r2,zero,811186f4 <vLoadDefaultETHConf+0x6fc>
81118034:	111ca400 	call	8111ca40 <bSDcardFAT16Check>
81118038:	1001ae26 	beq	r2,zero,811186f4 <vLoadDefaultETHConf+0x6fc>

		siFile = siOpenFile( ETH_FILE_NAME );
8111803c:	01204574 	movhi	r4,33045
81118040:	21314404 	addi	r4,r4,-15088
81118044:	111cb680 	call	8111cb68 <siOpenFile>
81118048:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
8111804c:	e0bffc0f 	ldh	r2,-16(fp)
81118050:	1001a016 	blt	r2,zero,811186d4 <vLoadDefaultETHConf+0x6dc>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81118054:	e0bffc84 	addi	r2,fp,-14
81118058:	01800204 	movi	r6,8
8111805c:	01400284 	movi	r5,10
81118060:	1009883a 	mov	r4,r2
81118064:	11207fc0 	call	811207fc <memset>
			p_inteiro = inteiro;
81118068:	e0bffc84 	addi	r2,fp,-14
8111806c:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81118070:	e0bffc0f 	ldh	r2,-16(fp)
81118074:	1009883a 	mov	r4,r2
81118078:	111cbe40 	call	8111cbe4 <cGetNextChar>
8111807c:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81118080:	e0bff947 	ldb	r2,-27(fp)
81118084:	10800084 	addi	r2,r2,2
81118088:	10c01428 	cmpgeui	r3,r2,80
8111808c:	1801851e 	bne	r3,zero,811186a4 <vLoadDefaultETHConf+0x6ac>
81118090:	100690ba 	slli	r3,r2,2
81118094:	00a044b4 	movhi	r2,33042
81118098:	10a02a04 	addi	r2,r2,-32600
8111809c:	1885883a 	add	r2,r3,r2
811180a0:	10800017 	ldw	r2,0(r2)
811180a4:	1000683a 	jmp	r2
811180a8:	81118228 	cmpgeui	r4,r16,17928
811180ac:	8111821c 	xori	r4,r16,17928
811180b0:	811186a4 	muli	r4,r16,17946
811180b4:	811186a4 	muli	r4,r16,17946
811180b8:	811186a4 	muli	r4,r16,17946
811180bc:	811186a4 	muli	r4,r16,17946
811180c0:	811186a4 	muli	r4,r16,17946
811180c4:	811186a4 	muli	r4,r16,17946
811180c8:	811186a4 	muli	r4,r16,17946
811180cc:	811186a4 	muli	r4,r16,17946
811180d0:	811186a4 	muli	r4,r16,17946
811180d4:	811186a4 	muli	r4,r16,17946
811180d8:	811186c4 	addi	r4,r16,17947
811180dc:	811186a4 	muli	r4,r16,17946
811180e0:	811186a4 	muli	r4,r16,17946
811180e4:	811186c4 	addi	r4,r16,17947
811180e8:	811186a4 	muli	r4,r16,17946
811180ec:	811186a4 	muli	r4,r16,17946
811180f0:	811186a4 	muli	r4,r16,17946
811180f4:	811186a4 	muli	r4,r16,17946
811180f8:	811186a4 	muli	r4,r16,17946
811180fc:	811186a4 	muli	r4,r16,17946
81118100:	811186a4 	muli	r4,r16,17946
81118104:	811186a4 	muli	r4,r16,17946
81118108:	811186a4 	muli	r4,r16,17946
8111810c:	811186a4 	muli	r4,r16,17946
81118110:	811186a4 	muli	r4,r16,17946
81118114:	811186a4 	muli	r4,r16,17946
81118118:	811186a4 	muli	r4,r16,17946
8111811c:	811186a4 	muli	r4,r16,17946
81118120:	811186a4 	muli	r4,r16,17946
81118124:	811186a4 	muli	r4,r16,17946
81118128:	811186a4 	muli	r4,r16,17946
8111812c:	811186a4 	muli	r4,r16,17946
81118130:	811186c4 	addi	r4,r16,17947
81118134:	811186a4 	muli	r4,r16,17946
81118138:	811186a4 	muli	r4,r16,17946
8111813c:	811186a4 	muli	r4,r16,17946
81118140:	811186a4 	muli	r4,r16,17946
81118144:	811186a4 	muli	r4,r16,17946
81118148:	811186a4 	muli	r4,r16,17946
8111814c:	811181e8 	cmpgeui	r4,r16,17927
81118150:	811186a4 	muli	r4,r16,17946
81118154:	811186a4 	muli	r4,r16,17946
81118158:	811186a4 	muli	r4,r16,17946
8111815c:	811186a4 	muli	r4,r16,17946
81118160:	811186a4 	muli	r4,r16,17946
81118164:	811186a4 	muli	r4,r16,17946
81118168:	811186a4 	muli	r4,r16,17946
8111816c:	811186a4 	muli	r4,r16,17946
81118170:	811186a4 	muli	r4,r16,17946
81118174:	811186a4 	muli	r4,r16,17946
81118178:	811186a4 	muli	r4,r16,17946
8111817c:	811186a4 	muli	r4,r16,17946
81118180:	811186a4 	muli	r4,r16,17946
81118184:	811186a4 	muli	r4,r16,17946
81118188:	811186a4 	muli	r4,r16,17946
8111818c:	811186a4 	muli	r4,r16,17946
81118190:	811186a4 	muli	r4,r16,17946
81118194:	811186a4 	muli	r4,r16,17946
81118198:	811186a4 	muli	r4,r16,17946
8111819c:	811186a4 	muli	r4,r16,17946
811181a0:	8111865c 	xori	r4,r16,17945
811181a4:	811186a4 	muli	r4,r16,17946
811181a8:	811186a4 	muli	r4,r16,17946
811181ac:	811186a4 	muli	r4,r16,17946
811181b0:	811186a4 	muli	r4,r16,17946
811181b4:	811186a4 	muli	r4,r16,17946
811181b8:	811186a4 	muli	r4,r16,17946
811181bc:	811186a4 	muli	r4,r16,17946
811181c0:	8111858c 	andi	r4,r16,17942
811181c4:	811186a4 	muli	r4,r16,17946
811181c8:	811186a4 	muli	r4,r16,17946
811181cc:	811183ec 	andhi	r4,r16,17935
811181d0:	811184bc 	xorhi	r4,r16,17938
811181d4:	81118320 	cmpeqi	r4,r16,17932
811181d8:	811186a4 	muli	r4,r16,17946
811181dc:	811186a4 	muli	r4,r16,17946
811181e0:	811186a4 	muli	r4,r16,17946
811181e4:	81118250 	cmplti	r4,r16,17929
					case 39:// single quote '
						c = cGetNextChar(siFile);
811181e8:	e0bffc0f 	ldh	r2,-16(fp)
811181ec:	1009883a 	mov	r4,r2
811181f0:	111cbe40 	call	8111cbe4 <cGetNextChar>
811181f4:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
811181f8:	00000406 	br	8111820c <vLoadDefaultETHConf+0x214>
							c = cGetNextChar(siFile);
811181fc:	e0bffc0f 	ldh	r2,-16(fp)
81118200:	1009883a 	mov	r4,r2
81118204:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118208:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
8111820c:	e0bff947 	ldb	r2,-27(fp)
81118210:	108009d8 	cmpnei	r2,r2,39
81118214:	103ff91e 	bne	r2,zero,811181fc <__reset+0xfb0f81fc>
							c = cGetNextChar(siFile);
						}
						break;
81118218:	00012b06 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case -1: 	//EOF
						bEOF = TRUE;
8111821c:	00800044 	movi	r2,1
81118220:	e0bff815 	stw	r2,-32(fp)
						break;
81118224:	00012806 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81118228:	d0a06117 	ldw	r2,-32380(gp)
8111822c:	100f883a 	mov	r7,r2
81118230:	018006c4 	movi	r6,27
81118234:	01400044 	movi	r5,1
81118238:	01204574 	movhi	r4,33045
8111823c:	21314604 	addi	r4,r4,-15080
81118240:	111fc980 	call	8111fc98 <fwrite>
						#endif
						bEOF = TRUE;
81118244:	00800044 	movi	r2,1
81118248:	e0bff815 	stw	r2,-32(fp)
						break;
8111824c:	00011e06 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81118250:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81118254:	e0bffc0f 	ldh	r2,-16(fp)
81118258:	1009883a 	mov	r4,r2
8111825c:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118260:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81118264:	d0e00317 	ldw	r3,-32756(gp)
81118268:	e0bff947 	ldb	r2,-27(fp)
8111826c:	10800044 	addi	r2,r2,1
81118270:	1885883a 	add	r2,r3,r2
81118274:	10800003 	ldbu	r2,0(r2)
81118278:	10803fcc 	andi	r2,r2,255
8111827c:	1080010c 	andi	r2,r2,4
81118280:	10000626 	beq	r2,zero,8111829c <vLoadDefaultETHConf+0x2a4>
									(*p_inteiro) = c;
81118284:	e0bffa17 	ldw	r2,-24(fp)
81118288:	e0fff943 	ldbu	r3,-27(fp)
8111828c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81118290:	e0bffa17 	ldw	r2,-24(fp)
81118294:	10800044 	addi	r2,r2,1
81118298:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
8111829c:	e0bff947 	ldb	r2,-27(fp)
811182a0:	10800ea0 	cmpeqi	r2,r2,58
811182a4:	1000031e 	bne	r2,zero,811182b4 <vLoadDefaultETHConf+0x2bc>
811182a8:	e0bff947 	ldb	r2,-27(fp)
811182ac:	10800ed8 	cmpnei	r2,r2,59
811182b0:	103fe81e 	bne	r2,zero,81118254 <__reset+0xfb0f8254>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811182b4:	e0bffa17 	ldw	r2,-24(fp)
811182b8:	00c00284 	movi	r3,10
811182bc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
811182c0:	e0bff903 	ldbu	r2,-28(fp)
811182c4:	10800168 	cmpgeui	r2,r2,5
811182c8:	1000021e 	bne	r2,zero,811182d4 <vLoadDefaultETHConf+0x2dc>
811182cc:	e43ff903 	ldbu	r16,-28(fp)
811182d0:	00000106 	br	811182d8 <vLoadDefaultETHConf+0x2e0>
811182d4:	04000144 	movi	r16,5
811182d8:	e0bffc84 	addi	r2,fp,-14
811182dc:	1009883a 	mov	r4,r2
811182e0:	111f4a00 	call	8111f4a0 <atoi>
811182e4:	1007883a 	mov	r3,r2
811182e8:	00a045b4 	movhi	r2,33046
811182ec:	1091c804 	addi	r2,r2,18208
811182f0:	1405883a 	add	r2,r2,r16
811182f4:	10800404 	addi	r2,r2,16
811182f8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811182fc:	e0bffc84 	addi	r2,fp,-14
81118300:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81118304:	e0bff903 	ldbu	r2,-28(fp)
81118308:	10800044 	addi	r2,r2,1
8111830c:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81118310:	e0bff947 	ldb	r2,-27(fp)
81118314:	10800ed8 	cmpnei	r2,r2,59
81118318:	103fce1e 	bne	r2,zero,81118254 <__reset+0xfb0f8254>

						break;
8111831c:	0000ea06 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case 'I':

						ucParser = 0;
81118320:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81118324:	e0bffc0f 	ldh	r2,-16(fp)
81118328:	1009883a 	mov	r4,r2
8111832c:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118330:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81118334:	d0e00317 	ldw	r3,-32756(gp)
81118338:	e0bff947 	ldb	r2,-27(fp)
8111833c:	10800044 	addi	r2,r2,1
81118340:	1885883a 	add	r2,r3,r2
81118344:	10800003 	ldbu	r2,0(r2)
81118348:	10803fcc 	andi	r2,r2,255
8111834c:	1080010c 	andi	r2,r2,4
81118350:	10000626 	beq	r2,zero,8111836c <vLoadDefaultETHConf+0x374>
									(*p_inteiro) = c;
81118354:	e0bffa17 	ldw	r2,-24(fp)
81118358:	e0fff943 	ldbu	r3,-27(fp)
8111835c:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81118360:	e0bffa17 	ldw	r2,-24(fp)
81118364:	10800044 	addi	r2,r2,1
81118368:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
8111836c:	e0bff947 	ldb	r2,-27(fp)
81118370:	10800ba0 	cmpeqi	r2,r2,46
81118374:	1000031e 	bne	r2,zero,81118384 <vLoadDefaultETHConf+0x38c>
81118378:	e0bff947 	ldb	r2,-27(fp)
8111837c:	10800ed8 	cmpnei	r2,r2,59
81118380:	103fe81e 	bne	r2,zero,81118324 <__reset+0xfb0f8324>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81118384:	e0bffa17 	ldw	r2,-24(fp)
81118388:	00c00284 	movi	r3,10
8111838c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81118390:	e0bff903 	ldbu	r2,-28(fp)
81118394:	108000e8 	cmpgeui	r2,r2,3
81118398:	1000021e 	bne	r2,zero,811183a4 <vLoadDefaultETHConf+0x3ac>
8111839c:	e43ff903 	ldbu	r16,-28(fp)
811183a0:	00000106 	br	811183a8 <vLoadDefaultETHConf+0x3b0>
811183a4:	040000c4 	movi	r16,3
811183a8:	e0bffc84 	addi	r2,fp,-14
811183ac:	1009883a 	mov	r4,r2
811183b0:	111f4a00 	call	8111f4a0 <atoi>
811183b4:	1007883a 	mov	r3,r2
811183b8:	00a045b4 	movhi	r2,33046
811183bc:	1091c804 	addi	r2,r2,18208
811183c0:	1405883a 	add	r2,r2,r16
811183c4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811183c8:	e0bffc84 	addi	r2,fp,-14
811183cc:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811183d0:	e0bff903 	ldbu	r2,-28(fp)
811183d4:	10800044 	addi	r2,r2,1
811183d8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811183dc:	e0bff947 	ldb	r2,-27(fp)
811183e0:	10800ed8 	cmpnei	r2,r2,59
811183e4:	103fcf1e 	bne	r2,zero,81118324 <__reset+0xfb0f8324>

						break;
811183e8:	0000b706 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case 'G':

						ucParser = 0;
811183ec:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811183f0:	e0bffc0f 	ldh	r2,-16(fp)
811183f4:	1009883a 	mov	r4,r2
811183f8:	111cbe40 	call	8111cbe4 <cGetNextChar>
811183fc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81118400:	d0e00317 	ldw	r3,-32756(gp)
81118404:	e0bff947 	ldb	r2,-27(fp)
81118408:	10800044 	addi	r2,r2,1
8111840c:	1885883a 	add	r2,r3,r2
81118410:	10800003 	ldbu	r2,0(r2)
81118414:	10803fcc 	andi	r2,r2,255
81118418:	1080010c 	andi	r2,r2,4
8111841c:	10000626 	beq	r2,zero,81118438 <vLoadDefaultETHConf+0x440>
									(*p_inteiro) = c;
81118420:	e0bffa17 	ldw	r2,-24(fp)
81118424:	e0fff943 	ldbu	r3,-27(fp)
81118428:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
8111842c:	e0bffa17 	ldw	r2,-24(fp)
81118430:	10800044 	addi	r2,r2,1
81118434:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81118438:	e0bff947 	ldb	r2,-27(fp)
8111843c:	10800ba0 	cmpeqi	r2,r2,46
81118440:	1000031e 	bne	r2,zero,81118450 <vLoadDefaultETHConf+0x458>
81118444:	e0bff947 	ldb	r2,-27(fp)
81118448:	10800ed8 	cmpnei	r2,r2,59
8111844c:	103fe81e 	bne	r2,zero,811183f0 <__reset+0xfb0f83f0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81118450:	e0bffa17 	ldw	r2,-24(fp)
81118454:	00c00284 	movi	r3,10
81118458:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
8111845c:	e0bff903 	ldbu	r2,-28(fp)
81118460:	108000e8 	cmpgeui	r2,r2,3
81118464:	1000021e 	bne	r2,zero,81118470 <vLoadDefaultETHConf+0x478>
81118468:	e43ff903 	ldbu	r16,-28(fp)
8111846c:	00000106 	br	81118474 <vLoadDefaultETHConf+0x47c>
81118470:	040000c4 	movi	r16,3
81118474:	e0bffc84 	addi	r2,fp,-14
81118478:	1009883a 	mov	r4,r2
8111847c:	111f4a00 	call	8111f4a0 <atoi>
81118480:	1007883a 	mov	r3,r2
81118484:	00a045b4 	movhi	r2,33046
81118488:	1091c804 	addi	r2,r2,18208
8111848c:	1405883a 	add	r2,r2,r16
81118490:	10800104 	addi	r2,r2,4
81118494:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81118498:	e0bffc84 	addi	r2,fp,-14
8111849c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811184a0:	e0bff903 	ldbu	r2,-28(fp)
811184a4:	10800044 	addi	r2,r2,1
811184a8:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811184ac:	e0bff947 	ldb	r2,-27(fp)
811184b0:	10800ed8 	cmpnei	r2,r2,59
811184b4:	103fce1e 	bne	r2,zero,811183f0 <__reset+0xfb0f83f0>

						break;
811184b8:	00008306 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case 'H':

						ucParser = 0;
811184bc:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811184c0:	e0bffc0f 	ldh	r2,-16(fp)
811184c4:	1009883a 	mov	r4,r2
811184c8:	111cbe40 	call	8111cbe4 <cGetNextChar>
811184cc:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811184d0:	d0e00317 	ldw	r3,-32756(gp)
811184d4:	e0bff947 	ldb	r2,-27(fp)
811184d8:	10800044 	addi	r2,r2,1
811184dc:	1885883a 	add	r2,r3,r2
811184e0:	10800003 	ldbu	r2,0(r2)
811184e4:	10803fcc 	andi	r2,r2,255
811184e8:	1080010c 	andi	r2,r2,4
811184ec:	10000626 	beq	r2,zero,81118508 <vLoadDefaultETHConf+0x510>
									(*p_inteiro) = c;
811184f0:	e0bffa17 	ldw	r2,-24(fp)
811184f4:	e0fff943 	ldbu	r3,-27(fp)
811184f8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811184fc:	e0bffa17 	ldw	r2,-24(fp)
81118500:	10800044 	addi	r2,r2,1
81118504:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81118508:	e0bff947 	ldb	r2,-27(fp)
8111850c:	10800ba0 	cmpeqi	r2,r2,46
81118510:	1000031e 	bne	r2,zero,81118520 <vLoadDefaultETHConf+0x528>
81118514:	e0bff947 	ldb	r2,-27(fp)
81118518:	10800ed8 	cmpnei	r2,r2,59
8111851c:	103fe81e 	bne	r2,zero,811184c0 <__reset+0xfb0f84c0>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81118520:	e0bffa17 	ldw	r2,-24(fp)
81118524:	00c00284 	movi	r3,10
81118528:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
8111852c:	e0bff903 	ldbu	r2,-28(fp)
81118530:	108000e8 	cmpgeui	r2,r2,3
81118534:	1000021e 	bne	r2,zero,81118540 <vLoadDefaultETHConf+0x548>
81118538:	e43ff903 	ldbu	r16,-28(fp)
8111853c:	00000106 	br	81118544 <vLoadDefaultETHConf+0x54c>
81118540:	040000c4 	movi	r16,3
81118544:	e0bffc84 	addi	r2,fp,-14
81118548:	1009883a 	mov	r4,r2
8111854c:	111f4a00 	call	8111f4a0 <atoi>
81118550:	1007883a 	mov	r3,r2
81118554:	00a045b4 	movhi	r2,33046
81118558:	1091c804 	addi	r2,r2,18208
8111855c:	1405883a 	add	r2,r2,r16
81118560:	10800204 	addi	r2,r2,8
81118564:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81118568:	e0bffc84 	addi	r2,fp,-14
8111856c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81118570:	e0bff903 	ldbu	r2,-28(fp)
81118574:	10800044 	addi	r2,r2,1
81118578:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111857c:	e0bff947 	ldb	r2,-27(fp)
81118580:	10800ed8 	cmpnei	r2,r2,59
81118584:	103fce1e 	bne	r2,zero,811184c0 <__reset+0xfb0f84c0>

						break;
81118588:	00004f06 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case 'D':

						ucParser = 0;
8111858c:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81118590:	e0bffc0f 	ldh	r2,-16(fp)
81118594:	1009883a 	mov	r4,r2
81118598:	111cbe40 	call	8111cbe4 <cGetNextChar>
8111859c:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811185a0:	d0e00317 	ldw	r3,-32756(gp)
811185a4:	e0bff947 	ldb	r2,-27(fp)
811185a8:	10800044 	addi	r2,r2,1
811185ac:	1885883a 	add	r2,r3,r2
811185b0:	10800003 	ldbu	r2,0(r2)
811185b4:	10803fcc 	andi	r2,r2,255
811185b8:	1080010c 	andi	r2,r2,4
811185bc:	10000626 	beq	r2,zero,811185d8 <vLoadDefaultETHConf+0x5e0>
									(*p_inteiro) = c;
811185c0:	e0bffa17 	ldw	r2,-24(fp)
811185c4:	e0fff943 	ldbu	r3,-27(fp)
811185c8:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811185cc:	e0bffa17 	ldw	r2,-24(fp)
811185d0:	10800044 	addi	r2,r2,1
811185d4:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811185d8:	e0bff947 	ldb	r2,-27(fp)
811185dc:	10800ba0 	cmpeqi	r2,r2,46
811185e0:	1000031e 	bne	r2,zero,811185f0 <vLoadDefaultETHConf+0x5f8>
811185e4:	e0bff947 	ldb	r2,-27(fp)
811185e8:	10800ed8 	cmpnei	r2,r2,59
811185ec:	103fe81e 	bne	r2,zero,81118590 <__reset+0xfb0f8590>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811185f0:	e0bffa17 	ldw	r2,-24(fp)
811185f4:	00c00284 	movi	r3,10
811185f8:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
811185fc:	e0bff903 	ldbu	r2,-28(fp)
81118600:	108000e8 	cmpgeui	r2,r2,3
81118604:	1000021e 	bne	r2,zero,81118610 <vLoadDefaultETHConf+0x618>
81118608:	e43ff903 	ldbu	r16,-28(fp)
8111860c:	00000106 	br	81118614 <vLoadDefaultETHConf+0x61c>
81118610:	040000c4 	movi	r16,3
81118614:	e0bffc84 	addi	r2,fp,-14
81118618:	1009883a 	mov	r4,r2
8111861c:	111f4a00 	call	8111f4a0 <atoi>
81118620:	1007883a 	mov	r3,r2
81118624:	00a045b4 	movhi	r2,33046
81118628:	1091c804 	addi	r2,r2,18208
8111862c:	1405883a 	add	r2,r2,r16
81118630:	10800304 	addi	r2,r2,12
81118634:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81118638:	e0bffc84 	addi	r2,fp,-14
8111863c:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81118640:	e0bff903 	ldbu	r2,-28(fp)
81118644:	10800044 	addi	r2,r2,1
81118648:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
8111864c:	e0bff947 	ldb	r2,-27(fp)
81118650:	10800ed8 	cmpnei	r2,r2,59
81118654:	103fce1e 	bne	r2,zero,81118590 <__reset+0xfb0f8590>

						break;						
81118658:	00001b06 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
8111865c:	e0bffc0f 	ldh	r2,-16(fp)
81118660:	1009883a 	mov	r4,r2
81118664:	111cba40 	call	8111cba4 <siCloseFile>
81118668:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
8111866c:	e0bffb17 	ldw	r2,-20(fp)
81118670:	1000071e 	bne	r2,zero,81118690 <vLoadDefaultETHConf+0x698>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
81118674:	d0a06117 	ldw	r2,-32380(gp)
81118678:	100f883a 	mov	r7,r2
8111867c:	01800784 	movi	r6,30
81118680:	01400044 	movi	r5,1
81118684:	01204574 	movhi	r4,33045
81118688:	21314d04 	addi	r4,r4,-15052
8111868c:	111fc980 	call	8111fc98 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81118690:	00800044 	movi	r2,1
81118694:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81118698:	00800044 	movi	r2,1
8111869c:	e0bff715 	stw	r2,-36(fp)
						break;
811186a0:	00000906 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
811186a4:	d0a06117 	ldw	r2,-32380(gp)
811186a8:	100f883a 	mov	r7,r2
811186ac:	01800844 	movi	r6,33
811186b0:	01400044 	movi	r5,1
811186b4:	01204574 	movhi	r4,33045
811186b8:	21315504 	addi	r4,r4,-15020
811186bc:	111fc980 	call	8111fc98 <fwrite>
						#endif
						break;
811186c0:	00000106 	br	811186c8 <vLoadDefaultETHConf+0x6d0>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
811186c4:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
811186c8:	e0bff817 	ldw	r2,-32(fp)
811186cc:	103e6826 	beq	r2,zero,81118070 <__reset+0xfb0f8070>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
811186d0:	00000f06 	br	81118710 <vLoadDefaultETHConf+0x718>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
811186d4:	d0a06117 	ldw	r2,-32380(gp)
811186d8:	100f883a 	mov	r7,r2
811186dc:	01800604 	movi	r6,24
811186e0:	01400044 	movi	r5,1
811186e4:	01204574 	movhi	r4,33045
811186e8:	21315e04 	addi	r4,r4,-14984
811186ec:	111fc980 	call	8111fc98 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
811186f0:	00000706 	br	81118710 <vLoadDefaultETHConf+0x718>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
811186f4:	d0a06117 	ldw	r2,-32380(gp)
811186f8:	100f883a 	mov	r7,r2
811186fc:	018004c4 	movi	r6,19
81118700:	01400044 	movi	r5,1
81118704:	01204574 	movhi	r4,33045
81118708:	21316504 	addi	r4,r4,-14956
8111870c:	111fc980 	call	8111fc98 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81118710:	e0bff717 	ldw	r2,-36(fp)
81118714:	1000541e 	bne	r2,zero,81118868 <vLoadDefaultETHConf+0x870>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81118718:	01204574 	movhi	r4,33045
8111871c:	21316a04 	addi	r4,r4,-14936
81118720:	1120c480 	call	81120c48 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
81118724:	01604574 	movhi	r5,33045
81118728:	29714404 	addi	r5,r5,-15088
8111872c:	01204574 	movhi	r4,33045
81118730:	21317e04 	addi	r4,r4,-14856
81118734:	11209c40 	call	811209c4 <printf>


		xConfEth.siPortPUS = 17000;
81118738:	00a045b4 	movhi	r2,33046
8111873c:	1091c804 	addi	r2,r2,18208
81118740:	00d09a04 	movi	r3,17000
81118744:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
81118748:	00a045b4 	movhi	r2,33046
8111874c:	1091c804 	addi	r2,r2,18208
81118750:	00fff004 	movi	r3,-64
81118754:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
81118758:	00a045b4 	movhi	r2,33046
8111875c:	1091c804 	addi	r2,r2,18208
81118760:	00ffea04 	movi	r3,-88
81118764:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
81118768:	00a045b4 	movhi	r2,33046
8111876c:	1091c804 	addi	r2,r2,18208
81118770:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
81118774:	00a045b4 	movhi	r2,33046
81118778:	1091c804 	addi	r2,r2,18208
8111877c:	00c00144 	movi	r3,5
81118780:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
81118784:	00a045b4 	movhi	r2,33046
81118788:	1091c804 	addi	r2,r2,18208
8111878c:	00fff004 	movi	r3,-64
81118790:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
81118794:	00a045b4 	movhi	r2,33046
81118798:	1091c804 	addi	r2,r2,18208
8111879c:	00ffea04 	movi	r3,-88
811187a0:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
811187a4:	00a045b4 	movhi	r2,33046
811187a8:	1091c804 	addi	r2,r2,18208
811187ac:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
811187b0:	00a045b4 	movhi	r2,33046
811187b4:	1091c804 	addi	r2,r2,18208
811187b8:	00c00044 	movi	r3,1
811187bc:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
811187c0:	00a045b4 	movhi	r2,33046
811187c4:	1091c804 	addi	r2,r2,18208
811187c8:	00ffffc4 	movi	r3,-1
811187cc:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
811187d0:	00a045b4 	movhi	r2,33046
811187d4:	1091c804 	addi	r2,r2,18208
811187d8:	00ffffc4 	movi	r3,-1
811187dc:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
811187e0:	00a045b4 	movhi	r2,33046
811187e4:	1091c804 	addi	r2,r2,18208
811187e8:	00ffffc4 	movi	r3,-1
811187ec:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
811187f0:	00a045b4 	movhi	r2,33046
811187f4:	1091c804 	addi	r2,r2,18208
811187f8:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
811187fc:	00a045b4 	movhi	r2,33046
81118800:	1091c804 	addi	r2,r2,18208
81118804:	00ffff04 	movi	r3,-4
81118808:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
8111880c:	00a045b4 	movhi	r2,33046
81118810:	1091c804 	addi	r2,r2,18208
81118814:	00fffdc4 	movi	r3,-9
81118818:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
8111881c:	00a045b4 	movhi	r2,33046
81118820:	1091c804 	addi	r2,r2,18208
81118824:	00c018c4 	movi	r3,99
81118828:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
8111882c:	00a045b4 	movhi	r2,33046
81118830:	1091c804 	addi	r2,r2,18208
81118834:	00c01344 	movi	r3,77
81118838:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
8111883c:	00a045b4 	movhi	r2,33046
81118840:	1091c804 	addi	r2,r2,18208
81118844:	00c007c4 	movi	r3,31
81118848:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
8111884c:	00a045b4 	movhi	r2,33046
81118850:	1091c804 	addi	r2,r2,18208
81118854:	00c01084 	movi	r3,66
81118858:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
8111885c:	00a045b4 	movhi	r2,33046
81118860:	1091c804 	addi	r2,r2,18208
81118864:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
81118868:	e0bff717 	ldw	r2,-36(fp)
}
8111886c:	e6ffff04 	addi	sp,fp,-4
81118870:	dfc00217 	ldw	ra,8(sp)
81118874:	df000117 	ldw	fp,4(sp)
81118878:	dc000017 	ldw	r16,0(sp)
8111887c:	dec00304 	addi	sp,sp,12
81118880:	f800283a 	ret

81118884 <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
81118884:	defff004 	addi	sp,sp,-64
81118888:	de00012e 	bgeu	sp,et,81118890 <vShowEthConfig+0xc>
8111888c:	003b68fa 	trap	3
81118890:	dfc00f15 	stw	ra,60(sp)
81118894:	df000e15 	stw	fp,56(sp)
81118898:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
8111889c:	d0a06117 	ldw	r2,-32380(gp)
811188a0:	100f883a 	mov	r7,r2
811188a4:	018007c4 	movi	r6,31
811188a8:	01400044 	movi	r5,1
811188ac:	01204574 	movhi	r4,33045
811188b0:	21318404 	addi	r4,r4,-14832
811188b4:	111fc980 	call	8111fc98 <fwrite>

		memset(buffer,0,40);
811188b8:	01800a04 	movi	r6,40
811188bc:	000b883a 	mov	r5,zero
811188c0:	e13ff604 	addi	r4,fp,-40
811188c4:	11207fc0 	call	811207fc <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
811188c8:	00a045b4 	movhi	r2,33046
811188cc:	1091c804 	addi	r2,r2,18208
811188d0:	10800403 	ldbu	r2,16(r2)
811188d4:	11803fcc 	andi	r6,r2,255
811188d8:	00a045b4 	movhi	r2,33046
811188dc:	1091c804 	addi	r2,r2,18208
811188e0:	10800443 	ldbu	r2,17(r2)
811188e4:	11c03fcc 	andi	r7,r2,255
811188e8:	00a045b4 	movhi	r2,33046
811188ec:	1091c804 	addi	r2,r2,18208
811188f0:	10800483 	ldbu	r2,18(r2)
811188f4:	10c03fcc 	andi	r3,r2,255
811188f8:	00a045b4 	movhi	r2,33046
811188fc:	1091c804 	addi	r2,r2,18208
81118900:	108004c3 	ldbu	r2,19(r2)
81118904:	11003fcc 	andi	r4,r2,255
81118908:	00a045b4 	movhi	r2,33046
8111890c:	1091c804 	addi	r2,r2,18208
81118910:	10800503 	ldbu	r2,20(r2)
81118914:	11403fcc 	andi	r5,r2,255
81118918:	00a045b4 	movhi	r2,33046
8111891c:	1091c804 	addi	r2,r2,18208
81118920:	10800543 	ldbu	r2,21(r2)
81118924:	10803fcc 	andi	r2,r2,255
81118928:	d8800315 	stw	r2,12(sp)
8111892c:	d9400215 	stw	r5,8(sp)
81118930:	d9000115 	stw	r4,4(sp)
81118934:	d8c00015 	stw	r3,0(sp)
81118938:	01604574 	movhi	r5,33045
8111893c:	29718c04 	addi	r5,r5,-14800
81118940:	e13ff604 	addi	r4,fp,-40
81118944:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer );
81118948:	d0a06117 	ldw	r2,-32380(gp)
8111894c:	e17ff604 	addi	r5,fp,-40
81118950:	1009883a 	mov	r4,r2
81118954:	111f5fc0 	call	8111f5fc <fprintf>

		memset(buffer,0,40);
81118958:	01800a04 	movi	r6,40
8111895c:	000b883a 	mov	r5,zero
81118960:	e13ff604 	addi	r4,fp,-40
81118964:	11207fc0 	call	811207fc <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
81118968:	00a045b4 	movhi	r2,33046
8111896c:	1091c804 	addi	r2,r2,18208
81118970:	10800003 	ldbu	r2,0(r2)
81118974:	11003fcc 	andi	r4,r2,255
81118978:	00a045b4 	movhi	r2,33046
8111897c:	1091c804 	addi	r2,r2,18208
81118980:	10800043 	ldbu	r2,1(r2)
81118984:	11403fcc 	andi	r5,r2,255
81118988:	00a045b4 	movhi	r2,33046
8111898c:	1091c804 	addi	r2,r2,18208
81118990:	10800083 	ldbu	r2,2(r2)
81118994:	10c03fcc 	andi	r3,r2,255
81118998:	00a045b4 	movhi	r2,33046
8111899c:	1091c804 	addi	r2,r2,18208
811189a0:	108000c3 	ldbu	r2,3(r2)
811189a4:	10803fcc 	andi	r2,r2,255
811189a8:	d8800115 	stw	r2,4(sp)
811189ac:	d8c00015 	stw	r3,0(sp)
811189b0:	280f883a 	mov	r7,r5
811189b4:	200d883a 	mov	r6,r4
811189b8:	01604574 	movhi	r5,33045
811189bc:	29719504 	addi	r5,r5,-14764
811189c0:	e13ff604 	addi	r4,fp,-40
811189c4:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer );
811189c8:	d0a06117 	ldw	r2,-32380(gp)
811189cc:	e17ff604 	addi	r5,fp,-40
811189d0:	1009883a 	mov	r4,r2
811189d4:	111f5fc0 	call	8111f5fc <fprintf>

		memset(buffer,0,40);
811189d8:	01800a04 	movi	r6,40
811189dc:	000b883a 	mov	r5,zero
811189e0:	e13ff604 	addi	r4,fp,-40
811189e4:	11207fc0 	call	811207fc <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
811189e8:	00a045b4 	movhi	r2,33046
811189ec:	1091c804 	addi	r2,r2,18208
811189f0:	10800103 	ldbu	r2,4(r2)
811189f4:	11003fcc 	andi	r4,r2,255
811189f8:	00a045b4 	movhi	r2,33046
811189fc:	1091c804 	addi	r2,r2,18208
81118a00:	10800143 	ldbu	r2,5(r2)
81118a04:	11403fcc 	andi	r5,r2,255
81118a08:	00a045b4 	movhi	r2,33046
81118a0c:	1091c804 	addi	r2,r2,18208
81118a10:	10800183 	ldbu	r2,6(r2)
81118a14:	10c03fcc 	andi	r3,r2,255
81118a18:	00a045b4 	movhi	r2,33046
81118a1c:	1091c804 	addi	r2,r2,18208
81118a20:	108001c3 	ldbu	r2,7(r2)
81118a24:	10803fcc 	andi	r2,r2,255
81118a28:	d8800115 	stw	r2,4(sp)
81118a2c:	d8c00015 	stw	r3,0(sp)
81118a30:	280f883a 	mov	r7,r5
81118a34:	200d883a 	mov	r6,r4
81118a38:	01604574 	movhi	r5,33045
81118a3c:	29719b04 	addi	r5,r5,-14740
81118a40:	e13ff604 	addi	r4,fp,-40
81118a44:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer );
81118a48:	d0a06117 	ldw	r2,-32380(gp)
81118a4c:	e17ff604 	addi	r5,fp,-40
81118a50:	1009883a 	mov	r4,r2
81118a54:	111f5fc0 	call	8111f5fc <fprintf>

		memset(buffer,0,40);
81118a58:	01800a04 	movi	r6,40
81118a5c:	000b883a 	mov	r5,zero
81118a60:	e13ff604 	addi	r4,fp,-40
81118a64:	11207fc0 	call	811207fc <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
81118a68:	00a045b4 	movhi	r2,33046
81118a6c:	1091c804 	addi	r2,r2,18208
81118a70:	10800203 	ldbu	r2,8(r2)
81118a74:	11003fcc 	andi	r4,r2,255
81118a78:	00a045b4 	movhi	r2,33046
81118a7c:	1091c804 	addi	r2,r2,18208
81118a80:	10800243 	ldbu	r2,9(r2)
81118a84:	11403fcc 	andi	r5,r2,255
81118a88:	00a045b4 	movhi	r2,33046
81118a8c:	1091c804 	addi	r2,r2,18208
81118a90:	10800283 	ldbu	r2,10(r2)
81118a94:	10c03fcc 	andi	r3,r2,255
81118a98:	00a045b4 	movhi	r2,33046
81118a9c:	1091c804 	addi	r2,r2,18208
81118aa0:	108002c3 	ldbu	r2,11(r2)
81118aa4:	10803fcc 	andi	r2,r2,255
81118aa8:	d8800115 	stw	r2,4(sp)
81118aac:	d8c00015 	stw	r3,0(sp)
81118ab0:	280f883a 	mov	r7,r5
81118ab4:	200d883a 	mov	r6,r4
81118ab8:	01604574 	movhi	r5,33045
81118abc:	2971a204 	addi	r5,r5,-14712
81118ac0:	e13ff604 	addi	r4,fp,-40
81118ac4:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer );
81118ac8:	d0a06117 	ldw	r2,-32380(gp)
81118acc:	e17ff604 	addi	r5,fp,-40
81118ad0:	1009883a 	mov	r4,r2
81118ad4:	111f5fc0 	call	8111f5fc <fprintf>

		memset(buffer,0,40);
81118ad8:	01800a04 	movi	r6,40
81118adc:	000b883a 	mov	r5,zero
81118ae0:	e13ff604 	addi	r4,fp,-40
81118ae4:	11207fc0 	call	811207fc <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81118ae8:	00a045b4 	movhi	r2,33046
81118aec:	1091c804 	addi	r2,r2,18208
81118af0:	10800303 	ldbu	r2,12(r2)
81118af4:	11003fcc 	andi	r4,r2,255
81118af8:	00a045b4 	movhi	r2,33046
81118afc:	1091c804 	addi	r2,r2,18208
81118b00:	10800343 	ldbu	r2,13(r2)
81118b04:	11403fcc 	andi	r5,r2,255
81118b08:	00a045b4 	movhi	r2,33046
81118b0c:	1091c804 	addi	r2,r2,18208
81118b10:	10800383 	ldbu	r2,14(r2)
81118b14:	10c03fcc 	andi	r3,r2,255
81118b18:	00a045b4 	movhi	r2,33046
81118b1c:	1091c804 	addi	r2,r2,18208
81118b20:	108003c3 	ldbu	r2,15(r2)
81118b24:	10803fcc 	andi	r2,r2,255
81118b28:	d8800115 	stw	r2,4(sp)
81118b2c:	d8c00015 	stw	r3,0(sp)
81118b30:	280f883a 	mov	r7,r5
81118b34:	200d883a 	mov	r6,r4
81118b38:	01604574 	movhi	r5,33045
81118b3c:	2971a904 	addi	r5,r5,-14684
81118b40:	e13ff604 	addi	r4,fp,-40
81118b44:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer );
81118b48:	d0a06117 	ldw	r2,-32380(gp)
81118b4c:	e17ff604 	addi	r5,fp,-40
81118b50:	1009883a 	mov	r4,r2
81118b54:	111f5fc0 	call	8111f5fc <fprintf>

		memset(buffer,0,40);
81118b58:	01800a04 	movi	r6,40
81118b5c:	000b883a 	mov	r5,zero
81118b60:	e13ff604 	addi	r4,fp,-40
81118b64:	11207fc0 	call	811207fc <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
81118b68:	00a045b4 	movhi	r2,33046
81118b6c:	1091c804 	addi	r2,r2,18208
81118b70:	1080058b 	ldhu	r2,22(r2)
81118b74:	10bfffcc 	andi	r2,r2,65535
81118b78:	100d883a 	mov	r6,r2
81118b7c:	01604574 	movhi	r5,33045
81118b80:	2971b004 	addi	r5,r5,-14656
81118b84:	e13ff604 	addi	r4,fp,-40
81118b88:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer );
81118b8c:	d0a06117 	ldw	r2,-32380(gp)
81118b90:	e17ff604 	addi	r5,fp,-40
81118b94:	1009883a 	mov	r4,r2
81118b98:	111f5fc0 	call	8111f5fc <fprintf>

	}
81118b9c:	0001883a 	nop
81118ba0:	e037883a 	mov	sp,fp
81118ba4:	dfc00117 	ldw	ra,4(sp)
81118ba8:	df000017 	ldw	fp,0(sp)
81118bac:	dec00204 	addi	sp,sp,8
81118bb0:	f800283a 	ret

81118bb4 <vLoadDebugConfs>:





bool vLoadDebugConfs( void ){
81118bb4:	defff504 	addi	sp,sp,-44
81118bb8:	de00012e 	bgeu	sp,et,81118bc0 <vLoadDebugConfs+0xc>
81118bbc:	003b68fa 	trap	3
81118bc0:	dfc00a15 	stw	ra,40(sp)
81118bc4:	df000915 	stw	fp,36(sp)
81118bc8:	dc000815 	stw	r16,32(sp)
81118bcc:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81118bd0:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81118bd4:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81118bd8:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81118bdc:	d0a07517 	ldw	r2,-32300(gp)
81118be0:	10800058 	cmpnei	r2,r2,1
81118be4:	1002a31e 	bne	r2,zero,81119674 <vLoadDebugConfs+0xac0>
81118be8:	111ca100 	call	8111ca10 <bSDcardIsPresent>
81118bec:	1002a126 	beq	r2,zero,81119674 <vLoadDebugConfs+0xac0>
81118bf0:	111ca400 	call	8111ca40 <bSDcardFAT16Check>
81118bf4:	10029f26 	beq	r2,zero,81119674 <vLoadDebugConfs+0xac0>

		siFile = siOpenFile( DEBUG_FILE_NAME );
81118bf8:	01204574 	movhi	r4,33045
81118bfc:	2131b404 	addi	r4,r4,-14640
81118c00:	111cb680 	call	8111cb68 <siOpenFile>
81118c04:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81118c08:	e0bffc0f 	ldh	r2,-16(fp)
81118c0c:	10029116 	blt	r2,zero,81119654 <vLoadDebugConfs+0xaa0>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81118c10:	e0bffd04 	addi	r2,fp,-12
81118c14:	01800204 	movi	r6,8
81118c18:	01400284 	movi	r5,10
81118c1c:	1009883a 	mov	r4,r2
81118c20:	11207fc0 	call	811207fc <memset>
			p_inteiro = inteiro;
81118c24:	e0bffd04 	addi	r2,fp,-12
81118c28:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81118c2c:	e0bffc0f 	ldh	r2,-16(fp)
81118c30:	1009883a 	mov	r4,r2
81118c34:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118c38:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81118c3c:	e0bff947 	ldb	r2,-27(fp)
81118c40:	10800084 	addi	r2,r2,2
81118c44:	10c015e8 	cmpgeui	r3,r2,87
81118c48:	1802761e 	bne	r3,zero,81119624 <vLoadDebugConfs+0xa70>
81118c4c:	100690ba 	slli	r3,r2,2
81118c50:	00a044b4 	movhi	r2,33042
81118c54:	10a31904 	addi	r2,r2,-29596
81118c58:	1885883a 	add	r2,r3,r2
81118c5c:	10800017 	ldw	r2,0(r2)
81118c60:	1000683a 	jmp	r2
81118c64:	81118e00 	call	881118e0 <__reset+0x20f18e0>
81118c68:	81118df4 	orhi	r4,r16,17975
81118c6c:	81119624 	muli	r4,r16,18008
81118c70:	81119624 	muli	r4,r16,18008
81118c74:	81119624 	muli	r4,r16,18008
81118c78:	81119624 	muli	r4,r16,18008
81118c7c:	81119624 	muli	r4,r16,18008
81118c80:	81119624 	muli	r4,r16,18008
81118c84:	81119624 	muli	r4,r16,18008
81118c88:	81119624 	muli	r4,r16,18008
81118c8c:	81119624 	muli	r4,r16,18008
81118c90:	81119624 	muli	r4,r16,18008
81118c94:	81119644 	addi	r4,r16,18009
81118c98:	81119624 	muli	r4,r16,18008
81118c9c:	81119624 	muli	r4,r16,18008
81118ca0:	81119644 	addi	r4,r16,18009
81118ca4:	81119624 	muli	r4,r16,18008
81118ca8:	81119624 	muli	r4,r16,18008
81118cac:	81119624 	muli	r4,r16,18008
81118cb0:	81119624 	muli	r4,r16,18008
81118cb4:	81119624 	muli	r4,r16,18008
81118cb8:	81119624 	muli	r4,r16,18008
81118cbc:	81119624 	muli	r4,r16,18008
81118cc0:	81119624 	muli	r4,r16,18008
81118cc4:	81119624 	muli	r4,r16,18008
81118cc8:	81119624 	muli	r4,r16,18008
81118ccc:	81119624 	muli	r4,r16,18008
81118cd0:	81119624 	muli	r4,r16,18008
81118cd4:	81119624 	muli	r4,r16,18008
81118cd8:	81119624 	muli	r4,r16,18008
81118cdc:	81119624 	muli	r4,r16,18008
81118ce0:	81119624 	muli	r4,r16,18008
81118ce4:	81119624 	muli	r4,r16,18008
81118ce8:	81119624 	muli	r4,r16,18008
81118cec:	81119644 	addi	r4,r16,18009
81118cf0:	81119624 	muli	r4,r16,18008
81118cf4:	81119624 	muli	r4,r16,18008
81118cf8:	81119624 	muli	r4,r16,18008
81118cfc:	81119624 	muli	r4,r16,18008
81118d00:	81119624 	muli	r4,r16,18008
81118d04:	81119624 	muli	r4,r16,18008
81118d08:	81118dc0 	call	881118dc <__reset+0x20f18dc>
81118d0c:	81119624 	muli	r4,r16,18008
81118d10:	81119624 	muli	r4,r16,18008
81118d14:	81119624 	muli	r4,r16,18008
81118d18:	81119624 	muli	r4,r16,18008
81118d1c:	81119624 	muli	r4,r16,18008
81118d20:	81119624 	muli	r4,r16,18008
81118d24:	81119624 	muli	r4,r16,18008
81118d28:	81119624 	muli	r4,r16,18008
81118d2c:	81119624 	muli	r4,r16,18008
81118d30:	81119624 	muli	r4,r16,18008
81118d34:	81119624 	muli	r4,r16,18008
81118d38:	81119624 	muli	r4,r16,18008
81118d3c:	81119624 	muli	r4,r16,18008
81118d40:	81119624 	muli	r4,r16,18008
81118d44:	81119624 	muli	r4,r16,18008
81118d48:	81119624 	muli	r4,r16,18008
81118d4c:	81119624 	muli	r4,r16,18008
81118d50:	81119624 	muli	r4,r16,18008
81118d54:	81119624 	muli	r4,r16,18008
81118d58:	81119624 	muli	r4,r16,18008
81118d5c:	811195dc 	xori	r4,r16,18007
81118d60:	81119624 	muli	r4,r16,18008
81118d64:	81119624 	muli	r4,r16,18008
81118d68:	81119624 	muli	r4,r16,18008
81118d6c:	81119624 	muli	r4,r16,18008
81118d70:	81119624 	muli	r4,r16,18008
81118d74:	81119624 	muli	r4,r16,18008
81118d78:	81119198 	cmpnei	r4,r16,17990
81118d7c:	81119314 	ori	r4,r16,17996
81118d80:	81119624 	muli	r4,r16,18008
81118d84:	81119624 	muli	r4,r16,18008
81118d88:	81119624 	muli	r4,r16,18008
81118d8c:	81119248 	cmpgei	r4,r16,17993
81118d90:	81119624 	muli	r4,r16,18008
81118d94:	811194ac 	andhi	r4,r16,18002
81118d98:	8111939c 	xori	r4,r16,17998
81118d9c:	81119038 	rdprs	r4,r16,17984
81118da0:	81119424 	muli	r4,r16,18000
81118da4:	81118f88 	cmpgei	r4,r16,17982
81118da8:	811190e8 	cmpgeui	r4,r16,17987
81118dac:	81118ed8 	cmpnei	r4,r16,17979
81118db0:	81119624 	muli	r4,r16,18008
81118db4:	81119624 	muli	r4,r16,18008
81118db8:	81118e28 	cmpgeui	r4,r16,17976
81118dbc:	81119534 	orhi	r4,r16,18004
					case 39:// single quote '
						c = cGetNextChar(siFile);
81118dc0:	e0bffc0f 	ldh	r2,-16(fp)
81118dc4:	1009883a 	mov	r4,r2
81118dc8:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118dcc:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81118dd0:	00000406 	br	81118de4 <vLoadDebugConfs+0x230>
							c = cGetNextChar(siFile);
81118dd4:	e0bffc0f 	ldh	r2,-16(fp)
81118dd8:	1009883a 	mov	r4,r2
81118ddc:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118de0:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81118de4:	e0bff947 	ldb	r2,-27(fp)
81118de8:	108009d8 	cmpnei	r2,r2,39
81118dec:	103ff91e 	bne	r2,zero,81118dd4 <__reset+0xfb0f8dd4>
							c = cGetNextChar(siFile);
						}
						break;
81118df0:	00021506 	br	81119648 <vLoadDebugConfs+0xa94>
					case -1: 	//EOF
						bEOF = TRUE;
81118df4:	00800044 	movi	r2,1
81118df8:	e0bff815 	stw	r2,-32(fp)
						break;
81118dfc:	00021206 	br	81119648 <vLoadDebugConfs+0xa94>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81118e00:	d0a06117 	ldw	r2,-32380(gp)
81118e04:	100f883a 	mov	r7,r2
81118e08:	018006c4 	movi	r6,27
81118e0c:	01400044 	movi	r5,1
81118e10:	01204574 	movhi	r4,33045
81118e14:	21314604 	addi	r4,r4,-15080
81118e18:	111fc980 	call	8111fc98 <fwrite>
						#endif
						bEOF = TRUE;
81118e1c:	00800044 	movi	r2,1
81118e20:	e0bff815 	stw	r2,-32(fp)
						break;
81118e24:	00020806 	br	81119648 <vLoadDebugConfs+0xa94>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;

					case 'S':
						ucParser = 0;
81118e28:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81118e2c:	e0bffc0f 	ldh	r2,-16(fp)
81118e30:	1009883a 	mov	r4,r2
81118e34:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118e38:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81118e3c:	d0e00317 	ldw	r3,-32756(gp)
81118e40:	e0bff947 	ldb	r2,-27(fp)
81118e44:	10800044 	addi	r2,r2,1
81118e48:	1885883a 	add	r2,r3,r2
81118e4c:	10800003 	ldbu	r2,0(r2)
81118e50:	10803fcc 	andi	r2,r2,255
81118e54:	1080010c 	andi	r2,r2,4
81118e58:	10000626 	beq	r2,zero,81118e74 <vLoadDebugConfs+0x2c0>
									(*p_inteiro) = c;
81118e5c:	e0bffa17 	ldw	r2,-24(fp)
81118e60:	e0fff943 	ldbu	r3,-27(fp)
81118e64:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81118e68:	e0bffa17 	ldw	r2,-24(fp)
81118e6c:	10800044 	addi	r2,r2,1
81118e70:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81118e74:	e0bff947 	ldb	r2,-27(fp)
81118e78:	10800ba0 	cmpeqi	r2,r2,46
81118e7c:	1000031e 	bne	r2,zero,81118e8c <vLoadDebugConfs+0x2d8>
81118e80:	e0bff947 	ldb	r2,-27(fp)
81118e84:	10800ed8 	cmpnei	r2,r2,59
81118e88:	103fe81e 	bne	r2,zero,81118e2c <__reset+0xfb0f8e2c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81118e8c:	e0bffa17 	ldw	r2,-24(fp)
81118e90:	00c00284 	movi	r3,10
81118e94:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiSyncPeriod = atoi( inteiro );
81118e98:	e0bffd04 	addi	r2,fp,-12
81118e9c:	1009883a 	mov	r4,r2
81118ea0:	111f4a00 	call	8111f4a0 <atoi>
81118ea4:	1007883a 	mov	r3,r2
81118ea8:	00a045b4 	movhi	r2,33046
81118eac:	1091bc04 	addi	r2,r2,18160
81118eb0:	10c0068d 	sth	r3,26(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81118eb4:	e0bffd04 	addi	r2,fp,-12
81118eb8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81118ebc:	e0bff903 	ldbu	r2,-28(fp)
81118ec0:	10800044 	addi	r2,r2,1
81118ec4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81118ec8:	e0bff947 	ldb	r2,-27(fp)
81118ecc:	10800ed8 	cmpnei	r2,r2,59
81118ed0:	103fd61e 	bne	r2,zero,81118e2c <__reset+0xfb0f8e2c>

						break;
81118ed4:	0001dc06 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'P':
						ucParser = 0;
81118ed8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81118edc:	e0bffc0f 	ldh	r2,-16(fp)
81118ee0:	1009883a 	mov	r4,r2
81118ee4:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118ee8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81118eec:	d0e00317 	ldw	r3,-32756(gp)
81118ef0:	e0bff947 	ldb	r2,-27(fp)
81118ef4:	10800044 	addi	r2,r2,1
81118ef8:	1885883a 	add	r2,r3,r2
81118efc:	10800003 	ldbu	r2,0(r2)
81118f00:	10803fcc 	andi	r2,r2,255
81118f04:	1080010c 	andi	r2,r2,4
81118f08:	10000626 	beq	r2,zero,81118f24 <vLoadDebugConfs+0x370>
									(*p_inteiro) = c;
81118f0c:	e0bffa17 	ldw	r2,-24(fp)
81118f10:	e0fff943 	ldbu	r3,-27(fp)
81118f14:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81118f18:	e0bffa17 	ldw	r2,-24(fp)
81118f1c:	10800044 	addi	r2,r2,1
81118f20:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81118f24:	e0bff947 	ldb	r2,-27(fp)
81118f28:	10800ba0 	cmpeqi	r2,r2,46
81118f2c:	1000031e 	bne	r2,zero,81118f3c <vLoadDebugConfs+0x388>
81118f30:	e0bff947 	ldb	r2,-27(fp)
81118f34:	10800ed8 	cmpnei	r2,r2,59
81118f38:	103fe81e 	bne	r2,zero,81118edc <__reset+0xfb0f8edc>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81118f3c:	e0bffa17 	ldw	r2,-24(fp)
81118f40:	00c00284 	movi	r3,10
81118f44:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiPreScanSerial = atoi( inteiro );
81118f48:	e0bffd04 	addi	r2,fp,-12
81118f4c:	1009883a 	mov	r4,r2
81118f50:	111f4a00 	call	8111f4a0 <atoi>
81118f54:	1007883a 	mov	r3,r2
81118f58:	00a045b4 	movhi	r2,33046
81118f5c:	1091bc04 	addi	r2,r2,18160
81118f60:	10c0048d 	sth	r3,18(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81118f64:	e0bffd04 	addi	r2,fp,-12
81118f68:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81118f6c:	e0bff903 	ldbu	r2,-28(fp)
81118f70:	10800044 	addi	r2,r2,1
81118f74:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81118f78:	e0bff947 	ldb	r2,-27(fp)
81118f7c:	10800ed8 	cmpnei	r2,r2,59
81118f80:	103fd61e 	bne	r2,zero,81118edc <__reset+0xfb0f8edc>

						break;
81118f84:	0001b006 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'N':
						ucParser = 0;
81118f88:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81118f8c:	e0bffc0f 	ldh	r2,-16(fp)
81118f90:	1009883a 	mov	r4,r2
81118f94:	111cbe40 	call	8111cbe4 <cGetNextChar>
81118f98:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81118f9c:	d0e00317 	ldw	r3,-32756(gp)
81118fa0:	e0bff947 	ldb	r2,-27(fp)
81118fa4:	10800044 	addi	r2,r2,1
81118fa8:	1885883a 	add	r2,r3,r2
81118fac:	10800003 	ldbu	r2,0(r2)
81118fb0:	10803fcc 	andi	r2,r2,255
81118fb4:	1080010c 	andi	r2,r2,4
81118fb8:	10000626 	beq	r2,zero,81118fd4 <vLoadDebugConfs+0x420>
									(*p_inteiro) = c;
81118fbc:	e0bffa17 	ldw	r2,-24(fp)
81118fc0:	e0fff943 	ldbu	r3,-27(fp)
81118fc4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81118fc8:	e0bffa17 	ldw	r2,-24(fp)
81118fcc:	10800044 	addi	r2,r2,1
81118fd0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81118fd4:	e0bff947 	ldb	r2,-27(fp)
81118fd8:	10800ba0 	cmpeqi	r2,r2,46
81118fdc:	1000031e 	bne	r2,zero,81118fec <vLoadDebugConfs+0x438>
81118fe0:	e0bff947 	ldb	r2,-27(fp)
81118fe4:	10800ed8 	cmpnei	r2,r2,59
81118fe8:	103fe81e 	bne	r2,zero,81118f8c <__reset+0xfb0f8f8c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81118fec:	e0bffa17 	ldw	r2,-24(fp)
81118ff0:	00c00284 	movi	r3,10
81118ff4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOverScanSerial = atoi( inteiro );
81118ff8:	e0bffd04 	addi	r2,fp,-12
81118ffc:	1009883a 	mov	r4,r2
81119000:	111f4a00 	call	8111f4a0 <atoi>
81119004:	1007883a 	mov	r3,r2
81119008:	00a045b4 	movhi	r2,33046
8111900c:	1091bc04 	addi	r2,r2,18160
81119010:	10c0040d 	sth	r3,16(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119014:	e0bffd04 	addi	r2,fp,-12
81119018:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111901c:	e0bff903 	ldbu	r2,-28(fp)
81119020:	10800044 	addi	r2,r2,1
81119024:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119028:	e0bff947 	ldb	r2,-27(fp)
8111902c:	10800ed8 	cmpnei	r2,r2,59
81119030:	103fd61e 	bne	r2,zero,81118f8c <__reset+0xfb0f8f8c>

						break;
81119034:	00018406 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'L':
						ucParser = 0;
81119038:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111903c:	e0bffc0f 	ldh	r2,-16(fp)
81119040:	1009883a 	mov	r4,r2
81119044:	111cbe40 	call	8111cbe4 <cGetNextChar>
81119048:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111904c:	d0e00317 	ldw	r3,-32756(gp)
81119050:	e0bff947 	ldb	r2,-27(fp)
81119054:	10800044 	addi	r2,r2,1
81119058:	1885883a 	add	r2,r3,r2
8111905c:	10800003 	ldbu	r2,0(r2)
81119060:	10803fcc 	andi	r2,r2,255
81119064:	1080010c 	andi	r2,r2,4
81119068:	10000626 	beq	r2,zero,81119084 <vLoadDebugConfs+0x4d0>
									(*p_inteiro) = c;
8111906c:	e0bffa17 	ldw	r2,-24(fp)
81119070:	e0fff943 	ldbu	r3,-27(fp)
81119074:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119078:	e0bffa17 	ldw	r2,-24(fp)
8111907c:	10800044 	addi	r2,r2,1
81119080:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119084:	e0bff947 	ldb	r2,-27(fp)
81119088:	10800ba0 	cmpeqi	r2,r2,46
8111908c:	1000031e 	bne	r2,zero,8111909c <vLoadDebugConfs+0x4e8>
81119090:	e0bff947 	ldb	r2,-27(fp)
81119094:	10800ed8 	cmpnei	r2,r2,59
81119098:	103fe81e 	bne	r2,zero,8111903c <__reset+0xfb0f903c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111909c:	e0bffa17 	ldw	r2,-24(fp)
811190a0:	00c00284 	movi	r3,10
811190a4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiRows = atoi( inteiro );
811190a8:	e0bffd04 	addi	r2,fp,-12
811190ac:	1009883a 	mov	r4,r2
811190b0:	111f4a00 	call	8111f4a0 <atoi>
811190b4:	1007883a 	mov	r3,r2
811190b8:	00a045b4 	movhi	r2,33046
811190bc:	1091bc04 	addi	r2,r2,18160
811190c0:	10c0060d 	sth	r3,24(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811190c4:	e0bffd04 	addi	r2,fp,-12
811190c8:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811190cc:	e0bff903 	ldbu	r2,-28(fp)
811190d0:	10800044 	addi	r2,r2,1
811190d4:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811190d8:	e0bff947 	ldb	r2,-27(fp)
811190dc:	10800ed8 	cmpnei	r2,r2,59
811190e0:	103fd61e 	bne	r2,zero,8111903c <__reset+0xfb0f903c>

						break;
811190e4:	00015806 	br	81119648 <vLoadDebugConfs+0xa94>

					case 'O':
						ucParser = 0;
811190e8:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811190ec:	e0bffc0f 	ldh	r2,-16(fp)
811190f0:	1009883a 	mov	r4,r2
811190f4:	111cbe40 	call	8111cbe4 <cGetNextChar>
811190f8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811190fc:	d0e00317 	ldw	r3,-32756(gp)
81119100:	e0bff947 	ldb	r2,-27(fp)
81119104:	10800044 	addi	r2,r2,1
81119108:	1885883a 	add	r2,r3,r2
8111910c:	10800003 	ldbu	r2,0(r2)
81119110:	10803fcc 	andi	r2,r2,255
81119114:	1080010c 	andi	r2,r2,4
81119118:	10000626 	beq	r2,zero,81119134 <vLoadDebugConfs+0x580>
									(*p_inteiro) = c;
8111911c:	e0bffa17 	ldw	r2,-24(fp)
81119120:	e0fff943 	ldbu	r3,-27(fp)
81119124:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119128:	e0bffa17 	ldw	r2,-24(fp)
8111912c:	10800044 	addi	r2,r2,1
81119130:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119134:	e0bff947 	ldb	r2,-27(fp)
81119138:	10800ba0 	cmpeqi	r2,r2,46
8111913c:	1000031e 	bne	r2,zero,8111914c <vLoadDebugConfs+0x598>
81119140:	e0bff947 	ldb	r2,-27(fp)
81119144:	10800ed8 	cmpnei	r2,r2,59
81119148:	103fe81e 	bne	r2,zero,811190ec <__reset+0xfb0f90ec>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
8111914c:	e0bffa17 	ldw	r2,-24(fp)
81119150:	00c00284 	movi	r3,10
81119154:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiOLN = atoi( inteiro );
81119158:	e0bffd04 	addi	r2,fp,-12
8111915c:	1009883a 	mov	r4,r2
81119160:	111f4a00 	call	8111f4a0 <atoi>
81119164:	1007883a 	mov	r3,r2
81119168:	00a045b4 	movhi	r2,33046
8111916c:	1091bc04 	addi	r2,r2,18160
81119170:	10c0050d 	sth	r3,20(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119174:	e0bffd04 	addi	r2,fp,-12
81119178:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111917c:	e0bff903 	ldbu	r2,-28(fp)
81119180:	10800044 	addi	r2,r2,1
81119184:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119188:	e0bff947 	ldb	r2,-27(fp)
8111918c:	10800ed8 	cmpnei	r2,r2,59
81119190:	103fd61e 	bne	r2,zero,811190ec <__reset+0xfb0f90ec>

						break;
81119194:	00012c06 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'C':
						ucParser = 0;
81119198:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111919c:	e0bffc0f 	ldh	r2,-16(fp)
811191a0:	1009883a 	mov	r4,r2
811191a4:	111cbe40 	call	8111cbe4 <cGetNextChar>
811191a8:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811191ac:	d0e00317 	ldw	r3,-32756(gp)
811191b0:	e0bff947 	ldb	r2,-27(fp)
811191b4:	10800044 	addi	r2,r2,1
811191b8:	1885883a 	add	r2,r3,r2
811191bc:	10800003 	ldbu	r2,0(r2)
811191c0:	10803fcc 	andi	r2,r2,255
811191c4:	1080010c 	andi	r2,r2,4
811191c8:	10000626 	beq	r2,zero,811191e4 <vLoadDebugConfs+0x630>
									(*p_inteiro) = c;
811191cc:	e0bffa17 	ldw	r2,-24(fp)
811191d0:	e0fff943 	ldbu	r3,-27(fp)
811191d4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
811191d8:	e0bffa17 	ldw	r2,-24(fp)
811191dc:	10800044 	addi	r2,r2,1
811191e0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
811191e4:	e0bff947 	ldb	r2,-27(fp)
811191e8:	10800ba0 	cmpeqi	r2,r2,46
811191ec:	1000031e 	bne	r2,zero,811191fc <vLoadDebugConfs+0x648>
811191f0:	e0bff947 	ldb	r2,-27(fp)
811191f4:	10800ed8 	cmpnei	r2,r2,59
811191f8:	103fe81e 	bne	r2,zero,8111919c <__reset+0xfb0f919c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811191fc:	e0bffa17 	ldw	r2,-24(fp)
81119200:	00c00284 	movi	r3,10
81119204:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.usiCols = atoi( inteiro );
81119208:	e0bffd04 	addi	r2,fp,-12
8111920c:	1009883a 	mov	r4,r2
81119210:	111f4a00 	call	8111f4a0 <atoi>
81119214:	1007883a 	mov	r3,r2
81119218:	00a045b4 	movhi	r2,33046
8111921c:	1091bc04 	addi	r2,r2,18160
81119220:	10c0058d 	sth	r3,22(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81119224:	e0bffd04 	addi	r2,fp,-12
81119228:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
8111922c:	e0bff903 	ldbu	r2,-28(fp)
81119230:	10800044 	addi	r2,r2,1
81119234:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119238:	e0bff947 	ldb	r2,-27(fp)
8111923c:	10800ed8 	cmpnei	r2,r2,59
81119240:	103fd61e 	bne	r2,zero,8111919c <__reset+0xfb0f919c>

						break;
81119244:	00010006 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'H':

						ucParser = 0;
81119248:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
8111924c:	e0bffc0f 	ldh	r2,-16(fp)
81119250:	1009883a 	mov	r4,r2
81119254:	111cbe40 	call	8111cbe4 <cGetNextChar>
81119258:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
8111925c:	d0e00317 	ldw	r3,-32756(gp)
81119260:	e0bff947 	ldb	r2,-27(fp)
81119264:	10800044 	addi	r2,r2,1
81119268:	1885883a 	add	r2,r3,r2
8111926c:	10800003 	ldbu	r2,0(r2)
81119270:	10803fcc 	andi	r2,r2,255
81119274:	1080010c 	andi	r2,r2,4
81119278:	10000626 	beq	r2,zero,81119294 <vLoadDebugConfs+0x6e0>
									(*p_inteiro) = c;
8111927c:	e0bffa17 	ldw	r2,-24(fp)
81119280:	e0fff943 	ldbu	r3,-27(fp)
81119284:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81119288:	e0bffa17 	ldw	r2,-24(fp)
8111928c:	10800044 	addi	r2,r2,1
81119290:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81119294:	e0bff947 	ldb	r2,-27(fp)
81119298:	10800ba0 	cmpeqi	r2,r2,46
8111929c:	1000031e 	bne	r2,zero,811192ac <vLoadDebugConfs+0x6f8>
811192a0:	e0bff947 	ldb	r2,-27(fp)
811192a4:	10800ed8 	cmpnei	r2,r2,59
811192a8:	103fe81e 	bne	r2,zero,8111924c <__reset+0xfb0f924c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811192ac:	e0bffa17 	ldw	r2,-24(fp)
811192b0:	00c00284 	movi	r3,10
811192b4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xDefaults.HK[min_sim(ucParser,15)] = atoi( inteiro );
811192b8:	e0bff903 	ldbu	r2,-28(fp)
811192bc:	108003e8 	cmpgeui	r2,r2,15
811192c0:	1000021e 	bne	r2,zero,811192cc <vLoadDebugConfs+0x718>
811192c4:	e43ff903 	ldbu	r16,-28(fp)
811192c8:	00000106 	br	811192d0 <vLoadDebugConfs+0x71c>
811192cc:	040003c4 	movi	r16,15
811192d0:	e0bffd04 	addi	r2,fp,-12
811192d4:	1009883a 	mov	r4,r2
811192d8:	111f4a00 	call	8111f4a0 <atoi>
811192dc:	1007883a 	mov	r3,r2
811192e0:	00a045b4 	movhi	r2,33046
811192e4:	1091bc04 	addi	r2,r2,18160
811192e8:	1405883a 	add	r2,r2,r16
811192ec:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811192f0:	e0bffd04 	addi	r2,fp,-12
811192f4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811192f8:	e0bff903 	ldbu	r2,-28(fp)
811192fc:	10800044 	addi	r2,r2,1
81119300:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81119304:	e0bff947 	ldb	r2,-27(fp)
81119308:	10800ed8 	cmpnei	r2,r2,59
8111930c:	103fcf1e 	bne	r2,zero,8111924c <__reset+0xfb0f924c>

						break;
81119310:	0000cd06 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'D':

						do {
							c = cGetNextChar(siFile);
81119314:	e0bffc0f 	ldh	r2,-16(fp)
81119318:	1009883a 	mov	r4,r2
8111931c:	111cbe40 	call	8111cbe4 <cGetNextChar>
81119320:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119324:	d0e00317 	ldw	r3,-32756(gp)
81119328:	e0bff947 	ldb	r2,-27(fp)
8111932c:	10800044 	addi	r2,r2,1
81119330:	1885883a 	add	r2,r3,r2
81119334:	10800003 	ldbu	r2,0(r2)
81119338:	10803fcc 	andi	r2,r2,255
8111933c:	1080010c 	andi	r2,r2,4
81119340:	10000626 	beq	r2,zero,8111935c <vLoadDebugConfs+0x7a8>
								(*p_inteiro) = c;
81119344:	e0bffa17 	ldw	r2,-24(fp)
81119348:	e0fff943 	ldbu	r3,-27(fp)
8111934c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119350:	e0bffa17 	ldw	r2,-24(fp)
81119354:	10800044 	addi	r2,r2,1
81119358:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111935c:	e0bff947 	ldb	r2,-27(fp)
81119360:	10800ed8 	cmpnei	r2,r2,59
81119364:	103feb1e 	bne	r2,zero,81119314 <__reset+0xfb0f9314>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119368:	e0bffa17 	ldw	r2,-24(fp)
8111936c:	00c00284 	movi	r3,10
81119370:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.usiDelay = atoi( inteiro );
81119374:	e0bffd04 	addi	r2,fp,-12
81119378:	1009883a 	mov	r4,r2
8111937c:	111f4a00 	call	8111f4a0 <atoi>
81119380:	1007883a 	mov	r3,r2
81119384:	00a045b4 	movhi	r2,33046
81119388:	1091bc04 	addi	r2,r2,18160
8111938c:	10c0070d 	sth	r3,28(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119390:	e0bffd04 	addi	r2,fp,-12
81119394:	e0bffa15 	stw	r2,-24(fp)

						break;
81119398:	0000ab06 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'K':

						do {
							c = cGetNextChar(siFile);
8111939c:	e0bffc0f 	ldh	r2,-16(fp)
811193a0:	1009883a 	mov	r4,r2
811193a4:	111cbe40 	call	8111cbe4 <cGetNextChar>
811193a8:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811193ac:	d0e00317 	ldw	r3,-32756(gp)
811193b0:	e0bff947 	ldb	r2,-27(fp)
811193b4:	10800044 	addi	r2,r2,1
811193b8:	1885883a 	add	r2,r3,r2
811193bc:	10800003 	ldbu	r2,0(r2)
811193c0:	10803fcc 	andi	r2,r2,255
811193c4:	1080010c 	andi	r2,r2,4
811193c8:	10000626 	beq	r2,zero,811193e4 <vLoadDebugConfs+0x830>
								(*p_inteiro) = c;
811193cc:	e0bffa17 	ldw	r2,-24(fp)
811193d0:	e0fff943 	ldbu	r3,-27(fp)
811193d4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811193d8:	e0bffa17 	ldw	r2,-24(fp)
811193dc:	10800044 	addi	r2,r2,1
811193e0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811193e4:	e0bff947 	ldb	r2,-27(fp)
811193e8:	10800ed8 	cmpnei	r2,r2,59
811193ec:	103feb1e 	bne	r2,zero,8111939c <__reset+0xfb0f939c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811193f0:	e0bffa17 	ldw	r2,-24(fp)
811193f4:	00c00284 	movi	r3,10
811193f8:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulColDelay = atoi( inteiro );
811193fc:	e0bffd04 	addi	r2,fp,-12
81119400:	1009883a 	mov	r4,r2
81119404:	111f4a00 	call	8111f4a0 <atoi>
81119408:	1007883a 	mov	r3,r2
8111940c:	00a045b4 	movhi	r2,33046
81119410:	1091bc04 	addi	r2,r2,18160
81119414:	10c00a15 	stw	r3,40(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119418:	e0bffd04 	addi	r2,fp,-12
8111941c:	e0bffa15 	stw	r2,-24(fp)

						break;
81119420:	00008906 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'M':

						do {
							c = cGetNextChar(siFile);
81119424:	e0bffc0f 	ldh	r2,-16(fp)
81119428:	1009883a 	mov	r4,r2
8111942c:	111cbe40 	call	8111cbe4 <cGetNextChar>
81119430:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119434:	d0e00317 	ldw	r3,-32756(gp)
81119438:	e0bff947 	ldb	r2,-27(fp)
8111943c:	10800044 	addi	r2,r2,1
81119440:	1885883a 	add	r2,r3,r2
81119444:	10800003 	ldbu	r2,0(r2)
81119448:	10803fcc 	andi	r2,r2,255
8111944c:	1080010c 	andi	r2,r2,4
81119450:	10000626 	beq	r2,zero,8111946c <vLoadDebugConfs+0x8b8>
								(*p_inteiro) = c;
81119454:	e0bffa17 	ldw	r2,-24(fp)
81119458:	e0fff943 	ldbu	r3,-27(fp)
8111945c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119460:	e0bffa17 	ldw	r2,-24(fp)
81119464:	10800044 	addi	r2,r2,1
81119468:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111946c:	e0bff947 	ldb	r2,-27(fp)
81119470:	10800ed8 	cmpnei	r2,r2,59
81119474:	103feb1e 	bne	r2,zero,81119424 <__reset+0xfb0f9424>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119478:	e0bffa17 	ldw	r2,-24(fp)
8111947c:	00c00284 	movi	r3,10
81119480:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulADCPixelDelay = atoi( inteiro );
81119484:	e0bffd04 	addi	r2,fp,-12
81119488:	1009883a 	mov	r4,r2
8111948c:	111f4a00 	call	8111f4a0 <atoi>
81119490:	1007883a 	mov	r3,r2
81119494:	00a045b4 	movhi	r2,33046
81119498:	1091bc04 	addi	r2,r2,18160
8111949c:	10c00b15 	stw	r3,44(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811194a0:	e0bffd04 	addi	r2,fp,-12
811194a4:	e0bffa15 	stw	r2,-24(fp)

						break;
811194a8:	00006706 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'J':

						do {
							c = cGetNextChar(siFile);
811194ac:	e0bffc0f 	ldh	r2,-16(fp)
811194b0:	1009883a 	mov	r4,r2
811194b4:	111cbe40 	call	8111cbe4 <cGetNextChar>
811194b8:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811194bc:	d0e00317 	ldw	r3,-32756(gp)
811194c0:	e0bff947 	ldb	r2,-27(fp)
811194c4:	10800044 	addi	r2,r2,1
811194c8:	1885883a 	add	r2,r3,r2
811194cc:	10800003 	ldbu	r2,0(r2)
811194d0:	10803fcc 	andi	r2,r2,255
811194d4:	1080010c 	andi	r2,r2,4
811194d8:	10000626 	beq	r2,zero,811194f4 <vLoadDebugConfs+0x940>
								(*p_inteiro) = c;
811194dc:	e0bffa17 	ldw	r2,-24(fp)
811194e0:	e0fff943 	ldbu	r3,-27(fp)
811194e4:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811194e8:	e0bffa17 	ldw	r2,-24(fp)
811194ec:	10800044 	addi	r2,r2,1
811194f0:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811194f4:	e0bff947 	ldb	r2,-27(fp)
811194f8:	10800ed8 	cmpnei	r2,r2,59
811194fc:	103feb1e 	bne	r2,zero,811194ac <__reset+0xfb0f94ac>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119500:	e0bffa17 	ldw	r2,-24(fp)
81119504:	00c00284 	movi	r3,10
81119508:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xDefaults.ulLineDelay = atoi( inteiro );
8111950c:	e0bffd04 	addi	r2,fp,-12
81119510:	1009883a 	mov	r4,r2
81119514:	111f4a00 	call	8111f4a0 <atoi>
81119518:	1007883a 	mov	r3,r2
8111951c:	00a045b4 	movhi	r2,33046
81119520:	1091bc04 	addi	r2,r2,18160
81119524:	10c00915 	stw	r3,36(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81119528:	e0bffd04 	addi	r2,fp,-12
8111952c:	e0bffa15 	stw	r2,-24(fp)

						break;
81119530:	00004506 	br	81119648 <vLoadDebugConfs+0xa94>
					case 'T':

						do {
							c = cGetNextChar(siFile);
81119534:	e0bffc0f 	ldh	r2,-16(fp)
81119538:	1009883a 	mov	r4,r2
8111953c:	111cbe40 	call	8111cbe4 <cGetNextChar>
81119540:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
81119544:	d0e00317 	ldw	r3,-32756(gp)
81119548:	e0bff947 	ldb	r2,-27(fp)
8111954c:	10800044 	addi	r2,r2,1
81119550:	1885883a 	add	r2,r3,r2
81119554:	10800003 	ldbu	r2,0(r2)
81119558:	10803fcc 	andi	r2,r2,255
8111955c:	1080010c 	andi	r2,r2,4
81119560:	10000626 	beq	r2,zero,8111957c <vLoadDebugConfs+0x9c8>
								(*p_inteiro) = c;
81119564:	e0bffa17 	ldw	r2,-24(fp)
81119568:	e0fff943 	ldbu	r3,-27(fp)
8111956c:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81119570:	e0bffa17 	ldw	r2,-24(fp)
81119574:	10800044 	addi	r2,r2,1
81119578:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
8111957c:	e0bff947 	ldb	r2,-27(fp)
81119580:	10800ed8 	cmpnei	r2,r2,59
81119584:	103feb1e 	bne	r2,zero,81119534 <__reset+0xfb0f9534>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81119588:	e0bffa17 	ldw	r2,-24(fp)
8111958c:	00c00284 	movi	r3,10
81119590:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
81119594:	e0bffd04 	addi	r2,fp,-12
81119598:	1009883a 	mov	r4,r2
8111959c:	111f4a00 	call	8111f4a0 <atoi>
811195a0:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
811195a4:	e0bffc8f 	ldh	r2,-14(fp)
811195a8:	10800058 	cmpnei	r2,r2,1
811195ac:	1000051e 	bne	r2,zero,811195c4 <vLoadDebugConfs+0xa10>
							xDefaults.bDataPacket = TRUE;
811195b0:	00a045b4 	movhi	r2,33046
811195b4:	1091bc04 	addi	r2,r2,18160
811195b8:	00c00044 	movi	r3,1
811195bc:	10c00815 	stw	r3,32(r2)
811195c0:	00000306 	br	811195d0 <vLoadDebugConfs+0xa1c>
						else
							xDefaults.bDataPacket = FALSE;
811195c4:	00a045b4 	movhi	r2,33046
811195c8:	1091bc04 	addi	r2,r2,18160
811195cc:	10000815 	stw	zero,32(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811195d0:	e0bffd04 	addi	r2,fp,-12
811195d4:	e0bffa15 	stw	r2,-24(fp)

						break;
811195d8:	00001b06 	br	81119648 <vLoadDebugConfs+0xa94>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
811195dc:	e0bffc0f 	ldh	r2,-16(fp)
811195e0:	1009883a 	mov	r4,r2
811195e4:	111cba40 	call	8111cba4 <siCloseFile>
811195e8:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
811195ec:	e0bffb17 	ldw	r2,-20(fp)
811195f0:	1000071e 	bne	r2,zero,81119610 <vLoadDebugConfs+0xa5c>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
811195f4:	d0a06117 	ldw	r2,-32380(gp)
811195f8:	100f883a 	mov	r7,r2
811195fc:	01800784 	movi	r6,30
81119600:	01400044 	movi	r5,1
81119604:	01204574 	movhi	r4,33045
81119608:	21314d04 	addi	r4,r4,-15052
8111960c:	111fc980 	call	8111fc98 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
81119610:	00800044 	movi	r2,1
81119614:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81119618:	00800044 	movi	r2,1
8111961c:	e0bff715 	stw	r2,-36(fp)
						break;
81119620:	00000906 	br	81119648 <vLoadDebugConfs+0xa94>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
81119624:	d0a06117 	ldw	r2,-32380(gp)
81119628:	100f883a 	mov	r7,r2
8111962c:	01800844 	movi	r6,33
81119630:	01400044 	movi	r5,1
81119634:	01204574 	movhi	r4,33045
81119638:	21315504 	addi	r4,r4,-15020
8111963c:	111fc980 	call	8111fc98 <fwrite>
						#endif
						break;
81119640:	00000106 	br	81119648 <vLoadDebugConfs+0xa94>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
81119644:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81119648:	e0bff817 	ldw	r2,-32(fp)
8111964c:	103d7726 	beq	r2,zero,81118c2c <__reset+0xfb0f8c2c>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
81119650:	00000f06 	br	81119690 <vLoadDebugConfs+0xadc>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
81119654:	d0a06117 	ldw	r2,-32380(gp)
81119658:	100f883a 	mov	r7,r2
8111965c:	01800604 	movi	r6,24
81119660:	01400044 	movi	r5,1
81119664:	01204574 	movhi	r4,33045
81119668:	21315e04 	addi	r4,r4,-14984
8111966c:	111fc980 	call	8111fc98 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( DEBUG_FILE_NAME );

		if ( siFile >= 0 ){
81119670:	00000706 	br	81119690 <vLoadDebugConfs+0xadc>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
81119674:	d0a06117 	ldw	r2,-32380(gp)
81119678:	100f883a 	mov	r7,r2
8111967c:	018004c4 	movi	r6,19
81119680:	01400044 	movi	r5,1
81119684:	01204574 	movhi	r4,33045
81119688:	21316504 	addi	r4,r4,-14956
8111968c:	111fc980 	call	8111fc98 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81119690:	e0bff717 	ldw	r2,-36(fp)
81119694:	1000311e 	bne	r2,zero,8111975c <vLoadDebugConfs+0xba8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Debug Configs: Could not load the default values from SDCard\n");
81119698:	01204574 	movhi	r4,33045
8111969c:	2131b704 	addi	r4,r4,-14628
811196a0:	1120c480 	call	81120c48 <puts>
		printf("Can't find the file:'%s'.\n", ETH_FILE_NAME);
811196a4:	01604574 	movhi	r5,33045
811196a8:	29714404 	addi	r5,r5,-15088
811196ac:	01204574 	movhi	r4,33045
811196b0:	2131c704 	addi	r4,r4,-14564
811196b4:	11209c40 	call	811209c4 <printf>



		xDefaults.usiRows = 4510;
811196b8:	00a045b4 	movhi	r2,33046
811196bc:	1091bc04 	addi	r2,r2,18160
811196c0:	00c46784 	movi	r3,4510
811196c4:	10c0060d 	sth	r3,24(r2)
		xDefaults.usiCols = 2255;
811196c8:	00a045b4 	movhi	r2,33046
811196cc:	1091bc04 	addi	r2,r2,18160
811196d0:	00c233c4 	movi	r3,2255
811196d4:	10c0058d 	sth	r3,22(r2)
		xDefaults.usiOLN = 30;
811196d8:	00a045b4 	movhi	r2,33046
811196dc:	1091bc04 	addi	r2,r2,18160
811196e0:	00c00784 	movi	r3,30
811196e4:	10c0050d 	sth	r3,20(r2)
		xDefaults.usiPreScanSerial = 25;
811196e8:	00a045b4 	movhi	r2,33046
811196ec:	1091bc04 	addi	r2,r2,18160
811196f0:	00c00644 	movi	r3,25
811196f4:	10c0048d 	sth	r3,18(r2)
		xDefaults.usiOverScanSerial = 15;
811196f8:	00a045b4 	movhi	r2,33046
811196fc:	1091bc04 	addi	r2,r2,18160
81119700:	00c003c4 	movi	r3,15
81119704:	10c0040d 	sth	r3,16(r2)
		xDefaults.usiSyncPeriod = 6250;
81119708:	00a045b4 	movhi	r2,33046
8111970c:	1091bc04 	addi	r2,r2,18160
81119710:	00c61a84 	movi	r3,6250
81119714:	10c0068d 	sth	r3,26(r2)
		xDefaults.usiDelay = 20;
81119718:	00a045b4 	movhi	r2,33046
8111971c:	1091bc04 	addi	r2,r2,18160
81119720:	00c00504 	movi	r3,20
81119724:	10c0070d 	sth	r3,28(r2)
		xDefaults.bDataPacket = TRUE;
81119728:	00a045b4 	movhi	r2,33046
8111972c:	1091bc04 	addi	r2,r2,18160
81119730:	00c00044 	movi	r3,1
81119734:	10c00815 	stw	r3,32(r2)
		xDefaults.ulLineDelay = 0;
81119738:	00a045b4 	movhi	r2,33046
8111973c:	1091bc04 	addi	r2,r2,18160
81119740:	10000915 	stw	zero,36(r2)
		xDefaults.ulColDelay = 0;
81119744:	00a045b4 	movhi	r2,33046
81119748:	1091bc04 	addi	r2,r2,18160
8111974c:	10000a15 	stw	zero,40(r2)
		xDefaults.ulADCPixelDelay = 0;
81119750:	00a045b4 	movhi	r2,33046
81119754:	1091bc04 	addi	r2,r2,18160
81119758:	10000b15 	stw	zero,44(r2)

	}

	return bSuccess;
8111975c:	e0bff717 	ldw	r2,-36(fp)
}
81119760:	e6ffff04 	addi	sp,fp,-4
81119764:	dfc00217 	ldw	ra,8(sp)
81119768:	df000117 	ldw	fp,4(sp)
8111976c:	dc000017 	ldw	r16,0(sp)
81119770:	dec00304 	addi	sp,sp,12
81119774:	f800283a 	ret

81119778 <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
81119778:	defffb04 	addi	sp,sp,-20
8111977c:	de00012e 	bgeu	sp,et,81119784 <ucCrc8+0xc>
81119780:	003b68fa 	trap	3
81119784:	df000415 	stw	fp,16(sp)
81119788:	df000404 	addi	fp,sp,16
8111978c:	e13ffd15 	stw	r4,-12(fp)
81119790:	e17ffe15 	stw	r5,-8(fp)
81119794:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
81119798:	e0bffe17 	ldw	r2,-8(fp)
8111979c:	1000021e 	bne	r2,zero,811197a8 <ucCrc8+0x30>
        return 0;
811197a0:	0005883a 	mov	r2,zero
811197a4:	00001906 	br	8111980c <ucCrc8+0x94>
    crc &= 0xff;
811197a8:	e0bffd17 	ldw	r2,-12(fp)
811197ac:	10803fcc 	andi	r2,r2,255
811197b0:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
811197b4:	e0fffe17 	ldw	r3,-8(fp)
811197b8:	e0bfff17 	ldw	r2,-4(fp)
811197bc:	1885883a 	add	r2,r3,r2
811197c0:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
811197c4:	00000d06 	br	811197fc <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
811197c8:	e0bffe17 	ldw	r2,-8(fp)
811197cc:	10c00044 	addi	r3,r2,1
811197d0:	e0fffe15 	stw	r3,-8(fp)
811197d4:	10800003 	ldbu	r2,0(r2)
811197d8:	10c03fcc 	andi	r3,r2,255
811197dc:	e0bffd17 	ldw	r2,-12(fp)
811197e0:	1886f03a 	xor	r3,r3,r2
811197e4:	00a04574 	movhi	r2,33045
811197e8:	10b1cdc4 	addi	r2,r2,-14537
811197ec:	10c5883a 	add	r2,r2,r3
811197f0:	10800003 	ldbu	r2,0(r2)
811197f4:	10803fcc 	andi	r2,r2,255
811197f8:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
811197fc:	e0fffe17 	ldw	r3,-8(fp)
81119800:	e0bffc17 	ldw	r2,-16(fp)
81119804:	18bff036 	bltu	r3,r2,811197c8 <__reset+0xfb0f97c8>
        crc = crc8_table[crc ^ *data++];
    return crc;
81119808:	e0bffd17 	ldw	r2,-12(fp)
}
8111980c:	e037883a 	mov	sp,fp
81119810:	df000017 	ldw	fp,0(sp)
81119814:	dec00104 	addi	sp,sp,4
81119818:	f800283a 	ret

8111981c <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
8111981c:	defffb04 	addi	sp,sp,-20
81119820:	de00012e 	bgeu	sp,et,81119828 <ucCrc8wInit+0xc>
81119824:	003b68fa 	trap	3
81119828:	dfc00415 	stw	ra,16(sp)
8111982c:	df000315 	stw	fp,12(sp)
81119830:	df000304 	addi	fp,sp,12
81119834:	e13ffe15 	stw	r4,-8(fp)
81119838:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
8111983c:	000d883a 	mov	r6,zero
81119840:	000b883a 	mov	r5,zero
81119844:	0009883a 	mov	r4,zero
81119848:	11197780 	call	81119778 <ucCrc8>
8111984c:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
81119850:	e0bffd03 	ldbu	r2,-12(fp)
81119854:	e1bfff17 	ldw	r6,-4(fp)
81119858:	e17ffe17 	ldw	r5,-8(fp)
8111985c:	1009883a 	mov	r4,r2
81119860:	11197780 	call	81119778 <ucCrc8>
}
81119864:	e037883a 	mov	sp,fp
81119868:	dfc00117 	ldw	ra,4(sp)
8111986c:	df000017 	ldw	fp,0(sp)
81119870:	dec00204 	addi	sp,sp,8
81119874:	f800283a 	ret

81119878 <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
81119878:	defffc04 	addi	sp,sp,-16
8111987c:	de00012e 	bgeu	sp,et,81119884 <vDataControllerInit+0xc>
81119880:	003b68fa 	trap	3
81119884:	df000315 	stw	fp,12(sp)
81119888:	df000304 	addi	fp,sp,12
8111988c:	e13ffe15 	stw	r4,-8(fp)
81119890:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
81119894:	e0bffe17 	ldw	r2,-8(fp)
81119898:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
8111989c:	e03ffd05 	stb	zero,-12(fp)
811198a0:	00001c06 	br	81119914 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
811198a4:	e0bffd03 	ldbu	r2,-12(fp)
811198a8:	e0fffd03 	ldbu	r3,-12(fp)
811198ac:	18c09624 	muli	r3,r3,600
811198b0:	e13fff17 	ldw	r4,-4(fp)
811198b4:	20c7883a 	add	r3,r4,r3
811198b8:	e13ffe17 	ldw	r4,-8(fp)
811198bc:	10800084 	addi	r2,r2,2
811198c0:	1085883a 	add	r2,r2,r2
811198c4:	1085883a 	add	r2,r2,r2
811198c8:	2085883a 	add	r2,r4,r2
811198cc:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
811198d0:	e17ffd03 	ldbu	r5,-12(fp)
811198d4:	e0bffd03 	ldbu	r2,-12(fp)
811198d8:	e0ffff17 	ldw	r3,-4(fp)
811198dc:	108025c4 	addi	r2,r2,151
811198e0:	1085883a 	add	r2,r2,r2
811198e4:	1085883a 	add	r2,r2,r2
811198e8:	1885883a 	add	r2,r3,r2
811198ec:	10c00017 	ldw	r3,0(r2)
811198f0:	e13ffe17 	ldw	r4,-8(fp)
811198f4:	288000c4 	addi	r2,r5,3
811198f8:	1085883a 	add	r2,r2,r2
811198fc:	1085883a 	add	r2,r2,r2
81119900:	2085883a 	add	r2,r4,r2
81119904:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81119908:	e0bffd03 	ldbu	r2,-12(fp)
8111990c:	10800044 	addi	r2,r2,1
81119910:	e0bffd05 	stb	r2,-12(fp)
81119914:	e0bffd03 	ldbu	r2,-12(fp)
81119918:	103fe226 	beq	r2,zero,811198a4 <__reset+0xfb0f98a4>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
8111991c:	e0bfff17 	ldw	r2,-4(fp)
81119920:	10c09904 	addi	r3,r2,612
81119924:	e0bffe17 	ldw	r2,-8(fp)
81119928:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
8111992c:	e0bffe17 	ldw	r2,-8(fp)
81119930:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
81119934:	e0bffe17 	ldw	r2,-8(fp)
81119938:	10c00504 	addi	r3,r2,20
8111993c:	e0bfff17 	ldw	r2,-4(fp)
81119940:	10c09b15 	stw	r3,620(r2)
}
81119944:	0001883a 	nop
81119948:	e037883a 	mov	sp,fp
8111994c:	df000017 	ldw	fp,0(sp)
81119950:	dec00104 	addi	sp,sp,4
81119954:	f800283a 	ret

81119958 <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
81119958:	defff904 	addi	sp,sp,-28
8111995c:	de00012e 	bgeu	sp,et,81119964 <printErrorTask+0xc>
81119960:	003b68fa 	trap	3
81119964:	dfc00615 	stw	ra,24(sp)
81119968:	df000515 	stw	fp,20(sp)
8111996c:	df000504 	addi	fp,sp,20
81119970:	2005883a 	mov	r2,r4
81119974:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81119978:	e03ffb15 	stw	zero,-20(fp)
8111997c:	e03ffc15 	stw	zero,-16(fp)
81119980:	e03ffd15 	stw	zero,-12(fp)
81119984:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81119988:	e0bfff03 	ldbu	r2,-4(fp)
8111998c:	100d883a 	mov	r6,r2
81119990:	01604574 	movhi	r5,33045
81119994:	29720e04 	addi	r5,r5,-14280
81119998:	e13ffb04 	addi	r4,fp,-20
8111999c:	1120f8c0 	call	81120f8c <sprintf>
		debug(fp, buffer);
811199a0:	d0a06117 	ldw	r2,-32380(gp)
811199a4:	e17ffb04 	addi	r5,fp,-20
811199a8:	1009883a 	mov	r4,r2
811199ac:	111f5fc0 	call	8111f5fc <fprintf>
	}
811199b0:	0001883a 	nop
811199b4:	e037883a 	mov	sp,fp
811199b8:	dfc00117 	ldw	ra,4(sp)
811199bc:	df000017 	ldw	fp,0(sp)
811199c0:	dec00204 	addi	sp,sp,8
811199c4:	f800283a 	ret

811199c8 <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
811199c8:	defffd04 	addi	sp,sp,-12
811199cc:	de00012e 	bgeu	sp,et,811199d4 <vFailCreateMutexSResources+0xc>
811199d0:	003b68fa 	trap	3
811199d4:	dfc00215 	stw	ra,8(sp)
811199d8:	df000115 	stw	fp,4(sp)
811199dc:	df000104 	addi	fp,sp,4
811199e0:	2005883a 	mov	r2,r4
811199e4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
811199e8:	d0a06117 	ldw	r2,-32380(gp)
811199ec:	100f883a 	mov	r7,r2
811199f0:	018008c4 	movi	r6,35
811199f4:	01400044 	movi	r5,1
811199f8:	01204574 	movhi	r4,33045
811199fc:	21321104 	addi	r4,r4,-14268
81119a00:	111fc980 	call	8111fc98 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81119a04:	e0bfff03 	ldbu	r2,-4(fp)
81119a08:	1009883a 	mov	r4,r2
81119a0c:	11199580 	call	81119958 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119a10:	0001883a 	nop
81119a14:	e037883a 	mov	sp,fp
81119a18:	dfc00117 	ldw	ra,4(sp)
81119a1c:	df000017 	ldw	fp,0(sp)
81119a20:	dec00204 	addi	sp,sp,8
81119a24:	f800283a 	ret

81119a28 <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81119a28:	defffe04 	addi	sp,sp,-8
81119a2c:	de00012e 	bgeu	sp,et,81119a34 <vFailCreateMutexDMA+0xc>
81119a30:	003b68fa 	trap	3
81119a34:	dfc00115 	stw	ra,4(sp)
81119a38:	df000015 	stw	fp,0(sp)
81119a3c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
81119a40:	d0a06117 	ldw	r2,-32380(gp)
81119a44:	100f883a 	mov	r7,r2
81119a48:	018009c4 	movi	r6,39
81119a4c:	01400044 	movi	r5,1
81119a50:	01204574 	movhi	r4,33045
81119a54:	21321a04 	addi	r4,r4,-14232
81119a58:	111fc980 	call	8111fc98 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119a5c:	0001883a 	nop
81119a60:	e037883a 	mov	sp,fp
81119a64:	dfc00117 	ldw	ra,4(sp)
81119a68:	df000017 	ldw	fp,0(sp)
81119a6c:	dec00204 	addi	sp,sp,8
81119a70:	f800283a 	ret

81119a74 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
81119a74:	defffe04 	addi	sp,sp,-8
81119a78:	de00012e 	bgeu	sp,et,81119a80 <vFailCreateSemaphoreResources+0xc>
81119a7c:	003b68fa 	trap	3
81119a80:	dfc00115 	stw	ra,4(sp)
81119a84:	df000015 	stw	fp,0(sp)
81119a88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
81119a8c:	d0a06117 	ldw	r2,-32380(gp)
81119a90:	100f883a 	mov	r7,r2
81119a94:	01800984 	movi	r6,38
81119a98:	01400044 	movi	r5,1
81119a9c:	01204574 	movhi	r4,33045
81119aa0:	21322404 	addi	r4,r4,-14192
81119aa4:	111fc980 	call	8111fc98 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119aa8:	0001883a 	nop
81119aac:	e037883a 	mov	sp,fp
81119ab0:	dfc00117 	ldw	ra,4(sp)
81119ab4:	df000017 	ldw	fp,0(sp)
81119ab8:	dec00204 	addi	sp,sp,8
81119abc:	f800283a 	ret

81119ac0 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81119ac0:	defffe04 	addi	sp,sp,-8
81119ac4:	de00012e 	bgeu	sp,et,81119acc <vFailTestCriticasParts+0xc>
81119ac8:	003b68fa 	trap	3
81119acc:	dfc00115 	stw	ra,4(sp)
81119ad0:	df000015 	stw	fp,0(sp)
81119ad4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
81119ad8:	d0a06117 	ldw	r2,-32380(gp)
81119adc:	100f883a 	mov	r7,r2
81119ae0:	018007c4 	movi	r6,31
81119ae4:	01400044 	movi	r5,1
81119ae8:	01204574 	movhi	r4,33045
81119aec:	21322e04 	addi	r4,r4,-14152
81119af0:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119af4:	0001883a 	nop
81119af8:	e037883a 	mov	sp,fp
81119afc:	dfc00117 	ldw	ra,4(sp)
81119b00:	df000017 	ldw	fp,0(sp)
81119b04:	dec00204 	addi	sp,sp,8
81119b08:	f800283a 	ret

81119b0c <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81119b0c:	defffe04 	addi	sp,sp,-8
81119b10:	de00012e 	bgeu	sp,et,81119b18 <vFailSendxSemCommInit+0xc>
81119b14:	003b68fa 	trap	3
81119b18:	dfc00115 	stw	ra,4(sp)
81119b1c:	df000015 	stw	fp,0(sp)
81119b20:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81119b24:	d0a06117 	ldw	r2,-32380(gp)
81119b28:	100f883a 	mov	r7,r2
81119b2c:	01800744 	movi	r6,29
81119b30:	01400044 	movi	r5,1
81119b34:	01204574 	movhi	r4,33045
81119b38:	21323604 	addi	r4,r4,-14120
81119b3c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
81119b40:	d0a06117 	ldw	r2,-32380(gp)
81119b44:	100f883a 	mov	r7,r2
81119b48:	01800a44 	movi	r6,41
81119b4c:	01400044 	movi	r5,1
81119b50:	01204574 	movhi	r4,33045
81119b54:	21323e04 	addi	r4,r4,-14088
81119b58:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119b5c:	0001883a 	nop
81119b60:	e037883a 	mov	sp,fp
81119b64:	dfc00117 	ldw	ra,4(sp)
81119b68:	df000017 	ldw	fp,0(sp)
81119b6c:	dec00204 	addi	sp,sp,8
81119b70:	f800283a 	ret

81119b74 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
81119b74:	defffe04 	addi	sp,sp,-8
81119b78:	de00012e 	bgeu	sp,et,81119b80 <vFailSendPreParsedSemaphore+0xc>
81119b7c:	003b68fa 	trap	3
81119b80:	dfc00115 	stw	ra,4(sp)
81119b84:	df000015 	stw	fp,0(sp)
81119b88:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
81119b8c:	d0a06117 	ldw	r2,-32380(gp)
81119b90:	100f883a 	mov	r7,r2
81119b94:	01800904 	movi	r6,36
81119b98:	01400044 	movi	r5,1
81119b9c:	01204574 	movhi	r4,33045
81119ba0:	21324904 	addi	r4,r4,-14044
81119ba4:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119ba8:	0001883a 	nop
81119bac:	e037883a 	mov	sp,fp
81119bb0:	dfc00117 	ldw	ra,4(sp)
81119bb4:	df000017 	ldw	fp,0(sp)
81119bb8:	dec00204 	addi	sp,sp,8
81119bbc:	f800283a 	ret

81119bc0 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81119bc0:	defffe04 	addi	sp,sp,-8
81119bc4:	de00012e 	bgeu	sp,et,81119bcc <vFailSendPreAckReceiverSemaphore+0xc>
81119bc8:	003b68fa 	trap	3
81119bcc:	dfc00115 	stw	ra,4(sp)
81119bd0:	df000015 	stw	fp,0(sp)
81119bd4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
81119bd8:	d0a06117 	ldw	r2,-32380(gp)
81119bdc:	100f883a 	mov	r7,r2
81119be0:	01800a44 	movi	r6,41
81119be4:	01400044 	movi	r5,1
81119be8:	01204574 	movhi	r4,33045
81119bec:	21325304 	addi	r4,r4,-14004
81119bf0:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119bf4:	0001883a 	nop
81119bf8:	e037883a 	mov	sp,fp
81119bfc:	dfc00117 	ldw	ra,4(sp)
81119c00:	df000017 	ldw	fp,0(sp)
81119c04:	dec00204 	addi	sp,sp,8
81119c08:	f800283a 	ret

81119c0c <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81119c0c:	defffe04 	addi	sp,sp,-8
81119c10:	de00012e 	bgeu	sp,et,81119c18 <vFailSendPreAckSenderSemaphore+0xc>
81119c14:	003b68fa 	trap	3
81119c18:	dfc00115 	stw	ra,4(sp)
81119c1c:	df000015 	stw	fp,0(sp)
81119c20:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81119c24:	d0a06117 	ldw	r2,-32380(gp)
81119c28:	100f883a 	mov	r7,r2
81119c2c:	018009c4 	movi	r6,39
81119c30:	01400044 	movi	r5,1
81119c34:	01204574 	movhi	r4,33045
81119c38:	21325e04 	addi	r4,r4,-13960
81119c3c:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119c40:	0001883a 	nop
81119c44:	e037883a 	mov	sp,fp
81119c48:	dfc00117 	ldw	ra,4(sp)
81119c4c:	df000017 	ldw	fp,0(sp)
81119c50:	dec00204 	addi	sp,sp,8
81119c54:	f800283a 	ret

81119c58 <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
81119c58:	defffe04 	addi	sp,sp,-8
81119c5c:	de00012e 	bgeu	sp,et,81119c64 <vFailGetCountSemaphoreSenderTask+0xc>
81119c60:	003b68fa 	trap	3
81119c64:	dfc00115 	stw	ra,4(sp)
81119c68:	df000015 	stw	fp,0(sp)
81119c6c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
81119c70:	d0a06117 	ldw	r2,-32380(gp)
81119c74:	100f883a 	mov	r7,r2
81119c78:	01800a44 	movi	r6,41
81119c7c:	01400044 	movi	r5,1
81119c80:	01204574 	movhi	r4,33045
81119c84:	21326804 	addi	r4,r4,-13920
81119c88:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
81119c8c:	d0a06117 	ldw	r2,-32380(gp)
81119c90:	100f883a 	mov	r7,r2
81119c94:	01801104 	movi	r6,68
81119c98:	01400044 	movi	r5,1
81119c9c:	01204574 	movhi	r4,33045
81119ca0:	21327304 	addi	r4,r4,-13876
81119ca4:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119ca8:	0001883a 	nop
81119cac:	e037883a 	mov	sp,fp
81119cb0:	dfc00117 	ldw	ra,4(sp)
81119cb4:	df000017 	ldw	fp,0(sp)
81119cb8:	dec00204 	addi	sp,sp,8
81119cbc:	f800283a 	ret

81119cc0 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81119cc0:	defffe04 	addi	sp,sp,-8
81119cc4:	de00012e 	bgeu	sp,et,81119ccc <vFailGetMutexSenderTask+0xc>
81119cc8:	003b68fa 	trap	3
81119ccc:	dfc00115 	stw	ra,4(sp)
81119cd0:	df000015 	stw	fp,0(sp)
81119cd4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
81119cd8:	d0a06117 	ldw	r2,-32380(gp)
81119cdc:	100f883a 	mov	r7,r2
81119ce0:	01800804 	movi	r6,32
81119ce4:	01400044 	movi	r5,1
81119ce8:	01204574 	movhi	r4,33045
81119cec:	21328504 	addi	r4,r4,-13804
81119cf0:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81119cf4:	d0a06117 	ldw	r2,-32380(gp)
81119cf8:	100f883a 	mov	r7,r2
81119cfc:	01801084 	movi	r6,66
81119d00:	01400044 	movi	r5,1
81119d04:	01204574 	movhi	r4,33045
81119d08:	21328e04 	addi	r4,r4,-13768
81119d0c:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119d10:	0001883a 	nop
81119d14:	e037883a 	mov	sp,fp
81119d18:	dfc00117 	ldw	ra,4(sp)
81119d1c:	df000017 	ldw	fp,0(sp)
81119d20:	dec00204 	addi	sp,sp,8
81119d24:	f800283a 	ret

81119d28 <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81119d28:	defffe04 	addi	sp,sp,-8
81119d2c:	de00012e 	bgeu	sp,et,81119d34 <vFailGetCountSemaphoreReceiverTask+0xc>
81119d30:	003b68fa 	trap	3
81119d34:	dfc00115 	stw	ra,4(sp)
81119d38:	df000015 	stw	fp,0(sp)
81119d3c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
81119d40:	d0a06117 	ldw	r2,-32380(gp)
81119d44:	100f883a 	mov	r7,r2
81119d48:	01800ac4 	movi	r6,43
81119d4c:	01400044 	movi	r5,1
81119d50:	01204574 	movhi	r4,33045
81119d54:	21329f04 	addi	r4,r4,-13700
81119d58:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
81119d5c:	d0a06117 	ldw	r2,-32380(gp)
81119d60:	100f883a 	mov	r7,r2
81119d64:	01801184 	movi	r6,70
81119d68:	01400044 	movi	r5,1
81119d6c:	01204574 	movhi	r4,33045
81119d70:	2132aa04 	addi	r4,r4,-13656
81119d74:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119d78:	0001883a 	nop
81119d7c:	e037883a 	mov	sp,fp
81119d80:	dfc00117 	ldw	ra,4(sp)
81119d84:	df000017 	ldw	fp,0(sp)
81119d88:	dec00204 	addi	sp,sp,8
81119d8c:	f800283a 	ret

81119d90 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
81119d90:	defffe04 	addi	sp,sp,-8
81119d94:	de00012e 	bgeu	sp,et,81119d9c <vFailGetMutexReceiverTask+0xc>
81119d98:	003b68fa 	trap	3
81119d9c:	dfc00115 	stw	ra,4(sp)
81119da0:	df000015 	stw	fp,0(sp)
81119da4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
81119da8:	d0a06117 	ldw	r2,-32380(gp)
81119dac:	100f883a 	mov	r7,r2
81119db0:	01800884 	movi	r6,34
81119db4:	01400044 	movi	r5,1
81119db8:	01204574 	movhi	r4,33045
81119dbc:	2132bc04 	addi	r4,r4,-13584
81119dc0:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81119dc4:	d0a06117 	ldw	r2,-32380(gp)
81119dc8:	100f883a 	mov	r7,r2
81119dcc:	01801104 	movi	r6,68
81119dd0:	01400044 	movi	r5,1
81119dd4:	01204574 	movhi	r4,33045
81119dd8:	2132c504 	addi	r4,r4,-13548
81119ddc:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119de0:	0001883a 	nop
81119de4:	e037883a 	mov	sp,fp
81119de8:	dfc00117 	ldw	ra,4(sp)
81119dec:	df000017 	ldw	fp,0(sp)
81119df0:	dec00204 	addi	sp,sp,8
81119df4:	f800283a 	ret

81119df8 <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81119df8:	defffe04 	addi	sp,sp,-8
81119dfc:	de00012e 	bgeu	sp,et,81119e04 <vFailGetMutexTxUARTSenderTask+0xc>
81119e00:	003b68fa 	trap	3
81119e04:	dfc00115 	stw	ra,4(sp)
81119e08:	df000015 	stw	fp,0(sp)
81119e0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81119e10:	d0a06117 	ldw	r2,-32380(gp)
81119e14:	100f883a 	mov	r7,r2
81119e18:	01800984 	movi	r6,38
81119e1c:	01400044 	movi	r5,1
81119e20:	01204574 	movhi	r4,33045
81119e24:	2132d704 	addi	r4,r4,-13476
81119e28:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
81119e2c:	d0a06117 	ldw	r2,-32380(gp)
81119e30:	100f883a 	mov	r7,r2
81119e34:	01801044 	movi	r6,65
81119e38:	01400044 	movi	r5,1
81119e3c:	01204574 	movhi	r4,33045
81119e40:	2132e104 	addi	r4,r4,-13436
81119e44:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119e48:	0001883a 	nop
81119e4c:	e037883a 	mov	sp,fp
81119e50:	dfc00117 	ldw	ra,4(sp)
81119e54:	df000017 	ldw	fp,0(sp)
81119e58:	dec00204 	addi	sp,sp,8
81119e5c:	f800283a 	ret

81119e60 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
81119e60:	defffe04 	addi	sp,sp,-8
81119e64:	de00012e 	bgeu	sp,et,81119e6c <vFailGetMacRTC+0xc>
81119e68:	003b68fa 	trap	3
81119e6c:	dfc00115 	stw	ra,4(sp)
81119e70:	df000015 	stw	fp,0(sp)
81119e74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
81119e78:	d0a06117 	ldw	r2,-32380(gp)
81119e7c:	100f883a 	mov	r7,r2
81119e80:	018003c4 	movi	r6,15
81119e84:	01400044 	movi	r5,1
81119e88:	01204574 	movhi	r4,33045
81119e8c:	2132f204 	addi	r4,r4,-13368
81119e90:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119e94:	0001883a 	nop
81119e98:	e037883a 	mov	sp,fp
81119e9c:	dfc00117 	ldw	ra,4(sp)
81119ea0:	df000017 	ldw	fp,0(sp)
81119ea4:	dec00204 	addi	sp,sp,8
81119ea8:	f800283a 	ret

81119eac <vFailInitialization>:


void vFailInitialization( void )
{
81119eac:	defffe04 	addi	sp,sp,-8
81119eb0:	de00012e 	bgeu	sp,et,81119eb8 <vFailInitialization+0xc>
81119eb4:	003b68fa 	trap	3
81119eb8:	dfc00115 	stw	ra,4(sp)
81119ebc:	df000015 	stw	fp,0(sp)
81119ec0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81119ec4:	d0a06117 	ldw	r2,-32380(gp)
81119ec8:	100f883a 	mov	r7,r2
81119ecc:	01800504 	movi	r6,20
81119ed0:	01400044 	movi	r5,1
81119ed4:	01204574 	movhi	r4,33045
81119ed8:	2132f604 	addi	r4,r4,-13352
81119edc:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119ee0:	0001883a 	nop
81119ee4:	e037883a 	mov	sp,fp
81119ee8:	dfc00117 	ldw	ra,4(sp)
81119eec:	df000017 	ldw	fp,0(sp)
81119ef0:	dec00204 	addi	sp,sp,8
81119ef4:	f800283a 	ret

81119ef8 <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81119ef8:	defffe04 	addi	sp,sp,-8
81119efc:	de00012e 	bgeu	sp,et,81119f04 <vFailReceiverCreate+0xc>
81119f00:	003b68fa 	trap	3
81119f04:	dfc00115 	stw	ra,4(sp)
81119f08:	df000015 	stw	fp,0(sp)
81119f0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81119f10:	d0a06117 	ldw	r2,-32380(gp)
81119f14:	100f883a 	mov	r7,r2
81119f18:	01800484 	movi	r6,18
81119f1c:	01400044 	movi	r5,1
81119f20:	01204574 	movhi	r4,33045
81119f24:	2132fc04 	addi	r4,r4,-13328
81119f28:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119f2c:	0001883a 	nop
81119f30:	e037883a 	mov	sp,fp
81119f34:	dfc00117 	ldw	ra,4(sp)
81119f38:	df000017 	ldw	fp,0(sp)
81119f3c:	dec00204 	addi	sp,sp,8
81119f40:	f800283a 	ret

81119f44 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
81119f44:	defffe04 	addi	sp,sp,-8
81119f48:	de00012e 	bgeu	sp,et,81119f50 <vFailSenderCreate+0xc>
81119f4c:	003b68fa 	trap	3
81119f50:	dfc00115 	stw	ra,4(sp)
81119f54:	df000015 	stw	fp,0(sp)
81119f58:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
81119f5c:	d0a06117 	ldw	r2,-32380(gp)
81119f60:	100f883a 	mov	r7,r2
81119f64:	01800484 	movi	r6,18
81119f68:	01400044 	movi	r5,1
81119f6c:	01204574 	movhi	r4,33045
81119f70:	21330104 	addi	r4,r4,-13308
81119f74:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119f78:	0001883a 	nop
81119f7c:	e037883a 	mov	sp,fp
81119f80:	dfc00117 	ldw	ra,4(sp)
81119f84:	df000017 	ldw	fp,0(sp)
81119f88:	dec00204 	addi	sp,sp,8
81119f8c:	f800283a 	ret

81119f90 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
81119f90:	defffe04 	addi	sp,sp,-8
81119f94:	de00012e 	bgeu	sp,et,81119f9c <vFailDeleteInitialization+0xc>
81119f98:	003b68fa 	trap	3
81119f9c:	dfc00115 	stw	ra,4(sp)
81119fa0:	df000015 	stw	fp,0(sp)
81119fa4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
81119fa8:	d0a06117 	ldw	r2,-32380(gp)
81119fac:	100f883a 	mov	r7,r2
81119fb0:	01800684 	movi	r6,26
81119fb4:	01400044 	movi	r5,1
81119fb8:	01204574 	movhi	r4,33045
81119fbc:	21330604 	addi	r4,r4,-13288
81119fc0:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119fc4:	0001883a 	nop
81119fc8:	e037883a 	mov	sp,fp
81119fcc:	dfc00117 	ldw	ra,4(sp)
81119fd0:	df000017 	ldw	fp,0(sp)
81119fd4:	dec00204 	addi	sp,sp,8
81119fd8:	f800283a 	ret

81119fdc <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81119fdc:	defffe04 	addi	sp,sp,-8
81119fe0:	de00012e 	bgeu	sp,et,81119fe8 <vFailSetCountSemaphorexBuffer32+0xc>
81119fe4:	003b68fa 	trap	3
81119fe8:	dfc00115 	stw	ra,4(sp)
81119fec:	df000015 	stw	fp,0(sp)
81119ff0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81119ff4:	d0a06117 	ldw	r2,-32380(gp)
81119ff8:	100f883a 	mov	r7,r2
81119ffc:	01800a04 	movi	r6,40
8111a000:	01400044 	movi	r5,1
8111a004:	01204574 	movhi	r4,33045
8111a008:	21330d04 	addi	r4,r4,-13260
8111a00c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111a010:	d0a06117 	ldw	r2,-32380(gp)
8111a014:	100f883a 	mov	r7,r2
8111a018:	018008c4 	movi	r6,35
8111a01c:	01400044 	movi	r5,1
8111a020:	01204574 	movhi	r4,33045
8111a024:	21331804 	addi	r4,r4,-13216
8111a028:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a02c:	0001883a 	nop
8111a030:	e037883a 	mov	sp,fp
8111a034:	dfc00117 	ldw	ra,4(sp)
8111a038:	df000017 	ldw	fp,0(sp)
8111a03c:	dec00204 	addi	sp,sp,8
8111a040:	f800283a 	ret

8111a044 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
8111a044:	defffe04 	addi	sp,sp,-8
8111a048:	de00012e 	bgeu	sp,et,8111a050 <vFailSetCountSemaphorexBuffer64+0xc>
8111a04c:	003b68fa 	trap	3
8111a050:	dfc00115 	stw	ra,4(sp)
8111a054:	df000015 	stw	fp,0(sp)
8111a058:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
8111a05c:	d0a06117 	ldw	r2,-32380(gp)
8111a060:	100f883a 	mov	r7,r2
8111a064:	01800a04 	movi	r6,40
8111a068:	01400044 	movi	r5,1
8111a06c:	01204574 	movhi	r4,33045
8111a070:	21332104 	addi	r4,r4,-13180
8111a074:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111a078:	d0a06117 	ldw	r2,-32380(gp)
8111a07c:	100f883a 	mov	r7,r2
8111a080:	018008c4 	movi	r6,35
8111a084:	01400044 	movi	r5,1
8111a088:	01204574 	movhi	r4,33045
8111a08c:	21331804 	addi	r4,r4,-13216
8111a090:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a094:	0001883a 	nop
8111a098:	e037883a 	mov	sp,fp
8111a09c:	dfc00117 	ldw	ra,4(sp)
8111a0a0:	df000017 	ldw	fp,0(sp)
8111a0a4:	dec00204 	addi	sp,sp,8
8111a0a8:	f800283a 	ret

8111a0ac <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
8111a0ac:	defffe04 	addi	sp,sp,-8
8111a0b0:	de00012e 	bgeu	sp,et,8111a0b8 <vFailSetCountSemaphorexBuffer128+0xc>
8111a0b4:	003b68fa 	trap	3
8111a0b8:	dfc00115 	stw	ra,4(sp)
8111a0bc:	df000015 	stw	fp,0(sp)
8111a0c0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
8111a0c4:	d0a06117 	ldw	r2,-32380(gp)
8111a0c8:	100f883a 	mov	r7,r2
8111a0cc:	01800a44 	movi	r6,41
8111a0d0:	01400044 	movi	r5,1
8111a0d4:	01204574 	movhi	r4,33045
8111a0d8:	21332c04 	addi	r4,r4,-13136
8111a0dc:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111a0e0:	d0a06117 	ldw	r2,-32380(gp)
8111a0e4:	100f883a 	mov	r7,r2
8111a0e8:	018008c4 	movi	r6,35
8111a0ec:	01400044 	movi	r5,1
8111a0f0:	01204574 	movhi	r4,33045
8111a0f4:	21331804 	addi	r4,r4,-13216
8111a0f8:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a0fc:	0001883a 	nop
8111a100:	e037883a 	mov	sp,fp
8111a104:	dfc00117 	ldw	ra,4(sp)
8111a108:	df000017 	ldw	fp,0(sp)
8111a10c:	dec00204 	addi	sp,sp,8
8111a110:	f800283a 	ret

8111a114 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
8111a114:	defffe04 	addi	sp,sp,-8
8111a118:	de00012e 	bgeu	sp,et,8111a120 <vFailGetCountSemaphorexBuffer128+0xc>
8111a11c:	003b68fa 	trap	3
8111a120:	dfc00115 	stw	ra,4(sp)
8111a124:	df000015 	stw	fp,0(sp)
8111a128:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
8111a12c:	d0a06117 	ldw	r2,-32380(gp)
8111a130:	100f883a 	mov	r7,r2
8111a134:	01800a44 	movi	r6,41
8111a138:	01400044 	movi	r5,1
8111a13c:	01204574 	movhi	r4,33045
8111a140:	21333704 	addi	r4,r4,-13092
8111a144:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111a148:	d0a06117 	ldw	r2,-32380(gp)
8111a14c:	100f883a 	mov	r7,r2
8111a150:	01800884 	movi	r6,34
8111a154:	01400044 	movi	r5,1
8111a158:	01204574 	movhi	r4,33045
8111a15c:	21334204 	addi	r4,r4,-13048
8111a160:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a164:	0001883a 	nop
8111a168:	e037883a 	mov	sp,fp
8111a16c:	dfc00117 	ldw	ra,4(sp)
8111a170:	df000017 	ldw	fp,0(sp)
8111a174:	dec00204 	addi	sp,sp,8
8111a178:	f800283a 	ret

8111a17c <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
8111a17c:	defffe04 	addi	sp,sp,-8
8111a180:	de00012e 	bgeu	sp,et,8111a188 <vFailGetCountSemaphorexBuffer64+0xc>
8111a184:	003b68fa 	trap	3
8111a188:	dfc00115 	stw	ra,4(sp)
8111a18c:	df000015 	stw	fp,0(sp)
8111a190:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
8111a194:	d0a06117 	ldw	r2,-32380(gp)
8111a198:	100f883a 	mov	r7,r2
8111a19c:	01800a04 	movi	r6,40
8111a1a0:	01400044 	movi	r5,1
8111a1a4:	01204574 	movhi	r4,33045
8111a1a8:	21334b04 	addi	r4,r4,-13012
8111a1ac:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111a1b0:	d0a06117 	ldw	r2,-32380(gp)
8111a1b4:	100f883a 	mov	r7,r2
8111a1b8:	01800884 	movi	r6,34
8111a1bc:	01400044 	movi	r5,1
8111a1c0:	01204574 	movhi	r4,33045
8111a1c4:	21334204 	addi	r4,r4,-13048
8111a1c8:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a1cc:	0001883a 	nop
8111a1d0:	e037883a 	mov	sp,fp
8111a1d4:	dfc00117 	ldw	ra,4(sp)
8111a1d8:	df000017 	ldw	fp,0(sp)
8111a1dc:	dec00204 	addi	sp,sp,8
8111a1e0:	f800283a 	ret

8111a1e4 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
8111a1e4:	defffe04 	addi	sp,sp,-8
8111a1e8:	de00012e 	bgeu	sp,et,8111a1f0 <vFailGetCountSemaphorexBuffer32+0xc>
8111a1ec:	003b68fa 	trap	3
8111a1f0:	dfc00115 	stw	ra,4(sp)
8111a1f4:	df000015 	stw	fp,0(sp)
8111a1f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
8111a1fc:	d0a06117 	ldw	r2,-32380(gp)
8111a200:	100f883a 	mov	r7,r2
8111a204:	01800a04 	movi	r6,40
8111a208:	01400044 	movi	r5,1
8111a20c:	01204574 	movhi	r4,33045
8111a210:	21335604 	addi	r4,r4,-12968
8111a214:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
8111a218:	d0a06117 	ldw	r2,-32380(gp)
8111a21c:	100f883a 	mov	r7,r2
8111a220:	01800884 	movi	r6,34
8111a224:	01400044 	movi	r5,1
8111a228:	01204574 	movhi	r4,33045
8111a22c:	21334204 	addi	r4,r4,-13048
8111a230:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a234:	0001883a 	nop
8111a238:	e037883a 	mov	sp,fp
8111a23c:	dfc00117 	ldw	ra,4(sp)
8111a240:	df000017 	ldw	fp,0(sp)
8111a244:	dec00204 	addi	sp,sp,8
8111a248:	f800283a 	ret

8111a24c <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
8111a24c:	defffe04 	addi	sp,sp,-8
8111a250:	de00012e 	bgeu	sp,et,8111a258 <vFailFoundBufferRetransmission+0xc>
8111a254:	003b68fa 	trap	3
8111a258:	dfc00115 	stw	ra,4(sp)
8111a25c:	df000015 	stw	fp,0(sp)
8111a260:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
8111a264:	d0a06117 	ldw	r2,-32380(gp)
8111a268:	100f883a 	mov	r7,r2
8111a26c:	01800a84 	movi	r6,42
8111a270:	01400044 	movi	r5,1
8111a274:	01204574 	movhi	r4,33045
8111a278:	21336104 	addi	r4,r4,-12924
8111a27c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
8111a280:	d0a06117 	ldw	r2,-32380(gp)
8111a284:	100f883a 	mov	r7,r2
8111a288:	01801204 	movi	r6,72
8111a28c:	01400044 	movi	r5,1
8111a290:	01204574 	movhi	r4,33045
8111a294:	21336c04 	addi	r4,r4,-12880
8111a298:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a29c:	0001883a 	nop
8111a2a0:	e037883a 	mov	sp,fp
8111a2a4:	dfc00117 	ldw	ra,4(sp)
8111a2a8:	df000017 	ldw	fp,0(sp)
8111a2ac:	dec00204 	addi	sp,sp,8
8111a2b0:	f800283a 	ret

8111a2b4 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
8111a2b4:	defffe04 	addi	sp,sp,-8
8111a2b8:	de00012e 	bgeu	sp,et,8111a2c0 <vFailGetCountSemaphorePreParsedBuffer+0xc>
8111a2bc:	003b68fa 	trap	3
8111a2c0:	dfc00115 	stw	ra,4(sp)
8111a2c4:	df000015 	stw	fp,0(sp)
8111a2c8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
8111a2cc:	d0a06117 	ldw	r2,-32380(gp)
8111a2d0:	100f883a 	mov	r7,r2
8111a2d4:	01800b84 	movi	r6,46
8111a2d8:	01400044 	movi	r5,1
8111a2dc:	01204574 	movhi	r4,33045
8111a2e0:	21337f04 	addi	r4,r4,-12804
8111a2e4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111a2e8:	d0a06117 	ldw	r2,-32380(gp)
8111a2ec:	100f883a 	mov	r7,r2
8111a2f0:	018010c4 	movi	r6,67
8111a2f4:	01400044 	movi	r5,1
8111a2f8:	01204574 	movhi	r4,33045
8111a2fc:	21338b04 	addi	r4,r4,-12756
8111a300:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a304:	0001883a 	nop
8111a308:	e037883a 	mov	sp,fp
8111a30c:	dfc00117 	ldw	ra,4(sp)
8111a310:	df000017 	ldw	fp,0(sp)
8111a314:	dec00204 	addi	sp,sp,8
8111a318:	f800283a 	ret

8111a31c <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
8111a31c:	defffe04 	addi	sp,sp,-8
8111a320:	de00012e 	bgeu	sp,et,8111a328 <vFailGetxMutexPreParsedParserRxTask+0xc>
8111a324:	003b68fa 	trap	3
8111a328:	dfc00115 	stw	ra,4(sp)
8111a32c:	df000015 	stw	fp,0(sp)
8111a330:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
8111a334:	d0a06117 	ldw	r2,-32380(gp)
8111a338:	100f883a 	mov	r7,r2
8111a33c:	01800b04 	movi	r6,44
8111a340:	01400044 	movi	r5,1
8111a344:	01204574 	movhi	r4,33045
8111a348:	21339c04 	addi	r4,r4,-12688
8111a34c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
8111a350:	d0a06117 	ldw	r2,-32380(gp)
8111a354:	100f883a 	mov	r7,r2
8111a358:	01800fc4 	movi	r6,63
8111a35c:	01400044 	movi	r5,1
8111a360:	01204574 	movhi	r4,33045
8111a364:	2133a804 	addi	r4,r4,-12640
8111a368:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a36c:	0001883a 	nop
8111a370:	e037883a 	mov	sp,fp
8111a374:	dfc00117 	ldw	ra,4(sp)
8111a378:	df000017 	ldw	fp,0(sp)
8111a37c:	dec00204 	addi	sp,sp,8
8111a380:	f800283a 	ret

8111a384 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
8111a384:	defffe04 	addi	sp,sp,-8
8111a388:	de00012e 	bgeu	sp,et,8111a390 <vNoContentInPreParsedBuffer+0xc>
8111a38c:	003b68fa 	trap	3
8111a390:	dfc00115 	stw	ra,4(sp)
8111a394:	df000015 	stw	fp,0(sp)
8111a398:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
8111a39c:	d0a06117 	ldw	r2,-32380(gp)
8111a3a0:	100f883a 	mov	r7,r2
8111a3a4:	01800904 	movi	r6,36
8111a3a8:	01400044 	movi	r5,1
8111a3ac:	01204574 	movhi	r4,33045
8111a3b0:	2133b804 	addi	r4,r4,-12576
8111a3b4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111a3b8:	d0a06117 	ldw	r2,-32380(gp)
8111a3bc:	100f883a 	mov	r7,r2
8111a3c0:	01801684 	movi	r6,90
8111a3c4:	01400044 	movi	r5,1
8111a3c8:	01204574 	movhi	r4,33045
8111a3cc:	2133c204 	addi	r4,r4,-12536
8111a3d0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a3d4:	0001883a 	nop
8111a3d8:	e037883a 	mov	sp,fp
8111a3dc:	dfc00117 	ldw	ra,4(sp)
8111a3e0:	df000017 	ldw	fp,0(sp)
8111a3e4:	dec00204 	addi	sp,sp,8
8111a3e8:	f800283a 	ret

8111a3ec <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
8111a3ec:	defffe04 	addi	sp,sp,-8
8111a3f0:	de00012e 	bgeu	sp,et,8111a3f8 <vCouldNotSendEthConfUART+0xc>
8111a3f4:	003b68fa 	trap	3
8111a3f8:	dfc00115 	stw	ra,4(sp)
8111a3fc:	df000015 	stw	fp,0(sp)
8111a400:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
8111a404:	d0a06117 	ldw	r2,-32380(gp)
8111a408:	100f883a 	mov	r7,r2
8111a40c:	01800844 	movi	r6,33
8111a410:	01400044 	movi	r5,1
8111a414:	01204574 	movhi	r4,33045
8111a418:	2133d904 	addi	r4,r4,-12444
8111a41c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
8111a420:	d0a06117 	ldw	r2,-32380(gp)
8111a424:	100f883a 	mov	r7,r2
8111a428:	01801784 	movi	r6,94
8111a42c:	01400044 	movi	r5,1
8111a430:	01204574 	movhi	r4,33045
8111a434:	2133e204 	addi	r4,r4,-12408
8111a438:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a43c:	0001883a 	nop
8111a440:	e037883a 	mov	sp,fp
8111a444:	dfc00117 	ldw	ra,4(sp)
8111a448:	df000017 	ldw	fp,0(sp)
8111a44c:	dec00204 	addi	sp,sp,8
8111a450:	f800283a 	ret

8111a454 <vFailSendNack>:

void vFailSendNack( void )
{
8111a454:	defffe04 	addi	sp,sp,-8
8111a458:	de00012e 	bgeu	sp,et,8111a460 <vFailSendNack+0xc>
8111a45c:	003b68fa 	trap	3
8111a460:	dfc00115 	stw	ra,4(sp)
8111a464:	df000015 	stw	fp,0(sp)
8111a468:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
8111a46c:	d0a06117 	ldw	r2,-32380(gp)
8111a470:	100f883a 	mov	r7,r2
8111a474:	01800584 	movi	r6,22
8111a478:	01400044 	movi	r5,1
8111a47c:	01204574 	movhi	r4,33045
8111a480:	2133fa04 	addi	r4,r4,-12312
8111a484:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111a488:	d0a06117 	ldw	r2,-32380(gp)
8111a48c:	100f883a 	mov	r7,r2
8111a490:	01800a84 	movi	r6,42
8111a494:	01400044 	movi	r5,1
8111a498:	01204574 	movhi	r4,33045
8111a49c:	21340004 	addi	r4,r4,-12288
8111a4a0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a4a4:	0001883a 	nop
8111a4a8:	e037883a 	mov	sp,fp
8111a4ac:	dfc00117 	ldw	ra,4(sp)
8111a4b0:	df000017 	ldw	fp,0(sp)
8111a4b4:	dec00204 	addi	sp,sp,8
8111a4b8:	f800283a 	ret

8111a4bc <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
8111a4bc:	defffe04 	addi	sp,sp,-8
8111a4c0:	de00012e 	bgeu	sp,et,8111a4c8 <vFailSetPreAckSenderBuffer+0xc>
8111a4c4:	003b68fa 	trap	3
8111a4c8:	dfc00115 	stw	ra,4(sp)
8111a4cc:	df000015 	stw	fp,0(sp)
8111a4d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
8111a4d4:	d0a06117 	ldw	r2,-32380(gp)
8111a4d8:	100f883a 	mov	r7,r2
8111a4dc:	018008c4 	movi	r6,35
8111a4e0:	01400044 	movi	r5,1
8111a4e4:	01204574 	movhi	r4,33045
8111a4e8:	21340b04 	addi	r4,r4,-12244
8111a4ec:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
8111a4f0:	d0a06117 	ldw	r2,-32380(gp)
8111a4f4:	100f883a 	mov	r7,r2
8111a4f8:	01801584 	movi	r6,86
8111a4fc:	01400044 	movi	r5,1
8111a500:	01204574 	movhi	r4,33045
8111a504:	21341404 	addi	r4,r4,-12208
8111a508:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a50c:	0001883a 	nop
8111a510:	e037883a 	mov	sp,fp
8111a514:	dfc00117 	ldw	ra,4(sp)
8111a518:	df000017 	ldw	fp,0(sp)
8111a51c:	dec00204 	addi	sp,sp,8
8111a520:	f800283a 	ret

8111a524 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
8111a524:	defffe04 	addi	sp,sp,-8
8111a528:	de00012e 	bgeu	sp,et,8111a530 <vFailSetPreParsedBuffer+0xc>
8111a52c:	003b68fa 	trap	3
8111a530:	dfc00115 	stw	ra,4(sp)
8111a534:	df000015 	stw	fp,0(sp)
8111a538:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
8111a53c:	d0a06117 	ldw	r2,-32380(gp)
8111a540:	100f883a 	mov	r7,r2
8111a544:	01800804 	movi	r6,32
8111a548:	01400044 	movi	r5,1
8111a54c:	01204574 	movhi	r4,33045
8111a550:	21342a04 	addi	r4,r4,-12120
8111a554:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
8111a558:	d0a06117 	ldw	r2,-32380(gp)
8111a55c:	100f883a 	mov	r7,r2
8111a560:	018013c4 	movi	r6,79
8111a564:	01400044 	movi	r5,1
8111a568:	01204574 	movhi	r4,33045
8111a56c:	21343304 	addi	r4,r4,-12084
8111a570:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a574:	0001883a 	nop
8111a578:	e037883a 	mov	sp,fp
8111a57c:	dfc00117 	ldw	ra,4(sp)
8111a580:	df000017 	ldw	fp,0(sp)
8111a584:	dec00204 	addi	sp,sp,8
8111a588:	f800283a 	ret

8111a58c <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
8111a58c:	defffe04 	addi	sp,sp,-8
8111a590:	de00012e 	bgeu	sp,et,8111a598 <vFailSetPreAckReceiverBuffer+0xc>
8111a594:	003b68fa 	trap	3
8111a598:	dfc00115 	stw	ra,4(sp)
8111a59c:	df000015 	stw	fp,0(sp)
8111a5a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
8111a5a4:	d0a06117 	ldw	r2,-32380(gp)
8111a5a8:	100f883a 	mov	r7,r2
8111a5ac:	01800944 	movi	r6,37
8111a5b0:	01400044 	movi	r5,1
8111a5b4:	01204574 	movhi	r4,33045
8111a5b8:	21344704 	addi	r4,r4,-12004
8111a5bc:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
8111a5c0:	d0a06117 	ldw	r2,-32380(gp)
8111a5c4:	100f883a 	mov	r7,r2
8111a5c8:	018015c4 	movi	r6,87
8111a5cc:	01400044 	movi	r5,1
8111a5d0:	01204574 	movhi	r4,33045
8111a5d4:	21345104 	addi	r4,r4,-11964
8111a5d8:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a5dc:	0001883a 	nop
8111a5e0:	e037883a 	mov	sp,fp
8111a5e4:	dfc00117 	ldw	ra,4(sp)
8111a5e8:	df000017 	ldw	fp,0(sp)
8111a5ec:	dec00204 	addi	sp,sp,8
8111a5f0:	f800283a 	ret

8111a5f4 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
8111a5f4:	defffe04 	addi	sp,sp,-8
8111a5f8:	de00012e 	bgeu	sp,et,8111a600 <vFailParserCommTaskCreate+0xc>
8111a5fc:	003b68fa 	trap	3
8111a600:	dfc00115 	stw	ra,4(sp)
8111a604:	df000015 	stw	fp,0(sp)
8111a608:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
8111a60c:	d0a06117 	ldw	r2,-32380(gp)
8111a610:	100f883a 	mov	r7,r2
8111a614:	01800684 	movi	r6,26
8111a618:	01400044 	movi	r5,1
8111a61c:	01204574 	movhi	r4,33045
8111a620:	21346704 	addi	r4,r4,-11876
8111a624:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a628:	0001883a 	nop
8111a62c:	e037883a 	mov	sp,fp
8111a630:	dfc00117 	ldw	ra,4(sp)
8111a634:	df000017 	ldw	fp,0(sp)
8111a638:	dec00204 	addi	sp,sp,8
8111a63c:	f800283a 	ret

8111a640 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
8111a640:	defffe04 	addi	sp,sp,-8
8111a644:	de00012e 	bgeu	sp,et,8111a64c <vFailInAckHandlerTaskCreate+0xc>
8111a648:	003b68fa 	trap	3
8111a64c:	dfc00115 	stw	ra,4(sp)
8111a650:	df000015 	stw	fp,0(sp)
8111a654:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111a658:	d0a06117 	ldw	r2,-32380(gp)
8111a65c:	100f883a 	mov	r7,r2
8111a660:	01800704 	movi	r6,28
8111a664:	01400044 	movi	r5,1
8111a668:	01204574 	movhi	r4,33045
8111a66c:	21346e04 	addi	r4,r4,-11848
8111a670:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a674:	0001883a 	nop
8111a678:	e037883a 	mov	sp,fp
8111a67c:	dfc00117 	ldw	ra,4(sp)
8111a680:	df000017 	ldw	fp,0(sp)
8111a684:	dec00204 	addi	sp,sp,8
8111a688:	f800283a 	ret

8111a68c <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
8111a68c:	defffe04 	addi	sp,sp,-8
8111a690:	de00012e 	bgeu	sp,et,8111a698 <vFailOutAckHandlerTaskCreate+0xc>
8111a694:	003b68fa 	trap	3
8111a698:	dfc00115 	stw	ra,4(sp)
8111a69c:	df000015 	stw	fp,0(sp)
8111a6a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
8111a6a4:	d0a06117 	ldw	r2,-32380(gp)
8111a6a8:	100f883a 	mov	r7,r2
8111a6ac:	01800704 	movi	r6,28
8111a6b0:	01400044 	movi	r5,1
8111a6b4:	01204574 	movhi	r4,33045
8111a6b8:	21346e04 	addi	r4,r4,-11848
8111a6bc:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a6c0:	0001883a 	nop
8111a6c4:	e037883a 	mov	sp,fp
8111a6c8:	dfc00117 	ldw	ra,4(sp)
8111a6cc:	df000017 	ldw	fp,0(sp)
8111a6d0:	dec00204 	addi	sp,sp,8
8111a6d4:	f800283a 	ret

8111a6d8 <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111a6d8:	defffe04 	addi	sp,sp,-8
8111a6dc:	de00012e 	bgeu	sp,et,8111a6e4 <vFailCreateTimerRetransmisison+0xc>
8111a6e0:	003b68fa 	trap	3
8111a6e4:	dfc00115 	stw	ra,4(sp)
8111a6e8:	df000015 	stw	fp,0(sp)
8111a6ec:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
8111a6f0:	d0a06117 	ldw	r2,-32380(gp)
8111a6f4:	100f883a 	mov	r7,r2
8111a6f8:	018007c4 	movi	r6,31
8111a6fc:	01400044 	movi	r5,1
8111a700:	01204574 	movhi	r4,33045
8111a704:	21347604 	addi	r4,r4,-11816
8111a708:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a70c:	0001883a 	nop
8111a710:	e037883a 	mov	sp,fp
8111a714:	dfc00117 	ldw	ra,4(sp)
8111a718:	df000017 	ldw	fp,0(sp)
8111a71c:	dec00204 	addi	sp,sp,8
8111a720:	f800283a 	ret

8111a724 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
8111a724:	defffe04 	addi	sp,sp,-8
8111a728:	de00012e 	bgeu	sp,et,8111a730 <vCouldNotCheckBufferTimeOutFunction+0xc>
8111a72c:	003b68fa 	trap	3
8111a730:	dfc00115 	stw	ra,4(sp)
8111a734:	df000015 	stw	fp,0(sp)
8111a738:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
8111a73c:	d0a06117 	ldw	r2,-32380(gp)
8111a740:	100f883a 	mov	r7,r2
8111a744:	01800904 	movi	r6,36
8111a748:	01400044 	movi	r5,1
8111a74c:	01204574 	movhi	r4,33045
8111a750:	21347e04 	addi	r4,r4,-11784
8111a754:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a758:	0001883a 	nop
8111a75c:	e037883a 	mov	sp,fp
8111a760:	dfc00117 	ldw	ra,4(sp)
8111a764:	df000017 	ldw	fp,0(sp)
8111a768:	dec00204 	addi	sp,sp,8
8111a76c:	f800283a 	ret

8111a770 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
8111a770:	defffe04 	addi	sp,sp,-8
8111a774:	de00012e 	bgeu	sp,et,8111a77c <vFailTimeoutCheckerTaskCreate+0xc>
8111a778:	003b68fa 	trap	3
8111a77c:	dfc00115 	stw	ra,4(sp)
8111a780:	df000015 	stw	fp,0(sp)
8111a784:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111a788:	d0a06117 	ldw	r2,-32380(gp)
8111a78c:	100f883a 	mov	r7,r2
8111a790:	01800a04 	movi	r6,40
8111a794:	01400044 	movi	r5,1
8111a798:	01204574 	movhi	r4,33045
8111a79c:	21348804 	addi	r4,r4,-11744
8111a7a0:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a7a4:	0001883a 	nop
8111a7a8:	e037883a 	mov	sp,fp
8111a7ac:	dfc00117 	ldw	ra,4(sp)
8111a7b0:	df000017 	ldw	fp,0(sp)
8111a7b4:	dec00204 	addi	sp,sp,8
8111a7b8:	f800283a 	ret

8111a7bc <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
8111a7bc:	defffe04 	addi	sp,sp,-8
8111a7c0:	de00012e 	bgeu	sp,et,8111a7c8 <vFailGetBlockingSemTimeoutTask+0xc>
8111a7c4:	003b68fa 	trap	3
8111a7c8:	dfc00115 	stw	ra,4(sp)
8111a7cc:	df000015 	stw	fp,0(sp)
8111a7d0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
8111a7d4:	d0a06117 	ldw	r2,-32380(gp)
8111a7d8:	100f883a 	mov	r7,r2
8111a7dc:	018009c4 	movi	r6,39
8111a7e0:	01400044 	movi	r5,1
8111a7e4:	01204574 	movhi	r4,33045
8111a7e8:	21349304 	addi	r4,r4,-11700
8111a7ec:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
8111a7f0:	d0a06117 	ldw	r2,-32380(gp)
8111a7f4:	100f883a 	mov	r7,r2
8111a7f8:	01800cc4 	movi	r6,51
8111a7fc:	01400044 	movi	r5,1
8111a800:	01204574 	movhi	r4,33045
8111a804:	21349d04 	addi	r4,r4,-11660
8111a808:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a80c:	0001883a 	nop
8111a810:	e037883a 	mov	sp,fp
8111a814:	dfc00117 	ldw	ra,4(sp)
8111a818:	df000017 	ldw	fp,0(sp)
8111a81c:	dec00204 	addi	sp,sp,8
8111a820:	f800283a 	ret

8111a824 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
8111a824:	defffe04 	addi	sp,sp,-8
8111a828:	de00012e 	bgeu	sp,et,8111a830 <vFailPostBlockingSemTimeoutTask+0xc>
8111a82c:	003b68fa 	trap	3
8111a830:	dfc00115 	stw	ra,4(sp)
8111a834:	df000015 	stw	fp,0(sp)
8111a838:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
8111a83c:	d0a06117 	ldw	r2,-32380(gp)
8111a840:	100f883a 	mov	r7,r2
8111a844:	01800a04 	movi	r6,40
8111a848:	01400044 	movi	r5,1
8111a84c:	01204574 	movhi	r4,33045
8111a850:	2134aa04 	addi	r4,r4,-11608
8111a854:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
8111a858:	d0a06117 	ldw	r2,-32380(gp)
8111a85c:	100f883a 	mov	r7,r2
8111a860:	01800c84 	movi	r6,50
8111a864:	01400044 	movi	r5,1
8111a868:	01204574 	movhi	r4,33045
8111a86c:	2134b504 	addi	r4,r4,-11564
8111a870:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a874:	0001883a 	nop
8111a878:	e037883a 	mov	sp,fp
8111a87c:	dfc00117 	ldw	ra,4(sp)
8111a880:	df000017 	ldw	fp,0(sp)
8111a884:	dec00204 	addi	sp,sp,8
8111a888:	f800283a 	ret

8111a88c <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
8111a88c:	defffe04 	addi	sp,sp,-8
8111a890:	de00012e 	bgeu	sp,et,8111a898 <vFailCouldNotRetransmitTimeoutTask+0xc>
8111a894:	003b68fa 	trap	3
8111a898:	dfc00115 	stw	ra,4(sp)
8111a89c:	df000015 	stw	fp,0(sp)
8111a8a0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
8111a8a4:	d0a06117 	ldw	r2,-32380(gp)
8111a8a8:	100f883a 	mov	r7,r2
8111a8ac:	01800ac4 	movi	r6,43
8111a8b0:	01400044 	movi	r5,1
8111a8b4:	01204574 	movhi	r4,33045
8111a8b8:	2134c204 	addi	r4,r4,-11512
8111a8bc:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
8111a8c0:	d0a06117 	ldw	r2,-32380(gp)
8111a8c4:	100f883a 	mov	r7,r2
8111a8c8:	01801644 	movi	r6,89
8111a8cc:	01400044 	movi	r5,1
8111a8d0:	01204574 	movhi	r4,33045
8111a8d4:	2134cd04 	addi	r4,r4,-11468
8111a8d8:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a8dc:	0001883a 	nop
8111a8e0:	e037883a 	mov	sp,fp
8111a8e4:	dfc00117 	ldw	ra,4(sp)
8111a8e8:	df000017 	ldw	fp,0(sp)
8111a8ec:	dec00204 	addi	sp,sp,8
8111a8f0:	f800283a 	ret

8111a8f4 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
8111a8f4:	defffe04 	addi	sp,sp,-8
8111a8f8:	de00012e 	bgeu	sp,et,8111a900 <vCouldNotRetransmitB32TimeoutTask+0xc>
8111a8fc:	003b68fa 	trap	3
8111a900:	dfc00115 	stw	ra,4(sp)
8111a904:	df000015 	stw	fp,0(sp)
8111a908:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
8111a90c:	d0a06117 	ldw	r2,-32380(gp)
8111a910:	100f883a 	mov	r7,r2
8111a914:	01800a84 	movi	r6,42
8111a918:	01400044 	movi	r5,1
8111a91c:	01204574 	movhi	r4,33045
8111a920:	2134e404 	addi	r4,r4,-11376
8111a924:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
8111a928:	d0a06117 	ldw	r2,-32380(gp)
8111a92c:	100f883a 	mov	r7,r2
8111a930:	01801444 	movi	r6,81
8111a934:	01400044 	movi	r5,1
8111a938:	01204574 	movhi	r4,33045
8111a93c:	2134ef04 	addi	r4,r4,-11332
8111a940:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a944:	0001883a 	nop
8111a948:	e037883a 	mov	sp,fp
8111a94c:	dfc00117 	ldw	ra,4(sp)
8111a950:	df000017 	ldw	fp,0(sp)
8111a954:	dec00204 	addi	sp,sp,8
8111a958:	f800283a 	ret

8111a95c <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
8111a95c:	defffe04 	addi	sp,sp,-8
8111a960:	de00012e 	bgeu	sp,et,8111a968 <vCouldNotRetransmitB64TimeoutTask+0xc>
8111a964:	003b68fa 	trap	3
8111a968:	dfc00115 	stw	ra,4(sp)
8111a96c:	df000015 	stw	fp,0(sp)
8111a970:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
8111a974:	d0a06117 	ldw	r2,-32380(gp)
8111a978:	100f883a 	mov	r7,r2
8111a97c:	01800a84 	movi	r6,42
8111a980:	01400044 	movi	r5,1
8111a984:	01204574 	movhi	r4,33045
8111a988:	21350404 	addi	r4,r4,-11248
8111a98c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
8111a990:	d0a06117 	ldw	r2,-32380(gp)
8111a994:	100f883a 	mov	r7,r2
8111a998:	01801444 	movi	r6,81
8111a99c:	01400044 	movi	r5,1
8111a9a0:	01204574 	movhi	r4,33045
8111a9a4:	21350f04 	addi	r4,r4,-11204
8111a9a8:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111a9ac:	0001883a 	nop
8111a9b0:	e037883a 	mov	sp,fp
8111a9b4:	dfc00117 	ldw	ra,4(sp)
8111a9b8:	df000017 	ldw	fp,0(sp)
8111a9bc:	dec00204 	addi	sp,sp,8
8111a9c0:	f800283a 	ret

8111a9c4 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
8111a9c4:	defffe04 	addi	sp,sp,-8
8111a9c8:	de00012e 	bgeu	sp,et,8111a9d0 <vCouldNotRetransmitB128TimeoutTask+0xc>
8111a9cc:	003b68fa 	trap	3
8111a9d0:	dfc00115 	stw	ra,4(sp)
8111a9d4:	df000015 	stw	fp,0(sp)
8111a9d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
8111a9dc:	d0a06117 	ldw	r2,-32380(gp)
8111a9e0:	100f883a 	mov	r7,r2
8111a9e4:	01800ac4 	movi	r6,43
8111a9e8:	01400044 	movi	r5,1
8111a9ec:	01204574 	movhi	r4,33045
8111a9f0:	21352404 	addi	r4,r4,-11120
8111a9f4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
8111a9f8:	d0a06117 	ldw	r2,-32380(gp)
8111a9fc:	100f883a 	mov	r7,r2
8111aa00:	01801484 	movi	r6,82
8111aa04:	01400044 	movi	r5,1
8111aa08:	01204574 	movhi	r4,33045
8111aa0c:	21352f04 	addi	r4,r4,-11076
8111aa10:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aa14:	0001883a 	nop
8111aa18:	e037883a 	mov	sp,fp
8111aa1c:	dfc00117 	ldw	ra,4(sp)
8111aa20:	df000017 	ldw	fp,0(sp)
8111aa24:	dec00204 	addi	sp,sp,8
8111aa28:	f800283a 	ret

8111aa2c <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
8111aa2c:	defffe04 	addi	sp,sp,-8
8111aa30:	de00012e 	bgeu	sp,et,8111aa38 <vFailStartTimerRetransmission+0xc>
8111aa34:	003b68fa 	trap	3
8111aa38:	dfc00115 	stw	ra,4(sp)
8111aa3c:	df000015 	stw	fp,0(sp)
8111aa40:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
8111aa44:	d0a06117 	ldw	r2,-32380(gp)
8111aa48:	100f883a 	mov	r7,r2
8111aa4c:	01800984 	movi	r6,38
8111aa50:	01400044 	movi	r5,1
8111aa54:	01204574 	movhi	r4,33045
8111aa58:	21354404 	addi	r4,r4,-10992
8111aa5c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
8111aa60:	d0a06117 	ldw	r2,-32380(gp)
8111aa64:	100f883a 	mov	r7,r2
8111aa68:	01800d44 	movi	r6,53
8111aa6c:	01400044 	movi	r5,1
8111aa70:	01204574 	movhi	r4,33045
8111aa74:	21354e04 	addi	r4,r4,-10952
8111aa78:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aa7c:	0001883a 	nop
8111aa80:	e037883a 	mov	sp,fp
8111aa84:	dfc00117 	ldw	ra,4(sp)
8111aa88:	df000017 	ldw	fp,0(sp)
8111aa8c:	dec00204 	addi	sp,sp,8
8111aa90:	f800283a 	ret

8111aa94 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
8111aa94:	defffe04 	addi	sp,sp,-8
8111aa98:	de00012e 	bgeu	sp,et,8111aaa0 <vCouldNotSendTurnOff+0xc>
8111aa9c:	003b68fa 	trap	3
8111aaa0:	dfc00115 	stw	ra,4(sp)
8111aaa4:	df000015 	stw	fp,0(sp)
8111aaa8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
8111aaac:	d0a06117 	ldw	r2,-32380(gp)
8111aab0:	100f883a 	mov	r7,r2
8111aab4:	01800744 	movi	r6,29
8111aab8:	01400044 	movi	r5,1
8111aabc:	01204574 	movhi	r4,33045
8111aac0:	21355c04 	addi	r4,r4,-10896
8111aac4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
8111aac8:	d0a06117 	ldw	r2,-32380(gp)
8111aacc:	100f883a 	mov	r7,r2
8111aad0:	01800984 	movi	r6,38
8111aad4:	01400044 	movi	r5,1
8111aad8:	01204574 	movhi	r4,33045
8111aadc:	21356404 	addi	r4,r4,-10864
8111aae0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aae4:	0001883a 	nop
8111aae8:	e037883a 	mov	sp,fp
8111aaec:	dfc00117 	ldw	ra,4(sp)
8111aaf0:	df000017 	ldw	fp,0(sp)
8111aaf4:	dec00204 	addi	sp,sp,8
8111aaf8:	f800283a 	ret

8111aafc <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
8111aafc:	defffe04 	addi	sp,sp,-8
8111ab00:	de00012e 	bgeu	sp,et,8111ab08 <vCouldNotSendReset+0xc>
8111ab04:	003b68fa 	trap	3
8111ab08:	dfc00115 	stw	ra,4(sp)
8111ab0c:	df000015 	stw	fp,0(sp)
8111ab10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
8111ab14:	d0a06117 	ldw	r2,-32380(gp)
8111ab18:	100f883a 	mov	r7,r2
8111ab1c:	018006c4 	movi	r6,27
8111ab20:	01400044 	movi	r5,1
8111ab24:	01204574 	movhi	r4,33045
8111ab28:	21356e04 	addi	r4,r4,-10824
8111ab2c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
8111ab30:	d0a06117 	ldw	r2,-32380(gp)
8111ab34:	100f883a 	mov	r7,r2
8111ab38:	018008c4 	movi	r6,35
8111ab3c:	01400044 	movi	r5,1
8111ab40:	01204574 	movhi	r4,33045
8111ab44:	21357504 	addi	r4,r4,-10796
8111ab48:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ab4c:	0001883a 	nop
8111ab50:	e037883a 	mov	sp,fp
8111ab54:	dfc00117 	ldw	ra,4(sp)
8111ab58:	df000017 	ldw	fp,0(sp)
8111ab5c:	dec00204 	addi	sp,sp,8
8111ab60:	f800283a 	ret

8111ab64 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
8111ab64:	defffe04 	addi	sp,sp,-8
8111ab68:	de00012e 	bgeu	sp,et,8111ab70 <vCouldNotSendLog+0xc>
8111ab6c:	003b68fa 	trap	3
8111ab70:	dfc00115 	stw	ra,4(sp)
8111ab74:	df000015 	stw	fp,0(sp)
8111ab78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
8111ab7c:	d0a06117 	ldw	r2,-32380(gp)
8111ab80:	100f883a 	mov	r7,r2
8111ab84:	01800644 	movi	r6,25
8111ab88:	01400044 	movi	r5,1
8111ab8c:	01204574 	movhi	r4,33045
8111ab90:	21357e04 	addi	r4,r4,-10760
8111ab94:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
8111ab98:	d0a06117 	ldw	r2,-32380(gp)
8111ab9c:	100f883a 	mov	r7,r2
8111aba0:	018008c4 	movi	r6,35
8111aba4:	01400044 	movi	r5,1
8111aba8:	01204574 	movhi	r4,33045
8111abac:	21358504 	addi	r4,r4,-10732
8111abb0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111abb4:	0001883a 	nop
8111abb8:	e037883a 	mov	sp,fp
8111abbc:	dfc00117 	ldw	ra,4(sp)
8111abc0:	df000017 	ldw	fp,0(sp)
8111abc4:	dec00204 	addi	sp,sp,8
8111abc8:	f800283a 	ret

8111abcc <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
8111abcc:	defffd04 	addi	sp,sp,-12
8111abd0:	de00012e 	bgeu	sp,et,8111abd8 <vCouldNotSendTMPusCommand+0xc>
8111abd4:	003b68fa 	trap	3
8111abd8:	dfc00215 	stw	ra,8(sp)
8111abdc:	df000115 	stw	fp,4(sp)
8111abe0:	df000104 	addi	fp,sp,4
8111abe4:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
8111abe8:	d0a06117 	ldw	r2,-32380(gp)
8111abec:	100f883a 	mov	r7,r2
8111abf0:	01800884 	movi	r6,34
8111abf4:	01400044 	movi	r5,1
8111abf8:	01204574 	movhi	r4,33045
8111abfc:	21358e04 	addi	r4,r4,-10696
8111ac00:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
8111ac04:	d0a06117 	ldw	r2,-32380(gp)
8111ac08:	100f883a 	mov	r7,r2
8111ac0c:	01800ac4 	movi	r6,43
8111ac10:	01400044 	movi	r5,1
8111ac14:	01204574 	movhi	r4,33045
8111ac18:	21359704 	addi	r4,r4,-10660
8111ac1c:	111fc980 	call	8111fc98 <fwrite>
		debug(fp,"cData");
8111ac20:	d0a06117 	ldw	r2,-32380(gp)
8111ac24:	100f883a 	mov	r7,r2
8111ac28:	01800144 	movi	r6,5
8111ac2c:	01400044 	movi	r5,1
8111ac30:	01204574 	movhi	r4,33045
8111ac34:	2135a204 	addi	r4,r4,-10616
8111ac38:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ac3c:	0001883a 	nop
8111ac40:	e037883a 	mov	sp,fp
8111ac44:	dfc00117 	ldw	ra,4(sp)
8111ac48:	df000017 	ldw	fp,0(sp)
8111ac4c:	dec00204 	addi	sp,sp,8
8111ac50:	f800283a 	ret

8111ac54 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
8111ac54:	defffe04 	addi	sp,sp,-8
8111ac58:	de00012e 	bgeu	sp,et,8111ac60 <vWarnCouldNotgetMutexRetrans128+0xc>
8111ac5c:	003b68fa 	trap	3
8111ac60:	dfc00115 	stw	ra,4(sp)
8111ac64:	df000015 	stw	fp,0(sp)
8111ac68:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
8111ac6c:	d0a06117 	ldw	r2,-32380(gp)
8111ac70:	100f883a 	mov	r7,r2
8111ac74:	01800a04 	movi	r6,40
8111ac78:	01400044 	movi	r5,1
8111ac7c:	01204574 	movhi	r4,33045
8111ac80:	2135a404 	addi	r4,r4,-10608
8111ac84:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
8111ac88:	d0a06117 	ldw	r2,-32380(gp)
8111ac8c:	100f883a 	mov	r7,r2
8111ac90:	018014c4 	movi	r6,83
8111ac94:	01400044 	movi	r5,1
8111ac98:	01204574 	movhi	r4,33045
8111ac9c:	2135af04 	addi	r4,r4,-10564
8111aca0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aca4:	0001883a 	nop
8111aca8:	e037883a 	mov	sp,fp
8111acac:	dfc00117 	ldw	ra,4(sp)
8111acb0:	df000017 	ldw	fp,0(sp)
8111acb4:	dec00204 	addi	sp,sp,8
8111acb8:	f800283a 	ret

8111acbc <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
8111acbc:	defffe04 	addi	sp,sp,-8
8111acc0:	de00012e 	bgeu	sp,et,8111acc8 <vFailCreateScheduleQueue+0xc>
8111acc4:	003b68fa 	trap	3
8111acc8:	dfc00115 	stw	ra,4(sp)
8111accc:	df000015 	stw	fp,0(sp)
8111acd0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
8111acd4:	d0a06117 	ldw	r2,-32380(gp)
8111acd8:	100f883a 	mov	r7,r2
8111acdc:	01800844 	movi	r6,33
8111ace0:	01400044 	movi	r5,1
8111ace4:	01204574 	movhi	r4,33045
8111ace8:	2135c404 	addi	r4,r4,-10480
8111acec:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
8111acf0:	d0a06117 	ldw	r2,-32380(gp)
8111acf4:	100f883a 	mov	r7,r2
8111acf8:	01801204 	movi	r6,72
8111acfc:	01400044 	movi	r5,1
8111ad00:	01204574 	movhi	r4,33045
8111ad04:	2135cd04 	addi	r4,r4,-10444
8111ad08:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ad0c:	0001883a 	nop
8111ad10:	e037883a 	mov	sp,fp
8111ad14:	dfc00117 	ldw	ra,4(sp)
8111ad18:	df000017 	ldw	fp,0(sp)
8111ad1c:	dec00204 	addi	sp,sp,8
8111ad20:	f800283a 	ret

8111ad24 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
8111ad24:	defffd04 	addi	sp,sp,-12
8111ad28:	de00012e 	bgeu	sp,et,8111ad30 <vFailCreateNFEEQueue+0xc>
8111ad2c:	003b68fa 	trap	3
8111ad30:	dfc00215 	stw	ra,8(sp)
8111ad34:	df000115 	stw	fp,4(sp)
8111ad38:	df000104 	addi	fp,sp,4
8111ad3c:	2005883a 	mov	r2,r4
8111ad40:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
8111ad44:	d0a06117 	ldw	r2,-32380(gp)
8111ad48:	100f883a 	mov	r7,r2
8111ad4c:	01800744 	movi	r6,29
8111ad50:	01400044 	movi	r5,1
8111ad54:	01204574 	movhi	r4,33045
8111ad58:	2135e004 	addi	r4,r4,-10368
8111ad5c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
8111ad60:	d0a06117 	ldw	r2,-32380(gp)
8111ad64:	e0ffff03 	ldbu	r3,-4(fp)
8111ad68:	180d883a 	mov	r6,r3
8111ad6c:	01604574 	movhi	r5,33045
8111ad70:	2975e804 	addi	r5,r5,-10336
8111ad74:	1009883a 	mov	r4,r2
8111ad78:	11209c40 	call	811209c4 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ad7c:	0001883a 	nop
8111ad80:	e037883a 	mov	sp,fp
8111ad84:	dfc00117 	ldw	ra,4(sp)
8111ad88:	df000017 	ldw	fp,0(sp)
8111ad8c:	dec00204 	addi	sp,sp,8
8111ad90:	f800283a 	ret

8111ad94 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
8111ad94:	defffd04 	addi	sp,sp,-12
8111ad98:	de00012e 	bgeu	sp,et,8111ada0 <vFailCreateNFEESyncQueue+0xc>
8111ad9c:	003b68fa 	trap	3
8111ada0:	dfc00215 	stw	ra,8(sp)
8111ada4:	df000115 	stw	fp,4(sp)
8111ada8:	df000104 	addi	fp,sp,4
8111adac:	2005883a 	mov	r2,r4
8111adb0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
8111adb4:	d0a06117 	ldw	r2,-32380(gp)
8111adb8:	100f883a 	mov	r7,r2
8111adbc:	01800844 	movi	r6,33
8111adc0:	01400044 	movi	r5,1
8111adc4:	01204574 	movhi	r4,33045
8111adc8:	2135f604 	addi	r4,r4,-10280
8111adcc:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
8111add0:	d0a06117 	ldw	r2,-32380(gp)
8111add4:	e0ffff03 	ldbu	r3,-4(fp)
8111add8:	180d883a 	mov	r6,r3
8111addc:	01604574 	movhi	r5,33045
8111ade0:	2975ff04 	addi	r5,r5,-10244
8111ade4:	1009883a 	mov	r4,r2
8111ade8:	11209c40 	call	811209c4 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111adec:	0001883a 	nop
8111adf0:	e037883a 	mov	sp,fp
8111adf4:	dfc00117 	ldw	ra,4(sp)
8111adf8:	df000017 	ldw	fp,0(sp)
8111adfc:	dec00204 	addi	sp,sp,8
8111ae00:	f800283a 	ret

8111ae04 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
8111ae04:	defffe04 	addi	sp,sp,-8
8111ae08:	de00012e 	bgeu	sp,et,8111ae10 <vCoudlNotCreateNFee0Task+0xc>
8111ae0c:	003b68fa 	trap	3
8111ae10:	dfc00115 	stw	ra,4(sp)
8111ae14:	df000015 	stw	fp,0(sp)
8111ae18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
8111ae1c:	d0a06117 	ldw	r2,-32380(gp)
8111ae20:	100f883a 	mov	r7,r2
8111ae24:	01800844 	movi	r6,33
8111ae28:	01400044 	movi	r5,1
8111ae2c:	01204574 	movhi	r4,33045
8111ae30:	21360d04 	addi	r4,r4,-10188
8111ae34:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
8111ae38:	d0a06117 	ldw	r2,-32380(gp)
8111ae3c:	100f883a 	mov	r7,r2
8111ae40:	01800784 	movi	r6,30
8111ae44:	01400044 	movi	r5,1
8111ae48:	01204574 	movhi	r4,33045
8111ae4c:	21361604 	addi	r4,r4,-10152
8111ae50:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111ae54:	0001883a 	nop
8111ae58:	e037883a 	mov	sp,fp
8111ae5c:	dfc00117 	ldw	ra,4(sp)
8111ae60:	df000017 	ldw	fp,0(sp)
8111ae64:	dec00204 	addi	sp,sp,8
8111ae68:	f800283a 	ret

8111ae6c <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
8111ae6c:	defffe04 	addi	sp,sp,-8
8111ae70:	de00012e 	bgeu	sp,et,8111ae78 <vCoudlNotCreateNFee1Task+0xc>
8111ae74:	003b68fa 	trap	3
8111ae78:	dfc00115 	stw	ra,4(sp)
8111ae7c:	df000015 	stw	fp,0(sp)
8111ae80:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
8111ae84:	d0a06117 	ldw	r2,-32380(gp)
8111ae88:	100f883a 	mov	r7,r2
8111ae8c:	01800844 	movi	r6,33
8111ae90:	01400044 	movi	r5,1
8111ae94:	01204574 	movhi	r4,33045
8111ae98:	21361e04 	addi	r4,r4,-10120
8111ae9c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
8111aea0:	d0a06117 	ldw	r2,-32380(gp)
8111aea4:	100f883a 	mov	r7,r2
8111aea8:	01800784 	movi	r6,30
8111aeac:	01400044 	movi	r5,1
8111aeb0:	01204574 	movhi	r4,33045
8111aeb4:	21362704 	addi	r4,r4,-10084
8111aeb8:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aebc:	0001883a 	nop
8111aec0:	e037883a 	mov	sp,fp
8111aec4:	dfc00117 	ldw	ra,4(sp)
8111aec8:	df000017 	ldw	fp,0(sp)
8111aecc:	dec00204 	addi	sp,sp,8
8111aed0:	f800283a 	ret

8111aed4 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
8111aed4:	defffe04 	addi	sp,sp,-8
8111aed8:	de00012e 	bgeu	sp,et,8111aee0 <vCoudlNotCreateNFee2Task+0xc>
8111aedc:	003b68fa 	trap	3
8111aee0:	dfc00115 	stw	ra,4(sp)
8111aee4:	df000015 	stw	fp,0(sp)
8111aee8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
8111aeec:	d0a06117 	ldw	r2,-32380(gp)
8111aef0:	100f883a 	mov	r7,r2
8111aef4:	01800844 	movi	r6,33
8111aef8:	01400044 	movi	r5,1
8111aefc:	01204574 	movhi	r4,33045
8111af00:	21362f04 	addi	r4,r4,-10052
8111af04:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
8111af08:	d0a06117 	ldw	r2,-32380(gp)
8111af0c:	100f883a 	mov	r7,r2
8111af10:	01800784 	movi	r6,30
8111af14:	01400044 	movi	r5,1
8111af18:	01204574 	movhi	r4,33045
8111af1c:	21363804 	addi	r4,r4,-10016
8111af20:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111af24:	0001883a 	nop
8111af28:	e037883a 	mov	sp,fp
8111af2c:	dfc00117 	ldw	ra,4(sp)
8111af30:	df000017 	ldw	fp,0(sp)
8111af34:	dec00204 	addi	sp,sp,8
8111af38:	f800283a 	ret

8111af3c <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
8111af3c:	defffe04 	addi	sp,sp,-8
8111af40:	de00012e 	bgeu	sp,et,8111af48 <vCoudlNotCreateNFee3Task+0xc>
8111af44:	003b68fa 	trap	3
8111af48:	dfc00115 	stw	ra,4(sp)
8111af4c:	df000015 	stw	fp,0(sp)
8111af50:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
8111af54:	d0a06117 	ldw	r2,-32380(gp)
8111af58:	100f883a 	mov	r7,r2
8111af5c:	01800844 	movi	r6,33
8111af60:	01400044 	movi	r5,1
8111af64:	01204574 	movhi	r4,33045
8111af68:	21364004 	addi	r4,r4,-9984
8111af6c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
8111af70:	d0a06117 	ldw	r2,-32380(gp)
8111af74:	100f883a 	mov	r7,r2
8111af78:	01800784 	movi	r6,30
8111af7c:	01400044 	movi	r5,1
8111af80:	01204574 	movhi	r4,33045
8111af84:	21364904 	addi	r4,r4,-9948
8111af88:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111af8c:	0001883a 	nop
8111af90:	e037883a 	mov	sp,fp
8111af94:	dfc00117 	ldw	ra,4(sp)
8111af98:	df000017 	ldw	fp,0(sp)
8111af9c:	dec00204 	addi	sp,sp,8
8111afa0:	f800283a 	ret

8111afa4 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
8111afa4:	defffe04 	addi	sp,sp,-8
8111afa8:	de00012e 	bgeu	sp,et,8111afb0 <vCoudlNotCreateNFee4Task+0xc>
8111afac:	003b68fa 	trap	3
8111afb0:	dfc00115 	stw	ra,4(sp)
8111afb4:	df000015 	stw	fp,0(sp)
8111afb8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
8111afbc:	d0a06117 	ldw	r2,-32380(gp)
8111afc0:	100f883a 	mov	r7,r2
8111afc4:	01800844 	movi	r6,33
8111afc8:	01400044 	movi	r5,1
8111afcc:	01204574 	movhi	r4,33045
8111afd0:	21365104 	addi	r4,r4,-9916
8111afd4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
8111afd8:	d0a06117 	ldw	r2,-32380(gp)
8111afdc:	100f883a 	mov	r7,r2
8111afe0:	01800784 	movi	r6,30
8111afe4:	01400044 	movi	r5,1
8111afe8:	01204574 	movhi	r4,33045
8111afec:	21365a04 	addi	r4,r4,-9880
8111aff0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111aff4:	0001883a 	nop
8111aff8:	e037883a 	mov	sp,fp
8111affc:	dfc00117 	ldw	ra,4(sp)
8111b000:	df000017 	ldw	fp,0(sp)
8111b004:	dec00204 	addi	sp,sp,8
8111b008:	f800283a 	ret

8111b00c <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
8111b00c:	defffe04 	addi	sp,sp,-8
8111b010:	de00012e 	bgeu	sp,et,8111b018 <vCoudlNotCreateNFee5Task+0xc>
8111b014:	003b68fa 	trap	3
8111b018:	dfc00115 	stw	ra,4(sp)
8111b01c:	df000015 	stw	fp,0(sp)
8111b020:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
8111b024:	d0a06117 	ldw	r2,-32380(gp)
8111b028:	100f883a 	mov	r7,r2
8111b02c:	01800844 	movi	r6,33
8111b030:	01400044 	movi	r5,1
8111b034:	01204574 	movhi	r4,33045
8111b038:	21366204 	addi	r4,r4,-9848
8111b03c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
8111b040:	d0a06117 	ldw	r2,-32380(gp)
8111b044:	100f883a 	mov	r7,r2
8111b048:	01800784 	movi	r6,30
8111b04c:	01400044 	movi	r5,1
8111b050:	01204574 	movhi	r4,33045
8111b054:	21366b04 	addi	r4,r4,-9812
8111b058:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b05c:	0001883a 	nop
8111b060:	e037883a 	mov	sp,fp
8111b064:	dfc00117 	ldw	ra,4(sp)
8111b068:	df000017 	ldw	fp,0(sp)
8111b06c:	dec00204 	addi	sp,sp,8
8111b070:	f800283a 	ret

8111b074 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
8111b074:	defffe04 	addi	sp,sp,-8
8111b078:	de00012e 	bgeu	sp,et,8111b080 <vCoudlNotCreateNFeeControllerTask+0xc>
8111b07c:	003b68fa 	trap	3
8111b080:	dfc00115 	stw	ra,4(sp)
8111b084:	df000015 	stw	fp,0(sp)
8111b088:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
8111b08c:	d0a06117 	ldw	r2,-32380(gp)
8111b090:	100f883a 	mov	r7,r2
8111b094:	01800a84 	movi	r6,42
8111b098:	01400044 	movi	r5,1
8111b09c:	01204574 	movhi	r4,33045
8111b0a0:	21367304 	addi	r4,r4,-9780
8111b0a4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111b0a8:	d0a06117 	ldw	r2,-32380(gp)
8111b0ac:	100f883a 	mov	r7,r2
8111b0b0:	018009c4 	movi	r6,39
8111b0b4:	01400044 	movi	r5,1
8111b0b8:	01204574 	movhi	r4,33045
8111b0bc:	21367e04 	addi	r4,r4,-9736
8111b0c0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b0c4:	0001883a 	nop
8111b0c8:	e037883a 	mov	sp,fp
8111b0cc:	dfc00117 	ldw	ra,4(sp)
8111b0d0:	df000017 	ldw	fp,0(sp)
8111b0d4:	dec00204 	addi	sp,sp,8
8111b0d8:	f800283a 	ret

8111b0dc <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
8111b0dc:	defffe04 	addi	sp,sp,-8
8111b0e0:	de00012e 	bgeu	sp,et,8111b0e8 <vCoudlNotCreateDataControllerTask+0xc>
8111b0e4:	003b68fa 	trap	3
8111b0e8:	dfc00115 	stw	ra,4(sp)
8111b0ec:	df000015 	stw	fp,0(sp)
8111b0f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
8111b0f4:	d0a06117 	ldw	r2,-32380(gp)
8111b0f8:	100f883a 	mov	r7,r2
8111b0fc:	01800a84 	movi	r6,42
8111b100:	01400044 	movi	r5,1
8111b104:	01204574 	movhi	r4,33045
8111b108:	21368804 	addi	r4,r4,-9696
8111b10c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
8111b110:	d0a06117 	ldw	r2,-32380(gp)
8111b114:	100f883a 	mov	r7,r2
8111b118:	018009c4 	movi	r6,39
8111b11c:	01400044 	movi	r5,1
8111b120:	01204574 	movhi	r4,33045
8111b124:	21369304 	addi	r4,r4,-9652
8111b128:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b12c:	0001883a 	nop
8111b130:	e037883a 	mov	sp,fp
8111b134:	dfc00117 	ldw	ra,4(sp)
8111b138:	df000017 	ldw	fp,0(sp)
8111b13c:	dec00204 	addi	sp,sp,8
8111b140:	f800283a 	ret

8111b144 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
8111b144:	defffe04 	addi	sp,sp,-8
8111b148:	de00012e 	bgeu	sp,et,8111b150 <vCoudlNotCreateMebTask+0xc>
8111b14c:	003b68fa 	trap	3
8111b150:	dfc00115 	stw	ra,4(sp)
8111b154:	df000015 	stw	fp,0(sp)
8111b158:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
8111b15c:	d0a06117 	ldw	r2,-32380(gp)
8111b160:	100f883a 	mov	r7,r2
8111b164:	018007c4 	movi	r6,31
8111b168:	01400044 	movi	r5,1
8111b16c:	01204574 	movhi	r4,33045
8111b170:	21369d04 	addi	r4,r4,-9612
8111b174:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111b178:	d0a06117 	ldw	r2,-32380(gp)
8111b17c:	100f883a 	mov	r7,r2
8111b180:	018006c4 	movi	r6,27
8111b184:	01400044 	movi	r5,1
8111b188:	01204574 	movhi	r4,33045
8111b18c:	2136a504 	addi	r4,r4,-9580
8111b190:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b194:	0001883a 	nop
8111b198:	e037883a 	mov	sp,fp
8111b19c:	dfc00117 	ldw	ra,4(sp)
8111b1a0:	df000017 	ldw	fp,0(sp)
8111b1a4:	dec00204 	addi	sp,sp,8
8111b1a8:	f800283a 	ret

8111b1ac <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
8111b1ac:	defffd04 	addi	sp,sp,-12
8111b1b0:	de00012e 	bgeu	sp,et,8111b1b8 <vFailCreateMutexSPUSQueueMeb+0xc>
8111b1b4:	003b68fa 	trap	3
8111b1b8:	dfc00215 	stw	ra,8(sp)
8111b1bc:	df000115 	stw	fp,4(sp)
8111b1c0:	df000104 	addi	fp,sp,4
8111b1c4:	2005883a 	mov	r2,r4
8111b1c8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
8111b1cc:	d0a06117 	ldw	r2,-32380(gp)
8111b1d0:	100f883a 	mov	r7,r2
8111b1d4:	01800944 	movi	r6,37
8111b1d8:	01400044 	movi	r5,1
8111b1dc:	01204574 	movhi	r4,33045
8111b1e0:	2136ac04 	addi	r4,r4,-9552
8111b1e4:	111fc980 	call	8111fc98 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111b1e8:	e0bfff03 	ldbu	r2,-4(fp)
8111b1ec:	1009883a 	mov	r4,r2
8111b1f0:	11199580 	call	81119958 <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b1f4:	0001883a 	nop
8111b1f8:	e037883a 	mov	sp,fp
8111b1fc:	dfc00117 	ldw	ra,4(sp)
8111b200:	df000017 	ldw	fp,0(sp)
8111b204:	dec00204 	addi	sp,sp,8
8111b208:	f800283a 	ret

8111b20c <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
8111b20c:	defffe04 	addi	sp,sp,-8
8111b210:	de00012e 	bgeu	sp,et,8111b218 <vFailSendPUStoMebTask+0xc>
8111b214:	003b68fa 	trap	3
8111b218:	dfc00115 	stw	ra,4(sp)
8111b21c:	df000015 	stw	fp,0(sp)
8111b220:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
8111b224:	d0a06117 	ldw	r2,-32380(gp)
8111b228:	100f883a 	mov	r7,r2
8111b22c:	01800784 	movi	r6,30
8111b230:	01400044 	movi	r5,1
8111b234:	01204574 	movhi	r4,33045
8111b238:	2136b604 	addi	r4,r4,-9512
8111b23c:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b240:	0001883a 	nop
8111b244:	e037883a 	mov	sp,fp
8111b248:	dfc00117 	ldw	ra,4(sp)
8111b24c:	df000017 	ldw	fp,0(sp)
8111b250:	dec00204 	addi	sp,sp,8
8111b254:	f800283a 	ret

8111b258 <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
8111b258:	defffe04 	addi	sp,sp,-8
8111b25c:	de00012e 	bgeu	sp,et,8111b264 <vCouldNotGetCmdQueueMeb+0xc>
8111b260:	003b68fa 	trap	3
8111b264:	dfc00115 	stw	ra,4(sp)
8111b268:	df000015 	stw	fp,0(sp)
8111b26c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
8111b270:	d0a06117 	ldw	r2,-32380(gp)
8111b274:	100f883a 	mov	r7,r2
8111b278:	01800a84 	movi	r6,42
8111b27c:	01400044 	movi	r5,1
8111b280:	01204574 	movhi	r4,33045
8111b284:	2136be04 	addi	r4,r4,-9480
8111b288:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
8111b28c:	d0a06117 	ldw	r2,-32380(gp)
8111b290:	100f883a 	mov	r7,r2
8111b294:	01800cc4 	movi	r6,51
8111b298:	01400044 	movi	r5,1
8111b29c:	01204574 	movhi	r4,33045
8111b2a0:	2136c904 	addi	r4,r4,-9436
8111b2a4:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b2a8:	0001883a 	nop
8111b2ac:	e037883a 	mov	sp,fp
8111b2b0:	dfc00117 	ldw	ra,4(sp)
8111b2b4:	df000017 	ldw	fp,0(sp)
8111b2b8:	dec00204 	addi	sp,sp,8
8111b2bc:	f800283a 	ret

8111b2c0 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
8111b2c0:	defffe04 	addi	sp,sp,-8
8111b2c4:	de00012e 	bgeu	sp,et,8111b2cc <vCouldNotGetMutexMebPus+0xc>
8111b2c8:	003b68fa 	trap	3
8111b2cc:	dfc00115 	stw	ra,4(sp)
8111b2d0:	df000015 	stw	fp,0(sp)
8111b2d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111b2d8:	d0a06117 	ldw	r2,-32380(gp)
8111b2dc:	100f883a 	mov	r7,r2
8111b2e0:	01800804 	movi	r6,32
8111b2e4:	01400044 	movi	r5,1
8111b2e8:	01204574 	movhi	r4,33045
8111b2ec:	2136d604 	addi	r4,r4,-9384
8111b2f0:	111fc980 	call	8111fc98 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b2f4:	0001883a 	nop
8111b2f8:	e037883a 	mov	sp,fp
8111b2fc:	dfc00117 	ldw	ra,4(sp)
8111b300:	df000017 	ldw	fp,0(sp)
8111b304:	dec00204 	addi	sp,sp,8
8111b308:	f800283a 	ret

8111b30c <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
8111b30c:	defffe04 	addi	sp,sp,-8
8111b310:	de00012e 	bgeu	sp,et,8111b318 <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
8111b314:	003b68fa 	trap	3
8111b318:	dfc00115 	stw	ra,4(sp)
8111b31c:	df000015 	stw	fp,0(sp)
8111b320:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
8111b324:	d0a06117 	ldw	r2,-32380(gp)
8111b328:	100f883a 	mov	r7,r2
8111b32c:	01800a44 	movi	r6,41
8111b330:	01400044 	movi	r5,1
8111b334:	01204574 	movhi	r4,33045
8111b338:	2136df04 	addi	r4,r4,-9348
8111b33c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
8111b340:	d0a06117 	ldw	r2,-32380(gp)
8111b344:	100f883a 	mov	r7,r2
8111b348:	01800c84 	movi	r6,50
8111b34c:	01400044 	movi	r5,1
8111b350:	01204574 	movhi	r4,33045
8111b354:	2136ea04 	addi	r4,r4,-9304
8111b358:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b35c:	0001883a 	nop
8111b360:	e037883a 	mov	sp,fp
8111b364:	dfc00117 	ldw	ra,4(sp)
8111b368:	df000017 	ldw	fp,0(sp)
8111b36c:	dec00204 	addi	sp,sp,8
8111b370:	f800283a 	ret

8111b374 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
8111b374:	defffe04 	addi	sp,sp,-8
8111b378:	de00012e 	bgeu	sp,et,8111b380 <vCouldNotCreateQueueMaskDataCtrl+0xc>
8111b37c:	003b68fa 	trap	3
8111b380:	dfc00115 	stw	ra,4(sp)
8111b384:	df000015 	stw	fp,0(sp)
8111b388:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
8111b38c:	d0a06117 	ldw	r2,-32380(gp)
8111b390:	100f883a 	mov	r7,r2
8111b394:	01800a44 	movi	r6,41
8111b398:	01400044 	movi	r5,1
8111b39c:	01204574 	movhi	r4,33045
8111b3a0:	2136f704 	addi	r4,r4,-9252
8111b3a4:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111b3a8:	d0a06117 	ldw	r2,-32380(gp)
8111b3ac:	100f883a 	mov	r7,r2
8111b3b0:	01800c84 	movi	r6,50
8111b3b4:	01400044 	movi	r5,1
8111b3b8:	01204574 	movhi	r4,33045
8111b3bc:	21370204 	addi	r4,r4,-9208
8111b3c0:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b3c4:	0001883a 	nop
8111b3c8:	e037883a 	mov	sp,fp
8111b3cc:	dfc00117 	ldw	ra,4(sp)
8111b3d0:	df000017 	ldw	fp,0(sp)
8111b3d4:	dec00204 	addi	sp,sp,8
8111b3d8:	f800283a 	ret

8111b3dc <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
8111b3dc:	defffe04 	addi	sp,sp,-8
8111b3e0:	de00012e 	bgeu	sp,et,8111b3e8 <vCouldNotGetQueueMaskNfeeCtrl+0xc>
8111b3e4:	003b68fa 	trap	3
8111b3e8:	dfc00115 	stw	ra,4(sp)
8111b3ec:	df000015 	stw	fp,0(sp)
8111b3f0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
8111b3f4:	d0a06117 	ldw	r2,-32380(gp)
8111b3f8:	100f883a 	mov	r7,r2
8111b3fc:	01800984 	movi	r6,38
8111b400:	01400044 	movi	r5,1
8111b404:	01204574 	movhi	r4,33045
8111b408:	21370f04 	addi	r4,r4,-9156
8111b40c:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
8111b410:	d0a06117 	ldw	r2,-32380(gp)
8111b414:	100f883a 	mov	r7,r2
8111b418:	01800bc4 	movi	r6,47
8111b41c:	01400044 	movi	r5,1
8111b420:	01204574 	movhi	r4,33045
8111b424:	21371904 	addi	r4,r4,-9116
8111b428:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b42c:	0001883a 	nop
8111b430:	e037883a 	mov	sp,fp
8111b434:	dfc00117 	ldw	ra,4(sp)
8111b438:	df000017 	ldw	fp,0(sp)
8111b43c:	dec00204 	addi	sp,sp,8
8111b440:	f800283a 	ret

8111b444 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
8111b444:	defffe04 	addi	sp,sp,-8
8111b448:	de00012e 	bgeu	sp,et,8111b450 <vCouldNotGetQueueMaskDataCtrl+0xc>
8111b44c:	003b68fa 	trap	3
8111b450:	dfc00115 	stw	ra,4(sp)
8111b454:	df000015 	stw	fp,0(sp)
8111b458:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
8111b45c:	d0a06117 	ldw	r2,-32380(gp)
8111b460:	100f883a 	mov	r7,r2
8111b464:	01800984 	movi	r6,38
8111b468:	01400044 	movi	r5,1
8111b46c:	01204574 	movhi	r4,33045
8111b470:	21372504 	addi	r4,r4,-9068
8111b474:	111fc980 	call	8111fc98 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111b478:	d0a06117 	ldw	r2,-32380(gp)
8111b47c:	100f883a 	mov	r7,r2
8111b480:	01800bc4 	movi	r6,47
8111b484:	01400044 	movi	r5,1
8111b488:	01204574 	movhi	r4,33045
8111b48c:	21372f04 	addi	r4,r4,-9028
8111b490:	111fc980 	call	8111fc98 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b494:	0001883a 	nop
8111b498:	e037883a 	mov	sp,fp
8111b49c:	dfc00117 	ldw	ra,4(sp)
8111b4a0:	df000017 	ldw	fp,0(sp)
8111b4a4:	dec00204 	addi	sp,sp,8
8111b4a8:	f800283a 	ret

8111b4ac <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
8111b4ac:	defffd04 	addi	sp,sp,-12
8111b4b0:	de00012e 	bgeu	sp,et,8111b4b8 <vFailSendMsgAccessDMA+0xc>
8111b4b4:	003b68fa 	trap	3
8111b4b8:	dfc00215 	stw	ra,8(sp)
8111b4bc:	df000115 	stw	fp,4(sp)
8111b4c0:	df000104 	addi	fp,sp,4
8111b4c4:	2005883a 	mov	r2,r4
8111b4c8:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
8111b4cc:	d0a06117 	ldw	r2,-32380(gp)
8111b4d0:	e0ffff03 	ldbu	r3,-4(fp)
8111b4d4:	180d883a 	mov	r6,r3
8111b4d8:	01604574 	movhi	r5,33045
8111b4dc:	29773b04 	addi	r5,r5,-8980
8111b4e0:	1009883a 	mov	r4,r2
8111b4e4:	111f5fc0 	call	8111f5fc <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b4e8:	0001883a 	nop
8111b4ec:	e037883a 	mov	sp,fp
8111b4f0:	dfc00117 	ldw	ra,4(sp)
8111b4f4:	df000017 	ldw	fp,0(sp)
8111b4f8:	dec00204 	addi	sp,sp,8
8111b4fc:	f800283a 	ret

8111b500 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
8111b500:	defffd04 	addi	sp,sp,-12
8111b504:	de00012e 	bgeu	sp,et,8111b50c <vFailRequestDMA+0xc>
8111b508:	003b68fa 	trap	3
8111b50c:	dfc00215 	stw	ra,8(sp)
8111b510:	df000115 	stw	fp,4(sp)
8111b514:	df000104 	addi	fp,sp,4
8111b518:	2005883a 	mov	r2,r4
8111b51c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111b520:	d0a06117 	ldw	r2,-32380(gp)
8111b524:	e0ffff03 	ldbu	r3,-4(fp)
8111b528:	180d883a 	mov	r6,r3
8111b52c:	01604574 	movhi	r5,33045
8111b530:	29774304 	addi	r5,r5,-8948
8111b534:	1009883a 	mov	r4,r2
8111b538:	111f5fc0 	call	8111f5fc <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b53c:	0001883a 	nop
8111b540:	e037883a 	mov	sp,fp
8111b544:	dfc00117 	ldw	ra,4(sp)
8111b548:	df000017 	ldw	fp,0(sp)
8111b54c:	dec00204 	addi	sp,sp,8
8111b550:	f800283a 	ret

8111b554 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
8111b554:	defffd04 	addi	sp,sp,-12
8111b558:	de00012e 	bgeu	sp,et,8111b560 <vFailRequestDMAFromIRQ+0xc>
8111b55c:	003b68fa 	trap	3
8111b560:	dfc00215 	stw	ra,8(sp)
8111b564:	df000115 	stw	fp,4(sp)
8111b568:	df000104 	addi	fp,sp,4
8111b56c:	2005883a 	mov	r2,r4
8111b570:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
8111b574:	d0a06117 	ldw	r2,-32380(gp)
8111b578:	e0ffff03 	ldbu	r3,-4(fp)
8111b57c:	180d883a 	mov	r6,r3
8111b580:	01604574 	movhi	r5,33045
8111b584:	29774304 	addi	r5,r5,-8948
8111b588:	1009883a 	mov	r4,r2
8111b58c:	111f5fc0 	call	8111f5fc <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b590:	0001883a 	nop
8111b594:	e037883a 	mov	sp,fp
8111b598:	dfc00117 	ldw	ra,4(sp)
8111b59c:	df000017 	ldw	fp,0(sp)
8111b5a0:	dec00204 	addi	sp,sp,8
8111b5a4:	f800283a 	ret

8111b5a8 <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111b5a8:	defffd04 	addi	sp,sp,-12
8111b5ac:	de00012e 	bgeu	sp,et,8111b5b4 <vFailSendRMAPFromIRQ+0xc>
8111b5b0:	003b68fa 	trap	3
8111b5b4:	dfc00215 	stw	ra,8(sp)
8111b5b8:	df000115 	stw	fp,4(sp)
8111b5bc:	df000104 	addi	fp,sp,4
8111b5c0:	2005883a 	mov	r2,r4
8111b5c4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111b5c8:	d0a06117 	ldw	r2,-32380(gp)
8111b5cc:	e0ffff03 	ldbu	r3,-4(fp)
8111b5d0:	180d883a 	mov	r6,r3
8111b5d4:	01604574 	movhi	r5,33045
8111b5d8:	29774a04 	addi	r5,r5,-8920
8111b5dc:	1009883a 	mov	r4,r2
8111b5e0:	111f5fc0 	call	8111f5fc <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b5e4:	0001883a 	nop
8111b5e8:	e037883a 	mov	sp,fp
8111b5ec:	dfc00117 	ldw	ra,4(sp)
8111b5f0:	df000017 	ldw	fp,0(sp)
8111b5f4:	dec00204 	addi	sp,sp,8
8111b5f8:	f800283a 	ret

8111b5fc <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
8111b5fc:	defffd04 	addi	sp,sp,-12
8111b600:	de00012e 	bgeu	sp,et,8111b608 <vFailSendMsgSync+0xc>
8111b604:	003b68fa 	trap	3
8111b608:	dfc00215 	stw	ra,8(sp)
8111b60c:	df000115 	stw	fp,4(sp)
8111b610:	df000104 	addi	fp,sp,4
8111b614:	2005883a 	mov	r2,r4
8111b618:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
8111b61c:	d0a06117 	ldw	r2,-32380(gp)
8111b620:	e0ffff03 	ldbu	r3,-4(fp)
8111b624:	180d883a 	mov	r6,r3
8111b628:	01604574 	movhi	r5,33045
8111b62c:	29775204 	addi	r5,r5,-8888
8111b630:	1009883a 	mov	r4,r2
8111b634:	111f5fc0 	call	8111f5fc <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b638:	0001883a 	nop
8111b63c:	e037883a 	mov	sp,fp
8111b640:	dfc00117 	ldw	ra,4(sp)
8111b644:	df000017 	ldw	fp,0(sp)
8111b648:	dec00204 	addi	sp,sp,8
8111b64c:	f800283a 	ret

8111b650 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
8111b650:	defffd04 	addi	sp,sp,-12
8111b654:	de00012e 	bgeu	sp,et,8111b65c <vFailSendMsgSyncRMAPTRIGGER+0xc>
8111b658:	003b68fa 	trap	3
8111b65c:	dfc00215 	stw	ra,8(sp)
8111b660:	df000115 	stw	fp,4(sp)
8111b664:	df000104 	addi	fp,sp,4
8111b668:	2005883a 	mov	r2,r4
8111b66c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
8111b670:	d0a06117 	ldw	r2,-32380(gp)
8111b674:	e0ffff03 	ldbu	r3,-4(fp)
8111b678:	180d883a 	mov	r6,r3
8111b67c:	01604574 	movhi	r5,33045
8111b680:	29775904 	addi	r5,r5,-8860
8111b684:	1009883a 	mov	r4,r2
8111b688:	111f5fc0 	call	8111f5fc <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b68c:	0001883a 	nop
8111b690:	e037883a 	mov	sp,fp
8111b694:	dfc00117 	ldw	ra,4(sp)
8111b698:	df000017 	ldw	fp,0(sp)
8111b69c:	dec00204 	addi	sp,sp,8
8111b6a0:	f800283a 	ret

8111b6a4 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
8111b6a4:	defffe04 	addi	sp,sp,-8
8111b6a8:	de00012e 	bgeu	sp,et,8111b6b0 <vFailSendMsgMasterSyncMeb+0xc>
8111b6ac:	003b68fa 	trap	3
8111b6b0:	dfc00115 	stw	ra,4(sp)
8111b6b4:	df000015 	stw	fp,0(sp)
8111b6b8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
8111b6bc:	d0a06117 	ldw	r2,-32380(gp)
8111b6c0:	100f883a 	mov	r7,r2
8111b6c4:	018006c4 	movi	r6,27
8111b6c8:	01400044 	movi	r5,1
8111b6cc:	01204574 	movhi	r4,33045
8111b6d0:	21376604 	addi	r4,r4,-8808
8111b6d4:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b6d8:	0001883a 	nop
8111b6dc:	e037883a 	mov	sp,fp
8111b6e0:	dfc00117 	ldw	ra,4(sp)
8111b6e4:	df000017 	ldw	fp,0(sp)
8111b6e8:	dec00204 	addi	sp,sp,8
8111b6ec:	f800283a 	ret

8111b6f0 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
8111b6f0:	defffe04 	addi	sp,sp,-8
8111b6f4:	de00012e 	bgeu	sp,et,8111b6fc <vFailSendMsgFeeCTRL+0xc>
8111b6f8:	003b68fa 	trap	3
8111b6fc:	dfc00115 	stw	ra,4(sp)
8111b700:	df000015 	stw	fp,0(sp)
8111b704:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
8111b708:	d0a06117 	ldw	r2,-32380(gp)
8111b70c:	100f883a 	mov	r7,r2
8111b710:	018005c4 	movi	r6,23
8111b714:	01400044 	movi	r5,1
8111b718:	01204574 	movhi	r4,33045
8111b71c:	21376d04 	addi	r4,r4,-8780
8111b720:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b724:	0001883a 	nop
8111b728:	e037883a 	mov	sp,fp
8111b72c:	dfc00117 	ldw	ra,4(sp)
8111b730:	df000017 	ldw	fp,0(sp)
8111b734:	dec00204 	addi	sp,sp,8
8111b738:	f800283a 	ret

8111b73c <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
8111b73c:	defffe04 	addi	sp,sp,-8
8111b740:	de00012e 	bgeu	sp,et,8111b748 <vFailSendMsgDataCTRL+0xc>
8111b744:	003b68fa 	trap	3
8111b748:	dfc00115 	stw	ra,4(sp)
8111b74c:	df000015 	stw	fp,0(sp)
8111b750:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
8111b754:	d0a06117 	ldw	r2,-32380(gp)
8111b758:	100f883a 	mov	r7,r2
8111b75c:	01800604 	movi	r6,24
8111b760:	01400044 	movi	r5,1
8111b764:	01204574 	movhi	r4,33045
8111b768:	21377304 	addi	r4,r4,-8756
8111b76c:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b770:	0001883a 	nop
8111b774:	e037883a 	mov	sp,fp
8111b778:	dfc00117 	ldw	ra,4(sp)
8111b77c:	df000017 	ldw	fp,0(sp)
8111b780:	dec00204 	addi	sp,sp,8
8111b784:	f800283a 	ret

8111b788 <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111b788:	defffe04 	addi	sp,sp,-8
8111b78c:	de00012e 	bgeu	sp,et,8111b794 <vFailFlushQueue+0xc>
8111b790:	003b68fa 	trap	3
8111b794:	dfc00115 	stw	ra,4(sp)
8111b798:	df000015 	stw	fp,0(sp)
8111b79c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
8111b7a0:	d0a06117 	ldw	r2,-32380(gp)
8111b7a4:	100f883a 	mov	r7,r2
8111b7a8:	01800744 	movi	r6,29
8111b7ac:	01400044 	movi	r5,1
8111b7b0:	01204574 	movhi	r4,33045
8111b7b4:	21377a04 	addi	r4,r4,-8728
8111b7b8:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b7bc:	0001883a 	nop
8111b7c0:	e037883a 	mov	sp,fp
8111b7c4:	dfc00117 	ldw	ra,4(sp)
8111b7c8:	df000017 	ldw	fp,0(sp)
8111b7cc:	dec00204 	addi	sp,sp,8
8111b7d0:	f800283a 	ret

8111b7d4 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
8111b7d4:	defffe04 	addi	sp,sp,-8
8111b7d8:	de00012e 	bgeu	sp,et,8111b7e0 <vFailFlushQueueData+0xc>
8111b7dc:	003b68fa 	trap	3
8111b7e0:	dfc00115 	stw	ra,4(sp)
8111b7e4:	df000015 	stw	fp,0(sp)
8111b7e8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
8111b7ec:	d0a06117 	ldw	r2,-32380(gp)
8111b7f0:	100f883a 	mov	r7,r2
8111b7f4:	01800844 	movi	r6,33
8111b7f8:	01400044 	movi	r5,1
8111b7fc:	01204574 	movhi	r4,33045
8111b800:	21378204 	addi	r4,r4,-8696
8111b804:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b808:	0001883a 	nop
8111b80c:	e037883a 	mov	sp,fp
8111b810:	dfc00117 	ldw	ra,4(sp)
8111b814:	df000017 	ldw	fp,0(sp)
8111b818:	dec00204 	addi	sp,sp,8
8111b81c:	f800283a 	ret

8111b820 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
8111b820:	defffe04 	addi	sp,sp,-8
8111b824:	de00012e 	bgeu	sp,et,8111b82c <vFailFlushMEBQueue+0xc>
8111b828:	003b68fa 	trap	3
8111b82c:	dfc00115 	stw	ra,4(sp)
8111b830:	df000015 	stw	fp,0(sp)
8111b834:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
8111b838:	d0a06117 	ldw	r2,-32380(gp)
8111b83c:	100f883a 	mov	r7,r2
8111b840:	01800804 	movi	r6,32
8111b844:	01400044 	movi	r5,1
8111b848:	01204574 	movhi	r4,33045
8111b84c:	21378b04 	addi	r4,r4,-8660
8111b850:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b854:	0001883a 	nop
8111b858:	e037883a 	mov	sp,fp
8111b85c:	dfc00117 	ldw	ra,4(sp)
8111b860:	df000017 	ldw	fp,0(sp)
8111b864:	dec00204 	addi	sp,sp,8
8111b868:	f800283a 	ret

8111b86c <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
8111b86c:	defffe04 	addi	sp,sp,-8
8111b870:	de00012e 	bgeu	sp,et,8111b878 <vFailFlushNFEEQueue+0xc>
8111b874:	003b68fa 	trap	3
8111b878:	dfc00115 	stw	ra,4(sp)
8111b87c:	df000015 	stw	fp,0(sp)
8111b880:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
8111b884:	d0a06117 	ldw	r2,-32380(gp)
8111b888:	100f883a 	mov	r7,r2
8111b88c:	01800844 	movi	r6,33
8111b890:	01400044 	movi	r5,1
8111b894:	01204574 	movhi	r4,33045
8111b898:	21379404 	addi	r4,r4,-8624
8111b89c:	111fc980 	call	8111fc98 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111b8a0:	0001883a 	nop
8111b8a4:	e037883a 	mov	sp,fp
8111b8a8:	dfc00117 	ldw	ra,4(sp)
8111b8ac:	df000017 	ldw	fp,0(sp)
8111b8b0:	dec00204 	addi	sp,sp,8
8111b8b4:	f800283a 	ret

8111b8b8 <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111b8b8:	deffff04 	addi	sp,sp,-4
8111b8bc:	de00012e 	bgeu	sp,et,8111b8c4 <vEvtChangeMebMode+0xc>
8111b8c0:	003b68fa 	trap	3
8111b8c4:	df000015 	stw	fp,0(sp)
8111b8c8:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111b8cc:	0001883a 	nop
8111b8d0:	e037883a 	mov	sp,fp
8111b8d4:	df000017 	ldw	fp,0(sp)
8111b8d8:	dec00104 	addi	sp,sp,4
8111b8dc:	f800283a 	ret

8111b8e0 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
8111b8e0:	deffff04 	addi	sp,sp,-4
8111b8e4:	de00012e 	bgeu	sp,et,8111b8ec <vEvtChangeFeeControllerMode+0xc>
8111b8e8:	003b68fa 	trap	3
8111b8ec:	df000015 	stw	fp,0(sp)
8111b8f0:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111b8f4:	0001883a 	nop
8111b8f8:	e037883a 	mov	sp,fp
8111b8fc:	df000017 	ldw	fp,0(sp)
8111b900:	dec00104 	addi	sp,sp,4
8111b904:	f800283a 	ret

8111b908 <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
8111b908:	deffff04 	addi	sp,sp,-4
8111b90c:	de00012e 	bgeu	sp,et,8111b914 <vEvtChangeDataControllerMode+0xc>
8111b910:	003b68fa 	trap	3
8111b914:	df000015 	stw	fp,0(sp)
8111b918:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
8111b91c:	0001883a 	nop
8111b920:	e037883a 	mov	sp,fp
8111b924:	df000017 	ldw	fp,0(sp)
8111b928:	dec00104 	addi	sp,sp,4
8111b92c:	f800283a 	ret

8111b930 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111b930:	defffd04 	addi	sp,sp,-12
8111b934:	de00012e 	bgeu	sp,et,8111b93c <vNFeeNotInUse+0xc>
8111b938:	003b68fa 	trap	3
8111b93c:	df000215 	stw	fp,8(sp)
8111b940:	df000204 	addi	fp,sp,8
8111b944:	e13ffe15 	stw	r4,-8(fp)
8111b948:	2805883a 	mov	r2,r5
8111b94c:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
8111b950:	e0bffe17 	ldw	r2,-8(fp)
8111b954:	e0ffff03 	ldbu	r3,-4(fp)
8111b958:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
8111b95c:	e0bffe17 	ldw	r2,-8(fp)
8111b960:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111b964:	e0bffe17 	ldw	r2,-8(fp)
8111b968:	10002315 	stw	zero,140(r2)
}
8111b96c:	0001883a 	nop
8111b970:	e037883a 	mov	sp,fp
8111b974:	df000017 	ldw	fp,0(sp)
8111b978:	dec00104 	addi	sp,sp,4
8111b97c:	f800283a 	ret

8111b980 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
8111b980:	defffb04 	addi	sp,sp,-20
8111b984:	de00012e 	bgeu	sp,et,8111b98c <vNFeeStructureInit+0xc>
8111b988:	003b68fa 	trap	3
8111b98c:	dfc00415 	stw	ra,16(sp)
8111b990:	df000315 	stw	fp,12(sp)
8111b994:	df000304 	addi	fp,sp,12
8111b998:	e13ffe15 	stw	r4,-8(fp)
8111b99c:	2805883a 	mov	r2,r5
8111b9a0:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
8111b9a4:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
8111b9a8:	e0bffe17 	ldw	r2,-8(fp)
8111b9ac:	e0ffff03 	ldbu	r3,-4(fp)
8111b9b0:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
8111b9b4:	e0bffe17 	ldw	r2,-8(fp)
8111b9b8:	10802f04 	addi	r2,r2,188
8111b9bc:	1009883a 	mov	r4,r2
8111b9c0:	1116b700 	call	81116b70 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
8111b9c4:	e13ffe17 	ldw	r4,-8(fp)
8111b9c8:	111baf80 	call	8111baf8 <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
8111b9cc:	e0bffe17 	ldw	r2,-8(fp)
8111b9d0:	00c00044 	movi	r3,1
8111b9d4:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
8111b9d8:	e0bffe17 	ldw	r2,-8(fp)
8111b9dc:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
8111b9e0:	e0bffe17 	ldw	r2,-8(fp)
8111b9e4:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
8111b9e8:	e0bffe17 	ldw	r2,-8(fp)
8111b9ec:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
8111b9f0:	e0bffe17 	ldw	r2,-8(fp)
8111b9f4:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
8111b9f8:	e0bffe17 	ldw	r2,-8(fp)
8111b9fc:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
8111ba00:	e0bffe17 	ldw	r2,-8(fp)
8111ba04:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
8111ba08:	e0bffe17 	ldw	r2,-8(fp)
8111ba0c:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
8111ba10:	e0bffe17 	ldw	r2,-8(fp)
8111ba14:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
8111ba18:	e0bffe17 	ldw	r2,-8(fp)
8111ba1c:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
8111ba20:	e0bffe17 	ldw	r2,-8(fp)
8111ba24:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
8111ba28:	e0bffe17 	ldw	r2,-8(fp)
8111ba2c:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111ba30:	e03ffd05 	stb	zero,-12(fp)
8111ba34:	00000906 	br	8111ba5c <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
8111ba38:	e0bffd03 	ldbu	r2,-12(fp)
8111ba3c:	e0fffe17 	ldw	r3,-8(fp)
8111ba40:	1885883a 	add	r2,r3,r2
8111ba44:	10802a44 	addi	r2,r2,169
8111ba48:	e0fffd03 	ldbu	r3,-12(fp)
8111ba4c:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
8111ba50:	e0bffd03 	ldbu	r2,-12(fp)
8111ba54:	10800044 	addi	r2,r2,1
8111ba58:	e0bffd05 	stb	r2,-12(fp)
8111ba5c:	e0bffd03 	ldbu	r2,-12(fp)
8111ba60:	10800130 	cmpltui	r2,r2,4
8111ba64:	103ff41e 	bne	r2,zero,8111ba38 <__reset+0xfb0fba38>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
8111ba68:	e0bffe17 	ldw	r2,-8(fp)
8111ba6c:	10803204 	addi	r2,r2,200
8111ba70:	e0ffff03 	ldbu	r3,-4(fp)
8111ba74:	180b883a 	mov	r5,r3
8111ba78:	1009883a 	mov	r4,r2
8111ba7c:	11046980 	call	81104698 <bCommInitCh>
8111ba80:	1000091e 	bne	r2,zero,8111baa8 <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
8111ba84:	d0e06117 	ldw	r3,-32380(gp)
8111ba88:	e0bffe17 	ldw	r2,-8(fp)
8111ba8c:	10800003 	ldbu	r2,0(r2)
8111ba90:	10803fcc 	andi	r2,r2,255
8111ba94:	100d883a 	mov	r6,r2
8111ba98:	01604574 	movhi	r5,33045
8111ba9c:	29779d04 	addi	r5,r5,-8588
8111baa0:	1809883a 	mov	r4,r3
8111baa4:	111f5fc0 	call	8111f5fc <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, ucIdNFEE ) == FALSE ) {
8111baa8:	e0bfff03 	ldbu	r2,-4(fp)
8111baac:	100b883a 	mov	r5,r2
8111bab0:	01000044 	movi	r4,1
8111bab4:	110452c0 	call	8110452c <bCommSetGlobalIrqEn>
8111bab8:	1000091e 	bne	r2,zero,8111bae0 <vNFeeStructureInit+0x160>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
8111babc:	d0e06117 	ldw	r3,-32380(gp)
8111bac0:	e0bffe17 	ldw	r2,-8(fp)
8111bac4:	10800003 	ldbu	r2,0(r2)
8111bac8:	10803fcc 	andi	r2,r2,255
8111bacc:	100d883a 	mov	r6,r2
8111bad0:	01604574 	movhi	r5,33045
8111bad4:	2977a904 	addi	r5,r5,-8540
8111bad8:	1809883a 	mov	r4,r3
8111badc:	111f5fc0 	call	8111f5fc <fprintf>
		#endif
    }

}
8111bae0:	0001883a 	nop
8111bae4:	e037883a 	mov	sp,fp
8111bae8:	dfc00117 	ldw	ra,4(sp)
8111baec:	df000017 	ldw	fp,0(sp)
8111baf0:	dec00204 	addi	sp,sp,8
8111baf4:	f800283a 	ret

8111baf8 <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
8111baf8:	defff404 	addi	sp,sp,-48
8111bafc:	de00012e 	bgeu	sp,et,8111bb04 <vUpdateMemMapFEE+0xc>
8111bb00:	003b68fa 	trap	3
8111bb04:	df000b15 	stw	fp,44(sp)
8111bb08:	df000b04 	addi	fp,sp,44
8111bb0c:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
8111bb10:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
8111bb14:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
8111bb18:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
8111bb1c:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
8111bb20:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
8111bb24:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
8111bb28:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
8111bb2c:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
8111bb30:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
8111bb34:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
8111bb38:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
8111bb3c:	e17fff17 	ldw	r5,-4(fp)
8111bb40:	01035a34 	movhi	r4,3432
8111bb44:	21348c04 	addi	r4,r4,-11728
8111bb48:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
8111bb4c:	e13fff17 	ldw	r4,-4(fp)
8111bb50:	21000003 	ldbu	r4,0(r4)
8111bb54:	21403fcc 	andi	r5,r4,255
8111bb58:	01035a34 	movhi	r4,3432
8111bb5c:	21348c04 	addi	r4,r4,-11728
8111bb60:	2909383a 	mul	r4,r5,r4
8111bb64:	200b883a 	mov	r5,r4
8111bb68:	e13fff17 	ldw	r4,-4(fp)
8111bb6c:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
8111bb70:	e13fff17 	ldw	r4,-4(fp)
8111bb74:	21400117 	ldw	r5,4(r4)
8111bb78:	01033234 	movhi	r4,3272
8111bb7c:	21348c04 	addi	r4,r4,-11728
8111bb80:	290b883a 	add	r5,r5,r4
8111bb84:	e13fff17 	ldw	r4,-4(fp)
8111bb88:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111bb8c:	e13fff17 	ldw	r4,-4(fp)
8111bb90:	2100310b 	ldhu	r4,196(r4)
8111bb94:	217fffcc 	andi	r5,r4,65535
8111bb98:	e13fff17 	ldw	r4,-4(fp)
8111bb9c:	2100300b 	ldhu	r4,192(r4)
8111bba0:	213fffcc 	andi	r4,r4,65535
8111bba4:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
8111bba8:	e13fff17 	ldw	r4,-4(fp)
8111bbac:	2100308b 	ldhu	r4,194(r4)
8111bbb0:	21bfffcc 	andi	r6,r4,65535
8111bbb4:	e13fff17 	ldw	r4,-4(fp)
8111bbb8:	21002f8b 	ldhu	r4,190(r4)
8111bbbc:	213fffcc 	andi	r4,r4,65535
8111bbc0:	310d883a 	add	r6,r6,r4
8111bbc4:	e13fff17 	ldw	r4,-4(fp)
8111bbc8:	21002f0b 	ldhu	r4,188(r4)
8111bbcc:	213fffcc 	andi	r4,r4,65535
8111bbd0:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
8111bbd4:	2909383a 	mul	r4,r5,r4
8111bbd8:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
8111bbdc:	e13ffa17 	ldw	r4,-24(fp)
8111bbe0:	2109883a 	add	r4,r4,r4
8111bbe4:	200b883a 	mov	r5,r4
8111bbe8:	e13fff17 	ldw	r4,-4(fp)
8111bbec:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
8111bbf0:	e13fff17 	ldw	r4,-4(fp)
8111bbf4:	21000517 	ldw	r4,20(r4)
8111bbf8:	2008d0fa 	srli	r4,r4,3
8111bbfc:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
8111bc00:	e13fff17 	ldw	r4,-4(fp)
8111bc04:	21000517 	ldw	r4,20(r4)
8111bc08:	210001cc 	andi	r4,r4,7
8111bc0c:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
8111bc10:	e13ffb17 	ldw	r4,-20(fp)
8111bc14:	20001226 	beq	r4,zero,8111bc60 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
8111bc18:	e13ff517 	ldw	r4,-44(fp)
8111bc1c:	21000044 	addi	r4,r4,1
8111bc20:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
8111bc24:	e13fff17 	ldw	r4,-4(fp)
8111bc28:	21400517 	ldw	r5,20(r4)
8111bc2c:	e13ffb17 	ldw	r4,-20(fp)
8111bc30:	2909c83a 	sub	r4,r5,r4
8111bc34:	21400204 	addi	r5,r4,8
8111bc38:	e13fff17 	ldw	r4,-4(fp)
8111bc3c:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
8111bc40:	e13ffb17 	ldw	r4,-20(fp)
8111bc44:	200b883a 	mov	r5,r4
8111bc48:	01000204 	movi	r4,8
8111bc4c:	2149c83a 	sub	r4,r4,r5
8111bc50:	200b883a 	mov	r5,r4
8111bc54:	e13fff17 	ldw	r4,-4(fp)
8111bc58:	21400605 	stb	r5,24(r4)
8111bc5c:	00000206 	br	8111bc68 <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
8111bc60:	e13fff17 	ldw	r4,-4(fp)
8111bc64:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
8111bc68:	e13ff517 	ldw	r4,-44(fp)
8111bc6c:	2008d13a 	srli	r4,r4,4
8111bc70:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
8111bc74:	e13ff517 	ldw	r4,-44(fp)
8111bc78:	210003cc 	andi	r4,r4,15
8111bc7c:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
8111bc80:	e13ffc17 	ldw	r4,-16(fp)
8111bc84:	20000b26 	beq	r4,zero,8111bcb4 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
8111bc88:	e13ff717 	ldw	r4,-36(fp)
8111bc8c:	21000044 	addi	r4,r4,1
8111bc90:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
8111bc94:	e17ff517 	ldw	r5,-44(fp)
8111bc98:	e13ffc17 	ldw	r4,-16(fp)
8111bc9c:	290bc83a 	sub	r5,r5,r4
8111bca0:	e13ff717 	ldw	r4,-36(fp)
8111bca4:	2909883a 	add	r4,r5,r4
8111bca8:	21000404 	addi	r4,r4,16
8111bcac:	e13ff615 	stw	r4,-40(fp)
8111bcb0:	00000406 	br	8111bcc4 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
8111bcb4:	e17ff517 	ldw	r5,-44(fp)
8111bcb8:	e13ff717 	ldw	r4,-36(fp)
8111bcbc:	2909883a 	add	r4,r5,r4
8111bcc0:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
8111bcc4:	e13ff617 	ldw	r4,-40(fp)
8111bcc8:	200a90fa 	slli	r5,r4,3
8111bccc:	e13fff17 	ldw	r4,-4(fp)
8111bcd0:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
8111bcd4:	e13ffb17 	ldw	r4,-20(fp)
8111bcd8:	20000926 	beq	r4,zero,8111bd00 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
8111bcdc:	e13ffc17 	ldw	r4,-16(fp)
8111bce0:	2109883a 	add	r4,r4,r4
8111bce4:	2109883a 	add	r4,r4,r4
8111bce8:	200b883a 	mov	r5,r4
8111bcec:	e13ffb17 	ldw	r4,-20(fp)
8111bcf0:	2008d07a 	srli	r4,r4,1
8111bcf4:	2909883a 	add	r4,r5,r4
8111bcf8:	e13ff805 	stb	r4,-32(fp)
8111bcfc:	00000406 	br	8111bd10 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
8111bd00:	e13ffc17 	ldw	r4,-16(fp)
8111bd04:	2109883a 	add	r4,r4,r4
8111bd08:	2109883a 	add	r4,r4,r4
8111bd0c:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
8111bd10:	e13ff803 	ldbu	r4,-32(fp)
8111bd14:	01401004 	movi	r5,64
8111bd18:	2909c83a 	sub	r4,r5,r4
8111bd1c:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
8111bd20:	e13ffd03 	ldbu	r4,-12(fp)
8111bd24:	217ff804 	addi	r5,r4,-32
8111bd28:	28000416 	blt	r5,zero,8111bd3c <vUpdateMemMapFEE+0x244>
8111bd2c:	013fffc4 	movi	r4,-1
8111bd30:	2144d83a 	srl	r2,r4,r5
8111bd34:	0007883a 	mov	r3,zero
8111bd38:	00000a06 	br	8111bd64 <vUpdateMemMapFEE+0x26c>
8111bd3c:	017fffc4 	movi	r5,-1
8111bd40:	280c907a 	slli	r6,r5,1
8111bd44:	014007c4 	movi	r5,31
8111bd48:	290bc83a 	sub	r5,r5,r4
8111bd4c:	314a983a 	sll	r5,r6,r5
8111bd50:	01bfffc4 	movi	r6,-1
8111bd54:	3104d83a 	srl	r2,r6,r4
8111bd58:	2884b03a 	or	r2,r5,r2
8111bd5c:	017fffc4 	movi	r5,-1
8111bd60:	2906d83a 	srl	r3,r5,r4
8111bd64:	e13fff17 	ldw	r4,-4(fp)
8111bd68:	20800715 	stw	r2,28(r4)
8111bd6c:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
8111bd70:	e0bfff17 	ldw	r2,-4(fp)
8111bd74:	e0fff717 	ldw	r3,-36(fp)
8111bd78:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
8111bd7c:	e0bfff17 	ldw	r2,-4(fp)
8111bd80:	10c00117 	ldw	r3,4(r2)
8111bd84:	008004b4 	movhi	r2,18
8111bd88:	10a40004 	addi	r2,r2,-28672
8111bd8c:	1885883a 	add	r2,r3,r2
8111bd90:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
8111bd94:	e0bfff17 	ldw	r2,-4(fp)
8111bd98:	10c00517 	ldw	r3,20(r2)
8111bd9c:	008000b4 	movhi	r2,2
8111bda0:	10a40004 	addi	r2,r2,-28672
8111bda4:	1885883a 	add	r2,r3,r2
8111bda8:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111bdac:	e03ff845 	stb	zero,-31(fp)
8111bdb0:	00001906 	br	8111be18 <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
8111bdb4:	e0bff843 	ldbu	r2,-31(fp)
8111bdb8:	e0ffff17 	ldw	r3,-4(fp)
8111bdbc:	10800624 	muli	r2,r2,24
8111bdc0:	1885883a 	add	r2,r3,r2
8111bdc4:	10800904 	addi	r2,r2,36
8111bdc8:	e0fff917 	ldw	r3,-28(fp)
8111bdcc:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111bdd0:	e0fff917 	ldw	r3,-28(fp)
8111bdd4:	e0bffe17 	ldw	r2,-8(fp)
8111bdd8:	1885883a 	add	r2,r3,r2
8111bddc:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
8111bde0:	e0bff843 	ldbu	r2,-31(fp)
8111bde4:	e0ffff17 	ldw	r3,-4(fp)
8111bde8:	10800624 	muli	r2,r2,24
8111bdec:	1885883a 	add	r2,r3,r2
8111bdf0:	10800c04 	addi	r2,r2,48
8111bdf4:	e0fff917 	ldw	r3,-28(fp)
8111bdf8:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
8111bdfc:	e0fff917 	ldw	r3,-28(fp)
8111be00:	e0bffe17 	ldw	r2,-8(fp)
8111be04:	1885883a 	add	r2,r3,r2
8111be08:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111be0c:	e0bff843 	ldbu	r2,-31(fp)
8111be10:	10800044 	addi	r2,r2,1
8111be14:	e0bff845 	stb	r2,-31(fp)
8111be18:	e0bff843 	ldbu	r2,-31(fp)
8111be1c:	10800130 	cmpltui	r2,r2,4
8111be20:	103fe41e 	bne	r2,zero,8111bdb4 <__reset+0xfb0fbdb4>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
8111be24:	0001883a 	nop
8111be28:	e037883a 	mov	sp,fp
8111be2c:	df000017 	ldw	fp,0(sp)
8111be30:	dec00104 	addi	sp,sp,4
8111be34:	f800283a 	ret

8111be38 <vResetMemCCDFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
8111be38:	defffd04 	addi	sp,sp,-12
8111be3c:	de00012e 	bgeu	sp,et,8111be44 <vResetMemCCDFEE+0xc>
8111be40:	003b68fa 	trap	3
8111be44:	df000215 	stw	fp,8(sp)
8111be48:	df000204 	addi	fp,sp,8
8111be4c:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL = 0;
8111be50:	e03ffe05 	stb	zero,-8(fp)

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111be54:	e03ffe05 	stb	zero,-8(fp)
8111be58:	00001b06 	br	8111bec8 <vResetMemCCDFEE+0x90>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
8111be5c:	e0bffe03 	ldbu	r2,-8(fp)
8111be60:	e0ffff17 	ldw	r3,-4(fp)
8111be64:	10800624 	muli	r2,r2,24
8111be68:	1885883a 	add	r2,r3,r2
8111be6c:	10800b04 	addi	r2,r2,44
8111be70:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
8111be74:	e0bffe03 	ldbu	r2,-8(fp)
8111be78:	e0ffff17 	ldw	r3,-4(fp)
8111be7c:	10800624 	muli	r2,r2,24
8111be80:	1885883a 	add	r2,r3,r2
8111be84:	10800a04 	addi	r2,r2,40
8111be88:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
8111be8c:	e0bffe03 	ldbu	r2,-8(fp)
8111be90:	e0ffff17 	ldw	r3,-4(fp)
8111be94:	10800624 	muli	r2,r2,24
8111be98:	1885883a 	add	r2,r3,r2
8111be9c:	10800e04 	addi	r2,r2,56
8111bea0:	10000015 	stw	zero,0(r2)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
8111bea4:	e0bffe03 	ldbu	r2,-8(fp)
8111bea8:	e0ffff17 	ldw	r3,-4(fp)
8111beac:	10800624 	muli	r2,r2,24
8111beb0:	1885883a 	add	r2,r3,r2
8111beb4:	10800d04 	addi	r2,r2,52
8111beb8:	10000015 	stw	zero,0(r2)

/* Update the memory mapping for the FEE due to the CCD informations */
void vResetMemCCDFEE( TNFee *pxNfeeL ) {
	unsigned char ucIL = 0;

    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
8111bebc:	e0bffe03 	ldbu	r2,-8(fp)
8111bec0:	10800044 	addi	r2,r2,1
8111bec4:	e0bffe05 	stb	r2,-8(fp)
8111bec8:	e0bffe03 	ldbu	r2,-8(fp)
8111becc:	10800130 	cmpltui	r2,r2,4
8111bed0:	103fe21e 	bne	r2,zero,8111be5c <__reset+0xfb0fbe5c>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulBlockI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulAddrI = 0;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulBlockI = 0;
    }
}
8111bed4:	0001883a 	nop
8111bed8:	e037883a 	mov	sp,fp
8111bedc:	df000017 	ldw	fp,0(sp)
8111bee0:	dec00104 	addi	sp,sp,4
8111bee4:	f800283a 	ret

8111bee8 <vFeeSpwRMAPLoadDefault>:



/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
8111bee8:	defffe04 	addi	sp,sp,-8
8111beec:	de00012e 	bgeu	sp,et,8111bef4 <vFeeSpwRMAPLoadDefault+0xc>
8111bef0:	003b68fa 	trap	3
8111bef4:	df000115 	stw	fp,4(sp)
8111bef8:	df000104 	addi	fp,sp,4
8111befc:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111bf00:	0001883a 	nop
8111bf04:	e037883a 	mov	sp,fp
8111bf08:	df000017 	ldw	fp,0(sp)
8111bf0c:	dec00104 	addi	sp,sp,4
8111bf10:	f800283a 	ret

8111bf14 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
8111bf14:	defffe04 	addi	sp,sp,-8
8111bf18:	de00012e 	bgeu	sp,et,8111bf20 <vFeeSpwRMAPChangeConfig+0xc>
8111bf1c:	003b68fa 	trap	3
8111bf20:	df000115 	stw	fp,4(sp)
8111bf24:	df000104 	addi	fp,sp,4
8111bf28:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
8111bf2c:	0001883a 	nop
8111bf30:	e037883a 	mov	sp,fp
8111bf34:	df000017 	ldw	fp,0(sp)
8111bf38:	dec00104 	addi	sp,sp,4
8111bf3c:	f800283a 	ret

8111bf40 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
8111bf40:	defffe04 	addi	sp,sp,-8
8111bf44:	de00012e 	bgeu	sp,et,8111bf4c <vFeeSpwRMAPChangeDefault+0xc>
8111bf48:	003b68fa 	trap	3
8111bf4c:	df000115 	stw	fp,4(sp)
8111bf50:	df000104 	addi	fp,sp,4
8111bf54:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
8111bf58:	0001883a 	nop
8111bf5c:	e037883a 	mov	sp,fp
8111bf60:	df000017 	ldw	fp,0(sp)
8111bf64:	dec00104 	addi	sp,sp,4
8111bf68:	f800283a 	ret

8111bf6c <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
8111bf6c:	defffe04 	addi	sp,sp,-8
8111bf70:	de00012e 	bgeu	sp,et,8111bf78 <cFeeSpwChannelEnable+0xc>
8111bf74:	003b68fa 	trap	3
8111bf78:	df000115 	stw	fp,4(sp)
8111bf7c:	df000104 	addi	fp,sp,4
8111bf80:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111bf84:	0001883a 	nop
8111bf88:	e037883a 	mov	sp,fp
8111bf8c:	df000017 	ldw	fp,0(sp)
8111bf90:	dec00104 	addi	sp,sp,4
8111bf94:	f800283a 	ret

8111bf98 <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
8111bf98:	defffe04 	addi	sp,sp,-8
8111bf9c:	de00012e 	bgeu	sp,et,8111bfa4 <cFeeSpwChannelDisable+0xc>
8111bfa0:	003b68fa 	trap	3
8111bfa4:	df000115 	stw	fp,4(sp)
8111bfa8:	df000104 	addi	fp,sp,4
8111bfac:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
8111bfb0:	0001883a 	nop
8111bfb4:	e037883a 	mov	sp,fp
8111bfb8:	df000017 	ldw	fp,0(sp)
8111bfbc:	dec00104 	addi	sp,sp,4
8111bfc0:	f800283a 	ret

8111bfc4 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
8111bfc4:	defffe04 	addi	sp,sp,-8
8111bfc8:	de00012e 	bgeu	sp,et,8111bfd0 <cFeeRMAPDump+0xc>
8111bfcc:	003b68fa 	trap	3
8111bfd0:	df000115 	stw	fp,4(sp)
8111bfd4:	df000104 	addi	fp,sp,4
8111bfd8:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
8111bfdc:	0001883a 	nop
8111bfe0:	e037883a 	mov	sp,fp
8111bfe4:	df000017 	ldw	fp,0(sp)
8111bfe8:	dec00104 	addi	sp,sp,4
8111bfec:	f800283a 	ret

8111bff0 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
8111bff0:	defffe04 	addi	sp,sp,-8
8111bff4:	de00012e 	bgeu	sp,et,8111bffc <cFeeRMAPEchoingEnable+0xc>
8111bff8:	003b68fa 	trap	3
8111bffc:	df000115 	stw	fp,4(sp)
8111c000:	df000104 	addi	fp,sp,4
8111c004:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
8111c008:	e0bfff17 	ldw	r2,-4(fp)
8111c00c:	00c00044 	movi	r3,1
8111c010:	10c02515 	stw	r3,148(r2)
}
8111c014:	0001883a 	nop
8111c018:	e037883a 	mov	sp,fp
8111c01c:	df000017 	ldw	fp,0(sp)
8111c020:	dec00104 	addi	sp,sp,4
8111c024:	f800283a 	ret

8111c028 <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111c028:	defffe04 	addi	sp,sp,-8
8111c02c:	de00012e 	bgeu	sp,et,8111c034 <cFeeRMAPEchoingDisable+0xc>
8111c030:	003b68fa 	trap	3
8111c034:	df000115 	stw	fp,4(sp)
8111c038:	df000104 	addi	fp,sp,4
8111c03c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111c040:	e0bfff17 	ldw	r2,-4(fp)
8111c044:	10002515 	stw	zero,148(r2)
}
8111c048:	0001883a 	nop
8111c04c:	e037883a 	mov	sp,fp
8111c050:	df000017 	ldw	fp,0(sp)
8111c054:	dec00104 	addi	sp,sp,4
8111c058:	f800283a 	ret

8111c05c <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111c05c:	defffe04 	addi	sp,sp,-8
8111c060:	de00012e 	bgeu	sp,et,8111c068 <cFeeRMAPLogEnable+0xc>
8111c064:	003b68fa 	trap	3
8111c068:	df000115 	stw	fp,4(sp)
8111c06c:	df000104 	addi	fp,sp,4
8111c070:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111c074:	e0bfff17 	ldw	r2,-4(fp)
8111c078:	00c00044 	movi	r3,1
8111c07c:	10c02415 	stw	r3,144(r2)
}
8111c080:	0001883a 	nop
8111c084:	e037883a 	mov	sp,fp
8111c088:	df000017 	ldw	fp,0(sp)
8111c08c:	dec00104 	addi	sp,sp,4
8111c090:	f800283a 	ret

8111c094 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111c094:	defffe04 	addi	sp,sp,-8
8111c098:	de00012e 	bgeu	sp,et,8111c0a0 <cFeeRMAPLogDisable+0xc>
8111c09c:	003b68fa 	trap	3
8111c0a0:	df000115 	stw	fp,4(sp)
8111c0a4:	df000104 	addi	fp,sp,4
8111c0a8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111c0ac:	e0bfff17 	ldw	r2,-4(fp)
8111c0b0:	10002415 	stw	zero,144(r2)
}
8111c0b4:	0001883a 	nop
8111c0b8:	e037883a 	mov	sp,fp
8111c0bc:	df000017 	ldw	fp,0(sp)
8111c0c0:	dec00104 	addi	sp,sp,4
8111c0c4:	f800283a 	ret

8111c0c8 <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111c0c8:	defffc04 	addi	sp,sp,-16
8111c0cc:	de00012e 	bgeu	sp,et,8111c0d4 <vNFeeControlInit+0xc>
8111c0d0:	003b68fa 	trap	3
8111c0d4:	dfc00315 	stw	ra,12(sp)
8111c0d8:	df000215 	stw	fp,8(sp)
8111c0dc:	df000204 	addi	fp,sp,8
8111c0e0:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111c0e4:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111c0e8:	e13fff17 	ldw	r4,-4(fp)
8111c0ec:	111c2140 	call	8111c214 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111c0f0:	e13fff17 	ldw	r4,-4(fp)
8111c0f4:	111c2480 	call	8111c248 <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111c0f8:	e0bfff17 	ldw	r2,-4(fp)
8111c0fc:	10009a15 	stw	zero,616(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111c100:	e03ffe05 	stb	zero,-8(fp)
8111c104:	00002b06 	br	8111c1b4 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111c108:	e0bffe03 	ldbu	r2,-8(fp)
8111c10c:	10809624 	muli	r2,r2,600
8111c110:	e0ffff17 	ldw	r3,-4(fp)
8111c114:	1885883a 	add	r2,r3,r2
8111c118:	e0fffe03 	ldbu	r3,-8(fp)
8111c11c:	180b883a 	mov	r5,r3
8111c120:	1009883a 	mov	r4,r2
8111c124:	111b9800 	call	8111b980 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111c128:	e0bffe03 	ldbu	r2,-8(fp)
8111c12c:	e0fffe03 	ldbu	r3,-8(fp)
8111c130:	18c09624 	muli	r3,r3,600
8111c134:	18c02104 	addi	r3,r3,132
8111c138:	e13fff17 	ldw	r4,-4(fp)
8111c13c:	20c7883a 	add	r3,r4,r3
8111c140:	e13fff17 	ldw	r4,-4(fp)
8111c144:	108025c4 	addi	r2,r2,151
8111c148:	1085883a 	add	r2,r2,r2
8111c14c:	1085883a 	add	r2,r2,r2
8111c150:	2085883a 	add	r2,r4,r2
8111c154:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111c158:	e0bffe03 	ldbu	r2,-8(fp)
8111c15c:	e0fffe03 	ldbu	r3,-8(fp)
8111c160:	18c09624 	muli	r3,r3,600
8111c164:	18c02704 	addi	r3,r3,156
8111c168:	e13fff17 	ldw	r4,-4(fp)
8111c16c:	20c7883a 	add	r3,r4,r3
8111c170:	e13fff17 	ldw	r4,-4(fp)
8111c174:	10802604 	addi	r2,r2,152
8111c178:	1085883a 	add	r2,r2,r2
8111c17c:	1085883a 	add	r2,r2,r2
8111c180:	2085883a 	add	r2,r4,r2
8111c184:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111c188:	e0bffe03 	ldbu	r2,-8(fp)
8111c18c:	e0ffff17 	ldw	r3,-4(fp)
8111c190:	18c09617 	ldw	r3,600(r3)
8111c194:	e13fff17 	ldw	r4,-4(fp)
8111c198:	10809624 	muli	r2,r2,600
8111c19c:	2085883a 	add	r2,r4,r2
8111c1a0:	10802904 	addi	r2,r2,164
8111c1a4:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111c1a8:	e0bffe03 	ldbu	r2,-8(fp)
8111c1ac:	10800044 	addi	r2,r2,1
8111c1b0:	e0bffe05 	stb	r2,-8(fp)
8111c1b4:	e0bffe03 	ldbu	r2,-8(fp)
8111c1b8:	103fd326 	beq	r2,zero,8111c108 <__reset+0xfb0fc108>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111c1bc:	0001883a 	nop
8111c1c0:	e037883a 	mov	sp,fp
8111c1c4:	dfc00117 	ldw	ra,4(sp)
8111c1c8:	df000017 	ldw	fp,0(sp)
8111c1cc:	dec00204 	addi	sp,sp,8
8111c1d0:	f800283a 	ret

8111c1d4 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111c1d4:	defffd04 	addi	sp,sp,-12
8111c1d8:	de00012e 	bgeu	sp,et,8111c1e0 <vSetTimeCode+0xc>
8111c1dc:	003b68fa 	trap	3
8111c1e0:	df000215 	stw	fp,8(sp)
8111c1e4:	df000204 	addi	fp,sp,8
8111c1e8:	e13ffe15 	stw	r4,-8(fp)
8111c1ec:	2805883a 	mov	r2,r5
8111c1f0:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111c1f4:	e0bffe17 	ldw	r2,-8(fp)
8111c1f8:	e0ffff03 	ldbu	r3,-4(fp)
8111c1fc:	10c09905 	stb	r3,612(r2)
}
8111c200:	0001883a 	nop
8111c204:	e037883a 	mov	sp,fp
8111c208:	df000017 	ldw	fp,0(sp)
8111c20c:	dec00104 	addi	sp,sp,4
8111c210:	f800283a 	ret

8111c214 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111c214:	defffe04 	addi	sp,sp,-8
8111c218:	de00012e 	bgeu	sp,et,8111c220 <vResetTimeCode+0xc>
8111c21c:	003b68fa 	trap	3
8111c220:	df000115 	stw	fp,4(sp)
8111c224:	df000104 	addi	fp,sp,4
8111c228:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111c22c:	e0bfff17 	ldw	r2,-4(fp)
8111c230:	10009905 	stb	zero,612(r2)
}
8111c234:	0001883a 	nop
8111c238:	e037883a 	mov	sp,fp
8111c23c:	df000017 	ldw	fp,0(sp)
8111c240:	dec00104 	addi	sp,sp,4
8111c244:	f800283a 	ret

8111c248 <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111c248:	defffe04 	addi	sp,sp,-8
8111c24c:	de00012e 	bgeu	sp,et,8111c254 <vLoadDefaultIdNFEEMaster+0xc>
8111c250:	003b68fa 	trap	3
8111c254:	df000115 	stw	fp,4(sp)
8111c258:	df000104 	addi	fp,sp,4
8111c25c:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111c260:	e0bfff17 	ldw	r2,-4(fp)
8111c264:	10009945 	stb	zero,613(r2)
}
8111c268:	0001883a 	nop
8111c26c:	e037883a 	mov	sp,fp
8111c270:	df000017 	ldw	fp,0(sp)
8111c274:	dec00104 	addi	sp,sp,4
8111c278:	f800283a 	ret

8111c27c <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111c27c:	defffd04 	addi	sp,sp,-12
8111c280:	de00012e 	bgeu	sp,et,8111c288 <vChangeIdNFEEMaster+0xc>
8111c284:	003b68fa 	trap	3
8111c288:	df000215 	stw	fp,8(sp)
8111c28c:	df000204 	addi	fp,sp,8
8111c290:	e13ffe15 	stw	r4,-8(fp)
8111c294:	2805883a 	mov	r2,r5
8111c298:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111c29c:	e0bffe17 	ldw	r2,-8(fp)
8111c2a0:	e0ffff03 	ldbu	r3,-4(fp)
8111c2a4:	10c09945 	stb	r3,613(r2)
}
8111c2a8:	0001883a 	nop
8111c2ac:	e037883a 	mov	sp,fp
8111c2b0:	df000017 	ldw	fp,0(sp)
8111c2b4:	dec00104 	addi	sp,sp,4
8111c2b8:	f800283a 	ret

8111c2bc <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111c2bc:	defffd04 	addi	sp,sp,-12
8111c2c0:	de00012e 	bgeu	sp,et,8111c2c8 <vChangeDefaultIdNFEEMaster+0xc>
8111c2c4:	003b68fa 	trap	3
8111c2c8:	df000215 	stw	fp,8(sp)
8111c2cc:	df000204 	addi	fp,sp,8
8111c2d0:	e13ffe15 	stw	r4,-8(fp)
8111c2d4:	2805883a 	mov	r2,r5
8111c2d8:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111c2dc:	0001883a 	nop
8111c2e0:	e037883a 	mov	sp,fp
8111c2e4:	df000017 	ldw	fp,0(sp)
8111c2e8:	dec00104 	addi	sp,sp,4
8111c2ec:	f800283a 	ret

8111c2f0 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111c2f0:	defffe04 	addi	sp,sp,-8
8111c2f4:	de00012e 	bgeu	sp,et,8111c2fc <vInitSimucamBasicHW+0xc>
8111c2f8:	003b68fa 	trap	3
8111c2fc:	dfc00115 	stw	ra,4(sp)
8111c300:	df000015 	stw	fp,0(sp)
8111c304:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111c308:	01403fc4 	movi	r5,255
8111c30c:	0009883a 	mov	r4,zero
8111c310:	110ad380 	call	8110ad38 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111c314:	01400834 	movhi	r5,32
8111c318:	297fffc4 	addi	r5,r5,-1
8111c31c:	0009883a 	mov	r4,zero
8111c320:	110adb80 	call	8110adb8 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111c324:	01400074 	movhi	r5,1
8111c328:	01000044 	movi	r4,1
8111c32c:	110adb80 	call	8110adb8 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111c330:	0009883a 	mov	r4,zero
8111c334:	110c3940 	call	8110c394 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111c338:	0009883a 	mov	r4,zero
8111c33c:	110c4640 	call	8110c464 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111c340:	01008004 	movi	r4,512
8111c344:	110bef40 	call	8110bef4 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111c348:	01008004 	movi	r4,512
8111c34c:	110be800 	call	8110be80 <vRstcReleaseDeviceReset>

}
8111c350:	0001883a 	nop
8111c354:	e037883a 	mov	sp,fp
8111c358:	dfc00117 	ldw	ra,4(sp)
8111c35c:	df000017 	ldw	fp,0(sp)
8111c360:	dec00204 	addi	sp,sp,8
8111c364:	f800283a 	ret

8111c368 <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111c368:	defffd04 	addi	sp,sp,-12
8111c36c:	de00012e 	bgeu	sp,et,8111c374 <bLogWriteSDCard+0xc>
8111c370:	003b68fa 	trap	3
8111c374:	df000215 	stw	fp,8(sp)
8111c378:	df000204 	addi	fp,sp,8
8111c37c:	e13ffe15 	stw	r4,-8(fp)
8111c380:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111c384:	00800044 	movi	r2,1
}
8111c388:	e037883a 	mov	sp,fp
8111c38c:	df000017 	ldw	fp,0(sp)
8111c390:	dec00104 	addi	sp,sp,4
8111c394:	f800283a 	ret

8111c398 <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111c398:	deffe004 	addi	sp,sp,-128
8111c39c:	de00012e 	bgeu	sp,et,8111c3a4 <vLogWriteNUC+0xc>
8111c3a0:	003b68fa 	trap	3
8111c3a4:	dfc01f15 	stw	ra,124(sp)
8111c3a8:	df001e15 	stw	fp,120(sp)
8111c3ac:	df001e04 	addi	fp,sp,120
8111c3b0:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111c3b4:	e03fe215 	stw	zero,-120(fp)
8111c3b8:	e0bfe304 	addi	r2,fp,-116
8111c3bc:	00c01b84 	movi	r3,110
8111c3c0:	180d883a 	mov	r6,r3
8111c3c4:	000b883a 	mov	r5,zero
8111c3c8:	1009883a 	mov	r4,r2
8111c3cc:	11207fc0 	call	811207fc <memset>
	memset(cTemp,0,114);
8111c3d0:	01801c84 	movi	r6,114
8111c3d4:	000b883a 	mov	r5,zero
8111c3d8:	e13fe204 	addi	r4,fp,-120
8111c3dc:	11207fc0 	call	811207fc <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111c3e0:	e13fff17 	ldw	r4,-4(fp)
8111c3e4:	11211a00 	call	811211a0 <strlen>
8111c3e8:	10801c68 	cmpgeui	r2,r2,113
8111c3ec:	1000031e 	bne	r2,zero,8111c3fc <vLogWriteNUC+0x64>
8111c3f0:	e13fff17 	ldw	r4,-4(fp)
8111c3f4:	11211a00 	call	811211a0 <strlen>
8111c3f8:	00000106 	br	8111c400 <vLogWriteNUC+0x68>
8111c3fc:	00801c44 	movi	r2,113
8111c400:	100d883a 	mov	r6,r2
8111c404:	e17fff17 	ldw	r5,-4(fp)
8111c408:	e13fe204 	addi	r4,fp,-120
8111c40c:	11206ac0 	call	811206ac <memcpy>
	vSendLog ( cDataIn );
8111c410:	e13fff17 	ldw	r4,-4(fp)
8111c414:	1117a300 	call	81117a30 <vSendLog>
}
8111c418:	0001883a 	nop
8111c41c:	e037883a 	mov	sp,fp
8111c420:	dfc00117 	ldw	ra,4(sp)
8111c424:	df000017 	ldw	fp,0(sp)
8111c428:	dec00204 	addi	sp,sp,8
8111c42c:	f800283a 	ret

8111c430 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111c430:	defffd04 	addi	sp,sp,-12
8111c434:	de00012e 	bgeu	sp,et,8111c43c <vSimucamStructureInit+0xc>
8111c438:	003b68fa 	trap	3
8111c43c:	dfc00215 	stw	ra,8(sp)
8111c440:	df000115 	stw	fp,4(sp)
8111c444:	df000104 	addi	fp,sp,4
8111c448:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111c44c:	e0bfff17 	ldw	r2,-4(fp)
8111c450:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111c454:	e0bfff17 	ldw	r2,-4(fp)
8111c458:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111c45c:	e13fff17 	ldw	r4,-4(fp)
8111c460:	111c51c0 	call	8111c51c <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111c464:	e13fff17 	ldw	r4,-4(fp)
8111c468:	111c5c00 	call	8111c5c0 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111c46c:	e13fff17 	ldw	r4,-4(fp)
8111c470:	111c6680 	call	8111c668 <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111c474:	e13fff17 	ldw	r4,-4(fp)
8111c478:	111c7080 	call	8111c708 <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111c47c:	e0bfff17 	ldw	r2,-4(fp)
8111c480:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111c484:	e0bfff17 	ldw	r2,-4(fp)
8111c488:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111c48c:	e0bfff17 	ldw	r2,-4(fp)
8111c490:	00c07d04 	movi	r3,500
8111c494:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111c498:	e0bfff17 	ldw	r2,-4(fp)
8111c49c:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111c4a0:	e0bfff17 	ldw	r2,-4(fp)
8111c4a4:	00c00044 	movi	r3,1
8111c4a8:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111c4ac:	e0bfff17 	ldw	r2,-4(fp)
8111c4b0:	10c00204 	addi	r3,r2,8
8111c4b4:	e0bfff17 	ldw	r2,-4(fp)
8111c4b8:	10c0a815 	stw	r3,672(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111c4bc:	e0bfff17 	ldw	r2,-4(fp)
8111c4c0:	10c00244 	addi	r3,r2,9
8111c4c4:	e0bfff17 	ldw	r2,-4(fp)
8111c4c8:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111c4cc:	e0bfff17 	ldw	r2,-4(fp)
8111c4d0:	10800017 	ldw	r2,0(r2)
8111c4d4:	10000b1e 	bne	r2,zero,8111c504 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111c4d8:	e0bfff17 	ldw	r2,-4(fp)
8111c4dc:	10801204 	addi	r2,r2,72
8111c4e0:	1009883a 	mov	r4,r2
8111c4e4:	111c0c80 	call	8111c0c8 <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111c4e8:	e0bfff17 	ldw	r2,-4(fp)
8111c4ec:	10c00a04 	addi	r3,r2,40
8111c4f0:	e0bfff17 	ldw	r2,-4(fp)
8111c4f4:	10801204 	addi	r2,r2,72
8111c4f8:	100b883a 	mov	r5,r2
8111c4fc:	1809883a 	mov	r4,r3
8111c500:	11198780 	call	81119878 <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111c504:	0001883a 	nop
8111c508:	e037883a 	mov	sp,fp
8111c50c:	dfc00117 	ldw	ra,4(sp)
8111c510:	df000017 	ldw	fp,0(sp)
8111c514:	dec00204 	addi	sp,sp,8
8111c518:	f800283a 	ret

8111c51c <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111c51c:	defffe04 	addi	sp,sp,-8
8111c520:	de00012e 	bgeu	sp,et,8111c528 <vLoadDefaultEPValue+0xc>
8111c524:	003b68fa 	trap	3
8111c528:	df000115 	stw	fp,4(sp)
8111c52c:	df000104 	addi	fp,sp,4
8111c530:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111c534:	e0bfff17 	ldw	r2,-4(fp)
8111c538:	00d07234 	movhi	r3,16840
8111c53c:	10c00315 	stw	r3,12(r2)
}
8111c540:	0001883a 	nop
8111c544:	e037883a 	mov	sp,fp
8111c548:	df000017 	ldw	fp,0(sp)
8111c54c:	dec00104 	addi	sp,sp,4
8111c550:	f800283a 	ret

8111c554 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111c554:	defffd04 	addi	sp,sp,-12
8111c558:	de00012e 	bgeu	sp,et,8111c560 <vChangeEPValue+0xc>
8111c55c:	003b68fa 	trap	3
8111c560:	df000215 	stw	fp,8(sp)
8111c564:	df000204 	addi	fp,sp,8
8111c568:	e13ffe15 	stw	r4,-8(fp)
8111c56c:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111c570:	e0bffe17 	ldw	r2,-8(fp)
8111c574:	e0ffff17 	ldw	r3,-4(fp)
8111c578:	10c00315 	stw	r3,12(r2)
}
8111c57c:	0001883a 	nop
8111c580:	e037883a 	mov	sp,fp
8111c584:	df000017 	ldw	fp,0(sp)
8111c588:	dec00104 	addi	sp,sp,4
8111c58c:	f800283a 	ret

8111c590 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111c590:	defffd04 	addi	sp,sp,-12
8111c594:	de00012e 	bgeu	sp,et,8111c59c <vChangeDefaultEPValue+0xc>
8111c598:	003b68fa 	trap	3
8111c59c:	df000215 	stw	fp,8(sp)
8111c5a0:	df000204 	addi	fp,sp,8
8111c5a4:	e13ffe15 	stw	r4,-8(fp)
8111c5a8:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111c5ac:	0001883a 	nop
8111c5b0:	e037883a 	mov	sp,fp
8111c5b4:	df000017 	ldw	fp,0(sp)
8111c5b8:	dec00104 	addi	sp,sp,4
8111c5bc:	f800283a 	ret

8111c5c0 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111c5c0:	defffe04 	addi	sp,sp,-8
8111c5c4:	de00012e 	bgeu	sp,et,8111c5cc <vLoadDefaultRTValue+0xc>
8111c5c8:	003b68fa 	trap	3
8111c5cc:	df000115 	stw	fp,4(sp)
8111c5d0:	df000104 	addi	fp,sp,4
8111c5d4:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111c5d8:	e0ffff17 	ldw	r3,-4(fp)
8111c5dc:	00901eb4 	movhi	r2,16506
8111c5e0:	10a66684 	addi	r2,r2,-26214
8111c5e4:	18800415 	stw	r2,16(r3)
}
8111c5e8:	0001883a 	nop
8111c5ec:	e037883a 	mov	sp,fp
8111c5f0:	df000017 	ldw	fp,0(sp)
8111c5f4:	dec00104 	addi	sp,sp,4
8111c5f8:	f800283a 	ret

8111c5fc <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111c5fc:	defffd04 	addi	sp,sp,-12
8111c600:	de00012e 	bgeu	sp,et,8111c608 <vChangeRTValue+0xc>
8111c604:	003b68fa 	trap	3
8111c608:	df000215 	stw	fp,8(sp)
8111c60c:	df000204 	addi	fp,sp,8
8111c610:	e13ffe15 	stw	r4,-8(fp)
8111c614:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111c618:	e0bffe17 	ldw	r2,-8(fp)
8111c61c:	e0ffff17 	ldw	r3,-4(fp)
8111c620:	10c00415 	stw	r3,16(r2)
}
8111c624:	0001883a 	nop
8111c628:	e037883a 	mov	sp,fp
8111c62c:	df000017 	ldw	fp,0(sp)
8111c630:	dec00104 	addi	sp,sp,4
8111c634:	f800283a 	ret

8111c638 <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111c638:	defffd04 	addi	sp,sp,-12
8111c63c:	de00012e 	bgeu	sp,et,8111c644 <vChangeDefaultRTValue+0xc>
8111c640:	003b68fa 	trap	3
8111c644:	df000215 	stw	fp,8(sp)
8111c648:	df000204 	addi	fp,sp,8
8111c64c:	e13ffe15 	stw	r4,-8(fp)
8111c650:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111c654:	0001883a 	nop
8111c658:	e037883a 	mov	sp,fp
8111c65c:	df000017 	ldw	fp,0(sp)
8111c660:	dec00104 	addi	sp,sp,4
8111c664:	f800283a 	ret

8111c668 <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111c668:	defffe04 	addi	sp,sp,-8
8111c66c:	de00012e 	bgeu	sp,et,8111c674 <vLoadDefaultSyncSource+0xc>
8111c670:	003b68fa 	trap	3
8111c674:	df000115 	stw	fp,4(sp)
8111c678:	df000104 	addi	fp,sp,4
8111c67c:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111c680:	e0bfff17 	ldw	r2,-4(fp)
8111c684:	10000815 	stw	zero,32(r2)
}
8111c688:	0001883a 	nop
8111c68c:	e037883a 	mov	sp,fp
8111c690:	df000017 	ldw	fp,0(sp)
8111c694:	dec00104 	addi	sp,sp,4
8111c698:	f800283a 	ret

8111c69c <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111c69c:	defffd04 	addi	sp,sp,-12
8111c6a0:	de00012e 	bgeu	sp,et,8111c6a8 <vChangeSyncSource+0xc>
8111c6a4:	003b68fa 	trap	3
8111c6a8:	df000215 	stw	fp,8(sp)
8111c6ac:	df000204 	addi	fp,sp,8
8111c6b0:	e13ffe15 	stw	r4,-8(fp)
8111c6b4:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111c6b8:	e0bffe17 	ldw	r2,-8(fp)
8111c6bc:	e0ffff17 	ldw	r3,-4(fp)
8111c6c0:	10c00815 	stw	r3,32(r2)
}
8111c6c4:	0001883a 	nop
8111c6c8:	e037883a 	mov	sp,fp
8111c6cc:	df000017 	ldw	fp,0(sp)
8111c6d0:	dec00104 	addi	sp,sp,4
8111c6d4:	f800283a 	ret

8111c6d8 <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111c6d8:	defffd04 	addi	sp,sp,-12
8111c6dc:	de00012e 	bgeu	sp,et,8111c6e4 <vChangeDefaultSyncSource+0xc>
8111c6e0:	003b68fa 	trap	3
8111c6e4:	df000215 	stw	fp,8(sp)
8111c6e8:	df000204 	addi	fp,sp,8
8111c6ec:	e13ffe15 	stw	r4,-8(fp)
8111c6f0:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111c6f4:	0001883a 	nop
8111c6f8:	e037883a 	mov	sp,fp
8111c6fc:	df000017 	ldw	fp,0(sp)
8111c700:	dec00104 	addi	sp,sp,4
8111c704:	f800283a 	ret

8111c708 <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111c708:	defffe04 	addi	sp,sp,-8
8111c70c:	de00012e 	bgeu	sp,et,8111c714 <vLoadDefaultAutoResetSync+0xc>
8111c710:	003b68fa 	trap	3
8111c714:	df000115 	stw	fp,4(sp)
8111c718:	df000104 	addi	fp,sp,4
8111c71c:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111c720:	e0bfff17 	ldw	r2,-4(fp)
8111c724:	00c00044 	movi	r3,1
8111c728:	10c00915 	stw	r3,36(r2)
}
8111c72c:	0001883a 	nop
8111c730:	e037883a 	mov	sp,fp
8111c734:	df000017 	ldw	fp,0(sp)
8111c738:	dec00104 	addi	sp,sp,4
8111c73c:	f800283a 	ret

8111c740 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111c740:	defffd04 	addi	sp,sp,-12
8111c744:	de00012e 	bgeu	sp,et,8111c74c <vChangeAutoResetSync+0xc>
8111c748:	003b68fa 	trap	3
8111c74c:	df000215 	stw	fp,8(sp)
8111c750:	df000204 	addi	fp,sp,8
8111c754:	e13ffe15 	stw	r4,-8(fp)
8111c758:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111c75c:	e0bffe17 	ldw	r2,-8(fp)
8111c760:	e0ffff17 	ldw	r3,-4(fp)
8111c764:	10c00915 	stw	r3,36(r2)
}
8111c768:	0001883a 	nop
8111c76c:	e037883a 	mov	sp,fp
8111c770:	df000017 	ldw	fp,0(sp)
8111c774:	dec00104 	addi	sp,sp,4
8111c778:	f800283a 	ret

8111c77c <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111c77c:	defffd04 	addi	sp,sp,-12
8111c780:	de00012e 	bgeu	sp,et,8111c788 <vChangeDefaultAutoResetSync+0xc>
8111c784:	003b68fa 	trap	3
8111c788:	df000215 	stw	fp,8(sp)
8111c78c:	df000204 	addi	fp,sp,8
8111c790:	e13ffe15 	stw	r4,-8(fp)
8111c794:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111c798:	0001883a 	nop
8111c79c:	e037883a 	mov	sp,fp
8111c7a0:	df000017 	ldw	fp,0(sp)
8111c7a4:	dec00104 	addi	sp,sp,4
8111c7a8:	f800283a 	ret

8111c7ac <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111c7ac:	defffc04 	addi	sp,sp,-16
8111c7b0:	de00012e 	bgeu	sp,et,8111c7b8 <vSyncReset+0xc>
8111c7b4:	003b68fa 	trap	3
8111c7b8:	dfc00315 	stw	ra,12(sp)
8111c7bc:	df000215 	stw	fp,8(sp)
8111c7c0:	df000204 	addi	fp,sp,8
8111c7c4:	e13ffe15 	stw	r4,-8(fp)
8111c7c8:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111c7cc:	e0bffe17 	ldw	r2,-8(fp)
8111c7d0:	10801204 	addi	r2,r2,72
8111c7d4:	1009883a 	mov	r4,r2
8111c7d8:	111c2140 	call	8111c214 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111c7dc:	0001883a 	nop
8111c7e0:	e037883a 	mov	sp,fp
8111c7e4:	dfc00117 	ldw	ra,4(sp)
8111c7e8:	df000017 	ldw	fp,0(sp)
8111c7ec:	dec00204 	addi	sp,sp,8
8111c7f0:	f800283a 	ret

8111c7f4 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111c7f4:	defff004 	addi	sp,sp,-64
8111c7f8:	de00012e 	bgeu	sp,et,8111c800 <pattern_createPattern+0xc>
8111c7fc:	003b68fa 	trap	3
8111c800:	dfc00f15 	stw	ra,60(sp)
8111c804:	df000e15 	stw	fp,56(sp)
8111c808:	dcc00d15 	stw	r19,52(sp)
8111c80c:	dc800c15 	stw	r18,48(sp)
8111c810:	dc400b15 	stw	r17,44(sp)
8111c814:	dc000a15 	stw	r16,40(sp)
8111c818:	df000e04 	addi	fp,sp,56
8111c81c:	e17ff915 	stw	r5,-28(fp)
8111c820:	3007883a 	mov	r3,r6
8111c824:	3805883a 	mov	r2,r7
8111c828:	e13ff805 	stb	r4,-32(fp)
8111c82c:	e0fffa05 	stb	r3,-24(fp)
8111c830:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111c834:	e0bff803 	ldbu	r2,-32(fp)
8111c838:	1009883a 	mov	r4,r2
8111c83c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111c840:	e0bff917 	ldw	r2,-28(fp)
8111c844:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111c848:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111c84c:	e0bff217 	ldw	r2,-56(fp)
8111c850:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111c854:	e03ff515 	stw	zero,-44(fp)
8111c858:	00003606 	br	8111c934 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111c85c:	e03ff615 	stw	zero,-40(fp)
8111c860:	00002e06 	br	8111c91c <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111c864:	e0bff303 	ldbu	r2,-52(fp)
8111c868:	10801018 	cmpnei	r2,r2,64
8111c86c:	10000b1e 	bne	r2,zero,8111c89c <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111c870:	e0bff417 	ldw	r2,-48(fp)
8111c874:	00ffffc4 	movi	r3,-1
8111c878:	10c02015 	stw	r3,128(r2)
8111c87c:	00ffffc4 	movi	r3,-1
8111c880:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111c884:	e0bff217 	ldw	r2,-56(fp)
8111c888:	10802204 	addi	r2,r2,136
8111c88c:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111c890:	e0bff217 	ldw	r2,-56(fp)
8111c894:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111c898:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111c89c:	e0bff303 	ldbu	r2,-52(fp)
8111c8a0:	10c00044 	addi	r3,r2,1
8111c8a4:	e0fff305 	stb	r3,-52(fp)
8111c8a8:	10803fcc 	andi	r2,r2,255
8111c8ac:	e0fffa03 	ldbu	r3,-24(fp)
8111c8b0:	18c000cc 	andi	r3,r3,3
8111c8b4:	180692fa 	slli	r3,r3,11
8111c8b8:	1809883a 	mov	r4,r3
8111c8bc:	00f80004 	movi	r3,-8192
8111c8c0:	20c6b03a 	or	r3,r4,r3
8111c8c4:	1809883a 	mov	r4,r3
8111c8c8:	e0fffb03 	ldbu	r3,-20(fp)
8111c8cc:	18c0004c 	andi	r3,r3,1
8111c8d0:	180692ba 	slli	r3,r3,10
8111c8d4:	20c6b03a 	or	r3,r4,r3
8111c8d8:	1809883a 	mov	r4,r3
8111c8dc:	e0fff517 	ldw	r3,-44(fp)
8111c8e0:	18c007cc 	andi	r3,r3,31
8111c8e4:	1806917a 	slli	r3,r3,5
8111c8e8:	20c6b03a 	or	r3,r4,r3
8111c8ec:	1809883a 	mov	r4,r3
8111c8f0:	e0fff617 	ldw	r3,-40(fp)
8111c8f4:	18c007cc 	andi	r3,r3,31
8111c8f8:	20c6b03a 	or	r3,r4,r3
8111c8fc:	1809883a 	mov	r4,r3
8111c900:	e0fff417 	ldw	r3,-48(fp)
8111c904:	1085883a 	add	r2,r2,r2
8111c908:	1885883a 	add	r2,r3,r2
8111c90c:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111c910:	e0bff617 	ldw	r2,-40(fp)
8111c914:	10800044 	addi	r2,r2,1
8111c918:	e0bff615 	stw	r2,-40(fp)
8111c91c:	e0fff617 	ldw	r3,-40(fp)
8111c920:	e0800217 	ldw	r2,8(fp)
8111c924:	18bfcf36 	bltu	r3,r2,8111c864 <__reset+0xfb0fc864>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111c928:	e0bff517 	ldw	r2,-44(fp)
8111c92c:	10800044 	addi	r2,r2,1
8111c930:	e0bff515 	stw	r2,-44(fp)
8111c934:	e0fff517 	ldw	r3,-44(fp)
8111c938:	e0800317 	ldw	r2,12(fp)
8111c93c:	18bfc736 	bltu	r3,r2,8111c85c <__reset+0xfb0fc85c>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111c940:	e0bff303 	ldbu	r2,-52(fp)
8111c944:	e0bff705 	stb	r2,-36(fp)
8111c948:	00000806 	br	8111c96c <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
8111c94c:	e0bff703 	ldbu	r2,-36(fp)
8111c950:	e0fff417 	ldw	r3,-48(fp)
8111c954:	1085883a 	add	r2,r2,r2
8111c958:	1885883a 	add	r2,r3,r2
8111c95c:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111c960:	e0bff703 	ldbu	r2,-36(fp)
8111c964:	10800044 	addi	r2,r2,1
8111c968:	e0bff705 	stb	r2,-36(fp)
8111c96c:	e0bff703 	ldbu	r2,-36(fp)
8111c970:	10801030 	cmpltui	r2,r2,64
8111c974:	103ff51e 	bne	r2,zero,8111c94c <__reset+0xfb0fc94c>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
8111c978:	e0bff417 	ldw	r2,-48(fp)
8111c97c:	10002015 	stw	zero,128(r2)
8111c980:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111c984:	e03ff745 	stb	zero,-35(fp)
8111c988:	00001106 	br	8111c9d0 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
8111c98c:	e13ff417 	ldw	r4,-48(fp)
8111c990:	20802017 	ldw	r2,128(r4)
8111c994:	20c02117 	ldw	r3,132(r4)
8111c998:	e13ff743 	ldbu	r4,-35(fp)
8111c99c:	01400044 	movi	r5,1
8111c9a0:	2908983a 	sll	r4,r5,r4
8111c9a4:	2025883a 	mov	r18,r4
8111c9a8:	2009d7fa 	srai	r4,r4,31
8111c9ac:	2027883a 	mov	r19,r4
8111c9b0:	14a0b03a 	or	r16,r2,r18
8111c9b4:	1ce2b03a 	or	r17,r3,r19
8111c9b8:	e0bff417 	ldw	r2,-48(fp)
8111c9bc:	14002015 	stw	r16,128(r2)
8111c9c0:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111c9c4:	e0bff743 	ldbu	r2,-35(fp)
8111c9c8:	10800044 	addi	r2,r2,1
8111c9cc:	e0bff745 	stb	r2,-35(fp)
8111c9d0:	e0fff743 	ldbu	r3,-35(fp)
8111c9d4:	e0bff303 	ldbu	r2,-52(fp)
8111c9d8:	18bfec36 	bltu	r3,r2,8111c98c <__reset+0xfb0fc98c>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111c9dc:	e0bff217 	ldw	r2,-56(fp)
8111c9e0:	10802204 	addi	r2,r2,136
8111c9e4:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111c9e8:	e0bff217 	ldw	r2,-56(fp)
}
8111c9ec:	e6fffc04 	addi	sp,fp,-16
8111c9f0:	dfc00517 	ldw	ra,20(sp)
8111c9f4:	df000417 	ldw	fp,16(sp)
8111c9f8:	dcc00317 	ldw	r19,12(sp)
8111c9fc:	dc800217 	ldw	r18,8(sp)
8111ca00:	dc400117 	ldw	r17,4(sp)
8111ca04:	dc000017 	ldw	r16,0(sp)
8111ca08:	dec00604 	addi	sp,sp,24
8111ca0c:	f800283a 	ret

8111ca10 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111ca10:	defffe04 	addi	sp,sp,-8
8111ca14:	de00012e 	bgeu	sp,et,8111ca1c <bSDcardIsPresent+0xc>
8111ca18:	003b68fa 	trap	3
8111ca1c:	dfc00115 	stw	ra,4(sp)
8111ca20:	df000015 	stw	fp,0(sp)
8111ca24:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111ca28:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
}
8111ca2c:	e037883a 	mov	sp,fp
8111ca30:	dfc00117 	ldw	ra,4(sp)
8111ca34:	df000017 	ldw	fp,0(sp)
8111ca38:	dec00204 	addi	sp,sp,8
8111ca3c:	f800283a 	ret

8111ca40 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111ca40:	defffe04 	addi	sp,sp,-8
8111ca44:	de00012e 	bgeu	sp,et,8111ca4c <bSDcardFAT16Check+0xc>
8111ca48:	003b68fa 	trap	3
8111ca4c:	dfc00115 	stw	ra,4(sp)
8111ca50:	df000015 	stw	fp,0(sp)
8111ca54:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111ca58:	11430240 	call	81143024 <alt_up_sd_card_is_FAT16>
}
8111ca5c:	e037883a 	mov	sp,fp
8111ca60:	dfc00117 	ldw	ra,4(sp)
8111ca64:	df000017 	ldw	fp,0(sp)
8111ca68:	dec00204 	addi	sp,sp,8
8111ca6c:	f800283a 	ret

8111ca70 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111ca70:	defffd04 	addi	sp,sp,-12
8111ca74:	de00012e 	bgeu	sp,et,8111ca7c <bInitializeSDCard+0xc>
8111ca78:	003b68fa 	trap	3
8111ca7c:	dfc00215 	stw	ra,8(sp)
8111ca80:	df000115 	stw	fp,4(sp)
8111ca84:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111ca88:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111ca8c:	d0207615 	stw	zero,-32296(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111ca90:	01204574 	movhi	r4,33045
8111ca94:	2137b904 	addi	r4,r4,-8476
8111ca98:	1142e940 	call	81142e94 <alt_up_sd_card_open_dev>
8111ca9c:	d0a07615 	stw	r2,-32296(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111caa0:	d0a07617 	ldw	r2,-32296(gp)
8111caa4:	10002226 	beq	r2,zero,8111cb30 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111caa8:	111ca100 	call	8111ca10 <bSDcardIsPresent>
8111caac:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111cab0:	e0bfff17 	ldw	r2,-4(fp)
8111cab4:	10001626 	beq	r2,zero,8111cb10 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111cab8:	111ca400 	call	8111ca40 <bSDcardFAT16Check>
8111cabc:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111cac0:	e0bfff17 	ldw	r2,-4(fp)
8111cac4:	10000a26 	beq	r2,zero,8111caf0 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111cac8:	00800044 	movi	r2,1
8111cacc:	d0a07515 	stw	r2,-32300(gp)
				debug(fp, "SD is up.\r\n");
8111cad0:	d0a06117 	ldw	r2,-32380(gp)
8111cad4:	100f883a 	mov	r7,r2
8111cad8:	018002c4 	movi	r6,11
8111cadc:	01400044 	movi	r5,1
8111cae0:	01204574 	movhi	r4,33045
8111cae4:	2137c404 	addi	r4,r4,-8432
8111cae8:	111fc980 	call	8111fc98 <fwrite>
8111caec:	00001806 	br	8111cb50 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111caf0:	d0a06117 	ldw	r2,-32380(gp)
8111caf4:	100f883a 	mov	r7,r2
8111caf8:	01800984 	movi	r6,38
8111cafc:	01400044 	movi	r5,1
8111cb00:	01204574 	movhi	r4,33045
8111cb04:	2137c704 	addi	r4,r4,-8420
8111cb08:	111fc980 	call	8111fc98 <fwrite>
8111cb0c:	00001006 	br	8111cb50 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111cb10:	d0a06117 	ldw	r2,-32380(gp)
8111cb14:	100f883a 	mov	r7,r2
8111cb18:	01800744 	movi	r6,29
8111cb1c:	01400044 	movi	r5,1
8111cb20:	01204574 	movhi	r4,33045
8111cb24:	2137d104 	addi	r4,r4,-8380
8111cb28:	111fc980 	call	8111fc98 <fwrite>
8111cb2c:	00000806 	br	8111cb50 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111cb30:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111cb34:	d0a06117 	ldw	r2,-32380(gp)
8111cb38:	100f883a 	mov	r7,r2
8111cb3c:	018008c4 	movi	r6,35
8111cb40:	01400044 	movi	r5,1
8111cb44:	01204574 	movhi	r4,33045
8111cb48:	2137d904 	addi	r4,r4,-8348
8111cb4c:	111fc980 	call	8111fc98 <fwrite>
	}

	return bSucess;
8111cb50:	e0bfff17 	ldw	r2,-4(fp)
}
8111cb54:	e037883a 	mov	sp,fp
8111cb58:	dfc00117 	ldw	ra,4(sp)
8111cb5c:	df000017 	ldw	fp,0(sp)
8111cb60:	dec00204 	addi	sp,sp,8
8111cb64:	f800283a 	ret

8111cb68 <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111cb68:	defffd04 	addi	sp,sp,-12
8111cb6c:	de00012e 	bgeu	sp,et,8111cb74 <siOpenFile+0xc>
8111cb70:	003b68fa 	trap	3
8111cb74:	dfc00215 	stw	ra,8(sp)
8111cb78:	df000115 	stw	fp,4(sp)
8111cb7c:	df000104 	addi	fp,sp,4
8111cb80:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111cb84:	000b883a 	mov	r5,zero
8111cb88:	e13fff17 	ldw	r4,-4(fp)
8111cb8c:	11435300 	call	81143530 <alt_up_sd_card_fopen>
}
8111cb90:	e037883a 	mov	sp,fp
8111cb94:	dfc00117 	ldw	ra,4(sp)
8111cb98:	df000017 	ldw	fp,0(sp)
8111cb9c:	dec00204 	addi	sp,sp,8
8111cba0:	f800283a 	ret

8111cba4 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111cba4:	defffd04 	addi	sp,sp,-12
8111cba8:	de00012e 	bgeu	sp,et,8111cbb0 <siCloseFile+0xc>
8111cbac:	003b68fa 	trap	3
8111cbb0:	dfc00215 	stw	ra,8(sp)
8111cbb4:	df000115 	stw	fp,4(sp)
8111cbb8:	df000104 	addi	fp,sp,4
8111cbbc:	2005883a 	mov	r2,r4
8111cbc0:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111cbc4:	e0bfff0f 	ldh	r2,-4(fp)
8111cbc8:	1009883a 	mov	r4,r2
8111cbcc:	114437c0 	call	8114437c <alt_up_sd_card_fclose>
}
8111cbd0:	e037883a 	mov	sp,fp
8111cbd4:	dfc00117 	ldw	ra,4(sp)
8111cbd8:	df000017 	ldw	fp,0(sp)
8111cbdc:	dec00204 	addi	sp,sp,8
8111cbe0:	f800283a 	ret

8111cbe4 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111cbe4:	defffd04 	addi	sp,sp,-12
8111cbe8:	de00012e 	bgeu	sp,et,8111cbf0 <cGetNextChar+0xc>
8111cbec:	003b68fa 	trap	3
8111cbf0:	dfc00215 	stw	ra,8(sp)
8111cbf4:	df000115 	stw	fp,4(sp)
8111cbf8:	df000104 	addi	fp,sp,4
8111cbfc:	2005883a 	mov	r2,r4
8111cc00:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111cc04:	e0bfff0f 	ldh	r2,-4(fp)
8111cc08:	1009883a 	mov	r4,r2
8111cc0c:	11439d40 	call	811439d4 <alt_up_sd_card_read>
}
8111cc10:	e037883a 	mov	sp,fp
8111cc14:	dfc00117 	ldw	ra,4(sp)
8111cc18:	df000017 	ldw	fp,0(sp)
8111cc1c:	dec00204 	addi	sp,sp,8
8111cc20:	f800283a 	ret

8111cc24 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111cc24:	defffc04 	addi	sp,sp,-16
8111cc28:	de00012e 	bgeu	sp,et,8111cc30 <bInitSync+0xc>
8111cc2c:	003b68fa 	trap	3
8111cc30:	dfc00315 	stw	ra,12(sp)
8111cc34:	df000215 	stw	fp,8(sp)
8111cc38:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111cc3c:	110c6040 	call	8110c604 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111cc40:	d0a06117 	ldw	r2,-32380(gp)
8111cc44:	100f883a 	mov	r7,r2
8111cc48:	01800684 	movi	r6,26
8111cc4c:	01400044 	movi	r5,1
8111cc50:	01204574 	movhi	r4,33045
8111cc54:	2137e204 	addi	r4,r4,-8312
8111cc58:	111fc980 	call	8111fc98 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111cc5c:	01004c74 	movhi	r4,305
8111cc60:	210b4004 	addi	r4,r4,11520
8111cc64:	110c80c0 	call	8110c80c <bSyncSetMbt>
8111cc68:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111cc6c:	e0bffe17 	ldw	r2,-8(fp)
8111cc70:	1000091e 	bne	r2,zero,8111cc98 <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111cc74:	d0a06117 	ldw	r2,-32380(gp)
8111cc78:	100f883a 	mov	r7,r2
8111cc7c:	018005c4 	movi	r6,23
8111cc80:	01400044 	movi	r5,1
8111cc84:	01204574 	movhi	r4,33045
8111cc88:	2137e904 	addi	r4,r4,-8284
8111cc8c:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111cc90:	e0bffe17 	ldw	r2,-8(fp)
8111cc94:	00007f06 	br	8111ce94 <bInitSync+0x270>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111cc98:	01002674 	movhi	r4,153
8111cc9c:	2125a004 	addi	r4,r4,-27008
8111cca0:	110c84c0 	call	8110c84c <bSyncSetBt>
8111cca4:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111cca8:	e0bffe17 	ldw	r2,-8(fp)
8111ccac:	1000091e 	bne	r2,zero,8111ccd4 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ccb0:	d0a06117 	ldw	r2,-32380(gp)
8111ccb4:	100f883a 	mov	r7,r2
8111ccb8:	018005c4 	movi	r6,23
8111ccbc:	01400044 	movi	r5,1
8111ccc0:	01204574 	movhi	r4,33045
8111ccc4:	2137e904 	addi	r4,r4,-8284
8111ccc8:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111cccc:	e0bffe17 	ldw	r2,-8(fp)
8111ccd0:	00007006 	br	8111ce94 <bInitSync+0x270>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer(  uliPerCalcPeriodMs( xDefaults.usiSyncPeriod ) );
8111ccd4:	00a045b4 	movhi	r2,33046
8111ccd8:	1091bc04 	addi	r2,r2,18160
8111ccdc:	1080068b 	ldhu	r2,26(r2)
8111cce0:	10bfffcc 	andi	r2,r2,65535
8111cce4:	1009883a 	mov	r4,r2
8111cce8:	110d4e40 	call	8110d4e4 <uliPerCalcPeriodMs>
8111ccec:	1009883a 	mov	r4,r2
8111ccf0:	110c88c0 	call	8110c88c <bSyncSetPer>
8111ccf4:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ccf8:	e0bffe17 	ldw	r2,-8(fp)
8111ccfc:	1000091e 	bne	r2,zero,8111cd24 <bInitSync+0x100>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111cd00:	d0a06117 	ldw	r2,-32380(gp)
8111cd04:	100f883a 	mov	r7,r2
8111cd08:	018005c4 	movi	r6,23
8111cd0c:	01400044 	movi	r5,1
8111cd10:	01204574 	movhi	r4,33045
8111cd14:	2137e904 	addi	r4,r4,-8284
8111cd18:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111cd1c:	e0bffe17 	ldw	r2,-8(fp)
8111cd20:	00005c06 	br	8111ce94 <bInitSync+0x270>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111cd24:	01005f74 	movhi	r4,381
8111cd28:	211e1004 	addi	r4,r4,30784
8111cd2c:	110c8cc0 	call	8110c8cc <bSyncSetOst>
8111cd30:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111cd34:	e0bffe17 	ldw	r2,-8(fp)
8111cd38:	1000091e 	bne	r2,zero,8111cd60 <bInitSync+0x13c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111cd3c:	d0a06117 	ldw	r2,-32380(gp)
8111cd40:	100f883a 	mov	r7,r2
8111cd44:	018005c4 	movi	r6,23
8111cd48:	01400044 	movi	r5,1
8111cd4c:	01204574 	movhi	r4,33045
8111cd50:	2137e904 	addi	r4,r4,-8284
8111cd54:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111cd58:	e0bffe17 	ldw	r2,-8(fp)
8111cd5c:	00004d06 	br	8111ce94 <bInitSync+0x270>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111cd60:	0009883a 	mov	r4,zero
8111cd64:	110c90c0 	call	8110c90c <bSyncSetPolarity>
8111cd68:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111cd6c:	e0bffe17 	ldw	r2,-8(fp)
8111cd70:	1000091e 	bne	r2,zero,8111cd98 <bInitSync+0x174>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111cd74:	d0a06117 	ldw	r2,-32380(gp)
8111cd78:	100f883a 	mov	r7,r2
8111cd7c:	018005c4 	movi	r6,23
8111cd80:	01400044 	movi	r5,1
8111cd84:	01204574 	movhi	r4,33045
8111cd88:	2137e904 	addi	r4,r4,-8284
8111cd8c:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111cd90:	e0bffe17 	ldw	r2,-8(fp)
8111cd94:	00003f06 	br	8111ce94 <bInitSync+0x270>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111cd98:	01000104 	movi	r4,4
8111cd9c:	110c9800 	call	8110c980 <bSyncSetNCycles>
8111cda0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111cda4:	e0bffe17 	ldw	r2,-8(fp)
8111cda8:	1000091e 	bne	r2,zero,8111cdd0 <bInitSync+0x1ac>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111cdac:	d0a06117 	ldw	r2,-32380(gp)
8111cdb0:	100f883a 	mov	r7,r2
8111cdb4:	018005c4 	movi	r6,23
8111cdb8:	01400044 	movi	r5,1
8111cdbc:	01204574 	movhi	r4,33045
8111cdc0:	2137e904 	addi	r4,r4,-8284
8111cdc4:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111cdc8:	e0bffe17 	ldw	r2,-8(fp)
8111cdcc:	00003106 	br	8111ce94 <bInitSync+0x270>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111cdd0:	01000044 	movi	r4,1
8111cdd4:	110cb5c0 	call	8110cb5c <bSyncCtrExtnIrq>
8111cdd8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111cddc:	e0bffe17 	ldw	r2,-8(fp)
8111cde0:	1000091e 	bne	r2,zero,8111ce08 <bInitSync+0x1e4>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111cde4:	d0a06117 	ldw	r2,-32380(gp)
8111cde8:	100f883a 	mov	r7,r2
8111cdec:	018005c4 	movi	r6,23
8111cdf0:	01400044 	movi	r5,1
8111cdf4:	01204574 	movhi	r4,33045
8111cdf8:	2137e904 	addi	r4,r4,-8284
8111cdfc:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111ce00:	e0bffe17 	ldw	r2,-8(fp)
8111ce04:	00002306 	br	8111ce94 <bInitSync+0x270>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111ce08:	01000044 	movi	r4,1
8111ce0c:	110cd240 	call	8110cd24 <bSyncCtrSyncOutEnable>
8111ce10:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ce14:	e0bffe17 	ldw	r2,-8(fp)
8111ce18:	1000091e 	bne	r2,zero,8111ce40 <bInitSync+0x21c>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ce1c:	d0a06117 	ldw	r2,-32380(gp)
8111ce20:	100f883a 	mov	r7,r2
8111ce24:	018005c4 	movi	r6,23
8111ce28:	01400044 	movi	r5,1
8111ce2c:	01204574 	movhi	r4,33045
8111ce30:	2137e904 	addi	r4,r4,-8284
8111ce34:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111ce38:	e0bffe17 	ldw	r2,-8(fp)
8111ce3c:	00001506 	br	8111ce94 <bInitSync+0x270>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111ce40:	01000044 	movi	r4,1
8111ce44:	110cd980 	call	8110cd98 <bSyncCtrCh1OutEnable>
8111ce48:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ce4c:	e0bffe17 	ldw	r2,-8(fp)
8111ce50:	1000091e 	bne	r2,zero,8111ce78 <bInitSync+0x254>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ce54:	d0a06117 	ldw	r2,-32380(gp)
8111ce58:	100f883a 	mov	r7,r2
8111ce5c:	018005c4 	movi	r6,23
8111ce60:	01400044 	movi	r5,1
8111ce64:	01204574 	movhi	r4,33045
8111ce68:	2137e904 	addi	r4,r4,-8284
8111ce6c:	111fc980 	call	8111fc98 <fwrite>
		#endif
		return bSuccess;
8111ce70:	e0bffe17 	ldw	r2,-8(fp)
8111ce74:	00000706 	br	8111ce94 <bInitSync+0x270>
	}

	bSuccess = bSyncCtrStart();
8111ce78:	110cbd40 	call	8110cbd4 <bSyncCtrStart>
8111ce7c:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111ce80:	110cc280 	call	8110cc28 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111ce84:	01000044 	movi	r4,1
8111ce88:	110d1ac0 	call	8110d1ac <bSyncIrqEnableBlank>
8111ce8c:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111ce90:	e0bffe17 	ldw	r2,-8(fp)
}
8111ce94:	e037883a 	mov	sp,fp
8111ce98:	dfc00117 	ldw	ra,4(sp)
8111ce9c:	df000017 	ldw	fp,0(sp)
8111cea0:	dec00204 	addi	sp,sp,8
8111cea4:	f800283a 	ret

8111cea8 <bStartSync>:


bool bStartSync(void) {
8111cea8:	defffd04 	addi	sp,sp,-12
8111ceac:	de00012e 	bgeu	sp,et,8111ceb4 <bStartSync+0xc>
8111ceb0:	003b68fa 	trap	3
8111ceb4:	dfc00215 	stw	ra,8(sp)
8111ceb8:	df000115 	stw	fp,4(sp)
8111cebc:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSyncCtrReset();
8111cec0:	110cc280 	call	8110cc28 <bSyncCtrReset>
	bSuccess = bSyncCtrStart();
8111cec4:	110cbd40 	call	8110cbd4 <bSyncCtrStart>
8111cec8:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111cecc:	e0bfff17 	ldw	r2,-4(fp)
}
8111ced0:	e037883a 	mov	sp,fp
8111ced4:	dfc00117 	ldw	ra,4(sp)
8111ced8:	df000017 	ldw	fp,0(sp)
8111cedc:	dec00204 	addi	sp,sp,8
8111cee0:	f800283a 	ret

8111cee4 <bStopSync>:

bool bStopSync(void) {
8111cee4:	defffe04 	addi	sp,sp,-8
8111cee8:	de00012e 	bgeu	sp,et,8111cef0 <bStopSync+0xc>
8111ceec:	003b68fa 	trap	3
8111cef0:	dfc00115 	stw	ra,4(sp)
8111cef4:	df000015 	stw	fp,0(sp)
8111cef8:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111cefc:	110cc280 	call	8110cc28 <bSyncCtrReset>
}
8111cf00:	e037883a 	mov	sp,fp
8111cf04:	dfc00117 	ldw	ra,4(sp)
8111cf08:	df000017 	ldw	fp,0(sp)
8111cf0c:	dec00204 	addi	sp,sp,8
8111cf10:	f800283a 	ret

8111cf14 <bClearCounterSync>:

void bClearCounterSync(void) {
8111cf14:	defffe04 	addi	sp,sp,-8
8111cf18:	de00012e 	bgeu	sp,et,8111cf20 <bClearCounterSync+0xc>
8111cf1c:	003b68fa 	trap	3
8111cf20:	dfc00115 	stw	ra,4(sp)
8111cf24:	df000015 	stw	fp,0(sp)
8111cf28:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111cf2c:	110c5d80 	call	8110c5d8 <vSyncClearCounter>
}
8111cf30:	0001883a 	nop
8111cf34:	e037883a 	mov	sp,fp
8111cf38:	dfc00117 	ldw	ra,4(sp)
8111cf3c:	df000017 	ldw	fp,0(sp)
8111cf40:	dec00204 	addi	sp,sp,8
8111cf44:	f800283a 	ret

8111cf48 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111cf48:	defffd04 	addi	sp,sp,-12
8111cf4c:	de00012e 	bgeu	sp,et,8111cf54 <bTestSimucamCriticalHW+0xc>
8111cf50:	003b68fa 	trap	3
8111cf54:	dfc00215 	stw	ra,8(sp)
8111cf58:	df000115 	stw	fp,4(sp)
8111cf5c:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111cf60:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111cf64:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111cf68:	e0bfff17 	ldw	r2,-4(fp)
8111cf6c:	1000021e 	bne	r2,zero,8111cf78 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111cf70:	e0bfff17 	ldw	r2,-4(fp)
8111cf74:	00001106 	br	8111cfbc <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
8111cf78:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111cf7c:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111cf80:	e0bfff17 	ldw	r2,-4(fp)
8111cf84:	1000021e 	bne	r2,zero,8111cf90 <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111cf88:	e0bfff17 	ldw	r2,-4(fp)
8111cf8c:	00000b06 	br	8111cfbc <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
8111cf90:	00a045b4 	movhi	r2,33046
8111cf94:	10850004 	addi	r2,r2,5120
8111cf98:	00e04434 	movhi	r3,33040
8111cf9c:	18cf2404 	addi	r3,r3,15504
8111cfa0:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111cfa4:	00a045b4 	movhi	r2,33046
8111cfa8:	10850004 	addi	r2,r2,5120
8111cfac:	00e04434 	movhi	r3,33040
8111cfb0:	18d04604 	addi	r3,r3,16664
8111cfb4:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111cfb8:	00800044 	movi	r2,1
}
8111cfbc:	e037883a 	mov	sp,fp
8111cfc0:	dfc00117 	ldw	ra,4(sp)
8111cfc4:	df000017 	ldw	fp,0(sp)
8111cfc8:	dec00204 	addi	sp,sp,8
8111cfcc:	f800283a 	ret

8111cfd0 <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111cfd0:	defffc04 	addi	sp,sp,-16
8111cfd4:	de00012e 	bgeu	sp,et,8111cfdc <_reg_write+0xc>
8111cfd8:	003b68fa 	trap	3
8111cfdc:	df000315 	stw	fp,12(sp)
8111cfe0:	df000304 	addi	fp,sp,12
8111cfe4:	e13ffd15 	stw	r4,-12(fp)
8111cfe8:	e17ffe15 	stw	r5,-8(fp)
8111cfec:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111cff0:	e0bffe17 	ldw	r2,-8(fp)
8111cff4:	1085883a 	add	r2,r2,r2
8111cff8:	1085883a 	add	r2,r2,r2
8111cffc:	1007883a 	mov	r3,r2
8111d000:	e0bffd17 	ldw	r2,-12(fp)
8111d004:	1885883a 	add	r2,r3,r2
8111d008:	1007883a 	mov	r3,r2
8111d00c:	e0bfff17 	ldw	r2,-4(fp)
8111d010:	18800035 	stwio	r2,0(r3)
	return 1;
8111d014:	00800044 	movi	r2,1

}
8111d018:	e037883a 	mov	sp,fp
8111d01c:	df000017 	ldw	fp,0(sp)
8111d020:	dec00104 	addi	sp,sp,4
8111d024:	f800283a 	ret

8111d028 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111d028:	defffc04 	addi	sp,sp,-16
8111d02c:	de00012e 	bgeu	sp,et,8111d034 <_reg_read+0xc>
8111d030:	003b68fa 	trap	3
8111d034:	df000315 	stw	fp,12(sp)
8111d038:	df000304 	addi	fp,sp,12
8111d03c:	e13ffd15 	stw	r4,-12(fp)
8111d040:	e17ffe15 	stw	r5,-8(fp)
8111d044:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111d048:	e0bffe17 	ldw	r2,-8(fp)
8111d04c:	1085883a 	add	r2,r2,r2
8111d050:	1085883a 	add	r2,r2,r2
8111d054:	1007883a 	mov	r3,r2
8111d058:	e0bffd17 	ldw	r2,-12(fp)
8111d05c:	1885883a 	add	r2,r3,r2
8111d060:	10c00037 	ldwio	r3,0(r2)
8111d064:	e0bfff17 	ldw	r2,-4(fp)
8111d068:	10c00015 	stw	r3,0(r2)
	return 1;
8111d06c:	00800044 	movi	r2,1

}
8111d070:	e037883a 	mov	sp,fp
8111d074:	df000017 	ldw	fp,0(sp)
8111d078:	dec00104 	addi	sp,sp,4
8111d07c:	f800283a 	ret

8111d080 <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111d080:	defffa04 	addi	sp,sp,-24
8111d084:	de00012e 	bgeu	sp,et,8111d08c <_print_codec_status+0xc>
8111d088:	003b68fa 	trap	3
8111d08c:	dfc00515 	stw	ra,20(sp)
8111d090:	df000415 	stw	fp,16(sp)
8111d094:	df000404 	addi	fp,sp,16
8111d098:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111d09c:	e0bfff17 	ldw	r2,-4(fp)
8111d0a0:	1005d1ba 	srai	r2,r2,6
8111d0a4:	1080004c 	andi	r2,r2,1
8111d0a8:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111d0ac:	e0bfff17 	ldw	r2,-4(fp)
8111d0b0:	1005d17a 	srai	r2,r2,5
8111d0b4:	1080004c 	andi	r2,r2,1
8111d0b8:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111d0bc:	e0bfff17 	ldw	r2,-4(fp)
8111d0c0:	1005d13a 	srai	r2,r2,4
8111d0c4:	1080004c 	andi	r2,r2,1
8111d0c8:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111d0cc:	00e04574 	movhi	r3,33045
8111d0d0:	18c3d204 	addi	r3,r3,3912
8111d0d4:	00a04574 	movhi	r2,33045
8111d0d8:	10b7ef04 	addi	r2,r2,-8260
8111d0dc:	1009883a 	mov	r4,r2
8111d0e0:	008005c4 	movi	r2,23
8111d0e4:	100d883a 	mov	r6,r2
8111d0e8:	200b883a 	mov	r5,r4
8111d0ec:	1809883a 	mov	r4,r3
8111d0f0:	11206ac0 	call	811206ac <memcpy>
	debug(fp, cDebugBuffer);
8111d0f4:	d0a06117 	ldw	r2,-32380(gp)
8111d0f8:	01604574 	movhi	r5,33045
8111d0fc:	2943d204 	addi	r5,r5,3912
8111d100:	1009883a 	mov	r4,r2
8111d104:	111f5fc0 	call	8111f5fc <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111d108:	e0bffc17 	ldw	r2,-16(fp)
8111d10c:	10800058 	cmpnei	r2,r2,1
8111d110:	1000031e 	bne	r2,zero,8111d120 <_print_codec_status+0xa0>
8111d114:	00a04574 	movhi	r2,33045
8111d118:	10b7f504 	addi	r2,r2,-8236
8111d11c:	00000206 	br	8111d128 <_print_codec_status+0xa8>
8111d120:	00a04574 	movhi	r2,33045
8111d124:	10b7f604 	addi	r2,r2,-8232
8111d128:	100d883a 	mov	r6,r2
8111d12c:	01604574 	movhi	r5,33045
8111d130:	2977f704 	addi	r5,r5,-8228
8111d134:	01204574 	movhi	r4,33045
8111d138:	2103d204 	addi	r4,r4,3912
8111d13c:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
8111d140:	d0a06117 	ldw	r2,-32380(gp)
8111d144:	01604574 	movhi	r5,33045
8111d148:	2943d204 	addi	r5,r5,3912
8111d14c:	1009883a 	mov	r4,r2
8111d150:	111f5fc0 	call	8111f5fc <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111d154:	e0bffd17 	ldw	r2,-12(fp)
8111d158:	10800058 	cmpnei	r2,r2,1
8111d15c:	1000031e 	bne	r2,zero,8111d16c <_print_codec_status+0xec>
8111d160:	00a04574 	movhi	r2,33045
8111d164:	10b7f504 	addi	r2,r2,-8236
8111d168:	00000206 	br	8111d174 <_print_codec_status+0xf4>
8111d16c:	00a04574 	movhi	r2,33045
8111d170:	10b7f604 	addi	r2,r2,-8232
8111d174:	100d883a 	mov	r6,r2
8111d178:	01604574 	movhi	r5,33045
8111d17c:	2977fd04 	addi	r5,r5,-8204
8111d180:	01204574 	movhi	r4,33045
8111d184:	2103d204 	addi	r4,r4,3912
8111d188:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
8111d18c:	d0a06117 	ldw	r2,-32380(gp)
8111d190:	01604574 	movhi	r5,33045
8111d194:	2943d204 	addi	r5,r5,3912
8111d198:	1009883a 	mov	r4,r2
8111d19c:	111f5fc0 	call	8111f5fc <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111d1a0:	e0bffe17 	ldw	r2,-8(fp)
8111d1a4:	10800058 	cmpnei	r2,r2,1
8111d1a8:	1000031e 	bne	r2,zero,8111d1b8 <_print_codec_status+0x138>
8111d1ac:	00a04574 	movhi	r2,33045
8111d1b0:	10b7f504 	addi	r2,r2,-8236
8111d1b4:	00000206 	br	8111d1c0 <_print_codec_status+0x140>
8111d1b8:	00a04574 	movhi	r2,33045
8111d1bc:	10b7f604 	addi	r2,r2,-8232
8111d1c0:	100d883a 	mov	r6,r2
8111d1c4:	01604574 	movhi	r5,33045
8111d1c8:	29780304 	addi	r5,r5,-8180
8111d1cc:	01204574 	movhi	r4,33045
8111d1d0:	2103d204 	addi	r4,r4,3912
8111d1d4:	1120f8c0 	call	81120f8c <sprintf>
	debug(fp, cDebugBuffer);
8111d1d8:	d0a06117 	ldw	r2,-32380(gp)
8111d1dc:	01604574 	movhi	r5,33045
8111d1e0:	2943d204 	addi	r5,r5,3912
8111d1e4:	1009883a 	mov	r4,r2
8111d1e8:	111f5fc0 	call	8111f5fc <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111d1ec:	00a04574 	movhi	r2,33045
8111d1f0:	1083d204 	addi	r2,r2,3912
8111d1f4:	00c00b44 	movi	r3,45
8111d1f8:	10c00005 	stb	r3,0(r2)
8111d1fc:	00c00b44 	movi	r3,45
8111d200:	10c00045 	stb	r3,1(r2)
8111d204:	00c00b44 	movi	r3,45
8111d208:	10c00085 	stb	r3,2(r2)
8111d20c:	00c00b44 	movi	r3,45
8111d210:	10c000c5 	stb	r3,3(r2)
8111d214:	00c00b44 	movi	r3,45
8111d218:	10c00105 	stb	r3,4(r2)
8111d21c:	00c00b44 	movi	r3,45
8111d220:	10c00145 	stb	r3,5(r2)
8111d224:	00c00b44 	movi	r3,45
8111d228:	10c00185 	stb	r3,6(r2)
8111d22c:	00c00b44 	movi	r3,45
8111d230:	10c001c5 	stb	r3,7(r2)
8111d234:	00c00804 	movi	r3,32
8111d238:	10c00205 	stb	r3,8(r2)
8111d23c:	00c00804 	movi	r3,32
8111d240:	10c00245 	stb	r3,9(r2)
8111d244:	00c00284 	movi	r3,10
8111d248:	10c00285 	stb	r3,10(r2)
8111d24c:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111d250:	d0a06117 	ldw	r2,-32380(gp)
8111d254:	01604574 	movhi	r5,33045
8111d258:	2943d204 	addi	r5,r5,3912
8111d25c:	1009883a 	mov	r4,r2
8111d260:	111f5fc0 	call	8111f5fc <fprintf>
#endif
}
8111d264:	0001883a 	nop
8111d268:	e037883a 	mov	sp,fp
8111d26c:	dfc00117 	ldw	ra,4(sp)
8111d270:	df000017 	ldw	fp,0(sp)
8111d274:	dec00204 	addi	sp,sp,8
8111d278:	f800283a 	ret

8111d27c <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111d27c:	defffb04 	addi	sp,sp,-20
8111d280:	de00012e 	bgeu	sp,et,8111d288 <_split_codec_status+0xc>
8111d284:	003b68fa 	trap	3
8111d288:	df000415 	stw	fp,16(sp)
8111d28c:	df000404 	addi	fp,sp,16
8111d290:	e13ffc15 	stw	r4,-16(fp)
8111d294:	e17ffd15 	stw	r5,-12(fp)
8111d298:	e1bffe15 	stw	r6,-8(fp)
8111d29c:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111d2a0:	e0bffc17 	ldw	r2,-16(fp)
8111d2a4:	1005d1ba 	srai	r2,r2,6
8111d2a8:	10c0004c 	andi	r3,r2,1
8111d2ac:	e0bffd17 	ldw	r2,-12(fp)
8111d2b0:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111d2b4:	e0bffc17 	ldw	r2,-16(fp)
8111d2b8:	1005d17a 	srai	r2,r2,5
8111d2bc:	10c0004c 	andi	r3,r2,1
8111d2c0:	e0bffe17 	ldw	r2,-8(fp)
8111d2c4:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111d2c8:	e0bffc17 	ldw	r2,-16(fp)
8111d2cc:	1005d13a 	srai	r2,r2,4
8111d2d0:	10c0004c 	andi	r3,r2,1
8111d2d4:	e0bfff17 	ldw	r2,-4(fp)
8111d2d8:	10c00015 	stw	r3,0(r2)
}
8111d2dc:	0001883a 	nop
8111d2e0:	e037883a 	mov	sp,fp
8111d2e4:	df000017 	ldw	fp,0(sp)
8111d2e8:	dec00104 	addi	sp,sp,4
8111d2ec:	f800283a 	ret

8111d2f0 <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111d2f0:	defffc04 	addi	sp,sp,-16
8111d2f4:	de00012e 	bgeu	sp,et,8111d2fc <aatoh+0xc>
8111d2f8:	003b68fa 	trap	3
8111d2fc:	df000315 	stw	fp,12(sp)
8111d300:	df000304 	addi	fp,sp,12
8111d304:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111d308:	e0bfff17 	ldw	r2,-4(fp)
8111d30c:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111d310:	e0bffd17 	ldw	r2,-12(fp)
8111d314:	10c00003 	ldbu	r3,0(r2)
8111d318:	e0bffd17 	ldw	r2,-12(fp)
8111d31c:	10800003 	ldbu	r2,0(r2)
8111d320:	10803fcc 	andi	r2,r2,255
8111d324:	10800eb0 	cmpltui	r2,r2,58
8111d328:	1000021e 	bne	r2,zero,8111d334 <aatoh+0x44>
8111d32c:	00800dc4 	movi	r2,55
8111d330:	00000106 	br	8111d338 <aatoh+0x48>
8111d334:	00800c04 	movi	r2,48
8111d338:	1885c83a 	sub	r2,r3,r2
8111d33c:	1004913a 	slli	r2,r2,4
8111d340:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111d344:	e0bffd17 	ldw	r2,-12(fp)
8111d348:	10800044 	addi	r2,r2,1
8111d34c:	10c00003 	ldbu	r3,0(r2)
8111d350:	e0bffd17 	ldw	r2,-12(fp)
8111d354:	10800044 	addi	r2,r2,1
8111d358:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111d35c:	10803fcc 	andi	r2,r2,255
8111d360:	10800eb0 	cmpltui	r2,r2,58
8111d364:	1000021e 	bne	r2,zero,8111d370 <aatoh+0x80>
8111d368:	00800dc4 	movi	r2,55
8111d36c:	00000106 	br	8111d374 <aatoh+0x84>
8111d370:	00800c04 	movi	r2,48
8111d374:	1885c83a 	sub	r2,r3,r2
8111d378:	2085883a 	add	r2,r4,r2
8111d37c:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111d380:	e0bffe03 	ldbu	r2,-8(fp)
}
8111d384:	e037883a 	mov	sp,fp
8111d388:	df000017 	ldw	fp,0(sp)
8111d38c:	dec00104 	addi	sp,sp,4
8111d390:	f800283a 	ret

8111d394 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111d394:	defffd04 	addi	sp,sp,-12
8111d398:	de00012e 	bgeu	sp,et,8111d3a0 <Verif_Error+0xc>
8111d39c:	003b68fa 	trap	3
8111d3a0:	dfc00215 	stw	ra,8(sp)
8111d3a4:	df000115 	stw	fp,4(sp)
8111d3a8:	df000104 	addi	fp,sp,4
8111d3ac:	2005883a 	mov	r2,r4
8111d3b0:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111d3b4:	e0bfff03 	ldbu	r2,-4(fp)
8111d3b8:	1000091e 	bne	r2,zero,8111d3e0 <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111d3bc:	d0a06117 	ldw	r2,-32380(gp)
8111d3c0:	100f883a 	mov	r7,r2
8111d3c4:	018001c4 	movi	r6,7
8111d3c8:	01400044 	movi	r5,1
8111d3cc:	01204574 	movhi	r4,33045
8111d3d0:	21380904 	addi	r4,r4,-8156
8111d3d4:	111fc980 	call	8111fc98 <fwrite>
#endif
		return 0;
8111d3d8:	0005883a 	mov	r2,zero
8111d3dc:	00000106 	br	8111d3e4 <Verif_Error+0x50>
	} else
		return 1;
8111d3e0:	00800044 	movi	r2,1
}
8111d3e4:	e037883a 	mov	sp,fp
8111d3e8:	dfc00117 	ldw	ra,4(sp)
8111d3ec:	df000017 	ldw	fp,0(sp)
8111d3f0:	dec00204 	addi	sp,sp,8
8111d3f4:	f800283a 	ret

8111d3f8 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111d3f8:	defffe04 	addi	sp,sp,-8
8111d3fc:	de00012e 	bgeu	sp,et,8111d404 <toInt+0xc>
8111d400:	003b68fa 	trap	3
8111d404:	df000115 	stw	fp,4(sp)
8111d408:	df000104 	addi	fp,sp,4
8111d40c:	2005883a 	mov	r2,r4
8111d410:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111d414:	e0bfff03 	ldbu	r2,-4(fp)
8111d418:	10bff404 	addi	r2,r2,-48
}
8111d41c:	e037883a 	mov	sp,fp
8111d420:	df000017 	ldw	fp,0(sp)
8111d424:	dec00104 	addi	sp,sp,4
8111d428:	f800283a 	ret

8111d42c <__fixunsdfsi>:
8111d42c:	defffd04 	addi	sp,sp,-12
8111d430:	000d883a 	mov	r6,zero
8111d434:	01d07834 	movhi	r7,16864
8111d438:	de00012e 	bgeu	sp,et,8111d440 <__fixunsdfsi+0x14>
8111d43c:	003b68fa 	trap	3
8111d440:	dc400115 	stw	r17,4(sp)
8111d444:	dc000015 	stw	r16,0(sp)
8111d448:	dfc00215 	stw	ra,8(sp)
8111d44c:	2023883a 	mov	r17,r4
8111d450:	2821883a 	mov	r16,r5
8111d454:	111df180 	call	8111df18 <__gedf2>
8111d458:	1000080e 	bge	r2,zero,8111d47c <__fixunsdfsi+0x50>
8111d45c:	8809883a 	mov	r4,r17
8111d460:	800b883a 	mov	r5,r16
8111d464:	111f0180 	call	8111f018 <__fixdfsi>
8111d468:	dfc00217 	ldw	ra,8(sp)
8111d46c:	dc400117 	ldw	r17,4(sp)
8111d470:	dc000017 	ldw	r16,0(sp)
8111d474:	dec00304 	addi	sp,sp,12
8111d478:	f800283a 	ret
8111d47c:	000d883a 	mov	r6,zero
8111d480:	01d07834 	movhi	r7,16864
8111d484:	8809883a 	mov	r4,r17
8111d488:	800b883a 	mov	r5,r16
8111d48c:	111e7140 	call	8111e714 <__subdf3>
8111d490:	180b883a 	mov	r5,r3
8111d494:	1009883a 	mov	r4,r2
8111d498:	111f0180 	call	8111f018 <__fixdfsi>
8111d49c:	00e00034 	movhi	r3,32768
8111d4a0:	10c5883a 	add	r2,r2,r3
8111d4a4:	003ff006 	br	8111d468 <__reset+0xfb0fd468>

8111d4a8 <__divsf3>:
8111d4a8:	defff504 	addi	sp,sp,-44
8111d4ac:	200cd5fa 	srli	r6,r4,23
8111d4b0:	de00012e 	bgeu	sp,et,8111d4b8 <__divsf3+0x10>
8111d4b4:	003b68fa 	trap	3
8111d4b8:	dcc00415 	stw	r19,16(sp)
8111d4bc:	2026d7fa 	srli	r19,r4,31
8111d4c0:	00c02034 	movhi	r3,128
8111d4c4:	dd800715 	stw	r22,28(sp)
8111d4c8:	dd000515 	stw	r20,20(sp)
8111d4cc:	dc800315 	stw	r18,12(sp)
8111d4d0:	18ffffc4 	addi	r3,r3,-1
8111d4d4:	dfc00a15 	stw	ra,40(sp)
8111d4d8:	df000915 	stw	fp,36(sp)
8111d4dc:	ddc00815 	stw	r23,32(sp)
8111d4e0:	dd400615 	stw	r21,24(sp)
8111d4e4:	dc400215 	stw	r17,8(sp)
8111d4e8:	dc000115 	stw	r16,4(sp)
8111d4ec:	35003fcc 	andi	r20,r6,255
8111d4f0:	1924703a 	and	r18,r3,r4
8111d4f4:	9d803fcc 	andi	r22,r19,255
8111d4f8:	a0005226 	beq	r20,zero,8111d644 <__divsf3+0x19c>
8111d4fc:	00803fc4 	movi	r2,255
8111d500:	a0802e26 	beq	r20,r2,8111d5bc <__divsf3+0x114>
8111d504:	91002034 	orhi	r4,r18,128
8111d508:	202490fa 	slli	r18,r4,3
8111d50c:	a53fe044 	addi	r20,r20,-127
8111d510:	0021883a 	mov	r16,zero
8111d514:	002f883a 	mov	r23,zero
8111d518:	280cd5fa 	srli	r6,r5,23
8111d51c:	282ad7fa 	srli	r21,r5,31
8111d520:	00c02034 	movhi	r3,128
8111d524:	18ffffc4 	addi	r3,r3,-1
8111d528:	31803fcc 	andi	r6,r6,255
8111d52c:	1962703a 	and	r17,r3,r5
8111d530:	af003fcc 	andi	fp,r21,255
8111d534:	30004a26 	beq	r6,zero,8111d660 <__divsf3+0x1b8>
8111d538:	00803fc4 	movi	r2,255
8111d53c:	30804526 	beq	r6,r2,8111d654 <__divsf3+0x1ac>
8111d540:	89402034 	orhi	r5,r17,128
8111d544:	282290fa 	slli	r17,r5,3
8111d548:	31bfe044 	addi	r6,r6,-127
8111d54c:	000b883a 	mov	r5,zero
8111d550:	2c20b03a 	or	r16,r5,r16
8111d554:	802090ba 	slli	r16,r16,2
8111d558:	00a044b4 	movhi	r2,33042
8111d55c:	10b55f04 	addi	r2,r2,-10884
8111d560:	80a1883a 	add	r16,r16,r2
8111d564:	81000017 	ldw	r4,0(r16)
8111d568:	9d46f03a 	xor	r3,r19,r21
8111d56c:	180f883a 	mov	r7,r3
8111d570:	18803fcc 	andi	r2,r3,255
8111d574:	a18dc83a 	sub	r6,r20,r6
8111d578:	2000683a 	jmp	r4
8111d57c:	8111d760 	cmpeqi	r4,r16,18269
8111d580:	8111d5e4 	muli	r4,r16,18263
8111d584:	8111d754 	ori	r4,r16,18269
8111d588:	8111d5d0 	cmplti	r4,r16,18263
8111d58c:	8111d754 	ori	r4,r16,18269
8111d590:	8111d72c 	andhi	r4,r16,18268
8111d594:	8111d754 	ori	r4,r16,18269
8111d598:	8111d5d0 	cmplti	r4,r16,18263
8111d59c:	8111d5e4 	muli	r4,r16,18263
8111d5a0:	8111d5e4 	muli	r4,r16,18263
8111d5a4:	8111d72c 	andhi	r4,r16,18268
8111d5a8:	8111d5d0 	cmplti	r4,r16,18263
8111d5ac:	8111d840 	call	88111d84 <__reset+0x20f1d84>
8111d5b0:	8111d840 	call	88111d84 <__reset+0x20f1d84>
8111d5b4:	8111d840 	call	88111d84 <__reset+0x20f1d84>
8111d5b8:	8111d7f4 	orhi	r4,r16,18271
8111d5bc:	9000581e 	bne	r18,zero,8111d720 <__divsf3+0x278>
8111d5c0:	04000204 	movi	r16,8
8111d5c4:	05c00084 	movi	r23,2
8111d5c8:	003fd306 	br	8111d518 <__reset+0xfb0fd518>
8111d5cc:	0023883a 	mov	r17,zero
8111d5d0:	e02d883a 	mov	r22,fp
8111d5d4:	282f883a 	mov	r23,r5
8111d5d8:	00800084 	movi	r2,2
8111d5dc:	b8808f1e 	bne	r23,r2,8111d81c <__divsf3+0x374>
8111d5e0:	b005883a 	mov	r2,r22
8111d5e4:	11c0004c 	andi	r7,r2,1
8111d5e8:	013fffc4 	movi	r4,-1
8111d5ec:	000d883a 	mov	r6,zero
8111d5f0:	21003fcc 	andi	r4,r4,255
8111d5f4:	200895fa 	slli	r4,r4,23
8111d5f8:	38803fcc 	andi	r2,r7,255
8111d5fc:	00c02034 	movhi	r3,128
8111d600:	100497fa 	slli	r2,r2,31
8111d604:	18ffffc4 	addi	r3,r3,-1
8111d608:	30c6703a 	and	r3,r6,r3
8111d60c:	1906b03a 	or	r3,r3,r4
8111d610:	1884b03a 	or	r2,r3,r2
8111d614:	dfc00a17 	ldw	ra,40(sp)
8111d618:	df000917 	ldw	fp,36(sp)
8111d61c:	ddc00817 	ldw	r23,32(sp)
8111d620:	dd800717 	ldw	r22,28(sp)
8111d624:	dd400617 	ldw	r21,24(sp)
8111d628:	dd000517 	ldw	r20,20(sp)
8111d62c:	dcc00417 	ldw	r19,16(sp)
8111d630:	dc800317 	ldw	r18,12(sp)
8111d634:	dc400217 	ldw	r17,8(sp)
8111d638:	dc000117 	ldw	r16,4(sp)
8111d63c:	dec00b04 	addi	sp,sp,44
8111d640:	f800283a 	ret
8111d644:	90002b1e 	bne	r18,zero,8111d6f4 <__divsf3+0x24c>
8111d648:	04000104 	movi	r16,4
8111d64c:	05c00044 	movi	r23,1
8111d650:	003fb106 	br	8111d518 <__reset+0xfb0fd518>
8111d654:	8800251e 	bne	r17,zero,8111d6ec <__divsf3+0x244>
8111d658:	01400084 	movi	r5,2
8111d65c:	00000206 	br	8111d668 <__divsf3+0x1c0>
8111d660:	88001a1e 	bne	r17,zero,8111d6cc <__divsf3+0x224>
8111d664:	01400044 	movi	r5,1
8111d668:	8160b03a 	or	r16,r16,r5
8111d66c:	802090ba 	slli	r16,r16,2
8111d670:	00e044b4 	movhi	r3,33042
8111d674:	18f5a304 	addi	r3,r3,-10612
8111d678:	80e1883a 	add	r16,r16,r3
8111d67c:	80c00017 	ldw	r3,0(r16)
8111d680:	9d44f03a 	xor	r2,r19,r21
8111d684:	a18dc83a 	sub	r6,r20,r6
8111d688:	1800683a 	jmp	r3
8111d68c:	8111d5e4 	muli	r4,r16,18263
8111d690:	8111d5e4 	muli	r4,r16,18263
8111d694:	8111d830 	cmpltui	r4,r16,18272
8111d698:	8111d5cc 	andi	r4,r16,18263
8111d69c:	8111d830 	cmpltui	r4,r16,18272
8111d6a0:	8111d72c 	andhi	r4,r16,18268
8111d6a4:	8111d830 	cmpltui	r4,r16,18272
8111d6a8:	8111d5cc 	andi	r4,r16,18263
8111d6ac:	8111d5e4 	muli	r4,r16,18263
8111d6b0:	8111d5e4 	muli	r4,r16,18263
8111d6b4:	8111d72c 	andhi	r4,r16,18268
8111d6b8:	8111d5cc 	andi	r4,r16,18263
8111d6bc:	8111d840 	call	88111d84 <__reset+0x20f1d84>
8111d6c0:	8111d840 	call	88111d84 <__reset+0x20f1d84>
8111d6c4:	8111d840 	call	88111d84 <__reset+0x20f1d84>
8111d6c8:	8111d858 	cmpnei	r4,r16,18273
8111d6cc:	8809883a 	mov	r4,r17
8111d6d0:	111f43c0 	call	8111f43c <__clzsi2>
8111d6d4:	10fffec4 	addi	r3,r2,-5
8111d6d8:	10801d84 	addi	r2,r2,118
8111d6dc:	88e2983a 	sll	r17,r17,r3
8111d6e0:	008dc83a 	sub	r6,zero,r2
8111d6e4:	000b883a 	mov	r5,zero
8111d6e8:	003f9906 	br	8111d550 <__reset+0xfb0fd550>
8111d6ec:	014000c4 	movi	r5,3
8111d6f0:	003f9706 	br	8111d550 <__reset+0xfb0fd550>
8111d6f4:	9009883a 	mov	r4,r18
8111d6f8:	d9400015 	stw	r5,0(sp)
8111d6fc:	111f43c0 	call	8111f43c <__clzsi2>
8111d700:	10fffec4 	addi	r3,r2,-5
8111d704:	11801d84 	addi	r6,r2,118
8111d708:	90e4983a 	sll	r18,r18,r3
8111d70c:	01a9c83a 	sub	r20,zero,r6
8111d710:	0021883a 	mov	r16,zero
8111d714:	002f883a 	mov	r23,zero
8111d718:	d9400017 	ldw	r5,0(sp)
8111d71c:	003f7e06 	br	8111d518 <__reset+0xfb0fd518>
8111d720:	04000304 	movi	r16,12
8111d724:	05c000c4 	movi	r23,3
8111d728:	003f7b06 	br	8111d518 <__reset+0xfb0fd518>
8111d72c:	01802034 	movhi	r6,128
8111d730:	000f883a 	mov	r7,zero
8111d734:	31bfffc4 	addi	r6,r6,-1
8111d738:	013fffc4 	movi	r4,-1
8111d73c:	003fac06 	br	8111d5f0 <__reset+0xfb0fd5f0>
8111d740:	01400044 	movi	r5,1
8111d744:	2909c83a 	sub	r4,r5,r4
8111d748:	00c006c4 	movi	r3,27
8111d74c:	19004b0e 	bge	r3,r4,8111d87c <__divsf3+0x3d4>
8111d750:	114e703a 	and	r7,r2,r5
8111d754:	0009883a 	mov	r4,zero
8111d758:	000d883a 	mov	r6,zero
8111d75c:	003fa406 	br	8111d5f0 <__reset+0xfb0fd5f0>
8111d760:	9006917a 	slli	r3,r18,5
8111d764:	8822917a 	slli	r17,r17,5
8111d768:	1c40372e 	bgeu	r3,r17,8111d848 <__divsf3+0x3a0>
8111d76c:	31bfffc4 	addi	r6,r6,-1
8111d770:	010006c4 	movi	r4,27
8111d774:	000b883a 	mov	r5,zero
8111d778:	180f883a 	mov	r7,r3
8111d77c:	294b883a 	add	r5,r5,r5
8111d780:	18c7883a 	add	r3,r3,r3
8111d784:	38000116 	blt	r7,zero,8111d78c <__divsf3+0x2e4>
8111d788:	1c400236 	bltu	r3,r17,8111d794 <__divsf3+0x2ec>
8111d78c:	1c47c83a 	sub	r3,r3,r17
8111d790:	29400054 	ori	r5,r5,1
8111d794:	213fffc4 	addi	r4,r4,-1
8111d798:	203ff71e 	bne	r4,zero,8111d778 <__reset+0xfb0fd778>
8111d79c:	1806c03a 	cmpne	r3,r3,zero
8111d7a0:	1962b03a 	or	r17,r3,r5
8111d7a4:	31001fc4 	addi	r4,r6,127
8111d7a8:	013fe50e 	bge	zero,r4,8111d740 <__reset+0xfb0fd740>
8111d7ac:	88c001cc 	andi	r3,r17,7
8111d7b0:	18000426 	beq	r3,zero,8111d7c4 <__divsf3+0x31c>
8111d7b4:	88c003cc 	andi	r3,r17,15
8111d7b8:	01400104 	movi	r5,4
8111d7bc:	19400126 	beq	r3,r5,8111d7c4 <__divsf3+0x31c>
8111d7c0:	8963883a 	add	r17,r17,r5
8111d7c4:	88c2002c 	andhi	r3,r17,2048
8111d7c8:	18000426 	beq	r3,zero,8111d7dc <__divsf3+0x334>
8111d7cc:	00fe0034 	movhi	r3,63488
8111d7d0:	18ffffc4 	addi	r3,r3,-1
8111d7d4:	31002004 	addi	r4,r6,128
8111d7d8:	88e2703a 	and	r17,r17,r3
8111d7dc:	00c03f84 	movi	r3,254
8111d7e0:	193f8016 	blt	r3,r4,8111d5e4 <__reset+0xfb0fd5e4>
8111d7e4:	880c91ba 	slli	r6,r17,6
8111d7e8:	11c0004c 	andi	r7,r2,1
8111d7ec:	300cd27a 	srli	r6,r6,9
8111d7f0:	003f7f06 	br	8111d5f0 <__reset+0xfb0fd5f0>
8111d7f4:	9080102c 	andhi	r2,r18,64
8111d7f8:	10000226 	beq	r2,zero,8111d804 <__divsf3+0x35c>
8111d7fc:	8880102c 	andhi	r2,r17,64
8111d800:	10001826 	beq	r2,zero,8111d864 <__divsf3+0x3bc>
8111d804:	00802034 	movhi	r2,128
8111d808:	91801034 	orhi	r6,r18,64
8111d80c:	10bfffc4 	addi	r2,r2,-1
8111d810:	980f883a 	mov	r7,r19
8111d814:	308c703a 	and	r6,r6,r2
8111d818:	003fc706 	br	8111d738 <__reset+0xfb0fd738>
8111d81c:	008000c4 	movi	r2,3
8111d820:	b8802d26 	beq	r23,r2,8111d8d8 <__divsf3+0x430>
8111d824:	00c00044 	movi	r3,1
8111d828:	b005883a 	mov	r2,r22
8111d82c:	b8ffdd1e 	bne	r23,r3,8111d7a4 <__reset+0xfb0fd7a4>
8111d830:	11c0004c 	andi	r7,r2,1
8111d834:	0009883a 	mov	r4,zero
8111d838:	000d883a 	mov	r6,zero
8111d83c:	003f6c06 	br	8111d5f0 <__reset+0xfb0fd5f0>
8111d840:	9023883a 	mov	r17,r18
8111d844:	003f6406 	br	8111d5d8 <__reset+0xfb0fd5d8>
8111d848:	1c47c83a 	sub	r3,r3,r17
8111d84c:	01000684 	movi	r4,26
8111d850:	01400044 	movi	r5,1
8111d854:	003fc806 	br	8111d778 <__reset+0xfb0fd778>
8111d858:	9080102c 	andhi	r2,r18,64
8111d85c:	103fe926 	beq	r2,zero,8111d804 <__reset+0xfb0fd804>
8111d860:	0023883a 	mov	r17,zero
8111d864:	00802034 	movhi	r2,128
8111d868:	89801034 	orhi	r6,r17,64
8111d86c:	10bfffc4 	addi	r2,r2,-1
8111d870:	a80f883a 	mov	r7,r21
8111d874:	308c703a 	and	r6,r6,r2
8111d878:	003faf06 	br	8111d738 <__reset+0xfb0fd738>
8111d87c:	01c00804 	movi	r7,32
8111d880:	390fc83a 	sub	r7,r7,r4
8111d884:	89ce983a 	sll	r7,r17,r7
8111d888:	890ad83a 	srl	r5,r17,r4
8111d88c:	380ec03a 	cmpne	r7,r7,zero
8111d890:	29cab03a 	or	r5,r5,r7
8111d894:	28c001cc 	andi	r3,r5,7
8111d898:	18000426 	beq	r3,zero,8111d8ac <__divsf3+0x404>
8111d89c:	28c003cc 	andi	r3,r5,15
8111d8a0:	01000104 	movi	r4,4
8111d8a4:	19000126 	beq	r3,r4,8111d8ac <__divsf3+0x404>
8111d8a8:	290b883a 	add	r5,r5,r4
8111d8ac:	28c1002c 	andhi	r3,r5,1024
8111d8b0:	18000426 	beq	r3,zero,8111d8c4 <__divsf3+0x41c>
8111d8b4:	11c0004c 	andi	r7,r2,1
8111d8b8:	01000044 	movi	r4,1
8111d8bc:	000d883a 	mov	r6,zero
8111d8c0:	003f4b06 	br	8111d5f0 <__reset+0xfb0fd5f0>
8111d8c4:	280a91ba 	slli	r5,r5,6
8111d8c8:	11c0004c 	andi	r7,r2,1
8111d8cc:	0009883a 	mov	r4,zero
8111d8d0:	280cd27a 	srli	r6,r5,9
8111d8d4:	003f4606 	br	8111d5f0 <__reset+0xfb0fd5f0>
8111d8d8:	00802034 	movhi	r2,128
8111d8dc:	89801034 	orhi	r6,r17,64
8111d8e0:	10bfffc4 	addi	r2,r2,-1
8111d8e4:	b00f883a 	mov	r7,r22
8111d8e8:	308c703a 	and	r6,r6,r2
8111d8ec:	003f9206 	br	8111d738 <__reset+0xfb0fd738>

8111d8f0 <__mulsf3>:
8111d8f0:	defff504 	addi	sp,sp,-44
8111d8f4:	de00012e 	bgeu	sp,et,8111d8fc <__mulsf3+0xc>
8111d8f8:	003b68fa 	trap	3
8111d8fc:	dc000115 	stw	r16,4(sp)
8111d900:	2020d5fa 	srli	r16,r4,23
8111d904:	dd400615 	stw	r21,24(sp)
8111d908:	202ad7fa 	srli	r21,r4,31
8111d90c:	dc800315 	stw	r18,12(sp)
8111d910:	04802034 	movhi	r18,128
8111d914:	df000915 	stw	fp,36(sp)
8111d918:	dd000515 	stw	r20,20(sp)
8111d91c:	94bfffc4 	addi	r18,r18,-1
8111d920:	dfc00a15 	stw	ra,40(sp)
8111d924:	ddc00815 	stw	r23,32(sp)
8111d928:	dd800715 	stw	r22,28(sp)
8111d92c:	dcc00415 	stw	r19,16(sp)
8111d930:	dc400215 	stw	r17,8(sp)
8111d934:	84003fcc 	andi	r16,r16,255
8111d938:	9124703a 	and	r18,r18,r4
8111d93c:	a829883a 	mov	r20,r21
8111d940:	af003fcc 	andi	fp,r21,255
8111d944:	80005426 	beq	r16,zero,8111da98 <__mulsf3+0x1a8>
8111d948:	00803fc4 	movi	r2,255
8111d94c:	80802f26 	beq	r16,r2,8111da0c <__mulsf3+0x11c>
8111d950:	91002034 	orhi	r4,r18,128
8111d954:	202490fa 	slli	r18,r4,3
8111d958:	843fe044 	addi	r16,r16,-127
8111d95c:	0023883a 	mov	r17,zero
8111d960:	002f883a 	mov	r23,zero
8111d964:	2804d5fa 	srli	r2,r5,23
8111d968:	282cd7fa 	srli	r22,r5,31
8111d96c:	01002034 	movhi	r4,128
8111d970:	213fffc4 	addi	r4,r4,-1
8111d974:	10803fcc 	andi	r2,r2,255
8111d978:	2166703a 	and	r19,r4,r5
8111d97c:	b1803fcc 	andi	r6,r22,255
8111d980:	10004c26 	beq	r2,zero,8111dab4 <__mulsf3+0x1c4>
8111d984:	00c03fc4 	movi	r3,255
8111d988:	10c04726 	beq	r2,r3,8111daa8 <__mulsf3+0x1b8>
8111d98c:	99002034 	orhi	r4,r19,128
8111d990:	202690fa 	slli	r19,r4,3
8111d994:	10bfe044 	addi	r2,r2,-127
8111d998:	0007883a 	mov	r3,zero
8111d99c:	80a1883a 	add	r16,r16,r2
8111d9a0:	010003c4 	movi	r4,15
8111d9a4:	1c44b03a 	or	r2,r3,r17
8111d9a8:	b56af03a 	xor	r21,r22,r21
8111d9ac:	81c00044 	addi	r7,r16,1
8111d9b0:	20806b36 	bltu	r4,r2,8111db60 <__mulsf3+0x270>
8111d9b4:	100490ba 	slli	r2,r2,2
8111d9b8:	012044b4 	movhi	r4,33042
8111d9bc:	21367304 	addi	r4,r4,-9780
8111d9c0:	1105883a 	add	r2,r2,r4
8111d9c4:	10800017 	ldw	r2,0(r2)
8111d9c8:	1000683a 	jmp	r2
8111d9cc:	8111db60 	cmpeqi	r4,r16,18285
8111d9d0:	8111da20 	cmpeqi	r4,r16,18280
8111d9d4:	8111da20 	cmpeqi	r4,r16,18280
8111d9d8:	8111da1c 	xori	r4,r16,18280
8111d9dc:	8111db44 	addi	r4,r16,18285
8111d9e0:	8111db44 	addi	r4,r16,18285
8111d9e4:	8111db30 	cmpltui	r4,r16,18284
8111d9e8:	8111da1c 	xori	r4,r16,18280
8111d9ec:	8111db44 	addi	r4,r16,18285
8111d9f0:	8111db30 	cmpltui	r4,r16,18284
8111d9f4:	8111db44 	addi	r4,r16,18285
8111d9f8:	8111da1c 	xori	r4,r16,18280
8111d9fc:	8111db50 	cmplti	r4,r16,18285
8111da00:	8111db50 	cmplti	r4,r16,18285
8111da04:	8111db50 	cmplti	r4,r16,18285
8111da08:	8111dc2c 	andhi	r4,r16,18288
8111da0c:	90003b1e 	bne	r18,zero,8111dafc <__mulsf3+0x20c>
8111da10:	04400204 	movi	r17,8
8111da14:	05c00084 	movi	r23,2
8111da18:	003fd206 	br	8111d964 <__reset+0xfb0fd964>
8111da1c:	302b883a 	mov	r21,r6
8111da20:	00800084 	movi	r2,2
8111da24:	18802626 	beq	r3,r2,8111dac0 <__mulsf3+0x1d0>
8111da28:	008000c4 	movi	r2,3
8111da2c:	1880ab26 	beq	r3,r2,8111dcdc <__mulsf3+0x3ec>
8111da30:	00800044 	movi	r2,1
8111da34:	1880a21e 	bne	r3,r2,8111dcc0 <__mulsf3+0x3d0>
8111da38:	a829883a 	mov	r20,r21
8111da3c:	0007883a 	mov	r3,zero
8111da40:	0009883a 	mov	r4,zero
8111da44:	18803fcc 	andi	r2,r3,255
8111da48:	100695fa 	slli	r3,r2,23
8111da4c:	a0803fcc 	andi	r2,r20,255
8111da50:	100a97fa 	slli	r5,r2,31
8111da54:	00802034 	movhi	r2,128
8111da58:	10bfffc4 	addi	r2,r2,-1
8111da5c:	2084703a 	and	r2,r4,r2
8111da60:	10c4b03a 	or	r2,r2,r3
8111da64:	1144b03a 	or	r2,r2,r5
8111da68:	dfc00a17 	ldw	ra,40(sp)
8111da6c:	df000917 	ldw	fp,36(sp)
8111da70:	ddc00817 	ldw	r23,32(sp)
8111da74:	dd800717 	ldw	r22,28(sp)
8111da78:	dd400617 	ldw	r21,24(sp)
8111da7c:	dd000517 	ldw	r20,20(sp)
8111da80:	dcc00417 	ldw	r19,16(sp)
8111da84:	dc800317 	ldw	r18,12(sp)
8111da88:	dc400217 	ldw	r17,8(sp)
8111da8c:	dc000117 	ldw	r16,4(sp)
8111da90:	dec00b04 	addi	sp,sp,44
8111da94:	f800283a 	ret
8111da98:	90000d1e 	bne	r18,zero,8111dad0 <__mulsf3+0x1e0>
8111da9c:	04400104 	movi	r17,4
8111daa0:	05c00044 	movi	r23,1
8111daa4:	003faf06 	br	8111d964 <__reset+0xfb0fd964>
8111daa8:	9806c03a 	cmpne	r3,r19,zero
8111daac:	18c00084 	addi	r3,r3,2
8111dab0:	003fba06 	br	8111d99c <__reset+0xfb0fd99c>
8111dab4:	9800141e 	bne	r19,zero,8111db08 <__mulsf3+0x218>
8111dab8:	00c00044 	movi	r3,1
8111dabc:	003fb706 	br	8111d99c <__reset+0xfb0fd99c>
8111dac0:	a829883a 	mov	r20,r21
8111dac4:	00ffffc4 	movi	r3,-1
8111dac8:	0009883a 	mov	r4,zero
8111dacc:	003fdd06 	br	8111da44 <__reset+0xfb0fda44>
8111dad0:	9009883a 	mov	r4,r18
8111dad4:	d9400015 	stw	r5,0(sp)
8111dad8:	111f43c0 	call	8111f43c <__clzsi2>
8111dadc:	10fffec4 	addi	r3,r2,-5
8111dae0:	10801d84 	addi	r2,r2,118
8111dae4:	90e4983a 	sll	r18,r18,r3
8111dae8:	00a1c83a 	sub	r16,zero,r2
8111daec:	0023883a 	mov	r17,zero
8111daf0:	002f883a 	mov	r23,zero
8111daf4:	d9400017 	ldw	r5,0(sp)
8111daf8:	003f9a06 	br	8111d964 <__reset+0xfb0fd964>
8111dafc:	04400304 	movi	r17,12
8111db00:	05c000c4 	movi	r23,3
8111db04:	003f9706 	br	8111d964 <__reset+0xfb0fd964>
8111db08:	9809883a 	mov	r4,r19
8111db0c:	d9800015 	stw	r6,0(sp)
8111db10:	111f43c0 	call	8111f43c <__clzsi2>
8111db14:	10fffec4 	addi	r3,r2,-5
8111db18:	10801d84 	addi	r2,r2,118
8111db1c:	98e6983a 	sll	r19,r19,r3
8111db20:	0085c83a 	sub	r2,zero,r2
8111db24:	0007883a 	mov	r3,zero
8111db28:	d9800017 	ldw	r6,0(sp)
8111db2c:	003f9b06 	br	8111d99c <__reset+0xfb0fd99c>
8111db30:	01002034 	movhi	r4,128
8111db34:	0029883a 	mov	r20,zero
8111db38:	213fffc4 	addi	r4,r4,-1
8111db3c:	00ffffc4 	movi	r3,-1
8111db40:	003fc006 	br	8111da44 <__reset+0xfb0fda44>
8111db44:	9027883a 	mov	r19,r18
8111db48:	b807883a 	mov	r3,r23
8111db4c:	003fb406 	br	8111da20 <__reset+0xfb0fda20>
8111db50:	9027883a 	mov	r19,r18
8111db54:	e02b883a 	mov	r21,fp
8111db58:	b807883a 	mov	r3,r23
8111db5c:	003fb006 	br	8111da20 <__reset+0xfb0fda20>
8111db60:	9004d43a 	srli	r2,r18,16
8111db64:	9810d43a 	srli	r8,r19,16
8111db68:	94bfffcc 	andi	r18,r18,65535
8111db6c:	993fffcc 	andi	r4,r19,65535
8111db70:	910d383a 	mul	r6,r18,r4
8111db74:	20a7383a 	mul	r19,r4,r2
8111db78:	9225383a 	mul	r18,r18,r8
8111db7c:	3006d43a 	srli	r3,r6,16
8111db80:	1211383a 	mul	r8,r2,r8
8111db84:	94e5883a 	add	r18,r18,r19
8111db88:	1c87883a 	add	r3,r3,r18
8111db8c:	1cc0022e 	bgeu	r3,r19,8111db98 <__mulsf3+0x2a8>
8111db90:	00800074 	movhi	r2,1
8111db94:	4091883a 	add	r8,r8,r2
8111db98:	1804943a 	slli	r2,r3,16
8111db9c:	31bfffcc 	andi	r6,r6,65535
8111dba0:	1806d43a 	srli	r3,r3,16
8111dba4:	1185883a 	add	r2,r2,r6
8111dba8:	102691ba 	slli	r19,r2,6
8111dbac:	1a07883a 	add	r3,r3,r8
8111dbb0:	1004d6ba 	srli	r2,r2,26
8111dbb4:	180891ba 	slli	r4,r3,6
8111dbb8:	9826c03a 	cmpne	r19,r19,zero
8111dbbc:	9884b03a 	or	r2,r19,r2
8111dbc0:	1126b03a 	or	r19,r2,r4
8111dbc4:	9882002c 	andhi	r2,r19,2048
8111dbc8:	10000426 	beq	r2,zero,8111dbdc <__mulsf3+0x2ec>
8111dbcc:	9804d07a 	srli	r2,r19,1
8111dbd0:	9900004c 	andi	r4,r19,1
8111dbd4:	3821883a 	mov	r16,r7
8111dbd8:	1126b03a 	or	r19,r2,r4
8111dbdc:	80c01fc4 	addi	r3,r16,127
8111dbe0:	00c0210e 	bge	zero,r3,8111dc68 <__mulsf3+0x378>
8111dbe4:	988001cc 	andi	r2,r19,7
8111dbe8:	10000426 	beq	r2,zero,8111dbfc <__mulsf3+0x30c>
8111dbec:	988003cc 	andi	r2,r19,15
8111dbf0:	01000104 	movi	r4,4
8111dbf4:	11000126 	beq	r2,r4,8111dbfc <__mulsf3+0x30c>
8111dbf8:	9927883a 	add	r19,r19,r4
8111dbfc:	9882002c 	andhi	r2,r19,2048
8111dc00:	10000426 	beq	r2,zero,8111dc14 <__mulsf3+0x324>
8111dc04:	00be0034 	movhi	r2,63488
8111dc08:	10bfffc4 	addi	r2,r2,-1
8111dc0c:	80c02004 	addi	r3,r16,128
8111dc10:	98a6703a 	and	r19,r19,r2
8111dc14:	00803f84 	movi	r2,254
8111dc18:	10ffa916 	blt	r2,r3,8111dac0 <__reset+0xfb0fdac0>
8111dc1c:	980891ba 	slli	r4,r19,6
8111dc20:	a829883a 	mov	r20,r21
8111dc24:	2008d27a 	srli	r4,r4,9
8111dc28:	003f8606 	br	8111da44 <__reset+0xfb0fda44>
8111dc2c:	9080102c 	andhi	r2,r18,64
8111dc30:	10000826 	beq	r2,zero,8111dc54 <__mulsf3+0x364>
8111dc34:	9880102c 	andhi	r2,r19,64
8111dc38:	1000061e 	bne	r2,zero,8111dc54 <__mulsf3+0x364>
8111dc3c:	00802034 	movhi	r2,128
8111dc40:	99001034 	orhi	r4,r19,64
8111dc44:	10bfffc4 	addi	r2,r2,-1
8111dc48:	b029883a 	mov	r20,r22
8111dc4c:	2088703a 	and	r4,r4,r2
8111dc50:	003fba06 	br	8111db3c <__reset+0xfb0fdb3c>
8111dc54:	00802034 	movhi	r2,128
8111dc58:	91001034 	orhi	r4,r18,64
8111dc5c:	10bfffc4 	addi	r2,r2,-1
8111dc60:	2088703a 	and	r4,r4,r2
8111dc64:	003fb506 	br	8111db3c <__reset+0xfb0fdb3c>
8111dc68:	00800044 	movi	r2,1
8111dc6c:	10c7c83a 	sub	r3,r2,r3
8111dc70:	008006c4 	movi	r2,27
8111dc74:	10ff7016 	blt	r2,r3,8111da38 <__reset+0xfb0fda38>
8111dc78:	00800804 	movi	r2,32
8111dc7c:	10c5c83a 	sub	r2,r2,r3
8111dc80:	9884983a 	sll	r2,r19,r2
8111dc84:	98c6d83a 	srl	r3,r19,r3
8111dc88:	1004c03a 	cmpne	r2,r2,zero
8111dc8c:	1884b03a 	or	r2,r3,r2
8111dc90:	10c001cc 	andi	r3,r2,7
8111dc94:	18000426 	beq	r3,zero,8111dca8 <__mulsf3+0x3b8>
8111dc98:	10c003cc 	andi	r3,r2,15
8111dc9c:	01000104 	movi	r4,4
8111dca0:	19000126 	beq	r3,r4,8111dca8 <__mulsf3+0x3b8>
8111dca4:	1105883a 	add	r2,r2,r4
8111dca8:	10c1002c 	andhi	r3,r2,1024
8111dcac:	18000626 	beq	r3,zero,8111dcc8 <__mulsf3+0x3d8>
8111dcb0:	a829883a 	mov	r20,r21
8111dcb4:	00c00044 	movi	r3,1
8111dcb8:	0009883a 	mov	r4,zero
8111dcbc:	003f6106 	br	8111da44 <__reset+0xfb0fda44>
8111dcc0:	3821883a 	mov	r16,r7
8111dcc4:	003fc506 	br	8111dbdc <__reset+0xfb0fdbdc>
8111dcc8:	100491ba 	slli	r2,r2,6
8111dccc:	a829883a 	mov	r20,r21
8111dcd0:	0007883a 	mov	r3,zero
8111dcd4:	1008d27a 	srli	r4,r2,9
8111dcd8:	003f5a06 	br	8111da44 <__reset+0xfb0fda44>
8111dcdc:	00802034 	movhi	r2,128
8111dce0:	99001034 	orhi	r4,r19,64
8111dce4:	10bfffc4 	addi	r2,r2,-1
8111dce8:	a829883a 	mov	r20,r21
8111dcec:	2088703a 	and	r4,r4,r2
8111dcf0:	003f9206 	br	8111db3c <__reset+0xfb0fdb3c>

8111dcf4 <__floatsisf>:
8111dcf4:	defffd04 	addi	sp,sp,-12
8111dcf8:	de00012e 	bgeu	sp,et,8111dd00 <__floatsisf+0xc>
8111dcfc:	003b68fa 	trap	3
8111dd00:	dfc00215 	stw	ra,8(sp)
8111dd04:	dc400115 	stw	r17,4(sp)
8111dd08:	dc000015 	stw	r16,0(sp)
8111dd0c:	20003526 	beq	r4,zero,8111dde4 <__floatsisf+0xf0>
8111dd10:	2021883a 	mov	r16,r4
8111dd14:	2022d7fa 	srli	r17,r4,31
8111dd18:	20003616 	blt	r4,zero,8111ddf4 <__floatsisf+0x100>
8111dd1c:	8009883a 	mov	r4,r16
8111dd20:	111f43c0 	call	8111f43c <__clzsi2>
8111dd24:	00c02784 	movi	r3,158
8111dd28:	1887c83a 	sub	r3,r3,r2
8111dd2c:	01002584 	movi	r4,150
8111dd30:	20c01416 	blt	r4,r3,8111dd84 <__floatsisf+0x90>
8111dd34:	20c9c83a 	sub	r4,r4,r3
8111dd38:	8120983a 	sll	r16,r16,r4
8111dd3c:	00802034 	movhi	r2,128
8111dd40:	10bfffc4 	addi	r2,r2,-1
8111dd44:	8809883a 	mov	r4,r17
8111dd48:	80a0703a 	and	r16,r16,r2
8111dd4c:	18803fcc 	andi	r2,r3,255
8111dd50:	100695fa 	slli	r3,r2,23
8111dd54:	20803fcc 	andi	r2,r4,255
8111dd58:	100897fa 	slli	r4,r2,31
8111dd5c:	00802034 	movhi	r2,128
8111dd60:	10bfffc4 	addi	r2,r2,-1
8111dd64:	8084703a 	and	r2,r16,r2
8111dd68:	10c4b03a 	or	r2,r2,r3
8111dd6c:	1104b03a 	or	r2,r2,r4
8111dd70:	dfc00217 	ldw	ra,8(sp)
8111dd74:	dc400117 	ldw	r17,4(sp)
8111dd78:	dc000017 	ldw	r16,0(sp)
8111dd7c:	dec00304 	addi	sp,sp,12
8111dd80:	f800283a 	ret
8111dd84:	01002644 	movi	r4,153
8111dd88:	20c01c16 	blt	r4,r3,8111ddfc <__floatsisf+0x108>
8111dd8c:	20c9c83a 	sub	r4,r4,r3
8111dd90:	8120983a 	sll	r16,r16,r4
8111dd94:	013f0034 	movhi	r4,64512
8111dd98:	213fffc4 	addi	r4,r4,-1
8111dd9c:	814001cc 	andi	r5,r16,7
8111dda0:	8108703a 	and	r4,r16,r4
8111dda4:	28000426 	beq	r5,zero,8111ddb8 <__floatsisf+0xc4>
8111dda8:	840003cc 	andi	r16,r16,15
8111ddac:	01400104 	movi	r5,4
8111ddb0:	81400126 	beq	r16,r5,8111ddb8 <__floatsisf+0xc4>
8111ddb4:	2149883a 	add	r4,r4,r5
8111ddb8:	2141002c 	andhi	r5,r4,1024
8111ddbc:	28000526 	beq	r5,zero,8111ddd4 <__floatsisf+0xe0>
8111ddc0:	00c027c4 	movi	r3,159
8111ddc4:	1887c83a 	sub	r3,r3,r2
8111ddc8:	00bf0034 	movhi	r2,64512
8111ddcc:	10bfffc4 	addi	r2,r2,-1
8111ddd0:	2088703a 	and	r4,r4,r2
8111ddd4:	202091ba 	slli	r16,r4,6
8111ddd8:	8809883a 	mov	r4,r17
8111dddc:	8020d27a 	srli	r16,r16,9
8111dde0:	003fda06 	br	8111dd4c <__reset+0xfb0fdd4c>
8111dde4:	0009883a 	mov	r4,zero
8111dde8:	0007883a 	mov	r3,zero
8111ddec:	0021883a 	mov	r16,zero
8111ddf0:	003fd606 	br	8111dd4c <__reset+0xfb0fdd4c>
8111ddf4:	0121c83a 	sub	r16,zero,r4
8111ddf8:	003fc806 	br	8111dd1c <__reset+0xfb0fdd1c>
8111ddfc:	01002e44 	movi	r4,185
8111de00:	20c9c83a 	sub	r4,r4,r3
8111de04:	01400144 	movi	r5,5
8111de08:	8108983a 	sll	r4,r16,r4
8111de0c:	288bc83a 	sub	r5,r5,r2
8111de10:	8160d83a 	srl	r16,r16,r5
8111de14:	2008c03a 	cmpne	r4,r4,zero
8111de18:	8120b03a 	or	r16,r16,r4
8111de1c:	003fdd06 	br	8111dd94 <__reset+0xfb0fdd94>

8111de20 <__floatunsisf>:
8111de20:	defffe04 	addi	sp,sp,-8
8111de24:	de00012e 	bgeu	sp,et,8111de2c <__floatunsisf+0xc>
8111de28:	003b68fa 	trap	3
8111de2c:	dfc00115 	stw	ra,4(sp)
8111de30:	dc000015 	stw	r16,0(sp)
8111de34:	20002c26 	beq	r4,zero,8111dee8 <__floatunsisf+0xc8>
8111de38:	2021883a 	mov	r16,r4
8111de3c:	111f43c0 	call	8111f43c <__clzsi2>
8111de40:	00c02784 	movi	r3,158
8111de44:	1887c83a 	sub	r3,r3,r2
8111de48:	01002584 	movi	r4,150
8111de4c:	20c00f16 	blt	r4,r3,8111de8c <__floatunsisf+0x6c>
8111de50:	20c9c83a 	sub	r4,r4,r3
8111de54:	8108983a 	sll	r4,r16,r4
8111de58:	00802034 	movhi	r2,128
8111de5c:	10bfffc4 	addi	r2,r2,-1
8111de60:	2088703a 	and	r4,r4,r2
8111de64:	18803fcc 	andi	r2,r3,255
8111de68:	100695fa 	slli	r3,r2,23
8111de6c:	00802034 	movhi	r2,128
8111de70:	10bfffc4 	addi	r2,r2,-1
8111de74:	2084703a 	and	r2,r4,r2
8111de78:	10c4b03a 	or	r2,r2,r3
8111de7c:	dfc00117 	ldw	ra,4(sp)
8111de80:	dc000017 	ldw	r16,0(sp)
8111de84:	dec00204 	addi	sp,sp,8
8111de88:	f800283a 	ret
8111de8c:	01002644 	movi	r4,153
8111de90:	20c01816 	blt	r4,r3,8111def4 <__floatunsisf+0xd4>
8111de94:	20c9c83a 	sub	r4,r4,r3
8111de98:	8108983a 	sll	r4,r16,r4
8111de9c:	017f0034 	movhi	r5,64512
8111dea0:	297fffc4 	addi	r5,r5,-1
8111dea4:	218001cc 	andi	r6,r4,7
8111dea8:	214a703a 	and	r5,r4,r5
8111deac:	30000426 	beq	r6,zero,8111dec0 <__floatunsisf+0xa0>
8111deb0:	210003cc 	andi	r4,r4,15
8111deb4:	01800104 	movi	r6,4
8111deb8:	21800126 	beq	r4,r6,8111dec0 <__floatunsisf+0xa0>
8111debc:	298b883a 	add	r5,r5,r6
8111dec0:	2901002c 	andhi	r4,r5,1024
8111dec4:	20000526 	beq	r4,zero,8111dedc <__floatunsisf+0xbc>
8111dec8:	00c027c4 	movi	r3,159
8111decc:	1887c83a 	sub	r3,r3,r2
8111ded0:	00bf0034 	movhi	r2,64512
8111ded4:	10bfffc4 	addi	r2,r2,-1
8111ded8:	288a703a 	and	r5,r5,r2
8111dedc:	280891ba 	slli	r4,r5,6
8111dee0:	2008d27a 	srli	r4,r4,9
8111dee4:	003fdf06 	br	8111de64 <__reset+0xfb0fde64>
8111dee8:	0007883a 	mov	r3,zero
8111deec:	0009883a 	mov	r4,zero
8111def0:	003fdc06 	br	8111de64 <__reset+0xfb0fde64>
8111def4:	01402e44 	movi	r5,185
8111def8:	28cbc83a 	sub	r5,r5,r3
8111defc:	01000144 	movi	r4,5
8111df00:	2089c83a 	sub	r4,r4,r2
8111df04:	814a983a 	sll	r5,r16,r5
8111df08:	8108d83a 	srl	r4,r16,r4
8111df0c:	2820c03a 	cmpne	r16,r5,zero
8111df10:	2408b03a 	or	r4,r4,r16
8111df14:	003fe106 	br	8111de9c <__reset+0xfb0fde9c>

8111df18 <__gedf2>:
8111df18:	2804d53a 	srli	r2,r5,20
8111df1c:	3806d53a 	srli	r3,r7,20
8111df20:	02000434 	movhi	r8,16
8111df24:	423fffc4 	addi	r8,r8,-1
8111df28:	1081ffcc 	andi	r2,r2,2047
8111df2c:	0241ffc4 	movi	r9,2047
8111df30:	2a14703a 	and	r10,r5,r8
8111df34:	18c1ffcc 	andi	r3,r3,2047
8111df38:	3a10703a 	and	r8,r7,r8
8111df3c:	280ad7fa 	srli	r5,r5,31
8111df40:	380ed7fa 	srli	r7,r7,31
8111df44:	12401d26 	beq	r2,r9,8111dfbc <__gedf2+0xa4>
8111df48:	0241ffc4 	movi	r9,2047
8111df4c:	1a401226 	beq	r3,r9,8111df98 <__gedf2+0x80>
8111df50:	1000081e 	bne	r2,zero,8111df74 <__gedf2+0x5c>
8111df54:	2296b03a 	or	r11,r4,r10
8111df58:	5813003a 	cmpeq	r9,r11,zero
8111df5c:	1800091e 	bne	r3,zero,8111df84 <__gedf2+0x6c>
8111df60:	3218b03a 	or	r12,r6,r8
8111df64:	6000071e 	bne	r12,zero,8111df84 <__gedf2+0x6c>
8111df68:	0005883a 	mov	r2,zero
8111df6c:	5800101e 	bne	r11,zero,8111dfb0 <__gedf2+0x98>
8111df70:	f800283a 	ret
8111df74:	18000c1e 	bne	r3,zero,8111dfa8 <__gedf2+0x90>
8111df78:	3212b03a 	or	r9,r6,r8
8111df7c:	48000c26 	beq	r9,zero,8111dfb0 <__gedf2+0x98>
8111df80:	0013883a 	mov	r9,zero
8111df84:	39c03fcc 	andi	r7,r7,255
8111df88:	48000826 	beq	r9,zero,8111dfac <__gedf2+0x94>
8111df8c:	38000926 	beq	r7,zero,8111dfb4 <__gedf2+0x9c>
8111df90:	00800044 	movi	r2,1
8111df94:	f800283a 	ret
8111df98:	3212b03a 	or	r9,r6,r8
8111df9c:	483fec26 	beq	r9,zero,8111df50 <__reset+0xfb0fdf50>
8111dfa0:	00bfff84 	movi	r2,-2
8111dfa4:	f800283a 	ret
8111dfa8:	39c03fcc 	andi	r7,r7,255
8111dfac:	29c00626 	beq	r5,r7,8111dfc8 <__gedf2+0xb0>
8111dfb0:	283ff726 	beq	r5,zero,8111df90 <__reset+0xfb0fdf90>
8111dfb4:	00bfffc4 	movi	r2,-1
8111dfb8:	f800283a 	ret
8111dfbc:	2292b03a 	or	r9,r4,r10
8111dfc0:	483fe126 	beq	r9,zero,8111df48 <__reset+0xfb0fdf48>
8111dfc4:	003ff606 	br	8111dfa0 <__reset+0xfb0fdfa0>
8111dfc8:	18bff916 	blt	r3,r2,8111dfb0 <__reset+0xfb0fdfb0>
8111dfcc:	10c00316 	blt	r2,r3,8111dfdc <__gedf2+0xc4>
8111dfd0:	42bff736 	bltu	r8,r10,8111dfb0 <__reset+0xfb0fdfb0>
8111dfd4:	52000326 	beq	r10,r8,8111dfe4 <__gedf2+0xcc>
8111dfd8:	5200042e 	bgeu	r10,r8,8111dfec <__gedf2+0xd4>
8111dfdc:	283fec1e 	bne	r5,zero,8111df90 <__reset+0xfb0fdf90>
8111dfe0:	003ff406 	br	8111dfb4 <__reset+0xfb0fdfb4>
8111dfe4:	313ff236 	bltu	r6,r4,8111dfb0 <__reset+0xfb0fdfb0>
8111dfe8:	21bffc36 	bltu	r4,r6,8111dfdc <__reset+0xfb0fdfdc>
8111dfec:	0005883a 	mov	r2,zero
8111dff0:	f800283a 	ret

8111dff4 <__muldf3>:
8111dff4:	defff304 	addi	sp,sp,-52
8111dff8:	2804d53a 	srli	r2,r5,20
8111dffc:	de00012e 	bgeu	sp,et,8111e004 <__muldf3+0x10>
8111e000:	003b68fa 	trap	3
8111e004:	dd800915 	stw	r22,36(sp)
8111e008:	282cd7fa 	srli	r22,r5,31
8111e00c:	dc000315 	stw	r16,12(sp)
8111e010:	04000434 	movhi	r16,16
8111e014:	dd400815 	stw	r21,32(sp)
8111e018:	dc800515 	stw	r18,20(sp)
8111e01c:	843fffc4 	addi	r16,r16,-1
8111e020:	dfc00c15 	stw	ra,48(sp)
8111e024:	df000b15 	stw	fp,44(sp)
8111e028:	ddc00a15 	stw	r23,40(sp)
8111e02c:	dd000715 	stw	r20,28(sp)
8111e030:	dcc00615 	stw	r19,24(sp)
8111e034:	dc400415 	stw	r17,16(sp)
8111e038:	1481ffcc 	andi	r18,r2,2047
8111e03c:	2c20703a 	and	r16,r5,r16
8111e040:	b02b883a 	mov	r21,r22
8111e044:	b2403fcc 	andi	r9,r22,255
8111e048:	90006026 	beq	r18,zero,8111e1cc <__muldf3+0x1d8>
8111e04c:	0081ffc4 	movi	r2,2047
8111e050:	2029883a 	mov	r20,r4
8111e054:	90803626 	beq	r18,r2,8111e130 <__muldf3+0x13c>
8111e058:	80800434 	orhi	r2,r16,16
8111e05c:	100490fa 	slli	r2,r2,3
8111e060:	2020d77a 	srli	r16,r4,29
8111e064:	202890fa 	slli	r20,r4,3
8111e068:	94bf0044 	addi	r18,r18,-1023
8111e06c:	80a0b03a 	or	r16,r16,r2
8111e070:	0027883a 	mov	r19,zero
8111e074:	0039883a 	mov	fp,zero
8111e078:	3804d53a 	srli	r2,r7,20
8111e07c:	382ed7fa 	srli	r23,r7,31
8111e080:	04400434 	movhi	r17,16
8111e084:	8c7fffc4 	addi	r17,r17,-1
8111e088:	1081ffcc 	andi	r2,r2,2047
8111e08c:	3011883a 	mov	r8,r6
8111e090:	3c62703a 	and	r17,r7,r17
8111e094:	ba803fcc 	andi	r10,r23,255
8111e098:	10006d26 	beq	r2,zero,8111e250 <__muldf3+0x25c>
8111e09c:	00c1ffc4 	movi	r3,2047
8111e0a0:	10c06526 	beq	r2,r3,8111e238 <__muldf3+0x244>
8111e0a4:	88c00434 	orhi	r3,r17,16
8111e0a8:	180690fa 	slli	r3,r3,3
8111e0ac:	3022d77a 	srli	r17,r6,29
8111e0b0:	301090fa 	slli	r8,r6,3
8111e0b4:	10bf0044 	addi	r2,r2,-1023
8111e0b8:	88e2b03a 	or	r17,r17,r3
8111e0bc:	000b883a 	mov	r5,zero
8111e0c0:	9085883a 	add	r2,r18,r2
8111e0c4:	2cc8b03a 	or	r4,r5,r19
8111e0c8:	00c003c4 	movi	r3,15
8111e0cc:	bdacf03a 	xor	r22,r23,r22
8111e0d0:	12c00044 	addi	r11,r2,1
8111e0d4:	19009936 	bltu	r3,r4,8111e33c <__muldf3+0x348>
8111e0d8:	200890ba 	slli	r4,r4,2
8111e0dc:	00e044b4 	movhi	r3,33042
8111e0e0:	18f83c04 	addi	r3,r3,-7952
8111e0e4:	20c9883a 	add	r4,r4,r3
8111e0e8:	20c00017 	ldw	r3,0(r4)
8111e0ec:	1800683a 	jmp	r3
8111e0f0:	8111e33c 	xorhi	r4,r16,18316
8111e0f4:	8111e150 	cmplti	r4,r16,18309
8111e0f8:	8111e150 	cmplti	r4,r16,18309
8111e0fc:	8111e14c 	andi	r4,r16,18309
8111e100:	8111e318 	cmpnei	r4,r16,18316
8111e104:	8111e318 	cmpnei	r4,r16,18316
8111e108:	8111e300 	call	88111e30 <__reset+0x20f1e30>
8111e10c:	8111e14c 	andi	r4,r16,18309
8111e110:	8111e318 	cmpnei	r4,r16,18316
8111e114:	8111e300 	call	88111e30 <__reset+0x20f1e30>
8111e118:	8111e318 	cmpnei	r4,r16,18316
8111e11c:	8111e14c 	andi	r4,r16,18309
8111e120:	8111e328 	cmpgeui	r4,r16,18316
8111e124:	8111e328 	cmpgeui	r4,r16,18316
8111e128:	8111e328 	cmpgeui	r4,r16,18316
8111e12c:	8111e544 	addi	r4,r16,18325
8111e130:	2404b03a 	or	r2,r4,r16
8111e134:	10006f1e 	bne	r2,zero,8111e2f4 <__muldf3+0x300>
8111e138:	04c00204 	movi	r19,8
8111e13c:	0021883a 	mov	r16,zero
8111e140:	0029883a 	mov	r20,zero
8111e144:	07000084 	movi	fp,2
8111e148:	003fcb06 	br	8111e078 <__reset+0xfb0fe078>
8111e14c:	502d883a 	mov	r22,r10
8111e150:	00800084 	movi	r2,2
8111e154:	28805726 	beq	r5,r2,8111e2b4 <__muldf3+0x2c0>
8111e158:	008000c4 	movi	r2,3
8111e15c:	28816626 	beq	r5,r2,8111e6f8 <__muldf3+0x704>
8111e160:	00800044 	movi	r2,1
8111e164:	2881411e 	bne	r5,r2,8111e66c <__muldf3+0x678>
8111e168:	b02b883a 	mov	r21,r22
8111e16c:	0005883a 	mov	r2,zero
8111e170:	000b883a 	mov	r5,zero
8111e174:	0029883a 	mov	r20,zero
8111e178:	1004953a 	slli	r2,r2,20
8111e17c:	a8c03fcc 	andi	r3,r21,255
8111e180:	04400434 	movhi	r17,16
8111e184:	8c7fffc4 	addi	r17,r17,-1
8111e188:	180697fa 	slli	r3,r3,31
8111e18c:	2c4a703a 	and	r5,r5,r17
8111e190:	288ab03a 	or	r5,r5,r2
8111e194:	28c6b03a 	or	r3,r5,r3
8111e198:	a005883a 	mov	r2,r20
8111e19c:	dfc00c17 	ldw	ra,48(sp)
8111e1a0:	df000b17 	ldw	fp,44(sp)
8111e1a4:	ddc00a17 	ldw	r23,40(sp)
8111e1a8:	dd800917 	ldw	r22,36(sp)
8111e1ac:	dd400817 	ldw	r21,32(sp)
8111e1b0:	dd000717 	ldw	r20,28(sp)
8111e1b4:	dcc00617 	ldw	r19,24(sp)
8111e1b8:	dc800517 	ldw	r18,20(sp)
8111e1bc:	dc400417 	ldw	r17,16(sp)
8111e1c0:	dc000317 	ldw	r16,12(sp)
8111e1c4:	dec00d04 	addi	sp,sp,52
8111e1c8:	f800283a 	ret
8111e1cc:	2404b03a 	or	r2,r4,r16
8111e1d0:	2027883a 	mov	r19,r4
8111e1d4:	10004226 	beq	r2,zero,8111e2e0 <__muldf3+0x2ec>
8111e1d8:	8000fc26 	beq	r16,zero,8111e5cc <__muldf3+0x5d8>
8111e1dc:	8009883a 	mov	r4,r16
8111e1e0:	d9800215 	stw	r6,8(sp)
8111e1e4:	d9c00015 	stw	r7,0(sp)
8111e1e8:	da400115 	stw	r9,4(sp)
8111e1ec:	111f43c0 	call	8111f43c <__clzsi2>
8111e1f0:	d9800217 	ldw	r6,8(sp)
8111e1f4:	d9c00017 	ldw	r7,0(sp)
8111e1f8:	da400117 	ldw	r9,4(sp)
8111e1fc:	113ffd44 	addi	r4,r2,-11
8111e200:	00c00704 	movi	r3,28
8111e204:	1900ed16 	blt	r3,r4,8111e5bc <__muldf3+0x5c8>
8111e208:	00c00744 	movi	r3,29
8111e20c:	147ffe04 	addi	r17,r2,-8
8111e210:	1907c83a 	sub	r3,r3,r4
8111e214:	8460983a 	sll	r16,r16,r17
8111e218:	98c6d83a 	srl	r3,r19,r3
8111e21c:	9c68983a 	sll	r20,r19,r17
8111e220:	1c20b03a 	or	r16,r3,r16
8111e224:	1080fcc4 	addi	r2,r2,1011
8111e228:	00a5c83a 	sub	r18,zero,r2
8111e22c:	0027883a 	mov	r19,zero
8111e230:	0039883a 	mov	fp,zero
8111e234:	003f9006 	br	8111e078 <__reset+0xfb0fe078>
8111e238:	3446b03a 	or	r3,r6,r17
8111e23c:	1800261e 	bne	r3,zero,8111e2d8 <__muldf3+0x2e4>
8111e240:	0023883a 	mov	r17,zero
8111e244:	0011883a 	mov	r8,zero
8111e248:	01400084 	movi	r5,2
8111e24c:	003f9c06 	br	8111e0c0 <__reset+0xfb0fe0c0>
8111e250:	3446b03a 	or	r3,r6,r17
8111e254:	18001c26 	beq	r3,zero,8111e2c8 <__muldf3+0x2d4>
8111e258:	8800ce26 	beq	r17,zero,8111e594 <__muldf3+0x5a0>
8111e25c:	8809883a 	mov	r4,r17
8111e260:	d9800215 	stw	r6,8(sp)
8111e264:	da400115 	stw	r9,4(sp)
8111e268:	da800015 	stw	r10,0(sp)
8111e26c:	111f43c0 	call	8111f43c <__clzsi2>
8111e270:	d9800217 	ldw	r6,8(sp)
8111e274:	da400117 	ldw	r9,4(sp)
8111e278:	da800017 	ldw	r10,0(sp)
8111e27c:	113ffd44 	addi	r4,r2,-11
8111e280:	00c00704 	movi	r3,28
8111e284:	1900bf16 	blt	r3,r4,8111e584 <__muldf3+0x590>
8111e288:	00c00744 	movi	r3,29
8111e28c:	123ffe04 	addi	r8,r2,-8
8111e290:	1907c83a 	sub	r3,r3,r4
8111e294:	8a22983a 	sll	r17,r17,r8
8111e298:	30c6d83a 	srl	r3,r6,r3
8111e29c:	3210983a 	sll	r8,r6,r8
8111e2a0:	1c62b03a 	or	r17,r3,r17
8111e2a4:	1080fcc4 	addi	r2,r2,1011
8111e2a8:	0085c83a 	sub	r2,zero,r2
8111e2ac:	000b883a 	mov	r5,zero
8111e2b0:	003f8306 	br	8111e0c0 <__reset+0xfb0fe0c0>
8111e2b4:	b02b883a 	mov	r21,r22
8111e2b8:	0081ffc4 	movi	r2,2047
8111e2bc:	000b883a 	mov	r5,zero
8111e2c0:	0029883a 	mov	r20,zero
8111e2c4:	003fac06 	br	8111e178 <__reset+0xfb0fe178>
8111e2c8:	0023883a 	mov	r17,zero
8111e2cc:	0011883a 	mov	r8,zero
8111e2d0:	01400044 	movi	r5,1
8111e2d4:	003f7a06 	br	8111e0c0 <__reset+0xfb0fe0c0>
8111e2d8:	014000c4 	movi	r5,3
8111e2dc:	003f7806 	br	8111e0c0 <__reset+0xfb0fe0c0>
8111e2e0:	04c00104 	movi	r19,4
8111e2e4:	0021883a 	mov	r16,zero
8111e2e8:	0029883a 	mov	r20,zero
8111e2ec:	07000044 	movi	fp,1
8111e2f0:	003f6106 	br	8111e078 <__reset+0xfb0fe078>
8111e2f4:	04c00304 	movi	r19,12
8111e2f8:	070000c4 	movi	fp,3
8111e2fc:	003f5e06 	br	8111e078 <__reset+0xfb0fe078>
8111e300:	01400434 	movhi	r5,16
8111e304:	002b883a 	mov	r21,zero
8111e308:	297fffc4 	addi	r5,r5,-1
8111e30c:	053fffc4 	movi	r20,-1
8111e310:	0081ffc4 	movi	r2,2047
8111e314:	003f9806 	br	8111e178 <__reset+0xfb0fe178>
8111e318:	8023883a 	mov	r17,r16
8111e31c:	a011883a 	mov	r8,r20
8111e320:	e00b883a 	mov	r5,fp
8111e324:	003f8a06 	br	8111e150 <__reset+0xfb0fe150>
8111e328:	8023883a 	mov	r17,r16
8111e32c:	a011883a 	mov	r8,r20
8111e330:	482d883a 	mov	r22,r9
8111e334:	e00b883a 	mov	r5,fp
8111e338:	003f8506 	br	8111e150 <__reset+0xfb0fe150>
8111e33c:	a00ad43a 	srli	r5,r20,16
8111e340:	401ad43a 	srli	r13,r8,16
8111e344:	a53fffcc 	andi	r20,r20,65535
8111e348:	423fffcc 	andi	r8,r8,65535
8111e34c:	4519383a 	mul	r12,r8,r20
8111e350:	4147383a 	mul	r3,r8,r5
8111e354:	6d09383a 	mul	r4,r13,r20
8111e358:	600cd43a 	srli	r6,r12,16
8111e35c:	2b5d383a 	mul	r14,r5,r13
8111e360:	20c9883a 	add	r4,r4,r3
8111e364:	310d883a 	add	r6,r6,r4
8111e368:	30c0022e 	bgeu	r6,r3,8111e374 <__muldf3+0x380>
8111e36c:	00c00074 	movhi	r3,1
8111e370:	70dd883a 	add	r14,r14,r3
8111e374:	8826d43a 	srli	r19,r17,16
8111e378:	8bffffcc 	andi	r15,r17,65535
8111e37c:	7d23383a 	mul	r17,r15,r20
8111e380:	7949383a 	mul	r4,r15,r5
8111e384:	9d29383a 	mul	r20,r19,r20
8111e388:	8814d43a 	srli	r10,r17,16
8111e38c:	3012943a 	slli	r9,r6,16
8111e390:	a129883a 	add	r20,r20,r4
8111e394:	633fffcc 	andi	r12,r12,65535
8111e398:	5515883a 	add	r10,r10,r20
8111e39c:	3006d43a 	srli	r3,r6,16
8111e3a0:	4b13883a 	add	r9,r9,r12
8111e3a4:	2ccb383a 	mul	r5,r5,r19
8111e3a8:	5100022e 	bgeu	r10,r4,8111e3b4 <__muldf3+0x3c0>
8111e3ac:	01000074 	movhi	r4,1
8111e3b0:	290b883a 	add	r5,r5,r4
8111e3b4:	802ad43a 	srli	r21,r16,16
8111e3b8:	843fffcc 	andi	r16,r16,65535
8111e3bc:	440d383a 	mul	r6,r8,r16
8111e3c0:	4565383a 	mul	r18,r8,r21
8111e3c4:	8349383a 	mul	r4,r16,r13
8111e3c8:	500e943a 	slli	r7,r10,16
8111e3cc:	3010d43a 	srli	r8,r6,16
8111e3d0:	5028d43a 	srli	r20,r10,16
8111e3d4:	2489883a 	add	r4,r4,r18
8111e3d8:	8abfffcc 	andi	r10,r17,65535
8111e3dc:	3a95883a 	add	r10,r7,r10
8111e3e0:	4119883a 	add	r12,r8,r4
8111e3e4:	a169883a 	add	r20,r20,r5
8111e3e8:	1a87883a 	add	r3,r3,r10
8111e3ec:	6d5b383a 	mul	r13,r13,r21
8111e3f0:	6480022e 	bgeu	r12,r18,8111e3fc <__muldf3+0x408>
8111e3f4:	01000074 	movhi	r4,1
8111e3f8:	691b883a 	add	r13,r13,r4
8111e3fc:	7c25383a 	mul	r18,r15,r16
8111e400:	7d4b383a 	mul	r5,r15,r21
8111e404:	84cf383a 	mul	r7,r16,r19
8111e408:	901ed43a 	srli	r15,r18,16
8111e40c:	6008d43a 	srli	r4,r12,16
8111e410:	6010943a 	slli	r8,r12,16
8111e414:	394f883a 	add	r7,r7,r5
8111e418:	333fffcc 	andi	r12,r6,65535
8111e41c:	79df883a 	add	r15,r15,r7
8111e420:	235b883a 	add	r13,r4,r13
8111e424:	9d63383a 	mul	r17,r19,r21
8111e428:	4309883a 	add	r4,r8,r12
8111e42c:	7940022e 	bgeu	r15,r5,8111e438 <__muldf3+0x444>
8111e430:	01400074 	movhi	r5,1
8111e434:	8963883a 	add	r17,r17,r5
8111e438:	780a943a 	slli	r5,r15,16
8111e43c:	91bfffcc 	andi	r6,r18,65535
8111e440:	70c7883a 	add	r3,r14,r3
8111e444:	298d883a 	add	r6,r5,r6
8111e448:	1a8f803a 	cmpltu	r7,r3,r10
8111e44c:	350b883a 	add	r5,r6,r20
8111e450:	20c7883a 	add	r3,r4,r3
8111e454:	3955883a 	add	r10,r7,r5
8111e458:	1909803a 	cmpltu	r4,r3,r4
8111e45c:	6a91883a 	add	r8,r13,r10
8111e460:	780cd43a 	srli	r6,r15,16
8111e464:	2219883a 	add	r12,r4,r8
8111e468:	2d0b803a 	cmpltu	r5,r5,r20
8111e46c:	51cf803a 	cmpltu	r7,r10,r7
8111e470:	29ceb03a 	or	r7,r5,r7
8111e474:	4351803a 	cmpltu	r8,r8,r13
8111e478:	610b803a 	cmpltu	r5,r12,r4
8111e47c:	4148b03a 	or	r4,r8,r5
8111e480:	398f883a 	add	r7,r7,r6
8111e484:	3909883a 	add	r4,r7,r4
8111e488:	1810927a 	slli	r8,r3,9
8111e48c:	2449883a 	add	r4,r4,r17
8111e490:	2008927a 	slli	r4,r4,9
8111e494:	6022d5fa 	srli	r17,r12,23
8111e498:	1806d5fa 	srli	r3,r3,23
8111e49c:	4252b03a 	or	r9,r8,r9
8111e4a0:	600a927a 	slli	r5,r12,9
8111e4a4:	4810c03a 	cmpne	r8,r9,zero
8111e4a8:	2462b03a 	or	r17,r4,r17
8111e4ac:	40c6b03a 	or	r3,r8,r3
8111e4b0:	8900402c 	andhi	r4,r17,256
8111e4b4:	1950b03a 	or	r8,r3,r5
8111e4b8:	20000726 	beq	r4,zero,8111e4d8 <__muldf3+0x4e4>
8111e4bc:	4006d07a 	srli	r3,r8,1
8111e4c0:	880497fa 	slli	r2,r17,31
8111e4c4:	4200004c 	andi	r8,r8,1
8111e4c8:	8822d07a 	srli	r17,r17,1
8111e4cc:	1a10b03a 	or	r8,r3,r8
8111e4d0:	1210b03a 	or	r8,r2,r8
8111e4d4:	5805883a 	mov	r2,r11
8111e4d8:	1140ffc4 	addi	r5,r2,1023
8111e4dc:	0140440e 	bge	zero,r5,8111e5f0 <__muldf3+0x5fc>
8111e4e0:	40c001cc 	andi	r3,r8,7
8111e4e4:	18000726 	beq	r3,zero,8111e504 <__muldf3+0x510>
8111e4e8:	40c003cc 	andi	r3,r8,15
8111e4ec:	01000104 	movi	r4,4
8111e4f0:	19000426 	beq	r3,r4,8111e504 <__muldf3+0x510>
8111e4f4:	4107883a 	add	r3,r8,r4
8111e4f8:	1a11803a 	cmpltu	r8,r3,r8
8111e4fc:	8a23883a 	add	r17,r17,r8
8111e500:	1811883a 	mov	r8,r3
8111e504:	88c0402c 	andhi	r3,r17,256
8111e508:	18000426 	beq	r3,zero,8111e51c <__muldf3+0x528>
8111e50c:	11410004 	addi	r5,r2,1024
8111e510:	00bfc034 	movhi	r2,65280
8111e514:	10bfffc4 	addi	r2,r2,-1
8111e518:	88a2703a 	and	r17,r17,r2
8111e51c:	0081ff84 	movi	r2,2046
8111e520:	117f6416 	blt	r2,r5,8111e2b4 <__reset+0xfb0fe2b4>
8111e524:	8828977a 	slli	r20,r17,29
8111e528:	4010d0fa 	srli	r8,r8,3
8111e52c:	8822927a 	slli	r17,r17,9
8111e530:	2881ffcc 	andi	r2,r5,2047
8111e534:	a228b03a 	or	r20,r20,r8
8111e538:	880ad33a 	srli	r5,r17,12
8111e53c:	b02b883a 	mov	r21,r22
8111e540:	003f0d06 	br	8111e178 <__reset+0xfb0fe178>
8111e544:	8080022c 	andhi	r2,r16,8
8111e548:	10000926 	beq	r2,zero,8111e570 <__muldf3+0x57c>
8111e54c:	8880022c 	andhi	r2,r17,8
8111e550:	1000071e 	bne	r2,zero,8111e570 <__muldf3+0x57c>
8111e554:	00800434 	movhi	r2,16
8111e558:	89400234 	orhi	r5,r17,8
8111e55c:	10bfffc4 	addi	r2,r2,-1
8111e560:	b82b883a 	mov	r21,r23
8111e564:	288a703a 	and	r5,r5,r2
8111e568:	4029883a 	mov	r20,r8
8111e56c:	003f6806 	br	8111e310 <__reset+0xfb0fe310>
8111e570:	00800434 	movhi	r2,16
8111e574:	81400234 	orhi	r5,r16,8
8111e578:	10bfffc4 	addi	r2,r2,-1
8111e57c:	288a703a 	and	r5,r5,r2
8111e580:	003f6306 	br	8111e310 <__reset+0xfb0fe310>
8111e584:	147ff604 	addi	r17,r2,-40
8111e588:	3462983a 	sll	r17,r6,r17
8111e58c:	0011883a 	mov	r8,zero
8111e590:	003f4406 	br	8111e2a4 <__reset+0xfb0fe2a4>
8111e594:	3009883a 	mov	r4,r6
8111e598:	d9800215 	stw	r6,8(sp)
8111e59c:	da400115 	stw	r9,4(sp)
8111e5a0:	da800015 	stw	r10,0(sp)
8111e5a4:	111f43c0 	call	8111f43c <__clzsi2>
8111e5a8:	10800804 	addi	r2,r2,32
8111e5ac:	da800017 	ldw	r10,0(sp)
8111e5b0:	da400117 	ldw	r9,4(sp)
8111e5b4:	d9800217 	ldw	r6,8(sp)
8111e5b8:	003f3006 	br	8111e27c <__reset+0xfb0fe27c>
8111e5bc:	143ff604 	addi	r16,r2,-40
8111e5c0:	9c20983a 	sll	r16,r19,r16
8111e5c4:	0029883a 	mov	r20,zero
8111e5c8:	003f1606 	br	8111e224 <__reset+0xfb0fe224>
8111e5cc:	d9800215 	stw	r6,8(sp)
8111e5d0:	d9c00015 	stw	r7,0(sp)
8111e5d4:	da400115 	stw	r9,4(sp)
8111e5d8:	111f43c0 	call	8111f43c <__clzsi2>
8111e5dc:	10800804 	addi	r2,r2,32
8111e5e0:	da400117 	ldw	r9,4(sp)
8111e5e4:	d9c00017 	ldw	r7,0(sp)
8111e5e8:	d9800217 	ldw	r6,8(sp)
8111e5ec:	003f0306 	br	8111e1fc <__reset+0xfb0fe1fc>
8111e5f0:	00c00044 	movi	r3,1
8111e5f4:	1947c83a 	sub	r3,r3,r5
8111e5f8:	00800e04 	movi	r2,56
8111e5fc:	10feda16 	blt	r2,r3,8111e168 <__reset+0xfb0fe168>
8111e600:	008007c4 	movi	r2,31
8111e604:	10c01b16 	blt	r2,r3,8111e674 <__muldf3+0x680>
8111e608:	00800804 	movi	r2,32
8111e60c:	10c5c83a 	sub	r2,r2,r3
8111e610:	888a983a 	sll	r5,r17,r2
8111e614:	40c8d83a 	srl	r4,r8,r3
8111e618:	4084983a 	sll	r2,r8,r2
8111e61c:	88e2d83a 	srl	r17,r17,r3
8111e620:	2906b03a 	or	r3,r5,r4
8111e624:	1004c03a 	cmpne	r2,r2,zero
8111e628:	1886b03a 	or	r3,r3,r2
8111e62c:	188001cc 	andi	r2,r3,7
8111e630:	10000726 	beq	r2,zero,8111e650 <__muldf3+0x65c>
8111e634:	188003cc 	andi	r2,r3,15
8111e638:	01000104 	movi	r4,4
8111e63c:	11000426 	beq	r2,r4,8111e650 <__muldf3+0x65c>
8111e640:	1805883a 	mov	r2,r3
8111e644:	10c00104 	addi	r3,r2,4
8111e648:	1885803a 	cmpltu	r2,r3,r2
8111e64c:	88a3883a 	add	r17,r17,r2
8111e650:	8880202c 	andhi	r2,r17,128
8111e654:	10001c26 	beq	r2,zero,8111e6c8 <__muldf3+0x6d4>
8111e658:	b02b883a 	mov	r21,r22
8111e65c:	00800044 	movi	r2,1
8111e660:	000b883a 	mov	r5,zero
8111e664:	0029883a 	mov	r20,zero
8111e668:	003ec306 	br	8111e178 <__reset+0xfb0fe178>
8111e66c:	5805883a 	mov	r2,r11
8111e670:	003f9906 	br	8111e4d8 <__reset+0xfb0fe4d8>
8111e674:	00bff844 	movi	r2,-31
8111e678:	1145c83a 	sub	r2,r2,r5
8111e67c:	8888d83a 	srl	r4,r17,r2
8111e680:	00800804 	movi	r2,32
8111e684:	18801a26 	beq	r3,r2,8111e6f0 <__muldf3+0x6fc>
8111e688:	00801004 	movi	r2,64
8111e68c:	10c5c83a 	sub	r2,r2,r3
8111e690:	8884983a 	sll	r2,r17,r2
8111e694:	1204b03a 	or	r2,r2,r8
8111e698:	1004c03a 	cmpne	r2,r2,zero
8111e69c:	2084b03a 	or	r2,r4,r2
8111e6a0:	144001cc 	andi	r17,r2,7
8111e6a4:	88000d1e 	bne	r17,zero,8111e6dc <__muldf3+0x6e8>
8111e6a8:	000b883a 	mov	r5,zero
8111e6ac:	1028d0fa 	srli	r20,r2,3
8111e6b0:	b02b883a 	mov	r21,r22
8111e6b4:	0005883a 	mov	r2,zero
8111e6b8:	a468b03a 	or	r20,r20,r17
8111e6bc:	003eae06 	br	8111e178 <__reset+0xfb0fe178>
8111e6c0:	1007883a 	mov	r3,r2
8111e6c4:	0023883a 	mov	r17,zero
8111e6c8:	880a927a 	slli	r5,r17,9
8111e6cc:	1805883a 	mov	r2,r3
8111e6d0:	8822977a 	slli	r17,r17,29
8111e6d4:	280ad33a 	srli	r5,r5,12
8111e6d8:	003ff406 	br	8111e6ac <__reset+0xfb0fe6ac>
8111e6dc:	10c003cc 	andi	r3,r2,15
8111e6e0:	01000104 	movi	r4,4
8111e6e4:	193ff626 	beq	r3,r4,8111e6c0 <__reset+0xfb0fe6c0>
8111e6e8:	0023883a 	mov	r17,zero
8111e6ec:	003fd506 	br	8111e644 <__reset+0xfb0fe644>
8111e6f0:	0005883a 	mov	r2,zero
8111e6f4:	003fe706 	br	8111e694 <__reset+0xfb0fe694>
8111e6f8:	00800434 	movhi	r2,16
8111e6fc:	89400234 	orhi	r5,r17,8
8111e700:	10bfffc4 	addi	r2,r2,-1
8111e704:	b02b883a 	mov	r21,r22
8111e708:	288a703a 	and	r5,r5,r2
8111e70c:	4029883a 	mov	r20,r8
8111e710:	003eff06 	br	8111e310 <__reset+0xfb0fe310>

8111e714 <__subdf3>:
8111e714:	02000434 	movhi	r8,16
8111e718:	423fffc4 	addi	r8,r8,-1
8111e71c:	defffb04 	addi	sp,sp,-20
8111e720:	2a14703a 	and	r10,r5,r8
8111e724:	3812d53a 	srli	r9,r7,20
8111e728:	3a10703a 	and	r8,r7,r8
8111e72c:	de00012e 	bgeu	sp,et,8111e734 <__subdf3+0x20>
8111e730:	003b68fa 	trap	3
8111e734:	2006d77a 	srli	r3,r4,29
8111e738:	3004d77a 	srli	r2,r6,29
8111e73c:	dc000015 	stw	r16,0(sp)
8111e740:	501490fa 	slli	r10,r10,3
8111e744:	2820d53a 	srli	r16,r5,20
8111e748:	401090fa 	slli	r8,r8,3
8111e74c:	dc800215 	stw	r18,8(sp)
8111e750:	dc400115 	stw	r17,4(sp)
8111e754:	dfc00415 	stw	ra,16(sp)
8111e758:	202290fa 	slli	r17,r4,3
8111e75c:	dcc00315 	stw	r19,12(sp)
8111e760:	4a41ffcc 	andi	r9,r9,2047
8111e764:	0101ffc4 	movi	r4,2047
8111e768:	2824d7fa 	srli	r18,r5,31
8111e76c:	8401ffcc 	andi	r16,r16,2047
8111e770:	50c6b03a 	or	r3,r10,r3
8111e774:	380ed7fa 	srli	r7,r7,31
8111e778:	408ab03a 	or	r5,r8,r2
8111e77c:	300c90fa 	slli	r6,r6,3
8111e780:	49009626 	beq	r9,r4,8111e9dc <__subdf3+0x2c8>
8111e784:	39c0005c 	xori	r7,r7,1
8111e788:	8245c83a 	sub	r2,r16,r9
8111e78c:	3c807426 	beq	r7,r18,8111e960 <__subdf3+0x24c>
8111e790:	0080af0e 	bge	zero,r2,8111ea50 <__subdf3+0x33c>
8111e794:	48002a1e 	bne	r9,zero,8111e840 <__subdf3+0x12c>
8111e798:	2988b03a 	or	r4,r5,r6
8111e79c:	20009a1e 	bne	r4,zero,8111ea08 <__subdf3+0x2f4>
8111e7a0:	888001cc 	andi	r2,r17,7
8111e7a4:	10000726 	beq	r2,zero,8111e7c4 <__subdf3+0xb0>
8111e7a8:	888003cc 	andi	r2,r17,15
8111e7ac:	01000104 	movi	r4,4
8111e7b0:	11000426 	beq	r2,r4,8111e7c4 <__subdf3+0xb0>
8111e7b4:	890b883a 	add	r5,r17,r4
8111e7b8:	2c63803a 	cmpltu	r17,r5,r17
8111e7bc:	1c47883a 	add	r3,r3,r17
8111e7c0:	2823883a 	mov	r17,r5
8111e7c4:	1880202c 	andhi	r2,r3,128
8111e7c8:	10005926 	beq	r2,zero,8111e930 <__subdf3+0x21c>
8111e7cc:	84000044 	addi	r16,r16,1
8111e7d0:	0081ffc4 	movi	r2,2047
8111e7d4:	8080be26 	beq	r16,r2,8111ead0 <__subdf3+0x3bc>
8111e7d8:	017fe034 	movhi	r5,65408
8111e7dc:	297fffc4 	addi	r5,r5,-1
8111e7e0:	1946703a 	and	r3,r3,r5
8111e7e4:	1804977a 	slli	r2,r3,29
8111e7e8:	1806927a 	slli	r3,r3,9
8111e7ec:	8822d0fa 	srli	r17,r17,3
8111e7f0:	8401ffcc 	andi	r16,r16,2047
8111e7f4:	180ad33a 	srli	r5,r3,12
8111e7f8:	9100004c 	andi	r4,r18,1
8111e7fc:	1444b03a 	or	r2,r2,r17
8111e800:	80c1ffcc 	andi	r3,r16,2047
8111e804:	1820953a 	slli	r16,r3,20
8111e808:	20c03fcc 	andi	r3,r4,255
8111e80c:	180897fa 	slli	r4,r3,31
8111e810:	00c00434 	movhi	r3,16
8111e814:	18ffffc4 	addi	r3,r3,-1
8111e818:	28c6703a 	and	r3,r5,r3
8111e81c:	1c06b03a 	or	r3,r3,r16
8111e820:	1906b03a 	or	r3,r3,r4
8111e824:	dfc00417 	ldw	ra,16(sp)
8111e828:	dcc00317 	ldw	r19,12(sp)
8111e82c:	dc800217 	ldw	r18,8(sp)
8111e830:	dc400117 	ldw	r17,4(sp)
8111e834:	dc000017 	ldw	r16,0(sp)
8111e838:	dec00504 	addi	sp,sp,20
8111e83c:	f800283a 	ret
8111e840:	0101ffc4 	movi	r4,2047
8111e844:	813fd626 	beq	r16,r4,8111e7a0 <__reset+0xfb0fe7a0>
8111e848:	29402034 	orhi	r5,r5,128
8111e84c:	01000e04 	movi	r4,56
8111e850:	2080a316 	blt	r4,r2,8111eae0 <__subdf3+0x3cc>
8111e854:	010007c4 	movi	r4,31
8111e858:	2080c616 	blt	r4,r2,8111eb74 <__subdf3+0x460>
8111e85c:	01000804 	movi	r4,32
8111e860:	2089c83a 	sub	r4,r4,r2
8111e864:	2910983a 	sll	r8,r5,r4
8111e868:	308ed83a 	srl	r7,r6,r2
8111e86c:	3108983a 	sll	r4,r6,r4
8111e870:	2884d83a 	srl	r2,r5,r2
8111e874:	41ccb03a 	or	r6,r8,r7
8111e878:	2008c03a 	cmpne	r4,r4,zero
8111e87c:	310cb03a 	or	r6,r6,r4
8111e880:	898dc83a 	sub	r6,r17,r6
8111e884:	89a3803a 	cmpltu	r17,r17,r6
8111e888:	1887c83a 	sub	r3,r3,r2
8111e88c:	1c47c83a 	sub	r3,r3,r17
8111e890:	3023883a 	mov	r17,r6
8111e894:	1880202c 	andhi	r2,r3,128
8111e898:	10002326 	beq	r2,zero,8111e928 <__subdf3+0x214>
8111e89c:	04c02034 	movhi	r19,128
8111e8a0:	9cffffc4 	addi	r19,r19,-1
8111e8a4:	1ce6703a 	and	r19,r3,r19
8111e8a8:	98007a26 	beq	r19,zero,8111ea94 <__subdf3+0x380>
8111e8ac:	9809883a 	mov	r4,r19
8111e8b0:	111f43c0 	call	8111f43c <__clzsi2>
8111e8b4:	113ffe04 	addi	r4,r2,-8
8111e8b8:	00c007c4 	movi	r3,31
8111e8bc:	19007b16 	blt	r3,r4,8111eaac <__subdf3+0x398>
8111e8c0:	00800804 	movi	r2,32
8111e8c4:	1105c83a 	sub	r2,r2,r4
8111e8c8:	8884d83a 	srl	r2,r17,r2
8111e8cc:	9906983a 	sll	r3,r19,r4
8111e8d0:	8922983a 	sll	r17,r17,r4
8111e8d4:	10c4b03a 	or	r2,r2,r3
8111e8d8:	24007816 	blt	r4,r16,8111eabc <__subdf3+0x3a8>
8111e8dc:	2421c83a 	sub	r16,r4,r16
8111e8e0:	80c00044 	addi	r3,r16,1
8111e8e4:	010007c4 	movi	r4,31
8111e8e8:	20c09516 	blt	r4,r3,8111eb40 <__subdf3+0x42c>
8111e8ec:	01400804 	movi	r5,32
8111e8f0:	28cbc83a 	sub	r5,r5,r3
8111e8f4:	88c8d83a 	srl	r4,r17,r3
8111e8f8:	8962983a 	sll	r17,r17,r5
8111e8fc:	114a983a 	sll	r5,r2,r5
8111e900:	10c6d83a 	srl	r3,r2,r3
8111e904:	8804c03a 	cmpne	r2,r17,zero
8111e908:	290ab03a 	or	r5,r5,r4
8111e90c:	28a2b03a 	or	r17,r5,r2
8111e910:	0021883a 	mov	r16,zero
8111e914:	003fa206 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111e918:	2090b03a 	or	r8,r4,r2
8111e91c:	40018e26 	beq	r8,zero,8111ef58 <__subdf3+0x844>
8111e920:	1007883a 	mov	r3,r2
8111e924:	2023883a 	mov	r17,r4
8111e928:	888001cc 	andi	r2,r17,7
8111e92c:	103f9e1e 	bne	r2,zero,8111e7a8 <__reset+0xfb0fe7a8>
8111e930:	1804977a 	slli	r2,r3,29
8111e934:	8822d0fa 	srli	r17,r17,3
8111e938:	1810d0fa 	srli	r8,r3,3
8111e93c:	9100004c 	andi	r4,r18,1
8111e940:	1444b03a 	or	r2,r2,r17
8111e944:	00c1ffc4 	movi	r3,2047
8111e948:	80c02826 	beq	r16,r3,8111e9ec <__subdf3+0x2d8>
8111e94c:	01400434 	movhi	r5,16
8111e950:	297fffc4 	addi	r5,r5,-1
8111e954:	80e0703a 	and	r16,r16,r3
8111e958:	414a703a 	and	r5,r8,r5
8111e95c:	003fa806 	br	8111e800 <__reset+0xfb0fe800>
8111e960:	0080630e 	bge	zero,r2,8111eaf0 <__subdf3+0x3dc>
8111e964:	48003026 	beq	r9,zero,8111ea28 <__subdf3+0x314>
8111e968:	0101ffc4 	movi	r4,2047
8111e96c:	813f8c26 	beq	r16,r4,8111e7a0 <__reset+0xfb0fe7a0>
8111e970:	29402034 	orhi	r5,r5,128
8111e974:	01000e04 	movi	r4,56
8111e978:	2080a90e 	bge	r4,r2,8111ec20 <__subdf3+0x50c>
8111e97c:	298cb03a 	or	r6,r5,r6
8111e980:	3012c03a 	cmpne	r9,r6,zero
8111e984:	0005883a 	mov	r2,zero
8111e988:	4c53883a 	add	r9,r9,r17
8111e98c:	4c63803a 	cmpltu	r17,r9,r17
8111e990:	10c7883a 	add	r3,r2,r3
8111e994:	88c7883a 	add	r3,r17,r3
8111e998:	4823883a 	mov	r17,r9
8111e99c:	1880202c 	andhi	r2,r3,128
8111e9a0:	1000d026 	beq	r2,zero,8111ece4 <__subdf3+0x5d0>
8111e9a4:	84000044 	addi	r16,r16,1
8111e9a8:	0081ffc4 	movi	r2,2047
8111e9ac:	8080fe26 	beq	r16,r2,8111eda8 <__subdf3+0x694>
8111e9b0:	00bfe034 	movhi	r2,65408
8111e9b4:	10bfffc4 	addi	r2,r2,-1
8111e9b8:	1886703a 	and	r3,r3,r2
8111e9bc:	880ad07a 	srli	r5,r17,1
8111e9c0:	180497fa 	slli	r2,r3,31
8111e9c4:	8900004c 	andi	r4,r17,1
8111e9c8:	2922b03a 	or	r17,r5,r4
8111e9cc:	1806d07a 	srli	r3,r3,1
8111e9d0:	1462b03a 	or	r17,r2,r17
8111e9d4:	3825883a 	mov	r18,r7
8111e9d8:	003f7106 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111e9dc:	2984b03a 	or	r2,r5,r6
8111e9e0:	103f6826 	beq	r2,zero,8111e784 <__reset+0xfb0fe784>
8111e9e4:	39c03fcc 	andi	r7,r7,255
8111e9e8:	003f6706 	br	8111e788 <__reset+0xfb0fe788>
8111e9ec:	4086b03a 	or	r3,r8,r2
8111e9f0:	18015226 	beq	r3,zero,8111ef3c <__subdf3+0x828>
8111e9f4:	00c00434 	movhi	r3,16
8111e9f8:	41400234 	orhi	r5,r8,8
8111e9fc:	18ffffc4 	addi	r3,r3,-1
8111ea00:	28ca703a 	and	r5,r5,r3
8111ea04:	003f7e06 	br	8111e800 <__reset+0xfb0fe800>
8111ea08:	10bfffc4 	addi	r2,r2,-1
8111ea0c:	1000491e 	bne	r2,zero,8111eb34 <__subdf3+0x420>
8111ea10:	898fc83a 	sub	r7,r17,r6
8111ea14:	89e3803a 	cmpltu	r17,r17,r7
8111ea18:	1947c83a 	sub	r3,r3,r5
8111ea1c:	1c47c83a 	sub	r3,r3,r17
8111ea20:	3823883a 	mov	r17,r7
8111ea24:	003f9b06 	br	8111e894 <__reset+0xfb0fe894>
8111ea28:	2988b03a 	or	r4,r5,r6
8111ea2c:	203f5c26 	beq	r4,zero,8111e7a0 <__reset+0xfb0fe7a0>
8111ea30:	10bfffc4 	addi	r2,r2,-1
8111ea34:	1000931e 	bne	r2,zero,8111ec84 <__subdf3+0x570>
8111ea38:	898d883a 	add	r6,r17,r6
8111ea3c:	3463803a 	cmpltu	r17,r6,r17
8111ea40:	1947883a 	add	r3,r3,r5
8111ea44:	88c7883a 	add	r3,r17,r3
8111ea48:	3023883a 	mov	r17,r6
8111ea4c:	003fd306 	br	8111e99c <__reset+0xfb0fe99c>
8111ea50:	1000541e 	bne	r2,zero,8111eba4 <__subdf3+0x490>
8111ea54:	80800044 	addi	r2,r16,1
8111ea58:	1081ffcc 	andi	r2,r2,2047
8111ea5c:	01000044 	movi	r4,1
8111ea60:	2080a20e 	bge	r4,r2,8111ecec <__subdf3+0x5d8>
8111ea64:	8989c83a 	sub	r4,r17,r6
8111ea68:	8905803a 	cmpltu	r2,r17,r4
8111ea6c:	1967c83a 	sub	r19,r3,r5
8111ea70:	98a7c83a 	sub	r19,r19,r2
8111ea74:	9880202c 	andhi	r2,r19,128
8111ea78:	10006326 	beq	r2,zero,8111ec08 <__subdf3+0x4f4>
8111ea7c:	3463c83a 	sub	r17,r6,r17
8111ea80:	28c7c83a 	sub	r3,r5,r3
8111ea84:	344d803a 	cmpltu	r6,r6,r17
8111ea88:	19a7c83a 	sub	r19,r3,r6
8111ea8c:	3825883a 	mov	r18,r7
8111ea90:	983f861e 	bne	r19,zero,8111e8ac <__reset+0xfb0fe8ac>
8111ea94:	8809883a 	mov	r4,r17
8111ea98:	111f43c0 	call	8111f43c <__clzsi2>
8111ea9c:	10800804 	addi	r2,r2,32
8111eaa0:	113ffe04 	addi	r4,r2,-8
8111eaa4:	00c007c4 	movi	r3,31
8111eaa8:	193f850e 	bge	r3,r4,8111e8c0 <__reset+0xfb0fe8c0>
8111eaac:	10bff604 	addi	r2,r2,-40
8111eab0:	8884983a 	sll	r2,r17,r2
8111eab4:	0023883a 	mov	r17,zero
8111eab8:	243f880e 	bge	r4,r16,8111e8dc <__reset+0xfb0fe8dc>
8111eabc:	00ffe034 	movhi	r3,65408
8111eac0:	18ffffc4 	addi	r3,r3,-1
8111eac4:	8121c83a 	sub	r16,r16,r4
8111eac8:	10c6703a 	and	r3,r2,r3
8111eacc:	003f3406 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ead0:	9100004c 	andi	r4,r18,1
8111ead4:	000b883a 	mov	r5,zero
8111ead8:	0005883a 	mov	r2,zero
8111eadc:	003f4806 	br	8111e800 <__reset+0xfb0fe800>
8111eae0:	298cb03a 	or	r6,r5,r6
8111eae4:	300cc03a 	cmpne	r6,r6,zero
8111eae8:	0005883a 	mov	r2,zero
8111eaec:	003f6406 	br	8111e880 <__reset+0xfb0fe880>
8111eaf0:	10009a1e 	bne	r2,zero,8111ed5c <__subdf3+0x648>
8111eaf4:	82400044 	addi	r9,r16,1
8111eaf8:	4881ffcc 	andi	r2,r9,2047
8111eafc:	02800044 	movi	r10,1
8111eb00:	5080670e 	bge	r10,r2,8111eca0 <__subdf3+0x58c>
8111eb04:	0081ffc4 	movi	r2,2047
8111eb08:	4880af26 	beq	r9,r2,8111edc8 <__subdf3+0x6b4>
8111eb0c:	898d883a 	add	r6,r17,r6
8111eb10:	1945883a 	add	r2,r3,r5
8111eb14:	3447803a 	cmpltu	r3,r6,r17
8111eb18:	1887883a 	add	r3,r3,r2
8111eb1c:	182297fa 	slli	r17,r3,31
8111eb20:	300cd07a 	srli	r6,r6,1
8111eb24:	1806d07a 	srli	r3,r3,1
8111eb28:	4821883a 	mov	r16,r9
8111eb2c:	89a2b03a 	or	r17,r17,r6
8111eb30:	003f1b06 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111eb34:	0101ffc4 	movi	r4,2047
8111eb38:	813f441e 	bne	r16,r4,8111e84c <__reset+0xfb0fe84c>
8111eb3c:	003f1806 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111eb40:	843ff844 	addi	r16,r16,-31
8111eb44:	01400804 	movi	r5,32
8111eb48:	1408d83a 	srl	r4,r2,r16
8111eb4c:	19405026 	beq	r3,r5,8111ec90 <__subdf3+0x57c>
8111eb50:	01401004 	movi	r5,64
8111eb54:	28c7c83a 	sub	r3,r5,r3
8111eb58:	10c4983a 	sll	r2,r2,r3
8111eb5c:	88a2b03a 	or	r17,r17,r2
8111eb60:	8822c03a 	cmpne	r17,r17,zero
8111eb64:	2462b03a 	or	r17,r4,r17
8111eb68:	0007883a 	mov	r3,zero
8111eb6c:	0021883a 	mov	r16,zero
8111eb70:	003f6d06 	br	8111e928 <__reset+0xfb0fe928>
8111eb74:	11fff804 	addi	r7,r2,-32
8111eb78:	01000804 	movi	r4,32
8111eb7c:	29ced83a 	srl	r7,r5,r7
8111eb80:	11004526 	beq	r2,r4,8111ec98 <__subdf3+0x584>
8111eb84:	01001004 	movi	r4,64
8111eb88:	2089c83a 	sub	r4,r4,r2
8111eb8c:	2904983a 	sll	r2,r5,r4
8111eb90:	118cb03a 	or	r6,r2,r6
8111eb94:	300cc03a 	cmpne	r6,r6,zero
8111eb98:	398cb03a 	or	r6,r7,r6
8111eb9c:	0005883a 	mov	r2,zero
8111eba0:	003f3706 	br	8111e880 <__reset+0xfb0fe880>
8111eba4:	80002a26 	beq	r16,zero,8111ec50 <__subdf3+0x53c>
8111eba8:	0101ffc4 	movi	r4,2047
8111ebac:	49006626 	beq	r9,r4,8111ed48 <__subdf3+0x634>
8111ebb0:	0085c83a 	sub	r2,zero,r2
8111ebb4:	18c02034 	orhi	r3,r3,128
8111ebb8:	01000e04 	movi	r4,56
8111ebbc:	20807e16 	blt	r4,r2,8111edb8 <__subdf3+0x6a4>
8111ebc0:	010007c4 	movi	r4,31
8111ebc4:	2080e716 	blt	r4,r2,8111ef64 <__subdf3+0x850>
8111ebc8:	01000804 	movi	r4,32
8111ebcc:	2089c83a 	sub	r4,r4,r2
8111ebd0:	1914983a 	sll	r10,r3,r4
8111ebd4:	8890d83a 	srl	r8,r17,r2
8111ebd8:	8908983a 	sll	r4,r17,r4
8111ebdc:	1884d83a 	srl	r2,r3,r2
8111ebe0:	5222b03a 	or	r17,r10,r8
8111ebe4:	2006c03a 	cmpne	r3,r4,zero
8111ebe8:	88e2b03a 	or	r17,r17,r3
8111ebec:	3463c83a 	sub	r17,r6,r17
8111ebf0:	2885c83a 	sub	r2,r5,r2
8111ebf4:	344d803a 	cmpltu	r6,r6,r17
8111ebf8:	1187c83a 	sub	r3,r2,r6
8111ebfc:	4821883a 	mov	r16,r9
8111ec00:	3825883a 	mov	r18,r7
8111ec04:	003f2306 	br	8111e894 <__reset+0xfb0fe894>
8111ec08:	24d0b03a 	or	r8,r4,r19
8111ec0c:	40001b1e 	bne	r8,zero,8111ec7c <__subdf3+0x568>
8111ec10:	0005883a 	mov	r2,zero
8111ec14:	0009883a 	mov	r4,zero
8111ec18:	0021883a 	mov	r16,zero
8111ec1c:	003f4906 	br	8111e944 <__reset+0xfb0fe944>
8111ec20:	010007c4 	movi	r4,31
8111ec24:	20803a16 	blt	r4,r2,8111ed10 <__subdf3+0x5fc>
8111ec28:	01000804 	movi	r4,32
8111ec2c:	2089c83a 	sub	r4,r4,r2
8111ec30:	2912983a 	sll	r9,r5,r4
8111ec34:	3090d83a 	srl	r8,r6,r2
8111ec38:	3108983a 	sll	r4,r6,r4
8111ec3c:	2884d83a 	srl	r2,r5,r2
8111ec40:	4a12b03a 	or	r9,r9,r8
8111ec44:	2008c03a 	cmpne	r4,r4,zero
8111ec48:	4912b03a 	or	r9,r9,r4
8111ec4c:	003f4e06 	br	8111e988 <__reset+0xfb0fe988>
8111ec50:	1c48b03a 	or	r4,r3,r17
8111ec54:	20003c26 	beq	r4,zero,8111ed48 <__subdf3+0x634>
8111ec58:	0084303a 	nor	r2,zero,r2
8111ec5c:	1000381e 	bne	r2,zero,8111ed40 <__subdf3+0x62c>
8111ec60:	3463c83a 	sub	r17,r6,r17
8111ec64:	28c5c83a 	sub	r2,r5,r3
8111ec68:	344d803a 	cmpltu	r6,r6,r17
8111ec6c:	1187c83a 	sub	r3,r2,r6
8111ec70:	4821883a 	mov	r16,r9
8111ec74:	3825883a 	mov	r18,r7
8111ec78:	003f0606 	br	8111e894 <__reset+0xfb0fe894>
8111ec7c:	2023883a 	mov	r17,r4
8111ec80:	003f0906 	br	8111e8a8 <__reset+0xfb0fe8a8>
8111ec84:	0101ffc4 	movi	r4,2047
8111ec88:	813f3a1e 	bne	r16,r4,8111e974 <__reset+0xfb0fe974>
8111ec8c:	003ec406 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ec90:	0005883a 	mov	r2,zero
8111ec94:	003fb106 	br	8111eb5c <__reset+0xfb0feb5c>
8111ec98:	0005883a 	mov	r2,zero
8111ec9c:	003fbc06 	br	8111eb90 <__reset+0xfb0feb90>
8111eca0:	1c44b03a 	or	r2,r3,r17
8111eca4:	80008e1e 	bne	r16,zero,8111eee0 <__subdf3+0x7cc>
8111eca8:	1000c826 	beq	r2,zero,8111efcc <__subdf3+0x8b8>
8111ecac:	2984b03a 	or	r2,r5,r6
8111ecb0:	103ebb26 	beq	r2,zero,8111e7a0 <__reset+0xfb0fe7a0>
8111ecb4:	8989883a 	add	r4,r17,r6
8111ecb8:	1945883a 	add	r2,r3,r5
8111ecbc:	2447803a 	cmpltu	r3,r4,r17
8111ecc0:	1887883a 	add	r3,r3,r2
8111ecc4:	1880202c 	andhi	r2,r3,128
8111ecc8:	2023883a 	mov	r17,r4
8111eccc:	103f1626 	beq	r2,zero,8111e928 <__reset+0xfb0fe928>
8111ecd0:	00bfe034 	movhi	r2,65408
8111ecd4:	10bfffc4 	addi	r2,r2,-1
8111ecd8:	5021883a 	mov	r16,r10
8111ecdc:	1886703a 	and	r3,r3,r2
8111ece0:	003eaf06 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ece4:	3825883a 	mov	r18,r7
8111ece8:	003f0f06 	br	8111e928 <__reset+0xfb0fe928>
8111ecec:	1c44b03a 	or	r2,r3,r17
8111ecf0:	8000251e 	bne	r16,zero,8111ed88 <__subdf3+0x674>
8111ecf4:	1000661e 	bne	r2,zero,8111ee90 <__subdf3+0x77c>
8111ecf8:	2990b03a 	or	r8,r5,r6
8111ecfc:	40009626 	beq	r8,zero,8111ef58 <__subdf3+0x844>
8111ed00:	2807883a 	mov	r3,r5
8111ed04:	3023883a 	mov	r17,r6
8111ed08:	3825883a 	mov	r18,r7
8111ed0c:	003ea406 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ed10:	127ff804 	addi	r9,r2,-32
8111ed14:	01000804 	movi	r4,32
8111ed18:	2a52d83a 	srl	r9,r5,r9
8111ed1c:	11008c26 	beq	r2,r4,8111ef50 <__subdf3+0x83c>
8111ed20:	01001004 	movi	r4,64
8111ed24:	2085c83a 	sub	r2,r4,r2
8111ed28:	2884983a 	sll	r2,r5,r2
8111ed2c:	118cb03a 	or	r6,r2,r6
8111ed30:	300cc03a 	cmpne	r6,r6,zero
8111ed34:	4992b03a 	or	r9,r9,r6
8111ed38:	0005883a 	mov	r2,zero
8111ed3c:	003f1206 	br	8111e988 <__reset+0xfb0fe988>
8111ed40:	0101ffc4 	movi	r4,2047
8111ed44:	493f9c1e 	bne	r9,r4,8111ebb8 <__reset+0xfb0febb8>
8111ed48:	2807883a 	mov	r3,r5
8111ed4c:	3023883a 	mov	r17,r6
8111ed50:	4821883a 	mov	r16,r9
8111ed54:	3825883a 	mov	r18,r7
8111ed58:	003e9106 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ed5c:	80001f1e 	bne	r16,zero,8111eddc <__subdf3+0x6c8>
8111ed60:	1c48b03a 	or	r4,r3,r17
8111ed64:	20005a26 	beq	r4,zero,8111eed0 <__subdf3+0x7bc>
8111ed68:	0084303a 	nor	r2,zero,r2
8111ed6c:	1000561e 	bne	r2,zero,8111eec8 <__subdf3+0x7b4>
8111ed70:	89a3883a 	add	r17,r17,r6
8111ed74:	1945883a 	add	r2,r3,r5
8111ed78:	898d803a 	cmpltu	r6,r17,r6
8111ed7c:	3087883a 	add	r3,r6,r2
8111ed80:	4821883a 	mov	r16,r9
8111ed84:	003f0506 	br	8111e99c <__reset+0xfb0fe99c>
8111ed88:	10002b1e 	bne	r2,zero,8111ee38 <__subdf3+0x724>
8111ed8c:	2984b03a 	or	r2,r5,r6
8111ed90:	10008026 	beq	r2,zero,8111ef94 <__subdf3+0x880>
8111ed94:	2807883a 	mov	r3,r5
8111ed98:	3023883a 	mov	r17,r6
8111ed9c:	3825883a 	mov	r18,r7
8111eda0:	0401ffc4 	movi	r16,2047
8111eda4:	003e7e06 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111eda8:	3809883a 	mov	r4,r7
8111edac:	0011883a 	mov	r8,zero
8111edb0:	0005883a 	mov	r2,zero
8111edb4:	003ee306 	br	8111e944 <__reset+0xfb0fe944>
8111edb8:	1c62b03a 	or	r17,r3,r17
8111edbc:	8822c03a 	cmpne	r17,r17,zero
8111edc0:	0005883a 	mov	r2,zero
8111edc4:	003f8906 	br	8111ebec <__reset+0xfb0febec>
8111edc8:	3809883a 	mov	r4,r7
8111edcc:	4821883a 	mov	r16,r9
8111edd0:	0011883a 	mov	r8,zero
8111edd4:	0005883a 	mov	r2,zero
8111edd8:	003eda06 	br	8111e944 <__reset+0xfb0fe944>
8111eddc:	0101ffc4 	movi	r4,2047
8111ede0:	49003b26 	beq	r9,r4,8111eed0 <__subdf3+0x7bc>
8111ede4:	0085c83a 	sub	r2,zero,r2
8111ede8:	18c02034 	orhi	r3,r3,128
8111edec:	01000e04 	movi	r4,56
8111edf0:	20806e16 	blt	r4,r2,8111efac <__subdf3+0x898>
8111edf4:	010007c4 	movi	r4,31
8111edf8:	20807716 	blt	r4,r2,8111efd8 <__subdf3+0x8c4>
8111edfc:	01000804 	movi	r4,32
8111ee00:	2089c83a 	sub	r4,r4,r2
8111ee04:	1914983a 	sll	r10,r3,r4
8111ee08:	8890d83a 	srl	r8,r17,r2
8111ee0c:	8908983a 	sll	r4,r17,r4
8111ee10:	1884d83a 	srl	r2,r3,r2
8111ee14:	5222b03a 	or	r17,r10,r8
8111ee18:	2006c03a 	cmpne	r3,r4,zero
8111ee1c:	88e2b03a 	or	r17,r17,r3
8111ee20:	89a3883a 	add	r17,r17,r6
8111ee24:	1145883a 	add	r2,r2,r5
8111ee28:	898d803a 	cmpltu	r6,r17,r6
8111ee2c:	3087883a 	add	r3,r6,r2
8111ee30:	4821883a 	mov	r16,r9
8111ee34:	003ed906 	br	8111e99c <__reset+0xfb0fe99c>
8111ee38:	2984b03a 	or	r2,r5,r6
8111ee3c:	10004226 	beq	r2,zero,8111ef48 <__subdf3+0x834>
8111ee40:	1808d0fa 	srli	r4,r3,3
8111ee44:	8822d0fa 	srli	r17,r17,3
8111ee48:	1806977a 	slli	r3,r3,29
8111ee4c:	2080022c 	andhi	r2,r4,8
8111ee50:	1c62b03a 	or	r17,r3,r17
8111ee54:	10000826 	beq	r2,zero,8111ee78 <__subdf3+0x764>
8111ee58:	2812d0fa 	srli	r9,r5,3
8111ee5c:	4880022c 	andhi	r2,r9,8
8111ee60:	1000051e 	bne	r2,zero,8111ee78 <__subdf3+0x764>
8111ee64:	300cd0fa 	srli	r6,r6,3
8111ee68:	2804977a 	slli	r2,r5,29
8111ee6c:	4809883a 	mov	r4,r9
8111ee70:	3825883a 	mov	r18,r7
8111ee74:	11a2b03a 	or	r17,r2,r6
8111ee78:	8806d77a 	srli	r3,r17,29
8111ee7c:	200890fa 	slli	r4,r4,3
8111ee80:	882290fa 	slli	r17,r17,3
8111ee84:	0401ffc4 	movi	r16,2047
8111ee88:	1906b03a 	or	r3,r3,r4
8111ee8c:	003e4406 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ee90:	2984b03a 	or	r2,r5,r6
8111ee94:	103e4226 	beq	r2,zero,8111e7a0 <__reset+0xfb0fe7a0>
8111ee98:	8989c83a 	sub	r4,r17,r6
8111ee9c:	8911803a 	cmpltu	r8,r17,r4
8111eea0:	1945c83a 	sub	r2,r3,r5
8111eea4:	1205c83a 	sub	r2,r2,r8
8111eea8:	1200202c 	andhi	r8,r2,128
8111eeac:	403e9a26 	beq	r8,zero,8111e918 <__reset+0xfb0fe918>
8111eeb0:	3463c83a 	sub	r17,r6,r17
8111eeb4:	28c5c83a 	sub	r2,r5,r3
8111eeb8:	344d803a 	cmpltu	r6,r6,r17
8111eebc:	1187c83a 	sub	r3,r2,r6
8111eec0:	3825883a 	mov	r18,r7
8111eec4:	003e3606 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111eec8:	0101ffc4 	movi	r4,2047
8111eecc:	493fc71e 	bne	r9,r4,8111edec <__reset+0xfb0fedec>
8111eed0:	2807883a 	mov	r3,r5
8111eed4:	3023883a 	mov	r17,r6
8111eed8:	4821883a 	mov	r16,r9
8111eedc:	003e3006 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111eee0:	10003626 	beq	r2,zero,8111efbc <__subdf3+0x8a8>
8111eee4:	2984b03a 	or	r2,r5,r6
8111eee8:	10001726 	beq	r2,zero,8111ef48 <__subdf3+0x834>
8111eeec:	1808d0fa 	srli	r4,r3,3
8111eef0:	8822d0fa 	srli	r17,r17,3
8111eef4:	1806977a 	slli	r3,r3,29
8111eef8:	2080022c 	andhi	r2,r4,8
8111eefc:	1c62b03a 	or	r17,r3,r17
8111ef00:	10000726 	beq	r2,zero,8111ef20 <__subdf3+0x80c>
8111ef04:	2812d0fa 	srli	r9,r5,3
8111ef08:	4880022c 	andhi	r2,r9,8
8111ef0c:	1000041e 	bne	r2,zero,8111ef20 <__subdf3+0x80c>
8111ef10:	300cd0fa 	srli	r6,r6,3
8111ef14:	2804977a 	slli	r2,r5,29
8111ef18:	4809883a 	mov	r4,r9
8111ef1c:	11a2b03a 	or	r17,r2,r6
8111ef20:	8806d77a 	srli	r3,r17,29
8111ef24:	200890fa 	slli	r4,r4,3
8111ef28:	882290fa 	slli	r17,r17,3
8111ef2c:	3825883a 	mov	r18,r7
8111ef30:	1906b03a 	or	r3,r3,r4
8111ef34:	0401ffc4 	movi	r16,2047
8111ef38:	003e1906 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ef3c:	000b883a 	mov	r5,zero
8111ef40:	0005883a 	mov	r2,zero
8111ef44:	003e2e06 	br	8111e800 <__reset+0xfb0fe800>
8111ef48:	0401ffc4 	movi	r16,2047
8111ef4c:	003e1406 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111ef50:	0005883a 	mov	r2,zero
8111ef54:	003f7506 	br	8111ed2c <__reset+0xfb0fed2c>
8111ef58:	0005883a 	mov	r2,zero
8111ef5c:	0009883a 	mov	r4,zero
8111ef60:	003e7806 	br	8111e944 <__reset+0xfb0fe944>
8111ef64:	123ff804 	addi	r8,r2,-32
8111ef68:	01000804 	movi	r4,32
8111ef6c:	1a10d83a 	srl	r8,r3,r8
8111ef70:	11002526 	beq	r2,r4,8111f008 <__subdf3+0x8f4>
8111ef74:	01001004 	movi	r4,64
8111ef78:	2085c83a 	sub	r2,r4,r2
8111ef7c:	1884983a 	sll	r2,r3,r2
8111ef80:	1444b03a 	or	r2,r2,r17
8111ef84:	1004c03a 	cmpne	r2,r2,zero
8111ef88:	40a2b03a 	or	r17,r8,r2
8111ef8c:	0005883a 	mov	r2,zero
8111ef90:	003f1606 	br	8111ebec <__reset+0xfb0febec>
8111ef94:	02000434 	movhi	r8,16
8111ef98:	0009883a 	mov	r4,zero
8111ef9c:	423fffc4 	addi	r8,r8,-1
8111efa0:	00bfffc4 	movi	r2,-1
8111efa4:	0401ffc4 	movi	r16,2047
8111efa8:	003e6606 	br	8111e944 <__reset+0xfb0fe944>
8111efac:	1c62b03a 	or	r17,r3,r17
8111efb0:	8822c03a 	cmpne	r17,r17,zero
8111efb4:	0005883a 	mov	r2,zero
8111efb8:	003f9906 	br	8111ee20 <__reset+0xfb0fee20>
8111efbc:	2807883a 	mov	r3,r5
8111efc0:	3023883a 	mov	r17,r6
8111efc4:	0401ffc4 	movi	r16,2047
8111efc8:	003df506 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111efcc:	2807883a 	mov	r3,r5
8111efd0:	3023883a 	mov	r17,r6
8111efd4:	003df206 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111efd8:	123ff804 	addi	r8,r2,-32
8111efdc:	01000804 	movi	r4,32
8111efe0:	1a10d83a 	srl	r8,r3,r8
8111efe4:	11000a26 	beq	r2,r4,8111f010 <__subdf3+0x8fc>
8111efe8:	01001004 	movi	r4,64
8111efec:	2085c83a 	sub	r2,r4,r2
8111eff0:	1884983a 	sll	r2,r3,r2
8111eff4:	1444b03a 	or	r2,r2,r17
8111eff8:	1004c03a 	cmpne	r2,r2,zero
8111effc:	40a2b03a 	or	r17,r8,r2
8111f000:	0005883a 	mov	r2,zero
8111f004:	003f8606 	br	8111ee20 <__reset+0xfb0fee20>
8111f008:	0005883a 	mov	r2,zero
8111f00c:	003fdc06 	br	8111ef80 <__reset+0xfb0fef80>
8111f010:	0005883a 	mov	r2,zero
8111f014:	003ff706 	br	8111eff4 <__reset+0xfb0feff4>

8111f018 <__fixdfsi>:
8111f018:	280cd53a 	srli	r6,r5,20
8111f01c:	00c00434 	movhi	r3,16
8111f020:	18ffffc4 	addi	r3,r3,-1
8111f024:	3181ffcc 	andi	r6,r6,2047
8111f028:	01c0ff84 	movi	r7,1022
8111f02c:	28c6703a 	and	r3,r5,r3
8111f030:	280ad7fa 	srli	r5,r5,31
8111f034:	3980120e 	bge	r7,r6,8111f080 <__fixdfsi+0x68>
8111f038:	00810744 	movi	r2,1053
8111f03c:	11800c16 	blt	r2,r6,8111f070 <__fixdfsi+0x58>
8111f040:	00810cc4 	movi	r2,1075
8111f044:	1185c83a 	sub	r2,r2,r6
8111f048:	01c007c4 	movi	r7,31
8111f04c:	18c00434 	orhi	r3,r3,16
8111f050:	38800d16 	blt	r7,r2,8111f088 <__fixdfsi+0x70>
8111f054:	31befb44 	addi	r6,r6,-1043
8111f058:	2084d83a 	srl	r2,r4,r2
8111f05c:	1986983a 	sll	r3,r3,r6
8111f060:	1884b03a 	or	r2,r3,r2
8111f064:	28000726 	beq	r5,zero,8111f084 <__fixdfsi+0x6c>
8111f068:	0085c83a 	sub	r2,zero,r2
8111f06c:	f800283a 	ret
8111f070:	00a00034 	movhi	r2,32768
8111f074:	10bfffc4 	addi	r2,r2,-1
8111f078:	2885883a 	add	r2,r5,r2
8111f07c:	f800283a 	ret
8111f080:	0005883a 	mov	r2,zero
8111f084:	f800283a 	ret
8111f088:	008104c4 	movi	r2,1043
8111f08c:	1185c83a 	sub	r2,r2,r6
8111f090:	1884d83a 	srl	r2,r3,r2
8111f094:	003ff306 	br	8111f064 <__reset+0xfb0ff064>

8111f098 <__floatsidf>:
8111f098:	defffd04 	addi	sp,sp,-12
8111f09c:	de00012e 	bgeu	sp,et,8111f0a4 <__floatsidf+0xc>
8111f0a0:	003b68fa 	trap	3
8111f0a4:	dfc00215 	stw	ra,8(sp)
8111f0a8:	dc400115 	stw	r17,4(sp)
8111f0ac:	dc000015 	stw	r16,0(sp)
8111f0b0:	20002b26 	beq	r4,zero,8111f160 <__floatsidf+0xc8>
8111f0b4:	2023883a 	mov	r17,r4
8111f0b8:	2020d7fa 	srli	r16,r4,31
8111f0bc:	20002d16 	blt	r4,zero,8111f174 <__floatsidf+0xdc>
8111f0c0:	8809883a 	mov	r4,r17
8111f0c4:	111f43c0 	call	8111f43c <__clzsi2>
8111f0c8:	01410784 	movi	r5,1054
8111f0cc:	288bc83a 	sub	r5,r5,r2
8111f0d0:	01010cc4 	movi	r4,1075
8111f0d4:	2149c83a 	sub	r4,r4,r5
8111f0d8:	00c007c4 	movi	r3,31
8111f0dc:	1900160e 	bge	r3,r4,8111f138 <__floatsidf+0xa0>
8111f0e0:	00c104c4 	movi	r3,1043
8111f0e4:	1947c83a 	sub	r3,r3,r5
8111f0e8:	88c6983a 	sll	r3,r17,r3
8111f0ec:	00800434 	movhi	r2,16
8111f0f0:	10bfffc4 	addi	r2,r2,-1
8111f0f4:	1886703a 	and	r3,r3,r2
8111f0f8:	2941ffcc 	andi	r5,r5,2047
8111f0fc:	800d883a 	mov	r6,r16
8111f100:	0005883a 	mov	r2,zero
8111f104:	280a953a 	slli	r5,r5,20
8111f108:	31803fcc 	andi	r6,r6,255
8111f10c:	01000434 	movhi	r4,16
8111f110:	300c97fa 	slli	r6,r6,31
8111f114:	213fffc4 	addi	r4,r4,-1
8111f118:	1906703a 	and	r3,r3,r4
8111f11c:	1946b03a 	or	r3,r3,r5
8111f120:	1986b03a 	or	r3,r3,r6
8111f124:	dfc00217 	ldw	ra,8(sp)
8111f128:	dc400117 	ldw	r17,4(sp)
8111f12c:	dc000017 	ldw	r16,0(sp)
8111f130:	dec00304 	addi	sp,sp,12
8111f134:	f800283a 	ret
8111f138:	00c002c4 	movi	r3,11
8111f13c:	1887c83a 	sub	r3,r3,r2
8111f140:	88c6d83a 	srl	r3,r17,r3
8111f144:	8904983a 	sll	r2,r17,r4
8111f148:	01000434 	movhi	r4,16
8111f14c:	213fffc4 	addi	r4,r4,-1
8111f150:	2941ffcc 	andi	r5,r5,2047
8111f154:	1906703a 	and	r3,r3,r4
8111f158:	800d883a 	mov	r6,r16
8111f15c:	003fe906 	br	8111f104 <__reset+0xfb0ff104>
8111f160:	000d883a 	mov	r6,zero
8111f164:	000b883a 	mov	r5,zero
8111f168:	0007883a 	mov	r3,zero
8111f16c:	0005883a 	mov	r2,zero
8111f170:	003fe406 	br	8111f104 <__reset+0xfb0ff104>
8111f174:	0123c83a 	sub	r17,zero,r4
8111f178:	003fd106 	br	8111f0c0 <__reset+0xfb0ff0c0>

8111f17c <__extendsfdf2>:
8111f17c:	200ad5fa 	srli	r5,r4,23
8111f180:	defffd04 	addi	sp,sp,-12
8111f184:	de00012e 	bgeu	sp,et,8111f18c <__extendsfdf2+0x10>
8111f188:	003b68fa 	trap	3
8111f18c:	29403fcc 	andi	r5,r5,255
8111f190:	dc400115 	stw	r17,4(sp)
8111f194:	29800044 	addi	r6,r5,1
8111f198:	04402034 	movhi	r17,128
8111f19c:	dc000015 	stw	r16,0(sp)
8111f1a0:	8c7fffc4 	addi	r17,r17,-1
8111f1a4:	dfc00215 	stw	ra,8(sp)
8111f1a8:	31803fcc 	andi	r6,r6,255
8111f1ac:	00800044 	movi	r2,1
8111f1b0:	8922703a 	and	r17,r17,r4
8111f1b4:	2020d7fa 	srli	r16,r4,31
8111f1b8:	1180110e 	bge	r2,r6,8111f200 <__extendsfdf2+0x84>
8111f1bc:	880cd0fa 	srli	r6,r17,3
8111f1c0:	8822977a 	slli	r17,r17,29
8111f1c4:	2940e004 	addi	r5,r5,896
8111f1c8:	2941ffcc 	andi	r5,r5,2047
8111f1cc:	2804953a 	slli	r2,r5,20
8111f1d0:	01400434 	movhi	r5,16
8111f1d4:	800697fa 	slli	r3,r16,31
8111f1d8:	297fffc4 	addi	r5,r5,-1
8111f1dc:	314a703a 	and	r5,r6,r5
8111f1e0:	288ab03a 	or	r5,r5,r2
8111f1e4:	28c6b03a 	or	r3,r5,r3
8111f1e8:	8805883a 	mov	r2,r17
8111f1ec:	dfc00217 	ldw	ra,8(sp)
8111f1f0:	dc400117 	ldw	r17,4(sp)
8111f1f4:	dc000017 	ldw	r16,0(sp)
8111f1f8:	dec00304 	addi	sp,sp,12
8111f1fc:	f800283a 	ret
8111f200:	2800111e 	bne	r5,zero,8111f248 <__extendsfdf2+0xcc>
8111f204:	88001c26 	beq	r17,zero,8111f278 <__extendsfdf2+0xfc>
8111f208:	8809883a 	mov	r4,r17
8111f20c:	111f43c0 	call	8111f43c <__clzsi2>
8111f210:	00c00284 	movi	r3,10
8111f214:	18801b16 	blt	r3,r2,8111f284 <__extendsfdf2+0x108>
8111f218:	018002c4 	movi	r6,11
8111f21c:	308dc83a 	sub	r6,r6,r2
8111f220:	11000544 	addi	r4,r2,21
8111f224:	8986d83a 	srl	r3,r17,r6
8111f228:	8922983a 	sll	r17,r17,r4
8111f22c:	0180e244 	movi	r6,905
8111f230:	01400434 	movhi	r5,16
8111f234:	3085c83a 	sub	r2,r6,r2
8111f238:	297fffc4 	addi	r5,r5,-1
8111f23c:	194c703a 	and	r6,r3,r5
8111f240:	1141ffcc 	andi	r5,r2,2047
8111f244:	003fe006 	br	8111f1c8 <__reset+0xfb0ff1c8>
8111f248:	88000826 	beq	r17,zero,8111f26c <__extendsfdf2+0xf0>
8111f24c:	880cd0fa 	srli	r6,r17,3
8111f250:	00800434 	movhi	r2,16
8111f254:	10bfffc4 	addi	r2,r2,-1
8111f258:	31800234 	orhi	r6,r6,8
8111f25c:	8822977a 	slli	r17,r17,29
8111f260:	308c703a 	and	r6,r6,r2
8111f264:	0141ffc4 	movi	r5,2047
8111f268:	003fd706 	br	8111f1c8 <__reset+0xfb0ff1c8>
8111f26c:	0141ffc4 	movi	r5,2047
8111f270:	000d883a 	mov	r6,zero
8111f274:	003fd406 	br	8111f1c8 <__reset+0xfb0ff1c8>
8111f278:	000b883a 	mov	r5,zero
8111f27c:	000d883a 	mov	r6,zero
8111f280:	003fd106 	br	8111f1c8 <__reset+0xfb0ff1c8>
8111f284:	11bffd44 	addi	r6,r2,-11
8111f288:	8986983a 	sll	r3,r17,r6
8111f28c:	0023883a 	mov	r17,zero
8111f290:	003fe606 	br	8111f22c <__reset+0xfb0ff22c>

8111f294 <__truncdfsf2>:
8111f294:	2810d53a 	srli	r8,r5,20
8111f298:	01c00434 	movhi	r7,16
8111f29c:	39ffffc4 	addi	r7,r7,-1
8111f2a0:	29ce703a 	and	r7,r5,r7
8111f2a4:	4201ffcc 	andi	r8,r8,2047
8111f2a8:	380e90fa 	slli	r7,r7,3
8111f2ac:	200cd77a 	srli	r6,r4,29
8111f2b0:	42400044 	addi	r9,r8,1
8111f2b4:	4a41ffcc 	andi	r9,r9,2047
8111f2b8:	00c00044 	movi	r3,1
8111f2bc:	280ad7fa 	srli	r5,r5,31
8111f2c0:	31ceb03a 	or	r7,r6,r7
8111f2c4:	200490fa 	slli	r2,r4,3
8111f2c8:	1a40230e 	bge	r3,r9,8111f358 <__truncdfsf2+0xc4>
8111f2cc:	40ff2004 	addi	r3,r8,-896
8111f2d0:	01803f84 	movi	r6,254
8111f2d4:	30c01516 	blt	r6,r3,8111f32c <__truncdfsf2+0x98>
8111f2d8:	00c0380e 	bge	zero,r3,8111f3bc <__truncdfsf2+0x128>
8111f2dc:	200c91ba 	slli	r6,r4,6
8111f2e0:	380e90fa 	slli	r7,r7,3
8111f2e4:	1004d77a 	srli	r2,r2,29
8111f2e8:	300cc03a 	cmpne	r6,r6,zero
8111f2ec:	31ccb03a 	or	r6,r6,r7
8111f2f0:	308cb03a 	or	r6,r6,r2
8111f2f4:	308001cc 	andi	r2,r6,7
8111f2f8:	10000426 	beq	r2,zero,8111f30c <__truncdfsf2+0x78>
8111f2fc:	308003cc 	andi	r2,r6,15
8111f300:	01000104 	movi	r4,4
8111f304:	11000126 	beq	r2,r4,8111f30c <__truncdfsf2+0x78>
8111f308:	31800104 	addi	r6,r6,4
8111f30c:	3081002c 	andhi	r2,r6,1024
8111f310:	10001626 	beq	r2,zero,8111f36c <__truncdfsf2+0xd8>
8111f314:	18c00044 	addi	r3,r3,1
8111f318:	00803fc4 	movi	r2,255
8111f31c:	18800326 	beq	r3,r2,8111f32c <__truncdfsf2+0x98>
8111f320:	300c91ba 	slli	r6,r6,6
8111f324:	300cd27a 	srli	r6,r6,9
8111f328:	00000206 	br	8111f334 <__truncdfsf2+0xa0>
8111f32c:	00ffffc4 	movi	r3,-1
8111f330:	000d883a 	mov	r6,zero
8111f334:	18c03fcc 	andi	r3,r3,255
8111f338:	180895fa 	slli	r4,r3,23
8111f33c:	00c02034 	movhi	r3,128
8111f340:	280a97fa 	slli	r5,r5,31
8111f344:	18ffffc4 	addi	r3,r3,-1
8111f348:	30c6703a 	and	r3,r6,r3
8111f34c:	1906b03a 	or	r3,r3,r4
8111f350:	1944b03a 	or	r2,r3,r5
8111f354:	f800283a 	ret
8111f358:	40000b1e 	bne	r8,zero,8111f388 <__truncdfsf2+0xf4>
8111f35c:	388cb03a 	or	r6,r7,r2
8111f360:	0007883a 	mov	r3,zero
8111f364:	30000426 	beq	r6,zero,8111f378 <__truncdfsf2+0xe4>
8111f368:	01800144 	movi	r6,5
8111f36c:	00803fc4 	movi	r2,255
8111f370:	300cd0fa 	srli	r6,r6,3
8111f374:	18800a26 	beq	r3,r2,8111f3a0 <__truncdfsf2+0x10c>
8111f378:	00802034 	movhi	r2,128
8111f37c:	10bfffc4 	addi	r2,r2,-1
8111f380:	308c703a 	and	r6,r6,r2
8111f384:	003feb06 	br	8111f334 <__reset+0xfb0ff334>
8111f388:	3888b03a 	or	r4,r7,r2
8111f38c:	203fe726 	beq	r4,zero,8111f32c <__reset+0xfb0ff32c>
8111f390:	380c90fa 	slli	r6,r7,3
8111f394:	00c03fc4 	movi	r3,255
8111f398:	31808034 	orhi	r6,r6,512
8111f39c:	003fd506 	br	8111f2f4 <__reset+0xfb0ff2f4>
8111f3a0:	303fe226 	beq	r6,zero,8111f32c <__reset+0xfb0ff32c>
8111f3a4:	00802034 	movhi	r2,128
8111f3a8:	31801034 	orhi	r6,r6,64
8111f3ac:	10bfffc4 	addi	r2,r2,-1
8111f3b0:	00ffffc4 	movi	r3,-1
8111f3b4:	308c703a 	and	r6,r6,r2
8111f3b8:	003fde06 	br	8111f334 <__reset+0xfb0ff334>
8111f3bc:	013ffa44 	movi	r4,-23
8111f3c0:	19000e16 	blt	r3,r4,8111f3fc <__truncdfsf2+0x168>
8111f3c4:	01000784 	movi	r4,30
8111f3c8:	20c9c83a 	sub	r4,r4,r3
8111f3cc:	018007c4 	movi	r6,31
8111f3d0:	39c02034 	orhi	r7,r7,128
8111f3d4:	31000b16 	blt	r6,r4,8111f404 <__truncdfsf2+0x170>
8111f3d8:	423f2084 	addi	r8,r8,-894
8111f3dc:	120c983a 	sll	r6,r2,r8
8111f3e0:	3a0e983a 	sll	r7,r7,r8
8111f3e4:	1104d83a 	srl	r2,r2,r4
8111f3e8:	300cc03a 	cmpne	r6,r6,zero
8111f3ec:	31ceb03a 	or	r7,r6,r7
8111f3f0:	388cb03a 	or	r6,r7,r2
8111f3f4:	0007883a 	mov	r3,zero
8111f3f8:	003fbe06 	br	8111f2f4 <__reset+0xfb0ff2f4>
8111f3fc:	0007883a 	mov	r3,zero
8111f400:	003fd906 	br	8111f368 <__reset+0xfb0ff368>
8111f404:	01bfff84 	movi	r6,-2
8111f408:	30cdc83a 	sub	r6,r6,r3
8111f40c:	00c00804 	movi	r3,32
8111f410:	398cd83a 	srl	r6,r7,r6
8111f414:	20c00726 	beq	r4,r3,8111f434 <__truncdfsf2+0x1a0>
8111f418:	423f2884 	addi	r8,r8,-862
8111f41c:	3a0e983a 	sll	r7,r7,r8
8111f420:	3884b03a 	or	r2,r7,r2
8111f424:	1004c03a 	cmpne	r2,r2,zero
8111f428:	118cb03a 	or	r6,r2,r6
8111f42c:	0007883a 	mov	r3,zero
8111f430:	003fb006 	br	8111f2f4 <__reset+0xfb0ff2f4>
8111f434:	000f883a 	mov	r7,zero
8111f438:	003ff906 	br	8111f420 <__reset+0xfb0ff420>

8111f43c <__clzsi2>:
8111f43c:	00bfffd4 	movui	r2,65535
8111f440:	11000536 	bltu	r2,r4,8111f458 <__clzsi2+0x1c>
8111f444:	00803fc4 	movi	r2,255
8111f448:	11000f36 	bltu	r2,r4,8111f488 <__clzsi2+0x4c>
8111f44c:	00800804 	movi	r2,32
8111f450:	0007883a 	mov	r3,zero
8111f454:	00000506 	br	8111f46c <__clzsi2+0x30>
8111f458:	00804034 	movhi	r2,256
8111f45c:	10bfffc4 	addi	r2,r2,-1
8111f460:	11000c2e 	bgeu	r2,r4,8111f494 <__clzsi2+0x58>
8111f464:	00800204 	movi	r2,8
8111f468:	00c00604 	movi	r3,24
8111f46c:	20c8d83a 	srl	r4,r4,r3
8111f470:	00e04574 	movhi	r3,33045
8111f474:	18f80b04 	addi	r3,r3,-8148
8111f478:	1909883a 	add	r4,r3,r4
8111f47c:	20c00003 	ldbu	r3,0(r4)
8111f480:	10c5c83a 	sub	r2,r2,r3
8111f484:	f800283a 	ret
8111f488:	00800604 	movi	r2,24
8111f48c:	00c00204 	movi	r3,8
8111f490:	003ff606 	br	8111f46c <__reset+0xfb0ff46c>
8111f494:	00800404 	movi	r2,16
8111f498:	1007883a 	mov	r3,r2
8111f49c:	003ff306 	br	8111f46c <__reset+0xfb0ff46c>

8111f4a0 <atoi>:
8111f4a0:	01800284 	movi	r6,10
8111f4a4:	000b883a 	mov	r5,zero
8111f4a8:	11214bc1 	jmpi	811214bc <strtol>

8111f4ac <_atoi_r>:
8111f4ac:	01c00284 	movi	r7,10
8111f4b0:	000d883a 	mov	r6,zero
8111f4b4:	112127c1 	jmpi	8112127c <_strtol_r>

8111f4b8 <_fopen_r>:
8111f4b8:	defffa04 	addi	sp,sp,-24
8111f4bc:	3005883a 	mov	r2,r6
8111f4c0:	de00012e 	bgeu	sp,et,8111f4c8 <_fopen_r+0x10>
8111f4c4:	003b68fa 	trap	3
8111f4c8:	d80d883a 	mov	r6,sp
8111f4cc:	dcc00415 	stw	r19,16(sp)
8111f4d0:	2827883a 	mov	r19,r5
8111f4d4:	100b883a 	mov	r5,r2
8111f4d8:	dc800315 	stw	r18,12(sp)
8111f4dc:	dfc00515 	stw	ra,20(sp)
8111f4e0:	dc400215 	stw	r17,8(sp)
8111f4e4:	dc000115 	stw	r16,4(sp)
8111f4e8:	2025883a 	mov	r18,r4
8111f4ec:	11294c40 	call	811294c4 <__sflags>
8111f4f0:	10002726 	beq	r2,zero,8111f590 <_fopen_r+0xd8>
8111f4f4:	9009883a 	mov	r4,r18
8111f4f8:	1023883a 	mov	r17,r2
8111f4fc:	112933c0 	call	8112933c <__sfp>
8111f500:	1021883a 	mov	r16,r2
8111f504:	10002226 	beq	r2,zero,8111f590 <_fopen_r+0xd8>
8111f508:	d9800017 	ldw	r6,0(sp)
8111f50c:	01c06d84 	movi	r7,438
8111f510:	980b883a 	mov	r5,r19
8111f514:	9009883a 	mov	r4,r18
8111f518:	11209240 	call	81120924 <_open_r>
8111f51c:	10001916 	blt	r2,zero,8111f584 <_fopen_r+0xcc>
8111f520:	8080038d 	sth	r2,14(r16)
8111f524:	00a044b4 	movhi	r2,33042
8111f528:	10840004 	addi	r2,r2,4096
8111f52c:	80800815 	stw	r2,32(r16)
8111f530:	00a044b4 	movhi	r2,33042
8111f534:	10841904 	addi	r2,r2,4196
8111f538:	80800915 	stw	r2,36(r16)
8111f53c:	00a044b4 	movhi	r2,33042
8111f540:	10843a04 	addi	r2,r2,4328
8111f544:	80800a15 	stw	r2,40(r16)
8111f548:	00a044b4 	movhi	r2,33042
8111f54c:	10845304 	addi	r2,r2,4428
8111f550:	8440030d 	sth	r17,12(r16)
8111f554:	84000715 	stw	r16,28(r16)
8111f558:	80800b15 	stw	r2,44(r16)
8111f55c:	8c40400c 	andi	r17,r17,256
8111f560:	88000d1e 	bne	r17,zero,8111f598 <_fopen_r+0xe0>
8111f564:	8005883a 	mov	r2,r16
8111f568:	dfc00517 	ldw	ra,20(sp)
8111f56c:	dcc00417 	ldw	r19,16(sp)
8111f570:	dc800317 	ldw	r18,12(sp)
8111f574:	dc400217 	ldw	r17,8(sp)
8111f578:	dc000117 	ldw	r16,4(sp)
8111f57c:	dec00604 	addi	sp,sp,24
8111f580:	f800283a 	ret
8111f584:	11294840 	call	81129484 <__sfp_lock_acquire>
8111f588:	8000030d 	sth	zero,12(r16)
8111f58c:	11294880 	call	81129488 <__sfp_lock_release>
8111f590:	0005883a 	mov	r2,zero
8111f594:	003ff406 	br	8111f568 <__reset+0xfb0ff568>
8111f598:	01c00084 	movi	r7,2
8111f59c:	000d883a 	mov	r6,zero
8111f5a0:	800b883a 	mov	r5,r16
8111f5a4:	9009883a 	mov	r4,r18
8111f5a8:	111f6d80 	call	8111f6d8 <_fseek_r>
8111f5ac:	8005883a 	mov	r2,r16
8111f5b0:	003fed06 	br	8111f568 <__reset+0xfb0ff568>

8111f5b4 <fopen>:
8111f5b4:	00a04574 	movhi	r2,33045
8111f5b8:	1082c604 	addi	r2,r2,2840
8111f5bc:	280d883a 	mov	r6,r5
8111f5c0:	200b883a 	mov	r5,r4
8111f5c4:	11000017 	ldw	r4,0(r2)
8111f5c8:	111f4b81 	jmpi	8111f4b8 <_fopen_r>

8111f5cc <_fprintf_r>:
8111f5cc:	defffe04 	addi	sp,sp,-8
8111f5d0:	2809883a 	mov	r4,r5
8111f5d4:	300b883a 	mov	r5,r6
8111f5d8:	de00012e 	bgeu	sp,et,8111f5e0 <_fprintf_r+0x14>
8111f5dc:	003b68fa 	trap	3
8111f5e0:	dfc00015 	stw	ra,0(sp)
8111f5e4:	d9c00115 	stw	r7,4(sp)
8111f5e8:	d9800104 	addi	r6,sp,4
8111f5ec:	11258b80 	call	811258b8 <__vfprintf_internal>
8111f5f0:	dfc00017 	ldw	ra,0(sp)
8111f5f4:	dec00204 	addi	sp,sp,8
8111f5f8:	f800283a 	ret

8111f5fc <fprintf>:
8111f5fc:	defffd04 	addi	sp,sp,-12
8111f600:	de00012e 	bgeu	sp,et,8111f608 <fprintf+0xc>
8111f604:	003b68fa 	trap	3
8111f608:	dfc00015 	stw	ra,0(sp)
8111f60c:	d9800115 	stw	r6,4(sp)
8111f610:	d9c00215 	stw	r7,8(sp)
8111f614:	d9800104 	addi	r6,sp,4
8111f618:	11258b80 	call	811258b8 <__vfprintf_internal>
8111f61c:	dfc00017 	ldw	ra,0(sp)
8111f620:	dec00304 	addi	sp,sp,12
8111f624:	f800283a 	ret

8111f628 <_fputc_r>:
8111f628:	defffc04 	addi	sp,sp,-16
8111f62c:	de00012e 	bgeu	sp,et,8111f634 <_fputc_r+0xc>
8111f630:	003b68fa 	trap	3
8111f634:	dc000215 	stw	r16,8(sp)
8111f638:	dfc00315 	stw	ra,12(sp)
8111f63c:	2021883a 	mov	r16,r4
8111f640:	20000726 	beq	r4,zero,8111f660 <_fputc_r+0x38>
8111f644:	20800e17 	ldw	r2,56(r4)
8111f648:	1000051e 	bne	r2,zero,8111f660 <_fputc_r+0x38>
8111f64c:	d9400015 	stw	r5,0(sp)
8111f650:	d9800115 	stw	r6,4(sp)
8111f654:	11294740 	call	81129474 <__sinit>
8111f658:	d9800117 	ldw	r6,4(sp)
8111f65c:	d9400017 	ldw	r5,0(sp)
8111f660:	8009883a 	mov	r4,r16
8111f664:	dfc00317 	ldw	ra,12(sp)
8111f668:	dc000217 	ldw	r16,8(sp)
8111f66c:	dec00404 	addi	sp,sp,16
8111f670:	1120a081 	jmpi	81120a08 <_putc_r>

8111f674 <fputc>:
8111f674:	00a04574 	movhi	r2,33045
8111f678:	defffc04 	addi	sp,sp,-16
8111f67c:	1082c604 	addi	r2,r2,2840
8111f680:	de00012e 	bgeu	sp,et,8111f688 <fputc+0x14>
8111f684:	003b68fa 	trap	3
8111f688:	dc000115 	stw	r16,4(sp)
8111f68c:	14000017 	ldw	r16,0(r2)
8111f690:	dc400215 	stw	r17,8(sp)
8111f694:	dfc00315 	stw	ra,12(sp)
8111f698:	2023883a 	mov	r17,r4
8111f69c:	80000626 	beq	r16,zero,8111f6b8 <fputc+0x44>
8111f6a0:	80800e17 	ldw	r2,56(r16)
8111f6a4:	1000041e 	bne	r2,zero,8111f6b8 <fputc+0x44>
8111f6a8:	8009883a 	mov	r4,r16
8111f6ac:	d9400015 	stw	r5,0(sp)
8111f6b0:	11294740 	call	81129474 <__sinit>
8111f6b4:	d9400017 	ldw	r5,0(sp)
8111f6b8:	280d883a 	mov	r6,r5
8111f6bc:	8009883a 	mov	r4,r16
8111f6c0:	880b883a 	mov	r5,r17
8111f6c4:	dfc00317 	ldw	ra,12(sp)
8111f6c8:	dc400217 	ldw	r17,8(sp)
8111f6cc:	dc000117 	ldw	r16,4(sp)
8111f6d0:	dec00404 	addi	sp,sp,16
8111f6d4:	1120a081 	jmpi	81120a08 <_putc_r>

8111f6d8 <_fseek_r>:
8111f6d8:	111f6f81 	jmpi	8111f6f8 <_fseeko_r>

8111f6dc <fseek>:
8111f6dc:	00a04574 	movhi	r2,33045
8111f6e0:	1082c604 	addi	r2,r2,2840
8111f6e4:	300f883a 	mov	r7,r6
8111f6e8:	280d883a 	mov	r6,r5
8111f6ec:	200b883a 	mov	r5,r4
8111f6f0:	11000017 	ldw	r4,0(r2)
8111f6f4:	111f6f81 	jmpi	8111f6f8 <_fseeko_r>

8111f6f8 <_fseeko_r>:
8111f6f8:	deffe804 	addi	sp,sp,-96
8111f6fc:	de00012e 	bgeu	sp,et,8111f704 <_fseeko_r+0xc>
8111f700:	003b68fa 	trap	3
8111f704:	dd401415 	stw	r21,80(sp)
8111f708:	dc801115 	stw	r18,68(sp)
8111f70c:	dc401015 	stw	r17,64(sp)
8111f710:	dc000f15 	stw	r16,60(sp)
8111f714:	dfc01715 	stw	ra,92(sp)
8111f718:	ddc01615 	stw	r23,88(sp)
8111f71c:	dd801515 	stw	r22,84(sp)
8111f720:	dd001315 	stw	r20,76(sp)
8111f724:	dcc01215 	stw	r19,72(sp)
8111f728:	2023883a 	mov	r17,r4
8111f72c:	2821883a 	mov	r16,r5
8111f730:	302b883a 	mov	r21,r6
8111f734:	3825883a 	mov	r18,r7
8111f738:	20000226 	beq	r4,zero,8111f744 <_fseeko_r+0x4c>
8111f73c:	20800e17 	ldw	r2,56(r4)
8111f740:	10005a26 	beq	r2,zero,8111f8ac <_fseeko_r+0x1b4>
8111f744:	8080030b 	ldhu	r2,12(r16)
8111f748:	00c04204 	movi	r3,264
8111f74c:	1080420c 	andi	r2,r2,264
8111f750:	10c05b26 	beq	r2,r3,8111f8c0 <_fseeko_r+0x1c8>
8111f754:	85000a17 	ldw	r20,40(r16)
8111f758:	a000f626 	beq	r20,zero,8111fb34 <_fseeko_r+0x43c>
8111f75c:	00800044 	movi	r2,1
8111f760:	90803e26 	beq	r18,r2,8111f85c <_fseeko_r+0x164>
8111f764:	00800084 	movi	r2,2
8111f768:	90801026 	beq	r18,r2,8111f7ac <_fseeko_r+0xb4>
8111f76c:	90000f26 	beq	r18,zero,8111f7ac <_fseeko_r+0xb4>
8111f770:	00800584 	movi	r2,22
8111f774:	88800015 	stw	r2,0(r17)
8111f778:	04ffffc4 	movi	r19,-1
8111f77c:	9805883a 	mov	r2,r19
8111f780:	dfc01717 	ldw	ra,92(sp)
8111f784:	ddc01617 	ldw	r23,88(sp)
8111f788:	dd801517 	ldw	r22,84(sp)
8111f78c:	dd401417 	ldw	r21,80(sp)
8111f790:	dd001317 	ldw	r20,76(sp)
8111f794:	dcc01217 	ldw	r19,72(sp)
8111f798:	dc801117 	ldw	r18,68(sp)
8111f79c:	dc401017 	ldw	r17,64(sp)
8111f7a0:	dc000f17 	ldw	r16,60(sp)
8111f7a4:	dec01804 	addi	sp,sp,96
8111f7a8:	f800283a 	ret
8111f7ac:	80800417 	ldw	r2,16(r16)
8111f7b0:	002f883a 	mov	r23,zero
8111f7b4:	0027883a 	mov	r19,zero
8111f7b8:	1000cb26 	beq	r2,zero,8111fae8 <_fseeko_r+0x3f0>
8111f7bc:	8080030b 	ldhu	r2,12(r16)
8111f7c0:	10c2068c 	andi	r3,r2,2074
8111f7c4:	1800071e 	bne	r3,zero,8111f7e4 <_fseeko_r+0xec>
8111f7c8:	10c1000c 	andi	r3,r2,1024
8111f7cc:	1800451e 	bne	r3,zero,8111f8e4 <_fseeko_r+0x1ec>
8111f7d0:	00e044b4 	movhi	r3,33042
8111f7d4:	18c43a04 	addi	r3,r3,4328
8111f7d8:	a0c0b726 	beq	r20,r3,8111fab8 <_fseeko_r+0x3c0>
8111f7dc:	10820014 	ori	r2,r2,2048
8111f7e0:	8080030d 	sth	r2,12(r16)
8111f7e4:	800b883a 	mov	r5,r16
8111f7e8:	8809883a 	mov	r4,r17
8111f7ec:	11290780 	call	81129078 <_fflush_r>
8111f7f0:	1027883a 	mov	r19,r2
8111f7f4:	103fe01e 	bne	r2,zero,8111f778 <__reset+0xfb0ff778>
8111f7f8:	81400717 	ldw	r5,28(r16)
8111f7fc:	900f883a 	mov	r7,r18
8111f800:	a80d883a 	mov	r6,r21
8111f804:	8809883a 	mov	r4,r17
8111f808:	a03ee83a 	callr	r20
8111f80c:	00ffffc4 	movi	r3,-1
8111f810:	10ffd926 	beq	r2,r3,8111f778 <__reset+0xfb0ff778>
8111f814:	81400c17 	ldw	r5,48(r16)
8111f818:	28000526 	beq	r5,zero,8111f830 <_fseeko_r+0x138>
8111f81c:	80801004 	addi	r2,r16,64
8111f820:	28800226 	beq	r5,r2,8111f82c <_fseeko_r+0x134>
8111f824:	8809883a 	mov	r4,r17
8111f828:	112990c0 	call	8112990c <_free_r>
8111f82c:	80000c15 	stw	zero,48(r16)
8111f830:	8080030b 	ldhu	r2,12(r16)
8111f834:	80c00417 	ldw	r3,16(r16)
8111f838:	80000115 	stw	zero,4(r16)
8111f83c:	10bdf7cc 	andi	r2,r2,63455
8111f840:	80c00015 	stw	r3,0(r16)
8111f844:	8080030d 	sth	r2,12(r16)
8111f848:	01800204 	movi	r6,8
8111f84c:	000b883a 	mov	r5,zero
8111f850:	81001704 	addi	r4,r16,92
8111f854:	11207fc0 	call	811207fc <memset>
8111f858:	003fc806 	br	8111f77c <__reset+0xfb0ff77c>
8111f85c:	800b883a 	mov	r5,r16
8111f860:	8809883a 	mov	r4,r17
8111f864:	11290780 	call	81129078 <_fflush_r>
8111f868:	8080030b 	ldhu	r2,12(r16)
8111f86c:	10c4000c 	andi	r3,r2,4096
8111f870:	18008726 	beq	r3,zero,8111fa90 <_fseeko_r+0x398>
8111f874:	84c01417 	ldw	r19,80(r16)
8111f878:	10c0010c 	andi	r3,r2,4
8111f87c:	1800431e 	bne	r3,zero,8111f98c <_fseeko_r+0x294>
8111f880:	1080020c 	andi	r2,r2,8
8111f884:	10008026 	beq	r2,zero,8111fa88 <_fseeko_r+0x390>
8111f888:	80c00017 	ldw	r3,0(r16)
8111f88c:	80800417 	ldw	r2,16(r16)
8111f890:	18000226 	beq	r3,zero,8111f89c <_fseeko_r+0x1a4>
8111f894:	1887c83a 	sub	r3,r3,r2
8111f898:	98e7883a 	add	r19,r19,r3
8111f89c:	aceb883a 	add	r21,r21,r19
8111f8a0:	05c00044 	movi	r23,1
8111f8a4:	0025883a 	mov	r18,zero
8111f8a8:	003fc306 	br	8111f7b8 <__reset+0xfb0ff7b8>
8111f8ac:	11294740 	call	81129474 <__sinit>
8111f8b0:	8080030b 	ldhu	r2,12(r16)
8111f8b4:	00c04204 	movi	r3,264
8111f8b8:	1080420c 	andi	r2,r2,264
8111f8bc:	10ffa51e 	bne	r2,r3,8111f754 <__reset+0xfb0ff754>
8111f8c0:	800b883a 	mov	r5,r16
8111f8c4:	8809883a 	mov	r4,r17
8111f8c8:	11290780 	call	81129078 <_fflush_r>
8111f8cc:	003fa106 	br	8111f754 <__reset+0xfb0ff754>
8111f8d0:	8080030b 	ldhu	r2,12(r16)
8111f8d4:	00c10004 	movi	r3,1024
8111f8d8:	80c01315 	stw	r3,76(r16)
8111f8dc:	10c4b03a 	or	r2,r2,r3
8111f8e0:	8080030d 	sth	r2,12(r16)
8111f8e4:	9000311e 	bne	r18,zero,8111f9ac <_fseeko_r+0x2b4>
8111f8e8:	a82d883a 	mov	r22,r21
8111f8ec:	b800371e 	bne	r23,zero,8111f9cc <_fseeko_r+0x2d4>
8111f8f0:	8080030b 	ldhu	r2,12(r16)
8111f8f4:	1084000c 	andi	r2,r2,4096
8111f8f8:	10007f26 	beq	r2,zero,8111faf8 <_fseeko_r+0x400>
8111f8fc:	80801417 	ldw	r2,80(r16)
8111f900:	81800117 	ldw	r6,4(r16)
8111f904:	81400c17 	ldw	r5,48(r16)
8111f908:	11a7c83a 	sub	r19,r2,r6
8111f90c:	28008226 	beq	r5,zero,8111fb18 <_fseeko_r+0x420>
8111f910:	81c00f17 	ldw	r7,60(r16)
8111f914:	99e7c83a 	sub	r19,r19,r7
8111f918:	81000e17 	ldw	r4,56(r16)
8111f91c:	80800417 	ldw	r2,16(r16)
8111f920:	99a7883a 	add	r19,r19,r6
8111f924:	2087c83a 	sub	r3,r4,r2
8111f928:	98e7c83a 	sub	r19,r19,r3
8111f92c:	38c7883a 	add	r3,r7,r3
8111f930:	b4c02b16 	blt	r22,r19,8111f9e0 <_fseeko_r+0x2e8>
8111f934:	98c9883a 	add	r4,r19,r3
8111f938:	b100292e 	bgeu	r22,r4,8111f9e0 <_fseeko_r+0x2e8>
8111f93c:	b4e7c83a 	sub	r19,r22,r19
8111f940:	14c5883a 	add	r2,r2,r19
8111f944:	1ce7c83a 	sub	r19,r3,r19
8111f948:	80800015 	stw	r2,0(r16)
8111f94c:	84c00115 	stw	r19,4(r16)
8111f950:	28000526 	beq	r5,zero,8111f968 <_fseeko_r+0x270>
8111f954:	80801004 	addi	r2,r16,64
8111f958:	28800226 	beq	r5,r2,8111f964 <_fseeko_r+0x26c>
8111f95c:	8809883a 	mov	r4,r17
8111f960:	112990c0 	call	8112990c <_free_r>
8111f964:	80000c15 	stw	zero,48(r16)
8111f968:	8080030b 	ldhu	r2,12(r16)
8111f96c:	01800204 	movi	r6,8
8111f970:	000b883a 	mov	r5,zero
8111f974:	10bff7cc 	andi	r2,r2,65503
8111f978:	8080030d 	sth	r2,12(r16)
8111f97c:	81001704 	addi	r4,r16,92
8111f980:	11207fc0 	call	811207fc <memset>
8111f984:	0027883a 	mov	r19,zero
8111f988:	003f7c06 	br	8111f77c <__reset+0xfb0ff77c>
8111f98c:	80c00117 	ldw	r3,4(r16)
8111f990:	80800c17 	ldw	r2,48(r16)
8111f994:	98e7c83a 	sub	r19,r19,r3
8111f998:	10003b26 	beq	r2,zero,8111fa88 <_fseeko_r+0x390>
8111f99c:	80c00f17 	ldw	r3,60(r16)
8111f9a0:	80800417 	ldw	r2,16(r16)
8111f9a4:	98e7c83a 	sub	r19,r19,r3
8111f9a8:	003fbc06 	br	8111f89c <__reset+0xfb0ff89c>
8111f9ac:	8140038f 	ldh	r5,14(r16)
8111f9b0:	d80d883a 	mov	r6,sp
8111f9b4:	8809883a 	mov	r4,r17
8111f9b8:	111fb600 	call	8111fb60 <_fstat_r>
8111f9bc:	103f891e 	bne	r2,zero,8111f7e4 <__reset+0xfb0ff7e4>
8111f9c0:	dd800417 	ldw	r22,16(sp)
8111f9c4:	adad883a 	add	r22,r21,r22
8111f9c8:	b83fc926 	beq	r23,zero,8111f8f0 <__reset+0xfb0ff8f0>
8111f9cc:	81400c17 	ldw	r5,48(r16)
8111f9d0:	81800117 	ldw	r6,4(r16)
8111f9d4:	28005026 	beq	r5,zero,8111fb18 <_fseeko_r+0x420>
8111f9d8:	81c00f17 	ldw	r7,60(r16)
8111f9dc:	003fce06 	br	8111f918 <__reset+0xfb0ff918>
8111f9e0:	84c01317 	ldw	r19,76(r16)
8111f9e4:	81400717 	ldw	r5,28(r16)
8111f9e8:	000f883a 	mov	r7,zero
8111f9ec:	04e7c83a 	sub	r19,zero,r19
8111f9f0:	9da6703a 	and	r19,r19,r22
8111f9f4:	980d883a 	mov	r6,r19
8111f9f8:	8809883a 	mov	r4,r17
8111f9fc:	a03ee83a 	callr	r20
8111fa00:	00ffffc4 	movi	r3,-1
8111fa04:	10ff7726 	beq	r2,r3,8111f7e4 <__reset+0xfb0ff7e4>
8111fa08:	80800417 	ldw	r2,16(r16)
8111fa0c:	81400c17 	ldw	r5,48(r16)
8111fa10:	80000115 	stw	zero,4(r16)
8111fa14:	80800015 	stw	r2,0(r16)
8111fa18:	28000526 	beq	r5,zero,8111fa30 <_fseeko_r+0x338>
8111fa1c:	80801004 	addi	r2,r16,64
8111fa20:	28800226 	beq	r5,r2,8111fa2c <_fseeko_r+0x334>
8111fa24:	8809883a 	mov	r4,r17
8111fa28:	112990c0 	call	8112990c <_free_r>
8111fa2c:	80000c15 	stw	zero,48(r16)
8111fa30:	8080030b 	ldhu	r2,12(r16)
8111fa34:	b4e7c83a 	sub	r19,r22,r19
8111fa38:	10bff7cc 	andi	r2,r2,65503
8111fa3c:	8080030d 	sth	r2,12(r16)
8111fa40:	98000b26 	beq	r19,zero,8111fa70 <_fseeko_r+0x378>
8111fa44:	800b883a 	mov	r5,r16
8111fa48:	8809883a 	mov	r4,r17
8111fa4c:	1120c780 	call	81120c78 <__srefill_r>
8111fa50:	103f641e 	bne	r2,zero,8111f7e4 <__reset+0xfb0ff7e4>
8111fa54:	80800117 	ldw	r2,4(r16)
8111fa58:	14ff6236 	bltu	r2,r19,8111f7e4 <__reset+0xfb0ff7e4>
8111fa5c:	80c00017 	ldw	r3,0(r16)
8111fa60:	14c5c83a 	sub	r2,r2,r19
8111fa64:	80800115 	stw	r2,4(r16)
8111fa68:	1ce7883a 	add	r19,r3,r19
8111fa6c:	84c00015 	stw	r19,0(r16)
8111fa70:	01800204 	movi	r6,8
8111fa74:	000b883a 	mov	r5,zero
8111fa78:	81001704 	addi	r4,r16,92
8111fa7c:	11207fc0 	call	811207fc <memset>
8111fa80:	0027883a 	mov	r19,zero
8111fa84:	003f3d06 	br	8111f77c <__reset+0xfb0ff77c>
8111fa88:	80800417 	ldw	r2,16(r16)
8111fa8c:	003f8306 	br	8111f89c <__reset+0xfb0ff89c>
8111fa90:	81400717 	ldw	r5,28(r16)
8111fa94:	900f883a 	mov	r7,r18
8111fa98:	000d883a 	mov	r6,zero
8111fa9c:	8809883a 	mov	r4,r17
8111faa0:	a03ee83a 	callr	r20
8111faa4:	1027883a 	mov	r19,r2
8111faa8:	00bfffc4 	movi	r2,-1
8111faac:	98bf3226 	beq	r19,r2,8111f778 <__reset+0xfb0ff778>
8111fab0:	8080030b 	ldhu	r2,12(r16)
8111fab4:	003f7006 	br	8111f878 <__reset+0xfb0ff878>
8111fab8:	8140038f 	ldh	r5,14(r16)
8111fabc:	283f4716 	blt	r5,zero,8111f7dc <__reset+0xfb0ff7dc>
8111fac0:	d80d883a 	mov	r6,sp
8111fac4:	8809883a 	mov	r4,r17
8111fac8:	111fb600 	call	8111fb60 <_fstat_r>
8111facc:	1000041e 	bne	r2,zero,8111fae0 <_fseeko_r+0x3e8>
8111fad0:	d8800117 	ldw	r2,4(sp)
8111fad4:	00e00014 	movui	r3,32768
8111fad8:	10bc000c 	andi	r2,r2,61440
8111fadc:	10ff7c26 	beq	r2,r3,8111f8d0 <__reset+0xfb0ff8d0>
8111fae0:	8080030b 	ldhu	r2,12(r16)
8111fae4:	003f3d06 	br	8111f7dc <__reset+0xfb0ff7dc>
8111fae8:	800b883a 	mov	r5,r16
8111faec:	8809883a 	mov	r4,r17
8111faf0:	111fcd40 	call	8111fcd4 <__smakebuf_r>
8111faf4:	003f3106 	br	8111f7bc <__reset+0xfb0ff7bc>
8111faf8:	81400717 	ldw	r5,28(r16)
8111fafc:	01c00044 	movi	r7,1
8111fb00:	000d883a 	mov	r6,zero
8111fb04:	8809883a 	mov	r4,r17
8111fb08:	a03ee83a 	callr	r20
8111fb0c:	00ffffc4 	movi	r3,-1
8111fb10:	10ff7b1e 	bne	r2,r3,8111f900 <__reset+0xfb0ff900>
8111fb14:	003f3306 	br	8111f7e4 <__reset+0xfb0ff7e4>
8111fb18:	80c00017 	ldw	r3,0(r16)
8111fb1c:	80800417 	ldw	r2,16(r16)
8111fb20:	000b883a 	mov	r5,zero
8111fb24:	1887c83a 	sub	r3,r3,r2
8111fb28:	98e7c83a 	sub	r19,r19,r3
8111fb2c:	30c7883a 	add	r3,r6,r3
8111fb30:	003f7f06 	br	8111f930 <__reset+0xfb0ff930>
8111fb34:	00800744 	movi	r2,29
8111fb38:	88800015 	stw	r2,0(r17)
8111fb3c:	04ffffc4 	movi	r19,-1
8111fb40:	003f0e06 	br	8111f77c <__reset+0xfb0ff77c>

8111fb44 <fseeko>:
8111fb44:	00a04574 	movhi	r2,33045
8111fb48:	1082c604 	addi	r2,r2,2840
8111fb4c:	300f883a 	mov	r7,r6
8111fb50:	280d883a 	mov	r6,r5
8111fb54:	200b883a 	mov	r5,r4
8111fb58:	11000017 	ldw	r4,0(r2)
8111fb5c:	111f6f81 	jmpi	8111f6f8 <_fseeko_r>

8111fb60 <_fstat_r>:
8111fb60:	defffd04 	addi	sp,sp,-12
8111fb64:	de00012e 	bgeu	sp,et,8111fb6c <_fstat_r+0xc>
8111fb68:	003b68fa 	trap	3
8111fb6c:	2805883a 	mov	r2,r5
8111fb70:	dc000015 	stw	r16,0(sp)
8111fb74:	04204574 	movhi	r16,33045
8111fb78:	dc400115 	stw	r17,4(sp)
8111fb7c:	84033804 	addi	r16,r16,3296
8111fb80:	2023883a 	mov	r17,r4
8111fb84:	300b883a 	mov	r5,r6
8111fb88:	1009883a 	mov	r4,r2
8111fb8c:	dfc00215 	stw	ra,8(sp)
8111fb90:	80000015 	stw	zero,0(r16)
8111fb94:	113458c0 	call	8113458c <fstat>
8111fb98:	00ffffc4 	movi	r3,-1
8111fb9c:	10c00526 	beq	r2,r3,8111fbb4 <_fstat_r+0x54>
8111fba0:	dfc00217 	ldw	ra,8(sp)
8111fba4:	dc400117 	ldw	r17,4(sp)
8111fba8:	dc000017 	ldw	r16,0(sp)
8111fbac:	dec00304 	addi	sp,sp,12
8111fbb0:	f800283a 	ret
8111fbb4:	80c00017 	ldw	r3,0(r16)
8111fbb8:	183ff926 	beq	r3,zero,8111fba0 <__reset+0xfb0ffba0>
8111fbbc:	88c00015 	stw	r3,0(r17)
8111fbc0:	003ff706 	br	8111fba0 <__reset+0xfb0ffba0>

8111fbc4 <_fwrite_r>:
8111fbc4:	defff504 	addi	sp,sp,-44
8111fbc8:	de00012e 	bgeu	sp,et,8111fbd0 <_fwrite_r+0xc>
8111fbcc:	003b68fa 	trap	3
8111fbd0:	dc800815 	stw	r18,32(sp)
8111fbd4:	39a5383a 	mul	r18,r7,r6
8111fbd8:	d8800304 	addi	r2,sp,12
8111fbdc:	d8800015 	stw	r2,0(sp)
8111fbe0:	00800044 	movi	r2,1
8111fbe4:	dcc00915 	stw	r19,36(sp)
8111fbe8:	dc400715 	stw	r17,28(sp)
8111fbec:	dc000615 	stw	r16,24(sp)
8111fbf0:	d9400315 	stw	r5,12(sp)
8111fbf4:	dfc00a15 	stw	ra,40(sp)
8111fbf8:	dc800415 	stw	r18,16(sp)
8111fbfc:	dc800215 	stw	r18,8(sp)
8111fc00:	d8800115 	stw	r2,4(sp)
8111fc04:	3027883a 	mov	r19,r6
8111fc08:	3821883a 	mov	r16,r7
8111fc0c:	2023883a 	mov	r17,r4
8111fc10:	d9400b17 	ldw	r5,44(sp)
8111fc14:	20000226 	beq	r4,zero,8111fc20 <_fwrite_r+0x5c>
8111fc18:	20800e17 	ldw	r2,56(r4)
8111fc1c:	10001a26 	beq	r2,zero,8111fc88 <_fwrite_r+0xc4>
8111fc20:	2880030b 	ldhu	r2,12(r5)
8111fc24:	10c8000c 	andi	r3,r2,8192
8111fc28:	1800061e 	bne	r3,zero,8111fc44 <_fwrite_r+0x80>
8111fc2c:	29001917 	ldw	r4,100(r5)
8111fc30:	00f7ffc4 	movi	r3,-8193
8111fc34:	10880014 	ori	r2,r2,8192
8111fc38:	20c6703a 	and	r3,r4,r3
8111fc3c:	2880030d 	sth	r2,12(r5)
8111fc40:	28c01915 	stw	r3,100(r5)
8111fc44:	d80d883a 	mov	r6,sp
8111fc48:	8809883a 	mov	r4,r17
8111fc4c:	1129c240 	call	81129c24 <__sfvwrite_r>
8111fc50:	10000b26 	beq	r2,zero,8111fc80 <_fwrite_r+0xbc>
8111fc54:	d9000217 	ldw	r4,8(sp)
8111fc58:	980b883a 	mov	r5,r19
8111fc5c:	9109c83a 	sub	r4,r18,r4
8111fc60:	1132c180 	call	81132c18 <__udivsi3>
8111fc64:	dfc00a17 	ldw	ra,40(sp)
8111fc68:	dcc00917 	ldw	r19,36(sp)
8111fc6c:	dc800817 	ldw	r18,32(sp)
8111fc70:	dc400717 	ldw	r17,28(sp)
8111fc74:	dc000617 	ldw	r16,24(sp)
8111fc78:	dec00b04 	addi	sp,sp,44
8111fc7c:	f800283a 	ret
8111fc80:	8005883a 	mov	r2,r16
8111fc84:	003ff706 	br	8111fc64 <__reset+0xfb0ffc64>
8111fc88:	d9400515 	stw	r5,20(sp)
8111fc8c:	11294740 	call	81129474 <__sinit>
8111fc90:	d9400517 	ldw	r5,20(sp)
8111fc94:	003fe206 	br	8111fc20 <__reset+0xfb0ffc20>

8111fc98 <fwrite>:
8111fc98:	defffe04 	addi	sp,sp,-8
8111fc9c:	00a04574 	movhi	r2,33045
8111fca0:	de00012e 	bgeu	sp,et,8111fca8 <fwrite+0x10>
8111fca4:	003b68fa 	trap	3
8111fca8:	1082c604 	addi	r2,r2,2840
8111fcac:	d9c00015 	stw	r7,0(sp)
8111fcb0:	300f883a 	mov	r7,r6
8111fcb4:	280d883a 	mov	r6,r5
8111fcb8:	200b883a 	mov	r5,r4
8111fcbc:	11000017 	ldw	r4,0(r2)
8111fcc0:	dfc00115 	stw	ra,4(sp)
8111fcc4:	111fbc40 	call	8111fbc4 <_fwrite_r>
8111fcc8:	dfc00117 	ldw	ra,4(sp)
8111fccc:	dec00204 	addi	sp,sp,8
8111fcd0:	f800283a 	ret

8111fcd4 <__smakebuf_r>:
8111fcd4:	2880030b 	ldhu	r2,12(r5)
8111fcd8:	10c0008c 	andi	r3,r2,2
8111fcdc:	1800431e 	bne	r3,zero,8111fdec <__smakebuf_r+0x118>
8111fce0:	deffec04 	addi	sp,sp,-80
8111fce4:	de00012e 	bgeu	sp,et,8111fcec <__smakebuf_r+0x18>
8111fce8:	003b68fa 	trap	3
8111fcec:	dc000f15 	stw	r16,60(sp)
8111fcf0:	2821883a 	mov	r16,r5
8111fcf4:	2940038f 	ldh	r5,14(r5)
8111fcf8:	dc401015 	stw	r17,64(sp)
8111fcfc:	dfc01315 	stw	ra,76(sp)
8111fd00:	dcc01215 	stw	r19,72(sp)
8111fd04:	dc801115 	stw	r18,68(sp)
8111fd08:	2023883a 	mov	r17,r4
8111fd0c:	28001c16 	blt	r5,zero,8111fd80 <__smakebuf_r+0xac>
8111fd10:	d80d883a 	mov	r6,sp
8111fd14:	111fb600 	call	8111fb60 <_fstat_r>
8111fd18:	10001816 	blt	r2,zero,8111fd7c <__smakebuf_r+0xa8>
8111fd1c:	d8800117 	ldw	r2,4(sp)
8111fd20:	00e00014 	movui	r3,32768
8111fd24:	10bc000c 	andi	r2,r2,61440
8111fd28:	14c80020 	cmpeqi	r19,r2,8192
8111fd2c:	10c03726 	beq	r2,r3,8111fe0c <__smakebuf_r+0x138>
8111fd30:	80c0030b 	ldhu	r3,12(r16)
8111fd34:	18c20014 	ori	r3,r3,2048
8111fd38:	80c0030d 	sth	r3,12(r16)
8111fd3c:	00c80004 	movi	r3,8192
8111fd40:	10c0521e 	bne	r2,r3,8111fe8c <__smakebuf_r+0x1b8>
8111fd44:	8140038f 	ldh	r5,14(r16)
8111fd48:	8809883a 	mov	r4,r17
8111fd4c:	112a2800 	call	8112a280 <_isatty_r>
8111fd50:	10004c26 	beq	r2,zero,8111fe84 <__smakebuf_r+0x1b0>
8111fd54:	8080030b 	ldhu	r2,12(r16)
8111fd58:	80c010c4 	addi	r3,r16,67
8111fd5c:	80c00015 	stw	r3,0(r16)
8111fd60:	10800054 	ori	r2,r2,1
8111fd64:	8080030d 	sth	r2,12(r16)
8111fd68:	00800044 	movi	r2,1
8111fd6c:	80c00415 	stw	r3,16(r16)
8111fd70:	80800515 	stw	r2,20(r16)
8111fd74:	04810004 	movi	r18,1024
8111fd78:	00000706 	br	8111fd98 <__smakebuf_r+0xc4>
8111fd7c:	8080030b 	ldhu	r2,12(r16)
8111fd80:	10c0200c 	andi	r3,r2,128
8111fd84:	18001f1e 	bne	r3,zero,8111fe04 <__smakebuf_r+0x130>
8111fd88:	04810004 	movi	r18,1024
8111fd8c:	10820014 	ori	r2,r2,2048
8111fd90:	8080030d 	sth	r2,12(r16)
8111fd94:	0027883a 	mov	r19,zero
8111fd98:	900b883a 	mov	r5,r18
8111fd9c:	8809883a 	mov	r4,r17
8111fda0:	111fe980 	call	8111fe98 <_malloc_r>
8111fda4:	10002c26 	beq	r2,zero,8111fe58 <__smakebuf_r+0x184>
8111fda8:	80c0030b 	ldhu	r3,12(r16)
8111fdac:	012044f4 	movhi	r4,33043
8111fdb0:	21244504 	addi	r4,r4,-28396
8111fdb4:	89000f15 	stw	r4,60(r17)
8111fdb8:	18c02014 	ori	r3,r3,128
8111fdbc:	80c0030d 	sth	r3,12(r16)
8111fdc0:	80800015 	stw	r2,0(r16)
8111fdc4:	80800415 	stw	r2,16(r16)
8111fdc8:	84800515 	stw	r18,20(r16)
8111fdcc:	98001a1e 	bne	r19,zero,8111fe38 <__smakebuf_r+0x164>
8111fdd0:	dfc01317 	ldw	ra,76(sp)
8111fdd4:	dcc01217 	ldw	r19,72(sp)
8111fdd8:	dc801117 	ldw	r18,68(sp)
8111fddc:	dc401017 	ldw	r17,64(sp)
8111fde0:	dc000f17 	ldw	r16,60(sp)
8111fde4:	dec01404 	addi	sp,sp,80
8111fde8:	f800283a 	ret
8111fdec:	288010c4 	addi	r2,r5,67
8111fdf0:	28800015 	stw	r2,0(r5)
8111fdf4:	28800415 	stw	r2,16(r5)
8111fdf8:	00800044 	movi	r2,1
8111fdfc:	28800515 	stw	r2,20(r5)
8111fe00:	f800283a 	ret
8111fe04:	04801004 	movi	r18,64
8111fe08:	003fe006 	br	8111fd8c <__reset+0xfb0ffd8c>
8111fe0c:	81000a17 	ldw	r4,40(r16)
8111fe10:	00e044b4 	movhi	r3,33042
8111fe14:	18c43a04 	addi	r3,r3,4328
8111fe18:	20ffc51e 	bne	r4,r3,8111fd30 <__reset+0xfb0ffd30>
8111fe1c:	8080030b 	ldhu	r2,12(r16)
8111fe20:	04810004 	movi	r18,1024
8111fe24:	84801315 	stw	r18,76(r16)
8111fe28:	1484b03a 	or	r2,r2,r18
8111fe2c:	8080030d 	sth	r2,12(r16)
8111fe30:	0027883a 	mov	r19,zero
8111fe34:	003fd806 	br	8111fd98 <__reset+0xfb0ffd98>
8111fe38:	8140038f 	ldh	r5,14(r16)
8111fe3c:	8809883a 	mov	r4,r17
8111fe40:	112a2800 	call	8112a280 <_isatty_r>
8111fe44:	103fe226 	beq	r2,zero,8111fdd0 <__reset+0xfb0ffdd0>
8111fe48:	8080030b 	ldhu	r2,12(r16)
8111fe4c:	10800054 	ori	r2,r2,1
8111fe50:	8080030d 	sth	r2,12(r16)
8111fe54:	003fde06 	br	8111fdd0 <__reset+0xfb0ffdd0>
8111fe58:	8080030b 	ldhu	r2,12(r16)
8111fe5c:	10c0800c 	andi	r3,r2,512
8111fe60:	183fdb1e 	bne	r3,zero,8111fdd0 <__reset+0xfb0ffdd0>
8111fe64:	10800094 	ori	r2,r2,2
8111fe68:	80c010c4 	addi	r3,r16,67
8111fe6c:	8080030d 	sth	r2,12(r16)
8111fe70:	00800044 	movi	r2,1
8111fe74:	80c00015 	stw	r3,0(r16)
8111fe78:	80c00415 	stw	r3,16(r16)
8111fe7c:	80800515 	stw	r2,20(r16)
8111fe80:	003fd306 	br	8111fdd0 <__reset+0xfb0ffdd0>
8111fe84:	04810004 	movi	r18,1024
8111fe88:	003fc306 	br	8111fd98 <__reset+0xfb0ffd98>
8111fe8c:	0027883a 	mov	r19,zero
8111fe90:	04810004 	movi	r18,1024
8111fe94:	003fc006 	br	8111fd98 <__reset+0xfb0ffd98>

8111fe98 <_malloc_r>:
8111fe98:	defff504 	addi	sp,sp,-44
8111fe9c:	de00012e 	bgeu	sp,et,8111fea4 <_malloc_r+0xc>
8111fea0:	003b68fa 	trap	3
8111fea4:	288002c4 	addi	r2,r5,11
8111fea8:	dc800315 	stw	r18,12(sp)
8111feac:	dfc00a15 	stw	ra,40(sp)
8111feb0:	df000915 	stw	fp,36(sp)
8111feb4:	ddc00815 	stw	r23,32(sp)
8111feb8:	dd800715 	stw	r22,28(sp)
8111febc:	dd400615 	stw	r21,24(sp)
8111fec0:	dd000515 	stw	r20,20(sp)
8111fec4:	dcc00415 	stw	r19,16(sp)
8111fec8:	dc400215 	stw	r17,8(sp)
8111fecc:	dc000115 	stw	r16,4(sp)
8111fed0:	00c00584 	movi	r3,22
8111fed4:	2025883a 	mov	r18,r4
8111fed8:	18807f2e 	bgeu	r3,r2,811200d8 <_malloc_r+0x240>
8111fedc:	047ffe04 	movi	r17,-8
8111fee0:	1462703a 	and	r17,r2,r17
8111fee4:	8800a316 	blt	r17,zero,81120174 <_malloc_r+0x2dc>
8111fee8:	8940a236 	bltu	r17,r5,81120174 <_malloc_r+0x2dc>
8111feec:	11360d40 	call	811360d4 <__malloc_lock>
8111fef0:	00807dc4 	movi	r2,503
8111fef4:	1441e92e 	bgeu	r2,r17,8112069c <_malloc_r+0x804>
8111fef8:	8804d27a 	srli	r2,r17,9
8111fefc:	1000a126 	beq	r2,zero,81120184 <_malloc_r+0x2ec>
8111ff00:	00c00104 	movi	r3,4
8111ff04:	18811e36 	bltu	r3,r2,81120380 <_malloc_r+0x4e8>
8111ff08:	8804d1ba 	srli	r2,r17,6
8111ff0c:	12000e44 	addi	r8,r2,57
8111ff10:	11c00e04 	addi	r7,r2,56
8111ff14:	4209883a 	add	r4,r8,r8
8111ff18:	04e04574 	movhi	r19,33045
8111ff1c:	2109883a 	add	r4,r4,r4
8111ff20:	9cfc8404 	addi	r19,r19,-3568
8111ff24:	2109883a 	add	r4,r4,r4
8111ff28:	9909883a 	add	r4,r19,r4
8111ff2c:	24000117 	ldw	r16,4(r4)
8111ff30:	213ffe04 	addi	r4,r4,-8
8111ff34:	24009726 	beq	r4,r16,81120194 <_malloc_r+0x2fc>
8111ff38:	80800117 	ldw	r2,4(r16)
8111ff3c:	01bfff04 	movi	r6,-4
8111ff40:	014003c4 	movi	r5,15
8111ff44:	1184703a 	and	r2,r2,r6
8111ff48:	1447c83a 	sub	r3,r2,r17
8111ff4c:	28c00716 	blt	r5,r3,8111ff6c <_malloc_r+0xd4>
8111ff50:	1800920e 	bge	r3,zero,8112019c <_malloc_r+0x304>
8111ff54:	84000317 	ldw	r16,12(r16)
8111ff58:	24008e26 	beq	r4,r16,81120194 <_malloc_r+0x2fc>
8111ff5c:	80800117 	ldw	r2,4(r16)
8111ff60:	1184703a 	and	r2,r2,r6
8111ff64:	1447c83a 	sub	r3,r2,r17
8111ff68:	28fff90e 	bge	r5,r3,8111ff50 <__reset+0xfb0fff50>
8111ff6c:	3809883a 	mov	r4,r7
8111ff70:	01a04574 	movhi	r6,33045
8111ff74:	9c000417 	ldw	r16,16(r19)
8111ff78:	31bc8404 	addi	r6,r6,-3568
8111ff7c:	32000204 	addi	r8,r6,8
8111ff80:	82013426 	beq	r16,r8,81120454 <_malloc_r+0x5bc>
8111ff84:	80c00117 	ldw	r3,4(r16)
8111ff88:	00bfff04 	movi	r2,-4
8111ff8c:	188e703a 	and	r7,r3,r2
8111ff90:	3c45c83a 	sub	r2,r7,r17
8111ff94:	00c003c4 	movi	r3,15
8111ff98:	18811f16 	blt	r3,r2,81120418 <_malloc_r+0x580>
8111ff9c:	32000515 	stw	r8,20(r6)
8111ffa0:	32000415 	stw	r8,16(r6)
8111ffa4:	10007f0e 	bge	r2,zero,811201a4 <_malloc_r+0x30c>
8111ffa8:	00807fc4 	movi	r2,511
8111ffac:	11c0fd36 	bltu	r2,r7,811203a4 <_malloc_r+0x50c>
8111ffb0:	3806d0fa 	srli	r3,r7,3
8111ffb4:	01c00044 	movi	r7,1
8111ffb8:	30800117 	ldw	r2,4(r6)
8111ffbc:	19400044 	addi	r5,r3,1
8111ffc0:	294b883a 	add	r5,r5,r5
8111ffc4:	1807d0ba 	srai	r3,r3,2
8111ffc8:	294b883a 	add	r5,r5,r5
8111ffcc:	294b883a 	add	r5,r5,r5
8111ffd0:	298b883a 	add	r5,r5,r6
8111ffd4:	38c6983a 	sll	r3,r7,r3
8111ffd8:	29c00017 	ldw	r7,0(r5)
8111ffdc:	2a7ffe04 	addi	r9,r5,-8
8111ffe0:	1886b03a 	or	r3,r3,r2
8111ffe4:	82400315 	stw	r9,12(r16)
8111ffe8:	81c00215 	stw	r7,8(r16)
8111ffec:	30c00115 	stw	r3,4(r6)
8111fff0:	2c000015 	stw	r16,0(r5)
8111fff4:	3c000315 	stw	r16,12(r7)
8111fff8:	2005d0ba 	srai	r2,r4,2
8111fffc:	01400044 	movi	r5,1
81120000:	288a983a 	sll	r5,r5,r2
81120004:	19406f36 	bltu	r3,r5,811201c4 <_malloc_r+0x32c>
81120008:	28c4703a 	and	r2,r5,r3
8112000c:	10000a1e 	bne	r2,zero,81120038 <_malloc_r+0x1a0>
81120010:	00bfff04 	movi	r2,-4
81120014:	294b883a 	add	r5,r5,r5
81120018:	2088703a 	and	r4,r4,r2
8112001c:	28c4703a 	and	r2,r5,r3
81120020:	21000104 	addi	r4,r4,4
81120024:	1000041e 	bne	r2,zero,81120038 <_malloc_r+0x1a0>
81120028:	294b883a 	add	r5,r5,r5
8112002c:	28c4703a 	and	r2,r5,r3
81120030:	21000104 	addi	r4,r4,4
81120034:	103ffc26 	beq	r2,zero,81120028 <__reset+0xfb100028>
81120038:	02bfff04 	movi	r10,-4
8112003c:	024003c4 	movi	r9,15
81120040:	21800044 	addi	r6,r4,1
81120044:	318d883a 	add	r6,r6,r6
81120048:	318d883a 	add	r6,r6,r6
8112004c:	318d883a 	add	r6,r6,r6
81120050:	998d883a 	add	r6,r19,r6
81120054:	333ffe04 	addi	r12,r6,-8
81120058:	2017883a 	mov	r11,r4
8112005c:	31800104 	addi	r6,r6,4
81120060:	34000017 	ldw	r16,0(r6)
81120064:	31fffd04 	addi	r7,r6,-12
81120068:	81c0041e 	bne	r16,r7,8112007c <_malloc_r+0x1e4>
8112006c:	0000fb06 	br	8112045c <_malloc_r+0x5c4>
81120070:	1801030e 	bge	r3,zero,81120480 <_malloc_r+0x5e8>
81120074:	84000317 	ldw	r16,12(r16)
81120078:	81c0f826 	beq	r16,r7,8112045c <_malloc_r+0x5c4>
8112007c:	80800117 	ldw	r2,4(r16)
81120080:	1284703a 	and	r2,r2,r10
81120084:	1447c83a 	sub	r3,r2,r17
81120088:	48fff90e 	bge	r9,r3,81120070 <__reset+0xfb100070>
8112008c:	80800317 	ldw	r2,12(r16)
81120090:	81000217 	ldw	r4,8(r16)
81120094:	89400054 	ori	r5,r17,1
81120098:	81400115 	stw	r5,4(r16)
8112009c:	20800315 	stw	r2,12(r4)
811200a0:	11000215 	stw	r4,8(r2)
811200a4:	8463883a 	add	r17,r16,r17
811200a8:	9c400515 	stw	r17,20(r19)
811200ac:	9c400415 	stw	r17,16(r19)
811200b0:	18800054 	ori	r2,r3,1
811200b4:	88800115 	stw	r2,4(r17)
811200b8:	8a000315 	stw	r8,12(r17)
811200bc:	8a000215 	stw	r8,8(r17)
811200c0:	88e3883a 	add	r17,r17,r3
811200c4:	88c00015 	stw	r3,0(r17)
811200c8:	9009883a 	mov	r4,r18
811200cc:	11361fc0 	call	811361fc <__malloc_unlock>
811200d0:	80800204 	addi	r2,r16,8
811200d4:	00001b06 	br	81120144 <_malloc_r+0x2ac>
811200d8:	04400404 	movi	r17,16
811200dc:	89402536 	bltu	r17,r5,81120174 <_malloc_r+0x2dc>
811200e0:	11360d40 	call	811360d4 <__malloc_lock>
811200e4:	00800184 	movi	r2,6
811200e8:	01000084 	movi	r4,2
811200ec:	04e04574 	movhi	r19,33045
811200f0:	1085883a 	add	r2,r2,r2
811200f4:	9cfc8404 	addi	r19,r19,-3568
811200f8:	1085883a 	add	r2,r2,r2
811200fc:	9885883a 	add	r2,r19,r2
81120100:	14000117 	ldw	r16,4(r2)
81120104:	10fffe04 	addi	r3,r2,-8
81120108:	80c0d926 	beq	r16,r3,81120470 <_malloc_r+0x5d8>
8112010c:	80c00117 	ldw	r3,4(r16)
81120110:	81000317 	ldw	r4,12(r16)
81120114:	00bfff04 	movi	r2,-4
81120118:	1884703a 	and	r2,r3,r2
8112011c:	81400217 	ldw	r5,8(r16)
81120120:	8085883a 	add	r2,r16,r2
81120124:	10c00117 	ldw	r3,4(r2)
81120128:	29000315 	stw	r4,12(r5)
8112012c:	21400215 	stw	r5,8(r4)
81120130:	18c00054 	ori	r3,r3,1
81120134:	10c00115 	stw	r3,4(r2)
81120138:	9009883a 	mov	r4,r18
8112013c:	11361fc0 	call	811361fc <__malloc_unlock>
81120140:	80800204 	addi	r2,r16,8
81120144:	dfc00a17 	ldw	ra,40(sp)
81120148:	df000917 	ldw	fp,36(sp)
8112014c:	ddc00817 	ldw	r23,32(sp)
81120150:	dd800717 	ldw	r22,28(sp)
81120154:	dd400617 	ldw	r21,24(sp)
81120158:	dd000517 	ldw	r20,20(sp)
8112015c:	dcc00417 	ldw	r19,16(sp)
81120160:	dc800317 	ldw	r18,12(sp)
81120164:	dc400217 	ldw	r17,8(sp)
81120168:	dc000117 	ldw	r16,4(sp)
8112016c:	dec00b04 	addi	sp,sp,44
81120170:	f800283a 	ret
81120174:	00800304 	movi	r2,12
81120178:	90800015 	stw	r2,0(r18)
8112017c:	0005883a 	mov	r2,zero
81120180:	003ff006 	br	81120144 <__reset+0xfb100144>
81120184:	01002004 	movi	r4,128
81120188:	02001004 	movi	r8,64
8112018c:	01c00fc4 	movi	r7,63
81120190:	003f6106 	br	8111ff18 <__reset+0xfb0fff18>
81120194:	4009883a 	mov	r4,r8
81120198:	003f7506 	br	8111ff70 <__reset+0xfb0fff70>
8112019c:	81000317 	ldw	r4,12(r16)
811201a0:	003fde06 	br	8112011c <__reset+0xfb10011c>
811201a4:	81c5883a 	add	r2,r16,r7
811201a8:	11400117 	ldw	r5,4(r2)
811201ac:	9009883a 	mov	r4,r18
811201b0:	29400054 	ori	r5,r5,1
811201b4:	11400115 	stw	r5,4(r2)
811201b8:	11361fc0 	call	811361fc <__malloc_unlock>
811201bc:	80800204 	addi	r2,r16,8
811201c0:	003fe006 	br	81120144 <__reset+0xfb100144>
811201c4:	9c000217 	ldw	r16,8(r19)
811201c8:	00bfff04 	movi	r2,-4
811201cc:	85800117 	ldw	r22,4(r16)
811201d0:	b0ac703a 	and	r22,r22,r2
811201d4:	b4400336 	bltu	r22,r17,811201e4 <_malloc_r+0x34c>
811201d8:	b445c83a 	sub	r2,r22,r17
811201dc:	00c003c4 	movi	r3,15
811201e0:	18805d16 	blt	r3,r2,81120358 <_malloc_r+0x4c0>
811201e4:	05e04574 	movhi	r23,33045
811201e8:	00a04574 	movhi	r2,33045
811201ec:	10833b04 	addi	r2,r2,3308
811201f0:	bdc2c704 	addi	r23,r23,2844
811201f4:	15400017 	ldw	r21,0(r2)
811201f8:	b8c00017 	ldw	r3,0(r23)
811201fc:	00bfffc4 	movi	r2,-1
81120200:	858d883a 	add	r6,r16,r22
81120204:	8d6b883a 	add	r21,r17,r21
81120208:	1880ea26 	beq	r3,r2,811205b4 <_malloc_r+0x71c>
8112020c:	ad4403c4 	addi	r21,r21,4111
81120210:	00bc0004 	movi	r2,-4096
81120214:	a8aa703a 	and	r21,r21,r2
81120218:	a80b883a 	mov	r5,r21
8112021c:	9009883a 	mov	r4,r18
81120220:	d9800015 	stw	r6,0(sp)
81120224:	1120e540 	call	81120e54 <_sbrk_r>
81120228:	1029883a 	mov	r20,r2
8112022c:	00bfffc4 	movi	r2,-1
81120230:	d9800017 	ldw	r6,0(sp)
81120234:	a080e826 	beq	r20,r2,811205d8 <_malloc_r+0x740>
81120238:	a180a636 	bltu	r20,r6,811204d4 <_malloc_r+0x63c>
8112023c:	07204574 	movhi	fp,33045
81120240:	e703c804 	addi	fp,fp,3872
81120244:	e0800017 	ldw	r2,0(fp)
81120248:	a887883a 	add	r3,r21,r2
8112024c:	e0c00015 	stw	r3,0(fp)
81120250:	3500e626 	beq	r6,r20,811205ec <_malloc_r+0x754>
81120254:	b9000017 	ldw	r4,0(r23)
81120258:	00bfffc4 	movi	r2,-1
8112025c:	2080ee26 	beq	r4,r2,81120618 <_malloc_r+0x780>
81120260:	a185c83a 	sub	r2,r20,r6
81120264:	10c5883a 	add	r2,r2,r3
81120268:	e0800015 	stw	r2,0(fp)
8112026c:	a0c001cc 	andi	r3,r20,7
81120270:	1800bc26 	beq	r3,zero,81120564 <_malloc_r+0x6cc>
81120274:	a0e9c83a 	sub	r20,r20,r3
81120278:	00840204 	movi	r2,4104
8112027c:	a5000204 	addi	r20,r20,8
81120280:	10c7c83a 	sub	r3,r2,r3
81120284:	a545883a 	add	r2,r20,r21
81120288:	1083ffcc 	andi	r2,r2,4095
8112028c:	18abc83a 	sub	r21,r3,r2
81120290:	a80b883a 	mov	r5,r21
81120294:	9009883a 	mov	r4,r18
81120298:	1120e540 	call	81120e54 <_sbrk_r>
8112029c:	00ffffc4 	movi	r3,-1
811202a0:	10c0e126 	beq	r2,r3,81120628 <_malloc_r+0x790>
811202a4:	1505c83a 	sub	r2,r2,r20
811202a8:	1545883a 	add	r2,r2,r21
811202ac:	10800054 	ori	r2,r2,1
811202b0:	e0c00017 	ldw	r3,0(fp)
811202b4:	9d000215 	stw	r20,8(r19)
811202b8:	a0800115 	stw	r2,4(r20)
811202bc:	a8c7883a 	add	r3,r21,r3
811202c0:	e0c00015 	stw	r3,0(fp)
811202c4:	84c00e26 	beq	r16,r19,81120300 <_malloc_r+0x468>
811202c8:	018003c4 	movi	r6,15
811202cc:	3580a72e 	bgeu	r6,r22,8112056c <_malloc_r+0x6d4>
811202d0:	81400117 	ldw	r5,4(r16)
811202d4:	013ffe04 	movi	r4,-8
811202d8:	b0bffd04 	addi	r2,r22,-12
811202dc:	1104703a 	and	r2,r2,r4
811202e0:	2900004c 	andi	r4,r5,1
811202e4:	2088b03a 	or	r4,r4,r2
811202e8:	81000115 	stw	r4,4(r16)
811202ec:	01400144 	movi	r5,5
811202f0:	8089883a 	add	r4,r16,r2
811202f4:	21400115 	stw	r5,4(r4)
811202f8:	21400215 	stw	r5,8(r4)
811202fc:	3080cd36 	bltu	r6,r2,81120634 <_malloc_r+0x79c>
81120300:	00a04574 	movhi	r2,33045
81120304:	10833a04 	addi	r2,r2,3304
81120308:	11000017 	ldw	r4,0(r2)
8112030c:	20c0012e 	bgeu	r4,r3,81120314 <_malloc_r+0x47c>
81120310:	10c00015 	stw	r3,0(r2)
81120314:	00a04574 	movhi	r2,33045
81120318:	10833904 	addi	r2,r2,3300
8112031c:	11000017 	ldw	r4,0(r2)
81120320:	9c000217 	ldw	r16,8(r19)
81120324:	20c0012e 	bgeu	r4,r3,8112032c <_malloc_r+0x494>
81120328:	10c00015 	stw	r3,0(r2)
8112032c:	80c00117 	ldw	r3,4(r16)
81120330:	00bfff04 	movi	r2,-4
81120334:	1886703a 	and	r3,r3,r2
81120338:	1c45c83a 	sub	r2,r3,r17
8112033c:	1c400236 	bltu	r3,r17,81120348 <_malloc_r+0x4b0>
81120340:	00c003c4 	movi	r3,15
81120344:	18800416 	blt	r3,r2,81120358 <_malloc_r+0x4c0>
81120348:	9009883a 	mov	r4,r18
8112034c:	11361fc0 	call	811361fc <__malloc_unlock>
81120350:	0005883a 	mov	r2,zero
81120354:	003f7b06 	br	81120144 <__reset+0xfb100144>
81120358:	88c00054 	ori	r3,r17,1
8112035c:	80c00115 	stw	r3,4(r16)
81120360:	8463883a 	add	r17,r16,r17
81120364:	10800054 	ori	r2,r2,1
81120368:	9c400215 	stw	r17,8(r19)
8112036c:	88800115 	stw	r2,4(r17)
81120370:	9009883a 	mov	r4,r18
81120374:	11361fc0 	call	811361fc <__malloc_unlock>
81120378:	80800204 	addi	r2,r16,8
8112037c:	003f7106 	br	81120144 <__reset+0xfb100144>
81120380:	00c00504 	movi	r3,20
81120384:	18804a2e 	bgeu	r3,r2,811204b0 <_malloc_r+0x618>
81120388:	00c01504 	movi	r3,84
8112038c:	18806e36 	bltu	r3,r2,81120548 <_malloc_r+0x6b0>
81120390:	8804d33a 	srli	r2,r17,12
81120394:	12001bc4 	addi	r8,r2,111
81120398:	11c01b84 	addi	r7,r2,110
8112039c:	4209883a 	add	r4,r8,r8
811203a0:	003edd06 	br	8111ff18 <__reset+0xfb0fff18>
811203a4:	3804d27a 	srli	r2,r7,9
811203a8:	00c00104 	movi	r3,4
811203ac:	1880442e 	bgeu	r3,r2,811204c0 <_malloc_r+0x628>
811203b0:	00c00504 	movi	r3,20
811203b4:	18808136 	bltu	r3,r2,811205bc <_malloc_r+0x724>
811203b8:	11401704 	addi	r5,r2,92
811203bc:	10c016c4 	addi	r3,r2,91
811203c0:	294b883a 	add	r5,r5,r5
811203c4:	294b883a 	add	r5,r5,r5
811203c8:	294b883a 	add	r5,r5,r5
811203cc:	994b883a 	add	r5,r19,r5
811203d0:	28800017 	ldw	r2,0(r5)
811203d4:	01a04574 	movhi	r6,33045
811203d8:	297ffe04 	addi	r5,r5,-8
811203dc:	31bc8404 	addi	r6,r6,-3568
811203e0:	28806526 	beq	r5,r2,81120578 <_malloc_r+0x6e0>
811203e4:	01bfff04 	movi	r6,-4
811203e8:	10c00117 	ldw	r3,4(r2)
811203ec:	1986703a 	and	r3,r3,r6
811203f0:	38c0022e 	bgeu	r7,r3,811203fc <_malloc_r+0x564>
811203f4:	10800217 	ldw	r2,8(r2)
811203f8:	28bffb1e 	bne	r5,r2,811203e8 <__reset+0xfb1003e8>
811203fc:	11400317 	ldw	r5,12(r2)
81120400:	98c00117 	ldw	r3,4(r19)
81120404:	81400315 	stw	r5,12(r16)
81120408:	80800215 	stw	r2,8(r16)
8112040c:	2c000215 	stw	r16,8(r5)
81120410:	14000315 	stw	r16,12(r2)
81120414:	003ef806 	br	8111fff8 <__reset+0xfb0ffff8>
81120418:	88c00054 	ori	r3,r17,1
8112041c:	80c00115 	stw	r3,4(r16)
81120420:	8463883a 	add	r17,r16,r17
81120424:	34400515 	stw	r17,20(r6)
81120428:	34400415 	stw	r17,16(r6)
8112042c:	10c00054 	ori	r3,r2,1
81120430:	8a000315 	stw	r8,12(r17)
81120434:	8a000215 	stw	r8,8(r17)
81120438:	88c00115 	stw	r3,4(r17)
8112043c:	88a3883a 	add	r17,r17,r2
81120440:	88800015 	stw	r2,0(r17)
81120444:	9009883a 	mov	r4,r18
81120448:	11361fc0 	call	811361fc <__malloc_unlock>
8112044c:	80800204 	addi	r2,r16,8
81120450:	003f3c06 	br	81120144 <__reset+0xfb100144>
81120454:	30c00117 	ldw	r3,4(r6)
81120458:	003ee706 	br	8111fff8 <__reset+0xfb0ffff8>
8112045c:	5ac00044 	addi	r11,r11,1
81120460:	588000cc 	andi	r2,r11,3
81120464:	31800204 	addi	r6,r6,8
81120468:	103efd1e 	bne	r2,zero,81120060 <__reset+0xfb100060>
8112046c:	00002406 	br	81120500 <_malloc_r+0x668>
81120470:	14000317 	ldw	r16,12(r2)
81120474:	143f251e 	bne	r2,r16,8112010c <__reset+0xfb10010c>
81120478:	21000084 	addi	r4,r4,2
8112047c:	003ebc06 	br	8111ff70 <__reset+0xfb0fff70>
81120480:	8085883a 	add	r2,r16,r2
81120484:	10c00117 	ldw	r3,4(r2)
81120488:	81000317 	ldw	r4,12(r16)
8112048c:	81400217 	ldw	r5,8(r16)
81120490:	18c00054 	ori	r3,r3,1
81120494:	10c00115 	stw	r3,4(r2)
81120498:	29000315 	stw	r4,12(r5)
8112049c:	21400215 	stw	r5,8(r4)
811204a0:	9009883a 	mov	r4,r18
811204a4:	11361fc0 	call	811361fc <__malloc_unlock>
811204a8:	80800204 	addi	r2,r16,8
811204ac:	003f2506 	br	81120144 <__reset+0xfb100144>
811204b0:	12001704 	addi	r8,r2,92
811204b4:	11c016c4 	addi	r7,r2,91
811204b8:	4209883a 	add	r4,r8,r8
811204bc:	003e9606 	br	8111ff18 <__reset+0xfb0fff18>
811204c0:	3804d1ba 	srli	r2,r7,6
811204c4:	11400e44 	addi	r5,r2,57
811204c8:	10c00e04 	addi	r3,r2,56
811204cc:	294b883a 	add	r5,r5,r5
811204d0:	003fbc06 	br	811203c4 <__reset+0xfb1003c4>
811204d4:	84ff5926 	beq	r16,r19,8112023c <__reset+0xfb10023c>
811204d8:	00a04574 	movhi	r2,33045
811204dc:	10bc8404 	addi	r2,r2,-3568
811204e0:	14000217 	ldw	r16,8(r2)
811204e4:	00bfff04 	movi	r2,-4
811204e8:	80c00117 	ldw	r3,4(r16)
811204ec:	1886703a 	and	r3,r3,r2
811204f0:	003f9106 	br	81120338 <__reset+0xfb100338>
811204f4:	60800217 	ldw	r2,8(r12)
811204f8:	213fffc4 	addi	r4,r4,-1
811204fc:	1300651e 	bne	r2,r12,81120694 <_malloc_r+0x7fc>
81120500:	208000cc 	andi	r2,r4,3
81120504:	633ffe04 	addi	r12,r12,-8
81120508:	103ffa1e 	bne	r2,zero,811204f4 <__reset+0xfb1004f4>
8112050c:	98800117 	ldw	r2,4(r19)
81120510:	0146303a 	nor	r3,zero,r5
81120514:	1884703a 	and	r2,r3,r2
81120518:	98800115 	stw	r2,4(r19)
8112051c:	294b883a 	add	r5,r5,r5
81120520:	117f2836 	bltu	r2,r5,811201c4 <__reset+0xfb1001c4>
81120524:	283f2726 	beq	r5,zero,811201c4 <__reset+0xfb1001c4>
81120528:	2886703a 	and	r3,r5,r2
8112052c:	5809883a 	mov	r4,r11
81120530:	183ec31e 	bne	r3,zero,81120040 <__reset+0xfb100040>
81120534:	294b883a 	add	r5,r5,r5
81120538:	2886703a 	and	r3,r5,r2
8112053c:	21000104 	addi	r4,r4,4
81120540:	183ffc26 	beq	r3,zero,81120534 <__reset+0xfb100534>
81120544:	003ebe06 	br	81120040 <__reset+0xfb100040>
81120548:	00c05504 	movi	r3,340
8112054c:	18801236 	bltu	r3,r2,81120598 <_malloc_r+0x700>
81120550:	8804d3fa 	srli	r2,r17,15
81120554:	12001e04 	addi	r8,r2,120
81120558:	11c01dc4 	addi	r7,r2,119
8112055c:	4209883a 	add	r4,r8,r8
81120560:	003e6d06 	br	8111ff18 <__reset+0xfb0fff18>
81120564:	00c40004 	movi	r3,4096
81120568:	003f4606 	br	81120284 <__reset+0xfb100284>
8112056c:	00800044 	movi	r2,1
81120570:	a0800115 	stw	r2,4(r20)
81120574:	003f7406 	br	81120348 <__reset+0xfb100348>
81120578:	1805d0ba 	srai	r2,r3,2
8112057c:	01c00044 	movi	r7,1
81120580:	30c00117 	ldw	r3,4(r6)
81120584:	388e983a 	sll	r7,r7,r2
81120588:	2805883a 	mov	r2,r5
8112058c:	38c6b03a 	or	r3,r7,r3
81120590:	30c00115 	stw	r3,4(r6)
81120594:	003f9b06 	br	81120404 <__reset+0xfb100404>
81120598:	00c15504 	movi	r3,1364
8112059c:	18801a36 	bltu	r3,r2,81120608 <_malloc_r+0x770>
811205a0:	8804d4ba 	srli	r2,r17,18
811205a4:	12001f44 	addi	r8,r2,125
811205a8:	11c01f04 	addi	r7,r2,124
811205ac:	4209883a 	add	r4,r8,r8
811205b0:	003e5906 	br	8111ff18 <__reset+0xfb0fff18>
811205b4:	ad400404 	addi	r21,r21,16
811205b8:	003f1706 	br	81120218 <__reset+0xfb100218>
811205bc:	00c01504 	movi	r3,84
811205c0:	18802336 	bltu	r3,r2,81120650 <_malloc_r+0x7b8>
811205c4:	3804d33a 	srli	r2,r7,12
811205c8:	11401bc4 	addi	r5,r2,111
811205cc:	10c01b84 	addi	r3,r2,110
811205d0:	294b883a 	add	r5,r5,r5
811205d4:	003f7b06 	br	811203c4 <__reset+0xfb1003c4>
811205d8:	9c000217 	ldw	r16,8(r19)
811205dc:	00bfff04 	movi	r2,-4
811205e0:	80c00117 	ldw	r3,4(r16)
811205e4:	1886703a 	and	r3,r3,r2
811205e8:	003f5306 	br	81120338 <__reset+0xfb100338>
811205ec:	3083ffcc 	andi	r2,r6,4095
811205f0:	103f181e 	bne	r2,zero,81120254 <__reset+0xfb100254>
811205f4:	99000217 	ldw	r4,8(r19)
811205f8:	b545883a 	add	r2,r22,r21
811205fc:	10800054 	ori	r2,r2,1
81120600:	20800115 	stw	r2,4(r4)
81120604:	003f3e06 	br	81120300 <__reset+0xfb100300>
81120608:	01003f84 	movi	r4,254
8112060c:	02001fc4 	movi	r8,127
81120610:	01c01f84 	movi	r7,126
81120614:	003e4006 	br	8111ff18 <__reset+0xfb0fff18>
81120618:	00a04574 	movhi	r2,33045
8112061c:	1082c704 	addi	r2,r2,2844
81120620:	15000015 	stw	r20,0(r2)
81120624:	003f1106 	br	8112026c <__reset+0xfb10026c>
81120628:	00800044 	movi	r2,1
8112062c:	002b883a 	mov	r21,zero
81120630:	003f1f06 	br	811202b0 <__reset+0xfb1002b0>
81120634:	81400204 	addi	r5,r16,8
81120638:	9009883a 	mov	r4,r18
8112063c:	112990c0 	call	8112990c <_free_r>
81120640:	00a04574 	movhi	r2,33045
81120644:	1083c804 	addi	r2,r2,3872
81120648:	10c00017 	ldw	r3,0(r2)
8112064c:	003f2c06 	br	81120300 <__reset+0xfb100300>
81120650:	00c05504 	movi	r3,340
81120654:	18800536 	bltu	r3,r2,8112066c <_malloc_r+0x7d4>
81120658:	3804d3fa 	srli	r2,r7,15
8112065c:	11401e04 	addi	r5,r2,120
81120660:	10c01dc4 	addi	r3,r2,119
81120664:	294b883a 	add	r5,r5,r5
81120668:	003f5606 	br	811203c4 <__reset+0xfb1003c4>
8112066c:	00c15504 	movi	r3,1364
81120670:	18800536 	bltu	r3,r2,81120688 <_malloc_r+0x7f0>
81120674:	3804d4ba 	srli	r2,r7,18
81120678:	11401f44 	addi	r5,r2,125
8112067c:	10c01f04 	addi	r3,r2,124
81120680:	294b883a 	add	r5,r5,r5
81120684:	003f4f06 	br	811203c4 <__reset+0xfb1003c4>
81120688:	01403f84 	movi	r5,254
8112068c:	00c01f84 	movi	r3,126
81120690:	003f4c06 	br	811203c4 <__reset+0xfb1003c4>
81120694:	98800117 	ldw	r2,4(r19)
81120698:	003fa006 	br	8112051c <__reset+0xfb10051c>
8112069c:	8808d0fa 	srli	r4,r17,3
811206a0:	20800044 	addi	r2,r4,1
811206a4:	1085883a 	add	r2,r2,r2
811206a8:	003e9006 	br	811200ec <__reset+0xfb1000ec>

811206ac <memcpy>:
811206ac:	defffd04 	addi	sp,sp,-12
811206b0:	de00012e 	bgeu	sp,et,811206b8 <memcpy+0xc>
811206b4:	003b68fa 	trap	3
811206b8:	00c003c4 	movi	r3,15
811206bc:	dfc00215 	stw	ra,8(sp)
811206c0:	dc400115 	stw	r17,4(sp)
811206c4:	dc000015 	stw	r16,0(sp)
811206c8:	2005883a 	mov	r2,r4
811206cc:	1980452e 	bgeu	r3,r6,811207e4 <memcpy+0x138>
811206d0:	2906b03a 	or	r3,r5,r4
811206d4:	18c000cc 	andi	r3,r3,3
811206d8:	1800441e 	bne	r3,zero,811207ec <memcpy+0x140>
811206dc:	347ffc04 	addi	r17,r6,-16
811206e0:	8822d13a 	srli	r17,r17,4
811206e4:	28c00104 	addi	r3,r5,4
811206e8:	23400104 	addi	r13,r4,4
811206ec:	8820913a 	slli	r16,r17,4
811206f0:	2b000204 	addi	r12,r5,8
811206f4:	22c00204 	addi	r11,r4,8
811206f8:	84000504 	addi	r16,r16,20
811206fc:	2a800304 	addi	r10,r5,12
81120700:	22400304 	addi	r9,r4,12
81120704:	2c21883a 	add	r16,r5,r16
81120708:	2811883a 	mov	r8,r5
8112070c:	200f883a 	mov	r7,r4
81120710:	41000017 	ldw	r4,0(r8)
81120714:	1fc00017 	ldw	ra,0(r3)
81120718:	63c00017 	ldw	r15,0(r12)
8112071c:	39000015 	stw	r4,0(r7)
81120720:	53800017 	ldw	r14,0(r10)
81120724:	6fc00015 	stw	ra,0(r13)
81120728:	5bc00015 	stw	r15,0(r11)
8112072c:	4b800015 	stw	r14,0(r9)
81120730:	18c00404 	addi	r3,r3,16
81120734:	39c00404 	addi	r7,r7,16
81120738:	42000404 	addi	r8,r8,16
8112073c:	6b400404 	addi	r13,r13,16
81120740:	63000404 	addi	r12,r12,16
81120744:	5ac00404 	addi	r11,r11,16
81120748:	52800404 	addi	r10,r10,16
8112074c:	4a400404 	addi	r9,r9,16
81120750:	1c3fef1e 	bne	r3,r16,81120710 <__reset+0xfb100710>
81120754:	89c00044 	addi	r7,r17,1
81120758:	380e913a 	slli	r7,r7,4
8112075c:	310003cc 	andi	r4,r6,15
81120760:	02c000c4 	movi	r11,3
81120764:	11c7883a 	add	r3,r2,r7
81120768:	29cb883a 	add	r5,r5,r7
8112076c:	5900212e 	bgeu	r11,r4,811207f4 <memcpy+0x148>
81120770:	1813883a 	mov	r9,r3
81120774:	2811883a 	mov	r8,r5
81120778:	200f883a 	mov	r7,r4
8112077c:	42800017 	ldw	r10,0(r8)
81120780:	4a400104 	addi	r9,r9,4
81120784:	39ffff04 	addi	r7,r7,-4
81120788:	4abfff15 	stw	r10,-4(r9)
8112078c:	42000104 	addi	r8,r8,4
81120790:	59fffa36 	bltu	r11,r7,8112077c <__reset+0xfb10077c>
81120794:	213fff04 	addi	r4,r4,-4
81120798:	2008d0ba 	srli	r4,r4,2
8112079c:	318000cc 	andi	r6,r6,3
811207a0:	21000044 	addi	r4,r4,1
811207a4:	2109883a 	add	r4,r4,r4
811207a8:	2109883a 	add	r4,r4,r4
811207ac:	1907883a 	add	r3,r3,r4
811207b0:	290b883a 	add	r5,r5,r4
811207b4:	30000626 	beq	r6,zero,811207d0 <memcpy+0x124>
811207b8:	198d883a 	add	r6,r3,r6
811207bc:	29c00003 	ldbu	r7,0(r5)
811207c0:	18c00044 	addi	r3,r3,1
811207c4:	29400044 	addi	r5,r5,1
811207c8:	19ffffc5 	stb	r7,-1(r3)
811207cc:	19bffb1e 	bne	r3,r6,811207bc <__reset+0xfb1007bc>
811207d0:	dfc00217 	ldw	ra,8(sp)
811207d4:	dc400117 	ldw	r17,4(sp)
811207d8:	dc000017 	ldw	r16,0(sp)
811207dc:	dec00304 	addi	sp,sp,12
811207e0:	f800283a 	ret
811207e4:	2007883a 	mov	r3,r4
811207e8:	003ff206 	br	811207b4 <__reset+0xfb1007b4>
811207ec:	2007883a 	mov	r3,r4
811207f0:	003ff106 	br	811207b8 <__reset+0xfb1007b8>
811207f4:	200d883a 	mov	r6,r4
811207f8:	003fee06 	br	811207b4 <__reset+0xfb1007b4>

811207fc <memset>:
811207fc:	20c000cc 	andi	r3,r4,3
81120800:	2005883a 	mov	r2,r4
81120804:	18004426 	beq	r3,zero,81120918 <memset+0x11c>
81120808:	31ffffc4 	addi	r7,r6,-1
8112080c:	30004026 	beq	r6,zero,81120910 <memset+0x114>
81120810:	2813883a 	mov	r9,r5
81120814:	200d883a 	mov	r6,r4
81120818:	2007883a 	mov	r3,r4
8112081c:	00000406 	br	81120830 <memset+0x34>
81120820:	3a3fffc4 	addi	r8,r7,-1
81120824:	31800044 	addi	r6,r6,1
81120828:	38003926 	beq	r7,zero,81120910 <memset+0x114>
8112082c:	400f883a 	mov	r7,r8
81120830:	18c00044 	addi	r3,r3,1
81120834:	32400005 	stb	r9,0(r6)
81120838:	1a0000cc 	andi	r8,r3,3
8112083c:	403ff81e 	bne	r8,zero,81120820 <__reset+0xfb100820>
81120840:	010000c4 	movi	r4,3
81120844:	21c02d2e 	bgeu	r4,r7,811208fc <memset+0x100>
81120848:	29003fcc 	andi	r4,r5,255
8112084c:	200c923a 	slli	r6,r4,8
81120850:	3108b03a 	or	r4,r6,r4
81120854:	200c943a 	slli	r6,r4,16
81120858:	218cb03a 	or	r6,r4,r6
8112085c:	010003c4 	movi	r4,15
81120860:	21c0182e 	bgeu	r4,r7,811208c4 <memset+0xc8>
81120864:	3b3ffc04 	addi	r12,r7,-16
81120868:	6018d13a 	srli	r12,r12,4
8112086c:	1a000104 	addi	r8,r3,4
81120870:	1ac00204 	addi	r11,r3,8
81120874:	6008913a 	slli	r4,r12,4
81120878:	1a800304 	addi	r10,r3,12
8112087c:	1813883a 	mov	r9,r3
81120880:	21000504 	addi	r4,r4,20
81120884:	1909883a 	add	r4,r3,r4
81120888:	49800015 	stw	r6,0(r9)
8112088c:	41800015 	stw	r6,0(r8)
81120890:	59800015 	stw	r6,0(r11)
81120894:	51800015 	stw	r6,0(r10)
81120898:	42000404 	addi	r8,r8,16
8112089c:	4a400404 	addi	r9,r9,16
811208a0:	5ac00404 	addi	r11,r11,16
811208a4:	52800404 	addi	r10,r10,16
811208a8:	413ff71e 	bne	r8,r4,81120888 <__reset+0xfb100888>
811208ac:	63000044 	addi	r12,r12,1
811208b0:	6018913a 	slli	r12,r12,4
811208b4:	39c003cc 	andi	r7,r7,15
811208b8:	010000c4 	movi	r4,3
811208bc:	1b07883a 	add	r3,r3,r12
811208c0:	21c00e2e 	bgeu	r4,r7,811208fc <memset+0x100>
811208c4:	1813883a 	mov	r9,r3
811208c8:	3811883a 	mov	r8,r7
811208cc:	010000c4 	movi	r4,3
811208d0:	49800015 	stw	r6,0(r9)
811208d4:	423fff04 	addi	r8,r8,-4
811208d8:	4a400104 	addi	r9,r9,4
811208dc:	223ffc36 	bltu	r4,r8,811208d0 <__reset+0xfb1008d0>
811208e0:	393fff04 	addi	r4,r7,-4
811208e4:	2008d0ba 	srli	r4,r4,2
811208e8:	39c000cc 	andi	r7,r7,3
811208ec:	21000044 	addi	r4,r4,1
811208f0:	2109883a 	add	r4,r4,r4
811208f4:	2109883a 	add	r4,r4,r4
811208f8:	1907883a 	add	r3,r3,r4
811208fc:	38000526 	beq	r7,zero,81120914 <memset+0x118>
81120900:	19cf883a 	add	r7,r3,r7
81120904:	19400005 	stb	r5,0(r3)
81120908:	18c00044 	addi	r3,r3,1
8112090c:	38fffd1e 	bne	r7,r3,81120904 <__reset+0xfb100904>
81120910:	f800283a 	ret
81120914:	f800283a 	ret
81120918:	2007883a 	mov	r3,r4
8112091c:	300f883a 	mov	r7,r6
81120920:	003fc706 	br	81120840 <__reset+0xfb100840>

81120924 <_open_r>:
81120924:	defffd04 	addi	sp,sp,-12
81120928:	de00012e 	bgeu	sp,et,81120930 <_open_r+0xc>
8112092c:	003b68fa 	trap	3
81120930:	2805883a 	mov	r2,r5
81120934:	dc000015 	stw	r16,0(sp)
81120938:	04204574 	movhi	r16,33045
8112093c:	dc400115 	stw	r17,4(sp)
81120940:	300b883a 	mov	r5,r6
81120944:	84033804 	addi	r16,r16,3296
81120948:	2023883a 	mov	r17,r4
8112094c:	380d883a 	mov	r6,r7
81120950:	1009883a 	mov	r4,r2
81120954:	dfc00215 	stw	ra,8(sp)
81120958:	80000015 	stw	zero,0(r16)
8112095c:	11357540 	call	81135754 <open>
81120960:	00ffffc4 	movi	r3,-1
81120964:	10c00526 	beq	r2,r3,8112097c <_open_r+0x58>
81120968:	dfc00217 	ldw	ra,8(sp)
8112096c:	dc400117 	ldw	r17,4(sp)
81120970:	dc000017 	ldw	r16,0(sp)
81120974:	dec00304 	addi	sp,sp,12
81120978:	f800283a 	ret
8112097c:	80c00017 	ldw	r3,0(r16)
81120980:	183ff926 	beq	r3,zero,81120968 <__reset+0xfb100968>
81120984:	88c00015 	stw	r3,0(r17)
81120988:	003ff706 	br	81120968 <__reset+0xfb100968>

8112098c <_printf_r>:
8112098c:	defffd04 	addi	sp,sp,-12
81120990:	2805883a 	mov	r2,r5
81120994:	de00012e 	bgeu	sp,et,8112099c <_printf_r+0x10>
81120998:	003b68fa 	trap	3
8112099c:	dfc00015 	stw	ra,0(sp)
811209a0:	d9800115 	stw	r6,4(sp)
811209a4:	d9c00215 	stw	r7,8(sp)
811209a8:	21400217 	ldw	r5,8(r4)
811209ac:	d9c00104 	addi	r7,sp,4
811209b0:	100d883a 	mov	r6,r2
811209b4:	11236b80 	call	811236b8 <___vfprintf_internal_r>
811209b8:	dfc00017 	ldw	ra,0(sp)
811209bc:	dec00304 	addi	sp,sp,12
811209c0:	f800283a 	ret

811209c4 <printf>:
811209c4:	defffc04 	addi	sp,sp,-16
811209c8:	de00012e 	bgeu	sp,et,811209d0 <printf+0xc>
811209cc:	003b68fa 	trap	3
811209d0:	dfc00015 	stw	ra,0(sp)
811209d4:	d9400115 	stw	r5,4(sp)
811209d8:	d9800215 	stw	r6,8(sp)
811209dc:	d9c00315 	stw	r7,12(sp)
811209e0:	00a04574 	movhi	r2,33045
811209e4:	1082c604 	addi	r2,r2,2840
811209e8:	10800017 	ldw	r2,0(r2)
811209ec:	200b883a 	mov	r5,r4
811209f0:	d9800104 	addi	r6,sp,4
811209f4:	11000217 	ldw	r4,8(r2)
811209f8:	11258b80 	call	811258b8 <__vfprintf_internal>
811209fc:	dfc00017 	ldw	ra,0(sp)
81120a00:	dec00404 	addi	sp,sp,16
81120a04:	f800283a 	ret

81120a08 <_putc_r>:
81120a08:	defffc04 	addi	sp,sp,-16
81120a0c:	de00012e 	bgeu	sp,et,81120a14 <_putc_r+0xc>
81120a10:	003b68fa 	trap	3
81120a14:	dc000215 	stw	r16,8(sp)
81120a18:	dfc00315 	stw	ra,12(sp)
81120a1c:	2021883a 	mov	r16,r4
81120a20:	20000226 	beq	r4,zero,81120a2c <_putc_r+0x24>
81120a24:	20800e17 	ldw	r2,56(r4)
81120a28:	10001b26 	beq	r2,zero,81120a98 <_putc_r+0x90>
81120a2c:	30800217 	ldw	r2,8(r6)
81120a30:	10bfffc4 	addi	r2,r2,-1
81120a34:	30800215 	stw	r2,8(r6)
81120a38:	10000a16 	blt	r2,zero,81120a64 <_putc_r+0x5c>
81120a3c:	30800017 	ldw	r2,0(r6)
81120a40:	11400005 	stb	r5,0(r2)
81120a44:	30800017 	ldw	r2,0(r6)
81120a48:	10c00044 	addi	r3,r2,1
81120a4c:	30c00015 	stw	r3,0(r6)
81120a50:	10800003 	ldbu	r2,0(r2)
81120a54:	dfc00317 	ldw	ra,12(sp)
81120a58:	dc000217 	ldw	r16,8(sp)
81120a5c:	dec00404 	addi	sp,sp,16
81120a60:	f800283a 	ret
81120a64:	30c00617 	ldw	r3,24(r6)
81120a68:	10c00616 	blt	r2,r3,81120a84 <_putc_r+0x7c>
81120a6c:	30800017 	ldw	r2,0(r6)
81120a70:	00c00284 	movi	r3,10
81120a74:	11400005 	stb	r5,0(r2)
81120a78:	30800017 	ldw	r2,0(r6)
81120a7c:	11400003 	ldbu	r5,0(r2)
81120a80:	28fff11e 	bne	r5,r3,81120a48 <__reset+0xfb100a48>
81120a84:	8009883a 	mov	r4,r16
81120a88:	dfc00317 	ldw	ra,12(sp)
81120a8c:	dc000217 	ldw	r16,8(sp)
81120a90:	dec00404 	addi	sp,sp,16
81120a94:	112723c1 	jmpi	8112723c <__swbuf_r>
81120a98:	d9400015 	stw	r5,0(sp)
81120a9c:	d9800115 	stw	r6,4(sp)
81120aa0:	11294740 	call	81129474 <__sinit>
81120aa4:	d9800117 	ldw	r6,4(sp)
81120aa8:	d9400017 	ldw	r5,0(sp)
81120aac:	003fdf06 	br	81120a2c <__reset+0xfb100a2c>

81120ab0 <putc>:
81120ab0:	00a04574 	movhi	r2,33045
81120ab4:	defffc04 	addi	sp,sp,-16
81120ab8:	1082c604 	addi	r2,r2,2840
81120abc:	de00012e 	bgeu	sp,et,81120ac4 <putc+0x14>
81120ac0:	003b68fa 	trap	3
81120ac4:	dc000115 	stw	r16,4(sp)
81120ac8:	14000017 	ldw	r16,0(r2)
81120acc:	dc400215 	stw	r17,8(sp)
81120ad0:	dfc00315 	stw	ra,12(sp)
81120ad4:	2023883a 	mov	r17,r4
81120ad8:	80000226 	beq	r16,zero,81120ae4 <putc+0x34>
81120adc:	80800e17 	ldw	r2,56(r16)
81120ae0:	10001a26 	beq	r2,zero,81120b4c <putc+0x9c>
81120ae4:	28800217 	ldw	r2,8(r5)
81120ae8:	10bfffc4 	addi	r2,r2,-1
81120aec:	28800215 	stw	r2,8(r5)
81120af0:	10000b16 	blt	r2,zero,81120b20 <putc+0x70>
81120af4:	28800017 	ldw	r2,0(r5)
81120af8:	14400005 	stb	r17,0(r2)
81120afc:	28800017 	ldw	r2,0(r5)
81120b00:	10c00044 	addi	r3,r2,1
81120b04:	28c00015 	stw	r3,0(r5)
81120b08:	10800003 	ldbu	r2,0(r2)
81120b0c:	dfc00317 	ldw	ra,12(sp)
81120b10:	dc400217 	ldw	r17,8(sp)
81120b14:	dc000117 	ldw	r16,4(sp)
81120b18:	dec00404 	addi	sp,sp,16
81120b1c:	f800283a 	ret
81120b20:	28c00617 	ldw	r3,24(r5)
81120b24:	10c00e16 	blt	r2,r3,81120b60 <putc+0xb0>
81120b28:	28800017 	ldw	r2,0(r5)
81120b2c:	01000284 	movi	r4,10
81120b30:	14400005 	stb	r17,0(r2)
81120b34:	28800017 	ldw	r2,0(r5)
81120b38:	10c00003 	ldbu	r3,0(r2)
81120b3c:	193ff01e 	bne	r3,r4,81120b00 <__reset+0xfb100b00>
81120b40:	280d883a 	mov	r6,r5
81120b44:	180b883a 	mov	r5,r3
81120b48:	00000706 	br	81120b68 <putc+0xb8>
81120b4c:	8009883a 	mov	r4,r16
81120b50:	d9400015 	stw	r5,0(sp)
81120b54:	11294740 	call	81129474 <__sinit>
81120b58:	d9400017 	ldw	r5,0(sp)
81120b5c:	003fe106 	br	81120ae4 <__reset+0xfb100ae4>
81120b60:	280d883a 	mov	r6,r5
81120b64:	880b883a 	mov	r5,r17
81120b68:	8009883a 	mov	r4,r16
81120b6c:	dfc00317 	ldw	ra,12(sp)
81120b70:	dc400217 	ldw	r17,8(sp)
81120b74:	dc000117 	ldw	r16,4(sp)
81120b78:	dec00404 	addi	sp,sp,16
81120b7c:	112723c1 	jmpi	8112723c <__swbuf_r>

81120b80 <_puts_r>:
81120b80:	defff604 	addi	sp,sp,-40
81120b84:	de00012e 	bgeu	sp,et,81120b8c <_puts_r+0xc>
81120b88:	003b68fa 	trap	3
81120b8c:	dc000715 	stw	r16,28(sp)
81120b90:	2021883a 	mov	r16,r4
81120b94:	2809883a 	mov	r4,r5
81120b98:	dc400815 	stw	r17,32(sp)
81120b9c:	dfc00915 	stw	ra,36(sp)
81120ba0:	2823883a 	mov	r17,r5
81120ba4:	11211a00 	call	811211a0 <strlen>
81120ba8:	10c00044 	addi	r3,r2,1
81120bac:	d8800115 	stw	r2,4(sp)
81120bb0:	00a04574 	movhi	r2,33045
81120bb4:	10b8ed04 	addi	r2,r2,-7244
81120bb8:	d8800215 	stw	r2,8(sp)
81120bbc:	00800044 	movi	r2,1
81120bc0:	d8800315 	stw	r2,12(sp)
81120bc4:	00800084 	movi	r2,2
81120bc8:	dc400015 	stw	r17,0(sp)
81120bcc:	d8c00615 	stw	r3,24(sp)
81120bd0:	dec00415 	stw	sp,16(sp)
81120bd4:	d8800515 	stw	r2,20(sp)
81120bd8:	80000226 	beq	r16,zero,81120be4 <_puts_r+0x64>
81120bdc:	80800e17 	ldw	r2,56(r16)
81120be0:	10001426 	beq	r2,zero,81120c34 <_puts_r+0xb4>
81120be4:	81400217 	ldw	r5,8(r16)
81120be8:	2880030b 	ldhu	r2,12(r5)
81120bec:	10c8000c 	andi	r3,r2,8192
81120bf0:	1800061e 	bne	r3,zero,81120c0c <_puts_r+0x8c>
81120bf4:	29001917 	ldw	r4,100(r5)
81120bf8:	00f7ffc4 	movi	r3,-8193
81120bfc:	10880014 	ori	r2,r2,8192
81120c00:	20c6703a 	and	r3,r4,r3
81120c04:	2880030d 	sth	r2,12(r5)
81120c08:	28c01915 	stw	r3,100(r5)
81120c0c:	d9800404 	addi	r6,sp,16
81120c10:	8009883a 	mov	r4,r16
81120c14:	1129c240 	call	81129c24 <__sfvwrite_r>
81120c18:	1000091e 	bne	r2,zero,81120c40 <_puts_r+0xc0>
81120c1c:	00800284 	movi	r2,10
81120c20:	dfc00917 	ldw	ra,36(sp)
81120c24:	dc400817 	ldw	r17,32(sp)
81120c28:	dc000717 	ldw	r16,28(sp)
81120c2c:	dec00a04 	addi	sp,sp,40
81120c30:	f800283a 	ret
81120c34:	8009883a 	mov	r4,r16
81120c38:	11294740 	call	81129474 <__sinit>
81120c3c:	003fe906 	br	81120be4 <__reset+0xfb100be4>
81120c40:	00bfffc4 	movi	r2,-1
81120c44:	003ff606 	br	81120c20 <__reset+0xfb100c20>

81120c48 <puts>:
81120c48:	00a04574 	movhi	r2,33045
81120c4c:	1082c604 	addi	r2,r2,2840
81120c50:	200b883a 	mov	r5,r4
81120c54:	11000017 	ldw	r4,0(r2)
81120c58:	1120b801 	jmpi	81120b80 <_puts_r>

81120c5c <lflush>:
81120c5c:	2080030b 	ldhu	r2,12(r4)
81120c60:	00c00244 	movi	r3,9
81120c64:	1080024c 	andi	r2,r2,9
81120c68:	10c00226 	beq	r2,r3,81120c74 <lflush+0x18>
81120c6c:	0005883a 	mov	r2,zero
81120c70:	f800283a 	ret
81120c74:	11290dc1 	jmpi	811290dc <fflush>

81120c78 <__srefill_r>:
81120c78:	defffc04 	addi	sp,sp,-16
81120c7c:	de00012e 	bgeu	sp,et,81120c84 <__srefill_r+0xc>
81120c80:	003b68fa 	trap	3
81120c84:	dc400115 	stw	r17,4(sp)
81120c88:	dc000015 	stw	r16,0(sp)
81120c8c:	dfc00315 	stw	ra,12(sp)
81120c90:	dc800215 	stw	r18,8(sp)
81120c94:	2023883a 	mov	r17,r4
81120c98:	2821883a 	mov	r16,r5
81120c9c:	20000226 	beq	r4,zero,81120ca8 <__srefill_r+0x30>
81120ca0:	20800e17 	ldw	r2,56(r4)
81120ca4:	10003c26 	beq	r2,zero,81120d98 <__srefill_r+0x120>
81120ca8:	80c0030b 	ldhu	r3,12(r16)
81120cac:	1908000c 	andi	r4,r3,8192
81120cb0:	1805883a 	mov	r2,r3
81120cb4:	2000071e 	bne	r4,zero,81120cd4 <__srefill_r+0x5c>
81120cb8:	81001917 	ldw	r4,100(r16)
81120cbc:	18880014 	ori	r2,r3,8192
81120cc0:	00f7ffc4 	movi	r3,-8193
81120cc4:	20c8703a 	and	r4,r4,r3
81120cc8:	8080030d 	sth	r2,12(r16)
81120ccc:	1007883a 	mov	r3,r2
81120cd0:	81001915 	stw	r4,100(r16)
81120cd4:	80000115 	stw	zero,4(r16)
81120cd8:	1100080c 	andi	r4,r2,32
81120cdc:	2000571e 	bne	r4,zero,81120e3c <__srefill_r+0x1c4>
81120ce0:	1100010c 	andi	r4,r2,4
81120ce4:	20001f26 	beq	r4,zero,81120d64 <__srefill_r+0xec>
81120ce8:	81400c17 	ldw	r5,48(r16)
81120cec:	28000826 	beq	r5,zero,81120d10 <__srefill_r+0x98>
81120cf0:	80801004 	addi	r2,r16,64
81120cf4:	28800226 	beq	r5,r2,81120d00 <__srefill_r+0x88>
81120cf8:	8809883a 	mov	r4,r17
81120cfc:	112990c0 	call	8112990c <_free_r>
81120d00:	80800f17 	ldw	r2,60(r16)
81120d04:	80000c15 	stw	zero,48(r16)
81120d08:	80800115 	stw	r2,4(r16)
81120d0c:	1000391e 	bne	r2,zero,81120df4 <__srefill_r+0x17c>
81120d10:	80800417 	ldw	r2,16(r16)
81120d14:	10004b26 	beq	r2,zero,81120e44 <__srefill_r+0x1cc>
81120d18:	8480030b 	ldhu	r18,12(r16)
81120d1c:	908000cc 	andi	r2,r18,3
81120d20:	10001f1e 	bne	r2,zero,81120da0 <__srefill_r+0x128>
81120d24:	81800417 	ldw	r6,16(r16)
81120d28:	80800817 	ldw	r2,32(r16)
81120d2c:	81c00517 	ldw	r7,20(r16)
81120d30:	81400717 	ldw	r5,28(r16)
81120d34:	81800015 	stw	r6,0(r16)
81120d38:	8809883a 	mov	r4,r17
81120d3c:	103ee83a 	callr	r2
81120d40:	80800115 	stw	r2,4(r16)
81120d44:	00800e0e 	bge	zero,r2,81120d80 <__srefill_r+0x108>
81120d48:	0005883a 	mov	r2,zero
81120d4c:	dfc00317 	ldw	ra,12(sp)
81120d50:	dc800217 	ldw	r18,8(sp)
81120d54:	dc400117 	ldw	r17,4(sp)
81120d58:	dc000017 	ldw	r16,0(sp)
81120d5c:	dec00404 	addi	sp,sp,16
81120d60:	f800283a 	ret
81120d64:	1100040c 	andi	r4,r2,16
81120d68:	20003026 	beq	r4,zero,81120e2c <__srefill_r+0x1b4>
81120d6c:	1080020c 	andi	r2,r2,8
81120d70:	1000241e 	bne	r2,zero,81120e04 <__srefill_r+0x18c>
81120d74:	18c00114 	ori	r3,r3,4
81120d78:	80c0030d 	sth	r3,12(r16)
81120d7c:	003fe406 	br	81120d10 <__reset+0xfb100d10>
81120d80:	80c0030b 	ldhu	r3,12(r16)
81120d84:	1000161e 	bne	r2,zero,81120de0 <__srefill_r+0x168>
81120d88:	18c00814 	ori	r3,r3,32
81120d8c:	00bfffc4 	movi	r2,-1
81120d90:	80c0030d 	sth	r3,12(r16)
81120d94:	003fed06 	br	81120d4c <__reset+0xfb100d4c>
81120d98:	11294740 	call	81129474 <__sinit>
81120d9c:	003fc206 	br	81120ca8 <__reset+0xfb100ca8>
81120da0:	00a04574 	movhi	r2,33045
81120da4:	1082c504 	addi	r2,r2,2836
81120da8:	11000017 	ldw	r4,0(r2)
81120dac:	016044b4 	movhi	r5,33042
81120db0:	00800044 	movi	r2,1
81120db4:	29431704 	addi	r5,r5,3164
81120db8:	8080030d 	sth	r2,12(r16)
81120dbc:	112a0e80 	call	8112a0e8 <_fwalk>
81120dc0:	00800244 	movi	r2,9
81120dc4:	8480030d 	sth	r18,12(r16)
81120dc8:	9480024c 	andi	r18,r18,9
81120dcc:	90bfd51e 	bne	r18,r2,81120d24 <__reset+0xfb100d24>
81120dd0:	800b883a 	mov	r5,r16
81120dd4:	8809883a 	mov	r4,r17
81120dd8:	1128e540 	call	81128e54 <__sflush_r>
81120ddc:	003fd106 	br	81120d24 <__reset+0xfb100d24>
81120de0:	18c01014 	ori	r3,r3,64
81120de4:	80000115 	stw	zero,4(r16)
81120de8:	00bfffc4 	movi	r2,-1
81120dec:	80c0030d 	sth	r3,12(r16)
81120df0:	003fd606 	br	81120d4c <__reset+0xfb100d4c>
81120df4:	80c00e17 	ldw	r3,56(r16)
81120df8:	0005883a 	mov	r2,zero
81120dfc:	80c00015 	stw	r3,0(r16)
81120e00:	003fd206 	br	81120d4c <__reset+0xfb100d4c>
81120e04:	800b883a 	mov	r5,r16
81120e08:	8809883a 	mov	r4,r17
81120e0c:	11290780 	call	81129078 <_fflush_r>
81120e10:	10000a1e 	bne	r2,zero,81120e3c <__srefill_r+0x1c4>
81120e14:	8080030b 	ldhu	r2,12(r16)
81120e18:	00fffdc4 	movi	r3,-9
81120e1c:	80000215 	stw	zero,8(r16)
81120e20:	1886703a 	and	r3,r3,r2
81120e24:	80000615 	stw	zero,24(r16)
81120e28:	003fd206 	br	81120d74 <__reset+0xfb100d74>
81120e2c:	00800244 	movi	r2,9
81120e30:	88800015 	stw	r2,0(r17)
81120e34:	18c01014 	ori	r3,r3,64
81120e38:	80c0030d 	sth	r3,12(r16)
81120e3c:	00bfffc4 	movi	r2,-1
81120e40:	003fc206 	br	81120d4c <__reset+0xfb100d4c>
81120e44:	800b883a 	mov	r5,r16
81120e48:	8809883a 	mov	r4,r17
81120e4c:	111fcd40 	call	8111fcd4 <__smakebuf_r>
81120e50:	003fb106 	br	81120d18 <__reset+0xfb100d18>

81120e54 <_sbrk_r>:
81120e54:	defffd04 	addi	sp,sp,-12
81120e58:	de00012e 	bgeu	sp,et,81120e60 <_sbrk_r+0xc>
81120e5c:	003b68fa 	trap	3
81120e60:	dc000015 	stw	r16,0(sp)
81120e64:	04204574 	movhi	r16,33045
81120e68:	dc400115 	stw	r17,4(sp)
81120e6c:	84033804 	addi	r16,r16,3296
81120e70:	2023883a 	mov	r17,r4
81120e74:	2809883a 	mov	r4,r5
81120e78:	dfc00215 	stw	ra,8(sp)
81120e7c:	80000015 	stw	zero,0(r16)
81120e80:	1135a640 	call	81135a64 <sbrk>
81120e84:	00ffffc4 	movi	r3,-1
81120e88:	10c00526 	beq	r2,r3,81120ea0 <_sbrk_r+0x4c>
81120e8c:	dfc00217 	ldw	ra,8(sp)
81120e90:	dc400117 	ldw	r17,4(sp)
81120e94:	dc000017 	ldw	r16,0(sp)
81120e98:	dec00304 	addi	sp,sp,12
81120e9c:	f800283a 	ret
81120ea0:	80c00017 	ldw	r3,0(r16)
81120ea4:	183ff926 	beq	r3,zero,81120e8c <__reset+0xfb100e8c>
81120ea8:	88c00015 	stw	r3,0(r17)
81120eac:	003ff706 	br	81120e8c <__reset+0xfb100e8c>

81120eb0 <scanf>:
81120eb0:	defffc04 	addi	sp,sp,-16
81120eb4:	de00012e 	bgeu	sp,et,81120ebc <scanf+0xc>
81120eb8:	003b68fa 	trap	3
81120ebc:	dfc00015 	stw	ra,0(sp)
81120ec0:	d9400115 	stw	r5,4(sp)
81120ec4:	d9800215 	stw	r6,8(sp)
81120ec8:	d9c00315 	stw	r7,12(sp)
81120ecc:	00a04574 	movhi	r2,33045
81120ed0:	1082c604 	addi	r2,r2,2840
81120ed4:	200d883a 	mov	r6,r4
81120ed8:	11000017 	ldw	r4,0(r2)
81120edc:	d9c00104 	addi	r7,sp,4
81120ee0:	21400117 	ldw	r5,4(r4)
81120ee4:	11271e80 	call	811271e8 <_vfscanf_r>
81120ee8:	dfc00017 	ldw	ra,0(sp)
81120eec:	dec00404 	addi	sp,sp,16
81120ef0:	f800283a 	ret

81120ef4 <_scanf_r>:
81120ef4:	defffd04 	addi	sp,sp,-12
81120ef8:	2805883a 	mov	r2,r5
81120efc:	de00012e 	bgeu	sp,et,81120f04 <_scanf_r+0x10>
81120f00:	003b68fa 	trap	3
81120f04:	dfc00015 	stw	ra,0(sp)
81120f08:	d9800115 	stw	r6,4(sp)
81120f0c:	d9c00215 	stw	r7,8(sp)
81120f10:	21400117 	ldw	r5,4(r4)
81120f14:	d9c00104 	addi	r7,sp,4
81120f18:	100d883a 	mov	r6,r2
81120f1c:	11271e80 	call	811271e8 <_vfscanf_r>
81120f20:	dfc00017 	ldw	ra,0(sp)
81120f24:	dec00304 	addi	sp,sp,12
81120f28:	f800283a 	ret

81120f2c <_sprintf_r>:
81120f2c:	deffe404 	addi	sp,sp,-112
81120f30:	2807883a 	mov	r3,r5
81120f34:	de00012e 	bgeu	sp,et,81120f3c <_sprintf_r+0x10>
81120f38:	003b68fa 	trap	3
81120f3c:	dfc01a15 	stw	ra,104(sp)
81120f40:	d9c01b15 	stw	r7,108(sp)
81120f44:	00a00034 	movhi	r2,32768
81120f48:	10bfffc4 	addi	r2,r2,-1
81120f4c:	02008204 	movi	r8,520
81120f50:	d8800215 	stw	r2,8(sp)
81120f54:	d8800515 	stw	r2,20(sp)
81120f58:	d9c01b04 	addi	r7,sp,108
81120f5c:	d80b883a 	mov	r5,sp
81120f60:	00bfffc4 	movi	r2,-1
81120f64:	d8c00015 	stw	r3,0(sp)
81120f68:	d8c00415 	stw	r3,16(sp)
81120f6c:	da00030d 	sth	r8,12(sp)
81120f70:	d880038d 	sth	r2,14(sp)
81120f74:	11214d80 	call	811214d8 <___svfprintf_internal_r>
81120f78:	d8c00017 	ldw	r3,0(sp)
81120f7c:	18000005 	stb	zero,0(r3)
81120f80:	dfc01a17 	ldw	ra,104(sp)
81120f84:	dec01c04 	addi	sp,sp,112
81120f88:	f800283a 	ret

81120f8c <sprintf>:
81120f8c:	deffe304 	addi	sp,sp,-116
81120f90:	2007883a 	mov	r3,r4
81120f94:	de00012e 	bgeu	sp,et,81120f9c <sprintf+0x10>
81120f98:	003b68fa 	trap	3
81120f9c:	dfc01a15 	stw	ra,104(sp)
81120fa0:	d9801b15 	stw	r6,108(sp)
81120fa4:	d9c01c15 	stw	r7,112(sp)
81120fa8:	01204574 	movhi	r4,33045
81120fac:	2102c604 	addi	r4,r4,2840
81120fb0:	21000017 	ldw	r4,0(r4)
81120fb4:	00a00034 	movhi	r2,32768
81120fb8:	10bfffc4 	addi	r2,r2,-1
81120fbc:	280d883a 	mov	r6,r5
81120fc0:	02008204 	movi	r8,520
81120fc4:	d8800215 	stw	r2,8(sp)
81120fc8:	d8800515 	stw	r2,20(sp)
81120fcc:	d9c01b04 	addi	r7,sp,108
81120fd0:	d80b883a 	mov	r5,sp
81120fd4:	00bfffc4 	movi	r2,-1
81120fd8:	d8c00015 	stw	r3,0(sp)
81120fdc:	d8c00415 	stw	r3,16(sp)
81120fe0:	da00030d 	sth	r8,12(sp)
81120fe4:	d880038d 	sth	r2,14(sp)
81120fe8:	11214d80 	call	811214d8 <___svfprintf_internal_r>
81120fec:	d8c00017 	ldw	r3,0(sp)
81120ff0:	18000005 	stb	zero,0(r3)
81120ff4:	dfc01a17 	ldw	ra,104(sp)
81120ff8:	dec01d04 	addi	sp,sp,116
81120ffc:	f800283a 	ret

81121000 <__sread>:
81121000:	defffe04 	addi	sp,sp,-8
81121004:	de00012e 	bgeu	sp,et,8112100c <__sread+0xc>
81121008:	003b68fa 	trap	3
8112100c:	dc000015 	stw	r16,0(sp)
81121010:	2821883a 	mov	r16,r5
81121014:	2940038f 	ldh	r5,14(r5)
81121018:	dfc00115 	stw	ra,4(sp)
8112101c:	112b9380 	call	8112b938 <_read_r>
81121020:	10000716 	blt	r2,zero,81121040 <__sread+0x40>
81121024:	80c01417 	ldw	r3,80(r16)
81121028:	1887883a 	add	r3,r3,r2
8112102c:	80c01415 	stw	r3,80(r16)
81121030:	dfc00117 	ldw	ra,4(sp)
81121034:	dc000017 	ldw	r16,0(sp)
81121038:	dec00204 	addi	sp,sp,8
8112103c:	f800283a 	ret
81121040:	80c0030b 	ldhu	r3,12(r16)
81121044:	18fbffcc 	andi	r3,r3,61439
81121048:	80c0030d 	sth	r3,12(r16)
8112104c:	dfc00117 	ldw	ra,4(sp)
81121050:	dc000017 	ldw	r16,0(sp)
81121054:	dec00204 	addi	sp,sp,8
81121058:	f800283a 	ret

8112105c <__seofread>:
8112105c:	0005883a 	mov	r2,zero
81121060:	f800283a 	ret

81121064 <__swrite>:
81121064:	defffb04 	addi	sp,sp,-20
81121068:	de00012e 	bgeu	sp,et,81121070 <__swrite+0xc>
8112106c:	003b68fa 	trap	3
81121070:	2880030b 	ldhu	r2,12(r5)
81121074:	dcc00315 	stw	r19,12(sp)
81121078:	dc800215 	stw	r18,8(sp)
8112107c:	dc400115 	stw	r17,4(sp)
81121080:	dc000015 	stw	r16,0(sp)
81121084:	dfc00415 	stw	ra,16(sp)
81121088:	10c0400c 	andi	r3,r2,256
8112108c:	2821883a 	mov	r16,r5
81121090:	2023883a 	mov	r17,r4
81121094:	3025883a 	mov	r18,r6
81121098:	3827883a 	mov	r19,r7
8112109c:	18000526 	beq	r3,zero,811210b4 <__swrite+0x50>
811210a0:	2940038f 	ldh	r5,14(r5)
811210a4:	01c00084 	movi	r7,2
811210a8:	000d883a 	mov	r6,zero
811210ac:	112a3f00 	call	8112a3f0 <_lseek_r>
811210b0:	8080030b 	ldhu	r2,12(r16)
811210b4:	8140038f 	ldh	r5,14(r16)
811210b8:	10bbffcc 	andi	r2,r2,61439
811210bc:	980f883a 	mov	r7,r19
811210c0:	900d883a 	mov	r6,r18
811210c4:	8809883a 	mov	r4,r17
811210c8:	8080030d 	sth	r2,12(r16)
811210cc:	dfc00417 	ldw	ra,16(sp)
811210d0:	dcc00317 	ldw	r19,12(sp)
811210d4:	dc800217 	ldw	r18,8(sp)
811210d8:	dc400117 	ldw	r17,4(sp)
811210dc:	dc000017 	ldw	r16,0(sp)
811210e0:	dec00504 	addi	sp,sp,20
811210e4:	112739c1 	jmpi	8112739c <_write_r>

811210e8 <__sseek>:
811210e8:	defffe04 	addi	sp,sp,-8
811210ec:	de00012e 	bgeu	sp,et,811210f4 <__sseek+0xc>
811210f0:	003b68fa 	trap	3
811210f4:	dc000015 	stw	r16,0(sp)
811210f8:	2821883a 	mov	r16,r5
811210fc:	2940038f 	ldh	r5,14(r5)
81121100:	dfc00115 	stw	ra,4(sp)
81121104:	112a3f00 	call	8112a3f0 <_lseek_r>
81121108:	00ffffc4 	movi	r3,-1
8112110c:	10c00826 	beq	r2,r3,81121130 <__sseek+0x48>
81121110:	80c0030b 	ldhu	r3,12(r16)
81121114:	80801415 	stw	r2,80(r16)
81121118:	18c40014 	ori	r3,r3,4096
8112111c:	80c0030d 	sth	r3,12(r16)
81121120:	dfc00117 	ldw	ra,4(sp)
81121124:	dc000017 	ldw	r16,0(sp)
81121128:	dec00204 	addi	sp,sp,8
8112112c:	f800283a 	ret
81121130:	80c0030b 	ldhu	r3,12(r16)
81121134:	18fbffcc 	andi	r3,r3,61439
81121138:	80c0030d 	sth	r3,12(r16)
8112113c:	dfc00117 	ldw	ra,4(sp)
81121140:	dc000017 	ldw	r16,0(sp)
81121144:	dec00204 	addi	sp,sp,8
81121148:	f800283a 	ret

8112114c <__sclose>:
8112114c:	2940038f 	ldh	r5,14(r5)
81121150:	11275601 	jmpi	81127560 <_close_r>

81121154 <strcspn>:
81121154:	21c00007 	ldb	r7,0(r4)
81121158:	38000f26 	beq	r7,zero,81121198 <strcspn+0x44>
8112115c:	2a000007 	ldb	r8,0(r5)
81121160:	2005883a 	mov	r2,r4
81121164:	40000726 	beq	r8,zero,81121184 <strcspn+0x30>
81121168:	3a000926 	beq	r7,r8,81121190 <strcspn+0x3c>
8112116c:	2807883a 	mov	r3,r5
81121170:	00000106 	br	81121178 <strcspn+0x24>
81121174:	31c00626 	beq	r6,r7,81121190 <strcspn+0x3c>
81121178:	18c00044 	addi	r3,r3,1
8112117c:	19800007 	ldb	r6,0(r3)
81121180:	303ffc1e 	bne	r6,zero,81121174 <__reset+0xfb101174>
81121184:	10800044 	addi	r2,r2,1
81121188:	11c00007 	ldb	r7,0(r2)
8112118c:	383ff51e 	bne	r7,zero,81121164 <__reset+0xfb101164>
81121190:	1105c83a 	sub	r2,r2,r4
81121194:	f800283a 	ret
81121198:	0005883a 	mov	r2,zero
8112119c:	f800283a 	ret

811211a0 <strlen>:
811211a0:	208000cc 	andi	r2,r4,3
811211a4:	10002026 	beq	r2,zero,81121228 <strlen+0x88>
811211a8:	20800007 	ldb	r2,0(r4)
811211ac:	10002026 	beq	r2,zero,81121230 <strlen+0x90>
811211b0:	2005883a 	mov	r2,r4
811211b4:	00000206 	br	811211c0 <strlen+0x20>
811211b8:	10c00007 	ldb	r3,0(r2)
811211bc:	18001826 	beq	r3,zero,81121220 <strlen+0x80>
811211c0:	10800044 	addi	r2,r2,1
811211c4:	10c000cc 	andi	r3,r2,3
811211c8:	183ffb1e 	bne	r3,zero,811211b8 <__reset+0xfb1011b8>
811211cc:	10c00017 	ldw	r3,0(r2)
811211d0:	01ffbff4 	movhi	r7,65279
811211d4:	39ffbfc4 	addi	r7,r7,-257
811211d8:	00ca303a 	nor	r5,zero,r3
811211dc:	01a02074 	movhi	r6,32897
811211e0:	19c7883a 	add	r3,r3,r7
811211e4:	31a02004 	addi	r6,r6,-32640
811211e8:	1946703a 	and	r3,r3,r5
811211ec:	1986703a 	and	r3,r3,r6
811211f0:	1800091e 	bne	r3,zero,81121218 <strlen+0x78>
811211f4:	10800104 	addi	r2,r2,4
811211f8:	10c00017 	ldw	r3,0(r2)
811211fc:	19cb883a 	add	r5,r3,r7
81121200:	00c6303a 	nor	r3,zero,r3
81121204:	28c6703a 	and	r3,r5,r3
81121208:	1986703a 	and	r3,r3,r6
8112120c:	183ff926 	beq	r3,zero,811211f4 <__reset+0xfb1011f4>
81121210:	00000106 	br	81121218 <strlen+0x78>
81121214:	10800044 	addi	r2,r2,1
81121218:	10c00007 	ldb	r3,0(r2)
8112121c:	183ffd1e 	bne	r3,zero,81121214 <__reset+0xfb101214>
81121220:	1105c83a 	sub	r2,r2,r4
81121224:	f800283a 	ret
81121228:	2005883a 	mov	r2,r4
8112122c:	003fe706 	br	811211cc <__reset+0xfb1011cc>
81121230:	0005883a 	mov	r2,zero
81121234:	f800283a 	ret

81121238 <strnlen>:
81121238:	28000e26 	beq	r5,zero,81121274 <strnlen+0x3c>
8112123c:	20800007 	ldb	r2,0(r4)
81121240:	10000c26 	beq	r2,zero,81121274 <strnlen+0x3c>
81121244:	20c00044 	addi	r3,r4,1
81121248:	214b883a 	add	r5,r4,r5
8112124c:	28c00526 	beq	r5,r3,81121264 <strnlen+0x2c>
81121250:	19800007 	ldb	r6,0(r3)
81121254:	19c00044 	addi	r7,r3,1
81121258:	30000426 	beq	r6,zero,8112126c <strnlen+0x34>
8112125c:	3807883a 	mov	r3,r7
81121260:	28fffb1e 	bne	r5,r3,81121250 <__reset+0xfb101250>
81121264:	2905c83a 	sub	r2,r5,r4
81121268:	f800283a 	ret
8112126c:	1905c83a 	sub	r2,r3,r4
81121270:	f800283a 	ret
81121274:	0005883a 	mov	r2,zero
81121278:	f800283a 	ret

8112127c <_strtol_r>:
8112127c:	00a04574 	movhi	r2,33045
81121280:	defff404 	addi	sp,sp,-48
81121284:	1082c404 	addi	r2,r2,2832
81121288:	de00012e 	bgeu	sp,et,81121290 <_strtol_r+0x14>
8112128c:	003b68fa 	trap	3
81121290:	dd400715 	stw	r21,28(sp)
81121294:	15400017 	ldw	r21,0(r2)
81121298:	dd800815 	stw	r22,32(sp)
8112129c:	dd000615 	stw	r20,24(sp)
811212a0:	dcc00515 	stw	r19,20(sp)
811212a4:	d9000015 	stw	r4,0(sp)
811212a8:	dfc00b15 	stw	ra,44(sp)
811212ac:	df000a15 	stw	fp,40(sp)
811212b0:	ddc00915 	stw	r23,36(sp)
811212b4:	dc800415 	stw	r18,16(sp)
811212b8:	dc400315 	stw	r17,12(sp)
811212bc:	dc000215 	stw	r16,8(sp)
811212c0:	2829883a 	mov	r20,r5
811212c4:	3027883a 	mov	r19,r6
811212c8:	382d883a 	mov	r22,r7
811212cc:	2809883a 	mov	r4,r5
811212d0:	24000003 	ldbu	r16,0(r4)
811212d4:	24400044 	addi	r17,r4,1
811212d8:	2007883a 	mov	r3,r4
811212dc:	ac05883a 	add	r2,r21,r16
811212e0:	10800043 	ldbu	r2,1(r2)
811212e4:	8809883a 	mov	r4,r17
811212e8:	1080020c 	andi	r2,r2,8
811212ec:	103ff81e 	bne	r2,zero,811212d0 <__reset+0xfb1012d0>
811212f0:	00800b44 	movi	r2,45
811212f4:	80805826 	beq	r16,r2,81121458 <_strtol_r+0x1dc>
811212f8:	00800ac4 	movi	r2,43
811212fc:	80805a26 	beq	r16,r2,81121468 <_strtol_r+0x1ec>
81121300:	0039883a 	mov	fp,zero
81121304:	b0004426 	beq	r22,zero,81121418 <_strtol_r+0x19c>
81121308:	00800404 	movi	r2,16
8112130c:	b0806026 	beq	r22,r2,81121490 <_strtol_r+0x214>
81121310:	b02f883a 	mov	r23,r22
81121314:	00a00034 	movhi	r2,32768
81121318:	e025003a 	cmpeq	r18,fp,zero
8112131c:	14a5c83a 	sub	r18,r2,r18
81121320:	b80b883a 	mov	r5,r23
81121324:	9009883a 	mov	r4,r18
81121328:	1132c7c0 	call	81132c7c <__umodsi3>
8112132c:	b80b883a 	mov	r5,r23
81121330:	9009883a 	mov	r4,r18
81121334:	d8800115 	stw	r2,4(sp)
81121338:	1132c180 	call	81132c18 <__udivsi3>
8112133c:	ac07883a 	add	r3,r21,r16
81121340:	18c00043 	ldbu	r3,1(r3)
81121344:	880b883a 	mov	r5,r17
81121348:	000d883a 	mov	r6,zero
8112134c:	1a00010c 	andi	r8,r3,4
81121350:	0009883a 	mov	r4,zero
81121354:	02800044 	movi	r10,1
81121358:	027fffc4 	movi	r9,-1
8112135c:	d9c00117 	ldw	r7,4(sp)
81121360:	40000e26 	beq	r8,zero,8112139c <_strtol_r+0x120>
81121364:	843ff404 	addi	r16,r16,-48
81121368:	8580120e 	bge	r16,r22,811213b4 <_strtol_r+0x138>
8112136c:	32400526 	beq	r6,r9,81121384 <_strtol_r+0x108>
81121370:	11002536 	bltu	r2,r4,81121408 <_strtol_r+0x18c>
81121374:	20802326 	beq	r4,r2,81121404 <_strtol_r+0x188>
81121378:	25c9383a 	mul	r4,r4,r23
8112137c:	01800044 	movi	r6,1
81121380:	8109883a 	add	r4,r16,r4
81121384:	2c000003 	ldbu	r16,0(r5)
81121388:	29400044 	addi	r5,r5,1
8112138c:	ac07883a 	add	r3,r21,r16
81121390:	18c00043 	ldbu	r3,1(r3)
81121394:	1a00010c 	andi	r8,r3,4
81121398:	403ff21e 	bne	r8,zero,81121364 <__reset+0xfb101364>
8112139c:	18c000cc 	andi	r3,r3,3
811213a0:	18000426 	beq	r3,zero,811213b4 <_strtol_r+0x138>
811213a4:	1a801a26 	beq	r3,r10,81121410 <_strtol_r+0x194>
811213a8:	00c015c4 	movi	r3,87
811213ac:	80e1c83a 	sub	r16,r16,r3
811213b0:	85bfee16 	blt	r16,r22,8112136c <__reset+0xfb10136c>
811213b4:	00bfffc4 	movi	r2,-1
811213b8:	30801e26 	beq	r6,r2,81121434 <_strtol_r+0x1b8>
811213bc:	e0001b1e 	bne	fp,zero,8112142c <_strtol_r+0x1b0>
811213c0:	2005883a 	mov	r2,r4
811213c4:	98000326 	beq	r19,zero,811213d4 <_strtol_r+0x158>
811213c8:	3000211e 	bne	r6,zero,81121450 <_strtol_r+0x1d4>
811213cc:	a00b883a 	mov	r5,r20
811213d0:	99400015 	stw	r5,0(r19)
811213d4:	dfc00b17 	ldw	ra,44(sp)
811213d8:	df000a17 	ldw	fp,40(sp)
811213dc:	ddc00917 	ldw	r23,36(sp)
811213e0:	dd800817 	ldw	r22,32(sp)
811213e4:	dd400717 	ldw	r21,28(sp)
811213e8:	dd000617 	ldw	r20,24(sp)
811213ec:	dcc00517 	ldw	r19,20(sp)
811213f0:	dc800417 	ldw	r18,16(sp)
811213f4:	dc400317 	ldw	r17,12(sp)
811213f8:	dc000217 	ldw	r16,8(sp)
811213fc:	dec00c04 	addi	sp,sp,48
81121400:	f800283a 	ret
81121404:	3c3fdc0e 	bge	r7,r16,81121378 <__reset+0xfb101378>
81121408:	01bfffc4 	movi	r6,-1
8112140c:	003fdd06 	br	81121384 <__reset+0xfb101384>
81121410:	00c00dc4 	movi	r3,55
81121414:	003fe506 	br	811213ac <__reset+0xfb1013ac>
81121418:	00800c04 	movi	r2,48
8112141c:	80801626 	beq	r16,r2,81121478 <_strtol_r+0x1fc>
81121420:	05800284 	movi	r22,10
81121424:	b02f883a 	mov	r23,r22
81121428:	003fba06 	br	81121314 <__reset+0xfb101314>
8112142c:	0109c83a 	sub	r4,zero,r4
81121430:	003fe306 	br	811213c0 <__reset+0xfb1013c0>
81121434:	d9000017 	ldw	r4,0(sp)
81121438:	00c00884 	movi	r3,34
8112143c:	e005003a 	cmpeq	r2,fp,zero
81121440:	20c00015 	stw	r3,0(r4)
81121444:	00e00034 	movhi	r3,32768
81121448:	1885c83a 	sub	r2,r3,r2
8112144c:	983fe126 	beq	r19,zero,811213d4 <__reset+0xfb1013d4>
81121450:	297fffc4 	addi	r5,r5,-1
81121454:	003fde06 	br	811213d0 <__reset+0xfb1013d0>
81121458:	1c400084 	addi	r17,r3,2
8112145c:	1c000043 	ldbu	r16,1(r3)
81121460:	07000044 	movi	fp,1
81121464:	003fa706 	br	81121304 <__reset+0xfb101304>
81121468:	1c400084 	addi	r17,r3,2
8112146c:	1c000043 	ldbu	r16,1(r3)
81121470:	0039883a 	mov	fp,zero
81121474:	003fa306 	br	81121304 <__reset+0xfb101304>
81121478:	88800003 	ldbu	r2,0(r17)
8112147c:	00c01604 	movi	r3,88
81121480:	108037cc 	andi	r2,r2,223
81121484:	10c00826 	beq	r2,r3,811214a8 <_strtol_r+0x22c>
81121488:	05800204 	movi	r22,8
8112148c:	003fa006 	br	81121310 <__reset+0xfb101310>
81121490:	00800c04 	movi	r2,48
81121494:	80bf9e1e 	bne	r16,r2,81121310 <__reset+0xfb101310>
81121498:	88800003 	ldbu	r2,0(r17)
8112149c:	00c01604 	movi	r3,88
811214a0:	108037cc 	andi	r2,r2,223
811214a4:	10ff9a1e 	bne	r2,r3,81121310 <__reset+0xfb101310>
811214a8:	05c00404 	movi	r23,16
811214ac:	8c000043 	ldbu	r16,1(r17)
811214b0:	b82d883a 	mov	r22,r23
811214b4:	8c400084 	addi	r17,r17,2
811214b8:	003f9606 	br	81121314 <__reset+0xfb101314>

811214bc <strtol>:
811214bc:	00a04574 	movhi	r2,33045
811214c0:	1082c604 	addi	r2,r2,2840
811214c4:	300f883a 	mov	r7,r6
811214c8:	280d883a 	mov	r6,r5
811214cc:	200b883a 	mov	r5,r4
811214d0:	11000017 	ldw	r4,0(r2)
811214d4:	112127c1 	jmpi	8112127c <_strtol_r>

811214d8 <___svfprintf_internal_r>:
811214d8:	deffb704 	addi	sp,sp,-292
811214dc:	de00012e 	bgeu	sp,et,811214e4 <___svfprintf_internal_r+0xc>
811214e0:	003b68fa 	trap	3
811214e4:	dfc04815 	stw	ra,288(sp)
811214e8:	ddc04615 	stw	r23,280(sp)
811214ec:	d9402c15 	stw	r5,176(sp)
811214f0:	d9003915 	stw	r4,228(sp)
811214f4:	302f883a 	mov	r23,r6
811214f8:	d9c02d15 	stw	r7,180(sp)
811214fc:	df004715 	stw	fp,284(sp)
81121500:	dd804515 	stw	r22,276(sp)
81121504:	dd404415 	stw	r21,272(sp)
81121508:	dd004315 	stw	r20,268(sp)
8112150c:	dcc04215 	stw	r19,264(sp)
81121510:	dc804115 	stw	r18,260(sp)
81121514:	dc404015 	stw	r17,256(sp)
81121518:	dc003f15 	stw	r16,252(sp)
8112151c:	112a3c00 	call	8112a3c0 <_localeconv_r>
81121520:	10800017 	ldw	r2,0(r2)
81121524:	1009883a 	mov	r4,r2
81121528:	d8803415 	stw	r2,208(sp)
8112152c:	11211a00 	call	811211a0 <strlen>
81121530:	d8c02c17 	ldw	r3,176(sp)
81121534:	d8803815 	stw	r2,224(sp)
81121538:	1880030b 	ldhu	r2,12(r3)
8112153c:	1080200c 	andi	r2,r2,128
81121540:	10000226 	beq	r2,zero,8112154c <___svfprintf_internal_r+0x74>
81121544:	18800417 	ldw	r2,16(r3)
81121548:	10067f26 	beq	r2,zero,81122f48 <___svfprintf_internal_r+0x1a70>
8112154c:	dcc03917 	ldw	r19,228(sp)
81121550:	d8c00404 	addi	r3,sp,16
81121554:	05604574 	movhi	r21,33045
81121558:	d9001e04 	addi	r4,sp,120
8112155c:	ad78fe84 	addi	r21,r21,-7174
81121560:	d8c01e15 	stw	r3,120(sp)
81121564:	d8002015 	stw	zero,128(sp)
81121568:	d8001f15 	stw	zero,124(sp)
8112156c:	d8003315 	stw	zero,204(sp)
81121570:	d8003615 	stw	zero,216(sp)
81121574:	d8003715 	stw	zero,220(sp)
81121578:	1811883a 	mov	r8,r3
8112157c:	d8003a15 	stw	zero,232(sp)
81121580:	d8003b15 	stw	zero,236(sp)
81121584:	d8002f15 	stw	zero,188(sp)
81121588:	d9002815 	stw	r4,160(sp)
8112158c:	b8800007 	ldb	r2,0(r23)
81121590:	10026726 	beq	r2,zero,81121f30 <___svfprintf_internal_r+0xa58>
81121594:	00c00944 	movi	r3,37
81121598:	b821883a 	mov	r16,r23
8112159c:	10c0021e 	bne	r2,r3,811215a8 <___svfprintf_internal_r+0xd0>
811215a0:	00001406 	br	811215f4 <___svfprintf_internal_r+0x11c>
811215a4:	10c00326 	beq	r2,r3,811215b4 <___svfprintf_internal_r+0xdc>
811215a8:	84000044 	addi	r16,r16,1
811215ac:	80800007 	ldb	r2,0(r16)
811215b0:	103ffc1e 	bne	r2,zero,811215a4 <__reset+0xfb1015a4>
811215b4:	85e3c83a 	sub	r17,r16,r23
811215b8:	88000e26 	beq	r17,zero,811215f4 <___svfprintf_internal_r+0x11c>
811215bc:	d8c02017 	ldw	r3,128(sp)
811215c0:	d8801f17 	ldw	r2,124(sp)
811215c4:	45c00015 	stw	r23,0(r8)
811215c8:	1c47883a 	add	r3,r3,r17
811215cc:	10800044 	addi	r2,r2,1
811215d0:	d8c02015 	stw	r3,128(sp)
811215d4:	44400115 	stw	r17,4(r8)
811215d8:	d8801f15 	stw	r2,124(sp)
811215dc:	00c001c4 	movi	r3,7
811215e0:	18809716 	blt	r3,r2,81121840 <___svfprintf_internal_r+0x368>
811215e4:	42000204 	addi	r8,r8,8
811215e8:	d9402f17 	ldw	r5,188(sp)
811215ec:	2c4b883a 	add	r5,r5,r17
811215f0:	d9402f15 	stw	r5,188(sp)
811215f4:	80800007 	ldb	r2,0(r16)
811215f8:	10009826 	beq	r2,zero,8112185c <___svfprintf_internal_r+0x384>
811215fc:	84400047 	ldb	r17,1(r16)
81121600:	00bfffc4 	movi	r2,-1
81121604:	85c00044 	addi	r23,r16,1
81121608:	d8002785 	stb	zero,158(sp)
8112160c:	0007883a 	mov	r3,zero
81121610:	000f883a 	mov	r7,zero
81121614:	d8802915 	stw	r2,164(sp)
81121618:	d8003115 	stw	zero,196(sp)
8112161c:	0025883a 	mov	r18,zero
81121620:	01401604 	movi	r5,88
81121624:	01800244 	movi	r6,9
81121628:	02800a84 	movi	r10,42
8112162c:	02401b04 	movi	r9,108
81121630:	bdc00044 	addi	r23,r23,1
81121634:	88bff804 	addi	r2,r17,-32
81121638:	2882f036 	bltu	r5,r2,811221fc <___svfprintf_internal_r+0xd24>
8112163c:	100490ba 	slli	r2,r2,2
81121640:	012044b4 	movhi	r4,33042
81121644:	21059504 	addi	r4,r4,5716
81121648:	1105883a 	add	r2,r2,r4
8112164c:	10800017 	ldw	r2,0(r2)
81121650:	1000683a 	jmp	r2
81121654:	81122164 	muli	r4,r16,18565
81121658:	811221fc 	xorhi	r4,r16,18567
8112165c:	811221fc 	xorhi	r4,r16,18567
81121660:	81122158 	cmpnei	r4,r16,18565
81121664:	811221fc 	xorhi	r4,r16,18567
81121668:	811221fc 	xorhi	r4,r16,18567
8112166c:	811221fc 	xorhi	r4,r16,18567
81121670:	811221fc 	xorhi	r4,r16,18567
81121674:	811221fc 	xorhi	r4,r16,18567
81121678:	811221fc 	xorhi	r4,r16,18567
8112167c:	811218b8 	rdprs	r4,r16,18530
81121680:	81122094 	ori	r4,r16,18562
81121684:	811221fc 	xorhi	r4,r16,18567
81121688:	811217c8 	cmpgei	r4,r16,18527
8112168c:	811218e0 	cmpeqi	r4,r16,18531
81121690:	811221fc 	xorhi	r4,r16,18567
81121694:	81121954 	ori	r4,r16,18533
81121698:	81121920 	cmpeqi	r4,r16,18532
8112169c:	81121920 	cmpeqi	r4,r16,18532
811216a0:	81121920 	cmpeqi	r4,r16,18532
811216a4:	81121920 	cmpeqi	r4,r16,18532
811216a8:	81121920 	cmpeqi	r4,r16,18532
811216ac:	81121920 	cmpeqi	r4,r16,18532
811216b0:	81121920 	cmpeqi	r4,r16,18532
811216b4:	81121920 	cmpeqi	r4,r16,18532
811216b8:	81121920 	cmpeqi	r4,r16,18532
811216bc:	811221fc 	xorhi	r4,r16,18567
811216c0:	811221fc 	xorhi	r4,r16,18567
811216c4:	811221fc 	xorhi	r4,r16,18567
811216c8:	811221fc 	xorhi	r4,r16,18567
811216cc:	811221fc 	xorhi	r4,r16,18567
811216d0:	811221fc 	xorhi	r4,r16,18567
811216d4:	811221fc 	xorhi	r4,r16,18567
811216d8:	811221fc 	xorhi	r4,r16,18567
811216dc:	811221fc 	xorhi	r4,r16,18567
811216e0:	811221fc 	xorhi	r4,r16,18567
811216e4:	81121a0c 	andi	r4,r16,18536
811216e8:	81121960 	cmpeqi	r4,r16,18533
811216ec:	811221fc 	xorhi	r4,r16,18567
811216f0:	81121960 	cmpeqi	r4,r16,18533
811216f4:	811221fc 	xorhi	r4,r16,18567
811216f8:	811221fc 	xorhi	r4,r16,18567
811216fc:	811221fc 	xorhi	r4,r16,18567
81121700:	811221fc 	xorhi	r4,r16,18567
81121704:	81121a00 	call	881121a0 <__reset+0x20f21a0>
81121708:	811221fc 	xorhi	r4,r16,18567
8112170c:	811221fc 	xorhi	r4,r16,18567
81121710:	81121ac8 	cmpgei	r4,r16,18539
81121714:	811221fc 	xorhi	r4,r16,18567
81121718:	811221fc 	xorhi	r4,r16,18567
8112171c:	811221fc 	xorhi	r4,r16,18567
81121720:	811221fc 	xorhi	r4,r16,18567
81121724:	811221fc 	xorhi	r4,r16,18567
81121728:	81121f38 	rdprs	r4,r16,18556
8112172c:	811221fc 	xorhi	r4,r16,18567
81121730:	811221fc 	xorhi	r4,r16,18567
81121734:	81121f98 	cmpnei	r4,r16,18558
81121738:	811221fc 	xorhi	r4,r16,18567
8112173c:	811221fc 	xorhi	r4,r16,18567
81121740:	811221fc 	xorhi	r4,r16,18567
81121744:	811221fc 	xorhi	r4,r16,18567
81121748:	811221fc 	xorhi	r4,r16,18567
8112174c:	811221fc 	xorhi	r4,r16,18567
81121750:	811221fc 	xorhi	r4,r16,18567
81121754:	811221fc 	xorhi	r4,r16,18567
81121758:	811221fc 	xorhi	r4,r16,18567
8112175c:	811221fc 	xorhi	r4,r16,18567
81121760:	81122048 	cmpgei	r4,r16,18561
81121764:	81122184 	addi	r4,r16,18566
81121768:	81121960 	cmpeqi	r4,r16,18533
8112176c:	81121960 	cmpeqi	r4,r16,18533
81121770:	81121960 	cmpeqi	r4,r16,18533
81121774:	811221d8 	cmpnei	r4,r16,18567
81121778:	81122184 	addi	r4,r16,18566
8112177c:	811221fc 	xorhi	r4,r16,18567
81121780:	811221fc 	xorhi	r4,r16,18567
81121784:	81122194 	ori	r4,r16,18566
81121788:	811221fc 	xorhi	r4,r16,18567
8112178c:	811221a4 	muli	r4,r16,18566
81121790:	81122084 	addi	r4,r16,18562
81121794:	811217d4 	ori	r4,r16,18527
81121798:	811220a4 	muli	r4,r16,18562
8112179c:	811221fc 	xorhi	r4,r16,18567
811217a0:	811220b0 	cmpltui	r4,r16,18562
811217a4:	811221fc 	xorhi	r4,r16,18567
811217a8:	8112210c 	andi	r4,r16,18564
811217ac:	811221fc 	xorhi	r4,r16,18567
811217b0:	811221fc 	xorhi	r4,r16,18567
811217b4:	8112211c 	xori	r4,r16,18564
811217b8:	d9003117 	ldw	r4,196(sp)
811217bc:	d8802d15 	stw	r2,180(sp)
811217c0:	0109c83a 	sub	r4,zero,r4
811217c4:	d9003115 	stw	r4,196(sp)
811217c8:	94800114 	ori	r18,r18,4
811217cc:	bc400007 	ldb	r17,0(r23)
811217d0:	003f9706 	br	81121630 <__reset+0xfb101630>
811217d4:	00800c04 	movi	r2,48
811217d8:	d9002d17 	ldw	r4,180(sp)
811217dc:	d9402917 	ldw	r5,164(sp)
811217e0:	d8802705 	stb	r2,156(sp)
811217e4:	00801e04 	movi	r2,120
811217e8:	d8802745 	stb	r2,157(sp)
811217ec:	d8002785 	stb	zero,158(sp)
811217f0:	20c00104 	addi	r3,r4,4
811217f4:	25000017 	ldw	r20,0(r4)
811217f8:	002d883a 	mov	r22,zero
811217fc:	90800094 	ori	r2,r18,2
81121800:	28028616 	blt	r5,zero,8112221c <___svfprintf_internal_r+0xd44>
81121804:	00bfdfc4 	movi	r2,-129
81121808:	90a4703a 	and	r18,r18,r2
8112180c:	d8c02d15 	stw	r3,180(sp)
81121810:	94800094 	ori	r18,r18,2
81121814:	a002731e 	bne	r20,zero,811221e4 <___svfprintf_internal_r+0xd0c>
81121818:	00a04574 	movhi	r2,33045
8112181c:	10b8f704 	addi	r2,r2,-7204
81121820:	d8803a15 	stw	r2,232(sp)
81121824:	04401e04 	movi	r17,120
81121828:	d8c02917 	ldw	r3,164(sp)
8112182c:	0039883a 	mov	fp,zero
81121830:	1801d526 	beq	r3,zero,81121f88 <___svfprintf_internal_r+0xab0>
81121834:	0029883a 	mov	r20,zero
81121838:	002d883a 	mov	r22,zero
8112183c:	0001f106 	br	81122004 <___svfprintf_internal_r+0xb2c>
81121840:	d9402c17 	ldw	r5,176(sp)
81121844:	d9801e04 	addi	r6,sp,120
81121848:	9809883a 	mov	r4,r19
8112184c:	112e0f80 	call	8112e0f8 <__ssprint_r>
81121850:	1000081e 	bne	r2,zero,81121874 <___svfprintf_internal_r+0x39c>
81121854:	da000404 	addi	r8,sp,16
81121858:	003f6306 	br	811215e8 <__reset+0xfb1015e8>
8112185c:	d8802017 	ldw	r2,128(sp)
81121860:	10000426 	beq	r2,zero,81121874 <___svfprintf_internal_r+0x39c>
81121864:	d9402c17 	ldw	r5,176(sp)
81121868:	d9003917 	ldw	r4,228(sp)
8112186c:	d9801e04 	addi	r6,sp,120
81121870:	112e0f80 	call	8112e0f8 <__ssprint_r>
81121874:	d8802c17 	ldw	r2,176(sp)
81121878:	10c0030b 	ldhu	r3,12(r2)
8112187c:	d8802f17 	ldw	r2,188(sp)
81121880:	18c0100c 	andi	r3,r3,64
81121884:	1805f51e 	bne	r3,zero,8112305c <___svfprintf_internal_r+0x1b84>
81121888:	dfc04817 	ldw	ra,288(sp)
8112188c:	df004717 	ldw	fp,284(sp)
81121890:	ddc04617 	ldw	r23,280(sp)
81121894:	dd804517 	ldw	r22,276(sp)
81121898:	dd404417 	ldw	r21,272(sp)
8112189c:	dd004317 	ldw	r20,268(sp)
811218a0:	dcc04217 	ldw	r19,264(sp)
811218a4:	dc804117 	ldw	r18,260(sp)
811218a8:	dc404017 	ldw	r17,256(sp)
811218ac:	dc003f17 	ldw	r16,252(sp)
811218b0:	dec04904 	addi	sp,sp,292
811218b4:	f800283a 	ret
811218b8:	d8802d17 	ldw	r2,180(sp)
811218bc:	d9002d17 	ldw	r4,180(sp)
811218c0:	10800017 	ldw	r2,0(r2)
811218c4:	d8803115 	stw	r2,196(sp)
811218c8:	20800104 	addi	r2,r4,4
811218cc:	d9003117 	ldw	r4,196(sp)
811218d0:	203fb916 	blt	r4,zero,811217b8 <__reset+0xfb1017b8>
811218d4:	d8802d15 	stw	r2,180(sp)
811218d8:	bc400007 	ldb	r17,0(r23)
811218dc:	003f5406 	br	81121630 <__reset+0xfb101630>
811218e0:	bc400007 	ldb	r17,0(r23)
811218e4:	bac00044 	addi	r11,r23,1
811218e8:	8a873926 	beq	r17,r10,811235d0 <___svfprintf_internal_r+0x20f8>
811218ec:	88bff404 	addi	r2,r17,-48
811218f0:	0009883a 	mov	r4,zero
811218f4:	30868836 	bltu	r6,r2,81123318 <___svfprintf_internal_r+0x1e40>
811218f8:	5c400007 	ldb	r17,0(r11)
811218fc:	210002a4 	muli	r4,r4,10
81121900:	5dc00044 	addi	r23,r11,1
81121904:	b817883a 	mov	r11,r23
81121908:	2089883a 	add	r4,r4,r2
8112190c:	88bff404 	addi	r2,r17,-48
81121910:	30bff92e 	bgeu	r6,r2,811218f8 <__reset+0xfb1018f8>
81121914:	2005d716 	blt	r4,zero,81123074 <___svfprintf_internal_r+0x1b9c>
81121918:	d9002915 	stw	r4,164(sp)
8112191c:	003f4506 	br	81121634 <__reset+0xfb101634>
81121920:	b809883a 	mov	r4,r23
81121924:	d8003115 	stw	zero,196(sp)
81121928:	88bff404 	addi	r2,r17,-48
8112192c:	0017883a 	mov	r11,zero
81121930:	24400007 	ldb	r17,0(r4)
81121934:	5ac002a4 	muli	r11,r11,10
81121938:	bdc00044 	addi	r23,r23,1
8112193c:	b809883a 	mov	r4,r23
81121940:	12d7883a 	add	r11,r2,r11
81121944:	88bff404 	addi	r2,r17,-48
81121948:	30bff92e 	bgeu	r6,r2,81121930 <__reset+0xfb101930>
8112194c:	dac03115 	stw	r11,196(sp)
81121950:	003f3806 	br	81121634 <__reset+0xfb101634>
81121954:	94802014 	ori	r18,r18,128
81121958:	bc400007 	ldb	r17,0(r23)
8112195c:	003f3406 	br	81121630 <__reset+0xfb101630>
81121960:	18c03fcc 	andi	r3,r3,255
81121964:	1807471e 	bne	r3,zero,81123684 <___svfprintf_internal_r+0x21ac>
81121968:	9080020c 	andi	r2,r18,8
8112196c:	10047d26 	beq	r2,zero,81122b64 <___svfprintf_internal_r+0x168c>
81121970:	d8c02d17 	ldw	r3,180(sp)
81121974:	d9002d17 	ldw	r4,180(sp)
81121978:	d9402d17 	ldw	r5,180(sp)
8112197c:	18c00017 	ldw	r3,0(r3)
81121980:	21000117 	ldw	r4,4(r4)
81121984:	29400204 	addi	r5,r5,8
81121988:	d8c03615 	stw	r3,216(sp)
8112198c:	d9003715 	stw	r4,220(sp)
81121990:	d9402d15 	stw	r5,180(sp)
81121994:	d9003617 	ldw	r4,216(sp)
81121998:	d9403717 	ldw	r5,220(sp)
8112199c:	da003e15 	stw	r8,248(sp)
811219a0:	04000044 	movi	r16,1
811219a4:	112bf0c0 	call	8112bf0c <__fpclassifyd>
811219a8:	da003e17 	ldw	r8,248(sp)
811219ac:	14044b1e 	bne	r2,r16,81122adc <___svfprintf_internal_r+0x1604>
811219b0:	d9003617 	ldw	r4,216(sp)
811219b4:	d9403717 	ldw	r5,220(sp)
811219b8:	000d883a 	mov	r6,zero
811219bc:	000f883a 	mov	r7,zero
811219c0:	11340fc0 	call	811340fc <__ledf2>
811219c4:	da003e17 	ldw	r8,248(sp)
811219c8:	1005f316 	blt	r2,zero,81123198 <___svfprintf_internal_r+0x1cc0>
811219cc:	df002783 	ldbu	fp,158(sp)
811219d0:	008011c4 	movi	r2,71
811219d4:	1445590e 	bge	r2,r17,81122f3c <___svfprintf_internal_r+0x1a64>
811219d8:	04204574 	movhi	r16,33045
811219dc:	8438ef04 	addi	r16,r16,-7236
811219e0:	00c000c4 	movi	r3,3
811219e4:	00bfdfc4 	movi	r2,-129
811219e8:	d8c02a15 	stw	r3,168(sp)
811219ec:	90a4703a 	and	r18,r18,r2
811219f0:	d8c02e15 	stw	r3,184(sp)
811219f4:	d8002915 	stw	zero,164(sp)
811219f8:	d8003215 	stw	zero,200(sp)
811219fc:	00006606 	br	81121b98 <___svfprintf_internal_r+0x6c0>
81121a00:	94800214 	ori	r18,r18,8
81121a04:	bc400007 	ldb	r17,0(r23)
81121a08:	003f0906 	br	81121630 <__reset+0xfb101630>
81121a0c:	18c03fcc 	andi	r3,r3,255
81121a10:	1807181e 	bne	r3,zero,81123674 <___svfprintf_internal_r+0x219c>
81121a14:	94800414 	ori	r18,r18,16
81121a18:	9080080c 	andi	r2,r18,32
81121a1c:	10039626 	beq	r2,zero,81122878 <___svfprintf_internal_r+0x13a0>
81121a20:	d9402d17 	ldw	r5,180(sp)
81121a24:	28800117 	ldw	r2,4(r5)
81121a28:	2d000017 	ldw	r20,0(r5)
81121a2c:	29400204 	addi	r5,r5,8
81121a30:	d9402d15 	stw	r5,180(sp)
81121a34:	102d883a 	mov	r22,r2
81121a38:	10039816 	blt	r2,zero,8112289c <___svfprintf_internal_r+0x13c4>
81121a3c:	d9402917 	ldw	r5,164(sp)
81121a40:	df002783 	ldbu	fp,158(sp)
81121a44:	2803ab16 	blt	r5,zero,811228f4 <___svfprintf_internal_r+0x141c>
81121a48:	00ffdfc4 	movi	r3,-129
81121a4c:	a584b03a 	or	r2,r20,r22
81121a50:	90e4703a 	and	r18,r18,r3
81121a54:	10014a26 	beq	r2,zero,81121f80 <___svfprintf_internal_r+0xaa8>
81121a58:	b0034b26 	beq	r22,zero,81122788 <___svfprintf_internal_r+0x12b0>
81121a5c:	dc402a15 	stw	r17,168(sp)
81121a60:	dc001e04 	addi	r16,sp,120
81121a64:	b023883a 	mov	r17,r22
81121a68:	402d883a 	mov	r22,r8
81121a6c:	a009883a 	mov	r4,r20
81121a70:	880b883a 	mov	r5,r17
81121a74:	01800284 	movi	r6,10
81121a78:	000f883a 	mov	r7,zero
81121a7c:	11325e00 	call	811325e0 <__umoddi3>
81121a80:	10800c04 	addi	r2,r2,48
81121a84:	843fffc4 	addi	r16,r16,-1
81121a88:	a009883a 	mov	r4,r20
81121a8c:	880b883a 	mov	r5,r17
81121a90:	80800005 	stb	r2,0(r16)
81121a94:	01800284 	movi	r6,10
81121a98:	000f883a 	mov	r7,zero
81121a9c:	11320600 	call	81132060 <__udivdi3>
81121aa0:	1029883a 	mov	r20,r2
81121aa4:	10c4b03a 	or	r2,r2,r3
81121aa8:	1823883a 	mov	r17,r3
81121aac:	103fef1e 	bne	r2,zero,81121a6c <__reset+0xfb101a6c>
81121ab0:	d8c02817 	ldw	r3,160(sp)
81121ab4:	dc402a17 	ldw	r17,168(sp)
81121ab8:	b011883a 	mov	r8,r22
81121abc:	1c07c83a 	sub	r3,r3,r16
81121ac0:	d8c02e15 	stw	r3,184(sp)
81121ac4:	00002e06 	br	81121b80 <___svfprintf_internal_r+0x6a8>
81121ac8:	18c03fcc 	andi	r3,r3,255
81121acc:	1806e71e 	bne	r3,zero,8112366c <___svfprintf_internal_r+0x2194>
81121ad0:	94800414 	ori	r18,r18,16
81121ad4:	9080080c 	andi	r2,r18,32
81121ad8:	1002d426 	beq	r2,zero,8112262c <___svfprintf_internal_r+0x1154>
81121adc:	d9402d17 	ldw	r5,180(sp)
81121ae0:	d8c02917 	ldw	r3,164(sp)
81121ae4:	d8002785 	stb	zero,158(sp)
81121ae8:	28800204 	addi	r2,r5,8
81121aec:	2d000017 	ldw	r20,0(r5)
81121af0:	2d800117 	ldw	r22,4(r5)
81121af4:	18041516 	blt	r3,zero,81122b4c <___svfprintf_internal_r+0x1674>
81121af8:	013fdfc4 	movi	r4,-129
81121afc:	a586b03a 	or	r3,r20,r22
81121b00:	d8802d15 	stw	r2,180(sp)
81121b04:	9124703a 	and	r18,r18,r4
81121b08:	1802d51e 	bne	r3,zero,81122660 <___svfprintf_internal_r+0x1188>
81121b0c:	d9402917 	ldw	r5,164(sp)
81121b10:	0039883a 	mov	fp,zero
81121b14:	2806be26 	beq	r5,zero,81123610 <___svfprintf_internal_r+0x2138>
81121b18:	0029883a 	mov	r20,zero
81121b1c:	002d883a 	mov	r22,zero
81121b20:	dc001e04 	addi	r16,sp,120
81121b24:	a006d0fa 	srli	r3,r20,3
81121b28:	b008977a 	slli	r4,r22,29
81121b2c:	b02cd0fa 	srli	r22,r22,3
81121b30:	a50001cc 	andi	r20,r20,7
81121b34:	a0800c04 	addi	r2,r20,48
81121b38:	843fffc4 	addi	r16,r16,-1
81121b3c:	20e8b03a 	or	r20,r4,r3
81121b40:	80800005 	stb	r2,0(r16)
81121b44:	a586b03a 	or	r3,r20,r22
81121b48:	183ff61e 	bne	r3,zero,81121b24 <__reset+0xfb101b24>
81121b4c:	90c0004c 	andi	r3,r18,1
81121b50:	18013926 	beq	r3,zero,81122038 <___svfprintf_internal_r+0xb60>
81121b54:	10803fcc 	andi	r2,r2,255
81121b58:	1080201c 	xori	r2,r2,128
81121b5c:	10bfe004 	addi	r2,r2,-128
81121b60:	00c00c04 	movi	r3,48
81121b64:	10c13426 	beq	r2,r3,81122038 <___svfprintf_internal_r+0xb60>
81121b68:	80ffffc5 	stb	r3,-1(r16)
81121b6c:	d8c02817 	ldw	r3,160(sp)
81121b70:	80bfffc4 	addi	r2,r16,-1
81121b74:	1021883a 	mov	r16,r2
81121b78:	1887c83a 	sub	r3,r3,r2
81121b7c:	d8c02e15 	stw	r3,184(sp)
81121b80:	d8802e17 	ldw	r2,184(sp)
81121b84:	d9002917 	ldw	r4,164(sp)
81121b88:	1100010e 	bge	r2,r4,81121b90 <___svfprintf_internal_r+0x6b8>
81121b8c:	2005883a 	mov	r2,r4
81121b90:	d8802a15 	stw	r2,168(sp)
81121b94:	d8003215 	stw	zero,200(sp)
81121b98:	e7003fcc 	andi	fp,fp,255
81121b9c:	e700201c 	xori	fp,fp,128
81121ba0:	e73fe004 	addi	fp,fp,-128
81121ba4:	e0000326 	beq	fp,zero,81121bb4 <___svfprintf_internal_r+0x6dc>
81121ba8:	d8c02a17 	ldw	r3,168(sp)
81121bac:	18c00044 	addi	r3,r3,1
81121bb0:	d8c02a15 	stw	r3,168(sp)
81121bb4:	90c0008c 	andi	r3,r18,2
81121bb8:	d8c02b15 	stw	r3,172(sp)
81121bbc:	18000326 	beq	r3,zero,81121bcc <___svfprintf_internal_r+0x6f4>
81121bc0:	d8c02a17 	ldw	r3,168(sp)
81121bc4:	18c00084 	addi	r3,r3,2
81121bc8:	d8c02a15 	stw	r3,168(sp)
81121bcc:	90c0210c 	andi	r3,r18,132
81121bd0:	d8c03015 	stw	r3,192(sp)
81121bd4:	1801a11e 	bne	r3,zero,8112225c <___svfprintf_internal_r+0xd84>
81121bd8:	d9003117 	ldw	r4,196(sp)
81121bdc:	d8c02a17 	ldw	r3,168(sp)
81121be0:	20e9c83a 	sub	r20,r4,r3
81121be4:	05019d0e 	bge	zero,r20,8112225c <___svfprintf_internal_r+0xd84>
81121be8:	02400404 	movi	r9,16
81121bec:	d8c02017 	ldw	r3,128(sp)
81121bf0:	d8801f17 	ldw	r2,124(sp)
81121bf4:	4d051b0e 	bge	r9,r20,81123064 <___svfprintf_internal_r+0x1b8c>
81121bf8:	01604574 	movhi	r5,33045
81121bfc:	29790284 	addi	r5,r5,-7158
81121c00:	dc403c15 	stw	r17,240(sp)
81121c04:	d9403515 	stw	r5,212(sp)
81121c08:	a023883a 	mov	r17,r20
81121c0c:	482d883a 	mov	r22,r9
81121c10:	9029883a 	mov	r20,r18
81121c14:	070001c4 	movi	fp,7
81121c18:	8025883a 	mov	r18,r16
81121c1c:	dc002c17 	ldw	r16,176(sp)
81121c20:	00000306 	br	81121c30 <___svfprintf_internal_r+0x758>
81121c24:	8c7ffc04 	addi	r17,r17,-16
81121c28:	42000204 	addi	r8,r8,8
81121c2c:	b440130e 	bge	r22,r17,81121c7c <___svfprintf_internal_r+0x7a4>
81121c30:	01204574 	movhi	r4,33045
81121c34:	18c00404 	addi	r3,r3,16
81121c38:	10800044 	addi	r2,r2,1
81121c3c:	21390284 	addi	r4,r4,-7158
81121c40:	41000015 	stw	r4,0(r8)
81121c44:	45800115 	stw	r22,4(r8)
81121c48:	d8c02015 	stw	r3,128(sp)
81121c4c:	d8801f15 	stw	r2,124(sp)
81121c50:	e0bff40e 	bge	fp,r2,81121c24 <__reset+0xfb101c24>
81121c54:	d9801e04 	addi	r6,sp,120
81121c58:	800b883a 	mov	r5,r16
81121c5c:	9809883a 	mov	r4,r19
81121c60:	112e0f80 	call	8112e0f8 <__ssprint_r>
81121c64:	103f031e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81121c68:	8c7ffc04 	addi	r17,r17,-16
81121c6c:	d8c02017 	ldw	r3,128(sp)
81121c70:	d8801f17 	ldw	r2,124(sp)
81121c74:	da000404 	addi	r8,sp,16
81121c78:	b47fed16 	blt	r22,r17,81121c30 <__reset+0xfb101c30>
81121c7c:	9021883a 	mov	r16,r18
81121c80:	a025883a 	mov	r18,r20
81121c84:	8829883a 	mov	r20,r17
81121c88:	dc403c17 	ldw	r17,240(sp)
81121c8c:	d9403517 	ldw	r5,212(sp)
81121c90:	a0c7883a 	add	r3,r20,r3
81121c94:	10800044 	addi	r2,r2,1
81121c98:	41400015 	stw	r5,0(r8)
81121c9c:	45000115 	stw	r20,4(r8)
81121ca0:	d8c02015 	stw	r3,128(sp)
81121ca4:	d8801f15 	stw	r2,124(sp)
81121ca8:	010001c4 	movi	r4,7
81121cac:	20829f16 	blt	r4,r2,8112272c <___svfprintf_internal_r+0x1254>
81121cb0:	df002787 	ldb	fp,158(sp)
81121cb4:	42000204 	addi	r8,r8,8
81121cb8:	e0000c26 	beq	fp,zero,81121cec <___svfprintf_internal_r+0x814>
81121cbc:	d8801f17 	ldw	r2,124(sp)
81121cc0:	d9002784 	addi	r4,sp,158
81121cc4:	18c00044 	addi	r3,r3,1
81121cc8:	10800044 	addi	r2,r2,1
81121ccc:	41000015 	stw	r4,0(r8)
81121cd0:	01000044 	movi	r4,1
81121cd4:	41000115 	stw	r4,4(r8)
81121cd8:	d8c02015 	stw	r3,128(sp)
81121cdc:	d8801f15 	stw	r2,124(sp)
81121ce0:	010001c4 	movi	r4,7
81121ce4:	20823816 	blt	r4,r2,811225c8 <___svfprintf_internal_r+0x10f0>
81121ce8:	42000204 	addi	r8,r8,8
81121cec:	d8802b17 	ldw	r2,172(sp)
81121cf0:	10000c26 	beq	r2,zero,81121d24 <___svfprintf_internal_r+0x84c>
81121cf4:	d8801f17 	ldw	r2,124(sp)
81121cf8:	d9002704 	addi	r4,sp,156
81121cfc:	18c00084 	addi	r3,r3,2
81121d00:	10800044 	addi	r2,r2,1
81121d04:	41000015 	stw	r4,0(r8)
81121d08:	01000084 	movi	r4,2
81121d0c:	41000115 	stw	r4,4(r8)
81121d10:	d8c02015 	stw	r3,128(sp)
81121d14:	d8801f15 	stw	r2,124(sp)
81121d18:	010001c4 	movi	r4,7
81121d1c:	20823216 	blt	r4,r2,811225e8 <___svfprintf_internal_r+0x1110>
81121d20:	42000204 	addi	r8,r8,8
81121d24:	d9003017 	ldw	r4,192(sp)
81121d28:	00802004 	movi	r2,128
81121d2c:	20819726 	beq	r4,r2,8112238c <___svfprintf_internal_r+0xeb4>
81121d30:	d9402917 	ldw	r5,164(sp)
81121d34:	d8802e17 	ldw	r2,184(sp)
81121d38:	28adc83a 	sub	r22,r5,r2
81121d3c:	05802f0e 	bge	zero,r22,81121dfc <___svfprintf_internal_r+0x924>
81121d40:	07000404 	movi	fp,16
81121d44:	d8801f17 	ldw	r2,124(sp)
81121d48:	e583c00e 	bge	fp,r22,81122c4c <___svfprintf_internal_r+0x1774>
81121d4c:	01604574 	movhi	r5,33045
81121d50:	2978fe84 	addi	r5,r5,-7174
81121d54:	dc402915 	stw	r17,164(sp)
81121d58:	d9402b15 	stw	r5,172(sp)
81121d5c:	b023883a 	mov	r17,r22
81121d60:	050001c4 	movi	r20,7
81121d64:	902d883a 	mov	r22,r18
81121d68:	8025883a 	mov	r18,r16
81121d6c:	dc002c17 	ldw	r16,176(sp)
81121d70:	00000306 	br	81121d80 <___svfprintf_internal_r+0x8a8>
81121d74:	8c7ffc04 	addi	r17,r17,-16
81121d78:	42000204 	addi	r8,r8,8
81121d7c:	e440110e 	bge	fp,r17,81121dc4 <___svfprintf_internal_r+0x8ec>
81121d80:	18c00404 	addi	r3,r3,16
81121d84:	10800044 	addi	r2,r2,1
81121d88:	45400015 	stw	r21,0(r8)
81121d8c:	47000115 	stw	fp,4(r8)
81121d90:	d8c02015 	stw	r3,128(sp)
81121d94:	d8801f15 	stw	r2,124(sp)
81121d98:	a0bff60e 	bge	r20,r2,81121d74 <__reset+0xfb101d74>
81121d9c:	d9801e04 	addi	r6,sp,120
81121da0:	800b883a 	mov	r5,r16
81121da4:	9809883a 	mov	r4,r19
81121da8:	112e0f80 	call	8112e0f8 <__ssprint_r>
81121dac:	103eb11e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81121db0:	8c7ffc04 	addi	r17,r17,-16
81121db4:	d8c02017 	ldw	r3,128(sp)
81121db8:	d8801f17 	ldw	r2,124(sp)
81121dbc:	da000404 	addi	r8,sp,16
81121dc0:	e47fef16 	blt	fp,r17,81121d80 <__reset+0xfb101d80>
81121dc4:	9021883a 	mov	r16,r18
81121dc8:	b025883a 	mov	r18,r22
81121dcc:	882d883a 	mov	r22,r17
81121dd0:	dc402917 	ldw	r17,164(sp)
81121dd4:	d9002b17 	ldw	r4,172(sp)
81121dd8:	1d87883a 	add	r3,r3,r22
81121ddc:	10800044 	addi	r2,r2,1
81121de0:	41000015 	stw	r4,0(r8)
81121de4:	45800115 	stw	r22,4(r8)
81121de8:	d8c02015 	stw	r3,128(sp)
81121dec:	d8801f15 	stw	r2,124(sp)
81121df0:	010001c4 	movi	r4,7
81121df4:	2081ec16 	blt	r4,r2,811225a8 <___svfprintf_internal_r+0x10d0>
81121df8:	42000204 	addi	r8,r8,8
81121dfc:	9080400c 	andi	r2,r18,256
81121e00:	1001181e 	bne	r2,zero,81122264 <___svfprintf_internal_r+0xd8c>
81121e04:	d9402e17 	ldw	r5,184(sp)
81121e08:	d8801f17 	ldw	r2,124(sp)
81121e0c:	44000015 	stw	r16,0(r8)
81121e10:	1947883a 	add	r3,r3,r5
81121e14:	10800044 	addi	r2,r2,1
81121e18:	41400115 	stw	r5,4(r8)
81121e1c:	d8c02015 	stw	r3,128(sp)
81121e20:	d8801f15 	stw	r2,124(sp)
81121e24:	010001c4 	movi	r4,7
81121e28:	2081d116 	blt	r4,r2,81122570 <___svfprintf_internal_r+0x1098>
81121e2c:	42000204 	addi	r8,r8,8
81121e30:	9480010c 	andi	r18,r18,4
81121e34:	90003226 	beq	r18,zero,81121f00 <___svfprintf_internal_r+0xa28>
81121e38:	d9403117 	ldw	r5,196(sp)
81121e3c:	d8802a17 	ldw	r2,168(sp)
81121e40:	28a1c83a 	sub	r16,r5,r2
81121e44:	04002e0e 	bge	zero,r16,81121f00 <___svfprintf_internal_r+0xa28>
81121e48:	04400404 	movi	r17,16
81121e4c:	d8801f17 	ldw	r2,124(sp)
81121e50:	8c04b90e 	bge	r17,r16,81123138 <___svfprintf_internal_r+0x1c60>
81121e54:	01604574 	movhi	r5,33045
81121e58:	29790284 	addi	r5,r5,-7158
81121e5c:	d9403515 	stw	r5,212(sp)
81121e60:	048001c4 	movi	r18,7
81121e64:	dd002c17 	ldw	r20,176(sp)
81121e68:	00000306 	br	81121e78 <___svfprintf_internal_r+0x9a0>
81121e6c:	843ffc04 	addi	r16,r16,-16
81121e70:	42000204 	addi	r8,r8,8
81121e74:	8c00130e 	bge	r17,r16,81121ec4 <___svfprintf_internal_r+0x9ec>
81121e78:	01204574 	movhi	r4,33045
81121e7c:	18c00404 	addi	r3,r3,16
81121e80:	10800044 	addi	r2,r2,1
81121e84:	21390284 	addi	r4,r4,-7158
81121e88:	41000015 	stw	r4,0(r8)
81121e8c:	44400115 	stw	r17,4(r8)
81121e90:	d8c02015 	stw	r3,128(sp)
81121e94:	d8801f15 	stw	r2,124(sp)
81121e98:	90bff40e 	bge	r18,r2,81121e6c <__reset+0xfb101e6c>
81121e9c:	d9801e04 	addi	r6,sp,120
81121ea0:	a00b883a 	mov	r5,r20
81121ea4:	9809883a 	mov	r4,r19
81121ea8:	112e0f80 	call	8112e0f8 <__ssprint_r>
81121eac:	103e711e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81121eb0:	843ffc04 	addi	r16,r16,-16
81121eb4:	d8c02017 	ldw	r3,128(sp)
81121eb8:	d8801f17 	ldw	r2,124(sp)
81121ebc:	da000404 	addi	r8,sp,16
81121ec0:	8c3fed16 	blt	r17,r16,81121e78 <__reset+0xfb101e78>
81121ec4:	d9403517 	ldw	r5,212(sp)
81121ec8:	1c07883a 	add	r3,r3,r16
81121ecc:	10800044 	addi	r2,r2,1
81121ed0:	41400015 	stw	r5,0(r8)
81121ed4:	44000115 	stw	r16,4(r8)
81121ed8:	d8c02015 	stw	r3,128(sp)
81121edc:	d8801f15 	stw	r2,124(sp)
81121ee0:	010001c4 	movi	r4,7
81121ee4:	2080060e 	bge	r4,r2,81121f00 <___svfprintf_internal_r+0xa28>
81121ee8:	d9402c17 	ldw	r5,176(sp)
81121eec:	d9801e04 	addi	r6,sp,120
81121ef0:	9809883a 	mov	r4,r19
81121ef4:	112e0f80 	call	8112e0f8 <__ssprint_r>
81121ef8:	103e5e1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81121efc:	d8c02017 	ldw	r3,128(sp)
81121f00:	d8803117 	ldw	r2,196(sp)
81121f04:	d9002a17 	ldw	r4,168(sp)
81121f08:	1100010e 	bge	r2,r4,81121f10 <___svfprintf_internal_r+0xa38>
81121f0c:	2005883a 	mov	r2,r4
81121f10:	d9402f17 	ldw	r5,188(sp)
81121f14:	288b883a 	add	r5,r5,r2
81121f18:	d9402f15 	stw	r5,188(sp)
81121f1c:	18019c1e 	bne	r3,zero,81122590 <___svfprintf_internal_r+0x10b8>
81121f20:	b8800007 	ldb	r2,0(r23)
81121f24:	d8001f15 	stw	zero,124(sp)
81121f28:	da000404 	addi	r8,sp,16
81121f2c:	103d991e 	bne	r2,zero,81121594 <__reset+0xfb101594>
81121f30:	b821883a 	mov	r16,r23
81121f34:	003daf06 	br	811215f4 <__reset+0xfb1015f4>
81121f38:	18c03fcc 	andi	r3,r3,255
81121f3c:	1805c71e 	bne	r3,zero,8112365c <___svfprintf_internal_r+0x2184>
81121f40:	94800414 	ori	r18,r18,16
81121f44:	9080080c 	andi	r2,r18,32
81121f48:	10020126 	beq	r2,zero,81122750 <___svfprintf_internal_r+0x1278>
81121f4c:	d8802d17 	ldw	r2,180(sp)
81121f50:	d9002917 	ldw	r4,164(sp)
81121f54:	d8002785 	stb	zero,158(sp)
81121f58:	10c00204 	addi	r3,r2,8
81121f5c:	15000017 	ldw	r20,0(r2)
81121f60:	15800117 	ldw	r22,4(r2)
81121f64:	20038e16 	blt	r4,zero,81122da0 <___svfprintf_internal_r+0x18c8>
81121f68:	013fdfc4 	movi	r4,-129
81121f6c:	a584b03a 	or	r2,r20,r22
81121f70:	d8c02d15 	stw	r3,180(sp)
81121f74:	9124703a 	and	r18,r18,r4
81121f78:	0039883a 	mov	fp,zero
81121f7c:	103eb61e 	bne	r2,zero,81121a58 <__reset+0xfb101a58>
81121f80:	d8802917 	ldw	r2,164(sp)
81121f84:	1002c81e 	bne	r2,zero,81122aa8 <___svfprintf_internal_r+0x15d0>
81121f88:	d8002915 	stw	zero,164(sp)
81121f8c:	d8002e15 	stw	zero,184(sp)
81121f90:	dc001e04 	addi	r16,sp,120
81121f94:	003efa06 	br	81121b80 <__reset+0xfb101b80>
81121f98:	18c03fcc 	andi	r3,r3,255
81121f9c:	1805ad1e 	bne	r3,zero,81123654 <___svfprintf_internal_r+0x217c>
81121fa0:	01604574 	movhi	r5,33045
81121fa4:	2978f204 	addi	r5,r5,-7224
81121fa8:	d9403a15 	stw	r5,232(sp)
81121fac:	9080080c 	andi	r2,r18,32
81121fb0:	10006126 	beq	r2,zero,81122138 <___svfprintf_internal_r+0xc60>
81121fb4:	d8802d17 	ldw	r2,180(sp)
81121fb8:	15000017 	ldw	r20,0(r2)
81121fbc:	15800117 	ldw	r22,4(r2)
81121fc0:	10800204 	addi	r2,r2,8
81121fc4:	d8802d15 	stw	r2,180(sp)
81121fc8:	9080004c 	andi	r2,r18,1
81121fcc:	10018e26 	beq	r2,zero,81122608 <___svfprintf_internal_r+0x1130>
81121fd0:	a584b03a 	or	r2,r20,r22
81121fd4:	10030926 	beq	r2,zero,81122bfc <___svfprintf_internal_r+0x1724>
81121fd8:	d8c02917 	ldw	r3,164(sp)
81121fdc:	00800c04 	movi	r2,48
81121fe0:	d8802705 	stb	r2,156(sp)
81121fe4:	dc402745 	stb	r17,157(sp)
81121fe8:	d8002785 	stb	zero,158(sp)
81121fec:	90800094 	ori	r2,r18,2
81121ff0:	18048716 	blt	r3,zero,81123210 <___svfprintf_internal_r+0x1d38>
81121ff4:	00bfdfc4 	movi	r2,-129
81121ff8:	90a4703a 	and	r18,r18,r2
81121ffc:	94800094 	ori	r18,r18,2
81122000:	0039883a 	mov	fp,zero
81122004:	d9003a17 	ldw	r4,232(sp)
81122008:	dc001e04 	addi	r16,sp,120
8112200c:	a08003cc 	andi	r2,r20,15
81122010:	b006973a 	slli	r3,r22,28
81122014:	2085883a 	add	r2,r4,r2
81122018:	a028d13a 	srli	r20,r20,4
8112201c:	10800003 	ldbu	r2,0(r2)
81122020:	b02cd13a 	srli	r22,r22,4
81122024:	843fffc4 	addi	r16,r16,-1
81122028:	1d28b03a 	or	r20,r3,r20
8112202c:	80800005 	stb	r2,0(r16)
81122030:	a584b03a 	or	r2,r20,r22
81122034:	103ff51e 	bne	r2,zero,8112200c <__reset+0xfb10200c>
81122038:	d8c02817 	ldw	r3,160(sp)
8112203c:	1c07c83a 	sub	r3,r3,r16
81122040:	d8c02e15 	stw	r3,184(sp)
81122044:	003ece06 	br	81121b80 <__reset+0xfb101b80>
81122048:	d8c02d17 	ldw	r3,180(sp)
8112204c:	d9002d17 	ldw	r4,180(sp)
81122050:	d8002785 	stb	zero,158(sp)
81122054:	18800017 	ldw	r2,0(r3)
81122058:	21000104 	addi	r4,r4,4
8112205c:	00c00044 	movi	r3,1
81122060:	d8c02a15 	stw	r3,168(sp)
81122064:	d8801405 	stb	r2,80(sp)
81122068:	d9002d15 	stw	r4,180(sp)
8112206c:	d8c02e15 	stw	r3,184(sp)
81122070:	d8002915 	stw	zero,164(sp)
81122074:	d8003215 	stw	zero,200(sp)
81122078:	dc001404 	addi	r16,sp,80
8112207c:	0039883a 	mov	fp,zero
81122080:	003ecc06 	br	81121bb4 <__reset+0xfb101bb4>
81122084:	18c03fcc 	andi	r3,r3,255
81122088:	183e9226 	beq	r3,zero,81121ad4 <__reset+0xfb101ad4>
8112208c:	d9c02785 	stb	r7,158(sp)
81122090:	003e9006 	br	81121ad4 <__reset+0xfb101ad4>
81122094:	00c00044 	movi	r3,1
81122098:	01c00ac4 	movi	r7,43
8112209c:	bc400007 	ldb	r17,0(r23)
811220a0:	003d6306 	br	81121630 <__reset+0xfb101630>
811220a4:	94800814 	ori	r18,r18,32
811220a8:	bc400007 	ldb	r17,0(r23)
811220ac:	003d6006 	br	81121630 <__reset+0xfb101630>
811220b0:	d8c02d17 	ldw	r3,180(sp)
811220b4:	d8002785 	stb	zero,158(sp)
811220b8:	1c000017 	ldw	r16,0(r3)
811220bc:	1d000104 	addi	r20,r3,4
811220c0:	80040f26 	beq	r16,zero,81123100 <___svfprintf_internal_r+0x1c28>
811220c4:	d9002917 	ldw	r4,164(sp)
811220c8:	2003dc16 	blt	r4,zero,8112303c <___svfprintf_internal_r+0x1b64>
811220cc:	200d883a 	mov	r6,r4
811220d0:	000b883a 	mov	r5,zero
811220d4:	8009883a 	mov	r4,r16
811220d8:	da003e15 	stw	r8,248(sp)
811220dc:	112a69c0 	call	8112a69c <memchr>
811220e0:	da003e17 	ldw	r8,248(sp)
811220e4:	10045826 	beq	r2,zero,81123248 <___svfprintf_internal_r+0x1d70>
811220e8:	1405c83a 	sub	r2,r2,r16
811220ec:	d8802e15 	stw	r2,184(sp)
811220f0:	1003d816 	blt	r2,zero,81123054 <___svfprintf_internal_r+0x1b7c>
811220f4:	df002783 	ldbu	fp,158(sp)
811220f8:	d8802a15 	stw	r2,168(sp)
811220fc:	dd002d15 	stw	r20,180(sp)
81122100:	d8002915 	stw	zero,164(sp)
81122104:	d8003215 	stw	zero,200(sp)
81122108:	003ea306 	br	81121b98 <__reset+0xfb101b98>
8112210c:	18c03fcc 	andi	r3,r3,255
81122110:	183f8c26 	beq	r3,zero,81121f44 <__reset+0xfb101f44>
81122114:	d9c02785 	stb	r7,158(sp)
81122118:	003f8a06 	br	81121f44 <__reset+0xfb101f44>
8112211c:	18c03fcc 	andi	r3,r3,255
81122120:	1805631e 	bne	r3,zero,811236b0 <___svfprintf_internal_r+0x21d8>
81122124:	01604574 	movhi	r5,33045
81122128:	2978f704 	addi	r5,r5,-7204
8112212c:	d9403a15 	stw	r5,232(sp)
81122130:	9080080c 	andi	r2,r18,32
81122134:	103f9f1e 	bne	r2,zero,81121fb4 <__reset+0xfb101fb4>
81122138:	9080040c 	andi	r2,r18,16
8112213c:	10029c26 	beq	r2,zero,81122bb0 <___svfprintf_internal_r+0x16d8>
81122140:	d8c02d17 	ldw	r3,180(sp)
81122144:	002d883a 	mov	r22,zero
81122148:	1d000017 	ldw	r20,0(r3)
8112214c:	18c00104 	addi	r3,r3,4
81122150:	d8c02d15 	stw	r3,180(sp)
81122154:	003f9c06 	br	81121fc8 <__reset+0xfb101fc8>
81122158:	94800054 	ori	r18,r18,1
8112215c:	bc400007 	ldb	r17,0(r23)
81122160:	003d3306 	br	81121630 <__reset+0xfb101630>
81122164:	38803fcc 	andi	r2,r7,255
81122168:	1080201c 	xori	r2,r2,128
8112216c:	10bfe004 	addi	r2,r2,-128
81122170:	1002971e 	bne	r2,zero,81122bd0 <___svfprintf_internal_r+0x16f8>
81122174:	00c00044 	movi	r3,1
81122178:	01c00804 	movi	r7,32
8112217c:	bc400007 	ldb	r17,0(r23)
81122180:	003d2b06 	br	81121630 <__reset+0xfb101630>
81122184:	18c03fcc 	andi	r3,r3,255
81122188:	183e2326 	beq	r3,zero,81121a18 <__reset+0xfb101a18>
8112218c:	d9c02785 	stb	r7,158(sp)
81122190:	003e2106 	br	81121a18 <__reset+0xfb101a18>
81122194:	bc400007 	ldb	r17,0(r23)
81122198:	8a430426 	beq	r17,r9,81122dac <___svfprintf_internal_r+0x18d4>
8112219c:	94800414 	ori	r18,r18,16
811221a0:	003d2306 	br	81121630 <__reset+0xfb101630>
811221a4:	18c03fcc 	andi	r3,r3,255
811221a8:	18053f1e 	bne	r3,zero,811236a8 <___svfprintf_internal_r+0x21d0>
811221ac:	9080080c 	andi	r2,r18,32
811221b0:	10028926 	beq	r2,zero,81122bd8 <___svfprintf_internal_r+0x1700>
811221b4:	d9402d17 	ldw	r5,180(sp)
811221b8:	d9002f17 	ldw	r4,188(sp)
811221bc:	28800017 	ldw	r2,0(r5)
811221c0:	2007d7fa 	srai	r3,r4,31
811221c4:	29400104 	addi	r5,r5,4
811221c8:	d9402d15 	stw	r5,180(sp)
811221cc:	11000015 	stw	r4,0(r2)
811221d0:	10c00115 	stw	r3,4(r2)
811221d4:	003ced06 	br	8112158c <__reset+0xfb10158c>
811221d8:	94801014 	ori	r18,r18,64
811221dc:	bc400007 	ldb	r17,0(r23)
811221e0:	003d1306 	br	81121630 <__reset+0xfb101630>
811221e4:	01204574 	movhi	r4,33045
811221e8:	2138f704 	addi	r4,r4,-7204
811221ec:	0039883a 	mov	fp,zero
811221f0:	d9003a15 	stw	r4,232(sp)
811221f4:	04401e04 	movi	r17,120
811221f8:	003f8206 	br	81122004 <__reset+0xfb102004>
811221fc:	18c03fcc 	andi	r3,r3,255
81122200:	1805221e 	bne	r3,zero,8112368c <___svfprintf_internal_r+0x21b4>
81122204:	883d9526 	beq	r17,zero,8112185c <__reset+0xfb10185c>
81122208:	00c00044 	movi	r3,1
8112220c:	d8c02a15 	stw	r3,168(sp)
81122210:	dc401405 	stb	r17,80(sp)
81122214:	d8002785 	stb	zero,158(sp)
81122218:	003f9406 	br	8112206c <__reset+0xfb10206c>
8112221c:	01204574 	movhi	r4,33045
81122220:	2138f704 	addi	r4,r4,-7204
81122224:	d9003a15 	stw	r4,232(sp)
81122228:	d8c02d15 	stw	r3,180(sp)
8112222c:	1025883a 	mov	r18,r2
81122230:	04401e04 	movi	r17,120
81122234:	a584b03a 	or	r2,r20,r22
81122238:	1000fa1e 	bne	r2,zero,81122624 <___svfprintf_internal_r+0x114c>
8112223c:	0039883a 	mov	fp,zero
81122240:	00800084 	movi	r2,2
81122244:	10803fcc 	andi	r2,r2,255
81122248:	00c00044 	movi	r3,1
8112224c:	10c21626 	beq	r2,r3,81122aa8 <___svfprintf_internal_r+0x15d0>
81122250:	00c00084 	movi	r3,2
81122254:	10fe301e 	bne	r2,r3,81121b18 <__reset+0xfb101b18>
81122258:	003d7606 	br	81121834 <__reset+0xfb101834>
8112225c:	d8c02017 	ldw	r3,128(sp)
81122260:	003e9506 	br	81121cb8 <__reset+0xfb101cb8>
81122264:	00801944 	movi	r2,101
81122268:	14407c0e 	bge	r2,r17,8112245c <___svfprintf_internal_r+0xf84>
8112226c:	d9003617 	ldw	r4,216(sp)
81122270:	d9403717 	ldw	r5,220(sp)
81122274:	000d883a 	mov	r6,zero
81122278:	000f883a 	mov	r7,zero
8112227c:	d8c03d15 	stw	r3,244(sp)
81122280:	da003e15 	stw	r8,248(sp)
81122284:	11340740 	call	81134074 <__eqdf2>
81122288:	d8c03d17 	ldw	r3,244(sp)
8112228c:	da003e17 	ldw	r8,248(sp)
81122290:	1000f51e 	bne	r2,zero,81122668 <___svfprintf_internal_r+0x1190>
81122294:	d8801f17 	ldw	r2,124(sp)
81122298:	01204574 	movhi	r4,33045
8112229c:	2138fe04 	addi	r4,r4,-7176
811222a0:	18c00044 	addi	r3,r3,1
811222a4:	10800044 	addi	r2,r2,1
811222a8:	41000015 	stw	r4,0(r8)
811222ac:	01000044 	movi	r4,1
811222b0:	41000115 	stw	r4,4(r8)
811222b4:	d8c02015 	stw	r3,128(sp)
811222b8:	d8801f15 	stw	r2,124(sp)
811222bc:	010001c4 	movi	r4,7
811222c0:	20826616 	blt	r4,r2,81122c5c <___svfprintf_internal_r+0x1784>
811222c4:	42000204 	addi	r8,r8,8
811222c8:	d8802617 	ldw	r2,152(sp)
811222cc:	d9403317 	ldw	r5,204(sp)
811222d0:	11400216 	blt	r2,r5,811222dc <___svfprintf_internal_r+0xe04>
811222d4:	9080004c 	andi	r2,r18,1
811222d8:	103ed526 	beq	r2,zero,81121e30 <__reset+0xfb101e30>
811222dc:	d8803817 	ldw	r2,224(sp)
811222e0:	d9003417 	ldw	r4,208(sp)
811222e4:	d9403817 	ldw	r5,224(sp)
811222e8:	1887883a 	add	r3,r3,r2
811222ec:	d8801f17 	ldw	r2,124(sp)
811222f0:	41000015 	stw	r4,0(r8)
811222f4:	41400115 	stw	r5,4(r8)
811222f8:	10800044 	addi	r2,r2,1
811222fc:	d8c02015 	stw	r3,128(sp)
81122300:	d8801f15 	stw	r2,124(sp)
81122304:	010001c4 	movi	r4,7
81122308:	2082af16 	blt	r4,r2,81122dc8 <___svfprintf_internal_r+0x18f0>
8112230c:	42000204 	addi	r8,r8,8
81122310:	d8803317 	ldw	r2,204(sp)
81122314:	143fffc4 	addi	r16,r2,-1
81122318:	043ec50e 	bge	zero,r16,81121e30 <__reset+0xfb101e30>
8112231c:	04400404 	movi	r17,16
81122320:	d8801f17 	ldw	r2,124(sp)
81122324:	8c00860e 	bge	r17,r16,81122540 <___svfprintf_internal_r+0x1068>
81122328:	01604574 	movhi	r5,33045
8112232c:	2978fe84 	addi	r5,r5,-7174
81122330:	d9402b15 	stw	r5,172(sp)
81122334:	058001c4 	movi	r22,7
81122338:	dd002c17 	ldw	r20,176(sp)
8112233c:	00000306 	br	8112234c <___svfprintf_internal_r+0xe74>
81122340:	42000204 	addi	r8,r8,8
81122344:	843ffc04 	addi	r16,r16,-16
81122348:	8c00800e 	bge	r17,r16,8112254c <___svfprintf_internal_r+0x1074>
8112234c:	18c00404 	addi	r3,r3,16
81122350:	10800044 	addi	r2,r2,1
81122354:	45400015 	stw	r21,0(r8)
81122358:	44400115 	stw	r17,4(r8)
8112235c:	d8c02015 	stw	r3,128(sp)
81122360:	d8801f15 	stw	r2,124(sp)
81122364:	b0bff60e 	bge	r22,r2,81122340 <__reset+0xfb102340>
81122368:	d9801e04 	addi	r6,sp,120
8112236c:	a00b883a 	mov	r5,r20
81122370:	9809883a 	mov	r4,r19
81122374:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122378:	103d3e1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
8112237c:	d8c02017 	ldw	r3,128(sp)
81122380:	d8801f17 	ldw	r2,124(sp)
81122384:	da000404 	addi	r8,sp,16
81122388:	003fee06 	br	81122344 <__reset+0xfb102344>
8112238c:	d9403117 	ldw	r5,196(sp)
81122390:	d8802a17 	ldw	r2,168(sp)
81122394:	28adc83a 	sub	r22,r5,r2
81122398:	05be650e 	bge	zero,r22,81121d30 <__reset+0xfb101d30>
8112239c:	07000404 	movi	fp,16
811223a0:	d8801f17 	ldw	r2,124(sp)
811223a4:	e583a20e 	bge	fp,r22,81123230 <___svfprintf_internal_r+0x1d58>
811223a8:	01604574 	movhi	r5,33045
811223ac:	2978fe84 	addi	r5,r5,-7174
811223b0:	dc403015 	stw	r17,192(sp)
811223b4:	d9402b15 	stw	r5,172(sp)
811223b8:	b023883a 	mov	r17,r22
811223bc:	050001c4 	movi	r20,7
811223c0:	902d883a 	mov	r22,r18
811223c4:	8025883a 	mov	r18,r16
811223c8:	dc002c17 	ldw	r16,176(sp)
811223cc:	00000306 	br	811223dc <___svfprintf_internal_r+0xf04>
811223d0:	8c7ffc04 	addi	r17,r17,-16
811223d4:	42000204 	addi	r8,r8,8
811223d8:	e440110e 	bge	fp,r17,81122420 <___svfprintf_internal_r+0xf48>
811223dc:	18c00404 	addi	r3,r3,16
811223e0:	10800044 	addi	r2,r2,1
811223e4:	45400015 	stw	r21,0(r8)
811223e8:	47000115 	stw	fp,4(r8)
811223ec:	d8c02015 	stw	r3,128(sp)
811223f0:	d8801f15 	stw	r2,124(sp)
811223f4:	a0bff60e 	bge	r20,r2,811223d0 <__reset+0xfb1023d0>
811223f8:	d9801e04 	addi	r6,sp,120
811223fc:	800b883a 	mov	r5,r16
81122400:	9809883a 	mov	r4,r19
81122404:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122408:	103d1a1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
8112240c:	8c7ffc04 	addi	r17,r17,-16
81122410:	d8c02017 	ldw	r3,128(sp)
81122414:	d8801f17 	ldw	r2,124(sp)
81122418:	da000404 	addi	r8,sp,16
8112241c:	e47fef16 	blt	fp,r17,811223dc <__reset+0xfb1023dc>
81122420:	9021883a 	mov	r16,r18
81122424:	b025883a 	mov	r18,r22
81122428:	882d883a 	mov	r22,r17
8112242c:	dc403017 	ldw	r17,192(sp)
81122430:	d9002b17 	ldw	r4,172(sp)
81122434:	1d87883a 	add	r3,r3,r22
81122438:	10800044 	addi	r2,r2,1
8112243c:	41000015 	stw	r4,0(r8)
81122440:	45800115 	stw	r22,4(r8)
81122444:	d8c02015 	stw	r3,128(sp)
81122448:	d8801f15 	stw	r2,124(sp)
8112244c:	010001c4 	movi	r4,7
81122450:	20819a16 	blt	r4,r2,81122abc <___svfprintf_internal_r+0x15e4>
81122454:	42000204 	addi	r8,r8,8
81122458:	003e3506 	br	81121d30 <__reset+0xfb101d30>
8112245c:	d9403317 	ldw	r5,204(sp)
81122460:	00800044 	movi	r2,1
81122464:	18c00044 	addi	r3,r3,1
81122468:	1141710e 	bge	r2,r5,81122a30 <___svfprintf_internal_r+0x1558>
8112246c:	dc401f17 	ldw	r17,124(sp)
81122470:	00800044 	movi	r2,1
81122474:	40800115 	stw	r2,4(r8)
81122478:	8c400044 	addi	r17,r17,1
8112247c:	44000015 	stw	r16,0(r8)
81122480:	d8c02015 	stw	r3,128(sp)
81122484:	dc401f15 	stw	r17,124(sp)
81122488:	008001c4 	movi	r2,7
8112248c:	14417416 	blt	r2,r17,81122a60 <___svfprintf_internal_r+0x1588>
81122490:	42000204 	addi	r8,r8,8
81122494:	d8803817 	ldw	r2,224(sp)
81122498:	d9003417 	ldw	r4,208(sp)
8112249c:	8c400044 	addi	r17,r17,1
811224a0:	10c7883a 	add	r3,r2,r3
811224a4:	40800115 	stw	r2,4(r8)
811224a8:	41000015 	stw	r4,0(r8)
811224ac:	d8c02015 	stw	r3,128(sp)
811224b0:	dc401f15 	stw	r17,124(sp)
811224b4:	008001c4 	movi	r2,7
811224b8:	14417216 	blt	r2,r17,81122a84 <___svfprintf_internal_r+0x15ac>
811224bc:	45800204 	addi	r22,r8,8
811224c0:	d9003617 	ldw	r4,216(sp)
811224c4:	d9403717 	ldw	r5,220(sp)
811224c8:	000d883a 	mov	r6,zero
811224cc:	000f883a 	mov	r7,zero
811224d0:	d8c03d15 	stw	r3,244(sp)
811224d4:	11340740 	call	81134074 <__eqdf2>
811224d8:	d8c03d17 	ldw	r3,244(sp)
811224dc:	1000b326 	beq	r2,zero,811227ac <___svfprintf_internal_r+0x12d4>
811224e0:	d9403317 	ldw	r5,204(sp)
811224e4:	84000044 	addi	r16,r16,1
811224e8:	8c400044 	addi	r17,r17,1
811224ec:	28bfffc4 	addi	r2,r5,-1
811224f0:	1887883a 	add	r3,r3,r2
811224f4:	b0800115 	stw	r2,4(r22)
811224f8:	b4000015 	stw	r16,0(r22)
811224fc:	d8c02015 	stw	r3,128(sp)
81122500:	dc401f15 	stw	r17,124(sp)
81122504:	008001c4 	movi	r2,7
81122508:	1440d216 	blt	r2,r17,81122854 <___svfprintf_internal_r+0x137c>
8112250c:	b5800204 	addi	r22,r22,8
81122510:	d9003b17 	ldw	r4,236(sp)
81122514:	df0022c4 	addi	fp,sp,139
81122518:	8c400044 	addi	r17,r17,1
8112251c:	20c7883a 	add	r3,r4,r3
81122520:	b7000015 	stw	fp,0(r22)
81122524:	b1000115 	stw	r4,4(r22)
81122528:	d8c02015 	stw	r3,128(sp)
8112252c:	dc401f15 	stw	r17,124(sp)
81122530:	008001c4 	movi	r2,7
81122534:	14400e16 	blt	r2,r17,81122570 <___svfprintf_internal_r+0x1098>
81122538:	b2000204 	addi	r8,r22,8
8112253c:	003e3c06 	br	81121e30 <__reset+0xfb101e30>
81122540:	01204574 	movhi	r4,33045
81122544:	2138fe84 	addi	r4,r4,-7174
81122548:	d9002b15 	stw	r4,172(sp)
8112254c:	d9002b17 	ldw	r4,172(sp)
81122550:	1c07883a 	add	r3,r3,r16
81122554:	44000115 	stw	r16,4(r8)
81122558:	41000015 	stw	r4,0(r8)
8112255c:	10800044 	addi	r2,r2,1
81122560:	d8c02015 	stw	r3,128(sp)
81122564:	d8801f15 	stw	r2,124(sp)
81122568:	010001c4 	movi	r4,7
8112256c:	20be2f0e 	bge	r4,r2,81121e2c <__reset+0xfb101e2c>
81122570:	d9402c17 	ldw	r5,176(sp)
81122574:	d9801e04 	addi	r6,sp,120
81122578:	9809883a 	mov	r4,r19
8112257c:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122580:	103cbc1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122584:	d8c02017 	ldw	r3,128(sp)
81122588:	da000404 	addi	r8,sp,16
8112258c:	003e2806 	br	81121e30 <__reset+0xfb101e30>
81122590:	d9402c17 	ldw	r5,176(sp)
81122594:	d9801e04 	addi	r6,sp,120
81122598:	9809883a 	mov	r4,r19
8112259c:	112e0f80 	call	8112e0f8 <__ssprint_r>
811225a0:	103e5f26 	beq	r2,zero,81121f20 <__reset+0xfb101f20>
811225a4:	003cb306 	br	81121874 <__reset+0xfb101874>
811225a8:	d9402c17 	ldw	r5,176(sp)
811225ac:	d9801e04 	addi	r6,sp,120
811225b0:	9809883a 	mov	r4,r19
811225b4:	112e0f80 	call	8112e0f8 <__ssprint_r>
811225b8:	103cae1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
811225bc:	d8c02017 	ldw	r3,128(sp)
811225c0:	da000404 	addi	r8,sp,16
811225c4:	003e0d06 	br	81121dfc <__reset+0xfb101dfc>
811225c8:	d9402c17 	ldw	r5,176(sp)
811225cc:	d9801e04 	addi	r6,sp,120
811225d0:	9809883a 	mov	r4,r19
811225d4:	112e0f80 	call	8112e0f8 <__ssprint_r>
811225d8:	103ca61e 	bne	r2,zero,81121874 <__reset+0xfb101874>
811225dc:	d8c02017 	ldw	r3,128(sp)
811225e0:	da000404 	addi	r8,sp,16
811225e4:	003dc106 	br	81121cec <__reset+0xfb101cec>
811225e8:	d9402c17 	ldw	r5,176(sp)
811225ec:	d9801e04 	addi	r6,sp,120
811225f0:	9809883a 	mov	r4,r19
811225f4:	112e0f80 	call	8112e0f8 <__ssprint_r>
811225f8:	103c9e1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
811225fc:	d8c02017 	ldw	r3,128(sp)
81122600:	da000404 	addi	r8,sp,16
81122604:	003dc706 	br	81121d24 <__reset+0xfb101d24>
81122608:	d8802917 	ldw	r2,164(sp)
8112260c:	d8002785 	stb	zero,158(sp)
81122610:	103f0816 	blt	r2,zero,81122234 <__reset+0xfb102234>
81122614:	00ffdfc4 	movi	r3,-129
81122618:	a584b03a 	or	r2,r20,r22
8112261c:	90e4703a 	and	r18,r18,r3
81122620:	103c8126 	beq	r2,zero,81121828 <__reset+0xfb101828>
81122624:	0039883a 	mov	fp,zero
81122628:	003e7606 	br	81122004 <__reset+0xfb102004>
8112262c:	9080040c 	andi	r2,r18,16
81122630:	10013d26 	beq	r2,zero,81122b28 <___svfprintf_internal_r+0x1650>
81122634:	d9002d17 	ldw	r4,180(sp)
81122638:	d9402917 	ldw	r5,164(sp)
8112263c:	d8002785 	stb	zero,158(sp)
81122640:	20800104 	addi	r2,r4,4
81122644:	25000017 	ldw	r20,0(r4)
81122648:	002d883a 	mov	r22,zero
8112264c:	28013f16 	blt	r5,zero,81122b4c <___svfprintf_internal_r+0x1674>
81122650:	00ffdfc4 	movi	r3,-129
81122654:	d8802d15 	stw	r2,180(sp)
81122658:	90e4703a 	and	r18,r18,r3
8112265c:	a03d2b26 	beq	r20,zero,81121b0c <__reset+0xfb101b0c>
81122660:	0039883a 	mov	fp,zero
81122664:	003d2e06 	br	81121b20 <__reset+0xfb101b20>
81122668:	dc402617 	ldw	r17,152(sp)
8112266c:	0441830e 	bge	zero,r17,81122c7c <___svfprintf_internal_r+0x17a4>
81122670:	dc403217 	ldw	r17,200(sp)
81122674:	d8803317 	ldw	r2,204(sp)
81122678:	1440010e 	bge	r2,r17,81122680 <___svfprintf_internal_r+0x11a8>
8112267c:	1023883a 	mov	r17,r2
81122680:	04400a0e 	bge	zero,r17,811226ac <___svfprintf_internal_r+0x11d4>
81122684:	d8801f17 	ldw	r2,124(sp)
81122688:	1c47883a 	add	r3,r3,r17
8112268c:	44000015 	stw	r16,0(r8)
81122690:	10800044 	addi	r2,r2,1
81122694:	44400115 	stw	r17,4(r8)
81122698:	d8c02015 	stw	r3,128(sp)
8112269c:	d8801f15 	stw	r2,124(sp)
811226a0:	010001c4 	movi	r4,7
811226a4:	20827516 	blt	r4,r2,8112307c <___svfprintf_internal_r+0x1ba4>
811226a8:	42000204 	addi	r8,r8,8
811226ac:	88027b16 	blt	r17,zero,8112309c <___svfprintf_internal_r+0x1bc4>
811226b0:	d9003217 	ldw	r4,200(sp)
811226b4:	2463c83a 	sub	r17,r4,r17
811226b8:	0440990e 	bge	zero,r17,81122920 <___svfprintf_internal_r+0x1448>
811226bc:	05800404 	movi	r22,16
811226c0:	d8801f17 	ldw	r2,124(sp)
811226c4:	b441530e 	bge	r22,r17,81122c14 <___svfprintf_internal_r+0x173c>
811226c8:	01204574 	movhi	r4,33045
811226cc:	2138fe84 	addi	r4,r4,-7174
811226d0:	d9002b15 	stw	r4,172(sp)
811226d4:	070001c4 	movi	fp,7
811226d8:	dd002c17 	ldw	r20,176(sp)
811226dc:	00000306 	br	811226ec <___svfprintf_internal_r+0x1214>
811226e0:	42000204 	addi	r8,r8,8
811226e4:	8c7ffc04 	addi	r17,r17,-16
811226e8:	b4414d0e 	bge	r22,r17,81122c20 <___svfprintf_internal_r+0x1748>
811226ec:	18c00404 	addi	r3,r3,16
811226f0:	10800044 	addi	r2,r2,1
811226f4:	45400015 	stw	r21,0(r8)
811226f8:	45800115 	stw	r22,4(r8)
811226fc:	d8c02015 	stw	r3,128(sp)
81122700:	d8801f15 	stw	r2,124(sp)
81122704:	e0bff60e 	bge	fp,r2,811226e0 <__reset+0xfb1026e0>
81122708:	d9801e04 	addi	r6,sp,120
8112270c:	a00b883a 	mov	r5,r20
81122710:	9809883a 	mov	r4,r19
81122714:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122718:	103c561e 	bne	r2,zero,81121874 <__reset+0xfb101874>
8112271c:	d8c02017 	ldw	r3,128(sp)
81122720:	d8801f17 	ldw	r2,124(sp)
81122724:	da000404 	addi	r8,sp,16
81122728:	003fee06 	br	811226e4 <__reset+0xfb1026e4>
8112272c:	d9402c17 	ldw	r5,176(sp)
81122730:	d9801e04 	addi	r6,sp,120
81122734:	9809883a 	mov	r4,r19
81122738:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112273c:	103c4d1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122740:	d8c02017 	ldw	r3,128(sp)
81122744:	df002787 	ldb	fp,158(sp)
81122748:	da000404 	addi	r8,sp,16
8112274c:	003d5a06 	br	81121cb8 <__reset+0xfb101cb8>
81122750:	9080040c 	andi	r2,r18,16
81122754:	10005c26 	beq	r2,zero,811228c8 <___svfprintf_internal_r+0x13f0>
81122758:	d9402d17 	ldw	r5,180(sp)
8112275c:	d8c02917 	ldw	r3,164(sp)
81122760:	d8002785 	stb	zero,158(sp)
81122764:	28800104 	addi	r2,r5,4
81122768:	2d000017 	ldw	r20,0(r5)
8112276c:	002d883a 	mov	r22,zero
81122770:	18005e16 	blt	r3,zero,811228ec <___svfprintf_internal_r+0x1414>
81122774:	00ffdfc4 	movi	r3,-129
81122778:	d8802d15 	stw	r2,180(sp)
8112277c:	90e4703a 	and	r18,r18,r3
81122780:	0039883a 	mov	fp,zero
81122784:	a03dfe26 	beq	r20,zero,81121f80 <__reset+0xfb101f80>
81122788:	00800244 	movi	r2,9
8112278c:	153cb336 	bltu	r2,r20,81121a5c <__reset+0xfb101a5c>
81122790:	a5000c04 	addi	r20,r20,48
81122794:	dc001dc4 	addi	r16,sp,119
81122798:	dd001dc5 	stb	r20,119(sp)
8112279c:	d8c02817 	ldw	r3,160(sp)
811227a0:	1c07c83a 	sub	r3,r3,r16
811227a4:	d8c02e15 	stw	r3,184(sp)
811227a8:	003cf506 	br	81121b80 <__reset+0xfb101b80>
811227ac:	d8803317 	ldw	r2,204(sp)
811227b0:	143fffc4 	addi	r16,r2,-1
811227b4:	043f560e 	bge	zero,r16,81122510 <__reset+0xfb102510>
811227b8:	07000404 	movi	fp,16
811227bc:	e403530e 	bge	fp,r16,8112350c <___svfprintf_internal_r+0x2034>
811227c0:	01604574 	movhi	r5,33045
811227c4:	2978fe84 	addi	r5,r5,-7174
811227c8:	d9402b15 	stw	r5,172(sp)
811227cc:	01c001c4 	movi	r7,7
811227d0:	dd002c17 	ldw	r20,176(sp)
811227d4:	00000306 	br	811227e4 <___svfprintf_internal_r+0x130c>
811227d8:	843ffc04 	addi	r16,r16,-16
811227dc:	b5800204 	addi	r22,r22,8
811227e0:	e400130e 	bge	fp,r16,81122830 <___svfprintf_internal_r+0x1358>
811227e4:	18c00404 	addi	r3,r3,16
811227e8:	8c400044 	addi	r17,r17,1
811227ec:	b5400015 	stw	r21,0(r22)
811227f0:	b7000115 	stw	fp,4(r22)
811227f4:	d8c02015 	stw	r3,128(sp)
811227f8:	dc401f15 	stw	r17,124(sp)
811227fc:	3c7ff60e 	bge	r7,r17,811227d8 <__reset+0xfb1027d8>
81122800:	d9801e04 	addi	r6,sp,120
81122804:	a00b883a 	mov	r5,r20
81122808:	9809883a 	mov	r4,r19
8112280c:	d9c03d15 	stw	r7,244(sp)
81122810:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122814:	d9c03d17 	ldw	r7,244(sp)
81122818:	103c161e 	bne	r2,zero,81121874 <__reset+0xfb101874>
8112281c:	843ffc04 	addi	r16,r16,-16
81122820:	d8c02017 	ldw	r3,128(sp)
81122824:	dc401f17 	ldw	r17,124(sp)
81122828:	dd800404 	addi	r22,sp,16
8112282c:	e43fed16 	blt	fp,r16,811227e4 <__reset+0xfb1027e4>
81122830:	d8802b17 	ldw	r2,172(sp)
81122834:	1c07883a 	add	r3,r3,r16
81122838:	8c400044 	addi	r17,r17,1
8112283c:	b0800015 	stw	r2,0(r22)
81122840:	b4000115 	stw	r16,4(r22)
81122844:	d8c02015 	stw	r3,128(sp)
81122848:	dc401f15 	stw	r17,124(sp)
8112284c:	008001c4 	movi	r2,7
81122850:	147f2e0e 	bge	r2,r17,8112250c <__reset+0xfb10250c>
81122854:	d9402c17 	ldw	r5,176(sp)
81122858:	d9801e04 	addi	r6,sp,120
8112285c:	9809883a 	mov	r4,r19
81122860:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122864:	103c031e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122868:	d8c02017 	ldw	r3,128(sp)
8112286c:	dc401f17 	ldw	r17,124(sp)
81122870:	dd800404 	addi	r22,sp,16
81122874:	003f2606 	br	81122510 <__reset+0xfb102510>
81122878:	9080040c 	andi	r2,r18,16
8112287c:	1000c326 	beq	r2,zero,81122b8c <___svfprintf_internal_r+0x16b4>
81122880:	d8802d17 	ldw	r2,180(sp)
81122884:	15000017 	ldw	r20,0(r2)
81122888:	10800104 	addi	r2,r2,4
8112288c:	d8802d15 	stw	r2,180(sp)
81122890:	a02dd7fa 	srai	r22,r20,31
81122894:	b005883a 	mov	r2,r22
81122898:	103c680e 	bge	r2,zero,81121a3c <__reset+0xfb101a3c>
8112289c:	0529c83a 	sub	r20,zero,r20
811228a0:	a004c03a 	cmpne	r2,r20,zero
811228a4:	05adc83a 	sub	r22,zero,r22
811228a8:	b0adc83a 	sub	r22,r22,r2
811228ac:	d8802917 	ldw	r2,164(sp)
811228b0:	07000b44 	movi	fp,45
811228b4:	df002785 	stb	fp,158(sp)
811228b8:	10022e16 	blt	r2,zero,81123174 <___svfprintf_internal_r+0x1c9c>
811228bc:	00bfdfc4 	movi	r2,-129
811228c0:	90a4703a 	and	r18,r18,r2
811228c4:	003c6406 	br	81121a58 <__reset+0xfb101a58>
811228c8:	9080100c 	andi	r2,r18,64
811228cc:	d8002785 	stb	zero,158(sp)
811228d0:	10012526 	beq	r2,zero,81122d68 <___svfprintf_internal_r+0x1890>
811228d4:	d9002d17 	ldw	r4,180(sp)
811228d8:	d9402917 	ldw	r5,164(sp)
811228dc:	002d883a 	mov	r22,zero
811228e0:	20800104 	addi	r2,r4,4
811228e4:	2500000b 	ldhu	r20,0(r4)
811228e8:	283fa20e 	bge	r5,zero,81122774 <__reset+0xfb102774>
811228ec:	d8802d15 	stw	r2,180(sp)
811228f0:	0039883a 	mov	fp,zero
811228f4:	a584b03a 	or	r2,r20,r22
811228f8:	103c571e 	bne	r2,zero,81121a58 <__reset+0xfb101a58>
811228fc:	00800044 	movi	r2,1
81122900:	003e5006 	br	81122244 <__reset+0xfb102244>
81122904:	d9402c17 	ldw	r5,176(sp)
81122908:	d9801e04 	addi	r6,sp,120
8112290c:	9809883a 	mov	r4,r19
81122910:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122914:	103bd71e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122918:	d8c02017 	ldw	r3,128(sp)
8112291c:	da000404 	addi	r8,sp,16
81122920:	d9003217 	ldw	r4,200(sp)
81122924:	d8802617 	ldw	r2,152(sp)
81122928:	d9403317 	ldw	r5,204(sp)
8112292c:	8123883a 	add	r17,r16,r4
81122930:	11400216 	blt	r2,r5,8112293c <___svfprintf_internal_r+0x1464>
81122934:	9100004c 	andi	r4,r18,1
81122938:	20000d26 	beq	r4,zero,81122970 <___svfprintf_internal_r+0x1498>
8112293c:	d9003817 	ldw	r4,224(sp)
81122940:	d9403417 	ldw	r5,208(sp)
81122944:	1907883a 	add	r3,r3,r4
81122948:	d9001f17 	ldw	r4,124(sp)
8112294c:	41400015 	stw	r5,0(r8)
81122950:	d9403817 	ldw	r5,224(sp)
81122954:	21000044 	addi	r4,r4,1
81122958:	d8c02015 	stw	r3,128(sp)
8112295c:	41400115 	stw	r5,4(r8)
81122960:	d9001f15 	stw	r4,124(sp)
81122964:	014001c4 	movi	r5,7
81122968:	2901dc16 	blt	r5,r4,811230dc <___svfprintf_internal_r+0x1c04>
8112296c:	42000204 	addi	r8,r8,8
81122970:	d9003317 	ldw	r4,204(sp)
81122974:	8121883a 	add	r16,r16,r4
81122978:	2085c83a 	sub	r2,r4,r2
8112297c:	8461c83a 	sub	r16,r16,r17
81122980:	1400010e 	bge	r2,r16,81122988 <___svfprintf_internal_r+0x14b0>
81122984:	1021883a 	mov	r16,r2
81122988:	04000a0e 	bge	zero,r16,811229b4 <___svfprintf_internal_r+0x14dc>
8112298c:	d9001f17 	ldw	r4,124(sp)
81122990:	1c07883a 	add	r3,r3,r16
81122994:	44400015 	stw	r17,0(r8)
81122998:	21000044 	addi	r4,r4,1
8112299c:	44000115 	stw	r16,4(r8)
811229a0:	d8c02015 	stw	r3,128(sp)
811229a4:	d9001f15 	stw	r4,124(sp)
811229a8:	014001c4 	movi	r5,7
811229ac:	2901e616 	blt	r5,r4,81123148 <___svfprintf_internal_r+0x1c70>
811229b0:	42000204 	addi	r8,r8,8
811229b4:	8001f616 	blt	r16,zero,81123190 <___svfprintf_internal_r+0x1cb8>
811229b8:	1421c83a 	sub	r16,r2,r16
811229bc:	043d1c0e 	bge	zero,r16,81121e30 <__reset+0xfb101e30>
811229c0:	04400404 	movi	r17,16
811229c4:	d8801f17 	ldw	r2,124(sp)
811229c8:	8c3edd0e 	bge	r17,r16,81122540 <__reset+0xfb102540>
811229cc:	01604574 	movhi	r5,33045
811229d0:	2978fe84 	addi	r5,r5,-7174
811229d4:	d9402b15 	stw	r5,172(sp)
811229d8:	058001c4 	movi	r22,7
811229dc:	dd002c17 	ldw	r20,176(sp)
811229e0:	00000306 	br	811229f0 <___svfprintf_internal_r+0x1518>
811229e4:	42000204 	addi	r8,r8,8
811229e8:	843ffc04 	addi	r16,r16,-16
811229ec:	8c3ed70e 	bge	r17,r16,8112254c <__reset+0xfb10254c>
811229f0:	18c00404 	addi	r3,r3,16
811229f4:	10800044 	addi	r2,r2,1
811229f8:	45400015 	stw	r21,0(r8)
811229fc:	44400115 	stw	r17,4(r8)
81122a00:	d8c02015 	stw	r3,128(sp)
81122a04:	d8801f15 	stw	r2,124(sp)
81122a08:	b0bff60e 	bge	r22,r2,811229e4 <__reset+0xfb1029e4>
81122a0c:	d9801e04 	addi	r6,sp,120
81122a10:	a00b883a 	mov	r5,r20
81122a14:	9809883a 	mov	r4,r19
81122a18:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122a1c:	103b951e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122a20:	d8c02017 	ldw	r3,128(sp)
81122a24:	d8801f17 	ldw	r2,124(sp)
81122a28:	da000404 	addi	r8,sp,16
81122a2c:	003fee06 	br	811229e8 <__reset+0xfb1029e8>
81122a30:	9088703a 	and	r4,r18,r2
81122a34:	203e8d1e 	bne	r4,zero,8112246c <__reset+0xfb10246c>
81122a38:	dc401f17 	ldw	r17,124(sp)
81122a3c:	40800115 	stw	r2,4(r8)
81122a40:	44000015 	stw	r16,0(r8)
81122a44:	8c400044 	addi	r17,r17,1
81122a48:	d8c02015 	stw	r3,128(sp)
81122a4c:	dc401f15 	stw	r17,124(sp)
81122a50:	008001c4 	movi	r2,7
81122a54:	147f7f16 	blt	r2,r17,81122854 <__reset+0xfb102854>
81122a58:	45800204 	addi	r22,r8,8
81122a5c:	003eac06 	br	81122510 <__reset+0xfb102510>
81122a60:	d9402c17 	ldw	r5,176(sp)
81122a64:	d9801e04 	addi	r6,sp,120
81122a68:	9809883a 	mov	r4,r19
81122a6c:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122a70:	103b801e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122a74:	d8c02017 	ldw	r3,128(sp)
81122a78:	dc401f17 	ldw	r17,124(sp)
81122a7c:	da000404 	addi	r8,sp,16
81122a80:	003e8406 	br	81122494 <__reset+0xfb102494>
81122a84:	d9402c17 	ldw	r5,176(sp)
81122a88:	d9801e04 	addi	r6,sp,120
81122a8c:	9809883a 	mov	r4,r19
81122a90:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122a94:	103b771e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122a98:	d8c02017 	ldw	r3,128(sp)
81122a9c:	dc401f17 	ldw	r17,124(sp)
81122aa0:	dd800404 	addi	r22,sp,16
81122aa4:	003e8606 	br	811224c0 <__reset+0xfb1024c0>
81122aa8:	0029883a 	mov	r20,zero
81122aac:	a5000c04 	addi	r20,r20,48
81122ab0:	dc001dc4 	addi	r16,sp,119
81122ab4:	dd001dc5 	stb	r20,119(sp)
81122ab8:	003f3806 	br	8112279c <__reset+0xfb10279c>
81122abc:	d9402c17 	ldw	r5,176(sp)
81122ac0:	d9801e04 	addi	r6,sp,120
81122ac4:	9809883a 	mov	r4,r19
81122ac8:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122acc:	103b691e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122ad0:	d8c02017 	ldw	r3,128(sp)
81122ad4:	da000404 	addi	r8,sp,16
81122ad8:	003c9506 	br	81121d30 <__reset+0xfb101d30>
81122adc:	d9003617 	ldw	r4,216(sp)
81122ae0:	d9403717 	ldw	r5,220(sp)
81122ae4:	da003e15 	stw	r8,248(sp)
81122ae8:	112bf0c0 	call	8112bf0c <__fpclassifyd>
81122aec:	da003e17 	ldw	r8,248(sp)
81122af0:	1000bd1e 	bne	r2,zero,81122de8 <___svfprintf_internal_r+0x1910>
81122af4:	008011c4 	movi	r2,71
81122af8:	14411e0e 	bge	r2,r17,81122f74 <___svfprintf_internal_r+0x1a9c>
81122afc:	04204574 	movhi	r16,33045
81122b00:	8438f104 	addi	r16,r16,-7228
81122b04:	00c000c4 	movi	r3,3
81122b08:	00bfdfc4 	movi	r2,-129
81122b0c:	d8c02a15 	stw	r3,168(sp)
81122b10:	90a4703a 	and	r18,r18,r2
81122b14:	df002783 	ldbu	fp,158(sp)
81122b18:	d8c02e15 	stw	r3,184(sp)
81122b1c:	d8002915 	stw	zero,164(sp)
81122b20:	d8003215 	stw	zero,200(sp)
81122b24:	003c1c06 	br	81121b98 <__reset+0xfb101b98>
81122b28:	9080100c 	andi	r2,r18,64
81122b2c:	d8002785 	stb	zero,158(sp)
81122b30:	10009426 	beq	r2,zero,81122d84 <___svfprintf_internal_r+0x18ac>
81122b34:	d8c02d17 	ldw	r3,180(sp)
81122b38:	d9002917 	ldw	r4,164(sp)
81122b3c:	002d883a 	mov	r22,zero
81122b40:	18800104 	addi	r2,r3,4
81122b44:	1d00000b 	ldhu	r20,0(r3)
81122b48:	203ec10e 	bge	r4,zero,81122650 <__reset+0xfb102650>
81122b4c:	a586b03a 	or	r3,r20,r22
81122b50:	d8802d15 	stw	r2,180(sp)
81122b54:	183ec21e 	bne	r3,zero,81122660 <__reset+0xfb102660>
81122b58:	0039883a 	mov	fp,zero
81122b5c:	0005883a 	mov	r2,zero
81122b60:	003db806 	br	81122244 <__reset+0xfb102244>
81122b64:	d8802d17 	ldw	r2,180(sp)
81122b68:	d8c02d17 	ldw	r3,180(sp)
81122b6c:	d9002d17 	ldw	r4,180(sp)
81122b70:	10800017 	ldw	r2,0(r2)
81122b74:	18c00117 	ldw	r3,4(r3)
81122b78:	21000204 	addi	r4,r4,8
81122b7c:	d8803615 	stw	r2,216(sp)
81122b80:	d8c03715 	stw	r3,220(sp)
81122b84:	d9002d15 	stw	r4,180(sp)
81122b88:	003b8206 	br	81121994 <__reset+0xfb101994>
81122b8c:	9080100c 	andi	r2,r18,64
81122b90:	10010726 	beq	r2,zero,81122fb0 <___svfprintf_internal_r+0x1ad8>
81122b94:	d8c02d17 	ldw	r3,180(sp)
81122b98:	1d00000f 	ldh	r20,0(r3)
81122b9c:	18c00104 	addi	r3,r3,4
81122ba0:	d8c02d15 	stw	r3,180(sp)
81122ba4:	a02dd7fa 	srai	r22,r20,31
81122ba8:	b005883a 	mov	r2,r22
81122bac:	003ba206 	br	81121a38 <__reset+0xfb101a38>
81122bb0:	9080100c 	andi	r2,r18,64
81122bb4:	10010526 	beq	r2,zero,81122fcc <___svfprintf_internal_r+0x1af4>
81122bb8:	d9002d17 	ldw	r4,180(sp)
81122bbc:	002d883a 	mov	r22,zero
81122bc0:	2500000b 	ldhu	r20,0(r4)
81122bc4:	21000104 	addi	r4,r4,4
81122bc8:	d9002d15 	stw	r4,180(sp)
81122bcc:	003cfe06 	br	81121fc8 <__reset+0xfb101fc8>
81122bd0:	bc400007 	ldb	r17,0(r23)
81122bd4:	003a9606 	br	81121630 <__reset+0xfb101630>
81122bd8:	9080040c 	andi	r2,r18,16
81122bdc:	10010126 	beq	r2,zero,81122fe4 <___svfprintf_internal_r+0x1b0c>
81122be0:	d9402d17 	ldw	r5,180(sp)
81122be4:	d8c02f17 	ldw	r3,188(sp)
81122be8:	28800017 	ldw	r2,0(r5)
81122bec:	29400104 	addi	r5,r5,4
81122bf0:	d9402d15 	stw	r5,180(sp)
81122bf4:	10c00015 	stw	r3,0(r2)
81122bf8:	003a6406 	br	8112158c <__reset+0xfb10158c>
81122bfc:	d9002917 	ldw	r4,164(sp)
81122c00:	d8002785 	stb	zero,158(sp)
81122c04:	203d8d16 	blt	r4,zero,8112223c <__reset+0xfb10223c>
81122c08:	00bfdfc4 	movi	r2,-129
81122c0c:	90a4703a 	and	r18,r18,r2
81122c10:	003b0506 	br	81121828 <__reset+0xfb101828>
81122c14:	01604574 	movhi	r5,33045
81122c18:	2978fe84 	addi	r5,r5,-7174
81122c1c:	d9402b15 	stw	r5,172(sp)
81122c20:	d9402b17 	ldw	r5,172(sp)
81122c24:	1c47883a 	add	r3,r3,r17
81122c28:	10800044 	addi	r2,r2,1
81122c2c:	41400015 	stw	r5,0(r8)
81122c30:	44400115 	stw	r17,4(r8)
81122c34:	d8c02015 	stw	r3,128(sp)
81122c38:	d8801f15 	stw	r2,124(sp)
81122c3c:	010001c4 	movi	r4,7
81122c40:	20bf3016 	blt	r4,r2,81122904 <__reset+0xfb102904>
81122c44:	42000204 	addi	r8,r8,8
81122c48:	003f3506 	br	81122920 <__reset+0xfb102920>
81122c4c:	01204574 	movhi	r4,33045
81122c50:	2138fe84 	addi	r4,r4,-7174
81122c54:	d9002b15 	stw	r4,172(sp)
81122c58:	003c5e06 	br	81121dd4 <__reset+0xfb101dd4>
81122c5c:	d9402c17 	ldw	r5,176(sp)
81122c60:	d9801e04 	addi	r6,sp,120
81122c64:	9809883a 	mov	r4,r19
81122c68:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122c6c:	103b011e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122c70:	d8c02017 	ldw	r3,128(sp)
81122c74:	da000404 	addi	r8,sp,16
81122c78:	003d9306 	br	811222c8 <__reset+0xfb1022c8>
81122c7c:	d8801f17 	ldw	r2,124(sp)
81122c80:	01604574 	movhi	r5,33045
81122c84:	01000044 	movi	r4,1
81122c88:	18c00044 	addi	r3,r3,1
81122c8c:	10800044 	addi	r2,r2,1
81122c90:	2978fe04 	addi	r5,r5,-7176
81122c94:	41000115 	stw	r4,4(r8)
81122c98:	41400015 	stw	r5,0(r8)
81122c9c:	d8c02015 	stw	r3,128(sp)
81122ca0:	d8801f15 	stw	r2,124(sp)
81122ca4:	010001c4 	movi	r4,7
81122ca8:	2080b516 	blt	r4,r2,81122f80 <___svfprintf_internal_r+0x1aa8>
81122cac:	42000204 	addi	r8,r8,8
81122cb0:	8800041e 	bne	r17,zero,81122cc4 <___svfprintf_internal_r+0x17ec>
81122cb4:	d8803317 	ldw	r2,204(sp)
81122cb8:	1000021e 	bne	r2,zero,81122cc4 <___svfprintf_internal_r+0x17ec>
81122cbc:	9080004c 	andi	r2,r18,1
81122cc0:	103c5b26 	beq	r2,zero,81121e30 <__reset+0xfb101e30>
81122cc4:	d9003817 	ldw	r4,224(sp)
81122cc8:	d8801f17 	ldw	r2,124(sp)
81122ccc:	d9403417 	ldw	r5,208(sp)
81122cd0:	20c7883a 	add	r3,r4,r3
81122cd4:	10800044 	addi	r2,r2,1
81122cd8:	41000115 	stw	r4,4(r8)
81122cdc:	41400015 	stw	r5,0(r8)
81122ce0:	d8c02015 	stw	r3,128(sp)
81122ce4:	d8801f15 	stw	r2,124(sp)
81122ce8:	010001c4 	movi	r4,7
81122cec:	20818016 	blt	r4,r2,811232f0 <___svfprintf_internal_r+0x1e18>
81122cf0:	42000204 	addi	r8,r8,8
81122cf4:	0463c83a 	sub	r17,zero,r17
81122cf8:	0440cb0e 	bge	zero,r17,81123028 <___svfprintf_internal_r+0x1b50>
81122cfc:	05800404 	movi	r22,16
81122d00:	b440e80e 	bge	r22,r17,811230a4 <___svfprintf_internal_r+0x1bcc>
81122d04:	01604574 	movhi	r5,33045
81122d08:	2978fe84 	addi	r5,r5,-7174
81122d0c:	d9402b15 	stw	r5,172(sp)
81122d10:	070001c4 	movi	fp,7
81122d14:	dd002c17 	ldw	r20,176(sp)
81122d18:	00000306 	br	81122d28 <___svfprintf_internal_r+0x1850>
81122d1c:	42000204 	addi	r8,r8,8
81122d20:	8c7ffc04 	addi	r17,r17,-16
81122d24:	b440e20e 	bge	r22,r17,811230b0 <___svfprintf_internal_r+0x1bd8>
81122d28:	18c00404 	addi	r3,r3,16
81122d2c:	10800044 	addi	r2,r2,1
81122d30:	45400015 	stw	r21,0(r8)
81122d34:	45800115 	stw	r22,4(r8)
81122d38:	d8c02015 	stw	r3,128(sp)
81122d3c:	d8801f15 	stw	r2,124(sp)
81122d40:	e0bff60e 	bge	fp,r2,81122d1c <__reset+0xfb102d1c>
81122d44:	d9801e04 	addi	r6,sp,120
81122d48:	a00b883a 	mov	r5,r20
81122d4c:	9809883a 	mov	r4,r19
81122d50:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122d54:	103ac71e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122d58:	d8c02017 	ldw	r3,128(sp)
81122d5c:	d8801f17 	ldw	r2,124(sp)
81122d60:	da000404 	addi	r8,sp,16
81122d64:	003fee06 	br	81122d20 <__reset+0xfb102d20>
81122d68:	d8c02d17 	ldw	r3,180(sp)
81122d6c:	d9002917 	ldw	r4,164(sp)
81122d70:	002d883a 	mov	r22,zero
81122d74:	18800104 	addi	r2,r3,4
81122d78:	1d000017 	ldw	r20,0(r3)
81122d7c:	203e7d0e 	bge	r4,zero,81122774 <__reset+0xfb102774>
81122d80:	003eda06 	br	811228ec <__reset+0xfb1028ec>
81122d84:	d9402d17 	ldw	r5,180(sp)
81122d88:	d8c02917 	ldw	r3,164(sp)
81122d8c:	002d883a 	mov	r22,zero
81122d90:	28800104 	addi	r2,r5,4
81122d94:	2d000017 	ldw	r20,0(r5)
81122d98:	183e2d0e 	bge	r3,zero,81122650 <__reset+0xfb102650>
81122d9c:	003f6b06 	br	81122b4c <__reset+0xfb102b4c>
81122da0:	d8c02d15 	stw	r3,180(sp)
81122da4:	0039883a 	mov	fp,zero
81122da8:	003ed206 	br	811228f4 <__reset+0xfb1028f4>
81122dac:	bc400043 	ldbu	r17,1(r23)
81122db0:	94800814 	ori	r18,r18,32
81122db4:	bdc00044 	addi	r23,r23,1
81122db8:	8c403fcc 	andi	r17,r17,255
81122dbc:	8c40201c 	xori	r17,r17,128
81122dc0:	8c7fe004 	addi	r17,r17,-128
81122dc4:	003a1a06 	br	81121630 <__reset+0xfb101630>
81122dc8:	d9402c17 	ldw	r5,176(sp)
81122dcc:	d9801e04 	addi	r6,sp,120
81122dd0:	9809883a 	mov	r4,r19
81122dd4:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122dd8:	103aa61e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122ddc:	d8c02017 	ldw	r3,128(sp)
81122de0:	da000404 	addi	r8,sp,16
81122de4:	003d4a06 	br	81122310 <__reset+0xfb102310>
81122de8:	d9002917 	ldw	r4,164(sp)
81122dec:	05bff7c4 	movi	r22,-33
81122df0:	00bfffc4 	movi	r2,-1
81122df4:	8dac703a 	and	r22,r17,r22
81122df8:	20806a26 	beq	r4,r2,81122fa4 <___svfprintf_internal_r+0x1acc>
81122dfc:	008011c4 	movi	r2,71
81122e00:	b0813726 	beq	r22,r2,811232e0 <___svfprintf_internal_r+0x1e08>
81122e04:	d9003717 	ldw	r4,220(sp)
81122e08:	90c04014 	ori	r3,r18,256
81122e0c:	d8c02b15 	stw	r3,172(sp)
81122e10:	20015d16 	blt	r4,zero,81123388 <___svfprintf_internal_r+0x1eb0>
81122e14:	dd003717 	ldw	r20,220(sp)
81122e18:	d8002a05 	stb	zero,168(sp)
81122e1c:	00801984 	movi	r2,102
81122e20:	88814026 	beq	r17,r2,81123324 <___svfprintf_internal_r+0x1e4c>
81122e24:	00801184 	movi	r2,70
81122e28:	88817126 	beq	r17,r2,811233f0 <___svfprintf_internal_r+0x1f18>
81122e2c:	00801144 	movi	r2,69
81122e30:	b0816226 	beq	r22,r2,811233bc <___svfprintf_internal_r+0x1ee4>
81122e34:	d8c02917 	ldw	r3,164(sp)
81122e38:	d8802104 	addi	r2,sp,132
81122e3c:	d8800315 	stw	r2,12(sp)
81122e40:	d9403617 	ldw	r5,216(sp)
81122e44:	d8802504 	addi	r2,sp,148
81122e48:	d8800215 	stw	r2,8(sp)
81122e4c:	d8802604 	addi	r2,sp,152
81122e50:	d8c00015 	stw	r3,0(sp)
81122e54:	d8800115 	stw	r2,4(sp)
81122e58:	01c00084 	movi	r7,2
81122e5c:	a00d883a 	mov	r6,r20
81122e60:	9809883a 	mov	r4,r19
81122e64:	d8c03d15 	stw	r3,244(sp)
81122e68:	da003e15 	stw	r8,248(sp)
81122e6c:	11277c40 	call	811277c4 <_dtoa_r>
81122e70:	1021883a 	mov	r16,r2
81122e74:	008019c4 	movi	r2,103
81122e78:	d8c03d17 	ldw	r3,244(sp)
81122e7c:	da003e17 	ldw	r8,248(sp)
81122e80:	8880e726 	beq	r17,r2,81123220 <___svfprintf_internal_r+0x1d48>
81122e84:	008011c4 	movi	r2,71
81122e88:	8880d426 	beq	r17,r2,811231dc <___svfprintf_internal_r+0x1d04>
81122e8c:	80f9883a 	add	fp,r16,r3
81122e90:	d9003617 	ldw	r4,216(sp)
81122e94:	000d883a 	mov	r6,zero
81122e98:	000f883a 	mov	r7,zero
81122e9c:	a00b883a 	mov	r5,r20
81122ea0:	da003e15 	stw	r8,248(sp)
81122ea4:	11340740 	call	81134074 <__eqdf2>
81122ea8:	da003e17 	ldw	r8,248(sp)
81122eac:	1000e426 	beq	r2,zero,81123240 <___svfprintf_internal_r+0x1d68>
81122eb0:	d8802117 	ldw	r2,132(sp)
81122eb4:	1700062e 	bgeu	r2,fp,81122ed0 <___svfprintf_internal_r+0x19f8>
81122eb8:	01000c04 	movi	r4,48
81122ebc:	10c00044 	addi	r3,r2,1
81122ec0:	d8c02115 	stw	r3,132(sp)
81122ec4:	11000005 	stb	r4,0(r2)
81122ec8:	d8802117 	ldw	r2,132(sp)
81122ecc:	173ffb36 	bltu	r2,fp,81122ebc <__reset+0xfb102ebc>
81122ed0:	1405c83a 	sub	r2,r2,r16
81122ed4:	d8803315 	stw	r2,204(sp)
81122ed8:	008011c4 	movi	r2,71
81122edc:	b080c526 	beq	r22,r2,811231f4 <___svfprintf_internal_r+0x1d1c>
81122ee0:	00801944 	movi	r2,101
81122ee4:	1441d90e 	bge	r2,r17,8112364c <___svfprintf_internal_r+0x2174>
81122ee8:	d8c02617 	ldw	r3,152(sp)
81122eec:	00801984 	movi	r2,102
81122ef0:	d8c03215 	stw	r3,200(sp)
81122ef4:	88813426 	beq	r17,r2,811233c8 <___svfprintf_internal_r+0x1ef0>
81122ef8:	d8c03217 	ldw	r3,200(sp)
81122efc:	d9003317 	ldw	r4,204(sp)
81122f00:	19012516 	blt	r3,r4,81123398 <___svfprintf_internal_r+0x1ec0>
81122f04:	9480004c 	andi	r18,r18,1
81122f08:	9001841e 	bne	r18,zero,8112351c <___svfprintf_internal_r+0x2044>
81122f0c:	1805883a 	mov	r2,r3
81122f10:	1801cc16 	blt	r3,zero,81123644 <___svfprintf_internal_r+0x216c>
81122f14:	d8c03217 	ldw	r3,200(sp)
81122f18:	044019c4 	movi	r17,103
81122f1c:	d8c02e15 	stw	r3,184(sp)
81122f20:	df002a07 	ldb	fp,168(sp)
81122f24:	e000a61e 	bne	fp,zero,811231c0 <___svfprintf_internal_r+0x1ce8>
81122f28:	df002783 	ldbu	fp,158(sp)
81122f2c:	d8802a15 	stw	r2,168(sp)
81122f30:	dc802b17 	ldw	r18,172(sp)
81122f34:	d8002915 	stw	zero,164(sp)
81122f38:	003b1706 	br	81121b98 <__reset+0xfb101b98>
81122f3c:	04204574 	movhi	r16,33045
81122f40:	8438ee04 	addi	r16,r16,-7240
81122f44:	003aa606 	br	811219e0 <__reset+0xfb1019e0>
81122f48:	d9003917 	ldw	r4,228(sp)
81122f4c:	04001004 	movi	r16,64
81122f50:	800b883a 	mov	r5,r16
81122f54:	111fe980 	call	8111fe98 <_malloc_r>
81122f58:	d9002c17 	ldw	r4,176(sp)
81122f5c:	20800015 	stw	r2,0(r4)
81122f60:	20800415 	stw	r2,16(r4)
81122f64:	1001cb26 	beq	r2,zero,81123694 <___svfprintf_internal_r+0x21bc>
81122f68:	d8802c17 	ldw	r2,176(sp)
81122f6c:	14000515 	stw	r16,20(r2)
81122f70:	00397606 	br	8112154c <__reset+0xfb10154c>
81122f74:	04204574 	movhi	r16,33045
81122f78:	8438f004 	addi	r16,r16,-7232
81122f7c:	003ee106 	br	81122b04 <__reset+0xfb102b04>
81122f80:	d9402c17 	ldw	r5,176(sp)
81122f84:	d9801e04 	addi	r6,sp,120
81122f88:	9809883a 	mov	r4,r19
81122f8c:	112e0f80 	call	8112e0f8 <__ssprint_r>
81122f90:	103a381e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81122f94:	dc402617 	ldw	r17,152(sp)
81122f98:	d8c02017 	ldw	r3,128(sp)
81122f9c:	da000404 	addi	r8,sp,16
81122fa0:	003f4306 	br	81122cb0 <__reset+0xfb102cb0>
81122fa4:	01400184 	movi	r5,6
81122fa8:	d9402915 	stw	r5,164(sp)
81122fac:	003f9506 	br	81122e04 <__reset+0xfb102e04>
81122fb0:	d9002d17 	ldw	r4,180(sp)
81122fb4:	25000017 	ldw	r20,0(r4)
81122fb8:	21000104 	addi	r4,r4,4
81122fbc:	d9002d15 	stw	r4,180(sp)
81122fc0:	a02dd7fa 	srai	r22,r20,31
81122fc4:	b005883a 	mov	r2,r22
81122fc8:	003a9b06 	br	81121a38 <__reset+0xfb101a38>
81122fcc:	d9402d17 	ldw	r5,180(sp)
81122fd0:	002d883a 	mov	r22,zero
81122fd4:	2d000017 	ldw	r20,0(r5)
81122fd8:	29400104 	addi	r5,r5,4
81122fdc:	d9402d15 	stw	r5,180(sp)
81122fe0:	003bf906 	br	81121fc8 <__reset+0xfb101fc8>
81122fe4:	9480100c 	andi	r18,r18,64
81122fe8:	90006e26 	beq	r18,zero,811231a4 <___svfprintf_internal_r+0x1ccc>
81122fec:	d9002d17 	ldw	r4,180(sp)
81122ff0:	d9402f17 	ldw	r5,188(sp)
81122ff4:	20800017 	ldw	r2,0(r4)
81122ff8:	21000104 	addi	r4,r4,4
81122ffc:	d9002d15 	stw	r4,180(sp)
81123000:	1140000d 	sth	r5,0(r2)
81123004:	00396106 	br	8112158c <__reset+0xfb10158c>
81123008:	d9402c17 	ldw	r5,176(sp)
8112300c:	d9801e04 	addi	r6,sp,120
81123010:	9809883a 	mov	r4,r19
81123014:	112e0f80 	call	8112e0f8 <__ssprint_r>
81123018:	103a161e 	bne	r2,zero,81121874 <__reset+0xfb101874>
8112301c:	d8c02017 	ldw	r3,128(sp)
81123020:	d8801f17 	ldw	r2,124(sp)
81123024:	da000404 	addi	r8,sp,16
81123028:	d9403317 	ldw	r5,204(sp)
8112302c:	10800044 	addi	r2,r2,1
81123030:	44000015 	stw	r16,0(r8)
81123034:	28c7883a 	add	r3,r5,r3
81123038:	003b7706 	br	81121e18 <__reset+0xfb101e18>
8112303c:	8009883a 	mov	r4,r16
81123040:	da003e15 	stw	r8,248(sp)
81123044:	11211a00 	call	811211a0 <strlen>
81123048:	d8802e15 	stw	r2,184(sp)
8112304c:	da003e17 	ldw	r8,248(sp)
81123050:	103c280e 	bge	r2,zero,811220f4 <__reset+0xfb1020f4>
81123054:	0005883a 	mov	r2,zero
81123058:	003c2606 	br	811220f4 <__reset+0xfb1020f4>
8112305c:	00bfffc4 	movi	r2,-1
81123060:	003a0906 	br	81121888 <__reset+0xfb101888>
81123064:	01204574 	movhi	r4,33045
81123068:	21390284 	addi	r4,r4,-7158
8112306c:	d9003515 	stw	r4,212(sp)
81123070:	003b0606 	br	81121c8c <__reset+0xfb101c8c>
81123074:	013fffc4 	movi	r4,-1
81123078:	003a2706 	br	81121918 <__reset+0xfb101918>
8112307c:	d9402c17 	ldw	r5,176(sp)
81123080:	d9801e04 	addi	r6,sp,120
81123084:	9809883a 	mov	r4,r19
81123088:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112308c:	1039f91e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81123090:	d8c02017 	ldw	r3,128(sp)
81123094:	da000404 	addi	r8,sp,16
81123098:	003d8406 	br	811226ac <__reset+0xfb1026ac>
8112309c:	0023883a 	mov	r17,zero
811230a0:	003d8306 	br	811226b0 <__reset+0xfb1026b0>
811230a4:	01204574 	movhi	r4,33045
811230a8:	2138fe84 	addi	r4,r4,-7174
811230ac:	d9002b15 	stw	r4,172(sp)
811230b0:	d9002b17 	ldw	r4,172(sp)
811230b4:	1c47883a 	add	r3,r3,r17
811230b8:	10800044 	addi	r2,r2,1
811230bc:	41000015 	stw	r4,0(r8)
811230c0:	44400115 	stw	r17,4(r8)
811230c4:	d8c02015 	stw	r3,128(sp)
811230c8:	d8801f15 	stw	r2,124(sp)
811230cc:	010001c4 	movi	r4,7
811230d0:	20bfcd16 	blt	r4,r2,81123008 <__reset+0xfb103008>
811230d4:	42000204 	addi	r8,r8,8
811230d8:	003fd306 	br	81123028 <__reset+0xfb103028>
811230dc:	d9402c17 	ldw	r5,176(sp)
811230e0:	d9801e04 	addi	r6,sp,120
811230e4:	9809883a 	mov	r4,r19
811230e8:	112e0f80 	call	8112e0f8 <__ssprint_r>
811230ec:	1039e11e 	bne	r2,zero,81121874 <__reset+0xfb101874>
811230f0:	d8802617 	ldw	r2,152(sp)
811230f4:	d8c02017 	ldw	r3,128(sp)
811230f8:	da000404 	addi	r8,sp,16
811230fc:	003e1c06 	br	81122970 <__reset+0xfb102970>
81123100:	d8802917 	ldw	r2,164(sp)
81123104:	00c00184 	movi	r3,6
81123108:	1880012e 	bgeu	r3,r2,81123110 <___svfprintf_internal_r+0x1c38>
8112310c:	1805883a 	mov	r2,r3
81123110:	d8802e15 	stw	r2,184(sp)
81123114:	1000f316 	blt	r2,zero,811234e4 <___svfprintf_internal_r+0x200c>
81123118:	04204574 	movhi	r16,33045
8112311c:	d8802a15 	stw	r2,168(sp)
81123120:	dd002d15 	stw	r20,180(sp)
81123124:	d8002915 	stw	zero,164(sp)
81123128:	d8003215 	stw	zero,200(sp)
8112312c:	8438fc04 	addi	r16,r16,-7184
81123130:	0039883a 	mov	fp,zero
81123134:	003a9f06 	br	81121bb4 <__reset+0xfb101bb4>
81123138:	01204574 	movhi	r4,33045
8112313c:	21390284 	addi	r4,r4,-7158
81123140:	d9003515 	stw	r4,212(sp)
81123144:	003b5f06 	br	81121ec4 <__reset+0xfb101ec4>
81123148:	d9402c17 	ldw	r5,176(sp)
8112314c:	d9801e04 	addi	r6,sp,120
81123150:	9809883a 	mov	r4,r19
81123154:	112e0f80 	call	8112e0f8 <__ssprint_r>
81123158:	1039c61e 	bne	r2,zero,81121874 <__reset+0xfb101874>
8112315c:	d8802617 	ldw	r2,152(sp)
81123160:	d9403317 	ldw	r5,204(sp)
81123164:	d8c02017 	ldw	r3,128(sp)
81123168:	da000404 	addi	r8,sp,16
8112316c:	2885c83a 	sub	r2,r5,r2
81123170:	003e1006 	br	811229b4 <__reset+0xfb1029b4>
81123174:	00800044 	movi	r2,1
81123178:	10803fcc 	andi	r2,r2,255
8112317c:	00c00044 	movi	r3,1
81123180:	10fa3526 	beq	r2,r3,81121a58 <__reset+0xfb101a58>
81123184:	00c00084 	movi	r3,2
81123188:	10fb9e26 	beq	r2,r3,81122004 <__reset+0xfb102004>
8112318c:	003a6406 	br	81121b20 <__reset+0xfb101b20>
81123190:	0021883a 	mov	r16,zero
81123194:	003e0806 	br	811229b8 <__reset+0xfb1029b8>
81123198:	07000b44 	movi	fp,45
8112319c:	df002785 	stb	fp,158(sp)
811231a0:	003a0b06 	br	811219d0 <__reset+0xfb1019d0>
811231a4:	d8c02d17 	ldw	r3,180(sp)
811231a8:	d9002f17 	ldw	r4,188(sp)
811231ac:	18800017 	ldw	r2,0(r3)
811231b0:	18c00104 	addi	r3,r3,4
811231b4:	d8c02d15 	stw	r3,180(sp)
811231b8:	11000015 	stw	r4,0(r2)
811231bc:	0038f306 	br	8112158c <__reset+0xfb10158c>
811231c0:	00c00b44 	movi	r3,45
811231c4:	d8c02785 	stb	r3,158(sp)
811231c8:	d8802a15 	stw	r2,168(sp)
811231cc:	dc802b17 	ldw	r18,172(sp)
811231d0:	d8002915 	stw	zero,164(sp)
811231d4:	07000b44 	movi	fp,45
811231d8:	003a7306 	br	81121ba8 <__reset+0xfb101ba8>
811231dc:	9080004c 	andi	r2,r18,1
811231e0:	1000941e 	bne	r2,zero,81123434 <___svfprintf_internal_r+0x1f5c>
811231e4:	d8802117 	ldw	r2,132(sp)
811231e8:	1405c83a 	sub	r2,r2,r16
811231ec:	d8803315 	stw	r2,204(sp)
811231f0:	b441161e 	bne	r22,r17,8112364c <___svfprintf_internal_r+0x2174>
811231f4:	dd802617 	ldw	r22,152(sp)
811231f8:	00bfff44 	movi	r2,-3
811231fc:	b0801a16 	blt	r22,r2,81123268 <___svfprintf_internal_r+0x1d90>
81123200:	d9402917 	ldw	r5,164(sp)
81123204:	2d801816 	blt	r5,r22,81123268 <___svfprintf_internal_r+0x1d90>
81123208:	dd803215 	stw	r22,200(sp)
8112320c:	003f3a06 	br	81122ef8 <__reset+0xfb102ef8>
81123210:	1025883a 	mov	r18,r2
81123214:	0039883a 	mov	fp,zero
81123218:	00800084 	movi	r2,2
8112321c:	003fd606 	br	81123178 <__reset+0xfb103178>
81123220:	9080004c 	andi	r2,r18,1
81123224:	103f191e 	bne	r2,zero,81122e8c <__reset+0xfb102e8c>
81123228:	d8802117 	ldw	r2,132(sp)
8112322c:	003f2806 	br	81122ed0 <__reset+0xfb102ed0>
81123230:	01204574 	movhi	r4,33045
81123234:	2138fe84 	addi	r4,r4,-7174
81123238:	d9002b15 	stw	r4,172(sp)
8112323c:	003c7c06 	br	81122430 <__reset+0xfb102430>
81123240:	e005883a 	mov	r2,fp
81123244:	003f2206 	br	81122ed0 <__reset+0xfb102ed0>
81123248:	d9402917 	ldw	r5,164(sp)
8112324c:	df002783 	ldbu	fp,158(sp)
81123250:	dd002d15 	stw	r20,180(sp)
81123254:	d9402a15 	stw	r5,168(sp)
81123258:	d9402e15 	stw	r5,184(sp)
8112325c:	d8002915 	stw	zero,164(sp)
81123260:	d8003215 	stw	zero,200(sp)
81123264:	003a4c06 	br	81121b98 <__reset+0xfb101b98>
81123268:	8c7fff84 	addi	r17,r17,-2
8112326c:	b5bfffc4 	addi	r22,r22,-1
81123270:	dd802615 	stw	r22,152(sp)
81123274:	dc4022c5 	stb	r17,139(sp)
81123278:	b000c316 	blt	r22,zero,81123588 <___svfprintf_internal_r+0x20b0>
8112327c:	00800ac4 	movi	r2,43
81123280:	d8802305 	stb	r2,140(sp)
81123284:	00800244 	movi	r2,9
81123288:	15806e16 	blt	r2,r22,81123444 <___svfprintf_internal_r+0x1f6c>
8112328c:	00800c04 	movi	r2,48
81123290:	b5800c04 	addi	r22,r22,48
81123294:	d8802345 	stb	r2,141(sp)
81123298:	dd802385 	stb	r22,142(sp)
8112329c:	d88023c4 	addi	r2,sp,143
811232a0:	df0022c4 	addi	fp,sp,139
811232a4:	d8c03317 	ldw	r3,204(sp)
811232a8:	1739c83a 	sub	fp,r2,fp
811232ac:	d9003317 	ldw	r4,204(sp)
811232b0:	e0c7883a 	add	r3,fp,r3
811232b4:	df003b15 	stw	fp,236(sp)
811232b8:	d8c02e15 	stw	r3,184(sp)
811232bc:	00800044 	movi	r2,1
811232c0:	1100b70e 	bge	r2,r4,811235a0 <___svfprintf_internal_r+0x20c8>
811232c4:	d8c02e17 	ldw	r3,184(sp)
811232c8:	18c00044 	addi	r3,r3,1
811232cc:	d8c02e15 	stw	r3,184(sp)
811232d0:	1805883a 	mov	r2,r3
811232d4:	1800b016 	blt	r3,zero,81123598 <___svfprintf_internal_r+0x20c0>
811232d8:	d8003215 	stw	zero,200(sp)
811232dc:	003f1006 	br	81122f20 <__reset+0xfb102f20>
811232e0:	d8802917 	ldw	r2,164(sp)
811232e4:	103ec71e 	bne	r2,zero,81122e04 <__reset+0xfb102e04>
811232e8:	dc002915 	stw	r16,164(sp)
811232ec:	003ec506 	br	81122e04 <__reset+0xfb102e04>
811232f0:	d9402c17 	ldw	r5,176(sp)
811232f4:	d9801e04 	addi	r6,sp,120
811232f8:	9809883a 	mov	r4,r19
811232fc:	112e0f80 	call	8112e0f8 <__ssprint_r>
81123300:	10395c1e 	bne	r2,zero,81121874 <__reset+0xfb101874>
81123304:	dc402617 	ldw	r17,152(sp)
81123308:	d8c02017 	ldw	r3,128(sp)
8112330c:	d8801f17 	ldw	r2,124(sp)
81123310:	da000404 	addi	r8,sp,16
81123314:	003e7706 	br	81122cf4 <__reset+0xfb102cf4>
81123318:	582f883a 	mov	r23,r11
8112331c:	d8002915 	stw	zero,164(sp)
81123320:	0038c406 	br	81121634 <__reset+0xfb101634>
81123324:	d8c02917 	ldw	r3,164(sp)
81123328:	d8802104 	addi	r2,sp,132
8112332c:	d8800315 	stw	r2,12(sp)
81123330:	d9403617 	ldw	r5,216(sp)
81123334:	d8802504 	addi	r2,sp,148
81123338:	d8800215 	stw	r2,8(sp)
8112333c:	d8802604 	addi	r2,sp,152
81123340:	d8c00015 	stw	r3,0(sp)
81123344:	9809883a 	mov	r4,r19
81123348:	d8800115 	stw	r2,4(sp)
8112334c:	01c000c4 	movi	r7,3
81123350:	a00d883a 	mov	r6,r20
81123354:	da003e15 	stw	r8,248(sp)
81123358:	11277c40 	call	811277c4 <_dtoa_r>
8112335c:	d9002917 	ldw	r4,164(sp)
81123360:	da003e17 	ldw	r8,248(sp)
81123364:	1021883a 	mov	r16,r2
81123368:	1139883a 	add	fp,r2,r4
8112336c:	2007883a 	mov	r3,r4
81123370:	81000007 	ldb	r4,0(r16)
81123374:	00800c04 	movi	r2,48
81123378:	20806f26 	beq	r4,r2,81123538 <___svfprintf_internal_r+0x2060>
8112337c:	d8c02617 	ldw	r3,152(sp)
81123380:	e0f9883a 	add	fp,fp,r3
81123384:	003ec206 	br	81122e90 <__reset+0xfb102e90>
81123388:	00c00b44 	movi	r3,45
8112338c:	2520003c 	xorhi	r20,r4,32768
81123390:	d8c02a05 	stb	r3,168(sp)
81123394:	003ea106 	br	81122e1c <__reset+0xfb102e1c>
81123398:	d8c03217 	ldw	r3,200(sp)
8112339c:	00c0890e 	bge	zero,r3,811235c4 <___svfprintf_internal_r+0x20ec>
811233a0:	00800044 	movi	r2,1
811233a4:	d9003317 	ldw	r4,204(sp)
811233a8:	1105883a 	add	r2,r2,r4
811233ac:	d8802e15 	stw	r2,184(sp)
811233b0:	10005f16 	blt	r2,zero,81123530 <___svfprintf_internal_r+0x2058>
811233b4:	044019c4 	movi	r17,103
811233b8:	003ed906 	br	81122f20 <__reset+0xfb102f20>
811233bc:	d9002917 	ldw	r4,164(sp)
811233c0:	20c00044 	addi	r3,r4,1
811233c4:	003e9c06 	br	81122e38 <__reset+0xfb102e38>
811233c8:	d9002917 	ldw	r4,164(sp)
811233cc:	00c0680e 	bge	zero,r3,81123570 <___svfprintf_internal_r+0x2098>
811233d0:	2000461e 	bne	r4,zero,811234ec <___svfprintf_internal_r+0x2014>
811233d4:	9480004c 	andi	r18,r18,1
811233d8:	9000441e 	bne	r18,zero,811234ec <___svfprintf_internal_r+0x2014>
811233dc:	1805883a 	mov	r2,r3
811233e0:	1800a016 	blt	r3,zero,81123664 <___svfprintf_internal_r+0x218c>
811233e4:	d8c03217 	ldw	r3,200(sp)
811233e8:	d8c02e15 	stw	r3,184(sp)
811233ec:	003ecc06 	br	81122f20 <__reset+0xfb102f20>
811233f0:	d9402917 	ldw	r5,164(sp)
811233f4:	d8802104 	addi	r2,sp,132
811233f8:	d8800315 	stw	r2,12(sp)
811233fc:	d9400015 	stw	r5,0(sp)
81123400:	d8802504 	addi	r2,sp,148
81123404:	d9403617 	ldw	r5,216(sp)
81123408:	d8800215 	stw	r2,8(sp)
8112340c:	d8802604 	addi	r2,sp,152
81123410:	d8800115 	stw	r2,4(sp)
81123414:	01c000c4 	movi	r7,3
81123418:	a00d883a 	mov	r6,r20
8112341c:	9809883a 	mov	r4,r19
81123420:	da003e15 	stw	r8,248(sp)
81123424:	11277c40 	call	811277c4 <_dtoa_r>
81123428:	d8c02917 	ldw	r3,164(sp)
8112342c:	da003e17 	ldw	r8,248(sp)
81123430:	1021883a 	mov	r16,r2
81123434:	00801184 	movi	r2,70
81123438:	80f9883a 	add	fp,r16,r3
8112343c:	88bfcc26 	beq	r17,r2,81123370 <__reset+0xfb103370>
81123440:	003e9306 	br	81122e90 <__reset+0xfb102e90>
81123444:	df0022c4 	addi	fp,sp,139
81123448:	dc002915 	stw	r16,164(sp)
8112344c:	9829883a 	mov	r20,r19
81123450:	e021883a 	mov	r16,fp
81123454:	4027883a 	mov	r19,r8
81123458:	b009883a 	mov	r4,r22
8112345c:	01400284 	movi	r5,10
81123460:	1132ba40 	call	81132ba4 <__modsi3>
81123464:	10800c04 	addi	r2,r2,48
81123468:	843fffc4 	addi	r16,r16,-1
8112346c:	b009883a 	mov	r4,r22
81123470:	01400284 	movi	r5,10
81123474:	80800005 	stb	r2,0(r16)
81123478:	1132b200 	call	81132b20 <__divsi3>
8112347c:	102d883a 	mov	r22,r2
81123480:	00800244 	movi	r2,9
81123484:	15bff416 	blt	r2,r22,81123458 <__reset+0xfb103458>
81123488:	9811883a 	mov	r8,r19
8112348c:	b0800c04 	addi	r2,r22,48
81123490:	a027883a 	mov	r19,r20
81123494:	8029883a 	mov	r20,r16
81123498:	a17fffc4 	addi	r5,r20,-1
8112349c:	a0bfffc5 	stb	r2,-1(r20)
811234a0:	dc002917 	ldw	r16,164(sp)
811234a4:	2f00752e 	bgeu	r5,fp,8112367c <___svfprintf_internal_r+0x21a4>
811234a8:	d9c02384 	addi	r7,sp,142
811234ac:	3d0fc83a 	sub	r7,r7,r20
811234b0:	d9002344 	addi	r4,sp,141
811234b4:	e1cf883a 	add	r7,fp,r7
811234b8:	00000106 	br	811234c0 <___svfprintf_internal_r+0x1fe8>
811234bc:	28800003 	ldbu	r2,0(r5)
811234c0:	20800005 	stb	r2,0(r4)
811234c4:	21000044 	addi	r4,r4,1
811234c8:	29400044 	addi	r5,r5,1
811234cc:	21fffb1e 	bne	r4,r7,811234bc <__reset+0xfb1034bc>
811234d0:	d8802304 	addi	r2,sp,140
811234d4:	1505c83a 	sub	r2,r2,r20
811234d8:	d8c02344 	addi	r3,sp,141
811234dc:	1885883a 	add	r2,r3,r2
811234e0:	003f7006 	br	811232a4 <__reset+0xfb1032a4>
811234e4:	0005883a 	mov	r2,zero
811234e8:	003f0b06 	br	81123118 <__reset+0xfb103118>
811234ec:	d9002917 	ldw	r4,164(sp)
811234f0:	d8c03217 	ldw	r3,200(sp)
811234f4:	20800044 	addi	r2,r4,1
811234f8:	1885883a 	add	r2,r3,r2
811234fc:	d8802e15 	stw	r2,184(sp)
81123500:	103e870e 	bge	r2,zero,81122f20 <__reset+0xfb102f20>
81123504:	0005883a 	mov	r2,zero
81123508:	003e8506 	br	81122f20 <__reset+0xfb102f20>
8112350c:	01204574 	movhi	r4,33045
81123510:	2138fe84 	addi	r4,r4,-7174
81123514:	d9002b15 	stw	r4,172(sp)
81123518:	003cc506 	br	81122830 <__reset+0xfb102830>
8112351c:	d8c03217 	ldw	r3,200(sp)
81123520:	18c00044 	addi	r3,r3,1
81123524:	d8c02e15 	stw	r3,184(sp)
81123528:	1805883a 	mov	r2,r3
8112352c:	183fa10e 	bge	r3,zero,811233b4 <__reset+0xfb1033b4>
81123530:	0005883a 	mov	r2,zero
81123534:	003f9f06 	br	811233b4 <__reset+0xfb1033b4>
81123538:	d9003617 	ldw	r4,216(sp)
8112353c:	000d883a 	mov	r6,zero
81123540:	000f883a 	mov	r7,zero
81123544:	a00b883a 	mov	r5,r20
81123548:	d8c03d15 	stw	r3,244(sp)
8112354c:	da003e15 	stw	r8,248(sp)
81123550:	11340740 	call	81134074 <__eqdf2>
81123554:	d8c03d17 	ldw	r3,244(sp)
81123558:	da003e17 	ldw	r8,248(sp)
8112355c:	103f8726 	beq	r2,zero,8112337c <__reset+0xfb10337c>
81123560:	00800044 	movi	r2,1
81123564:	10c7c83a 	sub	r3,r2,r3
81123568:	d8c02615 	stw	r3,152(sp)
8112356c:	003f8406 	br	81123380 <__reset+0xfb103380>
81123570:	20000e1e 	bne	r4,zero,811235ac <___svfprintf_internal_r+0x20d4>
81123574:	9480004c 	andi	r18,r18,1
81123578:	90000c1e 	bne	r18,zero,811235ac <___svfprintf_internal_r+0x20d4>
8112357c:	00800044 	movi	r2,1
81123580:	d8802e15 	stw	r2,184(sp)
81123584:	003e6606 	br	81122f20 <__reset+0xfb102f20>
81123588:	00800b44 	movi	r2,45
8112358c:	05adc83a 	sub	r22,zero,r22
81123590:	d8802305 	stb	r2,140(sp)
81123594:	003f3b06 	br	81123284 <__reset+0xfb103284>
81123598:	0005883a 	mov	r2,zero
8112359c:	003f4e06 	br	811232d8 <__reset+0xfb1032d8>
811235a0:	90a4703a 	and	r18,r18,r2
811235a4:	903f4a26 	beq	r18,zero,811232d0 <__reset+0xfb1032d0>
811235a8:	003f4606 	br	811232c4 <__reset+0xfb1032c4>
811235ac:	d8c02917 	ldw	r3,164(sp)
811235b0:	18c00084 	addi	r3,r3,2
811235b4:	d8c02e15 	stw	r3,184(sp)
811235b8:	1805883a 	mov	r2,r3
811235bc:	183e580e 	bge	r3,zero,81122f20 <__reset+0xfb102f20>
811235c0:	003fd006 	br	81123504 <__reset+0xfb103504>
811235c4:	00800084 	movi	r2,2
811235c8:	10c5c83a 	sub	r2,r2,r3
811235cc:	003f7506 	br	811233a4 <__reset+0xfb1033a4>
811235d0:	d8802d17 	ldw	r2,180(sp)
811235d4:	d9002d17 	ldw	r4,180(sp)
811235d8:	bc400043 	ldbu	r17,1(r23)
811235dc:	10800017 	ldw	r2,0(r2)
811235e0:	582f883a 	mov	r23,r11
811235e4:	d8802915 	stw	r2,164(sp)
811235e8:	20800104 	addi	r2,r4,4
811235ec:	d9002917 	ldw	r4,164(sp)
811235f0:	d8802d15 	stw	r2,180(sp)
811235f4:	203df00e 	bge	r4,zero,81122db8 <__reset+0xfb102db8>
811235f8:	8c403fcc 	andi	r17,r17,255
811235fc:	00bfffc4 	movi	r2,-1
81123600:	8c40201c 	xori	r17,r17,128
81123604:	d8802915 	stw	r2,164(sp)
81123608:	8c7fe004 	addi	r17,r17,-128
8112360c:	00380806 	br	81121630 <__reset+0xfb101630>
81123610:	9080004c 	andi	r2,r18,1
81123614:	0039883a 	mov	fp,zero
81123618:	10000726 	beq	r2,zero,81123638 <___svfprintf_internal_r+0x2160>
8112361c:	d8c02817 	ldw	r3,160(sp)
81123620:	dc001dc4 	addi	r16,sp,119
81123624:	00800c04 	movi	r2,48
81123628:	1c07c83a 	sub	r3,r3,r16
8112362c:	d8801dc5 	stb	r2,119(sp)
81123630:	d8c02e15 	stw	r3,184(sp)
81123634:	00395206 	br	81121b80 <__reset+0xfb101b80>
81123638:	d8002e15 	stw	zero,184(sp)
8112363c:	dc001e04 	addi	r16,sp,120
81123640:	00394f06 	br	81121b80 <__reset+0xfb101b80>
81123644:	0005883a 	mov	r2,zero
81123648:	003e3206 	br	81122f14 <__reset+0xfb102f14>
8112364c:	dd802617 	ldw	r22,152(sp)
81123650:	003f0606 	br	8112326c <__reset+0xfb10326c>
81123654:	d9c02785 	stb	r7,158(sp)
81123658:	003a5106 	br	81121fa0 <__reset+0xfb101fa0>
8112365c:	d9c02785 	stb	r7,158(sp)
81123660:	003a3706 	br	81121f40 <__reset+0xfb101f40>
81123664:	0005883a 	mov	r2,zero
81123668:	003f5e06 	br	811233e4 <__reset+0xfb1033e4>
8112366c:	d9c02785 	stb	r7,158(sp)
81123670:	00391706 	br	81121ad0 <__reset+0xfb101ad0>
81123674:	d9c02785 	stb	r7,158(sp)
81123678:	0038e606 	br	81121a14 <__reset+0xfb101a14>
8112367c:	d8802344 	addi	r2,sp,141
81123680:	003f0806 	br	811232a4 <__reset+0xfb1032a4>
81123684:	d9c02785 	stb	r7,158(sp)
81123688:	0038b706 	br	81121968 <__reset+0xfb101968>
8112368c:	d9c02785 	stb	r7,158(sp)
81123690:	003adc06 	br	81122204 <__reset+0xfb102204>
81123694:	d9403917 	ldw	r5,228(sp)
81123698:	00800304 	movi	r2,12
8112369c:	28800015 	stw	r2,0(r5)
811236a0:	00bfffc4 	movi	r2,-1
811236a4:	00387806 	br	81121888 <__reset+0xfb101888>
811236a8:	d9c02785 	stb	r7,158(sp)
811236ac:	003abf06 	br	811221ac <__reset+0xfb1021ac>
811236b0:	d9c02785 	stb	r7,158(sp)
811236b4:	003a9b06 	br	81122124 <__reset+0xfb102124>

811236b8 <___vfprintf_internal_r>:
811236b8:	deffb804 	addi	sp,sp,-288
811236bc:	de00012e 	bgeu	sp,et,811236c4 <___vfprintf_internal_r+0xc>
811236c0:	003b68fa 	trap	3
811236c4:	dfc04715 	stw	ra,284(sp)
811236c8:	ddc04515 	stw	r23,276(sp)
811236cc:	dd404315 	stw	r21,268(sp)
811236d0:	d9002c15 	stw	r4,176(sp)
811236d4:	282f883a 	mov	r23,r5
811236d8:	302b883a 	mov	r21,r6
811236dc:	d9c02d15 	stw	r7,180(sp)
811236e0:	df004615 	stw	fp,280(sp)
811236e4:	dd804415 	stw	r22,272(sp)
811236e8:	dd004215 	stw	r20,264(sp)
811236ec:	dcc04115 	stw	r19,260(sp)
811236f0:	dc804015 	stw	r18,256(sp)
811236f4:	dc403f15 	stw	r17,252(sp)
811236f8:	dc003e15 	stw	r16,248(sp)
811236fc:	112a3c00 	call	8112a3c0 <_localeconv_r>
81123700:	10800017 	ldw	r2,0(r2)
81123704:	1009883a 	mov	r4,r2
81123708:	d8803415 	stw	r2,208(sp)
8112370c:	11211a00 	call	811211a0 <strlen>
81123710:	d8803715 	stw	r2,220(sp)
81123714:	d8802c17 	ldw	r2,176(sp)
81123718:	10000226 	beq	r2,zero,81123724 <___vfprintf_internal_r+0x6c>
8112371c:	10800e17 	ldw	r2,56(r2)
81123720:	1000f926 	beq	r2,zero,81123b08 <___vfprintf_internal_r+0x450>
81123724:	b880030b 	ldhu	r2,12(r23)
81123728:	10c8000c 	andi	r3,r2,8192
8112372c:	1800061e 	bne	r3,zero,81123748 <___vfprintf_internal_r+0x90>
81123730:	b9001917 	ldw	r4,100(r23)
81123734:	00f7ffc4 	movi	r3,-8193
81123738:	10880014 	ori	r2,r2,8192
8112373c:	20c6703a 	and	r3,r4,r3
81123740:	b880030d 	sth	r2,12(r23)
81123744:	b8c01915 	stw	r3,100(r23)
81123748:	10c0020c 	andi	r3,r2,8
8112374c:	1800c126 	beq	r3,zero,81123a54 <___vfprintf_internal_r+0x39c>
81123750:	b8c00417 	ldw	r3,16(r23)
81123754:	1800bf26 	beq	r3,zero,81123a54 <___vfprintf_internal_r+0x39c>
81123758:	1080068c 	andi	r2,r2,26
8112375c:	00c00284 	movi	r3,10
81123760:	10c0c426 	beq	r2,r3,81123a74 <___vfprintf_internal_r+0x3bc>
81123764:	d8c00404 	addi	r3,sp,16
81123768:	05204574 	movhi	r20,33045
8112376c:	d9001e04 	addi	r4,sp,120
81123770:	a5390684 	addi	r20,r20,-7142
81123774:	d8c01e15 	stw	r3,120(sp)
81123778:	d8002015 	stw	zero,128(sp)
8112377c:	d8001f15 	stw	zero,124(sp)
81123780:	d8003315 	stw	zero,204(sp)
81123784:	d8003615 	stw	zero,216(sp)
81123788:	d8003815 	stw	zero,224(sp)
8112378c:	1811883a 	mov	r8,r3
81123790:	d8003915 	stw	zero,228(sp)
81123794:	d8003a15 	stw	zero,232(sp)
81123798:	d8002f15 	stw	zero,188(sp)
8112379c:	d9002815 	stw	r4,160(sp)
811237a0:	a8800007 	ldb	r2,0(r21)
811237a4:	10027b26 	beq	r2,zero,81124194 <___vfprintf_internal_r+0xadc>
811237a8:	00c00944 	movi	r3,37
811237ac:	a821883a 	mov	r16,r21
811237b0:	10c0021e 	bne	r2,r3,811237bc <___vfprintf_internal_r+0x104>
811237b4:	00001406 	br	81123808 <___vfprintf_internal_r+0x150>
811237b8:	10c00326 	beq	r2,r3,811237c8 <___vfprintf_internal_r+0x110>
811237bc:	84000044 	addi	r16,r16,1
811237c0:	80800007 	ldb	r2,0(r16)
811237c4:	103ffc1e 	bne	r2,zero,811237b8 <__reset+0xfb1037b8>
811237c8:	8563c83a 	sub	r17,r16,r21
811237cc:	88000e26 	beq	r17,zero,81123808 <___vfprintf_internal_r+0x150>
811237d0:	d8c02017 	ldw	r3,128(sp)
811237d4:	d8801f17 	ldw	r2,124(sp)
811237d8:	45400015 	stw	r21,0(r8)
811237dc:	1c47883a 	add	r3,r3,r17
811237e0:	10800044 	addi	r2,r2,1
811237e4:	d8c02015 	stw	r3,128(sp)
811237e8:	44400115 	stw	r17,4(r8)
811237ec:	d8801f15 	stw	r2,124(sp)
811237f0:	00c001c4 	movi	r3,7
811237f4:	1880a716 	blt	r3,r2,81123a94 <___vfprintf_internal_r+0x3dc>
811237f8:	42000204 	addi	r8,r8,8
811237fc:	d9402f17 	ldw	r5,188(sp)
81123800:	2c4b883a 	add	r5,r5,r17
81123804:	d9402f15 	stw	r5,188(sp)
81123808:	80800007 	ldb	r2,0(r16)
8112380c:	1000a826 	beq	r2,zero,81123ab0 <___vfprintf_internal_r+0x3f8>
81123810:	84400047 	ldb	r17,1(r16)
81123814:	00bfffc4 	movi	r2,-1
81123818:	85400044 	addi	r21,r16,1
8112381c:	d8002785 	stb	zero,158(sp)
81123820:	0007883a 	mov	r3,zero
81123824:	000f883a 	mov	r7,zero
81123828:	d8802915 	stw	r2,164(sp)
8112382c:	d8003115 	stw	zero,196(sp)
81123830:	0025883a 	mov	r18,zero
81123834:	01401604 	movi	r5,88
81123838:	01800244 	movi	r6,9
8112383c:	02800a84 	movi	r10,42
81123840:	02401b04 	movi	r9,108
81123844:	ad400044 	addi	r21,r21,1
81123848:	88bff804 	addi	r2,r17,-32
8112384c:	28830436 	bltu	r5,r2,81124460 <___vfprintf_internal_r+0xda8>
81123850:	100490ba 	slli	r2,r2,2
81123854:	012044b4 	movhi	r4,33042
81123858:	210e1a04 	addi	r4,r4,14440
8112385c:	1105883a 	add	r2,r2,r4
81123860:	10800017 	ldw	r2,0(r2)
81123864:	1000683a 	jmp	r2
81123868:	81124380 	call	88112438 <__reset+0x20f2438>
8112386c:	81124460 	cmpeqi	r4,r16,18705
81123870:	81124460 	cmpeqi	r4,r16,18705
81123874:	811243a0 	cmpeqi	r4,r16,18702
81123878:	81124460 	cmpeqi	r4,r16,18705
8112387c:	81124460 	cmpeqi	r4,r16,18705
81123880:	81124460 	cmpeqi	r4,r16,18705
81123884:	81124460 	cmpeqi	r4,r16,18705
81123888:	81124460 	cmpeqi	r4,r16,18705
8112388c:	81124460 	cmpeqi	r4,r16,18705
81123890:	81123b14 	ori	r4,r16,18668
81123894:	811242bc 	xorhi	r4,r16,18698
81123898:	81124460 	cmpeqi	r4,r16,18705
8112389c:	811239dc 	xori	r4,r16,18663
811238a0:	81123b3c 	xorhi	r4,r16,18668
811238a4:	81124460 	cmpeqi	r4,r16,18705
811238a8:	81123b7c 	xorhi	r4,r16,18669
811238ac:	81123b88 	cmpgei	r4,r16,18670
811238b0:	81123b88 	cmpgei	r4,r16,18670
811238b4:	81123b88 	cmpgei	r4,r16,18670
811238b8:	81123b88 	cmpgei	r4,r16,18670
811238bc:	81123b88 	cmpgei	r4,r16,18670
811238c0:	81123b88 	cmpgei	r4,r16,18670
811238c4:	81123b88 	cmpgei	r4,r16,18670
811238c8:	81123b88 	cmpgei	r4,r16,18670
811238cc:	81123b88 	cmpgei	r4,r16,18670
811238d0:	81124460 	cmpeqi	r4,r16,18705
811238d4:	81124460 	cmpeqi	r4,r16,18705
811238d8:	81124460 	cmpeqi	r4,r16,18705
811238dc:	81124460 	cmpeqi	r4,r16,18705
811238e0:	81124460 	cmpeqi	r4,r16,18705
811238e4:	81124460 	cmpeqi	r4,r16,18705
811238e8:	81124460 	cmpeqi	r4,r16,18705
811238ec:	81124460 	cmpeqi	r4,r16,18705
811238f0:	81124460 	cmpeqi	r4,r16,18705
811238f4:	81124460 	cmpeqi	r4,r16,18705
811238f8:	81123bbc 	xorhi	r4,r16,18670
811238fc:	81123c78 	rdprs	r4,r16,18673
81123900:	81124460 	cmpeqi	r4,r16,18705
81123904:	81123c78 	rdprs	r4,r16,18673
81123908:	81124460 	cmpeqi	r4,r16,18705
8112390c:	81124460 	cmpeqi	r4,r16,18705
81123910:	81124460 	cmpeqi	r4,r16,18705
81123914:	81124460 	cmpeqi	r4,r16,18705
81123918:	81123d18 	cmpnei	r4,r16,18676
8112391c:	81124460 	cmpeqi	r4,r16,18705
81123920:	81124460 	cmpeqi	r4,r16,18705
81123924:	81123d24 	muli	r4,r16,18676
81123928:	81124460 	cmpeqi	r4,r16,18705
8112392c:	81124460 	cmpeqi	r4,r16,18705
81123930:	81124460 	cmpeqi	r4,r16,18705
81123934:	81124460 	cmpeqi	r4,r16,18705
81123938:	81124460 	cmpeqi	r4,r16,18705
8112393c:	8112419c 	xori	r4,r16,18694
81123940:	81124460 	cmpeqi	r4,r16,18705
81123944:	81124460 	cmpeqi	r4,r16,18705
81123948:	811241fc 	xorhi	r4,r16,18695
8112394c:	81124460 	cmpeqi	r4,r16,18705
81123950:	81124460 	cmpeqi	r4,r16,18705
81123954:	81124460 	cmpeqi	r4,r16,18705
81123958:	81124460 	cmpeqi	r4,r16,18705
8112395c:	81124460 	cmpeqi	r4,r16,18705
81123960:	81124460 	cmpeqi	r4,r16,18705
81123964:	81124460 	cmpeqi	r4,r16,18705
81123968:	81124460 	cmpeqi	r4,r16,18705
8112396c:	81124460 	cmpeqi	r4,r16,18705
81123970:	81124460 	cmpeqi	r4,r16,18705
81123974:	8112440c 	andi	r4,r16,18704
81123978:	811243ac 	andhi	r4,r16,18702
8112397c:	81123c78 	rdprs	r4,r16,18673
81123980:	81123c78 	rdprs	r4,r16,18673
81123984:	81123c78 	rdprs	r4,r16,18673
81123988:	811243bc 	xorhi	r4,r16,18702
8112398c:	811243ac 	andhi	r4,r16,18702
81123990:	81124460 	cmpeqi	r4,r16,18705
81123994:	81124460 	cmpeqi	r4,r16,18705
81123998:	811243c8 	cmpgei	r4,r16,18703
8112399c:	81124460 	cmpeqi	r4,r16,18705
811239a0:	811243d8 	cmpnei	r4,r16,18703
811239a4:	811242ac 	andhi	r4,r16,18698
811239a8:	811239e8 	cmpgeui	r4,r16,18663
811239ac:	811242cc 	andi	r4,r16,18699
811239b0:	81124460 	cmpeqi	r4,r16,18705
811239b4:	811242d8 	cmpnei	r4,r16,18699
811239b8:	81124460 	cmpeqi	r4,r16,18705
811239bc:	81124334 	orhi	r4,r16,18700
811239c0:	81124460 	cmpeqi	r4,r16,18705
811239c4:	81124460 	cmpeqi	r4,r16,18705
811239c8:	81124344 	addi	r4,r16,18701
811239cc:	d9003117 	ldw	r4,196(sp)
811239d0:	d8802d15 	stw	r2,180(sp)
811239d4:	0109c83a 	sub	r4,zero,r4
811239d8:	d9003115 	stw	r4,196(sp)
811239dc:	94800114 	ori	r18,r18,4
811239e0:	ac400007 	ldb	r17,0(r21)
811239e4:	003f9706 	br	81123844 <__reset+0xfb103844>
811239e8:	00800c04 	movi	r2,48
811239ec:	d9002d17 	ldw	r4,180(sp)
811239f0:	d9402917 	ldw	r5,164(sp)
811239f4:	d8802705 	stb	r2,156(sp)
811239f8:	00801e04 	movi	r2,120
811239fc:	d8802745 	stb	r2,157(sp)
81123a00:	d8002785 	stb	zero,158(sp)
81123a04:	20c00104 	addi	r3,r4,4
81123a08:	24c00017 	ldw	r19,0(r4)
81123a0c:	002d883a 	mov	r22,zero
81123a10:	90800094 	ori	r2,r18,2
81123a14:	28029a16 	blt	r5,zero,81124480 <___vfprintf_internal_r+0xdc8>
81123a18:	00bfdfc4 	movi	r2,-129
81123a1c:	90a4703a 	and	r18,r18,r2
81123a20:	d8c02d15 	stw	r3,180(sp)
81123a24:	94800094 	ori	r18,r18,2
81123a28:	9802871e 	bne	r19,zero,81124448 <___vfprintf_internal_r+0xd90>
81123a2c:	00a04574 	movhi	r2,33045
81123a30:	10b8f704 	addi	r2,r2,-7204
81123a34:	d8803915 	stw	r2,228(sp)
81123a38:	04401e04 	movi	r17,120
81123a3c:	d8802917 	ldw	r2,164(sp)
81123a40:	0039883a 	mov	fp,zero
81123a44:	1001e926 	beq	r2,zero,811241ec <___vfprintf_internal_r+0xb34>
81123a48:	0027883a 	mov	r19,zero
81123a4c:	002d883a 	mov	r22,zero
81123a50:	00020506 	br	81124268 <___vfprintf_internal_r+0xbb0>
81123a54:	d9002c17 	ldw	r4,176(sp)
81123a58:	b80b883a 	mov	r5,r23
81123a5c:	11274040 	call	81127404 <__swsetup_r>
81123a60:	1005ac1e 	bne	r2,zero,81125114 <___vfprintf_internal_r+0x1a5c>
81123a64:	b880030b 	ldhu	r2,12(r23)
81123a68:	00c00284 	movi	r3,10
81123a6c:	1080068c 	andi	r2,r2,26
81123a70:	10ff3c1e 	bne	r2,r3,81123764 <__reset+0xfb103764>
81123a74:	b880038f 	ldh	r2,14(r23)
81123a78:	103f3a16 	blt	r2,zero,81123764 <__reset+0xfb103764>
81123a7c:	d9c02d17 	ldw	r7,180(sp)
81123a80:	d9002c17 	ldw	r4,176(sp)
81123a84:	a80d883a 	mov	r6,r21
81123a88:	b80b883a 	mov	r5,r23
81123a8c:	11258d40 	call	811258d4 <__sbprintf>
81123a90:	00001106 	br	81123ad8 <___vfprintf_internal_r+0x420>
81123a94:	d9002c17 	ldw	r4,176(sp)
81123a98:	d9801e04 	addi	r6,sp,120
81123a9c:	b80b883a 	mov	r5,r23
81123aa0:	112f8a80 	call	8112f8a8 <__sprint_r>
81123aa4:	1000081e 	bne	r2,zero,81123ac8 <___vfprintf_internal_r+0x410>
81123aa8:	da000404 	addi	r8,sp,16
81123aac:	003f5306 	br	811237fc <__reset+0xfb1037fc>
81123ab0:	d8802017 	ldw	r2,128(sp)
81123ab4:	10000426 	beq	r2,zero,81123ac8 <___vfprintf_internal_r+0x410>
81123ab8:	d9002c17 	ldw	r4,176(sp)
81123abc:	d9801e04 	addi	r6,sp,120
81123ac0:	b80b883a 	mov	r5,r23
81123ac4:	112f8a80 	call	8112f8a8 <__sprint_r>
81123ac8:	b880030b 	ldhu	r2,12(r23)
81123acc:	1080100c 	andi	r2,r2,64
81123ad0:	1005901e 	bne	r2,zero,81125114 <___vfprintf_internal_r+0x1a5c>
81123ad4:	d8802f17 	ldw	r2,188(sp)
81123ad8:	dfc04717 	ldw	ra,284(sp)
81123adc:	df004617 	ldw	fp,280(sp)
81123ae0:	ddc04517 	ldw	r23,276(sp)
81123ae4:	dd804417 	ldw	r22,272(sp)
81123ae8:	dd404317 	ldw	r21,268(sp)
81123aec:	dd004217 	ldw	r20,264(sp)
81123af0:	dcc04117 	ldw	r19,260(sp)
81123af4:	dc804017 	ldw	r18,256(sp)
81123af8:	dc403f17 	ldw	r17,252(sp)
81123afc:	dc003e17 	ldw	r16,248(sp)
81123b00:	dec04804 	addi	sp,sp,288
81123b04:	f800283a 	ret
81123b08:	d9002c17 	ldw	r4,176(sp)
81123b0c:	11294740 	call	81129474 <__sinit>
81123b10:	003f0406 	br	81123724 <__reset+0xfb103724>
81123b14:	d8802d17 	ldw	r2,180(sp)
81123b18:	d9002d17 	ldw	r4,180(sp)
81123b1c:	10800017 	ldw	r2,0(r2)
81123b20:	d8803115 	stw	r2,196(sp)
81123b24:	20800104 	addi	r2,r4,4
81123b28:	d9003117 	ldw	r4,196(sp)
81123b2c:	203fa716 	blt	r4,zero,811239cc <__reset+0xfb1039cc>
81123b30:	d8802d15 	stw	r2,180(sp)
81123b34:	ac400007 	ldb	r17,0(r21)
81123b38:	003f4206 	br	81123844 <__reset+0xfb103844>
81123b3c:	ac400007 	ldb	r17,0(r21)
81123b40:	aac00044 	addi	r11,r21,1
81123b44:	8a872826 	beq	r17,r10,811257e8 <___vfprintf_internal_r+0x2130>
81123b48:	88bff404 	addi	r2,r17,-48
81123b4c:	0009883a 	mov	r4,zero
81123b50:	30867d36 	bltu	r6,r2,81125548 <___vfprintf_internal_r+0x1e90>
81123b54:	5c400007 	ldb	r17,0(r11)
81123b58:	210002a4 	muli	r4,r4,10
81123b5c:	5d400044 	addi	r21,r11,1
81123b60:	a817883a 	mov	r11,r21
81123b64:	2089883a 	add	r4,r4,r2
81123b68:	88bff404 	addi	r2,r17,-48
81123b6c:	30bff92e 	bgeu	r6,r2,81123b54 <__reset+0xfb103b54>
81123b70:	2005c916 	blt	r4,zero,81125298 <___vfprintf_internal_r+0x1be0>
81123b74:	d9002915 	stw	r4,164(sp)
81123b78:	003f3306 	br	81123848 <__reset+0xfb103848>
81123b7c:	94802014 	ori	r18,r18,128
81123b80:	ac400007 	ldb	r17,0(r21)
81123b84:	003f2f06 	br	81123844 <__reset+0xfb103844>
81123b88:	a809883a 	mov	r4,r21
81123b8c:	d8003115 	stw	zero,196(sp)
81123b90:	88bff404 	addi	r2,r17,-48
81123b94:	0017883a 	mov	r11,zero
81123b98:	24400007 	ldb	r17,0(r4)
81123b9c:	5ac002a4 	muli	r11,r11,10
81123ba0:	ad400044 	addi	r21,r21,1
81123ba4:	a809883a 	mov	r4,r21
81123ba8:	12d7883a 	add	r11,r2,r11
81123bac:	88bff404 	addi	r2,r17,-48
81123bb0:	30bff92e 	bgeu	r6,r2,81123b98 <__reset+0xfb103b98>
81123bb4:	dac03115 	stw	r11,196(sp)
81123bb8:	003f2306 	br	81123848 <__reset+0xfb103848>
81123bbc:	18c03fcc 	andi	r3,r3,255
81123bc0:	18072b1e 	bne	r3,zero,81125870 <___vfprintf_internal_r+0x21b8>
81123bc4:	94800414 	ori	r18,r18,16
81123bc8:	9080080c 	andi	r2,r18,32
81123bcc:	10037b26 	beq	r2,zero,811249bc <___vfprintf_internal_r+0x1304>
81123bd0:	d9402d17 	ldw	r5,180(sp)
81123bd4:	28800117 	ldw	r2,4(r5)
81123bd8:	2cc00017 	ldw	r19,0(r5)
81123bdc:	29400204 	addi	r5,r5,8
81123be0:	d9402d15 	stw	r5,180(sp)
81123be4:	102d883a 	mov	r22,r2
81123be8:	10044b16 	blt	r2,zero,81124d18 <___vfprintf_internal_r+0x1660>
81123bec:	d9402917 	ldw	r5,164(sp)
81123bf0:	df002783 	ldbu	fp,158(sp)
81123bf4:	2803bc16 	blt	r5,zero,81124ae8 <___vfprintf_internal_r+0x1430>
81123bf8:	00ffdfc4 	movi	r3,-129
81123bfc:	9d84b03a 	or	r2,r19,r22
81123c00:	90e4703a 	and	r18,r18,r3
81123c04:	10017726 	beq	r2,zero,811241e4 <___vfprintf_internal_r+0xb2c>
81123c08:	b0038326 	beq	r22,zero,81124a18 <___vfprintf_internal_r+0x1360>
81123c0c:	dc402a15 	stw	r17,168(sp)
81123c10:	dc001e04 	addi	r16,sp,120
81123c14:	b023883a 	mov	r17,r22
81123c18:	402d883a 	mov	r22,r8
81123c1c:	9809883a 	mov	r4,r19
81123c20:	880b883a 	mov	r5,r17
81123c24:	01800284 	movi	r6,10
81123c28:	000f883a 	mov	r7,zero
81123c2c:	11325e00 	call	811325e0 <__umoddi3>
81123c30:	10800c04 	addi	r2,r2,48
81123c34:	843fffc4 	addi	r16,r16,-1
81123c38:	9809883a 	mov	r4,r19
81123c3c:	880b883a 	mov	r5,r17
81123c40:	80800005 	stb	r2,0(r16)
81123c44:	01800284 	movi	r6,10
81123c48:	000f883a 	mov	r7,zero
81123c4c:	11320600 	call	81132060 <__udivdi3>
81123c50:	1027883a 	mov	r19,r2
81123c54:	10c4b03a 	or	r2,r2,r3
81123c58:	1823883a 	mov	r17,r3
81123c5c:	103fef1e 	bne	r2,zero,81123c1c <__reset+0xfb103c1c>
81123c60:	d8c02817 	ldw	r3,160(sp)
81123c64:	dc402a17 	ldw	r17,168(sp)
81123c68:	b011883a 	mov	r8,r22
81123c6c:	1c07c83a 	sub	r3,r3,r16
81123c70:	d8c02e15 	stw	r3,184(sp)
81123c74:	00005906 	br	81123ddc <___vfprintf_internal_r+0x724>
81123c78:	18c03fcc 	andi	r3,r3,255
81123c7c:	1806fa1e 	bne	r3,zero,81125868 <___vfprintf_internal_r+0x21b0>
81123c80:	9080020c 	andi	r2,r18,8
81123c84:	10048a26 	beq	r2,zero,81124eb0 <___vfprintf_internal_r+0x17f8>
81123c88:	d8c02d17 	ldw	r3,180(sp)
81123c8c:	d9002d17 	ldw	r4,180(sp)
81123c90:	d9402d17 	ldw	r5,180(sp)
81123c94:	18c00017 	ldw	r3,0(r3)
81123c98:	21000117 	ldw	r4,4(r4)
81123c9c:	29400204 	addi	r5,r5,8
81123ca0:	d8c03615 	stw	r3,216(sp)
81123ca4:	d9003815 	stw	r4,224(sp)
81123ca8:	d9402d15 	stw	r5,180(sp)
81123cac:	d9003617 	ldw	r4,216(sp)
81123cb0:	d9403817 	ldw	r5,224(sp)
81123cb4:	da003d15 	stw	r8,244(sp)
81123cb8:	04000044 	movi	r16,1
81123cbc:	112bf0c0 	call	8112bf0c <__fpclassifyd>
81123cc0:	da003d17 	ldw	r8,244(sp)
81123cc4:	14041f1e 	bne	r2,r16,81124d44 <___vfprintf_internal_r+0x168c>
81123cc8:	d9003617 	ldw	r4,216(sp)
81123ccc:	d9403817 	ldw	r5,224(sp)
81123cd0:	000d883a 	mov	r6,zero
81123cd4:	000f883a 	mov	r7,zero
81123cd8:	11340fc0 	call	811340fc <__ledf2>
81123cdc:	da003d17 	ldw	r8,244(sp)
81123ce0:	1005be16 	blt	r2,zero,811253dc <___vfprintf_internal_r+0x1d24>
81123ce4:	df002783 	ldbu	fp,158(sp)
81123ce8:	008011c4 	movi	r2,71
81123cec:	1445330e 	bge	r2,r17,811251bc <___vfprintf_internal_r+0x1b04>
81123cf0:	04204574 	movhi	r16,33045
81123cf4:	8438ef04 	addi	r16,r16,-7236
81123cf8:	00c000c4 	movi	r3,3
81123cfc:	00bfdfc4 	movi	r2,-129
81123d00:	d8c02a15 	stw	r3,168(sp)
81123d04:	90a4703a 	and	r18,r18,r2
81123d08:	d8c02e15 	stw	r3,184(sp)
81123d0c:	d8002915 	stw	zero,164(sp)
81123d10:	d8003215 	stw	zero,200(sp)
81123d14:	00003706 	br	81123df4 <___vfprintf_internal_r+0x73c>
81123d18:	94800214 	ori	r18,r18,8
81123d1c:	ac400007 	ldb	r17,0(r21)
81123d20:	003ec806 	br	81123844 <__reset+0xfb103844>
81123d24:	18c03fcc 	andi	r3,r3,255
81123d28:	1806db1e 	bne	r3,zero,81125898 <___vfprintf_internal_r+0x21e0>
81123d2c:	94800414 	ori	r18,r18,16
81123d30:	9080080c 	andi	r2,r18,32
81123d34:	1002d826 	beq	r2,zero,81124898 <___vfprintf_internal_r+0x11e0>
81123d38:	d9402d17 	ldw	r5,180(sp)
81123d3c:	d8c02917 	ldw	r3,164(sp)
81123d40:	d8002785 	stb	zero,158(sp)
81123d44:	28800204 	addi	r2,r5,8
81123d48:	2cc00017 	ldw	r19,0(r5)
81123d4c:	2d800117 	ldw	r22,4(r5)
81123d50:	18048f16 	blt	r3,zero,81124f90 <___vfprintf_internal_r+0x18d8>
81123d54:	013fdfc4 	movi	r4,-129
81123d58:	9d86b03a 	or	r3,r19,r22
81123d5c:	d8802d15 	stw	r2,180(sp)
81123d60:	9124703a 	and	r18,r18,r4
81123d64:	1802d91e 	bne	r3,zero,811248cc <___vfprintf_internal_r+0x1214>
81123d68:	d8c02917 	ldw	r3,164(sp)
81123d6c:	0039883a 	mov	fp,zero
81123d70:	1805c326 	beq	r3,zero,81125480 <___vfprintf_internal_r+0x1dc8>
81123d74:	0027883a 	mov	r19,zero
81123d78:	002d883a 	mov	r22,zero
81123d7c:	dc001e04 	addi	r16,sp,120
81123d80:	9806d0fa 	srli	r3,r19,3
81123d84:	b008977a 	slli	r4,r22,29
81123d88:	b02cd0fa 	srli	r22,r22,3
81123d8c:	9cc001cc 	andi	r19,r19,7
81123d90:	98800c04 	addi	r2,r19,48
81123d94:	843fffc4 	addi	r16,r16,-1
81123d98:	20e6b03a 	or	r19,r4,r3
81123d9c:	80800005 	stb	r2,0(r16)
81123da0:	9d86b03a 	or	r3,r19,r22
81123da4:	183ff61e 	bne	r3,zero,81123d80 <__reset+0xfb103d80>
81123da8:	90c0004c 	andi	r3,r18,1
81123dac:	18013b26 	beq	r3,zero,8112429c <___vfprintf_internal_r+0xbe4>
81123db0:	10803fcc 	andi	r2,r2,255
81123db4:	1080201c 	xori	r2,r2,128
81123db8:	10bfe004 	addi	r2,r2,-128
81123dbc:	00c00c04 	movi	r3,48
81123dc0:	10c13626 	beq	r2,r3,8112429c <___vfprintf_internal_r+0xbe4>
81123dc4:	80ffffc5 	stb	r3,-1(r16)
81123dc8:	d8c02817 	ldw	r3,160(sp)
81123dcc:	80bfffc4 	addi	r2,r16,-1
81123dd0:	1021883a 	mov	r16,r2
81123dd4:	1887c83a 	sub	r3,r3,r2
81123dd8:	d8c02e15 	stw	r3,184(sp)
81123ddc:	d8802e17 	ldw	r2,184(sp)
81123de0:	d9002917 	ldw	r4,164(sp)
81123de4:	1100010e 	bge	r2,r4,81123dec <___vfprintf_internal_r+0x734>
81123de8:	2005883a 	mov	r2,r4
81123dec:	d8802a15 	stw	r2,168(sp)
81123df0:	d8003215 	stw	zero,200(sp)
81123df4:	e7003fcc 	andi	fp,fp,255
81123df8:	e700201c 	xori	fp,fp,128
81123dfc:	e73fe004 	addi	fp,fp,-128
81123e00:	e0000326 	beq	fp,zero,81123e10 <___vfprintf_internal_r+0x758>
81123e04:	d8c02a17 	ldw	r3,168(sp)
81123e08:	18c00044 	addi	r3,r3,1
81123e0c:	d8c02a15 	stw	r3,168(sp)
81123e10:	90c0008c 	andi	r3,r18,2
81123e14:	d8c02b15 	stw	r3,172(sp)
81123e18:	18000326 	beq	r3,zero,81123e28 <___vfprintf_internal_r+0x770>
81123e1c:	d8c02a17 	ldw	r3,168(sp)
81123e20:	18c00084 	addi	r3,r3,2
81123e24:	d8c02a15 	stw	r3,168(sp)
81123e28:	90c0210c 	andi	r3,r18,132
81123e2c:	d8c03015 	stw	r3,192(sp)
81123e30:	1801a31e 	bne	r3,zero,811244c0 <___vfprintf_internal_r+0xe08>
81123e34:	d9003117 	ldw	r4,196(sp)
81123e38:	d8c02a17 	ldw	r3,168(sp)
81123e3c:	20e7c83a 	sub	r19,r4,r3
81123e40:	04c19f0e 	bge	zero,r19,811244c0 <___vfprintf_internal_r+0xe08>
81123e44:	02400404 	movi	r9,16
81123e48:	d8c02017 	ldw	r3,128(sp)
81123e4c:	d8801f17 	ldw	r2,124(sp)
81123e50:	4cc50d0e 	bge	r9,r19,81125288 <___vfprintf_internal_r+0x1bd0>
81123e54:	01604574 	movhi	r5,33045
81123e58:	29790a84 	addi	r5,r5,-7126
81123e5c:	dc403b15 	stw	r17,236(sp)
81123e60:	d9403515 	stw	r5,212(sp)
81123e64:	9823883a 	mov	r17,r19
81123e68:	482d883a 	mov	r22,r9
81123e6c:	9027883a 	mov	r19,r18
81123e70:	070001c4 	movi	fp,7
81123e74:	8025883a 	mov	r18,r16
81123e78:	dc002c17 	ldw	r16,176(sp)
81123e7c:	00000306 	br	81123e8c <___vfprintf_internal_r+0x7d4>
81123e80:	8c7ffc04 	addi	r17,r17,-16
81123e84:	42000204 	addi	r8,r8,8
81123e88:	b440130e 	bge	r22,r17,81123ed8 <___vfprintf_internal_r+0x820>
81123e8c:	01204574 	movhi	r4,33045
81123e90:	18c00404 	addi	r3,r3,16
81123e94:	10800044 	addi	r2,r2,1
81123e98:	21390a84 	addi	r4,r4,-7126
81123e9c:	41000015 	stw	r4,0(r8)
81123ea0:	45800115 	stw	r22,4(r8)
81123ea4:	d8c02015 	stw	r3,128(sp)
81123ea8:	d8801f15 	stw	r2,124(sp)
81123eac:	e0bff40e 	bge	fp,r2,81123e80 <__reset+0xfb103e80>
81123eb0:	d9801e04 	addi	r6,sp,120
81123eb4:	b80b883a 	mov	r5,r23
81123eb8:	8009883a 	mov	r4,r16
81123ebc:	112f8a80 	call	8112f8a8 <__sprint_r>
81123ec0:	103f011e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81123ec4:	8c7ffc04 	addi	r17,r17,-16
81123ec8:	d8c02017 	ldw	r3,128(sp)
81123ecc:	d8801f17 	ldw	r2,124(sp)
81123ed0:	da000404 	addi	r8,sp,16
81123ed4:	b47fed16 	blt	r22,r17,81123e8c <__reset+0xfb103e8c>
81123ed8:	9021883a 	mov	r16,r18
81123edc:	9825883a 	mov	r18,r19
81123ee0:	8827883a 	mov	r19,r17
81123ee4:	dc403b17 	ldw	r17,236(sp)
81123ee8:	d9403517 	ldw	r5,212(sp)
81123eec:	98c7883a 	add	r3,r19,r3
81123ef0:	10800044 	addi	r2,r2,1
81123ef4:	41400015 	stw	r5,0(r8)
81123ef8:	44c00115 	stw	r19,4(r8)
81123efc:	d8c02015 	stw	r3,128(sp)
81123f00:	d8801f15 	stw	r2,124(sp)
81123f04:	010001c4 	movi	r4,7
81123f08:	2082a316 	blt	r4,r2,81124998 <___vfprintf_internal_r+0x12e0>
81123f0c:	df002787 	ldb	fp,158(sp)
81123f10:	42000204 	addi	r8,r8,8
81123f14:	e0000c26 	beq	fp,zero,81123f48 <___vfprintf_internal_r+0x890>
81123f18:	d8801f17 	ldw	r2,124(sp)
81123f1c:	d9002784 	addi	r4,sp,158
81123f20:	18c00044 	addi	r3,r3,1
81123f24:	10800044 	addi	r2,r2,1
81123f28:	41000015 	stw	r4,0(r8)
81123f2c:	01000044 	movi	r4,1
81123f30:	41000115 	stw	r4,4(r8)
81123f34:	d8c02015 	stw	r3,128(sp)
81123f38:	d8801f15 	stw	r2,124(sp)
81123f3c:	010001c4 	movi	r4,7
81123f40:	20823c16 	blt	r4,r2,81124834 <___vfprintf_internal_r+0x117c>
81123f44:	42000204 	addi	r8,r8,8
81123f48:	d8802b17 	ldw	r2,172(sp)
81123f4c:	10000c26 	beq	r2,zero,81123f80 <___vfprintf_internal_r+0x8c8>
81123f50:	d8801f17 	ldw	r2,124(sp)
81123f54:	d9002704 	addi	r4,sp,156
81123f58:	18c00084 	addi	r3,r3,2
81123f5c:	10800044 	addi	r2,r2,1
81123f60:	41000015 	stw	r4,0(r8)
81123f64:	01000084 	movi	r4,2
81123f68:	41000115 	stw	r4,4(r8)
81123f6c:	d8c02015 	stw	r3,128(sp)
81123f70:	d8801f15 	stw	r2,124(sp)
81123f74:	010001c4 	movi	r4,7
81123f78:	20823616 	blt	r4,r2,81124854 <___vfprintf_internal_r+0x119c>
81123f7c:	42000204 	addi	r8,r8,8
81123f80:	d9003017 	ldw	r4,192(sp)
81123f84:	00802004 	movi	r2,128
81123f88:	20819926 	beq	r4,r2,811245f0 <___vfprintf_internal_r+0xf38>
81123f8c:	d9402917 	ldw	r5,164(sp)
81123f90:	d8802e17 	ldw	r2,184(sp)
81123f94:	28adc83a 	sub	r22,r5,r2
81123f98:	0580310e 	bge	zero,r22,81124060 <___vfprintf_internal_r+0x9a8>
81123f9c:	07000404 	movi	fp,16
81123fa0:	d8801f17 	ldw	r2,124(sp)
81123fa4:	e584140e 	bge	fp,r22,81124ff8 <___vfprintf_internal_r+0x1940>
81123fa8:	01604574 	movhi	r5,33045
81123fac:	29790684 	addi	r5,r5,-7142
81123fb0:	dc402915 	stw	r17,164(sp)
81123fb4:	d9402b15 	stw	r5,172(sp)
81123fb8:	b023883a 	mov	r17,r22
81123fbc:	04c001c4 	movi	r19,7
81123fc0:	a82d883a 	mov	r22,r21
81123fc4:	902b883a 	mov	r21,r18
81123fc8:	8025883a 	mov	r18,r16
81123fcc:	dc002c17 	ldw	r16,176(sp)
81123fd0:	00000306 	br	81123fe0 <___vfprintf_internal_r+0x928>
81123fd4:	8c7ffc04 	addi	r17,r17,-16
81123fd8:	42000204 	addi	r8,r8,8
81123fdc:	e440110e 	bge	fp,r17,81124024 <___vfprintf_internal_r+0x96c>
81123fe0:	18c00404 	addi	r3,r3,16
81123fe4:	10800044 	addi	r2,r2,1
81123fe8:	45000015 	stw	r20,0(r8)
81123fec:	47000115 	stw	fp,4(r8)
81123ff0:	d8c02015 	stw	r3,128(sp)
81123ff4:	d8801f15 	stw	r2,124(sp)
81123ff8:	98bff60e 	bge	r19,r2,81123fd4 <__reset+0xfb103fd4>
81123ffc:	d9801e04 	addi	r6,sp,120
81124000:	b80b883a 	mov	r5,r23
81124004:	8009883a 	mov	r4,r16
81124008:	112f8a80 	call	8112f8a8 <__sprint_r>
8112400c:	103eae1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124010:	8c7ffc04 	addi	r17,r17,-16
81124014:	d8c02017 	ldw	r3,128(sp)
81124018:	d8801f17 	ldw	r2,124(sp)
8112401c:	da000404 	addi	r8,sp,16
81124020:	e47fef16 	blt	fp,r17,81123fe0 <__reset+0xfb103fe0>
81124024:	9021883a 	mov	r16,r18
81124028:	a825883a 	mov	r18,r21
8112402c:	b02b883a 	mov	r21,r22
81124030:	882d883a 	mov	r22,r17
81124034:	dc402917 	ldw	r17,164(sp)
81124038:	d9002b17 	ldw	r4,172(sp)
8112403c:	1d87883a 	add	r3,r3,r22
81124040:	10800044 	addi	r2,r2,1
81124044:	41000015 	stw	r4,0(r8)
81124048:	45800115 	stw	r22,4(r8)
8112404c:	d8c02015 	stw	r3,128(sp)
81124050:	d8801f15 	stw	r2,124(sp)
81124054:	010001c4 	movi	r4,7
81124058:	2081ee16 	blt	r4,r2,81124814 <___vfprintf_internal_r+0x115c>
8112405c:	42000204 	addi	r8,r8,8
81124060:	9080400c 	andi	r2,r18,256
81124064:	1001181e 	bne	r2,zero,811244c8 <___vfprintf_internal_r+0xe10>
81124068:	d9402e17 	ldw	r5,184(sp)
8112406c:	d8801f17 	ldw	r2,124(sp)
81124070:	44000015 	stw	r16,0(r8)
81124074:	1947883a 	add	r3,r3,r5
81124078:	10800044 	addi	r2,r2,1
8112407c:	41400115 	stw	r5,4(r8)
81124080:	d8c02015 	stw	r3,128(sp)
81124084:	d8801f15 	stw	r2,124(sp)
81124088:	010001c4 	movi	r4,7
8112408c:	2081d316 	blt	r4,r2,811247dc <___vfprintf_internal_r+0x1124>
81124090:	42000204 	addi	r8,r8,8
81124094:	9480010c 	andi	r18,r18,4
81124098:	90003226 	beq	r18,zero,81124164 <___vfprintf_internal_r+0xaac>
8112409c:	d9403117 	ldw	r5,196(sp)
811240a0:	d8802a17 	ldw	r2,168(sp)
811240a4:	28a1c83a 	sub	r16,r5,r2
811240a8:	04002e0e 	bge	zero,r16,81124164 <___vfprintf_internal_r+0xaac>
811240ac:	04400404 	movi	r17,16
811240b0:	d8801f17 	ldw	r2,124(sp)
811240b4:	8c04a20e 	bge	r17,r16,81125340 <___vfprintf_internal_r+0x1c88>
811240b8:	01604574 	movhi	r5,33045
811240bc:	29790a84 	addi	r5,r5,-7126
811240c0:	d9403515 	stw	r5,212(sp)
811240c4:	048001c4 	movi	r18,7
811240c8:	dcc02c17 	ldw	r19,176(sp)
811240cc:	00000306 	br	811240dc <___vfprintf_internal_r+0xa24>
811240d0:	843ffc04 	addi	r16,r16,-16
811240d4:	42000204 	addi	r8,r8,8
811240d8:	8c00130e 	bge	r17,r16,81124128 <___vfprintf_internal_r+0xa70>
811240dc:	01204574 	movhi	r4,33045
811240e0:	18c00404 	addi	r3,r3,16
811240e4:	10800044 	addi	r2,r2,1
811240e8:	21390a84 	addi	r4,r4,-7126
811240ec:	41000015 	stw	r4,0(r8)
811240f0:	44400115 	stw	r17,4(r8)
811240f4:	d8c02015 	stw	r3,128(sp)
811240f8:	d8801f15 	stw	r2,124(sp)
811240fc:	90bff40e 	bge	r18,r2,811240d0 <__reset+0xfb1040d0>
81124100:	d9801e04 	addi	r6,sp,120
81124104:	b80b883a 	mov	r5,r23
81124108:	9809883a 	mov	r4,r19
8112410c:	112f8a80 	call	8112f8a8 <__sprint_r>
81124110:	103e6d1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124114:	843ffc04 	addi	r16,r16,-16
81124118:	d8c02017 	ldw	r3,128(sp)
8112411c:	d8801f17 	ldw	r2,124(sp)
81124120:	da000404 	addi	r8,sp,16
81124124:	8c3fed16 	blt	r17,r16,811240dc <__reset+0xfb1040dc>
81124128:	d9403517 	ldw	r5,212(sp)
8112412c:	1c07883a 	add	r3,r3,r16
81124130:	10800044 	addi	r2,r2,1
81124134:	41400015 	stw	r5,0(r8)
81124138:	44000115 	stw	r16,4(r8)
8112413c:	d8c02015 	stw	r3,128(sp)
81124140:	d8801f15 	stw	r2,124(sp)
81124144:	010001c4 	movi	r4,7
81124148:	2080060e 	bge	r4,r2,81124164 <___vfprintf_internal_r+0xaac>
8112414c:	d9002c17 	ldw	r4,176(sp)
81124150:	d9801e04 	addi	r6,sp,120
81124154:	b80b883a 	mov	r5,r23
81124158:	112f8a80 	call	8112f8a8 <__sprint_r>
8112415c:	103e5a1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124160:	d8c02017 	ldw	r3,128(sp)
81124164:	d8803117 	ldw	r2,196(sp)
81124168:	d9002a17 	ldw	r4,168(sp)
8112416c:	1100010e 	bge	r2,r4,81124174 <___vfprintf_internal_r+0xabc>
81124170:	2005883a 	mov	r2,r4
81124174:	d9402f17 	ldw	r5,188(sp)
81124178:	288b883a 	add	r5,r5,r2
8112417c:	d9402f15 	stw	r5,188(sp)
81124180:	18019e1e 	bne	r3,zero,811247fc <___vfprintf_internal_r+0x1144>
81124184:	a8800007 	ldb	r2,0(r21)
81124188:	d8001f15 	stw	zero,124(sp)
8112418c:	da000404 	addi	r8,sp,16
81124190:	103d851e 	bne	r2,zero,811237a8 <__reset+0xfb1037a8>
81124194:	a821883a 	mov	r16,r21
81124198:	003d9b06 	br	81123808 <__reset+0xfb103808>
8112419c:	18c03fcc 	andi	r3,r3,255
811241a0:	1805c11e 	bne	r3,zero,811258a8 <___vfprintf_internal_r+0x21f0>
811241a4:	94800414 	ori	r18,r18,16
811241a8:	9080080c 	andi	r2,r18,32
811241ac:	10020c26 	beq	r2,zero,811249e0 <___vfprintf_internal_r+0x1328>
811241b0:	d8802d17 	ldw	r2,180(sp)
811241b4:	d9002917 	ldw	r4,164(sp)
811241b8:	d8002785 	stb	zero,158(sp)
811241bc:	10c00204 	addi	r3,r2,8
811241c0:	14c00017 	ldw	r19,0(r2)
811241c4:	15800117 	ldw	r22,4(r2)
811241c8:	20040f16 	blt	r4,zero,81125208 <___vfprintf_internal_r+0x1b50>
811241cc:	013fdfc4 	movi	r4,-129
811241d0:	9d84b03a 	or	r2,r19,r22
811241d4:	d8c02d15 	stw	r3,180(sp)
811241d8:	9124703a 	and	r18,r18,r4
811241dc:	0039883a 	mov	fp,zero
811241e0:	103e891e 	bne	r2,zero,81123c08 <__reset+0xfb103c08>
811241e4:	d9002917 	ldw	r4,164(sp)
811241e8:	2002c11e 	bne	r4,zero,81124cf0 <___vfprintf_internal_r+0x1638>
811241ec:	d8002915 	stw	zero,164(sp)
811241f0:	d8002e15 	stw	zero,184(sp)
811241f4:	dc001e04 	addi	r16,sp,120
811241f8:	003ef806 	br	81123ddc <__reset+0xfb103ddc>
811241fc:	18c03fcc 	andi	r3,r3,255
81124200:	18059d1e 	bne	r3,zero,81125878 <___vfprintf_internal_r+0x21c0>
81124204:	01604574 	movhi	r5,33045
81124208:	2978f204 	addi	r5,r5,-7224
8112420c:	d9403915 	stw	r5,228(sp)
81124210:	9080080c 	andi	r2,r18,32
81124214:	10005226 	beq	r2,zero,81124360 <___vfprintf_internal_r+0xca8>
81124218:	d8802d17 	ldw	r2,180(sp)
8112421c:	14c00017 	ldw	r19,0(r2)
81124220:	15800117 	ldw	r22,4(r2)
81124224:	10800204 	addi	r2,r2,8
81124228:	d8802d15 	stw	r2,180(sp)
8112422c:	9080004c 	andi	r2,r18,1
81124230:	10019026 	beq	r2,zero,81124874 <___vfprintf_internal_r+0x11bc>
81124234:	9d84b03a 	or	r2,r19,r22
81124238:	10036926 	beq	r2,zero,81124fe0 <___vfprintf_internal_r+0x1928>
8112423c:	d8c02917 	ldw	r3,164(sp)
81124240:	00800c04 	movi	r2,48
81124244:	d8802705 	stb	r2,156(sp)
81124248:	dc402745 	stb	r17,157(sp)
8112424c:	d8002785 	stb	zero,158(sp)
81124250:	90800094 	ori	r2,r18,2
81124254:	18045d16 	blt	r3,zero,811253cc <___vfprintf_internal_r+0x1d14>
81124258:	00bfdfc4 	movi	r2,-129
8112425c:	90a4703a 	and	r18,r18,r2
81124260:	94800094 	ori	r18,r18,2
81124264:	0039883a 	mov	fp,zero
81124268:	d9003917 	ldw	r4,228(sp)
8112426c:	dc001e04 	addi	r16,sp,120
81124270:	988003cc 	andi	r2,r19,15
81124274:	b006973a 	slli	r3,r22,28
81124278:	2085883a 	add	r2,r4,r2
8112427c:	9826d13a 	srli	r19,r19,4
81124280:	10800003 	ldbu	r2,0(r2)
81124284:	b02cd13a 	srli	r22,r22,4
81124288:	843fffc4 	addi	r16,r16,-1
8112428c:	1ce6b03a 	or	r19,r3,r19
81124290:	80800005 	stb	r2,0(r16)
81124294:	9d84b03a 	or	r2,r19,r22
81124298:	103ff51e 	bne	r2,zero,81124270 <__reset+0xfb104270>
8112429c:	d8c02817 	ldw	r3,160(sp)
811242a0:	1c07c83a 	sub	r3,r3,r16
811242a4:	d8c02e15 	stw	r3,184(sp)
811242a8:	003ecc06 	br	81123ddc <__reset+0xfb103ddc>
811242ac:	18c03fcc 	andi	r3,r3,255
811242b0:	183e9f26 	beq	r3,zero,81123d30 <__reset+0xfb103d30>
811242b4:	d9c02785 	stb	r7,158(sp)
811242b8:	003e9d06 	br	81123d30 <__reset+0xfb103d30>
811242bc:	00c00044 	movi	r3,1
811242c0:	01c00ac4 	movi	r7,43
811242c4:	ac400007 	ldb	r17,0(r21)
811242c8:	003d5e06 	br	81123844 <__reset+0xfb103844>
811242cc:	94800814 	ori	r18,r18,32
811242d0:	ac400007 	ldb	r17,0(r21)
811242d4:	003d5b06 	br	81123844 <__reset+0xfb103844>
811242d8:	d8c02d17 	ldw	r3,180(sp)
811242dc:	d8002785 	stb	zero,158(sp)
811242e0:	1c000017 	ldw	r16,0(r3)
811242e4:	1cc00104 	addi	r19,r3,4
811242e8:	80041926 	beq	r16,zero,81125350 <___vfprintf_internal_r+0x1c98>
811242ec:	d9002917 	ldw	r4,164(sp)
811242f0:	2003d016 	blt	r4,zero,81125234 <___vfprintf_internal_r+0x1b7c>
811242f4:	200d883a 	mov	r6,r4
811242f8:	000b883a 	mov	r5,zero
811242fc:	8009883a 	mov	r4,r16
81124300:	da003d15 	stw	r8,244(sp)
81124304:	112a69c0 	call	8112a69c <memchr>
81124308:	da003d17 	ldw	r8,244(sp)
8112430c:	10045426 	beq	r2,zero,81125460 <___vfprintf_internal_r+0x1da8>
81124310:	1405c83a 	sub	r2,r2,r16
81124314:	d8802e15 	stw	r2,184(sp)
81124318:	1003cc16 	blt	r2,zero,8112524c <___vfprintf_internal_r+0x1b94>
8112431c:	df002783 	ldbu	fp,158(sp)
81124320:	d8802a15 	stw	r2,168(sp)
81124324:	dcc02d15 	stw	r19,180(sp)
81124328:	d8002915 	stw	zero,164(sp)
8112432c:	d8003215 	stw	zero,200(sp)
81124330:	003eb006 	br	81123df4 <__reset+0xfb103df4>
81124334:	18c03fcc 	andi	r3,r3,255
81124338:	183f9b26 	beq	r3,zero,811241a8 <__reset+0xfb1041a8>
8112433c:	d9c02785 	stb	r7,158(sp)
81124340:	003f9906 	br	811241a8 <__reset+0xfb1041a8>
81124344:	18c03fcc 	andi	r3,r3,255
81124348:	1805551e 	bne	r3,zero,811258a0 <___vfprintf_internal_r+0x21e8>
8112434c:	01604574 	movhi	r5,33045
81124350:	2978f704 	addi	r5,r5,-7204
81124354:	d9403915 	stw	r5,228(sp)
81124358:	9080080c 	andi	r2,r18,32
8112435c:	103fae1e 	bne	r2,zero,81124218 <__reset+0xfb104218>
81124360:	9080040c 	andi	r2,r18,16
81124364:	1002de26 	beq	r2,zero,81124ee0 <___vfprintf_internal_r+0x1828>
81124368:	d8c02d17 	ldw	r3,180(sp)
8112436c:	002d883a 	mov	r22,zero
81124370:	1cc00017 	ldw	r19,0(r3)
81124374:	18c00104 	addi	r3,r3,4
81124378:	d8c02d15 	stw	r3,180(sp)
8112437c:	003fab06 	br	8112422c <__reset+0xfb10422c>
81124380:	38803fcc 	andi	r2,r7,255
81124384:	1080201c 	xori	r2,r2,128
81124388:	10bfe004 	addi	r2,r2,-128
8112438c:	1002d21e 	bne	r2,zero,81124ed8 <___vfprintf_internal_r+0x1820>
81124390:	00c00044 	movi	r3,1
81124394:	01c00804 	movi	r7,32
81124398:	ac400007 	ldb	r17,0(r21)
8112439c:	003d2906 	br	81123844 <__reset+0xfb103844>
811243a0:	94800054 	ori	r18,r18,1
811243a4:	ac400007 	ldb	r17,0(r21)
811243a8:	003d2606 	br	81123844 <__reset+0xfb103844>
811243ac:	18c03fcc 	andi	r3,r3,255
811243b0:	183e0526 	beq	r3,zero,81123bc8 <__reset+0xfb103bc8>
811243b4:	d9c02785 	stb	r7,158(sp)
811243b8:	003e0306 	br	81123bc8 <__reset+0xfb103bc8>
811243bc:	94801014 	ori	r18,r18,64
811243c0:	ac400007 	ldb	r17,0(r21)
811243c4:	003d1f06 	br	81123844 <__reset+0xfb103844>
811243c8:	ac400007 	ldb	r17,0(r21)
811243cc:	8a438726 	beq	r17,r9,811251ec <___vfprintf_internal_r+0x1b34>
811243d0:	94800414 	ori	r18,r18,16
811243d4:	003d1b06 	br	81123844 <__reset+0xfb103844>
811243d8:	18c03fcc 	andi	r3,r3,255
811243dc:	1805341e 	bne	r3,zero,811258b0 <___vfprintf_internal_r+0x21f8>
811243e0:	9080080c 	andi	r2,r18,32
811243e4:	1002cd26 	beq	r2,zero,81124f1c <___vfprintf_internal_r+0x1864>
811243e8:	d9402d17 	ldw	r5,180(sp)
811243ec:	d9002f17 	ldw	r4,188(sp)
811243f0:	28800017 	ldw	r2,0(r5)
811243f4:	2007d7fa 	srai	r3,r4,31
811243f8:	29400104 	addi	r5,r5,4
811243fc:	d9402d15 	stw	r5,180(sp)
81124400:	11000015 	stw	r4,0(r2)
81124404:	10c00115 	stw	r3,4(r2)
81124408:	003ce506 	br	811237a0 <__reset+0xfb1037a0>
8112440c:	d8c02d17 	ldw	r3,180(sp)
81124410:	d9002d17 	ldw	r4,180(sp)
81124414:	d8002785 	stb	zero,158(sp)
81124418:	18800017 	ldw	r2,0(r3)
8112441c:	21000104 	addi	r4,r4,4
81124420:	00c00044 	movi	r3,1
81124424:	d8c02a15 	stw	r3,168(sp)
81124428:	d8801405 	stb	r2,80(sp)
8112442c:	d9002d15 	stw	r4,180(sp)
81124430:	d8c02e15 	stw	r3,184(sp)
81124434:	d8002915 	stw	zero,164(sp)
81124438:	d8003215 	stw	zero,200(sp)
8112443c:	dc001404 	addi	r16,sp,80
81124440:	0039883a 	mov	fp,zero
81124444:	003e7206 	br	81123e10 <__reset+0xfb103e10>
81124448:	01204574 	movhi	r4,33045
8112444c:	2138f704 	addi	r4,r4,-7204
81124450:	0039883a 	mov	fp,zero
81124454:	d9003915 	stw	r4,228(sp)
81124458:	04401e04 	movi	r17,120
8112445c:	003f8206 	br	81124268 <__reset+0xfb104268>
81124460:	18c03fcc 	andi	r3,r3,255
81124464:	1805061e 	bne	r3,zero,81125880 <___vfprintf_internal_r+0x21c8>
81124468:	883d9126 	beq	r17,zero,81123ab0 <__reset+0xfb103ab0>
8112446c:	00c00044 	movi	r3,1
81124470:	d8c02a15 	stw	r3,168(sp)
81124474:	dc401405 	stb	r17,80(sp)
81124478:	d8002785 	stb	zero,158(sp)
8112447c:	003fec06 	br	81124430 <__reset+0xfb104430>
81124480:	01604574 	movhi	r5,33045
81124484:	2978f704 	addi	r5,r5,-7204
81124488:	d9403915 	stw	r5,228(sp)
8112448c:	d8c02d15 	stw	r3,180(sp)
81124490:	1025883a 	mov	r18,r2
81124494:	04401e04 	movi	r17,120
81124498:	9d84b03a 	or	r2,r19,r22
8112449c:	1000fc1e 	bne	r2,zero,81124890 <___vfprintf_internal_r+0x11d8>
811244a0:	0039883a 	mov	fp,zero
811244a4:	00800084 	movi	r2,2
811244a8:	10803fcc 	andi	r2,r2,255
811244ac:	00c00044 	movi	r3,1
811244b0:	10c20f26 	beq	r2,r3,81124cf0 <___vfprintf_internal_r+0x1638>
811244b4:	00c00084 	movi	r3,2
811244b8:	10fd6326 	beq	r2,r3,81123a48 <__reset+0xfb103a48>
811244bc:	003e2d06 	br	81123d74 <__reset+0xfb103d74>
811244c0:	d8c02017 	ldw	r3,128(sp)
811244c4:	003e9306 	br	81123f14 <__reset+0xfb103f14>
811244c8:	00801944 	movi	r2,101
811244cc:	14407e0e 	bge	r2,r17,811246c8 <___vfprintf_internal_r+0x1010>
811244d0:	d9003617 	ldw	r4,216(sp)
811244d4:	d9403817 	ldw	r5,224(sp)
811244d8:	000d883a 	mov	r6,zero
811244dc:	000f883a 	mov	r7,zero
811244e0:	d8c03c15 	stw	r3,240(sp)
811244e4:	da003d15 	stw	r8,244(sp)
811244e8:	11340740 	call	81134074 <__eqdf2>
811244ec:	d8c03c17 	ldw	r3,240(sp)
811244f0:	da003d17 	ldw	r8,244(sp)
811244f4:	1000f71e 	bne	r2,zero,811248d4 <___vfprintf_internal_r+0x121c>
811244f8:	d8801f17 	ldw	r2,124(sp)
811244fc:	01204574 	movhi	r4,33045
81124500:	2138fe04 	addi	r4,r4,-7176
81124504:	18c00044 	addi	r3,r3,1
81124508:	10800044 	addi	r2,r2,1
8112450c:	41000015 	stw	r4,0(r8)
81124510:	01000044 	movi	r4,1
81124514:	41000115 	stw	r4,4(r8)
81124518:	d8c02015 	stw	r3,128(sp)
8112451c:	d8801f15 	stw	r2,124(sp)
81124520:	010001c4 	movi	r4,7
81124524:	2082b816 	blt	r4,r2,81125008 <___vfprintf_internal_r+0x1950>
81124528:	42000204 	addi	r8,r8,8
8112452c:	d8802617 	ldw	r2,152(sp)
81124530:	d9403317 	ldw	r5,204(sp)
81124534:	11400216 	blt	r2,r5,81124540 <___vfprintf_internal_r+0xe88>
81124538:	9080004c 	andi	r2,r18,1
8112453c:	103ed526 	beq	r2,zero,81124094 <__reset+0xfb104094>
81124540:	d8803717 	ldw	r2,220(sp)
81124544:	d9003417 	ldw	r4,208(sp)
81124548:	d9403717 	ldw	r5,220(sp)
8112454c:	1887883a 	add	r3,r3,r2
81124550:	d8801f17 	ldw	r2,124(sp)
81124554:	41000015 	stw	r4,0(r8)
81124558:	41400115 	stw	r5,4(r8)
8112455c:	10800044 	addi	r2,r2,1
81124560:	d8c02015 	stw	r3,128(sp)
81124564:	d8801f15 	stw	r2,124(sp)
81124568:	010001c4 	movi	r4,7
8112456c:	20832916 	blt	r4,r2,81125214 <___vfprintf_internal_r+0x1b5c>
81124570:	42000204 	addi	r8,r8,8
81124574:	d8803317 	ldw	r2,204(sp)
81124578:	143fffc4 	addi	r16,r2,-1
8112457c:	043ec50e 	bge	zero,r16,81124094 <__reset+0xfb104094>
81124580:	04400404 	movi	r17,16
81124584:	d8801f17 	ldw	r2,124(sp)
81124588:	8c00880e 	bge	r17,r16,811247ac <___vfprintf_internal_r+0x10f4>
8112458c:	01604574 	movhi	r5,33045
81124590:	29790684 	addi	r5,r5,-7142
81124594:	d9402b15 	stw	r5,172(sp)
81124598:	058001c4 	movi	r22,7
8112459c:	dcc02c17 	ldw	r19,176(sp)
811245a0:	00000306 	br	811245b0 <___vfprintf_internal_r+0xef8>
811245a4:	42000204 	addi	r8,r8,8
811245a8:	843ffc04 	addi	r16,r16,-16
811245ac:	8c00820e 	bge	r17,r16,811247b8 <___vfprintf_internal_r+0x1100>
811245b0:	18c00404 	addi	r3,r3,16
811245b4:	10800044 	addi	r2,r2,1
811245b8:	45000015 	stw	r20,0(r8)
811245bc:	44400115 	stw	r17,4(r8)
811245c0:	d8c02015 	stw	r3,128(sp)
811245c4:	d8801f15 	stw	r2,124(sp)
811245c8:	b0bff60e 	bge	r22,r2,811245a4 <__reset+0xfb1045a4>
811245cc:	d9801e04 	addi	r6,sp,120
811245d0:	b80b883a 	mov	r5,r23
811245d4:	9809883a 	mov	r4,r19
811245d8:	112f8a80 	call	8112f8a8 <__sprint_r>
811245dc:	103d3a1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
811245e0:	d8c02017 	ldw	r3,128(sp)
811245e4:	d8801f17 	ldw	r2,124(sp)
811245e8:	da000404 	addi	r8,sp,16
811245ec:	003fee06 	br	811245a8 <__reset+0xfb1045a8>
811245f0:	d9403117 	ldw	r5,196(sp)
811245f4:	d8802a17 	ldw	r2,168(sp)
811245f8:	28adc83a 	sub	r22,r5,r2
811245fc:	05be630e 	bge	zero,r22,81123f8c <__reset+0xfb103f8c>
81124600:	07000404 	movi	fp,16
81124604:	d8801f17 	ldw	r2,124(sp)
81124608:	e5838f0e 	bge	fp,r22,81125448 <___vfprintf_internal_r+0x1d90>
8112460c:	01604574 	movhi	r5,33045
81124610:	29790684 	addi	r5,r5,-7142
81124614:	dc403015 	stw	r17,192(sp)
81124618:	d9402b15 	stw	r5,172(sp)
8112461c:	b023883a 	mov	r17,r22
81124620:	04c001c4 	movi	r19,7
81124624:	a82d883a 	mov	r22,r21
81124628:	902b883a 	mov	r21,r18
8112462c:	8025883a 	mov	r18,r16
81124630:	dc002c17 	ldw	r16,176(sp)
81124634:	00000306 	br	81124644 <___vfprintf_internal_r+0xf8c>
81124638:	8c7ffc04 	addi	r17,r17,-16
8112463c:	42000204 	addi	r8,r8,8
81124640:	e440110e 	bge	fp,r17,81124688 <___vfprintf_internal_r+0xfd0>
81124644:	18c00404 	addi	r3,r3,16
81124648:	10800044 	addi	r2,r2,1
8112464c:	45000015 	stw	r20,0(r8)
81124650:	47000115 	stw	fp,4(r8)
81124654:	d8c02015 	stw	r3,128(sp)
81124658:	d8801f15 	stw	r2,124(sp)
8112465c:	98bff60e 	bge	r19,r2,81124638 <__reset+0xfb104638>
81124660:	d9801e04 	addi	r6,sp,120
81124664:	b80b883a 	mov	r5,r23
81124668:	8009883a 	mov	r4,r16
8112466c:	112f8a80 	call	8112f8a8 <__sprint_r>
81124670:	103d151e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124674:	8c7ffc04 	addi	r17,r17,-16
81124678:	d8c02017 	ldw	r3,128(sp)
8112467c:	d8801f17 	ldw	r2,124(sp)
81124680:	da000404 	addi	r8,sp,16
81124684:	e47fef16 	blt	fp,r17,81124644 <__reset+0xfb104644>
81124688:	9021883a 	mov	r16,r18
8112468c:	a825883a 	mov	r18,r21
81124690:	b02b883a 	mov	r21,r22
81124694:	882d883a 	mov	r22,r17
81124698:	dc403017 	ldw	r17,192(sp)
8112469c:	d9002b17 	ldw	r4,172(sp)
811246a0:	1d87883a 	add	r3,r3,r22
811246a4:	10800044 	addi	r2,r2,1
811246a8:	41000015 	stw	r4,0(r8)
811246ac:	45800115 	stw	r22,4(r8)
811246b0:	d8c02015 	stw	r3,128(sp)
811246b4:	d8801f15 	stw	r2,124(sp)
811246b8:	010001c4 	movi	r4,7
811246bc:	20818e16 	blt	r4,r2,81124cf8 <___vfprintf_internal_r+0x1640>
811246c0:	42000204 	addi	r8,r8,8
811246c4:	003e3106 	br	81123f8c <__reset+0xfb103f8c>
811246c8:	d9403317 	ldw	r5,204(sp)
811246cc:	00800044 	movi	r2,1
811246d0:	18c00044 	addi	r3,r3,1
811246d4:	1141530e 	bge	r2,r5,81124c24 <___vfprintf_internal_r+0x156c>
811246d8:	dc401f17 	ldw	r17,124(sp)
811246dc:	00800044 	movi	r2,1
811246e0:	40800115 	stw	r2,4(r8)
811246e4:	8c400044 	addi	r17,r17,1
811246e8:	44000015 	stw	r16,0(r8)
811246ec:	d8c02015 	stw	r3,128(sp)
811246f0:	dc401f15 	stw	r17,124(sp)
811246f4:	008001c4 	movi	r2,7
811246f8:	14416b16 	blt	r2,r17,81124ca8 <___vfprintf_internal_r+0x15f0>
811246fc:	42000204 	addi	r8,r8,8
81124700:	d8803717 	ldw	r2,220(sp)
81124704:	d9003417 	ldw	r4,208(sp)
81124708:	8c400044 	addi	r17,r17,1
8112470c:	10c7883a 	add	r3,r2,r3
81124710:	40800115 	stw	r2,4(r8)
81124714:	41000015 	stw	r4,0(r8)
81124718:	d8c02015 	stw	r3,128(sp)
8112471c:	dc401f15 	stw	r17,124(sp)
81124720:	008001c4 	movi	r2,7
81124724:	14416916 	blt	r2,r17,81124ccc <___vfprintf_internal_r+0x1614>
81124728:	45800204 	addi	r22,r8,8
8112472c:	d9003617 	ldw	r4,216(sp)
81124730:	d9403817 	ldw	r5,224(sp)
81124734:	000d883a 	mov	r6,zero
81124738:	000f883a 	mov	r7,zero
8112473c:	d8c03c15 	stw	r3,240(sp)
81124740:	11340740 	call	81134074 <__eqdf2>
81124744:	d8c03c17 	ldw	r3,240(sp)
81124748:	1000bc26 	beq	r2,zero,81124a3c <___vfprintf_internal_r+0x1384>
8112474c:	d9403317 	ldw	r5,204(sp)
81124750:	84000044 	addi	r16,r16,1
81124754:	8c400044 	addi	r17,r17,1
81124758:	28bfffc4 	addi	r2,r5,-1
8112475c:	1887883a 	add	r3,r3,r2
81124760:	b0800115 	stw	r2,4(r22)
81124764:	b4000015 	stw	r16,0(r22)
81124768:	d8c02015 	stw	r3,128(sp)
8112476c:	dc401f15 	stw	r17,124(sp)
81124770:	008001c4 	movi	r2,7
81124774:	14414316 	blt	r2,r17,81124c84 <___vfprintf_internal_r+0x15cc>
81124778:	b5800204 	addi	r22,r22,8
8112477c:	d9003a17 	ldw	r4,232(sp)
81124780:	df0022c4 	addi	fp,sp,139
81124784:	8c400044 	addi	r17,r17,1
81124788:	20c7883a 	add	r3,r4,r3
8112478c:	b7000015 	stw	fp,0(r22)
81124790:	b1000115 	stw	r4,4(r22)
81124794:	d8c02015 	stw	r3,128(sp)
81124798:	dc401f15 	stw	r17,124(sp)
8112479c:	008001c4 	movi	r2,7
811247a0:	14400e16 	blt	r2,r17,811247dc <___vfprintf_internal_r+0x1124>
811247a4:	b2000204 	addi	r8,r22,8
811247a8:	003e3a06 	br	81124094 <__reset+0xfb104094>
811247ac:	01204574 	movhi	r4,33045
811247b0:	21390684 	addi	r4,r4,-7142
811247b4:	d9002b15 	stw	r4,172(sp)
811247b8:	d9002b17 	ldw	r4,172(sp)
811247bc:	1c07883a 	add	r3,r3,r16
811247c0:	44000115 	stw	r16,4(r8)
811247c4:	41000015 	stw	r4,0(r8)
811247c8:	10800044 	addi	r2,r2,1
811247cc:	d8c02015 	stw	r3,128(sp)
811247d0:	d8801f15 	stw	r2,124(sp)
811247d4:	010001c4 	movi	r4,7
811247d8:	20be2d0e 	bge	r4,r2,81124090 <__reset+0xfb104090>
811247dc:	d9002c17 	ldw	r4,176(sp)
811247e0:	d9801e04 	addi	r6,sp,120
811247e4:	b80b883a 	mov	r5,r23
811247e8:	112f8a80 	call	8112f8a8 <__sprint_r>
811247ec:	103cb61e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
811247f0:	d8c02017 	ldw	r3,128(sp)
811247f4:	da000404 	addi	r8,sp,16
811247f8:	003e2606 	br	81124094 <__reset+0xfb104094>
811247fc:	d9002c17 	ldw	r4,176(sp)
81124800:	d9801e04 	addi	r6,sp,120
81124804:	b80b883a 	mov	r5,r23
81124808:	112f8a80 	call	8112f8a8 <__sprint_r>
8112480c:	103e5d26 	beq	r2,zero,81124184 <__reset+0xfb104184>
81124810:	003cad06 	br	81123ac8 <__reset+0xfb103ac8>
81124814:	d9002c17 	ldw	r4,176(sp)
81124818:	d9801e04 	addi	r6,sp,120
8112481c:	b80b883a 	mov	r5,r23
81124820:	112f8a80 	call	8112f8a8 <__sprint_r>
81124824:	103ca81e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124828:	d8c02017 	ldw	r3,128(sp)
8112482c:	da000404 	addi	r8,sp,16
81124830:	003e0b06 	br	81124060 <__reset+0xfb104060>
81124834:	d9002c17 	ldw	r4,176(sp)
81124838:	d9801e04 	addi	r6,sp,120
8112483c:	b80b883a 	mov	r5,r23
81124840:	112f8a80 	call	8112f8a8 <__sprint_r>
81124844:	103ca01e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124848:	d8c02017 	ldw	r3,128(sp)
8112484c:	da000404 	addi	r8,sp,16
81124850:	003dbd06 	br	81123f48 <__reset+0xfb103f48>
81124854:	d9002c17 	ldw	r4,176(sp)
81124858:	d9801e04 	addi	r6,sp,120
8112485c:	b80b883a 	mov	r5,r23
81124860:	112f8a80 	call	8112f8a8 <__sprint_r>
81124864:	103c981e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124868:	d8c02017 	ldw	r3,128(sp)
8112486c:	da000404 	addi	r8,sp,16
81124870:	003dc306 	br	81123f80 <__reset+0xfb103f80>
81124874:	d8802917 	ldw	r2,164(sp)
81124878:	d8002785 	stb	zero,158(sp)
8112487c:	103f0616 	blt	r2,zero,81124498 <__reset+0xfb104498>
81124880:	00ffdfc4 	movi	r3,-129
81124884:	9d84b03a 	or	r2,r19,r22
81124888:	90e4703a 	and	r18,r18,r3
8112488c:	103c6b26 	beq	r2,zero,81123a3c <__reset+0xfb103a3c>
81124890:	0039883a 	mov	fp,zero
81124894:	003e7406 	br	81124268 <__reset+0xfb104268>
81124898:	9080040c 	andi	r2,r18,16
8112489c:	1001b326 	beq	r2,zero,81124f6c <___vfprintf_internal_r+0x18b4>
811248a0:	d9002d17 	ldw	r4,180(sp)
811248a4:	d9402917 	ldw	r5,164(sp)
811248a8:	d8002785 	stb	zero,158(sp)
811248ac:	20800104 	addi	r2,r4,4
811248b0:	24c00017 	ldw	r19,0(r4)
811248b4:	002d883a 	mov	r22,zero
811248b8:	2801b516 	blt	r5,zero,81124f90 <___vfprintf_internal_r+0x18d8>
811248bc:	00ffdfc4 	movi	r3,-129
811248c0:	d8802d15 	stw	r2,180(sp)
811248c4:	90e4703a 	and	r18,r18,r3
811248c8:	983d2726 	beq	r19,zero,81123d68 <__reset+0xfb103d68>
811248cc:	0039883a 	mov	fp,zero
811248d0:	003d2a06 	br	81123d7c <__reset+0xfb103d7c>
811248d4:	dc402617 	ldw	r17,152(sp)
811248d8:	0441d30e 	bge	zero,r17,81125028 <___vfprintf_internal_r+0x1970>
811248dc:	dc403217 	ldw	r17,200(sp)
811248e0:	d8803317 	ldw	r2,204(sp)
811248e4:	1440010e 	bge	r2,r17,811248ec <___vfprintf_internal_r+0x1234>
811248e8:	1023883a 	mov	r17,r2
811248ec:	04400a0e 	bge	zero,r17,81124918 <___vfprintf_internal_r+0x1260>
811248f0:	d8801f17 	ldw	r2,124(sp)
811248f4:	1c47883a 	add	r3,r3,r17
811248f8:	44000015 	stw	r16,0(r8)
811248fc:	10800044 	addi	r2,r2,1
81124900:	44400115 	stw	r17,4(r8)
81124904:	d8c02015 	stw	r3,128(sp)
81124908:	d8801f15 	stw	r2,124(sp)
8112490c:	010001c4 	movi	r4,7
81124910:	20826516 	blt	r4,r2,811252a8 <___vfprintf_internal_r+0x1bf0>
81124914:	42000204 	addi	r8,r8,8
81124918:	88026116 	blt	r17,zero,811252a0 <___vfprintf_internal_r+0x1be8>
8112491c:	d9003217 	ldw	r4,200(sp)
81124920:	2463c83a 	sub	r17,r4,r17
81124924:	04407b0e 	bge	zero,r17,81124b14 <___vfprintf_internal_r+0x145c>
81124928:	05800404 	movi	r22,16
8112492c:	d8801f17 	ldw	r2,124(sp)
81124930:	b4419d0e 	bge	r22,r17,81124fa8 <___vfprintf_internal_r+0x18f0>
81124934:	01204574 	movhi	r4,33045
81124938:	21390684 	addi	r4,r4,-7142
8112493c:	d9002b15 	stw	r4,172(sp)
81124940:	070001c4 	movi	fp,7
81124944:	dcc02c17 	ldw	r19,176(sp)
81124948:	00000306 	br	81124958 <___vfprintf_internal_r+0x12a0>
8112494c:	42000204 	addi	r8,r8,8
81124950:	8c7ffc04 	addi	r17,r17,-16
81124954:	b441970e 	bge	r22,r17,81124fb4 <___vfprintf_internal_r+0x18fc>
81124958:	18c00404 	addi	r3,r3,16
8112495c:	10800044 	addi	r2,r2,1
81124960:	45000015 	stw	r20,0(r8)
81124964:	45800115 	stw	r22,4(r8)
81124968:	d8c02015 	stw	r3,128(sp)
8112496c:	d8801f15 	stw	r2,124(sp)
81124970:	e0bff60e 	bge	fp,r2,8112494c <__reset+0xfb10494c>
81124974:	d9801e04 	addi	r6,sp,120
81124978:	b80b883a 	mov	r5,r23
8112497c:	9809883a 	mov	r4,r19
81124980:	112f8a80 	call	8112f8a8 <__sprint_r>
81124984:	103c501e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124988:	d8c02017 	ldw	r3,128(sp)
8112498c:	d8801f17 	ldw	r2,124(sp)
81124990:	da000404 	addi	r8,sp,16
81124994:	003fee06 	br	81124950 <__reset+0xfb104950>
81124998:	d9002c17 	ldw	r4,176(sp)
8112499c:	d9801e04 	addi	r6,sp,120
811249a0:	b80b883a 	mov	r5,r23
811249a4:	112f8a80 	call	8112f8a8 <__sprint_r>
811249a8:	103c471e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
811249ac:	d8c02017 	ldw	r3,128(sp)
811249b0:	df002787 	ldb	fp,158(sp)
811249b4:	da000404 	addi	r8,sp,16
811249b8:	003d5606 	br	81123f14 <__reset+0xfb103f14>
811249bc:	9080040c 	andi	r2,r18,16
811249c0:	10016126 	beq	r2,zero,81124f48 <___vfprintf_internal_r+0x1890>
811249c4:	d8802d17 	ldw	r2,180(sp)
811249c8:	14c00017 	ldw	r19,0(r2)
811249cc:	10800104 	addi	r2,r2,4
811249d0:	d8802d15 	stw	r2,180(sp)
811249d4:	982dd7fa 	srai	r22,r19,31
811249d8:	b005883a 	mov	r2,r22
811249dc:	003c8206 	br	81123be8 <__reset+0xfb103be8>
811249e0:	9080040c 	andi	r2,r18,16
811249e4:	10003526 	beq	r2,zero,81124abc <___vfprintf_internal_r+0x1404>
811249e8:	d9402d17 	ldw	r5,180(sp)
811249ec:	d8c02917 	ldw	r3,164(sp)
811249f0:	d8002785 	stb	zero,158(sp)
811249f4:	28800104 	addi	r2,r5,4
811249f8:	2cc00017 	ldw	r19,0(r5)
811249fc:	002d883a 	mov	r22,zero
81124a00:	18003716 	blt	r3,zero,81124ae0 <___vfprintf_internal_r+0x1428>
81124a04:	00ffdfc4 	movi	r3,-129
81124a08:	d8802d15 	stw	r2,180(sp)
81124a0c:	90e4703a 	and	r18,r18,r3
81124a10:	0039883a 	mov	fp,zero
81124a14:	983df326 	beq	r19,zero,811241e4 <__reset+0xfb1041e4>
81124a18:	00800244 	movi	r2,9
81124a1c:	14fc7b36 	bltu	r2,r19,81123c0c <__reset+0xfb103c0c>
81124a20:	d8c02817 	ldw	r3,160(sp)
81124a24:	dc001dc4 	addi	r16,sp,119
81124a28:	9cc00c04 	addi	r19,r19,48
81124a2c:	1c07c83a 	sub	r3,r3,r16
81124a30:	dcc01dc5 	stb	r19,119(sp)
81124a34:	d8c02e15 	stw	r3,184(sp)
81124a38:	003ce806 	br	81123ddc <__reset+0xfb103ddc>
81124a3c:	d8803317 	ldw	r2,204(sp)
81124a40:	143fffc4 	addi	r16,r2,-1
81124a44:	043f4d0e 	bge	zero,r16,8112477c <__reset+0xfb10477c>
81124a48:	07000404 	movi	fp,16
81124a4c:	e400810e 	bge	fp,r16,81124c54 <___vfprintf_internal_r+0x159c>
81124a50:	01604574 	movhi	r5,33045
81124a54:	29790684 	addi	r5,r5,-7142
81124a58:	d9402b15 	stw	r5,172(sp)
81124a5c:	01c001c4 	movi	r7,7
81124a60:	dcc02c17 	ldw	r19,176(sp)
81124a64:	00000306 	br	81124a74 <___vfprintf_internal_r+0x13bc>
81124a68:	b5800204 	addi	r22,r22,8
81124a6c:	843ffc04 	addi	r16,r16,-16
81124a70:	e4007b0e 	bge	fp,r16,81124c60 <___vfprintf_internal_r+0x15a8>
81124a74:	18c00404 	addi	r3,r3,16
81124a78:	8c400044 	addi	r17,r17,1
81124a7c:	b5000015 	stw	r20,0(r22)
81124a80:	b7000115 	stw	fp,4(r22)
81124a84:	d8c02015 	stw	r3,128(sp)
81124a88:	dc401f15 	stw	r17,124(sp)
81124a8c:	3c7ff60e 	bge	r7,r17,81124a68 <__reset+0xfb104a68>
81124a90:	d9801e04 	addi	r6,sp,120
81124a94:	b80b883a 	mov	r5,r23
81124a98:	9809883a 	mov	r4,r19
81124a9c:	d9c03c15 	stw	r7,240(sp)
81124aa0:	112f8a80 	call	8112f8a8 <__sprint_r>
81124aa4:	d9c03c17 	ldw	r7,240(sp)
81124aa8:	103c071e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124aac:	d8c02017 	ldw	r3,128(sp)
81124ab0:	dc401f17 	ldw	r17,124(sp)
81124ab4:	dd800404 	addi	r22,sp,16
81124ab8:	003fec06 	br	81124a6c <__reset+0xfb104a6c>
81124abc:	9080100c 	andi	r2,r18,64
81124ac0:	d8002785 	stb	zero,158(sp)
81124ac4:	10010e26 	beq	r2,zero,81124f00 <___vfprintf_internal_r+0x1848>
81124ac8:	d9002d17 	ldw	r4,180(sp)
81124acc:	d9402917 	ldw	r5,164(sp)
81124ad0:	002d883a 	mov	r22,zero
81124ad4:	20800104 	addi	r2,r4,4
81124ad8:	24c0000b 	ldhu	r19,0(r4)
81124adc:	283fc90e 	bge	r5,zero,81124a04 <__reset+0xfb104a04>
81124ae0:	d8802d15 	stw	r2,180(sp)
81124ae4:	0039883a 	mov	fp,zero
81124ae8:	9d84b03a 	or	r2,r19,r22
81124aec:	103c461e 	bne	r2,zero,81123c08 <__reset+0xfb103c08>
81124af0:	00800044 	movi	r2,1
81124af4:	003e6c06 	br	811244a8 <__reset+0xfb1044a8>
81124af8:	d9002c17 	ldw	r4,176(sp)
81124afc:	d9801e04 	addi	r6,sp,120
81124b00:	b80b883a 	mov	r5,r23
81124b04:	112f8a80 	call	8112f8a8 <__sprint_r>
81124b08:	103bef1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124b0c:	d8c02017 	ldw	r3,128(sp)
81124b10:	da000404 	addi	r8,sp,16
81124b14:	d9003217 	ldw	r4,200(sp)
81124b18:	d8802617 	ldw	r2,152(sp)
81124b1c:	d9403317 	ldw	r5,204(sp)
81124b20:	8123883a 	add	r17,r16,r4
81124b24:	11400216 	blt	r2,r5,81124b30 <___vfprintf_internal_r+0x1478>
81124b28:	9100004c 	andi	r4,r18,1
81124b2c:	20000d26 	beq	r4,zero,81124b64 <___vfprintf_internal_r+0x14ac>
81124b30:	d9003717 	ldw	r4,220(sp)
81124b34:	d9403417 	ldw	r5,208(sp)
81124b38:	1907883a 	add	r3,r3,r4
81124b3c:	d9001f17 	ldw	r4,124(sp)
81124b40:	41400015 	stw	r5,0(r8)
81124b44:	d9403717 	ldw	r5,220(sp)
81124b48:	21000044 	addi	r4,r4,1
81124b4c:	d8c02015 	stw	r3,128(sp)
81124b50:	41400115 	stw	r5,4(r8)
81124b54:	d9001f15 	stw	r4,124(sp)
81124b58:	014001c4 	movi	r5,7
81124b5c:	2901e816 	blt	r5,r4,81125300 <___vfprintf_internal_r+0x1c48>
81124b60:	42000204 	addi	r8,r8,8
81124b64:	d9003317 	ldw	r4,204(sp)
81124b68:	8121883a 	add	r16,r16,r4
81124b6c:	2085c83a 	sub	r2,r4,r2
81124b70:	8461c83a 	sub	r16,r16,r17
81124b74:	1400010e 	bge	r2,r16,81124b7c <___vfprintf_internal_r+0x14c4>
81124b78:	1021883a 	mov	r16,r2
81124b7c:	04000a0e 	bge	zero,r16,81124ba8 <___vfprintf_internal_r+0x14f0>
81124b80:	d9001f17 	ldw	r4,124(sp)
81124b84:	1c07883a 	add	r3,r3,r16
81124b88:	44400015 	stw	r17,0(r8)
81124b8c:	21000044 	addi	r4,r4,1
81124b90:	44000115 	stw	r16,4(r8)
81124b94:	d8c02015 	stw	r3,128(sp)
81124b98:	d9001f15 	stw	r4,124(sp)
81124b9c:	014001c4 	movi	r5,7
81124ba0:	2901fb16 	blt	r5,r4,81125390 <___vfprintf_internal_r+0x1cd8>
81124ba4:	42000204 	addi	r8,r8,8
81124ba8:	8001f716 	blt	r16,zero,81125388 <___vfprintf_internal_r+0x1cd0>
81124bac:	1421c83a 	sub	r16,r2,r16
81124bb0:	043d380e 	bge	zero,r16,81124094 <__reset+0xfb104094>
81124bb4:	04400404 	movi	r17,16
81124bb8:	d8801f17 	ldw	r2,124(sp)
81124bbc:	8c3efb0e 	bge	r17,r16,811247ac <__reset+0xfb1047ac>
81124bc0:	01604574 	movhi	r5,33045
81124bc4:	29790684 	addi	r5,r5,-7142
81124bc8:	d9402b15 	stw	r5,172(sp)
81124bcc:	058001c4 	movi	r22,7
81124bd0:	dcc02c17 	ldw	r19,176(sp)
81124bd4:	00000306 	br	81124be4 <___vfprintf_internal_r+0x152c>
81124bd8:	42000204 	addi	r8,r8,8
81124bdc:	843ffc04 	addi	r16,r16,-16
81124be0:	8c3ef50e 	bge	r17,r16,811247b8 <__reset+0xfb1047b8>
81124be4:	18c00404 	addi	r3,r3,16
81124be8:	10800044 	addi	r2,r2,1
81124bec:	45000015 	stw	r20,0(r8)
81124bf0:	44400115 	stw	r17,4(r8)
81124bf4:	d8c02015 	stw	r3,128(sp)
81124bf8:	d8801f15 	stw	r2,124(sp)
81124bfc:	b0bff60e 	bge	r22,r2,81124bd8 <__reset+0xfb104bd8>
81124c00:	d9801e04 	addi	r6,sp,120
81124c04:	b80b883a 	mov	r5,r23
81124c08:	9809883a 	mov	r4,r19
81124c0c:	112f8a80 	call	8112f8a8 <__sprint_r>
81124c10:	103bad1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124c14:	d8c02017 	ldw	r3,128(sp)
81124c18:	d8801f17 	ldw	r2,124(sp)
81124c1c:	da000404 	addi	r8,sp,16
81124c20:	003fee06 	br	81124bdc <__reset+0xfb104bdc>
81124c24:	9088703a 	and	r4,r18,r2
81124c28:	203eab1e 	bne	r4,zero,811246d8 <__reset+0xfb1046d8>
81124c2c:	dc401f17 	ldw	r17,124(sp)
81124c30:	40800115 	stw	r2,4(r8)
81124c34:	44000015 	stw	r16,0(r8)
81124c38:	8c400044 	addi	r17,r17,1
81124c3c:	d8c02015 	stw	r3,128(sp)
81124c40:	dc401f15 	stw	r17,124(sp)
81124c44:	008001c4 	movi	r2,7
81124c48:	14400e16 	blt	r2,r17,81124c84 <___vfprintf_internal_r+0x15cc>
81124c4c:	45800204 	addi	r22,r8,8
81124c50:	003eca06 	br	8112477c <__reset+0xfb10477c>
81124c54:	01204574 	movhi	r4,33045
81124c58:	21390684 	addi	r4,r4,-7142
81124c5c:	d9002b15 	stw	r4,172(sp)
81124c60:	d8802b17 	ldw	r2,172(sp)
81124c64:	1c07883a 	add	r3,r3,r16
81124c68:	8c400044 	addi	r17,r17,1
81124c6c:	b0800015 	stw	r2,0(r22)
81124c70:	b4000115 	stw	r16,4(r22)
81124c74:	d8c02015 	stw	r3,128(sp)
81124c78:	dc401f15 	stw	r17,124(sp)
81124c7c:	008001c4 	movi	r2,7
81124c80:	147ebd0e 	bge	r2,r17,81124778 <__reset+0xfb104778>
81124c84:	d9002c17 	ldw	r4,176(sp)
81124c88:	d9801e04 	addi	r6,sp,120
81124c8c:	b80b883a 	mov	r5,r23
81124c90:	112f8a80 	call	8112f8a8 <__sprint_r>
81124c94:	103b8c1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124c98:	d8c02017 	ldw	r3,128(sp)
81124c9c:	dc401f17 	ldw	r17,124(sp)
81124ca0:	dd800404 	addi	r22,sp,16
81124ca4:	003eb506 	br	8112477c <__reset+0xfb10477c>
81124ca8:	d9002c17 	ldw	r4,176(sp)
81124cac:	d9801e04 	addi	r6,sp,120
81124cb0:	b80b883a 	mov	r5,r23
81124cb4:	112f8a80 	call	8112f8a8 <__sprint_r>
81124cb8:	103b831e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124cbc:	d8c02017 	ldw	r3,128(sp)
81124cc0:	dc401f17 	ldw	r17,124(sp)
81124cc4:	da000404 	addi	r8,sp,16
81124cc8:	003e8d06 	br	81124700 <__reset+0xfb104700>
81124ccc:	d9002c17 	ldw	r4,176(sp)
81124cd0:	d9801e04 	addi	r6,sp,120
81124cd4:	b80b883a 	mov	r5,r23
81124cd8:	112f8a80 	call	8112f8a8 <__sprint_r>
81124cdc:	103b7a1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124ce0:	d8c02017 	ldw	r3,128(sp)
81124ce4:	dc401f17 	ldw	r17,124(sp)
81124ce8:	dd800404 	addi	r22,sp,16
81124cec:	003e8f06 	br	8112472c <__reset+0xfb10472c>
81124cf0:	0027883a 	mov	r19,zero
81124cf4:	003f4a06 	br	81124a20 <__reset+0xfb104a20>
81124cf8:	d9002c17 	ldw	r4,176(sp)
81124cfc:	d9801e04 	addi	r6,sp,120
81124d00:	b80b883a 	mov	r5,r23
81124d04:	112f8a80 	call	8112f8a8 <__sprint_r>
81124d08:	103b6f1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81124d0c:	d8c02017 	ldw	r3,128(sp)
81124d10:	da000404 	addi	r8,sp,16
81124d14:	003c9d06 	br	81123f8c <__reset+0xfb103f8c>
81124d18:	04e7c83a 	sub	r19,zero,r19
81124d1c:	9804c03a 	cmpne	r2,r19,zero
81124d20:	05adc83a 	sub	r22,zero,r22
81124d24:	b0adc83a 	sub	r22,r22,r2
81124d28:	d8802917 	ldw	r2,164(sp)
81124d2c:	07000b44 	movi	fp,45
81124d30:	df002785 	stb	fp,158(sp)
81124d34:	10017b16 	blt	r2,zero,81125324 <___vfprintf_internal_r+0x1c6c>
81124d38:	00bfdfc4 	movi	r2,-129
81124d3c:	90a4703a 	and	r18,r18,r2
81124d40:	003bb106 	br	81123c08 <__reset+0xfb103c08>
81124d44:	d9003617 	ldw	r4,216(sp)
81124d48:	d9403817 	ldw	r5,224(sp)
81124d4c:	da003d15 	stw	r8,244(sp)
81124d50:	112bf0c0 	call	8112bf0c <__fpclassifyd>
81124d54:	da003d17 	ldw	r8,244(sp)
81124d58:	1000f026 	beq	r2,zero,8112511c <___vfprintf_internal_r+0x1a64>
81124d5c:	d9002917 	ldw	r4,164(sp)
81124d60:	05bff7c4 	movi	r22,-33
81124d64:	00bfffc4 	movi	r2,-1
81124d68:	8dac703a 	and	r22,r17,r22
81124d6c:	20820026 	beq	r4,r2,81125570 <___vfprintf_internal_r+0x1eb8>
81124d70:	008011c4 	movi	r2,71
81124d74:	b081f726 	beq	r22,r2,81125554 <___vfprintf_internal_r+0x1e9c>
81124d78:	d9003817 	ldw	r4,224(sp)
81124d7c:	90c04014 	ori	r3,r18,256
81124d80:	d8c02b15 	stw	r3,172(sp)
81124d84:	20021516 	blt	r4,zero,811255dc <___vfprintf_internal_r+0x1f24>
81124d88:	dcc03817 	ldw	r19,224(sp)
81124d8c:	d8002a05 	stb	zero,168(sp)
81124d90:	00801984 	movi	r2,102
81124d94:	8881f926 	beq	r17,r2,8112557c <___vfprintf_internal_r+0x1ec4>
81124d98:	00801184 	movi	r2,70
81124d9c:	88821c26 	beq	r17,r2,81125610 <___vfprintf_internal_r+0x1f58>
81124da0:	00801144 	movi	r2,69
81124da4:	b081ef26 	beq	r22,r2,81125564 <___vfprintf_internal_r+0x1eac>
81124da8:	d8c02917 	ldw	r3,164(sp)
81124dac:	d8802104 	addi	r2,sp,132
81124db0:	d8800315 	stw	r2,12(sp)
81124db4:	d9403617 	ldw	r5,216(sp)
81124db8:	d8802504 	addi	r2,sp,148
81124dbc:	d9002c17 	ldw	r4,176(sp)
81124dc0:	d8800215 	stw	r2,8(sp)
81124dc4:	d8802604 	addi	r2,sp,152
81124dc8:	d8c00015 	stw	r3,0(sp)
81124dcc:	d8800115 	stw	r2,4(sp)
81124dd0:	01c00084 	movi	r7,2
81124dd4:	980d883a 	mov	r6,r19
81124dd8:	d8c03c15 	stw	r3,240(sp)
81124ddc:	da003d15 	stw	r8,244(sp)
81124de0:	11277c40 	call	811277c4 <_dtoa_r>
81124de4:	1021883a 	mov	r16,r2
81124de8:	008019c4 	movi	r2,103
81124dec:	d8c03c17 	ldw	r3,240(sp)
81124df0:	da003d17 	ldw	r8,244(sp)
81124df4:	88817126 	beq	r17,r2,811253bc <___vfprintf_internal_r+0x1d04>
81124df8:	008011c4 	movi	r2,71
81124dfc:	88829226 	beq	r17,r2,81125848 <___vfprintf_internal_r+0x2190>
81124e00:	80f9883a 	add	fp,r16,r3
81124e04:	d9003617 	ldw	r4,216(sp)
81124e08:	000d883a 	mov	r6,zero
81124e0c:	000f883a 	mov	r7,zero
81124e10:	980b883a 	mov	r5,r19
81124e14:	da003d15 	stw	r8,244(sp)
81124e18:	11340740 	call	81134074 <__eqdf2>
81124e1c:	da003d17 	ldw	r8,244(sp)
81124e20:	10018d26 	beq	r2,zero,81125458 <___vfprintf_internal_r+0x1da0>
81124e24:	d8802117 	ldw	r2,132(sp)
81124e28:	1700062e 	bgeu	r2,fp,81124e44 <___vfprintf_internal_r+0x178c>
81124e2c:	01000c04 	movi	r4,48
81124e30:	10c00044 	addi	r3,r2,1
81124e34:	d8c02115 	stw	r3,132(sp)
81124e38:	11000005 	stb	r4,0(r2)
81124e3c:	d8802117 	ldw	r2,132(sp)
81124e40:	173ffb36 	bltu	r2,fp,81124e30 <__reset+0xfb104e30>
81124e44:	1405c83a 	sub	r2,r2,r16
81124e48:	d8803315 	stw	r2,204(sp)
81124e4c:	008011c4 	movi	r2,71
81124e50:	b0817626 	beq	r22,r2,8112542c <___vfprintf_internal_r+0x1d74>
81124e54:	00801944 	movi	r2,101
81124e58:	1442810e 	bge	r2,r17,81125860 <___vfprintf_internal_r+0x21a8>
81124e5c:	d8c02617 	ldw	r3,152(sp)
81124e60:	00801984 	movi	r2,102
81124e64:	d8c03215 	stw	r3,200(sp)
81124e68:	8881fe26 	beq	r17,r2,81125664 <___vfprintf_internal_r+0x1fac>
81124e6c:	d8c03217 	ldw	r3,200(sp)
81124e70:	d9003317 	ldw	r4,204(sp)
81124e74:	1901dd16 	blt	r3,r4,811255ec <___vfprintf_internal_r+0x1f34>
81124e78:	9480004c 	andi	r18,r18,1
81124e7c:	90022b1e 	bne	r18,zero,8112572c <___vfprintf_internal_r+0x2074>
81124e80:	1805883a 	mov	r2,r3
81124e84:	18028016 	blt	r3,zero,81125888 <___vfprintf_internal_r+0x21d0>
81124e88:	d8c03217 	ldw	r3,200(sp)
81124e8c:	044019c4 	movi	r17,103
81124e90:	d8c02e15 	stw	r3,184(sp)
81124e94:	df002a07 	ldb	fp,168(sp)
81124e98:	e001531e 	bne	fp,zero,811253e8 <___vfprintf_internal_r+0x1d30>
81124e9c:	df002783 	ldbu	fp,158(sp)
81124ea0:	d8802a15 	stw	r2,168(sp)
81124ea4:	dc802b17 	ldw	r18,172(sp)
81124ea8:	d8002915 	stw	zero,164(sp)
81124eac:	003bd106 	br	81123df4 <__reset+0xfb103df4>
81124eb0:	d8802d17 	ldw	r2,180(sp)
81124eb4:	d8c02d17 	ldw	r3,180(sp)
81124eb8:	d9002d17 	ldw	r4,180(sp)
81124ebc:	10800017 	ldw	r2,0(r2)
81124ec0:	18c00117 	ldw	r3,4(r3)
81124ec4:	21000204 	addi	r4,r4,8
81124ec8:	d8803615 	stw	r2,216(sp)
81124ecc:	d8c03815 	stw	r3,224(sp)
81124ed0:	d9002d15 	stw	r4,180(sp)
81124ed4:	003b7506 	br	81123cac <__reset+0xfb103cac>
81124ed8:	ac400007 	ldb	r17,0(r21)
81124edc:	003a5906 	br	81123844 <__reset+0xfb103844>
81124ee0:	9080100c 	andi	r2,r18,64
81124ee4:	1000a826 	beq	r2,zero,81125188 <___vfprintf_internal_r+0x1ad0>
81124ee8:	d9002d17 	ldw	r4,180(sp)
81124eec:	002d883a 	mov	r22,zero
81124ef0:	24c0000b 	ldhu	r19,0(r4)
81124ef4:	21000104 	addi	r4,r4,4
81124ef8:	d9002d15 	stw	r4,180(sp)
81124efc:	003ccb06 	br	8112422c <__reset+0xfb10422c>
81124f00:	d8c02d17 	ldw	r3,180(sp)
81124f04:	d9002917 	ldw	r4,164(sp)
81124f08:	002d883a 	mov	r22,zero
81124f0c:	18800104 	addi	r2,r3,4
81124f10:	1cc00017 	ldw	r19,0(r3)
81124f14:	203ebb0e 	bge	r4,zero,81124a04 <__reset+0xfb104a04>
81124f18:	003ef106 	br	81124ae0 <__reset+0xfb104ae0>
81124f1c:	9080040c 	andi	r2,r18,16
81124f20:	1000921e 	bne	r2,zero,8112516c <___vfprintf_internal_r+0x1ab4>
81124f24:	9480100c 	andi	r18,r18,64
81124f28:	90013926 	beq	r18,zero,81125410 <___vfprintf_internal_r+0x1d58>
81124f2c:	d9002d17 	ldw	r4,180(sp)
81124f30:	d9402f17 	ldw	r5,188(sp)
81124f34:	20800017 	ldw	r2,0(r4)
81124f38:	21000104 	addi	r4,r4,4
81124f3c:	d9002d15 	stw	r4,180(sp)
81124f40:	1140000d 	sth	r5,0(r2)
81124f44:	003a1606 	br	811237a0 <__reset+0xfb1037a0>
81124f48:	9080100c 	andi	r2,r18,64
81124f4c:	10008026 	beq	r2,zero,81125150 <___vfprintf_internal_r+0x1a98>
81124f50:	d8c02d17 	ldw	r3,180(sp)
81124f54:	1cc0000f 	ldh	r19,0(r3)
81124f58:	18c00104 	addi	r3,r3,4
81124f5c:	d8c02d15 	stw	r3,180(sp)
81124f60:	982dd7fa 	srai	r22,r19,31
81124f64:	b005883a 	mov	r2,r22
81124f68:	003b1f06 	br	81123be8 <__reset+0xfb103be8>
81124f6c:	9080100c 	andi	r2,r18,64
81124f70:	d8002785 	stb	zero,158(sp)
81124f74:	10008a1e 	bne	r2,zero,811251a0 <___vfprintf_internal_r+0x1ae8>
81124f78:	d9402d17 	ldw	r5,180(sp)
81124f7c:	d8c02917 	ldw	r3,164(sp)
81124f80:	002d883a 	mov	r22,zero
81124f84:	28800104 	addi	r2,r5,4
81124f88:	2cc00017 	ldw	r19,0(r5)
81124f8c:	183e4b0e 	bge	r3,zero,811248bc <__reset+0xfb1048bc>
81124f90:	9d86b03a 	or	r3,r19,r22
81124f94:	d8802d15 	stw	r2,180(sp)
81124f98:	183e4c1e 	bne	r3,zero,811248cc <__reset+0xfb1048cc>
81124f9c:	0039883a 	mov	fp,zero
81124fa0:	0005883a 	mov	r2,zero
81124fa4:	003d4006 	br	811244a8 <__reset+0xfb1044a8>
81124fa8:	01604574 	movhi	r5,33045
81124fac:	29790684 	addi	r5,r5,-7142
81124fb0:	d9402b15 	stw	r5,172(sp)
81124fb4:	d9402b17 	ldw	r5,172(sp)
81124fb8:	1c47883a 	add	r3,r3,r17
81124fbc:	10800044 	addi	r2,r2,1
81124fc0:	41400015 	stw	r5,0(r8)
81124fc4:	44400115 	stw	r17,4(r8)
81124fc8:	d8c02015 	stw	r3,128(sp)
81124fcc:	d8801f15 	stw	r2,124(sp)
81124fd0:	010001c4 	movi	r4,7
81124fd4:	20bec816 	blt	r4,r2,81124af8 <__reset+0xfb104af8>
81124fd8:	42000204 	addi	r8,r8,8
81124fdc:	003ecd06 	br	81124b14 <__reset+0xfb104b14>
81124fe0:	d9002917 	ldw	r4,164(sp)
81124fe4:	d8002785 	stb	zero,158(sp)
81124fe8:	203d2d16 	blt	r4,zero,811244a0 <__reset+0xfb1044a0>
81124fec:	00bfdfc4 	movi	r2,-129
81124ff0:	90a4703a 	and	r18,r18,r2
81124ff4:	003a9106 	br	81123a3c <__reset+0xfb103a3c>
81124ff8:	01204574 	movhi	r4,33045
81124ffc:	21390684 	addi	r4,r4,-7142
81125000:	d9002b15 	stw	r4,172(sp)
81125004:	003c0c06 	br	81124038 <__reset+0xfb104038>
81125008:	d9002c17 	ldw	r4,176(sp)
8112500c:	d9801e04 	addi	r6,sp,120
81125010:	b80b883a 	mov	r5,r23
81125014:	112f8a80 	call	8112f8a8 <__sprint_r>
81125018:	103aab1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
8112501c:	d8c02017 	ldw	r3,128(sp)
81125020:	da000404 	addi	r8,sp,16
81125024:	003d4106 	br	8112452c <__reset+0xfb10452c>
81125028:	d8801f17 	ldw	r2,124(sp)
8112502c:	01604574 	movhi	r5,33045
81125030:	01000044 	movi	r4,1
81125034:	18c00044 	addi	r3,r3,1
81125038:	10800044 	addi	r2,r2,1
8112503c:	2978fe04 	addi	r5,r5,-7176
81125040:	41000115 	stw	r4,4(r8)
81125044:	41400015 	stw	r5,0(r8)
81125048:	d8c02015 	stw	r3,128(sp)
8112504c:	d8801f15 	stw	r2,124(sp)
81125050:	010001c4 	movi	r4,7
81125054:	20805c16 	blt	r4,r2,811251c8 <___vfprintf_internal_r+0x1b10>
81125058:	42000204 	addi	r8,r8,8
8112505c:	8800041e 	bne	r17,zero,81125070 <___vfprintf_internal_r+0x19b8>
81125060:	d8803317 	ldw	r2,204(sp)
81125064:	1000021e 	bne	r2,zero,81125070 <___vfprintf_internal_r+0x19b8>
81125068:	9080004c 	andi	r2,r18,1
8112506c:	103c0926 	beq	r2,zero,81124094 <__reset+0xfb104094>
81125070:	d9003717 	ldw	r4,220(sp)
81125074:	d8801f17 	ldw	r2,124(sp)
81125078:	d9403417 	ldw	r5,208(sp)
8112507c:	20c7883a 	add	r3,r4,r3
81125080:	10800044 	addi	r2,r2,1
81125084:	41000115 	stw	r4,4(r8)
81125088:	41400015 	stw	r5,0(r8)
8112508c:	d8c02015 	stw	r3,128(sp)
81125090:	d8801f15 	stw	r2,124(sp)
81125094:	010001c4 	movi	r4,7
81125098:	20812116 	blt	r4,r2,81125520 <___vfprintf_internal_r+0x1e68>
8112509c:	42000204 	addi	r8,r8,8
811250a0:	0463c83a 	sub	r17,zero,r17
811250a4:	0440730e 	bge	zero,r17,81125274 <___vfprintf_internal_r+0x1bbc>
811250a8:	05800404 	movi	r22,16
811250ac:	b440860e 	bge	r22,r17,811252c8 <___vfprintf_internal_r+0x1c10>
811250b0:	01604574 	movhi	r5,33045
811250b4:	29790684 	addi	r5,r5,-7142
811250b8:	d9402b15 	stw	r5,172(sp)
811250bc:	070001c4 	movi	fp,7
811250c0:	dcc02c17 	ldw	r19,176(sp)
811250c4:	00000306 	br	811250d4 <___vfprintf_internal_r+0x1a1c>
811250c8:	42000204 	addi	r8,r8,8
811250cc:	8c7ffc04 	addi	r17,r17,-16
811250d0:	b440800e 	bge	r22,r17,811252d4 <___vfprintf_internal_r+0x1c1c>
811250d4:	18c00404 	addi	r3,r3,16
811250d8:	10800044 	addi	r2,r2,1
811250dc:	45000015 	stw	r20,0(r8)
811250e0:	45800115 	stw	r22,4(r8)
811250e4:	d8c02015 	stw	r3,128(sp)
811250e8:	d8801f15 	stw	r2,124(sp)
811250ec:	e0bff60e 	bge	fp,r2,811250c8 <__reset+0xfb1050c8>
811250f0:	d9801e04 	addi	r6,sp,120
811250f4:	b80b883a 	mov	r5,r23
811250f8:	9809883a 	mov	r4,r19
811250fc:	112f8a80 	call	8112f8a8 <__sprint_r>
81125100:	103a711e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81125104:	d8c02017 	ldw	r3,128(sp)
81125108:	d8801f17 	ldw	r2,124(sp)
8112510c:	da000404 	addi	r8,sp,16
81125110:	003fee06 	br	811250cc <__reset+0xfb1050cc>
81125114:	00bfffc4 	movi	r2,-1
81125118:	003a6f06 	br	81123ad8 <__reset+0xfb103ad8>
8112511c:	008011c4 	movi	r2,71
81125120:	1440b816 	blt	r2,r17,81125404 <___vfprintf_internal_r+0x1d4c>
81125124:	04204574 	movhi	r16,33045
81125128:	8438f004 	addi	r16,r16,-7232
8112512c:	00c000c4 	movi	r3,3
81125130:	00bfdfc4 	movi	r2,-129
81125134:	d8c02a15 	stw	r3,168(sp)
81125138:	90a4703a 	and	r18,r18,r2
8112513c:	df002783 	ldbu	fp,158(sp)
81125140:	d8c02e15 	stw	r3,184(sp)
81125144:	d8002915 	stw	zero,164(sp)
81125148:	d8003215 	stw	zero,200(sp)
8112514c:	003b2906 	br	81123df4 <__reset+0xfb103df4>
81125150:	d9002d17 	ldw	r4,180(sp)
81125154:	24c00017 	ldw	r19,0(r4)
81125158:	21000104 	addi	r4,r4,4
8112515c:	d9002d15 	stw	r4,180(sp)
81125160:	982dd7fa 	srai	r22,r19,31
81125164:	b005883a 	mov	r2,r22
81125168:	003a9f06 	br	81123be8 <__reset+0xfb103be8>
8112516c:	d9402d17 	ldw	r5,180(sp)
81125170:	d8c02f17 	ldw	r3,188(sp)
81125174:	28800017 	ldw	r2,0(r5)
81125178:	29400104 	addi	r5,r5,4
8112517c:	d9402d15 	stw	r5,180(sp)
81125180:	10c00015 	stw	r3,0(r2)
81125184:	00398606 	br	811237a0 <__reset+0xfb1037a0>
81125188:	d9402d17 	ldw	r5,180(sp)
8112518c:	002d883a 	mov	r22,zero
81125190:	2cc00017 	ldw	r19,0(r5)
81125194:	29400104 	addi	r5,r5,4
81125198:	d9402d15 	stw	r5,180(sp)
8112519c:	003c2306 	br	8112422c <__reset+0xfb10422c>
811251a0:	d8c02d17 	ldw	r3,180(sp)
811251a4:	d9002917 	ldw	r4,164(sp)
811251a8:	002d883a 	mov	r22,zero
811251ac:	18800104 	addi	r2,r3,4
811251b0:	1cc0000b 	ldhu	r19,0(r3)
811251b4:	203dc10e 	bge	r4,zero,811248bc <__reset+0xfb1048bc>
811251b8:	003f7506 	br	81124f90 <__reset+0xfb104f90>
811251bc:	04204574 	movhi	r16,33045
811251c0:	8438ee04 	addi	r16,r16,-7240
811251c4:	003acc06 	br	81123cf8 <__reset+0xfb103cf8>
811251c8:	d9002c17 	ldw	r4,176(sp)
811251cc:	d9801e04 	addi	r6,sp,120
811251d0:	b80b883a 	mov	r5,r23
811251d4:	112f8a80 	call	8112f8a8 <__sprint_r>
811251d8:	103a3b1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
811251dc:	dc402617 	ldw	r17,152(sp)
811251e0:	d8c02017 	ldw	r3,128(sp)
811251e4:	da000404 	addi	r8,sp,16
811251e8:	003f9c06 	br	8112505c <__reset+0xfb10505c>
811251ec:	ac400043 	ldbu	r17,1(r21)
811251f0:	94800814 	ori	r18,r18,32
811251f4:	ad400044 	addi	r21,r21,1
811251f8:	8c403fcc 	andi	r17,r17,255
811251fc:	8c40201c 	xori	r17,r17,128
81125200:	8c7fe004 	addi	r17,r17,-128
81125204:	00398f06 	br	81123844 <__reset+0xfb103844>
81125208:	d8c02d15 	stw	r3,180(sp)
8112520c:	0039883a 	mov	fp,zero
81125210:	003e3506 	br	81124ae8 <__reset+0xfb104ae8>
81125214:	d9002c17 	ldw	r4,176(sp)
81125218:	d9801e04 	addi	r6,sp,120
8112521c:	b80b883a 	mov	r5,r23
81125220:	112f8a80 	call	8112f8a8 <__sprint_r>
81125224:	103a281e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81125228:	d8c02017 	ldw	r3,128(sp)
8112522c:	da000404 	addi	r8,sp,16
81125230:	003cd006 	br	81124574 <__reset+0xfb104574>
81125234:	8009883a 	mov	r4,r16
81125238:	da003d15 	stw	r8,244(sp)
8112523c:	11211a00 	call	811211a0 <strlen>
81125240:	d8802e15 	stw	r2,184(sp)
81125244:	da003d17 	ldw	r8,244(sp)
81125248:	103c340e 	bge	r2,zero,8112431c <__reset+0xfb10431c>
8112524c:	0005883a 	mov	r2,zero
81125250:	003c3206 	br	8112431c <__reset+0xfb10431c>
81125254:	d9002c17 	ldw	r4,176(sp)
81125258:	d9801e04 	addi	r6,sp,120
8112525c:	b80b883a 	mov	r5,r23
81125260:	112f8a80 	call	8112f8a8 <__sprint_r>
81125264:	103a181e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81125268:	d8c02017 	ldw	r3,128(sp)
8112526c:	d8801f17 	ldw	r2,124(sp)
81125270:	da000404 	addi	r8,sp,16
81125274:	d9403317 	ldw	r5,204(sp)
81125278:	10800044 	addi	r2,r2,1
8112527c:	44000015 	stw	r16,0(r8)
81125280:	28c7883a 	add	r3,r5,r3
81125284:	003b7d06 	br	8112407c <__reset+0xfb10407c>
81125288:	01204574 	movhi	r4,33045
8112528c:	21390a84 	addi	r4,r4,-7126
81125290:	d9003515 	stw	r4,212(sp)
81125294:	003b1406 	br	81123ee8 <__reset+0xfb103ee8>
81125298:	013fffc4 	movi	r4,-1
8112529c:	003a3506 	br	81123b74 <__reset+0xfb103b74>
811252a0:	0023883a 	mov	r17,zero
811252a4:	003d9d06 	br	8112491c <__reset+0xfb10491c>
811252a8:	d9002c17 	ldw	r4,176(sp)
811252ac:	d9801e04 	addi	r6,sp,120
811252b0:	b80b883a 	mov	r5,r23
811252b4:	112f8a80 	call	8112f8a8 <__sprint_r>
811252b8:	103a031e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
811252bc:	d8c02017 	ldw	r3,128(sp)
811252c0:	da000404 	addi	r8,sp,16
811252c4:	003d9406 	br	81124918 <__reset+0xfb104918>
811252c8:	01204574 	movhi	r4,33045
811252cc:	21390684 	addi	r4,r4,-7142
811252d0:	d9002b15 	stw	r4,172(sp)
811252d4:	d9002b17 	ldw	r4,172(sp)
811252d8:	1c47883a 	add	r3,r3,r17
811252dc:	10800044 	addi	r2,r2,1
811252e0:	41000015 	stw	r4,0(r8)
811252e4:	44400115 	stw	r17,4(r8)
811252e8:	d8c02015 	stw	r3,128(sp)
811252ec:	d8801f15 	stw	r2,124(sp)
811252f0:	010001c4 	movi	r4,7
811252f4:	20bfd716 	blt	r4,r2,81125254 <__reset+0xfb105254>
811252f8:	42000204 	addi	r8,r8,8
811252fc:	003fdd06 	br	81125274 <__reset+0xfb105274>
81125300:	d9002c17 	ldw	r4,176(sp)
81125304:	d9801e04 	addi	r6,sp,120
81125308:	b80b883a 	mov	r5,r23
8112530c:	112f8a80 	call	8112f8a8 <__sprint_r>
81125310:	1039ed1e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81125314:	d8802617 	ldw	r2,152(sp)
81125318:	d8c02017 	ldw	r3,128(sp)
8112531c:	da000404 	addi	r8,sp,16
81125320:	003e1006 	br	81124b64 <__reset+0xfb104b64>
81125324:	00800044 	movi	r2,1
81125328:	10803fcc 	andi	r2,r2,255
8112532c:	00c00044 	movi	r3,1
81125330:	10fa3526 	beq	r2,r3,81123c08 <__reset+0xfb103c08>
81125334:	00c00084 	movi	r3,2
81125338:	10fbcb26 	beq	r2,r3,81124268 <__reset+0xfb104268>
8112533c:	003a8f06 	br	81123d7c <__reset+0xfb103d7c>
81125340:	01204574 	movhi	r4,33045
81125344:	21390a84 	addi	r4,r4,-7126
81125348:	d9003515 	stw	r4,212(sp)
8112534c:	003b7606 	br	81124128 <__reset+0xfb104128>
81125350:	d8802917 	ldw	r2,164(sp)
81125354:	00c00184 	movi	r3,6
81125358:	1880012e 	bgeu	r3,r2,81125360 <___vfprintf_internal_r+0x1ca8>
8112535c:	1805883a 	mov	r2,r3
81125360:	d8802e15 	stw	r2,184(sp)
81125364:	1000ef16 	blt	r2,zero,81125724 <___vfprintf_internal_r+0x206c>
81125368:	04204574 	movhi	r16,33045
8112536c:	d8802a15 	stw	r2,168(sp)
81125370:	dcc02d15 	stw	r19,180(sp)
81125374:	d8002915 	stw	zero,164(sp)
81125378:	d8003215 	stw	zero,200(sp)
8112537c:	8438fc04 	addi	r16,r16,-7184
81125380:	0039883a 	mov	fp,zero
81125384:	003aa206 	br	81123e10 <__reset+0xfb103e10>
81125388:	0021883a 	mov	r16,zero
8112538c:	003e0706 	br	81124bac <__reset+0xfb104bac>
81125390:	d9002c17 	ldw	r4,176(sp)
81125394:	d9801e04 	addi	r6,sp,120
81125398:	b80b883a 	mov	r5,r23
8112539c:	112f8a80 	call	8112f8a8 <__sprint_r>
811253a0:	1039c91e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
811253a4:	d8802617 	ldw	r2,152(sp)
811253a8:	d9403317 	ldw	r5,204(sp)
811253ac:	d8c02017 	ldw	r3,128(sp)
811253b0:	da000404 	addi	r8,sp,16
811253b4:	2885c83a 	sub	r2,r5,r2
811253b8:	003dfb06 	br	81124ba8 <__reset+0xfb104ba8>
811253bc:	9080004c 	andi	r2,r18,1
811253c0:	103e8f1e 	bne	r2,zero,81124e00 <__reset+0xfb104e00>
811253c4:	d8802117 	ldw	r2,132(sp)
811253c8:	003e9e06 	br	81124e44 <__reset+0xfb104e44>
811253cc:	1025883a 	mov	r18,r2
811253d0:	0039883a 	mov	fp,zero
811253d4:	00800084 	movi	r2,2
811253d8:	003fd306 	br	81125328 <__reset+0xfb105328>
811253dc:	07000b44 	movi	fp,45
811253e0:	df002785 	stb	fp,158(sp)
811253e4:	003a4006 	br	81123ce8 <__reset+0xfb103ce8>
811253e8:	00c00b44 	movi	r3,45
811253ec:	d8c02785 	stb	r3,158(sp)
811253f0:	d8802a15 	stw	r2,168(sp)
811253f4:	dc802b17 	ldw	r18,172(sp)
811253f8:	d8002915 	stw	zero,164(sp)
811253fc:	07000b44 	movi	fp,45
81125400:	003a8006 	br	81123e04 <__reset+0xfb103e04>
81125404:	04204574 	movhi	r16,33045
81125408:	8438f104 	addi	r16,r16,-7228
8112540c:	003f4706 	br	8112512c <__reset+0xfb10512c>
81125410:	d8c02d17 	ldw	r3,180(sp)
81125414:	d9002f17 	ldw	r4,188(sp)
81125418:	18800017 	ldw	r2,0(r3)
8112541c:	18c00104 	addi	r3,r3,4
81125420:	d8c02d15 	stw	r3,180(sp)
81125424:	11000015 	stw	r4,0(r2)
81125428:	0038dd06 	br	811237a0 <__reset+0xfb1037a0>
8112542c:	dd802617 	ldw	r22,152(sp)
81125430:	00bfff44 	movi	r2,-3
81125434:	b0801c16 	blt	r22,r2,811254a8 <___vfprintf_internal_r+0x1df0>
81125438:	d9402917 	ldw	r5,164(sp)
8112543c:	2d801a16 	blt	r5,r22,811254a8 <___vfprintf_internal_r+0x1df0>
81125440:	dd803215 	stw	r22,200(sp)
81125444:	003e8906 	br	81124e6c <__reset+0xfb104e6c>
81125448:	01204574 	movhi	r4,33045
8112544c:	21390684 	addi	r4,r4,-7142
81125450:	d9002b15 	stw	r4,172(sp)
81125454:	003c9106 	br	8112469c <__reset+0xfb10469c>
81125458:	e005883a 	mov	r2,fp
8112545c:	003e7906 	br	81124e44 <__reset+0xfb104e44>
81125460:	d9402917 	ldw	r5,164(sp)
81125464:	df002783 	ldbu	fp,158(sp)
81125468:	dcc02d15 	stw	r19,180(sp)
8112546c:	d9402a15 	stw	r5,168(sp)
81125470:	d9402e15 	stw	r5,184(sp)
81125474:	d8002915 	stw	zero,164(sp)
81125478:	d8003215 	stw	zero,200(sp)
8112547c:	003a5d06 	br	81123df4 <__reset+0xfb103df4>
81125480:	9080004c 	andi	r2,r18,1
81125484:	0039883a 	mov	fp,zero
81125488:	10000426 	beq	r2,zero,8112549c <___vfprintf_internal_r+0x1de4>
8112548c:	00800c04 	movi	r2,48
81125490:	dc001dc4 	addi	r16,sp,119
81125494:	d8801dc5 	stb	r2,119(sp)
81125498:	003b8006 	br	8112429c <__reset+0xfb10429c>
8112549c:	d8002e15 	stw	zero,184(sp)
811254a0:	dc001e04 	addi	r16,sp,120
811254a4:	003a4d06 	br	81123ddc <__reset+0xfb103ddc>
811254a8:	8c7fff84 	addi	r17,r17,-2
811254ac:	b5bfffc4 	addi	r22,r22,-1
811254b0:	dd802615 	stw	r22,152(sp)
811254b4:	dc4022c5 	stb	r17,139(sp)
811254b8:	b000bf16 	blt	r22,zero,811257b8 <___vfprintf_internal_r+0x2100>
811254bc:	00800ac4 	movi	r2,43
811254c0:	d8802305 	stb	r2,140(sp)
811254c4:	00800244 	movi	r2,9
811254c8:	15807016 	blt	r2,r22,8112568c <___vfprintf_internal_r+0x1fd4>
811254cc:	00800c04 	movi	r2,48
811254d0:	b5800c04 	addi	r22,r22,48
811254d4:	d8802345 	stb	r2,141(sp)
811254d8:	dd802385 	stb	r22,142(sp)
811254dc:	d88023c4 	addi	r2,sp,143
811254e0:	df0022c4 	addi	fp,sp,139
811254e4:	d8c03317 	ldw	r3,204(sp)
811254e8:	1739c83a 	sub	fp,r2,fp
811254ec:	d9003317 	ldw	r4,204(sp)
811254f0:	e0c7883a 	add	r3,fp,r3
811254f4:	df003a15 	stw	fp,232(sp)
811254f8:	d8c02e15 	stw	r3,184(sp)
811254fc:	00800044 	movi	r2,1
81125500:	1100b30e 	bge	r2,r4,811257d0 <___vfprintf_internal_r+0x2118>
81125504:	d8c02e17 	ldw	r3,184(sp)
81125508:	18c00044 	addi	r3,r3,1
8112550c:	d8c02e15 	stw	r3,184(sp)
81125510:	1805883a 	mov	r2,r3
81125514:	1800ac16 	blt	r3,zero,811257c8 <___vfprintf_internal_r+0x2110>
81125518:	d8003215 	stw	zero,200(sp)
8112551c:	003e5d06 	br	81124e94 <__reset+0xfb104e94>
81125520:	d9002c17 	ldw	r4,176(sp)
81125524:	d9801e04 	addi	r6,sp,120
81125528:	b80b883a 	mov	r5,r23
8112552c:	112f8a80 	call	8112f8a8 <__sprint_r>
81125530:	1039651e 	bne	r2,zero,81123ac8 <__reset+0xfb103ac8>
81125534:	dc402617 	ldw	r17,152(sp)
81125538:	d8c02017 	ldw	r3,128(sp)
8112553c:	d8801f17 	ldw	r2,124(sp)
81125540:	da000404 	addi	r8,sp,16
81125544:	003ed606 	br	811250a0 <__reset+0xfb1050a0>
81125548:	582b883a 	mov	r21,r11
8112554c:	d8002915 	stw	zero,164(sp)
81125550:	0038bd06 	br	81123848 <__reset+0xfb103848>
81125554:	d8802917 	ldw	r2,164(sp)
81125558:	103e071e 	bne	r2,zero,81124d78 <__reset+0xfb104d78>
8112555c:	dc002915 	stw	r16,164(sp)
81125560:	003e0506 	br	81124d78 <__reset+0xfb104d78>
81125564:	d9002917 	ldw	r4,164(sp)
81125568:	20c00044 	addi	r3,r4,1
8112556c:	003e0f06 	br	81124dac <__reset+0xfb104dac>
81125570:	01400184 	movi	r5,6
81125574:	d9402915 	stw	r5,164(sp)
81125578:	003dff06 	br	81124d78 <__reset+0xfb104d78>
8112557c:	d8802104 	addi	r2,sp,132
81125580:	d8800315 	stw	r2,12(sp)
81125584:	d8802504 	addi	r2,sp,148
81125588:	d8800215 	stw	r2,8(sp)
8112558c:	d8802604 	addi	r2,sp,152
81125590:	d8800115 	stw	r2,4(sp)
81125594:	d8802917 	ldw	r2,164(sp)
81125598:	d9403617 	ldw	r5,216(sp)
8112559c:	d9002c17 	ldw	r4,176(sp)
811255a0:	d8800015 	stw	r2,0(sp)
811255a4:	01c000c4 	movi	r7,3
811255a8:	980d883a 	mov	r6,r19
811255ac:	da003d15 	stw	r8,244(sp)
811255b0:	11277c40 	call	811277c4 <_dtoa_r>
811255b4:	d8c02917 	ldw	r3,164(sp)
811255b8:	da003d17 	ldw	r8,244(sp)
811255bc:	1021883a 	mov	r16,r2
811255c0:	10f9883a 	add	fp,r2,r3
811255c4:	81000007 	ldb	r4,0(r16)
811255c8:	00800c04 	movi	r2,48
811255cc:	20805e26 	beq	r4,r2,81125748 <___vfprintf_internal_r+0x2090>
811255d0:	d8c02617 	ldw	r3,152(sp)
811255d4:	e0f9883a 	add	fp,fp,r3
811255d8:	003e0a06 	br	81124e04 <__reset+0xfb104e04>
811255dc:	00c00b44 	movi	r3,45
811255e0:	24e0003c 	xorhi	r19,r4,32768
811255e4:	d8c02a05 	stb	r3,168(sp)
811255e8:	003de906 	br	81124d90 <__reset+0xfb104d90>
811255ec:	d8c03217 	ldw	r3,200(sp)
811255f0:	00c07a0e 	bge	zero,r3,811257dc <___vfprintf_internal_r+0x2124>
811255f4:	00800044 	movi	r2,1
811255f8:	d9003317 	ldw	r4,204(sp)
811255fc:	1105883a 	add	r2,r2,r4
81125600:	d8802e15 	stw	r2,184(sp)
81125604:	10004e16 	blt	r2,zero,81125740 <___vfprintf_internal_r+0x2088>
81125608:	044019c4 	movi	r17,103
8112560c:	003e2106 	br	81124e94 <__reset+0xfb104e94>
81125610:	d9002917 	ldw	r4,164(sp)
81125614:	d8802104 	addi	r2,sp,132
81125618:	d8800315 	stw	r2,12(sp)
8112561c:	d9000015 	stw	r4,0(sp)
81125620:	d8802504 	addi	r2,sp,148
81125624:	d9403617 	ldw	r5,216(sp)
81125628:	d9002c17 	ldw	r4,176(sp)
8112562c:	d8800215 	stw	r2,8(sp)
81125630:	d8802604 	addi	r2,sp,152
81125634:	d8800115 	stw	r2,4(sp)
81125638:	01c000c4 	movi	r7,3
8112563c:	980d883a 	mov	r6,r19
81125640:	da003d15 	stw	r8,244(sp)
81125644:	11277c40 	call	811277c4 <_dtoa_r>
81125648:	d8c02917 	ldw	r3,164(sp)
8112564c:	da003d17 	ldw	r8,244(sp)
81125650:	1021883a 	mov	r16,r2
81125654:	00801184 	movi	r2,70
81125658:	80f9883a 	add	fp,r16,r3
8112565c:	88bfd926 	beq	r17,r2,811255c4 <__reset+0xfb1055c4>
81125660:	003de806 	br	81124e04 <__reset+0xfb104e04>
81125664:	d9002917 	ldw	r4,164(sp)
81125668:	00c04d0e 	bge	zero,r3,811257a0 <___vfprintf_internal_r+0x20e8>
8112566c:	2000441e 	bne	r4,zero,81125780 <___vfprintf_internal_r+0x20c8>
81125670:	9480004c 	andi	r18,r18,1
81125674:	9000421e 	bne	r18,zero,81125780 <___vfprintf_internal_r+0x20c8>
81125678:	1805883a 	mov	r2,r3
8112567c:	18007016 	blt	r3,zero,81125840 <___vfprintf_internal_r+0x2188>
81125680:	d8c03217 	ldw	r3,200(sp)
81125684:	d8c02e15 	stw	r3,184(sp)
81125688:	003e0206 	br	81124e94 <__reset+0xfb104e94>
8112568c:	df0022c4 	addi	fp,sp,139
81125690:	dc002915 	stw	r16,164(sp)
81125694:	4027883a 	mov	r19,r8
81125698:	e021883a 	mov	r16,fp
8112569c:	b009883a 	mov	r4,r22
811256a0:	01400284 	movi	r5,10
811256a4:	1132ba40 	call	81132ba4 <__modsi3>
811256a8:	10800c04 	addi	r2,r2,48
811256ac:	843fffc4 	addi	r16,r16,-1
811256b0:	b009883a 	mov	r4,r22
811256b4:	01400284 	movi	r5,10
811256b8:	80800005 	stb	r2,0(r16)
811256bc:	1132b200 	call	81132b20 <__divsi3>
811256c0:	102d883a 	mov	r22,r2
811256c4:	00800244 	movi	r2,9
811256c8:	15bff416 	blt	r2,r22,8112569c <__reset+0xfb10569c>
811256cc:	9811883a 	mov	r8,r19
811256d0:	b0800c04 	addi	r2,r22,48
811256d4:	8027883a 	mov	r19,r16
811256d8:	997fffc4 	addi	r5,r19,-1
811256dc:	98bfffc5 	stb	r2,-1(r19)
811256e0:	dc002917 	ldw	r16,164(sp)
811256e4:	2f006a2e 	bgeu	r5,fp,81125890 <___vfprintf_internal_r+0x21d8>
811256e8:	d9c02384 	addi	r7,sp,142
811256ec:	3ccfc83a 	sub	r7,r7,r19
811256f0:	d9002344 	addi	r4,sp,141
811256f4:	e1cf883a 	add	r7,fp,r7
811256f8:	00000106 	br	81125700 <___vfprintf_internal_r+0x2048>
811256fc:	28800003 	ldbu	r2,0(r5)
81125700:	20800005 	stb	r2,0(r4)
81125704:	21000044 	addi	r4,r4,1
81125708:	29400044 	addi	r5,r5,1
8112570c:	393ffb1e 	bne	r7,r4,811256fc <__reset+0xfb1056fc>
81125710:	d8802304 	addi	r2,sp,140
81125714:	14c5c83a 	sub	r2,r2,r19
81125718:	d8c02344 	addi	r3,sp,141
8112571c:	1885883a 	add	r2,r3,r2
81125720:	003f7006 	br	811254e4 <__reset+0xfb1054e4>
81125724:	0005883a 	mov	r2,zero
81125728:	003f0f06 	br	81125368 <__reset+0xfb105368>
8112572c:	d8c03217 	ldw	r3,200(sp)
81125730:	18c00044 	addi	r3,r3,1
81125734:	d8c02e15 	stw	r3,184(sp)
81125738:	1805883a 	mov	r2,r3
8112573c:	183fb20e 	bge	r3,zero,81125608 <__reset+0xfb105608>
81125740:	0005883a 	mov	r2,zero
81125744:	003fb006 	br	81125608 <__reset+0xfb105608>
81125748:	d9003617 	ldw	r4,216(sp)
8112574c:	000d883a 	mov	r6,zero
81125750:	000f883a 	mov	r7,zero
81125754:	980b883a 	mov	r5,r19
81125758:	d8c03c15 	stw	r3,240(sp)
8112575c:	da003d15 	stw	r8,244(sp)
81125760:	11340740 	call	81134074 <__eqdf2>
81125764:	d8c03c17 	ldw	r3,240(sp)
81125768:	da003d17 	ldw	r8,244(sp)
8112576c:	103f9826 	beq	r2,zero,811255d0 <__reset+0xfb1055d0>
81125770:	00800044 	movi	r2,1
81125774:	10c7c83a 	sub	r3,r2,r3
81125778:	d8c02615 	stw	r3,152(sp)
8112577c:	003f9506 	br	811255d4 <__reset+0xfb1055d4>
81125780:	d9002917 	ldw	r4,164(sp)
81125784:	d8c03217 	ldw	r3,200(sp)
81125788:	20800044 	addi	r2,r4,1
8112578c:	1885883a 	add	r2,r3,r2
81125790:	d8802e15 	stw	r2,184(sp)
81125794:	103dbf0e 	bge	r2,zero,81124e94 <__reset+0xfb104e94>
81125798:	0005883a 	mov	r2,zero
8112579c:	003dbd06 	br	81124e94 <__reset+0xfb104e94>
811257a0:	2000211e 	bne	r4,zero,81125828 <___vfprintf_internal_r+0x2170>
811257a4:	9480004c 	andi	r18,r18,1
811257a8:	90001f1e 	bne	r18,zero,81125828 <___vfprintf_internal_r+0x2170>
811257ac:	00800044 	movi	r2,1
811257b0:	d8802e15 	stw	r2,184(sp)
811257b4:	003db706 	br	81124e94 <__reset+0xfb104e94>
811257b8:	00800b44 	movi	r2,45
811257bc:	05adc83a 	sub	r22,zero,r22
811257c0:	d8802305 	stb	r2,140(sp)
811257c4:	003f3f06 	br	811254c4 <__reset+0xfb1054c4>
811257c8:	0005883a 	mov	r2,zero
811257cc:	003f5206 	br	81125518 <__reset+0xfb105518>
811257d0:	90a4703a 	and	r18,r18,r2
811257d4:	903f4e26 	beq	r18,zero,81125510 <__reset+0xfb105510>
811257d8:	003f4a06 	br	81125504 <__reset+0xfb105504>
811257dc:	00800084 	movi	r2,2
811257e0:	10c5c83a 	sub	r2,r2,r3
811257e4:	003f8406 	br	811255f8 <__reset+0xfb1055f8>
811257e8:	d8802d17 	ldw	r2,180(sp)
811257ec:	d9002d17 	ldw	r4,180(sp)
811257f0:	ac400043 	ldbu	r17,1(r21)
811257f4:	10800017 	ldw	r2,0(r2)
811257f8:	582b883a 	mov	r21,r11
811257fc:	d8802915 	stw	r2,164(sp)
81125800:	20800104 	addi	r2,r4,4
81125804:	d9002917 	ldw	r4,164(sp)
81125808:	d8802d15 	stw	r2,180(sp)
8112580c:	203e7a0e 	bge	r4,zero,811251f8 <__reset+0xfb1051f8>
81125810:	8c403fcc 	andi	r17,r17,255
81125814:	00bfffc4 	movi	r2,-1
81125818:	8c40201c 	xori	r17,r17,128
8112581c:	d8802915 	stw	r2,164(sp)
81125820:	8c7fe004 	addi	r17,r17,-128
81125824:	00380706 	br	81123844 <__reset+0xfb103844>
81125828:	d8c02917 	ldw	r3,164(sp)
8112582c:	18c00084 	addi	r3,r3,2
81125830:	d8c02e15 	stw	r3,184(sp)
81125834:	1805883a 	mov	r2,r3
81125838:	183d960e 	bge	r3,zero,81124e94 <__reset+0xfb104e94>
8112583c:	003fd606 	br	81125798 <__reset+0xfb105798>
81125840:	0005883a 	mov	r2,zero
81125844:	003f8e06 	br	81125680 <__reset+0xfb105680>
81125848:	9080004c 	andi	r2,r18,1
8112584c:	103f811e 	bne	r2,zero,81125654 <__reset+0xfb105654>
81125850:	d8802117 	ldw	r2,132(sp)
81125854:	1405c83a 	sub	r2,r2,r16
81125858:	d8803315 	stw	r2,204(sp)
8112585c:	b47ef326 	beq	r22,r17,8112542c <__reset+0xfb10542c>
81125860:	dd802617 	ldw	r22,152(sp)
81125864:	003f1106 	br	811254ac <__reset+0xfb1054ac>
81125868:	d9c02785 	stb	r7,158(sp)
8112586c:	00390406 	br	81123c80 <__reset+0xfb103c80>
81125870:	d9c02785 	stb	r7,158(sp)
81125874:	0038d306 	br	81123bc4 <__reset+0xfb103bc4>
81125878:	d9c02785 	stb	r7,158(sp)
8112587c:	003a6106 	br	81124204 <__reset+0xfb104204>
81125880:	d9c02785 	stb	r7,158(sp)
81125884:	003af806 	br	81124468 <__reset+0xfb104468>
81125888:	0005883a 	mov	r2,zero
8112588c:	003d7e06 	br	81124e88 <__reset+0xfb104e88>
81125890:	d8802344 	addi	r2,sp,141
81125894:	003f1306 	br	811254e4 <__reset+0xfb1054e4>
81125898:	d9c02785 	stb	r7,158(sp)
8112589c:	00392306 	br	81123d2c <__reset+0xfb103d2c>
811258a0:	d9c02785 	stb	r7,158(sp)
811258a4:	003aa906 	br	8112434c <__reset+0xfb10434c>
811258a8:	d9c02785 	stb	r7,158(sp)
811258ac:	003a3d06 	br	811241a4 <__reset+0xfb1041a4>
811258b0:	d9c02785 	stb	r7,158(sp)
811258b4:	003aca06 	br	811243e0 <__reset+0xfb1043e0>

811258b8 <__vfprintf_internal>:
811258b8:	00a04574 	movhi	r2,33045
811258bc:	1082c604 	addi	r2,r2,2840
811258c0:	300f883a 	mov	r7,r6
811258c4:	280d883a 	mov	r6,r5
811258c8:	200b883a 	mov	r5,r4
811258cc:	11000017 	ldw	r4,0(r2)
811258d0:	11236b81 	jmpi	811236b8 <___vfprintf_internal_r>

811258d4 <__sbprintf>:
811258d4:	defee204 	addi	sp,sp,-1144
811258d8:	de00012e 	bgeu	sp,et,811258e0 <__sbprintf+0xc>
811258dc:	003b68fa 	trap	3
811258e0:	2880030b 	ldhu	r2,12(r5)
811258e4:	2ac01917 	ldw	r11,100(r5)
811258e8:	2a80038b 	ldhu	r10,14(r5)
811258ec:	2a400717 	ldw	r9,28(r5)
811258f0:	2a000917 	ldw	r8,36(r5)
811258f4:	00c10004 	movi	r3,1024
811258f8:	dc011a15 	stw	r16,1128(sp)
811258fc:	10bfff4c 	andi	r2,r2,65533
81125900:	2821883a 	mov	r16,r5
81125904:	d8cb883a 	add	r5,sp,r3
81125908:	dc811c15 	stw	r18,1136(sp)
8112590c:	dc411b15 	stw	r17,1132(sp)
81125910:	dfc11d15 	stw	ra,1140(sp)
81125914:	2025883a 	mov	r18,r4
81125918:	d881030d 	sth	r2,1036(sp)
8112591c:	dac11915 	stw	r11,1124(sp)
81125920:	da81038d 	sth	r10,1038(sp)
81125924:	da410715 	stw	r9,1052(sp)
81125928:	da010915 	stw	r8,1060(sp)
8112592c:	dec10015 	stw	sp,1024(sp)
81125930:	dec10415 	stw	sp,1040(sp)
81125934:	d8c10215 	stw	r3,1032(sp)
81125938:	d8c10515 	stw	r3,1044(sp)
8112593c:	d8010615 	stw	zero,1048(sp)
81125940:	11236b80 	call	811236b8 <___vfprintf_internal_r>
81125944:	1023883a 	mov	r17,r2
81125948:	10000416 	blt	r2,zero,8112595c <__sbprintf+0x88>
8112594c:	d9410004 	addi	r5,sp,1024
81125950:	9009883a 	mov	r4,r18
81125954:	11290780 	call	81129078 <_fflush_r>
81125958:	10000d1e 	bne	r2,zero,81125990 <__sbprintf+0xbc>
8112595c:	d881030b 	ldhu	r2,1036(sp)
81125960:	1080100c 	andi	r2,r2,64
81125964:	10000326 	beq	r2,zero,81125974 <__sbprintf+0xa0>
81125968:	8080030b 	ldhu	r2,12(r16)
8112596c:	10801014 	ori	r2,r2,64
81125970:	8080030d 	sth	r2,12(r16)
81125974:	8805883a 	mov	r2,r17
81125978:	dfc11d17 	ldw	ra,1140(sp)
8112597c:	dc811c17 	ldw	r18,1136(sp)
81125980:	dc411b17 	ldw	r17,1132(sp)
81125984:	dc011a17 	ldw	r16,1128(sp)
81125988:	dec11e04 	addi	sp,sp,1144
8112598c:	f800283a 	ret
81125990:	047fffc4 	movi	r17,-1
81125994:	003ff106 	br	8112595c <__reset+0xfb10595c>

81125998 <__svfscanf_r>:
81125998:	deff4b04 	addi	sp,sp,-724
8112599c:	de00012e 	bgeu	sp,et,811259a4 <__svfscanf_r+0xc>
811259a0:	003b68fa 	trap	3
811259a4:	2880030b 	ldhu	r2,12(r5)
811259a8:	df00b315 	stw	fp,716(sp)
811259ac:	dd80b115 	stw	r22,708(sp)
811259b0:	dfc0b415 	stw	ra,720(sp)
811259b4:	ddc0b215 	stw	r23,712(sp)
811259b8:	dd40b015 	stw	r21,704(sp)
811259bc:	dd00af15 	stw	r20,700(sp)
811259c0:	dcc0ae15 	stw	r19,696(sp)
811259c4:	dc80ad15 	stw	r18,692(sp)
811259c8:	dc40ac15 	stw	r17,688(sp)
811259cc:	dc00ab15 	stw	r16,684(sp)
811259d0:	10c8000c 	andi	r3,r2,8192
811259d4:	d9c09c15 	stw	r7,624(sp)
811259d8:	2839883a 	mov	fp,r5
811259dc:	202d883a 	mov	r22,r4
811259e0:	1800061e 	bne	r3,zero,811259fc <__svfscanf_r+0x64>
811259e4:	29001917 	ldw	r4,100(r5)
811259e8:	00f7ffc4 	movi	r3,-8193
811259ec:	10880014 	ori	r2,r2,8192
811259f0:	20c6703a 	and	r3,r4,r3
811259f4:	2880030d 	sth	r2,12(r5)
811259f8:	28c01915 	stw	r3,100(r5)
811259fc:	30800003 	ldbu	r2,0(r6)
81125a00:	0021883a 	mov	r16,zero
81125a04:	05e04574 	movhi	r23,33045
81125a08:	d800a115 	stw	zero,644(sp)
81125a0c:	d8009e15 	stw	zero,632(sp)
81125a10:	d800a015 	stw	zero,640(sp)
81125a14:	d8809b15 	stw	r2,620(sp)
81125a18:	bdc2c404 	addi	r23,r23,2832
81125a1c:	8025883a 	mov	r18,r16
81125a20:	35000044 	addi	r20,r6,1
81125a24:	10001e26 	beq	r2,zero,81125aa0 <__svfscanf_r+0x108>
81125a28:	b9c00017 	ldw	r7,0(r23)
81125a2c:	3887883a 	add	r3,r7,r2
81125a30:	18c00043 	ldbu	r3,1(r3)
81125a34:	18c0020c 	andi	r3,r3,8
81125a38:	18001b26 	beq	r3,zero,81125aa8 <__svfscanf_r+0x110>
81125a3c:	e0800117 	ldw	r2,4(fp)
81125a40:	00800e0e 	bge	zero,r2,81125a7c <__svfscanf_r+0xe4>
81125a44:	e0c00017 	ldw	r3,0(fp)
81125a48:	b9000017 	ldw	r4,0(r23)
81125a4c:	18800003 	ldbu	r2,0(r3)
81125a50:	2085883a 	add	r2,r4,r2
81125a54:	10800043 	ldbu	r2,1(r2)
81125a58:	1080020c 	andi	r2,r2,8
81125a5c:	10000b26 	beq	r2,zero,81125a8c <__svfscanf_r+0xf4>
81125a60:	e0800117 	ldw	r2,4(fp)
81125a64:	18c00044 	addi	r3,r3,1
81125a68:	e0c00015 	stw	r3,0(fp)
81125a6c:	10bfffc4 	addi	r2,r2,-1
81125a70:	e0800115 	stw	r2,4(fp)
81125a74:	94800044 	addi	r18,r18,1
81125a78:	00bff216 	blt	zero,r2,81125a44 <__reset+0xfb105a44>
81125a7c:	e00b883a 	mov	r5,fp
81125a80:	b009883a 	mov	r4,r22
81125a84:	1120c780 	call	81120c78 <__srefill_r>
81125a88:	103fee26 	beq	r2,zero,81125a44 <__reset+0xfb105a44>
81125a8c:	a00d883a 	mov	r6,r20
81125a90:	30800003 	ldbu	r2,0(r6)
81125a94:	35000044 	addi	r20,r6,1
81125a98:	d8809b15 	stw	r2,620(sp)
81125a9c:	103fe21e 	bne	r2,zero,81125a28 <__reset+0xfb105a28>
81125aa0:	d880a017 	ldw	r2,640(sp)
81125aa4:	00009906 	br	81125d0c <__svfscanf_r+0x374>
81125aa8:	00c00944 	movi	r3,37
81125aac:	10c0881e 	bne	r2,r3,81125cd0 <__svfscanf_r+0x338>
81125ab0:	30c00043 	ldbu	r3,1(r6)
81125ab4:	0023883a 	mov	r17,zero
81125ab8:	0027883a 	mov	r19,zero
81125abc:	01001e04 	movi	r4,120
81125ac0:	01401b04 	movi	r5,108
81125ac4:	a1800044 	addi	r6,r20,1
81125ac8:	20c0a236 	bltu	r4,r3,81125d54 <__svfscanf_r+0x3bc>
81125acc:	180490ba 	slli	r2,r3,2
81125ad0:	022044b4 	movhi	r8,33042
81125ad4:	4216b904 	addi	r8,r8,23268
81125ad8:	1205883a 	add	r2,r2,r8
81125adc:	10800017 	ldw	r2,0(r2)
81125ae0:	1000683a 	jmp	r2
81125ae4:	81125d08 	cmpgei	r4,r16,18804
81125ae8:	81125d54 	ori	r4,r16,18805
81125aec:	81125d54 	ori	r4,r16,18805
81125af0:	81125d54 	ori	r4,r16,18805
81125af4:	81125d54 	ori	r4,r16,18805
81125af8:	81125d54 	ori	r4,r16,18805
81125afc:	81125d54 	ori	r4,r16,18805
81125b00:	81125d54 	ori	r4,r16,18805
81125b04:	81125d54 	ori	r4,r16,18805
81125b08:	81125d54 	ori	r4,r16,18805
81125b0c:	81125d54 	ori	r4,r16,18805
81125b10:	81125d54 	ori	r4,r16,18805
81125b14:	81125d54 	ori	r4,r16,18805
81125b18:	81125d54 	ori	r4,r16,18805
81125b1c:	81125d54 	ori	r4,r16,18805
81125b20:	81125d54 	ori	r4,r16,18805
81125b24:	81125d54 	ori	r4,r16,18805
81125b28:	81125d54 	ori	r4,r16,18805
81125b2c:	81125d54 	ori	r4,r16,18805
81125b30:	81125d54 	ori	r4,r16,18805
81125b34:	81125d54 	ori	r4,r16,18805
81125b38:	81125d54 	ori	r4,r16,18805
81125b3c:	81125d54 	ori	r4,r16,18805
81125b40:	81125d54 	ori	r4,r16,18805
81125b44:	81125d54 	ori	r4,r16,18805
81125b48:	81125d54 	ori	r4,r16,18805
81125b4c:	81125d54 	ori	r4,r16,18805
81125b50:	81125d54 	ori	r4,r16,18805
81125b54:	81125d54 	ori	r4,r16,18805
81125b58:	81125d54 	ori	r4,r16,18805
81125b5c:	81125d54 	ori	r4,r16,18805
81125b60:	81125d54 	ori	r4,r16,18805
81125b64:	81125d54 	ori	r4,r16,18805
81125b68:	81125d54 	ori	r4,r16,18805
81125b6c:	81125d54 	ori	r4,r16,18805
81125b70:	81125d54 	ori	r4,r16,18805
81125b74:	81125d54 	ori	r4,r16,18805
81125b78:	81125cc8 	cmpgei	r4,r16,18803
81125b7c:	81125d54 	ori	r4,r16,18805
81125b80:	81125d54 	ori	r4,r16,18805
81125b84:	81125d54 	ori	r4,r16,18805
81125b88:	81125d54 	ori	r4,r16,18805
81125b8c:	81125d3c 	xorhi	r4,r16,18804
81125b90:	81125d54 	ori	r4,r16,18805
81125b94:	81125d54 	ori	r4,r16,18805
81125b98:	81125d54 	ori	r4,r16,18805
81125b9c:	81125d54 	ori	r4,r16,18805
81125ba0:	81125d54 	ori	r4,r16,18805
81125ba4:	81125e70 	cmpltui	r4,r16,18809
81125ba8:	81125e70 	cmpltui	r4,r16,18809
81125bac:	81125e70 	cmpltui	r4,r16,18809
81125bb0:	81125e70 	cmpltui	r4,r16,18809
81125bb4:	81125e70 	cmpltui	r4,r16,18809
81125bb8:	81125e70 	cmpltui	r4,r16,18809
81125bbc:	81125e70 	cmpltui	r4,r16,18809
81125bc0:	81125e70 	cmpltui	r4,r16,18809
81125bc4:	81125e70 	cmpltui	r4,r16,18809
81125bc8:	81125e70 	cmpltui	r4,r16,18809
81125bcc:	81125d54 	ori	r4,r16,18805
81125bd0:	81125d54 	ori	r4,r16,18805
81125bd4:	81125d54 	ori	r4,r16,18805
81125bd8:	81125d54 	ori	r4,r16,18805
81125bdc:	81125d54 	ori	r4,r16,18805
81125be0:	81125d54 	ori	r4,r16,18805
81125be4:	81125d54 	ori	r4,r16,18805
81125be8:	81125d54 	ori	r4,r16,18805
81125bec:	81125d54 	ori	r4,r16,18805
81125bf0:	81125d54 	ori	r4,r16,18805
81125bf4:	81125e44 	addi	r4,r16,18809
81125bf8:	81125ef4 	orhi	r4,r16,18811
81125bfc:	81125d54 	ori	r4,r16,18805
81125c00:	81125ef4 	orhi	r4,r16,18811
81125c04:	81125d54 	ori	r4,r16,18805
81125c08:	81125d54 	ori	r4,r16,18805
81125c0c:	81125d54 	ori	r4,r16,18805
81125c10:	81125d54 	ori	r4,r16,18805
81125c14:	81125ee0 	cmpeqi	r4,r16,18811
81125c18:	81125d54 	ori	r4,r16,18805
81125c1c:	81125d54 	ori	r4,r16,18805
81125c20:	81125eb4 	orhi	r4,r16,18810
81125c24:	81125d54 	ori	r4,r16,18805
81125c28:	81125d54 	ori	r4,r16,18805
81125c2c:	81125d54 	ori	r4,r16,18805
81125c30:	81125d54 	ori	r4,r16,18805
81125c34:	81125d54 	ori	r4,r16,18805
81125c38:	81125d54 	ori	r4,r16,18805
81125c3c:	81125d54 	ori	r4,r16,18805
81125c40:	81125d54 	ori	r4,r16,18805
81125c44:	81125e8c 	andi	r4,r16,18810
81125c48:	81125d54 	ori	r4,r16,18805
81125c4c:	81125d54 	ori	r4,r16,18805
81125c50:	81126028 	cmpgeui	r4,r16,18816
81125c54:	81125d54 	ori	r4,r16,18805
81125c58:	81125d54 	ori	r4,r16,18805
81125c5c:	81125d54 	ori	r4,r16,18805
81125c60:	81125d54 	ori	r4,r16,18805
81125c64:	81125d54 	ori	r4,r16,18805
81125c68:	81125d54 	ori	r4,r16,18805
81125c6c:	81125d54 	ori	r4,r16,18805
81125c70:	81125fac 	andhi	r4,r16,18814
81125c74:	81125f84 	addi	r4,r16,18814
81125c78:	81125ef4 	orhi	r4,r16,18811
81125c7c:	81125ef4 	orhi	r4,r16,18811
81125c80:	81125ef4 	orhi	r4,r16,18811
81125c84:	81125f70 	cmpltui	r4,r16,18813
81125c88:	811260b4 	orhi	r4,r16,18818
81125c8c:	81125d54 	ori	r4,r16,18805
81125c90:	81125d54 	ori	r4,r16,18805
81125c94:	81125f5c 	xori	r4,r16,18813
81125c98:	81125d54 	ori	r4,r16,18805
81125c9c:	81125f2c 	andhi	r4,r16,18812
81125ca0:	81125f08 	cmpgei	r4,r16,18812
81125ca4:	81125e18 	cmpnei	r4,r16,18808
81125ca8:	81125d54 	ori	r4,r16,18805
81125cac:	81125d54 	ori	r4,r16,18805
81125cb0:	81125e04 	addi	r4,r16,18808
81125cb4:	81125d54 	ori	r4,r16,18805
81125cb8:	81125d8c 	andi	r4,r16,18806
81125cbc:	81125d54 	ori	r4,r16,18805
81125cc0:	81125d54 	ori	r4,r16,18805
81125cc4:	81125e8c 	andi	r4,r16,18810
81125cc8:	d9809d15 	stw	r6,628(sp)
81125ccc:	3029883a 	mov	r20,r6
81125cd0:	e0800117 	ldw	r2,4(fp)
81125cd4:	0081aa0e 	bge	zero,r2,81126380 <__svfscanf_r+0x9e8>
81125cd8:	e0800017 	ldw	r2,0(fp)
81125cdc:	a0ffffc3 	ldbu	r3,-1(r20)
81125ce0:	11000003 	ldbu	r4,0(r2)
81125ce4:	20ff6e1e 	bne	r4,r3,81125aa0 <__reset+0xfb105aa0>
81125ce8:	e0c00117 	ldw	r3,4(fp)
81125cec:	10800044 	addi	r2,r2,1
81125cf0:	e0800015 	stw	r2,0(fp)
81125cf4:	18bfffc4 	addi	r2,r3,-1
81125cf8:	e0800115 	stw	r2,4(fp)
81125cfc:	94800044 	addi	r18,r18,1
81125d00:	a00d883a 	mov	r6,r20
81125d04:	003f6206 	br	81125a90 <__reset+0xfb105a90>
81125d08:	00bfffc4 	movi	r2,-1
81125d0c:	dfc0b417 	ldw	ra,720(sp)
81125d10:	df00b317 	ldw	fp,716(sp)
81125d14:	ddc0b217 	ldw	r23,712(sp)
81125d18:	dd80b117 	ldw	r22,708(sp)
81125d1c:	dd40b017 	ldw	r21,704(sp)
81125d20:	dd00af17 	ldw	r20,700(sp)
81125d24:	dcc0ae17 	ldw	r19,696(sp)
81125d28:	dc80ad17 	ldw	r18,692(sp)
81125d2c:	dc40ac17 	ldw	r17,688(sp)
81125d30:	dc00ab17 	ldw	r16,684(sp)
81125d34:	dec0b504 	addi	sp,sp,724
81125d38:	f800283a 	ret
81125d3c:	a0800043 	ldbu	r2,1(r20)
81125d40:	3029883a 	mov	r20,r6
81125d44:	8c400414 	ori	r17,r17,16
81125d48:	10c03fcc 	andi	r3,r2,255
81125d4c:	a1800044 	addi	r6,r20,1
81125d50:	20ff5e2e 	bgeu	r4,r3,81125acc <__reset+0xfb105acc>
81125d54:	38c7883a 	add	r3,r7,r3
81125d58:	18800043 	ldbu	r2,1(r3)
81125d5c:	d9809d15 	stw	r6,628(sp)
81125d60:	00c00044 	movi	r3,1
81125d64:	108000cc 	andi	r2,r2,3
81125d68:	10c18f26 	beq	r2,r3,811263a8 <__svfscanf_r+0xa10>
81125d6c:	e0800117 	ldw	r2,4(fp)
81125d70:	00808716 	blt	zero,r2,81125f90 <__svfscanf_r+0x5f8>
81125d74:	e00b883a 	mov	r5,fp
81125d78:	b009883a 	mov	r4,r22
81125d7c:	1120c780 	call	81120c78 <__srefill_r>
81125d80:	1001431e 	bne	r2,zero,81126290 <__svfscanf_r+0x8f8>
81125d84:	b9c00017 	ldw	r7,0(r23)
81125d88:	00008106 	br	81125f90 <__svfscanf_r+0x5f8>
81125d8c:	e0800117 	ldw	r2,4(fp)
81125d90:	d9809d15 	stw	r6,628(sp)
81125d94:	0081a30e 	bge	zero,r2,81126424 <__svfscanf_r+0xa8c>
81125d98:	00a044f4 	movhi	r2,33043
81125d9c:	10b6ea04 	addi	r2,r2,-9304
81125da0:	02000284 	movi	r8,10
81125da4:	d880a115 	stw	r2,644(sp)
81125da8:	da009e15 	stw	r8,632(sp)
81125dac:	050000c4 	movi	r20,3
81125db0:	e0c00017 	ldw	r3,0(fp)
81125db4:	00000206 	br	81125dc0 <__svfscanf_r+0x428>
81125db8:	18c00044 	addi	r3,r3,1
81125dbc:	e0c00015 	stw	r3,0(fp)
81125dc0:	19000003 	ldbu	r4,0(r3)
81125dc4:	20803fcc 	andi	r2,r4,255
81125dc8:	3885883a 	add	r2,r7,r2
81125dcc:	10800043 	ldbu	r2,1(r2)
81125dd0:	1140020c 	andi	r5,r2,8
81125dd4:	2801ab26 	beq	r5,zero,81126484 <__svfscanf_r+0xaec>
81125dd8:	e0800117 	ldw	r2,4(fp)
81125ddc:	94800044 	addi	r18,r18,1
81125de0:	10bfffc4 	addi	r2,r2,-1
81125de4:	e0800115 	stw	r2,4(fp)
81125de8:	00bff316 	blt	zero,r2,81125db8 <__reset+0xfb105db8>
81125dec:	e00b883a 	mov	r5,fp
81125df0:	b009883a 	mov	r4,r22
81125df4:	1120c780 	call	81120c78 <__srefill_r>
81125df8:	1001251e 	bne	r2,zero,81126290 <__svfscanf_r+0x8f8>
81125dfc:	b9c00017 	ldw	r7,0(r23)
81125e00:	003feb06 	br	81125db0 <__reset+0xfb105db0>
81125e04:	e0800117 	ldw	r2,4(fp)
81125e08:	d9809d15 	stw	r6,628(sp)
81125e0c:	00818b0e 	bge	zero,r2,8112643c <__svfscanf_r+0xaa4>
81125e10:	05000084 	movi	r20,2
81125e14:	003fe606 	br	81125db0 <__reset+0xfb105db0>
81125e18:	e0800117 	ldw	r2,4(fp)
81125e1c:	d9809d15 	stw	r6,628(sp)
81125e20:	8c408814 	ori	r17,r17,544
81125e24:	00801d0e 	bge	zero,r2,81125e9c <__svfscanf_r+0x504>
81125e28:	00a044f4 	movhi	r2,33043
81125e2c:	10b6ea04 	addi	r2,r2,-9304
81125e30:	02000404 	movi	r8,16
81125e34:	d880a115 	stw	r2,644(sp)
81125e38:	da009e15 	stw	r8,632(sp)
81125e3c:	050000c4 	movi	r20,3
81125e40:	003fdb06 	br	81125db0 <__reset+0xfb105db0>
81125e44:	e0800117 	ldw	r2,4(fp)
81125e48:	d9809d15 	stw	r6,628(sp)
81125e4c:	8c400054 	ori	r17,r17,1
81125e50:	00bfc80e 	bge	zero,r2,81125d74 <__reset+0xfb105d74>
81125e54:	00e044b4 	movhi	r3,33042
81125e58:	18c49f04 	addi	r3,r3,4732
81125e5c:	02000284 	movi	r8,10
81125e60:	d8c0a115 	stw	r3,644(sp)
81125e64:	da009e15 	stw	r8,632(sp)
81125e68:	050000c4 	movi	r20,3
81125e6c:	003fd006 	br	81125db0 <__reset+0xfb105db0>
81125e70:	9cc002a4 	muli	r19,r19,10
81125e74:	a0800043 	ldbu	r2,1(r20)
81125e78:	3029883a 	mov	r20,r6
81125e7c:	98e7883a 	add	r19,r19,r3
81125e80:	9cfff404 	addi	r19,r19,-48
81125e84:	10c03fcc 	andi	r3,r2,255
81125e88:	003f0e06 	br	81125ac4 <__reset+0xfb105ac4>
81125e8c:	e0800117 	ldw	r2,4(fp)
81125e90:	d9809d15 	stw	r6,628(sp)
81125e94:	8c408014 	ori	r17,r17,512
81125e98:	00bfe316 	blt	zero,r2,81125e28 <__reset+0xfb105e28>
81125e9c:	e00b883a 	mov	r5,fp
81125ea0:	b009883a 	mov	r4,r22
81125ea4:	1120c780 	call	81120c78 <__srefill_r>
81125ea8:	1000f91e 	bne	r2,zero,81126290 <__svfscanf_r+0x8f8>
81125eac:	b9c00017 	ldw	r7,0(r23)
81125eb0:	003fdd06 	br	81125e28 <__reset+0xfb105e28>
81125eb4:	e0800117 	ldw	r2,4(fp)
81125eb8:	d9809d15 	stw	r6,628(sp)
81125ebc:	8c400054 	ori	r17,r17,1
81125ec0:	0080140e 	bge	zero,r2,81125f14 <__svfscanf_r+0x57c>
81125ec4:	00a044f4 	movhi	r2,33043
81125ec8:	10b6ea04 	addi	r2,r2,-9304
81125ecc:	02000204 	movi	r8,8
81125ed0:	d880a115 	stw	r2,644(sp)
81125ed4:	da009e15 	stw	r8,632(sp)
81125ed8:	050000c4 	movi	r20,3
81125edc:	003fb406 	br	81125db0 <__reset+0xfb105db0>
81125ee0:	a0800043 	ldbu	r2,1(r20)
81125ee4:	8c400094 	ori	r17,r17,2
81125ee8:	3029883a 	mov	r20,r6
81125eec:	10c03fcc 	andi	r3,r2,255
81125ef0:	003ef406 	br	81125ac4 <__reset+0xfb105ac4>
81125ef4:	e0800117 	ldw	r2,4(fp)
81125ef8:	d9809d15 	stw	r6,628(sp)
81125efc:	0081420e 	bge	zero,r2,81126408 <__svfscanf_r+0xa70>
81125f00:	05000104 	movi	r20,4
81125f04:	003faa06 	br	81125db0 <__reset+0xfb105db0>
81125f08:	e0800117 	ldw	r2,4(fp)
81125f0c:	d9809d15 	stw	r6,628(sp)
81125f10:	00bfec16 	blt	zero,r2,81125ec4 <__reset+0xfb105ec4>
81125f14:	e00b883a 	mov	r5,fp
81125f18:	b009883a 	mov	r4,r22
81125f1c:	1120c780 	call	81120c78 <__srefill_r>
81125f20:	1000db1e 	bne	r2,zero,81126290 <__svfscanf_r+0x8f8>
81125f24:	b9c00017 	ldw	r7,0(r23)
81125f28:	003fe606 	br	81125ec4 <__reset+0xfb105ec4>
81125f2c:	d9809d15 	stw	r6,628(sp)
81125f30:	8880040c 	andi	r2,r17,16
81125f34:	10009c1e 	bne	r2,zero,811261a8 <__svfscanf_r+0x810>
81125f38:	8880010c 	andi	r2,r17,4
81125f3c:	10011e26 	beq	r2,zero,811263b8 <__svfscanf_r+0xa20>
81125f40:	da009c17 	ldw	r8,624(sp)
81125f44:	3029883a 	mov	r20,r6
81125f48:	40800017 	ldw	r2,0(r8)
81125f4c:	42000104 	addi	r8,r8,4
81125f50:	da009c15 	stw	r8,624(sp)
81125f54:	1480000d 	sth	r18,0(r2)
81125f58:	003ecc06 	br	81125a8c <__reset+0xfb105a8c>
81125f5c:	a0c00043 	ldbu	r3,1(r20)
81125f60:	19410c26 	beq	r3,r5,81126394 <__svfscanf_r+0x9fc>
81125f64:	8c400054 	ori	r17,r17,1
81125f68:	3029883a 	mov	r20,r6
81125f6c:	003ed506 	br	81125ac4 <__reset+0xfb105ac4>
81125f70:	a0800043 	ldbu	r2,1(r20)
81125f74:	8c400114 	ori	r17,r17,4
81125f78:	3029883a 	mov	r20,r6
81125f7c:	10c03fcc 	andi	r3,r2,255
81125f80:	003ed006 	br	81125ac4 <__reset+0xfb105ac4>
81125f84:	e0800117 	ldw	r2,4(fp)
81125f88:	d9809d15 	stw	r6,628(sp)
81125f8c:	00bf790e 	bge	zero,r2,81125d74 <__reset+0xfb105d74>
81125f90:	00a044b4 	movhi	r2,33042
81125f94:	10849f04 	addi	r2,r2,4732
81125f98:	02000284 	movi	r8,10
81125f9c:	d880a115 	stw	r2,644(sp)
81125fa0:	da009e15 	stw	r8,632(sp)
81125fa4:	050000c4 	movi	r20,3
81125fa8:	003f8106 	br	81125db0 <__reset+0xfb105db0>
81125fac:	e0800117 	ldw	r2,4(fp)
81125fb0:	d9809d15 	stw	r6,628(sp)
81125fb4:	0080c40e 	bge	zero,r2,811262c8 <__svfscanf_r+0x930>
81125fb8:	9800011e 	bne	r19,zero,81125fc0 <__svfscanf_r+0x628>
81125fbc:	04c00044 	movi	r19,1
81125fc0:	8880004c 	andi	r2,r17,1
81125fc4:	1000441e 	bne	r2,zero,811260d8 <__svfscanf_r+0x740>
81125fc8:	8c40040c 	andi	r17,r17,16
81125fcc:	8800da26 	beq	r17,zero,81126338 <__svfscanf_r+0x9a0>
81125fd0:	0021883a 	mov	r16,zero
81125fd4:	00000806 	br	81125ff8 <__svfscanf_r+0x660>
81125fd8:	1887883a 	add	r3,r3,r2
81125fdc:	e00b883a 	mov	r5,fp
81125fe0:	b009883a 	mov	r4,r22
81125fe4:	e0c00015 	stw	r3,0(fp)
81125fe8:	80a1883a 	add	r16,r16,r2
81125fec:	98a7c83a 	sub	r19,r19,r2
81125ff0:	1120c780 	call	81120c78 <__srefill_r>
81125ff4:	1000ca1e 	bne	r2,zero,81126320 <__svfscanf_r+0x988>
81125ff8:	e0800117 	ldw	r2,4(fp)
81125ffc:	e0c00017 	ldw	r3,0(fp)
81126000:	14fff516 	blt	r2,r19,81125fd8 <__reset+0xfb105fd8>
81126004:	14c5c83a 	sub	r2,r2,r19
81126008:	1cd5883a 	add	r10,r3,r19
8112600c:	84e1883a 	add	r16,r16,r19
81126010:	e0800115 	stw	r2,4(fp)
81126014:	e2800015 	stw	r10,0(fp)
81126018:	dd009d17 	ldw	r20,628(sp)
8112601c:	9425883a 	add	r18,r18,r16
81126020:	a00d883a 	mov	r6,r20
81126024:	003e9a06 	br	81125a90 <__reset+0xfb105a90>
81126028:	300b883a 	mov	r5,r6
8112602c:	d9005884 	addi	r4,sp,354
81126030:	d9809d15 	stw	r6,628(sp)
81126034:	112bf800 	call	8112bf80 <__sccl>
81126038:	1029883a 	mov	r20,r2
8112603c:	e0800117 	ldw	r2,4(fp)
81126040:	0081050e 	bge	zero,r2,81126458 <__svfscanf_r+0xac0>
81126044:	e1000017 	ldw	r4,0(fp)
81126048:	20800003 	ldbu	r2,0(r4)
8112604c:	98005926 	beq	r19,zero,811261b4 <__svfscanf_r+0x81c>
81126050:	8c40040c 	andi	r17,r17,16
81126054:	88005a26 	beq	r17,zero,811261c0 <__svfscanf_r+0x828>
81126058:	9823883a 	mov	r17,r19
8112605c:	0021883a 	mov	r16,zero
81126060:	00000106 	br	81126068 <__svfscanf_r+0x6d0>
81126064:	20800003 	ldbu	r2,0(r4)
81126068:	10803fcc 	andi	r2,r2,255
8112606c:	d8c05884 	addi	r3,sp,354
81126070:	1885883a 	add	r2,r3,r2
81126074:	10800007 	ldb	r2,0(r2)
81126078:	1000ad26 	beq	r2,zero,81126330 <__svfscanf_r+0x998>
8112607c:	e0800117 	ldw	r2,4(fp)
81126080:	21000044 	addi	r4,r4,1
81126084:	84000044 	addi	r16,r16,1
81126088:	10bfffc4 	addi	r2,r2,-1
8112608c:	e0800115 	stw	r2,4(fp)
81126090:	e1000015 	stw	r4,0(fp)
81126094:	84c0a026 	beq	r16,r19,81126318 <__svfscanf_r+0x980>
81126098:	00bff216 	blt	zero,r2,81126064 <__reset+0xfb106064>
8112609c:	e00b883a 	mov	r5,fp
811260a0:	b009883a 	mov	r4,r22
811260a4:	1120c780 	call	81120c78 <__srefill_r>
811260a8:	10009a1e 	bne	r2,zero,81126314 <__svfscanf_r+0x97c>
811260ac:	e1000017 	ldw	r4,0(fp)
811260b0:	003fec06 	br	81126064 <__reset+0xfb106064>
811260b4:	e0800117 	ldw	r2,4(fp)
811260b8:	d9809d15 	stw	r6,628(sp)
811260bc:	0080eb0e 	bge	zero,r2,8112646c <__svfscanf_r+0xad4>
811260c0:	00a044b4 	movhi	r2,33042
811260c4:	10849f04 	addi	r2,r2,4732
811260c8:	d880a115 	stw	r2,644(sp)
811260cc:	d8009e15 	stw	zero,632(sp)
811260d0:	050000c4 	movi	r20,3
811260d4:	003f3606 	br	81125db0 <__reset+0xfb105db0>
811260d8:	dd409904 	addi	r21,sp,612
811260dc:	8c40040c 	andi	r17,r17,16
811260e0:	01800204 	movi	r6,8
811260e4:	000b883a 	mov	r5,zero
811260e8:	a809883a 	mov	r4,r21
811260ec:	dc409f15 	stw	r17,636(sp)
811260f0:	11207fc0 	call	811207fc <memset>
811260f4:	dc409f17 	ldw	r17,636(sp)
811260f8:	88006e26 	beq	r17,zero,811262b4 <__svfscanf_r+0x91c>
811260fc:	0029883a 	mov	r20,zero
81126100:	0023883a 	mov	r17,zero
81126104:	112a39c0 	call	8112a39c <__locale_mb_cur_max>
81126108:	14406126 	beq	r2,r17,81126290 <__svfscanf_r+0x8f8>
8112610c:	e0800017 	ldw	r2,0(fp)
81126110:	e0c00117 	ldw	r3,4(fp)
81126114:	d9000104 	addi	r4,sp,4
81126118:	12000003 	ldbu	r8,0(r2)
8112611c:	18ffffc4 	addi	r3,r3,-1
81126120:	10800044 	addi	r2,r2,1
81126124:	e0c00115 	stw	r3,4(fp)
81126128:	e0800015 	stw	r2,0(fp)
8112612c:	8c000044 	addi	r16,r17,1
81126130:	dd400015 	stw	r21,0(sp)
81126134:	2463883a 	add	r17,r4,r17
81126138:	200d883a 	mov	r6,r4
8112613c:	a00b883a 	mov	r5,r20
81126140:	800f883a 	mov	r7,r16
81126144:	b009883a 	mov	r4,r22
81126148:	8a000005 	stb	r8,0(r17)
8112614c:	112a4580 	call	8112a458 <_mbrtowc_r>
81126150:	017fffc4 	movi	r5,-1
81126154:	11404e26 	beq	r2,r5,81126290 <__svfscanf_r+0x8f8>
81126158:	1000601e 	bne	r2,zero,811262dc <__svfscanf_r+0x944>
8112615c:	da009f17 	ldw	r8,636(sp)
81126160:	4000641e 	bne	r8,zero,811262f4 <__svfscanf_r+0x95c>
81126164:	a0000015 	stw	zero,0(r20)
81126168:	9425883a 	add	r18,r18,r16
8112616c:	9967883a 	add	r19,r19,r5
81126170:	a5000104 	addi	r20,r20,4
81126174:	e0800117 	ldw	r2,4(fp)
81126178:	0023883a 	mov	r17,zero
8112617c:	00804b16 	blt	zero,r2,811262ac <__svfscanf_r+0x914>
81126180:	e00b883a 	mov	r5,fp
81126184:	b009883a 	mov	r4,r22
81126188:	1120c780 	call	81120c78 <__srefill_r>
8112618c:	10004726 	beq	r2,zero,811262ac <__svfscanf_r+0x914>
81126190:	88003f1e 	bne	r17,zero,81126290 <__svfscanf_r+0x8f8>
81126194:	d8c09f17 	ldw	r3,636(sp)
81126198:	1800031e 	bne	r3,zero,811261a8 <__svfscanf_r+0x810>
8112619c:	da00a017 	ldw	r8,640(sp)
811261a0:	42000044 	addi	r8,r8,1
811261a4:	da00a015 	stw	r8,640(sp)
811261a8:	dd009d17 	ldw	r20,628(sp)
811261ac:	a00d883a 	mov	r6,r20
811261b0:	003e3706 	br	81125a90 <__reset+0xfb105a90>
811261b4:	8c40040c 	andi	r17,r17,16
811261b8:	04ffffc4 	movi	r19,-1
811261bc:	883fa61e 	bne	r17,zero,81126058 <__reset+0xfb106058>
811261c0:	da009c17 	ldw	r8,624(sp)
811261c4:	9abfffc4 	addi	r10,r19,-1
811261c8:	44000017 	ldw	r16,0(r8)
811261cc:	44400104 	addi	r17,r8,4
811261d0:	8007883a 	mov	r3,r16
811261d4:	82ab883a 	add	r21,r16,r10
811261d8:	00000306 	br	811261e8 <__svfscanf_r+0x850>
811261dc:	e1000017 	ldw	r4,0(fp)
811261e0:	9807883a 	mov	r3,r19
811261e4:	20800003 	ldbu	r2,0(r4)
811261e8:	10803fcc 	andi	r2,r2,255
811261ec:	d9405884 	addi	r5,sp,354
811261f0:	2885883a 	add	r2,r5,r2
811261f4:	10800007 	ldb	r2,0(r2)
811261f8:	10004b26 	beq	r2,zero,81126328 <__svfscanf_r+0x990>
811261fc:	e0800117 	ldw	r2,4(fp)
81126200:	21400044 	addi	r5,r4,1
81126204:	e1400015 	stw	r5,0(fp)
81126208:	10bfffc4 	addi	r2,r2,-1
8112620c:	e0800115 	stw	r2,4(fp)
81126210:	20800003 	ldbu	r2,0(r4)
81126214:	1cc00044 	addi	r19,r3,1
81126218:	18800005 	stb	r2,0(r3)
8112621c:	1d400726 	beq	r3,r21,8112623c <__svfscanf_r+0x8a4>
81126220:	e0800117 	ldw	r2,4(fp)
81126224:	00bfed16 	blt	zero,r2,811261dc <__reset+0xfb1061dc>
81126228:	e00b883a 	mov	r5,fp
8112622c:	b009883a 	mov	r4,r22
81126230:	1120c780 	call	81120c78 <__srefill_r>
81126234:	103fe926 	beq	r2,zero,811261dc <__reset+0xfb1061dc>
81126238:	84c01526 	beq	r16,r19,81126290 <__svfscanf_r+0x8f8>
8112623c:	9c21c83a 	sub	r16,r19,r16
81126240:	803e1726 	beq	r16,zero,81125aa0 <__reset+0xfb105aa0>
81126244:	da00a017 	ldw	r8,640(sp)
81126248:	98000005 	stb	zero,0(r19)
8112624c:	dc409c15 	stw	r17,624(sp)
81126250:	42000044 	addi	r8,r8,1
81126254:	da00a015 	stw	r8,640(sp)
81126258:	9425883a 	add	r18,r18,r16
8112625c:	a00d883a 	mov	r6,r20
81126260:	003e0b06 	br	81125a90 <__reset+0xfb105a90>
81126264:	017fff84 	movi	r5,-2
81126268:	11439b1e 	bne	r2,r5,811270d8 <__svfscanf_r+0x1740>
8112626c:	8821883a 	mov	r16,r17
81126270:	e0800117 	ldw	r2,4(fp)
81126274:	0082e516 	blt	zero,r2,81126e0c <__svfscanf_r+0x1474>
81126278:	e00b883a 	mov	r5,fp
8112627c:	b009883a 	mov	r4,r22
81126280:	1120c780 	call	81120c78 <__srefill_r>
81126284:	1002e126 	beq	r2,zero,81126e0c <__svfscanf_r+0x1474>
81126288:	dc409f17 	ldw	r17,636(sp)
8112628c:	8002e826 	beq	r16,zero,81126e30 <__svfscanf_r+0x1498>
81126290:	da00a017 	ldw	r8,640(sp)
81126294:	403e9c26 	beq	r8,zero,81125d08 <__reset+0xfb105d08>
81126298:	e080030b 	ldhu	r2,12(fp)
8112629c:	1080100c 	andi	r2,r2,64
811262a0:	103e991e 	bne	r2,zero,81125d08 <__reset+0xfb105d08>
811262a4:	4005883a 	mov	r2,r8
811262a8:	003e9806 	br	81125d0c <__reset+0xfb105d0c>
811262ac:	983f951e 	bne	r19,zero,81126104 <__reset+0xfb106104>
811262b0:	003fb806 	br	81126194 <__reset+0xfb106194>
811262b4:	da009c17 	ldw	r8,624(sp)
811262b8:	45000017 	ldw	r20,0(r8)
811262bc:	42000104 	addi	r8,r8,4
811262c0:	da009c15 	stw	r8,624(sp)
811262c4:	003f8e06 	br	81126100 <__reset+0xfb106100>
811262c8:	e00b883a 	mov	r5,fp
811262cc:	b009883a 	mov	r4,r22
811262d0:	1120c780 	call	81120c78 <__srefill_r>
811262d4:	103f3826 	beq	r2,zero,81125fb8 <__reset+0xfb105fb8>
811262d8:	003fed06 	br	81126290 <__reset+0xfb106290>
811262dc:	00ffff84 	movi	r3,-2
811262e0:	10c0071e 	bne	r2,r3,81126300 <__svfscanf_r+0x968>
811262e4:	e0800117 	ldw	r2,4(fp)
811262e8:	8023883a 	mov	r17,r16
811262ec:	00bf8516 	blt	zero,r2,81126104 <__reset+0xfb106104>
811262f0:	003fa306 	br	81126180 <__reset+0xfb106180>
811262f4:	9425883a 	add	r18,r18,r16
811262f8:	9cffffc4 	addi	r19,r19,-1
811262fc:	003f9d06 	br	81126174 <__reset+0xfb106174>
81126300:	da009f17 	ldw	r8,636(sp)
81126304:	9425883a 	add	r18,r18,r16
81126308:	9cffffc4 	addi	r19,r19,-1
8112630c:	403f9826 	beq	r8,zero,81126170 <__reset+0xfb106170>
81126310:	003f9806 	br	81126174 <__reset+0xfb106174>
81126314:	8023883a 	mov	r17,r16
81126318:	8821883a 	mov	r16,r17
8112631c:	003fce06 	br	81126258 <__reset+0xfb106258>
81126320:	803f3d1e 	bne	r16,zero,81126018 <__reset+0xfb106018>
81126324:	003fda06 	br	81126290 <__reset+0xfb106290>
81126328:	1827883a 	mov	r19,r3
8112632c:	003fc306 	br	8112623c <__reset+0xfb10623c>
81126330:	803fc91e 	bne	r16,zero,81126258 <__reset+0xfb106258>
81126334:	003dda06 	br	81125aa0 <__reset+0xfb105aa0>
81126338:	da009c17 	ldw	r8,624(sp)
8112633c:	df000015 	stw	fp,0(sp)
81126340:	980f883a 	mov	r7,r19
81126344:	41400017 	ldw	r5,0(r8)
81126348:	01800044 	movi	r6,1
8112634c:	b009883a 	mov	r4,r22
81126350:	11295700 	call	81129570 <_fread_r>
81126354:	da009c17 	ldw	r8,624(sp)
81126358:	40c00104 	addi	r3,r8,4
8112635c:	103fcc26 	beq	r2,zero,81126290 <__reset+0xfb106290>
81126360:	da00a017 	ldw	r8,640(sp)
81126364:	dd009d17 	ldw	r20,628(sp)
81126368:	90a5883a 	add	r18,r18,r2
8112636c:	42000044 	addi	r8,r8,1
81126370:	da00a015 	stw	r8,640(sp)
81126374:	d8c09c15 	stw	r3,624(sp)
81126378:	a00d883a 	mov	r6,r20
8112637c:	003dc406 	br	81125a90 <__reset+0xfb105a90>
81126380:	e00b883a 	mov	r5,fp
81126384:	b009883a 	mov	r4,r22
81126388:	1120c780 	call	81120c78 <__srefill_r>
8112638c:	103e5226 	beq	r2,zero,81125cd8 <__reset+0xfb105cd8>
81126390:	003fbf06 	br	81126290 <__reset+0xfb106290>
81126394:	a0800083 	ldbu	r2,2(r20)
81126398:	8c400094 	ori	r17,r17,2
8112639c:	a5000084 	addi	r20,r20,2
811263a0:	10c03fcc 	andi	r3,r2,255
811263a4:	003dc706 	br	81125ac4 <__reset+0xfb105ac4>
811263a8:	e0800117 	ldw	r2,4(fp)
811263ac:	88e2b03a 	or	r17,r17,r3
811263b0:	00bef716 	blt	zero,r2,81125f90 <__reset+0xfb105f90>
811263b4:	003e6f06 	br	81125d74 <__reset+0xfb105d74>
811263b8:	8880004c 	andi	r2,r17,1
811263bc:	10000b1e 	bne	r2,zero,811263ec <__svfscanf_r+0xa54>
811263c0:	8c40008c 	andi	r17,r17,2
811263c4:	88000926 	beq	r17,zero,811263ec <__svfscanf_r+0xa54>
811263c8:	da009c17 	ldw	r8,624(sp)
811263cc:	9007d7fa 	srai	r3,r18,31
811263d0:	dd009d17 	ldw	r20,628(sp)
811263d4:	40800017 	ldw	r2,0(r8)
811263d8:	42000104 	addi	r8,r8,4
811263dc:	da009c15 	stw	r8,624(sp)
811263e0:	14800015 	stw	r18,0(r2)
811263e4:	10c00115 	stw	r3,4(r2)
811263e8:	003da806 	br	81125a8c <__reset+0xfb105a8c>
811263ec:	da009c17 	ldw	r8,624(sp)
811263f0:	dd009d17 	ldw	r20,628(sp)
811263f4:	40800017 	ldw	r2,0(r8)
811263f8:	42000104 	addi	r8,r8,4
811263fc:	da009c15 	stw	r8,624(sp)
81126400:	14800015 	stw	r18,0(r2)
81126404:	003da106 	br	81125a8c <__reset+0xfb105a8c>
81126408:	e00b883a 	mov	r5,fp
8112640c:	b009883a 	mov	r4,r22
81126410:	1120c780 	call	81120c78 <__srefill_r>
81126414:	103f9e1e 	bne	r2,zero,81126290 <__reset+0xfb106290>
81126418:	b9c00017 	ldw	r7,0(r23)
8112641c:	05000104 	movi	r20,4
81126420:	003e6306 	br	81125db0 <__reset+0xfb105db0>
81126424:	e00b883a 	mov	r5,fp
81126428:	b009883a 	mov	r4,r22
8112642c:	1120c780 	call	81120c78 <__srefill_r>
81126430:	103f971e 	bne	r2,zero,81126290 <__reset+0xfb106290>
81126434:	b9c00017 	ldw	r7,0(r23)
81126438:	003e5706 	br	81125d98 <__reset+0xfb105d98>
8112643c:	e00b883a 	mov	r5,fp
81126440:	b009883a 	mov	r4,r22
81126444:	1120c780 	call	81120c78 <__srefill_r>
81126448:	103f911e 	bne	r2,zero,81126290 <__reset+0xfb106290>
8112644c:	b9c00017 	ldw	r7,0(r23)
81126450:	05000084 	movi	r20,2
81126454:	003e5606 	br	81125db0 <__reset+0xfb105db0>
81126458:	e00b883a 	mov	r5,fp
8112645c:	b009883a 	mov	r4,r22
81126460:	1120c780 	call	81120c78 <__srefill_r>
81126464:	103ef726 	beq	r2,zero,81126044 <__reset+0xfb106044>
81126468:	003f8906 	br	81126290 <__reset+0xfb106290>
8112646c:	e00b883a 	mov	r5,fp
81126470:	b009883a 	mov	r4,r22
81126474:	1120c780 	call	81120c78 <__srefill_r>
81126478:	103f851e 	bne	r2,zero,81126290 <__reset+0xfb106290>
8112647c:	b9c00017 	ldw	r7,0(r23)
81126480:	003f0f06 	br	811260c0 <__reset+0xfb1060c0>
81126484:	014000c4 	movi	r5,3
81126488:	a1414a26 	beq	r20,r5,811269b4 <__svfscanf_r+0x101c>
8112648c:	01000104 	movi	r4,4
81126490:	a101f11e 	bne	r20,r4,81126c58 <__svfscanf_r+0x12c0>
81126494:	b009883a 	mov	r4,r22
81126498:	112a3c00 	call	8112a3c0 <_localeconv_r>
8112649c:	10800017 	ldw	r2,0(r2)
811264a0:	98ffffc4 	addi	r3,r19,-1
811264a4:	d880a315 	stw	r2,652(sp)
811264a8:	00805704 	movi	r2,348
811264ac:	10c21e2e 	bgeu	r2,r3,81126d28 <__svfscanf_r+0x1390>
811264b0:	9cffa8c4 	addi	r19,r19,-349
811264b4:	dcc0a215 	stw	r19,648(sp)
811264b8:	04c05744 	movi	r19,349
811264bc:	8d01e014 	ori	r20,r17,1920
811264c0:	0023883a 	mov	r17,zero
811264c4:	dc000104 	addi	r16,sp,4
811264c8:	8805883a 	mov	r2,r17
811264cc:	0019883a 	mov	r12,zero
811264d0:	8023883a 	mov	r17,r16
811264d4:	b007883a 	mov	r3,r22
811264d8:	9821883a 	mov	r16,r19
811264dc:	002b883a 	mov	r21,zero
811264e0:	d800a515 	stw	zero,660(sp)
811264e4:	d800a415 	stw	zero,656(sp)
811264e8:	d8009f15 	stw	zero,636(sp)
811264ec:	01c01384 	movi	r7,78
811264f0:	602d883a 	mov	r22,r12
811264f4:	1027883a 	mov	r19,r2
811264f8:	e1000017 	ldw	r4,0(fp)
811264fc:	21400003 	ldbu	r5,0(r4)
81126500:	28bff544 	addi	r2,r5,-43
81126504:	10803fcc 	andi	r2,r2,255
81126508:	38810e36 	bltu	r7,r2,81126944 <__svfscanf_r+0xfac>
8112650c:	100490ba 	slli	r2,r2,2
81126510:	01a044b4 	movhi	r6,33042
81126514:	31994904 	addi	r6,r6,25892
81126518:	1185883a 	add	r2,r2,r6
8112651c:	10800017 	ldw	r2,0(r2)
81126520:	1000683a 	jmp	r2
81126524:	8112681c 	xori	r4,r16,18848
81126528:	81126944 	addi	r4,r16,18853
8112652c:	8112681c 	xori	r4,r16,18848
81126530:	81126944 	addi	r4,r16,18853
81126534:	81126944 	addi	r4,r16,18853
81126538:	811267f0 	cmpltui	r4,r16,18847
8112653c:	81126660 	cmpeqi	r4,r16,18841
81126540:	81126660 	cmpeqi	r4,r16,18841
81126544:	81126660 	cmpeqi	r4,r16,18841
81126548:	81126660 	cmpeqi	r4,r16,18841
8112654c:	81126660 	cmpeqi	r4,r16,18841
81126550:	81126660 	cmpeqi	r4,r16,18841
81126554:	81126660 	cmpeqi	r4,r16,18841
81126558:	81126660 	cmpeqi	r4,r16,18841
8112655c:	81126660 	cmpeqi	r4,r16,18841
81126560:	81126944 	addi	r4,r16,18853
81126564:	81126944 	addi	r4,r16,18853
81126568:	81126944 	addi	r4,r16,18853
8112656c:	81126944 	addi	r4,r16,18853
81126570:	81126944 	addi	r4,r16,18853
81126574:	81126944 	addi	r4,r16,18853
81126578:	81126944 	addi	r4,r16,18853
8112657c:	81126934 	orhi	r4,r16,18852
81126580:	81126944 	addi	r4,r16,18853
81126584:	81126944 	addi	r4,r16,18853
81126588:	81126944 	addi	r4,r16,18853
8112658c:	811268f0 	cmpltui	r4,r16,18851
81126590:	811268d4 	ori	r4,r16,18851
81126594:	81126944 	addi	r4,r16,18853
81126598:	81126944 	addi	r4,r16,18853
8112659c:	811268a0 	cmpeqi	r4,r16,18850
811265a0:	81126944 	addi	r4,r16,18853
811265a4:	81126944 	addi	r4,r16,18853
811265a8:	81126944 	addi	r4,r16,18853
811265ac:	81126944 	addi	r4,r16,18853
811265b0:	81126868 	cmpgeui	r4,r16,18849
811265b4:	81126944 	addi	r4,r16,18853
811265b8:	81126944 	addi	r4,r16,18853
811265bc:	81126944 	addi	r4,r16,18853
811265c0:	81126944 	addi	r4,r16,18853
811265c4:	81126944 	addi	r4,r16,18853
811265c8:	8112684c 	andi	r4,r16,18849
811265cc:	81126944 	addi	r4,r16,18853
811265d0:	81126944 	addi	r4,r16,18853
811265d4:	81126944 	addi	r4,r16,18853
811265d8:	81126944 	addi	r4,r16,18853
811265dc:	81126830 	cmpltui	r4,r16,18848
811265e0:	81126944 	addi	r4,r16,18853
811265e4:	81126944 	addi	r4,r16,18853
811265e8:	81126944 	addi	r4,r16,18853
811265ec:	81126944 	addi	r4,r16,18853
811265f0:	81126944 	addi	r4,r16,18853
811265f4:	81126944 	addi	r4,r16,18853
811265f8:	81126944 	addi	r4,r16,18853
811265fc:	81126934 	orhi	r4,r16,18852
81126600:	81126944 	addi	r4,r16,18853
81126604:	81126944 	addi	r4,r16,18853
81126608:	81126944 	addi	r4,r16,18853
8112660c:	811268f0 	cmpltui	r4,r16,18851
81126610:	811268d4 	ori	r4,r16,18851
81126614:	81126944 	addi	r4,r16,18853
81126618:	81126944 	addi	r4,r16,18853
8112661c:	811268a0 	cmpeqi	r4,r16,18850
81126620:	81126944 	addi	r4,r16,18853
81126624:	81126944 	addi	r4,r16,18853
81126628:	81126944 	addi	r4,r16,18853
8112662c:	81126944 	addi	r4,r16,18853
81126630:	81126868 	cmpgeui	r4,r16,18849
81126634:	81126944 	addi	r4,r16,18853
81126638:	81126944 	addi	r4,r16,18853
8112663c:	81126944 	addi	r4,r16,18853
81126640:	81126944 	addi	r4,r16,18853
81126644:	81126944 	addi	r4,r16,18853
81126648:	8112684c 	andi	r4,r16,18849
8112664c:	81126944 	addi	r4,r16,18853
81126650:	81126944 	addi	r4,r16,18853
81126654:	81126944 	addi	r4,r16,18853
81126658:	81126944 	addi	r4,r16,18853
8112665c:	81126830 	cmpltui	r4,r16,18848
81126660:	a8803fcc 	andi	r2,r21,255
81126664:	1080201c 	xori	r2,r2,128
81126668:	10bfe004 	addi	r2,r2,-128
8112666c:	b085883a 	add	r2,r22,r2
81126670:	10000d1e 	bne	r2,zero,811266a8 <__svfscanf_r+0xd10>
81126674:	00bf9fc4 	movi	r2,-385
81126678:	a0a8703a 	and	r20,r20,r2
8112667c:	89400005 	stb	r5,0(r17)
81126680:	8c400044 	addi	r17,r17,1
81126684:	e0800117 	ldw	r2,4(fp)
81126688:	843fffc4 	addi	r16,r16,-1
8112668c:	94800044 	addi	r18,r18,1
81126690:	10bfffc4 	addi	r2,r2,-1
81126694:	e0800115 	stw	r2,4(fp)
81126698:	0080b40e 	bge	zero,r2,8112696c <__svfscanf_r+0xfd4>
8112669c:	21000044 	addi	r4,r4,1
811266a0:	e1000015 	stw	r4,0(fp)
811266a4:	803f941e 	bne	r16,zero,811264f8 <__reset+0xfb1064f8>
811266a8:	8821883a 	mov	r16,r17
811266ac:	b019883a 	mov	r12,r22
811266b0:	9823883a 	mov	r17,r19
811266b4:	182d883a 	mov	r22,r3
811266b8:	9801961e 	bne	r19,zero,81126d14 <__svfscanf_r+0x137c>
811266bc:	633fffc4 	addi	r12,r12,-1
811266c0:	00800044 	movi	r2,1
811266c4:	1302882e 	bgeu	r2,r12,811270e8 <__svfscanf_r+0x1750>
811266c8:	a8803fcc 	andi	r2,r21,255
811266cc:	1080201c 	xori	r2,r2,128
811266d0:	10bfe004 	addi	r2,r2,-128
811266d4:	113fffc4 	addi	r4,r2,-1
811266d8:	01400184 	movi	r5,6
811266dc:	29001136 	bltu	r5,r4,81126724 <__svfscanf_r+0xd8c>
811266e0:	01000084 	movi	r4,2
811266e4:	2082900e 	bge	r4,r2,81127128 <__svfscanf_r+0x1790>
811266e8:	00c000c4 	movi	r3,3
811266ec:	10c00d26 	beq	r2,r3,81126724 <__svfscanf_r+0xd8c>
811266f0:	9425c83a 	sub	r18,r18,r16
811266f4:	1827883a 	mov	r19,r3
811266f8:	843fffc4 	addi	r16,r16,-1
811266fc:	81400007 	ldb	r5,0(r16)
81126700:	e00d883a 	mov	r6,fp
81126704:	b009883a 	mov	r4,r22
81126708:	112f5f00 	call	8112f5f0 <_ungetc_r>
8112670c:	a8bfffc4 	addi	r2,r21,-1
81126710:	10c03fcc 	andi	r3,r2,255
81126714:	8493883a 	add	r9,r16,r18
81126718:	102b883a 	mov	r21,r2
8112671c:	98fff636 	bltu	r19,r3,811266f8 <__reset+0xfb1066f8>
81126720:	4825883a 	mov	r18,r9
81126724:	a080400c 	andi	r2,r20,256
81126728:	10001426 	beq	r2,zero,8112677c <__svfscanf_r+0xde4>
8112672c:	a081000c 	andi	r2,r20,1024
81126730:	1002571e 	bne	r2,zero,81127090 <__svfscanf_r+0x16f8>
81126734:	817fffc7 	ldb	r5,-1(r16)
81126738:	00801944 	movi	r2,101
8112673c:	84ffffc4 	addi	r19,r16,-1
81126740:	957fffc4 	addi	r21,r18,-1
81126744:	28800826 	beq	r5,r2,81126768 <__svfscanf_r+0xdd0>
81126748:	00801144 	movi	r2,69
8112674c:	28800626 	beq	r5,r2,81126768 <__svfscanf_r+0xdd0>
81126750:	e00d883a 	mov	r6,fp
81126754:	b009883a 	mov	r4,r22
81126758:	112f5f00 	call	8112f5f0 <_ungetc_r>
8112675c:	817fff87 	ldb	r5,-2(r16)
81126760:	84ffff84 	addi	r19,r16,-2
81126764:	957fff84 	addi	r21,r18,-2
81126768:	e00d883a 	mov	r6,fp
8112676c:	b009883a 	mov	r4,r22
81126770:	112f5f00 	call	8112f5f0 <_ungetc_r>
81126774:	a825883a 	mov	r18,r21
81126778:	9821883a 	mov	r16,r19
8112677c:	a080040c 	andi	r2,r20,16
81126780:	103e891e 	bne	r2,zero,811261a8 <__reset+0xfb1061a8>
81126784:	80000005 	stb	zero,0(r16)
81126788:	a081800c 	andi	r2,r20,1536
8112678c:	01010004 	movi	r4,1024
81126790:	1101dd26 	beq	r2,r4,81126f08 <__svfscanf_r+0x1570>
81126794:	da00a417 	ldw	r8,656(sp)
81126798:	4001e71e 	bne	r8,zero,81126f38 <__svfscanf_r+0x15a0>
8112679c:	000d883a 	mov	r6,zero
811267a0:	d9400104 	addi	r5,sp,4
811267a4:	b009883a 	mov	r4,r22
811267a8:	112c1a00 	call	8112c1a0 <_strtod_r>
811267ac:	1021883a 	mov	r16,r2
811267b0:	a080004c 	andi	r2,r20,1
811267b4:	1000021e 	bne	r2,zero,811267c0 <__svfscanf_r+0xe28>
811267b8:	a2c0008c 	andi	r11,r20,2
811267bc:	5801e826 	beq	r11,zero,81126f60 <__svfscanf_r+0x15c8>
811267c0:	da009c17 	ldw	r8,624(sp)
811267c4:	40800017 	ldw	r2,0(r8)
811267c8:	42000104 	addi	r8,r8,4
811267cc:	da009c15 	stw	r8,624(sp)
811267d0:	14000015 	stw	r16,0(r2)
811267d4:	10c00115 	stw	r3,4(r2)
811267d8:	da00a017 	ldw	r8,640(sp)
811267dc:	dd009d17 	ldw	r20,628(sp)
811267e0:	42000044 	addi	r8,r8,1
811267e4:	da00a015 	stw	r8,640(sp)
811267e8:	a00d883a 	mov	r6,r20
811267ec:	003ca806 	br	81125a90 <__reset+0xfb105a90>
811267f0:	a080400c 	andi	r2,r20,256
811267f4:	103f9a26 	beq	r2,zero,81126660 <__reset+0xfb106660>
811267f8:	da00a217 	ldw	r8,648(sp)
811267fc:	00bfdfc4 	movi	r2,-129
81126800:	a0a8703a 	and	r20,r20,r2
81126804:	9cc00044 	addi	r19,r19,1
81126808:	403f9e26 	beq	r8,zero,81126684 <__reset+0xfb106684>
8112680c:	423fffc4 	addi	r8,r8,-1
81126810:	da00a215 	stw	r8,648(sp)
81126814:	84000044 	addi	r16,r16,1
81126818:	003f9a06 	br	81126684 <__reset+0xfb106684>
8112681c:	a080200c 	andi	r2,r20,128
81126820:	103fa126 	beq	r2,zero,811266a8 <__reset+0xfb1066a8>
81126824:	00bfdfc4 	movi	r2,-129
81126828:	a0a8703a 	and	r20,r20,r2
8112682c:	003f9306 	br	8112667c <__reset+0xfb10667c>
81126830:	a8803fcc 	andi	r2,r21,255
81126834:	1080201c 	xori	r2,r2,128
81126838:	10bfe004 	addi	r2,r2,-128
8112683c:	020001c4 	movi	r8,7
81126840:	123f991e 	bne	r2,r8,811266a8 <__reset+0xfb1066a8>
81126844:	05400204 	movi	r21,8
81126848:	003f8c06 	br	8112667c <__reset+0xfb10667c>
8112684c:	a8803fcc 	andi	r2,r21,255
81126850:	1080201c 	xori	r2,r2,128
81126854:	10bfe004 	addi	r2,r2,-128
81126858:	01800184 	movi	r6,6
8112685c:	11bf921e 	bne	r2,r6,811266a8 <__reset+0xfb1066a8>
81126860:	054001c4 	movi	r21,7
81126864:	003f8506 	br	8112667c <__reset+0xfb10667c>
81126868:	b000491e 	bne	r22,zero,81126990 <__svfscanf_r+0xff8>
8112686c:	9800031e 	bne	r19,zero,8112687c <__svfscanf_r+0xee4>
81126870:	a081c00c 	andi	r2,r20,1792
81126874:	0181c004 	movi	r6,1792
81126878:	11819f26 	beq	r2,r6,81126ef8 <__svfscanf_r+0x1560>
8112687c:	a8803fcc 	andi	r2,r21,255
81126880:	1080201c 	xori	r2,r2,128
81126884:	10bfe004 	addi	r2,r2,-128
81126888:	01800044 	movi	r6,1
8112688c:	11800226 	beq	r2,r6,81126898 <__svfscanf_r+0xf00>
81126890:	01800104 	movi	r6,4
81126894:	11bf841e 	bne	r2,r6,811266a8 <__reset+0xfb1066a8>
81126898:	ad400044 	addi	r21,r21,1
8112689c:	003f7706 	br	8112667c <__reset+0xfb10667c>
811268a0:	a8803fcc 	andi	r2,r21,255
811268a4:	1080201c 	xori	r2,r2,128
811268a8:	10bfe004 	addi	r2,r2,-128
811268ac:	10003c1e 	bne	r2,zero,811269a0 <__svfscanf_r+0x1008>
811268b0:	9801141e 	bne	r19,zero,81126d04 <__svfscanf_r+0x136c>
811268b4:	a081c00c 	andi	r2,r20,1792
811268b8:	0181c004 	movi	r6,1792
811268bc:	11818226 	beq	r2,r6,81126ec8 <__svfscanf_r+0x1530>
811268c0:	8821883a 	mov	r16,r17
811268c4:	b019883a 	mov	r12,r22
811268c8:	9823883a 	mov	r17,r19
811268cc:	182d883a 	mov	r22,r3
811268d0:	003f7a06 	br	811266bc <__reset+0xfb1066bc>
811268d4:	a8803fcc 	andi	r2,r21,255
811268d8:	1080201c 	xori	r2,r2,128
811268dc:	10bfe004 	addi	r2,r2,-128
811268e0:	01800084 	movi	r6,2
811268e4:	11bf701e 	bne	r2,r6,811266a8 <__reset+0xfb1066a8>
811268e8:	054000c4 	movi	r21,3
811268ec:	003f6306 	br	8112667c <__reset+0xfb10667c>
811268f0:	a081400c 	andi	r2,r20,1280
811268f4:	01810004 	movi	r6,1024
811268f8:	11800326 	beq	r2,r6,81126908 <__svfscanf_r+0xf70>
811268fc:	a184703a 	and	r2,r20,r6
81126900:	103f6926 	beq	r2,zero,811266a8 <__reset+0xfb1066a8>
81126904:	983fee26 	beq	r19,zero,811268c0 <__reset+0xfb1068c0>
81126908:	a080800c 	andi	r2,r20,512
8112690c:	1000041e 	bne	r2,zero,81126920 <__svfscanf_r+0xf88>
81126910:	da009f17 	ldw	r8,636(sp)
81126914:	dc40a515 	stw	r17,660(sp)
81126918:	9a27c83a 	sub	r19,r19,r8
8112691c:	dcc0a415 	stw	r19,656(sp)
81126920:	00be1fc4 	movi	r2,-1921
81126924:	a0a8703a 	and	r20,r20,r2
81126928:	a5006014 	ori	r20,r20,384
8112692c:	0027883a 	mov	r19,zero
81126930:	003f5206 	br	8112667c <__reset+0xfb10667c>
81126934:	00800044 	movi	r2,1
81126938:	b0bf5b1e 	bne	r22,r2,811266a8 <__reset+0xfb1066a8>
8112693c:	05800084 	movi	r22,2
81126940:	003f4e06 	br	8112667c <__reset+0xfb10667c>
81126944:	d980a317 	ldw	r6,652(sp)
81126948:	30800003 	ldbu	r2,0(r6)
8112694c:	29803fcc 	andi	r6,r5,255
81126950:	30bf551e 	bne	r6,r2,811266a8 <__reset+0xfb1066a8>
81126954:	a080800c 	andi	r2,r20,512
81126958:	103f5326 	beq	r2,zero,811266a8 <__reset+0xfb1066a8>
8112695c:	023f5fc4 	movi	r8,-641
81126960:	a228703a 	and	r20,r20,r8
81126964:	dcc09f15 	stw	r19,636(sp)
81126968:	003f4406 	br	8112667c <__reset+0xfb10667c>
8112696c:	1809883a 	mov	r4,r3
81126970:	e00b883a 	mov	r5,fp
81126974:	d8c0a615 	stw	r3,664(sp)
81126978:	d9c0aa15 	stw	r7,680(sp)
8112697c:	1120c780 	call	81120c78 <__srefill_r>
81126980:	d8c0a617 	ldw	r3,664(sp)
81126984:	d9c0aa17 	ldw	r7,680(sp)
81126988:	103f4626 	beq	r2,zero,811266a4 <__reset+0xfb1066a4>
8112698c:	003f4606 	br	811266a8 <__reset+0xfb1066a8>
81126990:	00800084 	movi	r2,2
81126994:	b0bfb91e 	bne	r22,r2,8112687c <__reset+0xfb10687c>
81126998:	058000c4 	movi	r22,3
8112699c:	003f3706 	br	8112667c <__reset+0xfb10667c>
811269a0:	018000c4 	movi	r6,3
811269a4:	11bfbc26 	beq	r2,r6,81126898 <__reset+0xfb106898>
811269a8:	01800144 	movi	r6,5
811269ac:	11bfba26 	beq	r2,r6,81126898 <__reset+0xfb106898>
811269b0:	003f3d06 	br	811266a8 <__reset+0xfb1066a8>
811269b4:	98bfffc4 	addi	r2,r19,-1
811269b8:	01405704 	movi	r5,348
811269bc:	2880d82e 	bgeu	r5,r2,81126d20 <__svfscanf_r+0x1388>
811269c0:	99ffa8c4 	addi	r7,r19,-349
811269c4:	04c05744 	movi	r19,349
811269c8:	8c436014 	ori	r17,r17,3456
811269cc:	9013883a 	mov	r9,r18
811269d0:	8825883a 	mov	r18,r17
811269d4:	dc409e17 	ldw	r17,632(sp)
811269d8:	0029883a 	mov	r20,zero
811269dc:	dc000104 	addi	r16,sp,4
811269e0:	05401344 	movi	r21,77
811269e4:	02c08004 	movi	r11,512
811269e8:	01bf7fc4 	movi	r6,-513
811269ec:	023fdfc4 	movi	r8,-129
811269f0:	20bff544 	addi	r2,r4,-43
811269f4:	10803fcc 	andi	r2,r2,255
811269f8:	a8807236 	bltu	r21,r2,81126bc4 <__svfscanf_r+0x122c>
811269fc:	100490ba 	slli	r2,r2,2
81126a00:	016044b4 	movhi	r5,33042
81126a04:	295a8504 	addi	r5,r5,27156
81126a08:	1145883a 	add	r2,r2,r5
81126a0c:	10800017 	ldw	r2,0(r2)
81126a10:	1000683a 	jmp	r2
81126a14:	81126c48 	cmpgei	r4,r16,18865
81126a18:	81126bc4 	addi	r4,r16,18863
81126a1c:	81126c48 	cmpgei	r4,r16,18865
81126a20:	81126bc4 	addi	r4,r16,18863
81126a24:	81126bc4 	addi	r4,r16,18863
81126a28:	81126c20 	cmpeqi	r4,r16,18864
81126a2c:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a30:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a34:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a38:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a3c:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a40:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a44:	81126c00 	call	881126c0 <__reset+0x20f26c0>
81126a48:	81126ba8 	cmpgeui	r4,r16,18862
81126a4c:	81126ba8 	cmpgeui	r4,r16,18862
81126a50:	81126bc4 	addi	r4,r16,18863
81126a54:	81126bc4 	addi	r4,r16,18863
81126a58:	81126bc4 	addi	r4,r16,18863
81126a5c:	81126bc4 	addi	r4,r16,18863
81126a60:	81126bc4 	addi	r4,r16,18863
81126a64:	81126bc4 	addi	r4,r16,18863
81126a68:	81126bc4 	addi	r4,r16,18863
81126a6c:	81126b94 	ori	r4,r16,18862
81126a70:	81126b94 	ori	r4,r16,18862
81126a74:	81126b94 	ori	r4,r16,18862
81126a78:	81126b94 	ori	r4,r16,18862
81126a7c:	81126b94 	ori	r4,r16,18862
81126a80:	81126b94 	ori	r4,r16,18862
81126a84:	81126bc4 	addi	r4,r16,18863
81126a88:	81126bc4 	addi	r4,r16,18863
81126a8c:	81126bc4 	addi	r4,r16,18863
81126a90:	81126bc4 	addi	r4,r16,18863
81126a94:	81126bc4 	addi	r4,r16,18863
81126a98:	81126bc4 	addi	r4,r16,18863
81126a9c:	81126bc4 	addi	r4,r16,18863
81126aa0:	81126bc4 	addi	r4,r16,18863
81126aa4:	81126bc4 	addi	r4,r16,18863
81126aa8:	81126bc4 	addi	r4,r16,18863
81126aac:	81126bc4 	addi	r4,r16,18863
81126ab0:	81126bc4 	addi	r4,r16,18863
81126ab4:	81126bc4 	addi	r4,r16,18863
81126ab8:	81126bc4 	addi	r4,r16,18863
81126abc:	81126bc4 	addi	r4,r16,18863
81126ac0:	81126bc4 	addi	r4,r16,18863
81126ac4:	81126bc4 	addi	r4,r16,18863
81126ac8:	81126b4c 	andi	r4,r16,18861
81126acc:	81126bc4 	addi	r4,r16,18863
81126ad0:	81126bc4 	addi	r4,r16,18863
81126ad4:	81126bc4 	addi	r4,r16,18863
81126ad8:	81126bc4 	addi	r4,r16,18863
81126adc:	81126bc4 	addi	r4,r16,18863
81126ae0:	81126bc4 	addi	r4,r16,18863
81126ae4:	81126bc4 	addi	r4,r16,18863
81126ae8:	81126bc4 	addi	r4,r16,18863
81126aec:	81126b94 	ori	r4,r16,18862
81126af0:	81126b94 	ori	r4,r16,18862
81126af4:	81126b94 	ori	r4,r16,18862
81126af8:	81126b94 	ori	r4,r16,18862
81126afc:	81126b94 	ori	r4,r16,18862
81126b00:	81126b94 	ori	r4,r16,18862
81126b04:	81126bc4 	addi	r4,r16,18863
81126b08:	81126bc4 	addi	r4,r16,18863
81126b0c:	81126bc4 	addi	r4,r16,18863
81126b10:	81126bc4 	addi	r4,r16,18863
81126b14:	81126bc4 	addi	r4,r16,18863
81126b18:	81126bc4 	addi	r4,r16,18863
81126b1c:	81126bc4 	addi	r4,r16,18863
81126b20:	81126bc4 	addi	r4,r16,18863
81126b24:	81126bc4 	addi	r4,r16,18863
81126b28:	81126bc4 	addi	r4,r16,18863
81126b2c:	81126bc4 	addi	r4,r16,18863
81126b30:	81126bc4 	addi	r4,r16,18863
81126b34:	81126bc4 	addi	r4,r16,18863
81126b38:	81126bc4 	addi	r4,r16,18863
81126b3c:	81126bc4 	addi	r4,r16,18863
81126b40:	81126bc4 	addi	r4,r16,18863
81126b44:	81126bc4 	addi	r4,r16,18863
81126b48:	81126b4c 	andi	r4,r16,18861
81126b4c:	9081800c 	andi	r2,r18,1536
81126b50:	12c01c1e 	bne	r2,r11,81126bc4 <__svfscanf_r+0x122c>
81126b54:	91a4703a 	and	r18,r18,r6
81126b58:	94814014 	ori	r18,r18,1280
81126b5c:	04400404 	movi	r17,16
81126b60:	81000005 	stb	r4,0(r16)
81126b64:	84000044 	addi	r16,r16,1
81126b68:	e0800117 	ldw	r2,4(fp)
81126b6c:	10bfffc4 	addi	r2,r2,-1
81126b70:	e0800115 	stw	r2,4(fp)
81126b74:	0080540e 	bge	zero,r2,81126cc8 <__svfscanf_r+0x1330>
81126b78:	18c00044 	addi	r3,r3,1
81126b7c:	e0c00015 	stw	r3,0(fp)
81126b80:	9cffffc4 	addi	r19,r19,-1
81126b84:	98000f26 	beq	r19,zero,81126bc4 <__svfscanf_r+0x122c>
81126b88:	e0c00017 	ldw	r3,0(fp)
81126b8c:	19000003 	ldbu	r4,0(r3)
81126b90:	003f9706 	br	811269f0 <__reset+0xfb1069f0>
81126b94:	00800284 	movi	r2,10
81126b98:	14400a0e 	bge	r2,r17,81126bc4 <__svfscanf_r+0x122c>
81126b9c:	00bd1fc4 	movi	r2,-2945
81126ba0:	90a4703a 	and	r18,r18,r2
81126ba4:	003fee06 	br	81126b60 <__reset+0xfb106b60>
81126ba8:	01604574 	movhi	r5,33045
81126bac:	8c63883a 	add	r17,r17,r17
81126bb0:	29791084 	addi	r5,r5,-7102
81126bb4:	2c45883a 	add	r2,r5,r17
81126bb8:	1440000f 	ldh	r17,0(r2)
81126bbc:	00800204 	movi	r2,8
81126bc0:	147ff616 	blt	r2,r17,81126b9c <__reset+0xfb106b9c>
81126bc4:	dc409e15 	stw	r17,632(sp)
81126bc8:	9023883a 	mov	r17,r18
81126bcc:	8880400c 	andi	r2,r17,256
81126bd0:	4825883a 	mov	r18,r9
81126bd4:	10000426 	beq	r2,zero,81126be8 <__svfscanf_r+0x1250>
81126bd8:	d9800104 	addi	r6,sp,4
81126bdc:	3400be36 	bltu	r6,r16,81126ed8 <__svfscanf_r+0x1540>
81126be0:	da000104 	addi	r8,sp,4
81126be4:	443bae26 	beq	r8,r16,81125aa0 <__reset+0xfb105aa0>
81126be8:	8880040c 	andi	r2,r17,16
81126bec:	10009326 	beq	r2,zero,81126e3c <__svfscanf_r+0x14a4>
81126bf0:	d8800104 	addi	r2,sp,4
81126bf4:	80a1c83a 	sub	r16,r16,r2
81126bf8:	8521883a 	add	r16,r16,r20
81126bfc:	003d0606 	br	81126018 <__reset+0xfb106018>
81126c00:	01604574 	movhi	r5,33045
81126c04:	8c63883a 	add	r17,r17,r17
81126c08:	29791084 	addi	r5,r5,-7102
81126c0c:	2c45883a 	add	r2,r5,r17
81126c10:	1440000f 	ldh	r17,0(r2)
81126c14:	00bd1fc4 	movi	r2,-2945
81126c18:	90a4703a 	and	r18,r18,r2
81126c1c:	003fd006 	br	81126b60 <__reset+0xfb106b60>
81126c20:	9082000c 	andi	r2,r18,2048
81126c24:	103fce26 	beq	r2,zero,81126b60 <__reset+0xfb106b60>
81126c28:	8800021e 	bne	r17,zero,81126c34 <__svfscanf_r+0x129c>
81126c2c:	94808014 	ori	r18,r18,512
81126c30:	04400204 	movi	r17,8
81126c34:	9081000c 	andi	r2,r18,1024
81126c38:	10009426 	beq	r2,zero,81126e8c <__svfscanf_r+0x14f4>
81126c3c:	00be9fc4 	movi	r2,-1409
81126c40:	90a4703a 	and	r18,r18,r2
81126c44:	003fc606 	br	81126b60 <__reset+0xfb106b60>
81126c48:	9080200c 	andi	r2,r18,128
81126c4c:	103fdd26 	beq	r2,zero,81126bc4 <__reset+0xfb106bc4>
81126c50:	9224703a 	and	r18,r18,r8
81126c54:	003fc206 	br	81126b60 <__reset+0xfb106b60>
81126c58:	9800011e 	bne	r19,zero,81126c60 <__svfscanf_r+0x12c8>
81126c5c:	04ffffc4 	movi	r19,-1
81126c60:	8900004c 	andi	r4,r17,1
81126c64:	20005b1e 	bne	r4,zero,81126dd4 <__svfscanf_r+0x143c>
81126c68:	8c40040c 	andi	r17,r17,16
81126c6c:	88003026 	beq	r17,zero,81126d30 <__svfscanf_r+0x1398>
81126c70:	0021883a 	mov	r16,zero
81126c74:	00000306 	br	81126c84 <__svfscanf_r+0x12ec>
81126c78:	18800003 	ldbu	r2,0(r3)
81126c7c:	3885883a 	add	r2,r7,r2
81126c80:	10800043 	ldbu	r2,1(r2)
81126c84:	1080020c 	andi	r2,r2,8
81126c88:	103ce31e 	bne	r2,zero,81126018 <__reset+0xfb106018>
81126c8c:	e0800117 	ldw	r2,4(fp)
81126c90:	18c00044 	addi	r3,r3,1
81126c94:	84000044 	addi	r16,r16,1
81126c98:	10bfffc4 	addi	r2,r2,-1
81126c9c:	e0800115 	stw	r2,4(fp)
81126ca0:	e0c00015 	stw	r3,0(fp)
81126ca4:	84fcdc26 	beq	r16,r19,81126018 <__reset+0xfb106018>
81126ca8:	00bff316 	blt	zero,r2,81126c78 <__reset+0xfb106c78>
81126cac:	e00b883a 	mov	r5,fp
81126cb0:	b009883a 	mov	r4,r22
81126cb4:	1120c780 	call	81120c78 <__srefill_r>
81126cb8:	103cd71e 	bne	r2,zero,81126018 <__reset+0xfb106018>
81126cbc:	b9c00017 	ldw	r7,0(r23)
81126cc0:	e0c00017 	ldw	r3,0(fp)
81126cc4:	003fec06 	br	81126c78 <__reset+0xfb106c78>
81126cc8:	e00b883a 	mov	r5,fp
81126ccc:	b009883a 	mov	r4,r22
81126cd0:	d980a715 	stw	r6,668(sp)
81126cd4:	d9c0aa15 	stw	r7,680(sp)
81126cd8:	da00a815 	stw	r8,672(sp)
81126cdc:	da40a915 	stw	r9,676(sp)
81126ce0:	dac0a615 	stw	r11,664(sp)
81126ce4:	1120c780 	call	81120c78 <__srefill_r>
81126ce8:	d980a717 	ldw	r6,668(sp)
81126cec:	d9c0aa17 	ldw	r7,680(sp)
81126cf0:	da00a817 	ldw	r8,672(sp)
81126cf4:	da40a917 	ldw	r9,676(sp)
81126cf8:	dac0a617 	ldw	r11,664(sp)
81126cfc:	103fa026 	beq	r2,zero,81126b80 <__reset+0xfb106b80>
81126d00:	003fb006 	br	81126bc4 <__reset+0xfb106bc4>
81126d04:	8821883a 	mov	r16,r17
81126d08:	b019883a 	mov	r12,r22
81126d0c:	9823883a 	mov	r17,r19
81126d10:	182d883a 	mov	r22,r3
81126d14:	00bfbfc4 	movi	r2,-257
81126d18:	a0a8703a 	and	r20,r20,r2
81126d1c:	003e6706 	br	811266bc <__reset+0xfb1066bc>
81126d20:	000f883a 	mov	r7,zero
81126d24:	003f2806 	br	811269c8 <__reset+0xfb1069c8>
81126d28:	d800a215 	stw	zero,648(sp)
81126d2c:	003de306 	br	811264bc <__reset+0xfb1064bc>
81126d30:	da009c17 	ldw	r8,624(sp)
81126d34:	9abfffc4 	addi	r10,r19,-1
81126d38:	44400017 	ldw	r17,0(r8)
81126d3c:	44000104 	addi	r16,r8,4
81126d40:	880b883a 	mov	r5,r17
81126d44:	8aa9883a 	add	r20,r17,r10
81126d48:	00000606 	br	81126d64 <__svfscanf_r+0x13cc>
81126d4c:	e0c00017 	ldw	r3,0(fp)
81126d50:	b9000017 	ldw	r4,0(r23)
81126d54:	a80b883a 	mov	r5,r21
81126d58:	18800003 	ldbu	r2,0(r3)
81126d5c:	2085883a 	add	r2,r4,r2
81126d60:	10800043 	ldbu	r2,1(r2)
81126d64:	1080020c 	andi	r2,r2,8
81126d68:	1000551e 	bne	r2,zero,81126ec0 <__svfscanf_r+0x1528>
81126d6c:	e0800117 	ldw	r2,4(fp)
81126d70:	19000044 	addi	r4,r3,1
81126d74:	e1000015 	stw	r4,0(fp)
81126d78:	10bfffc4 	addi	r2,r2,-1
81126d7c:	e0800115 	stw	r2,4(fp)
81126d80:	18800003 	ldbu	r2,0(r3)
81126d84:	2d400044 	addi	r21,r5,1
81126d88:	a827883a 	mov	r19,r21
81126d8c:	28800005 	stb	r2,0(r5)
81126d90:	2d000626 	beq	r5,r20,81126dac <__svfscanf_r+0x1414>
81126d94:	e0800117 	ldw	r2,4(fp)
81126d98:	00bfec16 	blt	zero,r2,81126d4c <__reset+0xfb106d4c>
81126d9c:	e00b883a 	mov	r5,fp
81126da0:	b009883a 	mov	r4,r22
81126da4:	1120c780 	call	81120c78 <__srefill_r>
81126da8:	103fe826 	beq	r2,zero,81126d4c <__reset+0xfb106d4c>
81126dac:	da00a017 	ldw	r8,640(sp)
81126db0:	dd009d17 	ldw	r20,628(sp)
81126db4:	9c63c83a 	sub	r17,r19,r17
81126db8:	42000044 	addi	r8,r8,1
81126dbc:	98000005 	stb	zero,0(r19)
81126dc0:	9465883a 	add	r18,r18,r17
81126dc4:	da00a015 	stw	r8,640(sp)
81126dc8:	dc009c15 	stw	r16,624(sp)
81126dcc:	a00d883a 	mov	r6,r20
81126dd0:	003b2f06 	br	81125a90 <__reset+0xfb105a90>
81126dd4:	dd409904 	addi	r21,sp,612
81126dd8:	8c40040c 	andi	r17,r17,16
81126ddc:	01800204 	movi	r6,8
81126de0:	000b883a 	mov	r5,zero
81126de4:	a809883a 	mov	r4,r21
81126de8:	11207fc0 	call	811207fc <memset>
81126dec:	8800401e 	bne	r17,zero,81126ef0 <__svfscanf_r+0x1558>
81126df0:	da009c17 	ldw	r8,624(sp)
81126df4:	45000017 	ldw	r20,0(r8)
81126df8:	42000104 	addi	r8,r8,4
81126dfc:	da009c15 	stw	r8,624(sp)
81126e00:	000d883a 	mov	r6,zero
81126e04:	3021883a 	mov	r16,r6
81126e08:	dc409f15 	stw	r17,636(sp)
81126e0c:	e0800017 	ldw	r2,0(fp)
81126e10:	b8c00017 	ldw	r3,0(r23)
81126e14:	10800003 	ldbu	r2,0(r2)
81126e18:	1885883a 	add	r2,r3,r2
81126e1c:	10800043 	ldbu	r2,1(r2)
81126e20:	1080020c 	andi	r2,r2,8
81126e24:	1000011e 	bne	r2,zero,81126e2c <__svfscanf_r+0x1494>
81126e28:	9800701e 	bne	r19,zero,81126fec <__svfscanf_r+0x1654>
81126e2c:	dc409f17 	ldw	r17,636(sp)
81126e30:	883cdd1e 	bne	r17,zero,811261a8 <__reset+0xfb1061a8>
81126e34:	a0000015 	stw	zero,0(r20)
81126e38:	003cd806 	br	8112619c <__reset+0xfb10619c>
81126e3c:	d9c09e17 	ldw	r7,632(sp)
81126e40:	da00a117 	ldw	r8,644(sp)
81126e44:	000d883a 	mov	r6,zero
81126e48:	d9400104 	addi	r5,sp,4
81126e4c:	b009883a 	mov	r4,r22
81126e50:	80000005 	stb	zero,0(r16)
81126e54:	403ee83a 	callr	r8
81126e58:	88c0080c 	andi	r3,r17,32
81126e5c:	1800121e 	bne	r3,zero,81126ea8 <__svfscanf_r+0x1510>
81126e60:	88c0010c 	andi	r3,r17,4
81126e64:	18004d26 	beq	r3,zero,81126f9c <__svfscanf_r+0x1604>
81126e68:	da009c17 	ldw	r8,624(sp)
81126e6c:	40c00017 	ldw	r3,0(r8)
81126e70:	42000104 	addi	r8,r8,4
81126e74:	da009c15 	stw	r8,624(sp)
81126e78:	1880000d 	sth	r2,0(r3)
81126e7c:	da00a017 	ldw	r8,640(sp)
81126e80:	42000044 	addi	r8,r8,1
81126e84:	da00a015 	stw	r8,640(sp)
81126e88:	003f5906 	br	81126bf0 <__reset+0xfb106bf0>
81126e8c:	00bf1fc4 	movi	r2,-897
81126e90:	90a4703a 	and	r18,r18,r2
81126e94:	38000226 	beq	r7,zero,81126ea0 <__svfscanf_r+0x1508>
81126e98:	39ffffc4 	addi	r7,r7,-1
81126e9c:	9cc00044 	addi	r19,r19,1
81126ea0:	a5000044 	addi	r20,r20,1
81126ea4:	003f3006 	br	81126b68 <__reset+0xfb106b68>
81126ea8:	da009c17 	ldw	r8,624(sp)
81126eac:	40c00017 	ldw	r3,0(r8)
81126eb0:	42000104 	addi	r8,r8,4
81126eb4:	da009c15 	stw	r8,624(sp)
81126eb8:	18800015 	stw	r2,0(r3)
81126ebc:	003fef06 	br	81126e7c <__reset+0xfb106e7c>
81126ec0:	2827883a 	mov	r19,r5
81126ec4:	003fb906 	br	81126dac <__reset+0xfb106dac>
81126ec8:	01be1fc4 	movi	r6,-1921
81126ecc:	a1a8703a 	and	r20,r20,r6
81126ed0:	05400044 	movi	r21,1
81126ed4:	003de906 	br	8112667c <__reset+0xfb10667c>
81126ed8:	817fffc7 	ldb	r5,-1(r16)
81126edc:	e00d883a 	mov	r6,fp
81126ee0:	b009883a 	mov	r4,r22
81126ee4:	843fffc4 	addi	r16,r16,-1
81126ee8:	112f5f00 	call	8112f5f0 <_ungetc_r>
81126eec:	003f3c06 	br	81126be0 <__reset+0xfb106be0>
81126ef0:	dd009b04 	addi	r20,sp,620
81126ef4:	003fc206 	br	81126e00 <__reset+0xfb106e00>
81126ef8:	00be1fc4 	movi	r2,-1921
81126efc:	a0a8703a 	and	r20,r20,r2
81126f00:	05800044 	movi	r22,1
81126f04:	003ddd06 	br	8112667c <__reset+0xfb10667c>
81126f08:	d8c09f17 	ldw	r3,636(sp)
81126f0c:	88e3c83a 	sub	r17,r17,r3
81126f10:	044dc83a 	sub	r6,zero,r17
81126f14:	883e2126 	beq	r17,zero,8112679c <__reset+0xfb10679c>
81126f18:	d88055c4 	addi	r2,sp,343
81126f1c:	80800136 	bltu	r16,r2,81126f24 <__svfscanf_r+0x158c>
81126f20:	dc005584 	addi	r16,sp,342
81126f24:	01604574 	movhi	r5,33045
81126f28:	29790f04 	addi	r5,r5,-7108
81126f2c:	8009883a 	mov	r4,r16
81126f30:	1120f8c0 	call	81120f8c <sprintf>
81126f34:	003e1906 	br	8112679c <__reset+0xfb10679c>
81126f38:	d8c0a517 	ldw	r3,660(sp)
81126f3c:	000d883a 	mov	r6,zero
81126f40:	01c00284 	movi	r7,10
81126f44:	19400044 	addi	r5,r3,1
81126f48:	b009883a 	mov	r4,r22
81126f4c:	112127c0 	call	8112127c <_strtol_r>
81126f50:	da00a417 	ldw	r8,656(sp)
81126f54:	dc00a517 	ldw	r16,660(sp)
81126f58:	120dc83a 	sub	r6,r2,r8
81126f5c:	003fee06 	br	81126f18 <__reset+0xfb106f18>
81126f60:	da009c17 	ldw	r8,624(sp)
81126f64:	180b883a 	mov	r5,r3
81126f68:	8009883a 	mov	r4,r16
81126f6c:	45000017 	ldw	r20,0(r8)
81126f70:	44400104 	addi	r17,r8,4
81126f74:	d8c0a615 	stw	r3,664(sp)
81126f78:	112bf0c0 	call	8112bf0c <__fpclassifyd>
81126f7c:	d8c0a617 	ldw	r3,664(sp)
81126f80:	10006426 	beq	r2,zero,81127114 <__svfscanf_r+0x177c>
81126f84:	8009883a 	mov	r4,r16
81126f88:	180b883a 	mov	r5,r3
81126f8c:	111f2940 	call	8111f294 <__truncdfsf2>
81126f90:	a0800015 	stw	r2,0(r20)
81126f94:	dc409c15 	stw	r17,624(sp)
81126f98:	003e0f06 	br	811267d8 <__reset+0xfb1067d8>
81126f9c:	88c0004c 	andi	r3,r17,1
81126fa0:	183fc11e 	bne	r3,zero,81126ea8 <__reset+0xfb106ea8>
81126fa4:	8c40008c 	andi	r17,r17,2
81126fa8:	883fbf26 	beq	r17,zero,81126ea8 <__reset+0xfb106ea8>
81126fac:	da00a117 	ldw	r8,644(sp)
81126fb0:	00a044f4 	movhi	r2,33043
81126fb4:	10b6ea04 	addi	r2,r2,-9304
81126fb8:	d9c09e17 	ldw	r7,632(sp)
81126fbc:	000d883a 	mov	r6,zero
81126fc0:	d9400104 	addi	r5,sp,4
81126fc4:	b009883a 	mov	r4,r22
81126fc8:	40806226 	beq	r8,r2,81127154 <__svfscanf_r+0x17bc>
81126fcc:	112d8c00 	call	8112d8c0 <_strtoll_r>
81126fd0:	da009c17 	ldw	r8,624(sp)
81126fd4:	41000017 	ldw	r4,0(r8)
81126fd8:	42000104 	addi	r8,r8,4
81126fdc:	da009c15 	stw	r8,624(sp)
81126fe0:	20800015 	stw	r2,0(r4)
81126fe4:	20c00115 	stw	r3,4(r4)
81126fe8:	003fa406 	br	81126e7c <__reset+0xfb106e7c>
81126fec:	112a39c0 	call	8112a39c <__locale_mb_cur_max>
81126ff0:	80bca726 	beq	r16,r2,81126290 <__reset+0xfb106290>
81126ff4:	e0800017 	ldw	r2,0(fp)
81126ff8:	e1000117 	ldw	r4,4(fp)
81126ffc:	d8c00104 	addi	r3,sp,4
81127000:	12000003 	ldbu	r8,0(r2)
81127004:	213fffc4 	addi	r4,r4,-1
81127008:	10800044 	addi	r2,r2,1
8112700c:	e1000115 	stw	r4,4(fp)
81127010:	e0800015 	stw	r2,0(fp)
81127014:	84400044 	addi	r17,r16,1
81127018:	dd400015 	stw	r21,0(sp)
8112701c:	1c21883a 	add	r16,r3,r16
81127020:	b009883a 	mov	r4,r22
81127024:	880f883a 	mov	r7,r17
81127028:	180d883a 	mov	r6,r3
8112702c:	a00b883a 	mov	r5,r20
81127030:	82000005 	stb	r8,0(r16)
81127034:	112a4580 	call	8112a458 <_mbrtowc_r>
81127038:	013fffc4 	movi	r4,-1
8112703c:	113c9426 	beq	r2,r4,81126290 <__reset+0xfb106290>
81127040:	103c881e 	bne	r2,zero,81126264 <__reset+0xfb106264>
81127044:	a0000015 	stw	zero,0(r20)
81127048:	0009883a 	mov	r4,zero
8112704c:	112a2dc0 	call	8112a2dc <iswspace>
81127050:	10001a26 	beq	r2,zero,811270bc <__svfscanf_r+0x1724>
81127054:	8821883a 	mov	r16,r17
81127058:	dc409f17 	ldw	r17,636(sp)
8112705c:	803f7426 	beq	r16,zero,81126e30 <__reset+0xfb106e30>
81127060:	843fffc4 	addi	r16,r16,-1
81127064:	d9800104 	addi	r6,sp,4
81127068:	342b883a 	add	r21,r6,r16
8112706c:	00000106 	br	81127074 <__svfscanf_r+0x16dc>
81127070:	843fffc4 	addi	r16,r16,-1
81127074:	a9400003 	ldbu	r5,0(r21)
81127078:	e00d883a 	mov	r6,fp
8112707c:	b009883a 	mov	r4,r22
81127080:	112f5f00 	call	8112f5f0 <_ungetc_r>
81127084:	ad7fffc4 	addi	r21,r21,-1
81127088:	803ff91e 	bne	r16,zero,81127070 <__reset+0xfb107070>
8112708c:	003f6806 	br	81126e30 <__reset+0xfb106e30>
81127090:	d9800104 	addi	r6,sp,4
81127094:	802b883a 	mov	r21,r16
81127098:	343a812e 	bgeu	r6,r16,81125aa0 <__reset+0xfb105aa0>
8112709c:	ad7fffc4 	addi	r21,r21,-1
811270a0:	a9400007 	ldb	r5,0(r21)
811270a4:	e00d883a 	mov	r6,fp
811270a8:	b009883a 	mov	r4,r22
811270ac:	112f5f00 	call	8112f5f0 <_ungetc_r>
811270b0:	da000104 	addi	r8,sp,4
811270b4:	457ff91e 	bne	r8,r21,8112709c <__reset+0xfb10709c>
811270b8:	003a7906 	br	81125aa0 <__reset+0xfb105aa0>
811270bc:	da009f17 	ldw	r8,636(sp)
811270c0:	9465883a 	add	r18,r18,r17
811270c4:	9cffffc4 	addi	r19,r19,-1
811270c8:	4000051e 	bne	r8,zero,811270e0 <__svfscanf_r+0x1748>
811270cc:	a5000104 	addi	r20,r20,4
811270d0:	0021883a 	mov	r16,zero
811270d4:	003c6606 	br	81126270 <__reset+0xfb106270>
811270d8:	a1000017 	ldw	r4,0(r20)
811270dc:	003fdb06 	br	8112704c <__reset+0xfb10704c>
811270e0:	0021883a 	mov	r16,zero
811270e4:	003c6206 	br	81126270 <__reset+0xfb106270>
811270e8:	d8800104 	addi	r2,sp,4
811270ec:	802b883a 	mov	r21,r16
811270f0:	143a6b2e 	bgeu	r2,r16,81125aa0 <__reset+0xfb105aa0>
811270f4:	ad7fffc4 	addi	r21,r21,-1
811270f8:	a9400007 	ldb	r5,0(r21)
811270fc:	e00d883a 	mov	r6,fp
81127100:	b009883a 	mov	r4,r22
81127104:	112f5f00 	call	8112f5f0 <_ungetc_r>
81127108:	d8c00104 	addi	r3,sp,4
8112710c:	1d7ff91e 	bne	r3,r21,811270f4 <__reset+0xfb1070f4>
81127110:	003a6306 	br	81125aa0 <__reset+0xfb105aa0>
81127114:	0009883a 	mov	r4,zero
81127118:	112c0500 	call	8112c050 <nanf>
8112711c:	a0800015 	stw	r2,0(r20)
81127120:	dc409c15 	stw	r17,624(sp)
81127124:	003dac06 	br	811267d8 <__reset+0xfb1067d8>
81127128:	d9000104 	addi	r4,sp,4
8112712c:	802b883a 	mov	r21,r16
81127130:	243a5b2e 	bgeu	r4,r16,81125aa0 <__reset+0xfb105aa0>
81127134:	ad7fffc4 	addi	r21,r21,-1
81127138:	a9400007 	ldb	r5,0(r21)
8112713c:	e00d883a 	mov	r6,fp
81127140:	b009883a 	mov	r4,r22
81127144:	112f5f00 	call	8112f5f0 <_ungetc_r>
81127148:	d9400104 	addi	r5,sp,4
8112714c:	2d7ff91e 	bne	r5,r21,81127134 <__reset+0xfb107134>
81127150:	003a5306 	br	81125aa0 <__reset+0xfb105aa0>
81127154:	112de180 	call	8112de18 <_strtoull_r>
81127158:	003f9d06 	br	81126fd0 <__reset+0xfb106fd0>

8112715c <vfscanf>:
8112715c:	00a04574 	movhi	r2,33045
81127160:	defffb04 	addi	sp,sp,-20
81127164:	1082c604 	addi	r2,r2,2840
81127168:	de00012e 	bgeu	sp,et,81127170 <vfscanf+0x14>
8112716c:	003b68fa 	trap	3
81127170:	dc000215 	stw	r16,8(sp)
81127174:	14000017 	ldw	r16,0(r2)
81127178:	dc400315 	stw	r17,12(sp)
8112717c:	dfc00415 	stw	ra,16(sp)
81127180:	2023883a 	mov	r17,r4
81127184:	80000826 	beq	r16,zero,811271a8 <vfscanf+0x4c>
81127188:	80800e17 	ldw	r2,56(r16)
8112718c:	1000061e 	bne	r2,zero,811271a8 <vfscanf+0x4c>
81127190:	8009883a 	mov	r4,r16
81127194:	d9400015 	stw	r5,0(sp)
81127198:	d9800115 	stw	r6,4(sp)
8112719c:	11294740 	call	81129474 <__sinit>
811271a0:	d9800117 	ldw	r6,4(sp)
811271a4:	d9400017 	ldw	r5,0(sp)
811271a8:	300f883a 	mov	r7,r6
811271ac:	8009883a 	mov	r4,r16
811271b0:	280d883a 	mov	r6,r5
811271b4:	880b883a 	mov	r5,r17
811271b8:	dfc00417 	ldw	ra,16(sp)
811271bc:	dc400317 	ldw	r17,12(sp)
811271c0:	dc000217 	ldw	r16,8(sp)
811271c4:	dec00504 	addi	sp,sp,20
811271c8:	11259981 	jmpi	81125998 <__svfscanf_r>

811271cc <__svfscanf>:
811271cc:	00a04574 	movhi	r2,33045
811271d0:	1082c604 	addi	r2,r2,2840
811271d4:	300f883a 	mov	r7,r6
811271d8:	280d883a 	mov	r6,r5
811271dc:	200b883a 	mov	r5,r4
811271e0:	11000017 	ldw	r4,0(r2)
811271e4:	11259981 	jmpi	81125998 <__svfscanf_r>

811271e8 <_vfscanf_r>:
811271e8:	defffb04 	addi	sp,sp,-20
811271ec:	de00012e 	bgeu	sp,et,811271f4 <_vfscanf_r+0xc>
811271f0:	003b68fa 	trap	3
811271f4:	dc000315 	stw	r16,12(sp)
811271f8:	dfc00415 	stw	ra,16(sp)
811271fc:	2021883a 	mov	r16,r4
81127200:	20000926 	beq	r4,zero,81127228 <_vfscanf_r+0x40>
81127204:	20800e17 	ldw	r2,56(r4)
81127208:	1000071e 	bne	r2,zero,81127228 <_vfscanf_r+0x40>
8112720c:	d9400015 	stw	r5,0(sp)
81127210:	d9800115 	stw	r6,4(sp)
81127214:	d9c00215 	stw	r7,8(sp)
81127218:	11294740 	call	81129474 <__sinit>
8112721c:	d9c00217 	ldw	r7,8(sp)
81127220:	d9800117 	ldw	r6,4(sp)
81127224:	d9400017 	ldw	r5,0(sp)
81127228:	8009883a 	mov	r4,r16
8112722c:	dfc00417 	ldw	ra,16(sp)
81127230:	dc000317 	ldw	r16,12(sp)
81127234:	dec00504 	addi	sp,sp,20
81127238:	11259981 	jmpi	81125998 <__svfscanf_r>

8112723c <__swbuf_r>:
8112723c:	defffb04 	addi	sp,sp,-20
81127240:	de00012e 	bgeu	sp,et,81127248 <__swbuf_r+0xc>
81127244:	003b68fa 	trap	3
81127248:	dcc00315 	stw	r19,12(sp)
8112724c:	dc800215 	stw	r18,8(sp)
81127250:	dc000015 	stw	r16,0(sp)
81127254:	dfc00415 	stw	ra,16(sp)
81127258:	dc400115 	stw	r17,4(sp)
8112725c:	2025883a 	mov	r18,r4
81127260:	2827883a 	mov	r19,r5
81127264:	3021883a 	mov	r16,r6
81127268:	20000226 	beq	r4,zero,81127274 <__swbuf_r+0x38>
8112726c:	20800e17 	ldw	r2,56(r4)
81127270:	10004226 	beq	r2,zero,8112737c <__swbuf_r+0x140>
81127274:	80800617 	ldw	r2,24(r16)
81127278:	8100030b 	ldhu	r4,12(r16)
8112727c:	80800215 	stw	r2,8(r16)
81127280:	2080020c 	andi	r2,r4,8
81127284:	10003626 	beq	r2,zero,81127360 <__swbuf_r+0x124>
81127288:	80c00417 	ldw	r3,16(r16)
8112728c:	18003426 	beq	r3,zero,81127360 <__swbuf_r+0x124>
81127290:	2088000c 	andi	r2,r4,8192
81127294:	9c403fcc 	andi	r17,r19,255
81127298:	10001a26 	beq	r2,zero,81127304 <__swbuf_r+0xc8>
8112729c:	80800017 	ldw	r2,0(r16)
811272a0:	81000517 	ldw	r4,20(r16)
811272a4:	10c7c83a 	sub	r3,r2,r3
811272a8:	1900200e 	bge	r3,r4,8112732c <__swbuf_r+0xf0>
811272ac:	18c00044 	addi	r3,r3,1
811272b0:	81000217 	ldw	r4,8(r16)
811272b4:	11400044 	addi	r5,r2,1
811272b8:	81400015 	stw	r5,0(r16)
811272bc:	213fffc4 	addi	r4,r4,-1
811272c0:	81000215 	stw	r4,8(r16)
811272c4:	14c00005 	stb	r19,0(r2)
811272c8:	80800517 	ldw	r2,20(r16)
811272cc:	10c01e26 	beq	r2,r3,81127348 <__swbuf_r+0x10c>
811272d0:	8080030b 	ldhu	r2,12(r16)
811272d4:	1080004c 	andi	r2,r2,1
811272d8:	10000226 	beq	r2,zero,811272e4 <__swbuf_r+0xa8>
811272dc:	00800284 	movi	r2,10
811272e0:	88801926 	beq	r17,r2,81127348 <__swbuf_r+0x10c>
811272e4:	8805883a 	mov	r2,r17
811272e8:	dfc00417 	ldw	ra,16(sp)
811272ec:	dcc00317 	ldw	r19,12(sp)
811272f0:	dc800217 	ldw	r18,8(sp)
811272f4:	dc400117 	ldw	r17,4(sp)
811272f8:	dc000017 	ldw	r16,0(sp)
811272fc:	dec00504 	addi	sp,sp,20
81127300:	f800283a 	ret
81127304:	81401917 	ldw	r5,100(r16)
81127308:	00b7ffc4 	movi	r2,-8193
8112730c:	21080014 	ori	r4,r4,8192
81127310:	2884703a 	and	r2,r5,r2
81127314:	80801915 	stw	r2,100(r16)
81127318:	80800017 	ldw	r2,0(r16)
8112731c:	8100030d 	sth	r4,12(r16)
81127320:	81000517 	ldw	r4,20(r16)
81127324:	10c7c83a 	sub	r3,r2,r3
81127328:	193fe016 	blt	r3,r4,811272ac <__reset+0xfb1072ac>
8112732c:	800b883a 	mov	r5,r16
81127330:	9009883a 	mov	r4,r18
81127334:	11290780 	call	81129078 <_fflush_r>
81127338:	1000071e 	bne	r2,zero,81127358 <__swbuf_r+0x11c>
8112733c:	80800017 	ldw	r2,0(r16)
81127340:	00c00044 	movi	r3,1
81127344:	003fda06 	br	811272b0 <__reset+0xfb1072b0>
81127348:	800b883a 	mov	r5,r16
8112734c:	9009883a 	mov	r4,r18
81127350:	11290780 	call	81129078 <_fflush_r>
81127354:	103fe326 	beq	r2,zero,811272e4 <__reset+0xfb1072e4>
81127358:	00bfffc4 	movi	r2,-1
8112735c:	003fe206 	br	811272e8 <__reset+0xfb1072e8>
81127360:	800b883a 	mov	r5,r16
81127364:	9009883a 	mov	r4,r18
81127368:	11274040 	call	81127404 <__swsetup_r>
8112736c:	103ffa1e 	bne	r2,zero,81127358 <__reset+0xfb107358>
81127370:	8100030b 	ldhu	r4,12(r16)
81127374:	80c00417 	ldw	r3,16(r16)
81127378:	003fc506 	br	81127290 <__reset+0xfb107290>
8112737c:	11294740 	call	81129474 <__sinit>
81127380:	003fbc06 	br	81127274 <__reset+0xfb107274>

81127384 <__swbuf>:
81127384:	00a04574 	movhi	r2,33045
81127388:	1082c604 	addi	r2,r2,2840
8112738c:	280d883a 	mov	r6,r5
81127390:	200b883a 	mov	r5,r4
81127394:	11000017 	ldw	r4,0(r2)
81127398:	112723c1 	jmpi	8112723c <__swbuf_r>

8112739c <_write_r>:
8112739c:	defffd04 	addi	sp,sp,-12
811273a0:	de00012e 	bgeu	sp,et,811273a8 <_write_r+0xc>
811273a4:	003b68fa 	trap	3
811273a8:	2805883a 	mov	r2,r5
811273ac:	dc000015 	stw	r16,0(sp)
811273b0:	04204574 	movhi	r16,33045
811273b4:	dc400115 	stw	r17,4(sp)
811273b8:	300b883a 	mov	r5,r6
811273bc:	84033804 	addi	r16,r16,3296
811273c0:	2023883a 	mov	r17,r4
811273c4:	380d883a 	mov	r6,r7
811273c8:	1009883a 	mov	r4,r2
811273cc:	dfc00215 	stw	ra,8(sp)
811273d0:	80000015 	stw	zero,0(r16)
811273d4:	1135e940 	call	81135e94 <write>
811273d8:	00ffffc4 	movi	r3,-1
811273dc:	10c00526 	beq	r2,r3,811273f4 <_write_r+0x58>
811273e0:	dfc00217 	ldw	ra,8(sp)
811273e4:	dc400117 	ldw	r17,4(sp)
811273e8:	dc000017 	ldw	r16,0(sp)
811273ec:	dec00304 	addi	sp,sp,12
811273f0:	f800283a 	ret
811273f4:	80c00017 	ldw	r3,0(r16)
811273f8:	183ff926 	beq	r3,zero,811273e0 <__reset+0xfb1073e0>
811273fc:	88c00015 	stw	r3,0(r17)
81127400:	003ff706 	br	811273e0 <__reset+0xfb1073e0>

81127404 <__swsetup_r>:
81127404:	00a04574 	movhi	r2,33045
81127408:	defffd04 	addi	sp,sp,-12
8112740c:	1082c604 	addi	r2,r2,2840
81127410:	de00012e 	bgeu	sp,et,81127418 <__swsetup_r+0x14>
81127414:	003b68fa 	trap	3
81127418:	dc400115 	stw	r17,4(sp)
8112741c:	2023883a 	mov	r17,r4
81127420:	11000017 	ldw	r4,0(r2)
81127424:	dc000015 	stw	r16,0(sp)
81127428:	dfc00215 	stw	ra,8(sp)
8112742c:	2821883a 	mov	r16,r5
81127430:	20000226 	beq	r4,zero,8112743c <__swsetup_r+0x38>
81127434:	20800e17 	ldw	r2,56(r4)
81127438:	10003126 	beq	r2,zero,81127500 <__swsetup_r+0xfc>
8112743c:	8080030b 	ldhu	r2,12(r16)
81127440:	10c0020c 	andi	r3,r2,8
81127444:	1009883a 	mov	r4,r2
81127448:	18000f26 	beq	r3,zero,81127488 <__swsetup_r+0x84>
8112744c:	80c00417 	ldw	r3,16(r16)
81127450:	18001526 	beq	r3,zero,811274a8 <__swsetup_r+0xa4>
81127454:	1100004c 	andi	r4,r2,1
81127458:	20001c1e 	bne	r4,zero,811274cc <__swsetup_r+0xc8>
8112745c:	1080008c 	andi	r2,r2,2
81127460:	1000291e 	bne	r2,zero,81127508 <__swsetup_r+0x104>
81127464:	80800517 	ldw	r2,20(r16)
81127468:	80800215 	stw	r2,8(r16)
8112746c:	18001c26 	beq	r3,zero,811274e0 <__swsetup_r+0xdc>
81127470:	0005883a 	mov	r2,zero
81127474:	dfc00217 	ldw	ra,8(sp)
81127478:	dc400117 	ldw	r17,4(sp)
8112747c:	dc000017 	ldw	r16,0(sp)
81127480:	dec00304 	addi	sp,sp,12
81127484:	f800283a 	ret
81127488:	2080040c 	andi	r2,r4,16
8112748c:	10002e26 	beq	r2,zero,81127548 <__swsetup_r+0x144>
81127490:	2080010c 	andi	r2,r4,4
81127494:	10001e1e 	bne	r2,zero,81127510 <__swsetup_r+0x10c>
81127498:	80c00417 	ldw	r3,16(r16)
8112749c:	20800214 	ori	r2,r4,8
811274a0:	8080030d 	sth	r2,12(r16)
811274a4:	183feb1e 	bne	r3,zero,81127454 <__reset+0xfb107454>
811274a8:	1100a00c 	andi	r4,r2,640
811274ac:	01408004 	movi	r5,512
811274b0:	217fe826 	beq	r4,r5,81127454 <__reset+0xfb107454>
811274b4:	800b883a 	mov	r5,r16
811274b8:	8809883a 	mov	r4,r17
811274bc:	111fcd40 	call	8111fcd4 <__smakebuf_r>
811274c0:	8080030b 	ldhu	r2,12(r16)
811274c4:	80c00417 	ldw	r3,16(r16)
811274c8:	003fe206 	br	81127454 <__reset+0xfb107454>
811274cc:	80800517 	ldw	r2,20(r16)
811274d0:	80000215 	stw	zero,8(r16)
811274d4:	0085c83a 	sub	r2,zero,r2
811274d8:	80800615 	stw	r2,24(r16)
811274dc:	183fe41e 	bne	r3,zero,81127470 <__reset+0xfb107470>
811274e0:	80c0030b 	ldhu	r3,12(r16)
811274e4:	0005883a 	mov	r2,zero
811274e8:	1900200c 	andi	r4,r3,128
811274ec:	203fe126 	beq	r4,zero,81127474 <__reset+0xfb107474>
811274f0:	18c01014 	ori	r3,r3,64
811274f4:	80c0030d 	sth	r3,12(r16)
811274f8:	00bfffc4 	movi	r2,-1
811274fc:	003fdd06 	br	81127474 <__reset+0xfb107474>
81127500:	11294740 	call	81129474 <__sinit>
81127504:	003fcd06 	br	8112743c <__reset+0xfb10743c>
81127508:	0005883a 	mov	r2,zero
8112750c:	003fd606 	br	81127468 <__reset+0xfb107468>
81127510:	81400c17 	ldw	r5,48(r16)
81127514:	28000626 	beq	r5,zero,81127530 <__swsetup_r+0x12c>
81127518:	80801004 	addi	r2,r16,64
8112751c:	28800326 	beq	r5,r2,8112752c <__swsetup_r+0x128>
81127520:	8809883a 	mov	r4,r17
81127524:	112990c0 	call	8112990c <_free_r>
81127528:	8100030b 	ldhu	r4,12(r16)
8112752c:	80000c15 	stw	zero,48(r16)
81127530:	80c00417 	ldw	r3,16(r16)
81127534:	00bff6c4 	movi	r2,-37
81127538:	1108703a 	and	r4,r2,r4
8112753c:	80000115 	stw	zero,4(r16)
81127540:	80c00015 	stw	r3,0(r16)
81127544:	003fd506 	br	8112749c <__reset+0xfb10749c>
81127548:	00800244 	movi	r2,9
8112754c:	88800015 	stw	r2,0(r17)
81127550:	20801014 	ori	r2,r4,64
81127554:	8080030d 	sth	r2,12(r16)
81127558:	00bfffc4 	movi	r2,-1
8112755c:	003fc506 	br	81127474 <__reset+0xfb107474>

81127560 <_close_r>:
81127560:	defffd04 	addi	sp,sp,-12
81127564:	de00012e 	bgeu	sp,et,8112756c <_close_r+0xc>
81127568:	003b68fa 	trap	3
8112756c:	dc000015 	stw	r16,0(sp)
81127570:	04204574 	movhi	r16,33045
81127574:	dc400115 	stw	r17,4(sp)
81127578:	84033804 	addi	r16,r16,3296
8112757c:	2023883a 	mov	r17,r4
81127580:	2809883a 	mov	r4,r5
81127584:	dfc00215 	stw	ra,8(sp)
81127588:	80000015 	stw	zero,0(r16)
8112758c:	11344140 	call	81134414 <close>
81127590:	00ffffc4 	movi	r3,-1
81127594:	10c00526 	beq	r2,r3,811275ac <_close_r+0x4c>
81127598:	dfc00217 	ldw	ra,8(sp)
8112759c:	dc400117 	ldw	r17,4(sp)
811275a0:	dc000017 	ldw	r16,0(sp)
811275a4:	dec00304 	addi	sp,sp,12
811275a8:	f800283a 	ret
811275ac:	80c00017 	ldw	r3,0(r16)
811275b0:	183ff926 	beq	r3,zero,81127598 <__reset+0xfb107598>
811275b4:	88c00015 	stw	r3,0(r17)
811275b8:	003ff706 	br	81127598 <__reset+0xfb107598>

811275bc <quorem>:
811275bc:	defff704 	addi	sp,sp,-36
811275c0:	de00012e 	bgeu	sp,et,811275c8 <quorem+0xc>
811275c4:	003b68fa 	trap	3
811275c8:	dc800215 	stw	r18,8(sp)
811275cc:	20800417 	ldw	r2,16(r4)
811275d0:	2c800417 	ldw	r18,16(r5)
811275d4:	dfc00815 	stw	ra,32(sp)
811275d8:	ddc00715 	stw	r23,28(sp)
811275dc:	dd800615 	stw	r22,24(sp)
811275e0:	dd400515 	stw	r21,20(sp)
811275e4:	dd000415 	stw	r20,16(sp)
811275e8:	dcc00315 	stw	r19,12(sp)
811275ec:	dc400115 	stw	r17,4(sp)
811275f0:	dc000015 	stw	r16,0(sp)
811275f4:	14807116 	blt	r2,r18,811277bc <quorem+0x200>
811275f8:	94bfffc4 	addi	r18,r18,-1
811275fc:	94ad883a 	add	r22,r18,r18
81127600:	b5ad883a 	add	r22,r22,r22
81127604:	2c400504 	addi	r17,r5,20
81127608:	8da9883a 	add	r20,r17,r22
8112760c:	25400504 	addi	r21,r4,20
81127610:	282f883a 	mov	r23,r5
81127614:	adad883a 	add	r22,r21,r22
81127618:	a1400017 	ldw	r5,0(r20)
8112761c:	2021883a 	mov	r16,r4
81127620:	b1000017 	ldw	r4,0(r22)
81127624:	29400044 	addi	r5,r5,1
81127628:	1132c180 	call	81132c18 <__udivsi3>
8112762c:	1027883a 	mov	r19,r2
81127630:	10002c26 	beq	r2,zero,811276e4 <quorem+0x128>
81127634:	a813883a 	mov	r9,r21
81127638:	880b883a 	mov	r5,r17
8112763c:	0009883a 	mov	r4,zero
81127640:	000d883a 	mov	r6,zero
81127644:	2a000017 	ldw	r8,0(r5)
81127648:	49c00017 	ldw	r7,0(r9)
8112764c:	29400104 	addi	r5,r5,4
81127650:	40bfffcc 	andi	r2,r8,65535
81127654:	14c5383a 	mul	r2,r2,r19
81127658:	4010d43a 	srli	r8,r8,16
8112765c:	38ffffcc 	andi	r3,r7,65535
81127660:	1105883a 	add	r2,r2,r4
81127664:	1008d43a 	srli	r4,r2,16
81127668:	44d1383a 	mul	r8,r8,r19
8112766c:	198d883a 	add	r6,r3,r6
81127670:	10ffffcc 	andi	r3,r2,65535
81127674:	30c7c83a 	sub	r3,r6,r3
81127678:	380ed43a 	srli	r7,r7,16
8112767c:	4105883a 	add	r2,r8,r4
81127680:	180dd43a 	srai	r6,r3,16
81127684:	113fffcc 	andi	r4,r2,65535
81127688:	390fc83a 	sub	r7,r7,r4
8112768c:	398d883a 	add	r6,r7,r6
81127690:	300e943a 	slli	r7,r6,16
81127694:	18ffffcc 	andi	r3,r3,65535
81127698:	1008d43a 	srli	r4,r2,16
8112769c:	38ceb03a 	or	r7,r7,r3
811276a0:	49c00015 	stw	r7,0(r9)
811276a4:	300dd43a 	srai	r6,r6,16
811276a8:	4a400104 	addi	r9,r9,4
811276ac:	a17fe52e 	bgeu	r20,r5,81127644 <__reset+0xfb107644>
811276b0:	b0800017 	ldw	r2,0(r22)
811276b4:	10000b1e 	bne	r2,zero,811276e4 <quorem+0x128>
811276b8:	b0bfff04 	addi	r2,r22,-4
811276bc:	a880082e 	bgeu	r21,r2,811276e0 <quorem+0x124>
811276c0:	b0ffff17 	ldw	r3,-4(r22)
811276c4:	18000326 	beq	r3,zero,811276d4 <quorem+0x118>
811276c8:	00000506 	br	811276e0 <quorem+0x124>
811276cc:	10c00017 	ldw	r3,0(r2)
811276d0:	1800031e 	bne	r3,zero,811276e0 <quorem+0x124>
811276d4:	10bfff04 	addi	r2,r2,-4
811276d8:	94bfffc4 	addi	r18,r18,-1
811276dc:	a8bffb36 	bltu	r21,r2,811276cc <__reset+0xfb1076cc>
811276e0:	84800415 	stw	r18,16(r16)
811276e4:	b80b883a 	mov	r5,r23
811276e8:	8009883a 	mov	r4,r16
811276ec:	112b1dc0 	call	8112b1dc <__mcmp>
811276f0:	10002616 	blt	r2,zero,8112778c <quorem+0x1d0>
811276f4:	9cc00044 	addi	r19,r19,1
811276f8:	a805883a 	mov	r2,r21
811276fc:	000b883a 	mov	r5,zero
81127700:	11000017 	ldw	r4,0(r2)
81127704:	89800017 	ldw	r6,0(r17)
81127708:	10800104 	addi	r2,r2,4
8112770c:	20ffffcc 	andi	r3,r4,65535
81127710:	194b883a 	add	r5,r3,r5
81127714:	30ffffcc 	andi	r3,r6,65535
81127718:	28c7c83a 	sub	r3,r5,r3
8112771c:	300cd43a 	srli	r6,r6,16
81127720:	2008d43a 	srli	r4,r4,16
81127724:	180bd43a 	srai	r5,r3,16
81127728:	18ffffcc 	andi	r3,r3,65535
8112772c:	2189c83a 	sub	r4,r4,r6
81127730:	2149883a 	add	r4,r4,r5
81127734:	200c943a 	slli	r6,r4,16
81127738:	8c400104 	addi	r17,r17,4
8112773c:	200bd43a 	srai	r5,r4,16
81127740:	30c6b03a 	or	r3,r6,r3
81127744:	10ffff15 	stw	r3,-4(r2)
81127748:	a47fed2e 	bgeu	r20,r17,81127700 <__reset+0xfb107700>
8112774c:	9485883a 	add	r2,r18,r18
81127750:	1085883a 	add	r2,r2,r2
81127754:	a887883a 	add	r3,r21,r2
81127758:	18800017 	ldw	r2,0(r3)
8112775c:	10000b1e 	bne	r2,zero,8112778c <quorem+0x1d0>
81127760:	18bfff04 	addi	r2,r3,-4
81127764:	a880082e 	bgeu	r21,r2,81127788 <quorem+0x1cc>
81127768:	18ffff17 	ldw	r3,-4(r3)
8112776c:	18000326 	beq	r3,zero,8112777c <quorem+0x1c0>
81127770:	00000506 	br	81127788 <quorem+0x1cc>
81127774:	10c00017 	ldw	r3,0(r2)
81127778:	1800031e 	bne	r3,zero,81127788 <quorem+0x1cc>
8112777c:	10bfff04 	addi	r2,r2,-4
81127780:	94bfffc4 	addi	r18,r18,-1
81127784:	a8bffb36 	bltu	r21,r2,81127774 <__reset+0xfb107774>
81127788:	84800415 	stw	r18,16(r16)
8112778c:	9805883a 	mov	r2,r19
81127790:	dfc00817 	ldw	ra,32(sp)
81127794:	ddc00717 	ldw	r23,28(sp)
81127798:	dd800617 	ldw	r22,24(sp)
8112779c:	dd400517 	ldw	r21,20(sp)
811277a0:	dd000417 	ldw	r20,16(sp)
811277a4:	dcc00317 	ldw	r19,12(sp)
811277a8:	dc800217 	ldw	r18,8(sp)
811277ac:	dc400117 	ldw	r17,4(sp)
811277b0:	dc000017 	ldw	r16,0(sp)
811277b4:	dec00904 	addi	sp,sp,36
811277b8:	f800283a 	ret
811277bc:	0005883a 	mov	r2,zero
811277c0:	003ff306 	br	81127790 <__reset+0xfb107790>

811277c4 <_dtoa_r>:
811277c4:	deffde04 	addi	sp,sp,-136
811277c8:	de00012e 	bgeu	sp,et,811277d0 <_dtoa_r+0xc>
811277cc:	003b68fa 	trap	3
811277d0:	20801017 	ldw	r2,64(r4)
811277d4:	df002015 	stw	fp,128(sp)
811277d8:	dcc01b15 	stw	r19,108(sp)
811277dc:	dc801a15 	stw	r18,104(sp)
811277e0:	dc401915 	stw	r17,100(sp)
811277e4:	dc001815 	stw	r16,96(sp)
811277e8:	dfc02115 	stw	ra,132(sp)
811277ec:	ddc01f15 	stw	r23,124(sp)
811277f0:	dd801e15 	stw	r22,120(sp)
811277f4:	dd401d15 	stw	r21,116(sp)
811277f8:	dd001c15 	stw	r20,112(sp)
811277fc:	d9c00315 	stw	r7,12(sp)
81127800:	2039883a 	mov	fp,r4
81127804:	3023883a 	mov	r17,r6
81127808:	2825883a 	mov	r18,r5
8112780c:	dc002417 	ldw	r16,144(sp)
81127810:	3027883a 	mov	r19,r6
81127814:	10000826 	beq	r2,zero,81127838 <_dtoa_r+0x74>
81127818:	21801117 	ldw	r6,68(r4)
8112781c:	00c00044 	movi	r3,1
81127820:	100b883a 	mov	r5,r2
81127824:	1986983a 	sll	r3,r3,r6
81127828:	11800115 	stw	r6,4(r2)
8112782c:	10c00215 	stw	r3,8(r2)
81127830:	112a98c0 	call	8112a98c <_Bfree>
81127834:	e0001015 	stw	zero,64(fp)
81127838:	88002e16 	blt	r17,zero,811278f4 <_dtoa_r+0x130>
8112783c:	80000015 	stw	zero,0(r16)
81127840:	889ffc2c 	andhi	r2,r17,32752
81127844:	00dffc34 	movhi	r3,32752
81127848:	10c01c26 	beq	r2,r3,811278bc <_dtoa_r+0xf8>
8112784c:	000d883a 	mov	r6,zero
81127850:	000f883a 	mov	r7,zero
81127854:	9009883a 	mov	r4,r18
81127858:	980b883a 	mov	r5,r19
8112785c:	11340740 	call	81134074 <__eqdf2>
81127860:	10002b1e 	bne	r2,zero,81127910 <_dtoa_r+0x14c>
81127864:	d9c02317 	ldw	r7,140(sp)
81127868:	00800044 	movi	r2,1
8112786c:	38800015 	stw	r2,0(r7)
81127870:	d8802517 	ldw	r2,148(sp)
81127874:	10019e26 	beq	r2,zero,81127ef0 <_dtoa_r+0x72c>
81127878:	d8c02517 	ldw	r3,148(sp)
8112787c:	00a04574 	movhi	r2,33045
81127880:	10b8fe44 	addi	r2,r2,-7175
81127884:	18800015 	stw	r2,0(r3)
81127888:	10bfffc4 	addi	r2,r2,-1
8112788c:	dfc02117 	ldw	ra,132(sp)
81127890:	df002017 	ldw	fp,128(sp)
81127894:	ddc01f17 	ldw	r23,124(sp)
81127898:	dd801e17 	ldw	r22,120(sp)
8112789c:	dd401d17 	ldw	r21,116(sp)
811278a0:	dd001c17 	ldw	r20,112(sp)
811278a4:	dcc01b17 	ldw	r19,108(sp)
811278a8:	dc801a17 	ldw	r18,104(sp)
811278ac:	dc401917 	ldw	r17,100(sp)
811278b0:	dc001817 	ldw	r16,96(sp)
811278b4:	dec02204 	addi	sp,sp,136
811278b8:	f800283a 	ret
811278bc:	d8c02317 	ldw	r3,140(sp)
811278c0:	0089c3c4 	movi	r2,9999
811278c4:	18800015 	stw	r2,0(r3)
811278c8:	90017726 	beq	r18,zero,81127ea8 <_dtoa_r+0x6e4>
811278cc:	00a04574 	movhi	r2,33045
811278d0:	10b91c04 	addi	r2,r2,-7056
811278d4:	d9002517 	ldw	r4,148(sp)
811278d8:	203fec26 	beq	r4,zero,8112788c <__reset+0xfb10788c>
811278dc:	10c000c7 	ldb	r3,3(r2)
811278e0:	1801781e 	bne	r3,zero,81127ec4 <_dtoa_r+0x700>
811278e4:	10c000c4 	addi	r3,r2,3
811278e8:	d9802517 	ldw	r6,148(sp)
811278ec:	30c00015 	stw	r3,0(r6)
811278f0:	003fe606 	br	8112788c <__reset+0xfb10788c>
811278f4:	04e00034 	movhi	r19,32768
811278f8:	9cffffc4 	addi	r19,r19,-1
811278fc:	00800044 	movi	r2,1
81127900:	8ce6703a 	and	r19,r17,r19
81127904:	80800015 	stw	r2,0(r16)
81127908:	9823883a 	mov	r17,r19
8112790c:	003fcc06 	br	81127840 <__reset+0xfb107840>
81127910:	d8800204 	addi	r2,sp,8
81127914:	d8800015 	stw	r2,0(sp)
81127918:	d9c00104 	addi	r7,sp,4
8112791c:	900b883a 	mov	r5,r18
81127920:	980d883a 	mov	r6,r19
81127924:	e009883a 	mov	r4,fp
81127928:	8820d53a 	srli	r16,r17,20
8112792c:	112b5b80 	call	8112b5b8 <__d2b>
81127930:	d8800915 	stw	r2,36(sp)
81127934:	8001651e 	bne	r16,zero,81127ecc <_dtoa_r+0x708>
81127938:	dd800217 	ldw	r22,8(sp)
8112793c:	dc000117 	ldw	r16,4(sp)
81127940:	00800804 	movi	r2,32
81127944:	b421883a 	add	r16,r22,r16
81127948:	80c10c84 	addi	r3,r16,1074
8112794c:	10c2d10e 	bge	r2,r3,81128494 <_dtoa_r+0xcd0>
81127950:	00801004 	movi	r2,64
81127954:	81010484 	addi	r4,r16,1042
81127958:	10c7c83a 	sub	r3,r2,r3
8112795c:	9108d83a 	srl	r4,r18,r4
81127960:	88e2983a 	sll	r17,r17,r3
81127964:	2448b03a 	or	r4,r4,r17
81127968:	11341f00 	call	811341f0 <__floatunsidf>
8112796c:	017f8434 	movhi	r5,65040
81127970:	01800044 	movi	r6,1
81127974:	1009883a 	mov	r4,r2
81127978:	194b883a 	add	r5,r3,r5
8112797c:	843fffc4 	addi	r16,r16,-1
81127980:	d9801115 	stw	r6,68(sp)
81127984:	000d883a 	mov	r6,zero
81127988:	01cffe34 	movhi	r7,16376
8112798c:	111e7140 	call	8111e714 <__subdf3>
81127990:	0198dbf4 	movhi	r6,25455
81127994:	01cff4f4 	movhi	r7,16339
81127998:	3190d844 	addi	r6,r6,17249
8112799c:	39e1e9c4 	addi	r7,r7,-30809
811279a0:	1009883a 	mov	r4,r2
811279a4:	180b883a 	mov	r5,r3
811279a8:	111dff40 	call	8111dff4 <__muldf3>
811279ac:	01a2d874 	movhi	r6,35681
811279b0:	01cff1f4 	movhi	r7,16327
811279b4:	31b22cc4 	addi	r6,r6,-14157
811279b8:	39e28a04 	addi	r7,r7,-30168
811279bc:	180b883a 	mov	r5,r3
811279c0:	1009883a 	mov	r4,r2
811279c4:	1132ed00 	call	81132ed0 <__adddf3>
811279c8:	8009883a 	mov	r4,r16
811279cc:	1029883a 	mov	r20,r2
811279d0:	1823883a 	mov	r17,r3
811279d4:	111f0980 	call	8111f098 <__floatsidf>
811279d8:	019427f4 	movhi	r6,20639
811279dc:	01cff4f4 	movhi	r7,16339
811279e0:	319e7ec4 	addi	r6,r6,31227
811279e4:	39d104c4 	addi	r7,r7,17427
811279e8:	1009883a 	mov	r4,r2
811279ec:	180b883a 	mov	r5,r3
811279f0:	111dff40 	call	8111dff4 <__muldf3>
811279f4:	100d883a 	mov	r6,r2
811279f8:	180f883a 	mov	r7,r3
811279fc:	a009883a 	mov	r4,r20
81127a00:	880b883a 	mov	r5,r17
81127a04:	1132ed00 	call	81132ed0 <__adddf3>
81127a08:	1009883a 	mov	r4,r2
81127a0c:	180b883a 	mov	r5,r3
81127a10:	1029883a 	mov	r20,r2
81127a14:	1823883a 	mov	r17,r3
81127a18:	111f0180 	call	8111f018 <__fixdfsi>
81127a1c:	000d883a 	mov	r6,zero
81127a20:	000f883a 	mov	r7,zero
81127a24:	a009883a 	mov	r4,r20
81127a28:	880b883a 	mov	r5,r17
81127a2c:	d8800515 	stw	r2,20(sp)
81127a30:	11340fc0 	call	811340fc <__ledf2>
81127a34:	10028716 	blt	r2,zero,81128454 <_dtoa_r+0xc90>
81127a38:	d8c00517 	ldw	r3,20(sp)
81127a3c:	00800584 	movi	r2,22
81127a40:	10c27536 	bltu	r2,r3,81128418 <_dtoa_r+0xc54>
81127a44:	180490fa 	slli	r2,r3,3
81127a48:	00e04574 	movhi	r3,33045
81127a4c:	18f93704 	addi	r3,r3,-6948
81127a50:	1885883a 	add	r2,r3,r2
81127a54:	11000017 	ldw	r4,0(r2)
81127a58:	11400117 	ldw	r5,4(r2)
81127a5c:	900d883a 	mov	r6,r18
81127a60:	980f883a 	mov	r7,r19
81127a64:	111df180 	call	8111df18 <__gedf2>
81127a68:	00828d0e 	bge	zero,r2,811284a0 <_dtoa_r+0xcdc>
81127a6c:	d9000517 	ldw	r4,20(sp)
81127a70:	d8000e15 	stw	zero,56(sp)
81127a74:	213fffc4 	addi	r4,r4,-1
81127a78:	d9000515 	stw	r4,20(sp)
81127a7c:	b42dc83a 	sub	r22,r22,r16
81127a80:	b5bfffc4 	addi	r22,r22,-1
81127a84:	b0026f16 	blt	r22,zero,81128444 <_dtoa_r+0xc80>
81127a88:	d8000815 	stw	zero,32(sp)
81127a8c:	d9c00517 	ldw	r7,20(sp)
81127a90:	38026416 	blt	r7,zero,81128424 <_dtoa_r+0xc60>
81127a94:	b1ed883a 	add	r22,r22,r7
81127a98:	d9c00d15 	stw	r7,52(sp)
81127a9c:	d8000a15 	stw	zero,40(sp)
81127aa0:	d9800317 	ldw	r6,12(sp)
81127aa4:	00800244 	movi	r2,9
81127aa8:	11811436 	bltu	r2,r6,81127efc <_dtoa_r+0x738>
81127aac:	00800144 	movi	r2,5
81127ab0:	1184e10e 	bge	r2,r6,81128e38 <_dtoa_r+0x1674>
81127ab4:	31bfff04 	addi	r6,r6,-4
81127ab8:	d9800315 	stw	r6,12(sp)
81127abc:	0023883a 	mov	r17,zero
81127ac0:	d9800317 	ldw	r6,12(sp)
81127ac4:	008000c4 	movi	r2,3
81127ac8:	30836726 	beq	r6,r2,81128868 <_dtoa_r+0x10a4>
81127acc:	1183410e 	bge	r2,r6,811287d4 <_dtoa_r+0x1010>
81127ad0:	d9c00317 	ldw	r7,12(sp)
81127ad4:	00800104 	movi	r2,4
81127ad8:	38827c26 	beq	r7,r2,811284cc <_dtoa_r+0xd08>
81127adc:	00800144 	movi	r2,5
81127ae0:	3884c41e 	bne	r7,r2,81128df4 <_dtoa_r+0x1630>
81127ae4:	00800044 	movi	r2,1
81127ae8:	d8800b15 	stw	r2,44(sp)
81127aec:	d8c00517 	ldw	r3,20(sp)
81127af0:	d9002217 	ldw	r4,136(sp)
81127af4:	1907883a 	add	r3,r3,r4
81127af8:	19800044 	addi	r6,r3,1
81127afc:	d8c00c15 	stw	r3,48(sp)
81127b00:	d9800615 	stw	r6,24(sp)
81127b04:	0183a40e 	bge	zero,r6,81128998 <_dtoa_r+0x11d4>
81127b08:	d9800617 	ldw	r6,24(sp)
81127b0c:	3021883a 	mov	r16,r6
81127b10:	e0001115 	stw	zero,68(fp)
81127b14:	008005c4 	movi	r2,23
81127b18:	1184c92e 	bgeu	r2,r6,81128e40 <_dtoa_r+0x167c>
81127b1c:	00c00044 	movi	r3,1
81127b20:	00800104 	movi	r2,4
81127b24:	1085883a 	add	r2,r2,r2
81127b28:	11000504 	addi	r4,r2,20
81127b2c:	180b883a 	mov	r5,r3
81127b30:	18c00044 	addi	r3,r3,1
81127b34:	313ffb2e 	bgeu	r6,r4,81127b24 <__reset+0xfb107b24>
81127b38:	e1401115 	stw	r5,68(fp)
81127b3c:	e009883a 	mov	r4,fp
81127b40:	112a8dc0 	call	8112a8dc <_Balloc>
81127b44:	d8800715 	stw	r2,28(sp)
81127b48:	e0801015 	stw	r2,64(fp)
81127b4c:	00800384 	movi	r2,14
81127b50:	1400f736 	bltu	r2,r16,81127f30 <_dtoa_r+0x76c>
81127b54:	8800f626 	beq	r17,zero,81127f30 <_dtoa_r+0x76c>
81127b58:	d9c00517 	ldw	r7,20(sp)
81127b5c:	01c39a0e 	bge	zero,r7,811289c8 <_dtoa_r+0x1204>
81127b60:	388003cc 	andi	r2,r7,15
81127b64:	100490fa 	slli	r2,r2,3
81127b68:	382bd13a 	srai	r21,r7,4
81127b6c:	00e04574 	movhi	r3,33045
81127b70:	18f93704 	addi	r3,r3,-6948
81127b74:	1885883a 	add	r2,r3,r2
81127b78:	a8c0040c 	andi	r3,r21,16
81127b7c:	12400017 	ldw	r9,0(r2)
81127b80:	12000117 	ldw	r8,4(r2)
81127b84:	18037926 	beq	r3,zero,8112896c <_dtoa_r+0x11a8>
81127b88:	00a04574 	movhi	r2,33045
81127b8c:	10b92d04 	addi	r2,r2,-6988
81127b90:	11800817 	ldw	r6,32(r2)
81127b94:	11c00917 	ldw	r7,36(r2)
81127b98:	9009883a 	mov	r4,r18
81127b9c:	980b883a 	mov	r5,r19
81127ba0:	da001715 	stw	r8,92(sp)
81127ba4:	da401615 	stw	r9,88(sp)
81127ba8:	11337840 	call	81133784 <__divdf3>
81127bac:	da001717 	ldw	r8,92(sp)
81127bb0:	da401617 	ldw	r9,88(sp)
81127bb4:	ad4003cc 	andi	r21,r21,15
81127bb8:	040000c4 	movi	r16,3
81127bbc:	1023883a 	mov	r17,r2
81127bc0:	1829883a 	mov	r20,r3
81127bc4:	a8001126 	beq	r21,zero,81127c0c <_dtoa_r+0x448>
81127bc8:	05e04574 	movhi	r23,33045
81127bcc:	bdf92d04 	addi	r23,r23,-6988
81127bd0:	4805883a 	mov	r2,r9
81127bd4:	4007883a 	mov	r3,r8
81127bd8:	a980004c 	andi	r6,r21,1
81127bdc:	1009883a 	mov	r4,r2
81127be0:	a82bd07a 	srai	r21,r21,1
81127be4:	180b883a 	mov	r5,r3
81127be8:	30000426 	beq	r6,zero,81127bfc <_dtoa_r+0x438>
81127bec:	b9800017 	ldw	r6,0(r23)
81127bf0:	b9c00117 	ldw	r7,4(r23)
81127bf4:	84000044 	addi	r16,r16,1
81127bf8:	111dff40 	call	8111dff4 <__muldf3>
81127bfc:	bdc00204 	addi	r23,r23,8
81127c00:	a83ff51e 	bne	r21,zero,81127bd8 <__reset+0xfb107bd8>
81127c04:	1013883a 	mov	r9,r2
81127c08:	1811883a 	mov	r8,r3
81127c0c:	480d883a 	mov	r6,r9
81127c10:	400f883a 	mov	r7,r8
81127c14:	8809883a 	mov	r4,r17
81127c18:	a00b883a 	mov	r5,r20
81127c1c:	11337840 	call	81133784 <__divdf3>
81127c20:	d8800f15 	stw	r2,60(sp)
81127c24:	d8c01015 	stw	r3,64(sp)
81127c28:	d8c00e17 	ldw	r3,56(sp)
81127c2c:	18000626 	beq	r3,zero,81127c48 <_dtoa_r+0x484>
81127c30:	d9000f17 	ldw	r4,60(sp)
81127c34:	d9401017 	ldw	r5,64(sp)
81127c38:	000d883a 	mov	r6,zero
81127c3c:	01cffc34 	movhi	r7,16368
81127c40:	11340fc0 	call	811340fc <__ledf2>
81127c44:	10040b16 	blt	r2,zero,81128c74 <_dtoa_r+0x14b0>
81127c48:	8009883a 	mov	r4,r16
81127c4c:	111f0980 	call	8111f098 <__floatsidf>
81127c50:	d9800f17 	ldw	r6,60(sp)
81127c54:	d9c01017 	ldw	r7,64(sp)
81127c58:	1009883a 	mov	r4,r2
81127c5c:	180b883a 	mov	r5,r3
81127c60:	111dff40 	call	8111dff4 <__muldf3>
81127c64:	000d883a 	mov	r6,zero
81127c68:	01d00734 	movhi	r7,16412
81127c6c:	1009883a 	mov	r4,r2
81127c70:	180b883a 	mov	r5,r3
81127c74:	1132ed00 	call	81132ed0 <__adddf3>
81127c78:	1021883a 	mov	r16,r2
81127c7c:	d8800617 	ldw	r2,24(sp)
81127c80:	047f3034 	movhi	r17,64704
81127c84:	1c63883a 	add	r17,r3,r17
81127c88:	10031826 	beq	r2,zero,811288ec <_dtoa_r+0x1128>
81127c8c:	d8c00517 	ldw	r3,20(sp)
81127c90:	db000617 	ldw	r12,24(sp)
81127c94:	d8c01315 	stw	r3,76(sp)
81127c98:	d9000b17 	ldw	r4,44(sp)
81127c9c:	20038f26 	beq	r4,zero,81128adc <_dtoa_r+0x1318>
81127ca0:	60bfffc4 	addi	r2,r12,-1
81127ca4:	100490fa 	slli	r2,r2,3
81127ca8:	00e04574 	movhi	r3,33045
81127cac:	18f93704 	addi	r3,r3,-6948
81127cb0:	1885883a 	add	r2,r3,r2
81127cb4:	11800017 	ldw	r6,0(r2)
81127cb8:	11c00117 	ldw	r7,4(r2)
81127cbc:	d8800717 	ldw	r2,28(sp)
81127cc0:	0009883a 	mov	r4,zero
81127cc4:	014ff834 	movhi	r5,16352
81127cc8:	db001615 	stw	r12,88(sp)
81127ccc:	15c00044 	addi	r23,r2,1
81127cd0:	11337840 	call	81133784 <__divdf3>
81127cd4:	800d883a 	mov	r6,r16
81127cd8:	880f883a 	mov	r7,r17
81127cdc:	1009883a 	mov	r4,r2
81127ce0:	180b883a 	mov	r5,r3
81127ce4:	111e7140 	call	8111e714 <__subdf3>
81127ce8:	d9401017 	ldw	r5,64(sp)
81127cec:	d9000f17 	ldw	r4,60(sp)
81127cf0:	102b883a 	mov	r21,r2
81127cf4:	d8c01215 	stw	r3,72(sp)
81127cf8:	111f0180 	call	8111f018 <__fixdfsi>
81127cfc:	1009883a 	mov	r4,r2
81127d00:	1029883a 	mov	r20,r2
81127d04:	111f0980 	call	8111f098 <__floatsidf>
81127d08:	d9000f17 	ldw	r4,60(sp)
81127d0c:	d9401017 	ldw	r5,64(sp)
81127d10:	100d883a 	mov	r6,r2
81127d14:	180f883a 	mov	r7,r3
81127d18:	111e7140 	call	8111e714 <__subdf3>
81127d1c:	1823883a 	mov	r17,r3
81127d20:	d8c00717 	ldw	r3,28(sp)
81127d24:	d9401217 	ldw	r5,72(sp)
81127d28:	a2000c04 	addi	r8,r20,48
81127d2c:	1021883a 	mov	r16,r2
81127d30:	1a000005 	stb	r8,0(r3)
81127d34:	800d883a 	mov	r6,r16
81127d38:	880f883a 	mov	r7,r17
81127d3c:	a809883a 	mov	r4,r21
81127d40:	4029883a 	mov	r20,r8
81127d44:	111df180 	call	8111df18 <__gedf2>
81127d48:	00841d16 	blt	zero,r2,81128dc0 <_dtoa_r+0x15fc>
81127d4c:	800d883a 	mov	r6,r16
81127d50:	880f883a 	mov	r7,r17
81127d54:	0009883a 	mov	r4,zero
81127d58:	014ffc34 	movhi	r5,16368
81127d5c:	111e7140 	call	8111e714 <__subdf3>
81127d60:	d9401217 	ldw	r5,72(sp)
81127d64:	100d883a 	mov	r6,r2
81127d68:	180f883a 	mov	r7,r3
81127d6c:	a809883a 	mov	r4,r21
81127d70:	111df180 	call	8111df18 <__gedf2>
81127d74:	db001617 	ldw	r12,88(sp)
81127d78:	00840e16 	blt	zero,r2,81128db4 <_dtoa_r+0x15f0>
81127d7c:	00800044 	movi	r2,1
81127d80:	13006b0e 	bge	r2,r12,81127f30 <_dtoa_r+0x76c>
81127d84:	d9000717 	ldw	r4,28(sp)
81127d88:	dd800f15 	stw	r22,60(sp)
81127d8c:	dcc01015 	stw	r19,64(sp)
81127d90:	2319883a 	add	r12,r4,r12
81127d94:	dcc01217 	ldw	r19,72(sp)
81127d98:	602d883a 	mov	r22,r12
81127d9c:	dc801215 	stw	r18,72(sp)
81127da0:	b825883a 	mov	r18,r23
81127da4:	00000906 	br	81127dcc <_dtoa_r+0x608>
81127da8:	111e7140 	call	8111e714 <__subdf3>
81127dac:	a80d883a 	mov	r6,r21
81127db0:	980f883a 	mov	r7,r19
81127db4:	1009883a 	mov	r4,r2
81127db8:	180b883a 	mov	r5,r3
81127dbc:	11340fc0 	call	811340fc <__ledf2>
81127dc0:	1003e816 	blt	r2,zero,81128d64 <_dtoa_r+0x15a0>
81127dc4:	b825883a 	mov	r18,r23
81127dc8:	bd83e926 	beq	r23,r22,81128d70 <_dtoa_r+0x15ac>
81127dcc:	a809883a 	mov	r4,r21
81127dd0:	980b883a 	mov	r5,r19
81127dd4:	000d883a 	mov	r6,zero
81127dd8:	01d00934 	movhi	r7,16420
81127ddc:	111dff40 	call	8111dff4 <__muldf3>
81127de0:	000d883a 	mov	r6,zero
81127de4:	01d00934 	movhi	r7,16420
81127de8:	8009883a 	mov	r4,r16
81127dec:	880b883a 	mov	r5,r17
81127df0:	102b883a 	mov	r21,r2
81127df4:	1827883a 	mov	r19,r3
81127df8:	111dff40 	call	8111dff4 <__muldf3>
81127dfc:	180b883a 	mov	r5,r3
81127e00:	1009883a 	mov	r4,r2
81127e04:	1821883a 	mov	r16,r3
81127e08:	1023883a 	mov	r17,r2
81127e0c:	111f0180 	call	8111f018 <__fixdfsi>
81127e10:	1009883a 	mov	r4,r2
81127e14:	1029883a 	mov	r20,r2
81127e18:	111f0980 	call	8111f098 <__floatsidf>
81127e1c:	8809883a 	mov	r4,r17
81127e20:	800b883a 	mov	r5,r16
81127e24:	100d883a 	mov	r6,r2
81127e28:	180f883a 	mov	r7,r3
81127e2c:	111e7140 	call	8111e714 <__subdf3>
81127e30:	a5000c04 	addi	r20,r20,48
81127e34:	a80d883a 	mov	r6,r21
81127e38:	980f883a 	mov	r7,r19
81127e3c:	1009883a 	mov	r4,r2
81127e40:	180b883a 	mov	r5,r3
81127e44:	95000005 	stb	r20,0(r18)
81127e48:	1021883a 	mov	r16,r2
81127e4c:	1823883a 	mov	r17,r3
81127e50:	11340fc0 	call	811340fc <__ledf2>
81127e54:	bdc00044 	addi	r23,r23,1
81127e58:	800d883a 	mov	r6,r16
81127e5c:	880f883a 	mov	r7,r17
81127e60:	0009883a 	mov	r4,zero
81127e64:	014ffc34 	movhi	r5,16368
81127e68:	103fcf0e 	bge	r2,zero,81127da8 <__reset+0xfb107da8>
81127e6c:	d8c01317 	ldw	r3,76(sp)
81127e70:	d8c00515 	stw	r3,20(sp)
81127e74:	d9400917 	ldw	r5,36(sp)
81127e78:	e009883a 	mov	r4,fp
81127e7c:	112a98c0 	call	8112a98c <_Bfree>
81127e80:	d9000517 	ldw	r4,20(sp)
81127e84:	d9802317 	ldw	r6,140(sp)
81127e88:	d9c02517 	ldw	r7,148(sp)
81127e8c:	b8000005 	stb	zero,0(r23)
81127e90:	20800044 	addi	r2,r4,1
81127e94:	30800015 	stw	r2,0(r6)
81127e98:	3802aa26 	beq	r7,zero,81128944 <_dtoa_r+0x1180>
81127e9c:	3dc00015 	stw	r23,0(r7)
81127ea0:	d8800717 	ldw	r2,28(sp)
81127ea4:	003e7906 	br	8112788c <__reset+0xfb10788c>
81127ea8:	00800434 	movhi	r2,16
81127eac:	10bfffc4 	addi	r2,r2,-1
81127eb0:	88a2703a 	and	r17,r17,r2
81127eb4:	883e851e 	bne	r17,zero,811278cc <__reset+0xfb1078cc>
81127eb8:	00a04574 	movhi	r2,33045
81127ebc:	10b91904 	addi	r2,r2,-7068
81127ec0:	003e8406 	br	811278d4 <__reset+0xfb1078d4>
81127ec4:	10c00204 	addi	r3,r2,8
81127ec8:	003e8706 	br	811278e8 <__reset+0xfb1078e8>
81127ecc:	01400434 	movhi	r5,16
81127ed0:	297fffc4 	addi	r5,r5,-1
81127ed4:	994a703a 	and	r5,r19,r5
81127ed8:	9009883a 	mov	r4,r18
81127edc:	843f0044 	addi	r16,r16,-1023
81127ee0:	294ffc34 	orhi	r5,r5,16368
81127ee4:	dd800217 	ldw	r22,8(sp)
81127ee8:	d8001115 	stw	zero,68(sp)
81127eec:	003ea506 	br	81127984 <__reset+0xfb107984>
81127ef0:	00a04574 	movhi	r2,33045
81127ef4:	10b8fe04 	addi	r2,r2,-7176
81127ef8:	003e6406 	br	8112788c <__reset+0xfb10788c>
81127efc:	e0001115 	stw	zero,68(fp)
81127f00:	000b883a 	mov	r5,zero
81127f04:	e009883a 	mov	r4,fp
81127f08:	112a8dc0 	call	8112a8dc <_Balloc>
81127f0c:	01bfffc4 	movi	r6,-1
81127f10:	01c00044 	movi	r7,1
81127f14:	d8800715 	stw	r2,28(sp)
81127f18:	d9800c15 	stw	r6,48(sp)
81127f1c:	e0801015 	stw	r2,64(fp)
81127f20:	d8000315 	stw	zero,12(sp)
81127f24:	d9c00b15 	stw	r7,44(sp)
81127f28:	d9800615 	stw	r6,24(sp)
81127f2c:	d8002215 	stw	zero,136(sp)
81127f30:	d8800117 	ldw	r2,4(sp)
81127f34:	10008916 	blt	r2,zero,8112815c <_dtoa_r+0x998>
81127f38:	d9000517 	ldw	r4,20(sp)
81127f3c:	00c00384 	movi	r3,14
81127f40:	19008616 	blt	r3,r4,8112815c <_dtoa_r+0x998>
81127f44:	200490fa 	slli	r2,r4,3
81127f48:	00e04574 	movhi	r3,33045
81127f4c:	d9802217 	ldw	r6,136(sp)
81127f50:	18f93704 	addi	r3,r3,-6948
81127f54:	1885883a 	add	r2,r3,r2
81127f58:	14000017 	ldw	r16,0(r2)
81127f5c:	14400117 	ldw	r17,4(r2)
81127f60:	30016316 	blt	r6,zero,811284f0 <_dtoa_r+0xd2c>
81127f64:	800d883a 	mov	r6,r16
81127f68:	880f883a 	mov	r7,r17
81127f6c:	9009883a 	mov	r4,r18
81127f70:	980b883a 	mov	r5,r19
81127f74:	11337840 	call	81133784 <__divdf3>
81127f78:	180b883a 	mov	r5,r3
81127f7c:	1009883a 	mov	r4,r2
81127f80:	111f0180 	call	8111f018 <__fixdfsi>
81127f84:	1009883a 	mov	r4,r2
81127f88:	102b883a 	mov	r21,r2
81127f8c:	111f0980 	call	8111f098 <__floatsidf>
81127f90:	800d883a 	mov	r6,r16
81127f94:	880f883a 	mov	r7,r17
81127f98:	1009883a 	mov	r4,r2
81127f9c:	180b883a 	mov	r5,r3
81127fa0:	111dff40 	call	8111dff4 <__muldf3>
81127fa4:	100d883a 	mov	r6,r2
81127fa8:	180f883a 	mov	r7,r3
81127fac:	9009883a 	mov	r4,r18
81127fb0:	980b883a 	mov	r5,r19
81127fb4:	111e7140 	call	8111e714 <__subdf3>
81127fb8:	d9c00717 	ldw	r7,28(sp)
81127fbc:	1009883a 	mov	r4,r2
81127fc0:	a8800c04 	addi	r2,r21,48
81127fc4:	38800005 	stb	r2,0(r7)
81127fc8:	3dc00044 	addi	r23,r7,1
81127fcc:	d9c00617 	ldw	r7,24(sp)
81127fd0:	01800044 	movi	r6,1
81127fd4:	180b883a 	mov	r5,r3
81127fd8:	2005883a 	mov	r2,r4
81127fdc:	39803826 	beq	r7,r6,811280c0 <_dtoa_r+0x8fc>
81127fe0:	000d883a 	mov	r6,zero
81127fe4:	01d00934 	movhi	r7,16420
81127fe8:	111dff40 	call	8111dff4 <__muldf3>
81127fec:	000d883a 	mov	r6,zero
81127ff0:	000f883a 	mov	r7,zero
81127ff4:	1009883a 	mov	r4,r2
81127ff8:	180b883a 	mov	r5,r3
81127ffc:	1025883a 	mov	r18,r2
81128000:	1827883a 	mov	r19,r3
81128004:	11340740 	call	81134074 <__eqdf2>
81128008:	103f9a26 	beq	r2,zero,81127e74 <__reset+0xfb107e74>
8112800c:	d9c00617 	ldw	r7,24(sp)
81128010:	d8c00717 	ldw	r3,28(sp)
81128014:	b829883a 	mov	r20,r23
81128018:	38bfffc4 	addi	r2,r7,-1
8112801c:	18ad883a 	add	r22,r3,r2
81128020:	00000a06 	br	8112804c <_dtoa_r+0x888>
81128024:	111dff40 	call	8111dff4 <__muldf3>
81128028:	000d883a 	mov	r6,zero
8112802c:	000f883a 	mov	r7,zero
81128030:	1009883a 	mov	r4,r2
81128034:	180b883a 	mov	r5,r3
81128038:	1025883a 	mov	r18,r2
8112803c:	1827883a 	mov	r19,r3
81128040:	b829883a 	mov	r20,r23
81128044:	11340740 	call	81134074 <__eqdf2>
81128048:	103f8a26 	beq	r2,zero,81127e74 <__reset+0xfb107e74>
8112804c:	800d883a 	mov	r6,r16
81128050:	880f883a 	mov	r7,r17
81128054:	9009883a 	mov	r4,r18
81128058:	980b883a 	mov	r5,r19
8112805c:	11337840 	call	81133784 <__divdf3>
81128060:	180b883a 	mov	r5,r3
81128064:	1009883a 	mov	r4,r2
81128068:	111f0180 	call	8111f018 <__fixdfsi>
8112806c:	1009883a 	mov	r4,r2
81128070:	102b883a 	mov	r21,r2
81128074:	111f0980 	call	8111f098 <__floatsidf>
81128078:	800d883a 	mov	r6,r16
8112807c:	880f883a 	mov	r7,r17
81128080:	1009883a 	mov	r4,r2
81128084:	180b883a 	mov	r5,r3
81128088:	111dff40 	call	8111dff4 <__muldf3>
8112808c:	100d883a 	mov	r6,r2
81128090:	180f883a 	mov	r7,r3
81128094:	9009883a 	mov	r4,r18
81128098:	980b883a 	mov	r5,r19
8112809c:	111e7140 	call	8111e714 <__subdf3>
811280a0:	aa000c04 	addi	r8,r21,48
811280a4:	a2000005 	stb	r8,0(r20)
811280a8:	000d883a 	mov	r6,zero
811280ac:	01d00934 	movhi	r7,16420
811280b0:	1009883a 	mov	r4,r2
811280b4:	180b883a 	mov	r5,r3
811280b8:	a5c00044 	addi	r23,r20,1
811280bc:	b53fd91e 	bne	r22,r20,81128024 <__reset+0xfb108024>
811280c0:	100d883a 	mov	r6,r2
811280c4:	180f883a 	mov	r7,r3
811280c8:	1009883a 	mov	r4,r2
811280cc:	180b883a 	mov	r5,r3
811280d0:	1132ed00 	call	81132ed0 <__adddf3>
811280d4:	100d883a 	mov	r6,r2
811280d8:	180f883a 	mov	r7,r3
811280dc:	8009883a 	mov	r4,r16
811280e0:	880b883a 	mov	r5,r17
811280e4:	1027883a 	mov	r19,r2
811280e8:	1825883a 	mov	r18,r3
811280ec:	11340fc0 	call	811340fc <__ledf2>
811280f0:	10000816 	blt	r2,zero,81128114 <_dtoa_r+0x950>
811280f4:	980d883a 	mov	r6,r19
811280f8:	900f883a 	mov	r7,r18
811280fc:	8009883a 	mov	r4,r16
81128100:	880b883a 	mov	r5,r17
81128104:	11340740 	call	81134074 <__eqdf2>
81128108:	103f5a1e 	bne	r2,zero,81127e74 <__reset+0xfb107e74>
8112810c:	ad40004c 	andi	r21,r21,1
81128110:	a83f5826 	beq	r21,zero,81127e74 <__reset+0xfb107e74>
81128114:	bd3fffc3 	ldbu	r20,-1(r23)
81128118:	b8bfffc4 	addi	r2,r23,-1
8112811c:	1007883a 	mov	r3,r2
81128120:	01400e44 	movi	r5,57
81128124:	d9800717 	ldw	r6,28(sp)
81128128:	00000506 	br	81128140 <_dtoa_r+0x97c>
8112812c:	18ffffc4 	addi	r3,r3,-1
81128130:	11824726 	beq	r2,r6,81128a50 <_dtoa_r+0x128c>
81128134:	1d000003 	ldbu	r20,0(r3)
81128138:	102f883a 	mov	r23,r2
8112813c:	10bfffc4 	addi	r2,r2,-1
81128140:	a1003fcc 	andi	r4,r20,255
81128144:	2100201c 	xori	r4,r4,128
81128148:	213fe004 	addi	r4,r4,-128
8112814c:	217ff726 	beq	r4,r5,8112812c <__reset+0xfb10812c>
81128150:	a2000044 	addi	r8,r20,1
81128154:	12000005 	stb	r8,0(r2)
81128158:	003f4606 	br	81127e74 <__reset+0xfb107e74>
8112815c:	d9000b17 	ldw	r4,44(sp)
81128160:	2000c826 	beq	r4,zero,81128484 <_dtoa_r+0xcc0>
81128164:	d9800317 	ldw	r6,12(sp)
81128168:	00c00044 	movi	r3,1
8112816c:	1980f90e 	bge	r3,r6,81128554 <_dtoa_r+0xd90>
81128170:	d8800617 	ldw	r2,24(sp)
81128174:	d8c00a17 	ldw	r3,40(sp)
81128178:	157fffc4 	addi	r21,r2,-1
8112817c:	1d41f316 	blt	r3,r21,8112894c <_dtoa_r+0x1188>
81128180:	1d6bc83a 	sub	r21,r3,r21
81128184:	d9c00617 	ldw	r7,24(sp)
81128188:	3802aa16 	blt	r7,zero,81128c34 <_dtoa_r+0x1470>
8112818c:	dd000817 	ldw	r20,32(sp)
81128190:	d8800617 	ldw	r2,24(sp)
81128194:	d8c00817 	ldw	r3,32(sp)
81128198:	01400044 	movi	r5,1
8112819c:	e009883a 	mov	r4,fp
811281a0:	1887883a 	add	r3,r3,r2
811281a4:	d8c00815 	stw	r3,32(sp)
811281a8:	b0ad883a 	add	r22,r22,r2
811281ac:	112ad000 	call	8112ad00 <__i2b>
811281b0:	1023883a 	mov	r17,r2
811281b4:	a0000826 	beq	r20,zero,811281d8 <_dtoa_r+0xa14>
811281b8:	0580070e 	bge	zero,r22,811281d8 <_dtoa_r+0xa14>
811281bc:	a005883a 	mov	r2,r20
811281c0:	b500b916 	blt	r22,r20,811284a8 <_dtoa_r+0xce4>
811281c4:	d9000817 	ldw	r4,32(sp)
811281c8:	a0a9c83a 	sub	r20,r20,r2
811281cc:	b0adc83a 	sub	r22,r22,r2
811281d0:	2089c83a 	sub	r4,r4,r2
811281d4:	d9000815 	stw	r4,32(sp)
811281d8:	d9800a17 	ldw	r6,40(sp)
811281dc:	0181810e 	bge	zero,r6,811287e4 <_dtoa_r+0x1020>
811281e0:	d9c00b17 	ldw	r7,44(sp)
811281e4:	3800b326 	beq	r7,zero,811284b4 <_dtoa_r+0xcf0>
811281e8:	a800b226 	beq	r21,zero,811284b4 <_dtoa_r+0xcf0>
811281ec:	880b883a 	mov	r5,r17
811281f0:	a80d883a 	mov	r6,r21
811281f4:	e009883a 	mov	r4,fp
811281f8:	112af440 	call	8112af44 <__pow5mult>
811281fc:	d9800917 	ldw	r6,36(sp)
81128200:	100b883a 	mov	r5,r2
81128204:	e009883a 	mov	r4,fp
81128208:	1023883a 	mov	r17,r2
8112820c:	112ad440 	call	8112ad44 <__multiply>
81128210:	1021883a 	mov	r16,r2
81128214:	d8800a17 	ldw	r2,40(sp)
81128218:	d9400917 	ldw	r5,36(sp)
8112821c:	e009883a 	mov	r4,fp
81128220:	1545c83a 	sub	r2,r2,r21
81128224:	d8800a15 	stw	r2,40(sp)
81128228:	112a98c0 	call	8112a98c <_Bfree>
8112822c:	d8c00a17 	ldw	r3,40(sp)
81128230:	18009f1e 	bne	r3,zero,811284b0 <_dtoa_r+0xcec>
81128234:	05c00044 	movi	r23,1
81128238:	e009883a 	mov	r4,fp
8112823c:	b80b883a 	mov	r5,r23
81128240:	112ad000 	call	8112ad00 <__i2b>
81128244:	d9000d17 	ldw	r4,52(sp)
81128248:	102b883a 	mov	r21,r2
8112824c:	2000ce26 	beq	r4,zero,81128588 <_dtoa_r+0xdc4>
81128250:	200d883a 	mov	r6,r4
81128254:	100b883a 	mov	r5,r2
81128258:	e009883a 	mov	r4,fp
8112825c:	112af440 	call	8112af44 <__pow5mult>
81128260:	d9800317 	ldw	r6,12(sp)
81128264:	102b883a 	mov	r21,r2
81128268:	b981810e 	bge	r23,r6,81128870 <_dtoa_r+0x10ac>
8112826c:	0027883a 	mov	r19,zero
81128270:	a8800417 	ldw	r2,16(r21)
81128274:	05c00804 	movi	r23,32
81128278:	10800104 	addi	r2,r2,4
8112827c:	1085883a 	add	r2,r2,r2
81128280:	1085883a 	add	r2,r2,r2
81128284:	a885883a 	add	r2,r21,r2
81128288:	11000017 	ldw	r4,0(r2)
8112828c:	112abe80 	call	8112abe8 <__hi0bits>
81128290:	b885c83a 	sub	r2,r23,r2
81128294:	1585883a 	add	r2,r2,r22
81128298:	108007cc 	andi	r2,r2,31
8112829c:	1000b326 	beq	r2,zero,8112856c <_dtoa_r+0xda8>
811282a0:	00c00804 	movi	r3,32
811282a4:	1887c83a 	sub	r3,r3,r2
811282a8:	01000104 	movi	r4,4
811282ac:	20c2cd0e 	bge	r4,r3,81128de4 <_dtoa_r+0x1620>
811282b0:	00c00704 	movi	r3,28
811282b4:	1885c83a 	sub	r2,r3,r2
811282b8:	d8c00817 	ldw	r3,32(sp)
811282bc:	a0a9883a 	add	r20,r20,r2
811282c0:	b0ad883a 	add	r22,r22,r2
811282c4:	1887883a 	add	r3,r3,r2
811282c8:	d8c00815 	stw	r3,32(sp)
811282cc:	d9800817 	ldw	r6,32(sp)
811282d0:	0180040e 	bge	zero,r6,811282e4 <_dtoa_r+0xb20>
811282d4:	800b883a 	mov	r5,r16
811282d8:	e009883a 	mov	r4,fp
811282dc:	112b08c0 	call	8112b08c <__lshift>
811282e0:	1021883a 	mov	r16,r2
811282e4:	0580050e 	bge	zero,r22,811282fc <_dtoa_r+0xb38>
811282e8:	a80b883a 	mov	r5,r21
811282ec:	b00d883a 	mov	r6,r22
811282f0:	e009883a 	mov	r4,fp
811282f4:	112b08c0 	call	8112b08c <__lshift>
811282f8:	102b883a 	mov	r21,r2
811282fc:	d9c00e17 	ldw	r7,56(sp)
81128300:	3801211e 	bne	r7,zero,81128788 <_dtoa_r+0xfc4>
81128304:	d9800617 	ldw	r6,24(sp)
81128308:	0181380e 	bge	zero,r6,811287ec <_dtoa_r+0x1028>
8112830c:	d8c00b17 	ldw	r3,44(sp)
81128310:	1800ab1e 	bne	r3,zero,811285c0 <_dtoa_r+0xdfc>
81128314:	dc800717 	ldw	r18,28(sp)
81128318:	dcc00617 	ldw	r19,24(sp)
8112831c:	9029883a 	mov	r20,r18
81128320:	00000206 	br	8112832c <_dtoa_r+0xb68>
81128324:	112a9b40 	call	8112a9b4 <__multadd>
81128328:	1021883a 	mov	r16,r2
8112832c:	a80b883a 	mov	r5,r21
81128330:	8009883a 	mov	r4,r16
81128334:	11275bc0 	call	811275bc <quorem>
81128338:	10800c04 	addi	r2,r2,48
8112833c:	90800005 	stb	r2,0(r18)
81128340:	94800044 	addi	r18,r18,1
81128344:	9507c83a 	sub	r3,r18,r20
81128348:	000f883a 	mov	r7,zero
8112834c:	01800284 	movi	r6,10
81128350:	800b883a 	mov	r5,r16
81128354:	e009883a 	mov	r4,fp
81128358:	1cfff216 	blt	r3,r19,81128324 <__reset+0xfb108324>
8112835c:	1011883a 	mov	r8,r2
81128360:	d8800617 	ldw	r2,24(sp)
81128364:	0082370e 	bge	zero,r2,81128c44 <_dtoa_r+0x1480>
81128368:	d9000717 	ldw	r4,28(sp)
8112836c:	0025883a 	mov	r18,zero
81128370:	20af883a 	add	r23,r4,r2
81128374:	01800044 	movi	r6,1
81128378:	800b883a 	mov	r5,r16
8112837c:	e009883a 	mov	r4,fp
81128380:	da001715 	stw	r8,92(sp)
81128384:	112b08c0 	call	8112b08c <__lshift>
81128388:	a80b883a 	mov	r5,r21
8112838c:	1009883a 	mov	r4,r2
81128390:	d8800915 	stw	r2,36(sp)
81128394:	112b1dc0 	call	8112b1dc <__mcmp>
81128398:	da001717 	ldw	r8,92(sp)
8112839c:	0081800e 	bge	zero,r2,811289a0 <_dtoa_r+0x11dc>
811283a0:	b93fffc3 	ldbu	r4,-1(r23)
811283a4:	b8bfffc4 	addi	r2,r23,-1
811283a8:	1007883a 	mov	r3,r2
811283ac:	01800e44 	movi	r6,57
811283b0:	d9c00717 	ldw	r7,28(sp)
811283b4:	00000506 	br	811283cc <_dtoa_r+0xc08>
811283b8:	18ffffc4 	addi	r3,r3,-1
811283bc:	11c12326 	beq	r2,r7,8112884c <_dtoa_r+0x1088>
811283c0:	19000003 	ldbu	r4,0(r3)
811283c4:	102f883a 	mov	r23,r2
811283c8:	10bfffc4 	addi	r2,r2,-1
811283cc:	21403fcc 	andi	r5,r4,255
811283d0:	2940201c 	xori	r5,r5,128
811283d4:	297fe004 	addi	r5,r5,-128
811283d8:	29bff726 	beq	r5,r6,811283b8 <__reset+0xfb1083b8>
811283dc:	21000044 	addi	r4,r4,1
811283e0:	11000005 	stb	r4,0(r2)
811283e4:	a80b883a 	mov	r5,r21
811283e8:	e009883a 	mov	r4,fp
811283ec:	112a98c0 	call	8112a98c <_Bfree>
811283f0:	883ea026 	beq	r17,zero,81127e74 <__reset+0xfb107e74>
811283f4:	90000426 	beq	r18,zero,81128408 <_dtoa_r+0xc44>
811283f8:	94400326 	beq	r18,r17,81128408 <_dtoa_r+0xc44>
811283fc:	900b883a 	mov	r5,r18
81128400:	e009883a 	mov	r4,fp
81128404:	112a98c0 	call	8112a98c <_Bfree>
81128408:	880b883a 	mov	r5,r17
8112840c:	e009883a 	mov	r4,fp
81128410:	112a98c0 	call	8112a98c <_Bfree>
81128414:	003e9706 	br	81127e74 <__reset+0xfb107e74>
81128418:	01800044 	movi	r6,1
8112841c:	d9800e15 	stw	r6,56(sp)
81128420:	003d9606 	br	81127a7c <__reset+0xfb107a7c>
81128424:	d8800817 	ldw	r2,32(sp)
81128428:	d8c00517 	ldw	r3,20(sp)
8112842c:	d8000d15 	stw	zero,52(sp)
81128430:	10c5c83a 	sub	r2,r2,r3
81128434:	00c9c83a 	sub	r4,zero,r3
81128438:	d8800815 	stw	r2,32(sp)
8112843c:	d9000a15 	stw	r4,40(sp)
81128440:	003d9706 	br	81127aa0 <__reset+0xfb107aa0>
81128444:	05adc83a 	sub	r22,zero,r22
81128448:	dd800815 	stw	r22,32(sp)
8112844c:	002d883a 	mov	r22,zero
81128450:	003d8e06 	br	81127a8c <__reset+0xfb107a8c>
81128454:	d9000517 	ldw	r4,20(sp)
81128458:	111f0980 	call	8111f098 <__floatsidf>
8112845c:	100d883a 	mov	r6,r2
81128460:	180f883a 	mov	r7,r3
81128464:	a009883a 	mov	r4,r20
81128468:	880b883a 	mov	r5,r17
8112846c:	11340740 	call	81134074 <__eqdf2>
81128470:	103d7126 	beq	r2,zero,81127a38 <__reset+0xfb107a38>
81128474:	d9c00517 	ldw	r7,20(sp)
81128478:	39ffffc4 	addi	r7,r7,-1
8112847c:	d9c00515 	stw	r7,20(sp)
81128480:	003d6d06 	br	81127a38 <__reset+0xfb107a38>
81128484:	dd400a17 	ldw	r21,40(sp)
81128488:	dd000817 	ldw	r20,32(sp)
8112848c:	0023883a 	mov	r17,zero
81128490:	003f4806 	br	811281b4 <__reset+0xfb1081b4>
81128494:	10e3c83a 	sub	r17,r2,r3
81128498:	9448983a 	sll	r4,r18,r17
8112849c:	003d3206 	br	81127968 <__reset+0xfb107968>
811284a0:	d8000e15 	stw	zero,56(sp)
811284a4:	003d7506 	br	81127a7c <__reset+0xfb107a7c>
811284a8:	b005883a 	mov	r2,r22
811284ac:	003f4506 	br	811281c4 <__reset+0xfb1081c4>
811284b0:	dc000915 	stw	r16,36(sp)
811284b4:	d9800a17 	ldw	r6,40(sp)
811284b8:	d9400917 	ldw	r5,36(sp)
811284bc:	e009883a 	mov	r4,fp
811284c0:	112af440 	call	8112af44 <__pow5mult>
811284c4:	1021883a 	mov	r16,r2
811284c8:	003f5a06 	br	81128234 <__reset+0xfb108234>
811284cc:	01c00044 	movi	r7,1
811284d0:	d9c00b15 	stw	r7,44(sp)
811284d4:	d8802217 	ldw	r2,136(sp)
811284d8:	0081280e 	bge	zero,r2,8112897c <_dtoa_r+0x11b8>
811284dc:	100d883a 	mov	r6,r2
811284e0:	1021883a 	mov	r16,r2
811284e4:	d8800c15 	stw	r2,48(sp)
811284e8:	d8800615 	stw	r2,24(sp)
811284ec:	003d8806 	br	81127b10 <__reset+0xfb107b10>
811284f0:	d8800617 	ldw	r2,24(sp)
811284f4:	00be9b16 	blt	zero,r2,81127f64 <__reset+0xfb107f64>
811284f8:	10010f1e 	bne	r2,zero,81128938 <_dtoa_r+0x1174>
811284fc:	880b883a 	mov	r5,r17
81128500:	000d883a 	mov	r6,zero
81128504:	01d00534 	movhi	r7,16404
81128508:	8009883a 	mov	r4,r16
8112850c:	111dff40 	call	8111dff4 <__muldf3>
81128510:	900d883a 	mov	r6,r18
81128514:	980f883a 	mov	r7,r19
81128518:	1009883a 	mov	r4,r2
8112851c:	180b883a 	mov	r5,r3
81128520:	111df180 	call	8111df18 <__gedf2>
81128524:	002b883a 	mov	r21,zero
81128528:	0023883a 	mov	r17,zero
8112852c:	1000bf16 	blt	r2,zero,8112882c <_dtoa_r+0x1068>
81128530:	d9802217 	ldw	r6,136(sp)
81128534:	ddc00717 	ldw	r23,28(sp)
81128538:	018c303a 	nor	r6,zero,r6
8112853c:	d9800515 	stw	r6,20(sp)
81128540:	a80b883a 	mov	r5,r21
81128544:	e009883a 	mov	r4,fp
81128548:	112a98c0 	call	8112a98c <_Bfree>
8112854c:	883e4926 	beq	r17,zero,81127e74 <__reset+0xfb107e74>
81128550:	003fad06 	br	81128408 <__reset+0xfb108408>
81128554:	d9c01117 	ldw	r7,68(sp)
81128558:	3801bc26 	beq	r7,zero,81128c4c <_dtoa_r+0x1488>
8112855c:	10810cc4 	addi	r2,r2,1075
81128560:	dd400a17 	ldw	r21,40(sp)
81128564:	dd000817 	ldw	r20,32(sp)
81128568:	003f0a06 	br	81128194 <__reset+0xfb108194>
8112856c:	00800704 	movi	r2,28
81128570:	d9000817 	ldw	r4,32(sp)
81128574:	a0a9883a 	add	r20,r20,r2
81128578:	b0ad883a 	add	r22,r22,r2
8112857c:	2089883a 	add	r4,r4,r2
81128580:	d9000815 	stw	r4,32(sp)
81128584:	003f5106 	br	811282cc <__reset+0xfb1082cc>
81128588:	d8c00317 	ldw	r3,12(sp)
8112858c:	b8c1fc0e 	bge	r23,r3,81128d80 <_dtoa_r+0x15bc>
81128590:	0027883a 	mov	r19,zero
81128594:	b805883a 	mov	r2,r23
81128598:	003f3e06 	br	81128294 <__reset+0xfb108294>
8112859c:	880b883a 	mov	r5,r17
811285a0:	e009883a 	mov	r4,fp
811285a4:	000f883a 	mov	r7,zero
811285a8:	01800284 	movi	r6,10
811285ac:	112a9b40 	call	8112a9b4 <__multadd>
811285b0:	d9000c17 	ldw	r4,48(sp)
811285b4:	1023883a 	mov	r17,r2
811285b8:	0102040e 	bge	zero,r4,81128dcc <_dtoa_r+0x1608>
811285bc:	d9000615 	stw	r4,24(sp)
811285c0:	0500050e 	bge	zero,r20,811285d8 <_dtoa_r+0xe14>
811285c4:	880b883a 	mov	r5,r17
811285c8:	a00d883a 	mov	r6,r20
811285cc:	e009883a 	mov	r4,fp
811285d0:	112b08c0 	call	8112b08c <__lshift>
811285d4:	1023883a 	mov	r17,r2
811285d8:	9801241e 	bne	r19,zero,81128a6c <_dtoa_r+0x12a8>
811285dc:	8829883a 	mov	r20,r17
811285e0:	d9000617 	ldw	r4,24(sp)
811285e4:	dcc00717 	ldw	r19,28(sp)
811285e8:	9480004c 	andi	r18,r18,1
811285ec:	20bfffc4 	addi	r2,r4,-1
811285f0:	9885883a 	add	r2,r19,r2
811285f4:	d8800415 	stw	r2,16(sp)
811285f8:	dc800615 	stw	r18,24(sp)
811285fc:	a80b883a 	mov	r5,r21
81128600:	8009883a 	mov	r4,r16
81128604:	11275bc0 	call	811275bc <quorem>
81128608:	880b883a 	mov	r5,r17
8112860c:	8009883a 	mov	r4,r16
81128610:	102f883a 	mov	r23,r2
81128614:	112b1dc0 	call	8112b1dc <__mcmp>
81128618:	a80b883a 	mov	r5,r21
8112861c:	a00d883a 	mov	r6,r20
81128620:	e009883a 	mov	r4,fp
81128624:	102d883a 	mov	r22,r2
81128628:	112b23c0 	call	8112b23c <__mdiff>
8112862c:	1007883a 	mov	r3,r2
81128630:	10800317 	ldw	r2,12(r2)
81128634:	bc800c04 	addi	r18,r23,48
81128638:	180b883a 	mov	r5,r3
8112863c:	10004e1e 	bne	r2,zero,81128778 <_dtoa_r+0xfb4>
81128640:	8009883a 	mov	r4,r16
81128644:	d8c01615 	stw	r3,88(sp)
81128648:	112b1dc0 	call	8112b1dc <__mcmp>
8112864c:	d8c01617 	ldw	r3,88(sp)
81128650:	e009883a 	mov	r4,fp
81128654:	d8801615 	stw	r2,88(sp)
81128658:	180b883a 	mov	r5,r3
8112865c:	112a98c0 	call	8112a98c <_Bfree>
81128660:	d8801617 	ldw	r2,88(sp)
81128664:	1000041e 	bne	r2,zero,81128678 <_dtoa_r+0xeb4>
81128668:	d9800317 	ldw	r6,12(sp)
8112866c:	3000021e 	bne	r6,zero,81128678 <_dtoa_r+0xeb4>
81128670:	d8c00617 	ldw	r3,24(sp)
81128674:	18003726 	beq	r3,zero,81128754 <_dtoa_r+0xf90>
81128678:	b0002016 	blt	r22,zero,811286fc <_dtoa_r+0xf38>
8112867c:	b000041e 	bne	r22,zero,81128690 <_dtoa_r+0xecc>
81128680:	d9000317 	ldw	r4,12(sp)
81128684:	2000021e 	bne	r4,zero,81128690 <_dtoa_r+0xecc>
81128688:	d8c00617 	ldw	r3,24(sp)
8112868c:	18001b26 	beq	r3,zero,811286fc <_dtoa_r+0xf38>
81128690:	00810716 	blt	zero,r2,81128ab0 <_dtoa_r+0x12ec>
81128694:	d8c00417 	ldw	r3,16(sp)
81128698:	9d800044 	addi	r22,r19,1
8112869c:	9c800005 	stb	r18,0(r19)
811286a0:	b02f883a 	mov	r23,r22
811286a4:	98c10626 	beq	r19,r3,81128ac0 <_dtoa_r+0x12fc>
811286a8:	800b883a 	mov	r5,r16
811286ac:	000f883a 	mov	r7,zero
811286b0:	01800284 	movi	r6,10
811286b4:	e009883a 	mov	r4,fp
811286b8:	112a9b40 	call	8112a9b4 <__multadd>
811286bc:	1021883a 	mov	r16,r2
811286c0:	000f883a 	mov	r7,zero
811286c4:	01800284 	movi	r6,10
811286c8:	880b883a 	mov	r5,r17
811286cc:	e009883a 	mov	r4,fp
811286d0:	8d002526 	beq	r17,r20,81128768 <_dtoa_r+0xfa4>
811286d4:	112a9b40 	call	8112a9b4 <__multadd>
811286d8:	a00b883a 	mov	r5,r20
811286dc:	000f883a 	mov	r7,zero
811286e0:	01800284 	movi	r6,10
811286e4:	e009883a 	mov	r4,fp
811286e8:	1023883a 	mov	r17,r2
811286ec:	112a9b40 	call	8112a9b4 <__multadd>
811286f0:	1029883a 	mov	r20,r2
811286f4:	b027883a 	mov	r19,r22
811286f8:	003fc006 	br	811285fc <__reset+0xfb1085fc>
811286fc:	9011883a 	mov	r8,r18
81128700:	00800e0e 	bge	zero,r2,8112873c <_dtoa_r+0xf78>
81128704:	800b883a 	mov	r5,r16
81128708:	01800044 	movi	r6,1
8112870c:	e009883a 	mov	r4,fp
81128710:	da001715 	stw	r8,92(sp)
81128714:	112b08c0 	call	8112b08c <__lshift>
81128718:	a80b883a 	mov	r5,r21
8112871c:	1009883a 	mov	r4,r2
81128720:	1021883a 	mov	r16,r2
81128724:	112b1dc0 	call	8112b1dc <__mcmp>
81128728:	da001717 	ldw	r8,92(sp)
8112872c:	0081960e 	bge	zero,r2,81128d88 <_dtoa_r+0x15c4>
81128730:	00800e44 	movi	r2,57
81128734:	40817026 	beq	r8,r2,81128cf8 <_dtoa_r+0x1534>
81128738:	ba000c44 	addi	r8,r23,49
8112873c:	8825883a 	mov	r18,r17
81128740:	9dc00044 	addi	r23,r19,1
81128744:	9a000005 	stb	r8,0(r19)
81128748:	a023883a 	mov	r17,r20
8112874c:	dc000915 	stw	r16,36(sp)
81128750:	003f2406 	br	811283e4 <__reset+0xfb1083e4>
81128754:	00800e44 	movi	r2,57
81128758:	9011883a 	mov	r8,r18
8112875c:	90816626 	beq	r18,r2,81128cf8 <_dtoa_r+0x1534>
81128760:	05bff516 	blt	zero,r22,81128738 <__reset+0xfb108738>
81128764:	003ff506 	br	8112873c <__reset+0xfb10873c>
81128768:	112a9b40 	call	8112a9b4 <__multadd>
8112876c:	1023883a 	mov	r17,r2
81128770:	1029883a 	mov	r20,r2
81128774:	003fdf06 	br	811286f4 <__reset+0xfb1086f4>
81128778:	e009883a 	mov	r4,fp
8112877c:	112a98c0 	call	8112a98c <_Bfree>
81128780:	00800044 	movi	r2,1
81128784:	003fbc06 	br	81128678 <__reset+0xfb108678>
81128788:	a80b883a 	mov	r5,r21
8112878c:	8009883a 	mov	r4,r16
81128790:	112b1dc0 	call	8112b1dc <__mcmp>
81128794:	103edb0e 	bge	r2,zero,81128304 <__reset+0xfb108304>
81128798:	800b883a 	mov	r5,r16
8112879c:	000f883a 	mov	r7,zero
811287a0:	01800284 	movi	r6,10
811287a4:	e009883a 	mov	r4,fp
811287a8:	112a9b40 	call	8112a9b4 <__multadd>
811287ac:	1021883a 	mov	r16,r2
811287b0:	d8800517 	ldw	r2,20(sp)
811287b4:	d8c00b17 	ldw	r3,44(sp)
811287b8:	10bfffc4 	addi	r2,r2,-1
811287bc:	d8800515 	stw	r2,20(sp)
811287c0:	183f761e 	bne	r3,zero,8112859c <__reset+0xfb10859c>
811287c4:	d9000c17 	ldw	r4,48(sp)
811287c8:	0101730e 	bge	zero,r4,81128d98 <_dtoa_r+0x15d4>
811287cc:	d9000615 	stw	r4,24(sp)
811287d0:	003ed006 	br	81128314 <__reset+0xfb108314>
811287d4:	00800084 	movi	r2,2
811287d8:	3081861e 	bne	r6,r2,81128df4 <_dtoa_r+0x1630>
811287dc:	d8000b15 	stw	zero,44(sp)
811287e0:	003f3c06 	br	811284d4 <__reset+0xfb1084d4>
811287e4:	dc000917 	ldw	r16,36(sp)
811287e8:	003e9206 	br	81128234 <__reset+0xfb108234>
811287ec:	d9c00317 	ldw	r7,12(sp)
811287f0:	00800084 	movi	r2,2
811287f4:	11fec50e 	bge	r2,r7,8112830c <__reset+0xfb10830c>
811287f8:	d9000617 	ldw	r4,24(sp)
811287fc:	20013c1e 	bne	r4,zero,81128cf0 <_dtoa_r+0x152c>
81128800:	a80b883a 	mov	r5,r21
81128804:	000f883a 	mov	r7,zero
81128808:	01800144 	movi	r6,5
8112880c:	e009883a 	mov	r4,fp
81128810:	112a9b40 	call	8112a9b4 <__multadd>
81128814:	100b883a 	mov	r5,r2
81128818:	8009883a 	mov	r4,r16
8112881c:	102b883a 	mov	r21,r2
81128820:	112b1dc0 	call	8112b1dc <__mcmp>
81128824:	dc000915 	stw	r16,36(sp)
81128828:	00bf410e 	bge	zero,r2,81128530 <__reset+0xfb108530>
8112882c:	d9c00717 	ldw	r7,28(sp)
81128830:	00800c44 	movi	r2,49
81128834:	38800005 	stb	r2,0(r7)
81128838:	d8800517 	ldw	r2,20(sp)
8112883c:	3dc00044 	addi	r23,r7,1
81128840:	10800044 	addi	r2,r2,1
81128844:	d8800515 	stw	r2,20(sp)
81128848:	003f3d06 	br	81128540 <__reset+0xfb108540>
8112884c:	d9800517 	ldw	r6,20(sp)
81128850:	d9c00717 	ldw	r7,28(sp)
81128854:	00800c44 	movi	r2,49
81128858:	31800044 	addi	r6,r6,1
8112885c:	d9800515 	stw	r6,20(sp)
81128860:	38800005 	stb	r2,0(r7)
81128864:	003edf06 	br	811283e4 <__reset+0xfb1083e4>
81128868:	d8000b15 	stw	zero,44(sp)
8112886c:	003c9f06 	br	81127aec <__reset+0xfb107aec>
81128870:	903e7e1e 	bne	r18,zero,8112826c <__reset+0xfb10826c>
81128874:	00800434 	movhi	r2,16
81128878:	10bfffc4 	addi	r2,r2,-1
8112887c:	9884703a 	and	r2,r19,r2
81128880:	1000ea1e 	bne	r2,zero,81128c2c <_dtoa_r+0x1468>
81128884:	9cdffc2c 	andhi	r19,r19,32752
81128888:	9800e826 	beq	r19,zero,81128c2c <_dtoa_r+0x1468>
8112888c:	d9c00817 	ldw	r7,32(sp)
81128890:	b5800044 	addi	r22,r22,1
81128894:	04c00044 	movi	r19,1
81128898:	39c00044 	addi	r7,r7,1
8112889c:	d9c00815 	stw	r7,32(sp)
811288a0:	d8800d17 	ldw	r2,52(sp)
811288a4:	103e721e 	bne	r2,zero,81128270 <__reset+0xfb108270>
811288a8:	00800044 	movi	r2,1
811288ac:	003e7906 	br	81128294 <__reset+0xfb108294>
811288b0:	8009883a 	mov	r4,r16
811288b4:	111f0980 	call	8111f098 <__floatsidf>
811288b8:	d9800f17 	ldw	r6,60(sp)
811288bc:	d9c01017 	ldw	r7,64(sp)
811288c0:	1009883a 	mov	r4,r2
811288c4:	180b883a 	mov	r5,r3
811288c8:	111dff40 	call	8111dff4 <__muldf3>
811288cc:	000d883a 	mov	r6,zero
811288d0:	01d00734 	movhi	r7,16412
811288d4:	1009883a 	mov	r4,r2
811288d8:	180b883a 	mov	r5,r3
811288dc:	1132ed00 	call	81132ed0 <__adddf3>
811288e0:	047f3034 	movhi	r17,64704
811288e4:	1021883a 	mov	r16,r2
811288e8:	1c63883a 	add	r17,r3,r17
811288ec:	d9000f17 	ldw	r4,60(sp)
811288f0:	d9401017 	ldw	r5,64(sp)
811288f4:	000d883a 	mov	r6,zero
811288f8:	01d00534 	movhi	r7,16404
811288fc:	111e7140 	call	8111e714 <__subdf3>
81128900:	800d883a 	mov	r6,r16
81128904:	880f883a 	mov	r7,r17
81128908:	1009883a 	mov	r4,r2
8112890c:	180b883a 	mov	r5,r3
81128910:	102b883a 	mov	r21,r2
81128914:	1829883a 	mov	r20,r3
81128918:	111df180 	call	8111df18 <__gedf2>
8112891c:	00806c16 	blt	zero,r2,81128ad0 <_dtoa_r+0x130c>
81128920:	89e0003c 	xorhi	r7,r17,32768
81128924:	800d883a 	mov	r6,r16
81128928:	a809883a 	mov	r4,r21
8112892c:	a00b883a 	mov	r5,r20
81128930:	11340fc0 	call	811340fc <__ledf2>
81128934:	103d7e0e 	bge	r2,zero,81127f30 <__reset+0xfb107f30>
81128938:	002b883a 	mov	r21,zero
8112893c:	0023883a 	mov	r17,zero
81128940:	003efb06 	br	81128530 <__reset+0xfb108530>
81128944:	d8800717 	ldw	r2,28(sp)
81128948:	003bd006 	br	8112788c <__reset+0xfb10788c>
8112894c:	d9000a17 	ldw	r4,40(sp)
81128950:	d9800d17 	ldw	r6,52(sp)
81128954:	dd400a15 	stw	r21,40(sp)
81128958:	a905c83a 	sub	r2,r21,r4
8112895c:	308d883a 	add	r6,r6,r2
81128960:	d9800d15 	stw	r6,52(sp)
81128964:	002b883a 	mov	r21,zero
81128968:	003e0606 	br	81128184 <__reset+0xfb108184>
8112896c:	9023883a 	mov	r17,r18
81128970:	9829883a 	mov	r20,r19
81128974:	04000084 	movi	r16,2
81128978:	003c9206 	br	81127bc4 <__reset+0xfb107bc4>
8112897c:	04000044 	movi	r16,1
81128980:	dc000c15 	stw	r16,48(sp)
81128984:	dc000615 	stw	r16,24(sp)
81128988:	dc002215 	stw	r16,136(sp)
8112898c:	e0001115 	stw	zero,68(fp)
81128990:	000b883a 	mov	r5,zero
81128994:	003c6906 	br	81127b3c <__reset+0xfb107b3c>
81128998:	3021883a 	mov	r16,r6
8112899c:	003ffb06 	br	8112898c <__reset+0xfb10898c>
811289a0:	1000021e 	bne	r2,zero,811289ac <_dtoa_r+0x11e8>
811289a4:	4200004c 	andi	r8,r8,1
811289a8:	403e7d1e 	bne	r8,zero,811283a0 <__reset+0xfb1083a0>
811289ac:	01000c04 	movi	r4,48
811289b0:	00000106 	br	811289b8 <_dtoa_r+0x11f4>
811289b4:	102f883a 	mov	r23,r2
811289b8:	b8bfffc4 	addi	r2,r23,-1
811289bc:	10c00007 	ldb	r3,0(r2)
811289c0:	193ffc26 	beq	r3,r4,811289b4 <__reset+0xfb1089b4>
811289c4:	003e8706 	br	811283e4 <__reset+0xfb1083e4>
811289c8:	d8800517 	ldw	r2,20(sp)
811289cc:	00a3c83a 	sub	r17,zero,r2
811289d0:	8800a426 	beq	r17,zero,81128c64 <_dtoa_r+0x14a0>
811289d4:	888003cc 	andi	r2,r17,15
811289d8:	100490fa 	slli	r2,r2,3
811289dc:	00e04574 	movhi	r3,33045
811289e0:	18f93704 	addi	r3,r3,-6948
811289e4:	1885883a 	add	r2,r3,r2
811289e8:	11800017 	ldw	r6,0(r2)
811289ec:	11c00117 	ldw	r7,4(r2)
811289f0:	9009883a 	mov	r4,r18
811289f4:	980b883a 	mov	r5,r19
811289f8:	8823d13a 	srai	r17,r17,4
811289fc:	111dff40 	call	8111dff4 <__muldf3>
81128a00:	d8800f15 	stw	r2,60(sp)
81128a04:	d8c01015 	stw	r3,64(sp)
81128a08:	8800e826 	beq	r17,zero,81128dac <_dtoa_r+0x15e8>
81128a0c:	05204574 	movhi	r20,33045
81128a10:	a5392d04 	addi	r20,r20,-6988
81128a14:	04000084 	movi	r16,2
81128a18:	8980004c 	andi	r6,r17,1
81128a1c:	1009883a 	mov	r4,r2
81128a20:	8823d07a 	srai	r17,r17,1
81128a24:	180b883a 	mov	r5,r3
81128a28:	30000426 	beq	r6,zero,81128a3c <_dtoa_r+0x1278>
81128a2c:	a1800017 	ldw	r6,0(r20)
81128a30:	a1c00117 	ldw	r7,4(r20)
81128a34:	84000044 	addi	r16,r16,1
81128a38:	111dff40 	call	8111dff4 <__muldf3>
81128a3c:	a5000204 	addi	r20,r20,8
81128a40:	883ff51e 	bne	r17,zero,81128a18 <__reset+0xfb108a18>
81128a44:	d8800f15 	stw	r2,60(sp)
81128a48:	d8c01015 	stw	r3,64(sp)
81128a4c:	003c7606 	br	81127c28 <__reset+0xfb107c28>
81128a50:	00c00c04 	movi	r3,48
81128a54:	10c00005 	stb	r3,0(r2)
81128a58:	d8c00517 	ldw	r3,20(sp)
81128a5c:	bd3fffc3 	ldbu	r20,-1(r23)
81128a60:	18c00044 	addi	r3,r3,1
81128a64:	d8c00515 	stw	r3,20(sp)
81128a68:	003db906 	br	81128150 <__reset+0xfb108150>
81128a6c:	89400117 	ldw	r5,4(r17)
81128a70:	e009883a 	mov	r4,fp
81128a74:	112a8dc0 	call	8112a8dc <_Balloc>
81128a78:	89800417 	ldw	r6,16(r17)
81128a7c:	89400304 	addi	r5,r17,12
81128a80:	11000304 	addi	r4,r2,12
81128a84:	31800084 	addi	r6,r6,2
81128a88:	318d883a 	add	r6,r6,r6
81128a8c:	318d883a 	add	r6,r6,r6
81128a90:	1027883a 	mov	r19,r2
81128a94:	11206ac0 	call	811206ac <memcpy>
81128a98:	01800044 	movi	r6,1
81128a9c:	980b883a 	mov	r5,r19
81128aa0:	e009883a 	mov	r4,fp
81128aa4:	112b08c0 	call	8112b08c <__lshift>
81128aa8:	1029883a 	mov	r20,r2
81128aac:	003ecc06 	br	811285e0 <__reset+0xfb1085e0>
81128ab0:	00800e44 	movi	r2,57
81128ab4:	90809026 	beq	r18,r2,81128cf8 <_dtoa_r+0x1534>
81128ab8:	92000044 	addi	r8,r18,1
81128abc:	003f1f06 	br	8112873c <__reset+0xfb10873c>
81128ac0:	9011883a 	mov	r8,r18
81128ac4:	8825883a 	mov	r18,r17
81128ac8:	a023883a 	mov	r17,r20
81128acc:	003e2906 	br	81128374 <__reset+0xfb108374>
81128ad0:	002b883a 	mov	r21,zero
81128ad4:	0023883a 	mov	r17,zero
81128ad8:	003f5406 	br	8112882c <__reset+0xfb10882c>
81128adc:	61bfffc4 	addi	r6,r12,-1
81128ae0:	300490fa 	slli	r2,r6,3
81128ae4:	00e04574 	movhi	r3,33045
81128ae8:	18f93704 	addi	r3,r3,-6948
81128aec:	1885883a 	add	r2,r3,r2
81128af0:	11000017 	ldw	r4,0(r2)
81128af4:	11400117 	ldw	r5,4(r2)
81128af8:	d8800717 	ldw	r2,28(sp)
81128afc:	880f883a 	mov	r7,r17
81128b00:	d9801215 	stw	r6,72(sp)
81128b04:	800d883a 	mov	r6,r16
81128b08:	db001615 	stw	r12,88(sp)
81128b0c:	15c00044 	addi	r23,r2,1
81128b10:	111dff40 	call	8111dff4 <__muldf3>
81128b14:	d9401017 	ldw	r5,64(sp)
81128b18:	d9000f17 	ldw	r4,60(sp)
81128b1c:	d8c01515 	stw	r3,84(sp)
81128b20:	d8801415 	stw	r2,80(sp)
81128b24:	111f0180 	call	8111f018 <__fixdfsi>
81128b28:	1009883a 	mov	r4,r2
81128b2c:	1021883a 	mov	r16,r2
81128b30:	111f0980 	call	8111f098 <__floatsidf>
81128b34:	d9000f17 	ldw	r4,60(sp)
81128b38:	d9401017 	ldw	r5,64(sp)
81128b3c:	100d883a 	mov	r6,r2
81128b40:	180f883a 	mov	r7,r3
81128b44:	111e7140 	call	8111e714 <__subdf3>
81128b48:	1829883a 	mov	r20,r3
81128b4c:	d8c00717 	ldw	r3,28(sp)
81128b50:	84000c04 	addi	r16,r16,48
81128b54:	1023883a 	mov	r17,r2
81128b58:	1c000005 	stb	r16,0(r3)
81128b5c:	db001617 	ldw	r12,88(sp)
81128b60:	00800044 	movi	r2,1
81128b64:	60802226 	beq	r12,r2,81128bf0 <_dtoa_r+0x142c>
81128b68:	d9c00717 	ldw	r7,28(sp)
81128b6c:	8805883a 	mov	r2,r17
81128b70:	b82b883a 	mov	r21,r23
81128b74:	3b19883a 	add	r12,r7,r12
81128b78:	6023883a 	mov	r17,r12
81128b7c:	a007883a 	mov	r3,r20
81128b80:	dc800f15 	stw	r18,60(sp)
81128b84:	000d883a 	mov	r6,zero
81128b88:	01d00934 	movhi	r7,16420
81128b8c:	1009883a 	mov	r4,r2
81128b90:	180b883a 	mov	r5,r3
81128b94:	111dff40 	call	8111dff4 <__muldf3>
81128b98:	180b883a 	mov	r5,r3
81128b9c:	1009883a 	mov	r4,r2
81128ba0:	1829883a 	mov	r20,r3
81128ba4:	1025883a 	mov	r18,r2
81128ba8:	111f0180 	call	8111f018 <__fixdfsi>
81128bac:	1009883a 	mov	r4,r2
81128bb0:	1021883a 	mov	r16,r2
81128bb4:	111f0980 	call	8111f098 <__floatsidf>
81128bb8:	100d883a 	mov	r6,r2
81128bbc:	180f883a 	mov	r7,r3
81128bc0:	9009883a 	mov	r4,r18
81128bc4:	a00b883a 	mov	r5,r20
81128bc8:	84000c04 	addi	r16,r16,48
81128bcc:	111e7140 	call	8111e714 <__subdf3>
81128bd0:	ad400044 	addi	r21,r21,1
81128bd4:	ac3fffc5 	stb	r16,-1(r21)
81128bd8:	ac7fea1e 	bne	r21,r17,81128b84 <__reset+0xfb108b84>
81128bdc:	1023883a 	mov	r17,r2
81128be0:	d8801217 	ldw	r2,72(sp)
81128be4:	dc800f17 	ldw	r18,60(sp)
81128be8:	1829883a 	mov	r20,r3
81128bec:	b8af883a 	add	r23,r23,r2
81128bf0:	d9001417 	ldw	r4,80(sp)
81128bf4:	d9401517 	ldw	r5,84(sp)
81128bf8:	000d883a 	mov	r6,zero
81128bfc:	01cff834 	movhi	r7,16352
81128c00:	1132ed00 	call	81132ed0 <__adddf3>
81128c04:	880d883a 	mov	r6,r17
81128c08:	a00f883a 	mov	r7,r20
81128c0c:	1009883a 	mov	r4,r2
81128c10:	180b883a 	mov	r5,r3
81128c14:	11340fc0 	call	811340fc <__ledf2>
81128c18:	10003e0e 	bge	r2,zero,81128d14 <_dtoa_r+0x1550>
81128c1c:	d9001317 	ldw	r4,76(sp)
81128c20:	bd3fffc3 	ldbu	r20,-1(r23)
81128c24:	d9000515 	stw	r4,20(sp)
81128c28:	003d3b06 	br	81128118 <__reset+0xfb108118>
81128c2c:	0027883a 	mov	r19,zero
81128c30:	003f1b06 	br	811288a0 <__reset+0xfb1088a0>
81128c34:	d8800817 	ldw	r2,32(sp)
81128c38:	11e9c83a 	sub	r20,r2,r7
81128c3c:	0005883a 	mov	r2,zero
81128c40:	003d5406 	br	81128194 <__reset+0xfb108194>
81128c44:	00800044 	movi	r2,1
81128c48:	003dc706 	br	81128368 <__reset+0xfb108368>
81128c4c:	d8c00217 	ldw	r3,8(sp)
81128c50:	00800d84 	movi	r2,54
81128c54:	dd400a17 	ldw	r21,40(sp)
81128c58:	10c5c83a 	sub	r2,r2,r3
81128c5c:	dd000817 	ldw	r20,32(sp)
81128c60:	003d4c06 	br	81128194 <__reset+0xfb108194>
81128c64:	dc800f15 	stw	r18,60(sp)
81128c68:	dcc01015 	stw	r19,64(sp)
81128c6c:	04000084 	movi	r16,2
81128c70:	003bed06 	br	81127c28 <__reset+0xfb107c28>
81128c74:	d9000617 	ldw	r4,24(sp)
81128c78:	203f0d26 	beq	r4,zero,811288b0 <__reset+0xfb1088b0>
81128c7c:	d9800c17 	ldw	r6,48(sp)
81128c80:	01bcab0e 	bge	zero,r6,81127f30 <__reset+0xfb107f30>
81128c84:	d9401017 	ldw	r5,64(sp)
81128c88:	d9000f17 	ldw	r4,60(sp)
81128c8c:	000d883a 	mov	r6,zero
81128c90:	01d00934 	movhi	r7,16420
81128c94:	111dff40 	call	8111dff4 <__muldf3>
81128c98:	81000044 	addi	r4,r16,1
81128c9c:	d8800f15 	stw	r2,60(sp)
81128ca0:	d8c01015 	stw	r3,64(sp)
81128ca4:	111f0980 	call	8111f098 <__floatsidf>
81128ca8:	d9800f17 	ldw	r6,60(sp)
81128cac:	d9c01017 	ldw	r7,64(sp)
81128cb0:	1009883a 	mov	r4,r2
81128cb4:	180b883a 	mov	r5,r3
81128cb8:	111dff40 	call	8111dff4 <__muldf3>
81128cbc:	01d00734 	movhi	r7,16412
81128cc0:	000d883a 	mov	r6,zero
81128cc4:	1009883a 	mov	r4,r2
81128cc8:	180b883a 	mov	r5,r3
81128ccc:	1132ed00 	call	81132ed0 <__adddf3>
81128cd0:	d9c00517 	ldw	r7,20(sp)
81128cd4:	047f3034 	movhi	r17,64704
81128cd8:	1021883a 	mov	r16,r2
81128cdc:	39ffffc4 	addi	r7,r7,-1
81128ce0:	d9c01315 	stw	r7,76(sp)
81128ce4:	1c63883a 	add	r17,r3,r17
81128ce8:	db000c17 	ldw	r12,48(sp)
81128cec:	003bea06 	br	81127c98 <__reset+0xfb107c98>
81128cf0:	dc000915 	stw	r16,36(sp)
81128cf4:	003e0e06 	br	81128530 <__reset+0xfb108530>
81128cf8:	01000e44 	movi	r4,57
81128cfc:	8825883a 	mov	r18,r17
81128d00:	9dc00044 	addi	r23,r19,1
81128d04:	99000005 	stb	r4,0(r19)
81128d08:	a023883a 	mov	r17,r20
81128d0c:	dc000915 	stw	r16,36(sp)
81128d10:	003da406 	br	811283a4 <__reset+0xfb1083a4>
81128d14:	d9801417 	ldw	r6,80(sp)
81128d18:	d9c01517 	ldw	r7,84(sp)
81128d1c:	0009883a 	mov	r4,zero
81128d20:	014ff834 	movhi	r5,16352
81128d24:	111e7140 	call	8111e714 <__subdf3>
81128d28:	880d883a 	mov	r6,r17
81128d2c:	a00f883a 	mov	r7,r20
81128d30:	1009883a 	mov	r4,r2
81128d34:	180b883a 	mov	r5,r3
81128d38:	111df180 	call	8111df18 <__gedf2>
81128d3c:	00bc7c0e 	bge	zero,r2,81127f30 <__reset+0xfb107f30>
81128d40:	01000c04 	movi	r4,48
81128d44:	00000106 	br	81128d4c <_dtoa_r+0x1588>
81128d48:	102f883a 	mov	r23,r2
81128d4c:	b8bfffc4 	addi	r2,r23,-1
81128d50:	10c00007 	ldb	r3,0(r2)
81128d54:	193ffc26 	beq	r3,r4,81128d48 <__reset+0xfb108d48>
81128d58:	d9801317 	ldw	r6,76(sp)
81128d5c:	d9800515 	stw	r6,20(sp)
81128d60:	003c4406 	br	81127e74 <__reset+0xfb107e74>
81128d64:	d9801317 	ldw	r6,76(sp)
81128d68:	d9800515 	stw	r6,20(sp)
81128d6c:	003cea06 	br	81128118 <__reset+0xfb108118>
81128d70:	dd800f17 	ldw	r22,60(sp)
81128d74:	dcc01017 	ldw	r19,64(sp)
81128d78:	dc801217 	ldw	r18,72(sp)
81128d7c:	003c6c06 	br	81127f30 <__reset+0xfb107f30>
81128d80:	903e031e 	bne	r18,zero,81128590 <__reset+0xfb108590>
81128d84:	003ebb06 	br	81128874 <__reset+0xfb108874>
81128d88:	103e6c1e 	bne	r2,zero,8112873c <__reset+0xfb10873c>
81128d8c:	4080004c 	andi	r2,r8,1
81128d90:	103e6a26 	beq	r2,zero,8112873c <__reset+0xfb10873c>
81128d94:	003e6606 	br	81128730 <__reset+0xfb108730>
81128d98:	d8c00317 	ldw	r3,12(sp)
81128d9c:	00800084 	movi	r2,2
81128da0:	10c02916 	blt	r2,r3,81128e48 <_dtoa_r+0x1684>
81128da4:	d9000c17 	ldw	r4,48(sp)
81128da8:	003e8806 	br	811287cc <__reset+0xfb1087cc>
81128dac:	04000084 	movi	r16,2
81128db0:	003b9d06 	br	81127c28 <__reset+0xfb107c28>
81128db4:	d9001317 	ldw	r4,76(sp)
81128db8:	d9000515 	stw	r4,20(sp)
81128dbc:	003cd606 	br	81128118 <__reset+0xfb108118>
81128dc0:	d8801317 	ldw	r2,76(sp)
81128dc4:	d8800515 	stw	r2,20(sp)
81128dc8:	003c2a06 	br	81127e74 <__reset+0xfb107e74>
81128dcc:	d9800317 	ldw	r6,12(sp)
81128dd0:	00800084 	movi	r2,2
81128dd4:	11801516 	blt	r2,r6,81128e2c <_dtoa_r+0x1668>
81128dd8:	d9c00c17 	ldw	r7,48(sp)
81128ddc:	d9c00615 	stw	r7,24(sp)
81128de0:	003df706 	br	811285c0 <__reset+0xfb1085c0>
81128de4:	193d3926 	beq	r3,r4,811282cc <__reset+0xfb1082cc>
81128de8:	00c00f04 	movi	r3,60
81128dec:	1885c83a 	sub	r2,r3,r2
81128df0:	003ddf06 	br	81128570 <__reset+0xfb108570>
81128df4:	e009883a 	mov	r4,fp
81128df8:	e0001115 	stw	zero,68(fp)
81128dfc:	000b883a 	mov	r5,zero
81128e00:	112a8dc0 	call	8112a8dc <_Balloc>
81128e04:	d8800715 	stw	r2,28(sp)
81128e08:	d8c00717 	ldw	r3,28(sp)
81128e0c:	00bfffc4 	movi	r2,-1
81128e10:	01000044 	movi	r4,1
81128e14:	d8800c15 	stw	r2,48(sp)
81128e18:	e0c01015 	stw	r3,64(fp)
81128e1c:	d9000b15 	stw	r4,44(sp)
81128e20:	d8800615 	stw	r2,24(sp)
81128e24:	d8002215 	stw	zero,136(sp)
81128e28:	003c4106 	br	81127f30 <__reset+0xfb107f30>
81128e2c:	d8c00c17 	ldw	r3,48(sp)
81128e30:	d8c00615 	stw	r3,24(sp)
81128e34:	003e7006 	br	811287f8 <__reset+0xfb1087f8>
81128e38:	04400044 	movi	r17,1
81128e3c:	003b2006 	br	81127ac0 <__reset+0xfb107ac0>
81128e40:	000b883a 	mov	r5,zero
81128e44:	003b3d06 	br	81127b3c <__reset+0xfb107b3c>
81128e48:	d8800c17 	ldw	r2,48(sp)
81128e4c:	d8800615 	stw	r2,24(sp)
81128e50:	003e6906 	br	811287f8 <__reset+0xfb1087f8>

81128e54 <__sflush_r>:
81128e54:	defffb04 	addi	sp,sp,-20
81128e58:	de00012e 	bgeu	sp,et,81128e60 <__sflush_r+0xc>
81128e5c:	003b68fa 	trap	3
81128e60:	2880030b 	ldhu	r2,12(r5)
81128e64:	dcc00315 	stw	r19,12(sp)
81128e68:	dc400115 	stw	r17,4(sp)
81128e6c:	dfc00415 	stw	ra,16(sp)
81128e70:	dc800215 	stw	r18,8(sp)
81128e74:	dc000015 	stw	r16,0(sp)
81128e78:	10c0020c 	andi	r3,r2,8
81128e7c:	2823883a 	mov	r17,r5
81128e80:	2027883a 	mov	r19,r4
81128e84:	1800311e 	bne	r3,zero,81128f4c <__sflush_r+0xf8>
81128e88:	28c00117 	ldw	r3,4(r5)
81128e8c:	10820014 	ori	r2,r2,2048
81128e90:	2880030d 	sth	r2,12(r5)
81128e94:	00c04b0e 	bge	zero,r3,81128fc4 <__sflush_r+0x170>
81128e98:	8a000a17 	ldw	r8,40(r17)
81128e9c:	40002326 	beq	r8,zero,81128f2c <__sflush_r+0xd8>
81128ea0:	9c000017 	ldw	r16,0(r19)
81128ea4:	10c4000c 	andi	r3,r2,4096
81128ea8:	98000015 	stw	zero,0(r19)
81128eac:	18004826 	beq	r3,zero,81128fd0 <__sflush_r+0x17c>
81128eb0:	89801417 	ldw	r6,80(r17)
81128eb4:	10c0010c 	andi	r3,r2,4
81128eb8:	18000626 	beq	r3,zero,81128ed4 <__sflush_r+0x80>
81128ebc:	88c00117 	ldw	r3,4(r17)
81128ec0:	88800c17 	ldw	r2,48(r17)
81128ec4:	30cdc83a 	sub	r6,r6,r3
81128ec8:	10000226 	beq	r2,zero,81128ed4 <__sflush_r+0x80>
81128ecc:	88800f17 	ldw	r2,60(r17)
81128ed0:	308dc83a 	sub	r6,r6,r2
81128ed4:	89400717 	ldw	r5,28(r17)
81128ed8:	000f883a 	mov	r7,zero
81128edc:	9809883a 	mov	r4,r19
81128ee0:	403ee83a 	callr	r8
81128ee4:	00ffffc4 	movi	r3,-1
81128ee8:	10c04426 	beq	r2,r3,81128ffc <__sflush_r+0x1a8>
81128eec:	88c0030b 	ldhu	r3,12(r17)
81128ef0:	89000417 	ldw	r4,16(r17)
81128ef4:	88000115 	stw	zero,4(r17)
81128ef8:	197dffcc 	andi	r5,r3,63487
81128efc:	8940030d 	sth	r5,12(r17)
81128f00:	89000015 	stw	r4,0(r17)
81128f04:	18c4000c 	andi	r3,r3,4096
81128f08:	18002c1e 	bne	r3,zero,81128fbc <__sflush_r+0x168>
81128f0c:	89400c17 	ldw	r5,48(r17)
81128f10:	9c000015 	stw	r16,0(r19)
81128f14:	28000526 	beq	r5,zero,81128f2c <__sflush_r+0xd8>
81128f18:	88801004 	addi	r2,r17,64
81128f1c:	28800226 	beq	r5,r2,81128f28 <__sflush_r+0xd4>
81128f20:	9809883a 	mov	r4,r19
81128f24:	112990c0 	call	8112990c <_free_r>
81128f28:	88000c15 	stw	zero,48(r17)
81128f2c:	0005883a 	mov	r2,zero
81128f30:	dfc00417 	ldw	ra,16(sp)
81128f34:	dcc00317 	ldw	r19,12(sp)
81128f38:	dc800217 	ldw	r18,8(sp)
81128f3c:	dc400117 	ldw	r17,4(sp)
81128f40:	dc000017 	ldw	r16,0(sp)
81128f44:	dec00504 	addi	sp,sp,20
81128f48:	f800283a 	ret
81128f4c:	2c800417 	ldw	r18,16(r5)
81128f50:	903ff626 	beq	r18,zero,81128f2c <__reset+0xfb108f2c>
81128f54:	2c000017 	ldw	r16,0(r5)
81128f58:	108000cc 	andi	r2,r2,3
81128f5c:	2c800015 	stw	r18,0(r5)
81128f60:	84a1c83a 	sub	r16,r16,r18
81128f64:	1000131e 	bne	r2,zero,81128fb4 <__sflush_r+0x160>
81128f68:	28800517 	ldw	r2,20(r5)
81128f6c:	88800215 	stw	r2,8(r17)
81128f70:	04000316 	blt	zero,r16,81128f80 <__sflush_r+0x12c>
81128f74:	003fed06 	br	81128f2c <__reset+0xfb108f2c>
81128f78:	90a5883a 	add	r18,r18,r2
81128f7c:	043feb0e 	bge	zero,r16,81128f2c <__reset+0xfb108f2c>
81128f80:	88800917 	ldw	r2,36(r17)
81128f84:	89400717 	ldw	r5,28(r17)
81128f88:	800f883a 	mov	r7,r16
81128f8c:	900d883a 	mov	r6,r18
81128f90:	9809883a 	mov	r4,r19
81128f94:	103ee83a 	callr	r2
81128f98:	80a1c83a 	sub	r16,r16,r2
81128f9c:	00bff616 	blt	zero,r2,81128f78 <__reset+0xfb108f78>
81128fa0:	88c0030b 	ldhu	r3,12(r17)
81128fa4:	00bfffc4 	movi	r2,-1
81128fa8:	18c01014 	ori	r3,r3,64
81128fac:	88c0030d 	sth	r3,12(r17)
81128fb0:	003fdf06 	br	81128f30 <__reset+0xfb108f30>
81128fb4:	0005883a 	mov	r2,zero
81128fb8:	003fec06 	br	81128f6c <__reset+0xfb108f6c>
81128fbc:	88801415 	stw	r2,80(r17)
81128fc0:	003fd206 	br	81128f0c <__reset+0xfb108f0c>
81128fc4:	28c00f17 	ldw	r3,60(r5)
81128fc8:	00ffb316 	blt	zero,r3,81128e98 <__reset+0xfb108e98>
81128fcc:	003fd706 	br	81128f2c <__reset+0xfb108f2c>
81128fd0:	89400717 	ldw	r5,28(r17)
81128fd4:	000d883a 	mov	r6,zero
81128fd8:	01c00044 	movi	r7,1
81128fdc:	9809883a 	mov	r4,r19
81128fe0:	403ee83a 	callr	r8
81128fe4:	100d883a 	mov	r6,r2
81128fe8:	00bfffc4 	movi	r2,-1
81128fec:	30801426 	beq	r6,r2,81129040 <__sflush_r+0x1ec>
81128ff0:	8880030b 	ldhu	r2,12(r17)
81128ff4:	8a000a17 	ldw	r8,40(r17)
81128ff8:	003fae06 	br	81128eb4 <__reset+0xfb108eb4>
81128ffc:	98c00017 	ldw	r3,0(r19)
81129000:	183fba26 	beq	r3,zero,81128eec <__reset+0xfb108eec>
81129004:	01000744 	movi	r4,29
81129008:	19000626 	beq	r3,r4,81129024 <__sflush_r+0x1d0>
8112900c:	01000584 	movi	r4,22
81129010:	19000426 	beq	r3,r4,81129024 <__sflush_r+0x1d0>
81129014:	88c0030b 	ldhu	r3,12(r17)
81129018:	18c01014 	ori	r3,r3,64
8112901c:	88c0030d 	sth	r3,12(r17)
81129020:	003fc306 	br	81128f30 <__reset+0xfb108f30>
81129024:	8880030b 	ldhu	r2,12(r17)
81129028:	88c00417 	ldw	r3,16(r17)
8112902c:	88000115 	stw	zero,4(r17)
81129030:	10bdffcc 	andi	r2,r2,63487
81129034:	8880030d 	sth	r2,12(r17)
81129038:	88c00015 	stw	r3,0(r17)
8112903c:	003fb306 	br	81128f0c <__reset+0xfb108f0c>
81129040:	98800017 	ldw	r2,0(r19)
81129044:	103fea26 	beq	r2,zero,81128ff0 <__reset+0xfb108ff0>
81129048:	00c00744 	movi	r3,29
8112904c:	10c00226 	beq	r2,r3,81129058 <__sflush_r+0x204>
81129050:	00c00584 	movi	r3,22
81129054:	10c0031e 	bne	r2,r3,81129064 <__sflush_r+0x210>
81129058:	9c000015 	stw	r16,0(r19)
8112905c:	0005883a 	mov	r2,zero
81129060:	003fb306 	br	81128f30 <__reset+0xfb108f30>
81129064:	88c0030b 	ldhu	r3,12(r17)
81129068:	3005883a 	mov	r2,r6
8112906c:	18c01014 	ori	r3,r3,64
81129070:	88c0030d 	sth	r3,12(r17)
81129074:	003fae06 	br	81128f30 <__reset+0xfb108f30>

81129078 <_fflush_r>:
81129078:	defffd04 	addi	sp,sp,-12
8112907c:	de00012e 	bgeu	sp,et,81129084 <_fflush_r+0xc>
81129080:	003b68fa 	trap	3
81129084:	dc000115 	stw	r16,4(sp)
81129088:	dfc00215 	stw	ra,8(sp)
8112908c:	2021883a 	mov	r16,r4
81129090:	20000226 	beq	r4,zero,8112909c <_fflush_r+0x24>
81129094:	20800e17 	ldw	r2,56(r4)
81129098:	10000c26 	beq	r2,zero,811290cc <_fflush_r+0x54>
8112909c:	2880030f 	ldh	r2,12(r5)
811290a0:	1000051e 	bne	r2,zero,811290b8 <_fflush_r+0x40>
811290a4:	0005883a 	mov	r2,zero
811290a8:	dfc00217 	ldw	ra,8(sp)
811290ac:	dc000117 	ldw	r16,4(sp)
811290b0:	dec00304 	addi	sp,sp,12
811290b4:	f800283a 	ret
811290b8:	8009883a 	mov	r4,r16
811290bc:	dfc00217 	ldw	ra,8(sp)
811290c0:	dc000117 	ldw	r16,4(sp)
811290c4:	dec00304 	addi	sp,sp,12
811290c8:	1128e541 	jmpi	81128e54 <__sflush_r>
811290cc:	d9400015 	stw	r5,0(sp)
811290d0:	11294740 	call	81129474 <__sinit>
811290d4:	d9400017 	ldw	r5,0(sp)
811290d8:	003ff006 	br	8112909c <__reset+0xfb10909c>

811290dc <fflush>:
811290dc:	20000526 	beq	r4,zero,811290f4 <fflush+0x18>
811290e0:	00a04574 	movhi	r2,33045
811290e4:	1082c604 	addi	r2,r2,2840
811290e8:	200b883a 	mov	r5,r4
811290ec:	11000017 	ldw	r4,0(r2)
811290f0:	11290781 	jmpi	81129078 <_fflush_r>
811290f4:	00a04574 	movhi	r2,33045
811290f8:	1082c504 	addi	r2,r2,2836
811290fc:	11000017 	ldw	r4,0(r2)
81129100:	016044f4 	movhi	r5,33043
81129104:	29641e04 	addi	r5,r5,-28552
81129108:	112a1b41 	jmpi	8112a1b4 <_fwalk_reent>

8112910c <__fp_unlock>:
8112910c:	0005883a 	mov	r2,zero
81129110:	f800283a 	ret

81129114 <_cleanup_r>:
81129114:	016044f4 	movhi	r5,33043
81129118:	2943b404 	addi	r5,r5,3792
8112911c:	112a1b41 	jmpi	8112a1b4 <_fwalk_reent>

81129120 <__sinit.part.1>:
81129120:	defff704 	addi	sp,sp,-36
81129124:	00e044f4 	movhi	r3,33043
81129128:	de00012e 	bgeu	sp,et,81129130 <__sinit.part.1+0x10>
8112912c:	003b68fa 	trap	3
81129130:	18e44504 	addi	r3,r3,-28396
81129134:	dfc00815 	stw	ra,32(sp)
81129138:	ddc00715 	stw	r23,28(sp)
8112913c:	dd800615 	stw	r22,24(sp)
81129140:	dd400515 	stw	r21,20(sp)
81129144:	dd000415 	stw	r20,16(sp)
81129148:	dcc00315 	stw	r19,12(sp)
8112914c:	dc800215 	stw	r18,8(sp)
81129150:	dc400115 	stw	r17,4(sp)
81129154:	dc000015 	stw	r16,0(sp)
81129158:	24000117 	ldw	r16,4(r4)
8112915c:	20c00f15 	stw	r3,60(r4)
81129160:	2080bb04 	addi	r2,r4,748
81129164:	00c000c4 	movi	r3,3
81129168:	20c0b915 	stw	r3,740(r4)
8112916c:	2080ba15 	stw	r2,744(r4)
81129170:	2000b815 	stw	zero,736(r4)
81129174:	05c00204 	movi	r23,8
81129178:	00800104 	movi	r2,4
8112917c:	2025883a 	mov	r18,r4
81129180:	b80d883a 	mov	r6,r23
81129184:	81001704 	addi	r4,r16,92
81129188:	000b883a 	mov	r5,zero
8112918c:	80000015 	stw	zero,0(r16)
81129190:	80000115 	stw	zero,4(r16)
81129194:	80000215 	stw	zero,8(r16)
81129198:	8080030d 	sth	r2,12(r16)
8112919c:	80001915 	stw	zero,100(r16)
811291a0:	8000038d 	sth	zero,14(r16)
811291a4:	80000415 	stw	zero,16(r16)
811291a8:	80000515 	stw	zero,20(r16)
811291ac:	80000615 	stw	zero,24(r16)
811291b0:	11207fc0 	call	811207fc <memset>
811291b4:	05a044b4 	movhi	r22,33042
811291b8:	94400217 	ldw	r17,8(r18)
811291bc:	056044b4 	movhi	r21,33042
811291c0:	052044b4 	movhi	r20,33042
811291c4:	04e044b4 	movhi	r19,33042
811291c8:	b5840004 	addi	r22,r22,4096
811291cc:	ad441904 	addi	r21,r21,4196
811291d0:	a5043a04 	addi	r20,r20,4328
811291d4:	9cc45304 	addi	r19,r19,4428
811291d8:	85800815 	stw	r22,32(r16)
811291dc:	85400915 	stw	r21,36(r16)
811291e0:	85000a15 	stw	r20,40(r16)
811291e4:	84c00b15 	stw	r19,44(r16)
811291e8:	84000715 	stw	r16,28(r16)
811291ec:	00800284 	movi	r2,10
811291f0:	8880030d 	sth	r2,12(r17)
811291f4:	00800044 	movi	r2,1
811291f8:	b80d883a 	mov	r6,r23
811291fc:	89001704 	addi	r4,r17,92
81129200:	000b883a 	mov	r5,zero
81129204:	88000015 	stw	zero,0(r17)
81129208:	88000115 	stw	zero,4(r17)
8112920c:	88000215 	stw	zero,8(r17)
81129210:	88001915 	stw	zero,100(r17)
81129214:	8880038d 	sth	r2,14(r17)
81129218:	88000415 	stw	zero,16(r17)
8112921c:	88000515 	stw	zero,20(r17)
81129220:	88000615 	stw	zero,24(r17)
81129224:	11207fc0 	call	811207fc <memset>
81129228:	94000317 	ldw	r16,12(r18)
8112922c:	00800484 	movi	r2,18
81129230:	8c400715 	stw	r17,28(r17)
81129234:	8d800815 	stw	r22,32(r17)
81129238:	8d400915 	stw	r21,36(r17)
8112923c:	8d000a15 	stw	r20,40(r17)
81129240:	8cc00b15 	stw	r19,44(r17)
81129244:	8080030d 	sth	r2,12(r16)
81129248:	00800084 	movi	r2,2
8112924c:	80000015 	stw	zero,0(r16)
81129250:	80000115 	stw	zero,4(r16)
81129254:	80000215 	stw	zero,8(r16)
81129258:	80001915 	stw	zero,100(r16)
8112925c:	8080038d 	sth	r2,14(r16)
81129260:	80000415 	stw	zero,16(r16)
81129264:	80000515 	stw	zero,20(r16)
81129268:	80000615 	stw	zero,24(r16)
8112926c:	b80d883a 	mov	r6,r23
81129270:	000b883a 	mov	r5,zero
81129274:	81001704 	addi	r4,r16,92
81129278:	11207fc0 	call	811207fc <memset>
8112927c:	00800044 	movi	r2,1
81129280:	84000715 	stw	r16,28(r16)
81129284:	85800815 	stw	r22,32(r16)
81129288:	85400915 	stw	r21,36(r16)
8112928c:	85000a15 	stw	r20,40(r16)
81129290:	84c00b15 	stw	r19,44(r16)
81129294:	90800e15 	stw	r2,56(r18)
81129298:	dfc00817 	ldw	ra,32(sp)
8112929c:	ddc00717 	ldw	r23,28(sp)
811292a0:	dd800617 	ldw	r22,24(sp)
811292a4:	dd400517 	ldw	r21,20(sp)
811292a8:	dd000417 	ldw	r20,16(sp)
811292ac:	dcc00317 	ldw	r19,12(sp)
811292b0:	dc800217 	ldw	r18,8(sp)
811292b4:	dc400117 	ldw	r17,4(sp)
811292b8:	dc000017 	ldw	r16,0(sp)
811292bc:	dec00904 	addi	sp,sp,36
811292c0:	f800283a 	ret

811292c4 <__fp_lock>:
811292c4:	0005883a 	mov	r2,zero
811292c8:	f800283a 	ret

811292cc <__sfmoreglue>:
811292cc:	defffc04 	addi	sp,sp,-16
811292d0:	de00012e 	bgeu	sp,et,811292d8 <__sfmoreglue+0xc>
811292d4:	003b68fa 	trap	3
811292d8:	dc400115 	stw	r17,4(sp)
811292dc:	2c7fffc4 	addi	r17,r5,-1
811292e0:	8c401a24 	muli	r17,r17,104
811292e4:	dc800215 	stw	r18,8(sp)
811292e8:	2825883a 	mov	r18,r5
811292ec:	89401d04 	addi	r5,r17,116
811292f0:	dc000015 	stw	r16,0(sp)
811292f4:	dfc00315 	stw	ra,12(sp)
811292f8:	111fe980 	call	8111fe98 <_malloc_r>
811292fc:	1021883a 	mov	r16,r2
81129300:	10000726 	beq	r2,zero,81129320 <__sfmoreglue+0x54>
81129304:	11000304 	addi	r4,r2,12
81129308:	10000015 	stw	zero,0(r2)
8112930c:	14800115 	stw	r18,4(r2)
81129310:	11000215 	stw	r4,8(r2)
81129314:	89801a04 	addi	r6,r17,104
81129318:	000b883a 	mov	r5,zero
8112931c:	11207fc0 	call	811207fc <memset>
81129320:	8005883a 	mov	r2,r16
81129324:	dfc00317 	ldw	ra,12(sp)
81129328:	dc800217 	ldw	r18,8(sp)
8112932c:	dc400117 	ldw	r17,4(sp)
81129330:	dc000017 	ldw	r16,0(sp)
81129334:	dec00404 	addi	sp,sp,16
81129338:	f800283a 	ret

8112933c <__sfp>:
8112933c:	defffb04 	addi	sp,sp,-20
81129340:	de00012e 	bgeu	sp,et,81129348 <__sfp+0xc>
81129344:	003b68fa 	trap	3
81129348:	dc000015 	stw	r16,0(sp)
8112934c:	04204574 	movhi	r16,33045
81129350:	8402c504 	addi	r16,r16,2836
81129354:	dcc00315 	stw	r19,12(sp)
81129358:	2027883a 	mov	r19,r4
8112935c:	81000017 	ldw	r4,0(r16)
81129360:	dfc00415 	stw	ra,16(sp)
81129364:	dc800215 	stw	r18,8(sp)
81129368:	20800e17 	ldw	r2,56(r4)
8112936c:	dc400115 	stw	r17,4(sp)
81129370:	1000021e 	bne	r2,zero,8112937c <__sfp+0x40>
81129374:	11291200 	call	81129120 <__sinit.part.1>
81129378:	81000017 	ldw	r4,0(r16)
8112937c:	2480b804 	addi	r18,r4,736
81129380:	047fffc4 	movi	r17,-1
81129384:	91000117 	ldw	r4,4(r18)
81129388:	94000217 	ldw	r16,8(r18)
8112938c:	213fffc4 	addi	r4,r4,-1
81129390:	20000a16 	blt	r4,zero,811293bc <__sfp+0x80>
81129394:	8080030f 	ldh	r2,12(r16)
81129398:	10000c26 	beq	r2,zero,811293cc <__sfp+0x90>
8112939c:	80c01d04 	addi	r3,r16,116
811293a0:	00000206 	br	811293ac <__sfp+0x70>
811293a4:	18bfe60f 	ldh	r2,-104(r3)
811293a8:	10000826 	beq	r2,zero,811293cc <__sfp+0x90>
811293ac:	213fffc4 	addi	r4,r4,-1
811293b0:	1c3ffd04 	addi	r16,r3,-12
811293b4:	18c01a04 	addi	r3,r3,104
811293b8:	247ffa1e 	bne	r4,r17,811293a4 <__reset+0xfb1093a4>
811293bc:	90800017 	ldw	r2,0(r18)
811293c0:	10001d26 	beq	r2,zero,81129438 <__sfp+0xfc>
811293c4:	1025883a 	mov	r18,r2
811293c8:	003fee06 	br	81129384 <__reset+0xfb109384>
811293cc:	00bfffc4 	movi	r2,-1
811293d0:	8080038d 	sth	r2,14(r16)
811293d4:	00800044 	movi	r2,1
811293d8:	8080030d 	sth	r2,12(r16)
811293dc:	80001915 	stw	zero,100(r16)
811293e0:	80000015 	stw	zero,0(r16)
811293e4:	80000215 	stw	zero,8(r16)
811293e8:	80000115 	stw	zero,4(r16)
811293ec:	80000415 	stw	zero,16(r16)
811293f0:	80000515 	stw	zero,20(r16)
811293f4:	80000615 	stw	zero,24(r16)
811293f8:	01800204 	movi	r6,8
811293fc:	000b883a 	mov	r5,zero
81129400:	81001704 	addi	r4,r16,92
81129404:	11207fc0 	call	811207fc <memset>
81129408:	8005883a 	mov	r2,r16
8112940c:	80000c15 	stw	zero,48(r16)
81129410:	80000d15 	stw	zero,52(r16)
81129414:	80001115 	stw	zero,68(r16)
81129418:	80001215 	stw	zero,72(r16)
8112941c:	dfc00417 	ldw	ra,16(sp)
81129420:	dcc00317 	ldw	r19,12(sp)
81129424:	dc800217 	ldw	r18,8(sp)
81129428:	dc400117 	ldw	r17,4(sp)
8112942c:	dc000017 	ldw	r16,0(sp)
81129430:	dec00504 	addi	sp,sp,20
81129434:	f800283a 	ret
81129438:	01400104 	movi	r5,4
8112943c:	9809883a 	mov	r4,r19
81129440:	11292cc0 	call	811292cc <__sfmoreglue>
81129444:	90800015 	stw	r2,0(r18)
81129448:	103fde1e 	bne	r2,zero,811293c4 <__reset+0xfb1093c4>
8112944c:	00800304 	movi	r2,12
81129450:	98800015 	stw	r2,0(r19)
81129454:	0005883a 	mov	r2,zero
81129458:	003ff006 	br	8112941c <__reset+0xfb10941c>

8112945c <_cleanup>:
8112945c:	00a04574 	movhi	r2,33045
81129460:	1082c504 	addi	r2,r2,2836
81129464:	11000017 	ldw	r4,0(r2)
81129468:	016044f4 	movhi	r5,33043
8112946c:	2943b404 	addi	r5,r5,3792
81129470:	112a1b41 	jmpi	8112a1b4 <_fwalk_reent>

81129474 <__sinit>:
81129474:	20800e17 	ldw	r2,56(r4)
81129478:	10000126 	beq	r2,zero,81129480 <__sinit+0xc>
8112947c:	f800283a 	ret
81129480:	11291201 	jmpi	81129120 <__sinit.part.1>

81129484 <__sfp_lock_acquire>:
81129484:	f800283a 	ret

81129488 <__sfp_lock_release>:
81129488:	f800283a 	ret

8112948c <__sinit_lock_acquire>:
8112948c:	f800283a 	ret

81129490 <__sinit_lock_release>:
81129490:	f800283a 	ret

81129494 <__fp_lock_all>:
81129494:	00a04574 	movhi	r2,33045
81129498:	1082c604 	addi	r2,r2,2840
8112949c:	11000017 	ldw	r4,0(r2)
811294a0:	016044f4 	movhi	r5,33043
811294a4:	2964b104 	addi	r5,r5,-27964
811294a8:	112a0e81 	jmpi	8112a0e8 <_fwalk>

811294ac <__fp_unlock_all>:
811294ac:	00a04574 	movhi	r2,33045
811294b0:	1082c604 	addi	r2,r2,2840
811294b4:	11000017 	ldw	r4,0(r2)
811294b8:	016044f4 	movhi	r5,33043
811294bc:	29644304 	addi	r5,r5,-28404
811294c0:	112a0e81 	jmpi	8112a0e8 <_fwalk>

811294c4 <__sflags>:
811294c4:	28800007 	ldb	r2,0(r5)
811294c8:	00c01c84 	movi	r3,114
811294cc:	10c02426 	beq	r2,r3,81129560 <__sflags+0x9c>
811294d0:	00c01dc4 	movi	r3,119
811294d4:	10c01e26 	beq	r2,r3,81129550 <__sflags+0x8c>
811294d8:	00c01844 	movi	r3,97
811294dc:	10c00426 	beq	r2,r3,811294f0 <__sflags+0x2c>
811294e0:	00800584 	movi	r2,22
811294e4:	20800015 	stw	r2,0(r4)
811294e8:	0005883a 	mov	r2,zero
811294ec:	f800283a 	ret
811294f0:	02c08204 	movi	r11,520
811294f4:	01000044 	movi	r4,1
811294f8:	00804204 	movi	r2,264
811294fc:	01c00ac4 	movi	r7,43
81129500:	02bff8c4 	movi	r10,-29
81129504:	027fff04 	movi	r9,-4
81129508:	02001e04 	movi	r8,120
8112950c:	29400044 	addi	r5,r5,1
81129510:	28c00007 	ldb	r3,0(r5)
81129514:	18000626 	beq	r3,zero,81129530 <__sflags+0x6c>
81129518:	19c00826 	beq	r3,r7,8112953c <__sflags+0x78>
8112951c:	1a3ffb1e 	bne	r3,r8,8112950c <__reset+0xfb10950c>
81129520:	29400044 	addi	r5,r5,1
81129524:	28c00007 	ldb	r3,0(r5)
81129528:	21020014 	ori	r4,r4,2048
8112952c:	183ffa1e 	bne	r3,zero,81129518 <__reset+0xfb109518>
81129530:	22c8b03a 	or	r4,r4,r11
81129534:	31000015 	stw	r4,0(r6)
81129538:	f800283a 	ret
8112953c:	1284703a 	and	r2,r2,r10
81129540:	2248703a 	and	r4,r4,r9
81129544:	10800414 	ori	r2,r2,16
81129548:	21000094 	ori	r4,r4,2
8112954c:	003fef06 	br	8112950c <__reset+0xfb10950c>
81129550:	02c18004 	movi	r11,1536
81129554:	01000044 	movi	r4,1
81129558:	00800204 	movi	r2,8
8112955c:	003fe706 	br	811294fc <__reset+0xfb1094fc>
81129560:	0017883a 	mov	r11,zero
81129564:	0009883a 	mov	r4,zero
81129568:	00800104 	movi	r2,4
8112956c:	003fe306 	br	811294fc <__reset+0xfb1094fc>

81129570 <_fread_r>:
81129570:	defff404 	addi	sp,sp,-48
81129574:	de00012e 	bgeu	sp,et,8112957c <_fread_r+0xc>
81129578:	003b68fa 	trap	3
8112957c:	dd800815 	stw	r22,32(sp)
81129580:	39ad383a 	mul	r22,r7,r6
81129584:	dc000215 	stw	r16,8(sp)
81129588:	dfc00b15 	stw	ra,44(sp)
8112958c:	df000a15 	stw	fp,40(sp)
81129590:	ddc00915 	stw	r23,36(sp)
81129594:	dd400715 	stw	r21,28(sp)
81129598:	dd000615 	stw	r20,24(sp)
8112959c:	dcc00515 	stw	r19,20(sp)
811295a0:	dc800415 	stw	r18,16(sp)
811295a4:	dc400315 	stw	r17,12(sp)
811295a8:	dc000c17 	ldw	r16,48(sp)
811295ac:	b0003b26 	beq	r22,zero,8112969c <_fread_r+0x12c>
811295b0:	302f883a 	mov	r23,r6
811295b4:	382b883a 	mov	r21,r7
811295b8:	2029883a 	mov	r20,r4
811295bc:	2827883a 	mov	r19,r5
811295c0:	20000226 	beq	r4,zero,811295cc <_fread_r+0x5c>
811295c4:	20800e17 	ldw	r2,56(r4)
811295c8:	10006e26 	beq	r2,zero,81129784 <_fread_r+0x214>
811295cc:	8080030b 	ldhu	r2,12(r16)
811295d0:	10c8000c 	andi	r3,r2,8192
811295d4:	1800061e 	bne	r3,zero,811295f0 <_fread_r+0x80>
811295d8:	81001917 	ldw	r4,100(r16)
811295dc:	00f7ffc4 	movi	r3,-8193
811295e0:	10880014 	ori	r2,r2,8192
811295e4:	20c6703a 	and	r3,r4,r3
811295e8:	8080030d 	sth	r2,12(r16)
811295ec:	80c01915 	stw	r3,100(r16)
811295f0:	84400117 	ldw	r17,4(r16)
811295f4:	88005f16 	blt	r17,zero,81129774 <_fread_r+0x204>
811295f8:	8809883a 	mov	r4,r17
811295fc:	1080008c 	andi	r2,r2,2
81129600:	1000281e 	bne	r2,zero,811296a4 <_fread_r+0x134>
81129604:	b025883a 	mov	r18,r22
81129608:	00000b06 	br	81129638 <_fread_r+0xc8>
8112960c:	11206ac0 	call	811206ac <memcpy>
81129610:	80800017 	ldw	r2,0(r16)
81129614:	9c67883a 	add	r19,r19,r17
81129618:	9465c83a 	sub	r18,r18,r17
8112961c:	1463883a 	add	r17,r2,r17
81129620:	800b883a 	mov	r5,r16
81129624:	a009883a 	mov	r4,r20
81129628:	84400015 	stw	r17,0(r16)
8112962c:	1120c780 	call	81120c78 <__srefill_r>
81129630:	10004c1e 	bne	r2,zero,81129764 <_fread_r+0x1f4>
81129634:	84400117 	ldw	r17,4(r16)
81129638:	880d883a 	mov	r6,r17
8112963c:	9809883a 	mov	r4,r19
81129640:	81400017 	ldw	r5,0(r16)
81129644:	8cbff136 	bltu	r17,r18,8112960c <__reset+0xfb10960c>
81129648:	900d883a 	mov	r6,r18
8112964c:	11206ac0 	call	811206ac <memcpy>
81129650:	80c00117 	ldw	r3,4(r16)
81129654:	81000017 	ldw	r4,0(r16)
81129658:	a805883a 	mov	r2,r21
8112965c:	1c87c83a 	sub	r3,r3,r18
81129660:	24a5883a 	add	r18,r4,r18
81129664:	80c00115 	stw	r3,4(r16)
81129668:	84800015 	stw	r18,0(r16)
8112966c:	dfc00b17 	ldw	ra,44(sp)
81129670:	df000a17 	ldw	fp,40(sp)
81129674:	ddc00917 	ldw	r23,36(sp)
81129678:	dd800817 	ldw	r22,32(sp)
8112967c:	dd400717 	ldw	r21,28(sp)
81129680:	dd000617 	ldw	r20,24(sp)
81129684:	dcc00517 	ldw	r19,20(sp)
81129688:	dc800417 	ldw	r18,16(sp)
8112968c:	dc400317 	ldw	r17,12(sp)
81129690:	dc000217 	ldw	r16,8(sp)
81129694:	dec00c04 	addi	sp,sp,48
81129698:	f800283a 	ret
8112969c:	0005883a 	mov	r2,zero
811296a0:	003ff206 	br	8112966c <__reset+0xfb10966c>
811296a4:	b007883a 	mov	r3,r22
811296a8:	2580012e 	bgeu	r4,r22,811296b0 <_fread_r+0x140>
811296ac:	2007883a 	mov	r3,r4
811296b0:	81400017 	ldw	r5,0(r16)
811296b4:	180d883a 	mov	r6,r3
811296b8:	9809883a 	mov	r4,r19
811296bc:	d8c00115 	stw	r3,4(sp)
811296c0:	11206ac0 	call	811206ac <memcpy>
811296c4:	d8c00117 	ldw	r3,4(sp)
811296c8:	84400017 	ldw	r17,0(r16)
811296cc:	80800117 	ldw	r2,4(r16)
811296d0:	81400c17 	ldw	r5,48(r16)
811296d4:	88e3883a 	add	r17,r17,r3
811296d8:	10c5c83a 	sub	r2,r2,r3
811296dc:	84400015 	stw	r17,0(r16)
811296e0:	80800115 	stw	r2,4(r16)
811296e4:	b0e5c83a 	sub	r18,r22,r3
811296e8:	28002b26 	beq	r5,zero,81129798 <_fread_r+0x228>
811296ec:	90002b26 	beq	r18,zero,8112979c <_fread_r+0x22c>
811296f0:	80801004 	addi	r2,r16,64
811296f4:	28800526 	beq	r5,r2,8112970c <_fread_r+0x19c>
811296f8:	a009883a 	mov	r4,r20
811296fc:	d8c00115 	stw	r3,4(sp)
81129700:	112990c0 	call	8112990c <_free_r>
81129704:	d8c00117 	ldw	r3,4(sp)
81129708:	84400017 	ldw	r17,0(r16)
8112970c:	80000c15 	stw	zero,48(r16)
81129710:	80800517 	ldw	r2,20(r16)
81129714:	87000417 	ldw	fp,16(r16)
81129718:	98e7883a 	add	r19,r19,r3
8112971c:	d8800015 	stw	r2,0(sp)
81129720:	00000106 	br	81129728 <_fread_r+0x1b8>
81129724:	90001d26 	beq	r18,zero,8112979c <_fread_r+0x22c>
81129728:	84c00415 	stw	r19,16(r16)
8112972c:	84800515 	stw	r18,20(r16)
81129730:	84c00015 	stw	r19,0(r16)
81129734:	a009883a 	mov	r4,r20
81129738:	800b883a 	mov	r5,r16
8112973c:	1120c780 	call	81120c78 <__srefill_r>
81129740:	d9000017 	ldw	r4,0(sp)
81129744:	80c00117 	ldw	r3,4(r16)
81129748:	87000415 	stw	fp,16(r16)
8112974c:	81000515 	stw	r4,20(r16)
81129750:	84400015 	stw	r17,0(r16)
81129754:	80000115 	stw	zero,4(r16)
81129758:	90e5c83a 	sub	r18,r18,r3
8112975c:	98e7883a 	add	r19,r19,r3
81129760:	103ff026 	beq	r2,zero,81129724 <__reset+0xfb109724>
81129764:	b80b883a 	mov	r5,r23
81129768:	b489c83a 	sub	r4,r22,r18
8112976c:	1132c180 	call	81132c18 <__udivsi3>
81129770:	003fbe06 	br	8112966c <__reset+0xfb10966c>
81129774:	80000115 	stw	zero,4(r16)
81129778:	0009883a 	mov	r4,zero
8112977c:	0023883a 	mov	r17,zero
81129780:	003f9e06 	br	811295fc <__reset+0xfb1095fc>
81129784:	11294740 	call	81129474 <__sinit>
81129788:	8080030b 	ldhu	r2,12(r16)
8112978c:	10c8000c 	andi	r3,r2,8192
81129790:	183f971e 	bne	r3,zero,811295f0 <__reset+0xfb1095f0>
81129794:	003f9006 	br	811295d8 <__reset+0xfb1095d8>
81129798:	903fdd1e 	bne	r18,zero,81129710 <__reset+0xfb109710>
8112979c:	a805883a 	mov	r2,r21
811297a0:	003fb206 	br	8112966c <__reset+0xfb10966c>

811297a4 <fread>:
811297a4:	defffe04 	addi	sp,sp,-8
811297a8:	00a04574 	movhi	r2,33045
811297ac:	de00012e 	bgeu	sp,et,811297b4 <fread+0x10>
811297b0:	003b68fa 	trap	3
811297b4:	1082c604 	addi	r2,r2,2840
811297b8:	d9c00015 	stw	r7,0(sp)
811297bc:	300f883a 	mov	r7,r6
811297c0:	280d883a 	mov	r6,r5
811297c4:	200b883a 	mov	r5,r4
811297c8:	11000017 	ldw	r4,0(r2)
811297cc:	dfc00115 	stw	ra,4(sp)
811297d0:	11295700 	call	81129570 <_fread_r>
811297d4:	dfc00117 	ldw	ra,4(sp)
811297d8:	dec00204 	addi	sp,sp,8
811297dc:	f800283a 	ret

811297e0 <_malloc_trim_r>:
811297e0:	defffb04 	addi	sp,sp,-20
811297e4:	de00012e 	bgeu	sp,et,811297ec <_malloc_trim_r+0xc>
811297e8:	003b68fa 	trap	3
811297ec:	dcc00315 	stw	r19,12(sp)
811297f0:	04e04574 	movhi	r19,33045
811297f4:	dc800215 	stw	r18,8(sp)
811297f8:	dc400115 	stw	r17,4(sp)
811297fc:	dc000015 	stw	r16,0(sp)
81129800:	dfc00415 	stw	ra,16(sp)
81129804:	2821883a 	mov	r16,r5
81129808:	9cfc8404 	addi	r19,r19,-3568
8112980c:	2025883a 	mov	r18,r4
81129810:	11360d40 	call	811360d4 <__malloc_lock>
81129814:	98800217 	ldw	r2,8(r19)
81129818:	14400117 	ldw	r17,4(r2)
8112981c:	00bfff04 	movi	r2,-4
81129820:	88a2703a 	and	r17,r17,r2
81129824:	8c21c83a 	sub	r16,r17,r16
81129828:	8403fbc4 	addi	r16,r16,4079
8112982c:	8020d33a 	srli	r16,r16,12
81129830:	0083ffc4 	movi	r2,4095
81129834:	843fffc4 	addi	r16,r16,-1
81129838:	8020933a 	slli	r16,r16,12
8112983c:	1400060e 	bge	r2,r16,81129858 <_malloc_trim_r+0x78>
81129840:	000b883a 	mov	r5,zero
81129844:	9009883a 	mov	r4,r18
81129848:	1120e540 	call	81120e54 <_sbrk_r>
8112984c:	98c00217 	ldw	r3,8(r19)
81129850:	1c47883a 	add	r3,r3,r17
81129854:	10c00a26 	beq	r2,r3,81129880 <_malloc_trim_r+0xa0>
81129858:	9009883a 	mov	r4,r18
8112985c:	11361fc0 	call	811361fc <__malloc_unlock>
81129860:	0005883a 	mov	r2,zero
81129864:	dfc00417 	ldw	ra,16(sp)
81129868:	dcc00317 	ldw	r19,12(sp)
8112986c:	dc800217 	ldw	r18,8(sp)
81129870:	dc400117 	ldw	r17,4(sp)
81129874:	dc000017 	ldw	r16,0(sp)
81129878:	dec00504 	addi	sp,sp,20
8112987c:	f800283a 	ret
81129880:	040bc83a 	sub	r5,zero,r16
81129884:	9009883a 	mov	r4,r18
81129888:	1120e540 	call	81120e54 <_sbrk_r>
8112988c:	00ffffc4 	movi	r3,-1
81129890:	10c00d26 	beq	r2,r3,811298c8 <_malloc_trim_r+0xe8>
81129894:	00e04574 	movhi	r3,33045
81129898:	18c3c804 	addi	r3,r3,3872
8112989c:	18800017 	ldw	r2,0(r3)
811298a0:	99000217 	ldw	r4,8(r19)
811298a4:	8c23c83a 	sub	r17,r17,r16
811298a8:	8c400054 	ori	r17,r17,1
811298ac:	1421c83a 	sub	r16,r2,r16
811298b0:	24400115 	stw	r17,4(r4)
811298b4:	9009883a 	mov	r4,r18
811298b8:	1c000015 	stw	r16,0(r3)
811298bc:	11361fc0 	call	811361fc <__malloc_unlock>
811298c0:	00800044 	movi	r2,1
811298c4:	003fe706 	br	81129864 <__reset+0xfb109864>
811298c8:	000b883a 	mov	r5,zero
811298cc:	9009883a 	mov	r4,r18
811298d0:	1120e540 	call	81120e54 <_sbrk_r>
811298d4:	99000217 	ldw	r4,8(r19)
811298d8:	014003c4 	movi	r5,15
811298dc:	1107c83a 	sub	r3,r2,r4
811298e0:	28ffdd0e 	bge	r5,r3,81129858 <__reset+0xfb109858>
811298e4:	01604574 	movhi	r5,33045
811298e8:	2942c704 	addi	r5,r5,2844
811298ec:	29400017 	ldw	r5,0(r5)
811298f0:	18c00054 	ori	r3,r3,1
811298f4:	20c00115 	stw	r3,4(r4)
811298f8:	00e04574 	movhi	r3,33045
811298fc:	1145c83a 	sub	r2,r2,r5
81129900:	18c3c804 	addi	r3,r3,3872
81129904:	18800015 	stw	r2,0(r3)
81129908:	003fd306 	br	81129858 <__reset+0xfb109858>

8112990c <_free_r>:
8112990c:	28004326 	beq	r5,zero,81129a1c <_free_r+0x110>
81129910:	defffd04 	addi	sp,sp,-12
81129914:	de00012e 	bgeu	sp,et,8112991c <_free_r+0x10>
81129918:	003b68fa 	trap	3
8112991c:	dc400115 	stw	r17,4(sp)
81129920:	dc000015 	stw	r16,0(sp)
81129924:	2023883a 	mov	r17,r4
81129928:	2821883a 	mov	r16,r5
8112992c:	dfc00215 	stw	ra,8(sp)
81129930:	11360d40 	call	811360d4 <__malloc_lock>
81129934:	81ffff17 	ldw	r7,-4(r16)
81129938:	00bfff84 	movi	r2,-2
8112993c:	01204574 	movhi	r4,33045
81129940:	81bffe04 	addi	r6,r16,-8
81129944:	3884703a 	and	r2,r7,r2
81129948:	213c8404 	addi	r4,r4,-3568
8112994c:	308b883a 	add	r5,r6,r2
81129950:	2a400117 	ldw	r9,4(r5)
81129954:	22000217 	ldw	r8,8(r4)
81129958:	00ffff04 	movi	r3,-4
8112995c:	48c6703a 	and	r3,r9,r3
81129960:	2a005726 	beq	r5,r8,81129ac0 <_free_r+0x1b4>
81129964:	28c00115 	stw	r3,4(r5)
81129968:	39c0004c 	andi	r7,r7,1
8112996c:	3800091e 	bne	r7,zero,81129994 <_free_r+0x88>
81129970:	823ffe17 	ldw	r8,-8(r16)
81129974:	22400204 	addi	r9,r4,8
81129978:	320dc83a 	sub	r6,r6,r8
8112997c:	31c00217 	ldw	r7,8(r6)
81129980:	1205883a 	add	r2,r2,r8
81129984:	3a406526 	beq	r7,r9,81129b1c <_free_r+0x210>
81129988:	32000317 	ldw	r8,12(r6)
8112998c:	3a000315 	stw	r8,12(r7)
81129990:	41c00215 	stw	r7,8(r8)
81129994:	28cf883a 	add	r7,r5,r3
81129998:	39c00117 	ldw	r7,4(r7)
8112999c:	39c0004c 	andi	r7,r7,1
811299a0:	38003a26 	beq	r7,zero,81129a8c <_free_r+0x180>
811299a4:	10c00054 	ori	r3,r2,1
811299a8:	30c00115 	stw	r3,4(r6)
811299ac:	3087883a 	add	r3,r6,r2
811299b0:	18800015 	stw	r2,0(r3)
811299b4:	00c07fc4 	movi	r3,511
811299b8:	18801936 	bltu	r3,r2,81129a20 <_free_r+0x114>
811299bc:	1004d0fa 	srli	r2,r2,3
811299c0:	01c00044 	movi	r7,1
811299c4:	21400117 	ldw	r5,4(r4)
811299c8:	10c00044 	addi	r3,r2,1
811299cc:	18c7883a 	add	r3,r3,r3
811299d0:	1005d0ba 	srai	r2,r2,2
811299d4:	18c7883a 	add	r3,r3,r3
811299d8:	18c7883a 	add	r3,r3,r3
811299dc:	1907883a 	add	r3,r3,r4
811299e0:	3884983a 	sll	r2,r7,r2
811299e4:	19c00017 	ldw	r7,0(r3)
811299e8:	1a3ffe04 	addi	r8,r3,-8
811299ec:	1144b03a 	or	r2,r2,r5
811299f0:	32000315 	stw	r8,12(r6)
811299f4:	31c00215 	stw	r7,8(r6)
811299f8:	20800115 	stw	r2,4(r4)
811299fc:	19800015 	stw	r6,0(r3)
81129a00:	39800315 	stw	r6,12(r7)
81129a04:	8809883a 	mov	r4,r17
81129a08:	dfc00217 	ldw	ra,8(sp)
81129a0c:	dc400117 	ldw	r17,4(sp)
81129a10:	dc000017 	ldw	r16,0(sp)
81129a14:	dec00304 	addi	sp,sp,12
81129a18:	11361fc1 	jmpi	811361fc <__malloc_unlock>
81129a1c:	f800283a 	ret
81129a20:	100ad27a 	srli	r5,r2,9
81129a24:	00c00104 	movi	r3,4
81129a28:	19404a36 	bltu	r3,r5,81129b54 <_free_r+0x248>
81129a2c:	100ad1ba 	srli	r5,r2,6
81129a30:	28c00e44 	addi	r3,r5,57
81129a34:	18c7883a 	add	r3,r3,r3
81129a38:	29400e04 	addi	r5,r5,56
81129a3c:	18c7883a 	add	r3,r3,r3
81129a40:	18c7883a 	add	r3,r3,r3
81129a44:	1909883a 	add	r4,r3,r4
81129a48:	20c00017 	ldw	r3,0(r4)
81129a4c:	01e04574 	movhi	r7,33045
81129a50:	213ffe04 	addi	r4,r4,-8
81129a54:	39fc8404 	addi	r7,r7,-3568
81129a58:	20c04426 	beq	r4,r3,81129b6c <_free_r+0x260>
81129a5c:	01ffff04 	movi	r7,-4
81129a60:	19400117 	ldw	r5,4(r3)
81129a64:	29ca703a 	and	r5,r5,r7
81129a68:	1140022e 	bgeu	r2,r5,81129a74 <_free_r+0x168>
81129a6c:	18c00217 	ldw	r3,8(r3)
81129a70:	20fffb1e 	bne	r4,r3,81129a60 <__reset+0xfb109a60>
81129a74:	19000317 	ldw	r4,12(r3)
81129a78:	31000315 	stw	r4,12(r6)
81129a7c:	30c00215 	stw	r3,8(r6)
81129a80:	21800215 	stw	r6,8(r4)
81129a84:	19800315 	stw	r6,12(r3)
81129a88:	003fde06 	br	81129a04 <__reset+0xfb109a04>
81129a8c:	29c00217 	ldw	r7,8(r5)
81129a90:	10c5883a 	add	r2,r2,r3
81129a94:	00e04574 	movhi	r3,33045
81129a98:	18fc8604 	addi	r3,r3,-3560
81129a9c:	38c03b26 	beq	r7,r3,81129b8c <_free_r+0x280>
81129aa0:	2a000317 	ldw	r8,12(r5)
81129aa4:	11400054 	ori	r5,r2,1
81129aa8:	3087883a 	add	r3,r6,r2
81129aac:	3a000315 	stw	r8,12(r7)
81129ab0:	41c00215 	stw	r7,8(r8)
81129ab4:	31400115 	stw	r5,4(r6)
81129ab8:	18800015 	stw	r2,0(r3)
81129abc:	003fbd06 	br	811299b4 <__reset+0xfb1099b4>
81129ac0:	39c0004c 	andi	r7,r7,1
81129ac4:	10c5883a 	add	r2,r2,r3
81129ac8:	3800071e 	bne	r7,zero,81129ae8 <_free_r+0x1dc>
81129acc:	81fffe17 	ldw	r7,-8(r16)
81129ad0:	31cdc83a 	sub	r6,r6,r7
81129ad4:	30c00317 	ldw	r3,12(r6)
81129ad8:	31400217 	ldw	r5,8(r6)
81129adc:	11c5883a 	add	r2,r2,r7
81129ae0:	28c00315 	stw	r3,12(r5)
81129ae4:	19400215 	stw	r5,8(r3)
81129ae8:	10c00054 	ori	r3,r2,1
81129aec:	30c00115 	stw	r3,4(r6)
81129af0:	00e04574 	movhi	r3,33045
81129af4:	18c2c804 	addi	r3,r3,2848
81129af8:	18c00017 	ldw	r3,0(r3)
81129afc:	21800215 	stw	r6,8(r4)
81129b00:	10ffc036 	bltu	r2,r3,81129a04 <__reset+0xfb109a04>
81129b04:	00a04574 	movhi	r2,33045
81129b08:	10833b04 	addi	r2,r2,3308
81129b0c:	11400017 	ldw	r5,0(r2)
81129b10:	8809883a 	mov	r4,r17
81129b14:	11297e00 	call	811297e0 <_malloc_trim_r>
81129b18:	003fba06 	br	81129a04 <__reset+0xfb109a04>
81129b1c:	28c9883a 	add	r4,r5,r3
81129b20:	21000117 	ldw	r4,4(r4)
81129b24:	2100004c 	andi	r4,r4,1
81129b28:	2000391e 	bne	r4,zero,81129c10 <_free_r+0x304>
81129b2c:	29c00217 	ldw	r7,8(r5)
81129b30:	29000317 	ldw	r4,12(r5)
81129b34:	1885883a 	add	r2,r3,r2
81129b38:	10c00054 	ori	r3,r2,1
81129b3c:	39000315 	stw	r4,12(r7)
81129b40:	21c00215 	stw	r7,8(r4)
81129b44:	30c00115 	stw	r3,4(r6)
81129b48:	308d883a 	add	r6,r6,r2
81129b4c:	30800015 	stw	r2,0(r6)
81129b50:	003fac06 	br	81129a04 <__reset+0xfb109a04>
81129b54:	00c00504 	movi	r3,20
81129b58:	19401536 	bltu	r3,r5,81129bb0 <_free_r+0x2a4>
81129b5c:	28c01704 	addi	r3,r5,92
81129b60:	18c7883a 	add	r3,r3,r3
81129b64:	294016c4 	addi	r5,r5,91
81129b68:	003fb406 	br	81129a3c <__reset+0xfb109a3c>
81129b6c:	280bd0ba 	srai	r5,r5,2
81129b70:	00c00044 	movi	r3,1
81129b74:	38800117 	ldw	r2,4(r7)
81129b78:	194a983a 	sll	r5,r3,r5
81129b7c:	2007883a 	mov	r3,r4
81129b80:	2884b03a 	or	r2,r5,r2
81129b84:	38800115 	stw	r2,4(r7)
81129b88:	003fbb06 	br	81129a78 <__reset+0xfb109a78>
81129b8c:	21800515 	stw	r6,20(r4)
81129b90:	21800415 	stw	r6,16(r4)
81129b94:	10c00054 	ori	r3,r2,1
81129b98:	31c00315 	stw	r7,12(r6)
81129b9c:	31c00215 	stw	r7,8(r6)
81129ba0:	30c00115 	stw	r3,4(r6)
81129ba4:	308d883a 	add	r6,r6,r2
81129ba8:	30800015 	stw	r2,0(r6)
81129bac:	003f9506 	br	81129a04 <__reset+0xfb109a04>
81129bb0:	00c01504 	movi	r3,84
81129bb4:	19400536 	bltu	r3,r5,81129bcc <_free_r+0x2c0>
81129bb8:	100ad33a 	srli	r5,r2,12
81129bbc:	28c01bc4 	addi	r3,r5,111
81129bc0:	18c7883a 	add	r3,r3,r3
81129bc4:	29401b84 	addi	r5,r5,110
81129bc8:	003f9c06 	br	81129a3c <__reset+0xfb109a3c>
81129bcc:	00c05504 	movi	r3,340
81129bd0:	19400536 	bltu	r3,r5,81129be8 <_free_r+0x2dc>
81129bd4:	100ad3fa 	srli	r5,r2,15
81129bd8:	28c01e04 	addi	r3,r5,120
81129bdc:	18c7883a 	add	r3,r3,r3
81129be0:	29401dc4 	addi	r5,r5,119
81129be4:	003f9506 	br	81129a3c <__reset+0xfb109a3c>
81129be8:	00c15504 	movi	r3,1364
81129bec:	19400536 	bltu	r3,r5,81129c04 <_free_r+0x2f8>
81129bf0:	100ad4ba 	srli	r5,r2,18
81129bf4:	28c01f44 	addi	r3,r5,125
81129bf8:	18c7883a 	add	r3,r3,r3
81129bfc:	29401f04 	addi	r5,r5,124
81129c00:	003f8e06 	br	81129a3c <__reset+0xfb109a3c>
81129c04:	00c03f84 	movi	r3,254
81129c08:	01401f84 	movi	r5,126
81129c0c:	003f8b06 	br	81129a3c <__reset+0xfb109a3c>
81129c10:	10c00054 	ori	r3,r2,1
81129c14:	30c00115 	stw	r3,4(r6)
81129c18:	308d883a 	add	r6,r6,r2
81129c1c:	30800015 	stw	r2,0(r6)
81129c20:	003f7806 	br	81129a04 <__reset+0xfb109a04>

81129c24 <__sfvwrite_r>:
81129c24:	30800217 	ldw	r2,8(r6)
81129c28:	10006926 	beq	r2,zero,81129dd0 <__sfvwrite_r+0x1ac>
81129c2c:	defff404 	addi	sp,sp,-48
81129c30:	de00012e 	bgeu	sp,et,81129c38 <__sfvwrite_r+0x14>
81129c34:	003b68fa 	trap	3
81129c38:	28c0030b 	ldhu	r3,12(r5)
81129c3c:	dd400715 	stw	r21,28(sp)
81129c40:	dd000615 	stw	r20,24(sp)
81129c44:	dc000215 	stw	r16,8(sp)
81129c48:	dfc00b15 	stw	ra,44(sp)
81129c4c:	df000a15 	stw	fp,40(sp)
81129c50:	ddc00915 	stw	r23,36(sp)
81129c54:	dd800815 	stw	r22,32(sp)
81129c58:	dcc00515 	stw	r19,20(sp)
81129c5c:	dc800415 	stw	r18,16(sp)
81129c60:	dc400315 	stw	r17,12(sp)
81129c64:	1880020c 	andi	r2,r3,8
81129c68:	2821883a 	mov	r16,r5
81129c6c:	202b883a 	mov	r21,r4
81129c70:	3029883a 	mov	r20,r6
81129c74:	10002726 	beq	r2,zero,81129d14 <__sfvwrite_r+0xf0>
81129c78:	28800417 	ldw	r2,16(r5)
81129c7c:	10002526 	beq	r2,zero,81129d14 <__sfvwrite_r+0xf0>
81129c80:	1880008c 	andi	r2,r3,2
81129c84:	a4400017 	ldw	r17,0(r20)
81129c88:	10002a26 	beq	r2,zero,81129d34 <__sfvwrite_r+0x110>
81129c8c:	05a00034 	movhi	r22,32768
81129c90:	0027883a 	mov	r19,zero
81129c94:	0025883a 	mov	r18,zero
81129c98:	b5bf0004 	addi	r22,r22,-1024
81129c9c:	980d883a 	mov	r6,r19
81129ca0:	a809883a 	mov	r4,r21
81129ca4:	90004626 	beq	r18,zero,81129dc0 <__sfvwrite_r+0x19c>
81129ca8:	900f883a 	mov	r7,r18
81129cac:	b480022e 	bgeu	r22,r18,81129cb8 <__sfvwrite_r+0x94>
81129cb0:	01e00034 	movhi	r7,32768
81129cb4:	39ff0004 	addi	r7,r7,-1024
81129cb8:	80800917 	ldw	r2,36(r16)
81129cbc:	81400717 	ldw	r5,28(r16)
81129cc0:	103ee83a 	callr	r2
81129cc4:	0080570e 	bge	zero,r2,81129e24 <__sfvwrite_r+0x200>
81129cc8:	a0c00217 	ldw	r3,8(r20)
81129ccc:	98a7883a 	add	r19,r19,r2
81129cd0:	90a5c83a 	sub	r18,r18,r2
81129cd4:	1885c83a 	sub	r2,r3,r2
81129cd8:	a0800215 	stw	r2,8(r20)
81129cdc:	103fef1e 	bne	r2,zero,81129c9c <__reset+0xfb109c9c>
81129ce0:	0005883a 	mov	r2,zero
81129ce4:	dfc00b17 	ldw	ra,44(sp)
81129ce8:	df000a17 	ldw	fp,40(sp)
81129cec:	ddc00917 	ldw	r23,36(sp)
81129cf0:	dd800817 	ldw	r22,32(sp)
81129cf4:	dd400717 	ldw	r21,28(sp)
81129cf8:	dd000617 	ldw	r20,24(sp)
81129cfc:	dcc00517 	ldw	r19,20(sp)
81129d00:	dc800417 	ldw	r18,16(sp)
81129d04:	dc400317 	ldw	r17,12(sp)
81129d08:	dc000217 	ldw	r16,8(sp)
81129d0c:	dec00c04 	addi	sp,sp,48
81129d10:	f800283a 	ret
81129d14:	800b883a 	mov	r5,r16
81129d18:	a809883a 	mov	r4,r21
81129d1c:	11274040 	call	81127404 <__swsetup_r>
81129d20:	1000eb1e 	bne	r2,zero,8112a0d0 <__sfvwrite_r+0x4ac>
81129d24:	80c0030b 	ldhu	r3,12(r16)
81129d28:	a4400017 	ldw	r17,0(r20)
81129d2c:	1880008c 	andi	r2,r3,2
81129d30:	103fd61e 	bne	r2,zero,81129c8c <__reset+0xfb109c8c>
81129d34:	1880004c 	andi	r2,r3,1
81129d38:	10003f1e 	bne	r2,zero,81129e38 <__sfvwrite_r+0x214>
81129d3c:	0039883a 	mov	fp,zero
81129d40:	0025883a 	mov	r18,zero
81129d44:	90001a26 	beq	r18,zero,81129db0 <__sfvwrite_r+0x18c>
81129d48:	1880800c 	andi	r2,r3,512
81129d4c:	84c00217 	ldw	r19,8(r16)
81129d50:	10002126 	beq	r2,zero,81129dd8 <__sfvwrite_r+0x1b4>
81129d54:	982f883a 	mov	r23,r19
81129d58:	94c09336 	bltu	r18,r19,81129fa8 <__sfvwrite_r+0x384>
81129d5c:	1881200c 	andi	r2,r3,1152
81129d60:	10009e1e 	bne	r2,zero,81129fdc <__sfvwrite_r+0x3b8>
81129d64:	81000017 	ldw	r4,0(r16)
81129d68:	b80d883a 	mov	r6,r23
81129d6c:	e00b883a 	mov	r5,fp
81129d70:	112a7800 	call	8112a780 <memmove>
81129d74:	80c00217 	ldw	r3,8(r16)
81129d78:	81000017 	ldw	r4,0(r16)
81129d7c:	9005883a 	mov	r2,r18
81129d80:	1ce7c83a 	sub	r19,r3,r19
81129d84:	25cf883a 	add	r7,r4,r23
81129d88:	84c00215 	stw	r19,8(r16)
81129d8c:	81c00015 	stw	r7,0(r16)
81129d90:	a0c00217 	ldw	r3,8(r20)
81129d94:	e0b9883a 	add	fp,fp,r2
81129d98:	90a5c83a 	sub	r18,r18,r2
81129d9c:	18a7c83a 	sub	r19,r3,r2
81129da0:	a4c00215 	stw	r19,8(r20)
81129da4:	983fce26 	beq	r19,zero,81129ce0 <__reset+0xfb109ce0>
81129da8:	80c0030b 	ldhu	r3,12(r16)
81129dac:	903fe61e 	bne	r18,zero,81129d48 <__reset+0xfb109d48>
81129db0:	8f000017 	ldw	fp,0(r17)
81129db4:	8c800117 	ldw	r18,4(r17)
81129db8:	8c400204 	addi	r17,r17,8
81129dbc:	003fe106 	br	81129d44 <__reset+0xfb109d44>
81129dc0:	8cc00017 	ldw	r19,0(r17)
81129dc4:	8c800117 	ldw	r18,4(r17)
81129dc8:	8c400204 	addi	r17,r17,8
81129dcc:	003fb306 	br	81129c9c <__reset+0xfb109c9c>
81129dd0:	0005883a 	mov	r2,zero
81129dd4:	f800283a 	ret
81129dd8:	81000017 	ldw	r4,0(r16)
81129ddc:	80800417 	ldw	r2,16(r16)
81129de0:	11005736 	bltu	r2,r4,81129f40 <__sfvwrite_r+0x31c>
81129de4:	85c00517 	ldw	r23,20(r16)
81129de8:	95c05536 	bltu	r18,r23,81129f40 <__sfvwrite_r+0x31c>
81129dec:	00a00034 	movhi	r2,32768
81129df0:	10bfffc4 	addi	r2,r2,-1
81129df4:	9009883a 	mov	r4,r18
81129df8:	1480012e 	bgeu	r2,r18,81129e00 <__sfvwrite_r+0x1dc>
81129dfc:	1009883a 	mov	r4,r2
81129e00:	b80b883a 	mov	r5,r23
81129e04:	1132b200 	call	81132b20 <__divsi3>
81129e08:	15cf383a 	mul	r7,r2,r23
81129e0c:	81400717 	ldw	r5,28(r16)
81129e10:	80800917 	ldw	r2,36(r16)
81129e14:	e00d883a 	mov	r6,fp
81129e18:	a809883a 	mov	r4,r21
81129e1c:	103ee83a 	callr	r2
81129e20:	00bfdb16 	blt	zero,r2,81129d90 <__reset+0xfb109d90>
81129e24:	8080030b 	ldhu	r2,12(r16)
81129e28:	10801014 	ori	r2,r2,64
81129e2c:	8080030d 	sth	r2,12(r16)
81129e30:	00bfffc4 	movi	r2,-1
81129e34:	003fab06 	br	81129ce4 <__reset+0xfb109ce4>
81129e38:	0027883a 	mov	r19,zero
81129e3c:	0011883a 	mov	r8,zero
81129e40:	0039883a 	mov	fp,zero
81129e44:	0025883a 	mov	r18,zero
81129e48:	90001f26 	beq	r18,zero,81129ec8 <__sfvwrite_r+0x2a4>
81129e4c:	40005a26 	beq	r8,zero,81129fb8 <__sfvwrite_r+0x394>
81129e50:	982d883a 	mov	r22,r19
81129e54:	94c0012e 	bgeu	r18,r19,81129e5c <__sfvwrite_r+0x238>
81129e58:	902d883a 	mov	r22,r18
81129e5c:	81000017 	ldw	r4,0(r16)
81129e60:	80800417 	ldw	r2,16(r16)
81129e64:	b02f883a 	mov	r23,r22
81129e68:	81c00517 	ldw	r7,20(r16)
81129e6c:	1100032e 	bgeu	r2,r4,81129e7c <__sfvwrite_r+0x258>
81129e70:	80c00217 	ldw	r3,8(r16)
81129e74:	38c7883a 	add	r3,r7,r3
81129e78:	1d801816 	blt	r3,r22,81129edc <__sfvwrite_r+0x2b8>
81129e7c:	b1c03e16 	blt	r22,r7,81129f78 <__sfvwrite_r+0x354>
81129e80:	80800917 	ldw	r2,36(r16)
81129e84:	81400717 	ldw	r5,28(r16)
81129e88:	e00d883a 	mov	r6,fp
81129e8c:	da000115 	stw	r8,4(sp)
81129e90:	a809883a 	mov	r4,r21
81129e94:	103ee83a 	callr	r2
81129e98:	102f883a 	mov	r23,r2
81129e9c:	da000117 	ldw	r8,4(sp)
81129ea0:	00bfe00e 	bge	zero,r2,81129e24 <__reset+0xfb109e24>
81129ea4:	9de7c83a 	sub	r19,r19,r23
81129ea8:	98001f26 	beq	r19,zero,81129f28 <__sfvwrite_r+0x304>
81129eac:	a0800217 	ldw	r2,8(r20)
81129eb0:	e5f9883a 	add	fp,fp,r23
81129eb4:	95e5c83a 	sub	r18,r18,r23
81129eb8:	15efc83a 	sub	r23,r2,r23
81129ebc:	a5c00215 	stw	r23,8(r20)
81129ec0:	b83f8726 	beq	r23,zero,81129ce0 <__reset+0xfb109ce0>
81129ec4:	903fe11e 	bne	r18,zero,81129e4c <__reset+0xfb109e4c>
81129ec8:	8f000017 	ldw	fp,0(r17)
81129ecc:	8c800117 	ldw	r18,4(r17)
81129ed0:	0011883a 	mov	r8,zero
81129ed4:	8c400204 	addi	r17,r17,8
81129ed8:	003fdb06 	br	81129e48 <__reset+0xfb109e48>
81129edc:	180d883a 	mov	r6,r3
81129ee0:	e00b883a 	mov	r5,fp
81129ee4:	da000115 	stw	r8,4(sp)
81129ee8:	d8c00015 	stw	r3,0(sp)
81129eec:	112a7800 	call	8112a780 <memmove>
81129ef0:	d8c00017 	ldw	r3,0(sp)
81129ef4:	80800017 	ldw	r2,0(r16)
81129ef8:	800b883a 	mov	r5,r16
81129efc:	a809883a 	mov	r4,r21
81129f00:	10c5883a 	add	r2,r2,r3
81129f04:	80800015 	stw	r2,0(r16)
81129f08:	d8c00015 	stw	r3,0(sp)
81129f0c:	11290780 	call	81129078 <_fflush_r>
81129f10:	d8c00017 	ldw	r3,0(sp)
81129f14:	da000117 	ldw	r8,4(sp)
81129f18:	103fc21e 	bne	r2,zero,81129e24 <__reset+0xfb109e24>
81129f1c:	182f883a 	mov	r23,r3
81129f20:	9de7c83a 	sub	r19,r19,r23
81129f24:	983fe11e 	bne	r19,zero,81129eac <__reset+0xfb109eac>
81129f28:	800b883a 	mov	r5,r16
81129f2c:	a809883a 	mov	r4,r21
81129f30:	11290780 	call	81129078 <_fflush_r>
81129f34:	103fbb1e 	bne	r2,zero,81129e24 <__reset+0xfb109e24>
81129f38:	0011883a 	mov	r8,zero
81129f3c:	003fdb06 	br	81129eac <__reset+0xfb109eac>
81129f40:	94c0012e 	bgeu	r18,r19,81129f48 <__sfvwrite_r+0x324>
81129f44:	9027883a 	mov	r19,r18
81129f48:	980d883a 	mov	r6,r19
81129f4c:	e00b883a 	mov	r5,fp
81129f50:	112a7800 	call	8112a780 <memmove>
81129f54:	80800217 	ldw	r2,8(r16)
81129f58:	80c00017 	ldw	r3,0(r16)
81129f5c:	14c5c83a 	sub	r2,r2,r19
81129f60:	1cc7883a 	add	r3,r3,r19
81129f64:	80800215 	stw	r2,8(r16)
81129f68:	80c00015 	stw	r3,0(r16)
81129f6c:	10004326 	beq	r2,zero,8112a07c <__sfvwrite_r+0x458>
81129f70:	9805883a 	mov	r2,r19
81129f74:	003f8606 	br	81129d90 <__reset+0xfb109d90>
81129f78:	b00d883a 	mov	r6,r22
81129f7c:	e00b883a 	mov	r5,fp
81129f80:	da000115 	stw	r8,4(sp)
81129f84:	112a7800 	call	8112a780 <memmove>
81129f88:	80800217 	ldw	r2,8(r16)
81129f8c:	80c00017 	ldw	r3,0(r16)
81129f90:	da000117 	ldw	r8,4(sp)
81129f94:	1585c83a 	sub	r2,r2,r22
81129f98:	1dad883a 	add	r22,r3,r22
81129f9c:	80800215 	stw	r2,8(r16)
81129fa0:	85800015 	stw	r22,0(r16)
81129fa4:	003fbf06 	br	81129ea4 <__reset+0xfb109ea4>
81129fa8:	81000017 	ldw	r4,0(r16)
81129fac:	9027883a 	mov	r19,r18
81129fb0:	902f883a 	mov	r23,r18
81129fb4:	003f6c06 	br	81129d68 <__reset+0xfb109d68>
81129fb8:	900d883a 	mov	r6,r18
81129fbc:	01400284 	movi	r5,10
81129fc0:	e009883a 	mov	r4,fp
81129fc4:	112a69c0 	call	8112a69c <memchr>
81129fc8:	10003e26 	beq	r2,zero,8112a0c4 <__sfvwrite_r+0x4a0>
81129fcc:	10800044 	addi	r2,r2,1
81129fd0:	1727c83a 	sub	r19,r2,fp
81129fd4:	02000044 	movi	r8,1
81129fd8:	003f9d06 	br	81129e50 <__reset+0xfb109e50>
81129fdc:	80800517 	ldw	r2,20(r16)
81129fe0:	81400417 	ldw	r5,16(r16)
81129fe4:	81c00017 	ldw	r7,0(r16)
81129fe8:	10a7883a 	add	r19,r2,r2
81129fec:	9885883a 	add	r2,r19,r2
81129ff0:	1026d7fa 	srli	r19,r2,31
81129ff4:	396dc83a 	sub	r22,r7,r5
81129ff8:	b1000044 	addi	r4,r22,1
81129ffc:	9885883a 	add	r2,r19,r2
8112a000:	1027d07a 	srai	r19,r2,1
8112a004:	2485883a 	add	r2,r4,r18
8112a008:	980d883a 	mov	r6,r19
8112a00c:	9880022e 	bgeu	r19,r2,8112a018 <__sfvwrite_r+0x3f4>
8112a010:	1027883a 	mov	r19,r2
8112a014:	100d883a 	mov	r6,r2
8112a018:	18c1000c 	andi	r3,r3,1024
8112a01c:	18001c26 	beq	r3,zero,8112a090 <__sfvwrite_r+0x46c>
8112a020:	300b883a 	mov	r5,r6
8112a024:	a809883a 	mov	r4,r21
8112a028:	111fe980 	call	8111fe98 <_malloc_r>
8112a02c:	102f883a 	mov	r23,r2
8112a030:	10002926 	beq	r2,zero,8112a0d8 <__sfvwrite_r+0x4b4>
8112a034:	81400417 	ldw	r5,16(r16)
8112a038:	b00d883a 	mov	r6,r22
8112a03c:	1009883a 	mov	r4,r2
8112a040:	11206ac0 	call	811206ac <memcpy>
8112a044:	8080030b 	ldhu	r2,12(r16)
8112a048:	00fedfc4 	movi	r3,-1153
8112a04c:	10c4703a 	and	r2,r2,r3
8112a050:	10802014 	ori	r2,r2,128
8112a054:	8080030d 	sth	r2,12(r16)
8112a058:	bd89883a 	add	r4,r23,r22
8112a05c:	9d8fc83a 	sub	r7,r19,r22
8112a060:	85c00415 	stw	r23,16(r16)
8112a064:	84c00515 	stw	r19,20(r16)
8112a068:	81000015 	stw	r4,0(r16)
8112a06c:	9027883a 	mov	r19,r18
8112a070:	81c00215 	stw	r7,8(r16)
8112a074:	902f883a 	mov	r23,r18
8112a078:	003f3b06 	br	81129d68 <__reset+0xfb109d68>
8112a07c:	800b883a 	mov	r5,r16
8112a080:	a809883a 	mov	r4,r21
8112a084:	11290780 	call	81129078 <_fflush_r>
8112a088:	103fb926 	beq	r2,zero,81129f70 <__reset+0xfb109f70>
8112a08c:	003f6506 	br	81129e24 <__reset+0xfb109e24>
8112a090:	a809883a 	mov	r4,r21
8112a094:	112b9a00 	call	8112b9a0 <_realloc_r>
8112a098:	102f883a 	mov	r23,r2
8112a09c:	103fee1e 	bne	r2,zero,8112a058 <__reset+0xfb10a058>
8112a0a0:	81400417 	ldw	r5,16(r16)
8112a0a4:	a809883a 	mov	r4,r21
8112a0a8:	112990c0 	call	8112990c <_free_r>
8112a0ac:	8080030b 	ldhu	r2,12(r16)
8112a0b0:	00ffdfc4 	movi	r3,-129
8112a0b4:	1884703a 	and	r2,r3,r2
8112a0b8:	00c00304 	movi	r3,12
8112a0bc:	a8c00015 	stw	r3,0(r21)
8112a0c0:	003f5906 	br	81129e28 <__reset+0xfb109e28>
8112a0c4:	94c00044 	addi	r19,r18,1
8112a0c8:	02000044 	movi	r8,1
8112a0cc:	003f6006 	br	81129e50 <__reset+0xfb109e50>
8112a0d0:	00bfffc4 	movi	r2,-1
8112a0d4:	003f0306 	br	81129ce4 <__reset+0xfb109ce4>
8112a0d8:	00800304 	movi	r2,12
8112a0dc:	a8800015 	stw	r2,0(r21)
8112a0e0:	8080030b 	ldhu	r2,12(r16)
8112a0e4:	003f5006 	br	81129e28 <__reset+0xfb109e28>

8112a0e8 <_fwalk>:
8112a0e8:	defff704 	addi	sp,sp,-36
8112a0ec:	de00012e 	bgeu	sp,et,8112a0f4 <_fwalk+0xc>
8112a0f0:	003b68fa 	trap	3
8112a0f4:	dd000415 	stw	r20,16(sp)
8112a0f8:	dfc00815 	stw	ra,32(sp)
8112a0fc:	ddc00715 	stw	r23,28(sp)
8112a100:	dd800615 	stw	r22,24(sp)
8112a104:	dd400515 	stw	r21,20(sp)
8112a108:	dcc00315 	stw	r19,12(sp)
8112a10c:	dc800215 	stw	r18,8(sp)
8112a110:	dc400115 	stw	r17,4(sp)
8112a114:	dc000015 	stw	r16,0(sp)
8112a118:	2500b804 	addi	r20,r4,736
8112a11c:	a0002326 	beq	r20,zero,8112a1ac <_fwalk+0xc4>
8112a120:	282b883a 	mov	r21,r5
8112a124:	002f883a 	mov	r23,zero
8112a128:	05800044 	movi	r22,1
8112a12c:	04ffffc4 	movi	r19,-1
8112a130:	a4400117 	ldw	r17,4(r20)
8112a134:	a4800217 	ldw	r18,8(r20)
8112a138:	8c7fffc4 	addi	r17,r17,-1
8112a13c:	88000d16 	blt	r17,zero,8112a174 <_fwalk+0x8c>
8112a140:	94000304 	addi	r16,r18,12
8112a144:	94800384 	addi	r18,r18,14
8112a148:	8080000b 	ldhu	r2,0(r16)
8112a14c:	8c7fffc4 	addi	r17,r17,-1
8112a150:	813ffd04 	addi	r4,r16,-12
8112a154:	b080042e 	bgeu	r22,r2,8112a168 <_fwalk+0x80>
8112a158:	9080000f 	ldh	r2,0(r18)
8112a15c:	14c00226 	beq	r2,r19,8112a168 <_fwalk+0x80>
8112a160:	a83ee83a 	callr	r21
8112a164:	b8aeb03a 	or	r23,r23,r2
8112a168:	84001a04 	addi	r16,r16,104
8112a16c:	94801a04 	addi	r18,r18,104
8112a170:	8cfff51e 	bne	r17,r19,8112a148 <__reset+0xfb10a148>
8112a174:	a5000017 	ldw	r20,0(r20)
8112a178:	a03fed1e 	bne	r20,zero,8112a130 <__reset+0xfb10a130>
8112a17c:	b805883a 	mov	r2,r23
8112a180:	dfc00817 	ldw	ra,32(sp)
8112a184:	ddc00717 	ldw	r23,28(sp)
8112a188:	dd800617 	ldw	r22,24(sp)
8112a18c:	dd400517 	ldw	r21,20(sp)
8112a190:	dd000417 	ldw	r20,16(sp)
8112a194:	dcc00317 	ldw	r19,12(sp)
8112a198:	dc800217 	ldw	r18,8(sp)
8112a19c:	dc400117 	ldw	r17,4(sp)
8112a1a0:	dc000017 	ldw	r16,0(sp)
8112a1a4:	dec00904 	addi	sp,sp,36
8112a1a8:	f800283a 	ret
8112a1ac:	002f883a 	mov	r23,zero
8112a1b0:	003ff206 	br	8112a17c <__reset+0xfb10a17c>

8112a1b4 <_fwalk_reent>:
8112a1b4:	defff704 	addi	sp,sp,-36
8112a1b8:	de00012e 	bgeu	sp,et,8112a1c0 <_fwalk_reent+0xc>
8112a1bc:	003b68fa 	trap	3
8112a1c0:	dd000415 	stw	r20,16(sp)
8112a1c4:	dfc00815 	stw	ra,32(sp)
8112a1c8:	ddc00715 	stw	r23,28(sp)
8112a1cc:	dd800615 	stw	r22,24(sp)
8112a1d0:	dd400515 	stw	r21,20(sp)
8112a1d4:	dcc00315 	stw	r19,12(sp)
8112a1d8:	dc800215 	stw	r18,8(sp)
8112a1dc:	dc400115 	stw	r17,4(sp)
8112a1e0:	dc000015 	stw	r16,0(sp)
8112a1e4:	2500b804 	addi	r20,r4,736
8112a1e8:	a0002326 	beq	r20,zero,8112a278 <_fwalk_reent+0xc4>
8112a1ec:	282b883a 	mov	r21,r5
8112a1f0:	2027883a 	mov	r19,r4
8112a1f4:	002f883a 	mov	r23,zero
8112a1f8:	05800044 	movi	r22,1
8112a1fc:	04bfffc4 	movi	r18,-1
8112a200:	a4400117 	ldw	r17,4(r20)
8112a204:	a4000217 	ldw	r16,8(r20)
8112a208:	8c7fffc4 	addi	r17,r17,-1
8112a20c:	88000c16 	blt	r17,zero,8112a240 <_fwalk_reent+0x8c>
8112a210:	84000304 	addi	r16,r16,12
8112a214:	8080000b 	ldhu	r2,0(r16)
8112a218:	8c7fffc4 	addi	r17,r17,-1
8112a21c:	817ffd04 	addi	r5,r16,-12
8112a220:	b080052e 	bgeu	r22,r2,8112a238 <_fwalk_reent+0x84>
8112a224:	8080008f 	ldh	r2,2(r16)
8112a228:	9809883a 	mov	r4,r19
8112a22c:	14800226 	beq	r2,r18,8112a238 <_fwalk_reent+0x84>
8112a230:	a83ee83a 	callr	r21
8112a234:	b8aeb03a 	or	r23,r23,r2
8112a238:	84001a04 	addi	r16,r16,104
8112a23c:	8cbff51e 	bne	r17,r18,8112a214 <__reset+0xfb10a214>
8112a240:	a5000017 	ldw	r20,0(r20)
8112a244:	a03fee1e 	bne	r20,zero,8112a200 <__reset+0xfb10a200>
8112a248:	b805883a 	mov	r2,r23
8112a24c:	dfc00817 	ldw	ra,32(sp)
8112a250:	ddc00717 	ldw	r23,28(sp)
8112a254:	dd800617 	ldw	r22,24(sp)
8112a258:	dd400517 	ldw	r21,20(sp)
8112a25c:	dd000417 	ldw	r20,16(sp)
8112a260:	dcc00317 	ldw	r19,12(sp)
8112a264:	dc800217 	ldw	r18,8(sp)
8112a268:	dc400117 	ldw	r17,4(sp)
8112a26c:	dc000017 	ldw	r16,0(sp)
8112a270:	dec00904 	addi	sp,sp,36
8112a274:	f800283a 	ret
8112a278:	002f883a 	mov	r23,zero
8112a27c:	003ff206 	br	8112a248 <__reset+0xfb10a248>

8112a280 <_isatty_r>:
8112a280:	defffd04 	addi	sp,sp,-12
8112a284:	de00012e 	bgeu	sp,et,8112a28c <_isatty_r+0xc>
8112a288:	003b68fa 	trap	3
8112a28c:	dc000015 	stw	r16,0(sp)
8112a290:	04204574 	movhi	r16,33045
8112a294:	dc400115 	stw	r17,4(sp)
8112a298:	84033804 	addi	r16,r16,3296
8112a29c:	2023883a 	mov	r17,r4
8112a2a0:	2809883a 	mov	r4,r5
8112a2a4:	dfc00215 	stw	ra,8(sp)
8112a2a8:	80000015 	stw	zero,0(r16)
8112a2ac:	11348100 	call	81134810 <isatty>
8112a2b0:	00ffffc4 	movi	r3,-1
8112a2b4:	10c00526 	beq	r2,r3,8112a2cc <_isatty_r+0x4c>
8112a2b8:	dfc00217 	ldw	ra,8(sp)
8112a2bc:	dc400117 	ldw	r17,4(sp)
8112a2c0:	dc000017 	ldw	r16,0(sp)
8112a2c4:	dec00304 	addi	sp,sp,12
8112a2c8:	f800283a 	ret
8112a2cc:	80c00017 	ldw	r3,0(r16)
8112a2d0:	183ff926 	beq	r3,zero,8112a2b8 <__reset+0xfb10a2b8>
8112a2d4:	88c00015 	stw	r3,0(r17)
8112a2d8:	003ff706 	br	8112a2b8 <__reset+0xfb10a2b8>

8112a2dc <iswspace>:
8112a2dc:	00803fc4 	movi	r2,255
8112a2e0:	11000836 	bltu	r2,r4,8112a304 <iswspace+0x28>
8112a2e4:	00a04574 	movhi	r2,33045
8112a2e8:	1082c404 	addi	r2,r2,2832
8112a2ec:	10800017 	ldw	r2,0(r2)
8112a2f0:	1109883a 	add	r4,r2,r4
8112a2f4:	20800043 	ldbu	r2,1(r4)
8112a2f8:	1080020c 	andi	r2,r2,8
8112a2fc:	10803fcc 	andi	r2,r2,255
8112a300:	f800283a 	ret
8112a304:	0005883a 	mov	r2,zero
8112a308:	f800283a 	ret

8112a30c <_setlocale_r>:
8112a30c:	30001d26 	beq	r6,zero,8112a384 <_setlocale_r+0x78>
8112a310:	01604574 	movhi	r5,33045
8112a314:	defffe04 	addi	sp,sp,-8
8112a318:	29791d04 	addi	r5,r5,-7052
8112a31c:	3009883a 	mov	r4,r6
8112a320:	de00012e 	bgeu	sp,et,8112a328 <_setlocale_r+0x1c>
8112a324:	003b68fa 	trap	3
8112a328:	dc000015 	stw	r16,0(sp)
8112a32c:	dfc00115 	stw	ra,4(sp)
8112a330:	3021883a 	mov	r16,r6
8112a334:	112c0580 	call	8112c058 <strcmp>
8112a338:	1000061e 	bne	r2,zero,8112a354 <_setlocale_r+0x48>
8112a33c:	00a04574 	movhi	r2,33045
8112a340:	10b8ec04 	addi	r2,r2,-7248
8112a344:	dfc00117 	ldw	ra,4(sp)
8112a348:	dc000017 	ldw	r16,0(sp)
8112a34c:	dec00204 	addi	sp,sp,8
8112a350:	f800283a 	ret
8112a354:	01604574 	movhi	r5,33045
8112a358:	2978ec04 	addi	r5,r5,-7248
8112a35c:	8009883a 	mov	r4,r16
8112a360:	112c0580 	call	8112c058 <strcmp>
8112a364:	103ff526 	beq	r2,zero,8112a33c <__reset+0xfb10a33c>
8112a368:	01604574 	movhi	r5,33045
8112a36c:	2978f604 	addi	r5,r5,-7208
8112a370:	8009883a 	mov	r4,r16
8112a374:	112c0580 	call	8112c058 <strcmp>
8112a378:	103ff026 	beq	r2,zero,8112a33c <__reset+0xfb10a33c>
8112a37c:	0005883a 	mov	r2,zero
8112a380:	003ff006 	br	8112a344 <__reset+0xfb10a344>
8112a384:	00a04574 	movhi	r2,33045
8112a388:	10b8ec04 	addi	r2,r2,-7248
8112a38c:	f800283a 	ret

8112a390 <__locale_charset>:
8112a390:	00a04574 	movhi	r2,33045
8112a394:	10bd8e04 	addi	r2,r2,-2504
8112a398:	f800283a 	ret

8112a39c <__locale_mb_cur_max>:
8112a39c:	00a04574 	movhi	r2,33045
8112a3a0:	1082c904 	addi	r2,r2,2852
8112a3a4:	10800017 	ldw	r2,0(r2)
8112a3a8:	f800283a 	ret

8112a3ac <__locale_msgcharset>:
8112a3ac:	00a04574 	movhi	r2,33045
8112a3b0:	10bd8604 	addi	r2,r2,-2536
8112a3b4:	f800283a 	ret

8112a3b8 <__locale_cjk_lang>:
8112a3b8:	0005883a 	mov	r2,zero
8112a3bc:	f800283a 	ret

8112a3c0 <_localeconv_r>:
8112a3c0:	00a04574 	movhi	r2,33045
8112a3c4:	10bd9604 	addi	r2,r2,-2472
8112a3c8:	f800283a 	ret

8112a3cc <setlocale>:
8112a3cc:	00a04574 	movhi	r2,33045
8112a3d0:	1082c604 	addi	r2,r2,2840
8112a3d4:	280d883a 	mov	r6,r5
8112a3d8:	200b883a 	mov	r5,r4
8112a3dc:	11000017 	ldw	r4,0(r2)
8112a3e0:	112a30c1 	jmpi	8112a30c <_setlocale_r>

8112a3e4 <localeconv>:
8112a3e4:	00a04574 	movhi	r2,33045
8112a3e8:	10bd9604 	addi	r2,r2,-2472
8112a3ec:	f800283a 	ret

8112a3f0 <_lseek_r>:
8112a3f0:	defffd04 	addi	sp,sp,-12
8112a3f4:	de00012e 	bgeu	sp,et,8112a3fc <_lseek_r+0xc>
8112a3f8:	003b68fa 	trap	3
8112a3fc:	2805883a 	mov	r2,r5
8112a400:	dc000015 	stw	r16,0(sp)
8112a404:	04204574 	movhi	r16,33045
8112a408:	dc400115 	stw	r17,4(sp)
8112a40c:	300b883a 	mov	r5,r6
8112a410:	84033804 	addi	r16,r16,3296
8112a414:	2023883a 	mov	r17,r4
8112a418:	380d883a 	mov	r6,r7
8112a41c:	1009883a 	mov	r4,r2
8112a420:	dfc00215 	stw	ra,8(sp)
8112a424:	80000015 	stw	zero,0(r16)
8112a428:	113540c0 	call	8113540c <lseek>
8112a42c:	00ffffc4 	movi	r3,-1
8112a430:	10c00526 	beq	r2,r3,8112a448 <_lseek_r+0x58>
8112a434:	dfc00217 	ldw	ra,8(sp)
8112a438:	dc400117 	ldw	r17,4(sp)
8112a43c:	dc000017 	ldw	r16,0(sp)
8112a440:	dec00304 	addi	sp,sp,12
8112a444:	f800283a 	ret
8112a448:	80c00017 	ldw	r3,0(r16)
8112a44c:	183ff926 	beq	r3,zero,8112a434 <__reset+0xfb10a434>
8112a450:	88c00015 	stw	r3,0(r17)
8112a454:	003ff706 	br	8112a434 <__reset+0xfb10a434>

8112a458 <_mbrtowc_r>:
8112a458:	defff704 	addi	sp,sp,-36
8112a45c:	00a04574 	movhi	r2,33045
8112a460:	de00012e 	bgeu	sp,et,8112a468 <_mbrtowc_r+0x10>
8112a464:	003b68fa 	trap	3
8112a468:	1082ca04 	addi	r2,r2,2856
8112a46c:	dc800715 	stw	r18,28(sp)
8112a470:	dc400615 	stw	r17,24(sp)
8112a474:	dc000515 	stw	r16,20(sp)
8112a478:	dfc00815 	stw	ra,32(sp)
8112a47c:	2021883a 	mov	r16,r4
8112a480:	dc400917 	ldw	r17,36(sp)
8112a484:	14800017 	ldw	r18,0(r2)
8112a488:	30001626 	beq	r6,zero,8112a4e4 <_mbrtowc_r+0x8c>
8112a48c:	d9400215 	stw	r5,8(sp)
8112a490:	d9800315 	stw	r6,12(sp)
8112a494:	d9c00415 	stw	r7,16(sp)
8112a498:	112a3900 	call	8112a390 <__locale_charset>
8112a49c:	d9c00417 	ldw	r7,16(sp)
8112a4a0:	d9800317 	ldw	r6,12(sp)
8112a4a4:	d9400217 	ldw	r5,8(sp)
8112a4a8:	d8800015 	stw	r2,0(sp)
8112a4ac:	dc400115 	stw	r17,4(sp)
8112a4b0:	8009883a 	mov	r4,r16
8112a4b4:	903ee83a 	callr	r18
8112a4b8:	00ffffc4 	movi	r3,-1
8112a4bc:	10c0031e 	bne	r2,r3,8112a4cc <_mbrtowc_r+0x74>
8112a4c0:	88000015 	stw	zero,0(r17)
8112a4c4:	00c02284 	movi	r3,138
8112a4c8:	80c00015 	stw	r3,0(r16)
8112a4cc:	dfc00817 	ldw	ra,32(sp)
8112a4d0:	dc800717 	ldw	r18,28(sp)
8112a4d4:	dc400617 	ldw	r17,24(sp)
8112a4d8:	dc000517 	ldw	r16,20(sp)
8112a4dc:	dec00904 	addi	sp,sp,36
8112a4e0:	f800283a 	ret
8112a4e4:	112a3900 	call	8112a390 <__locale_charset>
8112a4e8:	01a04574 	movhi	r6,33045
8112a4ec:	31b8f604 	addi	r6,r6,-7208
8112a4f0:	dc400115 	stw	r17,4(sp)
8112a4f4:	d8800015 	stw	r2,0(sp)
8112a4f8:	01c00044 	movi	r7,1
8112a4fc:	000b883a 	mov	r5,zero
8112a500:	8009883a 	mov	r4,r16
8112a504:	903ee83a 	callr	r18
8112a508:	003feb06 	br	8112a4b8 <__reset+0xfb10a4b8>

8112a50c <mbrtowc>:
8112a50c:	defff704 	addi	sp,sp,-36
8112a510:	00a04574 	movhi	r2,33045
8112a514:	de00012e 	bgeu	sp,et,8112a51c <mbrtowc+0x10>
8112a518:	003b68fa 	trap	3
8112a51c:	1082c604 	addi	r2,r2,2840
8112a520:	dc800415 	stw	r18,16(sp)
8112a524:	dc400315 	stw	r17,12(sp)
8112a528:	dfc00815 	stw	ra,32(sp)
8112a52c:	dd400715 	stw	r21,28(sp)
8112a530:	dd000615 	stw	r20,24(sp)
8112a534:	dcc00515 	stw	r19,20(sp)
8112a538:	dc000215 	stw	r16,8(sp)
8112a53c:	3825883a 	mov	r18,r7
8112a540:	14400017 	ldw	r17,0(r2)
8112a544:	28001c26 	beq	r5,zero,8112a5b8 <mbrtowc+0xac>
8112a548:	00a04574 	movhi	r2,33045
8112a54c:	1082ca04 	addi	r2,r2,2856
8112a550:	15400017 	ldw	r21,0(r2)
8112a554:	2821883a 	mov	r16,r5
8112a558:	2027883a 	mov	r19,r4
8112a55c:	3029883a 	mov	r20,r6
8112a560:	112a3900 	call	8112a390 <__locale_charset>
8112a564:	d8800015 	stw	r2,0(sp)
8112a568:	dc800115 	stw	r18,4(sp)
8112a56c:	a00f883a 	mov	r7,r20
8112a570:	800d883a 	mov	r6,r16
8112a574:	980b883a 	mov	r5,r19
8112a578:	8809883a 	mov	r4,r17
8112a57c:	a83ee83a 	callr	r21
8112a580:	00ffffc4 	movi	r3,-1
8112a584:	10c0031e 	bne	r2,r3,8112a594 <mbrtowc+0x88>
8112a588:	90000015 	stw	zero,0(r18)
8112a58c:	00c02284 	movi	r3,138
8112a590:	88c00015 	stw	r3,0(r17)
8112a594:	dfc00817 	ldw	ra,32(sp)
8112a598:	dd400717 	ldw	r21,28(sp)
8112a59c:	dd000617 	ldw	r20,24(sp)
8112a5a0:	dcc00517 	ldw	r19,20(sp)
8112a5a4:	dc800417 	ldw	r18,16(sp)
8112a5a8:	dc400317 	ldw	r17,12(sp)
8112a5ac:	dc000217 	ldw	r16,8(sp)
8112a5b0:	dec00904 	addi	sp,sp,36
8112a5b4:	f800283a 	ret
8112a5b8:	00a04574 	movhi	r2,33045
8112a5bc:	1082ca04 	addi	r2,r2,2856
8112a5c0:	14000017 	ldw	r16,0(r2)
8112a5c4:	112a3900 	call	8112a390 <__locale_charset>
8112a5c8:	01a04574 	movhi	r6,33045
8112a5cc:	31b8f604 	addi	r6,r6,-7208
8112a5d0:	dc800115 	stw	r18,4(sp)
8112a5d4:	d8800015 	stw	r2,0(sp)
8112a5d8:	01c00044 	movi	r7,1
8112a5dc:	000b883a 	mov	r5,zero
8112a5e0:	8809883a 	mov	r4,r17
8112a5e4:	803ee83a 	callr	r16
8112a5e8:	003fe506 	br	8112a580 <__reset+0xfb10a580>

8112a5ec <__ascii_mbtowc>:
8112a5ec:	deffff04 	addi	sp,sp,-4
8112a5f0:	de00012e 	bgeu	sp,et,8112a5f8 <__ascii_mbtowc+0xc>
8112a5f4:	003b68fa 	trap	3
8112a5f8:	28000826 	beq	r5,zero,8112a61c <__ascii_mbtowc+0x30>
8112a5fc:	30000926 	beq	r6,zero,8112a624 <__ascii_mbtowc+0x38>
8112a600:	38000b26 	beq	r7,zero,8112a630 <__ascii_mbtowc+0x44>
8112a604:	30800003 	ldbu	r2,0(r6)
8112a608:	28800015 	stw	r2,0(r5)
8112a60c:	30800003 	ldbu	r2,0(r6)
8112a610:	1004c03a 	cmpne	r2,r2,zero
8112a614:	dec00104 	addi	sp,sp,4
8112a618:	f800283a 	ret
8112a61c:	d80b883a 	mov	r5,sp
8112a620:	303ff71e 	bne	r6,zero,8112a600 <__reset+0xfb10a600>
8112a624:	0005883a 	mov	r2,zero
8112a628:	dec00104 	addi	sp,sp,4
8112a62c:	f800283a 	ret
8112a630:	00bfff84 	movi	r2,-2
8112a634:	003ff706 	br	8112a614 <__reset+0xfb10a614>

8112a638 <_mbtowc_r>:
8112a638:	00a04574 	movhi	r2,33045
8112a63c:	defff804 	addi	sp,sp,-32
8112a640:	1082ca04 	addi	r2,r2,2856
8112a644:	de00012e 	bgeu	sp,et,8112a64c <_mbtowc_r+0x14>
8112a648:	003b68fa 	trap	3
8112a64c:	dfc00715 	stw	ra,28(sp)
8112a650:	dc000615 	stw	r16,24(sp)
8112a654:	14000017 	ldw	r16,0(r2)
8112a658:	d9000215 	stw	r4,8(sp)
8112a65c:	d9400315 	stw	r5,12(sp)
8112a660:	d9800415 	stw	r6,16(sp)
8112a664:	d9c00515 	stw	r7,20(sp)
8112a668:	112a3900 	call	8112a390 <__locale_charset>
8112a66c:	d8800015 	stw	r2,0(sp)
8112a670:	d8800817 	ldw	r2,32(sp)
8112a674:	d9c00517 	ldw	r7,20(sp)
8112a678:	d9800417 	ldw	r6,16(sp)
8112a67c:	d9400317 	ldw	r5,12(sp)
8112a680:	d9000217 	ldw	r4,8(sp)
8112a684:	d8800115 	stw	r2,4(sp)
8112a688:	803ee83a 	callr	r16
8112a68c:	dfc00717 	ldw	ra,28(sp)
8112a690:	dc000617 	ldw	r16,24(sp)
8112a694:	dec00804 	addi	sp,sp,32
8112a698:	f800283a 	ret

8112a69c <memchr>:
8112a69c:	208000cc 	andi	r2,r4,3
8112a6a0:	280f883a 	mov	r7,r5
8112a6a4:	10003426 	beq	r2,zero,8112a778 <memchr+0xdc>
8112a6a8:	30bfffc4 	addi	r2,r6,-1
8112a6ac:	30001a26 	beq	r6,zero,8112a718 <memchr+0x7c>
8112a6b0:	20c00003 	ldbu	r3,0(r4)
8112a6b4:	29803fcc 	andi	r6,r5,255
8112a6b8:	30c0051e 	bne	r6,r3,8112a6d0 <memchr+0x34>
8112a6bc:	00001806 	br	8112a720 <memchr+0x84>
8112a6c0:	10001526 	beq	r2,zero,8112a718 <memchr+0x7c>
8112a6c4:	20c00003 	ldbu	r3,0(r4)
8112a6c8:	10bfffc4 	addi	r2,r2,-1
8112a6cc:	30c01426 	beq	r6,r3,8112a720 <memchr+0x84>
8112a6d0:	21000044 	addi	r4,r4,1
8112a6d4:	20c000cc 	andi	r3,r4,3
8112a6d8:	183ff91e 	bne	r3,zero,8112a6c0 <__reset+0xfb10a6c0>
8112a6dc:	020000c4 	movi	r8,3
8112a6e0:	40801136 	bltu	r8,r2,8112a728 <memchr+0x8c>
8112a6e4:	10000c26 	beq	r2,zero,8112a718 <memchr+0x7c>
8112a6e8:	20c00003 	ldbu	r3,0(r4)
8112a6ec:	29403fcc 	andi	r5,r5,255
8112a6f0:	28c00b26 	beq	r5,r3,8112a720 <memchr+0x84>
8112a6f4:	20c00044 	addi	r3,r4,1
8112a6f8:	39803fcc 	andi	r6,r7,255
8112a6fc:	2089883a 	add	r4,r4,r2
8112a700:	00000306 	br	8112a710 <memchr+0x74>
8112a704:	18c00044 	addi	r3,r3,1
8112a708:	197fffc3 	ldbu	r5,-1(r3)
8112a70c:	31400526 	beq	r6,r5,8112a724 <memchr+0x88>
8112a710:	1805883a 	mov	r2,r3
8112a714:	20fffb1e 	bne	r4,r3,8112a704 <__reset+0xfb10a704>
8112a718:	0005883a 	mov	r2,zero
8112a71c:	f800283a 	ret
8112a720:	2005883a 	mov	r2,r4
8112a724:	f800283a 	ret
8112a728:	28c03fcc 	andi	r3,r5,255
8112a72c:	1812923a 	slli	r9,r3,8
8112a730:	02ffbff4 	movhi	r11,65279
8112a734:	02a02074 	movhi	r10,32897
8112a738:	48d2b03a 	or	r9,r9,r3
8112a73c:	4806943a 	slli	r3,r9,16
8112a740:	5affbfc4 	addi	r11,r11,-257
8112a744:	52a02004 	addi	r10,r10,-32640
8112a748:	48d2b03a 	or	r9,r9,r3
8112a74c:	20c00017 	ldw	r3,0(r4)
8112a750:	48c6f03a 	xor	r3,r9,r3
8112a754:	1acd883a 	add	r6,r3,r11
8112a758:	00c6303a 	nor	r3,zero,r3
8112a75c:	30c6703a 	and	r3,r6,r3
8112a760:	1a86703a 	and	r3,r3,r10
8112a764:	183fe01e 	bne	r3,zero,8112a6e8 <__reset+0xfb10a6e8>
8112a768:	10bfff04 	addi	r2,r2,-4
8112a76c:	21000104 	addi	r4,r4,4
8112a770:	40bff636 	bltu	r8,r2,8112a74c <__reset+0xfb10a74c>
8112a774:	003fdb06 	br	8112a6e4 <__reset+0xfb10a6e4>
8112a778:	3005883a 	mov	r2,r6
8112a77c:	003fd706 	br	8112a6dc <__reset+0xfb10a6dc>

8112a780 <memmove>:
8112a780:	2005883a 	mov	r2,r4
8112a784:	29000b2e 	bgeu	r5,r4,8112a7b4 <memmove+0x34>
8112a788:	298f883a 	add	r7,r5,r6
8112a78c:	21c0092e 	bgeu	r4,r7,8112a7b4 <memmove+0x34>
8112a790:	2187883a 	add	r3,r4,r6
8112a794:	198bc83a 	sub	r5,r3,r6
8112a798:	30004826 	beq	r6,zero,8112a8bc <memmove+0x13c>
8112a79c:	39ffffc4 	addi	r7,r7,-1
8112a7a0:	39000003 	ldbu	r4,0(r7)
8112a7a4:	18ffffc4 	addi	r3,r3,-1
8112a7a8:	19000005 	stb	r4,0(r3)
8112a7ac:	28fffb1e 	bne	r5,r3,8112a79c <__reset+0xfb10a79c>
8112a7b0:	f800283a 	ret
8112a7b4:	00c003c4 	movi	r3,15
8112a7b8:	1980412e 	bgeu	r3,r6,8112a8c0 <memmove+0x140>
8112a7bc:	2886b03a 	or	r3,r5,r2
8112a7c0:	18c000cc 	andi	r3,r3,3
8112a7c4:	1800401e 	bne	r3,zero,8112a8c8 <memmove+0x148>
8112a7c8:	33fffc04 	addi	r15,r6,-16
8112a7cc:	781ed13a 	srli	r15,r15,4
8112a7d0:	28c00104 	addi	r3,r5,4
8112a7d4:	13400104 	addi	r13,r2,4
8112a7d8:	781c913a 	slli	r14,r15,4
8112a7dc:	2b000204 	addi	r12,r5,8
8112a7e0:	12c00204 	addi	r11,r2,8
8112a7e4:	73800504 	addi	r14,r14,20
8112a7e8:	2a800304 	addi	r10,r5,12
8112a7ec:	12400304 	addi	r9,r2,12
8112a7f0:	2b9d883a 	add	r14,r5,r14
8112a7f4:	2811883a 	mov	r8,r5
8112a7f8:	100f883a 	mov	r7,r2
8112a7fc:	41000017 	ldw	r4,0(r8)
8112a800:	39c00404 	addi	r7,r7,16
8112a804:	18c00404 	addi	r3,r3,16
8112a808:	393ffc15 	stw	r4,-16(r7)
8112a80c:	193ffc17 	ldw	r4,-16(r3)
8112a810:	6b400404 	addi	r13,r13,16
8112a814:	5ac00404 	addi	r11,r11,16
8112a818:	693ffc15 	stw	r4,-16(r13)
8112a81c:	61000017 	ldw	r4,0(r12)
8112a820:	4a400404 	addi	r9,r9,16
8112a824:	42000404 	addi	r8,r8,16
8112a828:	593ffc15 	stw	r4,-16(r11)
8112a82c:	51000017 	ldw	r4,0(r10)
8112a830:	63000404 	addi	r12,r12,16
8112a834:	52800404 	addi	r10,r10,16
8112a838:	493ffc15 	stw	r4,-16(r9)
8112a83c:	1bbfef1e 	bne	r3,r14,8112a7fc <__reset+0xfb10a7fc>
8112a840:	79000044 	addi	r4,r15,1
8112a844:	2008913a 	slli	r4,r4,4
8112a848:	328003cc 	andi	r10,r6,15
8112a84c:	02c000c4 	movi	r11,3
8112a850:	1107883a 	add	r3,r2,r4
8112a854:	290b883a 	add	r5,r5,r4
8112a858:	5a801e2e 	bgeu	r11,r10,8112a8d4 <memmove+0x154>
8112a85c:	1813883a 	mov	r9,r3
8112a860:	2811883a 	mov	r8,r5
8112a864:	500f883a 	mov	r7,r10
8112a868:	41000017 	ldw	r4,0(r8)
8112a86c:	4a400104 	addi	r9,r9,4
8112a870:	39ffff04 	addi	r7,r7,-4
8112a874:	493fff15 	stw	r4,-4(r9)
8112a878:	42000104 	addi	r8,r8,4
8112a87c:	59fffa36 	bltu	r11,r7,8112a868 <__reset+0xfb10a868>
8112a880:	513fff04 	addi	r4,r10,-4
8112a884:	2008d0ba 	srli	r4,r4,2
8112a888:	318000cc 	andi	r6,r6,3
8112a88c:	21000044 	addi	r4,r4,1
8112a890:	2109883a 	add	r4,r4,r4
8112a894:	2109883a 	add	r4,r4,r4
8112a898:	1907883a 	add	r3,r3,r4
8112a89c:	290b883a 	add	r5,r5,r4
8112a8a0:	30000b26 	beq	r6,zero,8112a8d0 <memmove+0x150>
8112a8a4:	198d883a 	add	r6,r3,r6
8112a8a8:	29c00003 	ldbu	r7,0(r5)
8112a8ac:	18c00044 	addi	r3,r3,1
8112a8b0:	29400044 	addi	r5,r5,1
8112a8b4:	19ffffc5 	stb	r7,-1(r3)
8112a8b8:	19bffb1e 	bne	r3,r6,8112a8a8 <__reset+0xfb10a8a8>
8112a8bc:	f800283a 	ret
8112a8c0:	1007883a 	mov	r3,r2
8112a8c4:	003ff606 	br	8112a8a0 <__reset+0xfb10a8a0>
8112a8c8:	1007883a 	mov	r3,r2
8112a8cc:	003ff506 	br	8112a8a4 <__reset+0xfb10a8a4>
8112a8d0:	f800283a 	ret
8112a8d4:	500d883a 	mov	r6,r10
8112a8d8:	003ff106 	br	8112a8a0 <__reset+0xfb10a8a0>

8112a8dc <_Balloc>:
8112a8dc:	defffc04 	addi	sp,sp,-16
8112a8e0:	de00012e 	bgeu	sp,et,8112a8e8 <_Balloc+0xc>
8112a8e4:	003b68fa 	trap	3
8112a8e8:	20801317 	ldw	r2,76(r4)
8112a8ec:	dc400115 	stw	r17,4(sp)
8112a8f0:	dc000015 	stw	r16,0(sp)
8112a8f4:	dfc00315 	stw	ra,12(sp)
8112a8f8:	dc800215 	stw	r18,8(sp)
8112a8fc:	2023883a 	mov	r17,r4
8112a900:	2821883a 	mov	r16,r5
8112a904:	10000f26 	beq	r2,zero,8112a944 <_Balloc+0x68>
8112a908:	8407883a 	add	r3,r16,r16
8112a90c:	18c7883a 	add	r3,r3,r3
8112a910:	10c7883a 	add	r3,r2,r3
8112a914:	18800017 	ldw	r2,0(r3)
8112a918:	10001126 	beq	r2,zero,8112a960 <_Balloc+0x84>
8112a91c:	11000017 	ldw	r4,0(r2)
8112a920:	19000015 	stw	r4,0(r3)
8112a924:	10000415 	stw	zero,16(r2)
8112a928:	10000315 	stw	zero,12(r2)
8112a92c:	dfc00317 	ldw	ra,12(sp)
8112a930:	dc800217 	ldw	r18,8(sp)
8112a934:	dc400117 	ldw	r17,4(sp)
8112a938:	dc000017 	ldw	r16,0(sp)
8112a93c:	dec00404 	addi	sp,sp,16
8112a940:	f800283a 	ret
8112a944:	01800844 	movi	r6,33
8112a948:	01400104 	movi	r5,4
8112a94c:	1130e040 	call	81130e04 <_calloc_r>
8112a950:	88801315 	stw	r2,76(r17)
8112a954:	103fec1e 	bne	r2,zero,8112a908 <__reset+0xfb10a908>
8112a958:	0005883a 	mov	r2,zero
8112a95c:	003ff306 	br	8112a92c <__reset+0xfb10a92c>
8112a960:	01400044 	movi	r5,1
8112a964:	2c24983a 	sll	r18,r5,r16
8112a968:	8809883a 	mov	r4,r17
8112a96c:	91800144 	addi	r6,r18,5
8112a970:	318d883a 	add	r6,r6,r6
8112a974:	318d883a 	add	r6,r6,r6
8112a978:	1130e040 	call	81130e04 <_calloc_r>
8112a97c:	103ff626 	beq	r2,zero,8112a958 <__reset+0xfb10a958>
8112a980:	14000115 	stw	r16,4(r2)
8112a984:	14800215 	stw	r18,8(r2)
8112a988:	003fe606 	br	8112a924 <__reset+0xfb10a924>

8112a98c <_Bfree>:
8112a98c:	28000826 	beq	r5,zero,8112a9b0 <_Bfree+0x24>
8112a990:	28c00117 	ldw	r3,4(r5)
8112a994:	20801317 	ldw	r2,76(r4)
8112a998:	18c7883a 	add	r3,r3,r3
8112a99c:	18c7883a 	add	r3,r3,r3
8112a9a0:	10c5883a 	add	r2,r2,r3
8112a9a4:	10c00017 	ldw	r3,0(r2)
8112a9a8:	28c00015 	stw	r3,0(r5)
8112a9ac:	11400015 	stw	r5,0(r2)
8112a9b0:	f800283a 	ret

8112a9b4 <__multadd>:
8112a9b4:	defffa04 	addi	sp,sp,-24
8112a9b8:	de00012e 	bgeu	sp,et,8112a9c0 <__multadd+0xc>
8112a9bc:	003b68fa 	trap	3
8112a9c0:	0011883a 	mov	r8,zero
8112a9c4:	dc800315 	stw	r18,12(sp)
8112a9c8:	dc400215 	stw	r17,8(sp)
8112a9cc:	dc000115 	stw	r16,4(sp)
8112a9d0:	2823883a 	mov	r17,r5
8112a9d4:	2c000417 	ldw	r16,16(r5)
8112a9d8:	dfc00515 	stw	ra,20(sp)
8112a9dc:	dcc00415 	stw	r19,16(sp)
8112a9e0:	2025883a 	mov	r18,r4
8112a9e4:	29400504 	addi	r5,r5,20
8112a9e8:	28c00017 	ldw	r3,0(r5)
8112a9ec:	29400104 	addi	r5,r5,4
8112a9f0:	42000044 	addi	r8,r8,1
8112a9f4:	18bfffcc 	andi	r2,r3,65535
8112a9f8:	1185383a 	mul	r2,r2,r6
8112a9fc:	1806d43a 	srli	r3,r3,16
8112aa00:	11cf883a 	add	r7,r2,r7
8112aa04:	3808d43a 	srli	r4,r7,16
8112aa08:	1987383a 	mul	r3,r3,r6
8112aa0c:	38bfffcc 	andi	r2,r7,65535
8112aa10:	1907883a 	add	r3,r3,r4
8112aa14:	1808943a 	slli	r4,r3,16
8112aa18:	180ed43a 	srli	r7,r3,16
8112aa1c:	2085883a 	add	r2,r4,r2
8112aa20:	28bfff15 	stw	r2,-4(r5)
8112aa24:	443ff016 	blt	r8,r16,8112a9e8 <__reset+0xfb10a9e8>
8112aa28:	38000926 	beq	r7,zero,8112aa50 <__multadd+0x9c>
8112aa2c:	88800217 	ldw	r2,8(r17)
8112aa30:	80800f0e 	bge	r16,r2,8112aa70 <__multadd+0xbc>
8112aa34:	80800144 	addi	r2,r16,5
8112aa38:	1085883a 	add	r2,r2,r2
8112aa3c:	1085883a 	add	r2,r2,r2
8112aa40:	8885883a 	add	r2,r17,r2
8112aa44:	11c00015 	stw	r7,0(r2)
8112aa48:	84000044 	addi	r16,r16,1
8112aa4c:	8c000415 	stw	r16,16(r17)
8112aa50:	8805883a 	mov	r2,r17
8112aa54:	dfc00517 	ldw	ra,20(sp)
8112aa58:	dcc00417 	ldw	r19,16(sp)
8112aa5c:	dc800317 	ldw	r18,12(sp)
8112aa60:	dc400217 	ldw	r17,8(sp)
8112aa64:	dc000117 	ldw	r16,4(sp)
8112aa68:	dec00604 	addi	sp,sp,24
8112aa6c:	f800283a 	ret
8112aa70:	89400117 	ldw	r5,4(r17)
8112aa74:	9009883a 	mov	r4,r18
8112aa78:	d9c00015 	stw	r7,0(sp)
8112aa7c:	29400044 	addi	r5,r5,1
8112aa80:	112a8dc0 	call	8112a8dc <_Balloc>
8112aa84:	89800417 	ldw	r6,16(r17)
8112aa88:	89400304 	addi	r5,r17,12
8112aa8c:	11000304 	addi	r4,r2,12
8112aa90:	31800084 	addi	r6,r6,2
8112aa94:	318d883a 	add	r6,r6,r6
8112aa98:	318d883a 	add	r6,r6,r6
8112aa9c:	1027883a 	mov	r19,r2
8112aaa0:	11206ac0 	call	811206ac <memcpy>
8112aaa4:	d9c00017 	ldw	r7,0(sp)
8112aaa8:	88000a26 	beq	r17,zero,8112aad4 <__multadd+0x120>
8112aaac:	88c00117 	ldw	r3,4(r17)
8112aab0:	90801317 	ldw	r2,76(r18)
8112aab4:	18c7883a 	add	r3,r3,r3
8112aab8:	18c7883a 	add	r3,r3,r3
8112aabc:	10c5883a 	add	r2,r2,r3
8112aac0:	10c00017 	ldw	r3,0(r2)
8112aac4:	88c00015 	stw	r3,0(r17)
8112aac8:	14400015 	stw	r17,0(r2)
8112aacc:	9823883a 	mov	r17,r19
8112aad0:	003fd806 	br	8112aa34 <__reset+0xfb10aa34>
8112aad4:	9823883a 	mov	r17,r19
8112aad8:	003fd606 	br	8112aa34 <__reset+0xfb10aa34>

8112aadc <__s2b>:
8112aadc:	defff904 	addi	sp,sp,-28
8112aae0:	de00012e 	bgeu	sp,et,8112aae8 <__s2b+0xc>
8112aae4:	003b68fa 	trap	3
8112aae8:	dc400115 	stw	r17,4(sp)
8112aaec:	dc000015 	stw	r16,0(sp)
8112aaf0:	2023883a 	mov	r17,r4
8112aaf4:	2821883a 	mov	r16,r5
8112aaf8:	39000204 	addi	r4,r7,8
8112aafc:	01400244 	movi	r5,9
8112ab00:	dcc00315 	stw	r19,12(sp)
8112ab04:	dc800215 	stw	r18,8(sp)
8112ab08:	dfc00615 	stw	ra,24(sp)
8112ab0c:	dd400515 	stw	r21,20(sp)
8112ab10:	dd000415 	stw	r20,16(sp)
8112ab14:	3825883a 	mov	r18,r7
8112ab18:	3027883a 	mov	r19,r6
8112ab1c:	1132b200 	call	81132b20 <__divsi3>
8112ab20:	00c00044 	movi	r3,1
8112ab24:	000b883a 	mov	r5,zero
8112ab28:	1880030e 	bge	r3,r2,8112ab38 <__s2b+0x5c>
8112ab2c:	18c7883a 	add	r3,r3,r3
8112ab30:	29400044 	addi	r5,r5,1
8112ab34:	18bffd16 	blt	r3,r2,8112ab2c <__reset+0xfb10ab2c>
8112ab38:	8809883a 	mov	r4,r17
8112ab3c:	112a8dc0 	call	8112a8dc <_Balloc>
8112ab40:	d8c00717 	ldw	r3,28(sp)
8112ab44:	10c00515 	stw	r3,20(r2)
8112ab48:	00c00044 	movi	r3,1
8112ab4c:	10c00415 	stw	r3,16(r2)
8112ab50:	00c00244 	movi	r3,9
8112ab54:	1cc0210e 	bge	r3,r19,8112abdc <__s2b+0x100>
8112ab58:	80eb883a 	add	r21,r16,r3
8112ab5c:	a829883a 	mov	r20,r21
8112ab60:	84e1883a 	add	r16,r16,r19
8112ab64:	a1c00007 	ldb	r7,0(r20)
8112ab68:	01800284 	movi	r6,10
8112ab6c:	a5000044 	addi	r20,r20,1
8112ab70:	100b883a 	mov	r5,r2
8112ab74:	39fff404 	addi	r7,r7,-48
8112ab78:	8809883a 	mov	r4,r17
8112ab7c:	112a9b40 	call	8112a9b4 <__multadd>
8112ab80:	a43ff81e 	bne	r20,r16,8112ab64 <__reset+0xfb10ab64>
8112ab84:	ace1883a 	add	r16,r21,r19
8112ab88:	843ffe04 	addi	r16,r16,-8
8112ab8c:	9c800a0e 	bge	r19,r18,8112abb8 <__s2b+0xdc>
8112ab90:	94e5c83a 	sub	r18,r18,r19
8112ab94:	84a5883a 	add	r18,r16,r18
8112ab98:	81c00007 	ldb	r7,0(r16)
8112ab9c:	01800284 	movi	r6,10
8112aba0:	84000044 	addi	r16,r16,1
8112aba4:	100b883a 	mov	r5,r2
8112aba8:	39fff404 	addi	r7,r7,-48
8112abac:	8809883a 	mov	r4,r17
8112abb0:	112a9b40 	call	8112a9b4 <__multadd>
8112abb4:	84bff81e 	bne	r16,r18,8112ab98 <__reset+0xfb10ab98>
8112abb8:	dfc00617 	ldw	ra,24(sp)
8112abbc:	dd400517 	ldw	r21,20(sp)
8112abc0:	dd000417 	ldw	r20,16(sp)
8112abc4:	dcc00317 	ldw	r19,12(sp)
8112abc8:	dc800217 	ldw	r18,8(sp)
8112abcc:	dc400117 	ldw	r17,4(sp)
8112abd0:	dc000017 	ldw	r16,0(sp)
8112abd4:	dec00704 	addi	sp,sp,28
8112abd8:	f800283a 	ret
8112abdc:	84000284 	addi	r16,r16,10
8112abe0:	1827883a 	mov	r19,r3
8112abe4:	003fe906 	br	8112ab8c <__reset+0xfb10ab8c>

8112abe8 <__hi0bits>:
8112abe8:	20bfffec 	andhi	r2,r4,65535
8112abec:	1000141e 	bne	r2,zero,8112ac40 <__hi0bits+0x58>
8112abf0:	2008943a 	slli	r4,r4,16
8112abf4:	00800404 	movi	r2,16
8112abf8:	20ffc02c 	andhi	r3,r4,65280
8112abfc:	1800021e 	bne	r3,zero,8112ac08 <__hi0bits+0x20>
8112ac00:	2008923a 	slli	r4,r4,8
8112ac04:	10800204 	addi	r2,r2,8
8112ac08:	20fc002c 	andhi	r3,r4,61440
8112ac0c:	1800021e 	bne	r3,zero,8112ac18 <__hi0bits+0x30>
8112ac10:	2008913a 	slli	r4,r4,4
8112ac14:	10800104 	addi	r2,r2,4
8112ac18:	20f0002c 	andhi	r3,r4,49152
8112ac1c:	1800031e 	bne	r3,zero,8112ac2c <__hi0bits+0x44>
8112ac20:	2109883a 	add	r4,r4,r4
8112ac24:	10800084 	addi	r2,r2,2
8112ac28:	2109883a 	add	r4,r4,r4
8112ac2c:	20000316 	blt	r4,zero,8112ac3c <__hi0bits+0x54>
8112ac30:	2110002c 	andhi	r4,r4,16384
8112ac34:	2000041e 	bne	r4,zero,8112ac48 <__hi0bits+0x60>
8112ac38:	00800804 	movi	r2,32
8112ac3c:	f800283a 	ret
8112ac40:	0005883a 	mov	r2,zero
8112ac44:	003fec06 	br	8112abf8 <__reset+0xfb10abf8>
8112ac48:	10800044 	addi	r2,r2,1
8112ac4c:	f800283a 	ret

8112ac50 <__lo0bits>:
8112ac50:	20c00017 	ldw	r3,0(r4)
8112ac54:	188001cc 	andi	r2,r3,7
8112ac58:	10000826 	beq	r2,zero,8112ac7c <__lo0bits+0x2c>
8112ac5c:	1880004c 	andi	r2,r3,1
8112ac60:	1000211e 	bne	r2,zero,8112ace8 <__lo0bits+0x98>
8112ac64:	1880008c 	andi	r2,r3,2
8112ac68:	1000211e 	bne	r2,zero,8112acf0 <__lo0bits+0xa0>
8112ac6c:	1806d0ba 	srli	r3,r3,2
8112ac70:	00800084 	movi	r2,2
8112ac74:	20c00015 	stw	r3,0(r4)
8112ac78:	f800283a 	ret
8112ac7c:	18bfffcc 	andi	r2,r3,65535
8112ac80:	10001326 	beq	r2,zero,8112acd0 <__lo0bits+0x80>
8112ac84:	0005883a 	mov	r2,zero
8112ac88:	19403fcc 	andi	r5,r3,255
8112ac8c:	2800021e 	bne	r5,zero,8112ac98 <__lo0bits+0x48>
8112ac90:	1806d23a 	srli	r3,r3,8
8112ac94:	10800204 	addi	r2,r2,8
8112ac98:	194003cc 	andi	r5,r3,15
8112ac9c:	2800021e 	bne	r5,zero,8112aca8 <__lo0bits+0x58>
8112aca0:	1806d13a 	srli	r3,r3,4
8112aca4:	10800104 	addi	r2,r2,4
8112aca8:	194000cc 	andi	r5,r3,3
8112acac:	2800021e 	bne	r5,zero,8112acb8 <__lo0bits+0x68>
8112acb0:	1806d0ba 	srli	r3,r3,2
8112acb4:	10800084 	addi	r2,r2,2
8112acb8:	1940004c 	andi	r5,r3,1
8112acbc:	2800081e 	bne	r5,zero,8112ace0 <__lo0bits+0x90>
8112acc0:	1806d07a 	srli	r3,r3,1
8112acc4:	1800051e 	bne	r3,zero,8112acdc <__lo0bits+0x8c>
8112acc8:	00800804 	movi	r2,32
8112accc:	f800283a 	ret
8112acd0:	1806d43a 	srli	r3,r3,16
8112acd4:	00800404 	movi	r2,16
8112acd8:	003feb06 	br	8112ac88 <__reset+0xfb10ac88>
8112acdc:	10800044 	addi	r2,r2,1
8112ace0:	20c00015 	stw	r3,0(r4)
8112ace4:	f800283a 	ret
8112ace8:	0005883a 	mov	r2,zero
8112acec:	f800283a 	ret
8112acf0:	1806d07a 	srli	r3,r3,1
8112acf4:	00800044 	movi	r2,1
8112acf8:	20c00015 	stw	r3,0(r4)
8112acfc:	f800283a 	ret

8112ad00 <__i2b>:
8112ad00:	defffd04 	addi	sp,sp,-12
8112ad04:	de00012e 	bgeu	sp,et,8112ad0c <__i2b+0xc>
8112ad08:	003b68fa 	trap	3
8112ad0c:	dc000015 	stw	r16,0(sp)
8112ad10:	04000044 	movi	r16,1
8112ad14:	dc400115 	stw	r17,4(sp)
8112ad18:	2823883a 	mov	r17,r5
8112ad1c:	800b883a 	mov	r5,r16
8112ad20:	dfc00215 	stw	ra,8(sp)
8112ad24:	112a8dc0 	call	8112a8dc <_Balloc>
8112ad28:	14400515 	stw	r17,20(r2)
8112ad2c:	14000415 	stw	r16,16(r2)
8112ad30:	dfc00217 	ldw	ra,8(sp)
8112ad34:	dc400117 	ldw	r17,4(sp)
8112ad38:	dc000017 	ldw	r16,0(sp)
8112ad3c:	dec00304 	addi	sp,sp,12
8112ad40:	f800283a 	ret

8112ad44 <__multiply>:
8112ad44:	defffa04 	addi	sp,sp,-24
8112ad48:	de00012e 	bgeu	sp,et,8112ad50 <__multiply+0xc>
8112ad4c:	003b68fa 	trap	3
8112ad50:	dcc00315 	stw	r19,12(sp)
8112ad54:	dc800215 	stw	r18,8(sp)
8112ad58:	34c00417 	ldw	r19,16(r6)
8112ad5c:	2c800417 	ldw	r18,16(r5)
8112ad60:	dd000415 	stw	r20,16(sp)
8112ad64:	dc400115 	stw	r17,4(sp)
8112ad68:	dfc00515 	stw	ra,20(sp)
8112ad6c:	dc000015 	stw	r16,0(sp)
8112ad70:	2829883a 	mov	r20,r5
8112ad74:	3023883a 	mov	r17,r6
8112ad78:	94c0050e 	bge	r18,r19,8112ad90 <__multiply+0x4c>
8112ad7c:	9007883a 	mov	r3,r18
8112ad80:	3029883a 	mov	r20,r6
8112ad84:	9825883a 	mov	r18,r19
8112ad88:	2823883a 	mov	r17,r5
8112ad8c:	1827883a 	mov	r19,r3
8112ad90:	a0800217 	ldw	r2,8(r20)
8112ad94:	94e1883a 	add	r16,r18,r19
8112ad98:	a1400117 	ldw	r5,4(r20)
8112ad9c:	1400010e 	bge	r2,r16,8112ada4 <__multiply+0x60>
8112ada0:	29400044 	addi	r5,r5,1
8112ada4:	112a8dc0 	call	8112a8dc <_Balloc>
8112ada8:	8415883a 	add	r10,r16,r16
8112adac:	12c00504 	addi	r11,r2,20
8112adb0:	5295883a 	add	r10,r10,r10
8112adb4:	5a95883a 	add	r10,r11,r10
8112adb8:	5807883a 	mov	r3,r11
8112adbc:	5a80032e 	bgeu	r11,r10,8112adcc <__multiply+0x88>
8112adc0:	18000015 	stw	zero,0(r3)
8112adc4:	18c00104 	addi	r3,r3,4
8112adc8:	1abffd36 	bltu	r3,r10,8112adc0 <__reset+0xfb10adc0>
8112adcc:	9ce7883a 	add	r19,r19,r19
8112add0:	94a5883a 	add	r18,r18,r18
8112add4:	89800504 	addi	r6,r17,20
8112add8:	9ce7883a 	add	r19,r19,r19
8112addc:	a3400504 	addi	r13,r20,20
8112ade0:	94a5883a 	add	r18,r18,r18
8112ade4:	34d9883a 	add	r12,r6,r19
8112ade8:	6c93883a 	add	r9,r13,r18
8112adec:	3300422e 	bgeu	r6,r12,8112aef8 <__multiply+0x1b4>
8112adf0:	37c00017 	ldw	ra,0(r6)
8112adf4:	fbffffcc 	andi	r15,ra,65535
8112adf8:	78001b26 	beq	r15,zero,8112ae68 <__multiply+0x124>
8112adfc:	5811883a 	mov	r8,r11
8112ae00:	681d883a 	mov	r14,r13
8112ae04:	000f883a 	mov	r7,zero
8112ae08:	71000017 	ldw	r4,0(r14)
8112ae0c:	40c00017 	ldw	r3,0(r8)
8112ae10:	73800104 	addi	r14,r14,4
8112ae14:	217fffcc 	andi	r5,r4,65535
8112ae18:	2bcb383a 	mul	r5,r5,r15
8112ae1c:	2008d43a 	srli	r4,r4,16
8112ae20:	1c7fffcc 	andi	r17,r3,65535
8112ae24:	2c4b883a 	add	r5,r5,r17
8112ae28:	29cb883a 	add	r5,r5,r7
8112ae2c:	23c9383a 	mul	r4,r4,r15
8112ae30:	1806d43a 	srli	r3,r3,16
8112ae34:	280ed43a 	srli	r7,r5,16
8112ae38:	297fffcc 	andi	r5,r5,65535
8112ae3c:	20c7883a 	add	r3,r4,r3
8112ae40:	19c7883a 	add	r3,r3,r7
8112ae44:	1808943a 	slli	r4,r3,16
8112ae48:	4023883a 	mov	r17,r8
8112ae4c:	180ed43a 	srli	r7,r3,16
8112ae50:	214ab03a 	or	r5,r4,r5
8112ae54:	41400015 	stw	r5,0(r8)
8112ae58:	42000104 	addi	r8,r8,4
8112ae5c:	727fea36 	bltu	r14,r9,8112ae08 <__reset+0xfb10ae08>
8112ae60:	89c00115 	stw	r7,4(r17)
8112ae64:	37c00017 	ldw	ra,0(r6)
8112ae68:	f83ed43a 	srli	ra,ra,16
8112ae6c:	f8001f26 	beq	ra,zero,8112aeec <__multiply+0x1a8>
8112ae70:	58c00017 	ldw	r3,0(r11)
8112ae74:	681d883a 	mov	r14,r13
8112ae78:	581f883a 	mov	r15,r11
8112ae7c:	1811883a 	mov	r8,r3
8112ae80:	5825883a 	mov	r18,r11
8112ae84:	000f883a 	mov	r7,zero
8112ae88:	00000106 	br	8112ae90 <__multiply+0x14c>
8112ae8c:	8825883a 	mov	r18,r17
8112ae90:	7140000b 	ldhu	r5,0(r14)
8112ae94:	4010d43a 	srli	r8,r8,16
8112ae98:	193fffcc 	andi	r4,r3,65535
8112ae9c:	2fcb383a 	mul	r5,r5,ra
8112aea0:	7bc00104 	addi	r15,r15,4
8112aea4:	73800104 	addi	r14,r14,4
8112aea8:	2a0b883a 	add	r5,r5,r8
8112aeac:	29cb883a 	add	r5,r5,r7
8112aeb0:	2806943a 	slli	r3,r5,16
8112aeb4:	94400104 	addi	r17,r18,4
8112aeb8:	280ad43a 	srli	r5,r5,16
8112aebc:	1908b03a 	or	r4,r3,r4
8112aec0:	793fff15 	stw	r4,-4(r15)
8112aec4:	70ffff17 	ldw	r3,-4(r14)
8112aec8:	8a000017 	ldw	r8,0(r17)
8112aecc:	1806d43a 	srli	r3,r3,16
8112aed0:	413fffcc 	andi	r4,r8,65535
8112aed4:	1fc7383a 	mul	r3,r3,ra
8112aed8:	1907883a 	add	r3,r3,r4
8112aedc:	1947883a 	add	r3,r3,r5
8112aee0:	180ed43a 	srli	r7,r3,16
8112aee4:	727fe936 	bltu	r14,r9,8112ae8c <__reset+0xfb10ae8c>
8112aee8:	90c00115 	stw	r3,4(r18)
8112aeec:	31800104 	addi	r6,r6,4
8112aef0:	5ac00104 	addi	r11,r11,4
8112aef4:	333fbe36 	bltu	r6,r12,8112adf0 <__reset+0xfb10adf0>
8112aef8:	0400090e 	bge	zero,r16,8112af20 <__multiply+0x1dc>
8112aefc:	50ffff17 	ldw	r3,-4(r10)
8112af00:	52bfff04 	addi	r10,r10,-4
8112af04:	18000326 	beq	r3,zero,8112af14 <__multiply+0x1d0>
8112af08:	00000506 	br	8112af20 <__multiply+0x1dc>
8112af0c:	50c00017 	ldw	r3,0(r10)
8112af10:	1800031e 	bne	r3,zero,8112af20 <__multiply+0x1dc>
8112af14:	843fffc4 	addi	r16,r16,-1
8112af18:	52bfff04 	addi	r10,r10,-4
8112af1c:	803ffb1e 	bne	r16,zero,8112af0c <__reset+0xfb10af0c>
8112af20:	14000415 	stw	r16,16(r2)
8112af24:	dfc00517 	ldw	ra,20(sp)
8112af28:	dd000417 	ldw	r20,16(sp)
8112af2c:	dcc00317 	ldw	r19,12(sp)
8112af30:	dc800217 	ldw	r18,8(sp)
8112af34:	dc400117 	ldw	r17,4(sp)
8112af38:	dc000017 	ldw	r16,0(sp)
8112af3c:	dec00604 	addi	sp,sp,24
8112af40:	f800283a 	ret

8112af44 <__pow5mult>:
8112af44:	defffa04 	addi	sp,sp,-24
8112af48:	de00012e 	bgeu	sp,et,8112af50 <__pow5mult+0xc>
8112af4c:	003b68fa 	trap	3
8112af50:	308000cc 	andi	r2,r6,3
8112af54:	dcc00315 	stw	r19,12(sp)
8112af58:	dc000015 	stw	r16,0(sp)
8112af5c:	dfc00515 	stw	ra,20(sp)
8112af60:	dd000415 	stw	r20,16(sp)
8112af64:	dc800215 	stw	r18,8(sp)
8112af68:	dc400115 	stw	r17,4(sp)
8112af6c:	3021883a 	mov	r16,r6
8112af70:	2027883a 	mov	r19,r4
8112af74:	10002f1e 	bne	r2,zero,8112b034 <__pow5mult+0xf0>
8112af78:	2825883a 	mov	r18,r5
8112af7c:	8021d0ba 	srai	r16,r16,2
8112af80:	80001a26 	beq	r16,zero,8112afec <__pow5mult+0xa8>
8112af84:	9c401217 	ldw	r17,72(r19)
8112af88:	8800061e 	bne	r17,zero,8112afa4 <__pow5mult+0x60>
8112af8c:	00003406 	br	8112b060 <__pow5mult+0x11c>
8112af90:	8021d07a 	srai	r16,r16,1
8112af94:	80001526 	beq	r16,zero,8112afec <__pow5mult+0xa8>
8112af98:	88800017 	ldw	r2,0(r17)
8112af9c:	10001c26 	beq	r2,zero,8112b010 <__pow5mult+0xcc>
8112afa0:	1023883a 	mov	r17,r2
8112afa4:	8080004c 	andi	r2,r16,1
8112afa8:	103ff926 	beq	r2,zero,8112af90 <__reset+0xfb10af90>
8112afac:	880d883a 	mov	r6,r17
8112afb0:	900b883a 	mov	r5,r18
8112afb4:	9809883a 	mov	r4,r19
8112afb8:	112ad440 	call	8112ad44 <__multiply>
8112afbc:	90001b26 	beq	r18,zero,8112b02c <__pow5mult+0xe8>
8112afc0:	91000117 	ldw	r4,4(r18)
8112afc4:	98c01317 	ldw	r3,76(r19)
8112afc8:	8021d07a 	srai	r16,r16,1
8112afcc:	2109883a 	add	r4,r4,r4
8112afd0:	2109883a 	add	r4,r4,r4
8112afd4:	1907883a 	add	r3,r3,r4
8112afd8:	19000017 	ldw	r4,0(r3)
8112afdc:	91000015 	stw	r4,0(r18)
8112afe0:	1c800015 	stw	r18,0(r3)
8112afe4:	1025883a 	mov	r18,r2
8112afe8:	803feb1e 	bne	r16,zero,8112af98 <__reset+0xfb10af98>
8112afec:	9005883a 	mov	r2,r18
8112aff0:	dfc00517 	ldw	ra,20(sp)
8112aff4:	dd000417 	ldw	r20,16(sp)
8112aff8:	dcc00317 	ldw	r19,12(sp)
8112affc:	dc800217 	ldw	r18,8(sp)
8112b000:	dc400117 	ldw	r17,4(sp)
8112b004:	dc000017 	ldw	r16,0(sp)
8112b008:	dec00604 	addi	sp,sp,24
8112b00c:	f800283a 	ret
8112b010:	880d883a 	mov	r6,r17
8112b014:	880b883a 	mov	r5,r17
8112b018:	9809883a 	mov	r4,r19
8112b01c:	112ad440 	call	8112ad44 <__multiply>
8112b020:	88800015 	stw	r2,0(r17)
8112b024:	10000015 	stw	zero,0(r2)
8112b028:	003fdd06 	br	8112afa0 <__reset+0xfb10afa0>
8112b02c:	1025883a 	mov	r18,r2
8112b030:	003fd706 	br	8112af90 <__reset+0xfb10af90>
8112b034:	10bfffc4 	addi	r2,r2,-1
8112b038:	1085883a 	add	r2,r2,r2
8112b03c:	00e04574 	movhi	r3,33045
8112b040:	18f92004 	addi	r3,r3,-7040
8112b044:	1085883a 	add	r2,r2,r2
8112b048:	1885883a 	add	r2,r3,r2
8112b04c:	11800017 	ldw	r6,0(r2)
8112b050:	000f883a 	mov	r7,zero
8112b054:	112a9b40 	call	8112a9b4 <__multadd>
8112b058:	1025883a 	mov	r18,r2
8112b05c:	003fc706 	br	8112af7c <__reset+0xfb10af7c>
8112b060:	05000044 	movi	r20,1
8112b064:	a00b883a 	mov	r5,r20
8112b068:	9809883a 	mov	r4,r19
8112b06c:	112a8dc0 	call	8112a8dc <_Balloc>
8112b070:	1023883a 	mov	r17,r2
8112b074:	00809c44 	movi	r2,625
8112b078:	88800515 	stw	r2,20(r17)
8112b07c:	8d000415 	stw	r20,16(r17)
8112b080:	9c401215 	stw	r17,72(r19)
8112b084:	88000015 	stw	zero,0(r17)
8112b088:	003fc606 	br	8112afa4 <__reset+0xfb10afa4>

8112b08c <__lshift>:
8112b08c:	defff904 	addi	sp,sp,-28
8112b090:	de00012e 	bgeu	sp,et,8112b098 <__lshift+0xc>
8112b094:	003b68fa 	trap	3
8112b098:	dd400515 	stw	r21,20(sp)
8112b09c:	dcc00315 	stw	r19,12(sp)
8112b0a0:	302bd17a 	srai	r21,r6,5
8112b0a4:	2cc00417 	ldw	r19,16(r5)
8112b0a8:	28800217 	ldw	r2,8(r5)
8112b0ac:	dd000415 	stw	r20,16(sp)
8112b0b0:	ace7883a 	add	r19,r21,r19
8112b0b4:	dc800215 	stw	r18,8(sp)
8112b0b8:	dc400115 	stw	r17,4(sp)
8112b0bc:	dc000015 	stw	r16,0(sp)
8112b0c0:	dfc00615 	stw	ra,24(sp)
8112b0c4:	9c000044 	addi	r16,r19,1
8112b0c8:	2823883a 	mov	r17,r5
8112b0cc:	3029883a 	mov	r20,r6
8112b0d0:	2025883a 	mov	r18,r4
8112b0d4:	29400117 	ldw	r5,4(r5)
8112b0d8:	1400030e 	bge	r2,r16,8112b0e8 <__lshift+0x5c>
8112b0dc:	1085883a 	add	r2,r2,r2
8112b0e0:	29400044 	addi	r5,r5,1
8112b0e4:	143ffd16 	blt	r2,r16,8112b0dc <__reset+0xfb10b0dc>
8112b0e8:	9009883a 	mov	r4,r18
8112b0ec:	112a8dc0 	call	8112a8dc <_Balloc>
8112b0f0:	10c00504 	addi	r3,r2,20
8112b0f4:	0540070e 	bge	zero,r21,8112b114 <__lshift+0x88>
8112b0f8:	ad6b883a 	add	r21,r21,r21
8112b0fc:	ad6b883a 	add	r21,r21,r21
8112b100:	1809883a 	mov	r4,r3
8112b104:	1d47883a 	add	r3,r3,r21
8112b108:	20000015 	stw	zero,0(r4)
8112b10c:	21000104 	addi	r4,r4,4
8112b110:	193ffd1e 	bne	r3,r4,8112b108 <__reset+0xfb10b108>
8112b114:	8a000417 	ldw	r8,16(r17)
8112b118:	89000504 	addi	r4,r17,20
8112b11c:	a18007cc 	andi	r6,r20,31
8112b120:	4211883a 	add	r8,r8,r8
8112b124:	4211883a 	add	r8,r8,r8
8112b128:	2211883a 	add	r8,r4,r8
8112b12c:	30002326 	beq	r6,zero,8112b1bc <__lshift+0x130>
8112b130:	02400804 	movi	r9,32
8112b134:	4993c83a 	sub	r9,r9,r6
8112b138:	000b883a 	mov	r5,zero
8112b13c:	21c00017 	ldw	r7,0(r4)
8112b140:	1815883a 	mov	r10,r3
8112b144:	18c00104 	addi	r3,r3,4
8112b148:	398e983a 	sll	r7,r7,r6
8112b14c:	21000104 	addi	r4,r4,4
8112b150:	394ab03a 	or	r5,r7,r5
8112b154:	197fff15 	stw	r5,-4(r3)
8112b158:	217fff17 	ldw	r5,-4(r4)
8112b15c:	2a4ad83a 	srl	r5,r5,r9
8112b160:	223ff636 	bltu	r4,r8,8112b13c <__reset+0xfb10b13c>
8112b164:	51400115 	stw	r5,4(r10)
8112b168:	28001a1e 	bne	r5,zero,8112b1d4 <__lshift+0x148>
8112b16c:	843fffc4 	addi	r16,r16,-1
8112b170:	14000415 	stw	r16,16(r2)
8112b174:	88000826 	beq	r17,zero,8112b198 <__lshift+0x10c>
8112b178:	89000117 	ldw	r4,4(r17)
8112b17c:	90c01317 	ldw	r3,76(r18)
8112b180:	2109883a 	add	r4,r4,r4
8112b184:	2109883a 	add	r4,r4,r4
8112b188:	1907883a 	add	r3,r3,r4
8112b18c:	19000017 	ldw	r4,0(r3)
8112b190:	89000015 	stw	r4,0(r17)
8112b194:	1c400015 	stw	r17,0(r3)
8112b198:	dfc00617 	ldw	ra,24(sp)
8112b19c:	dd400517 	ldw	r21,20(sp)
8112b1a0:	dd000417 	ldw	r20,16(sp)
8112b1a4:	dcc00317 	ldw	r19,12(sp)
8112b1a8:	dc800217 	ldw	r18,8(sp)
8112b1ac:	dc400117 	ldw	r17,4(sp)
8112b1b0:	dc000017 	ldw	r16,0(sp)
8112b1b4:	dec00704 	addi	sp,sp,28
8112b1b8:	f800283a 	ret
8112b1bc:	21400017 	ldw	r5,0(r4)
8112b1c0:	18c00104 	addi	r3,r3,4
8112b1c4:	21000104 	addi	r4,r4,4
8112b1c8:	197fff15 	stw	r5,-4(r3)
8112b1cc:	223ffb36 	bltu	r4,r8,8112b1bc <__reset+0xfb10b1bc>
8112b1d0:	003fe606 	br	8112b16c <__reset+0xfb10b16c>
8112b1d4:	9c000084 	addi	r16,r19,2
8112b1d8:	003fe406 	br	8112b16c <__reset+0xfb10b16c>

8112b1dc <__mcmp>:
8112b1dc:	20800417 	ldw	r2,16(r4)
8112b1e0:	28c00417 	ldw	r3,16(r5)
8112b1e4:	10c5c83a 	sub	r2,r2,r3
8112b1e8:	1000111e 	bne	r2,zero,8112b230 <__mcmp+0x54>
8112b1ec:	18c7883a 	add	r3,r3,r3
8112b1f0:	18c7883a 	add	r3,r3,r3
8112b1f4:	21000504 	addi	r4,r4,20
8112b1f8:	29400504 	addi	r5,r5,20
8112b1fc:	20c5883a 	add	r2,r4,r3
8112b200:	28cb883a 	add	r5,r5,r3
8112b204:	00000106 	br	8112b20c <__mcmp+0x30>
8112b208:	20800a2e 	bgeu	r4,r2,8112b234 <__mcmp+0x58>
8112b20c:	10bfff04 	addi	r2,r2,-4
8112b210:	297fff04 	addi	r5,r5,-4
8112b214:	11800017 	ldw	r6,0(r2)
8112b218:	28c00017 	ldw	r3,0(r5)
8112b21c:	30fffa26 	beq	r6,r3,8112b208 <__reset+0xfb10b208>
8112b220:	30c00236 	bltu	r6,r3,8112b22c <__mcmp+0x50>
8112b224:	00800044 	movi	r2,1
8112b228:	f800283a 	ret
8112b22c:	00bfffc4 	movi	r2,-1
8112b230:	f800283a 	ret
8112b234:	0005883a 	mov	r2,zero
8112b238:	f800283a 	ret

8112b23c <__mdiff>:
8112b23c:	defffa04 	addi	sp,sp,-24
8112b240:	de00012e 	bgeu	sp,et,8112b248 <__mdiff+0xc>
8112b244:	003b68fa 	trap	3
8112b248:	28c00417 	ldw	r3,16(r5)
8112b24c:	30800417 	ldw	r2,16(r6)
8112b250:	dcc00315 	stw	r19,12(sp)
8112b254:	dc800215 	stw	r18,8(sp)
8112b258:	dfc00515 	stw	ra,20(sp)
8112b25c:	dd000415 	stw	r20,16(sp)
8112b260:	dc400115 	stw	r17,4(sp)
8112b264:	dc000015 	stw	r16,0(sp)
8112b268:	1887c83a 	sub	r3,r3,r2
8112b26c:	2825883a 	mov	r18,r5
8112b270:	3027883a 	mov	r19,r6
8112b274:	1800141e 	bne	r3,zero,8112b2c8 <__mdiff+0x8c>
8112b278:	1085883a 	add	r2,r2,r2
8112b27c:	1085883a 	add	r2,r2,r2
8112b280:	2a000504 	addi	r8,r5,20
8112b284:	34000504 	addi	r16,r6,20
8112b288:	4087883a 	add	r3,r8,r2
8112b28c:	8085883a 	add	r2,r16,r2
8112b290:	00000106 	br	8112b298 <__mdiff+0x5c>
8112b294:	40c0592e 	bgeu	r8,r3,8112b3fc <__mdiff+0x1c0>
8112b298:	18ffff04 	addi	r3,r3,-4
8112b29c:	10bfff04 	addi	r2,r2,-4
8112b2a0:	19c00017 	ldw	r7,0(r3)
8112b2a4:	11400017 	ldw	r5,0(r2)
8112b2a8:	397ffa26 	beq	r7,r5,8112b294 <__reset+0xfb10b294>
8112b2ac:	3940592e 	bgeu	r7,r5,8112b414 <__mdiff+0x1d8>
8112b2b0:	9005883a 	mov	r2,r18
8112b2b4:	4023883a 	mov	r17,r8
8112b2b8:	9825883a 	mov	r18,r19
8112b2bc:	05000044 	movi	r20,1
8112b2c0:	1027883a 	mov	r19,r2
8112b2c4:	00000406 	br	8112b2d8 <__mdiff+0x9c>
8112b2c8:	18005616 	blt	r3,zero,8112b424 <__mdiff+0x1e8>
8112b2cc:	34400504 	addi	r17,r6,20
8112b2d0:	2c000504 	addi	r16,r5,20
8112b2d4:	0029883a 	mov	r20,zero
8112b2d8:	91400117 	ldw	r5,4(r18)
8112b2dc:	112a8dc0 	call	8112a8dc <_Balloc>
8112b2e0:	92400417 	ldw	r9,16(r18)
8112b2e4:	9b000417 	ldw	r12,16(r19)
8112b2e8:	12c00504 	addi	r11,r2,20
8112b2ec:	4a51883a 	add	r8,r9,r9
8112b2f0:	6319883a 	add	r12,r12,r12
8112b2f4:	4211883a 	add	r8,r8,r8
8112b2f8:	6319883a 	add	r12,r12,r12
8112b2fc:	15000315 	stw	r20,12(r2)
8112b300:	8211883a 	add	r8,r16,r8
8112b304:	8b19883a 	add	r12,r17,r12
8112b308:	0007883a 	mov	r3,zero
8112b30c:	81400017 	ldw	r5,0(r16)
8112b310:	89c00017 	ldw	r7,0(r17)
8112b314:	59800104 	addi	r6,r11,4
8112b318:	293fffcc 	andi	r4,r5,65535
8112b31c:	20c7883a 	add	r3,r4,r3
8112b320:	393fffcc 	andi	r4,r7,65535
8112b324:	1909c83a 	sub	r4,r3,r4
8112b328:	280ad43a 	srli	r5,r5,16
8112b32c:	380ed43a 	srli	r7,r7,16
8112b330:	2007d43a 	srai	r3,r4,16
8112b334:	213fffcc 	andi	r4,r4,65535
8112b338:	29cbc83a 	sub	r5,r5,r7
8112b33c:	28c7883a 	add	r3,r5,r3
8112b340:	180a943a 	slli	r5,r3,16
8112b344:	8c400104 	addi	r17,r17,4
8112b348:	84000104 	addi	r16,r16,4
8112b34c:	2908b03a 	or	r4,r5,r4
8112b350:	59000015 	stw	r4,0(r11)
8112b354:	1807d43a 	srai	r3,r3,16
8112b358:	3015883a 	mov	r10,r6
8112b35c:	3017883a 	mov	r11,r6
8112b360:	8b3fea36 	bltu	r17,r12,8112b30c <__reset+0xfb10b30c>
8112b364:	8200162e 	bgeu	r16,r8,8112b3c0 <__mdiff+0x184>
8112b368:	8017883a 	mov	r11,r16
8112b36c:	59400017 	ldw	r5,0(r11)
8112b370:	31800104 	addi	r6,r6,4
8112b374:	5ac00104 	addi	r11,r11,4
8112b378:	293fffcc 	andi	r4,r5,65535
8112b37c:	20c7883a 	add	r3,r4,r3
8112b380:	280ed43a 	srli	r7,r5,16
8112b384:	180bd43a 	srai	r5,r3,16
8112b388:	193fffcc 	andi	r4,r3,65535
8112b38c:	3947883a 	add	r3,r7,r5
8112b390:	180a943a 	slli	r5,r3,16
8112b394:	1807d43a 	srai	r3,r3,16
8112b398:	2908b03a 	or	r4,r5,r4
8112b39c:	313fff15 	stw	r4,-4(r6)
8112b3a0:	5a3ff236 	bltu	r11,r8,8112b36c <__reset+0xfb10b36c>
8112b3a4:	0406303a 	nor	r3,zero,r16
8112b3a8:	1a07883a 	add	r3,r3,r8
8112b3ac:	1806d0ba 	srli	r3,r3,2
8112b3b0:	18c00044 	addi	r3,r3,1
8112b3b4:	18c7883a 	add	r3,r3,r3
8112b3b8:	18c7883a 	add	r3,r3,r3
8112b3bc:	50d5883a 	add	r10,r10,r3
8112b3c0:	50ffff04 	addi	r3,r10,-4
8112b3c4:	2000041e 	bne	r4,zero,8112b3d8 <__mdiff+0x19c>
8112b3c8:	18ffff04 	addi	r3,r3,-4
8112b3cc:	19000017 	ldw	r4,0(r3)
8112b3d0:	4a7fffc4 	addi	r9,r9,-1
8112b3d4:	203ffc26 	beq	r4,zero,8112b3c8 <__reset+0xfb10b3c8>
8112b3d8:	12400415 	stw	r9,16(r2)
8112b3dc:	dfc00517 	ldw	ra,20(sp)
8112b3e0:	dd000417 	ldw	r20,16(sp)
8112b3e4:	dcc00317 	ldw	r19,12(sp)
8112b3e8:	dc800217 	ldw	r18,8(sp)
8112b3ec:	dc400117 	ldw	r17,4(sp)
8112b3f0:	dc000017 	ldw	r16,0(sp)
8112b3f4:	dec00604 	addi	sp,sp,24
8112b3f8:	f800283a 	ret
8112b3fc:	000b883a 	mov	r5,zero
8112b400:	112a8dc0 	call	8112a8dc <_Balloc>
8112b404:	00c00044 	movi	r3,1
8112b408:	10c00415 	stw	r3,16(r2)
8112b40c:	10000515 	stw	zero,20(r2)
8112b410:	003ff206 	br	8112b3dc <__reset+0xfb10b3dc>
8112b414:	8023883a 	mov	r17,r16
8112b418:	0029883a 	mov	r20,zero
8112b41c:	4021883a 	mov	r16,r8
8112b420:	003fad06 	br	8112b2d8 <__reset+0xfb10b2d8>
8112b424:	9005883a 	mov	r2,r18
8112b428:	94400504 	addi	r17,r18,20
8112b42c:	9c000504 	addi	r16,r19,20
8112b430:	9825883a 	mov	r18,r19
8112b434:	05000044 	movi	r20,1
8112b438:	1027883a 	mov	r19,r2
8112b43c:	003fa606 	br	8112b2d8 <__reset+0xfb10b2d8>

8112b440 <__ulp>:
8112b440:	295ffc2c 	andhi	r5,r5,32752
8112b444:	00bf3034 	movhi	r2,64704
8112b448:	2887883a 	add	r3,r5,r2
8112b44c:	00c0020e 	bge	zero,r3,8112b458 <__ulp+0x18>
8112b450:	0005883a 	mov	r2,zero
8112b454:	f800283a 	ret
8112b458:	00c7c83a 	sub	r3,zero,r3
8112b45c:	1807d53a 	srai	r3,r3,20
8112b460:	008004c4 	movi	r2,19
8112b464:	10c00b0e 	bge	r2,r3,8112b494 <__ulp+0x54>
8112b468:	18bffb04 	addi	r2,r3,-20
8112b46c:	01000784 	movi	r4,30
8112b470:	0007883a 	mov	r3,zero
8112b474:	20800516 	blt	r4,r2,8112b48c <__ulp+0x4c>
8112b478:	010007c4 	movi	r4,31
8112b47c:	2089c83a 	sub	r4,r4,r2
8112b480:	00800044 	movi	r2,1
8112b484:	1104983a 	sll	r2,r2,r4
8112b488:	f800283a 	ret
8112b48c:	00800044 	movi	r2,1
8112b490:	f800283a 	ret
8112b494:	01400234 	movhi	r5,8
8112b498:	28c7d83a 	sra	r3,r5,r3
8112b49c:	0005883a 	mov	r2,zero
8112b4a0:	f800283a 	ret

8112b4a4 <__b2d>:
8112b4a4:	defffa04 	addi	sp,sp,-24
8112b4a8:	de00012e 	bgeu	sp,et,8112b4b0 <__b2d+0xc>
8112b4ac:	003b68fa 	trap	3
8112b4b0:	dc000015 	stw	r16,0(sp)
8112b4b4:	24000417 	ldw	r16,16(r4)
8112b4b8:	dc400115 	stw	r17,4(sp)
8112b4bc:	24400504 	addi	r17,r4,20
8112b4c0:	8421883a 	add	r16,r16,r16
8112b4c4:	8421883a 	add	r16,r16,r16
8112b4c8:	8c21883a 	add	r16,r17,r16
8112b4cc:	dc800215 	stw	r18,8(sp)
8112b4d0:	84bfff17 	ldw	r18,-4(r16)
8112b4d4:	dd000415 	stw	r20,16(sp)
8112b4d8:	dcc00315 	stw	r19,12(sp)
8112b4dc:	9009883a 	mov	r4,r18
8112b4e0:	2829883a 	mov	r20,r5
8112b4e4:	dfc00515 	stw	ra,20(sp)
8112b4e8:	112abe80 	call	8112abe8 <__hi0bits>
8112b4ec:	00c00804 	movi	r3,32
8112b4f0:	1889c83a 	sub	r4,r3,r2
8112b4f4:	a1000015 	stw	r4,0(r20)
8112b4f8:	01000284 	movi	r4,10
8112b4fc:	84ffff04 	addi	r19,r16,-4
8112b500:	20801216 	blt	r4,r2,8112b54c <__b2d+0xa8>
8112b504:	018002c4 	movi	r6,11
8112b508:	308dc83a 	sub	r6,r6,r2
8112b50c:	9186d83a 	srl	r3,r18,r6
8112b510:	18cffc34 	orhi	r3,r3,16368
8112b514:	8cc0212e 	bgeu	r17,r19,8112b59c <__b2d+0xf8>
8112b518:	813ffe17 	ldw	r4,-8(r16)
8112b51c:	218cd83a 	srl	r6,r4,r6
8112b520:	10800544 	addi	r2,r2,21
8112b524:	9084983a 	sll	r2,r18,r2
8112b528:	1184b03a 	or	r2,r2,r6
8112b52c:	dfc00517 	ldw	ra,20(sp)
8112b530:	dd000417 	ldw	r20,16(sp)
8112b534:	dcc00317 	ldw	r19,12(sp)
8112b538:	dc800217 	ldw	r18,8(sp)
8112b53c:	dc400117 	ldw	r17,4(sp)
8112b540:	dc000017 	ldw	r16,0(sp)
8112b544:	dec00604 	addi	sp,sp,24
8112b548:	f800283a 	ret
8112b54c:	8cc00f2e 	bgeu	r17,r19,8112b58c <__b2d+0xe8>
8112b550:	117ffd44 	addi	r5,r2,-11
8112b554:	80bffe17 	ldw	r2,-8(r16)
8112b558:	28000e26 	beq	r5,zero,8112b594 <__b2d+0xf0>
8112b55c:	1949c83a 	sub	r4,r3,r5
8112b560:	9164983a 	sll	r18,r18,r5
8112b564:	1106d83a 	srl	r3,r2,r4
8112b568:	81bffe04 	addi	r6,r16,-8
8112b56c:	948ffc34 	orhi	r18,r18,16368
8112b570:	90c6b03a 	or	r3,r18,r3
8112b574:	89800e2e 	bgeu	r17,r6,8112b5b0 <__b2d+0x10c>
8112b578:	81bffd17 	ldw	r6,-12(r16)
8112b57c:	1144983a 	sll	r2,r2,r5
8112b580:	310ad83a 	srl	r5,r6,r4
8112b584:	2884b03a 	or	r2,r5,r2
8112b588:	003fe806 	br	8112b52c <__reset+0xfb10b52c>
8112b58c:	10bffd44 	addi	r2,r2,-11
8112b590:	1000041e 	bne	r2,zero,8112b5a4 <__b2d+0x100>
8112b594:	90cffc34 	orhi	r3,r18,16368
8112b598:	003fe406 	br	8112b52c <__reset+0xfb10b52c>
8112b59c:	000d883a 	mov	r6,zero
8112b5a0:	003fdf06 	br	8112b520 <__reset+0xfb10b520>
8112b5a4:	90a4983a 	sll	r18,r18,r2
8112b5a8:	0005883a 	mov	r2,zero
8112b5ac:	003ff906 	br	8112b594 <__reset+0xfb10b594>
8112b5b0:	1144983a 	sll	r2,r2,r5
8112b5b4:	003fdd06 	br	8112b52c <__reset+0xfb10b52c>

8112b5b8 <__d2b>:
8112b5b8:	defff804 	addi	sp,sp,-32
8112b5bc:	de00012e 	bgeu	sp,et,8112b5c4 <__d2b+0xc>
8112b5c0:	003b68fa 	trap	3
8112b5c4:	dc000215 	stw	r16,8(sp)
8112b5c8:	3021883a 	mov	r16,r6
8112b5cc:	dc400315 	stw	r17,12(sp)
8112b5d0:	8022907a 	slli	r17,r16,1
8112b5d4:	dd000615 	stw	r20,24(sp)
8112b5d8:	2829883a 	mov	r20,r5
8112b5dc:	01400044 	movi	r5,1
8112b5e0:	dcc00515 	stw	r19,20(sp)
8112b5e4:	dc800415 	stw	r18,16(sp)
8112b5e8:	dfc00715 	stw	ra,28(sp)
8112b5ec:	3825883a 	mov	r18,r7
8112b5f0:	8822d57a 	srli	r17,r17,21
8112b5f4:	112a8dc0 	call	8112a8dc <_Balloc>
8112b5f8:	1027883a 	mov	r19,r2
8112b5fc:	00800434 	movhi	r2,16
8112b600:	10bfffc4 	addi	r2,r2,-1
8112b604:	808c703a 	and	r6,r16,r2
8112b608:	88000126 	beq	r17,zero,8112b610 <__d2b+0x58>
8112b60c:	31800434 	orhi	r6,r6,16
8112b610:	d9800015 	stw	r6,0(sp)
8112b614:	a0002426 	beq	r20,zero,8112b6a8 <__d2b+0xf0>
8112b618:	d9000104 	addi	r4,sp,4
8112b61c:	dd000115 	stw	r20,4(sp)
8112b620:	112ac500 	call	8112ac50 <__lo0bits>
8112b624:	d8c00017 	ldw	r3,0(sp)
8112b628:	10002f1e 	bne	r2,zero,8112b6e8 <__d2b+0x130>
8112b62c:	d9000117 	ldw	r4,4(sp)
8112b630:	99000515 	stw	r4,20(r19)
8112b634:	1821003a 	cmpeq	r16,r3,zero
8112b638:	01000084 	movi	r4,2
8112b63c:	2421c83a 	sub	r16,r4,r16
8112b640:	98c00615 	stw	r3,24(r19)
8112b644:	9c000415 	stw	r16,16(r19)
8112b648:	88001f1e 	bne	r17,zero,8112b6c8 <__d2b+0x110>
8112b64c:	10bef384 	addi	r2,r2,-1074
8112b650:	90800015 	stw	r2,0(r18)
8112b654:	00900034 	movhi	r2,16384
8112b658:	10bfffc4 	addi	r2,r2,-1
8112b65c:	8085883a 	add	r2,r16,r2
8112b660:	1085883a 	add	r2,r2,r2
8112b664:	1085883a 	add	r2,r2,r2
8112b668:	9885883a 	add	r2,r19,r2
8112b66c:	11000517 	ldw	r4,20(r2)
8112b670:	8020917a 	slli	r16,r16,5
8112b674:	112abe80 	call	8112abe8 <__hi0bits>
8112b678:	d8c00817 	ldw	r3,32(sp)
8112b67c:	8085c83a 	sub	r2,r16,r2
8112b680:	18800015 	stw	r2,0(r3)
8112b684:	9805883a 	mov	r2,r19
8112b688:	dfc00717 	ldw	ra,28(sp)
8112b68c:	dd000617 	ldw	r20,24(sp)
8112b690:	dcc00517 	ldw	r19,20(sp)
8112b694:	dc800417 	ldw	r18,16(sp)
8112b698:	dc400317 	ldw	r17,12(sp)
8112b69c:	dc000217 	ldw	r16,8(sp)
8112b6a0:	dec00804 	addi	sp,sp,32
8112b6a4:	f800283a 	ret
8112b6a8:	d809883a 	mov	r4,sp
8112b6ac:	112ac500 	call	8112ac50 <__lo0bits>
8112b6b0:	d8c00017 	ldw	r3,0(sp)
8112b6b4:	04000044 	movi	r16,1
8112b6b8:	9c000415 	stw	r16,16(r19)
8112b6bc:	98c00515 	stw	r3,20(r19)
8112b6c0:	10800804 	addi	r2,r2,32
8112b6c4:	883fe126 	beq	r17,zero,8112b64c <__reset+0xfb10b64c>
8112b6c8:	00c00d44 	movi	r3,53
8112b6cc:	8c7ef344 	addi	r17,r17,-1075
8112b6d0:	88a3883a 	add	r17,r17,r2
8112b6d4:	1885c83a 	sub	r2,r3,r2
8112b6d8:	d8c00817 	ldw	r3,32(sp)
8112b6dc:	94400015 	stw	r17,0(r18)
8112b6e0:	18800015 	stw	r2,0(r3)
8112b6e4:	003fe706 	br	8112b684 <__reset+0xfb10b684>
8112b6e8:	01000804 	movi	r4,32
8112b6ec:	2089c83a 	sub	r4,r4,r2
8112b6f0:	1908983a 	sll	r4,r3,r4
8112b6f4:	d9400117 	ldw	r5,4(sp)
8112b6f8:	1886d83a 	srl	r3,r3,r2
8112b6fc:	2148b03a 	or	r4,r4,r5
8112b700:	99000515 	stw	r4,20(r19)
8112b704:	d8c00015 	stw	r3,0(sp)
8112b708:	003fca06 	br	8112b634 <__reset+0xfb10b634>

8112b70c <__ratio>:
8112b70c:	defff904 	addi	sp,sp,-28
8112b710:	de00012e 	bgeu	sp,et,8112b718 <__ratio+0xc>
8112b714:	003b68fa 	trap	3
8112b718:	dc400315 	stw	r17,12(sp)
8112b71c:	2823883a 	mov	r17,r5
8112b720:	d9400104 	addi	r5,sp,4
8112b724:	dfc00615 	stw	ra,24(sp)
8112b728:	dcc00515 	stw	r19,20(sp)
8112b72c:	dc800415 	stw	r18,16(sp)
8112b730:	2027883a 	mov	r19,r4
8112b734:	dc000215 	stw	r16,8(sp)
8112b738:	112b4a40 	call	8112b4a4 <__b2d>
8112b73c:	d80b883a 	mov	r5,sp
8112b740:	8809883a 	mov	r4,r17
8112b744:	1025883a 	mov	r18,r2
8112b748:	1821883a 	mov	r16,r3
8112b74c:	112b4a40 	call	8112b4a4 <__b2d>
8112b750:	8a000417 	ldw	r8,16(r17)
8112b754:	99000417 	ldw	r4,16(r19)
8112b758:	d9400117 	ldw	r5,4(sp)
8112b75c:	2209c83a 	sub	r4,r4,r8
8112b760:	2010917a 	slli	r8,r4,5
8112b764:	d9000017 	ldw	r4,0(sp)
8112b768:	2909c83a 	sub	r4,r5,r4
8112b76c:	4109883a 	add	r4,r8,r4
8112b770:	01000e0e 	bge	zero,r4,8112b7ac <__ratio+0xa0>
8112b774:	2008953a 	slli	r4,r4,20
8112b778:	2421883a 	add	r16,r4,r16
8112b77c:	100d883a 	mov	r6,r2
8112b780:	180f883a 	mov	r7,r3
8112b784:	9009883a 	mov	r4,r18
8112b788:	800b883a 	mov	r5,r16
8112b78c:	11337840 	call	81133784 <__divdf3>
8112b790:	dfc00617 	ldw	ra,24(sp)
8112b794:	dcc00517 	ldw	r19,20(sp)
8112b798:	dc800417 	ldw	r18,16(sp)
8112b79c:	dc400317 	ldw	r17,12(sp)
8112b7a0:	dc000217 	ldw	r16,8(sp)
8112b7a4:	dec00704 	addi	sp,sp,28
8112b7a8:	f800283a 	ret
8112b7ac:	2008953a 	slli	r4,r4,20
8112b7b0:	1907c83a 	sub	r3,r3,r4
8112b7b4:	003ff106 	br	8112b77c <__reset+0xfb10b77c>

8112b7b8 <_mprec_log10>:
8112b7b8:	defffe04 	addi	sp,sp,-8
8112b7bc:	de00012e 	bgeu	sp,et,8112b7c4 <_mprec_log10+0xc>
8112b7c0:	003b68fa 	trap	3
8112b7c4:	008005c4 	movi	r2,23
8112b7c8:	dc000015 	stw	r16,0(sp)
8112b7cc:	dfc00115 	stw	ra,4(sp)
8112b7d0:	2021883a 	mov	r16,r4
8112b7d4:	11000d0e 	bge	r2,r4,8112b80c <_mprec_log10+0x54>
8112b7d8:	0005883a 	mov	r2,zero
8112b7dc:	00cffc34 	movhi	r3,16368
8112b7e0:	843fffc4 	addi	r16,r16,-1
8112b7e4:	000d883a 	mov	r6,zero
8112b7e8:	01d00934 	movhi	r7,16420
8112b7ec:	1009883a 	mov	r4,r2
8112b7f0:	180b883a 	mov	r5,r3
8112b7f4:	111dff40 	call	8111dff4 <__muldf3>
8112b7f8:	803ff91e 	bne	r16,zero,8112b7e0 <__reset+0xfb10b7e0>
8112b7fc:	dfc00117 	ldw	ra,4(sp)
8112b800:	dc000017 	ldw	r16,0(sp)
8112b804:	dec00204 	addi	sp,sp,8
8112b808:	f800283a 	ret
8112b80c:	202090fa 	slli	r16,r4,3
8112b810:	00a04574 	movhi	r2,33045
8112b814:	10b93704 	addi	r2,r2,-6948
8112b818:	1421883a 	add	r16,r2,r16
8112b81c:	80800017 	ldw	r2,0(r16)
8112b820:	80c00117 	ldw	r3,4(r16)
8112b824:	dfc00117 	ldw	ra,4(sp)
8112b828:	dc000017 	ldw	r16,0(sp)
8112b82c:	dec00204 	addi	sp,sp,8
8112b830:	f800283a 	ret

8112b834 <__copybits>:
8112b834:	297fffc4 	addi	r5,r5,-1
8112b838:	280fd17a 	srai	r7,r5,5
8112b83c:	30c00417 	ldw	r3,16(r6)
8112b840:	30800504 	addi	r2,r6,20
8112b844:	39c00044 	addi	r7,r7,1
8112b848:	18c7883a 	add	r3,r3,r3
8112b84c:	39cf883a 	add	r7,r7,r7
8112b850:	18c7883a 	add	r3,r3,r3
8112b854:	39cf883a 	add	r7,r7,r7
8112b858:	10c7883a 	add	r3,r2,r3
8112b85c:	21cf883a 	add	r7,r4,r7
8112b860:	10c00d2e 	bgeu	r2,r3,8112b898 <__copybits+0x64>
8112b864:	200b883a 	mov	r5,r4
8112b868:	12000017 	ldw	r8,0(r2)
8112b86c:	29400104 	addi	r5,r5,4
8112b870:	10800104 	addi	r2,r2,4
8112b874:	2a3fff15 	stw	r8,-4(r5)
8112b878:	10fffb36 	bltu	r2,r3,8112b868 <__reset+0xfb10b868>
8112b87c:	1985c83a 	sub	r2,r3,r6
8112b880:	10bffac4 	addi	r2,r2,-21
8112b884:	1004d0ba 	srli	r2,r2,2
8112b888:	10800044 	addi	r2,r2,1
8112b88c:	1085883a 	add	r2,r2,r2
8112b890:	1085883a 	add	r2,r2,r2
8112b894:	2089883a 	add	r4,r4,r2
8112b898:	21c0032e 	bgeu	r4,r7,8112b8a8 <__copybits+0x74>
8112b89c:	20000015 	stw	zero,0(r4)
8112b8a0:	21000104 	addi	r4,r4,4
8112b8a4:	21fffd36 	bltu	r4,r7,8112b89c <__reset+0xfb10b89c>
8112b8a8:	f800283a 	ret

8112b8ac <__any_on>:
8112b8ac:	20c00417 	ldw	r3,16(r4)
8112b8b0:	2805d17a 	srai	r2,r5,5
8112b8b4:	21000504 	addi	r4,r4,20
8112b8b8:	18800d0e 	bge	r3,r2,8112b8f0 <__any_on+0x44>
8112b8bc:	18c7883a 	add	r3,r3,r3
8112b8c0:	18c7883a 	add	r3,r3,r3
8112b8c4:	20c7883a 	add	r3,r4,r3
8112b8c8:	20c0192e 	bgeu	r4,r3,8112b930 <__any_on+0x84>
8112b8cc:	18bfff17 	ldw	r2,-4(r3)
8112b8d0:	18ffff04 	addi	r3,r3,-4
8112b8d4:	1000041e 	bne	r2,zero,8112b8e8 <__any_on+0x3c>
8112b8d8:	20c0142e 	bgeu	r4,r3,8112b92c <__any_on+0x80>
8112b8dc:	18ffff04 	addi	r3,r3,-4
8112b8e0:	19400017 	ldw	r5,0(r3)
8112b8e4:	283ffc26 	beq	r5,zero,8112b8d8 <__reset+0xfb10b8d8>
8112b8e8:	00800044 	movi	r2,1
8112b8ec:	f800283a 	ret
8112b8f0:	10c00a0e 	bge	r2,r3,8112b91c <__any_on+0x70>
8112b8f4:	1085883a 	add	r2,r2,r2
8112b8f8:	1085883a 	add	r2,r2,r2
8112b8fc:	294007cc 	andi	r5,r5,31
8112b900:	2087883a 	add	r3,r4,r2
8112b904:	283ff026 	beq	r5,zero,8112b8c8 <__reset+0xfb10b8c8>
8112b908:	19800017 	ldw	r6,0(r3)
8112b90c:	3144d83a 	srl	r2,r6,r5
8112b910:	114a983a 	sll	r5,r2,r5
8112b914:	317ff41e 	bne	r6,r5,8112b8e8 <__reset+0xfb10b8e8>
8112b918:	003feb06 	br	8112b8c8 <__reset+0xfb10b8c8>
8112b91c:	1085883a 	add	r2,r2,r2
8112b920:	1085883a 	add	r2,r2,r2
8112b924:	2087883a 	add	r3,r4,r2
8112b928:	003fe706 	br	8112b8c8 <__reset+0xfb10b8c8>
8112b92c:	f800283a 	ret
8112b930:	0005883a 	mov	r2,zero
8112b934:	f800283a 	ret

8112b938 <_read_r>:
8112b938:	defffd04 	addi	sp,sp,-12
8112b93c:	de00012e 	bgeu	sp,et,8112b944 <_read_r+0xc>
8112b940:	003b68fa 	trap	3
8112b944:	2805883a 	mov	r2,r5
8112b948:	dc000015 	stw	r16,0(sp)
8112b94c:	04204574 	movhi	r16,33045
8112b950:	dc400115 	stw	r17,4(sp)
8112b954:	300b883a 	mov	r5,r6
8112b958:	84033804 	addi	r16,r16,3296
8112b95c:	2023883a 	mov	r17,r4
8112b960:	380d883a 	mov	r6,r7
8112b964:	1009883a 	mov	r4,r2
8112b968:	dfc00215 	stw	ra,8(sp)
8112b96c:	80000015 	stw	zero,0(r16)
8112b970:	11358f40 	call	811358f4 <read>
8112b974:	00ffffc4 	movi	r3,-1
8112b978:	10c00526 	beq	r2,r3,8112b990 <_read_r+0x58>
8112b97c:	dfc00217 	ldw	ra,8(sp)
8112b980:	dc400117 	ldw	r17,4(sp)
8112b984:	dc000017 	ldw	r16,0(sp)
8112b988:	dec00304 	addi	sp,sp,12
8112b98c:	f800283a 	ret
8112b990:	80c00017 	ldw	r3,0(r16)
8112b994:	183ff926 	beq	r3,zero,8112b97c <__reset+0xfb10b97c>
8112b998:	88c00015 	stw	r3,0(r17)
8112b99c:	003ff706 	br	8112b97c <__reset+0xfb10b97c>

8112b9a0 <_realloc_r>:
8112b9a0:	defff604 	addi	sp,sp,-40
8112b9a4:	de00012e 	bgeu	sp,et,8112b9ac <_realloc_r+0xc>
8112b9a8:	003b68fa 	trap	3
8112b9ac:	dc800215 	stw	r18,8(sp)
8112b9b0:	dfc00915 	stw	ra,36(sp)
8112b9b4:	df000815 	stw	fp,32(sp)
8112b9b8:	ddc00715 	stw	r23,28(sp)
8112b9bc:	dd800615 	stw	r22,24(sp)
8112b9c0:	dd400515 	stw	r21,20(sp)
8112b9c4:	dd000415 	stw	r20,16(sp)
8112b9c8:	dcc00315 	stw	r19,12(sp)
8112b9cc:	dc400115 	stw	r17,4(sp)
8112b9d0:	dc000015 	stw	r16,0(sp)
8112b9d4:	3025883a 	mov	r18,r6
8112b9d8:	2800b726 	beq	r5,zero,8112bcb8 <_realloc_r+0x318>
8112b9dc:	282b883a 	mov	r21,r5
8112b9e0:	2029883a 	mov	r20,r4
8112b9e4:	11360d40 	call	811360d4 <__malloc_lock>
8112b9e8:	a8bfff17 	ldw	r2,-4(r21)
8112b9ec:	043fff04 	movi	r16,-4
8112b9f0:	90c002c4 	addi	r3,r18,11
8112b9f4:	01000584 	movi	r4,22
8112b9f8:	acfffe04 	addi	r19,r21,-8
8112b9fc:	1420703a 	and	r16,r2,r16
8112ba00:	20c0332e 	bgeu	r4,r3,8112bad0 <_realloc_r+0x130>
8112ba04:	047ffe04 	movi	r17,-8
8112ba08:	1c62703a 	and	r17,r3,r17
8112ba0c:	8807883a 	mov	r3,r17
8112ba10:	88005816 	blt	r17,zero,8112bb74 <_realloc_r+0x1d4>
8112ba14:	8c805736 	bltu	r17,r18,8112bb74 <_realloc_r+0x1d4>
8112ba18:	80c0300e 	bge	r16,r3,8112badc <_realloc_r+0x13c>
8112ba1c:	07204574 	movhi	fp,33045
8112ba20:	e73c8404 	addi	fp,fp,-3568
8112ba24:	e1c00217 	ldw	r7,8(fp)
8112ba28:	9c09883a 	add	r4,r19,r16
8112ba2c:	22000117 	ldw	r8,4(r4)
8112ba30:	21c06326 	beq	r4,r7,8112bbc0 <_realloc_r+0x220>
8112ba34:	017fff84 	movi	r5,-2
8112ba38:	414a703a 	and	r5,r8,r5
8112ba3c:	214b883a 	add	r5,r4,r5
8112ba40:	29800117 	ldw	r6,4(r5)
8112ba44:	3180004c 	andi	r6,r6,1
8112ba48:	30003f26 	beq	r6,zero,8112bb48 <_realloc_r+0x1a8>
8112ba4c:	1080004c 	andi	r2,r2,1
8112ba50:	10008326 	beq	r2,zero,8112bc60 <_realloc_r+0x2c0>
8112ba54:	900b883a 	mov	r5,r18
8112ba58:	a009883a 	mov	r4,r20
8112ba5c:	111fe980 	call	8111fe98 <_malloc_r>
8112ba60:	1025883a 	mov	r18,r2
8112ba64:	10011e26 	beq	r2,zero,8112bee0 <_realloc_r+0x540>
8112ba68:	a93fff17 	ldw	r4,-4(r21)
8112ba6c:	10fffe04 	addi	r3,r2,-8
8112ba70:	00bfff84 	movi	r2,-2
8112ba74:	2084703a 	and	r2,r4,r2
8112ba78:	9885883a 	add	r2,r19,r2
8112ba7c:	1880ee26 	beq	r3,r2,8112be38 <_realloc_r+0x498>
8112ba80:	81bfff04 	addi	r6,r16,-4
8112ba84:	00800904 	movi	r2,36
8112ba88:	1180b836 	bltu	r2,r6,8112bd6c <_realloc_r+0x3cc>
8112ba8c:	00c004c4 	movi	r3,19
8112ba90:	19809636 	bltu	r3,r6,8112bcec <_realloc_r+0x34c>
8112ba94:	9005883a 	mov	r2,r18
8112ba98:	a807883a 	mov	r3,r21
8112ba9c:	19000017 	ldw	r4,0(r3)
8112baa0:	11000015 	stw	r4,0(r2)
8112baa4:	19000117 	ldw	r4,4(r3)
8112baa8:	11000115 	stw	r4,4(r2)
8112baac:	18c00217 	ldw	r3,8(r3)
8112bab0:	10c00215 	stw	r3,8(r2)
8112bab4:	a80b883a 	mov	r5,r21
8112bab8:	a009883a 	mov	r4,r20
8112babc:	112990c0 	call	8112990c <_free_r>
8112bac0:	a009883a 	mov	r4,r20
8112bac4:	11361fc0 	call	811361fc <__malloc_unlock>
8112bac8:	9005883a 	mov	r2,r18
8112bacc:	00001206 	br	8112bb18 <_realloc_r+0x178>
8112bad0:	00c00404 	movi	r3,16
8112bad4:	1823883a 	mov	r17,r3
8112bad8:	003fce06 	br	8112ba14 <__reset+0xfb10ba14>
8112badc:	a825883a 	mov	r18,r21
8112bae0:	8445c83a 	sub	r2,r16,r17
8112bae4:	00c003c4 	movi	r3,15
8112bae8:	18802636 	bltu	r3,r2,8112bb84 <_realloc_r+0x1e4>
8112baec:	99800117 	ldw	r6,4(r19)
8112baf0:	9c07883a 	add	r3,r19,r16
8112baf4:	3180004c 	andi	r6,r6,1
8112baf8:	3420b03a 	or	r16,r6,r16
8112bafc:	9c000115 	stw	r16,4(r19)
8112bb00:	18800117 	ldw	r2,4(r3)
8112bb04:	10800054 	ori	r2,r2,1
8112bb08:	18800115 	stw	r2,4(r3)
8112bb0c:	a009883a 	mov	r4,r20
8112bb10:	11361fc0 	call	811361fc <__malloc_unlock>
8112bb14:	9005883a 	mov	r2,r18
8112bb18:	dfc00917 	ldw	ra,36(sp)
8112bb1c:	df000817 	ldw	fp,32(sp)
8112bb20:	ddc00717 	ldw	r23,28(sp)
8112bb24:	dd800617 	ldw	r22,24(sp)
8112bb28:	dd400517 	ldw	r21,20(sp)
8112bb2c:	dd000417 	ldw	r20,16(sp)
8112bb30:	dcc00317 	ldw	r19,12(sp)
8112bb34:	dc800217 	ldw	r18,8(sp)
8112bb38:	dc400117 	ldw	r17,4(sp)
8112bb3c:	dc000017 	ldw	r16,0(sp)
8112bb40:	dec00a04 	addi	sp,sp,40
8112bb44:	f800283a 	ret
8112bb48:	017fff04 	movi	r5,-4
8112bb4c:	414a703a 	and	r5,r8,r5
8112bb50:	814d883a 	add	r6,r16,r5
8112bb54:	30c01f16 	blt	r6,r3,8112bbd4 <_realloc_r+0x234>
8112bb58:	20800317 	ldw	r2,12(r4)
8112bb5c:	20c00217 	ldw	r3,8(r4)
8112bb60:	a825883a 	mov	r18,r21
8112bb64:	3021883a 	mov	r16,r6
8112bb68:	18800315 	stw	r2,12(r3)
8112bb6c:	10c00215 	stw	r3,8(r2)
8112bb70:	003fdb06 	br	8112bae0 <__reset+0xfb10bae0>
8112bb74:	00800304 	movi	r2,12
8112bb78:	a0800015 	stw	r2,0(r20)
8112bb7c:	0005883a 	mov	r2,zero
8112bb80:	003fe506 	br	8112bb18 <__reset+0xfb10bb18>
8112bb84:	98c00117 	ldw	r3,4(r19)
8112bb88:	9c4b883a 	add	r5,r19,r17
8112bb8c:	11000054 	ori	r4,r2,1
8112bb90:	18c0004c 	andi	r3,r3,1
8112bb94:	1c62b03a 	or	r17,r3,r17
8112bb98:	9c400115 	stw	r17,4(r19)
8112bb9c:	29000115 	stw	r4,4(r5)
8112bba0:	2885883a 	add	r2,r5,r2
8112bba4:	10c00117 	ldw	r3,4(r2)
8112bba8:	29400204 	addi	r5,r5,8
8112bbac:	a009883a 	mov	r4,r20
8112bbb0:	18c00054 	ori	r3,r3,1
8112bbb4:	10c00115 	stw	r3,4(r2)
8112bbb8:	112990c0 	call	8112990c <_free_r>
8112bbbc:	003fd306 	br	8112bb0c <__reset+0xfb10bb0c>
8112bbc0:	017fff04 	movi	r5,-4
8112bbc4:	414a703a 	and	r5,r8,r5
8112bbc8:	89800404 	addi	r6,r17,16
8112bbcc:	8151883a 	add	r8,r16,r5
8112bbd0:	4180590e 	bge	r8,r6,8112bd38 <_realloc_r+0x398>
8112bbd4:	1080004c 	andi	r2,r2,1
8112bbd8:	103f9e1e 	bne	r2,zero,8112ba54 <__reset+0xfb10ba54>
8112bbdc:	adbffe17 	ldw	r22,-8(r21)
8112bbe0:	00bfff04 	movi	r2,-4
8112bbe4:	9dadc83a 	sub	r22,r19,r22
8112bbe8:	b1800117 	ldw	r6,4(r22)
8112bbec:	3084703a 	and	r2,r6,r2
8112bbf0:	20002026 	beq	r4,zero,8112bc74 <_realloc_r+0x2d4>
8112bbf4:	80af883a 	add	r23,r16,r2
8112bbf8:	b96f883a 	add	r23,r23,r5
8112bbfc:	21c05f26 	beq	r4,r7,8112bd7c <_realloc_r+0x3dc>
8112bc00:	b8c01c16 	blt	r23,r3,8112bc74 <_realloc_r+0x2d4>
8112bc04:	20800317 	ldw	r2,12(r4)
8112bc08:	20c00217 	ldw	r3,8(r4)
8112bc0c:	81bfff04 	addi	r6,r16,-4
8112bc10:	01000904 	movi	r4,36
8112bc14:	18800315 	stw	r2,12(r3)
8112bc18:	10c00215 	stw	r3,8(r2)
8112bc1c:	b0c00217 	ldw	r3,8(r22)
8112bc20:	b0800317 	ldw	r2,12(r22)
8112bc24:	b4800204 	addi	r18,r22,8
8112bc28:	18800315 	stw	r2,12(r3)
8112bc2c:	10c00215 	stw	r3,8(r2)
8112bc30:	21801b36 	bltu	r4,r6,8112bca0 <_realloc_r+0x300>
8112bc34:	008004c4 	movi	r2,19
8112bc38:	1180352e 	bgeu	r2,r6,8112bd10 <_realloc_r+0x370>
8112bc3c:	a8800017 	ldw	r2,0(r21)
8112bc40:	b0800215 	stw	r2,8(r22)
8112bc44:	a8800117 	ldw	r2,4(r21)
8112bc48:	b0800315 	stw	r2,12(r22)
8112bc4c:	008006c4 	movi	r2,27
8112bc50:	11807f36 	bltu	r2,r6,8112be50 <_realloc_r+0x4b0>
8112bc54:	b0800404 	addi	r2,r22,16
8112bc58:	ad400204 	addi	r21,r21,8
8112bc5c:	00002d06 	br	8112bd14 <_realloc_r+0x374>
8112bc60:	adbffe17 	ldw	r22,-8(r21)
8112bc64:	00bfff04 	movi	r2,-4
8112bc68:	9dadc83a 	sub	r22,r19,r22
8112bc6c:	b1000117 	ldw	r4,4(r22)
8112bc70:	2084703a 	and	r2,r4,r2
8112bc74:	b03f7726 	beq	r22,zero,8112ba54 <__reset+0xfb10ba54>
8112bc78:	80af883a 	add	r23,r16,r2
8112bc7c:	b8ff7516 	blt	r23,r3,8112ba54 <__reset+0xfb10ba54>
8112bc80:	b0800317 	ldw	r2,12(r22)
8112bc84:	b0c00217 	ldw	r3,8(r22)
8112bc88:	81bfff04 	addi	r6,r16,-4
8112bc8c:	01000904 	movi	r4,36
8112bc90:	18800315 	stw	r2,12(r3)
8112bc94:	10c00215 	stw	r3,8(r2)
8112bc98:	b4800204 	addi	r18,r22,8
8112bc9c:	21bfe52e 	bgeu	r4,r6,8112bc34 <__reset+0xfb10bc34>
8112bca0:	a80b883a 	mov	r5,r21
8112bca4:	9009883a 	mov	r4,r18
8112bca8:	112a7800 	call	8112a780 <memmove>
8112bcac:	b821883a 	mov	r16,r23
8112bcb0:	b027883a 	mov	r19,r22
8112bcb4:	003f8a06 	br	8112bae0 <__reset+0xfb10bae0>
8112bcb8:	300b883a 	mov	r5,r6
8112bcbc:	dfc00917 	ldw	ra,36(sp)
8112bcc0:	df000817 	ldw	fp,32(sp)
8112bcc4:	ddc00717 	ldw	r23,28(sp)
8112bcc8:	dd800617 	ldw	r22,24(sp)
8112bccc:	dd400517 	ldw	r21,20(sp)
8112bcd0:	dd000417 	ldw	r20,16(sp)
8112bcd4:	dcc00317 	ldw	r19,12(sp)
8112bcd8:	dc800217 	ldw	r18,8(sp)
8112bcdc:	dc400117 	ldw	r17,4(sp)
8112bce0:	dc000017 	ldw	r16,0(sp)
8112bce4:	dec00a04 	addi	sp,sp,40
8112bce8:	111fe981 	jmpi	8111fe98 <_malloc_r>
8112bcec:	a8c00017 	ldw	r3,0(r21)
8112bcf0:	90c00015 	stw	r3,0(r18)
8112bcf4:	a8c00117 	ldw	r3,4(r21)
8112bcf8:	90c00115 	stw	r3,4(r18)
8112bcfc:	00c006c4 	movi	r3,27
8112bd00:	19804536 	bltu	r3,r6,8112be18 <_realloc_r+0x478>
8112bd04:	90800204 	addi	r2,r18,8
8112bd08:	a8c00204 	addi	r3,r21,8
8112bd0c:	003f6306 	br	8112ba9c <__reset+0xfb10ba9c>
8112bd10:	9005883a 	mov	r2,r18
8112bd14:	a8c00017 	ldw	r3,0(r21)
8112bd18:	b821883a 	mov	r16,r23
8112bd1c:	b027883a 	mov	r19,r22
8112bd20:	10c00015 	stw	r3,0(r2)
8112bd24:	a8c00117 	ldw	r3,4(r21)
8112bd28:	10c00115 	stw	r3,4(r2)
8112bd2c:	a8c00217 	ldw	r3,8(r21)
8112bd30:	10c00215 	stw	r3,8(r2)
8112bd34:	003f6a06 	br	8112bae0 <__reset+0xfb10bae0>
8112bd38:	9c67883a 	add	r19,r19,r17
8112bd3c:	4445c83a 	sub	r2,r8,r17
8112bd40:	e4c00215 	stw	r19,8(fp)
8112bd44:	10800054 	ori	r2,r2,1
8112bd48:	98800115 	stw	r2,4(r19)
8112bd4c:	a8bfff17 	ldw	r2,-4(r21)
8112bd50:	a009883a 	mov	r4,r20
8112bd54:	1080004c 	andi	r2,r2,1
8112bd58:	1462b03a 	or	r17,r2,r17
8112bd5c:	ac7fff15 	stw	r17,-4(r21)
8112bd60:	11361fc0 	call	811361fc <__malloc_unlock>
8112bd64:	a805883a 	mov	r2,r21
8112bd68:	003f6b06 	br	8112bb18 <__reset+0xfb10bb18>
8112bd6c:	a80b883a 	mov	r5,r21
8112bd70:	9009883a 	mov	r4,r18
8112bd74:	112a7800 	call	8112a780 <memmove>
8112bd78:	003f4e06 	br	8112bab4 <__reset+0xfb10bab4>
8112bd7c:	89000404 	addi	r4,r17,16
8112bd80:	b93fbc16 	blt	r23,r4,8112bc74 <__reset+0xfb10bc74>
8112bd84:	b0800317 	ldw	r2,12(r22)
8112bd88:	b0c00217 	ldw	r3,8(r22)
8112bd8c:	81bfff04 	addi	r6,r16,-4
8112bd90:	01000904 	movi	r4,36
8112bd94:	18800315 	stw	r2,12(r3)
8112bd98:	10c00215 	stw	r3,8(r2)
8112bd9c:	b4800204 	addi	r18,r22,8
8112bda0:	21804336 	bltu	r4,r6,8112beb0 <_realloc_r+0x510>
8112bda4:	008004c4 	movi	r2,19
8112bda8:	11803f2e 	bgeu	r2,r6,8112bea8 <_realloc_r+0x508>
8112bdac:	a8800017 	ldw	r2,0(r21)
8112bdb0:	b0800215 	stw	r2,8(r22)
8112bdb4:	a8800117 	ldw	r2,4(r21)
8112bdb8:	b0800315 	stw	r2,12(r22)
8112bdbc:	008006c4 	movi	r2,27
8112bdc0:	11803f36 	bltu	r2,r6,8112bec0 <_realloc_r+0x520>
8112bdc4:	b0800404 	addi	r2,r22,16
8112bdc8:	ad400204 	addi	r21,r21,8
8112bdcc:	a8c00017 	ldw	r3,0(r21)
8112bdd0:	10c00015 	stw	r3,0(r2)
8112bdd4:	a8c00117 	ldw	r3,4(r21)
8112bdd8:	10c00115 	stw	r3,4(r2)
8112bddc:	a8c00217 	ldw	r3,8(r21)
8112bde0:	10c00215 	stw	r3,8(r2)
8112bde4:	b447883a 	add	r3,r22,r17
8112bde8:	bc45c83a 	sub	r2,r23,r17
8112bdec:	e0c00215 	stw	r3,8(fp)
8112bdf0:	10800054 	ori	r2,r2,1
8112bdf4:	18800115 	stw	r2,4(r3)
8112bdf8:	b0800117 	ldw	r2,4(r22)
8112bdfc:	a009883a 	mov	r4,r20
8112be00:	1080004c 	andi	r2,r2,1
8112be04:	1462b03a 	or	r17,r2,r17
8112be08:	b4400115 	stw	r17,4(r22)
8112be0c:	11361fc0 	call	811361fc <__malloc_unlock>
8112be10:	9005883a 	mov	r2,r18
8112be14:	003f4006 	br	8112bb18 <__reset+0xfb10bb18>
8112be18:	a8c00217 	ldw	r3,8(r21)
8112be1c:	90c00215 	stw	r3,8(r18)
8112be20:	a8c00317 	ldw	r3,12(r21)
8112be24:	90c00315 	stw	r3,12(r18)
8112be28:	30801126 	beq	r6,r2,8112be70 <_realloc_r+0x4d0>
8112be2c:	90800404 	addi	r2,r18,16
8112be30:	a8c00404 	addi	r3,r21,16
8112be34:	003f1906 	br	8112ba9c <__reset+0xfb10ba9c>
8112be38:	90ffff17 	ldw	r3,-4(r18)
8112be3c:	00bfff04 	movi	r2,-4
8112be40:	a825883a 	mov	r18,r21
8112be44:	1884703a 	and	r2,r3,r2
8112be48:	80a1883a 	add	r16,r16,r2
8112be4c:	003f2406 	br	8112bae0 <__reset+0xfb10bae0>
8112be50:	a8800217 	ldw	r2,8(r21)
8112be54:	b0800415 	stw	r2,16(r22)
8112be58:	a8800317 	ldw	r2,12(r21)
8112be5c:	b0800515 	stw	r2,20(r22)
8112be60:	31000a26 	beq	r6,r4,8112be8c <_realloc_r+0x4ec>
8112be64:	b0800604 	addi	r2,r22,24
8112be68:	ad400404 	addi	r21,r21,16
8112be6c:	003fa906 	br	8112bd14 <__reset+0xfb10bd14>
8112be70:	a9000417 	ldw	r4,16(r21)
8112be74:	90800604 	addi	r2,r18,24
8112be78:	a8c00604 	addi	r3,r21,24
8112be7c:	91000415 	stw	r4,16(r18)
8112be80:	a9000517 	ldw	r4,20(r21)
8112be84:	91000515 	stw	r4,20(r18)
8112be88:	003f0406 	br	8112ba9c <__reset+0xfb10ba9c>
8112be8c:	a8c00417 	ldw	r3,16(r21)
8112be90:	ad400604 	addi	r21,r21,24
8112be94:	b0800804 	addi	r2,r22,32
8112be98:	b0c00615 	stw	r3,24(r22)
8112be9c:	a8ffff17 	ldw	r3,-4(r21)
8112bea0:	b0c00715 	stw	r3,28(r22)
8112bea4:	003f9b06 	br	8112bd14 <__reset+0xfb10bd14>
8112bea8:	9005883a 	mov	r2,r18
8112beac:	003fc706 	br	8112bdcc <__reset+0xfb10bdcc>
8112beb0:	a80b883a 	mov	r5,r21
8112beb4:	9009883a 	mov	r4,r18
8112beb8:	112a7800 	call	8112a780 <memmove>
8112bebc:	003fc906 	br	8112bde4 <__reset+0xfb10bde4>
8112bec0:	a8800217 	ldw	r2,8(r21)
8112bec4:	b0800415 	stw	r2,16(r22)
8112bec8:	a8800317 	ldw	r2,12(r21)
8112becc:	b0800515 	stw	r2,20(r22)
8112bed0:	31000726 	beq	r6,r4,8112bef0 <_realloc_r+0x550>
8112bed4:	b0800604 	addi	r2,r22,24
8112bed8:	ad400404 	addi	r21,r21,16
8112bedc:	003fbb06 	br	8112bdcc <__reset+0xfb10bdcc>
8112bee0:	a009883a 	mov	r4,r20
8112bee4:	11361fc0 	call	811361fc <__malloc_unlock>
8112bee8:	0005883a 	mov	r2,zero
8112beec:	003f0a06 	br	8112bb18 <__reset+0xfb10bb18>
8112bef0:	a8c00417 	ldw	r3,16(r21)
8112bef4:	ad400604 	addi	r21,r21,24
8112bef8:	b0800804 	addi	r2,r22,32
8112befc:	b0c00615 	stw	r3,24(r22)
8112bf00:	a8ffff17 	ldw	r3,-4(r21)
8112bf04:	b0c00715 	stw	r3,28(r22)
8112bf08:	003fb006 	br	8112bdcc <__reset+0xfb10bdcc>

8112bf0c <__fpclassifyd>:
8112bf0c:	00a00034 	movhi	r2,32768
8112bf10:	10bfffc4 	addi	r2,r2,-1
8112bf14:	2884703a 	and	r2,r5,r2
8112bf18:	10000726 	beq	r2,zero,8112bf38 <__fpclassifyd+0x2c>
8112bf1c:	00fffc34 	movhi	r3,65520
8112bf20:	019ff834 	movhi	r6,32736
8112bf24:	28c7883a 	add	r3,r5,r3
8112bf28:	31bfffc4 	addi	r6,r6,-1
8112bf2c:	30c00536 	bltu	r6,r3,8112bf44 <__fpclassifyd+0x38>
8112bf30:	00800104 	movi	r2,4
8112bf34:	f800283a 	ret
8112bf38:	2000021e 	bne	r4,zero,8112bf44 <__fpclassifyd+0x38>
8112bf3c:	00800084 	movi	r2,2
8112bf40:	f800283a 	ret
8112bf44:	00dffc34 	movhi	r3,32752
8112bf48:	019ff834 	movhi	r6,32736
8112bf4c:	28cb883a 	add	r5,r5,r3
8112bf50:	31bfffc4 	addi	r6,r6,-1
8112bf54:	317ff62e 	bgeu	r6,r5,8112bf30 <__reset+0xfb10bf30>
8112bf58:	01400434 	movhi	r5,16
8112bf5c:	297fffc4 	addi	r5,r5,-1
8112bf60:	28800236 	bltu	r5,r2,8112bf6c <__fpclassifyd+0x60>
8112bf64:	008000c4 	movi	r2,3
8112bf68:	f800283a 	ret
8112bf6c:	10c00226 	beq	r2,r3,8112bf78 <__fpclassifyd+0x6c>
8112bf70:	0005883a 	mov	r2,zero
8112bf74:	f800283a 	ret
8112bf78:	2005003a 	cmpeq	r2,r4,zero
8112bf7c:	f800283a 	ret

8112bf80 <__sccl>:
8112bf80:	2a000003 	ldbu	r8,0(r5)
8112bf84:	00801784 	movi	r2,94
8112bf88:	40802a26 	beq	r8,r2,8112c034 <__sccl+0xb4>
8112bf8c:	29400044 	addi	r5,r5,1
8112bf90:	000f883a 	mov	r7,zero
8112bf94:	0013883a 	mov	r9,zero
8112bf98:	2007883a 	mov	r3,r4
8112bf9c:	21804004 	addi	r6,r4,256
8112bfa0:	19c00005 	stb	r7,0(r3)
8112bfa4:	18c00044 	addi	r3,r3,1
8112bfa8:	19bffd1e 	bne	r3,r6,8112bfa0 <__reset+0xfb10bfa0>
8112bfac:	40001126 	beq	r8,zero,8112bff4 <__sccl+0x74>
8112bfb0:	00800044 	movi	r2,1
8112bfb4:	124fc83a 	sub	r7,r2,r9
8112bfb8:	02800b44 	movi	r10,45
8112bfbc:	02c01744 	movi	r11,93
8112bfc0:	2205883a 	add	r2,r4,r8
8112bfc4:	11c00005 	stb	r7,0(r2)
8112bfc8:	28800044 	addi	r2,r5,1
8112bfcc:	28c00003 	ldbu	r3,0(r5)
8112bfd0:	1a800a26 	beq	r3,r10,8112bffc <__sccl+0x7c>
8112bfd4:	1ac00426 	beq	r3,r11,8112bfe8 <__sccl+0x68>
8112bfd8:	18000426 	beq	r3,zero,8112bfec <__sccl+0x6c>
8112bfdc:	1811883a 	mov	r8,r3
8112bfe0:	100b883a 	mov	r5,r2
8112bfe4:	003ff606 	br	8112bfc0 <__reset+0xfb10bfc0>
8112bfe8:	f800283a 	ret
8112bfec:	2805883a 	mov	r2,r5
8112bff0:	f800283a 	ret
8112bff4:	28bfffc4 	addi	r2,r5,-1
8112bff8:	f800283a 	ret
8112bffc:	12400003 	ldbu	r9,0(r2)
8112c000:	4ac01126 	beq	r9,r11,8112c048 <__sccl+0xc8>
8112c004:	4a001016 	blt	r9,r8,8112c048 <__sccl+0xc8>
8112c008:	41800044 	addi	r6,r8,1
8112c00c:	29400084 	addi	r5,r5,2
8112c010:	2187883a 	add	r3,r4,r6
8112c014:	00000106 	br	8112c01c <__sccl+0x9c>
8112c018:	31800044 	addi	r6,r6,1
8112c01c:	19c00005 	stb	r7,0(r3)
8112c020:	3011883a 	mov	r8,r6
8112c024:	18c00044 	addi	r3,r3,1
8112c028:	327ffb16 	blt	r6,r9,8112c018 <__reset+0xfb10c018>
8112c02c:	10800084 	addi	r2,r2,2
8112c030:	003fe606 	br	8112bfcc <__reset+0xfb10bfcc>
8112c034:	2a000043 	ldbu	r8,1(r5)
8112c038:	01c00044 	movi	r7,1
8112c03c:	29400084 	addi	r5,r5,2
8112c040:	02400044 	movi	r9,1
8112c044:	003fd406 	br	8112bf98 <__reset+0xfb10bf98>
8112c048:	5011883a 	mov	r8,r10
8112c04c:	003fe406 	br	8112bfe0 <__reset+0xfb10bfe0>

8112c050 <nanf>:
8112c050:	009ff034 	movhi	r2,32704
8112c054:	f800283a 	ret

8112c058 <strcmp>:
8112c058:	2144b03a 	or	r2,r4,r5
8112c05c:	108000cc 	andi	r2,r2,3
8112c060:	1000171e 	bne	r2,zero,8112c0c0 <strcmp+0x68>
8112c064:	20800017 	ldw	r2,0(r4)
8112c068:	28c00017 	ldw	r3,0(r5)
8112c06c:	10c0141e 	bne	r2,r3,8112c0c0 <strcmp+0x68>
8112c070:	027fbff4 	movhi	r9,65279
8112c074:	4a7fbfc4 	addi	r9,r9,-257
8112c078:	0086303a 	nor	r3,zero,r2
8112c07c:	02202074 	movhi	r8,32897
8112c080:	1245883a 	add	r2,r2,r9
8112c084:	42202004 	addi	r8,r8,-32640
8112c088:	10c4703a 	and	r2,r2,r3
8112c08c:	1204703a 	and	r2,r2,r8
8112c090:	10000226 	beq	r2,zero,8112c09c <strcmp+0x44>
8112c094:	00002306 	br	8112c124 <strcmp+0xcc>
8112c098:	1000221e 	bne	r2,zero,8112c124 <strcmp+0xcc>
8112c09c:	21000104 	addi	r4,r4,4
8112c0a0:	20c00017 	ldw	r3,0(r4)
8112c0a4:	29400104 	addi	r5,r5,4
8112c0a8:	29800017 	ldw	r6,0(r5)
8112c0ac:	1a4f883a 	add	r7,r3,r9
8112c0b0:	00c4303a 	nor	r2,zero,r3
8112c0b4:	3884703a 	and	r2,r7,r2
8112c0b8:	1204703a 	and	r2,r2,r8
8112c0bc:	19bff626 	beq	r3,r6,8112c098 <__reset+0xfb10c098>
8112c0c0:	20800003 	ldbu	r2,0(r4)
8112c0c4:	10c03fcc 	andi	r3,r2,255
8112c0c8:	18c0201c 	xori	r3,r3,128
8112c0cc:	18ffe004 	addi	r3,r3,-128
8112c0d0:	18000c26 	beq	r3,zero,8112c104 <strcmp+0xac>
8112c0d4:	29800007 	ldb	r6,0(r5)
8112c0d8:	19800326 	beq	r3,r6,8112c0e8 <strcmp+0x90>
8112c0dc:	00001306 	br	8112c12c <strcmp+0xd4>
8112c0e0:	29800007 	ldb	r6,0(r5)
8112c0e4:	11800b1e 	bne	r2,r6,8112c114 <strcmp+0xbc>
8112c0e8:	21000044 	addi	r4,r4,1
8112c0ec:	20c00003 	ldbu	r3,0(r4)
8112c0f0:	29400044 	addi	r5,r5,1
8112c0f4:	18803fcc 	andi	r2,r3,255
8112c0f8:	1080201c 	xori	r2,r2,128
8112c0fc:	10bfe004 	addi	r2,r2,-128
8112c100:	103ff71e 	bne	r2,zero,8112c0e0 <__reset+0xfb10c0e0>
8112c104:	0007883a 	mov	r3,zero
8112c108:	28800003 	ldbu	r2,0(r5)
8112c10c:	1885c83a 	sub	r2,r3,r2
8112c110:	f800283a 	ret
8112c114:	28800003 	ldbu	r2,0(r5)
8112c118:	18c03fcc 	andi	r3,r3,255
8112c11c:	1885c83a 	sub	r2,r3,r2
8112c120:	f800283a 	ret
8112c124:	0005883a 	mov	r2,zero
8112c128:	f800283a 	ret
8112c12c:	10c03fcc 	andi	r3,r2,255
8112c130:	003ff506 	br	8112c108 <__reset+0xfb10c108>

8112c134 <sulp>:
8112c134:	defffd04 	addi	sp,sp,-12
8112c138:	de00012e 	bgeu	sp,et,8112c140 <sulp+0xc>
8112c13c:	003b68fa 	trap	3
8112c140:	dc400115 	stw	r17,4(sp)
8112c144:	3023883a 	mov	r17,r6
8112c148:	dc000015 	stw	r16,0(sp)
8112c14c:	dfc00215 	stw	ra,8(sp)
8112c150:	2821883a 	mov	r16,r5
8112c154:	112b4400 	call	8112b440 <__ulp>
8112c158:	88000c26 	beq	r17,zero,8112c18c <sulp+0x58>
8112c15c:	841ffc2c 	andhi	r16,r16,32752
8112c160:	8020d53a 	srli	r16,r16,20
8112c164:	01c01ac4 	movi	r7,107
8112c168:	3c21c83a 	sub	r16,r7,r16
8112c16c:	0400070e 	bge	zero,r16,8112c18c <sulp+0x58>
8112c170:	8020953a 	slli	r16,r16,20
8112c174:	01cffc34 	movhi	r7,16368
8112c178:	000d883a 	mov	r6,zero
8112c17c:	81cf883a 	add	r7,r16,r7
8112c180:	1009883a 	mov	r4,r2
8112c184:	180b883a 	mov	r5,r3
8112c188:	111dff40 	call	8111dff4 <__muldf3>
8112c18c:	dfc00217 	ldw	ra,8(sp)
8112c190:	dc400117 	ldw	r17,4(sp)
8112c194:	dc000017 	ldw	r16,0(sp)
8112c198:	dec00304 	addi	sp,sp,12
8112c19c:	f800283a 	ret

8112c1a0 <_strtod_r>:
8112c1a0:	deffe204 	addi	sp,sp,-120
8112c1a4:	de00012e 	bgeu	sp,et,8112c1ac <_strtod_r+0xc>
8112c1a8:	003b68fa 	trap	3
8112c1ac:	ddc01b15 	stw	r23,108(sp)
8112c1b0:	dd001815 	stw	r20,96(sp)
8112c1b4:	dc801615 	stw	r18,88(sp)
8112c1b8:	dc401515 	stw	r17,84(sp)
8112c1bc:	dc001415 	stw	r16,80(sp)
8112c1c0:	d9400615 	stw	r5,24(sp)
8112c1c4:	dfc01d15 	stw	ra,116(sp)
8112c1c8:	df001c15 	stw	fp,112(sp)
8112c1cc:	dd801a15 	stw	r22,104(sp)
8112c1d0:	dd401915 	stw	r21,100(sp)
8112c1d4:	dcc01715 	stw	r19,92(sp)
8112c1d8:	2021883a 	mov	r16,r4
8112c1dc:	d8000515 	stw	zero,20(sp)
8112c1e0:	2809883a 	mov	r4,r5
8112c1e4:	20800003 	ldbu	r2,0(r4)
8112c1e8:	01e044f4 	movhi	r7,33043
8112c1ec:	282f883a 	mov	r23,r5
8112c1f0:	10c03fcc 	andi	r3,r2,255
8112c1f4:	01400b44 	movi	r5,45
8112c1f8:	39f08704 	addi	r7,r7,-15844
8112c1fc:	3029883a 	mov	r20,r6
8112c200:	0025883a 	mov	r18,zero
8112c204:	0023883a 	mov	r17,zero
8112c208:	28c0ba36 	bltu	r5,r3,8112c4f4 <_strtod_r+0x354>
8112c20c:	180690ba 	slli	r3,r3,2
8112c210:	19c7883a 	add	r3,r3,r7
8112c214:	18c00017 	ldw	r3,0(r3)
8112c218:	1800683a 	jmp	r3
8112c21c:	8112c2dc 	xori	r4,r16,19211
8112c220:	8112c4f4 	orhi	r4,r16,19219
8112c224:	8112c4f4 	orhi	r4,r16,19219
8112c228:	8112c4f4 	orhi	r4,r16,19219
8112c22c:	8112c4f4 	orhi	r4,r16,19219
8112c230:	8112c4f4 	orhi	r4,r16,19219
8112c234:	8112c4f4 	orhi	r4,r16,19219
8112c238:	8112c4f4 	orhi	r4,r16,19219
8112c23c:	8112c4f4 	orhi	r4,r16,19219
8112c240:	8112c4e0 	cmpeqi	r4,r16,19219
8112c244:	8112c4e0 	cmpeqi	r4,r16,19219
8112c248:	8112c4e0 	cmpeqi	r4,r16,19219
8112c24c:	8112c4e0 	cmpeqi	r4,r16,19219
8112c250:	8112c4e0 	cmpeqi	r4,r16,19219
8112c254:	8112c4f4 	orhi	r4,r16,19219
8112c258:	8112c4f4 	orhi	r4,r16,19219
8112c25c:	8112c4f4 	orhi	r4,r16,19219
8112c260:	8112c4f4 	orhi	r4,r16,19219
8112c264:	8112c4f4 	orhi	r4,r16,19219
8112c268:	8112c4f4 	orhi	r4,r16,19219
8112c26c:	8112c4f4 	orhi	r4,r16,19219
8112c270:	8112c4f4 	orhi	r4,r16,19219
8112c274:	8112c4f4 	orhi	r4,r16,19219
8112c278:	8112c4f4 	orhi	r4,r16,19219
8112c27c:	8112c4f4 	orhi	r4,r16,19219
8112c280:	8112c4f4 	orhi	r4,r16,19219
8112c284:	8112c4f4 	orhi	r4,r16,19219
8112c288:	8112c4f4 	orhi	r4,r16,19219
8112c28c:	8112c4f4 	orhi	r4,r16,19219
8112c290:	8112c4f4 	orhi	r4,r16,19219
8112c294:	8112c4f4 	orhi	r4,r16,19219
8112c298:	8112c4f4 	orhi	r4,r16,19219
8112c29c:	8112c4e0 	cmpeqi	r4,r16,19219
8112c2a0:	8112c4f4 	orhi	r4,r16,19219
8112c2a4:	8112c4f4 	orhi	r4,r16,19219
8112c2a8:	8112c4f4 	orhi	r4,r16,19219
8112c2ac:	8112c4f4 	orhi	r4,r16,19219
8112c2b0:	8112c4f4 	orhi	r4,r16,19219
8112c2b4:	8112c4f4 	orhi	r4,r16,19219
8112c2b8:	8112c4f4 	orhi	r4,r16,19219
8112c2bc:	8112c4f4 	orhi	r4,r16,19219
8112c2c0:	8112c4f4 	orhi	r4,r16,19219
8112c2c4:	8112c4f4 	orhi	r4,r16,19219
8112c2c8:	8112c334 	orhi	r4,r16,19212
8112c2cc:	8112c4f4 	orhi	r4,r16,19219
8112c2d0:	8112c4d4 	ori	r4,r16,19219
8112c2d4:	00801244 	movi	r2,73
8112c2d8:	88843526 	beq	r17,r2,8112d3b0 <_strtod_r+0x1210>
8112c2dc:	002b883a 	mov	r21,zero
8112c2e0:	002d883a 	mov	r22,zero
8112c2e4:	a0000526 	beq	r20,zero,8112c2fc <_strtod_r+0x15c>
8112c2e8:	d8000715 	stw	zero,28(sp)
8112c2ec:	a5c00015 	stw	r23,0(r20)
8112c2f0:	d9000717 	ldw	r4,28(sp)
8112c2f4:	20000126 	beq	r4,zero,8112c2fc <_strtod_r+0x15c>
8112c2f8:	b5a0003c 	xorhi	r22,r22,32768
8112c2fc:	a805883a 	mov	r2,r21
8112c300:	b007883a 	mov	r3,r22
8112c304:	dfc01d17 	ldw	ra,116(sp)
8112c308:	df001c17 	ldw	fp,112(sp)
8112c30c:	ddc01b17 	ldw	r23,108(sp)
8112c310:	dd801a17 	ldw	r22,104(sp)
8112c314:	dd401917 	ldw	r21,100(sp)
8112c318:	dd001817 	ldw	r20,96(sp)
8112c31c:	dcc01717 	ldw	r19,92(sp)
8112c320:	dc801617 	ldw	r18,88(sp)
8112c324:	dc401517 	ldw	r17,84(sp)
8112c328:	dc001417 	ldw	r16,80(sp)
8112c32c:	dec01e04 	addi	sp,sp,120
8112c330:	f800283a 	ret
8112c334:	d8000715 	stw	zero,28(sp)
8112c338:	24c00044 	addi	r19,r4,1
8112c33c:	dcc00615 	stw	r19,24(sp)
8112c340:	20800043 	ldbu	r2,1(r4)
8112c344:	10c03fcc 	andi	r3,r2,255
8112c348:	18c0201c 	xori	r3,r3,128
8112c34c:	18ffe004 	addi	r3,r3,-128
8112c350:	183fe226 	beq	r3,zero,8112c2dc <__reset+0xfb10c2dc>
8112c354:	11403fcc 	andi	r5,r2,255
8112c358:	2940201c 	xori	r5,r5,128
8112c35c:	297fe004 	addi	r5,r5,-128
8112c360:	00c00c04 	movi	r3,48
8112c364:	28c0e526 	beq	r5,r3,8112c6fc <_strtod_r+0x55c>
8112c368:	dcc00815 	stw	r19,32(sp)
8112c36c:	0025883a 	mov	r18,zero
8112c370:	10fff404 	addi	r3,r2,-48
8112c374:	18c03fcc 	andi	r3,r3,255
8112c378:	01000244 	movi	r4,9
8112c37c:	20c37536 	bltu	r4,r3,8112d154 <_strtod_r+0xfb4>
8112c380:	dd400817 	ldw	r21,32(sp)
8112c384:	0027883a 	mov	r19,zero
8112c388:	0039883a 	mov	fp,zero
8112c38c:	002d883a 	mov	r22,zero
8112c390:	01400204 	movi	r5,8
8112c394:	2d805a16 	blt	r5,r22,8112c500 <_strtod_r+0x360>
8112c398:	e70002a4 	muli	fp,fp,10
8112c39c:	10c03fcc 	andi	r3,r2,255
8112c3a0:	18c0201c 	xori	r3,r3,128
8112c3a4:	18ffe004 	addi	r3,r3,-128
8112c3a8:	e0f9883a 	add	fp,fp,r3
8112c3ac:	e73ff404 	addi	fp,fp,-48
8112c3b0:	ad400044 	addi	r21,r21,1
8112c3b4:	dd400615 	stw	r21,24(sp)
8112c3b8:	a8800003 	ldbu	r2,0(r21)
8112c3bc:	b5800044 	addi	r22,r22,1
8112c3c0:	10fff404 	addi	r3,r2,-48
8112c3c4:	18c03fcc 	andi	r3,r3,255
8112c3c8:	20fff22e 	bgeu	r4,r3,8112c394 <__reset+0xfb10c394>
8112c3cc:	14403fcc 	andi	r17,r2,255
8112c3d0:	8c40201c 	xori	r17,r17,128
8112c3d4:	8c7fe004 	addi	r17,r17,-128
8112c3d8:	8009883a 	mov	r4,r16
8112c3dc:	112a3c00 	call	8112a3c0 <_localeconv_r>
8112c3e0:	11400017 	ldw	r5,0(r2)
8112c3e4:	8009883a 	mov	r4,r16
8112c3e8:	d9401315 	stw	r5,76(sp)
8112c3ec:	112a3c00 	call	8112a3c0 <_localeconv_r>
8112c3f0:	11000017 	ldw	r4,0(r2)
8112c3f4:	11211a00 	call	811211a0 <strlen>
8112c3f8:	d9401317 	ldw	r5,76(sp)
8112c3fc:	100d883a 	mov	r6,r2
8112c400:	a809883a 	mov	r4,r21
8112c404:	1131d900 	call	81131d90 <strncmp>
8112c408:	1000ce26 	beq	r2,zero,8112c744 <_strtod_r+0x5a4>
8112c40c:	b013883a 	mov	r9,r22
8112c410:	000b883a 	mov	r5,zero
8112c414:	0015883a 	mov	r10,zero
8112c418:	0017883a 	mov	r11,zero
8112c41c:	00801944 	movi	r2,101
8112c420:	88807826 	beq	r17,r2,8112c604 <_strtod_r+0x464>
8112c424:	00801144 	movi	r2,69
8112c428:	88807626 	beq	r17,r2,8112c604 <_strtod_r+0x464>
8112c42c:	002b883a 	mov	r21,zero
8112c430:	48003d1e 	bne	r9,zero,8112c528 <_strtod_r+0x388>
8112c434:	2800391e 	bne	r5,zero,8112c51c <_strtod_r+0x37c>
8112c438:	9000381e 	bne	r18,zero,8112c51c <_strtod_r+0x37c>
8112c43c:	583fa71e 	bne	r11,zero,8112c2dc <__reset+0xfb10c2dc>
8112c440:	00801384 	movi	r2,78
8112c444:	88800526 	beq	r17,r2,8112c45c <_strtod_r+0x2bc>
8112c448:	147fa20e 	bge	r2,r17,8112c2d4 <__reset+0xfb10c2d4>
8112c44c:	00801a44 	movi	r2,105
8112c450:	8883d726 	beq	r17,r2,8112d3b0 <_strtod_r+0x1210>
8112c454:	00801b84 	movi	r2,110
8112c458:	88bfa01e 	bne	r17,r2,8112c2dc <__reset+0xfb10c2dc>
8112c45c:	01604574 	movhi	r5,33045
8112c460:	d9000617 	ldw	r4,24(sp)
8112c464:	29796c04 	addi	r5,r5,-6736
8112c468:	01c00644 	movi	r7,25
8112c46c:	00000b06 	br	8112c49c <_strtod_r+0x2fc>
8112c470:	21000044 	addi	r4,r4,1
8112c474:	20800003 	ldbu	r2,0(r4)
8112c478:	10ffefc4 	addi	r3,r2,-65
8112c47c:	10803fcc 	andi	r2,r2,255
8112c480:	1080201c 	xori	r2,r2,128
8112c484:	18c03fcc 	andi	r3,r3,255
8112c488:	10bfe004 	addi	r2,r2,-128
8112c48c:	38c00136 	bltu	r7,r3,8112c494 <_strtod_r+0x2f4>
8112c490:	10800804 	addi	r2,r2,32
8112c494:	29400044 	addi	r5,r5,1
8112c498:	11bf901e 	bne	r2,r6,8112c2dc <__reset+0xfb10c2dc>
8112c49c:	29800007 	ldb	r6,0(r5)
8112c4a0:	303ff31e 	bne	r6,zero,8112c470 <__reset+0xfb10c470>
8112c4a4:	20800044 	addi	r2,r4,1
8112c4a8:	d8800615 	stw	r2,24(sp)
8112c4ac:	20c00047 	ldb	r3,1(r4)
8112c4b0:	00800a04 	movi	r2,40
8112c4b4:	18849d26 	beq	r3,r2,8112d72c <_strtod_r+0x158c>
8112c4b8:	047ffe34 	movhi	r17,65528
8112c4bc:	0025883a 	mov	r18,zero
8112c4c0:	902b883a 	mov	r21,r18
8112c4c4:	882d883a 	mov	r22,r17
8112c4c8:	a03f8926 	beq	r20,zero,8112c2f0 <__reset+0xfb10c2f0>
8112c4cc:	ddc00617 	ldw	r23,24(sp)
8112c4d0:	003f8606 	br	8112c2ec <__reset+0xfb10c2ec>
8112c4d4:	00800044 	movi	r2,1
8112c4d8:	d8800715 	stw	r2,28(sp)
8112c4dc:	003f9606 	br	8112c338 <__reset+0xfb10c338>
8112c4e0:	21000044 	addi	r4,r4,1
8112c4e4:	d9000615 	stw	r4,24(sp)
8112c4e8:	20800003 	ldbu	r2,0(r4)
8112c4ec:	10c03fcc 	andi	r3,r2,255
8112c4f0:	28ff462e 	bgeu	r5,r3,8112c20c <__reset+0xfb10c20c>
8112c4f4:	2027883a 	mov	r19,r4
8112c4f8:	d8000715 	stw	zero,28(sp)
8112c4fc:	003f9506 	br	8112c354 <__reset+0xfb10c354>
8112c500:	9cc002a4 	muli	r19,r19,10
8112c504:	10803fcc 	andi	r2,r2,255
8112c508:	1080201c 	xori	r2,r2,128
8112c50c:	10bfe004 	addi	r2,r2,-128
8112c510:	9885883a 	add	r2,r19,r2
8112c514:	14fff404 	addi	r19,r2,-48
8112c518:	003fa506 	br	8112c3b0 <__reset+0xfb10c3b0>
8112c51c:	002b883a 	mov	r21,zero
8112c520:	002d883a 	mov	r22,zero
8112c524:	003fe806 	br	8112c4c8 <__reset+0xfb10c4c8>
8112c528:	aaabc83a 	sub	r21,r21,r10
8112c52c:	b000011e 	bne	r22,zero,8112c534 <_strtod_r+0x394>
8112c530:	482d883a 	mov	r22,r9
8112c534:	00800404 	movi	r2,16
8112c538:	482f883a 	mov	r23,r9
8112c53c:	1240010e 	bge	r2,r9,8112c544 <_strtod_r+0x3a4>
8112c540:	102f883a 	mov	r23,r2
8112c544:	e009883a 	mov	r4,fp
8112c548:	da401315 	stw	r9,76(sp)
8112c54c:	11341f00 	call	811341f0 <__floatunsidf>
8112c550:	1025883a 	mov	r18,r2
8112c554:	00800244 	movi	r2,9
8112c558:	1823883a 	mov	r17,r3
8112c55c:	da401317 	ldw	r9,76(sp)
8112c560:	15c0160e 	bge	r2,r23,8112c5bc <_strtod_r+0x41c>
8112c564:	b8bffdc4 	addi	r2,r23,-9
8112c568:	100490fa 	slli	r2,r2,3
8112c56c:	180b883a 	mov	r5,r3
8112c570:	00e04574 	movhi	r3,33045
8112c574:	18f93704 	addi	r3,r3,-6948
8112c578:	1885883a 	add	r2,r3,r2
8112c57c:	11800017 	ldw	r6,0(r2)
8112c580:	11c00117 	ldw	r7,4(r2)
8112c584:	9009883a 	mov	r4,r18
8112c588:	111dff40 	call	8111dff4 <__muldf3>
8112c58c:	9809883a 	mov	r4,r19
8112c590:	1025883a 	mov	r18,r2
8112c594:	1823883a 	mov	r17,r3
8112c598:	11341f00 	call	811341f0 <__floatunsidf>
8112c59c:	9009883a 	mov	r4,r18
8112c5a0:	880b883a 	mov	r5,r17
8112c5a4:	100d883a 	mov	r6,r2
8112c5a8:	180f883a 	mov	r7,r3
8112c5ac:	1132ed00 	call	81132ed0 <__adddf3>
8112c5b0:	da401317 	ldw	r9,76(sp)
8112c5b4:	1025883a 	mov	r18,r2
8112c5b8:	1823883a 	mov	r17,r3
8112c5bc:	008003c4 	movi	r2,15
8112c5c0:	12407b16 	blt	r2,r9,8112c7b0 <_strtod_r+0x610>
8112c5c4:	a83fbe26 	beq	r21,zero,8112c4c0 <__reset+0xfb10c4c0>
8112c5c8:	0543670e 	bge	zero,r21,8112d368 <_strtod_r+0x11c8>
8112c5cc:	00c00584 	movi	r3,22
8112c5d0:	1d42e816 	blt	r3,r21,8112d174 <_strtod_r+0xfd4>
8112c5d4:	a82a90fa 	slli	r21,r21,3
8112c5d8:	00a04574 	movhi	r2,33045
8112c5dc:	10b93704 	addi	r2,r2,-6948
8112c5e0:	1545883a 	add	r2,r2,r21
8112c5e4:	11000017 	ldw	r4,0(r2)
8112c5e8:	11400117 	ldw	r5,4(r2)
8112c5ec:	900d883a 	mov	r6,r18
8112c5f0:	880f883a 	mov	r7,r17
8112c5f4:	111dff40 	call	8111dff4 <__muldf3>
8112c5f8:	102b883a 	mov	r21,r2
8112c5fc:	182d883a 	mov	r22,r3
8112c600:	003fb106 	br	8112c4c8 <__reset+0xfb10c4c8>
8112c604:	4801b526 	beq	r9,zero,8112ccdc <_strtod_r+0xb3c>
8112c608:	ddc00617 	ldw	r23,24(sp)
8112c60c:	00c00ac4 	movi	r3,43
8112c610:	b8800044 	addi	r2,r23,1
8112c614:	d8800615 	stw	r2,24(sp)
8112c618:	b8800047 	ldb	r2,1(r23)
8112c61c:	10c1e926 	beq	r2,r3,8112cdc4 <_strtod_r+0xc24>
8112c620:	00c00b44 	movi	r3,45
8112c624:	10c1ec26 	beq	r2,r3,8112cdd8 <_strtod_r+0xc38>
8112c628:	1023883a 	mov	r17,r2
8112c62c:	0019883a 	mov	r12,zero
8112c630:	88bff404 	addi	r2,r17,-48
8112c634:	00c00244 	movi	r3,9
8112c638:	1881b736 	bltu	r3,r2,8112cd18 <_strtod_r+0xb78>
8112c63c:	00800c04 	movi	r2,48
8112c640:	8880071e 	bne	r17,r2,8112c660 <_strtod_r+0x4c0>
8112c644:	d8800617 	ldw	r2,24(sp)
8112c648:	8807883a 	mov	r3,r17
8112c64c:	10800044 	addi	r2,r2,1
8112c650:	d8800615 	stw	r2,24(sp)
8112c654:	14400007 	ldb	r17,0(r2)
8112c658:	10800044 	addi	r2,r2,1
8112c65c:	88fffc26 	beq	r17,r3,8112c650 <__reset+0xfb10c650>
8112c660:	88bff3c4 	addi	r2,r17,-49
8112c664:	00c00204 	movi	r3,8
8112c668:	18bf7036 	bltu	r3,r2,8112c42c <__reset+0xfb10c42c>
8112c66c:	db800617 	ldw	r14,24(sp)
8112c670:	88bff404 	addi	r2,r17,-48
8112c674:	03400244 	movi	r13,9
8112c678:	71c00044 	addi	r7,r14,1
8112c67c:	d9c00615 	stw	r7,24(sp)
8112c680:	74400043 	ldbu	r17,1(r14)
8112c684:	88fff404 	addi	r3,r17,-48
8112c688:	8c403fcc 	andi	r17,r17,255
8112c68c:	8c40201c 	xori	r17,r17,128
8112c690:	18c03fcc 	andi	r3,r3,255
8112c694:	8c7fe004 	addi	r17,r17,-128
8112c698:	68c00e36 	bltu	r13,r3,8112c6d4 <_strtod_r+0x534>
8112c69c:	71000084 	addi	r4,r14,2
8112c6a0:	d9000615 	stw	r4,24(sp)
8112c6a4:	108002a4 	muli	r2,r2,10
8112c6a8:	21800003 	ldbu	r6,0(r4)
8112c6ac:	200f883a 	mov	r7,r4
8112c6b0:	1463883a 	add	r17,r2,r17
8112c6b4:	30fff404 	addi	r3,r6,-48
8112c6b8:	88bff404 	addi	r2,r17,-48
8112c6bc:	34403fcc 	andi	r17,r6,255
8112c6c0:	8c40201c 	xori	r17,r17,128
8112c6c4:	18c03fcc 	andi	r3,r3,255
8112c6c8:	8c7fe004 	addi	r17,r17,-128
8112c6cc:	21000044 	addi	r4,r4,1
8112c6d0:	68fff32e 	bgeu	r13,r3,8112c6a0 <__reset+0xfb10c6a0>
8112c6d4:	3b8fc83a 	sub	r7,r7,r14
8112c6d8:	00c00204 	movi	r3,8
8112c6dc:	19c29716 	blt	r3,r7,8112d13c <_strtod_r+0xf9c>
8112c6e0:	102b883a 	mov	r21,r2
8112c6e4:	009387c4 	movi	r2,19999
8112c6e8:	1540010e 	bge	r2,r21,8112c6f0 <_strtod_r+0x550>
8112c6ec:	102b883a 	mov	r21,r2
8112c6f0:	603f4f26 	beq	r12,zero,8112c430 <__reset+0xfb10c430>
8112c6f4:	056bc83a 	sub	r21,zero,r21
8112c6f8:	003f4d06 	br	8112c430 <__reset+0xfb10c430>
8112c6fc:	98800047 	ldb	r2,1(r19)
8112c700:	00c01604 	movi	r3,88
8112c704:	10c1de26 	beq	r2,r3,8112ce80 <_strtod_r+0xce0>
8112c708:	00c01e04 	movi	r3,120
8112c70c:	10c1dc26 	beq	r2,r3,8112ce80 <_strtod_r+0xce0>
8112c710:	98c00044 	addi	r3,r19,1
8112c714:	1827883a 	mov	r19,r3
8112c718:	d8c00615 	stw	r3,24(sp)
8112c71c:	18c00044 	addi	r3,r3,1
8112c720:	18bfffc3 	ldbu	r2,-1(r3)
8112c724:	11003fcc 	andi	r4,r2,255
8112c728:	2100201c 	xori	r4,r4,128
8112c72c:	213fe004 	addi	r4,r4,-128
8112c730:	217ff826 	beq	r4,r5,8112c714 <__reset+0xfb10c714>
8112c734:	203f7926 	beq	r4,zero,8112c51c <__reset+0xfb10c51c>
8112c738:	dcc00815 	stw	r19,32(sp)
8112c73c:	04800044 	movi	r18,1
8112c740:	003f0b06 	br	8112c370 <__reset+0xfb10c370>
8112c744:	8009883a 	mov	r4,r16
8112c748:	112a3c00 	call	8112a3c0 <_localeconv_r>
8112c74c:	11000017 	ldw	r4,0(r2)
8112c750:	11211a00 	call	811211a0 <strlen>
8112c754:	d8c00617 	ldw	r3,24(sp)
8112c758:	1885883a 	add	r2,r3,r2
8112c75c:	d8800615 	stw	r2,24(sp)
8112c760:	14400007 	ldb	r17,0(r2)
8112c764:	b001881e 	bne	r22,zero,8112cd88 <_strtod_r+0xbe8>
8112c768:	00c00c04 	movi	r3,48
8112c76c:	88c3391e 	bne	r17,r3,8112d454 <_strtod_r+0x12b4>
8112c770:	10c00044 	addi	r3,r2,1
8112c774:	8809883a 	mov	r4,r17
8112c778:	d8c00615 	stw	r3,24(sp)
8112c77c:	1c400007 	ldb	r17,0(r3)
8112c780:	188bc83a 	sub	r5,r3,r2
8112c784:	18c00044 	addi	r3,r3,1
8112c788:	893ffb26 	beq	r17,r4,8112c778 <__reset+0xfb10c778>
8112c78c:	88bff3c4 	addi	r2,r17,-49
8112c790:	00c00204 	movi	r3,8
8112c794:	1882e72e 	bgeu	r3,r2,8112d334 <_strtod_r+0x1194>
8112c798:	00801944 	movi	r2,101
8112c79c:	88814d26 	beq	r17,r2,8112ccd4 <_strtod_r+0xb34>
8112c7a0:	0013883a 	mov	r9,zero
8112c7a4:	0015883a 	mov	r10,zero
8112c7a8:	02c00044 	movi	r11,1
8112c7ac:	003f1d06 	br	8112c424 <__reset+0xfb10c424>
8112c7b0:	4defc83a 	sub	r23,r9,r23
8112c7b4:	bd6f883a 	add	r23,r23,r21
8112c7b8:	05c21e0e 	bge	zero,r23,8112d034 <_strtod_r+0xe94>
8112c7bc:	b88003cc 	andi	r2,r23,15
8112c7c0:	10000d26 	beq	r2,zero,8112c7f8 <_strtod_r+0x658>
8112c7c4:	100490fa 	slli	r2,r2,3
8112c7c8:	00e04574 	movhi	r3,33045
8112c7cc:	18f93704 	addi	r3,r3,-6948
8112c7d0:	1885883a 	add	r2,r3,r2
8112c7d4:	11000017 	ldw	r4,0(r2)
8112c7d8:	11400117 	ldw	r5,4(r2)
8112c7dc:	900d883a 	mov	r6,r18
8112c7e0:	880f883a 	mov	r7,r17
8112c7e4:	da401315 	stw	r9,76(sp)
8112c7e8:	111dff40 	call	8111dff4 <__muldf3>
8112c7ec:	da401317 	ldw	r9,76(sp)
8112c7f0:	1025883a 	mov	r18,r2
8112c7f4:	1823883a 	mov	r17,r3
8112c7f8:	023ffc04 	movi	r8,-16
8112c7fc:	ba10703a 	and	r8,r23,r8
8112c800:	40003c26 	beq	r8,zero,8112c8f4 <_strtod_r+0x754>
8112c804:	00804d04 	movi	r2,308
8112c808:	1201cd16 	blt	r2,r8,8112cf40 <_strtod_r+0xda0>
8112c80c:	4011d13a 	srai	r8,r8,4
8112c810:	03000044 	movi	r12,1
8112c814:	62037c0e 	bge	r12,r8,8112d608 <_strtod_r+0x1468>
8112c818:	01204574 	movhi	r4,33045
8112c81c:	21392d04 	addi	r4,r4,-6988
8112c820:	2015883a 	mov	r10,r4
8112c824:	0027883a 	mov	r19,zero
8112c828:	d9000915 	stw	r4,36(sp)
8112c82c:	9005883a 	mov	r2,r18
8112c830:	8807883a 	mov	r3,r17
8112c834:	dc000c15 	stw	r16,48(sp)
8112c838:	dc800e15 	stw	r18,56(sp)
8112c83c:	9821883a 	mov	r16,r19
8112c840:	0009883a 	mov	r4,zero
8112c844:	8827883a 	mov	r19,r17
8112c848:	602f883a 	mov	r23,r12
8112c84c:	da400a15 	stw	r9,40(sp)
8112c850:	5025883a 	mov	r18,r10
8112c854:	4023883a 	mov	r17,r8
8112c858:	8980004c 	andi	r6,r17,1
8112c85c:	30000626 	beq	r6,zero,8112c878 <_strtod_r+0x6d8>
8112c860:	91800017 	ldw	r6,0(r18)
8112c864:	91c00117 	ldw	r7,4(r18)
8112c868:	1009883a 	mov	r4,r2
8112c86c:	180b883a 	mov	r5,r3
8112c870:	111dff40 	call	8111dff4 <__muldf3>
8112c874:	01000044 	movi	r4,1
8112c878:	8823d07a 	srai	r17,r17,1
8112c87c:	84000044 	addi	r16,r16,1
8112c880:	94800204 	addi	r18,r18,8
8112c884:	8dfff41e 	bne	r17,r23,8112c858 <__reset+0xfb10c858>
8112c888:	21003fcc 	andi	r4,r4,255
8112c88c:	9823883a 	mov	r17,r19
8112c890:	da400a17 	ldw	r9,40(sp)
8112c894:	8027883a 	mov	r19,r16
8112c898:	dc800e17 	ldw	r18,56(sp)
8112c89c:	dc000c17 	ldw	r16,48(sp)
8112c8a0:	2003b11e 	bne	r4,zero,8112d768 <_strtod_r+0x15c8>
8112c8a4:	981690fa 	slli	r11,r19,3
8112c8a8:	d8800917 	ldw	r2,36(sp)
8112c8ac:	01ff2c34 	movhi	r7,64688
8112c8b0:	900d883a 	mov	r6,r18
8112c8b4:	12ef883a 	add	r23,r2,r11
8112c8b8:	b9000017 	ldw	r4,0(r23)
8112c8bc:	b9400117 	ldw	r5,4(r23)
8112c8c0:	89cf883a 	add	r7,r17,r7
8112c8c4:	da401315 	stw	r9,76(sp)
8112c8c8:	111dff40 	call	8111dff4 <__muldf3>
8112c8cc:	1025883a 	mov	r18,r2
8112c8d0:	011f2834 	movhi	r4,31904
8112c8d4:	189ffc2c 	andhi	r2,r3,32752
8112c8d8:	da401317 	ldw	r9,76(sp)
8112c8dc:	20819836 	bltu	r4,r2,8112cf40 <_strtod_r+0xda0>
8112c8e0:	011f2434 	movhi	r4,31888
8112c8e4:	2083382e 	bgeu	r4,r2,8112d5c8 <_strtod_r+0x1428>
8112c8e8:	045ffc34 	movhi	r17,32752
8112c8ec:	8c7fffc4 	addi	r17,r17,-1
8112c8f0:	04bfffc4 	movi	r18,-1
8112c8f4:	d8000915 	stw	zero,36(sp)
8112c8f8:	d9400817 	ldw	r5,32(sp)
8112c8fc:	df000015 	stw	fp,0(sp)
8112c900:	480f883a 	mov	r7,r9
8112c904:	b00d883a 	mov	r6,r22
8112c908:	8009883a 	mov	r4,r16
8112c90c:	112aadc0 	call	8112aadc <__s2b>
8112c910:	d8800815 	stw	r2,32(sp)
8112c914:	10018a26 	beq	r2,zero,8112cf40 <_strtod_r+0xda0>
8112c918:	a807d7fa 	srai	r3,r21,31
8112c91c:	0545c83a 	sub	r2,zero,r21
8112c920:	dd400a15 	stw	r21,40(sp)
8112c924:	1886703a 	and	r3,r3,r2
8112c928:	d8c00c15 	stw	r3,48(sp)
8112c92c:	a8013516 	blt	r21,zero,8112ce04 <_strtod_r+0xc64>
8112c930:	d9400817 	ldw	r5,32(sp)
8112c934:	0011883a 	mov	r8,zero
8112c938:	0027883a 	mov	r19,zero
8112c93c:	29400304 	addi	r5,r5,12
8112c940:	d9400f15 	stw	r5,60(sp)
8112c944:	402b883a 	mov	r21,r8
8112c948:	dd001215 	stw	r20,72(sp)
8112c94c:	d8800817 	ldw	r2,32(sp)
8112c950:	8009883a 	mov	r4,r16
8112c954:	11400117 	ldw	r5,4(r2)
8112c958:	112a8dc0 	call	8112a8dc <_Balloc>
8112c95c:	1029883a 	mov	r20,r2
8112c960:	10012d26 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112c964:	d8c00817 	ldw	r3,32(sp)
8112c968:	d9400f17 	ldw	r5,60(sp)
8112c96c:	11000304 	addi	r4,r2,12
8112c970:	19800417 	ldw	r6,16(r3)
8112c974:	31800084 	addi	r6,r6,2
8112c978:	318d883a 	add	r6,r6,r6
8112c97c:	318d883a 	add	r6,r6,r6
8112c980:	11206ac0 	call	811206ac <memcpy>
8112c984:	d9000204 	addi	r4,sp,8
8112c988:	d9000015 	stw	r4,0(sp)
8112c98c:	d9c00404 	addi	r7,sp,16
8112c990:	900b883a 	mov	r5,r18
8112c994:	880d883a 	mov	r6,r17
8112c998:	8009883a 	mov	r4,r16
8112c99c:	112b5b80 	call	8112b5b8 <__d2b>
8112c9a0:	d8800515 	stw	r2,20(sp)
8112c9a4:	dc801115 	stw	r18,68(sp)
8112c9a8:	dc401015 	stw	r17,64(sp)
8112c9ac:	10027c26 	beq	r2,zero,8112d3a0 <_strtod_r+0x1200>
8112c9b0:	01400044 	movi	r5,1
8112c9b4:	8009883a 	mov	r4,r16
8112c9b8:	112ad000 	call	8112ad00 <__i2b>
8112c9bc:	1027883a 	mov	r19,r2
8112c9c0:	10011526 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112c9c4:	d8800417 	ldw	r2,16(sp)
8112c9c8:	1000c816 	blt	r2,zero,8112ccec <_strtod_r+0xb4c>
8112c9cc:	d9400c17 	ldw	r5,48(sp)
8112c9d0:	d9000a17 	ldw	r4,40(sp)
8112c9d4:	28ad883a 	add	r22,r5,r2
8112c9d8:	d9400917 	ldw	r5,36(sp)
8112c9dc:	df000217 	ldw	fp,8(sp)
8112c9e0:	05ff0084 	movi	r23,-1022
8112c9e4:	1147c83a 	sub	r3,r2,r5
8112c9e8:	1f07883a 	add	r3,r3,fp
8112c9ec:	00800d84 	movi	r2,54
8112c9f0:	18ffffc4 	addi	r3,r3,-1
8112c9f4:	1739c83a 	sub	fp,r2,fp
8112c9f8:	1dc0a50e 	bge	r3,r23,8112cc90 <_strtod_r+0xaf0>
8112c9fc:	b8efc83a 	sub	r23,r23,r3
8112ca00:	008007c4 	movi	r2,31
8112ca04:	e5f9c83a 	sub	fp,fp,r23
8112ca08:	15c0bc16 	blt	r2,r23,8112ccfc <_strtod_r+0xb5c>
8112ca0c:	00800044 	movi	r2,1
8112ca10:	15c4983a 	sll	r2,r2,r23
8112ca14:	d8000b15 	stw	zero,44(sp)
8112ca18:	d8800d15 	stw	r2,52(sp)
8112ca1c:	2707883a 	add	r3,r4,fp
8112ca20:	d9000917 	ldw	r4,36(sp)
8112ca24:	b739883a 	add	fp,r22,fp
8112ca28:	20ef883a 	add	r23,r4,r3
8112ca2c:	b009883a 	mov	r4,r22
8112ca30:	e580010e 	bge	fp,r22,8112ca38 <_strtod_r+0x898>
8112ca34:	e009883a 	mov	r4,fp
8112ca38:	b805883a 	mov	r2,r23
8112ca3c:	25c0010e 	bge	r4,r23,8112ca44 <_strtod_r+0x8a4>
8112ca40:	2005883a 	mov	r2,r4
8112ca44:	0080030e 	bge	zero,r2,8112ca54 <_strtod_r+0x8b4>
8112ca48:	e0b9c83a 	sub	fp,fp,r2
8112ca4c:	b8afc83a 	sub	r23,r23,r2
8112ca50:	b0adc83a 	sub	r22,r22,r2
8112ca54:	d9400c17 	ldw	r5,48(sp)
8112ca58:	28001126 	beq	r5,zero,8112caa0 <_strtod_r+0x900>
8112ca5c:	280d883a 	mov	r6,r5
8112ca60:	8009883a 	mov	r4,r16
8112ca64:	980b883a 	mov	r5,r19
8112ca68:	112af440 	call	8112af44 <__pow5mult>
8112ca6c:	1027883a 	mov	r19,r2
8112ca70:	1000e926 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112ca74:	d9800517 	ldw	r6,20(sp)
8112ca78:	100b883a 	mov	r5,r2
8112ca7c:	8009883a 	mov	r4,r16
8112ca80:	112ad440 	call	8112ad44 <__multiply>
8112ca84:	1000e426 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112ca88:	d9400517 	ldw	r5,20(sp)
8112ca8c:	8009883a 	mov	r4,r16
8112ca90:	d8801315 	stw	r2,76(sp)
8112ca94:	112a98c0 	call	8112a98c <_Bfree>
8112ca98:	d8801317 	ldw	r2,76(sp)
8112ca9c:	d8800515 	stw	r2,20(sp)
8112caa0:	0700060e 	bge	zero,fp,8112cabc <_strtod_r+0x91c>
8112caa4:	d9400517 	ldw	r5,20(sp)
8112caa8:	e00d883a 	mov	r6,fp
8112caac:	8009883a 	mov	r4,r16
8112cab0:	112b08c0 	call	8112b08c <__lshift>
8112cab4:	d8800515 	stw	r2,20(sp)
8112cab8:	10023926 	beq	r2,zero,8112d3a0 <_strtod_r+0x1200>
8112cabc:	d8800a17 	ldw	r2,40(sp)
8112cac0:	10000626 	beq	r2,zero,8112cadc <_strtod_r+0x93c>
8112cac4:	d9800a17 	ldw	r6,40(sp)
8112cac8:	a00b883a 	mov	r5,r20
8112cacc:	8009883a 	mov	r4,r16
8112cad0:	112af440 	call	8112af44 <__pow5mult>
8112cad4:	1029883a 	mov	r20,r2
8112cad8:	1000cf26 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112cadc:	05c0060e 	bge	zero,r23,8112caf8 <_strtod_r+0x958>
8112cae0:	a00b883a 	mov	r5,r20
8112cae4:	b80d883a 	mov	r6,r23
8112cae8:	8009883a 	mov	r4,r16
8112caec:	112b08c0 	call	8112b08c <__lshift>
8112caf0:	1029883a 	mov	r20,r2
8112caf4:	1000c826 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112caf8:	0580060e 	bge	zero,r22,8112cb14 <_strtod_r+0x974>
8112cafc:	980b883a 	mov	r5,r19
8112cb00:	b00d883a 	mov	r6,r22
8112cb04:	8009883a 	mov	r4,r16
8112cb08:	112b08c0 	call	8112b08c <__lshift>
8112cb0c:	1027883a 	mov	r19,r2
8112cb10:	1000c126 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112cb14:	d9400517 	ldw	r5,20(sp)
8112cb18:	a00d883a 	mov	r6,r20
8112cb1c:	8009883a 	mov	r4,r16
8112cb20:	112b23c0 	call	8112b23c <__mdiff>
8112cb24:	102b883a 	mov	r21,r2
8112cb28:	1000bb26 	beq	r2,zero,8112ce18 <_strtod_r+0xc78>
8112cb2c:	10c00317 	ldw	r3,12(r2)
8112cb30:	980b883a 	mov	r5,r19
8112cb34:	10000315 	stw	zero,12(r2)
8112cb38:	1009883a 	mov	r4,r2
8112cb3c:	d8c00e15 	stw	r3,56(sp)
8112cb40:	112b1dc0 	call	8112b1dc <__mcmp>
8112cb44:	10027616 	blt	r2,zero,8112d520 <_strtod_r+0x1380>
8112cb48:	10024426 	beq	r2,zero,8112d45c <_strtod_r+0x12bc>
8112cb4c:	980b883a 	mov	r5,r19
8112cb50:	a809883a 	mov	r4,r21
8112cb54:	112b70c0 	call	8112b70c <__ratio>
8112cb58:	000d883a 	mov	r6,zero
8112cb5c:	01d00034 	movhi	r7,16384
8112cb60:	1009883a 	mov	r4,r2
8112cb64:	180b883a 	mov	r5,r3
8112cb68:	102f883a 	mov	r23,r2
8112cb6c:	182d883a 	mov	r22,r3
8112cb70:	11340fc0 	call	811340fc <__ledf2>
8112cb74:	00804a16 	blt	zero,r2,8112cca0 <_strtod_r+0xb00>
8112cb78:	d9400e17 	ldw	r5,56(sp)
8112cb7c:	28006b26 	beq	r5,zero,8112cd2c <_strtod_r+0xb8c>
8112cb80:	058ffc34 	movhi	r22,16368
8112cb84:	d8000b15 	stw	zero,44(sp)
8112cb88:	d8000d15 	stw	zero,52(sp)
8112cb8c:	b02f883a 	mov	r23,r22
8112cb90:	8f1ffc2c 	andhi	fp,r17,32752
8112cb94:	009ff834 	movhi	r2,32736
8112cb98:	e080cd26 	beq	fp,r2,8112ced0 <_strtod_r+0xd30>
8112cb9c:	d9400917 	ldw	r5,36(sp)
8112cba0:	28001a26 	beq	r5,zero,8112cc0c <_strtod_r+0xa6c>
8112cba4:	0081a834 	movhi	r2,1696
8112cba8:	17001836 	bltu	r2,fp,8112cc0c <_strtod_r+0xa6c>
8112cbac:	d9000d17 	ldw	r4,52(sp)
8112cbb0:	01d07834 	movhi	r7,16864
8112cbb4:	39ffffc4 	addi	r7,r7,-1
8112cbb8:	01bff034 	movhi	r6,65472
8112cbbc:	b80b883a 	mov	r5,r23
8112cbc0:	11340fc0 	call	811340fc <__ledf2>
8112cbc4:	00800e16 	blt	zero,r2,8112cc00 <_strtod_r+0xa60>
8112cbc8:	d9000d17 	ldw	r4,52(sp)
8112cbcc:	b80b883a 	mov	r5,r23
8112cbd0:	111d42c0 	call	8111d42c <__fixunsdfsi>
8112cbd4:	10018126 	beq	r2,zero,8112d1dc <_strtod_r+0x103c>
8112cbd8:	1009883a 	mov	r4,r2
8112cbdc:	11341f00 	call	811341f0 <__floatunsidf>
8112cbe0:	d8800d15 	stw	r2,52(sp)
8112cbe4:	182f883a 	mov	r23,r3
8112cbe8:	d8800e17 	ldw	r2,56(sp)
8112cbec:	1001791e 	bne	r2,zero,8112d1d4 <_strtod_r+0x1034>
8112cbf0:	ba20003c 	xorhi	r8,r23,32768
8112cbf4:	d8c00d17 	ldw	r3,52(sp)
8112cbf8:	402d883a 	mov	r22,r8
8112cbfc:	d8c00b15 	stw	r3,44(sp)
8112cc00:	0081ac34 	movhi	r2,1712
8112cc04:	b091883a 	add	r8,r22,r2
8112cc08:	472dc83a 	sub	r22,r8,fp
8112cc0c:	9009883a 	mov	r4,r18
8112cc10:	880b883a 	mov	r5,r17
8112cc14:	112b4400 	call	8112b440 <__ulp>
8112cc18:	d9000b17 	ldw	r4,44(sp)
8112cc1c:	b00b883a 	mov	r5,r22
8112cc20:	100d883a 	mov	r6,r2
8112cc24:	180f883a 	mov	r7,r3
8112cc28:	111dff40 	call	8111dff4 <__muldf3>
8112cc2c:	900d883a 	mov	r6,r18
8112cc30:	880f883a 	mov	r7,r17
8112cc34:	1009883a 	mov	r4,r2
8112cc38:	180b883a 	mov	r5,r3
8112cc3c:	1132ed00 	call	81132ed0 <__adddf3>
8112cc40:	1025883a 	mov	r18,r2
8112cc44:	1823883a 	mov	r17,r3
8112cc48:	182d883a 	mov	r22,r3
8112cc4c:	d9000917 	ldw	r4,36(sp)
8112cc50:	2000021e 	bne	r4,zero,8112cc5c <_strtod_r+0xabc>
8112cc54:	b09ffc2c 	andhi	r2,r22,32752
8112cc58:	e080be26 	beq	fp,r2,8112cf54 <_strtod_r+0xdb4>
8112cc5c:	d9400517 	ldw	r5,20(sp)
8112cc60:	8009883a 	mov	r4,r16
8112cc64:	112a98c0 	call	8112a98c <_Bfree>
8112cc68:	a00b883a 	mov	r5,r20
8112cc6c:	8009883a 	mov	r4,r16
8112cc70:	112a98c0 	call	8112a98c <_Bfree>
8112cc74:	980b883a 	mov	r5,r19
8112cc78:	8009883a 	mov	r4,r16
8112cc7c:	112a98c0 	call	8112a98c <_Bfree>
8112cc80:	a80b883a 	mov	r5,r21
8112cc84:	8009883a 	mov	r4,r16
8112cc88:	112a98c0 	call	8112a98c <_Bfree>
8112cc8c:	003f2f06 	br	8112c94c <__reset+0xfb10c94c>
8112cc90:	00c00044 	movi	r3,1
8112cc94:	d8000b15 	stw	zero,44(sp)
8112cc98:	d8c00d15 	stw	r3,52(sp)
8112cc9c:	003f5f06 	br	8112ca1c <__reset+0xfb10ca1c>
8112cca0:	b809883a 	mov	r4,r23
8112cca4:	000d883a 	mov	r6,zero
8112cca8:	01cff834 	movhi	r7,16352
8112ccac:	b00b883a 	mov	r5,r22
8112ccb0:	111dff40 	call	8111dff4 <__muldf3>
8112ccb4:	d9000e17 	ldw	r4,56(sp)
8112ccb8:	d8800d15 	stw	r2,52(sp)
8112ccbc:	182f883a 	mov	r23,r3
8112ccc0:	2000181e 	bne	r4,zero,8112cd24 <_strtod_r+0xb84>
8112ccc4:	1a20003c 	xorhi	r8,r3,32768
8112ccc8:	d8800b15 	stw	r2,44(sp)
8112cccc:	402d883a 	mov	r22,r8
8112ccd0:	003faf06 	br	8112cb90 <__reset+0xfb10cb90>
8112ccd4:	0015883a 	mov	r10,zero
8112ccd8:	02c00044 	movi	r11,1
8112ccdc:	2800011e 	bne	r5,zero,8112cce4 <_strtod_r+0xb44>
8112cce0:	903d7e26 	beq	r18,zero,8112c2dc <__reset+0xfb10c2dc>
8112cce4:	0013883a 	mov	r9,zero
8112cce8:	003e4706 	br	8112c608 <__reset+0xfb10c608>
8112ccec:	d8c00a17 	ldw	r3,40(sp)
8112ccf0:	dd800c17 	ldw	r22,48(sp)
8112ccf4:	1889c83a 	sub	r4,r3,r2
8112ccf8:	003f3706 	br	8112c9d8 <__reset+0xfb10c9d8>
8112ccfc:	00bef884 	movi	r2,-1054
8112cd00:	05c00044 	movi	r23,1
8112cd04:	10c5c83a 	sub	r2,r2,r3
8112cd08:	b884983a 	sll	r2,r23,r2
8112cd0c:	ddc00d15 	stw	r23,52(sp)
8112cd10:	d8800b15 	stw	r2,44(sp)
8112cd14:	003f4106 	br	8112ca1c <__reset+0xfb10ca1c>
8112cd18:	ddc00615 	stw	r23,24(sp)
8112cd1c:	002b883a 	mov	r21,zero
8112cd20:	003dc306 	br	8112c430 <__reset+0xfb10c430>
8112cd24:	1811883a 	mov	r8,r3
8112cd28:	003fe706 	br	8112ccc8 <__reset+0xfb10ccc8>
8112cd2c:	90002e1e 	bne	r18,zero,8112cde8 <_strtod_r+0xc48>
8112cd30:	00c00434 	movhi	r3,16
8112cd34:	18ffffc4 	addi	r3,r3,-1
8112cd38:	88c4703a 	and	r2,r17,r3
8112cd3c:	10002c1e 	bne	r2,zero,8112cdf0 <_strtod_r+0xc50>
8112cd40:	000d883a 	mov	r6,zero
8112cd44:	01cffc34 	movhi	r7,16368
8112cd48:	b809883a 	mov	r4,r23
8112cd4c:	b00b883a 	mov	r5,r22
8112cd50:	11340fc0 	call	811340fc <__ledf2>
8112cd54:	10021716 	blt	r2,zero,8112d5b4 <_strtod_r+0x1414>
8112cd58:	b809883a 	mov	r4,r23
8112cd5c:	b00b883a 	mov	r5,r22
8112cd60:	000d883a 	mov	r6,zero
8112cd64:	01cff834 	movhi	r7,16352
8112cd68:	111dff40 	call	8111dff4 <__muldf3>
8112cd6c:	d8800d15 	stw	r2,52(sp)
8112cd70:	182f883a 	mov	r23,r3
8112cd74:	102d883a 	mov	r22,r2
8112cd78:	1a20003c 	xorhi	r8,r3,32768
8112cd7c:	dd800b15 	stw	r22,44(sp)
8112cd80:	402d883a 	mov	r22,r8
8112cd84:	003f8206 	br	8112cb90 <__reset+0xfb10cb90>
8112cd88:	b013883a 	mov	r9,r22
8112cd8c:	000b883a 	mov	r5,zero
8112cd90:	0015883a 	mov	r10,zero
8112cd94:	893ff404 	addi	r4,r17,-48
8112cd98:	00800244 	movi	r2,9
8112cd9c:	11001036 	bltu	r2,r4,8112cde0 <_strtod_r+0xc40>
8112cda0:	28c00044 	addi	r3,r5,1
8112cda4:	2023883a 	mov	r17,r4
8112cda8:	20014d1e 	bne	r4,zero,8112d2e0 <_strtod_r+0x1140>
8112cdac:	d9800617 	ldw	r6,24(sp)
8112cdb0:	180b883a 	mov	r5,r3
8112cdb4:	30800044 	addi	r2,r6,1
8112cdb8:	d8800615 	stw	r2,24(sp)
8112cdbc:	34400047 	ldb	r17,1(r6)
8112cdc0:	003ff406 	br	8112cd94 <__reset+0xfb10cd94>
8112cdc4:	0019883a 	mov	r12,zero
8112cdc8:	b8800084 	addi	r2,r23,2
8112cdcc:	d8800615 	stw	r2,24(sp)
8112cdd0:	bc400087 	ldb	r17,2(r23)
8112cdd4:	003e1606 	br	8112c630 <__reset+0xfb10c630>
8112cdd8:	03000044 	movi	r12,1
8112cddc:	003ffa06 	br	8112cdc8 <__reset+0xfb10cdc8>
8112cde0:	02c00044 	movi	r11,1
8112cde4:	003d8d06 	br	8112c41c <__reset+0xfb10c41c>
8112cde8:	00800044 	movi	r2,1
8112cdec:	9080fe26 	beq	r18,r2,8112d1e8 <_strtod_r+0x1048>
8112cdf0:	d8000b15 	stw	zero,44(sp)
8112cdf4:	05affc34 	movhi	r22,49136
8112cdf8:	d8000d15 	stw	zero,52(sp)
8112cdfc:	05cffc34 	movhi	r23,16368
8112ce00:	003f6306 	br	8112cb90 <__reset+0xfb10cb90>
8112ce04:	d8000a15 	stw	zero,40(sp)
8112ce08:	003ec906 	br	8112c930 <__reset+0xfb10c930>
8112ce0c:	d9001117 	ldw	r4,68(sp)
8112ce10:	00bfffc4 	movi	r2,-1
8112ce14:	2080461e 	bne	r4,r2,8112cf30 <_strtod_r+0xd90>
8112ce18:	dd000a15 	stw	r20,40(sp)
8112ce1c:	dd001217 	ldw	r20,72(sp)
8112ce20:	a811883a 	mov	r8,r21
8112ce24:	d8800517 	ldw	r2,20(sp)
8112ce28:	00c00884 	movi	r3,34
8112ce2c:	80c00015 	stw	r3,0(r16)
8112ce30:	002b883a 	mov	r21,zero
8112ce34:	059ffc34 	movhi	r22,32752
8112ce38:	100b883a 	mov	r5,r2
8112ce3c:	8009883a 	mov	r4,r16
8112ce40:	da001315 	stw	r8,76(sp)
8112ce44:	112a98c0 	call	8112a98c <_Bfree>
8112ce48:	d9400a17 	ldw	r5,40(sp)
8112ce4c:	8009883a 	mov	r4,r16
8112ce50:	112a98c0 	call	8112a98c <_Bfree>
8112ce54:	980b883a 	mov	r5,r19
8112ce58:	8009883a 	mov	r4,r16
8112ce5c:	112a98c0 	call	8112a98c <_Bfree>
8112ce60:	d9400817 	ldw	r5,32(sp)
8112ce64:	8009883a 	mov	r4,r16
8112ce68:	112a98c0 	call	8112a98c <_Bfree>
8112ce6c:	da001317 	ldw	r8,76(sp)
8112ce70:	8009883a 	mov	r4,r16
8112ce74:	400b883a 	mov	r5,r8
8112ce78:	112a98c0 	call	8112a98c <_Bfree>
8112ce7c:	003d9206 	br	8112c4c8 <__reset+0xfb10c4c8>
8112ce80:	d8c00717 	ldw	r3,28(sp)
8112ce84:	d8800504 	addi	r2,sp,20
8112ce88:	01a04574 	movhi	r6,33045
8112ce8c:	31b97204 	addi	r6,r6,-6712
8112ce90:	d8c00115 	stw	r3,4(sp)
8112ce94:	d8800015 	stw	r2,0(sp)
8112ce98:	d9c00404 	addi	r7,sp,16
8112ce9c:	d9400604 	addi	r5,sp,24
8112cea0:	8009883a 	mov	r4,r16
8112cea4:	11312f40 	call	811312f4 <__gethex>
8112cea8:	154001cc 	andi	r21,r2,7
8112ceac:	a83d9b26 	beq	r21,zero,8112c51c <__reset+0xfb10c51c>
8112ceb0:	00c00184 	movi	r3,6
8112ceb4:	a8c0d61e 	bne	r21,r3,8112d210 <_strtod_r+0x1070>
8112ceb8:	9cc00044 	addi	r19,r19,1
8112cebc:	dcc00615 	stw	r19,24(sp)
8112cec0:	002b883a 	mov	r21,zero
8112cec4:	002d883a 	mov	r22,zero
8112cec8:	d8000715 	stw	zero,28(sp)
8112cecc:	003d7e06 	br	8112c4c8 <__reset+0xfb10c4c8>
8112ced0:	00bf2c34 	movhi	r2,64688
8112ced4:	88a3883a 	add	r17,r17,r2
8112ced8:	9009883a 	mov	r4,r18
8112cedc:	880b883a 	mov	r5,r17
8112cee0:	112b4400 	call	8112b440 <__ulp>
8112cee4:	d9000b17 	ldw	r4,44(sp)
8112cee8:	100d883a 	mov	r6,r2
8112ceec:	180f883a 	mov	r7,r3
8112cef0:	b00b883a 	mov	r5,r22
8112cef4:	111dff40 	call	8111dff4 <__muldf3>
8112cef8:	900d883a 	mov	r6,r18
8112cefc:	180b883a 	mov	r5,r3
8112cf00:	880f883a 	mov	r7,r17
8112cf04:	1009883a 	mov	r4,r2
8112cf08:	1132ed00 	call	81132ed0 <__adddf3>
8112cf0c:	015f2834 	movhi	r5,31904
8112cf10:	1025883a 	mov	r18,r2
8112cf14:	297fffc4 	addi	r5,r5,-1
8112cf18:	189ffc2c 	andhi	r2,r3,32752
8112cf1c:	2880892e 	bgeu	r5,r2,8112d144 <_strtod_r+0xfa4>
8112cf20:	d8801017 	ldw	r2,64(sp)
8112cf24:	00dffc34 	movhi	r3,32752
8112cf28:	18ffffc4 	addi	r3,r3,-1
8112cf2c:	10ffb726 	beq	r2,r3,8112ce0c <__reset+0xfb10ce0c>
8112cf30:	045ffc34 	movhi	r17,32752
8112cf34:	8c7fffc4 	addi	r17,r17,-1
8112cf38:	04bfffc4 	movi	r18,-1
8112cf3c:	003f4706 	br	8112cc5c <__reset+0xfb10cc5c>
8112cf40:	00800884 	movi	r2,34
8112cf44:	80800015 	stw	r2,0(r16)
8112cf48:	002b883a 	mov	r21,zero
8112cf4c:	059ffc34 	movhi	r22,32752
8112cf50:	003d5d06 	br	8112c4c8 <__reset+0xfb10c4c8>
8112cf54:	d9000d17 	ldw	r4,52(sp)
8112cf58:	b80b883a 	mov	r5,r23
8112cf5c:	111f0180 	call	8111f018 <__fixdfsi>
8112cf60:	1009883a 	mov	r4,r2
8112cf64:	111f0980 	call	8111f098 <__floatsidf>
8112cf68:	d9000d17 	ldw	r4,52(sp)
8112cf6c:	b80b883a 	mov	r5,r23
8112cf70:	100d883a 	mov	r6,r2
8112cf74:	180f883a 	mov	r7,r3
8112cf78:	111e7140 	call	8111e714 <__subdf3>
8112cf7c:	d9400e17 	ldw	r5,56(sp)
8112cf80:	1039883a 	mov	fp,r2
8112cf84:	182f883a 	mov	r23,r3
8112cf88:	2800141e 	bne	r5,zero,8112cfdc <_strtod_r+0xe3c>
8112cf8c:	9000131e 	bne	r18,zero,8112cfdc <_strtod_r+0xe3c>
8112cf90:	00800434 	movhi	r2,16
8112cf94:	10bfffc4 	addi	r2,r2,-1
8112cf98:	b0ac703a 	and	r22,r22,r2
8112cf9c:	b0000f1e 	bne	r22,zero,8112cfdc <_strtod_r+0xe3c>
8112cfa0:	01a52834 	movhi	r6,38048
8112cfa4:	01cff434 	movhi	r7,16336
8112cfa8:	318d6544 	addi	r6,r6,13717
8112cfac:	39ffffc4 	addi	r7,r7,-1
8112cfb0:	e009883a 	mov	r4,fp
8112cfb4:	180b883a 	mov	r5,r3
8112cfb8:	11340fc0 	call	811340fc <__ledf2>
8112cfbc:	103f270e 	bge	r2,zero,8112cc5c <__reset+0xfb10cc5c>
8112cfc0:	dd000a15 	stw	r20,40(sp)
8112cfc4:	a811883a 	mov	r8,r21
8112cfc8:	dd001217 	ldw	r20,72(sp)
8112cfcc:	d8800517 	ldw	r2,20(sp)
8112cfd0:	002b883a 	mov	r21,zero
8112cfd4:	882d883a 	mov	r22,r17
8112cfd8:	003f9706 	br	8112ce38 <__reset+0xfb10ce38>
8112cfdc:	01a52834 	movhi	r6,38048
8112cfe0:	01cff834 	movhi	r7,16352
8112cfe4:	318d6544 	addi	r6,r6,13717
8112cfe8:	39ffffc4 	addi	r7,r7,-1
8112cfec:	e009883a 	mov	r4,fp
8112cff0:	b80b883a 	mov	r5,r23
8112cff4:	11340fc0 	call	811340fc <__ledf2>
8112cff8:	10000716 	blt	r2,zero,8112d018 <_strtod_r+0xe78>
8112cffc:	018d6c34 	movhi	r6,13744
8112d000:	31b94d44 	addi	r6,r6,-6859
8112d004:	01cff834 	movhi	r7,16352
8112d008:	e009883a 	mov	r4,fp
8112d00c:	b80b883a 	mov	r5,r23
8112d010:	111df180 	call	8111df18 <__gedf2>
8112d014:	00bf110e 	bge	zero,r2,8112cc5c <__reset+0xfb10cc5c>
8112d018:	dd000a15 	stw	r20,40(sp)
8112d01c:	a811883a 	mov	r8,r21
8112d020:	dd001217 	ldw	r20,72(sp)
8112d024:	d8800517 	ldw	r2,20(sp)
8112d028:	902b883a 	mov	r21,r18
8112d02c:	882d883a 	mov	r22,r17
8112d030:	003f8106 	br	8112ce38 <__reset+0xfb10ce38>
8112d034:	b83e2f26 	beq	r23,zero,8112c8f4 <__reset+0xfb10c8f4>
8112d038:	05efc83a 	sub	r23,zero,r23
8112d03c:	b88003cc 	andi	r2,r23,15
8112d040:	10000d26 	beq	r2,zero,8112d078 <_strtod_r+0xed8>
8112d044:	100490fa 	slli	r2,r2,3
8112d048:	00e04574 	movhi	r3,33045
8112d04c:	18f93704 	addi	r3,r3,-6948
8112d050:	1885883a 	add	r2,r3,r2
8112d054:	11800017 	ldw	r6,0(r2)
8112d058:	11c00117 	ldw	r7,4(r2)
8112d05c:	9009883a 	mov	r4,r18
8112d060:	880b883a 	mov	r5,r17
8112d064:	da401315 	stw	r9,76(sp)
8112d068:	11337840 	call	81133784 <__divdf3>
8112d06c:	da401317 	ldw	r9,76(sp)
8112d070:	1025883a 	mov	r18,r2
8112d074:	1823883a 	mov	r17,r3
8112d078:	b82fd13a 	srai	r23,r23,4
8112d07c:	b83e1d26 	beq	r23,zero,8112c8f4 <__reset+0xfb10c8f4>
8112d080:	008007c4 	movi	r2,31
8112d084:	15c02816 	blt	r2,r23,8112d128 <_strtod_r+0xf88>
8112d088:	b880040c 	andi	r2,r23,16
8112d08c:	10019726 	beq	r2,zero,8112d6ec <_strtod_r+0x154c>
8112d090:	05c1880e 	bge	zero,r23,8112d6b4 <_strtod_r+0x1514>
8112d094:	00c01a84 	movi	r3,106
8112d098:	d8c00915 	stw	r3,36(sp)
8112d09c:	04e04574 	movhi	r19,33045
8112d0a0:	9cf97704 	addi	r19,r19,-6692
8112d0a4:	8807883a 	mov	r3,r17
8112d0a8:	9005883a 	mov	r2,r18
8112d0ac:	8023883a 	mov	r17,r16
8112d0b0:	0009883a 	mov	r4,zero
8112d0b4:	9821883a 	mov	r16,r19
8112d0b8:	da400a15 	stw	r9,40(sp)
8112d0bc:	1827883a 	mov	r19,r3
8112d0c0:	b980004c 	andi	r6,r23,1
8112d0c4:	30000626 	beq	r6,zero,8112d0e0 <_strtod_r+0xf40>
8112d0c8:	81800017 	ldw	r6,0(r16)
8112d0cc:	81c00117 	ldw	r7,4(r16)
8112d0d0:	1009883a 	mov	r4,r2
8112d0d4:	180b883a 	mov	r5,r3
8112d0d8:	111dff40 	call	8111dff4 <__muldf3>
8112d0dc:	01000044 	movi	r4,1
8112d0e0:	b82fd07a 	srai	r23,r23,1
8112d0e4:	84000204 	addi	r16,r16,8
8112d0e8:	b83ff51e 	bne	r23,zero,8112d0c0 <__reset+0xfb10d0c0>
8112d0ec:	21003fcc 	andi	r4,r4,255
8112d0f0:	8821883a 	mov	r16,r17
8112d0f4:	da400a17 	ldw	r9,40(sp)
8112d0f8:	9823883a 	mov	r17,r19
8112d0fc:	2001a51e 	bne	r4,zero,8112d794 <_strtod_r+0x15f4>
8112d100:	d9000917 	ldw	r4,36(sp)
8112d104:	20016d1e 	bne	r4,zero,8112d6bc <_strtod_r+0x151c>
8112d108:	000d883a 	mov	r6,zero
8112d10c:	000f883a 	mov	r7,zero
8112d110:	9009883a 	mov	r4,r18
8112d114:	880b883a 	mov	r5,r17
8112d118:	da401315 	stw	r9,76(sp)
8112d11c:	11340740 	call	81134074 <__eqdf2>
8112d120:	da401317 	ldw	r9,76(sp)
8112d124:	103df41e 	bne	r2,zero,8112c8f8 <__reset+0xfb10c8f8>
8112d128:	00800884 	movi	r2,34
8112d12c:	80800015 	stw	r2,0(r16)
8112d130:	002b883a 	mov	r21,zero
8112d134:	002d883a 	mov	r22,zero
8112d138:	003ce306 	br	8112c4c8 <__reset+0xfb10c4c8>
8112d13c:	055387c4 	movi	r21,19999
8112d140:	003d6b06 	br	8112c6f0 <__reset+0xfb10c6f0>
8112d144:	0440d434 	movhi	r17,848
8112d148:	1c63883a 	add	r17,r3,r17
8112d14c:	882d883a 	mov	r22,r17
8112d150:	003ebe06 	br	8112cc4c <__reset+0xfb10cc4c>
8112d154:	14403fcc 	andi	r17,r2,255
8112d158:	8c40201c 	xori	r17,r17,128
8112d15c:	8c7fe004 	addi	r17,r17,-128
8112d160:	dd400817 	ldw	r21,32(sp)
8112d164:	0027883a 	mov	r19,zero
8112d168:	0039883a 	mov	fp,zero
8112d16c:	002d883a 	mov	r22,zero
8112d170:	003c9906 	br	8112c3d8 <__reset+0xfb10c3d8>
8112d174:	00c00944 	movi	r3,37
8112d178:	1a47c83a 	sub	r3,r3,r9
8112d17c:	1d7d8c16 	blt	r3,r21,8112c7b0 <__reset+0xfb10c7b0>
8112d180:	1261c83a 	sub	r16,r2,r9
8112d184:	800490fa 	slli	r2,r16,3
8112d188:	04e04574 	movhi	r19,33045
8112d18c:	9cf93704 	addi	r19,r19,-6948
8112d190:	9885883a 	add	r2,r19,r2
8112d194:	11000017 	ldw	r4,0(r2)
8112d198:	11400117 	ldw	r5,4(r2)
8112d19c:	900d883a 	mov	r6,r18
8112d1a0:	880f883a 	mov	r7,r17
8112d1a4:	111dff40 	call	8111dff4 <__muldf3>
8112d1a8:	ac0dc83a 	sub	r6,r21,r16
8112d1ac:	300c90fa 	slli	r6,r6,3
8112d1b0:	1009883a 	mov	r4,r2
8112d1b4:	180b883a 	mov	r5,r3
8112d1b8:	9985883a 	add	r2,r19,r6
8112d1bc:	11800017 	ldw	r6,0(r2)
8112d1c0:	11c00117 	ldw	r7,4(r2)
8112d1c4:	111dff40 	call	8111dff4 <__muldf3>
8112d1c8:	102b883a 	mov	r21,r2
8112d1cc:	182d883a 	mov	r22,r3
8112d1d0:	003cbd06 	br	8112c4c8 <__reset+0xfb10c4c8>
8112d1d4:	b811883a 	mov	r8,r23
8112d1d8:	003e8606 	br	8112cbf4 <__reset+0xfb10cbf4>
8112d1dc:	d8000d15 	stw	zero,52(sp)
8112d1e0:	05cffc34 	movhi	r23,16368
8112d1e4:	003e8006 	br	8112cbe8 <__reset+0xfb10cbe8>
8112d1e8:	883f011e 	bne	r17,zero,8112cdf0 <__reset+0xfb10cdf0>
8112d1ec:	dd000a15 	stw	r20,40(sp)
8112d1f0:	dd001217 	ldw	r20,72(sp)
8112d1f4:	a811883a 	mov	r8,r21
8112d1f8:	00800884 	movi	r2,34
8112d1fc:	80800015 	stw	r2,0(r16)
8112d200:	002b883a 	mov	r21,zero
8112d204:	d8800517 	ldw	r2,20(sp)
8112d208:	002d883a 	mov	r22,zero
8112d20c:	003f0a06 	br	8112ce38 <__reset+0xfb10ce38>
8112d210:	d9800517 	ldw	r6,20(sp)
8112d214:	30000826 	beq	r6,zero,8112d238 <_strtod_r+0x1098>
8112d218:	01400d44 	movi	r5,53
8112d21c:	d9000204 	addi	r4,sp,8
8112d220:	d8801315 	stw	r2,76(sp)
8112d224:	112b8340 	call	8112b834 <__copybits>
8112d228:	d9400517 	ldw	r5,20(sp)
8112d22c:	8009883a 	mov	r4,r16
8112d230:	112a98c0 	call	8112a98c <_Bfree>
8112d234:	d8801317 	ldw	r2,76(sp)
8112d238:	00c00184 	movi	r3,6
8112d23c:	1d400f36 	bltu	r3,r21,8112d27c <_strtod_r+0x10dc>
8112d240:	a82a90ba 	slli	r21,r21,2
8112d244:	00e044f4 	movhi	r3,33043
8112d248:	18f49604 	addi	r3,r3,-11688
8112d24c:	a8eb883a 	add	r21,r21,r3
8112d250:	a8c00017 	ldw	r3,0(r21)
8112d254:	1800683a 	jmp	r3
8112d258:	8112d2d4 	ori	r4,r16,19275
8112d25c:	8112d2ac 	andhi	r4,r16,19274
8112d260:	8112d290 	cmplti	r4,r16,19274
8112d264:	8112d274 	orhi	r4,r16,19273
8112d268:	8112d29c 	xori	r4,r16,19274
8112d26c:	8112d2ac 	andhi	r4,r16,19274
8112d270:	8112d2d4 	ori	r4,r16,19275
8112d274:	045ffc34 	movhi	r17,32752
8112d278:	0025883a 	mov	r18,zero
8112d27c:	1080020c 	andi	r2,r2,8
8112d280:	902b883a 	mov	r21,r18
8112d284:	103c8f26 	beq	r2,zero,8112c4c4 <__reset+0xfb10c4c4>
8112d288:	8da00034 	orhi	r22,r17,32768
8112d28c:	003c8e06 	br	8112c4c8 <__reset+0xfb10c4c8>
8112d290:	dc800217 	ldw	r18,8(sp)
8112d294:	dc400317 	ldw	r17,12(sp)
8112d298:	003ff806 	br	8112d27c <__reset+0xfb10d27c>
8112d29c:	04600034 	movhi	r17,32768
8112d2a0:	8c7fffc4 	addi	r17,r17,-1
8112d2a4:	04bfffc4 	movi	r18,-1
8112d2a8:	003ff406 	br	8112d27c <__reset+0xfb10d27c>
8112d2ac:	d8c00417 	ldw	r3,16(sp)
8112d2b0:	dc400317 	ldw	r17,12(sp)
8112d2b4:	013ffc34 	movhi	r4,65520
8112d2b8:	18c10cc4 	addi	r3,r3,1075
8112d2bc:	1806953a 	slli	r3,r3,20
8112d2c0:	213fffc4 	addi	r4,r4,-1
8112d2c4:	8922703a 	and	r17,r17,r4
8112d2c8:	dc800217 	ldw	r18,8(sp)
8112d2cc:	88e2b03a 	or	r17,r17,r3
8112d2d0:	003fea06 	br	8112d27c <__reset+0xfb10d27c>
8112d2d4:	0023883a 	mov	r17,zero
8112d2d8:	0025883a 	mov	r18,zero
8112d2dc:	003fe706 	br	8112d27c <__reset+0xfb10d27c>
8112d2e0:	01800044 	movi	r6,1
8112d2e4:	50d5883a 	add	r10,r10,r3
8112d2e8:	2a4b883a 	add	r5,r5,r9
8112d2ec:	19811a26 	beq	r3,r6,8112d758 <_strtod_r+0x15b8>
8112d2f0:	01800204 	movi	r6,8
8112d2f4:	01c00404 	movi	r7,16
8112d2f8:	4a400044 	addi	r9,r9,1
8112d2fc:	48bfffc4 	addi	r2,r9,-1
8112d300:	30801616 	blt	r6,r2,8112d35c <_strtod_r+0x11bc>
8112d304:	e70002a4 	muli	fp,fp,10
8112d308:	497ffb1e 	bne	r9,r5,8112d2f8 <__reset+0xfb10d2f8>
8112d30c:	d9800617 	ldw	r6,24(sp)
8112d310:	4a400044 	addi	r9,r9,1
8112d314:	00c00204 	movi	r3,8
8112d318:	19400c0e 	bge	r3,r5,8112d34c <_strtod_r+0x11ac>
8112d31c:	00800404 	movi	r2,16
8112d320:	000b883a 	mov	r5,zero
8112d324:	127ea316 	blt	r2,r9,8112cdb4 <__reset+0xfb10cdb4>
8112d328:	988002a4 	muli	r2,r19,10
8112d32c:	20a7883a 	add	r19,r4,r2
8112d330:	003ea006 	br	8112cdb4 <__reset+0xfb10cdb4>
8112d334:	d8800617 	ldw	r2,24(sp)
8112d338:	8c7ff404 	addi	r17,r17,-48
8112d33c:	2a800044 	addi	r10,r5,1
8112d340:	d8800815 	stw	r2,32(sp)
8112d344:	100d883a 	mov	r6,r2
8112d348:	02400044 	movi	r9,1
8112d34c:	e08002a4 	muli	r2,fp,10
8112d350:	000b883a 	mov	r5,zero
8112d354:	88b9883a 	add	fp,r17,r2
8112d358:	003e9606 	br	8112cdb4 <__reset+0xfb10cdb4>
8112d35c:	3a7fea16 	blt	r7,r9,8112d308 <__reset+0xfb10d308>
8112d360:	9cc002a4 	muli	r19,r19,10
8112d364:	003fe806 	br	8112d308 <__reset+0xfb10d308>
8112d368:	00bffa84 	movi	r2,-22
8112d36c:	a8bd1016 	blt	r21,r2,8112c7b0 <__reset+0xfb10c7b0>
8112d370:	a82a90fa 	slli	r21,r21,3
8112d374:	00a04574 	movhi	r2,33045
8112d378:	10b93704 	addi	r2,r2,-6948
8112d37c:	1545c83a 	sub	r2,r2,r21
8112d380:	11800017 	ldw	r6,0(r2)
8112d384:	11c00117 	ldw	r7,4(r2)
8112d388:	9009883a 	mov	r4,r18
8112d38c:	880b883a 	mov	r5,r17
8112d390:	11337840 	call	81133784 <__divdf3>
8112d394:	102b883a 	mov	r21,r2
8112d398:	182d883a 	mov	r22,r3
8112d39c:	003c4a06 	br	8112c4c8 <__reset+0xfb10c4c8>
8112d3a0:	dd000a15 	stw	r20,40(sp)
8112d3a4:	a811883a 	mov	r8,r21
8112d3a8:	dd001217 	ldw	r20,72(sp)
8112d3ac:	003e9e06 	br	8112ce28 <__reset+0xfb10ce28>
8112d3b0:	01604574 	movhi	r5,33045
8112d3b4:	d9000617 	ldw	r4,24(sp)
8112d3b8:	29796904 	addi	r5,r5,-6748
8112d3bc:	01c00644 	movi	r7,25
8112d3c0:	00000b06 	br	8112d3f0 <_strtod_r+0x1250>
8112d3c4:	21000044 	addi	r4,r4,1
8112d3c8:	20800003 	ldbu	r2,0(r4)
8112d3cc:	10ffefc4 	addi	r3,r2,-65
8112d3d0:	10803fcc 	andi	r2,r2,255
8112d3d4:	1080201c 	xori	r2,r2,128
8112d3d8:	18c03fcc 	andi	r3,r3,255
8112d3dc:	10bfe004 	addi	r2,r2,-128
8112d3e0:	38c00136 	bltu	r7,r3,8112d3e8 <_strtod_r+0x1248>
8112d3e4:	10800804 	addi	r2,r2,32
8112d3e8:	29400044 	addi	r5,r5,1
8112d3ec:	11bbbb1e 	bne	r2,r6,8112c2dc <__reset+0xfb10c2dc>
8112d3f0:	29800007 	ldb	r6,0(r5)
8112d3f4:	303ff31e 	bne	r6,zero,8112d3c4 <__reset+0xfb10d3c4>
8112d3f8:	01a04574 	movhi	r6,33045
8112d3fc:	d9000615 	stw	r4,24(sp)
8112d400:	31b96a04 	addi	r6,r6,-6744
8112d404:	200b883a 	mov	r5,r4
8112d408:	02000644 	movi	r8,25
8112d40c:	00000a06 	br	8112d438 <_strtod_r+0x1298>
8112d410:	28800003 	ldbu	r2,0(r5)
8112d414:	10ffefc4 	addi	r3,r2,-65
8112d418:	10803fcc 	andi	r2,r2,255
8112d41c:	1080201c 	xori	r2,r2,128
8112d420:	18c03fcc 	andi	r3,r3,255
8112d424:	10bfe004 	addi	r2,r2,-128
8112d428:	40c00136 	bltu	r8,r3,8112d430 <_strtod_r+0x1290>
8112d42c:	10800804 	addi	r2,r2,32
8112d430:	31800044 	addi	r6,r6,1
8112d434:	11c0711e 	bne	r2,r7,8112d5fc <_strtod_r+0x145c>
8112d438:	31c00007 	ldb	r7,0(r6)
8112d43c:	29400044 	addi	r5,r5,1
8112d440:	383ff31e 	bne	r7,zero,8112d410 <__reset+0xfb10d410>
8112d444:	d9400615 	stw	r5,24(sp)
8112d448:	045ffc34 	movhi	r17,32752
8112d44c:	0025883a 	mov	r18,zero
8112d450:	003c1b06 	br	8112c4c0 <__reset+0xfb10c4c0>
8112d454:	000b883a 	mov	r5,zero
8112d458:	003ccc06 	br	8112c78c <__reset+0xfb10c78c>
8112d45c:	d9400e17 	ldw	r5,56(sp)
8112d460:	dd000a15 	stw	r20,40(sp)
8112d464:	00800434 	movhi	r2,16
8112d468:	a811883a 	mov	r8,r21
8112d46c:	dd001217 	ldw	r20,72(sp)
8112d470:	dd401117 	ldw	r21,68(sp)
8112d474:	dd801017 	ldw	r22,64(sp)
8112d478:	10bfffc4 	addi	r2,r2,-1
8112d47c:	28005626 	beq	r5,zero,8112d5d8 <_strtod_r+0x1438>
8112d480:	8886703a 	and	r3,r17,r2
8112d484:	18807826 	beq	r3,r2,8112d668 <_strtod_r+0x14c8>
8112d488:	d8c00b17 	ldw	r3,44(sp)
8112d48c:	18005726 	beq	r3,zero,8112d5ec <_strtod_r+0x144c>
8112d490:	1c44703a 	and	r2,r3,r17
8112d494:	10000f26 	beq	r2,zero,8112d4d4 <_strtod_r+0x1334>
8112d498:	d9000e17 	ldw	r4,56(sp)
8112d49c:	d9800917 	ldw	r6,36(sp)
8112d4a0:	20005e26 	beq	r4,zero,8112d61c <_strtod_r+0x147c>
8112d4a4:	9009883a 	mov	r4,r18
8112d4a8:	880b883a 	mov	r5,r17
8112d4ac:	da001315 	stw	r8,76(sp)
8112d4b0:	112c1340 	call	8112c134 <sulp>
8112d4b4:	100d883a 	mov	r6,r2
8112d4b8:	180f883a 	mov	r7,r3
8112d4bc:	9009883a 	mov	r4,r18
8112d4c0:	880b883a 	mov	r5,r17
8112d4c4:	1132ed00 	call	81132ed0 <__adddf3>
8112d4c8:	da001317 	ldw	r8,76(sp)
8112d4cc:	102b883a 	mov	r21,r2
8112d4d0:	182d883a 	mov	r22,r3
8112d4d4:	d8c00917 	ldw	r3,36(sp)
8112d4d8:	18000f26 	beq	r3,zero,8112d518 <_strtod_r+0x1378>
8112d4dc:	a809883a 	mov	r4,r21
8112d4e0:	b00b883a 	mov	r5,r22
8112d4e4:	000d883a 	mov	r6,zero
8112d4e8:	01ce5434 	movhi	r7,14672
8112d4ec:	da001315 	stw	r8,76(sp)
8112d4f0:	111dff40 	call	8111dff4 <__muldf3>
8112d4f4:	102b883a 	mov	r21,r2
8112d4f8:	182d883a 	mov	r22,r3
8112d4fc:	da001317 	ldw	r8,76(sp)
8112d500:	1800051e 	bne	r3,zero,8112d518 <_strtod_r+0x1378>
8112d504:	d8800517 	ldw	r2,20(sp)
8112d508:	a83e4b1e 	bne	r21,zero,8112ce38 <__reset+0xfb10ce38>
8112d50c:	00c00884 	movi	r3,34
8112d510:	80c00015 	stw	r3,0(r16)
8112d514:	003e4806 	br	8112ce38 <__reset+0xfb10ce38>
8112d518:	d8800517 	ldw	r2,20(sp)
8112d51c:	003e4606 	br	8112ce38 <__reset+0xfb10ce38>
8112d520:	d9000e17 	ldw	r4,56(sp)
8112d524:	dd000a15 	stw	r20,40(sp)
8112d528:	a811883a 	mov	r8,r21
8112d52c:	dd001217 	ldw	r20,72(sp)
8112d530:	dd401117 	ldw	r21,68(sp)
8112d534:	dd801017 	ldw	r22,64(sp)
8112d538:	203fe61e 	bne	r4,zero,8112d4d4 <__reset+0xfb10d4d4>
8112d53c:	903fe51e 	bne	r18,zero,8112d4d4 <__reset+0xfb10d4d4>
8112d540:	00800434 	movhi	r2,16
8112d544:	10bfffc4 	addi	r2,r2,-1
8112d548:	8884703a 	and	r2,r17,r2
8112d54c:	103fe11e 	bne	r2,zero,8112d4d4 <__reset+0xfb10d4d4>
8112d550:	8ddffc2c 	andhi	r23,r17,32752
8112d554:	0081ac34 	movhi	r2,1712
8112d558:	15ffde2e 	bgeu	r2,r23,8112d4d4 <__reset+0xfb10d4d4>
8112d55c:	40800517 	ldw	r2,20(r8)
8112d560:	1000031e 	bne	r2,zero,8112d570 <_strtod_r+0x13d0>
8112d564:	40800417 	ldw	r2,16(r8)
8112d568:	00c00044 	movi	r3,1
8112d56c:	18bfd90e 	bge	r3,r2,8112d4d4 <__reset+0xfb10d4d4>
8112d570:	400b883a 	mov	r5,r8
8112d574:	01800044 	movi	r6,1
8112d578:	8009883a 	mov	r4,r16
8112d57c:	112b08c0 	call	8112b08c <__lshift>
8112d580:	980b883a 	mov	r5,r19
8112d584:	1009883a 	mov	r4,r2
8112d588:	d8801315 	stw	r2,76(sp)
8112d58c:	112b1dc0 	call	8112b1dc <__mcmp>
8112d590:	da001317 	ldw	r8,76(sp)
8112d594:	00bfcf0e 	bge	zero,r2,8112d4d4 <__reset+0xfb10d4d4>
8112d598:	d8c00917 	ldw	r3,36(sp)
8112d59c:	18005c26 	beq	r3,zero,8112d710 <_strtod_r+0x1570>
8112d5a0:	0081ac34 	movhi	r2,1712
8112d5a4:	15c05a16 	blt	r2,r23,8112d710 <_strtod_r+0x1570>
8112d5a8:	0080dc34 	movhi	r2,880
8112d5ac:	15ffcb16 	blt	r2,r23,8112d4dc <__reset+0xfb10d4dc>
8112d5b0:	003f1106 	br	8112d1f8 <__reset+0xfb10d1f8>
8112d5b4:	002d883a 	mov	r22,zero
8112d5b8:	022ff834 	movhi	r8,49120
8112d5bc:	d8000d15 	stw	zero,52(sp)
8112d5c0:	05cff834 	movhi	r23,16352
8112d5c4:	003ded06 	br	8112cd7c <__reset+0xfb10cd7c>
8112d5c8:	0440d434 	movhi	r17,848
8112d5cc:	1c63883a 	add	r17,r3,r17
8112d5d0:	d8000915 	stw	zero,36(sp)
8112d5d4:	003cc806 	br	8112c8f8 <__reset+0xfb10c8f8>
8112d5d8:	8884703a 	and	r2,r17,r2
8112d5dc:	103faa1e 	bne	r2,zero,8112d488 <__reset+0xfb10d488>
8112d5e0:	903fa91e 	bne	r18,zero,8112d488 <__reset+0xfb10d488>
8112d5e4:	8ddffc2c 	andhi	r23,r17,32752
8112d5e8:	003feb06 	br	8112d598 <__reset+0xfb10d598>
8112d5ec:	d8c00d17 	ldw	r3,52(sp)
8112d5f0:	1cae703a 	and	r23,r3,r18
8112d5f4:	b83fb726 	beq	r23,zero,8112d4d4 <__reset+0xfb10d4d4>
8112d5f8:	003fa706 	br	8112d498 <__reset+0xfb10d498>
8112d5fc:	21000044 	addi	r4,r4,1
8112d600:	d9000615 	stw	r4,24(sp)
8112d604:	003f9006 	br	8112d448 <__reset+0xfb10d448>
8112d608:	01604574 	movhi	r5,33045
8112d60c:	29792d04 	addi	r5,r5,-6988
8112d610:	d9400915 	stw	r5,36(sp)
8112d614:	0027883a 	mov	r19,zero
8112d618:	003ca206 	br	8112c8a4 <__reset+0xfb10c8a4>
8112d61c:	9009883a 	mov	r4,r18
8112d620:	880b883a 	mov	r5,r17
8112d624:	da001315 	stw	r8,76(sp)
8112d628:	112c1340 	call	8112c134 <sulp>
8112d62c:	100d883a 	mov	r6,r2
8112d630:	180f883a 	mov	r7,r3
8112d634:	9009883a 	mov	r4,r18
8112d638:	880b883a 	mov	r5,r17
8112d63c:	111e7140 	call	8111e714 <__subdf3>
8112d640:	000d883a 	mov	r6,zero
8112d644:	000f883a 	mov	r7,zero
8112d648:	1009883a 	mov	r4,r2
8112d64c:	180b883a 	mov	r5,r3
8112d650:	102b883a 	mov	r21,r2
8112d654:	182d883a 	mov	r22,r3
8112d658:	11340740 	call	81134074 <__eqdf2>
8112d65c:	da001317 	ldw	r8,76(sp)
8112d660:	103ee526 	beq	r2,zero,8112d1f8 <__reset+0xfb10d1f8>
8112d664:	003f9b06 	br	8112d4d4 <__reset+0xfb10d4d4>
8112d668:	d8800917 	ldw	r2,36(sp)
8112d66c:	10002226 	beq	r2,zero,8112d6f8 <_strtod_r+0x1558>
8112d670:	889ffc2c 	andhi	r2,r17,32752
8112d674:	00c1a834 	movhi	r3,1696
8112d678:	18801f36 	bltu	r3,r2,8112d6f8 <_strtod_r+0x1558>
8112d67c:	1004d53a 	srli	r2,r2,20
8112d680:	00c01ac4 	movi	r3,107
8112d684:	1887c83a 	sub	r3,r3,r2
8112d688:	00bfffc4 	movi	r2,-1
8112d68c:	10c4983a 	sll	r2,r2,r3
8112d690:	14bf7d1e 	bne	r2,r18,8112d488 <__reset+0xfb10d488>
8112d694:	00dffc34 	movhi	r3,32752
8112d698:	18ffffc4 	addi	r3,r3,-1
8112d69c:	88c03526 	beq	r17,r3,8112d774 <_strtod_r+0x15d4>
8112d6a0:	8c5ffc2c 	andhi	r17,r17,32752
8112d6a4:	00800434 	movhi	r2,16
8112d6a8:	002b883a 	mov	r21,zero
8112d6ac:	88ad883a 	add	r22,r17,r2
8112d6b0:	003f8806 	br	8112d4d4 <__reset+0xfb10d4d4>
8112d6b4:	01401a84 	movi	r5,106
8112d6b8:	d9400915 	stw	r5,36(sp)
8112d6bc:	8ddffc2c 	andhi	r23,r17,32752
8112d6c0:	b82ed53a 	srli	r23,r23,20
8112d6c4:	00801ac4 	movi	r2,107
8112d6c8:	15c5c83a 	sub	r2,r2,r23
8112d6cc:	00be8e0e 	bge	zero,r2,8112d108 <__reset+0xfb10d108>
8112d6d0:	00c007c4 	movi	r3,31
8112d6d4:	18800a0e 	bge	r3,r2,8112d700 <_strtod_r+0x1560>
8112d6d8:	00c00d04 	movi	r3,52
8112d6dc:	0025883a 	mov	r18,zero
8112d6e0:	1880270e 	bge	r3,r2,8112d780 <_strtod_r+0x15e0>
8112d6e4:	0440dc34 	movhi	r17,880
8112d6e8:	003e8706 	br	8112d108 <__reset+0xfb10d108>
8112d6ec:	d8000915 	stw	zero,36(sp)
8112d6f0:	05fe6a16 	blt	zero,r23,8112d09c <__reset+0xfb10d09c>
8112d6f4:	003e8406 	br	8112d108 <__reset+0xfb10d108>
8112d6f8:	00bfffc4 	movi	r2,-1
8112d6fc:	003fe406 	br	8112d690 <__reset+0xfb10d690>
8112d700:	00ffffc4 	movi	r3,-1
8112d704:	1884983a 	sll	r2,r3,r2
8112d708:	14a4703a 	and	r18,r2,r18
8112d70c:	003e7e06 	br	8112d108 <__reset+0xfb10d108>
8112d710:	00bffc34 	movhi	r2,65520
8112d714:	b8af883a 	add	r23,r23,r2
8112d718:	057fffc4 	movi	r21,-1
8112d71c:	00800434 	movhi	r2,16
8112d720:	1545883a 	add	r2,r2,r21
8112d724:	b8acb03a 	or	r22,r23,r2
8112d728:	003f6a06 	br	8112d4d4 <__reset+0xfb10d4d4>
8112d72c:	01604574 	movhi	r5,33045
8112d730:	29796d04 	addi	r5,r5,-6732
8112d734:	d9800204 	addi	r6,sp,8
8112d738:	d9000604 	addi	r4,sp,24
8112d73c:	1131b2c0 	call	81131b2c <__hexnan>
8112d740:	00c00144 	movi	r3,5
8112d744:	10fb5c1e 	bne	r2,r3,8112c4b8 <__reset+0xfb10c4b8>
8112d748:	dc400317 	ldw	r17,12(sp)
8112d74c:	dc800217 	ldw	r18,8(sp)
8112d750:	8c5ffc34 	orhi	r17,r17,32752
8112d754:	003b5a06 	br	8112c4c0 <__reset+0xfb10c4c0>
8112d758:	480b883a 	mov	r5,r9
8112d75c:	d9800617 	ldw	r6,24(sp)
8112d760:	4a400044 	addi	r9,r9,1
8112d764:	003eeb06 	br	8112d314 <__reset+0xfb10d314>
8112d768:	1025883a 	mov	r18,r2
8112d76c:	1823883a 	mov	r17,r3
8112d770:	003c4c06 	br	8112c8a4 <__reset+0xfb10c8a4>
8112d774:	00ffffc4 	movi	r3,-1
8112d778:	10ffc91e 	bne	r2,r3,8112d6a0 <__reset+0xfb10d6a0>
8112d77c:	003da906 	br	8112ce24 <__reset+0xfb10ce24>
8112d780:	10bff804 	addi	r2,r2,-32
8112d784:	00ffffc4 	movi	r3,-1
8112d788:	1884983a 	sll	r2,r3,r2
8112d78c:	1462703a 	and	r17,r2,r17
8112d790:	003e5d06 	br	8112d108 <__reset+0xfb10d108>
8112d794:	1025883a 	mov	r18,r2
8112d798:	1823883a 	mov	r17,r3
8112d79c:	003e5806 	br	8112d100 <__reset+0xfb10d100>

8112d7a0 <strtod>:
8112d7a0:	00a04574 	movhi	r2,33045
8112d7a4:	1082c604 	addi	r2,r2,2840
8112d7a8:	280d883a 	mov	r6,r5
8112d7ac:	200b883a 	mov	r5,r4
8112d7b0:	11000017 	ldw	r4,0(r2)
8112d7b4:	112c1a01 	jmpi	8112c1a0 <_strtod_r>

8112d7b8 <strtof>:
8112d7b8:	defffb04 	addi	sp,sp,-20
8112d7bc:	de00012e 	bgeu	sp,et,8112d7c4 <strtof+0xc>
8112d7c0:	003b68fa 	trap	3
8112d7c4:	dcc00315 	stw	r19,12(sp)
8112d7c8:	04e04574 	movhi	r19,33045
8112d7cc:	9cc2c604 	addi	r19,r19,2840
8112d7d0:	280d883a 	mov	r6,r5
8112d7d4:	200b883a 	mov	r5,r4
8112d7d8:	99000017 	ldw	r4,0(r19)
8112d7dc:	dfc00415 	stw	ra,16(sp)
8112d7e0:	dc800215 	stw	r18,8(sp)
8112d7e4:	dc400115 	stw	r17,4(sp)
8112d7e8:	dc000015 	stw	r16,0(sp)
8112d7ec:	112c1a00 	call	8112c1a0 <_strtod_r>
8112d7f0:	1009883a 	mov	r4,r2
8112d7f4:	180b883a 	mov	r5,r3
8112d7f8:	1025883a 	mov	r18,r2
8112d7fc:	1823883a 	mov	r17,r3
8112d800:	111f2940 	call	8111f294 <__truncdfsf2>
8112d804:	000b883a 	mov	r5,zero
8112d808:	1009883a 	mov	r4,r2
8112d80c:	1021883a 	mov	r16,r2
8112d810:	1132cd40 	call	81132cd4 <__eqsf2>
8112d814:	1000111e 	bne	r2,zero,8112d85c <strtof+0xa4>
8112d818:	000d883a 	mov	r6,zero
8112d81c:	000f883a 	mov	r7,zero
8112d820:	9009883a 	mov	r4,r18
8112d824:	880b883a 	mov	r5,r17
8112d828:	11340740 	call	81134074 <__eqdf2>
8112d82c:	10000b26 	beq	r2,zero,8112d85c <strtof+0xa4>
8112d830:	98800017 	ldw	r2,0(r19)
8112d834:	00c00884 	movi	r3,34
8112d838:	10c00015 	stw	r3,0(r2)
8112d83c:	8005883a 	mov	r2,r16
8112d840:	dfc00417 	ldw	ra,16(sp)
8112d844:	dcc00317 	ldw	r19,12(sp)
8112d848:	dc800217 	ldw	r18,8(sp)
8112d84c:	dc400117 	ldw	r17,4(sp)
8112d850:	dc000017 	ldw	r16,0(sp)
8112d854:	dec00504 	addi	sp,sp,20
8112d858:	f800283a 	ret
8112d85c:	015fe034 	movhi	r5,32640
8112d860:	297fffc4 	addi	r5,r5,-1
8112d864:	8009883a 	mov	r4,r16
8112d868:	1132d4c0 	call	81132d4c <__gesf2>
8112d86c:	0080070e 	bge	zero,r2,8112d88c <strtof+0xd4>
8112d870:	01dffc34 	movhi	r7,32752
8112d874:	39ffffc4 	addi	r7,r7,-1
8112d878:	01bfffc4 	movi	r6,-1
8112d87c:	9009883a 	mov	r4,r18
8112d880:	880b883a 	mov	r5,r17
8112d884:	111df180 	call	8111df18 <__gedf2>
8112d888:	00bfe90e 	bge	zero,r2,8112d830 <__reset+0xfb10d830>
8112d88c:	017fe034 	movhi	r5,65408
8112d890:	297fffc4 	addi	r5,r5,-1
8112d894:	8009883a 	mov	r4,r16
8112d898:	1132e080 	call	81132e08 <__lesf2>
8112d89c:	103fe70e 	bge	r2,zero,8112d83c <__reset+0xfb10d83c>
8112d8a0:	01fffc34 	movhi	r7,65520
8112d8a4:	39ffffc4 	addi	r7,r7,-1
8112d8a8:	01bfffc4 	movi	r6,-1
8112d8ac:	9009883a 	mov	r4,r18
8112d8b0:	880b883a 	mov	r5,r17
8112d8b4:	11340fc0 	call	811340fc <__ledf2>
8112d8b8:	103fdd0e 	bge	r2,zero,8112d830 <__reset+0xfb10d830>
8112d8bc:	003fdf06 	br	8112d83c <__reset+0xfb10d83c>

8112d8c0 <_strtoll_r>:
8112d8c0:	00a04574 	movhi	r2,33045
8112d8c4:	defff304 	addi	sp,sp,-52
8112d8c8:	1082c404 	addi	r2,r2,2832
8112d8cc:	de00012e 	bgeu	sp,et,8112d8d4 <_strtoll_r+0x14>
8112d8d0:	003b68fa 	trap	3
8112d8d4:	dc800515 	stw	r18,20(sp)
8112d8d8:	14800017 	ldw	r18,0(r2)
8112d8dc:	dd800915 	stw	r22,36(sp)
8112d8e0:	dd400815 	stw	r21,32(sp)
8112d8e4:	dcc00615 	stw	r19,24(sp)
8112d8e8:	d9000015 	stw	r4,0(sp)
8112d8ec:	dfc00c15 	stw	ra,48(sp)
8112d8f0:	df000b15 	stw	fp,44(sp)
8112d8f4:	ddc00a15 	stw	r23,40(sp)
8112d8f8:	dd000715 	stw	r20,28(sp)
8112d8fc:	dc400415 	stw	r17,16(sp)
8112d900:	dc000315 	stw	r16,12(sp)
8112d904:	282d883a 	mov	r22,r5
8112d908:	302b883a 	mov	r21,r6
8112d90c:	3827883a 	mov	r19,r7
8112d910:	2809883a 	mov	r4,r5
8112d914:	24000003 	ldbu	r16,0(r4)
8112d918:	24400044 	addi	r17,r4,1
8112d91c:	2007883a 	mov	r3,r4
8112d920:	9405883a 	add	r2,r18,r16
8112d924:	10800043 	ldbu	r2,1(r2)
8112d928:	8809883a 	mov	r4,r17
8112d92c:	1080020c 	andi	r2,r2,8
8112d930:	103ff81e 	bne	r2,zero,8112d914 <__reset+0xfb10d914>
8112d934:	00800b44 	movi	r2,45
8112d938:	80807826 	beq	r16,r2,8112db1c <_strtoll_r+0x25c>
8112d93c:	00800ac4 	movi	r2,43
8112d940:	80807a26 	beq	r16,r2,8112db2c <_strtoll_r+0x26c>
8112d944:	0039883a 	mov	fp,zero
8112d948:	98004e26 	beq	r19,zero,8112da84 <_strtoll_r+0x1c4>
8112d94c:	00800404 	movi	r2,16
8112d950:	98808226 	beq	r19,r2,8112db5c <_strtoll_r+0x29c>
8112d954:	982fd7fa 	srai	r23,r19,31
8112d958:	9829883a 	mov	r20,r19
8112d95c:	e0004f26 	beq	fp,zero,8112da9c <_strtoll_r+0x1dc>
8112d960:	0017883a 	mov	r11,zero
8112d964:	02a00034 	movhi	r10,32768
8112d968:	5809883a 	mov	r4,r11
8112d96c:	500b883a 	mov	r5,r10
8112d970:	a00d883a 	mov	r6,r20
8112d974:	b80f883a 	mov	r7,r23
8112d978:	da800215 	stw	r10,8(sp)
8112d97c:	dac00115 	stw	r11,4(sp)
8112d980:	11325e00 	call	811325e0 <__umoddi3>
8112d984:	dac00117 	ldw	r11,4(sp)
8112d988:	da800217 	ldw	r10,8(sp)
8112d98c:	a00d883a 	mov	r6,r20
8112d990:	5809883a 	mov	r4,r11
8112d994:	500b883a 	mov	r5,r10
8112d998:	b80f883a 	mov	r7,r23
8112d99c:	d8800115 	stw	r2,4(sp)
8112d9a0:	11320600 	call	81132060 <__udivdi3>
8112d9a4:	9409883a 	add	r4,r18,r16
8112d9a8:	21000043 	ldbu	r4,1(r4)
8112d9ac:	1019883a 	mov	r12,r2
8112d9b0:	880b883a 	mov	r5,r17
8112d9b4:	2240010c 	andi	r9,r4,4
8112d9b8:	0015883a 	mov	r10,zero
8112d9bc:	000d883a 	mov	r6,zero
8112d9c0:	000f883a 	mov	r7,zero
8112d9c4:	03400044 	movi	r13,1
8112d9c8:	02ffffc4 	movi	r11,-1
8112d9cc:	da000117 	ldw	r8,4(sp)
8112d9d0:	48000d26 	beq	r9,zero,8112da08 <_strtoll_r+0x148>
8112d9d4:	843ff404 	addi	r16,r16,-48
8112d9d8:	84c0110e 	bge	r16,r19,8112da20 <_strtoll_r+0x160>
8112d9dc:	52c00426 	beq	r10,r11,8112d9f0 <_strtoll_r+0x130>
8112d9e0:	19c00236 	bltu	r3,r7,8112d9ec <_strtoll_r+0x12c>
8112d9e4:	38c0311e 	bne	r7,r3,8112daac <_strtoll_r+0x1ec>
8112d9e8:	6180302e 	bgeu	r12,r6,8112daac <_strtoll_r+0x1ec>
8112d9ec:	02bfffc4 	movi	r10,-1
8112d9f0:	2c000003 	ldbu	r16,0(r5)
8112d9f4:	29400044 	addi	r5,r5,1
8112d9f8:	9409883a 	add	r4,r18,r16
8112d9fc:	21000043 	ldbu	r4,1(r4)
8112da00:	2240010c 	andi	r9,r4,4
8112da04:	483ff31e 	bne	r9,zero,8112d9d4 <__reset+0xfb10d9d4>
8112da08:	210000cc 	andi	r4,r4,3
8112da0c:	20000426 	beq	r4,zero,8112da20 <_strtoll_r+0x160>
8112da10:	23403426 	beq	r4,r13,8112dae4 <_strtoll_r+0x224>
8112da14:	008015c4 	movi	r2,87
8112da18:	80a1c83a 	sub	r16,r16,r2
8112da1c:	84ffef16 	blt	r16,r19,8112d9dc <__reset+0xfb10d9dc>
8112da20:	00bfffc4 	movi	r2,-1
8112da24:	50803426 	beq	r10,r2,8112daf8 <_strtoll_r+0x238>
8112da28:	e0000426 	beq	fp,zero,8112da3c <_strtoll_r+0x17c>
8112da2c:	018dc83a 	sub	r6,zero,r6
8112da30:	3004c03a 	cmpne	r2,r6,zero
8112da34:	01e1c83a 	sub	r16,zero,r7
8112da38:	808fc83a 	sub	r7,r16,r2
8112da3c:	3005883a 	mov	r2,r6
8112da40:	3807883a 	mov	r3,r7
8112da44:	a8000326 	beq	r21,zero,8112da54 <_strtoll_r+0x194>
8112da48:	5000321e 	bne	r10,zero,8112db14 <_strtoll_r+0x254>
8112da4c:	b00b883a 	mov	r5,r22
8112da50:	a9400015 	stw	r5,0(r21)
8112da54:	dfc00c17 	ldw	ra,48(sp)
8112da58:	df000b17 	ldw	fp,44(sp)
8112da5c:	ddc00a17 	ldw	r23,40(sp)
8112da60:	dd800917 	ldw	r22,36(sp)
8112da64:	dd400817 	ldw	r21,32(sp)
8112da68:	dd000717 	ldw	r20,28(sp)
8112da6c:	dcc00617 	ldw	r19,24(sp)
8112da70:	dc800517 	ldw	r18,20(sp)
8112da74:	dc400417 	ldw	r17,16(sp)
8112da78:	dc000317 	ldw	r16,12(sp)
8112da7c:	dec00d04 	addi	sp,sp,52
8112da80:	f800283a 	ret
8112da84:	00800c04 	movi	r2,48
8112da88:	80802c26 	beq	r16,r2,8112db3c <_strtoll_r+0x27c>
8112da8c:	05000284 	movi	r20,10
8112da90:	002f883a 	mov	r23,zero
8112da94:	a027883a 	mov	r19,r20
8112da98:	e03fb11e 	bne	fp,zero,8112d960 <__reset+0xfb10d960>
8112da9c:	02a00034 	movhi	r10,32768
8112daa0:	52bfffc4 	addi	r10,r10,-1
8112daa4:	02ffffc4 	movi	r11,-1
8112daa8:	003faf06 	br	8112d968 <__reset+0xfb10d968>
8112daac:	33000f26 	beq	r6,r12,8112daec <_strtoll_r+0x22c>
8112dab0:	b985383a 	mul	r2,r23,r6
8112dab4:	3d0f383a 	mul	r7,r7,r20
8112dab8:	3508383a 	mulxuu	r4,r6,r20
8112dabc:	350d383a 	mul	r6,r6,r20
8112dac0:	8013d7fa 	srai	r9,r16,31
8112dac4:	388f883a 	add	r7,r7,r2
8112dac8:	818d883a 	add	r6,r16,r6
8112dacc:	390f883a 	add	r7,r7,r4
8112dad0:	3421803a 	cmpltu	r16,r6,r16
8112dad4:	49cf883a 	add	r7,r9,r7
8112dad8:	81cf883a 	add	r7,r16,r7
8112dadc:	02800044 	movi	r10,1
8112dae0:	003fc306 	br	8112d9f0 <__reset+0xfb10d9f0>
8112dae4:	00800dc4 	movi	r2,55
8112dae8:	003fcb06 	br	8112da18 <__reset+0xfb10da18>
8112daec:	38fff01e 	bne	r7,r3,8112dab0 <__reset+0xfb10dab0>
8112daf0:	443fbe16 	blt	r8,r16,8112d9ec <__reset+0xfb10d9ec>
8112daf4:	003fee06 	br	8112dab0 <__reset+0xfb10dab0>
8112daf8:	e0002426 	beq	fp,zero,8112db8c <_strtoll_r+0x2cc>
8112dafc:	0005883a 	mov	r2,zero
8112db00:	00e00034 	movhi	r3,32768
8112db04:	d9800017 	ldw	r6,0(sp)
8112db08:	01000884 	movi	r4,34
8112db0c:	31000015 	stw	r4,0(r6)
8112db10:	a83fd026 	beq	r21,zero,8112da54 <__reset+0xfb10da54>
8112db14:	297fffc4 	addi	r5,r5,-1
8112db18:	003fcd06 	br	8112da50 <__reset+0xfb10da50>
8112db1c:	1c400084 	addi	r17,r3,2
8112db20:	1c000043 	ldbu	r16,1(r3)
8112db24:	07000044 	movi	fp,1
8112db28:	003f8706 	br	8112d948 <__reset+0xfb10d948>
8112db2c:	1c400084 	addi	r17,r3,2
8112db30:	1c000043 	ldbu	r16,1(r3)
8112db34:	0039883a 	mov	fp,zero
8112db38:	003f8306 	br	8112d948 <__reset+0xfb10d948>
8112db3c:	88800003 	ldbu	r2,0(r17)
8112db40:	00c01604 	movi	r3,88
8112db44:	108037cc 	andi	r2,r2,223
8112db48:	10c00a26 	beq	r2,r3,8112db74 <_strtoll_r+0x2b4>
8112db4c:	05000204 	movi	r20,8
8112db50:	002f883a 	mov	r23,zero
8112db54:	a027883a 	mov	r19,r20
8112db58:	003f8006 	br	8112d95c <__reset+0xfb10d95c>
8112db5c:	00800c04 	movi	r2,48
8112db60:	80800e1e 	bne	r16,r2,8112db9c <_strtoll_r+0x2dc>
8112db64:	88800003 	ldbu	r2,0(r17)
8112db68:	00c01604 	movi	r3,88
8112db6c:	108037cc 	andi	r2,r2,223
8112db70:	10c00a1e 	bne	r2,r3,8112db9c <_strtoll_r+0x2dc>
8112db74:	05000404 	movi	r20,16
8112db78:	8c000043 	ldbu	r16,1(r17)
8112db7c:	002f883a 	mov	r23,zero
8112db80:	8c400084 	addi	r17,r17,2
8112db84:	a027883a 	mov	r19,r20
8112db88:	003f7406 	br	8112d95c <__reset+0xfb10d95c>
8112db8c:	00e00034 	movhi	r3,32768
8112db90:	18ffffc4 	addi	r3,r3,-1
8112db94:	5005883a 	mov	r2,r10
8112db98:	003fda06 	br	8112db04 <__reset+0xfb10db04>
8112db9c:	9829883a 	mov	r20,r19
8112dba0:	002f883a 	mov	r23,zero
8112dba4:	003f6d06 	br	8112d95c <__reset+0xfb10d95c>

8112dba8 <_strtoul_r>:
8112dba8:	00a04574 	movhi	r2,33045
8112dbac:	defff604 	addi	sp,sp,-40
8112dbb0:	1082c404 	addi	r2,r2,2832
8112dbb4:	de00012e 	bgeu	sp,et,8112dbbc <_strtoul_r+0x14>
8112dbb8:	003b68fa 	trap	3
8112dbbc:	dc800315 	stw	r18,12(sp)
8112dbc0:	14800017 	ldw	r18,0(r2)
8112dbc4:	dd400615 	stw	r21,24(sp)
8112dbc8:	dd000515 	stw	r20,20(sp)
8112dbcc:	dcc00415 	stw	r19,16(sp)
8112dbd0:	2029883a 	mov	r20,r4
8112dbd4:	dfc00915 	stw	ra,36(sp)
8112dbd8:	ddc00815 	stw	r23,32(sp)
8112dbdc:	dd800715 	stw	r22,28(sp)
8112dbe0:	dc400215 	stw	r17,8(sp)
8112dbe4:	dc000115 	stw	r16,4(sp)
8112dbe8:	2827883a 	mov	r19,r5
8112dbec:	382b883a 	mov	r21,r7
8112dbf0:	2809883a 	mov	r4,r5
8112dbf4:	24000003 	ldbu	r16,0(r4)
8112dbf8:	24400044 	addi	r17,r4,1
8112dbfc:	2007883a 	mov	r3,r4
8112dc00:	9405883a 	add	r2,r18,r16
8112dc04:	10800043 	ldbu	r2,1(r2)
8112dc08:	8809883a 	mov	r4,r17
8112dc0c:	1080020c 	andi	r2,r2,8
8112dc10:	103ff81e 	bne	r2,zero,8112dbf4 <__reset+0xfb10dbf4>
8112dc14:	00800b44 	movi	r2,45
8112dc18:	80805326 	beq	r16,r2,8112dd68 <_strtoul_r+0x1c0>
8112dc1c:	00800ac4 	movi	r2,43
8112dc20:	80805526 	beq	r16,r2,8112dd78 <_strtoul_r+0x1d0>
8112dc24:	002f883a 	mov	r23,zero
8112dc28:	a8000f26 	beq	r21,zero,8112dc68 <_strtoul_r+0xc0>
8112dc2c:	00800404 	movi	r2,16
8112dc30:	a8805f26 	beq	r21,r2,8112ddb0 <_strtoul_r+0x208>
8112dc34:	013fffc4 	movi	r4,-1
8112dc38:	a80b883a 	mov	r5,r21
8112dc3c:	d9800015 	stw	r6,0(sp)
8112dc40:	1132c180 	call	81132c18 <__udivsi3>
8112dc44:	a80b883a 	mov	r5,r21
8112dc48:	013fffc4 	movi	r4,-1
8112dc4c:	102d883a 	mov	r22,r2
8112dc50:	1132c7c0 	call	81132c7c <__umodsi3>
8112dc54:	d9800017 	ldw	r6,0(sp)
8112dc58:	1019883a 	mov	r12,r2
8112dc5c:	a817883a 	mov	r11,r21
8112dc60:	b00f883a 	mov	r7,r22
8112dc64:	00000706 	br	8112dc84 <_strtoul_r+0xdc>
8112dc68:	00800c04 	movi	r2,48
8112dc6c:	80804626 	beq	r16,r2,8112dd88 <_strtoul_r+0x1e0>
8112dc70:	05400284 	movi	r21,10
8112dc74:	01c666b4 	movhi	r7,6554
8112dc78:	03000144 	movi	r12,5
8112dc7c:	39e66644 	addi	r7,r7,-26215
8112dc80:	a817883a 	mov	r11,r21
8112dc84:	9407883a 	add	r3,r18,r16
8112dc88:	18c00043 	ldbu	r3,1(r3)
8112dc8c:	8809883a 	mov	r4,r17
8112dc90:	0011883a 	mov	r8,zero
8112dc94:	1940010c 	andi	r5,r3,4
8112dc98:	0005883a 	mov	r2,zero
8112dc9c:	02800044 	movi	r10,1
8112dca0:	027fffc4 	movi	r9,-1
8112dca4:	28000e26 	beq	r5,zero,8112dce0 <_strtoul_r+0x138>
8112dca8:	843ff404 	addi	r16,r16,-48
8112dcac:	8540120e 	bge	r16,r21,8112dcf8 <_strtoul_r+0x150>
8112dcb0:	42400526 	beq	r8,r9,8112dcc8 <_strtoul_r+0x120>
8112dcb4:	38802236 	bltu	r7,r2,8112dd40 <_strtoul_r+0x198>
8112dcb8:	11c02026 	beq	r2,r7,8112dd3c <_strtoul_r+0x194>
8112dcbc:	12c5383a 	mul	r2,r2,r11
8112dcc0:	02000044 	movi	r8,1
8112dcc4:	8085883a 	add	r2,r16,r2
8112dcc8:	24000003 	ldbu	r16,0(r4)
8112dccc:	21000044 	addi	r4,r4,1
8112dcd0:	9407883a 	add	r3,r18,r16
8112dcd4:	18c00043 	ldbu	r3,1(r3)
8112dcd8:	1940010c 	andi	r5,r3,4
8112dcdc:	283ff21e 	bne	r5,zero,8112dca8 <__reset+0xfb10dca8>
8112dce0:	18c000cc 	andi	r3,r3,3
8112dce4:	18000426 	beq	r3,zero,8112dcf8 <_strtoul_r+0x150>
8112dce8:	1a801726 	beq	r3,r10,8112dd48 <_strtoul_r+0x1a0>
8112dcec:	00c015c4 	movi	r3,87
8112dcf0:	80e1c83a 	sub	r16,r16,r3
8112dcf4:	857fee16 	blt	r16,r21,8112dcb0 <__reset+0xfb10dcb0>
8112dcf8:	40001516 	blt	r8,zero,8112dd50 <_strtoul_r+0x1a8>
8112dcfc:	b8000126 	beq	r23,zero,8112dd04 <_strtoul_r+0x15c>
8112dd00:	0085c83a 	sub	r2,zero,r2
8112dd04:	30000226 	beq	r6,zero,8112dd10 <_strtoul_r+0x168>
8112dd08:	4000151e 	bne	r8,zero,8112dd60 <_strtoul_r+0x1b8>
8112dd0c:	34c00015 	stw	r19,0(r6)
8112dd10:	dfc00917 	ldw	ra,36(sp)
8112dd14:	ddc00817 	ldw	r23,32(sp)
8112dd18:	dd800717 	ldw	r22,28(sp)
8112dd1c:	dd400617 	ldw	r21,24(sp)
8112dd20:	dd000517 	ldw	r20,20(sp)
8112dd24:	dcc00417 	ldw	r19,16(sp)
8112dd28:	dc800317 	ldw	r18,12(sp)
8112dd2c:	dc400217 	ldw	r17,8(sp)
8112dd30:	dc000117 	ldw	r16,4(sp)
8112dd34:	dec00a04 	addi	sp,sp,40
8112dd38:	f800283a 	ret
8112dd3c:	643fdf0e 	bge	r12,r16,8112dcbc <__reset+0xfb10dcbc>
8112dd40:	023fffc4 	movi	r8,-1
8112dd44:	003fe006 	br	8112dcc8 <__reset+0xfb10dcc8>
8112dd48:	00c00dc4 	movi	r3,55
8112dd4c:	003fe806 	br	8112dcf0 <__reset+0xfb10dcf0>
8112dd50:	00800884 	movi	r2,34
8112dd54:	a0800015 	stw	r2,0(r20)
8112dd58:	00bfffc4 	movi	r2,-1
8112dd5c:	303fec26 	beq	r6,zero,8112dd10 <__reset+0xfb10dd10>
8112dd60:	24ffffc4 	addi	r19,r4,-1
8112dd64:	003fe906 	br	8112dd0c <__reset+0xfb10dd0c>
8112dd68:	1c400084 	addi	r17,r3,2
8112dd6c:	1c000043 	ldbu	r16,1(r3)
8112dd70:	05c00044 	movi	r23,1
8112dd74:	003fac06 	br	8112dc28 <__reset+0xfb10dc28>
8112dd78:	1c400084 	addi	r17,r3,2
8112dd7c:	1c000043 	ldbu	r16,1(r3)
8112dd80:	002f883a 	mov	r23,zero
8112dd84:	003fa806 	br	8112dc28 <__reset+0xfb10dc28>
8112dd88:	88800003 	ldbu	r2,0(r17)
8112dd8c:	00c01604 	movi	r3,88
8112dd90:	108037cc 	andi	r2,r2,223
8112dd94:	10c00c26 	beq	r2,r3,8112ddc8 <_strtoul_r+0x220>
8112dd98:	05400204 	movi	r21,8
8112dd9c:	01c80034 	movhi	r7,8192
8112dda0:	030001c4 	movi	r12,7
8112dda4:	39ffffc4 	addi	r7,r7,-1
8112dda8:	a817883a 	mov	r11,r21
8112ddac:	003fb506 	br	8112dc84 <__reset+0xfb10dc84>
8112ddb0:	00800c04 	movi	r2,48
8112ddb4:	80800c1e 	bne	r16,r2,8112dde8 <_strtoul_r+0x240>
8112ddb8:	88800003 	ldbu	r2,0(r17)
8112ddbc:	00c01604 	movi	r3,88
8112ddc0:	108037cc 	andi	r2,r2,223
8112ddc4:	10c0081e 	bne	r2,r3,8112dde8 <_strtoul_r+0x240>
8112ddc8:	02c00404 	movi	r11,16
8112ddcc:	05840034 	movhi	r22,4096
8112ddd0:	8c000043 	ldbu	r16,1(r17)
8112ddd4:	030003c4 	movi	r12,15
8112ddd8:	8c400084 	addi	r17,r17,2
8112dddc:	b5bfffc4 	addi	r22,r22,-1
8112dde0:	582b883a 	mov	r21,r11
8112dde4:	003f9e06 	br	8112dc60 <__reset+0xfb10dc60>
8112dde8:	01c40034 	movhi	r7,4096
8112ddec:	030003c4 	movi	r12,15
8112ddf0:	39ffffc4 	addi	r7,r7,-1
8112ddf4:	a817883a 	mov	r11,r21
8112ddf8:	003fa206 	br	8112dc84 <__reset+0xfb10dc84>

8112ddfc <strtoul>:
8112ddfc:	00a04574 	movhi	r2,33045
8112de00:	1082c604 	addi	r2,r2,2840
8112de04:	300f883a 	mov	r7,r6
8112de08:	280d883a 	mov	r6,r5
8112de0c:	200b883a 	mov	r5,r4
8112de10:	11000017 	ldw	r4,0(r2)
8112de14:	112dba81 	jmpi	8112dba8 <_strtoul_r>

8112de18 <_strtoull_r>:
8112de18:	00a04574 	movhi	r2,33045
8112de1c:	defff404 	addi	sp,sp,-48
8112de20:	1082c404 	addi	r2,r2,2832
8112de24:	de00012e 	bgeu	sp,et,8112de2c <_strtoull_r+0x14>
8112de28:	003b68fa 	trap	3
8112de2c:	dc400315 	stw	r17,12(sp)
8112de30:	14400017 	ldw	r17,0(r2)
8112de34:	dd400715 	stw	r21,28(sp)
8112de38:	dd000615 	stw	r20,24(sp)
8112de3c:	dcc00515 	stw	r19,20(sp)
8112de40:	dc800415 	stw	r18,16(sp)
8112de44:	dfc00b15 	stw	ra,44(sp)
8112de48:	df000a15 	stw	fp,40(sp)
8112de4c:	ddc00915 	stw	r23,36(sp)
8112de50:	dd800815 	stw	r22,32(sp)
8112de54:	dc000215 	stw	r16,8(sp)
8112de58:	2827883a 	mov	r19,r5
8112de5c:	202b883a 	mov	r21,r4
8112de60:	3029883a 	mov	r20,r6
8112de64:	3825883a 	mov	r18,r7
8112de68:	2807883a 	mov	r3,r5
8112de6c:	1c000003 	ldbu	r16,0(r3)
8112de70:	1f000044 	addi	fp,r3,1
8112de74:	1809883a 	mov	r4,r3
8112de78:	8c05883a 	add	r2,r17,r16
8112de7c:	10800043 	ldbu	r2,1(r2)
8112de80:	e007883a 	mov	r3,fp
8112de84:	1080020c 	andi	r2,r2,8
8112de88:	103ff81e 	bne	r2,zero,8112de6c <__reset+0xfb10de6c>
8112de8c:	00800b44 	movi	r2,45
8112de90:	80806e26 	beq	r16,r2,8112e04c <_strtoull_r+0x234>
8112de94:	00800ac4 	movi	r2,43
8112de98:	80807026 	beq	r16,r2,8112e05c <_strtoull_r+0x244>
8112de9c:	002f883a 	mov	r23,zero
8112dea0:	90001426 	beq	r18,zero,8112def4 <_strtoull_r+0xdc>
8112dea4:	00800404 	movi	r2,16
8112dea8:	90807c26 	beq	r18,r2,8112e09c <_strtoull_r+0x284>
8112deac:	902dd7fa 	srai	r22,r18,31
8112deb0:	013fffc4 	movi	r4,-1
8112deb4:	200b883a 	mov	r5,r4
8112deb8:	900d883a 	mov	r6,r18
8112debc:	b00f883a 	mov	r7,r22
8112dec0:	11320600 	call	81132060 <__udivdi3>
8112dec4:	013fffc4 	movi	r4,-1
8112dec8:	900d883a 	mov	r6,r18
8112decc:	b00f883a 	mov	r7,r22
8112ded0:	200b883a 	mov	r5,r4
8112ded4:	d8c00115 	stw	r3,4(sp)
8112ded8:	d8800015 	stw	r2,0(sp)
8112dedc:	11325e00 	call	811325e0 <__umoddi3>
8112dee0:	101b883a 	mov	r13,r2
8112dee4:	9015883a 	mov	r10,r18
8112dee8:	dac00017 	ldw	r11,0(sp)
8112deec:	da000117 	ldw	r8,4(sp)
8112def0:	00000a06 	br	8112df1c <_strtoull_r+0x104>
8112def4:	00800c04 	movi	r2,48
8112def8:	80805c26 	beq	r16,r2,8112e06c <_strtoull_r+0x254>
8112defc:	02800284 	movi	r10,10
8112df00:	02e666b4 	movhi	r11,39322
8112df04:	020666b4 	movhi	r8,6554
8112df08:	03400144 	movi	r13,5
8112df0c:	5ae66644 	addi	r11,r11,-26215
8112df10:	42266644 	addi	r8,r8,-26215
8112df14:	002d883a 	mov	r22,zero
8112df18:	5025883a 	mov	r18,r10
8112df1c:	8c0b883a 	add	r5,r17,r16
8112df20:	29400043 	ldbu	r5,1(r5)
8112df24:	e009883a 	mov	r4,fp
8112df28:	000f883a 	mov	r7,zero
8112df2c:	2980010c 	andi	r6,r5,4
8112df30:	0005883a 	mov	r2,zero
8112df34:	0007883a 	mov	r3,zero
8112df38:	03000044 	movi	r12,1
8112df3c:	027fffc4 	movi	r9,-1
8112df40:	30000d26 	beq	r6,zero,8112df78 <_strtoull_r+0x160>
8112df44:	843ff404 	addi	r16,r16,-48
8112df48:	8480110e 	bge	r16,r18,8112df90 <_strtoull_r+0x178>
8112df4c:	3a400426 	beq	r7,r9,8112df60 <_strtoull_r+0x148>
8112df50:	40c00236 	bltu	r8,r3,8112df5c <_strtoull_r+0x144>
8112df54:	1a00231e 	bne	r3,r8,8112dfe4 <_strtoull_r+0x1cc>
8112df58:	5880222e 	bgeu	r11,r2,8112dfe4 <_strtoull_r+0x1cc>
8112df5c:	01ffffc4 	movi	r7,-1
8112df60:	24000003 	ldbu	r16,0(r4)
8112df64:	21000044 	addi	r4,r4,1
8112df68:	8c0b883a 	add	r5,r17,r16
8112df6c:	29400043 	ldbu	r5,1(r5)
8112df70:	2980010c 	andi	r6,r5,4
8112df74:	303ff31e 	bne	r6,zero,8112df44 <__reset+0xfb10df44>
8112df78:	294000cc 	andi	r5,r5,3
8112df7c:	28000426 	beq	r5,zero,8112df90 <_strtoull_r+0x178>
8112df80:	2b002626 	beq	r5,r12,8112e01c <_strtoull_r+0x204>
8112df84:	014015c4 	movi	r5,87
8112df88:	8161c83a 	sub	r16,r16,r5
8112df8c:	84bfef16 	blt	r16,r18,8112df4c <__reset+0xfb10df4c>
8112df90:	38002716 	blt	r7,zero,8112e030 <_strtoull_r+0x218>
8112df94:	b8000426 	beq	r23,zero,8112dfa8 <_strtoull_r+0x190>
8112df98:	0085c83a 	sub	r2,zero,r2
8112df9c:	100ac03a 	cmpne	r5,r2,zero
8112dfa0:	00e1c83a 	sub	r16,zero,r3
8112dfa4:	8147c83a 	sub	r3,r16,r5
8112dfa8:	a0000226 	beq	r20,zero,8112dfb4 <_strtoull_r+0x19c>
8112dfac:	3800251e 	bne	r7,zero,8112e044 <_strtoull_r+0x22c>
8112dfb0:	a4c00015 	stw	r19,0(r20)
8112dfb4:	dfc00b17 	ldw	ra,44(sp)
8112dfb8:	df000a17 	ldw	fp,40(sp)
8112dfbc:	ddc00917 	ldw	r23,36(sp)
8112dfc0:	dd800817 	ldw	r22,32(sp)
8112dfc4:	dd400717 	ldw	r21,28(sp)
8112dfc8:	dd000617 	ldw	r20,24(sp)
8112dfcc:	dcc00517 	ldw	r19,20(sp)
8112dfd0:	dc800417 	ldw	r18,16(sp)
8112dfd4:	dc400317 	ldw	r17,12(sp)
8112dfd8:	dc000217 	ldw	r16,8(sp)
8112dfdc:	dec00c04 	addi	sp,sp,48
8112dfe0:	f800283a 	ret
8112dfe4:	12c00f26 	beq	r2,r11,8112e024 <_strtoull_r+0x20c>
8112dfe8:	b08d383a 	mul	r6,r22,r2
8112dfec:	1a87383a 	mul	r3,r3,r10
8112dff0:	128a383a 	mulxuu	r5,r2,r10
8112dff4:	1285383a 	mul	r2,r2,r10
8112dff8:	800fd7fa 	srai	r7,r16,31
8112dffc:	1987883a 	add	r3,r3,r6
8112e000:	8085883a 	add	r2,r16,r2
8112e004:	1947883a 	add	r3,r3,r5
8112e008:	38c7883a 	add	r3,r7,r3
8112e00c:	1421803a 	cmpltu	r16,r2,r16
8112e010:	80c7883a 	add	r3,r16,r3
8112e014:	01c00044 	movi	r7,1
8112e018:	003fd106 	br	8112df60 <__reset+0xfb10df60>
8112e01c:	01400dc4 	movi	r5,55
8112e020:	003fd906 	br	8112df88 <__reset+0xfb10df88>
8112e024:	1a3ff01e 	bne	r3,r8,8112dfe8 <__reset+0xfb10dfe8>
8112e028:	6c3fcc16 	blt	r13,r16,8112df5c <__reset+0xfb10df5c>
8112e02c:	003fee06 	br	8112dfe8 <__reset+0xfb10dfe8>
8112e030:	00800884 	movi	r2,34
8112e034:	a8800015 	stw	r2,0(r21)
8112e038:	00bfffc4 	movi	r2,-1
8112e03c:	1007883a 	mov	r3,r2
8112e040:	a03fdc26 	beq	r20,zero,8112dfb4 <__reset+0xfb10dfb4>
8112e044:	24ffffc4 	addi	r19,r4,-1
8112e048:	003fd906 	br	8112dfb0 <__reset+0xfb10dfb0>
8112e04c:	27000084 	addi	fp,r4,2
8112e050:	24000043 	ldbu	r16,1(r4)
8112e054:	05c00044 	movi	r23,1
8112e058:	003f9106 	br	8112dea0 <__reset+0xfb10dea0>
8112e05c:	27000084 	addi	fp,r4,2
8112e060:	24000043 	ldbu	r16,1(r4)
8112e064:	002f883a 	mov	r23,zero
8112e068:	003f8d06 	br	8112dea0 <__reset+0xfb10dea0>
8112e06c:	e0800003 	ldbu	r2,0(fp)
8112e070:	00c01604 	movi	r3,88
8112e074:	108037cc 	andi	r2,r2,223
8112e078:	10c00e26 	beq	r2,r3,8112e0b4 <_strtoull_r+0x29c>
8112e07c:	02800204 	movi	r10,8
8112e080:	02ffffc4 	movi	r11,-1
8112e084:	02080034 	movhi	r8,8192
8112e088:	034001c4 	movi	r13,7
8112e08c:	42d1883a 	add	r8,r8,r11
8112e090:	002d883a 	mov	r22,zero
8112e094:	5025883a 	mov	r18,r10
8112e098:	003fa006 	br	8112df1c <__reset+0xfb10df1c>
8112e09c:	00800c04 	movi	r2,48
8112e0a0:	80800e1e 	bne	r16,r2,8112e0dc <_strtoull_r+0x2c4>
8112e0a4:	e0800003 	ldbu	r2,0(fp)
8112e0a8:	00c01604 	movi	r3,88
8112e0ac:	108037cc 	andi	r2,r2,223
8112e0b0:	10c00a1e 	bne	r2,r3,8112e0dc <_strtoull_r+0x2c4>
8112e0b4:	02800404 	movi	r10,16
8112e0b8:	02ffffc4 	movi	r11,-1
8112e0bc:	02040034 	movhi	r8,4096
8112e0c0:	e4000043 	ldbu	r16,1(fp)
8112e0c4:	034003c4 	movi	r13,15
8112e0c8:	e7000084 	addi	fp,fp,2
8112e0cc:	42d1883a 	add	r8,r8,r11
8112e0d0:	002d883a 	mov	r22,zero
8112e0d4:	5025883a 	mov	r18,r10
8112e0d8:	003f9006 	br	8112df1c <__reset+0xfb10df1c>
8112e0dc:	02ffffc4 	movi	r11,-1
8112e0e0:	02040034 	movhi	r8,4096
8112e0e4:	034003c4 	movi	r13,15
8112e0e8:	42d1883a 	add	r8,r8,r11
8112e0ec:	9015883a 	mov	r10,r18
8112e0f0:	002d883a 	mov	r22,zero
8112e0f4:	003f8906 	br	8112df1c <__reset+0xfb10df1c>

8112e0f8 <__ssprint_r>:
8112e0f8:	defff604 	addi	sp,sp,-40
8112e0fc:	de00012e 	bgeu	sp,et,8112e104 <__ssprint_r+0xc>
8112e100:	003b68fa 	trap	3
8112e104:	30800217 	ldw	r2,8(r6)
8112e108:	dc800215 	stw	r18,8(sp)
8112e10c:	dfc00915 	stw	ra,36(sp)
8112e110:	df000815 	stw	fp,32(sp)
8112e114:	ddc00715 	stw	r23,28(sp)
8112e118:	dd800615 	stw	r22,24(sp)
8112e11c:	dd400515 	stw	r21,20(sp)
8112e120:	dd000415 	stw	r20,16(sp)
8112e124:	dcc00315 	stw	r19,12(sp)
8112e128:	dc400115 	stw	r17,4(sp)
8112e12c:	dc000015 	stw	r16,0(sp)
8112e130:	3025883a 	mov	r18,r6
8112e134:	10005826 	beq	r2,zero,8112e298 <__ssprint_r+0x1a0>
8112e138:	2027883a 	mov	r19,r4
8112e13c:	35c00017 	ldw	r23,0(r6)
8112e140:	29000017 	ldw	r4,0(r5)
8112e144:	28800217 	ldw	r2,8(r5)
8112e148:	2823883a 	mov	r17,r5
8112e14c:	0039883a 	mov	fp,zero
8112e150:	0021883a 	mov	r16,zero
8112e154:	80003926 	beq	r16,zero,8112e23c <__ssprint_r+0x144>
8112e158:	102b883a 	mov	r21,r2
8112e15c:	102d883a 	mov	r22,r2
8112e160:	80803a36 	bltu	r16,r2,8112e24c <__ssprint_r+0x154>
8112e164:	88c0030b 	ldhu	r3,12(r17)
8112e168:	1881200c 	andi	r2,r3,1152
8112e16c:	10002626 	beq	r2,zero,8112e208 <__ssprint_r+0x110>
8112e170:	88800517 	ldw	r2,20(r17)
8112e174:	89400417 	ldw	r5,16(r17)
8112e178:	81800044 	addi	r6,r16,1
8112e17c:	108f883a 	add	r7,r2,r2
8112e180:	3885883a 	add	r2,r7,r2
8112e184:	100ed7fa 	srli	r7,r2,31
8112e188:	216dc83a 	sub	r22,r4,r5
8112e18c:	3589883a 	add	r4,r6,r22
8112e190:	3885883a 	add	r2,r7,r2
8112e194:	102bd07a 	srai	r21,r2,1
8112e198:	a80d883a 	mov	r6,r21
8112e19c:	a900022e 	bgeu	r21,r4,8112e1a8 <__ssprint_r+0xb0>
8112e1a0:	202b883a 	mov	r21,r4
8112e1a4:	200d883a 	mov	r6,r4
8112e1a8:	18c1000c 	andi	r3,r3,1024
8112e1ac:	18002a26 	beq	r3,zero,8112e258 <__ssprint_r+0x160>
8112e1b0:	300b883a 	mov	r5,r6
8112e1b4:	9809883a 	mov	r4,r19
8112e1b8:	111fe980 	call	8111fe98 <_malloc_r>
8112e1bc:	1029883a 	mov	r20,r2
8112e1c0:	10002c26 	beq	r2,zero,8112e274 <__ssprint_r+0x17c>
8112e1c4:	89400417 	ldw	r5,16(r17)
8112e1c8:	b00d883a 	mov	r6,r22
8112e1cc:	1009883a 	mov	r4,r2
8112e1d0:	11206ac0 	call	811206ac <memcpy>
8112e1d4:	8880030b 	ldhu	r2,12(r17)
8112e1d8:	00fedfc4 	movi	r3,-1153
8112e1dc:	10c4703a 	and	r2,r2,r3
8112e1e0:	10802014 	ori	r2,r2,128
8112e1e4:	8880030d 	sth	r2,12(r17)
8112e1e8:	a589883a 	add	r4,r20,r22
8112e1ec:	adadc83a 	sub	r22,r21,r22
8112e1f0:	8d400515 	stw	r21,20(r17)
8112e1f4:	8d800215 	stw	r22,8(r17)
8112e1f8:	8d000415 	stw	r20,16(r17)
8112e1fc:	89000015 	stw	r4,0(r17)
8112e200:	802b883a 	mov	r21,r16
8112e204:	802d883a 	mov	r22,r16
8112e208:	b00d883a 	mov	r6,r22
8112e20c:	e00b883a 	mov	r5,fp
8112e210:	112a7800 	call	8112a780 <memmove>
8112e214:	88800217 	ldw	r2,8(r17)
8112e218:	89000017 	ldw	r4,0(r17)
8112e21c:	90c00217 	ldw	r3,8(r18)
8112e220:	1545c83a 	sub	r2,r2,r21
8112e224:	2589883a 	add	r4,r4,r22
8112e228:	88800215 	stw	r2,8(r17)
8112e22c:	89000015 	stw	r4,0(r17)
8112e230:	1c21c83a 	sub	r16,r3,r16
8112e234:	94000215 	stw	r16,8(r18)
8112e238:	80001726 	beq	r16,zero,8112e298 <__ssprint_r+0x1a0>
8112e23c:	bf000017 	ldw	fp,0(r23)
8112e240:	bc000117 	ldw	r16,4(r23)
8112e244:	bdc00204 	addi	r23,r23,8
8112e248:	003fc206 	br	8112e154 <__reset+0xfb10e154>
8112e24c:	802b883a 	mov	r21,r16
8112e250:	802d883a 	mov	r22,r16
8112e254:	003fec06 	br	8112e208 <__reset+0xfb10e208>
8112e258:	9809883a 	mov	r4,r19
8112e25c:	112b9a00 	call	8112b9a0 <_realloc_r>
8112e260:	1029883a 	mov	r20,r2
8112e264:	103fe01e 	bne	r2,zero,8112e1e8 <__reset+0xfb10e1e8>
8112e268:	89400417 	ldw	r5,16(r17)
8112e26c:	9809883a 	mov	r4,r19
8112e270:	112990c0 	call	8112990c <_free_r>
8112e274:	88c0030b 	ldhu	r3,12(r17)
8112e278:	00800304 	movi	r2,12
8112e27c:	98800015 	stw	r2,0(r19)
8112e280:	18c01014 	ori	r3,r3,64
8112e284:	88c0030d 	sth	r3,12(r17)
8112e288:	00bfffc4 	movi	r2,-1
8112e28c:	90000215 	stw	zero,8(r18)
8112e290:	90000115 	stw	zero,4(r18)
8112e294:	00000206 	br	8112e2a0 <__ssprint_r+0x1a8>
8112e298:	90000115 	stw	zero,4(r18)
8112e29c:	0005883a 	mov	r2,zero
8112e2a0:	dfc00917 	ldw	ra,36(sp)
8112e2a4:	df000817 	ldw	fp,32(sp)
8112e2a8:	ddc00717 	ldw	r23,28(sp)
8112e2ac:	dd800617 	ldw	r22,24(sp)
8112e2b0:	dd400517 	ldw	r21,20(sp)
8112e2b4:	dd000417 	ldw	r20,16(sp)
8112e2b8:	dcc00317 	ldw	r19,12(sp)
8112e2bc:	dc800217 	ldw	r18,8(sp)
8112e2c0:	dc400117 	ldw	r17,4(sp)
8112e2c4:	dc000017 	ldw	r16,0(sp)
8112e2c8:	dec00a04 	addi	sp,sp,40
8112e2cc:	f800283a 	ret

8112e2d0 <___svfiprintf_internal_r>:
8112e2d0:	deffc804 	addi	sp,sp,-224
8112e2d4:	de00012e 	bgeu	sp,et,8112e2dc <___svfiprintf_internal_r+0xc>
8112e2d8:	003b68fa 	trap	3
8112e2dc:	2880030b 	ldhu	r2,12(r5)
8112e2e0:	dcc03115 	stw	r19,196(sp)
8112e2e4:	dfc03715 	stw	ra,220(sp)
8112e2e8:	df003615 	stw	fp,216(sp)
8112e2ec:	ddc03515 	stw	r23,212(sp)
8112e2f0:	dd803415 	stw	r22,208(sp)
8112e2f4:	dd403315 	stw	r21,204(sp)
8112e2f8:	dd003215 	stw	r20,200(sp)
8112e2fc:	dc803015 	stw	r18,192(sp)
8112e300:	dc402f15 	stw	r17,188(sp)
8112e304:	dc002e15 	stw	r16,184(sp)
8112e308:	d9402715 	stw	r5,156(sp)
8112e30c:	d9002a15 	stw	r4,168(sp)
8112e310:	1080200c 	andi	r2,r2,128
8112e314:	d9c02315 	stw	r7,140(sp)
8112e318:	3027883a 	mov	r19,r6
8112e31c:	10000226 	beq	r2,zero,8112e328 <___svfiprintf_internal_r+0x58>
8112e320:	28800417 	ldw	r2,16(r5)
8112e324:	10041d26 	beq	r2,zero,8112f39c <___svfiprintf_internal_r+0x10cc>
8112e328:	dac01a04 	addi	r11,sp,104
8112e32c:	dac01e15 	stw	r11,120(sp)
8112e330:	d8801e17 	ldw	r2,120(sp)
8112e334:	dac019c4 	addi	r11,sp,103
8112e338:	dd402a17 	ldw	r21,168(sp)
8112e33c:	ddc02717 	ldw	r23,156(sp)
8112e340:	05a04574 	movhi	r22,33045
8112e344:	05204574 	movhi	r20,33045
8112e348:	dac01f15 	stw	r11,124(sp)
8112e34c:	12d7c83a 	sub	r11,r2,r11
8112e350:	b5b98504 	addi	r22,r22,-6636
8112e354:	a5398104 	addi	r20,r20,-6652
8112e358:	dec01a15 	stw	sp,104(sp)
8112e35c:	d8001c15 	stw	zero,112(sp)
8112e360:	d8001b15 	stw	zero,108(sp)
8112e364:	d811883a 	mov	r8,sp
8112e368:	d8002915 	stw	zero,164(sp)
8112e36c:	d8002515 	stw	zero,148(sp)
8112e370:	dac02b15 	stw	r11,172(sp)
8112e374:	98800007 	ldb	r2,0(r19)
8112e378:	1002dd26 	beq	r2,zero,8112eef0 <___svfiprintf_internal_r+0xc20>
8112e37c:	00c00944 	movi	r3,37
8112e380:	9823883a 	mov	r17,r19
8112e384:	10c0021e 	bne	r2,r3,8112e390 <___svfiprintf_internal_r+0xc0>
8112e388:	00001406 	br	8112e3dc <___svfiprintf_internal_r+0x10c>
8112e38c:	10c00326 	beq	r2,r3,8112e39c <___svfiprintf_internal_r+0xcc>
8112e390:	8c400044 	addi	r17,r17,1
8112e394:	88800007 	ldb	r2,0(r17)
8112e398:	103ffc1e 	bne	r2,zero,8112e38c <__reset+0xfb10e38c>
8112e39c:	8ce1c83a 	sub	r16,r17,r19
8112e3a0:	80000e26 	beq	r16,zero,8112e3dc <___svfiprintf_internal_r+0x10c>
8112e3a4:	d8c01c17 	ldw	r3,112(sp)
8112e3a8:	d8801b17 	ldw	r2,108(sp)
8112e3ac:	44c00015 	stw	r19,0(r8)
8112e3b0:	1c07883a 	add	r3,r3,r16
8112e3b4:	10800044 	addi	r2,r2,1
8112e3b8:	d8c01c15 	stw	r3,112(sp)
8112e3bc:	44000115 	stw	r16,4(r8)
8112e3c0:	d8801b15 	stw	r2,108(sp)
8112e3c4:	00c001c4 	movi	r3,7
8112e3c8:	18831e16 	blt	r3,r2,8112f044 <___svfiprintf_internal_r+0xd74>
8112e3cc:	42000204 	addi	r8,r8,8
8112e3d0:	dac02517 	ldw	r11,148(sp)
8112e3d4:	5c17883a 	add	r11,r11,r16
8112e3d8:	dac02515 	stw	r11,148(sp)
8112e3dc:	88800007 	ldb	r2,0(r17)
8112e3e0:	1002c526 	beq	r2,zero,8112eef8 <___svfiprintf_internal_r+0xc28>
8112e3e4:	88c00047 	ldb	r3,1(r17)
8112e3e8:	8cc00044 	addi	r19,r17,1
8112e3ec:	d8001d85 	stb	zero,118(sp)
8112e3f0:	0009883a 	mov	r4,zero
8112e3f4:	000f883a 	mov	r7,zero
8112e3f8:	043fffc4 	movi	r16,-1
8112e3fc:	d8002415 	stw	zero,144(sp)
8112e400:	0025883a 	mov	r18,zero
8112e404:	01401604 	movi	r5,88
8112e408:	01800244 	movi	r6,9
8112e40c:	02800a84 	movi	r10,42
8112e410:	02401b04 	movi	r9,108
8112e414:	9cc00044 	addi	r19,r19,1
8112e418:	18bff804 	addi	r2,r3,-32
8112e41c:	2881dd36 	bltu	r5,r2,8112eb94 <___svfiprintf_internal_r+0x8c4>
8112e420:	100490ba 	slli	r2,r2,2
8112e424:	02e044f4 	movhi	r11,33043
8112e428:	5af90e04 	addi	r11,r11,-7112
8112e42c:	12c5883a 	add	r2,r2,r11
8112e430:	10800017 	ldw	r2,0(r2)
8112e434:	1000683a 	jmp	r2
8112e438:	8112e634 	orhi	r4,r16,19352
8112e43c:	8112eb94 	ori	r4,r16,19374
8112e440:	8112eb94 	ori	r4,r16,19374
8112e444:	8112e628 	cmpgeui	r4,r16,19352
8112e448:	8112eb94 	ori	r4,r16,19374
8112e44c:	8112eb94 	ori	r4,r16,19374
8112e450:	8112eb94 	ori	r4,r16,19374
8112e454:	8112eb94 	ori	r4,r16,19374
8112e458:	8112eb94 	ori	r4,r16,19374
8112e45c:	8112eb94 	ori	r4,r16,19374
8112e460:	8112e59c 	xori	r4,r16,19350
8112e464:	8112e778 	rdprs	r4,r16,19357
8112e468:	8112eb94 	ori	r4,r16,19374
8112e46c:	8112e5c8 	cmpgei	r4,r16,19351
8112e470:	8112ebc8 	cmpgei	r4,r16,19375
8112e474:	8112eb94 	ori	r4,r16,19374
8112e478:	8112ebbc 	xorhi	r4,r16,19374
8112e47c:	8112eb5c 	xori	r4,r16,19373
8112e480:	8112eb5c 	xori	r4,r16,19373
8112e484:	8112eb5c 	xori	r4,r16,19373
8112e488:	8112eb5c 	xori	r4,r16,19373
8112e48c:	8112eb5c 	xori	r4,r16,19373
8112e490:	8112eb5c 	xori	r4,r16,19373
8112e494:	8112eb5c 	xori	r4,r16,19373
8112e498:	8112eb5c 	xori	r4,r16,19373
8112e49c:	8112eb5c 	xori	r4,r16,19373
8112e4a0:	8112eb94 	ori	r4,r16,19374
8112e4a4:	8112eb94 	ori	r4,r16,19374
8112e4a8:	8112eb94 	ori	r4,r16,19374
8112e4ac:	8112eb94 	ori	r4,r16,19374
8112e4b0:	8112eb94 	ori	r4,r16,19374
8112e4b4:	8112eb94 	ori	r4,r16,19374
8112e4b8:	8112eb94 	ori	r4,r16,19374
8112e4bc:	8112eb94 	ori	r4,r16,19374
8112e4c0:	8112eb94 	ori	r4,r16,19374
8112e4c4:	8112eb94 	ori	r4,r16,19374
8112e4c8:	8112eaf8 	rdprs	r4,r16,19371
8112e4cc:	8112eb94 	ori	r4,r16,19374
8112e4d0:	8112eb94 	ori	r4,r16,19374
8112e4d4:	8112eb94 	ori	r4,r16,19374
8112e4d8:	8112eb94 	ori	r4,r16,19374
8112e4dc:	8112eb94 	ori	r4,r16,19374
8112e4e0:	8112eb94 	ori	r4,r16,19374
8112e4e4:	8112eb94 	ori	r4,r16,19374
8112e4e8:	8112eb94 	ori	r4,r16,19374
8112e4ec:	8112eb94 	ori	r4,r16,19374
8112e4f0:	8112eb94 	ori	r4,r16,19374
8112e4f4:	8112ec70 	cmpltui	r4,r16,19377
8112e4f8:	8112eb94 	ori	r4,r16,19374
8112e4fc:	8112eb94 	ori	r4,r16,19374
8112e500:	8112eb94 	ori	r4,r16,19374
8112e504:	8112eb94 	ori	r4,r16,19374
8112e508:	8112eb94 	ori	r4,r16,19374
8112e50c:	8112ec08 	cmpgei	r4,r16,19376
8112e510:	8112eb94 	ori	r4,r16,19374
8112e514:	8112eb94 	ori	r4,r16,19374
8112e518:	8112e93c 	xorhi	r4,r16,19364
8112e51c:	8112eb94 	ori	r4,r16,19374
8112e520:	8112eb94 	ori	r4,r16,19374
8112e524:	8112eb94 	ori	r4,r16,19374
8112e528:	8112eb94 	ori	r4,r16,19374
8112e52c:	8112eb94 	ori	r4,r16,19374
8112e530:	8112eb94 	ori	r4,r16,19374
8112e534:	8112eb94 	ori	r4,r16,19374
8112e538:	8112eb94 	ori	r4,r16,19374
8112e53c:	8112eb94 	ori	r4,r16,19374
8112e540:	8112eb94 	ori	r4,r16,19374
8112e544:	8112e82c 	andhi	r4,r16,19360
8112e548:	8112e9d8 	cmpnei	r4,r16,19367
8112e54c:	8112eb94 	ori	r4,r16,19374
8112e550:	8112eb94 	ori	r4,r16,19374
8112e554:	8112eb94 	ori	r4,r16,19374
8112e558:	8112e9cc 	andi	r4,r16,19367
8112e55c:	8112e9d8 	cmpnei	r4,r16,19367
8112e560:	8112eb94 	ori	r4,r16,19374
8112e564:	8112eb94 	ori	r4,r16,19374
8112e568:	8112e9bc 	xorhi	r4,r16,19366
8112e56c:	8112eb94 	ori	r4,r16,19374
8112e570:	8112e980 	call	88112e98 <__reset+0x20f2e98>
8112e574:	8112e788 	cmpgei	r4,r16,19358
8112e578:	8112e5d4 	ori	r4,r16,19351
8112e57c:	8112eaec 	andhi	r4,r16,19371
8112e580:	8112eb94 	ori	r4,r16,19374
8112e584:	8112eaa0 	cmpeqi	r4,r16,19370
8112e588:	8112eb94 	ori	r4,r16,19374
8112e58c:	8112e6f8 	rdprs	r4,r16,19355
8112e590:	8112eb94 	ori	r4,r16,19374
8112e594:	8112eb94 	ori	r4,r16,19374
8112e598:	8112e654 	ori	r4,r16,19353
8112e59c:	dac02317 	ldw	r11,140(sp)
8112e5a0:	5ac00017 	ldw	r11,0(r11)
8112e5a4:	dac02415 	stw	r11,144(sp)
8112e5a8:	dac02317 	ldw	r11,140(sp)
8112e5ac:	58800104 	addi	r2,r11,4
8112e5b0:	dac02417 	ldw	r11,144(sp)
8112e5b4:	5802e90e 	bge	r11,zero,8112f15c <___svfiprintf_internal_r+0xe8c>
8112e5b8:	dac02417 	ldw	r11,144(sp)
8112e5bc:	d8802315 	stw	r2,140(sp)
8112e5c0:	02d7c83a 	sub	r11,zero,r11
8112e5c4:	dac02415 	stw	r11,144(sp)
8112e5c8:	94800114 	ori	r18,r18,4
8112e5cc:	98c00007 	ldb	r3,0(r19)
8112e5d0:	003f9006 	br	8112e414 <__reset+0xfb10e414>
8112e5d4:	00800c04 	movi	r2,48
8112e5d8:	dac02317 	ldw	r11,140(sp)
8112e5dc:	d8801d05 	stb	r2,116(sp)
8112e5e0:	00801e04 	movi	r2,120
8112e5e4:	d8801d45 	stb	r2,117(sp)
8112e5e8:	d8001d85 	stb	zero,118(sp)
8112e5ec:	58c00104 	addi	r3,r11,4
8112e5f0:	5f000017 	ldw	fp,0(r11)
8112e5f4:	0013883a 	mov	r9,zero
8112e5f8:	90800094 	ori	r2,r18,2
8112e5fc:	80032b16 	blt	r16,zero,8112f2ac <___svfiprintf_internal_r+0xfdc>
8112e600:	00bfdfc4 	movi	r2,-129
8112e604:	90a4703a 	and	r18,r18,r2
8112e608:	d8c02315 	stw	r3,140(sp)
8112e60c:	94800094 	ori	r18,r18,2
8112e610:	e002dc26 	beq	fp,zero,8112f184 <___svfiprintf_internal_r+0xeb4>
8112e614:	01204574 	movhi	r4,33045
8112e618:	2138f704 	addi	r4,r4,-7204
8112e61c:	0015883a 	mov	r10,zero
8112e620:	d9002915 	stw	r4,164(sp)
8112e624:	00002306 	br	8112e6b4 <___svfiprintf_internal_r+0x3e4>
8112e628:	94800054 	ori	r18,r18,1
8112e62c:	98c00007 	ldb	r3,0(r19)
8112e630:	003f7806 	br	8112e414 <__reset+0xfb10e414>
8112e634:	38803fcc 	andi	r2,r7,255
8112e638:	1080201c 	xori	r2,r2,128
8112e63c:	10bfe004 	addi	r2,r2,-128
8112e640:	1002f31e 	bne	r2,zero,8112f210 <___svfiprintf_internal_r+0xf40>
8112e644:	01000044 	movi	r4,1
8112e648:	01c00804 	movi	r7,32
8112e64c:	98c00007 	ldb	r3,0(r19)
8112e650:	003f7006 	br	8112e414 <__reset+0xfb10e414>
8112e654:	21003fcc 	andi	r4,r4,255
8112e658:	2003aa1e 	bne	r4,zero,8112f504 <___svfiprintf_internal_r+0x1234>
8112e65c:	00a04574 	movhi	r2,33045
8112e660:	10b8f704 	addi	r2,r2,-7204
8112e664:	d8802915 	stw	r2,164(sp)
8112e668:	9080080c 	andi	r2,r18,32
8112e66c:	1000ba26 	beq	r2,zero,8112e958 <___svfiprintf_internal_r+0x688>
8112e670:	dac02317 	ldw	r11,140(sp)
8112e674:	5f000017 	ldw	fp,0(r11)
8112e678:	5a400117 	ldw	r9,4(r11)
8112e67c:	5ac00204 	addi	r11,r11,8
8112e680:	dac02315 	stw	r11,140(sp)
8112e684:	9080004c 	andi	r2,r18,1
8112e688:	10029026 	beq	r2,zero,8112f0cc <___svfiprintf_internal_r+0xdfc>
8112e68c:	e244b03a 	or	r2,fp,r9
8112e690:	1002d41e 	bne	r2,zero,8112f1e4 <___svfiprintf_internal_r+0xf14>
8112e694:	d8001d85 	stb	zero,118(sp)
8112e698:	80030b16 	blt	r16,zero,8112f2c8 <___svfiprintf_internal_r+0xff8>
8112e69c:	00bfdfc4 	movi	r2,-129
8112e6a0:	90a4703a 	and	r18,r18,r2
8112e6a4:	0015883a 	mov	r10,zero
8112e6a8:	80002426 	beq	r16,zero,8112e73c <___svfiprintf_internal_r+0x46c>
8112e6ac:	0039883a 	mov	fp,zero
8112e6b0:	0013883a 	mov	r9,zero
8112e6b4:	d9002917 	ldw	r4,164(sp)
8112e6b8:	dc401a04 	addi	r17,sp,104
8112e6bc:	e08003cc 	andi	r2,fp,15
8112e6c0:	4806973a 	slli	r3,r9,28
8112e6c4:	2085883a 	add	r2,r4,r2
8112e6c8:	e038d13a 	srli	fp,fp,4
8112e6cc:	10800003 	ldbu	r2,0(r2)
8112e6d0:	4812d13a 	srli	r9,r9,4
8112e6d4:	8c7fffc4 	addi	r17,r17,-1
8112e6d8:	1f38b03a 	or	fp,r3,fp
8112e6dc:	88800005 	stb	r2,0(r17)
8112e6e0:	e244b03a 	or	r2,fp,r9
8112e6e4:	103ff51e 	bne	r2,zero,8112e6bc <__reset+0xfb10e6bc>
8112e6e8:	dac01e17 	ldw	r11,120(sp)
8112e6ec:	5c57c83a 	sub	r11,r11,r17
8112e6f0:	dac02115 	stw	r11,132(sp)
8112e6f4:	00001406 	br	8112e748 <___svfiprintf_internal_r+0x478>
8112e6f8:	21003fcc 	andi	r4,r4,255
8112e6fc:	2003741e 	bne	r4,zero,8112f4d0 <___svfiprintf_internal_r+0x1200>
8112e700:	9080080c 	andi	r2,r18,32
8112e704:	10014526 	beq	r2,zero,8112ec1c <___svfiprintf_internal_r+0x94c>
8112e708:	dac02317 	ldw	r11,140(sp)
8112e70c:	d8001d85 	stb	zero,118(sp)
8112e710:	58c00204 	addi	r3,r11,8
8112e714:	5f000017 	ldw	fp,0(r11)
8112e718:	5a400117 	ldw	r9,4(r11)
8112e71c:	8002d916 	blt	r16,zero,8112f284 <___svfiprintf_internal_r+0xfb4>
8112e720:	013fdfc4 	movi	r4,-129
8112e724:	e244b03a 	or	r2,fp,r9
8112e728:	d8c02315 	stw	r3,140(sp)
8112e72c:	9124703a 	and	r18,r18,r4
8112e730:	0015883a 	mov	r10,zero
8112e734:	1000b91e 	bne	r2,zero,8112ea1c <___svfiprintf_internal_r+0x74c>
8112e738:	8002e61e 	bne	r16,zero,8112f2d4 <___svfiprintf_internal_r+0x1004>
8112e73c:	0021883a 	mov	r16,zero
8112e740:	d8002115 	stw	zero,132(sp)
8112e744:	dc401a04 	addi	r17,sp,104
8112e748:	d8c02117 	ldw	r3,132(sp)
8112e74c:	dc002015 	stw	r16,128(sp)
8112e750:	80c0010e 	bge	r16,r3,8112e758 <___svfiprintf_internal_r+0x488>
8112e754:	d8c02015 	stw	r3,128(sp)
8112e758:	52803fcc 	andi	r10,r10,255
8112e75c:	5280201c 	xori	r10,r10,128
8112e760:	52bfe004 	addi	r10,r10,-128
8112e764:	50003c26 	beq	r10,zero,8112e858 <___svfiprintf_internal_r+0x588>
8112e768:	dac02017 	ldw	r11,128(sp)
8112e76c:	5ac00044 	addi	r11,r11,1
8112e770:	dac02015 	stw	r11,128(sp)
8112e774:	00003806 	br	8112e858 <___svfiprintf_internal_r+0x588>
8112e778:	01000044 	movi	r4,1
8112e77c:	01c00ac4 	movi	r7,43
8112e780:	98c00007 	ldb	r3,0(r19)
8112e784:	003f2306 	br	8112e414 <__reset+0xfb10e414>
8112e788:	21003fcc 	andi	r4,r4,255
8112e78c:	2003481e 	bne	r4,zero,8112f4b0 <___svfiprintf_internal_r+0x11e0>
8112e790:	9080080c 	andi	r2,r18,32
8112e794:	10013b26 	beq	r2,zero,8112ec84 <___svfiprintf_internal_r+0x9b4>
8112e798:	dac02317 	ldw	r11,140(sp)
8112e79c:	d8001d85 	stb	zero,118(sp)
8112e7a0:	58800204 	addi	r2,r11,8
8112e7a4:	5f000017 	ldw	fp,0(r11)
8112e7a8:	5a400117 	ldw	r9,4(r11)
8112e7ac:	8002a816 	blt	r16,zero,8112f250 <___svfiprintf_internal_r+0xf80>
8112e7b0:	013fdfc4 	movi	r4,-129
8112e7b4:	e246b03a 	or	r3,fp,r9
8112e7b8:	d8802315 	stw	r2,140(sp)
8112e7bc:	9124703a 	and	r18,r18,r4
8112e7c0:	18013c26 	beq	r3,zero,8112ecb4 <___svfiprintf_internal_r+0x9e4>
8112e7c4:	0015883a 	mov	r10,zero
8112e7c8:	dc401a04 	addi	r17,sp,104
8112e7cc:	e006d0fa 	srli	r3,fp,3
8112e7d0:	4808977a 	slli	r4,r9,29
8112e7d4:	4812d0fa 	srli	r9,r9,3
8112e7d8:	e70001cc 	andi	fp,fp,7
8112e7dc:	e0800c04 	addi	r2,fp,48
8112e7e0:	8c7fffc4 	addi	r17,r17,-1
8112e7e4:	20f8b03a 	or	fp,r4,r3
8112e7e8:	88800005 	stb	r2,0(r17)
8112e7ec:	e246b03a 	or	r3,fp,r9
8112e7f0:	183ff61e 	bne	r3,zero,8112e7cc <__reset+0xfb10e7cc>
8112e7f4:	90c0004c 	andi	r3,r18,1
8112e7f8:	1800a526 	beq	r3,zero,8112ea90 <___svfiprintf_internal_r+0x7c0>
8112e7fc:	10803fcc 	andi	r2,r2,255
8112e800:	1080201c 	xori	r2,r2,128
8112e804:	10bfe004 	addi	r2,r2,-128
8112e808:	00c00c04 	movi	r3,48
8112e80c:	10ffb626 	beq	r2,r3,8112e6e8 <__reset+0xfb10e6e8>
8112e810:	88ffffc5 	stb	r3,-1(r17)
8112e814:	d8c01e17 	ldw	r3,120(sp)
8112e818:	88bfffc4 	addi	r2,r17,-1
8112e81c:	1023883a 	mov	r17,r2
8112e820:	1887c83a 	sub	r3,r3,r2
8112e824:	d8c02115 	stw	r3,132(sp)
8112e828:	003fc706 	br	8112e748 <__reset+0xfb10e748>
8112e82c:	dac02317 	ldw	r11,140(sp)
8112e830:	00c00044 	movi	r3,1
8112e834:	d8c02015 	stw	r3,128(sp)
8112e838:	58800017 	ldw	r2,0(r11)
8112e83c:	5ac00104 	addi	r11,r11,4
8112e840:	d8001d85 	stb	zero,118(sp)
8112e844:	d8801005 	stb	r2,64(sp)
8112e848:	dac02315 	stw	r11,140(sp)
8112e84c:	d8c02115 	stw	r3,132(sp)
8112e850:	dc401004 	addi	r17,sp,64
8112e854:	0021883a 	mov	r16,zero
8112e858:	90c0008c 	andi	r3,r18,2
8112e85c:	d8c02215 	stw	r3,136(sp)
8112e860:	18000326 	beq	r3,zero,8112e870 <___svfiprintf_internal_r+0x5a0>
8112e864:	dac02017 	ldw	r11,128(sp)
8112e868:	5ac00084 	addi	r11,r11,2
8112e86c:	dac02015 	stw	r11,128(sp)
8112e870:	90c0210c 	andi	r3,r18,132
8112e874:	d8c02615 	stw	r3,152(sp)
8112e878:	1801131e 	bne	r3,zero,8112ecc8 <___svfiprintf_internal_r+0x9f8>
8112e87c:	dac02417 	ldw	r11,144(sp)
8112e880:	d8c02017 	ldw	r3,128(sp)
8112e884:	58f9c83a 	sub	fp,r11,r3
8112e888:	07010f0e 	bge	zero,fp,8112ecc8 <___svfiprintf_internal_r+0x9f8>
8112e88c:	02400404 	movi	r9,16
8112e890:	d8c01c17 	ldw	r3,112(sp)
8112e894:	d8801b17 	ldw	r2,108(sp)
8112e898:	4f02d60e 	bge	r9,fp,8112f3f4 <___svfiprintf_internal_r+0x1124>
8112e89c:	01604574 	movhi	r5,33045
8112e8a0:	29798504 	addi	r5,r5,-6636
8112e8a4:	d9402815 	stw	r5,160(sp)
8112e8a8:	028001c4 	movi	r10,7
8112e8ac:	00000306 	br	8112e8bc <___svfiprintf_internal_r+0x5ec>
8112e8b0:	e73ffc04 	addi	fp,fp,-16
8112e8b4:	42000204 	addi	r8,r8,8
8112e8b8:	4f00150e 	bge	r9,fp,8112e910 <___svfiprintf_internal_r+0x640>
8112e8bc:	18c00404 	addi	r3,r3,16
8112e8c0:	10800044 	addi	r2,r2,1
8112e8c4:	45800015 	stw	r22,0(r8)
8112e8c8:	42400115 	stw	r9,4(r8)
8112e8cc:	d8c01c15 	stw	r3,112(sp)
8112e8d0:	d8801b15 	stw	r2,108(sp)
8112e8d4:	50bff60e 	bge	r10,r2,8112e8b0 <__reset+0xfb10e8b0>
8112e8d8:	d9801a04 	addi	r6,sp,104
8112e8dc:	b80b883a 	mov	r5,r23
8112e8e0:	a809883a 	mov	r4,r21
8112e8e4:	da402c15 	stw	r9,176(sp)
8112e8e8:	da802d15 	stw	r10,180(sp)
8112e8ec:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112e8f0:	da402c17 	ldw	r9,176(sp)
8112e8f4:	da802d17 	ldw	r10,180(sp)
8112e8f8:	1001851e 	bne	r2,zero,8112ef10 <___svfiprintf_internal_r+0xc40>
8112e8fc:	e73ffc04 	addi	fp,fp,-16
8112e900:	d8c01c17 	ldw	r3,112(sp)
8112e904:	d8801b17 	ldw	r2,108(sp)
8112e908:	d811883a 	mov	r8,sp
8112e90c:	4f3feb16 	blt	r9,fp,8112e8bc <__reset+0xfb10e8bc>
8112e910:	dac02817 	ldw	r11,160(sp)
8112e914:	e0c7883a 	add	r3,fp,r3
8112e918:	10800044 	addi	r2,r2,1
8112e91c:	42c00015 	stw	r11,0(r8)
8112e920:	47000115 	stw	fp,4(r8)
8112e924:	d8c01c15 	stw	r3,112(sp)
8112e928:	d8801b15 	stw	r2,108(sp)
8112e92c:	010001c4 	movi	r4,7
8112e930:	2081ee16 	blt	r4,r2,8112f0ec <___svfiprintf_internal_r+0xe1c>
8112e934:	42000204 	addi	r8,r8,8
8112e938:	0000e506 	br	8112ecd0 <___svfiprintf_internal_r+0xa00>
8112e93c:	21003fcc 	andi	r4,r4,255
8112e940:	2002dd1e 	bne	r4,zero,8112f4b8 <___svfiprintf_internal_r+0x11e8>
8112e944:	00a04574 	movhi	r2,33045
8112e948:	10b8f204 	addi	r2,r2,-7224
8112e94c:	d8802915 	stw	r2,164(sp)
8112e950:	9080080c 	andi	r2,r18,32
8112e954:	103f461e 	bne	r2,zero,8112e670 <__reset+0xfb10e670>
8112e958:	9080040c 	andi	r2,r18,16
8112e95c:	10022e1e 	bne	r2,zero,8112f218 <___svfiprintf_internal_r+0xf48>
8112e960:	9080100c 	andi	r2,r18,64
8112e964:	dac02317 	ldw	r11,140(sp)
8112e968:	10027326 	beq	r2,zero,8112f338 <___svfiprintf_internal_r+0x1068>
8112e96c:	5f00000b 	ldhu	fp,0(r11)
8112e970:	5ac00104 	addi	r11,r11,4
8112e974:	0013883a 	mov	r9,zero
8112e978:	dac02315 	stw	r11,140(sp)
8112e97c:	003f4106 	br	8112e684 <__reset+0xfb10e684>
8112e980:	21003fcc 	andi	r4,r4,255
8112e984:	2002e11e 	bne	r4,zero,8112f50c <___svfiprintf_internal_r+0x123c>
8112e988:	9080080c 	andi	r2,r18,32
8112e98c:	1002011e 	bne	r2,zero,8112f194 <___svfiprintf_internal_r+0xec4>
8112e990:	9080040c 	andi	r2,r18,16
8112e994:	10023e1e 	bne	r2,zero,8112f290 <___svfiprintf_internal_r+0xfc0>
8112e998:	9480100c 	andi	r18,r18,64
8112e99c:	90023c26 	beq	r18,zero,8112f290 <___svfiprintf_internal_r+0xfc0>
8112e9a0:	dac02317 	ldw	r11,140(sp)
8112e9a4:	58800017 	ldw	r2,0(r11)
8112e9a8:	5ac00104 	addi	r11,r11,4
8112e9ac:	dac02315 	stw	r11,140(sp)
8112e9b0:	dac02517 	ldw	r11,148(sp)
8112e9b4:	12c0000d 	sth	r11,0(r2)
8112e9b8:	003e6e06 	br	8112e374 <__reset+0xfb10e374>
8112e9bc:	98c00007 	ldb	r3,0(r19)
8112e9c0:	1a422926 	beq	r3,r9,8112f268 <___svfiprintf_internal_r+0xf98>
8112e9c4:	94800414 	ori	r18,r18,16
8112e9c8:	003e9206 	br	8112e414 <__reset+0xfb10e414>
8112e9cc:	94801014 	ori	r18,r18,64
8112e9d0:	98c00007 	ldb	r3,0(r19)
8112e9d4:	003e8f06 	br	8112e414 <__reset+0xfb10e414>
8112e9d8:	21003fcc 	andi	r4,r4,255
8112e9dc:	2002c71e 	bne	r4,zero,8112f4fc <___svfiprintf_internal_r+0x122c>
8112e9e0:	9080080c 	andi	r2,r18,32
8112e9e4:	10004926 	beq	r2,zero,8112eb0c <___svfiprintf_internal_r+0x83c>
8112e9e8:	dac02317 	ldw	r11,140(sp)
8112e9ec:	58800117 	ldw	r2,4(r11)
8112e9f0:	5f000017 	ldw	fp,0(r11)
8112e9f4:	5ac00204 	addi	r11,r11,8
8112e9f8:	dac02315 	stw	r11,140(sp)
8112e9fc:	1013883a 	mov	r9,r2
8112ea00:	10004b16 	blt	r2,zero,8112eb30 <___svfiprintf_internal_r+0x860>
8112ea04:	da801d83 	ldbu	r10,118(sp)
8112ea08:	8001cb16 	blt	r16,zero,8112f138 <___svfiprintf_internal_r+0xe68>
8112ea0c:	00ffdfc4 	movi	r3,-129
8112ea10:	e244b03a 	or	r2,fp,r9
8112ea14:	90e4703a 	and	r18,r18,r3
8112ea18:	103f4726 	beq	r2,zero,8112e738 <__reset+0xfb10e738>
8112ea1c:	48008c26 	beq	r9,zero,8112ec50 <___svfiprintf_internal_r+0x980>
8112ea20:	dc802015 	stw	r18,128(sp)
8112ea24:	dc002115 	stw	r16,132(sp)
8112ea28:	dc401a04 	addi	r17,sp,104
8112ea2c:	e021883a 	mov	r16,fp
8112ea30:	da002215 	stw	r8,136(sp)
8112ea34:	5039883a 	mov	fp,r10
8112ea38:	4825883a 	mov	r18,r9
8112ea3c:	8009883a 	mov	r4,r16
8112ea40:	900b883a 	mov	r5,r18
8112ea44:	01800284 	movi	r6,10
8112ea48:	000f883a 	mov	r7,zero
8112ea4c:	11325e00 	call	811325e0 <__umoddi3>
8112ea50:	10800c04 	addi	r2,r2,48
8112ea54:	8c7fffc4 	addi	r17,r17,-1
8112ea58:	8009883a 	mov	r4,r16
8112ea5c:	900b883a 	mov	r5,r18
8112ea60:	88800005 	stb	r2,0(r17)
8112ea64:	01800284 	movi	r6,10
8112ea68:	000f883a 	mov	r7,zero
8112ea6c:	11320600 	call	81132060 <__udivdi3>
8112ea70:	1021883a 	mov	r16,r2
8112ea74:	10c4b03a 	or	r2,r2,r3
8112ea78:	1825883a 	mov	r18,r3
8112ea7c:	103fef1e 	bne	r2,zero,8112ea3c <__reset+0xfb10ea3c>
8112ea80:	dc802017 	ldw	r18,128(sp)
8112ea84:	dc002117 	ldw	r16,132(sp)
8112ea88:	da002217 	ldw	r8,136(sp)
8112ea8c:	e015883a 	mov	r10,fp
8112ea90:	d8c01e17 	ldw	r3,120(sp)
8112ea94:	1c47c83a 	sub	r3,r3,r17
8112ea98:	d8c02115 	stw	r3,132(sp)
8112ea9c:	003f2a06 	br	8112e748 <__reset+0xfb10e748>
8112eaa0:	dac02317 	ldw	r11,140(sp)
8112eaa4:	d8001d85 	stb	zero,118(sp)
8112eaa8:	5c400017 	ldw	r17,0(r11)
8112eaac:	5f000104 	addi	fp,r11,4
8112eab0:	88022f26 	beq	r17,zero,8112f370 <___svfiprintf_internal_r+0x10a0>
8112eab4:	80022516 	blt	r16,zero,8112f34c <___svfiprintf_internal_r+0x107c>
8112eab8:	800d883a 	mov	r6,r16
8112eabc:	000b883a 	mov	r5,zero
8112eac0:	8809883a 	mov	r4,r17
8112eac4:	da002c15 	stw	r8,176(sp)
8112eac8:	112a69c0 	call	8112a69c <memchr>
8112eacc:	da002c17 	ldw	r8,176(sp)
8112ead0:	10026426 	beq	r2,zero,8112f464 <___svfiprintf_internal_r+0x1194>
8112ead4:	1445c83a 	sub	r2,r2,r17
8112ead8:	d8802115 	stw	r2,132(sp)
8112eadc:	da801d83 	ldbu	r10,118(sp)
8112eae0:	df002315 	stw	fp,140(sp)
8112eae4:	0021883a 	mov	r16,zero
8112eae8:	003f1706 	br	8112e748 <__reset+0xfb10e748>
8112eaec:	94800814 	ori	r18,r18,32
8112eaf0:	98c00007 	ldb	r3,0(r19)
8112eaf4:	003e4706 	br	8112e414 <__reset+0xfb10e414>
8112eaf8:	21003fcc 	andi	r4,r4,255
8112eafc:	2002701e 	bne	r4,zero,8112f4c0 <___svfiprintf_internal_r+0x11f0>
8112eb00:	94800414 	ori	r18,r18,16
8112eb04:	9080080c 	andi	r2,r18,32
8112eb08:	103fb71e 	bne	r2,zero,8112e9e8 <__reset+0xfb10e9e8>
8112eb0c:	9080040c 	andi	r2,r18,16
8112eb10:	1001ab26 	beq	r2,zero,8112f1c0 <___svfiprintf_internal_r+0xef0>
8112eb14:	dac02317 	ldw	r11,140(sp)
8112eb18:	5f000017 	ldw	fp,0(r11)
8112eb1c:	5ac00104 	addi	r11,r11,4
8112eb20:	dac02315 	stw	r11,140(sp)
8112eb24:	e013d7fa 	srai	r9,fp,31
8112eb28:	4805883a 	mov	r2,r9
8112eb2c:	103fb50e 	bge	r2,zero,8112ea04 <__reset+0xfb10ea04>
8112eb30:	0739c83a 	sub	fp,zero,fp
8112eb34:	02800b44 	movi	r10,45
8112eb38:	e004c03a 	cmpne	r2,fp,zero
8112eb3c:	0253c83a 	sub	r9,zero,r9
8112eb40:	da801d85 	stb	r10,118(sp)
8112eb44:	4893c83a 	sub	r9,r9,r2
8112eb48:	80023016 	blt	r16,zero,8112f40c <___svfiprintf_internal_r+0x113c>
8112eb4c:	00bfdfc4 	movi	r2,-129
8112eb50:	90a4703a 	and	r18,r18,r2
8112eb54:	483fb21e 	bne	r9,zero,8112ea20 <__reset+0xfb10ea20>
8112eb58:	00003d06 	br	8112ec50 <___svfiprintf_internal_r+0x980>
8112eb5c:	9817883a 	mov	r11,r19
8112eb60:	d8002415 	stw	zero,144(sp)
8112eb64:	18bff404 	addi	r2,r3,-48
8112eb68:	0019883a 	mov	r12,zero
8112eb6c:	58c00007 	ldb	r3,0(r11)
8112eb70:	630002a4 	muli	r12,r12,10
8112eb74:	9cc00044 	addi	r19,r19,1
8112eb78:	9817883a 	mov	r11,r19
8112eb7c:	1319883a 	add	r12,r2,r12
8112eb80:	18bff404 	addi	r2,r3,-48
8112eb84:	30bff92e 	bgeu	r6,r2,8112eb6c <__reset+0xfb10eb6c>
8112eb88:	db002415 	stw	r12,144(sp)
8112eb8c:	18bff804 	addi	r2,r3,-32
8112eb90:	28be232e 	bgeu	r5,r2,8112e420 <__reset+0xfb10e420>
8112eb94:	21003fcc 	andi	r4,r4,255
8112eb98:	20024b1e 	bne	r4,zero,8112f4c8 <___svfiprintf_internal_r+0x11f8>
8112eb9c:	1800d626 	beq	r3,zero,8112eef8 <___svfiprintf_internal_r+0xc28>
8112eba0:	02c00044 	movi	r11,1
8112eba4:	dac02015 	stw	r11,128(sp)
8112eba8:	d8c01005 	stb	r3,64(sp)
8112ebac:	d8001d85 	stb	zero,118(sp)
8112ebb0:	dac02115 	stw	r11,132(sp)
8112ebb4:	dc401004 	addi	r17,sp,64
8112ebb8:	003f2606 	br	8112e854 <__reset+0xfb10e854>
8112ebbc:	94802014 	ori	r18,r18,128
8112ebc0:	98c00007 	ldb	r3,0(r19)
8112ebc4:	003e1306 	br	8112e414 <__reset+0xfb10e414>
8112ebc8:	98c00007 	ldb	r3,0(r19)
8112ebcc:	9ac00044 	addi	r11,r19,1
8112ebd0:	1a822b26 	beq	r3,r10,8112f480 <___svfiprintf_internal_r+0x11b0>
8112ebd4:	18bff404 	addi	r2,r3,-48
8112ebd8:	0021883a 	mov	r16,zero
8112ebdc:	30821e36 	bltu	r6,r2,8112f458 <___svfiprintf_internal_r+0x1188>
8112ebe0:	58c00007 	ldb	r3,0(r11)
8112ebe4:	840002a4 	muli	r16,r16,10
8112ebe8:	5cc00044 	addi	r19,r11,1
8112ebec:	9817883a 	mov	r11,r19
8112ebf0:	80a1883a 	add	r16,r16,r2
8112ebf4:	18bff404 	addi	r2,r3,-48
8112ebf8:	30bff92e 	bgeu	r6,r2,8112ebe0 <__reset+0xfb10ebe0>
8112ebfc:	803e060e 	bge	r16,zero,8112e418 <__reset+0xfb10e418>
8112ec00:	043fffc4 	movi	r16,-1
8112ec04:	003e0406 	br	8112e418 <__reset+0xfb10e418>
8112ec08:	21003fcc 	andi	r4,r4,255
8112ec0c:	2002371e 	bne	r4,zero,8112f4ec <___svfiprintf_internal_r+0x121c>
8112ec10:	94800414 	ori	r18,r18,16
8112ec14:	9080080c 	andi	r2,r18,32
8112ec18:	103ebb1e 	bne	r2,zero,8112e708 <__reset+0xfb10e708>
8112ec1c:	9080040c 	andi	r2,r18,16
8112ec20:	10013b26 	beq	r2,zero,8112f110 <___svfiprintf_internal_r+0xe40>
8112ec24:	dac02317 	ldw	r11,140(sp)
8112ec28:	d8001d85 	stb	zero,118(sp)
8112ec2c:	0013883a 	mov	r9,zero
8112ec30:	58800104 	addi	r2,r11,4
8112ec34:	5f000017 	ldw	fp,0(r11)
8112ec38:	80013d16 	blt	r16,zero,8112f130 <___svfiprintf_internal_r+0xe60>
8112ec3c:	00ffdfc4 	movi	r3,-129
8112ec40:	d8802315 	stw	r2,140(sp)
8112ec44:	90e4703a 	and	r18,r18,r3
8112ec48:	0015883a 	mov	r10,zero
8112ec4c:	e03eba26 	beq	fp,zero,8112e738 <__reset+0xfb10e738>
8112ec50:	00800244 	movi	r2,9
8112ec54:	173f7236 	bltu	r2,fp,8112ea20 <__reset+0xfb10ea20>
8112ec58:	dac02b17 	ldw	r11,172(sp)
8112ec5c:	e7000c04 	addi	fp,fp,48
8112ec60:	df0019c5 	stb	fp,103(sp)
8112ec64:	dac02115 	stw	r11,132(sp)
8112ec68:	dc4019c4 	addi	r17,sp,103
8112ec6c:	003eb606 	br	8112e748 <__reset+0xfb10e748>
8112ec70:	21003fcc 	andi	r4,r4,255
8112ec74:	20021f1e 	bne	r4,zero,8112f4f4 <___svfiprintf_internal_r+0x1224>
8112ec78:	94800414 	ori	r18,r18,16
8112ec7c:	9080080c 	andi	r2,r18,32
8112ec80:	103ec51e 	bne	r2,zero,8112e798 <__reset+0xfb10e798>
8112ec84:	9080040c 	andi	r2,r18,16
8112ec88:	10016926 	beq	r2,zero,8112f230 <___svfiprintf_internal_r+0xf60>
8112ec8c:	dac02317 	ldw	r11,140(sp)
8112ec90:	d8001d85 	stb	zero,118(sp)
8112ec94:	0013883a 	mov	r9,zero
8112ec98:	58800104 	addi	r2,r11,4
8112ec9c:	5f000017 	ldw	fp,0(r11)
8112eca0:	80016b16 	blt	r16,zero,8112f250 <___svfiprintf_internal_r+0xf80>
8112eca4:	00ffdfc4 	movi	r3,-129
8112eca8:	d8802315 	stw	r2,140(sp)
8112ecac:	90e4703a 	and	r18,r18,r3
8112ecb0:	e03ec41e 	bne	fp,zero,8112e7c4 <__reset+0xfb10e7c4>
8112ecb4:	0015883a 	mov	r10,zero
8112ecb8:	8001c226 	beq	r16,zero,8112f3c4 <___svfiprintf_internal_r+0x10f4>
8112ecbc:	0039883a 	mov	fp,zero
8112ecc0:	0013883a 	mov	r9,zero
8112ecc4:	003ec006 	br	8112e7c8 <__reset+0xfb10e7c8>
8112ecc8:	d8c01c17 	ldw	r3,112(sp)
8112eccc:	d8801b17 	ldw	r2,108(sp)
8112ecd0:	d9001d87 	ldb	r4,118(sp)
8112ecd4:	20000b26 	beq	r4,zero,8112ed04 <___svfiprintf_internal_r+0xa34>
8112ecd8:	d9001d84 	addi	r4,sp,118
8112ecdc:	18c00044 	addi	r3,r3,1
8112ece0:	10800044 	addi	r2,r2,1
8112ece4:	41000015 	stw	r4,0(r8)
8112ece8:	01000044 	movi	r4,1
8112ecec:	41000115 	stw	r4,4(r8)
8112ecf0:	d8c01c15 	stw	r3,112(sp)
8112ecf4:	d8801b15 	stw	r2,108(sp)
8112ecf8:	010001c4 	movi	r4,7
8112ecfc:	2080e116 	blt	r4,r2,8112f084 <___svfiprintf_internal_r+0xdb4>
8112ed00:	42000204 	addi	r8,r8,8
8112ed04:	dac02217 	ldw	r11,136(sp)
8112ed08:	58000b26 	beq	r11,zero,8112ed38 <___svfiprintf_internal_r+0xa68>
8112ed0c:	d9001d04 	addi	r4,sp,116
8112ed10:	18c00084 	addi	r3,r3,2
8112ed14:	10800044 	addi	r2,r2,1
8112ed18:	41000015 	stw	r4,0(r8)
8112ed1c:	01000084 	movi	r4,2
8112ed20:	41000115 	stw	r4,4(r8)
8112ed24:	d8c01c15 	stw	r3,112(sp)
8112ed28:	d8801b15 	stw	r2,108(sp)
8112ed2c:	010001c4 	movi	r4,7
8112ed30:	2080dd16 	blt	r4,r2,8112f0a8 <___svfiprintf_internal_r+0xdd8>
8112ed34:	42000204 	addi	r8,r8,8
8112ed38:	dac02617 	ldw	r11,152(sp)
8112ed3c:	01002004 	movi	r4,128
8112ed40:	59008426 	beq	r11,r4,8112ef54 <___svfiprintf_internal_r+0xc84>
8112ed44:	dac02117 	ldw	r11,132(sp)
8112ed48:	82e1c83a 	sub	r16,r16,r11
8112ed4c:	0400270e 	bge	zero,r16,8112edec <___svfiprintf_internal_r+0xb1c>
8112ed50:	01c00404 	movi	r7,16
8112ed54:	3c016a0e 	bge	r7,r16,8112f300 <___svfiprintf_internal_r+0x1030>
8112ed58:	01604574 	movhi	r5,33045
8112ed5c:	29798104 	addi	r5,r5,-6652
8112ed60:	d9402215 	stw	r5,136(sp)
8112ed64:	070001c4 	movi	fp,7
8112ed68:	00000306 	br	8112ed78 <___svfiprintf_internal_r+0xaa8>
8112ed6c:	843ffc04 	addi	r16,r16,-16
8112ed70:	42000204 	addi	r8,r8,8
8112ed74:	3c00130e 	bge	r7,r16,8112edc4 <___svfiprintf_internal_r+0xaf4>
8112ed78:	18c00404 	addi	r3,r3,16
8112ed7c:	10800044 	addi	r2,r2,1
8112ed80:	45000015 	stw	r20,0(r8)
8112ed84:	41c00115 	stw	r7,4(r8)
8112ed88:	d8c01c15 	stw	r3,112(sp)
8112ed8c:	d8801b15 	stw	r2,108(sp)
8112ed90:	e0bff60e 	bge	fp,r2,8112ed6c <__reset+0xfb10ed6c>
8112ed94:	d9801a04 	addi	r6,sp,104
8112ed98:	b80b883a 	mov	r5,r23
8112ed9c:	a809883a 	mov	r4,r21
8112eda0:	d9c02c15 	stw	r7,176(sp)
8112eda4:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112eda8:	d9c02c17 	ldw	r7,176(sp)
8112edac:	1000581e 	bne	r2,zero,8112ef10 <___svfiprintf_internal_r+0xc40>
8112edb0:	843ffc04 	addi	r16,r16,-16
8112edb4:	d8c01c17 	ldw	r3,112(sp)
8112edb8:	d8801b17 	ldw	r2,108(sp)
8112edbc:	d811883a 	mov	r8,sp
8112edc0:	3c3fed16 	blt	r7,r16,8112ed78 <__reset+0xfb10ed78>
8112edc4:	dac02217 	ldw	r11,136(sp)
8112edc8:	1c07883a 	add	r3,r3,r16
8112edcc:	10800044 	addi	r2,r2,1
8112edd0:	42c00015 	stw	r11,0(r8)
8112edd4:	44000115 	stw	r16,4(r8)
8112edd8:	d8c01c15 	stw	r3,112(sp)
8112eddc:	d8801b15 	stw	r2,108(sp)
8112ede0:	010001c4 	movi	r4,7
8112ede4:	20809e16 	blt	r4,r2,8112f060 <___svfiprintf_internal_r+0xd90>
8112ede8:	42000204 	addi	r8,r8,8
8112edec:	dac02117 	ldw	r11,132(sp)
8112edf0:	10800044 	addi	r2,r2,1
8112edf4:	44400015 	stw	r17,0(r8)
8112edf8:	58c7883a 	add	r3,r11,r3
8112edfc:	42c00115 	stw	r11,4(r8)
8112ee00:	d8c01c15 	stw	r3,112(sp)
8112ee04:	d8801b15 	stw	r2,108(sp)
8112ee08:	010001c4 	movi	r4,7
8112ee0c:	20807f16 	blt	r4,r2,8112f00c <___svfiprintf_internal_r+0xd3c>
8112ee10:	42000204 	addi	r8,r8,8
8112ee14:	9480010c 	andi	r18,r18,4
8112ee18:	90002926 	beq	r18,zero,8112eec0 <___svfiprintf_internal_r+0xbf0>
8112ee1c:	dac02417 	ldw	r11,144(sp)
8112ee20:	d8802017 	ldw	r2,128(sp)
8112ee24:	58a1c83a 	sub	r16,r11,r2
8112ee28:	0400250e 	bge	zero,r16,8112eec0 <___svfiprintf_internal_r+0xbf0>
8112ee2c:	04400404 	movi	r17,16
8112ee30:	d8801b17 	ldw	r2,108(sp)
8112ee34:	8c017c0e 	bge	r17,r16,8112f428 <___svfiprintf_internal_r+0x1158>
8112ee38:	01604574 	movhi	r5,33045
8112ee3c:	29798504 	addi	r5,r5,-6636
8112ee40:	d9402815 	stw	r5,160(sp)
8112ee44:	048001c4 	movi	r18,7
8112ee48:	00000306 	br	8112ee58 <___svfiprintf_internal_r+0xb88>
8112ee4c:	843ffc04 	addi	r16,r16,-16
8112ee50:	42000204 	addi	r8,r8,8
8112ee54:	8c00110e 	bge	r17,r16,8112ee9c <___svfiprintf_internal_r+0xbcc>
8112ee58:	18c00404 	addi	r3,r3,16
8112ee5c:	10800044 	addi	r2,r2,1
8112ee60:	45800015 	stw	r22,0(r8)
8112ee64:	44400115 	stw	r17,4(r8)
8112ee68:	d8c01c15 	stw	r3,112(sp)
8112ee6c:	d8801b15 	stw	r2,108(sp)
8112ee70:	90bff60e 	bge	r18,r2,8112ee4c <__reset+0xfb10ee4c>
8112ee74:	d9801a04 	addi	r6,sp,104
8112ee78:	b80b883a 	mov	r5,r23
8112ee7c:	a809883a 	mov	r4,r21
8112ee80:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112ee84:	1000221e 	bne	r2,zero,8112ef10 <___svfiprintf_internal_r+0xc40>
8112ee88:	843ffc04 	addi	r16,r16,-16
8112ee8c:	d8c01c17 	ldw	r3,112(sp)
8112ee90:	d8801b17 	ldw	r2,108(sp)
8112ee94:	d811883a 	mov	r8,sp
8112ee98:	8c3fef16 	blt	r17,r16,8112ee58 <__reset+0xfb10ee58>
8112ee9c:	dac02817 	ldw	r11,160(sp)
8112eea0:	1c07883a 	add	r3,r3,r16
8112eea4:	10800044 	addi	r2,r2,1
8112eea8:	42c00015 	stw	r11,0(r8)
8112eeac:	44000115 	stw	r16,4(r8)
8112eeb0:	d8c01c15 	stw	r3,112(sp)
8112eeb4:	d8801b15 	stw	r2,108(sp)
8112eeb8:	010001c4 	movi	r4,7
8112eebc:	2080aa16 	blt	r4,r2,8112f168 <___svfiprintf_internal_r+0xe98>
8112eec0:	d8802417 	ldw	r2,144(sp)
8112eec4:	dac02017 	ldw	r11,128(sp)
8112eec8:	12c0010e 	bge	r2,r11,8112eed0 <___svfiprintf_internal_r+0xc00>
8112eecc:	5805883a 	mov	r2,r11
8112eed0:	dac02517 	ldw	r11,148(sp)
8112eed4:	5897883a 	add	r11,r11,r2
8112eed8:	dac02515 	stw	r11,148(sp)
8112eedc:	1800531e 	bne	r3,zero,8112f02c <___svfiprintf_internal_r+0xd5c>
8112eee0:	98800007 	ldb	r2,0(r19)
8112eee4:	d8001b15 	stw	zero,108(sp)
8112eee8:	d811883a 	mov	r8,sp
8112eeec:	103d231e 	bne	r2,zero,8112e37c <__reset+0xfb10e37c>
8112eef0:	9823883a 	mov	r17,r19
8112eef4:	003d3906 	br	8112e3dc <__reset+0xfb10e3dc>
8112eef8:	d8801c17 	ldw	r2,112(sp)
8112eefc:	10000426 	beq	r2,zero,8112ef10 <___svfiprintf_internal_r+0xc40>
8112ef00:	d9402717 	ldw	r5,156(sp)
8112ef04:	d9002a17 	ldw	r4,168(sp)
8112ef08:	d9801a04 	addi	r6,sp,104
8112ef0c:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112ef10:	dac02717 	ldw	r11,156(sp)
8112ef14:	d8802517 	ldw	r2,148(sp)
8112ef18:	58c0030b 	ldhu	r3,12(r11)
8112ef1c:	18c0100c 	andi	r3,r3,64
8112ef20:	1801381e 	bne	r3,zero,8112f404 <___svfiprintf_internal_r+0x1134>
8112ef24:	dfc03717 	ldw	ra,220(sp)
8112ef28:	df003617 	ldw	fp,216(sp)
8112ef2c:	ddc03517 	ldw	r23,212(sp)
8112ef30:	dd803417 	ldw	r22,208(sp)
8112ef34:	dd403317 	ldw	r21,204(sp)
8112ef38:	dd003217 	ldw	r20,200(sp)
8112ef3c:	dcc03117 	ldw	r19,196(sp)
8112ef40:	dc803017 	ldw	r18,192(sp)
8112ef44:	dc402f17 	ldw	r17,188(sp)
8112ef48:	dc002e17 	ldw	r16,184(sp)
8112ef4c:	dec03804 	addi	sp,sp,224
8112ef50:	f800283a 	ret
8112ef54:	dac02417 	ldw	r11,144(sp)
8112ef58:	d9002017 	ldw	r4,128(sp)
8112ef5c:	5939c83a 	sub	fp,r11,r4
8112ef60:	073f780e 	bge	zero,fp,8112ed44 <__reset+0xfb10ed44>
8112ef64:	02400404 	movi	r9,16
8112ef68:	4f01370e 	bge	r9,fp,8112f448 <___svfiprintf_internal_r+0x1178>
8112ef6c:	02e04574 	movhi	r11,33045
8112ef70:	5af98104 	addi	r11,r11,-6652
8112ef74:	dac02215 	stw	r11,136(sp)
8112ef78:	028001c4 	movi	r10,7
8112ef7c:	00000306 	br	8112ef8c <___svfiprintf_internal_r+0xcbc>
8112ef80:	e73ffc04 	addi	fp,fp,-16
8112ef84:	42000204 	addi	r8,r8,8
8112ef88:	4f00150e 	bge	r9,fp,8112efe0 <___svfiprintf_internal_r+0xd10>
8112ef8c:	18c00404 	addi	r3,r3,16
8112ef90:	10800044 	addi	r2,r2,1
8112ef94:	45000015 	stw	r20,0(r8)
8112ef98:	42400115 	stw	r9,4(r8)
8112ef9c:	d8c01c15 	stw	r3,112(sp)
8112efa0:	d8801b15 	stw	r2,108(sp)
8112efa4:	50bff60e 	bge	r10,r2,8112ef80 <__reset+0xfb10ef80>
8112efa8:	d9801a04 	addi	r6,sp,104
8112efac:	b80b883a 	mov	r5,r23
8112efb0:	a809883a 	mov	r4,r21
8112efb4:	da402c15 	stw	r9,176(sp)
8112efb8:	da802d15 	stw	r10,180(sp)
8112efbc:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112efc0:	da402c17 	ldw	r9,176(sp)
8112efc4:	da802d17 	ldw	r10,180(sp)
8112efc8:	103fd11e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112efcc:	e73ffc04 	addi	fp,fp,-16
8112efd0:	d8c01c17 	ldw	r3,112(sp)
8112efd4:	d8801b17 	ldw	r2,108(sp)
8112efd8:	d811883a 	mov	r8,sp
8112efdc:	4f3feb16 	blt	r9,fp,8112ef8c <__reset+0xfb10ef8c>
8112efe0:	dac02217 	ldw	r11,136(sp)
8112efe4:	1f07883a 	add	r3,r3,fp
8112efe8:	10800044 	addi	r2,r2,1
8112efec:	42c00015 	stw	r11,0(r8)
8112eff0:	47000115 	stw	fp,4(r8)
8112eff4:	d8c01c15 	stw	r3,112(sp)
8112eff8:	d8801b15 	stw	r2,108(sp)
8112effc:	010001c4 	movi	r4,7
8112f000:	2080b616 	blt	r4,r2,8112f2dc <___svfiprintf_internal_r+0x100c>
8112f004:	42000204 	addi	r8,r8,8
8112f008:	003f4e06 	br	8112ed44 <__reset+0xfb10ed44>
8112f00c:	d9801a04 	addi	r6,sp,104
8112f010:	b80b883a 	mov	r5,r23
8112f014:	a809883a 	mov	r4,r21
8112f018:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f01c:	103fbc1e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f020:	d8c01c17 	ldw	r3,112(sp)
8112f024:	d811883a 	mov	r8,sp
8112f028:	003f7a06 	br	8112ee14 <__reset+0xfb10ee14>
8112f02c:	d9801a04 	addi	r6,sp,104
8112f030:	b80b883a 	mov	r5,r23
8112f034:	a809883a 	mov	r4,r21
8112f038:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f03c:	103fa826 	beq	r2,zero,8112eee0 <__reset+0xfb10eee0>
8112f040:	003fb306 	br	8112ef10 <__reset+0xfb10ef10>
8112f044:	d9801a04 	addi	r6,sp,104
8112f048:	b80b883a 	mov	r5,r23
8112f04c:	a809883a 	mov	r4,r21
8112f050:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f054:	103fae1e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f058:	d811883a 	mov	r8,sp
8112f05c:	003cdc06 	br	8112e3d0 <__reset+0xfb10e3d0>
8112f060:	d9801a04 	addi	r6,sp,104
8112f064:	b80b883a 	mov	r5,r23
8112f068:	a809883a 	mov	r4,r21
8112f06c:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f070:	103fa71e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f074:	d8c01c17 	ldw	r3,112(sp)
8112f078:	d8801b17 	ldw	r2,108(sp)
8112f07c:	d811883a 	mov	r8,sp
8112f080:	003f5a06 	br	8112edec <__reset+0xfb10edec>
8112f084:	d9801a04 	addi	r6,sp,104
8112f088:	b80b883a 	mov	r5,r23
8112f08c:	a809883a 	mov	r4,r21
8112f090:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f094:	103f9e1e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f098:	d8c01c17 	ldw	r3,112(sp)
8112f09c:	d8801b17 	ldw	r2,108(sp)
8112f0a0:	d811883a 	mov	r8,sp
8112f0a4:	003f1706 	br	8112ed04 <__reset+0xfb10ed04>
8112f0a8:	d9801a04 	addi	r6,sp,104
8112f0ac:	b80b883a 	mov	r5,r23
8112f0b0:	a809883a 	mov	r4,r21
8112f0b4:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f0b8:	103f951e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f0bc:	d8c01c17 	ldw	r3,112(sp)
8112f0c0:	d8801b17 	ldw	r2,108(sp)
8112f0c4:	d811883a 	mov	r8,sp
8112f0c8:	003f1b06 	br	8112ed38 <__reset+0xfb10ed38>
8112f0cc:	d8001d85 	stb	zero,118(sp)
8112f0d0:	80007b16 	blt	r16,zero,8112f2c0 <___svfiprintf_internal_r+0xff0>
8112f0d4:	00ffdfc4 	movi	r3,-129
8112f0d8:	e244b03a 	or	r2,fp,r9
8112f0dc:	90e4703a 	and	r18,r18,r3
8112f0e0:	103d7026 	beq	r2,zero,8112e6a4 <__reset+0xfb10e6a4>
8112f0e4:	0015883a 	mov	r10,zero
8112f0e8:	003d7206 	br	8112e6b4 <__reset+0xfb10e6b4>
8112f0ec:	d9801a04 	addi	r6,sp,104
8112f0f0:	b80b883a 	mov	r5,r23
8112f0f4:	a809883a 	mov	r4,r21
8112f0f8:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f0fc:	103f841e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f100:	d8c01c17 	ldw	r3,112(sp)
8112f104:	d8801b17 	ldw	r2,108(sp)
8112f108:	d811883a 	mov	r8,sp
8112f10c:	003ef006 	br	8112ecd0 <__reset+0xfb10ecd0>
8112f110:	9080100c 	andi	r2,r18,64
8112f114:	d8001d85 	stb	zero,118(sp)
8112f118:	dac02317 	ldw	r11,140(sp)
8112f11c:	10008126 	beq	r2,zero,8112f324 <___svfiprintf_internal_r+0x1054>
8112f120:	58800104 	addi	r2,r11,4
8112f124:	5f00000b 	ldhu	fp,0(r11)
8112f128:	0013883a 	mov	r9,zero
8112f12c:	803ec30e 	bge	r16,zero,8112ec3c <__reset+0xfb10ec3c>
8112f130:	d8802315 	stw	r2,140(sp)
8112f134:	0015883a 	mov	r10,zero
8112f138:	e244b03a 	or	r2,fp,r9
8112f13c:	103e371e 	bne	r2,zero,8112ea1c <__reset+0xfb10ea1c>
8112f140:	00800044 	movi	r2,1
8112f144:	10803fcc 	andi	r2,r2,255
8112f148:	00c00044 	movi	r3,1
8112f14c:	10c06126 	beq	r2,r3,8112f2d4 <___svfiprintf_internal_r+0x1004>
8112f150:	00c00084 	movi	r3,2
8112f154:	10fd5526 	beq	r2,r3,8112e6ac <__reset+0xfb10e6ac>
8112f158:	003ed806 	br	8112ecbc <__reset+0xfb10ecbc>
8112f15c:	d8802315 	stw	r2,140(sp)
8112f160:	98c00007 	ldb	r3,0(r19)
8112f164:	003cab06 	br	8112e414 <__reset+0xfb10e414>
8112f168:	d9801a04 	addi	r6,sp,104
8112f16c:	b80b883a 	mov	r5,r23
8112f170:	a809883a 	mov	r4,r21
8112f174:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f178:	103f651e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f17c:	d8c01c17 	ldw	r3,112(sp)
8112f180:	003f4f06 	br	8112eec0 <__reset+0xfb10eec0>
8112f184:	00a04574 	movhi	r2,33045
8112f188:	10b8f704 	addi	r2,r2,-7204
8112f18c:	d8802915 	stw	r2,164(sp)
8112f190:	003d4406 	br	8112e6a4 <__reset+0xfb10e6a4>
8112f194:	dac02317 	ldw	r11,140(sp)
8112f198:	58800017 	ldw	r2,0(r11)
8112f19c:	dac02517 	ldw	r11,148(sp)
8112f1a0:	5807d7fa 	srai	r3,r11,31
8112f1a4:	dac02317 	ldw	r11,140(sp)
8112f1a8:	10c00115 	stw	r3,4(r2)
8112f1ac:	5ac00104 	addi	r11,r11,4
8112f1b0:	dac02315 	stw	r11,140(sp)
8112f1b4:	dac02517 	ldw	r11,148(sp)
8112f1b8:	12c00015 	stw	r11,0(r2)
8112f1bc:	003c6d06 	br	8112e374 <__reset+0xfb10e374>
8112f1c0:	9080100c 	andi	r2,r18,64
8112f1c4:	dac02317 	ldw	r11,140(sp)
8112f1c8:	103e5326 	beq	r2,zero,8112eb18 <__reset+0xfb10eb18>
8112f1cc:	5f00000f 	ldh	fp,0(r11)
8112f1d0:	5ac00104 	addi	r11,r11,4
8112f1d4:	dac02315 	stw	r11,140(sp)
8112f1d8:	e013d7fa 	srai	r9,fp,31
8112f1dc:	4805883a 	mov	r2,r9
8112f1e0:	003e0706 	br	8112ea00 <__reset+0xfb10ea00>
8112f1e4:	00800c04 	movi	r2,48
8112f1e8:	d8801d05 	stb	r2,116(sp)
8112f1ec:	d8c01d45 	stb	r3,117(sp)
8112f1f0:	d8001d85 	stb	zero,118(sp)
8112f1f4:	90800094 	ori	r2,r18,2
8112f1f8:	80008f16 	blt	r16,zero,8112f438 <___svfiprintf_internal_r+0x1168>
8112f1fc:	00bfdfc4 	movi	r2,-129
8112f200:	90a4703a 	and	r18,r18,r2
8112f204:	94800094 	ori	r18,r18,2
8112f208:	0015883a 	mov	r10,zero
8112f20c:	003d2906 	br	8112e6b4 <__reset+0xfb10e6b4>
8112f210:	98c00007 	ldb	r3,0(r19)
8112f214:	003c7f06 	br	8112e414 <__reset+0xfb10e414>
8112f218:	dac02317 	ldw	r11,140(sp)
8112f21c:	0013883a 	mov	r9,zero
8112f220:	5f000017 	ldw	fp,0(r11)
8112f224:	5ac00104 	addi	r11,r11,4
8112f228:	dac02315 	stw	r11,140(sp)
8112f22c:	003d1506 	br	8112e684 <__reset+0xfb10e684>
8112f230:	9080100c 	andi	r2,r18,64
8112f234:	d8001d85 	stb	zero,118(sp)
8112f238:	dac02317 	ldw	r11,140(sp)
8112f23c:	10003426 	beq	r2,zero,8112f310 <___svfiprintf_internal_r+0x1040>
8112f240:	58800104 	addi	r2,r11,4
8112f244:	5f00000b 	ldhu	fp,0(r11)
8112f248:	0013883a 	mov	r9,zero
8112f24c:	803e950e 	bge	r16,zero,8112eca4 <__reset+0xfb10eca4>
8112f250:	e246b03a 	or	r3,fp,r9
8112f254:	d8802315 	stw	r2,140(sp)
8112f258:	183d5a1e 	bne	r3,zero,8112e7c4 <__reset+0xfb10e7c4>
8112f25c:	0015883a 	mov	r10,zero
8112f260:	0005883a 	mov	r2,zero
8112f264:	003fb706 	br	8112f144 <__reset+0xfb10f144>
8112f268:	98c00043 	ldbu	r3,1(r19)
8112f26c:	94800814 	ori	r18,r18,32
8112f270:	9cc00044 	addi	r19,r19,1
8112f274:	18c03fcc 	andi	r3,r3,255
8112f278:	18c0201c 	xori	r3,r3,128
8112f27c:	18ffe004 	addi	r3,r3,-128
8112f280:	003c6406 	br	8112e414 <__reset+0xfb10e414>
8112f284:	d8c02315 	stw	r3,140(sp)
8112f288:	0015883a 	mov	r10,zero
8112f28c:	003faa06 	br	8112f138 <__reset+0xfb10f138>
8112f290:	dac02317 	ldw	r11,140(sp)
8112f294:	58800017 	ldw	r2,0(r11)
8112f298:	5ac00104 	addi	r11,r11,4
8112f29c:	dac02315 	stw	r11,140(sp)
8112f2a0:	dac02517 	ldw	r11,148(sp)
8112f2a4:	12c00015 	stw	r11,0(r2)
8112f2a8:	003c3206 	br	8112e374 <__reset+0xfb10e374>
8112f2ac:	01204574 	movhi	r4,33045
8112f2b0:	2138f704 	addi	r4,r4,-7204
8112f2b4:	d9002915 	stw	r4,164(sp)
8112f2b8:	d8c02315 	stw	r3,140(sp)
8112f2bc:	1025883a 	mov	r18,r2
8112f2c0:	e244b03a 	or	r2,fp,r9
8112f2c4:	103f871e 	bne	r2,zero,8112f0e4 <__reset+0xfb10f0e4>
8112f2c8:	0015883a 	mov	r10,zero
8112f2cc:	00800084 	movi	r2,2
8112f2d0:	003f9c06 	br	8112f144 <__reset+0xfb10f144>
8112f2d4:	0039883a 	mov	fp,zero
8112f2d8:	003e5f06 	br	8112ec58 <__reset+0xfb10ec58>
8112f2dc:	d9801a04 	addi	r6,sp,104
8112f2e0:	b80b883a 	mov	r5,r23
8112f2e4:	a809883a 	mov	r4,r21
8112f2e8:	112e0f80 	call	8112e0f8 <__ssprint_r>
8112f2ec:	103f081e 	bne	r2,zero,8112ef10 <__reset+0xfb10ef10>
8112f2f0:	d8c01c17 	ldw	r3,112(sp)
8112f2f4:	d8801b17 	ldw	r2,108(sp)
8112f2f8:	d811883a 	mov	r8,sp
8112f2fc:	003e9106 	br	8112ed44 <__reset+0xfb10ed44>
8112f300:	01204574 	movhi	r4,33045
8112f304:	21398104 	addi	r4,r4,-6652
8112f308:	d9002215 	stw	r4,136(sp)
8112f30c:	003ead06 	br	8112edc4 <__reset+0xfb10edc4>
8112f310:	58800104 	addi	r2,r11,4
8112f314:	5f000017 	ldw	fp,0(r11)
8112f318:	0013883a 	mov	r9,zero
8112f31c:	803e610e 	bge	r16,zero,8112eca4 <__reset+0xfb10eca4>
8112f320:	003fcb06 	br	8112f250 <__reset+0xfb10f250>
8112f324:	58800104 	addi	r2,r11,4
8112f328:	5f000017 	ldw	fp,0(r11)
8112f32c:	0013883a 	mov	r9,zero
8112f330:	803e420e 	bge	r16,zero,8112ec3c <__reset+0xfb10ec3c>
8112f334:	003f7e06 	br	8112f130 <__reset+0xfb10f130>
8112f338:	5f000017 	ldw	fp,0(r11)
8112f33c:	5ac00104 	addi	r11,r11,4
8112f340:	0013883a 	mov	r9,zero
8112f344:	dac02315 	stw	r11,140(sp)
8112f348:	003cce06 	br	8112e684 <__reset+0xfb10e684>
8112f34c:	8809883a 	mov	r4,r17
8112f350:	da002c15 	stw	r8,176(sp)
8112f354:	11211a00 	call	811211a0 <strlen>
8112f358:	d8802115 	stw	r2,132(sp)
8112f35c:	da801d83 	ldbu	r10,118(sp)
8112f360:	df002315 	stw	fp,140(sp)
8112f364:	0021883a 	mov	r16,zero
8112f368:	da002c17 	ldw	r8,176(sp)
8112f36c:	003cf606 	br	8112e748 <__reset+0xfb10e748>
8112f370:	00800184 	movi	r2,6
8112f374:	1400012e 	bgeu	r2,r16,8112f37c <___svfiprintf_internal_r+0x10ac>
8112f378:	1021883a 	mov	r16,r2
8112f37c:	dc002115 	stw	r16,132(sp)
8112f380:	8005883a 	mov	r2,r16
8112f384:	80003c16 	blt	r16,zero,8112f478 <___svfiprintf_internal_r+0x11a8>
8112f388:	04604574 	movhi	r17,33045
8112f38c:	d8802015 	stw	r2,128(sp)
8112f390:	df002315 	stw	fp,140(sp)
8112f394:	8c78fc04 	addi	r17,r17,-7184
8112f398:	003d2e06 	br	8112e854 <__reset+0xfb10e854>
8112f39c:	04001004 	movi	r16,64
8112f3a0:	800b883a 	mov	r5,r16
8112f3a4:	111fe980 	call	8111fe98 <_malloc_r>
8112f3a8:	dac02717 	ldw	r11,156(sp)
8112f3ac:	58800015 	stw	r2,0(r11)
8112f3b0:	58800415 	stw	r2,16(r11)
8112f3b4:	10004826 	beq	r2,zero,8112f4d8 <___svfiprintf_internal_r+0x1208>
8112f3b8:	dac02717 	ldw	r11,156(sp)
8112f3bc:	5c000515 	stw	r16,20(r11)
8112f3c0:	003bd906 	br	8112e328 <__reset+0xfb10e328>
8112f3c4:	9080004c 	andi	r2,r18,1
8112f3c8:	0015883a 	mov	r10,zero
8112f3cc:	10000626 	beq	r2,zero,8112f3e8 <___svfiprintf_internal_r+0x1118>
8112f3d0:	dac02b17 	ldw	r11,172(sp)
8112f3d4:	00800c04 	movi	r2,48
8112f3d8:	d88019c5 	stb	r2,103(sp)
8112f3dc:	dac02115 	stw	r11,132(sp)
8112f3e0:	dc4019c4 	addi	r17,sp,103
8112f3e4:	003cd806 	br	8112e748 <__reset+0xfb10e748>
8112f3e8:	d8002115 	stw	zero,132(sp)
8112f3ec:	dc401a04 	addi	r17,sp,104
8112f3f0:	003cd506 	br	8112e748 <__reset+0xfb10e748>
8112f3f4:	01204574 	movhi	r4,33045
8112f3f8:	21398504 	addi	r4,r4,-6636
8112f3fc:	d9002815 	stw	r4,160(sp)
8112f400:	003d4306 	br	8112e910 <__reset+0xfb10e910>
8112f404:	00bfffc4 	movi	r2,-1
8112f408:	003ec606 	br	8112ef24 <__reset+0xfb10ef24>
8112f40c:	00800044 	movi	r2,1
8112f410:	10803fcc 	andi	r2,r2,255
8112f414:	00c00044 	movi	r3,1
8112f418:	10fd8026 	beq	r2,r3,8112ea1c <__reset+0xfb10ea1c>
8112f41c:	00c00084 	movi	r3,2
8112f420:	10fca426 	beq	r2,r3,8112e6b4 <__reset+0xfb10e6b4>
8112f424:	003ce806 	br	8112e7c8 <__reset+0xfb10e7c8>
8112f428:	01204574 	movhi	r4,33045
8112f42c:	21398504 	addi	r4,r4,-6636
8112f430:	d9002815 	stw	r4,160(sp)
8112f434:	003e9906 	br	8112ee9c <__reset+0xfb10ee9c>
8112f438:	1025883a 	mov	r18,r2
8112f43c:	0015883a 	mov	r10,zero
8112f440:	00800084 	movi	r2,2
8112f444:	003ff206 	br	8112f410 <__reset+0xfb10f410>
8112f448:	01604574 	movhi	r5,33045
8112f44c:	29798104 	addi	r5,r5,-6652
8112f450:	d9402215 	stw	r5,136(sp)
8112f454:	003ee206 	br	8112efe0 <__reset+0xfb10efe0>
8112f458:	5827883a 	mov	r19,r11
8112f45c:	0021883a 	mov	r16,zero
8112f460:	003bed06 	br	8112e418 <__reset+0xfb10e418>
8112f464:	dc002115 	stw	r16,132(sp)
8112f468:	da801d83 	ldbu	r10,118(sp)
8112f46c:	df002315 	stw	fp,140(sp)
8112f470:	0021883a 	mov	r16,zero
8112f474:	003cb406 	br	8112e748 <__reset+0xfb10e748>
8112f478:	0005883a 	mov	r2,zero
8112f47c:	003fc206 	br	8112f388 <__reset+0xfb10f388>
8112f480:	d8802317 	ldw	r2,140(sp)
8112f484:	98c00043 	ldbu	r3,1(r19)
8112f488:	5827883a 	mov	r19,r11
8112f48c:	14000017 	ldw	r16,0(r2)
8112f490:	10800104 	addi	r2,r2,4
8112f494:	d8802315 	stw	r2,140(sp)
8112f498:	803f760e 	bge	r16,zero,8112f274 <__reset+0xfb10f274>
8112f49c:	18c03fcc 	andi	r3,r3,255
8112f4a0:	18c0201c 	xori	r3,r3,128
8112f4a4:	043fffc4 	movi	r16,-1
8112f4a8:	18ffe004 	addi	r3,r3,-128
8112f4ac:	003bd906 	br	8112e414 <__reset+0xfb10e414>
8112f4b0:	d9c01d85 	stb	r7,118(sp)
8112f4b4:	003cb606 	br	8112e790 <__reset+0xfb10e790>
8112f4b8:	d9c01d85 	stb	r7,118(sp)
8112f4bc:	003d2106 	br	8112e944 <__reset+0xfb10e944>
8112f4c0:	d9c01d85 	stb	r7,118(sp)
8112f4c4:	003d8e06 	br	8112eb00 <__reset+0xfb10eb00>
8112f4c8:	d9c01d85 	stb	r7,118(sp)
8112f4cc:	003db306 	br	8112eb9c <__reset+0xfb10eb9c>
8112f4d0:	d9c01d85 	stb	r7,118(sp)
8112f4d4:	003c8a06 	br	8112e700 <__reset+0xfb10e700>
8112f4d8:	dac02a17 	ldw	r11,168(sp)
8112f4dc:	00800304 	movi	r2,12
8112f4e0:	58800015 	stw	r2,0(r11)
8112f4e4:	00bfffc4 	movi	r2,-1
8112f4e8:	003e8e06 	br	8112ef24 <__reset+0xfb10ef24>
8112f4ec:	d9c01d85 	stb	r7,118(sp)
8112f4f0:	003dc706 	br	8112ec10 <__reset+0xfb10ec10>
8112f4f4:	d9c01d85 	stb	r7,118(sp)
8112f4f8:	003ddf06 	br	8112ec78 <__reset+0xfb10ec78>
8112f4fc:	d9c01d85 	stb	r7,118(sp)
8112f500:	003d3706 	br	8112e9e0 <__reset+0xfb10e9e0>
8112f504:	d9c01d85 	stb	r7,118(sp)
8112f508:	003c5406 	br	8112e65c <__reset+0xfb10e65c>
8112f50c:	d9c01d85 	stb	r7,118(sp)
8112f510:	003d1d06 	br	8112e988 <__reset+0xfb10e988>

8112f514 <__submore>:
8112f514:	defffa04 	addi	sp,sp,-24
8112f518:	de00012e 	bgeu	sp,et,8112f520 <__submore+0xc>
8112f51c:	003b68fa 	trap	3
8112f520:	dc000015 	stw	r16,0(sp)
8112f524:	2821883a 	mov	r16,r5
8112f528:	29400c17 	ldw	r5,48(r5)
8112f52c:	dfc00515 	stw	ra,20(sp)
8112f530:	dd000415 	stw	r20,16(sp)
8112f534:	dcc00315 	stw	r19,12(sp)
8112f538:	dc800215 	stw	r18,8(sp)
8112f53c:	dc400115 	stw	r17,4(sp)
8112f540:	80801004 	addi	r2,r16,64
8112f544:	28801726 	beq	r5,r2,8112f5a4 <__submore+0x90>
8112f548:	84400d17 	ldw	r17,52(r16)
8112f54c:	8c67883a 	add	r19,r17,r17
8112f550:	980d883a 	mov	r6,r19
8112f554:	112b9a00 	call	8112b9a0 <_realloc_r>
8112f558:	1025883a 	mov	r18,r2
8112f55c:	10002226 	beq	r2,zero,8112f5e8 <__submore+0xd4>
8112f560:	1469883a 	add	r20,r2,r17
8112f564:	880d883a 	mov	r6,r17
8112f568:	100b883a 	mov	r5,r2
8112f56c:	a009883a 	mov	r4,r20
8112f570:	11206ac0 	call	811206ac <memcpy>
8112f574:	0005883a 	mov	r2,zero
8112f578:	85000015 	stw	r20,0(r16)
8112f57c:	84800c15 	stw	r18,48(r16)
8112f580:	84c00d15 	stw	r19,52(r16)
8112f584:	dfc00517 	ldw	ra,20(sp)
8112f588:	dd000417 	ldw	r20,16(sp)
8112f58c:	dcc00317 	ldw	r19,12(sp)
8112f590:	dc800217 	ldw	r18,8(sp)
8112f594:	dc400117 	ldw	r17,4(sp)
8112f598:	dc000017 	ldw	r16,0(sp)
8112f59c:	dec00604 	addi	sp,sp,24
8112f5a0:	f800283a 	ret
8112f5a4:	04410004 	movi	r17,1024
8112f5a8:	880b883a 	mov	r5,r17
8112f5ac:	111fe980 	call	8111fe98 <_malloc_r>
8112f5b0:	1007883a 	mov	r3,r2
8112f5b4:	10000c26 	beq	r2,zero,8112f5e8 <__submore+0xd4>
8112f5b8:	80801083 	ldbu	r2,66(r16)
8112f5bc:	80c00c15 	stw	r3,48(r16)
8112f5c0:	84400d15 	stw	r17,52(r16)
8112f5c4:	1880ffc5 	stb	r2,1023(r3)
8112f5c8:	81401043 	ldbu	r5,65(r16)
8112f5cc:	1900ff44 	addi	r4,r3,1021
8112f5d0:	0005883a 	mov	r2,zero
8112f5d4:	1940ff85 	stb	r5,1022(r3)
8112f5d8:	81401003 	ldbu	r5,64(r16)
8112f5dc:	1940ff45 	stb	r5,1021(r3)
8112f5e0:	81000015 	stw	r4,0(r16)
8112f5e4:	003fe706 	br	8112f584 <__reset+0xfb10f584>
8112f5e8:	00bfffc4 	movi	r2,-1
8112f5ec:	003fe506 	br	8112f584 <__reset+0xfb10f584>

8112f5f0 <_ungetc_r>:
8112f5f0:	00bfffc4 	movi	r2,-1
8112f5f4:	28806326 	beq	r5,r2,8112f784 <_ungetc_r+0x194>
8112f5f8:	defffb04 	addi	sp,sp,-20
8112f5fc:	de00012e 	bgeu	sp,et,8112f604 <_ungetc_r+0x14>
8112f600:	003b68fa 	trap	3
8112f604:	dcc00315 	stw	r19,12(sp)
8112f608:	dc400115 	stw	r17,4(sp)
8112f60c:	dc000015 	stw	r16,0(sp)
8112f610:	dfc00415 	stw	ra,16(sp)
8112f614:	dc800215 	stw	r18,8(sp)
8112f618:	2023883a 	mov	r17,r4
8112f61c:	3021883a 	mov	r16,r6
8112f620:	2827883a 	mov	r19,r5
8112f624:	20000226 	beq	r4,zero,8112f630 <_ungetc_r+0x40>
8112f628:	20800e17 	ldw	r2,56(r4)
8112f62c:	10002e26 	beq	r2,zero,8112f6e8 <_ungetc_r+0xf8>
8112f630:	80c0030b 	ldhu	r3,12(r16)
8112f634:	1888000c 	andi	r2,r3,8192
8112f638:	1000051e 	bne	r2,zero,8112f650 <_ungetc_r+0x60>
8112f63c:	81001917 	ldw	r4,100(r16)
8112f640:	00b7ffc4 	movi	r2,-8193
8112f644:	18c80014 	ori	r3,r3,8192
8112f648:	2084703a 	and	r2,r4,r2
8112f64c:	80801915 	stw	r2,100(r16)
8112f650:	00bff7c4 	movi	r2,-33
8112f654:	1884703a 	and	r2,r3,r2
8112f658:	8080030d 	sth	r2,12(r16)
8112f65c:	1900010c 	andi	r4,r3,4
8112f660:	2000061e 	bne	r4,zero,8112f67c <_ungetc_r+0x8c>
8112f664:	1900040c 	andi	r4,r3,16
8112f668:	20001d26 	beq	r4,zero,8112f6e0 <_ungetc_r+0xf0>
8112f66c:	18c0020c 	andi	r3,r3,8
8112f670:	1800331e 	bne	r3,zero,8112f740 <_ungetc_r+0x150>
8112f674:	10800114 	ori	r2,r2,4
8112f678:	8080030d 	sth	r2,12(r16)
8112f67c:	80800c17 	ldw	r2,48(r16)
8112f680:	9c803fcc 	andi	r18,r19,255
8112f684:	10001a26 	beq	r2,zero,8112f6f0 <_ungetc_r+0x100>
8112f688:	80c00117 	ldw	r3,4(r16)
8112f68c:	80800d17 	ldw	r2,52(r16)
8112f690:	18800f0e 	bge	r3,r2,8112f6d0 <_ungetc_r+0xe0>
8112f694:	80c00017 	ldw	r3,0(r16)
8112f698:	9005883a 	mov	r2,r18
8112f69c:	193fffc4 	addi	r4,r3,-1
8112f6a0:	81000015 	stw	r4,0(r16)
8112f6a4:	1cffffc5 	stb	r19,-1(r3)
8112f6a8:	80c00117 	ldw	r3,4(r16)
8112f6ac:	18c00044 	addi	r3,r3,1
8112f6b0:	80c00115 	stw	r3,4(r16)
8112f6b4:	dfc00417 	ldw	ra,16(sp)
8112f6b8:	dcc00317 	ldw	r19,12(sp)
8112f6bc:	dc800217 	ldw	r18,8(sp)
8112f6c0:	dc400117 	ldw	r17,4(sp)
8112f6c4:	dc000017 	ldw	r16,0(sp)
8112f6c8:	dec00504 	addi	sp,sp,20
8112f6cc:	f800283a 	ret
8112f6d0:	800b883a 	mov	r5,r16
8112f6d4:	8809883a 	mov	r4,r17
8112f6d8:	112f5140 	call	8112f514 <__submore>
8112f6dc:	103fed26 	beq	r2,zero,8112f694 <__reset+0xfb10f694>
8112f6e0:	00bfffc4 	movi	r2,-1
8112f6e4:	003ff306 	br	8112f6b4 <__reset+0xfb10f6b4>
8112f6e8:	11294740 	call	81129474 <__sinit>
8112f6ec:	003fd006 	br	8112f630 <__reset+0xfb10f630>
8112f6f0:	80c00417 	ldw	r3,16(r16)
8112f6f4:	80800017 	ldw	r2,0(r16)
8112f6f8:	18000326 	beq	r3,zero,8112f708 <_ungetc_r+0x118>
8112f6fc:	1880022e 	bgeu	r3,r2,8112f708 <_ungetc_r+0x118>
8112f700:	10ffffc3 	ldbu	r3,-1(r2)
8112f704:	90c01826 	beq	r18,r3,8112f768 <_ungetc_r+0x178>
8112f708:	81400117 	ldw	r5,4(r16)
8112f70c:	80800e15 	stw	r2,56(r16)
8112f710:	008000c4 	movi	r2,3
8112f714:	81001004 	addi	r4,r16,64
8112f718:	80c01084 	addi	r3,r16,66
8112f71c:	80800d15 	stw	r2,52(r16)
8112f720:	00800044 	movi	r2,1
8112f724:	80800115 	stw	r2,4(r16)
8112f728:	81400f15 	stw	r5,60(r16)
8112f72c:	81000c15 	stw	r4,48(r16)
8112f730:	84c01085 	stb	r19,66(r16)
8112f734:	80c00015 	stw	r3,0(r16)
8112f738:	9005883a 	mov	r2,r18
8112f73c:	003fdd06 	br	8112f6b4 <__reset+0xfb10f6b4>
8112f740:	800b883a 	mov	r5,r16
8112f744:	8809883a 	mov	r4,r17
8112f748:	11290780 	call	81129078 <_fflush_r>
8112f74c:	103fe41e 	bne	r2,zero,8112f6e0 <__reset+0xfb10f6e0>
8112f750:	8080030b 	ldhu	r2,12(r16)
8112f754:	00fffdc4 	movi	r3,-9
8112f758:	80000215 	stw	zero,8(r16)
8112f75c:	1884703a 	and	r2,r3,r2
8112f760:	80000615 	stw	zero,24(r16)
8112f764:	003fc306 	br	8112f674 <__reset+0xfb10f674>
8112f768:	80c00117 	ldw	r3,4(r16)
8112f76c:	10bfffc4 	addi	r2,r2,-1
8112f770:	80800015 	stw	r2,0(r16)
8112f774:	18800044 	addi	r2,r3,1
8112f778:	80800115 	stw	r2,4(r16)
8112f77c:	9005883a 	mov	r2,r18
8112f780:	003fcc06 	br	8112f6b4 <__reset+0xfb10f6b4>
8112f784:	00bfffc4 	movi	r2,-1
8112f788:	f800283a 	ret

8112f78c <ungetc>:
8112f78c:	00a04574 	movhi	r2,33045
8112f790:	1082c604 	addi	r2,r2,2840
8112f794:	280d883a 	mov	r6,r5
8112f798:	200b883a 	mov	r5,r4
8112f79c:	11000017 	ldw	r4,0(r2)
8112f7a0:	112f5f01 	jmpi	8112f5f0 <_ungetc_r>

8112f7a4 <__sprint_r.part.0>:
8112f7a4:	defff604 	addi	sp,sp,-40
8112f7a8:	de00012e 	bgeu	sp,et,8112f7b0 <__sprint_r.part.0+0xc>
8112f7ac:	003b68fa 	trap	3
8112f7b0:	28801917 	ldw	r2,100(r5)
8112f7b4:	dd400515 	stw	r21,20(sp)
8112f7b8:	dfc00915 	stw	ra,36(sp)
8112f7bc:	df000815 	stw	fp,32(sp)
8112f7c0:	ddc00715 	stw	r23,28(sp)
8112f7c4:	dd800615 	stw	r22,24(sp)
8112f7c8:	dd000415 	stw	r20,16(sp)
8112f7cc:	dcc00315 	stw	r19,12(sp)
8112f7d0:	dc800215 	stw	r18,8(sp)
8112f7d4:	dc400115 	stw	r17,4(sp)
8112f7d8:	dc000015 	stw	r16,0(sp)
8112f7dc:	1088000c 	andi	r2,r2,8192
8112f7e0:	302b883a 	mov	r21,r6
8112f7e4:	10002e26 	beq	r2,zero,8112f8a0 <__sprint_r.part.0+0xfc>
8112f7e8:	30800217 	ldw	r2,8(r6)
8112f7ec:	35800017 	ldw	r22,0(r6)
8112f7f0:	10002926 	beq	r2,zero,8112f898 <__sprint_r.part.0+0xf4>
8112f7f4:	2827883a 	mov	r19,r5
8112f7f8:	2029883a 	mov	r20,r4
8112f7fc:	b5c00104 	addi	r23,r22,4
8112f800:	04bfffc4 	movi	r18,-1
8112f804:	bc400017 	ldw	r17,0(r23)
8112f808:	b4000017 	ldw	r16,0(r22)
8112f80c:	0039883a 	mov	fp,zero
8112f810:	8822d0ba 	srli	r17,r17,2
8112f814:	8800031e 	bne	r17,zero,8112f824 <__sprint_r.part.0+0x80>
8112f818:	00001806 	br	8112f87c <__sprint_r.part.0+0xd8>
8112f81c:	84000104 	addi	r16,r16,4
8112f820:	8f001526 	beq	r17,fp,8112f878 <__sprint_r.part.0+0xd4>
8112f824:	81400017 	ldw	r5,0(r16)
8112f828:	980d883a 	mov	r6,r19
8112f82c:	a009883a 	mov	r4,r20
8112f830:	11311480 	call	81131148 <_fputwc_r>
8112f834:	e7000044 	addi	fp,fp,1
8112f838:	14bff81e 	bne	r2,r18,8112f81c <__reset+0xfb10f81c>
8112f83c:	9005883a 	mov	r2,r18
8112f840:	a8000215 	stw	zero,8(r21)
8112f844:	a8000115 	stw	zero,4(r21)
8112f848:	dfc00917 	ldw	ra,36(sp)
8112f84c:	df000817 	ldw	fp,32(sp)
8112f850:	ddc00717 	ldw	r23,28(sp)
8112f854:	dd800617 	ldw	r22,24(sp)
8112f858:	dd400517 	ldw	r21,20(sp)
8112f85c:	dd000417 	ldw	r20,16(sp)
8112f860:	dcc00317 	ldw	r19,12(sp)
8112f864:	dc800217 	ldw	r18,8(sp)
8112f868:	dc400117 	ldw	r17,4(sp)
8112f86c:	dc000017 	ldw	r16,0(sp)
8112f870:	dec00a04 	addi	sp,sp,40
8112f874:	f800283a 	ret
8112f878:	a8800217 	ldw	r2,8(r21)
8112f87c:	8c63883a 	add	r17,r17,r17
8112f880:	8c63883a 	add	r17,r17,r17
8112f884:	1445c83a 	sub	r2,r2,r17
8112f888:	a8800215 	stw	r2,8(r21)
8112f88c:	b5800204 	addi	r22,r22,8
8112f890:	bdc00204 	addi	r23,r23,8
8112f894:	103fdb1e 	bne	r2,zero,8112f804 <__reset+0xfb10f804>
8112f898:	0005883a 	mov	r2,zero
8112f89c:	003fe806 	br	8112f840 <__reset+0xfb10f840>
8112f8a0:	1129c240 	call	81129c24 <__sfvwrite_r>
8112f8a4:	003fe606 	br	8112f840 <__reset+0xfb10f840>

8112f8a8 <__sprint_r>:
8112f8a8:	30c00217 	ldw	r3,8(r6)
8112f8ac:	18000126 	beq	r3,zero,8112f8b4 <__sprint_r+0xc>
8112f8b0:	112f7a41 	jmpi	8112f7a4 <__sprint_r.part.0>
8112f8b4:	30000115 	stw	zero,4(r6)
8112f8b8:	0005883a 	mov	r2,zero
8112f8bc:	f800283a 	ret

8112f8c0 <___vfiprintf_internal_r>:
8112f8c0:	deffc904 	addi	sp,sp,-220
8112f8c4:	de00012e 	bgeu	sp,et,8112f8cc <___vfiprintf_internal_r+0xc>
8112f8c8:	003b68fa 	trap	3
8112f8cc:	df003515 	stw	fp,212(sp)
8112f8d0:	dd003115 	stw	r20,196(sp)
8112f8d4:	dfc03615 	stw	ra,216(sp)
8112f8d8:	ddc03415 	stw	r23,208(sp)
8112f8dc:	dd803315 	stw	r22,204(sp)
8112f8e0:	dd403215 	stw	r21,200(sp)
8112f8e4:	dcc03015 	stw	r19,192(sp)
8112f8e8:	dc802f15 	stw	r18,188(sp)
8112f8ec:	dc402e15 	stw	r17,184(sp)
8112f8f0:	dc002d15 	stw	r16,180(sp)
8112f8f4:	d9002015 	stw	r4,128(sp)
8112f8f8:	d9c02215 	stw	r7,136(sp)
8112f8fc:	2829883a 	mov	r20,r5
8112f900:	3039883a 	mov	fp,r6
8112f904:	20000226 	beq	r4,zero,8112f910 <___vfiprintf_internal_r+0x50>
8112f908:	20800e17 	ldw	r2,56(r4)
8112f90c:	1000cf26 	beq	r2,zero,8112fc4c <___vfiprintf_internal_r+0x38c>
8112f910:	a080030b 	ldhu	r2,12(r20)
8112f914:	10c8000c 	andi	r3,r2,8192
8112f918:	1800061e 	bne	r3,zero,8112f934 <___vfiprintf_internal_r+0x74>
8112f91c:	a1001917 	ldw	r4,100(r20)
8112f920:	00f7ffc4 	movi	r3,-8193
8112f924:	10880014 	ori	r2,r2,8192
8112f928:	20c6703a 	and	r3,r4,r3
8112f92c:	a080030d 	sth	r2,12(r20)
8112f930:	a0c01915 	stw	r3,100(r20)
8112f934:	10c0020c 	andi	r3,r2,8
8112f938:	1800a926 	beq	r3,zero,8112fbe0 <___vfiprintf_internal_r+0x320>
8112f93c:	a0c00417 	ldw	r3,16(r20)
8112f940:	1800a726 	beq	r3,zero,8112fbe0 <___vfiprintf_internal_r+0x320>
8112f944:	1080068c 	andi	r2,r2,26
8112f948:	00c00284 	movi	r3,10
8112f94c:	10c0ac26 	beq	r2,r3,8112fc00 <___vfiprintf_internal_r+0x340>
8112f950:	da801a04 	addi	r10,sp,104
8112f954:	da801e15 	stw	r10,120(sp)
8112f958:	d8801e17 	ldw	r2,120(sp)
8112f95c:	da8019c4 	addi	r10,sp,103
8112f960:	05a04574 	movhi	r22,33045
8112f964:	05e04574 	movhi	r23,33045
8112f968:	da801f15 	stw	r10,124(sp)
8112f96c:	1295c83a 	sub	r10,r2,r10
8112f970:	b5b98d04 	addi	r22,r22,-6604
8112f974:	bdf98904 	addi	r23,r23,-6620
8112f978:	dec01a15 	stw	sp,104(sp)
8112f97c:	d8001c15 	stw	zero,112(sp)
8112f980:	d8001b15 	stw	zero,108(sp)
8112f984:	d8002615 	stw	zero,152(sp)
8112f988:	d8002315 	stw	zero,140(sp)
8112f98c:	da802715 	stw	r10,156(sp)
8112f990:	d811883a 	mov	r8,sp
8112f994:	dd002115 	stw	r20,132(sp)
8112f998:	e021883a 	mov	r16,fp
8112f99c:	80800007 	ldb	r2,0(r16)
8112f9a0:	1003ea26 	beq	r2,zero,8113094c <___vfiprintf_internal_r+0x108c>
8112f9a4:	00c00944 	movi	r3,37
8112f9a8:	8025883a 	mov	r18,r16
8112f9ac:	10c0021e 	bne	r2,r3,8112f9b8 <___vfiprintf_internal_r+0xf8>
8112f9b0:	00001606 	br	8112fa0c <___vfiprintf_internal_r+0x14c>
8112f9b4:	10c00326 	beq	r2,r3,8112f9c4 <___vfiprintf_internal_r+0x104>
8112f9b8:	94800044 	addi	r18,r18,1
8112f9bc:	90800007 	ldb	r2,0(r18)
8112f9c0:	103ffc1e 	bne	r2,zero,8112f9b4 <__reset+0xfb10f9b4>
8112f9c4:	9423c83a 	sub	r17,r18,r16
8112f9c8:	88001026 	beq	r17,zero,8112fa0c <___vfiprintf_internal_r+0x14c>
8112f9cc:	d8c01c17 	ldw	r3,112(sp)
8112f9d0:	d8801b17 	ldw	r2,108(sp)
8112f9d4:	44000015 	stw	r16,0(r8)
8112f9d8:	88c7883a 	add	r3,r17,r3
8112f9dc:	10800044 	addi	r2,r2,1
8112f9e0:	44400115 	stw	r17,4(r8)
8112f9e4:	d8c01c15 	stw	r3,112(sp)
8112f9e8:	d8801b15 	stw	r2,108(sp)
8112f9ec:	010001c4 	movi	r4,7
8112f9f0:	2080760e 	bge	r4,r2,8112fbcc <___vfiprintf_internal_r+0x30c>
8112f9f4:	1803821e 	bne	r3,zero,81130800 <___vfiprintf_internal_r+0xf40>
8112f9f8:	da802317 	ldw	r10,140(sp)
8112f9fc:	d8001b15 	stw	zero,108(sp)
8112fa00:	d811883a 	mov	r8,sp
8112fa04:	5455883a 	add	r10,r10,r17
8112fa08:	da802315 	stw	r10,140(sp)
8112fa0c:	90800007 	ldb	r2,0(r18)
8112fa10:	10044626 	beq	r2,zero,81130b2c <___vfiprintf_internal_r+0x126c>
8112fa14:	90c00047 	ldb	r3,1(r18)
8112fa18:	94000044 	addi	r16,r18,1
8112fa1c:	d8001d85 	stb	zero,118(sp)
8112fa20:	0009883a 	mov	r4,zero
8112fa24:	000f883a 	mov	r7,zero
8112fa28:	027fffc4 	movi	r9,-1
8112fa2c:	0023883a 	mov	r17,zero
8112fa30:	0029883a 	mov	r20,zero
8112fa34:	01401604 	movi	r5,88
8112fa38:	01800244 	movi	r6,9
8112fa3c:	03400a84 	movi	r13,42
8112fa40:	03001b04 	movi	r12,108
8112fa44:	84000044 	addi	r16,r16,1
8112fa48:	18bff804 	addi	r2,r3,-32
8112fa4c:	28827336 	bltu	r5,r2,8113041c <___vfiprintf_internal_r+0xb5c>
8112fa50:	100490ba 	slli	r2,r2,2
8112fa54:	02a044f4 	movhi	r10,33043
8112fa58:	52be9a04 	addi	r10,r10,-1432
8112fa5c:	1285883a 	add	r2,r2,r10
8112fa60:	10800017 	ldw	r2,0(r2)
8112fa64:	1000683a 	jmp	r2
8112fa68:	81130150 	cmplti	r4,r16,19461
8112fa6c:	8113041c 	xori	r4,r16,19472
8112fa70:	8113041c 	xori	r4,r16,19472
8112fa74:	81130170 	cmpltui	r4,r16,19461
8112fa78:	8113041c 	xori	r4,r16,19472
8112fa7c:	8113041c 	xori	r4,r16,19472
8112fa80:	8113041c 	xori	r4,r16,19472
8112fa84:	8113041c 	xori	r4,r16,19472
8112fa88:	8113041c 	xori	r4,r16,19472
8112fa8c:	8113041c 	xori	r4,r16,19472
8112fa90:	81130358 	cmpnei	r4,r16,19469
8112fa94:	81130374 	orhi	r4,r16,19469
8112fa98:	8113041c 	xori	r4,r16,19472
8112fa9c:	8112fc5c 	xori	r4,r16,19441
8112faa0:	81130384 	addi	r4,r16,19470
8112faa4:	8113041c 	xori	r4,r16,19472
8112faa8:	8113017c 	xorhi	r4,r16,19461
8112faac:	81130188 	cmpgei	r4,r16,19462
8112fab0:	81130188 	cmpgei	r4,r16,19462
8112fab4:	81130188 	cmpgei	r4,r16,19462
8112fab8:	81130188 	cmpgei	r4,r16,19462
8112fabc:	81130188 	cmpgei	r4,r16,19462
8112fac0:	81130188 	cmpgei	r4,r16,19462
8112fac4:	81130188 	cmpgei	r4,r16,19462
8112fac8:	81130188 	cmpgei	r4,r16,19462
8112facc:	81130188 	cmpgei	r4,r16,19462
8112fad0:	8113041c 	xori	r4,r16,19472
8112fad4:	8113041c 	xori	r4,r16,19472
8112fad8:	8113041c 	xori	r4,r16,19472
8112fadc:	8113041c 	xori	r4,r16,19472
8112fae0:	8113041c 	xori	r4,r16,19472
8112fae4:	8113041c 	xori	r4,r16,19472
8112fae8:	8113041c 	xori	r4,r16,19472
8112faec:	8113041c 	xori	r4,r16,19472
8112faf0:	8113041c 	xori	r4,r16,19472
8112faf4:	8113041c 	xori	r4,r16,19472
8112faf8:	811301b4 	orhi	r4,r16,19462
8112fafc:	8113041c 	xori	r4,r16,19472
8112fb00:	8113041c 	xori	r4,r16,19472
8112fb04:	8113041c 	xori	r4,r16,19472
8112fb08:	8113041c 	xori	r4,r16,19472
8112fb0c:	8113041c 	xori	r4,r16,19472
8112fb10:	8113041c 	xori	r4,r16,19472
8112fb14:	8113041c 	xori	r4,r16,19472
8112fb18:	8113041c 	xori	r4,r16,19472
8112fb1c:	8113041c 	xori	r4,r16,19472
8112fb20:	8113041c 	xori	r4,r16,19472
8112fb24:	811301ec 	andhi	r4,r16,19463
8112fb28:	8113041c 	xori	r4,r16,19472
8112fb2c:	8113041c 	xori	r4,r16,19472
8112fb30:	8113041c 	xori	r4,r16,19472
8112fb34:	8113041c 	xori	r4,r16,19472
8112fb38:	8113041c 	xori	r4,r16,19472
8112fb3c:	81130244 	addi	r4,r16,19465
8112fb40:	8113041c 	xori	r4,r16,19472
8112fb44:	8113041c 	xori	r4,r16,19472
8112fb48:	811302b4 	orhi	r4,r16,19466
8112fb4c:	8113041c 	xori	r4,r16,19472
8112fb50:	8113041c 	xori	r4,r16,19472
8112fb54:	8113041c 	xori	r4,r16,19472
8112fb58:	8113041c 	xori	r4,r16,19472
8112fb5c:	8113041c 	xori	r4,r16,19472
8112fb60:	8113041c 	xori	r4,r16,19472
8112fb64:	8113041c 	xori	r4,r16,19472
8112fb68:	8113041c 	xori	r4,r16,19472
8112fb6c:	8113041c 	xori	r4,r16,19472
8112fb70:	8113041c 	xori	r4,r16,19472
8112fb74:	81130060 	cmpeqi	r4,r16,19457
8112fb78:	8113008c 	andi	r4,r16,19458
8112fb7c:	8113041c 	xori	r4,r16,19472
8112fb80:	8113041c 	xori	r4,r16,19472
8112fb84:	8113041c 	xori	r4,r16,19472
8112fb88:	811303c4 	addi	r4,r16,19471
8112fb8c:	8113008c 	andi	r4,r16,19458
8112fb90:	8113041c 	xori	r4,r16,19472
8112fb94:	8113041c 	xori	r4,r16,19472
8112fb98:	8112ff20 	cmpeqi	r4,r16,19452
8112fb9c:	8113041c 	xori	r4,r16,19472
8112fba0:	8112ff30 	cmpltui	r4,r16,19452
8112fba4:	8112ff6c 	andhi	r4,r16,19453
8112fba8:	8112fc68 	cmpgeui	r4,r16,19441
8112fbac:	8112ff14 	ori	r4,r16,19452
8112fbb0:	8113041c 	xori	r4,r16,19472
8112fbb4:	811302f0 	cmpltui	r4,r16,19467
8112fbb8:	8113041c 	xori	r4,r16,19472
8112fbbc:	81130348 	cmpgei	r4,r16,19469
8112fbc0:	8113041c 	xori	r4,r16,19472
8112fbc4:	8113041c 	xori	r4,r16,19472
8112fbc8:	8113000c 	andi	r4,r16,19456
8112fbcc:	42000204 	addi	r8,r8,8
8112fbd0:	da802317 	ldw	r10,140(sp)
8112fbd4:	5455883a 	add	r10,r10,r17
8112fbd8:	da802315 	stw	r10,140(sp)
8112fbdc:	003f8b06 	br	8112fa0c <__reset+0xfb10fa0c>
8112fbe0:	d9002017 	ldw	r4,128(sp)
8112fbe4:	a00b883a 	mov	r5,r20
8112fbe8:	11274040 	call	81127404 <__swsetup_r>
8112fbec:	1003b11e 	bne	r2,zero,81130ab4 <___vfiprintf_internal_r+0x11f4>
8112fbf0:	a080030b 	ldhu	r2,12(r20)
8112fbf4:	00c00284 	movi	r3,10
8112fbf8:	1080068c 	andi	r2,r2,26
8112fbfc:	10ff541e 	bne	r2,r3,8112f950 <__reset+0xfb10f950>
8112fc00:	a080038f 	ldh	r2,14(r20)
8112fc04:	103f5216 	blt	r2,zero,8112f950 <__reset+0xfb10f950>
8112fc08:	d9c02217 	ldw	r7,136(sp)
8112fc0c:	d9002017 	ldw	r4,128(sp)
8112fc10:	e00d883a 	mov	r6,fp
8112fc14:	a00b883a 	mov	r5,r20
8112fc18:	1130d400 	call	81130d40 <__sbprintf>
8112fc1c:	dfc03617 	ldw	ra,216(sp)
8112fc20:	df003517 	ldw	fp,212(sp)
8112fc24:	ddc03417 	ldw	r23,208(sp)
8112fc28:	dd803317 	ldw	r22,204(sp)
8112fc2c:	dd403217 	ldw	r21,200(sp)
8112fc30:	dd003117 	ldw	r20,196(sp)
8112fc34:	dcc03017 	ldw	r19,192(sp)
8112fc38:	dc802f17 	ldw	r18,188(sp)
8112fc3c:	dc402e17 	ldw	r17,184(sp)
8112fc40:	dc002d17 	ldw	r16,180(sp)
8112fc44:	dec03704 	addi	sp,sp,220
8112fc48:	f800283a 	ret
8112fc4c:	11294740 	call	81129474 <__sinit>
8112fc50:	003f2f06 	br	8112f910 <__reset+0xfb10f910>
8112fc54:	0463c83a 	sub	r17,zero,r17
8112fc58:	d8802215 	stw	r2,136(sp)
8112fc5c:	a5000114 	ori	r20,r20,4
8112fc60:	80c00007 	ldb	r3,0(r16)
8112fc64:	003f7706 	br	8112fa44 <__reset+0xfb10fa44>
8112fc68:	00800c04 	movi	r2,48
8112fc6c:	da802217 	ldw	r10,136(sp)
8112fc70:	d8801d05 	stb	r2,116(sp)
8112fc74:	00801e04 	movi	r2,120
8112fc78:	d8801d45 	stb	r2,117(sp)
8112fc7c:	d8001d85 	stb	zero,118(sp)
8112fc80:	50c00104 	addi	r3,r10,4
8112fc84:	54800017 	ldw	r18,0(r10)
8112fc88:	0027883a 	mov	r19,zero
8112fc8c:	a0800094 	ori	r2,r20,2
8112fc90:	48030b16 	blt	r9,zero,811308c0 <___vfiprintf_internal_r+0x1000>
8112fc94:	00bfdfc4 	movi	r2,-129
8112fc98:	a096703a 	and	r11,r20,r2
8112fc9c:	d8c02215 	stw	r3,136(sp)
8112fca0:	5d000094 	ori	r20,r11,2
8112fca4:	90032b1e 	bne	r18,zero,81130954 <___vfiprintf_internal_r+0x1094>
8112fca8:	00a04574 	movhi	r2,33045
8112fcac:	10b8f704 	addi	r2,r2,-7204
8112fcb0:	d8802615 	stw	r2,152(sp)
8112fcb4:	0039883a 	mov	fp,zero
8112fcb8:	48017b1e 	bne	r9,zero,811302a8 <___vfiprintf_internal_r+0x9e8>
8112fcbc:	0013883a 	mov	r9,zero
8112fcc0:	0027883a 	mov	r19,zero
8112fcc4:	dd401a04 	addi	r21,sp,104
8112fcc8:	4825883a 	mov	r18,r9
8112fccc:	4cc0010e 	bge	r9,r19,8112fcd4 <___vfiprintf_internal_r+0x414>
8112fcd0:	9825883a 	mov	r18,r19
8112fcd4:	e7003fcc 	andi	fp,fp,255
8112fcd8:	e700201c 	xori	fp,fp,128
8112fcdc:	e73fe004 	addi	fp,fp,-128
8112fce0:	e0000126 	beq	fp,zero,8112fce8 <___vfiprintf_internal_r+0x428>
8112fce4:	94800044 	addi	r18,r18,1
8112fce8:	a380008c 	andi	r14,r20,2
8112fcec:	70000126 	beq	r14,zero,8112fcf4 <___vfiprintf_internal_r+0x434>
8112fcf0:	94800084 	addi	r18,r18,2
8112fcf4:	a700210c 	andi	fp,r20,132
8112fcf8:	e001df1e 	bne	fp,zero,81130478 <___vfiprintf_internal_r+0xbb8>
8112fcfc:	8c87c83a 	sub	r3,r17,r18
8112fd00:	00c1dd0e 	bge	zero,r3,81130478 <___vfiprintf_internal_r+0xbb8>
8112fd04:	01c00404 	movi	r7,16
8112fd08:	d8801c17 	ldw	r2,112(sp)
8112fd0c:	38c3ad0e 	bge	r7,r3,81130bc4 <___vfiprintf_internal_r+0x1304>
8112fd10:	02a04574 	movhi	r10,33045
8112fd14:	52b98d04 	addi	r10,r10,-6604
8112fd18:	dc002915 	stw	r16,164(sp)
8112fd1c:	d9801b17 	ldw	r6,108(sp)
8112fd20:	da802415 	stw	r10,144(sp)
8112fd24:	03c001c4 	movi	r15,7
8112fd28:	da402515 	stw	r9,148(sp)
8112fd2c:	db802815 	stw	r14,160(sp)
8112fd30:	1821883a 	mov	r16,r3
8112fd34:	00000506 	br	8112fd4c <___vfiprintf_internal_r+0x48c>
8112fd38:	31400084 	addi	r5,r6,2
8112fd3c:	42000204 	addi	r8,r8,8
8112fd40:	200d883a 	mov	r6,r4
8112fd44:	843ffc04 	addi	r16,r16,-16
8112fd48:	3c000d0e 	bge	r7,r16,8112fd80 <___vfiprintf_internal_r+0x4c0>
8112fd4c:	10800404 	addi	r2,r2,16
8112fd50:	31000044 	addi	r4,r6,1
8112fd54:	45800015 	stw	r22,0(r8)
8112fd58:	41c00115 	stw	r7,4(r8)
8112fd5c:	d8801c15 	stw	r2,112(sp)
8112fd60:	d9001b15 	stw	r4,108(sp)
8112fd64:	793ff40e 	bge	r15,r4,8112fd38 <__reset+0xfb10fd38>
8112fd68:	1001b51e 	bne	r2,zero,81130440 <___vfiprintf_internal_r+0xb80>
8112fd6c:	843ffc04 	addi	r16,r16,-16
8112fd70:	000d883a 	mov	r6,zero
8112fd74:	01400044 	movi	r5,1
8112fd78:	d811883a 	mov	r8,sp
8112fd7c:	3c3ff316 	blt	r7,r16,8112fd4c <__reset+0xfb10fd4c>
8112fd80:	8007883a 	mov	r3,r16
8112fd84:	da402517 	ldw	r9,148(sp)
8112fd88:	db802817 	ldw	r14,160(sp)
8112fd8c:	dc002917 	ldw	r16,164(sp)
8112fd90:	da802417 	ldw	r10,144(sp)
8112fd94:	1885883a 	add	r2,r3,r2
8112fd98:	40c00115 	stw	r3,4(r8)
8112fd9c:	42800015 	stw	r10,0(r8)
8112fda0:	d8801c15 	stw	r2,112(sp)
8112fda4:	d9401b15 	stw	r5,108(sp)
8112fda8:	00c001c4 	movi	r3,7
8112fdac:	19426016 	blt	r3,r5,81130730 <___vfiprintf_internal_r+0xe70>
8112fdb0:	d8c01d87 	ldb	r3,118(sp)
8112fdb4:	42000204 	addi	r8,r8,8
8112fdb8:	29000044 	addi	r4,r5,1
8112fdbc:	1801b31e 	bne	r3,zero,8113048c <___vfiprintf_internal_r+0xbcc>
8112fdc0:	7001c026 	beq	r14,zero,811304c4 <___vfiprintf_internal_r+0xc04>
8112fdc4:	d8c01d04 	addi	r3,sp,116
8112fdc8:	10800084 	addi	r2,r2,2
8112fdcc:	40c00015 	stw	r3,0(r8)
8112fdd0:	00c00084 	movi	r3,2
8112fdd4:	40c00115 	stw	r3,4(r8)
8112fdd8:	d8801c15 	stw	r2,112(sp)
8112fddc:	d9001b15 	stw	r4,108(sp)
8112fde0:	00c001c4 	movi	r3,7
8112fde4:	1902650e 	bge	r3,r4,8113077c <___vfiprintf_internal_r+0xebc>
8112fde8:	10029a1e 	bne	r2,zero,81130854 <___vfiprintf_internal_r+0xf94>
8112fdec:	00c02004 	movi	r3,128
8112fdf0:	01000044 	movi	r4,1
8112fdf4:	000b883a 	mov	r5,zero
8112fdf8:	d811883a 	mov	r8,sp
8112fdfc:	e0c1b31e 	bne	fp,r3,811304cc <___vfiprintf_internal_r+0xc0c>
8112fe00:	8cb9c83a 	sub	fp,r17,r18
8112fe04:	0701b10e 	bge	zero,fp,811304cc <___vfiprintf_internal_r+0xc0c>
8112fe08:	01c00404 	movi	r7,16
8112fe0c:	3f03890e 	bge	r7,fp,81130c34 <___vfiprintf_internal_r+0x1374>
8112fe10:	00e04574 	movhi	r3,33045
8112fe14:	18f98904 	addi	r3,r3,-6620
8112fe18:	d8c02415 	stw	r3,144(sp)
8112fe1c:	8007883a 	mov	r3,r16
8112fe20:	034001c4 	movi	r13,7
8112fe24:	e021883a 	mov	r16,fp
8112fe28:	da402515 	stw	r9,148(sp)
8112fe2c:	1839883a 	mov	fp,r3
8112fe30:	00000506 	br	8112fe48 <___vfiprintf_internal_r+0x588>
8112fe34:	29800084 	addi	r6,r5,2
8112fe38:	42000204 	addi	r8,r8,8
8112fe3c:	180b883a 	mov	r5,r3
8112fe40:	843ffc04 	addi	r16,r16,-16
8112fe44:	3c000d0e 	bge	r7,r16,8112fe7c <___vfiprintf_internal_r+0x5bc>
8112fe48:	10800404 	addi	r2,r2,16
8112fe4c:	28c00044 	addi	r3,r5,1
8112fe50:	45c00015 	stw	r23,0(r8)
8112fe54:	41c00115 	stw	r7,4(r8)
8112fe58:	d8801c15 	stw	r2,112(sp)
8112fe5c:	d8c01b15 	stw	r3,108(sp)
8112fe60:	68fff40e 	bge	r13,r3,8112fe34 <__reset+0xfb10fe34>
8112fe64:	1002241e 	bne	r2,zero,811306f8 <___vfiprintf_internal_r+0xe38>
8112fe68:	843ffc04 	addi	r16,r16,-16
8112fe6c:	01800044 	movi	r6,1
8112fe70:	000b883a 	mov	r5,zero
8112fe74:	d811883a 	mov	r8,sp
8112fe78:	3c3ff316 	blt	r7,r16,8112fe48 <__reset+0xfb10fe48>
8112fe7c:	da402517 	ldw	r9,148(sp)
8112fe80:	e007883a 	mov	r3,fp
8112fe84:	8039883a 	mov	fp,r16
8112fe88:	1821883a 	mov	r16,r3
8112fe8c:	d8c02417 	ldw	r3,144(sp)
8112fe90:	1705883a 	add	r2,r2,fp
8112fe94:	47000115 	stw	fp,4(r8)
8112fe98:	40c00015 	stw	r3,0(r8)
8112fe9c:	d8801c15 	stw	r2,112(sp)
8112fea0:	d9801b15 	stw	r6,108(sp)
8112fea4:	00c001c4 	movi	r3,7
8112fea8:	19827616 	blt	r3,r6,81130884 <___vfiprintf_internal_r+0xfc4>
8112feac:	4cf9c83a 	sub	fp,r9,r19
8112feb0:	42000204 	addi	r8,r8,8
8112feb4:	31000044 	addi	r4,r6,1
8112feb8:	300b883a 	mov	r5,r6
8112febc:	07018516 	blt	zero,fp,811304d4 <___vfiprintf_internal_r+0xc14>
8112fec0:	9885883a 	add	r2,r19,r2
8112fec4:	45400015 	stw	r21,0(r8)
8112fec8:	44c00115 	stw	r19,4(r8)
8112fecc:	d8801c15 	stw	r2,112(sp)
8112fed0:	d9001b15 	stw	r4,108(sp)
8112fed4:	00c001c4 	movi	r3,7
8112fed8:	1901dd0e 	bge	r3,r4,81130650 <___vfiprintf_internal_r+0xd90>
8112fedc:	1002401e 	bne	r2,zero,811307e0 <___vfiprintf_internal_r+0xf20>
8112fee0:	d8001b15 	stw	zero,108(sp)
8112fee4:	a2c0010c 	andi	r11,r20,4
8112fee8:	58000226 	beq	r11,zero,8112fef4 <___vfiprintf_internal_r+0x634>
8112feec:	8ca7c83a 	sub	r19,r17,r18
8112fef0:	04c2f216 	blt	zero,r19,81130abc <___vfiprintf_internal_r+0x11fc>
8112fef4:	8c80010e 	bge	r17,r18,8112fefc <___vfiprintf_internal_r+0x63c>
8112fef8:	9023883a 	mov	r17,r18
8112fefc:	da802317 	ldw	r10,140(sp)
8112ff00:	5455883a 	add	r10,r10,r17
8112ff04:	da802315 	stw	r10,140(sp)
8112ff08:	d8001b15 	stw	zero,108(sp)
8112ff0c:	d811883a 	mov	r8,sp
8112ff10:	003ea206 	br	8112f99c <__reset+0xfb10f99c>
8112ff14:	a5000814 	ori	r20,r20,32
8112ff18:	80c00007 	ldb	r3,0(r16)
8112ff1c:	003ec906 	br	8112fa44 <__reset+0xfb10fa44>
8112ff20:	80c00007 	ldb	r3,0(r16)
8112ff24:	1b030926 	beq	r3,r12,81130b4c <___vfiprintf_internal_r+0x128c>
8112ff28:	a5000414 	ori	r20,r20,16
8112ff2c:	003ec506 	br	8112fa44 <__reset+0xfb10fa44>
8112ff30:	21003fcc 	andi	r4,r4,255
8112ff34:	20035e1e 	bne	r4,zero,81130cb0 <___vfiprintf_internal_r+0x13f0>
8112ff38:	a080080c 	andi	r2,r20,32
8112ff3c:	1002a526 	beq	r2,zero,811309d4 <___vfiprintf_internal_r+0x1114>
8112ff40:	da802217 	ldw	r10,136(sp)
8112ff44:	50800017 	ldw	r2,0(r10)
8112ff48:	da802317 	ldw	r10,140(sp)
8112ff4c:	5007d7fa 	srai	r3,r10,31
8112ff50:	da802217 	ldw	r10,136(sp)
8112ff54:	10c00115 	stw	r3,4(r2)
8112ff58:	52800104 	addi	r10,r10,4
8112ff5c:	da802215 	stw	r10,136(sp)
8112ff60:	da802317 	ldw	r10,140(sp)
8112ff64:	12800015 	stw	r10,0(r2)
8112ff68:	003e8c06 	br	8112f99c <__reset+0xfb10f99c>
8112ff6c:	21003fcc 	andi	r4,r4,255
8112ff70:	2003511e 	bne	r4,zero,81130cb8 <___vfiprintf_internal_r+0x13f8>
8112ff74:	a080080c 	andi	r2,r20,32
8112ff78:	1000a126 	beq	r2,zero,81130200 <___vfiprintf_internal_r+0x940>
8112ff7c:	da802217 	ldw	r10,136(sp)
8112ff80:	d8001d85 	stb	zero,118(sp)
8112ff84:	50800204 	addi	r2,r10,8
8112ff88:	54800017 	ldw	r18,0(r10)
8112ff8c:	54c00117 	ldw	r19,4(r10)
8112ff90:	4802b416 	blt	r9,zero,81130a64 <___vfiprintf_internal_r+0x11a4>
8112ff94:	013fdfc4 	movi	r4,-129
8112ff98:	94c6b03a 	or	r3,r18,r19
8112ff9c:	d8802215 	stw	r2,136(sp)
8112ffa0:	a128703a 	and	r20,r20,r4
8112ffa4:	1800a226 	beq	r3,zero,81130230 <___vfiprintf_internal_r+0x970>
8112ffa8:	0039883a 	mov	fp,zero
8112ffac:	dd401a04 	addi	r21,sp,104
8112ffb0:	9006d0fa 	srli	r3,r18,3
8112ffb4:	9808977a 	slli	r4,r19,29
8112ffb8:	9826d0fa 	srli	r19,r19,3
8112ffbc:	948001cc 	andi	r18,r18,7
8112ffc0:	90800c04 	addi	r2,r18,48
8112ffc4:	ad7fffc4 	addi	r21,r21,-1
8112ffc8:	20e4b03a 	or	r18,r4,r3
8112ffcc:	a8800005 	stb	r2,0(r21)
8112ffd0:	94c6b03a 	or	r3,r18,r19
8112ffd4:	183ff61e 	bne	r3,zero,8112ffb0 <__reset+0xfb10ffb0>
8112ffd8:	a0c0004c 	andi	r3,r20,1
8112ffdc:	18005926 	beq	r3,zero,81130144 <___vfiprintf_internal_r+0x884>
8112ffe0:	10803fcc 	andi	r2,r2,255
8112ffe4:	1080201c 	xori	r2,r2,128
8112ffe8:	10bfe004 	addi	r2,r2,-128
8112ffec:	00c00c04 	movi	r3,48
8112fff0:	10c05426 	beq	r2,r3,81130144 <___vfiprintf_internal_r+0x884>
8112fff4:	da801e17 	ldw	r10,120(sp)
8112fff8:	a8bfffc4 	addi	r2,r21,-1
8112fffc:	a8ffffc5 	stb	r3,-1(r21)
81130000:	50a7c83a 	sub	r19,r10,r2
81130004:	102b883a 	mov	r21,r2
81130008:	003f2f06 	br	8112fcc8 <__reset+0xfb10fcc8>
8113000c:	21003fcc 	andi	r4,r4,255
81130010:	2003421e 	bne	r4,zero,81130d1c <___vfiprintf_internal_r+0x145c>
81130014:	00a04574 	movhi	r2,33045
81130018:	10b8f704 	addi	r2,r2,-7204
8113001c:	d8802615 	stw	r2,152(sp)
81130020:	a080080c 	andi	r2,r20,32
81130024:	1000aa26 	beq	r2,zero,811302d0 <___vfiprintf_internal_r+0xa10>
81130028:	da802217 	ldw	r10,136(sp)
8113002c:	54800017 	ldw	r18,0(r10)
81130030:	54c00117 	ldw	r19,4(r10)
81130034:	52800204 	addi	r10,r10,8
81130038:	da802215 	stw	r10,136(sp)
8113003c:	a080004c 	andi	r2,r20,1
81130040:	1001d226 	beq	r2,zero,8113078c <___vfiprintf_internal_r+0xecc>
81130044:	94c4b03a 	or	r2,r18,r19
81130048:	1002351e 	bne	r2,zero,81130920 <___vfiprintf_internal_r+0x1060>
8113004c:	d8001d85 	stb	zero,118(sp)
81130050:	48022216 	blt	r9,zero,811308dc <___vfiprintf_internal_r+0x101c>
81130054:	00bfdfc4 	movi	r2,-129
81130058:	a0a8703a 	and	r20,r20,r2
8113005c:	003f1506 	br	8112fcb4 <__reset+0xfb10fcb4>
81130060:	da802217 	ldw	r10,136(sp)
81130064:	04800044 	movi	r18,1
81130068:	d8001d85 	stb	zero,118(sp)
8113006c:	50800017 	ldw	r2,0(r10)
81130070:	52800104 	addi	r10,r10,4
81130074:	da802215 	stw	r10,136(sp)
81130078:	d8801005 	stb	r2,64(sp)
8113007c:	9027883a 	mov	r19,r18
81130080:	dd401004 	addi	r21,sp,64
81130084:	0013883a 	mov	r9,zero
81130088:	003f1706 	br	8112fce8 <__reset+0xfb10fce8>
8113008c:	21003fcc 	andi	r4,r4,255
81130090:	2003201e 	bne	r4,zero,81130d14 <___vfiprintf_internal_r+0x1454>
81130094:	a080080c 	andi	r2,r20,32
81130098:	10004b26 	beq	r2,zero,811301c8 <___vfiprintf_internal_r+0x908>
8113009c:	da802217 	ldw	r10,136(sp)
811300a0:	50800117 	ldw	r2,4(r10)
811300a4:	54800017 	ldw	r18,0(r10)
811300a8:	52800204 	addi	r10,r10,8
811300ac:	da802215 	stw	r10,136(sp)
811300b0:	1027883a 	mov	r19,r2
811300b4:	10022c16 	blt	r2,zero,81130968 <___vfiprintf_internal_r+0x10a8>
811300b8:	df001d83 	ldbu	fp,118(sp)
811300bc:	48007216 	blt	r9,zero,81130288 <___vfiprintf_internal_r+0x9c8>
811300c0:	00ffdfc4 	movi	r3,-129
811300c4:	94c4b03a 	or	r2,r18,r19
811300c8:	a0e8703a 	and	r20,r20,r3
811300cc:	1000cc26 	beq	r2,zero,81130400 <___vfiprintf_internal_r+0xb40>
811300d0:	98021026 	beq	r19,zero,81130914 <___vfiprintf_internal_r+0x1054>
811300d4:	dc402415 	stw	r17,144(sp)
811300d8:	dc002515 	stw	r16,148(sp)
811300dc:	9823883a 	mov	r17,r19
811300e0:	9021883a 	mov	r16,r18
811300e4:	dd401a04 	addi	r21,sp,104
811300e8:	4825883a 	mov	r18,r9
811300ec:	4027883a 	mov	r19,r8
811300f0:	8009883a 	mov	r4,r16
811300f4:	880b883a 	mov	r5,r17
811300f8:	01800284 	movi	r6,10
811300fc:	000f883a 	mov	r7,zero
81130100:	11325e00 	call	811325e0 <__umoddi3>
81130104:	10800c04 	addi	r2,r2,48
81130108:	ad7fffc4 	addi	r21,r21,-1
8113010c:	8009883a 	mov	r4,r16
81130110:	880b883a 	mov	r5,r17
81130114:	a8800005 	stb	r2,0(r21)
81130118:	01800284 	movi	r6,10
8113011c:	000f883a 	mov	r7,zero
81130120:	11320600 	call	81132060 <__udivdi3>
81130124:	1021883a 	mov	r16,r2
81130128:	10c4b03a 	or	r2,r2,r3
8113012c:	1823883a 	mov	r17,r3
81130130:	103fef1e 	bne	r2,zero,811300f0 <__reset+0xfb1100f0>
81130134:	dc402417 	ldw	r17,144(sp)
81130138:	dc002517 	ldw	r16,148(sp)
8113013c:	9013883a 	mov	r9,r18
81130140:	9811883a 	mov	r8,r19
81130144:	da801e17 	ldw	r10,120(sp)
81130148:	5567c83a 	sub	r19,r10,r21
8113014c:	003ede06 	br	8112fcc8 <__reset+0xfb10fcc8>
81130150:	38803fcc 	andi	r2,r7,255
81130154:	1080201c 	xori	r2,r2,128
81130158:	10bfe004 	addi	r2,r2,-128
8113015c:	1002371e 	bne	r2,zero,81130a3c <___vfiprintf_internal_r+0x117c>
81130160:	01000044 	movi	r4,1
81130164:	01c00804 	movi	r7,32
81130168:	80c00007 	ldb	r3,0(r16)
8113016c:	003e3506 	br	8112fa44 <__reset+0xfb10fa44>
81130170:	a5000054 	ori	r20,r20,1
81130174:	80c00007 	ldb	r3,0(r16)
81130178:	003e3206 	br	8112fa44 <__reset+0xfb10fa44>
8113017c:	a5002014 	ori	r20,r20,128
81130180:	80c00007 	ldb	r3,0(r16)
81130184:	003e2f06 	br	8112fa44 <__reset+0xfb10fa44>
81130188:	8015883a 	mov	r10,r16
8113018c:	0023883a 	mov	r17,zero
81130190:	18bff404 	addi	r2,r3,-48
81130194:	50c00007 	ldb	r3,0(r10)
81130198:	8c4002a4 	muli	r17,r17,10
8113019c:	84000044 	addi	r16,r16,1
811301a0:	8015883a 	mov	r10,r16
811301a4:	1463883a 	add	r17,r2,r17
811301a8:	18bff404 	addi	r2,r3,-48
811301ac:	30bff92e 	bgeu	r6,r2,81130194 <__reset+0xfb110194>
811301b0:	003e2506 	br	8112fa48 <__reset+0xfb10fa48>
811301b4:	21003fcc 	andi	r4,r4,255
811301b8:	2002d41e 	bne	r4,zero,81130d0c <___vfiprintf_internal_r+0x144c>
811301bc:	a5000414 	ori	r20,r20,16
811301c0:	a080080c 	andi	r2,r20,32
811301c4:	103fb51e 	bne	r2,zero,8113009c <__reset+0xfb11009c>
811301c8:	a080040c 	andi	r2,r20,16
811301cc:	1001f826 	beq	r2,zero,811309b0 <___vfiprintf_internal_r+0x10f0>
811301d0:	da802217 	ldw	r10,136(sp)
811301d4:	54800017 	ldw	r18,0(r10)
811301d8:	52800104 	addi	r10,r10,4
811301dc:	da802215 	stw	r10,136(sp)
811301e0:	9027d7fa 	srai	r19,r18,31
811301e4:	9805883a 	mov	r2,r19
811301e8:	003fb206 	br	811300b4 <__reset+0xfb1100b4>
811301ec:	21003fcc 	andi	r4,r4,255
811301f0:	2002c41e 	bne	r4,zero,81130d04 <___vfiprintf_internal_r+0x1444>
811301f4:	a5000414 	ori	r20,r20,16
811301f8:	a080080c 	andi	r2,r20,32
811301fc:	103f5f1e 	bne	r2,zero,8112ff7c <__reset+0xfb10ff7c>
81130200:	a080040c 	andi	r2,r20,16
81130204:	10020f26 	beq	r2,zero,81130a44 <___vfiprintf_internal_r+0x1184>
81130208:	da802217 	ldw	r10,136(sp)
8113020c:	d8001d85 	stb	zero,118(sp)
81130210:	0027883a 	mov	r19,zero
81130214:	50800104 	addi	r2,r10,4
81130218:	54800017 	ldw	r18,0(r10)
8113021c:	48021116 	blt	r9,zero,81130a64 <___vfiprintf_internal_r+0x11a4>
81130220:	00ffdfc4 	movi	r3,-129
81130224:	d8802215 	stw	r2,136(sp)
81130228:	a0e8703a 	and	r20,r20,r3
8113022c:	903f5e1e 	bne	r18,zero,8112ffa8 <__reset+0xfb10ffa8>
81130230:	0039883a 	mov	fp,zero
81130234:	4802a626 	beq	r9,zero,81130cd0 <___vfiprintf_internal_r+0x1410>
81130238:	0025883a 	mov	r18,zero
8113023c:	0027883a 	mov	r19,zero
81130240:	003f5a06 	br	8112ffac <__reset+0xfb10ffac>
81130244:	21003fcc 	andi	r4,r4,255
81130248:	20029f1e 	bne	r4,zero,81130cc8 <___vfiprintf_internal_r+0x1408>
8113024c:	a5000414 	ori	r20,r20,16
81130250:	a080080c 	andi	r2,r20,32
81130254:	10005e1e 	bne	r2,zero,811303d0 <___vfiprintf_internal_r+0xb10>
81130258:	a080040c 	andi	r2,r20,16
8113025c:	1001a21e 	bne	r2,zero,811308e8 <___vfiprintf_internal_r+0x1028>
81130260:	a080100c 	andi	r2,r20,64
81130264:	d8001d85 	stb	zero,118(sp)
81130268:	da802217 	ldw	r10,136(sp)
8113026c:	1002231e 	bne	r2,zero,81130afc <___vfiprintf_internal_r+0x123c>
81130270:	50800104 	addi	r2,r10,4
81130274:	54800017 	ldw	r18,0(r10)
81130278:	0027883a 	mov	r19,zero
8113027c:	4801a00e 	bge	r9,zero,81130900 <___vfiprintf_internal_r+0x1040>
81130280:	d8802215 	stw	r2,136(sp)
81130284:	0039883a 	mov	fp,zero
81130288:	94c4b03a 	or	r2,r18,r19
8113028c:	103f901e 	bne	r2,zero,811300d0 <__reset+0xfb1100d0>
81130290:	00800044 	movi	r2,1
81130294:	10803fcc 	andi	r2,r2,255
81130298:	00c00044 	movi	r3,1
8113029c:	10c05926 	beq	r2,r3,81130404 <___vfiprintf_internal_r+0xb44>
811302a0:	00c00084 	movi	r3,2
811302a4:	10ffe41e 	bne	r2,r3,81130238 <__reset+0xfb110238>
811302a8:	0025883a 	mov	r18,zero
811302ac:	0027883a 	mov	r19,zero
811302b0:	00013d06 	br	811307a8 <___vfiprintf_internal_r+0xee8>
811302b4:	21003fcc 	andi	r4,r4,255
811302b8:	2002811e 	bne	r4,zero,81130cc0 <___vfiprintf_internal_r+0x1400>
811302bc:	00a04574 	movhi	r2,33045
811302c0:	10b8f204 	addi	r2,r2,-7224
811302c4:	d8802615 	stw	r2,152(sp)
811302c8:	a080080c 	andi	r2,r20,32
811302cc:	103f561e 	bne	r2,zero,81130028 <__reset+0xfb110028>
811302d0:	a080040c 	andi	r2,r20,16
811302d4:	1001d126 	beq	r2,zero,81130a1c <___vfiprintf_internal_r+0x115c>
811302d8:	da802217 	ldw	r10,136(sp)
811302dc:	0027883a 	mov	r19,zero
811302e0:	54800017 	ldw	r18,0(r10)
811302e4:	52800104 	addi	r10,r10,4
811302e8:	da802215 	stw	r10,136(sp)
811302ec:	003f5306 	br	8113003c <__reset+0xfb11003c>
811302f0:	da802217 	ldw	r10,136(sp)
811302f4:	d8001d85 	stb	zero,118(sp)
811302f8:	55400017 	ldw	r21,0(r10)
811302fc:	50c00104 	addi	r3,r10,4
81130300:	a8024226 	beq	r21,zero,81130c0c <___vfiprintf_internal_r+0x134c>
81130304:	48021816 	blt	r9,zero,81130b68 <___vfiprintf_internal_r+0x12a8>
81130308:	480d883a 	mov	r6,r9
8113030c:	000b883a 	mov	r5,zero
81130310:	a809883a 	mov	r4,r21
81130314:	d8c02a15 	stw	r3,168(sp)
81130318:	da002b15 	stw	r8,172(sp)
8113031c:	da402c15 	stw	r9,176(sp)
81130320:	112a69c0 	call	8112a69c <memchr>
81130324:	d8c02a17 	ldw	r3,168(sp)
81130328:	da002b17 	ldw	r8,172(sp)
8113032c:	da402c17 	ldw	r9,176(sp)
81130330:	10024826 	beq	r2,zero,81130c54 <___vfiprintf_internal_r+0x1394>
81130334:	1567c83a 	sub	r19,r2,r21
81130338:	df001d83 	ldbu	fp,118(sp)
8113033c:	d8c02215 	stw	r3,136(sp)
81130340:	0013883a 	mov	r9,zero
81130344:	003e6006 	br	8112fcc8 <__reset+0xfb10fcc8>
81130348:	21003fcc 	andi	r4,r4,255
8113034c:	203fc026 	beq	r4,zero,81130250 <__reset+0xfb110250>
81130350:	d9c01d85 	stb	r7,118(sp)
81130354:	003fbe06 	br	81130250 <__reset+0xfb110250>
81130358:	da802217 	ldw	r10,136(sp)
8113035c:	54400017 	ldw	r17,0(r10)
81130360:	50800104 	addi	r2,r10,4
81130364:	883e3b16 	blt	r17,zero,8112fc54 <__reset+0xfb10fc54>
81130368:	d8802215 	stw	r2,136(sp)
8113036c:	80c00007 	ldb	r3,0(r16)
81130370:	003db406 	br	8112fa44 <__reset+0xfb10fa44>
81130374:	01000044 	movi	r4,1
81130378:	01c00ac4 	movi	r7,43
8113037c:	80c00007 	ldb	r3,0(r16)
81130380:	003db006 	br	8112fa44 <__reset+0xfb10fa44>
81130384:	80c00007 	ldb	r3,0(r16)
81130388:	82800044 	addi	r10,r16,1
8113038c:	1b423c26 	beq	r3,r13,81130c80 <___vfiprintf_internal_r+0x13c0>
81130390:	18bff404 	addi	r2,r3,-48
81130394:	0013883a 	mov	r9,zero
81130398:	30822b36 	bltu	r6,r2,81130c48 <___vfiprintf_internal_r+0x1388>
8113039c:	50c00007 	ldb	r3,0(r10)
811303a0:	4a4002a4 	muli	r9,r9,10
811303a4:	54000044 	addi	r16,r10,1
811303a8:	8015883a 	mov	r10,r16
811303ac:	4893883a 	add	r9,r9,r2
811303b0:	18bff404 	addi	r2,r3,-48
811303b4:	30bff92e 	bgeu	r6,r2,8113039c <__reset+0xfb11039c>
811303b8:	483da30e 	bge	r9,zero,8112fa48 <__reset+0xfb10fa48>
811303bc:	027fffc4 	movi	r9,-1
811303c0:	003da106 	br	8112fa48 <__reset+0xfb10fa48>
811303c4:	a5001014 	ori	r20,r20,64
811303c8:	80c00007 	ldb	r3,0(r16)
811303cc:	003d9d06 	br	8112fa44 <__reset+0xfb10fa44>
811303d0:	da802217 	ldw	r10,136(sp)
811303d4:	d8001d85 	stb	zero,118(sp)
811303d8:	50c00204 	addi	r3,r10,8
811303dc:	54800017 	ldw	r18,0(r10)
811303e0:	54c00117 	ldw	r19,4(r10)
811303e4:	4801ca16 	blt	r9,zero,81130b10 <___vfiprintf_internal_r+0x1250>
811303e8:	013fdfc4 	movi	r4,-129
811303ec:	94c4b03a 	or	r2,r18,r19
811303f0:	d8c02215 	stw	r3,136(sp)
811303f4:	a128703a 	and	r20,r20,r4
811303f8:	0039883a 	mov	fp,zero
811303fc:	103f341e 	bne	r2,zero,811300d0 <__reset+0xfb1100d0>
81130400:	483e2e26 	beq	r9,zero,8112fcbc <__reset+0xfb10fcbc>
81130404:	0025883a 	mov	r18,zero
81130408:	94800c04 	addi	r18,r18,48
8113040c:	dc8019c5 	stb	r18,103(sp)
81130410:	dcc02717 	ldw	r19,156(sp)
81130414:	dd4019c4 	addi	r21,sp,103
81130418:	003e2b06 	br	8112fcc8 <__reset+0xfb10fcc8>
8113041c:	21003fcc 	andi	r4,r4,255
81130420:	2002361e 	bne	r4,zero,81130cfc <___vfiprintf_internal_r+0x143c>
81130424:	1801c126 	beq	r3,zero,81130b2c <___vfiprintf_internal_r+0x126c>
81130428:	04800044 	movi	r18,1
8113042c:	d8c01005 	stb	r3,64(sp)
81130430:	d8001d85 	stb	zero,118(sp)
81130434:	9027883a 	mov	r19,r18
81130438:	dd401004 	addi	r21,sp,64
8113043c:	003f1106 	br	81130084 <__reset+0xfb110084>
81130440:	d9402117 	ldw	r5,132(sp)
81130444:	d9002017 	ldw	r4,128(sp)
81130448:	d9801a04 	addi	r6,sp,104
8113044c:	d9c02b15 	stw	r7,172(sp)
81130450:	dbc02a15 	stw	r15,168(sp)
81130454:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130458:	d9c02b17 	ldw	r7,172(sp)
8113045c:	dbc02a17 	ldw	r15,168(sp)
81130460:	10006d1e 	bne	r2,zero,81130618 <___vfiprintf_internal_r+0xd58>
81130464:	d9801b17 	ldw	r6,108(sp)
81130468:	d8801c17 	ldw	r2,112(sp)
8113046c:	d811883a 	mov	r8,sp
81130470:	31400044 	addi	r5,r6,1
81130474:	003e3306 	br	8112fd44 <__reset+0xfb10fd44>
81130478:	d9401b17 	ldw	r5,108(sp)
8113047c:	d8801c17 	ldw	r2,112(sp)
81130480:	29000044 	addi	r4,r5,1
81130484:	d8c01d87 	ldb	r3,118(sp)
81130488:	183e4d26 	beq	r3,zero,8112fdc0 <__reset+0xfb10fdc0>
8113048c:	00c00044 	movi	r3,1
81130490:	d9401d84 	addi	r5,sp,118
81130494:	10c5883a 	add	r2,r2,r3
81130498:	41400015 	stw	r5,0(r8)
8113049c:	40c00115 	stw	r3,4(r8)
811304a0:	d8801c15 	stw	r2,112(sp)
811304a4:	d9001b15 	stw	r4,108(sp)
811304a8:	014001c4 	movi	r5,7
811304ac:	2900a90e 	bge	r5,r4,81130754 <___vfiprintf_internal_r+0xe94>
811304b0:	1000da1e 	bne	r2,zero,8113081c <___vfiprintf_internal_r+0xf5c>
811304b4:	7000ab1e 	bne	r14,zero,81130764 <___vfiprintf_internal_r+0xea4>
811304b8:	000b883a 	mov	r5,zero
811304bc:	1809883a 	mov	r4,r3
811304c0:	d811883a 	mov	r8,sp
811304c4:	00c02004 	movi	r3,128
811304c8:	e0fe4d26 	beq	fp,r3,8112fe00 <__reset+0xfb10fe00>
811304cc:	4cf9c83a 	sub	fp,r9,r19
811304d0:	073e7b0e 	bge	zero,fp,8112fec0 <__reset+0xfb10fec0>
811304d4:	01c00404 	movi	r7,16
811304d8:	3f01900e 	bge	r7,fp,81130b1c <___vfiprintf_internal_r+0x125c>
811304dc:	00e04574 	movhi	r3,33045
811304e0:	18f98904 	addi	r3,r3,-6620
811304e4:	d8c02415 	stw	r3,144(sp)
811304e8:	034001c4 	movi	r13,7
811304ec:	00000506 	br	81130504 <___vfiprintf_internal_r+0xc44>
811304f0:	29000084 	addi	r4,r5,2
811304f4:	42000204 	addi	r8,r8,8
811304f8:	180b883a 	mov	r5,r3
811304fc:	e73ffc04 	addi	fp,fp,-16
81130500:	3f000d0e 	bge	r7,fp,81130538 <___vfiprintf_internal_r+0xc78>
81130504:	10800404 	addi	r2,r2,16
81130508:	28c00044 	addi	r3,r5,1
8113050c:	45c00015 	stw	r23,0(r8)
81130510:	41c00115 	stw	r7,4(r8)
81130514:	d8801c15 	stw	r2,112(sp)
81130518:	d8c01b15 	stw	r3,108(sp)
8113051c:	68fff40e 	bge	r13,r3,811304f0 <__reset+0xfb1104f0>
81130520:	1000101e 	bne	r2,zero,81130564 <___vfiprintf_internal_r+0xca4>
81130524:	e73ffc04 	addi	fp,fp,-16
81130528:	01000044 	movi	r4,1
8113052c:	000b883a 	mov	r5,zero
81130530:	d811883a 	mov	r8,sp
81130534:	3f3ff316 	blt	r7,fp,81130504 <__reset+0xfb110504>
81130538:	da802417 	ldw	r10,144(sp)
8113053c:	1705883a 	add	r2,r2,fp
81130540:	47000115 	stw	fp,4(r8)
81130544:	42800015 	stw	r10,0(r8)
81130548:	d8801c15 	stw	r2,112(sp)
8113054c:	d9001b15 	stw	r4,108(sp)
81130550:	00c001c4 	movi	r3,7
81130554:	19003616 	blt	r3,r4,81130630 <___vfiprintf_internal_r+0xd70>
81130558:	42000204 	addi	r8,r8,8
8113055c:	21000044 	addi	r4,r4,1
81130560:	003e5706 	br	8112fec0 <__reset+0xfb10fec0>
81130564:	d9402117 	ldw	r5,132(sp)
81130568:	d9002017 	ldw	r4,128(sp)
8113056c:	d9801a04 	addi	r6,sp,104
81130570:	d9c02b15 	stw	r7,172(sp)
81130574:	db402a15 	stw	r13,168(sp)
81130578:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
8113057c:	d9c02b17 	ldw	r7,172(sp)
81130580:	db402a17 	ldw	r13,168(sp)
81130584:	1000241e 	bne	r2,zero,81130618 <___vfiprintf_internal_r+0xd58>
81130588:	d9401b17 	ldw	r5,108(sp)
8113058c:	d8801c17 	ldw	r2,112(sp)
81130590:	d811883a 	mov	r8,sp
81130594:	29000044 	addi	r4,r5,1
81130598:	003fd806 	br	811304fc <__reset+0xfb1104fc>
8113059c:	d9401b17 	ldw	r5,108(sp)
811305a0:	00e04574 	movhi	r3,33045
811305a4:	18f98d04 	addi	r3,r3,-6604
811305a8:	d8c02415 	stw	r3,144(sp)
811305ac:	29400044 	addi	r5,r5,1
811305b0:	d8c02417 	ldw	r3,144(sp)
811305b4:	14c5883a 	add	r2,r2,r19
811305b8:	44c00115 	stw	r19,4(r8)
811305bc:	40c00015 	stw	r3,0(r8)
811305c0:	d8801c15 	stw	r2,112(sp)
811305c4:	d9401b15 	stw	r5,108(sp)
811305c8:	00c001c4 	movi	r3,7
811305cc:	1940070e 	bge	r3,r5,811305ec <___vfiprintf_internal_r+0xd2c>
811305d0:	103e4826 	beq	r2,zero,8112fef4 <__reset+0xfb10fef4>
811305d4:	d9402117 	ldw	r5,132(sp)
811305d8:	d9002017 	ldw	r4,128(sp)
811305dc:	d9801a04 	addi	r6,sp,104
811305e0:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
811305e4:	10000c1e 	bne	r2,zero,81130618 <___vfiprintf_internal_r+0xd58>
811305e8:	d8801c17 	ldw	r2,112(sp)
811305ec:	8c80010e 	bge	r17,r18,811305f4 <___vfiprintf_internal_r+0xd34>
811305f0:	9023883a 	mov	r17,r18
811305f4:	da802317 	ldw	r10,140(sp)
811305f8:	5455883a 	add	r10,r10,r17
811305fc:	da802315 	stw	r10,140(sp)
81130600:	103e4126 	beq	r2,zero,8112ff08 <__reset+0xfb10ff08>
81130604:	d9402117 	ldw	r5,132(sp)
81130608:	d9002017 	ldw	r4,128(sp)
8113060c:	d9801a04 	addi	r6,sp,104
81130610:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130614:	103e3c26 	beq	r2,zero,8112ff08 <__reset+0xfb10ff08>
81130618:	dd002117 	ldw	r20,132(sp)
8113061c:	a080030b 	ldhu	r2,12(r20)
81130620:	1080100c 	andi	r2,r2,64
81130624:	1001231e 	bne	r2,zero,81130ab4 <___vfiprintf_internal_r+0x11f4>
81130628:	d8802317 	ldw	r2,140(sp)
8113062c:	003d7b06 	br	8112fc1c <__reset+0xfb10fc1c>
81130630:	1000991e 	bne	r2,zero,81130898 <___vfiprintf_internal_r+0xfd8>
81130634:	00c00044 	movi	r3,1
81130638:	9805883a 	mov	r2,r19
8113063c:	dd400015 	stw	r21,0(sp)
81130640:	dcc00115 	stw	r19,4(sp)
81130644:	dcc01c15 	stw	r19,112(sp)
81130648:	d8c01b15 	stw	r3,108(sp)
8113064c:	d811883a 	mov	r8,sp
81130650:	42000204 	addi	r8,r8,8
81130654:	a2c0010c 	andi	r11,r20,4
81130658:	583fe426 	beq	r11,zero,811305ec <__reset+0xfb1105ec>
8113065c:	8ca7c83a 	sub	r19,r17,r18
81130660:	04ffe20e 	bge	zero,r19,811305ec <__reset+0xfb1105ec>
81130664:	01c00404 	movi	r7,16
81130668:	3cffcc0e 	bge	r7,r19,8113059c <__reset+0xfb11059c>
8113066c:	02a04574 	movhi	r10,33045
81130670:	52b98d04 	addi	r10,r10,-6604
81130674:	d9001b17 	ldw	r4,108(sp)
81130678:	da802415 	stw	r10,144(sp)
8113067c:	382b883a 	mov	r21,r7
81130680:	050001c4 	movi	r20,7
81130684:	df002017 	ldw	fp,128(sp)
81130688:	00000506 	br	811306a0 <___vfiprintf_internal_r+0xde0>
8113068c:	21400084 	addi	r5,r4,2
81130690:	42000204 	addi	r8,r8,8
81130694:	1809883a 	mov	r4,r3
81130698:	9cfffc04 	addi	r19,r19,-16
8113069c:	acffc40e 	bge	r21,r19,811305b0 <__reset+0xfb1105b0>
811306a0:	10800404 	addi	r2,r2,16
811306a4:	20c00044 	addi	r3,r4,1
811306a8:	45800015 	stw	r22,0(r8)
811306ac:	45400115 	stw	r21,4(r8)
811306b0:	d8801c15 	stw	r2,112(sp)
811306b4:	d8c01b15 	stw	r3,108(sp)
811306b8:	a0fff40e 	bge	r20,r3,8113068c <__reset+0xfb11068c>
811306bc:	1000041e 	bne	r2,zero,811306d0 <___vfiprintf_internal_r+0xe10>
811306c0:	01400044 	movi	r5,1
811306c4:	0009883a 	mov	r4,zero
811306c8:	d811883a 	mov	r8,sp
811306cc:	003ff206 	br	81130698 <__reset+0xfb110698>
811306d0:	d9402117 	ldw	r5,132(sp)
811306d4:	d9801a04 	addi	r6,sp,104
811306d8:	e009883a 	mov	r4,fp
811306dc:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
811306e0:	103fcd1e 	bne	r2,zero,81130618 <__reset+0xfb110618>
811306e4:	d9001b17 	ldw	r4,108(sp)
811306e8:	d8801c17 	ldw	r2,112(sp)
811306ec:	d811883a 	mov	r8,sp
811306f0:	21400044 	addi	r5,r4,1
811306f4:	003fe806 	br	81130698 <__reset+0xfb110698>
811306f8:	d9402117 	ldw	r5,132(sp)
811306fc:	d9002017 	ldw	r4,128(sp)
81130700:	d9801a04 	addi	r6,sp,104
81130704:	d9c02b15 	stw	r7,172(sp)
81130708:	db402a15 	stw	r13,168(sp)
8113070c:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130710:	d9c02b17 	ldw	r7,172(sp)
81130714:	db402a17 	ldw	r13,168(sp)
81130718:	103fbf1e 	bne	r2,zero,81130618 <__reset+0xfb110618>
8113071c:	d9401b17 	ldw	r5,108(sp)
81130720:	d8801c17 	ldw	r2,112(sp)
81130724:	d811883a 	mov	r8,sp
81130728:	29800044 	addi	r6,r5,1
8113072c:	003dc406 	br	8112fe40 <__reset+0xfb10fe40>
81130730:	1000d21e 	bne	r2,zero,81130a7c <___vfiprintf_internal_r+0x11bc>
81130734:	d8c01d87 	ldb	r3,118(sp)
81130738:	18009526 	beq	r3,zero,81130990 <___vfiprintf_internal_r+0x10d0>
8113073c:	00800044 	movi	r2,1
81130740:	d8c01d84 	addi	r3,sp,118
81130744:	1009883a 	mov	r4,r2
81130748:	d8c00015 	stw	r3,0(sp)
8113074c:	d8800115 	stw	r2,4(sp)
81130750:	d811883a 	mov	r8,sp
81130754:	200b883a 	mov	r5,r4
81130758:	42000204 	addi	r8,r8,8
8113075c:	21000044 	addi	r4,r4,1
81130760:	003d9706 	br	8112fdc0 <__reset+0xfb10fdc0>
81130764:	d9001d04 	addi	r4,sp,116
81130768:	00800084 	movi	r2,2
8113076c:	d9000015 	stw	r4,0(sp)
81130770:	d8800115 	stw	r2,4(sp)
81130774:	1809883a 	mov	r4,r3
81130778:	d811883a 	mov	r8,sp
8113077c:	200b883a 	mov	r5,r4
81130780:	42000204 	addi	r8,r8,8
81130784:	21000044 	addi	r4,r4,1
81130788:	003f4e06 	br	811304c4 <__reset+0xfb1104c4>
8113078c:	d8001d85 	stb	zero,118(sp)
81130790:	48005016 	blt	r9,zero,811308d4 <___vfiprintf_internal_r+0x1014>
81130794:	00ffdfc4 	movi	r3,-129
81130798:	94c4b03a 	or	r2,r18,r19
8113079c:	a0e8703a 	and	r20,r20,r3
811307a0:	103d4426 	beq	r2,zero,8112fcb4 <__reset+0xfb10fcb4>
811307a4:	0039883a 	mov	fp,zero
811307a8:	d9002617 	ldw	r4,152(sp)
811307ac:	dd401a04 	addi	r21,sp,104
811307b0:	908003cc 	andi	r2,r18,15
811307b4:	9806973a 	slli	r3,r19,28
811307b8:	2085883a 	add	r2,r4,r2
811307bc:	9024d13a 	srli	r18,r18,4
811307c0:	10800003 	ldbu	r2,0(r2)
811307c4:	9826d13a 	srli	r19,r19,4
811307c8:	ad7fffc4 	addi	r21,r21,-1
811307cc:	1ca4b03a 	or	r18,r3,r18
811307d0:	a8800005 	stb	r2,0(r21)
811307d4:	94c4b03a 	or	r2,r18,r19
811307d8:	103ff51e 	bne	r2,zero,811307b0 <__reset+0xfb1107b0>
811307dc:	003e5906 	br	81130144 <__reset+0xfb110144>
811307e0:	d9402117 	ldw	r5,132(sp)
811307e4:	d9002017 	ldw	r4,128(sp)
811307e8:	d9801a04 	addi	r6,sp,104
811307ec:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
811307f0:	103f891e 	bne	r2,zero,81130618 <__reset+0xfb110618>
811307f4:	d8801c17 	ldw	r2,112(sp)
811307f8:	d811883a 	mov	r8,sp
811307fc:	003f9506 	br	81130654 <__reset+0xfb110654>
81130800:	d9402117 	ldw	r5,132(sp)
81130804:	d9002017 	ldw	r4,128(sp)
81130808:	d9801a04 	addi	r6,sp,104
8113080c:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130810:	103f811e 	bne	r2,zero,81130618 <__reset+0xfb110618>
81130814:	d811883a 	mov	r8,sp
81130818:	003ced06 	br	8112fbd0 <__reset+0xfb10fbd0>
8113081c:	d9402117 	ldw	r5,132(sp)
81130820:	d9002017 	ldw	r4,128(sp)
81130824:	d9801a04 	addi	r6,sp,104
81130828:	da402c15 	stw	r9,176(sp)
8113082c:	db802a15 	stw	r14,168(sp)
81130830:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130834:	da402c17 	ldw	r9,176(sp)
81130838:	db802a17 	ldw	r14,168(sp)
8113083c:	103f761e 	bne	r2,zero,81130618 <__reset+0xfb110618>
81130840:	d9401b17 	ldw	r5,108(sp)
81130844:	d8801c17 	ldw	r2,112(sp)
81130848:	d811883a 	mov	r8,sp
8113084c:	29000044 	addi	r4,r5,1
81130850:	003d5b06 	br	8112fdc0 <__reset+0xfb10fdc0>
81130854:	d9402117 	ldw	r5,132(sp)
81130858:	d9002017 	ldw	r4,128(sp)
8113085c:	d9801a04 	addi	r6,sp,104
81130860:	da402c15 	stw	r9,176(sp)
81130864:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130868:	da402c17 	ldw	r9,176(sp)
8113086c:	103f6a1e 	bne	r2,zero,81130618 <__reset+0xfb110618>
81130870:	d9401b17 	ldw	r5,108(sp)
81130874:	d8801c17 	ldw	r2,112(sp)
81130878:	d811883a 	mov	r8,sp
8113087c:	29000044 	addi	r4,r5,1
81130880:	003f1006 	br	811304c4 <__reset+0xfb1104c4>
81130884:	1000c31e 	bne	r2,zero,81130b94 <___vfiprintf_internal_r+0x12d4>
81130888:	01000044 	movi	r4,1
8113088c:	000b883a 	mov	r5,zero
81130890:	d811883a 	mov	r8,sp
81130894:	003f0d06 	br	811304cc <__reset+0xfb1104cc>
81130898:	d9402117 	ldw	r5,132(sp)
8113089c:	d9002017 	ldw	r4,128(sp)
811308a0:	d9801a04 	addi	r6,sp,104
811308a4:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
811308a8:	103f5b1e 	bne	r2,zero,81130618 <__reset+0xfb110618>
811308ac:	d9001b17 	ldw	r4,108(sp)
811308b0:	d8801c17 	ldw	r2,112(sp)
811308b4:	d811883a 	mov	r8,sp
811308b8:	21000044 	addi	r4,r4,1
811308bc:	003d8006 	br	8112fec0 <__reset+0xfb10fec0>
811308c0:	01204574 	movhi	r4,33045
811308c4:	2138f704 	addi	r4,r4,-7204
811308c8:	d9002615 	stw	r4,152(sp)
811308cc:	d8c02215 	stw	r3,136(sp)
811308d0:	1029883a 	mov	r20,r2
811308d4:	94c4b03a 	or	r2,r18,r19
811308d8:	103fb21e 	bne	r2,zero,811307a4 <__reset+0xfb1107a4>
811308dc:	0039883a 	mov	fp,zero
811308e0:	00800084 	movi	r2,2
811308e4:	003e6b06 	br	81130294 <__reset+0xfb110294>
811308e8:	da802217 	ldw	r10,136(sp)
811308ec:	d8001d85 	stb	zero,118(sp)
811308f0:	0027883a 	mov	r19,zero
811308f4:	50800104 	addi	r2,r10,4
811308f8:	54800017 	ldw	r18,0(r10)
811308fc:	483e6016 	blt	r9,zero,81130280 <__reset+0xfb110280>
81130900:	00ffdfc4 	movi	r3,-129
81130904:	d8802215 	stw	r2,136(sp)
81130908:	a0e8703a 	and	r20,r20,r3
8113090c:	0039883a 	mov	fp,zero
81130910:	903ebb26 	beq	r18,zero,81130400 <__reset+0xfb110400>
81130914:	00800244 	movi	r2,9
81130918:	14bdee36 	bltu	r2,r18,811300d4 <__reset+0xfb1100d4>
8113091c:	003eba06 	br	81130408 <__reset+0xfb110408>
81130920:	00800c04 	movi	r2,48
81130924:	d8c01d45 	stb	r3,117(sp)
81130928:	d8801d05 	stb	r2,116(sp)
8113092c:	d8001d85 	stb	zero,118(sp)
81130930:	a0c00094 	ori	r3,r20,2
81130934:	4800a916 	blt	r9,zero,81130bdc <___vfiprintf_internal_r+0x131c>
81130938:	00bfdfc4 	movi	r2,-129
8113093c:	a096703a 	and	r11,r20,r2
81130940:	5d000094 	ori	r20,r11,2
81130944:	0039883a 	mov	fp,zero
81130948:	003f9706 	br	811307a8 <__reset+0xfb1107a8>
8113094c:	8025883a 	mov	r18,r16
81130950:	003c2e06 	br	8112fa0c <__reset+0xfb10fa0c>
81130954:	00a04574 	movhi	r2,33045
81130958:	10b8f704 	addi	r2,r2,-7204
8113095c:	0039883a 	mov	fp,zero
81130960:	d8802615 	stw	r2,152(sp)
81130964:	003f9006 	br	811307a8 <__reset+0xfb1107a8>
81130968:	04a5c83a 	sub	r18,zero,r18
8113096c:	07000b44 	movi	fp,45
81130970:	9004c03a 	cmpne	r2,r18,zero
81130974:	04e7c83a 	sub	r19,zero,r19
81130978:	df001d85 	stb	fp,118(sp)
8113097c:	98a7c83a 	sub	r19,r19,r2
81130980:	48009f16 	blt	r9,zero,81130c00 <___vfiprintf_internal_r+0x1340>
81130984:	00bfdfc4 	movi	r2,-129
81130988:	a0a8703a 	and	r20,r20,r2
8113098c:	003dd006 	br	811300d0 <__reset+0xfb1100d0>
81130990:	70004c26 	beq	r14,zero,81130ac4 <___vfiprintf_internal_r+0x1204>
81130994:	00800084 	movi	r2,2
81130998:	d8c01d04 	addi	r3,sp,116
8113099c:	d8c00015 	stw	r3,0(sp)
811309a0:	d8800115 	stw	r2,4(sp)
811309a4:	01000044 	movi	r4,1
811309a8:	d811883a 	mov	r8,sp
811309ac:	003f7306 	br	8113077c <__reset+0xfb11077c>
811309b0:	a080100c 	andi	r2,r20,64
811309b4:	da802217 	ldw	r10,136(sp)
811309b8:	103e0626 	beq	r2,zero,811301d4 <__reset+0xfb1101d4>
811309bc:	5480000f 	ldh	r18,0(r10)
811309c0:	52800104 	addi	r10,r10,4
811309c4:	da802215 	stw	r10,136(sp)
811309c8:	9027d7fa 	srai	r19,r18,31
811309cc:	9805883a 	mov	r2,r19
811309d0:	003db806 	br	811300b4 <__reset+0xfb1100b4>
811309d4:	a080040c 	andi	r2,r20,16
811309d8:	1000091e 	bne	r2,zero,81130a00 <___vfiprintf_internal_r+0x1140>
811309dc:	a2c0100c 	andi	r11,r20,64
811309e0:	58000726 	beq	r11,zero,81130a00 <___vfiprintf_internal_r+0x1140>
811309e4:	da802217 	ldw	r10,136(sp)
811309e8:	50800017 	ldw	r2,0(r10)
811309ec:	52800104 	addi	r10,r10,4
811309f0:	da802215 	stw	r10,136(sp)
811309f4:	da802317 	ldw	r10,140(sp)
811309f8:	1280000d 	sth	r10,0(r2)
811309fc:	003be706 	br	8112f99c <__reset+0xfb10f99c>
81130a00:	da802217 	ldw	r10,136(sp)
81130a04:	50800017 	ldw	r2,0(r10)
81130a08:	52800104 	addi	r10,r10,4
81130a0c:	da802215 	stw	r10,136(sp)
81130a10:	da802317 	ldw	r10,140(sp)
81130a14:	12800015 	stw	r10,0(r2)
81130a18:	003be006 	br	8112f99c <__reset+0xfb10f99c>
81130a1c:	a080100c 	andi	r2,r20,64
81130a20:	da802217 	ldw	r10,136(sp)
81130a24:	10003026 	beq	r2,zero,81130ae8 <___vfiprintf_internal_r+0x1228>
81130a28:	5480000b 	ldhu	r18,0(r10)
81130a2c:	52800104 	addi	r10,r10,4
81130a30:	0027883a 	mov	r19,zero
81130a34:	da802215 	stw	r10,136(sp)
81130a38:	003d8006 	br	8113003c <__reset+0xfb11003c>
81130a3c:	80c00007 	ldb	r3,0(r16)
81130a40:	003c0006 	br	8112fa44 <__reset+0xfb10fa44>
81130a44:	a080100c 	andi	r2,r20,64
81130a48:	d8001d85 	stb	zero,118(sp)
81130a4c:	da802217 	ldw	r10,136(sp)
81130a50:	1000201e 	bne	r2,zero,81130ad4 <___vfiprintf_internal_r+0x1214>
81130a54:	50800104 	addi	r2,r10,4
81130a58:	54800017 	ldw	r18,0(r10)
81130a5c:	0027883a 	mov	r19,zero
81130a60:	483def0e 	bge	r9,zero,81130220 <__reset+0xfb110220>
81130a64:	94c6b03a 	or	r3,r18,r19
81130a68:	d8802215 	stw	r2,136(sp)
81130a6c:	183d4e1e 	bne	r3,zero,8112ffa8 <__reset+0xfb10ffa8>
81130a70:	0039883a 	mov	fp,zero
81130a74:	0005883a 	mov	r2,zero
81130a78:	003e0606 	br	81130294 <__reset+0xfb110294>
81130a7c:	d9402117 	ldw	r5,132(sp)
81130a80:	d9002017 	ldw	r4,128(sp)
81130a84:	d9801a04 	addi	r6,sp,104
81130a88:	da402c15 	stw	r9,176(sp)
81130a8c:	db802a15 	stw	r14,168(sp)
81130a90:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130a94:	da402c17 	ldw	r9,176(sp)
81130a98:	db802a17 	ldw	r14,168(sp)
81130a9c:	103ede1e 	bne	r2,zero,81130618 <__reset+0xfb110618>
81130aa0:	d9401b17 	ldw	r5,108(sp)
81130aa4:	d8801c17 	ldw	r2,112(sp)
81130aa8:	d811883a 	mov	r8,sp
81130aac:	29000044 	addi	r4,r5,1
81130ab0:	003e7406 	br	81130484 <__reset+0xfb110484>
81130ab4:	00bfffc4 	movi	r2,-1
81130ab8:	003c5806 	br	8112fc1c <__reset+0xfb10fc1c>
81130abc:	d811883a 	mov	r8,sp
81130ac0:	003ee806 	br	81130664 <__reset+0xfb110664>
81130ac4:	000b883a 	mov	r5,zero
81130ac8:	01000044 	movi	r4,1
81130acc:	d811883a 	mov	r8,sp
81130ad0:	003e7c06 	br	811304c4 <__reset+0xfb1104c4>
81130ad4:	50800104 	addi	r2,r10,4
81130ad8:	5480000b 	ldhu	r18,0(r10)
81130adc:	0027883a 	mov	r19,zero
81130ae0:	483dcf0e 	bge	r9,zero,81130220 <__reset+0xfb110220>
81130ae4:	003fdf06 	br	81130a64 <__reset+0xfb110a64>
81130ae8:	54800017 	ldw	r18,0(r10)
81130aec:	52800104 	addi	r10,r10,4
81130af0:	0027883a 	mov	r19,zero
81130af4:	da802215 	stw	r10,136(sp)
81130af8:	003d5006 	br	8113003c <__reset+0xfb11003c>
81130afc:	50800104 	addi	r2,r10,4
81130b00:	5480000b 	ldhu	r18,0(r10)
81130b04:	0027883a 	mov	r19,zero
81130b08:	483f7d0e 	bge	r9,zero,81130900 <__reset+0xfb110900>
81130b0c:	003ddc06 	br	81130280 <__reset+0xfb110280>
81130b10:	d8c02215 	stw	r3,136(sp)
81130b14:	0039883a 	mov	fp,zero
81130b18:	003ddb06 	br	81130288 <__reset+0xfb110288>
81130b1c:	02a04574 	movhi	r10,33045
81130b20:	52b98904 	addi	r10,r10,-6620
81130b24:	da802415 	stw	r10,144(sp)
81130b28:	003e8306 	br	81130538 <__reset+0xfb110538>
81130b2c:	d8801c17 	ldw	r2,112(sp)
81130b30:	dd002117 	ldw	r20,132(sp)
81130b34:	103eb926 	beq	r2,zero,8113061c <__reset+0xfb11061c>
81130b38:	d9002017 	ldw	r4,128(sp)
81130b3c:	d9801a04 	addi	r6,sp,104
81130b40:	a00b883a 	mov	r5,r20
81130b44:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130b48:	003eb406 	br	8113061c <__reset+0xfb11061c>
81130b4c:	80c00043 	ldbu	r3,1(r16)
81130b50:	a5000814 	ori	r20,r20,32
81130b54:	84000044 	addi	r16,r16,1
81130b58:	18c03fcc 	andi	r3,r3,255
81130b5c:	18c0201c 	xori	r3,r3,128
81130b60:	18ffe004 	addi	r3,r3,-128
81130b64:	003bb706 	br	8112fa44 <__reset+0xfb10fa44>
81130b68:	a809883a 	mov	r4,r21
81130b6c:	d8c02a15 	stw	r3,168(sp)
81130b70:	da002b15 	stw	r8,172(sp)
81130b74:	11211a00 	call	811211a0 <strlen>
81130b78:	d8c02a17 	ldw	r3,168(sp)
81130b7c:	1027883a 	mov	r19,r2
81130b80:	df001d83 	ldbu	fp,118(sp)
81130b84:	d8c02215 	stw	r3,136(sp)
81130b88:	0013883a 	mov	r9,zero
81130b8c:	da002b17 	ldw	r8,172(sp)
81130b90:	003c4d06 	br	8112fcc8 <__reset+0xfb10fcc8>
81130b94:	d9402117 	ldw	r5,132(sp)
81130b98:	d9002017 	ldw	r4,128(sp)
81130b9c:	d9801a04 	addi	r6,sp,104
81130ba0:	da402c15 	stw	r9,176(sp)
81130ba4:	112f7a40 	call	8112f7a4 <__sprint_r.part.0>
81130ba8:	da402c17 	ldw	r9,176(sp)
81130bac:	103e9a1e 	bne	r2,zero,81130618 <__reset+0xfb110618>
81130bb0:	d9401b17 	ldw	r5,108(sp)
81130bb4:	d8801c17 	ldw	r2,112(sp)
81130bb8:	d811883a 	mov	r8,sp
81130bbc:	29000044 	addi	r4,r5,1
81130bc0:	003e4206 	br	811304cc <__reset+0xfb1104cc>
81130bc4:	d9401b17 	ldw	r5,108(sp)
81130bc8:	01204574 	movhi	r4,33045
81130bcc:	21398d04 	addi	r4,r4,-6604
81130bd0:	d9002415 	stw	r4,144(sp)
81130bd4:	29400044 	addi	r5,r5,1
81130bd8:	003c6d06 	br	8112fd90 <__reset+0xfb10fd90>
81130bdc:	0039883a 	mov	fp,zero
81130be0:	00800084 	movi	r2,2
81130be4:	10803fcc 	andi	r2,r2,255
81130be8:	01000044 	movi	r4,1
81130bec:	11001e26 	beq	r2,r4,81130c68 <___vfiprintf_internal_r+0x13a8>
81130bf0:	01000084 	movi	r4,2
81130bf4:	11001e1e 	bne	r2,r4,81130c70 <___vfiprintf_internal_r+0x13b0>
81130bf8:	1829883a 	mov	r20,r3
81130bfc:	003eea06 	br	811307a8 <__reset+0xfb1107a8>
81130c00:	a007883a 	mov	r3,r20
81130c04:	00800044 	movi	r2,1
81130c08:	003ff606 	br	81130be4 <__reset+0xfb110be4>
81130c0c:	00800184 	movi	r2,6
81130c10:	1240012e 	bgeu	r2,r9,81130c18 <___vfiprintf_internal_r+0x1358>
81130c14:	1013883a 	mov	r9,r2
81130c18:	4827883a 	mov	r19,r9
81130c1c:	4825883a 	mov	r18,r9
81130c20:	48001516 	blt	r9,zero,81130c78 <___vfiprintf_internal_r+0x13b8>
81130c24:	05604574 	movhi	r21,33045
81130c28:	d8c02215 	stw	r3,136(sp)
81130c2c:	ad78fc04 	addi	r21,r21,-7184
81130c30:	003d1406 	br	81130084 <__reset+0xfb110084>
81130c34:	02a04574 	movhi	r10,33045
81130c38:	52b98904 	addi	r10,r10,-6620
81130c3c:	da802415 	stw	r10,144(sp)
81130c40:	200d883a 	mov	r6,r4
81130c44:	003c9106 	br	8112fe8c <__reset+0xfb10fe8c>
81130c48:	5021883a 	mov	r16,r10
81130c4c:	0013883a 	mov	r9,zero
81130c50:	003b7d06 	br	8112fa48 <__reset+0xfb10fa48>
81130c54:	4827883a 	mov	r19,r9
81130c58:	df001d83 	ldbu	fp,118(sp)
81130c5c:	d8c02215 	stw	r3,136(sp)
81130c60:	0013883a 	mov	r9,zero
81130c64:	003c1806 	br	8112fcc8 <__reset+0xfb10fcc8>
81130c68:	1829883a 	mov	r20,r3
81130c6c:	003d1806 	br	811300d0 <__reset+0xfb1100d0>
81130c70:	1829883a 	mov	r20,r3
81130c74:	003ccd06 	br	8112ffac <__reset+0xfb10ffac>
81130c78:	0025883a 	mov	r18,zero
81130c7c:	003fe906 	br	81130c24 <__reset+0xfb110c24>
81130c80:	d8802217 	ldw	r2,136(sp)
81130c84:	80c00043 	ldbu	r3,1(r16)
81130c88:	5021883a 	mov	r16,r10
81130c8c:	12400017 	ldw	r9,0(r2)
81130c90:	10800104 	addi	r2,r2,4
81130c94:	d8802215 	stw	r2,136(sp)
81130c98:	483faf0e 	bge	r9,zero,81130b58 <__reset+0xfb110b58>
81130c9c:	18c03fcc 	andi	r3,r3,255
81130ca0:	18c0201c 	xori	r3,r3,128
81130ca4:	027fffc4 	movi	r9,-1
81130ca8:	18ffe004 	addi	r3,r3,-128
81130cac:	003b6506 	br	8112fa44 <__reset+0xfb10fa44>
81130cb0:	d9c01d85 	stb	r7,118(sp)
81130cb4:	003ca006 	br	8112ff38 <__reset+0xfb10ff38>
81130cb8:	d9c01d85 	stb	r7,118(sp)
81130cbc:	003cad06 	br	8112ff74 <__reset+0xfb10ff74>
81130cc0:	d9c01d85 	stb	r7,118(sp)
81130cc4:	003d7d06 	br	811302bc <__reset+0xfb1102bc>
81130cc8:	d9c01d85 	stb	r7,118(sp)
81130ccc:	003d5f06 	br	8113024c <__reset+0xfb11024c>
81130cd0:	a080004c 	andi	r2,r20,1
81130cd4:	0039883a 	mov	fp,zero
81130cd8:	10000526 	beq	r2,zero,81130cf0 <___vfiprintf_internal_r+0x1430>
81130cdc:	00800c04 	movi	r2,48
81130ce0:	d88019c5 	stb	r2,103(sp)
81130ce4:	dcc02717 	ldw	r19,156(sp)
81130ce8:	dd4019c4 	addi	r21,sp,103
81130cec:	003bf606 	br	8112fcc8 <__reset+0xfb10fcc8>
81130cf0:	0027883a 	mov	r19,zero
81130cf4:	dd401a04 	addi	r21,sp,104
81130cf8:	003bf306 	br	8112fcc8 <__reset+0xfb10fcc8>
81130cfc:	d9c01d85 	stb	r7,118(sp)
81130d00:	003dc806 	br	81130424 <__reset+0xfb110424>
81130d04:	d9c01d85 	stb	r7,118(sp)
81130d08:	003d3a06 	br	811301f4 <__reset+0xfb1101f4>
81130d0c:	d9c01d85 	stb	r7,118(sp)
81130d10:	003d2a06 	br	811301bc <__reset+0xfb1101bc>
81130d14:	d9c01d85 	stb	r7,118(sp)
81130d18:	003cde06 	br	81130094 <__reset+0xfb110094>
81130d1c:	d9c01d85 	stb	r7,118(sp)
81130d20:	003cbc06 	br	81130014 <__reset+0xfb110014>

81130d24 <__vfiprintf_internal>:
81130d24:	00a04574 	movhi	r2,33045
81130d28:	1082c604 	addi	r2,r2,2840
81130d2c:	300f883a 	mov	r7,r6
81130d30:	280d883a 	mov	r6,r5
81130d34:	200b883a 	mov	r5,r4
81130d38:	11000017 	ldw	r4,0(r2)
81130d3c:	112f8c01 	jmpi	8112f8c0 <___vfiprintf_internal_r>

81130d40 <__sbprintf>:
81130d40:	defee204 	addi	sp,sp,-1144
81130d44:	de00012e 	bgeu	sp,et,81130d4c <__sbprintf+0xc>
81130d48:	003b68fa 	trap	3
81130d4c:	2880030b 	ldhu	r2,12(r5)
81130d50:	2ac01917 	ldw	r11,100(r5)
81130d54:	2a80038b 	ldhu	r10,14(r5)
81130d58:	2a400717 	ldw	r9,28(r5)
81130d5c:	2a000917 	ldw	r8,36(r5)
81130d60:	00c10004 	movi	r3,1024
81130d64:	dc011a15 	stw	r16,1128(sp)
81130d68:	10bfff4c 	andi	r2,r2,65533
81130d6c:	2821883a 	mov	r16,r5
81130d70:	d8cb883a 	add	r5,sp,r3
81130d74:	dc811c15 	stw	r18,1136(sp)
81130d78:	dc411b15 	stw	r17,1132(sp)
81130d7c:	dfc11d15 	stw	ra,1140(sp)
81130d80:	2025883a 	mov	r18,r4
81130d84:	d881030d 	sth	r2,1036(sp)
81130d88:	dac11915 	stw	r11,1124(sp)
81130d8c:	da81038d 	sth	r10,1038(sp)
81130d90:	da410715 	stw	r9,1052(sp)
81130d94:	da010915 	stw	r8,1060(sp)
81130d98:	dec10015 	stw	sp,1024(sp)
81130d9c:	dec10415 	stw	sp,1040(sp)
81130da0:	d8c10215 	stw	r3,1032(sp)
81130da4:	d8c10515 	stw	r3,1044(sp)
81130da8:	d8010615 	stw	zero,1048(sp)
81130dac:	112f8c00 	call	8112f8c0 <___vfiprintf_internal_r>
81130db0:	1023883a 	mov	r17,r2
81130db4:	10000416 	blt	r2,zero,81130dc8 <__sbprintf+0x88>
81130db8:	d9410004 	addi	r5,sp,1024
81130dbc:	9009883a 	mov	r4,r18
81130dc0:	11290780 	call	81129078 <_fflush_r>
81130dc4:	10000d1e 	bne	r2,zero,81130dfc <__sbprintf+0xbc>
81130dc8:	d881030b 	ldhu	r2,1036(sp)
81130dcc:	1080100c 	andi	r2,r2,64
81130dd0:	10000326 	beq	r2,zero,81130de0 <__sbprintf+0xa0>
81130dd4:	8080030b 	ldhu	r2,12(r16)
81130dd8:	10801014 	ori	r2,r2,64
81130ddc:	8080030d 	sth	r2,12(r16)
81130de0:	8805883a 	mov	r2,r17
81130de4:	dfc11d17 	ldw	ra,1140(sp)
81130de8:	dc811c17 	ldw	r18,1136(sp)
81130dec:	dc411b17 	ldw	r17,1132(sp)
81130df0:	dc011a17 	ldw	r16,1128(sp)
81130df4:	dec11e04 	addi	sp,sp,1144
81130df8:	f800283a 	ret
81130dfc:	047fffc4 	movi	r17,-1
81130e00:	003ff106 	br	81130dc8 <__reset+0xfb110dc8>

81130e04 <_calloc_r>:
81130e04:	298b383a 	mul	r5,r5,r6
81130e08:	defffe04 	addi	sp,sp,-8
81130e0c:	de00012e 	bgeu	sp,et,81130e14 <_calloc_r+0x10>
81130e10:	003b68fa 	trap	3
81130e14:	dfc00115 	stw	ra,4(sp)
81130e18:	dc000015 	stw	r16,0(sp)
81130e1c:	111fe980 	call	8111fe98 <_malloc_r>
81130e20:	10002926 	beq	r2,zero,81130ec8 <_calloc_r+0xc4>
81130e24:	11bfff17 	ldw	r6,-4(r2)
81130e28:	1021883a 	mov	r16,r2
81130e2c:	00bfff04 	movi	r2,-4
81130e30:	308c703a 	and	r6,r6,r2
81130e34:	00c00904 	movi	r3,36
81130e38:	308d883a 	add	r6,r6,r2
81130e3c:	19801636 	bltu	r3,r6,81130e98 <_calloc_r+0x94>
81130e40:	008004c4 	movi	r2,19
81130e44:	11800b2e 	bgeu	r2,r6,81130e74 <_calloc_r+0x70>
81130e48:	80000015 	stw	zero,0(r16)
81130e4c:	80000115 	stw	zero,4(r16)
81130e50:	008006c4 	movi	r2,27
81130e54:	11801a2e 	bgeu	r2,r6,81130ec0 <_calloc_r+0xbc>
81130e58:	80000215 	stw	zero,8(r16)
81130e5c:	80000315 	stw	zero,12(r16)
81130e60:	30c0151e 	bne	r6,r3,81130eb8 <_calloc_r+0xb4>
81130e64:	80000415 	stw	zero,16(r16)
81130e68:	80800604 	addi	r2,r16,24
81130e6c:	80000515 	stw	zero,20(r16)
81130e70:	00000106 	br	81130e78 <_calloc_r+0x74>
81130e74:	8005883a 	mov	r2,r16
81130e78:	10000015 	stw	zero,0(r2)
81130e7c:	10000115 	stw	zero,4(r2)
81130e80:	10000215 	stw	zero,8(r2)
81130e84:	8005883a 	mov	r2,r16
81130e88:	dfc00117 	ldw	ra,4(sp)
81130e8c:	dc000017 	ldw	r16,0(sp)
81130e90:	dec00204 	addi	sp,sp,8
81130e94:	f800283a 	ret
81130e98:	000b883a 	mov	r5,zero
81130e9c:	8009883a 	mov	r4,r16
81130ea0:	11207fc0 	call	811207fc <memset>
81130ea4:	8005883a 	mov	r2,r16
81130ea8:	dfc00117 	ldw	ra,4(sp)
81130eac:	dc000017 	ldw	r16,0(sp)
81130eb0:	dec00204 	addi	sp,sp,8
81130eb4:	f800283a 	ret
81130eb8:	80800404 	addi	r2,r16,16
81130ebc:	003fee06 	br	81130e78 <__reset+0xfb110e78>
81130ec0:	80800204 	addi	r2,r16,8
81130ec4:	003fec06 	br	81130e78 <__reset+0xfb110e78>
81130ec8:	0005883a 	mov	r2,zero
81130ecc:	003fee06 	br	81130e88 <__reset+0xfb110e88>

81130ed0 <_fclose_r>:
81130ed0:	28003b26 	beq	r5,zero,81130fc0 <_fclose_r+0xf0>
81130ed4:	defffc04 	addi	sp,sp,-16
81130ed8:	de00012e 	bgeu	sp,et,81130ee0 <_fclose_r+0x10>
81130edc:	003b68fa 	trap	3
81130ee0:	dc400115 	stw	r17,4(sp)
81130ee4:	dc000015 	stw	r16,0(sp)
81130ee8:	dfc00315 	stw	ra,12(sp)
81130eec:	dc800215 	stw	r18,8(sp)
81130ef0:	2023883a 	mov	r17,r4
81130ef4:	2821883a 	mov	r16,r5
81130ef8:	20000226 	beq	r4,zero,81130f04 <_fclose_r+0x34>
81130efc:	20800e17 	ldw	r2,56(r4)
81130f00:	10002726 	beq	r2,zero,81130fa0 <_fclose_r+0xd0>
81130f04:	8080030f 	ldh	r2,12(r16)
81130f08:	1000071e 	bne	r2,zero,81130f28 <_fclose_r+0x58>
81130f0c:	0005883a 	mov	r2,zero
81130f10:	dfc00317 	ldw	ra,12(sp)
81130f14:	dc800217 	ldw	r18,8(sp)
81130f18:	dc400117 	ldw	r17,4(sp)
81130f1c:	dc000017 	ldw	r16,0(sp)
81130f20:	dec00404 	addi	sp,sp,16
81130f24:	f800283a 	ret
81130f28:	800b883a 	mov	r5,r16
81130f2c:	8809883a 	mov	r4,r17
81130f30:	1128e540 	call	81128e54 <__sflush_r>
81130f34:	1025883a 	mov	r18,r2
81130f38:	80800b17 	ldw	r2,44(r16)
81130f3c:	10000426 	beq	r2,zero,81130f50 <_fclose_r+0x80>
81130f40:	81400717 	ldw	r5,28(r16)
81130f44:	8809883a 	mov	r4,r17
81130f48:	103ee83a 	callr	r2
81130f4c:	10001616 	blt	r2,zero,81130fa8 <_fclose_r+0xd8>
81130f50:	8080030b 	ldhu	r2,12(r16)
81130f54:	1080200c 	andi	r2,r2,128
81130f58:	1000151e 	bne	r2,zero,81130fb0 <_fclose_r+0xe0>
81130f5c:	81400c17 	ldw	r5,48(r16)
81130f60:	28000526 	beq	r5,zero,81130f78 <_fclose_r+0xa8>
81130f64:	80801004 	addi	r2,r16,64
81130f68:	28800226 	beq	r5,r2,81130f74 <_fclose_r+0xa4>
81130f6c:	8809883a 	mov	r4,r17
81130f70:	112990c0 	call	8112990c <_free_r>
81130f74:	80000c15 	stw	zero,48(r16)
81130f78:	81401117 	ldw	r5,68(r16)
81130f7c:	28000326 	beq	r5,zero,81130f8c <_fclose_r+0xbc>
81130f80:	8809883a 	mov	r4,r17
81130f84:	112990c0 	call	8112990c <_free_r>
81130f88:	80001115 	stw	zero,68(r16)
81130f8c:	11294840 	call	81129484 <__sfp_lock_acquire>
81130f90:	8000030d 	sth	zero,12(r16)
81130f94:	11294880 	call	81129488 <__sfp_lock_release>
81130f98:	9005883a 	mov	r2,r18
81130f9c:	003fdc06 	br	81130f10 <__reset+0xfb110f10>
81130fa0:	11294740 	call	81129474 <__sinit>
81130fa4:	003fd706 	br	81130f04 <__reset+0xfb110f04>
81130fa8:	04bfffc4 	movi	r18,-1
81130fac:	003fe806 	br	81130f50 <__reset+0xfb110f50>
81130fb0:	81400417 	ldw	r5,16(r16)
81130fb4:	8809883a 	mov	r4,r17
81130fb8:	112990c0 	call	8112990c <_free_r>
81130fbc:	003fe706 	br	81130f5c <__reset+0xfb110f5c>
81130fc0:	0005883a 	mov	r2,zero
81130fc4:	f800283a 	ret

81130fc8 <fclose>:
81130fc8:	00a04574 	movhi	r2,33045
81130fcc:	1082c604 	addi	r2,r2,2840
81130fd0:	200b883a 	mov	r5,r4
81130fd4:	11000017 	ldw	r4,0(r2)
81130fd8:	1130ed01 	jmpi	81130ed0 <_fclose_r>

81130fdc <__fputwc>:
81130fdc:	defff804 	addi	sp,sp,-32
81130fe0:	de00012e 	bgeu	sp,et,81130fe8 <__fputwc+0xc>
81130fe4:	003b68fa 	trap	3
81130fe8:	dcc00415 	stw	r19,16(sp)
81130fec:	dc800315 	stw	r18,12(sp)
81130ff0:	dc000115 	stw	r16,4(sp)
81130ff4:	dfc00715 	stw	ra,28(sp)
81130ff8:	dd400615 	stw	r21,24(sp)
81130ffc:	dd000515 	stw	r20,20(sp)
81131000:	dc400215 	stw	r17,8(sp)
81131004:	2027883a 	mov	r19,r4
81131008:	2825883a 	mov	r18,r5
8113100c:	3021883a 	mov	r16,r6
81131010:	112a39c0 	call	8112a39c <__locale_mb_cur_max>
81131014:	00c00044 	movi	r3,1
81131018:	10c03e26 	beq	r2,r3,81131114 <__fputwc+0x138>
8113101c:	81c01704 	addi	r7,r16,92
81131020:	900d883a 	mov	r6,r18
81131024:	d80b883a 	mov	r5,sp
81131028:	9809883a 	mov	r4,r19
8113102c:	1131e600 	call	81131e60 <_wcrtomb_r>
81131030:	1029883a 	mov	r20,r2
81131034:	00bfffc4 	movi	r2,-1
81131038:	a0802026 	beq	r20,r2,811310bc <__fputwc+0xe0>
8113103c:	d9400003 	ldbu	r5,0(sp)
81131040:	a0001c26 	beq	r20,zero,811310b4 <__fputwc+0xd8>
81131044:	0023883a 	mov	r17,zero
81131048:	05400284 	movi	r21,10
8113104c:	00000906 	br	81131074 <__fputwc+0x98>
81131050:	80800017 	ldw	r2,0(r16)
81131054:	11400005 	stb	r5,0(r2)
81131058:	80c00017 	ldw	r3,0(r16)
8113105c:	18c00044 	addi	r3,r3,1
81131060:	80c00015 	stw	r3,0(r16)
81131064:	8c400044 	addi	r17,r17,1
81131068:	dc45883a 	add	r2,sp,r17
8113106c:	8d00112e 	bgeu	r17,r20,811310b4 <__fputwc+0xd8>
81131070:	11400003 	ldbu	r5,0(r2)
81131074:	80c00217 	ldw	r3,8(r16)
81131078:	18ffffc4 	addi	r3,r3,-1
8113107c:	80c00215 	stw	r3,8(r16)
81131080:	183ff30e 	bge	r3,zero,81131050 <__reset+0xfb111050>
81131084:	80800617 	ldw	r2,24(r16)
81131088:	18801916 	blt	r3,r2,811310f0 <__fputwc+0x114>
8113108c:	80800017 	ldw	r2,0(r16)
81131090:	11400005 	stb	r5,0(r2)
81131094:	80800017 	ldw	r2,0(r16)
81131098:	10c00003 	ldbu	r3,0(r2)
8113109c:	10800044 	addi	r2,r2,1
811310a0:	1d402326 	beq	r3,r21,81131130 <__fputwc+0x154>
811310a4:	80800015 	stw	r2,0(r16)
811310a8:	8c400044 	addi	r17,r17,1
811310ac:	dc45883a 	add	r2,sp,r17
811310b0:	8d3fef36 	bltu	r17,r20,81131070 <__reset+0xfb111070>
811310b4:	9005883a 	mov	r2,r18
811310b8:	00000406 	br	811310cc <__fputwc+0xf0>
811310bc:	80c0030b 	ldhu	r3,12(r16)
811310c0:	a005883a 	mov	r2,r20
811310c4:	18c01014 	ori	r3,r3,64
811310c8:	80c0030d 	sth	r3,12(r16)
811310cc:	dfc00717 	ldw	ra,28(sp)
811310d0:	dd400617 	ldw	r21,24(sp)
811310d4:	dd000517 	ldw	r20,20(sp)
811310d8:	dcc00417 	ldw	r19,16(sp)
811310dc:	dc800317 	ldw	r18,12(sp)
811310e0:	dc400217 	ldw	r17,8(sp)
811310e4:	dc000117 	ldw	r16,4(sp)
811310e8:	dec00804 	addi	sp,sp,32
811310ec:	f800283a 	ret
811310f0:	800d883a 	mov	r6,r16
811310f4:	29403fcc 	andi	r5,r5,255
811310f8:	9809883a 	mov	r4,r19
811310fc:	112723c0 	call	8112723c <__swbuf_r>
81131100:	10bfffe0 	cmpeqi	r2,r2,-1
81131104:	10803fcc 	andi	r2,r2,255
81131108:	103fd626 	beq	r2,zero,81131064 <__reset+0xfb111064>
8113110c:	00bfffc4 	movi	r2,-1
81131110:	003fee06 	br	811310cc <__reset+0xfb1110cc>
81131114:	90ffffc4 	addi	r3,r18,-1
81131118:	01003f84 	movi	r4,254
8113111c:	20ffbf36 	bltu	r4,r3,8113101c <__reset+0xfb11101c>
81131120:	900b883a 	mov	r5,r18
81131124:	dc800005 	stb	r18,0(sp)
81131128:	1029883a 	mov	r20,r2
8113112c:	003fc506 	br	81131044 <__reset+0xfb111044>
81131130:	800d883a 	mov	r6,r16
81131134:	a80b883a 	mov	r5,r21
81131138:	9809883a 	mov	r4,r19
8113113c:	112723c0 	call	8112723c <__swbuf_r>
81131140:	10bfffe0 	cmpeqi	r2,r2,-1
81131144:	003fef06 	br	81131104 <__reset+0xfb111104>

81131148 <_fputwc_r>:
81131148:	3080030b 	ldhu	r2,12(r6)
8113114c:	10c8000c 	andi	r3,r2,8192
81131150:	1800051e 	bne	r3,zero,81131168 <_fputwc_r+0x20>
81131154:	30c01917 	ldw	r3,100(r6)
81131158:	10880014 	ori	r2,r2,8192
8113115c:	3080030d 	sth	r2,12(r6)
81131160:	18880014 	ori	r2,r3,8192
81131164:	30801915 	stw	r2,100(r6)
81131168:	1130fdc1 	jmpi	81130fdc <__fputwc>

8113116c <fputwc>:
8113116c:	00a04574 	movhi	r2,33045
81131170:	defffc04 	addi	sp,sp,-16
81131174:	1082c604 	addi	r2,r2,2840
81131178:	de00012e 	bgeu	sp,et,81131180 <fputwc+0x14>
8113117c:	003b68fa 	trap	3
81131180:	dc000115 	stw	r16,4(sp)
81131184:	14000017 	ldw	r16,0(r2)
81131188:	dc400215 	stw	r17,8(sp)
8113118c:	dfc00315 	stw	ra,12(sp)
81131190:	2023883a 	mov	r17,r4
81131194:	80000226 	beq	r16,zero,811311a0 <fputwc+0x34>
81131198:	80800e17 	ldw	r2,56(r16)
8113119c:	10001026 	beq	r2,zero,811311e0 <fputwc+0x74>
811311a0:	2880030b 	ldhu	r2,12(r5)
811311a4:	10c8000c 	andi	r3,r2,8192
811311a8:	1800051e 	bne	r3,zero,811311c0 <fputwc+0x54>
811311ac:	28c01917 	ldw	r3,100(r5)
811311b0:	10880014 	ori	r2,r2,8192
811311b4:	2880030d 	sth	r2,12(r5)
811311b8:	18880014 	ori	r2,r3,8192
811311bc:	28801915 	stw	r2,100(r5)
811311c0:	280d883a 	mov	r6,r5
811311c4:	8009883a 	mov	r4,r16
811311c8:	880b883a 	mov	r5,r17
811311cc:	dfc00317 	ldw	ra,12(sp)
811311d0:	dc400217 	ldw	r17,8(sp)
811311d4:	dc000117 	ldw	r16,4(sp)
811311d8:	dec00404 	addi	sp,sp,16
811311dc:	1130fdc1 	jmpi	81130fdc <__fputwc>
811311e0:	8009883a 	mov	r4,r16
811311e4:	d9400015 	stw	r5,0(sp)
811311e8:	11294740 	call	81129474 <__sinit>
811311ec:	d9400017 	ldw	r5,0(sp)
811311f0:	003feb06 	br	811311a0 <__reset+0xfb1111a0>

811311f4 <rshift>:
811311f4:	2807d17a 	srai	r3,r5,5
811311f8:	20800417 	ldw	r2,16(r4)
811311fc:	22000504 	addi	r8,r4,20
81131200:	1880250e 	bge	r3,r2,81131298 <rshift+0xa4>
81131204:	1085883a 	add	r2,r2,r2
81131208:	18c7883a 	add	r3,r3,r3
8113120c:	1085883a 	add	r2,r2,r2
81131210:	18c7883a 	add	r3,r3,r3
81131214:	294007cc 	andi	r5,r5,31
81131218:	4085883a 	add	r2,r8,r2
8113121c:	40c7883a 	add	r3,r8,r3
81131220:	28002026 	beq	r5,zero,811312a4 <rshift+0xb0>
81131224:	19800017 	ldw	r6,0(r3)
81131228:	02c00804 	movi	r11,32
8113122c:	19c00104 	addi	r7,r3,4
81131230:	5957c83a 	sub	r11,r11,r5
81131234:	314cd83a 	srl	r6,r6,r5
81131238:	38802c2e 	bgeu	r7,r2,811312ec <rshift+0xf8>
8113123c:	4015883a 	mov	r10,r8
81131240:	3a400017 	ldw	r9,0(r7)
81131244:	52800104 	addi	r10,r10,4
81131248:	39c00104 	addi	r7,r7,4
8113124c:	4ad2983a 	sll	r9,r9,r11
81131250:	498cb03a 	or	r6,r9,r6
81131254:	51bfff15 	stw	r6,-4(r10)
81131258:	39bfff17 	ldw	r6,-4(r7)
8113125c:	314cd83a 	srl	r6,r6,r5
81131260:	38bff736 	bltu	r7,r2,81131240 <__reset+0xfb111240>
81131264:	10c7c83a 	sub	r3,r2,r3
81131268:	18fffec4 	addi	r3,r3,-5
8113126c:	1806d0ba 	srli	r3,r3,2
81131270:	18c00044 	addi	r3,r3,1
81131274:	18c7883a 	add	r3,r3,r3
81131278:	18c7883a 	add	r3,r3,r3
8113127c:	40c7883a 	add	r3,r8,r3
81131280:	19800015 	stw	r6,0(r3)
81131284:	30000126 	beq	r6,zero,8113128c <rshift+0x98>
81131288:	18c00104 	addi	r3,r3,4
8113128c:	1a05c83a 	sub	r2,r3,r8
81131290:	1005d0ba 	srai	r2,r2,2
81131294:	00001206 	br	811312e0 <rshift+0xec>
81131298:	20000415 	stw	zero,16(r4)
8113129c:	20000515 	stw	zero,20(r4)
811312a0:	f800283a 	ret
811312a4:	18bffc2e 	bgeu	r3,r2,81131298 <__reset+0xfb111298>
811312a8:	180d883a 	mov	r6,r3
811312ac:	400b883a 	mov	r5,r8
811312b0:	31c00017 	ldw	r7,0(r6)
811312b4:	29400104 	addi	r5,r5,4
811312b8:	31800104 	addi	r6,r6,4
811312bc:	29ffff15 	stw	r7,-4(r5)
811312c0:	30bffb36 	bltu	r6,r2,811312b0 <__reset+0xfb1112b0>
811312c4:	00c6303a 	nor	r3,zero,r3
811312c8:	1885883a 	add	r2,r3,r2
811312cc:	1004d0ba 	srli	r2,r2,2
811312d0:	10800044 	addi	r2,r2,1
811312d4:	1085883a 	add	r2,r2,r2
811312d8:	1085883a 	add	r2,r2,r2
811312dc:	1005d0ba 	srai	r2,r2,2
811312e0:	20800415 	stw	r2,16(r4)
811312e4:	103fed26 	beq	r2,zero,8113129c <__reset+0xfb11129c>
811312e8:	f800283a 	ret
811312ec:	4007883a 	mov	r3,r8
811312f0:	003fe306 	br	81131280 <__reset+0xfb111280>

811312f4 <__gethex>:
811312f4:	deffeb04 	addi	sp,sp,-84
811312f8:	de00012e 	bgeu	sp,et,81131300 <__gethex+0xc>
811312fc:	003b68fa 	trap	3
81131300:	dfc01415 	stw	ra,80(sp)
81131304:	dd801115 	stw	r22,68(sp)
81131308:	dcc00e15 	stw	r19,56(sp)
8113130c:	dc800d15 	stw	r18,52(sp)
81131310:	2827883a 	mov	r19,r5
81131314:	d9000115 	stw	r4,4(sp)
81131318:	d9800015 	stw	r6,0(sp)
8113131c:	d9c00415 	stw	r7,16(sp)
81131320:	df001315 	stw	fp,76(sp)
81131324:	ddc01215 	stw	r23,72(sp)
81131328:	dd401015 	stw	r21,64(sp)
8113132c:	dd000f15 	stw	r20,60(sp)
81131330:	dc400c15 	stw	r17,48(sp)
81131334:	dc000b15 	stw	r16,44(sp)
81131338:	112a3c00 	call	8112a3c0 <_localeconv_r>
8113133c:	14800017 	ldw	r18,0(r2)
81131340:	9009883a 	mov	r4,r18
81131344:	11211a00 	call	811211a0 <strlen>
81131348:	98c00017 	ldw	r3,0(r19)
8113134c:	102d883a 	mov	r22,r2
81131350:	9085883a 	add	r2,r18,r2
81131354:	10bfffc3 	ldbu	r2,-1(r2)
81131358:	19000083 	ldbu	r4,2(r3)
8113135c:	d8800305 	stb	r2,12(sp)
81131360:	00800c04 	movi	r2,48
81131364:	2081521e 	bne	r4,r2,811318b0 <__gethex+0x5bc>
81131368:	017fff84 	movi	r5,-2
8113136c:	188000c4 	addi	r2,r3,3
81131370:	28cbc83a 	sub	r5,r5,r3
81131374:	200d883a 	mov	r6,r4
81131378:	28a3883a 	add	r17,r5,r2
8113137c:	102b883a 	mov	r21,r2
81131380:	10800044 	addi	r2,r2,1
81131384:	113fffc3 	ldbu	r4,-1(r2)
81131388:	21bffb26 	beq	r4,r6,81131378 <__reset+0xfb111378>
8113138c:	05204574 	movhi	r20,33045
81131390:	a5399104 	addi	r20,r20,-6588
81131394:	a109883a 	add	r4,r20,r4
81131398:	20800003 	ldbu	r2,0(r4)
8113139c:	10008826 	beq	r2,zero,811315c0 <__gethex+0x2cc>
811313a0:	a8800003 	ldbu	r2,0(r21)
811313a4:	0015883a 	mov	r10,zero
811313a8:	002f883a 	mov	r23,zero
811313ac:	a085883a 	add	r2,r20,r2
811313b0:	10800003 	ldbu	r2,0(r2)
811313b4:	a821883a 	mov	r16,r21
811313b8:	10000526 	beq	r2,zero,811313d0 <__gethex+0xdc>
811313bc:	84000044 	addi	r16,r16,1
811313c0:	80800003 	ldbu	r2,0(r16)
811313c4:	a085883a 	add	r2,r20,r2
811313c8:	10800003 	ldbu	r2,0(r2)
811313cc:	103ffb1e 	bne	r2,zero,811313bc <__reset+0xfb1113bc>
811313d0:	b00d883a 	mov	r6,r22
811313d4:	900b883a 	mov	r5,r18
811313d8:	8009883a 	mov	r4,r16
811313dc:	da800a15 	stw	r10,40(sp)
811313e0:	1131d900 	call	81131d90 <strncmp>
811313e4:	da800a17 	ldw	r10,40(sp)
811313e8:	1000031e 	bne	r2,zero,811313f8 <__gethex+0x104>
811313ec:	b8015226 	beq	r23,zero,81131938 <__gethex+0x644>
811313f0:	80800003 	ldbu	r2,0(r16)
811313f4:	00000206 	br	81131400 <__gethex+0x10c>
811313f8:	80800003 	ldbu	r2,0(r16)
811313fc:	b8011f26 	beq	r23,zero,8113187c <__gethex+0x588>
81131400:	85efc83a 	sub	r23,r16,r23
81131404:	bdef883a 	add	r23,r23,r23
81131408:	bdef883a 	add	r23,r23,r23
8113140c:	05efc83a 	sub	r23,zero,r23
81131410:	10803fcc 	andi	r2,r2,255
81131414:	01001404 	movi	r4,80
81131418:	11008626 	beq	r2,r4,81131634 <__gethex+0x340>
8113141c:	01001c04 	movi	r4,112
81131420:	11008426 	beq	r2,r4,81131634 <__gethex+0x340>
81131424:	8039883a 	mov	fp,r16
81131428:	9c000015 	stw	r16,0(r19)
8113142c:	5000711e 	bne	r10,zero,811315f4 <__gethex+0x300>
81131430:	e545c83a 	sub	r2,fp,r21
81131434:	10bfffc4 	addi	r2,r2,-1
81131438:	010001c4 	movi	r4,7
8113143c:	000b883a 	mov	r5,zero
81131440:	2080030e 	bge	r4,r2,81131450 <__gethex+0x15c>
81131444:	1005d07a 	srai	r2,r2,1
81131448:	29400044 	addi	r5,r5,1
8113144c:	20bffd16 	blt	r4,r2,81131444 <__reset+0xfb111444>
81131450:	d9000117 	ldw	r4,4(sp)
81131454:	112a8dc0 	call	8112a8dc <_Balloc>
81131458:	10c00504 	addi	r3,r2,20
8113145c:	d8c00215 	stw	r3,8(sp)
81131460:	1021883a 	mov	r16,r2
81131464:	af01732e 	bgeu	r21,fp,81131a34 <__gethex+0x740>
81131468:	dc400303 	ldbu	r17,12(sp)
8113146c:	03400044 	movi	r13,1
81131470:	1815883a 	mov	r10,r3
81131474:	0013883a 	mov	r9,zero
81131478:	0027883a 	mov	r19,zero
8113147c:	6d9bc83a 	sub	r13,r13,r22
81131480:	02c00804 	movi	r11,32
81131484:	e0bfffc3 	ldbu	r2,-1(fp)
81131488:	e3bfffc4 	addi	r14,fp,-1
8113148c:	88803026 	beq	r17,r2,81131550 <__gethex+0x25c>
81131490:	9ac04526 	beq	r19,r11,811315a8 <__gethex+0x2b4>
81131494:	980b883a 	mov	r5,r19
81131498:	9cc00104 	addi	r19,r19,4
8113149c:	e13fffc3 	ldbu	r4,-1(fp)
811314a0:	7039883a 	mov	fp,r14
811314a4:	a109883a 	add	r4,r20,r4
811314a8:	20800003 	ldbu	r2,0(r4)
811314ac:	108003cc 	andi	r2,r2,15
811314b0:	1144983a 	sll	r2,r2,r5
811314b4:	4892b03a 	or	r9,r9,r2
811314b8:	af3ff236 	bltu	r21,fp,81131484 <__reset+0xfb111484>
811314bc:	d8c00217 	ldw	r3,8(sp)
811314c0:	50800104 	addi	r2,r10,4
811314c4:	52400015 	stw	r9,0(r10)
811314c8:	10c5c83a 	sub	r2,r2,r3
811314cc:	1005d0ba 	srai	r2,r2,2
811314d0:	4809883a 	mov	r4,r9
811314d4:	80800415 	stw	r2,16(r16)
811314d8:	1022917a 	slli	r17,r2,5
811314dc:	112abe80 	call	8112abe8 <__hi0bits>
811314e0:	d8c00017 	ldw	r3,0(sp)
811314e4:	8885c83a 	sub	r2,r17,r2
811314e8:	1c800017 	ldw	r18,0(r3)
811314ec:	9080c716 	blt	r18,r2,8113180c <__gethex+0x518>
811314f0:	1480e416 	blt	r2,r18,81131884 <__gethex+0x590>
811314f4:	0027883a 	mov	r19,zero
811314f8:	d8c00017 	ldw	r3,0(sp)
811314fc:	18800217 	ldw	r2,8(r3)
81131500:	15c08d16 	blt	r2,r23,81131738 <__gethex+0x444>
81131504:	d8c00017 	ldw	r3,0(sp)
81131508:	18800117 	ldw	r2,4(r3)
8113150c:	b880aa0e 	bge	r23,r2,811317b8 <__gethex+0x4c4>
81131510:	15efc83a 	sub	r23,r2,r23
81131514:	bc80ed16 	blt	r23,r18,811318cc <__gethex+0x5d8>
81131518:	18c00317 	ldw	r3,12(r3)
8113151c:	01000084 	movi	r4,2
81131520:	19014926 	beq	r3,r4,81131a48 <__gethex+0x754>
81131524:	010000c4 	movi	r4,3
81131528:	19012e26 	beq	r3,r4,811319e4 <__gethex+0x6f0>
8113152c:	01000044 	movi	r4,1
81131530:	19014826 	beq	r3,r4,81131a54 <__gethex+0x760>
81131534:	d9000117 	ldw	r4,4(sp)
81131538:	800b883a 	mov	r5,r16
8113153c:	112a98c0 	call	8112a98c <_Bfree>
81131540:	d8801517 	ldw	r2,84(sp)
81131544:	10000015 	stw	zero,0(r2)
81131548:	00801404 	movi	r2,80
8113154c:	00002b06 	br	811315fc <__gethex+0x308>
81131550:	735f883a 	add	r15,r14,r13
81131554:	7d7fce36 	bltu	r15,r21,81131490 <__reset+0xfb111490>
81131558:	7809883a 	mov	r4,r15
8113155c:	b00d883a 	mov	r6,r22
81131560:	900b883a 	mov	r5,r18
81131564:	da400515 	stw	r9,20(sp)
81131568:	da800a15 	stw	r10,40(sp)
8113156c:	dac00915 	stw	r11,36(sp)
81131570:	db400815 	stw	r13,32(sp)
81131574:	db800615 	stw	r14,24(sp)
81131578:	dbc00715 	stw	r15,28(sp)
8113157c:	1131d900 	call	81131d90 <strncmp>
81131580:	da400517 	ldw	r9,20(sp)
81131584:	da800a17 	ldw	r10,40(sp)
81131588:	dac00917 	ldw	r11,36(sp)
8113158c:	db400817 	ldw	r13,32(sp)
81131590:	db800617 	ldw	r14,24(sp)
81131594:	dbc00717 	ldw	r15,28(sp)
81131598:	103fbd1e 	bne	r2,zero,81131490 <__reset+0xfb111490>
8113159c:	7839883a 	mov	fp,r15
811315a0:	af3fb836 	bltu	r21,fp,81131484 <__reset+0xfb111484>
811315a4:	003fc506 	br	811314bc <__reset+0xfb1114bc>
811315a8:	04c00104 	movi	r19,4
811315ac:	52400015 	stw	r9,0(r10)
811315b0:	000b883a 	mov	r5,zero
811315b4:	54d5883a 	add	r10,r10,r19
811315b8:	0013883a 	mov	r9,zero
811315bc:	003fb706 	br	8113149c <__reset+0xfb11149c>
811315c0:	b00d883a 	mov	r6,r22
811315c4:	900b883a 	mov	r5,r18
811315c8:	a809883a 	mov	r4,r21
811315cc:	1131d900 	call	81131d90 <strncmp>
811315d0:	10006426 	beq	r2,zero,81131764 <__gethex+0x470>
811315d4:	a8800003 	ldbu	r2,0(r21)
811315d8:	a821883a 	mov	r16,r21
811315dc:	10803fcc 	andi	r2,r2,255
811315e0:	01001404 	movi	r4,80
811315e4:	11001126 	beq	r2,r4,8113162c <__gethex+0x338>
811315e8:	01001c04 	movi	r4,112
811315ec:	11000f26 	beq	r2,r4,8113162c <__gethex+0x338>
811315f0:	9c000015 	stw	r16,0(r19)
811315f4:	8800831e 	bne	r17,zero,81131804 <__gethex+0x510>
811315f8:	00800184 	movi	r2,6
811315fc:	dfc01417 	ldw	ra,80(sp)
81131600:	df001317 	ldw	fp,76(sp)
81131604:	ddc01217 	ldw	r23,72(sp)
81131608:	dd801117 	ldw	r22,68(sp)
8113160c:	dd401017 	ldw	r21,64(sp)
81131610:	dd000f17 	ldw	r20,60(sp)
81131614:	dcc00e17 	ldw	r19,56(sp)
81131618:	dc800d17 	ldw	r18,52(sp)
8113161c:	dc400c17 	ldw	r17,48(sp)
81131620:	dc000b17 	ldw	r16,44(sp)
81131624:	dec01504 	addi	sp,sp,84
81131628:	f800283a 	ret
8113162c:	002f883a 	mov	r23,zero
81131630:	02800044 	movi	r10,1
81131634:	80800043 	ldbu	r2,1(r16)
81131638:	01400ac4 	movi	r5,43
8113163c:	11003fcc 	andi	r4,r2,255
81131640:	21406e26 	beq	r4,r5,811317fc <__gethex+0x508>
81131644:	01400b44 	movi	r5,45
81131648:	21404226 	beq	r4,r5,81131754 <__gethex+0x460>
8113164c:	81400044 	addi	r5,r16,1
81131650:	000d883a 	mov	r6,zero
81131654:	10803fcc 	andi	r2,r2,255
81131658:	a085883a 	add	r2,r20,r2
8113165c:	11000003 	ldbu	r4,0(r2)
81131660:	03000604 	movi	r12,24
81131664:	20bfffc4 	addi	r2,r4,-1
81131668:	10803fcc 	andi	r2,r2,255
8113166c:	60bf6d36 	bltu	r12,r2,81131424 <__reset+0xfb111424>
81131670:	2ac00043 	ldbu	r11,1(r5)
81131674:	20803fcc 	andi	r2,r4,255
81131678:	01204574 	movhi	r4,33045
8113167c:	21399104 	addi	r4,r4,-6588
81131680:	22c9883a 	add	r4,r4,r11
81131684:	23400003 	ldbu	r13,0(r4)
81131688:	10bffc04 	addi	r2,r2,-16
8113168c:	29400044 	addi	r5,r5,1
81131690:	693fffc4 	addi	r4,r13,-1
81131694:	21003fcc 	andi	r4,r4,255
81131698:	6b403fcc 	andi	r13,r13,255
8113169c:	61000b36 	bltu	r12,r4,811316cc <__gethex+0x3d8>
811316a0:	29400044 	addi	r5,r5,1
811316a4:	29000003 	ldbu	r4,0(r5)
811316a8:	108002a4 	muli	r2,r2,10
811316ac:	a109883a 	add	r4,r20,r4
811316b0:	22c00003 	ldbu	r11,0(r4)
811316b4:	1345883a 	add	r2,r2,r13
811316b8:	10bffc04 	addi	r2,r2,-16
811316bc:	593fffc4 	addi	r4,r11,-1
811316c0:	21003fcc 	andi	r4,r4,255
811316c4:	5b403fcc 	andi	r13,r11,255
811316c8:	613ff52e 	bgeu	r12,r4,811316a0 <__reset+0xfb1116a0>
811316cc:	30000126 	beq	r6,zero,811316d4 <__gethex+0x3e0>
811316d0:	0085c83a 	sub	r2,zero,r2
811316d4:	8039883a 	mov	fp,r16
811316d8:	b8af883a 	add	r23,r23,r2
811316dc:	2821883a 	mov	r16,r5
811316e0:	003f5106 	br	81131428 <__reset+0xfb111428>
811316e4:	80800217 	ldw	r2,8(r16)
811316e8:	e080f00e 	bge	fp,r2,81131aac <__gethex+0x7b8>
811316ec:	e007883a 	mov	r3,fp
811316f0:	18800144 	addi	r2,r3,5
811316f4:	1085883a 	add	r2,r2,r2
811316f8:	18c00044 	addi	r3,r3,1
811316fc:	1085883a 	add	r2,r2,r2
81131700:	8085883a 	add	r2,r16,r2
81131704:	80c00415 	stw	r3,16(r16)
81131708:	01000044 	movi	r4,1
8113170c:	11000015 	stw	r4,0(r2)
81131710:	00800084 	movi	r2,2
81131714:	8880d826 	beq	r17,r2,81131a78 <__gethex+0x784>
81131718:	e0c0ac0e 	bge	fp,r3,811319cc <__gethex+0x6d8>
8113171c:	01400044 	movi	r5,1
81131720:	8009883a 	mov	r4,r16
81131724:	11311f40 	call	811311f4 <rshift>
81131728:	d8c00017 	ldw	r3,0(sp)
8113172c:	bdc00044 	addi	r23,r23,1
81131730:	18800217 	ldw	r2,8(r3)
81131734:	15c0a70e 	bge	r2,r23,811319d4 <__gethex+0x6e0>
81131738:	d9000117 	ldw	r4,4(sp)
8113173c:	800b883a 	mov	r5,r16
81131740:	112a98c0 	call	8112a98c <_Bfree>
81131744:	d9001517 	ldw	r4,84(sp)
81131748:	008028c4 	movi	r2,163
8113174c:	20000015 	stw	zero,0(r4)
81131750:	003faa06 	br	811315fc <__reset+0xfb1115fc>
81131754:	01800044 	movi	r6,1
81131758:	80800083 	ldbu	r2,2(r16)
8113175c:	81400084 	addi	r5,r16,2
81131760:	003fbc06 	br	81131654 <__reset+0xfb111654>
81131764:	ada1883a 	add	r16,r21,r22
81131768:	81000003 	ldbu	r4,0(r16)
8113176c:	21403fcc 	andi	r5,r4,255
81131770:	a145883a 	add	r2,r20,r5
81131774:	10800003 	ldbu	r2,0(r2)
81131778:	11803fcc 	andi	r6,r2,255
8113177c:	30004f26 	beq	r6,zero,811318bc <__gethex+0x5c8>
81131780:	00c00c04 	movi	r3,48
81131784:	802b883a 	mov	r21,r16
81131788:	28c0061e 	bne	r5,r3,811317a4 <__gethex+0x4b0>
8113178c:	2809883a 	mov	r4,r5
81131790:	ad400044 	addi	r21,r21,1
81131794:	a8800003 	ldbu	r2,0(r21)
81131798:	113ffd26 	beq	r2,r4,81131790 <__reset+0xfb111790>
8113179c:	a085883a 	add	r2,r20,r2
811317a0:	10800003 	ldbu	r2,0(r2)
811317a4:	10803fcc 	andi	r2,r2,255
811317a8:	1015003a 	cmpeq	r10,r2,zero
811317ac:	802f883a 	mov	r23,r16
811317b0:	04400044 	movi	r17,1
811317b4:	003eff06 	br	811313b4 <__reset+0xfb1113b4>
811317b8:	04400044 	movi	r17,1
811317bc:	98000926 	beq	r19,zero,811317e4 <__gethex+0x4f0>
811317c0:	d8c00017 	ldw	r3,0(sp)
811317c4:	18800317 	ldw	r2,12(r3)
811317c8:	00c00084 	movi	r3,2
811317cc:	10c06826 	beq	r2,r3,81131970 <__gethex+0x67c>
811317d0:	00c000c4 	movi	r3,3
811317d4:	10c06a26 	beq	r2,r3,81131980 <__gethex+0x68c>
811317d8:	00c00044 	movi	r3,1
811317dc:	10c08d26 	beq	r2,r3,81131a14 <__gethex+0x720>
811317e0:	8c400414 	ori	r17,r17,16
811317e4:	d9001517 	ldw	r4,84(sp)
811317e8:	d8c00417 	ldw	r3,16(sp)
811317ec:	8805883a 	mov	r2,r17
811317f0:	24000015 	stw	r16,0(r4)
811317f4:	1dc00015 	stw	r23,0(r3)
811317f8:	003f8006 	br	811315fc <__reset+0xfb1115fc>
811317fc:	000d883a 	mov	r6,zero
81131800:	003fd506 	br	81131758 <__reset+0xfb111758>
81131804:	0005883a 	mov	r2,zero
81131808:	003f7c06 	br	811315fc <__reset+0xfb1115fc>
8113180c:	14a3c83a 	sub	r17,r2,r18
81131810:	880b883a 	mov	r5,r17
81131814:	8009883a 	mov	r4,r16
81131818:	112b8ac0 	call	8112b8ac <__any_on>
8113181c:	10002926 	beq	r2,zero,811318c4 <__gethex+0x5d0>
81131820:	897fffc4 	addi	r5,r17,-1
81131824:	2807d17a 	srai	r3,r5,5
81131828:	d8800217 	ldw	r2,8(sp)
8113182c:	290007cc 	andi	r4,r5,31
81131830:	18c7883a 	add	r3,r3,r3
81131834:	18c7883a 	add	r3,r3,r3
81131838:	04c00044 	movi	r19,1
8113183c:	10c7883a 	add	r3,r2,r3
81131840:	9908983a 	sll	r4,r19,r4
81131844:	18c00017 	ldw	r3,0(r3)
81131848:	20c6703a 	and	r3,r4,r3
8113184c:	18000626 	beq	r3,zero,81131868 <__gethex+0x574>
81131850:	99407b0e 	bge	r19,r5,81131a40 <__gethex+0x74c>
81131854:	897fff84 	addi	r5,r17,-2
81131858:	8009883a 	mov	r4,r16
8113185c:	112b8ac0 	call	8112b8ac <__any_on>
81131860:	10007726 	beq	r2,zero,81131a40 <__gethex+0x74c>
81131864:	04c000c4 	movi	r19,3
81131868:	880b883a 	mov	r5,r17
8113186c:	8009883a 	mov	r4,r16
81131870:	11311f40 	call	811311f4 <rshift>
81131874:	bc6f883a 	add	r23,r23,r17
81131878:	003f1f06 	br	811314f8 <__reset+0xfb1114f8>
8113187c:	002f883a 	mov	r23,zero
81131880:	003ee306 	br	81131410 <__reset+0xfb111410>
81131884:	d9000117 	ldw	r4,4(sp)
81131888:	90a3c83a 	sub	r17,r18,r2
8113188c:	800b883a 	mov	r5,r16
81131890:	880d883a 	mov	r6,r17
81131894:	112b08c0 	call	8112b08c <__lshift>
81131898:	10c00504 	addi	r3,r2,20
8113189c:	1021883a 	mov	r16,r2
811318a0:	bc6fc83a 	sub	r23,r23,r17
811318a4:	d8c00215 	stw	r3,8(sp)
811318a8:	0027883a 	mov	r19,zero
811318ac:	003f1206 	br	811314f8 <__reset+0xfb1114f8>
811318b0:	1d400084 	addi	r21,r3,2
811318b4:	0023883a 	mov	r17,zero
811318b8:	003eb406 	br	8113138c <__reset+0xfb11138c>
811318bc:	2005883a 	mov	r2,r4
811318c0:	003f4606 	br	811315dc <__reset+0xfb1115dc>
811318c4:	0027883a 	mov	r19,zero
811318c8:	003fe706 	br	81131868 <__reset+0xfb111868>
811318cc:	bc7fffc4 	addi	r17,r23,-1
811318d0:	9800421e 	bne	r19,zero,811319dc <__gethex+0x6e8>
811318d4:	88000426 	beq	r17,zero,811318e8 <__gethex+0x5f4>
811318d8:	880b883a 	mov	r5,r17
811318dc:	8009883a 	mov	r4,r16
811318e0:	112b8ac0 	call	8112b8ac <__any_on>
811318e4:	1027883a 	mov	r19,r2
811318e8:	8805d17a 	srai	r2,r17,5
811318ec:	d8c00217 	ldw	r3,8(sp)
811318f0:	8c4007cc 	andi	r17,r17,31
811318f4:	1085883a 	add	r2,r2,r2
811318f8:	1085883a 	add	r2,r2,r2
811318fc:	1885883a 	add	r2,r3,r2
81131900:	00c00044 	movi	r3,1
81131904:	1c62983a 	sll	r17,r3,r17
81131908:	10800017 	ldw	r2,0(r2)
8113190c:	8884703a 	and	r2,r17,r2
81131910:	10000126 	beq	r2,zero,81131918 <__gethex+0x624>
81131914:	9cc00094 	ori	r19,r19,2
81131918:	b80b883a 	mov	r5,r23
8113191c:	8009883a 	mov	r4,r16
81131920:	11311f40 	call	811311f4 <rshift>
81131924:	d8c00017 	ldw	r3,0(sp)
81131928:	95e5c83a 	sub	r18,r18,r23
8113192c:	04400084 	movi	r17,2
81131930:	1dc00117 	ldw	r23,4(r3)
81131934:	003fa106 	br	811317bc <__reset+0xfb1117bc>
81131938:	85af883a 	add	r23,r16,r22
8113193c:	b8800003 	ldbu	r2,0(r23)
81131940:	b821883a 	mov	r16,r23
81131944:	11003fcc 	andi	r4,r2,255
81131948:	a109883a 	add	r4,r20,r4
8113194c:	21000003 	ldbu	r4,0(r4)
81131950:	203eaa26 	beq	r4,zero,811313fc <__reset+0xfb1113fc>
81131954:	84000044 	addi	r16,r16,1
81131958:	80800003 	ldbu	r2,0(r16)
8113195c:	11003fcc 	andi	r4,r2,255
81131960:	a109883a 	add	r4,r20,r4
81131964:	21000003 	ldbu	r4,0(r4)
81131968:	203ffa1e 	bne	r4,zero,81131954 <__reset+0xfb111954>
8113196c:	003ea306 	br	811313fc <__reset+0xfb1113fc>
81131970:	d9001617 	ldw	r4,88(sp)
81131974:	00800044 	movi	r2,1
81131978:	1109c83a 	sub	r4,r2,r4
8113197c:	d9001615 	stw	r4,88(sp)
81131980:	d8801617 	ldw	r2,88(sp)
81131984:	103f9626 	beq	r2,zero,811317e0 <__reset+0xfb1117e0>
81131988:	87000417 	ldw	fp,16(r16)
8113198c:	d9800217 	ldw	r6,8(sp)
81131990:	013fffc4 	movi	r4,-1
81131994:	e727883a 	add	r19,fp,fp
81131998:	9ce7883a 	add	r19,r19,r19
8113199c:	3005883a 	mov	r2,r6
811319a0:	34cb883a 	add	r5,r6,r19
811319a4:	00000306 	br	811319b4 <__gethex+0x6c0>
811319a8:	10000015 	stw	zero,0(r2)
811319ac:	10800104 	addi	r2,r2,4
811319b0:	117f4c2e 	bgeu	r2,r5,811316e4 <__reset+0xfb1116e4>
811319b4:	10c00017 	ldw	r3,0(r2)
811319b8:	193ffb26 	beq	r3,r4,811319a8 <__reset+0xfb1119a8>
811319bc:	18c00044 	addi	r3,r3,1
811319c0:	10c00015 	stw	r3,0(r2)
811319c4:	00800084 	movi	r2,2
811319c8:	88802b26 	beq	r17,r2,81131a78 <__gethex+0x784>
811319cc:	948007cc 	andi	r18,r18,31
811319d0:	90002f1e 	bne	r18,zero,81131a90 <__gethex+0x79c>
811319d4:	04400844 	movi	r17,33
811319d8:	003f8206 	br	811317e4 <__reset+0xfb1117e4>
811319dc:	04c00044 	movi	r19,1
811319e0:	003fc106 	br	811318e8 <__reset+0xfb1118e8>
811319e4:	d8c01617 	ldw	r3,88(sp)
811319e8:	183ed226 	beq	r3,zero,81131534 <__reset+0xfb111534>
811319ec:	d8c00417 	ldw	r3,16(sp)
811319f0:	d9001517 	ldw	r4,84(sp)
811319f4:	18800015 	stw	r2,0(r3)
811319f8:	d8c00217 	ldw	r3,8(sp)
811319fc:	00800044 	movi	r2,1
81131a00:	80800415 	stw	r2,16(r16)
81131a04:	18800015 	stw	r2,0(r3)
81131a08:	24000015 	stw	r16,0(r4)
81131a0c:	00801884 	movi	r2,98
81131a10:	003efa06 	br	811315fc <__reset+0xfb1115fc>
81131a14:	9880008c 	andi	r2,r19,2
81131a18:	103f7126 	beq	r2,zero,811317e0 <__reset+0xfb1117e0>
81131a1c:	d8c00217 	ldw	r3,8(sp)
81131a20:	18800017 	ldw	r2,0(r3)
81131a24:	9884b03a 	or	r2,r19,r2
81131a28:	1080004c 	andi	r2,r2,1
81131a2c:	103fd61e 	bne	r2,zero,81131988 <__reset+0xfb111988>
81131a30:	003f6b06 	br	811317e0 <__reset+0xfb1117e0>
81131a34:	da800217 	ldw	r10,8(sp)
81131a38:	0013883a 	mov	r9,zero
81131a3c:	003e9f06 	br	811314bc <__reset+0xfb1114bc>
81131a40:	04c00084 	movi	r19,2
81131a44:	003f8806 	br	81131868 <__reset+0xfb111868>
81131a48:	d9001617 	ldw	r4,88(sp)
81131a4c:	203fe726 	beq	r4,zero,811319ec <__reset+0xfb1119ec>
81131a50:	003eb806 	br	81131534 <__reset+0xfb111534>
81131a54:	95feb71e 	bne	r18,r23,81131534 <__reset+0xfb111534>
81131a58:	1cbfe40e 	bge	r3,r18,811319ec <__reset+0xfb1119ec>
81131a5c:	917fffc4 	addi	r5,r18,-1
81131a60:	8009883a 	mov	r4,r16
81131a64:	112b8ac0 	call	8112b8ac <__any_on>
81131a68:	103eb226 	beq	r2,zero,81131534 <__reset+0xfb111534>
81131a6c:	d8c00017 	ldw	r3,0(sp)
81131a70:	18800117 	ldw	r2,4(r3)
81131a74:	003fdd06 	br	811319ec <__reset+0xfb1119ec>
81131a78:	d8c00017 	ldw	r3,0(sp)
81131a7c:	18800017 	ldw	r2,0(r3)
81131a80:	10bfffc4 	addi	r2,r2,-1
81131a84:	90801c26 	beq	r18,r2,81131af8 <__gethex+0x804>
81131a88:	04400884 	movi	r17,34
81131a8c:	003f5506 	br	811317e4 <__reset+0xfb1117e4>
81131a90:	34c5883a 	add	r2,r6,r19
81131a94:	113fff17 	ldw	r4,-4(r2)
81131a98:	112abe80 	call	8112abe8 <__hi0bits>
81131a9c:	00c00804 	movi	r3,32
81131aa0:	1ca5c83a 	sub	r18,r3,r18
81131aa4:	14bfcb0e 	bge	r2,r18,811319d4 <__reset+0xfb1119d4>
81131aa8:	003f1c06 	br	8113171c <__reset+0xfb11171c>
81131aac:	81400117 	ldw	r5,4(r16)
81131ab0:	d9000117 	ldw	r4,4(sp)
81131ab4:	29400044 	addi	r5,r5,1
81131ab8:	112a8dc0 	call	8112a8dc <_Balloc>
81131abc:	81800417 	ldw	r6,16(r16)
81131ac0:	81400304 	addi	r5,r16,12
81131ac4:	11000304 	addi	r4,r2,12
81131ac8:	31800084 	addi	r6,r6,2
81131acc:	318d883a 	add	r6,r6,r6
81131ad0:	318d883a 	add	r6,r6,r6
81131ad4:	1029883a 	mov	r20,r2
81131ad8:	11206ac0 	call	811206ac <memcpy>
81131adc:	d9000117 	ldw	r4,4(sp)
81131ae0:	800b883a 	mov	r5,r16
81131ae4:	a021883a 	mov	r16,r20
81131ae8:	112a98c0 	call	8112a98c <_Bfree>
81131aec:	a0c00417 	ldw	r3,16(r20)
81131af0:	a1800504 	addi	r6,r20,20
81131af4:	003efe06 	br	811316f0 <__reset+0xfb1116f0>
81131af8:	9005d17a 	srai	r2,r18,5
81131afc:	944007cc 	andi	r17,r18,31
81131b00:	1085883a 	add	r2,r2,r2
81131b04:	1085883a 	add	r2,r2,r2
81131b08:	3087883a 	add	r3,r6,r2
81131b0c:	00800044 	movi	r2,1
81131b10:	1462983a 	sll	r17,r2,r17
81131b14:	18800017 	ldw	r2,0(r3)
81131b18:	8884703a 	and	r2,r17,r2
81131b1c:	1022c03a 	cmpne	r17,r2,zero
81131b20:	00800884 	movi	r2,34
81131b24:	1463c83a 	sub	r17,r2,r17
81131b28:	003f2e06 	br	811317e4 <__reset+0xfb1117e4>

81131b2c <__hexnan>:
81131b2c:	defff904 	addi	sp,sp,-28
81131b30:	de00012e 	bgeu	sp,et,81131b38 <__hexnan+0xc>
81131b34:	003b68fa 	trap	3
81131b38:	dc800215 	stw	r18,8(sp)
81131b3c:	2c800017 	ldw	r18,0(r5)
81131b40:	dfc00615 	stw	ra,24(sp)
81131b44:	dd400515 	stw	r21,20(sp)
81131b48:	901fd17a 	srai	r15,r18,5
81131b4c:	dd000415 	stw	r20,16(sp)
81131b50:	dcc00315 	stw	r19,12(sp)
81131b54:	7bdf883a 	add	r15,r15,r15
81131b58:	7bdf883a 	add	r15,r15,r15
81131b5c:	dc400115 	stw	r17,4(sp)
81131b60:	dc000015 	stw	r16,0(sp)
81131b64:	948007cc 	andi	r18,r18,31
81131b68:	33df883a 	add	r15,r6,r15
81131b6c:	90000126 	beq	r18,zero,81131b74 <__hexnan+0x48>
81131b70:	7bc00104 	addi	r15,r15,4
81131b74:	22000017 	ldw	r8,0(r4)
81131b78:	7affff04 	addi	r11,r15,-4
81131b7c:	03a04574 	movhi	r14,33045
81131b80:	783fff15 	stw	zero,-4(r15)
81131b84:	581b883a 	mov	r13,r11
81131b88:	580b883a 	mov	r5,r11
81131b8c:	000f883a 	mov	r7,zero
81131b90:	003f883a 	mov	ra,zero
81131b94:	0019883a 	mov	r12,zero
81131b98:	73b99104 	addi	r14,r14,-6588
81131b9c:	04400204 	movi	r17,8
81131ba0:	04000804 	movi	r16,32
81131ba4:	04c001c4 	movi	r19,7
81131ba8:	42000044 	addi	r8,r8,1
81131bac:	40c00003 	ldbu	r3,0(r8)
81131bb0:	18001d26 	beq	r3,zero,81131c28 <__hexnan+0xfc>
81131bb4:	70c5883a 	add	r2,r14,r3
81131bb8:	10800003 	ldbu	r2,0(r2)
81131bbc:	12403fcc 	andi	r9,r2,255
81131bc0:	4800301e 	bne	r9,zero,81131c84 <__hexnan+0x158>
81131bc4:	80c04236 	bltu	r16,r3,81131cd0 <__hexnan+0x1a4>
81131bc8:	fb3ff70e 	bge	ra,r12,81131ba8 <__reset+0xfb111ba8>
81131bcc:	2b40112e 	bgeu	r5,r13,81131c14 <__hexnan+0xe8>
81131bd0:	99c01016 	blt	r19,r7,81131c14 <__hexnan+0xe8>
81131bd4:	89e9c83a 	sub	r20,r17,r7
81131bd8:	a529883a 	add	r20,r20,r20
81131bdc:	2a800017 	ldw	r10,0(r5)
81131be0:	a529883a 	add	r20,r20,r20
81131be4:	852bc83a 	sub	r21,r16,r20
81131be8:	28c00104 	addi	r3,r5,4
81131bec:	2805883a 	mov	r2,r5
81131bf0:	19c00017 	ldw	r7,0(r3)
81131bf4:	10800104 	addi	r2,r2,4
81131bf8:	18c00104 	addi	r3,r3,4
81131bfc:	3d52983a 	sll	r9,r7,r21
81131c00:	4a92b03a 	or	r9,r9,r10
81131c04:	3d14d83a 	srl	r10,r7,r20
81131c08:	127fff15 	stw	r9,-4(r2)
81131c0c:	1abfff15 	stw	r10,-4(r3)
81131c10:	137ff736 	bltu	r2,r13,81131bf0 <__reset+0xfb111bf0>
81131c14:	31402836 	bltu	r6,r5,81131cb8 <__hexnan+0x18c>
81131c18:	42000044 	addi	r8,r8,1
81131c1c:	40c00003 	ldbu	r3,0(r8)
81131c20:	01c00204 	movi	r7,8
81131c24:	183fe31e 	bne	r3,zero,81131bb4 <__reset+0xfb111bb4>
81131c28:	60002b26 	beq	r12,zero,81131cd8 <__hexnan+0x1ac>
81131c2c:	2b40022e 	bgeu	r5,r13,81131c38 <__hexnan+0x10c>
81131c30:	008001c4 	movi	r2,7
81131c34:	11c0430e 	bge	r2,r7,81131d44 <__hexnan+0x218>
81131c38:	3140312e 	bgeu	r6,r5,81131d00 <__hexnan+0x1d4>
81131c3c:	3007883a 	mov	r3,r6
81131c40:	29000017 	ldw	r4,0(r5)
81131c44:	18800104 	addi	r2,r3,4
81131c48:	29400104 	addi	r5,r5,4
81131c4c:	19000015 	stw	r4,0(r3)
81131c50:	1007883a 	mov	r3,r2
81131c54:	597ffa2e 	bgeu	r11,r5,81131c40 <__reset+0xfb111c40>
81131c58:	10000015 	stw	zero,0(r2)
81131c5c:	10800104 	addi	r2,r2,4
81131c60:	58bffd2e 	bgeu	r11,r2,81131c58 <__reset+0xfb111c58>
81131c64:	78bfff17 	ldw	r2,-4(r15)
81131c68:	1000041e 	bne	r2,zero,81131c7c <__hexnan+0x150>
81131c6c:	32c02d26 	beq	r6,r11,81131d24 <__hexnan+0x1f8>
81131c70:	5affff04 	addi	r11,r11,-4
81131c74:	58800017 	ldw	r2,0(r11)
81131c78:	103ffc26 	beq	r2,zero,81131c6c <__reset+0xfb111c6c>
81131c7c:	00800144 	movi	r2,5
81131c80:	00001606 	br	81131cdc <__hexnan+0x1b0>
81131c84:	39c00044 	addi	r7,r7,1
81131c88:	63000044 	addi	r12,r12,1
81131c8c:	89c0040e 	bge	r17,r7,81131ca0 <__hexnan+0x174>
81131c90:	317fc52e 	bgeu	r6,r5,81131ba8 <__reset+0xfb111ba8>
81131c94:	283fff15 	stw	zero,-4(r5)
81131c98:	01c00044 	movi	r7,1
81131c9c:	297fff04 	addi	r5,r5,-4
81131ca0:	28c00017 	ldw	r3,0(r5)
81131ca4:	108003cc 	andi	r2,r2,15
81131ca8:	1806913a 	slli	r3,r3,4
81131cac:	1884b03a 	or	r2,r3,r2
81131cb0:	28800015 	stw	r2,0(r5)
81131cb4:	003fbc06 	br	81131ba8 <__reset+0xfb111ba8>
81131cb8:	2b7fff04 	addi	r13,r5,-4
81131cbc:	283fff15 	stw	zero,-4(r5)
81131cc0:	603f883a 	mov	ra,r12
81131cc4:	680b883a 	mov	r5,r13
81131cc8:	000f883a 	mov	r7,zero
81131ccc:	003fb606 	br	81131ba8 <__reset+0xfb111ba8>
81131cd0:	00800a44 	movi	r2,41
81131cd4:	18801726 	beq	r3,r2,81131d34 <__hexnan+0x208>
81131cd8:	00800104 	movi	r2,4
81131cdc:	dfc00617 	ldw	ra,24(sp)
81131ce0:	dd400517 	ldw	r21,20(sp)
81131ce4:	dd000417 	ldw	r20,16(sp)
81131ce8:	dcc00317 	ldw	r19,12(sp)
81131cec:	dc800217 	ldw	r18,8(sp)
81131cf0:	dc400117 	ldw	r17,4(sp)
81131cf4:	dc000017 	ldw	r16,0(sp)
81131cf8:	dec00704 	addi	sp,sp,28
81131cfc:	f800283a 	ret
81131d00:	903fd826 	beq	r18,zero,81131c64 <__reset+0xfb111c64>
81131d04:	00c00804 	movi	r3,32
81131d08:	1ca5c83a 	sub	r18,r3,r18
81131d0c:	00ffffc4 	movi	r3,-1
81131d10:	78bfff17 	ldw	r2,-4(r15)
81131d14:	1c86d83a 	srl	r3,r3,r18
81131d18:	1884703a 	and	r2,r3,r2
81131d1c:	78bfff15 	stw	r2,-4(r15)
81131d20:	003fd106 	br	81131c68 <__reset+0xfb111c68>
81131d24:	00800044 	movi	r2,1
81131d28:	58800015 	stw	r2,0(r11)
81131d2c:	00800144 	movi	r2,5
81131d30:	003fea06 	br	81131cdc <__reset+0xfb111cdc>
81131d34:	42000044 	addi	r8,r8,1
81131d38:	22000015 	stw	r8,0(r4)
81131d3c:	603fbb1e 	bne	r12,zero,81131c2c <__reset+0xfb111c2c>
81131d40:	003fe506 	br	81131cd8 <__reset+0xfb111cd8>
81131d44:	02400204 	movi	r9,8
81131d48:	49d3c83a 	sub	r9,r9,r7
81131d4c:	4a53883a 	add	r9,r9,r9
81131d50:	2a000017 	ldw	r8,0(r5)
81131d54:	4a53883a 	add	r9,r9,r9
81131d58:	02800804 	movi	r10,32
81131d5c:	5255c83a 	sub	r10,r10,r9
81131d60:	28c00104 	addi	r3,r5,4
81131d64:	2805883a 	mov	r2,r5
81131d68:	19c00017 	ldw	r7,0(r3)
81131d6c:	10800104 	addi	r2,r2,4
81131d70:	18c00104 	addi	r3,r3,4
81131d74:	3a88983a 	sll	r4,r7,r10
81131d78:	2208b03a 	or	r4,r4,r8
81131d7c:	3a50d83a 	srl	r8,r7,r9
81131d80:	113fff15 	stw	r4,-4(r2)
81131d84:	1a3fff15 	stw	r8,-4(r3)
81131d88:	137ff736 	bltu	r2,r13,81131d68 <__reset+0xfb111d68>
81131d8c:	003faa06 	br	81131c38 <__reset+0xfb111c38>

81131d90 <strncmp>:
81131d90:	30003126 	beq	r6,zero,81131e58 <strncmp+0xc8>
81131d94:	2144b03a 	or	r2,r4,r5
81131d98:	108000cc 	andi	r2,r2,3
81131d9c:	10001e1e 	bne	r2,zero,81131e18 <strncmp+0x88>
81131da0:	024000c4 	movi	r9,3
81131da4:	49801c2e 	bgeu	r9,r6,81131e18 <strncmp+0x88>
81131da8:	20800017 	ldw	r2,0(r4)
81131dac:	28c00017 	ldw	r3,0(r5)
81131db0:	10c0191e 	bne	r2,r3,81131e18 <strncmp+0x88>
81131db4:	31bfff04 	addi	r6,r6,-4
81131db8:	30002726 	beq	r6,zero,81131e58 <strncmp+0xc8>
81131dbc:	02ffbff4 	movhi	r11,65279
81131dc0:	5affbfc4 	addi	r11,r11,-257
81131dc4:	0086303a 	nor	r3,zero,r2
81131dc8:	02a02074 	movhi	r10,32897
81131dcc:	12c5883a 	add	r2,r2,r11
81131dd0:	52a02004 	addi	r10,r10,-32640
81131dd4:	10c4703a 	and	r2,r2,r3
81131dd8:	1284703a 	and	r2,r2,r10
81131ddc:	10000b26 	beq	r2,zero,81131e0c <strncmp+0x7c>
81131de0:	00001d06 	br	81131e58 <strncmp+0xc8>
81131de4:	20c00017 	ldw	r3,0(r4)
81131de8:	29c00017 	ldw	r7,0(r5)
81131dec:	1ad1883a 	add	r8,r3,r11
81131df0:	00c4303a 	nor	r2,zero,r3
81131df4:	4084703a 	and	r2,r8,r2
81131df8:	1284703a 	and	r2,r2,r10
81131dfc:	19c0061e 	bne	r3,r7,81131e18 <strncmp+0x88>
81131e00:	31bfff04 	addi	r6,r6,-4
81131e04:	30001426 	beq	r6,zero,81131e58 <strncmp+0xc8>
81131e08:	1000131e 	bne	r2,zero,81131e58 <strncmp+0xc8>
81131e0c:	21000104 	addi	r4,r4,4
81131e10:	29400104 	addi	r5,r5,4
81131e14:	49bff336 	bltu	r9,r6,81131de4 <__reset+0xfb111de4>
81131e18:	28800007 	ldb	r2,0(r5)
81131e1c:	20c00007 	ldb	r3,0(r4)
81131e20:	31bfffc4 	addi	r6,r6,-1
81131e24:	10c0081e 	bne	r2,r3,81131e48 <strncmp+0xb8>
81131e28:	30000b26 	beq	r6,zero,81131e58 <strncmp+0xc8>
81131e2c:	10000a26 	beq	r2,zero,81131e58 <strncmp+0xc8>
81131e30:	21000044 	addi	r4,r4,1
81131e34:	29400044 	addi	r5,r5,1
81131e38:	20800007 	ldb	r2,0(r4)
81131e3c:	28c00007 	ldb	r3,0(r5)
81131e40:	31bfffc4 	addi	r6,r6,-1
81131e44:	10fff826 	beq	r2,r3,81131e28 <__reset+0xfb111e28>
81131e48:	20800003 	ldbu	r2,0(r4)
81131e4c:	28c00003 	ldbu	r3,0(r5)
81131e50:	10c5c83a 	sub	r2,r2,r3
81131e54:	f800283a 	ret
81131e58:	0005883a 	mov	r2,zero
81131e5c:	f800283a 	ret

81131e60 <_wcrtomb_r>:
81131e60:	defff604 	addi	sp,sp,-40
81131e64:	00a04574 	movhi	r2,33045
81131e68:	de00012e 	bgeu	sp,et,81131e70 <_wcrtomb_r+0x10>
81131e6c:	003b68fa 	trap	3
81131e70:	1082cb04 	addi	r2,r2,2860
81131e74:	dc800815 	stw	r18,32(sp)
81131e78:	dc400715 	stw	r17,28(sp)
81131e7c:	dc000615 	stw	r16,24(sp)
81131e80:	dfc00915 	stw	ra,36(sp)
81131e84:	2021883a 	mov	r16,r4
81131e88:	3823883a 	mov	r17,r7
81131e8c:	14800017 	ldw	r18,0(r2)
81131e90:	28001426 	beq	r5,zero,81131ee4 <_wcrtomb_r+0x84>
81131e94:	d9400415 	stw	r5,16(sp)
81131e98:	d9800515 	stw	r6,20(sp)
81131e9c:	112a3900 	call	8112a390 <__locale_charset>
81131ea0:	d9800517 	ldw	r6,20(sp)
81131ea4:	d9400417 	ldw	r5,16(sp)
81131ea8:	100f883a 	mov	r7,r2
81131eac:	dc400015 	stw	r17,0(sp)
81131eb0:	8009883a 	mov	r4,r16
81131eb4:	903ee83a 	callr	r18
81131eb8:	00ffffc4 	movi	r3,-1
81131ebc:	10c0031e 	bne	r2,r3,81131ecc <_wcrtomb_r+0x6c>
81131ec0:	88000015 	stw	zero,0(r17)
81131ec4:	00c02284 	movi	r3,138
81131ec8:	80c00015 	stw	r3,0(r16)
81131ecc:	dfc00917 	ldw	ra,36(sp)
81131ed0:	dc800817 	ldw	r18,32(sp)
81131ed4:	dc400717 	ldw	r17,28(sp)
81131ed8:	dc000617 	ldw	r16,24(sp)
81131edc:	dec00a04 	addi	sp,sp,40
81131ee0:	f800283a 	ret
81131ee4:	112a3900 	call	8112a390 <__locale_charset>
81131ee8:	100f883a 	mov	r7,r2
81131eec:	dc400015 	stw	r17,0(sp)
81131ef0:	000d883a 	mov	r6,zero
81131ef4:	d9400104 	addi	r5,sp,4
81131ef8:	8009883a 	mov	r4,r16
81131efc:	903ee83a 	callr	r18
81131f00:	003fed06 	br	81131eb8 <__reset+0xfb111eb8>

81131f04 <wcrtomb>:
81131f04:	defff604 	addi	sp,sp,-40
81131f08:	00a04574 	movhi	r2,33045
81131f0c:	de00012e 	bgeu	sp,et,81131f14 <wcrtomb+0x10>
81131f10:	003b68fa 	trap	3
81131f14:	1082c604 	addi	r2,r2,2840
81131f18:	dc800615 	stw	r18,24(sp)
81131f1c:	dc400515 	stw	r17,20(sp)
81131f20:	dfc00915 	stw	ra,36(sp)
81131f24:	dd000815 	stw	r20,32(sp)
81131f28:	dcc00715 	stw	r19,28(sp)
81131f2c:	dc000415 	stw	r16,16(sp)
81131f30:	3025883a 	mov	r18,r6
81131f34:	14400017 	ldw	r17,0(r2)
81131f38:	20001926 	beq	r4,zero,81131fa0 <wcrtomb+0x9c>
81131f3c:	00a04574 	movhi	r2,33045
81131f40:	1082cb04 	addi	r2,r2,2860
81131f44:	15000017 	ldw	r20,0(r2)
81131f48:	2021883a 	mov	r16,r4
81131f4c:	2827883a 	mov	r19,r5
81131f50:	112a3900 	call	8112a390 <__locale_charset>
81131f54:	100f883a 	mov	r7,r2
81131f58:	dc800015 	stw	r18,0(sp)
81131f5c:	980d883a 	mov	r6,r19
81131f60:	800b883a 	mov	r5,r16
81131f64:	8809883a 	mov	r4,r17
81131f68:	a03ee83a 	callr	r20
81131f6c:	00ffffc4 	movi	r3,-1
81131f70:	10c0031e 	bne	r2,r3,81131f80 <wcrtomb+0x7c>
81131f74:	90000015 	stw	zero,0(r18)
81131f78:	00c02284 	movi	r3,138
81131f7c:	88c00015 	stw	r3,0(r17)
81131f80:	dfc00917 	ldw	ra,36(sp)
81131f84:	dd000817 	ldw	r20,32(sp)
81131f88:	dcc00717 	ldw	r19,28(sp)
81131f8c:	dc800617 	ldw	r18,24(sp)
81131f90:	dc400517 	ldw	r17,20(sp)
81131f94:	dc000417 	ldw	r16,16(sp)
81131f98:	dec00a04 	addi	sp,sp,40
81131f9c:	f800283a 	ret
81131fa0:	00a04574 	movhi	r2,33045
81131fa4:	1082cb04 	addi	r2,r2,2860
81131fa8:	14000017 	ldw	r16,0(r2)
81131fac:	112a3900 	call	8112a390 <__locale_charset>
81131fb0:	100f883a 	mov	r7,r2
81131fb4:	dc800015 	stw	r18,0(sp)
81131fb8:	000d883a 	mov	r6,zero
81131fbc:	d9400104 	addi	r5,sp,4
81131fc0:	8809883a 	mov	r4,r17
81131fc4:	803ee83a 	callr	r16
81131fc8:	003fe806 	br	81131f6c <__reset+0xfb111f6c>

81131fcc <__ascii_wctomb>:
81131fcc:	28000526 	beq	r5,zero,81131fe4 <__ascii_wctomb+0x18>
81131fd0:	00803fc4 	movi	r2,255
81131fd4:	11800536 	bltu	r2,r6,81131fec <__ascii_wctomb+0x20>
81131fd8:	29800005 	stb	r6,0(r5)
81131fdc:	00800044 	movi	r2,1
81131fe0:	f800283a 	ret
81131fe4:	0005883a 	mov	r2,zero
81131fe8:	f800283a 	ret
81131fec:	00802284 	movi	r2,138
81131ff0:	20800015 	stw	r2,0(r4)
81131ff4:	00bfffc4 	movi	r2,-1
81131ff8:	f800283a 	ret

81131ffc <_wctomb_r>:
81131ffc:	00a04574 	movhi	r2,33045
81132000:	defff904 	addi	sp,sp,-28
81132004:	1082cb04 	addi	r2,r2,2860
81132008:	de00012e 	bgeu	sp,et,81132010 <_wctomb_r+0x14>
8113200c:	003b68fa 	trap	3
81132010:	dfc00615 	stw	ra,24(sp)
81132014:	dc400515 	stw	r17,20(sp)
81132018:	dc000415 	stw	r16,16(sp)
8113201c:	3823883a 	mov	r17,r7
81132020:	14000017 	ldw	r16,0(r2)
81132024:	d9000115 	stw	r4,4(sp)
81132028:	d9400215 	stw	r5,8(sp)
8113202c:	d9800315 	stw	r6,12(sp)
81132030:	112a3900 	call	8112a390 <__locale_charset>
81132034:	d9800317 	ldw	r6,12(sp)
81132038:	d9400217 	ldw	r5,8(sp)
8113203c:	d9000117 	ldw	r4,4(sp)
81132040:	100f883a 	mov	r7,r2
81132044:	dc400015 	stw	r17,0(sp)
81132048:	803ee83a 	callr	r16
8113204c:	dfc00617 	ldw	ra,24(sp)
81132050:	dc400517 	ldw	r17,20(sp)
81132054:	dc000417 	ldw	r16,16(sp)
81132058:	dec00704 	addi	sp,sp,28
8113205c:	f800283a 	ret

81132060 <__udivdi3>:
81132060:	defff504 	addi	sp,sp,-44
81132064:	de00012e 	bgeu	sp,et,8113206c <__udivdi3+0xc>
81132068:	003b68fa 	trap	3
8113206c:	dcc00415 	stw	r19,16(sp)
81132070:	dc000115 	stw	r16,4(sp)
81132074:	dfc00a15 	stw	ra,40(sp)
81132078:	df000915 	stw	fp,36(sp)
8113207c:	ddc00815 	stw	r23,32(sp)
81132080:	dd800715 	stw	r22,28(sp)
81132084:	dd400615 	stw	r21,24(sp)
81132088:	dd000515 	stw	r20,20(sp)
8113208c:	dc800315 	stw	r18,12(sp)
81132090:	dc400215 	stw	r17,8(sp)
81132094:	2027883a 	mov	r19,r4
81132098:	2821883a 	mov	r16,r5
8113209c:	3800411e 	bne	r7,zero,811321a4 <__udivdi3+0x144>
811320a0:	3023883a 	mov	r17,r6
811320a4:	2025883a 	mov	r18,r4
811320a8:	2980522e 	bgeu	r5,r6,811321f4 <__udivdi3+0x194>
811320ac:	00bfffd4 	movui	r2,65535
811320b0:	282d883a 	mov	r22,r5
811320b4:	1180a836 	bltu	r2,r6,81132358 <__udivdi3+0x2f8>
811320b8:	00803fc4 	movi	r2,255
811320bc:	1185803a 	cmpltu	r2,r2,r6
811320c0:	100490fa 	slli	r2,r2,3
811320c4:	3086d83a 	srl	r3,r6,r2
811320c8:	01204574 	movhi	r4,33045
811320cc:	21380b04 	addi	r4,r4,-8148
811320d0:	20c7883a 	add	r3,r4,r3
811320d4:	18c00003 	ldbu	r3,0(r3)
811320d8:	1885883a 	add	r2,r3,r2
811320dc:	00c00804 	movi	r3,32
811320e0:	1887c83a 	sub	r3,r3,r2
811320e4:	18000526 	beq	r3,zero,811320fc <__udivdi3+0x9c>
811320e8:	80e0983a 	sll	r16,r16,r3
811320ec:	9884d83a 	srl	r2,r19,r2
811320f0:	30e2983a 	sll	r17,r6,r3
811320f4:	98e4983a 	sll	r18,r19,r3
811320f8:	142cb03a 	or	r22,r2,r16
811320fc:	882ad43a 	srli	r21,r17,16
81132100:	b009883a 	mov	r4,r22
81132104:	8d3fffcc 	andi	r20,r17,65535
81132108:	a80b883a 	mov	r5,r21
8113210c:	1132c7c0 	call	81132c7c <__umodsi3>
81132110:	b009883a 	mov	r4,r22
81132114:	a80b883a 	mov	r5,r21
81132118:	1027883a 	mov	r19,r2
8113211c:	1132c180 	call	81132c18 <__udivsi3>
81132120:	102d883a 	mov	r22,r2
81132124:	9826943a 	slli	r19,r19,16
81132128:	9004d43a 	srli	r2,r18,16
8113212c:	a5a1383a 	mul	r16,r20,r22
81132130:	14c4b03a 	or	r2,r2,r19
81132134:	1400052e 	bgeu	r2,r16,8113214c <__udivdi3+0xec>
81132138:	1445883a 	add	r2,r2,r17
8113213c:	b0ffffc4 	addi	r3,r22,-1
81132140:	14400136 	bltu	r2,r17,81132148 <__udivdi3+0xe8>
81132144:	14012336 	bltu	r2,r16,811325d4 <__udivdi3+0x574>
81132148:	182d883a 	mov	r22,r3
8113214c:	1421c83a 	sub	r16,r2,r16
81132150:	a80b883a 	mov	r5,r21
81132154:	8009883a 	mov	r4,r16
81132158:	1132c7c0 	call	81132c7c <__umodsi3>
8113215c:	1027883a 	mov	r19,r2
81132160:	a80b883a 	mov	r5,r21
81132164:	8009883a 	mov	r4,r16
81132168:	1132c180 	call	81132c18 <__udivsi3>
8113216c:	9826943a 	slli	r19,r19,16
81132170:	a0a9383a 	mul	r20,r20,r2
81132174:	94bfffcc 	andi	r18,r18,65535
81132178:	94e4b03a 	or	r18,r18,r19
8113217c:	9500052e 	bgeu	r18,r20,81132194 <__udivdi3+0x134>
81132180:	8ca5883a 	add	r18,r17,r18
81132184:	10ffffc4 	addi	r3,r2,-1
81132188:	9440f136 	bltu	r18,r17,81132550 <__udivdi3+0x4f0>
8113218c:	9500f02e 	bgeu	r18,r20,81132550 <__udivdi3+0x4f0>
81132190:	10bfff84 	addi	r2,r2,-2
81132194:	b00c943a 	slli	r6,r22,16
81132198:	0007883a 	mov	r3,zero
8113219c:	3084b03a 	or	r2,r6,r2
811321a0:	00005906 	br	81132308 <__udivdi3+0x2a8>
811321a4:	29c05636 	bltu	r5,r7,81132300 <__udivdi3+0x2a0>
811321a8:	00bfffd4 	movui	r2,65535
811321ac:	11c0622e 	bgeu	r2,r7,81132338 <__udivdi3+0x2d8>
811321b0:	00804034 	movhi	r2,256
811321b4:	10bfffc4 	addi	r2,r2,-1
811321b8:	11c0ee36 	bltu	r2,r7,81132574 <__udivdi3+0x514>
811321bc:	00800404 	movi	r2,16
811321c0:	3886d83a 	srl	r3,r7,r2
811321c4:	01204574 	movhi	r4,33045
811321c8:	21380b04 	addi	r4,r4,-8148
811321cc:	20c7883a 	add	r3,r4,r3
811321d0:	18c00003 	ldbu	r3,0(r3)
811321d4:	05400804 	movi	r21,32
811321d8:	1885883a 	add	r2,r3,r2
811321dc:	a8abc83a 	sub	r21,r21,r2
811321e0:	a800621e 	bne	r21,zero,8113236c <__udivdi3+0x30c>
811321e4:	3c00e936 	bltu	r7,r16,8113258c <__udivdi3+0x52c>
811321e8:	9985403a 	cmpgeu	r2,r19,r6
811321ec:	0007883a 	mov	r3,zero
811321f0:	00004506 	br	81132308 <__udivdi3+0x2a8>
811321f4:	3000041e 	bne	r6,zero,81132208 <__udivdi3+0x1a8>
811321f8:	000b883a 	mov	r5,zero
811321fc:	01000044 	movi	r4,1
81132200:	1132c180 	call	81132c18 <__udivsi3>
81132204:	1023883a 	mov	r17,r2
81132208:	00bfffd4 	movui	r2,65535
8113220c:	14404e2e 	bgeu	r2,r17,81132348 <__udivdi3+0x2e8>
81132210:	00804034 	movhi	r2,256
81132214:	10bfffc4 	addi	r2,r2,-1
81132218:	1440d836 	bltu	r2,r17,8113257c <__udivdi3+0x51c>
8113221c:	00800404 	movi	r2,16
81132220:	8886d83a 	srl	r3,r17,r2
81132224:	01204574 	movhi	r4,33045
81132228:	21380b04 	addi	r4,r4,-8148
8113222c:	20c7883a 	add	r3,r4,r3
81132230:	18c00003 	ldbu	r3,0(r3)
81132234:	1885883a 	add	r2,r3,r2
81132238:	00c00804 	movi	r3,32
8113223c:	1887c83a 	sub	r3,r3,r2
81132240:	18008f1e 	bne	r3,zero,81132480 <__udivdi3+0x420>
81132244:	882ad43a 	srli	r21,r17,16
81132248:	8461c83a 	sub	r16,r16,r17
8113224c:	8d3fffcc 	andi	r20,r17,65535
81132250:	00c00044 	movi	r3,1
81132254:	8009883a 	mov	r4,r16
81132258:	a80b883a 	mov	r5,r21
8113225c:	d8c00015 	stw	r3,0(sp)
81132260:	1132c7c0 	call	81132c7c <__umodsi3>
81132264:	8009883a 	mov	r4,r16
81132268:	a80b883a 	mov	r5,r21
8113226c:	1027883a 	mov	r19,r2
81132270:	1132c180 	call	81132c18 <__udivsi3>
81132274:	9826943a 	slli	r19,r19,16
81132278:	9008d43a 	srli	r4,r18,16
8113227c:	1521383a 	mul	r16,r2,r20
81132280:	102d883a 	mov	r22,r2
81132284:	24c8b03a 	or	r4,r4,r19
81132288:	d8c00017 	ldw	r3,0(sp)
8113228c:	2400052e 	bgeu	r4,r16,811322a4 <__udivdi3+0x244>
81132290:	2449883a 	add	r4,r4,r17
81132294:	b0bfffc4 	addi	r2,r22,-1
81132298:	24400136 	bltu	r4,r17,811322a0 <__udivdi3+0x240>
8113229c:	2400ca36 	bltu	r4,r16,811325c8 <__udivdi3+0x568>
811322a0:	102d883a 	mov	r22,r2
811322a4:	2421c83a 	sub	r16,r4,r16
811322a8:	a80b883a 	mov	r5,r21
811322ac:	8009883a 	mov	r4,r16
811322b0:	d8c00015 	stw	r3,0(sp)
811322b4:	1132c7c0 	call	81132c7c <__umodsi3>
811322b8:	1027883a 	mov	r19,r2
811322bc:	a80b883a 	mov	r5,r21
811322c0:	8009883a 	mov	r4,r16
811322c4:	1132c180 	call	81132c18 <__udivsi3>
811322c8:	9826943a 	slli	r19,r19,16
811322cc:	1529383a 	mul	r20,r2,r20
811322d0:	94bfffcc 	andi	r18,r18,65535
811322d4:	94e4b03a 	or	r18,r18,r19
811322d8:	d8c00017 	ldw	r3,0(sp)
811322dc:	9500052e 	bgeu	r18,r20,811322f4 <__udivdi3+0x294>
811322e0:	8ca5883a 	add	r18,r17,r18
811322e4:	113fffc4 	addi	r4,r2,-1
811322e8:	94409736 	bltu	r18,r17,81132548 <__udivdi3+0x4e8>
811322ec:	9500962e 	bgeu	r18,r20,81132548 <__udivdi3+0x4e8>
811322f0:	10bfff84 	addi	r2,r2,-2
811322f4:	b00c943a 	slli	r6,r22,16
811322f8:	3084b03a 	or	r2,r6,r2
811322fc:	00000206 	br	81132308 <__udivdi3+0x2a8>
81132300:	0007883a 	mov	r3,zero
81132304:	0005883a 	mov	r2,zero
81132308:	dfc00a17 	ldw	ra,40(sp)
8113230c:	df000917 	ldw	fp,36(sp)
81132310:	ddc00817 	ldw	r23,32(sp)
81132314:	dd800717 	ldw	r22,28(sp)
81132318:	dd400617 	ldw	r21,24(sp)
8113231c:	dd000517 	ldw	r20,20(sp)
81132320:	dcc00417 	ldw	r19,16(sp)
81132324:	dc800317 	ldw	r18,12(sp)
81132328:	dc400217 	ldw	r17,8(sp)
8113232c:	dc000117 	ldw	r16,4(sp)
81132330:	dec00b04 	addi	sp,sp,44
81132334:	f800283a 	ret
81132338:	00803fc4 	movi	r2,255
8113233c:	11c5803a 	cmpltu	r2,r2,r7
81132340:	100490fa 	slli	r2,r2,3
81132344:	003f9e06 	br	811321c0 <__reset+0xfb1121c0>
81132348:	00803fc4 	movi	r2,255
8113234c:	1445803a 	cmpltu	r2,r2,r17
81132350:	100490fa 	slli	r2,r2,3
81132354:	003fb206 	br	81132220 <__reset+0xfb112220>
81132358:	00804034 	movhi	r2,256
8113235c:	10bfffc4 	addi	r2,r2,-1
81132360:	11808836 	bltu	r2,r6,81132584 <__udivdi3+0x524>
81132364:	00800404 	movi	r2,16
81132368:	003f5606 	br	811320c4 <__reset+0xfb1120c4>
8113236c:	30aed83a 	srl	r23,r6,r2
81132370:	3d4e983a 	sll	r7,r7,r21
81132374:	80acd83a 	srl	r22,r16,r2
81132378:	9884d83a 	srl	r2,r19,r2
8113237c:	3deeb03a 	or	r23,r7,r23
81132380:	b824d43a 	srli	r18,r23,16
81132384:	8560983a 	sll	r16,r16,r21
81132388:	b009883a 	mov	r4,r22
8113238c:	900b883a 	mov	r5,r18
81132390:	3568983a 	sll	r20,r6,r21
81132394:	1420b03a 	or	r16,r2,r16
81132398:	1132c7c0 	call	81132c7c <__umodsi3>
8113239c:	b009883a 	mov	r4,r22
811323a0:	900b883a 	mov	r5,r18
811323a4:	1023883a 	mov	r17,r2
811323a8:	1132c180 	call	81132c18 <__udivsi3>
811323ac:	8808943a 	slli	r4,r17,16
811323b0:	bf3fffcc 	andi	fp,r23,65535
811323b4:	8006d43a 	srli	r3,r16,16
811323b8:	e0a3383a 	mul	r17,fp,r2
811323bc:	100d883a 	mov	r6,r2
811323c0:	1906b03a 	or	r3,r3,r4
811323c4:	1c40042e 	bgeu	r3,r17,811323d8 <__udivdi3+0x378>
811323c8:	1dc7883a 	add	r3,r3,r23
811323cc:	10bfffc4 	addi	r2,r2,-1
811323d0:	1dc0752e 	bgeu	r3,r23,811325a8 <__udivdi3+0x548>
811323d4:	100d883a 	mov	r6,r2
811323d8:	1c63c83a 	sub	r17,r3,r17
811323dc:	900b883a 	mov	r5,r18
811323e0:	8809883a 	mov	r4,r17
811323e4:	d9800015 	stw	r6,0(sp)
811323e8:	1132c7c0 	call	81132c7c <__umodsi3>
811323ec:	102d883a 	mov	r22,r2
811323f0:	8809883a 	mov	r4,r17
811323f4:	900b883a 	mov	r5,r18
811323f8:	1132c180 	call	81132c18 <__udivsi3>
811323fc:	b02c943a 	slli	r22,r22,16
81132400:	e089383a 	mul	r4,fp,r2
81132404:	843fffcc 	andi	r16,r16,65535
81132408:	85a0b03a 	or	r16,r16,r22
8113240c:	d9800017 	ldw	r6,0(sp)
81132410:	8100042e 	bgeu	r16,r4,81132424 <__udivdi3+0x3c4>
81132414:	85e1883a 	add	r16,r16,r23
81132418:	10ffffc4 	addi	r3,r2,-1
8113241c:	85c05e2e 	bgeu	r16,r23,81132598 <__udivdi3+0x538>
81132420:	1805883a 	mov	r2,r3
81132424:	300c943a 	slli	r6,r6,16
81132428:	a17fffcc 	andi	r5,r20,65535
8113242c:	a028d43a 	srli	r20,r20,16
81132430:	3084b03a 	or	r2,r6,r2
81132434:	10ffffcc 	andi	r3,r2,65535
81132438:	100cd43a 	srli	r6,r2,16
8113243c:	194f383a 	mul	r7,r3,r5
81132440:	1d07383a 	mul	r3,r3,r20
81132444:	314b383a 	mul	r5,r6,r5
81132448:	3810d43a 	srli	r8,r7,16
8113244c:	8121c83a 	sub	r16,r16,r4
81132450:	1947883a 	add	r3,r3,r5
81132454:	40c7883a 	add	r3,r8,r3
81132458:	350d383a 	mul	r6,r6,r20
8113245c:	1940022e 	bgeu	r3,r5,81132468 <__udivdi3+0x408>
81132460:	01000074 	movhi	r4,1
81132464:	310d883a 	add	r6,r6,r4
81132468:	1828d43a 	srli	r20,r3,16
8113246c:	a18d883a 	add	r6,r20,r6
81132470:	81803e36 	bltu	r16,r6,8113256c <__udivdi3+0x50c>
81132474:	81803826 	beq	r16,r6,81132558 <__udivdi3+0x4f8>
81132478:	0007883a 	mov	r3,zero
8113247c:	003fa206 	br	81132308 <__reset+0xfb112308>
81132480:	88e2983a 	sll	r17,r17,r3
81132484:	80a8d83a 	srl	r20,r16,r2
81132488:	80e0983a 	sll	r16,r16,r3
8113248c:	882ad43a 	srli	r21,r17,16
81132490:	9884d83a 	srl	r2,r19,r2
81132494:	a009883a 	mov	r4,r20
81132498:	a80b883a 	mov	r5,r21
8113249c:	142eb03a 	or	r23,r2,r16
811324a0:	98e4983a 	sll	r18,r19,r3
811324a4:	1132c7c0 	call	81132c7c <__umodsi3>
811324a8:	a009883a 	mov	r4,r20
811324ac:	a80b883a 	mov	r5,r21
811324b0:	1021883a 	mov	r16,r2
811324b4:	1132c180 	call	81132c18 <__udivsi3>
811324b8:	1039883a 	mov	fp,r2
811324bc:	8d3fffcc 	andi	r20,r17,65535
811324c0:	8020943a 	slli	r16,r16,16
811324c4:	b804d43a 	srli	r2,r23,16
811324c8:	a72d383a 	mul	r22,r20,fp
811324cc:	1404b03a 	or	r2,r2,r16
811324d0:	1580062e 	bgeu	r2,r22,811324ec <__udivdi3+0x48c>
811324d4:	1445883a 	add	r2,r2,r17
811324d8:	e0ffffc4 	addi	r3,fp,-1
811324dc:	14403836 	bltu	r2,r17,811325c0 <__udivdi3+0x560>
811324e0:	1580372e 	bgeu	r2,r22,811325c0 <__udivdi3+0x560>
811324e4:	e73fff84 	addi	fp,fp,-2
811324e8:	1445883a 	add	r2,r2,r17
811324ec:	15adc83a 	sub	r22,r2,r22
811324f0:	a80b883a 	mov	r5,r21
811324f4:	b009883a 	mov	r4,r22
811324f8:	1132c7c0 	call	81132c7c <__umodsi3>
811324fc:	1027883a 	mov	r19,r2
81132500:	b009883a 	mov	r4,r22
81132504:	a80b883a 	mov	r5,r21
81132508:	1132c180 	call	81132c18 <__udivsi3>
8113250c:	9826943a 	slli	r19,r19,16
81132510:	a0a1383a 	mul	r16,r20,r2
81132514:	b93fffcc 	andi	r4,r23,65535
81132518:	24c8b03a 	or	r4,r4,r19
8113251c:	2400062e 	bgeu	r4,r16,81132538 <__udivdi3+0x4d8>
81132520:	2449883a 	add	r4,r4,r17
81132524:	10ffffc4 	addi	r3,r2,-1
81132528:	24402336 	bltu	r4,r17,811325b8 <__udivdi3+0x558>
8113252c:	2400222e 	bgeu	r4,r16,811325b8 <__udivdi3+0x558>
81132530:	10bfff84 	addi	r2,r2,-2
81132534:	2449883a 	add	r4,r4,r17
81132538:	e038943a 	slli	fp,fp,16
8113253c:	2421c83a 	sub	r16,r4,r16
81132540:	e086b03a 	or	r3,fp,r2
81132544:	003f4306 	br	81132254 <__reset+0xfb112254>
81132548:	2005883a 	mov	r2,r4
8113254c:	003f6906 	br	811322f4 <__reset+0xfb1122f4>
81132550:	1805883a 	mov	r2,r3
81132554:	003f0f06 	br	81132194 <__reset+0xfb112194>
81132558:	1806943a 	slli	r3,r3,16
8113255c:	9d66983a 	sll	r19,r19,r21
81132560:	39ffffcc 	andi	r7,r7,65535
81132564:	19c7883a 	add	r3,r3,r7
81132568:	98ffc32e 	bgeu	r19,r3,81132478 <__reset+0xfb112478>
8113256c:	10bfffc4 	addi	r2,r2,-1
81132570:	003fc106 	br	81132478 <__reset+0xfb112478>
81132574:	00800604 	movi	r2,24
81132578:	003f1106 	br	811321c0 <__reset+0xfb1121c0>
8113257c:	00800604 	movi	r2,24
81132580:	003f2706 	br	81132220 <__reset+0xfb112220>
81132584:	00800604 	movi	r2,24
81132588:	003ece06 	br	811320c4 <__reset+0xfb1120c4>
8113258c:	0007883a 	mov	r3,zero
81132590:	00800044 	movi	r2,1
81132594:	003f5c06 	br	81132308 <__reset+0xfb112308>
81132598:	813fa12e 	bgeu	r16,r4,81132420 <__reset+0xfb112420>
8113259c:	10bfff84 	addi	r2,r2,-2
811325a0:	85e1883a 	add	r16,r16,r23
811325a4:	003f9f06 	br	81132424 <__reset+0xfb112424>
811325a8:	1c7f8a2e 	bgeu	r3,r17,811323d4 <__reset+0xfb1123d4>
811325ac:	31bfff84 	addi	r6,r6,-2
811325b0:	1dc7883a 	add	r3,r3,r23
811325b4:	003f8806 	br	811323d8 <__reset+0xfb1123d8>
811325b8:	1805883a 	mov	r2,r3
811325bc:	003fde06 	br	81132538 <__reset+0xfb112538>
811325c0:	1839883a 	mov	fp,r3
811325c4:	003fc906 	br	811324ec <__reset+0xfb1124ec>
811325c8:	b5bfff84 	addi	r22,r22,-2
811325cc:	2449883a 	add	r4,r4,r17
811325d0:	003f3406 	br	811322a4 <__reset+0xfb1122a4>
811325d4:	b5bfff84 	addi	r22,r22,-2
811325d8:	1445883a 	add	r2,r2,r17
811325dc:	003edb06 	br	8113214c <__reset+0xfb11214c>

811325e0 <__umoddi3>:
811325e0:	defff404 	addi	sp,sp,-48
811325e4:	de00012e 	bgeu	sp,et,811325ec <__umoddi3+0xc>
811325e8:	003b68fa 	trap	3
811325ec:	df000a15 	stw	fp,40(sp)
811325f0:	dc400315 	stw	r17,12(sp)
811325f4:	dc000215 	stw	r16,8(sp)
811325f8:	dfc00b15 	stw	ra,44(sp)
811325fc:	ddc00915 	stw	r23,36(sp)
81132600:	dd800815 	stw	r22,32(sp)
81132604:	dd400715 	stw	r21,28(sp)
81132608:	dd000615 	stw	r20,24(sp)
8113260c:	dcc00515 	stw	r19,20(sp)
81132610:	dc800415 	stw	r18,16(sp)
81132614:	2021883a 	mov	r16,r4
81132618:	2823883a 	mov	r17,r5
8113261c:	2839883a 	mov	fp,r5
81132620:	38003c1e 	bne	r7,zero,81132714 <__umoddi3+0x134>
81132624:	3027883a 	mov	r19,r6
81132628:	2029883a 	mov	r20,r4
8113262c:	2980512e 	bgeu	r5,r6,81132774 <__umoddi3+0x194>
81132630:	00bfffd4 	movui	r2,65535
81132634:	11809a36 	bltu	r2,r6,811328a0 <__umoddi3+0x2c0>
81132638:	01003fc4 	movi	r4,255
8113263c:	2189803a 	cmpltu	r4,r4,r6
81132640:	200890fa 	slli	r4,r4,3
81132644:	3104d83a 	srl	r2,r6,r4
81132648:	00e04574 	movhi	r3,33045
8113264c:	18f80b04 	addi	r3,r3,-8148
81132650:	1885883a 	add	r2,r3,r2
81132654:	10c00003 	ldbu	r3,0(r2)
81132658:	00800804 	movi	r2,32
8113265c:	1909883a 	add	r4,r3,r4
81132660:	1125c83a 	sub	r18,r2,r4
81132664:	90000526 	beq	r18,zero,8113267c <__umoddi3+0x9c>
81132668:	8ca2983a 	sll	r17,r17,r18
8113266c:	8108d83a 	srl	r4,r16,r4
81132670:	34a6983a 	sll	r19,r6,r18
81132674:	84a8983a 	sll	r20,r16,r18
81132678:	2478b03a 	or	fp,r4,r17
8113267c:	982ed43a 	srli	r23,r19,16
81132680:	e009883a 	mov	r4,fp
81132684:	9dbfffcc 	andi	r22,r19,65535
81132688:	b80b883a 	mov	r5,r23
8113268c:	1132c7c0 	call	81132c7c <__umodsi3>
81132690:	e009883a 	mov	r4,fp
81132694:	b80b883a 	mov	r5,r23
81132698:	102b883a 	mov	r21,r2
8113269c:	1132c180 	call	81132c18 <__udivsi3>
811326a0:	a806943a 	slli	r3,r21,16
811326a4:	a008d43a 	srli	r4,r20,16
811326a8:	b085383a 	mul	r2,r22,r2
811326ac:	20c8b03a 	or	r4,r4,r3
811326b0:	2080032e 	bgeu	r4,r2,811326c0 <__umoddi3+0xe0>
811326b4:	24c9883a 	add	r4,r4,r19
811326b8:	24c00136 	bltu	r4,r19,811326c0 <__umoddi3+0xe0>
811326bc:	20811036 	bltu	r4,r2,81132b00 <__umoddi3+0x520>
811326c0:	20abc83a 	sub	r21,r4,r2
811326c4:	b80b883a 	mov	r5,r23
811326c8:	a809883a 	mov	r4,r21
811326cc:	1132c7c0 	call	81132c7c <__umodsi3>
811326d0:	1023883a 	mov	r17,r2
811326d4:	b80b883a 	mov	r5,r23
811326d8:	a809883a 	mov	r4,r21
811326dc:	1132c180 	call	81132c18 <__udivsi3>
811326e0:	8822943a 	slli	r17,r17,16
811326e4:	b085383a 	mul	r2,r22,r2
811326e8:	a0ffffcc 	andi	r3,r20,65535
811326ec:	1c46b03a 	or	r3,r3,r17
811326f0:	1880042e 	bgeu	r3,r2,81132704 <__umoddi3+0x124>
811326f4:	1cc7883a 	add	r3,r3,r19
811326f8:	1cc00236 	bltu	r3,r19,81132704 <__umoddi3+0x124>
811326fc:	1880012e 	bgeu	r3,r2,81132704 <__umoddi3+0x124>
81132700:	1cc7883a 	add	r3,r3,r19
81132704:	1885c83a 	sub	r2,r3,r2
81132708:	1484d83a 	srl	r2,r2,r18
8113270c:	0007883a 	mov	r3,zero
81132710:	00004f06 	br	81132850 <__umoddi3+0x270>
81132714:	29c04c36 	bltu	r5,r7,81132848 <__umoddi3+0x268>
81132718:	00bfffd4 	movui	r2,65535
8113271c:	11c0582e 	bgeu	r2,r7,81132880 <__umoddi3+0x2a0>
81132720:	00804034 	movhi	r2,256
81132724:	10bfffc4 	addi	r2,r2,-1
81132728:	11c0e736 	bltu	r2,r7,81132ac8 <__umoddi3+0x4e8>
8113272c:	01000404 	movi	r4,16
81132730:	3904d83a 	srl	r2,r7,r4
81132734:	00e04574 	movhi	r3,33045
81132738:	18f80b04 	addi	r3,r3,-8148
8113273c:	1885883a 	add	r2,r3,r2
81132740:	14c00003 	ldbu	r19,0(r2)
81132744:	00c00804 	movi	r3,32
81132748:	9927883a 	add	r19,r19,r4
8113274c:	1ce9c83a 	sub	r20,r3,r19
81132750:	a000581e 	bne	r20,zero,811328b4 <__umoddi3+0x2d4>
81132754:	3c400136 	bltu	r7,r17,8113275c <__umoddi3+0x17c>
81132758:	8180eb36 	bltu	r16,r6,81132b08 <__umoddi3+0x528>
8113275c:	8185c83a 	sub	r2,r16,r6
81132760:	89e3c83a 	sub	r17,r17,r7
81132764:	8089803a 	cmpltu	r4,r16,r2
81132768:	8939c83a 	sub	fp,r17,r4
8113276c:	e007883a 	mov	r3,fp
81132770:	00003706 	br	81132850 <__umoddi3+0x270>
81132774:	3000041e 	bne	r6,zero,81132788 <__umoddi3+0x1a8>
81132778:	000b883a 	mov	r5,zero
8113277c:	01000044 	movi	r4,1
81132780:	1132c180 	call	81132c18 <__udivsi3>
81132784:	1027883a 	mov	r19,r2
81132788:	00bfffd4 	movui	r2,65535
8113278c:	14c0402e 	bgeu	r2,r19,81132890 <__umoddi3+0x2b0>
81132790:	00804034 	movhi	r2,256
81132794:	10bfffc4 	addi	r2,r2,-1
81132798:	14c0cd36 	bltu	r2,r19,81132ad0 <__umoddi3+0x4f0>
8113279c:	00800404 	movi	r2,16
811327a0:	9886d83a 	srl	r3,r19,r2
811327a4:	01204574 	movhi	r4,33045
811327a8:	21380b04 	addi	r4,r4,-8148
811327ac:	20c7883a 	add	r3,r4,r3
811327b0:	18c00003 	ldbu	r3,0(r3)
811327b4:	1887883a 	add	r3,r3,r2
811327b8:	00800804 	movi	r2,32
811327bc:	10e5c83a 	sub	r18,r2,r3
811327c0:	9000901e 	bne	r18,zero,81132a04 <__umoddi3+0x424>
811327c4:	982cd43a 	srli	r22,r19,16
811327c8:	8ce3c83a 	sub	r17,r17,r19
811327cc:	9d7fffcc 	andi	r21,r19,65535
811327d0:	b00b883a 	mov	r5,r22
811327d4:	8809883a 	mov	r4,r17
811327d8:	1132c7c0 	call	81132c7c <__umodsi3>
811327dc:	8809883a 	mov	r4,r17
811327e0:	b00b883a 	mov	r5,r22
811327e4:	1021883a 	mov	r16,r2
811327e8:	1132c180 	call	81132c18 <__udivsi3>
811327ec:	8006943a 	slli	r3,r16,16
811327f0:	a008d43a 	srli	r4,r20,16
811327f4:	1545383a 	mul	r2,r2,r21
811327f8:	20c8b03a 	or	r4,r4,r3
811327fc:	2080042e 	bgeu	r4,r2,81132810 <__umoddi3+0x230>
81132800:	24c9883a 	add	r4,r4,r19
81132804:	24c00236 	bltu	r4,r19,81132810 <__umoddi3+0x230>
81132808:	2080012e 	bgeu	r4,r2,81132810 <__umoddi3+0x230>
8113280c:	24c9883a 	add	r4,r4,r19
81132810:	20a1c83a 	sub	r16,r4,r2
81132814:	b00b883a 	mov	r5,r22
81132818:	8009883a 	mov	r4,r16
8113281c:	1132c7c0 	call	81132c7c <__umodsi3>
81132820:	1023883a 	mov	r17,r2
81132824:	b00b883a 	mov	r5,r22
81132828:	8009883a 	mov	r4,r16
8113282c:	1132c180 	call	81132c18 <__udivsi3>
81132830:	8822943a 	slli	r17,r17,16
81132834:	1545383a 	mul	r2,r2,r21
81132838:	a53fffcc 	andi	r20,r20,65535
8113283c:	a446b03a 	or	r3,r20,r17
81132840:	18bfb02e 	bgeu	r3,r2,81132704 <__reset+0xfb112704>
81132844:	003fab06 	br	811326f4 <__reset+0xfb1126f4>
81132848:	2005883a 	mov	r2,r4
8113284c:	2807883a 	mov	r3,r5
81132850:	dfc00b17 	ldw	ra,44(sp)
81132854:	df000a17 	ldw	fp,40(sp)
81132858:	ddc00917 	ldw	r23,36(sp)
8113285c:	dd800817 	ldw	r22,32(sp)
81132860:	dd400717 	ldw	r21,28(sp)
81132864:	dd000617 	ldw	r20,24(sp)
81132868:	dcc00517 	ldw	r19,20(sp)
8113286c:	dc800417 	ldw	r18,16(sp)
81132870:	dc400317 	ldw	r17,12(sp)
81132874:	dc000217 	ldw	r16,8(sp)
81132878:	dec00c04 	addi	sp,sp,48
8113287c:	f800283a 	ret
81132880:	04c03fc4 	movi	r19,255
81132884:	99c9803a 	cmpltu	r4,r19,r7
81132888:	200890fa 	slli	r4,r4,3
8113288c:	003fa806 	br	81132730 <__reset+0xfb112730>
81132890:	00803fc4 	movi	r2,255
81132894:	14c5803a 	cmpltu	r2,r2,r19
81132898:	100490fa 	slli	r2,r2,3
8113289c:	003fc006 	br	811327a0 <__reset+0xfb1127a0>
811328a0:	00804034 	movhi	r2,256
811328a4:	10bfffc4 	addi	r2,r2,-1
811328a8:	11808b36 	bltu	r2,r6,81132ad8 <__umoddi3+0x4f8>
811328ac:	01000404 	movi	r4,16
811328b0:	003f6406 	br	81132644 <__reset+0xfb112644>
811328b4:	34c4d83a 	srl	r2,r6,r19
811328b8:	3d0e983a 	sll	r7,r7,r20
811328bc:	8cf8d83a 	srl	fp,r17,r19
811328c0:	8d10983a 	sll	r8,r17,r20
811328c4:	38aab03a 	or	r21,r7,r2
811328c8:	a82cd43a 	srli	r22,r21,16
811328cc:	84e2d83a 	srl	r17,r16,r19
811328d0:	e009883a 	mov	r4,fp
811328d4:	b00b883a 	mov	r5,r22
811328d8:	8a22b03a 	or	r17,r17,r8
811328dc:	3524983a 	sll	r18,r6,r20
811328e0:	1132c7c0 	call	81132c7c <__umodsi3>
811328e4:	e009883a 	mov	r4,fp
811328e8:	b00b883a 	mov	r5,r22
811328ec:	102f883a 	mov	r23,r2
811328f0:	1132c180 	call	81132c18 <__udivsi3>
811328f4:	100d883a 	mov	r6,r2
811328f8:	b808943a 	slli	r4,r23,16
811328fc:	aa3fffcc 	andi	r8,r21,65535
81132900:	8804d43a 	srli	r2,r17,16
81132904:	41af383a 	mul	r23,r8,r6
81132908:	8520983a 	sll	r16,r16,r20
8113290c:	1104b03a 	or	r2,r2,r4
81132910:	15c0042e 	bgeu	r2,r23,81132924 <__umoddi3+0x344>
81132914:	1545883a 	add	r2,r2,r21
81132918:	30ffffc4 	addi	r3,r6,-1
8113291c:	1540742e 	bgeu	r2,r21,81132af0 <__umoddi3+0x510>
81132920:	180d883a 	mov	r6,r3
81132924:	15efc83a 	sub	r23,r2,r23
81132928:	b00b883a 	mov	r5,r22
8113292c:	b809883a 	mov	r4,r23
81132930:	d9800115 	stw	r6,4(sp)
81132934:	da000015 	stw	r8,0(sp)
81132938:	1132c7c0 	call	81132c7c <__umodsi3>
8113293c:	b00b883a 	mov	r5,r22
81132940:	b809883a 	mov	r4,r23
81132944:	1039883a 	mov	fp,r2
81132948:	1132c180 	call	81132c18 <__udivsi3>
8113294c:	da000017 	ldw	r8,0(sp)
81132950:	e038943a 	slli	fp,fp,16
81132954:	100b883a 	mov	r5,r2
81132958:	4089383a 	mul	r4,r8,r2
8113295c:	8a3fffcc 	andi	r8,r17,65535
81132960:	4710b03a 	or	r8,r8,fp
81132964:	d9800117 	ldw	r6,4(sp)
81132968:	4100042e 	bgeu	r8,r4,8113297c <__umoddi3+0x39c>
8113296c:	4551883a 	add	r8,r8,r21
81132970:	10bfffc4 	addi	r2,r2,-1
81132974:	45405a2e 	bgeu	r8,r21,81132ae0 <__umoddi3+0x500>
81132978:	100b883a 	mov	r5,r2
8113297c:	300c943a 	slli	r6,r6,16
81132980:	91ffffcc 	andi	r7,r18,65535
81132984:	9004d43a 	srli	r2,r18,16
81132988:	314cb03a 	or	r6,r6,r5
8113298c:	317fffcc 	andi	r5,r6,65535
81132990:	300cd43a 	srli	r6,r6,16
81132994:	29d3383a 	mul	r9,r5,r7
81132998:	288b383a 	mul	r5,r5,r2
8113299c:	31cf383a 	mul	r7,r6,r7
811329a0:	4806d43a 	srli	r3,r9,16
811329a4:	4111c83a 	sub	r8,r8,r4
811329a8:	29cb883a 	add	r5,r5,r7
811329ac:	194b883a 	add	r5,r3,r5
811329b0:	3085383a 	mul	r2,r6,r2
811329b4:	29c0022e 	bgeu	r5,r7,811329c0 <__umoddi3+0x3e0>
811329b8:	00c00074 	movhi	r3,1
811329bc:	10c5883a 	add	r2,r2,r3
811329c0:	2808d43a 	srli	r4,r5,16
811329c4:	280a943a 	slli	r5,r5,16
811329c8:	4a7fffcc 	andi	r9,r9,65535
811329cc:	2085883a 	add	r2,r4,r2
811329d0:	2a4b883a 	add	r5,r5,r9
811329d4:	40803636 	bltu	r8,r2,81132ab0 <__umoddi3+0x4d0>
811329d8:	40804d26 	beq	r8,r2,81132b10 <__umoddi3+0x530>
811329dc:	4089c83a 	sub	r4,r8,r2
811329e0:	280f883a 	mov	r7,r5
811329e4:	81cfc83a 	sub	r7,r16,r7
811329e8:	81c7803a 	cmpltu	r3,r16,r7
811329ec:	20c7c83a 	sub	r3,r4,r3
811329f0:	1cc4983a 	sll	r2,r3,r19
811329f4:	3d0ed83a 	srl	r7,r7,r20
811329f8:	1d06d83a 	srl	r3,r3,r20
811329fc:	11c4b03a 	or	r2,r2,r7
81132a00:	003f9306 	br	81132850 <__reset+0xfb112850>
81132a04:	9ca6983a 	sll	r19,r19,r18
81132a08:	88e8d83a 	srl	r20,r17,r3
81132a0c:	80c4d83a 	srl	r2,r16,r3
81132a10:	982cd43a 	srli	r22,r19,16
81132a14:	8ca2983a 	sll	r17,r17,r18
81132a18:	a009883a 	mov	r4,r20
81132a1c:	b00b883a 	mov	r5,r22
81132a20:	1478b03a 	or	fp,r2,r17
81132a24:	1132c7c0 	call	81132c7c <__umodsi3>
81132a28:	a009883a 	mov	r4,r20
81132a2c:	b00b883a 	mov	r5,r22
81132a30:	1023883a 	mov	r17,r2
81132a34:	1132c180 	call	81132c18 <__udivsi3>
81132a38:	9d7fffcc 	andi	r21,r19,65535
81132a3c:	880a943a 	slli	r5,r17,16
81132a40:	e008d43a 	srli	r4,fp,16
81132a44:	a885383a 	mul	r2,r21,r2
81132a48:	84a8983a 	sll	r20,r16,r18
81132a4c:	2148b03a 	or	r4,r4,r5
81132a50:	2080042e 	bgeu	r4,r2,81132a64 <__umoddi3+0x484>
81132a54:	24c9883a 	add	r4,r4,r19
81132a58:	24c00236 	bltu	r4,r19,81132a64 <__umoddi3+0x484>
81132a5c:	2080012e 	bgeu	r4,r2,81132a64 <__umoddi3+0x484>
81132a60:	24c9883a 	add	r4,r4,r19
81132a64:	20a3c83a 	sub	r17,r4,r2
81132a68:	b00b883a 	mov	r5,r22
81132a6c:	8809883a 	mov	r4,r17
81132a70:	1132c7c0 	call	81132c7c <__umodsi3>
81132a74:	102f883a 	mov	r23,r2
81132a78:	8809883a 	mov	r4,r17
81132a7c:	b00b883a 	mov	r5,r22
81132a80:	1132c180 	call	81132c18 <__udivsi3>
81132a84:	b82e943a 	slli	r23,r23,16
81132a88:	a885383a 	mul	r2,r21,r2
81132a8c:	e13fffcc 	andi	r4,fp,65535
81132a90:	25c8b03a 	or	r4,r4,r23
81132a94:	2080042e 	bgeu	r4,r2,81132aa8 <__umoddi3+0x4c8>
81132a98:	24c9883a 	add	r4,r4,r19
81132a9c:	24c00236 	bltu	r4,r19,81132aa8 <__umoddi3+0x4c8>
81132aa0:	2080012e 	bgeu	r4,r2,81132aa8 <__umoddi3+0x4c8>
81132aa4:	24c9883a 	add	r4,r4,r19
81132aa8:	20a3c83a 	sub	r17,r4,r2
81132aac:	003f4806 	br	811327d0 <__reset+0xfb1127d0>
81132ab0:	2c8fc83a 	sub	r7,r5,r18
81132ab4:	1545c83a 	sub	r2,r2,r21
81132ab8:	29cb803a 	cmpltu	r5,r5,r7
81132abc:	1145c83a 	sub	r2,r2,r5
81132ac0:	4089c83a 	sub	r4,r8,r2
81132ac4:	003fc706 	br	811329e4 <__reset+0xfb1129e4>
81132ac8:	01000604 	movi	r4,24
81132acc:	003f1806 	br	81132730 <__reset+0xfb112730>
81132ad0:	00800604 	movi	r2,24
81132ad4:	003f3206 	br	811327a0 <__reset+0xfb1127a0>
81132ad8:	01000604 	movi	r4,24
81132adc:	003ed906 	br	81132644 <__reset+0xfb112644>
81132ae0:	413fa52e 	bgeu	r8,r4,81132978 <__reset+0xfb112978>
81132ae4:	297fff84 	addi	r5,r5,-2
81132ae8:	4551883a 	add	r8,r8,r21
81132aec:	003fa306 	br	8113297c <__reset+0xfb11297c>
81132af0:	15ff8b2e 	bgeu	r2,r23,81132920 <__reset+0xfb112920>
81132af4:	31bfff84 	addi	r6,r6,-2
81132af8:	1545883a 	add	r2,r2,r21
81132afc:	003f8906 	br	81132924 <__reset+0xfb112924>
81132b00:	24c9883a 	add	r4,r4,r19
81132b04:	003eee06 	br	811326c0 <__reset+0xfb1126c0>
81132b08:	8005883a 	mov	r2,r16
81132b0c:	003f1706 	br	8113276c <__reset+0xfb11276c>
81132b10:	817fe736 	bltu	r16,r5,81132ab0 <__reset+0xfb112ab0>
81132b14:	280f883a 	mov	r7,r5
81132b18:	0009883a 	mov	r4,zero
81132b1c:	003fb106 	br	811329e4 <__reset+0xfb1129e4>

81132b20 <__divsi3>:
81132b20:	20001b16 	blt	r4,zero,81132b90 <__divsi3+0x70>
81132b24:	000f883a 	mov	r7,zero
81132b28:	28001616 	blt	r5,zero,81132b84 <__divsi3+0x64>
81132b2c:	200d883a 	mov	r6,r4
81132b30:	29001a2e 	bgeu	r5,r4,81132b9c <__divsi3+0x7c>
81132b34:	00800804 	movi	r2,32
81132b38:	00c00044 	movi	r3,1
81132b3c:	00000106 	br	81132b44 <__divsi3+0x24>
81132b40:	10000d26 	beq	r2,zero,81132b78 <__divsi3+0x58>
81132b44:	294b883a 	add	r5,r5,r5
81132b48:	10bfffc4 	addi	r2,r2,-1
81132b4c:	18c7883a 	add	r3,r3,r3
81132b50:	293ffb36 	bltu	r5,r4,81132b40 <__reset+0xfb112b40>
81132b54:	0005883a 	mov	r2,zero
81132b58:	18000726 	beq	r3,zero,81132b78 <__divsi3+0x58>
81132b5c:	0005883a 	mov	r2,zero
81132b60:	31400236 	bltu	r6,r5,81132b6c <__divsi3+0x4c>
81132b64:	314dc83a 	sub	r6,r6,r5
81132b68:	10c4b03a 	or	r2,r2,r3
81132b6c:	1806d07a 	srli	r3,r3,1
81132b70:	280ad07a 	srli	r5,r5,1
81132b74:	183ffa1e 	bne	r3,zero,81132b60 <__reset+0xfb112b60>
81132b78:	38000126 	beq	r7,zero,81132b80 <__divsi3+0x60>
81132b7c:	0085c83a 	sub	r2,zero,r2
81132b80:	f800283a 	ret
81132b84:	014bc83a 	sub	r5,zero,r5
81132b88:	39c0005c 	xori	r7,r7,1
81132b8c:	003fe706 	br	81132b2c <__reset+0xfb112b2c>
81132b90:	0109c83a 	sub	r4,zero,r4
81132b94:	01c00044 	movi	r7,1
81132b98:	003fe306 	br	81132b28 <__reset+0xfb112b28>
81132b9c:	00c00044 	movi	r3,1
81132ba0:	003fee06 	br	81132b5c <__reset+0xfb112b5c>

81132ba4 <__modsi3>:
81132ba4:	20001716 	blt	r4,zero,81132c04 <__modsi3+0x60>
81132ba8:	000f883a 	mov	r7,zero
81132bac:	2005883a 	mov	r2,r4
81132bb0:	28001216 	blt	r5,zero,81132bfc <__modsi3+0x58>
81132bb4:	2900162e 	bgeu	r5,r4,81132c10 <__modsi3+0x6c>
81132bb8:	01800804 	movi	r6,32
81132bbc:	00c00044 	movi	r3,1
81132bc0:	00000106 	br	81132bc8 <__modsi3+0x24>
81132bc4:	30000a26 	beq	r6,zero,81132bf0 <__modsi3+0x4c>
81132bc8:	294b883a 	add	r5,r5,r5
81132bcc:	31bfffc4 	addi	r6,r6,-1
81132bd0:	18c7883a 	add	r3,r3,r3
81132bd4:	293ffb36 	bltu	r5,r4,81132bc4 <__reset+0xfb112bc4>
81132bd8:	18000526 	beq	r3,zero,81132bf0 <__modsi3+0x4c>
81132bdc:	1806d07a 	srli	r3,r3,1
81132be0:	11400136 	bltu	r2,r5,81132be8 <__modsi3+0x44>
81132be4:	1145c83a 	sub	r2,r2,r5
81132be8:	280ad07a 	srli	r5,r5,1
81132bec:	183ffb1e 	bne	r3,zero,81132bdc <__reset+0xfb112bdc>
81132bf0:	38000126 	beq	r7,zero,81132bf8 <__modsi3+0x54>
81132bf4:	0085c83a 	sub	r2,zero,r2
81132bf8:	f800283a 	ret
81132bfc:	014bc83a 	sub	r5,zero,r5
81132c00:	003fec06 	br	81132bb4 <__reset+0xfb112bb4>
81132c04:	0109c83a 	sub	r4,zero,r4
81132c08:	01c00044 	movi	r7,1
81132c0c:	003fe706 	br	81132bac <__reset+0xfb112bac>
81132c10:	00c00044 	movi	r3,1
81132c14:	003ff106 	br	81132bdc <__reset+0xfb112bdc>

81132c18 <__udivsi3>:
81132c18:	200d883a 	mov	r6,r4
81132c1c:	2900152e 	bgeu	r5,r4,81132c74 <__udivsi3+0x5c>
81132c20:	28001416 	blt	r5,zero,81132c74 <__udivsi3+0x5c>
81132c24:	00800804 	movi	r2,32
81132c28:	00c00044 	movi	r3,1
81132c2c:	00000206 	br	81132c38 <__udivsi3+0x20>
81132c30:	10000e26 	beq	r2,zero,81132c6c <__udivsi3+0x54>
81132c34:	28000516 	blt	r5,zero,81132c4c <__udivsi3+0x34>
81132c38:	294b883a 	add	r5,r5,r5
81132c3c:	10bfffc4 	addi	r2,r2,-1
81132c40:	18c7883a 	add	r3,r3,r3
81132c44:	293ffa36 	bltu	r5,r4,81132c30 <__reset+0xfb112c30>
81132c48:	18000826 	beq	r3,zero,81132c6c <__udivsi3+0x54>
81132c4c:	0005883a 	mov	r2,zero
81132c50:	31400236 	bltu	r6,r5,81132c5c <__udivsi3+0x44>
81132c54:	314dc83a 	sub	r6,r6,r5
81132c58:	10c4b03a 	or	r2,r2,r3
81132c5c:	1806d07a 	srli	r3,r3,1
81132c60:	280ad07a 	srli	r5,r5,1
81132c64:	183ffa1e 	bne	r3,zero,81132c50 <__reset+0xfb112c50>
81132c68:	f800283a 	ret
81132c6c:	0005883a 	mov	r2,zero
81132c70:	f800283a 	ret
81132c74:	00c00044 	movi	r3,1
81132c78:	003ff406 	br	81132c4c <__reset+0xfb112c4c>

81132c7c <__umodsi3>:
81132c7c:	2005883a 	mov	r2,r4
81132c80:	2900122e 	bgeu	r5,r4,81132ccc <__umodsi3+0x50>
81132c84:	28001116 	blt	r5,zero,81132ccc <__umodsi3+0x50>
81132c88:	01800804 	movi	r6,32
81132c8c:	00c00044 	movi	r3,1
81132c90:	00000206 	br	81132c9c <__umodsi3+0x20>
81132c94:	30000c26 	beq	r6,zero,81132cc8 <__umodsi3+0x4c>
81132c98:	28000516 	blt	r5,zero,81132cb0 <__umodsi3+0x34>
81132c9c:	294b883a 	add	r5,r5,r5
81132ca0:	31bfffc4 	addi	r6,r6,-1
81132ca4:	18c7883a 	add	r3,r3,r3
81132ca8:	293ffa36 	bltu	r5,r4,81132c94 <__reset+0xfb112c94>
81132cac:	18000626 	beq	r3,zero,81132cc8 <__umodsi3+0x4c>
81132cb0:	1806d07a 	srli	r3,r3,1
81132cb4:	11400136 	bltu	r2,r5,81132cbc <__umodsi3+0x40>
81132cb8:	1145c83a 	sub	r2,r2,r5
81132cbc:	280ad07a 	srli	r5,r5,1
81132cc0:	183ffb1e 	bne	r3,zero,81132cb0 <__reset+0xfb112cb0>
81132cc4:	f800283a 	ret
81132cc8:	f800283a 	ret
81132ccc:	00c00044 	movi	r3,1
81132cd0:	003ff706 	br	81132cb0 <__reset+0xfb112cb0>

81132cd4 <__eqsf2>:
81132cd4:	2006d5fa 	srli	r3,r4,23
81132cd8:	280cd5fa 	srli	r6,r5,23
81132cdc:	01c02034 	movhi	r7,128
81132ce0:	39ffffc4 	addi	r7,r7,-1
81132ce4:	18c03fcc 	andi	r3,r3,255
81132ce8:	02003fc4 	movi	r8,255
81132cec:	3904703a 	and	r2,r7,r4
81132cf0:	31803fcc 	andi	r6,r6,255
81132cf4:	394e703a 	and	r7,r7,r5
81132cf8:	2008d7fa 	srli	r4,r4,31
81132cfc:	280ad7fa 	srli	r5,r5,31
81132d00:	1a000d26 	beq	r3,r8,81132d38 <__eqsf2+0x64>
81132d04:	02003fc4 	movi	r8,255
81132d08:	32000826 	beq	r6,r8,81132d2c <__eqsf2+0x58>
81132d0c:	19800226 	beq	r3,r6,81132d18 <__eqsf2+0x44>
81132d10:	00800044 	movi	r2,1
81132d14:	f800283a 	ret
81132d18:	11fffd1e 	bne	r2,r7,81132d10 <__reset+0xfb112d10>
81132d1c:	21400926 	beq	r4,r5,81132d44 <__eqsf2+0x70>
81132d20:	183ffb1e 	bne	r3,zero,81132d10 <__reset+0xfb112d10>
81132d24:	1004c03a 	cmpne	r2,r2,zero
81132d28:	f800283a 	ret
81132d2c:	383ff726 	beq	r7,zero,81132d0c <__reset+0xfb112d0c>
81132d30:	00800044 	movi	r2,1
81132d34:	f800283a 	ret
81132d38:	103ff226 	beq	r2,zero,81132d04 <__reset+0xfb112d04>
81132d3c:	00800044 	movi	r2,1
81132d40:	f800283a 	ret
81132d44:	0005883a 	mov	r2,zero
81132d48:	f800283a 	ret

81132d4c <__gesf2>:
81132d4c:	2004d5fa 	srli	r2,r4,23
81132d50:	2806d5fa 	srli	r3,r5,23
81132d54:	01802034 	movhi	r6,128
81132d58:	31bfffc4 	addi	r6,r6,-1
81132d5c:	10803fcc 	andi	r2,r2,255
81132d60:	01c03fc4 	movi	r7,255
81132d64:	3110703a 	and	r8,r6,r4
81132d68:	18c03fcc 	andi	r3,r3,255
81132d6c:	314c703a 	and	r6,r6,r5
81132d70:	2008d7fa 	srli	r4,r4,31
81132d74:	280ad7fa 	srli	r5,r5,31
81132d78:	11c01926 	beq	r2,r7,81132de0 <__gesf2+0x94>
81132d7c:	01c03fc4 	movi	r7,255
81132d80:	19c00f26 	beq	r3,r7,81132dc0 <__gesf2+0x74>
81132d84:	1000061e 	bne	r2,zero,81132da0 <__gesf2+0x54>
81132d88:	400f003a 	cmpeq	r7,r8,zero
81132d8c:	1800071e 	bne	r3,zero,81132dac <__gesf2+0x60>
81132d90:	3000061e 	bne	r6,zero,81132dac <__gesf2+0x60>
81132d94:	0005883a 	mov	r2,zero
81132d98:	40000e1e 	bne	r8,zero,81132dd4 <__gesf2+0x88>
81132d9c:	f800283a 	ret
81132da0:	18000a1e 	bne	r3,zero,81132dcc <__gesf2+0x80>
81132da4:	30000b26 	beq	r6,zero,81132dd4 <__gesf2+0x88>
81132da8:	000f883a 	mov	r7,zero
81132dac:	29403fcc 	andi	r5,r5,255
81132db0:	38000726 	beq	r7,zero,81132dd0 <__gesf2+0x84>
81132db4:	28000826 	beq	r5,zero,81132dd8 <__gesf2+0x8c>
81132db8:	00800044 	movi	r2,1
81132dbc:	f800283a 	ret
81132dc0:	303ff026 	beq	r6,zero,81132d84 <__reset+0xfb112d84>
81132dc4:	00bfff84 	movi	r2,-2
81132dc8:	f800283a 	ret
81132dcc:	29403fcc 	andi	r5,r5,255
81132dd0:	21400526 	beq	r4,r5,81132de8 <__gesf2+0x9c>
81132dd4:	203ff826 	beq	r4,zero,81132db8 <__reset+0xfb112db8>
81132dd8:	00bfffc4 	movi	r2,-1
81132ddc:	f800283a 	ret
81132de0:	403fe626 	beq	r8,zero,81132d7c <__reset+0xfb112d7c>
81132de4:	003ff706 	br	81132dc4 <__reset+0xfb112dc4>
81132de8:	18bffa16 	blt	r3,r2,81132dd4 <__reset+0xfb112dd4>
81132dec:	10c00216 	blt	r2,r3,81132df8 <__gesf2+0xac>
81132df0:	323ff836 	bltu	r6,r8,81132dd4 <__reset+0xfb112dd4>
81132df4:	4180022e 	bgeu	r8,r6,81132e00 <__gesf2+0xb4>
81132df8:	203fef1e 	bne	r4,zero,81132db8 <__reset+0xfb112db8>
81132dfc:	003ff606 	br	81132dd8 <__reset+0xfb112dd8>
81132e00:	0005883a 	mov	r2,zero
81132e04:	f800283a 	ret

81132e08 <__lesf2>:
81132e08:	2004d5fa 	srli	r2,r4,23
81132e0c:	280cd5fa 	srli	r6,r5,23
81132e10:	00c02034 	movhi	r3,128
81132e14:	18ffffc4 	addi	r3,r3,-1
81132e18:	10803fcc 	andi	r2,r2,255
81132e1c:	01c03fc4 	movi	r7,255
81132e20:	1910703a 	and	r8,r3,r4
81132e24:	31803fcc 	andi	r6,r6,255
81132e28:	1946703a 	and	r3,r3,r5
81132e2c:	2008d7fa 	srli	r4,r4,31
81132e30:	280ad7fa 	srli	r5,r5,31
81132e34:	11c01b26 	beq	r2,r7,81132ea4 <__lesf2+0x9c>
81132e38:	01c03fc4 	movi	r7,255
81132e3c:	31c01126 	beq	r6,r7,81132e84 <__lesf2+0x7c>
81132e40:	1000071e 	bne	r2,zero,81132e60 <__lesf2+0x58>
81132e44:	400f003a 	cmpeq	r7,r8,zero
81132e48:	21003fcc 	andi	r4,r4,255
81132e4c:	3000081e 	bne	r6,zero,81132e70 <__lesf2+0x68>
81132e50:	1800071e 	bne	r3,zero,81132e70 <__lesf2+0x68>
81132e54:	0005883a 	mov	r2,zero
81132e58:	40000f1e 	bne	r8,zero,81132e98 <__lesf2+0x90>
81132e5c:	f800283a 	ret
81132e60:	21003fcc 	andi	r4,r4,255
81132e64:	30000a1e 	bne	r6,zero,81132e90 <__lesf2+0x88>
81132e68:	18000b26 	beq	r3,zero,81132e98 <__lesf2+0x90>
81132e6c:	000f883a 	mov	r7,zero
81132e70:	29403fcc 	andi	r5,r5,255
81132e74:	38000726 	beq	r7,zero,81132e94 <__lesf2+0x8c>
81132e78:	28000826 	beq	r5,zero,81132e9c <__lesf2+0x94>
81132e7c:	00800044 	movi	r2,1
81132e80:	f800283a 	ret
81132e84:	183fee26 	beq	r3,zero,81132e40 <__reset+0xfb112e40>
81132e88:	00800084 	movi	r2,2
81132e8c:	f800283a 	ret
81132e90:	29403fcc 	andi	r5,r5,255
81132e94:	21400626 	beq	r4,r5,81132eb0 <__lesf2+0xa8>
81132e98:	203ff826 	beq	r4,zero,81132e7c <__reset+0xfb112e7c>
81132e9c:	00bfffc4 	movi	r2,-1
81132ea0:	f800283a 	ret
81132ea4:	403fe426 	beq	r8,zero,81132e38 <__reset+0xfb112e38>
81132ea8:	00800084 	movi	r2,2
81132eac:	f800283a 	ret
81132eb0:	30bff916 	blt	r6,r2,81132e98 <__reset+0xfb112e98>
81132eb4:	11800216 	blt	r2,r6,81132ec0 <__lesf2+0xb8>
81132eb8:	1a3ff736 	bltu	r3,r8,81132e98 <__reset+0xfb112e98>
81132ebc:	40c0022e 	bgeu	r8,r3,81132ec8 <__lesf2+0xc0>
81132ec0:	203fee1e 	bne	r4,zero,81132e7c <__reset+0xfb112e7c>
81132ec4:	003ff506 	br	81132e9c <__reset+0xfb112e9c>
81132ec8:	0005883a 	mov	r2,zero
81132ecc:	f800283a 	ret

81132ed0 <__adddf3>:
81132ed0:	02c00434 	movhi	r11,16
81132ed4:	5affffc4 	addi	r11,r11,-1
81132ed8:	2806d7fa 	srli	r3,r5,31
81132edc:	2ad4703a 	and	r10,r5,r11
81132ee0:	3ad2703a 	and	r9,r7,r11
81132ee4:	3804d53a 	srli	r2,r7,20
81132ee8:	3018d77a 	srli	r12,r6,29
81132eec:	280ad53a 	srli	r5,r5,20
81132ef0:	501490fa 	slli	r10,r10,3
81132ef4:	2010d77a 	srli	r8,r4,29
81132ef8:	481290fa 	slli	r9,r9,3
81132efc:	380ed7fa 	srli	r7,r7,31
81132f00:	defffb04 	addi	sp,sp,-20
81132f04:	de00012e 	bgeu	sp,et,81132f0c <__adddf3+0x3c>
81132f08:	003b68fa 	trap	3
81132f0c:	dc800215 	stw	r18,8(sp)
81132f10:	dc400115 	stw	r17,4(sp)
81132f14:	dc000015 	stw	r16,0(sp)
81132f18:	dfc00415 	stw	ra,16(sp)
81132f1c:	dcc00315 	stw	r19,12(sp)
81132f20:	1c803fcc 	andi	r18,r3,255
81132f24:	2c01ffcc 	andi	r16,r5,2047
81132f28:	5210b03a 	or	r8,r10,r8
81132f2c:	202290fa 	slli	r17,r4,3
81132f30:	1081ffcc 	andi	r2,r2,2047
81132f34:	4b12b03a 	or	r9,r9,r12
81132f38:	300c90fa 	slli	r6,r6,3
81132f3c:	91c07526 	beq	r18,r7,81133114 <__adddf3+0x244>
81132f40:	8087c83a 	sub	r3,r16,r2
81132f44:	00c0ab0e 	bge	zero,r3,811331f4 <__adddf3+0x324>
81132f48:	10002a1e 	bne	r2,zero,81132ff4 <__adddf3+0x124>
81132f4c:	4984b03a 	or	r2,r9,r6
81132f50:	1000961e 	bne	r2,zero,811331ac <__adddf3+0x2dc>
81132f54:	888001cc 	andi	r2,r17,7
81132f58:	10000726 	beq	r2,zero,81132f78 <__adddf3+0xa8>
81132f5c:	888003cc 	andi	r2,r17,15
81132f60:	00c00104 	movi	r3,4
81132f64:	10c00426 	beq	r2,r3,81132f78 <__adddf3+0xa8>
81132f68:	88c7883a 	add	r3,r17,r3
81132f6c:	1c63803a 	cmpltu	r17,r3,r17
81132f70:	4451883a 	add	r8,r8,r17
81132f74:	1823883a 	mov	r17,r3
81132f78:	4080202c 	andhi	r2,r8,128
81132f7c:	10005926 	beq	r2,zero,811330e4 <__adddf3+0x214>
81132f80:	84000044 	addi	r16,r16,1
81132f84:	0081ffc4 	movi	r2,2047
81132f88:	8080ba26 	beq	r16,r2,81133274 <__adddf3+0x3a4>
81132f8c:	00bfe034 	movhi	r2,65408
81132f90:	10bfffc4 	addi	r2,r2,-1
81132f94:	4090703a 	and	r8,r8,r2
81132f98:	4004977a 	slli	r2,r8,29
81132f9c:	4010927a 	slli	r8,r8,9
81132fa0:	8822d0fa 	srli	r17,r17,3
81132fa4:	8401ffcc 	andi	r16,r16,2047
81132fa8:	4010d33a 	srli	r8,r8,12
81132fac:	9007883a 	mov	r3,r18
81132fb0:	1444b03a 	or	r2,r2,r17
81132fb4:	8401ffcc 	andi	r16,r16,2047
81132fb8:	8020953a 	slli	r16,r16,20
81132fbc:	18c03fcc 	andi	r3,r3,255
81132fc0:	01000434 	movhi	r4,16
81132fc4:	213fffc4 	addi	r4,r4,-1
81132fc8:	180697fa 	slli	r3,r3,31
81132fcc:	4110703a 	and	r8,r8,r4
81132fd0:	4410b03a 	or	r8,r8,r16
81132fd4:	40c6b03a 	or	r3,r8,r3
81132fd8:	dfc00417 	ldw	ra,16(sp)
81132fdc:	dcc00317 	ldw	r19,12(sp)
81132fe0:	dc800217 	ldw	r18,8(sp)
81132fe4:	dc400117 	ldw	r17,4(sp)
81132fe8:	dc000017 	ldw	r16,0(sp)
81132fec:	dec00504 	addi	sp,sp,20
81132ff0:	f800283a 	ret
81132ff4:	0081ffc4 	movi	r2,2047
81132ff8:	80bfd626 	beq	r16,r2,81132f54 <__reset+0xfb112f54>
81132ffc:	4a402034 	orhi	r9,r9,128
81133000:	00800e04 	movi	r2,56
81133004:	10c09f16 	blt	r2,r3,81133284 <__adddf3+0x3b4>
81133008:	008007c4 	movi	r2,31
8113300c:	10c0c216 	blt	r2,r3,81133318 <__adddf3+0x448>
81133010:	00800804 	movi	r2,32
81133014:	10c5c83a 	sub	r2,r2,r3
81133018:	488a983a 	sll	r5,r9,r2
8113301c:	30c8d83a 	srl	r4,r6,r3
81133020:	3084983a 	sll	r2,r6,r2
81133024:	48c6d83a 	srl	r3,r9,r3
81133028:	290cb03a 	or	r6,r5,r4
8113302c:	1004c03a 	cmpne	r2,r2,zero
81133030:	308cb03a 	or	r6,r6,r2
81133034:	898dc83a 	sub	r6,r17,r6
81133038:	89a3803a 	cmpltu	r17,r17,r6
8113303c:	40d1c83a 	sub	r8,r8,r3
81133040:	4451c83a 	sub	r8,r8,r17
81133044:	3023883a 	mov	r17,r6
81133048:	4080202c 	andhi	r2,r8,128
8113304c:	10002326 	beq	r2,zero,811330dc <__adddf3+0x20c>
81133050:	04c02034 	movhi	r19,128
81133054:	9cffffc4 	addi	r19,r19,-1
81133058:	44e6703a 	and	r19,r8,r19
8113305c:	98007626 	beq	r19,zero,81133238 <__adddf3+0x368>
81133060:	9809883a 	mov	r4,r19
81133064:	111f43c0 	call	8111f43c <__clzsi2>
81133068:	10fffe04 	addi	r3,r2,-8
8113306c:	010007c4 	movi	r4,31
81133070:	20c07716 	blt	r4,r3,81133250 <__adddf3+0x380>
81133074:	00800804 	movi	r2,32
81133078:	10c5c83a 	sub	r2,r2,r3
8113307c:	8884d83a 	srl	r2,r17,r2
81133080:	98d0983a 	sll	r8,r19,r3
81133084:	88e2983a 	sll	r17,r17,r3
81133088:	1204b03a 	or	r2,r2,r8
8113308c:	1c007416 	blt	r3,r16,81133260 <__adddf3+0x390>
81133090:	1c21c83a 	sub	r16,r3,r16
81133094:	82000044 	addi	r8,r16,1
81133098:	00c007c4 	movi	r3,31
8113309c:	1a009116 	blt	r3,r8,811332e4 <__adddf3+0x414>
811330a0:	00c00804 	movi	r3,32
811330a4:	1a07c83a 	sub	r3,r3,r8
811330a8:	8a08d83a 	srl	r4,r17,r8
811330ac:	88e2983a 	sll	r17,r17,r3
811330b0:	10c6983a 	sll	r3,r2,r3
811330b4:	1210d83a 	srl	r8,r2,r8
811330b8:	8804c03a 	cmpne	r2,r17,zero
811330bc:	1906b03a 	or	r3,r3,r4
811330c0:	18a2b03a 	or	r17,r3,r2
811330c4:	0021883a 	mov	r16,zero
811330c8:	003fa206 	br	81132f54 <__reset+0xfb112f54>
811330cc:	1890b03a 	or	r8,r3,r2
811330d0:	40017d26 	beq	r8,zero,811336c8 <__adddf3+0x7f8>
811330d4:	1011883a 	mov	r8,r2
811330d8:	1823883a 	mov	r17,r3
811330dc:	888001cc 	andi	r2,r17,7
811330e0:	103f9e1e 	bne	r2,zero,81132f5c <__reset+0xfb112f5c>
811330e4:	4004977a 	slli	r2,r8,29
811330e8:	8822d0fa 	srli	r17,r17,3
811330ec:	4010d0fa 	srli	r8,r8,3
811330f0:	9007883a 	mov	r3,r18
811330f4:	1444b03a 	or	r2,r2,r17
811330f8:	0101ffc4 	movi	r4,2047
811330fc:	81002426 	beq	r16,r4,81133190 <__adddf3+0x2c0>
81133100:	8120703a 	and	r16,r16,r4
81133104:	01000434 	movhi	r4,16
81133108:	213fffc4 	addi	r4,r4,-1
8113310c:	4110703a 	and	r8,r8,r4
81133110:	003fa806 	br	81132fb4 <__reset+0xfb112fb4>
81133114:	8089c83a 	sub	r4,r16,r2
81133118:	01005e0e 	bge	zero,r4,81133294 <__adddf3+0x3c4>
8113311c:	10002b26 	beq	r2,zero,811331cc <__adddf3+0x2fc>
81133120:	0081ffc4 	movi	r2,2047
81133124:	80bf8b26 	beq	r16,r2,81132f54 <__reset+0xfb112f54>
81133128:	4a402034 	orhi	r9,r9,128
8113312c:	00800e04 	movi	r2,56
81133130:	1100a40e 	bge	r2,r4,811333c4 <__adddf3+0x4f4>
81133134:	498cb03a 	or	r6,r9,r6
81133138:	300ac03a 	cmpne	r5,r6,zero
8113313c:	0013883a 	mov	r9,zero
81133140:	2c4b883a 	add	r5,r5,r17
81133144:	2c63803a 	cmpltu	r17,r5,r17
81133148:	4a11883a 	add	r8,r9,r8
8113314c:	8a11883a 	add	r8,r17,r8
81133150:	2823883a 	mov	r17,r5
81133154:	4080202c 	andhi	r2,r8,128
81133158:	103fe026 	beq	r2,zero,811330dc <__reset+0xfb1130dc>
8113315c:	84000044 	addi	r16,r16,1
81133160:	0081ffc4 	movi	r2,2047
81133164:	8080d226 	beq	r16,r2,811334b0 <__adddf3+0x5e0>
81133168:	00bfe034 	movhi	r2,65408
8113316c:	10bfffc4 	addi	r2,r2,-1
81133170:	4090703a 	and	r8,r8,r2
81133174:	880ad07a 	srli	r5,r17,1
81133178:	400897fa 	slli	r4,r8,31
8113317c:	88c0004c 	andi	r3,r17,1
81133180:	28e2b03a 	or	r17,r5,r3
81133184:	4010d07a 	srli	r8,r8,1
81133188:	2462b03a 	or	r17,r4,r17
8113318c:	003f7106 	br	81132f54 <__reset+0xfb112f54>
81133190:	4088b03a 	or	r4,r8,r2
81133194:	20014526 	beq	r4,zero,811336ac <__adddf3+0x7dc>
81133198:	01000434 	movhi	r4,16
8113319c:	42000234 	orhi	r8,r8,8
811331a0:	213fffc4 	addi	r4,r4,-1
811331a4:	4110703a 	and	r8,r8,r4
811331a8:	003f8206 	br	81132fb4 <__reset+0xfb112fb4>
811331ac:	18ffffc4 	addi	r3,r3,-1
811331b0:	1800491e 	bne	r3,zero,811332d8 <__adddf3+0x408>
811331b4:	898bc83a 	sub	r5,r17,r6
811331b8:	8963803a 	cmpltu	r17,r17,r5
811331bc:	4251c83a 	sub	r8,r8,r9
811331c0:	4451c83a 	sub	r8,r8,r17
811331c4:	2823883a 	mov	r17,r5
811331c8:	003f9f06 	br	81133048 <__reset+0xfb113048>
811331cc:	4984b03a 	or	r2,r9,r6
811331d0:	103f6026 	beq	r2,zero,81132f54 <__reset+0xfb112f54>
811331d4:	213fffc4 	addi	r4,r4,-1
811331d8:	2000931e 	bne	r4,zero,81133428 <__adddf3+0x558>
811331dc:	898d883a 	add	r6,r17,r6
811331e0:	3463803a 	cmpltu	r17,r6,r17
811331e4:	4251883a 	add	r8,r8,r9
811331e8:	8a11883a 	add	r8,r17,r8
811331ec:	3023883a 	mov	r17,r6
811331f0:	003fd806 	br	81133154 <__reset+0xfb113154>
811331f4:	1800541e 	bne	r3,zero,81133348 <__adddf3+0x478>
811331f8:	80800044 	addi	r2,r16,1
811331fc:	1081ffcc 	andi	r2,r2,2047
81133200:	00c00044 	movi	r3,1
81133204:	1880a00e 	bge	r3,r2,81133488 <__adddf3+0x5b8>
81133208:	8989c83a 	sub	r4,r17,r6
8113320c:	8905803a 	cmpltu	r2,r17,r4
81133210:	4267c83a 	sub	r19,r8,r9
81133214:	98a7c83a 	sub	r19,r19,r2
81133218:	9880202c 	andhi	r2,r19,128
8113321c:	10006326 	beq	r2,zero,811333ac <__adddf3+0x4dc>
81133220:	3463c83a 	sub	r17,r6,r17
81133224:	4a07c83a 	sub	r3,r9,r8
81133228:	344d803a 	cmpltu	r6,r6,r17
8113322c:	19a7c83a 	sub	r19,r3,r6
81133230:	3825883a 	mov	r18,r7
81133234:	983f8a1e 	bne	r19,zero,81133060 <__reset+0xfb113060>
81133238:	8809883a 	mov	r4,r17
8113323c:	111f43c0 	call	8111f43c <__clzsi2>
81133240:	10800804 	addi	r2,r2,32
81133244:	10fffe04 	addi	r3,r2,-8
81133248:	010007c4 	movi	r4,31
8113324c:	20ff890e 	bge	r4,r3,81133074 <__reset+0xfb113074>
81133250:	10bff604 	addi	r2,r2,-40
81133254:	8884983a 	sll	r2,r17,r2
81133258:	0023883a 	mov	r17,zero
8113325c:	1c3f8c0e 	bge	r3,r16,81133090 <__reset+0xfb113090>
81133260:	023fe034 	movhi	r8,65408
81133264:	423fffc4 	addi	r8,r8,-1
81133268:	80e1c83a 	sub	r16,r16,r3
8113326c:	1210703a 	and	r8,r2,r8
81133270:	003f3806 	br	81132f54 <__reset+0xfb112f54>
81133274:	9007883a 	mov	r3,r18
81133278:	0011883a 	mov	r8,zero
8113327c:	0005883a 	mov	r2,zero
81133280:	003f4c06 	br	81132fb4 <__reset+0xfb112fb4>
81133284:	498cb03a 	or	r6,r9,r6
81133288:	300cc03a 	cmpne	r6,r6,zero
8113328c:	0007883a 	mov	r3,zero
81133290:	003f6806 	br	81133034 <__reset+0xfb113034>
81133294:	20009c1e 	bne	r4,zero,81133508 <__adddf3+0x638>
81133298:	80800044 	addi	r2,r16,1
8113329c:	1141ffcc 	andi	r5,r2,2047
811332a0:	01000044 	movi	r4,1
811332a4:	2140670e 	bge	r4,r5,81133444 <__adddf3+0x574>
811332a8:	0101ffc4 	movi	r4,2047
811332ac:	11007f26 	beq	r2,r4,811334ac <__adddf3+0x5dc>
811332b0:	898d883a 	add	r6,r17,r6
811332b4:	4247883a 	add	r3,r8,r9
811332b8:	3451803a 	cmpltu	r8,r6,r17
811332bc:	40d1883a 	add	r8,r8,r3
811332c0:	402297fa 	slli	r17,r8,31
811332c4:	300cd07a 	srli	r6,r6,1
811332c8:	4010d07a 	srli	r8,r8,1
811332cc:	1021883a 	mov	r16,r2
811332d0:	89a2b03a 	or	r17,r17,r6
811332d4:	003f1f06 	br	81132f54 <__reset+0xfb112f54>
811332d8:	0081ffc4 	movi	r2,2047
811332dc:	80bf481e 	bne	r16,r2,81133000 <__reset+0xfb113000>
811332e0:	003f1c06 	br	81132f54 <__reset+0xfb112f54>
811332e4:	843ff844 	addi	r16,r16,-31
811332e8:	01000804 	movi	r4,32
811332ec:	1406d83a 	srl	r3,r2,r16
811332f0:	41005026 	beq	r8,r4,81133434 <__adddf3+0x564>
811332f4:	01001004 	movi	r4,64
811332f8:	2211c83a 	sub	r8,r4,r8
811332fc:	1204983a 	sll	r2,r2,r8
81133300:	88a2b03a 	or	r17,r17,r2
81133304:	8822c03a 	cmpne	r17,r17,zero
81133308:	1c62b03a 	or	r17,r3,r17
8113330c:	0011883a 	mov	r8,zero
81133310:	0021883a 	mov	r16,zero
81133314:	003f7106 	br	811330dc <__reset+0xfb1130dc>
81133318:	193ff804 	addi	r4,r3,-32
8113331c:	00800804 	movi	r2,32
81133320:	4908d83a 	srl	r4,r9,r4
81133324:	18804526 	beq	r3,r2,8113343c <__adddf3+0x56c>
81133328:	00801004 	movi	r2,64
8113332c:	10c5c83a 	sub	r2,r2,r3
81133330:	4886983a 	sll	r3,r9,r2
81133334:	198cb03a 	or	r6,r3,r6
81133338:	300cc03a 	cmpne	r6,r6,zero
8113333c:	218cb03a 	or	r6,r4,r6
81133340:	0007883a 	mov	r3,zero
81133344:	003f3b06 	br	81133034 <__reset+0xfb113034>
81133348:	80002a26 	beq	r16,zero,811333f4 <__adddf3+0x524>
8113334c:	0101ffc4 	movi	r4,2047
81133350:	11006826 	beq	r2,r4,811334f4 <__adddf3+0x624>
81133354:	00c7c83a 	sub	r3,zero,r3
81133358:	42002034 	orhi	r8,r8,128
8113335c:	01000e04 	movi	r4,56
81133360:	20c07c16 	blt	r4,r3,81133554 <__adddf3+0x684>
81133364:	010007c4 	movi	r4,31
81133368:	20c0da16 	blt	r4,r3,811336d4 <__adddf3+0x804>
8113336c:	01000804 	movi	r4,32
81133370:	20c9c83a 	sub	r4,r4,r3
81133374:	4114983a 	sll	r10,r8,r4
81133378:	88cad83a 	srl	r5,r17,r3
8113337c:	8908983a 	sll	r4,r17,r4
81133380:	40c6d83a 	srl	r3,r8,r3
81133384:	5162b03a 	or	r17,r10,r5
81133388:	2008c03a 	cmpne	r4,r4,zero
8113338c:	8922b03a 	or	r17,r17,r4
81133390:	3463c83a 	sub	r17,r6,r17
81133394:	48c7c83a 	sub	r3,r9,r3
81133398:	344d803a 	cmpltu	r6,r6,r17
8113339c:	1991c83a 	sub	r8,r3,r6
811333a0:	1021883a 	mov	r16,r2
811333a4:	3825883a 	mov	r18,r7
811333a8:	003f2706 	br	81133048 <__reset+0xfb113048>
811333ac:	24d0b03a 	or	r8,r4,r19
811333b0:	40001b1e 	bne	r8,zero,81133420 <__adddf3+0x550>
811333b4:	0005883a 	mov	r2,zero
811333b8:	0007883a 	mov	r3,zero
811333bc:	0021883a 	mov	r16,zero
811333c0:	003f4d06 	br	811330f8 <__reset+0xfb1130f8>
811333c4:	008007c4 	movi	r2,31
811333c8:	11003c16 	blt	r2,r4,811334bc <__adddf3+0x5ec>
811333cc:	00800804 	movi	r2,32
811333d0:	1105c83a 	sub	r2,r2,r4
811333d4:	488e983a 	sll	r7,r9,r2
811333d8:	310ad83a 	srl	r5,r6,r4
811333dc:	3084983a 	sll	r2,r6,r2
811333e0:	4912d83a 	srl	r9,r9,r4
811333e4:	394ab03a 	or	r5,r7,r5
811333e8:	1004c03a 	cmpne	r2,r2,zero
811333ec:	288ab03a 	or	r5,r5,r2
811333f0:	003f5306 	br	81133140 <__reset+0xfb113140>
811333f4:	4448b03a 	or	r4,r8,r17
811333f8:	20003e26 	beq	r4,zero,811334f4 <__adddf3+0x624>
811333fc:	00c6303a 	nor	r3,zero,r3
81133400:	18003a1e 	bne	r3,zero,811334ec <__adddf3+0x61c>
81133404:	3463c83a 	sub	r17,r6,r17
81133408:	4a07c83a 	sub	r3,r9,r8
8113340c:	344d803a 	cmpltu	r6,r6,r17
81133410:	1991c83a 	sub	r8,r3,r6
81133414:	1021883a 	mov	r16,r2
81133418:	3825883a 	mov	r18,r7
8113341c:	003f0a06 	br	81133048 <__reset+0xfb113048>
81133420:	2023883a 	mov	r17,r4
81133424:	003f0d06 	br	8113305c <__reset+0xfb11305c>
81133428:	0081ffc4 	movi	r2,2047
8113342c:	80bf3f1e 	bne	r16,r2,8113312c <__reset+0xfb11312c>
81133430:	003ec806 	br	81132f54 <__reset+0xfb112f54>
81133434:	0005883a 	mov	r2,zero
81133438:	003fb106 	br	81133300 <__reset+0xfb113300>
8113343c:	0007883a 	mov	r3,zero
81133440:	003fbc06 	br	81133334 <__reset+0xfb113334>
81133444:	4444b03a 	or	r2,r8,r17
81133448:	8000871e 	bne	r16,zero,81133668 <__adddf3+0x798>
8113344c:	1000ba26 	beq	r2,zero,81133738 <__adddf3+0x868>
81133450:	4984b03a 	or	r2,r9,r6
81133454:	103ebf26 	beq	r2,zero,81132f54 <__reset+0xfb112f54>
81133458:	8985883a 	add	r2,r17,r6
8113345c:	4247883a 	add	r3,r8,r9
81133460:	1451803a 	cmpltu	r8,r2,r17
81133464:	40d1883a 	add	r8,r8,r3
81133468:	40c0202c 	andhi	r3,r8,128
8113346c:	1023883a 	mov	r17,r2
81133470:	183f1a26 	beq	r3,zero,811330dc <__reset+0xfb1130dc>
81133474:	00bfe034 	movhi	r2,65408
81133478:	10bfffc4 	addi	r2,r2,-1
8113347c:	2021883a 	mov	r16,r4
81133480:	4090703a 	and	r8,r8,r2
81133484:	003eb306 	br	81132f54 <__reset+0xfb112f54>
81133488:	4444b03a 	or	r2,r8,r17
8113348c:	8000291e 	bne	r16,zero,81133534 <__adddf3+0x664>
81133490:	10004b1e 	bne	r2,zero,811335c0 <__adddf3+0x6f0>
81133494:	4990b03a 	or	r8,r9,r6
81133498:	40008b26 	beq	r8,zero,811336c8 <__adddf3+0x7f8>
8113349c:	4811883a 	mov	r8,r9
811334a0:	3023883a 	mov	r17,r6
811334a4:	3825883a 	mov	r18,r7
811334a8:	003eaa06 	br	81132f54 <__reset+0xfb112f54>
811334ac:	1021883a 	mov	r16,r2
811334b0:	0011883a 	mov	r8,zero
811334b4:	0005883a 	mov	r2,zero
811334b8:	003f0f06 	br	811330f8 <__reset+0xfb1130f8>
811334bc:	217ff804 	addi	r5,r4,-32
811334c0:	00800804 	movi	r2,32
811334c4:	494ad83a 	srl	r5,r9,r5
811334c8:	20807d26 	beq	r4,r2,811336c0 <__adddf3+0x7f0>
811334cc:	00801004 	movi	r2,64
811334d0:	1109c83a 	sub	r4,r2,r4
811334d4:	4912983a 	sll	r9,r9,r4
811334d8:	498cb03a 	or	r6,r9,r6
811334dc:	300cc03a 	cmpne	r6,r6,zero
811334e0:	298ab03a 	or	r5,r5,r6
811334e4:	0013883a 	mov	r9,zero
811334e8:	003f1506 	br	81133140 <__reset+0xfb113140>
811334ec:	0101ffc4 	movi	r4,2047
811334f0:	113f9a1e 	bne	r2,r4,8113335c <__reset+0xfb11335c>
811334f4:	4811883a 	mov	r8,r9
811334f8:	3023883a 	mov	r17,r6
811334fc:	1021883a 	mov	r16,r2
81133500:	3825883a 	mov	r18,r7
81133504:	003e9306 	br	81132f54 <__reset+0xfb112f54>
81133508:	8000161e 	bne	r16,zero,81133564 <__adddf3+0x694>
8113350c:	444ab03a 	or	r5,r8,r17
81133510:	28005126 	beq	r5,zero,81133658 <__adddf3+0x788>
81133514:	0108303a 	nor	r4,zero,r4
81133518:	20004d1e 	bne	r4,zero,81133650 <__adddf3+0x780>
8113351c:	89a3883a 	add	r17,r17,r6
81133520:	4253883a 	add	r9,r8,r9
81133524:	898d803a 	cmpltu	r6,r17,r6
81133528:	3251883a 	add	r8,r6,r9
8113352c:	1021883a 	mov	r16,r2
81133530:	003f0806 	br	81133154 <__reset+0xfb113154>
81133534:	1000301e 	bne	r2,zero,811335f8 <__adddf3+0x728>
81133538:	4984b03a 	or	r2,r9,r6
8113353c:	10007126 	beq	r2,zero,81133704 <__adddf3+0x834>
81133540:	4811883a 	mov	r8,r9
81133544:	3023883a 	mov	r17,r6
81133548:	3825883a 	mov	r18,r7
8113354c:	0401ffc4 	movi	r16,2047
81133550:	003e8006 	br	81132f54 <__reset+0xfb112f54>
81133554:	4462b03a 	or	r17,r8,r17
81133558:	8822c03a 	cmpne	r17,r17,zero
8113355c:	0007883a 	mov	r3,zero
81133560:	003f8b06 	br	81133390 <__reset+0xfb113390>
81133564:	0141ffc4 	movi	r5,2047
81133568:	11403b26 	beq	r2,r5,81133658 <__adddf3+0x788>
8113356c:	0109c83a 	sub	r4,zero,r4
81133570:	42002034 	orhi	r8,r8,128
81133574:	01400e04 	movi	r5,56
81133578:	29006716 	blt	r5,r4,81133718 <__adddf3+0x848>
8113357c:	014007c4 	movi	r5,31
81133580:	29007016 	blt	r5,r4,81133744 <__adddf3+0x874>
81133584:	01400804 	movi	r5,32
81133588:	290bc83a 	sub	r5,r5,r4
8113358c:	4154983a 	sll	r10,r8,r5
81133590:	890ed83a 	srl	r7,r17,r4
81133594:	894a983a 	sll	r5,r17,r5
81133598:	4108d83a 	srl	r4,r8,r4
8113359c:	51e2b03a 	or	r17,r10,r7
811335a0:	280ac03a 	cmpne	r5,r5,zero
811335a4:	8962b03a 	or	r17,r17,r5
811335a8:	89a3883a 	add	r17,r17,r6
811335ac:	2253883a 	add	r9,r4,r9
811335b0:	898d803a 	cmpltu	r6,r17,r6
811335b4:	3251883a 	add	r8,r6,r9
811335b8:	1021883a 	mov	r16,r2
811335bc:	003ee506 	br	81133154 <__reset+0xfb113154>
811335c0:	4984b03a 	or	r2,r9,r6
811335c4:	103e6326 	beq	r2,zero,81132f54 <__reset+0xfb112f54>
811335c8:	8987c83a 	sub	r3,r17,r6
811335cc:	88c9803a 	cmpltu	r4,r17,r3
811335d0:	4245c83a 	sub	r2,r8,r9
811335d4:	1105c83a 	sub	r2,r2,r4
811335d8:	1100202c 	andhi	r4,r2,128
811335dc:	203ebb26 	beq	r4,zero,811330cc <__reset+0xfb1130cc>
811335e0:	3463c83a 	sub	r17,r6,r17
811335e4:	4a07c83a 	sub	r3,r9,r8
811335e8:	344d803a 	cmpltu	r6,r6,r17
811335ec:	1991c83a 	sub	r8,r3,r6
811335f0:	3825883a 	mov	r18,r7
811335f4:	003e5706 	br	81132f54 <__reset+0xfb112f54>
811335f8:	4984b03a 	or	r2,r9,r6
811335fc:	10002e26 	beq	r2,zero,811336b8 <__adddf3+0x7e8>
81133600:	4004d0fa 	srli	r2,r8,3
81133604:	8822d0fa 	srli	r17,r17,3
81133608:	4010977a 	slli	r8,r8,29
8113360c:	10c0022c 	andhi	r3,r2,8
81133610:	4462b03a 	or	r17,r8,r17
81133614:	18000826 	beq	r3,zero,81133638 <__adddf3+0x768>
81133618:	4808d0fa 	srli	r4,r9,3
8113361c:	20c0022c 	andhi	r3,r4,8
81133620:	1800051e 	bne	r3,zero,81133638 <__adddf3+0x768>
81133624:	300cd0fa 	srli	r6,r6,3
81133628:	4806977a 	slli	r3,r9,29
8113362c:	2005883a 	mov	r2,r4
81133630:	3825883a 	mov	r18,r7
81133634:	19a2b03a 	or	r17,r3,r6
81133638:	8810d77a 	srli	r8,r17,29
8113363c:	100490fa 	slli	r2,r2,3
81133640:	882290fa 	slli	r17,r17,3
81133644:	0401ffc4 	movi	r16,2047
81133648:	4090b03a 	or	r8,r8,r2
8113364c:	003e4106 	br	81132f54 <__reset+0xfb112f54>
81133650:	0141ffc4 	movi	r5,2047
81133654:	117fc71e 	bne	r2,r5,81133574 <__reset+0xfb113574>
81133658:	4811883a 	mov	r8,r9
8113365c:	3023883a 	mov	r17,r6
81133660:	1021883a 	mov	r16,r2
81133664:	003e3b06 	br	81132f54 <__reset+0xfb112f54>
81133668:	10002f26 	beq	r2,zero,81133728 <__adddf3+0x858>
8113366c:	4984b03a 	or	r2,r9,r6
81133670:	10001126 	beq	r2,zero,811336b8 <__adddf3+0x7e8>
81133674:	4004d0fa 	srli	r2,r8,3
81133678:	8822d0fa 	srli	r17,r17,3
8113367c:	4010977a 	slli	r8,r8,29
81133680:	10c0022c 	andhi	r3,r2,8
81133684:	4462b03a 	or	r17,r8,r17
81133688:	183feb26 	beq	r3,zero,81133638 <__reset+0xfb113638>
8113368c:	4808d0fa 	srli	r4,r9,3
81133690:	20c0022c 	andhi	r3,r4,8
81133694:	183fe81e 	bne	r3,zero,81133638 <__reset+0xfb113638>
81133698:	300cd0fa 	srli	r6,r6,3
8113369c:	4806977a 	slli	r3,r9,29
811336a0:	2005883a 	mov	r2,r4
811336a4:	19a2b03a 	or	r17,r3,r6
811336a8:	003fe306 	br	81133638 <__reset+0xfb113638>
811336ac:	0011883a 	mov	r8,zero
811336b0:	0005883a 	mov	r2,zero
811336b4:	003e3f06 	br	81132fb4 <__reset+0xfb112fb4>
811336b8:	0401ffc4 	movi	r16,2047
811336bc:	003e2506 	br	81132f54 <__reset+0xfb112f54>
811336c0:	0013883a 	mov	r9,zero
811336c4:	003f8406 	br	811334d8 <__reset+0xfb1134d8>
811336c8:	0005883a 	mov	r2,zero
811336cc:	0007883a 	mov	r3,zero
811336d0:	003e8906 	br	811330f8 <__reset+0xfb1130f8>
811336d4:	197ff804 	addi	r5,r3,-32
811336d8:	01000804 	movi	r4,32
811336dc:	414ad83a 	srl	r5,r8,r5
811336e0:	19002426 	beq	r3,r4,81133774 <__adddf3+0x8a4>
811336e4:	01001004 	movi	r4,64
811336e8:	20c7c83a 	sub	r3,r4,r3
811336ec:	40c6983a 	sll	r3,r8,r3
811336f0:	1c46b03a 	or	r3,r3,r17
811336f4:	1806c03a 	cmpne	r3,r3,zero
811336f8:	28e2b03a 	or	r17,r5,r3
811336fc:	0007883a 	mov	r3,zero
81133700:	003f2306 	br	81133390 <__reset+0xfb113390>
81133704:	0007883a 	mov	r3,zero
81133708:	5811883a 	mov	r8,r11
8113370c:	00bfffc4 	movi	r2,-1
81133710:	0401ffc4 	movi	r16,2047
81133714:	003e7806 	br	811330f8 <__reset+0xfb1130f8>
81133718:	4462b03a 	or	r17,r8,r17
8113371c:	8822c03a 	cmpne	r17,r17,zero
81133720:	0009883a 	mov	r4,zero
81133724:	003fa006 	br	811335a8 <__reset+0xfb1135a8>
81133728:	4811883a 	mov	r8,r9
8113372c:	3023883a 	mov	r17,r6
81133730:	0401ffc4 	movi	r16,2047
81133734:	003e0706 	br	81132f54 <__reset+0xfb112f54>
81133738:	4811883a 	mov	r8,r9
8113373c:	3023883a 	mov	r17,r6
81133740:	003e0406 	br	81132f54 <__reset+0xfb112f54>
81133744:	21fff804 	addi	r7,r4,-32
81133748:	01400804 	movi	r5,32
8113374c:	41ced83a 	srl	r7,r8,r7
81133750:	21400a26 	beq	r4,r5,8113377c <__adddf3+0x8ac>
81133754:	01401004 	movi	r5,64
81133758:	2909c83a 	sub	r4,r5,r4
8113375c:	4108983a 	sll	r4,r8,r4
81133760:	2448b03a 	or	r4,r4,r17
81133764:	2008c03a 	cmpne	r4,r4,zero
81133768:	3922b03a 	or	r17,r7,r4
8113376c:	0009883a 	mov	r4,zero
81133770:	003f8d06 	br	811335a8 <__reset+0xfb1135a8>
81133774:	0007883a 	mov	r3,zero
81133778:	003fdd06 	br	811336f0 <__reset+0xfb1136f0>
8113377c:	0009883a 	mov	r4,zero
81133780:	003ff706 	br	81133760 <__reset+0xfb113760>

81133784 <__divdf3>:
81133784:	defff204 	addi	sp,sp,-56
81133788:	de00012e 	bgeu	sp,et,81133790 <__divdf3+0xc>
8113378c:	003b68fa 	trap	3
81133790:	dd400915 	stw	r21,36(sp)
81133794:	282ad53a 	srli	r21,r5,20
81133798:	dd000815 	stw	r20,32(sp)
8113379c:	2828d7fa 	srli	r20,r5,31
811337a0:	dc000415 	stw	r16,16(sp)
811337a4:	04000434 	movhi	r16,16
811337a8:	df000c15 	stw	fp,48(sp)
811337ac:	843fffc4 	addi	r16,r16,-1
811337b0:	dfc00d15 	stw	ra,52(sp)
811337b4:	ddc00b15 	stw	r23,44(sp)
811337b8:	dd800a15 	stw	r22,40(sp)
811337bc:	dcc00715 	stw	r19,28(sp)
811337c0:	dc800615 	stw	r18,24(sp)
811337c4:	dc400515 	stw	r17,20(sp)
811337c8:	ad41ffcc 	andi	r21,r21,2047
811337cc:	2c20703a 	and	r16,r5,r16
811337d0:	a7003fcc 	andi	fp,r20,255
811337d4:	a8006126 	beq	r21,zero,8113395c <__divdf3+0x1d8>
811337d8:	0081ffc4 	movi	r2,2047
811337dc:	2025883a 	mov	r18,r4
811337e0:	a8803726 	beq	r21,r2,811338c0 <__divdf3+0x13c>
811337e4:	80800434 	orhi	r2,r16,16
811337e8:	100490fa 	slli	r2,r2,3
811337ec:	2020d77a 	srli	r16,r4,29
811337f0:	202490fa 	slli	r18,r4,3
811337f4:	ad7f0044 	addi	r21,r21,-1023
811337f8:	80a0b03a 	or	r16,r16,r2
811337fc:	0027883a 	mov	r19,zero
81133800:	0013883a 	mov	r9,zero
81133804:	3804d53a 	srli	r2,r7,20
81133808:	382cd7fa 	srli	r22,r7,31
8113380c:	04400434 	movhi	r17,16
81133810:	8c7fffc4 	addi	r17,r17,-1
81133814:	1081ffcc 	andi	r2,r2,2047
81133818:	3011883a 	mov	r8,r6
8113381c:	3c62703a 	and	r17,r7,r17
81133820:	b5c03fcc 	andi	r23,r22,255
81133824:	10006c26 	beq	r2,zero,811339d8 <__divdf3+0x254>
81133828:	00c1ffc4 	movi	r3,2047
8113382c:	10c06426 	beq	r2,r3,811339c0 <__divdf3+0x23c>
81133830:	88c00434 	orhi	r3,r17,16
81133834:	180690fa 	slli	r3,r3,3
81133838:	3022d77a 	srli	r17,r6,29
8113383c:	301090fa 	slli	r8,r6,3
81133840:	10bf0044 	addi	r2,r2,-1023
81133844:	88e2b03a 	or	r17,r17,r3
81133848:	000f883a 	mov	r7,zero
8113384c:	a58cf03a 	xor	r6,r20,r22
81133850:	3cc8b03a 	or	r4,r7,r19
81133854:	a8abc83a 	sub	r21,r21,r2
81133858:	008003c4 	movi	r2,15
8113385c:	3007883a 	mov	r3,r6
81133860:	34c03fcc 	andi	r19,r6,255
81133864:	11009036 	bltu	r2,r4,81133aa8 <__divdf3+0x324>
81133868:	200890ba 	slli	r4,r4,2
8113386c:	00a044f4 	movhi	r2,33043
81133870:	108e2004 	addi	r2,r2,14464
81133874:	2089883a 	add	r4,r4,r2
81133878:	20800017 	ldw	r2,0(r4)
8113387c:	1000683a 	jmp	r2
81133880:	81133aa8 	cmpgeui	r4,r16,19690
81133884:	811338f8 	rdprs	r4,r16,19683
81133888:	81133a98 	cmpnei	r4,r16,19690
8113388c:	811338ec 	andhi	r4,r16,19683
81133890:	81133a98 	cmpnei	r4,r16,19690
81133894:	81133a6c 	andhi	r4,r16,19689
81133898:	81133a98 	cmpnei	r4,r16,19690
8113389c:	811338ec 	andhi	r4,r16,19683
811338a0:	811338f8 	rdprs	r4,r16,19683
811338a4:	811338f8 	rdprs	r4,r16,19683
811338a8:	81133a6c 	andhi	r4,r16,19689
811338ac:	811338ec 	andhi	r4,r16,19683
811338b0:	811338dc 	xori	r4,r16,19683
811338b4:	811338dc 	xori	r4,r16,19683
811338b8:	811338dc 	xori	r4,r16,19683
811338bc:	81133d8c 	andi	r4,r16,19702
811338c0:	2404b03a 	or	r2,r4,r16
811338c4:	1000661e 	bne	r2,zero,81133a60 <__divdf3+0x2dc>
811338c8:	04c00204 	movi	r19,8
811338cc:	0021883a 	mov	r16,zero
811338d0:	0025883a 	mov	r18,zero
811338d4:	02400084 	movi	r9,2
811338d8:	003fca06 	br	81133804 <__reset+0xfb113804>
811338dc:	8023883a 	mov	r17,r16
811338e0:	9011883a 	mov	r8,r18
811338e4:	e02f883a 	mov	r23,fp
811338e8:	480f883a 	mov	r7,r9
811338ec:	00800084 	movi	r2,2
811338f0:	3881311e 	bne	r7,r2,81133db8 <__divdf3+0x634>
811338f4:	b827883a 	mov	r19,r23
811338f8:	98c0004c 	andi	r3,r19,1
811338fc:	0081ffc4 	movi	r2,2047
81133900:	000b883a 	mov	r5,zero
81133904:	0025883a 	mov	r18,zero
81133908:	1004953a 	slli	r2,r2,20
8113390c:	18c03fcc 	andi	r3,r3,255
81133910:	04400434 	movhi	r17,16
81133914:	8c7fffc4 	addi	r17,r17,-1
81133918:	180697fa 	slli	r3,r3,31
8113391c:	2c4a703a 	and	r5,r5,r17
81133920:	288ab03a 	or	r5,r5,r2
81133924:	28c6b03a 	or	r3,r5,r3
81133928:	9005883a 	mov	r2,r18
8113392c:	dfc00d17 	ldw	ra,52(sp)
81133930:	df000c17 	ldw	fp,48(sp)
81133934:	ddc00b17 	ldw	r23,44(sp)
81133938:	dd800a17 	ldw	r22,40(sp)
8113393c:	dd400917 	ldw	r21,36(sp)
81133940:	dd000817 	ldw	r20,32(sp)
81133944:	dcc00717 	ldw	r19,28(sp)
81133948:	dc800617 	ldw	r18,24(sp)
8113394c:	dc400517 	ldw	r17,20(sp)
81133950:	dc000417 	ldw	r16,16(sp)
81133954:	dec00e04 	addi	sp,sp,56
81133958:	f800283a 	ret
8113395c:	2404b03a 	or	r2,r4,r16
81133960:	2027883a 	mov	r19,r4
81133964:	10003926 	beq	r2,zero,81133a4c <__divdf3+0x2c8>
81133968:	80012e26 	beq	r16,zero,81133e24 <__divdf3+0x6a0>
8113396c:	8009883a 	mov	r4,r16
81133970:	d9800315 	stw	r6,12(sp)
81133974:	d9c00215 	stw	r7,8(sp)
81133978:	111f43c0 	call	8111f43c <__clzsi2>
8113397c:	d9800317 	ldw	r6,12(sp)
81133980:	d9c00217 	ldw	r7,8(sp)
81133984:	113ffd44 	addi	r4,r2,-11
81133988:	00c00704 	movi	r3,28
8113398c:	19012116 	blt	r3,r4,81133e14 <__divdf3+0x690>
81133990:	00c00744 	movi	r3,29
81133994:	147ffe04 	addi	r17,r2,-8
81133998:	1907c83a 	sub	r3,r3,r4
8113399c:	8460983a 	sll	r16,r16,r17
811339a0:	98c6d83a 	srl	r3,r19,r3
811339a4:	9c64983a 	sll	r18,r19,r17
811339a8:	1c20b03a 	or	r16,r3,r16
811339ac:	1080fcc4 	addi	r2,r2,1011
811339b0:	00abc83a 	sub	r21,zero,r2
811339b4:	0027883a 	mov	r19,zero
811339b8:	0013883a 	mov	r9,zero
811339bc:	003f9106 	br	81133804 <__reset+0xfb113804>
811339c0:	3446b03a 	or	r3,r6,r17
811339c4:	18001f1e 	bne	r3,zero,81133a44 <__divdf3+0x2c0>
811339c8:	0023883a 	mov	r17,zero
811339cc:	0011883a 	mov	r8,zero
811339d0:	01c00084 	movi	r7,2
811339d4:	003f9d06 	br	8113384c <__reset+0xfb11384c>
811339d8:	3446b03a 	or	r3,r6,r17
811339dc:	18001526 	beq	r3,zero,81133a34 <__divdf3+0x2b0>
811339e0:	88011b26 	beq	r17,zero,81133e50 <__divdf3+0x6cc>
811339e4:	8809883a 	mov	r4,r17
811339e8:	d9800315 	stw	r6,12(sp)
811339ec:	da400115 	stw	r9,4(sp)
811339f0:	111f43c0 	call	8111f43c <__clzsi2>
811339f4:	d9800317 	ldw	r6,12(sp)
811339f8:	da400117 	ldw	r9,4(sp)
811339fc:	113ffd44 	addi	r4,r2,-11
81133a00:	00c00704 	movi	r3,28
81133a04:	19010e16 	blt	r3,r4,81133e40 <__divdf3+0x6bc>
81133a08:	00c00744 	movi	r3,29
81133a0c:	123ffe04 	addi	r8,r2,-8
81133a10:	1907c83a 	sub	r3,r3,r4
81133a14:	8a22983a 	sll	r17,r17,r8
81133a18:	30c6d83a 	srl	r3,r6,r3
81133a1c:	3210983a 	sll	r8,r6,r8
81133a20:	1c62b03a 	or	r17,r3,r17
81133a24:	1080fcc4 	addi	r2,r2,1011
81133a28:	0085c83a 	sub	r2,zero,r2
81133a2c:	000f883a 	mov	r7,zero
81133a30:	003f8606 	br	8113384c <__reset+0xfb11384c>
81133a34:	0023883a 	mov	r17,zero
81133a38:	0011883a 	mov	r8,zero
81133a3c:	01c00044 	movi	r7,1
81133a40:	003f8206 	br	8113384c <__reset+0xfb11384c>
81133a44:	01c000c4 	movi	r7,3
81133a48:	003f8006 	br	8113384c <__reset+0xfb11384c>
81133a4c:	04c00104 	movi	r19,4
81133a50:	0021883a 	mov	r16,zero
81133a54:	0025883a 	mov	r18,zero
81133a58:	02400044 	movi	r9,1
81133a5c:	003f6906 	br	81133804 <__reset+0xfb113804>
81133a60:	04c00304 	movi	r19,12
81133a64:	024000c4 	movi	r9,3
81133a68:	003f6606 	br	81133804 <__reset+0xfb113804>
81133a6c:	01400434 	movhi	r5,16
81133a70:	0007883a 	mov	r3,zero
81133a74:	297fffc4 	addi	r5,r5,-1
81133a78:	04bfffc4 	movi	r18,-1
81133a7c:	0081ffc4 	movi	r2,2047
81133a80:	003fa106 	br	81133908 <__reset+0xfb113908>
81133a84:	00c00044 	movi	r3,1
81133a88:	1887c83a 	sub	r3,r3,r2
81133a8c:	01000e04 	movi	r4,56
81133a90:	20c1210e 	bge	r4,r3,81133f18 <__divdf3+0x794>
81133a94:	98c0004c 	andi	r3,r19,1
81133a98:	0005883a 	mov	r2,zero
81133a9c:	000b883a 	mov	r5,zero
81133aa0:	0025883a 	mov	r18,zero
81133aa4:	003f9806 	br	81133908 <__reset+0xfb113908>
81133aa8:	8c00fd36 	bltu	r17,r16,81133ea0 <__divdf3+0x71c>
81133aac:	8440fb26 	beq	r16,r17,81133e9c <__divdf3+0x718>
81133ab0:	8007883a 	mov	r3,r16
81133ab4:	ad7fffc4 	addi	r21,r21,-1
81133ab8:	0021883a 	mov	r16,zero
81133abc:	4004d63a 	srli	r2,r8,24
81133ac0:	8822923a 	slli	r17,r17,8
81133ac4:	1809883a 	mov	r4,r3
81133ac8:	402c923a 	slli	r22,r8,8
81133acc:	88b8b03a 	or	fp,r17,r2
81133ad0:	e028d43a 	srli	r20,fp,16
81133ad4:	d8c00015 	stw	r3,0(sp)
81133ad8:	e5ffffcc 	andi	r23,fp,65535
81133adc:	a00b883a 	mov	r5,r20
81133ae0:	1132c180 	call	81132c18 <__udivsi3>
81133ae4:	d8c00017 	ldw	r3,0(sp)
81133ae8:	a00b883a 	mov	r5,r20
81133aec:	d8800315 	stw	r2,12(sp)
81133af0:	1809883a 	mov	r4,r3
81133af4:	1132c7c0 	call	81132c7c <__umodsi3>
81133af8:	d9800317 	ldw	r6,12(sp)
81133afc:	1006943a 	slli	r3,r2,16
81133b00:	9004d43a 	srli	r2,r18,16
81133b04:	b9a3383a 	mul	r17,r23,r6
81133b08:	10c4b03a 	or	r2,r2,r3
81133b0c:	1440062e 	bgeu	r2,r17,81133b28 <__divdf3+0x3a4>
81133b10:	1705883a 	add	r2,r2,fp
81133b14:	30ffffc4 	addi	r3,r6,-1
81133b18:	1700ee36 	bltu	r2,fp,81133ed4 <__divdf3+0x750>
81133b1c:	1440ed2e 	bgeu	r2,r17,81133ed4 <__divdf3+0x750>
81133b20:	31bfff84 	addi	r6,r6,-2
81133b24:	1705883a 	add	r2,r2,fp
81133b28:	1463c83a 	sub	r17,r2,r17
81133b2c:	a00b883a 	mov	r5,r20
81133b30:	8809883a 	mov	r4,r17
81133b34:	d9800315 	stw	r6,12(sp)
81133b38:	1132c180 	call	81132c18 <__udivsi3>
81133b3c:	a00b883a 	mov	r5,r20
81133b40:	8809883a 	mov	r4,r17
81133b44:	d8800215 	stw	r2,8(sp)
81133b48:	1132c7c0 	call	81132c7c <__umodsi3>
81133b4c:	d9c00217 	ldw	r7,8(sp)
81133b50:	1004943a 	slli	r2,r2,16
81133b54:	94bfffcc 	andi	r18,r18,65535
81133b58:	b9d1383a 	mul	r8,r23,r7
81133b5c:	90a4b03a 	or	r18,r18,r2
81133b60:	d9800317 	ldw	r6,12(sp)
81133b64:	9200062e 	bgeu	r18,r8,81133b80 <__divdf3+0x3fc>
81133b68:	9725883a 	add	r18,r18,fp
81133b6c:	38bfffc4 	addi	r2,r7,-1
81133b70:	9700d636 	bltu	r18,fp,81133ecc <__divdf3+0x748>
81133b74:	9200d52e 	bgeu	r18,r8,81133ecc <__divdf3+0x748>
81133b78:	39ffff84 	addi	r7,r7,-2
81133b7c:	9725883a 	add	r18,r18,fp
81133b80:	3004943a 	slli	r2,r6,16
81133b84:	b012d43a 	srli	r9,r22,16
81133b88:	b1bfffcc 	andi	r6,r22,65535
81133b8c:	11e2b03a 	or	r17,r2,r7
81133b90:	8806d43a 	srli	r3,r17,16
81133b94:	893fffcc 	andi	r4,r17,65535
81133b98:	218b383a 	mul	r5,r4,r6
81133b9c:	30c5383a 	mul	r2,r6,r3
81133ba0:	2249383a 	mul	r4,r4,r9
81133ba4:	280ed43a 	srli	r7,r5,16
81133ba8:	9225c83a 	sub	r18,r18,r8
81133bac:	2089883a 	add	r4,r4,r2
81133bb0:	3909883a 	add	r4,r7,r4
81133bb4:	1a47383a 	mul	r3,r3,r9
81133bb8:	2080022e 	bgeu	r4,r2,81133bc4 <__divdf3+0x440>
81133bbc:	00800074 	movhi	r2,1
81133bc0:	1887883a 	add	r3,r3,r2
81133bc4:	2004d43a 	srli	r2,r4,16
81133bc8:	2008943a 	slli	r4,r4,16
81133bcc:	297fffcc 	andi	r5,r5,65535
81133bd0:	10c7883a 	add	r3,r2,r3
81133bd4:	2149883a 	add	r4,r4,r5
81133bd8:	90c0a536 	bltu	r18,r3,81133e70 <__divdf3+0x6ec>
81133bdc:	90c0bf26 	beq	r18,r3,81133edc <__divdf3+0x758>
81133be0:	90c7c83a 	sub	r3,r18,r3
81133be4:	810fc83a 	sub	r7,r16,r4
81133be8:	81e5803a 	cmpltu	r18,r16,r7
81133bec:	1ca5c83a 	sub	r18,r3,r18
81133bf0:	e480c126 	beq	fp,r18,81133ef8 <__divdf3+0x774>
81133bf4:	a00b883a 	mov	r5,r20
81133bf8:	9009883a 	mov	r4,r18
81133bfc:	d9800315 	stw	r6,12(sp)
81133c00:	d9c00215 	stw	r7,8(sp)
81133c04:	da400115 	stw	r9,4(sp)
81133c08:	1132c180 	call	81132c18 <__udivsi3>
81133c0c:	a00b883a 	mov	r5,r20
81133c10:	9009883a 	mov	r4,r18
81133c14:	d8800015 	stw	r2,0(sp)
81133c18:	1132c7c0 	call	81132c7c <__umodsi3>
81133c1c:	d9c00217 	ldw	r7,8(sp)
81133c20:	da000017 	ldw	r8,0(sp)
81133c24:	1006943a 	slli	r3,r2,16
81133c28:	3804d43a 	srli	r2,r7,16
81133c2c:	ba21383a 	mul	r16,r23,r8
81133c30:	d9800317 	ldw	r6,12(sp)
81133c34:	10c4b03a 	or	r2,r2,r3
81133c38:	da400117 	ldw	r9,4(sp)
81133c3c:	1400062e 	bgeu	r2,r16,81133c58 <__divdf3+0x4d4>
81133c40:	1705883a 	add	r2,r2,fp
81133c44:	40ffffc4 	addi	r3,r8,-1
81133c48:	1700ad36 	bltu	r2,fp,81133f00 <__divdf3+0x77c>
81133c4c:	1400ac2e 	bgeu	r2,r16,81133f00 <__divdf3+0x77c>
81133c50:	423fff84 	addi	r8,r8,-2
81133c54:	1705883a 	add	r2,r2,fp
81133c58:	1421c83a 	sub	r16,r2,r16
81133c5c:	a00b883a 	mov	r5,r20
81133c60:	8009883a 	mov	r4,r16
81133c64:	d9800315 	stw	r6,12(sp)
81133c68:	d9c00215 	stw	r7,8(sp)
81133c6c:	da000015 	stw	r8,0(sp)
81133c70:	da400115 	stw	r9,4(sp)
81133c74:	1132c180 	call	81132c18 <__udivsi3>
81133c78:	8009883a 	mov	r4,r16
81133c7c:	a00b883a 	mov	r5,r20
81133c80:	1025883a 	mov	r18,r2
81133c84:	1132c7c0 	call	81132c7c <__umodsi3>
81133c88:	d9c00217 	ldw	r7,8(sp)
81133c8c:	1004943a 	slli	r2,r2,16
81133c90:	bcaf383a 	mul	r23,r23,r18
81133c94:	393fffcc 	andi	r4,r7,65535
81133c98:	2088b03a 	or	r4,r4,r2
81133c9c:	d9800317 	ldw	r6,12(sp)
81133ca0:	da000017 	ldw	r8,0(sp)
81133ca4:	da400117 	ldw	r9,4(sp)
81133ca8:	25c0062e 	bgeu	r4,r23,81133cc4 <__divdf3+0x540>
81133cac:	2709883a 	add	r4,r4,fp
81133cb0:	90bfffc4 	addi	r2,r18,-1
81133cb4:	27009436 	bltu	r4,fp,81133f08 <__divdf3+0x784>
81133cb8:	25c0932e 	bgeu	r4,r23,81133f08 <__divdf3+0x784>
81133cbc:	94bfff84 	addi	r18,r18,-2
81133cc0:	2709883a 	add	r4,r4,fp
81133cc4:	4004943a 	slli	r2,r8,16
81133cc8:	25efc83a 	sub	r23,r4,r23
81133ccc:	1490b03a 	or	r8,r2,r18
81133cd0:	4008d43a 	srli	r4,r8,16
81133cd4:	40ffffcc 	andi	r3,r8,65535
81133cd8:	30c5383a 	mul	r2,r6,r3
81133cdc:	1a47383a 	mul	r3,r3,r9
81133ce0:	310d383a 	mul	r6,r6,r4
81133ce4:	100ad43a 	srli	r5,r2,16
81133ce8:	4913383a 	mul	r9,r9,r4
81133cec:	1987883a 	add	r3,r3,r6
81133cf0:	28c7883a 	add	r3,r5,r3
81133cf4:	1980022e 	bgeu	r3,r6,81133d00 <__divdf3+0x57c>
81133cf8:	01000074 	movhi	r4,1
81133cfc:	4913883a 	add	r9,r9,r4
81133d00:	1808d43a 	srli	r4,r3,16
81133d04:	1806943a 	slli	r3,r3,16
81133d08:	10bfffcc 	andi	r2,r2,65535
81133d0c:	2253883a 	add	r9,r4,r9
81133d10:	1887883a 	add	r3,r3,r2
81133d14:	ba403836 	bltu	r23,r9,81133df8 <__divdf3+0x674>
81133d18:	ba403626 	beq	r23,r9,81133df4 <__divdf3+0x670>
81133d1c:	42000054 	ori	r8,r8,1
81133d20:	a880ffc4 	addi	r2,r21,1023
81133d24:	00bf570e 	bge	zero,r2,81133a84 <__reset+0xfb113a84>
81133d28:	40c001cc 	andi	r3,r8,7
81133d2c:	18000726 	beq	r3,zero,81133d4c <__divdf3+0x5c8>
81133d30:	40c003cc 	andi	r3,r8,15
81133d34:	01000104 	movi	r4,4
81133d38:	19000426 	beq	r3,r4,81133d4c <__divdf3+0x5c8>
81133d3c:	4107883a 	add	r3,r8,r4
81133d40:	1a11803a 	cmpltu	r8,r3,r8
81133d44:	8a23883a 	add	r17,r17,r8
81133d48:	1811883a 	mov	r8,r3
81133d4c:	88c0402c 	andhi	r3,r17,256
81133d50:	18000426 	beq	r3,zero,81133d64 <__divdf3+0x5e0>
81133d54:	00ffc034 	movhi	r3,65280
81133d58:	18ffffc4 	addi	r3,r3,-1
81133d5c:	a8810004 	addi	r2,r21,1024
81133d60:	88e2703a 	and	r17,r17,r3
81133d64:	00c1ff84 	movi	r3,2046
81133d68:	18bee316 	blt	r3,r2,811338f8 <__reset+0xfb1138f8>
81133d6c:	8824977a 	slli	r18,r17,29
81133d70:	4010d0fa 	srli	r8,r8,3
81133d74:	8822927a 	slli	r17,r17,9
81133d78:	1081ffcc 	andi	r2,r2,2047
81133d7c:	9224b03a 	or	r18,r18,r8
81133d80:	880ad33a 	srli	r5,r17,12
81133d84:	98c0004c 	andi	r3,r19,1
81133d88:	003edf06 	br	81133908 <__reset+0xfb113908>
81133d8c:	8080022c 	andhi	r2,r16,8
81133d90:	10001226 	beq	r2,zero,81133ddc <__divdf3+0x658>
81133d94:	8880022c 	andhi	r2,r17,8
81133d98:	1000101e 	bne	r2,zero,81133ddc <__divdf3+0x658>
81133d9c:	00800434 	movhi	r2,16
81133da0:	89400234 	orhi	r5,r17,8
81133da4:	10bfffc4 	addi	r2,r2,-1
81133da8:	b007883a 	mov	r3,r22
81133dac:	288a703a 	and	r5,r5,r2
81133db0:	4025883a 	mov	r18,r8
81133db4:	003f3106 	br	81133a7c <__reset+0xfb113a7c>
81133db8:	008000c4 	movi	r2,3
81133dbc:	3880a626 	beq	r7,r2,81134058 <__divdf3+0x8d4>
81133dc0:	00800044 	movi	r2,1
81133dc4:	3880521e 	bne	r7,r2,81133f10 <__divdf3+0x78c>
81133dc8:	b807883a 	mov	r3,r23
81133dcc:	0005883a 	mov	r2,zero
81133dd0:	000b883a 	mov	r5,zero
81133dd4:	0025883a 	mov	r18,zero
81133dd8:	003ecb06 	br	81133908 <__reset+0xfb113908>
81133ddc:	00800434 	movhi	r2,16
81133de0:	81400234 	orhi	r5,r16,8
81133de4:	10bfffc4 	addi	r2,r2,-1
81133de8:	a007883a 	mov	r3,r20
81133dec:	288a703a 	and	r5,r5,r2
81133df0:	003f2206 	br	81133a7c <__reset+0xfb113a7c>
81133df4:	183fca26 	beq	r3,zero,81133d20 <__reset+0xfb113d20>
81133df8:	e5ef883a 	add	r23,fp,r23
81133dfc:	40bfffc4 	addi	r2,r8,-1
81133e00:	bf00392e 	bgeu	r23,fp,81133ee8 <__divdf3+0x764>
81133e04:	1011883a 	mov	r8,r2
81133e08:	ba7fc41e 	bne	r23,r9,81133d1c <__reset+0xfb113d1c>
81133e0c:	b0ffc31e 	bne	r22,r3,81133d1c <__reset+0xfb113d1c>
81133e10:	003fc306 	br	81133d20 <__reset+0xfb113d20>
81133e14:	143ff604 	addi	r16,r2,-40
81133e18:	9c20983a 	sll	r16,r19,r16
81133e1c:	0025883a 	mov	r18,zero
81133e20:	003ee206 	br	811339ac <__reset+0xfb1139ac>
81133e24:	d9800315 	stw	r6,12(sp)
81133e28:	d9c00215 	stw	r7,8(sp)
81133e2c:	111f43c0 	call	8111f43c <__clzsi2>
81133e30:	10800804 	addi	r2,r2,32
81133e34:	d9c00217 	ldw	r7,8(sp)
81133e38:	d9800317 	ldw	r6,12(sp)
81133e3c:	003ed106 	br	81133984 <__reset+0xfb113984>
81133e40:	147ff604 	addi	r17,r2,-40
81133e44:	3462983a 	sll	r17,r6,r17
81133e48:	0011883a 	mov	r8,zero
81133e4c:	003ef506 	br	81133a24 <__reset+0xfb113a24>
81133e50:	3009883a 	mov	r4,r6
81133e54:	d9800315 	stw	r6,12(sp)
81133e58:	da400115 	stw	r9,4(sp)
81133e5c:	111f43c0 	call	8111f43c <__clzsi2>
81133e60:	10800804 	addi	r2,r2,32
81133e64:	da400117 	ldw	r9,4(sp)
81133e68:	d9800317 	ldw	r6,12(sp)
81133e6c:	003ee306 	br	811339fc <__reset+0xfb1139fc>
81133e70:	85a1883a 	add	r16,r16,r22
81133e74:	8585803a 	cmpltu	r2,r16,r22
81133e78:	1705883a 	add	r2,r2,fp
81133e7c:	14a5883a 	add	r18,r2,r18
81133e80:	88bfffc4 	addi	r2,r17,-1
81133e84:	e4800c2e 	bgeu	fp,r18,81133eb8 <__divdf3+0x734>
81133e88:	90c03e36 	bltu	r18,r3,81133f84 <__divdf3+0x800>
81133e8c:	1c806926 	beq	r3,r18,81134034 <__divdf3+0x8b0>
81133e90:	90c7c83a 	sub	r3,r18,r3
81133e94:	1023883a 	mov	r17,r2
81133e98:	003f5206 	br	81133be4 <__reset+0xfb113be4>
81133e9c:	923f0436 	bltu	r18,r8,81133ab0 <__reset+0xfb113ab0>
81133ea0:	800897fa 	slli	r4,r16,31
81133ea4:	9004d07a 	srli	r2,r18,1
81133ea8:	8006d07a 	srli	r3,r16,1
81133eac:	902097fa 	slli	r16,r18,31
81133eb0:	20a4b03a 	or	r18,r4,r2
81133eb4:	003f0106 	br	81133abc <__reset+0xfb113abc>
81133eb8:	e4bff51e 	bne	fp,r18,81133e90 <__reset+0xfb113e90>
81133ebc:	85bff22e 	bgeu	r16,r22,81133e88 <__reset+0xfb113e88>
81133ec0:	e0c7c83a 	sub	r3,fp,r3
81133ec4:	1023883a 	mov	r17,r2
81133ec8:	003f4606 	br	81133be4 <__reset+0xfb113be4>
81133ecc:	100f883a 	mov	r7,r2
81133ed0:	003f2b06 	br	81133b80 <__reset+0xfb113b80>
81133ed4:	180d883a 	mov	r6,r3
81133ed8:	003f1306 	br	81133b28 <__reset+0xfb113b28>
81133edc:	813fe436 	bltu	r16,r4,81133e70 <__reset+0xfb113e70>
81133ee0:	0007883a 	mov	r3,zero
81133ee4:	003f3f06 	br	81133be4 <__reset+0xfb113be4>
81133ee8:	ba402c36 	bltu	r23,r9,81133f9c <__divdf3+0x818>
81133eec:	4dc05426 	beq	r9,r23,81134040 <__divdf3+0x8bc>
81133ef0:	1011883a 	mov	r8,r2
81133ef4:	003f8906 	br	81133d1c <__reset+0xfb113d1c>
81133ef8:	023fffc4 	movi	r8,-1
81133efc:	003f8806 	br	81133d20 <__reset+0xfb113d20>
81133f00:	1811883a 	mov	r8,r3
81133f04:	003f5406 	br	81133c58 <__reset+0xfb113c58>
81133f08:	1025883a 	mov	r18,r2
81133f0c:	003f6d06 	br	81133cc4 <__reset+0xfb113cc4>
81133f10:	b827883a 	mov	r19,r23
81133f14:	003f8206 	br	81133d20 <__reset+0xfb113d20>
81133f18:	010007c4 	movi	r4,31
81133f1c:	20c02616 	blt	r4,r3,81133fb8 <__divdf3+0x834>
81133f20:	00800804 	movi	r2,32
81133f24:	10c5c83a 	sub	r2,r2,r3
81133f28:	888a983a 	sll	r5,r17,r2
81133f2c:	40c8d83a 	srl	r4,r8,r3
81133f30:	4084983a 	sll	r2,r8,r2
81133f34:	88e2d83a 	srl	r17,r17,r3
81133f38:	2906b03a 	or	r3,r5,r4
81133f3c:	1004c03a 	cmpne	r2,r2,zero
81133f40:	1886b03a 	or	r3,r3,r2
81133f44:	188001cc 	andi	r2,r3,7
81133f48:	10000726 	beq	r2,zero,81133f68 <__divdf3+0x7e4>
81133f4c:	188003cc 	andi	r2,r3,15
81133f50:	01000104 	movi	r4,4
81133f54:	11000426 	beq	r2,r4,81133f68 <__divdf3+0x7e4>
81133f58:	1805883a 	mov	r2,r3
81133f5c:	10c00104 	addi	r3,r2,4
81133f60:	1885803a 	cmpltu	r2,r3,r2
81133f64:	88a3883a 	add	r17,r17,r2
81133f68:	8880202c 	andhi	r2,r17,128
81133f6c:	10002726 	beq	r2,zero,8113400c <__divdf3+0x888>
81133f70:	98c0004c 	andi	r3,r19,1
81133f74:	00800044 	movi	r2,1
81133f78:	000b883a 	mov	r5,zero
81133f7c:	0025883a 	mov	r18,zero
81133f80:	003e6106 	br	81133908 <__reset+0xfb113908>
81133f84:	85a1883a 	add	r16,r16,r22
81133f88:	8585803a 	cmpltu	r2,r16,r22
81133f8c:	1705883a 	add	r2,r2,fp
81133f90:	14a5883a 	add	r18,r2,r18
81133f94:	8c7fff84 	addi	r17,r17,-2
81133f98:	003f1106 	br	81133be0 <__reset+0xfb113be0>
81133f9c:	b589883a 	add	r4,r22,r22
81133fa0:	25ad803a 	cmpltu	r22,r4,r22
81133fa4:	b739883a 	add	fp,r22,fp
81133fa8:	40bfff84 	addi	r2,r8,-2
81133fac:	bf2f883a 	add	r23,r23,fp
81133fb0:	202d883a 	mov	r22,r4
81133fb4:	003f9306 	br	81133e04 <__reset+0xfb113e04>
81133fb8:	013ff844 	movi	r4,-31
81133fbc:	2085c83a 	sub	r2,r4,r2
81133fc0:	8888d83a 	srl	r4,r17,r2
81133fc4:	00800804 	movi	r2,32
81133fc8:	18802126 	beq	r3,r2,81134050 <__divdf3+0x8cc>
81133fcc:	00801004 	movi	r2,64
81133fd0:	10c5c83a 	sub	r2,r2,r3
81133fd4:	8884983a 	sll	r2,r17,r2
81133fd8:	1204b03a 	or	r2,r2,r8
81133fdc:	1004c03a 	cmpne	r2,r2,zero
81133fe0:	2084b03a 	or	r2,r4,r2
81133fe4:	144001cc 	andi	r17,r2,7
81133fe8:	88000d1e 	bne	r17,zero,81134020 <__divdf3+0x89c>
81133fec:	000b883a 	mov	r5,zero
81133ff0:	1024d0fa 	srli	r18,r2,3
81133ff4:	98c0004c 	andi	r3,r19,1
81133ff8:	0005883a 	mov	r2,zero
81133ffc:	9464b03a 	or	r18,r18,r17
81134000:	003e4106 	br	81133908 <__reset+0xfb113908>
81134004:	1007883a 	mov	r3,r2
81134008:	0023883a 	mov	r17,zero
8113400c:	880a927a 	slli	r5,r17,9
81134010:	1805883a 	mov	r2,r3
81134014:	8822977a 	slli	r17,r17,29
81134018:	280ad33a 	srli	r5,r5,12
8113401c:	003ff406 	br	81133ff0 <__reset+0xfb113ff0>
81134020:	10c003cc 	andi	r3,r2,15
81134024:	01000104 	movi	r4,4
81134028:	193ff626 	beq	r3,r4,81134004 <__reset+0xfb114004>
8113402c:	0023883a 	mov	r17,zero
81134030:	003fca06 	br	81133f5c <__reset+0xfb113f5c>
81134034:	813fd336 	bltu	r16,r4,81133f84 <__reset+0xfb113f84>
81134038:	1023883a 	mov	r17,r2
8113403c:	003fa806 	br	81133ee0 <__reset+0xfb113ee0>
81134040:	b0ffd636 	bltu	r22,r3,81133f9c <__reset+0xfb113f9c>
81134044:	1011883a 	mov	r8,r2
81134048:	b0ff341e 	bne	r22,r3,81133d1c <__reset+0xfb113d1c>
8113404c:	003f3406 	br	81133d20 <__reset+0xfb113d20>
81134050:	0005883a 	mov	r2,zero
81134054:	003fe006 	br	81133fd8 <__reset+0xfb113fd8>
81134058:	00800434 	movhi	r2,16
8113405c:	89400234 	orhi	r5,r17,8
81134060:	10bfffc4 	addi	r2,r2,-1
81134064:	b807883a 	mov	r3,r23
81134068:	288a703a 	and	r5,r5,r2
8113406c:	4025883a 	mov	r18,r8
81134070:	003e8206 	br	81133a7c <__reset+0xfb113a7c>

81134074 <__eqdf2>:
81134074:	2804d53a 	srli	r2,r5,20
81134078:	3806d53a 	srli	r3,r7,20
8113407c:	02000434 	movhi	r8,16
81134080:	423fffc4 	addi	r8,r8,-1
81134084:	1081ffcc 	andi	r2,r2,2047
81134088:	0281ffc4 	movi	r10,2047
8113408c:	2a12703a 	and	r9,r5,r8
81134090:	18c1ffcc 	andi	r3,r3,2047
81134094:	3a10703a 	and	r8,r7,r8
81134098:	280ad7fa 	srli	r5,r5,31
8113409c:	380ed7fa 	srli	r7,r7,31
811340a0:	12801026 	beq	r2,r10,811340e4 <__eqdf2+0x70>
811340a4:	0281ffc4 	movi	r10,2047
811340a8:	1a800a26 	beq	r3,r10,811340d4 <__eqdf2+0x60>
811340ac:	10c00226 	beq	r2,r3,811340b8 <__eqdf2+0x44>
811340b0:	00800044 	movi	r2,1
811340b4:	f800283a 	ret
811340b8:	4a3ffd1e 	bne	r9,r8,811340b0 <__reset+0xfb1140b0>
811340bc:	21bffc1e 	bne	r4,r6,811340b0 <__reset+0xfb1140b0>
811340c0:	29c00c26 	beq	r5,r7,811340f4 <__eqdf2+0x80>
811340c4:	103ffa1e 	bne	r2,zero,811340b0 <__reset+0xfb1140b0>
811340c8:	2244b03a 	or	r2,r4,r9
811340cc:	1004c03a 	cmpne	r2,r2,zero
811340d0:	f800283a 	ret
811340d4:	3214b03a 	or	r10,r6,r8
811340d8:	503ff426 	beq	r10,zero,811340ac <__reset+0xfb1140ac>
811340dc:	00800044 	movi	r2,1
811340e0:	f800283a 	ret
811340e4:	2254b03a 	or	r10,r4,r9
811340e8:	503fee26 	beq	r10,zero,811340a4 <__reset+0xfb1140a4>
811340ec:	00800044 	movi	r2,1
811340f0:	f800283a 	ret
811340f4:	0005883a 	mov	r2,zero
811340f8:	f800283a 	ret

811340fc <__ledf2>:
811340fc:	2804d53a 	srli	r2,r5,20
81134100:	3810d53a 	srli	r8,r7,20
81134104:	00c00434 	movhi	r3,16
81134108:	18ffffc4 	addi	r3,r3,-1
8113410c:	1081ffcc 	andi	r2,r2,2047
81134110:	0241ffc4 	movi	r9,2047
81134114:	28d4703a 	and	r10,r5,r3
81134118:	4201ffcc 	andi	r8,r8,2047
8113411c:	38c6703a 	and	r3,r7,r3
81134120:	280ad7fa 	srli	r5,r5,31
81134124:	380ed7fa 	srli	r7,r7,31
81134128:	12401f26 	beq	r2,r9,811341a8 <__ledf2+0xac>
8113412c:	0241ffc4 	movi	r9,2047
81134130:	42401426 	beq	r8,r9,81134184 <__ledf2+0x88>
81134134:	1000091e 	bne	r2,zero,8113415c <__ledf2+0x60>
81134138:	2296b03a 	or	r11,r4,r10
8113413c:	5813003a 	cmpeq	r9,r11,zero
81134140:	29403fcc 	andi	r5,r5,255
81134144:	40000a1e 	bne	r8,zero,81134170 <__ledf2+0x74>
81134148:	30d8b03a 	or	r12,r6,r3
8113414c:	6000081e 	bne	r12,zero,81134170 <__ledf2+0x74>
81134150:	0005883a 	mov	r2,zero
81134154:	5800111e 	bne	r11,zero,8113419c <__ledf2+0xa0>
81134158:	f800283a 	ret
8113415c:	29403fcc 	andi	r5,r5,255
81134160:	40000c1e 	bne	r8,zero,81134194 <__ledf2+0x98>
81134164:	30d2b03a 	or	r9,r6,r3
81134168:	48000c26 	beq	r9,zero,8113419c <__ledf2+0xa0>
8113416c:	0013883a 	mov	r9,zero
81134170:	39c03fcc 	andi	r7,r7,255
81134174:	48000826 	beq	r9,zero,81134198 <__ledf2+0x9c>
81134178:	38001126 	beq	r7,zero,811341c0 <__ledf2+0xc4>
8113417c:	00800044 	movi	r2,1
81134180:	f800283a 	ret
81134184:	30d2b03a 	or	r9,r6,r3
81134188:	483fea26 	beq	r9,zero,81134134 <__reset+0xfb114134>
8113418c:	00800084 	movi	r2,2
81134190:	f800283a 	ret
81134194:	39c03fcc 	andi	r7,r7,255
81134198:	39400726 	beq	r7,r5,811341b8 <__ledf2+0xbc>
8113419c:	2800081e 	bne	r5,zero,811341c0 <__ledf2+0xc4>
811341a0:	00800044 	movi	r2,1
811341a4:	f800283a 	ret
811341a8:	2292b03a 	or	r9,r4,r10
811341ac:	483fdf26 	beq	r9,zero,8113412c <__reset+0xfb11412c>
811341b0:	00800084 	movi	r2,2
811341b4:	f800283a 	ret
811341b8:	4080030e 	bge	r8,r2,811341c8 <__ledf2+0xcc>
811341bc:	383fef26 	beq	r7,zero,8113417c <__reset+0xfb11417c>
811341c0:	00bfffc4 	movi	r2,-1
811341c4:	f800283a 	ret
811341c8:	123feb16 	blt	r2,r8,81134178 <__reset+0xfb114178>
811341cc:	1abff336 	bltu	r3,r10,8113419c <__reset+0xfb11419c>
811341d0:	50c00326 	beq	r10,r3,811341e0 <__ledf2+0xe4>
811341d4:	50c0042e 	bgeu	r10,r3,811341e8 <__ledf2+0xec>
811341d8:	283fe81e 	bne	r5,zero,8113417c <__reset+0xfb11417c>
811341dc:	003ff806 	br	811341c0 <__reset+0xfb1141c0>
811341e0:	313fee36 	bltu	r6,r4,8113419c <__reset+0xfb11419c>
811341e4:	21bffc36 	bltu	r4,r6,811341d8 <__reset+0xfb1141d8>
811341e8:	0005883a 	mov	r2,zero
811341ec:	f800283a 	ret

811341f0 <__floatunsidf>:
811341f0:	defffe04 	addi	sp,sp,-8
811341f4:	de00012e 	bgeu	sp,et,811341fc <__floatunsidf+0xc>
811341f8:	003b68fa 	trap	3
811341fc:	dc000015 	stw	r16,0(sp)
81134200:	dfc00115 	stw	ra,4(sp)
81134204:	2021883a 	mov	r16,r4
81134208:	20002226 	beq	r4,zero,81134294 <__floatunsidf+0xa4>
8113420c:	111f43c0 	call	8111f43c <__clzsi2>
81134210:	01010784 	movi	r4,1054
81134214:	2089c83a 	sub	r4,r4,r2
81134218:	01810cc4 	movi	r6,1075
8113421c:	310dc83a 	sub	r6,r6,r4
81134220:	00c007c4 	movi	r3,31
81134224:	1980120e 	bge	r3,r6,81134270 <__floatunsidf+0x80>
81134228:	00c104c4 	movi	r3,1043
8113422c:	1907c83a 	sub	r3,r3,r4
81134230:	80ca983a 	sll	r5,r16,r3
81134234:	00800434 	movhi	r2,16
81134238:	10bfffc4 	addi	r2,r2,-1
8113423c:	2101ffcc 	andi	r4,r4,2047
81134240:	0021883a 	mov	r16,zero
81134244:	288a703a 	and	r5,r5,r2
81134248:	2008953a 	slli	r4,r4,20
8113424c:	00c00434 	movhi	r3,16
81134250:	18ffffc4 	addi	r3,r3,-1
81134254:	28c6703a 	and	r3,r5,r3
81134258:	8005883a 	mov	r2,r16
8113425c:	1906b03a 	or	r3,r3,r4
81134260:	dfc00117 	ldw	ra,4(sp)
81134264:	dc000017 	ldw	r16,0(sp)
81134268:	dec00204 	addi	sp,sp,8
8113426c:	f800283a 	ret
81134270:	00c002c4 	movi	r3,11
81134274:	188bc83a 	sub	r5,r3,r2
81134278:	814ad83a 	srl	r5,r16,r5
8113427c:	00c00434 	movhi	r3,16
81134280:	18ffffc4 	addi	r3,r3,-1
81134284:	81a0983a 	sll	r16,r16,r6
81134288:	2101ffcc 	andi	r4,r4,2047
8113428c:	28ca703a 	and	r5,r5,r3
81134290:	003fed06 	br	81134248 <__reset+0xfb114248>
81134294:	0009883a 	mov	r4,zero
81134298:	000b883a 	mov	r5,zero
8113429c:	003fea06 	br	81134248 <__reset+0xfb114248>

811342a0 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
811342a0:	defffb04 	addi	sp,sp,-20
811342a4:	de00012e 	bgeu	sp,et,811342ac <alt_busy_sleep+0xc>
811342a8:	003b68fa 	trap	3
811342ac:	df000415 	stw	fp,16(sp)
811342b0:	df000404 	addi	fp,sp,16
811342b4:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
811342b8:	008000c4 	movi	r2,3
811342bc:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
811342c0:	e0fffd17 	ldw	r3,-12(fp)
811342c4:	008003f4 	movhi	r2,15
811342c8:	10909004 	addi	r2,r2,16960
811342cc:	1887383a 	mul	r3,r3,r2
811342d0:	00817db4 	movhi	r2,1526
811342d4:	10b84004 	addi	r2,r2,-7936
811342d8:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
811342dc:	00a00034 	movhi	r2,32768
811342e0:	10bfffc4 	addi	r2,r2,-1
811342e4:	10c5203a 	divu	r2,r2,r3
811342e8:	e0ffff17 	ldw	r3,-4(fp)
811342ec:	1885203a 	divu	r2,r3,r2
811342f0:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811342f4:	e0bffe17 	ldw	r2,-8(fp)
811342f8:	10002526 	beq	r2,zero,81134390 <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811342fc:	e03ffc15 	stw	zero,-16(fp)
81134300:	00001406 	br	81134354 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
81134304:	00a00034 	movhi	r2,32768
81134308:	10bfffc4 	addi	r2,r2,-1
8113430c:	10bfffc4 	addi	r2,r2,-1
81134310:	103ffe1e 	bne	r2,zero,8113430c <__reset+0xfb11430c>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
81134314:	e0fffd17 	ldw	r3,-12(fp)
81134318:	008003f4 	movhi	r2,15
8113431c:	10909004 	addi	r2,r2,16960
81134320:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81134324:	00817db4 	movhi	r2,1526
81134328:	10b84004 	addi	r2,r2,-7936
8113432c:	10c7203a 	divu	r3,r2,r3
81134330:	00a00034 	movhi	r2,32768
81134334:	10bfffc4 	addi	r2,r2,-1
81134338:	10c5203a 	divu	r2,r2,r3
8113433c:	e0ffff17 	ldw	r3,-4(fp)
81134340:	1885c83a 	sub	r2,r3,r2
81134344:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81134348:	e0bffc17 	ldw	r2,-16(fp)
8113434c:	10800044 	addi	r2,r2,1
81134350:	e0bffc15 	stw	r2,-16(fp)
81134354:	e0fffc17 	ldw	r3,-16(fp)
81134358:	e0bffe17 	ldw	r2,-8(fp)
8113435c:	18bfe916 	blt	r3,r2,81134304 <__reset+0xfb114304>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81134360:	e0fffd17 	ldw	r3,-12(fp)
81134364:	008003f4 	movhi	r2,15
81134368:	10909004 	addi	r2,r2,16960
8113436c:	1887383a 	mul	r3,r3,r2
81134370:	00817db4 	movhi	r2,1526
81134374:	10b84004 	addi	r2,r2,-7936
81134378:	10c7203a 	divu	r3,r2,r3
8113437c:	e0bfff17 	ldw	r2,-4(fp)
81134380:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81134384:	10bfffc4 	addi	r2,r2,-1
81134388:	103ffe1e 	bne	r2,zero,81134384 <__reset+0xfb114384>
8113438c:	00000b06 	br	811343bc <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
81134390:	e0fffd17 	ldw	r3,-12(fp)
81134394:	008003f4 	movhi	r2,15
81134398:	10909004 	addi	r2,r2,16960
8113439c:	1887383a 	mul	r3,r3,r2
811343a0:	00817db4 	movhi	r2,1526
811343a4:	10b84004 	addi	r2,r2,-7936
811343a8:	10c7203a 	divu	r3,r2,r3
811343ac:	e0bfff17 	ldw	r2,-4(fp)
811343b0:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
811343b4:	10bfffc4 	addi	r2,r2,-1
811343b8:	00bffe16 	blt	zero,r2,811343b4 <__reset+0xfb1143b4>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
811343bc:	0005883a 	mov	r2,zero
}
811343c0:	e037883a 	mov	sp,fp
811343c4:	df000017 	ldw	fp,0(sp)
811343c8:	dec00104 	addi	sp,sp,4
811343cc:	f800283a 	ret

811343d0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811343d0:	defffe04 	addi	sp,sp,-8
811343d4:	de00012e 	bgeu	sp,et,811343dc <alt_get_errno+0xc>
811343d8:	003b68fa 	trap	3
811343dc:	dfc00115 	stw	ra,4(sp)
811343e0:	df000015 	stw	fp,0(sp)
811343e4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811343e8:	d0a01017 	ldw	r2,-32704(gp)
811343ec:	10000326 	beq	r2,zero,811343fc <alt_get_errno+0x2c>
811343f0:	d0a01017 	ldw	r2,-32704(gp)
811343f4:	103ee83a 	callr	r2
811343f8:	00000106 	br	81134400 <alt_get_errno+0x30>
811343fc:	d0a07704 	addi	r2,gp,-32292
}
81134400:	e037883a 	mov	sp,fp
81134404:	dfc00117 	ldw	ra,4(sp)
81134408:	df000017 	ldw	fp,0(sp)
8113440c:	dec00204 	addi	sp,sp,8
81134410:	f800283a 	ret

81134414 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
81134414:	defffb04 	addi	sp,sp,-20
81134418:	de00012e 	bgeu	sp,et,81134420 <close+0xc>
8113441c:	003b68fa 	trap	3
81134420:	dfc00415 	stw	ra,16(sp)
81134424:	df000315 	stw	fp,12(sp)
81134428:	df000304 	addi	fp,sp,12
8113442c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
81134430:	e0bfff17 	ldw	r2,-4(fp)
81134434:	10000616 	blt	r2,zero,81134450 <close+0x3c>
81134438:	e0bfff17 	ldw	r2,-4(fp)
8113443c:	10c00324 	muli	r3,r2,12
81134440:	00a04574 	movhi	r2,33045
81134444:	10bdae04 	addi	r2,r2,-2376
81134448:	1885883a 	add	r2,r3,r2
8113444c:	00000106 	br	81134454 <close+0x40>
81134450:	0005883a 	mov	r2,zero
81134454:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81134458:	e0bffd17 	ldw	r2,-12(fp)
8113445c:	10001926 	beq	r2,zero,811344c4 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
81134460:	e0bffd17 	ldw	r2,-12(fp)
81134464:	10800017 	ldw	r2,0(r2)
81134468:	10800417 	ldw	r2,16(r2)
8113446c:	10000626 	beq	r2,zero,81134488 <close+0x74>
81134470:	e0bffd17 	ldw	r2,-12(fp)
81134474:	10800017 	ldw	r2,0(r2)
81134478:	10800417 	ldw	r2,16(r2)
8113447c:	e13ffd17 	ldw	r4,-12(fp)
81134480:	103ee83a 	callr	r2
81134484:	00000106 	br	8113448c <close+0x78>
81134488:	0005883a 	mov	r2,zero
8113448c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
81134490:	e13fff17 	ldw	r4,-4(fp)
81134494:	11359f80 	call	811359f8 <alt_release_fd>
    if (rval < 0)
81134498:	e0bffe17 	ldw	r2,-8(fp)
8113449c:	1000070e 	bge	r2,zero,811344bc <close+0xa8>
    {
      ALT_ERRNO = -rval;
811344a0:	11343d00 	call	811343d0 <alt_get_errno>
811344a4:	1007883a 	mov	r3,r2
811344a8:	e0bffe17 	ldw	r2,-8(fp)
811344ac:	0085c83a 	sub	r2,zero,r2
811344b0:	18800015 	stw	r2,0(r3)
      return -1;
811344b4:	00bfffc4 	movi	r2,-1
811344b8:	00000706 	br	811344d8 <close+0xc4>
    }
    return 0;
811344bc:	0005883a 	mov	r2,zero
811344c0:	00000506 	br	811344d8 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
811344c4:	11343d00 	call	811343d0 <alt_get_errno>
811344c8:	1007883a 	mov	r3,r2
811344cc:	00801444 	movi	r2,81
811344d0:	18800015 	stw	r2,0(r3)
    return -1;
811344d4:	00bfffc4 	movi	r2,-1
  }
}
811344d8:	e037883a 	mov	sp,fp
811344dc:	dfc00117 	ldw	ra,4(sp)
811344e0:	df000017 	ldw	fp,0(sp)
811344e4:	dec00204 	addi	sp,sp,8
811344e8:	f800283a 	ret

811344ec <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811344ec:	deffff04 	addi	sp,sp,-4
811344f0:	de00012e 	bgeu	sp,et,811344f8 <alt_dcache_flush_all+0xc>
811344f4:	003b68fa 	trap	3
811344f8:	df000015 	stw	fp,0(sp)
811344fc:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
81134500:	0001883a 	nop
81134504:	e037883a 	mov	sp,fp
81134508:	df000017 	ldw	fp,0(sp)
8113450c:	dec00104 	addi	sp,sp,4
81134510:	f800283a 	ret

81134514 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
81134514:	defffc04 	addi	sp,sp,-16
81134518:	de00012e 	bgeu	sp,et,81134520 <alt_dev_null_write+0xc>
8113451c:	003b68fa 	trap	3
81134520:	df000315 	stw	fp,12(sp)
81134524:	df000304 	addi	fp,sp,12
81134528:	e13ffd15 	stw	r4,-12(fp)
8113452c:	e17ffe15 	stw	r5,-8(fp)
81134530:	e1bfff15 	stw	r6,-4(fp)
  return len;
81134534:	e0bfff17 	ldw	r2,-4(fp)
}
81134538:	e037883a 	mov	sp,fp
8113453c:	df000017 	ldw	fp,0(sp)
81134540:	dec00104 	addi	sp,sp,4
81134544:	f800283a 	ret

81134548 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81134548:	defffe04 	addi	sp,sp,-8
8113454c:	de00012e 	bgeu	sp,et,81134554 <alt_get_errno+0xc>
81134550:	003b68fa 	trap	3
81134554:	dfc00115 	stw	ra,4(sp)
81134558:	df000015 	stw	fp,0(sp)
8113455c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81134560:	d0a01017 	ldw	r2,-32704(gp)
81134564:	10000326 	beq	r2,zero,81134574 <alt_get_errno+0x2c>
81134568:	d0a01017 	ldw	r2,-32704(gp)
8113456c:	103ee83a 	callr	r2
81134570:	00000106 	br	81134578 <alt_get_errno+0x30>
81134574:	d0a07704 	addi	r2,gp,-32292
}
81134578:	e037883a 	mov	sp,fp
8113457c:	dfc00117 	ldw	ra,4(sp)
81134580:	df000017 	ldw	fp,0(sp)
81134584:	dec00204 	addi	sp,sp,8
81134588:	f800283a 	ret

8113458c <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
8113458c:	defffb04 	addi	sp,sp,-20
81134590:	de00012e 	bgeu	sp,et,81134598 <fstat+0xc>
81134594:	003b68fa 	trap	3
81134598:	dfc00415 	stw	ra,16(sp)
8113459c:	df000315 	stw	fp,12(sp)
811345a0:	df000304 	addi	fp,sp,12
811345a4:	e13ffe15 	stw	r4,-8(fp)
811345a8:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811345ac:	e0bffe17 	ldw	r2,-8(fp)
811345b0:	10000616 	blt	r2,zero,811345cc <fstat+0x40>
811345b4:	e0bffe17 	ldw	r2,-8(fp)
811345b8:	10c00324 	muli	r3,r2,12
811345bc:	00a04574 	movhi	r2,33045
811345c0:	10bdae04 	addi	r2,r2,-2376
811345c4:	1885883a 	add	r2,r3,r2
811345c8:	00000106 	br	811345d0 <fstat+0x44>
811345cc:	0005883a 	mov	r2,zero
811345d0:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811345d4:	e0bffd17 	ldw	r2,-12(fp)
811345d8:	10001026 	beq	r2,zero,8113461c <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
811345dc:	e0bffd17 	ldw	r2,-12(fp)
811345e0:	10800017 	ldw	r2,0(r2)
811345e4:	10800817 	ldw	r2,32(r2)
811345e8:	10000726 	beq	r2,zero,81134608 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811345ec:	e0bffd17 	ldw	r2,-12(fp)
811345f0:	10800017 	ldw	r2,0(r2)
811345f4:	10800817 	ldw	r2,32(r2)
811345f8:	e17fff17 	ldw	r5,-4(fp)
811345fc:	e13ffd17 	ldw	r4,-12(fp)
81134600:	103ee83a 	callr	r2
81134604:	00000a06 	br	81134630 <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
81134608:	e0bfff17 	ldw	r2,-4(fp)
8113460c:	00c80004 	movi	r3,8192
81134610:	10c00115 	stw	r3,4(r2)
      return 0;
81134614:	0005883a 	mov	r2,zero
81134618:	00000506 	br	81134630 <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
8113461c:	11345480 	call	81134548 <alt_get_errno>
81134620:	1007883a 	mov	r3,r2
81134624:	00801444 	movi	r2,81
81134628:	18800015 	stw	r2,0(r3)
    return -1;
8113462c:	00bfffc4 	movi	r2,-1
  }
}
81134630:	e037883a 	mov	sp,fp
81134634:	dfc00117 	ldw	ra,4(sp)
81134638:	df000017 	ldw	fp,0(sp)
8113463c:	dec00204 	addi	sp,sp,8
81134640:	f800283a 	ret

81134644 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81134644:	defff004 	addi	sp,sp,-64
81134648:	de00012e 	bgeu	sp,et,81134650 <alt_irq_register+0xc>
8113464c:	003b68fa 	trap	3
81134650:	df000f15 	stw	fp,60(sp)
81134654:	df000f04 	addi	fp,sp,60
81134658:	e13ffd15 	stw	r4,-12(fp)
8113465c:	e17ffe15 	stw	r5,-8(fp)
81134660:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81134664:	00bffa84 	movi	r2,-22
81134668:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
8113466c:	e0bffd17 	ldw	r2,-12(fp)
81134670:	10800828 	cmpgeui	r2,r2,32
81134674:	1000501e 	bne	r2,zero,811347b8 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134678:	0005303a 	rdctl	r2,status
8113467c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134680:	e0fff617 	ldw	r3,-40(fp)
81134684:	00bfff84 	movi	r2,-2
81134688:	1884703a 	and	r2,r3,r2
8113468c:	1001703a 	wrctl	status,r2
  
  return context;
81134690:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81134694:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81134698:	00a045f4 	movhi	r2,33047
8113469c:	10ab5504 	addi	r2,r2,-21164
811346a0:	e0fffd17 	ldw	r3,-12(fp)
811346a4:	180690fa 	slli	r3,r3,3
811346a8:	10c5883a 	add	r2,r2,r3
811346ac:	e0ffff17 	ldw	r3,-4(fp)
811346b0:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
811346b4:	00a045f4 	movhi	r2,33047
811346b8:	10ab5504 	addi	r2,r2,-21164
811346bc:	e0fffd17 	ldw	r3,-12(fp)
811346c0:	180690fa 	slli	r3,r3,3
811346c4:	10c5883a 	add	r2,r2,r3
811346c8:	10800104 	addi	r2,r2,4
811346cc:	e0fffe17 	ldw	r3,-8(fp)
811346d0:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811346d4:	e0bfff17 	ldw	r2,-4(fp)
811346d8:	10001926 	beq	r2,zero,81134740 <alt_irq_register+0xfc>
811346dc:	e0bffd17 	ldw	r2,-12(fp)
811346e0:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811346e4:	0005303a 	rdctl	r2,status
811346e8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811346ec:	e0fff717 	ldw	r3,-36(fp)
811346f0:	00bfff84 	movi	r2,-2
811346f4:	1884703a 	and	r2,r3,r2
811346f8:	1001703a 	wrctl	status,r2
  
  return context;
811346fc:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81134700:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
81134704:	00c00044 	movi	r3,1
81134708:	e0bff217 	ldw	r2,-56(fp)
8113470c:	1884983a 	sll	r2,r3,r2
81134710:	1007883a 	mov	r3,r2
81134714:	d0a07f17 	ldw	r2,-32260(gp)
81134718:	1884b03a 	or	r2,r3,r2
8113471c:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81134720:	d0a07f17 	ldw	r2,-32260(gp)
81134724:	100170fa 	wrctl	ienable,r2
81134728:	e0bff817 	ldw	r2,-32(fp)
8113472c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134730:	e0bff917 	ldw	r2,-28(fp)
81134734:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81134738:	0005883a 	mov	r2,zero
8113473c:	00001906 	br	811347a4 <alt_irq_register+0x160>
81134740:	e0bffd17 	ldw	r2,-12(fp)
81134744:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134748:	0005303a 	rdctl	r2,status
8113474c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134750:	e0fffa17 	ldw	r3,-24(fp)
81134754:	00bfff84 	movi	r2,-2
81134758:	1884703a 	and	r2,r3,r2
8113475c:	1001703a 	wrctl	status,r2
  
  return context;
81134760:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81134764:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81134768:	00c00044 	movi	r3,1
8113476c:	e0bff417 	ldw	r2,-48(fp)
81134770:	1884983a 	sll	r2,r3,r2
81134774:	0084303a 	nor	r2,zero,r2
81134778:	1007883a 	mov	r3,r2
8113477c:	d0a07f17 	ldw	r2,-32260(gp)
81134780:	1884703a 	and	r2,r3,r2
81134784:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81134788:	d0a07f17 	ldw	r2,-32260(gp)
8113478c:	100170fa 	wrctl	ienable,r2
81134790:	e0bffb17 	ldw	r2,-20(fp)
81134794:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134798:	e0bffc17 	ldw	r2,-16(fp)
8113479c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811347a0:	0005883a 	mov	r2,zero
811347a4:	e0bff115 	stw	r2,-60(fp)
811347a8:	e0bff317 	ldw	r2,-52(fp)
811347ac:	e0bff515 	stw	r2,-44(fp)
811347b0:	e0bff517 	ldw	r2,-44(fp)
811347b4:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
811347b8:	e0bff117 	ldw	r2,-60(fp)
}
811347bc:	e037883a 	mov	sp,fp
811347c0:	df000017 	ldw	fp,0(sp)
811347c4:	dec00104 	addi	sp,sp,4
811347c8:	f800283a 	ret

811347cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811347cc:	defffe04 	addi	sp,sp,-8
811347d0:	de00012e 	bgeu	sp,et,811347d8 <alt_get_errno+0xc>
811347d4:	003b68fa 	trap	3
811347d8:	dfc00115 	stw	ra,4(sp)
811347dc:	df000015 	stw	fp,0(sp)
811347e0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811347e4:	d0a01017 	ldw	r2,-32704(gp)
811347e8:	10000326 	beq	r2,zero,811347f8 <alt_get_errno+0x2c>
811347ec:	d0a01017 	ldw	r2,-32704(gp)
811347f0:	103ee83a 	callr	r2
811347f4:	00000106 	br	811347fc <alt_get_errno+0x30>
811347f8:	d0a07704 	addi	r2,gp,-32292
}
811347fc:	e037883a 	mov	sp,fp
81134800:	dfc00117 	ldw	ra,4(sp)
81134804:	df000017 	ldw	fp,0(sp)
81134808:	dec00204 	addi	sp,sp,8
8113480c:	f800283a 	ret

81134810 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
81134810:	deffed04 	addi	sp,sp,-76
81134814:	de00012e 	bgeu	sp,et,8113481c <isatty+0xc>
81134818:	003b68fa 	trap	3
8113481c:	dfc01215 	stw	ra,72(sp)
81134820:	df001115 	stw	fp,68(sp)
81134824:	df001104 	addi	fp,sp,68
81134828:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
8113482c:	e0bfff17 	ldw	r2,-4(fp)
81134830:	10000616 	blt	r2,zero,8113484c <isatty+0x3c>
81134834:	e0bfff17 	ldw	r2,-4(fp)
81134838:	10c00324 	muli	r3,r2,12
8113483c:	00a04574 	movhi	r2,33045
81134840:	10bdae04 	addi	r2,r2,-2376
81134844:	1885883a 	add	r2,r3,r2
81134848:	00000106 	br	81134850 <isatty+0x40>
8113484c:	0005883a 	mov	r2,zero
81134850:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81134854:	e0bfef17 	ldw	r2,-68(fp)
81134858:	10000e26 	beq	r2,zero,81134894 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
8113485c:	e0bfef17 	ldw	r2,-68(fp)
81134860:	10800017 	ldw	r2,0(r2)
81134864:	10800817 	ldw	r2,32(r2)
81134868:	1000021e 	bne	r2,zero,81134874 <isatty+0x64>
    {
      return 1;
8113486c:	00800044 	movi	r2,1
81134870:	00000d06 	br	811348a8 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81134874:	e0bff004 	addi	r2,fp,-64
81134878:	100b883a 	mov	r5,r2
8113487c:	e13fff17 	ldw	r4,-4(fp)
81134880:	113458c0 	call	8113458c <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81134884:	e0bff117 	ldw	r2,-60(fp)
81134888:	10880020 	cmpeqi	r2,r2,8192
8113488c:	10803fcc 	andi	r2,r2,255
81134890:	00000506 	br	811348a8 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81134894:	11347cc0 	call	811347cc <alt_get_errno>
81134898:	1007883a 	mov	r3,r2
8113489c:	00801444 	movi	r2,81
811348a0:	18800015 	stw	r2,0(r3)
    return 0;
811348a4:	0005883a 	mov	r2,zero
  }
}
811348a8:	e037883a 	mov	sp,fp
811348ac:	dfc00117 	ldw	ra,4(sp)
811348b0:	df000017 	ldw	fp,0(sp)
811348b4:	dec00204 	addi	sp,sp,8
811348b8:	f800283a 	ret

811348bc <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
811348bc:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
811348c0:	318c2404 	addi	r6,r6,12432

811348c4 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
811348c4:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
811348c8:	01c00826 	beq	zero,r7,811348ec <end_tx>

811348cc <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
811348cc:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
811348d0:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
811348d4:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
811348d8:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
811348dc:	283ffb26 	beq	r5,zero,811348cc <__reset+0xfb1148cc>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
811348e0:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
811348e4:	21000044 	addi	r4,r4,1
	br tx_next_char
811348e8:	003ff606 	br	811348c4 <__reset+0xfb1148c4>

811348ec <end_tx>:
end_tx:	
        ret
811348ec:	f800283a 	ret

811348f0 <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
811348f0:	defffd04 	addi	sp,sp,-12
811348f4:	de00012e 	bgeu	sp,et,811348fc <alt_log_txchar+0xc>
811348f8:	003b68fa 	trap	3
811348fc:	df000215 	stw	fp,8(sp)
81134900:	df000204 	addi	fp,sp,8
81134904:	e13ffe15 	stw	r4,-8(fp)
81134908:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
8113490c:	0001883a 	nop
81134910:	e0bfff17 	ldw	r2,-4(fp)
81134914:	10800104 	addi	r2,r2,4
81134918:	10800037 	ldwio	r2,0(r2)
8113491c:	10bfffec 	andhi	r2,r2,65535
81134920:	103ffb26 	beq	r2,zero,81134910 <__reset+0xfb114910>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81134924:	e0bfff17 	ldw	r2,-4(fp)
81134928:	e0fffe17 	ldw	r3,-8(fp)
8113492c:	10c00035 	stwio	r3,0(r2)
}
81134930:	0001883a 	nop
81134934:	e037883a 	mov	sp,fp
81134938:	df000017 	ldw	fp,0(sp)
8113493c:	dec00104 	addi	sp,sp,4
81134940:	f800283a 	ret

81134944 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81134944:	defffb04 	addi	sp,sp,-20
81134948:	de00012e 	bgeu	sp,et,81134950 <alt_log_repchar+0xc>
8113494c:	003b68fa 	trap	3
81134950:	dfc00415 	stw	ra,16(sp)
81134954:	df000315 	stw	fp,12(sp)
81134958:	df000304 	addi	fp,sp,12
8113495c:	2005883a 	mov	r2,r4
81134960:	e17ffe15 	stw	r5,-8(fp)
81134964:	e1bfff15 	stw	r6,-4(fp)
81134968:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
8113496c:	00000506 	br	81134984 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
81134970:	e0bffd07 	ldb	r2,-12(fp)
81134974:	e0ffff17 	ldw	r3,-4(fp)
81134978:	180b883a 	mov	r5,r3
8113497c:	1009883a 	mov	r4,r2
81134980:	11348f00 	call	811348f0 <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81134984:	e0bffe17 	ldw	r2,-8(fp)
81134988:	10ffffc4 	addi	r3,r2,-1
8113498c:	e0fffe15 	stw	r3,-8(fp)
81134990:	00bff716 	blt	zero,r2,81134970 <__reset+0xfb114970>
    alt_log_txchar(c,(char*) base);
}
81134994:	0001883a 	nop
81134998:	e037883a 	mov	sp,fp
8113499c:	dfc00117 	ldw	ra,4(sp)
811349a0:	df000017 	ldw	fp,0(sp)
811349a4:	dec00204 	addi	sp,sp,8
811349a8:	f800283a 	ret

811349ac <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
811349ac:	deffe904 	addi	sp,sp,-92
811349b0:	de00012e 	bgeu	sp,et,811349b8 <alt_log_private_printf+0xc>
811349b4:	003b68fa 	trap	3
811349b8:	dfc01615 	stw	ra,88(sp)
811349bc:	df001515 	stw	fp,84(sp)
811349c0:	dc001415 	stw	r16,80(sp)
811349c4:	df001504 	addi	fp,sp,84
811349c8:	e13ffc15 	stw	r4,-16(fp)
811349cc:	e17ffd15 	stw	r5,-12(fp)
811349d0:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811349d4:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811349d8:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
811349dc:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
811349e0:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
811349e4:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
811349e8:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
811349ec:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
811349f0:	e0bffc17 	ldw	r2,-16(fp)
811349f4:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811349f8:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811349fc:	00014b06 	br	81134f2c <alt_log_private_printf+0x580>
    {
    switch(state)
81134a00:	e0bfec17 	ldw	r2,-80(fp)
81134a04:	10c00060 	cmpeqi	r3,r2,1
81134a08:	18001b1e 	bne	r3,zero,81134a78 <alt_log_private_printf+0xcc>
81134a0c:	10c000a0 	cmpeqi	r3,r2,2
81134a10:	18002d1e 	bne	r3,zero,81134ac8 <alt_log_private_printf+0x11c>
81134a14:	10000126 	beq	r2,zero,81134a1c <alt_log_private_printf+0x70>
81134a18:	00014406 	br	81134f2c <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
81134a1c:	e0bffb07 	ldb	r2,-20(fp)
81134a20:	10800958 	cmpnei	r2,r2,37
81134a24:	10000e1e 	bne	r2,zero,81134a60 <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81134a28:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81134a2c:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81134a30:	00800284 	movi	r2,10
81134a34:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81134a38:	00800044 	movi	r2,1
81134a3c:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81134a40:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81134a44:	00bfffc4 	movi	r2,-1
81134a48:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81134a4c:	00bfffc4 	movi	r2,-1
81134a50:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81134a54:	00800044 	movi	r2,1
81134a58:	e0bfec15 	stw	r2,-80(fp)
81134a5c:	00013306 	br	81134f2c <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81134a60:	e0bffb07 	ldb	r2,-20(fp)
81134a64:	e0fffd17 	ldw	r3,-12(fp)
81134a68:	180b883a 	mov	r5,r3
81134a6c:	1009883a 	mov	r4,r2
81134a70:	11348f00 	call	811348f0 <alt_log_txchar>
        }
        break;
81134a74:	00012d06 	br	81134f2c <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81134a78:	e0bffb07 	ldb	r2,-20(fp)
81134a7c:	10800c18 	cmpnei	r2,r2,48
81134a80:	1000051e 	bne	r2,zero,81134a98 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81134a84:	00800044 	movi	r2,1
81134a88:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81134a8c:	00800084 	movi	r2,2
81134a90:	e0bfec15 	stw	r2,-80(fp)
81134a94:	00012506 	br	81134f2c <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81134a98:	e0bffb07 	ldb	r2,-20(fp)
81134a9c:	10800958 	cmpnei	r2,r2,37
81134aa0:	1000071e 	bne	r2,zero,81134ac0 <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81134aa4:	e0bffb07 	ldb	r2,-20(fp)
81134aa8:	e0fffd17 	ldw	r3,-12(fp)
81134aac:	180b883a 	mov	r5,r3
81134ab0:	1009883a 	mov	r4,r2
81134ab4:	11348f00 	call	811348f0 <alt_log_txchar>
          state = pfState_chars;
81134ab8:	e03fec15 	stw	zero,-80(fp)
81134abc:	00011b06 	br	81134f2c <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81134ac0:	00800084 	movi	r2,2
81134ac4:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81134ac8:	e0bffb07 	ldb	r2,-20(fp)
81134acc:	10800b98 	cmpnei	r2,r2,46
81134ad0:	1000021e 	bne	r2,zero,81134adc <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81134ad4:	e03ff015 	stw	zero,-64(fp)
81134ad8:	00011306 	br	81134f28 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81134adc:	e0bffb07 	ldb	r2,-20(fp)
81134ae0:	10800c10 	cmplti	r2,r2,48
81134ae4:	10001a1e 	bne	r2,zero,81134b50 <alt_log_private_printf+0x1a4>
81134ae8:	e0bffb07 	ldb	r2,-20(fp)
81134aec:	10800e88 	cmpgei	r2,r2,58
81134af0:	1000171e 	bne	r2,zero,81134b50 <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81134af4:	e0bffb03 	ldbu	r2,-20(fp)
81134af8:	10bff404 	addi	r2,r2,-48
81134afc:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81134b00:	e0bff017 	ldw	r2,-64(fp)
81134b04:	10000c0e 	bge	r2,zero,81134b38 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81134b08:	e0bfef17 	ldw	r2,-68(fp)
81134b0c:	1000020e 	bge	r2,zero,81134b18 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81134b10:	e03fef15 	stw	zero,-68(fp)
81134b14:	00000306 	br	81134b24 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81134b18:	e0bfef17 	ldw	r2,-68(fp)
81134b1c:	108002a4 	muli	r2,r2,10
81134b20:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81134b24:	e0bffb07 	ldb	r2,-20(fp)
81134b28:	e0ffef17 	ldw	r3,-68(fp)
81134b2c:	1885883a 	add	r2,r3,r2
81134b30:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81134b34:	0000fc06 	br	81134f28 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81134b38:	e0bff017 	ldw	r2,-64(fp)
81134b3c:	10c002a4 	muli	r3,r2,10
81134b40:	e0bffb07 	ldb	r2,-20(fp)
81134b44:	1885883a 	add	r2,r3,r2
81134b48:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81134b4c:	0000f606 	br	81134f28 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81134b50:	e0bffb07 	ldb	r2,-20(fp)
81134b54:	10801b18 	cmpnei	r2,r2,108
81134b58:	1000031e 	bne	r2,zero,81134b68 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81134b5c:	00800044 	movi	r2,1
81134b60:	e0bfee15 	stw	r2,-72(fp)
81134b64:	0000f006 	br	81134f28 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81134b68:	e0bffb07 	ldb	r2,-20(fp)
81134b6c:	10bfea04 	addi	r2,r2,-88
81134b70:	10c00868 	cmpgeui	r3,r2,33
81134b74:	1800eb1e 	bne	r3,zero,81134f24 <alt_log_private_printf+0x578>
81134b78:	100690ba 	slli	r3,r2,2
81134b7c:	00a044f4 	movhi	r2,33043
81134b80:	1092e404 	addi	r2,r2,19344
81134b84:	1885883a 	add	r2,r3,r2
81134b88:	10800017 	ldw	r2,0(r2)
81134b8c:	1000683a 	jmp	r2
81134b90:	81134e50 	cmplti	r4,r16,19769
81134b94:	81134f24 	muli	r4,r16,19772
81134b98:	81134f24 	muli	r4,r16,19772
81134b9c:	81134f24 	muli	r4,r16,19772
81134ba0:	81134f24 	muli	r4,r16,19772
81134ba4:	81134f24 	muli	r4,r16,19772
81134ba8:	81134f24 	muli	r4,r16,19772
81134bac:	81134f24 	muli	r4,r16,19772
81134bb0:	81134f24 	muli	r4,r16,19772
81134bb4:	81134f24 	muli	r4,r16,19772
81134bb8:	81134f24 	muli	r4,r16,19772
81134bbc:	81134e68 	cmpgeui	r4,r16,19769
81134bc0:	81134c14 	ori	r4,r16,19760
81134bc4:	81134f24 	muli	r4,r16,19772
81134bc8:	81134f24 	muli	r4,r16,19772
81134bcc:	81134f24 	muli	r4,r16,19772
81134bd0:	81134f24 	muli	r4,r16,19772
81134bd4:	81134c14 	ori	r4,r16,19760
81134bd8:	81134f24 	muli	r4,r16,19772
81134bdc:	81134f24 	muli	r4,r16,19772
81134be0:	81134f24 	muli	r4,r16,19772
81134be4:	81134f24 	muli	r4,r16,19772
81134be8:	81134f24 	muli	r4,r16,19772
81134bec:	81134e30 	cmpltui	r4,r16,19768
81134bf0:	81134f24 	muli	r4,r16,19772
81134bf4:	81134f24 	muli	r4,r16,19772
81134bf8:	81134f24 	muli	r4,r16,19772
81134bfc:	81134ea4 	muli	r4,r16,19770
81134c00:	81134f24 	muli	r4,r16,19772
81134c04:	81134e28 	cmpgeui	r4,r16,19768
81134c08:	81134f24 	muli	r4,r16,19772
81134c0c:	81134f24 	muli	r4,r16,19772
81134c10:	81134e40 	call	881134e4 <__reset+0x20f34e4>
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81134c14:	e0bfee17 	ldw	r2,-72(fp)
81134c18:	10000e26 	beq	r2,zero,81134c54 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81134c1c:	e0bff217 	ldw	r2,-56(fp)
81134c20:	10000626 	beq	r2,zero,81134c3c <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81134c24:	e0bffe17 	ldw	r2,-8(fp)
81134c28:	10c00104 	addi	r3,r2,4
81134c2c:	e0fffe15 	stw	r3,-8(fp)
81134c30:	10800017 	ldw	r2,0(r2)
81134c34:	e0bff415 	stw	r2,-48(fp)
81134c38:	00001306 	br	81134c88 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81134c3c:	e0bffe17 	ldw	r2,-8(fp)
81134c40:	10c00104 	addi	r3,r2,4
81134c44:	e0fffe15 	stw	r3,-8(fp)
81134c48:	10800017 	ldw	r2,0(r2)
81134c4c:	e0bff415 	stw	r2,-48(fp)
81134c50:	00000d06 	br	81134c88 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81134c54:	e0bff217 	ldw	r2,-56(fp)
81134c58:	10000626 	beq	r2,zero,81134c74 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81134c5c:	e0bffe17 	ldw	r2,-8(fp)
81134c60:	10c00104 	addi	r3,r2,4
81134c64:	e0fffe15 	stw	r3,-8(fp)
81134c68:	10800017 	ldw	r2,0(r2)
81134c6c:	e0bff415 	stw	r2,-48(fp)
81134c70:	00000506 	br	81134c88 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81134c74:	e0bffe17 	ldw	r2,-8(fp)
81134c78:	10c00104 	addi	r3,r2,4
81134c7c:	e0fffe15 	stw	r3,-8(fp)
81134c80:	10800017 	ldw	r2,0(r2)
81134c84:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81134c88:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81134c8c:	e0bff217 	ldw	r2,-56(fp)
81134c90:	10000726 	beq	r2,zero,81134cb0 <alt_log_private_printf+0x304>
81134c94:	e0bff417 	ldw	r2,-48(fp)
81134c98:	1000050e 	bge	r2,zero,81134cb0 <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81134c9c:	e0bff417 	ldw	r2,-48(fp)
81134ca0:	0085c83a 	sub	r2,zero,r2
81134ca4:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81134ca8:	00800044 	movi	r2,1
81134cac:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81134cb0:	e0bff417 	ldw	r2,-48(fp)
81134cb4:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81134cb8:	00800044 	movi	r2,1
81134cbc:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81134cc0:	00800044 	movi	r2,1
81134cc4:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81134cc8:	00000706 	br	81134ce8 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81134ccc:	e0bff817 	ldw	r2,-32(fp)
81134cd0:	10800044 	addi	r2,r2,1
81134cd4:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81134cd8:	e0bff117 	ldw	r2,-60(fp)
81134cdc:	e0fff517 	ldw	r3,-44(fp)
81134ce0:	1885383a 	mul	r2,r3,r2
81134ce4:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81134ce8:	e0bff117 	ldw	r2,-60(fp)
81134cec:	e0fff617 	ldw	r3,-40(fp)
81134cf0:	1885203a 	divu	r2,r3,r2
81134cf4:	e0bff615 	stw	r2,-40(fp)
81134cf8:	e0bff617 	ldw	r2,-40(fp)
81134cfc:	103ff31e 	bne	r2,zero,81134ccc <__reset+0xfb114ccc>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81134d00:	e0ffef17 	ldw	r3,-68(fp)
81134d04:	e0bff817 	ldw	r2,-32(fp)
81134d08:	1885c83a 	sub	r2,r3,r2
81134d0c:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81134d10:	e0bfed17 	ldw	r2,-76(fp)
81134d14:	10000e26 	beq	r2,zero,81134d50 <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81134d18:	e0bff717 	ldw	r2,-36(fp)
81134d1c:	10000726 	beq	r2,zero,81134d3c <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81134d20:	e0bffd17 	ldw	r2,-12(fp)
81134d24:	100b883a 	mov	r5,r2
81134d28:	01000b44 	movi	r4,45
81134d2c:	11348f00 	call	811348f0 <alt_log_txchar>
                    fmtBeforeDecimal--;
81134d30:	e0bfef17 	ldw	r2,-68(fp)
81134d34:	10bfffc4 	addi	r2,r2,-1
81134d38:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81134d3c:	e1bffd17 	ldw	r6,-12(fp)
81134d40:	e17fef17 	ldw	r5,-68(fp)
81134d44:	01000c04 	movi	r4,48
81134d48:	11349440 	call	81134944 <alt_log_repchar>
81134d4c:	00003206 	br	81134e18 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81134d50:	e0bff717 	ldw	r2,-36(fp)
81134d54:	10000326 	beq	r2,zero,81134d64 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81134d58:	e0bfef17 	ldw	r2,-68(fp)
81134d5c:	10bfffc4 	addi	r2,r2,-1
81134d60:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81134d64:	e1bffd17 	ldw	r6,-12(fp)
81134d68:	e17fef17 	ldw	r5,-68(fp)
81134d6c:	01000804 	movi	r4,32
81134d70:	11349440 	call	81134944 <alt_log_repchar>
                    if(sign)
81134d74:	e0bff717 	ldw	r2,-36(fp)
81134d78:	10002726 	beq	r2,zero,81134e18 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81134d7c:	e0bffd17 	ldw	r2,-12(fp)
81134d80:	100b883a 	mov	r5,r2
81134d84:	01000b44 	movi	r4,45
81134d88:	11348f00 	call	811348f0 <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81134d8c:	00002206 	br	81134e18 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81134d90:	e0fff417 	ldw	r3,-48(fp)
81134d94:	e0bff517 	ldw	r2,-44(fp)
81134d98:	1885203a 	divu	r2,r3,r2
81134d9c:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81134da0:	e0bff903 	ldbu	r2,-28(fp)
81134da4:	10800c04 	addi	r2,r2,48
81134da8:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81134dac:	e0bff903 	ldbu	r2,-28(fp)
81134db0:	10800eb0 	cmpltui	r2,r2,58
81134db4:	1000081e 	bne	r2,zero,81134dd8 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81134db8:	e0bff317 	ldw	r2,-52(fp)
81134dbc:	10000226 	beq	r2,zero,81134dc8 <alt_log_private_printf+0x41c>
81134dc0:	008001c4 	movi	r2,7
81134dc4:	00000106 	br	81134dcc <alt_log_private_printf+0x420>
81134dc8:	008009c4 	movi	r2,39
81134dcc:	e0fff903 	ldbu	r3,-28(fp)
81134dd0:	10c5883a 	add	r2,r2,r3
81134dd4:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81134dd8:	e0bff903 	ldbu	r2,-28(fp)
81134ddc:	e0fffd17 	ldw	r3,-12(fp)
81134de0:	180b883a 	mov	r5,r3
81134de4:	1009883a 	mov	r4,r2
81134de8:	11348f00 	call	811348f0 <alt_log_txchar>

                  v = v % p;
81134dec:	e0bff417 	ldw	r2,-48(fp)
81134df0:	e0fff517 	ldw	r3,-44(fp)
81134df4:	10c9203a 	divu	r4,r2,r3
81134df8:	e0fff517 	ldw	r3,-44(fp)
81134dfc:	20c7383a 	mul	r3,r4,r3
81134e00:	10c5c83a 	sub	r2,r2,r3
81134e04:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81134e08:	e0bff117 	ldw	r2,-60(fp)
81134e0c:	e0fff517 	ldw	r3,-44(fp)
81134e10:	1885203a 	divu	r2,r3,r2
81134e14:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81134e18:	e0bff517 	ldw	r2,-44(fp)
81134e1c:	103fdc1e 	bne	r2,zero,81134d90 <__reset+0xfb114d90>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81134e20:	e03fec15 	stw	zero,-80(fp)
              break;
81134e24:	00003f06 	br	81134f24 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81134e28:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81134e2c:	003f7906 	br	81134c14 <__reset+0xfb114c14>
            case 'o':
              fmtSigned = 0;
81134e30:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81134e34:	00800204 	movi	r2,8
81134e38:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81134e3c:	003f7506 	br	81134c14 <__reset+0xfb114c14>
            case 'x':
              fmtSigned = 0;
81134e40:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81134e44:	00800404 	movi	r2,16
81134e48:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81134e4c:	003f7106 	br	81134c14 <__reset+0xfb114c14>
            case 'X':
              fmtSigned = 0;
81134e50:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81134e54:	00800404 	movi	r2,16
81134e58:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81134e5c:	00800044 	movi	r2,1
81134e60:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81134e64:	003f6b06 	br	81134c14 <__reset+0xfb114c14>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81134e68:	e0bfef17 	ldw	r2,-68(fp)
81134e6c:	10bfffc4 	addi	r2,r2,-1
81134e70:	e1bffd17 	ldw	r6,-12(fp)
81134e74:	100b883a 	mov	r5,r2
81134e78:	01000804 	movi	r4,32
81134e7c:	11349440 	call	81134944 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81134e80:	e0bffe17 	ldw	r2,-8(fp)
81134e84:	10c00104 	addi	r3,r2,4
81134e88:	e0fffe15 	stw	r3,-8(fp)
81134e8c:	10800017 	ldw	r2,0(r2)
81134e90:	e0fffd17 	ldw	r3,-12(fp)
81134e94:	180b883a 	mov	r5,r3
81134e98:	1009883a 	mov	r4,r2
81134e9c:	11348f00 	call	811348f0 <alt_log_txchar>
              break;
81134ea0:	00002006 	br	81134f24 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81134ea4:	e0bffe17 	ldw	r2,-8(fp)
81134ea8:	10c00104 	addi	r3,r2,4
81134eac:	e0fffe15 	stw	r3,-8(fp)
81134eb0:	10800017 	ldw	r2,0(r2)
81134eb4:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81134eb8:	e43fef17 	ldw	r16,-68(fp)
81134ebc:	e13ffa17 	ldw	r4,-24(fp)
81134ec0:	11211a00 	call	811211a0 <strlen>
81134ec4:	8085c83a 	sub	r2,r16,r2
81134ec8:	e1bffd17 	ldw	r6,-12(fp)
81134ecc:	100b883a 	mov	r5,r2
81134ed0:	01000804 	movi	r4,32
81134ed4:	11349440 	call	81134944 <alt_log_repchar>

                while(*s)
81134ed8:	00000b06 	br	81134f08 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81134edc:	e0bffa17 	ldw	r2,-24(fp)
81134ee0:	10c00044 	addi	r3,r2,1
81134ee4:	e0fffa15 	stw	r3,-24(fp)
81134ee8:	10800003 	ldbu	r2,0(r2)
81134eec:	10803fcc 	andi	r2,r2,255
81134ef0:	1080201c 	xori	r2,r2,128
81134ef4:	10bfe004 	addi	r2,r2,-128
81134ef8:	e0fffd17 	ldw	r3,-12(fp)
81134efc:	180b883a 	mov	r5,r3
81134f00:	1009883a 	mov	r4,r2
81134f04:	11348f00 	call	811348f0 <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81134f08:	e0bffa17 	ldw	r2,-24(fp)
81134f0c:	10800003 	ldbu	r2,0(r2)
81134f10:	10803fcc 	andi	r2,r2,255
81134f14:	1080201c 	xori	r2,r2,128
81134f18:	10bfe004 	addi	r2,r2,-128
81134f1c:	103fef1e 	bne	r2,zero,81134edc <__reset+0xfb114edc>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81134f20:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81134f24:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81134f28:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81134f2c:	e0bfeb17 	ldw	r2,-84(fp)
81134f30:	10c00044 	addi	r3,r2,1
81134f34:	e0ffeb15 	stw	r3,-84(fp)
81134f38:	10800003 	ldbu	r2,0(r2)
81134f3c:	e0bffb05 	stb	r2,-20(fp)
81134f40:	e0bffb07 	ldb	r2,-20(fp)
81134f44:	103eae1e 	bne	r2,zero,81134a00 <__reset+0xfb114a00>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81134f48:	0001883a 	nop
81134f4c:	e6ffff04 	addi	sp,fp,-4
81134f50:	dfc00217 	ldw	ra,8(sp)
81134f54:	df000117 	ldw	fp,4(sp)
81134f58:	dc000017 	ldw	r16,0(sp)
81134f5c:	dec00304 	addi	sp,sp,12
81134f60:	f800283a 	ret

81134f64 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81134f64:	defff904 	addi	sp,sp,-28
81134f68:	de00012e 	bgeu	sp,et,81134f70 <alt_log_printf_proc+0xc>
81134f6c:	003b68fa 	trap	3
81134f70:	dfc00315 	stw	ra,12(sp)
81134f74:	df000215 	stw	fp,8(sp)
81134f78:	df000204 	addi	fp,sp,8
81134f7c:	e13fff15 	stw	r4,-4(fp)
81134f80:	e1400215 	stw	r5,8(fp)
81134f84:	e1800315 	stw	r6,12(fp)
81134f88:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81134f8c:	e0800204 	addi	r2,fp,8
81134f90:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81134f94:	e0bffe17 	ldw	r2,-8(fp)
81134f98:	100d883a 	mov	r6,r2
81134f9c:	01604834 	movhi	r5,33056
81134fa0:	294c2404 	addi	r5,r5,12432
81134fa4:	e13fff17 	ldw	r4,-4(fp)
81134fa8:	11349ac0 	call	811349ac <alt_log_private_printf>
    return (0);
81134fac:	0005883a 	mov	r2,zero
}
81134fb0:	e037883a 	mov	sp,fp
81134fb4:	dfc00117 	ldw	ra,4(sp)
81134fb8:	df000017 	ldw	fp,0(sp)
81134fbc:	dec00504 	addi	sp,sp,20
81134fc0:	f800283a 	ret

81134fc4 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81134fc4:	defff904 	addi	sp,sp,-28
81134fc8:	de00012e 	bgeu	sp,et,81134fd0 <altera_avalon_jtag_uart_report_log+0xc>
81134fcc:	003b68fa 	trap	3
81134fd0:	dfc00615 	stw	ra,24(sp)
81134fd4:	df000515 	stw	fp,20(sp)
81134fd8:	dc400415 	stw	r17,16(sp)
81134fdc:	dc000315 	stw	r16,12(sp)
81134fe0:	df000504 	addi	fp,sp,20
81134fe4:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81134fe8:	d0a08083 	ldbu	r2,-32254(gp)
81134fec:	10803fcc 	andi	r2,r2,255
81134ff0:	10001426 	beq	r2,zero,81135044 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81134ff4:	e0bffd17 	ldw	r2,-12(fp)
81134ff8:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81134ffc:	00a04574 	movhi	r2,33045
81135000:	10b9d404 	addi	r2,r2,-6320
81135004:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81135008:	e0bffb17 	ldw	r2,-20(fp)
8113500c:	10800017 	ldw	r2,0(r2)
81135010:	e1bffc17 	ldw	r6,-16(fp)
81135014:	100b883a 	mov	r5,r2
81135018:	e13ffb17 	ldw	r4,-20(fp)
8113501c:	11350640 	call	81135064 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81135020:	d0e08717 	ldw	r3,-32228(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81135024:	00b33374 	movhi	r2,52429
81135028:	10b33344 	addi	r2,r2,-13107
8113502c:	1888383a 	mulxuu	r4,r3,r2
81135030:	1885383a 	mul	r2,r3,r2
81135034:	1021883a 	mov	r16,r2
81135038:	2023883a 	mov	r17,r4
8113503c:	8804d0fa 	srli	r2,r17,3
81135040:	00000106 	br	81135048 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81135044:	0005883a 	mov	r2,zero
    }
}
81135048:	e6fffe04 	addi	sp,fp,-8
8113504c:	dfc00317 	ldw	ra,12(sp)
81135050:	df000217 	ldw	fp,8(sp)
81135054:	dc400117 	ldw	r17,4(sp)
81135058:	dc000017 	ldw	r16,0(sp)
8113505c:	dec00404 	addi	sp,sp,16
81135060:	f800283a 	ret

81135064 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81135064:	deffef04 	addi	sp,sp,-68
81135068:	de00012e 	bgeu	sp,et,81135070 <alt_log_jtag_uart_print_control_reg+0xc>
8113506c:	003b68fa 	trap	3
81135070:	dfc01015 	stw	ra,64(sp)
81135074:	df000f15 	stw	fp,60(sp)
81135078:	df000f04 	addi	fp,sp,60
8113507c:	e13ffd15 	stw	r4,-12(fp)
81135080:	e17ffe15 	stw	r5,-8(fp)
81135084:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81135088:	e0bffe17 	ldw	r2,-8(fp)
8113508c:	10800104 	addi	r2,r2,4
81135090:	10800037 	ldwio	r2,0(r2)
81135094:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81135098:	e0bff617 	ldw	r2,-40(fp)
8113509c:	1004d43a 	srli	r2,r2,16
811350a0:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
811350a4:	e0bff617 	ldw	r2,-40(fp)
811350a8:	1080008c 	andi	r2,r2,2
811350ac:	1004d07a 	srli	r2,r2,1
811350b0:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
811350b4:	e0bff617 	ldw	r2,-40(fp)
811350b8:	1080004c 	andi	r2,r2,1
811350bc:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
811350c0:	e0bff617 	ldw	r2,-40(fp)
811350c4:	1080400c 	andi	r2,r2,256
811350c8:	1004d23a 	srli	r2,r2,8
811350cc:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
811350d0:	e0bff617 	ldw	r2,-40(fp)
811350d4:	1080800c 	andi	r2,r2,512
811350d8:	1004d27a 	srli	r2,r2,9
811350dc:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
811350e0:	e0bff617 	ldw	r2,-40(fp)
811350e4:	1081000c 	andi	r2,r2,1024
811350e8:	1004d2ba 	srli	r2,r2,10
811350ec:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811350f0:	e0bffd17 	ldw	r2,-12(fp)
811350f4:	10c01017 	ldw	r3,64(r2)
811350f8:	e0bffd17 	ldw	r2,-12(fp)
811350fc:	10800f17 	ldw	r2,60(r2)
81135100:	1887c83a 	sub	r3,r3,r2
81135104:	e0bff917 	ldw	r2,-28(fp)
81135108:	d8800415 	stw	r2,16(sp)
8113510c:	e0bff817 	ldw	r2,-32(fp)
81135110:	d8800315 	stw	r2,12(sp)
81135114:	e0bffa17 	ldw	r2,-24(fp)
81135118:	d8800215 	stw	r2,8(sp)
8113511c:	e0bffb17 	ldw	r2,-20(fp)
81135120:	d8800115 	stw	r2,4(sp)
81135124:	e0bffc17 	ldw	r2,-16(fp)
81135128:	d8800015 	stw	r2,0(sp)
8113512c:	e1fff717 	ldw	r7,-36(fp)
81135130:	180d883a 	mov	r6,r3
81135134:	e17fff17 	ldw	r5,-4(fp)
81135138:	01204574 	movhi	r4,33045
8113513c:	2139d704 	addi	r4,r4,-6308
81135140:	1134f640 	call	81134f64 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81135144:	0001883a 	nop

}
81135148:	e037883a 	mov	sp,fp
8113514c:	dfc00117 	ldw	ra,4(sp)
81135150:	df000017 	ldw	fp,0(sp)
81135154:	dec00204 	addi	sp,sp,8
81135158:	f800283a 	ret

8113515c <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
8113515c:	defffb04 	addi	sp,sp,-20
81135160:	de00012e 	bgeu	sp,et,81135168 <alt_log_jtag_uart_startup_info+0xc>
81135164:	003b68fa 	trap	3
81135168:	dfc00415 	stw	ra,16(sp)
8113516c:	df000315 	stw	fp,12(sp)
81135170:	df000304 	addi	fp,sp,12
81135174:	e13ffe15 	stw	r4,-8(fp)
81135178:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
8113517c:	00a04574 	movhi	r2,33045
81135180:	10b9e904 	addi	r2,r2,-6236
81135184:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81135188:	e1bffd17 	ldw	r6,-12(fp)
8113518c:	e17fff17 	ldw	r5,-4(fp)
81135190:	e13ffe17 	ldw	r4,-8(fp)
81135194:	11350640 	call	81135064 <alt_log_jtag_uart_print_control_reg>
     return;
81135198:	0001883a 	nop
}
8113519c:	e037883a 	mov	sp,fp
811351a0:	dfc00117 	ldw	ra,4(sp)
811351a4:	df000017 	ldw	fp,0(sp)
811351a8:	dec00204 	addi	sp,sp,8
811351ac:	f800283a 	ret

811351b0 <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
811351b0:	defffb04 	addi	sp,sp,-20
811351b4:	de00012e 	bgeu	sp,et,811351bc <alt_log_jtag_uart_isr_proc+0xc>
811351b8:	003b68fa 	trap	3
811351bc:	dfc00415 	stw	ra,16(sp)
811351c0:	df000315 	stw	fp,12(sp)
811351c4:	df000304 	addi	fp,sp,12
811351c8:	e13ffe15 	stw	r4,-8(fp)
811351cc:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811351d0:	d0a080c3 	ldbu	r2,-32253(gp)
811351d4:	10803fcc 	andi	r2,r2,255
811351d8:	10000826 	beq	r2,zero,811351fc <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
811351dc:	00a04574 	movhi	r2,33045
811351e0:	10b9ee04 	addi	r2,r2,-6216
811351e4:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
811351e8:	e1bffd17 	ldw	r6,-12(fp)
811351ec:	e17ffe17 	ldw	r5,-8(fp)
811351f0:	e13fff17 	ldw	r4,-4(fp)
811351f4:	11350640 	call	81135064 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811351f8:	0001883a 	nop
811351fc:	0001883a 	nop
}
81135200:	e037883a 	mov	sp,fp
81135204:	dfc00117 	ldw	ra,4(sp)
81135208:	df000017 	ldw	fp,0(sp)
8113520c:	dec00204 	addi	sp,sp,8
81135210:	f800283a 	ret

81135214 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
81135214:	defffa04 	addi	sp,sp,-24
81135218:	de00012e 	bgeu	sp,et,81135220 <alt_log_write+0xc>
8113521c:	003b68fa 	trap	3
81135220:	dfc00515 	stw	ra,20(sp)
81135224:	df000415 	stw	fp,16(sp)
81135228:	df000404 	addi	fp,sp,16
8113522c:	e13ffe15 	stw	r4,-8(fp)
81135230:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81135234:	d0a08003 	ldbu	r2,-32256(gp)
81135238:	10803fcc 	andi	r2,r2,255
8113523c:	10004026 	beq	r2,zero,81135340 <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
81135240:	e0bfff17 	ldw	r2,-4(fp)
81135244:	10c00430 	cmpltui	r3,r2,16
81135248:	1800011e 	bne	r3,zero,81135250 <alt_log_write+0x3c>
8113524c:	008003c4 	movi	r2,15
81135250:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81135254:	e0bffd17 	ldw	r2,-12(fp)
81135258:	10800088 	cmpgei	r2,r2,2
8113525c:	10003726 	beq	r2,zero,8113533c <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
81135260:	e0bffd17 	ldw	r2,-12(fp)
81135264:	100d883a 	mov	r6,r2
81135268:	e17ffe17 	ldw	r5,-8(fp)
8113526c:	012045b4 	movhi	r4,33046
81135270:	2111cf04 	addi	r4,r4,18236
81135274:	11491e00 	call	811491e0 <strncpy>
    alt_log_write_buf[length-1]='\n';
81135278:	e0bffd17 	ldw	r2,-12(fp)
8113527c:	10ffffc4 	addi	r3,r2,-1
81135280:	00a045b4 	movhi	r2,33046
81135284:	1091cf04 	addi	r2,r2,18236
81135288:	10c5883a 	add	r2,r2,r3
8113528c:	00c00284 	movi	r3,10
81135290:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81135294:	00a045b4 	movhi	r2,33046
81135298:	1091cf04 	addi	r2,r2,18236
8113529c:	e0fffd17 	ldw	r3,-12(fp)
811352a0:	10c5883a 	add	r2,r2,r3
811352a4:	00c00344 	movi	r3,13
811352a8:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
811352ac:	e0bffd17 	ldw	r2,-12(fp)
811352b0:	10c00044 	addi	r3,r2,1
811352b4:	00a045b4 	movhi	r2,33046
811352b8:	1091cf04 	addi	r2,r2,18236
811352bc:	10c5883a 	add	r2,r2,r3
811352c0:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811352c4:	e03ffc15 	stw	zero,-16(fp)
811352c8:	00001306 	br	81135318 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811352cc:	00a045b4 	movhi	r2,33046
811352d0:	1091cf04 	addi	r2,r2,18236
811352d4:	e0fffc17 	ldw	r3,-16(fp)
811352d8:	10c5883a 	add	r2,r2,r3
811352dc:	10800003 	ldbu	r2,0(r2)
811352e0:	10803fcc 	andi	r2,r2,255
811352e4:	1080201c 	xori	r2,r2,128
811352e8:	10bfe004 	addi	r2,r2,-128
811352ec:	10800118 	cmpnei	r2,r2,4
811352f0:	1000061e 	bne	r2,zero,8113530c <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811352f4:	00a045b4 	movhi	r2,33046
811352f8:	1091cf04 	addi	r2,r2,18236
811352fc:	e0fffc17 	ldw	r3,-16(fp)
81135300:	10c5883a 	add	r2,r2,r3
81135304:	00c01104 	movi	r3,68
81135308:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
8113530c:	e0bffc17 	ldw	r2,-16(fp)
81135310:	10800044 	addi	r2,r2,1
81135314:	e0bffc15 	stw	r2,-16(fp)
81135318:	e0fffc17 	ldw	r3,-16(fp)
8113531c:	e0bffd17 	ldw	r2,-12(fp)
81135320:	18bfea16 	blt	r3,r2,811352cc <__reset+0xfb1152cc>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81135324:	016045b4 	movhi	r5,33046
81135328:	2951cf04 	addi	r5,r5,18236
8113532c:	01204574 	movhi	r4,33045
81135330:	2139f104 	addi	r4,r4,-6204
81135334:	1134f640 	call	81134f64 <alt_log_printf_proc>
81135338:	00000106 	br	81135340 <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
8113533c:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
81135340:	e037883a 	mov	sp,fp
81135344:	dfc00117 	ldw	ra,4(sp)
81135348:	df000017 	ldw	fp,0(sp)
8113534c:	dec00204 	addi	sp,sp,8
81135350:	f800283a 	ret

81135354 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81135354:	defffe04 	addi	sp,sp,-8
81135358:	de00012e 	bgeu	sp,et,81135360 <alt_log_system_clock+0xc>
8113535c:	003b68fa 	trap	3
81135360:	dfc00115 	stw	ra,4(sp)
81135364:	df000015 	stw	fp,0(sp)
81135368:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
8113536c:	d0a08043 	ldbu	r2,-32255(gp)
81135370:	10803fcc 	andi	r2,r2,255
81135374:	10000e26 	beq	r2,zero,811353b0 <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81135378:	d0a08317 	ldw	r2,-32244(gp)
8113537c:	10800044 	addi	r2,r2,1
81135380:	d0a08315 	stw	r2,-32244(gp)
81135384:	d0a08717 	ldw	r2,-32228(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81135388:	d0e08317 	ldw	r3,-32244(gp)
8113538c:	10c0082e 	bgeu	r2,r3,811353b0 <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
81135390:	d0208315 	stw	zero,-32244(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81135394:	d0a08217 	ldw	r2,-32248(gp)
81135398:	10c00044 	addi	r3,r2,1
8113539c:	d0e08215 	stw	r3,-32248(gp)
811353a0:	100b883a 	mov	r5,r2
811353a4:	01204574 	movhi	r4,33045
811353a8:	2139f504 	addi	r4,r4,-6188
811353ac:	1134f640 	call	81134f64 <alt_log_printf_proc>
        }
    }
}
811353b0:	0001883a 	nop
811353b4:	e037883a 	mov	sp,fp
811353b8:	dfc00117 	ldw	ra,4(sp)
811353bc:	df000017 	ldw	fp,0(sp)
811353c0:	dec00204 	addi	sp,sp,8
811353c4:	f800283a 	ret

811353c8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811353c8:	defffe04 	addi	sp,sp,-8
811353cc:	de00012e 	bgeu	sp,et,811353d4 <alt_get_errno+0xc>
811353d0:	003b68fa 	trap	3
811353d4:	dfc00115 	stw	ra,4(sp)
811353d8:	df000015 	stw	fp,0(sp)
811353dc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811353e0:	d0a01017 	ldw	r2,-32704(gp)
811353e4:	10000326 	beq	r2,zero,811353f4 <alt_get_errno+0x2c>
811353e8:	d0a01017 	ldw	r2,-32704(gp)
811353ec:	103ee83a 	callr	r2
811353f0:	00000106 	br	811353f8 <alt_get_errno+0x30>
811353f4:	d0a07704 	addi	r2,gp,-32292
}
811353f8:	e037883a 	mov	sp,fp
811353fc:	dfc00117 	ldw	ra,4(sp)
81135400:	df000017 	ldw	fp,0(sp)
81135404:	dec00204 	addi	sp,sp,8
81135408:	f800283a 	ret

8113540c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
8113540c:	defff904 	addi	sp,sp,-28
81135410:	de00012e 	bgeu	sp,et,81135418 <lseek+0xc>
81135414:	003b68fa 	trap	3
81135418:	dfc00615 	stw	ra,24(sp)
8113541c:	df000515 	stw	fp,20(sp)
81135420:	df000504 	addi	fp,sp,20
81135424:	e13ffd15 	stw	r4,-12(fp)
81135428:	e17ffe15 	stw	r5,-8(fp)
8113542c:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
81135430:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81135434:	e0bffd17 	ldw	r2,-12(fp)
81135438:	10000616 	blt	r2,zero,81135454 <lseek+0x48>
8113543c:	e0bffd17 	ldw	r2,-12(fp)
81135440:	10c00324 	muli	r3,r2,12
81135444:	00a04574 	movhi	r2,33045
81135448:	10bdae04 	addi	r2,r2,-2376
8113544c:	1885883a 	add	r2,r3,r2
81135450:	00000106 	br	81135458 <lseek+0x4c>
81135454:	0005883a 	mov	r2,zero
81135458:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
8113545c:	e0bffc17 	ldw	r2,-16(fp)
81135460:	10001026 	beq	r2,zero,811354a4 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81135464:	e0bffc17 	ldw	r2,-16(fp)
81135468:	10800017 	ldw	r2,0(r2)
8113546c:	10800717 	ldw	r2,28(r2)
81135470:	10000926 	beq	r2,zero,81135498 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81135474:	e0bffc17 	ldw	r2,-16(fp)
81135478:	10800017 	ldw	r2,0(r2)
8113547c:	10800717 	ldw	r2,28(r2)
81135480:	e1bfff17 	ldw	r6,-4(fp)
81135484:	e17ffe17 	ldw	r5,-8(fp)
81135488:	e13ffc17 	ldw	r4,-16(fp)
8113548c:	103ee83a 	callr	r2
81135490:	e0bffb15 	stw	r2,-20(fp)
81135494:	00000506 	br	811354ac <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81135498:	00bfde84 	movi	r2,-134
8113549c:	e0bffb15 	stw	r2,-20(fp)
811354a0:	00000206 	br	811354ac <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
811354a4:	00bfebc4 	movi	r2,-81
811354a8:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
811354ac:	e0bffb17 	ldw	r2,-20(fp)
811354b0:	1000070e 	bge	r2,zero,811354d0 <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
811354b4:	11353c80 	call	811353c8 <alt_get_errno>
811354b8:	1007883a 	mov	r3,r2
811354bc:	e0bffb17 	ldw	r2,-20(fp)
811354c0:	0085c83a 	sub	r2,zero,r2
811354c4:	18800015 	stw	r2,0(r3)
    rc = -1;
811354c8:	00bfffc4 	movi	r2,-1
811354cc:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811354d0:	e0bffb17 	ldw	r2,-20(fp)
}
811354d4:	e037883a 	mov	sp,fp
811354d8:	dfc00117 	ldw	ra,4(sp)
811354dc:	df000017 	ldw	fp,0(sp)
811354e0:	dec00204 	addi	sp,sp,8
811354e4:	f800283a 	ret

811354e8 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811354e8:	defff904 	addi	sp,sp,-28
811354ec:	de00012e 	bgeu	sp,et,811354f4 <alt_main+0xc>
811354f0:	003b68fa 	trap	3
811354f4:	dfc00615 	stw	ra,24(sp)
811354f8:	df000515 	stw	fp,20(sp)
811354fc:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
81135500:	d0a01217 	ldw	r2,-32696(gp)
81135504:	10800058 	cmpnei	r2,r2,1
81135508:	1000031e 	bne	r2,zero,81135518 <alt_main+0x30>
8113550c:	01204574 	movhi	r4,33045
81135510:	2139fb04 	addi	r4,r4,-6164
81135514:	1134f640 	call	81134f64 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
81135518:	0009883a 	mov	r4,zero
8113551c:	11400400 	call	81140040 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
81135520:	d0a01217 	ldw	r2,-32696(gp)
81135524:	10800058 	cmpnei	r2,r2,1
81135528:	1000031e 	bne	r2,zero,81135538 <alt_main+0x50>
8113552c:	01204574 	movhi	r4,33045
81135530:	213a0904 	addi	r4,r4,-6108
81135534:	1134f640 	call	81134f64 <alt_log_printf_proc>
  ALT_OS_INIT();
81135538:	1136ad40 	call	81136ad4 <OSInit>
8113553c:	01000044 	movi	r4,1
81135540:	113c7f00 	call	8113c7f0 <OSSemCreate>
81135544:	d0a08a15 	stw	r2,-32216(gp)
81135548:	01000044 	movi	r4,1
8113554c:	113c7f00 	call	8113c7f0 <OSSemCreate>
81135550:	d0a08c15 	stw	r2,-32208(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81135554:	d0a01217 	ldw	r2,-32696(gp)
81135558:	10800058 	cmpnei	r2,r2,1
8113555c:	1000031e 	bne	r2,zero,8113556c <alt_main+0x84>
81135560:	01204574 	movhi	r4,33045
81135564:	213a1704 	addi	r4,r4,-6052
81135568:	1134f640 	call	81134f64 <alt_log_printf_proc>
8113556c:	d0a07e04 	addi	r2,gp,-32264
81135570:	e0bffc15 	stw	r2,-16(fp)
81135574:	00800044 	movi	r2,1
81135578:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8113557c:	e0bffd0b 	ldhu	r2,-12(fp)
81135580:	1009883a 	mov	r4,r2
81135584:	113c7f00 	call	8113c7f0 <OSSemCreate>
81135588:	1007883a 	mov	r3,r2
8113558c:	e0bffc17 	ldw	r2,-16(fp)
81135590:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81135594:	d0a01217 	ldw	r2,-32696(gp)
81135598:	10800058 	cmpnei	r2,r2,1
8113559c:	1000031e 	bne	r2,zero,811355ac <alt_main+0xc4>
811355a0:	01204574 	movhi	r4,33045
811355a4:	213a2504 	addi	r4,r4,-5996
811355a8:	1134f640 	call	81134f64 <alt_log_printf_proc>
  alt_sys_init();
811355ac:	11400800 	call	81140080 <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
811355b0:	d0a01217 	ldw	r2,-32696(gp)
811355b4:	10800058 	cmpnei	r2,r2,1
811355b8:	1000031e 	bne	r2,zero,811355c8 <alt_main+0xe0>
811355bc:	01204574 	movhi	r4,33045
811355c0:	213a2f04 	addi	r4,r4,-5956
811355c4:	1134f640 	call	81134f64 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811355c8:	d0a01217 	ldw	r2,-32696(gp)
811355cc:	10800058 	cmpnei	r2,r2,1
811355d0:	1000031e 	bne	r2,zero,811355e0 <alt_main+0xf8>
811355d4:	01204574 	movhi	r4,33045
811355d8:	213a3804 	addi	r4,r4,-5920
811355dc:	1134f640 	call	81134f64 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811355e0:	01a04574 	movhi	r6,33045
811355e4:	31ba4004 	addi	r6,r6,-5888
811355e8:	01604574 	movhi	r5,33045
811355ec:	297a4504 	addi	r5,r5,-5868
811355f0:	01204574 	movhi	r4,33045
811355f4:	213a4504 	addi	r4,r4,-5868
811355f8:	11489700 	call	81148970 <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811355fc:	d0a01217 	ldw	r2,-32696(gp)
81135600:	10800058 	cmpnei	r2,r2,1
81135604:	1000031e 	bne	r2,zero,81135614 <alt_main+0x12c>
81135608:	01204574 	movhi	r4,33045
8113560c:	213a4904 	addi	r4,r4,-5852
81135610:	1134f640 	call	81134f64 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
81135614:	d0a08417 	ldw	r2,-32240(gp)
81135618:	d0e08517 	ldw	r3,-32236(gp)
8113561c:	d1208617 	ldw	r4,-32232(gp)
81135620:	200d883a 	mov	r6,r4
81135624:	180b883a 	mov	r5,r3
81135628:	1009883a 	mov	r4,r2
8113562c:	11164f00 	call	811164f0 <main>
81135630:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81135634:	01000044 	movi	r4,1
81135638:	11344140 	call	81134414 <close>
  exit (result);
8113563c:	e13ffb17 	ldw	r4,-20(fp)
81135640:	11491240 	call	81149124 <exit>

81135644 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81135644:	defffe04 	addi	sp,sp,-8
81135648:	de00012e 	bgeu	sp,et,81135650 <alt_get_errno+0xc>
8113564c:	003b68fa 	trap	3
81135650:	dfc00115 	stw	ra,4(sp)
81135654:	df000015 	stw	fp,0(sp)
81135658:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113565c:	d0a01017 	ldw	r2,-32704(gp)
81135660:	10000326 	beq	r2,zero,81135670 <alt_get_errno+0x2c>
81135664:	d0a01017 	ldw	r2,-32704(gp)
81135668:	103ee83a 	callr	r2
8113566c:	00000106 	br	81135674 <alt_get_errno+0x30>
81135670:	d0a07704 	addi	r2,gp,-32292
}
81135674:	e037883a 	mov	sp,fp
81135678:	dfc00117 	ldw	ra,4(sp)
8113567c:	df000017 	ldw	fp,0(sp)
81135680:	dec00204 	addi	sp,sp,8
81135684:	f800283a 	ret

81135688 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81135688:	defffd04 	addi	sp,sp,-12
8113568c:	de00012e 	bgeu	sp,et,81135694 <alt_file_locked+0xc>
81135690:	003b68fa 	trap	3
81135694:	df000215 	stw	fp,8(sp)
81135698:	df000204 	addi	fp,sp,8
8113569c:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
811356a0:	e0bfff17 	ldw	r2,-4(fp)
811356a4:	10800217 	ldw	r2,8(r2)
811356a8:	10d00034 	orhi	r3,r2,16384
811356ac:	e0bfff17 	ldw	r2,-4(fp)
811356b0:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
811356b4:	e03ffe15 	stw	zero,-8(fp)
811356b8:	00001d06 	br	81135730 <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811356bc:	00a04574 	movhi	r2,33045
811356c0:	10bdae04 	addi	r2,r2,-2376
811356c4:	e0fffe17 	ldw	r3,-8(fp)
811356c8:	18c00324 	muli	r3,r3,12
811356cc:	10c5883a 	add	r2,r2,r3
811356d0:	10c00017 	ldw	r3,0(r2)
811356d4:	e0bfff17 	ldw	r2,-4(fp)
811356d8:	10800017 	ldw	r2,0(r2)
811356dc:	1880111e 	bne	r3,r2,81135724 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811356e0:	00a04574 	movhi	r2,33045
811356e4:	10bdae04 	addi	r2,r2,-2376
811356e8:	e0fffe17 	ldw	r3,-8(fp)
811356ec:	18c00324 	muli	r3,r3,12
811356f0:	10c5883a 	add	r2,r2,r3
811356f4:	10800204 	addi	r2,r2,8
811356f8:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811356fc:	1000090e 	bge	r2,zero,81135724 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
81135700:	e0bffe17 	ldw	r2,-8(fp)
81135704:	10c00324 	muli	r3,r2,12
81135708:	00a04574 	movhi	r2,33045
8113570c:	10bdae04 	addi	r2,r2,-2376
81135710:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
81135714:	e0bfff17 	ldw	r2,-4(fp)
81135718:	18800226 	beq	r3,r2,81135724 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
8113571c:	00bffcc4 	movi	r2,-13
81135720:	00000806 	br	81135744 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81135724:	e0bffe17 	ldw	r2,-8(fp)
81135728:	10800044 	addi	r2,r2,1
8113572c:	e0bffe15 	stw	r2,-8(fp)
81135730:	d0a00f17 	ldw	r2,-32708(gp)
81135734:	1007883a 	mov	r3,r2
81135738:	e0bffe17 	ldw	r2,-8(fp)
8113573c:	18bfdf2e 	bgeu	r3,r2,811356bc <__reset+0xfb1156bc>
    }
  }
  
  /* The device is not locked */
 
  return 0;
81135740:	0005883a 	mov	r2,zero
}
81135744:	e037883a 	mov	sp,fp
81135748:	df000017 	ldw	fp,0(sp)
8113574c:	dec00104 	addi	sp,sp,4
81135750:	f800283a 	ret

81135754 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81135754:	defff604 	addi	sp,sp,-40
81135758:	de00012e 	bgeu	sp,et,81135760 <open+0xc>
8113575c:	003b68fa 	trap	3
81135760:	dfc00915 	stw	ra,36(sp)
81135764:	df000815 	stw	fp,32(sp)
81135768:	df000804 	addi	fp,sp,32
8113576c:	e13ffd15 	stw	r4,-12(fp)
81135770:	e17ffe15 	stw	r5,-8(fp)
81135774:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81135778:	00bfffc4 	movi	r2,-1
8113577c:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
81135780:	00bffb44 	movi	r2,-19
81135784:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81135788:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
8113578c:	d1600d04 	addi	r5,gp,-32716
81135790:	e13ffd17 	ldw	r4,-12(fp)
81135794:	11483500 	call	81148350 <alt_find_dev>
81135798:	e0bff815 	stw	r2,-32(fp)
8113579c:	e0bff817 	ldw	r2,-32(fp)
811357a0:	1000051e 	bne	r2,zero,811357b8 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
811357a4:	e13ffd17 	ldw	r4,-12(fp)
811357a8:	11483e80 	call	811483e8 <alt_find_file>
811357ac:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
811357b0:	00800044 	movi	r2,1
811357b4:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
811357b8:	e0bff817 	ldw	r2,-32(fp)
811357bc:	10002926 	beq	r2,zero,81135864 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
811357c0:	e13ff817 	ldw	r4,-32(fp)
811357c4:	11484f80 	call	811484f8 <alt_get_fd>
811357c8:	e0bff915 	stw	r2,-28(fp)
811357cc:	e0bff917 	ldw	r2,-28(fp)
811357d0:	1000030e 	bge	r2,zero,811357e0 <open+0x8c>
    {
      status = index;
811357d4:	e0bff917 	ldw	r2,-28(fp)
811357d8:	e0bffa15 	stw	r2,-24(fp)
811357dc:	00002306 	br	8113586c <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811357e0:	e0bff917 	ldw	r2,-28(fp)
811357e4:	10c00324 	muli	r3,r2,12
811357e8:	00a04574 	movhi	r2,33045
811357ec:	10bdae04 	addi	r2,r2,-2376
811357f0:	1885883a 	add	r2,r3,r2
811357f4:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811357f8:	e0fffe17 	ldw	r3,-8(fp)
811357fc:	00900034 	movhi	r2,16384
81135800:	10bfffc4 	addi	r2,r2,-1
81135804:	1886703a 	and	r3,r3,r2
81135808:	e0bffc17 	ldw	r2,-16(fp)
8113580c:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
81135810:	e0bffb17 	ldw	r2,-20(fp)
81135814:	1000051e 	bne	r2,zero,8113582c <open+0xd8>
81135818:	e13ffc17 	ldw	r4,-16(fp)
8113581c:	11356880 	call	81135688 <alt_file_locked>
81135820:	e0bffa15 	stw	r2,-24(fp)
81135824:	e0bffa17 	ldw	r2,-24(fp)
81135828:	10001016 	blt	r2,zero,8113586c <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
8113582c:	e0bff817 	ldw	r2,-32(fp)
81135830:	10800317 	ldw	r2,12(r2)
81135834:	10000826 	beq	r2,zero,81135858 <open+0x104>
81135838:	e0bff817 	ldw	r2,-32(fp)
8113583c:	10800317 	ldw	r2,12(r2)
81135840:	e1ffff17 	ldw	r7,-4(fp)
81135844:	e1bffe17 	ldw	r6,-8(fp)
81135848:	e17ffd17 	ldw	r5,-12(fp)
8113584c:	e13ffc17 	ldw	r4,-16(fp)
81135850:	103ee83a 	callr	r2
81135854:	00000106 	br	8113585c <open+0x108>
81135858:	0005883a 	mov	r2,zero
8113585c:	e0bffa15 	stw	r2,-24(fp)
81135860:	00000206 	br	8113586c <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81135864:	00bffb44 	movi	r2,-19
81135868:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
8113586c:	e0bffa17 	ldw	r2,-24(fp)
81135870:	1000090e 	bge	r2,zero,81135898 <open+0x144>
  {
    alt_release_fd (index);  
81135874:	e13ff917 	ldw	r4,-28(fp)
81135878:	11359f80 	call	811359f8 <alt_release_fd>
    ALT_ERRNO = -status;
8113587c:	11356440 	call	81135644 <alt_get_errno>
81135880:	1007883a 	mov	r3,r2
81135884:	e0bffa17 	ldw	r2,-24(fp)
81135888:	0085c83a 	sub	r2,zero,r2
8113588c:	18800015 	stw	r2,0(r3)
    return -1;
81135890:	00bfffc4 	movi	r2,-1
81135894:	00000106 	br	8113589c <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81135898:	e0bff917 	ldw	r2,-28(fp)
}
8113589c:	e037883a 	mov	sp,fp
811358a0:	dfc00117 	ldw	ra,4(sp)
811358a4:	df000017 	ldw	fp,0(sp)
811358a8:	dec00204 	addi	sp,sp,8
811358ac:	f800283a 	ret

811358b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811358b0:	defffe04 	addi	sp,sp,-8
811358b4:	de00012e 	bgeu	sp,et,811358bc <alt_get_errno+0xc>
811358b8:	003b68fa 	trap	3
811358bc:	dfc00115 	stw	ra,4(sp)
811358c0:	df000015 	stw	fp,0(sp)
811358c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811358c8:	d0a01017 	ldw	r2,-32704(gp)
811358cc:	10000326 	beq	r2,zero,811358dc <alt_get_errno+0x2c>
811358d0:	d0a01017 	ldw	r2,-32704(gp)
811358d4:	103ee83a 	callr	r2
811358d8:	00000106 	br	811358e0 <alt_get_errno+0x30>
811358dc:	d0a07704 	addi	r2,gp,-32292
}
811358e0:	e037883a 	mov	sp,fp
811358e4:	dfc00117 	ldw	ra,4(sp)
811358e8:	df000017 	ldw	fp,0(sp)
811358ec:	dec00204 	addi	sp,sp,8
811358f0:	f800283a 	ret

811358f4 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
811358f4:	defff904 	addi	sp,sp,-28
811358f8:	de00012e 	bgeu	sp,et,81135900 <read+0xc>
811358fc:	003b68fa 	trap	3
81135900:	dfc00615 	stw	ra,24(sp)
81135904:	df000515 	stw	fp,20(sp)
81135908:	df000504 	addi	fp,sp,20
8113590c:	e13ffd15 	stw	r4,-12(fp)
81135910:	e17ffe15 	stw	r5,-8(fp)
81135914:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81135918:	e0bffd17 	ldw	r2,-12(fp)
8113591c:	10000616 	blt	r2,zero,81135938 <read+0x44>
81135920:	e0bffd17 	ldw	r2,-12(fp)
81135924:	10c00324 	muli	r3,r2,12
81135928:	00a04574 	movhi	r2,33045
8113592c:	10bdae04 	addi	r2,r2,-2376
81135930:	1885883a 	add	r2,r3,r2
81135934:	00000106 	br	8113593c <read+0x48>
81135938:	0005883a 	mov	r2,zero
8113593c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81135940:	e0bffb17 	ldw	r2,-20(fp)
81135944:	10002226 	beq	r2,zero,811359d0 <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81135948:	e0bffb17 	ldw	r2,-20(fp)
8113594c:	10800217 	ldw	r2,8(r2)
81135950:	108000cc 	andi	r2,r2,3
81135954:	10800060 	cmpeqi	r2,r2,1
81135958:	1000181e 	bne	r2,zero,811359bc <read+0xc8>
        (fd->dev->read))
8113595c:	e0bffb17 	ldw	r2,-20(fp)
81135960:	10800017 	ldw	r2,0(r2)
81135964:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81135968:	10001426 	beq	r2,zero,811359bc <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
8113596c:	e0bffb17 	ldw	r2,-20(fp)
81135970:	10800017 	ldw	r2,0(r2)
81135974:	10800517 	ldw	r2,20(r2)
81135978:	e0ffff17 	ldw	r3,-4(fp)
8113597c:	180d883a 	mov	r6,r3
81135980:	e17ffe17 	ldw	r5,-8(fp)
81135984:	e13ffb17 	ldw	r4,-20(fp)
81135988:	103ee83a 	callr	r2
8113598c:	e0bffc15 	stw	r2,-16(fp)
81135990:	e0bffc17 	ldw	r2,-16(fp)
81135994:	1000070e 	bge	r2,zero,811359b4 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81135998:	11358b00 	call	811358b0 <alt_get_errno>
8113599c:	1007883a 	mov	r3,r2
811359a0:	e0bffc17 	ldw	r2,-16(fp)
811359a4:	0085c83a 	sub	r2,zero,r2
811359a8:	18800015 	stw	r2,0(r3)
          return -1;
811359ac:	00bfffc4 	movi	r2,-1
811359b0:	00000c06 	br	811359e4 <read+0xf0>
        }
        return rval;
811359b4:	e0bffc17 	ldw	r2,-16(fp)
811359b8:	00000a06 	br	811359e4 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
811359bc:	11358b00 	call	811358b0 <alt_get_errno>
811359c0:	1007883a 	mov	r3,r2
811359c4:	00800344 	movi	r2,13
811359c8:	18800015 	stw	r2,0(r3)
811359cc:	00000406 	br	811359e0 <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811359d0:	11358b00 	call	811358b0 <alt_get_errno>
811359d4:	1007883a 	mov	r3,r2
811359d8:	00801444 	movi	r2,81
811359dc:	18800015 	stw	r2,0(r3)
  }
  return -1;
811359e0:	00bfffc4 	movi	r2,-1
}
811359e4:	e037883a 	mov	sp,fp
811359e8:	dfc00117 	ldw	ra,4(sp)
811359ec:	df000017 	ldw	fp,0(sp)
811359f0:	dec00204 	addi	sp,sp,8
811359f4:	f800283a 	ret

811359f8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811359f8:	defffe04 	addi	sp,sp,-8
811359fc:	de00012e 	bgeu	sp,et,81135a04 <alt_release_fd+0xc>
81135a00:	003b68fa 	trap	3
81135a04:	df000115 	stw	fp,4(sp)
81135a08:	df000104 	addi	fp,sp,4
81135a0c:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
81135a10:	e0bfff17 	ldw	r2,-4(fp)
81135a14:	108000d0 	cmplti	r2,r2,3
81135a18:	10000d1e 	bne	r2,zero,81135a50 <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
81135a1c:	00a04574 	movhi	r2,33045
81135a20:	10bdae04 	addi	r2,r2,-2376
81135a24:	e0ffff17 	ldw	r3,-4(fp)
81135a28:	18c00324 	muli	r3,r3,12
81135a2c:	10c5883a 	add	r2,r2,r3
81135a30:	10800204 	addi	r2,r2,8
81135a34:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81135a38:	00a04574 	movhi	r2,33045
81135a3c:	10bdae04 	addi	r2,r2,-2376
81135a40:	e0ffff17 	ldw	r3,-4(fp)
81135a44:	18c00324 	muli	r3,r3,12
81135a48:	10c5883a 	add	r2,r2,r3
81135a4c:	10000015 	stw	zero,0(r2)
  }
}
81135a50:	0001883a 	nop
81135a54:	e037883a 	mov	sp,fp
81135a58:	df000017 	ldw	fp,0(sp)
81135a5c:	dec00104 	addi	sp,sp,4
81135a60:	f800283a 	ret

81135a64 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81135a64:	defff604 	addi	sp,sp,-40
81135a68:	de00012e 	bgeu	sp,et,81135a70 <sbrk+0xc>
81135a6c:	003b68fa 	trap	3
81135a70:	df000915 	stw	fp,36(sp)
81135a74:	df000904 	addi	fp,sp,36
81135a78:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135a7c:	0005303a 	rdctl	r2,status
81135a80:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135a84:	e0fffe17 	ldw	r3,-8(fp)
81135a88:	00bfff84 	movi	r2,-2
81135a8c:	1884703a 	and	r2,r3,r2
81135a90:	1001703a 	wrctl	status,r2
  
  return context;
81135a94:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81135a98:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81135a9c:	d0a01317 	ldw	r2,-32692(gp)
81135aa0:	10c000c4 	addi	r3,r2,3
81135aa4:	00bfff04 	movi	r2,-4
81135aa8:	1884703a 	and	r2,r3,r2
81135aac:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81135ab0:	d0e01317 	ldw	r3,-32692(gp)
81135ab4:	e0bfff17 	ldw	r2,-4(fp)
81135ab8:	1887883a 	add	r3,r3,r2
81135abc:	00a04834 	movhi	r2,33056
81135ac0:	10a80004 	addi	r2,r2,-24576
81135ac4:	10c0062e 	bgeu	r2,r3,81135ae0 <sbrk+0x7c>
81135ac8:	e0bff817 	ldw	r2,-32(fp)
81135acc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135ad0:	e0bff717 	ldw	r2,-36(fp)
81135ad4:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81135ad8:	00bfffc4 	movi	r2,-1
81135adc:	00001c06 	br	81135b50 <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81135ae0:	d0a01317 	ldw	r2,-32692(gp)
81135ae4:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81135ae8:	d0e01317 	ldw	r3,-32692(gp)
81135aec:	e0bfff17 	ldw	r2,-4(fp)
81135af0:	1885883a 	add	r2,r3,r2
81135af4:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81135af8:	c005883a 	mov	r2,et
81135afc:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81135b00:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81135b04:	e0bffa17 	ldw	r2,-24(fp)
81135b08:	18800c1e 	bne	r3,r2,81135b3c <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81135b0c:	d805883a 	mov	r2,sp
81135b10:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81135b14:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81135b18:	d0e01317 	ldw	r3,-32692(gp)
81135b1c:	18800136 	bltu	r3,r2,81135b24 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81135b20:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81135b24:	d0a01317 	ldw	r2,-32692(gp)
81135b28:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81135b2c:	e0bffc17 	ldw	r2,-16(fp)
81135b30:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81135b34:	e0bffc17 	ldw	r2,-16(fp)
81135b38:	1031883a 	mov	et,r2
81135b3c:	e0bff817 	ldw	r2,-32(fp)
81135b40:	e0bffd15 	stw	r2,-12(fp)
81135b44:	e0bffd17 	ldw	r2,-12(fp)
81135b48:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81135b4c:	e0bffa17 	ldw	r2,-24(fp)
} 
81135b50:	e037883a 	mov	sp,fp
81135b54:	df000017 	ldw	fp,0(sp)
81135b58:	dec00104 	addi	sp,sp,4
81135b5c:	f800283a 	ret

81135b60 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81135b60:	defffa04 	addi	sp,sp,-24
81135b64:	de00012e 	bgeu	sp,et,81135b6c <alt_alarm_stop+0xc>
81135b68:	003b68fa 	trap	3
81135b6c:	df000515 	stw	fp,20(sp)
81135b70:	df000504 	addi	fp,sp,20
81135b74:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135b78:	0005303a 	rdctl	r2,status
81135b7c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135b80:	e0fffc17 	ldw	r3,-16(fp)
81135b84:	00bfff84 	movi	r2,-2
81135b88:	1884703a 	and	r2,r3,r2
81135b8c:	1001703a 	wrctl	status,r2
  
  return context;
81135b90:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81135b94:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81135b98:	e0bfff17 	ldw	r2,-4(fp)
81135b9c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81135ba0:	e0bffd17 	ldw	r2,-12(fp)
81135ba4:	10800017 	ldw	r2,0(r2)
81135ba8:	e0fffd17 	ldw	r3,-12(fp)
81135bac:	18c00117 	ldw	r3,4(r3)
81135bb0:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81135bb4:	e0bffd17 	ldw	r2,-12(fp)
81135bb8:	10800117 	ldw	r2,4(r2)
81135bbc:	e0fffd17 	ldw	r3,-12(fp)
81135bc0:	18c00017 	ldw	r3,0(r3)
81135bc4:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81135bc8:	e0bffd17 	ldw	r2,-12(fp)
81135bcc:	e0fffd17 	ldw	r3,-12(fp)
81135bd0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81135bd4:	e0bffd17 	ldw	r2,-12(fp)
81135bd8:	e0fffd17 	ldw	r3,-12(fp)
81135bdc:	10c00015 	stw	r3,0(r2)
81135be0:	e0bffb17 	ldw	r2,-20(fp)
81135be4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135be8:	e0bffe17 	ldw	r2,-8(fp)
81135bec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81135bf0:	0001883a 	nop
81135bf4:	e037883a 	mov	sp,fp
81135bf8:	df000017 	ldw	fp,0(sp)
81135bfc:	dec00104 	addi	sp,sp,4
81135c00:	f800283a 	ret

81135c04 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81135c04:	defffb04 	addi	sp,sp,-20
81135c08:	de00012e 	bgeu	sp,et,81135c10 <alt_tick+0xc>
81135c0c:	003b68fa 	trap	3
81135c10:	dfc00415 	stw	ra,16(sp)
81135c14:	df000315 	stw	fp,12(sp)
81135c18:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81135c1c:	d0a01417 	ldw	r2,-32688(gp)
81135c20:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81135c24:	d0a08817 	ldw	r2,-32224(gp)
81135c28:	10800044 	addi	r2,r2,1
81135c2c:	d0a08815 	stw	r2,-32224(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81135c30:	00002e06 	br	81135cec <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81135c34:	e0bffd17 	ldw	r2,-12(fp)
81135c38:	10800017 	ldw	r2,0(r2)
81135c3c:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81135c40:	e0bffd17 	ldw	r2,-12(fp)
81135c44:	10800403 	ldbu	r2,16(r2)
81135c48:	10803fcc 	andi	r2,r2,255
81135c4c:	10000426 	beq	r2,zero,81135c60 <alt_tick+0x5c>
81135c50:	d0a08817 	ldw	r2,-32224(gp)
81135c54:	1000021e 	bne	r2,zero,81135c60 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81135c58:	e0bffd17 	ldw	r2,-12(fp)
81135c5c:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81135c60:	e0bffd17 	ldw	r2,-12(fp)
81135c64:	10800217 	ldw	r2,8(r2)
81135c68:	d0e08817 	ldw	r3,-32224(gp)
81135c6c:	18801d36 	bltu	r3,r2,81135ce4 <alt_tick+0xe0>
81135c70:	e0bffd17 	ldw	r2,-12(fp)
81135c74:	10800403 	ldbu	r2,16(r2)
81135c78:	10803fcc 	andi	r2,r2,255
81135c7c:	1000191e 	bne	r2,zero,81135ce4 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81135c80:	e0bffd17 	ldw	r2,-12(fp)
81135c84:	10800317 	ldw	r2,12(r2)
81135c88:	e0fffd17 	ldw	r3,-12(fp)
81135c8c:	18c00517 	ldw	r3,20(r3)
81135c90:	1809883a 	mov	r4,r3
81135c94:	103ee83a 	callr	r2
81135c98:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81135c9c:	e0bfff17 	ldw	r2,-4(fp)
81135ca0:	1000031e 	bne	r2,zero,81135cb0 <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81135ca4:	e13ffd17 	ldw	r4,-12(fp)
81135ca8:	1135b600 	call	81135b60 <alt_alarm_stop>
81135cac:	00000d06 	br	81135ce4 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81135cb0:	e0bffd17 	ldw	r2,-12(fp)
81135cb4:	10c00217 	ldw	r3,8(r2)
81135cb8:	e0bfff17 	ldw	r2,-4(fp)
81135cbc:	1887883a 	add	r3,r3,r2
81135cc0:	e0bffd17 	ldw	r2,-12(fp)
81135cc4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81135cc8:	e0bffd17 	ldw	r2,-12(fp)
81135ccc:	10c00217 	ldw	r3,8(r2)
81135cd0:	d0a08817 	ldw	r2,-32224(gp)
81135cd4:	1880032e 	bgeu	r3,r2,81135ce4 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81135cd8:	e0bffd17 	ldw	r2,-12(fp)
81135cdc:	00c00044 	movi	r3,1
81135ce0:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81135ce4:	e0bffe17 	ldw	r2,-8(fp)
81135ce8:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81135cec:	e0fffd17 	ldw	r3,-12(fp)
81135cf0:	d0a01404 	addi	r2,gp,-32688
81135cf4:	18bfcf1e 	bne	r3,r2,81135c34 <__reset+0xfb115c34>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81135cf8:	1136f340 	call	81136f34 <OSTimeTick>
}
81135cfc:	0001883a 	nop
81135d00:	e037883a 	mov	sp,fp
81135d04:	dfc00117 	ldw	ra,4(sp)
81135d08:	df000017 	ldw	fp,0(sp)
81135d0c:	dec00204 	addi	sp,sp,8
81135d10:	f800283a 	ret

81135d14 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81135d14:	defffb04 	addi	sp,sp,-20
81135d18:	de00012e 	bgeu	sp,et,81135d20 <usleep+0xc>
81135d1c:	003b68fa 	trap	3
81135d20:	dfc00415 	stw	ra,16(sp)
81135d24:	df000315 	stw	fp,12(sp)
81135d28:	df000304 	addi	fp,sp,12
81135d2c:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81135d30:	d0a09003 	ldbu	r2,-32192(gp)
81135d34:	10803fcc 	andi	r2,r2,255
81135d38:	1000031e 	bne	r2,zero,81135d48 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81135d3c:	e13fff17 	ldw	r4,-4(fp)
81135d40:	11342a00 	call	811342a0 <alt_busy_sleep>
81135d44:	00003d06 	br	81135e3c <usleep+0x128>
81135d48:	d0a08717 	ldw	r2,-32228(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81135d4c:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81135d50:	e0ffff17 	ldw	r3,-4(fp)
81135d54:	0090c734 	movhi	r2,17180
81135d58:	10b7a0c4 	addi	r2,r2,-8573
81135d5c:	1888383a 	mulxuu	r4,r3,r2
81135d60:	1885383a 	mul	r2,r3,r2
81135d64:	1013883a 	mov	r9,r2
81135d68:	2015883a 	mov	r10,r4
81135d6c:	5006d4ba 	srli	r3,r10,18
81135d70:	e0bffe17 	ldw	r2,-8(fp)
81135d74:	1893383a 	mul	r9,r3,r2
81135d78:	e0ffff17 	ldw	r3,-4(fp)
81135d7c:	0090c734 	movhi	r2,17180
81135d80:	10b7a0c4 	addi	r2,r2,-8573
81135d84:	1888383a 	mulxuu	r4,r3,r2
81135d88:	1885383a 	mul	r2,r3,r2
81135d8c:	100f883a 	mov	r7,r2
81135d90:	2011883a 	mov	r8,r4
81135d94:	4004d4ba 	srli	r2,r8,18
81135d98:	010003f4 	movhi	r4,15
81135d9c:	21109004 	addi	r4,r4,16960
81135da0:	1105383a 	mul	r2,r2,r4
81135da4:	1885c83a 	sub	r2,r3,r2
81135da8:	e0fffe17 	ldw	r3,-8(fp)
81135dac:	10c7383a 	mul	r3,r2,r3
81135db0:	0090c734 	movhi	r2,17180
81135db4:	10b7a0c4 	addi	r2,r2,-8573
81135db8:	1888383a 	mulxuu	r4,r3,r2
81135dbc:	1885383a 	mul	r2,r3,r2
81135dc0:	100b883a 	mov	r5,r2
81135dc4:	200d883a 	mov	r6,r4
81135dc8:	3004d4ba 	srli	r2,r6,18
81135dcc:	4885883a 	add	r2,r9,r2
81135dd0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81135dd4:	00000706 	br	81135df4 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81135dd8:	013fffd4 	movui	r4,65535
81135ddc:	113e9a40 	call	8113e9a4 <OSTimeDly>
    ticks -= 0xffff;
81135de0:	e0fffd17 	ldw	r3,-12(fp)
81135de4:	00bffff4 	movhi	r2,65535
81135de8:	10800044 	addi	r2,r2,1
81135dec:	1885883a 	add	r2,r3,r2
81135df0:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81135df4:	e0bffd17 	ldw	r2,-12(fp)
81135df8:	00ffffd4 	movui	r3,65535
81135dfc:	18bff636 	bltu	r3,r2,81135dd8 <__reset+0xfb115dd8>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81135e00:	e0bffd17 	ldw	r2,-12(fp)
81135e04:	10bfffcc 	andi	r2,r2,65535
81135e08:	1009883a 	mov	r4,r2
81135e0c:	113e9a40 	call	8113e9a4 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81135e10:	008003f4 	movhi	r2,15
81135e14:	10909004 	addi	r2,r2,16960
81135e18:	e0fffe17 	ldw	r3,-8(fp)
81135e1c:	10c7203a 	divu	r3,r2,r3
81135e20:	e0bfff17 	ldw	r2,-4(fp)
81135e24:	10c9203a 	divu	r4,r2,r3
81135e28:	20c7383a 	mul	r3,r4,r3
81135e2c:	10c5c83a 	sub	r2,r2,r3
81135e30:	1009883a 	mov	r4,r2
81135e34:	11342a00 	call	811342a0 <alt_busy_sleep>

  return 0;  
81135e38:	0005883a 	mov	r2,zero
}
81135e3c:	e037883a 	mov	sp,fp
81135e40:	dfc00117 	ldw	ra,4(sp)
81135e44:	df000017 	ldw	fp,0(sp)
81135e48:	dec00204 	addi	sp,sp,8
81135e4c:	f800283a 	ret

81135e50 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81135e50:	defffe04 	addi	sp,sp,-8
81135e54:	de00012e 	bgeu	sp,et,81135e5c <alt_get_errno+0xc>
81135e58:	003b68fa 	trap	3
81135e5c:	dfc00115 	stw	ra,4(sp)
81135e60:	df000015 	stw	fp,0(sp)
81135e64:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81135e68:	d0a01017 	ldw	r2,-32704(gp)
81135e6c:	10000326 	beq	r2,zero,81135e7c <alt_get_errno+0x2c>
81135e70:	d0a01017 	ldw	r2,-32704(gp)
81135e74:	103ee83a 	callr	r2
81135e78:	00000106 	br	81135e80 <alt_get_errno+0x30>
81135e7c:	d0a07704 	addi	r2,gp,-32292
}
81135e80:	e037883a 	mov	sp,fp
81135e84:	dfc00117 	ldw	ra,4(sp)
81135e88:	df000017 	ldw	fp,0(sp)
81135e8c:	dec00204 	addi	sp,sp,8
81135e90:	f800283a 	ret

81135e94 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81135e94:	defff904 	addi	sp,sp,-28
81135e98:	de00012e 	bgeu	sp,et,81135ea0 <write+0xc>
81135e9c:	003b68fa 	trap	3
81135ea0:	dfc00615 	stw	ra,24(sp)
81135ea4:	df000515 	stw	fp,20(sp)
81135ea8:	df000504 	addi	fp,sp,20
81135eac:	e13ffd15 	stw	r4,-12(fp)
81135eb0:	e17ffe15 	stw	r5,-8(fp)
81135eb4:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81135eb8:	e0bffd17 	ldw	r2,-12(fp)
81135ebc:	10000616 	blt	r2,zero,81135ed8 <write+0x44>
81135ec0:	e0bffd17 	ldw	r2,-12(fp)
81135ec4:	10c00324 	muli	r3,r2,12
81135ec8:	00a04574 	movhi	r2,33045
81135ecc:	10bdae04 	addi	r2,r2,-2376
81135ed0:	1885883a 	add	r2,r3,r2
81135ed4:	00000106 	br	81135edc <write+0x48>
81135ed8:	0005883a 	mov	r2,zero
81135edc:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81135ee0:	e0bffb17 	ldw	r2,-20(fp)
81135ee4:	10002426 	beq	r2,zero,81135f78 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81135ee8:	e0bffb17 	ldw	r2,-20(fp)
81135eec:	10800217 	ldw	r2,8(r2)
81135ef0:	108000cc 	andi	r2,r2,3
81135ef4:	10001b26 	beq	r2,zero,81135f64 <write+0xd0>
81135ef8:	e0bffb17 	ldw	r2,-20(fp)
81135efc:	10800017 	ldw	r2,0(r2)
81135f00:	10800617 	ldw	r2,24(r2)
81135f04:	10001726 	beq	r2,zero,81135f64 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81135f08:	e17fff17 	ldw	r5,-4(fp)
81135f0c:	e13ffe17 	ldw	r4,-8(fp)
81135f10:	11352140 	call	81135214 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81135f14:	e0bffb17 	ldw	r2,-20(fp)
81135f18:	10800017 	ldw	r2,0(r2)
81135f1c:	10800617 	ldw	r2,24(r2)
81135f20:	e0ffff17 	ldw	r3,-4(fp)
81135f24:	180d883a 	mov	r6,r3
81135f28:	e17ffe17 	ldw	r5,-8(fp)
81135f2c:	e13ffb17 	ldw	r4,-20(fp)
81135f30:	103ee83a 	callr	r2
81135f34:	e0bffc15 	stw	r2,-16(fp)
81135f38:	e0bffc17 	ldw	r2,-16(fp)
81135f3c:	1000070e 	bge	r2,zero,81135f5c <write+0xc8>
      {
        ALT_ERRNO = -rval;
81135f40:	1135e500 	call	81135e50 <alt_get_errno>
81135f44:	1007883a 	mov	r3,r2
81135f48:	e0bffc17 	ldw	r2,-16(fp)
81135f4c:	0085c83a 	sub	r2,zero,r2
81135f50:	18800015 	stw	r2,0(r3)
        return -1;
81135f54:	00bfffc4 	movi	r2,-1
81135f58:	00000c06 	br	81135f8c <write+0xf8>
      }
      return rval;
81135f5c:	e0bffc17 	ldw	r2,-16(fp)
81135f60:	00000a06 	br	81135f8c <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81135f64:	1135e500 	call	81135e50 <alt_get_errno>
81135f68:	1007883a 	mov	r3,r2
81135f6c:	00800344 	movi	r2,13
81135f70:	18800015 	stw	r2,0(r3)
81135f74:	00000406 	br	81135f88 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81135f78:	1135e500 	call	81135e50 <alt_get_errno>
81135f7c:	1007883a 	mov	r3,r2
81135f80:	00801444 	movi	r2,81
81135f84:	18800015 	stw	r2,0(r3)
  }
  return -1;
81135f88:	00bfffc4 	movi	r2,-1
}
81135f8c:	e037883a 	mov	sp,fp
81135f90:	dfc00117 	ldw	ra,4(sp)
81135f94:	df000017 	ldw	fp,0(sp)
81135f98:	dec00204 	addi	sp,sp,8
81135f9c:	f800283a 	ret

81135fa0 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81135fa0:	deffde04 	addi	sp,sp,-136
81135fa4:	de00012e 	bgeu	sp,et,81135fac <__env_lock+0xc>
81135fa8:	003b68fa 	trap	3
81135fac:	dfc02115 	stw	ra,132(sp)
81135fb0:	df002015 	stw	fp,128(sp)
81135fb4:	df002004 	addi	fp,sp,128
81135fb8:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81135fbc:	e0bfe104 	addi	r2,fp,-124
81135fc0:	100b883a 	mov	r5,r2
81135fc4:	01003fc4 	movi	r4,255
81135fc8:	113e8000 	call	8113e800 <OSTaskQuery>
81135fcc:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81135fd0:	e0bffe83 	ldbu	r2,-6(fp)
81135fd4:	10803fcc 	andi	r2,r2,255
81135fd8:	10001e1e 	bne	r2,zero,81136054 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81135fdc:	e0bfed83 	ldbu	r2,-74(fp)
81135fe0:	10803fcc 	andi	r2,r2,255
81135fe4:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81135fe8:	d0a08a17 	ldw	r2,-32216(gp)
81135fec:	e0fffc04 	addi	r3,fp,-16
81135ff0:	180b883a 	mov	r5,r3
81135ff4:	1009883a 	mov	r4,r2
81135ff8:	113cfb80 	call	8113cfb8 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81135ffc:	e0bffe03 	ldbu	r2,-8(fp)
81136000:	10803fcc 	andi	r2,r2,255
81136004:	10000726 	beq	r2,zero,81136024 <__env_lock+0x84>
81136008:	d0a01617 	ldw	r2,-32680(gp)
8113600c:	e0ffe017 	ldw	r3,-128(fp)
81136010:	1880041e 	bne	r3,r2,81136024 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81136014:	d0a08917 	ldw	r2,-32220(gp)
81136018:	10800044 	addi	r2,r2,1
8113601c:	d0a08915 	stw	r2,-32220(gp)
81136020:	00000a06 	br	8113604c <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81136024:	d0a08a17 	ldw	r2,-32216(gp)
81136028:	e0fffe84 	addi	r3,fp,-6
8113602c:	180d883a 	mov	r6,r3
81136030:	000b883a 	mov	r5,zero
81136034:	1009883a 	mov	r4,r2
81136038:	113cb180 	call	8113cb18 <OSSemPend>
    locks  = 1;
8113603c:	00800044 	movi	r2,1
81136040:	d0a08915 	stw	r2,-32220(gp)
    lockid = id;
81136044:	e0bfe017 	ldw	r2,-128(fp)
81136048:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
8113604c:	0001883a 	nop
81136050:	00000106 	br	81136058 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81136054:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81136058:	e037883a 	mov	sp,fp
8113605c:	dfc00117 	ldw	ra,4(sp)
81136060:	df000017 	ldw	fp,0(sp)
81136064:	dec00204 	addi	sp,sp,8
81136068:	f800283a 	ret

8113606c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
8113606c:	defffd04 	addi	sp,sp,-12
81136070:	de00012e 	bgeu	sp,et,81136078 <__env_unlock+0xc>
81136074:	003b68fa 	trap	3
81136078:	dfc00215 	stw	ra,8(sp)
8113607c:	df000115 	stw	fp,4(sp)
81136080:	df000104 	addi	fp,sp,4
81136084:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81136088:	d0a08917 	ldw	r2,-32220(gp)
8113608c:	10000b26 	beq	r2,zero,811360bc <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
81136090:	d0a08917 	ldw	r2,-32220(gp)
81136094:	10bfffc4 	addi	r2,r2,-1
81136098:	d0a08915 	stw	r2,-32220(gp)
8113609c:	d0a08917 	ldw	r2,-32220(gp)
811360a0:	1000071e 	bne	r2,zero,811360c0 <__env_unlock+0x54>
  {
    lockid = -1;
811360a4:	00bfffc4 	movi	r2,-1
811360a8:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
811360ac:	d0a08a17 	ldw	r2,-32216(gp)
811360b0:	1009883a 	mov	r4,r2
811360b4:	113cea00 	call	8113cea0 <OSSemPost>
811360b8:	00000106 	br	811360c0 <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
811360bc:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811360c0:	e037883a 	mov	sp,fp
811360c4:	dfc00117 	ldw	ra,4(sp)
811360c8:	df000017 	ldw	fp,0(sp)
811360cc:	dec00204 	addi	sp,sp,8
811360d0:	f800283a 	ret

811360d4 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
811360d4:	deffda04 	addi	sp,sp,-152
811360d8:	de00012e 	bgeu	sp,et,811360e0 <__malloc_lock+0xc>
811360dc:	003b68fa 	trap	3
811360e0:	dfc02515 	stw	ra,148(sp)
811360e4:	df002415 	stw	fp,144(sp)
811360e8:	df002404 	addi	fp,sp,144
811360ec:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811360f0:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
811360f4:	d0a09003 	ldbu	r2,-32192(gp)
811360f8:	10803fcc 	andi	r2,r2,255
811360fc:	10800060 	cmpeqi	r2,r2,1
81136100:	10003626 	beq	r2,zero,811361dc <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81136104:	e0bfe104 	addi	r2,fp,-124
81136108:	100b883a 	mov	r5,r2
8113610c:	01003fc4 	movi	r4,255
81136110:	113e8000 	call	8113e800 <OSTaskQuery>
81136114:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81136118:	e0bffe83 	ldbu	r2,-6(fp)
8113611c:	10803fcc 	andi	r2,r2,255
81136120:	1000301e 	bne	r2,zero,811361e4 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81136124:	e0bfed83 	ldbu	r2,-74(fp)
81136128:	10803fcc 	andi	r2,r2,255
8113612c:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
81136130:	d0a08c17 	ldw	r2,-32208(gp)
81136134:	e0fffc04 	addi	r3,fp,-16
81136138:	180b883a 	mov	r5,r3
8113613c:	1009883a 	mov	r4,r2
81136140:	113cfb80 	call	8113cfb8 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136144:	0005303a 	rdctl	r2,status
81136148:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113614c:	e0ffe017 	ldw	r3,-128(fp)
81136150:	00bfff84 	movi	r2,-2
81136154:	1884703a 	and	r2,r3,r2
81136158:	1001703a 	wrctl	status,r2
  
  return context;
8113615c:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
81136160:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81136164:	e0bffc0b 	ldhu	r2,-16(fp)
81136168:	10bfffcc 	andi	r2,r2,65535
8113616c:	10000b1e 	bne	r2,zero,8113619c <__malloc_lock+0xc8>
81136170:	d0a01717 	ldw	r2,-32676(gp)
81136174:	e0ffdd17 	ldw	r3,-140(fp)
81136178:	1880081e 	bne	r3,r2,8113619c <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
8113617c:	d0a08b17 	ldw	r2,-32212(gp)
81136180:	10800044 	addi	r2,r2,1
81136184:	d0a08b15 	stw	r2,-32212(gp)
81136188:	e0bfdc17 	ldw	r2,-144(fp)
8113618c:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136190:	e0bfde17 	ldw	r2,-136(fp)
81136194:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81136198:	00000e06 	br	811361d4 <__malloc_lock+0x100>
8113619c:	e0bfdc17 	ldw	r2,-144(fp)
811361a0:	e0bfdf15 	stw	r2,-132(fp)
811361a4:	e0bfdf17 	ldw	r2,-132(fp)
811361a8:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
811361ac:	d0a08c17 	ldw	r2,-32208(gp)
811361b0:	e0fffe84 	addi	r3,fp,-6
811361b4:	180d883a 	mov	r6,r3
811361b8:	000b883a 	mov	r5,zero
811361bc:	1009883a 	mov	r4,r2
811361c0:	113cb180 	call	8113cb18 <OSSemPend>
    locks  = 1;
811361c4:	00800044 	movi	r2,1
811361c8:	d0a08b15 	stw	r2,-32212(gp)
    lockid = id;
811361cc:	e0bfdd17 	ldw	r2,-140(fp)
811361d0:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811361d4:	0001883a 	nop
811361d8:	00000306 	br	811361e8 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
811361dc:	0001883a 	nop
811361e0:	00000106 	br	811361e8 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811361e4:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811361e8:	e037883a 	mov	sp,fp
811361ec:	dfc00117 	ldw	ra,4(sp)
811361f0:	df000017 	ldw	fp,0(sp)
811361f4:	dec00204 	addi	sp,sp,8
811361f8:	f800283a 	ret

811361fc <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811361fc:	defff804 	addi	sp,sp,-32
81136200:	de00012e 	bgeu	sp,et,81136208 <__malloc_unlock+0xc>
81136204:	003b68fa 	trap	3
81136208:	dfc00715 	stw	ra,28(sp)
8113620c:	df000615 	stw	fp,24(sp)
81136210:	df000604 	addi	fp,sp,24
81136214:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136218:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
8113621c:	d0a09003 	ldbu	r2,-32192(gp)
81136220:	10803fcc 	andi	r2,r2,255
81136224:	10800060 	cmpeqi	r2,r2,1
81136228:	10002326 	beq	r2,zero,811362b8 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113622c:	0005303a 	rdctl	r2,status
81136230:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136234:	e0fffe17 	ldw	r3,-8(fp)
81136238:	00bfff84 	movi	r2,-2
8113623c:	1884703a 	and	r2,r3,r2
81136240:	1001703a 	wrctl	status,r2
  
  return context;
81136244:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81136248:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
8113624c:	d0a08b17 	ldw	r2,-32212(gp)
81136250:	1000051e 	bne	r2,zero,81136268 <__malloc_unlock+0x6c>
81136254:	e0bffa17 	ldw	r2,-24(fp)
81136258:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113625c:	e0bffb17 	ldw	r2,-20(fp)
81136260:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81136264:	00001506 	br	811362bc <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81136268:	d0a08b17 	ldw	r2,-32212(gp)
8113626c:	10bfffc4 	addi	r2,r2,-1
81136270:	d0a08b15 	stw	r2,-32212(gp)
81136274:	d0a08b17 	ldw	r2,-32212(gp)
81136278:	10000a1e 	bne	r2,zero,811362a4 <__malloc_unlock+0xa8>
  {
    lockid = -1;
8113627c:	00bfffc4 	movi	r2,-1
81136280:	d0a01715 	stw	r2,-32676(gp)
81136284:	e0bffa17 	ldw	r2,-24(fp)
81136288:	e0bffc15 	stw	r2,-16(fp)
8113628c:	e0bffc17 	ldw	r2,-16(fp)
81136290:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81136294:	d0a08c17 	ldw	r2,-32208(gp)
81136298:	1009883a 	mov	r4,r2
8113629c:	113cea00 	call	8113cea0 <OSSemPost>
811362a0:	00000606 	br	811362bc <__malloc_unlock+0xc0>
811362a4:	e0bffa17 	ldw	r2,-24(fp)
811362a8:	e0bffd15 	stw	r2,-12(fp)
811362ac:	e0bffd17 	ldw	r2,-12(fp)
811362b0:	1001703a 	wrctl	status,r2
811362b4:	00000106 	br	811362bc <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
811362b8:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
811362bc:	e037883a 	mov	sp,fp
811362c0:	dfc00117 	ldw	ra,4(sp)
811362c4:	df000017 	ldw	fp,0(sp)
811362c8:	dec00204 	addi	sp,sp,8
811362cc:	f800283a 	ret

811362d0 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811362d0:	defff704 	addi	sp,sp,-36
811362d4:	de00012e 	bgeu	sp,et,811362dc <OSEventNameGet+0xc>
811362d8:	003b68fa 	trap	3
811362dc:	dfc00815 	stw	ra,32(sp)
811362e0:	df000715 	stw	fp,28(sp)
811362e4:	df000704 	addi	fp,sp,28
811362e8:	e13ffd15 	stw	r4,-12(fp)
811362ec:	e17ffe15 	stw	r5,-8(fp)
811362f0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811362f4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811362f8:	e0bfff17 	ldw	r2,-4(fp)
811362fc:	1000021e 	bne	r2,zero,81136308 <OSEventNameGet+0x38>
        return (0);
81136300:	0005883a 	mov	r2,zero
81136304:	00003706 	br	811363e4 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81136308:	e0bffd17 	ldw	r2,-12(fp)
8113630c:	1000051e 	bne	r2,zero,81136324 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
81136310:	e0bfff17 	ldw	r2,-4(fp)
81136314:	00c00104 	movi	r3,4
81136318:	10c00005 	stb	r3,0(r2)
        return (0);
8113631c:	0005883a 	mov	r2,zero
81136320:	00003006 	br	811363e4 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136324:	e0bffe17 	ldw	r2,-8(fp)
81136328:	1000051e 	bne	r2,zero,81136340 <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113632c:	e0bfff17 	ldw	r2,-4(fp)
81136330:	00c00304 	movi	r3,12
81136334:	10c00005 	stb	r3,0(r2)
        return (0);
81136338:	0005883a 	mov	r2,zero
8113633c:	00002906 	br	811363e4 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136340:	d0a0a003 	ldbu	r2,-32128(gp)
81136344:	10803fcc 	andi	r2,r2,255
81136348:	10000526 	beq	r2,zero,81136360 <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
8113634c:	e0bfff17 	ldw	r2,-4(fp)
81136350:	00c00444 	movi	r3,17
81136354:	10c00005 	stb	r3,0(r2)
        return (0);
81136358:	0005883a 	mov	r2,zero
8113635c:	00002106 	br	811363e4 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
81136360:	e0bffd17 	ldw	r2,-12(fp)
81136364:	10800003 	ldbu	r2,0(r2)
81136368:	10803fcc 	andi	r2,r2,255
8113636c:	10bfffc4 	addi	r2,r2,-1
81136370:	10800128 	cmpgeui	r2,r2,4
81136374:	10000526 	beq	r2,zero,8113638c <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81136378:	e0bfff17 	ldw	r2,-4(fp)
8113637c:	00c00044 	movi	r3,1
81136380:	10c00005 	stb	r3,0(r2)
             return (0);
81136384:	0005883a 	mov	r2,zero
81136388:	00001606 	br	811363e4 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113638c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136390:	0005303a 	rdctl	r2,status
81136394:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136398:	e0fffb17 	ldw	r3,-20(fp)
8113639c:	00bfff84 	movi	r2,-2
811363a0:	1884703a 	and	r2,r3,r2
811363a4:	1001703a 	wrctl	status,r2
  
  return context;
811363a8:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
811363ac:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
811363b0:	e0bffd17 	ldw	r2,-12(fp)
811363b4:	10800444 	addi	r2,r2,17
811363b8:	100b883a 	mov	r5,r2
811363bc:	e13ffe17 	ldw	r4,-8(fp)
811363c0:	1137dbc0 	call	81137dbc <OS_StrCopy>
811363c4:	e0bffa05 	stb	r2,-24(fp)
811363c8:	e0bff917 	ldw	r2,-28(fp)
811363cc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811363d0:	e0bffc17 	ldw	r2,-16(fp)
811363d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811363d8:	e0bfff17 	ldw	r2,-4(fp)
811363dc:	10000005 	stb	zero,0(r2)
    return (len);
811363e0:	e0bffa03 	ldbu	r2,-24(fp)
}
811363e4:	e037883a 	mov	sp,fp
811363e8:	dfc00117 	ldw	ra,4(sp)
811363ec:	df000017 	ldw	fp,0(sp)
811363f0:	dec00204 	addi	sp,sp,8
811363f4:	f800283a 	ret

811363f8 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811363f8:	defff604 	addi	sp,sp,-40
811363fc:	de00012e 	bgeu	sp,et,81136404 <OSEventNameSet+0xc>
81136400:	003b68fa 	trap	3
81136404:	dfc00915 	stw	ra,36(sp)
81136408:	df000815 	stw	fp,32(sp)
8113640c:	df000804 	addi	fp,sp,32
81136410:	e13ffd15 	stw	r4,-12(fp)
81136414:	e17ffe15 	stw	r5,-8(fp)
81136418:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113641c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81136420:	e0bfff17 	ldw	r2,-4(fp)
81136424:	10004026 	beq	r2,zero,81136528 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81136428:	e0bffd17 	ldw	r2,-12(fp)
8113642c:	1000041e 	bne	r2,zero,81136440 <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
81136430:	e0bfff17 	ldw	r2,-4(fp)
81136434:	00c00104 	movi	r3,4
81136438:	10c00005 	stb	r3,0(r2)
        return;
8113643c:	00003b06 	br	8113652c <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136440:	e0bffe17 	ldw	r2,-8(fp)
81136444:	1000041e 	bne	r2,zero,81136458 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81136448:	e0bfff17 	ldw	r2,-4(fp)
8113644c:	00c00304 	movi	r3,12
81136450:	10c00005 	stb	r3,0(r2)
        return;
81136454:	00003506 	br	8113652c <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136458:	d0a0a003 	ldbu	r2,-32128(gp)
8113645c:	10803fcc 	andi	r2,r2,255
81136460:	10000426 	beq	r2,zero,81136474 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81136464:	e0bfff17 	ldw	r2,-4(fp)
81136468:	00c00484 	movi	r3,18
8113646c:	10c00005 	stb	r3,0(r2)
        return;
81136470:	00002e06 	br	8113652c <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81136474:	e0bffd17 	ldw	r2,-12(fp)
81136478:	10800003 	ldbu	r2,0(r2)
8113647c:	10803fcc 	andi	r2,r2,255
81136480:	10bfffc4 	addi	r2,r2,-1
81136484:	10800128 	cmpgeui	r2,r2,4
81136488:	10000426 	beq	r2,zero,8113649c <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
8113648c:	e0bfff17 	ldw	r2,-4(fp)
81136490:	00c00044 	movi	r3,1
81136494:	10c00005 	stb	r3,0(r2)
             return;
81136498:	00002406 	br	8113652c <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
8113649c:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811364a0:	0005303a 	rdctl	r2,status
811364a4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811364a8:	e0fffc17 	ldw	r3,-16(fp)
811364ac:	00bfff84 	movi	r2,-2
811364b0:	1884703a 	and	r2,r3,r2
811364b4:	1001703a 	wrctl	status,r2
  
  return context;
811364b8:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
811364bc:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
811364c0:	e13ffe17 	ldw	r4,-8(fp)
811364c4:	1137e380 	call	81137e38 <OS_StrLen>
811364c8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
811364cc:	e0bffa03 	ldbu	r2,-24(fp)
811364d0:	10800830 	cmpltui	r2,r2,32
811364d4:	1000081e 	bne	r2,zero,811364f8 <OSEventNameSet+0x100>
811364d8:	e0bff817 	ldw	r2,-32(fp)
811364dc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811364e0:	e0bff917 	ldw	r2,-28(fp)
811364e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
811364e8:	e0bfff17 	ldw	r2,-4(fp)
811364ec:	00c002c4 	movi	r3,11
811364f0:	10c00005 	stb	r3,0(r2)
        return;
811364f4:	00000d06 	br	8113652c <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811364f8:	e0bffd17 	ldw	r2,-12(fp)
811364fc:	10800444 	addi	r2,r2,17
81136500:	e17ffe17 	ldw	r5,-8(fp)
81136504:	1009883a 	mov	r4,r2
81136508:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113650c:	e0bff817 	ldw	r2,-32(fp)
81136510:	e0bffb15 	stw	r2,-20(fp)
81136514:	e0bffb17 	ldw	r2,-20(fp)
81136518:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113651c:	e0bfff17 	ldw	r2,-4(fp)
81136520:	10000005 	stb	zero,0(r2)
81136524:	00000106 	br	8113652c <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81136528:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113652c:	e037883a 	mov	sp,fp
81136530:	dfc00117 	ldw	ra,4(sp)
81136534:	df000017 	ldw	fp,0(sp)
81136538:	dec00204 	addi	sp,sp,8
8113653c:	f800283a 	ret

81136540 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
81136540:	deffed04 	addi	sp,sp,-76
81136544:	de00012e 	bgeu	sp,et,8113654c <OSEventPendMulti+0xc>
81136548:	003b68fa 	trap	3
8113654c:	dfc01215 	stw	ra,72(sp)
81136550:	df001115 	stw	fp,68(sp)
81136554:	df001104 	addi	fp,sp,68
81136558:	e13ffc15 	stw	r4,-16(fp)
8113655c:	e17ffd15 	stw	r5,-12(fp)
81136560:	e1bffe15 	stw	r6,-8(fp)
81136564:	3805883a 	mov	r2,r7
81136568:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
8113656c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
81136570:	e0800217 	ldw	r2,8(fp)
81136574:	1000021e 	bne	r2,zero,81136580 <OSEventPendMulti+0x40>
        return (0);
81136578:	0005883a 	mov	r2,zero
8113657c:	00015006 	br	81136ac0 <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
81136580:	e0bffc17 	ldw	r2,-16(fp)
81136584:	1000051e 	bne	r2,zero,8113659c <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81136588:	e0800217 	ldw	r2,8(fp)
8113658c:	00c00104 	movi	r3,4
81136590:	10c00005 	stb	r3,0(r2)
        return (0);
81136594:	0005883a 	mov	r2,zero
81136598:	00014906 	br	81136ac0 <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
8113659c:	e0bffd17 	ldw	r2,-12(fp)
811365a0:	1000051e 	bne	r2,zero,811365b8 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
811365a4:	e0800217 	ldw	r2,8(fp)
811365a8:	00c00104 	movi	r3,4
811365ac:	10c00005 	stb	r3,0(r2)
        return (0);
811365b0:	0005883a 	mov	r2,zero
811365b4:	00014206 	br	81136ac0 <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
811365b8:	e0bffe17 	ldw	r2,-8(fp)
811365bc:	1000051e 	bne	r2,zero,811365d4 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
811365c0:	e0800217 	ldw	r2,8(fp)
811365c4:	00c00104 	movi	r3,4
811365c8:	10c00005 	stb	r3,0(r2)
        return (0);
811365cc:	0005883a 	mov	r2,zero
811365d0:	00013b06 	br	81136ac0 <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811365d4:	e0bffd17 	ldw	r2,-12(fp)
811365d8:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
811365dc:	e0bffc17 	ldw	r2,-16(fp)
811365e0:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
811365e4:	e0bfef17 	ldw	r2,-68(fp)
811365e8:	10800017 	ldw	r2,0(r2)
811365ec:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811365f0:	00001506 	br	81136648 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811365f4:	e0bff017 	ldw	r2,-64(fp)
811365f8:	10800003 	ldbu	r2,0(r2)
811365fc:	10803fcc 	andi	r2,r2,255
81136600:	10c000a0 	cmpeqi	r3,r2,2
81136604:	1800071e 	bne	r3,zero,81136624 <OSEventPendMulti+0xe4>
81136608:	108000e0 	cmpeqi	r2,r2,3
8113660c:	1000071e 	bne	r2,zero,8113662c <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
81136610:	e0800217 	ldw	r2,8(fp)
81136614:	00c00044 	movi	r3,1
81136618:	10c00005 	stb	r3,0(r2)
                 return (0);
8113661c:	0005883a 	mov	r2,zero
81136620:	00012706 	br	81136ac0 <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81136624:	0001883a 	nop
81136628:	00000106 	br	81136630 <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
8113662c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
81136630:	e0bfef17 	ldw	r2,-68(fp)
81136634:	10800104 	addi	r2,r2,4
81136638:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
8113663c:	e0bfef17 	ldw	r2,-68(fp)
81136640:	10800017 	ldw	r2,0(r2)
81136644:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81136648:	e0bff017 	ldw	r2,-64(fp)
8113664c:	103fe91e 	bne	r2,zero,811365f4 <__reset+0xfb1165f4>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
81136650:	d0a0a003 	ldbu	r2,-32128(gp)
81136654:	10803fcc 	andi	r2,r2,255
81136658:	10000526 	beq	r2,zero,81136670 <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
8113665c:	e0800217 	ldw	r2,8(fp)
81136660:	00c00084 	movi	r3,2
81136664:	10c00005 	stb	r3,0(r2)
        return (0);
81136668:	0005883a 	mov	r2,zero
8113666c:	00011406 	br	81136ac0 <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
81136670:	d0a08e03 	ldbu	r2,-32200(gp)
81136674:	10803fcc 	andi	r2,r2,255
81136678:	10000526 	beq	r2,zero,81136690 <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
8113667c:	e0800217 	ldw	r2,8(fp)
81136680:	00c00344 	movi	r3,13
81136684:	10c00005 	stb	r3,0(r2)
        return (0);
81136688:	0005883a 	mov	r2,zero
8113668c:	00010c06 	br	81136ac0 <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136690:	0005303a 	rdctl	r2,status
81136694:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136698:	e0fffb17 	ldw	r3,-20(fp)
8113669c:	00bfff84 	movi	r2,-2
811366a0:	1884703a 	and	r2,r3,r2
811366a4:	1001703a 	wrctl	status,r2
  
  return context;
811366a8:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
811366ac:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
811366b0:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
811366b4:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
811366b8:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
811366bc:	e0bffc17 	ldw	r2,-16(fp)
811366c0:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
811366c4:	e0bfef17 	ldw	r2,-68(fp)
811366c8:	10800017 	ldw	r2,0(r2)
811366cc:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811366d0:	00006406 	br	81136864 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
811366d4:	e0bff017 	ldw	r2,-64(fp)
811366d8:	10800003 	ldbu	r2,0(r2)
811366dc:	10803fcc 	andi	r2,r2,255
811366e0:	10c000a0 	cmpeqi	r3,r2,2
811366e4:	18001f1e 	bne	r3,zero,81136764 <OSEventPendMulti+0x224>
811366e8:	108000e0 	cmpeqi	r2,r2,3
811366ec:	10004c26 	beq	r2,zero,81136820 <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811366f0:	e0bff017 	ldw	r2,-64(fp)
811366f4:	1080020b 	ldhu	r2,8(r2)
811366f8:	10bfffcc 	andi	r2,r2,65535
811366fc:	10001526 	beq	r2,zero,81136754 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
81136700:	e0bff017 	ldw	r2,-64(fp)
81136704:	1080020b 	ldhu	r2,8(r2)
81136708:	10bfffc4 	addi	r2,r2,-1
8113670c:	1007883a 	mov	r3,r2
81136710:	e0bff017 	ldw	r2,-64(fp)
81136714:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
81136718:	e0bffd17 	ldw	r2,-12(fp)
8113671c:	10c00104 	addi	r3,r2,4
81136720:	e0fffd15 	stw	r3,-12(fp)
81136724:	e0fff017 	ldw	r3,-64(fp)
81136728:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
8113672c:	00800044 	movi	r2,1
81136730:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81136734:	e0bffe17 	ldw	r2,-8(fp)
81136738:	10c00104 	addi	r3,r2,4
8113673c:	e0fffe15 	stw	r3,-8(fp)
81136740:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81136744:	e0bff18b 	ldhu	r2,-58(fp)
81136748:	10800044 	addi	r2,r2,1
8113674c:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
81136750:	00003e06 	br	8113684c <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81136754:	e0bff203 	ldbu	r2,-56(fp)
81136758:	10800054 	ori	r2,r2,1
8113675c:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
81136760:	00003a06 	br	8113684c <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81136764:	e0bff017 	ldw	r2,-64(fp)
81136768:	10800117 	ldw	r2,4(r2)
8113676c:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
81136770:	e0bff517 	ldw	r2,-44(fp)
81136774:	1080058b 	ldhu	r2,22(r2)
81136778:	10bfffcc 	andi	r2,r2,65535
8113677c:	10002426 	beq	r2,zero,81136810 <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
81136780:	e0bffe17 	ldw	r2,-8(fp)
81136784:	10c00104 	addi	r3,r2,4
81136788:	e0fffe15 	stw	r3,-8(fp)
8113678c:	e0fff517 	ldw	r3,-44(fp)
81136790:	18c00417 	ldw	r3,16(r3)
81136794:	19400104 	addi	r5,r3,4
81136798:	e13ff517 	ldw	r4,-44(fp)
8113679c:	21400415 	stw	r5,16(r4)
811367a0:	18c00017 	ldw	r3,0(r3)
811367a4:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
811367a8:	e0bff517 	ldw	r2,-44(fp)
811367ac:	10c00417 	ldw	r3,16(r2)
811367b0:	e0bff517 	ldw	r2,-44(fp)
811367b4:	10800217 	ldw	r2,8(r2)
811367b8:	1880041e 	bne	r3,r2,811367cc <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
811367bc:	e0bff517 	ldw	r2,-44(fp)
811367c0:	10c00117 	ldw	r3,4(r2)
811367c4:	e0bff517 	ldw	r2,-44(fp)
811367c8:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
811367cc:	e0bff517 	ldw	r2,-44(fp)
811367d0:	1080058b 	ldhu	r2,22(r2)
811367d4:	10bfffc4 	addi	r2,r2,-1
811367d8:	1007883a 	mov	r3,r2
811367dc:	e0bff517 	ldw	r2,-44(fp)
811367e0:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
811367e4:	e0bffd17 	ldw	r2,-12(fp)
811367e8:	10c00104 	addi	r3,r2,4
811367ec:	e0fffd15 	stw	r3,-12(fp)
811367f0:	e0fff017 	ldw	r3,-64(fp)
811367f4:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
811367f8:	00800044 	movi	r2,1
811367fc:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
81136800:	e0bff18b 	ldhu	r2,-58(fp)
81136804:	10800044 	addi	r2,r2,1
81136808:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
8113680c:	00000f06 	br	8113684c <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
81136810:	e0bff203 	ldbu	r2,-56(fp)
81136814:	10800114 	ori	r2,r2,4
81136818:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113681c:	00000b06 	br	8113684c <OSEventPendMulti+0x30c>
81136820:	e0bff317 	ldw	r2,-52(fp)
81136824:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136828:	e0bff417 	ldw	r2,-48(fp)
8113682c:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
81136830:	e0bffd17 	ldw	r2,-12(fp)
81136834:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81136838:	e0800217 	ldw	r2,8(fp)
8113683c:	00c00044 	movi	r3,1
81136840:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81136844:	e0bff18b 	ldhu	r2,-58(fp)
81136848:	00009d06 	br	81136ac0 <OSEventPendMulti+0x580>
        }
        pevents++;
8113684c:	e0bfef17 	ldw	r2,-68(fp)
81136850:	10800104 	addi	r2,r2,4
81136854:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81136858:	e0bfef17 	ldw	r2,-68(fp)
8113685c:	10800017 	ldw	r2,0(r2)
81136860:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81136864:	e0bff017 	ldw	r2,-64(fp)
81136868:	103f9a1e 	bne	r2,zero,811366d4 <__reset+0xfb1166d4>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
8113686c:	e0bff103 	ldbu	r2,-60(fp)
81136870:	10800058 	cmpnei	r2,r2,1
81136874:	10000a1e 	bne	r2,zero,811368a0 <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81136878:	e0bffd17 	ldw	r2,-12(fp)
8113687c:	10000015 	stw	zero,0(r2)
81136880:	e0bff317 	ldw	r2,-52(fp)
81136884:	e0bff615 	stw	r2,-40(fp)
81136888:	e0bff617 	ldw	r2,-40(fp)
8113688c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
81136890:	e0800217 	ldw	r2,8(fp)
81136894:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81136898:	e0bff18b 	ldhu	r2,-58(fp)
8113689c:	00008806 	br	81136ac0 <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
811368a0:	d0a0a117 	ldw	r2,-32124(gp)
811368a4:	d0e0a117 	ldw	r3,-32124(gp)
811368a8:	19000c03 	ldbu	r4,48(r3)
811368ac:	e0fff203 	ldbu	r3,-56(fp)
811368b0:	20c6b03a 	or	r3,r4,r3
811368b4:	1809883a 	mov	r4,r3
811368b8:	00ffe004 	movi	r3,-128
811368bc:	20c6b03a 	or	r3,r4,r3
811368c0:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811368c4:	d0a0a117 	ldw	r2,-32124(gp)
811368c8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
811368cc:	d0a0a117 	ldw	r2,-32124(gp)
811368d0:	e0ffff0b 	ldhu	r3,-4(fp)
811368d4:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
811368d8:	e13ffc17 	ldw	r4,-16(fp)
811368dc:	11374640 	call	81137464 <OS_EventTaskWaitMulti>
811368e0:	e0bff317 	ldw	r2,-52(fp)
811368e4:	e0bff915 	stw	r2,-28(fp)
811368e8:	e0bff917 	ldw	r2,-28(fp)
811368ec:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
811368f0:	1137c680 	call	81137c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811368f4:	0005303a 	rdctl	r2,status
811368f8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811368fc:	e0fff717 	ldw	r3,-36(fp)
81136900:	00bfff84 	movi	r2,-2
81136904:	1884703a 	and	r2,r3,r2
81136908:	1001703a 	wrctl	status,r2
  
  return context;
8113690c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
81136910:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
81136914:	d0a0a117 	ldw	r2,-32124(gp)
81136918:	10800c43 	ldbu	r2,49(r2)
8113691c:	10803fcc 	andi	r2,r2,255
81136920:	10000226 	beq	r2,zero,8113692c <OSEventPendMulti+0x3ec>
81136924:	108000a0 	cmpeqi	r2,r2,2
81136928:	10001826 	beq	r2,zero,8113698c <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
8113692c:	d0a0a117 	ldw	r2,-32124(gp)
81136930:	10800717 	ldw	r2,28(r2)
81136934:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81136938:	e0bff017 	ldw	r2,-64(fp)
8113693c:	10000b26 	beq	r2,zero,8113696c <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
81136940:	e0bffd17 	ldw	r2,-12(fp)
81136944:	10c00104 	addi	r3,r2,4
81136948:	e0fffd15 	stw	r3,-12(fp)
8113694c:	e0fff017 	ldw	r3,-64(fp)
81136950:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81136954:	e0bffd17 	ldw	r2,-12(fp)
81136958:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
8113695c:	e0bff18b 	ldhu	r2,-58(fp)
81136960:	10800044 	addi	r2,r2,1
81136964:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81136968:	00000d06 	br	811369a0 <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
8113696c:	d0a0a117 	ldw	r2,-32124(gp)
81136970:	00c00044 	movi	r3,1
81136974:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81136978:	d0a0a117 	ldw	r2,-32124(gp)
8113697c:	e17ffc17 	ldw	r5,-16(fp)
81136980:	1009883a 	mov	r4,r2
81136984:	113767c0 	call	8113767c <OS_EventTaskRemoveMulti>
             }
			 break;
81136988:	00000506 	br	811369a0 <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
8113698c:	d0a0a117 	ldw	r2,-32124(gp)
81136990:	e17ffc17 	ldw	r5,-16(fp)
81136994:	1009883a 	mov	r4,r2
81136998:	113767c0 	call	8113767c <OS_EventTaskRemoveMulti>
             break;
8113699c:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
811369a0:	d0a0a117 	ldw	r2,-32124(gp)
811369a4:	10800c43 	ldbu	r2,49(r2)
811369a8:	10803fcc 	andi	r2,r2,255
811369ac:	10000326 	beq	r2,zero,811369bc <OSEventPendMulti+0x47c>
811369b0:	108000a0 	cmpeqi	r2,r2,2
811369b4:	1000231e 	bne	r2,zero,81136a44 <OSEventPendMulti+0x504>
811369b8:	00002a06 	br	81136a64 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
811369bc:	e0bff017 	ldw	r2,-64(fp)
811369c0:	10800003 	ldbu	r2,0(r2)
811369c4:	10803fcc 	andi	r2,r2,255
811369c8:	0080100e 	bge	zero,r2,81136a0c <OSEventPendMulti+0x4cc>
811369cc:	10c000d0 	cmplti	r3,r2,3
811369d0:	1800071e 	bne	r3,zero,811369f0 <OSEventPendMulti+0x4b0>
811369d4:	108000e0 	cmpeqi	r2,r2,3
811369d8:	10000c26 	beq	r2,zero,81136a0c <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
811369dc:	e0bffe17 	ldw	r2,-8(fp)
811369e0:	10c00104 	addi	r3,r2,4
811369e4:	e0fffe15 	stw	r3,-8(fp)
811369e8:	10000015 	stw	zero,0(r2)
                      break;
811369ec:	00001206 	br	81136a38 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
811369f0:	e0bffe17 	ldw	r2,-8(fp)
811369f4:	10c00104 	addi	r3,r2,4
811369f8:	e0fffe15 	stw	r3,-8(fp)
811369fc:	d0e0a117 	ldw	r3,-32124(gp)
81136a00:	18c00917 	ldw	r3,36(r3)
81136a04:	10c00015 	stw	r3,0(r2)
                      break;
81136a08:	00000b06 	br	81136a38 <OSEventPendMulti+0x4f8>
81136a0c:	e0bff317 	ldw	r2,-52(fp)
81136a10:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136a14:	e0bff817 	ldw	r2,-32(fp)
81136a18:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
81136a1c:	e0bffd17 	ldw	r2,-12(fp)
81136a20:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81136a24:	e0800217 	ldw	r2,8(fp)
81136a28:	00c00044 	movi	r3,1
81136a2c:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81136a30:	e0bff18b 	ldhu	r2,-58(fp)
81136a34:	00002206 	br	81136ac0 <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81136a38:	e0800217 	ldw	r2,8(fp)
81136a3c:	10000005 	stb	zero,0(r2)
             break;
81136a40:	00001006 	br	81136a84 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81136a44:	e0bffe17 	ldw	r2,-8(fp)
81136a48:	10c00104 	addi	r3,r2,4
81136a4c:	e0fffe15 	stw	r3,-8(fp)
81136a50:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81136a54:	e0800217 	ldw	r2,8(fp)
81136a58:	00c00384 	movi	r3,14
81136a5c:	10c00005 	stb	r3,0(r2)
             break;
81136a60:	00000806 	br	81136a84 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81136a64:	e0bffe17 	ldw	r2,-8(fp)
81136a68:	10c00104 	addi	r3,r2,4
81136a6c:	e0fffe15 	stw	r3,-8(fp)
81136a70:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81136a74:	e0800217 	ldw	r2,8(fp)
81136a78:	00c00284 	movi	r3,10
81136a7c:	10c00005 	stb	r3,0(r2)
             break;
81136a80:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81136a84:	d0a0a117 	ldw	r2,-32124(gp)
81136a88:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81136a8c:	d0a0a117 	ldw	r2,-32124(gp)
81136a90:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81136a94:	d0a0a117 	ldw	r2,-32124(gp)
81136a98:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81136a9c:	d0a0a117 	ldw	r2,-32124(gp)
81136aa0:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81136aa4:	d0a0a117 	ldw	r2,-32124(gp)
81136aa8:	10000915 	stw	zero,36(r2)
81136aac:	e0bff317 	ldw	r2,-52(fp)
81136ab0:	e0bffa15 	stw	r2,-24(fp)
81136ab4:	e0bffa17 	ldw	r2,-24(fp)
81136ab8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81136abc:	e0bff18b 	ldhu	r2,-58(fp)
}
81136ac0:	e037883a 	mov	sp,fp
81136ac4:	dfc00117 	ldw	ra,4(sp)
81136ac8:	df000017 	ldw	fp,0(sp)
81136acc:	dec00204 	addi	sp,sp,8
81136ad0:	f800283a 	ret

81136ad4 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81136ad4:	defffe04 	addi	sp,sp,-8
81136ad8:	de00012e 	bgeu	sp,et,81136ae0 <OSInit+0xc>
81136adc:	003b68fa 	trap	3
81136ae0:	dfc00115 	stw	ra,4(sp)
81136ae4:	df000015 	stw	fp,0(sp)
81136ae8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81136aec:	1148fd80 	call	81148fd8 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81136af0:	11378dc0 	call	811378dc <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81136af4:	113792c0 	call	8113792c <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81136af8:	1137ab00 	call	81137ab0 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81136afc:	11377f40 	call	811377f4 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81136b00:	1139a700 	call	81139a70 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81136b04:	113a3b80 	call	8113a3b8 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81136b08:	113c6880 	call	8113c688 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81136b0c:	11379a00 	call	811379a0 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81136b10:	1137a280 	call	81137a28 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81136b14:	113fa2c0 	call	8113fa2c <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81136b18:	11490040 	call	81149004 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81136b1c:	113838c0 	call	8113838c <OSDebugInit>
#endif
}
81136b20:	0001883a 	nop
81136b24:	e037883a 	mov	sp,fp
81136b28:	dfc00117 	ldw	ra,4(sp)
81136b2c:	df000017 	ldw	fp,0(sp)
81136b30:	dec00204 	addi	sp,sp,8
81136b34:	f800283a 	ret

81136b38 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81136b38:	deffff04 	addi	sp,sp,-4
81136b3c:	de00012e 	bgeu	sp,et,81136b44 <OSIntEnter+0xc>
81136b40:	003b68fa 	trap	3
81136b44:	df000015 	stw	fp,0(sp)
81136b48:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81136b4c:	d0a09003 	ldbu	r2,-32192(gp)
81136b50:	10803fcc 	andi	r2,r2,255
81136b54:	10800058 	cmpnei	r2,r2,1
81136b58:	1000071e 	bne	r2,zero,81136b78 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81136b5c:	d0a0a003 	ldbu	r2,-32128(gp)
81136b60:	10803fcc 	andi	r2,r2,255
81136b64:	10803fe0 	cmpeqi	r2,r2,255
81136b68:	1000031e 	bne	r2,zero,81136b78 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81136b6c:	d0a0a003 	ldbu	r2,-32128(gp)
81136b70:	10800044 	addi	r2,r2,1
81136b74:	d0a0a005 	stb	r2,-32128(gp)
        }
    }
}
81136b78:	0001883a 	nop
81136b7c:	e037883a 	mov	sp,fp
81136b80:	df000017 	ldw	fp,0(sp)
81136b84:	dec00104 	addi	sp,sp,4
81136b88:	f800283a 	ret

81136b8c <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81136b8c:	defffb04 	addi	sp,sp,-20
81136b90:	de00012e 	bgeu	sp,et,81136b98 <OSIntExit+0xc>
81136b94:	003b68fa 	trap	3
81136b98:	dfc00415 	stw	ra,16(sp)
81136b9c:	df000315 	stw	fp,12(sp)
81136ba0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136ba4:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81136ba8:	d0a09003 	ldbu	r2,-32192(gp)
81136bac:	10803fcc 	andi	r2,r2,255
81136bb0:	10800058 	cmpnei	r2,r2,1
81136bb4:	10002f1e 	bne	r2,zero,81136c74 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136bb8:	0005303a 	rdctl	r2,status
81136bbc:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136bc0:	e0ffff17 	ldw	r3,-4(fp)
81136bc4:	00bfff84 	movi	r2,-2
81136bc8:	1884703a 	and	r2,r3,r2
81136bcc:	1001703a 	wrctl	status,r2
  
  return context;
81136bd0:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81136bd4:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81136bd8:	d0a0a003 	ldbu	r2,-32128(gp)
81136bdc:	10803fcc 	andi	r2,r2,255
81136be0:	10000326 	beq	r2,zero,81136bf0 <OSIntExit+0x64>
            OSIntNesting--;
81136be4:	d0a0a003 	ldbu	r2,-32128(gp)
81136be8:	10bfffc4 	addi	r2,r2,-1
81136bec:	d0a0a005 	stb	r2,-32128(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81136bf0:	d0a0a003 	ldbu	r2,-32128(gp)
81136bf4:	10803fcc 	andi	r2,r2,255
81136bf8:	10001a1e 	bne	r2,zero,81136c64 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81136bfc:	d0a08e03 	ldbu	r2,-32200(gp)
81136c00:	10803fcc 	andi	r2,r2,255
81136c04:	1000171e 	bne	r2,zero,81136c64 <OSIntExit+0xd8>
                OS_SchedNew();
81136c08:	1137d400 	call	81137d40 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81136c0c:	d0e09283 	ldbu	r3,-32182(gp)
81136c10:	d0a092c3 	ldbu	r2,-32181(gp)
81136c14:	18c03fcc 	andi	r3,r3,255
81136c18:	10803fcc 	andi	r2,r2,255
81136c1c:	18801126 	beq	r3,r2,81136c64 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81136c20:	d0a09283 	ldbu	r2,-32182(gp)
81136c24:	10c03fcc 	andi	r3,r2,255
81136c28:	00a045f4 	movhi	r2,33047
81136c2c:	10a9d004 	addi	r2,r2,-22720
81136c30:	18c7883a 	add	r3,r3,r3
81136c34:	18c7883a 	add	r3,r3,r3
81136c38:	10c5883a 	add	r2,r2,r3
81136c3c:	10800017 	ldw	r2,0(r2)
81136c40:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81136c44:	d0a09b17 	ldw	r2,-32148(gp)
81136c48:	10c00e17 	ldw	r3,56(r2)
81136c4c:	18c00044 	addi	r3,r3,1
81136c50:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81136c54:	d0a09517 	ldw	r2,-32172(gp)
81136c58:	10800044 	addi	r2,r2,1
81136c5c:	d0a09515 	stw	r2,-32172(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81136c60:	1148c980 	call	81148c98 <OSCtxSw>
81136c64:	e0bffd17 	ldw	r2,-12(fp)
81136c68:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136c6c:	e0bffe17 	ldw	r2,-8(fp)
81136c70:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81136c74:	0001883a 	nop
81136c78:	e037883a 	mov	sp,fp
81136c7c:	dfc00117 	ldw	ra,4(sp)
81136c80:	df000017 	ldw	fp,0(sp)
81136c84:	dec00204 	addi	sp,sp,8
81136c88:	f800283a 	ret

81136c8c <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81136c8c:	defffc04 	addi	sp,sp,-16
81136c90:	de00012e 	bgeu	sp,et,81136c98 <OSSchedLock+0xc>
81136c94:	003b68fa 	trap	3
81136c98:	df000315 	stw	fp,12(sp)
81136c9c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136ca0:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81136ca4:	d0a09003 	ldbu	r2,-32192(gp)
81136ca8:	10803fcc 	andi	r2,r2,255
81136cac:	10800058 	cmpnei	r2,r2,1
81136cb0:	1000161e 	bne	r2,zero,81136d0c <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136cb4:	0005303a 	rdctl	r2,status
81136cb8:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136cbc:	e0ffff17 	ldw	r3,-4(fp)
81136cc0:	00bfff84 	movi	r2,-2
81136cc4:	1884703a 	and	r2,r3,r2
81136cc8:	1001703a 	wrctl	status,r2
  
  return context;
81136ccc:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81136cd0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81136cd4:	d0a0a003 	ldbu	r2,-32128(gp)
81136cd8:	10803fcc 	andi	r2,r2,255
81136cdc:	1000071e 	bne	r2,zero,81136cfc <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81136ce0:	d0a08e03 	ldbu	r2,-32200(gp)
81136ce4:	10803fcc 	andi	r2,r2,255
81136ce8:	10803fe0 	cmpeqi	r2,r2,255
81136cec:	1000031e 	bne	r2,zero,81136cfc <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81136cf0:	d0a08e03 	ldbu	r2,-32200(gp)
81136cf4:	10800044 	addi	r2,r2,1
81136cf8:	d0a08e05 	stb	r2,-32200(gp)
81136cfc:	e0bffd17 	ldw	r2,-12(fp)
81136d00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136d04:	e0bffe17 	ldw	r2,-8(fp)
81136d08:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81136d0c:	0001883a 	nop
81136d10:	e037883a 	mov	sp,fp
81136d14:	df000017 	ldw	fp,0(sp)
81136d18:	dec00104 	addi	sp,sp,4
81136d1c:	f800283a 	ret

81136d20 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81136d20:	defff804 	addi	sp,sp,-32
81136d24:	de00012e 	bgeu	sp,et,81136d2c <OSSchedUnlock+0xc>
81136d28:	003b68fa 	trap	3
81136d2c:	dfc00715 	stw	ra,28(sp)
81136d30:	df000615 	stw	fp,24(sp)
81136d34:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81136d38:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81136d3c:	d0a09003 	ldbu	r2,-32192(gp)
81136d40:	10803fcc 	andi	r2,r2,255
81136d44:	10800058 	cmpnei	r2,r2,1
81136d48:	1000281e 	bne	r2,zero,81136dec <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136d4c:	0005303a 	rdctl	r2,status
81136d50:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136d54:	e0ffff17 	ldw	r3,-4(fp)
81136d58:	00bfff84 	movi	r2,-2
81136d5c:	1884703a 	and	r2,r3,r2
81136d60:	1001703a 	wrctl	status,r2
  
  return context;
81136d64:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81136d68:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81136d6c:	d0a08e03 	ldbu	r2,-32200(gp)
81136d70:	10803fcc 	andi	r2,r2,255
81136d74:	10001926 	beq	r2,zero,81136ddc <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81136d78:	d0a08e03 	ldbu	r2,-32200(gp)
81136d7c:	10bfffc4 	addi	r2,r2,-1
81136d80:	d0a08e05 	stb	r2,-32200(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81136d84:	d0a08e03 	ldbu	r2,-32200(gp)
81136d88:	10803fcc 	andi	r2,r2,255
81136d8c:	10000e1e 	bne	r2,zero,81136dc8 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81136d90:	d0a0a003 	ldbu	r2,-32128(gp)
81136d94:	10803fcc 	andi	r2,r2,255
81136d98:	1000061e 	bne	r2,zero,81136db4 <OSSchedUnlock+0x94>
81136d9c:	e0bffa17 	ldw	r2,-24(fp)
81136da0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136da4:	e0bffb17 	ldw	r2,-20(fp)
81136da8:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81136dac:	1137c680 	call	81137c68 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81136db0:	00000e06 	br	81136dec <OSSchedUnlock+0xcc>
81136db4:	e0bffa17 	ldw	r2,-24(fp)
81136db8:	e0bffc15 	stw	r2,-16(fp)
81136dbc:	e0bffc17 	ldw	r2,-16(fp)
81136dc0:	1001703a 	wrctl	status,r2
81136dc4:	00000906 	br	81136dec <OSSchedUnlock+0xcc>
81136dc8:	e0bffa17 	ldw	r2,-24(fp)
81136dcc:	e0bffd15 	stw	r2,-12(fp)
81136dd0:	e0bffd17 	ldw	r2,-12(fp)
81136dd4:	1001703a 	wrctl	status,r2
81136dd8:	00000406 	br	81136dec <OSSchedUnlock+0xcc>
81136ddc:	e0bffa17 	ldw	r2,-24(fp)
81136de0:	e0bffe15 	stw	r2,-8(fp)
81136de4:	e0bffe17 	ldw	r2,-8(fp)
81136de8:	1001703a 	wrctl	status,r2
81136dec:	0001883a 	nop
81136df0:	e037883a 	mov	sp,fp
81136df4:	dfc00117 	ldw	ra,4(sp)
81136df8:	df000017 	ldw	fp,0(sp)
81136dfc:	dec00204 	addi	sp,sp,8
81136e00:	f800283a 	ret

81136e04 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81136e04:	defffe04 	addi	sp,sp,-8
81136e08:	de00012e 	bgeu	sp,et,81136e10 <OSStart+0xc>
81136e0c:	003b68fa 	trap	3
81136e10:	dfc00115 	stw	ra,4(sp)
81136e14:	df000015 	stw	fp,0(sp)
81136e18:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81136e1c:	d0a09003 	ldbu	r2,-32192(gp)
81136e20:	10803fcc 	andi	r2,r2,255
81136e24:	10000f1e 	bne	r2,zero,81136e64 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81136e28:	1137d400 	call	81137d40 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81136e2c:	d0a09283 	ldbu	r2,-32182(gp)
81136e30:	d0a092c5 	stb	r2,-32181(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81136e34:	d0a09283 	ldbu	r2,-32182(gp)
81136e38:	10c03fcc 	andi	r3,r2,255
81136e3c:	00a045f4 	movhi	r2,33047
81136e40:	10a9d004 	addi	r2,r2,-22720
81136e44:	18c7883a 	add	r3,r3,r3
81136e48:	18c7883a 	add	r3,r3,r3
81136e4c:	10c5883a 	add	r2,r2,r3
81136e50:	10800017 	ldw	r2,0(r2)
81136e54:	d0a09b15 	stw	r2,-32148(gp)
        OSTCBCur      = OSTCBHighRdy;
81136e58:	d0a09b17 	ldw	r2,-32148(gp)
81136e5c:	d0a0a115 	stw	r2,-32124(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81136e60:	1148d340 	call	81148d34 <OSStartHighRdy>
    }
}
81136e64:	0001883a 	nop
81136e68:	e037883a 	mov	sp,fp
81136e6c:	dfc00117 	ldw	ra,4(sp)
81136e70:	df000017 	ldw	fp,0(sp)
81136e74:	dec00204 	addi	sp,sp,8
81136e78:	f800283a 	ret

81136e7c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81136e7c:	defff904 	addi	sp,sp,-28
81136e80:	de00012e 	bgeu	sp,et,81136e88 <OSStatInit+0xc>
81136e84:	003b68fa 	trap	3
81136e88:	dfc00615 	stw	ra,24(sp)
81136e8c:	df000515 	stw	fp,20(sp)
81136e90:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136e94:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81136e98:	01000084 	movi	r4,2
81136e9c:	113e9a40 	call	8113e9a4 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136ea0:	0005303a 	rdctl	r2,status
81136ea4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136ea8:	e0fffc17 	ldw	r3,-16(fp)
81136eac:	00bfff84 	movi	r2,-2
81136eb0:	1884703a 	and	r2,r3,r2
81136eb4:	1001703a 	wrctl	status,r2
  
  return context;
81136eb8:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81136ebc:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81136ec0:	d0209115 	stw	zero,-32188(gp)
81136ec4:	e0bffb17 	ldw	r2,-20(fp)
81136ec8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136ecc:	e0bffd17 	ldw	r2,-12(fp)
81136ed0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81136ed4:	01001904 	movi	r4,100
81136ed8:	113e9a40 	call	8113e9a4 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136edc:	0005303a 	rdctl	r2,status
81136ee0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136ee4:	e0fffe17 	ldw	r3,-8(fp)
81136ee8:	00bfff84 	movi	r2,-2
81136eec:	1884703a 	and	r2,r3,r2
81136ef0:	1001703a 	wrctl	status,r2
  
  return context;
81136ef4:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81136ef8:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81136efc:	d0a09117 	ldw	r2,-32188(gp)
81136f00:	d0a09715 	stw	r2,-32164(gp)
    OSStatRdy    = OS_TRUE;
81136f04:	00800044 	movi	r2,1
81136f08:	d0a0a605 	stb	r2,-32104(gp)
81136f0c:	e0bffb17 	ldw	r2,-20(fp)
81136f10:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136f14:	e0bfff17 	ldw	r2,-4(fp)
81136f18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81136f1c:	0001883a 	nop
81136f20:	e037883a 	mov	sp,fp
81136f24:	dfc00117 	ldw	ra,4(sp)
81136f28:	df000017 	ldw	fp,0(sp)
81136f2c:	dec00204 	addi	sp,sp,8
81136f30:	f800283a 	ret

81136f34 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81136f34:	defff704 	addi	sp,sp,-36
81136f38:	de00012e 	bgeu	sp,et,81136f40 <OSTimeTick+0xc>
81136f3c:	003b68fa 	trap	3
81136f40:	dfc00815 	stw	ra,32(sp)
81136f44:	df000715 	stw	fp,28(sp)
81136f48:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81136f4c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81136f50:	1148f840 	call	81148f84 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136f54:	0005303a 	rdctl	r2,status
81136f58:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136f5c:	e0fffd17 	ldw	r3,-12(fp)
81136f60:	00bfff84 	movi	r2,-2
81136f64:	1884703a 	and	r2,r3,r2
81136f68:	1001703a 	wrctl	status,r2
  
  return context;
81136f6c:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81136f70:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81136f74:	d0a0a317 	ldw	r2,-32116(gp)
81136f78:	10800044 	addi	r2,r2,1
81136f7c:	d0a0a315 	stw	r2,-32116(gp)
81136f80:	e0bffb17 	ldw	r2,-20(fp)
81136f84:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136f88:	e0bfff17 	ldw	r2,-4(fp)
81136f8c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81136f90:	d0a09003 	ldbu	r2,-32192(gp)
81136f94:	10803fcc 	andi	r2,r2,255
81136f98:	10800058 	cmpnei	r2,r2,1
81136f9c:	10006a1e 	bne	r2,zero,81137148 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81136fa0:	d0a09403 	ldbu	r2,-32176(gp)
81136fa4:	10803fcc 	andi	r2,r2,255
81136fa8:	10c00060 	cmpeqi	r3,r2,1
81136fac:	1800061e 	bne	r3,zero,81136fc8 <OSTimeTick+0x94>
81136fb0:	10c000a0 	cmpeqi	r3,r2,2
81136fb4:	1800061e 	bne	r3,zero,81136fd0 <OSTimeTick+0x9c>
81136fb8:	10000a1e 	bne	r2,zero,81136fe4 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81136fbc:	00800044 	movi	r2,1
81136fc0:	e0bffa05 	stb	r2,-24(fp)
                 break;
81136fc4:	00000b06 	br	81136ff4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81136fc8:	e03ffa05 	stb	zero,-24(fp)
                 break;
81136fcc:	00000906 	br	81136ff4 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81136fd0:	00800044 	movi	r2,1
81136fd4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81136fd8:	00800044 	movi	r2,1
81136fdc:	d0a09405 	stb	r2,-32176(gp)
                 break;
81136fe0:	00000406 	br	81136ff4 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81136fe4:	00800044 	movi	r2,1
81136fe8:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81136fec:	d0209405 	stb	zero,-32176(gp)
                 break;
81136ff0:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81136ff4:	e0bffa03 	ldbu	r2,-24(fp)
81136ff8:	10005226 	beq	r2,zero,81137144 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81136ffc:	d0a09317 	ldw	r2,-32180(gp)
81137000:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81137004:	00004906 	br	8113712c <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137008:	0005303a 	rdctl	r2,status
8113700c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137010:	e0fffc17 	ldw	r3,-16(fp)
81137014:	00bfff84 	movi	r2,-2
81137018:	1884703a 	and	r2,r3,r2
8113701c:	1001703a 	wrctl	status,r2
  
  return context;
81137020:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81137024:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81137028:	e0bff917 	ldw	r2,-28(fp)
8113702c:	10800b8b 	ldhu	r2,46(r2)
81137030:	10bfffcc 	andi	r2,r2,65535
81137034:	10003626 	beq	r2,zero,81137110 <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81137038:	e0bff917 	ldw	r2,-28(fp)
8113703c:	10800b8b 	ldhu	r2,46(r2)
81137040:	10bfffc4 	addi	r2,r2,-1
81137044:	1007883a 	mov	r3,r2
81137048:	e0bff917 	ldw	r2,-28(fp)
8113704c:	10c00b8d 	sth	r3,46(r2)
81137050:	e0bff917 	ldw	r2,-28(fp)
81137054:	10800b8b 	ldhu	r2,46(r2)
81137058:	10bfffcc 	andi	r2,r2,65535
8113705c:	10002c1e 	bne	r2,zero,81137110 <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
81137060:	e0bff917 	ldw	r2,-28(fp)
81137064:	10800c03 	ldbu	r2,48(r2)
81137068:	10803fcc 	andi	r2,r2,255
8113706c:	10800dcc 	andi	r2,r2,55
81137070:	10000b26 	beq	r2,zero,811370a0 <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81137074:	e0bff917 	ldw	r2,-28(fp)
81137078:	10c00c03 	ldbu	r3,48(r2)
8113707c:	00bff204 	movi	r2,-56
81137080:	1884703a 	and	r2,r3,r2
81137084:	1007883a 	mov	r3,r2
81137088:	e0bff917 	ldw	r2,-28(fp)
8113708c:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
81137090:	e0bff917 	ldw	r2,-28(fp)
81137094:	00c00044 	movi	r3,1
81137098:	10c00c45 	stb	r3,49(r2)
8113709c:	00000206 	br	811370a8 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
811370a0:	e0bff917 	ldw	r2,-28(fp)
811370a4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
811370a8:	e0bff917 	ldw	r2,-28(fp)
811370ac:	10800c03 	ldbu	r2,48(r2)
811370b0:	10803fcc 	andi	r2,r2,255
811370b4:	1080020c 	andi	r2,r2,8
811370b8:	1000151e 	bne	r2,zero,81137110 <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
811370bc:	e0bff917 	ldw	r2,-28(fp)
811370c0:	10c00d83 	ldbu	r3,54(r2)
811370c4:	d0a09d03 	ldbu	r2,-32140(gp)
811370c8:	1884b03a 	or	r2,r3,r2
811370cc:	d0a09d05 	stb	r2,-32140(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811370d0:	e0bff917 	ldw	r2,-28(fp)
811370d4:	10800d03 	ldbu	r2,52(r2)
811370d8:	10c03fcc 	andi	r3,r2,255
811370dc:	e0bff917 	ldw	r2,-28(fp)
811370e0:	10800d03 	ldbu	r2,52(r2)
811370e4:	11003fcc 	andi	r4,r2,255
811370e8:	d0a09d44 	addi	r2,gp,-32139
811370ec:	2085883a 	add	r2,r4,r2
811370f0:	11000003 	ldbu	r4,0(r2)
811370f4:	e0bff917 	ldw	r2,-28(fp)
811370f8:	10800d43 	ldbu	r2,53(r2)
811370fc:	2084b03a 	or	r2,r4,r2
81137100:	1009883a 	mov	r4,r2
81137104:	d0a09d44 	addi	r2,gp,-32139
81137108:	1885883a 	add	r2,r3,r2
8113710c:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
81137110:	e0bff917 	ldw	r2,-28(fp)
81137114:	10800517 	ldw	r2,20(r2)
81137118:	e0bff915 	stw	r2,-28(fp)
8113711c:	e0bffb17 	ldw	r2,-20(fp)
81137120:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137124:	e0bffe17 	ldw	r2,-8(fp)
81137128:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
8113712c:	e0bff917 	ldw	r2,-28(fp)
81137130:	10800c83 	ldbu	r2,50(r2)
81137134:	10803fcc 	andi	r2,r2,255
81137138:	10800a98 	cmpnei	r2,r2,42
8113713c:	103fb21e 	bne	r2,zero,81137008 <__reset+0xfb117008>
81137140:	00000106 	br	81137148 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81137144:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81137148:	e037883a 	mov	sp,fp
8113714c:	dfc00117 	ldw	ra,4(sp)
81137150:	df000017 	ldw	fp,0(sp)
81137154:	dec00204 	addi	sp,sp,8
81137158:	f800283a 	ret

8113715c <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
8113715c:	deffff04 	addi	sp,sp,-4
81137160:	de00012e 	bgeu	sp,et,81137168 <OSVersion+0xc>
81137164:	003b68fa 	trap	3
81137168:	df000015 	stw	fp,0(sp)
8113716c:	d839883a 	mov	fp,sp
    return (OS_VERSION);
81137170:	00804784 	movi	r2,286
}
81137174:	e037883a 	mov	sp,fp
81137178:	df000017 	ldw	fp,0(sp)
8113717c:	dec00104 	addi	sp,sp,4
81137180:	f800283a 	ret

81137184 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81137184:	deffff04 	addi	sp,sp,-4
81137188:	de00012e 	bgeu	sp,et,81137190 <OS_Dummy+0xc>
8113718c:	003b68fa 	trap	3
81137190:	df000015 	stw	fp,0(sp)
81137194:	d839883a 	mov	fp,sp
}
81137198:	0001883a 	nop
8113719c:	e037883a 	mov	sp,fp
811371a0:	df000017 	ldw	fp,0(sp)
811371a4:	dec00104 	addi	sp,sp,4
811371a8:	f800283a 	ret

811371ac <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
811371ac:	defff804 	addi	sp,sp,-32
811371b0:	de00012e 	bgeu	sp,et,811371b8 <OS_EventTaskRdy+0xc>
811371b4:	003b68fa 	trap	3
811371b8:	dfc00715 	stw	ra,28(sp)
811371bc:	df000615 	stw	fp,24(sp)
811371c0:	df000604 	addi	fp,sp,24
811371c4:	e13ffc15 	stw	r4,-16(fp)
811371c8:	e17ffd15 	stw	r5,-12(fp)
811371cc:	3007883a 	mov	r3,r6
811371d0:	3805883a 	mov	r2,r7
811371d4:	e0fffe05 	stb	r3,-8(fp)
811371d8:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
811371dc:	e0bffc17 	ldw	r2,-16(fp)
811371e0:	10800283 	ldbu	r2,10(r2)
811371e4:	10c03fcc 	andi	r3,r2,255
811371e8:	00a04574 	movhi	r2,33045
811371ec:	10ba5104 	addi	r2,r2,-5820
811371f0:	10c5883a 	add	r2,r2,r3
811371f4:	10800003 	ldbu	r2,0(r2)
811371f8:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
811371fc:	e0bffa03 	ldbu	r2,-24(fp)
81137200:	e0fffc17 	ldw	r3,-16(fp)
81137204:	1885883a 	add	r2,r3,r2
81137208:	108002c4 	addi	r2,r2,11
8113720c:	10800003 	ldbu	r2,0(r2)
81137210:	10c03fcc 	andi	r3,r2,255
81137214:	00a04574 	movhi	r2,33045
81137218:	10ba5104 	addi	r2,r2,-5820
8113721c:	10c5883a 	add	r2,r2,r3
81137220:	10800003 	ldbu	r2,0(r2)
81137224:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81137228:	e0bffa03 	ldbu	r2,-24(fp)
8113722c:	100490fa 	slli	r2,r2,3
81137230:	1007883a 	mov	r3,r2
81137234:	e0bffa43 	ldbu	r2,-23(fp)
81137238:	1885883a 	add	r2,r3,r2
8113723c:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
81137240:	e0fffa83 	ldbu	r3,-22(fp)
81137244:	00a045f4 	movhi	r2,33047
81137248:	10a9d004 	addi	r2,r2,-22720
8113724c:	18c7883a 	add	r3,r3,r3
81137250:	18c7883a 	add	r3,r3,r3
81137254:	10c5883a 	add	r2,r2,r3
81137258:	10800017 	ldw	r2,0(r2)
8113725c:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
81137260:	e0bffb17 	ldw	r2,-20(fp)
81137264:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81137268:	e0bffb17 	ldw	r2,-20(fp)
8113726c:	e0fffd17 	ldw	r3,-12(fp)
81137270:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81137274:	e0bffb17 	ldw	r2,-20(fp)
81137278:	10800c03 	ldbu	r2,48(r2)
8113727c:	1007883a 	mov	r3,r2
81137280:	e0bffe03 	ldbu	r2,-8(fp)
81137284:	0084303a 	nor	r2,zero,r2
81137288:	1884703a 	and	r2,r3,r2
8113728c:	1007883a 	mov	r3,r2
81137290:	e0bffb17 	ldw	r2,-20(fp)
81137294:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81137298:	e0bffb17 	ldw	r2,-20(fp)
8113729c:	e0ffff03 	ldbu	r3,-4(fp)
811372a0:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
811372a4:	e0bffb17 	ldw	r2,-20(fp)
811372a8:	10800c03 	ldbu	r2,48(r2)
811372ac:	10803fcc 	andi	r2,r2,255
811372b0:	1080020c 	andi	r2,r2,8
811372b4:	1000111e 	bne	r2,zero,811372fc <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
811372b8:	e0bffb17 	ldw	r2,-20(fp)
811372bc:	10c00d83 	ldbu	r3,54(r2)
811372c0:	d0a09d03 	ldbu	r2,-32140(gp)
811372c4:	1884b03a 	or	r2,r3,r2
811372c8:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
811372cc:	e0fffa03 	ldbu	r3,-24(fp)
811372d0:	e13ffa03 	ldbu	r4,-24(fp)
811372d4:	d0a09d44 	addi	r2,gp,-32139
811372d8:	2085883a 	add	r2,r4,r2
811372dc:	11000003 	ldbu	r4,0(r2)
811372e0:	e0bffb17 	ldw	r2,-20(fp)
811372e4:	10800d43 	ldbu	r2,53(r2)
811372e8:	2084b03a 	or	r2,r4,r2
811372ec:	1009883a 	mov	r4,r2
811372f0:	d0a09d44 	addi	r2,gp,-32139
811372f4:	1885883a 	add	r2,r3,r2
811372f8:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
811372fc:	e17ffc17 	ldw	r5,-16(fp)
81137300:	e13ffb17 	ldw	r4,-20(fp)
81137304:	11375bc0 	call	811375bc <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
81137308:	e0bffb17 	ldw	r2,-20(fp)
8113730c:	10800817 	ldw	r2,32(r2)
81137310:	10000826 	beq	r2,zero,81137334 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
81137314:	e0bffb17 	ldw	r2,-20(fp)
81137318:	10800817 	ldw	r2,32(r2)
8113731c:	100b883a 	mov	r5,r2
81137320:	e13ffb17 	ldw	r4,-20(fp)
81137324:	113767c0 	call	8113767c <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81137328:	e0bffb17 	ldw	r2,-20(fp)
8113732c:	e0fffc17 	ldw	r3,-16(fp)
81137330:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81137334:	e0bffa83 	ldbu	r2,-22(fp)
}
81137338:	e037883a 	mov	sp,fp
8113733c:	dfc00117 	ldw	ra,4(sp)
81137340:	df000017 	ldw	fp,0(sp)
81137344:	dec00204 	addi	sp,sp,8
81137348:	f800283a 	ret

8113734c <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
8113734c:	defffd04 	addi	sp,sp,-12
81137350:	de00012e 	bgeu	sp,et,81137358 <OS_EventTaskWait+0xc>
81137354:	003b68fa 	trap	3
81137358:	df000215 	stw	fp,8(sp)
8113735c:	df000204 	addi	fp,sp,8
81137360:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81137364:	d0a0a117 	ldw	r2,-32124(gp)
81137368:	e0ffff17 	ldw	r3,-4(fp)
8113736c:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
81137370:	d0a0a117 	ldw	r2,-32124(gp)
81137374:	10800d03 	ldbu	r2,52(r2)
81137378:	10803fcc 	andi	r2,r2,255
8113737c:	d0e0a117 	ldw	r3,-32124(gp)
81137380:	18c00d03 	ldbu	r3,52(r3)
81137384:	18c03fcc 	andi	r3,r3,255
81137388:	e13fff17 	ldw	r4,-4(fp)
8113738c:	20c7883a 	add	r3,r4,r3
81137390:	18c002c4 	addi	r3,r3,11
81137394:	19000003 	ldbu	r4,0(r3)
81137398:	d0e0a117 	ldw	r3,-32124(gp)
8113739c:	18c00d43 	ldbu	r3,53(r3)
811373a0:	20c6b03a 	or	r3,r4,r3
811373a4:	1809883a 	mov	r4,r3
811373a8:	e0ffff17 	ldw	r3,-4(fp)
811373ac:	1885883a 	add	r2,r3,r2
811373b0:	108002c4 	addi	r2,r2,11
811373b4:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811373b8:	e0bfff17 	ldw	r2,-4(fp)
811373bc:	10c00283 	ldbu	r3,10(r2)
811373c0:	d0a0a117 	ldw	r2,-32124(gp)
811373c4:	10800d83 	ldbu	r2,54(r2)
811373c8:	1884b03a 	or	r2,r3,r2
811373cc:	1007883a 	mov	r3,r2
811373d0:	e0bfff17 	ldw	r2,-4(fp)
811373d4:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
811373d8:	d0a0a117 	ldw	r2,-32124(gp)
811373dc:	10800d03 	ldbu	r2,52(r2)
811373e0:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
811373e4:	e0fffe03 	ldbu	r3,-8(fp)
811373e8:	e13ffe03 	ldbu	r4,-8(fp)
811373ec:	d0a09d44 	addi	r2,gp,-32139
811373f0:	2085883a 	add	r2,r4,r2
811373f4:	10800003 	ldbu	r2,0(r2)
811373f8:	1009883a 	mov	r4,r2
811373fc:	d0a0a117 	ldw	r2,-32124(gp)
81137400:	10800d43 	ldbu	r2,53(r2)
81137404:	0084303a 	nor	r2,zero,r2
81137408:	2084703a 	and	r2,r4,r2
8113740c:	1009883a 	mov	r4,r2
81137410:	d0a09d44 	addi	r2,gp,-32139
81137414:	1885883a 	add	r2,r3,r2
81137418:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113741c:	e0fffe03 	ldbu	r3,-8(fp)
81137420:	d0a09d44 	addi	r2,gp,-32139
81137424:	1885883a 	add	r2,r3,r2
81137428:	10800003 	ldbu	r2,0(r2)
8113742c:	10803fcc 	andi	r2,r2,255
81137430:	1000071e 	bne	r2,zero,81137450 <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81137434:	d0a0a117 	ldw	r2,-32124(gp)
81137438:	10800d83 	ldbu	r2,54(r2)
8113743c:	0084303a 	nor	r2,zero,r2
81137440:	1007883a 	mov	r3,r2
81137444:	d0a09d03 	ldbu	r2,-32140(gp)
81137448:	1884703a 	and	r2,r3,r2
8113744c:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81137450:	0001883a 	nop
81137454:	e037883a 	mov	sp,fp
81137458:	df000017 	ldw	fp,0(sp)
8113745c:	dec00104 	addi	sp,sp,4
81137460:	f800283a 	ret

81137464 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81137464:	defffb04 	addi	sp,sp,-20
81137468:	de00012e 	bgeu	sp,et,81137470 <OS_EventTaskWaitMulti+0xc>
8113746c:	003b68fa 	trap	3
81137470:	df000415 	stw	fp,16(sp)
81137474:	df000404 	addi	fp,sp,16
81137478:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
8113747c:	d0a0a117 	ldw	r2,-32124(gp)
81137480:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81137484:	d0a0a117 	ldw	r2,-32124(gp)
81137488:	e0ffff17 	ldw	r3,-4(fp)
8113748c:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
81137490:	e0bfff17 	ldw	r2,-4(fp)
81137494:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81137498:	e0bffc17 	ldw	r2,-16(fp)
8113749c:	10800017 	ldw	r2,0(r2)
811374a0:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
811374a4:	00002006 	br	81137528 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
811374a8:	d0a0a117 	ldw	r2,-32124(gp)
811374ac:	10800d03 	ldbu	r2,52(r2)
811374b0:	10803fcc 	andi	r2,r2,255
811374b4:	d0e0a117 	ldw	r3,-32124(gp)
811374b8:	18c00d03 	ldbu	r3,52(r3)
811374bc:	18c03fcc 	andi	r3,r3,255
811374c0:	e13ffd17 	ldw	r4,-12(fp)
811374c4:	20c7883a 	add	r3,r4,r3
811374c8:	18c002c4 	addi	r3,r3,11
811374cc:	19000003 	ldbu	r4,0(r3)
811374d0:	d0e0a117 	ldw	r3,-32124(gp)
811374d4:	18c00d43 	ldbu	r3,53(r3)
811374d8:	20c6b03a 	or	r3,r4,r3
811374dc:	1809883a 	mov	r4,r3
811374e0:	e0fffd17 	ldw	r3,-12(fp)
811374e4:	1885883a 	add	r2,r3,r2
811374e8:	108002c4 	addi	r2,r2,11
811374ec:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811374f0:	e0bffd17 	ldw	r2,-12(fp)
811374f4:	10c00283 	ldbu	r3,10(r2)
811374f8:	d0a0a117 	ldw	r2,-32124(gp)
811374fc:	10800d83 	ldbu	r2,54(r2)
81137500:	1884b03a 	or	r2,r3,r2
81137504:	1007883a 	mov	r3,r2
81137508:	e0bffd17 	ldw	r2,-12(fp)
8113750c:	10c00285 	stb	r3,10(r2)
        pevents++;
81137510:	e0bffc17 	ldw	r2,-16(fp)
81137514:	10800104 	addi	r2,r2,4
81137518:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
8113751c:	e0bffc17 	ldw	r2,-16(fp)
81137520:	10800017 	ldw	r2,0(r2)
81137524:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81137528:	e0bffd17 	ldw	r2,-12(fp)
8113752c:	103fde1e 	bne	r2,zero,811374a8 <__reset+0xfb1174a8>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
81137530:	d0a0a117 	ldw	r2,-32124(gp)
81137534:	10800d03 	ldbu	r2,52(r2)
81137538:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
8113753c:	e0fffe03 	ldbu	r3,-8(fp)
81137540:	e13ffe03 	ldbu	r4,-8(fp)
81137544:	d0a09d44 	addi	r2,gp,-32139
81137548:	2085883a 	add	r2,r4,r2
8113754c:	10800003 	ldbu	r2,0(r2)
81137550:	1009883a 	mov	r4,r2
81137554:	d0a0a117 	ldw	r2,-32124(gp)
81137558:	10800d43 	ldbu	r2,53(r2)
8113755c:	0084303a 	nor	r2,zero,r2
81137560:	2084703a 	and	r2,r4,r2
81137564:	1009883a 	mov	r4,r2
81137568:	d0a09d44 	addi	r2,gp,-32139
8113756c:	1885883a 	add	r2,r3,r2
81137570:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81137574:	e0fffe03 	ldbu	r3,-8(fp)
81137578:	d0a09d44 	addi	r2,gp,-32139
8113757c:	1885883a 	add	r2,r3,r2
81137580:	10800003 	ldbu	r2,0(r2)
81137584:	10803fcc 	andi	r2,r2,255
81137588:	1000071e 	bne	r2,zero,811375a8 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
8113758c:	d0a0a117 	ldw	r2,-32124(gp)
81137590:	10800d83 	ldbu	r2,54(r2)
81137594:	0084303a 	nor	r2,zero,r2
81137598:	1007883a 	mov	r3,r2
8113759c:	d0a09d03 	ldbu	r2,-32140(gp)
811375a0:	1884703a 	and	r2,r3,r2
811375a4:	d0a09d05 	stb	r2,-32140(gp)
    }
}
811375a8:	0001883a 	nop
811375ac:	e037883a 	mov	sp,fp
811375b0:	df000017 	ldw	fp,0(sp)
811375b4:	dec00104 	addi	sp,sp,4
811375b8:	f800283a 	ret

811375bc <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
811375bc:	defffc04 	addi	sp,sp,-16
811375c0:	de00012e 	bgeu	sp,et,811375c8 <OS_EventTaskRemove+0xc>
811375c4:	003b68fa 	trap	3
811375c8:	df000315 	stw	fp,12(sp)
811375cc:	df000304 	addi	fp,sp,12
811375d0:	e13ffe15 	stw	r4,-8(fp)
811375d4:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
811375d8:	e0bffe17 	ldw	r2,-8(fp)
811375dc:	10800d03 	ldbu	r2,52(r2)
811375e0:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
811375e4:	e0bffd03 	ldbu	r2,-12(fp)
811375e8:	e0fffd03 	ldbu	r3,-12(fp)
811375ec:	e13fff17 	ldw	r4,-4(fp)
811375f0:	20c7883a 	add	r3,r4,r3
811375f4:	18c002c4 	addi	r3,r3,11
811375f8:	18c00003 	ldbu	r3,0(r3)
811375fc:	1809883a 	mov	r4,r3
81137600:	e0fffe17 	ldw	r3,-8(fp)
81137604:	18c00d43 	ldbu	r3,53(r3)
81137608:	00c6303a 	nor	r3,zero,r3
8113760c:	20c6703a 	and	r3,r4,r3
81137610:	1809883a 	mov	r4,r3
81137614:	e0ffff17 	ldw	r3,-4(fp)
81137618:	1885883a 	add	r2,r3,r2
8113761c:	108002c4 	addi	r2,r2,11
81137620:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81137624:	e0bffd03 	ldbu	r2,-12(fp)
81137628:	e0ffff17 	ldw	r3,-4(fp)
8113762c:	1885883a 	add	r2,r3,r2
81137630:	108002c4 	addi	r2,r2,11
81137634:	10800003 	ldbu	r2,0(r2)
81137638:	10803fcc 	andi	r2,r2,255
8113763c:	10000a1e 	bne	r2,zero,81137668 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
81137640:	e0bfff17 	ldw	r2,-4(fp)
81137644:	10800283 	ldbu	r2,10(r2)
81137648:	1007883a 	mov	r3,r2
8113764c:	e0bffe17 	ldw	r2,-8(fp)
81137650:	10800d83 	ldbu	r2,54(r2)
81137654:	0084303a 	nor	r2,zero,r2
81137658:	1884703a 	and	r2,r3,r2
8113765c:	1007883a 	mov	r3,r2
81137660:	e0bfff17 	ldw	r2,-4(fp)
81137664:	10c00285 	stb	r3,10(r2)
    }
}
81137668:	0001883a 	nop
8113766c:	e037883a 	mov	sp,fp
81137670:	df000017 	ldw	fp,0(sp)
81137674:	dec00104 	addi	sp,sp,4
81137678:	f800283a 	ret

8113767c <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
8113767c:	defffa04 	addi	sp,sp,-24
81137680:	de00012e 	bgeu	sp,et,81137688 <OS_EventTaskRemoveMulti+0xc>
81137684:	003b68fa 	trap	3
81137688:	df000515 	stw	fp,20(sp)
8113768c:	df000504 	addi	fp,sp,20
81137690:	e13ffe15 	stw	r4,-8(fp)
81137694:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81137698:	e0bffe17 	ldw	r2,-8(fp)
8113769c:	10800d03 	ldbu	r2,52(r2)
811376a0:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
811376a4:	e0bffe17 	ldw	r2,-8(fp)
811376a8:	10800d83 	ldbu	r2,54(r2)
811376ac:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
811376b0:	e0bffe17 	ldw	r2,-8(fp)
811376b4:	10800d43 	ldbu	r2,53(r2)
811376b8:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
811376bc:	e0bfff17 	ldw	r2,-4(fp)
811376c0:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
811376c4:	e0bffb17 	ldw	r2,-20(fp)
811376c8:	10800017 	ldw	r2,0(r2)
811376cc:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811376d0:	00002506 	br	81137768 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
811376d4:	e0bffd03 	ldbu	r2,-12(fp)
811376d8:	e0fffd03 	ldbu	r3,-12(fp)
811376dc:	e13ffc17 	ldw	r4,-16(fp)
811376e0:	20c7883a 	add	r3,r4,r3
811376e4:	18c002c4 	addi	r3,r3,11
811376e8:	18c00003 	ldbu	r3,0(r3)
811376ec:	1809883a 	mov	r4,r3
811376f0:	e0fffd83 	ldbu	r3,-10(fp)
811376f4:	00c6303a 	nor	r3,zero,r3
811376f8:	20c6703a 	and	r3,r4,r3
811376fc:	1809883a 	mov	r4,r3
81137700:	e0fffc17 	ldw	r3,-16(fp)
81137704:	1885883a 	add	r2,r3,r2
81137708:	108002c4 	addi	r2,r2,11
8113770c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
81137710:	e0bffd03 	ldbu	r2,-12(fp)
81137714:	e0fffc17 	ldw	r3,-16(fp)
81137718:	1885883a 	add	r2,r3,r2
8113771c:	108002c4 	addi	r2,r2,11
81137720:	10800003 	ldbu	r2,0(r2)
81137724:	10803fcc 	andi	r2,r2,255
81137728:	1000091e 	bne	r2,zero,81137750 <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
8113772c:	e0bffc17 	ldw	r2,-16(fp)
81137730:	10800283 	ldbu	r2,10(r2)
81137734:	1007883a 	mov	r3,r2
81137738:	e0bffd43 	ldbu	r2,-11(fp)
8113773c:	0084303a 	nor	r2,zero,r2
81137740:	1884703a 	and	r2,r3,r2
81137744:	1007883a 	mov	r3,r2
81137748:	e0bffc17 	ldw	r2,-16(fp)
8113774c:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
81137750:	e0bffb17 	ldw	r2,-20(fp)
81137754:	10800104 	addi	r2,r2,4
81137758:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
8113775c:	e0bffb17 	ldw	r2,-20(fp)
81137760:	10800017 	ldw	r2,0(r2)
81137764:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81137768:	e0bffc17 	ldw	r2,-16(fp)
8113776c:	103fd91e 	bne	r2,zero,811376d4 <__reset+0xfb1176d4>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
81137770:	0001883a 	nop
81137774:	e037883a 	mov	sp,fp
81137778:	df000017 	ldw	fp,0(sp)
8113777c:	dec00104 	addi	sp,sp,4
81137780:	f800283a 	ret

81137784 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
81137784:	defffc04 	addi	sp,sp,-16
81137788:	de00012e 	bgeu	sp,et,81137790 <OS_EventWaitListInit+0xc>
8113778c:	003b68fa 	trap	3
81137790:	df000315 	stw	fp,12(sp)
81137794:	df000304 	addi	fp,sp,12
81137798:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
8113779c:	e0bfff17 	ldw	r2,-4(fp)
811377a0:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
811377a4:	e0bfff17 	ldw	r2,-4(fp)
811377a8:	108002c4 	addi	r2,r2,11
811377ac:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811377b0:	e03ffe05 	stb	zero,-8(fp)
811377b4:	00000706 	br	811377d4 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
811377b8:	e0bffd17 	ldw	r2,-12(fp)
811377bc:	10c00044 	addi	r3,r2,1
811377c0:	e0fffd15 	stw	r3,-12(fp)
811377c4:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811377c8:	e0bffe03 	ldbu	r2,-8(fp)
811377cc:	10800044 	addi	r2,r2,1
811377d0:	e0bffe05 	stb	r2,-8(fp)
811377d4:	e0bffe03 	ldbu	r2,-8(fp)
811377d8:	108001b0 	cmpltui	r2,r2,6
811377dc:	103ff61e 	bne	r2,zero,811377b8 <__reset+0xfb1177b8>
        *ptbl++ = 0;
    }
}
811377e0:	0001883a 	nop
811377e4:	e037883a 	mov	sp,fp
811377e8:	df000017 	ldw	fp,0(sp)
811377ec:	dec00104 	addi	sp,sp,4
811377f0:	f800283a 	ret

811377f4 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
811377f4:	defffb04 	addi	sp,sp,-20
811377f8:	de00012e 	bgeu	sp,et,81137800 <OS_InitEventList+0xc>
811377fc:	003b68fa 	trap	3
81137800:	dfc00415 	stw	ra,16(sp)
81137804:	df000315 	stw	fp,12(sp)
81137808:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
8113780c:	01434004 	movi	r5,3328
81137810:	012045f4 	movhi	r4,33047
81137814:	21222204 	addi	r4,r4,-30584
81137818:	1137b9c0 	call	81137b9c <OS_MemClr>
    pevent1 = &OSEventTbl[0];
8113781c:	00a045f4 	movhi	r2,33047
81137820:	10a22204 	addi	r2,r2,-30584
81137824:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81137828:	00a045f4 	movhi	r2,33047
8113782c:	10a22f04 	addi	r2,r2,-30532
81137830:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81137834:	e03ffd0d 	sth	zero,-12(fp)
81137838:	00001306 	br	81137888 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113783c:	e0bffe17 	ldw	r2,-8(fp)
81137840:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81137844:	e0bffe17 	ldw	r2,-8(fp)
81137848:	e0ffff17 	ldw	r3,-4(fp)
8113784c:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
81137850:	e0bffe17 	ldw	r2,-8(fp)
81137854:	00c00fc4 	movi	r3,63
81137858:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
8113785c:	e0bffe17 	ldw	r2,-8(fp)
81137860:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
81137864:	e0bffe17 	ldw	r2,-8(fp)
81137868:	10800d04 	addi	r2,r2,52
8113786c:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
81137870:	e0bfff17 	ldw	r2,-4(fp)
81137874:	10800d04 	addi	r2,r2,52
81137878:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
8113787c:	e0bffd0b 	ldhu	r2,-12(fp)
81137880:	10800044 	addi	r2,r2,1
81137884:	e0bffd0d 	sth	r2,-12(fp)
81137888:	e0bffd0b 	ldhu	r2,-12(fp)
8113788c:	10800ff0 	cmpltui	r2,r2,63
81137890:	103fea1e 	bne	r2,zero,8113783c <__reset+0xfb11783c>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
81137894:	e0bffe17 	ldw	r2,-8(fp)
81137898:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
8113789c:	e0bffe17 	ldw	r2,-8(fp)
811378a0:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
811378a4:	e0bffe17 	ldw	r2,-8(fp)
811378a8:	00c00fc4 	movi	r3,63
811378ac:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
811378b0:	e0bffe17 	ldw	r2,-8(fp)
811378b4:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
811378b8:	00a045f4 	movhi	r2,33047
811378bc:	10a22204 	addi	r2,r2,-30584
811378c0:	d0a09f15 	stw	r2,-32132(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
811378c4:	0001883a 	nop
811378c8:	e037883a 	mov	sp,fp
811378cc:	dfc00117 	ldw	ra,4(sp)
811378d0:	df000017 	ldw	fp,0(sp)
811378d4:	dec00204 	addi	sp,sp,8
811378d8:	f800283a 	ret

811378dc <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
811378dc:	deffff04 	addi	sp,sp,-4
811378e0:	de00012e 	bgeu	sp,et,811378e8 <OS_InitMisc+0xc>
811378e4:	003b68fa 	trap	3
811378e8:	df000015 	stw	fp,0(sp)
811378ec:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
811378f0:	d020a315 	stw	zero,-32116(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
811378f4:	d020a005 	stb	zero,-32128(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
811378f8:	d0208e05 	stb	zero,-32200(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
811378fc:	d0209945 	stb	zero,-32155(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
81137900:	d0209005 	stb	zero,-32192(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
81137904:	d0209515 	stw	zero,-32172(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
81137908:	d0209115 	stw	zero,-32188(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
8113790c:	d020a715 	stw	zero,-32100(gp)
    OSIdleCtrMax  = 0L;
81137910:	d0209715 	stw	zero,-32164(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
81137914:	d020a605 	stb	zero,-32104(gp)
#endif
}
81137918:	0001883a 	nop
8113791c:	e037883a 	mov	sp,fp
81137920:	df000017 	ldw	fp,0(sp)
81137924:	dec00104 	addi	sp,sp,4
81137928:	f800283a 	ret

8113792c <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
8113792c:	defffd04 	addi	sp,sp,-12
81137930:	de00012e 	bgeu	sp,et,81137938 <OS_InitRdyList+0xc>
81137934:	003b68fa 	trap	3
81137938:	df000215 	stw	fp,8(sp)
8113793c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
81137940:	d0209d05 	stb	zero,-32140(gp)
    prdytbl       = &OSRdyTbl[0];
81137944:	d0a09d44 	addi	r2,gp,-32139
81137948:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
8113794c:	e03ffe05 	stb	zero,-8(fp)
81137950:	00000706 	br	81137970 <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
81137954:	e0bfff17 	ldw	r2,-4(fp)
81137958:	10c00044 	addi	r3,r2,1
8113795c:	e0ffff15 	stw	r3,-4(fp)
81137960:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81137964:	e0bffe03 	ldbu	r2,-8(fp)
81137968:	10800044 	addi	r2,r2,1
8113796c:	e0bffe05 	stb	r2,-8(fp)
81137970:	e0bffe03 	ldbu	r2,-8(fp)
81137974:	108001b0 	cmpltui	r2,r2,6
81137978:	103ff61e 	bne	r2,zero,81137954 <__reset+0xfb117954>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
8113797c:	d02092c5 	stb	zero,-32181(gp)
    OSPrioHighRdy = 0;
81137980:	d0209285 	stb	zero,-32182(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
81137984:	d0209b15 	stw	zero,-32148(gp)
    OSTCBCur      = (OS_TCB *)0;
81137988:	d020a115 	stw	zero,-32124(gp)
}
8113798c:	0001883a 	nop
81137990:	e037883a 	mov	sp,fp
81137994:	df000017 	ldw	fp,0(sp)
81137998:	dec00104 	addi	sp,sp,4
8113799c:	f800283a 	ret

811379a0 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
811379a0:	defff804 	addi	sp,sp,-32
811379a4:	de00012e 	bgeu	sp,et,811379ac <OS_InitTaskIdle+0xc>
811379a8:	003b68fa 	trap	3
811379ac:	dfc00715 	stw	ra,28(sp)
811379b0:	df000615 	stw	fp,24(sp)
811379b4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
811379b8:	008000c4 	movi	r2,3
811379bc:	d8800415 	stw	r2,16(sp)
811379c0:	d8000315 	stw	zero,12(sp)
811379c4:	00810004 	movi	r2,1024
811379c8:	d8800215 	stw	r2,8(sp)
811379cc:	00a045b4 	movhi	r2,33046
811379d0:	109e2204 	addi	r2,r2,30856
811379d4:	d8800115 	stw	r2,4(sp)
811379d8:	00bfffd4 	movui	r2,65535
811379dc:	d8800015 	stw	r2,0(sp)
811379e0:	01c00a84 	movi	r7,42
811379e4:	01a045f4 	movhi	r6,33047
811379e8:	31a22104 	addi	r6,r6,-30588
811379ec:	000b883a 	mov	r5,zero
811379f0:	012044f4 	movhi	r4,33043
811379f4:	211fa504 	addi	r4,r4,32404
811379f8:	113d8840 	call	8113d884 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
811379fc:	e1bfff04 	addi	r6,fp,-4
81137a00:	01604574 	movhi	r5,33045
81137a04:	297a9104 	addi	r5,r5,-5564
81137a08:	01000a84 	movi	r4,42
81137a0c:	113e0b40 	call	8113e0b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
81137a10:	0001883a 	nop
81137a14:	e037883a 	mov	sp,fp
81137a18:	dfc00117 	ldw	ra,4(sp)
81137a1c:	df000017 	ldw	fp,0(sp)
81137a20:	dec00204 	addi	sp,sp,8
81137a24:	f800283a 	ret

81137a28 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81137a28:	defff804 	addi	sp,sp,-32
81137a2c:	de00012e 	bgeu	sp,et,81137a34 <OS_InitTaskStat+0xc>
81137a30:	003b68fa 	trap	3
81137a34:	dfc00715 	stw	ra,28(sp)
81137a38:	df000615 	stw	fp,24(sp)
81137a3c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81137a40:	008000c4 	movi	r2,3
81137a44:	d8800415 	stw	r2,16(sp)
81137a48:	d8000315 	stw	zero,12(sp)
81137a4c:	00810004 	movi	r2,1024
81137a50:	d8800215 	stw	r2,8(sp)
81137a54:	00a045b4 	movhi	r2,33046
81137a58:	10976204 	addi	r2,r2,23944
81137a5c:	d8800115 	stw	r2,4(sp)
81137a60:	00bfff94 	movui	r2,65534
81137a64:	d8800015 	stw	r2,0(sp)
81137a68:	01c00a44 	movi	r7,41
81137a6c:	01a045b4 	movhi	r6,33046
81137a70:	319b6104 	addi	r6,r6,28036
81137a74:	000b883a 	mov	r5,zero
81137a78:	012044f4 	movhi	r4,33043
81137a7c:	211fbe04 	addi	r4,r4,32504
81137a80:	113d8840 	call	8113d884 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
81137a84:	e1bfff04 	addi	r6,fp,-4
81137a88:	01604574 	movhi	r5,33045
81137a8c:	297a9504 	addi	r5,r5,-5548
81137a90:	01000a44 	movi	r4,41
81137a94:	113e0b40 	call	8113e0b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81137a98:	0001883a 	nop
81137a9c:	e037883a 	mov	sp,fp
81137aa0:	dfc00117 	ldw	ra,4(sp)
81137aa4:	df000017 	ldw	fp,0(sp)
81137aa8:	dec00204 	addi	sp,sp,8
81137aac:	f800283a 	ret

81137ab0 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81137ab0:	defffb04 	addi	sp,sp,-20
81137ab4:	de00012e 	bgeu	sp,et,81137abc <OS_InitTCBList+0xc>
81137ab8:	003b68fa 	trap	3
81137abc:	dfc00415 	stw	ra,16(sp)
81137ac0:	df000315 	stw	fp,12(sp)
81137ac4:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81137ac8:	01446e04 	movi	r5,4536
81137acc:	012045f4 	movhi	r4,33047
81137ad0:	21256204 	addi	r4,r4,-27256
81137ad4:	1137b9c0 	call	81137b9c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81137ad8:	01402b04 	movi	r5,172
81137adc:	012045f4 	movhi	r4,33047
81137ae0:	2129d004 	addi	r4,r4,-22720
81137ae4:	1137b9c0 	call	81137b9c <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81137ae8:	00a045f4 	movhi	r2,33047
81137aec:	10a56204 	addi	r2,r2,-27256
81137af0:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81137af4:	00a045f4 	movhi	r2,33047
81137af8:	10a57d04 	addi	r2,r2,-27148
81137afc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81137b00:	e03ffd05 	stb	zero,-12(fp)
81137b04:	00001106 	br	81137b4c <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81137b08:	e0bffe17 	ldw	r2,-8(fp)
81137b0c:	e0ffff17 	ldw	r3,-4(fp)
81137b10:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81137b14:	e0bffe17 	ldw	r2,-8(fp)
81137b18:	00c00fc4 	movi	r3,63
81137b1c:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81137b20:	e0bffe17 	ldw	r2,-8(fp)
81137b24:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81137b28:	e0bffe17 	ldw	r2,-8(fp)
81137b2c:	10801b04 	addi	r2,r2,108
81137b30:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81137b34:	e0bfff17 	ldw	r2,-4(fp)
81137b38:	10801b04 	addi	r2,r2,108
81137b3c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81137b40:	e0bffd03 	ldbu	r2,-12(fp)
81137b44:	10800044 	addi	r2,r2,1
81137b48:	e0bffd05 	stb	r2,-12(fp)
81137b4c:	e0bffd03 	ldbu	r2,-12(fp)
81137b50:	10800a70 	cmpltui	r2,r2,41
81137b54:	103fec1e 	bne	r2,zero,81137b08 <__reset+0xfb117b08>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81137b58:	e0bffe17 	ldw	r2,-8(fp)
81137b5c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81137b60:	e0bffe17 	ldw	r2,-8(fp)
81137b64:	00c00fc4 	movi	r3,63
81137b68:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81137b6c:	e0bffe17 	ldw	r2,-8(fp)
81137b70:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81137b74:	d0209315 	stw	zero,-32180(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81137b78:	00a045f4 	movhi	r2,33047
81137b7c:	10a56204 	addi	r2,r2,-27256
81137b80:	d0a09815 	stw	r2,-32160(gp)
}
81137b84:	0001883a 	nop
81137b88:	e037883a 	mov	sp,fp
81137b8c:	dfc00117 	ldw	ra,4(sp)
81137b90:	df000017 	ldw	fp,0(sp)
81137b94:	dec00204 	addi	sp,sp,8
81137b98:	f800283a 	ret

81137b9c <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81137b9c:	defffd04 	addi	sp,sp,-12
81137ba0:	de00012e 	bgeu	sp,et,81137ba8 <OS_MemClr+0xc>
81137ba4:	003b68fa 	trap	3
81137ba8:	df000215 	stw	fp,8(sp)
81137bac:	df000204 	addi	fp,sp,8
81137bb0:	e13ffe15 	stw	r4,-8(fp)
81137bb4:	2805883a 	mov	r2,r5
81137bb8:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81137bbc:	00000706 	br	81137bdc <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81137bc0:	e0bffe17 	ldw	r2,-8(fp)
81137bc4:	10c00044 	addi	r3,r2,1
81137bc8:	e0fffe15 	stw	r3,-8(fp)
81137bcc:	10000005 	stb	zero,0(r2)
        size--;
81137bd0:	e0bfff0b 	ldhu	r2,-4(fp)
81137bd4:	10bfffc4 	addi	r2,r2,-1
81137bd8:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81137bdc:	e0bfff0b 	ldhu	r2,-4(fp)
81137be0:	103ff71e 	bne	r2,zero,81137bc0 <__reset+0xfb117bc0>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81137be4:	0001883a 	nop
81137be8:	e037883a 	mov	sp,fp
81137bec:	df000017 	ldw	fp,0(sp)
81137bf0:	dec00104 	addi	sp,sp,4
81137bf4:	f800283a 	ret

81137bf8 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81137bf8:	defffc04 	addi	sp,sp,-16
81137bfc:	de00012e 	bgeu	sp,et,81137c04 <OS_MemCopy+0xc>
81137c00:	003b68fa 	trap	3
81137c04:	df000315 	stw	fp,12(sp)
81137c08:	df000304 	addi	fp,sp,12
81137c0c:	e13ffd15 	stw	r4,-12(fp)
81137c10:	e17ffe15 	stw	r5,-8(fp)
81137c14:	3005883a 	mov	r2,r6
81137c18:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81137c1c:	00000b06 	br	81137c4c <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81137c20:	e0bffd17 	ldw	r2,-12(fp)
81137c24:	10c00044 	addi	r3,r2,1
81137c28:	e0fffd15 	stw	r3,-12(fp)
81137c2c:	e0fffe17 	ldw	r3,-8(fp)
81137c30:	19000044 	addi	r4,r3,1
81137c34:	e13ffe15 	stw	r4,-8(fp)
81137c38:	18c00003 	ldbu	r3,0(r3)
81137c3c:	10c00005 	stb	r3,0(r2)
        size--;
81137c40:	e0bfff0b 	ldhu	r2,-4(fp)
81137c44:	10bfffc4 	addi	r2,r2,-1
81137c48:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81137c4c:	e0bfff0b 	ldhu	r2,-4(fp)
81137c50:	103ff31e 	bne	r2,zero,81137c20 <__reset+0xfb117c20>
        *pdest++ = *psrc++;
        size--;
    }
}
81137c54:	0001883a 	nop
81137c58:	e037883a 	mov	sp,fp
81137c5c:	df000017 	ldw	fp,0(sp)
81137c60:	dec00104 	addi	sp,sp,4
81137c64:	f800283a 	ret

81137c68 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81137c68:	defffb04 	addi	sp,sp,-20
81137c6c:	de00012e 	bgeu	sp,et,81137c74 <OS_Sched+0xc>
81137c70:	003b68fa 	trap	3
81137c74:	dfc00415 	stw	ra,16(sp)
81137c78:	df000315 	stw	fp,12(sp)
81137c7c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81137c80:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137c84:	0005303a 	rdctl	r2,status
81137c88:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137c8c:	e0ffff17 	ldw	r3,-4(fp)
81137c90:	00bfff84 	movi	r2,-2
81137c94:	1884703a 	and	r2,r3,r2
81137c98:	1001703a 	wrctl	status,r2
  
  return context;
81137c9c:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81137ca0:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81137ca4:	d0a0a003 	ldbu	r2,-32128(gp)
81137ca8:	10803fcc 	andi	r2,r2,255
81137cac:	10001a1e 	bne	r2,zero,81137d18 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81137cb0:	d0a08e03 	ldbu	r2,-32200(gp)
81137cb4:	10803fcc 	andi	r2,r2,255
81137cb8:	1000171e 	bne	r2,zero,81137d18 <OS_Sched+0xb0>
            OS_SchedNew();
81137cbc:	1137d400 	call	81137d40 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81137cc0:	d0e09283 	ldbu	r3,-32182(gp)
81137cc4:	d0a092c3 	ldbu	r2,-32181(gp)
81137cc8:	18c03fcc 	andi	r3,r3,255
81137ccc:	10803fcc 	andi	r2,r2,255
81137cd0:	18801126 	beq	r3,r2,81137d18 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81137cd4:	d0a09283 	ldbu	r2,-32182(gp)
81137cd8:	10c03fcc 	andi	r3,r2,255
81137cdc:	00a045f4 	movhi	r2,33047
81137ce0:	10a9d004 	addi	r2,r2,-22720
81137ce4:	18c7883a 	add	r3,r3,r3
81137ce8:	18c7883a 	add	r3,r3,r3
81137cec:	10c5883a 	add	r2,r2,r3
81137cf0:	10800017 	ldw	r2,0(r2)
81137cf4:	d0a09b15 	stw	r2,-32148(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81137cf8:	d0a09b17 	ldw	r2,-32148(gp)
81137cfc:	10c00e17 	ldw	r3,56(r2)
81137d00:	18c00044 	addi	r3,r3,1
81137d04:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81137d08:	d0a09517 	ldw	r2,-32172(gp)
81137d0c:	10800044 	addi	r2,r2,1
81137d10:	d0a09515 	stw	r2,-32172(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81137d14:	1148c980 	call	81148c98 <OSCtxSw>
81137d18:	e0bffd17 	ldw	r2,-12(fp)
81137d1c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137d20:	e0bffe17 	ldw	r2,-8(fp)
81137d24:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81137d28:	0001883a 	nop
81137d2c:	e037883a 	mov	sp,fp
81137d30:	dfc00117 	ldw	ra,4(sp)
81137d34:	df000017 	ldw	fp,0(sp)
81137d38:	dec00204 	addi	sp,sp,8
81137d3c:	f800283a 	ret

81137d40 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81137d40:	defffe04 	addi	sp,sp,-8
81137d44:	de00012e 	bgeu	sp,et,81137d4c <OS_SchedNew+0xc>
81137d48:	003b68fa 	trap	3
81137d4c:	df000115 	stw	fp,4(sp)
81137d50:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81137d54:	d0a09d03 	ldbu	r2,-32140(gp)
81137d58:	10c03fcc 	andi	r3,r2,255
81137d5c:	00a04574 	movhi	r2,33045
81137d60:	10ba5104 	addi	r2,r2,-5820
81137d64:	10c5883a 	add	r2,r2,r3
81137d68:	10800003 	ldbu	r2,0(r2)
81137d6c:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81137d70:	e0bfff03 	ldbu	r2,-4(fp)
81137d74:	100490fa 	slli	r2,r2,3
81137d78:	1009883a 	mov	r4,r2
81137d7c:	e0ffff03 	ldbu	r3,-4(fp)
81137d80:	d0a09d44 	addi	r2,gp,-32139
81137d84:	1885883a 	add	r2,r3,r2
81137d88:	10800003 	ldbu	r2,0(r2)
81137d8c:	10c03fcc 	andi	r3,r2,255
81137d90:	00a04574 	movhi	r2,33045
81137d94:	10ba5104 	addi	r2,r2,-5820
81137d98:	10c5883a 	add	r2,r2,r3
81137d9c:	10800003 	ldbu	r2,0(r2)
81137da0:	2085883a 	add	r2,r4,r2
81137da4:	d0a09285 	stb	r2,-32182(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81137da8:	0001883a 	nop
81137dac:	e037883a 	mov	sp,fp
81137db0:	df000017 	ldw	fp,0(sp)
81137db4:	dec00104 	addi	sp,sp,4
81137db8:	f800283a 	ret

81137dbc <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81137dbc:	defffc04 	addi	sp,sp,-16
81137dc0:	de00012e 	bgeu	sp,et,81137dc8 <OS_StrCopy+0xc>
81137dc4:	003b68fa 	trap	3
81137dc8:	df000315 	stw	fp,12(sp)
81137dcc:	df000304 	addi	fp,sp,12
81137dd0:	e13ffe15 	stw	r4,-8(fp)
81137dd4:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81137dd8:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81137ddc:	00000b06 	br	81137e0c <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81137de0:	e0bffe17 	ldw	r2,-8(fp)
81137de4:	10c00044 	addi	r3,r2,1
81137de8:	e0fffe15 	stw	r3,-8(fp)
81137dec:	e0ffff17 	ldw	r3,-4(fp)
81137df0:	19000044 	addi	r4,r3,1
81137df4:	e13fff15 	stw	r4,-4(fp)
81137df8:	18c00003 	ldbu	r3,0(r3)
81137dfc:	10c00005 	stb	r3,0(r2)
        len++;
81137e00:	e0bffd03 	ldbu	r2,-12(fp)
81137e04:	10800044 	addi	r2,r2,1
81137e08:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81137e0c:	e0bfff17 	ldw	r2,-4(fp)
81137e10:	10800003 	ldbu	r2,0(r2)
81137e14:	10803fcc 	andi	r2,r2,255
81137e18:	103ff11e 	bne	r2,zero,81137de0 <__reset+0xfb117de0>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81137e1c:	e0bffe17 	ldw	r2,-8(fp)
81137e20:	10000005 	stb	zero,0(r2)
    return (len);
81137e24:	e0bffd03 	ldbu	r2,-12(fp)
}
81137e28:	e037883a 	mov	sp,fp
81137e2c:	df000017 	ldw	fp,0(sp)
81137e30:	dec00104 	addi	sp,sp,4
81137e34:	f800283a 	ret

81137e38 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81137e38:	defffd04 	addi	sp,sp,-12
81137e3c:	de00012e 	bgeu	sp,et,81137e44 <OS_StrLen+0xc>
81137e40:	003b68fa 	trap	3
81137e44:	df000215 	stw	fp,8(sp)
81137e48:	df000204 	addi	fp,sp,8
81137e4c:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81137e50:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81137e54:	00000606 	br	81137e70 <OS_StrLen+0x38>
        psrc++;
81137e58:	e0bfff17 	ldw	r2,-4(fp)
81137e5c:	10800044 	addi	r2,r2,1
81137e60:	e0bfff15 	stw	r2,-4(fp)
        len++;
81137e64:	e0bffe03 	ldbu	r2,-8(fp)
81137e68:	10800044 	addi	r2,r2,1
81137e6c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81137e70:	e0bfff17 	ldw	r2,-4(fp)
81137e74:	10800003 	ldbu	r2,0(r2)
81137e78:	10803fcc 	andi	r2,r2,255
81137e7c:	103ff61e 	bne	r2,zero,81137e58 <__reset+0xfb117e58>
        psrc++;
        len++;
    }
    return (len);
81137e80:	e0bffe03 	ldbu	r2,-8(fp)
}
81137e84:	e037883a 	mov	sp,fp
81137e88:	df000017 	ldw	fp,0(sp)
81137e8c:	dec00104 	addi	sp,sp,4
81137e90:	f800283a 	ret

81137e94 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81137e94:	defffa04 	addi	sp,sp,-24
81137e98:	de00012e 	bgeu	sp,et,81137ea0 <OS_TaskIdle+0xc>
81137e9c:	003b68fa 	trap	3
81137ea0:	dfc00515 	stw	ra,20(sp)
81137ea4:	df000415 	stw	fp,16(sp)
81137ea8:	df000404 	addi	fp,sp,16
81137eac:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137eb0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137eb4:	0005303a 	rdctl	r2,status
81137eb8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137ebc:	e0fffd17 	ldw	r3,-12(fp)
81137ec0:	00bfff84 	movi	r2,-2
81137ec4:	1884703a 	and	r2,r3,r2
81137ec8:	1001703a 	wrctl	status,r2
  
  return context;
81137ecc:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81137ed0:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81137ed4:	d0a09117 	ldw	r2,-32188(gp)
81137ed8:	10800044 	addi	r2,r2,1
81137edc:	d0a09115 	stw	r2,-32188(gp)
81137ee0:	e0bffc17 	ldw	r2,-16(fp)
81137ee4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137ee8:	e0bffe17 	ldw	r2,-8(fp)
81137eec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81137ef0:	114902c0 	call	8114902c <OSTaskIdleHook>
    }
81137ef4:	003fef06 	br	81137eb4 <__reset+0xfb117eb4>

81137ef8 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81137ef8:	defff804 	addi	sp,sp,-32
81137efc:	de00012e 	bgeu	sp,et,81137f04 <OS_TaskStat+0xc>
81137f00:	003b68fa 	trap	3
81137f04:	dfc00715 	stw	ra,28(sp)
81137f08:	df000615 	stw	fp,24(sp)
81137f0c:	dc400515 	stw	r17,20(sp)
81137f10:	dc000415 	stw	r16,16(sp)
81137f14:	df000604 	addi	fp,sp,24
81137f18:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137f1c:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81137f20:	00000206 	br	81137f2c <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81137f24:	01003204 	movi	r4,200
81137f28:	113e9a40 	call	8113e9a4 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81137f2c:	d0a0a603 	ldbu	r2,-32104(gp)
81137f30:	10803fcc 	andi	r2,r2,255
81137f34:	103ffb26 	beq	r2,zero,81137f24 <__reset+0xfb117f24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81137f38:	d0e09717 	ldw	r3,-32164(gp)
81137f3c:	00947b34 	movhi	r2,20972
81137f40:	10a147c4 	addi	r2,r2,-31457
81137f44:	1888383a 	mulxuu	r4,r3,r2
81137f48:	1885383a 	mul	r2,r3,r2
81137f4c:	1021883a 	mov	r16,r2
81137f50:	2023883a 	mov	r17,r4
81137f54:	8804d17a 	srli	r2,r17,5
81137f58:	d0a09715 	stw	r2,-32164(gp)
    if (OSIdleCtrMax == 0L) {
81137f5c:	d0a09717 	ldw	r2,-32164(gp)
81137f60:	1000031e 	bne	r2,zero,81137f70 <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81137f64:	d0209905 	stb	zero,-32156(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81137f68:	01003fc4 	movi	r4,255
81137f6c:	113e6140 	call	8113e614 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137f70:	0005303a 	rdctl	r2,status
81137f74:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137f78:	e0fffb17 	ldw	r3,-20(fp)
81137f7c:	00bfff84 	movi	r2,-2
81137f80:	1884703a 	and	r2,r3,r2
81137f84:	1001703a 	wrctl	status,r2
  
  return context;
81137f88:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81137f8c:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81137f90:	d0a09117 	ldw	r2,-32188(gp)
81137f94:	d0a0a715 	stw	r2,-32100(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81137f98:	d0209115 	stw	zero,-32188(gp)
81137f9c:	e0bffa17 	ldw	r2,-24(fp)
81137fa0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137fa4:	e0bffc17 	ldw	r2,-16(fp)
81137fa8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81137fac:	d0e0a717 	ldw	r3,-32100(gp)
81137fb0:	d0a09717 	ldw	r2,-32164(gp)
81137fb4:	1885203a 	divu	r2,r3,r2
81137fb8:	1007883a 	mov	r3,r2
81137fbc:	00801904 	movi	r2,100
81137fc0:	10c5c83a 	sub	r2,r2,r3
81137fc4:	d0a09905 	stb	r2,-32156(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81137fc8:	1148f5c0 	call	81148f5c <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81137fcc:	1137fdc0 	call	81137fdc <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81137fd0:	01001904 	movi	r4,100
81137fd4:	113e9a40 	call	8113e9a4 <OSTimeDly>
    }
81137fd8:	003fe506 	br	81137f70 <__reset+0xfb117f70>

81137fdc <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81137fdc:	defffa04 	addi	sp,sp,-24
81137fe0:	de00012e 	bgeu	sp,et,81137fe8 <OS_TaskStatStkChk+0xc>
81137fe4:	003b68fa 	trap	3
81137fe8:	dfc00515 	stw	ra,20(sp)
81137fec:	df000415 	stw	fp,16(sp)
81137ff0:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81137ff4:	e03ffc05 	stb	zero,-16(fp)
81137ff8:	00002406 	br	8113808c <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81137ffc:	e0bffc03 	ldbu	r2,-16(fp)
81138000:	e0fffe04 	addi	r3,fp,-8
81138004:	180b883a 	mov	r5,r3
81138008:	1009883a 	mov	r4,r2
8113800c:	113e44c0 	call	8113e44c <OSTaskStkChk>
81138010:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81138014:	e0bffc43 	ldbu	r2,-15(fp)
81138018:	1000191e 	bne	r2,zero,81138080 <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
8113801c:	e0fffc03 	ldbu	r3,-16(fp)
81138020:	00a045f4 	movhi	r2,33047
81138024:	10a9d004 	addi	r2,r2,-22720
81138028:	18c7883a 	add	r3,r3,r3
8113802c:	18c7883a 	add	r3,r3,r3
81138030:	10c5883a 	add	r2,r2,r3
81138034:	10800017 	ldw	r2,0(r2)
81138038:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
8113803c:	e0bffd17 	ldw	r2,-12(fp)
81138040:	10000f26 	beq	r2,zero,81138080 <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81138044:	e0bffd17 	ldw	r2,-12(fp)
81138048:	10800060 	cmpeqi	r2,r2,1
8113804c:	10000c1e 	bne	r2,zero,81138080 <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
81138050:	e0bffd17 	ldw	r2,-12(fp)
81138054:	10c00217 	ldw	r3,8(r2)
81138058:	e0bffd17 	ldw	r2,-12(fp)
8113805c:	10800317 	ldw	r2,12(r2)
81138060:	1085883a 	add	r2,r2,r2
81138064:	1085883a 	add	r2,r2,r2
81138068:	1887883a 	add	r3,r3,r2
8113806c:	e0bffd17 	ldw	r2,-12(fp)
81138070:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81138074:	e0ffff17 	ldw	r3,-4(fp)
81138078:	e0bffd17 	ldw	r2,-12(fp)
8113807c:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81138080:	e0bffc03 	ldbu	r2,-16(fp)
81138084:	10800044 	addi	r2,r2,1
81138088:	e0bffc05 	stb	r2,-16(fp)
8113808c:	e0bffc03 	ldbu	r2,-16(fp)
81138090:	10800af0 	cmpltui	r2,r2,43
81138094:	103fd91e 	bne	r2,zero,81137ffc <__reset+0xfb117ffc>
#endif
                }
            }
        }
    }
}
81138098:	0001883a 	nop
8113809c:	e037883a 	mov	sp,fp
811380a0:	dfc00117 	ldw	ra,4(sp)
811380a4:	df000017 	ldw	fp,0(sp)
811380a8:	dec00204 	addi	sp,sp,8
811380ac:	f800283a 	ret

811380b0 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
811380b0:	defff204 	addi	sp,sp,-56
811380b4:	de00012e 	bgeu	sp,et,811380bc <OS_TCBInit+0xc>
811380b8:	003b68fa 	trap	3
811380bc:	dfc00d15 	stw	ra,52(sp)
811380c0:	df000c15 	stw	fp,48(sp)
811380c4:	df000c04 	addi	fp,sp,48
811380c8:	e17ffc15 	stw	r5,-16(fp)
811380cc:	e1bffd15 	stw	r6,-12(fp)
811380d0:	3807883a 	mov	r3,r7
811380d4:	e0800417 	ldw	r2,16(fp)
811380d8:	e13ffb05 	stb	r4,-20(fp)
811380dc:	e0fffe0d 	sth	r3,-8(fp)
811380e0:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811380e4:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811380e8:	0005303a 	rdctl	r2,status
811380ec:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811380f0:	e0fffa17 	ldw	r3,-24(fp)
811380f4:	00bfff84 	movi	r2,-2
811380f8:	1884703a 	and	r2,r3,r2
811380fc:	1001703a 	wrctl	status,r2
  
  return context;
81138100:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
81138104:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
81138108:	d0a09817 	ldw	r2,-32160(gp)
8113810c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
81138110:	e0bff617 	ldw	r2,-40(fp)
81138114:	10009326 	beq	r2,zero,81138364 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
81138118:	e0bff617 	ldw	r2,-40(fp)
8113811c:	10800517 	ldw	r2,20(r2)
81138120:	d0a09815 	stw	r2,-32160(gp)
81138124:	e0bff417 	ldw	r2,-48(fp)
81138128:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113812c:	e0bff817 	ldw	r2,-32(fp)
81138130:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81138134:	e0bff617 	ldw	r2,-40(fp)
81138138:	e0fffc17 	ldw	r3,-16(fp)
8113813c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
81138140:	e0bff617 	ldw	r2,-40(fp)
81138144:	e0fffb03 	ldbu	r3,-20(fp)
81138148:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
8113814c:	e0bff617 	ldw	r2,-40(fp)
81138150:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81138154:	e0bff617 	ldw	r2,-40(fp)
81138158:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
8113815c:	e0bff617 	ldw	r2,-40(fp)
81138160:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81138164:	e0bff617 	ldw	r2,-40(fp)
81138168:	e0c00317 	ldw	r3,12(fp)
8113816c:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
81138170:	e0bff617 	ldw	r2,-40(fp)
81138174:	e0c00217 	ldw	r3,8(fp)
81138178:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
8113817c:	e0bff617 	ldw	r2,-40(fp)
81138180:	e0fffd17 	ldw	r3,-12(fp)
81138184:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81138188:	e0bff617 	ldw	r2,-40(fp)
8113818c:	e0ffff0b 	ldhu	r3,-4(fp)
81138190:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81138194:	e0bff617 	ldw	r2,-40(fp)
81138198:	e0fffe0b 	ldhu	r3,-8(fp)
8113819c:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
811381a0:	e0bff617 	ldw	r2,-40(fp)
811381a4:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
811381a8:	e0bffb03 	ldbu	r2,-20(fp)
811381ac:	1004d0fa 	srli	r2,r2,3
811381b0:	1007883a 	mov	r3,r2
811381b4:	e0bff617 	ldw	r2,-40(fp)
811381b8:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
811381bc:	e0bffb03 	ldbu	r2,-20(fp)
811381c0:	108001cc 	andi	r2,r2,7
811381c4:	1007883a 	mov	r3,r2
811381c8:	e0bff617 	ldw	r2,-40(fp)
811381cc:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
811381d0:	e0bff617 	ldw	r2,-40(fp)
811381d4:	10800d03 	ldbu	r2,52(r2)
811381d8:	10803fcc 	andi	r2,r2,255
811381dc:	00c00044 	movi	r3,1
811381e0:	1884983a 	sll	r2,r3,r2
811381e4:	1007883a 	mov	r3,r2
811381e8:	e0bff617 	ldw	r2,-40(fp)
811381ec:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
811381f0:	e0bff617 	ldw	r2,-40(fp)
811381f4:	10800cc3 	ldbu	r2,51(r2)
811381f8:	10803fcc 	andi	r2,r2,255
811381fc:	00c00044 	movi	r3,1
81138200:	1884983a 	sll	r2,r3,r2
81138204:	1007883a 	mov	r3,r2
81138208:	e0bff617 	ldw	r2,-40(fp)
8113820c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
81138210:	e0bff617 	ldw	r2,-40(fp)
81138214:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
81138218:	e0bff617 	ldw	r2,-40(fp)
8113821c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
81138220:	e0bff617 	ldw	r2,-40(fp)
81138224:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81138228:	e0bff617 	ldw	r2,-40(fp)
8113822c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
81138230:	e0bff617 	ldw	r2,-40(fp)
81138234:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81138238:	e0bff617 	ldw	r2,-40(fp)
8113823c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
81138240:	e0bff617 	ldw	r2,-40(fp)
81138244:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81138248:	e0bff617 	ldw	r2,-40(fp)
8113824c:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
81138250:	e0bff617 	ldw	r2,-40(fp)
81138254:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81138258:	e0bff617 	ldw	r2,-40(fp)
8113825c:	00c00fc4 	movi	r3,63
81138260:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81138264:	e0bff617 	ldw	r2,-40(fp)
81138268:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
8113826c:	e13ff617 	ldw	r4,-40(fp)
81138270:	11490540 	call	81149054 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81138274:	e13ff617 	ldw	r4,-40(fp)
81138278:	1148edc0 	call	81148edc <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113827c:	0005303a 	rdctl	r2,status
81138280:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138284:	e0fff517 	ldw	r3,-44(fp)
81138288:	00bfff84 	movi	r2,-2
8113828c:	1884703a 	and	r2,r3,r2
81138290:	1001703a 	wrctl	status,r2
  
  return context;
81138294:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81138298:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
8113829c:	e0fffb03 	ldbu	r3,-20(fp)
811382a0:	00a045f4 	movhi	r2,33047
811382a4:	10a9d004 	addi	r2,r2,-22720
811382a8:	18c7883a 	add	r3,r3,r3
811382ac:	18c7883a 	add	r3,r3,r3
811382b0:	10c5883a 	add	r2,r2,r3
811382b4:	e0fff617 	ldw	r3,-40(fp)
811382b8:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
811382bc:	d0e09317 	ldw	r3,-32180(gp)
811382c0:	e0bff617 	ldw	r2,-40(fp)
811382c4:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
811382c8:	e0bff617 	ldw	r2,-40(fp)
811382cc:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
811382d0:	d0a09317 	ldw	r2,-32180(gp)
811382d4:	10000326 	beq	r2,zero,811382e4 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
811382d8:	d0a09317 	ldw	r2,-32180(gp)
811382dc:	e0fff617 	ldw	r3,-40(fp)
811382e0:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
811382e4:	e0bff617 	ldw	r2,-40(fp)
811382e8:	d0a09315 	stw	r2,-32180(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
811382ec:	e0bff617 	ldw	r2,-40(fp)
811382f0:	10c00d83 	ldbu	r3,54(r2)
811382f4:	d0a09d03 	ldbu	r2,-32140(gp)
811382f8:	1884b03a 	or	r2,r3,r2
811382fc:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138300:	e0bff617 	ldw	r2,-40(fp)
81138304:	10800d03 	ldbu	r2,52(r2)
81138308:	10c03fcc 	andi	r3,r2,255
8113830c:	e0bff617 	ldw	r2,-40(fp)
81138310:	10800d03 	ldbu	r2,52(r2)
81138314:	11003fcc 	andi	r4,r2,255
81138318:	d0a09d44 	addi	r2,gp,-32139
8113831c:	2085883a 	add	r2,r4,r2
81138320:	11000003 	ldbu	r4,0(r2)
81138324:	e0bff617 	ldw	r2,-40(fp)
81138328:	10800d43 	ldbu	r2,53(r2)
8113832c:	2084b03a 	or	r2,r4,r2
81138330:	1009883a 	mov	r4,r2
81138334:	d0a09d44 	addi	r2,gp,-32139
81138338:	1885883a 	add	r2,r3,r2
8113833c:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
81138340:	d0a09943 	ldbu	r2,-32155(gp)
81138344:	10800044 	addi	r2,r2,1
81138348:	d0a09945 	stb	r2,-32155(gp)
8113834c:	e0bff417 	ldw	r2,-48(fp)
81138350:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138354:	e0bff717 	ldw	r2,-36(fp)
81138358:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113835c:	0005883a 	mov	r2,zero
81138360:	00000506 	br	81138378 <OS_TCBInit+0x2c8>
81138364:	e0bff417 	ldw	r2,-48(fp)
81138368:	e0bff915 	stw	r2,-28(fp)
8113836c:	e0bff917 	ldw	r2,-28(fp)
81138370:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81138374:	00801084 	movi	r2,66
}
81138378:	e037883a 	mov	sp,fp
8113837c:	dfc00117 	ldw	ra,4(sp)
81138380:	df000017 	ldw	fp,0(sp)
81138384:	dec00204 	addi	sp,sp,8
81138388:	f800283a 	ret

8113838c <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
8113838c:	defffe04 	addi	sp,sp,-8
81138390:	de00012e 	bgeu	sp,et,81138398 <OSDebugInit+0xc>
81138394:	003b68fa 	trap	3
81138398:	df000115 	stw	fp,4(sp)
8113839c:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
811383a0:	d0a01804 	addi	r2,gp,-32672
811383a4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
811383a8:	d0a01904 	addi	r2,gp,-32668
811383ac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
811383b0:	d0a01a84 	addi	r2,gp,-32662
811383b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
811383b8:	d0a01b04 	addi	r2,gp,-32660
811383bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
811383c0:	d0a01a04 	addi	r2,gp,-32664
811383c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
811383c8:	d0a01b84 	addi	r2,gp,-32658
811383cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
811383d0:	d0a01c04 	addi	r2,gp,-32656
811383d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
811383d8:	d0a01c84 	addi	r2,gp,-32654
811383dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
811383e0:	d0a01d04 	addi	r2,gp,-32652
811383e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
811383e8:	d0a01d84 	addi	r2,gp,-32650
811383ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
811383f0:	d0a01e04 	addi	r2,gp,-32648
811383f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
811383f8:	d0a01e84 	addi	r2,gp,-32646
811383fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
81138400:	d0a01f04 	addi	r2,gp,-32644
81138404:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
81138408:	d0a01f84 	addi	r2,gp,-32642
8113840c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
81138410:	d0a02004 	addi	r2,gp,-32640
81138414:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
81138418:	d0a02084 	addi	r2,gp,-32638
8113841c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
81138420:	d0a02104 	addi	r2,gp,-32636
81138424:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81138428:	d0a02184 	addi	r2,gp,-32634
8113842c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
81138430:	d0a02204 	addi	r2,gp,-32632
81138434:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81138438:	d0a02284 	addi	r2,gp,-32630
8113843c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
81138440:	d0a02304 	addi	r2,gp,-32628
81138444:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81138448:	d0a02384 	addi	r2,gp,-32626
8113844c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
81138450:	d0a02404 	addi	r2,gp,-32624
81138454:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81138458:	d0a02484 	addi	r2,gp,-32622
8113845c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
81138460:	d0a02504 	addi	r2,gp,-32620
81138464:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81138468:	d0a02584 	addi	r2,gp,-32618
8113846c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
81138470:	d0a02604 	addi	r2,gp,-32616
81138474:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81138478:	d0a02684 	addi	r2,gp,-32614
8113847c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
81138480:	d0a02704 	addi	r2,gp,-32612
81138484:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81138488:	d0a02784 	addi	r2,gp,-32610
8113848c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
81138490:	d0a02804 	addi	r2,gp,-32608
81138494:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81138498:	d0a02884 	addi	r2,gp,-32606
8113849c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
811384a0:	d0a02904 	addi	r2,gp,-32604
811384a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
811384a8:	d0a02984 	addi	r2,gp,-32602
811384ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
811384b0:	d0a02a04 	addi	r2,gp,-32600
811384b4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
811384b8:	d0a02a84 	addi	r2,gp,-32598
811384bc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
811384c0:	d0a02b04 	addi	r2,gp,-32596
811384c4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
811384c8:	d0a02b84 	addi	r2,gp,-32594
811384cc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
811384d0:	d0a02c04 	addi	r2,gp,-32592
811384d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
811384d8:	d0a02c84 	addi	r2,gp,-32590
811384dc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
811384e0:	d0a02d04 	addi	r2,gp,-32588
811384e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
811384e8:	d0a02d84 	addi	r2,gp,-32586
811384ec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
811384f0:	d0a02e04 	addi	r2,gp,-32584
811384f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
811384f8:	d0a02e84 	addi	r2,gp,-32582
811384fc:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
81138500:	00a045b4 	movhi	r2,33046
81138504:	1093ee04 	addi	r2,r2,20408
81138508:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
8113850c:	00a045b4 	movhi	r2,33046
81138510:	1091da04 	addi	r2,r2,18280
81138514:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
81138518:	d0a02f84 	addi	r2,gp,-32578
8113851c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
81138520:	d0a03004 	addi	r2,gp,-32576
81138524:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81138528:	d0a03084 	addi	r2,gp,-32574
8113852c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
81138530:	d0a03104 	addi	r2,gp,-32572
81138534:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81138538:	d0a03184 	addi	r2,gp,-32570
8113853c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
81138540:	d0a03204 	addi	r2,gp,-32568
81138544:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81138548:	d0a03284 	addi	r2,gp,-32566
8113854c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
81138550:	d0a03304 	addi	r2,gp,-32564
81138554:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81138558:	d0a03384 	addi	r2,gp,-32562
8113855c:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
81138560:	d0a02f04 	addi	r2,gp,-32580
81138564:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81138568:	d0a03404 	addi	r2,gp,-32560
8113856c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
81138570:	0001883a 	nop
81138574:	e037883a 	mov	sp,fp
81138578:	df000017 	ldw	fp,0(sp)
8113857c:	dec00104 	addi	sp,sp,4
81138580:	f800283a 	ret

81138584 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81138584:	defff204 	addi	sp,sp,-56
81138588:	de00012e 	bgeu	sp,et,81138590 <OSFlagAccept+0xc>
8113858c:	003b68fa 	trap	3
81138590:	df000d15 	stw	fp,52(sp)
81138594:	df000d04 	addi	fp,sp,52
81138598:	e13ffc15 	stw	r4,-16(fp)
8113859c:	2807883a 	mov	r3,r5
811385a0:	3005883a 	mov	r2,r6
811385a4:	e1ffff15 	stw	r7,-4(fp)
811385a8:	e0fffd0d 	sth	r3,-12(fp)
811385ac:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811385b0:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811385b4:	e0bfff17 	ldw	r2,-4(fp)
811385b8:	1000021e 	bne	r2,zero,811385c4 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
811385bc:	0005883a 	mov	r2,zero
811385c0:	0000b006 	br	81138884 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811385c4:	e0bffc17 	ldw	r2,-16(fp)
811385c8:	1000051e 	bne	r2,zero,811385e0 <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811385cc:	e0bfff17 	ldw	r2,-4(fp)
811385d0:	00c01b84 	movi	r3,110
811385d4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811385d8:	0005883a 	mov	r2,zero
811385dc:	0000a906 	br	81138884 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
811385e0:	e0bffc17 	ldw	r2,-16(fp)
811385e4:	10800003 	ldbu	r2,0(r2)
811385e8:	10803fcc 	andi	r2,r2,255
811385ec:	10800160 	cmpeqi	r2,r2,5
811385f0:	1000051e 	bne	r2,zero,81138608 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
811385f4:	e0bfff17 	ldw	r2,-4(fp)
811385f8:	00c00044 	movi	r3,1
811385fc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138600:	0005883a 	mov	r2,zero
81138604:	00009f06 	br	81138884 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81138608:	e0fffe03 	ldbu	r3,-8(fp)
8113860c:	00bfe004 	movi	r2,-128
81138610:	1884703a 	and	r2,r3,r2
81138614:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
81138618:	e0bff503 	ldbu	r2,-44(fp)
8113861c:	10000626 	beq	r2,zero,81138638 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
81138620:	e0bffe03 	ldbu	r2,-8(fp)
81138624:	10801fcc 	andi	r2,r2,127
81138628:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
8113862c:	00800044 	movi	r2,1
81138630:	e0bff385 	stb	r2,-50(fp)
81138634:	00000106 	br	8113863c <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81138638:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
8113863c:	e0bfff17 	ldw	r2,-4(fp)
81138640:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138644:	0005303a 	rdctl	r2,status
81138648:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113864c:	e0fffb17 	ldw	r3,-20(fp)
81138650:	00bfff84 	movi	r2,-2
81138654:	1884703a 	and	r2,r3,r2
81138658:	1001703a 	wrctl	status,r2
  
  return context;
8113865c:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
81138660:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81138664:	e0bffe03 	ldbu	r2,-8(fp)
81138668:	10c00060 	cmpeqi	r3,r2,1
8113866c:	18005f1e 	bne	r3,zero,811387ec <OSFlagAccept+0x268>
81138670:	10c00088 	cmpgei	r3,r2,2
81138674:	1800021e 	bne	r3,zero,81138680 <OSFlagAccept+0xfc>
81138678:	10003f26 	beq	r2,zero,81138778 <OSFlagAccept+0x1f4>
8113867c:	00007706 	br	8113885c <OSFlagAccept+0x2d8>
81138680:	10c000a0 	cmpeqi	r3,r2,2
81138684:	1800031e 	bne	r3,zero,81138694 <OSFlagAccept+0x110>
81138688:	108000e0 	cmpeqi	r2,r2,3
8113868c:	10001e1e 	bne	r2,zero,81138708 <OSFlagAccept+0x184>
81138690:	00007206 	br	8113885c <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81138694:	e0bffc17 	ldw	r2,-16(fp)
81138698:	10c0020b 	ldhu	r3,8(r2)
8113869c:	e0bffd0b 	ldhu	r2,-12(fp)
811386a0:	1884703a 	and	r2,r3,r2
811386a4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
811386a8:	e0fff30b 	ldhu	r3,-52(fp)
811386ac:	e0bffd0b 	ldhu	r2,-12(fp)
811386b0:	18800d1e 	bne	r3,r2,811386e8 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811386b4:	e0bff383 	ldbu	r2,-50(fp)
811386b8:	10800058 	cmpnei	r2,r2,1
811386bc:	10000d1e 	bne	r2,zero,811386f4 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
811386c0:	e0bffc17 	ldw	r2,-16(fp)
811386c4:	1080020b 	ldhu	r2,8(r2)
811386c8:	1007883a 	mov	r3,r2
811386cc:	e0bff30b 	ldhu	r2,-52(fp)
811386d0:	0084303a 	nor	r2,zero,r2
811386d4:	1884703a 	and	r2,r3,r2
811386d8:	1007883a 	mov	r3,r2
811386dc:	e0bffc17 	ldw	r2,-16(fp)
811386e0:	10c0020d 	sth	r3,8(r2)
811386e4:	00000306 	br	811386f4 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811386e8:	e0bfff17 	ldw	r2,-4(fp)
811386ec:	00c01c04 	movi	r3,112
811386f0:	10c00005 	stb	r3,0(r2)
811386f4:	e0bff417 	ldw	r2,-48(fp)
811386f8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811386fc:	e0bff617 	ldw	r2,-40(fp)
81138700:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81138704:	00005e06 	br	81138880 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81138708:	e0bffc17 	ldw	r2,-16(fp)
8113870c:	10c0020b 	ldhu	r3,8(r2)
81138710:	e0bffd0b 	ldhu	r2,-12(fp)
81138714:	1884703a 	and	r2,r3,r2
81138718:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
8113871c:	e0bff30b 	ldhu	r2,-52(fp)
81138720:	10000d26 	beq	r2,zero,81138758 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81138724:	e0bff383 	ldbu	r2,-50(fp)
81138728:	10800058 	cmpnei	r2,r2,1
8113872c:	10000d1e 	bne	r2,zero,81138764 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81138730:	e0bffc17 	ldw	r2,-16(fp)
81138734:	1080020b 	ldhu	r2,8(r2)
81138738:	1007883a 	mov	r3,r2
8113873c:	e0bff30b 	ldhu	r2,-52(fp)
81138740:	0084303a 	nor	r2,zero,r2
81138744:	1884703a 	and	r2,r3,r2
81138748:	1007883a 	mov	r3,r2
8113874c:	e0bffc17 	ldw	r2,-16(fp)
81138750:	10c0020d 	sth	r3,8(r2)
81138754:	00000306 	br	81138764 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81138758:	e0bfff17 	ldw	r2,-4(fp)
8113875c:	00c01c04 	movi	r3,112
81138760:	10c00005 	stb	r3,0(r2)
81138764:	e0bff417 	ldw	r2,-48(fp)
81138768:	e0bff715 	stw	r2,-36(fp)
8113876c:	e0bff717 	ldw	r2,-36(fp)
81138770:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81138774:	00004206 	br	81138880 <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81138778:	e0bffc17 	ldw	r2,-16(fp)
8113877c:	1080020b 	ldhu	r2,8(r2)
81138780:	0084303a 	nor	r2,zero,r2
81138784:	1007883a 	mov	r3,r2
81138788:	e0bffd0b 	ldhu	r2,-12(fp)
8113878c:	1884703a 	and	r2,r3,r2
81138790:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81138794:	e0fff30b 	ldhu	r3,-52(fp)
81138798:	e0bffd0b 	ldhu	r2,-12(fp)
8113879c:	18800b1e 	bne	r3,r2,811387cc <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811387a0:	e0bff383 	ldbu	r2,-50(fp)
811387a4:	10800058 	cmpnei	r2,r2,1
811387a8:	10000b1e 	bne	r2,zero,811387d8 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
811387ac:	e0bffc17 	ldw	r2,-16(fp)
811387b0:	10c0020b 	ldhu	r3,8(r2)
811387b4:	e0bff30b 	ldhu	r2,-52(fp)
811387b8:	1884b03a 	or	r2,r3,r2
811387bc:	1007883a 	mov	r3,r2
811387c0:	e0bffc17 	ldw	r2,-16(fp)
811387c4:	10c0020d 	sth	r3,8(r2)
811387c8:	00000306 	br	811387d8 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811387cc:	e0bfff17 	ldw	r2,-4(fp)
811387d0:	00c01c04 	movi	r3,112
811387d4:	10c00005 	stb	r3,0(r2)
811387d8:	e0bff417 	ldw	r2,-48(fp)
811387dc:	e0bff815 	stw	r2,-32(fp)
811387e0:	e0bff817 	ldw	r2,-32(fp)
811387e4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811387e8:	00002506 	br	81138880 <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811387ec:	e0bffc17 	ldw	r2,-16(fp)
811387f0:	1080020b 	ldhu	r2,8(r2)
811387f4:	0084303a 	nor	r2,zero,r2
811387f8:	1007883a 	mov	r3,r2
811387fc:	e0bffd0b 	ldhu	r2,-12(fp)
81138800:	1884703a 	and	r2,r3,r2
81138804:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81138808:	e0bff30b 	ldhu	r2,-52(fp)
8113880c:	10000b26 	beq	r2,zero,8113883c <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81138810:	e0bff383 	ldbu	r2,-50(fp)
81138814:	10800058 	cmpnei	r2,r2,1
81138818:	10000b1e 	bne	r2,zero,81138848 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113881c:	e0bffc17 	ldw	r2,-16(fp)
81138820:	10c0020b 	ldhu	r3,8(r2)
81138824:	e0bff30b 	ldhu	r2,-52(fp)
81138828:	1884b03a 	or	r2,r3,r2
8113882c:	1007883a 	mov	r3,r2
81138830:	e0bffc17 	ldw	r2,-16(fp)
81138834:	10c0020d 	sth	r3,8(r2)
81138838:	00000306 	br	81138848 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
8113883c:	e0bfff17 	ldw	r2,-4(fp)
81138840:	00c01c04 	movi	r3,112
81138844:	10c00005 	stb	r3,0(r2)
81138848:	e0bff417 	ldw	r2,-48(fp)
8113884c:	e0bff915 	stw	r2,-28(fp)
81138850:	e0bff917 	ldw	r2,-28(fp)
81138854:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81138858:	00000906 	br	81138880 <OSFlagAccept+0x2fc>
8113885c:	e0bff417 	ldw	r2,-48(fp)
81138860:	e0bffa15 	stw	r2,-24(fp)
81138864:	e0bffa17 	ldw	r2,-24(fp)
81138868:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113886c:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
81138870:	e0bfff17 	ldw	r2,-4(fp)
81138874:	00c01bc4 	movi	r3,111
81138878:	10c00005 	stb	r3,0(r2)
             break;
8113887c:	0001883a 	nop
    }
    return (flags_rdy);
81138880:	e0bff30b 	ldhu	r2,-52(fp)
}
81138884:	e037883a 	mov	sp,fp
81138888:	df000017 	ldw	fp,0(sp)
8113888c:	dec00104 	addi	sp,sp,4
81138890:	f800283a 	ret

81138894 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
81138894:	defff804 	addi	sp,sp,-32
81138898:	de00012e 	bgeu	sp,et,811388a0 <OSFlagCreate+0xc>
8113889c:	003b68fa 	trap	3
811388a0:	df000715 	stw	fp,28(sp)
811388a4:	df000704 	addi	fp,sp,28
811388a8:	2005883a 	mov	r2,r4
811388ac:	e17fff15 	stw	r5,-4(fp)
811388b0:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
811388b4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
811388b8:	e0bfff17 	ldw	r2,-4(fp)
811388bc:	1000021e 	bne	r2,zero,811388c8 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
811388c0:	0005883a 	mov	r2,zero
811388c4:	00003306 	br	81138994 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
811388c8:	d0a0a003 	ldbu	r2,-32128(gp)
811388cc:	10803fcc 	andi	r2,r2,255
811388d0:	10000526 	beq	r2,zero,811388e8 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
811388d4:	e0bfff17 	ldw	r2,-4(fp)
811388d8:	00c00404 	movi	r3,16
811388dc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
811388e0:	0005883a 	mov	r2,zero
811388e4:	00002b06 	br	81138994 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811388e8:	0005303a 	rdctl	r2,status
811388ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811388f0:	e0fffd17 	ldw	r3,-12(fp)
811388f4:	00bfff84 	movi	r2,-2
811388f8:	1884703a 	and	r2,r3,r2
811388fc:	1001703a 	wrctl	status,r2
  
  return context;
81138900:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81138904:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
81138908:	d0a0a517 	ldw	r2,-32108(gp)
8113890c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
81138910:	e0bffb17 	ldw	r2,-20(fp)
81138914:	10001726 	beq	r2,zero,81138974 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
81138918:	d0a0a517 	ldw	r2,-32108(gp)
8113891c:	10800117 	ldw	r2,4(r2)
81138920:	d0a0a515 	stw	r2,-32108(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81138924:	e0bffb17 	ldw	r2,-20(fp)
81138928:	00c00144 	movi	r3,5
8113892c:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
81138930:	e0bffb17 	ldw	r2,-20(fp)
81138934:	e0fffe0b 	ldhu	r3,-8(fp)
81138938:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
8113893c:	e0bffb17 	ldw	r2,-20(fp)
81138940:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81138944:	e0bffb17 	ldw	r2,-20(fp)
81138948:	00c00fc4 	movi	r3,63
8113894c:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81138950:	e0bffb17 	ldw	r2,-20(fp)
81138954:	100002c5 	stb	zero,11(r2)
81138958:	e0bff917 	ldw	r2,-28(fp)
8113895c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138960:	e0bffa17 	ldw	r2,-24(fp)
81138964:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
81138968:	e0bfff17 	ldw	r2,-4(fp)
8113896c:	10000005 	stb	zero,0(r2)
81138970:	00000706 	br	81138990 <OSFlagCreate+0xfc>
81138974:	e0bff917 	ldw	r2,-28(fp)
81138978:	e0bffc15 	stw	r2,-16(fp)
8113897c:	e0bffc17 	ldw	r2,-16(fp)
81138980:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
81138984:	e0bfff17 	ldw	r2,-4(fp)
81138988:	00c01c84 	movi	r3,114
8113898c:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
81138990:	e0bffb17 	ldw	r2,-20(fp)
}
81138994:	e037883a 	mov	sp,fp
81138998:	df000017 	ldw	fp,0(sp)
8113899c:	dec00104 	addi	sp,sp,4
811389a0:	f800283a 	ret

811389a4 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
811389a4:	defff204 	addi	sp,sp,-56
811389a8:	de00012e 	bgeu	sp,et,811389b0 <OSFlagDel+0xc>
811389ac:	003b68fa 	trap	3
811389b0:	dfc00d15 	stw	ra,52(sp)
811389b4:	df000c15 	stw	fp,48(sp)
811389b8:	df000c04 	addi	fp,sp,48
811389bc:	e13ffd15 	stw	r4,-12(fp)
811389c0:	2805883a 	mov	r2,r5
811389c4:	e1bfff15 	stw	r6,-4(fp)
811389c8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811389cc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811389d0:	e0bfff17 	ldw	r2,-4(fp)
811389d4:	1000021e 	bne	r2,zero,811389e0 <OSFlagDel+0x3c>
        return (pgrp);
811389d8:	e0bffd17 	ldw	r2,-12(fp)
811389dc:	00008006 	br	81138be0 <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811389e0:	e0bffd17 	ldw	r2,-12(fp)
811389e4:	1000051e 	bne	r2,zero,811389fc <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811389e8:	e0bfff17 	ldw	r2,-4(fp)
811389ec:	00c01b84 	movi	r3,110
811389f0:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811389f4:	e0bffd17 	ldw	r2,-12(fp)
811389f8:	00007906 	br	81138be0 <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811389fc:	d0a0a003 	ldbu	r2,-32128(gp)
81138a00:	10803fcc 	andi	r2,r2,255
81138a04:	10000526 	beq	r2,zero,81138a1c <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81138a08:	e0bfff17 	ldw	r2,-4(fp)
81138a0c:	00c003c4 	movi	r3,15
81138a10:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81138a14:	e0bffd17 	ldw	r2,-12(fp)
81138a18:	00007106 	br	81138be0 <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
81138a1c:	e0bffd17 	ldw	r2,-12(fp)
81138a20:	10800003 	ldbu	r2,0(r2)
81138a24:	10803fcc 	andi	r2,r2,255
81138a28:	10800160 	cmpeqi	r2,r2,5
81138a2c:	1000051e 	bne	r2,zero,81138a44 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81138a30:	e0bfff17 	ldw	r2,-4(fp)
81138a34:	00c00044 	movi	r3,1
81138a38:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81138a3c:	e0bffd17 	ldw	r2,-12(fp)
81138a40:	00006706 	br	81138be0 <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138a44:	0005303a 	rdctl	r2,status
81138a48:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138a4c:	e0fffc17 	ldw	r3,-16(fp)
81138a50:	00bfff84 	movi	r2,-2
81138a54:	1884703a 	and	r2,r3,r2
81138a58:	1001703a 	wrctl	status,r2
  
  return context;
81138a5c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138a60:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81138a64:	e0bffd17 	ldw	r2,-12(fp)
81138a68:	10800117 	ldw	r2,4(r2)
81138a6c:	10000326 	beq	r2,zero,81138a7c <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81138a70:	00800044 	movi	r2,1
81138a74:	e0bff405 	stb	r2,-48(fp)
81138a78:	00000106 	br	81138a80 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81138a7c:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81138a80:	e0bffe03 	ldbu	r2,-8(fp)
81138a84:	10000326 	beq	r2,zero,81138a94 <OSFlagDel+0xf0>
81138a88:	10800060 	cmpeqi	r2,r2,1
81138a8c:	1000231e 	bne	r2,zero,81138b1c <OSFlagDel+0x178>
81138a90:	00004806 	br	81138bb4 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
81138a94:	e0bff403 	ldbu	r2,-48(fp)
81138a98:	1000161e 	bne	r2,zero,81138af4 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
81138a9c:	e0bffd17 	ldw	r2,-12(fp)
81138aa0:	00c00fc4 	movi	r3,63
81138aa4:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81138aa8:	e0bffd17 	ldw	r2,-12(fp)
81138aac:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81138ab0:	e0bffd17 	ldw	r2,-12(fp)
81138ab4:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81138ab8:	d0e0a517 	ldw	r3,-32108(gp)
81138abc:	e0bffd17 	ldw	r2,-12(fp)
81138ac0:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81138ac4:	e0bffd17 	ldw	r2,-12(fp)
81138ac8:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
81138acc:	e0bffd17 	ldw	r2,-12(fp)
81138ad0:	d0a0a515 	stw	r2,-32108(gp)
81138ad4:	e0bff717 	ldw	r2,-36(fp)
81138ad8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138adc:	e0bff817 	ldw	r2,-32(fp)
81138ae0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81138ae4:	e0bfff17 	ldw	r2,-4(fp)
81138ae8:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81138aec:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81138af0:	00003a06 	br	81138bdc <OSFlagDel+0x238>
81138af4:	e0bff717 	ldw	r2,-36(fp)
81138af8:	e0bff915 	stw	r2,-28(fp)
81138afc:	e0bff917 	ldw	r2,-28(fp)
81138b00:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81138b04:	e0bfff17 	ldw	r2,-4(fp)
81138b08:	00c01244 	movi	r3,73
81138b0c:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81138b10:	e0bffd17 	ldw	r2,-12(fp)
81138b14:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81138b18:	00003006 	br	81138bdc <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81138b1c:	e0bffd17 	ldw	r2,-12(fp)
81138b20:	10800117 	ldw	r2,4(r2)
81138b24:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81138b28:	00000606 	br	81138b44 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81138b2c:	000b883a 	mov	r5,zero
81138b30:	e13ff517 	ldw	r4,-44(fp)
81138b34:	1139b580 	call	81139b58 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81138b38:	e0bff517 	ldw	r2,-44(fp)
81138b3c:	10800017 	ldw	r2,0(r2)
81138b40:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81138b44:	e0bff517 	ldw	r2,-44(fp)
81138b48:	103ff81e 	bne	r2,zero,81138b2c <__reset+0xfb118b2c>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81138b4c:	e0bffd17 	ldw	r2,-12(fp)
81138b50:	00c00fc4 	movi	r3,63
81138b54:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81138b58:	e0bffd17 	ldw	r2,-12(fp)
81138b5c:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81138b60:	e0bffd17 	ldw	r2,-12(fp)
81138b64:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81138b68:	d0e0a517 	ldw	r3,-32108(gp)
81138b6c:	e0bffd17 	ldw	r2,-12(fp)
81138b70:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81138b74:	e0bffd17 	ldw	r2,-12(fp)
81138b78:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81138b7c:	e0bffd17 	ldw	r2,-12(fp)
81138b80:	d0a0a515 	stw	r2,-32108(gp)
81138b84:	e0bff717 	ldw	r2,-36(fp)
81138b88:	e0bffa15 	stw	r2,-24(fp)
81138b8c:	e0bffa17 	ldw	r2,-24(fp)
81138b90:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81138b94:	e0bff403 	ldbu	r2,-48(fp)
81138b98:	10800058 	cmpnei	r2,r2,1
81138b9c:	1000011e 	bne	r2,zero,81138ba4 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81138ba0:	1137c680 	call	81137c68 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81138ba4:	e0bfff17 	ldw	r2,-4(fp)
81138ba8:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81138bac:	e03ff615 	stw	zero,-40(fp)
             break;
81138bb0:	00000a06 	br	81138bdc <OSFlagDel+0x238>
81138bb4:	e0bff717 	ldw	r2,-36(fp)
81138bb8:	e0bffb15 	stw	r2,-20(fp)
81138bbc:	e0bffb17 	ldw	r2,-20(fp)
81138bc0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81138bc4:	e0bfff17 	ldw	r2,-4(fp)
81138bc8:	00c001c4 	movi	r3,7
81138bcc:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81138bd0:	e0bffd17 	ldw	r2,-12(fp)
81138bd4:	e0bff615 	stw	r2,-40(fp)
             break;
81138bd8:	0001883a 	nop
    }
    return (pgrp_return);
81138bdc:	e0bff617 	ldw	r2,-40(fp)
}
81138be0:	e037883a 	mov	sp,fp
81138be4:	dfc00117 	ldw	ra,4(sp)
81138be8:	df000017 	ldw	fp,0(sp)
81138bec:	dec00204 	addi	sp,sp,8
81138bf0:	f800283a 	ret

81138bf4 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81138bf4:	defff604 	addi	sp,sp,-40
81138bf8:	de00012e 	bgeu	sp,et,81138c00 <OSFlagNameGet+0xc>
81138bfc:	003b68fa 	trap	3
81138c00:	dfc00915 	stw	ra,36(sp)
81138c04:	df000815 	stw	fp,32(sp)
81138c08:	df000804 	addi	fp,sp,32
81138c0c:	e13ffd15 	stw	r4,-12(fp)
81138c10:	e17ffe15 	stw	r5,-8(fp)
81138c14:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138c18:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138c1c:	e0bfff17 	ldw	r2,-4(fp)
81138c20:	1000021e 	bne	r2,zero,81138c2c <OSFlagNameGet+0x38>
        return (0);
81138c24:	0005883a 	mov	r2,zero
81138c28:	00003906 	br	81138d10 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81138c2c:	e0bffd17 	ldw	r2,-12(fp)
81138c30:	1000051e 	bne	r2,zero,81138c48 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81138c34:	e0bfff17 	ldw	r2,-4(fp)
81138c38:	00c01b84 	movi	r3,110
81138c3c:	10c00005 	stb	r3,0(r2)
        return (0);
81138c40:	0005883a 	mov	r2,zero
81138c44:	00003206 	br	81138d10 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138c48:	e0bffe17 	ldw	r2,-8(fp)
81138c4c:	1000051e 	bne	r2,zero,81138c64 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81138c50:	e0bfff17 	ldw	r2,-4(fp)
81138c54:	00c00304 	movi	r3,12
81138c58:	10c00005 	stb	r3,0(r2)
        return (0);
81138c5c:	0005883a 	mov	r2,zero
81138c60:	00002b06 	br	81138d10 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138c64:	d0a0a003 	ldbu	r2,-32128(gp)
81138c68:	10803fcc 	andi	r2,r2,255
81138c6c:	10000526 	beq	r2,zero,81138c84 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81138c70:	e0bfff17 	ldw	r2,-4(fp)
81138c74:	00c00444 	movi	r3,17
81138c78:	10c00005 	stb	r3,0(r2)
        return (0);
81138c7c:	0005883a 	mov	r2,zero
81138c80:	00002306 	br	81138d10 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138c84:	0005303a 	rdctl	r2,status
81138c88:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138c8c:	e0fffc17 	ldw	r3,-16(fp)
81138c90:	00bfff84 	movi	r2,-2
81138c94:	1884703a 	and	r2,r3,r2
81138c98:	1001703a 	wrctl	status,r2
  
  return context;
81138c9c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138ca0:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81138ca4:	e0bffd17 	ldw	r2,-12(fp)
81138ca8:	10800003 	ldbu	r2,0(r2)
81138cac:	10803fcc 	andi	r2,r2,255
81138cb0:	10800160 	cmpeqi	r2,r2,5
81138cb4:	1000091e 	bne	r2,zero,81138cdc <OSFlagNameGet+0xe8>
81138cb8:	e0bff817 	ldw	r2,-32(fp)
81138cbc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138cc0:	e0bff917 	ldw	r2,-28(fp)
81138cc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81138cc8:	e0bfff17 	ldw	r2,-4(fp)
81138ccc:	00c00044 	movi	r3,1
81138cd0:	10c00005 	stb	r3,0(r2)
        return (0);
81138cd4:	0005883a 	mov	r2,zero
81138cd8:	00000d06 	br	81138d10 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81138cdc:	e0bffd17 	ldw	r2,-12(fp)
81138ce0:	10800284 	addi	r2,r2,10
81138ce4:	100b883a 	mov	r5,r2
81138ce8:	e13ffe17 	ldw	r4,-8(fp)
81138cec:	1137dbc0 	call	81137dbc <OS_StrCopy>
81138cf0:	e0bffb05 	stb	r2,-20(fp)
81138cf4:	e0bff817 	ldw	r2,-32(fp)
81138cf8:	e0bffa15 	stw	r2,-24(fp)
81138cfc:	e0bffa17 	ldw	r2,-24(fp)
81138d00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138d04:	e0bfff17 	ldw	r2,-4(fp)
81138d08:	10000005 	stb	zero,0(r2)
    return (len);
81138d0c:	e0bffb03 	ldbu	r2,-20(fp)
}
81138d10:	e037883a 	mov	sp,fp
81138d14:	dfc00117 	ldw	ra,4(sp)
81138d18:	df000017 	ldw	fp,0(sp)
81138d1c:	dec00204 	addi	sp,sp,8
81138d20:	f800283a 	ret

81138d24 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81138d24:	defff504 	addi	sp,sp,-44
81138d28:	de00012e 	bgeu	sp,et,81138d30 <OSFlagNameSet+0xc>
81138d2c:	003b68fa 	trap	3
81138d30:	dfc00a15 	stw	ra,40(sp)
81138d34:	df000915 	stw	fp,36(sp)
81138d38:	df000904 	addi	fp,sp,36
81138d3c:	e13ffd15 	stw	r4,-12(fp)
81138d40:	e17ffe15 	stw	r5,-8(fp)
81138d44:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81138d48:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81138d4c:	e0bfff17 	ldw	r2,-4(fp)
81138d50:	10004326 	beq	r2,zero,81138e60 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81138d54:	e0bffd17 	ldw	r2,-12(fp)
81138d58:	1000041e 	bne	r2,zero,81138d6c <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81138d5c:	e0bfff17 	ldw	r2,-4(fp)
81138d60:	00c01b84 	movi	r3,110
81138d64:	10c00005 	stb	r3,0(r2)
        return;
81138d68:	00003e06 	br	81138e64 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138d6c:	e0bffe17 	ldw	r2,-8(fp)
81138d70:	1000041e 	bne	r2,zero,81138d84 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81138d74:	e0bfff17 	ldw	r2,-4(fp)
81138d78:	00c00304 	movi	r3,12
81138d7c:	10c00005 	stb	r3,0(r2)
        return;
81138d80:	00003806 	br	81138e64 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138d84:	d0a0a003 	ldbu	r2,-32128(gp)
81138d88:	10803fcc 	andi	r2,r2,255
81138d8c:	10000426 	beq	r2,zero,81138da0 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81138d90:	e0bfff17 	ldw	r2,-4(fp)
81138d94:	00c00484 	movi	r3,18
81138d98:	10c00005 	stb	r3,0(r2)
        return;
81138d9c:	00003106 	br	81138e64 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138da0:	0005303a 	rdctl	r2,status
81138da4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138da8:	e0fffc17 	ldw	r3,-16(fp)
81138dac:	00bfff84 	movi	r2,-2
81138db0:	1884703a 	and	r2,r3,r2
81138db4:	1001703a 	wrctl	status,r2
  
  return context;
81138db8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138dbc:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81138dc0:	e0bffd17 	ldw	r2,-12(fp)
81138dc4:	10800003 	ldbu	r2,0(r2)
81138dc8:	10803fcc 	andi	r2,r2,255
81138dcc:	10800160 	cmpeqi	r2,r2,5
81138dd0:	1000081e 	bne	r2,zero,81138df4 <OSFlagNameSet+0xd0>
81138dd4:	e0bff717 	ldw	r2,-36(fp)
81138dd8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138ddc:	e0bff817 	ldw	r2,-32(fp)
81138de0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81138de4:	e0bfff17 	ldw	r2,-4(fp)
81138de8:	00c00044 	movi	r3,1
81138dec:	10c00005 	stb	r3,0(r2)
        return;
81138df0:	00001c06 	br	81138e64 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81138df4:	e13ffe17 	ldw	r4,-8(fp)
81138df8:	1137e380 	call	81137e38 <OS_StrLen>
81138dfc:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81138e00:	e0bffa03 	ldbu	r2,-24(fp)
81138e04:	10800830 	cmpltui	r2,r2,32
81138e08:	1000081e 	bne	r2,zero,81138e2c <OSFlagNameSet+0x108>
81138e0c:	e0bff717 	ldw	r2,-36(fp)
81138e10:	e0bff915 	stw	r2,-28(fp)
81138e14:	e0bff917 	ldw	r2,-28(fp)
81138e18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81138e1c:	e0bfff17 	ldw	r2,-4(fp)
81138e20:	00c01cc4 	movi	r3,115
81138e24:	10c00005 	stb	r3,0(r2)
        return;
81138e28:	00000e06 	br	81138e64 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81138e2c:	e0bffd17 	ldw	r2,-12(fp)
81138e30:	10800284 	addi	r2,r2,10
81138e34:	e17ffe17 	ldw	r5,-8(fp)
81138e38:	1009883a 	mov	r4,r2
81138e3c:	1137dbc0 	call	81137dbc <OS_StrCopy>
81138e40:	e0bff717 	ldw	r2,-36(fp)
81138e44:	e0bffb15 	stw	r2,-20(fp)
81138e48:	e0bffb17 	ldw	r2,-20(fp)
81138e4c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138e50:	e0bfff17 	ldw	r2,-4(fp)
81138e54:	10000005 	stb	zero,0(r2)
    return;
81138e58:	0001883a 	nop
81138e5c:	00000106 	br	81138e64 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81138e60:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81138e64:	e037883a 	mov	sp,fp
81138e68:	dfc00117 	ldw	ra,4(sp)
81138e6c:	df000017 	ldw	fp,0(sp)
81138e70:	dec00204 	addi	sp,sp,8
81138e74:	f800283a 	ret

81138e78 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81138e78:	deffe104 	addi	sp,sp,-124
81138e7c:	de00012e 	bgeu	sp,et,81138e84 <OSFlagPend+0xc>
81138e80:	003b68fa 	trap	3
81138e84:	dfc01e15 	stw	ra,120(sp)
81138e88:	df001d15 	stw	fp,116(sp)
81138e8c:	df001d04 	addi	fp,sp,116
81138e90:	e13ffc15 	stw	r4,-16(fp)
81138e94:	2809883a 	mov	r4,r5
81138e98:	3007883a 	mov	r3,r6
81138e9c:	3805883a 	mov	r2,r7
81138ea0:	e13ffd0d 	sth	r4,-12(fp)
81138ea4:	e0fffe05 	stb	r3,-8(fp)
81138ea8:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81138eac:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138eb0:	e0800217 	ldw	r2,8(fp)
81138eb4:	1000021e 	bne	r2,zero,81138ec0 <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81138eb8:	0005883a 	mov	r2,zero
81138ebc:	00015906 	br	81139424 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81138ec0:	e0bffc17 	ldw	r2,-16(fp)
81138ec4:	1000051e 	bne	r2,zero,81138edc <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81138ec8:	e0800217 	ldw	r2,8(fp)
81138ecc:	00c01b84 	movi	r3,110
81138ed0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138ed4:	0005883a 	mov	r2,zero
81138ed8:	00015206 	br	81139424 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81138edc:	d0a0a003 	ldbu	r2,-32128(gp)
81138ee0:	10803fcc 	andi	r2,r2,255
81138ee4:	10000526 	beq	r2,zero,81138efc <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81138ee8:	e0800217 	ldw	r2,8(fp)
81138eec:	00c00084 	movi	r3,2
81138ef0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138ef4:	0005883a 	mov	r2,zero
81138ef8:	00014a06 	br	81139424 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81138efc:	d0a08e03 	ldbu	r2,-32200(gp)
81138f00:	10803fcc 	andi	r2,r2,255
81138f04:	10000526 	beq	r2,zero,81138f1c <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81138f08:	e0800217 	ldw	r2,8(fp)
81138f0c:	00c00344 	movi	r3,13
81138f10:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138f14:	0005883a 	mov	r2,zero
81138f18:	00014206 	br	81139424 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81138f1c:	e0bffc17 	ldw	r2,-16(fp)
81138f20:	10800003 	ldbu	r2,0(r2)
81138f24:	10803fcc 	andi	r2,r2,255
81138f28:	10800160 	cmpeqi	r2,r2,5
81138f2c:	1000051e 	bne	r2,zero,81138f44 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81138f30:	e0800217 	ldw	r2,8(fp)
81138f34:	00c00044 	movi	r3,1
81138f38:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81138f3c:	0005883a 	mov	r2,zero
81138f40:	00013806 	br	81139424 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81138f44:	e0fffe03 	ldbu	r3,-8(fp)
81138f48:	00bfe004 	movi	r2,-128
81138f4c:	1884703a 	and	r2,r3,r2
81138f50:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81138f54:	e0bfe603 	ldbu	r2,-104(fp)
81138f58:	10000626 	beq	r2,zero,81138f74 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
81138f5c:	e0bffe03 	ldbu	r2,-8(fp)
81138f60:	10801fcc 	andi	r2,r2,127
81138f64:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81138f68:	00800044 	movi	r2,1
81138f6c:	e0bfe405 	stb	r2,-112(fp)
81138f70:	00000106 	br	81138f78 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81138f74:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138f78:	0005303a 	rdctl	r2,status
81138f7c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138f80:	e0fff617 	ldw	r3,-40(fp)
81138f84:	00bfff84 	movi	r2,-2
81138f88:	1884703a 	and	r2,r3,r2
81138f8c:	1001703a 	wrctl	status,r2
  
  return context;
81138f90:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81138f94:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81138f98:	e0bffe03 	ldbu	r2,-8(fp)
81138f9c:	10c00060 	cmpeqi	r3,r2,1
81138fa0:	1800921e 	bne	r3,zero,811391ec <OSFlagPend+0x374>
81138fa4:	10c00088 	cmpgei	r3,r2,2
81138fa8:	1800021e 	bne	r3,zero,81138fb4 <OSFlagPend+0x13c>
81138fac:	10006126 	beq	r2,zero,81139134 <OSFlagPend+0x2bc>
81138fb0:	0000bb06 	br	811392a0 <OSFlagPend+0x428>
81138fb4:	10c000a0 	cmpeqi	r3,r2,2
81138fb8:	1800031e 	bne	r3,zero,81138fc8 <OSFlagPend+0x150>
81138fbc:	108000e0 	cmpeqi	r2,r2,3
81138fc0:	10002f1e 	bne	r2,zero,81139080 <OSFlagPend+0x208>
81138fc4:	0000b606 	br	811392a0 <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
81138fc8:	e0bffc17 	ldw	r2,-16(fp)
81138fcc:	10c0020b 	ldhu	r3,8(r2)
81138fd0:	e0bffd0b 	ldhu	r2,-12(fp)
81138fd4:	1884703a 	and	r2,r3,r2
81138fd8:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81138fdc:	e0ffe80b 	ldhu	r3,-96(fp)
81138fe0:	e0bffd0b 	ldhu	r2,-12(fp)
81138fe4:	1880171e 	bne	r3,r2,81139044 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81138fe8:	e0bfe403 	ldbu	r2,-112(fp)
81138fec:	10800058 	cmpnei	r2,r2,1
81138ff0:	1000091e 	bne	r2,zero,81139018 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81138ff4:	e0bffc17 	ldw	r2,-16(fp)
81138ff8:	1080020b 	ldhu	r2,8(r2)
81138ffc:	1007883a 	mov	r3,r2
81139000:	e0bfe80b 	ldhu	r2,-96(fp)
81139004:	0084303a 	nor	r2,zero,r2
81139008:	1884703a 	and	r2,r3,r2
8113900c:	1007883a 	mov	r3,r2
81139010:	e0bffc17 	ldw	r2,-16(fp)
81139014:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81139018:	d0a0a117 	ldw	r2,-32124(gp)
8113901c:	e0ffe80b 	ldhu	r3,-96(fp)
81139020:	10c00b0d 	sth	r3,44(r2)
81139024:	e0bfe517 	ldw	r2,-108(fp)
81139028:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113902c:	e0bfe717 	ldw	r2,-100(fp)
81139030:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81139034:	e0800217 	ldw	r2,8(fp)
81139038:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113903c:	e0bfe80b 	ldhu	r2,-96(fp)
81139040:	0000f806 	br	81139424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81139044:	e13ffd0b 	ldhu	r4,-12(fp)
81139048:	e17ffe03 	ldbu	r5,-8(fp)
8113904c:	e0bfff0b 	ldhu	r2,-4(fp)
81139050:	e0fff704 	addi	r3,fp,-36
81139054:	d8800015 	stw	r2,0(sp)
81139058:	280f883a 	mov	r7,r5
8113905c:	200d883a 	mov	r6,r4
81139060:	180b883a 	mov	r5,r3
81139064:	e13ffc17 	ldw	r4,-16(fp)
81139068:	11399080 	call	81139908 <OS_FlagBlock>
8113906c:	e0bfe517 	ldw	r2,-108(fp)
81139070:	e0bfe915 	stw	r2,-92(fp)
81139074:	e0bfe917 	ldw	r2,-92(fp)
81139078:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113907c:	00009206 	br	811392c8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
81139080:	e0bffc17 	ldw	r2,-16(fp)
81139084:	10c0020b 	ldhu	r3,8(r2)
81139088:	e0bffd0b 	ldhu	r2,-12(fp)
8113908c:	1884703a 	and	r2,r3,r2
81139090:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81139094:	e0bfe80b 	ldhu	r2,-96(fp)
81139098:	10001726 	beq	r2,zero,811390f8 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113909c:	e0bfe403 	ldbu	r2,-112(fp)
811390a0:	10800058 	cmpnei	r2,r2,1
811390a4:	1000091e 	bne	r2,zero,811390cc <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
811390a8:	e0bffc17 	ldw	r2,-16(fp)
811390ac:	1080020b 	ldhu	r2,8(r2)
811390b0:	1007883a 	mov	r3,r2
811390b4:	e0bfe80b 	ldhu	r2,-96(fp)
811390b8:	0084303a 	nor	r2,zero,r2
811390bc:	1884703a 	and	r2,r3,r2
811390c0:	1007883a 	mov	r3,r2
811390c4:	e0bffc17 	ldw	r2,-16(fp)
811390c8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811390cc:	d0a0a117 	ldw	r2,-32124(gp)
811390d0:	e0ffe80b 	ldhu	r3,-96(fp)
811390d4:	10c00b0d 	sth	r3,44(r2)
811390d8:	e0bfe517 	ldw	r2,-108(fp)
811390dc:	e0bfea15 	stw	r2,-88(fp)
811390e0:	e0bfea17 	ldw	r2,-88(fp)
811390e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811390e8:	e0800217 	ldw	r2,8(fp)
811390ec:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811390f0:	e0bfe80b 	ldhu	r2,-96(fp)
811390f4:	0000cb06 	br	81139424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811390f8:	e13ffd0b 	ldhu	r4,-12(fp)
811390fc:	e17ffe03 	ldbu	r5,-8(fp)
81139100:	e0bfff0b 	ldhu	r2,-4(fp)
81139104:	e0fff704 	addi	r3,fp,-36
81139108:	d8800015 	stw	r2,0(sp)
8113910c:	280f883a 	mov	r7,r5
81139110:	200d883a 	mov	r6,r4
81139114:	180b883a 	mov	r5,r3
81139118:	e13ffc17 	ldw	r4,-16(fp)
8113911c:	11399080 	call	81139908 <OS_FlagBlock>
81139120:	e0bfe517 	ldw	r2,-108(fp)
81139124:	e0bfeb15 	stw	r2,-84(fp)
81139128:	e0bfeb17 	ldw	r2,-84(fp)
8113912c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81139130:	00006506 	br	811392c8 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81139134:	e0bffc17 	ldw	r2,-16(fp)
81139138:	1080020b 	ldhu	r2,8(r2)
8113913c:	0084303a 	nor	r2,zero,r2
81139140:	1007883a 	mov	r3,r2
81139144:	e0bffd0b 	ldhu	r2,-12(fp)
81139148:	1884703a 	and	r2,r3,r2
8113914c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81139150:	e0ffe80b 	ldhu	r3,-96(fp)
81139154:	e0bffd0b 	ldhu	r2,-12(fp)
81139158:	1880151e 	bne	r3,r2,811391b0 <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113915c:	e0bfe403 	ldbu	r2,-112(fp)
81139160:	10800058 	cmpnei	r2,r2,1
81139164:	1000071e 	bne	r2,zero,81139184 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81139168:	e0bffc17 	ldw	r2,-16(fp)
8113916c:	10c0020b 	ldhu	r3,8(r2)
81139170:	e0bfe80b 	ldhu	r2,-96(fp)
81139174:	1884b03a 	or	r2,r3,r2
81139178:	1007883a 	mov	r3,r2
8113917c:	e0bffc17 	ldw	r2,-16(fp)
81139180:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81139184:	d0a0a117 	ldw	r2,-32124(gp)
81139188:	e0ffe80b 	ldhu	r3,-96(fp)
8113918c:	10c00b0d 	sth	r3,44(r2)
81139190:	e0bfe517 	ldw	r2,-108(fp)
81139194:	e0bfec15 	stw	r2,-80(fp)
81139198:	e0bfec17 	ldw	r2,-80(fp)
8113919c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811391a0:	e0800217 	ldw	r2,8(fp)
811391a4:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811391a8:	e0bfe80b 	ldhu	r2,-96(fp)
811391ac:	00009d06 	br	81139424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811391b0:	e13ffd0b 	ldhu	r4,-12(fp)
811391b4:	e17ffe03 	ldbu	r5,-8(fp)
811391b8:	e0bfff0b 	ldhu	r2,-4(fp)
811391bc:	e0fff704 	addi	r3,fp,-36
811391c0:	d8800015 	stw	r2,0(sp)
811391c4:	280f883a 	mov	r7,r5
811391c8:	200d883a 	mov	r6,r4
811391cc:	180b883a 	mov	r5,r3
811391d0:	e13ffc17 	ldw	r4,-16(fp)
811391d4:	11399080 	call	81139908 <OS_FlagBlock>
811391d8:	e0bfe517 	ldw	r2,-108(fp)
811391dc:	e0bfed15 	stw	r2,-76(fp)
811391e0:	e0bfed17 	ldw	r2,-76(fp)
811391e4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811391e8:	00003706 	br	811392c8 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811391ec:	e0bffc17 	ldw	r2,-16(fp)
811391f0:	1080020b 	ldhu	r2,8(r2)
811391f4:	0084303a 	nor	r2,zero,r2
811391f8:	1007883a 	mov	r3,r2
811391fc:	e0bffd0b 	ldhu	r2,-12(fp)
81139200:	1884703a 	and	r2,r3,r2
81139204:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
81139208:	e0bfe80b 	ldhu	r2,-96(fp)
8113920c:	10001526 	beq	r2,zero,81139264 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81139210:	e0bfe403 	ldbu	r2,-112(fp)
81139214:	10800058 	cmpnei	r2,r2,1
81139218:	1000071e 	bne	r2,zero,81139238 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
8113921c:	e0bffc17 	ldw	r2,-16(fp)
81139220:	10c0020b 	ldhu	r3,8(r2)
81139224:	e0bfe80b 	ldhu	r2,-96(fp)
81139228:	1884b03a 	or	r2,r3,r2
8113922c:	1007883a 	mov	r3,r2
81139230:	e0bffc17 	ldw	r2,-16(fp)
81139234:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81139238:	d0a0a117 	ldw	r2,-32124(gp)
8113923c:	e0ffe80b 	ldhu	r3,-96(fp)
81139240:	10c00b0d 	sth	r3,44(r2)
81139244:	e0bfe517 	ldw	r2,-108(fp)
81139248:	e0bfee15 	stw	r2,-72(fp)
8113924c:	e0bfee17 	ldw	r2,-72(fp)
81139250:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81139254:	e0800217 	ldw	r2,8(fp)
81139258:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
8113925c:	e0bfe80b 	ldhu	r2,-96(fp)
81139260:	00007006 	br	81139424 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81139264:	e13ffd0b 	ldhu	r4,-12(fp)
81139268:	e17ffe03 	ldbu	r5,-8(fp)
8113926c:	e0bfff0b 	ldhu	r2,-4(fp)
81139270:	e0fff704 	addi	r3,fp,-36
81139274:	d8800015 	stw	r2,0(sp)
81139278:	280f883a 	mov	r7,r5
8113927c:	200d883a 	mov	r6,r4
81139280:	180b883a 	mov	r5,r3
81139284:	e13ffc17 	ldw	r4,-16(fp)
81139288:	11399080 	call	81139908 <OS_FlagBlock>
8113928c:	e0bfe517 	ldw	r2,-108(fp)
81139290:	e0bfef15 	stw	r2,-68(fp)
81139294:	e0bfef17 	ldw	r2,-68(fp)
81139298:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113929c:	00000a06 	br	811392c8 <OSFlagPend+0x450>
811392a0:	e0bfe517 	ldw	r2,-108(fp)
811392a4:	e0bff015 	stw	r2,-64(fp)
811392a8:	e0bff017 	ldw	r2,-64(fp)
811392ac:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
811392b0:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
811392b4:	e0800217 	ldw	r2,8(fp)
811392b8:	00c01bc4 	movi	r3,111
811392bc:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
811392c0:	e0bfe80b 	ldhu	r2,-96(fp)
811392c4:	00005706 	br	81139424 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
811392c8:	1137c680 	call	81137c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811392cc:	0005303a 	rdctl	r2,status
811392d0:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811392d4:	e0fff117 	ldw	r3,-60(fp)
811392d8:	00bfff84 	movi	r2,-2
811392dc:	1884703a 	and	r2,r3,r2
811392e0:	1001703a 	wrctl	status,r2
  
  return context;
811392e4:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
811392e8:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
811392ec:	d0a0a117 	ldw	r2,-32124(gp)
811392f0:	10800c43 	ldbu	r2,49(r2)
811392f4:	10803fcc 	andi	r2,r2,255
811392f8:	10001c26 	beq	r2,zero,8113936c <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
811392fc:	d0a0a117 	ldw	r2,-32124(gp)
81139300:	10800c43 	ldbu	r2,49(r2)
81139304:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139308:	d0a0a117 	ldw	r2,-32124(gp)
8113930c:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
81139310:	e0bff704 	addi	r2,fp,-36
81139314:	1009883a 	mov	r4,r2
81139318:	1139c540 	call	81139c54 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
8113931c:	d0a0a117 	ldw	r2,-32124(gp)
81139320:	10000c05 	stb	zero,48(r2)
81139324:	e0bfe517 	ldw	r2,-108(fp)
81139328:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113932c:	e0bff217 	ldw	r2,-56(fp)
81139330:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81139334:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81139338:	e0bff303 	ldbu	r2,-52(fp)
8113933c:	108000a0 	cmpeqi	r2,r2,2
81139340:	10000426 	beq	r2,zero,81139354 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81139344:	e0800217 	ldw	r2,8(fp)
81139348:	00c00384 	movi	r3,14
8113934c:	10c00005 	stb	r3,0(r2)
                 break;
81139350:	00000406 	br	81139364 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81139354:	e0800217 	ldw	r2,8(fp)
81139358:	00c00284 	movi	r3,10
8113935c:	10c00005 	stb	r3,0(r2)
                 break;
81139360:	0001883a 	nop
        }
        return (flags_rdy);
81139364:	e0bfe80b 	ldhu	r2,-96(fp)
81139368:	00002e06 	br	81139424 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
8113936c:	d0a0a117 	ldw	r2,-32124(gp)
81139370:	10800b0b 	ldhu	r2,44(r2)
81139374:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81139378:	e0bfe403 	ldbu	r2,-112(fp)
8113937c:	10800058 	cmpnei	r2,r2,1
81139380:	1000211e 	bne	r2,zero,81139408 <OSFlagPend+0x590>
        switch (wait_type) {
81139384:	e0bffe03 	ldbu	r2,-8(fp)
81139388:	10001616 	blt	r2,zero,811393e4 <OSFlagPend+0x56c>
8113938c:	10c00090 	cmplti	r3,r2,2
81139390:	18000c1e 	bne	r3,zero,811393c4 <OSFlagPend+0x54c>
81139394:	10800108 	cmpgei	r2,r2,4
81139398:	1000121e 	bne	r2,zero,811393e4 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
8113939c:	e0bffc17 	ldw	r2,-16(fp)
811393a0:	1080020b 	ldhu	r2,8(r2)
811393a4:	1007883a 	mov	r3,r2
811393a8:	e0bfe80b 	ldhu	r2,-96(fp)
811393ac:	0084303a 	nor	r2,zero,r2
811393b0:	1884703a 	and	r2,r3,r2
811393b4:	1007883a 	mov	r3,r2
811393b8:	e0bffc17 	ldw	r2,-16(fp)
811393bc:	10c0020d 	sth	r3,8(r2)
                 break;
811393c0:	00001106 	br	81139408 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
811393c4:	e0bffc17 	ldw	r2,-16(fp)
811393c8:	10c0020b 	ldhu	r3,8(r2)
811393cc:	e0bfe80b 	ldhu	r2,-96(fp)
811393d0:	1884b03a 	or	r2,r3,r2
811393d4:	1007883a 	mov	r3,r2
811393d8:	e0bffc17 	ldw	r2,-16(fp)
811393dc:	10c0020d 	sth	r3,8(r2)
                 break;
811393e0:	00000906 	br	81139408 <OSFlagPend+0x590>
811393e4:	e0bfe517 	ldw	r2,-108(fp)
811393e8:	e0bff415 	stw	r2,-48(fp)
811393ec:	e0bff417 	ldw	r2,-48(fp)
811393f0:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811393f4:	e0800217 	ldw	r2,8(fp)
811393f8:	00c01bc4 	movi	r3,111
811393fc:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81139400:	0005883a 	mov	r2,zero
81139404:	00000706 	br	81139424 <OSFlagPend+0x5ac>
81139408:	e0bfe517 	ldw	r2,-108(fp)
8113940c:	e0bff515 	stw	r2,-44(fp)
81139410:	e0bff517 	ldw	r2,-44(fp)
81139414:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
81139418:	e0800217 	ldw	r2,8(fp)
8113941c:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
81139420:	e0bfe80b 	ldhu	r2,-96(fp)
}
81139424:	e037883a 	mov	sp,fp
81139428:	dfc00117 	ldw	ra,4(sp)
8113942c:	df000017 	ldw	fp,0(sp)
81139430:	dec00204 	addi	sp,sp,8
81139434:	f800283a 	ret

81139438 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81139438:	defffb04 	addi	sp,sp,-20
8113943c:	de00012e 	bgeu	sp,et,81139444 <OSFlagPendGetFlagsRdy+0xc>
81139440:	003b68fa 	trap	3
81139444:	df000415 	stw	fp,16(sp)
81139448:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113944c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139450:	0005303a 	rdctl	r2,status
81139454:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139458:	e0fffe17 	ldw	r3,-8(fp)
8113945c:	00bfff84 	movi	r2,-2
81139460:	1884703a 	and	r2,r3,r2
81139464:	1001703a 	wrctl	status,r2
  
  return context;
81139468:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113946c:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
81139470:	d0a0a117 	ldw	r2,-32124(gp)
81139474:	10800b0b 	ldhu	r2,44(r2)
81139478:	e0bffd0d 	sth	r2,-12(fp)
8113947c:	e0bffc17 	ldw	r2,-16(fp)
81139480:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139484:	e0bfff17 	ldw	r2,-4(fp)
81139488:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
8113948c:	e0bffd0b 	ldhu	r2,-12(fp)
}
81139490:	e037883a 	mov	sp,fp
81139494:	df000017 	ldw	fp,0(sp)
81139498:	dec00104 	addi	sp,sp,4
8113949c:	f800283a 	ret

811394a0 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
811394a0:	deffef04 	addi	sp,sp,-68
811394a4:	de00012e 	bgeu	sp,et,811394ac <OSFlagPost+0xc>
811394a8:	003b68fa 	trap	3
811394ac:	dfc01015 	stw	ra,64(sp)
811394b0:	df000f15 	stw	fp,60(sp)
811394b4:	df000f04 	addi	fp,sp,60
811394b8:	e13ffc15 	stw	r4,-16(fp)
811394bc:	2807883a 	mov	r3,r5
811394c0:	3005883a 	mov	r2,r6
811394c4:	e1ffff15 	stw	r7,-4(fp)
811394c8:	e0fffd0d 	sth	r3,-12(fp)
811394cc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
811394d0:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811394d4:	e0bfff17 	ldw	r2,-4(fp)
811394d8:	1000021e 	bne	r2,zero,811394e4 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
811394dc:	0005883a 	mov	r2,zero
811394e0:	0000d106 	br	81139828 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
811394e4:	e0bffc17 	ldw	r2,-16(fp)
811394e8:	1000051e 	bne	r2,zero,81139500 <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811394ec:	e0bfff17 	ldw	r2,-4(fp)
811394f0:	00c01b84 	movi	r3,110
811394f4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811394f8:	0005883a 	mov	r2,zero
811394fc:	0000ca06 	br	81139828 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
81139500:	e0bffc17 	ldw	r2,-16(fp)
81139504:	10800003 	ldbu	r2,0(r2)
81139508:	10803fcc 	andi	r2,r2,255
8113950c:	10800160 	cmpeqi	r2,r2,5
81139510:	1000051e 	bne	r2,zero,81139528 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
81139514:	e0bfff17 	ldw	r2,-4(fp)
81139518:	00c00044 	movi	r3,1
8113951c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81139520:	0005883a 	mov	r2,zero
81139524:	0000c006 	br	81139828 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139528:	0005303a 	rdctl	r2,status
8113952c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139530:	e0fffb17 	ldw	r3,-20(fp)
81139534:	00bfff84 	movi	r2,-2
81139538:	1884703a 	and	r2,r3,r2
8113953c:	1001703a 	wrctl	status,r2
  
  return context;
81139540:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81139544:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81139548:	e0bffe03 	ldbu	r2,-8(fp)
8113954c:	10000326 	beq	r2,zero,8113955c <OSFlagPost+0xbc>
81139550:	10800060 	cmpeqi	r2,r2,1
81139554:	10000b1e 	bne	r2,zero,81139584 <OSFlagPost+0xe4>
81139558:	00001206 	br	811395a4 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
8113955c:	e0bffc17 	ldw	r2,-16(fp)
81139560:	1080020b 	ldhu	r2,8(r2)
81139564:	1007883a 	mov	r3,r2
81139568:	e0bffd0b 	ldhu	r2,-12(fp)
8113956c:	0084303a 	nor	r2,zero,r2
81139570:	1884703a 	and	r2,r3,r2
81139574:	1007883a 	mov	r3,r2
81139578:	e0bffc17 	ldw	r2,-16(fp)
8113957c:	10c0020d 	sth	r3,8(r2)
             break;
81139580:	00001106 	br	811395c8 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
81139584:	e0bffc17 	ldw	r2,-16(fp)
81139588:	10c0020b 	ldhu	r3,8(r2)
8113958c:	e0bffd0b 	ldhu	r2,-12(fp)
81139590:	1884b03a 	or	r2,r3,r2
81139594:	1007883a 	mov	r3,r2
81139598:	e0bffc17 	ldw	r2,-16(fp)
8113959c:	10c0020d 	sth	r3,8(r2)
             break;
811395a0:	00000906 	br	811395c8 <OSFlagPost+0x128>
811395a4:	e0bff317 	ldw	r2,-52(fp)
811395a8:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811395ac:	e0bff417 	ldw	r2,-48(fp)
811395b0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
811395b4:	e0bfff17 	ldw	r2,-4(fp)
811395b8:	00c01c44 	movi	r3,113
811395bc:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
811395c0:	0005883a 	mov	r2,zero
811395c4:	00009806 	br	81139828 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
811395c8:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811395cc:	e0bffc17 	ldw	r2,-16(fp)
811395d0:	10800117 	ldw	r2,4(r2)
811395d4:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811395d8:	00007706 	br	811397b8 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
811395dc:	e0bff117 	ldw	r2,-60(fp)
811395e0:	10800483 	ldbu	r2,18(r2)
811395e4:	10803fcc 	andi	r2,r2,255
811395e8:	10c00060 	cmpeqi	r3,r2,1
811395ec:	18004a1e 	bne	r3,zero,81139718 <OSFlagPost+0x278>
811395f0:	10c00088 	cmpgei	r3,r2,2
811395f4:	1800021e 	bne	r3,zero,81139600 <OSFlagPost+0x160>
811395f8:	10002f26 	beq	r2,zero,811396b8 <OSFlagPost+0x218>
811395fc:	00005b06 	br	8113976c <OSFlagPost+0x2cc>
81139600:	10c000a0 	cmpeqi	r3,r2,2
81139604:	1800031e 	bne	r3,zero,81139614 <OSFlagPost+0x174>
81139608:	108000e0 	cmpeqi	r2,r2,3
8113960c:	1000171e 	bne	r2,zero,8113966c <OSFlagPost+0x1cc>
81139610:	00005606 	br	8113976c <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81139614:	e0bffc17 	ldw	r2,-16(fp)
81139618:	10c0020b 	ldhu	r3,8(r2)
8113961c:	e0bff117 	ldw	r2,-60(fp)
81139620:	1080040b 	ldhu	r2,16(r2)
81139624:	1884703a 	and	r2,r3,r2
81139628:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
8113962c:	e0bff117 	ldw	r2,-60(fp)
81139630:	1080040b 	ldhu	r2,16(r2)
81139634:	10ffffcc 	andi	r3,r2,65535
81139638:	e0bff60b 	ldhu	r2,-40(fp)
8113963c:	1880541e 	bne	r3,r2,81139790 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81139640:	e0bff60b 	ldhu	r2,-40(fp)
81139644:	100b883a 	mov	r5,r2
81139648:	e13ff117 	ldw	r4,-60(fp)
8113964c:	1139b580 	call	81139b58 <OS_FlagTaskRdy>
81139650:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81139654:	e0bff683 	ldbu	r2,-38(fp)
81139658:	10800058 	cmpnei	r2,r2,1
8113965c:	10004c1e 	bne	r2,zero,81139790 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81139660:	00800044 	movi	r2,1
81139664:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81139668:	00004906 	br	81139790 <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
8113966c:	e0bffc17 	ldw	r2,-16(fp)
81139670:	10c0020b 	ldhu	r3,8(r2)
81139674:	e0bff117 	ldw	r2,-60(fp)
81139678:	1080040b 	ldhu	r2,16(r2)
8113967c:	1884703a 	and	r2,r3,r2
81139680:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81139684:	e0bff60b 	ldhu	r2,-40(fp)
81139688:	10004326 	beq	r2,zero,81139798 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113968c:	e0bff60b 	ldhu	r2,-40(fp)
81139690:	100b883a 	mov	r5,r2
81139694:	e13ff117 	ldw	r4,-60(fp)
81139698:	1139b580 	call	81139b58 <OS_FlagTaskRdy>
8113969c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811396a0:	e0bff683 	ldbu	r2,-38(fp)
811396a4:	10800058 	cmpnei	r2,r2,1
811396a8:	10003b1e 	bne	r2,zero,81139798 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811396ac:	00800044 	movi	r2,1
811396b0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811396b4:	00003806 	br	81139798 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811396b8:	e0bffc17 	ldw	r2,-16(fp)
811396bc:	1080020b 	ldhu	r2,8(r2)
811396c0:	0084303a 	nor	r2,zero,r2
811396c4:	1007883a 	mov	r3,r2
811396c8:	e0bff117 	ldw	r2,-60(fp)
811396cc:	1080040b 	ldhu	r2,16(r2)
811396d0:	1884703a 	and	r2,r3,r2
811396d4:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
811396d8:	e0bff117 	ldw	r2,-60(fp)
811396dc:	1080040b 	ldhu	r2,16(r2)
811396e0:	10ffffcc 	andi	r3,r2,65535
811396e4:	e0bff60b 	ldhu	r2,-40(fp)
811396e8:	18802d1e 	bne	r3,r2,811397a0 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811396ec:	e0bff60b 	ldhu	r2,-40(fp)
811396f0:	100b883a 	mov	r5,r2
811396f4:	e13ff117 	ldw	r4,-60(fp)
811396f8:	1139b580 	call	81139b58 <OS_FlagTaskRdy>
811396fc:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81139700:	e0bff683 	ldbu	r2,-38(fp)
81139704:	10800058 	cmpnei	r2,r2,1
81139708:	1000251e 	bne	r2,zero,811397a0 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113970c:	00800044 	movi	r2,1
81139710:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81139714:	00002206 	br	811397a0 <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81139718:	e0bffc17 	ldw	r2,-16(fp)
8113971c:	1080020b 	ldhu	r2,8(r2)
81139720:	0084303a 	nor	r2,zero,r2
81139724:	1007883a 	mov	r3,r2
81139728:	e0bff117 	ldw	r2,-60(fp)
8113972c:	1080040b 	ldhu	r2,16(r2)
81139730:	1884703a 	and	r2,r3,r2
81139734:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81139738:	e0bff60b 	ldhu	r2,-40(fp)
8113973c:	10001a26 	beq	r2,zero,811397a8 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81139740:	e0bff60b 	ldhu	r2,-40(fp)
81139744:	100b883a 	mov	r5,r2
81139748:	e13ff117 	ldw	r4,-60(fp)
8113974c:	1139b580 	call	81139b58 <OS_FlagTaskRdy>
81139750:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81139754:	e0bff683 	ldbu	r2,-38(fp)
81139758:	10800058 	cmpnei	r2,r2,1
8113975c:	1000121e 	bne	r2,zero,811397a8 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81139760:	00800044 	movi	r2,1
81139764:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81139768:	00000f06 	br	811397a8 <OSFlagPost+0x308>
8113976c:	e0bff317 	ldw	r2,-52(fp)
81139770:	e0bff515 	stw	r2,-44(fp)
81139774:	e0bff517 	ldw	r2,-44(fp)
81139778:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
8113977c:	e0bfff17 	ldw	r2,-4(fp)
81139780:	00c01bc4 	movi	r3,111
81139784:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81139788:	0005883a 	mov	r2,zero
8113978c:	00002606 	br	81139828 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81139790:	0001883a 	nop
81139794:	00000506 	br	811397ac <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81139798:	0001883a 	nop
8113979c:	00000306 	br	811397ac <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811397a0:	0001883a 	nop
811397a4:	00000106 	br	811397ac <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
811397a8:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
811397ac:	e0bff117 	ldw	r2,-60(fp)
811397b0:	10800017 	ldw	r2,0(r2)
811397b4:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811397b8:	e0bff117 	ldw	r2,-60(fp)
811397bc:	103f871e 	bne	r2,zero,811395dc <__reset+0xfb1195dc>
811397c0:	e0bff317 	ldw	r2,-52(fp)
811397c4:	e0bff715 	stw	r2,-36(fp)
811397c8:	e0bff717 	ldw	r2,-36(fp)
811397cc:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
811397d0:	e0bff203 	ldbu	r2,-56(fp)
811397d4:	10800058 	cmpnei	r2,r2,1
811397d8:	1000011e 	bne	r2,zero,811397e0 <OSFlagPost+0x340>
        OS_Sched();
811397dc:	1137c680 	call	81137c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811397e0:	0005303a 	rdctl	r2,status
811397e4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811397e8:	e0fffa17 	ldw	r3,-24(fp)
811397ec:	00bfff84 	movi	r2,-2
811397f0:	1884703a 	and	r2,r3,r2
811397f4:	1001703a 	wrctl	status,r2
  
  return context;
811397f8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
811397fc:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
81139800:	e0bffc17 	ldw	r2,-16(fp)
81139804:	1080020b 	ldhu	r2,8(r2)
81139808:	e0bff90d 	sth	r2,-28(fp)
8113980c:	e0bff317 	ldw	r2,-52(fp)
81139810:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139814:	e0bff817 	ldw	r2,-32(fp)
81139818:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
8113981c:	e0bfff17 	ldw	r2,-4(fp)
81139820:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81139824:	e0bff90b 	ldhu	r2,-28(fp)
}
81139828:	e037883a 	mov	sp,fp
8113982c:	dfc00117 	ldw	ra,4(sp)
81139830:	df000017 	ldw	fp,0(sp)
81139834:	dec00204 	addi	sp,sp,8
81139838:	f800283a 	ret

8113983c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
8113983c:	defff904 	addi	sp,sp,-28
81139840:	de00012e 	bgeu	sp,et,81139848 <OSFlagQuery+0xc>
81139844:	003b68fa 	trap	3
81139848:	df000615 	stw	fp,24(sp)
8113984c:	df000604 	addi	fp,sp,24
81139850:	e13ffe15 	stw	r4,-8(fp)
81139854:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
81139858:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
8113985c:	e0bfff17 	ldw	r2,-4(fp)
81139860:	1000021e 	bne	r2,zero,8113986c <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
81139864:	0005883a 	mov	r2,zero
81139868:	00002306 	br	811398f8 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
8113986c:	e0bffe17 	ldw	r2,-8(fp)
81139870:	1000051e 	bne	r2,zero,81139888 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81139874:	e0bfff17 	ldw	r2,-4(fp)
81139878:	00c01b84 	movi	r3,110
8113987c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81139880:	0005883a 	mov	r2,zero
81139884:	00001c06 	br	811398f8 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
81139888:	e0bffe17 	ldw	r2,-8(fp)
8113988c:	10800003 	ldbu	r2,0(r2)
81139890:	10803fcc 	andi	r2,r2,255
81139894:	10800160 	cmpeqi	r2,r2,5
81139898:	1000051e 	bne	r2,zero,811398b0 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113989c:	e0bfff17 	ldw	r2,-4(fp)
811398a0:	00c00044 	movi	r3,1
811398a4:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811398a8:	0005883a 	mov	r2,zero
811398ac:	00001206 	br	811398f8 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811398b0:	0005303a 	rdctl	r2,status
811398b4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811398b8:	e0fffc17 	ldw	r3,-16(fp)
811398bc:	00bfff84 	movi	r2,-2
811398c0:	1884703a 	and	r2,r3,r2
811398c4:	1001703a 	wrctl	status,r2
  
  return context;
811398c8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811398cc:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
811398d0:	e0bffe17 	ldw	r2,-8(fp)
811398d4:	1080020b 	ldhu	r2,8(r2)
811398d8:	e0bffb0d 	sth	r2,-20(fp)
811398dc:	e0bffa17 	ldw	r2,-24(fp)
811398e0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811398e4:	e0bffd17 	ldw	r2,-12(fp)
811398e8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811398ec:	e0bfff17 	ldw	r2,-4(fp)
811398f0:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
811398f4:	e0bffb0b 	ldhu	r2,-20(fp)
}
811398f8:	e037883a 	mov	sp,fp
811398fc:	df000017 	ldw	fp,0(sp)
81139900:	dec00104 	addi	sp,sp,4
81139904:	f800283a 	ret

81139908 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
81139908:	defff804 	addi	sp,sp,-32
8113990c:	de00012e 	bgeu	sp,et,81139914 <OS_FlagBlock+0xc>
81139910:	003b68fa 	trap	3
81139914:	df000715 	stw	fp,28(sp)
81139918:	df000704 	addi	fp,sp,28
8113991c:	e13ffb15 	stw	r4,-20(fp)
81139920:	e17ffc15 	stw	r5,-16(fp)
81139924:	3009883a 	mov	r4,r6
81139928:	3807883a 	mov	r3,r7
8113992c:	e0800117 	ldw	r2,4(fp)
81139930:	e13ffd0d 	sth	r4,-12(fp)
81139934:	e0fffe05 	stb	r3,-8(fp)
81139938:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
8113993c:	d0a0a117 	ldw	r2,-32124(gp)
81139940:	d0e0a117 	ldw	r3,-32124(gp)
81139944:	18c00c03 	ldbu	r3,48(r3)
81139948:	18c00814 	ori	r3,r3,32
8113994c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
81139950:	d0a0a117 	ldw	r2,-32124(gp)
81139954:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
81139958:	d0a0a117 	ldw	r2,-32124(gp)
8113995c:	e0ffff0b 	ldhu	r3,-4(fp)
81139960:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
81139964:	d0a0a117 	ldw	r2,-32124(gp)
81139968:	e0fffc17 	ldw	r3,-16(fp)
8113996c:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
81139970:	e0bffc17 	ldw	r2,-16(fp)
81139974:	e0fffd0b 	ldhu	r3,-12(fp)
81139978:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
8113997c:	e0bffc17 	ldw	r2,-16(fp)
81139980:	e0fffe03 	ldbu	r3,-8(fp)
81139984:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
81139988:	d0e0a117 	ldw	r3,-32124(gp)
8113998c:	e0bffc17 	ldw	r2,-16(fp)
81139990:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
81139994:	e0bffb17 	ldw	r2,-20(fp)
81139998:	10c00117 	ldw	r3,4(r2)
8113999c:	e0bffc17 	ldw	r2,-16(fp)
811399a0:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
811399a4:	e0bffc17 	ldw	r2,-16(fp)
811399a8:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
811399ac:	e0bffc17 	ldw	r2,-16(fp)
811399b0:	e0fffb17 	ldw	r3,-20(fp)
811399b4:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811399b8:	e0bffb17 	ldw	r2,-20(fp)
811399bc:	10800117 	ldw	r2,4(r2)
811399c0:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
811399c4:	e0bff917 	ldw	r2,-28(fp)
811399c8:	10000326 	beq	r2,zero,811399d8 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
811399cc:	e0bff917 	ldw	r2,-28(fp)
811399d0:	e0fffc17 	ldw	r3,-16(fp)
811399d4:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
811399d8:	e0bffb17 	ldw	r2,-20(fp)
811399dc:	e0fffc17 	ldw	r3,-16(fp)
811399e0:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
811399e4:	d0a0a117 	ldw	r2,-32124(gp)
811399e8:	10800d03 	ldbu	r2,52(r2)
811399ec:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
811399f0:	e0fffa03 	ldbu	r3,-24(fp)
811399f4:	e13ffa03 	ldbu	r4,-24(fp)
811399f8:	d0a09d44 	addi	r2,gp,-32139
811399fc:	2085883a 	add	r2,r4,r2
81139a00:	10800003 	ldbu	r2,0(r2)
81139a04:	1009883a 	mov	r4,r2
81139a08:	d0a0a117 	ldw	r2,-32124(gp)
81139a0c:	10800d43 	ldbu	r2,53(r2)
81139a10:	0084303a 	nor	r2,zero,r2
81139a14:	2084703a 	and	r2,r4,r2
81139a18:	1009883a 	mov	r4,r2
81139a1c:	d0a09d44 	addi	r2,gp,-32139
81139a20:	1885883a 	add	r2,r3,r2
81139a24:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81139a28:	e0fffa03 	ldbu	r3,-24(fp)
81139a2c:	d0a09d44 	addi	r2,gp,-32139
81139a30:	1885883a 	add	r2,r3,r2
81139a34:	10800003 	ldbu	r2,0(r2)
81139a38:	10803fcc 	andi	r2,r2,255
81139a3c:	1000071e 	bne	r2,zero,81139a5c <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81139a40:	d0a0a117 	ldw	r2,-32124(gp)
81139a44:	10800d83 	ldbu	r2,54(r2)
81139a48:	0084303a 	nor	r2,zero,r2
81139a4c:	1007883a 	mov	r3,r2
81139a50:	d0a09d03 	ldbu	r2,-32140(gp)
81139a54:	1884703a 	and	r2,r3,r2
81139a58:	d0a09d05 	stb	r2,-32140(gp)
    }
}
81139a5c:	0001883a 	nop
81139a60:	e037883a 	mov	sp,fp
81139a64:	df000017 	ldw	fp,0(sp)
81139a68:	dec00104 	addi	sp,sp,4
81139a6c:	f800283a 	ret

81139a70 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81139a70:	defffb04 	addi	sp,sp,-20
81139a74:	de00012e 	bgeu	sp,et,81139a7c <OS_FlagInit+0xc>
81139a78:	003b68fa 	trap	3
81139a7c:	dfc00415 	stw	ra,16(sp)
81139a80:	df000315 	stw	fp,12(sp)
81139a84:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
81139a88:	01421004 	movi	r5,2112
81139a8c:	012045b4 	movhi	r4,33046
81139a90:	2111de04 	addi	r4,r4,18296
81139a94:	1137b9c0 	call	81137b9c <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
81139a98:	00a045b4 	movhi	r2,33046
81139a9c:	1091de04 	addi	r2,r2,18296
81139aa0:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
81139aa4:	00a045b4 	movhi	r2,33046
81139aa8:	1091e904 	addi	r2,r2,18340
81139aac:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81139ab0:	e03ffd0d 	sth	zero,-12(fp)
81139ab4:	00001306 	br	81139b04 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81139ab8:	e0bffe17 	ldw	r2,-8(fp)
81139abc:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81139ac0:	e0bffe17 	ldw	r2,-8(fp)
81139ac4:	e0ffff17 	ldw	r3,-4(fp)
81139ac8:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
81139acc:	e0bffe17 	ldw	r2,-8(fp)
81139ad0:	00c00fc4 	movi	r3,63
81139ad4:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81139ad8:	e0bffe17 	ldw	r2,-8(fp)
81139adc:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81139ae0:	e0bffe17 	ldw	r2,-8(fp)
81139ae4:	10800b04 	addi	r2,r2,44
81139ae8:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81139aec:	e0bfff17 	ldw	r2,-4(fp)
81139af0:	10800b04 	addi	r2,r2,44
81139af4:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81139af8:	e0bffd0b 	ldhu	r2,-12(fp)
81139afc:	10800044 	addi	r2,r2,1
81139b00:	e0bffd0d 	sth	r2,-12(fp)
81139b04:	e0bffd0b 	ldhu	r2,-12(fp)
81139b08:	10800bf0 	cmpltui	r2,r2,47
81139b0c:	103fea1e 	bne	r2,zero,81139ab8 <__reset+0xfb119ab8>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81139b10:	e0bffe17 	ldw	r2,-8(fp)
81139b14:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81139b18:	e0bffe17 	ldw	r2,-8(fp)
81139b1c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81139b20:	e0bffe17 	ldw	r2,-8(fp)
81139b24:	00c00fc4 	movi	r3,63
81139b28:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81139b2c:	e0bffe17 	ldw	r2,-8(fp)
81139b30:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81139b34:	00a045b4 	movhi	r2,33046
81139b38:	1091de04 	addi	r2,r2,18296
81139b3c:	d0a0a515 	stw	r2,-32108(gp)
#endif
}
81139b40:	0001883a 	nop
81139b44:	e037883a 	mov	sp,fp
81139b48:	dfc00117 	ldw	ra,4(sp)
81139b4c:	df000017 	ldw	fp,0(sp)
81139b50:	dec00204 	addi	sp,sp,8
81139b54:	f800283a 	ret

81139b58 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81139b58:	defffa04 	addi	sp,sp,-24
81139b5c:	de00012e 	bgeu	sp,et,81139b64 <OS_FlagTaskRdy+0xc>
81139b60:	003b68fa 	trap	3
81139b64:	dfc00515 	stw	ra,20(sp)
81139b68:	df000415 	stw	fp,16(sp)
81139b6c:	df000404 	addi	fp,sp,16
81139b70:	e13ffe15 	stw	r4,-8(fp)
81139b74:	2805883a 	mov	r2,r5
81139b78:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
81139b7c:	e0bffe17 	ldw	r2,-8(fp)
81139b80:	10800217 	ldw	r2,8(r2)
81139b84:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81139b88:	e0bffd17 	ldw	r2,-12(fp)
81139b8c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81139b90:	e0bffd17 	ldw	r2,-12(fp)
81139b94:	e0ffff0b 	ldhu	r3,-4(fp)
81139b98:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
81139b9c:	e0bffd17 	ldw	r2,-12(fp)
81139ba0:	10c00c03 	ldbu	r3,48(r2)
81139ba4:	00bff7c4 	movi	r2,-33
81139ba8:	1884703a 	and	r2,r3,r2
81139bac:	1007883a 	mov	r3,r2
81139bb0:	e0bffd17 	ldw	r2,-12(fp)
81139bb4:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81139bb8:	e0bffd17 	ldw	r2,-12(fp)
81139bbc:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81139bc0:	e0bffd17 	ldw	r2,-12(fp)
81139bc4:	10800c03 	ldbu	r2,48(r2)
81139bc8:	10803fcc 	andi	r2,r2,255
81139bcc:	1000181e 	bne	r2,zero,81139c30 <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81139bd0:	e0bffd17 	ldw	r2,-12(fp)
81139bd4:	10c00d83 	ldbu	r3,54(r2)
81139bd8:	d0a09d03 	ldbu	r2,-32140(gp)
81139bdc:	1884b03a 	or	r2,r3,r2
81139be0:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81139be4:	e0bffd17 	ldw	r2,-12(fp)
81139be8:	10800d03 	ldbu	r2,52(r2)
81139bec:	10c03fcc 	andi	r3,r2,255
81139bf0:	e0bffd17 	ldw	r2,-12(fp)
81139bf4:	10800d03 	ldbu	r2,52(r2)
81139bf8:	11003fcc 	andi	r4,r2,255
81139bfc:	d0a09d44 	addi	r2,gp,-32139
81139c00:	2085883a 	add	r2,r4,r2
81139c04:	11000003 	ldbu	r4,0(r2)
81139c08:	e0bffd17 	ldw	r2,-12(fp)
81139c0c:	10800d43 	ldbu	r2,53(r2)
81139c10:	2084b03a 	or	r2,r4,r2
81139c14:	1009883a 	mov	r4,r2
81139c18:	d0a09d44 	addi	r2,gp,-32139
81139c1c:	1885883a 	add	r2,r3,r2
81139c20:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81139c24:	00800044 	movi	r2,1
81139c28:	e0bffc05 	stb	r2,-16(fp)
81139c2c:	00000106 	br	81139c34 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81139c30:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81139c34:	e13ffe17 	ldw	r4,-8(fp)
81139c38:	1139c540 	call	81139c54 <OS_FlagUnlink>
    return (sched);
81139c3c:	e0bffc03 	ldbu	r2,-16(fp)
}
81139c40:	e037883a 	mov	sp,fp
81139c44:	dfc00117 	ldw	ra,4(sp)
81139c48:	df000017 	ldw	fp,0(sp)
81139c4c:	dec00204 	addi	sp,sp,8
81139c50:	f800283a 	ret

81139c54 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
81139c54:	defffa04 	addi	sp,sp,-24
81139c58:	de00012e 	bgeu	sp,et,81139c60 <OS_FlagUnlink+0xc>
81139c5c:	003b68fa 	trap	3
81139c60:	df000515 	stw	fp,20(sp)
81139c64:	df000504 	addi	fp,sp,20
81139c68:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
81139c6c:	e0bfff17 	ldw	r2,-4(fp)
81139c70:	10800117 	ldw	r2,4(r2)
81139c74:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81139c78:	e0bfff17 	ldw	r2,-4(fp)
81139c7c:	10800017 	ldw	r2,0(r2)
81139c80:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
81139c84:	e0bffb17 	ldw	r2,-20(fp)
81139c88:	10000b1e 	bne	r2,zero,81139cb8 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
81139c8c:	e0bfff17 	ldw	r2,-4(fp)
81139c90:	10800317 	ldw	r2,12(r2)
81139c94:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81139c98:	e0bffd17 	ldw	r2,-12(fp)
81139c9c:	e0fffc17 	ldw	r3,-16(fp)
81139ca0:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81139ca4:	e0bffc17 	ldw	r2,-16(fp)
81139ca8:	10000b26 	beq	r2,zero,81139cd8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81139cac:	e0bffc17 	ldw	r2,-16(fp)
81139cb0:	10000115 	stw	zero,4(r2)
81139cb4:	00000806 	br	81139cd8 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81139cb8:	e0bffb17 	ldw	r2,-20(fp)
81139cbc:	e0fffc17 	ldw	r3,-16(fp)
81139cc0:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81139cc4:	e0bffc17 	ldw	r2,-16(fp)
81139cc8:	10000326 	beq	r2,zero,81139cd8 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81139ccc:	e0bffc17 	ldw	r2,-16(fp)
81139cd0:	e0fffb17 	ldw	r3,-20(fp)
81139cd4:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81139cd8:	e0bfff17 	ldw	r2,-4(fp)
81139cdc:	10800217 	ldw	r2,8(r2)
81139ce0:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81139ce4:	e0bffe17 	ldw	r2,-8(fp)
81139ce8:	10000a15 	stw	zero,40(r2)
#endif
}
81139cec:	0001883a 	nop
81139cf0:	e037883a 	mov	sp,fp
81139cf4:	df000017 	ldw	fp,0(sp)
81139cf8:	dec00104 	addi	sp,sp,4
81139cfc:	f800283a 	ret

81139d00 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81139d00:	defff404 	addi	sp,sp,-48
81139d04:	de00012e 	bgeu	sp,et,81139d0c <OSMemCreate+0xc>
81139d08:	003b68fa 	trap	3
81139d0c:	df000b15 	stw	fp,44(sp)
81139d10:	df000b04 	addi	fp,sp,44
81139d14:	e13ffc15 	stw	r4,-16(fp)
81139d18:	e17ffd15 	stw	r5,-12(fp)
81139d1c:	e1bffe15 	stw	r6,-8(fp)
81139d20:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139d24:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81139d28:	e0bfff17 	ldw	r2,-4(fp)
81139d2c:	1000021e 	bne	r2,zero,81139d38 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81139d30:	0005883a 	mov	r2,zero
81139d34:	00006506 	br	81139ecc <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81139d38:	e0bffc17 	ldw	r2,-16(fp)
81139d3c:	1000051e 	bne	r2,zero,81139d54 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81139d40:	e0bfff17 	ldw	r2,-4(fp)
81139d44:	00c01884 	movi	r3,98
81139d48:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81139d4c:	0005883a 	mov	r2,zero
81139d50:	00005e06 	br	81139ecc <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
81139d54:	e0bffc17 	ldw	r2,-16(fp)
81139d58:	108000cc 	andi	r2,r2,3
81139d5c:	10000526 	beq	r2,zero,81139d74 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81139d60:	e0bfff17 	ldw	r2,-4(fp)
81139d64:	00c01884 	movi	r3,98
81139d68:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81139d6c:	0005883a 	mov	r2,zero
81139d70:	00005606 	br	81139ecc <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
81139d74:	e0bffd17 	ldw	r2,-12(fp)
81139d78:	108000a8 	cmpgeui	r2,r2,2
81139d7c:	1000051e 	bne	r2,zero,81139d94 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81139d80:	e0bfff17 	ldw	r2,-4(fp)
81139d84:	00c016c4 	movi	r3,91
81139d88:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81139d8c:	0005883a 	mov	r2,zero
81139d90:	00004e06 	br	81139ecc <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
81139d94:	e0bffe17 	ldw	r2,-8(fp)
81139d98:	10800128 	cmpgeui	r2,r2,4
81139d9c:	1000051e 	bne	r2,zero,81139db4 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81139da0:	e0bfff17 	ldw	r2,-4(fp)
81139da4:	00c01704 	movi	r3,92
81139da8:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81139dac:	0005883a 	mov	r2,zero
81139db0:	00004606 	br	81139ecc <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139db4:	0005303a 	rdctl	r2,status
81139db8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139dbc:	e0fffb17 	ldw	r3,-20(fp)
81139dc0:	00bfff84 	movi	r2,-2
81139dc4:	1884703a 	and	r2,r3,r2
81139dc8:	1001703a 	wrctl	status,r2
  
  return context;
81139dcc:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81139dd0:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81139dd4:	d0a09a17 	ldw	r2,-32152(gp)
81139dd8:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81139ddc:	d0a09a17 	ldw	r2,-32152(gp)
81139de0:	10000326 	beq	r2,zero,81139df0 <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81139de4:	d0a09a17 	ldw	r2,-32152(gp)
81139de8:	10800117 	ldw	r2,4(r2)
81139dec:	d0a09a15 	stw	r2,-32152(gp)
81139df0:	e0bff817 	ldw	r2,-32(fp)
81139df4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139df8:	e0bff917 	ldw	r2,-28(fp)
81139dfc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81139e00:	e0bffa17 	ldw	r2,-24(fp)
81139e04:	1000051e 	bne	r2,zero,81139e1c <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81139e08:	e0bfff17 	ldw	r2,-4(fp)
81139e0c:	00c01684 	movi	r3,90
81139e10:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81139e14:	0005883a 	mov	r2,zero
81139e18:	00002c06 	br	81139ecc <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81139e1c:	e0bffc17 	ldw	r2,-16(fp)
81139e20:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81139e24:	e0fffc17 	ldw	r3,-16(fp)
81139e28:	e0bffe17 	ldw	r2,-8(fp)
81139e2c:	1885883a 	add	r2,r3,r2
81139e30:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81139e34:	e03ff715 	stw	zero,-36(fp)
81139e38:	00000c06 	br	81139e6c <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81139e3c:	e0bff617 	ldw	r2,-40(fp)
81139e40:	e0fff517 	ldw	r3,-44(fp)
81139e44:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81139e48:	e0bff517 	ldw	r2,-44(fp)
81139e4c:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81139e50:	e0fff517 	ldw	r3,-44(fp)
81139e54:	e0bffe17 	ldw	r2,-8(fp)
81139e58:	1885883a 	add	r2,r3,r2
81139e5c:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81139e60:	e0bff717 	ldw	r2,-36(fp)
81139e64:	10800044 	addi	r2,r2,1
81139e68:	e0bff715 	stw	r2,-36(fp)
81139e6c:	e0bffd17 	ldw	r2,-12(fp)
81139e70:	10bfffc4 	addi	r2,r2,-1
81139e74:	e0fff717 	ldw	r3,-36(fp)
81139e78:	18bff036 	bltu	r3,r2,81139e3c <__reset+0xfb119e3c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
81139e7c:	e0bff617 	ldw	r2,-40(fp)
81139e80:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81139e84:	e0bffa17 	ldw	r2,-24(fp)
81139e88:	e0fffc17 	ldw	r3,-16(fp)
81139e8c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81139e90:	e0bffa17 	ldw	r2,-24(fp)
81139e94:	e0fffc17 	ldw	r3,-16(fp)
81139e98:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
81139e9c:	e0bffa17 	ldw	r2,-24(fp)
81139ea0:	e0fffd17 	ldw	r3,-12(fp)
81139ea4:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81139ea8:	e0bffa17 	ldw	r2,-24(fp)
81139eac:	e0fffd17 	ldw	r3,-12(fp)
81139eb0:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81139eb4:	e0bffa17 	ldw	r2,-24(fp)
81139eb8:	e0fffe17 	ldw	r3,-8(fp)
81139ebc:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81139ec0:	e0bfff17 	ldw	r2,-4(fp)
81139ec4:	10000005 	stb	zero,0(r2)
    return (pmem);
81139ec8:	e0bffa17 	ldw	r2,-24(fp)
}
81139ecc:	e037883a 	mov	sp,fp
81139ed0:	df000017 	ldw	fp,0(sp)
81139ed4:	dec00104 	addi	sp,sp,4
81139ed8:	f800283a 	ret

81139edc <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81139edc:	defff804 	addi	sp,sp,-32
81139ee0:	de00012e 	bgeu	sp,et,81139ee8 <OSMemGet+0xc>
81139ee4:	003b68fa 	trap	3
81139ee8:	df000715 	stw	fp,28(sp)
81139eec:	df000704 	addi	fp,sp,28
81139ef0:	e13ffe15 	stw	r4,-8(fp)
81139ef4:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139ef8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81139efc:	e0bfff17 	ldw	r2,-4(fp)
81139f00:	1000021e 	bne	r2,zero,81139f0c <OSMemGet+0x30>
        return ((void *)0);
81139f04:	0005883a 	mov	r2,zero
81139f08:	00002e06 	br	81139fc4 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81139f0c:	e0bffe17 	ldw	r2,-8(fp)
81139f10:	1000051e 	bne	r2,zero,81139f28 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81139f14:	e0bfff17 	ldw	r2,-4(fp)
81139f18:	00c01804 	movi	r3,96
81139f1c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139f20:	0005883a 	mov	r2,zero
81139f24:	00002706 	br	81139fc4 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f28:	0005303a 	rdctl	r2,status
81139f2c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f30:	e0fffd17 	ldw	r3,-12(fp)
81139f34:	00bfff84 	movi	r2,-2
81139f38:	1884703a 	and	r2,r3,r2
81139f3c:	1001703a 	wrctl	status,r2
  
  return context;
81139f40:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81139f44:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81139f48:	e0bffe17 	ldw	r2,-8(fp)
81139f4c:	10800417 	ldw	r2,16(r2)
81139f50:	10001426 	beq	r2,zero,81139fa4 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81139f54:	e0bffe17 	ldw	r2,-8(fp)
81139f58:	10800117 	ldw	r2,4(r2)
81139f5c:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81139f60:	e0bffb17 	ldw	r2,-20(fp)
81139f64:	10c00017 	ldw	r3,0(r2)
81139f68:	e0bffe17 	ldw	r2,-8(fp)
81139f6c:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81139f70:	e0bffe17 	ldw	r2,-8(fp)
81139f74:	10800417 	ldw	r2,16(r2)
81139f78:	10ffffc4 	addi	r3,r2,-1
81139f7c:	e0bffe17 	ldw	r2,-8(fp)
81139f80:	10c00415 	stw	r3,16(r2)
81139f84:	e0bff917 	ldw	r2,-28(fp)
81139f88:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139f8c:	e0bffa17 	ldw	r2,-24(fp)
81139f90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81139f94:	e0bfff17 	ldw	r2,-4(fp)
81139f98:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
81139f9c:	e0bffb17 	ldw	r2,-20(fp)
81139fa0:	00000806 	br	81139fc4 <OSMemGet+0xe8>
81139fa4:	e0bff917 	ldw	r2,-28(fp)
81139fa8:	e0bffc15 	stw	r2,-16(fp)
81139fac:	e0bffc17 	ldw	r2,-16(fp)
81139fb0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81139fb4:	e0bfff17 	ldw	r2,-4(fp)
81139fb8:	00c01744 	movi	r3,93
81139fbc:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81139fc0:	0005883a 	mov	r2,zero
}
81139fc4:	e037883a 	mov	sp,fp
81139fc8:	df000017 	ldw	fp,0(sp)
81139fcc:	dec00104 	addi	sp,sp,4
81139fd0:	f800283a 	ret

81139fd4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81139fd4:	defff704 	addi	sp,sp,-36
81139fd8:	de00012e 	bgeu	sp,et,81139fe0 <OSMemNameGet+0xc>
81139fdc:	003b68fa 	trap	3
81139fe0:	dfc00815 	stw	ra,32(sp)
81139fe4:	df000715 	stw	fp,28(sp)
81139fe8:	df000704 	addi	fp,sp,28
81139fec:	e13ffd15 	stw	r4,-12(fp)
81139ff0:	e17ffe15 	stw	r5,-8(fp)
81139ff4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139ff8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81139ffc:	e0bfff17 	ldw	r2,-4(fp)
8113a000:	1000021e 	bne	r2,zero,8113a00c <OSMemNameGet+0x38>
        return (0);
8113a004:	0005883a 	mov	r2,zero
8113a008:	00002b06 	br	8113a0b8 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113a00c:	e0bffd17 	ldw	r2,-12(fp)
8113a010:	1000051e 	bne	r2,zero,8113a028 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113a014:	e0bfff17 	ldw	r2,-4(fp)
8113a018:	00c01804 	movi	r3,96
8113a01c:	10c00005 	stb	r3,0(r2)
        return (0);
8113a020:	0005883a 	mov	r2,zero
8113a024:	00002406 	br	8113a0b8 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a028:	e0bffe17 	ldw	r2,-8(fp)
8113a02c:	1000051e 	bne	r2,zero,8113a044 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113a030:	e0bfff17 	ldw	r2,-4(fp)
8113a034:	00c00304 	movi	r3,12
8113a038:	10c00005 	stb	r3,0(r2)
        return (0);
8113a03c:	0005883a 	mov	r2,zero
8113a040:	00001d06 	br	8113a0b8 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a044:	d0a0a003 	ldbu	r2,-32128(gp)
8113a048:	10803fcc 	andi	r2,r2,255
8113a04c:	10000526 	beq	r2,zero,8113a064 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113a050:	e0bfff17 	ldw	r2,-4(fp)
8113a054:	00c00444 	movi	r3,17
8113a058:	10c00005 	stb	r3,0(r2)
        return (0);
8113a05c:	0005883a 	mov	r2,zero
8113a060:	00001506 	br	8113a0b8 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a064:	0005303a 	rdctl	r2,status
8113a068:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a06c:	e0fffb17 	ldw	r3,-20(fp)
8113a070:	00bfff84 	movi	r2,-2
8113a074:	1884703a 	and	r2,r3,r2
8113a078:	1001703a 	wrctl	status,r2
  
  return context;
8113a07c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113a080:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
8113a084:	e0bffd17 	ldw	r2,-12(fp)
8113a088:	10800504 	addi	r2,r2,20
8113a08c:	100b883a 	mov	r5,r2
8113a090:	e13ffe17 	ldw	r4,-8(fp)
8113a094:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113a098:	e0bffa05 	stb	r2,-24(fp)
8113a09c:	e0bff917 	ldw	r2,-28(fp)
8113a0a0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0a4:	e0bffc17 	ldw	r2,-16(fp)
8113a0a8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a0ac:	e0bfff17 	ldw	r2,-4(fp)
8113a0b0:	10000005 	stb	zero,0(r2)
    return (len);
8113a0b4:	e0bffa03 	ldbu	r2,-24(fp)
}
8113a0b8:	e037883a 	mov	sp,fp
8113a0bc:	dfc00117 	ldw	ra,4(sp)
8113a0c0:	df000017 	ldw	fp,0(sp)
8113a0c4:	dec00204 	addi	sp,sp,8
8113a0c8:	f800283a 	ret

8113a0cc <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
8113a0cc:	defff604 	addi	sp,sp,-40
8113a0d0:	de00012e 	bgeu	sp,et,8113a0d8 <OSMemNameSet+0xc>
8113a0d4:	003b68fa 	trap	3
8113a0d8:	dfc00915 	stw	ra,36(sp)
8113a0dc:	df000815 	stw	fp,32(sp)
8113a0e0:	df000804 	addi	fp,sp,32
8113a0e4:	e13ffd15 	stw	r4,-12(fp)
8113a0e8:	e17ffe15 	stw	r5,-8(fp)
8113a0ec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a0f0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113a0f4:	e0bfff17 	ldw	r2,-4(fp)
8113a0f8:	10003526 	beq	r2,zero,8113a1d0 <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
8113a0fc:	e0bffd17 	ldw	r2,-12(fp)
8113a100:	1000041e 	bne	r2,zero,8113a114 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
8113a104:	e0bfff17 	ldw	r2,-4(fp)
8113a108:	00c01804 	movi	r3,96
8113a10c:	10c00005 	stb	r3,0(r2)
        return;
8113a110:	00003006 	br	8113a1d4 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113a114:	e0bffe17 	ldw	r2,-8(fp)
8113a118:	1000041e 	bne	r2,zero,8113a12c <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
8113a11c:	e0bfff17 	ldw	r2,-4(fp)
8113a120:	00c00304 	movi	r3,12
8113a124:	10c00005 	stb	r3,0(r2)
        return;
8113a128:	00002a06 	br	8113a1d4 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113a12c:	d0a0a003 	ldbu	r2,-32128(gp)
8113a130:	10803fcc 	andi	r2,r2,255
8113a134:	10000426 	beq	r2,zero,8113a148 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
8113a138:	e0bfff17 	ldw	r2,-4(fp)
8113a13c:	00c00484 	movi	r3,18
8113a140:	10c00005 	stb	r3,0(r2)
        return;
8113a144:	00002306 	br	8113a1d4 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a148:	0005303a 	rdctl	r2,status
8113a14c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a150:	e0fffc17 	ldw	r3,-16(fp)
8113a154:	00bfff84 	movi	r2,-2
8113a158:	1884703a 	and	r2,r3,r2
8113a15c:	1001703a 	wrctl	status,r2
  
  return context;
8113a160:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a164:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
8113a168:	e13ffe17 	ldw	r4,-8(fp)
8113a16c:	1137e380 	call	81137e38 <OS_StrLen>
8113a170:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
8113a174:	e0bffa03 	ldbu	r2,-24(fp)
8113a178:	10800830 	cmpltui	r2,r2,32
8113a17c:	1000081e 	bne	r2,zero,8113a1a0 <OSMemNameSet+0xd4>
8113a180:	e0bff817 	ldw	r2,-32(fp)
8113a184:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a188:	e0bff917 	ldw	r2,-28(fp)
8113a18c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113a190:	e0bfff17 	ldw	r2,-4(fp)
8113a194:	00c018c4 	movi	r3,99
8113a198:	10c00005 	stb	r3,0(r2)
        return;
8113a19c:	00000d06 	br	8113a1d4 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113a1a0:	e0bffd17 	ldw	r2,-12(fp)
8113a1a4:	10800504 	addi	r2,r2,20
8113a1a8:	e17ffe17 	ldw	r5,-8(fp)
8113a1ac:	1009883a 	mov	r4,r2
8113a1b0:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113a1b4:	e0bff817 	ldw	r2,-32(fp)
8113a1b8:	e0bffb15 	stw	r2,-20(fp)
8113a1bc:	e0bffb17 	ldw	r2,-20(fp)
8113a1c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a1c4:	e0bfff17 	ldw	r2,-4(fp)
8113a1c8:	10000005 	stb	zero,0(r2)
8113a1cc:	00000106 	br	8113a1d4 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
8113a1d0:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113a1d4:	e037883a 	mov	sp,fp
8113a1d8:	dfc00117 	ldw	ra,4(sp)
8113a1dc:	df000017 	ldw	fp,0(sp)
8113a1e0:	dec00204 	addi	sp,sp,8
8113a1e4:	f800283a 	ret

8113a1e8 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
8113a1e8:	defff904 	addi	sp,sp,-28
8113a1ec:	de00012e 	bgeu	sp,et,8113a1f4 <OSMemPut+0xc>
8113a1f0:	003b68fa 	trap	3
8113a1f4:	df000615 	stw	fp,24(sp)
8113a1f8:	df000604 	addi	fp,sp,24
8113a1fc:	e13ffe15 	stw	r4,-8(fp)
8113a200:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a204:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113a208:	e0bffe17 	ldw	r2,-8(fp)
8113a20c:	1000021e 	bne	r2,zero,8113a218 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113a210:	00801804 	movi	r2,96
8113a214:	00002806 	br	8113a2b8 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
8113a218:	e0bfff17 	ldw	r2,-4(fp)
8113a21c:	1000021e 	bne	r2,zero,8113a228 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
8113a220:	008017c4 	movi	r2,95
8113a224:	00002406 	br	8113a2b8 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a228:	0005303a 	rdctl	r2,status
8113a22c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a230:	e0fffd17 	ldw	r3,-12(fp)
8113a234:	00bfff84 	movi	r2,-2
8113a238:	1884703a 	and	r2,r3,r2
8113a23c:	1001703a 	wrctl	status,r2
  
  return context;
8113a240:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a244:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
8113a248:	e0bffe17 	ldw	r2,-8(fp)
8113a24c:	10c00417 	ldw	r3,16(r2)
8113a250:	e0bffe17 	ldw	r2,-8(fp)
8113a254:	10800317 	ldw	r2,12(r2)
8113a258:	18800636 	bltu	r3,r2,8113a274 <OSMemPut+0x8c>
8113a25c:	e0bffa17 	ldw	r2,-24(fp)
8113a260:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a264:	e0bffb17 	ldw	r2,-20(fp)
8113a268:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
8113a26c:	00801784 	movi	r2,94
8113a270:	00001106 	br	8113a2b8 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
8113a274:	e0bffe17 	ldw	r2,-8(fp)
8113a278:	10c00117 	ldw	r3,4(r2)
8113a27c:	e0bfff17 	ldw	r2,-4(fp)
8113a280:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
8113a284:	e0bffe17 	ldw	r2,-8(fp)
8113a288:	e0ffff17 	ldw	r3,-4(fp)
8113a28c:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113a290:	e0bffe17 	ldw	r2,-8(fp)
8113a294:	10800417 	ldw	r2,16(r2)
8113a298:	10c00044 	addi	r3,r2,1
8113a29c:	e0bffe17 	ldw	r2,-8(fp)
8113a2a0:	10c00415 	stw	r3,16(r2)
8113a2a4:	e0bffa17 	ldw	r2,-24(fp)
8113a2a8:	e0bffc15 	stw	r2,-16(fp)
8113a2ac:	e0bffc17 	ldw	r2,-16(fp)
8113a2b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
8113a2b4:	0005883a 	mov	r2,zero
}
8113a2b8:	e037883a 	mov	sp,fp
8113a2bc:	df000017 	ldw	fp,0(sp)
8113a2c0:	dec00104 	addi	sp,sp,4
8113a2c4:	f800283a 	ret

8113a2c8 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
8113a2c8:	defffa04 	addi	sp,sp,-24
8113a2cc:	de00012e 	bgeu	sp,et,8113a2d4 <OSMemQuery+0xc>
8113a2d0:	003b68fa 	trap	3
8113a2d4:	df000515 	stw	fp,20(sp)
8113a2d8:	df000504 	addi	fp,sp,20
8113a2dc:	e13ffe15 	stw	r4,-8(fp)
8113a2e0:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113a2e4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
8113a2e8:	e0bffe17 	ldw	r2,-8(fp)
8113a2ec:	1000021e 	bne	r2,zero,8113a2f8 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
8113a2f0:	00801804 	movi	r2,96
8113a2f4:	00002c06 	br	8113a3a8 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
8113a2f8:	e0bfff17 	ldw	r2,-4(fp)
8113a2fc:	1000021e 	bne	r2,zero,8113a308 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
8113a300:	00801844 	movi	r2,97
8113a304:	00002806 	br	8113a3a8 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a308:	0005303a 	rdctl	r2,status
8113a30c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a310:	e0fffc17 	ldw	r3,-16(fp)
8113a314:	00bfff84 	movi	r2,-2
8113a318:	1884703a 	and	r2,r3,r2
8113a31c:	1001703a 	wrctl	status,r2
  
  return context;
8113a320:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113a324:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
8113a328:	e0bffe17 	ldw	r2,-8(fp)
8113a32c:	10c00017 	ldw	r3,0(r2)
8113a330:	e0bfff17 	ldw	r2,-4(fp)
8113a334:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
8113a338:	e0bffe17 	ldw	r2,-8(fp)
8113a33c:	10c00117 	ldw	r3,4(r2)
8113a340:	e0bfff17 	ldw	r2,-4(fp)
8113a344:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
8113a348:	e0bffe17 	ldw	r2,-8(fp)
8113a34c:	10c00217 	ldw	r3,8(r2)
8113a350:	e0bfff17 	ldw	r2,-4(fp)
8113a354:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
8113a358:	e0bffe17 	ldw	r2,-8(fp)
8113a35c:	10c00317 	ldw	r3,12(r2)
8113a360:	e0bfff17 	ldw	r2,-4(fp)
8113a364:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
8113a368:	e0bffe17 	ldw	r2,-8(fp)
8113a36c:	10c00417 	ldw	r3,16(r2)
8113a370:	e0bfff17 	ldw	r2,-4(fp)
8113a374:	10c00415 	stw	r3,16(r2)
8113a378:	e0bffb17 	ldw	r2,-20(fp)
8113a37c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a380:	e0bffd17 	ldw	r2,-12(fp)
8113a384:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
8113a388:	e0bfff17 	ldw	r2,-4(fp)
8113a38c:	10c00317 	ldw	r3,12(r2)
8113a390:	e0bfff17 	ldw	r2,-4(fp)
8113a394:	10800417 	ldw	r2,16(r2)
8113a398:	1887c83a 	sub	r3,r3,r2
8113a39c:	e0bfff17 	ldw	r2,-4(fp)
8113a3a0:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
8113a3a4:	0005883a 	mov	r2,zero
}
8113a3a8:	e037883a 	mov	sp,fp
8113a3ac:	df000017 	ldw	fp,0(sp)
8113a3b0:	dec00104 	addi	sp,sp,4
8113a3b4:	f800283a 	ret

8113a3b8 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
8113a3b8:	defffc04 	addi	sp,sp,-16
8113a3bc:	de00012e 	bgeu	sp,et,8113a3c4 <OS_MemInit+0xc>
8113a3c0:	003b68fa 	trap	3
8113a3c4:	dfc00315 	stw	ra,12(sp)
8113a3c8:	df000215 	stw	fp,8(sp)
8113a3cc:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
8113a3d0:	01430c04 	movi	r5,3120
8113a3d4:	012045b4 	movhi	r4,33046
8113a3d8:	21145604 	addi	r4,r4,20824
8113a3dc:	1137b9c0 	call	81137b9c <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
8113a3e0:	00a045b4 	movhi	r2,33046
8113a3e4:	10945604 	addi	r2,r2,20824
8113a3e8:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113a3ec:	e03fff0d 	sth	zero,-4(fp)
8113a3f0:	00001306 	br	8113a440 <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
8113a3f4:	e0bfff0b 	ldhu	r2,-4(fp)
8113a3f8:	10800044 	addi	r2,r2,1
8113a3fc:	10c00d24 	muli	r3,r2,52
8113a400:	00a045b4 	movhi	r2,33046
8113a404:	10945604 	addi	r2,r2,20824
8113a408:	1887883a 	add	r3,r3,r2
8113a40c:	e0bffe17 	ldw	r2,-8(fp)
8113a410:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
8113a414:	e0bffe17 	ldw	r2,-8(fp)
8113a418:	00c00fc4 	movi	r3,63
8113a41c:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
8113a420:	e0bffe17 	ldw	r2,-8(fp)
8113a424:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
8113a428:	e0bffe17 	ldw	r2,-8(fp)
8113a42c:	10800d04 	addi	r2,r2,52
8113a430:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
8113a434:	e0bfff0b 	ldhu	r2,-4(fp)
8113a438:	10800044 	addi	r2,r2,1
8113a43c:	e0bfff0d 	sth	r2,-4(fp)
8113a440:	e0bfff0b 	ldhu	r2,-4(fp)
8113a444:	10800ef0 	cmpltui	r2,r2,59
8113a448:	103fea1e 	bne	r2,zero,8113a3f4 <__reset+0xfb11a3f4>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
8113a44c:	e0bffe17 	ldw	r2,-8(fp)
8113a450:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
8113a454:	e0bffe17 	ldw	r2,-8(fp)
8113a458:	00c00fc4 	movi	r3,63
8113a45c:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113a460:	e0bffe17 	ldw	r2,-8(fp)
8113a464:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
8113a468:	00a045b4 	movhi	r2,33046
8113a46c:	10945604 	addi	r2,r2,20824
8113a470:	d0a09a15 	stw	r2,-32152(gp)
#endif
}
8113a474:	0001883a 	nop
8113a478:	e037883a 	mov	sp,fp
8113a47c:	dfc00117 	ldw	ra,4(sp)
8113a480:	df000017 	ldw	fp,0(sp)
8113a484:	dec00204 	addi	sp,sp,8
8113a488:	f800283a 	ret

8113a48c <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
8113a48c:	defff704 	addi	sp,sp,-36
8113a490:	de00012e 	bgeu	sp,et,8113a498 <OSMutexAccept+0xc>
8113a494:	003b68fa 	trap	3
8113a498:	df000815 	stw	fp,32(sp)
8113a49c:	df000804 	addi	fp,sp,32
8113a4a0:	e13ffe15 	stw	r4,-8(fp)
8113a4a4:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113a4a8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
8113a4ac:	e0bfff17 	ldw	r2,-4(fp)
8113a4b0:	1000021e 	bne	r2,zero,8113a4bc <OSMutexAccept+0x30>
        return (OS_FALSE);
8113a4b4:	0005883a 	mov	r2,zero
8113a4b8:	00005b06 	br	8113a628 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113a4bc:	e0bffe17 	ldw	r2,-8(fp)
8113a4c0:	1000051e 	bne	r2,zero,8113a4d8 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113a4c4:	e0bfff17 	ldw	r2,-4(fp)
8113a4c8:	00c00104 	movi	r3,4
8113a4cc:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a4d0:	0005883a 	mov	r2,zero
8113a4d4:	00005406 	br	8113a628 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
8113a4d8:	e0bffe17 	ldw	r2,-8(fp)
8113a4dc:	10800003 	ldbu	r2,0(r2)
8113a4e0:	10803fcc 	andi	r2,r2,255
8113a4e4:	10800120 	cmpeqi	r2,r2,4
8113a4e8:	1000051e 	bne	r2,zero,8113a500 <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113a4ec:	e0bfff17 	ldw	r2,-4(fp)
8113a4f0:	00c00044 	movi	r3,1
8113a4f4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a4f8:	0005883a 	mov	r2,zero
8113a4fc:	00004a06 	br	8113a628 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
8113a500:	d0a0a003 	ldbu	r2,-32128(gp)
8113a504:	10803fcc 	andi	r2,r2,255
8113a508:	10000526 	beq	r2,zero,8113a520 <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
8113a50c:	e0bfff17 	ldw	r2,-4(fp)
8113a510:	00c00084 	movi	r3,2
8113a514:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113a518:	0005883a 	mov	r2,zero
8113a51c:	00004206 	br	8113a628 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a520:	0005303a 	rdctl	r2,status
8113a524:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a528:	e0fffd17 	ldw	r3,-12(fp)
8113a52c:	00bfff84 	movi	r2,-2
8113a530:	1884703a 	and	r2,r3,r2
8113a534:	1001703a 	wrctl	status,r2
  
  return context;
8113a538:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
8113a53c:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113a540:	e0bffe17 	ldw	r2,-8(fp)
8113a544:	1080020b 	ldhu	r2,8(r2)
8113a548:	10bfffcc 	andi	r2,r2,65535
8113a54c:	1004d23a 	srli	r2,r2,8
8113a550:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113a554:	e0bffe17 	ldw	r2,-8(fp)
8113a558:	1080020b 	ldhu	r2,8(r2)
8113a55c:	10bfffcc 	andi	r2,r2,65535
8113a560:	10803fcc 	andi	r2,r2,255
8113a564:	10803fd8 	cmpnei	r2,r2,255
8113a568:	1000281e 	bne	r2,zero,8113a60c <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
8113a56c:	e0bffe17 	ldw	r2,-8(fp)
8113a570:	10c0020b 	ldhu	r3,8(r2)
8113a574:	00bfc004 	movi	r2,-256
8113a578:	1884703a 	and	r2,r3,r2
8113a57c:	1007883a 	mov	r3,r2
8113a580:	e0bffe17 	ldw	r2,-8(fp)
8113a584:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
8113a588:	e0bffe17 	ldw	r2,-8(fp)
8113a58c:	10c0020b 	ldhu	r3,8(r2)
8113a590:	d0a0a117 	ldw	r2,-32124(gp)
8113a594:	10800c83 	ldbu	r2,50(r2)
8113a598:	10803fcc 	andi	r2,r2,255
8113a59c:	1884b03a 	or	r2,r3,r2
8113a5a0:	1007883a 	mov	r3,r2
8113a5a4:	e0bffe17 	ldw	r2,-8(fp)
8113a5a8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
8113a5ac:	d0e0a117 	ldw	r3,-32124(gp)
8113a5b0:	e0bffe17 	ldw	r2,-8(fp)
8113a5b4:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
8113a5b8:	d0a0a117 	ldw	r2,-32124(gp)
8113a5bc:	10800c83 	ldbu	r2,50(r2)
8113a5c0:	10803fcc 	andi	r2,r2,255
8113a5c4:	e0fffa03 	ldbu	r3,-24(fp)
8113a5c8:	18800836 	bltu	r3,r2,8113a5ec <OSMutexAccept+0x160>
8113a5cc:	e0bff817 	ldw	r2,-32(fp)
8113a5d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a5d4:	e0bff917 	ldw	r2,-28(fp)
8113a5d8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
8113a5dc:	e0bfff17 	ldw	r2,-4(fp)
8113a5e0:	00c01e04 	movi	r3,120
8113a5e4:	10c00005 	stb	r3,0(r2)
8113a5e8:	00000606 	br	8113a604 <OSMutexAccept+0x178>
8113a5ec:	e0bff817 	ldw	r2,-32(fp)
8113a5f0:	e0bffb15 	stw	r2,-20(fp)
8113a5f4:	e0bffb17 	ldw	r2,-20(fp)
8113a5f8:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113a5fc:	e0bfff17 	ldw	r2,-4(fp)
8113a600:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
8113a604:	00800044 	movi	r2,1
8113a608:	00000706 	br	8113a628 <OSMutexAccept+0x19c>
8113a60c:	e0bff817 	ldw	r2,-32(fp)
8113a610:	e0bffc15 	stw	r2,-16(fp)
8113a614:	e0bffc17 	ldw	r2,-16(fp)
8113a618:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113a61c:	e0bfff17 	ldw	r2,-4(fp)
8113a620:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
8113a624:	0005883a 	mov	r2,zero
}
8113a628:	e037883a 	mov	sp,fp
8113a62c:	df000017 	ldw	fp,0(sp)
8113a630:	dec00104 	addi	sp,sp,4
8113a634:	f800283a 	ret

8113a638 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
8113a638:	defff604 	addi	sp,sp,-40
8113a63c:	de00012e 	bgeu	sp,et,8113a644 <OSMutexCreate+0xc>
8113a640:	003b68fa 	trap	3
8113a644:	dfc00915 	stw	ra,36(sp)
8113a648:	df000815 	stw	fp,32(sp)
8113a64c:	df000804 	addi	fp,sp,32
8113a650:	2005883a 	mov	r2,r4
8113a654:	e17fff15 	stw	r5,-4(fp)
8113a658:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a65c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a660:	e0bfff17 	ldw	r2,-4(fp)
8113a664:	1000021e 	bne	r2,zero,8113a670 <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
8113a668:	0005883a 	mov	r2,zero
8113a66c:	00006106 	br	8113a7f4 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113a670:	e0bffe03 	ldbu	r2,-8(fp)
8113a674:	10800ab0 	cmpltui	r2,r2,42
8113a678:	1000051e 	bne	r2,zero,8113a690 <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
8113a67c:	e0bfff17 	ldw	r2,-4(fp)
8113a680:	00c00a84 	movi	r3,42
8113a684:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113a688:	0005883a 	mov	r2,zero
8113a68c:	00005906 	br	8113a7f4 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a690:	d0a0a003 	ldbu	r2,-32128(gp)
8113a694:	10803fcc 	andi	r2,r2,255
8113a698:	10000526 	beq	r2,zero,8113a6b0 <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
8113a69c:	e0bfff17 	ldw	r2,-4(fp)
8113a6a0:	00c00404 	movi	r3,16
8113a6a4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113a6a8:	0005883a 	mov	r2,zero
8113a6ac:	00005106 	br	8113a7f4 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a6b0:	0005303a 	rdctl	r2,status
8113a6b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a6b8:	e0fffd17 	ldw	r3,-12(fp)
8113a6bc:	00bfff84 	movi	r2,-2
8113a6c0:	1884703a 	and	r2,r3,r2
8113a6c4:	1001703a 	wrctl	status,r2
  
  return context;
8113a6c8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a6cc:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
8113a6d0:	e0fffe03 	ldbu	r3,-8(fp)
8113a6d4:	00a045f4 	movhi	r2,33047
8113a6d8:	10a9d004 	addi	r2,r2,-22720
8113a6dc:	18c7883a 	add	r3,r3,r3
8113a6e0:	18c7883a 	add	r3,r3,r3
8113a6e4:	10c5883a 	add	r2,r2,r3
8113a6e8:	10800017 	ldw	r2,0(r2)
8113a6ec:	10000926 	beq	r2,zero,8113a714 <OSMutexCreate+0xdc>
8113a6f0:	e0bff817 	ldw	r2,-32(fp)
8113a6f4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a6f8:	e0bff917 	ldw	r2,-28(fp)
8113a6fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
8113a700:	e0bfff17 	ldw	r2,-4(fp)
8113a704:	00c00a04 	movi	r3,40
8113a708:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
8113a70c:	0005883a 	mov	r2,zero
8113a710:	00003806 	br	8113a7f4 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
8113a714:	e0fffe03 	ldbu	r3,-8(fp)
8113a718:	00a045f4 	movhi	r2,33047
8113a71c:	10a9d004 	addi	r2,r2,-22720
8113a720:	18c7883a 	add	r3,r3,r3
8113a724:	18c7883a 	add	r3,r3,r3
8113a728:	10c5883a 	add	r2,r2,r3
8113a72c:	00c00044 	movi	r3,1
8113a730:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
8113a734:	d0a09f17 	ldw	r2,-32132(gp)
8113a738:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
8113a73c:	e0bffb17 	ldw	r2,-20(fp)
8113a740:	1000101e 	bne	r2,zero,8113a784 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
8113a744:	e0fffe03 	ldbu	r3,-8(fp)
8113a748:	00a045f4 	movhi	r2,33047
8113a74c:	10a9d004 	addi	r2,r2,-22720
8113a750:	18c7883a 	add	r3,r3,r3
8113a754:	18c7883a 	add	r3,r3,r3
8113a758:	10c5883a 	add	r2,r2,r3
8113a75c:	10000015 	stw	zero,0(r2)
8113a760:	e0bff817 	ldw	r2,-32(fp)
8113a764:	e0bffa15 	stw	r2,-24(fp)
8113a768:	e0bffa17 	ldw	r2,-24(fp)
8113a76c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113a770:	e0bfff17 	ldw	r2,-4(fp)
8113a774:	00c00104 	movi	r3,4
8113a778:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a77c:	e0bffb17 	ldw	r2,-20(fp)
8113a780:	00001c06 	br	8113a7f4 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
8113a784:	d0a09f17 	ldw	r2,-32132(gp)
8113a788:	10800117 	ldw	r2,4(r2)
8113a78c:	d0a09f15 	stw	r2,-32132(gp)
8113a790:	e0bff817 	ldw	r2,-32(fp)
8113a794:	e0bffc15 	stw	r2,-16(fp)
8113a798:	e0bffc17 	ldw	r2,-16(fp)
8113a79c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113a7a0:	e0bffb17 	ldw	r2,-20(fp)
8113a7a4:	00c00104 	movi	r3,4
8113a7a8:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
8113a7ac:	e0bffe03 	ldbu	r2,-8(fp)
8113a7b0:	1004923a 	slli	r2,r2,8
8113a7b4:	10803fd4 	ori	r2,r2,255
8113a7b8:	1007883a 	mov	r3,r2
8113a7bc:	e0bffb17 	ldw	r2,-20(fp)
8113a7c0:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
8113a7c4:	e0bffb17 	ldw	r2,-20(fp)
8113a7c8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
8113a7cc:	e0bffb17 	ldw	r2,-20(fp)
8113a7d0:	00c00fc4 	movi	r3,63
8113a7d4:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
8113a7d8:	e0bffb17 	ldw	r2,-20(fp)
8113a7dc:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
8113a7e0:	e13ffb17 	ldw	r4,-20(fp)
8113a7e4:	11377840 	call	81137784 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
8113a7e8:	e0bfff17 	ldw	r2,-4(fp)
8113a7ec:	10000005 	stb	zero,0(r2)
    return (pevent);
8113a7f0:	e0bffb17 	ldw	r2,-20(fp)
}
8113a7f4:	e037883a 	mov	sp,fp
8113a7f8:	dfc00117 	ldw	ra,4(sp)
8113a7fc:	df000017 	ldw	fp,0(sp)
8113a800:	dec00204 	addi	sp,sp,8
8113a804:	f800283a 	ret

8113a808 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113a808:	defff004 	addi	sp,sp,-64
8113a80c:	de00012e 	bgeu	sp,et,8113a814 <OSMutexDel+0xc>
8113a810:	003b68fa 	trap	3
8113a814:	dfc00f15 	stw	ra,60(sp)
8113a818:	df000e15 	stw	fp,56(sp)
8113a81c:	df000e04 	addi	fp,sp,56
8113a820:	e13ffd15 	stw	r4,-12(fp)
8113a824:	2805883a 	mov	r2,r5
8113a828:	e1bfff15 	stw	r6,-4(fp)
8113a82c:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a830:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a834:	e0bfff17 	ldw	r2,-4(fp)
8113a838:	1000021e 	bne	r2,zero,8113a844 <OSMutexDel+0x3c>
        return (pevent);
8113a83c:	e0bffd17 	ldw	r2,-12(fp)
8113a840:	0000ad06 	br	8113aaf8 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113a844:	e0bffd17 	ldw	r2,-12(fp)
8113a848:	1000051e 	bne	r2,zero,8113a860 <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113a84c:	e0bfff17 	ldw	r2,-4(fp)
8113a850:	00c00104 	movi	r3,4
8113a854:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a858:	e0bffd17 	ldw	r2,-12(fp)
8113a85c:	0000a606 	br	8113aaf8 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113a860:	e0bffd17 	ldw	r2,-12(fp)
8113a864:	10800003 	ldbu	r2,0(r2)
8113a868:	10803fcc 	andi	r2,r2,255
8113a86c:	10800120 	cmpeqi	r2,r2,4
8113a870:	1000051e 	bne	r2,zero,8113a888 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113a874:	e0bfff17 	ldw	r2,-4(fp)
8113a878:	00c00044 	movi	r3,1
8113a87c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a880:	e0bffd17 	ldw	r2,-12(fp)
8113a884:	00009c06 	br	8113aaf8 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a888:	d0a0a003 	ldbu	r2,-32128(gp)
8113a88c:	10803fcc 	andi	r2,r2,255
8113a890:	10000526 	beq	r2,zero,8113a8a8 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113a894:	e0bfff17 	ldw	r2,-4(fp)
8113a898:	00c003c4 	movi	r3,15
8113a89c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a8a0:	e0bffd17 	ldw	r2,-12(fp)
8113a8a4:	00009406 	br	8113aaf8 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a8a8:	0005303a 	rdctl	r2,status
8113a8ac:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a8b0:	e0fffc17 	ldw	r3,-16(fp)
8113a8b4:	00bfff84 	movi	r2,-2
8113a8b8:	1884703a 	and	r2,r3,r2
8113a8bc:	1001703a 	wrctl	status,r2
  
  return context;
8113a8c0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a8c4:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
8113a8c8:	e0bffd17 	ldw	r2,-12(fp)
8113a8cc:	10800283 	ldbu	r2,10(r2)
8113a8d0:	10803fcc 	andi	r2,r2,255
8113a8d4:	10000326 	beq	r2,zero,8113a8e4 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113a8d8:	00800044 	movi	r2,1
8113a8dc:	e0bff205 	stb	r2,-56(fp)
8113a8e0:	00000106 	br	8113a8e8 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113a8e4:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
8113a8e8:	e0bffe03 	ldbu	r2,-8(fp)
8113a8ec:	10000326 	beq	r2,zero,8113a8fc <OSMutexDel+0xf4>
8113a8f0:	10800060 	cmpeqi	r2,r2,1
8113a8f4:	10002f1e 	bne	r2,zero,8113a9b4 <OSMutexDel+0x1ac>
8113a8f8:	00007406 	br	8113aacc <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
8113a8fc:	e0bff203 	ldbu	r2,-56(fp)
8113a900:	1000221e 	bne	r2,zero,8113a98c <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113a904:	e0bffd17 	ldw	r2,-12(fp)
8113a908:	00c00fc4 	movi	r3,63
8113a90c:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113a910:	e0bffd17 	ldw	r2,-12(fp)
8113a914:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113a918:	e0bffd17 	ldw	r2,-12(fp)
8113a91c:	1080020b 	ldhu	r2,8(r2)
8113a920:	10bfffcc 	andi	r2,r2,65535
8113a924:	1004d23a 	srli	r2,r2,8
8113a928:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
8113a92c:	e0fff603 	ldbu	r3,-40(fp)
8113a930:	00a045f4 	movhi	r2,33047
8113a934:	10a9d004 	addi	r2,r2,-22720
8113a938:	18c7883a 	add	r3,r3,r3
8113a93c:	18c7883a 	add	r3,r3,r3
8113a940:	10c5883a 	add	r2,r2,r3
8113a944:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113a948:	e0bffd17 	ldw	r2,-12(fp)
8113a94c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113a950:	d0e09f17 	ldw	r3,-32132(gp)
8113a954:	e0bffd17 	ldw	r2,-12(fp)
8113a958:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
8113a95c:	e0bffd17 	ldw	r2,-12(fp)
8113a960:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
8113a964:	e0bffd17 	ldw	r2,-12(fp)
8113a968:	d0a09f15 	stw	r2,-32132(gp)
8113a96c:	e0bff417 	ldw	r2,-48(fp)
8113a970:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a974:	e0bff517 	ldw	r2,-44(fp)
8113a978:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
8113a97c:	e0bfff17 	ldw	r2,-4(fp)
8113a980:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
8113a984:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
8113a988:	00005a06 	br	8113aaf4 <OSMutexDel+0x2ec>
8113a98c:	e0bff417 	ldw	r2,-48(fp)
8113a990:	e0bff715 	stw	r2,-36(fp)
8113a994:	e0bff717 	ldw	r2,-36(fp)
8113a998:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
8113a99c:	e0bfff17 	ldw	r2,-4(fp)
8113a9a0:	00c01244 	movi	r3,73
8113a9a4:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
8113a9a8:	e0bffd17 	ldw	r2,-12(fp)
8113a9ac:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113a9b0:	00005006 	br	8113aaf4 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
8113a9b4:	e0bffd17 	ldw	r2,-12(fp)
8113a9b8:	1080020b 	ldhu	r2,8(r2)
8113a9bc:	10bfffcc 	andi	r2,r2,65535
8113a9c0:	1004d23a 	srli	r2,r2,8
8113a9c4:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
8113a9c8:	e0bffd17 	ldw	r2,-12(fp)
8113a9cc:	1080020b 	ldhu	r2,8(r2)
8113a9d0:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
8113a9d4:	e0bffd17 	ldw	r2,-12(fp)
8113a9d8:	10800117 	ldw	r2,4(r2)
8113a9dc:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
8113a9e0:	e0bffa17 	ldw	r2,-24(fp)
8113a9e4:	10000f26 	beq	r2,zero,8113aa24 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
8113a9e8:	e0bffa17 	ldw	r2,-24(fp)
8113a9ec:	10800c83 	ldbu	r2,50(r2)
8113a9f0:	10c03fcc 	andi	r3,r2,255
8113a9f4:	e0bff603 	ldbu	r2,-40(fp)
8113a9f8:	18800a1e 	bne	r3,r2,8113aa24 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
8113a9fc:	e0bff903 	ldbu	r2,-28(fp)
8113aa00:	100b883a 	mov	r5,r2
8113aa04:	e13ffa17 	ldw	r4,-24(fp)
8113aa08:	113b4440 	call	8113b444 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113aa0c:	00000506 	br	8113aa24 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113aa10:	000f883a 	mov	r7,zero
8113aa14:	01800404 	movi	r6,16
8113aa18:	000b883a 	mov	r5,zero
8113aa1c:	e13ffd17 	ldw	r4,-12(fp)
8113aa20:	11371ac0 	call	811371ac <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
8113aa24:	e0bffd17 	ldw	r2,-12(fp)
8113aa28:	10800283 	ldbu	r2,10(r2)
8113aa2c:	10803fcc 	andi	r2,r2,255
8113aa30:	103ff71e 	bne	r2,zero,8113aa10 <__reset+0xfb11aa10>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113aa34:	e0bffd17 	ldw	r2,-12(fp)
8113aa38:	00c00fc4 	movi	r3,63
8113aa3c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113aa40:	e0bffd17 	ldw	r2,-12(fp)
8113aa44:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
8113aa48:	e0bffd17 	ldw	r2,-12(fp)
8113aa4c:	1080020b 	ldhu	r2,8(r2)
8113aa50:	10bfffcc 	andi	r2,r2,65535
8113aa54:	1004d23a 	srli	r2,r2,8
8113aa58:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
8113aa5c:	e0fff603 	ldbu	r3,-40(fp)
8113aa60:	00a045f4 	movhi	r2,33047
8113aa64:	10a9d004 	addi	r2,r2,-22720
8113aa68:	18c7883a 	add	r3,r3,r3
8113aa6c:	18c7883a 	add	r3,r3,r3
8113aa70:	10c5883a 	add	r2,r2,r3
8113aa74:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
8113aa78:	e0bffd17 	ldw	r2,-12(fp)
8113aa7c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
8113aa80:	d0e09f17 	ldw	r3,-32132(gp)
8113aa84:	e0bffd17 	ldw	r2,-12(fp)
8113aa88:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
8113aa8c:	e0bffd17 	ldw	r2,-12(fp)
8113aa90:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
8113aa94:	e0bffd17 	ldw	r2,-12(fp)
8113aa98:	d0a09f15 	stw	r2,-32132(gp)
8113aa9c:	e0bff417 	ldw	r2,-48(fp)
8113aaa0:	e0bff815 	stw	r2,-32(fp)
8113aaa4:	e0bff817 	ldw	r2,-32(fp)
8113aaa8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113aaac:	e0bff203 	ldbu	r2,-56(fp)
8113aab0:	10800058 	cmpnei	r2,r2,1
8113aab4:	1000011e 	bne	r2,zero,8113aabc <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113aab8:	1137c680 	call	81137c68 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
8113aabc:	e0bfff17 	ldw	r2,-4(fp)
8113aac0:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
8113aac4:	e03ff315 	stw	zero,-52(fp)
             break;
8113aac8:	00000a06 	br	8113aaf4 <OSMutexDel+0x2ec>
8113aacc:	e0bff417 	ldw	r2,-48(fp)
8113aad0:	e0bffb15 	stw	r2,-20(fp)
8113aad4:	e0bffb17 	ldw	r2,-20(fp)
8113aad8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
8113aadc:	e0bfff17 	ldw	r2,-4(fp)
8113aae0:	00c001c4 	movi	r3,7
8113aae4:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
8113aae8:	e0bffd17 	ldw	r2,-12(fp)
8113aaec:	e0bff315 	stw	r2,-52(fp)
             break;
8113aaf0:	0001883a 	nop
    }
    return (pevent_return);
8113aaf4:	e0bff317 	ldw	r2,-52(fp)
}
8113aaf8:	e037883a 	mov	sp,fp
8113aafc:	dfc00117 	ldw	ra,4(sp)
8113ab00:	df000017 	ldw	fp,0(sp)
8113ab04:	dec00204 	addi	sp,sp,8
8113ab08:	f800283a 	ret

8113ab0c <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113ab0c:	deffee04 	addi	sp,sp,-72
8113ab10:	de00012e 	bgeu	sp,et,8113ab18 <OSMutexPend+0xc>
8113ab14:	003b68fa 	trap	3
8113ab18:	dfc01115 	stw	ra,68(sp)
8113ab1c:	df001015 	stw	fp,64(sp)
8113ab20:	df001004 	addi	fp,sp,64
8113ab24:	e13ffd15 	stw	r4,-12(fp)
8113ab28:	2805883a 	mov	r2,r5
8113ab2c:	e1bfff15 	stw	r6,-4(fp)
8113ab30:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113ab34:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113ab38:	e0bfff17 	ldw	r2,-4(fp)
8113ab3c:	10015626 	beq	r2,zero,8113b098 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113ab40:	e0bffd17 	ldw	r2,-12(fp)
8113ab44:	1000041e 	bne	r2,zero,8113ab58 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113ab48:	e0bfff17 	ldw	r2,-4(fp)
8113ab4c:	00c00104 	movi	r3,4
8113ab50:	10c00005 	stb	r3,0(r2)
        return;
8113ab54:	00015106 	br	8113b09c <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113ab58:	e0bffd17 	ldw	r2,-12(fp)
8113ab5c:	10800003 	ldbu	r2,0(r2)
8113ab60:	10803fcc 	andi	r2,r2,255
8113ab64:	10800120 	cmpeqi	r2,r2,4
8113ab68:	1000041e 	bne	r2,zero,8113ab7c <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113ab6c:	e0bfff17 	ldw	r2,-4(fp)
8113ab70:	00c00044 	movi	r3,1
8113ab74:	10c00005 	stb	r3,0(r2)
        return;
8113ab78:	00014806 	br	8113b09c <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113ab7c:	d0a0a003 	ldbu	r2,-32128(gp)
8113ab80:	10803fcc 	andi	r2,r2,255
8113ab84:	10000426 	beq	r2,zero,8113ab98 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
8113ab88:	e0bfff17 	ldw	r2,-4(fp)
8113ab8c:	00c00084 	movi	r3,2
8113ab90:	10c00005 	stb	r3,0(r2)
        return;
8113ab94:	00014106 	br	8113b09c <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
8113ab98:	d0a08e03 	ldbu	r2,-32200(gp)
8113ab9c:	10803fcc 	andi	r2,r2,255
8113aba0:	10000426 	beq	r2,zero,8113abb4 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
8113aba4:	e0bfff17 	ldw	r2,-4(fp)
8113aba8:	00c00344 	movi	r3,13
8113abac:	10c00005 	stb	r3,0(r2)
        return;
8113abb0:	00013a06 	br	8113b09c <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113abb4:	0005303a 	rdctl	r2,status
8113abb8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113abbc:	e0fffc17 	ldw	r3,-16(fp)
8113abc0:	00bfff84 	movi	r2,-2
8113abc4:	1884703a 	and	r2,r3,r2
8113abc8:	1001703a 	wrctl	status,r2
  
  return context;
8113abcc:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
8113abd0:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
8113abd4:	e0bffd17 	ldw	r2,-12(fp)
8113abd8:	1080020b 	ldhu	r2,8(r2)
8113abdc:	10bfffcc 	andi	r2,r2,65535
8113abe0:	1004d23a 	srli	r2,r2,8
8113abe4:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
8113abe8:	e0bffd17 	ldw	r2,-12(fp)
8113abec:	1080020b 	ldhu	r2,8(r2)
8113abf0:	10803fcc 	andi	r2,r2,255
8113abf4:	10803fd8 	cmpnei	r2,r2,255
8113abf8:	1000271e 	bne	r2,zero,8113ac98 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
8113abfc:	e0bffd17 	ldw	r2,-12(fp)
8113ac00:	10c0020b 	ldhu	r3,8(r2)
8113ac04:	00bfc004 	movi	r2,-256
8113ac08:	1884703a 	and	r2,r3,r2
8113ac0c:	1007883a 	mov	r3,r2
8113ac10:	e0bffd17 	ldw	r2,-12(fp)
8113ac14:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
8113ac18:	e0bffd17 	ldw	r2,-12(fp)
8113ac1c:	10c0020b 	ldhu	r3,8(r2)
8113ac20:	d0a0a117 	ldw	r2,-32124(gp)
8113ac24:	10800c83 	ldbu	r2,50(r2)
8113ac28:	10803fcc 	andi	r2,r2,255
8113ac2c:	1884b03a 	or	r2,r3,r2
8113ac30:	1007883a 	mov	r3,r2
8113ac34:	e0bffd17 	ldw	r2,-12(fp)
8113ac38:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
8113ac3c:	d0e0a117 	ldw	r3,-32124(gp)
8113ac40:	e0bffd17 	ldw	r2,-12(fp)
8113ac44:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
8113ac48:	d0a0a117 	ldw	r2,-32124(gp)
8113ac4c:	10800c83 	ldbu	r2,50(r2)
8113ac50:	10803fcc 	andi	r2,r2,255
8113ac54:	e0fff303 	ldbu	r3,-52(fp)
8113ac58:	18800836 	bltu	r3,r2,8113ac7c <OSMutexPend+0x170>
8113ac5c:	e0bff117 	ldw	r2,-60(fp)
8113ac60:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ac64:	e0bff217 	ldw	r2,-56(fp)
8113ac68:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
8113ac6c:	e0bfff17 	ldw	r2,-4(fp)
8113ac70:	00c01e04 	movi	r3,120
8113ac74:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
8113ac78:	00010806 	br	8113b09c <OSMutexPend+0x590>
8113ac7c:	e0bff117 	ldw	r2,-60(fp)
8113ac80:	e0bff415 	stw	r2,-48(fp)
8113ac84:	e0bff417 	ldw	r2,-48(fp)
8113ac88:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
8113ac8c:	e0bfff17 	ldw	r2,-4(fp)
8113ac90:	10000005 	stb	zero,0(r2)
        }
        return;
8113ac94:	00010106 	br	8113b09c <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
8113ac98:	e0bffd17 	ldw	r2,-12(fp)
8113ac9c:	1080020b 	ldhu	r2,8(r2)
8113aca0:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
8113aca4:	e0bffd17 	ldw	r2,-12(fp)
8113aca8:	10800117 	ldw	r2,4(r2)
8113acac:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
8113acb0:	e0bff717 	ldw	r2,-36(fp)
8113acb4:	10800c83 	ldbu	r2,50(r2)
8113acb8:	10803fcc 	andi	r2,r2,255
8113acbc:	e0fff303 	ldbu	r3,-52(fp)
8113acc0:	1880b92e 	bgeu	r3,r2,8113afa8 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
8113acc4:	d0a0a117 	ldw	r2,-32124(gp)
8113acc8:	10800c83 	ldbu	r2,50(r2)
8113accc:	10c03fcc 	andi	r3,r2,255
8113acd0:	e0bff603 	ldbu	r2,-40(fp)
8113acd4:	1880b42e 	bgeu	r3,r2,8113afa8 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
8113acd8:	e0bff717 	ldw	r2,-36(fp)
8113acdc:	10800d03 	ldbu	r2,52(r2)
8113ace0:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
8113ace4:	e0fff803 	ldbu	r3,-32(fp)
8113ace8:	d0a09d44 	addi	r2,gp,-32139
8113acec:	1885883a 	add	r2,r3,r2
8113acf0:	10c00003 	ldbu	r3,0(r2)
8113acf4:	e0bff717 	ldw	r2,-36(fp)
8113acf8:	10800d43 	ldbu	r2,53(r2)
8113acfc:	1884703a 	and	r2,r3,r2
8113ad00:	10803fcc 	andi	r2,r2,255
8113ad04:	10001e26 	beq	r2,zero,8113ad80 <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
8113ad08:	e0fff803 	ldbu	r3,-32(fp)
8113ad0c:	e13ff803 	ldbu	r4,-32(fp)
8113ad10:	d0a09d44 	addi	r2,gp,-32139
8113ad14:	2085883a 	add	r2,r4,r2
8113ad18:	10800003 	ldbu	r2,0(r2)
8113ad1c:	1009883a 	mov	r4,r2
8113ad20:	e0bff717 	ldw	r2,-36(fp)
8113ad24:	10800d43 	ldbu	r2,53(r2)
8113ad28:	0084303a 	nor	r2,zero,r2
8113ad2c:	2084703a 	and	r2,r4,r2
8113ad30:	1009883a 	mov	r4,r2
8113ad34:	d0a09d44 	addi	r2,gp,-32139
8113ad38:	1885883a 	add	r2,r3,r2
8113ad3c:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
8113ad40:	e0fff803 	ldbu	r3,-32(fp)
8113ad44:	d0a09d44 	addi	r2,gp,-32139
8113ad48:	1885883a 	add	r2,r3,r2
8113ad4c:	10800003 	ldbu	r2,0(r2)
8113ad50:	10803fcc 	andi	r2,r2,255
8113ad54:	1000071e 	bne	r2,zero,8113ad74 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
8113ad58:	e0bff717 	ldw	r2,-36(fp)
8113ad5c:	10800d83 	ldbu	r2,54(r2)
8113ad60:	0084303a 	nor	r2,zero,r2
8113ad64:	1007883a 	mov	r3,r2
8113ad68:	d0a09d03 	ldbu	r2,-32140(gp)
8113ad6c:	1884703a 	and	r2,r3,r2
8113ad70:	d0a09d05 	stb	r2,-32140(gp)
                }
                rdy = OS_TRUE;
8113ad74:	00800044 	movi	r2,1
8113ad78:	e0bff005 	stb	r2,-64(fp)
8113ad7c:	00002a06 	br	8113ae28 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113ad80:	e0bff717 	ldw	r2,-36(fp)
8113ad84:	10800717 	ldw	r2,28(r2)
8113ad88:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
8113ad8c:	e0bff917 	ldw	r2,-28(fp)
8113ad90:	10002426 	beq	r2,zero,8113ae24 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
8113ad94:	e0bff717 	ldw	r2,-36(fp)
8113ad98:	10800d03 	ldbu	r2,52(r2)
8113ad9c:	10803fcc 	andi	r2,r2,255
8113ada0:	e0fff717 	ldw	r3,-36(fp)
8113ada4:	18c00d03 	ldbu	r3,52(r3)
8113ada8:	18c03fcc 	andi	r3,r3,255
8113adac:	e13ff917 	ldw	r4,-28(fp)
8113adb0:	20c7883a 	add	r3,r4,r3
8113adb4:	18c002c4 	addi	r3,r3,11
8113adb8:	18c00003 	ldbu	r3,0(r3)
8113adbc:	1809883a 	mov	r4,r3
8113adc0:	e0fff717 	ldw	r3,-36(fp)
8113adc4:	18c00d43 	ldbu	r3,53(r3)
8113adc8:	00c6303a 	nor	r3,zero,r3
8113adcc:	20c6703a 	and	r3,r4,r3
8113add0:	1809883a 	mov	r4,r3
8113add4:	e0fff917 	ldw	r3,-28(fp)
8113add8:	1887883a 	add	r3,r3,r2
8113addc:	18c002c4 	addi	r3,r3,11
8113ade0:	19000005 	stb	r4,0(r3)
8113ade4:	e0fff917 	ldw	r3,-28(fp)
8113ade8:	1885883a 	add	r2,r3,r2
8113adec:	108002c4 	addi	r2,r2,11
8113adf0:	10800003 	ldbu	r2,0(r2)
8113adf4:	10803fcc 	andi	r2,r2,255
8113adf8:	10000a1e 	bne	r2,zero,8113ae24 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
8113adfc:	e0bff917 	ldw	r2,-28(fp)
8113ae00:	10800283 	ldbu	r2,10(r2)
8113ae04:	1007883a 	mov	r3,r2
8113ae08:	e0bff717 	ldw	r2,-36(fp)
8113ae0c:	10800d83 	ldbu	r2,54(r2)
8113ae10:	0084303a 	nor	r2,zero,r2
8113ae14:	1884703a 	and	r2,r3,r2
8113ae18:	1007883a 	mov	r3,r2
8113ae1c:	e0bff917 	ldw	r2,-28(fp)
8113ae20:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
8113ae24:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
8113ae28:	e0bff717 	ldw	r2,-36(fp)
8113ae2c:	e0fff303 	ldbu	r3,-52(fp)
8113ae30:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
8113ae34:	e0bff717 	ldw	r2,-36(fp)
8113ae38:	10800c83 	ldbu	r2,50(r2)
8113ae3c:	10803fcc 	andi	r2,r2,255
8113ae40:	1004d0fa 	srli	r2,r2,3
8113ae44:	1007883a 	mov	r3,r2
8113ae48:	e0bff717 	ldw	r2,-36(fp)
8113ae4c:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
8113ae50:	e0bff717 	ldw	r2,-36(fp)
8113ae54:	10800c83 	ldbu	r2,50(r2)
8113ae58:	108001cc 	andi	r2,r2,7
8113ae5c:	1007883a 	mov	r3,r2
8113ae60:	e0bff717 	ldw	r2,-36(fp)
8113ae64:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
8113ae68:	e0bff717 	ldw	r2,-36(fp)
8113ae6c:	10800d03 	ldbu	r2,52(r2)
8113ae70:	10803fcc 	andi	r2,r2,255
8113ae74:	00c00044 	movi	r3,1
8113ae78:	1884983a 	sll	r2,r3,r2
8113ae7c:	1007883a 	mov	r3,r2
8113ae80:	e0bff717 	ldw	r2,-36(fp)
8113ae84:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
8113ae88:	e0bff717 	ldw	r2,-36(fp)
8113ae8c:	10800cc3 	ldbu	r2,51(r2)
8113ae90:	10803fcc 	andi	r2,r2,255
8113ae94:	00c00044 	movi	r3,1
8113ae98:	1884983a 	sll	r2,r3,r2
8113ae9c:	1007883a 	mov	r3,r2
8113aea0:	e0bff717 	ldw	r2,-36(fp)
8113aea4:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
8113aea8:	e0bff003 	ldbu	r2,-64(fp)
8113aeac:	10800058 	cmpnei	r2,r2,1
8113aeb0:	1000161e 	bne	r2,zero,8113af0c <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
8113aeb4:	e0bff717 	ldw	r2,-36(fp)
8113aeb8:	10c00d83 	ldbu	r3,54(r2)
8113aebc:	d0a09d03 	ldbu	r2,-32140(gp)
8113aec0:	1884b03a 	or	r2,r3,r2
8113aec4:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113aec8:	e0bff717 	ldw	r2,-36(fp)
8113aecc:	10800d03 	ldbu	r2,52(r2)
8113aed0:	10c03fcc 	andi	r3,r2,255
8113aed4:	e0bff717 	ldw	r2,-36(fp)
8113aed8:	10800d03 	ldbu	r2,52(r2)
8113aedc:	11003fcc 	andi	r4,r2,255
8113aee0:	d0a09d44 	addi	r2,gp,-32139
8113aee4:	2085883a 	add	r2,r4,r2
8113aee8:	11000003 	ldbu	r4,0(r2)
8113aeec:	e0bff717 	ldw	r2,-36(fp)
8113aef0:	10800d43 	ldbu	r2,53(r2)
8113aef4:	2084b03a 	or	r2,r4,r2
8113aef8:	1009883a 	mov	r4,r2
8113aefc:	d0a09d44 	addi	r2,gp,-32139
8113af00:	1885883a 	add	r2,r3,r2
8113af04:	11000005 	stb	r4,0(r2)
8113af08:	00001f06 	br	8113af88 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
8113af0c:	e0bff717 	ldw	r2,-36(fp)
8113af10:	10800717 	ldw	r2,28(r2)
8113af14:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
8113af18:	e0bff917 	ldw	r2,-28(fp)
8113af1c:	10001a26 	beq	r2,zero,8113af88 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
8113af20:	e0bff917 	ldw	r2,-28(fp)
8113af24:	10c00283 	ldbu	r3,10(r2)
8113af28:	e0bff717 	ldw	r2,-36(fp)
8113af2c:	10800d83 	ldbu	r2,54(r2)
8113af30:	1884b03a 	or	r2,r3,r2
8113af34:	1007883a 	mov	r3,r2
8113af38:	e0bff917 	ldw	r2,-28(fp)
8113af3c:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113af40:	e0bff717 	ldw	r2,-36(fp)
8113af44:	10800d03 	ldbu	r2,52(r2)
8113af48:	10803fcc 	andi	r2,r2,255
8113af4c:	e0fff717 	ldw	r3,-36(fp)
8113af50:	18c00d03 	ldbu	r3,52(r3)
8113af54:	18c03fcc 	andi	r3,r3,255
8113af58:	e13ff917 	ldw	r4,-28(fp)
8113af5c:	20c7883a 	add	r3,r4,r3
8113af60:	18c002c4 	addi	r3,r3,11
8113af64:	19000003 	ldbu	r4,0(r3)
8113af68:	e0fff717 	ldw	r3,-36(fp)
8113af6c:	18c00d43 	ldbu	r3,53(r3)
8113af70:	20c6b03a 	or	r3,r4,r3
8113af74:	1809883a 	mov	r4,r3
8113af78:	e0fff917 	ldw	r3,-28(fp)
8113af7c:	1885883a 	add	r2,r3,r2
8113af80:	108002c4 	addi	r2,r2,11
8113af84:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
8113af88:	e0fff303 	ldbu	r3,-52(fp)
8113af8c:	00a045f4 	movhi	r2,33047
8113af90:	10a9d004 	addi	r2,r2,-22720
8113af94:	18c7883a 	add	r3,r3,r3
8113af98:	18c7883a 	add	r3,r3,r3
8113af9c:	10c5883a 	add	r2,r2,r3
8113afa0:	e0fff717 	ldw	r3,-36(fp)
8113afa4:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
8113afa8:	d0a0a117 	ldw	r2,-32124(gp)
8113afac:	d0e0a117 	ldw	r3,-32124(gp)
8113afb0:	18c00c03 	ldbu	r3,48(r3)
8113afb4:	18c00414 	ori	r3,r3,16
8113afb8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113afbc:	d0a0a117 	ldw	r2,-32124(gp)
8113afc0:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
8113afc4:	d0a0a117 	ldw	r2,-32124(gp)
8113afc8:	e0fffe0b 	ldhu	r3,-8(fp)
8113afcc:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113afd0:	e13ffd17 	ldw	r4,-12(fp)
8113afd4:	113734c0 	call	8113734c <OS_EventTaskWait>
8113afd8:	e0bff117 	ldw	r2,-60(fp)
8113afdc:	e0bffb15 	stw	r2,-20(fp)
8113afe0:	e0bffb17 	ldw	r2,-20(fp)
8113afe4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113afe8:	1137c680 	call	81137c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113afec:	0005303a 	rdctl	r2,status
8113aff0:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aff4:	e0fff517 	ldw	r3,-44(fp)
8113aff8:	00bfff84 	movi	r2,-2
8113affc:	1884703a 	and	r2,r3,r2
8113b000:	1001703a 	wrctl	status,r2
  
  return context;
8113b004:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
8113b008:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113b00c:	d0a0a117 	ldw	r2,-32124(gp)
8113b010:	10800c43 	ldbu	r2,49(r2)
8113b014:	10803fcc 	andi	r2,r2,255
8113b018:	10000326 	beq	r2,zero,8113b028 <OSMutexPend+0x51c>
8113b01c:	108000a0 	cmpeqi	r2,r2,2
8113b020:	1000041e 	bne	r2,zero,8113b034 <OSMutexPend+0x528>
8113b024:	00000706 	br	8113b044 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113b028:	e0bfff17 	ldw	r2,-4(fp)
8113b02c:	10000005 	stb	zero,0(r2)
             break;
8113b030:	00000c06 	br	8113b064 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
8113b034:	e0bfff17 	ldw	r2,-4(fp)
8113b038:	00c00384 	movi	r3,14
8113b03c:	10c00005 	stb	r3,0(r2)
             break;
8113b040:	00000806 	br	8113b064 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113b044:	d0a0a117 	ldw	r2,-32124(gp)
8113b048:	e17ffd17 	ldw	r5,-12(fp)
8113b04c:	1009883a 	mov	r4,r2
8113b050:	11375bc0 	call	811375bc <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
8113b054:	e0bfff17 	ldw	r2,-4(fp)
8113b058:	00c00284 	movi	r3,10
8113b05c:	10c00005 	stb	r3,0(r2)
             break;
8113b060:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113b064:	d0a0a117 	ldw	r2,-32124(gp)
8113b068:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113b06c:	d0a0a117 	ldw	r2,-32124(gp)
8113b070:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113b074:	d0a0a117 	ldw	r2,-32124(gp)
8113b078:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113b07c:	d0a0a117 	ldw	r2,-32124(gp)
8113b080:	10000815 	stw	zero,32(r2)
8113b084:	e0bff117 	ldw	r2,-60(fp)
8113b088:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b08c:	e0bffa17 	ldw	r2,-24(fp)
8113b090:	1001703a 	wrctl	status,r2
8113b094:	00000106 	br	8113b09c <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
8113b098:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113b09c:	e037883a 	mov	sp,fp
8113b0a0:	dfc00117 	ldw	ra,4(sp)
8113b0a4:	df000017 	ldw	fp,0(sp)
8113b0a8:	dec00204 	addi	sp,sp,8
8113b0ac:	f800283a 	ret

8113b0b0 <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113b0b0:	defff604 	addi	sp,sp,-40
8113b0b4:	de00012e 	bgeu	sp,et,8113b0bc <OSMutexPost+0xc>
8113b0b8:	003b68fa 	trap	3
8113b0bc:	dfc00915 	stw	ra,36(sp)
8113b0c0:	df000815 	stw	fp,32(sp)
8113b0c4:	df000804 	addi	fp,sp,32
8113b0c8:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b0cc:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113b0d0:	d0a0a003 	ldbu	r2,-32128(gp)
8113b0d4:	10803fcc 	andi	r2,r2,255
8113b0d8:	10000226 	beq	r2,zero,8113b0e4 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
8113b0dc:	00800144 	movi	r2,5
8113b0e0:	00007606 	br	8113b2bc <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113b0e4:	e0bfff17 	ldw	r2,-4(fp)
8113b0e8:	1000021e 	bne	r2,zero,8113b0f4 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
8113b0ec:	00800104 	movi	r2,4
8113b0f0:	00007206 	br	8113b2bc <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
8113b0f4:	e0bfff17 	ldw	r2,-4(fp)
8113b0f8:	10800003 	ldbu	r2,0(r2)
8113b0fc:	10803fcc 	andi	r2,r2,255
8113b100:	10800120 	cmpeqi	r2,r2,4
8113b104:	1000021e 	bne	r2,zero,8113b110 <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
8113b108:	00800044 	movi	r2,1
8113b10c:	00006b06 	br	8113b2bc <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b110:	0005303a 	rdctl	r2,status
8113b114:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b118:	e0fffe17 	ldw	r3,-8(fp)
8113b11c:	00bfff84 	movi	r2,-2
8113b120:	1884703a 	and	r2,r3,r2
8113b124:	1001703a 	wrctl	status,r2
  
  return context;
8113b128:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113b12c:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113b130:	e0bfff17 	ldw	r2,-4(fp)
8113b134:	1080020b 	ldhu	r2,8(r2)
8113b138:	10bfffcc 	andi	r2,r2,65535
8113b13c:	1004d23a 	srli	r2,r2,8
8113b140:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
8113b144:	e0bfff17 	ldw	r2,-4(fp)
8113b148:	1080020b 	ldhu	r2,8(r2)
8113b14c:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113b150:	e0bfff17 	ldw	r2,-4(fp)
8113b154:	10c00117 	ldw	r3,4(r2)
8113b158:	d0a0a117 	ldw	r2,-32124(gp)
8113b15c:	18800626 	beq	r3,r2,8113b178 <OSMutexPost+0xc8>
8113b160:	e0bff817 	ldw	r2,-32(fp)
8113b164:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b168:	e0bff917 	ldw	r2,-28(fp)
8113b16c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113b170:	00801904 	movi	r2,100
8113b174:	00005106 	br	8113b2bc <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
8113b178:	d0a0a117 	ldw	r2,-32124(gp)
8113b17c:	10800c83 	ldbu	r2,50(r2)
8113b180:	10c03fcc 	andi	r3,r2,255
8113b184:	e0bffa03 	ldbu	r2,-24(fp)
8113b188:	1880051e 	bne	r3,r2,8113b1a0 <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
8113b18c:	d0a0a117 	ldw	r2,-32124(gp)
8113b190:	e0fffa43 	ldbu	r3,-23(fp)
8113b194:	180b883a 	mov	r5,r3
8113b198:	1009883a 	mov	r4,r2
8113b19c:	113b4440 	call	8113b444 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113b1a0:	e0fffa03 	ldbu	r3,-24(fp)
8113b1a4:	00a045f4 	movhi	r2,33047
8113b1a8:	10a9d004 	addi	r2,r2,-22720
8113b1ac:	18c7883a 	add	r3,r3,r3
8113b1b0:	18c7883a 	add	r3,r3,r3
8113b1b4:	10c5883a 	add	r2,r2,r3
8113b1b8:	00c00044 	movi	r3,1
8113b1bc:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113b1c0:	e0bfff17 	ldw	r2,-4(fp)
8113b1c4:	10800283 	ldbu	r2,10(r2)
8113b1c8:	10803fcc 	andi	r2,r2,255
8113b1cc:	10002e26 	beq	r2,zero,8113b288 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
8113b1d0:	000f883a 	mov	r7,zero
8113b1d4:	01800404 	movi	r6,16
8113b1d8:	000b883a 	mov	r5,zero
8113b1dc:	e13fff17 	ldw	r4,-4(fp)
8113b1e0:	11371ac0 	call	811371ac <OS_EventTaskRdy>
8113b1e4:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
8113b1e8:	e0bfff17 	ldw	r2,-4(fp)
8113b1ec:	10c0020b 	ldhu	r3,8(r2)
8113b1f0:	00bfc004 	movi	r2,-256
8113b1f4:	1884703a 	and	r2,r3,r2
8113b1f8:	1007883a 	mov	r3,r2
8113b1fc:	e0bfff17 	ldw	r2,-4(fp)
8113b200:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
8113b204:	e0bfff17 	ldw	r2,-4(fp)
8113b208:	10c0020b 	ldhu	r3,8(r2)
8113b20c:	e0bffa43 	ldbu	r2,-23(fp)
8113b210:	1884b03a 	or	r2,r3,r2
8113b214:	1007883a 	mov	r3,r2
8113b218:	e0bfff17 	ldw	r2,-4(fp)
8113b21c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
8113b220:	e0fffa43 	ldbu	r3,-23(fp)
8113b224:	00a045f4 	movhi	r2,33047
8113b228:	10a9d004 	addi	r2,r2,-22720
8113b22c:	18c7883a 	add	r3,r3,r3
8113b230:	18c7883a 	add	r3,r3,r3
8113b234:	10c5883a 	add	r2,r2,r3
8113b238:	10c00017 	ldw	r3,0(r2)
8113b23c:	e0bfff17 	ldw	r2,-4(fp)
8113b240:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
8113b244:	e0bffa43 	ldbu	r2,-23(fp)
8113b248:	e0fffa03 	ldbu	r3,-24(fp)
8113b24c:	18800736 	bltu	r3,r2,8113b26c <OSMutexPost+0x1bc>
8113b250:	e0bff817 	ldw	r2,-32(fp)
8113b254:	e0bffb15 	stw	r2,-20(fp)
8113b258:	e0bffb17 	ldw	r2,-20(fp)
8113b25c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113b260:	1137c680 	call	81137c68 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
8113b264:	00801e04 	movi	r2,120
8113b268:	00001406 	br	8113b2bc <OSMutexPost+0x20c>
8113b26c:	e0bff817 	ldw	r2,-32(fp)
8113b270:	e0bffc15 	stw	r2,-16(fp)
8113b274:	e0bffc17 	ldw	r2,-16(fp)
8113b278:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113b27c:	1137c680 	call	81137c68 <OS_Sched>
            return (OS_ERR_NONE);
8113b280:	0005883a 	mov	r2,zero
8113b284:	00000d06 	br	8113b2bc <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
8113b288:	e0bfff17 	ldw	r2,-4(fp)
8113b28c:	1080020b 	ldhu	r2,8(r2)
8113b290:	10803fd4 	ori	r2,r2,255
8113b294:	1007883a 	mov	r3,r2
8113b298:	e0bfff17 	ldw	r2,-4(fp)
8113b29c:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113b2a0:	e0bfff17 	ldw	r2,-4(fp)
8113b2a4:	10000115 	stw	zero,4(r2)
8113b2a8:	e0bff817 	ldw	r2,-32(fp)
8113b2ac:	e0bffd15 	stw	r2,-12(fp)
8113b2b0:	e0bffd17 	ldw	r2,-12(fp)
8113b2b4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b2b8:	0005883a 	mov	r2,zero
}
8113b2bc:	e037883a 	mov	sp,fp
8113b2c0:	dfc00117 	ldw	ra,4(sp)
8113b2c4:	df000017 	ldw	fp,0(sp)
8113b2c8:	dec00204 	addi	sp,sp,8
8113b2cc:	f800283a 	ret

8113b2d0 <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
8113b2d0:	defff704 	addi	sp,sp,-36
8113b2d4:	de00012e 	bgeu	sp,et,8113b2dc <OSMutexQuery+0xc>
8113b2d8:	003b68fa 	trap	3
8113b2dc:	df000815 	stw	fp,32(sp)
8113b2e0:	df000804 	addi	fp,sp,32
8113b2e4:	e13ffe15 	stw	r4,-8(fp)
8113b2e8:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b2ec:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113b2f0:	d0a0a003 	ldbu	r2,-32128(gp)
8113b2f4:	10803fcc 	andi	r2,r2,255
8113b2f8:	10000226 	beq	r2,zero,8113b304 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
8113b2fc:	00800184 	movi	r2,6
8113b300:	00004c06 	br	8113b434 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113b304:	e0bffe17 	ldw	r2,-8(fp)
8113b308:	1000021e 	bne	r2,zero,8113b314 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
8113b30c:	00800104 	movi	r2,4
8113b310:	00004806 	br	8113b434 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
8113b314:	e0bfff17 	ldw	r2,-4(fp)
8113b318:	1000021e 	bne	r2,zero,8113b324 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
8113b31c:	00800244 	movi	r2,9
8113b320:	00004406 	br	8113b434 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113b324:	e0bffe17 	ldw	r2,-8(fp)
8113b328:	10800003 	ldbu	r2,0(r2)
8113b32c:	10803fcc 	andi	r2,r2,255
8113b330:	10800120 	cmpeqi	r2,r2,4
8113b334:	1000021e 	bne	r2,zero,8113b340 <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
8113b338:	00800044 	movi	r2,1
8113b33c:	00003d06 	br	8113b434 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b340:	0005303a 	rdctl	r2,status
8113b344:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b348:	e0fffd17 	ldw	r3,-12(fp)
8113b34c:	00bfff84 	movi	r2,-2
8113b350:	1884703a 	and	r2,r3,r2
8113b354:	1001703a 	wrctl	status,r2
  
  return context;
8113b358:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113b35c:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113b360:	e0bffe17 	ldw	r2,-8(fp)
8113b364:	1080020b 	ldhu	r2,8(r2)
8113b368:	10bfffcc 	andi	r2,r2,65535
8113b36c:	1004d23a 	srli	r2,r2,8
8113b370:	1007883a 	mov	r3,r2
8113b374:	e0bfff17 	ldw	r2,-4(fp)
8113b378:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
8113b37c:	e0bffe17 	ldw	r2,-8(fp)
8113b380:	1080020b 	ldhu	r2,8(r2)
8113b384:	1007883a 	mov	r3,r2
8113b388:	e0bfff17 	ldw	r2,-4(fp)
8113b38c:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113b390:	e0bfff17 	ldw	r2,-4(fp)
8113b394:	10800203 	ldbu	r2,8(r2)
8113b398:	10803fcc 	andi	r2,r2,255
8113b39c:	10803fd8 	cmpnei	r2,r2,255
8113b3a0:	1000041e 	bne	r2,zero,8113b3b4 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
8113b3a4:	e0bfff17 	ldw	r2,-4(fp)
8113b3a8:	00c00044 	movi	r3,1
8113b3ac:	10c001c5 	stb	r3,7(r2)
8113b3b0:	00000206 	br	8113b3bc <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
8113b3b4:	e0bfff17 	ldw	r2,-4(fp)
8113b3b8:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
8113b3bc:	e0bffe17 	ldw	r2,-8(fp)
8113b3c0:	10c00283 	ldbu	r3,10(r2)
8113b3c4:	e0bfff17 	ldw	r2,-4(fp)
8113b3c8:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
8113b3cc:	e0bffe17 	ldw	r2,-8(fp)
8113b3d0:	108002c4 	addi	r2,r2,11
8113b3d4:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
8113b3d8:	e0bfff17 	ldw	r2,-4(fp)
8113b3dc:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b3e0:	e03ff805 	stb	zero,-32(fp)
8113b3e4:	00000b06 	br	8113b414 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
8113b3e8:	e0bffa17 	ldw	r2,-24(fp)
8113b3ec:	10c00044 	addi	r3,r2,1
8113b3f0:	e0fffa15 	stw	r3,-24(fp)
8113b3f4:	e0fff917 	ldw	r3,-28(fp)
8113b3f8:	19000044 	addi	r4,r3,1
8113b3fc:	e13ff915 	stw	r4,-28(fp)
8113b400:	18c00003 	ldbu	r3,0(r3)
8113b404:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b408:	e0bff803 	ldbu	r2,-32(fp)
8113b40c:	10800044 	addi	r2,r2,1
8113b410:	e0bff805 	stb	r2,-32(fp)
8113b414:	e0bff803 	ldbu	r2,-32(fp)
8113b418:	108001b0 	cmpltui	r2,r2,6
8113b41c:	103ff21e 	bne	r2,zero,8113b3e8 <__reset+0xfb11b3e8>
8113b420:	e0bffb17 	ldw	r2,-20(fp)
8113b424:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b428:	e0bffc17 	ldw	r2,-16(fp)
8113b42c:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b430:	0005883a 	mov	r2,zero
}
8113b434:	e037883a 	mov	sp,fp
8113b438:	df000017 	ldw	fp,0(sp)
8113b43c:	dec00104 	addi	sp,sp,4
8113b440:	f800283a 	ret

8113b444 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
8113b444:	defffc04 	addi	sp,sp,-16
8113b448:	de00012e 	bgeu	sp,et,8113b450 <OSMutex_RdyAtPrio+0xc>
8113b44c:	003b68fa 	trap	3
8113b450:	df000315 	stw	fp,12(sp)
8113b454:	df000304 	addi	fp,sp,12
8113b458:	e13ffe15 	stw	r4,-8(fp)
8113b45c:	2805883a 	mov	r2,r5
8113b460:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
8113b464:	e0bffe17 	ldw	r2,-8(fp)
8113b468:	10800d03 	ldbu	r2,52(r2)
8113b46c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113b470:	e0fffd03 	ldbu	r3,-12(fp)
8113b474:	e13ffd03 	ldbu	r4,-12(fp)
8113b478:	d0a09d44 	addi	r2,gp,-32139
8113b47c:	2085883a 	add	r2,r4,r2
8113b480:	10800003 	ldbu	r2,0(r2)
8113b484:	1009883a 	mov	r4,r2
8113b488:	e0bffe17 	ldw	r2,-8(fp)
8113b48c:	10800d43 	ldbu	r2,53(r2)
8113b490:	0084303a 	nor	r2,zero,r2
8113b494:	2084703a 	and	r2,r4,r2
8113b498:	1009883a 	mov	r4,r2
8113b49c:	d0a09d44 	addi	r2,gp,-32139
8113b4a0:	1885883a 	add	r2,r3,r2
8113b4a4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113b4a8:	e0fffd03 	ldbu	r3,-12(fp)
8113b4ac:	d0a09d44 	addi	r2,gp,-32139
8113b4b0:	1885883a 	add	r2,r3,r2
8113b4b4:	10800003 	ldbu	r2,0(r2)
8113b4b8:	10803fcc 	andi	r2,r2,255
8113b4bc:	1000071e 	bne	r2,zero,8113b4dc <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113b4c0:	e0bffe17 	ldw	r2,-8(fp)
8113b4c4:	10800d83 	ldbu	r2,54(r2)
8113b4c8:	0084303a 	nor	r2,zero,r2
8113b4cc:	1007883a 	mov	r3,r2
8113b4d0:	d0a09d03 	ldbu	r2,-32140(gp)
8113b4d4:	1884703a 	and	r2,r3,r2
8113b4d8:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBPrio         = prio;
8113b4dc:	e0bffe17 	ldw	r2,-8(fp)
8113b4e0:	e0ffff03 	ldbu	r3,-4(fp)
8113b4e4:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
8113b4e8:	e0bfff03 	ldbu	r2,-4(fp)
8113b4ec:	1004d0fa 	srli	r2,r2,3
8113b4f0:	108001cc 	andi	r2,r2,7
8113b4f4:	1007883a 	mov	r3,r2
8113b4f8:	e0bffe17 	ldw	r2,-8(fp)
8113b4fc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
8113b500:	e0bfff03 	ldbu	r2,-4(fp)
8113b504:	108001cc 	andi	r2,r2,7
8113b508:	1007883a 	mov	r3,r2
8113b50c:	e0bffe17 	ldw	r2,-8(fp)
8113b510:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
8113b514:	e0bffe17 	ldw	r2,-8(fp)
8113b518:	10800d03 	ldbu	r2,52(r2)
8113b51c:	10803fcc 	andi	r2,r2,255
8113b520:	00c00044 	movi	r3,1
8113b524:	1884983a 	sll	r2,r3,r2
8113b528:	1007883a 	mov	r3,r2
8113b52c:	e0bffe17 	ldw	r2,-8(fp)
8113b530:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
8113b534:	e0bffe17 	ldw	r2,-8(fp)
8113b538:	10800cc3 	ldbu	r2,51(r2)
8113b53c:	10803fcc 	andi	r2,r2,255
8113b540:	00c00044 	movi	r3,1
8113b544:	1884983a 	sll	r2,r3,r2
8113b548:	1007883a 	mov	r3,r2
8113b54c:	e0bffe17 	ldw	r2,-8(fp)
8113b550:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
8113b554:	e0bffe17 	ldw	r2,-8(fp)
8113b558:	10c00d83 	ldbu	r3,54(r2)
8113b55c:	d0a09d03 	ldbu	r2,-32140(gp)
8113b560:	1884b03a 	or	r2,r3,r2
8113b564:	d0a09d05 	stb	r2,-32140(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113b568:	e0bffe17 	ldw	r2,-8(fp)
8113b56c:	10800d03 	ldbu	r2,52(r2)
8113b570:	10c03fcc 	andi	r3,r2,255
8113b574:	e0bffe17 	ldw	r2,-8(fp)
8113b578:	10800d03 	ldbu	r2,52(r2)
8113b57c:	11003fcc 	andi	r4,r2,255
8113b580:	d0a09d44 	addi	r2,gp,-32139
8113b584:	2085883a 	add	r2,r4,r2
8113b588:	11000003 	ldbu	r4,0(r2)
8113b58c:	e0bffe17 	ldw	r2,-8(fp)
8113b590:	10800d43 	ldbu	r2,53(r2)
8113b594:	2084b03a 	or	r2,r4,r2
8113b598:	1009883a 	mov	r4,r2
8113b59c:	d0a09d44 	addi	r2,gp,-32139
8113b5a0:	1885883a 	add	r2,r3,r2
8113b5a4:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
8113b5a8:	e0ffff03 	ldbu	r3,-4(fp)
8113b5ac:	00a045f4 	movhi	r2,33047
8113b5b0:	10a9d004 	addi	r2,r2,-22720
8113b5b4:	18c7883a 	add	r3,r3,r3
8113b5b8:	18c7883a 	add	r3,r3,r3
8113b5bc:	10c5883a 	add	r2,r2,r3
8113b5c0:	e0fffe17 	ldw	r3,-8(fp)
8113b5c4:	10c00015 	stw	r3,0(r2)
}
8113b5c8:	0001883a 	nop
8113b5cc:	e037883a 	mov	sp,fp
8113b5d0:	df000017 	ldw	fp,0(sp)
8113b5d4:	dec00104 	addi	sp,sp,4
8113b5d8:	f800283a 	ret

8113b5dc <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
8113b5dc:	defff804 	addi	sp,sp,-32
8113b5e0:	de00012e 	bgeu	sp,et,8113b5e8 <OSQAccept+0xc>
8113b5e4:	003b68fa 	trap	3
8113b5e8:	df000715 	stw	fp,28(sp)
8113b5ec:	df000704 	addi	fp,sp,28
8113b5f0:	e13ffe15 	stw	r4,-8(fp)
8113b5f4:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b5f8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113b5fc:	e0bfff17 	ldw	r2,-4(fp)
8113b600:	1000021e 	bne	r2,zero,8113b60c <OSQAccept+0x30>
        return ((void *)0);
8113b604:	0005883a 	mov	r2,zero
8113b608:	00004206 	br	8113b714 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113b60c:	e0bffe17 	ldw	r2,-8(fp)
8113b610:	1000051e 	bne	r2,zero,8113b628 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113b614:	e0bfff17 	ldw	r2,-4(fp)
8113b618:	00c00104 	movi	r3,4
8113b61c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113b620:	0005883a 	mov	r2,zero
8113b624:	00003b06 	br	8113b714 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113b628:	e0bffe17 	ldw	r2,-8(fp)
8113b62c:	10800003 	ldbu	r2,0(r2)
8113b630:	10803fcc 	andi	r2,r2,255
8113b634:	108000a0 	cmpeqi	r2,r2,2
8113b638:	1000051e 	bne	r2,zero,8113b650 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
8113b63c:	e0bfff17 	ldw	r2,-4(fp)
8113b640:	00c00044 	movi	r3,1
8113b644:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113b648:	0005883a 	mov	r2,zero
8113b64c:	00003106 	br	8113b714 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b650:	0005303a 	rdctl	r2,status
8113b654:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b658:	e0fffd17 	ldw	r3,-12(fp)
8113b65c:	00bfff84 	movi	r2,-2
8113b660:	1884703a 	and	r2,r3,r2
8113b664:	1001703a 	wrctl	status,r2
  
  return context;
8113b668:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113b66c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113b670:	e0bffe17 	ldw	r2,-8(fp)
8113b674:	10800117 	ldw	r2,4(r2)
8113b678:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113b67c:	e0bffc17 	ldw	r2,-16(fp)
8113b680:	1080058b 	ldhu	r2,22(r2)
8113b684:	10bfffcc 	andi	r2,r2,65535
8113b688:	10001926 	beq	r2,zero,8113b6f0 <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113b68c:	e0bffc17 	ldw	r2,-16(fp)
8113b690:	10800417 	ldw	r2,16(r2)
8113b694:	11000104 	addi	r4,r2,4
8113b698:	e0fffc17 	ldw	r3,-16(fp)
8113b69c:	19000415 	stw	r4,16(r3)
8113b6a0:	10800017 	ldw	r2,0(r2)
8113b6a4:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113b6a8:	e0bffc17 	ldw	r2,-16(fp)
8113b6ac:	1080058b 	ldhu	r2,22(r2)
8113b6b0:	10bfffc4 	addi	r2,r2,-1
8113b6b4:	1007883a 	mov	r3,r2
8113b6b8:	e0bffc17 	ldw	r2,-16(fp)
8113b6bc:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113b6c0:	e0bffc17 	ldw	r2,-16(fp)
8113b6c4:	10c00417 	ldw	r3,16(r2)
8113b6c8:	e0bffc17 	ldw	r2,-16(fp)
8113b6cc:	10800217 	ldw	r2,8(r2)
8113b6d0:	1880041e 	bne	r3,r2,8113b6e4 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
8113b6d4:	e0bffc17 	ldw	r2,-16(fp)
8113b6d8:	10c00117 	ldw	r3,4(r2)
8113b6dc:	e0bffc17 	ldw	r2,-16(fp)
8113b6e0:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
8113b6e4:	e0bfff17 	ldw	r2,-4(fp)
8113b6e8:	10000005 	stb	zero,0(r2)
8113b6ec:	00000406 	br	8113b700 <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
8113b6f0:	e0bfff17 	ldw	r2,-4(fp)
8113b6f4:	00c007c4 	movi	r3,31
8113b6f8:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
8113b6fc:	e03ff915 	stw	zero,-28(fp)
8113b700:	e0bffa17 	ldw	r2,-24(fp)
8113b704:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b708:	e0bffb17 	ldw	r2,-20(fp)
8113b70c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
8113b710:	e0bff917 	ldw	r2,-28(fp)
}
8113b714:	e037883a 	mov	sp,fp
8113b718:	df000017 	ldw	fp,0(sp)
8113b71c:	dec00104 	addi	sp,sp,4
8113b720:	f800283a 	ret

8113b724 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
8113b724:	defff404 	addi	sp,sp,-48
8113b728:	de00012e 	bgeu	sp,et,8113b730 <OSQCreate+0xc>
8113b72c:	003b68fa 	trap	3
8113b730:	dfc00b15 	stw	ra,44(sp)
8113b734:	df000a15 	stw	fp,40(sp)
8113b738:	df000a04 	addi	fp,sp,40
8113b73c:	e13ffe15 	stw	r4,-8(fp)
8113b740:	2805883a 	mov	r2,r5
8113b744:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113b748:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113b74c:	d0a0a003 	ldbu	r2,-32128(gp)
8113b750:	10803fcc 	andi	r2,r2,255
8113b754:	10000226 	beq	r2,zero,8113b760 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
8113b758:	0005883a 	mov	r2,zero
8113b75c:	00005906 	br	8113b8c4 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b760:	0005303a 	rdctl	r2,status
8113b764:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b768:	e0fffd17 	ldw	r3,-12(fp)
8113b76c:	00bfff84 	movi	r2,-2
8113b770:	1884703a 	and	r2,r3,r2
8113b774:	1001703a 	wrctl	status,r2
  
  return context;
8113b778:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113b77c:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113b780:	d0a09f17 	ldw	r2,-32132(gp)
8113b784:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
8113b788:	d0a09f17 	ldw	r2,-32132(gp)
8113b78c:	10000326 	beq	r2,zero,8113b79c <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113b790:	d0a09f17 	ldw	r2,-32132(gp)
8113b794:	10800117 	ldw	r2,4(r2)
8113b798:	d0a09f15 	stw	r2,-32132(gp)
8113b79c:	e0bff717 	ldw	r2,-36(fp)
8113b7a0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b7a4:	e0bff817 	ldw	r2,-32(fp)
8113b7a8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
8113b7ac:	e0bff617 	ldw	r2,-40(fp)
8113b7b0:	10004326 	beq	r2,zero,8113b8c0 <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b7b4:	0005303a 	rdctl	r2,status
8113b7b8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b7bc:	e0fff917 	ldw	r3,-28(fp)
8113b7c0:	00bfff84 	movi	r2,-2
8113b7c4:	1884703a 	and	r2,r3,r2
8113b7c8:	1001703a 	wrctl	status,r2
  
  return context;
8113b7cc:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
8113b7d0:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
8113b7d4:	d0a09c17 	ldw	r2,-32144(gp)
8113b7d8:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
8113b7dc:	e0bffb17 	ldw	r2,-20(fp)
8113b7e0:	10002d26 	beq	r2,zero,8113b898 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
8113b7e4:	d0a09c17 	ldw	r2,-32144(gp)
8113b7e8:	10800017 	ldw	r2,0(r2)
8113b7ec:	d0a09c15 	stw	r2,-32144(gp)
8113b7f0:	e0bff717 	ldw	r2,-36(fp)
8113b7f4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b7f8:	e0bffa17 	ldw	r2,-24(fp)
8113b7fc:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
8113b800:	e0bffb17 	ldw	r2,-20(fp)
8113b804:	e0fffe17 	ldw	r3,-8(fp)
8113b808:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
8113b80c:	e0bfff0b 	ldhu	r2,-4(fp)
8113b810:	1085883a 	add	r2,r2,r2
8113b814:	1085883a 	add	r2,r2,r2
8113b818:	1007883a 	mov	r3,r2
8113b81c:	e0bffe17 	ldw	r2,-8(fp)
8113b820:	10c7883a 	add	r3,r2,r3
8113b824:	e0bffb17 	ldw	r2,-20(fp)
8113b828:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
8113b82c:	e0bffb17 	ldw	r2,-20(fp)
8113b830:	e0fffe17 	ldw	r3,-8(fp)
8113b834:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
8113b838:	e0bffb17 	ldw	r2,-20(fp)
8113b83c:	e0fffe17 	ldw	r3,-8(fp)
8113b840:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
8113b844:	e0bffb17 	ldw	r2,-20(fp)
8113b848:	e0ffff0b 	ldhu	r3,-4(fp)
8113b84c:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113b850:	e0bffb17 	ldw	r2,-20(fp)
8113b854:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
8113b858:	e0bff617 	ldw	r2,-40(fp)
8113b85c:	00c00084 	movi	r3,2
8113b860:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
8113b864:	e0bff617 	ldw	r2,-40(fp)
8113b868:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
8113b86c:	e0bff617 	ldw	r2,-40(fp)
8113b870:	e0fffb17 	ldw	r3,-20(fp)
8113b874:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
8113b878:	e0bff617 	ldw	r2,-40(fp)
8113b87c:	00c00fc4 	movi	r3,63
8113b880:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
8113b884:	e0bff617 	ldw	r2,-40(fp)
8113b888:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
8113b88c:	e13ff617 	ldw	r4,-40(fp)
8113b890:	11377840 	call	81137784 <OS_EventWaitListInit>
8113b894:	00000a06 	br	8113b8c0 <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
8113b898:	d0e09f17 	ldw	r3,-32132(gp)
8113b89c:	e0bff617 	ldw	r2,-40(fp)
8113b8a0:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
8113b8a4:	e0bff617 	ldw	r2,-40(fp)
8113b8a8:	d0a09f15 	stw	r2,-32132(gp)
8113b8ac:	e0bff717 	ldw	r2,-36(fp)
8113b8b0:	e0bffc15 	stw	r2,-16(fp)
8113b8b4:	e0bffc17 	ldw	r2,-16(fp)
8113b8b8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
8113b8bc:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113b8c0:	e0bff617 	ldw	r2,-40(fp)
}
8113b8c4:	e037883a 	mov	sp,fp
8113b8c8:	dfc00117 	ldw	ra,4(sp)
8113b8cc:	df000017 	ldw	fp,0(sp)
8113b8d0:	dec00204 	addi	sp,sp,8
8113b8d4:	f800283a 	ret

8113b8d8 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113b8d8:	defff204 	addi	sp,sp,-56
8113b8dc:	de00012e 	bgeu	sp,et,8113b8e4 <OSQDel+0xc>
8113b8e0:	003b68fa 	trap	3
8113b8e4:	dfc00d15 	stw	ra,52(sp)
8113b8e8:	df000c15 	stw	fp,48(sp)
8113b8ec:	df000c04 	addi	fp,sp,48
8113b8f0:	e13ffd15 	stw	r4,-12(fp)
8113b8f4:	2805883a 	mov	r2,r5
8113b8f8:	e1bfff15 	stw	r6,-4(fp)
8113b8fc:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113b900:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113b904:	e0bfff17 	ldw	r2,-4(fp)
8113b908:	1000021e 	bne	r2,zero,8113b914 <OSQDel+0x3c>
        return (pevent);
8113b90c:	e0bffd17 	ldw	r2,-12(fp)
8113b910:	00008e06 	br	8113bb4c <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113b914:	e0bffd17 	ldw	r2,-12(fp)
8113b918:	1000051e 	bne	r2,zero,8113b930 <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113b91c:	e0bfff17 	ldw	r2,-4(fp)
8113b920:	00c00104 	movi	r3,4
8113b924:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b928:	e0bffd17 	ldw	r2,-12(fp)
8113b92c:	00008706 	br	8113bb4c <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113b930:	e0bffd17 	ldw	r2,-12(fp)
8113b934:	10800003 	ldbu	r2,0(r2)
8113b938:	10803fcc 	andi	r2,r2,255
8113b93c:	108000a0 	cmpeqi	r2,r2,2
8113b940:	1000051e 	bne	r2,zero,8113b958 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113b944:	e0bfff17 	ldw	r2,-4(fp)
8113b948:	00c00044 	movi	r3,1
8113b94c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b950:	e0bffd17 	ldw	r2,-12(fp)
8113b954:	00007d06 	br	8113bb4c <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113b958:	d0a0a003 	ldbu	r2,-32128(gp)
8113b95c:	10803fcc 	andi	r2,r2,255
8113b960:	10000526 	beq	r2,zero,8113b978 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
8113b964:	e0bfff17 	ldw	r2,-4(fp)
8113b968:	00c003c4 	movi	r3,15
8113b96c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113b970:	e0bffd17 	ldw	r2,-12(fp)
8113b974:	00007506 	br	8113bb4c <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b978:	0005303a 	rdctl	r2,status
8113b97c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b980:	e0fffc17 	ldw	r3,-16(fp)
8113b984:	00bfff84 	movi	r2,-2
8113b988:	1884703a 	and	r2,r3,r2
8113b98c:	1001703a 	wrctl	status,r2
  
  return context;
8113b990:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b994:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
8113b998:	e0bffd17 	ldw	r2,-12(fp)
8113b99c:	10800283 	ldbu	r2,10(r2)
8113b9a0:	10803fcc 	andi	r2,r2,255
8113b9a4:	10000326 	beq	r2,zero,8113b9b4 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113b9a8:	00800044 	movi	r2,1
8113b9ac:	e0bff405 	stb	r2,-48(fp)
8113b9b0:	00000106 	br	8113b9b8 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113b9b4:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
8113b9b8:	e0bffe03 	ldbu	r2,-8(fp)
8113b9bc:	10000326 	beq	r2,zero,8113b9cc <OSQDel+0xf4>
8113b9c0:	10800060 	cmpeqi	r2,r2,1
8113b9c4:	1000301e 	bne	r2,zero,8113ba88 <OSQDel+0x1b0>
8113b9c8:	00005506 	br	8113bb20 <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
8113b9cc:	e0bff403 	ldbu	r2,-48(fp)
8113b9d0:	10001e1e 	bne	r2,zero,8113ba4c <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113b9d4:	e0bffd17 	ldw	r2,-12(fp)
8113b9d8:	00c00fc4 	movi	r3,63
8113b9dc:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113b9e0:	e0bffd17 	ldw	r2,-12(fp)
8113b9e4:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
8113b9e8:	e0bffd17 	ldw	r2,-12(fp)
8113b9ec:	10800117 	ldw	r2,4(r2)
8113b9f0:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
8113b9f4:	d0e09c17 	ldw	r3,-32144(gp)
8113b9f8:	e0bff817 	ldw	r2,-32(fp)
8113b9fc:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
8113ba00:	e0bff817 	ldw	r2,-32(fp)
8113ba04:	d0a09c15 	stw	r2,-32144(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ba08:	e0bffd17 	ldw	r2,-12(fp)
8113ba0c:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113ba10:	d0e09f17 	ldw	r3,-32132(gp)
8113ba14:	e0bffd17 	ldw	r2,-12(fp)
8113ba18:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113ba1c:	e0bffd17 	ldw	r2,-12(fp)
8113ba20:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113ba24:	e0bffd17 	ldw	r2,-12(fp)
8113ba28:	d0a09f15 	stw	r2,-32132(gp)
8113ba2c:	e0bff617 	ldw	r2,-40(fp)
8113ba30:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ba34:	e0bff717 	ldw	r2,-36(fp)
8113ba38:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113ba3c:	e0bfff17 	ldw	r2,-4(fp)
8113ba40:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
8113ba44:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113ba48:	00003f06 	br	8113bb48 <OSQDel+0x270>
8113ba4c:	e0bff617 	ldw	r2,-40(fp)
8113ba50:	e0bff915 	stw	r2,-28(fp)
8113ba54:	e0bff917 	ldw	r2,-28(fp)
8113ba58:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113ba5c:	e0bfff17 	ldw	r2,-4(fp)
8113ba60:	00c01244 	movi	r3,73
8113ba64:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113ba68:	e0bffd17 	ldw	r2,-12(fp)
8113ba6c:	e0bff515 	stw	r2,-44(fp)
             }
             break;
8113ba70:	00003506 	br	8113bb48 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
8113ba74:	000f883a 	mov	r7,zero
8113ba78:	01800104 	movi	r6,4
8113ba7c:	000b883a 	mov	r5,zero
8113ba80:	e13ffd17 	ldw	r4,-12(fp)
8113ba84:	11371ac0 	call	811371ac <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
8113ba88:	e0bffd17 	ldw	r2,-12(fp)
8113ba8c:	10800283 	ldbu	r2,10(r2)
8113ba90:	10803fcc 	andi	r2,r2,255
8113ba94:	103ff71e 	bne	r2,zero,8113ba74 <__reset+0xfb11ba74>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113ba98:	e0bffd17 	ldw	r2,-12(fp)
8113ba9c:	00c00fc4 	movi	r3,63
8113baa0:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113baa4:	e0bffd17 	ldw	r2,-12(fp)
8113baa8:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
8113baac:	e0bffd17 	ldw	r2,-12(fp)
8113bab0:	10800117 	ldw	r2,4(r2)
8113bab4:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
8113bab8:	d0e09c17 	ldw	r3,-32144(gp)
8113babc:	e0bff817 	ldw	r2,-32(fp)
8113bac0:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
8113bac4:	e0bff817 	ldw	r2,-32(fp)
8113bac8:	d0a09c15 	stw	r2,-32144(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113bacc:	e0bffd17 	ldw	r2,-12(fp)
8113bad0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113bad4:	d0e09f17 	ldw	r3,-32132(gp)
8113bad8:	e0bffd17 	ldw	r2,-12(fp)
8113badc:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113bae0:	e0bffd17 	ldw	r2,-12(fp)
8113bae4:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113bae8:	e0bffd17 	ldw	r2,-12(fp)
8113baec:	d0a09f15 	stw	r2,-32132(gp)
8113baf0:	e0bff617 	ldw	r2,-40(fp)
8113baf4:	e0bffa15 	stw	r2,-24(fp)
8113baf8:	e0bffa17 	ldw	r2,-24(fp)
8113bafc:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113bb00:	e0bff403 	ldbu	r2,-48(fp)
8113bb04:	10800058 	cmpnei	r2,r2,1
8113bb08:	1000011e 	bne	r2,zero,8113bb10 <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113bb0c:	1137c680 	call	81137c68 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113bb10:	e0bfff17 	ldw	r2,-4(fp)
8113bb14:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
8113bb18:	e03ff515 	stw	zero,-44(fp)
             break;
8113bb1c:	00000a06 	br	8113bb48 <OSQDel+0x270>
8113bb20:	e0bff617 	ldw	r2,-40(fp)
8113bb24:	e0bffb15 	stw	r2,-20(fp)
8113bb28:	e0bffb17 	ldw	r2,-20(fp)
8113bb2c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113bb30:	e0bfff17 	ldw	r2,-4(fp)
8113bb34:	00c001c4 	movi	r3,7
8113bb38:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113bb3c:	e0bffd17 	ldw	r2,-12(fp)
8113bb40:	e0bff515 	stw	r2,-44(fp)
             break;
8113bb44:	0001883a 	nop
    }
    return (pevent_return);
8113bb48:	e0bff517 	ldw	r2,-44(fp)
}
8113bb4c:	e037883a 	mov	sp,fp
8113bb50:	dfc00117 	ldw	ra,4(sp)
8113bb54:	df000017 	ldw	fp,0(sp)
8113bb58:	dec00204 	addi	sp,sp,8
8113bb5c:	f800283a 	ret

8113bb60 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
8113bb60:	defffa04 	addi	sp,sp,-24
8113bb64:	de00012e 	bgeu	sp,et,8113bb6c <OSQFlush+0xc>
8113bb68:	003b68fa 	trap	3
8113bb6c:	df000515 	stw	fp,20(sp)
8113bb70:	df000504 	addi	fp,sp,20
8113bb74:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113bb78:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113bb7c:	e0bfff17 	ldw	r2,-4(fp)
8113bb80:	1000021e 	bne	r2,zero,8113bb8c <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
8113bb84:	00800104 	movi	r2,4
8113bb88:	00002106 	br	8113bc10 <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113bb8c:	e0bfff17 	ldw	r2,-4(fp)
8113bb90:	10800003 	ldbu	r2,0(r2)
8113bb94:	10803fcc 	andi	r2,r2,255
8113bb98:	108000a0 	cmpeqi	r2,r2,2
8113bb9c:	1000021e 	bne	r2,zero,8113bba8 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
8113bba0:	00800044 	movi	r2,1
8113bba4:	00001a06 	br	8113bc10 <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bba8:	0005303a 	rdctl	r2,status
8113bbac:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bbb0:	e0fffd17 	ldw	r3,-12(fp)
8113bbb4:	00bfff84 	movi	r2,-2
8113bbb8:	1884703a 	and	r2,r3,r2
8113bbbc:	1001703a 	wrctl	status,r2
  
  return context;
8113bbc0:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113bbc4:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
8113bbc8:	e0bfff17 	ldw	r2,-4(fp)
8113bbcc:	10800117 	ldw	r2,4(r2)
8113bbd0:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
8113bbd4:	e0bffc17 	ldw	r2,-16(fp)
8113bbd8:	10c00117 	ldw	r3,4(r2)
8113bbdc:	e0bffc17 	ldw	r2,-16(fp)
8113bbe0:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
8113bbe4:	e0bffc17 	ldw	r2,-16(fp)
8113bbe8:	10c00117 	ldw	r3,4(r2)
8113bbec:	e0bffc17 	ldw	r2,-16(fp)
8113bbf0:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
8113bbf4:	e0bffc17 	ldw	r2,-16(fp)
8113bbf8:	1000058d 	sth	zero,22(r2)
8113bbfc:	e0bffb17 	ldw	r2,-20(fp)
8113bc00:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bc04:	e0bffe17 	ldw	r2,-8(fp)
8113bc08:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113bc0c:	0005883a 	mov	r2,zero
}
8113bc10:	e037883a 	mov	sp,fp
8113bc14:	df000017 	ldw	fp,0(sp)
8113bc18:	dec00104 	addi	sp,sp,4
8113bc1c:	f800283a 	ret

8113bc20 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113bc20:	defff304 	addi	sp,sp,-52
8113bc24:	de00012e 	bgeu	sp,et,8113bc2c <OSQPend+0xc>
8113bc28:	003b68fa 	trap	3
8113bc2c:	dfc00c15 	stw	ra,48(sp)
8113bc30:	df000b15 	stw	fp,44(sp)
8113bc34:	df000b04 	addi	fp,sp,44
8113bc38:	e13ffd15 	stw	r4,-12(fp)
8113bc3c:	2805883a 	mov	r2,r5
8113bc40:	e1bfff15 	stw	r6,-4(fp)
8113bc44:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bc48:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
8113bc4c:	e0bfff17 	ldw	r2,-4(fp)
8113bc50:	1000021e 	bne	r2,zero,8113bc5c <OSQPend+0x3c>
        return ((void *)0);
8113bc54:	0005883a 	mov	r2,zero
8113bc58:	00009106 	br	8113bea0 <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
8113bc5c:	e0bffd17 	ldw	r2,-12(fp)
8113bc60:	1000051e 	bne	r2,zero,8113bc78 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113bc64:	e0bfff17 	ldw	r2,-4(fp)
8113bc68:	00c00104 	movi	r3,4
8113bc6c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113bc70:	0005883a 	mov	r2,zero
8113bc74:	00008a06 	br	8113bea0 <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
8113bc78:	e0bffd17 	ldw	r2,-12(fp)
8113bc7c:	10800003 	ldbu	r2,0(r2)
8113bc80:	10803fcc 	andi	r2,r2,255
8113bc84:	108000a0 	cmpeqi	r2,r2,2
8113bc88:	1000051e 	bne	r2,zero,8113bca0 <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113bc8c:	e0bfff17 	ldw	r2,-4(fp)
8113bc90:	00c00044 	movi	r3,1
8113bc94:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113bc98:	0005883a 	mov	r2,zero
8113bc9c:	00008006 	br	8113bea0 <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
8113bca0:	d0a0a003 	ldbu	r2,-32128(gp)
8113bca4:	10803fcc 	andi	r2,r2,255
8113bca8:	10000526 	beq	r2,zero,8113bcc0 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
8113bcac:	e0bfff17 	ldw	r2,-4(fp)
8113bcb0:	00c00084 	movi	r3,2
8113bcb4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113bcb8:	0005883a 	mov	r2,zero
8113bcbc:	00007806 	br	8113bea0 <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
8113bcc0:	d0a08e03 	ldbu	r2,-32200(gp)
8113bcc4:	10803fcc 	andi	r2,r2,255
8113bcc8:	10000526 	beq	r2,zero,8113bce0 <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
8113bccc:	e0bfff17 	ldw	r2,-4(fp)
8113bcd0:	00c00344 	movi	r3,13
8113bcd4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
8113bcd8:	0005883a 	mov	r2,zero
8113bcdc:	00007006 	br	8113bea0 <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bce0:	0005303a 	rdctl	r2,status
8113bce4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bce8:	e0fffc17 	ldw	r3,-16(fp)
8113bcec:	00bfff84 	movi	r2,-2
8113bcf0:	1884703a 	and	r2,r3,r2
8113bcf4:	1001703a 	wrctl	status,r2
  
  return context;
8113bcf8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bcfc:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113bd00:	e0bffd17 	ldw	r2,-12(fp)
8113bd04:	10800117 	ldw	r2,4(r2)
8113bd08:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
8113bd0c:	e0bff817 	ldw	r2,-32(fp)
8113bd10:	1080058b 	ldhu	r2,22(r2)
8113bd14:	10bfffcc 	andi	r2,r2,65535
8113bd18:	10001e26 	beq	r2,zero,8113bd94 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
8113bd1c:	e0bff817 	ldw	r2,-32(fp)
8113bd20:	10800417 	ldw	r2,16(r2)
8113bd24:	11000104 	addi	r4,r2,4
8113bd28:	e0fff817 	ldw	r3,-32(fp)
8113bd2c:	19000415 	stw	r4,16(r3)
8113bd30:	10800017 	ldw	r2,0(r2)
8113bd34:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
8113bd38:	e0bff817 	ldw	r2,-32(fp)
8113bd3c:	1080058b 	ldhu	r2,22(r2)
8113bd40:	10bfffc4 	addi	r2,r2,-1
8113bd44:	1007883a 	mov	r3,r2
8113bd48:	e0bff817 	ldw	r2,-32(fp)
8113bd4c:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113bd50:	e0bff817 	ldw	r2,-32(fp)
8113bd54:	10c00417 	ldw	r3,16(r2)
8113bd58:	e0bff817 	ldw	r2,-32(fp)
8113bd5c:	10800217 	ldw	r2,8(r2)
8113bd60:	1880041e 	bne	r3,r2,8113bd74 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
8113bd64:	e0bff817 	ldw	r2,-32(fp)
8113bd68:	10c00117 	ldw	r3,4(r2)
8113bd6c:	e0bff817 	ldw	r2,-32(fp)
8113bd70:	10c00415 	stw	r3,16(r2)
8113bd74:	e0bff617 	ldw	r2,-40(fp)
8113bd78:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd7c:	e0bff717 	ldw	r2,-36(fp)
8113bd80:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113bd84:	e0bfff17 	ldw	r2,-4(fp)
8113bd88:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
8113bd8c:	e0bff517 	ldw	r2,-44(fp)
8113bd90:	00004306 	br	8113bea0 <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
8113bd94:	d0a0a117 	ldw	r2,-32124(gp)
8113bd98:	d0e0a117 	ldw	r3,-32124(gp)
8113bd9c:	18c00c03 	ldbu	r3,48(r3)
8113bda0:	18c00114 	ori	r3,r3,4
8113bda4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113bda8:	d0a0a117 	ldw	r2,-32124(gp)
8113bdac:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
8113bdb0:	d0a0a117 	ldw	r2,-32124(gp)
8113bdb4:	e0fffe0b 	ldhu	r3,-8(fp)
8113bdb8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
8113bdbc:	e13ffd17 	ldw	r4,-12(fp)
8113bdc0:	113734c0 	call	8113734c <OS_EventTaskWait>
8113bdc4:	e0bff617 	ldw	r2,-40(fp)
8113bdc8:	e0bffb15 	stw	r2,-20(fp)
8113bdcc:	e0bffb17 	ldw	r2,-20(fp)
8113bdd0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
8113bdd4:	1137c680 	call	81137c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bdd8:	0005303a 	rdctl	r2,status
8113bddc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bde0:	e0fff917 	ldw	r3,-28(fp)
8113bde4:	00bfff84 	movi	r2,-2
8113bde8:	1884703a 	and	r2,r3,r2
8113bdec:	1001703a 	wrctl	status,r2
  
  return context;
8113bdf0:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113bdf4:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113bdf8:	d0a0a117 	ldw	r2,-32124(gp)
8113bdfc:	10800c43 	ldbu	r2,49(r2)
8113be00:	10803fcc 	andi	r2,r2,255
8113be04:	10000326 	beq	r2,zero,8113be14 <OSQPend+0x1f4>
8113be08:	108000a0 	cmpeqi	r2,r2,2
8113be0c:	1000071e 	bne	r2,zero,8113be2c <OSQPend+0x20c>
8113be10:	00000b06 	br	8113be40 <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
8113be14:	d0a0a117 	ldw	r2,-32124(gp)
8113be18:	10800917 	ldw	r2,36(r2)
8113be1c:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
8113be20:	e0bfff17 	ldw	r2,-4(fp)
8113be24:	10000005 	stb	zero,0(r2)
             break;
8113be28:	00000e06 	br	8113be64 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
8113be2c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113be30:	e0bfff17 	ldw	r2,-4(fp)
8113be34:	00c00384 	movi	r3,14
8113be38:	10c00005 	stb	r3,0(r2)
             break;
8113be3c:	00000906 	br	8113be64 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
8113be40:	d0a0a117 	ldw	r2,-32124(gp)
8113be44:	e17ffd17 	ldw	r5,-12(fp)
8113be48:	1009883a 	mov	r4,r2
8113be4c:	11375bc0 	call	811375bc <OS_EventTaskRemove>
             pmsg = (void *)0;
8113be50:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113be54:	e0bfff17 	ldw	r2,-4(fp)
8113be58:	00c00284 	movi	r3,10
8113be5c:	10c00005 	stb	r3,0(r2)
             break;
8113be60:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113be64:	d0a0a117 	ldw	r2,-32124(gp)
8113be68:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113be6c:	d0a0a117 	ldw	r2,-32124(gp)
8113be70:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113be74:	d0a0a117 	ldw	r2,-32124(gp)
8113be78:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113be7c:	d0a0a117 	ldw	r2,-32124(gp)
8113be80:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
8113be84:	d0a0a117 	ldw	r2,-32124(gp)
8113be88:	10000915 	stw	zero,36(r2)
8113be8c:	e0bff617 	ldw	r2,-40(fp)
8113be90:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be94:	e0bffa17 	ldw	r2,-24(fp)
8113be98:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
8113be9c:	e0bff517 	ldw	r2,-44(fp)
}
8113bea0:	e037883a 	mov	sp,fp
8113bea4:	dfc00117 	ldw	ra,4(sp)
8113bea8:	df000017 	ldw	fp,0(sp)
8113beac:	dec00204 	addi	sp,sp,8
8113beb0:	f800283a 	ret

8113beb4 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113beb4:	defff604 	addi	sp,sp,-40
8113beb8:	de00012e 	bgeu	sp,et,8113bec0 <OSQPendAbort+0xc>
8113bebc:	003b68fa 	trap	3
8113bec0:	dfc00915 	stw	ra,36(sp)
8113bec4:	df000815 	stw	fp,32(sp)
8113bec8:	df000804 	addi	fp,sp,32
8113becc:	e13ffd15 	stw	r4,-12(fp)
8113bed0:	2805883a 	mov	r2,r5
8113bed4:	e1bfff15 	stw	r6,-4(fp)
8113bed8:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113bedc:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113bee0:	e0bfff17 	ldw	r2,-4(fp)
8113bee4:	1000021e 	bne	r2,zero,8113bef0 <OSQPendAbort+0x3c>
        return (0);
8113bee8:	0005883a 	mov	r2,zero
8113beec:	00004906 	br	8113c014 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113bef0:	e0bffd17 	ldw	r2,-12(fp)
8113bef4:	1000051e 	bne	r2,zero,8113bf0c <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113bef8:	e0bfff17 	ldw	r2,-4(fp)
8113befc:	00c00104 	movi	r3,4
8113bf00:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf04:	0005883a 	mov	r2,zero
8113bf08:	00004206 	br	8113c014 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113bf0c:	e0bffd17 	ldw	r2,-12(fp)
8113bf10:	10800003 	ldbu	r2,0(r2)
8113bf14:	10803fcc 	andi	r2,r2,255
8113bf18:	108000a0 	cmpeqi	r2,r2,2
8113bf1c:	1000051e 	bne	r2,zero,8113bf34 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113bf20:	e0bfff17 	ldw	r2,-4(fp)
8113bf24:	00c00044 	movi	r3,1
8113bf28:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf2c:	0005883a 	mov	r2,zero
8113bf30:	00003806 	br	8113c014 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf34:	0005303a 	rdctl	r2,status
8113bf38:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf3c:	e0fffc17 	ldw	r3,-16(fp)
8113bf40:	00bfff84 	movi	r2,-2
8113bf44:	1884703a 	and	r2,r3,r2
8113bf48:	1001703a 	wrctl	status,r2
  
  return context;
8113bf4c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bf50:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
8113bf54:	e0bffd17 	ldw	r2,-12(fp)
8113bf58:	10800283 	ldbu	r2,10(r2)
8113bf5c:	10803fcc 	andi	r2,r2,255
8113bf60:	10002526 	beq	r2,zero,8113bff8 <OSQPendAbort+0x144>
        nbr_tasks = 0;
8113bf64:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113bf68:	e0bffe03 	ldbu	r2,-8(fp)
8113bf6c:	10800060 	cmpeqi	r2,r2,1
8113bf70:	10000e26 	beq	r2,zero,8113bfac <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113bf74:	00000806 	br	8113bf98 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113bf78:	01c00084 	movi	r7,2
8113bf7c:	01800104 	movi	r6,4
8113bf80:	000b883a 	mov	r5,zero
8113bf84:	e13ffd17 	ldw	r4,-12(fp)
8113bf88:	11371ac0 	call	811371ac <OS_EventTaskRdy>
                     nbr_tasks++;
8113bf8c:	e0bff803 	ldbu	r2,-32(fp)
8113bf90:	10800044 	addi	r2,r2,1
8113bf94:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
8113bf98:	e0bffd17 	ldw	r2,-12(fp)
8113bf9c:	10800283 	ldbu	r2,10(r2)
8113bfa0:	10803fcc 	andi	r2,r2,255
8113bfa4:	103ff41e 	bne	r2,zero,8113bf78 <__reset+0xfb11bf78>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113bfa8:	00000906 	br	8113bfd0 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
8113bfac:	01c00084 	movi	r7,2
8113bfb0:	01800104 	movi	r6,4
8113bfb4:	000b883a 	mov	r5,zero
8113bfb8:	e13ffd17 	ldw	r4,-12(fp)
8113bfbc:	11371ac0 	call	811371ac <OS_EventTaskRdy>
                 nbr_tasks++;
8113bfc0:	e0bff803 	ldbu	r2,-32(fp)
8113bfc4:	10800044 	addi	r2,r2,1
8113bfc8:	e0bff805 	stb	r2,-32(fp)
                 break;
8113bfcc:	0001883a 	nop
8113bfd0:	e0bff917 	ldw	r2,-28(fp)
8113bfd4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bfd8:	e0bffa17 	ldw	r2,-24(fp)
8113bfdc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
8113bfe0:	1137c680 	call	81137c68 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113bfe4:	e0bfff17 	ldw	r2,-4(fp)
8113bfe8:	00c00384 	movi	r3,14
8113bfec:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113bff0:	e0bff803 	ldbu	r2,-32(fp)
8113bff4:	00000706 	br	8113c014 <OSQPendAbort+0x160>
8113bff8:	e0bff917 	ldw	r2,-28(fp)
8113bffc:	e0bffb15 	stw	r2,-20(fp)
8113c000:	e0bffb17 	ldw	r2,-20(fp)
8113c004:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c008:	e0bfff17 	ldw	r2,-4(fp)
8113c00c:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
8113c010:	0005883a 	mov	r2,zero
}
8113c014:	e037883a 	mov	sp,fp
8113c018:	dfc00117 	ldw	ra,4(sp)
8113c01c:	df000017 	ldw	fp,0(sp)
8113c020:	dec00204 	addi	sp,sp,8
8113c024:	f800283a 	ret

8113c028 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113c028:	defff604 	addi	sp,sp,-40
8113c02c:	de00012e 	bgeu	sp,et,8113c034 <OSQPost+0xc>
8113c030:	003b68fa 	trap	3
8113c034:	dfc00915 	stw	ra,36(sp)
8113c038:	df000815 	stw	fp,32(sp)
8113c03c:	df000804 	addi	fp,sp,32
8113c040:	e13ffe15 	stw	r4,-8(fp)
8113c044:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113c048:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113c04c:	e0bffe17 	ldw	r2,-8(fp)
8113c050:	1000021e 	bne	r2,zero,8113c05c <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113c054:	00800104 	movi	r2,4
8113c058:	00004a06 	br	8113c184 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113c05c:	e0bffe17 	ldw	r2,-8(fp)
8113c060:	10800003 	ldbu	r2,0(r2)
8113c064:	10803fcc 	andi	r2,r2,255
8113c068:	108000a0 	cmpeqi	r2,r2,2
8113c06c:	1000021e 	bne	r2,zero,8113c078 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113c070:	00800044 	movi	r2,1
8113c074:	00004306 	br	8113c184 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c078:	0005303a 	rdctl	r2,status
8113c07c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c080:	e0fffd17 	ldw	r3,-12(fp)
8113c084:	00bfff84 	movi	r2,-2
8113c088:	1884703a 	and	r2,r3,r2
8113c08c:	1001703a 	wrctl	status,r2
  
  return context;
8113c090:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c094:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113c098:	e0bffe17 	ldw	r2,-8(fp)
8113c09c:	10800283 	ldbu	r2,10(r2)
8113c0a0:	10803fcc 	andi	r2,r2,255
8113c0a4:	10000c26 	beq	r2,zero,8113c0d8 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113c0a8:	000f883a 	mov	r7,zero
8113c0ac:	01800104 	movi	r6,4
8113c0b0:	e17fff17 	ldw	r5,-4(fp)
8113c0b4:	e13ffe17 	ldw	r4,-8(fp)
8113c0b8:	11371ac0 	call	811371ac <OS_EventTaskRdy>
8113c0bc:	e0bff817 	ldw	r2,-32(fp)
8113c0c0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c0c4:	e0bff917 	ldw	r2,-28(fp)
8113c0c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113c0cc:	1137c680 	call	81137c68 <OS_Sched>
        return (OS_ERR_NONE);
8113c0d0:	0005883a 	mov	r2,zero
8113c0d4:	00002b06 	br	8113c184 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113c0d8:	e0bffe17 	ldw	r2,-8(fp)
8113c0dc:	10800117 	ldw	r2,4(r2)
8113c0e0:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113c0e4:	e0bffb17 	ldw	r2,-20(fp)
8113c0e8:	10c0058b 	ldhu	r3,22(r2)
8113c0ec:	e0bffb17 	ldw	r2,-20(fp)
8113c0f0:	1080050b 	ldhu	r2,20(r2)
8113c0f4:	18ffffcc 	andi	r3,r3,65535
8113c0f8:	10bfffcc 	andi	r2,r2,65535
8113c0fc:	18800636 	bltu	r3,r2,8113c118 <OSQPost+0xf0>
8113c100:	e0bff817 	ldw	r2,-32(fp)
8113c104:	e0bffa15 	stw	r2,-24(fp)
8113c108:	e0bffa17 	ldw	r2,-24(fp)
8113c10c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113c110:	00800784 	movi	r2,30
8113c114:	00001b06 	br	8113c184 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113c118:	e0bffb17 	ldw	r2,-20(fp)
8113c11c:	10800317 	ldw	r2,12(r2)
8113c120:	11000104 	addi	r4,r2,4
8113c124:	e0fffb17 	ldw	r3,-20(fp)
8113c128:	19000315 	stw	r4,12(r3)
8113c12c:	e0ffff17 	ldw	r3,-4(fp)
8113c130:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113c134:	e0bffb17 	ldw	r2,-20(fp)
8113c138:	1080058b 	ldhu	r2,22(r2)
8113c13c:	10800044 	addi	r2,r2,1
8113c140:	1007883a 	mov	r3,r2
8113c144:	e0bffb17 	ldw	r2,-20(fp)
8113c148:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113c14c:	e0bffb17 	ldw	r2,-20(fp)
8113c150:	10c00317 	ldw	r3,12(r2)
8113c154:	e0bffb17 	ldw	r2,-20(fp)
8113c158:	10800217 	ldw	r2,8(r2)
8113c15c:	1880041e 	bne	r3,r2,8113c170 <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113c160:	e0bffb17 	ldw	r2,-20(fp)
8113c164:	10c00117 	ldw	r3,4(r2)
8113c168:	e0bffb17 	ldw	r2,-20(fp)
8113c16c:	10c00315 	stw	r3,12(r2)
8113c170:	e0bff817 	ldw	r2,-32(fp)
8113c174:	e0bffc15 	stw	r2,-16(fp)
8113c178:	e0bffc17 	ldw	r2,-16(fp)
8113c17c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c180:	0005883a 	mov	r2,zero
}
8113c184:	e037883a 	mov	sp,fp
8113c188:	dfc00117 	ldw	ra,4(sp)
8113c18c:	df000017 	ldw	fp,0(sp)
8113c190:	dec00204 	addi	sp,sp,8
8113c194:	f800283a 	ret

8113c198 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113c198:	defff604 	addi	sp,sp,-40
8113c19c:	de00012e 	bgeu	sp,et,8113c1a4 <OSQPostFront+0xc>
8113c1a0:	003b68fa 	trap	3
8113c1a4:	dfc00915 	stw	ra,36(sp)
8113c1a8:	df000815 	stw	fp,32(sp)
8113c1ac:	df000804 	addi	fp,sp,32
8113c1b0:	e13ffe15 	stw	r4,-8(fp)
8113c1b4:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113c1b8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113c1bc:	e0bffe17 	ldw	r2,-8(fp)
8113c1c0:	1000021e 	bne	r2,zero,8113c1cc <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113c1c4:	00800104 	movi	r2,4
8113c1c8:	00004c06 	br	8113c2fc <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113c1cc:	e0bffe17 	ldw	r2,-8(fp)
8113c1d0:	10800003 	ldbu	r2,0(r2)
8113c1d4:	10803fcc 	andi	r2,r2,255
8113c1d8:	108000a0 	cmpeqi	r2,r2,2
8113c1dc:	1000021e 	bne	r2,zero,8113c1e8 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113c1e0:	00800044 	movi	r2,1
8113c1e4:	00004506 	br	8113c2fc <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c1e8:	0005303a 	rdctl	r2,status
8113c1ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c1f0:	e0fffd17 	ldw	r3,-12(fp)
8113c1f4:	00bfff84 	movi	r2,-2
8113c1f8:	1884703a 	and	r2,r3,r2
8113c1fc:	1001703a 	wrctl	status,r2
  
  return context;
8113c200:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c204:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113c208:	e0bffe17 	ldw	r2,-8(fp)
8113c20c:	10800283 	ldbu	r2,10(r2)
8113c210:	10803fcc 	andi	r2,r2,255
8113c214:	10000c26 	beq	r2,zero,8113c248 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113c218:	000f883a 	mov	r7,zero
8113c21c:	01800104 	movi	r6,4
8113c220:	e17fff17 	ldw	r5,-4(fp)
8113c224:	e13ffe17 	ldw	r4,-8(fp)
8113c228:	11371ac0 	call	811371ac <OS_EventTaskRdy>
8113c22c:	e0bff817 	ldw	r2,-32(fp)
8113c230:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c234:	e0bff917 	ldw	r2,-28(fp)
8113c238:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113c23c:	1137c680 	call	81137c68 <OS_Sched>
        return (OS_ERR_NONE);
8113c240:	0005883a 	mov	r2,zero
8113c244:	00002d06 	br	8113c2fc <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113c248:	e0bffe17 	ldw	r2,-8(fp)
8113c24c:	10800117 	ldw	r2,4(r2)
8113c250:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113c254:	e0bffb17 	ldw	r2,-20(fp)
8113c258:	10c0058b 	ldhu	r3,22(r2)
8113c25c:	e0bffb17 	ldw	r2,-20(fp)
8113c260:	1080050b 	ldhu	r2,20(r2)
8113c264:	18ffffcc 	andi	r3,r3,65535
8113c268:	10bfffcc 	andi	r2,r2,65535
8113c26c:	18800636 	bltu	r3,r2,8113c288 <OSQPostFront+0xf0>
8113c270:	e0bff817 	ldw	r2,-32(fp)
8113c274:	e0bffa15 	stw	r2,-24(fp)
8113c278:	e0bffa17 	ldw	r2,-24(fp)
8113c27c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113c280:	00800784 	movi	r2,30
8113c284:	00001d06 	br	8113c2fc <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113c288:	e0bffb17 	ldw	r2,-20(fp)
8113c28c:	10c00417 	ldw	r3,16(r2)
8113c290:	e0bffb17 	ldw	r2,-20(fp)
8113c294:	10800117 	ldw	r2,4(r2)
8113c298:	1880041e 	bne	r3,r2,8113c2ac <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113c29c:	e0bffb17 	ldw	r2,-20(fp)
8113c2a0:	10c00217 	ldw	r3,8(r2)
8113c2a4:	e0bffb17 	ldw	r2,-20(fp)
8113c2a8:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113c2ac:	e0bffb17 	ldw	r2,-20(fp)
8113c2b0:	10800417 	ldw	r2,16(r2)
8113c2b4:	10ffff04 	addi	r3,r2,-4
8113c2b8:	e0bffb17 	ldw	r2,-20(fp)
8113c2bc:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113c2c0:	e0bffb17 	ldw	r2,-20(fp)
8113c2c4:	10800417 	ldw	r2,16(r2)
8113c2c8:	e0ffff17 	ldw	r3,-4(fp)
8113c2cc:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113c2d0:	e0bffb17 	ldw	r2,-20(fp)
8113c2d4:	1080058b 	ldhu	r2,22(r2)
8113c2d8:	10800044 	addi	r2,r2,1
8113c2dc:	1007883a 	mov	r3,r2
8113c2e0:	e0bffb17 	ldw	r2,-20(fp)
8113c2e4:	10c0058d 	sth	r3,22(r2)
8113c2e8:	e0bff817 	ldw	r2,-32(fp)
8113c2ec:	e0bffc15 	stw	r2,-16(fp)
8113c2f0:	e0bffc17 	ldw	r2,-16(fp)
8113c2f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c2f8:	0005883a 	mov	r2,zero
}
8113c2fc:	e037883a 	mov	sp,fp
8113c300:	dfc00117 	ldw	ra,4(sp)
8113c304:	df000017 	ldw	fp,0(sp)
8113c308:	dec00204 	addi	sp,sp,8
8113c30c:	f800283a 	ret

8113c310 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113c310:	defff504 	addi	sp,sp,-44
8113c314:	de00012e 	bgeu	sp,et,8113c31c <OSQPostOpt+0xc>
8113c318:	003b68fa 	trap	3
8113c31c:	dfc00a15 	stw	ra,40(sp)
8113c320:	df000915 	stw	fp,36(sp)
8113c324:	df000904 	addi	fp,sp,36
8113c328:	e13ffd15 	stw	r4,-12(fp)
8113c32c:	e17ffe15 	stw	r5,-8(fp)
8113c330:	3005883a 	mov	r2,r6
8113c334:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113c338:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113c33c:	e0bffd17 	ldw	r2,-12(fp)
8113c340:	1000021e 	bne	r2,zero,8113c34c <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113c344:	00800104 	movi	r2,4
8113c348:	00007106 	br	8113c510 <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113c34c:	e0bffd17 	ldw	r2,-12(fp)
8113c350:	10800003 	ldbu	r2,0(r2)
8113c354:	10803fcc 	andi	r2,r2,255
8113c358:	108000a0 	cmpeqi	r2,r2,2
8113c35c:	1000021e 	bne	r2,zero,8113c368 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113c360:	00800044 	movi	r2,1
8113c364:	00006a06 	br	8113c510 <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c368:	0005303a 	rdctl	r2,status
8113c36c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c370:	e0fffc17 	ldw	r3,-16(fp)
8113c374:	00bfff84 	movi	r2,-2
8113c378:	1884703a 	and	r2,r3,r2
8113c37c:	1001703a 	wrctl	status,r2
  
  return context;
8113c380:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c384:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113c388:	e0bffd17 	ldw	r2,-12(fp)
8113c38c:	10800283 	ldbu	r2,10(r2)
8113c390:	10803fcc 	andi	r2,r2,255
8113c394:	10001d26 	beq	r2,zero,8113c40c <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113c398:	e0bfff03 	ldbu	r2,-4(fp)
8113c39c:	1080004c 	andi	r2,r2,1
8113c3a0:	10000b26 	beq	r2,zero,8113c3d0 <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113c3a4:	00000506 	br	8113c3bc <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113c3a8:	000f883a 	mov	r7,zero
8113c3ac:	01800104 	movi	r6,4
8113c3b0:	e17ffe17 	ldw	r5,-8(fp)
8113c3b4:	e13ffd17 	ldw	r4,-12(fp)
8113c3b8:	11371ac0 	call	811371ac <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113c3bc:	e0bffd17 	ldw	r2,-12(fp)
8113c3c0:	10800283 	ldbu	r2,10(r2)
8113c3c4:	10803fcc 	andi	r2,r2,255
8113c3c8:	103ff71e 	bne	r2,zero,8113c3a8 <__reset+0xfb11c3a8>
8113c3cc:	00000506 	br	8113c3e4 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113c3d0:	000f883a 	mov	r7,zero
8113c3d4:	01800104 	movi	r6,4
8113c3d8:	e17ffe17 	ldw	r5,-8(fp)
8113c3dc:	e13ffd17 	ldw	r4,-12(fp)
8113c3e0:	11371ac0 	call	811371ac <OS_EventTaskRdy>
8113c3e4:	e0bff717 	ldw	r2,-36(fp)
8113c3e8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c3ec:	e0bff817 	ldw	r2,-32(fp)
8113c3f0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113c3f4:	e0bfff03 	ldbu	r2,-4(fp)
8113c3f8:	1080010c 	andi	r2,r2,4
8113c3fc:	1000011e 	bne	r2,zero,8113c404 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113c400:	1137c680 	call	81137c68 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113c404:	0005883a 	mov	r2,zero
8113c408:	00004106 	br	8113c510 <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113c40c:	e0bffd17 	ldw	r2,-12(fp)
8113c410:	10800117 	ldw	r2,4(r2)
8113c414:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113c418:	e0bffa17 	ldw	r2,-24(fp)
8113c41c:	10c0058b 	ldhu	r3,22(r2)
8113c420:	e0bffa17 	ldw	r2,-24(fp)
8113c424:	1080050b 	ldhu	r2,20(r2)
8113c428:	18ffffcc 	andi	r3,r3,65535
8113c42c:	10bfffcc 	andi	r2,r2,65535
8113c430:	18800636 	bltu	r3,r2,8113c44c <OSQPostOpt+0x13c>
8113c434:	e0bff717 	ldw	r2,-36(fp)
8113c438:	e0bff915 	stw	r2,-28(fp)
8113c43c:	e0bff917 	ldw	r2,-28(fp)
8113c440:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113c444:	00800784 	movi	r2,30
8113c448:	00003106 	br	8113c510 <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113c44c:	e0bfff03 	ldbu	r2,-4(fp)
8113c450:	1080008c 	andi	r2,r2,2
8113c454:	10001326 	beq	r2,zero,8113c4a4 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113c458:	e0bffa17 	ldw	r2,-24(fp)
8113c45c:	10c00417 	ldw	r3,16(r2)
8113c460:	e0bffa17 	ldw	r2,-24(fp)
8113c464:	10800117 	ldw	r2,4(r2)
8113c468:	1880041e 	bne	r3,r2,8113c47c <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113c46c:	e0bffa17 	ldw	r2,-24(fp)
8113c470:	10c00217 	ldw	r3,8(r2)
8113c474:	e0bffa17 	ldw	r2,-24(fp)
8113c478:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113c47c:	e0bffa17 	ldw	r2,-24(fp)
8113c480:	10800417 	ldw	r2,16(r2)
8113c484:	10ffff04 	addi	r3,r2,-4
8113c488:	e0bffa17 	ldw	r2,-24(fp)
8113c48c:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113c490:	e0bffa17 	ldw	r2,-24(fp)
8113c494:	10800417 	ldw	r2,16(r2)
8113c498:	e0fffe17 	ldw	r3,-8(fp)
8113c49c:	10c00015 	stw	r3,0(r2)
8113c4a0:	00001006 	br	8113c4e4 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113c4a4:	e0bffa17 	ldw	r2,-24(fp)
8113c4a8:	10800317 	ldw	r2,12(r2)
8113c4ac:	11000104 	addi	r4,r2,4
8113c4b0:	e0fffa17 	ldw	r3,-24(fp)
8113c4b4:	19000315 	stw	r4,12(r3)
8113c4b8:	e0fffe17 	ldw	r3,-8(fp)
8113c4bc:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113c4c0:	e0bffa17 	ldw	r2,-24(fp)
8113c4c4:	10c00317 	ldw	r3,12(r2)
8113c4c8:	e0bffa17 	ldw	r2,-24(fp)
8113c4cc:	10800217 	ldw	r2,8(r2)
8113c4d0:	1880041e 	bne	r3,r2,8113c4e4 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113c4d4:	e0bffa17 	ldw	r2,-24(fp)
8113c4d8:	10c00117 	ldw	r3,4(r2)
8113c4dc:	e0bffa17 	ldw	r2,-24(fp)
8113c4e0:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113c4e4:	e0bffa17 	ldw	r2,-24(fp)
8113c4e8:	1080058b 	ldhu	r2,22(r2)
8113c4ec:	10800044 	addi	r2,r2,1
8113c4f0:	1007883a 	mov	r3,r2
8113c4f4:	e0bffa17 	ldw	r2,-24(fp)
8113c4f8:	10c0058d 	sth	r3,22(r2)
8113c4fc:	e0bff717 	ldw	r2,-36(fp)
8113c500:	e0bffb15 	stw	r2,-20(fp)
8113c504:	e0bffb17 	ldw	r2,-20(fp)
8113c508:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c50c:	0005883a 	mov	r2,zero
}
8113c510:	e037883a 	mov	sp,fp
8113c514:	dfc00117 	ldw	ra,4(sp)
8113c518:	df000017 	ldw	fp,0(sp)
8113c51c:	dec00204 	addi	sp,sp,8
8113c520:	f800283a 	ret

8113c524 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113c524:	defff604 	addi	sp,sp,-40
8113c528:	de00012e 	bgeu	sp,et,8113c530 <OSQQuery+0xc>
8113c52c:	003b68fa 	trap	3
8113c530:	df000915 	stw	fp,36(sp)
8113c534:	df000904 	addi	fp,sp,36
8113c538:	e13ffe15 	stw	r4,-8(fp)
8113c53c:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113c540:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113c544:	e0bffe17 	ldw	r2,-8(fp)
8113c548:	1000021e 	bne	r2,zero,8113c554 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113c54c:	00800104 	movi	r2,4
8113c550:	00004906 	br	8113c678 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113c554:	e0bfff17 	ldw	r2,-4(fp)
8113c558:	1000021e 	bne	r2,zero,8113c564 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113c55c:	00800244 	movi	r2,9
8113c560:	00004506 	br	8113c678 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113c564:	e0bffe17 	ldw	r2,-8(fp)
8113c568:	10800003 	ldbu	r2,0(r2)
8113c56c:	10803fcc 	andi	r2,r2,255
8113c570:	108000a0 	cmpeqi	r2,r2,2
8113c574:	1000021e 	bne	r2,zero,8113c580 <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113c578:	00800044 	movi	r2,1
8113c57c:	00003e06 	br	8113c678 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c580:	0005303a 	rdctl	r2,status
8113c584:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c588:	e0fffd17 	ldw	r3,-12(fp)
8113c58c:	00bfff84 	movi	r2,-2
8113c590:	1884703a 	and	r2,r3,r2
8113c594:	1001703a 	wrctl	status,r2
  
  return context;
8113c598:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113c59c:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113c5a0:	e0bffe17 	ldw	r2,-8(fp)
8113c5a4:	10c00283 	ldbu	r3,10(r2)
8113c5a8:	e0bfff17 	ldw	r2,-4(fp)
8113c5ac:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113c5b0:	e0bffe17 	ldw	r2,-8(fp)
8113c5b4:	108002c4 	addi	r2,r2,11
8113c5b8:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113c5bc:	e0bfff17 	ldw	r2,-4(fp)
8113c5c0:	10800204 	addi	r2,r2,8
8113c5c4:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113c5c8:	e03ff705 	stb	zero,-36(fp)
8113c5cc:	00000b06 	br	8113c5fc <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113c5d0:	e0bff917 	ldw	r2,-28(fp)
8113c5d4:	10c00044 	addi	r3,r2,1
8113c5d8:	e0fff915 	stw	r3,-28(fp)
8113c5dc:	e0fff817 	ldw	r3,-32(fp)
8113c5e0:	19000044 	addi	r4,r3,1
8113c5e4:	e13ff815 	stw	r4,-32(fp)
8113c5e8:	18c00003 	ldbu	r3,0(r3)
8113c5ec:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113c5f0:	e0bff703 	ldbu	r2,-36(fp)
8113c5f4:	10800044 	addi	r2,r2,1
8113c5f8:	e0bff705 	stb	r2,-36(fp)
8113c5fc:	e0bff703 	ldbu	r2,-36(fp)
8113c600:	108001b0 	cmpltui	r2,r2,6
8113c604:	103ff21e 	bne	r2,zero,8113c5d0 <__reset+0xfb11c5d0>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113c608:	e0bffe17 	ldw	r2,-8(fp)
8113c60c:	10800117 	ldw	r2,4(r2)
8113c610:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113c614:	e0bffc17 	ldw	r2,-16(fp)
8113c618:	1080058b 	ldhu	r2,22(r2)
8113c61c:	10bfffcc 	andi	r2,r2,65535
8113c620:	10000626 	beq	r2,zero,8113c63c <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113c624:	e0bffc17 	ldw	r2,-16(fp)
8113c628:	10800417 	ldw	r2,16(r2)
8113c62c:	10c00017 	ldw	r3,0(r2)
8113c630:	e0bfff17 	ldw	r2,-4(fp)
8113c634:	10c00015 	stw	r3,0(r2)
8113c638:	00000206 	br	8113c644 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113c63c:	e0bfff17 	ldw	r2,-4(fp)
8113c640:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113c644:	e0bffc17 	ldw	r2,-16(fp)
8113c648:	10c0058b 	ldhu	r3,22(r2)
8113c64c:	e0bfff17 	ldw	r2,-4(fp)
8113c650:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113c654:	e0bffc17 	ldw	r2,-16(fp)
8113c658:	10c0050b 	ldhu	r3,20(r2)
8113c65c:	e0bfff17 	ldw	r2,-4(fp)
8113c660:	10c0018d 	sth	r3,6(r2)
8113c664:	e0bffa17 	ldw	r2,-24(fp)
8113c668:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c66c:	e0bffb17 	ldw	r2,-20(fp)
8113c670:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c674:	0005883a 	mov	r2,zero
}
8113c678:	e037883a 	mov	sp,fp
8113c67c:	df000017 	ldw	fp,0(sp)
8113c680:	dec00104 	addi	sp,sp,4
8113c684:	f800283a 	ret

8113c688 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113c688:	defffb04 	addi	sp,sp,-20
8113c68c:	de00012e 	bgeu	sp,et,8113c694 <OS_QInit+0xc>
8113c690:	003b68fa 	trap	3
8113c694:	dfc00415 	stw	ra,16(sp)
8113c698:	df000315 	stw	fp,12(sp)
8113c69c:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113c6a0:	0140c004 	movi	r5,768
8113c6a4:	012045b4 	movhi	r4,33046
8113c6a8:	211b6204 	addi	r4,r4,28040
8113c6ac:	1137b9c0 	call	81137b9c <OS_MemClr>
    pq1 = &OSQTbl[0];
8113c6b0:	00a045b4 	movhi	r2,33046
8113c6b4:	109b6204 	addi	r2,r2,28040
8113c6b8:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113c6bc:	00a045b4 	movhi	r2,33046
8113c6c0:	109b6804 	addi	r2,r2,28064
8113c6c4:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113c6c8:	e03ffd0d 	sth	zero,-12(fp)
8113c6cc:	00000c06 	br	8113c700 <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113c6d0:	e0bffe17 	ldw	r2,-8(fp)
8113c6d4:	e0ffff17 	ldw	r3,-4(fp)
8113c6d8:	10c00015 	stw	r3,0(r2)
        pq1++;
8113c6dc:	e0bffe17 	ldw	r2,-8(fp)
8113c6e0:	10800604 	addi	r2,r2,24
8113c6e4:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113c6e8:	e0bfff17 	ldw	r2,-4(fp)
8113c6ec:	10800604 	addi	r2,r2,24
8113c6f0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113c6f4:	e0bffd0b 	ldhu	r2,-12(fp)
8113c6f8:	10800044 	addi	r2,r2,1
8113c6fc:	e0bffd0d 	sth	r2,-12(fp)
8113c700:	e0bffd0b 	ldhu	r2,-12(fp)
8113c704:	108007f0 	cmpltui	r2,r2,31
8113c708:	103ff11e 	bne	r2,zero,8113c6d0 <__reset+0xfb11c6d0>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113c70c:	e0bffe17 	ldw	r2,-8(fp)
8113c710:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113c714:	00a045b4 	movhi	r2,33046
8113c718:	109b6204 	addi	r2,r2,28040
8113c71c:	d0a09c15 	stw	r2,-32144(gp)
#endif
}
8113c720:	0001883a 	nop
8113c724:	e037883a 	mov	sp,fp
8113c728:	dfc00117 	ldw	ra,4(sp)
8113c72c:	df000017 	ldw	fp,0(sp)
8113c730:	dec00204 	addi	sp,sp,8
8113c734:	f800283a 	ret

8113c738 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113c738:	defffa04 	addi	sp,sp,-24
8113c73c:	de00012e 	bgeu	sp,et,8113c744 <OSSemAccept+0xc>
8113c740:	003b68fa 	trap	3
8113c744:	df000515 	stw	fp,20(sp)
8113c748:	df000504 	addi	fp,sp,20
8113c74c:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113c750:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113c754:	e0bfff17 	ldw	r2,-4(fp)
8113c758:	1000021e 	bne	r2,zero,8113c764 <OSSemAccept+0x2c>
        return (0);
8113c75c:	0005883a 	mov	r2,zero
8113c760:	00001f06 	br	8113c7e0 <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113c764:	e0bfff17 	ldw	r2,-4(fp)
8113c768:	10800003 	ldbu	r2,0(r2)
8113c76c:	10803fcc 	andi	r2,r2,255
8113c770:	108000e0 	cmpeqi	r2,r2,3
8113c774:	1000021e 	bne	r2,zero,8113c780 <OSSemAccept+0x48>
        return (0);
8113c778:	0005883a 	mov	r2,zero
8113c77c:	00001806 	br	8113c7e0 <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c780:	0005303a 	rdctl	r2,status
8113c784:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c788:	e0fffe17 	ldw	r3,-8(fp)
8113c78c:	00bfff84 	movi	r2,-2
8113c790:	1884703a 	and	r2,r3,r2
8113c794:	1001703a 	wrctl	status,r2
  
  return context;
8113c798:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113c79c:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113c7a0:	e0bfff17 	ldw	r2,-4(fp)
8113c7a4:	1080020b 	ldhu	r2,8(r2)
8113c7a8:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113c7ac:	e0bffd0b 	ldhu	r2,-12(fp)
8113c7b0:	10000626 	beq	r2,zero,8113c7cc <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113c7b4:	e0bfff17 	ldw	r2,-4(fp)
8113c7b8:	1080020b 	ldhu	r2,8(r2)
8113c7bc:	10bfffc4 	addi	r2,r2,-1
8113c7c0:	1007883a 	mov	r3,r2
8113c7c4:	e0bfff17 	ldw	r2,-4(fp)
8113c7c8:	10c0020d 	sth	r3,8(r2)
8113c7cc:	e0bffb17 	ldw	r2,-20(fp)
8113c7d0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c7d4:	e0bffc17 	ldw	r2,-16(fp)
8113c7d8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113c7dc:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113c7e0:	e037883a 	mov	sp,fp
8113c7e4:	df000017 	ldw	fp,0(sp)
8113c7e8:	dec00104 	addi	sp,sp,4
8113c7ec:	f800283a 	ret

8113c7f0 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113c7f0:	defff904 	addi	sp,sp,-28
8113c7f4:	de00012e 	bgeu	sp,et,8113c7fc <OSSemCreate+0xc>
8113c7f8:	003b68fa 	trap	3
8113c7fc:	dfc00615 	stw	ra,24(sp)
8113c800:	df000515 	stw	fp,20(sp)
8113c804:	df000504 	addi	fp,sp,20
8113c808:	2005883a 	mov	r2,r4
8113c80c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c810:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c814:	d0a0a003 	ldbu	r2,-32128(gp)
8113c818:	10803fcc 	andi	r2,r2,255
8113c81c:	10000226 	beq	r2,zero,8113c828 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113c820:	0005883a 	mov	r2,zero
8113c824:	00002506 	br	8113c8bc <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c828:	0005303a 	rdctl	r2,status
8113c82c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c830:	e0fffe17 	ldw	r3,-8(fp)
8113c834:	00bfff84 	movi	r2,-2
8113c838:	1884703a 	and	r2,r3,r2
8113c83c:	1001703a 	wrctl	status,r2
  
  return context;
8113c840:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113c844:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113c848:	d0a09f17 	ldw	r2,-32132(gp)
8113c84c:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113c850:	d0a09f17 	ldw	r2,-32132(gp)
8113c854:	10000326 	beq	r2,zero,8113c864 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113c858:	d0a09f17 	ldw	r2,-32132(gp)
8113c85c:	10800117 	ldw	r2,4(r2)
8113c860:	d0a09f15 	stw	r2,-32132(gp)
8113c864:	e0bffb17 	ldw	r2,-20(fp)
8113c868:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c86c:	e0bffc17 	ldw	r2,-16(fp)
8113c870:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113c874:	e0bffd17 	ldw	r2,-12(fp)
8113c878:	10000f26 	beq	r2,zero,8113c8b8 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113c87c:	e0bffd17 	ldw	r2,-12(fp)
8113c880:	00c000c4 	movi	r3,3
8113c884:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113c888:	e0bffd17 	ldw	r2,-12(fp)
8113c88c:	e0ffff0b 	ldhu	r3,-4(fp)
8113c890:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113c894:	e0bffd17 	ldw	r2,-12(fp)
8113c898:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113c89c:	e0bffd17 	ldw	r2,-12(fp)
8113c8a0:	00c00fc4 	movi	r3,63
8113c8a4:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113c8a8:	e0bffd17 	ldw	r2,-12(fp)
8113c8ac:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113c8b0:	e13ffd17 	ldw	r4,-12(fp)
8113c8b4:	11377840 	call	81137784 <OS_EventWaitListInit>
    }
    return (pevent);
8113c8b8:	e0bffd17 	ldw	r2,-12(fp)
}
8113c8bc:	e037883a 	mov	sp,fp
8113c8c0:	dfc00117 	ldw	ra,4(sp)
8113c8c4:	df000017 	ldw	fp,0(sp)
8113c8c8:	dec00204 	addi	sp,sp,8
8113c8cc:	f800283a 	ret

8113c8d0 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113c8d0:	defff304 	addi	sp,sp,-52
8113c8d4:	de00012e 	bgeu	sp,et,8113c8dc <OSSemDel+0xc>
8113c8d8:	003b68fa 	trap	3
8113c8dc:	dfc00c15 	stw	ra,48(sp)
8113c8e0:	df000b15 	stw	fp,44(sp)
8113c8e4:	df000b04 	addi	fp,sp,44
8113c8e8:	e13ffd15 	stw	r4,-12(fp)
8113c8ec:	2805883a 	mov	r2,r5
8113c8f0:	e1bfff15 	stw	r6,-4(fp)
8113c8f4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113c8f8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113c8fc:	e0bfff17 	ldw	r2,-4(fp)
8113c900:	1000021e 	bne	r2,zero,8113c90c <OSSemDel+0x3c>
        return (pevent);
8113c904:	e0bffd17 	ldw	r2,-12(fp)
8113c908:	00007e06 	br	8113cb04 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113c90c:	e0bffd17 	ldw	r2,-12(fp)
8113c910:	1000051e 	bne	r2,zero,8113c928 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113c914:	e0bfff17 	ldw	r2,-4(fp)
8113c918:	00c00104 	movi	r3,4
8113c91c:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c920:	e0bffd17 	ldw	r2,-12(fp)
8113c924:	00007706 	br	8113cb04 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113c928:	e0bffd17 	ldw	r2,-12(fp)
8113c92c:	10800003 	ldbu	r2,0(r2)
8113c930:	10803fcc 	andi	r2,r2,255
8113c934:	108000e0 	cmpeqi	r2,r2,3
8113c938:	1000051e 	bne	r2,zero,8113c950 <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113c93c:	e0bfff17 	ldw	r2,-4(fp)
8113c940:	00c00044 	movi	r3,1
8113c944:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c948:	e0bffd17 	ldw	r2,-12(fp)
8113c94c:	00006d06 	br	8113cb04 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113c950:	d0a0a003 	ldbu	r2,-32128(gp)
8113c954:	10803fcc 	andi	r2,r2,255
8113c958:	10000526 	beq	r2,zero,8113c970 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113c95c:	e0bfff17 	ldw	r2,-4(fp)
8113c960:	00c003c4 	movi	r3,15
8113c964:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113c968:	e0bffd17 	ldw	r2,-12(fp)
8113c96c:	00006506 	br	8113cb04 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c970:	0005303a 	rdctl	r2,status
8113c974:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c978:	e0fffc17 	ldw	r3,-16(fp)
8113c97c:	00bfff84 	movi	r2,-2
8113c980:	1884703a 	and	r2,r3,r2
8113c984:	1001703a 	wrctl	status,r2
  
  return context;
8113c988:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c98c:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113c990:	e0bffd17 	ldw	r2,-12(fp)
8113c994:	10800283 	ldbu	r2,10(r2)
8113c998:	10803fcc 	andi	r2,r2,255
8113c99c:	10000326 	beq	r2,zero,8113c9ac <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113c9a0:	00800044 	movi	r2,1
8113c9a4:	e0bff505 	stb	r2,-44(fp)
8113c9a8:	00000106 	br	8113c9b0 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113c9ac:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113c9b0:	e0bffe03 	ldbu	r2,-8(fp)
8113c9b4:	10000326 	beq	r2,zero,8113c9c4 <OSSemDel+0xf4>
8113c9b8:	10800060 	cmpeqi	r2,r2,1
8113c9bc:	1000281e 	bne	r2,zero,8113ca60 <OSSemDel+0x190>
8113c9c0:	00004506 	br	8113cad8 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113c9c4:	e0bff503 	ldbu	r2,-44(fp)
8113c9c8:	1000161e 	bne	r2,zero,8113ca24 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113c9cc:	e0bffd17 	ldw	r2,-12(fp)
8113c9d0:	00c00fc4 	movi	r3,63
8113c9d4:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113c9d8:	e0bffd17 	ldw	r2,-12(fp)
8113c9dc:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113c9e0:	e0bffd17 	ldw	r2,-12(fp)
8113c9e4:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113c9e8:	d0e09f17 	ldw	r3,-32132(gp)
8113c9ec:	e0bffd17 	ldw	r2,-12(fp)
8113c9f0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113c9f4:	e0bffd17 	ldw	r2,-12(fp)
8113c9f8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113c9fc:	e0bffd17 	ldw	r2,-12(fp)
8113ca00:	d0a09f15 	stw	r2,-32132(gp)
8113ca04:	e0bff717 	ldw	r2,-36(fp)
8113ca08:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca0c:	e0bff817 	ldw	r2,-32(fp)
8113ca10:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113ca14:	e0bfff17 	ldw	r2,-4(fp)
8113ca18:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113ca1c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113ca20:	00003706 	br	8113cb00 <OSSemDel+0x230>
8113ca24:	e0bff717 	ldw	r2,-36(fp)
8113ca28:	e0bff915 	stw	r2,-28(fp)
8113ca2c:	e0bff917 	ldw	r2,-28(fp)
8113ca30:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113ca34:	e0bfff17 	ldw	r2,-4(fp)
8113ca38:	00c01244 	movi	r3,73
8113ca3c:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113ca40:	e0bffd17 	ldw	r2,-12(fp)
8113ca44:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113ca48:	00002d06 	br	8113cb00 <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113ca4c:	000f883a 	mov	r7,zero
8113ca50:	01800044 	movi	r6,1
8113ca54:	000b883a 	mov	r5,zero
8113ca58:	e13ffd17 	ldw	r4,-12(fp)
8113ca5c:	11371ac0 	call	811371ac <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113ca60:	e0bffd17 	ldw	r2,-12(fp)
8113ca64:	10800283 	ldbu	r2,10(r2)
8113ca68:	10803fcc 	andi	r2,r2,255
8113ca6c:	103ff71e 	bne	r2,zero,8113ca4c <__reset+0xfb11ca4c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113ca70:	e0bffd17 	ldw	r2,-12(fp)
8113ca74:	00c00fc4 	movi	r3,63
8113ca78:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113ca7c:	e0bffd17 	ldw	r2,-12(fp)
8113ca80:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113ca84:	e0bffd17 	ldw	r2,-12(fp)
8113ca88:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113ca8c:	d0e09f17 	ldw	r3,-32132(gp)
8113ca90:	e0bffd17 	ldw	r2,-12(fp)
8113ca94:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113ca98:	e0bffd17 	ldw	r2,-12(fp)
8113ca9c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113caa0:	e0bffd17 	ldw	r2,-12(fp)
8113caa4:	d0a09f15 	stw	r2,-32132(gp)
8113caa8:	e0bff717 	ldw	r2,-36(fp)
8113caac:	e0bffa15 	stw	r2,-24(fp)
8113cab0:	e0bffa17 	ldw	r2,-24(fp)
8113cab4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113cab8:	e0bff503 	ldbu	r2,-44(fp)
8113cabc:	10800058 	cmpnei	r2,r2,1
8113cac0:	1000011e 	bne	r2,zero,8113cac8 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113cac4:	1137c680 	call	81137c68 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113cac8:	e0bfff17 	ldw	r2,-4(fp)
8113cacc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113cad0:	e03ff615 	stw	zero,-40(fp)
             break;
8113cad4:	00000a06 	br	8113cb00 <OSSemDel+0x230>
8113cad8:	e0bff717 	ldw	r2,-36(fp)
8113cadc:	e0bffb15 	stw	r2,-20(fp)
8113cae0:	e0bffb17 	ldw	r2,-20(fp)
8113cae4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113cae8:	e0bfff17 	ldw	r2,-4(fp)
8113caec:	00c001c4 	movi	r3,7
8113caf0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113caf4:	e0bffd17 	ldw	r2,-12(fp)
8113caf8:	e0bff615 	stw	r2,-40(fp)
             break;
8113cafc:	0001883a 	nop
    }
    return (pevent_return);
8113cb00:	e0bff617 	ldw	r2,-40(fp)
}
8113cb04:	e037883a 	mov	sp,fp
8113cb08:	dfc00117 	ldw	ra,4(sp)
8113cb0c:	df000017 	ldw	fp,0(sp)
8113cb10:	dec00204 	addi	sp,sp,8
8113cb14:	f800283a 	ret

8113cb18 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113cb18:	defff504 	addi	sp,sp,-44
8113cb1c:	de00012e 	bgeu	sp,et,8113cb24 <OSSemPend+0xc>
8113cb20:	003b68fa 	trap	3
8113cb24:	dfc00a15 	stw	ra,40(sp)
8113cb28:	df000915 	stw	fp,36(sp)
8113cb2c:	df000904 	addi	fp,sp,36
8113cb30:	e13ffd15 	stw	r4,-12(fp)
8113cb34:	2805883a 	mov	r2,r5
8113cb38:	e1bfff15 	stw	r6,-4(fp)
8113cb3c:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113cb40:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113cb44:	e0bfff17 	ldw	r2,-4(fp)
8113cb48:	10007226 	beq	r2,zero,8113cd14 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113cb4c:	e0bffd17 	ldw	r2,-12(fp)
8113cb50:	1000041e 	bne	r2,zero,8113cb64 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113cb54:	e0bfff17 	ldw	r2,-4(fp)
8113cb58:	00c00104 	movi	r3,4
8113cb5c:	10c00005 	stb	r3,0(r2)
        return;
8113cb60:	00006d06 	br	8113cd18 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113cb64:	e0bffd17 	ldw	r2,-12(fp)
8113cb68:	10800003 	ldbu	r2,0(r2)
8113cb6c:	10803fcc 	andi	r2,r2,255
8113cb70:	108000e0 	cmpeqi	r2,r2,3
8113cb74:	1000041e 	bne	r2,zero,8113cb88 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113cb78:	e0bfff17 	ldw	r2,-4(fp)
8113cb7c:	00c00044 	movi	r3,1
8113cb80:	10c00005 	stb	r3,0(r2)
        return;
8113cb84:	00006406 	br	8113cd18 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113cb88:	d0a0a003 	ldbu	r2,-32128(gp)
8113cb8c:	10803fcc 	andi	r2,r2,255
8113cb90:	10000426 	beq	r2,zero,8113cba4 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113cb94:	e0bfff17 	ldw	r2,-4(fp)
8113cb98:	00c00084 	movi	r3,2
8113cb9c:	10c00005 	stb	r3,0(r2)
        return;
8113cba0:	00005d06 	br	8113cd18 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113cba4:	d0a08e03 	ldbu	r2,-32200(gp)
8113cba8:	10803fcc 	andi	r2,r2,255
8113cbac:	10000426 	beq	r2,zero,8113cbc0 <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113cbb0:	e0bfff17 	ldw	r2,-4(fp)
8113cbb4:	00c00344 	movi	r3,13
8113cbb8:	10c00005 	stb	r3,0(r2)
        return;
8113cbbc:	00005606 	br	8113cd18 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cbc0:	0005303a 	rdctl	r2,status
8113cbc4:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cbc8:	e0fffc17 	ldw	r3,-16(fp)
8113cbcc:	00bfff84 	movi	r2,-2
8113cbd0:	1884703a 	and	r2,r3,r2
8113cbd4:	1001703a 	wrctl	status,r2
  
  return context;
8113cbd8:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cbdc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113cbe0:	e0bffd17 	ldw	r2,-12(fp)
8113cbe4:	1080020b 	ldhu	r2,8(r2)
8113cbe8:	10bfffcc 	andi	r2,r2,65535
8113cbec:	10000d26 	beq	r2,zero,8113cc24 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113cbf0:	e0bffd17 	ldw	r2,-12(fp)
8113cbf4:	1080020b 	ldhu	r2,8(r2)
8113cbf8:	10bfffc4 	addi	r2,r2,-1
8113cbfc:	1007883a 	mov	r3,r2
8113cc00:	e0bffd17 	ldw	r2,-12(fp)
8113cc04:	10c0020d 	sth	r3,8(r2)
8113cc08:	e0bff717 	ldw	r2,-36(fp)
8113cc0c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cc10:	e0bff817 	ldw	r2,-32(fp)
8113cc14:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113cc18:	e0bfff17 	ldw	r2,-4(fp)
8113cc1c:	10000005 	stb	zero,0(r2)
        return;
8113cc20:	00003d06 	br	8113cd18 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113cc24:	d0a0a117 	ldw	r2,-32124(gp)
8113cc28:	d0e0a117 	ldw	r3,-32124(gp)
8113cc2c:	18c00c03 	ldbu	r3,48(r3)
8113cc30:	18c00054 	ori	r3,r3,1
8113cc34:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113cc38:	d0a0a117 	ldw	r2,-32124(gp)
8113cc3c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113cc40:	d0a0a117 	ldw	r2,-32124(gp)
8113cc44:	e0fffe0b 	ldhu	r3,-8(fp)
8113cc48:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113cc4c:	e13ffd17 	ldw	r4,-12(fp)
8113cc50:	113734c0 	call	8113734c <OS_EventTaskWait>
8113cc54:	e0bff717 	ldw	r2,-36(fp)
8113cc58:	e0bffb15 	stw	r2,-20(fp)
8113cc5c:	e0bffb17 	ldw	r2,-20(fp)
8113cc60:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113cc64:	1137c680 	call	81137c68 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cc68:	0005303a 	rdctl	r2,status
8113cc6c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cc70:	e0fff917 	ldw	r3,-28(fp)
8113cc74:	00bfff84 	movi	r2,-2
8113cc78:	1884703a 	and	r2,r3,r2
8113cc7c:	1001703a 	wrctl	status,r2
  
  return context;
8113cc80:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113cc84:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113cc88:	d0a0a117 	ldw	r2,-32124(gp)
8113cc8c:	10800c43 	ldbu	r2,49(r2)
8113cc90:	10803fcc 	andi	r2,r2,255
8113cc94:	10000326 	beq	r2,zero,8113cca4 <OSSemPend+0x18c>
8113cc98:	108000a0 	cmpeqi	r2,r2,2
8113cc9c:	1000041e 	bne	r2,zero,8113ccb0 <OSSemPend+0x198>
8113cca0:	00000706 	br	8113ccc0 <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113cca4:	e0bfff17 	ldw	r2,-4(fp)
8113cca8:	10000005 	stb	zero,0(r2)
             break;
8113ccac:	00000c06 	br	8113cce0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113ccb0:	e0bfff17 	ldw	r2,-4(fp)
8113ccb4:	00c00384 	movi	r3,14
8113ccb8:	10c00005 	stb	r3,0(r2)
             break;
8113ccbc:	00000806 	br	8113cce0 <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ccc0:	d0a0a117 	ldw	r2,-32124(gp)
8113ccc4:	e17ffd17 	ldw	r5,-12(fp)
8113ccc8:	1009883a 	mov	r4,r2
8113cccc:	11375bc0 	call	811375bc <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113ccd0:	e0bfff17 	ldw	r2,-4(fp)
8113ccd4:	00c00284 	movi	r3,10
8113ccd8:	10c00005 	stb	r3,0(r2)
             break;
8113ccdc:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113cce0:	d0a0a117 	ldw	r2,-32124(gp)
8113cce4:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113cce8:	d0a0a117 	ldw	r2,-32124(gp)
8113ccec:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113ccf0:	d0a0a117 	ldw	r2,-32124(gp)
8113ccf4:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113ccf8:	d0a0a117 	ldw	r2,-32124(gp)
8113ccfc:	10000815 	stw	zero,32(r2)
8113cd00:	e0bff717 	ldw	r2,-36(fp)
8113cd04:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cd08:	e0bffa17 	ldw	r2,-24(fp)
8113cd0c:	1001703a 	wrctl	status,r2
8113cd10:	00000106 	br	8113cd18 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113cd14:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113cd18:	e037883a 	mov	sp,fp
8113cd1c:	dfc00117 	ldw	ra,4(sp)
8113cd20:	df000017 	ldw	fp,0(sp)
8113cd24:	dec00204 	addi	sp,sp,8
8113cd28:	f800283a 	ret

8113cd2c <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113cd2c:	defff604 	addi	sp,sp,-40
8113cd30:	de00012e 	bgeu	sp,et,8113cd38 <OSSemPendAbort+0xc>
8113cd34:	003b68fa 	trap	3
8113cd38:	dfc00915 	stw	ra,36(sp)
8113cd3c:	df000815 	stw	fp,32(sp)
8113cd40:	df000804 	addi	fp,sp,32
8113cd44:	e13ffd15 	stw	r4,-12(fp)
8113cd48:	2805883a 	mov	r2,r5
8113cd4c:	e1bfff15 	stw	r6,-4(fp)
8113cd50:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113cd54:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113cd58:	e0bfff17 	ldw	r2,-4(fp)
8113cd5c:	1000021e 	bne	r2,zero,8113cd68 <OSSemPendAbort+0x3c>
        return (0);
8113cd60:	0005883a 	mov	r2,zero
8113cd64:	00004906 	br	8113ce8c <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113cd68:	e0bffd17 	ldw	r2,-12(fp)
8113cd6c:	1000051e 	bne	r2,zero,8113cd84 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113cd70:	e0bfff17 	ldw	r2,-4(fp)
8113cd74:	00c00104 	movi	r3,4
8113cd78:	10c00005 	stb	r3,0(r2)
        return (0);
8113cd7c:	0005883a 	mov	r2,zero
8113cd80:	00004206 	br	8113ce8c <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113cd84:	e0bffd17 	ldw	r2,-12(fp)
8113cd88:	10800003 	ldbu	r2,0(r2)
8113cd8c:	10803fcc 	andi	r2,r2,255
8113cd90:	108000e0 	cmpeqi	r2,r2,3
8113cd94:	1000051e 	bne	r2,zero,8113cdac <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113cd98:	e0bfff17 	ldw	r2,-4(fp)
8113cd9c:	00c00044 	movi	r3,1
8113cda0:	10c00005 	stb	r3,0(r2)
        return (0);
8113cda4:	0005883a 	mov	r2,zero
8113cda8:	00003806 	br	8113ce8c <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cdac:	0005303a 	rdctl	r2,status
8113cdb0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cdb4:	e0fffc17 	ldw	r3,-16(fp)
8113cdb8:	00bfff84 	movi	r2,-2
8113cdbc:	1884703a 	and	r2,r3,r2
8113cdc0:	1001703a 	wrctl	status,r2
  
  return context;
8113cdc4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113cdc8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113cdcc:	e0bffd17 	ldw	r2,-12(fp)
8113cdd0:	10800283 	ldbu	r2,10(r2)
8113cdd4:	10803fcc 	andi	r2,r2,255
8113cdd8:	10002526 	beq	r2,zero,8113ce70 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113cddc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113cde0:	e0bffe03 	ldbu	r2,-8(fp)
8113cde4:	10800060 	cmpeqi	r2,r2,1
8113cde8:	10000e26 	beq	r2,zero,8113ce24 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113cdec:	00000806 	br	8113ce10 <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113cdf0:	01c00084 	movi	r7,2
8113cdf4:	01800044 	movi	r6,1
8113cdf8:	000b883a 	mov	r5,zero
8113cdfc:	e13ffd17 	ldw	r4,-12(fp)
8113ce00:	11371ac0 	call	811371ac <OS_EventTaskRdy>
                     nbr_tasks++;
8113ce04:	e0bff803 	ldbu	r2,-32(fp)
8113ce08:	10800044 	addi	r2,r2,1
8113ce0c:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113ce10:	e0bffd17 	ldw	r2,-12(fp)
8113ce14:	10800283 	ldbu	r2,10(r2)
8113ce18:	10803fcc 	andi	r2,r2,255
8113ce1c:	103ff41e 	bne	r2,zero,8113cdf0 <__reset+0xfb11cdf0>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113ce20:	00000906 	br	8113ce48 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113ce24:	01c00084 	movi	r7,2
8113ce28:	01800044 	movi	r6,1
8113ce2c:	000b883a 	mov	r5,zero
8113ce30:	e13ffd17 	ldw	r4,-12(fp)
8113ce34:	11371ac0 	call	811371ac <OS_EventTaskRdy>
                 nbr_tasks++;
8113ce38:	e0bff803 	ldbu	r2,-32(fp)
8113ce3c:	10800044 	addi	r2,r2,1
8113ce40:	e0bff805 	stb	r2,-32(fp)
                 break;
8113ce44:	0001883a 	nop
8113ce48:	e0bff917 	ldw	r2,-28(fp)
8113ce4c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ce50:	e0bffa17 	ldw	r2,-24(fp)
8113ce54:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113ce58:	1137c680 	call	81137c68 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113ce5c:	e0bfff17 	ldw	r2,-4(fp)
8113ce60:	00c00384 	movi	r3,14
8113ce64:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113ce68:	e0bff803 	ldbu	r2,-32(fp)
8113ce6c:	00000706 	br	8113ce8c <OSSemPendAbort+0x160>
8113ce70:	e0bff917 	ldw	r2,-28(fp)
8113ce74:	e0bffb15 	stw	r2,-20(fp)
8113ce78:	e0bffb17 	ldw	r2,-20(fp)
8113ce7c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ce80:	e0bfff17 	ldw	r2,-4(fp)
8113ce84:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113ce88:	0005883a 	mov	r2,zero
}
8113ce8c:	e037883a 	mov	sp,fp
8113ce90:	dfc00117 	ldw	ra,4(sp)
8113ce94:	df000017 	ldw	fp,0(sp)
8113ce98:	dec00204 	addi	sp,sp,8
8113ce9c:	f800283a 	ret

8113cea0 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113cea0:	defff804 	addi	sp,sp,-32
8113cea4:	de00012e 	bgeu	sp,et,8113ceac <OSSemPost+0xc>
8113cea8:	003b68fa 	trap	3
8113ceac:	dfc00715 	stw	ra,28(sp)
8113ceb0:	df000615 	stw	fp,24(sp)
8113ceb4:	df000604 	addi	fp,sp,24
8113ceb8:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113cebc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113cec0:	e0bfff17 	ldw	r2,-4(fp)
8113cec4:	1000021e 	bne	r2,zero,8113ced0 <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113cec8:	00800104 	movi	r2,4
8113cecc:	00003506 	br	8113cfa4 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113ced0:	e0bfff17 	ldw	r2,-4(fp)
8113ced4:	10800003 	ldbu	r2,0(r2)
8113ced8:	10803fcc 	andi	r2,r2,255
8113cedc:	108000e0 	cmpeqi	r2,r2,3
8113cee0:	1000021e 	bne	r2,zero,8113ceec <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113cee4:	00800044 	movi	r2,1
8113cee8:	00002e06 	br	8113cfa4 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ceec:	0005303a 	rdctl	r2,status
8113cef0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cef4:	e0fffe17 	ldw	r3,-8(fp)
8113cef8:	00bfff84 	movi	r2,-2
8113cefc:	1884703a 	and	r2,r3,r2
8113cf00:	1001703a 	wrctl	status,r2
  
  return context;
8113cf04:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113cf08:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113cf0c:	e0bfff17 	ldw	r2,-4(fp)
8113cf10:	10800283 	ldbu	r2,10(r2)
8113cf14:	10803fcc 	andi	r2,r2,255
8113cf18:	10000c26 	beq	r2,zero,8113cf4c <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113cf1c:	000f883a 	mov	r7,zero
8113cf20:	01800044 	movi	r6,1
8113cf24:	000b883a 	mov	r5,zero
8113cf28:	e13fff17 	ldw	r4,-4(fp)
8113cf2c:	11371ac0 	call	811371ac <OS_EventTaskRdy>
8113cf30:	e0bffa17 	ldw	r2,-24(fp)
8113cf34:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cf38:	e0bffb17 	ldw	r2,-20(fp)
8113cf3c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113cf40:	1137c680 	call	81137c68 <OS_Sched>
        return (OS_ERR_NONE);
8113cf44:	0005883a 	mov	r2,zero
8113cf48:	00001606 	br	8113cfa4 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113cf4c:	e0bfff17 	ldw	r2,-4(fp)
8113cf50:	1080020b 	ldhu	r2,8(r2)
8113cf54:	10ffffcc 	andi	r3,r2,65535
8113cf58:	00bfffd4 	movui	r2,65535
8113cf5c:	18800c26 	beq	r3,r2,8113cf90 <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113cf60:	e0bfff17 	ldw	r2,-4(fp)
8113cf64:	1080020b 	ldhu	r2,8(r2)
8113cf68:	10800044 	addi	r2,r2,1
8113cf6c:	1007883a 	mov	r3,r2
8113cf70:	e0bfff17 	ldw	r2,-4(fp)
8113cf74:	10c0020d 	sth	r3,8(r2)
8113cf78:	e0bffa17 	ldw	r2,-24(fp)
8113cf7c:	e0bffc15 	stw	r2,-16(fp)
8113cf80:	e0bffc17 	ldw	r2,-16(fp)
8113cf84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113cf88:	0005883a 	mov	r2,zero
8113cf8c:	00000506 	br	8113cfa4 <OSSemPost+0x104>
8113cf90:	e0bffa17 	ldw	r2,-24(fp)
8113cf94:	e0bffd15 	stw	r2,-12(fp)
8113cf98:	e0bffd17 	ldw	r2,-12(fp)
8113cf9c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113cfa0:	00800c84 	movi	r2,50
}
8113cfa4:	e037883a 	mov	sp,fp
8113cfa8:	dfc00117 	ldw	ra,4(sp)
8113cfac:	df000017 	ldw	fp,0(sp)
8113cfb0:	dec00204 	addi	sp,sp,8
8113cfb4:	f800283a 	ret

8113cfb8 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113cfb8:	defff704 	addi	sp,sp,-36
8113cfbc:	de00012e 	bgeu	sp,et,8113cfc4 <OSSemQuery+0xc>
8113cfc0:	003b68fa 	trap	3
8113cfc4:	df000815 	stw	fp,32(sp)
8113cfc8:	df000804 	addi	fp,sp,32
8113cfcc:	e13ffe15 	stw	r4,-8(fp)
8113cfd0:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113cfd4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113cfd8:	e0bffe17 	ldw	r2,-8(fp)
8113cfdc:	1000021e 	bne	r2,zero,8113cfe8 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113cfe0:	00800104 	movi	r2,4
8113cfe4:	00003606 	br	8113d0c0 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113cfe8:	e0bfff17 	ldw	r2,-4(fp)
8113cfec:	1000021e 	bne	r2,zero,8113cff8 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113cff0:	00800244 	movi	r2,9
8113cff4:	00003206 	br	8113d0c0 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113cff8:	e0bffe17 	ldw	r2,-8(fp)
8113cffc:	10800003 	ldbu	r2,0(r2)
8113d000:	10803fcc 	andi	r2,r2,255
8113d004:	108000e0 	cmpeqi	r2,r2,3
8113d008:	1000021e 	bne	r2,zero,8113d014 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113d00c:	00800044 	movi	r2,1
8113d010:	00002b06 	br	8113d0c0 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d014:	0005303a 	rdctl	r2,status
8113d018:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d01c:	e0fffd17 	ldw	r3,-12(fp)
8113d020:	00bfff84 	movi	r2,-2
8113d024:	1884703a 	and	r2,r3,r2
8113d028:	1001703a 	wrctl	status,r2
  
  return context;
8113d02c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113d030:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113d034:	e0bffe17 	ldw	r2,-8(fp)
8113d038:	10c00283 	ldbu	r3,10(r2)
8113d03c:	e0bfff17 	ldw	r2,-4(fp)
8113d040:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113d044:	e0bffe17 	ldw	r2,-8(fp)
8113d048:	108002c4 	addi	r2,r2,11
8113d04c:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113d050:	e0bfff17 	ldw	r2,-4(fp)
8113d054:	10800084 	addi	r2,r2,2
8113d058:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d05c:	e03ffa05 	stb	zero,-24(fp)
8113d060:	00000b06 	br	8113d090 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113d064:	e0bff917 	ldw	r2,-28(fp)
8113d068:	10c00044 	addi	r3,r2,1
8113d06c:	e0fff915 	stw	r3,-28(fp)
8113d070:	e0fff817 	ldw	r3,-32(fp)
8113d074:	19000044 	addi	r4,r3,1
8113d078:	e13ff815 	stw	r4,-32(fp)
8113d07c:	18c00003 	ldbu	r3,0(r3)
8113d080:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113d084:	e0bffa03 	ldbu	r2,-24(fp)
8113d088:	10800044 	addi	r2,r2,1
8113d08c:	e0bffa05 	stb	r2,-24(fp)
8113d090:	e0bffa03 	ldbu	r2,-24(fp)
8113d094:	108001b0 	cmpltui	r2,r2,6
8113d098:	103ff21e 	bne	r2,zero,8113d064 <__reset+0xfb11d064>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113d09c:	e0bffe17 	ldw	r2,-8(fp)
8113d0a0:	10c0020b 	ldhu	r3,8(r2)
8113d0a4:	e0bfff17 	ldw	r2,-4(fp)
8113d0a8:	10c0000d 	sth	r3,0(r2)
8113d0ac:	e0bffb17 	ldw	r2,-20(fp)
8113d0b0:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d0b4:	e0bffc17 	ldw	r2,-16(fp)
8113d0b8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113d0bc:	0005883a 	mov	r2,zero
}
8113d0c0:	e037883a 	mov	sp,fp
8113d0c4:	df000017 	ldw	fp,0(sp)
8113d0c8:	dec00104 	addi	sp,sp,4
8113d0cc:	f800283a 	ret

8113d0d0 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113d0d0:	defff904 	addi	sp,sp,-28
8113d0d4:	de00012e 	bgeu	sp,et,8113d0dc <OSSemSet+0xc>
8113d0d8:	003b68fa 	trap	3
8113d0dc:	df000615 	stw	fp,24(sp)
8113d0e0:	df000604 	addi	fp,sp,24
8113d0e4:	e13ffd15 	stw	r4,-12(fp)
8113d0e8:	2805883a 	mov	r2,r5
8113d0ec:	e1bfff15 	stw	r6,-4(fp)
8113d0f0:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113d0f4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113d0f8:	e0bfff17 	ldw	r2,-4(fp)
8113d0fc:	10003126 	beq	r2,zero,8113d1c4 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113d100:	e0bffd17 	ldw	r2,-12(fp)
8113d104:	1000041e 	bne	r2,zero,8113d118 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113d108:	e0bfff17 	ldw	r2,-4(fp)
8113d10c:	00c00104 	movi	r3,4
8113d110:	10c00005 	stb	r3,0(r2)
        return;
8113d114:	00002c06 	br	8113d1c8 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113d118:	e0bffd17 	ldw	r2,-12(fp)
8113d11c:	10800003 	ldbu	r2,0(r2)
8113d120:	10803fcc 	andi	r2,r2,255
8113d124:	108000e0 	cmpeqi	r2,r2,3
8113d128:	1000041e 	bne	r2,zero,8113d13c <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113d12c:	e0bfff17 	ldw	r2,-4(fp)
8113d130:	00c00044 	movi	r3,1
8113d134:	10c00005 	stb	r3,0(r2)
        return;
8113d138:	00002306 	br	8113d1c8 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d13c:	0005303a 	rdctl	r2,status
8113d140:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d144:	e0fffc17 	ldw	r3,-16(fp)
8113d148:	00bfff84 	movi	r2,-2
8113d14c:	1884703a 	and	r2,r3,r2
8113d150:	1001703a 	wrctl	status,r2
  
  return context;
8113d154:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113d158:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113d15c:	e0bfff17 	ldw	r2,-4(fp)
8113d160:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113d164:	e0bffd17 	ldw	r2,-12(fp)
8113d168:	1080020b 	ldhu	r2,8(r2)
8113d16c:	10bfffcc 	andi	r2,r2,65535
8113d170:	10000426 	beq	r2,zero,8113d184 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113d174:	e0bffd17 	ldw	r2,-12(fp)
8113d178:	e0fffe0b 	ldhu	r3,-8(fp)
8113d17c:	10c0020d 	sth	r3,8(r2)
8113d180:	00000b06 	br	8113d1b0 <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113d184:	e0bffd17 	ldw	r2,-12(fp)
8113d188:	10800283 	ldbu	r2,10(r2)
8113d18c:	10803fcc 	andi	r2,r2,255
8113d190:	1000041e 	bne	r2,zero,8113d1a4 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113d194:	e0bffd17 	ldw	r2,-12(fp)
8113d198:	e0fffe0b 	ldhu	r3,-8(fp)
8113d19c:	10c0020d 	sth	r3,8(r2)
8113d1a0:	00000306 	br	8113d1b0 <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113d1a4:	e0bfff17 	ldw	r2,-4(fp)
8113d1a8:	00c01244 	movi	r3,73
8113d1ac:	10c00005 	stb	r3,0(r2)
8113d1b0:	e0bffa17 	ldw	r2,-24(fp)
8113d1b4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d1b8:	e0bffb17 	ldw	r2,-20(fp)
8113d1bc:	1001703a 	wrctl	status,r2
8113d1c0:	00000106 	br	8113d1c8 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113d1c4:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113d1c8:	e037883a 	mov	sp,fp
8113d1cc:	df000017 	ldw	fp,0(sp)
8113d1d0:	dec00104 	addi	sp,sp,4
8113d1d4:	f800283a 	ret

8113d1d8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113d1d8:	defff104 	addi	sp,sp,-60
8113d1dc:	de00012e 	bgeu	sp,et,8113d1e4 <OSTaskChangePrio+0xc>
8113d1e0:	003b68fa 	trap	3
8113d1e4:	dfc00e15 	stw	ra,56(sp)
8113d1e8:	df000d15 	stw	fp,52(sp)
8113d1ec:	df000d04 	addi	fp,sp,52
8113d1f0:	2007883a 	mov	r3,r4
8113d1f4:	2805883a 	mov	r2,r5
8113d1f8:	e0fffe05 	stb	r3,-8(fp)
8113d1fc:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113d200:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113d204:	e0bffe03 	ldbu	r2,-8(fp)
8113d208:	10800ab0 	cmpltui	r2,r2,42
8113d20c:	1000051e 	bne	r2,zero,8113d224 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113d210:	e0bffe03 	ldbu	r2,-8(fp)
8113d214:	10803fe0 	cmpeqi	r2,r2,255
8113d218:	1000021e 	bne	r2,zero,8113d224 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113d21c:	00800a84 	movi	r2,42
8113d220:	00012606 	br	8113d6bc <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113d224:	e0bfff03 	ldbu	r2,-4(fp)
8113d228:	10800ab0 	cmpltui	r2,r2,42
8113d22c:	1000021e 	bne	r2,zero,8113d238 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113d230:	00800a84 	movi	r2,42
8113d234:	00012106 	br	8113d6bc <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d238:	0005303a 	rdctl	r2,status
8113d23c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d240:	e0fffd17 	ldw	r3,-12(fp)
8113d244:	00bfff84 	movi	r2,-2
8113d248:	1884703a 	and	r2,r3,r2
8113d24c:	1001703a 	wrctl	status,r2
  
  return context;
8113d250:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d254:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113d258:	e0ffff03 	ldbu	r3,-4(fp)
8113d25c:	00a045f4 	movhi	r2,33047
8113d260:	10a9d004 	addi	r2,r2,-22720
8113d264:	18c7883a 	add	r3,r3,r3
8113d268:	18c7883a 	add	r3,r3,r3
8113d26c:	10c5883a 	add	r2,r2,r3
8113d270:	10800017 	ldw	r2,0(r2)
8113d274:	10000626 	beq	r2,zero,8113d290 <OSTaskChangePrio+0xb8>
8113d278:	e0bff517 	ldw	r2,-44(fp)
8113d27c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d280:	e0bff617 	ldw	r2,-40(fp)
8113d284:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113d288:	00800a04 	movi	r2,40
8113d28c:	00010b06 	br	8113d6bc <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113d290:	e0bffe03 	ldbu	r2,-8(fp)
8113d294:	10803fd8 	cmpnei	r2,r2,255
8113d298:	1000031e 	bne	r2,zero,8113d2a8 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113d29c:	d0a0a117 	ldw	r2,-32124(gp)
8113d2a0:	10800c83 	ldbu	r2,50(r2)
8113d2a4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113d2a8:	e0fffe03 	ldbu	r3,-8(fp)
8113d2ac:	00a045f4 	movhi	r2,33047
8113d2b0:	10a9d004 	addi	r2,r2,-22720
8113d2b4:	18c7883a 	add	r3,r3,r3
8113d2b8:	18c7883a 	add	r3,r3,r3
8113d2bc:	10c5883a 	add	r2,r2,r3
8113d2c0:	10800017 	ldw	r2,0(r2)
8113d2c4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113d2c8:	e0bff817 	ldw	r2,-32(fp)
8113d2cc:	1000061e 	bne	r2,zero,8113d2e8 <OSTaskChangePrio+0x110>
8113d2d0:	e0bff517 	ldw	r2,-44(fp)
8113d2d4:	e0bff715 	stw	r2,-36(fp)
8113d2d8:	e0bff717 	ldw	r2,-36(fp)
8113d2dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113d2e0:	00800a44 	movi	r2,41
8113d2e4:	0000f506 	br	8113d6bc <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113d2e8:	e0bff817 	ldw	r2,-32(fp)
8113d2ec:	10800058 	cmpnei	r2,r2,1
8113d2f0:	1000061e 	bne	r2,zero,8113d30c <OSTaskChangePrio+0x134>
8113d2f4:	e0bff517 	ldw	r2,-44(fp)
8113d2f8:	e0bff915 	stw	r2,-28(fp)
8113d2fc:	e0bff917 	ldw	r2,-28(fp)
8113d300:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113d304:	008010c4 	movi	r2,67
8113d308:	0000ec06 	br	8113d6bc <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113d30c:	e0bfff03 	ldbu	r2,-4(fp)
8113d310:	1004d0fa 	srli	r2,r2,3
8113d314:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113d318:	e0bfff03 	ldbu	r2,-4(fp)
8113d31c:	108001cc 	andi	r2,r2,7
8113d320:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113d324:	e0bffb03 	ldbu	r2,-20(fp)
8113d328:	00c00044 	movi	r3,1
8113d32c:	1884983a 	sll	r2,r3,r2
8113d330:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113d334:	e0bffb43 	ldbu	r2,-19(fp)
8113d338:	00c00044 	movi	r3,1
8113d33c:	1884983a 	sll	r2,r3,r2
8113d340:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113d344:	e0fffe03 	ldbu	r3,-8(fp)
8113d348:	00a045f4 	movhi	r2,33047
8113d34c:	10a9d004 	addi	r2,r2,-22720
8113d350:	18c7883a 	add	r3,r3,r3
8113d354:	18c7883a 	add	r3,r3,r3
8113d358:	10c5883a 	add	r2,r2,r3
8113d35c:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113d360:	e0ffff03 	ldbu	r3,-4(fp)
8113d364:	00a045f4 	movhi	r2,33047
8113d368:	10a9d004 	addi	r2,r2,-22720
8113d36c:	18c7883a 	add	r3,r3,r3
8113d370:	18c7883a 	add	r3,r3,r3
8113d374:	10c5883a 	add	r2,r2,r3
8113d378:	e0fff817 	ldw	r3,-32(fp)
8113d37c:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113d380:	e0bff817 	ldw	r2,-32(fp)
8113d384:	10800d03 	ldbu	r2,52(r2)
8113d388:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113d38c:	e0bff817 	ldw	r2,-32(fp)
8113d390:	10800d83 	ldbu	r2,54(r2)
8113d394:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113d398:	e0bff817 	ldw	r2,-32(fp)
8113d39c:	10800d43 	ldbu	r2,53(r2)
8113d3a0:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113d3a4:	e0fffc03 	ldbu	r3,-16(fp)
8113d3a8:	d0a09d44 	addi	r2,gp,-32139
8113d3ac:	1885883a 	add	r2,r3,r2
8113d3b0:	10c00003 	ldbu	r3,0(r2)
8113d3b4:	e0bffc83 	ldbu	r2,-14(fp)
8113d3b8:	1884703a 	and	r2,r3,r2
8113d3bc:	10803fcc 	andi	r2,r2,255
8113d3c0:	10002826 	beq	r2,zero,8113d464 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113d3c4:	e0fffc03 	ldbu	r3,-16(fp)
8113d3c8:	e13ffc03 	ldbu	r4,-16(fp)
8113d3cc:	d0a09d44 	addi	r2,gp,-32139
8113d3d0:	2085883a 	add	r2,r4,r2
8113d3d4:	10800003 	ldbu	r2,0(r2)
8113d3d8:	1009883a 	mov	r4,r2
8113d3dc:	e0bffc83 	ldbu	r2,-14(fp)
8113d3e0:	0084303a 	nor	r2,zero,r2
8113d3e4:	2084703a 	and	r2,r4,r2
8113d3e8:	1009883a 	mov	r4,r2
8113d3ec:	d0a09d44 	addi	r2,gp,-32139
8113d3f0:	1885883a 	add	r2,r3,r2
8113d3f4:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113d3f8:	e0fffc03 	ldbu	r3,-16(fp)
8113d3fc:	d0a09d44 	addi	r2,gp,-32139
8113d400:	1885883a 	add	r2,r3,r2
8113d404:	10800003 	ldbu	r2,0(r2)
8113d408:	10803fcc 	andi	r2,r2,255
8113d40c:	1000061e 	bne	r2,zero,8113d428 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113d410:	e0bffc43 	ldbu	r2,-15(fp)
8113d414:	0084303a 	nor	r2,zero,r2
8113d418:	1007883a 	mov	r3,r2
8113d41c:	d0a09d03 	ldbu	r2,-32140(gp)
8113d420:	1884703a 	and	r2,r3,r2
8113d424:	d0a09d05 	stb	r2,-32140(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113d428:	d0e09d03 	ldbu	r3,-32140(gp)
8113d42c:	e0bffb83 	ldbu	r2,-18(fp)
8113d430:	1884b03a 	or	r2,r3,r2
8113d434:	d0a09d05 	stb	r2,-32140(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113d438:	e0fffb03 	ldbu	r3,-20(fp)
8113d43c:	e13ffb03 	ldbu	r4,-20(fp)
8113d440:	d0a09d44 	addi	r2,gp,-32139
8113d444:	2085883a 	add	r2,r4,r2
8113d448:	11000003 	ldbu	r4,0(r2)
8113d44c:	e0bffbc3 	ldbu	r2,-17(fp)
8113d450:	2084b03a 	or	r2,r4,r2
8113d454:	1009883a 	mov	r4,r2
8113d458:	d0a09d44 	addi	r2,gp,-32139
8113d45c:	1885883a 	add	r2,r3,r2
8113d460:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113d464:	e0bff817 	ldw	r2,-32(fp)
8113d468:	10800717 	ldw	r2,28(r2)
8113d46c:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113d470:	e0bff317 	ldw	r2,-52(fp)
8113d474:	10003326 	beq	r2,zero,8113d544 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113d478:	e0bffc03 	ldbu	r2,-16(fp)
8113d47c:	e0fffc03 	ldbu	r3,-16(fp)
8113d480:	e13ff317 	ldw	r4,-52(fp)
8113d484:	20c7883a 	add	r3,r4,r3
8113d488:	18c002c4 	addi	r3,r3,11
8113d48c:	18c00003 	ldbu	r3,0(r3)
8113d490:	1809883a 	mov	r4,r3
8113d494:	e0fffc83 	ldbu	r3,-14(fp)
8113d498:	00c6303a 	nor	r3,zero,r3
8113d49c:	20c6703a 	and	r3,r4,r3
8113d4a0:	1809883a 	mov	r4,r3
8113d4a4:	e0fff317 	ldw	r3,-52(fp)
8113d4a8:	1885883a 	add	r2,r3,r2
8113d4ac:	108002c4 	addi	r2,r2,11
8113d4b0:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113d4b4:	e0bffc03 	ldbu	r2,-16(fp)
8113d4b8:	e0fff317 	ldw	r3,-52(fp)
8113d4bc:	1885883a 	add	r2,r3,r2
8113d4c0:	108002c4 	addi	r2,r2,11
8113d4c4:	10800003 	ldbu	r2,0(r2)
8113d4c8:	10803fcc 	andi	r2,r2,255
8113d4cc:	1000091e 	bne	r2,zero,8113d4f4 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113d4d0:	e0bff317 	ldw	r2,-52(fp)
8113d4d4:	10800283 	ldbu	r2,10(r2)
8113d4d8:	1007883a 	mov	r3,r2
8113d4dc:	e0bffc43 	ldbu	r2,-15(fp)
8113d4e0:	0084303a 	nor	r2,zero,r2
8113d4e4:	1884703a 	and	r2,r3,r2
8113d4e8:	1007883a 	mov	r3,r2
8113d4ec:	e0bff317 	ldw	r2,-52(fp)
8113d4f0:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113d4f4:	e0bff317 	ldw	r2,-52(fp)
8113d4f8:	10c00283 	ldbu	r3,10(r2)
8113d4fc:	e0bffb83 	ldbu	r2,-18(fp)
8113d500:	1884b03a 	or	r2,r3,r2
8113d504:	1007883a 	mov	r3,r2
8113d508:	e0bff317 	ldw	r2,-52(fp)
8113d50c:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113d510:	e0bffb03 	ldbu	r2,-20(fp)
8113d514:	e0fffb03 	ldbu	r3,-20(fp)
8113d518:	e13ff317 	ldw	r4,-52(fp)
8113d51c:	20c7883a 	add	r3,r4,r3
8113d520:	18c002c4 	addi	r3,r3,11
8113d524:	19000003 	ldbu	r4,0(r3)
8113d528:	e0fffbc3 	ldbu	r3,-17(fp)
8113d52c:	20c6b03a 	or	r3,r4,r3
8113d530:	1809883a 	mov	r4,r3
8113d534:	e0fff317 	ldw	r3,-52(fp)
8113d538:	1885883a 	add	r2,r3,r2
8113d53c:	108002c4 	addi	r2,r2,11
8113d540:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113d544:	e0bff817 	ldw	r2,-32(fp)
8113d548:	10800817 	ldw	r2,32(r2)
8113d54c:	10004226 	beq	r2,zero,8113d658 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113d550:	e0bff817 	ldw	r2,-32(fp)
8113d554:	10800817 	ldw	r2,32(r2)
8113d558:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113d55c:	e0bff417 	ldw	r2,-48(fp)
8113d560:	10800017 	ldw	r2,0(r2)
8113d564:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113d568:	00003906 	br	8113d650 <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113d56c:	e0bffc03 	ldbu	r2,-16(fp)
8113d570:	e0fffc03 	ldbu	r3,-16(fp)
8113d574:	e13ff317 	ldw	r4,-52(fp)
8113d578:	20c7883a 	add	r3,r4,r3
8113d57c:	18c002c4 	addi	r3,r3,11
8113d580:	18c00003 	ldbu	r3,0(r3)
8113d584:	1809883a 	mov	r4,r3
8113d588:	e0fffc83 	ldbu	r3,-14(fp)
8113d58c:	00c6303a 	nor	r3,zero,r3
8113d590:	20c6703a 	and	r3,r4,r3
8113d594:	1809883a 	mov	r4,r3
8113d598:	e0fff317 	ldw	r3,-52(fp)
8113d59c:	1885883a 	add	r2,r3,r2
8113d5a0:	108002c4 	addi	r2,r2,11
8113d5a4:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113d5a8:	e0bffc03 	ldbu	r2,-16(fp)
8113d5ac:	e0fff317 	ldw	r3,-52(fp)
8113d5b0:	1885883a 	add	r2,r3,r2
8113d5b4:	108002c4 	addi	r2,r2,11
8113d5b8:	10800003 	ldbu	r2,0(r2)
8113d5bc:	10803fcc 	andi	r2,r2,255
8113d5c0:	1000091e 	bne	r2,zero,8113d5e8 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113d5c4:	e0bff317 	ldw	r2,-52(fp)
8113d5c8:	10800283 	ldbu	r2,10(r2)
8113d5cc:	1007883a 	mov	r3,r2
8113d5d0:	e0bffc43 	ldbu	r2,-15(fp)
8113d5d4:	0084303a 	nor	r2,zero,r2
8113d5d8:	1884703a 	and	r2,r3,r2
8113d5dc:	1007883a 	mov	r3,r2
8113d5e0:	e0bff317 	ldw	r2,-52(fp)
8113d5e4:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113d5e8:	e0bff317 	ldw	r2,-52(fp)
8113d5ec:	10c00283 	ldbu	r3,10(r2)
8113d5f0:	e0bffb83 	ldbu	r2,-18(fp)
8113d5f4:	1884b03a 	or	r2,r3,r2
8113d5f8:	1007883a 	mov	r3,r2
8113d5fc:	e0bff317 	ldw	r2,-52(fp)
8113d600:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113d604:	e0bffb03 	ldbu	r2,-20(fp)
8113d608:	e0fffb03 	ldbu	r3,-20(fp)
8113d60c:	e13ff317 	ldw	r4,-52(fp)
8113d610:	20c7883a 	add	r3,r4,r3
8113d614:	18c002c4 	addi	r3,r3,11
8113d618:	19000003 	ldbu	r4,0(r3)
8113d61c:	e0fffbc3 	ldbu	r3,-17(fp)
8113d620:	20c6b03a 	or	r3,r4,r3
8113d624:	1809883a 	mov	r4,r3
8113d628:	e0fff317 	ldw	r3,-52(fp)
8113d62c:	1885883a 	add	r2,r3,r2
8113d630:	108002c4 	addi	r2,r2,11
8113d634:	11000005 	stb	r4,0(r2)
            pevents++;
8113d638:	e0bff417 	ldw	r2,-48(fp)
8113d63c:	10800104 	addi	r2,r2,4
8113d640:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113d644:	e0bff417 	ldw	r2,-48(fp)
8113d648:	10800017 	ldw	r2,0(r2)
8113d64c:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113d650:	e0bff317 	ldw	r2,-52(fp)
8113d654:	103fc51e 	bne	r2,zero,8113d56c <__reset+0xfb11d56c>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113d658:	e0bff817 	ldw	r2,-32(fp)
8113d65c:	e0ffff03 	ldbu	r3,-4(fp)
8113d660:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113d664:	e0bff817 	ldw	r2,-32(fp)
8113d668:	e0fffb03 	ldbu	r3,-20(fp)
8113d66c:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113d670:	e0bff817 	ldw	r2,-32(fp)
8113d674:	e0fffb43 	ldbu	r3,-19(fp)
8113d678:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113d67c:	e0bff817 	ldw	r2,-32(fp)
8113d680:	e0fffb83 	ldbu	r3,-18(fp)
8113d684:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113d688:	e0bff817 	ldw	r2,-32(fp)
8113d68c:	e0fffbc3 	ldbu	r3,-17(fp)
8113d690:	10c00d45 	stb	r3,53(r2)
8113d694:	e0bff517 	ldw	r2,-44(fp)
8113d698:	e0bffa15 	stw	r2,-24(fp)
8113d69c:	e0bffa17 	ldw	r2,-24(fp)
8113d6a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113d6a4:	d0a09003 	ldbu	r2,-32192(gp)
8113d6a8:	10803fcc 	andi	r2,r2,255
8113d6ac:	10800058 	cmpnei	r2,r2,1
8113d6b0:	1000011e 	bne	r2,zero,8113d6b8 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113d6b4:	1137c680 	call	81137c68 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113d6b8:	0005883a 	mov	r2,zero
}
8113d6bc:	e037883a 	mov	sp,fp
8113d6c0:	dfc00117 	ldw	ra,4(sp)
8113d6c4:	df000017 	ldw	fp,0(sp)
8113d6c8:	dec00204 	addi	sp,sp,8
8113d6cc:	f800283a 	ret

8113d6d0 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113d6d0:	deffee04 	addi	sp,sp,-72
8113d6d4:	de00012e 	bgeu	sp,et,8113d6dc <OSTaskCreate+0xc>
8113d6d8:	003b68fa 	trap	3
8113d6dc:	dfc01115 	stw	ra,68(sp)
8113d6e0:	df001015 	stw	fp,64(sp)
8113d6e4:	df001004 	addi	fp,sp,64
8113d6e8:	e13ffc15 	stw	r4,-16(fp)
8113d6ec:	e17ffd15 	stw	r5,-12(fp)
8113d6f0:	e1bffe15 	stw	r6,-8(fp)
8113d6f4:	3805883a 	mov	r2,r7
8113d6f8:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113d6fc:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113d700:	e0bfff03 	ldbu	r2,-4(fp)
8113d704:	10800af0 	cmpltui	r2,r2,43
8113d708:	1000021e 	bne	r2,zero,8113d714 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113d70c:	00800a84 	movi	r2,42
8113d710:	00005706 	br	8113d870 <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d714:	0005303a 	rdctl	r2,status
8113d718:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d71c:	e0fffb17 	ldw	r3,-20(fp)
8113d720:	00bfff84 	movi	r2,-2
8113d724:	1884703a 	and	r2,r3,r2
8113d728:	1001703a 	wrctl	status,r2
  
  return context;
8113d72c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d730:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113d734:	d0a0a003 	ldbu	r2,-32128(gp)
8113d738:	10803fcc 	andi	r2,r2,255
8113d73c:	10000626 	beq	r2,zero,8113d758 <OSTaskCreate+0x88>
8113d740:	e0bff317 	ldw	r2,-52(fp)
8113d744:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d748:	e0bff417 	ldw	r2,-48(fp)
8113d74c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113d750:	00800f04 	movi	r2,60
8113d754:	00004606 	br	8113d870 <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113d758:	e0ffff03 	ldbu	r3,-4(fp)
8113d75c:	00a045f4 	movhi	r2,33047
8113d760:	10a9d004 	addi	r2,r2,-22720
8113d764:	18c7883a 	add	r3,r3,r3
8113d768:	18c7883a 	add	r3,r3,r3
8113d76c:	10c5883a 	add	r2,r2,r3
8113d770:	10800017 	ldw	r2,0(r2)
8113d774:	1000391e 	bne	r2,zero,8113d85c <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113d778:	e0ffff03 	ldbu	r3,-4(fp)
8113d77c:	00a045f4 	movhi	r2,33047
8113d780:	10a9d004 	addi	r2,r2,-22720
8113d784:	18c7883a 	add	r3,r3,r3
8113d788:	18c7883a 	add	r3,r3,r3
8113d78c:	10c5883a 	add	r2,r2,r3
8113d790:	00c00044 	movi	r3,1
8113d794:	10c00015 	stw	r3,0(r2)
8113d798:	e0bff317 	ldw	r2,-52(fp)
8113d79c:	e0bff515 	stw	r2,-44(fp)
8113d7a0:	e0bff517 	ldw	r2,-44(fp)
8113d7a4:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113d7a8:	000f883a 	mov	r7,zero
8113d7ac:	e1bffe17 	ldw	r6,-8(fp)
8113d7b0:	e17ffd17 	ldw	r5,-12(fp)
8113d7b4:	e13ffc17 	ldw	r4,-16(fp)
8113d7b8:	1148d780 	call	81148d78 <OSTaskStkInit>
8113d7bc:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113d7c0:	e0bfff03 	ldbu	r2,-4(fp)
8113d7c4:	d8000215 	stw	zero,8(sp)
8113d7c8:	d8000115 	stw	zero,4(sp)
8113d7cc:	d8000015 	stw	zero,0(sp)
8113d7d0:	000f883a 	mov	r7,zero
8113d7d4:	000d883a 	mov	r6,zero
8113d7d8:	e17ff717 	ldw	r5,-36(fp)
8113d7dc:	1009883a 	mov	r4,r2
8113d7e0:	11380b00 	call	811380b0 <OS_TCBInit>
8113d7e4:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113d7e8:	e0bff803 	ldbu	r2,-32(fp)
8113d7ec:	1000061e 	bne	r2,zero,8113d808 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113d7f0:	d0a09003 	ldbu	r2,-32192(gp)
8113d7f4:	10803fcc 	andi	r2,r2,255
8113d7f8:	10800058 	cmpnei	r2,r2,1
8113d7fc:	1000151e 	bne	r2,zero,8113d854 <OSTaskCreate+0x184>
                OS_Sched();
8113d800:	1137c680 	call	81137c68 <OS_Sched>
8113d804:	00001306 	br	8113d854 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d808:	0005303a 	rdctl	r2,status
8113d80c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d810:	e0fffa17 	ldw	r3,-24(fp)
8113d814:	00bfff84 	movi	r2,-2
8113d818:	1884703a 	and	r2,r3,r2
8113d81c:	1001703a 	wrctl	status,r2
  
  return context;
8113d820:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113d824:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113d828:	e0ffff03 	ldbu	r3,-4(fp)
8113d82c:	00a045f4 	movhi	r2,33047
8113d830:	10a9d004 	addi	r2,r2,-22720
8113d834:	18c7883a 	add	r3,r3,r3
8113d838:	18c7883a 	add	r3,r3,r3
8113d83c:	10c5883a 	add	r2,r2,r3
8113d840:	10000015 	stw	zero,0(r2)
8113d844:	e0bff317 	ldw	r2,-52(fp)
8113d848:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d84c:	e0bff617 	ldw	r2,-40(fp)
8113d850:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113d854:	e0bff803 	ldbu	r2,-32(fp)
8113d858:	00000506 	br	8113d870 <OSTaskCreate+0x1a0>
8113d85c:	e0bff317 	ldw	r2,-52(fp)
8113d860:	e0bff915 	stw	r2,-28(fp)
8113d864:	e0bff917 	ldw	r2,-28(fp)
8113d868:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113d86c:	00800a04 	movi	r2,40
}
8113d870:	e037883a 	mov	sp,fp
8113d874:	dfc00117 	ldw	ra,4(sp)
8113d878:	df000017 	ldw	fp,0(sp)
8113d87c:	dec00204 	addi	sp,sp,8
8113d880:	f800283a 	ret

8113d884 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113d884:	deffec04 	addi	sp,sp,-80
8113d888:	de00012e 	bgeu	sp,et,8113d890 <OSTaskCreateExt+0xc>
8113d88c:	003b68fa 	trap	3
8113d890:	dfc01315 	stw	ra,76(sp)
8113d894:	df001215 	stw	fp,72(sp)
8113d898:	df001204 	addi	fp,sp,72
8113d89c:	e13ffa15 	stw	r4,-24(fp)
8113d8a0:	e17ffb15 	stw	r5,-20(fp)
8113d8a4:	e1bffc15 	stw	r6,-16(fp)
8113d8a8:	3809883a 	mov	r4,r7
8113d8ac:	e0c00217 	ldw	r3,8(fp)
8113d8b0:	e0800617 	ldw	r2,24(fp)
8113d8b4:	e13ffd05 	stb	r4,-12(fp)
8113d8b8:	e0fffe0d 	sth	r3,-8(fp)
8113d8bc:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113d8c0:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113d8c4:	e0bffd03 	ldbu	r2,-12(fp)
8113d8c8:	10800af0 	cmpltui	r2,r2,43
8113d8cc:	1000021e 	bne	r2,zero,8113d8d8 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113d8d0:	00800a84 	movi	r2,42
8113d8d4:	00006106 	br	8113da5c <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d8d8:	0005303a 	rdctl	r2,status
8113d8dc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d8e0:	e0fff917 	ldw	r3,-28(fp)
8113d8e4:	00bfff84 	movi	r2,-2
8113d8e8:	1884703a 	and	r2,r3,r2
8113d8ec:	1001703a 	wrctl	status,r2
  
  return context;
8113d8f0:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113d8f4:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113d8f8:	d0a0a003 	ldbu	r2,-32128(gp)
8113d8fc:	10803fcc 	andi	r2,r2,255
8113d900:	10000626 	beq	r2,zero,8113d91c <OSTaskCreateExt+0x98>
8113d904:	e0bff117 	ldw	r2,-60(fp)
8113d908:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113d90c:	e0bff217 	ldw	r2,-56(fp)
8113d910:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113d914:	00800f04 	movi	r2,60
8113d918:	00005006 	br	8113da5c <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113d91c:	e0fffd03 	ldbu	r3,-12(fp)
8113d920:	00a045f4 	movhi	r2,33047
8113d924:	10a9d004 	addi	r2,r2,-22720
8113d928:	18c7883a 	add	r3,r3,r3
8113d92c:	18c7883a 	add	r3,r3,r3
8113d930:	10c5883a 	add	r2,r2,r3
8113d934:	10800017 	ldw	r2,0(r2)
8113d938:	1000431e 	bne	r2,zero,8113da48 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113d93c:	e0fffd03 	ldbu	r3,-12(fp)
8113d940:	00a045f4 	movhi	r2,33047
8113d944:	10a9d004 	addi	r2,r2,-22720
8113d948:	18c7883a 	add	r3,r3,r3
8113d94c:	18c7883a 	add	r3,r3,r3
8113d950:	10c5883a 	add	r2,r2,r3
8113d954:	00c00044 	movi	r3,1
8113d958:	10c00015 	stw	r3,0(r2)
8113d95c:	e0bff117 	ldw	r2,-60(fp)
8113d960:	e0bff315 	stw	r2,-52(fp)
8113d964:	e0bff317 	ldw	r2,-52(fp)
8113d968:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113d96c:	e0bfff0b 	ldhu	r2,-4(fp)
8113d970:	100d883a 	mov	r6,r2
8113d974:	e1400417 	ldw	r5,16(fp)
8113d978:	e1000317 	ldw	r4,12(fp)
8113d97c:	113e92c0 	call	8113e92c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113d980:	e0bfff0b 	ldhu	r2,-4(fp)
8113d984:	100f883a 	mov	r7,r2
8113d988:	e1bffc17 	ldw	r6,-16(fp)
8113d98c:	e17ffb17 	ldw	r5,-20(fp)
8113d990:	e13ffa17 	ldw	r4,-24(fp)
8113d994:	1148d780 	call	81148d78 <OSTaskStkInit>
8113d998:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113d99c:	e0fffd03 	ldbu	r3,-12(fp)
8113d9a0:	e13ffe0b 	ldhu	r4,-8(fp)
8113d9a4:	e0bfff0b 	ldhu	r2,-4(fp)
8113d9a8:	d8800215 	stw	r2,8(sp)
8113d9ac:	e0800517 	ldw	r2,20(fp)
8113d9b0:	d8800115 	stw	r2,4(sp)
8113d9b4:	e0800417 	ldw	r2,16(fp)
8113d9b8:	d8800015 	stw	r2,0(sp)
8113d9bc:	200f883a 	mov	r7,r4
8113d9c0:	e1800317 	ldw	r6,12(fp)
8113d9c4:	e17ff517 	ldw	r5,-44(fp)
8113d9c8:	1809883a 	mov	r4,r3
8113d9cc:	11380b00 	call	811380b0 <OS_TCBInit>
8113d9d0:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113d9d4:	e0bff603 	ldbu	r2,-40(fp)
8113d9d8:	1000061e 	bne	r2,zero,8113d9f4 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113d9dc:	d0a09003 	ldbu	r2,-32192(gp)
8113d9e0:	10803fcc 	andi	r2,r2,255
8113d9e4:	10800058 	cmpnei	r2,r2,1
8113d9e8:	1000151e 	bne	r2,zero,8113da40 <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113d9ec:	1137c680 	call	81137c68 <OS_Sched>
8113d9f0:	00001306 	br	8113da40 <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113d9f4:	0005303a 	rdctl	r2,status
8113d9f8:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113d9fc:	e0fff817 	ldw	r3,-32(fp)
8113da00:	00bfff84 	movi	r2,-2
8113da04:	1884703a 	and	r2,r3,r2
8113da08:	1001703a 	wrctl	status,r2
  
  return context;
8113da0c:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113da10:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113da14:	e0fffd03 	ldbu	r3,-12(fp)
8113da18:	00a045f4 	movhi	r2,33047
8113da1c:	10a9d004 	addi	r2,r2,-22720
8113da20:	18c7883a 	add	r3,r3,r3
8113da24:	18c7883a 	add	r3,r3,r3
8113da28:	10c5883a 	add	r2,r2,r3
8113da2c:	10000015 	stw	zero,0(r2)
8113da30:	e0bff117 	ldw	r2,-60(fp)
8113da34:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113da38:	e0bff417 	ldw	r2,-48(fp)
8113da3c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113da40:	e0bff603 	ldbu	r2,-40(fp)
8113da44:	00000506 	br	8113da5c <OSTaskCreateExt+0x1d8>
8113da48:	e0bff117 	ldw	r2,-60(fp)
8113da4c:	e0bff715 	stw	r2,-36(fp)
8113da50:	e0bff717 	ldw	r2,-36(fp)
8113da54:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113da58:	00800a04 	movi	r2,40
}
8113da5c:	e037883a 	mov	sp,fp
8113da60:	dfc00117 	ldw	ra,4(sp)
8113da64:	df000017 	ldw	fp,0(sp)
8113da68:	dec00204 	addi	sp,sp,8
8113da6c:	f800283a 	ret

8113da70 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113da70:	defff404 	addi	sp,sp,-48
8113da74:	de00012e 	bgeu	sp,et,8113da7c <OSTaskDel+0xc>
8113da78:	003b68fa 	trap	3
8113da7c:	dfc00b15 	stw	ra,44(sp)
8113da80:	df000a15 	stw	fp,40(sp)
8113da84:	df000a04 	addi	fp,sp,40
8113da88:	2005883a 	mov	r2,r4
8113da8c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113da90:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113da94:	d0a0a003 	ldbu	r2,-32128(gp)
8113da98:	10803fcc 	andi	r2,r2,255
8113da9c:	10000226 	beq	r2,zero,8113daa8 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113daa0:	00801004 	movi	r2,64
8113daa4:	0000c006 	br	8113dda8 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113daa8:	e0bfff03 	ldbu	r2,-4(fp)
8113daac:	10800a98 	cmpnei	r2,r2,42
8113dab0:	1000021e 	bne	r2,zero,8113dabc <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113dab4:	00800f84 	movi	r2,62
8113dab8:	0000bb06 	br	8113dda8 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113dabc:	e0bfff03 	ldbu	r2,-4(fp)
8113dac0:	10800ab0 	cmpltui	r2,r2,42
8113dac4:	1000051e 	bne	r2,zero,8113dadc <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113dac8:	e0bfff03 	ldbu	r2,-4(fp)
8113dacc:	10803fe0 	cmpeqi	r2,r2,255
8113dad0:	1000021e 	bne	r2,zero,8113dadc <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113dad4:	00800a84 	movi	r2,42
8113dad8:	0000b306 	br	8113dda8 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dadc:	0005303a 	rdctl	r2,status
8113dae0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dae4:	e0fffe17 	ldw	r3,-8(fp)
8113dae8:	00bfff84 	movi	r2,-2
8113daec:	1884703a 	and	r2,r3,r2
8113daf0:	1001703a 	wrctl	status,r2
  
  return context;
8113daf4:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113daf8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113dafc:	e0bfff03 	ldbu	r2,-4(fp)
8113db00:	10803fd8 	cmpnei	r2,r2,255
8113db04:	1000031e 	bne	r2,zero,8113db14 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113db08:	d0a0a117 	ldw	r2,-32124(gp)
8113db0c:	10800c83 	ldbu	r2,50(r2)
8113db10:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113db14:	e0ffff03 	ldbu	r3,-4(fp)
8113db18:	00a045f4 	movhi	r2,33047
8113db1c:	10a9d004 	addi	r2,r2,-22720
8113db20:	18c7883a 	add	r3,r3,r3
8113db24:	18c7883a 	add	r3,r3,r3
8113db28:	10c5883a 	add	r2,r2,r3
8113db2c:	10800017 	ldw	r2,0(r2)
8113db30:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113db34:	e0bff817 	ldw	r2,-32(fp)
8113db38:	1000061e 	bne	r2,zero,8113db54 <OSTaskDel+0xe4>
8113db3c:	e0bff617 	ldw	r2,-40(fp)
8113db40:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113db44:	e0bff717 	ldw	r2,-36(fp)
8113db48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113db4c:	008010c4 	movi	r2,67
8113db50:	00009506 	br	8113dda8 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113db54:	e0bff817 	ldw	r2,-32(fp)
8113db58:	10800058 	cmpnei	r2,r2,1
8113db5c:	1000061e 	bne	r2,zero,8113db78 <OSTaskDel+0x108>
8113db60:	e0bff617 	ldw	r2,-40(fp)
8113db64:	e0bff915 	stw	r2,-28(fp)
8113db68:	e0bff917 	ldw	r2,-28(fp)
8113db6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113db70:	00800f44 	movi	r2,61
8113db74:	00008c06 	br	8113dda8 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113db78:	e0bff817 	ldw	r2,-32(fp)
8113db7c:	10800d03 	ldbu	r2,52(r2)
8113db80:	10c03fcc 	andi	r3,r2,255
8113db84:	e0bff817 	ldw	r2,-32(fp)
8113db88:	10800d03 	ldbu	r2,52(r2)
8113db8c:	11003fcc 	andi	r4,r2,255
8113db90:	d0a09d44 	addi	r2,gp,-32139
8113db94:	2085883a 	add	r2,r4,r2
8113db98:	10800003 	ldbu	r2,0(r2)
8113db9c:	1009883a 	mov	r4,r2
8113dba0:	e0bff817 	ldw	r2,-32(fp)
8113dba4:	10800d43 	ldbu	r2,53(r2)
8113dba8:	0084303a 	nor	r2,zero,r2
8113dbac:	2084703a 	and	r2,r4,r2
8113dbb0:	1009883a 	mov	r4,r2
8113dbb4:	d0a09d44 	addi	r2,gp,-32139
8113dbb8:	1885883a 	add	r2,r3,r2
8113dbbc:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113dbc0:	e0bff817 	ldw	r2,-32(fp)
8113dbc4:	10800d03 	ldbu	r2,52(r2)
8113dbc8:	10c03fcc 	andi	r3,r2,255
8113dbcc:	d0a09d44 	addi	r2,gp,-32139
8113dbd0:	1885883a 	add	r2,r3,r2
8113dbd4:	10800003 	ldbu	r2,0(r2)
8113dbd8:	10803fcc 	andi	r2,r2,255
8113dbdc:	1000071e 	bne	r2,zero,8113dbfc <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113dbe0:	e0bff817 	ldw	r2,-32(fp)
8113dbe4:	10800d83 	ldbu	r2,54(r2)
8113dbe8:	0084303a 	nor	r2,zero,r2
8113dbec:	1007883a 	mov	r3,r2
8113dbf0:	d0a09d03 	ldbu	r2,-32140(gp)
8113dbf4:	1884703a 	and	r2,r3,r2
8113dbf8:	d0a09d05 	stb	r2,-32140(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113dbfc:	e0bff817 	ldw	r2,-32(fp)
8113dc00:	10800717 	ldw	r2,28(r2)
8113dc04:	10000526 	beq	r2,zero,8113dc1c <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113dc08:	e0bff817 	ldw	r2,-32(fp)
8113dc0c:	10800717 	ldw	r2,28(r2)
8113dc10:	100b883a 	mov	r5,r2
8113dc14:	e13ff817 	ldw	r4,-32(fp)
8113dc18:	11375bc0 	call	811375bc <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113dc1c:	e0bff817 	ldw	r2,-32(fp)
8113dc20:	10800817 	ldw	r2,32(r2)
8113dc24:	10000526 	beq	r2,zero,8113dc3c <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113dc28:	e0bff817 	ldw	r2,-32(fp)
8113dc2c:	10800817 	ldw	r2,32(r2)
8113dc30:	100b883a 	mov	r5,r2
8113dc34:	e13ff817 	ldw	r4,-32(fp)
8113dc38:	113767c0 	call	8113767c <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113dc3c:	e0bff817 	ldw	r2,-32(fp)
8113dc40:	10800a17 	ldw	r2,40(r2)
8113dc44:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113dc48:	e0bffb17 	ldw	r2,-20(fp)
8113dc4c:	10000226 	beq	r2,zero,8113dc58 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113dc50:	e13ffb17 	ldw	r4,-20(fp)
8113dc54:	1139c540 	call	81139c54 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113dc58:	e0bff817 	ldw	r2,-32(fp)
8113dc5c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113dc60:	e0bff817 	ldw	r2,-32(fp)
8113dc64:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113dc68:	e0bff817 	ldw	r2,-32(fp)
8113dc6c:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113dc70:	d0a08e03 	ldbu	r2,-32200(gp)
8113dc74:	10803fcc 	andi	r2,r2,255
8113dc78:	10803fe0 	cmpeqi	r2,r2,255
8113dc7c:	1000031e 	bne	r2,zero,8113dc8c <OSTaskDel+0x21c>
        OSLockNesting++;
8113dc80:	d0a08e03 	ldbu	r2,-32200(gp)
8113dc84:	10800044 	addi	r2,r2,1
8113dc88:	d0a08e05 	stb	r2,-32200(gp)
8113dc8c:	e0bff617 	ldw	r2,-40(fp)
8113dc90:	e0bffd15 	stw	r2,-12(fp)
8113dc94:	e0bffd17 	ldw	r2,-12(fp)
8113dc98:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113dc9c:	11371840 	call	81137184 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dca0:	0005303a 	rdctl	r2,status
8113dca4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dca8:	e0fffa17 	ldw	r3,-24(fp)
8113dcac:	00bfff84 	movi	r2,-2
8113dcb0:	1884703a 	and	r2,r3,r2
8113dcb4:	1001703a 	wrctl	status,r2
  
  return context;
8113dcb8:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113dcbc:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113dcc0:	d0a08e03 	ldbu	r2,-32200(gp)
8113dcc4:	10803fcc 	andi	r2,r2,255
8113dcc8:	10000326 	beq	r2,zero,8113dcd8 <OSTaskDel+0x268>
        OSLockNesting--;
8113dccc:	d0a08e03 	ldbu	r2,-32200(gp)
8113dcd0:	10bfffc4 	addi	r2,r2,-1
8113dcd4:	d0a08e05 	stb	r2,-32200(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113dcd8:	e13ff817 	ldw	r4,-32(fp)
8113dcdc:	1148f080 	call	81148f08 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113dce0:	d0a09943 	ldbu	r2,-32155(gp)
8113dce4:	10bfffc4 	addi	r2,r2,-1
8113dce8:	d0a09945 	stb	r2,-32155(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113dcec:	e0ffff03 	ldbu	r3,-4(fp)
8113dcf0:	00a045f4 	movhi	r2,33047
8113dcf4:	10a9d004 	addi	r2,r2,-22720
8113dcf8:	18c7883a 	add	r3,r3,r3
8113dcfc:	18c7883a 	add	r3,r3,r3
8113dd00:	10c5883a 	add	r2,r2,r3
8113dd04:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113dd08:	e0bff817 	ldw	r2,-32(fp)
8113dd0c:	10800617 	ldw	r2,24(r2)
8113dd10:	1000071e 	bne	r2,zero,8113dd30 <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113dd14:	e0bff817 	ldw	r2,-32(fp)
8113dd18:	10800517 	ldw	r2,20(r2)
8113dd1c:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113dd20:	e0bff817 	ldw	r2,-32(fp)
8113dd24:	10800517 	ldw	r2,20(r2)
8113dd28:	d0a09315 	stw	r2,-32180(gp)
8113dd2c:	00000a06 	br	8113dd58 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113dd30:	e0bff817 	ldw	r2,-32(fp)
8113dd34:	10800617 	ldw	r2,24(r2)
8113dd38:	e0fff817 	ldw	r3,-32(fp)
8113dd3c:	18c00517 	ldw	r3,20(r3)
8113dd40:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113dd44:	e0bff817 	ldw	r2,-32(fp)
8113dd48:	10800517 	ldw	r2,20(r2)
8113dd4c:	e0fff817 	ldw	r3,-32(fp)
8113dd50:	18c00617 	ldw	r3,24(r3)
8113dd54:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113dd58:	d0e09817 	ldw	r3,-32160(gp)
8113dd5c:	e0bff817 	ldw	r2,-32(fp)
8113dd60:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113dd64:	e0bff817 	ldw	r2,-32(fp)
8113dd68:	d0a09815 	stw	r2,-32160(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113dd6c:	e0bff817 	ldw	r2,-32(fp)
8113dd70:	00c00fc4 	movi	r3,63
8113dd74:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113dd78:	e0bff817 	ldw	r2,-32(fp)
8113dd7c:	10001345 	stb	zero,77(r2)
8113dd80:	e0bff617 	ldw	r2,-40(fp)
8113dd84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113dd88:	e0bffc17 	ldw	r2,-16(fp)
8113dd8c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113dd90:	d0a09003 	ldbu	r2,-32192(gp)
8113dd94:	10803fcc 	andi	r2,r2,255
8113dd98:	10800058 	cmpnei	r2,r2,1
8113dd9c:	1000011e 	bne	r2,zero,8113dda4 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113dda0:	1137c680 	call	81137c68 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113dda4:	0005883a 	mov	r2,zero
}
8113dda8:	e037883a 	mov	sp,fp
8113ddac:	dfc00117 	ldw	ra,4(sp)
8113ddb0:	df000017 	ldw	fp,0(sp)
8113ddb4:	dec00204 	addi	sp,sp,8
8113ddb8:	f800283a 	ret

8113ddbc <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113ddbc:	defff504 	addi	sp,sp,-44
8113ddc0:	de00012e 	bgeu	sp,et,8113ddc8 <OSTaskDelReq+0xc>
8113ddc4:	003b68fa 	trap	3
8113ddc8:	df000a15 	stw	fp,40(sp)
8113ddcc:	df000a04 	addi	fp,sp,40
8113ddd0:	2005883a 	mov	r2,r4
8113ddd4:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ddd8:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113dddc:	e0bfff03 	ldbu	r2,-4(fp)
8113dde0:	10800a98 	cmpnei	r2,r2,42
8113dde4:	1000021e 	bne	r2,zero,8113ddf0 <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113dde8:	00800f84 	movi	r2,62
8113ddec:	00004506 	br	8113df04 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113ddf0:	e0bfff03 	ldbu	r2,-4(fp)
8113ddf4:	10800ab0 	cmpltui	r2,r2,42
8113ddf8:	1000051e 	bne	r2,zero,8113de10 <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113ddfc:	e0bfff03 	ldbu	r2,-4(fp)
8113de00:	10803fe0 	cmpeqi	r2,r2,255
8113de04:	1000021e 	bne	r2,zero,8113de10 <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113de08:	00800a84 	movi	r2,42
8113de0c:	00003d06 	br	8113df04 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113de10:	e0bfff03 	ldbu	r2,-4(fp)
8113de14:	10803fd8 	cmpnei	r2,r2,255
8113de18:	1000111e 	bne	r2,zero,8113de60 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113de1c:	0005303a 	rdctl	r2,status
8113de20:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113de24:	e0fff917 	ldw	r3,-28(fp)
8113de28:	00bfff84 	movi	r2,-2
8113de2c:	1884703a 	and	r2,r3,r2
8113de30:	1001703a 	wrctl	status,r2
  
  return context;
8113de34:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113de38:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113de3c:	d0a0a117 	ldw	r2,-32124(gp)
8113de40:	10800dc3 	ldbu	r2,55(r2)
8113de44:	e0bff805 	stb	r2,-32(fp)
8113de48:	e0bff617 	ldw	r2,-40(fp)
8113de4c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113de50:	e0bffe17 	ldw	r2,-8(fp)
8113de54:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113de58:	e0bff803 	ldbu	r2,-32(fp)
8113de5c:	00002906 	br	8113df04 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113de60:	0005303a 	rdctl	r2,status
8113de64:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113de68:	e0fff717 	ldw	r3,-36(fp)
8113de6c:	00bfff84 	movi	r2,-2
8113de70:	1884703a 	and	r2,r3,r2
8113de74:	1001703a 	wrctl	status,r2
  
  return context;
8113de78:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113de7c:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113de80:	e0ffff03 	ldbu	r3,-4(fp)
8113de84:	00a045f4 	movhi	r2,33047
8113de88:	10a9d004 	addi	r2,r2,-22720
8113de8c:	18c7883a 	add	r3,r3,r3
8113de90:	18c7883a 	add	r3,r3,r3
8113de94:	10c5883a 	add	r2,r2,r3
8113de98:	10800017 	ldw	r2,0(r2)
8113de9c:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113dea0:	e0bffb17 	ldw	r2,-20(fp)
8113dea4:	1000061e 	bne	r2,zero,8113dec0 <OSTaskDelReq+0x104>
8113dea8:	e0bff617 	ldw	r2,-40(fp)
8113deac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113deb0:	e0bffa17 	ldw	r2,-24(fp)
8113deb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113deb8:	008010c4 	movi	r2,67
8113debc:	00001106 	br	8113df04 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113dec0:	e0bffb17 	ldw	r2,-20(fp)
8113dec4:	10800058 	cmpnei	r2,r2,1
8113dec8:	1000061e 	bne	r2,zero,8113dee4 <OSTaskDelReq+0x128>
8113decc:	e0bff617 	ldw	r2,-40(fp)
8113ded0:	e0bffc15 	stw	r2,-16(fp)
8113ded4:	e0bffc17 	ldw	r2,-16(fp)
8113ded8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113dedc:	00800f44 	movi	r2,61
8113dee0:	00000806 	br	8113df04 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113dee4:	e0bffb17 	ldw	r2,-20(fp)
8113dee8:	00c00fc4 	movi	r3,63
8113deec:	10c00dc5 	stb	r3,55(r2)
8113def0:	e0bff617 	ldw	r2,-40(fp)
8113def4:	e0bffd15 	stw	r2,-12(fp)
8113def8:	e0bffd17 	ldw	r2,-12(fp)
8113defc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113df00:	0005883a 	mov	r2,zero
}
8113df04:	e037883a 	mov	sp,fp
8113df08:	df000017 	ldw	fp,0(sp)
8113df0c:	dec00104 	addi	sp,sp,4
8113df10:	f800283a 	ret

8113df14 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113df14:	defff404 	addi	sp,sp,-48
8113df18:	de00012e 	bgeu	sp,et,8113df20 <OSTaskNameGet+0xc>
8113df1c:	003b68fa 	trap	3
8113df20:	dfc00b15 	stw	ra,44(sp)
8113df24:	df000a15 	stw	fp,40(sp)
8113df28:	df000a04 	addi	fp,sp,40
8113df2c:	2005883a 	mov	r2,r4
8113df30:	e17ffe15 	stw	r5,-8(fp)
8113df34:	e1bfff15 	stw	r6,-4(fp)
8113df38:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113df3c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113df40:	e0bfff17 	ldw	r2,-4(fp)
8113df44:	1000021e 	bne	r2,zero,8113df50 <OSTaskNameGet+0x3c>
        return (0);
8113df48:	0005883a 	mov	r2,zero
8113df4c:	00005406 	br	8113e0a0 <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113df50:	e0bffd03 	ldbu	r2,-12(fp)
8113df54:	10800af0 	cmpltui	r2,r2,43
8113df58:	1000081e 	bne	r2,zero,8113df7c <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113df5c:	e0bffd03 	ldbu	r2,-12(fp)
8113df60:	10803fe0 	cmpeqi	r2,r2,255
8113df64:	1000051e 	bne	r2,zero,8113df7c <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113df68:	e0bfff17 	ldw	r2,-4(fp)
8113df6c:	00c00a84 	movi	r3,42
8113df70:	10c00005 	stb	r3,0(r2)
            return (0);
8113df74:	0005883a 	mov	r2,zero
8113df78:	00004906 	br	8113e0a0 <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113df7c:	e0bffe17 	ldw	r2,-8(fp)
8113df80:	1000051e 	bne	r2,zero,8113df98 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113df84:	e0bfff17 	ldw	r2,-4(fp)
8113df88:	00c00304 	movi	r3,12
8113df8c:	10c00005 	stb	r3,0(r2)
        return (0);
8113df90:	0005883a 	mov	r2,zero
8113df94:	00004206 	br	8113e0a0 <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113df98:	d0a0a003 	ldbu	r2,-32128(gp)
8113df9c:	10803fcc 	andi	r2,r2,255
8113dfa0:	10000526 	beq	r2,zero,8113dfb8 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113dfa4:	e0bfff17 	ldw	r2,-4(fp)
8113dfa8:	00c00444 	movi	r3,17
8113dfac:	10c00005 	stb	r3,0(r2)
        return (0);
8113dfb0:	0005883a 	mov	r2,zero
8113dfb4:	00003a06 	br	8113e0a0 <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113dfb8:	0005303a 	rdctl	r2,status
8113dfbc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113dfc0:	e0fffc17 	ldw	r3,-16(fp)
8113dfc4:	00bfff84 	movi	r2,-2
8113dfc8:	1884703a 	and	r2,r3,r2
8113dfcc:	1001703a 	wrctl	status,r2
  
  return context;
8113dfd0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113dfd4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113dfd8:	e0bffd03 	ldbu	r2,-12(fp)
8113dfdc:	10803fd8 	cmpnei	r2,r2,255
8113dfe0:	1000031e 	bne	r2,zero,8113dff0 <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113dfe4:	d0a0a117 	ldw	r2,-32124(gp)
8113dfe8:	10800c83 	ldbu	r2,50(r2)
8113dfec:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113dff0:	e0fffd03 	ldbu	r3,-12(fp)
8113dff4:	00a045f4 	movhi	r2,33047
8113dff8:	10a9d004 	addi	r2,r2,-22720
8113dffc:	18c7883a 	add	r3,r3,r3
8113e000:	18c7883a 	add	r3,r3,r3
8113e004:	10c5883a 	add	r2,r2,r3
8113e008:	10800017 	ldw	r2,0(r2)
8113e00c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113e010:	e0bff817 	ldw	r2,-32(fp)
8113e014:	1000091e 	bne	r2,zero,8113e03c <OSTaskNameGet+0x128>
8113e018:	e0bff617 	ldw	r2,-40(fp)
8113e01c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e020:	e0bff717 	ldw	r2,-36(fp)
8113e024:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113e028:	e0bfff17 	ldw	r2,-4(fp)
8113e02c:	00c010c4 	movi	r3,67
8113e030:	10c00005 	stb	r3,0(r2)
        return (0);
8113e034:	0005883a 	mov	r2,zero
8113e038:	00001906 	br	8113e0a0 <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113e03c:	e0bff817 	ldw	r2,-32(fp)
8113e040:	10800058 	cmpnei	r2,r2,1
8113e044:	1000091e 	bne	r2,zero,8113e06c <OSTaskNameGet+0x158>
8113e048:	e0bff617 	ldw	r2,-40(fp)
8113e04c:	e0bff915 	stw	r2,-28(fp)
8113e050:	e0bff917 	ldw	r2,-28(fp)
8113e054:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113e058:	e0bfff17 	ldw	r2,-4(fp)
8113e05c:	00c010c4 	movi	r3,67
8113e060:	10c00005 	stb	r3,0(r2)
        return (0);
8113e064:	0005883a 	mov	r2,zero
8113e068:	00000d06 	br	8113e0a0 <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113e06c:	e0bff817 	ldw	r2,-32(fp)
8113e070:	10801304 	addi	r2,r2,76
8113e074:	100b883a 	mov	r5,r2
8113e078:	e13ffe17 	ldw	r4,-8(fp)
8113e07c:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113e080:	e0bffb05 	stb	r2,-20(fp)
8113e084:	e0bff617 	ldw	r2,-40(fp)
8113e088:	e0bffa15 	stw	r2,-24(fp)
8113e08c:	e0bffa17 	ldw	r2,-24(fp)
8113e090:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e094:	e0bfff17 	ldw	r2,-4(fp)
8113e098:	10000005 	stb	zero,0(r2)
    return (len);
8113e09c:	e0bffb03 	ldbu	r2,-20(fp)
}
8113e0a0:	e037883a 	mov	sp,fp
8113e0a4:	dfc00117 	ldw	ra,4(sp)
8113e0a8:	df000017 	ldw	fp,0(sp)
8113e0ac:	dec00204 	addi	sp,sp,8
8113e0b0:	f800283a 	ret

8113e0b4 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113e0b4:	defff304 	addi	sp,sp,-52
8113e0b8:	de00012e 	bgeu	sp,et,8113e0c0 <OSTaskNameSet+0xc>
8113e0bc:	003b68fa 	trap	3
8113e0c0:	dfc00c15 	stw	ra,48(sp)
8113e0c4:	df000b15 	stw	fp,44(sp)
8113e0c8:	df000b04 	addi	fp,sp,44
8113e0cc:	2005883a 	mov	r2,r4
8113e0d0:	e17ffe15 	stw	r5,-8(fp)
8113e0d4:	e1bfff15 	stw	r6,-4(fp)
8113e0d8:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113e0dc:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113e0e0:	e0bfff17 	ldw	r2,-4(fp)
8113e0e4:	10005c26 	beq	r2,zero,8113e258 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113e0e8:	e0bffd03 	ldbu	r2,-12(fp)
8113e0ec:	10800af0 	cmpltui	r2,r2,43
8113e0f0:	1000071e 	bne	r2,zero,8113e110 <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113e0f4:	e0bffd03 	ldbu	r2,-12(fp)
8113e0f8:	10803fe0 	cmpeqi	r2,r2,255
8113e0fc:	1000041e 	bne	r2,zero,8113e110 <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113e100:	e0bfff17 	ldw	r2,-4(fp)
8113e104:	00c00a84 	movi	r3,42
8113e108:	10c00005 	stb	r3,0(r2)
            return;
8113e10c:	00005306 	br	8113e25c <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113e110:	e0bffe17 	ldw	r2,-8(fp)
8113e114:	1000041e 	bne	r2,zero,8113e128 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113e118:	e0bfff17 	ldw	r2,-4(fp)
8113e11c:	00c00304 	movi	r3,12
8113e120:	10c00005 	stb	r3,0(r2)
        return;
8113e124:	00004d06 	br	8113e25c <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113e128:	d0a0a003 	ldbu	r2,-32128(gp)
8113e12c:	10803fcc 	andi	r2,r2,255
8113e130:	10000426 	beq	r2,zero,8113e144 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113e134:	e0bfff17 	ldw	r2,-4(fp)
8113e138:	00c00484 	movi	r3,18
8113e13c:	10c00005 	stb	r3,0(r2)
        return;
8113e140:	00004606 	br	8113e25c <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e144:	0005303a 	rdctl	r2,status
8113e148:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e14c:	e0fffc17 	ldw	r3,-16(fp)
8113e150:	00bfff84 	movi	r2,-2
8113e154:	1884703a 	and	r2,r3,r2
8113e158:	1001703a 	wrctl	status,r2
  
  return context;
8113e15c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113e160:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113e164:	e0bffd03 	ldbu	r2,-12(fp)
8113e168:	10803fd8 	cmpnei	r2,r2,255
8113e16c:	1000031e 	bne	r2,zero,8113e17c <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113e170:	d0a0a117 	ldw	r2,-32124(gp)
8113e174:	10800c83 	ldbu	r2,50(r2)
8113e178:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113e17c:	e0fffd03 	ldbu	r3,-12(fp)
8113e180:	00a045f4 	movhi	r2,33047
8113e184:	10a9d004 	addi	r2,r2,-22720
8113e188:	18c7883a 	add	r3,r3,r3
8113e18c:	18c7883a 	add	r3,r3,r3
8113e190:	10c5883a 	add	r2,r2,r3
8113e194:	10800017 	ldw	r2,0(r2)
8113e198:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113e19c:	e0bff717 	ldw	r2,-36(fp)
8113e1a0:	1000081e 	bne	r2,zero,8113e1c4 <OSTaskNameSet+0x110>
8113e1a4:	e0bff517 	ldw	r2,-44(fp)
8113e1a8:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e1ac:	e0bff617 	ldw	r2,-40(fp)
8113e1b0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113e1b4:	e0bfff17 	ldw	r2,-4(fp)
8113e1b8:	00c010c4 	movi	r3,67
8113e1bc:	10c00005 	stb	r3,0(r2)
        return;
8113e1c0:	00002606 	br	8113e25c <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113e1c4:	e0bff717 	ldw	r2,-36(fp)
8113e1c8:	10800058 	cmpnei	r2,r2,1
8113e1cc:	1000081e 	bne	r2,zero,8113e1f0 <OSTaskNameSet+0x13c>
8113e1d0:	e0bff517 	ldw	r2,-44(fp)
8113e1d4:	e0bff815 	stw	r2,-32(fp)
8113e1d8:	e0bff817 	ldw	r2,-32(fp)
8113e1dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113e1e0:	e0bfff17 	ldw	r2,-4(fp)
8113e1e4:	00c010c4 	movi	r3,67
8113e1e8:	10c00005 	stb	r3,0(r2)
        return;
8113e1ec:	00001b06 	br	8113e25c <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113e1f0:	e13ffe17 	ldw	r4,-8(fp)
8113e1f4:	1137e380 	call	81137e38 <OS_StrLen>
8113e1f8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113e1fc:	e0bffa03 	ldbu	r2,-24(fp)
8113e200:	10800830 	cmpltui	r2,r2,32
8113e204:	1000081e 	bne	r2,zero,8113e228 <OSTaskNameSet+0x174>
8113e208:	e0bff517 	ldw	r2,-44(fp)
8113e20c:	e0bff915 	stw	r2,-28(fp)
8113e210:	e0bff917 	ldw	r2,-28(fp)
8113e214:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113e218:	e0bfff17 	ldw	r2,-4(fp)
8113e21c:	00c01044 	movi	r3,65
8113e220:	10c00005 	stb	r3,0(r2)
        return;
8113e224:	00000d06 	br	8113e25c <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113e228:	e0bff717 	ldw	r2,-36(fp)
8113e22c:	10801304 	addi	r2,r2,76
8113e230:	e17ffe17 	ldw	r5,-8(fp)
8113e234:	1009883a 	mov	r4,r2
8113e238:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113e23c:	e0bff517 	ldw	r2,-44(fp)
8113e240:	e0bffb15 	stw	r2,-20(fp)
8113e244:	e0bffb17 	ldw	r2,-20(fp)
8113e248:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113e24c:	e0bfff17 	ldw	r2,-4(fp)
8113e250:	10000005 	stb	zero,0(r2)
8113e254:	00000106 	br	8113e25c <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113e258:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113e25c:	e037883a 	mov	sp,fp
8113e260:	dfc00117 	ldw	ra,4(sp)
8113e264:	df000017 	ldw	fp,0(sp)
8113e268:	dec00204 	addi	sp,sp,8
8113e26c:	f800283a 	ret

8113e270 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113e270:	defff404 	addi	sp,sp,-48
8113e274:	de00012e 	bgeu	sp,et,8113e27c <OSTaskResume+0xc>
8113e278:	003b68fa 	trap	3
8113e27c:	dfc00b15 	stw	ra,44(sp)
8113e280:	df000a15 	stw	fp,40(sp)
8113e284:	df000a04 	addi	fp,sp,40
8113e288:	2005883a 	mov	r2,r4
8113e28c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113e290:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113e294:	e0bfff03 	ldbu	r2,-4(fp)
8113e298:	10800ab0 	cmpltui	r2,r2,42
8113e29c:	1000021e 	bne	r2,zero,8113e2a8 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113e2a0:	00800a84 	movi	r2,42
8113e2a4:	00006406 	br	8113e438 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e2a8:	0005303a 	rdctl	r2,status
8113e2ac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e2b0:	e0fffe17 	ldw	r3,-8(fp)
8113e2b4:	00bfff84 	movi	r2,-2
8113e2b8:	1884703a 	and	r2,r3,r2
8113e2bc:	1001703a 	wrctl	status,r2
  
  return context;
8113e2c0:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113e2c4:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113e2c8:	e0ffff03 	ldbu	r3,-4(fp)
8113e2cc:	00a045f4 	movhi	r2,33047
8113e2d0:	10a9d004 	addi	r2,r2,-22720
8113e2d4:	18c7883a 	add	r3,r3,r3
8113e2d8:	18c7883a 	add	r3,r3,r3
8113e2dc:	10c5883a 	add	r2,r2,r3
8113e2e0:	10800017 	ldw	r2,0(r2)
8113e2e4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113e2e8:	e0bff817 	ldw	r2,-32(fp)
8113e2ec:	1000061e 	bne	r2,zero,8113e308 <OSTaskResume+0x98>
8113e2f0:	e0bff617 	ldw	r2,-40(fp)
8113e2f4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e2f8:	e0bff717 	ldw	r2,-36(fp)
8113e2fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113e300:	00801184 	movi	r2,70
8113e304:	00004c06 	br	8113e438 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113e308:	e0bff817 	ldw	r2,-32(fp)
8113e30c:	10800058 	cmpnei	r2,r2,1
8113e310:	1000061e 	bne	r2,zero,8113e32c <OSTaskResume+0xbc>
8113e314:	e0bff617 	ldw	r2,-40(fp)
8113e318:	e0bff915 	stw	r2,-28(fp)
8113e31c:	e0bff917 	ldw	r2,-28(fp)
8113e320:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113e324:	008010c4 	movi	r2,67
8113e328:	00004306 	br	8113e438 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113e32c:	e0bff817 	ldw	r2,-32(fp)
8113e330:	10800c03 	ldbu	r2,48(r2)
8113e334:	10803fcc 	andi	r2,r2,255
8113e338:	1080020c 	andi	r2,r2,8
8113e33c:	10003926 	beq	r2,zero,8113e424 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113e340:	e0bff817 	ldw	r2,-32(fp)
8113e344:	10c00c03 	ldbu	r3,48(r2)
8113e348:	00bffdc4 	movi	r2,-9
8113e34c:	1884703a 	and	r2,r3,r2
8113e350:	1007883a 	mov	r3,r2
8113e354:	e0bff817 	ldw	r2,-32(fp)
8113e358:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113e35c:	e0bff817 	ldw	r2,-32(fp)
8113e360:	10800c03 	ldbu	r2,48(r2)
8113e364:	10803fcc 	andi	r2,r2,255
8113e368:	1000281e 	bne	r2,zero,8113e40c <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113e36c:	e0bff817 	ldw	r2,-32(fp)
8113e370:	10800b8b 	ldhu	r2,46(r2)
8113e374:	10bfffcc 	andi	r2,r2,65535
8113e378:	10001f1e 	bne	r2,zero,8113e3f8 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113e37c:	e0bff817 	ldw	r2,-32(fp)
8113e380:	10c00d83 	ldbu	r3,54(r2)
8113e384:	d0a09d03 	ldbu	r2,-32140(gp)
8113e388:	1884b03a 	or	r2,r3,r2
8113e38c:	d0a09d05 	stb	r2,-32140(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113e390:	e0bff817 	ldw	r2,-32(fp)
8113e394:	10800d03 	ldbu	r2,52(r2)
8113e398:	10c03fcc 	andi	r3,r2,255
8113e39c:	e0bff817 	ldw	r2,-32(fp)
8113e3a0:	10800d03 	ldbu	r2,52(r2)
8113e3a4:	11003fcc 	andi	r4,r2,255
8113e3a8:	d0a09d44 	addi	r2,gp,-32139
8113e3ac:	2085883a 	add	r2,r4,r2
8113e3b0:	11000003 	ldbu	r4,0(r2)
8113e3b4:	e0bff817 	ldw	r2,-32(fp)
8113e3b8:	10800d43 	ldbu	r2,53(r2)
8113e3bc:	2084b03a 	or	r2,r4,r2
8113e3c0:	1009883a 	mov	r4,r2
8113e3c4:	d0a09d44 	addi	r2,gp,-32139
8113e3c8:	1885883a 	add	r2,r3,r2
8113e3cc:	11000005 	stb	r4,0(r2)
8113e3d0:	e0bff617 	ldw	r2,-40(fp)
8113e3d4:	e0bffa15 	stw	r2,-24(fp)
8113e3d8:	e0bffa17 	ldw	r2,-24(fp)
8113e3dc:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113e3e0:	d0a09003 	ldbu	r2,-32192(gp)
8113e3e4:	10803fcc 	andi	r2,r2,255
8113e3e8:	10800058 	cmpnei	r2,r2,1
8113e3ec:	10000b1e 	bne	r2,zero,8113e41c <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113e3f0:	1137c680 	call	81137c68 <OS_Sched>
8113e3f4:	00000906 	br	8113e41c <OSTaskResume+0x1ac>
8113e3f8:	e0bff617 	ldw	r2,-40(fp)
8113e3fc:	e0bffb15 	stw	r2,-20(fp)
8113e400:	e0bffb17 	ldw	r2,-20(fp)
8113e404:	1001703a 	wrctl	status,r2
8113e408:	00000406 	br	8113e41c <OSTaskResume+0x1ac>
8113e40c:	e0bff617 	ldw	r2,-40(fp)
8113e410:	e0bffc15 	stw	r2,-16(fp)
8113e414:	e0bffc17 	ldw	r2,-16(fp)
8113e418:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113e41c:	0005883a 	mov	r2,zero
8113e420:	00000506 	br	8113e438 <OSTaskResume+0x1c8>
8113e424:	e0bff617 	ldw	r2,-40(fp)
8113e428:	e0bffd15 	stw	r2,-12(fp)
8113e42c:	e0bffd17 	ldw	r2,-12(fp)
8113e430:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113e434:	00801104 	movi	r2,68
}
8113e438:	e037883a 	mov	sp,fp
8113e43c:	dfc00117 	ldw	ra,4(sp)
8113e440:	df000017 	ldw	fp,0(sp)
8113e444:	dec00204 	addi	sp,sp,8
8113e448:	f800283a 	ret

8113e44c <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113e44c:	defff304 	addi	sp,sp,-52
8113e450:	de00012e 	bgeu	sp,et,8113e458 <OSTaskStkChk+0xc>
8113e454:	003b68fa 	trap	3
8113e458:	df000c15 	stw	fp,48(sp)
8113e45c:	df000c04 	addi	fp,sp,48
8113e460:	2005883a 	mov	r2,r4
8113e464:	e17fff15 	stw	r5,-4(fp)
8113e468:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113e46c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113e470:	e0bffe03 	ldbu	r2,-8(fp)
8113e474:	10800af0 	cmpltui	r2,r2,43
8113e478:	1000051e 	bne	r2,zero,8113e490 <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113e47c:	e0bffe03 	ldbu	r2,-8(fp)
8113e480:	10803fe0 	cmpeqi	r2,r2,255
8113e484:	1000021e 	bne	r2,zero,8113e490 <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113e488:	00800a84 	movi	r2,42
8113e48c:	00005d06 	br	8113e604 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113e490:	e0bfff17 	ldw	r2,-4(fp)
8113e494:	1000021e 	bne	r2,zero,8113e4a0 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113e498:	00800244 	movi	r2,9
8113e49c:	00005906 	br	8113e604 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113e4a0:	e0bfff17 	ldw	r2,-4(fp)
8113e4a4:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113e4a8:	e0bfff17 	ldw	r2,-4(fp)
8113e4ac:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e4b0:	0005303a 	rdctl	r2,status
8113e4b4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e4b8:	e0fffd17 	ldw	r3,-12(fp)
8113e4bc:	00bfff84 	movi	r2,-2
8113e4c0:	1884703a 	and	r2,r3,r2
8113e4c4:	1001703a 	wrctl	status,r2
  
  return context;
8113e4c8:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113e4cc:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113e4d0:	e0bffe03 	ldbu	r2,-8(fp)
8113e4d4:	10803fd8 	cmpnei	r2,r2,255
8113e4d8:	1000031e 	bne	r2,zero,8113e4e8 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113e4dc:	d0a0a117 	ldw	r2,-32124(gp)
8113e4e0:	10800c83 	ldbu	r2,50(r2)
8113e4e4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113e4e8:	e0fffe03 	ldbu	r3,-8(fp)
8113e4ec:	00a045f4 	movhi	r2,33047
8113e4f0:	10a9d004 	addi	r2,r2,-22720
8113e4f4:	18c7883a 	add	r3,r3,r3
8113e4f8:	18c7883a 	add	r3,r3,r3
8113e4fc:	10c5883a 	add	r2,r2,r3
8113e500:	10800017 	ldw	r2,0(r2)
8113e504:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113e508:	e0bff817 	ldw	r2,-32(fp)
8113e50c:	1000061e 	bne	r2,zero,8113e528 <OSTaskStkChk+0xdc>
8113e510:	e0bff617 	ldw	r2,-40(fp)
8113e514:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e518:	e0bff717 	ldw	r2,-36(fp)
8113e51c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113e520:	008010c4 	movi	r2,67
8113e524:	00003706 	br	8113e604 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113e528:	e0bff817 	ldw	r2,-32(fp)
8113e52c:	10800058 	cmpnei	r2,r2,1
8113e530:	1000061e 	bne	r2,zero,8113e54c <OSTaskStkChk+0x100>
8113e534:	e0bff617 	ldw	r2,-40(fp)
8113e538:	e0bff915 	stw	r2,-28(fp)
8113e53c:	e0bff917 	ldw	r2,-28(fp)
8113e540:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113e544:	008010c4 	movi	r2,67
8113e548:	00002e06 	br	8113e604 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113e54c:	e0bff817 	ldw	r2,-32(fp)
8113e550:	1080040b 	ldhu	r2,16(r2)
8113e554:	10bfffcc 	andi	r2,r2,65535
8113e558:	1080004c 	andi	r2,r2,1
8113e55c:	1000061e 	bne	r2,zero,8113e578 <OSTaskStkChk+0x12c>
8113e560:	e0bff617 	ldw	r2,-40(fp)
8113e564:	e0bffa15 	stw	r2,-24(fp)
8113e568:	e0bffa17 	ldw	r2,-24(fp)
8113e56c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113e570:	00801144 	movi	r2,69
8113e574:	00002306 	br	8113e604 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113e578:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113e57c:	e0bff817 	ldw	r2,-32(fp)
8113e580:	10800317 	ldw	r2,12(r2)
8113e584:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113e588:	e0bff817 	ldw	r2,-32(fp)
8113e58c:	10800217 	ldw	r2,8(r2)
8113e590:	e0bff415 	stw	r2,-48(fp)
8113e594:	e0bff617 	ldw	r2,-40(fp)
8113e598:	e0bffb15 	stw	r2,-20(fp)
8113e59c:	e0bffb17 	ldw	r2,-20(fp)
8113e5a0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113e5a4:	00000306 	br	8113e5b4 <OSTaskStkChk+0x168>
        nfree++;
8113e5a8:	e0bff517 	ldw	r2,-44(fp)
8113e5ac:	10800044 	addi	r2,r2,1
8113e5b0:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113e5b4:	e0bff417 	ldw	r2,-48(fp)
8113e5b8:	10c00104 	addi	r3,r2,4
8113e5bc:	e0fff415 	stw	r3,-48(fp)
8113e5c0:	10800017 	ldw	r2,0(r2)
8113e5c4:	103ff826 	beq	r2,zero,8113e5a8 <__reset+0xfb11e5a8>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113e5c8:	e0bff517 	ldw	r2,-44(fp)
8113e5cc:	1085883a 	add	r2,r2,r2
8113e5d0:	1085883a 	add	r2,r2,r2
8113e5d4:	1007883a 	mov	r3,r2
8113e5d8:	e0bfff17 	ldw	r2,-4(fp)
8113e5dc:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113e5e0:	e0fffc17 	ldw	r3,-16(fp)
8113e5e4:	e0bff517 	ldw	r2,-44(fp)
8113e5e8:	1885c83a 	sub	r2,r3,r2
8113e5ec:	1085883a 	add	r2,r2,r2
8113e5f0:	1085883a 	add	r2,r2,r2
8113e5f4:	1007883a 	mov	r3,r2
8113e5f8:	e0bfff17 	ldw	r2,-4(fp)
8113e5fc:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113e600:	0005883a 	mov	r2,zero
}
8113e604:	e037883a 	mov	sp,fp
8113e608:	df000017 	ldw	fp,0(sp)
8113e60c:	dec00104 	addi	sp,sp,4
8113e610:	f800283a 	ret

8113e614 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113e614:	defff504 	addi	sp,sp,-44
8113e618:	de00012e 	bgeu	sp,et,8113e620 <OSTaskSuspend+0xc>
8113e61c:	003b68fa 	trap	3
8113e620:	dfc00a15 	stw	ra,40(sp)
8113e624:	df000915 	stw	fp,36(sp)
8113e628:	df000904 	addi	fp,sp,36
8113e62c:	2005883a 	mov	r2,r4
8113e630:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e634:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113e638:	e0bfff03 	ldbu	r2,-4(fp)
8113e63c:	10800a98 	cmpnei	r2,r2,42
8113e640:	1000021e 	bne	r2,zero,8113e64c <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113e644:	008011c4 	movi	r2,71
8113e648:	00006806 	br	8113e7ec <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113e64c:	e0bfff03 	ldbu	r2,-4(fp)
8113e650:	10800ab0 	cmpltui	r2,r2,42
8113e654:	1000051e 	bne	r2,zero,8113e66c <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113e658:	e0bfff03 	ldbu	r2,-4(fp)
8113e65c:	10803fe0 	cmpeqi	r2,r2,255
8113e660:	1000021e 	bne	r2,zero,8113e66c <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113e664:	00800a84 	movi	r2,42
8113e668:	00006006 	br	8113e7ec <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e66c:	0005303a 	rdctl	r2,status
8113e670:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e674:	e0fffe17 	ldw	r3,-8(fp)
8113e678:	00bfff84 	movi	r2,-2
8113e67c:	1884703a 	and	r2,r3,r2
8113e680:	1001703a 	wrctl	status,r2
  
  return context;
8113e684:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113e688:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113e68c:	e0bfff03 	ldbu	r2,-4(fp)
8113e690:	10803fd8 	cmpnei	r2,r2,255
8113e694:	1000061e 	bne	r2,zero,8113e6b0 <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113e698:	d0a0a117 	ldw	r2,-32124(gp)
8113e69c:	10800c83 	ldbu	r2,50(r2)
8113e6a0:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113e6a4:	00800044 	movi	r2,1
8113e6a8:	e0bff705 	stb	r2,-36(fp)
8113e6ac:	00000906 	br	8113e6d4 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113e6b0:	d0a0a117 	ldw	r2,-32124(gp)
8113e6b4:	10800c83 	ldbu	r2,50(r2)
8113e6b8:	10c03fcc 	andi	r3,r2,255
8113e6bc:	e0bfff03 	ldbu	r2,-4(fp)
8113e6c0:	1880031e 	bne	r3,r2,8113e6d0 <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113e6c4:	00800044 	movi	r2,1
8113e6c8:	e0bff705 	stb	r2,-36(fp)
8113e6cc:	00000106 	br	8113e6d4 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113e6d0:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113e6d4:	e0ffff03 	ldbu	r3,-4(fp)
8113e6d8:	00a045f4 	movhi	r2,33047
8113e6dc:	10a9d004 	addi	r2,r2,-22720
8113e6e0:	18c7883a 	add	r3,r3,r3
8113e6e4:	18c7883a 	add	r3,r3,r3
8113e6e8:	10c5883a 	add	r2,r2,r3
8113e6ec:	10800017 	ldw	r2,0(r2)
8113e6f0:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113e6f4:	e0bffa17 	ldw	r2,-24(fp)
8113e6f8:	1000061e 	bne	r2,zero,8113e714 <OSTaskSuspend+0x100>
8113e6fc:	e0bff817 	ldw	r2,-32(fp)
8113e700:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e704:	e0bff917 	ldw	r2,-28(fp)
8113e708:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113e70c:	00801204 	movi	r2,72
8113e710:	00003606 	br	8113e7ec <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113e714:	e0bffa17 	ldw	r2,-24(fp)
8113e718:	10800058 	cmpnei	r2,r2,1
8113e71c:	1000061e 	bne	r2,zero,8113e738 <OSTaskSuspend+0x124>
8113e720:	e0bff817 	ldw	r2,-32(fp)
8113e724:	e0bffb15 	stw	r2,-20(fp)
8113e728:	e0bffb17 	ldw	r2,-20(fp)
8113e72c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113e730:	008010c4 	movi	r2,67
8113e734:	00002d06 	br	8113e7ec <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113e738:	e0bffa17 	ldw	r2,-24(fp)
8113e73c:	10800d03 	ldbu	r2,52(r2)
8113e740:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113e744:	e0fffd03 	ldbu	r3,-12(fp)
8113e748:	e13ffd03 	ldbu	r4,-12(fp)
8113e74c:	d0a09d44 	addi	r2,gp,-32139
8113e750:	2085883a 	add	r2,r4,r2
8113e754:	10800003 	ldbu	r2,0(r2)
8113e758:	1009883a 	mov	r4,r2
8113e75c:	e0bffa17 	ldw	r2,-24(fp)
8113e760:	10800d43 	ldbu	r2,53(r2)
8113e764:	0084303a 	nor	r2,zero,r2
8113e768:	2084703a 	and	r2,r4,r2
8113e76c:	1009883a 	mov	r4,r2
8113e770:	d0a09d44 	addi	r2,gp,-32139
8113e774:	1885883a 	add	r2,r3,r2
8113e778:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113e77c:	e0fffd03 	ldbu	r3,-12(fp)
8113e780:	d0a09d44 	addi	r2,gp,-32139
8113e784:	1885883a 	add	r2,r3,r2
8113e788:	10800003 	ldbu	r2,0(r2)
8113e78c:	10803fcc 	andi	r2,r2,255
8113e790:	1000071e 	bne	r2,zero,8113e7b0 <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113e794:	e0bffa17 	ldw	r2,-24(fp)
8113e798:	10800d83 	ldbu	r2,54(r2)
8113e79c:	0084303a 	nor	r2,zero,r2
8113e7a0:	1007883a 	mov	r3,r2
8113e7a4:	d0a09d03 	ldbu	r2,-32140(gp)
8113e7a8:	1884703a 	and	r2,r3,r2
8113e7ac:	d0a09d05 	stb	r2,-32140(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113e7b0:	e0bffa17 	ldw	r2,-24(fp)
8113e7b4:	10800c03 	ldbu	r2,48(r2)
8113e7b8:	10800214 	ori	r2,r2,8
8113e7bc:	1007883a 	mov	r3,r2
8113e7c0:	e0bffa17 	ldw	r2,-24(fp)
8113e7c4:	10c00c05 	stb	r3,48(r2)
8113e7c8:	e0bff817 	ldw	r2,-32(fp)
8113e7cc:	e0bffc15 	stw	r2,-16(fp)
8113e7d0:	e0bffc17 	ldw	r2,-16(fp)
8113e7d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113e7d8:	e0bff703 	ldbu	r2,-36(fp)
8113e7dc:	10800058 	cmpnei	r2,r2,1
8113e7e0:	1000011e 	bne	r2,zero,8113e7e8 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113e7e4:	1137c680 	call	81137c68 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113e7e8:	0005883a 	mov	r2,zero
}
8113e7ec:	e037883a 	mov	sp,fp
8113e7f0:	dfc00117 	ldw	ra,4(sp)
8113e7f4:	df000017 	ldw	fp,0(sp)
8113e7f8:	dec00204 	addi	sp,sp,8
8113e7fc:	f800283a 	ret

8113e800 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113e800:	defff604 	addi	sp,sp,-40
8113e804:	de00012e 	bgeu	sp,et,8113e80c <OSTaskQuery+0xc>
8113e808:	003b68fa 	trap	3
8113e80c:	dfc00915 	stw	ra,36(sp)
8113e810:	df000815 	stw	fp,32(sp)
8113e814:	df000804 	addi	fp,sp,32
8113e818:	2005883a 	mov	r2,r4
8113e81c:	e17fff15 	stw	r5,-4(fp)
8113e820:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e824:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113e828:	e0bffe03 	ldbu	r2,-8(fp)
8113e82c:	10800af0 	cmpltui	r2,r2,43
8113e830:	1000051e 	bne	r2,zero,8113e848 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113e834:	e0bffe03 	ldbu	r2,-8(fp)
8113e838:	10803fe0 	cmpeqi	r2,r2,255
8113e83c:	1000021e 	bne	r2,zero,8113e848 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113e840:	00800a84 	movi	r2,42
8113e844:	00003406 	br	8113e918 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113e848:	e0bfff17 	ldw	r2,-4(fp)
8113e84c:	1000021e 	bne	r2,zero,8113e858 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113e850:	00800244 	movi	r2,9
8113e854:	00003006 	br	8113e918 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e858:	0005303a 	rdctl	r2,status
8113e85c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e860:	e0fffd17 	ldw	r3,-12(fp)
8113e864:	00bfff84 	movi	r2,-2
8113e868:	1884703a 	and	r2,r3,r2
8113e86c:	1001703a 	wrctl	status,r2
  
  return context;
8113e870:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113e874:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113e878:	e0bffe03 	ldbu	r2,-8(fp)
8113e87c:	10803fd8 	cmpnei	r2,r2,255
8113e880:	1000031e 	bne	r2,zero,8113e890 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113e884:	d0a0a117 	ldw	r2,-32124(gp)
8113e888:	10800c83 	ldbu	r2,50(r2)
8113e88c:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113e890:	e0fffe03 	ldbu	r3,-8(fp)
8113e894:	00a045f4 	movhi	r2,33047
8113e898:	10a9d004 	addi	r2,r2,-22720
8113e89c:	18c7883a 	add	r3,r3,r3
8113e8a0:	18c7883a 	add	r3,r3,r3
8113e8a4:	10c5883a 	add	r2,r2,r3
8113e8a8:	10800017 	ldw	r2,0(r2)
8113e8ac:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113e8b0:	e0bffa17 	ldw	r2,-24(fp)
8113e8b4:	1000061e 	bne	r2,zero,8113e8d0 <OSTaskQuery+0xd0>
8113e8b8:	e0bff817 	ldw	r2,-32(fp)
8113e8bc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113e8c0:	e0bff917 	ldw	r2,-28(fp)
8113e8c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113e8c8:	00800a44 	movi	r2,41
8113e8cc:	00001206 	br	8113e918 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113e8d0:	e0bffa17 	ldw	r2,-24(fp)
8113e8d4:	10800058 	cmpnei	r2,r2,1
8113e8d8:	1000061e 	bne	r2,zero,8113e8f4 <OSTaskQuery+0xf4>
8113e8dc:	e0bff817 	ldw	r2,-32(fp)
8113e8e0:	e0bffb15 	stw	r2,-20(fp)
8113e8e4:	e0bffb17 	ldw	r2,-20(fp)
8113e8e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113e8ec:	008010c4 	movi	r2,67
8113e8f0:	00000906 	br	8113e918 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113e8f4:	01801b04 	movi	r6,108
8113e8f8:	e17ffa17 	ldw	r5,-24(fp)
8113e8fc:	e13fff17 	ldw	r4,-4(fp)
8113e900:	1137bf80 	call	81137bf8 <OS_MemCopy>
8113e904:	e0bff817 	ldw	r2,-32(fp)
8113e908:	e0bffc15 	stw	r2,-16(fp)
8113e90c:	e0bffc17 	ldw	r2,-16(fp)
8113e910:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113e914:	0005883a 	mov	r2,zero
}
8113e918:	e037883a 	mov	sp,fp
8113e91c:	dfc00117 	ldw	ra,4(sp)
8113e920:	df000017 	ldw	fp,0(sp)
8113e924:	dec00204 	addi	sp,sp,8
8113e928:	f800283a 	ret

8113e92c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113e92c:	defffc04 	addi	sp,sp,-16
8113e930:	de00012e 	bgeu	sp,et,8113e938 <OS_TaskStkClr+0xc>
8113e934:	003b68fa 	trap	3
8113e938:	df000315 	stw	fp,12(sp)
8113e93c:	df000304 	addi	fp,sp,12
8113e940:	e13ffd15 	stw	r4,-12(fp)
8113e944:	e17ffe15 	stw	r5,-8(fp)
8113e948:	3005883a 	mov	r2,r6
8113e94c:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113e950:	e0bfff0b 	ldhu	r2,-4(fp)
8113e954:	1080004c 	andi	r2,r2,1
8113e958:	10000d26 	beq	r2,zero,8113e990 <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113e95c:	e0bfff0b 	ldhu	r2,-4(fp)
8113e960:	1080008c 	andi	r2,r2,2
8113e964:	10000a26 	beq	r2,zero,8113e990 <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113e968:	00000706 	br	8113e988 <OS_TaskStkClr+0x5c>
                size--;
8113e96c:	e0bffe17 	ldw	r2,-8(fp)
8113e970:	10bfffc4 	addi	r2,r2,-1
8113e974:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113e978:	e0bffd17 	ldw	r2,-12(fp)
8113e97c:	10c00104 	addi	r3,r2,4
8113e980:	e0fffd15 	stw	r3,-12(fp)
8113e984:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113e988:	e0bffe17 	ldw	r2,-8(fp)
8113e98c:	103ff71e 	bne	r2,zero,8113e96c <__reset+0xfb11e96c>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113e990:	0001883a 	nop
8113e994:	e037883a 	mov	sp,fp
8113e998:	df000017 	ldw	fp,0(sp)
8113e99c:	dec00104 	addi	sp,sp,4
8113e9a0:	f800283a 	ret

8113e9a4 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113e9a4:	defff904 	addi	sp,sp,-28
8113e9a8:	de00012e 	bgeu	sp,et,8113e9b0 <OSTimeDly+0xc>
8113e9ac:	003b68fa 	trap	3
8113e9b0:	dfc00615 	stw	ra,24(sp)
8113e9b4:	df000515 	stw	fp,20(sp)
8113e9b8:	df000504 	addi	fp,sp,20
8113e9bc:	2005883a 	mov	r2,r4
8113e9c0:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113e9c4:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113e9c8:	d0a0a003 	ldbu	r2,-32128(gp)
8113e9cc:	10803fcc 	andi	r2,r2,255
8113e9d0:	1000311e 	bne	r2,zero,8113ea98 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113e9d4:	e0bfff0b 	ldhu	r2,-4(fp)
8113e9d8:	10003026 	beq	r2,zero,8113ea9c <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113e9dc:	0005303a 	rdctl	r2,status
8113e9e0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113e9e4:	e0fffe17 	ldw	r3,-8(fp)
8113e9e8:	00bfff84 	movi	r2,-2
8113e9ec:	1884703a 	and	r2,r3,r2
8113e9f0:	1001703a 	wrctl	status,r2
  
  return context;
8113e9f4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113e9f8:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113e9fc:	d0a0a117 	ldw	r2,-32124(gp)
8113ea00:	10800d03 	ldbu	r2,52(r2)
8113ea04:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113ea08:	e0fffd03 	ldbu	r3,-12(fp)
8113ea0c:	e13ffd03 	ldbu	r4,-12(fp)
8113ea10:	d0a09d44 	addi	r2,gp,-32139
8113ea14:	2085883a 	add	r2,r4,r2
8113ea18:	10800003 	ldbu	r2,0(r2)
8113ea1c:	1009883a 	mov	r4,r2
8113ea20:	d0a0a117 	ldw	r2,-32124(gp)
8113ea24:	10800d43 	ldbu	r2,53(r2)
8113ea28:	0084303a 	nor	r2,zero,r2
8113ea2c:	2084703a 	and	r2,r4,r2
8113ea30:	1009883a 	mov	r4,r2
8113ea34:	d0a09d44 	addi	r2,gp,-32139
8113ea38:	1885883a 	add	r2,r3,r2
8113ea3c:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113ea40:	e0fffd03 	ldbu	r3,-12(fp)
8113ea44:	d0a09d44 	addi	r2,gp,-32139
8113ea48:	1885883a 	add	r2,r3,r2
8113ea4c:	10800003 	ldbu	r2,0(r2)
8113ea50:	10803fcc 	andi	r2,r2,255
8113ea54:	1000071e 	bne	r2,zero,8113ea74 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113ea58:	d0a0a117 	ldw	r2,-32124(gp)
8113ea5c:	10800d83 	ldbu	r2,54(r2)
8113ea60:	0084303a 	nor	r2,zero,r2
8113ea64:	1007883a 	mov	r3,r2
8113ea68:	d0a09d03 	ldbu	r2,-32140(gp)
8113ea6c:	1884703a 	and	r2,r3,r2
8113ea70:	d0a09d05 	stb	r2,-32140(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113ea74:	d0a0a117 	ldw	r2,-32124(gp)
8113ea78:	e0ffff0b 	ldhu	r3,-4(fp)
8113ea7c:	10c00b8d 	sth	r3,46(r2)
8113ea80:	e0bffb17 	ldw	r2,-20(fp)
8113ea84:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ea88:	e0bffc17 	ldw	r2,-16(fp)
8113ea8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113ea90:	1137c680 	call	81137c68 <OS_Sched>
8113ea94:	00000106 	br	8113ea9c <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113ea98:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113ea9c:	e037883a 	mov	sp,fp
8113eaa0:	dfc00117 	ldw	ra,4(sp)
8113eaa4:	df000017 	ldw	fp,0(sp)
8113eaa8:	dec00204 	addi	sp,sp,8
8113eaac:	f800283a 	ret

8113eab0 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113eab0:	defff804 	addi	sp,sp,-32
8113eab4:	de00012e 	bgeu	sp,et,8113eabc <OSTimeDlyHMSM+0xc>
8113eab8:	003b68fa 	trap	3
8113eabc:	dfc00715 	stw	ra,28(sp)
8113eac0:	df000615 	stw	fp,24(sp)
8113eac4:	df000604 	addi	fp,sp,24
8113eac8:	2015883a 	mov	r10,r4
8113eacc:	2809883a 	mov	r4,r5
8113ead0:	3007883a 	mov	r3,r6
8113ead4:	3805883a 	mov	r2,r7
8113ead8:	e2bffc05 	stb	r10,-16(fp)
8113eadc:	e13ffd05 	stb	r4,-12(fp)
8113eae0:	e0fffe05 	stb	r3,-8(fp)
8113eae4:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113eae8:	d0a0a003 	ldbu	r2,-32128(gp)
8113eaec:	10803fcc 	andi	r2,r2,255
8113eaf0:	10000226 	beq	r2,zero,8113eafc <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113eaf4:	00801544 	movi	r2,85
8113eaf8:	00004106 	br	8113ec00 <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113eafc:	e0bffc03 	ldbu	r2,-16(fp)
8113eb00:	1000081e 	bne	r2,zero,8113eb24 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113eb04:	e0bffd03 	ldbu	r2,-12(fp)
8113eb08:	1000061e 	bne	r2,zero,8113eb24 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113eb0c:	e0bffe03 	ldbu	r2,-8(fp)
8113eb10:	1000041e 	bne	r2,zero,8113eb24 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113eb14:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb18:	1000021e 	bne	r2,zero,8113eb24 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113eb1c:	00801504 	movi	r2,84
8113eb20:	00003706 	br	8113ec00 <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113eb24:	e0bffd03 	ldbu	r2,-12(fp)
8113eb28:	10800f30 	cmpltui	r2,r2,60
8113eb2c:	1000021e 	bne	r2,zero,8113eb38 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113eb30:	00801444 	movi	r2,81
8113eb34:	00003206 	br	8113ec00 <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113eb38:	e0bffe03 	ldbu	r2,-8(fp)
8113eb3c:	10800f30 	cmpltui	r2,r2,60
8113eb40:	1000021e 	bne	r2,zero,8113eb4c <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113eb44:	00801484 	movi	r2,82
8113eb48:	00002d06 	br	8113ec00 <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113eb4c:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb50:	1080fa30 	cmpltui	r2,r2,1000
8113eb54:	1000021e 	bne	r2,zero,8113eb60 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113eb58:	008014c4 	movi	r2,83
8113eb5c:	00002806 	br	8113ec00 <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113eb60:	e0bffc03 	ldbu	r2,-16(fp)
8113eb64:	10c38424 	muli	r3,r2,3600
8113eb68:	e0bffd03 	ldbu	r2,-12(fp)
8113eb6c:	10800f24 	muli	r2,r2,60
8113eb70:	1887883a 	add	r3,r3,r2
8113eb74:	e0bffe03 	ldbu	r2,-8(fp)
8113eb78:	1885883a 	add	r2,r3,r2
8113eb7c:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113eb80:	e0bfff0b 	ldhu	r2,-4(fp)
8113eb84:	10c0fa24 	muli	r3,r2,1000
8113eb88:	008418b4 	movhi	r2,4194
8113eb8c:	109374c4 	addi	r2,r2,19923
8113eb90:	188a383a 	mulxuu	r5,r3,r2
8113eb94:	1885383a 	mul	r2,r3,r2
8113eb98:	1011883a 	mov	r8,r2
8113eb9c:	2813883a 	mov	r9,r5
8113eba0:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113eba4:	2085883a 	add	r2,r4,r2
8113eba8:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113ebac:	e0bffb17 	ldw	r2,-20(fp)
8113ebb0:	1004d43a 	srli	r2,r2,16
8113ebb4:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113ebb8:	e0bffb17 	ldw	r2,-20(fp)
8113ebbc:	10bfffcc 	andi	r2,r2,65535
8113ebc0:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113ebc4:	e0bffb17 	ldw	r2,-20(fp)
8113ebc8:	10bfffcc 	andi	r2,r2,65535
8113ebcc:	1009883a 	mov	r4,r2
8113ebd0:	113e9a40 	call	8113e9a4 <OSTimeDly>
    while (loops > 0) {
8113ebd4:	00000706 	br	8113ebf4 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113ebd8:	01200014 	movui	r4,32768
8113ebdc:	113e9a40 	call	8113e9a4 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113ebe0:	01200014 	movui	r4,32768
8113ebe4:	113e9a40 	call	8113e9a4 <OSTimeDly>
        loops--;
8113ebe8:	e0bffa0b 	ldhu	r2,-24(fp)
8113ebec:	10bfffc4 	addi	r2,r2,-1
8113ebf0:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113ebf4:	e0bffa0b 	ldhu	r2,-24(fp)
8113ebf8:	103ff71e 	bne	r2,zero,8113ebd8 <__reset+0xfb11ebd8>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113ebfc:	0005883a 	mov	r2,zero
}
8113ec00:	e037883a 	mov	sp,fp
8113ec04:	dfc00117 	ldw	ra,4(sp)
8113ec08:	df000017 	ldw	fp,0(sp)
8113ec0c:	dec00204 	addi	sp,sp,8
8113ec10:	f800283a 	ret

8113ec14 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113ec14:	defff504 	addi	sp,sp,-44
8113ec18:	de00012e 	bgeu	sp,et,8113ec20 <OSTimeDlyResume+0xc>
8113ec1c:	003b68fa 	trap	3
8113ec20:	dfc00a15 	stw	ra,40(sp)
8113ec24:	df000915 	stw	fp,36(sp)
8113ec28:	df000904 	addi	fp,sp,36
8113ec2c:	2005883a 	mov	r2,r4
8113ec30:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ec34:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113ec38:	e0bfff03 	ldbu	r2,-4(fp)
8113ec3c:	10800ab0 	cmpltui	r2,r2,42
8113ec40:	1000021e 	bne	r2,zero,8113ec4c <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113ec44:	00800a84 	movi	r2,42
8113ec48:	00006406 	br	8113eddc <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ec4c:	0005303a 	rdctl	r2,status
8113ec50:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ec54:	e0fffe17 	ldw	r3,-8(fp)
8113ec58:	00bfff84 	movi	r2,-2
8113ec5c:	1884703a 	and	r2,r3,r2
8113ec60:	1001703a 	wrctl	status,r2
  
  return context;
8113ec64:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113ec68:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113ec6c:	e0ffff03 	ldbu	r3,-4(fp)
8113ec70:	00a045f4 	movhi	r2,33047
8113ec74:	10a9d004 	addi	r2,r2,-22720
8113ec78:	18c7883a 	add	r3,r3,r3
8113ec7c:	18c7883a 	add	r3,r3,r3
8113ec80:	10c5883a 	add	r2,r2,r3
8113ec84:	10800017 	ldw	r2,0(r2)
8113ec88:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113ec8c:	e0bff917 	ldw	r2,-28(fp)
8113ec90:	1000061e 	bne	r2,zero,8113ecac <OSTimeDlyResume+0x98>
8113ec94:	e0bff717 	ldw	r2,-36(fp)
8113ec98:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ec9c:	e0bff817 	ldw	r2,-32(fp)
8113eca0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113eca4:	008010c4 	movi	r2,67
8113eca8:	00004c06 	br	8113eddc <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113ecac:	e0bff917 	ldw	r2,-28(fp)
8113ecb0:	10800058 	cmpnei	r2,r2,1
8113ecb4:	1000061e 	bne	r2,zero,8113ecd0 <OSTimeDlyResume+0xbc>
8113ecb8:	e0bff717 	ldw	r2,-36(fp)
8113ecbc:	e0bffa15 	stw	r2,-24(fp)
8113ecc0:	e0bffa17 	ldw	r2,-24(fp)
8113ecc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113ecc8:	008010c4 	movi	r2,67
8113eccc:	00004306 	br	8113eddc <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113ecd0:	e0bff917 	ldw	r2,-28(fp)
8113ecd4:	10800b8b 	ldhu	r2,46(r2)
8113ecd8:	10bfffcc 	andi	r2,r2,65535
8113ecdc:	1000061e 	bne	r2,zero,8113ecf8 <OSTimeDlyResume+0xe4>
8113ece0:	e0bff717 	ldw	r2,-36(fp)
8113ece4:	e0bffb15 	stw	r2,-20(fp)
8113ece8:	e0bffb17 	ldw	r2,-20(fp)
8113ecec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113ecf0:	00801404 	movi	r2,80
8113ecf4:	00003906 	br	8113eddc <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113ecf8:	e0bff917 	ldw	r2,-28(fp)
8113ecfc:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113ed00:	e0bff917 	ldw	r2,-28(fp)
8113ed04:	10800c03 	ldbu	r2,48(r2)
8113ed08:	10803fcc 	andi	r2,r2,255
8113ed0c:	10800dcc 	andi	r2,r2,55
8113ed10:	10000b26 	beq	r2,zero,8113ed40 <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113ed14:	e0bff917 	ldw	r2,-28(fp)
8113ed18:	10c00c03 	ldbu	r3,48(r2)
8113ed1c:	00bff204 	movi	r2,-56
8113ed20:	1884703a 	and	r2,r3,r2
8113ed24:	1007883a 	mov	r3,r2
8113ed28:	e0bff917 	ldw	r2,-28(fp)
8113ed2c:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113ed30:	e0bff917 	ldw	r2,-28(fp)
8113ed34:	00c00044 	movi	r3,1
8113ed38:	10c00c45 	stb	r3,49(r2)
8113ed3c:	00000206 	br	8113ed48 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113ed40:	e0bff917 	ldw	r2,-28(fp)
8113ed44:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113ed48:	e0bff917 	ldw	r2,-28(fp)
8113ed4c:	10800c03 	ldbu	r2,48(r2)
8113ed50:	10803fcc 	andi	r2,r2,255
8113ed54:	1080020c 	andi	r2,r2,8
8113ed58:	10001b1e 	bne	r2,zero,8113edc8 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113ed5c:	e0bff917 	ldw	r2,-28(fp)
8113ed60:	10c00d83 	ldbu	r3,54(r2)
8113ed64:	d0a09d03 	ldbu	r2,-32140(gp)
8113ed68:	1884b03a 	or	r2,r3,r2
8113ed6c:	d0a09d05 	stb	r2,-32140(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113ed70:	e0bff917 	ldw	r2,-28(fp)
8113ed74:	10800d03 	ldbu	r2,52(r2)
8113ed78:	10c03fcc 	andi	r3,r2,255
8113ed7c:	e0bff917 	ldw	r2,-28(fp)
8113ed80:	10800d03 	ldbu	r2,52(r2)
8113ed84:	11003fcc 	andi	r4,r2,255
8113ed88:	d0a09d44 	addi	r2,gp,-32139
8113ed8c:	2085883a 	add	r2,r4,r2
8113ed90:	11000003 	ldbu	r4,0(r2)
8113ed94:	e0bff917 	ldw	r2,-28(fp)
8113ed98:	10800d43 	ldbu	r2,53(r2)
8113ed9c:	2084b03a 	or	r2,r4,r2
8113eda0:	1009883a 	mov	r4,r2
8113eda4:	d0a09d44 	addi	r2,gp,-32139
8113eda8:	1885883a 	add	r2,r3,r2
8113edac:	11000005 	stb	r4,0(r2)
8113edb0:	e0bff717 	ldw	r2,-36(fp)
8113edb4:	e0bffc15 	stw	r2,-16(fp)
8113edb8:	e0bffc17 	ldw	r2,-16(fp)
8113edbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113edc0:	1137c680 	call	81137c68 <OS_Sched>
8113edc4:	00000406 	br	8113edd8 <OSTimeDlyResume+0x1c4>
8113edc8:	e0bff717 	ldw	r2,-36(fp)
8113edcc:	e0bffd15 	stw	r2,-12(fp)
8113edd0:	e0bffd17 	ldw	r2,-12(fp)
8113edd4:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113edd8:	0005883a 	mov	r2,zero
}
8113eddc:	e037883a 	mov	sp,fp
8113ede0:	dfc00117 	ldw	ra,4(sp)
8113ede4:	df000017 	ldw	fp,0(sp)
8113ede8:	dec00204 	addi	sp,sp,8
8113edec:	f800283a 	ret

8113edf0 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113edf0:	defffb04 	addi	sp,sp,-20
8113edf4:	de00012e 	bgeu	sp,et,8113edfc <OSTimeGet+0xc>
8113edf8:	003b68fa 	trap	3
8113edfc:	df000415 	stw	fp,16(sp)
8113ee00:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ee04:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ee08:	0005303a 	rdctl	r2,status
8113ee0c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ee10:	e0fffe17 	ldw	r3,-8(fp)
8113ee14:	00bfff84 	movi	r2,-2
8113ee18:	1884703a 	and	r2,r3,r2
8113ee1c:	1001703a 	wrctl	status,r2
  
  return context;
8113ee20:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113ee24:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113ee28:	d0a0a317 	ldw	r2,-32116(gp)
8113ee2c:	e0bffd15 	stw	r2,-12(fp)
8113ee30:	e0bffc17 	ldw	r2,-16(fp)
8113ee34:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ee38:	e0bfff17 	ldw	r2,-4(fp)
8113ee3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113ee40:	e0bffd17 	ldw	r2,-12(fp)
}
8113ee44:	e037883a 	mov	sp,fp
8113ee48:	df000017 	ldw	fp,0(sp)
8113ee4c:	dec00104 	addi	sp,sp,4
8113ee50:	f800283a 	ret

8113ee54 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113ee54:	defffb04 	addi	sp,sp,-20
8113ee58:	de00012e 	bgeu	sp,et,8113ee60 <OSTimeSet+0xc>
8113ee5c:	003b68fa 	trap	3
8113ee60:	df000415 	stw	fp,16(sp)
8113ee64:	df000404 	addi	fp,sp,16
8113ee68:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ee6c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ee70:	0005303a 	rdctl	r2,status
8113ee74:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ee78:	e0fffd17 	ldw	r3,-12(fp)
8113ee7c:	00bfff84 	movi	r2,-2
8113ee80:	1884703a 	and	r2,r3,r2
8113ee84:	1001703a 	wrctl	status,r2
  
  return context;
8113ee88:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113ee8c:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113ee90:	e0bfff17 	ldw	r2,-4(fp)
8113ee94:	d0a0a315 	stw	r2,-32116(gp)
8113ee98:	e0bffc17 	ldw	r2,-16(fp)
8113ee9c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113eea0:	e0bffe17 	ldw	r2,-8(fp)
8113eea4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113eea8:	0001883a 	nop
8113eeac:	e037883a 	mov	sp,fp
8113eeb0:	df000017 	ldw	fp,0(sp)
8113eeb4:	dec00104 	addi	sp,sp,4
8113eeb8:	f800283a 	ret

8113eebc <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113eebc:	defff804 	addi	sp,sp,-32
8113eec0:	de00012e 	bgeu	sp,et,8113eec8 <OSTmrCreate+0xc>
8113eec4:	003b68fa 	trap	3
8113eec8:	dfc00715 	stw	ra,28(sp)
8113eecc:	df000615 	stw	fp,24(sp)
8113eed0:	df000604 	addi	fp,sp,24
8113eed4:	e13ffc15 	stw	r4,-16(fp)
8113eed8:	e17ffd15 	stw	r5,-12(fp)
8113eedc:	3005883a 	mov	r2,r6
8113eee0:	e1ffff15 	stw	r7,-4(fp)
8113eee4:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113eee8:	e0800417 	ldw	r2,16(fp)
8113eeec:	1000021e 	bne	r2,zero,8113eef8 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113eef0:	0005883a 	mov	r2,zero
8113eef4:	00005d06 	br	8113f06c <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113eef8:	e0bffe03 	ldbu	r2,-8(fp)
8113eefc:	10c00060 	cmpeqi	r3,r2,1
8113ef00:	1800091e 	bne	r3,zero,8113ef28 <OSTmrCreate+0x6c>
8113ef04:	108000a0 	cmpeqi	r2,r2,2
8113ef08:	10000e26 	beq	r2,zero,8113ef44 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113ef0c:	e0bffd17 	ldw	r2,-12(fp)
8113ef10:	1000111e 	bne	r2,zero,8113ef58 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113ef14:	e0800417 	ldw	r2,16(fp)
8113ef18:	00ffe0c4 	movi	r3,-125
8113ef1c:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113ef20:	0005883a 	mov	r2,zero
8113ef24:	00005106 	br	8113f06c <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113ef28:	e0bffc17 	ldw	r2,-16(fp)
8113ef2c:	10000c1e 	bne	r2,zero,8113ef60 <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113ef30:	e0800417 	ldw	r2,16(fp)
8113ef34:	00ffe084 	movi	r3,-126
8113ef38:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113ef3c:	0005883a 	mov	r2,zero
8113ef40:	00004a06 	br	8113f06c <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113ef44:	e0800417 	ldw	r2,16(fp)
8113ef48:	00ffe104 	movi	r3,-124
8113ef4c:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113ef50:	0005883a 	mov	r2,zero
8113ef54:	00004506 	br	8113f06c <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113ef58:	0001883a 	nop
8113ef5c:	00000106 	br	8113ef64 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113ef60:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113ef64:	d0a0a003 	ldbu	r2,-32128(gp)
8113ef68:	10803fcc 	andi	r2,r2,255
8113ef6c:	10000526 	beq	r2,zero,8113ef84 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113ef70:	e0800417 	ldw	r2,16(fp)
8113ef74:	00ffe2c4 	movi	r3,-117
8113ef78:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113ef7c:	0005883a 	mov	r2,zero
8113ef80:	00003a06 	br	8113f06c <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113ef84:	113fe740 	call	8113fe74 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113ef88:	113f9140 	call	8113f914 <OSTmr_Alloc>
8113ef8c:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113ef90:	e0bffa17 	ldw	r2,-24(fp)
8113ef94:	1000061e 	bne	r2,zero,8113efb0 <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113ef98:	113feb80 	call	8113feb8 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113ef9c:	e0800417 	ldw	r2,16(fp)
8113efa0:	00ffe184 	movi	r3,-122
8113efa4:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113efa8:	0005883a 	mov	r2,zero
8113efac:	00002f06 	br	8113f06c <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113efb0:	e0bffa17 	ldw	r2,-24(fp)
8113efb4:	00c00044 	movi	r3,1
8113efb8:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113efbc:	e0bffa17 	ldw	r2,-24(fp)
8113efc0:	e0fffc17 	ldw	r3,-16(fp)
8113efc4:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113efc8:	e0bffa17 	ldw	r2,-24(fp)
8113efcc:	e0fffd17 	ldw	r3,-12(fp)
8113efd0:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113efd4:	e0bffa17 	ldw	r2,-24(fp)
8113efd8:	e0fffe03 	ldbu	r3,-8(fp)
8113efdc:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113efe0:	e0bffa17 	ldw	r2,-24(fp)
8113efe4:	e0ffff17 	ldw	r3,-4(fp)
8113efe8:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113efec:	e0bffa17 	ldw	r2,-24(fp)
8113eff0:	e0c00217 	ldw	r3,8(fp)
8113eff4:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113eff8:	e0800317 	ldw	r2,12(fp)
8113effc:	10001726 	beq	r2,zero,8113f05c <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113f000:	e1000317 	ldw	r4,12(fp)
8113f004:	1137e380 	call	81137e38 <OS_StrLen>
8113f008:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113f00c:	e0bffb03 	ldbu	r2,-20(fp)
8113f010:	10800428 	cmpgeui	r2,r2,16
8113f014:	1000061e 	bne	r2,zero,8113f030 <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113f018:	e0bffa17 	ldw	r2,-24(fp)
8113f01c:	10800804 	addi	r2,r2,32
8113f020:	e1400317 	ldw	r5,12(fp)
8113f024:	1009883a 	mov	r4,r2
8113f028:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113f02c:	00000b06 	br	8113f05c <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113f030:	e0bffa17 	ldw	r2,-24(fp)
8113f034:	00c008c4 	movi	r3,35
8113f038:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113f03c:	e0bffa17 	ldw	r2,-24(fp)
8113f040:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113f044:	e0800417 	ldw	r2,16(fp)
8113f048:	00ffe304 	movi	r3,-116
8113f04c:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113f050:	113feb80 	call	8113feb8 <OSTmr_Unlock>
            return (ptmr);
8113f054:	e0bffa17 	ldw	r2,-24(fp)
8113f058:	00000406 	br	8113f06c <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113f05c:	113feb80 	call	8113feb8 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113f060:	e0800417 	ldw	r2,16(fp)
8113f064:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113f068:	e0bffa17 	ldw	r2,-24(fp)
}
8113f06c:	e037883a 	mov	sp,fp
8113f070:	dfc00117 	ldw	ra,4(sp)
8113f074:	df000017 	ldw	fp,0(sp)
8113f078:	dec00204 	addi	sp,sp,8
8113f07c:	f800283a 	ret

8113f080 <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113f080:	defffc04 	addi	sp,sp,-16
8113f084:	de00012e 	bgeu	sp,et,8113f08c <OSTmrDel+0xc>
8113f088:	003b68fa 	trap	3
8113f08c:	dfc00315 	stw	ra,12(sp)
8113f090:	df000215 	stw	fp,8(sp)
8113f094:	df000204 	addi	fp,sp,8
8113f098:	e13ffe15 	stw	r4,-8(fp)
8113f09c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113f0a0:	e0bfff17 	ldw	r2,-4(fp)
8113f0a4:	1000021e 	bne	r2,zero,8113f0b0 <OSTmrDel+0x30>
        return (OS_FALSE);
8113f0a8:	0005883a 	mov	r2,zero
8113f0ac:	00003f06 	br	8113f1ac <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113f0b0:	e0bffe17 	ldw	r2,-8(fp)
8113f0b4:	1000051e 	bne	r2,zero,8113f0cc <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113f0b8:	e0bfff17 	ldw	r2,-4(fp)
8113f0bc:	00ffe284 	movi	r3,-118
8113f0c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f0c4:	0005883a 	mov	r2,zero
8113f0c8:	00003806 	br	8113f1ac <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113f0cc:	e0bffe17 	ldw	r2,-8(fp)
8113f0d0:	10800003 	ldbu	r2,0(r2)
8113f0d4:	10803fcc 	andi	r2,r2,255
8113f0d8:	10801920 	cmpeqi	r2,r2,100
8113f0dc:	1000051e 	bne	r2,zero,8113f0f4 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113f0e0:	e0bfff17 	ldw	r2,-4(fp)
8113f0e4:	00ffe244 	movi	r3,-119
8113f0e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f0ec:	0005883a 	mov	r2,zero
8113f0f0:	00002e06 	br	8113f1ac <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113f0f4:	d0a0a003 	ldbu	r2,-32128(gp)
8113f0f8:	10803fcc 	andi	r2,r2,255
8113f0fc:	10000526 	beq	r2,zero,8113f114 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113f100:	e0bfff17 	ldw	r2,-4(fp)
8113f104:	00ffe2c4 	movi	r3,-117
8113f108:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f10c:	0005883a 	mov	r2,zero
8113f110:	00002606 	br	8113f1ac <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113f114:	113fe740 	call	8113fe74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113f118:	e0bffe17 	ldw	r2,-8(fp)
8113f11c:	10800c43 	ldbu	r2,49(r2)
8113f120:	10803fcc 	andi	r2,r2,255
8113f124:	10c000c8 	cmpgei	r3,r2,3
8113f128:	1800031e 	bne	r3,zero,8113f138 <OSTmrDel+0xb8>
8113f12c:	00800d16 	blt	zero,r2,8113f164 <OSTmrDel+0xe4>
8113f130:	10001326 	beq	r2,zero,8113f180 <OSTmrDel+0x100>
8113f134:	00001806 	br	8113f198 <OSTmrDel+0x118>
8113f138:	108000e0 	cmpeqi	r2,r2,3
8113f13c:	10001626 	beq	r2,zero,8113f198 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113f140:	e13ffe17 	ldw	r4,-8(fp)
8113f144:	113fd780 	call	8113fd78 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113f148:	e13ffe17 	ldw	r4,-8(fp)
8113f14c:	113f9880 	call	8113f988 <OSTmr_Free>
             OSTmr_Unlock();
8113f150:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113f154:	e0bfff17 	ldw	r2,-4(fp)
8113f158:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113f15c:	00800044 	movi	r2,1
8113f160:	00001206 	br	8113f1ac <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113f164:	e13ffe17 	ldw	r4,-8(fp)
8113f168:	113f9880 	call	8113f988 <OSTmr_Free>
             OSTmr_Unlock();
8113f16c:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113f170:	e0bfff17 	ldw	r2,-4(fp)
8113f174:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113f178:	00800044 	movi	r2,1
8113f17c:	00000b06 	br	8113f1ac <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113f180:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113f184:	e0bfff17 	ldw	r2,-4(fp)
8113f188:	00ffe1c4 	movi	r3,-121
8113f18c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113f190:	0005883a 	mov	r2,zero
8113f194:	00000506 	br	8113f1ac <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113f198:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113f19c:	e0bfff17 	ldw	r2,-4(fp)
8113f1a0:	00ffe344 	movi	r3,-115
8113f1a4:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113f1a8:	0005883a 	mov	r2,zero
    }
}
8113f1ac:	e037883a 	mov	sp,fp
8113f1b0:	dfc00117 	ldw	ra,4(sp)
8113f1b4:	df000017 	ldw	fp,0(sp)
8113f1b8:	dec00204 	addi	sp,sp,8
8113f1bc:	f800283a 	ret

8113f1c0 <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113f1c0:	defffa04 	addi	sp,sp,-24
8113f1c4:	de00012e 	bgeu	sp,et,8113f1cc <OSTmrNameGet+0xc>
8113f1c8:	003b68fa 	trap	3
8113f1cc:	dfc00515 	stw	ra,20(sp)
8113f1d0:	df000415 	stw	fp,16(sp)
8113f1d4:	df000404 	addi	fp,sp,16
8113f1d8:	e13ffd15 	stw	r4,-12(fp)
8113f1dc:	e17ffe15 	stw	r5,-8(fp)
8113f1e0:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113f1e4:	e0bfff17 	ldw	r2,-4(fp)
8113f1e8:	1000021e 	bne	r2,zero,8113f1f4 <OSTmrNameGet+0x34>
        return (0);
8113f1ec:	0005883a 	mov	r2,zero
8113f1f0:	00003e06 	br	8113f2ec <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113f1f4:	e0bffe17 	ldw	r2,-8(fp)
8113f1f8:	1000051e 	bne	r2,zero,8113f210 <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113f1fc:	e0bfff17 	ldw	r2,-4(fp)
8113f200:	00ffe204 	movi	r3,-120
8113f204:	10c00005 	stb	r3,0(r2)
        return (0);
8113f208:	0005883a 	mov	r2,zero
8113f20c:	00003706 	br	8113f2ec <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113f210:	e0bffd17 	ldw	r2,-12(fp)
8113f214:	1000051e 	bne	r2,zero,8113f22c <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113f218:	e0bfff17 	ldw	r2,-4(fp)
8113f21c:	00ffe284 	movi	r3,-118
8113f220:	10c00005 	stb	r3,0(r2)
        return (0);
8113f224:	0005883a 	mov	r2,zero
8113f228:	00003006 	br	8113f2ec <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113f22c:	e0bffd17 	ldw	r2,-12(fp)
8113f230:	10800003 	ldbu	r2,0(r2)
8113f234:	10803fcc 	andi	r2,r2,255
8113f238:	10801920 	cmpeqi	r2,r2,100
8113f23c:	1000051e 	bne	r2,zero,8113f254 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113f240:	e0bfff17 	ldw	r2,-4(fp)
8113f244:	00ffe244 	movi	r3,-119
8113f248:	10c00005 	stb	r3,0(r2)
        return (0);
8113f24c:	0005883a 	mov	r2,zero
8113f250:	00002606 	br	8113f2ec <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113f254:	d0a0a003 	ldbu	r2,-32128(gp)
8113f258:	10803fcc 	andi	r2,r2,255
8113f25c:	10000526 	beq	r2,zero,8113f274 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113f260:	e0bfff17 	ldw	r2,-4(fp)
8113f264:	00c00444 	movi	r3,17
8113f268:	10c00005 	stb	r3,0(r2)
        return (0);
8113f26c:	0005883a 	mov	r2,zero
8113f270:	00001e06 	br	8113f2ec <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113f274:	113fe740 	call	8113fe74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113f278:	e0bffd17 	ldw	r2,-12(fp)
8113f27c:	10800c43 	ldbu	r2,49(r2)
8113f280:	10803fcc 	andi	r2,r2,255
8113f284:	10000e26 	beq	r2,zero,8113f2c0 <OSTmrNameGet+0x100>
8113f288:	10001316 	blt	r2,zero,8113f2d8 <OSTmrNameGet+0x118>
8113f28c:	10800108 	cmpgei	r2,r2,4
8113f290:	1000111e 	bne	r2,zero,8113f2d8 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113f294:	e0bffd17 	ldw	r2,-12(fp)
8113f298:	10800804 	addi	r2,r2,32
8113f29c:	100b883a 	mov	r5,r2
8113f2a0:	e13ffe17 	ldw	r4,-8(fp)
8113f2a4:	1137dbc0 	call	81137dbc <OS_StrCopy>
8113f2a8:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113f2ac:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113f2b0:	e0bfff17 	ldw	r2,-4(fp)
8113f2b4:	10000005 	stb	zero,0(r2)
             return (len);
8113f2b8:	e0bffc03 	ldbu	r2,-16(fp)
8113f2bc:	00000b06 	br	8113f2ec <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113f2c0:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113f2c4:	e0bfff17 	ldw	r2,-4(fp)
8113f2c8:	00ffe1c4 	movi	r3,-121
8113f2cc:	10c00005 	stb	r3,0(r2)
             return (0);
8113f2d0:	0005883a 	mov	r2,zero
8113f2d4:	00000506 	br	8113f2ec <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113f2d8:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113f2dc:	e0bfff17 	ldw	r2,-4(fp)
8113f2e0:	00ffe344 	movi	r3,-115
8113f2e4:	10c00005 	stb	r3,0(r2)
             return (0);
8113f2e8:	0005883a 	mov	r2,zero
    }
}
8113f2ec:	e037883a 	mov	sp,fp
8113f2f0:	dfc00117 	ldw	ra,4(sp)
8113f2f4:	df000017 	ldw	fp,0(sp)
8113f2f8:	dec00204 	addi	sp,sp,8
8113f2fc:	f800283a 	ret

8113f300 <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113f300:	defffb04 	addi	sp,sp,-20
8113f304:	de00012e 	bgeu	sp,et,8113f30c <OSTmrRemainGet+0xc>
8113f308:	003b68fa 	trap	3
8113f30c:	dfc00415 	stw	ra,16(sp)
8113f310:	df000315 	stw	fp,12(sp)
8113f314:	df000304 	addi	fp,sp,12
8113f318:	e13ffe15 	stw	r4,-8(fp)
8113f31c:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113f320:	e0bfff17 	ldw	r2,-4(fp)
8113f324:	1000021e 	bne	r2,zero,8113f330 <OSTmrRemainGet+0x30>
        return (0);
8113f328:	0005883a 	mov	r2,zero
8113f32c:	00005d06 	br	8113f4a4 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113f330:	e0bffe17 	ldw	r2,-8(fp)
8113f334:	1000051e 	bne	r2,zero,8113f34c <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113f338:	e0bfff17 	ldw	r2,-4(fp)
8113f33c:	00ffe284 	movi	r3,-118
8113f340:	10c00005 	stb	r3,0(r2)
        return (0);
8113f344:	0005883a 	mov	r2,zero
8113f348:	00005606 	br	8113f4a4 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113f34c:	e0bffe17 	ldw	r2,-8(fp)
8113f350:	10800003 	ldbu	r2,0(r2)
8113f354:	10803fcc 	andi	r2,r2,255
8113f358:	10801920 	cmpeqi	r2,r2,100
8113f35c:	1000051e 	bne	r2,zero,8113f374 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113f360:	e0bfff17 	ldw	r2,-4(fp)
8113f364:	00ffe244 	movi	r3,-119
8113f368:	10c00005 	stb	r3,0(r2)
        return (0);
8113f36c:	0005883a 	mov	r2,zero
8113f370:	00004c06 	br	8113f4a4 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113f374:	d0a0a003 	ldbu	r2,-32128(gp)
8113f378:	10803fcc 	andi	r2,r2,255
8113f37c:	10000526 	beq	r2,zero,8113f394 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113f380:	e0bfff17 	ldw	r2,-4(fp)
8113f384:	00ffe2c4 	movi	r3,-117
8113f388:	10c00005 	stb	r3,0(r2)
        return (0);
8113f38c:	0005883a 	mov	r2,zero
8113f390:	00004406 	br	8113f4a4 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113f394:	113fe740 	call	8113fe74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113f398:	e0bffe17 	ldw	r2,-8(fp)
8113f39c:	10800c43 	ldbu	r2,49(r2)
8113f3a0:	10803fcc 	andi	r2,r2,255
8113f3a4:	10c00060 	cmpeqi	r3,r2,1
8113f3a8:	1800121e 	bne	r3,zero,8113f3f4 <OSTmrRemainGet+0xf4>
8113f3ac:	10c00088 	cmpgei	r3,r2,2
8113f3b0:	1800021e 	bne	r3,zero,8113f3bc <OSTmrRemainGet+0xbc>
8113f3b4:	10003026 	beq	r2,zero,8113f478 <OSTmrRemainGet+0x178>
8113f3b8:	00003506 	br	8113f490 <OSTmrRemainGet+0x190>
8113f3bc:	10c000a0 	cmpeqi	r3,r2,2
8113f3c0:	1800281e 	bne	r3,zero,8113f464 <OSTmrRemainGet+0x164>
8113f3c4:	108000e0 	cmpeqi	r2,r2,3
8113f3c8:	10003126 	beq	r2,zero,8113f490 <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113f3cc:	e0bffe17 	ldw	r2,-8(fp)
8113f3d0:	10c00517 	ldw	r3,20(r2)
8113f3d4:	d0a0a217 	ldw	r2,-32120(gp)
8113f3d8:	1885c83a 	sub	r2,r3,r2
8113f3dc:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113f3e0:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113f3e4:	e0bfff17 	ldw	r2,-4(fp)
8113f3e8:	10000005 	stb	zero,0(r2)
             return (remain);
8113f3ec:	e0bffd17 	ldw	r2,-12(fp)
8113f3f0:	00002c06 	br	8113f4a4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113f3f4:	e0bffe17 	ldw	r2,-8(fp)
8113f3f8:	10800c03 	ldbu	r2,48(r2)
8113f3fc:	10803fcc 	andi	r2,r2,255
8113f400:	108000a0 	cmpeqi	r2,r2,2
8113f404:	10000e26 	beq	r2,zero,8113f440 <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113f408:	e0bffe17 	ldw	r2,-8(fp)
8113f40c:	10800617 	ldw	r2,24(r2)
8113f410:	1000041e 	bne	r2,zero,8113f424 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113f414:	e0bffe17 	ldw	r2,-8(fp)
8113f418:	10800717 	ldw	r2,28(r2)
8113f41c:	e0bffd15 	stw	r2,-12(fp)
8113f420:	00000306 	br	8113f430 <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113f424:	e0bffe17 	ldw	r2,-8(fp)
8113f428:	10800617 	ldw	r2,24(r2)
8113f42c:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113f430:	113feb80 	call	8113feb8 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113f434:	e0bfff17 	ldw	r2,-4(fp)
8113f438:	10000005 	stb	zero,0(r2)
                      break;
8113f43c:	00000706 	br	8113f45c <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113f440:	e0bffe17 	ldw	r2,-8(fp)
8113f444:	10800617 	ldw	r2,24(r2)
8113f448:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113f44c:	113feb80 	call	8113feb8 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113f450:	e0bfff17 	ldw	r2,-4(fp)
8113f454:	10000005 	stb	zero,0(r2)
                      break;
8113f458:	0001883a 	nop
             }
             return (remain);
8113f45c:	e0bffd17 	ldw	r2,-12(fp)
8113f460:	00001006 	br	8113f4a4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113f464:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113f468:	e0bfff17 	ldw	r2,-4(fp)
8113f46c:	10000005 	stb	zero,0(r2)
             return (0);
8113f470:	0005883a 	mov	r2,zero
8113f474:	00000b06 	br	8113f4a4 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113f478:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113f47c:	e0bfff17 	ldw	r2,-4(fp)
8113f480:	00ffe1c4 	movi	r3,-121
8113f484:	10c00005 	stb	r3,0(r2)
             return (0);
8113f488:	0005883a 	mov	r2,zero
8113f48c:	00000506 	br	8113f4a4 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113f490:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113f494:	e0bfff17 	ldw	r2,-4(fp)
8113f498:	00ffe344 	movi	r3,-115
8113f49c:	10c00005 	stb	r3,0(r2)
             return (0);
8113f4a0:	0005883a 	mov	r2,zero
    }
}
8113f4a4:	e037883a 	mov	sp,fp
8113f4a8:	dfc00117 	ldw	ra,4(sp)
8113f4ac:	df000017 	ldw	fp,0(sp)
8113f4b0:	dec00204 	addi	sp,sp,8
8113f4b4:	f800283a 	ret

8113f4b8 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113f4b8:	defffb04 	addi	sp,sp,-20
8113f4bc:	de00012e 	bgeu	sp,et,8113f4c4 <OSTmrStateGet+0xc>
8113f4c0:	003b68fa 	trap	3
8113f4c4:	dfc00415 	stw	ra,16(sp)
8113f4c8:	df000315 	stw	fp,12(sp)
8113f4cc:	df000304 	addi	fp,sp,12
8113f4d0:	e13ffe15 	stw	r4,-8(fp)
8113f4d4:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113f4d8:	e0bfff17 	ldw	r2,-4(fp)
8113f4dc:	1000021e 	bne	r2,zero,8113f4e8 <OSTmrStateGet+0x30>
        return (0);
8113f4e0:	0005883a 	mov	r2,zero
8113f4e4:	00002a06 	br	8113f590 <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113f4e8:	e0bffe17 	ldw	r2,-8(fp)
8113f4ec:	1000051e 	bne	r2,zero,8113f504 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113f4f0:	e0bfff17 	ldw	r2,-4(fp)
8113f4f4:	00ffe284 	movi	r3,-118
8113f4f8:	10c00005 	stb	r3,0(r2)
        return (0);
8113f4fc:	0005883a 	mov	r2,zero
8113f500:	00002306 	br	8113f590 <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113f504:	e0bffe17 	ldw	r2,-8(fp)
8113f508:	10800003 	ldbu	r2,0(r2)
8113f50c:	10803fcc 	andi	r2,r2,255
8113f510:	10801920 	cmpeqi	r2,r2,100
8113f514:	1000051e 	bne	r2,zero,8113f52c <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113f518:	e0bfff17 	ldw	r2,-4(fp)
8113f51c:	00ffe244 	movi	r3,-119
8113f520:	10c00005 	stb	r3,0(r2)
        return (0);
8113f524:	0005883a 	mov	r2,zero
8113f528:	00001906 	br	8113f590 <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113f52c:	d0a0a003 	ldbu	r2,-32128(gp)
8113f530:	10803fcc 	andi	r2,r2,255
8113f534:	10000526 	beq	r2,zero,8113f54c <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113f538:	e0bfff17 	ldw	r2,-4(fp)
8113f53c:	00ffe2c4 	movi	r3,-117
8113f540:	10c00005 	stb	r3,0(r2)
        return (0);
8113f544:	0005883a 	mov	r2,zero
8113f548:	00001106 	br	8113f590 <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113f54c:	113fe740 	call	8113fe74 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113f550:	e0bffe17 	ldw	r2,-8(fp)
8113f554:	10800c43 	ldbu	r2,49(r2)
8113f558:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113f55c:	e0bffd03 	ldbu	r2,-12(fp)
8113f560:	1005883a 	mov	r2,r2
8113f564:	10800128 	cmpgeui	r2,r2,4
8113f568:	1000031e 	bne	r2,zero,8113f578 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113f56c:	e0bfff17 	ldw	r2,-4(fp)
8113f570:	10000005 	stb	zero,0(r2)
             break;
8113f574:	00000406 	br	8113f588 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113f578:	e0bfff17 	ldw	r2,-4(fp)
8113f57c:	00ffe344 	movi	r3,-115
8113f580:	10c00005 	stb	r3,0(r2)
             break;
8113f584:	0001883a 	nop
    }
    OSTmr_Unlock();
8113f588:	113feb80 	call	8113feb8 <OSTmr_Unlock>
    return (state);
8113f58c:	e0bffd03 	ldbu	r2,-12(fp)
}
8113f590:	e037883a 	mov	sp,fp
8113f594:	dfc00117 	ldw	ra,4(sp)
8113f598:	df000017 	ldw	fp,0(sp)
8113f59c:	dec00204 	addi	sp,sp,8
8113f5a0:	f800283a 	ret

8113f5a4 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113f5a4:	defffc04 	addi	sp,sp,-16
8113f5a8:	de00012e 	bgeu	sp,et,8113f5b0 <OSTmrStart+0xc>
8113f5ac:	003b68fa 	trap	3
8113f5b0:	dfc00315 	stw	ra,12(sp)
8113f5b4:	df000215 	stw	fp,8(sp)
8113f5b8:	df000204 	addi	fp,sp,8
8113f5bc:	e13ffe15 	stw	r4,-8(fp)
8113f5c0:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113f5c4:	e0bfff17 	ldw	r2,-4(fp)
8113f5c8:	1000021e 	bne	r2,zero,8113f5d4 <OSTmrStart+0x30>
        return (OS_FALSE);
8113f5cc:	0005883a 	mov	r2,zero
8113f5d0:	00004106 	br	8113f6d8 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113f5d4:	e0bffe17 	ldw	r2,-8(fp)
8113f5d8:	1000051e 	bne	r2,zero,8113f5f0 <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113f5dc:	e0bfff17 	ldw	r2,-4(fp)
8113f5e0:	00ffe284 	movi	r3,-118
8113f5e4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f5e8:	0005883a 	mov	r2,zero
8113f5ec:	00003a06 	br	8113f6d8 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113f5f0:	e0bffe17 	ldw	r2,-8(fp)
8113f5f4:	10800003 	ldbu	r2,0(r2)
8113f5f8:	10803fcc 	andi	r2,r2,255
8113f5fc:	10801920 	cmpeqi	r2,r2,100
8113f600:	1000051e 	bne	r2,zero,8113f618 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113f604:	e0bfff17 	ldw	r2,-4(fp)
8113f608:	00ffe244 	movi	r3,-119
8113f60c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f610:	0005883a 	mov	r2,zero
8113f614:	00003006 	br	8113f6d8 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113f618:	d0a0a003 	ldbu	r2,-32128(gp)
8113f61c:	10803fcc 	andi	r2,r2,255
8113f620:	10000526 	beq	r2,zero,8113f638 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113f624:	e0bfff17 	ldw	r2,-4(fp)
8113f628:	00ffe2c4 	movi	r3,-117
8113f62c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f630:	0005883a 	mov	r2,zero
8113f634:	00002806 	br	8113f6d8 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113f638:	113fe740 	call	8113fe74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113f63c:	e0bffe17 	ldw	r2,-8(fp)
8113f640:	10800c43 	ldbu	r2,49(r2)
8113f644:	10803fcc 	andi	r2,r2,255
8113f648:	10c000c8 	cmpgei	r3,r2,3
8113f64c:	1800031e 	bne	r3,zero,8113f65c <OSTmrStart+0xb8>
8113f650:	00800e16 	blt	zero,r2,8113f68c <OSTmrStart+0xe8>
8113f654:	10001526 	beq	r2,zero,8113f6ac <OSTmrStart+0x108>
8113f658:	00001a06 	br	8113f6c4 <OSTmrStart+0x120>
8113f65c:	108000e0 	cmpeqi	r2,r2,3
8113f660:	10001826 	beq	r2,zero,8113f6c4 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113f664:	e13ffe17 	ldw	r4,-8(fp)
8113f668:	113fd780 	call	8113fd78 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113f66c:	000b883a 	mov	r5,zero
8113f670:	e13ffe17 	ldw	r4,-8(fp)
8113f674:	113fc280 	call	8113fc28 <OSTmr_Link>
             OSTmr_Unlock();
8113f678:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113f67c:	e0bfff17 	ldw	r2,-4(fp)
8113f680:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113f684:	00800044 	movi	r2,1
8113f688:	00001306 	br	8113f6d8 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113f68c:	000b883a 	mov	r5,zero
8113f690:	e13ffe17 	ldw	r4,-8(fp)
8113f694:	113fc280 	call	8113fc28 <OSTmr_Link>
             OSTmr_Unlock();
8113f698:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113f69c:	e0bfff17 	ldw	r2,-4(fp)
8113f6a0:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113f6a4:	00800044 	movi	r2,1
8113f6a8:	00000b06 	br	8113f6d8 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113f6ac:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113f6b0:	e0bfff17 	ldw	r2,-4(fp)
8113f6b4:	00ffe1c4 	movi	r3,-121
8113f6b8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113f6bc:	0005883a 	mov	r2,zero
8113f6c0:	00000506 	br	8113f6d8 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113f6c4:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113f6c8:	e0bfff17 	ldw	r2,-4(fp)
8113f6cc:	00ffe344 	movi	r3,-115
8113f6d0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113f6d4:	0005883a 	mov	r2,zero
    }
}
8113f6d8:	e037883a 	mov	sp,fp
8113f6dc:	dfc00117 	ldw	ra,4(sp)
8113f6e0:	df000017 	ldw	fp,0(sp)
8113f6e4:	dec00204 	addi	sp,sp,8
8113f6e8:	f800283a 	ret

8113f6ec <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113f6ec:	defff904 	addi	sp,sp,-28
8113f6f0:	de00012e 	bgeu	sp,et,8113f6f8 <OSTmrStop+0xc>
8113f6f4:	003b68fa 	trap	3
8113f6f8:	dfc00615 	stw	ra,24(sp)
8113f6fc:	df000515 	stw	fp,20(sp)
8113f700:	df000504 	addi	fp,sp,20
8113f704:	e13ffc15 	stw	r4,-16(fp)
8113f708:	2805883a 	mov	r2,r5
8113f70c:	e1bffe15 	stw	r6,-8(fp)
8113f710:	e1ffff15 	stw	r7,-4(fp)
8113f714:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113f718:	e0bfff17 	ldw	r2,-4(fp)
8113f71c:	1000021e 	bne	r2,zero,8113f728 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113f720:	0005883a 	mov	r2,zero
8113f724:	00006606 	br	8113f8c0 <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113f728:	e0bffc17 	ldw	r2,-16(fp)
8113f72c:	1000051e 	bne	r2,zero,8113f744 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113f730:	e0bfff17 	ldw	r2,-4(fp)
8113f734:	00ffe284 	movi	r3,-118
8113f738:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f73c:	0005883a 	mov	r2,zero
8113f740:	00005f06 	br	8113f8c0 <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113f744:	e0bffc17 	ldw	r2,-16(fp)
8113f748:	10800003 	ldbu	r2,0(r2)
8113f74c:	10803fcc 	andi	r2,r2,255
8113f750:	10801920 	cmpeqi	r2,r2,100
8113f754:	1000051e 	bne	r2,zero,8113f76c <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113f758:	e0bfff17 	ldw	r2,-4(fp)
8113f75c:	00ffe244 	movi	r3,-119
8113f760:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f764:	0005883a 	mov	r2,zero
8113f768:	00005506 	br	8113f8c0 <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113f76c:	d0a0a003 	ldbu	r2,-32128(gp)
8113f770:	10803fcc 	andi	r2,r2,255
8113f774:	10000526 	beq	r2,zero,8113f78c <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113f778:	e0bfff17 	ldw	r2,-4(fp)
8113f77c:	00ffe2c4 	movi	r3,-117
8113f780:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113f784:	0005883a 	mov	r2,zero
8113f788:	00004d06 	br	8113f8c0 <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113f78c:	113fe740 	call	8113fe74 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113f790:	e0bffc17 	ldw	r2,-16(fp)
8113f794:	10800c43 	ldbu	r2,49(r2)
8113f798:	10803fcc 	andi	r2,r2,255
8113f79c:	10c000c8 	cmpgei	r3,r2,3
8113f7a0:	1800031e 	bne	r3,zero,8113f7b0 <OSTmrStop+0xc4>
8113f7a4:	00803516 	blt	zero,r2,8113f87c <OSTmrStop+0x190>
8113f7a8:	10003a26 	beq	r2,zero,8113f894 <OSTmrStop+0x1a8>
8113f7ac:	00003f06 	br	8113f8ac <OSTmrStop+0x1c0>
8113f7b0:	108000e0 	cmpeqi	r2,r2,3
8113f7b4:	10003d26 	beq	r2,zero,8113f8ac <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113f7b8:	e13ffc17 	ldw	r4,-16(fp)
8113f7bc:	113fd780 	call	8113fd78 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113f7c0:	e0bfff17 	ldw	r2,-4(fp)
8113f7c4:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113f7c8:	e0bffd03 	ldbu	r2,-12(fp)
8113f7cc:	10c000e0 	cmpeqi	r3,r2,3
8113f7d0:	1800041e 	bne	r3,zero,8113f7e4 <OSTmrStop+0xf8>
8113f7d4:	10c00120 	cmpeqi	r3,r2,4
8113f7d8:	1800121e 	bne	r3,zero,8113f824 <OSTmrStop+0x138>
8113f7dc:	10002326 	beq	r2,zero,8113f86c <OSTmrStop+0x180>
8113f7e0:	00001e06 	br	8113f85c <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113f7e4:	e0bffc17 	ldw	r2,-16(fp)
8113f7e8:	10800117 	ldw	r2,4(r2)
8113f7ec:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113f7f0:	e0bffb17 	ldw	r2,-20(fp)
8113f7f4:	10000726 	beq	r2,zero,8113f814 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113f7f8:	e0bffc17 	ldw	r2,-16(fp)
8113f7fc:	10c00217 	ldw	r3,8(r2)
8113f800:	e0bffb17 	ldw	r2,-20(fp)
8113f804:	180b883a 	mov	r5,r3
8113f808:	e13ffc17 	ldw	r4,-16(fp)
8113f80c:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113f810:	00001706 	br	8113f870 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113f814:	e0bfff17 	ldw	r2,-4(fp)
8113f818:	00ffe3c4 	movi	r3,-113
8113f81c:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113f820:	00001306 	br	8113f870 <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113f824:	e0bffc17 	ldw	r2,-16(fp)
8113f828:	10800117 	ldw	r2,4(r2)
8113f82c:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113f830:	e0bffb17 	ldw	r2,-20(fp)
8113f834:	10000526 	beq	r2,zero,8113f84c <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113f838:	e0bffb17 	ldw	r2,-20(fp)
8113f83c:	e17ffe17 	ldw	r5,-8(fp)
8113f840:	e13ffc17 	ldw	r4,-16(fp)
8113f844:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113f848:	00000906 	br	8113f870 <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113f84c:	e0bfff17 	ldw	r2,-4(fp)
8113f850:	00ffe3c4 	movi	r3,-113
8113f854:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113f858:	00000506 	br	8113f870 <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113f85c:	e0bfff17 	ldw	r2,-4(fp)
8113f860:	00ffe104 	movi	r3,-124
8113f864:	10c00005 	stb	r3,0(r2)
                     break;
8113f868:	00000106 	br	8113f870 <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113f86c:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113f870:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             return (OS_TRUE);
8113f874:	00800044 	movi	r2,1
8113f878:	00001106 	br	8113f8c0 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113f87c:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113f880:	e0bfff17 	ldw	r2,-4(fp)
8113f884:	00ffe384 	movi	r3,-114
8113f888:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113f88c:	00800044 	movi	r2,1
8113f890:	00000b06 	br	8113f8c0 <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113f894:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113f898:	e0bfff17 	ldw	r2,-4(fp)
8113f89c:	00ffe1c4 	movi	r3,-121
8113f8a0:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113f8a4:	0005883a 	mov	r2,zero
8113f8a8:	00000506 	br	8113f8c0 <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113f8ac:	113feb80 	call	8113feb8 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113f8b0:	e0bfff17 	ldw	r2,-4(fp)
8113f8b4:	00ffe344 	movi	r3,-115
8113f8b8:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113f8bc:	0005883a 	mov	r2,zero
    }
}
8113f8c0:	e037883a 	mov	sp,fp
8113f8c4:	dfc00117 	ldw	ra,4(sp)
8113f8c8:	df000017 	ldw	fp,0(sp)
8113f8cc:	dec00204 	addi	sp,sp,8
8113f8d0:	f800283a 	ret

8113f8d4 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113f8d4:	defffd04 	addi	sp,sp,-12
8113f8d8:	de00012e 	bgeu	sp,et,8113f8e0 <OSTmrSignal+0xc>
8113f8dc:	003b68fa 	trap	3
8113f8e0:	dfc00215 	stw	ra,8(sp)
8113f8e4:	df000115 	stw	fp,4(sp)
8113f8e8:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113f8ec:	d0a08f17 	ldw	r2,-32196(gp)
8113f8f0:	1009883a 	mov	r4,r2
8113f8f4:	113cea00 	call	8113cea0 <OSSemPost>
8113f8f8:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113f8fc:	e0bfff03 	ldbu	r2,-4(fp)
}
8113f900:	e037883a 	mov	sp,fp
8113f904:	dfc00117 	ldw	ra,4(sp)
8113f908:	df000017 	ldw	fp,0(sp)
8113f90c:	dec00204 	addi	sp,sp,8
8113f910:	f800283a 	ret

8113f914 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113f914:	defffe04 	addi	sp,sp,-8
8113f918:	de00012e 	bgeu	sp,et,8113f920 <OSTmr_Alloc+0xc>
8113f91c:	003b68fa 	trap	3
8113f920:	df000115 	stw	fp,4(sp)
8113f924:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113f928:	d0a08d17 	ldw	r2,-32204(gp)
8113f92c:	1000021e 	bne	r2,zero,8113f938 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113f930:	0005883a 	mov	r2,zero
8113f934:	00001006 	br	8113f978 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113f938:	d0a08d17 	ldw	r2,-32204(gp)
8113f93c:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113f940:	e0bfff17 	ldw	r2,-4(fp)
8113f944:	10800317 	ldw	r2,12(r2)
8113f948:	d0a08d15 	stw	r2,-32204(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113f94c:	e0bfff17 	ldw	r2,-4(fp)
8113f950:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113f954:	e0bfff17 	ldw	r2,-4(fp)
8113f958:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113f95c:	d0a0920b 	ldhu	r2,-32184(gp)
8113f960:	10800044 	addi	r2,r2,1
8113f964:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree--;
8113f968:	d0a0960b 	ldhu	r2,-32168(gp)
8113f96c:	10bfffc4 	addi	r2,r2,-1
8113f970:	d0a0960d 	sth	r2,-32168(gp)
    return (ptmr);
8113f974:	e0bfff17 	ldw	r2,-4(fp)
}
8113f978:	e037883a 	mov	sp,fp
8113f97c:	df000017 	ldw	fp,0(sp)
8113f980:	dec00104 	addi	sp,sp,4
8113f984:	f800283a 	ret

8113f988 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113f988:	defffe04 	addi	sp,sp,-8
8113f98c:	de00012e 	bgeu	sp,et,8113f994 <OSTmr_Free+0xc>
8113f990:	003b68fa 	trap	3
8113f994:	df000115 	stw	fp,4(sp)
8113f998:	df000104 	addi	fp,sp,4
8113f99c:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113f9a0:	e0bfff17 	ldw	r2,-4(fp)
8113f9a4:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113f9a8:	e0bfff17 	ldw	r2,-4(fp)
8113f9ac:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113f9b0:	e0bfff17 	ldw	r2,-4(fp)
8113f9b4:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113f9b8:	e0bfff17 	ldw	r2,-4(fp)
8113f9bc:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113f9c0:	e0bfff17 	ldw	r2,-4(fp)
8113f9c4:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113f9c8:	e0bfff17 	ldw	r2,-4(fp)
8113f9cc:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113f9d0:	e0bfff17 	ldw	r2,-4(fp)
8113f9d4:	00c00fc4 	movi	r3,63
8113f9d8:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113f9dc:	e0bfff17 	ldw	r2,-4(fp)
8113f9e0:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113f9e4:	e0bfff17 	ldw	r2,-4(fp)
8113f9e8:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113f9ec:	d0e08d17 	ldw	r3,-32204(gp)
8113f9f0:	e0bfff17 	ldw	r2,-4(fp)
8113f9f4:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113f9f8:	e0bfff17 	ldw	r2,-4(fp)
8113f9fc:	d0a08d15 	stw	r2,-32204(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113fa00:	d0a0920b 	ldhu	r2,-32184(gp)
8113fa04:	10bfffc4 	addi	r2,r2,-1
8113fa08:	d0a0920d 	sth	r2,-32184(gp)
    OSTmrFree++;
8113fa0c:	d0a0960b 	ldhu	r2,-32168(gp)
8113fa10:	10800044 	addi	r2,r2,1
8113fa14:	d0a0960d 	sth	r2,-32168(gp)
}
8113fa18:	0001883a 	nop
8113fa1c:	e037883a 	mov	sp,fp
8113fa20:	df000017 	ldw	fp,0(sp)
8113fa24:	dec00104 	addi	sp,sp,4
8113fa28:	f800283a 	ret

8113fa2c <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113fa2c:	defffa04 	addi	sp,sp,-24
8113fa30:	de00012e 	bgeu	sp,et,8113fa38 <OSTmr_Init+0xc>
8113fa34:	003b68fa 	trap	3
8113fa38:	dfc00515 	stw	ra,20(sp)
8113fa3c:	df000415 	stw	fp,16(sp)
8113fa40:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113fa44:	01406804 	movi	r5,416
8113fa48:	012045b4 	movhi	r4,33046
8113fa4c:	2113ee04 	addi	r4,r4,20408
8113fa50:	1137b9c0 	call	81137b9c <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113fa54:	01400404 	movi	r5,16
8113fa58:	012045b4 	movhi	r4,33046
8113fa5c:	2111da04 	addi	r4,r4,18280
8113fa60:	1137b9c0 	call	81137b9c <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113fa64:	00a045b4 	movhi	r2,33046
8113fa68:	1093ee04 	addi	r2,r2,20408
8113fa6c:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113fa70:	00a045b4 	movhi	r2,33046
8113fa74:	1093fb04 	addi	r2,r2,20460
8113fa78:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113fa7c:	e03ffc0d 	sth	zero,-16(fp)
8113fa80:	00001606 	br	8113fadc <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113fa84:	e0bffd17 	ldw	r2,-12(fp)
8113fa88:	00c01904 	movi	r3,100
8113fa8c:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113fa90:	e0bffd17 	ldw	r2,-12(fp)
8113fa94:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113fa98:	e0bffd17 	ldw	r2,-12(fp)
8113fa9c:	e0fffe17 	ldw	r3,-8(fp)
8113faa0:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113faa4:	e0bffd17 	ldw	r2,-12(fp)
8113faa8:	00c00fc4 	movi	r3,63
8113faac:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113fab0:	e0bffd17 	ldw	r2,-12(fp)
8113fab4:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113fab8:	e0bffd17 	ldw	r2,-12(fp)
8113fabc:	10800d04 	addi	r2,r2,52
8113fac0:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113fac4:	e0bffe17 	ldw	r2,-8(fp)
8113fac8:	10800d04 	addi	r2,r2,52
8113facc:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113fad0:	e0bffc0b 	ldhu	r2,-16(fp)
8113fad4:	10800044 	addi	r2,r2,1
8113fad8:	e0bffc0d 	sth	r2,-16(fp)
8113fadc:	e0bffc0b 	ldhu	r2,-16(fp)
8113fae0:	108001f0 	cmpltui	r2,r2,7
8113fae4:	103fe71e 	bne	r2,zero,8113fa84 <__reset+0xfb11fa84>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113fae8:	e0bffd17 	ldw	r2,-12(fp)
8113faec:	00c01904 	movi	r3,100
8113faf0:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113faf4:	e0bffd17 	ldw	r2,-12(fp)
8113faf8:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113fafc:	e0bffd17 	ldw	r2,-12(fp)
8113fb00:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113fb04:	e0bffd17 	ldw	r2,-12(fp)
8113fb08:	00c00fc4 	movi	r3,63
8113fb0c:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113fb10:	e0bffd17 	ldw	r2,-12(fp)
8113fb14:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113fb18:	d020a215 	stw	zero,-32120(gp)
    OSTmrUsed           = 0;
8113fb1c:	d020920d 	sth	zero,-32184(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113fb20:	00800204 	movi	r2,8
8113fb24:	d0a0960d 	sth	r2,-32168(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113fb28:	00a045b4 	movhi	r2,33046
8113fb2c:	1093ee04 	addi	r2,r2,20408
8113fb30:	d0a08d15 	stw	r2,-32204(gp)
    OSTmrSem            = OSSemCreate(1);
8113fb34:	01000044 	movi	r4,1
8113fb38:	113c7f00 	call	8113c7f0 <OSSemCreate>
8113fb3c:	d0a0a415 	stw	r2,-32112(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113fb40:	0009883a 	mov	r4,zero
8113fb44:	113c7f00 	call	8113c7f0 <OSSemCreate>
8113fb48:	d0a08f15 	stw	r2,-32196(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113fb4c:	d0a0a417 	ldw	r2,-32112(gp)
8113fb50:	e0ffff04 	addi	r3,fp,-4
8113fb54:	180d883a 	mov	r6,r3
8113fb58:	01604574 	movhi	r5,33045
8113fb5c:	297a9904 	addi	r5,r5,-5532
8113fb60:	1009883a 	mov	r4,r2
8113fb64:	11363f80 	call	811363f8 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113fb68:	d0a08f17 	ldw	r2,-32196(gp)
8113fb6c:	e0ffff04 	addi	r3,fp,-4
8113fb70:	180d883a 	mov	r6,r3
8113fb74:	01604574 	movhi	r5,33045
8113fb78:	297a9e04 	addi	r5,r5,-5512
8113fb7c:	1009883a 	mov	r4,r2
8113fb80:	11363f80 	call	811363f8 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113fb84:	113fba00 	call	8113fba0 <OSTmr_InitTask>
}
8113fb88:	0001883a 	nop
8113fb8c:	e037883a 	mov	sp,fp
8113fb90:	dfc00117 	ldw	ra,4(sp)
8113fb94:	df000017 	ldw	fp,0(sp)
8113fb98:	dec00204 	addi	sp,sp,8
8113fb9c:	f800283a 	ret

8113fba0 <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113fba0:	defff804 	addi	sp,sp,-32
8113fba4:	de00012e 	bgeu	sp,et,8113fbac <OSTmr_InitTask+0xc>
8113fba8:	003b68fa 	trap	3
8113fbac:	dfc00715 	stw	ra,28(sp)
8113fbb0:	df000615 	stw	fp,24(sp)
8113fbb4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113fbb8:	008000c4 	movi	r2,3
8113fbbc:	d8800415 	stw	r2,16(sp)
8113fbc0:	d8000315 	stw	zero,12(sp)
8113fbc4:	00808004 	movi	r2,512
8113fbc8:	d8800215 	stw	r2,8(sp)
8113fbcc:	00a045b4 	movhi	r2,33046
8113fbd0:	109c2204 	addi	r2,r2,28808
8113fbd4:	d8800115 	stw	r2,4(sp)
8113fbd8:	00bfff54 	movui	r2,65533
8113fbdc:	d8800015 	stw	r2,0(sp)
8113fbe0:	01c00744 	movi	r7,29
8113fbe4:	01a045b4 	movhi	r6,33046
8113fbe8:	319e2104 	addi	r6,r6,30852
8113fbec:	000b883a 	mov	r5,zero
8113fbf0:	01204534 	movhi	r4,33044
8113fbf4:	213fbd04 	addi	r4,r4,-268
8113fbf8:	113d8840 	call	8113d884 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113fbfc:	e1bfff04 	addi	r6,fp,-4
8113fc00:	01604574 	movhi	r5,33045
8113fc04:	297aa304 	addi	r5,r5,-5492
8113fc08:	01000744 	movi	r4,29
8113fc0c:	113e0b40 	call	8113e0b4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113fc10:	0001883a 	nop
8113fc14:	e037883a 	mov	sp,fp
8113fc18:	dfc00117 	ldw	ra,4(sp)
8113fc1c:	df000017 	ldw	fp,0(sp)
8113fc20:	dec00204 	addi	sp,sp,8
8113fc24:	f800283a 	ret

8113fc28 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113fc28:	defffa04 	addi	sp,sp,-24
8113fc2c:	de00012e 	bgeu	sp,et,8113fc34 <OSTmr_Link+0xc>
8113fc30:	003b68fa 	trap	3
8113fc34:	df000515 	stw	fp,20(sp)
8113fc38:	df000504 	addi	fp,sp,20
8113fc3c:	e13ffe15 	stw	r4,-8(fp)
8113fc40:	2805883a 	mov	r2,r5
8113fc44:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113fc48:	e0bffe17 	ldw	r2,-8(fp)
8113fc4c:	00c000c4 	movi	r3,3
8113fc50:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113fc54:	e0bfff03 	ldbu	r2,-4(fp)
8113fc58:	10800058 	cmpnei	r2,r2,1
8113fc5c:	1000071e 	bne	r2,zero,8113fc7c <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113fc60:	e0bffe17 	ldw	r2,-8(fp)
8113fc64:	10c00717 	ldw	r3,28(r2)
8113fc68:	d0a0a217 	ldw	r2,-32120(gp)
8113fc6c:	1887883a 	add	r3,r3,r2
8113fc70:	e0bffe17 	ldw	r2,-8(fp)
8113fc74:	10c00515 	stw	r3,20(r2)
8113fc78:	00001006 	br	8113fcbc <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113fc7c:	e0bffe17 	ldw	r2,-8(fp)
8113fc80:	10800617 	ldw	r2,24(r2)
8113fc84:	1000071e 	bne	r2,zero,8113fca4 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113fc88:	e0bffe17 	ldw	r2,-8(fp)
8113fc8c:	10c00717 	ldw	r3,28(r2)
8113fc90:	d0a0a217 	ldw	r2,-32120(gp)
8113fc94:	1887883a 	add	r3,r3,r2
8113fc98:	e0bffe17 	ldw	r2,-8(fp)
8113fc9c:	10c00515 	stw	r3,20(r2)
8113fca0:	00000606 	br	8113fcbc <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113fca4:	e0bffe17 	ldw	r2,-8(fp)
8113fca8:	10c00617 	ldw	r3,24(r2)
8113fcac:	d0a0a217 	ldw	r2,-32120(gp)
8113fcb0:	1887883a 	add	r3,r3,r2
8113fcb4:	e0bffe17 	ldw	r2,-8(fp)
8113fcb8:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113fcbc:	e0bffe17 	ldw	r2,-8(fp)
8113fcc0:	10800517 	ldw	r2,20(r2)
8113fcc4:	1080004c 	andi	r2,r2,1
8113fcc8:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113fccc:	e0bffb0b 	ldhu	r2,-20(fp)
8113fcd0:	100690fa 	slli	r3,r2,3
8113fcd4:	00a045b4 	movhi	r2,33046
8113fcd8:	1091da04 	addi	r2,r2,18280
8113fcdc:	1885883a 	add	r2,r3,r2
8113fce0:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113fce4:	e0bffc17 	ldw	r2,-16(fp)
8113fce8:	10800017 	ldw	r2,0(r2)
8113fcec:	1000091e 	bne	r2,zero,8113fd14 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113fcf0:	e0bffc17 	ldw	r2,-16(fp)
8113fcf4:	e0fffe17 	ldw	r3,-8(fp)
8113fcf8:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113fcfc:	e0bffe17 	ldw	r2,-8(fp)
8113fd00:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113fd04:	e0bffc17 	ldw	r2,-16(fp)
8113fd08:	00c00044 	movi	r3,1
8113fd0c:	10c0010d 	sth	r3,4(r2)
8113fd10:	00001206 	br	8113fd5c <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113fd14:	e0bffc17 	ldw	r2,-16(fp)
8113fd18:	10800017 	ldw	r2,0(r2)
8113fd1c:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113fd20:	e0bffc17 	ldw	r2,-16(fp)
8113fd24:	e0fffe17 	ldw	r3,-8(fp)
8113fd28:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113fd2c:	e0bffe17 	ldw	r2,-8(fp)
8113fd30:	e0fffd17 	ldw	r3,-12(fp)
8113fd34:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113fd38:	e0bffd17 	ldw	r2,-12(fp)
8113fd3c:	e0fffe17 	ldw	r3,-8(fp)
8113fd40:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113fd44:	e0bffc17 	ldw	r2,-16(fp)
8113fd48:	1080010b 	ldhu	r2,4(r2)
8113fd4c:	10800044 	addi	r2,r2,1
8113fd50:	1007883a 	mov	r3,r2
8113fd54:	e0bffc17 	ldw	r2,-16(fp)
8113fd58:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113fd5c:	e0bffe17 	ldw	r2,-8(fp)
8113fd60:	10000415 	stw	zero,16(r2)
}
8113fd64:	0001883a 	nop
8113fd68:	e037883a 	mov	sp,fp
8113fd6c:	df000017 	ldw	fp,0(sp)
8113fd70:	dec00104 	addi	sp,sp,4
8113fd74:	f800283a 	ret

8113fd78 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113fd78:	defffa04 	addi	sp,sp,-24
8113fd7c:	de00012e 	bgeu	sp,et,8113fd84 <OSTmr_Unlink+0xc>
8113fd80:	003b68fa 	trap	3
8113fd84:	df000515 	stw	fp,20(sp)
8113fd88:	df000504 	addi	fp,sp,20
8113fd8c:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113fd90:	e0bfff17 	ldw	r2,-4(fp)
8113fd94:	10800517 	ldw	r2,20(r2)
8113fd98:	1080004c 	andi	r2,r2,1
8113fd9c:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113fda0:	e0bffb0b 	ldhu	r2,-20(fp)
8113fda4:	100690fa 	slli	r3,r2,3
8113fda8:	00a045b4 	movhi	r2,33046
8113fdac:	1091da04 	addi	r2,r2,18280
8113fdb0:	1885883a 	add	r2,r3,r2
8113fdb4:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113fdb8:	e0bffc17 	ldw	r2,-16(fp)
8113fdbc:	10c00017 	ldw	r3,0(r2)
8113fdc0:	e0bfff17 	ldw	r2,-4(fp)
8113fdc4:	18800b1e 	bne	r3,r2,8113fdf4 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113fdc8:	e0bfff17 	ldw	r2,-4(fp)
8113fdcc:	10800317 	ldw	r2,12(r2)
8113fdd0:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113fdd4:	e0bffc17 	ldw	r2,-16(fp)
8113fdd8:	e0fffd17 	ldw	r3,-12(fp)
8113fddc:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113fde0:	e0bffd17 	ldw	r2,-12(fp)
8113fde4:	10001126 	beq	r2,zero,8113fe2c <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113fde8:	e0bffd17 	ldw	r2,-12(fp)
8113fdec:	10000415 	stw	zero,16(r2)
8113fdf0:	00000e06 	br	8113fe2c <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113fdf4:	e0bfff17 	ldw	r2,-4(fp)
8113fdf8:	10800417 	ldw	r2,16(r2)
8113fdfc:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113fe00:	e0bfff17 	ldw	r2,-4(fp)
8113fe04:	10800317 	ldw	r2,12(r2)
8113fe08:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113fe0c:	e0bffd17 	ldw	r2,-12(fp)
8113fe10:	e0fffe17 	ldw	r3,-8(fp)
8113fe14:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113fe18:	e0bffe17 	ldw	r2,-8(fp)
8113fe1c:	10000326 	beq	r2,zero,8113fe2c <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113fe20:	e0bffe17 	ldw	r2,-8(fp)
8113fe24:	e0fffd17 	ldw	r3,-12(fp)
8113fe28:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113fe2c:	e0bfff17 	ldw	r2,-4(fp)
8113fe30:	00c00044 	movi	r3,1
8113fe34:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113fe38:	e0bfff17 	ldw	r2,-4(fp)
8113fe3c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113fe40:	e0bfff17 	ldw	r2,-4(fp)
8113fe44:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113fe48:	e0bffc17 	ldw	r2,-16(fp)
8113fe4c:	1080010b 	ldhu	r2,4(r2)
8113fe50:	10bfffc4 	addi	r2,r2,-1
8113fe54:	1007883a 	mov	r3,r2
8113fe58:	e0bffc17 	ldw	r2,-16(fp)
8113fe5c:	10c0010d 	sth	r3,4(r2)
}
8113fe60:	0001883a 	nop
8113fe64:	e037883a 	mov	sp,fp
8113fe68:	df000017 	ldw	fp,0(sp)
8113fe6c:	dec00104 	addi	sp,sp,4
8113fe70:	f800283a 	ret

8113fe74 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113fe74:	defffd04 	addi	sp,sp,-12
8113fe78:	de00012e 	bgeu	sp,et,8113fe80 <OSTmr_Lock+0xc>
8113fe7c:	003b68fa 	trap	3
8113fe80:	dfc00215 	stw	ra,8(sp)
8113fe84:	df000115 	stw	fp,4(sp)
8113fe88:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113fe8c:	d0a0a417 	ldw	r2,-32112(gp)
8113fe90:	e1bfff04 	addi	r6,fp,-4
8113fe94:	000b883a 	mov	r5,zero
8113fe98:	1009883a 	mov	r4,r2
8113fe9c:	113cb180 	call	8113cb18 <OSSemPend>
    (void)err;
}
8113fea0:	0001883a 	nop
8113fea4:	e037883a 	mov	sp,fp
8113fea8:	dfc00117 	ldw	ra,4(sp)
8113feac:	df000017 	ldw	fp,0(sp)
8113feb0:	dec00204 	addi	sp,sp,8
8113feb4:	f800283a 	ret

8113feb8 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113feb8:	defffe04 	addi	sp,sp,-8
8113febc:	de00012e 	bgeu	sp,et,8113fec4 <OSTmr_Unlock+0xc>
8113fec0:	003b68fa 	trap	3
8113fec4:	dfc00115 	stw	ra,4(sp)
8113fec8:	df000015 	stw	fp,0(sp)
8113fecc:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113fed0:	d0a0a417 	ldw	r2,-32112(gp)
8113fed4:	1009883a 	mov	r4,r2
8113fed8:	113cea00 	call	8113cea0 <OSSemPost>
}
8113fedc:	0001883a 	nop
8113fee0:	e037883a 	mov	sp,fp
8113fee4:	dfc00117 	ldw	ra,4(sp)
8113fee8:	df000017 	ldw	fp,0(sp)
8113feec:	dec00204 	addi	sp,sp,8
8113fef0:	f800283a 	ret

8113fef4 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113fef4:	defff704 	addi	sp,sp,-36
8113fef8:	de00012e 	bgeu	sp,et,8113ff00 <OSTmr_Task+0xc>
8113fefc:	003b68fa 	trap	3
8113ff00:	dfc00815 	stw	ra,32(sp)
8113ff04:	df000715 	stw	fp,28(sp)
8113ff08:	df000704 	addi	fp,sp,28
8113ff0c:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113ff10:	d0a08f17 	ldw	r2,-32196(gp)
8113ff14:	e0fffe04 	addi	r3,fp,-8
8113ff18:	180d883a 	mov	r6,r3
8113ff1c:	000b883a 	mov	r5,zero
8113ff20:	1009883a 	mov	r4,r2
8113ff24:	113cb180 	call	8113cb18 <OSSemPend>
        OSTmr_Lock();
8113ff28:	113fe740 	call	8113fe74 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113ff2c:	d0a0a217 	ldw	r2,-32120(gp)
8113ff30:	10800044 	addi	r2,r2,1
8113ff34:	d0a0a215 	stw	r2,-32120(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113ff38:	d0a0a217 	ldw	r2,-32120(gp)
8113ff3c:	1080004c 	andi	r2,r2,1
8113ff40:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113ff44:	e0bffa0b 	ldhu	r2,-24(fp)
8113ff48:	100690fa 	slli	r3,r2,3
8113ff4c:	00a045b4 	movhi	r2,33046
8113ff50:	1091da04 	addi	r2,r2,18280
8113ff54:	1885883a 	add	r2,r3,r2
8113ff58:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113ff5c:	e0bffb17 	ldw	r2,-20(fp)
8113ff60:	10800017 	ldw	r2,0(r2)
8113ff64:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113ff68:	00002206 	br	8113fff4 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113ff6c:	e0bff917 	ldw	r2,-28(fp)
8113ff70:	10800317 	ldw	r2,12(r2)
8113ff74:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113ff78:	e0bff917 	ldw	r2,-28(fp)
8113ff7c:	10c00517 	ldw	r3,20(r2)
8113ff80:	d0a0a217 	ldw	r2,-32120(gp)
8113ff84:	1880191e 	bne	r3,r2,8113ffec <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113ff88:	e0bff917 	ldw	r2,-28(fp)
8113ff8c:	10800117 	ldw	r2,4(r2)
8113ff90:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113ff94:	e0bffd17 	ldw	r2,-12(fp)
8113ff98:	10000626 	beq	r2,zero,8113ffb4 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113ff9c:	e0bff917 	ldw	r2,-28(fp)
8113ffa0:	10c00217 	ldw	r3,8(r2)
8113ffa4:	e0bffd17 	ldw	r2,-12(fp)
8113ffa8:	180b883a 	mov	r5,r3
8113ffac:	e13ff917 	ldw	r4,-28(fp)
8113ffb0:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113ffb4:	e13ff917 	ldw	r4,-28(fp)
8113ffb8:	113fd780 	call	8113fd78 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113ffbc:	e0bff917 	ldw	r2,-28(fp)
8113ffc0:	10800c03 	ldbu	r2,48(r2)
8113ffc4:	10803fcc 	andi	r2,r2,255
8113ffc8:	10800098 	cmpnei	r2,r2,2
8113ffcc:	1000041e 	bne	r2,zero,8113ffe0 <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113ffd0:	01400044 	movi	r5,1
8113ffd4:	e13ff917 	ldw	r4,-28(fp)
8113ffd8:	113fc280 	call	8113fc28 <OSTmr_Link>
8113ffdc:	00000306 	br	8113ffec <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113ffe0:	e0bff917 	ldw	r2,-28(fp)
8113ffe4:	00c00084 	movi	r3,2
8113ffe8:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113ffec:	e0bffc17 	ldw	r2,-16(fp)
8113fff0:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113fff4:	e0bff917 	ldw	r2,-28(fp)
8113fff8:	103fdc1e 	bne	r2,zero,8113ff6c <__reset+0xfb11ff6c>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113fffc:	113feb80 	call	8113feb8 <OSTmr_Unlock>
    }
81140000:	003fc306 	br	8113ff10 <__reset+0xfb11ff10>

81140004 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
81140004:	defffd04 	addi	sp,sp,-12
81140008:	de00012e 	bgeu	sp,et,81140010 <alt_dev_reg+0xc>
8114000c:	003b68fa 	trap	3
81140010:	dfc00215 	stw	ra,8(sp)
81140014:	df000115 	stw	fp,4(sp)
81140018:	df000104 	addi	fp,sp,4
8114001c:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
81140020:	d1600d04 	addi	r5,gp,-32716
81140024:	e13fff17 	ldw	r4,-4(fp)
81140028:	11482a40 	call	811482a4 <alt_dev_llist_insert>
}
8114002c:	e037883a 	mov	sp,fp
81140030:	dfc00117 	ldw	ra,4(sp)
81140034:	df000017 	ldw	fp,0(sp)
81140038:	dec00204 	addi	sp,sp,8
8114003c:	f800283a 	ret

81140040 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
81140040:	defffd04 	addi	sp,sp,-12
81140044:	de00012e 	bgeu	sp,et,8114004c <alt_irq_init+0xc>
81140048:	003b68fa 	trap	3
8114004c:	dfc00215 	stw	ra,8(sp)
81140050:	df000115 	stw	fp,4(sp)
81140054:	df000104 	addi	fp,sp,4
81140058:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8114005c:	1148c6c0 	call	81148c6c <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
81140060:	00800044 	movi	r2,1
81140064:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
81140068:	0001883a 	nop
8114006c:	e037883a 	mov	sp,fp
81140070:	dfc00117 	ldw	ra,4(sp)
81140074:	df000017 	ldw	fp,0(sp)
81140078:	dec00204 	addi	sp,sp,8
8114007c:	f800283a 	ret

81140080 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
81140080:	defffe04 	addi	sp,sp,-8
81140084:	de00012e 	bgeu	sp,et,8114008c <alt_sys_init+0xc>
81140088:	003b68fa 	trap	3
8114008c:	dfc00115 	stw	ra,4(sp)
81140090:	df000015 	stw	fp,0(sp)
81140094:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
81140098:	01c0fa04 	movi	r7,1000
8114009c:	01800304 	movi	r6,12
811400a0:	000b883a 	mov	r5,zero
811400a4:	01200034 	movhi	r4,32768
811400a8:	21022004 	addi	r4,r4,2176
811400ac:	11453d80 	call	811453d8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
811400b0:	018002c4 	movi	r6,11
811400b4:	000b883a 	mov	r5,zero
811400b8:	01204574 	movhi	r4,33045
811400bc:	213e3f04 	addi	r4,r4,-1796
811400c0:	11446c40 	call	811446c4 <altera_avalon_jtag_uart_init>
811400c4:	01204574 	movhi	r4,33045
811400c8:	213e3504 	addi	r4,r4,-1836
811400cc:	11400040 	call	81140004 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
811400d0:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
811400d4:	018003c4 	movi	r6,15
811400d8:	000b883a 	mov	r5,zero
811400dc:	01204574 	movhi	r4,33045
811400e0:	21025a04 	addi	r4,r4,2408
811400e4:	11455840 	call	81145584 <altera_avalon_uart_init>
811400e8:	01204574 	movhi	r4,33045
811400ec:	21025004 	addi	r4,r4,2368
811400f0:	11400040 	call	81140004 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
811400f4:	00a04574 	movhi	r2,33045
811400f8:	10828404 	addi	r2,r2,2576
811400fc:	10c00717 	ldw	r3,28(r2)
81140100:	00a04574 	movhi	r2,33045
81140104:	10828404 	addi	r2,r2,2576
81140108:	10800817 	ldw	r2,32(r2)
8114010c:	100d883a 	mov	r6,r2
81140110:	180b883a 	mov	r5,r3
81140114:	01204574 	movhi	r4,33045
81140118:	21028404 	addi	r4,r4,2576
8114011c:	1147e0c0 	call	81147e0c <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
81140120:	00a04574 	movhi	r2,33045
81140124:	10829d04 	addi	r2,r2,2676
81140128:	10c00717 	ldw	r3,28(r2)
8114012c:	00a04574 	movhi	r2,33045
81140130:	10829d04 	addi	r2,r2,2676
81140134:	10800817 	ldw	r2,32(r2)
81140138:	100d883a 	mov	r6,r2
8114013c:	180b883a 	mov	r5,r3
81140140:	01204574 	movhi	r4,33045
81140144:	21029d04 	addi	r4,r4,2676
81140148:	1147e0c0 	call	81147e0c <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8114014c:	01204574 	movhi	r4,33045
81140150:	2102b604 	addi	r4,r4,2776
81140154:	11400040 	call	81140004 <alt_dev_reg>
}
81140158:	0001883a 	nop
8114015c:	e037883a 	mov	sp,fp
81140160:	dfc00117 	ldw	ra,4(sp)
81140164:	df000017 	ldw	fp,0(sp)
81140168:	dec00204 	addi	sp,sp,8
8114016c:	f800283a 	ret

81140170 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
81140170:	defffa04 	addi	sp,sp,-24
81140174:	de00012e 	bgeu	sp,et,8114017c <Write_Sector_Data+0xc>
81140178:	003b68fa 	trap	3
8114017c:	dfc00515 	stw	ra,20(sp)
81140180:	df000415 	stw	fp,16(sp)
81140184:	df000404 	addi	fp,sp,16
81140188:	e13ffe15 	stw	r4,-8(fp)
8114018c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81140190:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
81140194:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
81140198:	10001e26 	beq	r2,zero,81140214 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8114019c:	00803fc4 	movi	r2,255
811401a0:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811401a4:	d0a0ae17 	ldw	r2,-32072(gp)
811401a8:	e13ffe17 	ldw	r4,-8(fp)
811401ac:	e0ffff17 	ldw	r3,-4(fp)
811401b0:	20c7883a 	add	r3,r4,r3
811401b4:	1806927a 	slli	r3,r3,9
811401b8:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
811401bc:	d0a0ad17 	ldw	r2,-32076(gp)
811401c0:	00c00604 	movi	r3,24
811401c4:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811401c8:	d0a0aa17 	ldw	r2,-32088(gp)
811401cc:	1080002b 	ldhuio	r2,0(r2)
811401d0:	10bfffcc 	andi	r2,r2,65535
811401d4:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
811401d8:	e0bffd0b 	ldhu	r2,-12(fp)
811401dc:	10bfffcc 	andi	r2,r2,65535
811401e0:	1080010c 	andi	r2,r2,4
811401e4:	103ff81e 	bne	r2,zero,811401c8 <__reset+0xfb1201c8>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
811401e8:	e0bffd0b 	ldhu	r2,-12(fp)
811401ec:	10bfffcc 	andi	r2,r2,65535
811401f0:	1080040c 	andi	r2,r2,16
811401f4:	1000071e 	bne	r2,zero,81140214 <Write_Sector_Data+0xa4>
        {
            result = true;
811401f8:	00800044 	movi	r2,1
811401fc:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81140200:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
81140204:	e0fffe17 	ldw	r3,-8(fp)
81140208:	e0bfff17 	ldw	r2,-4(fp)
8114020c:	1885883a 	add	r2,r3,r2
81140210:	d0a0b415 	stw	r2,-32048(gp)
        }
    }
    return result;
81140214:	e0bffc17 	ldw	r2,-16(fp)
}
81140218:	e037883a 	mov	sp,fp
8114021c:	dfc00117 	ldw	ra,4(sp)
81140220:	df000017 	ldw	fp,0(sp)
81140224:	dec00204 	addi	sp,sp,8
81140228:	f800283a 	ret

8114022c <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8114022c:	defffd04 	addi	sp,sp,-12
81140230:	de00012e 	bgeu	sp,et,81140238 <Save_Modified_Sector+0xc>
81140234:	003b68fa 	trap	3
81140238:	dfc00215 	stw	ra,8(sp)
8114023c:	df000115 	stw	fp,4(sp)
81140240:	df000104 	addi	fp,sp,4
    bool result = true;
81140244:	00800044 	movi	r2,1
81140248:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8114024c:	d0a0b317 	ldw	r2,-32052(gp)
81140250:	10000526 	beq	r2,zero,81140268 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
81140254:	d0a0b417 	ldw	r2,-32048(gp)
81140258:	000b883a 	mov	r5,zero
8114025c:	1009883a 	mov	r4,r2
81140260:	11401700 	call	81140170 <Write_Sector_Data>
81140264:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
81140268:	e0bfff17 	ldw	r2,-4(fp)
}
8114026c:	e037883a 	mov	sp,fp
81140270:	dfc00117 	ldw	ra,4(sp)
81140274:	df000017 	ldw	fp,0(sp)
81140278:	dec00204 	addi	sp,sp,8
8114027c:	f800283a 	ret

81140280 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
81140280:	defffa04 	addi	sp,sp,-24
81140284:	de00012e 	bgeu	sp,et,8114028c <Read_Sector_Data+0xc>
81140288:	003b68fa 	trap	3
8114028c:	dfc00515 	stw	ra,20(sp)
81140290:	df000415 	stw	fp,16(sp)
81140294:	df000404 	addi	fp,sp,16
81140298:	e13ffe15 	stw	r4,-8(fp)
8114029c:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
811402a0:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
811402a4:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
811402a8:	10002726 	beq	r2,zero,81140348 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
811402ac:	00803fc4 	movi	r2,255
811402b0:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
811402b4:	d0a0b317 	ldw	r2,-32052(gp)
811402b8:	10000726 	beq	r2,zero,811402d8 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
811402bc:	d0a0b417 	ldw	r2,-32048(gp)
811402c0:	000b883a 	mov	r5,zero
811402c4:	1009883a 	mov	r4,r2
811402c8:	11401700 	call	81140170 <Write_Sector_Data>
811402cc:	1000021e 	bne	r2,zero,811402d8 <Read_Sector_Data+0x58>
            {
                return false;
811402d0:	0005883a 	mov	r2,zero
811402d4:	00001d06 	br	8114034c <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
811402d8:	d0a0ae17 	ldw	r2,-32072(gp)
811402dc:	e13ffe17 	ldw	r4,-8(fp)
811402e0:	e0ffff17 	ldw	r3,-4(fp)
811402e4:	20c7883a 	add	r3,r4,r3
811402e8:	1806927a 	slli	r3,r3,9
811402ec:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
811402f0:	d0a0ad17 	ldw	r2,-32076(gp)
811402f4:	00c00444 	movi	r3,17
811402f8:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
811402fc:	d0a0aa17 	ldw	r2,-32088(gp)
81140300:	1080002b 	ldhuio	r2,0(r2)
81140304:	10bfffcc 	andi	r2,r2,65535
81140308:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8114030c:	e0bffd0b 	ldhu	r2,-12(fp)
81140310:	10bfffcc 	andi	r2,r2,65535
81140314:	1080010c 	andi	r2,r2,4
81140318:	103ff81e 	bne	r2,zero,811402fc <__reset+0xfb1202fc>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8114031c:	e0bffd0b 	ldhu	r2,-12(fp)
81140320:	10bfffcc 	andi	r2,r2,65535
81140324:	1080040c 	andi	r2,r2,16
81140328:	1000071e 	bne	r2,zero,81140348 <Read_Sector_Data+0xc8>
		{
			result = true;
8114032c:	00800044 	movi	r2,1
81140330:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
81140334:	d020b315 	stw	zero,-32052(gp)
            current_sector_index = sector_index+partition_offset;
81140338:	e0fffe17 	ldw	r3,-8(fp)
8114033c:	e0bfff17 	ldw	r2,-4(fp)
81140340:	1885883a 	add	r2,r3,r2
81140344:	d0a0b415 	stw	r2,-32048(gp)
		}
	}
	return result;
81140348:	e0bffc17 	ldw	r2,-16(fp)
}
8114034c:	e037883a 	mov	sp,fp
81140350:	dfc00117 	ldw	ra,4(sp)
81140354:	df000017 	ldw	fp,0(sp)
81140358:	dec00204 	addi	sp,sp,8
8114035c:	f800283a 	ret

81140360 <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
81140360:	defffb04 	addi	sp,sp,-20
81140364:	de00012e 	bgeu	sp,et,8114036c <get_cluster_flag+0xc>
81140368:	003b68fa 	trap	3
8114036c:	dfc00415 	stw	ra,16(sp)
81140370:	df000315 	stw	fp,12(sp)
81140374:	df000304 	addi	fp,sp,12
81140378:	e13ffe15 	stw	r4,-8(fp)
8114037c:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
81140380:	e0bffe17 	ldw	r2,-8(fp)
81140384:	1004d23a 	srli	r2,r2,8
81140388:	d0e0b017 	ldw	r3,-32064(gp)
8114038c:	10c5883a 	add	r2,r2,r3
81140390:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81140394:	00a045f4 	movhi	r2,33047
81140398:	10aa0004 	addi	r2,r2,-22528
8114039c:	10801117 	ldw	r2,68(r2)
811403a0:	e0fffd17 	ldw	r3,-12(fp)
811403a4:	1885883a 	add	r2,r3,r2
811403a8:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
811403ac:	d0a0b417 	ldw	r2,-32048(gp)
811403b0:	e0fffd17 	ldw	r3,-12(fp)
811403b4:	18800726 	beq	r3,r2,811403d4 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811403b8:	e0bffd17 	ldw	r2,-12(fp)
811403bc:	000b883a 	mov	r5,zero
811403c0:	1009883a 	mov	r4,r2
811403c4:	11402800 	call	81140280 <Read_Sector_Data>
811403c8:	1000021e 	bne	r2,zero,811403d4 <get_cluster_flag+0x74>
        {
            return false;
811403cc:	0005883a 	mov	r2,zero
811403d0:	00000d06 	br	81140408 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
811403d4:	e0bffe17 	ldw	r2,-8(fp)
811403d8:	10803fcc 	andi	r2,r2,255
811403dc:	1085883a 	add	r2,r2,r2
811403e0:	1007883a 	mov	r3,r2
811403e4:	d0a0b217 	ldw	r2,-32056(gp)
811403e8:	10800a17 	ldw	r2,40(r2)
811403ec:	1885883a 	add	r2,r3,r2
811403f0:	1080002b 	ldhuio	r2,0(r2)
811403f4:	10bfffcc 	andi	r2,r2,65535
811403f8:	1007883a 	mov	r3,r2
811403fc:	e0bfff17 	ldw	r2,-4(fp)
81140400:	10c0000d 	sth	r3,0(r2)
    return true;
81140404:	00800044 	movi	r2,1
}
81140408:	e037883a 	mov	sp,fp
8114040c:	dfc00117 	ldw	ra,4(sp)
81140410:	df000017 	ldw	fp,0(sp)
81140414:	dec00204 	addi	sp,sp,8
81140418:	f800283a 	ret

8114041c <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8114041c:	defffa04 	addi	sp,sp,-24
81140420:	de00012e 	bgeu	sp,et,81140428 <mark_cluster+0xc>
81140424:	003b68fa 	trap	3
81140428:	dfc00515 	stw	ra,20(sp)
8114042c:	df000415 	stw	fp,16(sp)
81140430:	df000404 	addi	fp,sp,16
81140434:	e13ffd15 	stw	r4,-12(fp)
81140438:	2805883a 	mov	r2,r5
8114043c:	e1bfff15 	stw	r6,-4(fp)
81140440:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
81140444:	e0bffd17 	ldw	r2,-12(fp)
81140448:	1004d23a 	srli	r2,r2,8
8114044c:	d0e0b017 	ldw	r3,-32064(gp)
81140450:	10c5883a 	add	r2,r2,r3
81140454:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
81140458:	e0bfff17 	ldw	r2,-4(fp)
8114045c:	10000726 	beq	r2,zero,8114047c <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
81140460:	00a045f4 	movhi	r2,33047
81140464:	10aa0004 	addi	r2,r2,-22528
81140468:	10801117 	ldw	r2,68(r2)
8114046c:	e0fffc17 	ldw	r3,-16(fp)
81140470:	1885883a 	add	r2,r3,r2
81140474:	e0bffc15 	stw	r2,-16(fp)
81140478:	00000606 	br	81140494 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8114047c:	00a045f4 	movhi	r2,33047
81140480:	10aa0004 	addi	r2,r2,-22528
81140484:	10801217 	ldw	r2,72(r2)
81140488:	e0fffc17 	ldw	r3,-16(fp)
8114048c:	1885883a 	add	r2,r3,r2
81140490:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
81140494:	d0a0b417 	ldw	r2,-32048(gp)
81140498:	e0fffc17 	ldw	r3,-16(fp)
8114049c:	18800726 	beq	r3,r2,811404bc <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
811404a0:	e0bffc17 	ldw	r2,-16(fp)
811404a4:	000b883a 	mov	r5,zero
811404a8:	1009883a 	mov	r4,r2
811404ac:	11402800 	call	81140280 <Read_Sector_Data>
811404b0:	1000021e 	bne	r2,zero,811404bc <mark_cluster+0xa0>
        {
            return false;
811404b4:	0005883a 	mov	r2,zero
811404b8:	00000d06 	br	811404f0 <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
811404bc:	e0bffd17 	ldw	r2,-12(fp)
811404c0:	10803fcc 	andi	r2,r2,255
811404c4:	1085883a 	add	r2,r2,r2
811404c8:	1007883a 	mov	r3,r2
811404cc:	d0a0b217 	ldw	r2,-32056(gp)
811404d0:	10800a17 	ldw	r2,40(r2)
811404d4:	1885883a 	add	r2,r3,r2
811404d8:	1007883a 	mov	r3,r2
811404dc:	e0bffe0f 	ldh	r2,-8(fp)
811404e0:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
811404e4:	00800044 	movi	r2,1
811404e8:	d0a0b315 	stw	r2,-32052(gp)
    return true;
811404ec:	00800044 	movi	r2,1
}
811404f0:	e037883a 	mov	sp,fp
811404f4:	dfc00117 	ldw	ra,4(sp)
811404f8:	df000017 	ldw	fp,0(sp)
811404fc:	dec00204 	addi	sp,sp,8
81140500:	f800283a 	ret

81140504 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
81140504:	defff704 	addi	sp,sp,-36
81140508:	de00012e 	bgeu	sp,et,81140510 <Check_for_Master_Boot_Record+0xc>
8114050c:	003b68fa 	trap	3
81140510:	dfc00815 	stw	ra,32(sp)
81140514:	df000715 	stw	fp,28(sp)
81140518:	df000704 	addi	fp,sp,28
	bool result = false;
8114051c:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
81140520:	000b883a 	mov	r5,zero
81140524:	0009883a 	mov	r4,zero
81140528:	11402800 	call	81140280 <Read_Sector_Data>
8114052c:	10005a26 	beq	r2,zero,81140698 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
81140530:	d0a0b217 	ldw	r2,-32056(gp)
81140534:	10800a17 	ldw	r2,40(r2)
81140538:	10807f84 	addi	r2,r2,510
8114053c:	1080002b 	ldhuio	r2,0(r2)
81140540:	10bfffcc 	andi	r2,r2,65535
81140544:	10bfffcc 	andi	r2,r2,65535
81140548:	10a0001c 	xori	r2,r2,32768
8114054c:	10a00004 	addi	r2,r2,-32768
81140550:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
81140554:	e0bffb17 	ldw	r2,-20(fp)
81140558:	10ffffcc 	andi	r3,r2,65535
8114055c:	00aa9554 	movui	r2,43605
81140560:	18804d1e 	bne	r3,r2,81140698 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81140564:	e03ffa15 	stw	zero,-24(fp)
81140568:	00004806 	br	8114068c <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8114056c:	e0bffa17 	ldw	r2,-24(fp)
81140570:	1004913a 	slli	r2,r2,4
81140574:	10806f84 	addi	r2,r2,446
81140578:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8114057c:	d0a0b217 	ldw	r2,-32056(gp)
81140580:	10c00a17 	ldw	r3,40(r2)
81140584:	e0bffc17 	ldw	r2,-16(fp)
81140588:	1885883a 	add	r2,r3,r2
8114058c:	10800104 	addi	r2,r2,4
81140590:	10800023 	ldbuio	r2,0(r2)
81140594:	10803fcc 	andi	r2,r2,255
81140598:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8114059c:	e0bffd07 	ldb	r2,-12(fp)
811405a0:	10800060 	cmpeqi	r2,r2,1
811405a4:	1000091e 	bne	r2,zero,811405cc <Check_for_Master_Boot_Record+0xc8>
811405a8:	e0bffd07 	ldb	r2,-12(fp)
811405ac:	10800120 	cmpeqi	r2,r2,4
811405b0:	1000061e 	bne	r2,zero,811405cc <Check_for_Master_Boot_Record+0xc8>
811405b4:	e0bffd07 	ldb	r2,-12(fp)
811405b8:	108001a0 	cmpeqi	r2,r2,6
811405bc:	1000031e 	bne	r2,zero,811405cc <Check_for_Master_Boot_Record+0xc8>
811405c0:	e0bffd07 	ldb	r2,-12(fp)
811405c4:	10800398 	cmpnei	r2,r2,14
811405c8:	10002d1e 	bne	r2,zero,81140680 <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
811405cc:	d0a0b217 	ldw	r2,-32056(gp)
811405d0:	10c00a17 	ldw	r3,40(r2)
811405d4:	e0bffc17 	ldw	r2,-16(fp)
811405d8:	1885883a 	add	r2,r3,r2
811405dc:	10800284 	addi	r2,r2,10
811405e0:	1080002b 	ldhuio	r2,0(r2)
811405e4:	10bfffcc 	andi	r2,r2,65535
811405e8:	1006943a 	slli	r3,r2,16
811405ec:	d0a0b217 	ldw	r2,-32056(gp)
811405f0:	11000a17 	ldw	r4,40(r2)
811405f4:	e0bffc17 	ldw	r2,-16(fp)
811405f8:	2085883a 	add	r2,r4,r2
811405fc:	10800204 	addi	r2,r2,8
81140600:	1080002b 	ldhuio	r2,0(r2)
81140604:	10bfffcc 	andi	r2,r2,65535
81140608:	10bfffcc 	andi	r2,r2,65535
8114060c:	1884b03a 	or	r2,r3,r2
81140610:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
81140614:	d0a0b217 	ldw	r2,-32056(gp)
81140618:	10c00a17 	ldw	r3,40(r2)
8114061c:	e0bffc17 	ldw	r2,-16(fp)
81140620:	1885883a 	add	r2,r3,r2
81140624:	10800384 	addi	r2,r2,14
81140628:	1080002b 	ldhuio	r2,0(r2)
8114062c:	10bfffcc 	andi	r2,r2,65535
81140630:	1006943a 	slli	r3,r2,16
81140634:	d0a0b217 	ldw	r2,-32056(gp)
81140638:	11000a17 	ldw	r4,40(r2)
8114063c:	e0bffc17 	ldw	r2,-16(fp)
81140640:	2085883a 	add	r2,r4,r2
81140644:	10800304 	addi	r2,r2,12
81140648:	1080002b 	ldhuio	r2,0(r2)
8114064c:	10bfffcc 	andi	r2,r2,65535
81140650:	10bfffcc 	andi	r2,r2,65535
81140654:	1884b03a 	or	r2,r3,r2
81140658:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8114065c:	e0bfff17 	ldw	r2,-4(fp)
81140660:	0080070e 	bge	zero,r2,81140680 <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
81140664:	00800044 	movi	r2,1
81140668:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8114066c:	e0bfff17 	ldw	r2,-4(fp)
81140670:	d0a0b115 	stw	r2,-32060(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
81140674:	e0bffe17 	ldw	r2,-8(fp)
81140678:	d0a0b015 	stw	r2,-32064(gp)
						break;
8114067c:	00000606 	br	81140698 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
81140680:	e0bffa17 	ldw	r2,-24(fp)
81140684:	10800044 	addi	r2,r2,1
81140688:	e0bffa15 	stw	r2,-24(fp)
8114068c:	e0bffa17 	ldw	r2,-24(fp)
81140690:	10800110 	cmplti	r2,r2,4
81140694:	103fb51e 	bne	r2,zero,8114056c <__reset+0xfb12056c>
				}
			}
		}
	}

	return result;
81140698:	e0bff917 	ldw	r2,-28(fp)
}
8114069c:	e037883a 	mov	sp,fp
811406a0:	dfc00117 	ldw	ra,4(sp)
811406a4:	df000017 	ldw	fp,0(sp)
811406a8:	dec00204 	addi	sp,sp,8
811406ac:	f800283a 	ret

811406b0 <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
811406b0:	defff804 	addi	sp,sp,-32
811406b4:	de00012e 	bgeu	sp,et,811406bc <Read_File_Record_At_Offset+0xc>
811406b8:	003b68fa 	trap	3
811406bc:	dfc00715 	stw	ra,28(sp)
811406c0:	df000615 	stw	fp,24(sp)
811406c4:	df000604 	addi	fp,sp,24
811406c8:	e13ffc15 	stw	r4,-16(fp)
811406cc:	e17ffd15 	stw	r5,-12(fp)
811406d0:	e1bffe15 	stw	r6,-8(fp)
811406d4:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
811406d8:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811406dc:	e0bffc17 	ldw	r2,-16(fp)
811406e0:	108007cc 	andi	r2,r2,31
811406e4:	10008d1e 	bne	r2,zero,8114091c <Read_File_Record_At_Offset+0x26c>
811406e8:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
811406ec:	10008b26 	beq	r2,zero,8114091c <Read_File_Record_At_Offset+0x26c>
811406f0:	d0a0a917 	ldw	r2,-32092(gp)
811406f4:	10008926 	beq	r2,zero,8114091c <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
811406f8:	e03ffb15 	stw	zero,-20(fp)
811406fc:	00001106 	br	81140744 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
81140700:	e0fffc17 	ldw	r3,-16(fp)
81140704:	e0bffb17 	ldw	r2,-20(fp)
81140708:	1885883a 	add	r2,r3,r2
8114070c:	1007883a 	mov	r3,r2
81140710:	d0a0b217 	ldw	r2,-32056(gp)
81140714:	10800a17 	ldw	r2,40(r2)
81140718:	1885883a 	add	r2,r3,r2
8114071c:	10800023 	ldbuio	r2,0(r2)
81140720:	10803fcc 	andi	r2,r2,255
81140724:	1009883a 	mov	r4,r2
81140728:	e0fffd17 	ldw	r3,-12(fp)
8114072c:	e0bffb17 	ldw	r2,-20(fp)
81140730:	1885883a 	add	r2,r3,r2
81140734:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
81140738:	e0bffb17 	ldw	r2,-20(fp)
8114073c:	10800044 	addi	r2,r2,1
81140740:	e0bffb15 	stw	r2,-20(fp)
81140744:	e0bffb17 	ldw	r2,-20(fp)
81140748:	10800210 	cmplti	r2,r2,8
8114074c:	103fec1e 	bne	r2,zero,81140700 <__reset+0xfb120700>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81140750:	e03ffb15 	stw	zero,-20(fp)
81140754:	00001306 	br	811407a4 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
81140758:	e0fffc17 	ldw	r3,-16(fp)
8114075c:	e0bffb17 	ldw	r2,-20(fp)
81140760:	1885883a 	add	r2,r3,r2
81140764:	1007883a 	mov	r3,r2
81140768:	d0a0b217 	ldw	r2,-32056(gp)
8114076c:	10800a17 	ldw	r2,40(r2)
81140770:	1885883a 	add	r2,r3,r2
81140774:	10800204 	addi	r2,r2,8
81140778:	10800023 	ldbuio	r2,0(r2)
8114077c:	10803fcc 	andi	r2,r2,255
81140780:	1009883a 	mov	r4,r2
81140784:	e0fffd17 	ldw	r3,-12(fp)
81140788:	e0bffb17 	ldw	r2,-20(fp)
8114078c:	1885883a 	add	r2,r3,r2
81140790:	10800204 	addi	r2,r2,8
81140794:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
81140798:	e0bffb17 	ldw	r2,-20(fp)
8114079c:	10800044 	addi	r2,r2,1
811407a0:	e0bffb15 	stw	r2,-20(fp)
811407a4:	e0bffb17 	ldw	r2,-20(fp)
811407a8:	108000d0 	cmplti	r2,r2,3
811407ac:	103fea1e 	bne	r2,zero,81140758 <__reset+0xfb120758>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
811407b0:	d0a0b217 	ldw	r2,-32056(gp)
811407b4:	10c00a17 	ldw	r3,40(r2)
811407b8:	e0bffc17 	ldw	r2,-16(fp)
811407bc:	1885883a 	add	r2,r3,r2
811407c0:	108002c4 	addi	r2,r2,11
811407c4:	10800023 	ldbuio	r2,0(r2)
811407c8:	10803fcc 	andi	r2,r2,255
811407cc:	1007883a 	mov	r3,r2
811407d0:	e0bffd17 	ldw	r2,-12(fp)
811407d4:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
811407d8:	d0a0b217 	ldw	r2,-32056(gp)
811407dc:	10c00a17 	ldw	r3,40(r2)
811407e0:	e0bffc17 	ldw	r2,-16(fp)
811407e4:	1885883a 	add	r2,r3,r2
811407e8:	10800384 	addi	r2,r2,14
811407ec:	1080002b 	ldhuio	r2,0(r2)
811407f0:	10bfffcc 	andi	r2,r2,65535
811407f4:	1007883a 	mov	r3,r2
811407f8:	e0bffd17 	ldw	r2,-12(fp)
811407fc:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
81140800:	d0a0b217 	ldw	r2,-32056(gp)
81140804:	10c00a17 	ldw	r3,40(r2)
81140808:	e0bffc17 	ldw	r2,-16(fp)
8114080c:	1885883a 	add	r2,r3,r2
81140810:	10800404 	addi	r2,r2,16
81140814:	1080002b 	ldhuio	r2,0(r2)
81140818:	10bfffcc 	andi	r2,r2,65535
8114081c:	1007883a 	mov	r3,r2
81140820:	e0bffd17 	ldw	r2,-12(fp)
81140824:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
81140828:	d0a0b217 	ldw	r2,-32056(gp)
8114082c:	10c00a17 	ldw	r3,40(r2)
81140830:	e0bffc17 	ldw	r2,-16(fp)
81140834:	1885883a 	add	r2,r3,r2
81140838:	10800484 	addi	r2,r2,18
8114083c:	1080002b 	ldhuio	r2,0(r2)
81140840:	10bfffcc 	andi	r2,r2,65535
81140844:	1007883a 	mov	r3,r2
81140848:	e0bffd17 	ldw	r2,-12(fp)
8114084c:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
81140850:	d0a0b217 	ldw	r2,-32056(gp)
81140854:	10c00a17 	ldw	r3,40(r2)
81140858:	e0bffc17 	ldw	r2,-16(fp)
8114085c:	1885883a 	add	r2,r3,r2
81140860:	10800584 	addi	r2,r2,22
81140864:	1080002b 	ldhuio	r2,0(r2)
81140868:	10bfffcc 	andi	r2,r2,65535
8114086c:	1007883a 	mov	r3,r2
81140870:	e0bffd17 	ldw	r2,-12(fp)
81140874:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
81140878:	d0a0b217 	ldw	r2,-32056(gp)
8114087c:	10c00a17 	ldw	r3,40(r2)
81140880:	e0bffc17 	ldw	r2,-16(fp)
81140884:	1885883a 	add	r2,r3,r2
81140888:	10800604 	addi	r2,r2,24
8114088c:	1080002b 	ldhuio	r2,0(r2)
81140890:	10bfffcc 	andi	r2,r2,65535
81140894:	1007883a 	mov	r3,r2
81140898:	e0bffd17 	ldw	r2,-12(fp)
8114089c:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
811408a0:	d0a0b217 	ldw	r2,-32056(gp)
811408a4:	10c00a17 	ldw	r3,40(r2)
811408a8:	e0bffc17 	ldw	r2,-16(fp)
811408ac:	1885883a 	add	r2,r3,r2
811408b0:	10800684 	addi	r2,r2,26
811408b4:	1080002b 	ldhuio	r2,0(r2)
811408b8:	10bfffcc 	andi	r2,r2,65535
811408bc:	1007883a 	mov	r3,r2
811408c0:	e0bffd17 	ldw	r2,-12(fp)
811408c4:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
811408c8:	d0a0b217 	ldw	r2,-32056(gp)
811408cc:	10c00a17 	ldw	r3,40(r2)
811408d0:	e0bffc17 	ldw	r2,-16(fp)
811408d4:	1885883a 	add	r2,r3,r2
811408d8:	10800704 	addi	r2,r2,28
811408dc:	10800037 	ldwio	r2,0(r2)
811408e0:	1007883a 	mov	r3,r2
811408e4:	e0bffd17 	ldw	r2,-12(fp)
811408e8:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
811408ec:	e0bffd17 	ldw	r2,-12(fp)
811408f0:	e0fffe17 	ldw	r3,-8(fp)
811408f4:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
811408f8:	e0bffd17 	ldw	r2,-12(fp)
811408fc:	e0ffff17 	ldw	r3,-4(fp)
81140900:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
81140904:	e0bffc17 	ldw	r2,-16(fp)
81140908:	1007883a 	mov	r3,r2
8114090c:	e0bffd17 	ldw	r2,-12(fp)
81140910:	10c00c0d 	sth	r3,48(r2)
		result = true;
81140914:	00800044 	movi	r2,1
81140918:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8114091c:	e0bffa17 	ldw	r2,-24(fp)
}
81140920:	e037883a 	mov	sp,fp
81140924:	dfc00117 	ldw	ra,4(sp)
81140928:	df000017 	ldw	fp,0(sp)
8114092c:	dec00204 	addi	sp,sp,8
81140930:	f800283a 	ret

81140934 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
81140934:	defff904 	addi	sp,sp,-28
81140938:	de00012e 	bgeu	sp,et,81140940 <Write_File_Record_At_Offset+0xc>
8114093c:	003b68fa 	trap	3
81140940:	dfc00615 	stw	ra,24(sp)
81140944:	df000515 	stw	fp,20(sp)
81140948:	df000504 	addi	fp,sp,20
8114094c:	e13ffe15 	stw	r4,-8(fp)
81140950:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
81140954:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81140958:	e0bffe17 	ldw	r2,-8(fp)
8114095c:	108007cc 	andi	r2,r2,31
81140960:	1000931e 	bne	r2,zero,81140bb0 <Write_File_Record_At_Offset+0x27c>
81140964:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
81140968:	10009126 	beq	r2,zero,81140bb0 <Write_File_Record_At_Offset+0x27c>
8114096c:	d0a0a917 	ldw	r2,-32092(gp)
81140970:	10008f26 	beq	r2,zero,81140bb0 <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
81140974:	e03ffc15 	stw	zero,-16(fp)
81140978:	00001f06 	br	811409f8 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8114097c:	e0bffc17 	ldw	r2,-16(fp)
81140980:	10800044 	addi	r2,r2,1
81140984:	e0ffff17 	ldw	r3,-4(fp)
81140988:	1885883a 	add	r2,r3,r2
8114098c:	10800003 	ldbu	r2,0(r2)
81140990:	10803fcc 	andi	r2,r2,255
81140994:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
81140998:	e0bffd0f 	ldh	r2,-12(fp)
8114099c:	1004923a 	slli	r2,r2,8
811409a0:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
811409a4:	e0ffff17 	ldw	r3,-4(fp)
811409a8:	e0bffc17 	ldw	r2,-16(fp)
811409ac:	1885883a 	add	r2,r3,r2
811409b0:	10800003 	ldbu	r2,0(r2)
811409b4:	10c03fcc 	andi	r3,r2,255
811409b8:	e0bffd0b 	ldhu	r2,-12(fp)
811409bc:	1884b03a 	or	r2,r3,r2
811409c0:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
811409c4:	e0fffe17 	ldw	r3,-8(fp)
811409c8:	e0bffc17 	ldw	r2,-16(fp)
811409cc:	1885883a 	add	r2,r3,r2
811409d0:	1007883a 	mov	r3,r2
811409d4:	d0a0b217 	ldw	r2,-32056(gp)
811409d8:	10800a17 	ldw	r2,40(r2)
811409dc:	1885883a 	add	r2,r3,r2
811409e0:	1007883a 	mov	r3,r2
811409e4:	e0bffd0f 	ldh	r2,-12(fp)
811409e8:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
811409ec:	e0bffc17 	ldw	r2,-16(fp)
811409f0:	10800084 	addi	r2,r2,2
811409f4:	e0bffc15 	stw	r2,-16(fp)
811409f8:	e0bffc17 	ldw	r2,-16(fp)
811409fc:	10800210 	cmplti	r2,r2,8
81140a00:	103fde1e 	bne	r2,zero,8114097c <__reset+0xfb12097c>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81140a04:	e03ffc15 	stw	zero,-16(fp)
81140a08:	00001306 	br	81140a58 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
81140a0c:	e0fffe17 	ldw	r3,-8(fp)
81140a10:	e0bffc17 	ldw	r2,-16(fp)
81140a14:	1885883a 	add	r2,r3,r2
81140a18:	1007883a 	mov	r3,r2
81140a1c:	d0a0b217 	ldw	r2,-32056(gp)
81140a20:	10800a17 	ldw	r2,40(r2)
81140a24:	1885883a 	add	r2,r3,r2
81140a28:	10800204 	addi	r2,r2,8
81140a2c:	1009883a 	mov	r4,r2
81140a30:	e0ffff17 	ldw	r3,-4(fp)
81140a34:	e0bffc17 	ldw	r2,-16(fp)
81140a38:	1885883a 	add	r2,r3,r2
81140a3c:	10800204 	addi	r2,r2,8
81140a40:	10800003 	ldbu	r2,0(r2)
81140a44:	10803fcc 	andi	r2,r2,255
81140a48:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
81140a4c:	e0bffc17 	ldw	r2,-16(fp)
81140a50:	10800044 	addi	r2,r2,1
81140a54:	e0bffc15 	stw	r2,-16(fp)
81140a58:	e0bffc17 	ldw	r2,-16(fp)
81140a5c:	108000d0 	cmplti	r2,r2,3
81140a60:	103fea1e 	bne	r2,zero,81140a0c <__reset+0xfb120a0c>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
81140a64:	d0a0b217 	ldw	r2,-32056(gp)
81140a68:	10c00a17 	ldw	r3,40(r2)
81140a6c:	e0bffe17 	ldw	r2,-8(fp)
81140a70:	1885883a 	add	r2,r3,r2
81140a74:	108002c4 	addi	r2,r2,11
81140a78:	1007883a 	mov	r3,r2
81140a7c:	e0bfff17 	ldw	r2,-4(fp)
81140a80:	108002c3 	ldbu	r2,11(r2)
81140a84:	10803fcc 	andi	r2,r2,255
81140a88:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
81140a8c:	d0a0b217 	ldw	r2,-32056(gp)
81140a90:	10c00a17 	ldw	r3,40(r2)
81140a94:	e0bffe17 	ldw	r2,-8(fp)
81140a98:	1885883a 	add	r2,r3,r2
81140a9c:	10800384 	addi	r2,r2,14
81140aa0:	1007883a 	mov	r3,r2
81140aa4:	e0bfff17 	ldw	r2,-4(fp)
81140aa8:	1080030b 	ldhu	r2,12(r2)
81140aac:	10bfffcc 	andi	r2,r2,65535
81140ab0:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
81140ab4:	d0a0b217 	ldw	r2,-32056(gp)
81140ab8:	10c00a17 	ldw	r3,40(r2)
81140abc:	e0bffe17 	ldw	r2,-8(fp)
81140ac0:	1885883a 	add	r2,r3,r2
81140ac4:	10800404 	addi	r2,r2,16
81140ac8:	1007883a 	mov	r3,r2
81140acc:	e0bfff17 	ldw	r2,-4(fp)
81140ad0:	1080038b 	ldhu	r2,14(r2)
81140ad4:	10bfffcc 	andi	r2,r2,65535
81140ad8:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
81140adc:	d0a0b217 	ldw	r2,-32056(gp)
81140ae0:	10c00a17 	ldw	r3,40(r2)
81140ae4:	e0bffe17 	ldw	r2,-8(fp)
81140ae8:	1885883a 	add	r2,r3,r2
81140aec:	10800484 	addi	r2,r2,18
81140af0:	1007883a 	mov	r3,r2
81140af4:	e0bfff17 	ldw	r2,-4(fp)
81140af8:	1080040b 	ldhu	r2,16(r2)
81140afc:	10bfffcc 	andi	r2,r2,65535
81140b00:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
81140b04:	d0a0b217 	ldw	r2,-32056(gp)
81140b08:	10c00a17 	ldw	r3,40(r2)
81140b0c:	e0bffe17 	ldw	r2,-8(fp)
81140b10:	1885883a 	add	r2,r3,r2
81140b14:	10800584 	addi	r2,r2,22
81140b18:	1007883a 	mov	r3,r2
81140b1c:	e0bfff17 	ldw	r2,-4(fp)
81140b20:	1080048b 	ldhu	r2,18(r2)
81140b24:	10bfffcc 	andi	r2,r2,65535
81140b28:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
81140b2c:	d0a0b217 	ldw	r2,-32056(gp)
81140b30:	10c00a17 	ldw	r3,40(r2)
81140b34:	e0bffe17 	ldw	r2,-8(fp)
81140b38:	1885883a 	add	r2,r3,r2
81140b3c:	10800604 	addi	r2,r2,24
81140b40:	1007883a 	mov	r3,r2
81140b44:	e0bfff17 	ldw	r2,-4(fp)
81140b48:	1080050b 	ldhu	r2,20(r2)
81140b4c:	10bfffcc 	andi	r2,r2,65535
81140b50:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
81140b54:	d0a0b217 	ldw	r2,-32056(gp)
81140b58:	10c00a17 	ldw	r3,40(r2)
81140b5c:	e0bffe17 	ldw	r2,-8(fp)
81140b60:	1885883a 	add	r2,r3,r2
81140b64:	10800684 	addi	r2,r2,26
81140b68:	1007883a 	mov	r3,r2
81140b6c:	e0bfff17 	ldw	r2,-4(fp)
81140b70:	1080058b 	ldhu	r2,22(r2)
81140b74:	10bfffcc 	andi	r2,r2,65535
81140b78:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
81140b7c:	d0a0b217 	ldw	r2,-32056(gp)
81140b80:	10c00a17 	ldw	r3,40(r2)
81140b84:	e0bffe17 	ldw	r2,-8(fp)
81140b88:	1885883a 	add	r2,r3,r2
81140b8c:	10800704 	addi	r2,r2,28
81140b90:	1007883a 	mov	r3,r2
81140b94:	e0bfff17 	ldw	r2,-4(fp)
81140b98:	10800617 	ldw	r2,24(r2)
81140b9c:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
81140ba0:	00800044 	movi	r2,1
81140ba4:	d0a0b315 	stw	r2,-32052(gp)
        result = true;
81140ba8:	00800044 	movi	r2,1
81140bac:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
81140bb0:	e0bffb17 	ldw	r2,-20(fp)
}
81140bb4:	e037883a 	mov	sp,fp
81140bb8:	dfc00117 	ldw	ra,4(sp)
81140bbc:	df000017 	ldw	fp,0(sp)
81140bc0:	dec00204 	addi	sp,sp,8
81140bc4:	f800283a 	ret

81140bc8 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
81140bc8:	defff904 	addi	sp,sp,-28
81140bcc:	de00012e 	bgeu	sp,et,81140bd4 <Check_for_DOS_FAT+0xc>
81140bd0:	003b68fa 	trap	3
81140bd4:	dfc00615 	stw	ra,24(sp)
81140bd8:	df000515 	stw	fp,20(sp)
81140bdc:	df000504 	addi	fp,sp,20
81140be0:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
81140be4:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
81140be8:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
81140bec:	e17fff17 	ldw	r5,-4(fp)
81140bf0:	0009883a 	mov	r4,zero
81140bf4:	11402800 	call	81140280 <Read_Sector_Data>
81140bf8:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
81140bfc:	d0a0b217 	ldw	r2,-32056(gp)
81140c00:	10800a17 	ldw	r2,40(r2)
81140c04:	10807f84 	addi	r2,r2,510
81140c08:	1080002b 	ldhuio	r2,0(r2)
81140c0c:	10bfffcc 	andi	r2,r2,65535
81140c10:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
81140c14:	e0bffe0f 	ldh	r2,-8(fp)
81140c18:	10ffffcc 	andi	r3,r2,65535
81140c1c:	00aa9554 	movui	r2,43605
81140c20:	1881841e 	bne	r3,r2,81141234 <Check_for_DOS_FAT+0x66c>
81140c24:	e0bffb17 	ldw	r2,-20(fp)
81140c28:	10018226 	beq	r2,zero,81141234 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
81140c2c:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
81140c30:	d0a0b217 	ldw	r2,-32056(gp)
81140c34:	10800a17 	ldw	r2,40(r2)
81140c38:	10800023 	ldbuio	r2,0(r2)
81140c3c:	10803fcc 	andi	r2,r2,255
81140c40:	1007883a 	mov	r3,r2
81140c44:	00a045f4 	movhi	r2,33047
81140c48:	10aa0004 	addi	r2,r2,-22528
81140c4c:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
81140c50:	d0a0b217 	ldw	r2,-32056(gp)
81140c54:	10800a17 	ldw	r2,40(r2)
81140c58:	10800044 	addi	r2,r2,1
81140c5c:	10800023 	ldbuio	r2,0(r2)
81140c60:	10803fcc 	andi	r2,r2,255
81140c64:	1007883a 	mov	r3,r2
81140c68:	00a045f4 	movhi	r2,33047
81140c6c:	10aa0004 	addi	r2,r2,-22528
81140c70:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
81140c74:	d0a0b217 	ldw	r2,-32056(gp)
81140c78:	10800a17 	ldw	r2,40(r2)
81140c7c:	10800084 	addi	r2,r2,2
81140c80:	10800023 	ldbuio	r2,0(r2)
81140c84:	10803fcc 	andi	r2,r2,255
81140c88:	1007883a 	mov	r3,r2
81140c8c:	00a045f4 	movhi	r2,33047
81140c90:	10aa0004 	addi	r2,r2,-22528
81140c94:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
81140c98:	e03ffc15 	stw	zero,-16(fp)
81140c9c:	00001106 	br	81140ce4 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
81140ca0:	d0a0b217 	ldw	r2,-32056(gp)
81140ca4:	10c00a17 	ldw	r3,40(r2)
81140ca8:	e0bffc17 	ldw	r2,-16(fp)
81140cac:	1885883a 	add	r2,r3,r2
81140cb0:	108000c4 	addi	r2,r2,3
81140cb4:	10800023 	ldbuio	r2,0(r2)
81140cb8:	10803fcc 	andi	r2,r2,255
81140cbc:	1009883a 	mov	r4,r2
81140cc0:	00a045f4 	movhi	r2,33047
81140cc4:	10aa0004 	addi	r2,r2,-22528
81140cc8:	e0fffc17 	ldw	r3,-16(fp)
81140ccc:	10c5883a 	add	r2,r2,r3
81140cd0:	108000c4 	addi	r2,r2,3
81140cd4:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
81140cd8:	e0bffc17 	ldw	r2,-16(fp)
81140cdc:	10800044 	addi	r2,r2,1
81140ce0:	e0bffc15 	stw	r2,-16(fp)
81140ce4:	e0bffc17 	ldw	r2,-16(fp)
81140ce8:	10800210 	cmplti	r2,r2,8
81140cec:	103fec1e 	bne	r2,zero,81140ca0 <__reset+0xfb120ca0>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
81140cf0:	d0a0b217 	ldw	r2,-32056(gp)
81140cf4:	10800a17 	ldw	r2,40(r2)
81140cf8:	10800304 	addi	r2,r2,12
81140cfc:	10800023 	ldbuio	r2,0(r2)
81140d00:	10803fcc 	andi	r2,r2,255
81140d04:	1004923a 	slli	r2,r2,8
81140d08:	1007883a 	mov	r3,r2
81140d0c:	d0a0b217 	ldw	r2,-32056(gp)
81140d10:	10800a17 	ldw	r2,40(r2)
81140d14:	108002c4 	addi	r2,r2,11
81140d18:	10800023 	ldbuio	r2,0(r2)
81140d1c:	10803fcc 	andi	r2,r2,255
81140d20:	10803fcc 	andi	r2,r2,255
81140d24:	1080201c 	xori	r2,r2,128
81140d28:	10bfe004 	addi	r2,r2,-128
81140d2c:	1884b03a 	or	r2,r3,r2
81140d30:	1007883a 	mov	r3,r2
81140d34:	00a045f4 	movhi	r2,33047
81140d38:	10aa0004 	addi	r2,r2,-22528
81140d3c:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
81140d40:	d0a0b217 	ldw	r2,-32056(gp)
81140d44:	10800a17 	ldw	r2,40(r2)
81140d48:	10800344 	addi	r2,r2,13
81140d4c:	10800023 	ldbuio	r2,0(r2)
81140d50:	10803fcc 	andi	r2,r2,255
81140d54:	1007883a 	mov	r3,r2
81140d58:	00a045f4 	movhi	r2,33047
81140d5c:	10aa0004 	addi	r2,r2,-22528
81140d60:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
81140d64:	d0a0b217 	ldw	r2,-32056(gp)
81140d68:	10800a17 	ldw	r2,40(r2)
81140d6c:	10800384 	addi	r2,r2,14
81140d70:	1080002b 	ldhuio	r2,0(r2)
81140d74:	10bfffcc 	andi	r2,r2,65535
81140d78:	1007883a 	mov	r3,r2
81140d7c:	00a045f4 	movhi	r2,33047
81140d80:	10aa0004 	addi	r2,r2,-22528
81140d84:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
81140d88:	d0a0b217 	ldw	r2,-32056(gp)
81140d8c:	10800a17 	ldw	r2,40(r2)
81140d90:	10800404 	addi	r2,r2,16
81140d94:	10800023 	ldbuio	r2,0(r2)
81140d98:	10803fcc 	andi	r2,r2,255
81140d9c:	1007883a 	mov	r3,r2
81140da0:	00a045f4 	movhi	r2,33047
81140da4:	10aa0004 	addi	r2,r2,-22528
81140da8:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
81140dac:	d0a0b217 	ldw	r2,-32056(gp)
81140db0:	10800a17 	ldw	r2,40(r2)
81140db4:	10800484 	addi	r2,r2,18
81140db8:	10800023 	ldbuio	r2,0(r2)
81140dbc:	10803fcc 	andi	r2,r2,255
81140dc0:	1004923a 	slli	r2,r2,8
81140dc4:	1007883a 	mov	r3,r2
81140dc8:	d0a0b217 	ldw	r2,-32056(gp)
81140dcc:	10800a17 	ldw	r2,40(r2)
81140dd0:	10800444 	addi	r2,r2,17
81140dd4:	10800023 	ldbuio	r2,0(r2)
81140dd8:	10803fcc 	andi	r2,r2,255
81140ddc:	10803fcc 	andi	r2,r2,255
81140de0:	1884b03a 	or	r2,r3,r2
81140de4:	1007883a 	mov	r3,r2
81140de8:	00a045f4 	movhi	r2,33047
81140dec:	10aa0004 	addi	r2,r2,-22528
81140df0:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
81140df4:	d0a0b217 	ldw	r2,-32056(gp)
81140df8:	10800a17 	ldw	r2,40(r2)
81140dfc:	10800504 	addi	r2,r2,20
81140e00:	10800023 	ldbuio	r2,0(r2)
81140e04:	10803fcc 	andi	r2,r2,255
81140e08:	1004923a 	slli	r2,r2,8
81140e0c:	1007883a 	mov	r3,r2
81140e10:	d0a0b217 	ldw	r2,-32056(gp)
81140e14:	10800a17 	ldw	r2,40(r2)
81140e18:	108004c4 	addi	r2,r2,19
81140e1c:	10800023 	ldbuio	r2,0(r2)
81140e20:	10803fcc 	andi	r2,r2,255
81140e24:	10803fcc 	andi	r2,r2,255
81140e28:	1884b03a 	or	r2,r3,r2
81140e2c:	1007883a 	mov	r3,r2
81140e30:	00a045f4 	movhi	r2,33047
81140e34:	10aa0004 	addi	r2,r2,-22528
81140e38:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
81140e3c:	d0a0b217 	ldw	r2,-32056(gp)
81140e40:	10800a17 	ldw	r2,40(r2)
81140e44:	10800544 	addi	r2,r2,21
81140e48:	10800023 	ldbuio	r2,0(r2)
81140e4c:	10803fcc 	andi	r2,r2,255
81140e50:	1007883a 	mov	r3,r2
81140e54:	00a045f4 	movhi	r2,33047
81140e58:	10aa0004 	addi	r2,r2,-22528
81140e5c:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
81140e60:	d0a0b217 	ldw	r2,-32056(gp)
81140e64:	10800a17 	ldw	r2,40(r2)
81140e68:	10800584 	addi	r2,r2,22
81140e6c:	1080002b 	ldhuio	r2,0(r2)
81140e70:	10bfffcc 	andi	r2,r2,65535
81140e74:	1007883a 	mov	r3,r2
81140e78:	00a045f4 	movhi	r2,33047
81140e7c:	10aa0004 	addi	r2,r2,-22528
81140e80:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
81140e84:	d0a0b217 	ldw	r2,-32056(gp)
81140e88:	10800a17 	ldw	r2,40(r2)
81140e8c:	10800604 	addi	r2,r2,24
81140e90:	1080002b 	ldhuio	r2,0(r2)
81140e94:	10bfffcc 	andi	r2,r2,65535
81140e98:	1007883a 	mov	r3,r2
81140e9c:	00a045f4 	movhi	r2,33047
81140ea0:	10aa0004 	addi	r2,r2,-22528
81140ea4:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
81140ea8:	d0a0b217 	ldw	r2,-32056(gp)
81140eac:	10800a17 	ldw	r2,40(r2)
81140eb0:	10800684 	addi	r2,r2,26
81140eb4:	1080002b 	ldhuio	r2,0(r2)
81140eb8:	10bfffcc 	andi	r2,r2,65535
81140ebc:	1007883a 	mov	r3,r2
81140ec0:	00a045f4 	movhi	r2,33047
81140ec4:	10aa0004 	addi	r2,r2,-22528
81140ec8:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
81140ecc:	d0a0b217 	ldw	r2,-32056(gp)
81140ed0:	10800a17 	ldw	r2,40(r2)
81140ed4:	10800704 	addi	r2,r2,28
81140ed8:	10800037 	ldwio	r2,0(r2)
81140edc:	1007883a 	mov	r3,r2
81140ee0:	00a045f4 	movhi	r2,33047
81140ee4:	10aa0004 	addi	r2,r2,-22528
81140ee8:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
81140eec:	d0a0b217 	ldw	r2,-32056(gp)
81140ef0:	10800a17 	ldw	r2,40(r2)
81140ef4:	10800804 	addi	r2,r2,32
81140ef8:	10800037 	ldwio	r2,0(r2)
81140efc:	1007883a 	mov	r3,r2
81140f00:	00a045f4 	movhi	r2,33047
81140f04:	10aa0004 	addi	r2,r2,-22528
81140f08:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
81140f0c:	d0a0b217 	ldw	r2,-32056(gp)
81140f10:	10800a17 	ldw	r2,40(r2)
81140f14:	10800904 	addi	r2,r2,36
81140f18:	10800023 	ldbuio	r2,0(r2)
81140f1c:	10803fcc 	andi	r2,r2,255
81140f20:	1007883a 	mov	r3,r2
81140f24:	00a045f4 	movhi	r2,33047
81140f28:	10aa0004 	addi	r2,r2,-22528
81140f2c:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
81140f30:	d0a0b217 	ldw	r2,-32056(gp)
81140f34:	10800a17 	ldw	r2,40(r2)
81140f38:	10800944 	addi	r2,r2,37
81140f3c:	10800023 	ldbuio	r2,0(r2)
81140f40:	10803fcc 	andi	r2,r2,255
81140f44:	1007883a 	mov	r3,r2
81140f48:	00a045f4 	movhi	r2,33047
81140f4c:	10aa0004 	addi	r2,r2,-22528
81140f50:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
81140f54:	d0a0b217 	ldw	r2,-32056(gp)
81140f58:	10800a17 	ldw	r2,40(r2)
81140f5c:	10800984 	addi	r2,r2,38
81140f60:	10800023 	ldbuio	r2,0(r2)
81140f64:	10803fcc 	andi	r2,r2,255
81140f68:	1007883a 	mov	r3,r2
81140f6c:	00a045f4 	movhi	r2,33047
81140f70:	10aa0004 	addi	r2,r2,-22528
81140f74:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
81140f78:	00a045f4 	movhi	r2,33047
81140f7c:	10aa0004 	addi	r2,r2,-22528
81140f80:	1080040b 	ldhu	r2,16(r2)
81140f84:	10ffffcc 	andi	r3,r2,65535
81140f88:	00a045f4 	movhi	r2,33047
81140f8c:	10aa0004 	addi	r2,r2,-22528
81140f90:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
81140f94:	00a045f4 	movhi	r2,33047
81140f98:	10aa0004 	addi	r2,r2,-22528
81140f9c:	10c01117 	ldw	r3,68(r2)
81140fa0:	00a045f4 	movhi	r2,33047
81140fa4:	10aa0004 	addi	r2,r2,-22528
81140fa8:	1080068b 	ldhu	r2,26(r2)
81140fac:	10bfffcc 	andi	r2,r2,65535
81140fb0:	1887883a 	add	r3,r3,r2
81140fb4:	00a045f4 	movhi	r2,33047
81140fb8:	10aa0004 	addi	r2,r2,-22528
81140fbc:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
81140fc0:	00a045f4 	movhi	r2,33047
81140fc4:	10aa0004 	addi	r2,r2,-22528
81140fc8:	10c01217 	ldw	r3,72(r2)
81140fcc:	00a045f4 	movhi	r2,33047
81140fd0:	10aa0004 	addi	r2,r2,-22528
81140fd4:	1080068b 	ldhu	r2,26(r2)
81140fd8:	10bfffcc 	andi	r2,r2,65535
81140fdc:	1887883a 	add	r3,r3,r2
81140fe0:	00a045f4 	movhi	r2,33047
81140fe4:	10aa0004 	addi	r2,r2,-22528
81140fe8:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
81140fec:	00a045f4 	movhi	r2,33047
81140ff0:	10aa0004 	addi	r2,r2,-22528
81140ff4:	10c01317 	ldw	r3,76(r2)
81140ff8:	00a045f4 	movhi	r2,33047
81140ffc:	10aa0004 	addi	r2,r2,-22528
81141000:	1080050b 	ldhu	r2,20(r2)
81141004:	10bfffcc 	andi	r2,r2,65535
81141008:	1008917a 	slli	r4,r2,5
8114100c:	00a045f4 	movhi	r2,33047
81141010:	10aa0004 	addi	r2,r2,-22528
81141014:	1080030b 	ldhu	r2,12(r2)
81141018:	10bfffcc 	andi	r2,r2,65535
8114101c:	2085283a 	div	r2,r4,r2
81141020:	1887883a 	add	r3,r3,r2
81141024:	00a045f4 	movhi	r2,33047
81141028:	10aa0004 	addi	r2,r2,-22528
8114102c:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
81141030:	00a045f4 	movhi	r2,33047
81141034:	10aa0004 	addi	r2,r2,-22528
81141038:	1080058b 	ldhu	r2,22(r2)
8114103c:	10bfffcc 	andi	r2,r2,65535
81141040:	10000b26 	beq	r2,zero,81141070 <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
81141044:	00a045f4 	movhi	r2,33047
81141048:	10aa0004 	addi	r2,r2,-22528
8114104c:	1080058b 	ldhu	r2,22(r2)
81141050:	10ffffcc 	andi	r3,r2,65535
81141054:	00a045f4 	movhi	r2,33047
81141058:	10aa0004 	addi	r2,r2,-22528
8114105c:	10800383 	ldbu	r2,14(r2)
81141060:	10803fcc 	andi	r2,r2,255
81141064:	1885283a 	div	r2,r3,r2
81141068:	e0bffd15 	stw	r2,-12(fp)
8114106c:	00000906 	br	81141094 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
81141070:	00a045f4 	movhi	r2,33047
81141074:	10aa0004 	addi	r2,r2,-22528
81141078:	10c00917 	ldw	r3,36(r2)
8114107c:	00a045f4 	movhi	r2,33047
81141080:	10aa0004 	addi	r2,r2,-22528
81141084:	10800383 	ldbu	r2,14(r2)
81141088:	10803fcc 	andi	r2,r2,255
8114108c:	1885203a 	divu	r2,r3,r2
81141090:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
81141094:	e0bffd17 	ldw	r2,-12(fp)
81141098:	1083fdc8 	cmpgei	r2,r2,4087
8114109c:	1000051e 	bne	r2,zero,811410b4 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
811410a0:	00a045f4 	movhi	r2,33047
811410a4:	10aa0004 	addi	r2,r2,-22528
811410a8:	00c00304 	movi	r3,12
811410ac:	10c01085 	stb	r3,66(r2)
811410b0:	00000c06 	br	811410e4 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
811410b4:	e0bffd17 	ldw	r2,-12(fp)
811410b8:	00fffb54 	movui	r3,65517
811410bc:	18800516 	blt	r3,r2,811410d4 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
811410c0:	00a045f4 	movhi	r2,33047
811410c4:	10aa0004 	addi	r2,r2,-22528
811410c8:	00c00404 	movi	r3,16
811410cc:	10c01085 	stb	r3,66(r2)
811410d0:	00000406 	br	811410e4 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
811410d4:	00a045f4 	movhi	r2,33047
811410d8:	10aa0004 	addi	r2,r2,-22528
811410dc:	00c00804 	movi	r3,32
811410e0:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
811410e4:	e03ffc15 	stw	zero,-16(fp)
811410e8:	00001106 	br	81141130 <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
811410ec:	d0a0b217 	ldw	r2,-32056(gp)
811410f0:	10c00a17 	ldw	r3,40(r2)
811410f4:	e0bffc17 	ldw	r2,-16(fp)
811410f8:	1885883a 	add	r2,r3,r2
811410fc:	108009c4 	addi	r2,r2,39
81141100:	10800023 	ldbuio	r2,0(r2)
81141104:	10803fcc 	andi	r2,r2,255
81141108:	1009883a 	mov	r4,r2
8114110c:	00a045f4 	movhi	r2,33047
81141110:	10aa0004 	addi	r2,r2,-22528
81141114:	e0fffc17 	ldw	r3,-16(fp)
81141118:	10c5883a 	add	r2,r2,r3
8114111c:	10800ac4 	addi	r2,r2,43
81141120:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
81141124:	e0bffc17 	ldw	r2,-16(fp)
81141128:	10800044 	addi	r2,r2,1
8114112c:	e0bffc15 	stw	r2,-16(fp)
81141130:	e0bffc17 	ldw	r2,-16(fp)
81141134:	10800110 	cmplti	r2,r2,4
81141138:	103fec1e 	bne	r2,zero,811410ec <__reset+0xfb1210ec>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8114113c:	e03ffc15 	stw	zero,-16(fp)
81141140:	00001106 	br	81141188 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
81141144:	d0a0b217 	ldw	r2,-32056(gp)
81141148:	10c00a17 	ldw	r3,40(r2)
8114114c:	e0bffc17 	ldw	r2,-16(fp)
81141150:	1885883a 	add	r2,r3,r2
81141154:	10800ac4 	addi	r2,r2,43
81141158:	10800023 	ldbuio	r2,0(r2)
8114115c:	10803fcc 	andi	r2,r2,255
81141160:	1009883a 	mov	r4,r2
81141164:	00a045f4 	movhi	r2,33047
81141168:	10aa0004 	addi	r2,r2,-22528
8114116c:	e0fffc17 	ldw	r3,-16(fp)
81141170:	10c5883a 	add	r2,r2,r3
81141174:	10800bc4 	addi	r2,r2,47
81141178:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8114117c:	e0bffc17 	ldw	r2,-16(fp)
81141180:	10800044 	addi	r2,r2,1
81141184:	e0bffc15 	stw	r2,-16(fp)
81141188:	e0bffc17 	ldw	r2,-16(fp)
8114118c:	108002d0 	cmplti	r2,r2,11
81141190:	103fec1e 	bne	r2,zero,81141144 <__reset+0xfb121144>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
81141194:	e03ffc15 	stw	zero,-16(fp)
81141198:	00001106 	br	811411e0 <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8114119c:	d0a0b217 	ldw	r2,-32056(gp)
811411a0:	10c00a17 	ldw	r3,40(r2)
811411a4:	e0bffc17 	ldw	r2,-16(fp)
811411a8:	1885883a 	add	r2,r3,r2
811411ac:	10800d84 	addi	r2,r2,54
811411b0:	10800023 	ldbuio	r2,0(r2)
811411b4:	10803fcc 	andi	r2,r2,255
811411b8:	1009883a 	mov	r4,r2
811411bc:	00a045f4 	movhi	r2,33047
811411c0:	10aa0004 	addi	r2,r2,-22528
811411c4:	e0fffc17 	ldw	r3,-16(fp)
811411c8:	10c5883a 	add	r2,r2,r3
811411cc:	10800e84 	addi	r2,r2,58
811411d0:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
811411d4:	e0bffc17 	ldw	r2,-16(fp)
811411d8:	10800044 	addi	r2,r2,1
811411dc:	e0bffc15 	stw	r2,-16(fp)
811411e0:	e0bffc17 	ldw	r2,-16(fp)
811411e4:	10800210 	cmplti	r2,r2,8
811411e8:	103fec1e 	bne	r2,zero,8114119c <__reset+0xfb12119c>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
811411ec:	e03ffc15 	stw	zero,-16(fp)
811411f0:	00000a06 	br	8114121c <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
811411f4:	00a045f4 	movhi	r2,33047
811411f8:	10aa1504 	addi	r2,r2,-22444
811411fc:	e0fffc17 	ldw	r3,-16(fp)
81141200:	180691ba 	slli	r3,r3,6
81141204:	10c5883a 	add	r2,r2,r3
81141208:	10800f04 	addi	r2,r2,60
8114120c:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
81141210:	e0bffc17 	ldw	r2,-16(fp)
81141214:	10800044 	addi	r2,r2,1
81141218:	e0bffc15 	stw	r2,-16(fp)
8114121c:	e0bffc17 	ldw	r2,-16(fp)
81141220:	10800510 	cmplti	r2,r2,20
81141224:	103ff31e 	bne	r2,zero,811411f4 <__reset+0xfb1211f4>
		{
			active_files[counter].in_use = false;
		}
		result = true;
81141228:	00800044 	movi	r2,1
8114122c:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
81141230:	00000106 	br	81141238 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
81141234:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
81141238:	e0bffb17 	ldw	r2,-20(fp)
}
8114123c:	e037883a 	mov	sp,fp
81141240:	dfc00117 	ldw	ra,4(sp)
81141244:	df000017 	ldw	fp,0(sp)
81141248:	dec00204 	addi	sp,sp,8
8114124c:	f800283a 	ret

81141250 <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
81141250:	defffc04 	addi	sp,sp,-16
81141254:	de00012e 	bgeu	sp,et,8114125c <Look_for_FAT16+0xc>
81141258:	003b68fa 	trap	3
8114125c:	dfc00315 	stw	ra,12(sp)
81141260:	df000215 	stw	fp,8(sp)
81141264:	df000204 	addi	fp,sp,8
	bool result = false;
81141268:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8114126c:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
81141270:	10002e26 	beq	r2,zero,8114132c <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
81141274:	d0a0ac17 	ldw	r2,-32080(gp)
81141278:	1080000b 	ldhu	r2,0(r2)
8114127c:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
81141280:	d020b015 	stw	zero,-32064(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
81141284:	d020b115 	stw	zero,-32060(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
81141288:	e0bfff0f 	ldh	r2,-4(fp)
8114128c:	10002716 	blt	r2,zero,8114132c <Look_for_FAT16+0xdc>
81141290:	e0bfff0b 	ldhu	r2,-4(fp)
81141294:	10bfffcc 	andi	r2,r2,65535
81141298:	1083000c 	andi	r2,r2,3072
8114129c:	10830020 	cmpeqi	r2,r2,3072
811412a0:	1000221e 	bne	r2,zero,8114132c <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
811412a4:	e0bfff0b 	ldhu	r2,-4(fp)
811412a8:	10bfffcc 	andi	r2,r2,65535
811412ac:	1083000c 	andi	r2,r2,3072
811412b0:	10810018 	cmpnei	r2,r2,1024
811412b4:	1000031e 	bne	r2,zero,811412c4 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
811412b8:	0009883a 	mov	r4,zero
811412bc:	1140bc80 	call	81140bc8 <Check_for_DOS_FAT>
811412c0:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
811412c4:	e0bfff0b 	ldhu	r2,-4(fp)
811412c8:	10bfffcc 	andi	r2,r2,65535
811412cc:	1083000c 	andi	r2,r2,3072
811412d0:	1000061e 	bne	r2,zero,811412ec <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
811412d4:	11405040 	call	81140504 <Check_for_Master_Boot_Record>
811412d8:	10000426 	beq	r2,zero,811412ec <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
811412dc:	d0a0b017 	ldw	r2,-32064(gp)
811412e0:	1009883a 	mov	r4,r2
811412e4:	1140bc80 	call	81140bc8 <Check_for_DOS_FAT>
811412e8:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
811412ec:	e0bffe17 	ldw	r2,-8(fp)
811412f0:	10800058 	cmpnei	r2,r2,1
811412f4:	10000d1e 	bne	r2,zero,8114132c <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
811412f8:	00a045f4 	movhi	r2,33047
811412fc:	10aa0004 	addi	r2,r2,-22528
81141300:	10801083 	ldbu	r2,66(r2)
81141304:	10803fcc 	andi	r2,r2,255
81141308:	10800420 	cmpeqi	r2,r2,16
8114130c:	1000021e 	bne	r2,zero,81141318 <Look_for_FAT16+0xc8>
				{
					result = false;
81141310:	e03ffe15 	stw	zero,-8(fp)
81141314:	00000506 	br	8114132c <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
81141318:	00a045f4 	movhi	r2,33047
8114131c:	10aa0004 	addi	r2,r2,-22528
81141320:	1080058b 	ldhu	r2,22(r2)
81141324:	10bfffcc 	andi	r2,r2,65535
81141328:	d0a0b115 	stw	r2,-32060(gp)
				}
			}
		}
	}
	return result;
8114132c:	e0bffe17 	ldw	r2,-8(fp)
}
81141330:	e037883a 	mov	sp,fp
81141334:	dfc00117 	ldw	ra,4(sp)
81141338:	df000017 	ldw	fp,0(sp)
8114133c:	dec00204 	addi	sp,sp,8
81141340:	f800283a 	ret

81141344 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
81141344:	defffb04 	addi	sp,sp,-20
81141348:	de00012e 	bgeu	sp,et,81141350 <filename_to_upper_case+0xc>
8114134c:	003b68fa 	trap	3
81141350:	dfc00415 	stw	ra,16(sp)
81141354:	df000315 	stw	fp,12(sp)
81141358:	df000304 	addi	fp,sp,12
8114135c:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
81141360:	e13fff17 	ldw	r4,-4(fp)
81141364:	11211a00 	call	811211a0 <strlen>
81141368:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8114136c:	e03ffd15 	stw	zero,-12(fp)
81141370:	00001e06 	br	811413ec <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
81141374:	e0bffd17 	ldw	r2,-12(fp)
81141378:	e0ffff17 	ldw	r3,-4(fp)
8114137c:	1885883a 	add	r2,r3,r2
81141380:	10800003 	ldbu	r2,0(r2)
81141384:	10803fcc 	andi	r2,r2,255
81141388:	1080201c 	xori	r2,r2,128
8114138c:	10bfe004 	addi	r2,r2,-128
81141390:	10801850 	cmplti	r2,r2,97
81141394:	1000121e 	bne	r2,zero,811413e0 <filename_to_upper_case+0x9c>
81141398:	e0bffd17 	ldw	r2,-12(fp)
8114139c:	e0ffff17 	ldw	r3,-4(fp)
811413a0:	1885883a 	add	r2,r3,r2
811413a4:	10800003 	ldbu	r2,0(r2)
811413a8:	10803fcc 	andi	r2,r2,255
811413ac:	1080201c 	xori	r2,r2,128
811413b0:	10bfe004 	addi	r2,r2,-128
811413b4:	10801ec8 	cmpgei	r2,r2,123
811413b8:	1000091e 	bne	r2,zero,811413e0 <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
811413bc:	e0bffd17 	ldw	r2,-12(fp)
811413c0:	e0ffff17 	ldw	r3,-4(fp)
811413c4:	1885883a 	add	r2,r3,r2
811413c8:	e0fffd17 	ldw	r3,-12(fp)
811413cc:	e13fff17 	ldw	r4,-4(fp)
811413d0:	20c7883a 	add	r3,r4,r3
811413d4:	18c00003 	ldbu	r3,0(r3)
811413d8:	18fff804 	addi	r3,r3,-32
811413dc:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
811413e0:	e0bffd17 	ldw	r2,-12(fp)
811413e4:	10800044 	addi	r2,r2,1
811413e8:	e0bffd15 	stw	r2,-12(fp)
811413ec:	e0fffd17 	ldw	r3,-12(fp)
811413f0:	e0bffe17 	ldw	r2,-8(fp)
811413f4:	18bfdf16 	blt	r3,r2,81141374 <__reset+0xfb121374>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
811413f8:	0001883a 	nop
811413fc:	e037883a 	mov	sp,fp
81141400:	dfc00117 	ldw	ra,4(sp)
81141404:	df000017 	ldw	fp,0(sp)
81141408:	dec00204 	addi	sp,sp,8
8114140c:	f800283a 	ret

81141410 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
81141410:	defff804 	addi	sp,sp,-32
81141414:	de00012e 	bgeu	sp,et,8114141c <check_file_name_for_FAT16_compliance+0xc>
81141418:	003b68fa 	trap	3
8114141c:	dfc00715 	stw	ra,28(sp)
81141420:	df000615 	stw	fp,24(sp)
81141424:	df000604 	addi	fp,sp,24
81141428:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8114142c:	e13fff17 	ldw	r4,-4(fp)
81141430:	11211a00 	call	811211a0 <strlen>
81141434:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
81141438:	00bfffc4 	movi	r2,-1
8114143c:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
81141440:	00bfffc4 	movi	r2,-1
81141444:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
81141448:	00800044 	movi	r2,1
8114144c:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
81141450:	e03ffa15 	stw	zero,-24(fp)
81141454:	00006d06 	br	8114160c <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
81141458:	e0bffa17 	ldw	r2,-24(fp)
8114145c:	e0ffff17 	ldw	r3,-4(fp)
81141460:	1885883a 	add	r2,r3,r2
81141464:	10800003 	ldbu	r2,0(r2)
81141468:	10803fcc 	andi	r2,r2,255
8114146c:	1080201c 	xori	r2,r2,128
81141470:	10bfe004 	addi	r2,r2,-128
81141474:	10800820 	cmpeqi	r2,r2,32
81141478:	10003e1e 	bne	r2,zero,81141574 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8114147c:	e0bffa17 	ldw	r2,-24(fp)
81141480:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
81141484:	e0bffb17 	ldw	r2,-20(fp)
81141488:	1880121e 	bne	r3,r2,811414d4 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8114148c:	e0bffa17 	ldw	r2,-24(fp)
81141490:	e0ffff17 	ldw	r3,-4(fp)
81141494:	1885883a 	add	r2,r3,r2
81141498:	10800003 	ldbu	r2,0(r2)
8114149c:	10803fcc 	andi	r2,r2,255
811414a0:	1080201c 	xori	r2,r2,128
811414a4:	10bfe004 	addi	r2,r2,-128
811414a8:	10801720 	cmpeqi	r2,r2,92
811414ac:	1000311e 	bne	r2,zero,81141574 <check_file_name_for_FAT16_compliance+0x164>
811414b0:	e0bffa17 	ldw	r2,-24(fp)
811414b4:	e0ffff17 	ldw	r3,-4(fp)
811414b8:	1885883a 	add	r2,r3,r2
811414bc:	10800003 	ldbu	r2,0(r2)
811414c0:	10803fcc 	andi	r2,r2,255
811414c4:	1080201c 	xori	r2,r2,128
811414c8:	10bfe004 	addi	r2,r2,-128
811414cc:	10800be0 	cmpeqi	r2,r2,47
811414d0:	1000281e 	bne	r2,zero,81141574 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811414d4:	e0fffa17 	ldw	r3,-24(fp)
811414d8:	e0bffc17 	ldw	r2,-16(fp)
811414dc:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
811414e0:	10800258 	cmpnei	r2,r2,9
811414e4:	1000091e 	bne	r2,zero,8114150c <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
811414e8:	e0bffa17 	ldw	r2,-24(fp)
811414ec:	e0ffff17 	ldw	r3,-4(fp)
811414f0:	1885883a 	add	r2,r3,r2
811414f4:	10800003 	ldbu	r2,0(r2)
811414f8:	10803fcc 	andi	r2,r2,255
811414fc:	1080201c 	xori	r2,r2,128
81141500:	10bfe004 	addi	r2,r2,-128
81141504:	10800b98 	cmpnei	r2,r2,46
81141508:	10001a1e 	bne	r2,zero,81141574 <check_file_name_for_FAT16_compliance+0x164>
8114150c:	e0fffb17 	ldw	r3,-20(fp)
81141510:	e0bffc17 	ldw	r2,-16(fp)
81141514:	18801926 	beq	r3,r2,8114157c <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
81141518:	e0fffa17 	ldw	r3,-24(fp)
8114151c:	e0bffc17 	ldw	r2,-16(fp)
81141520:	1885c83a 	sub	r2,r3,r2
81141524:	10800110 	cmplti	r2,r2,4
81141528:	1000141e 	bne	r2,zero,8114157c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8114152c:	e0bffa17 	ldw	r2,-24(fp)
81141530:	e0ffff17 	ldw	r3,-4(fp)
81141534:	1885883a 	add	r2,r3,r2
81141538:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8114153c:	10803fcc 	andi	r2,r2,255
81141540:	1080201c 	xori	r2,r2,128
81141544:	10bfe004 	addi	r2,r2,-128
81141548:	10801720 	cmpeqi	r2,r2,92
8114154c:	10000b1e 	bne	r2,zero,8114157c <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
81141550:	e0bffa17 	ldw	r2,-24(fp)
81141554:	e0ffff17 	ldw	r3,-4(fp)
81141558:	1885883a 	add	r2,r3,r2
8114155c:	10800003 	ldbu	r2,0(r2)
81141560:	10803fcc 	andi	r2,r2,255
81141564:	1080201c 	xori	r2,r2,128
81141568:	10bfe004 	addi	r2,r2,-128
8114156c:	10800be0 	cmpeqi	r2,r2,47
81141570:	1000021e 	bne	r2,zero,8114157c <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
81141574:	e03ffd15 	stw	zero,-12(fp)
            break;
81141578:	00002706 	br	81141618 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8114157c:	e0bffa17 	ldw	r2,-24(fp)
81141580:	e0ffff17 	ldw	r3,-4(fp)
81141584:	1885883a 	add	r2,r3,r2
81141588:	10800003 	ldbu	r2,0(r2)
8114158c:	10803fcc 	andi	r2,r2,255
81141590:	1080201c 	xori	r2,r2,128
81141594:	10bfe004 	addi	r2,r2,-128
81141598:	10801720 	cmpeqi	r2,r2,92
8114159c:	1000091e 	bne	r2,zero,811415c4 <check_file_name_for_FAT16_compliance+0x1b4>
811415a0:	e0bffa17 	ldw	r2,-24(fp)
811415a4:	e0ffff17 	ldw	r3,-4(fp)
811415a8:	1885883a 	add	r2,r3,r2
811415ac:	10800003 	ldbu	r2,0(r2)
811415b0:	10803fcc 	andi	r2,r2,255
811415b4:	1080201c 	xori	r2,r2,128
811415b8:	10bfe004 	addi	r2,r2,-128
811415bc:	10800bd8 	cmpnei	r2,r2,47
811415c0:	1000041e 	bne	r2,zero,811415d4 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
811415c4:	e0bffa17 	ldw	r2,-24(fp)
811415c8:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
811415cc:	e0bffa17 	ldw	r2,-24(fp)
811415d0:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
811415d4:	e0bffa17 	ldw	r2,-24(fp)
811415d8:	e0ffff17 	ldw	r3,-4(fp)
811415dc:	1885883a 	add	r2,r3,r2
811415e0:	10800003 	ldbu	r2,0(r2)
811415e4:	10803fcc 	andi	r2,r2,255
811415e8:	1080201c 	xori	r2,r2,128
811415ec:	10bfe004 	addi	r2,r2,-128
811415f0:	10800b98 	cmpnei	r2,r2,46
811415f4:	1000021e 	bne	r2,zero,81141600 <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
811415f8:	e0bffa17 	ldw	r2,-24(fp)
811415fc:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
81141600:	e0bffa17 	ldw	r2,-24(fp)
81141604:	10800044 	addi	r2,r2,1
81141608:	e0bffa15 	stw	r2,-24(fp)
8114160c:	e0fffa17 	ldw	r3,-24(fp)
81141610:	e0bffe17 	ldw	r2,-8(fp)
81141614:	18bf9016 	blt	r3,r2,81141458 <__reset+0xfb121458>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
81141618:	e0bffe17 	ldw	r2,-8(fp)
8114161c:	10bfffc4 	addi	r2,r2,-1
81141620:	e0ffff17 	ldw	r3,-4(fp)
81141624:	1885883a 	add	r2,r3,r2
81141628:	10800003 	ldbu	r2,0(r2)
8114162c:	10803fcc 	andi	r2,r2,255
81141630:	1080201c 	xori	r2,r2,128
81141634:	10bfe004 	addi	r2,r2,-128
81141638:	10801720 	cmpeqi	r2,r2,92
8114163c:	10000a1e 	bne	r2,zero,81141668 <check_file_name_for_FAT16_compliance+0x258>
81141640:	e0bffe17 	ldw	r2,-8(fp)
81141644:	10bfffc4 	addi	r2,r2,-1
81141648:	e0ffff17 	ldw	r3,-4(fp)
8114164c:	1885883a 	add	r2,r3,r2
81141650:	10800003 	ldbu	r2,0(r2)
81141654:	10803fcc 	andi	r2,r2,255
81141658:	1080201c 	xori	r2,r2,128
8114165c:	10bfe004 	addi	r2,r2,-128
81141660:	10800bd8 	cmpnei	r2,r2,47
81141664:	1000011e 	bne	r2,zero,8114166c <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
81141668:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8114166c:	e0bffd17 	ldw	r2,-12(fp)
}
81141670:	e037883a 	mov	sp,fp
81141674:	dfc00117 	ldw	ra,4(sp)
81141678:	df000017 	ldw	fp,0(sp)
8114167c:	dec00204 	addi	sp,sp,8
81141680:	f800283a 	ret

81141684 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
81141684:	defffb04 	addi	sp,sp,-20
81141688:	de00012e 	bgeu	sp,et,81141690 <get_dir_divider_location+0xc>
8114168c:	003b68fa 	trap	3
81141690:	dfc00415 	stw	ra,16(sp)
81141694:	df000315 	stw	fp,12(sp)
81141698:	df000304 	addi	fp,sp,12
8114169c:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
811416a0:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
811416a4:	e13fff17 	ldw	r4,-4(fp)
811416a8:	11211a00 	call	811211a0 <strlen>
811416ac:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
811416b0:	e03ffd15 	stw	zero,-12(fp)
811416b4:	00001506 	br	8114170c <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
811416b8:	e0bffd17 	ldw	r2,-12(fp)
811416bc:	e0ffff17 	ldw	r3,-4(fp)
811416c0:	1885883a 	add	r2,r3,r2
811416c4:	10800003 	ldbu	r2,0(r2)
811416c8:	10803fcc 	andi	r2,r2,255
811416cc:	1080201c 	xori	r2,r2,128
811416d0:	10bfe004 	addi	r2,r2,-128
811416d4:	10801720 	cmpeqi	r2,r2,92
811416d8:	10000f1e 	bne	r2,zero,81141718 <get_dir_divider_location+0x94>
811416dc:	e0bffd17 	ldw	r2,-12(fp)
811416e0:	e0ffff17 	ldw	r3,-4(fp)
811416e4:	1885883a 	add	r2,r3,r2
811416e8:	10800003 	ldbu	r2,0(r2)
811416ec:	10803fcc 	andi	r2,r2,255
811416f0:	1080201c 	xori	r2,r2,128
811416f4:	10bfe004 	addi	r2,r2,-128
811416f8:	10800be0 	cmpeqi	r2,r2,47
811416fc:	1000061e 	bne	r2,zero,81141718 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
81141700:	e0bffd17 	ldw	r2,-12(fp)
81141704:	10800044 	addi	r2,r2,1
81141708:	e0bffd15 	stw	r2,-12(fp)
8114170c:	e0fffd17 	ldw	r3,-12(fp)
81141710:	e0bffe17 	ldw	r2,-8(fp)
81141714:	18bfe816 	blt	r3,r2,811416b8 <__reset+0xfb1216b8>
        {
            break;
        }
    }
    
    if (index == length)
81141718:	e0fffd17 	ldw	r3,-12(fp)
8114171c:	e0bffe17 	ldw	r2,-8(fp)
81141720:	1880021e 	bne	r3,r2,8114172c <get_dir_divider_location+0xa8>
    {
        index = -1;
81141724:	00bfffc4 	movi	r2,-1
81141728:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8114172c:	e0bffd17 	ldw	r2,-12(fp)
}
81141730:	e037883a 	mov	sp,fp
81141734:	dfc00117 	ldw	ra,4(sp)
81141738:	df000017 	ldw	fp,0(sp)
8114173c:	dec00204 	addi	sp,sp,8
81141740:	f800283a 	ret

81141744 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
81141744:	defffa04 	addi	sp,sp,-24
81141748:	de00012e 	bgeu	sp,et,81141750 <match_file_record_to_name_ext+0xc>
8114174c:	003b68fa 	trap	3
81141750:	df000515 	stw	fp,20(sp)
81141754:	df000504 	addi	fp,sp,20
81141758:	e13ffd15 	stw	r4,-12(fp)
8114175c:	e17ffe15 	stw	r5,-8(fp)
81141760:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
81141764:	00800044 	movi	r2,1
81141768:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8114176c:	e03ffc15 	stw	zero,-16(fp)
81141770:	00004606 	br	8114188c <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
81141774:	e0fffd17 	ldw	r3,-12(fp)
81141778:	e0bffc17 	ldw	r2,-16(fp)
8114177c:	1885883a 	add	r2,r3,r2
81141780:	10800003 	ldbu	r2,0(r2)
81141784:	10803fcc 	andi	r2,r2,255
81141788:	10801870 	cmpltui	r2,r2,97
8114178c:	1000101e 	bne	r2,zero,811417d0 <match_file_record_to_name_ext+0x8c>
81141790:	e0fffd17 	ldw	r3,-12(fp)
81141794:	e0bffc17 	ldw	r2,-16(fp)
81141798:	1885883a 	add	r2,r3,r2
8114179c:	10800003 	ldbu	r2,0(r2)
811417a0:	10803fcc 	andi	r2,r2,255
811417a4:	10801ee8 	cmpgeui	r2,r2,123
811417a8:	1000091e 	bne	r2,zero,811417d0 <match_file_record_to_name_ext+0x8c>
811417ac:	e0fffd17 	ldw	r3,-12(fp)
811417b0:	e0bffc17 	ldw	r2,-16(fp)
811417b4:	1885883a 	add	r2,r3,r2
811417b8:	10800003 	ldbu	r2,0(r2)
811417bc:	10bff804 	addi	r2,r2,-32
811417c0:	10c03fcc 	andi	r3,r2,255
811417c4:	18c0201c 	xori	r3,r3,128
811417c8:	18ffe004 	addi	r3,r3,-128
811417cc:	00000706 	br	811417ec <match_file_record_to_name_ext+0xa8>
811417d0:	e0fffd17 	ldw	r3,-12(fp)
811417d4:	e0bffc17 	ldw	r2,-16(fp)
811417d8:	1885883a 	add	r2,r3,r2
811417dc:	10800003 	ldbu	r2,0(r2)
811417e0:	10c03fcc 	andi	r3,r2,255
811417e4:	18c0201c 	xori	r3,r3,128
811417e8:	18ffe004 	addi	r3,r3,-128
811417ec:	e0bffc17 	ldw	r2,-16(fp)
811417f0:	e13ffe17 	ldw	r4,-8(fp)
811417f4:	2085883a 	add	r2,r4,r2
811417f8:	10800003 	ldbu	r2,0(r2)
811417fc:	10803fcc 	andi	r2,r2,255
81141800:	1080201c 	xori	r2,r2,128
81141804:	10bfe004 	addi	r2,r2,-128
81141808:	10801850 	cmplti	r2,r2,97
8114180c:	1000121e 	bne	r2,zero,81141858 <match_file_record_to_name_ext+0x114>
81141810:	e0bffc17 	ldw	r2,-16(fp)
81141814:	e13ffe17 	ldw	r4,-8(fp)
81141818:	2085883a 	add	r2,r4,r2
8114181c:	10800003 	ldbu	r2,0(r2)
81141820:	10803fcc 	andi	r2,r2,255
81141824:	1080201c 	xori	r2,r2,128
81141828:	10bfe004 	addi	r2,r2,-128
8114182c:	10801ec8 	cmpgei	r2,r2,123
81141830:	1000091e 	bne	r2,zero,81141858 <match_file_record_to_name_ext+0x114>
81141834:	e0bffc17 	ldw	r2,-16(fp)
81141838:	e13ffe17 	ldw	r4,-8(fp)
8114183c:	2085883a 	add	r2,r4,r2
81141840:	10800003 	ldbu	r2,0(r2)
81141844:	10bff804 	addi	r2,r2,-32
81141848:	10803fcc 	andi	r2,r2,255
8114184c:	1080201c 	xori	r2,r2,128
81141850:	10bfe004 	addi	r2,r2,-128
81141854:	00000706 	br	81141874 <match_file_record_to_name_ext+0x130>
81141858:	e0bffc17 	ldw	r2,-16(fp)
8114185c:	e13ffe17 	ldw	r4,-8(fp)
81141860:	2085883a 	add	r2,r4,r2
81141864:	10800003 	ldbu	r2,0(r2)
81141868:	10803fcc 	andi	r2,r2,255
8114186c:	1080201c 	xori	r2,r2,128
81141870:	10bfe004 	addi	r2,r2,-128
81141874:	18800226 	beq	r3,r2,81141880 <match_file_record_to_name_ext+0x13c>
        {
            match = false;
81141878:	e03ffb15 	stw	zero,-20(fp)
			break;
8114187c:	00000606 	br	81141898 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
81141880:	e0bffc17 	ldw	r2,-16(fp)
81141884:	10800044 	addi	r2,r2,1
81141888:	e0bffc15 	stw	r2,-16(fp)
8114188c:	e0bffc17 	ldw	r2,-16(fp)
81141890:	10800210 	cmplti	r2,r2,8
81141894:	103fb71e 	bne	r2,zero,81141774 <__reset+0xfb121774>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
81141898:	e03ffc15 	stw	zero,-16(fp)
8114189c:	00004a06 	br	811419c8 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
811418a0:	e0fffd17 	ldw	r3,-12(fp)
811418a4:	e0bffc17 	ldw	r2,-16(fp)
811418a8:	1885883a 	add	r2,r3,r2
811418ac:	10800204 	addi	r2,r2,8
811418b0:	10800003 	ldbu	r2,0(r2)
811418b4:	10803fcc 	andi	r2,r2,255
811418b8:	10801870 	cmpltui	r2,r2,97
811418bc:	1000121e 	bne	r2,zero,81141908 <match_file_record_to_name_ext+0x1c4>
811418c0:	e0fffd17 	ldw	r3,-12(fp)
811418c4:	e0bffc17 	ldw	r2,-16(fp)
811418c8:	1885883a 	add	r2,r3,r2
811418cc:	10800204 	addi	r2,r2,8
811418d0:	10800003 	ldbu	r2,0(r2)
811418d4:	10803fcc 	andi	r2,r2,255
811418d8:	10801ee8 	cmpgeui	r2,r2,123
811418dc:	10000a1e 	bne	r2,zero,81141908 <match_file_record_to_name_ext+0x1c4>
811418e0:	e0fffd17 	ldw	r3,-12(fp)
811418e4:	e0bffc17 	ldw	r2,-16(fp)
811418e8:	1885883a 	add	r2,r3,r2
811418ec:	10800204 	addi	r2,r2,8
811418f0:	10800003 	ldbu	r2,0(r2)
811418f4:	10bff804 	addi	r2,r2,-32
811418f8:	10c03fcc 	andi	r3,r2,255
811418fc:	18c0201c 	xori	r3,r3,128
81141900:	18ffe004 	addi	r3,r3,-128
81141904:	00000806 	br	81141928 <match_file_record_to_name_ext+0x1e4>
81141908:	e0fffd17 	ldw	r3,-12(fp)
8114190c:	e0bffc17 	ldw	r2,-16(fp)
81141910:	1885883a 	add	r2,r3,r2
81141914:	10800204 	addi	r2,r2,8
81141918:	10800003 	ldbu	r2,0(r2)
8114191c:	10c03fcc 	andi	r3,r2,255
81141920:	18c0201c 	xori	r3,r3,128
81141924:	18ffe004 	addi	r3,r3,-128
81141928:	e0bffc17 	ldw	r2,-16(fp)
8114192c:	e13fff17 	ldw	r4,-4(fp)
81141930:	2085883a 	add	r2,r4,r2
81141934:	10800003 	ldbu	r2,0(r2)
81141938:	10803fcc 	andi	r2,r2,255
8114193c:	1080201c 	xori	r2,r2,128
81141940:	10bfe004 	addi	r2,r2,-128
81141944:	10801850 	cmplti	r2,r2,97
81141948:	1000121e 	bne	r2,zero,81141994 <match_file_record_to_name_ext+0x250>
8114194c:	e0bffc17 	ldw	r2,-16(fp)
81141950:	e13fff17 	ldw	r4,-4(fp)
81141954:	2085883a 	add	r2,r4,r2
81141958:	10800003 	ldbu	r2,0(r2)
8114195c:	10803fcc 	andi	r2,r2,255
81141960:	1080201c 	xori	r2,r2,128
81141964:	10bfe004 	addi	r2,r2,-128
81141968:	10801ec8 	cmpgei	r2,r2,123
8114196c:	1000091e 	bne	r2,zero,81141994 <match_file_record_to_name_ext+0x250>
81141970:	e0bffc17 	ldw	r2,-16(fp)
81141974:	e13fff17 	ldw	r4,-4(fp)
81141978:	2085883a 	add	r2,r4,r2
8114197c:	10800003 	ldbu	r2,0(r2)
81141980:	10bff804 	addi	r2,r2,-32
81141984:	10803fcc 	andi	r2,r2,255
81141988:	1080201c 	xori	r2,r2,128
8114198c:	10bfe004 	addi	r2,r2,-128
81141990:	00000706 	br	811419b0 <match_file_record_to_name_ext+0x26c>
81141994:	e0bffc17 	ldw	r2,-16(fp)
81141998:	e13fff17 	ldw	r4,-4(fp)
8114199c:	2085883a 	add	r2,r4,r2
811419a0:	10800003 	ldbu	r2,0(r2)
811419a4:	10803fcc 	andi	r2,r2,255
811419a8:	1080201c 	xori	r2,r2,128
811419ac:	10bfe004 	addi	r2,r2,-128
811419b0:	18800226 	beq	r3,r2,811419bc <match_file_record_to_name_ext+0x278>
        {
            match = false;
811419b4:	e03ffb15 	stw	zero,-20(fp)
			break;
811419b8:	00000606 	br	811419d4 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
811419bc:	e0bffc17 	ldw	r2,-16(fp)
811419c0:	10800044 	addi	r2,r2,1
811419c4:	e0bffc15 	stw	r2,-16(fp)
811419c8:	e0bffc17 	ldw	r2,-16(fp)
811419cc:	108000d0 	cmplti	r2,r2,3
811419d0:	103fb31e 	bne	r2,zero,811418a0 <__reset+0xfb1218a0>
        {
            match = false;
			break;
        }
    }
	return match;
811419d4:	e0bffb17 	ldw	r2,-20(fp)
}
811419d8:	e037883a 	mov	sp,fp
811419dc:	df000017 	ldw	fp,0(sp)
811419e0:	dec00104 	addi	sp,sp,4
811419e4:	f800283a 	ret

811419e8 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
811419e8:	deffe704 	addi	sp,sp,-100
811419ec:	de00012e 	bgeu	sp,et,811419f4 <get_home_directory_cluster_for_file+0xc>
811419f0:	003b68fa 	trap	3
811419f4:	dfc01815 	stw	ra,96(sp)
811419f8:	df001715 	stw	fp,92(sp)
811419fc:	df001704 	addi	fp,sp,92
81141a00:	e13ffd15 	stw	r4,-12(fp)
81141a04:	e17ffe15 	stw	r5,-8(fp)
81141a08:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
81141a0c:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
81141a10:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
81141a14:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
81141a18:	e13ffd17 	ldw	r4,-12(fp)
81141a1c:	11416840 	call	81141684 <get_dir_divider_location>
81141a20:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
81141a24:	00012f06 	br	81141ee4 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81141a28:	00800804 	movi	r2,32
81141a2c:	e0bff905 	stb	r2,-28(fp)
81141a30:	00800804 	movi	r2,32
81141a34:	e0bff945 	stb	r2,-27(fp)
81141a38:	00800804 	movi	r2,32
81141a3c:	e0bff985 	stb	r2,-26(fp)
81141a40:	00800804 	movi	r2,32
81141a44:	e0bff9c5 	stb	r2,-25(fp)
81141a48:	00800804 	movi	r2,32
81141a4c:	e0bffa05 	stb	r2,-24(fp)
81141a50:	00800804 	movi	r2,32
81141a54:	e0bffa45 	stb	r2,-23(fp)
81141a58:	00800804 	movi	r2,32
81141a5c:	e0bffa85 	stb	r2,-22(fp)
81141a60:	00800804 	movi	r2,32
81141a64:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
81141a68:	00800804 	movi	r2,32
81141a6c:	e0bffb05 	stb	r2,-20(fp)
81141a70:	00800804 	movi	r2,32
81141a74:	e0bffb45 	stb	r2,-19(fp)
81141a78:	00800804 	movi	r2,32
81141a7c:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
81141a80:	00bfffc4 	movi	r2,-1
81141a84:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
81141a88:	e0bfea17 	ldw	r2,-88(fp)
81141a8c:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81141a90:	e03fec15 	stw	zero,-80(fp)
81141a94:	00002d06 	br	81141b4c <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
81141a98:	e0ffec17 	ldw	r3,-80(fp)
81141a9c:	e0bfed17 	ldw	r2,-76(fp)
81141aa0:	1885883a 	add	r2,r3,r2
81141aa4:	1007883a 	mov	r3,r2
81141aa8:	e0bffd17 	ldw	r2,-12(fp)
81141aac:	10c5883a 	add	r2,r2,r3
81141ab0:	10800003 	ldbu	r2,0(r2)
81141ab4:	10803fcc 	andi	r2,r2,255
81141ab8:	1080201c 	xori	r2,r2,128
81141abc:	10bfe004 	addi	r2,r2,-128
81141ac0:	10800b98 	cmpnei	r2,r2,46
81141ac4:	1000031e 	bne	r2,zero,81141ad4 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
81141ac8:	e0bfec17 	ldw	r2,-80(fp)
81141acc:	e0bfee15 	stw	r2,-72(fp)
81141ad0:	00001b06 	br	81141b40 <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
81141ad4:	e0bfee17 	ldw	r2,-72(fp)
81141ad8:	10000c0e 	bge	r2,zero,81141b0c <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
81141adc:	e0ffec17 	ldw	r3,-80(fp)
81141ae0:	e0bfed17 	ldw	r2,-76(fp)
81141ae4:	1885883a 	add	r2,r3,r2
81141ae8:	1007883a 	mov	r3,r2
81141aec:	e0bffd17 	ldw	r2,-12(fp)
81141af0:	10c5883a 	add	r2,r2,r3
81141af4:	10c00003 	ldbu	r3,0(r2)
81141af8:	e13ff904 	addi	r4,fp,-28
81141afc:	e0bfec17 	ldw	r2,-80(fp)
81141b00:	2085883a 	add	r2,r4,r2
81141b04:	10c00005 	stb	r3,0(r2)
81141b08:	00000d06 	br	81141b40 <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
81141b0c:	e0ffec17 	ldw	r3,-80(fp)
81141b10:	e0bfee17 	ldw	r2,-72(fp)
81141b14:	1885c83a 	sub	r2,r3,r2
81141b18:	e13fec17 	ldw	r4,-80(fp)
81141b1c:	e0ffed17 	ldw	r3,-76(fp)
81141b20:	20c7883a 	add	r3,r4,r3
81141b24:	1809883a 	mov	r4,r3
81141b28:	e0fffd17 	ldw	r3,-12(fp)
81141b2c:	1907883a 	add	r3,r3,r4
81141b30:	18c00003 	ldbu	r3,0(r3)
81141b34:	e13ffb04 	addi	r4,fp,-20
81141b38:	2085883a 	add	r2,r4,r2
81141b3c:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
81141b40:	e0bfec17 	ldw	r2,-80(fp)
81141b44:	10800044 	addi	r2,r2,1
81141b48:	e0bfec15 	stw	r2,-80(fp)
81141b4c:	e0ffec17 	ldw	r3,-80(fp)
81141b50:	e0bfeb17 	ldw	r2,-84(fp)
81141b54:	18bfd016 	blt	r3,r2,81141a98 <__reset+0xfb121a98>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
81141b58:	e0bfea17 	ldw	r2,-88(fp)
81141b5c:	10005c1e 	bne	r2,zero,81141cd0 <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
81141b60:	00a045f4 	movhi	r2,33047
81141b64:	10aa0004 	addi	r2,r2,-22528
81141b68:	1080050b 	ldhu	r2,20(r2)
81141b6c:	10bfffcc 	andi	r2,r2,65535
81141b70:	1006917a 	slli	r3,r2,5
81141b74:	00a045f4 	movhi	r2,33047
81141b78:	10aa0004 	addi	r2,r2,-22528
81141b7c:	1080030b 	ldhu	r2,12(r2)
81141b80:	10bfffcc 	andi	r2,r2,65535
81141b84:	1885283a 	div	r2,r3,r2
81141b88:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81141b8c:	e03ff015 	stw	zero,-64(fp)
81141b90:	00003b06 	br	81141c80 <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
81141b94:	00a045f4 	movhi	r2,33047
81141b98:	10aa0004 	addi	r2,r2,-22528
81141b9c:	10c01317 	ldw	r3,76(r2)
81141ba0:	e0bff017 	ldw	r2,-64(fp)
81141ba4:	1885883a 	add	r2,r3,r2
81141ba8:	1007883a 	mov	r3,r2
81141bac:	d0a0b017 	ldw	r2,-32064(gp)
81141bb0:	100b883a 	mov	r5,r2
81141bb4:	1809883a 	mov	r4,r3
81141bb8:	11402800 	call	81140280 <Read_Sector_Data>
81141bbc:	10003426 	beq	r2,zero,81141c90 <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81141bc0:	e03ff115 	stw	zero,-60(fp)
81141bc4:	00002506 	br	81141c5c <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81141bc8:	e0bff117 	ldw	r2,-60(fp)
81141bcc:	1004917a 	slli	r2,r2,5
81141bd0:	e0fff017 	ldw	r3,-64(fp)
81141bd4:	180f883a 	mov	r7,r3
81141bd8:	000d883a 	mov	r6,zero
81141bdc:	e17fff17 	ldw	r5,-4(fp)
81141be0:	1009883a 	mov	r4,r2
81141be4:	11406b00 	call	811406b0 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81141be8:	e0bfff17 	ldw	r2,-4(fp)
81141bec:	10800003 	ldbu	r2,0(r2)
81141bf0:	10803fcc 	andi	r2,r2,255
81141bf4:	10803960 	cmpeqi	r2,r2,229
81141bf8:	1000151e 	bne	r2,zero,81141c50 <get_home_directory_cluster_for_file+0x268>
81141bfc:	e0bfff17 	ldw	r2,-4(fp)
81141c00:	10800003 	ldbu	r2,0(r2)
81141c04:	10803fcc 	andi	r2,r2,255
81141c08:	10001126 	beq	r2,zero,81141c50 <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81141c0c:	e0fffb04 	addi	r3,fp,-20
81141c10:	e0bff904 	addi	r2,fp,-28
81141c14:	180d883a 	mov	r6,r3
81141c18:	100b883a 	mov	r5,r2
81141c1c:	e13fff17 	ldw	r4,-4(fp)
81141c20:	11417440 	call	81141744 <match_file_record_to_name_ext>
81141c24:	e0bff815 	stw	r2,-32(fp)
                            if (match)
81141c28:	e0bff817 	ldw	r2,-32(fp)
81141c2c:	10000826 	beq	r2,zero,81141c50 <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
81141c30:	e0bfff17 	ldw	r2,-4(fp)
81141c34:	1080058b 	ldhu	r2,22(r2)
81141c38:	10bfffcc 	andi	r2,r2,65535
81141c3c:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
81141c40:	e0bfff17 	ldw	r2,-4(fp)
81141c44:	00c00044 	movi	r3,1
81141c48:	10c00a15 	stw	r3,40(r2)
                                break;
81141c4c:	00000606 	br	81141c68 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81141c50:	e0bff117 	ldw	r2,-60(fp)
81141c54:	10800044 	addi	r2,r2,1
81141c58:	e0bff115 	stw	r2,-60(fp)
81141c5c:	e0bff117 	ldw	r2,-60(fp)
81141c60:	10800410 	cmplti	r2,r2,16
81141c64:	103fd81e 	bne	r2,zero,81141bc8 <__reset+0xfb121bc8>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
81141c68:	e0ffef17 	ldw	r3,-68(fp)
81141c6c:	e0bfea17 	ldw	r2,-88(fp)
81141c70:	1880091e 	bne	r3,r2,81141c98 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81141c74:	e0bff017 	ldw	r2,-64(fp)
81141c78:	10800044 	addi	r2,r2,1
81141c7c:	e0bff015 	stw	r2,-64(fp)
81141c80:	e0fff017 	ldw	r3,-64(fp)
81141c84:	e0bff717 	ldw	r2,-36(fp)
81141c88:	18bfc216 	blt	r3,r2,81141b94 <__reset+0xfb121b94>
81141c8c:	00000306 	br	81141c9c <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
81141c90:	0001883a 	nop
81141c94:	00000106 	br	81141c9c <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
81141c98:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
81141c9c:	e0ffef17 	ldw	r3,-68(fp)
81141ca0:	e0bfea17 	ldw	r2,-88(fp)
81141ca4:	18800826 	beq	r3,r2,81141cc8 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81141ca8:	e0bfef17 	ldw	r2,-68(fp)
81141cac:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81141cb0:	e0ffed17 	ldw	r3,-76(fp)
81141cb4:	e0bfeb17 	ldw	r2,-84(fp)
81141cb8:	1885883a 	add	r2,r3,r2
81141cbc:	10800044 	addi	r2,r2,1
81141cc0:	e0bfed15 	stw	r2,-76(fp)
81141cc4:	00007d06 	br	81141ebc <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81141cc8:	0005883a 	mov	r2,zero
81141ccc:	00009106 	br	81141f14 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
81141cd0:	e0bfea17 	ldw	r2,-88(fp)
81141cd4:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81141cd8:	e0bff417 	ldw	r2,-48(fp)
81141cdc:	10ffff84 	addi	r3,r2,-2
81141ce0:	00a045f4 	movhi	r2,33047
81141ce4:	10aa0004 	addi	r2,r2,-22528
81141ce8:	10800383 	ldbu	r2,14(r2)
81141cec:	10803fcc 	andi	r2,r2,255
81141cf0:	1885383a 	mul	r2,r3,r2
81141cf4:	1007883a 	mov	r3,r2
81141cf8:	00a045f4 	movhi	r2,33047
81141cfc:	10aa0004 	addi	r2,r2,-22528
81141d00:	10801417 	ldw	r2,80(r2)
81141d04:	1885883a 	add	r2,r3,r2
81141d08:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81141d0c:	e03ff215 	stw	zero,-56(fp)
81141d10:	00003606 	br	81141dec <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81141d14:	e0fff217 	ldw	r3,-56(fp)
81141d18:	e0bff517 	ldw	r2,-44(fp)
81141d1c:	1885883a 	add	r2,r3,r2
81141d20:	d0e0b017 	ldw	r3,-32064(gp)
81141d24:	180b883a 	mov	r5,r3
81141d28:	1009883a 	mov	r4,r2
81141d2c:	11402800 	call	81140280 <Read_Sector_Data>
81141d30:	10003526 	beq	r2,zero,81141e08 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81141d34:	e03ff315 	stw	zero,-52(fp)
81141d38:	00002306 	br	81141dc8 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81141d3c:	e0bff317 	ldw	r2,-52(fp)
81141d40:	1004917a 	slli	r2,r2,5
81141d44:	e0fff417 	ldw	r3,-48(fp)
81141d48:	e13ff217 	ldw	r4,-56(fp)
81141d4c:	200f883a 	mov	r7,r4
81141d50:	180d883a 	mov	r6,r3
81141d54:	e17fff17 	ldw	r5,-4(fp)
81141d58:	1009883a 	mov	r4,r2
81141d5c:	11406b00 	call	811406b0 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81141d60:	e0bfff17 	ldw	r2,-4(fp)
81141d64:	10800003 	ldbu	r2,0(r2)
81141d68:	10803fcc 	andi	r2,r2,255
81141d6c:	10803960 	cmpeqi	r2,r2,229
81141d70:	1000121e 	bne	r2,zero,81141dbc <get_home_directory_cluster_for_file+0x3d4>
81141d74:	e0bfff17 	ldw	r2,-4(fp)
81141d78:	10800003 	ldbu	r2,0(r2)
81141d7c:	10803fcc 	andi	r2,r2,255
81141d80:	10000e26 	beq	r2,zero,81141dbc <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
81141d84:	e0fffb04 	addi	r3,fp,-20
81141d88:	e0bff904 	addi	r2,fp,-28
81141d8c:	180d883a 	mov	r6,r3
81141d90:	100b883a 	mov	r5,r2
81141d94:	e13fff17 	ldw	r4,-4(fp)
81141d98:	11417440 	call	81141744 <match_file_record_to_name_ext>
81141d9c:	e0bff615 	stw	r2,-40(fp)
                                if (match)
81141da0:	e0bff617 	ldw	r2,-40(fp)
81141da4:	10000526 	beq	r2,zero,81141dbc <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
81141da8:	e0bfff17 	ldw	r2,-4(fp)
81141dac:	1080058b 	ldhu	r2,22(r2)
81141db0:	10bfffcc 	andi	r2,r2,65535
81141db4:	e0bfef15 	stw	r2,-68(fp)
                                    break;
81141db8:	00000606 	br	81141dd4 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
81141dbc:	e0bff317 	ldw	r2,-52(fp)
81141dc0:	10800044 	addi	r2,r2,1
81141dc4:	e0bff315 	stw	r2,-52(fp)
81141dc8:	e0bff317 	ldw	r2,-52(fp)
81141dcc:	10800410 	cmplti	r2,r2,16
81141dd0:	103fda1e 	bne	r2,zero,81141d3c <__reset+0xfb121d3c>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
81141dd4:	e0ffef17 	ldw	r3,-68(fp)
81141dd8:	e0bfea17 	ldw	r2,-88(fp)
81141ddc:	18800c1e 	bne	r3,r2,81141e10 <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81141de0:	e0bff217 	ldw	r2,-56(fp)
81141de4:	10800044 	addi	r2,r2,1
81141de8:	e0bff215 	stw	r2,-56(fp)
81141dec:	00a045f4 	movhi	r2,33047
81141df0:	10aa0004 	addi	r2,r2,-22528
81141df4:	10800383 	ldbu	r2,14(r2)
81141df8:	10803fcc 	andi	r2,r2,255
81141dfc:	e0fff217 	ldw	r3,-56(fp)
81141e00:	18bfc416 	blt	r3,r2,81141d14 <__reset+0xfb121d14>
81141e04:	00000306 	br	81141e14 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
81141e08:	0001883a 	nop
81141e0c:	00000106 	br	81141e14 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
81141e10:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
81141e14:	e0ffef17 	ldw	r3,-68(fp)
81141e18:	e0bfea17 	ldw	r2,-88(fp)
81141e1c:	1880141e 	bne	r3,r2,81141e70 <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
81141e20:	e0bfef17 	ldw	r2,-68(fp)
81141e24:	e0fffc04 	addi	r3,fp,-16
81141e28:	180b883a 	mov	r5,r3
81141e2c:	1009883a 	mov	r4,r2
81141e30:	11403600 	call	81140360 <get_cluster_flag>
81141e34:	10000c26 	beq	r2,zero,81141e68 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81141e38:	e0bffc0b 	ldhu	r2,-16(fp)
81141e3c:	10bfffcc 	andi	r2,r2,65535
81141e40:	10fffe0c 	andi	r3,r2,65528
81141e44:	00bffe14 	movui	r2,65528
81141e48:	1880021e 	bne	r3,r2,81141e54 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
81141e4c:	0005883a 	mov	r2,zero
81141e50:	00003006 	br	81141f14 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
81141e54:	e0bffc0b 	ldhu	r2,-16(fp)
81141e58:	10bfffcc 	andi	r2,r2,65535
81141e5c:	10bffe0c 	andi	r2,r2,65528
81141e60:	e0bfef15 	stw	r2,-68(fp)
81141e64:	00000206 	br	81141e70 <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
81141e68:	0005883a 	mov	r2,zero
81141e6c:	00002906 	br	81141f14 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
81141e70:	e0bff417 	ldw	r2,-48(fp)
81141e74:	00fffdd4 	movui	r3,65527
81141e78:	18800316 	blt	r3,r2,81141e88 <get_home_directory_cluster_for_file+0x4a0>
81141e7c:	e0ffef17 	ldw	r3,-68(fp)
81141e80:	e0bfea17 	ldw	r2,-88(fp)
81141e84:	18bf9426 	beq	r3,r2,81141cd8 <__reset+0xfb121cd8>
            if (new_cluster != home_dir_cluster)
81141e88:	e0ffef17 	ldw	r3,-68(fp)
81141e8c:	e0bfea17 	ldw	r2,-88(fp)
81141e90:	18800826 	beq	r3,r2,81141eb4 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
81141e94:	e0bfef17 	ldw	r2,-68(fp)
81141e98:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
81141e9c:	e0ffed17 	ldw	r3,-76(fp)
81141ea0:	e0bfeb17 	ldw	r2,-84(fp)
81141ea4:	1885883a 	add	r2,r3,r2
81141ea8:	10800044 	addi	r2,r2,1
81141eac:	e0bfed15 	stw	r2,-76(fp)
81141eb0:	00000206 	br	81141ebc <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
81141eb4:	0005883a 	mov	r2,zero
81141eb8:	00001606 	br	81141f14 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
81141ebc:	e0bfed17 	ldw	r2,-76(fp)
81141ec0:	e0fffd17 	ldw	r3,-12(fp)
81141ec4:	1885883a 	add	r2,r3,r2
81141ec8:	1009883a 	mov	r4,r2
81141ecc:	11416840 	call	81141684 <get_dir_divider_location>
81141ed0:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
81141ed4:	e0bfeb17 	ldw	r2,-84(fp)
81141ed8:	1000020e 	bge	r2,zero,81141ee4 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
81141edc:	00800044 	movi	r2,1
81141ee0:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
81141ee4:	e0bfeb17 	ldw	r2,-84(fp)
81141ee8:	00becf16 	blt	zero,r2,81141a28 <__reset+0xfb121a28>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
81141eec:	e0bffe17 	ldw	r2,-8(fp)
81141ef0:	e0ffea17 	ldw	r3,-88(fp)
81141ef4:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
81141ef8:	e0bfea17 	ldw	r2,-88(fp)
81141efc:	1000041e 	bne	r2,zero,81141f10 <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
81141f00:	e0bfff17 	ldw	r2,-4(fp)
81141f04:	10000a15 	stw	zero,40(r2)
		result = true;
81141f08:	00800044 	movi	r2,1
81141f0c:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
81141f10:	e0bfe917 	ldw	r2,-92(fp)
}
81141f14:	e037883a 	mov	sp,fp
81141f18:	dfc00117 	ldw	ra,4(sp)
81141f1c:	df000017 	ldw	fp,0(sp)
81141f20:	dec00204 	addi	sp,sp,8
81141f24:	f800283a 	ret

81141f28 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
81141f28:	deffe804 	addi	sp,sp,-96
81141f2c:	de00012e 	bgeu	sp,et,81141f34 <find_file_in_directory+0xc>
81141f30:	003b68fa 	trap	3
81141f34:	dfc01715 	stw	ra,92(sp)
81141f38:	df001615 	stw	fp,88(sp)
81141f3c:	df001604 	addi	fp,sp,88
81141f40:	e13ffd15 	stw	r4,-12(fp)
81141f44:	e17ffe15 	stw	r5,-8(fp)
81141f48:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
81141f4c:	e13ffe17 	ldw	r4,-8(fp)
81141f50:	11416840 	call	81141684 <get_dir_divider_location>
81141f54:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
81141f58:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
81141f5c:	00800804 	movi	r2,32
81141f60:	e0bff905 	stb	r2,-28(fp)
81141f64:	00800804 	movi	r2,32
81141f68:	e0bff945 	stb	r2,-27(fp)
81141f6c:	00800804 	movi	r2,32
81141f70:	e0bff985 	stb	r2,-26(fp)
81141f74:	00800804 	movi	r2,32
81141f78:	e0bff9c5 	stb	r2,-25(fp)
81141f7c:	00800804 	movi	r2,32
81141f80:	e0bffa05 	stb	r2,-24(fp)
81141f84:	00800804 	movi	r2,32
81141f88:	e0bffa45 	stb	r2,-23(fp)
81141f8c:	00800804 	movi	r2,32
81141f90:	e0bffa85 	stb	r2,-22(fp)
81141f94:	00800804 	movi	r2,32
81141f98:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
81141f9c:	00800804 	movi	r2,32
81141fa0:	e0bffb05 	stb	r2,-20(fp)
81141fa4:	00800804 	movi	r2,32
81141fa8:	e0bffb45 	stb	r2,-19(fp)
81141fac:	00800804 	movi	r2,32
81141fb0:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
81141fb4:	00bfffc4 	movi	r2,-1
81141fb8:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
81141fbc:	e0bffd17 	ldw	r2,-12(fp)
81141fc0:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
81141fc4:	e13ffe17 	ldw	r4,-8(fp)
81141fc8:	11211a00 	call	811211a0 <strlen>
81141fcc:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
81141fd0:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
81141fd4:	00000b06 	br	81142004 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
81141fd8:	e0ffeb17 	ldw	r3,-84(fp)
81141fdc:	e0bfea17 	ldw	r2,-88(fp)
81141fe0:	1885883a 	add	r2,r3,r2
81141fe4:	10800044 	addi	r2,r2,1
81141fe8:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
81141fec:	e0bfeb17 	ldw	r2,-84(fp)
81141ff0:	e0fffe17 	ldw	r3,-8(fp)
81141ff4:	1885883a 	add	r2,r3,r2
81141ff8:	1009883a 	mov	r4,r2
81141ffc:	11416840 	call	81141684 <get_dir_divider_location>
81142000:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
81142004:	e0bfea17 	ldw	r2,-88(fp)
81142008:	00bff316 	blt	zero,r2,81141fd8 <__reset+0xfb121fd8>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8114200c:	e0bfeb17 	ldw	r2,-84(fp)
81142010:	e0bfee15 	stw	r2,-72(fp)
81142014:	00002706 	br	811420b4 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
81142018:	e0bfee17 	ldw	r2,-72(fp)
8114201c:	e0fffe17 	ldw	r3,-8(fp)
81142020:	1885883a 	add	r2,r3,r2
81142024:	10800003 	ldbu	r2,0(r2)
81142028:	10803fcc 	andi	r2,r2,255
8114202c:	1080201c 	xori	r2,r2,128
81142030:	10bfe004 	addi	r2,r2,-128
81142034:	10800b98 	cmpnei	r2,r2,46
81142038:	1000031e 	bne	r2,zero,81142048 <find_file_in_directory+0x120>
        {
            ext_index = index;
8114203c:	e0bfee17 	ldw	r2,-72(fp)
81142040:	e0bfec15 	stw	r2,-80(fp)
81142044:	00001806 	br	811420a8 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81142048:	e0bfec17 	ldw	r2,-80(fp)
8114204c:	10000b0e 	bge	r2,zero,8114207c <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
81142050:	e0ffee17 	ldw	r3,-72(fp)
81142054:	e0bfeb17 	ldw	r2,-84(fp)
81142058:	1885c83a 	sub	r2,r3,r2
8114205c:	e0ffee17 	ldw	r3,-72(fp)
81142060:	e13ffe17 	ldw	r4,-8(fp)
81142064:	20c7883a 	add	r3,r4,r3
81142068:	18c00003 	ldbu	r3,0(r3)
8114206c:	e13ff904 	addi	r4,fp,-28
81142070:	2085883a 	add	r2,r4,r2
81142074:	10c00005 	stb	r3,0(r2)
81142078:	00000b06 	br	811420a8 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
8114207c:	e0ffee17 	ldw	r3,-72(fp)
81142080:	e0bfec17 	ldw	r2,-80(fp)
81142084:	1885c83a 	sub	r2,r3,r2
81142088:	10bfffc4 	addi	r2,r2,-1
8114208c:	e0ffee17 	ldw	r3,-72(fp)
81142090:	e13ffe17 	ldw	r4,-8(fp)
81142094:	20c7883a 	add	r3,r4,r3
81142098:	18c00003 	ldbu	r3,0(r3)
8114209c:	e13ffb04 	addi	r4,fp,-20
811420a0:	2085883a 	add	r2,r4,r2
811420a4:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
811420a8:	e0bfee17 	ldw	r2,-72(fp)
811420ac:	10800044 	addi	r2,r2,1
811420b0:	e0bfee15 	stw	r2,-72(fp)
811420b4:	e0ffee17 	ldw	r3,-72(fp)
811420b8:	e0bff417 	ldw	r2,-48(fp)
811420bc:	18bfd616 	blt	r3,r2,81142018 <__reset+0xfb122018>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
811420c0:	e0bffd17 	ldw	r2,-12(fp)
811420c4:	1000461e 	bne	r2,zero,811421e0 <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811420c8:	00a045f4 	movhi	r2,33047
811420cc:	10aa0004 	addi	r2,r2,-22528
811420d0:	1080050b 	ldhu	r2,20(r2)
811420d4:	10bfffcc 	andi	r2,r2,65535
811420d8:	1006917a 	slli	r3,r2,5
811420dc:	00a045f4 	movhi	r2,33047
811420e0:	10aa0004 	addi	r2,r2,-22528
811420e4:	1080030b 	ldhu	r2,12(r2)
811420e8:	10bfffcc 	andi	r2,r2,65535
811420ec:	1885283a 	div	r2,r3,r2
811420f0:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811420f4:	e03ff015 	stw	zero,-64(fp)
811420f8:	00003506 	br	811421d0 <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811420fc:	00a045f4 	movhi	r2,33047
81142100:	10aa0004 	addi	r2,r2,-22528
81142104:	10c01317 	ldw	r3,76(r2)
81142108:	e0bff017 	ldw	r2,-64(fp)
8114210c:	1885883a 	add	r2,r3,r2
81142110:	1007883a 	mov	r3,r2
81142114:	d0a0b017 	ldw	r2,-32064(gp)
81142118:	100b883a 	mov	r5,r2
8114211c:	1809883a 	mov	r4,r3
81142120:	11402800 	call	81140280 <Read_Sector_Data>
81142124:	10009626 	beq	r2,zero,81142380 <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81142128:	e03ff115 	stw	zero,-60(fp)
8114212c:	00002006 	br	811421b0 <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
81142130:	e0bff117 	ldw	r2,-60(fp)
81142134:	1004917a 	slli	r2,r2,5
81142138:	e0fff017 	ldw	r3,-64(fp)
8114213c:	180f883a 	mov	r7,r3
81142140:	000d883a 	mov	r6,zero
81142144:	e17fff17 	ldw	r5,-4(fp)
81142148:	1009883a 	mov	r4,r2
8114214c:	11406b00 	call	811406b0 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81142150:	e0bfff17 	ldw	r2,-4(fp)
81142154:	10800003 	ldbu	r2,0(r2)
81142158:	10803fcc 	andi	r2,r2,255
8114215c:	10803960 	cmpeqi	r2,r2,229
81142160:	1000101e 	bne	r2,zero,811421a4 <find_file_in_directory+0x27c>
81142164:	e0bfff17 	ldw	r2,-4(fp)
81142168:	10800003 	ldbu	r2,0(r2)
8114216c:	10803fcc 	andi	r2,r2,255
81142170:	10000c26 	beq	r2,zero,811421a4 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81142174:	e0fffb04 	addi	r3,fp,-20
81142178:	e0bff904 	addi	r2,fp,-28
8114217c:	180d883a 	mov	r6,r3
81142180:	100b883a 	mov	r5,r2
81142184:	e13fff17 	ldw	r4,-4(fp)
81142188:	11417440 	call	81141744 <match_file_record_to_name_ext>
8114218c:	e0bff815 	stw	r2,-32(fp)

                        if (match)
81142190:	e0bff817 	ldw	r2,-32(fp)
81142194:	10000326 	beq	r2,zero,811421a4 <find_file_in_directory+0x27c>
                        {
                            result = true;
81142198:	00800044 	movi	r2,1
8114219c:	e0bfef15 	stw	r2,-68(fp)
                            break;
811421a0:	00000606 	br	811421bc <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811421a4:	e0bff117 	ldw	r2,-60(fp)
811421a8:	10800044 	addi	r2,r2,1
811421ac:	e0bff115 	stw	r2,-60(fp)
811421b0:	e0bff117 	ldw	r2,-60(fp)
811421b4:	10800410 	cmplti	r2,r2,16
811421b8:	103fdd1e 	bne	r2,zero,81142130 <__reset+0xfb122130>
            }
            else
            {
                break;
            }
            if (result)
811421bc:	e0bfef17 	ldw	r2,-68(fp)
811421c0:	1000711e 	bne	r2,zero,81142388 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811421c4:	e0bff017 	ldw	r2,-64(fp)
811421c8:	10800044 	addi	r2,r2,1
811421cc:	e0bff015 	stw	r2,-64(fp)
811421d0:	e0fff017 	ldw	r3,-64(fp)
811421d4:	e0bff717 	ldw	r2,-36(fp)
811421d8:	18bfc816 	blt	r3,r2,811420fc <__reset+0xfb1220fc>
811421dc:	00006b06 	br	8114238c <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811421e0:	e0bfed17 	ldw	r2,-76(fp)
811421e4:	10ffff84 	addi	r3,r2,-2
811421e8:	00a045f4 	movhi	r2,33047
811421ec:	10aa0004 	addi	r2,r2,-22528
811421f0:	10800383 	ldbu	r2,14(r2)
811421f4:	10803fcc 	andi	r2,r2,255
811421f8:	1885383a 	mul	r2,r3,r2
811421fc:	1007883a 	mov	r3,r2
81142200:	00a045f4 	movhi	r2,33047
81142204:	10aa0004 	addi	r2,r2,-22528
81142208:	10801417 	ldw	r2,80(r2)
8114220c:	1885883a 	add	r2,r3,r2
81142210:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81142214:	e03ff215 	stw	zero,-56(fp)
81142218:	00003306 	br	811422e8 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8114221c:	e0fff217 	ldw	r3,-56(fp)
81142220:	e0bff517 	ldw	r2,-44(fp)
81142224:	1885883a 	add	r2,r3,r2
81142228:	d0e0b017 	ldw	r3,-32064(gp)
8114222c:	180b883a 	mov	r5,r3
81142230:	1009883a 	mov	r4,r2
81142234:	11402800 	call	81140280 <Read_Sector_Data>
81142238:	10003226 	beq	r2,zero,81142304 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8114223c:	e03ff315 	stw	zero,-52(fp)
81142240:	00002106 	br	811422c8 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81142244:	e0bff317 	ldw	r2,-52(fp)
81142248:	1004917a 	slli	r2,r2,5
8114224c:	e0ffed17 	ldw	r3,-76(fp)
81142250:	e13ff217 	ldw	r4,-56(fp)
81142254:	200f883a 	mov	r7,r4
81142258:	180d883a 	mov	r6,r3
8114225c:	e17fff17 	ldw	r5,-4(fp)
81142260:	1009883a 	mov	r4,r2
81142264:	11406b00 	call	811406b0 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81142268:	e0bfff17 	ldw	r2,-4(fp)
8114226c:	10800003 	ldbu	r2,0(r2)
81142270:	10803fcc 	andi	r2,r2,255
81142274:	10803960 	cmpeqi	r2,r2,229
81142278:	1000101e 	bne	r2,zero,811422bc <find_file_in_directory+0x394>
8114227c:	e0bfff17 	ldw	r2,-4(fp)
81142280:	10800003 	ldbu	r2,0(r2)
81142284:	10803fcc 	andi	r2,r2,255
81142288:	10000c26 	beq	r2,zero,811422bc <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8114228c:	e0fffb04 	addi	r3,fp,-20
81142290:	e0bff904 	addi	r2,fp,-28
81142294:	180d883a 	mov	r6,r3
81142298:	100b883a 	mov	r5,r2
8114229c:	e13fff17 	ldw	r4,-4(fp)
811422a0:	11417440 	call	81141744 <match_file_record_to_name_ext>
811422a4:	e0bff615 	stw	r2,-40(fp)

                            if (match)
811422a8:	e0bff617 	ldw	r2,-40(fp)
811422ac:	10000326 	beq	r2,zero,811422bc <find_file_in_directory+0x394>
                            {                               
                                result = true;
811422b0:	00800044 	movi	r2,1
811422b4:	e0bfef15 	stw	r2,-68(fp)
                                break;
811422b8:	00000606 	br	811422d4 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
811422bc:	e0bff317 	ldw	r2,-52(fp)
811422c0:	10800044 	addi	r2,r2,1
811422c4:	e0bff315 	stw	r2,-52(fp)
811422c8:	e0bff317 	ldw	r2,-52(fp)
811422cc:	10800410 	cmplti	r2,r2,16
811422d0:	103fdc1e 	bne	r2,zero,81142244 <__reset+0xfb122244>
                }
                else
                {
                    break;
                }
                if (result)
811422d4:	e0bfef17 	ldw	r2,-68(fp)
811422d8:	10000c1e 	bne	r2,zero,8114230c <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811422dc:	e0bff217 	ldw	r2,-56(fp)
811422e0:	10800044 	addi	r2,r2,1
811422e4:	e0bff215 	stw	r2,-56(fp)
811422e8:	00a045f4 	movhi	r2,33047
811422ec:	10aa0004 	addi	r2,r2,-22528
811422f0:	10800383 	ldbu	r2,14(r2)
811422f4:	10803fcc 	andi	r2,r2,255
811422f8:	e0fff217 	ldw	r3,-56(fp)
811422fc:	18bfc716 	blt	r3,r2,8114221c <__reset+0xfb12221c>
81142300:	00000306 	br	81142310 <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
81142304:	0001883a 	nop
81142308:	00000106 	br	81142310 <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
8114230c:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
81142310:	e0bfef17 	ldw	r2,-68(fp)
81142314:	1000141e 	bne	r2,zero,81142368 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
81142318:	e0bfed17 	ldw	r2,-76(fp)
8114231c:	e0fffc04 	addi	r3,fp,-16
81142320:	180b883a 	mov	r5,r3
81142324:	1009883a 	mov	r4,r2
81142328:	11403600 	call	81140360 <get_cluster_flag>
8114232c:	10000c26 	beq	r2,zero,81142360 <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81142330:	e0bffc0b 	ldhu	r2,-16(fp)
81142334:	10bfffcc 	andi	r2,r2,65535
81142338:	10fffe0c 	andi	r3,r2,65528
8114233c:	00bffe14 	movui	r2,65528
81142340:	1880021e 	bne	r3,r2,8114234c <find_file_in_directory+0x424>
					{
						return false;
81142344:	0005883a 	mov	r2,zero
81142348:	00001106 	br	81142390 <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
8114234c:	e0bffc0b 	ldhu	r2,-16(fp)
81142350:	10bfffcc 	andi	r2,r2,65535
81142354:	10bffe0c 	andi	r2,r2,65528
81142358:	e0bfed15 	stw	r2,-76(fp)
8114235c:	00000206 	br	81142368 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
81142360:	0005883a 	mov	r2,zero
81142364:	00000a06 	br	81142390 <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81142368:	e0bfed17 	ldw	r2,-76(fp)
8114236c:	00fffdd4 	movui	r3,65527
81142370:	18800616 	blt	r3,r2,8114238c <find_file_in_directory+0x464>
81142374:	e0bfef17 	ldw	r2,-68(fp)
81142378:	103f9926 	beq	r2,zero,811421e0 <__reset+0xfb1221e0>
8114237c:	00000306 	br	8114238c <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
81142380:	0001883a 	nop
81142384:	00000106 	br	8114238c <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81142388:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
8114238c:	e0bfef17 	ldw	r2,-68(fp)
}
81142390:	e037883a 	mov	sp,fp
81142394:	dfc00117 	ldw	ra,4(sp)
81142398:	df000017 	ldw	fp,0(sp)
8114239c:	dec00204 	addi	sp,sp,8
811423a0:	f800283a 	ret

811423a4 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
811423a4:	defff504 	addi	sp,sp,-44
811423a8:	de00012e 	bgeu	sp,et,811423b0 <find_first_empty_cluster+0xc>
811423ac:	003b68fa 	trap	3
811423b0:	dfc00a15 	stw	ra,40(sp)
811423b4:	df000915 	stw	fp,36(sp)
811423b8:	df000904 	addi	fp,sp,36
811423bc:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
811423c0:	00a045f4 	movhi	r2,33047
811423c4:	10aa0004 	addi	r2,r2,-22528
811423c8:	10801117 	ldw	r2,68(r2)
811423cc:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
811423d0:	00800084 	movi	r2,2
811423d4:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
811423d8:	00bfffc4 	movi	r2,-1
811423dc:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
811423e0:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
811423e4:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
811423e8:	00a045f4 	movhi	r2,33047
811423ec:	10aa0004 	addi	r2,r2,-22528
811423f0:	10801417 	ldw	r2,80(r2)
811423f4:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
811423f8:	00a045f4 	movhi	r2,33047
811423fc:	10aa0004 	addi	r2,r2,-22528
81142400:	1080058b 	ldhu	r2,22(r2)
81142404:	10bfffcc 	andi	r2,r2,65535
81142408:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
8114240c:	00a045f4 	movhi	r2,33047
81142410:	10aa0004 	addi	r2,r2,-22528
81142414:	10800917 	ldw	r2,36(r2)
81142418:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
8114241c:	e0bffd17 	ldw	r2,-12(fp)
81142420:	e0fffe17 	ldw	r3,-8(fp)
81142424:	18800b2e 	bgeu	r3,r2,81142454 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81142428:	e0fffd17 	ldw	r3,-12(fp)
8114242c:	e0bffc17 	ldw	r2,-16(fp)
81142430:	1887c83a 	sub	r3,r3,r2
81142434:	00a045f4 	movhi	r2,33047
81142438:	10aa0004 	addi	r2,r2,-22528
8114243c:	10800383 	ldbu	r2,14(r2)
81142440:	10803fcc 	andi	r2,r2,255
81142444:	1885203a 	divu	r2,r3,r2
81142448:	10800044 	addi	r2,r2,1
8114244c:	e0bffb15 	stw	r2,-20(fp)
81142450:	00002a06 	br	811424fc <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81142454:	e0fffe17 	ldw	r3,-8(fp)
81142458:	e0bffc17 	ldw	r2,-16(fp)
8114245c:	1887c83a 	sub	r3,r3,r2
81142460:	00a045f4 	movhi	r2,33047
81142464:	10aa0004 	addi	r2,r2,-22528
81142468:	10800383 	ldbu	r2,14(r2)
8114246c:	10803fcc 	andi	r2,r2,255
81142470:	1885203a 	divu	r2,r3,r2
81142474:	10800044 	addi	r2,r2,1
81142478:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
8114247c:	00001f06 	br	811424fc <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
81142480:	e0bff717 	ldw	r2,-36(fp)
81142484:	d0e0b017 	ldw	r3,-32064(gp)
81142488:	180b883a 	mov	r5,r3
8114248c:	1009883a 	mov	r4,r2
81142490:	11402800 	call	81140280 <Read_Sector_Data>
81142494:	10001426 	beq	r2,zero,811424e8 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81142498:	e0bff817 	ldw	r2,-32(fp)
8114249c:	10803fcc 	andi	r2,r2,255
811424a0:	1085883a 	add	r2,r2,r2
811424a4:	1007883a 	mov	r3,r2
811424a8:	d0a0b217 	ldw	r2,-32056(gp)
811424ac:	10800a17 	ldw	r2,40(r2)
811424b0:	1885883a 	add	r2,r3,r2
811424b4:	1080002b 	ldhuio	r2,0(r2)
811424b8:	10bfffcc 	andi	r2,r2,65535
811424bc:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
811424c0:	e0bff90f 	ldh	r2,-28(fp)
811424c4:	10000726 	beq	r2,zero,811424e4 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
811424c8:	e0bff817 	ldw	r2,-32(fp)
811424cc:	10800044 	addi	r2,r2,1
811424d0:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
811424d4:	e0bff817 	ldw	r2,-32(fp)
811424d8:	10803fcc 	andi	r2,r2,255
811424dc:	103fee1e 	bne	r2,zero,81142498 <__reset+0xfb122498>
811424e0:	00000106 	br	811424e8 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
811424e4:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
811424e8:	e0bff90f 	ldh	r2,-28(fp)
811424ec:	10000926 	beq	r2,zero,81142514 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811424f0:	e0bff717 	ldw	r2,-36(fp)
811424f4:	10800044 	addi	r2,r2,1
811424f8:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811424fc:	00a045f4 	movhi	r2,33047
81142500:	10aa0004 	addi	r2,r2,-22528
81142504:	10c01217 	ldw	r3,72(r2)
81142508:	e0bff717 	ldw	r2,-36(fp)
8114250c:	18bfdc1e 	bne	r3,r2,81142480 <__reset+0xfb122480>
81142510:	00000106 	br	81142518 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
81142514:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
81142518:	e0bff90f 	ldh	r2,-28(fp)
8114251c:	1000081e 	bne	r2,zero,81142540 <find_first_empty_cluster+0x19c>
81142520:	e0bff90f 	ldh	r2,-28(fp)
81142524:	e0fffb17 	ldw	r3,-20(fp)
81142528:	18800536 	bltu	r3,r2,81142540 <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
8114252c:	e0bfff17 	ldw	r2,-4(fp)
81142530:	e0fff817 	ldw	r3,-32(fp)
81142534:	10c00015 	stw	r3,0(r2)
		result = true;
81142538:	00800044 	movi	r2,1
8114253c:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
81142540:	e0bffa17 	ldw	r2,-24(fp)
}
81142544:	e037883a 	mov	sp,fp
81142548:	dfc00117 	ldw	ra,4(sp)
8114254c:	df000017 	ldw	fp,0(sp)
81142550:	dec00204 	addi	sp,sp,8
81142554:	f800283a 	ret

81142558 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81142558:	defff604 	addi	sp,sp,-40
8114255c:	de00012e 	bgeu	sp,et,81142564 <find_first_empty_record_in_a_subdirectory+0xc>
81142560:	003b68fa 	trap	3
81142564:	dfc00915 	stw	ra,36(sp)
81142568:	df000815 	stw	fp,32(sp)
8114256c:	df000804 	addi	fp,sp,32
81142570:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81142574:	00bfffc4 	movi	r2,-1
81142578:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
8114257c:	e0bfff17 	ldw	r2,-4(fp)
81142580:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81142584:	e0bff917 	ldw	r2,-28(fp)
81142588:	10ffff84 	addi	r3,r2,-2
8114258c:	00a045f4 	movhi	r2,33047
81142590:	10aa0004 	addi	r2,r2,-22528
81142594:	10800383 	ldbu	r2,14(r2)
81142598:	10803fcc 	andi	r2,r2,255
8114259c:	1885383a 	mul	r2,r3,r2
811425a0:	1007883a 	mov	r3,r2
811425a4:	00a045f4 	movhi	r2,33047
811425a8:	10aa0004 	addi	r2,r2,-22528
811425ac:	10801417 	ldw	r2,80(r2)
811425b0:	1885883a 	add	r2,r3,r2
811425b4:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811425b8:	e03ffa15 	stw	zero,-24(fp)
811425bc:	00002c06 	br	81142670 <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811425c0:	e0fffa17 	ldw	r3,-24(fp)
811425c4:	e0bffc17 	ldw	r2,-16(fp)
811425c8:	1885883a 	add	r2,r3,r2
811425cc:	d0e0b017 	ldw	r3,-32064(gp)
811425d0:	180b883a 	mov	r5,r3
811425d4:	1009883a 	mov	r4,r2
811425d8:	11402800 	call	81140280 <Read_Sector_Data>
811425dc:	10002b26 	beq	r2,zero,8114268c <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811425e0:	e03ffb15 	stw	zero,-20(fp)
811425e4:	00001c06 	br	81142658 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811425e8:	e0bffb17 	ldw	r2,-20(fp)
811425ec:	1004917a 	slli	r2,r2,5
811425f0:	1007883a 	mov	r3,r2
811425f4:	d0a0b217 	ldw	r2,-32056(gp)
811425f8:	10800a17 	ldw	r2,40(r2)
811425fc:	1885883a 	add	r2,r3,r2
81142600:	10800023 	ldbuio	r2,0(r2)
81142604:	10803fcc 	andi	r2,r2,255
81142608:	10803fcc 	andi	r2,r2,255
8114260c:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
81142610:	e0bffd0b 	ldhu	r2,-12(fp)
81142614:	10803960 	cmpeqi	r2,r2,229
81142618:	1000021e 	bne	r2,zero,81142624 <find_first_empty_record_in_a_subdirectory+0xcc>
8114261c:	e0bffd0b 	ldhu	r2,-12(fp)
81142620:	10000a1e 	bne	r2,zero,8114264c <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81142624:	e0bffa17 	ldw	r2,-24(fp)
81142628:	1006913a 	slli	r3,r2,4
8114262c:	e0bffb17 	ldw	r2,-20(fp)
81142630:	1885883a 	add	r2,r3,r2
81142634:	1006943a 	slli	r3,r2,16
81142638:	e0bff917 	ldw	r2,-28(fp)
8114263c:	1884b03a 	or	r2,r3,r2
81142640:	e0bff815 	stw	r2,-32(fp)
                        return result;
81142644:	e0bff817 	ldw	r2,-32(fp)
81142648:	00005306 	br	81142798 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
8114264c:	e0bffb17 	ldw	r2,-20(fp)
81142650:	10800044 	addi	r2,r2,1
81142654:	e0bffb15 	stw	r2,-20(fp)
81142658:	e0bffb17 	ldw	r2,-20(fp)
8114265c:	10800410 	cmplti	r2,r2,16
81142660:	103fe11e 	bne	r2,zero,811425e8 <__reset+0xfb1225e8>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81142664:	e0bffa17 	ldw	r2,-24(fp)
81142668:	10800044 	addi	r2,r2,1
8114266c:	e0bffa15 	stw	r2,-24(fp)
81142670:	00a045f4 	movhi	r2,33047
81142674:	10aa0004 	addi	r2,r2,-22528
81142678:	10800383 	ldbu	r2,14(r2)
8114267c:	10803fcc 	andi	r2,r2,255
81142680:	e0fffa17 	ldw	r3,-24(fp)
81142684:	18bfce16 	blt	r3,r2,811425c0 <__reset+0xfb1225c0>
81142688:	00000106 	br	81142690 <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
8114268c:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
81142690:	e0bff817 	ldw	r2,-32(fp)
81142694:	1000390e 	bge	r2,zero,8114277c <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
81142698:	e0bff917 	ldw	r2,-28(fp)
8114269c:	e0fffd84 	addi	r3,fp,-10
811426a0:	180b883a 	mov	r5,r3
811426a4:	1009883a 	mov	r4,r2
811426a8:	11403600 	call	81140360 <get_cluster_flag>
811426ac:	10003126 	beq	r2,zero,81142774 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811426b0:	e0bffd8b 	ldhu	r2,-10(fp)
811426b4:	10bfffcc 	andi	r2,r2,65535
811426b8:	10fffe0c 	andi	r3,r2,65528
811426bc:	00bffe14 	movui	r2,65528
811426c0:	18802e1e 	bne	r3,r2,8114277c <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
811426c4:	e0bffe04 	addi	r2,fp,-8
811426c8:	1009883a 	mov	r4,r2
811426cc:	11423a40 	call	811423a4 <find_first_empty_cluster>
811426d0:	10002326 	beq	r2,zero,81142760 <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811426d4:	e0bff917 	ldw	r2,-28(fp)
811426d8:	e0fffe17 	ldw	r3,-8(fp)
811426dc:	18ffffcc 	andi	r3,r3,65535
811426e0:	18e0001c 	xori	r3,r3,32768
811426e4:	18e00004 	addi	r3,r3,-32768
811426e8:	01800044 	movi	r6,1
811426ec:	180b883a 	mov	r5,r3
811426f0:	1009883a 	mov	r4,r2
811426f4:	114041c0 	call	8114041c <mark_cluster>
811426f8:	10001926 	beq	r2,zero,81142760 <find_first_empty_record_in_a_subdirectory+0x208>
811426fc:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81142700:	01800044 	movi	r6,1
81142704:	017fffc4 	movi	r5,-1
81142708:	1009883a 	mov	r4,r2
8114270c:	114041c0 	call	8114041c <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
81142710:	10001326 	beq	r2,zero,81142760 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81142714:	e0bff917 	ldw	r2,-28(fp)
81142718:	e0fffe17 	ldw	r3,-8(fp)
8114271c:	18ffffcc 	andi	r3,r3,65535
81142720:	18e0001c 	xori	r3,r3,32768
81142724:	18e00004 	addi	r3,r3,-32768
81142728:	000d883a 	mov	r6,zero
8114272c:	180b883a 	mov	r5,r3
81142730:	1009883a 	mov	r4,r2
81142734:	114041c0 	call	8114041c <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81142738:	10000926 	beq	r2,zero,81142760 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8114273c:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
81142740:	000d883a 	mov	r6,zero
81142744:	017fffc4 	movi	r5,-1
81142748:	1009883a 	mov	r4,r2
8114274c:	114041c0 	call	8114041c <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81142750:	10000326 	beq	r2,zero,81142760 <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81142754:	114022c0 	call	8114022c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81142758:	e0bffe17 	ldw	r2,-8(fp)
8114275c:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
81142760:	e0bffd8b 	ldhu	r2,-10(fp)
81142764:	10bfffcc 	andi	r2,r2,65535
81142768:	10bffe0c 	andi	r2,r2,65528
8114276c:	e0bff915 	stw	r2,-28(fp)
81142770:	00000206 	br	8114277c <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81142774:	00bfffc4 	movi	r2,-1
81142778:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
8114277c:	e0bff917 	ldw	r2,-28(fp)
81142780:	00fffdd4 	movui	r3,65527
81142784:	18800316 	blt	r3,r2,81142794 <find_first_empty_record_in_a_subdirectory+0x23c>
81142788:	e0bff817 	ldw	r2,-32(fp)
8114278c:	10bfffe0 	cmpeqi	r2,r2,-1
81142790:	103f7c1e 	bne	r2,zero,81142584 <__reset+0xfb122584>
    return result; 
81142794:	e0bff817 	ldw	r2,-32(fp)
}
81142798:	e037883a 	mov	sp,fp
8114279c:	dfc00117 	ldw	ra,4(sp)
811427a0:	df000017 	ldw	fp,0(sp)
811427a4:	dec00204 	addi	sp,sp,8
811427a8:	f800283a 	ret

811427ac <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
811427ac:	defff904 	addi	sp,sp,-28
811427b0:	de00012e 	bgeu	sp,et,811427b8 <find_first_empty_record_in_root_directory+0xc>
811427b4:	003b68fa 	trap	3
811427b8:	dfc00615 	stw	ra,24(sp)
811427bc:	df000515 	stw	fp,20(sp)
811427c0:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811427c4:	00a045f4 	movhi	r2,33047
811427c8:	10aa0004 	addi	r2,r2,-22528
811427cc:	1080050b 	ldhu	r2,20(r2)
811427d0:	10bfffcc 	andi	r2,r2,65535
811427d4:	1006917a 	slli	r3,r2,5
811427d8:	00a045f4 	movhi	r2,33047
811427dc:	10aa0004 	addi	r2,r2,-22528
811427e0:	1080030b 	ldhu	r2,12(r2)
811427e4:	10bfffcc 	andi	r2,r2,65535
811427e8:	1885283a 	div	r2,r3,r2
811427ec:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
811427f0:	00bfffc4 	movi	r2,-1
811427f4:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811427f8:	e03ffb15 	stw	zero,-20(fp)
811427fc:	00002d06 	br	811428b4 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81142800:	00a045f4 	movhi	r2,33047
81142804:	10aa0004 	addi	r2,r2,-22528
81142808:	10c01317 	ldw	r3,76(r2)
8114280c:	e0bffb17 	ldw	r2,-20(fp)
81142810:	1885883a 	add	r2,r3,r2
81142814:	1007883a 	mov	r3,r2
81142818:	d0a0b017 	ldw	r2,-32064(gp)
8114281c:	100b883a 	mov	r5,r2
81142820:	1809883a 	mov	r4,r3
81142824:	11402800 	call	81140280 <Read_Sector_Data>
81142828:	10002626 	beq	r2,zero,811428c4 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8114282c:	e03ffc15 	stw	zero,-16(fp)
81142830:	00001a06 	br	8114289c <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81142834:	e0bffc17 	ldw	r2,-16(fp)
81142838:	1004917a 	slli	r2,r2,5
8114283c:	1007883a 	mov	r3,r2
81142840:	d0a0b217 	ldw	r2,-32056(gp)
81142844:	10800a17 	ldw	r2,40(r2)
81142848:	1885883a 	add	r2,r3,r2
8114284c:	10800023 	ldbuio	r2,0(r2)
81142850:	10803fcc 	andi	r2,r2,255
81142854:	10803fcc 	andi	r2,r2,255
81142858:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
8114285c:	e0bfff0b 	ldhu	r2,-4(fp)
81142860:	10803960 	cmpeqi	r2,r2,229
81142864:	1000021e 	bne	r2,zero,81142870 <find_first_empty_record_in_root_directory+0xc4>
81142868:	e0bfff0b 	ldhu	r2,-4(fp)
8114286c:	1000081e 	bne	r2,zero,81142890 <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
81142870:	e0bffb17 	ldw	r2,-20(fp)
81142874:	1006913a 	slli	r3,r2,4
81142878:	e0bffc17 	ldw	r2,-16(fp)
8114287c:	1885883a 	add	r2,r3,r2
81142880:	1004943a 	slli	r2,r2,16
81142884:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81142888:	e0bffe17 	ldw	r2,-8(fp)
8114288c:	00000f06 	br	811428cc <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81142890:	e0bffc17 	ldw	r2,-16(fp)
81142894:	10800044 	addi	r2,r2,1
81142898:	e0bffc15 	stw	r2,-16(fp)
8114289c:	e0bffc17 	ldw	r2,-16(fp)
811428a0:	10800410 	cmplti	r2,r2,16
811428a4:	103fe31e 	bne	r2,zero,81142834 <__reset+0xfb122834>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811428a8:	e0bffb17 	ldw	r2,-20(fp)
811428ac:	10800044 	addi	r2,r2,1
811428b0:	e0bffb15 	stw	r2,-20(fp)
811428b4:	e0fffb17 	ldw	r3,-20(fp)
811428b8:	e0bffd17 	ldw	r2,-12(fp)
811428bc:	18bfd016 	blt	r3,r2,81142800 <__reset+0xfb122800>
811428c0:	00000106 	br	811428c8 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
811428c4:	0001883a 	nop
        }
    }
    return result;
811428c8:	e0bffe17 	ldw	r2,-8(fp)
}
811428cc:	e037883a 	mov	sp,fp
811428d0:	dfc00117 	ldw	ra,4(sp)
811428d4:	df000017 	ldw	fp,0(sp)
811428d8:	dec00204 	addi	sp,sp,8
811428dc:	f800283a 	ret

811428e0 <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
811428e0:	defffa04 	addi	sp,sp,-24
811428e4:	de00012e 	bgeu	sp,et,811428ec <convert_filename_to_name_extension+0xc>
811428e8:	003b68fa 	trap	3
811428ec:	df000515 	stw	fp,20(sp)
811428f0:	df000504 	addi	fp,sp,20
811428f4:	e13ffd15 	stw	r4,-12(fp)
811428f8:	e17ffe15 	stw	r5,-8(fp)
811428fc:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
81142900:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
81142904:	e03ffb15 	stw	zero,-20(fp)
81142908:	00002506 	br	811429a0 <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
8114290c:	e0bffc17 	ldw	r2,-16(fp)
81142910:	e0fffd17 	ldw	r3,-12(fp)
81142914:	1885883a 	add	r2,r3,r2
81142918:	10800003 	ldbu	r2,0(r2)
8114291c:	10803fcc 	andi	r2,r2,255
81142920:	1080201c 	xori	r2,r2,128
81142924:	10bfe004 	addi	r2,r2,-128
81142928:	10800ba0 	cmpeqi	r2,r2,46
8114292c:	1000141e 	bne	r2,zero,81142980 <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
81142930:	e0bffb17 	ldw	r2,-20(fp)
81142934:	e0fffe17 	ldw	r3,-8(fp)
81142938:	1885883a 	add	r2,r3,r2
8114293c:	e0fffc17 	ldw	r3,-16(fp)
81142940:	e13ffd17 	ldw	r4,-12(fp)
81142944:	20c7883a 	add	r3,r4,r3
81142948:	18c00003 	ldbu	r3,0(r3)
8114294c:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
81142950:	e0bffc17 	ldw	r2,-16(fp)
81142954:	e0fffd17 	ldw	r3,-12(fp)
81142958:	1885883a 	add	r2,r3,r2
8114295c:	10800003 	ldbu	r2,0(r2)
81142960:	10803fcc 	andi	r2,r2,255
81142964:	1080201c 	xori	r2,r2,128
81142968:	10bfe004 	addi	r2,r2,-128
8114296c:	10000926 	beq	r2,zero,81142994 <convert_filename_to_name_extension+0xb4>
81142970:	e0bffc17 	ldw	r2,-16(fp)
81142974:	10800044 	addi	r2,r2,1
81142978:	e0bffc15 	stw	r2,-16(fp)
8114297c:	00000506 	br	81142994 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
81142980:	e0bffb17 	ldw	r2,-20(fp)
81142984:	e0fffe17 	ldw	r3,-8(fp)
81142988:	1885883a 	add	r2,r3,r2
8114298c:	00c00804 	movi	r3,32
81142990:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81142994:	e0bffb17 	ldw	r2,-20(fp)
81142998:	10800044 	addi	r2,r2,1
8114299c:	e0bffb15 	stw	r2,-20(fp)
811429a0:	e0bffb17 	ldw	r2,-20(fp)
811429a4:	10800210 	cmplti	r2,r2,8
811429a8:	103fd81e 	bne	r2,zero,8114290c <__reset+0xfb12290c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
811429ac:	e0bffc17 	ldw	r2,-16(fp)
811429b0:	e0fffd17 	ldw	r3,-12(fp)
811429b4:	1885883a 	add	r2,r3,r2
811429b8:	10800003 	ldbu	r2,0(r2)
811429bc:	10803fcc 	andi	r2,r2,255
811429c0:	1080201c 	xori	r2,r2,128
811429c4:	10bfe004 	addi	r2,r2,-128
811429c8:	10800b98 	cmpnei	r2,r2,46
811429cc:	1000031e 	bne	r2,zero,811429dc <convert_filename_to_name_extension+0xfc>
811429d0:	e0bffc17 	ldw	r2,-16(fp)
811429d4:	10800044 	addi	r2,r2,1
811429d8:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
811429dc:	e03ffb15 	stw	zero,-20(fp)
811429e0:	00001c06 	br	81142a54 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
811429e4:	e0bffc17 	ldw	r2,-16(fp)
811429e8:	e0fffd17 	ldw	r3,-12(fp)
811429ec:	1885883a 	add	r2,r3,r2
811429f0:	10800003 	ldbu	r2,0(r2)
811429f4:	10803fcc 	andi	r2,r2,255
811429f8:	1080201c 	xori	r2,r2,128
811429fc:	10bfe004 	addi	r2,r2,-128
81142a00:	10000c26 	beq	r2,zero,81142a34 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
81142a04:	e0bffb17 	ldw	r2,-20(fp)
81142a08:	e0ffff17 	ldw	r3,-4(fp)
81142a0c:	1885883a 	add	r2,r3,r2
81142a10:	e0fffc17 	ldw	r3,-16(fp)
81142a14:	e13ffd17 	ldw	r4,-12(fp)
81142a18:	20c7883a 	add	r3,r4,r3
81142a1c:	18c00003 	ldbu	r3,0(r3)
81142a20:	10c00005 	stb	r3,0(r2)
            local++;
81142a24:	e0bffc17 	ldw	r2,-16(fp)
81142a28:	10800044 	addi	r2,r2,1
81142a2c:	e0bffc15 	stw	r2,-16(fp)
81142a30:	00000506 	br	81142a48 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81142a34:	e0bffb17 	ldw	r2,-20(fp)
81142a38:	e0ffff17 	ldw	r3,-4(fp)
81142a3c:	1885883a 	add	r2,r3,r2
81142a40:	00c00804 	movi	r3,32
81142a44:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81142a48:	e0bffb17 	ldw	r2,-20(fp)
81142a4c:	10800044 	addi	r2,r2,1
81142a50:	e0bffb15 	stw	r2,-20(fp)
81142a54:	e0bffb17 	ldw	r2,-20(fp)
81142a58:	108000d0 	cmplti	r2,r2,3
81142a5c:	103fe11e 	bne	r2,zero,811429e4 <__reset+0xfb1229e4>
        {
            extension[counter] = ' ';
        }
    }

}
81142a60:	0001883a 	nop
81142a64:	e037883a 	mov	sp,fp
81142a68:	df000017 	ldw	fp,0(sp)
81142a6c:	dec00104 	addi	sp,sp,4
81142a70:	f800283a 	ret

81142a74 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81142a74:	defff504 	addi	sp,sp,-44
81142a78:	de00012e 	bgeu	sp,et,81142a80 <create_file+0xc>
81142a7c:	003b68fa 	trap	3
81142a80:	dfc00a15 	stw	ra,40(sp)
81142a84:	df000915 	stw	fp,36(sp)
81142a88:	df000904 	addi	fp,sp,36
81142a8c:	e13ffd15 	stw	r4,-12(fp)
81142a90:	e17ffe15 	stw	r5,-8(fp)
81142a94:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81142a98:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81142a9c:	e0bffc04 	addi	r2,fp,-16
81142aa0:	1009883a 	mov	r4,r2
81142aa4:	11423a40 	call	811423a4 <find_first_empty_cluster>
81142aa8:	1000a026 	beq	r2,zero,81142d2c <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81142aac:	e0bfff17 	ldw	r2,-4(fp)
81142ab0:	10800a17 	ldw	r2,40(r2)
81142ab4:	1000031e 	bne	r2,zero,81142ac4 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81142ab8:	11427ac0 	call	811427ac <find_first_empty_record_in_root_directory>
81142abc:	e0bff815 	stw	r2,-32(fp)
81142ac0:	00000606 	br	81142adc <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81142ac4:	e0bfff17 	ldw	r2,-4(fp)
81142ac8:	1080058b 	ldhu	r2,22(r2)
81142acc:	10bfffcc 	andi	r2,r2,65535
81142ad0:	1009883a 	mov	r4,r2
81142ad4:	11425580 	call	81142558 <find_first_empty_record_in_a_subdirectory>
81142ad8:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81142adc:	e0bff817 	ldw	r2,-32(fp)
81142ae0:	10009216 	blt	r2,zero,81142d2c <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81142ae4:	e13ffd17 	ldw	r4,-12(fp)
81142ae8:	11416840 	call	81141684 <get_dir_divider_location>
81142aec:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81142af0:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81142af4:	00000b06 	br	81142b24 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81142af8:	e0fffa17 	ldw	r3,-24(fp)
81142afc:	e0bff917 	ldw	r2,-28(fp)
81142b00:	1885883a 	add	r2,r3,r2
81142b04:	10800044 	addi	r2,r2,1
81142b08:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81142b0c:	e0bffa17 	ldw	r2,-24(fp)
81142b10:	e0fffd17 	ldw	r3,-12(fp)
81142b14:	1885883a 	add	r2,r3,r2
81142b18:	1009883a 	mov	r4,r2
81142b1c:	11416840 	call	81141684 <get_dir_divider_location>
81142b20:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81142b24:	e0bff917 	ldw	r2,-28(fp)
81142b28:	00bff316 	blt	zero,r2,81142af8 <__reset+0xfb122af8>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81142b2c:	e0bffa17 	ldw	r2,-24(fp)
81142b30:	e0fffd17 	ldw	r3,-12(fp)
81142b34:	1887883a 	add	r3,r3,r2
81142b38:	e13ffe17 	ldw	r4,-8(fp)
81142b3c:	e0bffe17 	ldw	r2,-8(fp)
81142b40:	10800204 	addi	r2,r2,8
81142b44:	100d883a 	mov	r6,r2
81142b48:	200b883a 	mov	r5,r4
81142b4c:	1809883a 	mov	r4,r3
81142b50:	11428e00 	call	811428e0 <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81142b54:	e0bffe17 	ldw	r2,-8(fp)
81142b58:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81142b5c:	e0bffe17 	ldw	r2,-8(fp)
81142b60:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81142b64:	e0bffe17 	ldw	r2,-8(fp)
81142b68:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81142b6c:	e0bffe17 	ldw	r2,-8(fp)
81142b70:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81142b74:	e0bffe17 	ldw	r2,-8(fp)
81142b78:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81142b7c:	e0bffe17 	ldw	r2,-8(fp)
81142b80:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81142b84:	e0bffc17 	ldw	r2,-16(fp)
81142b88:	1007883a 	mov	r3,r2
81142b8c:	e0bffe17 	ldw	r2,-8(fp)
81142b90:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81142b94:	e0bffe17 	ldw	r2,-8(fp)
81142b98:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81142b9c:	e0fffc17 	ldw	r3,-16(fp)
81142ba0:	e0bffe17 	ldw	r2,-8(fp)
81142ba4:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81142ba8:	e0bffe17 	ldw	r2,-8(fp)
81142bac:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81142bb0:	e0bffe17 	ldw	r2,-8(fp)
81142bb4:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81142bb8:	e0bff817 	ldw	r2,-32(fp)
81142bbc:	10ffffcc 	andi	r3,r2,65535
81142bc0:	e0bffe17 	ldw	r2,-8(fp)
81142bc4:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81142bc8:	e0bff817 	ldw	r2,-32(fp)
81142bcc:	1004d43a 	srli	r2,r2,16
81142bd0:	1000010e 	bge	r2,zero,81142bd8 <create_file+0x164>
81142bd4:	108003c4 	addi	r2,r2,15
81142bd8:	1005d13a 	srai	r2,r2,4
81142bdc:	1007883a 	mov	r3,r2
81142be0:	e0bffe17 	ldw	r2,-8(fp)
81142be4:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81142be8:	e0bff817 	ldw	r2,-32(fp)
81142bec:	1004d43a 	srli	r2,r2,16
81142bf0:	1007883a 	mov	r3,r2
81142bf4:	00a00034 	movhi	r2,32768
81142bf8:	108003c4 	addi	r2,r2,15
81142bfc:	1884703a 	and	r2,r3,r2
81142c00:	1000040e 	bge	r2,zero,81142c14 <create_file+0x1a0>
81142c04:	10bfffc4 	addi	r2,r2,-1
81142c08:	00fffc04 	movi	r3,-16
81142c0c:	10c4b03a 	or	r2,r2,r3
81142c10:	10800044 	addi	r2,r2,1
81142c14:	1004917a 	slli	r2,r2,5
81142c18:	1007883a 	mov	r3,r2
81142c1c:	e0bffe17 	ldw	r2,-8(fp)
81142c20:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81142c24:	e0bfff17 	ldw	r2,-4(fp)
81142c28:	1080058b 	ldhu	r2,22(r2)
81142c2c:	10ffffcc 	andi	r3,r2,65535
81142c30:	e0bffe17 	ldw	r2,-8(fp)
81142c34:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81142c38:	e0bffe17 	ldw	r2,-8(fp)
81142c3c:	00c00044 	movi	r3,1
81142c40:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81142c44:	e0bffe17 	ldw	r2,-8(fp)
81142c48:	00c00044 	movi	r3,1
81142c4c:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81142c50:	e0bffe17 	ldw	r2,-8(fp)
81142c54:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81142c58:	1000071e 	bne	r2,zero,81142c78 <create_file+0x204>
81142c5c:	00a045f4 	movhi	r2,33047
81142c60:	10aa0004 	addi	r2,r2,-22528
81142c64:	10c01317 	ldw	r3,76(r2)
81142c68:	e0bffe17 	ldw	r2,-8(fp)
81142c6c:	10800b17 	ldw	r2,44(r2)
81142c70:	1885883a 	add	r2,r3,r2
81142c74:	00000f06 	br	81142cb4 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81142c78:	00a045f4 	movhi	r2,33047
81142c7c:	10aa0004 	addi	r2,r2,-22528
81142c80:	10c01417 	ldw	r3,80(r2)
81142c84:	e0bffe17 	ldw	r2,-8(fp)
81142c88:	10800a17 	ldw	r2,40(r2)
81142c8c:	113fff84 	addi	r4,r2,-2
81142c90:	00a045f4 	movhi	r2,33047
81142c94:	10aa0004 	addi	r2,r2,-22528
81142c98:	10800383 	ldbu	r2,14(r2)
81142c9c:	10803fcc 	andi	r2,r2,255
81142ca0:	2085383a 	mul	r2,r4,r2
81142ca4:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81142ca8:	e0bffe17 	ldw	r2,-8(fp)
81142cac:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81142cb0:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81142cb4:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81142cb8:	e0bffb17 	ldw	r2,-20(fp)
81142cbc:	d0e0b017 	ldw	r3,-32064(gp)
81142cc0:	180b883a 	mov	r5,r3
81142cc4:	1009883a 	mov	r4,r2
81142cc8:	11402800 	call	81140280 <Read_Sector_Data>
81142ccc:	10001726 	beq	r2,zero,81142d2c <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81142cd0:	e0bffe17 	ldw	r2,-8(fp)
81142cd4:	10800c0b 	ldhu	r2,48(r2)
81142cd8:	10bfffcc 	andi	r2,r2,65535
81142cdc:	10a0001c 	xori	r2,r2,32768
81142ce0:	10a00004 	addi	r2,r2,-32768
81142ce4:	e17ffe17 	ldw	r5,-8(fp)
81142ce8:	1009883a 	mov	r4,r2
81142cec:	11409340 	call	81140934 <Write_File_Record_At_Offset>
81142cf0:	10000e26 	beq	r2,zero,81142d2c <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81142cf4:	114022c0 	call	8114022c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81142cf8:	e0bffc17 	ldw	r2,-16(fp)
81142cfc:	01800044 	movi	r6,1
81142d00:	017fffc4 	movi	r5,-1
81142d04:	1009883a 	mov	r4,r2
81142d08:	114041c0 	call	8114041c <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81142d0c:	e0bffc17 	ldw	r2,-16(fp)
81142d10:	000d883a 	mov	r6,zero
81142d14:	017fffc4 	movi	r5,-1
81142d18:	1009883a 	mov	r4,r2
81142d1c:	114041c0 	call	8114041c <mark_cluster>
81142d20:	10000226 	beq	r2,zero,81142d2c <create_file+0x2b8>
                    {
                        result = true;
81142d24:	00800044 	movi	r2,1
81142d28:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81142d2c:	e0bff717 	ldw	r2,-36(fp)
}
81142d30:	e037883a 	mov	sp,fp
81142d34:	dfc00117 	ldw	ra,4(sp)
81142d38:	df000017 	ldw	fp,0(sp)
81142d3c:	dec00204 	addi	sp,sp,8
81142d40:	f800283a 	ret

81142d44 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81142d44:	defffb04 	addi	sp,sp,-20
81142d48:	de00012e 	bgeu	sp,et,81142d50 <copy_file_record_name_to_string+0xc>
81142d4c:	003b68fa 	trap	3
81142d50:	df000415 	stw	fp,16(sp)
81142d54:	df000404 	addi	fp,sp,16
81142d58:	e13ffe15 	stw	r4,-8(fp)
81142d5c:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81142d60:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81142d64:	e03ffc15 	stw	zero,-16(fp)
81142d68:	00001506 	br	81142dc0 <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81142d6c:	e0fffe17 	ldw	r3,-8(fp)
81142d70:	e0bffc17 	ldw	r2,-16(fp)
81142d74:	1885883a 	add	r2,r3,r2
81142d78:	10800003 	ldbu	r2,0(r2)
81142d7c:	10803fcc 	andi	r2,r2,255
81142d80:	10800820 	cmpeqi	r2,r2,32
81142d84:	10000b1e 	bne	r2,zero,81142db4 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81142d88:	e0bffd17 	ldw	r2,-12(fp)
81142d8c:	e0ffff17 	ldw	r3,-4(fp)
81142d90:	1885883a 	add	r2,r3,r2
81142d94:	e13ffe17 	ldw	r4,-8(fp)
81142d98:	e0fffc17 	ldw	r3,-16(fp)
81142d9c:	20c7883a 	add	r3,r4,r3
81142da0:	18c00003 	ldbu	r3,0(r3)
81142da4:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81142da8:	e0bffd17 	ldw	r2,-12(fp)
81142dac:	10800044 	addi	r2,r2,1
81142db0:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81142db4:	e0bffc17 	ldw	r2,-16(fp)
81142db8:	10800044 	addi	r2,r2,1
81142dbc:	e0bffc15 	stw	r2,-16(fp)
81142dc0:	e0bffc17 	ldw	r2,-16(fp)
81142dc4:	10800210 	cmplti	r2,r2,8
81142dc8:	103fe81e 	bne	r2,zero,81142d6c <__reset+0xfb122d6c>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81142dcc:	e0bffe17 	ldw	r2,-8(fp)
81142dd0:	10800203 	ldbu	r2,8(r2)
81142dd4:	10803fcc 	andi	r2,r2,255
81142dd8:	10800820 	cmpeqi	r2,r2,32
81142ddc:	1000241e 	bne	r2,zero,81142e70 <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81142de0:	e0bffd17 	ldw	r2,-12(fp)
81142de4:	e0ffff17 	ldw	r3,-4(fp)
81142de8:	1885883a 	add	r2,r3,r2
81142dec:	00c00b84 	movi	r3,46
81142df0:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81142df4:	e0bffd17 	ldw	r2,-12(fp)
81142df8:	10800044 	addi	r2,r2,1
81142dfc:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81142e00:	e03ffc15 	stw	zero,-16(fp)
81142e04:	00001706 	br	81142e64 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81142e08:	e0fffe17 	ldw	r3,-8(fp)
81142e0c:	e0bffc17 	ldw	r2,-16(fp)
81142e10:	1885883a 	add	r2,r3,r2
81142e14:	10800204 	addi	r2,r2,8
81142e18:	10800003 	ldbu	r2,0(r2)
81142e1c:	10803fcc 	andi	r2,r2,255
81142e20:	10800820 	cmpeqi	r2,r2,32
81142e24:	10000c1e 	bne	r2,zero,81142e58 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81142e28:	e0bffd17 	ldw	r2,-12(fp)
81142e2c:	e0ffff17 	ldw	r3,-4(fp)
81142e30:	1885883a 	add	r2,r3,r2
81142e34:	e13ffe17 	ldw	r4,-8(fp)
81142e38:	e0fffc17 	ldw	r3,-16(fp)
81142e3c:	20c7883a 	add	r3,r4,r3
81142e40:	18c00204 	addi	r3,r3,8
81142e44:	18c00003 	ldbu	r3,0(r3)
81142e48:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81142e4c:	e0bffd17 	ldw	r2,-12(fp)
81142e50:	10800044 	addi	r2,r2,1
81142e54:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81142e58:	e0bffc17 	ldw	r2,-16(fp)
81142e5c:	10800044 	addi	r2,r2,1
81142e60:	e0bffc15 	stw	r2,-16(fp)
81142e64:	e0bffc17 	ldw	r2,-16(fp)
81142e68:	108000d0 	cmplti	r2,r2,3
81142e6c:	103fe61e 	bne	r2,zero,81142e08 <__reset+0xfb122e08>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81142e70:	e0bffd17 	ldw	r2,-12(fp)
81142e74:	e0ffff17 	ldw	r3,-4(fp)
81142e78:	1885883a 	add	r2,r3,r2
81142e7c:	10000005 	stb	zero,0(r2)
}
81142e80:	0001883a 	nop
81142e84:	e037883a 	mov	sp,fp
81142e88:	df000017 	ldw	fp,0(sp)
81142e8c:	dec00104 	addi	sp,sp,4
81142e90:	f800283a 	ret

81142e94 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81142e94:	defffc04 	addi	sp,sp,-16
81142e98:	de00012e 	bgeu	sp,et,81142ea0 <alt_up_sd_card_open_dev+0xc>
81142e9c:	003b68fa 	trap	3
81142ea0:	dfc00315 	stw	ra,12(sp)
81142ea4:	df000215 	stw	fp,8(sp)
81142ea8:	df000204 	addi	fp,sp,8
81142eac:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81142eb0:	d1600d04 	addi	r5,gp,-32716
81142eb4:	e13fff17 	ldw	r4,-4(fp)
81142eb8:	11483500 	call	81148350 <alt_find_dev>
81142ebc:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81142ec0:	e0bffe17 	ldw	r2,-8(fp)
81142ec4:	10001e26 	beq	r2,zero,81142f40 <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81142ec8:	e0bffe17 	ldw	r2,-8(fp)
81142ecc:	10800a17 	ldw	r2,40(r2)
81142ed0:	10808d04 	addi	r2,r2,564
81142ed4:	d0a0aa15 	stw	r2,-32088(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81142ed8:	e0bffe17 	ldw	r2,-8(fp)
81142edc:	10800a17 	ldw	r2,40(r2)
81142ee0:	10808904 	addi	r2,r2,548
81142ee4:	d0a0ab15 	stw	r2,-32084(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81142ee8:	e0bffe17 	ldw	r2,-8(fp)
81142eec:	10800a17 	ldw	r2,40(r2)
81142ef0:	10808404 	addi	r2,r2,528
81142ef4:	d0a0ac15 	stw	r2,-32080(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81142ef8:	e0bffe17 	ldw	r2,-8(fp)
81142efc:	10800a17 	ldw	r2,40(r2)
81142f00:	10808c04 	addi	r2,r2,560
81142f04:	d0a0ad15 	stw	r2,-32076(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81142f08:	e0bffe17 	ldw	r2,-8(fp)
81142f0c:	10800a17 	ldw	r2,40(r2)
81142f10:	10808b04 	addi	r2,r2,556
81142f14:	d0a0ae15 	stw	r2,-32072(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81142f18:	e0bffe17 	ldw	r2,-8(fp)
81142f1c:	10800a17 	ldw	r2,40(r2)
81142f20:	d0a0af15 	stw	r2,-32068(gp)
		device_pointer = dev;
81142f24:	e0bffe17 	ldw	r2,-8(fp)
81142f28:	d0a0b215 	stw	r2,-32056(gp)
		initialized = false;
81142f2c:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
81142f30:	d020a915 	stw	zero,-32092(gp)
		search_data.valid = false;
81142f34:	00a045f4 	movhi	r2,33047
81142f38:	10a9fb04 	addi	r2,r2,-22548
81142f3c:	10000415 	stw	zero,16(r2)
	}
	return dev;
81142f40:	e0bffe17 	ldw	r2,-8(fp)
}
81142f44:	e037883a 	mov	sp,fp
81142f48:	dfc00117 	ldw	ra,4(sp)
81142f4c:	df000017 	ldw	fp,0(sp)
81142f50:	dec00204 	addi	sp,sp,8
81142f54:	f800283a 	ret

81142f58 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81142f58:	defffd04 	addi	sp,sp,-12
81142f5c:	de00012e 	bgeu	sp,et,81142f64 <alt_up_sd_card_is_Present+0xc>
81142f60:	003b68fa 	trap	3
81142f64:	df000215 	stw	fp,8(sp)
81142f68:	df000204 	addi	fp,sp,8
    bool result = false;
81142f6c:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81142f70:	d0a0b217 	ldw	r2,-32056(gp)
81142f74:	10000826 	beq	r2,zero,81142f98 <alt_up_sd_card_is_Present+0x40>
81142f78:	d0a0aa17 	ldw	r2,-32088(gp)
81142f7c:	1080002b 	ldhuio	r2,0(r2)
81142f80:	10bfffcc 	andi	r2,r2,65535
81142f84:	1080008c 	andi	r2,r2,2
81142f88:	10000326 	beq	r2,zero,81142f98 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81142f8c:	00800044 	movi	r2,1
81142f90:	e0bffe15 	stw	r2,-8(fp)
81142f94:	00001e06 	br	81143010 <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81142f98:	d0a0a817 	ldw	r2,-32096(gp)
81142f9c:	10800058 	cmpnei	r2,r2,1
81142fa0:	10001b1e 	bne	r2,zero,81143010 <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81142fa4:	d020a815 	stw	zero,-32096(gp)
		search_data.valid = false;
81142fa8:	00a045f4 	movhi	r2,33047
81142fac:	10a9fb04 	addi	r2,r2,-22548
81142fb0:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81142fb4:	d020a915 	stw	zero,-32092(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81142fb8:	e03fff15 	stw	zero,-4(fp)
81142fbc:	00001106 	br	81143004 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81142fc0:	00a045f4 	movhi	r2,33047
81142fc4:	10aa1504 	addi	r2,r2,-22444
81142fc8:	e0ffff17 	ldw	r3,-4(fp)
81142fcc:	180691ba 	slli	r3,r3,6
81142fd0:	10c5883a 	add	r2,r2,r3
81142fd4:	10800f04 	addi	r2,r2,60
81142fd8:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81142fdc:	00a045f4 	movhi	r2,33047
81142fe0:	10aa1504 	addi	r2,r2,-22444
81142fe4:	e0ffff17 	ldw	r3,-4(fp)
81142fe8:	180691ba 	slli	r3,r3,6
81142fec:	10c5883a 	add	r2,r2,r3
81142ff0:	10800e04 	addi	r2,r2,56
81142ff4:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81142ff8:	e0bfff17 	ldw	r2,-4(fp)
81142ffc:	10800044 	addi	r2,r2,1
81143000:	e0bfff15 	stw	r2,-4(fp)
81143004:	e0bfff17 	ldw	r2,-4(fp)
81143008:	10800510 	cmplti	r2,r2,20
8114300c:	103fec1e 	bne	r2,zero,81142fc0 <__reset+0xfb122fc0>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81143010:	e0bffe17 	ldw	r2,-8(fp)
}
81143014:	e037883a 	mov	sp,fp
81143018:	df000017 	ldw	fp,0(sp)
8114301c:	dec00104 	addi	sp,sp,4
81143020:	f800283a 	ret

81143024 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81143024:	defffd04 	addi	sp,sp,-12
81143028:	de00012e 	bgeu	sp,et,81143030 <alt_up_sd_card_is_FAT16+0xc>
8114302c:	003b68fa 	trap	3
81143030:	dfc00215 	stw	ra,8(sp)
81143034:	df000115 	stw	fp,4(sp)
81143038:	df000104 	addi	fp,sp,4
	bool result = false;
8114303c:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
81143040:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
81143044:	10000c26 	beq	r2,zero,81143078 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81143048:	d0a0a817 	ldw	r2,-32096(gp)
8114304c:	1000071e 	bne	r2,zero,8114306c <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
81143050:	11412500 	call	81141250 <Look_for_FAT16>
81143054:	d0a0a915 	stw	r2,-32092(gp)
			initialized = is_sd_card_formated_as_FAT16;
81143058:	d0a0a917 	ldw	r2,-32092(gp)
8114305c:	d0a0a815 	stw	r2,-32096(gp)
			search_data.valid = false;
81143060:	00a045f4 	movhi	r2,33047
81143064:	10a9fb04 	addi	r2,r2,-22548
81143068:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
8114306c:	d0a0a917 	ldw	r2,-32092(gp)
81143070:	e0bfff15 	stw	r2,-4(fp)
81143074:	00000206 	br	81143080 <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81143078:	d020a815 	stw	zero,-32096(gp)
		is_sd_card_formated_as_FAT16 = false;
8114307c:	d020a915 	stw	zero,-32092(gp)
	}

	return result;
81143080:	e0bfff17 	ldw	r2,-4(fp)
}
81143084:	e037883a 	mov	sp,fp
81143088:	dfc00117 	ldw	ra,4(sp)
8114308c:	df000017 	ldw	fp,0(sp)
81143090:	dec00204 	addi	sp,sp,8
81143094:	f800283a 	ret

81143098 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81143098:	deffea04 	addi	sp,sp,-88
8114309c:	de00012e 	bgeu	sp,et,811430a4 <alt_up_sd_card_find_first+0xc>
811430a0:	003b68fa 	trap	3
811430a4:	dfc01515 	stw	ra,84(sp)
811430a8:	df001415 	stw	fp,80(sp)
811430ac:	df001404 	addi	fp,sp,80
811430b0:	e13ffe15 	stw	r4,-8(fp)
811430b4:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
811430b8:	00800084 	movi	r2,2
811430bc:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811430c0:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
811430c4:	10002426 	beq	r2,zero,81143158 <alt_up_sd_card_find_first+0xc0>
811430c8:	d0a0a917 	ldw	r2,-32092(gp)
811430cc:	10002226 	beq	r2,zero,81143158 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
811430d0:	e0ffee04 	addi	r3,fp,-72
811430d4:	e0bfed04 	addi	r2,fp,-76
811430d8:	180d883a 	mov	r6,r3
811430dc:	100b883a 	mov	r5,r2
811430e0:	e13ffe17 	ldw	r4,-8(fp)
811430e4:	11419e80 	call	811419e8 <get_home_directory_cluster_for_file>
811430e8:	10001926 	beq	r2,zero,81143150 <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811430ec:	e0bfed17 	ldw	r2,-76(fp)
811430f0:	1007883a 	mov	r3,r2
811430f4:	00a045f4 	movhi	r2,33047
811430f8:	10a9fb04 	addi	r2,r2,-22548
811430fc:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
81143100:	e0bfed17 	ldw	r2,-76(fp)
81143104:	1007883a 	mov	r3,r2
81143108:	00a045f4 	movhi	r2,33047
8114310c:	10a9fb04 	addi	r2,r2,-22548
81143110:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
81143114:	00a045f4 	movhi	r2,33047
81143118:	10a9fb04 	addi	r2,r2,-22548
8114311c:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
81143120:	00a045f4 	movhi	r2,33047
81143124:	10a9fb04 	addi	r2,r2,-22548
81143128:	00ffffc4 	movi	r3,-1
8114312c:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
81143130:	00a045f4 	movhi	r2,33047
81143134:	10a9fb04 	addi	r2,r2,-22548
81143138:	00c00044 	movi	r3,1
8114313c:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
81143140:	e13fff17 	ldw	r4,-4(fp)
81143144:	11431700 	call	81143170 <alt_up_sd_card_find_next>
81143148:	e0bfec0d 	sth	r2,-80(fp)
8114314c:	00000206 	br	81143158 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
81143150:	00800044 	movi	r2,1
81143154:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81143158:	e0bfec0b 	ldhu	r2,-80(fp)
}
8114315c:	e037883a 	mov	sp,fp
81143160:	dfc00117 	ldw	ra,4(sp)
81143164:	df000017 	ldw	fp,0(sp)
81143168:	dec00204 	addi	sp,sp,8
8114316c:	f800283a 	ret

81143170 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
81143170:	deffe404 	addi	sp,sp,-112
81143174:	de00012e 	bgeu	sp,et,8114317c <alt_up_sd_card_find_next+0xc>
81143178:	003b68fa 	trap	3
8114317c:	dfc01b15 	stw	ra,108(sp)
81143180:	df001a15 	stw	fp,104(sp)
81143184:	df001a04 	addi	fp,sp,104
81143188:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
8114318c:	00800084 	movi	r2,2
81143190:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81143194:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
81143198:	1000df26 	beq	r2,zero,81143518 <alt_up_sd_card_find_next+0x3a8>
8114319c:	d0a0a917 	ldw	r2,-32092(gp)
811431a0:	1000dd26 	beq	r2,zero,81143518 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
811431a4:	00a045f4 	movhi	r2,33047
811431a8:	10a9fb04 	addi	r2,r2,-22548
811431ac:	10800417 	ldw	r2,16(r2)
811431b0:	1000d726 	beq	r2,zero,81143510 <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
811431b4:	00a045f4 	movhi	r2,33047
811431b8:	10a9fb04 	addi	r2,r2,-22548
811431bc:	10800117 	ldw	r2,4(r2)
811431c0:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
811431c4:	e0bfe717 	ldw	r2,-100(fp)
811431c8:	1000561e 	bne	r2,zero,81143324 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811431cc:	00a045f4 	movhi	r2,33047
811431d0:	10aa0004 	addi	r2,r2,-22528
811431d4:	1080050b 	ldhu	r2,20(r2)
811431d8:	10bfffcc 	andi	r2,r2,65535
811431dc:	1006917a 	slli	r3,r2,5
811431e0:	00a045f4 	movhi	r2,33047
811431e4:	10aa0004 	addi	r2,r2,-22528
811431e8:	1080030b 	ldhu	r2,12(r2)
811431ec:	10bfffcc 	andi	r2,r2,65535
811431f0:	1885283a 	div	r2,r3,r2
811431f4:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811431f8:	00a045f4 	movhi	r2,33047
811431fc:	10a9fb04 	addi	r2,r2,-22548
81143200:	10800217 	ldw	r2,8(r2)
81143204:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
81143208:	00a045f4 	movhi	r2,33047
8114320c:	10a9fb04 	addi	r2,r2,-22548
81143210:	1080030b 	ldhu	r2,12(r2)
81143214:	10bfffcc 	andi	r2,r2,65535
81143218:	10a0001c 	xori	r2,r2,32768
8114321c:	10a00004 	addi	r2,r2,-32768
81143220:	10800044 	addi	r2,r2,1
81143224:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81143228:	00003606 	br	81143304 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
8114322c:	00a045f4 	movhi	r2,33047
81143230:	10aa0004 	addi	r2,r2,-22528
81143234:	10c01317 	ldw	r3,76(r2)
81143238:	e0bfe817 	ldw	r2,-96(fp)
8114323c:	1885883a 	add	r2,r3,r2
81143240:	1007883a 	mov	r3,r2
81143244:	d0a0b017 	ldw	r2,-32064(gp)
81143248:	100b883a 	mov	r5,r2
8114324c:	1809883a 	mov	r4,r3
81143250:	11402800 	call	81140280 <Read_Sector_Data>
81143254:	10002f26 	beq	r2,zero,81143314 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81143258:	00002306 	br	811432e8 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
8114325c:	e0bfe917 	ldw	r2,-92(fp)
81143260:	1004917a 	slli	r2,r2,5
81143264:	e13fe817 	ldw	r4,-96(fp)
81143268:	e0ffef04 	addi	r3,fp,-68
8114326c:	200f883a 	mov	r7,r4
81143270:	000d883a 	mov	r6,zero
81143274:	180b883a 	mov	r5,r3
81143278:	1009883a 	mov	r4,r2
8114327c:	11406b00 	call	811406b0 <Read_File_Record_At_Offset>
81143280:	10001626 	beq	r2,zero,811432dc <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81143284:	e0bfef03 	ldbu	r2,-68(fp)
81143288:	10803fcc 	andi	r2,r2,255
8114328c:	10001326 	beq	r2,zero,811432dc <alt_up_sd_card_find_next+0x16c>
81143290:	e0bfef03 	ldbu	r2,-68(fp)
81143294:	10803fcc 	andi	r2,r2,255
81143298:	10803960 	cmpeqi	r2,r2,229
8114329c:	10000f1e 	bne	r2,zero,811432dc <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
811432a0:	e0bfe917 	ldw	r2,-92(fp)
811432a4:	1007883a 	mov	r3,r2
811432a8:	00a045f4 	movhi	r2,33047
811432ac:	10a9fb04 	addi	r2,r2,-22548
811432b0:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
811432b4:	e0ffe817 	ldw	r3,-96(fp)
811432b8:	00a045f4 	movhi	r2,33047
811432bc:	10a9fb04 	addi	r2,r2,-22548
811432c0:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
811432c4:	e0bfef04 	addi	r2,fp,-68
811432c8:	e17fff17 	ldw	r5,-4(fp)
811432cc:	1009883a 	mov	r4,r2
811432d0:	1142d440 	call	81142d44 <copy_file_record_name_to_string>
									return 0;
811432d4:	0005883a 	mov	r2,zero
811432d8:	00009006 	br	8114351c <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811432dc:	e0bfe917 	ldw	r2,-92(fp)
811432e0:	10800044 	addi	r2,r2,1
811432e4:	e0bfe915 	stw	r2,-92(fp)
811432e8:	e0bfe917 	ldw	r2,-92(fp)
811432ec:	10800410 	cmplti	r2,r2,16
811432f0:	103fda1e 	bne	r2,zero,8114325c <__reset+0xfb12325c>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811432f4:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811432f8:	e0bfe817 	ldw	r2,-96(fp)
811432fc:	10800044 	addi	r2,r2,1
81143300:	e0bfe815 	stw	r2,-96(fp)
81143304:	e0ffe817 	ldw	r3,-96(fp)
81143308:	e0bfec17 	ldw	r2,-80(fp)
8114330c:	18bfc716 	blt	r3,r2,8114322c <__reset+0xfb12322c>
81143310:	00000106 	br	81143318 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
81143314:	0001883a 	nop
					}
				}
				result = -1;
81143318:	00bfffc4 	movi	r2,-1
8114331c:	e0bfe60d 	sth	r2,-104(fp)
81143320:	00007d06 	br	81143518 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81143324:	00a045f4 	movhi	r2,33047
81143328:	10a9fb04 	addi	r2,r2,-22548
8114332c:	1080030b 	ldhu	r2,12(r2)
81143330:	10bfffcc 	andi	r2,r2,65535
81143334:	10a0001c 	xori	r2,r2,32768
81143338:	10a00004 	addi	r2,r2,-32768
8114333c:	10800044 	addi	r2,r2,1
81143340:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81143344:	e0bfe717 	ldw	r2,-100(fp)
81143348:	10ffff84 	addi	r3,r2,-2
8114334c:	00a045f4 	movhi	r2,33047
81143350:	10aa0004 	addi	r2,r2,-22528
81143354:	10800383 	ldbu	r2,14(r2)
81143358:	10803fcc 	andi	r2,r2,255
8114335c:	1885383a 	mul	r2,r3,r2
81143360:	1007883a 	mov	r3,r2
81143364:	00a045f4 	movhi	r2,33047
81143368:	10aa0004 	addi	r2,r2,-22528
8114336c:	10801417 	ldw	r2,80(r2)
81143370:	1885883a 	add	r2,r3,r2
81143374:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81143378:	00a045f4 	movhi	r2,33047
8114337c:	10a9fb04 	addi	r2,r2,-22548
81143380:	10800217 	ldw	r2,8(r2)
81143384:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143388:	00003806 	br	8114346c <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8114338c:	e0ffeb17 	ldw	r3,-84(fp)
81143390:	e0bfed17 	ldw	r2,-76(fp)
81143394:	1885883a 	add	r2,r3,r2
81143398:	d0e0b017 	ldw	r3,-32064(gp)
8114339c:	180b883a 	mov	r5,r3
811433a0:	1009883a 	mov	r4,r2
811433a4:	11402800 	call	81140280 <Read_Sector_Data>
811433a8:	10003726 	beq	r2,zero,81143488 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
811433ac:	00002806 	br	81143450 <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
811433b0:	e0bfea17 	ldw	r2,-88(fp)
811433b4:	1004917a 	slli	r2,r2,5
811433b8:	e13fe717 	ldw	r4,-100(fp)
811433bc:	e17feb17 	ldw	r5,-84(fp)
811433c0:	e0ffef04 	addi	r3,fp,-68
811433c4:	280f883a 	mov	r7,r5
811433c8:	200d883a 	mov	r6,r4
811433cc:	180b883a 	mov	r5,r3
811433d0:	1009883a 	mov	r4,r2
811433d4:	11406b00 	call	811406b0 <Read_File_Record_At_Offset>
811433d8:	10001a26 	beq	r2,zero,81143444 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811433dc:	e0bfef03 	ldbu	r2,-68(fp)
811433e0:	10803fcc 	andi	r2,r2,255
811433e4:	10001726 	beq	r2,zero,81143444 <alt_up_sd_card_find_next+0x2d4>
811433e8:	e0bfef03 	ldbu	r2,-68(fp)
811433ec:	10803fcc 	andi	r2,r2,255
811433f0:	10803960 	cmpeqi	r2,r2,229
811433f4:	1000131e 	bne	r2,zero,81143444 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811433f8:	e0ffe717 	ldw	r3,-100(fp)
811433fc:	00a045f4 	movhi	r2,33047
81143400:	10a9fb04 	addi	r2,r2,-22548
81143404:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
81143408:	e0bfea17 	ldw	r2,-88(fp)
8114340c:	1007883a 	mov	r3,r2
81143410:	00a045f4 	movhi	r2,33047
81143414:	10a9fb04 	addi	r2,r2,-22548
81143418:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
8114341c:	e0ffeb17 	ldw	r3,-84(fp)
81143420:	00a045f4 	movhi	r2,33047
81143424:	10a9fb04 	addi	r2,r2,-22548
81143428:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
8114342c:	e0bfef04 	addi	r2,fp,-68
81143430:	e17fff17 	ldw	r5,-4(fp)
81143434:	1009883a 	mov	r4,r2
81143438:	1142d440 	call	81142d44 <copy_file_record_name_to_string>
										return 0;
8114343c:	0005883a 	mov	r2,zero
81143440:	00003606 	br	8114351c <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81143444:	e0bfea17 	ldw	r2,-88(fp)
81143448:	10800044 	addi	r2,r2,1
8114344c:	e0bfea15 	stw	r2,-88(fp)
81143450:	e0bfea17 	ldw	r2,-88(fp)
81143454:	10800410 	cmplti	r2,r2,16
81143458:	103fd51e 	bne	r2,zero,811433b0 <__reset+0xfb1233b0>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
8114345c:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81143460:	e0bfeb17 	ldw	r2,-84(fp)
81143464:	10800044 	addi	r2,r2,1
81143468:	e0bfeb15 	stw	r2,-84(fp)
8114346c:	00a045f4 	movhi	r2,33047
81143470:	10aa0004 	addi	r2,r2,-22528
81143474:	10800383 	ldbu	r2,14(r2)
81143478:	10803fcc 	andi	r2,r2,255
8114347c:	e0ffeb17 	ldw	r3,-84(fp)
81143480:	18bfc216 	blt	r3,r2,8114338c <__reset+0xfb12338c>
81143484:	00000106 	br	8114348c <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81143488:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
8114348c:	00a045f4 	movhi	r2,33047
81143490:	10aa0004 	addi	r2,r2,-22528
81143494:	10800383 	ldbu	r2,14(r2)
81143498:	10803fcc 	andi	r2,r2,255
8114349c:	e0ffeb17 	ldw	r3,-84(fp)
811434a0:	18801716 	blt	r3,r2,81143500 <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
811434a4:	e0bfe717 	ldw	r2,-100(fp)
811434a8:	e0ffee04 	addi	r3,fp,-72
811434ac:	180b883a 	mov	r5,r3
811434b0:	1009883a 	mov	r4,r2
811434b4:	11403600 	call	81140360 <get_cluster_flag>
811434b8:	10000f26 	beq	r2,zero,811434f8 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
811434bc:	e0bfee0b 	ldhu	r2,-72(fp)
811434c0:	10bfffcc 	andi	r2,r2,65535
811434c4:	10fffe0c 	andi	r3,r2,65528
811434c8:	00bffe14 	movui	r2,65528
811434cc:	1880051e 	bne	r3,r2,811434e4 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
811434d0:	00bfffc4 	movi	r2,-1
811434d4:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
811434d8:	00a045f4 	movhi	r2,33047
811434dc:	10a9fb04 	addi	r2,r2,-22548
811434e0:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
811434e4:	e0bfee0b 	ldhu	r2,-72(fp)
811434e8:	10bfffcc 	andi	r2,r2,65535
811434ec:	10bffe0c 	andi	r2,r2,65528
811434f0:	e0bfe715 	stw	r2,-100(fp)
811434f4:	00000206 	br	81143500 <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811434f8:	00bfffc4 	movi	r2,-1
811434fc:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
81143500:	e0bfe717 	ldw	r2,-100(fp)
81143504:	00fffdd4 	movui	r3,65527
81143508:	18bf8e0e 	bge	r3,r2,81143344 <__reset+0xfb123344>
8114350c:	00000206 	br	81143518 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
81143510:	008000c4 	movi	r2,3
81143514:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
81143518:	e0bfe60b 	ldhu	r2,-104(fp)
}
8114351c:	e037883a 	mov	sp,fp
81143520:	dfc00117 	ldw	ra,4(sp)
81143524:	df000017 	ldw	fp,0(sp)
81143528:	dec00204 	addi	sp,sp,8
8114352c:	f800283a 	ret

81143530 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
81143530:	deffe904 	addi	sp,sp,-92
81143534:	de00012e 	bgeu	sp,et,8114353c <alt_up_sd_card_fopen+0xc>
81143538:	003b68fa 	trap	3
8114353c:	dfc01615 	stw	ra,88(sp)
81143540:	df001515 	stw	fp,84(sp)
81143544:	df001504 	addi	fp,sp,84
81143548:	e13ffe15 	stw	r4,-8(fp)
8114354c:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
81143550:	00bfffc4 	movi	r2,-1
81143554:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81143558:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
8114355c:	1000cf26 	beq	r2,zero,8114389c <alt_up_sd_card_fopen+0x36c>
81143560:	d0a0a917 	ldw	r2,-32092(gp)
81143564:	1000cd26 	beq	r2,zero,8114389c <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81143568:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
8114356c:	e13ffe17 	ldw	r4,-8(fp)
81143570:	11413440 	call	81141344 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81143574:	e13ffe17 	ldw	r4,-8(fp)
81143578:	11414100 	call	81141410 <check_file_name_for_FAT16_compliance>
8114357c:	1000c726 	beq	r2,zero,8114389c <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
81143580:	e0ffee04 	addi	r3,fp,-72
81143584:	e0bfed04 	addi	r2,fp,-76
81143588:	180d883a 	mov	r6,r3
8114358c:	100b883a 	mov	r5,r2
81143590:	e13ffe17 	ldw	r4,-8(fp)
81143594:	11419e80 	call	811419e8 <get_home_directory_cluster_for_file>
81143598:	1000021e 	bne	r2,zero,811435a4 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
8114359c:	e0bfeb0b 	ldhu	r2,-84(fp)
811435a0:	0000bf06 	br	811438a0 <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811435a4:	e03fec15 	stw	zero,-80(fp)
811435a8:	00000e06 	br	811435e4 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
811435ac:	00a045f4 	movhi	r2,33047
811435b0:	10aa1504 	addi	r2,r2,-22444
811435b4:	e0ffec17 	ldw	r3,-80(fp)
811435b8:	180691ba 	slli	r3,r3,6
811435bc:	10c5883a 	add	r2,r2,r3
811435c0:	10800f04 	addi	r2,r2,60
811435c4:	10800017 	ldw	r2,0(r2)
811435c8:	1000031e 	bne	r2,zero,811435d8 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
811435cc:	e0bfec17 	ldw	r2,-80(fp)
811435d0:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
811435d4:	00000606 	br	811435f0 <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811435d8:	e0bfec17 	ldw	r2,-80(fp)
811435dc:	10800044 	addi	r2,r2,1
811435e0:	e0bfec15 	stw	r2,-80(fp)
811435e4:	e0bfec17 	ldw	r2,-80(fp)
811435e8:	10800510 	cmplti	r2,r2,20
811435ec:	103fef1e 	bne	r2,zero,811435ac <__reset+0xfb1235ac>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811435f0:	e0bfeb0f 	ldh	r2,-84(fp)
811435f4:	1000a916 	blt	r2,zero,8114389c <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811435f8:	e0bfed17 	ldw	r2,-76(fp)
811435fc:	1009883a 	mov	r4,r2
81143600:	e0bfeb0f 	ldh	r2,-84(fp)
81143604:	100691ba 	slli	r3,r2,6
81143608:	00a045f4 	movhi	r2,33047
8114360c:	10aa1504 	addi	r2,r2,-22444
81143610:	1885883a 	add	r2,r3,r2
81143614:	100d883a 	mov	r6,r2
81143618:	e17ffe17 	ldw	r5,-8(fp)
8114361c:	1141f280 	call	81141f28 <find_file_in_directory>
81143620:	10007b26 	beq	r2,zero,81143810 <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81143624:	e0bfff17 	ldw	r2,-4(fp)
81143628:	10000226 	beq	r2,zero,81143634 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
8114362c:	00bfffc4 	movi	r2,-1
81143630:	00009b06 	br	811438a0 <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81143634:	e13feb0f 	ldh	r4,-84(fp)
81143638:	e0ffeb0f 	ldh	r3,-84(fp)
8114363c:	00a045f4 	movhi	r2,33047
81143640:	10aa1504 	addi	r2,r2,-22444
81143644:	180691ba 	slli	r3,r3,6
81143648:	10c5883a 	add	r2,r2,r3
8114364c:	10800584 	addi	r2,r2,22
81143650:	1080000b 	ldhu	r2,0(r2)
81143654:	10ffffcc 	andi	r3,r2,65535
81143658:	00a045f4 	movhi	r2,33047
8114365c:	10aa1504 	addi	r2,r2,-22444
81143660:	200891ba 	slli	r4,r4,6
81143664:	1105883a 	add	r2,r2,r4
81143668:	10800704 	addi	r2,r2,28
8114366c:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
81143670:	e0ffeb0f 	ldh	r3,-84(fp)
81143674:	00a045f4 	movhi	r2,33047
81143678:	10aa1504 	addi	r2,r2,-22444
8114367c:	180691ba 	slli	r3,r3,6
81143680:	10c5883a 	add	r2,r2,r3
81143684:	10800804 	addi	r2,r2,32
81143688:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
8114368c:	e0ffeb0f 	ldh	r3,-84(fp)
81143690:	00a045f4 	movhi	r2,33047
81143694:	10aa1504 	addi	r2,r2,-22444
81143698:	180691ba 	slli	r3,r3,6
8114369c:	10c5883a 	add	r2,r2,r3
811436a0:	10800904 	addi	r2,r2,36
811436a4:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
811436a8:	e0ffeb0f 	ldh	r3,-84(fp)
811436ac:	00a045f4 	movhi	r2,33047
811436b0:	10aa1504 	addi	r2,r2,-22444
811436b4:	180691ba 	slli	r3,r3,6
811436b8:	10c5883a 	add	r2,r2,r3
811436bc:	10800f04 	addi	r2,r2,60
811436c0:	00c00044 	movi	r3,1
811436c4:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
811436c8:	e0ffeb0f 	ldh	r3,-84(fp)
811436cc:	00a045f4 	movhi	r2,33047
811436d0:	10aa1504 	addi	r2,r2,-22444
811436d4:	180691ba 	slli	r3,r3,6
811436d8:	10c5883a 	add	r2,r2,r3
811436dc:	10800e04 	addi	r2,r2,56
811436e0:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811436e4:	e03fec15 	stw	zero,-80(fp)
811436e8:	00004506 	br	81143800 <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811436ec:	e0ffeb0f 	ldh	r3,-84(fp)
811436f0:	e0bfec17 	ldw	r2,-80(fp)
811436f4:	18803f26 	beq	r3,r2,811437f4 <alt_up_sd_card_fopen+0x2c4>
811436f8:	00a045f4 	movhi	r2,33047
811436fc:	10aa1504 	addi	r2,r2,-22444
81143700:	e0ffec17 	ldw	r3,-80(fp)
81143704:	180691ba 	slli	r3,r3,6
81143708:	10c5883a 	add	r2,r2,r3
8114370c:	10800f04 	addi	r2,r2,60
81143710:	10800017 	ldw	r2,0(r2)
81143714:	10800058 	cmpnei	r2,r2,1
81143718:	1000361e 	bne	r2,zero,811437f4 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8114371c:	e0ffeb0f 	ldh	r3,-84(fp)
81143720:	00a045f4 	movhi	r2,33047
81143724:	10aa1504 	addi	r2,r2,-22444
81143728:	180691ba 	slli	r3,r3,6
8114372c:	10c5883a 	add	r2,r2,r3
81143730:	10800a04 	addi	r2,r2,40
81143734:	10c00017 	ldw	r3,0(r2)
81143738:	00a045f4 	movhi	r2,33047
8114373c:	10aa1504 	addi	r2,r2,-22444
81143740:	e13fec17 	ldw	r4,-80(fp)
81143744:	200891ba 	slli	r4,r4,6
81143748:	1105883a 	add	r2,r2,r4
8114374c:	10800a04 	addi	r2,r2,40
81143750:	10800017 	ldw	r2,0(r2)
81143754:	1880271e 	bne	r3,r2,811437f4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81143758:	e0ffeb0f 	ldh	r3,-84(fp)
8114375c:	00a045f4 	movhi	r2,33047
81143760:	10aa1504 	addi	r2,r2,-22444
81143764:	180691ba 	slli	r3,r3,6
81143768:	10c5883a 	add	r2,r2,r3
8114376c:	10800b04 	addi	r2,r2,44
81143770:	10c00017 	ldw	r3,0(r2)
81143774:	00a045f4 	movhi	r2,33047
81143778:	10aa1504 	addi	r2,r2,-22444
8114377c:	e13fec17 	ldw	r4,-80(fp)
81143780:	200891ba 	slli	r4,r4,6
81143784:	1105883a 	add	r2,r2,r4
81143788:	10800b04 	addi	r2,r2,44
8114378c:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
81143790:	1880181e 	bne	r3,r2,811437f4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81143794:	e0ffeb0f 	ldh	r3,-84(fp)
81143798:	00a045f4 	movhi	r2,33047
8114379c:	10aa1504 	addi	r2,r2,-22444
811437a0:	180691ba 	slli	r3,r3,6
811437a4:	10c5883a 	add	r2,r2,r3
811437a8:	10800c04 	addi	r2,r2,48
811437ac:	1100000b 	ldhu	r4,0(r2)
811437b0:	00a045f4 	movhi	r2,33047
811437b4:	10aa1504 	addi	r2,r2,-22444
811437b8:	e0ffec17 	ldw	r3,-80(fp)
811437bc:	180691ba 	slli	r3,r3,6
811437c0:	10c5883a 	add	r2,r2,r3
811437c4:	10800c04 	addi	r2,r2,48
811437c8:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811437cc:	20ffffcc 	andi	r3,r4,65535
811437d0:	18e0001c 	xori	r3,r3,32768
811437d4:	18e00004 	addi	r3,r3,-32768
811437d8:	10bfffcc 	andi	r2,r2,65535
811437dc:	10a0001c 	xori	r2,r2,32768
811437e0:	10a00004 	addi	r2,r2,-32768
811437e4:	1880031e 	bne	r3,r2,811437f4 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
811437e8:	00bfff84 	movi	r2,-2
811437ec:	e0bfeb0d 	sth	r2,-84(fp)
								break;
811437f0:	00002a06 	br	8114389c <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811437f4:	e0bfec17 	ldw	r2,-80(fp)
811437f8:	10800044 	addi	r2,r2,1
811437fc:	e0bfec15 	stw	r2,-80(fp)
81143800:	e0bfec17 	ldw	r2,-80(fp)
81143804:	10800510 	cmplti	r2,r2,20
81143808:	103fb81e 	bne	r2,zero,811436ec <__reset+0xfb1236ec>
8114380c:	00002306 	br	8114389c <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
81143810:	e0bfff17 	ldw	r2,-4(fp)
81143814:	10001f26 	beq	r2,zero,81143894 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
81143818:	e0bfeb0f 	ldh	r2,-84(fp)
8114381c:	100691ba 	slli	r3,r2,6
81143820:	00a045f4 	movhi	r2,33047
81143824:	10aa1504 	addi	r2,r2,-22444
81143828:	1885883a 	add	r2,r3,r2
8114382c:	e0ffee04 	addi	r3,fp,-72
81143830:	180d883a 	mov	r6,r3
81143834:	100b883a 	mov	r5,r2
81143838:	e13ffe17 	ldw	r4,-8(fp)
8114383c:	1142a740 	call	81142a74 <create_file>
81143840:	10001126 	beq	r2,zero,81143888 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81143844:	e0ffeb0f 	ldh	r3,-84(fp)
81143848:	00a045f4 	movhi	r2,33047
8114384c:	10aa1504 	addi	r2,r2,-22444
81143850:	180691ba 	slli	r3,r3,6
81143854:	10c5883a 	add	r2,r2,r3
81143858:	10800f04 	addi	r2,r2,60
8114385c:	00c00044 	movi	r3,1
81143860:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81143864:	e0ffeb0f 	ldh	r3,-84(fp)
81143868:	00a045f4 	movhi	r2,33047
8114386c:	10aa1504 	addi	r2,r2,-22444
81143870:	180691ba 	slli	r3,r3,6
81143874:	10c5883a 	add	r2,r2,r3
81143878:	10800e04 	addi	r2,r2,56
8114387c:	00c00044 	movi	r3,1
81143880:	10c00015 	stw	r3,0(r2)
81143884:	00000506 	br	8114389c <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81143888:	00bfffc4 	movi	r2,-1
8114388c:	e0bfeb0d 	sth	r2,-84(fp)
81143890:	00000206 	br	8114389c <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81143894:	00bfffc4 	movi	r2,-1
81143898:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
8114389c:	e0bfeb0b 	ldhu	r2,-84(fp)
}
811438a0:	e037883a 	mov	sp,fp
811438a4:	dfc00117 	ldw	ra,4(sp)
811438a8:	df000017 	ldw	fp,0(sp)
811438ac:	dec00204 	addi	sp,sp,8
811438b0:	f800283a 	ret

811438b4 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
811438b4:	defffd04 	addi	sp,sp,-12
811438b8:	de00012e 	bgeu	sp,et,811438c0 <alt_up_sd_card_set_attributes+0xc>
811438bc:	003b68fa 	trap	3
811438c0:	df000215 	stw	fp,8(sp)
811438c4:	df000204 	addi	fp,sp,8
811438c8:	2007883a 	mov	r3,r4
811438cc:	2805883a 	mov	r2,r5
811438d0:	e0fffe0d 	sth	r3,-8(fp)
811438d4:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811438d8:	e0bffe0f 	ldh	r2,-8(fp)
811438dc:	10001416 	blt	r2,zero,81143930 <alt_up_sd_card_set_attributes+0x7c>
811438e0:	e0bffe0f 	ldh	r2,-8(fp)
811438e4:	10800508 	cmpgei	r2,r2,20
811438e8:	1000111e 	bne	r2,zero,81143930 <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811438ec:	e0fffe0f 	ldh	r3,-8(fp)
811438f0:	00a045f4 	movhi	r2,33047
811438f4:	10aa1504 	addi	r2,r2,-22444
811438f8:	180691ba 	slli	r3,r3,6
811438fc:	10c5883a 	add	r2,r2,r3
81143900:	10800f04 	addi	r2,r2,60
81143904:	10800017 	ldw	r2,0(r2)
81143908:	10000926 	beq	r2,zero,81143930 <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
8114390c:	e0fffe0f 	ldh	r3,-8(fp)
81143910:	e0bfff0b 	ldhu	r2,-4(fp)
81143914:	1009883a 	mov	r4,r2
81143918:	00a045f4 	movhi	r2,33047
8114391c:	10aa1504 	addi	r2,r2,-22444
81143920:	180691ba 	slli	r3,r3,6
81143924:	10c5883a 	add	r2,r2,r3
81143928:	108002c4 	addi	r2,r2,11
8114392c:	11000005 	stb	r4,0(r2)
        }
    }
}
81143930:	0001883a 	nop
81143934:	e037883a 	mov	sp,fp
81143938:	df000017 	ldw	fp,0(sp)
8114393c:	dec00104 	addi	sp,sp,4
81143940:	f800283a 	ret

81143944 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81143944:	defffd04 	addi	sp,sp,-12
81143948:	de00012e 	bgeu	sp,et,81143950 <alt_up_sd_card_get_attributes+0xc>
8114394c:	003b68fa 	trap	3
81143950:	df000215 	stw	fp,8(sp)
81143954:	df000204 	addi	fp,sp,8
81143958:	2005883a 	mov	r2,r4
8114395c:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
81143960:	00bfffc4 	movi	r2,-1
81143964:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81143968:	e0bfff0f 	ldh	r2,-4(fp)
8114396c:	10001416 	blt	r2,zero,811439c0 <alt_up_sd_card_get_attributes+0x7c>
81143970:	e0bfff0f 	ldh	r2,-4(fp)
81143974:	10800508 	cmpgei	r2,r2,20
81143978:	1000111e 	bne	r2,zero,811439c0 <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
8114397c:	e0ffff0f 	ldh	r3,-4(fp)
81143980:	00a045f4 	movhi	r2,33047
81143984:	10aa1504 	addi	r2,r2,-22444
81143988:	180691ba 	slli	r3,r3,6
8114398c:	10c5883a 	add	r2,r2,r3
81143990:	10800f04 	addi	r2,r2,60
81143994:	10800017 	ldw	r2,0(r2)
81143998:	10000926 	beq	r2,zero,811439c0 <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
8114399c:	e0ffff0f 	ldh	r3,-4(fp)
811439a0:	00a045f4 	movhi	r2,33047
811439a4:	10aa1504 	addi	r2,r2,-22444
811439a8:	180691ba 	slli	r3,r3,6
811439ac:	10c5883a 	add	r2,r2,r3
811439b0:	108002c4 	addi	r2,r2,11
811439b4:	10800003 	ldbu	r2,0(r2)
811439b8:	10803fcc 	andi	r2,r2,255
811439bc:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
811439c0:	e0bffe0b 	ldhu	r2,-8(fp)
}
811439c4:	e037883a 	mov	sp,fp
811439c8:	df000017 	ldw	fp,0(sp)
811439cc:	dec00104 	addi	sp,sp,4
811439d0:	f800283a 	ret

811439d4 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
811439d4:	defffa04 	addi	sp,sp,-24
811439d8:	de00012e 	bgeu	sp,et,811439e0 <alt_up_sd_card_read+0xc>
811439dc:	003b68fa 	trap	3
811439e0:	dfc00515 	stw	ra,20(sp)
811439e4:	df000415 	stw	fp,16(sp)
811439e8:	df000404 	addi	fp,sp,16
811439ec:	2005883a 	mov	r2,r4
811439f0:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811439f4:	00bfffc4 	movi	r2,-1
811439f8:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811439fc:	e0bfff0f 	ldh	r2,-4(fp)
81143a00:	1000ce16 	blt	r2,zero,81143d3c <alt_up_sd_card_read+0x368>
81143a04:	e0bfff0f 	ldh	r2,-4(fp)
81143a08:	10800508 	cmpgei	r2,r2,20
81143a0c:	1000cb1e 	bne	r2,zero,81143d3c <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
81143a10:	e0ffff0f 	ldh	r3,-4(fp)
81143a14:	00a045f4 	movhi	r2,33047
81143a18:	10aa1504 	addi	r2,r2,-22444
81143a1c:	180691ba 	slli	r3,r3,6
81143a20:	10c5883a 	add	r2,r2,r3
81143a24:	10800f04 	addi	r2,r2,60
81143a28:	10800017 	ldw	r2,0(r2)
81143a2c:	1000c326 	beq	r2,zero,81143d3c <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81143a30:	e0ffff0f 	ldh	r3,-4(fp)
81143a34:	00a045f4 	movhi	r2,33047
81143a38:	10aa1504 	addi	r2,r2,-22444
81143a3c:	180691ba 	slli	r3,r3,6
81143a40:	10c5883a 	add	r2,r2,r3
81143a44:	10800904 	addi	r2,r2,36
81143a48:	10c00017 	ldw	r3,0(r2)
81143a4c:	e13fff0f 	ldh	r4,-4(fp)
81143a50:	00a045f4 	movhi	r2,33047
81143a54:	10aa1504 	addi	r2,r2,-22444
81143a58:	200891ba 	slli	r4,r4,6
81143a5c:	1105883a 	add	r2,r2,r4
81143a60:	10800604 	addi	r2,r2,24
81143a64:	10800017 	ldw	r2,0(r2)
81143a68:	1880b42e 	bgeu	r3,r2,81143d3c <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143a6c:	00a045f4 	movhi	r2,33047
81143a70:	10aa0004 	addi	r2,r2,-22528
81143a74:	10c01417 	ldw	r3,80(r2)
81143a78:	e13fff0f 	ldh	r4,-4(fp)
81143a7c:	00a045f4 	movhi	r2,33047
81143a80:	10aa1504 	addi	r2,r2,-22444
81143a84:	200891ba 	slli	r4,r4,6
81143a88:	1105883a 	add	r2,r2,r4
81143a8c:	10800704 	addi	r2,r2,28
81143a90:	10800017 	ldw	r2,0(r2)
81143a94:	113fff84 	addi	r4,r2,-2
81143a98:	00a045f4 	movhi	r2,33047
81143a9c:	10aa0004 	addi	r2,r2,-22528
81143aa0:	10800383 	ldbu	r2,14(r2)
81143aa4:	10803fcc 	andi	r2,r2,255
81143aa8:	2085383a 	mul	r2,r4,r2
81143aac:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81143ab0:	e13fff0f 	ldh	r4,-4(fp)
81143ab4:	00a045f4 	movhi	r2,33047
81143ab8:	10aa1504 	addi	r2,r2,-22444
81143abc:	200891ba 	slli	r4,r4,6
81143ac0:	1105883a 	add	r2,r2,r4
81143ac4:	10800804 	addi	r2,r2,32
81143ac8:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143acc:	1885883a 	add	r2,r3,r2
81143ad0:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81143ad4:	e0ffff0f 	ldh	r3,-4(fp)
81143ad8:	00a045f4 	movhi	r2,33047
81143adc:	10aa1504 	addi	r2,r2,-22444
81143ae0:	180691ba 	slli	r3,r3,6
81143ae4:	10c5883a 	add	r2,r2,r3
81143ae8:	10800904 	addi	r2,r2,36
81143aec:	10800017 	ldw	r2,0(r2)
81143af0:	10006826 	beq	r2,zero,81143c94 <alt_up_sd_card_read+0x2c0>
81143af4:	e0ffff0f 	ldh	r3,-4(fp)
81143af8:	00a045f4 	movhi	r2,33047
81143afc:	10aa1504 	addi	r2,r2,-22444
81143b00:	180691ba 	slli	r3,r3,6
81143b04:	10c5883a 	add	r2,r2,r3
81143b08:	10800904 	addi	r2,r2,36
81143b0c:	10800017 	ldw	r2,0(r2)
81143b10:	10807fcc 	andi	r2,r2,511
81143b14:	10005f1e 	bne	r2,zero,81143c94 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81143b18:	e0ffff0f 	ldh	r3,-4(fp)
81143b1c:	00a045f4 	movhi	r2,33047
81143b20:	10aa1504 	addi	r2,r2,-22444
81143b24:	180691ba 	slli	r3,r3,6
81143b28:	10c5883a 	add	r2,r2,r3
81143b2c:	10800804 	addi	r2,r2,32
81143b30:	10c00017 	ldw	r3,0(r2)
81143b34:	00a045f4 	movhi	r2,33047
81143b38:	10aa0004 	addi	r2,r2,-22528
81143b3c:	10800383 	ldbu	r2,14(r2)
81143b40:	10803fcc 	andi	r2,r2,255
81143b44:	10bfffc4 	addi	r2,r2,-1
81143b48:	1880401e 	bne	r3,r2,81143c4c <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81143b4c:	e0ffff0f 	ldh	r3,-4(fp)
81143b50:	00a045f4 	movhi	r2,33047
81143b54:	10aa1504 	addi	r2,r2,-22444
81143b58:	180691ba 	slli	r3,r3,6
81143b5c:	10c5883a 	add	r2,r2,r3
81143b60:	10800704 	addi	r2,r2,28
81143b64:	10800017 	ldw	r2,0(r2)
81143b68:	e0fffe04 	addi	r3,fp,-8
81143b6c:	180b883a 	mov	r5,r3
81143b70:	1009883a 	mov	r4,r2
81143b74:	11403600 	call	81140360 <get_cluster_flag>
81143b78:	10003226 	beq	r2,zero,81143c44 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81143b7c:	e0bffe0b 	ldhu	r2,-8(fp)
81143b80:	10bfffcc 	andi	r2,r2,65535
81143b84:	10fffe0c 	andi	r3,r2,65528
81143b88:	00bffe14 	movui	r2,65528
81143b8c:	1880021e 	bne	r3,r2,81143b98 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81143b90:	00bfffc4 	movi	r2,-1
81143b94:	00006a06 	br	81143d40 <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81143b98:	e13fff0f 	ldh	r4,-4(fp)
81143b9c:	e0bffe0b 	ldhu	r2,-8(fp)
81143ba0:	10ffffcc 	andi	r3,r2,65535
81143ba4:	00a045f4 	movhi	r2,33047
81143ba8:	10aa1504 	addi	r2,r2,-22444
81143bac:	200891ba 	slli	r4,r4,6
81143bb0:	1105883a 	add	r2,r2,r4
81143bb4:	10800704 	addi	r2,r2,28
81143bb8:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81143bbc:	e0ffff0f 	ldh	r3,-4(fp)
81143bc0:	00a045f4 	movhi	r2,33047
81143bc4:	10aa1504 	addi	r2,r2,-22444
81143bc8:	180691ba 	slli	r3,r3,6
81143bcc:	10c5883a 	add	r2,r2,r3
81143bd0:	10800804 	addi	r2,r2,32
81143bd4:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143bd8:	00a045f4 	movhi	r2,33047
81143bdc:	10aa0004 	addi	r2,r2,-22528
81143be0:	10c01417 	ldw	r3,80(r2)
81143be4:	e13fff0f 	ldh	r4,-4(fp)
81143be8:	00a045f4 	movhi	r2,33047
81143bec:	10aa1504 	addi	r2,r2,-22444
81143bf0:	200891ba 	slli	r4,r4,6
81143bf4:	1105883a 	add	r2,r2,r4
81143bf8:	10800704 	addi	r2,r2,28
81143bfc:	10800017 	ldw	r2,0(r2)
81143c00:	113fff84 	addi	r4,r2,-2
81143c04:	00a045f4 	movhi	r2,33047
81143c08:	10aa0004 	addi	r2,r2,-22528
81143c0c:	10800383 	ldbu	r2,14(r2)
81143c10:	10803fcc 	andi	r2,r2,255
81143c14:	2085383a 	mul	r2,r4,r2
81143c18:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81143c1c:	e13fff0f 	ldh	r4,-4(fp)
81143c20:	00a045f4 	movhi	r2,33047
81143c24:	10aa1504 	addi	r2,r2,-22444
81143c28:	200891ba 	slli	r4,r4,6
81143c2c:	1105883a 	add	r2,r2,r4
81143c30:	10800804 	addi	r2,r2,32
81143c34:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143c38:	1885883a 	add	r2,r3,r2
81143c3c:	e0bffd15 	stw	r2,-12(fp)
81143c40:	00001406 	br	81143c94 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81143c44:	00bfff84 	movi	r2,-2
81143c48:	00003d06 	br	81143d40 <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81143c4c:	e13fff0f 	ldh	r4,-4(fp)
81143c50:	e0ffff0f 	ldh	r3,-4(fp)
81143c54:	00a045f4 	movhi	r2,33047
81143c58:	10aa1504 	addi	r2,r2,-22444
81143c5c:	180691ba 	slli	r3,r3,6
81143c60:	10c5883a 	add	r2,r2,r3
81143c64:	10800804 	addi	r2,r2,32
81143c68:	10800017 	ldw	r2,0(r2)
81143c6c:	10c00044 	addi	r3,r2,1
81143c70:	00a045f4 	movhi	r2,33047
81143c74:	10aa1504 	addi	r2,r2,-22444
81143c78:	200891ba 	slli	r4,r4,6
81143c7c:	1105883a 	add	r2,r2,r4
81143c80:	10800804 	addi	r2,r2,32
81143c84:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81143c88:	e0bffd17 	ldw	r2,-12(fp)
81143c8c:	10800044 	addi	r2,r2,1
81143c90:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81143c94:	d0e0b017 	ldw	r3,-32064(gp)
81143c98:	e0bffd17 	ldw	r2,-12(fp)
81143c9c:	1885883a 	add	r2,r3,r2
81143ca0:	1007883a 	mov	r3,r2
81143ca4:	d0a0b417 	ldw	r2,-32048(gp)
81143ca8:	18800726 	beq	r3,r2,81143cc8 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81143cac:	d0a0b017 	ldw	r2,-32064(gp)
81143cb0:	100b883a 	mov	r5,r2
81143cb4:	e13ffd17 	ldw	r4,-12(fp)
81143cb8:	11402800 	call	81140280 <Read_Sector_Data>
81143cbc:	1000021e 	bne	r2,zero,81143cc8 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81143cc0:	00bfff84 	movi	r2,-2
81143cc4:	00001e06 	br	81143d40 <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81143cc8:	d0e0af17 	ldw	r3,-32068(gp)
81143ccc:	e13fff0f 	ldh	r4,-4(fp)
81143cd0:	00a045f4 	movhi	r2,33047
81143cd4:	10aa1504 	addi	r2,r2,-22444
81143cd8:	200891ba 	slli	r4,r4,6
81143cdc:	1105883a 	add	r2,r2,r4
81143ce0:	10800904 	addi	r2,r2,36
81143ce4:	10800017 	ldw	r2,0(r2)
81143ce8:	10807fcc 	andi	r2,r2,511
81143cec:	1885883a 	add	r2,r3,r2
81143cf0:	10800023 	ldbuio	r2,0(r2)
81143cf4:	10803fcc 	andi	r2,r2,255
81143cf8:	10803fcc 	andi	r2,r2,255
81143cfc:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81143d00:	e13fff0f 	ldh	r4,-4(fp)
81143d04:	e0ffff0f 	ldh	r3,-4(fp)
81143d08:	00a045f4 	movhi	r2,33047
81143d0c:	10aa1504 	addi	r2,r2,-22444
81143d10:	180691ba 	slli	r3,r3,6
81143d14:	10c5883a 	add	r2,r2,r3
81143d18:	10800904 	addi	r2,r2,36
81143d1c:	10800017 	ldw	r2,0(r2)
81143d20:	10c00044 	addi	r3,r2,1
81143d24:	00a045f4 	movhi	r2,33047
81143d28:	10aa1504 	addi	r2,r2,-22444
81143d2c:	200891ba 	slli	r4,r4,6
81143d30:	1105883a 	add	r2,r2,r4
81143d34:	10800904 	addi	r2,r2,36
81143d38:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81143d3c:	e0bffc0b 	ldhu	r2,-16(fp)
}
81143d40:	e037883a 	mov	sp,fp
81143d44:	dfc00117 	ldw	ra,4(sp)
81143d48:	df000017 	ldw	fp,0(sp)
81143d4c:	dec00204 	addi	sp,sp,8
81143d50:	f800283a 	ret

81143d54 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81143d54:	defff804 	addi	sp,sp,-32
81143d58:	de00012e 	bgeu	sp,et,81143d60 <alt_up_sd_card_write+0xc>
81143d5c:	003b68fa 	trap	3
81143d60:	dfc00715 	stw	ra,28(sp)
81143d64:	df000615 	stw	fp,24(sp)
81143d68:	df000604 	addi	fp,sp,24
81143d6c:	2007883a 	mov	r3,r4
81143d70:	2805883a 	mov	r2,r5
81143d74:	e0fffe0d 	sth	r3,-8(fp)
81143d78:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81143d7c:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81143d80:	e0bffe0f 	ldh	r2,-8(fp)
81143d84:	10017716 	blt	r2,zero,81144364 <alt_up_sd_card_write+0x610>
81143d88:	e0bffe0f 	ldh	r2,-8(fp)
81143d8c:	10800508 	cmpgei	r2,r2,20
81143d90:	1001741e 	bne	r2,zero,81144364 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81143d94:	e0fffe0f 	ldh	r3,-8(fp)
81143d98:	00a045f4 	movhi	r2,33047
81143d9c:	10aa1504 	addi	r2,r2,-22444
81143da0:	180691ba 	slli	r3,r3,6
81143da4:	10c5883a 	add	r2,r2,r3
81143da8:	10800f04 	addi	r2,r2,60
81143dac:	10800017 	ldw	r2,0(r2)
81143db0:	10016c26 	beq	r2,zero,81144364 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143db4:	00a045f4 	movhi	r2,33047
81143db8:	10aa0004 	addi	r2,r2,-22528
81143dbc:	10c01417 	ldw	r3,80(r2)
81143dc0:	e13ffe0f 	ldh	r4,-8(fp)
81143dc4:	00a045f4 	movhi	r2,33047
81143dc8:	10aa1504 	addi	r2,r2,-22444
81143dcc:	200891ba 	slli	r4,r4,6
81143dd0:	1105883a 	add	r2,r2,r4
81143dd4:	10800704 	addi	r2,r2,28
81143dd8:	10800017 	ldw	r2,0(r2)
81143ddc:	113fff84 	addi	r4,r2,-2
81143de0:	00a045f4 	movhi	r2,33047
81143de4:	10aa0004 	addi	r2,r2,-22528
81143de8:	10800383 	ldbu	r2,14(r2)
81143dec:	10803fcc 	andi	r2,r2,255
81143df0:	2085383a 	mul	r2,r4,r2
81143df4:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81143df8:	e13ffe0f 	ldh	r4,-8(fp)
81143dfc:	00a045f4 	movhi	r2,33047
81143e00:	10aa1504 	addi	r2,r2,-22444
81143e04:	200891ba 	slli	r4,r4,6
81143e08:	1105883a 	add	r2,r2,r4
81143e0c:	10800804 	addi	r2,r2,32
81143e10:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143e14:	1885883a 	add	r2,r3,r2
81143e18:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81143e1c:	e0fffe0f 	ldh	r3,-8(fp)
81143e20:	00a045f4 	movhi	r2,33047
81143e24:	10aa1504 	addi	r2,r2,-22444
81143e28:	180691ba 	slli	r3,r3,6
81143e2c:	10c5883a 	add	r2,r2,r3
81143e30:	10800904 	addi	r2,r2,36
81143e34:	10c00017 	ldw	r3,0(r2)
81143e38:	00a045f4 	movhi	r2,33047
81143e3c:	10aa0004 	addi	r2,r2,-22528
81143e40:	1080030b 	ldhu	r2,12(r2)
81143e44:	10bfffcc 	andi	r2,r2,65535
81143e48:	1889203a 	divu	r4,r3,r2
81143e4c:	2085383a 	mul	r2,r4,r2
81143e50:	1885c83a 	sub	r2,r3,r2
81143e54:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81143e58:	e0fffe0f 	ldh	r3,-8(fp)
81143e5c:	00a045f4 	movhi	r2,33047
81143e60:	10aa1504 	addi	r2,r2,-22444
81143e64:	180691ba 	slli	r3,r3,6
81143e68:	10c5883a 	add	r2,r2,r3
81143e6c:	10800904 	addi	r2,r2,36
81143e70:	10c00017 	ldw	r3,0(r2)
81143e74:	e13ffe0f 	ldh	r4,-8(fp)
81143e78:	00a045f4 	movhi	r2,33047
81143e7c:	10aa1504 	addi	r2,r2,-22444
81143e80:	200891ba 	slli	r4,r4,6
81143e84:	1105883a 	add	r2,r2,r4
81143e88:	10800604 	addi	r2,r2,24
81143e8c:	10800017 	ldw	r2,0(r2)
81143e90:	1880672e 	bgeu	r3,r2,81144030 <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81143e94:	e0fffe0f 	ldh	r3,-8(fp)
81143e98:	00a045f4 	movhi	r2,33047
81143e9c:	10aa1504 	addi	r2,r2,-22444
81143ea0:	180691ba 	slli	r3,r3,6
81143ea4:	10c5883a 	add	r2,r2,r3
81143ea8:	10800904 	addi	r2,r2,36
81143eac:	10800017 	ldw	r2,0(r2)
81143eb0:	1000e126 	beq	r2,zero,81144238 <alt_up_sd_card_write+0x4e4>
81143eb4:	e0bffc0f 	ldh	r2,-16(fp)
81143eb8:	1000df1e 	bne	r2,zero,81144238 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81143ebc:	e0fffe0f 	ldh	r3,-8(fp)
81143ec0:	00a045f4 	movhi	r2,33047
81143ec4:	10aa1504 	addi	r2,r2,-22444
81143ec8:	180691ba 	slli	r3,r3,6
81143ecc:	10c5883a 	add	r2,r2,r3
81143ed0:	10800804 	addi	r2,r2,32
81143ed4:	10c00017 	ldw	r3,0(r2)
81143ed8:	00a045f4 	movhi	r2,33047
81143edc:	10aa0004 	addi	r2,r2,-22528
81143ee0:	10800383 	ldbu	r2,14(r2)
81143ee4:	10803fcc 	andi	r2,r2,255
81143ee8:	10bfffc4 	addi	r2,r2,-1
81143eec:	18803d1e 	bne	r3,r2,81143fe4 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81143ef0:	e0fffe0f 	ldh	r3,-8(fp)
81143ef4:	00a045f4 	movhi	r2,33047
81143ef8:	10aa1504 	addi	r2,r2,-22444
81143efc:	180691ba 	slli	r3,r3,6
81143f00:	10c5883a 	add	r2,r2,r3
81143f04:	10800704 	addi	r2,r2,28
81143f08:	10800017 	ldw	r2,0(r2)
81143f0c:	e0fffc84 	addi	r3,fp,-14
81143f10:	180b883a 	mov	r5,r3
81143f14:	1009883a 	mov	r4,r2
81143f18:	11403600 	call	81140360 <get_cluster_flag>
81143f1c:	10002f26 	beq	r2,zero,81143fdc <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81143f20:	e0bffc8b 	ldhu	r2,-14(fp)
81143f24:	10bfffcc 	andi	r2,r2,65535
81143f28:	10bffe28 	cmpgeui	r2,r2,65528
81143f2c:	1000c21e 	bne	r2,zero,81144238 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81143f30:	e13ffe0f 	ldh	r4,-8(fp)
81143f34:	e0bffc8b 	ldhu	r2,-14(fp)
81143f38:	10ffffcc 	andi	r3,r2,65535
81143f3c:	00a045f4 	movhi	r2,33047
81143f40:	10aa1504 	addi	r2,r2,-22444
81143f44:	200891ba 	slli	r4,r4,6
81143f48:	1105883a 	add	r2,r2,r4
81143f4c:	10800704 	addi	r2,r2,28
81143f50:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81143f54:	e0fffe0f 	ldh	r3,-8(fp)
81143f58:	00a045f4 	movhi	r2,33047
81143f5c:	10aa1504 	addi	r2,r2,-22444
81143f60:	180691ba 	slli	r3,r3,6
81143f64:	10c5883a 	add	r2,r2,r3
81143f68:	10800804 	addi	r2,r2,32
81143f6c:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143f70:	00a045f4 	movhi	r2,33047
81143f74:	10aa0004 	addi	r2,r2,-22528
81143f78:	10c01417 	ldw	r3,80(r2)
81143f7c:	e13ffe0f 	ldh	r4,-8(fp)
81143f80:	00a045f4 	movhi	r2,33047
81143f84:	10aa1504 	addi	r2,r2,-22444
81143f88:	200891ba 	slli	r4,r4,6
81143f8c:	1105883a 	add	r2,r2,r4
81143f90:	10800704 	addi	r2,r2,28
81143f94:	10800017 	ldw	r2,0(r2)
81143f98:	113fff84 	addi	r4,r2,-2
81143f9c:	00a045f4 	movhi	r2,33047
81143fa0:	10aa0004 	addi	r2,r2,-22528
81143fa4:	10800383 	ldbu	r2,14(r2)
81143fa8:	10803fcc 	andi	r2,r2,255
81143fac:	2085383a 	mul	r2,r4,r2
81143fb0:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81143fb4:	e13ffe0f 	ldh	r4,-8(fp)
81143fb8:	00a045f4 	movhi	r2,33047
81143fbc:	10aa1504 	addi	r2,r2,-22444
81143fc0:	200891ba 	slli	r4,r4,6
81143fc4:	1105883a 	add	r2,r2,r4
81143fc8:	10800804 	addi	r2,r2,32
81143fcc:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81143fd0:	1885883a 	add	r2,r3,r2
81143fd4:	e0bffb15 	stw	r2,-20(fp)
81143fd8:	00009706 	br	81144238 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81143fdc:	0005883a 	mov	r2,zero
81143fe0:	0000e106 	br	81144368 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81143fe4:	e13ffe0f 	ldh	r4,-8(fp)
81143fe8:	e0fffe0f 	ldh	r3,-8(fp)
81143fec:	00a045f4 	movhi	r2,33047
81143ff0:	10aa1504 	addi	r2,r2,-22444
81143ff4:	180691ba 	slli	r3,r3,6
81143ff8:	10c5883a 	add	r2,r2,r3
81143ffc:	10800804 	addi	r2,r2,32
81144000:	10800017 	ldw	r2,0(r2)
81144004:	10c00044 	addi	r3,r2,1
81144008:	00a045f4 	movhi	r2,33047
8114400c:	10aa1504 	addi	r2,r2,-22444
81144010:	200891ba 	slli	r4,r4,6
81144014:	1105883a 	add	r2,r2,r4
81144018:	10800804 	addi	r2,r2,32
8114401c:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81144020:	e0bffb17 	ldw	r2,-20(fp)
81144024:	10800044 	addi	r2,r2,1
81144028:	e0bffb15 	stw	r2,-20(fp)
8114402c:	00008206 	br	81144238 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81144030:	e0fffe0f 	ldh	r3,-8(fp)
81144034:	00a045f4 	movhi	r2,33047
81144038:	10aa1504 	addi	r2,r2,-22444
8114403c:	180691ba 	slli	r3,r3,6
81144040:	10c5883a 	add	r2,r2,r3
81144044:	10800904 	addi	r2,r2,36
81144048:	10800017 	ldw	r2,0(r2)
8114404c:	10007a26 	beq	r2,zero,81144238 <alt_up_sd_card_write+0x4e4>
81144050:	e0bffc0f 	ldh	r2,-16(fp)
81144054:	1000781e 	bne	r2,zero,81144238 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81144058:	e0fffe0f 	ldh	r3,-8(fp)
8114405c:	00a045f4 	movhi	r2,33047
81144060:	10aa1504 	addi	r2,r2,-22444
81144064:	180691ba 	slli	r3,r3,6
81144068:	10c5883a 	add	r2,r2,r3
8114406c:	10800804 	addi	r2,r2,32
81144070:	10c00017 	ldw	r3,0(r2)
81144074:	00a045f4 	movhi	r2,33047
81144078:	10aa0004 	addi	r2,r2,-22528
8114407c:	10800383 	ldbu	r2,14(r2)
81144080:	10803fcc 	andi	r2,r2,255
81144084:	10bfffc4 	addi	r2,r2,-1
81144088:	18803e1e 	bne	r3,r2,81144184 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
8114408c:	e0bffd04 	addi	r2,fp,-12
81144090:	1009883a 	mov	r4,r2
81144094:	11423a40 	call	811423a4 <find_first_empty_cluster>
81144098:	10003826 	beq	r2,zero,8114417c <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
8114409c:	e0fffe0f 	ldh	r3,-8(fp)
811440a0:	00a045f4 	movhi	r2,33047
811440a4:	10aa1504 	addi	r2,r2,-22444
811440a8:	180691ba 	slli	r3,r3,6
811440ac:	10c5883a 	add	r2,r2,r3
811440b0:	10800704 	addi	r2,r2,28
811440b4:	10800017 	ldw	r2,0(r2)
811440b8:	e0fffd17 	ldw	r3,-12(fp)
811440bc:	18ffffcc 	andi	r3,r3,65535
811440c0:	18e0001c 	xori	r3,r3,32768
811440c4:	18e00004 	addi	r3,r3,-32768
811440c8:	01800044 	movi	r6,1
811440cc:	180b883a 	mov	r5,r3
811440d0:	1009883a 	mov	r4,r2
811440d4:	114041c0 	call	8114041c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
811440d8:	e0bffd17 	ldw	r2,-12(fp)
811440dc:	01800044 	movi	r6,1
811440e0:	017fffc4 	movi	r5,-1
811440e4:	1009883a 	mov	r4,r2
811440e8:	114041c0 	call	8114041c <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811440ec:	e0fffe0f 	ldh	r3,-8(fp)
811440f0:	00a045f4 	movhi	r2,33047
811440f4:	10aa1504 	addi	r2,r2,-22444
811440f8:	180691ba 	slli	r3,r3,6
811440fc:	10c5883a 	add	r2,r2,r3
81144100:	10800704 	addi	r2,r2,28
81144104:	10800017 	ldw	r2,0(r2)
81144108:	e0fffd17 	ldw	r3,-12(fp)
8114410c:	18ffffcc 	andi	r3,r3,65535
81144110:	18e0001c 	xori	r3,r3,32768
81144114:	18e00004 	addi	r3,r3,-32768
81144118:	000d883a 	mov	r6,zero
8114411c:	180b883a 	mov	r5,r3
81144120:	1009883a 	mov	r4,r2
81144124:	114041c0 	call	8114041c <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81144128:	e0bffd17 	ldw	r2,-12(fp)
8114412c:	000d883a 	mov	r6,zero
81144130:	017fffc4 	movi	r5,-1
81144134:	1009883a 	mov	r4,r2
81144138:	114041c0 	call	8114041c <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
8114413c:	e13ffe0f 	ldh	r4,-8(fp)
81144140:	e0fffd17 	ldw	r3,-12(fp)
81144144:	00a045f4 	movhi	r2,33047
81144148:	10aa1504 	addi	r2,r2,-22444
8114414c:	200891ba 	slli	r4,r4,6
81144150:	1105883a 	add	r2,r2,r4
81144154:	10800704 	addi	r2,r2,28
81144158:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
8114415c:	e0fffe0f 	ldh	r3,-8(fp)
81144160:	00a045f4 	movhi	r2,33047
81144164:	10aa1504 	addi	r2,r2,-22444
81144168:	180691ba 	slli	r3,r3,6
8114416c:	10c5883a 	add	r2,r2,r3
81144170:	10800804 	addi	r2,r2,32
81144174:	10000015 	stw	zero,0(r2)
81144178:	00001506 	br	811441d0 <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
8114417c:	0005883a 	mov	r2,zero
81144180:	00007906 	br	81144368 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81144184:	e13ffe0f 	ldh	r4,-8(fp)
81144188:	e0fffe0f 	ldh	r3,-8(fp)
8114418c:	00a045f4 	movhi	r2,33047
81144190:	10aa1504 	addi	r2,r2,-22444
81144194:	180691ba 	slli	r3,r3,6
81144198:	10c5883a 	add	r2,r2,r3
8114419c:	10800904 	addi	r2,r2,36
811441a0:	10c00017 	ldw	r3,0(r2)
811441a4:	00a045f4 	movhi	r2,33047
811441a8:	10aa0004 	addi	r2,r2,-22528
811441ac:	1080030b 	ldhu	r2,12(r2)
811441b0:	10bfffcc 	andi	r2,r2,65535
811441b4:	1887203a 	divu	r3,r3,r2
811441b8:	00a045f4 	movhi	r2,33047
811441bc:	10aa1504 	addi	r2,r2,-22444
811441c0:	200891ba 	slli	r4,r4,6
811441c4:	1105883a 	add	r2,r2,r4
811441c8:	10800804 	addi	r2,r2,32
811441cc:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811441d0:	00a045f4 	movhi	r2,33047
811441d4:	10aa0004 	addi	r2,r2,-22528
811441d8:	10c01417 	ldw	r3,80(r2)
811441dc:	e13ffe0f 	ldh	r4,-8(fp)
811441e0:	00a045f4 	movhi	r2,33047
811441e4:	10aa1504 	addi	r2,r2,-22444
811441e8:	200891ba 	slli	r4,r4,6
811441ec:	1105883a 	add	r2,r2,r4
811441f0:	10800704 	addi	r2,r2,28
811441f4:	10800017 	ldw	r2,0(r2)
811441f8:	113fff84 	addi	r4,r2,-2
811441fc:	00a045f4 	movhi	r2,33047
81144200:	10aa0004 	addi	r2,r2,-22528
81144204:	10800383 	ldbu	r2,14(r2)
81144208:	10803fcc 	andi	r2,r2,255
8114420c:	2085383a 	mul	r2,r4,r2
81144210:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
81144214:	e13ffe0f 	ldh	r4,-8(fp)
81144218:	00a045f4 	movhi	r2,33047
8114421c:	10aa1504 	addi	r2,r2,-22444
81144220:	200891ba 	slli	r4,r4,6
81144224:	1105883a 	add	r2,r2,r4
81144228:	10800804 	addi	r2,r2,32
8114422c:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81144230:	1885883a 	add	r2,r3,r2
81144234:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81144238:	d0e0b017 	ldw	r3,-32064(gp)
8114423c:	e0bffb17 	ldw	r2,-20(fp)
81144240:	1885883a 	add	r2,r3,r2
81144244:	1007883a 	mov	r3,r2
81144248:	d0a0b417 	ldw	r2,-32048(gp)
8114424c:	18800726 	beq	r3,r2,8114426c <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81144250:	d0a0b017 	ldw	r2,-32064(gp)
81144254:	100b883a 	mov	r5,r2
81144258:	e13ffb17 	ldw	r4,-20(fp)
8114425c:	11402800 	call	81140280 <Read_Sector_Data>
81144260:	1000021e 	bne	r2,zero,8114426c <alt_up_sd_card_write+0x518>
                {
					return false;
81144264:	0005883a 	mov	r2,zero
81144268:	00003f06 	br	81144368 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
8114426c:	d0e0af17 	ldw	r3,-32068(gp)
81144270:	e0bffc0f 	ldh	r2,-16(fp)
81144274:	1885883a 	add	r2,r3,r2
81144278:	e0ffff07 	ldb	r3,-4(fp)
8114427c:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81144280:	e13ffe0f 	ldh	r4,-8(fp)
81144284:	e0fffe0f 	ldh	r3,-8(fp)
81144288:	00a045f4 	movhi	r2,33047
8114428c:	10aa1504 	addi	r2,r2,-22444
81144290:	180691ba 	slli	r3,r3,6
81144294:	10c5883a 	add	r2,r2,r3
81144298:	10800904 	addi	r2,r2,36
8114429c:	10800017 	ldw	r2,0(r2)
811442a0:	10c00044 	addi	r3,r2,1
811442a4:	00a045f4 	movhi	r2,33047
811442a8:	10aa1504 	addi	r2,r2,-22444
811442ac:	200891ba 	slli	r4,r4,6
811442b0:	1105883a 	add	r2,r2,r4
811442b4:	10800904 	addi	r2,r2,36
811442b8:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
811442bc:	e0fffe0f 	ldh	r3,-8(fp)
811442c0:	00a045f4 	movhi	r2,33047
811442c4:	10aa1504 	addi	r2,r2,-22444
811442c8:	180691ba 	slli	r3,r3,6
811442cc:	10c5883a 	add	r2,r2,r3
811442d0:	10800904 	addi	r2,r2,36
811442d4:	10c00017 	ldw	r3,0(r2)
811442d8:	e13ffe0f 	ldh	r4,-8(fp)
811442dc:	00a045f4 	movhi	r2,33047
811442e0:	10aa1504 	addi	r2,r2,-22444
811442e4:	200891ba 	slli	r4,r4,6
811442e8:	1105883a 	add	r2,r2,r4
811442ec:	10800604 	addi	r2,r2,24
811442f0:	10800017 	ldw	r2,0(r2)
811442f4:	18801736 	bltu	r3,r2,81144354 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811442f8:	e13ffe0f 	ldh	r4,-8(fp)
811442fc:	e0fffe0f 	ldh	r3,-8(fp)
81144300:	00a045f4 	movhi	r2,33047
81144304:	10aa1504 	addi	r2,r2,-22444
81144308:	180691ba 	slli	r3,r3,6
8114430c:	10c5883a 	add	r2,r2,r3
81144310:	10800604 	addi	r2,r2,24
81144314:	10800017 	ldw	r2,0(r2)
81144318:	10c00044 	addi	r3,r2,1
8114431c:	00a045f4 	movhi	r2,33047
81144320:	10aa1504 	addi	r2,r2,-22444
81144324:	200891ba 	slli	r4,r4,6
81144328:	1105883a 	add	r2,r2,r4
8114432c:	10800604 	addi	r2,r2,24
81144330:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81144334:	e0fffe0f 	ldh	r3,-8(fp)
81144338:	00a045f4 	movhi	r2,33047
8114433c:	10aa1504 	addi	r2,r2,-22444
81144340:	180691ba 	slli	r3,r3,6
81144344:	10c5883a 	add	r2,r2,r3
81144348:	10800e04 	addi	r2,r2,56
8114434c:	00c00044 	movi	r3,1
81144350:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81144354:	00800044 	movi	r2,1
81144358:	d0a0b315 	stw	r2,-32052(gp)
			result = true;
8114435c:	00800044 	movi	r2,1
81144360:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81144364:	e0bffa17 	ldw	r2,-24(fp)
}
81144368:	e037883a 	mov	sp,fp
8114436c:	dfc00117 	ldw	ra,4(sp)
81144370:	df000017 	ldw	fp,0(sp)
81144374:	dec00204 	addi	sp,sp,8
81144378:	f800283a 	ret

8114437c <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
8114437c:	defffb04 	addi	sp,sp,-20
81144380:	de00012e 	bgeu	sp,et,81144388 <alt_up_sd_card_fclose+0xc>
81144384:	003b68fa 	trap	3
81144388:	dfc00415 	stw	ra,16(sp)
8114438c:	df000315 	stw	fp,12(sp)
81144390:	df000304 	addi	fp,sp,12
81144394:	2005883a 	mov	r2,r4
81144398:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
8114439c:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
811443a0:	1142f580 	call	81142f58 <alt_up_sd_card_is_Present>
811443a4:	10006026 	beq	r2,zero,81144528 <alt_up_sd_card_fclose+0x1ac>
811443a8:	d0a0a917 	ldw	r2,-32092(gp)
811443ac:	10005e26 	beq	r2,zero,81144528 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
811443b0:	e0ffff0f 	ldh	r3,-4(fp)
811443b4:	00a045f4 	movhi	r2,33047
811443b8:	10aa1504 	addi	r2,r2,-22444
811443bc:	180691ba 	slli	r3,r3,6
811443c0:	10c5883a 	add	r2,r2,r3
811443c4:	10800f04 	addi	r2,r2,60
811443c8:	10800017 	ldw	r2,0(r2)
811443cc:	10005626 	beq	r2,zero,81144528 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
811443d0:	e0ffff0f 	ldh	r3,-4(fp)
811443d4:	00a045f4 	movhi	r2,33047
811443d8:	10aa1504 	addi	r2,r2,-22444
811443dc:	180691ba 	slli	r3,r3,6
811443e0:	10c5883a 	add	r2,r2,r3
811443e4:	10800e04 	addi	r2,r2,56
811443e8:	10800017 	ldw	r2,0(r2)
811443ec:	10004526 	beq	r2,zero,81144504 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
811443f0:	e0ffff0f 	ldh	r3,-4(fp)
811443f4:	00a045f4 	movhi	r2,33047
811443f8:	10aa1504 	addi	r2,r2,-22444
811443fc:	180691ba 	slli	r3,r3,6
81144400:	10c5883a 	add	r2,r2,r3
81144404:	10800b04 	addi	r2,r2,44
81144408:	10800017 	ldw	r2,0(r2)
8114440c:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
81144410:	e0ffff0f 	ldh	r3,-4(fp)
81144414:	00a045f4 	movhi	r2,33047
81144418:	10aa1504 	addi	r2,r2,-22444
8114441c:	180691ba 	slli	r3,r3,6
81144420:	10c5883a 	add	r2,r2,r3
81144424:	10800a04 	addi	r2,r2,40
81144428:	10800017 	ldw	r2,0(r2)
8114442c:	1000071e 	bne	r2,zero,8114444c <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
81144430:	00a045f4 	movhi	r2,33047
81144434:	10aa0004 	addi	r2,r2,-22528
81144438:	10801317 	ldw	r2,76(r2)
8114443c:	e0fffe17 	ldw	r3,-8(fp)
81144440:	1885883a 	add	r2,r3,r2
81144444:	e0bffe15 	stw	r2,-8(fp)
81144448:	00001406 	br	8114449c <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
8114444c:	00a045f4 	movhi	r2,33047
81144450:	10aa0004 	addi	r2,r2,-22528
81144454:	10c01417 	ldw	r3,80(r2)
81144458:	e0bffe17 	ldw	r2,-8(fp)
8114445c:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
81144460:	e13fff0f 	ldh	r4,-4(fp)
81144464:	00a045f4 	movhi	r2,33047
81144468:	10aa1504 	addi	r2,r2,-22444
8114446c:	200891ba 	slli	r4,r4,6
81144470:	1105883a 	add	r2,r2,r4
81144474:	10800a04 	addi	r2,r2,40
81144478:	10800017 	ldw	r2,0(r2)
8114447c:	113fff84 	addi	r4,r2,-2
81144480:	00a045f4 	movhi	r2,33047
81144484:	10aa0004 	addi	r2,r2,-22528
81144488:	10800383 	ldbu	r2,14(r2)
8114448c:	10803fcc 	andi	r2,r2,255
81144490:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81144494:	1885883a 	add	r2,r3,r2
81144498:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
8114449c:	e0bffe17 	ldw	r2,-8(fp)
811444a0:	d0e0b017 	ldw	r3,-32064(gp)
811444a4:	180b883a 	mov	r5,r3
811444a8:	1009883a 	mov	r4,r2
811444ac:	11402800 	call	81140280 <Read_Sector_Data>
811444b0:	10001426 	beq	r2,zero,81144504 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
811444b4:	e0ffff0f 	ldh	r3,-4(fp)
811444b8:	00a045f4 	movhi	r2,33047
811444bc:	10aa1504 	addi	r2,r2,-22444
811444c0:	180691ba 	slli	r3,r3,6
811444c4:	10c5883a 	add	r2,r2,r3
811444c8:	10800c04 	addi	r2,r2,48
811444cc:	1080000b 	ldhu	r2,0(r2)
811444d0:	113fffcc 	andi	r4,r2,65535
811444d4:	2120001c 	xori	r4,r4,32768
811444d8:	21200004 	addi	r4,r4,-32768
811444dc:	e0bfff0f 	ldh	r2,-4(fp)
811444e0:	100691ba 	slli	r3,r2,6
811444e4:	00a045f4 	movhi	r2,33047
811444e8:	10aa1504 	addi	r2,r2,-22444
811444ec:	1885883a 	add	r2,r3,r2
811444f0:	100b883a 	mov	r5,r2
811444f4:	11409340 	call	81140934 <Write_File_Record_At_Offset>
811444f8:	10000226 	beq	r2,zero,81144504 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811444fc:	114022c0 	call	8114022c <Save_Modified_Sector>
81144500:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
81144504:	e0ffff0f 	ldh	r3,-4(fp)
81144508:	00a045f4 	movhi	r2,33047
8114450c:	10aa1504 	addi	r2,r2,-22444
81144510:	180691ba 	slli	r3,r3,6
81144514:	10c5883a 	add	r2,r2,r3
81144518:	10800f04 	addi	r2,r2,60
8114451c:	10000015 	stw	zero,0(r2)
			result = true;
81144520:	00800044 	movi	r2,1
81144524:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81144528:	e0bffd17 	ldw	r2,-12(fp)
}
8114452c:	e037883a 	mov	sp,fp
81144530:	dfc00117 	ldw	ra,4(sp)
81144534:	df000017 	ldw	fp,0(sp)
81144538:	dec00204 	addi	sp,sp,8
8114453c:	f800283a 	ret

81144540 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81144540:	defffa04 	addi	sp,sp,-24
81144544:	de00012e 	bgeu	sp,et,8114454c <altera_avalon_jtag_uart_read_fd+0xc>
81144548:	003b68fa 	trap	3
8114454c:	dfc00515 	stw	ra,20(sp)
81144550:	df000415 	stw	fp,16(sp)
81144554:	df000404 	addi	fp,sp,16
81144558:	e13ffd15 	stw	r4,-12(fp)
8114455c:	e17ffe15 	stw	r5,-8(fp)
81144560:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81144564:	e0bffd17 	ldw	r2,-12(fp)
81144568:	10800017 	ldw	r2,0(r2)
8114456c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
81144570:	e0bffc17 	ldw	r2,-16(fp)
81144574:	10c00a04 	addi	r3,r2,40
81144578:	e0bffd17 	ldw	r2,-12(fp)
8114457c:	10800217 	ldw	r2,8(r2)
81144580:	100f883a 	mov	r7,r2
81144584:	e1bfff17 	ldw	r6,-4(fp)
81144588:	e17ffe17 	ldw	r5,-8(fp)
8114458c:	1809883a 	mov	r4,r3
81144590:	1144dc40 	call	81144dc4 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81144594:	e037883a 	mov	sp,fp
81144598:	dfc00117 	ldw	ra,4(sp)
8114459c:	df000017 	ldw	fp,0(sp)
811445a0:	dec00204 	addi	sp,sp,8
811445a4:	f800283a 	ret

811445a8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811445a8:	defffa04 	addi	sp,sp,-24
811445ac:	de00012e 	bgeu	sp,et,811445b4 <altera_avalon_jtag_uart_write_fd+0xc>
811445b0:	003b68fa 	trap	3
811445b4:	dfc00515 	stw	ra,20(sp)
811445b8:	df000415 	stw	fp,16(sp)
811445bc:	df000404 	addi	fp,sp,16
811445c0:	e13ffd15 	stw	r4,-12(fp)
811445c4:	e17ffe15 	stw	r5,-8(fp)
811445c8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811445cc:	e0bffd17 	ldw	r2,-12(fp)
811445d0:	10800017 	ldw	r2,0(r2)
811445d4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
811445d8:	e0bffc17 	ldw	r2,-16(fp)
811445dc:	10c00a04 	addi	r3,r2,40
811445e0:	e0bffd17 	ldw	r2,-12(fp)
811445e4:	10800217 	ldw	r2,8(r2)
811445e8:	100f883a 	mov	r7,r2
811445ec:	e1bfff17 	ldw	r6,-4(fp)
811445f0:	e17ffe17 	ldw	r5,-8(fp)
811445f4:	1809883a 	mov	r4,r3
811445f8:	11450880 	call	81145088 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811445fc:	e037883a 	mov	sp,fp
81144600:	dfc00117 	ldw	ra,4(sp)
81144604:	df000017 	ldw	fp,0(sp)
81144608:	dec00204 	addi	sp,sp,8
8114460c:	f800283a 	ret

81144610 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
81144610:	defffc04 	addi	sp,sp,-16
81144614:	de00012e 	bgeu	sp,et,8114461c <altera_avalon_jtag_uart_close_fd+0xc>
81144618:	003b68fa 	trap	3
8114461c:	dfc00315 	stw	ra,12(sp)
81144620:	df000215 	stw	fp,8(sp)
81144624:	df000204 	addi	fp,sp,8
81144628:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
8114462c:	e0bfff17 	ldw	r2,-4(fp)
81144630:	10800017 	ldw	r2,0(r2)
81144634:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81144638:	e0bffe17 	ldw	r2,-8(fp)
8114463c:	10c00a04 	addi	r3,r2,40
81144640:	e0bfff17 	ldw	r2,-4(fp)
81144644:	10800217 	ldw	r2,8(r2)
81144648:	100b883a 	mov	r5,r2
8114464c:	1809883a 	mov	r4,r3
81144650:	1144c5c0 	call	81144c5c <altera_avalon_jtag_uart_close>
}
81144654:	e037883a 	mov	sp,fp
81144658:	dfc00117 	ldw	ra,4(sp)
8114465c:	df000017 	ldw	fp,0(sp)
81144660:	dec00204 	addi	sp,sp,8
81144664:	f800283a 	ret

81144668 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81144668:	defffa04 	addi	sp,sp,-24
8114466c:	de00012e 	bgeu	sp,et,81144674 <altera_avalon_jtag_uart_ioctl_fd+0xc>
81144670:	003b68fa 	trap	3
81144674:	dfc00515 	stw	ra,20(sp)
81144678:	df000415 	stw	fp,16(sp)
8114467c:	df000404 	addi	fp,sp,16
81144680:	e13ffd15 	stw	r4,-12(fp)
81144684:	e17ffe15 	stw	r5,-8(fp)
81144688:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
8114468c:	e0bffd17 	ldw	r2,-12(fp)
81144690:	10800017 	ldw	r2,0(r2)
81144694:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81144698:	e0bffc17 	ldw	r2,-16(fp)
8114469c:	10800a04 	addi	r2,r2,40
811446a0:	e1bfff17 	ldw	r6,-4(fp)
811446a4:	e17ffe17 	ldw	r5,-8(fp)
811446a8:	1009883a 	mov	r4,r2
811446ac:	1144ccc0 	call	81144ccc <altera_avalon_jtag_uart_ioctl>
}
811446b0:	e037883a 	mov	sp,fp
811446b4:	dfc00117 	ldw	ra,4(sp)
811446b8:	df000017 	ldw	fp,0(sp)
811446bc:	dec00204 	addi	sp,sp,8
811446c0:	f800283a 	ret

811446c4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
811446c4:	deffef04 	addi	sp,sp,-68
811446c8:	de00012e 	bgeu	sp,et,811446d0 <altera_avalon_jtag_uart_init+0xc>
811446cc:	003b68fa 	trap	3
811446d0:	dfc01015 	stw	ra,64(sp)
811446d4:	df000f15 	stw	fp,60(sp)
811446d8:	dc400e15 	stw	r17,56(sp)
811446dc:	dc000d15 	stw	r16,52(sp)
811446e0:	df000f04 	addi	fp,sp,60
811446e4:	e13ff715 	stw	r4,-36(fp)
811446e8:	e17ff815 	stw	r5,-32(fp)
811446ec:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811446f0:	e0bff717 	ldw	r2,-36(fp)
811446f4:	10800c04 	addi	r2,r2,48
811446f8:	e0bff215 	stw	r2,-56(fp)
811446fc:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
81144700:	e0bff60b 	ldhu	r2,-40(fp)
81144704:	e0fff684 	addi	r3,fp,-38
81144708:	180b883a 	mov	r5,r3
8114470c:	1009883a 	mov	r4,r2
81144710:	11388940 	call	81138894 <OSFlagCreate>
81144714:	1007883a 	mov	r3,r2
81144718:	e0bff217 	ldw	r2,-56(fp)
8114471c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
81144720:	e0bff717 	ldw	r2,-36(fp)
81144724:	10800a04 	addi	r2,r2,40
81144728:	e0bff315 	stw	r2,-52(fp)
8114472c:	00800044 	movi	r2,1
81144730:	e0bff58d 	sth	r2,-42(fp)
81144734:	e0bff58b 	ldhu	r2,-42(fp)
81144738:	1009883a 	mov	r4,r2
8114473c:	113c7f00 	call	8113c7f0 <OSSemCreate>
81144740:	1007883a 	mov	r3,r2
81144744:	e0bff317 	ldw	r2,-52(fp)
81144748:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
8114474c:	e0bff717 	ldw	r2,-36(fp)
81144750:	10800b04 	addi	r2,r2,44
81144754:	e0bff415 	stw	r2,-48(fp)
81144758:	00800044 	movi	r2,1
8114475c:	e0bff50d 	sth	r2,-44(fp)
81144760:	e0bff50b 	ldhu	r2,-44(fp)
81144764:	1009883a 	mov	r4,r2
81144768:	113c7f00 	call	8113c7f0 <OSSemCreate>
8114476c:	1007883a 	mov	r3,r2
81144770:	e0bff417 	ldw	r2,-48(fp)
81144774:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81144778:	e0bff717 	ldw	r2,-36(fp)
8114477c:	00c00044 	movi	r3,1
81144780:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81144784:	e0bff717 	ldw	r2,-36(fp)
81144788:	10800017 	ldw	r2,0(r2)
8114478c:	10800104 	addi	r2,r2,4
81144790:	1007883a 	mov	r3,r2
81144794:	e0bff717 	ldw	r2,-36(fp)
81144798:	10800817 	ldw	r2,32(r2)
8114479c:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
811447a0:	e0bff817 	ldw	r2,-32(fp)
811447a4:	e0fff917 	ldw	r3,-28(fp)
811447a8:	d8000015 	stw	zero,0(sp)
811447ac:	e1fff717 	ldw	r7,-36(fp)
811447b0:	01a04534 	movhi	r6,33044
811447b4:	31922504 	addi	r6,r6,18580
811447b8:	180b883a 	mov	r5,r3
811447bc:	1009883a 	mov	r4,r2
811447c0:	11485dc0 	call	811485dc <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
811447c4:	e0bff717 	ldw	r2,-36(fp)
811447c8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
811447cc:	e0bff717 	ldw	r2,-36(fp)
811447d0:	10800204 	addi	r2,r2,8
811447d4:	d0e08717 	ldw	r3,-32228(gp)
811447d8:	e1fff717 	ldw	r7,-36(fp)
811447dc:	01a04534 	movhi	r6,33044
811447e0:	3192d404 	addi	r6,r6,19280
811447e4:	180b883a 	mov	r5,r3
811447e8:	1009883a 	mov	r4,r2
811447ec:	114812c0 	call	8114812c <alt_alarm_start>
811447f0:	1000040e 	bge	r2,zero,81144804 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811447f4:	e0fff717 	ldw	r3,-36(fp)
811447f8:	00a00034 	movhi	r2,32768
811447fc:	10bfffc4 	addi	r2,r2,-1
81144800:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
81144804:	d0a08083 	ldbu	r2,-32254(gp)
81144808:	10803fcc 	andi	r2,r2,255
8114480c:	10800058 	cmpnei	r2,r2,1
81144810:	10000f1e 	bne	r2,zero,81144850 <altera_avalon_jtag_uart_init+0x18c>
81144814:	d0e08717 	ldw	r3,-32228(gp)
81144818:	00b33374 	movhi	r2,52429
8114481c:	10b33344 	addi	r2,r2,-13107
81144820:	1888383a 	mulxuu	r4,r3,r2
81144824:	1885383a 	mul	r2,r3,r2
81144828:	1021883a 	mov	r16,r2
8114482c:	2023883a 	mov	r17,r4
81144830:	8804d0fa 	srli	r2,r17,3
81144834:	e1fff717 	ldw	r7,-36(fp)
81144838:	01a044f4 	movhi	r6,33043
8114483c:	3193f104 	addi	r6,r6,20420
81144840:	100b883a 	mov	r5,r2
81144844:	012045b4 	movhi	r4,33046
81144848:	2111d404 	addi	r4,r4,18256
8114484c:	114812c0 	call	8114812c <alt_alarm_start>
81144850:	d0a08103 	ldbu	r2,-32252(gp)
81144854:	10803fcc 	andi	r2,r2,255
81144858:	10800058 	cmpnei	r2,r2,1
8114485c:	1000051e 	bne	r2,zero,81144874 <altera_avalon_jtag_uart_init+0x1b0>
81144860:	e0bff717 	ldw	r2,-36(fp)
81144864:	10800017 	ldw	r2,0(r2)
81144868:	100b883a 	mov	r5,r2
8114486c:	e13ff717 	ldw	r4,-36(fp)
81144870:	113515c0 	call	8113515c <alt_log_jtag_uart_startup_info>
}
81144874:	0001883a 	nop
81144878:	e6fffe04 	addi	sp,fp,-8
8114487c:	dfc00317 	ldw	ra,12(sp)
81144880:	df000217 	ldw	fp,8(sp)
81144884:	dc400117 	ldw	r17,4(sp)
81144888:	dc000017 	ldw	r16,0(sp)
8114488c:	dec00404 	addi	sp,sp,16
81144890:	f800283a 	ret

81144894 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81144894:	defff204 	addi	sp,sp,-56
81144898:	de00012e 	bgeu	sp,et,811448a0 <altera_avalon_jtag_uart_irq+0xc>
8114489c:	003b68fa 	trap	3
811448a0:	dfc00d15 	stw	ra,52(sp)
811448a4:	df000c15 	stw	fp,48(sp)
811448a8:	df000c04 	addi	fp,sp,48
811448ac:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
811448b0:	e0bfff17 	ldw	r2,-4(fp)
811448b4:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
811448b8:	e0bff617 	ldw	r2,-40(fp)
811448bc:	10800017 	ldw	r2,0(r2)
811448c0:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
811448c4:	e0bff717 	ldw	r2,-36(fp)
811448c8:	e17ff617 	ldw	r5,-40(fp)
811448cc:	1009883a 	mov	r4,r2
811448d0:	11351b00 	call	811351b0 <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811448d4:	e0bff717 	ldw	r2,-36(fp)
811448d8:	10800104 	addi	r2,r2,4
811448dc:	10800037 	ldwio	r2,0(r2)
811448e0:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
811448e4:	e0bff817 	ldw	r2,-32(fp)
811448e8:	1080c00c 	andi	r2,r2,768
811448ec:	10009126 	beq	r2,zero,81144b34 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
811448f0:	e0bff817 	ldw	r2,-32(fp)
811448f4:	1080400c 	andi	r2,r2,256
811448f8:	10004726 	beq	r2,zero,81144a18 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811448fc:	00800074 	movhi	r2,1
81144900:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81144904:	e0bff617 	ldw	r2,-40(fp)
81144908:	10800d17 	ldw	r2,52(r2)
8114490c:	10800044 	addi	r2,r2,1
81144910:	1081ffcc 	andi	r2,r2,2047
81144914:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
81144918:	e0bff617 	ldw	r2,-40(fp)
8114491c:	10c00e17 	ldw	r3,56(r2)
81144920:	e0bff917 	ldw	r2,-28(fp)
81144924:	18802726 	beq	r3,r2,811449c4 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81144928:	e0bff717 	ldw	r2,-36(fp)
8114492c:	10800037 	ldwio	r2,0(r2)
81144930:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81144934:	e0bff417 	ldw	r2,-48(fp)
81144938:	10a0000c 	andi	r2,r2,32768
8114493c:	10002326 	beq	r2,zero,811449cc <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
81144940:	e0bff617 	ldw	r2,-40(fp)
81144944:	10800d17 	ldw	r2,52(r2)
81144948:	e0fff417 	ldw	r3,-48(fp)
8114494c:	1809883a 	mov	r4,r3
81144950:	e0fff617 	ldw	r3,-40(fp)
81144954:	1885883a 	add	r2,r3,r2
81144958:	10801104 	addi	r2,r2,68
8114495c:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81144960:	e0bff617 	ldw	r2,-40(fp)
81144964:	10800d17 	ldw	r2,52(r2)
81144968:	10800044 	addi	r2,r2,1
8114496c:	10c1ffcc 	andi	r3,r2,2047
81144970:	e0bff617 	ldw	r2,-40(fp)
81144974:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81144978:	e0bff617 	ldw	r2,-40(fp)
8114497c:	10800c17 	ldw	r2,48(r2)
81144980:	e0bffb15 	stw	r2,-20(fp)
81144984:	00800044 	movi	r2,1
81144988:	e0bffc0d 	sth	r2,-16(fp)
8114498c:	00800044 	movi	r2,1
81144990:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81144994:	d0a09003 	ldbu	r2,-32192(gp)
81144998:	10803fcc 	andi	r2,r2,255
8114499c:	103fd926 	beq	r2,zero,81144904 <__reset+0xfb124904>
  {
    OSFlagPost (group, flags, opt, &err);
811449a0:	e0bffc0b 	ldhu	r2,-16(fp)
811449a4:	e0fffc83 	ldbu	r3,-14(fp)
811449a8:	e13ffdc4 	addi	r4,fp,-9
811449ac:	200f883a 	mov	r7,r4
811449b0:	180d883a 	mov	r6,r3
811449b4:	100b883a 	mov	r5,r2
811449b8:	e13ffb17 	ldw	r4,-20(fp)
811449bc:	11394a00 	call	811394a0 <OSFlagPost>
      }
811449c0:	003fd006 	br	81144904 <__reset+0xfb124904>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
811449c4:	0001883a 	nop
811449c8:	00000106 	br	811449d0 <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
811449cc:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
811449d0:	e0bff417 	ldw	r2,-48(fp)
811449d4:	10bfffec 	andhi	r2,r2,65535
811449d8:	10000f26 	beq	r2,zero,81144a18 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811449dc:	e0bff617 	ldw	r2,-40(fp)
811449e0:	10c00817 	ldw	r3,32(r2)
811449e4:	00bfff84 	movi	r2,-2
811449e8:	1886703a 	and	r3,r3,r2
811449ec:	e0bff617 	ldw	r2,-40(fp)
811449f0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811449f4:	e0bff717 	ldw	r2,-36(fp)
811449f8:	10800104 	addi	r2,r2,4
811449fc:	1007883a 	mov	r3,r2
81144a00:	e0bff617 	ldw	r2,-40(fp)
81144a04:	10800817 	ldw	r2,32(r2)
81144a08:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81144a0c:	e0bff717 	ldw	r2,-36(fp)
81144a10:	10800104 	addi	r2,r2,4
81144a14:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
81144a18:	e0bff817 	ldw	r2,-32(fp)
81144a1c:	1080800c 	andi	r2,r2,512
81144a20:	103fac26 	beq	r2,zero,811448d4 <__reset+0xfb1248d4>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81144a24:	e0bff817 	ldw	r2,-32(fp)
81144a28:	1004d43a 	srli	r2,r2,16
81144a2c:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81144a30:	00002606 	br	81144acc <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81144a34:	e0bff717 	ldw	r2,-36(fp)
81144a38:	e0fff617 	ldw	r3,-40(fp)
81144a3c:	18c01017 	ldw	r3,64(r3)
81144a40:	e13ff617 	ldw	r4,-40(fp)
81144a44:	20c7883a 	add	r3,r4,r3
81144a48:	18c21104 	addi	r3,r3,2116
81144a4c:	18c00003 	ldbu	r3,0(r3)
81144a50:	18c03fcc 	andi	r3,r3,255
81144a54:	18c0201c 	xori	r3,r3,128
81144a58:	18ffe004 	addi	r3,r3,-128
81144a5c:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81144a60:	e0bff617 	ldw	r2,-40(fp)
81144a64:	10801017 	ldw	r2,64(r2)
81144a68:	10800044 	addi	r2,r2,1
81144a6c:	10c1ffcc 	andi	r3,r2,2047
81144a70:	e0bff617 	ldw	r2,-40(fp)
81144a74:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81144a78:	e0bff617 	ldw	r2,-40(fp)
81144a7c:	10800c17 	ldw	r2,48(r2)
81144a80:	e0bffa15 	stw	r2,-24(fp)
81144a84:	00800084 	movi	r2,2
81144a88:	e0bffd0d 	sth	r2,-12(fp)
81144a8c:	00800044 	movi	r2,1
81144a90:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81144a94:	d0a09003 	ldbu	r2,-32192(gp)
81144a98:	10803fcc 	andi	r2,r2,255
81144a9c:	10000826 	beq	r2,zero,81144ac0 <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81144aa0:	e0bffd0b 	ldhu	r2,-12(fp)
81144aa4:	e0fffd83 	ldbu	r3,-10(fp)
81144aa8:	e13ffe04 	addi	r4,fp,-8
81144aac:	200f883a 	mov	r7,r4
81144ab0:	180d883a 	mov	r6,r3
81144ab4:	100b883a 	mov	r5,r2
81144ab8:	e13ffa17 	ldw	r4,-24(fp)
81144abc:	11394a00 	call	811394a0 <OSFlagPost>

        space--;
81144ac0:	e0bff517 	ldw	r2,-44(fp)
81144ac4:	10bfffc4 	addi	r2,r2,-1
81144ac8:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81144acc:	e0bff517 	ldw	r2,-44(fp)
81144ad0:	10000526 	beq	r2,zero,81144ae8 <altera_avalon_jtag_uart_irq+0x254>
81144ad4:	e0bff617 	ldw	r2,-40(fp)
81144ad8:	10c01017 	ldw	r3,64(r2)
81144adc:	e0bff617 	ldw	r2,-40(fp)
81144ae0:	10800f17 	ldw	r2,60(r2)
81144ae4:	18bfd31e 	bne	r3,r2,81144a34 <__reset+0xfb124a34>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81144ae8:	e0bff517 	ldw	r2,-44(fp)
81144aec:	103f7926 	beq	r2,zero,811448d4 <__reset+0xfb1248d4>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81144af0:	e0bff617 	ldw	r2,-40(fp)
81144af4:	10c00817 	ldw	r3,32(r2)
81144af8:	00bfff44 	movi	r2,-3
81144afc:	1886703a 	and	r3,r3,r2
81144b00:	e0bff617 	ldw	r2,-40(fp)
81144b04:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81144b08:	e0bff617 	ldw	r2,-40(fp)
81144b0c:	10800017 	ldw	r2,0(r2)
81144b10:	10800104 	addi	r2,r2,4
81144b14:	1007883a 	mov	r3,r2
81144b18:	e0bff617 	ldw	r2,-40(fp)
81144b1c:	10800817 	ldw	r2,32(r2)
81144b20:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81144b24:	e0bff717 	ldw	r2,-36(fp)
81144b28:	10800104 	addi	r2,r2,4
81144b2c:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81144b30:	003f6806 	br	811448d4 <__reset+0xfb1248d4>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81144b34:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81144b38:	0001883a 	nop
81144b3c:	e037883a 	mov	sp,fp
81144b40:	dfc00117 	ldw	ra,4(sp)
81144b44:	df000017 	ldw	fp,0(sp)
81144b48:	dec00204 	addi	sp,sp,8
81144b4c:	f800283a 	ret

81144b50 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81144b50:	defff904 	addi	sp,sp,-28
81144b54:	de00012e 	bgeu	sp,et,81144b5c <altera_avalon_jtag_uart_timeout+0xc>
81144b58:	003b68fa 	trap	3
81144b5c:	dfc00615 	stw	ra,24(sp)
81144b60:	df000515 	stw	fp,20(sp)
81144b64:	df000504 	addi	fp,sp,20
81144b68:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81144b6c:	e0bfff17 	ldw	r2,-4(fp)
81144b70:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81144b74:	e0bffb17 	ldw	r2,-20(fp)
81144b78:	10800017 	ldw	r2,0(r2)
81144b7c:	10800104 	addi	r2,r2,4
81144b80:	10800037 	ldwio	r2,0(r2)
81144b84:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81144b88:	e0bffc17 	ldw	r2,-16(fp)
81144b8c:	1081000c 	andi	r2,r2,1024
81144b90:	10000b26 	beq	r2,zero,81144bc0 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81144b94:	e0bffb17 	ldw	r2,-20(fp)
81144b98:	10800017 	ldw	r2,0(r2)
81144b9c:	10800104 	addi	r2,r2,4
81144ba0:	1007883a 	mov	r3,r2
81144ba4:	e0bffb17 	ldw	r2,-20(fp)
81144ba8:	10800817 	ldw	r2,32(r2)
81144bac:	10810014 	ori	r2,r2,1024
81144bb0:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81144bb4:	e0bffb17 	ldw	r2,-20(fp)
81144bb8:	10000915 	stw	zero,36(r2)
81144bbc:	00002106 	br	81144c44 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81144bc0:	e0bffb17 	ldw	r2,-20(fp)
81144bc4:	10c00917 	ldw	r3,36(r2)
81144bc8:	00a00034 	movhi	r2,32768
81144bcc:	10bfff04 	addi	r2,r2,-4
81144bd0:	10c01c36 	bltu	r2,r3,81144c44 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81144bd4:	e0bffb17 	ldw	r2,-20(fp)
81144bd8:	10800917 	ldw	r2,36(r2)
81144bdc:	10c00044 	addi	r3,r2,1
81144be0:	e0bffb17 	ldw	r2,-20(fp)
81144be4:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81144be8:	e0bffb17 	ldw	r2,-20(fp)
81144bec:	10c00917 	ldw	r3,36(r2)
81144bf0:	e0bffb17 	ldw	r2,-20(fp)
81144bf4:	10800117 	ldw	r2,4(r2)
81144bf8:	18801236 	bltu	r3,r2,81144c44 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81144bfc:	e0bffb17 	ldw	r2,-20(fp)
81144c00:	10800c17 	ldw	r2,48(r2)
81144c04:	e0bffd15 	stw	r2,-12(fp)
81144c08:	00800104 	movi	r2,4
81144c0c:	e0bffe0d 	sth	r2,-8(fp)
81144c10:	00800044 	movi	r2,1
81144c14:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81144c18:	d0a09003 	ldbu	r2,-32192(gp)
81144c1c:	10803fcc 	andi	r2,r2,255
81144c20:	10000826 	beq	r2,zero,81144c44 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81144c24:	e0bffe0b 	ldhu	r2,-8(fp)
81144c28:	e0fffe83 	ldbu	r3,-6(fp)
81144c2c:	e13ffec4 	addi	r4,fp,-5
81144c30:	200f883a 	mov	r7,r4
81144c34:	180d883a 	mov	r6,r3
81144c38:	100b883a 	mov	r5,r2
81144c3c:	e13ffd17 	ldw	r4,-12(fp)
81144c40:	11394a00 	call	811394a0 <OSFlagPost>
81144c44:	d0a08717 	ldw	r2,-32228(gp)
    }
  }

  return alt_ticks_per_second();
}
81144c48:	e037883a 	mov	sp,fp
81144c4c:	dfc00117 	ldw	ra,4(sp)
81144c50:	df000017 	ldw	fp,0(sp)
81144c54:	dec00204 	addi	sp,sp,8
81144c58:	f800283a 	ret

81144c5c <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81144c5c:	defffd04 	addi	sp,sp,-12
81144c60:	de00012e 	bgeu	sp,et,81144c68 <altera_avalon_jtag_uart_close+0xc>
81144c64:	003b68fa 	trap	3
81144c68:	df000215 	stw	fp,8(sp)
81144c6c:	df000204 	addi	fp,sp,8
81144c70:	e13ffe15 	stw	r4,-8(fp)
81144c74:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81144c78:	00000506 	br	81144c90 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81144c7c:	e0bfff17 	ldw	r2,-4(fp)
81144c80:	1090000c 	andi	r2,r2,16384
81144c84:	10000226 	beq	r2,zero,81144c90 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81144c88:	00bffd44 	movi	r2,-11
81144c8c:	00000b06 	br	81144cbc <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81144c90:	e0bffe17 	ldw	r2,-8(fp)
81144c94:	10c01017 	ldw	r3,64(r2)
81144c98:	e0bffe17 	ldw	r2,-8(fp)
81144c9c:	10800f17 	ldw	r2,60(r2)
81144ca0:	18800526 	beq	r3,r2,81144cb8 <altera_avalon_jtag_uart_close+0x5c>
81144ca4:	e0bffe17 	ldw	r2,-8(fp)
81144ca8:	10c00917 	ldw	r3,36(r2)
81144cac:	e0bffe17 	ldw	r2,-8(fp)
81144cb0:	10800117 	ldw	r2,4(r2)
81144cb4:	18bff136 	bltu	r3,r2,81144c7c <__reset+0xfb124c7c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81144cb8:	0005883a 	mov	r2,zero
}
81144cbc:	e037883a 	mov	sp,fp
81144cc0:	df000017 	ldw	fp,0(sp)
81144cc4:	dec00104 	addi	sp,sp,4
81144cc8:	f800283a 	ret

81144ccc <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81144ccc:	defffa04 	addi	sp,sp,-24
81144cd0:	de00012e 	bgeu	sp,et,81144cd8 <altera_avalon_jtag_uart_ioctl+0xc>
81144cd4:	003b68fa 	trap	3
81144cd8:	df000515 	stw	fp,20(sp)
81144cdc:	df000504 	addi	fp,sp,20
81144ce0:	e13ffd15 	stw	r4,-12(fp)
81144ce4:	e17ffe15 	stw	r5,-8(fp)
81144ce8:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81144cec:	00bff9c4 	movi	r2,-25
81144cf0:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81144cf4:	e0bffe17 	ldw	r2,-8(fp)
81144cf8:	10da8060 	cmpeqi	r3,r2,27137
81144cfc:	1800031e 	bne	r3,zero,81144d0c <altera_avalon_jtag_uart_ioctl+0x40>
81144d00:	109a80a0 	cmpeqi	r2,r2,27138
81144d04:	1000181e 	bne	r2,zero,81144d68 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81144d08:	00002906 	br	81144db0 <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81144d0c:	e0bffd17 	ldw	r2,-12(fp)
81144d10:	10c00117 	ldw	r3,4(r2)
81144d14:	00a00034 	movhi	r2,32768
81144d18:	10bfffc4 	addi	r2,r2,-1
81144d1c:	18802126 	beq	r3,r2,81144da4 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81144d20:	e0bfff17 	ldw	r2,-4(fp)
81144d24:	10800017 	ldw	r2,0(r2)
81144d28:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81144d2c:	e0bffc17 	ldw	r2,-16(fp)
81144d30:	10800090 	cmplti	r2,r2,2
81144d34:	1000061e 	bne	r2,zero,81144d50 <altera_avalon_jtag_uart_ioctl+0x84>
81144d38:	e0fffc17 	ldw	r3,-16(fp)
81144d3c:	00a00034 	movhi	r2,32768
81144d40:	10bfffc4 	addi	r2,r2,-1
81144d44:	18800226 	beq	r3,r2,81144d50 <altera_avalon_jtag_uart_ioctl+0x84>
81144d48:	e0bffc17 	ldw	r2,-16(fp)
81144d4c:	00000206 	br	81144d58 <altera_avalon_jtag_uart_ioctl+0x8c>
81144d50:	00a00034 	movhi	r2,32768
81144d54:	10bfff84 	addi	r2,r2,-2
81144d58:	e0fffd17 	ldw	r3,-12(fp)
81144d5c:	18800115 	stw	r2,4(r3)
      rc = 0;
81144d60:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81144d64:	00000f06 	br	81144da4 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81144d68:	e0bffd17 	ldw	r2,-12(fp)
81144d6c:	10c00117 	ldw	r3,4(r2)
81144d70:	00a00034 	movhi	r2,32768
81144d74:	10bfffc4 	addi	r2,r2,-1
81144d78:	18800c26 	beq	r3,r2,81144dac <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81144d7c:	e0bffd17 	ldw	r2,-12(fp)
81144d80:	10c00917 	ldw	r3,36(r2)
81144d84:	e0bffd17 	ldw	r2,-12(fp)
81144d88:	10800117 	ldw	r2,4(r2)
81144d8c:	1885803a 	cmpltu	r2,r3,r2
81144d90:	10c03fcc 	andi	r3,r2,255
81144d94:	e0bfff17 	ldw	r2,-4(fp)
81144d98:	10c00015 	stw	r3,0(r2)
      rc = 0;
81144d9c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81144da0:	00000206 	br	81144dac <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81144da4:	0001883a 	nop
81144da8:	00000106 	br	81144db0 <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81144dac:	0001883a 	nop

  default:
    break;
  }

  return rc;
81144db0:	e0bffb17 	ldw	r2,-20(fp)
}
81144db4:	e037883a 	mov	sp,fp
81144db8:	df000017 	ldw	fp,0(sp)
81144dbc:	dec00104 	addi	sp,sp,4
81144dc0:	f800283a 	ret

81144dc4 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81144dc4:	deffed04 	addi	sp,sp,-76
81144dc8:	de00012e 	bgeu	sp,et,81144dd0 <altera_avalon_jtag_uart_read+0xc>
81144dcc:	003b68fa 	trap	3
81144dd0:	dfc01215 	stw	ra,72(sp)
81144dd4:	df001115 	stw	fp,68(sp)
81144dd8:	df001104 	addi	fp,sp,68
81144ddc:	e13ffc15 	stw	r4,-16(fp)
81144de0:	e17ffd15 	stw	r5,-12(fp)
81144de4:	e1bffe15 	stw	r6,-8(fp)
81144de8:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81144dec:	e0bffd17 	ldw	r2,-12(fp)
81144df0:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81144df4:	e0bffc17 	ldw	r2,-16(fp)
81144df8:	10800a17 	ldw	r2,40(r2)
81144dfc:	e0bff815 	stw	r2,-32(fp)
81144e00:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81144e04:	e0bff90b 	ldhu	r2,-28(fp)
81144e08:	e0fffb04 	addi	r3,fp,-20
81144e0c:	180d883a 	mov	r6,r3
81144e10:	100b883a 	mov	r5,r2
81144e14:	e13ff817 	ldw	r4,-32(fp)
81144e18:	113cb180 	call	8113cb18 <OSSemPend>

  while (space > 0)
81144e1c:	00006106 	br	81144fa4 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81144e20:	e0bffc17 	ldw	r2,-16(fp)
81144e24:	10800d17 	ldw	r2,52(r2)
81144e28:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81144e2c:	e0bffc17 	ldw	r2,-16(fp)
81144e30:	10800e17 	ldw	r2,56(r2)
81144e34:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81144e38:	e0fff317 	ldw	r3,-52(fp)
81144e3c:	e0bff417 	ldw	r2,-48(fp)
81144e40:	18800536 	bltu	r3,r2,81144e58 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81144e44:	e0fff317 	ldw	r3,-52(fp)
81144e48:	e0bff417 	ldw	r2,-48(fp)
81144e4c:	1885c83a 	sub	r2,r3,r2
81144e50:	e0bff115 	stw	r2,-60(fp)
81144e54:	00000406 	br	81144e68 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81144e58:	00c20004 	movi	r3,2048
81144e5c:	e0bff417 	ldw	r2,-48(fp)
81144e60:	1885c83a 	sub	r2,r3,r2
81144e64:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81144e68:	e0bff117 	ldw	r2,-60(fp)
81144e6c:	10001e26 	beq	r2,zero,81144ee8 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81144e70:	e0fffe17 	ldw	r3,-8(fp)
81144e74:	e0bff117 	ldw	r2,-60(fp)
81144e78:	1880022e 	bgeu	r3,r2,81144e84 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81144e7c:	e0bffe17 	ldw	r2,-8(fp)
81144e80:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81144e84:	e0bffc17 	ldw	r2,-16(fp)
81144e88:	10c01104 	addi	r3,r2,68
81144e8c:	e0bff417 	ldw	r2,-48(fp)
81144e90:	1885883a 	add	r2,r3,r2
81144e94:	e1bff117 	ldw	r6,-60(fp)
81144e98:	100b883a 	mov	r5,r2
81144e9c:	e13ff017 	ldw	r4,-64(fp)
81144ea0:	11206ac0 	call	811206ac <memcpy>
      ptr   += n;
81144ea4:	e0fff017 	ldw	r3,-64(fp)
81144ea8:	e0bff117 	ldw	r2,-60(fp)
81144eac:	1885883a 	add	r2,r3,r2
81144eb0:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81144eb4:	e0fffe17 	ldw	r3,-8(fp)
81144eb8:	e0bff117 	ldw	r2,-60(fp)
81144ebc:	1885c83a 	sub	r2,r3,r2
81144ec0:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81144ec4:	e0fff417 	ldw	r3,-48(fp)
81144ec8:	e0bff117 	ldw	r2,-60(fp)
81144ecc:	1885883a 	add	r2,r3,r2
81144ed0:	10c1ffcc 	andi	r3,r2,2047
81144ed4:	e0bffc17 	ldw	r2,-16(fp)
81144ed8:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81144edc:	e0bffe17 	ldw	r2,-8(fp)
81144ee0:	00bfcf16 	blt	zero,r2,81144e20 <__reset+0xfb124e20>
81144ee4:	00000106 	br	81144eec <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81144ee8:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81144eec:	e0fff017 	ldw	r3,-64(fp)
81144ef0:	e0bffd17 	ldw	r2,-12(fp)
81144ef4:	18802e1e 	bne	r3,r2,81144fb0 <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81144ef8:	e0bfff17 	ldw	r2,-4(fp)
81144efc:	1090000c 	andi	r2,r2,16384
81144f00:	10002d1e 	bne	r2,zero,81144fb8 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81144f04:	d0a09003 	ldbu	r2,-32192(gp)
81144f08:	10803fcc 	andi	r2,r2,255
81144f0c:	10800058 	cmpnei	r2,r2,1
81144f10:	1000161e 	bne	r2,zero,81144f6c <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81144f14:	e0bffc17 	ldw	r2,-16(fp)
81144f18:	10800c17 	ldw	r2,48(r2)
81144f1c:	e0bff215 	stw	r2,-56(fp)
81144f20:	00800144 	movi	r2,5
81144f24:	e0bff98d 	sth	r2,-26(fp)
81144f28:	00bfe0c4 	movi	r2,-125
81144f2c:	e0bffa05 	stb	r2,-24(fp)
81144f30:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81144f34:	d0a09003 	ldbu	r2,-32192(gp)
81144f38:	10803fcc 	andi	r2,r2,255
81144f3c:	10001526 	beq	r2,zero,81144f94 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81144f40:	e0fff98b 	ldhu	r3,-26(fp)
81144f44:	e13ffa03 	ldbu	r4,-24(fp)
81144f48:	e17ffa8b 	ldhu	r5,-22(fp)
81144f4c:	e0bffb44 	addi	r2,fp,-19
81144f50:	d8800015 	stw	r2,0(sp)
81144f54:	280f883a 	mov	r7,r5
81144f58:	200d883a 	mov	r6,r4
81144f5c:	180b883a 	mov	r5,r3
81144f60:	e13ff217 	ldw	r4,-56(fp)
81144f64:	1138e780 	call	81138e78 <OSFlagPend>
81144f68:	00000a06 	br	81144f94 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81144f6c:	0001883a 	nop
81144f70:	e0bffc17 	ldw	r2,-16(fp)
81144f74:	10c00d17 	ldw	r3,52(r2)
81144f78:	e0bff317 	ldw	r2,-52(fp)
81144f7c:	1880051e 	bne	r3,r2,81144f94 <altera_avalon_jtag_uart_read+0x1d0>
81144f80:	e0bffc17 	ldw	r2,-16(fp)
81144f84:	10c00917 	ldw	r3,36(r2)
81144f88:	e0bffc17 	ldw	r2,-16(fp)
81144f8c:	10800117 	ldw	r2,4(r2)
81144f90:	18bff736 	bltu	r3,r2,81144f70 <__reset+0xfb124f70>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81144f94:	e0bffc17 	ldw	r2,-16(fp)
81144f98:	10c00d17 	ldw	r3,52(r2)
81144f9c:	e0bff317 	ldw	r2,-52(fp)
81144fa0:	18800726 	beq	r3,r2,81144fc0 <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81144fa4:	e0bffe17 	ldw	r2,-8(fp)
81144fa8:	00bf9d16 	blt	zero,r2,81144e20 <__reset+0xfb124e20>
81144fac:	00000506 	br	81144fc4 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81144fb0:	0001883a 	nop
81144fb4:	00000306 	br	81144fc4 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81144fb8:	0001883a 	nop
81144fbc:	00000106 	br	81144fc4 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81144fc0:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81144fc4:	e0bffc17 	ldw	r2,-16(fp)
81144fc8:	10800a17 	ldw	r2,40(r2)
81144fcc:	1009883a 	mov	r4,r2
81144fd0:	113cea00 	call	8113cea0 <OSSemPost>

  if (ptr != buffer)
81144fd4:	e0fff017 	ldw	r3,-64(fp)
81144fd8:	e0bffd17 	ldw	r2,-12(fp)
81144fdc:	18801826 	beq	r3,r2,81145040 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144fe0:	0005303a 	rdctl	r2,status
81144fe4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144fe8:	e0fff717 	ldw	r3,-36(fp)
81144fec:	00bfff84 	movi	r2,-2
81144ff0:	1884703a 	and	r2,r3,r2
81144ff4:	1001703a 	wrctl	status,r2
  
  return context;
81144ff8:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81144ffc:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81145000:	e0bffc17 	ldw	r2,-16(fp)
81145004:	10800817 	ldw	r2,32(r2)
81145008:	10c00054 	ori	r3,r2,1
8114500c:	e0bffc17 	ldw	r2,-16(fp)
81145010:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81145014:	e0bffc17 	ldw	r2,-16(fp)
81145018:	10800017 	ldw	r2,0(r2)
8114501c:	10800104 	addi	r2,r2,4
81145020:	1007883a 	mov	r3,r2
81145024:	e0bffc17 	ldw	r2,-16(fp)
81145028:	10800817 	ldw	r2,32(r2)
8114502c:	18800035 	stwio	r2,0(r3)
81145030:	e0bff617 	ldw	r2,-40(fp)
81145034:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145038:	e0bff517 	ldw	r2,-44(fp)
8114503c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
81145040:	e0fff017 	ldw	r3,-64(fp)
81145044:	e0bffd17 	ldw	r2,-12(fp)
81145048:	18800426 	beq	r3,r2,8114505c <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
8114504c:	e0fff017 	ldw	r3,-64(fp)
81145050:	e0bffd17 	ldw	r2,-12(fp)
81145054:	1885c83a 	sub	r2,r3,r2
81145058:	00000606 	br	81145074 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
8114505c:	e0bfff17 	ldw	r2,-4(fp)
81145060:	1090000c 	andi	r2,r2,16384
81145064:	10000226 	beq	r2,zero,81145070 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81145068:	00bffd44 	movi	r2,-11
8114506c:	00000106 	br	81145074 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
81145070:	00bffec4 	movi	r2,-5
}
81145074:	e037883a 	mov	sp,fp
81145078:	dfc00117 	ldw	ra,4(sp)
8114507c:	df000017 	ldw	fp,0(sp)
81145080:	dec00204 	addi	sp,sp,8
81145084:	f800283a 	ret

81145088 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81145088:	deffed04 	addi	sp,sp,-76
8114508c:	de00012e 	bgeu	sp,et,81145094 <altera_avalon_jtag_uart_write+0xc>
81145090:	003b68fa 	trap	3
81145094:	dfc01215 	stw	ra,72(sp)
81145098:	df001115 	stw	fp,68(sp)
8114509c:	df001104 	addi	fp,sp,68
811450a0:	e13ffc15 	stw	r4,-16(fp)
811450a4:	e17ffd15 	stw	r5,-12(fp)
811450a8:	e1bffe15 	stw	r6,-8(fp)
811450ac:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
811450b0:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
811450b4:	e0bffd17 	ldw	r2,-12(fp)
811450b8:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
811450bc:	e0bffc17 	ldw	r2,-16(fp)
811450c0:	10800b17 	ldw	r2,44(r2)
811450c4:	e0bff815 	stw	r2,-32(fp)
811450c8:	e03ff90d 	sth	zero,-28(fp)
811450cc:	e0bff90b 	ldhu	r2,-28(fp)
811450d0:	e0fffb44 	addi	r3,fp,-19
811450d4:	180d883a 	mov	r6,r3
811450d8:	100b883a 	mov	r5,r2
811450dc:	e13ff817 	ldw	r4,-32(fp)
811450e0:	113cb180 	call	8113cb18 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811450e4:	00003706 	br	811451c4 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
811450e8:	e0bffc17 	ldw	r2,-16(fp)
811450ec:	10800f17 	ldw	r2,60(r2)
811450f0:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811450f4:	e0bffc17 	ldw	r2,-16(fp)
811450f8:	10801017 	ldw	r2,64(r2)
811450fc:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
81145100:	e0fff417 	ldw	r3,-48(fp)
81145104:	e0bff017 	ldw	r2,-64(fp)
81145108:	1880062e 	bgeu	r3,r2,81145124 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
8114510c:	e0fff017 	ldw	r3,-64(fp)
81145110:	e0bff417 	ldw	r2,-48(fp)
81145114:	1885c83a 	sub	r2,r3,r2
81145118:	10bfffc4 	addi	r2,r2,-1
8114511c:	e0bff115 	stw	r2,-60(fp)
81145120:	00000b06 	br	81145150 <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81145124:	e0bff017 	ldw	r2,-64(fp)
81145128:	10000526 	beq	r2,zero,81145140 <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
8114512c:	00c20004 	movi	r3,2048
81145130:	e0bff417 	ldw	r2,-48(fp)
81145134:	1885c83a 	sub	r2,r3,r2
81145138:	e0bff115 	stw	r2,-60(fp)
8114513c:	00000406 	br	81145150 <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
81145140:	00c1ffc4 	movi	r3,2047
81145144:	e0bff417 	ldw	r2,-48(fp)
81145148:	1885c83a 	sub	r2,r3,r2
8114514c:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81145150:	e0bff117 	ldw	r2,-60(fp)
81145154:	10001e26 	beq	r2,zero,811451d0 <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81145158:	e0fffe17 	ldw	r3,-8(fp)
8114515c:	e0bff117 	ldw	r2,-60(fp)
81145160:	1880022e 	bgeu	r3,r2,8114516c <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81145164:	e0bffe17 	ldw	r2,-8(fp)
81145168:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
8114516c:	e0bffc17 	ldw	r2,-16(fp)
81145170:	10c21104 	addi	r3,r2,2116
81145174:	e0bff417 	ldw	r2,-48(fp)
81145178:	1885883a 	add	r2,r3,r2
8114517c:	e1bff117 	ldw	r6,-60(fp)
81145180:	e17ffd17 	ldw	r5,-12(fp)
81145184:	1009883a 	mov	r4,r2
81145188:	11206ac0 	call	811206ac <memcpy>
      ptr   += n;
8114518c:	e0fffd17 	ldw	r3,-12(fp)
81145190:	e0bff117 	ldw	r2,-60(fp)
81145194:	1885883a 	add	r2,r3,r2
81145198:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
8114519c:	e0fffe17 	ldw	r3,-8(fp)
811451a0:	e0bff117 	ldw	r2,-60(fp)
811451a4:	1885c83a 	sub	r2,r3,r2
811451a8:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811451ac:	e0fff417 	ldw	r3,-48(fp)
811451b0:	e0bff117 	ldw	r2,-60(fp)
811451b4:	1885883a 	add	r2,r3,r2
811451b8:	10c1ffcc 	andi	r3,r2,2047
811451bc:	e0bffc17 	ldw	r2,-16(fp)
811451c0:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811451c4:	e0bffe17 	ldw	r2,-8(fp)
811451c8:	00bfc716 	blt	zero,r2,811450e8 <__reset+0xfb1250e8>
811451cc:	00000106 	br	811451d4 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
811451d0:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811451d4:	0005303a 	rdctl	r2,status
811451d8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811451dc:	e0fff717 	ldw	r3,-36(fp)
811451e0:	00bfff84 	movi	r2,-2
811451e4:	1884703a 	and	r2,r3,r2
811451e8:	1001703a 	wrctl	status,r2
  
  return context;
811451ec:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811451f0:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811451f4:	e0bffc17 	ldw	r2,-16(fp)
811451f8:	10800817 	ldw	r2,32(r2)
811451fc:	10c00094 	ori	r3,r2,2
81145200:	e0bffc17 	ldw	r2,-16(fp)
81145204:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81145208:	e0bffc17 	ldw	r2,-16(fp)
8114520c:	10800017 	ldw	r2,0(r2)
81145210:	10800104 	addi	r2,r2,4
81145214:	1007883a 	mov	r3,r2
81145218:	e0bffc17 	ldw	r2,-16(fp)
8114521c:	10800817 	ldw	r2,32(r2)
81145220:	18800035 	stwio	r2,0(r3)
81145224:	e0bff617 	ldw	r2,-40(fp)
81145228:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114522c:	e0bff317 	ldw	r2,-52(fp)
81145230:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81145234:	e0bffe17 	ldw	r2,-8(fp)
81145238:	00802a0e 	bge	zero,r2,811452e4 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
8114523c:	e0bfff17 	ldw	r2,-4(fp)
81145240:	1090000c 	andi	r2,r2,16384
81145244:	10002a1e 	bne	r2,zero,811452f0 <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81145248:	d0a09003 	ldbu	r2,-32192(gp)
8114524c:	10803fcc 	andi	r2,r2,255
81145250:	10800058 	cmpnei	r2,r2,1
81145254:	1000161e 	bne	r2,zero,811452b0 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81145258:	e0bffc17 	ldw	r2,-16(fp)
8114525c:	10800c17 	ldw	r2,48(r2)
81145260:	e0bff515 	stw	r2,-44(fp)
81145264:	00800184 	movi	r2,6
81145268:	e0bff98d 	sth	r2,-26(fp)
8114526c:	00bfe0c4 	movi	r2,-125
81145270:	e0bffa05 	stb	r2,-24(fp)
81145274:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81145278:	d0a09003 	ldbu	r2,-32192(gp)
8114527c:	10803fcc 	andi	r2,r2,255
81145280:	10001526 	beq	r2,zero,811452d8 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81145284:	e0fff98b 	ldhu	r3,-26(fp)
81145288:	e13ffa03 	ldbu	r4,-24(fp)
8114528c:	e17ffa8b 	ldhu	r5,-22(fp)
81145290:	e0bffb04 	addi	r2,fp,-20
81145294:	d8800015 	stw	r2,0(sp)
81145298:	280f883a 	mov	r7,r5
8114529c:	200d883a 	mov	r6,r4
811452a0:	180b883a 	mov	r5,r3
811452a4:	e13ff517 	ldw	r4,-44(fp)
811452a8:	1138e780 	call	81138e78 <OSFlagPend>
811452ac:	00000a06 	br	811452d8 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
811452b0:	0001883a 	nop
811452b4:	e0bffc17 	ldw	r2,-16(fp)
811452b8:	10c01017 	ldw	r3,64(r2)
811452bc:	e0bff017 	ldw	r2,-64(fp)
811452c0:	1880051e 	bne	r3,r2,811452d8 <altera_avalon_jtag_uart_write+0x250>
811452c4:	e0bffc17 	ldw	r2,-16(fp)
811452c8:	10c00917 	ldw	r3,36(r2)
811452cc:	e0bffc17 	ldw	r2,-16(fp)
811452d0:	10800117 	ldw	r2,4(r2)
811452d4:	18bff736 	bltu	r3,r2,811452b4 <__reset+0xfb1252b4>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
811452d8:	e0bffc17 	ldw	r2,-16(fp)
811452dc:	10800917 	ldw	r2,36(r2)
811452e0:	1000051e 	bne	r2,zero,811452f8 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811452e4:	e0bffe17 	ldw	r2,-8(fp)
811452e8:	00bfb616 	blt	zero,r2,811451c4 <__reset+0xfb1251c4>
811452ec:	00000306 	br	811452fc <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811452f0:	0001883a 	nop
811452f4:	00000106 	br	811452fc <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811452f8:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811452fc:	e0bffc17 	ldw	r2,-16(fp)
81145300:	10800b17 	ldw	r2,44(r2)
81145304:	1009883a 	mov	r4,r2
81145308:	113cea00 	call	8113cea0 <OSSemPost>

  if (ptr != start)
8114530c:	e0fffd17 	ldw	r3,-12(fp)
81145310:	e0bff217 	ldw	r2,-56(fp)
81145314:	18800426 	beq	r3,r2,81145328 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
81145318:	e0fffd17 	ldw	r3,-12(fp)
8114531c:	e0bff217 	ldw	r2,-56(fp)
81145320:	1885c83a 	sub	r2,r3,r2
81145324:	00000606 	br	81145340 <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81145328:	e0bfff17 	ldw	r2,-4(fp)
8114532c:	1090000c 	andi	r2,r2,16384
81145330:	10000226 	beq	r2,zero,8114533c <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81145334:	00bffd44 	movi	r2,-11
81145338:	00000106 	br	81145340 <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
8114533c:	00bffec4 	movi	r2,-5
}
81145340:	e037883a 	mov	sp,fp
81145344:	dfc00117 	ldw	ra,4(sp)
81145348:	df000017 	ldw	fp,0(sp)
8114534c:	dec00204 	addi	sp,sp,8
81145350:	f800283a 	ret

81145354 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81145354:	defffa04 	addi	sp,sp,-24
81145358:	de00012e 	bgeu	sp,et,81145360 <alt_avalon_timer_sc_irq+0xc>
8114535c:	003b68fa 	trap	3
81145360:	dfc00515 	stw	ra,20(sp)
81145364:	df000415 	stw	fp,16(sp)
81145368:	df000404 	addi	fp,sp,16
8114536c:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
81145370:	0007883a 	mov	r3,zero
81145374:	e0bfff17 	ldw	r2,-4(fp)
81145378:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
8114537c:	e0bfff17 	ldw	r2,-4(fp)
81145380:	10800104 	addi	r2,r2,4
81145384:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81145388:	11353540 	call	81135354 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114538c:	0005303a 	rdctl	r2,status
81145390:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145394:	e0fffd17 	ldw	r3,-12(fp)
81145398:	00bfff84 	movi	r2,-2
8114539c:	1884703a 	and	r2,r3,r2
811453a0:	1001703a 	wrctl	status,r2
  
  return context;
811453a4:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
811453a8:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
811453ac:	1135c040 	call	81135c04 <alt_tick>
811453b0:	e0bffc17 	ldw	r2,-16(fp)
811453b4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811453b8:	e0bffe17 	ldw	r2,-8(fp)
811453bc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
811453c0:	0001883a 	nop
811453c4:	e037883a 	mov	sp,fp
811453c8:	dfc00117 	ldw	ra,4(sp)
811453cc:	df000017 	ldw	fp,0(sp)
811453d0:	dec00204 	addi	sp,sp,8
811453d4:	f800283a 	ret

811453d8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
811453d8:	defff804 	addi	sp,sp,-32
811453dc:	de00012e 	bgeu	sp,et,811453e4 <alt_avalon_timer_sc_init+0xc>
811453e0:	003b68fa 	trap	3
811453e4:	dfc00715 	stw	ra,28(sp)
811453e8:	df000615 	stw	fp,24(sp)
811453ec:	df000604 	addi	fp,sp,24
811453f0:	e13ffc15 	stw	r4,-16(fp)
811453f4:	e17ffd15 	stw	r5,-12(fp)
811453f8:	e1bffe15 	stw	r6,-8(fp)
811453fc:	e1ffff15 	stw	r7,-4(fp)
81145400:	e0bfff17 	ldw	r2,-4(fp)
81145404:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
81145408:	d0a08717 	ldw	r2,-32228(gp)
8114540c:	1000021e 	bne	r2,zero,81145418 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
81145410:	e0bffb17 	ldw	r2,-20(fp)
81145414:	d0a08715 	stw	r2,-32228(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
81145418:	e0bffc17 	ldw	r2,-16(fp)
8114541c:	10800104 	addi	r2,r2,4
81145420:	00c001c4 	movi	r3,7
81145424:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81145428:	d8000015 	stw	zero,0(sp)
8114542c:	e1fffc17 	ldw	r7,-16(fp)
81145430:	01a04534 	movhi	r6,33044
81145434:	3194d504 	addi	r6,r6,21332
81145438:	e17ffe17 	ldw	r5,-8(fp)
8114543c:	e13ffd17 	ldw	r4,-12(fp)
81145440:	11485dc0 	call	811485dc <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81145444:	0001883a 	nop
81145448:	e037883a 	mov	sp,fp
8114544c:	dfc00117 	ldw	ra,4(sp)
81145450:	df000017 	ldw	fp,0(sp)
81145454:	dec00204 	addi	sp,sp,8
81145458:	f800283a 	ret

8114545c <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8114545c:	defffa04 	addi	sp,sp,-24
81145460:	de00012e 	bgeu	sp,et,81145468 <altera_avalon_uart_read_fd+0xc>
81145464:	003b68fa 	trap	3
81145468:	dfc00515 	stw	ra,20(sp)
8114546c:	df000415 	stw	fp,16(sp)
81145470:	df000404 	addi	fp,sp,16
81145474:	e13ffd15 	stw	r4,-12(fp)
81145478:	e17ffe15 	stw	r5,-8(fp)
8114547c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81145480:	e0bffd17 	ldw	r2,-12(fp)
81145484:	10800017 	ldw	r2,0(r2)
81145488:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
8114548c:	e0bffc17 	ldw	r2,-16(fp)
81145490:	10c00a04 	addi	r3,r2,40
81145494:	e0bffd17 	ldw	r2,-12(fp)
81145498:	10800217 	ldw	r2,8(r2)
8114549c:	100f883a 	mov	r7,r2
811454a0:	e1bfff17 	ldw	r6,-4(fp)
811454a4:	e17ffe17 	ldw	r5,-8(fp)
811454a8:	1809883a 	mov	r4,r3
811454ac:	1145b1c0 	call	81145b1c <altera_avalon_uart_read>
      fd->fd_flags);
}
811454b0:	e037883a 	mov	sp,fp
811454b4:	dfc00117 	ldw	ra,4(sp)
811454b8:	df000017 	ldw	fp,0(sp)
811454bc:	dec00204 	addi	sp,sp,8
811454c0:	f800283a 	ret

811454c4 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811454c4:	defffa04 	addi	sp,sp,-24
811454c8:	de00012e 	bgeu	sp,et,811454d0 <altera_avalon_uart_write_fd+0xc>
811454cc:	003b68fa 	trap	3
811454d0:	dfc00515 	stw	ra,20(sp)
811454d4:	df000415 	stw	fp,16(sp)
811454d8:	df000404 	addi	fp,sp,16
811454dc:	e13ffd15 	stw	r4,-12(fp)
811454e0:	e17ffe15 	stw	r5,-8(fp)
811454e4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811454e8:	e0bffd17 	ldw	r2,-12(fp)
811454ec:	10800017 	ldw	r2,0(r2)
811454f0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811454f4:	e0bffc17 	ldw	r2,-16(fp)
811454f8:	10c00a04 	addi	r3,r2,40
811454fc:	e0bffd17 	ldw	r2,-12(fp)
81145500:	10800217 	ldw	r2,8(r2)
81145504:	100f883a 	mov	r7,r2
81145508:	e1bfff17 	ldw	r6,-4(fp)
8114550c:	e17ffe17 	ldw	r5,-8(fp)
81145510:	1809883a 	mov	r4,r3
81145514:	1145dd00 	call	81145dd0 <altera_avalon_uart_write>
      fd->fd_flags);
}
81145518:	e037883a 	mov	sp,fp
8114551c:	dfc00117 	ldw	ra,4(sp)
81145520:	df000017 	ldw	fp,0(sp)
81145524:	dec00204 	addi	sp,sp,8
81145528:	f800283a 	ret

8114552c <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
8114552c:	defffc04 	addi	sp,sp,-16
81145530:	de00012e 	bgeu	sp,et,81145538 <altera_avalon_uart_close_fd+0xc>
81145534:	003b68fa 	trap	3
81145538:	dfc00315 	stw	ra,12(sp)
8114553c:	df000215 	stw	fp,8(sp)
81145540:	df000204 	addi	fp,sp,8
81145544:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81145548:	e0bfff17 	ldw	r2,-4(fp)
8114554c:	10800017 	ldw	r2,0(r2)
81145550:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81145554:	e0bffe17 	ldw	r2,-8(fp)
81145558:	10c00a04 	addi	r3,r2,40
8114555c:	e0bfff17 	ldw	r2,-4(fp)
81145560:	10800217 	ldw	r2,8(r2)
81145564:	100b883a 	mov	r5,r2
81145568:	1809883a 	mov	r4,r3
8114556c:	1145a7c0 	call	81145a7c <altera_avalon_uart_close>
}
81145570:	e037883a 	mov	sp,fp
81145574:	dfc00117 	ldw	ra,4(sp)
81145578:	df000017 	ldw	fp,0(sp)
8114557c:	dec00204 	addi	sp,sp,8
81145580:	f800283a 	ret

81145584 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81145584:	defff304 	addi	sp,sp,-52
81145588:	de00012e 	bgeu	sp,et,81145590 <altera_avalon_uart_init+0xc>
8114558c:	003b68fa 	trap	3
81145590:	dfc00c15 	stw	ra,48(sp)
81145594:	df000b15 	stw	fp,44(sp)
81145598:	df000b04 	addi	fp,sp,44
8114559c:	e13ffd15 	stw	r4,-12(fp)
811455a0:	e17ffe15 	stw	r5,-8(fp)
811455a4:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
811455a8:	e0bffd17 	ldw	r2,-12(fp)
811455ac:	10800017 	ldw	r2,0(r2)
811455b0:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
811455b4:	e0bffd17 	ldw	r2,-12(fp)
811455b8:	10800704 	addi	r2,r2,28
811455bc:	e0bffa15 	stw	r2,-24(fp)
811455c0:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811455c4:	e0bffb0b 	ldhu	r2,-20(fp)
811455c8:	e0fffc84 	addi	r3,fp,-14
811455cc:	180b883a 	mov	r5,r3
811455d0:	1009883a 	mov	r4,r2
811455d4:	11388940 	call	81138894 <OSFlagCreate>
811455d8:	1007883a 	mov	r3,r2
811455dc:	e0bffa17 	ldw	r2,-24(fp)
811455e0:	10c00015 	stw	r3,0(r2)
  return err;
811455e4:	e0bffc83 	ldbu	r2,-14(fp)
811455e8:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811455ec:	1000241e 	bne	r2,zero,81145680 <altera_avalon_uart_init+0xfc>
811455f0:	e0bffd17 	ldw	r2,-12(fp)
811455f4:	10800804 	addi	r2,r2,32
811455f8:	e0bff715 	stw	r2,-36(fp)
811455fc:	00800044 	movi	r2,1
81145600:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81145604:	e0bffb8b 	ldhu	r2,-18(fp)
81145608:	1009883a 	mov	r4,r2
8114560c:	113c7f00 	call	8113c7f0 <OSSemCreate>
81145610:	1007883a 	mov	r3,r2
81145614:	e0bff717 	ldw	r2,-36(fp)
81145618:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
8114561c:	e0bff717 	ldw	r2,-36(fp)
81145620:	10800017 	ldw	r2,0(r2)
81145624:	10000226 	beq	r2,zero,81145630 <altera_avalon_uart_init+0xac>
81145628:	0005883a 	mov	r2,zero
8114562c:	00000106 	br	81145634 <altera_avalon_uart_init+0xb0>
81145630:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81145634:	1000121e 	bne	r2,zero,81145680 <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81145638:	e0bffd17 	ldw	r2,-12(fp)
8114563c:	10800904 	addi	r2,r2,36
81145640:	e0bff815 	stw	r2,-32(fp)
81145644:	00800044 	movi	r2,1
81145648:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
8114564c:	e0bffc0b 	ldhu	r2,-16(fp)
81145650:	1009883a 	mov	r4,r2
81145654:	113c7f00 	call	8113c7f0 <OSSemCreate>
81145658:	1007883a 	mov	r3,r2
8114565c:	e0bff817 	ldw	r2,-32(fp)
81145660:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81145664:	e0bff817 	ldw	r2,-32(fp)
81145668:	10800017 	ldw	r2,0(r2)
8114566c:	10000226 	beq	r2,zero,81145678 <altera_avalon_uart_init+0xf4>
81145670:	0005883a 	mov	r2,zero
81145674:	00000106 	br	8114567c <altera_avalon_uart_init+0xf8>
81145678:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
8114567c:	10000226 	beq	r2,zero,81145688 <altera_avalon_uart_init+0x104>
81145680:	00800044 	movi	r2,1
81145684:	00000106 	br	8114568c <altera_avalon_uart_init+0x108>
81145688:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
8114568c:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
81145690:	e0bff917 	ldw	r2,-28(fp)
81145694:	10000f1e 	bne	r2,zero,811456d4 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81145698:	e0bffd17 	ldw	r2,-12(fp)
8114569c:	00c32004 	movi	r3,3200
811456a0:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
811456a4:	e0bff617 	ldw	r2,-40(fp)
811456a8:	10800304 	addi	r2,r2,12
811456ac:	e0fffd17 	ldw	r3,-12(fp)
811456b0:	18c00117 	ldw	r3,4(r3)
811456b4:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
811456b8:	d8000015 	stw	zero,0(sp)
811456bc:	e1fffd17 	ldw	r7,-12(fp)
811456c0:	01a04534 	movhi	r6,33044
811456c4:	3195bb04 	addi	r6,r6,22252
811456c8:	e17fff17 	ldw	r5,-4(fp)
811456cc:	e13ffe17 	ldw	r4,-8(fp)
811456d0:	11485dc0 	call	811485dc <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
811456d4:	0001883a 	nop
811456d8:	e037883a 	mov	sp,fp
811456dc:	dfc00117 	ldw	ra,4(sp)
811456e0:	df000017 	ldw	fp,0(sp)
811456e4:	dec00204 	addi	sp,sp,8
811456e8:	f800283a 	ret

811456ec <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811456ec:	defffa04 	addi	sp,sp,-24
811456f0:	de00012e 	bgeu	sp,et,811456f8 <altera_avalon_uart_irq+0xc>
811456f4:	003b68fa 	trap	3
811456f8:	dfc00515 	stw	ra,20(sp)
811456fc:	df000415 	stw	fp,16(sp)
81145700:	df000404 	addi	fp,sp,16
81145704:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
81145708:	e0bfff17 	ldw	r2,-4(fp)
8114570c:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
81145710:	e0bffc17 	ldw	r2,-16(fp)
81145714:	10800017 	ldw	r2,0(r2)
81145718:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
8114571c:	e0bffd17 	ldw	r2,-12(fp)
81145720:	10800204 	addi	r2,r2,8
81145724:	10800037 	ldwio	r2,0(r2)
81145728:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
8114572c:	e0bffd17 	ldw	r2,-12(fp)
81145730:	10800204 	addi	r2,r2,8
81145734:	0007883a 	mov	r3,zero
81145738:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
8114573c:	e0bffd17 	ldw	r2,-12(fp)
81145740:	10800204 	addi	r2,r2,8
81145744:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81145748:	e0bffe17 	ldw	r2,-8(fp)
8114574c:	1080200c 	andi	r2,r2,128
81145750:	10000326 	beq	r2,zero,81145760 <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81145754:	e17ffe17 	ldw	r5,-8(fp)
81145758:	e13ffc17 	ldw	r4,-16(fp)
8114575c:	11457900 	call	81145790 <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
81145760:	e0bffe17 	ldw	r2,-8(fp)
81145764:	1081100c 	andi	r2,r2,1088
81145768:	10000326 	beq	r2,zero,81145778 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
8114576c:	e17ffe17 	ldw	r5,-8(fp)
81145770:	e13ffc17 	ldw	r4,-16(fp)
81145774:	11458d00 	call	811458d0 <altera_avalon_uart_txirq>
  }
  

}
81145778:	0001883a 	nop
8114577c:	e037883a 	mov	sp,fp
81145780:	dfc00117 	ldw	ra,4(sp)
81145784:	df000017 	ldw	fp,0(sp)
81145788:	dec00204 	addi	sp,sp,8
8114578c:	f800283a 	ret

81145790 <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
81145790:	defff904 	addi	sp,sp,-28
81145794:	de00012e 	bgeu	sp,et,8114579c <altera_avalon_uart_rxirq+0xc>
81145798:	003b68fa 	trap	3
8114579c:	dfc00615 	stw	ra,24(sp)
811457a0:	df000515 	stw	fp,20(sp)
811457a4:	df000504 	addi	fp,sp,20
811457a8:	e13ffe15 	stw	r4,-8(fp)
811457ac:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
811457b0:	e0bfff17 	ldw	r2,-4(fp)
811457b4:	108000cc 	andi	r2,r2,3
811457b8:	10003f1e 	bne	r2,zero,811458b8 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
811457bc:	e0bffe17 	ldw	r2,-8(fp)
811457c0:	10c00317 	ldw	r3,12(r2)
811457c4:	e0bffe17 	ldw	r2,-8(fp)
811457c8:	10800217 	ldw	r2,8(r2)
811457cc:	1880121e 	bne	r3,r2,81145818 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
811457d0:	e0bffe17 	ldw	r2,-8(fp)
811457d4:	10800717 	ldw	r2,28(r2)
811457d8:	e0bffc15 	stw	r2,-16(fp)
811457dc:	00800044 	movi	r2,1
811457e0:	e0bffd0d 	sth	r2,-12(fp)
811457e4:	00800044 	movi	r2,1
811457e8:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811457ec:	d0a09003 	ldbu	r2,-32192(gp)
811457f0:	10803fcc 	andi	r2,r2,255
811457f4:	10000826 	beq	r2,zero,81145818 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811457f8:	e0bffd0b 	ldhu	r2,-12(fp)
811457fc:	e0fffd83 	ldbu	r3,-10(fp)
81145800:	e13ffdc4 	addi	r4,fp,-9
81145804:	200f883a 	mov	r7,r4
81145808:	180d883a 	mov	r6,r3
8114580c:	100b883a 	mov	r5,r2
81145810:	e13ffc17 	ldw	r4,-16(fp)
81145814:	11394a00 	call	811394a0 <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81145818:	e0bffe17 	ldw	r2,-8(fp)
8114581c:	10800317 	ldw	r2,12(r2)
81145820:	10800044 	addi	r2,r2,1
81145824:	10800fcc 	andi	r2,r2,63
81145828:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
8114582c:	e0bffe17 	ldw	r2,-8(fp)
81145830:	10800317 	ldw	r2,12(r2)
81145834:	e0fffe17 	ldw	r3,-8(fp)
81145838:	18c00017 	ldw	r3,0(r3)
8114583c:	18c00037 	ldwio	r3,0(r3)
81145840:	1809883a 	mov	r4,r3
81145844:	e0fffe17 	ldw	r3,-8(fp)
81145848:	1885883a 	add	r2,r3,r2
8114584c:	10800a04 	addi	r2,r2,40
81145850:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81145854:	e0bffe17 	ldw	r2,-8(fp)
81145858:	e0fffb17 	ldw	r3,-20(fp)
8114585c:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81145860:	e0bffe17 	ldw	r2,-8(fp)
81145864:	10800317 	ldw	r2,12(r2)
81145868:	10800044 	addi	r2,r2,1
8114586c:	10800fcc 	andi	r2,r2,63
81145870:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81145874:	e0bffe17 	ldw	r2,-8(fp)
81145878:	10c00217 	ldw	r3,8(r2)
8114587c:	e0bffb17 	ldw	r2,-20(fp)
81145880:	18800e1e 	bne	r3,r2,811458bc <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81145884:	e0bffe17 	ldw	r2,-8(fp)
81145888:	10c00117 	ldw	r3,4(r2)
8114588c:	00bfdfc4 	movi	r2,-129
81145890:	1886703a 	and	r3,r3,r2
81145894:	e0bffe17 	ldw	r2,-8(fp)
81145898:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
8114589c:	e0bffe17 	ldw	r2,-8(fp)
811458a0:	10800017 	ldw	r2,0(r2)
811458a4:	10800304 	addi	r2,r2,12
811458a8:	e0fffe17 	ldw	r3,-8(fp)
811458ac:	18c00117 	ldw	r3,4(r3)
811458b0:	10c00035 	stwio	r3,0(r2)
811458b4:	00000106 	br	811458bc <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
811458b8:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
811458bc:	e037883a 	mov	sp,fp
811458c0:	dfc00117 	ldw	ra,4(sp)
811458c4:	df000017 	ldw	fp,0(sp)
811458c8:	dec00204 	addi	sp,sp,8
811458cc:	f800283a 	ret

811458d0 <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811458d0:	defffa04 	addi	sp,sp,-24
811458d4:	de00012e 	bgeu	sp,et,811458dc <altera_avalon_uart_txirq+0xc>
811458d8:	003b68fa 	trap	3
811458dc:	dfc00515 	stw	ra,20(sp)
811458e0:	df000415 	stw	fp,16(sp)
811458e4:	df000404 	addi	fp,sp,16
811458e8:	e13ffe15 	stw	r4,-8(fp)
811458ec:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
811458f0:	e0bffe17 	ldw	r2,-8(fp)
811458f4:	10c00417 	ldw	r3,16(r2)
811458f8:	e0bffe17 	ldw	r2,-8(fp)
811458fc:	10800517 	ldw	r2,20(r2)
81145900:	18804726 	beq	r3,r2,81145a20 <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
81145904:	e0bffe17 	ldw	r2,-8(fp)
81145908:	10800617 	ldw	r2,24(r2)
8114590c:	1080008c 	andi	r2,r2,2
81145910:	10000326 	beq	r2,zero,81145920 <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
81145914:	e0bfff17 	ldw	r2,-4(fp)
81145918:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
8114591c:	10003226 	beq	r2,zero,811459e8 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
81145920:	e0bffe17 	ldw	r2,-8(fp)
81145924:	10c00417 	ldw	r3,16(r2)
81145928:	e0bffe17 	ldw	r2,-8(fp)
8114592c:	10800517 	ldw	r2,20(r2)
81145930:	10800044 	addi	r2,r2,1
81145934:	10800fcc 	andi	r2,r2,63
81145938:	1880121e 	bne	r3,r2,81145984 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
8114593c:	e0bffe17 	ldw	r2,-8(fp)
81145940:	10800717 	ldw	r2,28(r2)
81145944:	e0bffc15 	stw	r2,-16(fp)
81145948:	00800084 	movi	r2,2
8114594c:	e0bffd0d 	sth	r2,-12(fp)
81145950:	00800044 	movi	r2,1
81145954:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81145958:	d0a09003 	ldbu	r2,-32192(gp)
8114595c:	10803fcc 	andi	r2,r2,255
81145960:	10000826 	beq	r2,zero,81145984 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81145964:	e0bffd0b 	ldhu	r2,-12(fp)
81145968:	e0fffd83 	ldbu	r3,-10(fp)
8114596c:	e13ffdc4 	addi	r4,fp,-9
81145970:	200f883a 	mov	r7,r4
81145974:	180d883a 	mov	r6,r3
81145978:	100b883a 	mov	r5,r2
8114597c:	e13ffc17 	ldw	r4,-16(fp)
81145980:	11394a00 	call	811394a0 <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81145984:	e0bffe17 	ldw	r2,-8(fp)
81145988:	10800017 	ldw	r2,0(r2)
8114598c:	10800104 	addi	r2,r2,4
81145990:	e0fffe17 	ldw	r3,-8(fp)
81145994:	18c00417 	ldw	r3,16(r3)
81145998:	e13ffe17 	ldw	r4,-8(fp)
8114599c:	20c7883a 	add	r3,r4,r3
811459a0:	18c01a04 	addi	r3,r3,104
811459a4:	18c00003 	ldbu	r3,0(r3)
811459a8:	18c03fcc 	andi	r3,r3,255
811459ac:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
811459b0:	e0bffe17 	ldw	r2,-8(fp)
811459b4:	10800417 	ldw	r2,16(r2)
811459b8:	10800044 	addi	r2,r2,1
811459bc:	e0fffe17 	ldw	r3,-8(fp)
811459c0:	18800415 	stw	r2,16(r3)
811459c4:	10c00fcc 	andi	r3,r2,63
811459c8:	e0bffe17 	ldw	r2,-8(fp)
811459cc:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811459d0:	e0bffe17 	ldw	r2,-8(fp)
811459d4:	10800117 	ldw	r2,4(r2)
811459d8:	10c01014 	ori	r3,r2,64
811459dc:	e0bffe17 	ldw	r2,-8(fp)
811459e0:	10c00115 	stw	r3,4(r2)
811459e4:	00000e06 	br	81145a20 <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811459e8:	e0bffe17 	ldw	r2,-8(fp)
811459ec:	10800017 	ldw	r2,0(r2)
811459f0:	10800204 	addi	r2,r2,8
811459f4:	10800037 	ldwio	r2,0(r2)
811459f8:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811459fc:	e0bfff17 	ldw	r2,-4(fp)
81145a00:	1082000c 	andi	r2,r2,2048
81145a04:	1000061e 	bne	r2,zero,81145a20 <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
81145a08:	e0bffe17 	ldw	r2,-8(fp)
81145a0c:	10c00117 	ldw	r3,4(r2)
81145a10:	00bfefc4 	movi	r2,-65
81145a14:	1886703a 	and	r3,r3,r2
81145a18:	e0bffe17 	ldw	r2,-8(fp)
81145a1c:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
81145a20:	e0bffe17 	ldw	r2,-8(fp)
81145a24:	10c00417 	ldw	r3,16(r2)
81145a28:	e0bffe17 	ldw	r2,-8(fp)
81145a2c:	10800517 	ldw	r2,20(r2)
81145a30:	1880061e 	bne	r3,r2,81145a4c <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81145a34:	e0bffe17 	ldw	r2,-8(fp)
81145a38:	10c00117 	ldw	r3,4(r2)
81145a3c:	00beefc4 	movi	r2,-1089
81145a40:	1886703a 	and	r3,r3,r2
81145a44:	e0bffe17 	ldw	r2,-8(fp)
81145a48:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81145a4c:	e0bffe17 	ldw	r2,-8(fp)
81145a50:	10800017 	ldw	r2,0(r2)
81145a54:	10800304 	addi	r2,r2,12
81145a58:	e0fffe17 	ldw	r3,-8(fp)
81145a5c:	18c00117 	ldw	r3,4(r3)
81145a60:	10c00035 	stwio	r3,0(r2)
}
81145a64:	0001883a 	nop
81145a68:	e037883a 	mov	sp,fp
81145a6c:	dfc00117 	ldw	ra,4(sp)
81145a70:	df000017 	ldw	fp,0(sp)
81145a74:	dec00204 	addi	sp,sp,8
81145a78:	f800283a 	ret

81145a7c <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81145a7c:	defffd04 	addi	sp,sp,-12
81145a80:	de00012e 	bgeu	sp,et,81145a88 <altera_avalon_uart_close+0xc>
81145a84:	003b68fa 	trap	3
81145a88:	df000215 	stw	fp,8(sp)
81145a8c:	df000204 	addi	fp,sp,8
81145a90:	e13ffe15 	stw	r4,-8(fp)
81145a94:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81145a98:	00000506 	br	81145ab0 <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81145a9c:	e0bfff17 	ldw	r2,-4(fp)
81145aa0:	1090000c 	andi	r2,r2,16384
81145aa4:	10000226 	beq	r2,zero,81145ab0 <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81145aa8:	00bffd44 	movi	r2,-11
81145aac:	00000606 	br	81145ac8 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81145ab0:	e0bffe17 	ldw	r2,-8(fp)
81145ab4:	10c00417 	ldw	r3,16(r2)
81145ab8:	e0bffe17 	ldw	r2,-8(fp)
81145abc:	10800517 	ldw	r2,20(r2)
81145ac0:	18bff61e 	bne	r3,r2,81145a9c <__reset+0xfb125a9c>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81145ac4:	0005883a 	mov	r2,zero
}
81145ac8:	e037883a 	mov	sp,fp
81145acc:	df000017 	ldw	fp,0(sp)
81145ad0:	dec00104 	addi	sp,sp,4
81145ad4:	f800283a 	ret

81145ad8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81145ad8:	defffe04 	addi	sp,sp,-8
81145adc:	de00012e 	bgeu	sp,et,81145ae4 <alt_get_errno+0xc>
81145ae0:	003b68fa 	trap	3
81145ae4:	dfc00115 	stw	ra,4(sp)
81145ae8:	df000015 	stw	fp,0(sp)
81145aec:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81145af0:	d0a01017 	ldw	r2,-32704(gp)
81145af4:	10000326 	beq	r2,zero,81145b04 <alt_get_errno+0x2c>
81145af8:	d0a01017 	ldw	r2,-32704(gp)
81145afc:	103ee83a 	callr	r2
81145b00:	00000106 	br	81145b08 <alt_get_errno+0x30>
81145b04:	d0a07704 	addi	r2,gp,-32292
}
81145b08:	e037883a 	mov	sp,fp
81145b0c:	dfc00117 	ldw	ra,4(sp)
81145b10:	df000017 	ldw	fp,0(sp)
81145b14:	dec00204 	addi	sp,sp,8
81145b18:	f800283a 	ret

81145b1c <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81145b1c:	deffec04 	addi	sp,sp,-80
81145b20:	de00012e 	bgeu	sp,et,81145b28 <altera_avalon_uart_read+0xc>
81145b24:	003b68fa 	trap	3
81145b28:	dfc01315 	stw	ra,76(sp)
81145b2c:	df001215 	stw	fp,72(sp)
81145b30:	df001204 	addi	fp,sp,72
81145b34:	e13ffc15 	stw	r4,-16(fp)
81145b38:	e17ffd15 	stw	r5,-12(fp)
81145b3c:	e1bffe15 	stw	r6,-8(fp)
81145b40:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81145b44:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81145b48:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81145b4c:	e0bfff17 	ldw	r2,-4(fp)
81145b50:	1090000c 	andi	r2,r2,16384
81145b54:	1005003a 	cmpeq	r2,r2,zero
81145b58:	10803fcc 	andi	r2,r2,255
81145b5c:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81145b60:	e0bffc17 	ldw	r2,-16(fp)
81145b64:	10800817 	ldw	r2,32(r2)
81145b68:	e0bff815 	stw	r2,-32(fp)
81145b6c:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81145b70:	e0bff90b 	ldhu	r2,-28(fp)
81145b74:	e0fffb44 	addi	r3,fp,-19
81145b78:	180d883a 	mov	r6,r3
81145b7c:	100b883a 	mov	r5,r2
81145b80:	e13ff817 	ldw	r4,-32(fp)
81145b84:	113cb180 	call	8113cb18 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81145b88:	00001306 	br	81145bd8 <altera_avalon_uart_read+0xbc>
    {
      count++;
81145b8c:	e0bff017 	ldw	r2,-64(fp)
81145b90:	10800044 	addi	r2,r2,1
81145b94:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81145b98:	e0bffd17 	ldw	r2,-12(fp)
81145b9c:	10c00044 	addi	r3,r2,1
81145ba0:	e0fffd15 	stw	r3,-12(fp)
81145ba4:	e0fffc17 	ldw	r3,-16(fp)
81145ba8:	18c00217 	ldw	r3,8(r3)
81145bac:	e13ffc17 	ldw	r4,-16(fp)
81145bb0:	20c7883a 	add	r3,r4,r3
81145bb4:	18c00a04 	addi	r3,r3,40
81145bb8:	18c00003 	ldbu	r3,0(r3)
81145bbc:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81145bc0:	e0bffc17 	ldw	r2,-16(fp)
81145bc4:	10800217 	ldw	r2,8(r2)
81145bc8:	10800044 	addi	r2,r2,1
81145bcc:	10c00fcc 	andi	r3,r2,63
81145bd0:	e0bffc17 	ldw	r2,-16(fp)
81145bd4:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81145bd8:	e0fff017 	ldw	r3,-64(fp)
81145bdc:	e0bffe17 	ldw	r2,-8(fp)
81145be0:	1880050e 	bge	r3,r2,81145bf8 <altera_avalon_uart_read+0xdc>
81145be4:	e0bffc17 	ldw	r2,-16(fp)
81145be8:	10c00217 	ldw	r3,8(r2)
81145bec:	e0bffc17 	ldw	r2,-16(fp)
81145bf0:	10800317 	ldw	r2,12(r2)
81145bf4:	18bfe51e 	bne	r3,r2,81145b8c <__reset+0xfb125b8c>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81145bf8:	e0bff017 	ldw	r2,-64(fp)
81145bfc:	10003a1e 	bne	r2,zero,81145ce8 <altera_avalon_uart_read+0x1cc>
81145c00:	e0bffc17 	ldw	r2,-16(fp)
81145c04:	10c00217 	ldw	r3,8(r2)
81145c08:	e0bffc17 	ldw	r2,-16(fp)
81145c0c:	10800317 	ldw	r2,12(r2)
81145c10:	1880351e 	bne	r3,r2,81145ce8 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81145c14:	e0bff117 	ldw	r2,-60(fp)
81145c18:	1000071e 	bne	r2,zero,81145c38 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81145c1c:	1145ad80 	call	81145ad8 <alt_get_errno>
81145c20:	1007883a 	mov	r3,r2
81145c24:	008002c4 	movi	r2,11
81145c28:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81145c2c:	00800044 	movi	r2,1
81145c30:	e0bfef05 	stb	r2,-68(fp)
        break;
81145c34:	00003006 	br	81145cf8 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145c38:	0005303a 	rdctl	r2,status
81145c3c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145c40:	e0fff517 	ldw	r3,-44(fp)
81145c44:	00bfff84 	movi	r2,-2
81145c48:	1884703a 	and	r2,r3,r2
81145c4c:	1001703a 	wrctl	status,r2
  
  return context;
81145c50:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81145c54:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81145c58:	e0bffc17 	ldw	r2,-16(fp)
81145c5c:	10800117 	ldw	r2,4(r2)
81145c60:	10c02014 	ori	r3,r2,128
81145c64:	e0bffc17 	ldw	r2,-16(fp)
81145c68:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81145c6c:	e0bffc17 	ldw	r2,-16(fp)
81145c70:	10800017 	ldw	r2,0(r2)
81145c74:	10800304 	addi	r2,r2,12
81145c78:	e0fffc17 	ldw	r3,-16(fp)
81145c7c:	18c00117 	ldw	r3,4(r3)
81145c80:	10c00035 	stwio	r3,0(r2)
81145c84:	e0bff417 	ldw	r2,-48(fp)
81145c88:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145c8c:	e0bff617 	ldw	r2,-40(fp)
81145c90:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81145c94:	e0bffc17 	ldw	r2,-16(fp)
81145c98:	10800717 	ldw	r2,28(r2)
81145c9c:	e0bff215 	stw	r2,-56(fp)
81145ca0:	00800044 	movi	r2,1
81145ca4:	e0bff98d 	sth	r2,-26(fp)
81145ca8:	00bfe0c4 	movi	r2,-125
81145cac:	e0bffa05 	stb	r2,-24(fp)
81145cb0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81145cb4:	d0a09003 	ldbu	r2,-32192(gp)
81145cb8:	10803fcc 	andi	r2,r2,255
81145cbc:	10000a26 	beq	r2,zero,81145ce8 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81145cc0:	e0fff98b 	ldhu	r3,-26(fp)
81145cc4:	e13ffa03 	ldbu	r4,-24(fp)
81145cc8:	e17ffa8b 	ldhu	r5,-22(fp)
81145ccc:	e0bffb04 	addi	r2,fp,-20
81145cd0:	d8800015 	stw	r2,0(sp)
81145cd4:	280f883a 	mov	r7,r5
81145cd8:	200d883a 	mov	r6,r4
81145cdc:	180b883a 	mov	r5,r3
81145ce0:	e13ff217 	ldw	r4,-56(fp)
81145ce4:	1138e780 	call	81138e78 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81145ce8:	e0bff017 	ldw	r2,-64(fp)
81145cec:	1000021e 	bne	r2,zero,81145cf8 <altera_avalon_uart_read+0x1dc>
81145cf0:	e0bffe17 	ldw	r2,-8(fp)
81145cf4:	103fb81e 	bne	r2,zero,81145bd8 <__reset+0xfb125bd8>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81145cf8:	e0bffc17 	ldw	r2,-16(fp)
81145cfc:	10800817 	ldw	r2,32(r2)
81145d00:	1009883a 	mov	r4,r2
81145d04:	113cea00 	call	8113cea0 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145d08:	0005303a 	rdctl	r2,status
81145d0c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145d10:	e0fff717 	ldw	r3,-36(fp)
81145d14:	00bfff84 	movi	r2,-2
81145d18:	1884703a 	and	r2,r3,r2
81145d1c:	1001703a 	wrctl	status,r2
  
  return context;
81145d20:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81145d24:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81145d28:	e0bffc17 	ldw	r2,-16(fp)
81145d2c:	10800117 	ldw	r2,4(r2)
81145d30:	10c02014 	ori	r3,r2,128
81145d34:	e0bffc17 	ldw	r2,-16(fp)
81145d38:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81145d3c:	e0bffc17 	ldw	r2,-16(fp)
81145d40:	10800017 	ldw	r2,0(r2)
81145d44:	10800304 	addi	r2,r2,12
81145d48:	e0fffc17 	ldw	r3,-16(fp)
81145d4c:	18c00117 	ldw	r3,4(r3)
81145d50:	10c00035 	stwio	r3,0(r2)
81145d54:	e0bff417 	ldw	r2,-48(fp)
81145d58:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145d5c:	e0bff317 	ldw	r2,-52(fp)
81145d60:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81145d64:	e0bfef03 	ldbu	r2,-68(fp)
81145d68:	10000226 	beq	r2,zero,81145d74 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81145d6c:	00bffd44 	movi	r2,-11
81145d70:	00000106 	br	81145d78 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81145d74:	e0bff017 	ldw	r2,-64(fp)
  }
}
81145d78:	e037883a 	mov	sp,fp
81145d7c:	dfc00117 	ldw	ra,4(sp)
81145d80:	df000017 	ldw	fp,0(sp)
81145d84:	dec00204 	addi	sp,sp,8
81145d88:	f800283a 	ret

81145d8c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81145d8c:	defffe04 	addi	sp,sp,-8
81145d90:	de00012e 	bgeu	sp,et,81145d98 <alt_get_errno+0xc>
81145d94:	003b68fa 	trap	3
81145d98:	dfc00115 	stw	ra,4(sp)
81145d9c:	df000015 	stw	fp,0(sp)
81145da0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81145da4:	d0a01017 	ldw	r2,-32704(gp)
81145da8:	10000326 	beq	r2,zero,81145db8 <alt_get_errno+0x2c>
81145dac:	d0a01017 	ldw	r2,-32704(gp)
81145db0:	103ee83a 	callr	r2
81145db4:	00000106 	br	81145dbc <alt_get_errno+0x30>
81145db8:	d0a07704 	addi	r2,gp,-32292
}
81145dbc:	e037883a 	mov	sp,fp
81145dc0:	dfc00117 	ldw	ra,4(sp)
81145dc4:	df000017 	ldw	fp,0(sp)
81145dc8:	dec00204 	addi	sp,sp,8
81145dcc:	f800283a 	ret

81145dd0 <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81145dd0:	deffec04 	addi	sp,sp,-80
81145dd4:	de00012e 	bgeu	sp,et,81145ddc <altera_avalon_uart_write+0xc>
81145dd8:	003b68fa 	trap	3
81145ddc:	dfc01315 	stw	ra,76(sp)
81145de0:	df001215 	stw	fp,72(sp)
81145de4:	df001204 	addi	fp,sp,72
81145de8:	e13ffc15 	stw	r4,-16(fp)
81145dec:	e17ffd15 	stw	r5,-12(fp)
81145df0:	e1bffe15 	stw	r6,-8(fp)
81145df4:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81145df8:	e0bffe17 	ldw	r2,-8(fp)
81145dfc:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81145e00:	e0bfff17 	ldw	r2,-4(fp)
81145e04:	1090000c 	andi	r2,r2,16384
81145e08:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81145e0c:	e0bffc17 	ldw	r2,-16(fp)
81145e10:	10800917 	ldw	r2,36(r2)
81145e14:	e0bff815 	stw	r2,-32(fp)
81145e18:	e03ff90d 	sth	zero,-28(fp)
81145e1c:	e0bff90b 	ldhu	r2,-28(fp)
81145e20:	e0fffb44 	addi	r3,fp,-19
81145e24:	180d883a 	mov	r6,r3
81145e28:	100b883a 	mov	r5,r2
81145e2c:	e13ff817 	ldw	r4,-32(fp)
81145e30:	113cb180 	call	8113cb18 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81145e34:	00005106 	br	81145f7c <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81145e38:	e0bffc17 	ldw	r2,-16(fp)
81145e3c:	10800517 	ldw	r2,20(r2)
81145e40:	10800044 	addi	r2,r2,1
81145e44:	10800fcc 	andi	r2,r2,63
81145e48:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81145e4c:	e0bffc17 	ldw	r2,-16(fp)
81145e50:	10c00417 	ldw	r3,16(r2)
81145e54:	e0bff217 	ldw	r2,-56(fp)
81145e58:	1880371e 	bne	r3,r2,81145f38 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81145e5c:	e0bff017 	ldw	r2,-64(fp)
81145e60:	10000526 	beq	r2,zero,81145e78 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81145e64:	1145d8c0 	call	81145d8c <alt_get_errno>
81145e68:	1007883a 	mov	r3,r2
81145e6c:	008002c4 	movi	r2,11
81145e70:	18800015 	stw	r2,0(r3)
        break;
81145e74:	00004306 	br	81145f84 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145e78:	0005303a 	rdctl	r2,status
81145e7c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145e80:	e0fff517 	ldw	r3,-44(fp)
81145e84:	00bfff84 	movi	r2,-2
81145e88:	1884703a 	and	r2,r3,r2
81145e8c:	1001703a 	wrctl	status,r2
  
  return context;
81145e90:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81145e94:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81145e98:	e0bffc17 	ldw	r2,-16(fp)
81145e9c:	10800117 	ldw	r2,4(r2)
81145ea0:	10c11014 	ori	r3,r2,1088
81145ea4:	e0bffc17 	ldw	r2,-16(fp)
81145ea8:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81145eac:	e0bffc17 	ldw	r2,-16(fp)
81145eb0:	10800017 	ldw	r2,0(r2)
81145eb4:	10800304 	addi	r2,r2,12
81145eb8:	e0fffc17 	ldw	r3,-16(fp)
81145ebc:	18c00117 	ldw	r3,4(r3)
81145ec0:	10c00035 	stwio	r3,0(r2)
81145ec4:	e0bff417 	ldw	r2,-48(fp)
81145ec8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145ecc:	e0bff117 	ldw	r2,-60(fp)
81145ed0:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81145ed4:	e0bffc17 	ldw	r2,-16(fp)
81145ed8:	10800717 	ldw	r2,28(r2)
81145edc:	e0bff315 	stw	r2,-52(fp)
81145ee0:	00800084 	movi	r2,2
81145ee4:	e0bff98d 	sth	r2,-26(fp)
81145ee8:	00bfe0c4 	movi	r2,-125
81145eec:	e0bffa05 	stb	r2,-24(fp)
81145ef0:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81145ef4:	d0a09003 	ldbu	r2,-32192(gp)
81145ef8:	10803fcc 	andi	r2,r2,255
81145efc:	10000a26 	beq	r2,zero,81145f28 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81145f00:	e0fff98b 	ldhu	r3,-26(fp)
81145f04:	e13ffa03 	ldbu	r4,-24(fp)
81145f08:	e17ffa8b 	ldhu	r5,-22(fp)
81145f0c:	e0bffb04 	addi	r2,fp,-20
81145f10:	d8800015 	stw	r2,0(sp)
81145f14:	280f883a 	mov	r7,r5
81145f18:	200d883a 	mov	r6,r4
81145f1c:	180b883a 	mov	r5,r3
81145f20:	e13ff317 	ldw	r4,-52(fp)
81145f24:	1138e780 	call	81138e78 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81145f28:	e0bffc17 	ldw	r2,-16(fp)
81145f2c:	10c00417 	ldw	r3,16(r2)
81145f30:	e0bff217 	ldw	r2,-56(fp)
81145f34:	18bfe726 	beq	r3,r2,81145ed4 <__reset+0xfb125ed4>
      }
    }

    count--;
81145f38:	e0bfef17 	ldw	r2,-68(fp)
81145f3c:	10bfffc4 	addi	r2,r2,-1
81145f40:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81145f44:	e0bffc17 	ldw	r2,-16(fp)
81145f48:	10c00517 	ldw	r3,20(r2)
81145f4c:	e0bffd17 	ldw	r2,-12(fp)
81145f50:	11000044 	addi	r4,r2,1
81145f54:	e13ffd15 	stw	r4,-12(fp)
81145f58:	10800003 	ldbu	r2,0(r2)
81145f5c:	1009883a 	mov	r4,r2
81145f60:	e0bffc17 	ldw	r2,-16(fp)
81145f64:	10c5883a 	add	r2,r2,r3
81145f68:	10801a04 	addi	r2,r2,104
81145f6c:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81145f70:	e0bffc17 	ldw	r2,-16(fp)
81145f74:	e0fff217 	ldw	r3,-56(fp)
81145f78:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81145f7c:	e0bfef17 	ldw	r2,-68(fp)
81145f80:	103fad1e 	bne	r2,zero,81145e38 <__reset+0xfb125e38>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81145f84:	e0bffc17 	ldw	r2,-16(fp)
81145f88:	10800917 	ldw	r2,36(r2)
81145f8c:	1009883a 	mov	r4,r2
81145f90:	113cea00 	call	8113cea0 <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145f94:	0005303a 	rdctl	r2,status
81145f98:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145f9c:	e0fff717 	ldw	r3,-36(fp)
81145fa0:	00bfff84 	movi	r2,-2
81145fa4:	1884703a 	and	r2,r3,r2
81145fa8:	1001703a 	wrctl	status,r2
  
  return context;
81145fac:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81145fb0:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81145fb4:	e0bffc17 	ldw	r2,-16(fp)
81145fb8:	10800117 	ldw	r2,4(r2)
81145fbc:	10c11014 	ori	r3,r2,1088
81145fc0:	e0bffc17 	ldw	r2,-16(fp)
81145fc4:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81145fc8:	e0bffc17 	ldw	r2,-16(fp)
81145fcc:	10800017 	ldw	r2,0(r2)
81145fd0:	10800304 	addi	r2,r2,12
81145fd4:	e0fffc17 	ldw	r3,-16(fp)
81145fd8:	18c00117 	ldw	r3,4(r3)
81145fdc:	10c00035 	stwio	r3,0(r2)
81145fe0:	e0bff417 	ldw	r2,-48(fp)
81145fe4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145fe8:	e0bff617 	ldw	r2,-40(fp)
81145fec:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81145ff0:	e0fffe17 	ldw	r3,-8(fp)
81145ff4:	e0bfef17 	ldw	r2,-68(fp)
81145ff8:	1885c83a 	sub	r2,r3,r2
}
81145ffc:	e037883a 	mov	sp,fp
81146000:	dfc00117 	ldw	ra,4(sp)
81146004:	df000017 	ldw	fp,0(sp)
81146008:	dec00204 	addi	sp,sp,8
8114600c:	f800283a 	ret

81146010 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81146010:	defffe04 	addi	sp,sp,-8
81146014:	de00012e 	bgeu	sp,et,8114601c <alt_get_errno+0xc>
81146018:	003b68fa 	trap	3
8114601c:	dfc00115 	stw	ra,4(sp)
81146020:	df000015 	stw	fp,0(sp)
81146024:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81146028:	d0a01017 	ldw	r2,-32704(gp)
8114602c:	10000326 	beq	r2,zero,8114603c <alt_get_errno+0x2c>
81146030:	d0a01017 	ldw	r2,-32704(gp)
81146034:	103ee83a 	callr	r2
81146038:	00000106 	br	81146040 <alt_get_errno+0x30>
8114603c:	d0a07704 	addi	r2,gp,-32292
}
81146040:	e037883a 	mov	sp,fp
81146044:	dfc00117 	ldw	ra,4(sp)
81146048:	df000017 	ldw	fp,0(sp)
8114604c:	dec00204 	addi	sp,sp,8
81146050:	f800283a 	ret

81146054 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81146054:	defffc04 	addi	sp,sp,-16
81146058:	de00012e 	bgeu	sp,et,81146060 <alt_msgdma_write_standard_descriptor+0xc>
8114605c:	003b68fa 	trap	3
81146060:	df000315 	stw	fp,12(sp)
81146064:	df000304 	addi	fp,sp,12
81146068:	e13ffd15 	stw	r4,-12(fp)
8114606c:	e17ffe15 	stw	r5,-8(fp)
81146070:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81146074:	e0bffd17 	ldw	r2,-12(fp)
81146078:	10800037 	ldwio	r2,0(r2)
8114607c:	1080010c 	andi	r2,r2,4
81146080:	10000226 	beq	r2,zero,8114608c <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81146084:	00bff904 	movi	r2,-28
81146088:	00001506 	br	811460e0 <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
8114608c:	e0bfff17 	ldw	r2,-4(fp)
81146090:	10800017 	ldw	r2,0(r2)
81146094:	1007883a 	mov	r3,r2
81146098:	e0bffe17 	ldw	r2,-8(fp)
8114609c:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
811460a0:	e0bffe17 	ldw	r2,-8(fp)
811460a4:	10800104 	addi	r2,r2,4
811460a8:	e0ffff17 	ldw	r3,-4(fp)
811460ac:	18c00117 	ldw	r3,4(r3)
811460b0:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
811460b4:	e0bffe17 	ldw	r2,-8(fp)
811460b8:	10800204 	addi	r2,r2,8
811460bc:	e0ffff17 	ldw	r3,-4(fp)
811460c0:	18c00217 	ldw	r3,8(r3)
811460c4:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
811460c8:	e0bffe17 	ldw	r2,-8(fp)
811460cc:	10800304 	addi	r2,r2,12
811460d0:	e0ffff17 	ldw	r3,-4(fp)
811460d4:	18c00317 	ldw	r3,12(r3)
811460d8:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
811460dc:	0005883a 	mov	r2,zero
}
811460e0:	e037883a 	mov	sp,fp
811460e4:	df000017 	ldw	fp,0(sp)
811460e8:	dec00104 	addi	sp,sp,4
811460ec:	f800283a 	ret

811460f0 <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
811460f0:	defffc04 	addi	sp,sp,-16
811460f4:	de00012e 	bgeu	sp,et,811460fc <alt_msgdma_write_extended_descriptor+0xc>
811460f8:	003b68fa 	trap	3
811460fc:	df000315 	stw	fp,12(sp)
81146100:	df000304 	addi	fp,sp,12
81146104:	e13ffd15 	stw	r4,-12(fp)
81146108:	e17ffe15 	stw	r5,-8(fp)
8114610c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81146110:	e0bffd17 	ldw	r2,-12(fp)
81146114:	10800037 	ldwio	r2,0(r2)
81146118:	1080010c 	andi	r2,r2,4
8114611c:	10000226 	beq	r2,zero,81146128 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
81146120:	00bff904 	movi	r2,-28
81146124:	00003b06 	br	81146214 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81146128:	e0bfff17 	ldw	r2,-4(fp)
8114612c:	10800017 	ldw	r2,0(r2)
81146130:	1007883a 	mov	r3,r2
81146134:	e0bffe17 	ldw	r2,-8(fp)
81146138:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
8114613c:	e0bffe17 	ldw	r2,-8(fp)
81146140:	10800104 	addi	r2,r2,4
81146144:	e0ffff17 	ldw	r3,-4(fp)
81146148:	18c00117 	ldw	r3,4(r3)
8114614c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
81146150:	e0bffe17 	ldw	r2,-8(fp)
81146154:	10800204 	addi	r2,r2,8
81146158:	e0ffff17 	ldw	r3,-4(fp)
8114615c:	18c00217 	ldw	r3,8(r3)
81146160:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81146164:	e0bffe17 	ldw	r2,-8(fp)
81146168:	10800304 	addi	r2,r2,12
8114616c:	e0ffff17 	ldw	r3,-4(fp)
81146170:	18c0030b 	ldhu	r3,12(r3)
81146174:	18ffffcc 	andi	r3,r3,65535
81146178:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
8114617c:	e0bffe17 	ldw	r2,-8(fp)
81146180:	10800384 	addi	r2,r2,14
81146184:	e0ffff17 	ldw	r3,-4(fp)
81146188:	18c00383 	ldbu	r3,14(r3)
8114618c:	18c03fcc 	andi	r3,r3,255
81146190:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81146194:	e0bffe17 	ldw	r2,-8(fp)
81146198:	108003c4 	addi	r2,r2,15
8114619c:	e0ffff17 	ldw	r3,-4(fp)
811461a0:	18c003c3 	ldbu	r3,15(r3)
811461a4:	18c03fcc 	andi	r3,r3,255
811461a8:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
811461ac:	e0bffe17 	ldw	r2,-8(fp)
811461b0:	10800404 	addi	r2,r2,16
811461b4:	e0ffff17 	ldw	r3,-4(fp)
811461b8:	18c0040b 	ldhu	r3,16(r3)
811461bc:	18ffffcc 	andi	r3,r3,65535
811461c0:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
811461c4:	e0bffe17 	ldw	r2,-8(fp)
811461c8:	10800484 	addi	r2,r2,18
811461cc:	e0ffff17 	ldw	r3,-4(fp)
811461d0:	18c0048b 	ldhu	r3,18(r3)
811461d4:	18ffffcc 	andi	r3,r3,65535
811461d8:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
811461dc:	e0bffe17 	ldw	r2,-8(fp)
811461e0:	10800504 	addi	r2,r2,20
811461e4:	0007883a 	mov	r3,zero
811461e8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811461ec:	e0bffe17 	ldw	r2,-8(fp)
811461f0:	10800604 	addi	r2,r2,24
811461f4:	0007883a 	mov	r3,zero
811461f8:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811461fc:	e0bffe17 	ldw	r2,-8(fp)
81146200:	10800704 	addi	r2,r2,28
81146204:	e0ffff17 	ldw	r3,-4(fp)
81146208:	18c00717 	ldw	r3,28(r3)
8114620c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
81146210:	0005883a 	mov	r2,zero
}
81146214:	e037883a 	mov	sp,fp
81146218:	df000017 	ldw	fp,0(sp)
8114621c:	dec00104 	addi	sp,sp,4
81146220:	f800283a 	ret

81146224 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81146224:	defff804 	addi	sp,sp,-32
81146228:	de00012e 	bgeu	sp,et,81146230 <alt_msgdma_irq+0xc>
8114622c:	003b68fa 	trap	3
81146230:	dfc00715 	stw	ra,28(sp)
81146234:	df000615 	stw	fp,24(sp)
81146238:	df000604 	addi	fp,sp,24
8114623c:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
81146240:	e0bfff17 	ldw	r2,-4(fp)
81146244:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81146248:	e0bffa17 	ldw	r2,-24(fp)
8114624c:	10801783 	ldbu	r2,94(r2)
81146250:	10803fcc 	andi	r2,r2,255
81146254:	10001126 	beq	r2,zero,8114629c <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81146258:	e0bffa17 	ldw	r2,-24(fp)
8114625c:	10800617 	ldw	r2,24(r2)
81146260:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81146264:	1007883a 	mov	r3,r2
81146268:	00bffdc4 	movi	r2,-9
8114626c:	1884703a 	and	r2,r3,r2
81146270:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81146274:	e0bffa17 	ldw	r2,-24(fp)
81146278:	10800617 	ldw	r2,24(r2)
8114627c:	e0fffb17 	ldw	r3,-20(fp)
81146280:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81146284:	e0bffa17 	ldw	r2,-24(fp)
81146288:	10800617 	ldw	r2,24(r2)
8114628c:	10800404 	addi	r2,r2,16
81146290:	00c00044 	movi	r3,1
81146294:	10c00035 	stwio	r3,0(r2)
81146298:	00001106 	br	811462e0 <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
8114629c:	e0bffa17 	ldw	r2,-24(fp)
811462a0:	10800317 	ldw	r2,12(r2)
811462a4:	10800104 	addi	r2,r2,4
811462a8:	10800037 	ldwio	r2,0(r2)
811462ac:	1007883a 	mov	r3,r2
811462b0:	00bffbc4 	movi	r2,-17
811462b4:	1884703a 	and	r2,r3,r2
811462b8:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
811462bc:	e0bffa17 	ldw	r2,-24(fp)
811462c0:	10800317 	ldw	r2,12(r2)
811462c4:	10800104 	addi	r2,r2,4
811462c8:	e0fffb17 	ldw	r3,-20(fp)
811462cc:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811462d0:	e0bffa17 	ldw	r2,-24(fp)
811462d4:	10800317 	ldw	r2,12(r2)
811462d8:	00c08004 	movi	r3,512
811462dc:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
811462e0:	e0bffa17 	ldw	r2,-24(fp)
811462e4:	10800b17 	ldw	r2,44(r2)
811462e8:	10001226 	beq	r2,zero,81146334 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811462ec:	0005303a 	rdctl	r2,status
811462f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811462f4:	e0fffd17 	ldw	r3,-12(fp)
811462f8:	00bfff84 	movi	r2,-2
811462fc:	1884703a 	and	r2,r3,r2
81146300:	1001703a 	wrctl	status,r2
  
  return context;
81146304:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
81146308:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
8114630c:	e0bffa17 	ldw	r2,-24(fp)
81146310:	10800b17 	ldw	r2,44(r2)
81146314:	e0fffa17 	ldw	r3,-24(fp)
81146318:	18c00c17 	ldw	r3,48(r3)
8114631c:	1809883a 	mov	r4,r3
81146320:	103ee83a 	callr	r2
81146324:	e0bffc17 	ldw	r2,-16(fp)
81146328:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114632c:	e0bffe17 	ldw	r2,-8(fp)
81146330:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81146334:	e0bffa17 	ldw	r2,-24(fp)
81146338:	10801783 	ldbu	r2,94(r2)
8114633c:	10803fcc 	andi	r2,r2,255
81146340:	10000a26 	beq	r2,zero,8114636c <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81146344:	e0bffa17 	ldw	r2,-24(fp)
81146348:	10800617 	ldw	r2,24(r2)
8114634c:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81146350:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81146354:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81146358:	e0bffa17 	ldw	r2,-24(fp)
8114635c:	10800617 	ldw	r2,24(r2)
81146360:	e0fffb17 	ldw	r3,-20(fp)
81146364:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81146368:	00000c06 	br	8114639c <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114636c:	e0bffa17 	ldw	r2,-24(fp)
81146370:	10800317 	ldw	r2,12(r2)
81146374:	10800104 	addi	r2,r2,4
81146378:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
8114637c:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81146380:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81146384:	e0bffa17 	ldw	r2,-24(fp)
81146388:	10800317 	ldw	r2,12(r2)
8114638c:	10800104 	addi	r2,r2,4
81146390:	e0fffb17 	ldw	r3,-20(fp)
81146394:	10c00035 	stwio	r3,0(r2)
    }

    return;
81146398:	0001883a 	nop
}
8114639c:	e037883a 	mov	sp,fp
811463a0:	dfc00117 	ldw	ra,4(sp)
811463a4:	df000017 	ldw	fp,0(sp)
811463a8:	dec00204 	addi	sp,sp,8
811463ac:	f800283a 	ret

811463b0 <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
811463b0:	defffb04 	addi	sp,sp,-20
811463b4:	de00012e 	bgeu	sp,et,811463bc <alt_msgdma_construct_standard_descriptor+0xc>
811463b8:	003b68fa 	trap	3
811463bc:	df000415 	stw	fp,16(sp)
811463c0:	df000404 	addi	fp,sp,16
811463c4:	e13ffc15 	stw	r4,-16(fp)
811463c8:	e17ffd15 	stw	r5,-12(fp)
811463cc:	e1bffe15 	stw	r6,-8(fp)
811463d0:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811463d4:	e0bffc17 	ldw	r2,-16(fp)
811463d8:	10c01217 	ldw	r3,72(r2)
811463dc:	e0800117 	ldw	r2,4(fp)
811463e0:	18800436 	bltu	r3,r2,811463f4 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
811463e4:	e0bffc17 	ldw	r2,-16(fp)
811463e8:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811463ec:	10803fcc 	andi	r2,r2,255
811463f0:	10000226 	beq	r2,zero,811463fc <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811463f4:	00bffa84 	movi	r2,-22
811463f8:	00000e06 	br	81146434 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811463fc:	e0bffd17 	ldw	r2,-12(fp)
81146400:	e0fffe17 	ldw	r3,-8(fp)
81146404:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81146408:	e0bffd17 	ldw	r2,-12(fp)
8114640c:	e0ffff17 	ldw	r3,-4(fp)
81146410:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81146414:	e0bffd17 	ldw	r2,-12(fp)
81146418:	e0c00117 	ldw	r3,4(fp)
8114641c:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81146420:	e0800217 	ldw	r2,8(fp)
81146424:	10e00034 	orhi	r3,r2,32768
81146428:	e0bffd17 	ldw	r2,-12(fp)
8114642c:	10c00315 	stw	r3,12(r2)
    
    return 0;
81146430:	0005883a 	mov	r2,zero
}
81146434:	e037883a 	mov	sp,fp
81146438:	df000017 	ldw	fp,0(sp)
8114643c:	dec00104 	addi	sp,sp,4
81146440:	f800283a 	ret

81146444 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81146444:	defff604 	addi	sp,sp,-40
81146448:	de00012e 	bgeu	sp,et,81146450 <alt_msgdma_construct_extended_descriptor+0xc>
8114644c:	003b68fa 	trap	3
81146450:	df000915 	stw	fp,36(sp)
81146454:	df000904 	addi	fp,sp,36
81146458:	e13ff715 	stw	r4,-36(fp)
8114645c:	e17ff815 	stw	r5,-32(fp)
81146460:	e1bff915 	stw	r6,-28(fp)
81146464:	e1fffa15 	stw	r7,-24(fp)
81146468:	e1800317 	ldw	r6,12(fp)
8114646c:	e1400417 	ldw	r5,16(fp)
81146470:	e1000517 	ldw	r4,20(fp)
81146474:	e0c00617 	ldw	r3,24(fp)
81146478:	e0800717 	ldw	r2,28(fp)
8114647c:	e1bffb0d 	sth	r6,-20(fp)
81146480:	e17ffc05 	stb	r5,-16(fp)
81146484:	e13ffd05 	stb	r4,-12(fp)
81146488:	e0fffe0d 	sth	r3,-8(fp)
8114648c:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
81146490:	e0bff717 	ldw	r2,-36(fp)
81146494:	10c01217 	ldw	r3,72(r2)
81146498:	e0800117 	ldw	r2,4(fp)
8114649c:	18801936 	bltu	r3,r2,81146504 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811464a0:	e13ff717 	ldw	r4,-36(fp)
811464a4:	20801317 	ldw	r2,76(r4)
811464a8:	20c01417 	ldw	r3,80(r4)
811464ac:	e13ffe0b 	ldhu	r4,-8(fp)
811464b0:	213fffcc 	andi	r4,r4,65535
811464b4:	2015883a 	mov	r10,r4
811464b8:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
811464bc:	1ac01136 	bltu	r3,r11,81146504 <alt_msgdma_construct_extended_descriptor+0xc0>
811464c0:	58c0011e 	bne	r11,r3,811464c8 <alt_msgdma_construct_extended_descriptor+0x84>
811464c4:	12800f36 	bltu	r2,r10,81146504 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811464c8:	e13ff717 	ldw	r4,-36(fp)
811464cc:	20801317 	ldw	r2,76(r4)
811464d0:	20c01417 	ldw	r3,80(r4)
811464d4:	e13fff0b 	ldhu	r4,-4(fp)
811464d8:	213fffcc 	andi	r4,r4,65535
811464dc:	2011883a 	mov	r8,r4
811464e0:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811464e4:	1a400736 	bltu	r3,r9,81146504 <alt_msgdma_construct_extended_descriptor+0xc0>
811464e8:	48c0011e 	bne	r9,r3,811464f0 <alt_msgdma_construct_extended_descriptor+0xac>
811464ec:	12000536 	bltu	r2,r8,81146504 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811464f0:	e0bff717 	ldw	r2,-36(fp)
811464f4:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811464f8:	10803fcc 	andi	r2,r2,255
811464fc:	10800060 	cmpeqi	r2,r2,1
81146500:	1000021e 	bne	r2,zero,8114650c <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81146504:	00bffa84 	movi	r2,-22
81146508:	00002106 	br	81146590 <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
8114650c:	e0bff817 	ldw	r2,-32(fp)
81146510:	e0fff917 	ldw	r3,-28(fp)
81146514:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
81146518:	e0bff817 	ldw	r2,-32(fp)
8114651c:	e0fffa17 	ldw	r3,-24(fp)
81146520:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81146524:	e0bff817 	ldw	r2,-32(fp)
81146528:	e0c00117 	ldw	r3,4(fp)
8114652c:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81146530:	e0bff817 	ldw	r2,-32(fp)
81146534:	e0fffb0b 	ldhu	r3,-20(fp)
81146538:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
8114653c:	e0bff817 	ldw	r2,-32(fp)
81146540:	e0fffc03 	ldbu	r3,-16(fp)
81146544:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81146548:	e0bff817 	ldw	r2,-32(fp)
8114654c:	e0fffd03 	ldbu	r3,-12(fp)
81146550:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81146554:	e0bff817 	ldw	r2,-32(fp)
81146558:	e0fffe0b 	ldhu	r3,-8(fp)
8114655c:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
81146560:	e0bff817 	ldw	r2,-32(fp)
81146564:	e0ffff0b 	ldhu	r3,-4(fp)
81146568:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
8114656c:	e0bff817 	ldw	r2,-32(fp)
81146570:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81146574:	e0bff817 	ldw	r2,-32(fp)
81146578:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8114657c:	e0800217 	ldw	r2,8(fp)
81146580:	10e00034 	orhi	r3,r2,32768
81146584:	e0bff817 	ldw	r2,-32(fp)
81146588:	10c00715 	stw	r3,28(r2)

  return 0 ;
8114658c:	0005883a 	mov	r2,zero

}
81146590:	e037883a 	mov	sp,fp
81146594:	df000017 	ldw	fp,0(sp)
81146598:	dec00104 	addi	sp,sp,4
8114659c:	f800283a 	ret

811465a0 <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811465a0:	deffee04 	addi	sp,sp,-72
811465a4:	de00012e 	bgeu	sp,et,811465ac <alt_msgdma_descriptor_async_transfer+0xc>
811465a8:	003b68fa 	trap	3
811465ac:	dfc01115 	stw	ra,68(sp)
811465b0:	df001015 	stw	fp,64(sp)
811465b4:	df001004 	addi	fp,sp,64
811465b8:	e13ffd15 	stw	r4,-12(fp)
811465bc:	e17ffe15 	stw	r5,-8(fp)
811465c0:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
811465c4:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
811465c8:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
811465cc:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811465d0:	e0bffd17 	ldw	r2,-12(fp)
811465d4:	10800317 	ldw	r2,12(r2)
811465d8:	10800204 	addi	r2,r2,8
811465dc:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811465e0:	10bfffcc 	andi	r2,r2,65535
811465e4:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811465e8:	e0bffd17 	ldw	r2,-12(fp)
811465ec:	10800317 	ldw	r2,12(r2)
811465f0:	10800204 	addi	r2,r2,8
811465f4:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811465f8:	1004d43a 	srli	r2,r2,16
811465fc:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81146600:	e0bffd17 	ldw	r2,-12(fp)
81146604:	10800917 	ldw	r2,36(r2)
81146608:	e0fff417 	ldw	r3,-48(fp)
8114660c:	1880042e 	bgeu	r3,r2,81146620 <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
81146610:	e0bffd17 	ldw	r2,-12(fp)
81146614:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81146618:	e0fff317 	ldw	r3,-52(fp)
8114661c:	18800236 	bltu	r3,r2,81146628 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
81146620:	00bff904 	movi	r2,-28
81146624:	0000a906 	br	811468cc <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81146628:	e0bffd17 	ldw	r2,-12(fp)
8114662c:	10801817 	ldw	r2,96(r2)
81146630:	e0bff615 	stw	r2,-40(fp)
81146634:	e03ffc0d 	sth	zero,-16(fp)
81146638:	e0bffc0b 	ldhu	r2,-16(fp)
8114663c:	e0fffc84 	addi	r3,fp,-14
81146640:	180d883a 	mov	r6,r3
81146644:	100b883a 	mov	r5,r2
81146648:	e13ff617 	ldw	r4,-40(fp)
8114664c:	113cb180 	call	8113cb18 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81146650:	00800804 	movi	r2,32
81146654:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146658:	0005303a 	rdctl	r2,status
8114665c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146660:	e0fff717 	ldw	r3,-36(fp)
81146664:	00bfff84 	movi	r2,-2
81146668:	1884703a 	and	r2,r3,r2
8114666c:	1001703a 	wrctl	status,r2
  
  return context;
81146670:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81146674:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81146678:	e0bffd17 	ldw	r2,-12(fp)
8114667c:	10800317 	ldw	r2,12(r2)
81146680:	10800104 	addi	r2,r2,4
81146684:	e0fff117 	ldw	r3,-60(fp)
81146688:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
8114668c:	e0bffd17 	ldw	r2,-12(fp)
81146690:	10800317 	ldw	r2,12(r2)
81146694:	e0fffd17 	ldw	r3,-12(fp)
81146698:	18c00317 	ldw	r3,12(r3)
8114669c:	18c00037 	ldwio	r3,0(r3)
811466a0:	10c00035 	stwio	r3,0(r2)
811466a4:	e0bff217 	ldw	r2,-56(fp)
811466a8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811466ac:	e0bffb17 	ldw	r2,-20(fp)
811466b0:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
811466b4:	e0bffe17 	ldw	r2,-8(fp)
811466b8:	10001e26 	beq	r2,zero,81146734 <alt_msgdma_descriptor_async_transfer+0x194>
811466bc:	e0bfff17 	ldw	r2,-4(fp)
811466c0:	10001c1e 	bne	r2,zero,81146734 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811466c4:	00001106 	br	8114670c <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811466c8:	01000044 	movi	r4,1
811466cc:	11342a00 	call	811342a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811466d0:	e0bff00b 	ldhu	r2,-64(fp)
811466d4:	1084e230 	cmpltui	r2,r2,5000
811466d8:	1000091e 	bne	r2,zero,81146700 <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
811466dc:	01204574 	movhi	r4,33045
811466e0:	213acb04 	addi	r4,r4,-5332
811466e4:	11489f40 	call	811489f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811466e8:	e0bffd17 	ldw	r2,-12(fp)
811466ec:	10801817 	ldw	r2,96(r2)
811466f0:	1009883a 	mov	r4,r2
811466f4:	113cea00 	call	8113cea0 <OSSemPost>
				
                return -ETIME;
811466f8:	00bff084 	movi	r2,-62
811466fc:	00007306 	br	811468cc <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81146700:	e0bff00b 	ldhu	r2,-64(fp)
81146704:	10800044 	addi	r2,r2,1
81146708:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
8114670c:	e0bffd17 	ldw	r2,-12(fp)
81146710:	10c00317 	ldw	r3,12(r2)
81146714:	e0bffd17 	ldw	r2,-12(fp)
81146718:	10800417 	ldw	r2,16(r2)
8114671c:	e1bffe17 	ldw	r6,-8(fp)
81146720:	100b883a 	mov	r5,r2
81146724:	1809883a 	mov	r4,r3
81146728:	11460540 	call	81146054 <alt_msgdma_write_standard_descriptor>
8114672c:	103fe61e 	bne	r2,zero,811466c8 <__reset+0xfb1266c8>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81146730:	00002706 	br	811467d0 <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81146734:	e0bffe17 	ldw	r2,-8(fp)
81146738:	10001f1e 	bne	r2,zero,811467b8 <alt_msgdma_descriptor_async_transfer+0x218>
8114673c:	e0bfff17 	ldw	r2,-4(fp)
81146740:	10001d26 	beq	r2,zero,811467b8 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81146744:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81146748:	00001106 	br	81146790 <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
8114674c:	01000044 	movi	r4,1
81146750:	11342a00 	call	811342a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81146754:	e0bff00b 	ldhu	r2,-64(fp)
81146758:	1084e230 	cmpltui	r2,r2,5000
8114675c:	1000091e 	bne	r2,zero,81146784 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
81146760:	01204574 	movhi	r4,33045
81146764:	213ae104 	addi	r4,r4,-5244
81146768:	11489f40 	call	811489f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
8114676c:	e0bffd17 	ldw	r2,-12(fp)
81146770:	10801817 	ldw	r2,96(r2)
81146774:	1009883a 	mov	r4,r2
81146778:	113cea00 	call	8113cea0 <OSSemPost>
				
                return -ETIME;
8114677c:	00bff084 	movi	r2,-62
81146780:	00005206 	br	811468cc <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81146784:	e0bff00b 	ldhu	r2,-64(fp)
81146788:	10800044 	addi	r2,r2,1
8114678c:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81146790:	e0bffd17 	ldw	r2,-12(fp)
81146794:	10c00317 	ldw	r3,12(r2)
81146798:	e0bffd17 	ldw	r2,-12(fp)
8114679c:	10800417 	ldw	r2,16(r2)
811467a0:	e1bfff17 	ldw	r6,-4(fp)
811467a4:	100b883a 	mov	r5,r2
811467a8:	1809883a 	mov	r4,r3
811467ac:	11460f00 	call	811460f0 <alt_msgdma_write_extended_descriptor>
811467b0:	103fe61e 	bne	r2,zero,8114674c <__reset+0xfb12674c>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
811467b4:	00000606 	br	811467d0 <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
811467b8:	e0bffd17 	ldw	r2,-12(fp)
811467bc:	10801817 	ldw	r2,96(r2)
811467c0:	1009883a 	mov	r4,r2
811467c4:	113cea00 	call	8113cea0 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811467c8:	00bfffc4 	movi	r2,-1
811467cc:	00003f06 	br	811468cc <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
811467d0:	e0bffd17 	ldw	r2,-12(fp)
811467d4:	10800b17 	ldw	r2,44(r2)
811467d8:	10001c26 	beq	r2,zero,8114684c <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
811467dc:	e0bffd17 	ldw	r2,-12(fp)
811467e0:	10c00d17 	ldw	r3,52(r2)
811467e4:	e0bff117 	ldw	r2,-60(fp)
811467e8:	1884b03a 	or	r2,r3,r2
811467ec:	10800514 	ori	r2,r2,20
811467f0:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811467f4:	e0fff117 	ldw	r3,-60(fp)
811467f8:	00bff7c4 	movi	r2,-33
811467fc:	1884703a 	and	r2,r3,r2
81146800:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146804:	0005303a 	rdctl	r2,status
81146808:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114680c:	e0fff917 	ldw	r3,-28(fp)
81146810:	00bfff84 	movi	r2,-2
81146814:	1884703a 	and	r2,r3,r2
81146818:	1001703a 	wrctl	status,r2
  
  return context;
8114681c:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
81146820:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81146824:	e0bffd17 	ldw	r2,-12(fp)
81146828:	10800317 	ldw	r2,12(r2)
8114682c:	10800104 	addi	r2,r2,4
81146830:	e0fff117 	ldw	r3,-60(fp)
81146834:	10c00035 	stwio	r3,0(r2)
81146838:	e0bff217 	ldw	r2,-56(fp)
8114683c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146840:	e0bff517 	ldw	r2,-44(fp)
81146844:	1001703a 	wrctl	status,r2
81146848:	00001b06 	br	811468b8 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
8114684c:	e0bffd17 	ldw	r2,-12(fp)
81146850:	10c00d17 	ldw	r3,52(r2)
81146854:	e0bff117 	ldw	r2,-60(fp)
81146858:	1884b03a 	or	r2,r3,r2
8114685c:	10800114 	ori	r2,r2,4
81146860:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81146864:	e0fff117 	ldw	r3,-60(fp)
81146868:	00bff3c4 	movi	r2,-49
8114686c:	1884703a 	and	r2,r3,r2
81146870:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146874:	0005303a 	rdctl	r2,status
81146878:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114687c:	e0fffa17 	ldw	r3,-24(fp)
81146880:	00bfff84 	movi	r2,-2
81146884:	1884703a 	and	r2,r3,r2
81146888:	1001703a 	wrctl	status,r2
  
  return context;
8114688c:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
81146890:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81146894:	e0bffd17 	ldw	r2,-12(fp)
81146898:	10800317 	ldw	r2,12(r2)
8114689c:	10800104 	addi	r2,r2,4
811468a0:	e0fff117 	ldw	r3,-60(fp)
811468a4:	10c00035 	stwio	r3,0(r2)
811468a8:	e0bff217 	ldw	r2,-56(fp)
811468ac:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811468b0:	e0bff817 	ldw	r2,-32(fp)
811468b4:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
811468b8:	e0bffd17 	ldw	r2,-12(fp)
811468bc:	10801817 	ldw	r2,96(r2)
811468c0:	1009883a 	mov	r4,r2
811468c4:	113cea00 	call	8113cea0 <OSSemPost>
    
    return 0;
811468c8:	0005883a 	mov	r2,zero
}
811468cc:	e037883a 	mov	sp,fp
811468d0:	dfc00117 	ldw	ra,4(sp)
811468d4:	df000017 	ldw	fp,0(sp)
811468d8:	dec00204 	addi	sp,sp,8
811468dc:	f800283a 	ret

811468e0 <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811468e0:	deffee04 	addi	sp,sp,-72
811468e4:	de00012e 	bgeu	sp,et,811468ec <alt_msgdma_descriptor_sync_transfer+0xc>
811468e8:	003b68fa 	trap	3
811468ec:	dfc01115 	stw	ra,68(sp)
811468f0:	df001015 	stw	fp,64(sp)
811468f4:	df001004 	addi	fp,sp,64
811468f8:	e13ffd15 	stw	r4,-12(fp)
811468fc:	e17ffe15 	stw	r5,-8(fp)
81146900:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
81146904:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
81146908:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
8114690c:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
81146910:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81146914:	e0bffd17 	ldw	r2,-12(fp)
81146918:	10800317 	ldw	r2,12(r2)
8114691c:	10800204 	addi	r2,r2,8
81146920:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81146924:	10bfffcc 	andi	r2,r2,65535
81146928:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114692c:	e0bffd17 	ldw	r2,-12(fp)
81146930:	10800317 	ldw	r2,12(r2)
81146934:	10800204 	addi	r2,r2,8
81146938:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
8114693c:	1004d43a 	srli	r2,r2,16
81146940:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81146944:	00807804 	movi	r2,480
81146948:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
8114694c:	00001906 	br	811469b4 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
81146950:	01000044 	movi	r4,1
81146954:	11342a00 	call	811342a0 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81146958:	e0bff10b 	ldhu	r2,-60(fp)
8114695c:	1084e230 	cmpltui	r2,r2,5000
81146960:	1000051e 	bne	r2,zero,81146978 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81146964:	01204574 	movhi	r4,33045
81146968:	213af704 	addi	r4,r4,-5156
8114696c:	11489f40 	call	811489f4 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
81146970:	00bff084 	movi	r2,-62
81146974:	0000d706 	br	81146cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81146978:	e0bff10b 	ldhu	r2,-60(fp)
8114697c:	10800044 	addi	r2,r2,1
81146980:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81146984:	e0bffd17 	ldw	r2,-12(fp)
81146988:	10800317 	ldw	r2,12(r2)
8114698c:	10800204 	addi	r2,r2,8
81146990:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81146994:	10bfffcc 	andi	r2,r2,65535
81146998:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
8114699c:	e0bffd17 	ldw	r2,-12(fp)
811469a0:	10800317 	ldw	r2,12(r2)
811469a4:	10800204 	addi	r2,r2,8
811469a8:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
811469ac:	1004d43a 	srli	r2,r2,16
811469b0:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811469b4:	e0bffd17 	ldw	r2,-12(fp)
811469b8:	10800917 	ldw	r2,36(r2)
811469bc:	e0fff317 	ldw	r3,-52(fp)
811469c0:	18bfe32e 	bgeu	r3,r2,81146950 <__reset+0xfb126950>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811469c4:	e0bffd17 	ldw	r2,-12(fp)
811469c8:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811469cc:	e0fff217 	ldw	r3,-56(fp)
811469d0:	18bfdf2e 	bgeu	r3,r2,81146950 <__reset+0xfb126950>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
811469d4:	e0bffd17 	ldw	r2,-12(fp)
811469d8:	10801817 	ldw	r2,96(r2)
811469dc:	e0bff815 	stw	r2,-32(fp)
811469e0:	e03ffc0d 	sth	zero,-16(fp)
811469e4:	e0bffc0b 	ldhu	r2,-16(fp)
811469e8:	e0fffc84 	addi	r3,fp,-14
811469ec:	180d883a 	mov	r6,r3
811469f0:	100b883a 	mov	r5,r2
811469f4:	e13ff817 	ldw	r4,-32(fp)
811469f8:	113cb180 	call	8113cb18 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811469fc:	0005303a 	rdctl	r2,status
81146a00:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146a04:	e0fffb17 	ldw	r3,-20(fp)
81146a08:	00bfff84 	movi	r2,-2
81146a0c:	1884703a 	and	r2,r3,r2
81146a10:	1001703a 	wrctl	status,r2
  
  return context;
81146a14:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
81146a18:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81146a1c:	e0bffd17 	ldw	r2,-12(fp)
81146a20:	10800317 	ldw	r2,12(r2)
81146a24:	10800104 	addi	r2,r2,4
81146a28:	00c00804 	movi	r3,32
81146a2c:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81146a30:	e0bffd17 	ldw	r2,-12(fp)
81146a34:	10800317 	ldw	r2,12(r2)
81146a38:	e0fffd17 	ldw	r3,-12(fp)
81146a3c:	18c00317 	ldw	r3,12(r3)
81146a40:	18c00037 	ldwio	r3,0(r3)
81146a44:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81146a48:	e0bffe17 	ldw	r2,-8(fp)
81146a4c:	10001f26 	beq	r2,zero,81146acc <alt_msgdma_descriptor_sync_transfer+0x1ec>
81146a50:	e0bfff17 	ldw	r2,-4(fp)
81146a54:	10001d1e 	bne	r2,zero,81146acc <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81146a58:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81146a5c:	00001106 	br	81146aa4 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81146a60:	01000044 	movi	r4,1
81146a64:	11342a00 	call	811342a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81146a68:	e0bff10b 	ldhu	r2,-60(fp)
81146a6c:	1084e230 	cmpltui	r2,r2,5000
81146a70:	1000091e 	bne	r2,zero,81146a98 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81146a74:	01204574 	movhi	r4,33045
81146a78:	213b0b04 	addi	r4,r4,-5076
81146a7c:	11489f40 	call	811489f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81146a80:	e0bffd17 	ldw	r2,-12(fp)
81146a84:	10801817 	ldw	r2,96(r2)
81146a88:	1009883a 	mov	r4,r2
81146a8c:	113cea00 	call	8113cea0 <OSSemPost>
				
                return -ETIME;
81146a90:	00bff084 	movi	r2,-62
81146a94:	00008f06 	br	81146cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81146a98:	e0bff10b 	ldhu	r2,-60(fp)
81146a9c:	10800044 	addi	r2,r2,1
81146aa0:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81146aa4:	e0bffd17 	ldw	r2,-12(fp)
81146aa8:	10c00317 	ldw	r3,12(r2)
81146aac:	e0bffd17 	ldw	r2,-12(fp)
81146ab0:	10800417 	ldw	r2,16(r2)
81146ab4:	e1bffe17 	ldw	r6,-8(fp)
81146ab8:	100b883a 	mov	r5,r2
81146abc:	1809883a 	mov	r4,r3
81146ac0:	11460540 	call	81146054 <alt_msgdma_write_standard_descriptor>
81146ac4:	103fe61e 	bne	r2,zero,81146a60 <__reset+0xfb126a60>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81146ac8:	00002706 	br	81146b68 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81146acc:	e0bffe17 	ldw	r2,-8(fp)
81146ad0:	10001f1e 	bne	r2,zero,81146b50 <alt_msgdma_descriptor_sync_transfer+0x270>
81146ad4:	e0bfff17 	ldw	r2,-4(fp)
81146ad8:	10001d26 	beq	r2,zero,81146b50 <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81146adc:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81146ae0:	00001106 	br	81146b28 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81146ae4:	01000044 	movi	r4,1
81146ae8:	11342a00 	call	811342a0 <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81146aec:	e0bff10b 	ldhu	r2,-60(fp)
81146af0:	1084e230 	cmpltui	r2,r2,5000
81146af4:	1000091e 	bne	r2,zero,81146b1c <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81146af8:	01204574 	movhi	r4,33045
81146afc:	213b1c04 	addi	r4,r4,-5008
81146b00:	11489f40 	call	811489f4 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81146b04:	e0bffd17 	ldw	r2,-12(fp)
81146b08:	10801817 	ldw	r2,96(r2)
81146b0c:	1009883a 	mov	r4,r2
81146b10:	113cea00 	call	8113cea0 <OSSemPost>
				
                return -ETIME;
81146b14:	00bff084 	movi	r2,-62
81146b18:	00006e06 	br	81146cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81146b1c:	e0bff10b 	ldhu	r2,-60(fp)
81146b20:	10800044 	addi	r2,r2,1
81146b24:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81146b28:	e0bffd17 	ldw	r2,-12(fp)
81146b2c:	10c00317 	ldw	r3,12(r2)
81146b30:	e0bffd17 	ldw	r2,-12(fp)
81146b34:	10800417 	ldw	r2,16(r2)
81146b38:	e1bfff17 	ldw	r6,-4(fp)
81146b3c:	100b883a 	mov	r5,r2
81146b40:	1809883a 	mov	r4,r3
81146b44:	11460f00 	call	811460f0 <alt_msgdma_write_extended_descriptor>
81146b48:	103fe61e 	bne	r2,zero,81146ae4 <__reset+0xfb126ae4>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81146b4c:	00000606 	br	81146b68 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81146b50:	e0bffd17 	ldw	r2,-12(fp)
81146b54:	10801817 	ldw	r2,96(r2)
81146b58:	1009883a 	mov	r4,r2
81146b5c:	113cea00 	call	8113cea0 <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81146b60:	00bfffc4 	movi	r2,-1
81146b64:	00005b06 	br	81146cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81146b68:	e0bffd17 	ldw	r2,-12(fp)
81146b6c:	10800317 	ldw	r2,12(r2)
81146b70:	10800104 	addi	r2,r2,4
81146b74:	e0fffd17 	ldw	r3,-12(fp)
81146b78:	19000d17 	ldw	r4,52(r3)
81146b7c:	00fff2c4 	movi	r3,-53
81146b80:	20c6703a 	and	r3,r4,r3
81146b84:	18c00114 	ori	r3,r3,4
81146b88:	10c00035 	stwio	r3,0(r2)
81146b8c:	e0bff517 	ldw	r2,-44(fp)
81146b90:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146b94:	e0bff717 	ldw	r2,-36(fp)
81146b98:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81146b9c:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81146ba0:	e0bffd17 	ldw	r2,-12(fp)
81146ba4:	10800317 	ldw	r2,12(r2)
81146ba8:	10800037 	ldwio	r2,0(r2)
81146bac:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81146bb0:	00001506 	br	81146c08 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81146bb4:	01000044 	movi	r4,1
81146bb8:	11342a00 	call	811342a0 <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81146bbc:	e0bff10b 	ldhu	r2,-60(fp)
81146bc0:	1084e230 	cmpltui	r2,r2,5000
81146bc4:	1000091e 	bne	r2,zero,81146bec <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81146bc8:	01204574 	movhi	r4,33045
81146bcc:	213b2d04 	addi	r4,r4,-4940
81146bd0:	11489f40 	call	811489f4 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81146bd4:	e0bffd17 	ldw	r2,-12(fp)
81146bd8:	10801817 	ldw	r2,96(r2)
81146bdc:	1009883a 	mov	r4,r2
81146be0:	113cea00 	call	8113cea0 <OSSemPost>
			
            return -ETIME;
81146be4:	00bff084 	movi	r2,-62
81146be8:	00003a06 	br	81146cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81146bec:	e0bff10b 	ldhu	r2,-60(fp)
81146bf0:	10800044 	addi	r2,r2,1
81146bf4:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81146bf8:	e0bffd17 	ldw	r2,-12(fp)
81146bfc:	10800317 	ldw	r2,12(r2)
81146c00:	10800037 	ldwio	r2,0(r2)
81146c04:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81146c08:	e0fff017 	ldw	r3,-64(fp)
81146c0c:	e0bff617 	ldw	r2,-40(fp)
81146c10:	1884703a 	and	r2,r3,r2
81146c14:	1000031e 	bne	r2,zero,81146c24 <alt_msgdma_descriptor_sync_transfer+0x344>
81146c18:	e0bff017 	ldw	r2,-64(fp)
81146c1c:	1080004c 	andi	r2,r2,1
81146c20:	103fe41e 	bne	r2,zero,81146bb4 <__reset+0xfb126bb4>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81146c24:	e0fff017 	ldw	r3,-64(fp)
81146c28:	e0bff617 	ldw	r2,-40(fp)
81146c2c:	1884703a 	and	r2,r3,r2
81146c30:	10000626 	beq	r2,zero,81146c4c <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81146c34:	e0bffd17 	ldw	r2,-12(fp)
81146c38:	10801817 	ldw	r2,96(r2)
81146c3c:	1009883a 	mov	r4,r2
81146c40:	113cea00 	call	8113cea0 <OSSemPost>
		
        return error;
81146c44:	e0bff617 	ldw	r2,-40(fp)
81146c48:	00002206 	br	81146cd4 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81146c4c:	e0bffd17 	ldw	r2,-12(fp)
81146c50:	10800317 	ldw	r2,12(r2)
81146c54:	10800104 	addi	r2,r2,4
81146c58:	10800037 	ldwio	r2,0(r2)
81146c5c:	10800814 	ori	r2,r2,32
81146c60:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146c64:	0005303a 	rdctl	r2,status
81146c68:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146c6c:	e0fffa17 	ldw	r3,-24(fp)
81146c70:	00bfff84 	movi	r2,-2
81146c74:	1884703a 	and	r2,r3,r2
81146c78:	1001703a 	wrctl	status,r2
  
  return context;
81146c7c:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81146c80:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81146c84:	e0bffd17 	ldw	r2,-12(fp)
81146c88:	10800317 	ldw	r2,12(r2)
81146c8c:	10800104 	addi	r2,r2,4
81146c90:	e0fff417 	ldw	r3,-48(fp)
81146c94:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81146c98:	e0bffd17 	ldw	r2,-12(fp)
81146c9c:	10800317 	ldw	r2,12(r2)
81146ca0:	e0fffd17 	ldw	r3,-12(fp)
81146ca4:	18c00317 	ldw	r3,12(r3)
81146ca8:	18c00037 	ldwio	r3,0(r3)
81146cac:	10c00035 	stwio	r3,0(r2)
81146cb0:	e0bff517 	ldw	r2,-44(fp)
81146cb4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146cb8:	e0bff917 	ldw	r2,-28(fp)
81146cbc:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81146cc0:	e0bffd17 	ldw	r2,-12(fp)
81146cc4:	10801817 	ldw	r2,96(r2)
81146cc8:	1009883a 	mov	r4,r2
81146ccc:	113cea00 	call	8113cea0 <OSSemPost>
    
    return 0;
81146cd0:	0005883a 	mov	r2,zero

}
81146cd4:	e037883a 	mov	sp,fp
81146cd8:	dfc00117 	ldw	ra,4(sp)
81146cdc:	df000017 	ldw	fp,0(sp)
81146ce0:	dec00204 	addi	sp,sp,8
81146ce4:	f800283a 	ret

81146ce8 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81146ce8:	defff804 	addi	sp,sp,-32
81146cec:	de00012e 	bgeu	sp,et,81146cf4 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81146cf0:	003b68fa 	trap	3
81146cf4:	dfc00715 	stw	ra,28(sp)
81146cf8:	df000615 	stw	fp,24(sp)
81146cfc:	df000604 	addi	fp,sp,24
81146d00:	e13ffc15 	stw	r4,-16(fp)
81146d04:	e17ffd15 	stw	r5,-12(fp)
81146d08:	e1bffe15 	stw	r6,-8(fp)
81146d0c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81146d10:	e0800217 	ldw	r2,8(fp)
81146d14:	d8800115 	stw	r2,4(sp)
81146d18:	e0bfff17 	ldw	r2,-4(fp)
81146d1c:	d8800015 	stw	r2,0(sp)
81146d20:	e1fffe17 	ldw	r7,-8(fp)
81146d24:	000d883a 	mov	r6,zero
81146d28:	e17ffd17 	ldw	r5,-12(fp)
81146d2c:	e13ffc17 	ldw	r4,-16(fp)
81146d30:	11463b00 	call	811463b0 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81146d34:	e037883a 	mov	sp,fp
81146d38:	dfc00117 	ldw	ra,4(sp)
81146d3c:	df000017 	ldw	fp,0(sp)
81146d40:	dec00204 	addi	sp,sp,8
81146d44:	f800283a 	ret

81146d48 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81146d48:	defff804 	addi	sp,sp,-32
81146d4c:	de00012e 	bgeu	sp,et,81146d54 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81146d50:	003b68fa 	trap	3
81146d54:	dfc00715 	stw	ra,28(sp)
81146d58:	df000615 	stw	fp,24(sp)
81146d5c:	df000604 	addi	fp,sp,24
81146d60:	e13ffc15 	stw	r4,-16(fp)
81146d64:	e17ffd15 	stw	r5,-12(fp)
81146d68:	e1bffe15 	stw	r6,-8(fp)
81146d6c:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81146d70:	e0800217 	ldw	r2,8(fp)
81146d74:	d8800115 	stw	r2,4(sp)
81146d78:	e0bfff17 	ldw	r2,-4(fp)
81146d7c:	d8800015 	stw	r2,0(sp)
81146d80:	000f883a 	mov	r7,zero
81146d84:	e1bffe17 	ldw	r6,-8(fp)
81146d88:	e17ffd17 	ldw	r5,-12(fp)
81146d8c:	e13ffc17 	ldw	r4,-16(fp)
81146d90:	11463b00 	call	811463b0 <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81146d94:	e037883a 	mov	sp,fp
81146d98:	dfc00117 	ldw	ra,4(sp)
81146d9c:	df000017 	ldw	fp,0(sp)
81146da0:	dec00204 	addi	sp,sp,8
81146da4:	f800283a 	ret

81146da8 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81146da8:	defff804 	addi	sp,sp,-32
81146dac:	de00012e 	bgeu	sp,et,81146db4 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81146db0:	003b68fa 	trap	3
81146db4:	dfc00715 	stw	ra,28(sp)
81146db8:	df000615 	stw	fp,24(sp)
81146dbc:	df000604 	addi	fp,sp,24
81146dc0:	e13ffc15 	stw	r4,-16(fp)
81146dc4:	e17ffd15 	stw	r5,-12(fp)
81146dc8:	e1bffe15 	stw	r6,-8(fp)
81146dcc:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81146dd0:	e0800317 	ldw	r2,12(fp)
81146dd4:	d8800115 	stw	r2,4(sp)
81146dd8:	e0800217 	ldw	r2,8(fp)
81146ddc:	d8800015 	stw	r2,0(sp)
81146de0:	e1ffff17 	ldw	r7,-4(fp)
81146de4:	e1bffe17 	ldw	r6,-8(fp)
81146de8:	e17ffd17 	ldw	r5,-12(fp)
81146dec:	e13ffc17 	ldw	r4,-16(fp)
81146df0:	11463b00 	call	811463b0 <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81146df4:	e037883a 	mov	sp,fp
81146df8:	dfc00117 	ldw	ra,4(sp)
81146dfc:	df000017 	ldw	fp,0(sp)
81146e00:	dec00204 	addi	sp,sp,8
81146e04:	f800283a 	ret

81146e08 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81146e08:	defff004 	addi	sp,sp,-64
81146e0c:	de00012e 	bgeu	sp,et,81146e14 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81146e10:	003b68fa 	trap	3
81146e14:	dfc00f15 	stw	ra,60(sp)
81146e18:	df000e15 	stw	fp,56(sp)
81146e1c:	df000e04 	addi	fp,sp,56
81146e20:	e13ff915 	stw	r4,-28(fp)
81146e24:	e17ffa15 	stw	r5,-24(fp)
81146e28:	e1bffb15 	stw	r6,-20(fp)
81146e2c:	e1fffc15 	stw	r7,-16(fp)
81146e30:	e1000317 	ldw	r4,12(fp)
81146e34:	e0c00417 	ldw	r3,16(fp)
81146e38:	e0800517 	ldw	r2,20(fp)
81146e3c:	e13ffd0d 	sth	r4,-12(fp)
81146e40:	e0fffe05 	stb	r3,-8(fp)
81146e44:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81146e48:	e0bffd0b 	ldhu	r2,-12(fp)
81146e4c:	e0fffe03 	ldbu	r3,-8(fp)
81146e50:	e13fff0b 	ldhu	r4,-4(fp)
81146e54:	d9000615 	stw	r4,24(sp)
81146e58:	d8000515 	stw	zero,20(sp)
81146e5c:	d8c00415 	stw	r3,16(sp)
81146e60:	d8000315 	stw	zero,12(sp)
81146e64:	d8800215 	stw	r2,8(sp)
81146e68:	e0800217 	ldw	r2,8(fp)
81146e6c:	d8800115 	stw	r2,4(sp)
81146e70:	e0bffc17 	ldw	r2,-16(fp)
81146e74:	d8800015 	stw	r2,0(sp)
81146e78:	e1fffb17 	ldw	r7,-20(fp)
81146e7c:	000d883a 	mov	r6,zero
81146e80:	e17ffa17 	ldw	r5,-24(fp)
81146e84:	e13ff917 	ldw	r4,-28(fp)
81146e88:	11464440 	call	81146444 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81146e8c:	e037883a 	mov	sp,fp
81146e90:	dfc00117 	ldw	ra,4(sp)
81146e94:	df000017 	ldw	fp,0(sp)
81146e98:	dec00204 	addi	sp,sp,8
81146e9c:	f800283a 	ret

81146ea0 <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81146ea0:	defff004 	addi	sp,sp,-64
81146ea4:	de00012e 	bgeu	sp,et,81146eac <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81146ea8:	003b68fa 	trap	3
81146eac:	dfc00f15 	stw	ra,60(sp)
81146eb0:	df000e15 	stw	fp,56(sp)
81146eb4:	df000e04 	addi	fp,sp,56
81146eb8:	e13ff915 	stw	r4,-28(fp)
81146ebc:	e17ffa15 	stw	r5,-24(fp)
81146ec0:	e1bffb15 	stw	r6,-20(fp)
81146ec4:	e1fffc15 	stw	r7,-16(fp)
81146ec8:	e1000317 	ldw	r4,12(fp)
81146ecc:	e0c00417 	ldw	r3,16(fp)
81146ed0:	e0800517 	ldw	r2,20(fp)
81146ed4:	e13ffd0d 	sth	r4,-12(fp)
81146ed8:	e0fffe05 	stb	r3,-8(fp)
81146edc:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81146ee0:	e0bffd0b 	ldhu	r2,-12(fp)
81146ee4:	e0fffe03 	ldbu	r3,-8(fp)
81146ee8:	e13fff0b 	ldhu	r4,-4(fp)
81146eec:	d8000615 	stw	zero,24(sp)
81146ef0:	d9000515 	stw	r4,20(sp)
81146ef4:	d8000415 	stw	zero,16(sp)
81146ef8:	d8c00315 	stw	r3,12(sp)
81146efc:	d8800215 	stw	r2,8(sp)
81146f00:	e0800217 	ldw	r2,8(fp)
81146f04:	d8800115 	stw	r2,4(sp)
81146f08:	e0bffc17 	ldw	r2,-16(fp)
81146f0c:	d8800015 	stw	r2,0(sp)
81146f10:	000f883a 	mov	r7,zero
81146f14:	e1bffb17 	ldw	r6,-20(fp)
81146f18:	e17ffa17 	ldw	r5,-24(fp)
81146f1c:	e13ff917 	ldw	r4,-28(fp)
81146f20:	11464440 	call	81146444 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81146f24:	e037883a 	mov	sp,fp
81146f28:	dfc00117 	ldw	ra,4(sp)
81146f2c:	df000017 	ldw	fp,0(sp)
81146f30:	dec00204 	addi	sp,sp,8
81146f34:	f800283a 	ret

81146f38 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81146f38:	deffee04 	addi	sp,sp,-72
81146f3c:	de00012e 	bgeu	sp,et,81146f44 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81146f40:	003b68fa 	trap	3
81146f44:	dfc01115 	stw	ra,68(sp)
81146f48:	df001015 	stw	fp,64(sp)
81146f4c:	df001004 	addi	fp,sp,64
81146f50:	e13ff715 	stw	r4,-36(fp)
81146f54:	e17ff815 	stw	r5,-32(fp)
81146f58:	e1bff915 	stw	r6,-28(fp)
81146f5c:	e1fffa15 	stw	r7,-24(fp)
81146f60:	e1800417 	ldw	r6,16(fp)
81146f64:	e1400517 	ldw	r5,20(fp)
81146f68:	e1000617 	ldw	r4,24(fp)
81146f6c:	e0c00717 	ldw	r3,28(fp)
81146f70:	e0800817 	ldw	r2,32(fp)
81146f74:	e1bffb0d 	sth	r6,-20(fp)
81146f78:	e17ffc05 	stb	r5,-16(fp)
81146f7c:	e13ffd05 	stb	r4,-12(fp)
81146f80:	e0fffe0d 	sth	r3,-8(fp)
81146f84:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81146f88:	e0bffb0b 	ldhu	r2,-20(fp)
81146f8c:	e0fffc03 	ldbu	r3,-16(fp)
81146f90:	e13ffd03 	ldbu	r4,-12(fp)
81146f94:	e17ffe0b 	ldhu	r5,-8(fp)
81146f98:	e1bfff0b 	ldhu	r6,-4(fp)
81146f9c:	d9800615 	stw	r6,24(sp)
81146fa0:	d9400515 	stw	r5,20(sp)
81146fa4:	d9000415 	stw	r4,16(sp)
81146fa8:	d8c00315 	stw	r3,12(sp)
81146fac:	d8800215 	stw	r2,8(sp)
81146fb0:	e0800317 	ldw	r2,12(fp)
81146fb4:	d8800115 	stw	r2,4(sp)
81146fb8:	e0800217 	ldw	r2,8(fp)
81146fbc:	d8800015 	stw	r2,0(sp)
81146fc0:	e1fffa17 	ldw	r7,-24(fp)
81146fc4:	e1bff917 	ldw	r6,-28(fp)
81146fc8:	e17ff817 	ldw	r5,-32(fp)
81146fcc:	e13ff717 	ldw	r4,-36(fp)
81146fd0:	11464440 	call	81146444 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81146fd4:	e037883a 	mov	sp,fp
81146fd8:	dfc00117 	ldw	ra,4(sp)
81146fdc:	df000017 	ldw	fp,0(sp)
81146fe0:	dec00204 	addi	sp,sp,8
81146fe4:	f800283a 	ret

81146fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81146fe8:	defffb04 	addi	sp,sp,-20
81146fec:	de00012e 	bgeu	sp,et,81146ff4 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81146ff0:	003b68fa 	trap	3
81146ff4:	df000415 	stw	fp,16(sp)
81146ff8:	df000404 	addi	fp,sp,16
81146ffc:	e13ffc15 	stw	r4,-16(fp)
81147000:	e17ffd15 	stw	r5,-12(fp)
81147004:	e1bffe15 	stw	r6,-8(fp)
81147008:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
8114700c:	e0bffc17 	ldw	r2,-16(fp)
81147010:	10c01217 	ldw	r3,72(r2)
81147014:	e0800117 	ldw	r2,4(fp)
81147018:	18800436 	bltu	r3,r2,8114702c <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
8114701c:	e0bffc17 	ldw	r2,-16(fp)
81147020:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81147024:	10803fcc 	andi	r2,r2,255
81147028:	10000226 	beq	r2,zero,81147034 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
8114702c:	00bffa84 	movi	r2,-22
81147030:	00001406 	br	81147084 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81147034:	e0bffd17 	ldw	r2,-12(fp)
81147038:	e0fffe17 	ldw	r3,-8(fp)
8114703c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
81147040:	e0bffd17 	ldw	r2,-12(fp)
81147044:	e0ffff17 	ldw	r3,-4(fp)
81147048:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114704c:	e0bffd17 	ldw	r2,-12(fp)
81147050:	e0c00117 	ldw	r3,4(fp)
81147054:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81147058:	e0fffd17 	ldw	r3,-12(fp)
8114705c:	e0bffd17 	ldw	r2,-12(fp)
81147060:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81147064:	e0c00217 	ldw	r3,8(fp)
81147068:	00900034 	movhi	r2,16384
8114706c:	10bfffc4 	addi	r2,r2,-1
81147070:	1884703a 	and	r2,r3,r2
81147074:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81147078:	e0bffd17 	ldw	r2,-12(fp)
8114707c:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
81147080:	0005883a 	mov	r2,zero
}
81147084:	e037883a 	mov	sp,fp
81147088:	df000017 	ldw	fp,0(sp)
8114708c:	dec00104 	addi	sp,sp,4
81147090:	f800283a 	ret

81147094 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81147094:	defff404 	addi	sp,sp,-48
81147098:	de00012e 	bgeu	sp,et,811470a0 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
8114709c:	003b68fa 	trap	3
811470a0:	df000b15 	stw	fp,44(sp)
811470a4:	df000b04 	addi	fp,sp,44
811470a8:	e13ff715 	stw	r4,-36(fp)
811470ac:	e17ff815 	stw	r5,-32(fp)
811470b0:	e1bff915 	stw	r6,-28(fp)
811470b4:	e1fffa15 	stw	r7,-24(fp)
811470b8:	e1800517 	ldw	r6,20(fp)
811470bc:	e1400617 	ldw	r5,24(fp)
811470c0:	e1000717 	ldw	r4,28(fp)
811470c4:	e0c00817 	ldw	r3,32(fp)
811470c8:	e0800917 	ldw	r2,36(fp)
811470cc:	e1bffb0d 	sth	r6,-20(fp)
811470d0:	e17ffc05 	stb	r5,-16(fp)
811470d4:	e13ffd05 	stb	r4,-12(fp)
811470d8:	e0fffe0d 	sth	r3,-8(fp)
811470dc:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811470e0:	e0bff717 	ldw	r2,-36(fp)
811470e4:	10c01217 	ldw	r3,72(r2)
811470e8:	e0800317 	ldw	r2,12(fp)
811470ec:	18801936 	bltu	r3,r2,81147154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811470f0:	e13ff717 	ldw	r4,-36(fp)
811470f4:	20801317 	ldw	r2,76(r4)
811470f8:	20c01417 	ldw	r3,80(r4)
811470fc:	e13ffe0b 	ldhu	r4,-8(fp)
81147100:	213fffcc 	andi	r4,r4,65535
81147104:	2015883a 	mov	r10,r4
81147108:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
8114710c:	1ac01136 	bltu	r3,r11,81147154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81147110:	58c0011e 	bne	r11,r3,81147118 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
81147114:	12800f36 	bltu	r2,r10,81147154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81147118:	e13ff717 	ldw	r4,-36(fp)
8114711c:	20801317 	ldw	r2,76(r4)
81147120:	20c01417 	ldw	r3,80(r4)
81147124:	e13fff0b 	ldhu	r4,-4(fp)
81147128:	213fffcc 	andi	r4,r4,65535
8114712c:	2011883a 	mov	r8,r4
81147130:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81147134:	1a400736 	bltu	r3,r9,81147154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81147138:	48c0011e 	bne	r9,r3,81147140 <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
8114713c:	12000536 	bltu	r2,r8,81147154 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
81147140:	e0bff717 	ldw	r2,-36(fp)
81147144:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81147148:	10803fcc 	andi	r2,r2,255
8114714c:	10800060 	cmpeqi	r2,r2,1
81147150:	1000021e 	bne	r2,zero,8114715c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81147154:	00bffa84 	movi	r2,-22
81147158:	00003106 	br	81147220 <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
8114715c:	e0bff817 	ldw	r2,-32(fp)
81147160:	e0fff917 	ldw	r3,-28(fp)
81147164:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81147168:	e0bff817 	ldw	r2,-32(fp)
8114716c:	e0fffa17 	ldw	r3,-24(fp)
81147170:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81147174:	e0bff817 	ldw	r2,-32(fp)
81147178:	e0c00117 	ldw	r3,4(fp)
8114717c:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
81147180:	e0bff817 	ldw	r2,-32(fp)
81147184:	e0c00217 	ldw	r3,8(fp)
81147188:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
8114718c:	e0bff817 	ldw	r2,-32(fp)
81147190:	e0c00317 	ldw	r3,12(fp)
81147194:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81147198:	e0bff817 	ldw	r2,-32(fp)
8114719c:	e0fffb0b 	ldhu	r3,-20(fp)
811471a0:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
811471a4:	e0bff817 	ldw	r2,-32(fp)
811471a8:	e0fffc03 	ldbu	r3,-16(fp)
811471ac:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
811471b0:	e0bff817 	ldw	r2,-32(fp)
811471b4:	e0fffd03 	ldbu	r3,-12(fp)
811471b8:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
811471bc:	e0bff817 	ldw	r2,-32(fp)
811471c0:	e0fffe0b 	ldhu	r3,-8(fp)
811471c4:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
811471c8:	e0bff817 	ldw	r2,-32(fp)
811471cc:	e0ffff0b 	ldhu	r3,-4(fp)
811471d0:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
811471d4:	e0bff817 	ldw	r2,-32(fp)
811471d8:	1019883a 	mov	r12,r2
811471dc:	001b883a 	mov	r13,zero
811471e0:	e33ff515 	stw	r12,-44(fp)
811471e4:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
811471e8:	e0fff517 	ldw	r3,-44(fp)
811471ec:	e0bff817 	ldw	r2,-32(fp)
811471f0:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
811471f4:	e0fff617 	ldw	r3,-40(fp)
811471f8:	e0bff817 	ldw	r2,-32(fp)
811471fc:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81147200:	e0c00417 	ldw	r3,16(fp)
81147204:	00900034 	movhi	r2,16384
81147208:	10bfffc4 	addi	r2,r2,-1
8114720c:	1884703a 	and	r2,r3,r2
81147210:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
81147214:	e0bff817 	ldw	r2,-32(fp)
81147218:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
8114721c:	0005883a 	mov	r2,zero
}
81147220:	e037883a 	mov	sp,fp
81147224:	df000017 	ldw	fp,0(sp)
81147228:	dec00104 	addi	sp,sp,4
8114722c:	f800283a 	ret

81147230 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
81147230:	defff804 	addi	sp,sp,-32
81147234:	de00012e 	bgeu	sp,et,8114723c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81147238:	003b68fa 	trap	3
8114723c:	dfc00715 	stw	ra,28(sp)
81147240:	df000615 	stw	fp,24(sp)
81147244:	df000604 	addi	fp,sp,24
81147248:	e13ffc15 	stw	r4,-16(fp)
8114724c:	e17ffd15 	stw	r5,-12(fp)
81147250:	e1bffe15 	stw	r6,-8(fp)
81147254:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81147258:	e0800317 	ldw	r2,12(fp)
8114725c:	d8800115 	stw	r2,4(sp)
81147260:	e0800217 	ldw	r2,8(fp)
81147264:	d8800015 	stw	r2,0(sp)
81147268:	e1ffff17 	ldw	r7,-4(fp)
8114726c:	e1bffe17 	ldw	r6,-8(fp)
81147270:	e17ffd17 	ldw	r5,-12(fp)
81147274:	e13ffc17 	ldw	r4,-16(fp)
81147278:	1146fe80 	call	81146fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
8114727c:	e037883a 	mov	sp,fp
81147280:	dfc00117 	ldw	ra,4(sp)
81147284:	df000017 	ldw	fp,0(sp)
81147288:	dec00204 	addi	sp,sp,8
8114728c:	f800283a 	ret

81147290 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81147290:	defff804 	addi	sp,sp,-32
81147294:	de00012e 	bgeu	sp,et,8114729c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81147298:	003b68fa 	trap	3
8114729c:	dfc00715 	stw	ra,28(sp)
811472a0:	df000615 	stw	fp,24(sp)
811472a4:	df000604 	addi	fp,sp,24
811472a8:	e13ffc15 	stw	r4,-16(fp)
811472ac:	e17ffd15 	stw	r5,-12(fp)
811472b0:	e1bffe15 	stw	r6,-8(fp)
811472b4:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811472b8:	e0800217 	ldw	r2,8(fp)
811472bc:	d8800115 	stw	r2,4(sp)
811472c0:	e0bfff17 	ldw	r2,-4(fp)
811472c4:	d8800015 	stw	r2,0(sp)
811472c8:	e1fffe17 	ldw	r7,-8(fp)
811472cc:	000d883a 	mov	r6,zero
811472d0:	e17ffd17 	ldw	r5,-12(fp)
811472d4:	e13ffc17 	ldw	r4,-16(fp)
811472d8:	1146fe80 	call	81146fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
811472dc:	e037883a 	mov	sp,fp
811472e0:	dfc00117 	ldw	ra,4(sp)
811472e4:	df000017 	ldw	fp,0(sp)
811472e8:	dec00204 	addi	sp,sp,8
811472ec:	f800283a 	ret

811472f0 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
811472f0:	defff804 	addi	sp,sp,-32
811472f4:	de00012e 	bgeu	sp,et,811472fc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
811472f8:	003b68fa 	trap	3
811472fc:	dfc00715 	stw	ra,28(sp)
81147300:	df000615 	stw	fp,24(sp)
81147304:	df000604 	addi	fp,sp,24
81147308:	e13ffc15 	stw	r4,-16(fp)
8114730c:	e17ffd15 	stw	r5,-12(fp)
81147310:	e1bffe15 	stw	r6,-8(fp)
81147314:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81147318:	e0800217 	ldw	r2,8(fp)
8114731c:	d8800115 	stw	r2,4(sp)
81147320:	e0bfff17 	ldw	r2,-4(fp)
81147324:	d8800015 	stw	r2,0(sp)
81147328:	000f883a 	mov	r7,zero
8114732c:	e1bffe17 	ldw	r6,-8(fp)
81147330:	e17ffd17 	ldw	r5,-12(fp)
81147334:	e13ffc17 	ldw	r4,-16(fp)
81147338:	1146fe80 	call	81146fe8 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
8114733c:	e037883a 	mov	sp,fp
81147340:	dfc00117 	ldw	ra,4(sp)
81147344:	df000017 	ldw	fp,0(sp)
81147348:	dec00204 	addi	sp,sp,8
8114734c:	f800283a 	ret

81147350 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
81147350:	deffee04 	addi	sp,sp,-72
81147354:	de00012e 	bgeu	sp,et,8114735c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81147358:	003b68fa 	trap	3
8114735c:	dfc01115 	stw	ra,68(sp)
81147360:	df001015 	stw	fp,64(sp)
81147364:	df001004 	addi	fp,sp,64
81147368:	e13ff915 	stw	r4,-28(fp)
8114736c:	e17ffa15 	stw	r5,-24(fp)
81147370:	e1bffb15 	stw	r6,-20(fp)
81147374:	e1fffc15 	stw	r7,-16(fp)
81147378:	e1000417 	ldw	r4,16(fp)
8114737c:	e0c00517 	ldw	r3,20(fp)
81147380:	e0800617 	ldw	r2,24(fp)
81147384:	e13ffd0d 	sth	r4,-12(fp)
81147388:	e0fffe05 	stb	r3,-8(fp)
8114738c:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
81147390:	e0bffd0b 	ldhu	r2,-12(fp)
81147394:	e0fffe03 	ldbu	r3,-8(fp)
81147398:	e13fff0b 	ldhu	r4,-4(fp)
8114739c:	d9000815 	stw	r4,32(sp)
811473a0:	d8000715 	stw	zero,28(sp)
811473a4:	d8c00615 	stw	r3,24(sp)
811473a8:	d8000515 	stw	zero,20(sp)
811473ac:	d8800415 	stw	r2,16(sp)
811473b0:	e0800317 	ldw	r2,12(fp)
811473b4:	d8800315 	stw	r2,12(sp)
811473b8:	e0800217 	ldw	r2,8(fp)
811473bc:	d8800215 	stw	r2,8(sp)
811473c0:	e0bffc17 	ldw	r2,-16(fp)
811473c4:	d8800115 	stw	r2,4(sp)
811473c8:	e0bffb17 	ldw	r2,-20(fp)
811473cc:	d8800015 	stw	r2,0(sp)
811473d0:	000f883a 	mov	r7,zero
811473d4:	000d883a 	mov	r6,zero
811473d8:	e17ffa17 	ldw	r5,-24(fp)
811473dc:	e13ff917 	ldw	r4,-28(fp)
811473e0:	11470940 	call	81147094 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
811473e4:	e037883a 	mov	sp,fp
811473e8:	dfc00117 	ldw	ra,4(sp)
811473ec:	df000017 	ldw	fp,0(sp)
811473f0:	dec00204 	addi	sp,sp,8
811473f4:	f800283a 	ret

811473f8 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
811473f8:	deffee04 	addi	sp,sp,-72
811473fc:	de00012e 	bgeu	sp,et,81147404 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
81147400:	003b68fa 	trap	3
81147404:	dfc01115 	stw	ra,68(sp)
81147408:	df001015 	stw	fp,64(sp)
8114740c:	df001004 	addi	fp,sp,64
81147410:	e13ff915 	stw	r4,-28(fp)
81147414:	e17ffa15 	stw	r5,-24(fp)
81147418:	e1bffb15 	stw	r6,-20(fp)
8114741c:	e1fffc15 	stw	r7,-16(fp)
81147420:	e1000417 	ldw	r4,16(fp)
81147424:	e0c00517 	ldw	r3,20(fp)
81147428:	e0800617 	ldw	r2,24(fp)
8114742c:	e13ffd0d 	sth	r4,-12(fp)
81147430:	e0fffe05 	stb	r3,-8(fp)
81147434:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81147438:	e0bffd0b 	ldhu	r2,-12(fp)
8114743c:	e0fffe03 	ldbu	r3,-8(fp)
81147440:	e13fff0b 	ldhu	r4,-4(fp)
81147444:	d8000815 	stw	zero,32(sp)
81147448:	d9000715 	stw	r4,28(sp)
8114744c:	d8000615 	stw	zero,24(sp)
81147450:	d8c00515 	stw	r3,20(sp)
81147454:	d8800415 	stw	r2,16(sp)
81147458:	e0800317 	ldw	r2,12(fp)
8114745c:	d8800315 	stw	r2,12(sp)
81147460:	e0800217 	ldw	r2,8(fp)
81147464:	d8800215 	stw	r2,8(sp)
81147468:	d8000115 	stw	zero,4(sp)
8114746c:	d8000015 	stw	zero,0(sp)
81147470:	e1fffc17 	ldw	r7,-16(fp)
81147474:	e1bffb17 	ldw	r6,-20(fp)
81147478:	e17ffa17 	ldw	r5,-24(fp)
8114747c:	e13ff917 	ldw	r4,-28(fp)
81147480:	11470940 	call	81147094 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81147484:	e037883a 	mov	sp,fp
81147488:	dfc00117 	ldw	ra,4(sp)
8114748c:	df000017 	ldw	fp,0(sp)
81147490:	dec00204 	addi	sp,sp,8
81147494:	f800283a 	ret

81147498 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81147498:	deffec04 	addi	sp,sp,-80
8114749c:	de00012e 	bgeu	sp,et,811474a4 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
811474a0:	003b68fa 	trap	3
811474a4:	dfc01315 	stw	ra,76(sp)
811474a8:	df001215 	stw	fp,72(sp)
811474ac:	df001204 	addi	fp,sp,72
811474b0:	e13ff715 	stw	r4,-36(fp)
811474b4:	e17ff815 	stw	r5,-32(fp)
811474b8:	e1bff915 	stw	r6,-28(fp)
811474bc:	e1fffa15 	stw	r7,-24(fp)
811474c0:	e1800617 	ldw	r6,24(fp)
811474c4:	e1400717 	ldw	r5,28(fp)
811474c8:	e1000817 	ldw	r4,32(fp)
811474cc:	e0c00917 	ldw	r3,36(fp)
811474d0:	e0800a17 	ldw	r2,40(fp)
811474d4:	e1bffb0d 	sth	r6,-20(fp)
811474d8:	e17ffc05 	stb	r5,-16(fp)
811474dc:	e13ffd05 	stb	r4,-12(fp)
811474e0:	e0fffe0d 	sth	r3,-8(fp)
811474e4:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811474e8:	e0bffb0b 	ldhu	r2,-20(fp)
811474ec:	e0fffc03 	ldbu	r3,-16(fp)
811474f0:	e13ffd03 	ldbu	r4,-12(fp)
811474f4:	e17ffe0b 	ldhu	r5,-8(fp)
811474f8:	e1bfff0b 	ldhu	r6,-4(fp)
811474fc:	d9800815 	stw	r6,32(sp)
81147500:	d9400715 	stw	r5,28(sp)
81147504:	d9000615 	stw	r4,24(sp)
81147508:	d8c00515 	stw	r3,20(sp)
8114750c:	d8800415 	stw	r2,16(sp)
81147510:	e0800517 	ldw	r2,20(fp)
81147514:	d8800315 	stw	r2,12(sp)
81147518:	e0800417 	ldw	r2,16(fp)
8114751c:	d8800215 	stw	r2,8(sp)
81147520:	e0800317 	ldw	r2,12(fp)
81147524:	d8800115 	stw	r2,4(sp)
81147528:	e0800217 	ldw	r2,8(fp)
8114752c:	d8800015 	stw	r2,0(sp)
81147530:	e1fffa17 	ldw	r7,-24(fp)
81147534:	e1bff917 	ldw	r6,-28(fp)
81147538:	e17ff817 	ldw	r5,-32(fp)
8114753c:	e13ff717 	ldw	r4,-36(fp)
81147540:	11470940 	call	81147094 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81147544:	e037883a 	mov	sp,fp
81147548:	dfc00117 	ldw	ra,4(sp)
8114754c:	df000017 	ldw	fp,0(sp)
81147550:	dec00204 	addi	sp,sp,8
81147554:	f800283a 	ret

81147558 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81147558:	defffc04 	addi	sp,sp,-16
8114755c:	de00012e 	bgeu	sp,et,81147564 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
81147560:	003b68fa 	trap	3
81147564:	df000315 	stw	fp,12(sp)
81147568:	df000304 	addi	fp,sp,12
8114756c:	e13ffe15 	stw	r4,-8(fp)
81147570:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81147574:	e0bfff17 	ldw	r2,-4(fp)
81147578:	1000021e 	bne	r2,zero,81147584 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
8114757c:	00bffa84 	movi	r2,-22
81147580:	00002f06 	br	81147640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81147584:	e0bfff17 	ldw	r2,-4(fp)
81147588:	10c00317 	ldw	r3,12(r2)
8114758c:	e0bfff17 	ldw	r2,-4(fp)
81147590:	18800226 	beq	r3,r2,8114759c <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81147594:	00bffa84 	movi	r2,-22
81147598:	00002906 	br	81147640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
8114759c:	e0bffe17 	ldw	r2,-8(fp)
811475a0:	10800017 	ldw	r2,0(r2)
811475a4:	1000051e 	bne	r2,zero,811475bc <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
811475a8:	e0bffe17 	ldw	r2,-8(fp)
811475ac:	e0ffff17 	ldw	r3,-4(fp)
811475b0:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
811475b4:	0005883a 	mov	r2,zero
811475b8:	00002106 	br	81147640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
811475bc:	e0bffe17 	ldw	r2,-8(fp)
811475c0:	10c00017 	ldw	r3,0(r2)
811475c4:	e0bfff17 	ldw	r2,-4(fp)
811475c8:	1880021e 	bne	r3,r2,811475d4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811475cc:	00bffa84 	movi	r2,-22
811475d0:	00001b06 	br	81147640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811475d4:	e0bffe17 	ldw	r2,-8(fp)
811475d8:	10800017 	ldw	r2,0(r2)
811475dc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811475e0:	00000906 	br	81147608 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
811475e4:	e0bffd17 	ldw	r2,-12(fp)
811475e8:	10c00317 	ldw	r3,12(r2)
811475ec:	e0bfff17 	ldw	r2,-4(fp)
811475f0:	1880021e 	bne	r3,r2,811475fc <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811475f4:	00bffa84 	movi	r2,-22
811475f8:	00001106 	br	81147640 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811475fc:	e0bffd17 	ldw	r2,-12(fp)
81147600:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
81147604:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
81147608:	e0bffd17 	ldw	r2,-12(fp)
8114760c:	10800317 	ldw	r2,12(r2)
81147610:	e0fffe17 	ldw	r3,-8(fp)
81147614:	18c00017 	ldw	r3,0(r3)
81147618:	10fff21e 	bne	r2,r3,811475e4 <__reset+0xfb1275e4>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
8114761c:	e0ffff17 	ldw	r3,-4(fp)
81147620:	e0bffd17 	ldw	r2,-12(fp)
81147624:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81147628:	e0bffe17 	ldw	r2,-8(fp)
8114762c:	10800017 	ldw	r2,0(r2)
81147630:	1007883a 	mov	r3,r2
81147634:	e0bfff17 	ldw	r2,-4(fp)
81147638:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
8114763c:	0005883a 	mov	r2,zero
}
81147640:	e037883a 	mov	sp,fp
81147644:	df000017 	ldw	fp,0(sp)
81147648:	dec00104 	addi	sp,sp,4
8114764c:	f800283a 	ret

81147650 <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
81147650:	defff804 	addi	sp,sp,-32
81147654:	de00012e 	bgeu	sp,et,8114765c <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81147658:	003b68fa 	trap	3
8114765c:	df000715 	stw	fp,28(sp)
81147660:	df000704 	addi	fp,sp,28
81147664:	e13ffe15 	stw	r4,-8(fp)
81147668:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
8114766c:	e13fff17 	ldw	r4,-4(fp)
81147670:	2000021e 	bne	r4,zero,8114767c <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81147674:	00bffa84 	movi	r2,-22
81147678:	00005906 	br	811477e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
8114767c:	e13fff17 	ldw	r4,-4(fp)
81147680:	2015883a 	mov	r10,r4
81147684:	0017883a 	mov	r11,zero
81147688:	e2bffc15 	stw	r10,-16(fp)
8114768c:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81147690:	e13fff17 	ldw	r4,-4(fp)
81147694:	21400317 	ldw	r5,12(r4)
81147698:	e13ffc17 	ldw	r4,-16(fp)
8114769c:	29000626 	beq	r5,r4,811476b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
811476a0:	e13fff17 	ldw	r4,-4(fp)
811476a4:	21400b17 	ldw	r5,44(r4)
811476a8:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
811476ac:	29000226 	beq	r5,r4,811476b8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
811476b0:	00bffa84 	movi	r2,-22
811476b4:	00004a06 	br	811477e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
811476b8:	e13ffe17 	ldw	r4,-8(fp)
811476bc:	21000017 	ldw	r4,0(r4)
811476c0:	2000051e 	bne	r4,zero,811476d8 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
811476c4:	e0bffe17 	ldw	r2,-8(fp)
811476c8:	e0ffff17 	ldw	r3,-4(fp)
811476cc:	10c00015 	stw	r3,0(r2)
		return 0;
811476d0:	0005883a 	mov	r2,zero
811476d4:	00004206 	br	811477e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
811476d8:	e13ffe17 	ldw	r4,-8(fp)
811476dc:	21400017 	ldw	r5,0(r4)
811476e0:	e13fff17 	ldw	r4,-4(fp)
811476e4:	2900021e 	bne	r5,r4,811476f0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811476e8:	00bffa84 	movi	r2,-22
811476ec:	00003c06 	br	811477e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811476f0:	e13ffe17 	ldw	r4,-8(fp)
811476f4:	21000017 	ldw	r4,0(r4)
811476f8:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811476fc:	e13ffe17 	ldw	r4,-8(fp)
81147700:	21000017 	ldw	r4,0(r4)
81147704:	2011883a 	mov	r8,r4
81147708:	0013883a 	mov	r9,zero
8114770c:	e23ffa15 	stw	r8,-24(fp)
81147710:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81147714:	00001806 	br	81147778 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
81147718:	e13fff17 	ldw	r4,-4(fp)
8114771c:	200d883a 	mov	r6,r4
81147720:	000f883a 	mov	r7,zero
81147724:	e1bffc15 	stw	r6,-16(fp)
81147728:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
8114772c:	e13ff917 	ldw	r4,-28(fp)
81147730:	21400317 	ldw	r5,12(r4)
81147734:	e13ffc17 	ldw	r4,-16(fp)
81147738:	2900061e 	bne	r5,r4,81147754 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
8114773c:	e13ff917 	ldw	r4,-28(fp)
81147740:	21400b17 	ldw	r5,44(r4)
81147744:	e13ffd17 	ldw	r4,-12(fp)
81147748:	2900021e 	bne	r5,r4,81147754 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
8114774c:	00bffa84 	movi	r2,-22
81147750:	00002306 	br	811477e0 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81147754:	e13ff917 	ldw	r4,-28(fp)
81147758:	21000317 	ldw	r4,12(r4)
8114775c:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81147760:	e13ff917 	ldw	r4,-28(fp)
81147764:	21000b17 	ldw	r4,44(r4)
81147768:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
8114776c:	e13ffc17 	ldw	r4,-16(fp)
81147770:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81147774:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81147778:	e13ff917 	ldw	r4,-28(fp)
8114777c:	21400317 	ldw	r5,12(r4)
81147780:	e13ffa17 	ldw	r4,-24(fp)
81147784:	29000426 	beq	r5,r4,81147798 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81147788:	e13ff917 	ldw	r4,-28(fp)
8114778c:	21400b17 	ldw	r5,44(r4)
81147790:	e13ffb17 	ldw	r4,-20(fp)
81147794:	293fe01e 	bne	r5,r4,81147718 <__reset+0xfb127718>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81147798:	e13fff17 	ldw	r4,-4(fp)
8114779c:	2005883a 	mov	r2,r4
811477a0:	0007883a 	mov	r3,zero
811477a4:	e0bffc15 	stw	r2,-16(fp)
811477a8:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
811477ac:	e0fffc17 	ldw	r3,-16(fp)
811477b0:	e0bff917 	ldw	r2,-28(fp)
811477b4:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
811477b8:	e0fffd17 	ldw	r3,-12(fp)
811477bc:	e0bff917 	ldw	r2,-28(fp)
811477c0:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
811477c4:	e0fffa17 	ldw	r3,-24(fp)
811477c8:	e0bfff17 	ldw	r2,-4(fp)
811477cc:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
811477d0:	e0fffb17 	ldw	r3,-20(fp)
811477d4:	e0bfff17 	ldw	r2,-4(fp)
811477d8:	10c00b15 	stw	r3,44(r2)
	return 0;
811477dc:	0005883a 	mov	r2,zero
}
811477e0:	e037883a 	mov	sp,fp
811477e4:	df000017 	ldw	fp,0(sp)
811477e8:	dec00104 	addi	sp,sp,4
811477ec:	f800283a 	ret

811477f0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
811477f0:	defffc04 	addi	sp,sp,-16
811477f4:	de00012e 	bgeu	sp,et,811477fc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811477f8:	003b68fa 	trap	3
811477fc:	df000315 	stw	fp,12(sp)
81147800:	df000304 	addi	fp,sp,12
81147804:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81147808:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
8114780c:	e0bfff17 	ldw	r2,-4(fp)
81147810:	1000021e 	bne	r2,zero,8114781c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81147814:	00bffa84 	movi	r2,-22
81147818:	00001906 	br	81147880 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
8114781c:	e0bfff17 	ldw	r2,-4(fp)
81147820:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81147824:	00000a06 	br	81147850 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81147828:	e0bffd17 	ldw	r2,-12(fp)
8114782c:	10800717 	ldw	r2,28(r2)
81147830:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81147834:	e0bffe17 	ldw	r2,-8(fp)
81147838:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
8114783c:	e0bffd17 	ldw	r2,-12(fp)
81147840:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81147844:	e0bffd17 	ldw	r2,-12(fp)
81147848:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
8114784c:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81147850:	e0bffd17 	ldw	r2,-12(fp)
81147854:	10c00317 	ldw	r3,12(r2)
81147858:	e0bfff17 	ldw	r2,-4(fp)
8114785c:	18bff21e 	bne	r3,r2,81147828 <__reset+0xfb127828>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
81147860:	e0bffd17 	ldw	r2,-12(fp)
81147864:	10800717 	ldw	r2,28(r2)
81147868:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
8114786c:	e0bffe17 	ldw	r2,-8(fp)
81147870:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81147874:	e0bffd17 	ldw	r2,-12(fp)
81147878:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
8114787c:	0005883a 	mov	r2,zero
}
81147880:	e037883a 	mov	sp,fp
81147884:	df000017 	ldw	fp,0(sp)
81147888:	dec00104 	addi	sp,sp,4
8114788c:	f800283a 	ret

81147890 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
81147890:	defff804 	addi	sp,sp,-32
81147894:	de00012e 	bgeu	sp,et,8114789c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81147898:	003b68fa 	trap	3
8114789c:	df000715 	stw	fp,28(sp)
811478a0:	df000704 	addi	fp,sp,28
811478a4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811478a8:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
811478ac:	e13fff17 	ldw	r4,-4(fp)
811478b0:	2000021e 	bne	r4,zero,811478bc <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811478b4:	00bffa84 	movi	r2,-22
811478b8:	00002806 	br	8114795c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811478bc:	e13fff17 	ldw	r4,-4(fp)
811478c0:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
811478c4:	e13fff17 	ldw	r4,-4(fp)
811478c8:	2005883a 	mov	r2,r4
811478cc:	0007883a 	mov	r3,zero
811478d0:	e0bffb15 	stw	r2,-20(fp)
811478d4:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811478d8:	00001006 	br	8114791c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
811478dc:	e0bff917 	ldw	r2,-28(fp)
811478e0:	10800f17 	ldw	r2,60(r2)
811478e4:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811478e8:	e0bffa17 	ldw	r2,-24(fp)
811478ec:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811478f0:	e0bff917 	ldw	r2,-28(fp)
811478f4:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811478f8:	e0bff917 	ldw	r2,-28(fp)
811478fc:	10800317 	ldw	r2,12(r2)
81147900:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
81147904:	e0bff917 	ldw	r2,-28(fp)
81147908:	10800b17 	ldw	r2,44(r2)
8114790c:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81147910:	e0bffd17 	ldw	r2,-12(fp)
81147914:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81147918:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
8114791c:	e0bff917 	ldw	r2,-28(fp)
81147920:	10c00317 	ldw	r3,12(r2)
81147924:	e0bffb17 	ldw	r2,-20(fp)
81147928:	18800426 	beq	r3,r2,8114793c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
8114792c:	e0bff917 	ldw	r2,-28(fp)
81147930:	10c00b17 	ldw	r3,44(r2)
81147934:	e0bffc17 	ldw	r2,-16(fp)
81147938:	18bfe81e 	bne	r3,r2,811478dc <__reset+0xfb1278dc>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
8114793c:	e0bff917 	ldw	r2,-28(fp)
81147940:	10800f17 	ldw	r2,60(r2)
81147944:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81147948:	e0bffa17 	ldw	r2,-24(fp)
8114794c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81147950:	e0bff917 	ldw	r2,-28(fp)
81147954:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81147958:	0005883a 	mov	r2,zero
}
8114795c:	e037883a 	mov	sp,fp
81147960:	df000017 	ldw	fp,0(sp)
81147964:	dec00104 	addi	sp,sp,4
81147968:	f800283a 	ret

8114796c <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
8114796c:	deffeb04 	addi	sp,sp,-84
81147970:	de00012e 	bgeu	sp,et,81147978 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81147974:	003b68fa 	trap	3
81147978:	dfc01415 	stw	ra,80(sp)
8114797c:	df001315 	stw	fp,76(sp)
81147980:	df001304 	addi	fp,sp,76
81147984:	e13ffb15 	stw	r4,-20(fp)
81147988:	e17ffc15 	stw	r5,-16(fp)
8114798c:	e1bffd15 	stw	r6,-12(fp)
81147990:	3807883a 	mov	r3,r7
81147994:	e0800217 	ldw	r2,8(fp)
81147998:	e0fffe05 	stb	r3,-8(fp)
8114799c:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
811479a0:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
811479a4:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
811479a8:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
811479ac:	e0bffc17 	ldw	r2,-16(fp)
811479b0:	e0bff815 	stw	r2,-32(fp)
811479b4:	e0bffd17 	ldw	r2,-12(fp)
811479b8:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
811479bc:	e0bffb17 	ldw	r2,-20(fp)
811479c0:	10801817 	ldw	r2,96(r2)
811479c4:	e0bff615 	stw	r2,-40(fp)
811479c8:	e03ff70d 	sth	zero,-36(fp)
811479cc:	e0bff70b 	ldhu	r2,-36(fp)
811479d0:	e0fffa04 	addi	r3,fp,-24
811479d4:	180d883a 	mov	r6,r3
811479d8:	100b883a 	mov	r5,r2
811479dc:	e13ff617 	ldw	r4,-40(fp)
811479e0:	113cb180 	call	8113cb18 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
811479e4:	e0bffb17 	ldw	r2,-20(fp)
811479e8:	10800617 	ldw	r2,24(r2)
811479ec:	10800037 	ldwio	r2,0(r2)
811479f0:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
811479f4:	e0bfed17 	ldw	r2,-76(fp)
811479f8:	1080004c 	andi	r2,r2,1
811479fc:	10000626 	beq	r2,zero,81147a18 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
81147a00:	e0bffb17 	ldw	r2,-20(fp)
81147a04:	10801817 	ldw	r2,96(r2)
81147a08:	1009883a 	mov	r4,r2
81147a0c:	113cea00 	call	8113cea0 <OSSemPost>
		return -EBUSY;
81147a10:	00bffc04 	movi	r2,-16
81147a14:	00009606 	br	81147c70 <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81147a18:	00800804 	movi	r2,32
81147a1c:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147a20:	0005303a 	rdctl	r2,status
81147a24:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147a28:	e0fff217 	ldw	r3,-56(fp)
81147a2c:	00bfff84 	movi	r2,-2
81147a30:	1884703a 	and	r2,r3,r2
81147a34:	1001703a 	wrctl	status,r2
  
  return context;
81147a38:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81147a3c:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81147a40:	e0bffb17 	ldw	r2,-20(fp)
81147a44:	10800317 	ldw	r2,12(r2)
81147a48:	10800104 	addi	r2,r2,4
81147a4c:	e0ffee17 	ldw	r3,-72(fp)
81147a50:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
81147a54:	e0bffb17 	ldw	r2,-20(fp)
81147a58:	10800317 	ldw	r2,12(r2)
81147a5c:	e0fffb17 	ldw	r3,-20(fp)
81147a60:	18c00317 	ldw	r3,12(r3)
81147a64:	18c00037 	ldwio	r3,0(r3)
81147a68:	10c00035 	stwio	r3,0(r2)
81147a6c:	e0bfef17 	ldw	r2,-68(fp)
81147a70:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147a74:	e0bff017 	ldw	r2,-64(fp)
81147a78:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81147a7c:	e0bffb17 	ldw	r2,-20(fp)
81147a80:	10800b17 	ldw	r2,44(r2)
81147a84:	10002326 	beq	r2,zero,81147b14 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81147a88:	e0bffb17 	ldw	r2,-20(fp)
81147a8c:	10c00d17 	ldw	r3,52(r2)
81147a90:	e0bfee17 	ldw	r2,-72(fp)
81147a94:	1884b03a 	or	r2,r3,r2
81147a98:	10800514 	ori	r2,r2,20
81147a9c:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81147aa0:	e0ffee17 	ldw	r3,-72(fp)
81147aa4:	00bff7c4 	movi	r2,-33
81147aa8:	1884703a 	and	r2,r3,r2
81147aac:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81147ab0:	e0bfed17 	ldw	r2,-76(fp)
81147ab4:	10800214 	ori	r2,r2,8
81147ab8:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147abc:	0005303a 	rdctl	r2,status
81147ac0:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147ac4:	e0fff417 	ldw	r3,-48(fp)
81147ac8:	00bfff84 	movi	r2,-2
81147acc:	1884703a 	and	r2,r3,r2
81147ad0:	1001703a 	wrctl	status,r2
  
  return context;
81147ad4:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81147ad8:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81147adc:	e0bffb17 	ldw	r2,-20(fp)
81147ae0:	10800317 	ldw	r2,12(r2)
81147ae4:	10800104 	addi	r2,r2,4
81147ae8:	e0ffee17 	ldw	r3,-72(fp)
81147aec:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81147af0:	e0bffb17 	ldw	r2,-20(fp)
81147af4:	10800617 	ldw	r2,24(r2)
81147af8:	e0ffed17 	ldw	r3,-76(fp)
81147afc:	10c00035 	stwio	r3,0(r2)
81147b00:	e0bfef17 	ldw	r2,-68(fp)
81147b04:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147b08:	e0bff117 	ldw	r2,-60(fp)
81147b0c:	1001703a 	wrctl	status,r2
81147b10:	00002306 	br	81147ba0 <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81147b14:	e0bffb17 	ldw	r2,-20(fp)
81147b18:	10c00d17 	ldw	r3,52(r2)
81147b1c:	e0bfee17 	ldw	r2,-72(fp)
81147b20:	1884b03a 	or	r2,r3,r2
81147b24:	10800114 	ori	r2,r2,4
81147b28:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
81147b2c:	e0ffee17 	ldw	r3,-72(fp)
81147b30:	00bff3c4 	movi	r2,-49
81147b34:	1884703a 	and	r2,r3,r2
81147b38:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
81147b3c:	e0ffed17 	ldw	r3,-76(fp)
81147b40:	00bffdc4 	movi	r2,-9
81147b44:	1884703a 	and	r2,r3,r2
81147b48:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81147b4c:	0005303a 	rdctl	r2,status
81147b50:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81147b54:	e0fff517 	ldw	r3,-44(fp)
81147b58:	00bfff84 	movi	r2,-2
81147b5c:	1884703a 	and	r2,r3,r2
81147b60:	1001703a 	wrctl	status,r2
  
  return context;
81147b64:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81147b68:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81147b6c:	e0bffb17 	ldw	r2,-20(fp)
81147b70:	10800317 	ldw	r2,12(r2)
81147b74:	10800104 	addi	r2,r2,4
81147b78:	e0ffee17 	ldw	r3,-72(fp)
81147b7c:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81147b80:	e0bffb17 	ldw	r2,-20(fp)
81147b84:	10800617 	ldw	r2,24(r2)
81147b88:	e0ffed17 	ldw	r3,-76(fp)
81147b8c:	10c00035 	stwio	r3,0(r2)
81147b90:	e0bfef17 	ldw	r2,-68(fp)
81147b94:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81147b98:	e0bff317 	ldw	r2,-52(fp)
81147b9c:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81147ba0:	e0bffb17 	ldw	r2,-20(fp)
81147ba4:	10800617 	ldw	r2,24(r2)
81147ba8:	10800104 	addi	r2,r2,4
81147bac:	e0fff817 	ldw	r3,-32(fp)
81147bb0:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81147bb4:	e0bffb17 	ldw	r2,-20(fp)
81147bb8:	10800617 	ldw	r2,24(r2)
81147bbc:	10800204 	addi	r2,r2,8
81147bc0:	e0fff917 	ldw	r3,-28(fp)
81147bc4:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81147bc8:	e0bffe03 	ldbu	r2,-8(fp)
81147bcc:	10000426 	beq	r2,zero,81147be0 <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81147bd0:	e0bfed17 	ldw	r2,-76(fp)
81147bd4:	10800414 	ori	r2,r2,16
81147bd8:	e0bfed15 	stw	r2,-76(fp)
81147bdc:	00000406 	br	81147bf0 <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81147be0:	e0ffed17 	ldw	r3,-76(fp)
81147be4:	00bffbc4 	movi	r2,-17
81147be8:	1884703a 	and	r2,r3,r2
81147bec:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81147bf0:	e0bfff03 	ldbu	r2,-4(fp)
81147bf4:	10000e26 	beq	r2,zero,81147c30 <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81147bf8:	e0bfed17 	ldw	r2,-76(fp)
81147bfc:	10800094 	ori	r2,r2,2
81147c00:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81147c04:	e0bffb17 	ldw	r2,-20(fp)
81147c08:	10800617 	ldw	r2,24(r2)
81147c0c:	10800304 	addi	r2,r2,12
81147c10:	10800037 	ldwio	r2,0(r2)
81147c14:	10000a1e 	bne	r2,zero,81147c40 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81147c18:	e0bffb17 	ldw	r2,-20(fp)
81147c1c:	10800617 	ldw	r2,24(r2)
81147c20:	10800304 	addi	r2,r2,12
81147c24:	00c03fc4 	movi	r3,255
81147c28:	10c00035 	stwio	r3,0(r2)
81147c2c:	00000406 	br	81147c40 <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81147c30:	e0ffed17 	ldw	r3,-76(fp)
81147c34:	00bfff44 	movi	r2,-3
81147c38:	1884703a 	and	r2,r3,r2
81147c3c:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81147c40:	e0bfed17 	ldw	r2,-76(fp)
81147c44:	10800054 	ori	r2,r2,1
81147c48:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81147c4c:	e0bffb17 	ldw	r2,-20(fp)
81147c50:	10800617 	ldw	r2,24(r2)
81147c54:	e0ffed17 	ldw	r3,-76(fp)
81147c58:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81147c5c:	e0bffb17 	ldw	r2,-20(fp)
81147c60:	10801817 	ldw	r2,96(r2)
81147c64:	1009883a 	mov	r4,r2
81147c68:	113cea00 	call	8113cea0 <OSSemPost>
	 
	 return 0;
81147c6c:	0005883a 	mov	r2,zero
}
81147c70:	e037883a 	mov	sp,fp
81147c74:	dfc00117 	ldw	ra,4(sp)
81147c78:	df000017 	ldw	fp,0(sp)
81147c7c:	dec00204 	addi	sp,sp,8
81147c80:	f800283a 	ret

81147c84 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81147c84:	defff704 	addi	sp,sp,-36
81147c88:	de00012e 	bgeu	sp,et,81147c90 <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81147c8c:	003b68fa 	trap	3
81147c90:	dfc00815 	stw	ra,32(sp)
81147c94:	df000715 	stw	fp,28(sp)
81147c98:	dc400615 	stw	r17,24(sp)
81147c9c:	dc000515 	stw	r16,20(sp)
81147ca0:	df000704 	addi	fp,sp,28
81147ca4:	e13ffa15 	stw	r4,-24(fp)
81147ca8:	e17ffb15 	stw	r5,-20(fp)
81147cac:	3007883a 	mov	r3,r6
81147cb0:	3805883a 	mov	r2,r7
81147cb4:	e0fffc05 	stb	r3,-16(fp)
81147cb8:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81147cbc:	e13ffb17 	ldw	r4,-20(fp)
81147cc0:	11477f00 	call	811477f0 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81147cc4:	10000226 	beq	r2,zero,81147cd0 <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81147cc8:	00bffa84 	movi	r2,-22
81147ccc:	00000b06 	br	81147cfc <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81147cd0:	e0bffb17 	ldw	r2,-20(fp)
81147cd4:	1021883a 	mov	r16,r2
81147cd8:	0023883a 	mov	r17,zero
81147cdc:	e0fffc03 	ldbu	r3,-16(fp)
81147ce0:	e0bffd03 	ldbu	r2,-12(fp)
81147ce4:	d8800015 	stw	r2,0(sp)
81147ce8:	180f883a 	mov	r7,r3
81147cec:	800b883a 	mov	r5,r16
81147cf0:	880d883a 	mov	r6,r17
81147cf4:	e13ffa17 	ldw	r4,-24(fp)
81147cf8:	114796c0 	call	8114796c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81147cfc:	e6fffe04 	addi	sp,fp,-8
81147d00:	dfc00317 	ldw	ra,12(sp)
81147d04:	df000217 	ldw	fp,8(sp)
81147d08:	dc400117 	ldw	r17,4(sp)
81147d0c:	dc000017 	ldw	r16,0(sp)
81147d10:	dec00404 	addi	sp,sp,16
81147d14:	f800283a 	ret

81147d18 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81147d18:	defff704 	addi	sp,sp,-36
81147d1c:	de00012e 	bgeu	sp,et,81147d24 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81147d20:	003b68fa 	trap	3
81147d24:	dfc00815 	stw	ra,32(sp)
81147d28:	df000715 	stw	fp,28(sp)
81147d2c:	dc400615 	stw	r17,24(sp)
81147d30:	dc000515 	stw	r16,20(sp)
81147d34:	df000704 	addi	fp,sp,28
81147d38:	e13ffa15 	stw	r4,-24(fp)
81147d3c:	e17ffb15 	stw	r5,-20(fp)
81147d40:	3007883a 	mov	r3,r6
81147d44:	3805883a 	mov	r2,r7
81147d48:	e0fffc05 	stb	r3,-16(fp)
81147d4c:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81147d50:	e13ffb17 	ldw	r4,-20(fp)
81147d54:	11478900 	call	81147890 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81147d58:	10000226 	beq	r2,zero,81147d64 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81147d5c:	00bffa84 	movi	r2,-22
81147d60:	00000b06 	br	81147d90 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81147d64:	e0bffb17 	ldw	r2,-20(fp)
81147d68:	1021883a 	mov	r16,r2
81147d6c:	0023883a 	mov	r17,zero
81147d70:	e0fffc03 	ldbu	r3,-16(fp)
81147d74:	e0bffd03 	ldbu	r2,-12(fp)
81147d78:	d8800015 	stw	r2,0(sp)
81147d7c:	180f883a 	mov	r7,r3
81147d80:	800b883a 	mov	r5,r16
81147d84:	880d883a 	mov	r6,r17
81147d88:	e13ffa17 	ldw	r4,-24(fp)
81147d8c:	114796c0 	call	8114796c <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81147d90:	e6fffe04 	addi	sp,fp,-8
81147d94:	dfc00317 	ldw	ra,12(sp)
81147d98:	df000217 	ldw	fp,8(sp)
81147d9c:	dc400117 	ldw	r17,4(sp)
81147da0:	dc000017 	ldw	r16,0(sp)
81147da4:	dec00404 	addi	sp,sp,16
81147da8:	f800283a 	ret

81147dac <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81147dac:	defffc04 	addi	sp,sp,-16
81147db0:	de00012e 	bgeu	sp,et,81147db8 <alt_msgdma_open+0xc>
81147db4:	003b68fa 	trap	3
81147db8:	dfc00315 	stw	ra,12(sp)
81147dbc:	df000215 	stw	fp,8(sp)
81147dc0:	df000204 	addi	fp,sp,8
81147dc4:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81147dc8:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81147dcc:	d1603504 	addi	r5,gp,-32556
81147dd0:	e13fff17 	ldw	r4,-4(fp)
81147dd4:	11483500 	call	81148350 <alt_find_dev>
81147dd8:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81147ddc:	e0bffe17 	ldw	r2,-8(fp)
81147de0:	1000041e 	bne	r2,zero,81147df4 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81147de4:	11460100 	call	81146010 <alt_get_errno>
81147de8:	1007883a 	mov	r3,r2
81147dec:	008004c4 	movi	r2,19
81147df0:	18800015 	stw	r2,0(r3)
    }

    return dev;
81147df4:	e0bffe17 	ldw	r2,-8(fp)
}
81147df8:	e037883a 	mov	sp,fp
81147dfc:	dfc00117 	ldw	ra,4(sp)
81147e00:	df000017 	ldw	fp,0(sp)
81147e04:	dec00204 	addi	sp,sp,8
81147e08:	f800283a 	ret

81147e0c <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81147e0c:	defff604 	addi	sp,sp,-40
81147e10:	de00012e 	bgeu	sp,et,81147e18 <alt_msgdma_init+0xc>
81147e14:	003b68fa 	trap	3
81147e18:	dfc00915 	stw	ra,36(sp)
81147e1c:	df000815 	stw	fp,32(sp)
81147e20:	df000804 	addi	fp,sp,32
81147e24:	e13ffd15 	stw	r4,-12(fp)
81147e28:	e17ffe15 	stw	r5,-8(fp)
81147e2c:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81147e30:	e0bffd17 	ldw	r2,-12(fp)
81147e34:	10801783 	ldbu	r2,94(r2)
81147e38:	10803fcc 	andi	r2,r2,255
81147e3c:	10000b26 	beq	r2,zero,81147e6c <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81147e40:	e0bffd17 	ldw	r2,-12(fp)
81147e44:	10800617 	ldw	r2,24(r2)
81147e48:	00c00104 	movi	r3,4
81147e4c:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81147e50:	0001883a 	nop
81147e54:	e0bffd17 	ldw	r2,-12(fp)
81147e58:	10800617 	ldw	r2,24(r2)
81147e5c:	10800037 	ldwio	r2,0(r2)
81147e60:	1080010c 	andi	r2,r2,4
81147e64:	1005d0ba 	srai	r2,r2,2
81147e68:	103ffa1e 	bne	r2,zero,81147e54 <__reset+0xfb127e54>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81147e6c:	e0bffd17 	ldw	r2,-12(fp)
81147e70:	10800317 	ldw	r2,12(r2)
81147e74:	10800104 	addi	r2,r2,4
81147e78:	00c00084 	movi	r3,2
81147e7c:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81147e80:	0001883a 	nop
81147e84:	e0bffd17 	ldw	r2,-12(fp)
81147e88:	10800317 	ldw	r2,12(r2)
81147e8c:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81147e90:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81147e94:	103ffb1e 	bne	r2,zero,81147e84 <__reset+0xfb127e84>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81147e98:	e0bffd17 	ldw	r2,-12(fp)
81147e9c:	10800317 	ldw	r2,12(r2)
81147ea0:	10800104 	addi	r2,r2,4
81147ea4:	10800037 	ldwio	r2,0(r2)
81147ea8:	1007883a 	mov	r3,r2
81147eac:	00bffbc4 	movi	r2,-17
81147eb0:	1884703a 	and	r2,r3,r2
81147eb4:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81147eb8:	e0bff917 	ldw	r2,-28(fp)
81147ebc:	10800814 	ori	r2,r2,32
81147ec0:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81147ec4:	e0bffd17 	ldw	r2,-12(fp)
81147ec8:	10800317 	ldw	r2,12(r2)
81147ecc:	10800104 	addi	r2,r2,4
81147ed0:	e0fff917 	ldw	r3,-28(fp)
81147ed4:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81147ed8:	e0bffd17 	ldw	r2,-12(fp)
81147edc:	10800317 	ldw	r2,12(r2)
81147ee0:	e0fffd17 	ldw	r3,-12(fp)
81147ee4:	18c00317 	ldw	r3,12(r3)
81147ee8:	18c00037 	ldwio	r3,0(r3)
81147eec:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81147ef0:	e0bffd17 	ldw	r2,-12(fp)
81147ef4:	10801783 	ldbu	r2,94(r2)
81147ef8:	10803fcc 	andi	r2,r2,255
81147efc:	10000826 	beq	r2,zero,81147f20 <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81147f00:	e0bffd17 	ldw	r2,-12(fp)
81147f04:	10800617 	ldw	r2,24(r2)
81147f08:	10800404 	addi	r2,r2,16
81147f0c:	e0fffd17 	ldw	r3,-12(fp)
81147f10:	18c00617 	ldw	r3,24(r3)
81147f14:	18c00404 	addi	r3,r3,16
81147f18:	18c00037 	ldwio	r3,0(r3)
81147f1c:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81147f20:	d1603504 	addi	r5,gp,-32556
81147f24:	e13ffd17 	ldw	r4,-12(fp)
81147f28:	11482a40 	call	811482a4 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81147f2c:	e0bffd17 	ldw	r2,-12(fp)
81147f30:	10801804 	addi	r2,r2,96
81147f34:	e0bffb15 	stw	r2,-20(fp)
81147f38:	00800044 	movi	r2,1
81147f3c:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81147f40:	e0bffc0b 	ldhu	r2,-16(fp)
81147f44:	1009883a 	mov	r4,r2
81147f48:	113c7f00 	call	8113c7f0 <OSSemCreate>
81147f4c:	1007883a 	mov	r3,r2
81147f50:	e0bffb17 	ldw	r2,-20(fp)
81147f54:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81147f58:	e0bffb17 	ldw	r2,-20(fp)
81147f5c:	10800017 	ldw	r2,0(r2)
81147f60:	10000226 	beq	r2,zero,81147f6c <alt_msgdma_init+0x160>
81147f64:	0005883a 	mov	r2,zero
81147f68:	00000106 	br	81147f70 <alt_msgdma_init+0x164>
81147f6c:	00bfffc4 	movi	r2,-1
81147f70:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81147f74:	e0bffa17 	ldw	r2,-24(fp)
81147f78:	1000081e 	bne	r2,zero,81147f9c <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81147f7c:	d8000015 	stw	zero,0(sp)
81147f80:	e1fffd17 	ldw	r7,-12(fp)
81147f84:	01a04534 	movhi	r6,33044
81147f88:	31988904 	addi	r6,r6,25124
81147f8c:	e17fff17 	ldw	r5,-4(fp)
81147f90:	e13ffe17 	ldw	r4,-8(fp)
81147f94:	11485dc0 	call	811485dc <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81147f98:	00000406 	br	81147fac <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81147f9c:	01204574 	movhi	r4,33045
81147fa0:	213b3f04 	addi	r4,r4,-4868
81147fa4:	11489f40 	call	811489f4 <alt_printf>
    }
    
    return;
81147fa8:	0001883a 	nop

}
81147fac:	e037883a 	mov	sp,fp
81147fb0:	dfc00117 	ldw	ra,4(sp)
81147fb4:	df000017 	ldw	fp,0(sp)
81147fb8:	dec00204 	addi	sp,sp,8
81147fbc:	f800283a 	ret

81147fc0 <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81147fc0:	defffb04 	addi	sp,sp,-20
81147fc4:	de00012e 	bgeu	sp,et,81147fcc <alt_msgdma_register_callback+0xc>
81147fc8:	003b68fa 	trap	3
81147fcc:	df000415 	stw	fp,16(sp)
81147fd0:	df000404 	addi	fp,sp,16
81147fd4:	e13ffc15 	stw	r4,-16(fp)
81147fd8:	e17ffd15 	stw	r5,-12(fp)
81147fdc:	e1bffe15 	stw	r6,-8(fp)
81147fe0:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81147fe4:	e0bffc17 	ldw	r2,-16(fp)
81147fe8:	e0fffd17 	ldw	r3,-12(fp)
81147fec:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81147ff0:	e0bffc17 	ldw	r2,-16(fp)
81147ff4:	e0ffff17 	ldw	r3,-4(fp)
81147ff8:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81147ffc:	e0bffc17 	ldw	r2,-16(fp)
81148000:	e0fffe17 	ldw	r3,-8(fp)
81148004:	10c00d15 	stw	r3,52(r2)

    return ;
81148008:	0001883a 	nop
}
8114800c:	e037883a 	mov	sp,fp
81148010:	df000017 	ldw	fp,0(sp)
81148014:	dec00104 	addi	sp,sp,4
81148018:	f800283a 	ret

8114801c <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
8114801c:	defffc04 	addi	sp,sp,-16
81148020:	de00012e 	bgeu	sp,et,81148028 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81148024:	003b68fa 	trap	3
81148028:	dfc00315 	stw	ra,12(sp)
8114802c:	df000215 	stw	fp,8(sp)
81148030:	df000204 	addi	fp,sp,8
81148034:	e13ffe15 	stw	r4,-8(fp)
81148038:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
8114803c:	000d883a 	mov	r6,zero
81148040:	e17fff17 	ldw	r5,-4(fp)
81148044:	e13ffe17 	ldw	r4,-8(fp)
81148048:	11465a00 	call	811465a0 <alt_msgdma_descriptor_async_transfer>

}
8114804c:	e037883a 	mov	sp,fp
81148050:	dfc00117 	ldw	ra,4(sp)
81148054:	df000017 	ldw	fp,0(sp)
81148058:	dec00204 	addi	sp,sp,8
8114805c:	f800283a 	ret

81148060 <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
81148060:	defffc04 	addi	sp,sp,-16
81148064:	de00012e 	bgeu	sp,et,8114806c <alt_msgdma_extended_descriptor_async_transfer+0xc>
81148068:	003b68fa 	trap	3
8114806c:	dfc00315 	stw	ra,12(sp)
81148070:	df000215 	stw	fp,8(sp)
81148074:	df000204 	addi	fp,sp,8
81148078:	e13ffe15 	stw	r4,-8(fp)
8114807c:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
81148080:	e1bfff17 	ldw	r6,-4(fp)
81148084:	000b883a 	mov	r5,zero
81148088:	e13ffe17 	ldw	r4,-8(fp)
8114808c:	11465a00 	call	811465a0 <alt_msgdma_descriptor_async_transfer>
}
81148090:	e037883a 	mov	sp,fp
81148094:	dfc00117 	ldw	ra,4(sp)
81148098:	df000017 	ldw	fp,0(sp)
8114809c:	dec00204 	addi	sp,sp,8
811480a0:	f800283a 	ret

811480a4 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
811480a4:	defffc04 	addi	sp,sp,-16
811480a8:	de00012e 	bgeu	sp,et,811480b0 <alt_msgdma_standard_descriptor_sync_transfer+0xc>
811480ac:	003b68fa 	trap	3
811480b0:	dfc00315 	stw	ra,12(sp)
811480b4:	df000215 	stw	fp,8(sp)
811480b8:	df000204 	addi	fp,sp,8
811480bc:	e13ffe15 	stw	r4,-8(fp)
811480c0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
811480c4:	000d883a 	mov	r6,zero
811480c8:	e17fff17 	ldw	r5,-4(fp)
811480cc:	e13ffe17 	ldw	r4,-8(fp)
811480d0:	11468e00 	call	811468e0 <alt_msgdma_descriptor_sync_transfer>
}
811480d4:	e037883a 	mov	sp,fp
811480d8:	dfc00117 	ldw	ra,4(sp)
811480dc:	df000017 	ldw	fp,0(sp)
811480e0:	dec00204 	addi	sp,sp,8
811480e4:	f800283a 	ret

811480e8 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
811480e8:	defffc04 	addi	sp,sp,-16
811480ec:	de00012e 	bgeu	sp,et,811480f4 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
811480f0:	003b68fa 	trap	3
811480f4:	dfc00315 	stw	ra,12(sp)
811480f8:	df000215 	stw	fp,8(sp)
811480fc:	df000204 	addi	fp,sp,8
81148100:	e13ffe15 	stw	r4,-8(fp)
81148104:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
81148108:	e1bfff17 	ldw	r6,-4(fp)
8114810c:	000b883a 	mov	r5,zero
81148110:	e13ffe17 	ldw	r4,-8(fp)
81148114:	11468e00 	call	811468e0 <alt_msgdma_descriptor_sync_transfer>
}
81148118:	e037883a 	mov	sp,fp
8114811c:	dfc00117 	ldw	ra,4(sp)
81148120:	df000017 	ldw	fp,0(sp)
81148124:	dec00204 	addi	sp,sp,8
81148128:	f800283a 	ret

8114812c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
8114812c:	defff504 	addi	sp,sp,-44
81148130:	de00012e 	bgeu	sp,et,81148138 <alt_alarm_start+0xc>
81148134:	003b68fa 	trap	3
81148138:	df000a15 	stw	fp,40(sp)
8114813c:	df000a04 	addi	fp,sp,40
81148140:	e13ffc15 	stw	r4,-16(fp)
81148144:	e17ffd15 	stw	r5,-12(fp)
81148148:	e1bffe15 	stw	r6,-8(fp)
8114814c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
81148150:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81148154:	d0a08717 	ldw	r2,-32228(gp)
  
  if (alt_ticks_per_second ())
81148158:	10003c26 	beq	r2,zero,8114824c <alt_alarm_start+0x120>
  {
    if (alarm)
8114815c:	e0bffc17 	ldw	r2,-16(fp)
81148160:	10003826 	beq	r2,zero,81148244 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81148164:	e0bffc17 	ldw	r2,-16(fp)
81148168:	e0fffe17 	ldw	r3,-8(fp)
8114816c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
81148170:	e0bffc17 	ldw	r2,-16(fp)
81148174:	e0ffff17 	ldw	r3,-4(fp)
81148178:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8114817c:	0005303a 	rdctl	r2,status
81148180:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148184:	e0fff917 	ldw	r3,-28(fp)
81148188:	00bfff84 	movi	r2,-2
8114818c:	1884703a 	and	r2,r3,r2
81148190:	1001703a 	wrctl	status,r2
  
  return context;
81148194:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81148198:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8114819c:	d0a08817 	ldw	r2,-32224(gp)
      
      current_nticks = alt_nticks();
811481a0:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
811481a4:	e0fffd17 	ldw	r3,-12(fp)
811481a8:	e0bff617 	ldw	r2,-40(fp)
811481ac:	1885883a 	add	r2,r3,r2
811481b0:	10c00044 	addi	r3,r2,1
811481b4:	e0bffc17 	ldw	r2,-16(fp)
811481b8:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
811481bc:	e0bffc17 	ldw	r2,-16(fp)
811481c0:	10c00217 	ldw	r3,8(r2)
811481c4:	e0bff617 	ldw	r2,-40(fp)
811481c8:	1880042e 	bgeu	r3,r2,811481dc <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
811481cc:	e0bffc17 	ldw	r2,-16(fp)
811481d0:	00c00044 	movi	r3,1
811481d4:	10c00405 	stb	r3,16(r2)
811481d8:	00000206 	br	811481e4 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
811481dc:	e0bffc17 	ldw	r2,-16(fp)
811481e0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
811481e4:	e0bffc17 	ldw	r2,-16(fp)
811481e8:	d0e01404 	addi	r3,gp,-32688
811481ec:	e0fffa15 	stw	r3,-24(fp)
811481f0:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811481f4:	e0bffb17 	ldw	r2,-20(fp)
811481f8:	e0fffa17 	ldw	r3,-24(fp)
811481fc:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
81148200:	e0bffa17 	ldw	r2,-24(fp)
81148204:	10c00017 	ldw	r3,0(r2)
81148208:	e0bffb17 	ldw	r2,-20(fp)
8114820c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
81148210:	e0bffa17 	ldw	r2,-24(fp)
81148214:	10800017 	ldw	r2,0(r2)
81148218:	e0fffb17 	ldw	r3,-20(fp)
8114821c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81148220:	e0bffa17 	ldw	r2,-24(fp)
81148224:	e0fffb17 	ldw	r3,-20(fp)
81148228:	10c00015 	stw	r3,0(r2)
8114822c:	e0bff817 	ldw	r2,-32(fp)
81148230:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148234:	e0bff717 	ldw	r2,-36(fp)
81148238:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
8114823c:	0005883a 	mov	r2,zero
81148240:	00000306 	br	81148250 <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81148244:	00bffa84 	movi	r2,-22
81148248:	00000106 	br	81148250 <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
8114824c:	00bfde84 	movi	r2,-134
  }
}
81148250:	e037883a 	mov	sp,fp
81148254:	df000017 	ldw	fp,0(sp)
81148258:	dec00104 	addi	sp,sp,4
8114825c:	f800283a 	ret

81148260 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81148260:	defffe04 	addi	sp,sp,-8
81148264:	de00012e 	bgeu	sp,et,8114826c <alt_get_errno+0xc>
81148268:	003b68fa 	trap	3
8114826c:	dfc00115 	stw	ra,4(sp)
81148270:	df000015 	stw	fp,0(sp)
81148274:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81148278:	d0a01017 	ldw	r2,-32704(gp)
8114827c:	10000326 	beq	r2,zero,8114828c <alt_get_errno+0x2c>
81148280:	d0a01017 	ldw	r2,-32704(gp)
81148284:	103ee83a 	callr	r2
81148288:	00000106 	br	81148290 <alt_get_errno+0x30>
8114828c:	d0a07704 	addi	r2,gp,-32292
}
81148290:	e037883a 	mov	sp,fp
81148294:	dfc00117 	ldw	ra,4(sp)
81148298:	df000017 	ldw	fp,0(sp)
8114829c:	dec00204 	addi	sp,sp,8
811482a0:	f800283a 	ret

811482a4 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
811482a4:	defffa04 	addi	sp,sp,-24
811482a8:	de00012e 	bgeu	sp,et,811482b0 <alt_dev_llist_insert+0xc>
811482ac:	003b68fa 	trap	3
811482b0:	dfc00515 	stw	ra,20(sp)
811482b4:	df000415 	stw	fp,16(sp)
811482b8:	df000404 	addi	fp,sp,16
811482bc:	e13ffe15 	stw	r4,-8(fp)
811482c0:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
811482c4:	e0bffe17 	ldw	r2,-8(fp)
811482c8:	10000326 	beq	r2,zero,811482d8 <alt_dev_llist_insert+0x34>
811482cc:	e0bffe17 	ldw	r2,-8(fp)
811482d0:	10800217 	ldw	r2,8(r2)
811482d4:	1000061e 	bne	r2,zero,811482f0 <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
811482d8:	11482600 	call	81148260 <alt_get_errno>
811482dc:	1007883a 	mov	r3,r2
811482e0:	00800584 	movi	r2,22
811482e4:	18800015 	stw	r2,0(r3)
    return -EINVAL;
811482e8:	00bffa84 	movi	r2,-22
811482ec:	00001306 	br	8114833c <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
811482f0:	e0bffe17 	ldw	r2,-8(fp)
811482f4:	e0ffff17 	ldw	r3,-4(fp)
811482f8:	e0fffc15 	stw	r3,-16(fp)
811482fc:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
81148300:	e0bffd17 	ldw	r2,-12(fp)
81148304:	e0fffc17 	ldw	r3,-16(fp)
81148308:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
8114830c:	e0bffc17 	ldw	r2,-16(fp)
81148310:	10c00017 	ldw	r3,0(r2)
81148314:	e0bffd17 	ldw	r2,-12(fp)
81148318:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
8114831c:	e0bffc17 	ldw	r2,-16(fp)
81148320:	10800017 	ldw	r2,0(r2)
81148324:	e0fffd17 	ldw	r3,-12(fp)
81148328:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
8114832c:	e0bffc17 	ldw	r2,-16(fp)
81148330:	e0fffd17 	ldw	r3,-12(fp)
81148334:	10c00015 	stw	r3,0(r2)

  return 0;  
81148338:	0005883a 	mov	r2,zero
}
8114833c:	e037883a 	mov	sp,fp
81148340:	dfc00117 	ldw	ra,4(sp)
81148344:	df000017 	ldw	fp,0(sp)
81148348:	dec00204 	addi	sp,sp,8
8114834c:	f800283a 	ret

81148350 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
81148350:	defffa04 	addi	sp,sp,-24
81148354:	de00012e 	bgeu	sp,et,8114835c <alt_find_dev+0xc>
81148358:	003b68fa 	trap	3
8114835c:	dfc00515 	stw	ra,20(sp)
81148360:	df000415 	stw	fp,16(sp)
81148364:	df000404 	addi	fp,sp,16
81148368:	e13ffe15 	stw	r4,-8(fp)
8114836c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
81148370:	e0bfff17 	ldw	r2,-4(fp)
81148374:	10800017 	ldw	r2,0(r2)
81148378:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
8114837c:	e13ffe17 	ldw	r4,-8(fp)
81148380:	11211a00 	call	811211a0 <strlen>
81148384:	10800044 	addi	r2,r2,1
81148388:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
8114838c:	00000d06 	br	811483c4 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
81148390:	e0bffc17 	ldw	r2,-16(fp)
81148394:	10800217 	ldw	r2,8(r2)
81148398:	e0fffd17 	ldw	r3,-12(fp)
8114839c:	180d883a 	mov	r6,r3
811483a0:	e17ffe17 	ldw	r5,-8(fp)
811483a4:	1009883a 	mov	r4,r2
811483a8:	11491640 	call	81149164 <memcmp>
811483ac:	1000021e 	bne	r2,zero,811483b8 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
811483b0:	e0bffc17 	ldw	r2,-16(fp)
811483b4:	00000706 	br	811483d4 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
811483b8:	e0bffc17 	ldw	r2,-16(fp)
811483bc:	10800017 	ldw	r2,0(r2)
811483c0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
811483c4:	e0fffc17 	ldw	r3,-16(fp)
811483c8:	e0bfff17 	ldw	r2,-4(fp)
811483cc:	18bff01e 	bne	r3,r2,81148390 <__reset+0xfb128390>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
811483d0:	0005883a 	mov	r2,zero
}
811483d4:	e037883a 	mov	sp,fp
811483d8:	dfc00117 	ldw	ra,4(sp)
811483dc:	df000017 	ldw	fp,0(sp)
811483e0:	dec00204 	addi	sp,sp,8
811483e4:	f800283a 	ret

811483e8 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
811483e8:	defffb04 	addi	sp,sp,-20
811483ec:	de00012e 	bgeu	sp,et,811483f4 <alt_find_file+0xc>
811483f0:	003b68fa 	trap	3
811483f4:	dfc00415 	stw	ra,16(sp)
811483f8:	df000315 	stw	fp,12(sp)
811483fc:	df000304 	addi	fp,sp,12
81148400:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
81148404:	d0a00b17 	ldw	r2,-32724(gp)
81148408:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
8114840c:	00003106 	br	811484d4 <alt_find_file+0xec>
  {
    len = strlen(next->name);
81148410:	e0bffd17 	ldw	r2,-12(fp)
81148414:	10800217 	ldw	r2,8(r2)
81148418:	1009883a 	mov	r4,r2
8114841c:	11211a00 	call	811211a0 <strlen>
81148420:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81148424:	e0bffd17 	ldw	r2,-12(fp)
81148428:	10c00217 	ldw	r3,8(r2)
8114842c:	e0bffe17 	ldw	r2,-8(fp)
81148430:	10bfffc4 	addi	r2,r2,-1
81148434:	1885883a 	add	r2,r3,r2
81148438:	10800003 	ldbu	r2,0(r2)
8114843c:	10803fcc 	andi	r2,r2,255
81148440:	1080201c 	xori	r2,r2,128
81148444:	10bfe004 	addi	r2,r2,-128
81148448:	10800bd8 	cmpnei	r2,r2,47
8114844c:	1000031e 	bne	r2,zero,8114845c <alt_find_file+0x74>
    {
      len -= 1;
81148450:	e0bffe17 	ldw	r2,-8(fp)
81148454:	10bfffc4 	addi	r2,r2,-1
81148458:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
8114845c:	e0bffe17 	ldw	r2,-8(fp)
81148460:	e0ffff17 	ldw	r3,-4(fp)
81148464:	1885883a 	add	r2,r3,r2
81148468:	10800003 	ldbu	r2,0(r2)
8114846c:	10803fcc 	andi	r2,r2,255
81148470:	1080201c 	xori	r2,r2,128
81148474:	10bfe004 	addi	r2,r2,-128
81148478:	10800be0 	cmpeqi	r2,r2,47
8114847c:	1000081e 	bne	r2,zero,811484a0 <alt_find_file+0xb8>
81148480:	e0bffe17 	ldw	r2,-8(fp)
81148484:	e0ffff17 	ldw	r3,-4(fp)
81148488:	1885883a 	add	r2,r3,r2
8114848c:	10800003 	ldbu	r2,0(r2)
81148490:	10803fcc 	andi	r2,r2,255
81148494:	1080201c 	xori	r2,r2,128
81148498:	10bfe004 	addi	r2,r2,-128
8114849c:	10000a1e 	bne	r2,zero,811484c8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
811484a0:	e0bffd17 	ldw	r2,-12(fp)
811484a4:	10800217 	ldw	r2,8(r2)
811484a8:	e0fffe17 	ldw	r3,-8(fp)
811484ac:	180d883a 	mov	r6,r3
811484b0:	e17fff17 	ldw	r5,-4(fp)
811484b4:	1009883a 	mov	r4,r2
811484b8:	11491640 	call	81149164 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
811484bc:	1000021e 	bne	r2,zero,811484c8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
811484c0:	e0bffd17 	ldw	r2,-12(fp)
811484c4:	00000706 	br	811484e4 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
811484c8:	e0bffd17 	ldw	r2,-12(fp)
811484cc:	10800017 	ldw	r2,0(r2)
811484d0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
811484d4:	e0fffd17 	ldw	r3,-12(fp)
811484d8:	d0a00b04 	addi	r2,gp,-32724
811484dc:	18bfcc1e 	bne	r3,r2,81148410 <__reset+0xfb128410>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
811484e0:	0005883a 	mov	r2,zero
}
811484e4:	e037883a 	mov	sp,fp
811484e8:	dfc00117 	ldw	ra,4(sp)
811484ec:	df000017 	ldw	fp,0(sp)
811484f0:	dec00204 	addi	sp,sp,8
811484f4:	f800283a 	ret

811484f8 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
811484f8:	defff904 	addi	sp,sp,-28
811484fc:	de00012e 	bgeu	sp,et,81148504 <alt_get_fd+0xc>
81148500:	003b68fa 	trap	3
81148504:	dfc00615 	stw	ra,24(sp)
81148508:	df000515 	stw	fp,20(sp)
8114850c:	df000504 	addi	fp,sp,20
81148510:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
81148514:	00bffa04 	movi	r2,-24
81148518:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
8114851c:	d0a07e17 	ldw	r2,-32264(gp)
81148520:	e0bffd15 	stw	r2,-12(fp)
81148524:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81148528:	e0bffe0b 	ldhu	r2,-8(fp)
8114852c:	e0fffe84 	addi	r3,fp,-6
81148530:	180d883a 	mov	r6,r3
81148534:	100b883a 	mov	r5,r2
81148538:	e13ffd17 	ldw	r4,-12(fp)
8114853c:	113cb180 	call	8113cb18 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
81148540:	e03ffb15 	stw	zero,-20(fp)
81148544:	00001906 	br	811485ac <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81148548:	00a04574 	movhi	r2,33045
8114854c:	10bdae04 	addi	r2,r2,-2376
81148550:	e0fffb17 	ldw	r3,-20(fp)
81148554:	18c00324 	muli	r3,r3,12
81148558:	10c5883a 	add	r2,r2,r3
8114855c:	10800017 	ldw	r2,0(r2)
81148560:	10000f1e 	bne	r2,zero,811485a0 <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81148564:	00a04574 	movhi	r2,33045
81148568:	10bdae04 	addi	r2,r2,-2376
8114856c:	e0fffb17 	ldw	r3,-20(fp)
81148570:	18c00324 	muli	r3,r3,12
81148574:	10c5883a 	add	r2,r2,r3
81148578:	e0ffff17 	ldw	r3,-4(fp)
8114857c:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
81148580:	d0e00f17 	ldw	r3,-32708(gp)
81148584:	e0bffb17 	ldw	r2,-20(fp)
81148588:	1880020e 	bge	r3,r2,81148594 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
8114858c:	e0bffb17 	ldw	r2,-20(fp)
81148590:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81148594:	e0bffb17 	ldw	r2,-20(fp)
81148598:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
8114859c:	00000606 	br	811485b8 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
811485a0:	e0bffb17 	ldw	r2,-20(fp)
811485a4:	10800044 	addi	r2,r2,1
811485a8:	e0bffb15 	stw	r2,-20(fp)
811485ac:	e0bffb17 	ldw	r2,-20(fp)
811485b0:	10800810 	cmplti	r2,r2,32
811485b4:	103fe41e 	bne	r2,zero,81148548 <__reset+0xfb128548>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
811485b8:	d0a07e17 	ldw	r2,-32264(gp)
811485bc:	1009883a 	mov	r4,r2
811485c0:	113cea00 	call	8113cea0 <OSSemPost>

  return rc;
811485c4:	e0bffc17 	ldw	r2,-16(fp)
}
811485c8:	e037883a 	mov	sp,fp
811485cc:	dfc00117 	ldw	ra,4(sp)
811485d0:	df000017 	ldw	fp,0(sp)
811485d4:	dec00204 	addi	sp,sp,8
811485d8:	f800283a 	ret

811485dc <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
811485dc:	defff904 	addi	sp,sp,-28
811485e0:	de00012e 	bgeu	sp,et,811485e8 <alt_ic_isr_register+0xc>
811485e4:	003b68fa 	trap	3
811485e8:	dfc00615 	stw	ra,24(sp)
811485ec:	df000515 	stw	fp,20(sp)
811485f0:	df000504 	addi	fp,sp,20
811485f4:	e13ffc15 	stw	r4,-16(fp)
811485f8:	e17ffd15 	stw	r5,-12(fp)
811485fc:	e1bffe15 	stw	r6,-8(fp)
81148600:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
81148604:	e0800217 	ldw	r2,8(fp)
81148608:	d8800015 	stw	r2,0(sp)
8114860c:	e1ffff17 	ldw	r7,-4(fp)
81148610:	e1bffe17 	ldw	r6,-8(fp)
81148614:	e17ffd17 	ldw	r5,-12(fp)
81148618:	e13ffc17 	ldw	r4,-16(fp)
8114861c:	11487ac0 	call	811487ac <alt_iic_isr_register>
}  
81148620:	e037883a 	mov	sp,fp
81148624:	dfc00117 	ldw	ra,4(sp)
81148628:	df000017 	ldw	fp,0(sp)
8114862c:	dec00204 	addi	sp,sp,8
81148630:	f800283a 	ret

81148634 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81148634:	defff904 	addi	sp,sp,-28
81148638:	de00012e 	bgeu	sp,et,81148640 <alt_ic_irq_enable+0xc>
8114863c:	003b68fa 	trap	3
81148640:	df000615 	stw	fp,24(sp)
81148644:	df000604 	addi	fp,sp,24
81148648:	e13ffe15 	stw	r4,-8(fp)
8114864c:	e17fff15 	stw	r5,-4(fp)
81148650:	e0bfff17 	ldw	r2,-4(fp)
81148654:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81148658:	0005303a 	rdctl	r2,status
8114865c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81148660:	e0fffb17 	ldw	r3,-20(fp)
81148664:	00bfff84 	movi	r2,-2
81148668:	1884703a 	and	r2,r3,r2
8114866c:	1001703a 	wrctl	status,r2
  
  return context;
81148670:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81148674:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81148678:	00c00044 	movi	r3,1
8114867c:	e0bffa17 	ldw	r2,-24(fp)
81148680:	1884983a 	sll	r2,r3,r2
81148684:	1007883a 	mov	r3,r2
81148688:	d0a07f17 	ldw	r2,-32260(gp)
8114868c:	1884b03a 	or	r2,r3,r2
81148690:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81148694:	d0a07f17 	ldw	r2,-32260(gp)
81148698:	100170fa 	wrctl	ienable,r2
8114869c:	e0bffc17 	ldw	r2,-16(fp)
811486a0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811486a4:	e0bffd17 	ldw	r2,-12(fp)
811486a8:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
811486ac:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
811486b0:	0001883a 	nop
}
811486b4:	e037883a 	mov	sp,fp
811486b8:	df000017 	ldw	fp,0(sp)
811486bc:	dec00104 	addi	sp,sp,4
811486c0:	f800283a 	ret

811486c4 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
811486c4:	defff904 	addi	sp,sp,-28
811486c8:	de00012e 	bgeu	sp,et,811486d0 <alt_ic_irq_disable+0xc>
811486cc:	003b68fa 	trap	3
811486d0:	df000615 	stw	fp,24(sp)
811486d4:	df000604 	addi	fp,sp,24
811486d8:	e13ffe15 	stw	r4,-8(fp)
811486dc:	e17fff15 	stw	r5,-4(fp)
811486e0:	e0bfff17 	ldw	r2,-4(fp)
811486e4:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811486e8:	0005303a 	rdctl	r2,status
811486ec:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811486f0:	e0fffb17 	ldw	r3,-20(fp)
811486f4:	00bfff84 	movi	r2,-2
811486f8:	1884703a 	and	r2,r3,r2
811486fc:	1001703a 	wrctl	status,r2
  
  return context;
81148700:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81148704:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
81148708:	00c00044 	movi	r3,1
8114870c:	e0bffa17 	ldw	r2,-24(fp)
81148710:	1884983a 	sll	r2,r3,r2
81148714:	0084303a 	nor	r2,zero,r2
81148718:	1007883a 	mov	r3,r2
8114871c:	d0a07f17 	ldw	r2,-32260(gp)
81148720:	1884703a 	and	r2,r3,r2
81148724:	d0a07f15 	stw	r2,-32260(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81148728:	d0a07f17 	ldw	r2,-32260(gp)
8114872c:	100170fa 	wrctl	ienable,r2
81148730:	e0bffc17 	ldw	r2,-16(fp)
81148734:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148738:	e0bffd17 	ldw	r2,-12(fp)
8114873c:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81148740:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81148744:	0001883a 	nop
}
81148748:	e037883a 	mov	sp,fp
8114874c:	df000017 	ldw	fp,0(sp)
81148750:	dec00104 	addi	sp,sp,4
81148754:	f800283a 	ret

81148758 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81148758:	defffc04 	addi	sp,sp,-16
8114875c:	de00012e 	bgeu	sp,et,81148764 <alt_ic_irq_enabled+0xc>
81148760:	003b68fa 	trap	3
81148764:	df000315 	stw	fp,12(sp)
81148768:	df000304 	addi	fp,sp,12
8114876c:	e13ffe15 	stw	r4,-8(fp)
81148770:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81148774:	000530fa 	rdctl	r2,ienable
81148778:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
8114877c:	00c00044 	movi	r3,1
81148780:	e0bfff17 	ldw	r2,-4(fp)
81148784:	1884983a 	sll	r2,r3,r2
81148788:	1007883a 	mov	r3,r2
8114878c:	e0bffd17 	ldw	r2,-12(fp)
81148790:	1884703a 	and	r2,r3,r2
81148794:	1004c03a 	cmpne	r2,r2,zero
81148798:	10803fcc 	andi	r2,r2,255
}
8114879c:	e037883a 	mov	sp,fp
811487a0:	df000017 	ldw	fp,0(sp)
811487a4:	dec00104 	addi	sp,sp,4
811487a8:	f800283a 	ret

811487ac <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
811487ac:	defff504 	addi	sp,sp,-44
811487b0:	de00012e 	bgeu	sp,et,811487b8 <alt_iic_isr_register+0xc>
811487b4:	003b68fa 	trap	3
811487b8:	dfc00a15 	stw	ra,40(sp)
811487bc:	df000915 	stw	fp,36(sp)
811487c0:	df000904 	addi	fp,sp,36
811487c4:	e13ffc15 	stw	r4,-16(fp)
811487c8:	e17ffd15 	stw	r5,-12(fp)
811487cc:	e1bffe15 	stw	r6,-8(fp)
811487d0:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
811487d4:	00bffa84 	movi	r2,-22
811487d8:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
811487dc:	e0bffd17 	ldw	r2,-12(fp)
811487e0:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811487e4:	e0bff817 	ldw	r2,-32(fp)
811487e8:	10800808 	cmpgei	r2,r2,32
811487ec:	1000271e 	bne	r2,zero,8114888c <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811487f0:	0005303a 	rdctl	r2,status
811487f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811487f8:	e0fffb17 	ldw	r3,-20(fp)
811487fc:	00bfff84 	movi	r2,-2
81148800:	1884703a 	and	r2,r3,r2
81148804:	1001703a 	wrctl	status,r2
  
  return context;
81148808:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
8114880c:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
81148810:	00a045f4 	movhi	r2,33047
81148814:	10ab5504 	addi	r2,r2,-21164
81148818:	e0fff817 	ldw	r3,-32(fp)
8114881c:	180690fa 	slli	r3,r3,3
81148820:	10c5883a 	add	r2,r2,r3
81148824:	e0fffe17 	ldw	r3,-8(fp)
81148828:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
8114882c:	00a045f4 	movhi	r2,33047
81148830:	10ab5504 	addi	r2,r2,-21164
81148834:	e0fff817 	ldw	r3,-32(fp)
81148838:	180690fa 	slli	r3,r3,3
8114883c:	10c5883a 	add	r2,r2,r3
81148840:	10800104 	addi	r2,r2,4
81148844:	e0ffff17 	ldw	r3,-4(fp)
81148848:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
8114884c:	e0bffe17 	ldw	r2,-8(fp)
81148850:	10000526 	beq	r2,zero,81148868 <alt_iic_isr_register+0xbc>
81148854:	e0bff817 	ldw	r2,-32(fp)
81148858:	100b883a 	mov	r5,r2
8114885c:	e13ffc17 	ldw	r4,-16(fp)
81148860:	11486340 	call	81148634 <alt_ic_irq_enable>
81148864:	00000406 	br	81148878 <alt_iic_isr_register+0xcc>
81148868:	e0bff817 	ldw	r2,-32(fp)
8114886c:	100b883a 	mov	r5,r2
81148870:	e13ffc17 	ldw	r4,-16(fp)
81148874:	11486c40 	call	811486c4 <alt_ic_irq_disable>
81148878:	e0bff715 	stw	r2,-36(fp)
8114887c:	e0bffa17 	ldw	r2,-24(fp)
81148880:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81148884:	e0bff917 	ldw	r2,-28(fp)
81148888:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
8114888c:	e0bff717 	ldw	r2,-36(fp)
}
81148890:	e037883a 	mov	sp,fp
81148894:	dfc00117 	ldw	ra,4(sp)
81148898:	df000017 	ldw	fp,0(sp)
8114889c:	dec00204 	addi	sp,sp,8
811488a0:	f800283a 	ret

811488a4 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
811488a4:	defff904 	addi	sp,sp,-28
811488a8:	de00012e 	bgeu	sp,et,811488b0 <alt_open_fd+0xc>
811488ac:	003b68fa 	trap	3
811488b0:	dfc00615 	stw	ra,24(sp)
811488b4:	df000515 	stw	fp,20(sp)
811488b8:	df000504 	addi	fp,sp,20
811488bc:	e13ffc15 	stw	r4,-16(fp)
811488c0:	e17ffd15 	stw	r5,-12(fp)
811488c4:	e1bffe15 	stw	r6,-8(fp)
811488c8:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
811488cc:	e1bfff17 	ldw	r6,-4(fp)
811488d0:	e17ffe17 	ldw	r5,-8(fp)
811488d4:	e13ffd17 	ldw	r4,-12(fp)
811488d8:	11357540 	call	81135754 <open>
811488dc:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
811488e0:	e0bffb17 	ldw	r2,-20(fp)
811488e4:	10001c16 	blt	r2,zero,81148958 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
811488e8:	00a04574 	movhi	r2,33045
811488ec:	10bdae04 	addi	r2,r2,-2376
811488f0:	e0fffb17 	ldw	r3,-20(fp)
811488f4:	18c00324 	muli	r3,r3,12
811488f8:	10c5883a 	add	r2,r2,r3
811488fc:	10c00017 	ldw	r3,0(r2)
81148900:	e0bffc17 	ldw	r2,-16(fp)
81148904:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
81148908:	00a04574 	movhi	r2,33045
8114890c:	10bdae04 	addi	r2,r2,-2376
81148910:	e0fffb17 	ldw	r3,-20(fp)
81148914:	18c00324 	muli	r3,r3,12
81148918:	10c5883a 	add	r2,r2,r3
8114891c:	10800104 	addi	r2,r2,4
81148920:	10c00017 	ldw	r3,0(r2)
81148924:	e0bffc17 	ldw	r2,-16(fp)
81148928:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
8114892c:	00a04574 	movhi	r2,33045
81148930:	10bdae04 	addi	r2,r2,-2376
81148934:	e0fffb17 	ldw	r3,-20(fp)
81148938:	18c00324 	muli	r3,r3,12
8114893c:	10c5883a 	add	r2,r2,r3
81148940:	10800204 	addi	r2,r2,8
81148944:	10c00017 	ldw	r3,0(r2)
81148948:	e0bffc17 	ldw	r2,-16(fp)
8114894c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
81148950:	e13ffb17 	ldw	r4,-20(fp)
81148954:	11359f80 	call	811359f8 <alt_release_fd>
  }
} 
81148958:	0001883a 	nop
8114895c:	e037883a 	mov	sp,fp
81148960:	dfc00117 	ldw	ra,4(sp)
81148964:	df000017 	ldw	fp,0(sp)
81148968:	dec00204 	addi	sp,sp,8
8114896c:	f800283a 	ret

81148970 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
81148970:	defffb04 	addi	sp,sp,-20
81148974:	de00012e 	bgeu	sp,et,8114897c <alt_io_redirect+0xc>
81148978:	003b68fa 	trap	3
8114897c:	dfc00415 	stw	ra,16(sp)
81148980:	df000315 	stw	fp,12(sp)
81148984:	df000304 	addi	fp,sp,12
81148988:	e13ffd15 	stw	r4,-12(fp)
8114898c:	e17ffe15 	stw	r5,-8(fp)
81148990:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81148994:	01c07fc4 	movi	r7,511
81148998:	01800044 	movi	r6,1
8114899c:	e17ffd17 	ldw	r5,-12(fp)
811489a0:	01204574 	movhi	r4,33045
811489a4:	213db104 	addi	r4,r4,-2364
811489a8:	11488a40 	call	811488a4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
811489ac:	01c07fc4 	movi	r7,511
811489b0:	000d883a 	mov	r6,zero
811489b4:	e17ffe17 	ldw	r5,-8(fp)
811489b8:	01204574 	movhi	r4,33045
811489bc:	213dae04 	addi	r4,r4,-2376
811489c0:	11488a40 	call	811488a4 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
811489c4:	01c07fc4 	movi	r7,511
811489c8:	01800044 	movi	r6,1
811489cc:	e17fff17 	ldw	r5,-4(fp)
811489d0:	01204574 	movhi	r4,33045
811489d4:	213db404 	addi	r4,r4,-2352
811489d8:	11488a40 	call	811488a4 <alt_open_fd>
}  
811489dc:	0001883a 	nop
811489e0:	e037883a 	mov	sp,fp
811489e4:	dfc00117 	ldw	ra,4(sp)
811489e8:	df000017 	ldw	fp,0(sp)
811489ec:	dec00204 	addi	sp,sp,8
811489f0:	f800283a 	ret

811489f4 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
811489f4:	defff204 	addi	sp,sp,-56
811489f8:	de00012e 	bgeu	sp,et,81148a00 <alt_printf+0xc>
811489fc:	003b68fa 	trap	3
81148a00:	dfc00a15 	stw	ra,40(sp)
81148a04:	df000915 	stw	fp,36(sp)
81148a08:	df000904 	addi	fp,sp,36
81148a0c:	e13fff15 	stw	r4,-4(fp)
81148a10:	e1400215 	stw	r5,8(fp)
81148a14:	e1800315 	stw	r6,12(fp)
81148a18:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
81148a1c:	e0800204 	addi	r2,fp,8
81148a20:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
81148a24:	e0bfff17 	ldw	r2,-4(fp)
81148a28:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
81148a2c:	00006f06 	br	81148bec <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81148a30:	e0bff807 	ldb	r2,-32(fp)
81148a34:	10800960 	cmpeqi	r2,r2,37
81148a38:	1000041e 	bne	r2,zero,81148a4c <alt_printf+0x58>
        {
            alt_putchar(c);
81148a3c:	e0bff807 	ldb	r2,-32(fp)
81148a40:	1009883a 	mov	r4,r2
81148a44:	1148c280 	call	81148c28 <alt_putchar>
81148a48:	00006806 	br	81148bec <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
81148a4c:	e0bff717 	ldw	r2,-36(fp)
81148a50:	10c00044 	addi	r3,r2,1
81148a54:	e0fff715 	stw	r3,-36(fp)
81148a58:	10800003 	ldbu	r2,0(r2)
81148a5c:	e0bff805 	stb	r2,-32(fp)
81148a60:	e0bff807 	ldb	r2,-32(fp)
81148a64:	10006926 	beq	r2,zero,81148c0c <alt_printf+0x218>
            {
                if (c == '%')
81148a68:	e0bff807 	ldb	r2,-32(fp)
81148a6c:	10800958 	cmpnei	r2,r2,37
81148a70:	1000041e 	bne	r2,zero,81148a84 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81148a74:	e0bff807 	ldb	r2,-32(fp)
81148a78:	1009883a 	mov	r4,r2
81148a7c:	1148c280 	call	81148c28 <alt_putchar>
81148a80:	00005a06 	br	81148bec <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81148a84:	e0bff807 	ldb	r2,-32(fp)
81148a88:	108018d8 	cmpnei	r2,r2,99
81148a8c:	1000081e 	bne	r2,zero,81148ab0 <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81148a90:	e0bffe17 	ldw	r2,-8(fp)
81148a94:	10c00104 	addi	r3,r2,4
81148a98:	e0fffe15 	stw	r3,-8(fp)
81148a9c:	10800017 	ldw	r2,0(r2)
81148aa0:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81148aa4:	e13ffd17 	ldw	r4,-12(fp)
81148aa8:	1148c280 	call	81148c28 <alt_putchar>
81148aac:	00004f06 	br	81148bec <alt_printf+0x1f8>
                }
                else if (c == 'x')
81148ab0:	e0bff807 	ldb	r2,-32(fp)
81148ab4:	10801e18 	cmpnei	r2,r2,120
81148ab8:	1000341e 	bne	r2,zero,81148b8c <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81148abc:	e0bffe17 	ldw	r2,-8(fp)
81148ac0:	10c00104 	addi	r3,r2,4
81148ac4:	e0fffe15 	stw	r3,-8(fp)
81148ac8:	10800017 	ldw	r2,0(r2)
81148acc:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
81148ad0:	e0bffb17 	ldw	r2,-20(fp)
81148ad4:	1000031e 	bne	r2,zero,81148ae4 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81148ad8:	01000c04 	movi	r4,48
81148adc:	1148c280 	call	81148c28 <alt_putchar>
                        continue;
81148ae0:	00004206 	br	81148bec <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81148ae4:	00800704 	movi	r2,28
81148ae8:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
81148aec:	00000306 	br	81148afc <alt_printf+0x108>
                        digit_shift -= 4;
81148af0:	e0bff917 	ldw	r2,-28(fp)
81148af4:	10bfff04 	addi	r2,r2,-4
81148af8:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
81148afc:	00c003c4 	movi	r3,15
81148b00:	e0bff917 	ldw	r2,-28(fp)
81148b04:	1884983a 	sll	r2,r3,r2
81148b08:	1007883a 	mov	r3,r2
81148b0c:	e0bffb17 	ldw	r2,-20(fp)
81148b10:	1884703a 	and	r2,r3,r2
81148b14:	103ff626 	beq	r2,zero,81148af0 <__reset+0xfb128af0>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81148b18:	00001906 	br	81148b80 <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
81148b1c:	00c003c4 	movi	r3,15
81148b20:	e0bff917 	ldw	r2,-28(fp)
81148b24:	1884983a 	sll	r2,r3,r2
81148b28:	1007883a 	mov	r3,r2
81148b2c:	e0bffb17 	ldw	r2,-20(fp)
81148b30:	1886703a 	and	r3,r3,r2
81148b34:	e0bff917 	ldw	r2,-28(fp)
81148b38:	1884d83a 	srl	r2,r3,r2
81148b3c:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81148b40:	e0bffc17 	ldw	r2,-16(fp)
81148b44:	108002a8 	cmpgeui	r2,r2,10
81148b48:	1000041e 	bne	r2,zero,81148b5c <alt_printf+0x168>
                            c = '0' + digit;
81148b4c:	e0bffc17 	ldw	r2,-16(fp)
81148b50:	10800c04 	addi	r2,r2,48
81148b54:	e0bff805 	stb	r2,-32(fp)
81148b58:	00000306 	br	81148b68 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81148b5c:	e0bffc17 	ldw	r2,-16(fp)
81148b60:	108015c4 	addi	r2,r2,87
81148b64:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81148b68:	e0bff807 	ldb	r2,-32(fp)
81148b6c:	1009883a 	mov	r4,r2
81148b70:	1148c280 	call	81148c28 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81148b74:	e0bff917 	ldw	r2,-28(fp)
81148b78:	10bfff04 	addi	r2,r2,-4
81148b7c:	e0bff915 	stw	r2,-28(fp)
81148b80:	e0bff917 	ldw	r2,-28(fp)
81148b84:	103fe50e 	bge	r2,zero,81148b1c <__reset+0xfb128b1c>
81148b88:	00001806 	br	81148bec <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81148b8c:	e0bff807 	ldb	r2,-32(fp)
81148b90:	10801cd8 	cmpnei	r2,r2,115
81148b94:	1000151e 	bne	r2,zero,81148bec <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81148b98:	e0bffe17 	ldw	r2,-8(fp)
81148b9c:	10c00104 	addi	r3,r2,4
81148ba0:	e0fffe15 	stw	r3,-8(fp)
81148ba4:	10800017 	ldw	r2,0(r2)
81148ba8:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81148bac:	00000906 	br	81148bd4 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81148bb0:	e0bffa17 	ldw	r2,-24(fp)
81148bb4:	10c00044 	addi	r3,r2,1
81148bb8:	e0fffa15 	stw	r3,-24(fp)
81148bbc:	10800003 	ldbu	r2,0(r2)
81148bc0:	10803fcc 	andi	r2,r2,255
81148bc4:	1080201c 	xori	r2,r2,128
81148bc8:	10bfe004 	addi	r2,r2,-128
81148bcc:	1009883a 	mov	r4,r2
81148bd0:	1148c280 	call	81148c28 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81148bd4:	e0bffa17 	ldw	r2,-24(fp)
81148bd8:	10800003 	ldbu	r2,0(r2)
81148bdc:	10803fcc 	andi	r2,r2,255
81148be0:	1080201c 	xori	r2,r2,128
81148be4:	10bfe004 	addi	r2,r2,-128
81148be8:	103ff11e 	bne	r2,zero,81148bb0 <__reset+0xfb128bb0>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
81148bec:	e0bff717 	ldw	r2,-36(fp)
81148bf0:	10c00044 	addi	r3,r2,1
81148bf4:	e0fff715 	stw	r3,-36(fp)
81148bf8:	10800003 	ldbu	r2,0(r2)
81148bfc:	e0bff805 	stb	r2,-32(fp)
81148c00:	e0bff807 	ldb	r2,-32(fp)
81148c04:	103f8a1e 	bne	r2,zero,81148a30 <__reset+0xfb128a30>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81148c08:	00000106 	br	81148c10 <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
81148c0c:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81148c10:	0001883a 	nop
81148c14:	e037883a 	mov	sp,fp
81148c18:	dfc00117 	ldw	ra,4(sp)
81148c1c:	df000017 	ldw	fp,0(sp)
81148c20:	dec00504 	addi	sp,sp,20
81148c24:	f800283a 	ret

81148c28 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81148c28:	defffd04 	addi	sp,sp,-12
81148c2c:	de00012e 	bgeu	sp,et,81148c34 <alt_putchar+0xc>
81148c30:	003b68fa 	trap	3
81148c34:	dfc00215 	stw	ra,8(sp)
81148c38:	df000115 	stw	fp,4(sp)
81148c3c:	df000104 	addi	fp,sp,4
81148c40:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
81148c44:	d0a00517 	ldw	r2,-32748(gp)
81148c48:	10800217 	ldw	r2,8(r2)
81148c4c:	100b883a 	mov	r5,r2
81148c50:	e13fff17 	ldw	r4,-4(fp)
81148c54:	1120ab00 	call	81120ab0 <putc>
#endif
#endif
}
81148c58:	e037883a 	mov	sp,fp
81148c5c:	dfc00117 	ldw	ra,4(sp)
81148c60:	df000017 	ldw	fp,0(sp)
81148c64:	dec00204 	addi	sp,sp,8
81148c68:	f800283a 	ret

81148c6c <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81148c6c:	deffff04 	addi	sp,sp,-4
81148c70:	de00012e 	bgeu	sp,et,81148c78 <altera_nios2_gen2_irq_init+0xc>
81148c74:	003b68fa 	trap	3
81148c78:	df000015 	stw	fp,0(sp)
81148c7c:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81148c80:	000170fa 	wrctl	ienable,zero
}
81148c84:	0001883a 	nop
81148c88:	e037883a 	mov	sp,fp
81148c8c:	df000017 	ldw	fp,0(sp)
81148c90:	dec00104 	addi	sp,sp,4
81148c94:	f800283a 	ret

81148c98 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81148c98:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81148c9c:	de002436 	bltu	sp,et,81148d30 <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81148ca0:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81148ca4:	d120a117 	ldw	r4,-32124(gp)

      stw ra,  0(sp)
81148ca8:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81148cac:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81148cb0:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81148cb4:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81148cb8:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81148cbc:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81148cc0:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81148cc4:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81148cc8:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
81148ccc:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81148cd0:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81148cd4:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81148cd8:	1148f340 	call	81148f34 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
81148cdc:	d1209b17 	ldw	r4,-32148(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81148ce0:	d1609287 	ldb	r5,-32182(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81148ce4:	d120a115 	stw	r4,-32124(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81148ce8:	d16092c5 	stb	r5,-32181(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
81148cec:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81148cf0:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81148cf4:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81148cf8:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
81148cfc:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
81148d00:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
81148d04:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
81148d08:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
81148d0c:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
81148d10:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
81148d14:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
81148d18:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
81148d1c:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81148d20:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81148d24:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81148d28:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81148d2c:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81148d30:	003da0fa 	break	3

81148d34 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81148d34:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81148d38:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81148d3c:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81148d40:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81148d44:	1148f340 	call	81148f34 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81148d48:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81148d4c:	d4a09005 	stb	r18,-32192(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81148d50:	003fe206 	br	81148cdc <__reset+0xfb128cdc>

81148d54 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81148d54:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81148d58:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81148d5c:	10800054 	ori	r2,r2,1
      wrctl status, r2
81148d60:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81148d64:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81148d68:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81148d6c:	dec00204 	addi	sp,sp,8

      callr r2
81148d70:	103ee83a 	callr	r2

      nop
81148d74:	0001883a 	nop

81148d78 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81148d78:	defff704 	addi	sp,sp,-36
81148d7c:	de00012e 	bgeu	sp,et,81148d84 <OSTaskStkInit+0xc>
81148d80:	003b68fa 	trap	3
81148d84:	dfc00815 	stw	ra,32(sp)
81148d88:	df000715 	stw	fp,28(sp)
81148d8c:	df000704 	addi	fp,sp,28
81148d90:	e13ffc15 	stw	r4,-16(fp)
81148d94:	e17ffd15 	stw	r5,-12(fp)
81148d98:	e1bffe15 	stw	r6,-8(fp)
81148d9c:	3805883a 	mov	r2,r7
81148da0:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81148da4:	e0fffe17 	ldw	r3,-8(fp)
81148da8:	00bfff04 	movi	r2,-4
81148dac:	1884703a 	and	r2,r3,r2
81148db0:	10bef704 	addi	r2,r2,-1060
81148db4:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81148db8:	01810904 	movi	r6,1060
81148dbc:	000b883a 	mov	r5,zero
81148dc0:	e13ff917 	ldw	r4,-28(fp)
81148dc4:	11207fc0 	call	811207fc <memset>
81148dc8:	e0bff917 	ldw	r2,-28(fp)
81148dcc:	10c0bb04 	addi	r3,r2,748
81148dd0:	e0bff917 	ldw	r2,-28(fp)
81148dd4:	10c00115 	stw	r3,4(r2)
81148dd8:	e0bff917 	ldw	r2,-28(fp)
81148ddc:	10c0d504 	addi	r3,r2,852
81148de0:	e0bff917 	ldw	r2,-28(fp)
81148de4:	10c00215 	stw	r3,8(r2)
81148de8:	e0bff917 	ldw	r2,-28(fp)
81148dec:	10c0ef04 	addi	r3,r2,956
81148df0:	e0bff917 	ldw	r2,-28(fp)
81148df4:	10c00315 	stw	r3,12(r2)
81148df8:	e0fff917 	ldw	r3,-28(fp)
81148dfc:	00a04574 	movhi	r2,33045
81148e00:	10bb4704 	addi	r2,r2,-4836
81148e04:	18800d15 	stw	r2,52(r3)
81148e08:	e0bff917 	ldw	r2,-28(fp)
81148e0c:	00c00044 	movi	r3,1
81148e10:	10c02915 	stw	r3,164(r2)
81148e14:	10002a15 	stw	zero,168(r2)
81148e18:	e0bff917 	ldw	r2,-28(fp)
81148e1c:	00ccc384 	movi	r3,13070
81148e20:	10c02b0d 	sth	r3,172(r2)
81148e24:	e0bff917 	ldw	r2,-28(fp)
81148e28:	00eaf344 	movi	r3,-21555
81148e2c:	10c02b8d 	sth	r3,174(r2)
81148e30:	e0bff917 	ldw	r2,-28(fp)
81148e34:	00c48d04 	movi	r3,4660
81148e38:	10c02c0d 	sth	r3,176(r2)
81148e3c:	e0bff917 	ldw	r2,-28(fp)
81148e40:	00f99b44 	movi	r3,-6547
81148e44:	10c02c8d 	sth	r3,178(r2)
81148e48:	e0bff917 	ldw	r2,-28(fp)
81148e4c:	00f7bb04 	movi	r3,-8468
81148e50:	10c02d0d 	sth	r3,180(r2)
81148e54:	e0bff917 	ldw	r2,-28(fp)
81148e58:	00c00144 	movi	r3,5
81148e5c:	10c02d8d 	sth	r3,182(r2)
81148e60:	e0bff917 	ldw	r2,-28(fp)
81148e64:	00c002c4 	movi	r3,11
81148e68:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81148e6c:	e0bff917 	ldw	r2,-28(fp)
81148e70:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81148e74:	e0bffa17 	ldw	r2,-24(fp)
81148e78:	10bff304 	addi	r2,r2,-52
81148e7c:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81148e80:	e0bffb17 	ldw	r2,-20(fp)
81148e84:	10800c04 	addi	r2,r2,48
81148e88:	e0fffc17 	ldw	r3,-16(fp)
81148e8c:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81148e90:	e0bffb17 	ldw	r2,-20(fp)
81148e94:	10800b04 	addi	r2,r2,44
81148e98:	e0fffd17 	ldw	r3,-12(fp)
81148e9c:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81148ea0:	e0bffb17 	ldw	r2,-20(fp)
81148ea4:	10800a04 	addi	r2,r2,40
81148ea8:	e0fff917 	ldw	r3,-28(fp)
81148eac:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81148eb0:	00a04574 	movhi	r2,33045
81148eb4:	10a35504 	addi	r2,r2,-29356
81148eb8:	10c00104 	addi	r3,r2,4
81148ebc:	e0bffb17 	ldw	r2,-20(fp)
81148ec0:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81148ec4:	e0bffb17 	ldw	r2,-20(fp)
}
81148ec8:	e037883a 	mov	sp,fp
81148ecc:	dfc00117 	ldw	ra,4(sp)
81148ed0:	df000017 	ldw	fp,0(sp)
81148ed4:	dec00204 	addi	sp,sp,8
81148ed8:	f800283a 	ret

81148edc <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
81148edc:	defffe04 	addi	sp,sp,-8
81148ee0:	de00012e 	bgeu	sp,et,81148ee8 <OSTaskCreateHook+0xc>
81148ee4:	003b68fa 	trap	3
81148ee8:	df000115 	stw	fp,4(sp)
81148eec:	df000104 	addi	fp,sp,4
81148ef0:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81148ef4:	0001883a 	nop
81148ef8:	e037883a 	mov	sp,fp
81148efc:	df000017 	ldw	fp,0(sp)
81148f00:	dec00104 	addi	sp,sp,4
81148f04:	f800283a 	ret

81148f08 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
81148f08:	defffe04 	addi	sp,sp,-8
81148f0c:	de00012e 	bgeu	sp,et,81148f14 <OSTaskDelHook+0xc>
81148f10:	003b68fa 	trap	3
81148f14:	df000115 	stw	fp,4(sp)
81148f18:	df000104 	addi	fp,sp,4
81148f1c:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81148f20:	0001883a 	nop
81148f24:	e037883a 	mov	sp,fp
81148f28:	df000017 	ldw	fp,0(sp)
81148f2c:	dec00104 	addi	sp,sp,4
81148f30:	f800283a 	ret

81148f34 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81148f34:	deffff04 	addi	sp,sp,-4
81148f38:	de00012e 	bgeu	sp,et,81148f40 <OSTaskSwHook+0xc>
81148f3c:	003b68fa 	trap	3
81148f40:	df000015 	stw	fp,0(sp)
81148f44:	d839883a 	mov	fp,sp
}
81148f48:	0001883a 	nop
81148f4c:	e037883a 	mov	sp,fp
81148f50:	df000017 	ldw	fp,0(sp)
81148f54:	dec00104 	addi	sp,sp,4
81148f58:	f800283a 	ret

81148f5c <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81148f5c:	deffff04 	addi	sp,sp,-4
81148f60:	de00012e 	bgeu	sp,et,81148f68 <OSTaskStatHook+0xc>
81148f64:	003b68fa 	trap	3
81148f68:	df000015 	stw	fp,0(sp)
81148f6c:	d839883a 	mov	fp,sp
}
81148f70:	0001883a 	nop
81148f74:	e037883a 	mov	sp,fp
81148f78:	df000017 	ldw	fp,0(sp)
81148f7c:	dec00104 	addi	sp,sp,4
81148f80:	f800283a 	ret

81148f84 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81148f84:	defffe04 	addi	sp,sp,-8
81148f88:	de00012e 	bgeu	sp,et,81148f90 <OSTimeTickHook+0xc>
81148f8c:	003b68fa 	trap	3
81148f90:	dfc00115 	stw	ra,4(sp)
81148f94:	df000015 	stw	fp,0(sp)
81148f98:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81148f9c:	d0a0b50b 	ldhu	r2,-32044(gp)
81148fa0:	10800044 	addi	r2,r2,1
81148fa4:	d0a0b50d 	sth	r2,-32044(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81148fa8:	d0a0b50b 	ldhu	r2,-32044(gp)
81148fac:	10bfffcc 	andi	r2,r2,65535
81148fb0:	10807d30 	cmpltui	r2,r2,500
81148fb4:	1000021e 	bne	r2,zero,81148fc0 <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81148fb8:	d020b50d 	sth	zero,-32044(gp)
        OSTmrSignal();
81148fbc:	113f8d40 	call	8113f8d4 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81148fc0:	0001883a 	nop
81148fc4:	e037883a 	mov	sp,fp
81148fc8:	dfc00117 	ldw	ra,4(sp)
81148fcc:	df000017 	ldw	fp,0(sp)
81148fd0:	dec00204 	addi	sp,sp,8
81148fd4:	f800283a 	ret

81148fd8 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81148fd8:	deffff04 	addi	sp,sp,-4
81148fdc:	de00012e 	bgeu	sp,et,81148fe4 <OSInitHookBegin+0xc>
81148fe0:	003b68fa 	trap	3
81148fe4:	df000015 	stw	fp,0(sp)
81148fe8:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81148fec:	d020b50d 	sth	zero,-32044(gp)
#endif
}
81148ff0:	0001883a 	nop
81148ff4:	e037883a 	mov	sp,fp
81148ff8:	df000017 	ldw	fp,0(sp)
81148ffc:	dec00104 	addi	sp,sp,4
81149000:	f800283a 	ret

81149004 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81149004:	deffff04 	addi	sp,sp,-4
81149008:	de00012e 	bgeu	sp,et,81149010 <OSInitHookEnd+0xc>
8114900c:	003b68fa 	trap	3
81149010:	df000015 	stw	fp,0(sp)
81149014:	d839883a 	mov	fp,sp
}
81149018:	0001883a 	nop
8114901c:	e037883a 	mov	sp,fp
81149020:	df000017 	ldw	fp,0(sp)
81149024:	dec00104 	addi	sp,sp,4
81149028:	f800283a 	ret

8114902c <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
8114902c:	deffff04 	addi	sp,sp,-4
81149030:	de00012e 	bgeu	sp,et,81149038 <OSTaskIdleHook+0xc>
81149034:	003b68fa 	trap	3
81149038:	df000015 	stw	fp,0(sp)
8114903c:	d839883a 	mov	fp,sp
}
81149040:	0001883a 	nop
81149044:	e037883a 	mov	sp,fp
81149048:	df000017 	ldw	fp,0(sp)
8114904c:	dec00104 	addi	sp,sp,4
81149050:	f800283a 	ret

81149054 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81149054:	defffe04 	addi	sp,sp,-8
81149058:	de00012e 	bgeu	sp,et,81149060 <OSTCBInitHook+0xc>
8114905c:	003b68fa 	trap	3
81149060:	df000115 	stw	fp,4(sp)
81149064:	df000104 	addi	fp,sp,4
81149068:	e13fff15 	stw	r4,-4(fp)
}
8114906c:	0001883a 	nop
81149070:	e037883a 	mov	sp,fp
81149074:	df000017 	ldw	fp,0(sp)
81149078:	dec00104 	addi	sp,sp,4
8114907c:	f800283a 	ret

81149080 <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
81149080:	defffe04 	addi	sp,sp,-8
81149084:	de00012e 	bgeu	sp,et,8114908c <alt_exception_cause_generated_bad_addr+0xc>
81149088:	003b68fa 	trap	3
8114908c:	df000115 	stw	fp,4(sp)
81149090:	df000104 	addi	fp,sp,4
81149094:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81149098:	e0bfff17 	ldw	r2,-4(fp)
8114909c:	10bffe84 	addi	r2,r2,-6
811490a0:	10c00428 	cmpgeui	r3,r2,16
811490a4:	18001a1e 	bne	r3,zero,81149110 <alt_exception_cause_generated_bad_addr+0x90>
811490a8:	100690ba 	slli	r3,r2,2
811490ac:	00a04574 	movhi	r2,33045
811490b0:	10a43004 	addi	r2,r2,-28480
811490b4:	1885883a 	add	r2,r3,r2
811490b8:	10800017 	ldw	r2,0(r2)
811490bc:	1000683a 	jmp	r2
811490c0:	81149100 	call	88114910 <__reset+0x20f4910>
811490c4:	81149100 	call	88114910 <__reset+0x20f4910>
811490c8:	81149110 	cmplti	r4,r16,21060
811490cc:	81149110 	cmplti	r4,r16,21060
811490d0:	81149110 	cmplti	r4,r16,21060
811490d4:	81149100 	call	88114910 <__reset+0x20f4910>
811490d8:	81149108 	cmpgei	r4,r16,21060
811490dc:	81149110 	cmplti	r4,r16,21060
811490e0:	81149100 	call	88114910 <__reset+0x20f4910>
811490e4:	81149100 	call	88114910 <__reset+0x20f4910>
811490e8:	81149110 	cmplti	r4,r16,21060
811490ec:	81149100 	call	88114910 <__reset+0x20f4910>
811490f0:	81149108 	cmpgei	r4,r16,21060
811490f4:	81149110 	cmplti	r4,r16,21060
811490f8:	81149110 	cmplti	r4,r16,21060
811490fc:	81149100 	call	88114910 <__reset+0x20f4910>
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
81149100:	00800044 	movi	r2,1
81149104:	00000306 	br	81149114 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
81149108:	0005883a 	mov	r2,zero
8114910c:	00000106 	br	81149114 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
81149110:	0005883a 	mov	r2,zero
  }
}
81149114:	e037883a 	mov	sp,fp
81149118:	df000017 	ldw	fp,0(sp)
8114911c:	dec00104 	addi	sp,sp,4
81149120:	f800283a 	ret

81149124 <exit>:
81149124:	defffe04 	addi	sp,sp,-8
81149128:	000b883a 	mov	r5,zero
8114912c:	de00012e 	bgeu	sp,et,81149134 <exit+0x10>
81149130:	003b68fa 	trap	3
81149134:	dc000015 	stw	r16,0(sp)
81149138:	dfc00115 	stw	ra,4(sp)
8114913c:	2021883a 	mov	r16,r4
81149140:	11492cc0 	call	811492cc <__call_exitprocs>
81149144:	00a04574 	movhi	r2,33045
81149148:	1082c504 	addi	r2,r2,2836
8114914c:	11000017 	ldw	r4,0(r2)
81149150:	20800f17 	ldw	r2,60(r4)
81149154:	10000126 	beq	r2,zero,8114915c <exit+0x38>
81149158:	103ee83a 	callr	r2
8114915c:	8009883a 	mov	r4,r16
81149160:	11494540 	call	81149454 <_exit>

81149164 <memcmp>:
81149164:	01c000c4 	movi	r7,3
81149168:	3980192e 	bgeu	r7,r6,811491d0 <memcmp+0x6c>
8114916c:	2144b03a 	or	r2,r4,r5
81149170:	11c4703a 	and	r2,r2,r7
81149174:	10000f26 	beq	r2,zero,811491b4 <memcmp+0x50>
81149178:	20800003 	ldbu	r2,0(r4)
8114917c:	28c00003 	ldbu	r3,0(r5)
81149180:	10c0151e 	bne	r2,r3,811491d8 <memcmp+0x74>
81149184:	31bfff84 	addi	r6,r6,-2
81149188:	01ffffc4 	movi	r7,-1
8114918c:	00000406 	br	811491a0 <memcmp+0x3c>
81149190:	20800003 	ldbu	r2,0(r4)
81149194:	28c00003 	ldbu	r3,0(r5)
81149198:	31bfffc4 	addi	r6,r6,-1
8114919c:	10c00e1e 	bne	r2,r3,811491d8 <memcmp+0x74>
811491a0:	21000044 	addi	r4,r4,1
811491a4:	29400044 	addi	r5,r5,1
811491a8:	31fff91e 	bne	r6,r7,81149190 <__reset+0xfb129190>
811491ac:	0005883a 	mov	r2,zero
811491b0:	f800283a 	ret
811491b4:	20c00017 	ldw	r3,0(r4)
811491b8:	28800017 	ldw	r2,0(r5)
811491bc:	18bfee1e 	bne	r3,r2,81149178 <__reset+0xfb129178>
811491c0:	31bfff04 	addi	r6,r6,-4
811491c4:	21000104 	addi	r4,r4,4
811491c8:	29400104 	addi	r5,r5,4
811491cc:	39bff936 	bltu	r7,r6,811491b4 <__reset+0xfb1291b4>
811491d0:	303fe91e 	bne	r6,zero,81149178 <__reset+0xfb129178>
811491d4:	003ff506 	br	811491ac <__reset+0xfb1291ac>
811491d8:	10c5c83a 	sub	r2,r2,r3
811491dc:	f800283a 	ret

811491e0 <strncpy>:
811491e0:	2906b03a 	or	r3,r5,r4
811491e4:	18c000cc 	andi	r3,r3,3
811491e8:	2005883a 	mov	r2,r4
811491ec:	18002c1e 	bne	r3,zero,811492a0 <strncpy+0xc0>
811491f0:	010000c4 	movi	r4,3
811491f4:	21802a2e 	bgeu	r4,r6,811492a0 <strncpy+0xc0>
811491f8:	033fbff4 	movhi	r12,65279
811491fc:	02e02074 	movhi	r11,32897
81149200:	633fbfc4 	addi	r12,r12,-257
81149204:	5ae02004 	addi	r11,r11,-32640
81149208:	100f883a 	mov	r7,r2
8114920c:	2a000017 	ldw	r8,0(r5)
81149210:	3815883a 	mov	r10,r7
81149214:	4313883a 	add	r9,r8,r12
81149218:	0206303a 	nor	r3,zero,r8
8114921c:	48c6703a 	and	r3,r9,r3
81149220:	1ac6703a 	and	r3,r3,r11
81149224:	1800261e 	bne	r3,zero,811492c0 <strncpy+0xe0>
81149228:	39c00104 	addi	r7,r7,4
8114922c:	52000015 	stw	r8,0(r10)
81149230:	31bfff04 	addi	r6,r6,-4
81149234:	3811883a 	mov	r8,r7
81149238:	29400104 	addi	r5,r5,4
8114923c:	21bff336 	bltu	r4,r6,8114920c <__reset+0xfb12920c>
81149240:	30001e26 	beq	r6,zero,811492bc <strncpy+0xdc>
81149244:	29c00003 	ldbu	r7,0(r5)
81149248:	31bfffc4 	addi	r6,r6,-1
8114924c:	40c00044 	addi	r3,r8,1
81149250:	41c00005 	stb	r7,0(r8)
81149254:	39c03fcc 	andi	r7,r7,255
81149258:	39c0201c 	xori	r7,r7,128
8114925c:	39ffe004 	addi	r7,r7,-128
81149260:	29400044 	addi	r5,r5,1
81149264:	38001026 	beq	r7,zero,811492a8 <strncpy+0xc8>
81149268:	1811883a 	mov	r8,r3
8114926c:	00000906 	br	81149294 <strncpy+0xb4>
81149270:	29c00003 	ldbu	r7,0(r5)
81149274:	31bfffc4 	addi	r6,r6,-1
81149278:	29400044 	addi	r5,r5,1
8114927c:	41c00005 	stb	r7,0(r8)
81149280:	39c03fcc 	andi	r7,r7,255
81149284:	39c0201c 	xori	r7,r7,128
81149288:	39ffe004 	addi	r7,r7,-128
8114928c:	1811883a 	mov	r8,r3
81149290:	38000526 	beq	r7,zero,811492a8 <strncpy+0xc8>
81149294:	18c00044 	addi	r3,r3,1
81149298:	303ff51e 	bne	r6,zero,81149270 <__reset+0xfb129270>
8114929c:	f800283a 	ret
811492a0:	1011883a 	mov	r8,r2
811492a4:	003fe606 	br	81149240 <__reset+0xfb129240>
811492a8:	30000726 	beq	r6,zero,811492c8 <strncpy+0xe8>
811492ac:	198d883a 	add	r6,r3,r6
811492b0:	18000005 	stb	zero,0(r3)
811492b4:	18c00044 	addi	r3,r3,1
811492b8:	19bffd1e 	bne	r3,r6,811492b0 <__reset+0xfb1292b0>
811492bc:	f800283a 	ret
811492c0:	3811883a 	mov	r8,r7
811492c4:	003fdf06 	br	81149244 <__reset+0xfb129244>
811492c8:	f800283a 	ret

811492cc <__call_exitprocs>:
811492cc:	defff504 	addi	sp,sp,-44
811492d0:	de00012e 	bgeu	sp,et,811492d8 <__call_exitprocs+0xc>
811492d4:	003b68fa 	trap	3
811492d8:	df000915 	stw	fp,36(sp)
811492dc:	dd400615 	stw	r21,24(sp)
811492e0:	dc800315 	stw	r18,12(sp)
811492e4:	dfc00a15 	stw	ra,40(sp)
811492e8:	ddc00815 	stw	r23,32(sp)
811492ec:	dd800715 	stw	r22,28(sp)
811492f0:	dd000515 	stw	r20,20(sp)
811492f4:	dcc00415 	stw	r19,16(sp)
811492f8:	dc400215 	stw	r17,8(sp)
811492fc:	dc000115 	stw	r16,4(sp)
81149300:	d9000015 	stw	r4,0(sp)
81149304:	2839883a 	mov	fp,r5
81149308:	04800044 	movi	r18,1
8114930c:	057fffc4 	movi	r21,-1
81149310:	00a04574 	movhi	r2,33045
81149314:	1082c504 	addi	r2,r2,2836
81149318:	12000017 	ldw	r8,0(r2)
8114931c:	45005217 	ldw	r20,328(r8)
81149320:	44c05204 	addi	r19,r8,328
81149324:	a0001c26 	beq	r20,zero,81149398 <__call_exitprocs+0xcc>
81149328:	a0800117 	ldw	r2,4(r20)
8114932c:	15ffffc4 	addi	r23,r2,-1
81149330:	b8000d16 	blt	r23,zero,81149368 <__call_exitprocs+0x9c>
81149334:	14000044 	addi	r16,r2,1
81149338:	8421883a 	add	r16,r16,r16
8114933c:	8421883a 	add	r16,r16,r16
81149340:	84402004 	addi	r17,r16,128
81149344:	a463883a 	add	r17,r20,r17
81149348:	a421883a 	add	r16,r20,r16
8114934c:	e0001e26 	beq	fp,zero,811493c8 <__call_exitprocs+0xfc>
81149350:	80804017 	ldw	r2,256(r16)
81149354:	e0801c26 	beq	fp,r2,811493c8 <__call_exitprocs+0xfc>
81149358:	bdffffc4 	addi	r23,r23,-1
8114935c:	843fff04 	addi	r16,r16,-4
81149360:	8c7fff04 	addi	r17,r17,-4
81149364:	bd7ff91e 	bne	r23,r21,8114934c <__reset+0xfb12934c>
81149368:	00800034 	movhi	r2,0
8114936c:	10800004 	addi	r2,r2,0
81149370:	10000926 	beq	r2,zero,81149398 <__call_exitprocs+0xcc>
81149374:	a0800117 	ldw	r2,4(r20)
81149378:	1000301e 	bne	r2,zero,8114943c <__call_exitprocs+0x170>
8114937c:	a0800017 	ldw	r2,0(r20)
81149380:	10003226 	beq	r2,zero,8114944c <__call_exitprocs+0x180>
81149384:	a009883a 	mov	r4,r20
81149388:	98800015 	stw	r2,0(r19)
8114938c:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
81149390:	9d000017 	ldw	r20,0(r19)
81149394:	a03fe41e 	bne	r20,zero,81149328 <__reset+0xfb129328>
81149398:	dfc00a17 	ldw	ra,40(sp)
8114939c:	df000917 	ldw	fp,36(sp)
811493a0:	ddc00817 	ldw	r23,32(sp)
811493a4:	dd800717 	ldw	r22,28(sp)
811493a8:	dd400617 	ldw	r21,24(sp)
811493ac:	dd000517 	ldw	r20,20(sp)
811493b0:	dcc00417 	ldw	r19,16(sp)
811493b4:	dc800317 	ldw	r18,12(sp)
811493b8:	dc400217 	ldw	r17,8(sp)
811493bc:	dc000117 	ldw	r16,4(sp)
811493c0:	dec00b04 	addi	sp,sp,44
811493c4:	f800283a 	ret
811493c8:	a0800117 	ldw	r2,4(r20)
811493cc:	80c00017 	ldw	r3,0(r16)
811493d0:	10bfffc4 	addi	r2,r2,-1
811493d4:	15c01426 	beq	r2,r23,81149428 <__call_exitprocs+0x15c>
811493d8:	80000015 	stw	zero,0(r16)
811493dc:	183fde26 	beq	r3,zero,81149358 <__reset+0xfb129358>
811493e0:	95c8983a 	sll	r4,r18,r23
811493e4:	a0806217 	ldw	r2,392(r20)
811493e8:	a5800117 	ldw	r22,4(r20)
811493ec:	2084703a 	and	r2,r4,r2
811493f0:	10000b26 	beq	r2,zero,81149420 <__call_exitprocs+0x154>
811493f4:	a0806317 	ldw	r2,396(r20)
811493f8:	2088703a 	and	r4,r4,r2
811493fc:	20000c1e 	bne	r4,zero,81149430 <__call_exitprocs+0x164>
81149400:	89400017 	ldw	r5,0(r17)
81149404:	d9000017 	ldw	r4,0(sp)
81149408:	183ee83a 	callr	r3
8114940c:	a0800117 	ldw	r2,4(r20)
81149410:	15bfbf1e 	bne	r2,r22,81149310 <__reset+0xfb129310>
81149414:	98800017 	ldw	r2,0(r19)
81149418:	153fcf26 	beq	r2,r20,81149358 <__reset+0xfb129358>
8114941c:	003fbc06 	br	81149310 <__reset+0xfb129310>
81149420:	183ee83a 	callr	r3
81149424:	003ff906 	br	8114940c <__reset+0xfb12940c>
81149428:	a5c00115 	stw	r23,4(r20)
8114942c:	003feb06 	br	811493dc <__reset+0xfb1293dc>
81149430:	89000017 	ldw	r4,0(r17)
81149434:	183ee83a 	callr	r3
81149438:	003ff406 	br	8114940c <__reset+0xfb12940c>
8114943c:	a0800017 	ldw	r2,0(r20)
81149440:	a027883a 	mov	r19,r20
81149444:	1029883a 	mov	r20,r2
81149448:	003fb606 	br	81149324 <__reset+0xfb129324>
8114944c:	0005883a 	mov	r2,zero
81149450:	003ffb06 	br	81149440 <__reset+0xfb129440>

81149454 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81149454:	defffc04 	addi	sp,sp,-16
81149458:	de00012e 	bgeu	sp,et,81149460 <_exit+0xc>
8114945c:	003b68fa 	trap	3
81149460:	dfc00315 	stw	ra,12(sp)
81149464:	df000215 	stw	fp,8(sp)
81149468:	df000204 	addi	fp,sp,8
8114946c:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
81149470:	d0a01217 	ldw	r2,-32696(gp)
81149474:	10800058 	cmpnei	r2,r2,1
81149478:	1000031e 	bne	r2,zero,81149488 <_exit+0x34>
8114947c:	01204574 	movhi	r4,33045
81149480:	213b4804 	addi	r4,r4,-4832
81149484:	1134f640 	call	81134f64 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
81149488:	d0a01217 	ldw	r2,-32696(gp)
8114948c:	10800058 	cmpnei	r2,r2,1
81149490:	1000041e 	bne	r2,zero,811494a4 <_exit+0x50>
81149494:	e17fff17 	ldw	r5,-4(fp)
81149498:	01204574 	movhi	r4,33045
8114949c:	213b5304 	addi	r4,r4,-4788
811494a0:	1134f640 	call	81134f64 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
811494a4:	d0a01217 	ldw	r2,-32696(gp)
811494a8:	10800058 	cmpnei	r2,r2,1
811494ac:	1000031e 	bne	r2,zero,811494bc <_exit+0x68>
811494b0:	01204574 	movhi	r4,33045
811494b4:	213b5e04 	addi	r4,r4,-4744
811494b8:	1134f640 	call	81134f64 <alt_log_printf_proc>
  ALT_OS_STOP();
811494bc:	d0209005 	stb	zero,-32192(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
811494c0:	d0a01217 	ldw	r2,-32696(gp)
811494c4:	10800058 	cmpnei	r2,r2,1
811494c8:	1000031e 	bne	r2,zero,811494d8 <_exit+0x84>
811494cc:	01204574 	movhi	r4,33045
811494d0:	213b6804 	addi	r4,r4,-4704
811494d4:	1134f640 	call	81134f64 <alt_log_printf_proc>
811494d8:	e0bfff17 	ldw	r2,-4(fp)
811494dc:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
811494e0:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
811494e4:	10000226 	beq	r2,zero,811494f0 <_exit+0x9c>
    ALT_SIM_FAIL();
811494e8:	002af070 	cmpltui	zero,zero,43969
811494ec:	00000106 	br	811494f4 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
811494f0:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
811494f4:	d0a01217 	ldw	r2,-32696(gp)
811494f8:	10800058 	cmpnei	r2,r2,1
811494fc:	1000031e 	bne	r2,zero,8114950c <_exit+0xb8>
81149500:	01204574 	movhi	r4,33045
81149504:	213b7204 	addi	r4,r4,-4664
81149508:	1134f640 	call	81134f64 <alt_log_printf_proc>
  while (1);
8114950c:	003fff06 	br	8114950c <__reset+0xfb12950c>
