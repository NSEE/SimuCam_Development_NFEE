
Simucam_R0_UART.elf:     file format elf32-littlenios2
Simucam_R0_UART.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x8110025c

Program Header:
    LOAD off    0x00001020 vaddr 0x81100020 paddr 0x81100020 align 2**12
         filesz 0x0004eab0 memsz 0x00068af4 flags rwx
    LOAD off    0x00050000 vaddr 0x86020000 paddr 0x86020000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  86020000  86020000  00050000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000023c  81100020  81100020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00047290  8110025c  8110025c  0000125c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000057f0  811474ec  811474ec  000484ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001df4  8114ccdc  8114ccdc  0004dcdc  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0001a044  8114ead0  8114ead0  0004fad0  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory 00000000  81168b14  81168b14  00050000  2**0
                  CONTENTS
  7 .ext_flash    00000000  86020020  86020020  00050000  2**0
                  CONTENTS
  8 .comment      00000023  00000000  00000000  00050000  2**0
                  CONTENTS, READONLY
  9 .debug_aranges 00001d58  00000000  00000000  00050028  2**3
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_info   0006f8b7  00000000  00000000  00051d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00016677  00000000  00000000  000c1637  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0002222a  00000000  00000000  000d7cae  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_frame  000095f4  00000000  00000000  000f9ed8  2**2
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0000c6d3  00000000  00000000  001034cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    00026ecc  00000000  00000000  0010fb9f  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_alt_sim_info 00000040  00000000  00000000  00136a6c  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 00002390  00000000  00000000  00136ab0  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .thread_model 00000006  00000000  00000000  00144e3d  2**0
                  CONTENTS, READONLY
 19 .cpu          0000000c  00000000  00000000  00144e43  2**0
                  CONTENTS, READONLY
 20 .qsys         00000001  00000000  00000000  00144e4f  2**0
                  CONTENTS, READONLY
 21 .simulation_enabled 00000001  00000000  00000000  00144e50  2**0
                  CONTENTS, READONLY
 22 .sysid_hash   00000004  00000000  00000000  00144e51  2**0
                  CONTENTS, READONLY
 23 .sysid_base   00000004  00000000  00000000  00144e55  2**0
                  CONTENTS, READONLY
 24 .sysid_time   00000004  00000000  00000000  00144e59  2**0
                  CONTENTS, READONLY
 25 .stderr_dev   0000000b  00000000  00000000  00144e5d  2**0
                  CONTENTS, READONLY
 26 .stdin_dev    0000000a  00000000  00000000  00144e68  2**0
                  CONTENTS, READONLY
 27 .stdout_dev   0000000a  00000000  00000000  00144e72  2**0
                  CONTENTS, READONLY
 28 .sopc_system_name 00000011  00000000  00000000  00144e7c  2**0
                  CONTENTS, READONLY
 29 .quartus_project_dir 0000003f  00000000  00000000  00144e8d  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     002827ef  00000000  00000000  00144ecc  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
86020000 l    d  .entry	00000000 .entry
81100020 l    d  .exceptions	00000000 .exceptions
8110025c l    d  .text	00000000 .text
811474ec l    d  .rodata	00000000 .rodata
8114ccdc l    d  .rwdata	00000000 .rwdata
8114ead0 l    d  .bss	00000000 .bss
81168b14 l    d  .onchip_memory	00000000 .onchip_memory
86020020 l    d  .ext_flash	00000000 .ext_flash
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../Simucam_R0_UART_bsp//obj/HAL/src/crt0.o
81100304 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_instruction_exception_entry.c
00000000 l    df *ABS*	00000000 ddr2.c
00000000 l    df *ABS*	00000000 dma.c
00000000 l    df *ABS*	00000000 sense.c
00000000 l    df *ABS*	00000000 simucam_dma.c
00000000 l    df *ABS*	00000000 comm_channel.c
8110474c l     F .text	00000050 uliCommReadReg
811046f8 l     F .text	00000054 vCommWriteReg
00000000 l    df *ABS*	00000000 data_packet.c
81104f8c l     F .text	00000050 uliDpktReadReg
81104f38 l     F .text	00000054 vDpktWriteReg
00000000 l    df *ABS*	00000000 fee_buffers.c
8114eaf0 l     O .bss	00000004 viCh1HoldContext
8114eaf4 l     O .bss	00000004 viCh2HoldContext
8114eaf8 l     O .bss	00000004 viCh3HoldContext
8114eafc l     O .bss	00000004 viCh4HoldContext
8114eb00 l     O .bss	00000004 viCh5HoldContext
8114eb04 l     O .bss	00000004 viCh6HoldContext
8114eb08 l     O .bss	00000004 viCh7HoldContext
8114eb0c l     O .bss	00000004 viCh8HoldContext
811060cc l     F .text	00000054 vFeebWriteReg
81106120 l     F .text	00000050 uliFeebReadReg
00000000 l    df *ABS*	00000000 rmap.c
8114eb10 l     O .bss	00000004 viCh1HoldContext
8114eb14 l     O .bss	00000004 viCh2HoldContext
8114eb18 l     O .bss	00000004 viCh3HoldContext
8114eb1c l     O .bss	00000004 viCh4HoldContext
8114eb20 l     O .bss	00000004 viCh5HoldContext
8114eb24 l     O .bss	00000004 viCh6HoldContext
8114eb28 l     O .bss	00000004 viCh7HoldContext
8114eb2c l     O .bss	00000004 viCh8HoldContext
81108e84 l     F .text	00000054 vRmapWriteReg
81108f28 l     F .text	00000268 uliConvRmapCfgAddr
00000000 l    df *ABS*	00000000 spw_controller.c
8110985c l     F .text	00000050 uliSpwcReadReg
81109808 l     F .text	00000054 vSpwcWriteReg
00000000 l    df *ABS*	00000000 ctrl_io_lvds.c
8114e9f8 l     O .rwdata	00000001 ucIoValue
81109a5c l     F .text	0000007c bCtrlIoLvdsDrive
00000000 l    df *ABS*	00000000 i2c.c
00000000 l    df *ABS*	00000000 leds.c
00000000 l    df *ABS*	00000000 msgdma.c
8110a34c l     F .text	0000013c msgdma_write_extended_descriptor
8110a488 l     F .text	00000164 msgdma_construct_extended_descriptor
8110a5ec l     F .text	00000318 msgdma_descriptor_async_transfer
8110a904 l     F .text	000003fc msgdma_descriptor_sync_transfer
00000000 l    df *ABS*	00000000 power_spi.c
00000000 l    df *ABS*	00000000 reset.c
8110b480 l     F .text	00000054 vRstcWriteReg
8110b4d4 l     F .text	00000050 uliRstReadReg
00000000 l    df *ABS*	00000000 rtcc_spi.c
00000000 l    df *ABS*	00000000 seven_seg.c
00000000 l    df *ABS*	00000000 sync.c
8114eb34 l     O .bss	00000004 viHoldContext
00000000 l    df *ABS*	00000000 data_control_task.c
00000000 l    df *ABS*	00000000 fee_task.c
8114eb3c l     O .bss	00000004 pxNFee.5516
8114eb40 l     O .bss	00000004 incrementador.5520
00000000 l    df *ABS*	00000000 in_ack_handler_task.c
8114eb44 l     O .bss	00000004 xRAckLocal.5493
00000000 l    df *ABS*	00000000 initialization_task.c
00000000 l    df *ABS*	00000000 nfee_control_task.c
8114eb48 l     O .bss	00000004 bDmaBack.5495
00000000 l    df *ABS*	00000000 out_ack_handler_task.c
8114eb4c l     O .bss	00000004 xSAckLocal.5478
00000000 l    df *ABS*	00000000 parser_comm_task.c
8114ecc4 l     O .bss	0000004c PreParsedLocal.5567
8114ed10 l     O .bss	00000054 xTcPusL.5566
00000000 l    df *ABS*	00000000 receiver_uart_task.c
8114ed64 l     O .bss	0000004c xPreParsedReader.5559
00000000 l    df *ABS*	00000000 sender_com_task.c
00000000 l    df *ABS*	00000000 sim_meb_task.c
8114edb0 l     O .bss	00000054 xPusLocal.5752
00000000 l    df *ABS*	00000000 stack_monitor_task.c
00000000 l    df *ABS*	00000000 timeout_checker_ack_task.c
00000000 l    df *ABS*	00000000 simucam_main.c
00000000 l    df *ABS*	00000000 ccd.c
00000000 l    df *ABS*	00000000 communication_utils.c
00000000 l    df *ABS*	00000000 configs_simucam.c
00000000 l    df *ABS*	00000000 crc8.c
8114a627 l     O .rodata	00000100 crc8_table
00000000 l    df *ABS*	00000000 data_controller.c
00000000 l    df *ABS*	00000000 error_handler_simucam.c
00000000 l    df *ABS*	00000000 events_handler.c
00000000 l    df *ABS*	00000000 fee.c
00000000 l    df *ABS*	00000000 fee_controller.c
00000000 l    df *ABS*	00000000 initialization_simucam.c
00000000 l    df *ABS*	00000000 log_manager_simucam.c
00000000 l    df *ABS*	00000000 meb.c
00000000 l    df *ABS*	00000000 pattern.c
00000000 l    df *ABS*	00000000 sdcard_file_manager.c
00000000 l    df *ABS*	00000000 sync_handler.c
00000000 l    df *ABS*	00000000 test_module_simucam.c
00000000 l    df *ABS*	00000000 util.c
00000000 l    df *ABS*	00000000 divsf3.c
00000000 l    df *ABS*	00000000 mulsf3.c
00000000 l    df *ABS*	00000000 floatsisf.c
00000000 l    df *ABS*	00000000 floatunsisf.c
00000000 l    df *ABS*	00000000 muldf3.c
00000000 l    df *ABS*	00000000 extendsfdf2.c
00000000 l    df *ABS*	00000000 truncdfsf2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
8114c11d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fseeko.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 impure.c
8114ccdc l     O .rwdata	00000424 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
8111e078 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 scanf.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcspn.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strnlen.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114c2ea l     O .rodata	00000010 zeroes.4389
8114c2fa l     O .rodata	00000010 blanks.4388
00000000 l    df *ABS*	00000000 vfprintf.c
8114c30a l     O .rodata	00000010 zeroes.4404
81122cf0 l     F .text	000000c4 __sbprintf
8114c31a l     O .rodata	00000010 blanks.4403
00000000 l    df *ABS*	00000000 vfscanf.c
8114c332 l     O .rodata	00000022 basefix.4359
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
811249d8 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
81126528 l     F .text	00000008 __fp_unlock
8112653c l     F .text	000001a4 __sinit.part.1
811266e0 l     F .text	00000008 __fp_lock
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
8114d528 l     O .rwdata	00000020 lc_ctype_charset
8114d508 l     O .rwdata	00000020 lc_message_charset
8114d548 l     O .rwdata	00000038 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 mprec.c
8114c370 l     O .rodata	0000000c p05.2768
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_fpclassify.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strtod.c
81129550 l     F .text	0000006c sulp
8114c4b8 l     O .rodata	00000014 fpi.2737
8114c4cc l     O .rodata	00000028 tinytens
8114c4a4 l     O .rodata	00000014 fpinan.2773
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 vfprintf.c
8114c504 l     O .rodata	00000010 blanks.4332
8114c4f4 l     O .rodata	00000010 zeroes.4333
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 vfprintf.c
8112cbc0 l     F .text	00000104 __sprint_r.part.0
8114c524 l     O .rodata	00000010 blanks.4348
8114c514 l     O .rodata	00000010 zeroes.4349
8112e15c l     F .text	000000c4 __sbprintf
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fputwc.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
8112e610 l     F .text	00000100 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 wcrtomb.c
00000000 l    df *ABS*	00000000 wctomb_r.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 eqsf2.c
00000000 l    df *ABS*	00000000 gesf2.c
00000000 l    df *ABS*	00000000 lesf2.c
00000000 l    df *ABS*	00000000 adddf3.c
00000000 l    df *ABS*	00000000 divdf3.c
00000000 l    df *ABS*	00000000 eqdf2.c
00000000 l    df *ABS*	00000000 gedf2.c
00000000 l    df *ABS*	00000000 ledf2.c
00000000 l    df *ABS*	00000000 subdf3.c
00000000 l    df *ABS*	00000000 fixdfsi.c
00000000 l    df *ABS*	00000000 floatsidf.c
00000000 l    df *ABS*	00000000 floatunsidf.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
811323ac l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
811324f0 l     F .text	00000034 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_fstat.c
81132524 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_irq_register.c
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_isatty.c
811327a8 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_log_macro.o
811328a0 l       .text	00000000 tx_next_char
811328c8 l       .text	00000000 end_tx
811328a8 l       .text	00000000 wait_tx_ready_loop
00000000 l    df *ABS*	00000000 alt_log_printf.c
00000000 l    df *ABS*	00000000 alt_lseek.c
811333a4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
81133620 l     F .text	00000044 alt_get_errno
81133664 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_read.c
8113388c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
8114ea40 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
81133e2c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_env_lock.c
8114ea4c l     O .rwdata	00000004 lockid
8114ec0c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
8114ea50 l     O .rwdata	00000004 lockid
8114ec14 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
811358b8 l     F .text	00000050 OS_InitMisc
81135908 l     F .text	00000074 OS_InitRdyList
81135a8c l     F .text	000000ec OS_InitTCBList
811357d0 l     F .text	000000e8 OS_InitEventList
8113597c l     F .text	00000088 OS_InitTaskIdle
81135a04 l     F .text	00000088 OS_InitTaskStat
81135d1c l     F .text	0000007c OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
81137b34 l     F .text	000000fc OS_FlagTaskRdy
811378e4 l     F .text	00000168 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_mutex.c
81139420 l     F .text	00000198 OSMutex_RdyAtPrio
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 os_tmr.c
8113de50 l     F .text	00000044 OSTmr_Lock
8113d8f0 l     F .text	00000074 OSTmr_Alloc
8113de94 l     F .text	0000003c OSTmr_Unlock
8113dd54 l     F .text	000000fc OSTmr_Unlink
8113d964 l     F .text	000000a4 OSTmr_Free
8113dc04 l     F .text	00000150 OSTmr_Link
8113db7c l     F .text	00000088 OSTmr_InitTask
8113ded0 l     F .text	00000110 OSTmr_Task
00000000 l    df *ABS*	00000000 alt_sys_init.c
8113dfe0 l     F .text	0000003c alt_dev_reg
8114d7c4 l     O .rwdata	0000106c jtag_uart_0
8114e830 l     O .rwdata	000000d0 rs232_uart
8114e900 l     O .rwdata	00000064 dma_DDR_M1
8114e964 l     O .rwdata	00000064 dma_DDR_M2
8114e9c8 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
81142870 l     F .text	000002bc altera_avalon_jtag_uart_irq
81142b2c l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
81143330 l     F .text	00000084 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_uart_init.c
811436c8 l     F .text	000000a4 altera_avalon_uart_irq
8114376c l     F .text	00000140 altera_avalon_uart_rxirq
811438ac l     F .text	000001ac altera_avalon_uart_txirq
00000000 l    df *ABS*	00000000 altera_avalon_uart_read.c
81143ab4 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_avalon_uart_write.c
81143d68 l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 altera_msgdma.c
81143fec l     F .text	00000044 alt_get_errno
81144030 l     F .text	0000009c alt_msgdma_write_standard_descriptor
811440cc l     F .text	00000134 alt_msgdma_write_extended_descriptor
81144200 l     F .text	0000018c alt_msgdma_irq
8114438c l     F .text	00000094 alt_msgdma_construct_standard_descriptor
81144420 l     F .text	0000015c alt_msgdma_construct_extended_descriptor
8114457c l     F .text	00000340 alt_msgdma_descriptor_async_transfer
811448bc l     F .text	00000408 alt_msgdma_descriptor_sync_transfer
81144fc4 l     F .text	000000ac alt_msgdma_construct_prefetcher_standard_descriptor
81145070 l     F .text	0000019c alt_msgdma_construct_prefetcher_extended_descriptor
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
8114623c l     F .text	00000044 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
81146880 l     F .text	000000cc alt_open_fd
00000000 l    df *ABS*	00000000 alt_printf.c
00000000 l    df *ABS*	00000000 alt_putchar.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000044 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
8114ecbc l     O .bss	00000002 OSTmrCtr
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
8114ecc0 g     O .bss	00000004 alt_instruction_exception_handler
81106554 g     F .text	00000044 vRmapCh7IrqFlagClrWriteCmd
8114f444 g     O .bss	00001000 vFeeTask0_stk
81118034 g     F .text	0000004c vFailDeleteInitialization
8114ec90 g     O .bss	00000004 aux_status_register
81150444 g     O .bss	00001000 vInAckHandlerTask_stk
81145ff8 g     F .text	00000044 alt_msgdma_standard_descriptor_async_transfer
8110689c g     F .text	00000050 uliRmapCh1WriteCmdAddress
8110bb44 g     F .text	0000004c vSyncInitIrq
81114110 g     F .text	00000284 vCheckRetransmission128
81128bd4 g     F .text	0000007c _mprec_log10
8110bd4c g     F .text	00000040 bSyncSetMbt
811195f8 g     F .text	00000054 vFailRequestDMAFromIRQ
81109c40 g     F .text	00000108 I2C_Read
8114ea9e g     O .rwdata	00000002 OSTaskNameSize
8114eb54 g     O .bss	00000004 xWaitSyncQFee
81151444 g     O .bss	00000260 xBuffer64
81128cc8 g     F .text	0000008c __any_on
8112769c g     F .text	0000005c _isatty_r
8114c37c g     O .rodata	00000028 __mprec_tinytens
81106844 g     F .text	00000058 bRmapCh8IrqFlagWriteCmd
811334c4 g     F .text	0000015c alt_main
8111df9c g     F .text	000000c8 _puts_r
81105640 g     F .text	00000058 bFeebCh3IrqFlagBufferEmpty
8114ec1c g     O .bss	00000004 OSTmrFreeList
81168a14 g     O .bss	00000100 alt_irq
8112780c g     F .text	00000068 _lseek_r
8111a770 g     F .text	00000030 vChangeDefaultAutoResetSync
81138394 g     F .text	000000d4 OS_MemInit
811195a4 g     F .text	00000054 vFailRequestDMA
81116b18 g     F .text	000009d4 vLoadDefaultETHConf
8110f6d4 g     F .text	0000014c bCheckInAck64
811516a4 g     O .bss	00000150 xPus
8113ce30 g     F .text	00000068 OSTimeSet
81112d54 g     F .text	0000008c vPusType250run
811268e0 g     F .text	000000ac __sflags
81118f78 g     F .text	00000068 vCoudlNotCreateNFee2Task
81119364 g     F .text	0000004c vCouldNotGetMutexMebPus
8113150c g     F .text	00000088 .hidden __eqdf2
81113420 g     F .text	00000088 vSendCmdQToDataCTRL
81102a8c g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_FULL
8111a65c g     F .text	00000034 vLoadDefaultSyncSource
81117acc g     F .text	0000004c vFailCreateMutexDMA
8113e4e0 g     F .text	000001ac Check_for_Master_Boot_Record
81162428 g     O .bss	00000010 OSTmrWheelTbl
8110693c g     F .text	00000050 uliRmapCh3WriteCmdAddress
81144d84 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_mm_descriptor
811517f4 g     O .bss	00000010 xFeeQueueTBL3
8113451c g     F .text	00000594 OSEventPendMulti
8114eb58 g     O .bss	00000004 xNfeeSchedule
81168b14 g       *ABS*	00000000 __alt_heap_start
81146eb8 g     F .text	0000002c OSTaskCreateHook
81142358 g     F .text	000001c4 alt_up_sd_card_fclose
8114eb5c g     O .bss	00000004 xSemCountBuffer64
811044b0 g     F .text	0000016c bCommSetGlobalIrqEn
81106d40 g     F .text	00000088 bRmapGetIrqControl
8111dde0 g     F .text	00000044 printf
8114eb31 g     O .bss	00000001 SspdConfigControl
8110c168 g     F .text	00000054 bSyncCtrReset
8114ea76 g     O .rwdata	00000002 OSMboxEn
8111b2cc g     F .text	000000a4 aatoh
81134b14 g     F .text	00000054 OSIntEnter
8112f27c g     F .text	000000a4 _wcrtomb_r
8110554c g     F .text	00000044 vFeebCh8IrqFlagClrBufferEmpty
81117f9c g     F .text	0000004c vFailReceiverCreate
8114eb60 g     O .bss	00000004 xQMaskDataCtrl
8110505c g     F .text	00000084 vFeebCh2HandleIrq
8111e504 g     F .text	00000064 __sseek
81126890 g     F .text	00000010 __sinit
8110adc0 g     F .text	00000044 iMsgdmaExtendedDescriptorAsyncTransfer
81124658 g     F .text	00000148 __swbuf_r
811148e8 g     F .text	00000470 bResourcesInitRTOS
811093a8 g     F .text	000000f4 bSpwcGetLinkError
8114ea86 g     O .rwdata	00000002 OSQEn
8110ded4 g     F .text	000003ac vQCmdFeeRMAPinStandBy
8110627c g     F .text	00000040 vRmapCh4HandleIrq
81127728 g     F .text	00000084 _setlocale_r
81151804 g     O .bss	00000010 SyncTBL2
8114e9fc g     O .rwdata	00000004 LedsPainelControl
8114ee2c g     O .bss	00000100 cDebugBuffer
811266e8 g     F .text	00000070 __sfmoreglue
8112cba8 g     F .text	00000018 ungetc
811341d8 g     F .text	000000d4 __malloc_unlock
81102d88 g     F .text	00000214 DMA_MULTIPLE_TRANSFER
81146f38 g     F .text	00000028 OSTaskStatHook
8111327c g     F .text	00000088 vSendCmdQToNFeeCTRL
8111a6cc g     F .text	00000030 vChangeDefaultSyncSource
8114ec20 g     O .bss	00000001 OSLockNesting
8114ec24 g     O .bss	00000004 OSTmrSemSignal
81119a24 g     F .text	00000178 vNFeeStructureInit
8114eb64 g     O .bss	00000004 xSemCommInit
81102910 g     F .text	00000080 uliXorshift32
811295bc g     F .text	00001600 _strtod_r
8114eb68 g     O .bss	00000004 xSemCountSenderACK
8111b408 g     F .text	00000448 .hidden __divsf3
8114ecb4 g     O .bss	00000004 current_sector_modified
8114eac4 g     O .rwdata	00000002 OSDataSize
8114ec28 g     O .bss	00000001 OSRunning
81109684 g     F .text	00000184 bSpwcInitCh
8113318c g     F .text	00000064 alt_log_jtag_uart_isr_proc
81151814 g     O .bss	00001000 senderTask_stk
81107834 g     F .text	00000094 bRmapGetMemConfigStat
8114eb6c g     O .bss	00000004 fp
81152814 g     O .bss	00000030 xNfeeScheduleTBL
8110f58c g     F .text	00000148 bCheckInAck128
81127b9c g     F .text	0000015c memmove
81146fb4 g     F .text	0000002c OSInitHookBegin
8110c604 g     F .text	00000074 bSyncCtrCh8OutEnable
8110e6a4 g     F .text	00000084 bEnableDbBuffer
8114eabc g     O .rwdata	00000002 OSTmrSize
81126878 g     F .text	00000018 _cleanup
8111ab98 g     F .text	00000040 siCloseFile
81105f48 g     F .text	00000184 bFeebInitCh
81127cf8 g     F .text	000000b0 _Balloc
8111a6fc g     F .text	00000038 vLoadDefaultAutoResetSync
81106e50 g     F .text	000000d8 bRmapSetCodecConfig
81140f34 g     F .text	000000cc alt_up_sd_card_is_Present
81144cc4 g     F .text	00000060 alt_msgdma_construct_standard_st_to_mm_descriptor
8114ead8 g     O .bss	00000004 pxDmaM1Dev
81102b24 g     F .text	000000a8 DMA_DISPATCHER_STOP
8113e208 g     F .text	00000054 Save_Modified_Sector
811057a0 g     F .text	00000058 bFeebCh7IrqFlagBufferEmpty
8114ec2c g     O .bss	00000004 OSIdleCtr
8114ebe8 g     O .bss	00000001 alt_log_write_on_flag
811098ac g     F .text	0000003c bEnableIsoDrivers
81131594 g     F .text	000000dc .hidden __gtdf2
81146c48 g     F .text	0000002c altera_nios2_gen2_irq_init
81146d30 g       .text	00000000 OSStartTsk
8110bec0 g     F .text	00000070 bSyncSetNCycles
8113608c g     F .text	000002dc OS_TCBInit
8114ebeb g     O .bss	00000001 alt_log_jtag_uart_isr_on_flag
8111a2e4 g     F .text	00000078 vInitSimucamBasicHW
81152844 g     O .bss	00001000 vTimeoutCheckerTask_stk
8110c51c g     F .text	00000074 bSyncCtrCh6OutEnable
81109fbc g     F .text	00000138 i2c_write
86020000 g     F .entry	00000000 __reset
8114ecac g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
8114ec30 g     O .bss	00000002 OSTmrUsed
8114eb70 g     O .bss	00000004 xSemCountBuffer128
81103264 g     F .text	000000f8 TEMP_Read
81106c98 g     F .text	000000a8 bRmapSetIrqControl
81153844 g     O .bss	00001000 vDataControlTask_stk
81105164 g     F .text	00000084 vFeebCh4HandleIrq
8114eac2 g     O .rwdata	00000002 OSTmrWheelTblSize
81119f8c g     F .text	0000002c cFeeSpwChannelDisable
8114ea62 g     O .rwdata	00000002 OSEventSize
8114ec32 g     O .bss	00000001 OSPrioHighRdy
8111cf7c g     F .text	00000064 _fstat_r
81146ee4 g     F .text	0000002c OSTaskDelHook
8114ebc4 g     O .bss	00000004 errno
8110c8f8 g     F .text	0000003c uliSyncGetCtr
811245e8 g     F .text	0000001c __svfscanf
8111e478 g     F .text	00000008 __seofread
81146d10 g       .text	00000000 OSStartHighRdy
81119984 g     F .text	00000028 vEvtChangeFeeControllerMode
8110e8d4 g     F .text	00000968 vPrintConsoleNFee
811104dc g     F .text	000000c8 bSendCmdQToNFeeInst
8110633c g     F .text	00000040 vRmapCh7HandleIrq
8113b860 g     F .text	000001ec OSTaskCreateExt
811623fc g     O .bss	00000011 alt_log_write_buf
811049c8 g     F .text	0000012c bDpktGetPacketConfig
81106acc g     F .text	00000050 uliRmapCh8WriteCmdAddress
81118358 g     F .text	00000068 vFailGetCountSemaphorePreParsedBuffer
8112b6ec g     F .text	00001244 ___svfiprintf_internal_r
81111fb0 g     F .text	00000364 bPreParserV2
81137414 g     F .text	00000068 OSFlagPendGetFlagsRdy
8114eaa2 g     O .rwdata	00000002 OSTaskStatStkSize
81136560 g     F .text	00000310 OSFlagAccept
81139b3c g     F .text	000000c0 OSQFlush
811395b8 g     F .text	00000148 OSQAccept
8114ebfc g     O .bss	00000004 alt_argv
811569f4 g       *ABS*	00000000 _gp
81117c64 g     F .text	0000004c vFailSendPreAckReceiverSemaphore
81133cf0 g     F .text	0000013c usleep
8114150c g     F .text	00000384 alt_up_sd_card_fopen
8111aa04 g     F .text	00000030 bSDcardIsPresent
81112314 g     F .text	00000178 vSenderComTask
81141074 g     F .text	000000d8 alt_up_sd_card_find_first
8113b6ac g     F .text	000001b4 OSTaskCreate
811184f8 g     F .text	00000068 vFailSendNack
8114eca0 g     O .bss	00000004 command_argument_register
8113b1b4 g     F .text	000004f8 OSTaskChangePrio
81112918 g     F .text	000000ac vPusMebInTaskConfigMode
81118c70 g     F .text	00000088 vCouldNotSendTMPusCommand
8114ec18 g     O .bss	00000004 alt_heapsem
8110a254 g     F .text	00000080 bSetBoardLeds
81136368 g     F .text	000001f8 OSDebugInit
8113ba4c g     F .text	0000034c OSTaskDel
81138468 g     F .text	000001ac OSMutexAccept
81154844 g     O .bss	000002b4 xSimMeb
8111a1c8 g     F .text	00000040 vSetTimeCode
8114586c g     F .text	000000dc alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits
8114eb74 g     O .bss	00000004 xSemCountPreParsed
8114d5a8 g     O .rwdata	00000180 alt_fd_list
811056f0 g     F .text	00000058 bFeebCh5IrqFlagBufferEmpty
8114d744 g     O .rwdata	0000001d alt_log_msg_alt_main
81162438 g     O .bss	00000840 OSFlagTbl
811065dc g     F .text	00000058 bRmapCh1IrqFlagWriteCmd
81117dcc g     F .text	00000068 vFailGetCountSemaphoreReceiverTask
811069dc g     F .text	00000050 uliRmapCh5WriteCmdAddress
8111a5b4 g     F .text	0000003c vLoadDefaultRTValue
81135598 g     F .text	000000c0 OS_EventTaskRemove
81154af8 g     O .bss	00001000 vFeeTask5_stk
8114ebea g     O .bss	00000001 alt_log_jtag_uart_alarm_on_flag
81140788 g     F .text	00000134 find_first_empty_record_in_root_directory
8114632c g     F .text	00000098 alt_find_dev
8111dac8 g     F .text	00000150 memcpy
8112ef48 g     F .text	00000264 __hexnan
81104dc4 g     F .text	00000174 bDpktInitCh
81155af8 g     O .bss	00000160 xBuffer32
8114ea8c g     O .rwdata	00000002 OSRdyTblSize
81162c78 g     O .bss	000001a0 OSTmrTbl
81126530 g     F .text	0000000c _cleanup_r
811320e8 g     F .text	000000e4 .hidden __floatsidf
81116740 g     F .text	000001a8 vSendPusTM64
8110bcbc g     F .text	0000004c ucSyncStatusErrorCode
8111338c g     F .text	00000094 vSendCmdQToNFeeCTRL_GEN
8111a088 g     F .text	00000034 cFeeRMAPLogDisable
8111089c g     F .text	00000df0 vParserCommTask
8114694c g     F .text	00000084 alt_io_redirect
8111a01c g     F .text	00000034 cFeeRMAPEchoingDisable
81131670 g     F .text	000000f4 .hidden __ltdf2
811192b0 g     F .text	0000004c vFailSendPUStoMebTask
811067ec g     F .text	00000058 bRmapCh7IrqFlagWriteCmd
811059cc g     F .text	000000d4 bFeebSetIrqControl
81118a68 g     F .text	00000068 vCouldNotRetransmitB128TimeoutTask
8114eb78 g     O .bss	00000004 xMutexReceivedACK
81103be0 g     F .text	000000b0 bSdmaInitM2Dma
8114eae8 g     O .bss	00000004 EDpktMode
81145cf4 g     F .text	00000094 alt_msgdma_start_prefetcher_with_extd_desc_list
8114603c g     F .text	00000044 alt_msgdma_extended_descriptor_async_transfer
8110c210 g     F .text	00000054 bSyncCtrErrInj
81145f9c g     F .text	0000005c alt_msgdma_register_callback
811174ec g     F .text	00000330 vShowEthConfig
8111a35c g     F .text	00000030 bLogWriteSDCard
811180e8 g     F .text	00000068 vFailSetCountSemaphorexBuffer64
8111e064 g     F .text	00000014 puts
8111ac18 g     F .text	00000270 bInitSync
8114705c g     F .text	000000a4 alt_exception_cause_generated_bad_addr
8110b9cc g     F .text	0000014c vSyncHandleIrq
811342ac g     F .text	00000128 OSEventNameGet
811053b4 g     F .text	00000044 vFeebCh2IrqFlagClrBufferEmpty
8114ea70 g     O .rwdata	00000002 OSFlagMax
81127928 g     F .text	000000e0 mbrtowc
81140380 g     F .text	000001b4 find_first_empty_cluster
811134a8 g     F .text	00000088 vSendCmdQToDataCTRL_PRIO
8110c4a8 g     F .text	00000074 bSyncCtrCh5OutEnable
8114eb38 g     O .bss	00000001 vucN
81129328 g     F .text	00000074 __fpclassifyd
8110bc1c g     F .text	00000054 bSyncStatusExtnIrq
81124604 g     F .text	00000054 _vfscanf_r
81138ae8 g     F .text	000005a4 OSMutexPend
81128b28 g     F .text	000000ac __ratio
81140e70 g     F .text	000000c4 alt_up_sd_card_open_dev
81118cf8 g     F .text	00000068 vWarnCouldNotgetMutexRetrans128
81134b68 g     F .text	00000100 OSIntExit
8110bd8c g     F .text	00000040 bSyncSetBt
8112e140 g     F .text	0000001c __vfiprintf_internal
811193b0 g     F .text	00000068 vCouldNotCreateQueueMaskNfeeCtrl
8114eaaa g     O .rwdata	00000002 OSTCBSize
81105370 g     F .text	00000044 vFeebCh1IrqFlagClrBufferEmpty
8114ec33 g     O .bss	00000001 OSPrioCur
81142da0 g     F .text	000002c4 altera_avalon_jtag_uart_read
81145534 g     F .text	000000f8 alt_msgdma_prefetcher_add_standard_desc_to_list
8111dda8 g     F .text	00000038 _printf_r
811300b0 g     F .text	00000064 .hidden __udivsi3
811327ec g     F .text	000000ac isatty
8114eb30 g     O .bss	00000001 LedsBoardControl
8114eb7c g     O .bss	00000004 xSemCountReceivedACK
8114ea90 g     O .rwdata	00000002 OSStkWidth
811276f8 g     F .text	00000030 iswspace
8114c3cc g     O .rodata	000000c8 __mprec_tens
8114ea84 g     O .rwdata	00000002 OSPtrSize
8111964c g     F .text	00000054 vFailSendRMAPFromIRQ
81119118 g     F .text	00000068 vCoudlNotCreateNFeeControllerTask
811277ac g     F .text	0000000c __locale_charset
8110c3c0 g     F .text	00000074 bSyncCtrCh3OutEnable
811302a0 g     F .text	000000c8 .hidden __lesf2
8114ea64 g     O .rwdata	00000002 OSEventTblSize
8112f47c g     F .text	0000007c .hidden __fixunsdfsi
81146c74 g       .text	00000000 OSCtxSw
81109d48 g     F .text	00000160 I2C_MultipleRead
81133330 g     F .text	00000074 alt_log_system_clock
8114ebd0 g     O .bss	00000004 __malloc_top_pad
8114ec34 g     O .bss	00000004 OSTCBList
8113d8b0 g     F .text	00000040 OSTmrSignal
8114ebe0 g     O .bss	00000004 alt_fd_list_lock
8112b218 g     F .text	0000001c strtoul
8114ea14 g     O .rwdata	00000004 __mb_cur_max
811277dc g     F .text	0000000c _localeconv_r
8112b234 g     F .text	000002e0 _strtoull_r
8110b410 g     F .text	00000070 vRstcHoldDeviceReset
8112811c g     F .text	00000044 __i2b
81127040 g     F .text	000004c4 __sfvwrite_r
8113f660 g     F .text	000000c0 get_dir_divider_location
81106488 g     F .text	00000044 vRmapCh4IrqFlagClrWriteCmd
81162e18 g     O .bss	00000c30 OSMemTbl
8114ec38 g     O .bss	00000001 OSTickStepState
81132f40 g     F .text	00000060 alt_log_printf_proc
81104d00 g     F .text	000000c4 bDpktGetPixelDelay
81155c58 g     O .bss	00001800 vReceiverUartTask_stk
8111e270 g     F .text	0000005c _sbrk_r
8114eb80 g     O .bss	00000004 xSemTimeoutChecker
8113f320 g     F .text	000000cc filename_to_upper_case
8114ebec g     O .bss	00000001 alt_log_jtag_uart_startup_info_on_flag
8114ea88 g     O .rwdata	00000002 OSQMax
81141890 g     F .text	00000090 alt_up_sd_card_set_attributes
811387e4 g     F .text	00000304 OSMutexDel
81163a48 g     O .bss	00001000 OSTaskStatStk
8111aa34 g     F .text	00000030 bSDcardFAT16Check
81137fb0 g     F .text	000000f8 OSMemNameGet
81117a6c g     F .text	00000060 vFailCreateMutexSResources
8113e68c g     F .text	00000284 Read_File_Record_At_Offset
81157458 g     O .bss	00000040 xQMaskCMDNDataCtrlTBL
8114ea68 g     O .rwdata	00000002 OSFlagEn
81128d54 g     F .text	00000068 _read_r
8114eaae g     O .rwdata	00000002 OSTimeTickHookEn
81137c30 g     F .text	000000ac OS_FlagUnlink
8113a004 g     F .text	00000170 OSQPost
81102478 g     F .text	00000498 bDdr2MemoryRandomReadTest
8114ea30 g     O .rwdata	00000004 alt_max_fd
81118814 g     F .text	0000004c vFailTimeoutCheckerTaskCreate
81135bd4 g     F .text	00000070 OS_MemCopy
81135c44 g     F .text	000000d8 OS_Sched
8113ff04 g     F .text	0000047c find_file_in_directory
8112e2ec g     F .text	000000f8 _fclose_r
81137eb8 g     F .text	000000f8 OSMemGet
8113c090 g     F .text	000001bc OSTaskNameSet
811264f8 g     F .text	00000030 fflush
8114ebcc g     O .bss	00000004 __malloc_max_sbrked_mem
8114ec3c g     O .bss	00000004 OSCtxSwCtr
81146f60 g     F .text	00000054 OSTimeTickHook
81157498 g     O .bss	00001000 vOutAckHandlerTask_stk
81132620 g     F .text	00000188 alt_irq_register
8114ea72 g     O .rwdata	00000002 OSFlagNameSize
8111c598 g     F .text	00000118 .hidden __extendsfdf2
81135658 g     F .text	00000108 OS_EventTaskRemoveMulti
81118e38 g     F .text	00000070 vFailCreateNFEESyncQueue
81141000 g     F .text	00000074 alt_up_sd_card_is_FAT16
81109ad8 g     F .text	00000088 I2C_TestAdress
81130368 g     F .text	000008b4 .hidden __adddf3
81162410 g     O .bss	00000018 alt_log_jtag_uart_alarm_1
8113016c g     F .text	00000078 .hidden __nesf2
81106444 g     F .text	00000044 vRmapCh3IrqFlagClrWriteCmd
81135440 g     F .text	00000158 OS_EventTaskWaitMulti
81158498 g     O .bss	00000010 SyncTBL4
811288c0 g     F .text	00000114 __b2d
8114526c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor
8114ea8a g     O .rwdata	00000002 OSQSize
8112fa78 g     F .text	00000540 .hidden __umoddi3
811333e8 g     F .text	000000dc lseek
8113aaf4 g     F .text	00000214 OSSemPend
811192fc g     F .text	00000068 vCouldNotGetCmdQueueMeb
81106fb4 g     F .text	00000160 bRmapGetCodecStatus
8110949c g     F .text	000000d0 bSpwcGetLinkStatus
81105d28 g     F .text	00000088 bFeebGetWindowing
8114ea04 g     O .rwdata	00000004 _global_impure_ptr
8110b980 g     F .text	0000004c bSSDisplayUpdate
8113f9c4 g     F .text	00000540 get_home_directory_cluster_for_file
81128dbc g     F .text	0000056c _realloc_r
8114ea74 g     O .rwdata	00000002 OSLowestPrio
81168b14 g       *ABS*	00000000 __bss_end
81146788 g     F .text	000000f8 alt_iic_isr_register
81147030 g     F .text	0000002c OSTCBInitHook
8114eaba g     O .rwdata	00000002 OSTmrCfgTicksPerSec
81133be0 g     F .text	00000110 alt_tick
81106b1c g     F .text	0000017c vRmapInitIrq
81117d64 g     F .text	00000068 vFailGetMutexSenderTask
8110b330 g     F .text	0000006c vRstcSimucamReset
8110e78c g     F .text	000000a4 bSendRequestNFeeCtrl
8114c534 g     O .rodata	00000100 __hexdig
81145de8 g     F .text	000001b4 alt_msgdma_init
8112f4f8 g     F .text	00000580 .hidden __udivdi3
81111c98 g     F .text	0000017c setPreAckSenderFreePos
8112e564 g     F .text	00000024 _fputwc_r
8114ea5c g     O .rwdata	00000002 OSEventEn
8114c3a4 g     O .rodata	00000028 __mprec_bigtens
81127ef8 g     F .text	0000010c __s2b
8114eab6 g     O .rwdata	00000002 OSTmrCfgNameSize
811584a8 g     O .bss	00000010 xFeeQueueTBL4
8110be4c g     F .text	00000074 bSyncSetPolarity
81114394 g     F .text	0000028c vCheckRetransmission64
811321cc g     F .text	000000b0 .hidden __floatunsidf
8114ebf0 g     O .bss	00000004 alt_system_clock_in_sec
81133138 g     F .text	00000054 alt_log_jtag_uart_startup_info
811182f0 g     F .text	00000068 vFailFoundBufferRetransmission
811285f8 g     F .text	00000060 __mcmp
8114ecb8 g     O .bss	00000004 current_sector_index
81143560 g     F .text	00000168 altera_avalon_uart_init
811460c4 g     F .text	00000044 alt_msgdma_extended_descriptor_sync_transfer
8110409c g     F .text	00000414 bSdmaDmaM2Transfer
8111a208 g     F .text	00000034 vResetTimeCode
81119f60 g     F .text	0000002c cFeeSpwChannelEnable
811268b0 g     F .text	00000018 __fp_lock_all
811197e0 g     F .text	0000004c vFailSendMsgDataCTRL
81146734 g     F .text	00000054 alt_ic_irq_enabled
81109b60 g     F .text	000000e0 I2C_Write
8110668c g     F .text	00000058 bRmapCh3IrqFlagWriteCmd
8114ec40 g     O .bss	00000002 OSTmrFree
81137a4c g     F .text	000000e8 OS_FlagInit
81133b3c g     F .text	000000a4 alt_alarm_stop
8111e8d8 g     F .text	0000001c strtol
8114ebe9 g     O .bss	00000001 alt_log_sys_clk_on_flag
8113d05c g     F .text	00000140 OSTmrDel
8113e3f8 g     F .text	000000e8 mark_cluster
8114ea98 g     O .rwdata	00000002 OSTaskIdleStkSize
8114ebe4 g     O .bss	00000004 alt_irq_active
8113a714 g     F .text	000000b8 OSSemAccept
8111cb14 g     F .text	0000044c _fseeko_r
811151f8 g     F .text	00000260 vFillMemmoryPattern
8111e654 g     F .text	00000044 strnlen
811381c4 g     F .text	000000e0 OSMemPut
81137cdc g     F .text	000001dc OSMemCreate
8114ec44 g     O .bss	00000004 OSIdleCtrMax
811168e8 g     F .text	000001a8 vSendPusTM128
81100104 g     F .exceptions	000000dc alt_irq_handler
81132988 g     F .text	000005b8 alt_log_private_printf
8114d580 g     O .rwdata	00000028 alt_dev_null
81144e7c g     F .text	00000098 alt_msgdma_construct_extended_mm_to_st_descriptor
8110be0c g     F .text	00000040 bSyncSetOst
8114eaac g     O .rwdata	00000002 OSTicksPerSec
8114d728 g     O .rwdata	00000019 alt_log_msg_bss
811408bc g     F .text	00000194 convert_filename_to_name_extension
811078c8 g     F .text	00000c4c bRmapSetRmapMemHKArea
8111248c g     F .text	00000330 vSimMebTask
81109ea8 g     F .text	00000094 i2c_start
81146c74 g       .text	00000000 OSIntCtxSw
811196a0 g     F .text	00000054 vFailSendMsgSync
8110c434 g     F .text	00000074 bSyncCtrCh4OutEnable
81145c60 g     F .text	00000094 alt_msgdma_start_prefetcher_with_std_desc_list
811324c8 g     F .text	00000028 alt_dcache_flush_all
81128004 g     F .text	00000068 __hi0bits
81112de0 g     F .text	00000114 vPusType251run
81106a2c g     F .text	00000050 uliRmapCh6WriteCmdAddress
8111a5f0 g     F .text	0000003c vChangeRTValue
8114ec8c g     O .bss	00000004 is_sd_card_formated_as_FAT16
81113f8c g     F .text	00000184 vCheck
811199d4 g     F .text	00000050 vNFeeNotInUse
81132068 g     F .text	00000080 .hidden __fixdfsi
81105e38 g     F .text	00000088 bFeebStopCh
8110fef0 g     F .text	000003f8 vNFeeControlTask
811584b8 g     O .bss	00001000 vInitialTask_stk
8114eb84 g     O .bss	00000002 usiIdCMD
811594b8 g     O .bss	00000010 SyncTBL3
8110c114 g     F .text	00000054 bSyncCtrStart
81140534 g     F .text	00000254 find_first_empty_record_in_a_subdirectory
8112abbc g     F .text	00000018 strtod
81105ec0 g     F .text	00000088 bFeebClrCh
8114ec48 g     O .bss	00000004 OSTCBFreeList
81106794 g     F .text	00000058 bRmapCh6IrqFlagWriteCmd
8113ad08 g     F .text	00000174 OSSemPendAbort
81117f04 g     F .text	0000004c vFailGetMacRTC
8110698c g     F .text	00000050 uliRmapCh4WriteCmdAddress
81100000 g       *ABS*	00000000 __alt_mem_onchip_memory
8111877c g     F .text	0000004c vFailCreateTimerRetransmisison
81118288 g     F .text	00000068 vFailGetCountSemaphorexBuffer32
811157b0 g     F .text	000002f0 bSendUART128v2
8111a424 g     F .text	000000ec vSimucamStructureInit
8114ea28 g     O .rwdata	00000008 alt_dev_list
8111ca44 g     F .text	0000004c _fputc_r
81133e70 g     F .text	0000010c write
8111de24 g     F .text	000000a8 _putc_r
8114ecb0 g     O .bss	00000004 device_pointer
8114eab0 g     O .rwdata	00000002 OSVersionNbr
811301e4 g     F .text	000000bc .hidden __gtsf2
811198c4 g     F .text	0000004c vFailFlushMEBQueue
8111168c g     F .text	00000118 getPreParsedPacket
8110e644 g     F .text	00000060 bEnableSPWChannel
81132568 g     F .text	000000b8 fstat
8111a270 g     F .text	00000040 vChangeIdNFEEMaster
8111ca18 g     F .text	0000002c fprintf
8111a050 g     F .text	00000038 cFeeRMAPLogEnable
81102c74 g     F .text	00000114 DMA_SINGLE_TRANSFER
81105748 g     F .text	00000058 bFeebCh6IrqFlagBufferEmpty
811188c8 g     F .text	00000068 vFailPostBlockingSemTimeoutTask
8111afac g     F .text	00000058 _reg_write
8111a2b0 g     F .text	00000034 vChangeDefaultIdNFEEMaster
81131670 g     F .text	000000f4 .hidden __ledf2
811062bc g     F .text	00000040 vRmapCh5HandleIrq
8110e53c g     F .text	0000004c bDisableRmapIRQ
811594c8 g     O .bss	00001000 vStackMonitor_stk
81118c08 g     F .text	00000068 vCouldNotSendLog
8113d2dc g     F .text	000001b8 OSTmrRemainGet
8114ea58 g     O .rwdata	00000004 OSEndiannessTest
8110b524 g     F .text	00000058 v_spi_start
81128360 g     F .text	00000148 __pow5mult
811068ec g     F .text	00000050 uliRmapCh2WriteCmdAddress
8112ccdc g     F .text	00001464 ___vfiprintf_internal_r
8114ebdc g     O .bss	00000004 __nlocale_changed
81130114 g     F .text	00000058 .hidden __umodsi3
8110c264 g     F .text	00000074 bSyncCtrSyncOutEnable
8111aa64 g     F .text	000000f8 bInitializeSDCard
81118698 g     F .text	0000004c vFailParserCommTaskCreate
81118ba0 g     F .text	00000068 vCouldNotSendReset
8111e310 g     F .text	00000038 _scanf_r
81118730 g     F .text	0000004c vFailOutAckHandlerTaskCreate
8114ea6a g     O .rwdata	00000002 OSFlagGrpSize
811129c4 g     F .text	0000008c vPusType250conf
8115a4c8 g     O .bss	00000058 xInUseRetrans
8110bbcc g     F .text	00000050 bSyncIrqFlagSync
811452cc g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor
8113d494 g     F .text	000000ec OSTmrStateGet
81168b14 g       *ABS*	00000000 end
8110526c g     F .text	00000084 vFeebCh6HandleIrq
81115458 g     F .text	00000260 vPrintMemmoryPattern
81118428 g     F .text	00000068 vNoContentInPreParsedBuffer
8111cf60 g     F .text	0000001c fseeko
811117a4 g     F .text	00000168 bSendMessagePUStoMebTask
81118dc8 g     F .text	00000070 vFailCreateNFEEQueue
8111c8c8 g     F .text	0000000c _atoi_r
81143dac g     F .text	00000240 altera_avalon_uart_write
811328cc g     F .text	00000054 alt_log_txchar
8111caf8 g     F .text	0000001c fseek
81115720 g     F .text	00000090 vCCDChangeValues
811426a0 g     F .text	000001d0 altera_avalon_jtag_uart_init
81135ed4 g     F .text	000000e4 OS_TaskStat
811001e0 g     F .exceptions	0000007c alt_instruction_exception_entry
81117b64 g     F .text	0000004c vFailTestCriticasParts
811fa000 g       *ABS*	00000000 __alt_stack_pointer
8110200c g     F .text	0000046c bDdr2MemoryRandomWriteTest
811433b4 g     F .text	00000084 alt_avalon_timer_sc_init
81105c80 g     F .text	000000a8 bFeebSetWindowing
811434a0 g     F .text	00000068 altera_avalon_uart_write_fd
8111c858 g     F .text	00000064 .hidden __clzsi2
81143508 g     F .text	00000058 altera_avalon_uart_close_fd
8115a520 g     O .bss	00000020 xMebQTBL
81143064 g     F .text	000002cc altera_avalon_jtag_uart_write
8113da08 g     F .text	00000174 OSTmr_Init
8115a540 g     O .bss	00000348 xBuffer128
811268a0 g     F .text	00000004 __sfp_lock_acquire
8110335c g     F .text	00000048 sense_log_temp
81127ab8 g     F .text	000000e4 memchr
81135b78 g     F .text	0000005c OS_MemClr
81120ad4 g     F .text	00002200 ___vfprintf_internal_r
81146d54 g     F .text	00000164 OSTaskStkInit
8111e348 g     F .text	00000060 _sprintf_r
81107560 g     F .text	000002d4 bRmapGetMemConfigArea
8114eb86 g     O .bss	00000001 SemCount32
81126d28 g     F .text	00000318 _free_r
811469d0 g     F .text	00000234 alt_printf
811166f0 g     F .text	00000050 vTimeoutCheck
8111b05c g     F .text	000001fc _print_codec_status
811277b8 g     F .text	00000010 __locale_mb_cur_max
81135188 g     F .text	000001a0 OS_EventTaskRdy
81106dc8 g     F .text	00000088 bRmapGetIrqFlags
81102bcc g     F .text	000000a8 DMA_DISPATCHER_RESET
811472a8 g     F .text	00000188 __call_exitprocs
811103b0 g     F .text	0000012c vPerformActionNFCRunning
8114ec4c g     O .bss	00000001 OSCPUUsage
81119048 g     F .text	00000068 vCoudlNotCreateNFee4Task
8114ebd8 g     O .bss	00000004 __mlocale_changed
811102e8 g     F .text	000000c8 vPerformActionNFCConfig
8110c1bc g     F .text	00000054 bSyncCtrOneShot
8114ea0c g     O .rwdata	00000004 __malloc_sbrk_base
8110025c g     F .text	000000ac _start
8110c934 g     F .text	0000003c uliSyncReadStatus
8114ec04 g     O .bss	00000004 _alt_tick_rate
81139bfc g     F .text	00000294 OSQPend
8112acdc g     F .text	000002e8 _strtoll_r
8115a888 g     O .bss	00000040 xQMaskCMDNFeeCtrlTBL
8113c980 g     F .text	0000010c OSTimeDly
81112ca8 g     F .text	000000ac vPusMebInTaskRunningMode
8110bb90 g     F .text	0000003c vSyncIrqFlagClrSync
811284a8 g     F .text	00000150 __lshift
811105a4 g     F .text	000002f8 vOutAckHandlerTask
81144d24 g     F .text	00000060 alt_msgdma_construct_standard_mm_to_st_descriptor
8114ec08 g     O .bss	00000004 _alt_nticks
811338d0 g     F .text	00000104 read
8113e05c g     F .text	000000f0 alt_sys_init
8111bc54 g     F .text	0000012c .hidden __floatsisf
81106400 g     F .text	00000044 vRmapCh2IrqFlagClrWriteCmd
8112b514 g     F .text	000001d8 __ssprint_r
8111dd40 g     F .text	00000068 _open_r
8111af24 g     F .text	00000088 bTestSimucamCriticalHW
81105bd4 g     F .text	000000ac bFeebGetBuffersStatus
8111781c g     F .text	000000a4 ucCrc8
81100818 g     F .text	00000cb0 bDdr2EepromDump
8114ec4d g     O .bss	00000001 OSTaskCtr
81132898 g       .text	00000000 tx_log_str
811127bc g     F .text	0000015c vPusMebTask
811166a0 g     F .text	00000050 siPosStr
81113304 g     F .text	00000088 vSendCmdQToNFeeCTRL_PRIO
8112f1ac g     F .text	000000d0 strncmp
8110c970 g     F .text	0000005c bSyncWriteReg
8110673c g     F .text	00000058 bRmapCh5IrqFlagWriteCmd
8113ca8c g     F .text	00000164 OSTimeDlyHMSM
81128160 g     F .text	00000200 __multiply
81142c38 g     F .text	00000070 altera_avalon_jtag_uart_close
8110b6f4 g     F .text	00000058 v_spi_end
8111abd8 g     F .text	00000040 cGetNextChar
811471bc g     F .text	000000ec strncpy
8114ee04 g     O .bss	00000028 __malloc_current_mallinfo
8114ea5e g     O .rwdata	00000002 OSEventMax
8113016c g     F .text	00000078 .hidden __eqsf2
811289d4 g     F .text	00000154 __d2b
8113ae7c g     F .text	00000118 OSSemPost
8110543c g     F .text	00000044 vFeebCh4IrqFlagClrBufferEmpty
8111a62c g     F .text	00000030 vChangeDefaultRTValue
81105330 g     F .text	00000040 vFeebCh8HandleIrq
8114ec88 g     O .bss	00000004 initialized
81116550 g     F .text	00000100 vSendLog
81134cfc g     F .text	000000e4 OSSchedUnlock
8110b74c g     F .text	00000164 RTCC_SPI_R_MAC
8114ea3c g     O .rwdata	00000004 alt_log_boot_on_flag
8114251c g     F .text	00000068 altera_avalon_jtag_uart_read_fd
8112afc4 g     F .text	00000254 _strtoul_r
8115a8c8 g     O .bss	00000010 xFeeQueueTBL5
811464d4 g     F .text	000000e4 alt_get_fd
8114ec50 g     O .bss	00000004 OSMemFreeList
81134e58 g     F .text	000000b8 OSStatInit
8111aef0 g     F .text	00000034 bClearCounterSync
81102990 g     F .text	00000064 DMA_OPEN_DEVICE
811684ac g     O .bss	00000014 search_data
81109190 g     F .text	00000134 bSpwcSetLink
8113227c g     F .text	00000130 alt_busy_sleep
81137818 g     F .text	000000cc OSFlagQuery
8110c2d8 g     F .text	00000074 bSyncCtrCh1OutEnable
8114ea94 g     O .rwdata	00000002 OSTaskCreateExtEn
8111b258 g     F .text	00000074 _split_codec_status
8112497c g     F .text	0000005c _close_r
81118490 g     F .text	00000068 vCouldNotSendEthConfUART
8110f96c g     F .text	00000584 vInitialTask
81133040 g     F .text	000000f8 alt_log_jtag_uart_print_control_reg
8114520c g     F .text	00000060 alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor
81147140 g     F .text	0000007c memcmp
81135160 g     F .text	00000028 OS_Dummy
811425ec g     F .text	00000058 altera_avalon_jtag_uart_close_fd
81168b14 g       *ABS*	00000000 __alt_stack_base
81142644 g     F .text	0000005c altera_avalon_jtag_uart_ioctl_fd
81105480 g     F .text	00000044 vFeebCh5IrqFlagClrBufferEmpty
8111cfe0 g     F .text	000000d4 _fwrite_r
811136a0 g     F .text	000000a4 vReleaseSyncMessages
8114532c g     F .text	000000a8 alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor
81105590 g     F .text	00000058 bFeebCh1IrqFlagBufferEmpty
81124820 g     F .text	0000015c __swsetup_r
81164a48 g     O .bss	00000300 OSQTbl
81119480 g     F .text	00000068 vCouldNotGetQueueMaskNfeeCtrl
811623e0 g     O .bss	0000001c xConfEth
81130c1c g     F .text	000008f0 .hidden __divdf3
8111a690 g     F .text	0000003c vChangeSyncSource
81126758 g     F .text	00000120 __sfp
811684c0 g     O .bss	00000054 boot_sector_data
81119418 g     F .text	00000068 vCouldNotCreateQueueMaskDataCtrl
811095fc g     F .text	00000088 bSpwcClearTimecode
81102ad8 g     F .text	0000004c DMA_DESCRIPTOR_BUFFER_EMPTY
81128c50 g     F .text	00000078 __copybits
8114d100 g     O .rwdata	00000408 __malloc_av_
811268ac g     F .text	00000004 __sinit_lock_release
8114ead0 g     O .bss	00000004 uliInitialState
81109f3c g     F .text	00000080 i2c_stop
8111b370 g     F .text	00000064 Verif_Error
8111b3d4 g     F .text	00000034 toInt
81117cb0 g     F .text	0000004c vFailSendPreAckSenderSemaphore
8114ec54 g     O .bss	00000004 OSTCBHighRdy
8111be78 g     F .text	00000720 .hidden __muldf3
8111e41c g     F .text	0000005c __sread
81126bc0 g     F .text	0000003c fread
8114ec58 g     O .bss	00000004 OSQFreeList
811463c4 g     F .text	00000110 alt_find_file
81146280 g     F .text	000000ac alt_dev_llist_insert
811340b0 g     F .text	00000128 __malloc_lock
8111c9e8 g     F .text	00000030 _fprintf_r
81133a40 g     F .text	000000fc sbrk
81119edc g     F .text	0000002c vFeeSpwRMAPLoadDefault
81118220 g     F .text	00000068 vFailGetCountSemaphorexBuffer64
8111e8f4 g     F .text	000021e0 ___svfprintf_internal_r
81116a90 g     F .text	00000088 vTMPusTestConnection
8114eb88 g     O .bss	00000004 xMebQ
811343d4 g     F .text	00000148 OSEventNameSet
81126494 g     F .text	00000064 _fflush_r
8112e220 g     F .text	000000cc _calloc_r
8114ec5c g     O .bss	00000001 OSRdyGrp
81119794 g     F .text	0000004c vFailSendMsgFeeCTRL
8110bd08 g     F .text	00000044 ucSyncStatusCycleNumber
81106f28 g     F .text	0000008c bRmapGetCodecConfig
8113d580 g     F .text	00000148 OSTmrStart
811051e8 g     F .text	00000084 vFeebCh5HandleIrq
8111c9d0 g     F .text	00000018 fopen
811029f4 g     F .text	0000004c DMA_CONFIG
8114ead0 g       *ABS*	00000000 __bss_start
8111dc18 g     F .text	00000128 memset
81111b5c g     F .text	0000013c setPreParsedFreePos
8110db4c g     F .text	000001bc vQCmdFEEinStandBy
81145d88 g     F .text	00000060 alt_msgdma_open
8111a7e8 g     F .text	0000021c pattern_createPattern
8111506c g     F .text	0000018c main
81117e34 g     F .text	00000068 vFailGetMutexReceiverTask
8115a8d8 g     O .bss	00001000 vNFeeControlTask_stk
81106598 g     F .text	00000044 vRmapCh8IrqFlagClrWriteCmd
8111a548 g     F .text	0000003c vChangeEPValue
811066e4 g     F .text	00000058 bRmapCh4IrqFlagWriteCmd
8114ec00 g     O .bss	00000004 alt_envp
8111982c g     F .text	0000004c vFailFlushQueue
8114ebc8 g     O .bss	00000004 __malloc_max_total_mem
8114562c g     F .text	000001a0 alt_msgdma_prefetcher_add_extended_desc_to_list
811178c0 g     F .text	0000005c ucCrc8wInit
811187c8 g     F .text	0000004c vCouldNotCheckBufferTimeOutFunction
81142584 g     F .text	00000068 altera_avalon_jtag_uart_write_fd
81102f9c g     F .text	000002c8 POWER_Read
8110a0f4 g     F .text	00000160 i2c_read
8115b8d8 g     O .bss	00000010 SyncTBL5
811247a0 g     F .text	00000018 __swbuf
8114c834 g     O .rodata	00000100 OSUnMapTbl
811302a0 g     F .text	000000c8 .hidden __ltsf2
81141920 g     F .text	00000090 alt_up_sd_card_get_attributes
8112698c g     F .text	00000234 _fread_r
81117cfc g     F .text	00000068 vFailGetCountSemaphoreSenderTask
811098e8 g     F .text	0000003c bDisableIsoDrivers
8114ea8e g     O .rwdata	00000002 OSSemEn
8113e14c g     F .text	000000bc Write_Sector_Data
81141d30 g     F .text	00000628 alt_up_sd_card_write
8114eb8c g     O .bss	00000004 xFeeQ
8113747c g     F .text	0000039c OSFlagPost
8111e568 g     F .text	00000008 __sclose
81118ad0 g     F .text	00000068 vFailStartTimerRetransmission
811fa000 g       *ABS*	00000000 __alt_heap_limit
8112e3e4 g     F .text	00000014 fclose
81135328 g     F .text	00000118 OS_EventTaskWait
81118998 g     F .text	00000068 vCouldNotRetransmitB32TimeoutTask
8111e698 g     F .text	00000240 _strtol_r
8111c6b0 g     F .text	000001a8 .hidden __truncdfsf2
8115b8e8 g     O .bss	00000010 xFeeQueueTBL2
81135fb8 g     F .text	000000d4 OS_TaskStatStkChk
8113bd98 g     F .text	00000158 OSTaskDelReq
81104af4 g     F .text	000000c4 bDpktGetPacketHeader
81106170 g     F .text	0000008c vRmapCh1HandleIrq
81124be0 g     F .text	00001690 _dtoa_r
81145948 g     F .text	00000318 alt_msgdma_start_prefetcher_with_list_addr
8111d2b4 g     F .text	00000814 _malloc_r
8115b8f8 g     O .bss	00000010 SyncTBL0
8112f3e8 g     F .text	00000030 __ascii_wctomb
81138614 g     F .text	000001d0 OSMutexCreate
81118930 g     F .text	00000068 vFailCouldNotRetransmitTimeoutTask
8110f820 g     F .text	0000014c bCheckInAck32
8114ea34 g     O .rwdata	00000004 alt_errno
81145474 g     F .text	000000c0 alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor
81134de0 g     F .text	00000078 OSStart
811092c4 g     F .text	000000e4 bSpwcGetLink
8110ae48 g     F .text	000004e8 POWER_SPI_RW
8112c930 g     F .text	000000dc __submore
81132fa0 g     F .text	000000a0 altera_avalon_jtag_uart_report_log
81134048 g     F .text	00000068 __env_unlock
81118f10 g     F .text	00000068 vCoudlNotCreateNFee1Task
81127504 g     F .text	000000cc _fwalk
8113c24c g     F .text	000001dc OSTaskResume
811382a4 g     F .text	000000f0 OSMemQuery
8114eaa0 g     O .rwdata	00000002 OSTaskStatEn
81168b14 g       *ABS*	00000000 __alt_stack_limit
8114eaec g     O .bss	00000004 ECommSpwCh
8111a734 g     F .text	0000003c vChangeAutoResetSync
81127a54 g     F .text	00000064 _mbtowc_r
8110f23c g     F .text	00000350 vInAckHandlerTaskV2
8114ea7a g     O .rwdata	00000002 OSMemMax
8113a174 g     F .text	00000178 OSQPostFront
8111decc g     F .text	000000d0 putc
8112ffb8 g     F .text	00000084 .hidden __divsi3
8114ec5d g     O .bss	00000006 OSRdyTbl
8114ea54 g     O .rwdata	00000002 OSDebugEn
8114d798 g     O .rwdata	0000002a alt_log_msg_cache
81126bfc g     F .text	0000012c _malloc_trim_r
81108ce0 g     F .text	000001a4 bRmapInitCh
8114ebbc g     O .bss	00000008 xSdHandle
8111b850 g     F .text	00000404 .hidden __mulsf3
8114ea6c g     O .rwdata	00000002 OSFlagNodeSize
8114ead4 g     O .bss	00000004 pnt_memory
8111a7a0 g     F .text	00000048 vSyncReset
8110bdcc g     F .text	00000040 bSyncSetPer
81100308 g     F .text	00000510 bDdr2EepromTest
8114ec94 g     O .bss	00000004 status_register
8114eab4 g     O .rwdata	00000002 OSTmrCfgMax
8110c760 g     F .text	00000074 bSyncIrqFlagClrError
81118560 g     F .text	00000068 vFailSetPreAckSenderBuffer
81129474 g     F .text	000000dc strcmp
8114ec9c g     O .bss	00000004 command_register
81139700 g     F .text	000001b4 OSQCreate
8113bef0 g     F .text	000001a0 OSTaskNameGet
8115b908 g     O .bss	00001000 vFeeTask4_stk
8115c908 g     O .bss	00000018 xReceivedACK
8113a2ec g     F .text	00000214 OSQPostOpt
81134f10 g     F .text	00000228 OSTimeTick
8114ea9c g     O .rwdata	00000002 OSTaskMax
8113a7cc g     F .text	000000e0 OSSemCreate
8114eac0 g     O .rwdata	00000002 OSTmrWheelSize
81118d60 g     F .text	00000068 vFailCreateScheduleQueue
8111b004 g     F .text	00000058 _reg_read
811392ac g     F .text	00000174 OSMutexQuery
8110e830 g     F .text	000000a4 bSendGiveBackNFeeCtrl
8113150c g     F .text	00000088 .hidden __nedf2
8114ea96 g     O .rwdata	00000002 OSTaskDelEn
8111a510 g     F .text	00000038 vLoadDefaultEPValue
8115c920 g     O .bss	00001000 vFeeTask1_stk
8110c590 g     F .text	00000074 bSyncCtrCh7OutEnable
8113af94 g     F .text	00000118 OSSemQuery
811398b4 g     F .text	00000288 OSQDel
81139e90 g     F .text	00000174 OSQPendAbort
8114eb90 g     O .bss	00000004 xMutexPreParsed
8113e01c g     F .text	00000040 alt_irq_init
811339d4 g     F .text	0000006c alt_release_fd
8113e33c g     F .text	000000bc get_cluster_flag
8110c7d4 g     F .text	00000074 bSyncIrqFlagClrBlank
81146080 g     F .text	00000044 alt_msgdma_standard_descriptor_sync_transfer
8110bb18 g     F .text	0000002c vSyncClearCounter
8114d764 g     O .rwdata	00000031 alt_log_msg_stackpointer
8111e3a8 g     F .text	00000074 sprintf
8114bf1c g     O .rodata	00000100 .hidden __clz_tab
8113e910 g     F .text	00000294 Write_File_Record_At_Offset
81101584 g     F .text	0000057c bDdr2MemoryWriteTest
81117e9c g     F .text	00000068 vFailGetMutexTxUARTSenderTask
8114ebd4 g     O .bss	00000004 _PathLocale
8110c8a0 g     F .text	00000058 bSyncIrqFlagBlank
8110ad00 g     F .text	000000c0 iMsgdmaConstructExtendedMmToMmDescriptor
8113d6c8 g     F .text	000001e8 OSTmrStop
81108ed8 g     F .text	00000050 uliRmapReadReg
81116650 g     F .text	00000050 usiGetIdCMD
8110c9cc g     F .text	00000058 uliSyncReadReg
8112abd4 g     F .text	00000108 strtof
811050e0 g     F .text	00000084 vFeebCh3HandleIrq
811301e4 g     F .text	000000bc .hidden __gesf2
8111e570 g     F .text	0000004c strcspn
811247b8 g     F .text	00000068 _write_r
8110b39c g     F .text	00000074 vRstcReleaseDeviceReset
811186e4 g     F .text	0000004c vFailInAckHandlerTaskCreate
81134c68 g     F .text	00000094 OSSchedLock
81118fe0 g     F .text	00000068 vCoudlNotCreateNFee3Task
811277e8 g     F .text	00000018 setlocale
811453d4 g     F .text	000000a0 alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor
81164d48 g     O .bss	00000800 OSTmrTaskStk
8111e2cc g     F .text	00000044 scanf
81119250 g     F .text	00000060 vFailCreateMutexSPUSQueueMeb
81136870 g     F .text	00000110 OSFlagCreate
8113eba4 g     F .text	00000688 Check_for_DOS_FAT
81113530 g     F .text	00000064 vMebInit
81140a50 g     F .text	000002d0 create_file
8112946c g     F .text	00000008 nanf
8114ea08 g     O .rwdata	00000004 _impure_ptr
8114ec98 g     O .bss	00000004 CSD_register_w0
8114ebf8 g     O .bss	00000004 alt_argc
811181b8 g     F .text	00000068 vFailGetCountSemaphorexBuffer128
81126270 g     F .text	00000224 __sflush_r
81127874 g     F .text	000000b4 _mbrtowc_r
8110956c g     F .text	00000090 bSpwcGetTimecode
811277d4 g     F .text	00000008 __locale_cjk_lang
811033a4 g     F .text	0000078c sense_log
8114eae0 g     O .bss	00000004 ESdmaBufferSide
8114ea66 g     O .rwdata	00000002 OSEventMultiEn
8111caf4 g     F .text	00000004 _fseek_r
8115d920 g     O .bss	00001800 vParserCommTask_stk
811179fc g     F .text	00000070 printErrorTask
8111a584 g     F .text	00000030 vChangeDefaultEPValue
81114620 g     F .text	000002c8 vCheckRetransmission32
8113ce98 g     F .text	000001c4 OSTmrCreate
81113744 g     F .text	000007dc vStackMonitor
8111e094 g     F .text	000001dc __srefill_r
81109924 g     F .text	0000003c bEnableLvdsBoard
8114eb94 g     O .bss	00000004 xMutexBuffer32
811061fc g     F .text	00000040 vRmapCh2HandleIrq
81136980 g     F .text	00000250 OSFlagDel
8114ec64 g     O .bss	00000004 OSEventFreeList
8110999c g     F .text	000000c0 bSetPreEmphasys
8110d99c g     F .text	000001b0 vQCmdFEEinConfig
81100020 g       .exceptions	00000000 alt_irq_entry
81127a08 g     F .text	0000004c __ascii_mbtowc
8110c09c g     F .text	00000078 bSyncCtrExtnIrq
8112885c g     F .text	00000064 __ulp
8111a0bc g     F .text	0000010c vNFeeControlInit
81113594 g     F .text	0000010c vSwapMemmory
81136e54 g     F .text	000005c0 OSFlagPend
8114eab2 g     O .rwdata	00000002 OSTmrEn
811268c8 g     F .text	00000018 __fp_unlock_all
8115f120 g     O .bss	00000010 xDma
8111ca90 g     F .text	00000064 fputc
8110e588 g     F .text	0000005c bEnableRmapIRQ
81115d98 g     F .text	000002f8 bSendUART32v2
81111e14 g     F .text	0000019c setPreAckReceiverFreePos
8110c05c g     F .text	00000040 bSyncErrInj
8114ea20 g     O .rwdata	00000008 alt_fs_list
8115f130 g     O .bss	00001000 vSimMebTask_stk
811191e8 g     F .text	00000068 vCoudlNotCreateMebTask
8113f3ec g     F .text	00000274 check_file_name_for_FAT16_compliance
81160130 g     O .bss	00001000 vFeeTask3_stk
8113d19c g     F .text	00000140 OSTmrNameGet
8114ef2c g     O .bss	00000400 xSZData
8110dd08 g     F .text	000001cc vQCmdFEEinFullPattern
81135d98 g     F .text	0000007c OS_StrCopy
8114eca4 g     O .bss	00000004 buffer_memory
811183c0 g     F .text	00000068 vFailGetxMutexPreParsedParserRxTask
8111a38c g     F .text	00000098 vLogWriteNUC
8114ea7c g     O .rwdata	00000002 OSMemNameSize
81103b30 g     F .text	000000b0 bSdmaInitM1Dma
8110c6ec g     F .text	00000074 bSyncIrqEnableBlank
81146fe0 g     F .text	00000028 OSInitHookEnd
81119b9c g     F .text	00000340 vUpdateMemMapFEE
81118630 g     F .text	00000068 vFailSetPreAckReceiverBuffer
811057f8 g     F .text	00000058 bFeebCh8IrqFlagBufferEmpty
8114eaa8 g     O .rwdata	00000002 OSTCBPrioTblMax
81127800 g     F .text	0000000c localeconv
81119180 g     F .text	00000068 vCoudlNotCreateDataControllerTask
8114eb98 g     O .bss	00000004 xTimerRetransmission
8111190c g     F .text	00000250 vReceiverUartTask
8114ebf4 g     O .bss	00000004 alt_log_sys_clk_count
8114eaa4 g     O .rwdata	00000002 OSTaskStatStkChkEn
811331f0 g     F .text	00000140 alt_log_write
81161130 g     O .bss	00001000 vFeeTask2_stk
8114eb9c g     O .bss	00000004 xMutexBuffer128
81104fdc g     F .text	00000080 vFeebCh1HandleIrq
8111ae88 g     F .text	00000038 bStartSync
811052f0 g     F .text	00000040 vFeebCh7HandleIrq
8111aec0 g     F .text	00000030 bStopSync
811465b8 g     F .text	00000058 alt_ic_isr_register
8114ea78 g     O .rwdata	00000002 OSMemEn
8110623c g     F .text	00000040 vRmapCh3HandleIrq
8114e9f4 g     O .rwdata	00000004 alt_stack_limit_value
81112ef4 g     F .text	00000388 vPusType252run
81119748 g     F .text	0000004c vFailSendMsgMasterSyncMeb
8111d0b4 g     F .text	0000003c fwrite
8114eca8 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
8114ea82 g     O .rwdata	00000002 OSMutexEn
811194e8 g     F .text	00000068 vCouldNotGetQueueMaskDataCtrl
8114ead0 g       *ABS*	00000000 _edata
81143438 g     F .text	00000068 altera_avalon_uart_read_fd
8111a23c g     F .text	00000034 vLoadDefaultIdNFEEMaster
81168b14 g       *ABS*	00000000 _end
81168514 g     O .bss	00000500 active_files
8114ec68 g     O .bss	00000001 OSIntNesting
81117f50 g     F .text	0000004c vFailInitialization
811014c8 g     F .text	000000bc bDdr2SwitchMemory
81119fb8 g     F .text	0000002c cFeeRMAPDump
8114eba0 g     O .bss	00000004 xSemCountBuffer32
8112e3f8 g     F .text	0000016c __fputwc
8114eba4 g     O .bss	00000004 xQMaskFeeCtrl
81119f08 g     F .text	0000002c vFeeSpwRMAPChangeConfig
81124578 g     F .text	00000070 vfscanf
81140d20 g     F .text	00000150 copy_file_record_name_to_string
81142ca8 g     F .text	000000f8 altera_avalon_jtag_uart_ioctl
8113cbf0 g     F .text	000001dc OSTimeDlyResume
8113f22c g     F .text	000000f4 Look_for_FAT16
8110e5e4 g     F .text	00000060 bDisableSPWChannel
81136d00 g     F .text	00000154 OSFlagNameSet
8110e728 g     F .text	00000064 bDisAndClrDbBuffer
8114eba8 g     O .bss	00000004 xMutexBuffer64
81107114 g     F .text	00000160 bRmapGetCodecError
8113c428 g     F .text	000001c8 OSTaskStkChk
811466a0 g     F .text	00000094 alt_ic_irq_disable
81103c90 g     F .text	0000040c bSdmaDmaM1Transfer
8114ea7e g     O .rwdata	00000002 OSMemSize
81112aa4 g     F .text	00000204 vPusType252conf
81118080 g     F .text	00000068 vFailSetCountSemaphorexBuffer32
8111e480 g     F .text	00000084 __swrite
8114ea10 g     O .rwdata	00000004 __malloc_trim_threshold
811277c8 g     F .text	0000000c __locale_msgcharset
81162130 g     O .bss	00000010 xFeeQueueTBL1
8114ec6c g     O .bss	00000004 OSTCBCur
81118a00 g     F .text	00000068 vCouldNotRetransmitB64TimeoutTask
8110ae04 g     F .text	00000044 iMsgdmaExtendedDescriptorSyncTransfer
81147100 g     F .text	00000040 exit
8113908c g     F .text	00000220 OSMutexPost
8110c848 g     F .text	00000058 bSyncIrqFlagError
8114114c g     F .text	000003c0 alt_up_sd_card_find_next
8114ea80 g     O .rwdata	00000002 OSMemTblSize
811275d0 g     F .text	000000cc _fwalk_reent
811457cc g     F .text	000000a0 alt_msgdma_prefetcher_set_std_list_own_by_hw_bits
8111bd80 g     F .text	000000f8 .hidden __floatunsisf
81128658 g     F .text	00000204 __mdiff
81118ea8 g     F .text	00000068 vCoudlNotCreateNFee0Task
81105850 g     F .text	0000017c vFeebInitIrq
8110479c g     F .text	0000022c bDpktSetPacketConfig
81117fe8 g     F .text	0000004c vFailSenderCreate
8113003c g     F .text	00000074 .hidden __modsi3
811190b0 g     F .text	00000068 vCoudlNotCreateNFee5Task
8110bfa8 g     F .text	0000003c uliSyncGetPer
811062fc g     F .text	00000040 vRmapCh6HandleIrq
8114ebac g     O .bss	00000004 xMutexSenderACK
81118860 g     F .text	00000068 vFailGetBlockingSemTimeoutTask
8114ea00 g     O .rwdata	00000004 __ctype_ptr__
811185c8 g     F .text	00000068 vFailSetPreParsedBuffer
8113e25c g     F .text	000000e0 Read_Sector_Data
811fa000 g       *ABS*	00000000 __alt_data_end
81100020 g     F .exceptions	00000000 alt_exception
811268a4 g     F .text	00000004 __sfp_lock_release
81105aa0 g     F .text	000000ac bFeebGetIrqControl
81118b38 g     F .text	00000068 vCouldNotSendTurnOff
81134ab0 g     F .text	00000064 OSInit
8110a2d4 g     F .text	00000078 bSetPainelLeds
81144f14 g     F .text	000000b0 alt_msgdma_construct_extended_mm_to_mm_descriptor
8114ec70 g     O .bss	00000004 OSTmrTime
81101b00 g     F .text	0000050c bDdr2MemoryReadTest
81107274 g     F .text	000002ec bRmapSetMemConfigArea
8113c7dc g     F .text	0000012c OSTaskQuery
8110c678 g     F .text	00000074 bSyncIrqEnableError
8114ebb0 g     O .bss	00000004 xMutexPus
8113a664 g     F .text	000000b0 OS_QInit
8112939c g     F .text	000000d0 __sccl
8111c8bc g     F .text	0000000c atoi
8110cac4 g     F .text	00000ed8 vFeeTask
81135e14 g     F .text	0000005c OS_StrLen
81119910 g     F .text	0000004c vFailFlushNFEEQueue
811055e8 g     F .text	00000058 bFeebCh2IrqFlagBufferEmpty
8111791c g     F .text	000000e0 vDataControllerInit
811380a8 g     F .text	0000011c OSMemNameSet
8114c01c g     O .rodata	00000101 _ctype_
8110bf6c g     F .text	0000003c uliSyncGetBt
84000000 g       *ABS*	00000000 __alt_mem_ext_flash
81118150 g     F .text	00000068 vFailSetCountSemaphorexBuffer128
8114ea9a g     O .rwdata	00000002 OSTaskProfileEn
8111995c g     F .text	00000028 vEvtChangeMebMode
81144de4 g     F .text	00000098 alt_msgdma_construct_extended_st_to_mm_descriptor
8114ebb4 g     O .bss	00000004 xTxUARTMutex
8114ec74 g     O .bss	00000004 OSTime
8114ea18 g     O .rwdata	00000004 __mbtowc
81143a58 g     F .text	0000005c altera_avalon_uart_close
8114ec78 g     O .bss	00000004 OSTmrSem
81112a50 g     F .text	00000054 vPusType251conf
81165548 g     O .bss	00001000 OSTaskIdleStk
8111c8d4 g     F .text	000000fc _fopen_r
8114eb50 g     O .bss	00000004 pdata
81147430 g     F .text	000000bc _exit
81146108 g     F .text	00000134 alt_alarm_start
81136bd0 g     F .text	00000130 OSFlagNameGet
8113cdcc g     F .text	00000064 OSTimeGet
8114eae4 g     O .bss	00000004 ESdmaChBufferId
811419b0 g     F .text	00000380 alt_up_sd_card_read
811064cc g     F .text	00000044 vRmapCh5IrqFlagClrWriteCmd
8111d0f0 g     F .text	000001c4 __smakebuf_r
8114ebb8 g     O .bss	00000001 SemCount64
81115aa0 g     F .text	000002f8 bSendUART64v2
81119878 g     F .text	0000004c vFailFlushQueueData
81105698 g     F .text	00000058 bFeebCh4IrqFlagBufferEmpty
8114eac8 g     O .rwdata	00000008 alt_msgdma_list
8111e5bc g     F .text	00000098 strlen
8110b640 g     F .text	000000b4 uc_spi_get_byte
81106510 g     F .text	00000044 vRmapCh6IrqFlagClrWriteCmd
81119550 g     F .text	00000054 vFailSendMsgAccessDMA
81146f10 g     F .text	00000028 OSTaskSwHook
81133730 g     F .text	0000015c open
81108514 g     F .text	000007cc bRmapGetRmapMemHKArea
81166548 g     O .bss	00000d00 OSEventTbl
81119f34 g     F .text	0000002c vFeeSpwRMAPChangeDefault
81131594 g     F .text	000000dc .hidden __gedf2
81162140 g     O .bss	00000020 xSenderACK
811196f4 g     F .text	00000054 vFailSendMsgSyncRMAPTRIGGER
81146c04 g     F .text	00000044 alt_putchar
81167248 g     O .bss	000011b8 OSTCBTbl
8112e710 g     F .text	00000838 __gethex
8113b0ac g     F .text	00000108 OSSemSet
81113f20 g     F .text	0000006c vTimeoutCheckerTaskv2
81119fe4 g     F .text	00000038 cFeeRMAPEchoingEnable
8114ea1c g     O .rwdata	00000004 __wctomb
81114d58 g     F .text	00000314 vVariablesInitialization
8112ccc4 g     F .text	00000018 __sprint_r
8110e280 g     F .text	000002bc vQCmdFeeRMAPinFullPattern
81105b4c g     F .text	00000088 bFeebGetIrqFlags
8114eadc g     O .bss	00000004 pxDmaM2Dev
81117b18 g     F .text	0000004c vFailCreateSemaphoreResources
8114ea38 g     O .rwdata	00000004 alt_priority_mask
81109960 g     F .text	0000003c bDisableLvdsBoard
8113a8ac g     F .text	00000248 OSSemDel
8114ec7c g     O .bss	00000004 OSFlagFreeList
8110b57c g     F .text	000000c4 v_spi_send_byte
8110b8b0 g     F .text	000000d0 bSSDisplayConfig
81146610 g     F .text	00000090 alt_ic_irq_enable
8114ea60 g     O .rwdata	00000002 OSEventNameSize
81122cd4 g     F .text	0000001c __vfprintf_internal
8114ec80 g     O .bss	00000001 OSStatRdy
8110c34c g     F .text	00000074 bSyncCtrCh2OutEnable
81168400 g     O .bss	000000ac OSTCBPrioTbl
81143af8 g     F .text	00000270 altera_avalon_uart_read
8112f418 g     F .text	00000064 _wctomb_r
81133f7c g     F .text	000000cc __env_lock
8114eaa6 g     O .rwdata	00000002 OSTaskSwHookEn
811053f8 g     F .text	00000044 vFeebCh3IrqFlagClrBufferEmpty
81131764 g     F .text	00000904 .hidden __subdf3
81162160 g     O .bss	00000260 xPreParsed
8110bfe4 g     F .text	0000003c uliSyncGetOst
8114f32c g     O .bss	00000118 RmapConfAreaL
8114ebb9 g     O .bss	00000001 SemCount128
8110637c g     F .text	00000040 vRmapCh8HandleIrq
811054c4 g     F .text	00000044 vFeebCh6IrqFlagClrBufferEmpty
81116090 g     F .text	00000290 vSendEthConf
8110461c g     F .text	000000dc bCommInitCh
8112806c g     F .text	000000b0 __lo0bits
81122db4 g     F .text	000017c4 __svfscanf_r
8114ea44 g     O .rwdata	00000008 alt_alarm_list
8112ca0c g     F .text	0000019c _ungetc_r
8114ea6e g     O .rwdata	00000002 OSFlagWidth
811063bc g     F .text	00000044 vRmapCh1IrqFlagClrWriteCmd
81102a40 g     F .text	0000004c DMA_BUSY
8112f320 g     F .text	000000c8 wcrtomb
81104bb8 g     F .text	00000148 bDpktSetPixelDelay
811156b8 g     F .text	00000068 vCCDLoadDefaultValues
811323f0 g     F .text	000000d8 close
8110c020 g     F .text	0000003c uliSyncGetGeneral
811199ac g     F .text	00000028 vEvtChangeDataControllerMode
8114ec10 g     O .bss	00000004 alt_envsem
81132920 g     F .text	00000068 alt_log_repchar
8114ec84 g     O .bss	00000004 OSIdleCtrRun
81135138 g     F .text	00000028 OSVersion
8114eab8 g     O .rwdata	00000002 OSTmrCfgWheelSize
8113c908 g     F .text	00000078 OS_TaskStkClr
8111ab5c g     F .text	0000003c siOpenFile
8110ca24 g     F .text	000000a0 vDataControlTask
8114ea92 g     O .rwdata	00000002 OSTaskCreateEn
81106634 g     F .text	00000058 bRmapCh2IrqFlagWriteCmd
81106a7c g     F .text	00000050 uliRmapCh7WriteCmdAddress
81105db0 g     F .text	00000088 bFeebStartCh
81116320 g     F .text	00000118 vSendTurnOff
81117c18 g     F .text	0000004c vFailSendPreParsedSemaphore
8113f720 g     F .text	000002a4 match_file_record_to_name_ext
81135760 g     F .text	00000070 OS_EventWaitListInit
8112e588 g     F .text	00000088 fputwc
811623c0 g     O .bss	00000010 xFeeQueueTBL0
81117bb0 g     F .text	00000068 vFailSendxSemCommInit
81147008 g     F .text	00000028 OSTaskIdleHook
81116438 g     F .text	00000118 vSendReset
811268a8 g     F .text	00000004 __sinit_lock_acquire
81127dd0 g     F .text	00000128 __multadd
811623d0 g     O .bss	00000010 SyncTBL1
81105508 g     F .text	00000044 vFeebCh7IrqFlagClrBufferEmpty
8110bc70 g     F .text	0000004c ucSyncStatusState
8113c5f0 g     F .text	000001ec OSTaskSuspend
81127da8 g     F .text	00000028 _Bfree
8110bf30 g     F .text	0000003c uliSyncGetMbt
81135e70 g     F .text	00000064 OS_TaskIdle
8114eabe g     O .rwdata	00000002 OSTmrTblSize
8113a500 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

81100020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
81100020:	deffed04 	addi	sp,sp,-76

#ifdef ALT_STACK_CHECK
        /* Ensure stack didn't just overflow. */
        bltu  sp, et, .Lstack_overflow
81100024:	de003636 	bltu	sp,et,81100100 <alt_exception+0xe0>
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
81100028:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
8110002c:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
81100030:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
81100034:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
81100038:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
8110003c:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
81100040:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
81100044:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
81100048:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
8110004c:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
81100050:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
81100054:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
81100058:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
8110005c:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
81100060:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
81100064:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
81100068:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
8110006c:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
81100070:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
81100074:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
81100078:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
8110007c:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
81100080:	10000326 	beq	r2,zero,81100090 <alt_exception+0x70>
        beq   r4, zero, .Lnot_irq
81100084:	20000226 	beq	r4,zero,81100090 <alt_exception+0x70>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
81100088:	11001040 	call	81100104 <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
8110008c:	00000706 	br	811000ac <alt_exception+0x8c>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw ea, 72(sp) /* EA is PC+4 so will skip over instruction causing exception */
81100090:	df401215 	stw	ea,72(sp)
.Lunknown_16bit:
        addi.n r4, r4, 2 /* Need PC+2 to skip over instruction causing exception */
        stw r4, 72(sp)

#else /* CDX is not Enabled and all instructions are 32bits */
        ldw r2, -4(ea) /* Instruction value that caused exception */
81100094:	e8bfff17 	ldw	r2,-4(ea)
         * debugger is present) or go into an infinite loop since the
         * handling behavior is undefined; in that case we will not return here.
         */

        /* Load exception-causing address as first argument (r4) */
        addi   r4, ea, -4
81100098:	e93fff04 	addi	r4,ea,-4

        /* Call the instruction-exception entry */
        call   alt_instruction_exception_entry
8110009c:	11001e00 	call	811001e0 <alt_instruction_exception_entry>
         * instruction
         *
         * Return code was 0: Skip. The instruction after the exception is
         * already stored in 72(sp).
         */
        bne   r2, r0, .Lexception_exit
811000a0:	1000021e 	bne	r2,zero,811000ac <alt_exception+0x8c>

        /*
         * Otherwise, modify 72(sp) to re-issue the instruction that caused the
         * exception.
         */
        addi  r15, ea, -4  /* instruction that caused exception */
811000a4:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
811000a8:	dbc01215 	stw	r15,72(sp)
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
811000ac:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
811000b0:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
811000b4:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
811000b8:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
811000bc:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
811000c0:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
811000c4:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
811000c8:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
811000cc:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
811000d0:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
811000d4:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
811000d8:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
811000dc:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
811000e0:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
811000e4:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
811000e8:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
811000ec:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
811000f0:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
811000f4:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
811000f8:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
811000fc:	ef80083a 	eret

#ifdef ALT_STACK_CHECK
.Lstack_overflow:
        break 3
81100100:	003da0fa 	break	3

81100104 <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
81100104:	defff904 	addi	sp,sp,-28
81100108:	de00012e 	bgeu	sp,et,81100110 <alt_irq_handler+0xc>
8110010c:	003b68fa 	trap	3
81100110:	dfc00615 	stw	ra,24(sp)
81100114:	df000515 	stw	fp,20(sp)
81100118:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
8110011c:	1134b140 	call	81134b14 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
81100120:	0005313a 	rdctl	r2,ipending
81100124:	e0bffe15 	stw	r2,-8(fp)

  return active;
81100128:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
8110012c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
81100130:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
81100134:	00800044 	movi	r2,1
81100138:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
8110013c:	e0fffb17 	ldw	r3,-20(fp)
81100140:	e0bffc17 	ldw	r2,-16(fp)
81100144:	1884703a 	and	r2,r3,r2
81100148:	10001426 	beq	r2,zero,8110019c <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
8110014c:	00a045f4 	movhi	r2,33047
81100150:	10a28504 	addi	r2,r2,-30188
81100154:	e0fffd17 	ldw	r3,-12(fp)
81100158:	180690fa 	slli	r3,r3,3
8110015c:	10c5883a 	add	r2,r2,r3
81100160:	10c00017 	ldw	r3,0(r2)
81100164:	00a045f4 	movhi	r2,33047
81100168:	10a28504 	addi	r2,r2,-30188
8110016c:	e13ffd17 	ldw	r4,-12(fp)
81100170:	200890fa 	slli	r4,r4,3
81100174:	1105883a 	add	r2,r2,r4
81100178:	10800104 	addi	r2,r2,4
8110017c:	10800017 	ldw	r2,0(r2)
81100180:	1009883a 	mov	r4,r2
81100184:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
81100188:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
8110018c:	0005313a 	rdctl	r2,ipending
81100190:	e0bfff15 	stw	r2,-4(fp)

  return active;
81100194:	e0bfff17 	ldw	r2,-4(fp)
81100198:	00000706 	br	811001b8 <alt_irq_handler+0xb4>
      }
      mask <<= 1;
8110019c:	e0bffc17 	ldw	r2,-16(fp)
811001a0:	1085883a 	add	r2,r2,r2
811001a4:	e0bffc15 	stw	r2,-16(fp)
      i++;
811001a8:	e0bffd17 	ldw	r2,-12(fp)
811001ac:	10800044 	addi	r2,r2,1
811001b0:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
811001b4:	003fe106 	br	8110013c <__reset+0xfb0e013c>

    active = alt_irq_pending ();
811001b8:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
811001bc:	e0bffb17 	ldw	r2,-20(fp)
811001c0:	103fdb1e 	bne	r2,zero,81100130 <__reset+0xfb0e0130>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
811001c4:	1134b680 	call	81134b68 <OSIntExit>
}
811001c8:	0001883a 	nop
811001cc:	e037883a 	mov	sp,fp
811001d0:	dfc00117 	ldw	ra,4(sp)
811001d4:	df000017 	ldw	fp,0(sp)
811001d8:	dec00204 	addi	sp,sp,8
811001dc:	f800283a 	ret

811001e0 <alt_instruction_exception_entry>:
 * that handler if it has been registered. Absent a handler, it will
 * break break or hang as discussed below.
 */
int 
alt_instruction_exception_entry (alt_u32 exception_pc)
{
811001e0:	defffb04 	addi	sp,sp,-20
811001e4:	de00012e 	bgeu	sp,et,811001ec <alt_instruction_exception_entry+0xc>
811001e8:	003b68fa 	trap	3
811001ec:	dfc00415 	stw	ra,16(sp)
811001f0:	df000315 	stw	fp,12(sp)
811001f4:	df000304 	addi	fp,sp,12
811001f8:	e13fff15 	stw	r4,-4(fp)
 * NIOS2_EXCEPTION_CAUSE_NOT_PRESENT. Your handling routine should
 * check the validity of the cause argument before proceeding.
 */
#ifdef NIOS2_HAS_EXTRA_EXCEPTION_INFO
  /* Get exception cause & "badaddr" */
  NIOS2_READ_EXCEPTION(cause);
811001fc:	000531fa 	rdctl	r2,exception
81100200:	e0bffd15 	stw	r2,-12(fp)
  cause = ( (cause & NIOS2_EXCEPTION_REG_CAUSE_MASK) >>
81100204:	e0bffd17 	ldw	r2,-12(fp)
81100208:	10801f0c 	andi	r2,r2,124
8110020c:	1004d0ba 	srli	r2,r2,2
81100210:	e0bffd15 	stw	r2,-12(fp)
              NIOS2_EXCEPTION_REG_CAUSE_OFST );

  NIOS2_READ_BADADDR(badaddr);
81100214:	0005333a 	rdctl	r2,badaddr
81100218:	e0bffe15 	stw	r2,-8(fp)
#else
  cause = NIOS2_EXCEPTION_CAUSE_NOT_PRESENT;
  badaddr = 0;
#endif /* NIOS2_HAS_EXTRA_EXCEPTION_INFO */

  if(alt_instruction_exception_handler) {
8110021c:	d0a0b317 	ldw	r2,-32052(gp)
81100220:	10000726 	beq	r2,zero,81100240 <alt_instruction_exception_entry+0x60>
     * Call handler. Its return value indicates whether the exception-causing
     * instruction should be re-issued. The code that called us,
     * alt_eceptions_entry.S, will look at this value and adjust the ea
     * register as necessary
     */
    return alt_instruction_exception_handler(cause, exception_pc, badaddr);
81100224:	d0a0b317 	ldw	r2,-32052(gp)
81100228:	e0fffd17 	ldw	r3,-12(fp)
8110022c:	e1bffe17 	ldw	r6,-8(fp)
81100230:	e17fff17 	ldw	r5,-4(fp)
81100234:	1809883a 	mov	r4,r3
81100238:	103ee83a 	callr	r2
8110023c:	00000206 	br	81100248 <alt_instruction_exception_entry+0x68>
   *    (a peripheral which negates its interrupt output before its
   *    interrupt handler has been executed will cause spurious interrupts)
   */
  else {
#ifdef NIOS2_HAS_DEBUG_STUB
    NIOS2_BREAK();
81100240:	003da03a 	break	0
      ;
#endif /* NIOS2_HAS_DEBUG_STUB */
  }

  /* We should not get here. Remove compiler warning. */
  return NIOS2_EXCEPTION_RETURN_REISSUE_INST;
81100244:	0005883a 	mov	r2,zero
}
81100248:	e037883a 	mov	sp,fp
8110024c:	dfc00117 	ldw	ra,4(sp)
81100250:	df000017 	ldw	fp,0(sp)
81100254:	dec00204 	addi	sp,sp,8
81100258:	f800283a 	ret

Disassembly of section .text:

8110025c <_start>:
    .int 2, 1, 0b, 1b
    .popsection
#endif /* Initialize Data Cache */

    /* Log that caches have been initialized. */
    ALT_LOG_PUTS(alt_log_msg_cache)
8110025c:	01204574 	movhi	r4,33045
81100260:	213a8f04 	addi	r4,r4,-5572
81100264:	21400037 	ldwio	r5,0(r4)
81100268:	01400326 	beq	zero,r5,81100278 <_start+0x1c>
8110026c:	01204574 	movhi	r4,33045
81100270:	2135e604 	addi	r4,r4,-10344
81100274:	11328980 	call	81132898 <tx_log_str>

    /* Log that the stack pointer is about to be setup. */
    ALT_LOG_PUTS(alt_log_msg_stackpointer)
81100278:	01204574 	movhi	r4,33045
8110027c:	213a8f04 	addi	r4,r4,-5572
81100280:	21400037 	ldwio	r5,0(r4)
81100284:	01400326 	beq	zero,r5,81100294 <_start+0x38>
81100288:	01204574 	movhi	r4,33045
8110028c:	2135d904 	addi	r4,r4,-10396
81100290:	11328980 	call	81132898 <tx_log_str>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
81100294:	06e047f4 	movhi	sp,33055
    ori sp, sp, %lo(__alt_stack_pointer)
81100298:	dee80014 	ori	sp,sp,40960
    movhi gp, %hi(_gp)
8110029c:	06a04574 	movhi	gp,33045
    ori gp, gp, %lo(_gp)
811002a0:	d69a7d14 	ori	gp,gp,27124
 * by the linker script. They mark the begining and the end of the bss
 * region. The linker script guarantees that these values are word aligned.
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)
811002a4:	01204574 	movhi	r4,33045
811002a8:	213a8f04 	addi	r4,r4,-5572
811002ac:	21400037 	ldwio	r5,0(r4)
811002b0:	01400326 	beq	zero,r5,811002c0 <_start+0x64>
811002b4:	01204574 	movhi	r4,33045
811002b8:	2135ca04 	addi	r4,r4,-10456
811002bc:	11328980 	call	81132898 <tx_log_str>

    movhi r2, %hi(__bss_start)
811002c0:	00a04534 	movhi	r2,33044
    ori r2, r2, %lo(__bss_start)
811002c4:	10bab414 	ori	r2,r2,60112

    movhi r3, %hi(__bss_end)
811002c8:	00e045b4 	movhi	r3,33046
    ori r3, r3, %lo(__bss_end)
811002cc:	18e2c514 	ori	r3,r3,35604

    beq r2, r3, 1f
811002d0:	10c00326 	beq	r2,r3,811002e0 <_start+0x84>

0:
    stw zero, (r2)
811002d4:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
811002d8:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
811002dc:	10fffd36 	bltu	r2,r3,811002d4 <__reset+0xfb0e02d4>
    /*
     * Set up the stack limit (if required).  The linker has set up the
     * copy of the variable which is in memory.
     */

    ldw   et, %gprel(alt_stack_limit_value)(gp)
811002e0:	d6200017 	ldw	et,-32768(gp)
#endif

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)
811002e4:	01204574 	movhi	r4,33045
811002e8:	213a8f04 	addi	r4,r4,-5572
811002ec:	21400037 	ldwio	r5,0(r4)
811002f0:	01400326 	beq	zero,r5,81100300 <_start+0xa4>
811002f4:	01204574 	movhi	r4,33045
811002f8:	2135d104 	addi	r4,r4,-10428
811002fc:	11328980 	call	81132898 <tx_log_str>

    /* Call the C entry point. It should never return. */
    call alt_main
81100300:	11334c40 	call	811334c4 <alt_main>

81100304 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
81100304:	003fff06 	br	81100304 <__reset+0xfb0e0304>

81100308 <bDdr2EepromTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromTest(alt_u8 ucMemoryId) {
81100308:	defff604 	addi	sp,sp,-40
8110030c:	de00012e 	bgeu	sp,et,81100314 <bDdr2EepromTest+0xc>
81100310:	003b68fa 	trap	3
81100314:	dfc00915 	stw	ra,36(sp)
81100318:	df000815 	stw	fp,32(sp)
8110031c:	df000804 	addi	fp,sp,32
81100320:	2005883a 	mov	r2,r4
81100324:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Test =====\n");
81100328:	00e04574 	movhi	r3,33045
8110032c:	18fb8b04 	addi	r3,r3,-4564
81100330:	00a04534 	movhi	r2,33044
81100334:	109d3b04 	addi	r2,r2,29932
81100338:	1009883a 	mov	r4,r2
8110033c:	00800884 	movi	r2,34
81100340:	100d883a 	mov	r6,r2
81100344:	200b883a 	mov	r5,r4
81100348:	1809883a 	mov	r4,r3
8110034c:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81100350:	d0a05e17 	ldw	r2,-32392(gp)
81100354:	01604574 	movhi	r5,33045
81100358:	297b8b04 	addi	r5,r5,-4564
8110035c:	1009883a 	mov	r4,r2
81100360:	111ca180 	call	8111ca18 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100364:	00bfe804 	movi	r2,-96
81100368:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110036c:	00800044 	movi	r2,1
81100370:	e0bff915 	stw	r2,-28(fp)
	switch (ucMemoryId) {
81100374:	e0bfff03 	ldbu	r2,-4(fp)
81100378:	10000326 	beq	r2,zero,81100388 <bDdr2EepromTest+0x80>
8110037c:	10800060 	cmpeqi	r2,r2,1
81100380:	1000081e 	bne	r2,zero,811003a4 <bDdr2EepromTest+0x9c>
81100384:	00000e06 	br	811003c0 <bDdr2EepromTest+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100388:	00a00034 	movhi	r2,32768
8110038c:	10827c04 	addi	r2,r2,2544
81100390:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
81100394:	00a00034 	movhi	r2,32768
81100398:	10828004 	addi	r2,r2,2560
8110039c:	e0bffb15 	stw	r2,-20(fp)
		break;
811003a0:	00001906 	br	81100408 <bDdr2EepromTest+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811003a4:	00a00034 	movhi	r2,32768
811003a8:	10825804 	addi	r2,r2,2400
811003ac:	e0bffa15 	stw	r2,-24(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811003b0:	00a00034 	movhi	r2,32768
811003b4:	10825c04 	addi	r2,r2,2416
811003b8:	e0bffb15 	stw	r2,-20(fp)
		break;
811003bc:	00001206 	br	81100408 <bDdr2EepromTest+0x100>
	default:
		bSuccess = FALSE;
811003c0:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811003c4:	00e04574 	movhi	r3,33045
811003c8:	18fb8b04 	addi	r3,r3,-4564
811003cc:	00a04534 	movhi	r2,33044
811003d0:	109d4404 	addi	r2,r2,29968
811003d4:	1009883a 	mov	r4,r2
811003d8:	00800bc4 	movi	r2,47
811003dc:	100d883a 	mov	r6,r2
811003e0:	200b883a 	mov	r5,r4
811003e4:	1809883a 	mov	r4,r3
811003e8:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
811003ec:	d0a05e17 	ldw	r2,-32392(gp)
811003f0:	01604574 	movhi	r5,33045
811003f4:	297b8b04 	addi	r5,r5,-4564
811003f8:	1009883a 	mov	r4,r2
811003fc:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
		return bSuccess;
81100400:	e0bff917 	ldw	r2,-28(fp)
81100404:	0000ff06 	br	81100804 <bDdr2EepromTest+0x4fc>
	}

	alt_u8 ucControlAddr, ucValue;
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
81100408:	00e04574 	movhi	r3,33045
8110040c:	18fb8b04 	addi	r3,r3,-4564
81100410:	00a04534 	movhi	r2,33044
81100414:	109d5004 	addi	r2,r2,30016
81100418:	1009883a 	mov	r4,r2
8110041c:	008005c4 	movi	r2,23
81100420:	100d883a 	mov	r6,r2
81100424:	200b883a 	mov	r5,r4
81100428:	1809883a 	mov	r4,r3
8110042c:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81100430:	d0a05e17 	ldw	r2,-32392(gp)
81100434:	01604574 	movhi	r5,33045
81100438:	297b8b04 	addi	r5,r5,-4564
8110043c:	1009883a 	mov	r4,r2
81100440:	111ca180 	call	8111ca18 <fprintf>
#endif
	usleep(20 * 1000);
81100444:	01138804 	movi	r4,20000
81100448:	1133cf00 	call	81133cf0 <usleep>
	for (iI = 0; iI < 256 && bSuccess; iI++) {
8110044c:	e03ffc15 	stw	zero,-16(fp)
81100450:	00003306 	br	81100520 <bDdr2EepromTest+0x218>
		ucControlAddr = iI;
81100454:	e0bffc17 	ldw	r2,-16(fp)
81100458:	e0bffd45 	stb	r2,-11(fp)
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110045c:	e0bffd03 	ldbu	r2,-12(fp)
81100460:	10c03fcc 	andi	r3,r2,255
81100464:	18c0201c 	xori	r3,r3,128
81100468:	18ffe004 	addi	r3,r3,-128
8110046c:	e13ffd43 	ldbu	r4,-11(fp)
81100470:	e0bffe04 	addi	r2,fp,-8
81100474:	d8800015 	stw	r2,0(sp)
81100478:	200f883a 	mov	r7,r4
8110047c:	180d883a 	mov	r6,r3
81100480:	e17ffb17 	ldw	r5,-20(fp)
81100484:	e13ffa17 	ldw	r4,-24(fp)
81100488:	1109c400 	call	81109c40 <I2C_Read>
8110048c:	e0bff915 	stw	r2,-28(fp)
				ucControlAddr, &ucValue);
		if (bSuccess) {
81100490:	e0bff917 	ldw	r2,-28(fp)
81100494:	10001026 	beq	r2,zero,811004d8 <bDdr2EepromTest+0x1d0>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "EEPROM[%03d]=%02Xh\n", ucControlAddr,
81100498:	e0bffd43 	ldbu	r2,-11(fp)
8110049c:	e0fffe03 	ldbu	r3,-8(fp)
811004a0:	18c03fcc 	andi	r3,r3,255
811004a4:	180f883a 	mov	r7,r3
811004a8:	100d883a 	mov	r6,r2
811004ac:	01604534 	movhi	r5,33044
811004b0:	295d5604 	addi	r5,r5,30040
811004b4:	01204574 	movhi	r4,33045
811004b8:	213b8b04 	addi	r4,r4,-4564
811004bc:	111e3a80 	call	8111e3a8 <sprintf>
					ucValue);
			debug(fp, cDebugBuffer);
811004c0:	d0a05e17 	ldw	r2,-32392(gp)
811004c4:	01604574 	movhi	r5,33045
811004c8:	297b8b04 	addi	r5,r5,-4564
811004cc:	1009883a 	mov	r4,r2
811004d0:	111ca180 	call	8111ca18 <fprintf>
811004d4:	00000f06 	br	81100514 <bDdr2EepromTest+0x20c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
811004d8:	00e04574 	movhi	r3,33045
811004dc:	18fb8b04 	addi	r3,r3,-4564
811004e0:	00a04534 	movhi	r2,33044
811004e4:	109d5b04 	addi	r2,r2,30060
811004e8:	1009883a 	mov	r4,r2
811004ec:	008005c4 	movi	r2,23
811004f0:	100d883a 	mov	r6,r2
811004f4:	200b883a 	mov	r5,r4
811004f8:	1809883a 	mov	r4,r3
811004fc:	111dac80 	call	8111dac8 <memcpy>
			debug(fp, cDebugBuffer);
81100500:	d0a05e17 	ldw	r2,-32392(gp)
81100504:	01604574 	movhi	r5,33045
81100508:	297b8b04 	addi	r5,r5,-4564
8110050c:	1009883a 	mov	r4,r2
81100510:	111ca180 	call	8111ca18 <fprintf>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Read Test\n");
	debug(fp, cDebugBuffer);
#endif
	usleep(20 * 1000);
	for (iI = 0; iI < 256 && bSuccess; iI++) {
81100514:	e0bffc17 	ldw	r2,-16(fp)
81100518:	10800044 	addi	r2,r2,1
8110051c:	e0bffc15 	stw	r2,-16(fp)
81100520:	e0bffc17 	ldw	r2,-16(fp)
81100524:	10804008 	cmpgei	r2,r2,256
81100528:	1000021e 	bne	r2,zero,81100534 <bDdr2EepromTest+0x22c>
8110052c:	e0bff917 	ldw	r2,-28(fp)
81100530:	103fc81e 	bne	r2,zero,81100454 <__reset+0xfb0e0454>
			sprintf(cDebugBuffer, "Failed to read EEPROM\n");
			debug(fp, cDebugBuffer);
#endif
		}
	}
	if (bSuccess) {
81100534:	e0bff917 	ldw	r2,-28(fp)
81100538:	10001026 	beq	r2,zero,8110057c <bDdr2EepromTest+0x274>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Completed\n\n");
8110053c:	00e04574 	movhi	r3,33045
81100540:	18fb8b04 	addi	r3,r3,-4564
81100544:	00a04534 	movhi	r2,33044
81100548:	109d6104 	addi	r2,r2,30084
8110054c:	1009883a 	mov	r4,r2
81100550:	00800884 	movi	r2,34
81100554:	100d883a 	mov	r6,r2
81100558:	200b883a 	mov	r5,r4
8110055c:	1809883a 	mov	r4,r3
81100560:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81100564:	d0a05e17 	ldw	r2,-32392(gp)
81100568:	01604574 	movhi	r5,33045
8110056c:	297b8b04 	addi	r5,r5,-4564
81100570:	1009883a 	mov	r4,r2
81100574:	111ca180 	call	8111ca18 <fprintf>
81100578:	00000f06 	br	811005b8 <bDdr2EepromTest+0x2b0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Read Test Failed\n\n");
8110057c:	00e04574 	movhi	r3,33045
81100580:	18fb8b04 	addi	r3,r3,-4564
81100584:	00a04534 	movhi	r2,33044
81100588:	109d6a04 	addi	r2,r2,30120
8110058c:	1009883a 	mov	r4,r2
81100590:	008007c4 	movi	r2,31
81100594:	100d883a 	mov	r6,r2
81100598:	200b883a 	mov	r5,r4
8110059c:	1809883a 	mov	r4,r3
811005a0:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
811005a4:	d0a05e17 	ldw	r2,-32392(gp)
811005a8:	01604574 	movhi	r5,33045
811005ac:	297b8b04 	addi	r5,r5,-4564
811005b0:	1009883a 	mov	r4,r2
811005b4:	111ca180 	call	8111ca18 <fprintf>
#endif
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 EEPROM Write Test\n");
811005b8:	00e04574 	movhi	r3,33045
811005bc:	18fb8b04 	addi	r3,r3,-4564
811005c0:	00a04534 	movhi	r2,33044
811005c4:	109d7204 	addi	r2,r2,30152
811005c8:	1009883a 	mov	r4,r2
811005cc:	00800604 	movi	r2,24
811005d0:	100d883a 	mov	r6,r2
811005d4:	200b883a 	mov	r5,r4
811005d8:	1809883a 	mov	r4,r3
811005dc:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
811005e0:	d0a05e17 	ldw	r2,-32392(gp)
811005e4:	01604574 	movhi	r5,33045
811005e8:	297b8b04 	addi	r5,r5,-4564
811005ec:	1009883a 	mov	r4,r2
811005f0:	111ca180 	call	8111ca18 <fprintf>
#endif
	alt_u8 ucWriteData = 0x12, ucTestAddr = 128;
811005f4:	00800484 	movi	r2,18
811005f8:	e0bffd85 	stb	r2,-10(fp)
811005fc:	00bfe004 	movi	r2,-128
81100600:	e0bffdc5 	stb	r2,-9(fp)
	alt_u8 ucReadData;
	usleep(20 * 1000);
81100604:	01138804 	movi	r4,20000
81100608:	1133cf00 	call	81133cf0 <usleep>
	bSuccess = I2C_Write(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
8110060c:	e0bffd03 	ldbu	r2,-12(fp)
81100610:	10c03fcc 	andi	r3,r2,255
81100614:	18c0201c 	xori	r3,r3,128
81100618:	18ffe004 	addi	r3,r3,-128
8110061c:	e13ffdc3 	ldbu	r4,-9(fp)
81100620:	e0bffd83 	ldbu	r2,-10(fp)
81100624:	d8800015 	stw	r2,0(sp)
81100628:	200f883a 	mov	r7,r4
8110062c:	180d883a 	mov	r6,r3
81100630:	e17ffb17 	ldw	r5,-20(fp)
81100634:	e13ffa17 	ldw	r4,-24(fp)
81100638:	1109b600 	call	81109b60 <I2C_Write>
8110063c:	e0bff915 	stw	r2,-28(fp)
			ucTestAddr, ucWriteData);
	if (!bSuccess) {
81100640:	e0bff917 	ldw	r2,-28(fp)
81100644:	1000101e 	bne	r2,zero,81100688 <bDdr2EepromTest+0x380>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to write EEPROM\n");
81100648:	00e04574 	movhi	r3,33045
8110064c:	18fb8b04 	addi	r3,r3,-4564
81100650:	00a04534 	movhi	r2,33044
81100654:	109d7804 	addi	r2,r2,30176
81100658:	1009883a 	mov	r4,r2
8110065c:	00800604 	movi	r2,24
81100660:	100d883a 	mov	r6,r2
81100664:	200b883a 	mov	r5,r4
81100668:	1809883a 	mov	r4,r3
8110066c:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81100670:	d0a05e17 	ldw	r2,-32392(gp)
81100674:	01604574 	movhi	r5,33045
81100678:	297b8b04 	addi	r5,r5,-4564
8110067c:	1009883a 	mov	r4,r2
81100680:	111ca180 	call	8111ca18 <fprintf>
81100684:	00003306 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
	} else {
		bSuccess = I2C_Read(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100688:	e0bffd03 	ldbu	r2,-12(fp)
8110068c:	10c03fcc 	andi	r3,r2,255
81100690:	18c0201c 	xori	r3,r3,128
81100694:	18ffe004 	addi	r3,r3,-128
81100698:	e13ffdc3 	ldbu	r4,-9(fp)
8110069c:	e0bffe44 	addi	r2,fp,-7
811006a0:	d8800015 	stw	r2,0(sp)
811006a4:	200f883a 	mov	r7,r4
811006a8:	180d883a 	mov	r6,r3
811006ac:	e17ffb17 	ldw	r5,-20(fp)
811006b0:	e13ffa17 	ldw	r4,-24(fp)
811006b4:	1109c400 	call	81109c40 <I2C_Read>
811006b8:	e0bff915 	stw	r2,-28(fp)
				ucTestAddr, &ucReadData);
		if (!bSuccess) {
811006bc:	e0bff917 	ldw	r2,-28(fp)
811006c0:	1000101e 	bne	r2,zero,81100704 <bDdr2EepromTest+0x3fc>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "Failed to read EEPROM for verify\n");
811006c4:	00e04574 	movhi	r3,33045
811006c8:	18fb8b04 	addi	r3,r3,-4564
811006cc:	00a04534 	movhi	r2,33044
811006d0:	109d7e04 	addi	r2,r2,30200
811006d4:	1009883a 	mov	r4,r2
811006d8:	00800884 	movi	r2,34
811006dc:	100d883a 	mov	r6,r2
811006e0:	200b883a 	mov	r5,r4
811006e4:	1809883a 	mov	r4,r3
811006e8:	111dac80 	call	8111dac8 <memcpy>
			debug(fp, cDebugBuffer);
811006ec:	d0a05e17 	ldw	r2,-32392(gp)
811006f0:	01604574 	movhi	r5,33045
811006f4:	297b8b04 	addi	r5,r5,-4564
811006f8:	1009883a 	mov	r4,r2
811006fc:	111ca180 	call	8111ca18 <fprintf>
81100700:	00001406 	br	81100754 <bDdr2EepromTest+0x44c>
#endif
		} else {
			if (ucReadData != ucWriteData) {
81100704:	e0bffe43 	ldbu	r2,-7(fp)
81100708:	10c03fcc 	andi	r3,r2,255
8110070c:	e0bffd83 	ldbu	r2,-10(fp)
81100710:	18801026 	beq	r3,r2,81100754 <bDdr2EepromTest+0x44c>
				bSuccess = FALSE;
81100714:	e03ff915 	stw	zero,-28(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100718:	e0bffe43 	ldbu	r2,-7(fp)
8110071c:	10803fcc 	andi	r2,r2,255
81100720:	e0fffd83 	ldbu	r3,-10(fp)
81100724:	180f883a 	mov	r7,r3
81100728:	100d883a 	mov	r6,r2
8110072c:	01604534 	movhi	r5,33044
81100730:	295d8704 	addi	r5,r5,30236
81100734:	01204574 	movhi	r4,33045
81100738:	213b8b04 	addi	r4,r4,-4564
8110073c:	111e3a80 	call	8111e3a8 <sprintf>
						"Verify EEPROM write fail, ReadData=%02Xh, WriteData=%02Xh\n",
						ucReadData, ucWriteData);
				debug(fp, cDebugBuffer);
81100740:	d0a05e17 	ldw	r2,-32392(gp)
81100744:	01604574 	movhi	r5,33045
81100748:	297b8b04 	addi	r5,r5,-4564
8110074c:	1009883a 	mov	r4,r2
81100750:	111ca180 	call	8111ca18 <fprintf>
#endif
			}
		}
	}
	if (bSuccess) {
81100754:	e0bff917 	ldw	r2,-28(fp)
81100758:	10001026 	beq	r2,zero,8110079c <bDdr2EepromTest+0x494>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Completed\n\n");
8110075c:	00e04574 	movhi	r3,33045
81100760:	18fb8b04 	addi	r3,r3,-4564
81100764:	00a04534 	movhi	r2,33044
81100768:	109d9604 	addi	r2,r2,30296
8110076c:	1009883a 	mov	r4,r2
81100770:	008008c4 	movi	r2,35
81100774:	100d883a 	mov	r6,r2
81100778:	200b883a 	mov	r5,r4
8110077c:	1809883a 	mov	r4,r3
81100780:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81100784:	d0a05e17 	ldw	r2,-32392(gp)
81100788:	01604574 	movhi	r5,33045
8110078c:	297b8b04 	addi	r5,r5,-4564
81100790:	1009883a 	mov	r4,r2
81100794:	111ca180 	call	8111ca18 <fprintf>
81100798:	00000f06 	br	811007d8 <bDdr2EepromTest+0x4d0>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 EEPROM Write Test Failed\n\n");
8110079c:	00e04574 	movhi	r3,33045
811007a0:	18fb8b04 	addi	r3,r3,-4564
811007a4:	00a04534 	movhi	r2,33044
811007a8:	109d9f04 	addi	r2,r2,30332
811007ac:	1009883a 	mov	r4,r2
811007b0:	00800804 	movi	r2,32
811007b4:	100d883a 	mov	r6,r2
811007b8:	200b883a 	mov	r5,r4
811007bc:	1809883a 	mov	r4,r3
811007c0:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
811007c4:	d0a05e17 	ldw	r2,-32392(gp)
811007c8:	01604574 	movhi	r5,33045
811007cc:	297b8b04 	addi	r5,r5,-4564
811007d0:	1009883a 	mov	r4,r2
811007d4:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811007d8:	00a04574 	movhi	r2,33045
811007dc:	10bb8b04 	addi	r2,r2,-4564
811007e0:	00c00284 	movi	r3,10
811007e4:	10c00005 	stb	r3,0(r2)
811007e8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811007ec:	d0a05e17 	ldw	r2,-32392(gp)
811007f0:	01604574 	movhi	r5,33045
811007f4:	297b8b04 	addi	r5,r5,-4564
811007f8:	1009883a 	mov	r4,r2
811007fc:	111ca180 	call	8111ca18 <fprintf>
#endif

	return bSuccess;
81100800:	e0bff917 	ldw	r2,-28(fp)
}
81100804:	e037883a 	mov	sp,fp
81100808:	dfc00117 	ldw	ra,4(sp)
8110080c:	df000017 	ldw	fp,0(sp)
81100810:	dec00204 	addi	sp,sp,8
81100814:	f800283a 	ret

81100818 <bDdr2EepromDump>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2EepromDump(alt_u8 ucMemoryId) {
81100818:	deffb704 	addi	sp,sp,-292
8110081c:	de00012e 	bgeu	sp,et,81100824 <bDdr2EepromDump+0xc>
81100820:	003b68fa 	trap	3
81100824:	dfc04815 	stw	ra,288(sp)
81100828:	df004715 	stw	fp,284(sp)
8110082c:	df004704 	addi	fp,sp,284
81100830:	2005883a 	mov	r2,r4
81100834:	e0bfff05 	stb	r2,-4(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 EEPROM Dump =====\n");
81100838:	00e04574 	movhi	r3,33045
8110083c:	18fb8b04 	addi	r3,r3,-4564
81100840:	00a04534 	movhi	r2,33044
81100844:	109da704 	addi	r2,r2,30364
81100848:	1009883a 	mov	r4,r2
8110084c:	00800884 	movi	r2,34
81100850:	100d883a 	mov	r6,r2
81100854:	200b883a 	mov	r5,r4
81100858:	1809883a 	mov	r4,r3
8110085c:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81100860:	d0a05e17 	ldw	r2,-32392(gp)
81100864:	01604574 	movhi	r5,33045
81100868:	297b8b04 	addi	r5,r5,-4564
8110086c:	1009883a 	mov	r4,r2
81100870:	111ca180 	call	8111ca18 <fprintf>
#endif
	const alt_u8 cucDeviceAddr = DDR2_EEPROM_I2C_ADDRESS;
81100874:	00bfe804 	movi	r2,-96
81100878:	e0bfbd05 	stb	r2,-268(fp)
	bool bSuccess;
	alt_u32 uliI2cSclBase;
	alt_u32 uliI2cSdaBase;
	int iI;

	bSuccess = TRUE;
8110087c:	00800044 	movi	r2,1
81100880:	e0bfbe15 	stw	r2,-264(fp)
	switch (ucMemoryId) {
81100884:	e0bfff03 	ldbu	r2,-4(fp)
81100888:	10000326 	beq	r2,zero,81100898 <bDdr2EepromDump+0x80>
8110088c:	10800060 	cmpeqi	r2,r2,1
81100890:	1000081e 	bne	r2,zero,811008b4 <bDdr2EepromDump+0x9c>
81100894:	00000e06 	br	811008d0 <bDdr2EepromDump+0xb8>
	case DDR2_M1_ID:
		uliI2cSclBase = DDR2_M1_EEPROM_I2C_SCL_BASE;
81100898:	00a00034 	movhi	r2,32768
8110089c:	10827c04 	addi	r2,r2,2544
811008a0:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M1_EEPROM_I2C_SDA_BASE;
811008a4:	00a00034 	movhi	r2,32768
811008a8:	10828004 	addi	r2,r2,2560
811008ac:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008b0:	00001906 	br	81100918 <bDdr2EepromDump+0x100>
	case DDR2_M2_ID:
		uliI2cSclBase = DDR2_M2_EEPROM_I2C_SCL_BASE;
811008b4:	00a00034 	movhi	r2,32768
811008b8:	10825804 	addi	r2,r2,2400
811008bc:	e0bfba15 	stw	r2,-280(fp)
		uliI2cSdaBase = DDR2_M2_EEPROM_I2C_SDA_BASE;
811008c0:	00a00034 	movhi	r2,32768
811008c4:	10825c04 	addi	r2,r2,2416
811008c8:	e0bfbb15 	stw	r2,-276(fp)
		break;
811008cc:	00001206 	br	81100918 <bDdr2EepromDump+0x100>
	default:
		bSuccess = FALSE;
811008d0:	e03fbe15 	stw	zero,-264(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811008d4:	00e04574 	movhi	r3,33045
811008d8:	18fb8b04 	addi	r3,r3,-4564
811008dc:	00a04534 	movhi	r2,33044
811008e0:	109db004 	addi	r2,r2,30400
811008e4:	1009883a 	mov	r4,r2
811008e8:	00800bc4 	movi	r2,47
811008ec:	100d883a 	mov	r6,r2
811008f0:	200b883a 	mov	r5,r4
811008f4:	1809883a 	mov	r4,r3
811008f8:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Aborting Dump \n");
		debug(fp, cDebugBuffer)
811008fc:	d0a05e17 	ldw	r2,-32392(gp)
81100900:	01604574 	movhi	r5,33045
81100904:	297b8b04 	addi	r5,r5,-4564
81100908:	1009883a 	mov	r4,r2
8110090c:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
		return bSuccess;
81100910:	e0bfbe17 	ldw	r2,-264(fp)
81100914:	0002e706 	br	811014b4 <bDdr2EepromDump+0xc9c>
	}

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
81100918:	e0bfbd03 	ldbu	r2,-268(fp)
8110091c:	10c03fcc 	andi	r3,r2,255
81100920:	18c0201c 	xori	r3,r3,128
81100924:	18ffe004 	addi	r3,r3,-128
81100928:	e13fbf04 	addi	r4,fp,-260
8110092c:	00804004 	movi	r2,256
81100930:	d8800015 	stw	r2,0(sp)
81100934:	200f883a 	mov	r7,r4
81100938:	180d883a 	mov	r6,r3
8110093c:	e17fbb17 	ldw	r5,-276(fp)
81100940:	e13fba17 	ldw	r4,-280(fp)
81100944:	1109d480 	call	81109d48 <I2C_MultipleRead>
81100948:	e0bfbe15 	stw	r2,-264(fp)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
8110094c:	e0bfbe17 	ldw	r2,-264(fp)
81100950:	1002be26 	beq	r2,zero,8110144c <bDdr2EepromDump+0xc34>
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81100954:	e03fbc15 	stw	zero,-272(fp)
81100958:	0002b606 	br	81101434 <bDdr2EepromDump+0xc1c>
			if (iI == 0) {
8110095c:	e0bfbc17 	ldw	r2,-272(fp)
81100960:	1000121e 	bne	r2,zero,811009ac <bDdr2EepromDump+0x194>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
81100964:	e0ffbf04 	addi	r3,fp,-260
81100968:	e0bfbc17 	ldw	r2,-272(fp)
8110096c:	1885883a 	add	r2,r3,r2
81100970:	10800003 	ldbu	r2,0(r2)
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
			if (iI == 0) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100974:	10803fcc 	andi	r2,r2,255
81100978:	100f883a 	mov	r7,r2
8110097c:	e1bfbc17 	ldw	r6,-272(fp)
81100980:	01604534 	movhi	r5,33044
81100984:	295dbc04 	addi	r5,r5,30448
81100988:	01204574 	movhi	r4,33045
8110098c:	213b8b04 	addi	r4,r4,-4564
81100990:	111e3a80 	call	8111e3a8 <sprintf>
						"(Number of SPD Bytes Used)\n" "EEPROM[%03d]=%02Xh ",
						iI, ucSZData[iI]);
				debug(fp, cDebugBuffer);
81100994:	d0a05e17 	ldw	r2,-32392(gp)
81100998:	01604574 	movhi	r5,33045
8110099c:	297b8b04 	addi	r5,r5,-4564
811009a0:	1009883a 	mov	r4,r2
811009a4:	111ca180 	call	8111ca18 <fprintf>
811009a8:	00029f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 1) {
811009ac:	e0bfbc17 	ldw	r2,-272(fp)
811009b0:	10800058 	cmpnei	r2,r2,1
811009b4:	1000101e 	bne	r2,zero,811009f8 <bDdr2EepromDump+0x1e0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811009b8:	00e04574 	movhi	r3,33045
811009bc:	18fb8b04 	addi	r3,r3,-4564
811009c0:	00a04534 	movhi	r2,33044
811009c4:	109dc804 	addi	r2,r2,30496
811009c8:	1009883a 	mov	r4,r2
811009cc:	00800c04 	movi	r2,48
811009d0:	100d883a 	mov	r6,r2
811009d4:	200b883a 	mov	r5,r4
811009d8:	1809883a 	mov	r4,r3
811009dc:	111dac80 	call	8111dac8 <memcpy>
						"(Total Number of Bytes in SPD Device, Log2(N))\n");
				debug(fp, cDebugBuffer);
811009e0:	d0a05e17 	ldw	r2,-32392(gp)
811009e4:	01604574 	movhi	r5,33045
811009e8:	297b8b04 	addi	r5,r5,-4564
811009ec:	1009883a 	mov	r4,r2
811009f0:	111ca180 	call	8111ca18 <fprintf>
811009f4:	00028c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 2) {
811009f8:	e0bfbc17 	ldw	r2,-272(fp)
811009fc:	10800098 	cmpnei	r2,r2,2
81100a00:	1000101e 	bne	r2,zero,81100a44 <bDdr2EepromDump+0x22c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Basic Memory Type[08h:DDR2])\n");
81100a04:	00e04574 	movhi	r3,33045
81100a08:	18fb8b04 	addi	r3,r3,-4564
81100a0c:	00a04534 	movhi	r2,33044
81100a10:	109dd404 	addi	r2,r2,30544
81100a14:	1009883a 	mov	r4,r2
81100a18:	008007c4 	movi	r2,31
81100a1c:	100d883a 	mov	r6,r2
81100a20:	200b883a 	mov	r5,r4
81100a24:	1809883a 	mov	r4,r3
81100a28:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100a2c:	d0a05e17 	ldw	r2,-32392(gp)
81100a30:	01604574 	movhi	r5,33045
81100a34:	297b8b04 	addi	r5,r5,-4564
81100a38:	1009883a 	mov	r4,r2
81100a3c:	111ca180 	call	8111ca18 <fprintf>
81100a40:	00027906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 3) {
81100a44:	e0bfbc17 	ldw	r2,-272(fp)
81100a48:	108000d8 	cmpnei	r2,r2,3
81100a4c:	1000101e 	bne	r2,zero,81100a90 <bDdr2EepromDump+0x278>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a50:	00e04574 	movhi	r3,33045
81100a54:	18fb8b04 	addi	r3,r3,-4564
81100a58:	00a04534 	movhi	r2,33044
81100a5c:	109ddc04 	addi	r2,r2,30576
81100a60:	1009883a 	mov	r4,r2
81100a64:	008009c4 	movi	r2,39
81100a68:	100d883a 	mov	r6,r2
81100a6c:	200b883a 	mov	r5,r4
81100a70:	1809883a 	mov	r4,r3
81100a74:	111dac80 	call	8111dac8 <memcpy>
						"(Number of Row Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100a78:	d0a05e17 	ldw	r2,-32392(gp)
81100a7c:	01604574 	movhi	r5,33045
81100a80:	297b8b04 	addi	r5,r5,-4564
81100a84:	1009883a 	mov	r4,r2
81100a88:	111ca180 	call	8111ca18 <fprintf>
81100a8c:	00026606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 4) {
81100a90:	e0bfbc17 	ldw	r2,-272(fp)
81100a94:	10800118 	cmpnei	r2,r2,4
81100a98:	1000101e 	bne	r2,zero,81100adc <bDdr2EepromDump+0x2c4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100a9c:	00e04574 	movhi	r3,33045
81100aa0:	18fb8b04 	addi	r3,r3,-4564
81100aa4:	00a04534 	movhi	r2,33044
81100aa8:	109de604 	addi	r2,r2,30616
81100aac:	1009883a 	mov	r4,r2
81100ab0:	00800a84 	movi	r2,42
81100ab4:	100d883a 	mov	r6,r2
81100ab8:	200b883a 	mov	r5,r4
81100abc:	1809883a 	mov	r4,r3
81100ac0:	111dac80 	call	8111dac8 <memcpy>
						"(Number of Column Addresses on Assembly)\n");
				debug(fp, cDebugBuffer);
81100ac4:	d0a05e17 	ldw	r2,-32392(gp)
81100ac8:	01604574 	movhi	r5,33045
81100acc:	297b8b04 	addi	r5,r5,-4564
81100ad0:	1009883a 	mov	r4,r2
81100ad4:	111ca180 	call	8111ca18 <fprintf>
81100ad8:	00025306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 5) {
81100adc:	e0bfbc17 	ldw	r2,-272(fp)
81100ae0:	10800158 	cmpnei	r2,r2,5
81100ae4:	1000101e 	bne	r2,zero,81100b28 <bDdr2EepromDump+0x310>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ae8:	00e04574 	movhi	r3,33045
81100aec:	18fb8b04 	addi	r3,r3,-4564
81100af0:	00a04534 	movhi	r2,33044
81100af4:	109df104 	addi	r2,r2,30660
81100af8:	1009883a 	mov	r4,r2
81100afc:	00800c04 	movi	r2,48
81100b00:	100d883a 	mov	r6,r2
81100b04:	200b883a 	mov	r5,r4
81100b08:	1809883a 	mov	r4,r3
81100b0c:	111dac80 	call	8111dac8 <memcpy>
						"(DIMM Height and Module Rank Number[b2b1b0+1])\n");
				debug(fp, cDebugBuffer);
81100b10:	d0a05e17 	ldw	r2,-32392(gp)
81100b14:	01604574 	movhi	r5,33045
81100b18:	297b8b04 	addi	r5,r5,-4564
81100b1c:	1009883a 	mov	r4,r2
81100b20:	111ca180 	call	8111ca18 <fprintf>
81100b24:	00024006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 6) {
81100b28:	e0bfbc17 	ldw	r2,-272(fp)
81100b2c:	10800198 	cmpnei	r2,r2,6
81100b30:	1000101e 	bne	r2,zero,81100b74 <bDdr2EepromDump+0x35c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width)\n");
81100b34:	00e04574 	movhi	r3,33045
81100b38:	18fb8b04 	addi	r3,r3,-4564
81100b3c:	00a04534 	movhi	r2,33044
81100b40:	109dfd04 	addi	r2,r2,30708
81100b44:	1009883a 	mov	r4,r2
81100b48:	00800544 	movi	r2,21
81100b4c:	100d883a 	mov	r6,r2
81100b50:	200b883a 	mov	r5,r4
81100b54:	1809883a 	mov	r4,r3
81100b58:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100b5c:	d0a05e17 	ldw	r2,-32392(gp)
81100b60:	01604574 	movhi	r5,33045
81100b64:	297b8b04 	addi	r5,r5,-4564
81100b68:	1009883a 	mov	r4,r2
81100b6c:	111ca180 	call	8111ca18 <fprintf>
81100b70:	00022d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 7) {
81100b74:	e0bfbc17 	ldw	r2,-272(fp)
81100b78:	108001d8 	cmpnei	r2,r2,7
81100b7c:	1000101e 	bne	r2,zero,81100bc0 <bDdr2EepromDump+0x3a8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Module Data Width, Continued)\n");
81100b80:	00e04574 	movhi	r3,33045
81100b84:	18fb8b04 	addi	r3,r3,-4564
81100b88:	00a04534 	movhi	r2,33044
81100b8c:	109e0304 	addi	r2,r2,30732
81100b90:	1009883a 	mov	r4,r2
81100b94:	00800804 	movi	r2,32
81100b98:	100d883a 	mov	r6,r2
81100b9c:	200b883a 	mov	r5,r4
81100ba0:	1809883a 	mov	r4,r3
81100ba4:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100ba8:	d0a05e17 	ldw	r2,-32392(gp)
81100bac:	01604574 	movhi	r5,33045
81100bb0:	297b8b04 	addi	r5,r5,-4564
81100bb4:	1009883a 	mov	r4,r2
81100bb8:	111ca180 	call	8111ca18 <fprintf>
81100bbc:	00021a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 16) {
81100bc0:	e0bfbc17 	ldw	r2,-272(fp)
81100bc4:	10800418 	cmpnei	r2,r2,16
81100bc8:	1000101e 	bne	r2,zero,81100c0c <bDdr2EepromDump+0x3f4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100bcc:	00e04574 	movhi	r3,33045
81100bd0:	18fb8b04 	addi	r3,r3,-4564
81100bd4:	00a04534 	movhi	r2,33044
81100bd8:	109e0b04 	addi	r2,r2,30764
81100bdc:	1009883a 	mov	r4,r2
81100be0:	00800d04 	movi	r2,52
81100be4:	100d883a 	mov	r6,r2
81100be8:	200b883a 	mov	r5,r4
81100bec:	1809883a 	mov	r4,r3
81100bf0:	111dac80 	call	8111dac8 <memcpy>
						"(Burst Lengths Supported[bitmap: x x x x 8 4 x x])\n");
				debug(fp, cDebugBuffer);
81100bf4:	d0a05e17 	ldw	r2,-32392(gp)
81100bf8:	01604574 	movhi	r5,33045
81100bfc:	297b8b04 	addi	r5,r5,-4564
81100c00:	1009883a 	mov	r4,r2
81100c04:	111ca180 	call	8111ca18 <fprintf>
81100c08:	00020706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 13) {
81100c0c:	e0bfbc17 	ldw	r2,-272(fp)
81100c10:	10800358 	cmpnei	r2,r2,13
81100c14:	1000101e 	bne	r2,zero,81100c58 <bDdr2EepromDump+0x440>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Primary SDRAM width)\n");
81100c18:	00e04574 	movhi	r3,33045
81100c1c:	18fb8b04 	addi	r3,r3,-4564
81100c20:	00a04534 	movhi	r2,33044
81100c24:	109e1804 	addi	r2,r2,30816
81100c28:	1009883a 	mov	r4,r2
81100c2c:	008005c4 	movi	r2,23
81100c30:	100d883a 	mov	r6,r2
81100c34:	200b883a 	mov	r5,r4
81100c38:	1809883a 	mov	r4,r3
81100c3c:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100c40:	d0a05e17 	ldw	r2,-32392(gp)
81100c44:	01604574 	movhi	r5,33045
81100c48:	297b8b04 	addi	r5,r5,-4564
81100c4c:	1009883a 	mov	r4,r2
81100c50:	111ca180 	call	8111ca18 <fprintf>
81100c54:	0001f406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 14) {
81100c58:	e0bfbc17 	ldw	r2,-272(fp)
81100c5c:	10800398 	cmpnei	r2,r2,14
81100c60:	1000101e 	bne	r2,zero,81100ca4 <bDdr2EepromDump+0x48c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(ECC SDRAM width)\n");
81100c64:	00e04574 	movhi	r3,33045
81100c68:	18fb8b04 	addi	r3,r3,-4564
81100c6c:	00a04534 	movhi	r2,33044
81100c70:	109e1e04 	addi	r2,r2,30840
81100c74:	1009883a 	mov	r4,r2
81100c78:	008004c4 	movi	r2,19
81100c7c:	100d883a 	mov	r6,r2
81100c80:	200b883a 	mov	r5,r4
81100c84:	1809883a 	mov	r4,r3
81100c88:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100c8c:	d0a05e17 	ldw	r2,-32392(gp)
81100c90:	01604574 	movhi	r5,33045
81100c94:	297b8b04 	addi	r5,r5,-4564
81100c98:	1009883a 	mov	r4,r2
81100c9c:	111ca180 	call	8111ca18 <fprintf>
81100ca0:	0001e106 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 17) {
81100ca4:	e0bfbc17 	ldw	r2,-272(fp)
81100ca8:	10800458 	cmpnei	r2,r2,17
81100cac:	1000101e 	bne	r2,zero,81100cf0 <bDdr2EepromDump+0x4d8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Banks per SDRAM device)\n");
81100cb0:	00e04574 	movhi	r3,33045
81100cb4:	18fb8b04 	addi	r3,r3,-4564
81100cb8:	00a04534 	movhi	r2,33044
81100cbc:	109e2304 	addi	r2,r2,30860
81100cc0:	1009883a 	mov	r4,r2
81100cc4:	00800684 	movi	r2,26
81100cc8:	100d883a 	mov	r6,r2
81100ccc:	200b883a 	mov	r5,r4
81100cd0:	1809883a 	mov	r4,r3
81100cd4:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100cd8:	d0a05e17 	ldw	r2,-32392(gp)
81100cdc:	01604574 	movhi	r5,33045
81100ce0:	297b8b04 	addi	r5,r5,-4564
81100ce4:	1009883a 	mov	r4,r2
81100ce8:	111ca180 	call	8111ca18 <fprintf>
81100cec:	0001ce06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 18) {
81100cf0:	e0bfbc17 	ldw	r2,-272(fp)
81100cf4:	10800498 	cmpnei	r2,r2,18
81100cf8:	1000101e 	bne	r2,zero,81100d3c <bDdr2EepromDump+0x524>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100cfc:	00e04574 	movhi	r3,33045
81100d00:	18fb8b04 	addi	r3,r3,-4564
81100d04:	00a04534 	movhi	r2,33044
81100d08:	109e2a04 	addi	r2,r2,30888
81100d0c:	1009883a 	mov	r4,r2
81100d10:	00800d44 	movi	r2,53
81100d14:	100d883a 	mov	r6,r2
81100d18:	200b883a 	mov	r5,r4
81100d1c:	1809883a 	mov	r4,r3
81100d20:	111dac80 	call	8111dac8 <memcpy>
						"(CAS lantencies supported[bitmap: x x 5 4 3 2 x x])\n");
				debug(fp, cDebugBuffer);
81100d24:	d0a05e17 	ldw	r2,-32392(gp)
81100d28:	01604574 	movhi	r5,33045
81100d2c:	297b8b04 	addi	r5,r5,-4564
81100d30:	1009883a 	mov	r4,r2
81100d34:	111ca180 	call	8111ca18 <fprintf>
81100d38:	0001bb06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 20) {
81100d3c:	e0bfbc17 	ldw	r2,-272(fp)
81100d40:	10800518 	cmpnei	r2,r2,20
81100d44:	1000101e 	bne	r2,zero,81100d88 <bDdr2EepromDump+0x570>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100d48:	00e04574 	movhi	r3,33045
81100d4c:	18fb8b04 	addi	r3,r3,-4564
81100d50:	00a04534 	movhi	r2,33044
81100d54:	109e3804 	addi	r2,r2,30944
81100d58:	1009883a 	mov	r4,r2
81100d5c:	00801204 	movi	r2,72
81100d60:	100d883a 	mov	r6,r2
81100d64:	200b883a 	mov	r5,r4
81100d68:	1809883a 	mov	r4,r3
81100d6c:	111dac80 	call	8111dac8 <memcpy>
						"(DIMM Type: x x Mini-UDIMM Mini-RDIMM Micro-DIMM SO-DIMM UDIMMM RDIMM)\n");
				debug(fp, cDebugBuffer);
81100d70:	d0a05e17 	ldw	r2,-32392(gp)
81100d74:	01604574 	movhi	r5,33045
81100d78:	297b8b04 	addi	r5,r5,-4564
81100d7c:	1009883a 	mov	r4,r2
81100d80:	111ca180 	call	8111ca18 <fprintf>
81100d84:	0001a806 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 22) {
81100d88:	e0bfbc17 	ldw	r2,-272(fp)
81100d8c:	10800598 	cmpnei	r2,r2,22
81100d90:	1000101e 	bne	r2,zero,81100dd4 <bDdr2EepromDump+0x5bc>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Memory Chip feature bitmap)\n");
81100d94:	00e04574 	movhi	r3,33045
81100d98:	18fb8b04 	addi	r3,r3,-4564
81100d9c:	00a04534 	movhi	r2,33044
81100da0:	109e4a04 	addi	r2,r2,31016
81100da4:	1009883a 	mov	r4,r2
81100da8:	00800784 	movi	r2,30
81100dac:	100d883a 	mov	r6,r2
81100db0:	200b883a 	mov	r5,r4
81100db4:	1809883a 	mov	r4,r3
81100db8:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81100dbc:	d0a05e17 	ldw	r2,-32392(gp)
81100dc0:	01604574 	movhi	r5,33045
81100dc4:	297b8b04 	addi	r5,r5,-4564
81100dc8:	1009883a 	mov	r4,r2
81100dcc:	111ca180 	call	8111ca18 <fprintf>
81100dd0:	00019506 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 27) {
81100dd4:	e0bfbc17 	ldw	r2,-272(fp)
81100dd8:	108006d8 	cmpnei	r2,r2,27
81100ddc:	1000101e 	bne	r2,zero,81100e20 <bDdr2EepromDump+0x608>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100de0:	00e04574 	movhi	r3,33045
81100de4:	18fb8b04 	addi	r3,r3,-4564
81100de8:	00a04534 	movhi	r2,33044
81100dec:	109e5204 	addi	r2,r2,31048
81100df0:	1009883a 	mov	r4,r2
81100df4:	00800a04 	movi	r2,40
81100df8:	100d883a 	mov	r6,r2
81100dfc:	200b883a 	mov	r5,r4
81100e00:	1809883a 	mov	r4,r3
81100e04:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun row precharge time[tRP;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e08:	d0a05e17 	ldw	r2,-32392(gp)
81100e0c:	01604574 	movhi	r5,33045
81100e10:	297b8b04 	addi	r5,r5,-4564
81100e14:	1009883a 	mov	r4,r2
81100e18:	111ca180 	call	8111ca18 <fprintf>
81100e1c:	00018206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 28) {
81100e20:	e0bfbc17 	ldw	r2,-272(fp)
81100e24:	10800718 	cmpnei	r2,r2,28
81100e28:	1000101e 	bne	r2,zero,81100e6c <bDdr2EepromDump+0x654>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e2c:	00e04574 	movhi	r3,33045
81100e30:	18fb8b04 	addi	r3,r3,-4564
81100e34:	00a04534 	movhi	r2,33044
81100e38:	109e5c04 	addi	r2,r2,31088
81100e3c:	1009883a 	mov	r4,r2
81100e40:	00800cc4 	movi	r2,51
81100e44:	100d883a 	mov	r6,r2
81100e48:	200b883a 	mov	r5,r4
81100e4c:	1809883a 	mov	r4,r3
81100e50:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun row active-row activce delay[tRRD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100e54:	d0a05e17 	ldw	r2,-32392(gp)
81100e58:	01604574 	movhi	r5,33045
81100e5c:	297b8b04 	addi	r5,r5,-4564
81100e60:	1009883a 	mov	r4,r2
81100e64:	111ca180 	call	8111ca18 <fprintf>
81100e68:	00016f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 29) {
81100e6c:	e0bfbc17 	ldw	r2,-272(fp)
81100e70:	10800758 	cmpnei	r2,r2,29
81100e74:	1000101e 	bne	r2,zero,81100eb8 <bDdr2EepromDump+0x6a0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100e78:	00e04574 	movhi	r3,33045
81100e7c:	18fb8b04 	addi	r3,r3,-4564
81100e80:	00a04534 	movhi	r2,33044
81100e84:	109e6904 	addi	r2,r2,31140
81100e88:	1009883a 	mov	r4,r2
81100e8c:	008009c4 	movi	r2,39
81100e90:	100d883a 	mov	r6,r2
81100e94:	200b883a 	mov	r5,r4
81100e98:	1809883a 	mov	r4,r3
81100e9c:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun RAS to CAS delay[tRCD;nsx4])\n");
				debug(fp, cDebugBuffer);
81100ea0:	d0a05e17 	ldw	r2,-32392(gp)
81100ea4:	01604574 	movhi	r5,33045
81100ea8:	297b8b04 	addi	r5,r5,-4564
81100eac:	1009883a 	mov	r4,r2
81100eb0:	111ca180 	call	8111ca18 <fprintf>
81100eb4:	00015c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 30) {
81100eb8:	e0bfbc17 	ldw	r2,-272(fp)
81100ebc:	10800798 	cmpnei	r2,r2,30
81100ec0:	1000101e 	bne	r2,zero,81100f04 <bDdr2EepromDump+0x6ec>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ec4:	00e04574 	movhi	r3,33045
81100ec8:	18fb8b04 	addi	r3,r3,-4564
81100ecc:	00a04534 	movhi	r2,33044
81100ed0:	109e7304 	addi	r2,r2,31180
81100ed4:	1009883a 	mov	r4,r2
81100ed8:	00800b04 	movi	r2,44
81100edc:	100d883a 	mov	r6,r2
81100ee0:	200b883a 	mov	r5,r4
81100ee4:	1809883a 	mov	r4,r3
81100ee8:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun acive to precharge time[tRAS;ns])\n");
				debug(fp, cDebugBuffer);
81100eec:	d0a05e17 	ldw	r2,-32392(gp)
81100ef0:	01604574 	movhi	r5,33045
81100ef4:	297b8b04 	addi	r5,r5,-4564
81100ef8:	1009883a 	mov	r4,r2
81100efc:	111ca180 	call	8111ca18 <fprintf>
81100f00:	00014906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 31) {
81100f04:	e0bfbc17 	ldw	r2,-272(fp)
81100f08:	108007d8 	cmpnei	r2,r2,31
81100f0c:	1000101e 	bne	r2,zero,81100f50 <bDdr2EepromDump+0x738>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f10:	00e04574 	movhi	r3,33045
81100f14:	18fb8b04 	addi	r3,r3,-4564
81100f18:	00a04534 	movhi	r2,33044
81100f1c:	109e7e04 	addi	r2,r2,31224
81100f20:	1009883a 	mov	r4,r2
81100f24:	008010c4 	movi	r2,67
81100f28:	100d883a 	mov	r6,r2
81100f2c:	200b883a 	mov	r5,r4
81100f30:	1809883a 	mov	r4,r3
81100f34:	111dac80 	call	8111dac8 <memcpy>
						"(Size of each rank[bitmap:512MB,256MB,128MB,16GB,8GB,4GB,2GB,1GB)\n");
				debug(fp, cDebugBuffer);
81100f38:	d0a05e17 	ldw	r2,-32392(gp)
81100f3c:	01604574 	movhi	r5,33045
81100f40:	297b8b04 	addi	r5,r5,-4564
81100f44:	1009883a 	mov	r4,r2
81100f48:	111ca180 	call	8111ca18 <fprintf>
81100f4c:	00013606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 36) {
81100f50:	e0bfbc17 	ldw	r2,-272(fp)
81100f54:	10800918 	cmpnei	r2,r2,36
81100f58:	1000101e 	bne	r2,zero,81100f9c <bDdr2EepromDump+0x784>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100f5c:	00e04574 	movhi	r3,33045
81100f60:	18fb8b04 	addi	r3,r3,-4564
81100f64:	00a04534 	movhi	r2,33044
81100f68:	109e8f04 	addi	r2,r2,31292
81100f6c:	1009883a 	mov	r4,r2
81100f70:	00800a84 	movi	r2,42
81100f74:	100d883a 	mov	r6,r2
81100f78:	200b883a 	mov	r5,r4
81100f7c:	1809883a 	mov	r4,r3
81100f80:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun write receovery time[tWR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100f84:	d0a05e17 	ldw	r2,-32392(gp)
81100f88:	01604574 	movhi	r5,33045
81100f8c:	297b8b04 	addi	r5,r5,-4564
81100f90:	1009883a 	mov	r4,r2
81100f94:	111ca180 	call	8111ca18 <fprintf>
81100f98:	00012306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 37) {
81100f9c:	e0bfbc17 	ldw	r2,-272(fp)
81100fa0:	10800958 	cmpnei	r2,r2,37
81100fa4:	1000101e 	bne	r2,zero,81100fe8 <bDdr2EepromDump+0x7d0>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100fa8:	00e04574 	movhi	r3,33045
81100fac:	18fb8b04 	addi	r3,r3,-4564
81100fb0:	00a04534 	movhi	r2,33044
81100fb4:	109e9a04 	addi	r2,r2,31336
81100fb8:	1009883a 	mov	r4,r2
81100fbc:	00800cc4 	movi	r2,51
81100fc0:	100d883a 	mov	r6,r2
81100fc4:	200b883a 	mov	r5,r4
81100fc8:	1809883a 	mov	r4,r3
81100fcc:	111dac80 	call	8111dac8 <memcpy>
						"(Internal write to read command delay[tWTR;nsx4])\n");
				debug(fp, cDebugBuffer);
81100fd0:	d0a05e17 	ldw	r2,-32392(gp)
81100fd4:	01604574 	movhi	r5,33045
81100fd8:	297b8b04 	addi	r5,r5,-4564
81100fdc:	1009883a 	mov	r4,r2
81100fe0:	111ca180 	call	8111ca18 <fprintf>
81100fe4:	00011006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 38) {
81100fe8:	e0bfbc17 	ldw	r2,-272(fp)
81100fec:	10800998 	cmpnei	r2,r2,38
81100ff0:	1000101e 	bne	r2,zero,81101034 <bDdr2EepromDump+0x81c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81100ff4:	00e04574 	movhi	r3,33045
81100ff8:	18fb8b04 	addi	r3,r3,-4564
81100ffc:	00a04534 	movhi	r2,33044
81101000:	109ea704 	addi	r2,r2,31388
81101004:	1009883a 	mov	r4,r2
81101008:	00800dc4 	movi	r2,55
8110100c:	100d883a 	mov	r6,r2
81101010:	200b883a 	mov	r5,r4
81101014:	1809883a 	mov	r4,r3
81101018:	111dac80 	call	8111dac8 <memcpy>
						"(Internal read to precharge command delay[tRTP;nsx4])\n");
				debug(fp, cDebugBuffer);
8110101c:	d0a05e17 	ldw	r2,-32392(gp)
81101020:	01604574 	movhi	r5,33045
81101024:	297b8b04 	addi	r5,r5,-4564
81101028:	1009883a 	mov	r4,r2
8110102c:	111ca180 	call	8111ca18 <fprintf>
81101030:	0000fd06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 41) {
81101034:	e0bfbc17 	ldw	r2,-272(fp)
81101038:	10800a58 	cmpnei	r2,r2,41
8110103c:	1000101e 	bne	r2,zero,81101080 <bDdr2EepromDump+0x868>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101040:	00e04574 	movhi	r3,33045
81101044:	18fb8b04 	addi	r3,r3,-4564
81101048:	00a04534 	movhi	r2,33044
8110104c:	109eb504 	addi	r2,r2,31444
81101050:	1009883a 	mov	r4,r2
81101054:	00800c84 	movi	r2,50
81101058:	100d883a 	mov	r6,r2
8110105c:	200b883a 	mov	r5,r4
81101060:	1809883a 	mov	r4,r3
81101064:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun activce to active/refresh time[tRC;ns])\n");
				debug(fp, cDebugBuffer);
81101068:	d0a05e17 	ldw	r2,-32392(gp)
8110106c:	01604574 	movhi	r5,33045
81101070:	297b8b04 	addi	r5,r5,-4564
81101074:	1009883a 	mov	r4,r2
81101078:	111ca180 	call	8111ca18 <fprintf>
8110107c:	0000ea06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 42) {
81101080:	e0bfbc17 	ldw	r2,-272(fp)
81101084:	10800a98 	cmpnei	r2,r2,42
81101088:	1000101e 	bne	r2,zero,811010cc <bDdr2EepromDump+0x8b4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
8110108c:	00e04574 	movhi	r3,33045
81101090:	18fb8b04 	addi	r3,r3,-4564
81101094:	00a04534 	movhi	r2,33044
81101098:	109ec204 	addi	r2,r2,31496
8110109c:	1009883a 	mov	r4,r2
811010a0:	00800cc4 	movi	r2,51
811010a4:	100d883a 	mov	r6,r2
811010a8:	200b883a 	mov	r5,r4
811010ac:	1809883a 	mov	r4,r3
811010b0:	111dac80 	call	8111dac8 <memcpy>
						"(Minimun refresh to active/refresh time[tRFC;ns])\n");
				debug(fp, cDebugBuffer);
811010b4:	d0a05e17 	ldw	r2,-32392(gp)
811010b8:	01604574 	movhi	r5,33045
811010bc:	297b8b04 	addi	r5,r5,-4564
811010c0:	1009883a 	mov	r4,r2
811010c4:	111ca180 	call	8111ca18 <fprintf>
811010c8:	0000d706 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 62) {
811010cc:	e0bfbc17 	ldw	r2,-272(fp)
811010d0:	10800f98 	cmpnei	r2,r2,62
811010d4:	1000101e 	bne	r2,zero,81101118 <bDdr2EepromDump+0x900>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(SPD Revision)\n");
811010d8:	00e04574 	movhi	r3,33045
811010dc:	18fb8b04 	addi	r3,r3,-4564
811010e0:	00a04534 	movhi	r2,33044
811010e4:	109ecf04 	addi	r2,r2,31548
811010e8:	1009883a 	mov	r4,r2
811010ec:	00800404 	movi	r2,16
811010f0:	100d883a 	mov	r6,r2
811010f4:	200b883a 	mov	r5,r4
811010f8:	1809883a 	mov	r4,r3
811010fc:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81101100:	d0a05e17 	ldw	r2,-32392(gp)
81101104:	01604574 	movhi	r5,33045
81101108:	297b8b04 	addi	r5,r5,-4564
8110110c:	1009883a 	mov	r4,r2
81101110:	111ca180 	call	8111ca18 <fprintf>
81101114:	0000c406 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 63) {
81101118:	e0bfbc17 	ldw	r2,-272(fp)
8110111c:	10800fd8 	cmpnei	r2,r2,63
81101120:	10001f1e 	bne	r2,zero,811011a0 <bDdr2EepromDump+0x988>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Checksum)\n");
81101124:	00a04574 	movhi	r2,33045
81101128:	10bb8b04 	addi	r2,r2,-4564
8110112c:	00c00a04 	movi	r3,40
81101130:	10c00005 	stb	r3,0(r2)
81101134:	00c010c4 	movi	r3,67
81101138:	10c00045 	stb	r3,1(r2)
8110113c:	00c01a04 	movi	r3,104
81101140:	10c00085 	stb	r3,2(r2)
81101144:	00c01944 	movi	r3,101
81101148:	10c000c5 	stb	r3,3(r2)
8110114c:	00c018c4 	movi	r3,99
81101150:	10c00105 	stb	r3,4(r2)
81101154:	00c01ac4 	movi	r3,107
81101158:	10c00145 	stb	r3,5(r2)
8110115c:	00c01cc4 	movi	r3,115
81101160:	10c00185 	stb	r3,6(r2)
81101164:	00c01d44 	movi	r3,117
81101168:	10c001c5 	stb	r3,7(r2)
8110116c:	00c01b44 	movi	r3,109
81101170:	10c00205 	stb	r3,8(r2)
81101174:	00c00a44 	movi	r3,41
81101178:	10c00245 	stb	r3,9(r2)
8110117c:	00c00284 	movi	r3,10
81101180:	10c00285 	stb	r3,10(r2)
81101184:	100002c5 	stb	zero,11(r2)
				debug(fp, cDebugBuffer);
81101188:	d0a05e17 	ldw	r2,-32392(gp)
8110118c:	01604574 	movhi	r5,33045
81101190:	297b8b04 	addi	r5,r5,-4564
81101194:	1009883a 	mov	r4,r2
81101198:	111ca180 	call	8111ca18 <fprintf>
8110119c:	0000a206 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 64) {
811011a0:	e0bfbc17 	ldw	r2,-272(fp)
811011a4:	10801018 	cmpnei	r2,r2,64
811011a8:	1000101e 	bne	r2,zero,811011ec <bDdr2EepromDump+0x9d4>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(64~71: Manufacturer JEDEC ID)\n");
811011ac:	00e04574 	movhi	r3,33045
811011b0:	18fb8b04 	addi	r3,r3,-4564
811011b4:	00a04534 	movhi	r2,33044
811011b8:	109ed304 	addi	r2,r2,31564
811011bc:	1009883a 	mov	r4,r2
811011c0:	00800804 	movi	r2,32
811011c4:	100d883a 	mov	r6,r2
811011c8:	200b883a 	mov	r5,r4
811011cc:	1809883a 	mov	r4,r3
811011d0:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
811011d4:	d0a05e17 	ldw	r2,-32392(gp)
811011d8:	01604574 	movhi	r5,33045
811011dc:	297b8b04 	addi	r5,r5,-4564
811011e0:	1009883a 	mov	r4,r2
811011e4:	111ca180 	call	8111ca18 <fprintf>
811011e8:	00008f06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 72) {
811011ec:	e0bfbc17 	ldw	r2,-272(fp)
811011f0:	10801218 	cmpnei	r2,r2,72
811011f4:	1000101e 	bne	r2,zero,81101238 <bDdr2EepromDump+0xa20>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811011f8:	00e04574 	movhi	r3,33045
811011fc:	18fb8b04 	addi	r3,r3,-4564
81101200:	00a04534 	movhi	r2,33044
81101204:	109edb04 	addi	r2,r2,31596
81101208:	1009883a 	mov	r4,r2
8110120c:	00800dc4 	movi	r2,55
81101210:	100d883a 	mov	r6,r2
81101214:	200b883a 	mov	r5,r4
81101218:	1809883a 	mov	r4,r3
8110121c:	111dac80 	call	8111dac8 <memcpy>
						"(Module manufacturing location[Vendor-specific code])\n");
				debug(fp, cDebugBuffer);
81101220:	d0a05e17 	ldw	r2,-32392(gp)
81101224:	01604574 	movhi	r5,33045
81101228:	297b8b04 	addi	r5,r5,-4564
8110122c:	1009883a 	mov	r4,r2
81101230:	111ca180 	call	8111ca18 <fprintf>
81101234:	00007c06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 73) {
81101238:	e0bfbc17 	ldw	r2,-272(fp)
8110123c:	10801258 	cmpnei	r2,r2,73
81101240:	1000101e 	bne	r2,zero,81101284 <bDdr2EepromDump+0xa6c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(73~90: Moduloe part number)\n");
81101244:	00e04574 	movhi	r3,33045
81101248:	18fb8b04 	addi	r3,r3,-4564
8110124c:	00a04534 	movhi	r2,33044
81101250:	109ee904 	addi	r2,r2,31652
81101254:	1009883a 	mov	r4,r2
81101258:	00800784 	movi	r2,30
8110125c:	100d883a 	mov	r6,r2
81101260:	200b883a 	mov	r5,r4
81101264:	1809883a 	mov	r4,r3
81101268:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
8110126c:	d0a05e17 	ldw	r2,-32392(gp)
81101270:	01604574 	movhi	r5,33045
81101274:	297b8b04 	addi	r5,r5,-4564
81101278:	1009883a 	mov	r4,r2
8110127c:	111ca180 	call	8111ca18 <fprintf>
81101280:	00006906 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 91) {
81101284:	e0bfbc17 	ldw	r2,-272(fp)
81101288:	108016d8 	cmpnei	r2,r2,91
8110128c:	1000101e 	bne	r2,zero,811012d0 <bDdr2EepromDump+0xab8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(91~92: Moduloe revision code)\n");
81101290:	00e04574 	movhi	r3,33045
81101294:	18fb8b04 	addi	r3,r3,-4564
81101298:	00a04534 	movhi	r2,33044
8110129c:	109ef104 	addi	r2,r2,31684
811012a0:	1009883a 	mov	r4,r2
811012a4:	00800804 	movi	r2,32
811012a8:	100d883a 	mov	r6,r2
811012ac:	200b883a 	mov	r5,r4
811012b0:	1809883a 	mov	r4,r3
811012b4:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
811012b8:	d0a05e17 	ldw	r2,-32392(gp)
811012bc:	01604574 	movhi	r5,33045
811012c0:	297b8b04 	addi	r5,r5,-4564
811012c4:	1009883a 	mov	r4,r2
811012c8:	111ca180 	call	8111ca18 <fprintf>
811012cc:	00005606 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 93) {
811012d0:	e0bfbc17 	ldw	r2,-272(fp)
811012d4:	10801758 	cmpnei	r2,r2,93
811012d8:	1000101e 	bne	r2,zero,8110131c <bDdr2EepromDump+0xb04>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
811012dc:	00e04574 	movhi	r3,33045
811012e0:	18fb8b04 	addi	r3,r3,-4564
811012e4:	00a04534 	movhi	r2,33044
811012e8:	109ef904 	addi	r2,r2,31716
811012ec:	1009883a 	mov	r4,r2
811012f0:	008009c4 	movi	r2,39
811012f4:	100d883a 	mov	r6,r2
811012f8:	200b883a 	mov	r5,r4
811012fc:	1809883a 	mov	r4,r3
81101300:	111dac80 	call	8111dac8 <memcpy>
						"(Manufacture Years since 2000[0-255])\n");
				debug(fp, cDebugBuffer);
81101304:	d0a05e17 	ldw	r2,-32392(gp)
81101308:	01604574 	movhi	r5,33045
8110130c:	297b8b04 	addi	r5,r5,-4564
81101310:	1009883a 	mov	r4,r2
81101314:	111ca180 	call	8111ca18 <fprintf>
81101318:	00004306 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 94) {
8110131c:	e0bfbc17 	ldw	r2,-272(fp)
81101320:	10801798 	cmpnei	r2,r2,94
81101324:	1000101e 	bne	r2,zero,81101368 <bDdr2EepromDump+0xb50>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(Manufacture Weeks[1-52])\n");
81101328:	00e04574 	movhi	r3,33045
8110132c:	18fb8b04 	addi	r3,r3,-4564
81101330:	00a04534 	movhi	r2,33044
81101334:	109f0304 	addi	r2,r2,31756
81101338:	1009883a 	mov	r4,r2
8110133c:	008006c4 	movi	r2,27
81101340:	100d883a 	mov	r6,r2
81101344:	200b883a 	mov	r5,r4
81101348:	1809883a 	mov	r4,r3
8110134c:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
81101350:	d0a05e17 	ldw	r2,-32392(gp)
81101354:	01604574 	movhi	r5,33045
81101358:	297b8b04 	addi	r5,r5,-4564
8110135c:	1009883a 	mov	r4,r2
81101360:	111ca180 	call	8111ca18 <fprintf>
81101364:	00003006 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 95) {
81101368:	e0bfbc17 	ldw	r2,-272(fp)
8110136c:	108017d8 	cmpnei	r2,r2,95
81101370:	1000101e 	bne	r2,zero,811013b4 <bDdr2EepromDump+0xb9c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101374:	00e04574 	movhi	r3,33045
81101378:	18fb8b04 	addi	r3,r3,-4564
8110137c:	00a04534 	movhi	r2,33044
81101380:	109f0a04 	addi	r2,r2,31784
81101384:	1009883a 	mov	r4,r2
81101388:	00800a04 	movi	r2,40
8110138c:	100d883a 	mov	r6,r2
81101390:	200b883a 	mov	r5,r4
81101394:	1809883a 	mov	r4,r3
81101398:	111dac80 	call	8111dac8 <memcpy>
						"(95~98[4-bytes]: Module serial number)\n");
				debug(fp, cDebugBuffer);
8110139c:	d0a05e17 	ldw	r2,-32392(gp)
811013a0:	01604574 	movhi	r5,33045
811013a4:	297b8b04 	addi	r5,r5,-4564
811013a8:	1009883a 	mov	r4,r2
811013ac:	111ca180 	call	8111ca18 <fprintf>
811013b0:	00001d06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else if (iI == 99) {
811013b4:	e0bfbc17 	ldw	r2,-272(fp)
811013b8:	108018d8 	cmpnei	r2,r2,99
811013bc:	1000101e 	bne	r2,zero,81101400 <bDdr2EepromDump+0xbe8>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "(99~128: Manufacturer-specific data)\n");
811013c0:	00e04574 	movhi	r3,33045
811013c4:	18fb8b04 	addi	r3,r3,-4564
811013c8:	00a04534 	movhi	r2,33044
811013cc:	109f1404 	addi	r2,r2,31824
811013d0:	1009883a 	mov	r4,r2
811013d4:	00800984 	movi	r2,38
811013d8:	100d883a 	mov	r6,r2
811013dc:	200b883a 	mov	r5,r4
811013e0:	1809883a 	mov	r4,r3
811013e4:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
811013e8:	d0a05e17 	ldw	r2,-32392(gp)
811013ec:	01604574 	movhi	r5,33045
811013f0:	297b8b04 	addi	r5,r5,-4564
811013f4:	1009883a 	mov	r4,r2
811013f8:	111ca180 	call	8111ca18 <fprintf>
811013fc:	00000a06 	br	81101428 <bDdr2EepromDump+0xc10>
#endif
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "\n");
81101400:	00a04574 	movhi	r2,33045
81101404:	10bb8b04 	addi	r2,r2,-4564
81101408:	00c00284 	movi	r3,10
8110140c:	10c00005 	stb	r3,0(r2)
81101410:	10000045 	stb	zero,1(r2)
				debug(fp, cDebugBuffer);
81101414:	d0a05e17 	ldw	r2,-32392(gp)
81101418:	01604574 	movhi	r5,33045
8110141c:	297b8b04 	addi	r5,r5,-4564
81101420:	1009883a 	mov	r4,r2
81101424:	111ca180 	call	8111ca18 <fprintf>

	alt_u8 ucSZData[256];
	bSuccess = I2C_MultipleRead(uliI2cSclBase, uliI2cSdaBase, cucDeviceAddr,
			ucSZData, sizeof(ucSZData));
	if (bSuccess) {
		for (iI = 0; iI < 256 && bSuccess; iI++) {
81101428:	e0bfbc17 	ldw	r2,-272(fp)
8110142c:	10800044 	addi	r2,r2,1
81101430:	e0bfbc15 	stw	r2,-272(fp)
81101434:	e0bfbc17 	ldw	r2,-272(fp)
81101438:	10804008 	cmpgei	r2,r2,256
8110143c:	1000121e 	bne	r2,zero,81101488 <bDdr2EepromDump+0xc70>
81101440:	e0bfbe17 	ldw	r2,-264(fp)
81101444:	103d451e 	bne	r2,zero,8110095c <__reset+0xfb0e095c>
81101448:	00000f06 	br	81101488 <bDdr2EepromDump+0xc70>
#endif
			}
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Failed to dump EEPROM\n");
8110144c:	00e04574 	movhi	r3,33045
81101450:	18fb8b04 	addi	r3,r3,-4564
81101454:	00a04534 	movhi	r2,33044
81101458:	109f1e04 	addi	r2,r2,31864
8110145c:	1009883a 	mov	r4,r2
81101460:	008005c4 	movi	r2,23
81101464:	100d883a 	mov	r6,r2
81101468:	200b883a 	mov	r5,r4
8110146c:	1809883a 	mov	r4,r3
81101470:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81101474:	d0a05e17 	ldw	r2,-32392(gp)
81101478:	01604574 	movhi	r5,33045
8110147c:	297b8b04 	addi	r5,r5,-4564
81101480:	1009883a 	mov	r4,r2
81101484:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101488:	00a04574 	movhi	r2,33045
8110148c:	10bb8b04 	addi	r2,r2,-4564
81101490:	00c00284 	movi	r3,10
81101494:	10c00005 	stb	r3,0(r2)
81101498:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110149c:	d0a05e17 	ldw	r2,-32392(gp)
811014a0:	01604574 	movhi	r5,33045
811014a4:	297b8b04 	addi	r5,r5,-4564
811014a8:	1009883a 	mov	r4,r2
811014ac:	111ca180 	call	8111ca18 <fprintf>
#endif

	return bSuccess;
811014b0:	e0bfbe17 	ldw	r2,-264(fp)
}
811014b4:	e037883a 	mov	sp,fp
811014b8:	dfc00117 	ldw	ra,4(sp)
811014bc:	df000017 	ldw	fp,0(sp)
811014c0:	dec00204 	addi	sp,sp,8
811014c4:	f800283a 	ret

811014c8 <bDdr2SwitchMemory>:

bool bDdr2SwitchMemory(alt_u8 ucMemoryId) {
811014c8:	defffb04 	addi	sp,sp,-20
811014cc:	de00012e 	bgeu	sp,et,811014d4 <bDdr2SwitchMemory+0xc>
811014d0:	003b68fa 	trap	3
811014d4:	dfc00415 	stw	ra,16(sp)
811014d8:	df000315 	stw	fp,12(sp)
811014dc:	df000304 	addi	fp,sp,12
811014e0:	2005883a 	mov	r2,r4
811014e4:	e0bfff05 	stb	r2,-4(fp)

	bool bSuccess;
	alt_u32 *puliDdr2MemAddr = (alt_u32 *) DDR2_EXT_ADDR_CONTROL_BASE;
811014e8:	00a04834 	movhi	r2,33056
811014ec:	108c2204 	addi	r2,r2,12424
811014f0:	e0bffe15 	stw	r2,-8(fp)

	bSuccess = TRUE;
811014f4:	00800044 	movi	r2,1
811014f8:	e0bffd15 	stw	r2,-12(fp)
	switch (ucMemoryId) {
811014fc:	e0bfff03 	ldbu	r2,-4(fp)
81101500:	10000326 	beq	r2,zero,81101510 <bDdr2SwitchMemory+0x48>
81101504:	10800060 	cmpeqi	r2,r2,1
81101508:	1000041e 	bne	r2,zero,8110151c <bDdr2SwitchMemory+0x54>
8110150c:	00000706 	br	8110152c <bDdr2SwitchMemory+0x64>
	case DDR2_M1_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M1_MEMORY_WINDOWED_OFFSET;
81101510:	e0bffe17 	ldw	r2,-8(fp)
81101514:	10000015 	stw	zero,0(r2)
		break;
81101518:	00001406 	br	8110156c <bDdr2SwitchMemory+0xa4>
	case DDR2_M2_ID:
		*(puliDdr2MemAddr) = (alt_u32) DDR2_M2_MEMORY_WINDOWED_OFFSET;
8110151c:	e0bffe17 	ldw	r2,-8(fp)
81101520:	00e00034 	movhi	r3,32768
81101524:	10c00015 	stw	r3,0(r2)
		break;
81101528:	00001006 	br	8110156c <bDdr2SwitchMemory+0xa4>
	default:
		bSuccess = FALSE;
8110152c:	e03ffd15 	stw	zero,-12(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101530:	00e04574 	movhi	r3,33045
81101534:	18fb8b04 	addi	r3,r3,-4564
81101538:	00a04534 	movhi	r2,33044
8110153c:	109f2404 	addi	r2,r2,31888
81101540:	1009883a 	mov	r4,r2
81101544:	00800f04 	movi	r2,60
81101548:	100d883a 	mov	r6,r2
8110154c:	200b883a 	mov	r5,r4
81101550:	1809883a 	mov	r4,r3
81101554:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Error switching memories!! \n");
		debug(fp, cDebugBuffer)
81101558:	d0a05e17 	ldw	r2,-32392(gp)
8110155c:	01604574 	movhi	r5,33045
81101560:	297b8b04 	addi	r5,r5,-4564
81101564:	1009883a 	mov	r4,r2
81101568:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
	}

	return bSuccess;
8110156c:	e0bffd17 	ldw	r2,-12(fp)
}
81101570:	e037883a 	mov	sp,fp
81101574:	dfc00117 	ldw	ra,4(sp)
81101578:	df000017 	ldw	fp,0(sp)
8110157c:	dec00204 	addi	sp,sp,8
81101580:	f800283a 	ret

81101584 <bDdr2MemoryWriteTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryWriteTest(alt_u8 ucMemoryId) {
81101584:	deffe204 	addi	sp,sp,-120
81101588:	de00012e 	bgeu	sp,et,81101590 <bDdr2MemoryWriteTest+0xc>
8110158c:	003b68fa 	trap	3
81101590:	dfc01d15 	stw	ra,116(sp)
81101594:	df001c15 	stw	fp,112(sp)
81101598:	dc401b15 	stw	r17,108(sp)
8110159c:	dc001a15 	stw	r16,104(sp)
811015a0:	df001c04 	addi	fp,sp,112
811015a4:	2005883a 	mov	r2,r4
811015a8:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Write Test =====\n");
811015ac:	00e04574 	movhi	r3,33045
811015b0:	18fb8b04 	addi	r3,r3,-4564
811015b4:	00a04534 	movhi	r2,33044
811015b8:	109f3304 	addi	r2,r2,31948
811015bc:	1009883a 	mov	r4,r2
811015c0:	00800a04 	movi	r2,40
811015c4:	100d883a 	mov	r6,r2
811015c8:	200b883a 	mov	r5,r4
811015cc:	1809883a 	mov	r4,r3
811015d0:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
811015d4:	d0a05e17 	ldw	r2,-32392(gp)
811015d8:	01604574 	movhi	r5,33045
811015dc:	297b8b04 	addi	r5,r5,-4564
811015e0:	1009883a 	mov	r4,r2
811015e4:	111ca180 	call	8111ca18 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811015e8:	00800044 	movi	r2,1
811015ec:	e0bfed15 	stw	r2,-76(fp)
	switch (ucMemoryId) {
811015f0:	e0bffd03 	ldbu	r2,-12(fp)
811015f4:	10000326 	beq	r2,zero,81101604 <bDdr2MemoryWriteTest+0x80>
811015f8:	10800060 	cmpeqi	r2,r2,1
811015fc:	1000081e 	bne	r2,zero,81101620 <bDdr2MemoryWriteTest+0x9c>
81101600:	00000e06 	br	8110163c <bDdr2MemoryWriteTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101604:	e0bffd03 	ldbu	r2,-12(fp)
81101608:	1009883a 	mov	r4,r2
8110160c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101610:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101614:	00a00034 	movhi	r2,32768
81101618:	e0bfe615 	stw	r2,-104(fp)
		break;
8110161c:	00001906 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101620:	e0bffd03 	ldbu	r2,-12(fp)
81101624:	1009883a 	mov	r4,r2
81101628:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
8110162c:	e03fe515 	stw	zero,-108(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101630:	00a00034 	movhi	r2,32768
81101634:	e0bfe615 	stw	r2,-104(fp)
		break;
81101638:	00001206 	br	81101684 <bDdr2MemoryWriteTest+0x100>
	default:
		bSuccess = FALSE;
8110163c:	e03fed15 	stw	zero,-76(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101640:	00e04574 	movhi	r3,33045
81101644:	18fb8b04 	addi	r3,r3,-4564
81101648:	00a04534 	movhi	r2,33044
8110164c:	109d4404 	addi	r2,r2,29968
81101650:	1009883a 	mov	r4,r2
81101654:	00800bc4 	movi	r2,47
81101658:	100d883a 	mov	r6,r2
8110165c:	200b883a 	mov	r5,r4
81101660:	1809883a 	mov	r4,r3
81101664:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101668:	d0a05e17 	ldw	r2,-32392(gp)
8110166c:	01604574 	movhi	r5,33045
81101670:	297b8b04 	addi	r5,r5,-4564
81101674:	1009883a 	mov	r4,r2
81101678:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
		return bSuccess;
8110167c:	e0bfed17 	ldw	r2,-76(fp)
81101680:	00011806 	br	81101ae4 <bDdr2MemoryWriteTest+0x560>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81101684:	e0bfe617 	ldw	r2,-104(fp)
81101688:	1004d53a 	srli	r2,r2,20
8110168c:	100d883a 	mov	r6,r2
81101690:	01604534 	movhi	r5,33044
81101694:	295f3d04 	addi	r5,r5,31988
81101698:	01204574 	movhi	r4,33045
8110169c:	213b8b04 	addi	r4,r4,-4564
811016a0:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
811016a4:	d0a05e17 	ldw	r2,-32392(gp)
811016a8:	01604574 	movhi	r5,33045
811016ac:	297b8b04 	addi	r5,r5,-4564
811016b0:	1009883a 	mov	r4,r2
811016b4:	111ca180 	call	8111ca18 <fprintf>

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes;

	int iNItemNum, iNPos;
	const int ciMyDataSize = sizeof(TMyData);
811016b8:	00800104 	movi	r2,4
811016bc:	e0bfee15 	stw	r2,-72(fp)
	int iNProgressIndex = 0;
811016c0:	e03fec15 	stw	zero,-80(fp)
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
811016c4:	e03fef15 	stw	zero,-68(fp)

	for (iI = 0; iI < 10; iI++) {
811016c8:	e03fe715 	stw	zero,-100(fp)
811016cc:	00001506 	br	81101724 <bDdr2MemoryWriteTest+0x1a0>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
811016d0:	e0ffe617 	ldw	r3,-104(fp)
811016d4:	00b33374 	movhi	r2,52429
811016d8:	10b33344 	addi	r2,r2,-13107
811016dc:	1888383a 	mulxuu	r4,r3,r2
811016e0:	1885383a 	mul	r2,r3,r2
811016e4:	1021883a 	mov	r16,r2
811016e8:	2023883a 	mov	r17,r4
811016ec:	8804d0fa 	srli	r2,r17,3
811016f0:	e0ffe717 	ldw	r3,-100(fp)
811016f4:	18c00044 	addi	r3,r3,1
811016f8:	10c7383a 	mul	r3,r2,r3
811016fc:	e0bfe717 	ldw	r2,-100(fp)
81101700:	1085883a 	add	r2,r2,r2
81101704:	1085883a 	add	r2,r2,r2
81101708:	e13fe504 	addi	r4,fp,-108
8110170c:	2085883a 	add	r2,r4,r2
81101710:	10800e04 	addi	r2,r2,56
81101714:	10c00015 	stw	r3,0(r2)
	int iNProgressIndex = 0;
	alt_u32 uliInitValue;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101718:	e0bfe717 	ldw	r2,-100(fp)
8110171c:	10800044 	addi	r2,r2,1
81101720:	e0bfe715 	stw	r2,-100(fp)
81101724:	e0bfe717 	ldw	r2,-100(fp)
81101728:	10800290 	cmplti	r2,r2,10
8110172c:	103fe81e 	bne	r2,zero,811016d0 <__reset+0xfb0e16d0>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101730:	d0a08517 	ldw	r2,-32236(gp)
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
81101734:	e0bff015 	stw	r2,-64(fp)
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101738:	00804004 	movi	r2,256
8110173c:	e0bfea15 	stw	r2,-88(fp)
	for (iI = 0; iI < iNItemNum; iI++) {
81101740:	e03fe715 	stw	zero,-100(fp)
81101744:	00001e06 	br	811017c0 <bDdr2MemoryWriteTest+0x23c>
		if (iI == 0) {
81101748:	e0bfe717 	ldw	r2,-100(fp)
8110174c:	1000091e 	bne	r2,zero,81101774 <bDdr2MemoryWriteTest+0x1f0>
			xSZData[iI] = uliInitValue;
81101750:	00a04574 	movhi	r2,33045
81101754:	10bbcb04 	addi	r2,r2,-4308
81101758:	e0ffe717 	ldw	r3,-100(fp)
8110175c:	18c7883a 	add	r3,r3,r3
81101760:	18c7883a 	add	r3,r3,r3
81101764:	10c5883a 	add	r2,r2,r3
81101768:	e0fff017 	ldw	r3,-64(fp)
8110176c:	10c00015 	stw	r3,0(r2)
81101770:	00001006 	br	811017b4 <bDdr2MemoryWriteTest+0x230>
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
81101774:	e0bfe717 	ldw	r2,-100(fp)
81101778:	10ffffc4 	addi	r3,r2,-1
8110177c:	00a04574 	movhi	r2,33045
81101780:	10bbcb04 	addi	r2,r2,-4308
81101784:	18c7883a 	add	r3,r3,r3
81101788:	18c7883a 	add	r3,r3,r3
8110178c:	10c5883a 	add	r2,r2,r3
81101790:	10800017 	ldw	r2,0(r2)
81101794:	11000364 	muli	r4,r2,13
81101798:	00a04574 	movhi	r2,33045
8110179c:	10bbcb04 	addi	r2,r2,-4308
811017a0:	e0ffe717 	ldw	r3,-100(fp)
811017a4:	18c7883a 	add	r3,r3,r3
811017a8:	18c7883a 	add	r3,r3,r3
811017ac:	10c5883a 	add	r2,r2,r3
811017b0:	11000015 	stw	r4,0(r2)
	for (iI = 0; iI < 10; iI++) {
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}
	uliInitValue = alt_nticks();
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
	for (iI = 0; iI < iNItemNum; iI++) {
811017b4:	e0bfe717 	ldw	r2,-100(fp)
811017b8:	10800044 	addi	r2,r2,1
811017bc:	e0bfe715 	stw	r2,-100(fp)
811017c0:	e0ffe717 	ldw	r3,-100(fp)
811017c4:	e0bfea17 	ldw	r2,-88(fp)
811017c8:	18bfdf16 	blt	r3,r2,81101748 <__reset+0xfb0e1748>
			xSZData[iI] = uliInitValue;
		} else {
			xSZData[iI] = xSZData[iI - 1] * 13;
		}
	}
	xSZData[iNItemNum - 1] = 0xAAAAAAAA;
811017cc:	e0bfea17 	ldw	r2,-88(fp)
811017d0:	10ffffc4 	addi	r3,r2,-1
811017d4:	00a04574 	movhi	r2,33045
811017d8:	10bbcb04 	addi	r2,r2,-4308
811017dc:	18c7883a 	add	r3,r3,r3
811017e0:	18c7883a 	add	r3,r3,r3
811017e4:	10c7883a 	add	r3,r2,r3
811017e8:	00aaaaf4 	movhi	r2,43691
811017ec:	10aaaa84 	addi	r2,r2,-21846
811017f0:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 2] = 0x55555555;
811017f4:	e0bfea17 	ldw	r2,-88(fp)
811017f8:	10ffff84 	addi	r3,r2,-2
811017fc:	00a04574 	movhi	r2,33045
81101800:	10bbcb04 	addi	r2,r2,-4308
81101804:	18c7883a 	add	r3,r3,r3
81101808:	18c7883a 	add	r3,r3,r3
8110180c:	10c7883a 	add	r3,r2,r3
81101810:	00955574 	movhi	r2,21845
81101814:	10955544 	addi	r2,r2,21845
81101818:	18800015 	stw	r2,0(r3)
	xSZData[iNItemNum - 3] = 0x00000000;
8110181c:	e0bfea17 	ldw	r2,-88(fp)
81101820:	10ffff44 	addi	r3,r2,-3
81101824:	00a04574 	movhi	r2,33045
81101828:	10bbcb04 	addi	r2,r2,-4308
8110182c:	18c7883a 	add	r3,r3,r3
81101830:	18c7883a 	add	r3,r3,r3
81101834:	10c5883a 	add	r2,r2,r3
81101838:	10000015 	stw	zero,0(r2)
	xSZData[iNItemNum - 4] = 0xFFFFFFFF;
8110183c:	e0bfea17 	ldw	r2,-88(fp)
81101840:	10ffff04 	addi	r3,r2,-4
81101844:	00a04574 	movhi	r2,33045
81101848:	10bbcb04 	addi	r2,r2,-4308
8110184c:	18c7883a 	add	r3,r3,r3
81101850:	18c7883a 	add	r3,r3,r3
81101854:	10c5883a 	add	r2,r2,r3
81101858:	00ffffc4 	movi	r3,-1
8110185c:	10c00015 	stw	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing data...\n");
81101860:	00e04574 	movhi	r3,33045
81101864:	18fb8b04 	addi	r3,r3,-4564
81101868:	00a04534 	movhi	r2,33044
8110186c:	109f4304 	addi	r2,r2,32012
81101870:	1009883a 	mov	r4,r2
81101874:	00800444 	movi	r2,17
81101878:	100d883a 	mov	r6,r2
8110187c:	200b883a 	mov	r5,r4
81101880:	1809883a 	mov	r4,r3
81101884:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81101888:	d0a05e17 	ldw	r2,-32392(gp)
8110188c:	01604574 	movhi	r5,33045
81101890:	297b8b04 	addi	r5,r5,-4564
81101894:	1009883a 	mov	r4,r2
81101898:	111ca180 	call	8111ca18 <fprintf>
8110189c:	d0a08517 	ldw	r2,-32236(gp)
#endif
	iTimeStart = alt_nticks();
811018a0:	e0bff115 	stw	r2,-60(fp)
	pxDes = (TMyData *) uliDdr2Base;
811018a4:	e0bfe517 	ldw	r2,-108(fp)
811018a8:	e0bfe915 	stw	r2,-92(fp)
	iNAccessLen = sizeof(xSZData);
811018ac:	00810004 	movi	r2,1024
811018b0:	e0bfe815 	stw	r2,-96(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
811018b4:	e0ffe817 	ldw	r3,-96(fp)
811018b8:	e0bfee17 	ldw	r2,-72(fp)
811018bc:	1885283a 	div	r2,r3,r2
811018c0:	e0bfea15 	stw	r2,-88(fp)
	iNPos = 0;
811018c4:	e03feb15 	stw	zero,-84(fp)
	while (iNPos < uliByteLen) {
811018c8:	00003a06 	br	811019b4 <bDdr2MemoryWriteTest+0x430>
		iNRemainedLen = uliByteLen - iNPos;
811018cc:	e0bfeb17 	ldw	r2,-84(fp)
811018d0:	e0ffe617 	ldw	r3,-104(fp)
811018d4:	1885c83a 	sub	r2,r3,r2
811018d8:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
811018dc:	e0bfe817 	ldw	r2,-96(fp)
811018e0:	e0fff217 	ldw	r3,-56(fp)
811018e4:	1880060e 	bge	r3,r2,81101900 <bDdr2MemoryWriteTest+0x37c>
			iNAccessLen = iNRemainedLen;
811018e8:	e0bff217 	ldw	r2,-56(fp)
811018ec:	e0bfe815 	stw	r2,-96(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
811018f0:	e0ffe817 	ldw	r3,-96(fp)
811018f4:	e0bfee17 	ldw	r2,-72(fp)
811018f8:	1885283a 	div	r2,r3,r2
811018fc:	e0bfea15 	stw	r2,-88(fp)
		}
		memcpy(pxDes, xSZData, iNAccessLen);
81101900:	e0bfe817 	ldw	r2,-96(fp)
81101904:	100d883a 	mov	r6,r2
81101908:	01604574 	movhi	r5,33045
8110190c:	297bcb04 	addi	r5,r5,-4308
81101910:	e13fe917 	ldw	r4,-92(fp)
81101914:	111dac80 	call	8111dac8 <memcpy>
		pxDes += iNItemNum;
81101918:	e0bfea17 	ldw	r2,-88(fp)
8110191c:	1085883a 	add	r2,r2,r2
81101920:	1085883a 	add	r2,r2,r2
81101924:	1007883a 	mov	r3,r2
81101928:	e0bfe917 	ldw	r2,-92(fp)
8110192c:	10c5883a 	add	r2,r2,r3
81101930:	e0bfe915 	stw	r2,-92(fp)
		iNPos += iNAccessLen;
81101934:	e0ffeb17 	ldw	r3,-84(fp)
81101938:	e0bfe817 	ldw	r2,-96(fp)
8110193c:	1885883a 	add	r2,r3,r2
81101940:	e0bfeb15 	stw	r2,-84(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101944:	e0bfec17 	ldw	r2,-80(fp)
81101948:	10800288 	cmpgei	r2,r2,10
8110194c:	1000191e 	bne	r2,zero,811019b4 <bDdr2MemoryWriteTest+0x430>
81101950:	e0bfec17 	ldw	r2,-80(fp)
81101954:	1085883a 	add	r2,r2,r2
81101958:	1085883a 	add	r2,r2,r2
8110195c:	e0ffe504 	addi	r3,fp,-108
81101960:	1885883a 	add	r2,r3,r2
81101964:	10800e04 	addi	r2,r2,56
81101968:	10800017 	ldw	r2,0(r2)
8110196c:	e0ffeb17 	ldw	r3,-84(fp)
81101970:	18801036 	bltu	r3,r2,811019b4 <bDdr2MemoryWriteTest+0x430>
			iNProgressIndex++;
81101974:	e0bfec17 	ldw	r2,-80(fp)
81101978:	10800044 	addi	r2,r2,1
8110197c:	e0bfec15 	stw	r2,-80(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101980:	e0bfec17 	ldw	r2,-80(fp)
81101984:	108002a4 	muli	r2,r2,10
81101988:	100d883a 	mov	r6,r2
8110198c:	01604534 	movhi	r5,33044
81101990:	295f4804 	addi	r5,r5,32032
81101994:	01204574 	movhi	r4,33045
81101998:	213b8b04 	addi	r4,r4,-4564
8110199c:	111e3a80 	call	8111e3a8 <sprintf>
			debug(fp, cDebugBuffer);
811019a0:	d0a05e17 	ldw	r2,-32392(gp)
811019a4:	01604574 	movhi	r5,33045
811019a8:	297b8b04 	addi	r5,r5,-4564
811019ac:	1009883a 	mov	r4,r2
811019b0:	111ca180 	call	8111ca18 <fprintf>
	iTimeStart = alt_nticks();
	pxDes = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (iNPos < uliByteLen) {
811019b4:	e0ffeb17 	ldw	r3,-84(fp)
811019b8:	e0bfe617 	ldw	r2,-104(fp)
811019bc:	18bfc336 	bltu	r3,r2,811018cc <__reset+0xfb0e18cc>
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
			debug(fp, cDebugBuffer);
#endif
		}
	}
	alt_dcache_flush_all();
811019c0:	11324c80 	call	811324c8 <alt_dcache_flush_all>
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811019c4:	00a04574 	movhi	r2,33045
811019c8:	10bb8b04 	addi	r2,r2,-4564
811019cc:	00c00284 	movi	r3,10
811019d0:	10c00005 	stb	r3,0(r2)
811019d4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811019d8:	d0a05e17 	ldw	r2,-32392(gp)
811019dc:	01604574 	movhi	r5,33045
811019e0:	297b8b04 	addi	r5,r5,-4564
811019e4:	1009883a 	mov	r4,r2
811019e8:	111ca180 	call	8111ca18 <fprintf>
811019ec:	d0e08517 	ldw	r3,-32236(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
811019f0:	e0bff117 	ldw	r2,-60(fp)
811019f4:	1885c83a 	sub	r2,r3,r2
811019f8:	e0bfef15 	stw	r2,-68(fp)
	if (bSuccess) {
811019fc:	e0bfed17 	ldw	r2,-76(fp)
81101a00:	10001e26 	beq	r2,zero,81101a7c <bDdr2MemoryWriteTest+0x4f8>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101a04:	e13fef17 	ldw	r4,-68(fp)
81101a08:	111bc540 	call	8111bc54 <__floatsisf>
81101a0c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101a10:	d0a08417 	ldw	r2,-32240(gp)
81101a14:	1009883a 	mov	r4,r2
81101a18:	111bd800 	call	8111bd80 <__floatunsisf>
81101a1c:	1007883a 	mov	r3,r2
81101a20:	180b883a 	mov	r5,r3
81101a24:	8009883a 	mov	r4,r16
81101a28:	111b4080 	call	8111b408 <__divsf3>
81101a2c:	1007883a 	mov	r3,r2
81101a30:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101a34:	1009883a 	mov	r4,r2
81101a38:	111c5980 	call	8111c598 <__extendsfdf2>
81101a3c:	1009883a 	mov	r4,r2
81101a40:	180b883a 	mov	r5,r3
81101a44:	d9400015 	stw	r5,0(sp)
81101a48:	200f883a 	mov	r7,r4
81101a4c:	e1bfe617 	ldw	r6,-104(fp)
81101a50:	01604534 	movhi	r5,33044
81101a54:	295f4a04 	addi	r5,r5,32040
81101a58:	01204574 	movhi	r4,33045
81101a5c:	213b8b04 	addi	r4,r4,-4564
81101a60:	111e3a80 	call	8111e3a8 <sprintf>
				"DDR2 write test pass, size=%lu bytes, %.3f sec\n", uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101a64:	d0a05e17 	ldw	r2,-32392(gp)
81101a68:	01604574 	movhi	r5,33045
81101a6c:	297b8b04 	addi	r5,r5,-4564
81101a70:	1009883a 	mov	r4,r2
81101a74:	111ca180 	call	8111ca18 <fprintf>
81101a78:	00000f06 	br	81101ab8 <bDdr2MemoryWriteTest+0x534>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
81101a7c:	00e04574 	movhi	r3,33045
81101a80:	18fb8b04 	addi	r3,r3,-4564
81101a84:	00a04534 	movhi	r2,33044
81101a88:	109f5604 	addi	r2,r2,32088
81101a8c:	1009883a 	mov	r4,r2
81101a90:	00800584 	movi	r2,22
81101a94:	100d883a 	mov	r6,r2
81101a98:	200b883a 	mov	r5,r4
81101a9c:	1809883a 	mov	r4,r3
81101aa0:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81101aa4:	d0a05e17 	ldw	r2,-32392(gp)
81101aa8:	01604574 	movhi	r5,33045
81101aac:	297b8b04 	addi	r5,r5,-4564
81101ab0:	1009883a 	mov	r4,r2
81101ab4:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ab8:	00a04574 	movhi	r2,33045
81101abc:	10bb8b04 	addi	r2,r2,-4564
81101ac0:	00c00284 	movi	r3,10
81101ac4:	10c00005 	stb	r3,0(r2)
81101ac8:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101acc:	d0a05e17 	ldw	r2,-32392(gp)
81101ad0:	01604574 	movhi	r5,33045
81101ad4:	297b8b04 	addi	r5,r5,-4564
81101ad8:	1009883a 	mov	r4,r2
81101adc:	111ca180 	call	8111ca18 <fprintf>
#endif

	return bSuccess;
81101ae0:	e0bfed17 	ldw	r2,-76(fp)
}
81101ae4:	e6fffe04 	addi	sp,fp,-8
81101ae8:	dfc00317 	ldw	ra,12(sp)
81101aec:	df000217 	ldw	fp,8(sp)
81101af0:	dc400117 	ldw	r17,4(sp)
81101af4:	dc000017 	ldw	r16,0(sp)
81101af8:	dec00404 	addi	sp,sp,16
81101afc:	f800283a 	ret

81101b00 <bDdr2MemoryReadTest>:
 * @param [in] MemoryId  ID da mmoria a ser testada
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryReadTest(alt_u8 ucMemoryId) {
81101b00:	deffe204 	addi	sp,sp,-120
81101b04:	de00012e 	bgeu	sp,et,81101b0c <bDdr2MemoryReadTest+0xc>
81101b08:	003b68fa 	trap	3
81101b0c:	dfc01d15 	stw	ra,116(sp)
81101b10:	df001c15 	stw	fp,112(sp)
81101b14:	dc401b15 	stw	r17,108(sp)
81101b18:	dc001a15 	stw	r16,104(sp)
81101b1c:	df001c04 	addi	fp,sp,112
81101b20:	2005883a 	mov	r2,r4
81101b24:	e0bffd05 	stb	r2,-12(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Read Test =====\n");
81101b28:	00e04574 	movhi	r3,33045
81101b2c:	18fb8b04 	addi	r3,r3,-4564
81101b30:	00a04534 	movhi	r2,33044
81101b34:	109f5c04 	addi	r2,r2,32112
81101b38:	1009883a 	mov	r4,r2
81101b3c:	008009c4 	movi	r2,39
81101b40:	100d883a 	mov	r6,r2
81101b44:	200b883a 	mov	r5,r4
81101b48:	1809883a 	mov	r4,r3
81101b4c:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81101b50:	d0a05e17 	ldw	r2,-32392(gp)
81101b54:	01604574 	movhi	r5,33045
81101b58:	297b8b04 	addi	r5,r5,-4564
81101b5c:	1009883a 	mov	r4,r2
81101b60:	111ca180 	call	8111ca18 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81101b64:	00800044 	movi	r2,1
81101b68:	e0bfe515 	stw	r2,-108(fp)
	switch (ucMemoryId) {
81101b6c:	e0bffd03 	ldbu	r2,-12(fp)
81101b70:	10000326 	beq	r2,zero,81101b80 <bDdr2MemoryReadTest+0x80>
81101b74:	10800060 	cmpeqi	r2,r2,1
81101b78:	1000081e 	bne	r2,zero,81101b9c <bDdr2MemoryReadTest+0x9c>
81101b7c:	00000e06 	br	81101bb8 <bDdr2MemoryReadTest+0xb8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b80:	e0bffd03 	ldbu	r2,-12(fp)
81101b84:	1009883a 	mov	r4,r2
81101b88:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101b8c:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81101b90:	00a00034 	movhi	r2,32768
81101b94:	e0bfe715 	stw	r2,-100(fp)
		break;
81101b98:	00001906 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81101b9c:	e0bffd03 	ldbu	r2,-12(fp)
81101ba0:	1009883a 	mov	r4,r2
81101ba4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81101ba8:	e03fe615 	stw	zero,-104(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81101bac:	00a00034 	movhi	r2,32768
81101bb0:	e0bfe715 	stw	r2,-100(fp)
		break;
81101bb4:	00001206 	br	81101c00 <bDdr2MemoryReadTest+0x100>
	default:
		bSuccess = FALSE;
81101bb8:	e03fe515 	stw	zero,-108(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81101bbc:	00e04574 	movhi	r3,33045
81101bc0:	18fb8b04 	addi	r3,r3,-4564
81101bc4:	00a04534 	movhi	r2,33044
81101bc8:	109d4404 	addi	r2,r2,29968
81101bcc:	1009883a 	mov	r4,r2
81101bd0:	00800bc4 	movi	r2,47
81101bd4:	100d883a 	mov	r6,r2
81101bd8:	200b883a 	mov	r5,r4
81101bdc:	1809883a 	mov	r4,r3
81101be0:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81101be4:	d0a05e17 	ldw	r2,-32392(gp)
81101be8:	01604574 	movhi	r5,33045
81101bec:	297b8b04 	addi	r5,r5,-4564
81101bf0:	1009883a 	mov	r4,r2
81101bf4:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
		return bSuccess;
81101bf8:	e0bfe517 	ldw	r2,-108(fp)
81101bfc:	0000fc06 	br	81101ff0 <bDdr2MemoryReadTest+0x4f0>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %lu MBytes\n", uliByteLen / 1024 / 1024);
81101c00:	e0bfe717 	ldw	r2,-100(fp)
81101c04:	1004d53a 	srli	r2,r2,20
81101c08:	100d883a 	mov	r6,r2
81101c0c:	01604534 	movhi	r5,33044
81101c10:	295f6604 	addi	r5,r5,32152
81101c14:	01204574 	movhi	r4,33045
81101c18:	213b8b04 	addi	r4,r4,-4564
81101c1c:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
81101c20:	d0a05e17 	ldw	r2,-32392(gp)
81101c24:	01604574 	movhi	r5,33045
81101c28:	297b8b04 	addi	r5,r5,-4564
81101c2c:	1009883a 	mov	r4,r2
81101c30:	111ca180 	call	8111ca18 <fprintf>
#endif

	int iI, iNRemainedLen, iNAccessLen;
	TMyData *pxDes, *pxSrc;
	int iNItemNum, iNPos;
	iNItemNum = sizeof(xSZData) / sizeof(xSZData[0]);
81101c34:	00804004 	movi	r2,256
81101c38:	e0bfec15 	stw	r2,-80(fp)
	const int ciMyDataSize = sizeof(TMyData);
81101c3c:	00800104 	movi	r2,4
81101c40:	e0bfef15 	stw	r2,-68(fp)
	iNAccessLen = iNItemNum * ciMyDataSize;
81101c44:	e0ffec17 	ldw	r3,-80(fp)
81101c48:	e0bfef17 	ldw	r2,-68(fp)
81101c4c:	1885383a 	mul	r2,r3,r2
81101c50:	e0bfe915 	stw	r2,-92(fp)
	int iNProgressIndex = 0;
81101c54:	e03fee15 	stw	zero,-72(fp)
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;
81101c58:	e03ff015 	stw	zero,-64(fp)

	for (iI = 0; iI < 10; iI++) {
81101c5c:	e03fe815 	stw	zero,-96(fp)
81101c60:	00001506 	br	81101cb8 <bDdr2MemoryReadTest+0x1b8>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
81101c64:	e0ffe717 	ldw	r3,-100(fp)
81101c68:	00b33374 	movhi	r2,52429
81101c6c:	10b33344 	addi	r2,r2,-13107
81101c70:	1888383a 	mulxuu	r4,r3,r2
81101c74:	1885383a 	mul	r2,r3,r2
81101c78:	1021883a 	mov	r16,r2
81101c7c:	2023883a 	mov	r17,r4
81101c80:	8804d0fa 	srli	r2,r17,3
81101c84:	e0ffe817 	ldw	r3,-96(fp)
81101c88:	18c00044 	addi	r3,r3,1
81101c8c:	10c7383a 	mul	r3,r2,r3
81101c90:	e0bfe817 	ldw	r2,-96(fp)
81101c94:	1085883a 	add	r2,r2,r2
81101c98:	1085883a 	add	r2,r2,r2
81101c9c:	e13fe504 	addi	r4,fp,-108
81101ca0:	2085883a 	add	r2,r4,r2
81101ca4:	10800e04 	addi	r2,r2,56
81101ca8:	10c00015 	stw	r3,0(r2)
	iNAccessLen = iNItemNum * ciMyDataSize;
	int iNProgressIndex = 0;
	alt_u32 uliSZProgress[10];
	int iTimeStart, iTimeElapsed = 0;

	for (iI = 0; iI < 10; iI++) {
81101cac:	e0bfe817 	ldw	r2,-96(fp)
81101cb0:	10800044 	addi	r2,r2,1
81101cb4:	e0bfe815 	stw	r2,-96(fp)
81101cb8:	e0bfe817 	ldw	r2,-96(fp)
81101cbc:	10800290 	cmplti	r2,r2,10
81101cc0:	103fe81e 	bne	r2,zero,81101c64 <__reset+0xfb0e1c64>
		uliSZProgress[iI] = uliByteLen / 10 * (iI + 1);
	}

	iNProgressIndex = 0;
81101cc4:	e03fee15 	stw	zero,-72(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading/Verifying Data...\n");
81101cc8:	00e04574 	movhi	r3,33045
81101ccc:	18fb8b04 	addi	r3,r3,-4564
81101cd0:	00a04534 	movhi	r2,33044
81101cd4:	109f6c04 	addi	r2,r2,32176
81101cd8:	1009883a 	mov	r4,r2
81101cdc:	008006c4 	movi	r2,27
81101ce0:	100d883a 	mov	r6,r2
81101ce4:	200b883a 	mov	r5,r4
81101ce8:	1809883a 	mov	r4,r3
81101cec:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81101cf0:	d0a05e17 	ldw	r2,-32392(gp)
81101cf4:	01604574 	movhi	r5,33045
81101cf8:	297b8b04 	addi	r5,r5,-4564
81101cfc:	1009883a 	mov	r4,r2
81101d00:	111ca180 	call	8111ca18 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81101d04:	d0a08517 	ldw	r2,-32236(gp)
#endif
	iTimeStart = alt_nticks();
81101d08:	e0bff115 	stw	r2,-60(fp)

	pxSrc = (TMyData *) uliDdr2Base;
81101d0c:	e0bfe617 	ldw	r2,-104(fp)
81101d10:	e0bfeb15 	stw	r2,-84(fp)
	iNAccessLen = sizeof(xSZData);
81101d14:	00810004 	movi	r2,1024
81101d18:	e0bfe915 	stw	r2,-92(fp)
	iNItemNum = iNAccessLen / ciMyDataSize;
81101d1c:	e0ffe917 	ldw	r3,-92(fp)
81101d20:	e0bfef17 	ldw	r2,-68(fp)
81101d24:	1885283a 	div	r2,r3,r2
81101d28:	e0bfec15 	stw	r2,-80(fp)
	iNPos = 0;
81101d2c:	e03fed15 	stw	zero,-76(fp)
	while (bSuccess && iNPos < uliByteLen) {
81101d30:	00006206 	br	81101ebc <bDdr2MemoryReadTest+0x3bc>
		iNRemainedLen = uliByteLen - iNPos;
81101d34:	e0bfed17 	ldw	r2,-76(fp)
81101d38:	e0ffe717 	ldw	r3,-100(fp)
81101d3c:	1885c83a 	sub	r2,r3,r2
81101d40:	e0bff215 	stw	r2,-56(fp)
		if (iNAccessLen > iNRemainedLen) {
81101d44:	e0bfe917 	ldw	r2,-92(fp)
81101d48:	e0fff217 	ldw	r3,-56(fp)
81101d4c:	1880060e 	bge	r3,r2,81101d68 <bDdr2MemoryReadTest+0x268>
			iNAccessLen = iNRemainedLen;
81101d50:	e0bff217 	ldw	r2,-56(fp)
81101d54:	e0bfe915 	stw	r2,-92(fp)
			iNItemNum = iNAccessLen / ciMyDataSize;
81101d58:	e0ffe917 	ldw	r3,-92(fp)
81101d5c:	e0bfef17 	ldw	r2,-68(fp)
81101d60:	1885283a 	div	r2,r3,r2
81101d64:	e0bfec15 	stw	r2,-80(fp)
		}
		pxDes = xSZData;
81101d68:	00a04574 	movhi	r2,33045
81101d6c:	10bbcb04 	addi	r2,r2,-4308
81101d70:	e0bfea15 	stw	r2,-88(fp)
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101d74:	e03fe815 	stw	zero,-96(fp)
81101d78:	00002b06 	br	81101e28 <bDdr2MemoryReadTest+0x328>
			if (*pxSrc++ != *pxDes++) {
81101d7c:	e0bfeb17 	ldw	r2,-84(fp)
81101d80:	10c00104 	addi	r3,r2,4
81101d84:	e0ffeb15 	stw	r3,-84(fp)
81101d88:	10c00017 	ldw	r3,0(r2)
81101d8c:	e0bfea17 	ldw	r2,-88(fp)
81101d90:	11000104 	addi	r4,r2,4
81101d94:	e13fea15 	stw	r4,-88(fp)
81101d98:	10800017 	ldw	r2,0(r2)
81101d9c:	18801f26 	beq	r3,r2,81101e1c <bDdr2MemoryReadTest+0x31c>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101da0:	e0bfeb17 	ldw	r2,-84(fp)
81101da4:	10bfff04 	addi	r2,r2,-4
81101da8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dac:	1009883a 	mov	r4,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
81101db0:	00a04574 	movhi	r2,33045
81101db4:	10bbcb04 	addi	r2,r2,-4308
81101db8:	e0ffe817 	ldw	r3,-96(fp)
81101dbc:	18c7883a 	add	r3,r3,r3
81101dc0:	18c7883a 	add	r3,r3,r3
81101dc4:	10c5883a 	add	r2,r2,r3
81101dc8:	10800017 	ldw	r2,0(r2)
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101dcc:	100b883a 	mov	r5,r2
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
81101dd0:	e0ffed17 	ldw	r3,-76(fp)
81101dd4:	e0bfef17 	ldw	r2,-68(fp)
81101dd8:	1887283a 	div	r3,r3,r2
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
			if (*pxSrc++ != *pxDes++) {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81101ddc:	e0bfe817 	ldw	r2,-96(fp)
81101de0:	1885883a 	add	r2,r3,r2
81101de4:	d8800015 	stw	r2,0(sp)
81101de8:	280f883a 	mov	r7,r5
81101dec:	200d883a 	mov	r6,r4
81101df0:	01604534 	movhi	r5,33044
81101df4:	295f7304 	addi	r5,r5,32204
81101df8:	01204574 	movhi	r4,33045
81101dfc:	213b8b04 	addi	r4,r4,-4564
81101e00:	111e3a80 	call	8111e3a8 <sprintf>
						"verify ng, read=%08Xh, expected=%08Xh, WordIndex=%Xh\n",
						(int) *(pxSrc - 1), (int) xSZData[iI],
						(iNPos / ciMyDataSize) + iI);
				debug(fp, cDebugBuffer);
81101e04:	d0a05e17 	ldw	r2,-32392(gp)
81101e08:	01604574 	movhi	r5,33045
81101e0c:	297b8b04 	addi	r5,r5,-4564
81101e10:	1009883a 	mov	r4,r2
81101e14:	111ca180 	call	8111ca18 <fprintf>
#endif
				bSuccess = FALSE;
81101e18:	e03fe515 	stw	zero,-108(fp)
		if (iNAccessLen > iNRemainedLen) {
			iNAccessLen = iNRemainedLen;
			iNItemNum = iNAccessLen / ciMyDataSize;
		}
		pxDes = xSZData;
		for (iI = 0; iI < iNItemNum && bSuccess; iI++) {
81101e1c:	e0bfe817 	ldw	r2,-96(fp)
81101e20:	10800044 	addi	r2,r2,1
81101e24:	e0bfe815 	stw	r2,-96(fp)
81101e28:	e0ffe817 	ldw	r3,-96(fp)
81101e2c:	e0bfec17 	ldw	r2,-80(fp)
81101e30:	1880020e 	bge	r3,r2,81101e3c <bDdr2MemoryReadTest+0x33c>
81101e34:	e0bfe517 	ldw	r2,-108(fp)
81101e38:	103fd01e 	bne	r2,zero,81101d7c <__reset+0xfb0e1d7c>
				debug(fp, cDebugBuffer);
#endif
				bSuccess = FALSE;
			}
		}
		iNPos += iNAccessLen;
81101e3c:	e0ffed17 	ldw	r3,-76(fp)
81101e40:	e0bfe917 	ldw	r2,-92(fp)
81101e44:	1885883a 	add	r2,r3,r2
81101e48:	e0bfed15 	stw	r2,-76(fp)
		if (iNProgressIndex <= 9 && iNPos >= uliSZProgress[iNProgressIndex]) {
81101e4c:	e0bfee17 	ldw	r2,-72(fp)
81101e50:	10800288 	cmpgei	r2,r2,10
81101e54:	1000191e 	bne	r2,zero,81101ebc <bDdr2MemoryReadTest+0x3bc>
81101e58:	e0bfee17 	ldw	r2,-72(fp)
81101e5c:	1085883a 	add	r2,r2,r2
81101e60:	1085883a 	add	r2,r2,r2
81101e64:	e0ffe504 	addi	r3,fp,-108
81101e68:	1885883a 	add	r2,r3,r2
81101e6c:	10800e04 	addi	r2,r2,56
81101e70:	10800017 	ldw	r2,0(r2)
81101e74:	e0ffed17 	ldw	r3,-76(fp)
81101e78:	18801036 	bltu	r3,r2,81101ebc <bDdr2MemoryReadTest+0x3bc>
			iNProgressIndex++;
81101e7c:	e0bfee17 	ldw	r2,-72(fp)
81101e80:	10800044 	addi	r2,r2,1
81101e84:	e0bfee15 	stw	r2,-72(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "%02d%% ", iNProgressIndex * 10);
81101e88:	e0bfee17 	ldw	r2,-72(fp)
81101e8c:	108002a4 	muli	r2,r2,10
81101e90:	100d883a 	mov	r6,r2
81101e94:	01604534 	movhi	r5,33044
81101e98:	295f4804 	addi	r5,r5,32032
81101e9c:	01204574 	movhi	r4,33045
81101ea0:	213b8b04 	addi	r4,r4,-4564
81101ea4:	111e3a80 	call	8111e3a8 <sprintf>
			debug(fp, cDebugBuffer);
81101ea8:	d0a05e17 	ldw	r2,-32392(gp)
81101eac:	01604574 	movhi	r5,33045
81101eb0:	297b8b04 	addi	r5,r5,-4564
81101eb4:	1009883a 	mov	r4,r2
81101eb8:	111ca180 	call	8111ca18 <fprintf>

	pxSrc = (TMyData *) uliDdr2Base;
	iNAccessLen = sizeof(xSZData);
	iNItemNum = iNAccessLen / ciMyDataSize;
	iNPos = 0;
	while (bSuccess && iNPos < uliByteLen) {
81101ebc:	e0bfe517 	ldw	r2,-108(fp)
81101ec0:	10000326 	beq	r2,zero,81101ed0 <bDdr2MemoryReadTest+0x3d0>
81101ec4:	e0ffed17 	ldw	r3,-76(fp)
81101ec8:	e0bfe717 	ldw	r2,-100(fp)
81101ecc:	18bf9936 	bltu	r3,r2,81101d34 <__reset+0xfb0e1d34>
			debug(fp, cDebugBuffer);
#endif
		}
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101ed0:	00a04574 	movhi	r2,33045
81101ed4:	10bb8b04 	addi	r2,r2,-4564
81101ed8:	00c00284 	movi	r3,10
81101edc:	10c00005 	stb	r3,0(r2)
81101ee0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101ee4:	d0a05e17 	ldw	r2,-32392(gp)
81101ee8:	01604574 	movhi	r5,33045
81101eec:	297b8b04 	addi	r5,r5,-4564
81101ef0:	1009883a 	mov	r4,r2
81101ef4:	111ca180 	call	8111ca18 <fprintf>
81101ef8:	d0e08517 	ldw	r3,-32236(gp)
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
81101efc:	e0bff117 	ldw	r2,-60(fp)
81101f00:	1885c83a 	sub	r2,r3,r2
81101f04:	e0bff015 	stw	r2,-64(fp)
	if (bSuccess) {
81101f08:	e0bfe517 	ldw	r2,-108(fp)
81101f0c:	10001e26 	beq	r2,zero,81101f88 <bDdr2MemoryReadTest+0x488>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
81101f10:	e13ff017 	ldw	r4,-64(fp)
81101f14:	111bc540 	call	8111bc54 <__floatsisf>
81101f18:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81101f1c:	d0a08417 	ldw	r2,-32240(gp)
81101f20:	1009883a 	mov	r4,r2
81101f24:	111bd800 	call	8111bd80 <__floatunsisf>
81101f28:	1007883a 	mov	r3,r2
81101f2c:	180b883a 	mov	r5,r3
81101f30:	8009883a 	mov	r4,r16
81101f34:	111b4080 	call	8111b408 <__divsf3>
81101f38:	1007883a 	mov	r3,r2
81101f3c:	1805883a 	mov	r2,r3
#endif

	iTimeElapsed = alt_nticks() - iTimeStart;
	if (bSuccess) {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test pass, size=%ld bytes, %.3f sec\n",
81101f40:	1009883a 	mov	r4,r2
81101f44:	111c5980 	call	8111c598 <__extendsfdf2>
81101f48:	1009883a 	mov	r4,r2
81101f4c:	180b883a 	mov	r5,r3
81101f50:	d9400015 	stw	r5,0(sp)
81101f54:	200f883a 	mov	r7,r4
81101f58:	e1bfe717 	ldw	r6,-100(fp)
81101f5c:	01604534 	movhi	r5,33044
81101f60:	295f8104 	addi	r5,r5,32260
81101f64:	01204574 	movhi	r4,33045
81101f68:	213b8b04 	addi	r4,r4,-4564
81101f6c:	111e3a80 	call	8111e3a8 <sprintf>
				uliByteLen,
				(float) iTimeElapsed / (float) alt_ticks_per_second());
		debug(fp, cDebugBuffer);
81101f70:	d0a05e17 	ldw	r2,-32392(gp)
81101f74:	01604574 	movhi	r5,33045
81101f78:	297b8b04 	addi	r5,r5,-4564
81101f7c:	1009883a 	mov	r4,r2
81101f80:	111ca180 	call	8111ca18 <fprintf>
81101f84:	00000f06 	br	81101fc4 <bDdr2MemoryReadTest+0x4c4>
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81101f88:	00e04574 	movhi	r3,33045
81101f8c:	18fb8b04 	addi	r3,r3,-4564
81101f90:	00a04534 	movhi	r2,33044
81101f94:	109f8d04 	addi	r2,r2,32308
81101f98:	1009883a 	mov	r4,r2
81101f9c:	00800544 	movi	r2,21
81101fa0:	100d883a 	mov	r6,r2
81101fa4:	200b883a 	mov	r5,r4
81101fa8:	1809883a 	mov	r4,r3
81101fac:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81101fb0:	d0a05e17 	ldw	r2,-32392(gp)
81101fb4:	01604574 	movhi	r5,33045
81101fb8:	297b8b04 	addi	r5,r5,-4564
81101fbc:	1009883a 	mov	r4,r2
81101fc0:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81101fc4:	00a04574 	movhi	r2,33045
81101fc8:	10bb8b04 	addi	r2,r2,-4564
81101fcc:	00c00284 	movi	r3,10
81101fd0:	10c00005 	stb	r3,0(r2)
81101fd4:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
81101fd8:	d0a05e17 	ldw	r2,-32392(gp)
81101fdc:	01604574 	movhi	r5,33045
81101fe0:	297b8b04 	addi	r5,r5,-4564
81101fe4:	1009883a 	mov	r4,r2
81101fe8:	111ca180 	call	8111ca18 <fprintf>
#endif

	return bSuccess;
81101fec:	e0bfe517 	ldw	r2,-108(fp)
}
81101ff0:	e6fffe04 	addi	sp,fp,-8
81101ff4:	dfc00317 	ldw	ra,12(sp)
81101ff8:	df000217 	ldw	fp,8(sp)
81101ffc:	dc400117 	ldw	r17,4(sp)
81102000:	dc000017 	ldw	r16,0(sp)
81102004:	dec00404 	addi	sp,sp,16
81102008:	f800283a 	ret

8110200c <bDdr2MemoryRandomWriteTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomWriteTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
8110200c:	deffec04 	addi	sp,sp,-80
81102010:	de00012e 	bgeu	sp,et,81102018 <bDdr2MemoryRandomWriteTest+0xc>
81102014:	003b68fa 	trap	3
81102018:	dfc01315 	stw	ra,76(sp)
8110201c:	df001215 	stw	fp,72(sp)
81102020:	dcc01115 	stw	r19,68(sp)
81102024:	dc801015 	stw	r18,64(sp)
81102028:	dc400f15 	stw	r17,60(sp)
8110202c:	dc000e15 	stw	r16,56(sp)
81102030:	df001204 	addi	fp,sp,72
81102034:	2005883a 	mov	r2,r4
81102038:	e17ffa15 	stw	r5,-24(fp)
8110203c:	e1bffb15 	stw	r6,-20(fp)
81102040:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Write Test =====\n");
81102044:	00e04574 	movhi	r3,33045
81102048:	18fb8b04 	addi	r3,r3,-4564
8110204c:	00a04534 	movhi	r2,33044
81102050:	109f9304 	addi	r2,r2,32332
81102054:	1009883a 	mov	r4,r2
81102058:	00800bc4 	movi	r2,47
8110205c:	100d883a 	mov	r6,r2
81102060:	200b883a 	mov	r5,r4
81102064:	1809883a 	mov	r4,r3
81102068:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
8110206c:	d0a05e17 	ldw	r2,-32392(gp)
81102070:	01604574 	movhi	r5,33045
81102074:	297b8b04 	addi	r5,r5,-4564
81102078:	1009883a 	mov	r4,r2
8110207c:	111ca180 	call	8111ca18 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
81102080:	00800044 	movi	r2,1
81102084:	e0bff415 	stw	r2,-48(fp)
	switch (ucMemoryId) {
81102088:	e0bff903 	ldbu	r2,-28(fp)
8110208c:	10000326 	beq	r2,zero,8110209c <bDdr2MemoryRandomWriteTest+0x90>
81102090:	10800060 	cmpeqi	r2,r2,1
81102094:	1000081e 	bne	r2,zero,811020b8 <bDdr2MemoryRandomWriteTest+0xac>
81102098:	00000e06 	br	811020d4 <bDdr2MemoryRandomWriteTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
8110209c:	e0bff903 	ldbu	r2,-28(fp)
811020a0:	1009883a 	mov	r4,r2
811020a4:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020a8:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
811020ac:	00a00034 	movhi	r2,32768
811020b0:	e0bff015 	stw	r2,-64(fp)
		break;
811020b4:	00001906 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
811020b8:	e0bff903 	ldbu	r2,-28(fp)
811020bc:	1009883a 	mov	r4,r2
811020c0:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
811020c4:	e03fef15 	stw	zero,-68(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
811020c8:	00a00034 	movhi	r2,32768
811020cc:	e0bff015 	stw	r2,-64(fp)
		break;
811020d0:	00001206 	br	8110211c <bDdr2MemoryRandomWriteTest+0x110>
	default:
		bSuccess = FALSE;
811020d4:	e03ff415 	stw	zero,-48(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
811020d8:	00e04574 	movhi	r3,33045
811020dc:	18fb8b04 	addi	r3,r3,-4564
811020e0:	00a04534 	movhi	r2,33044
811020e4:	109d4404 	addi	r2,r2,29968
811020e8:	1009883a 	mov	r4,r2
811020ec:	00800bc4 	movi	r2,47
811020f0:	100d883a 	mov	r6,r2
811020f4:	200b883a 	mov	r5,r4
811020f8:	1809883a 	mov	r4,r3
811020fc:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
81102100:	d0a05e17 	ldw	r2,-32392(gp)
81102104:	01604574 	movhi	r5,33045
81102108:	297b8b04 	addi	r5,r5,-4564
8110210c:	1009883a 	mov	r4,r2
81102110:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
		return bSuccess;
81102114:	e0bff417 	ldw	r2,-48(fp)
81102118:	0000ce06 	br	81102454 <bDdr2MemoryRandomWriteTest+0x448>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
8110211c:	e0bff017 	ldw	r2,-64(fp)
81102120:	1004d53a 	srli	r2,r2,20
81102124:	100d883a 	mov	r6,r2
81102128:	01604534 	movhi	r5,33044
8110212c:	295f3d04 	addi	r5,r5,31988
81102130:	01204574 	movhi	r4,33045
81102134:	213b8b04 	addi	r4,r4,-4564
81102138:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
8110213c:	d0a05e17 	ldw	r2,-32392(gp)
81102140:	01604574 	movhi	r5,33045
81102144:	297b8b04 	addi	r5,r5,-4564
81102148:	1009883a 	mov	r4,r2
8110214c:	111ca180 	call	8111ca18 <fprintf>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81102150:	d0a08517 	ldw	r2,-32236(gp)
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliInitialState = alt_nticks();
81102154:	d0a03715 	stw	r2,-32548(gp)
	uliCurrentState = uliInitialState;
81102158:	d0a03717 	ldw	r2,-32548(gp)
8110215c:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
81102160:	e0ffef17 	ldw	r3,-68(fp)
81102164:	e0bff017 	ldw	r2,-64(fp)
81102168:	1885883a 	add	r2,r3,r2
8110216c:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
81102170:	e0fff017 	ldw	r3,-64(fp)
81102174:	00b33374 	movhi	r2,52429
81102178:	10b33344 	addi	r2,r2,-13107
8110217c:	1888383a 	mulxuu	r4,r3,r2
81102180:	1885383a 	mul	r2,r3,r2
81102184:	1025883a 	mov	r18,r2
81102188:	2027883a 	mov	r19,r4
8110218c:	9806d13a 	srli	r3,r19,4
81102190:	e0bfef17 	ldw	r2,-68(fp)
81102194:	1885883a 	add	r2,r3,r2
81102198:	e0bff215 	stw	r2,-56(fp)
	ucPercentage = 5;
8110219c:	00800144 	movi	r2,5
811021a0:	e0bff305 	stb	r2,-52(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Writing to memory...\n");
811021a4:	00e04574 	movhi	r3,33045
811021a8:	18fb8b04 	addi	r3,r3,-4564
811021ac:	00a04534 	movhi	r2,33044
811021b0:	109f9f04 	addi	r2,r2,32380
811021b4:	1009883a 	mov	r4,r2
811021b8:	00800584 	movi	r2,22
811021bc:	100d883a 	mov	r6,r2
811021c0:	200b883a 	mov	r5,r4
811021c4:	1809883a 	mov	r4,r3
811021c8:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
811021cc:	d0a05e17 	ldw	r2,-32392(gp)
811021d0:	01604574 	movhi	r5,33045
811021d4:	297b8b04 	addi	r5,r5,-4564
811021d8:	1009883a 	mov	r4,r2
811021dc:	111ca180 	call	8111ca18 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
811021e0:	e0bffa17 	ldw	r2,-24(fp)
811021e4:	10800058 	cmpnei	r2,r2,1
811021e8:	10000a1e 	bne	r2,zero,81102214 <bDdr2MemoryRandomWriteTest+0x208>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
811021ec:	01604534 	movhi	r5,33044
811021f0:	295fa504 	addi	r5,r5,32404
811021f4:	01204574 	movhi	r4,33045
811021f8:	213b8b04 	addi	r4,r4,-4564
811021fc:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, cDebugBuffer);
81102200:	d0a05e17 	ldw	r2,-32392(gp)
81102204:	01604574 	movhi	r5,33045
81102208:	297b8b04 	addi	r5,r5,-4564
8110220c:	1009883a 	mov	r4,r2
81102210:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
	int TimeStart, TimeElapsed = 0;
81102214:	e03ff615 	stw	zero,-40(fp)
81102218:	d0a08517 	ldw	r2,-32236(gp)

	TimeStart = alt_nticks();
8110221c:	e0bff715 	stw	r2,-36(fp)
	for (puliDestination = (alt_u32*) uliDdr2Base;
81102220:	e0bfef17 	ldw	r2,-68(fp)
81102224:	e0bff115 	stw	r2,-60(fp)
81102228:	00002c06 	br	811022dc <bDdr2MemoryRandomWriteTest+0x2d0>
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
8110222c:	e0bff804 	addi	r2,fp,-32
81102230:	1009883a 	mov	r4,r2
81102234:	11029100 	call	81102910 <uliXorshift32>
81102238:	1007883a 	mov	r3,r2
8110223c:	e0bff117 	ldw	r2,-60(fp)
81102240:	10c00015 	stw	r3,0(r2)
		if ((bVerbose == DDR2_VERBOSE)
				& ((alt_u32) puliDestination > uliNextMilestone)) {
81102244:	e0bffa17 	ldw	r2,-24(fp)
81102248:	10800060 	cmpeqi	r2,r2,1
8110224c:	1009883a 	mov	r4,r2
81102250:	e0bff117 	ldw	r2,-60(fp)
81102254:	e0fff217 	ldw	r3,-56(fp)
81102258:	1885803a 	cmpltu	r2,r3,r2
8110225c:	2084703a 	and	r2,r4,r2
	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
		*puliDestination = uliXorshift32(&uliCurrentState);
		if ((bVerbose == DDR2_VERBOSE)
81102260:	10803fcc 	andi	r2,r2,255
81102264:	10001a26 	beq	r2,zero,811022d0 <bDdr2MemoryRandomWriteTest+0x2c4>
				& ((alt_u32) puliDestination > uliNextMilestone)) {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102268:	e0bff303 	ldbu	r2,-52(fp)
8110226c:	100d883a 	mov	r6,r2
81102270:	01604534 	movhi	r5,33044
81102274:	295fa704 	addi	r5,r5,32412
81102278:	01204574 	movhi	r4,33045
8110227c:	213b8b04 	addi	r4,r4,-4564
81102280:	111e3a80 	call	8111e3a8 <sprintf>
			debug(fp, cDebugBuffer);
81102284:	d0a05e17 	ldw	r2,-32392(gp)
81102288:	01604574 	movhi	r5,33045
8110228c:	297b8b04 	addi	r5,r5,-4564
81102290:	1009883a 	mov	r4,r2
81102294:	111ca180 	call	8111ca18 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102298:	e0fff017 	ldw	r3,-64(fp)
8110229c:	00b33374 	movhi	r2,52429
811022a0:	10b33344 	addi	r2,r2,-13107
811022a4:	1888383a 	mulxuu	r4,r3,r2
811022a8:	1885383a 	mul	r2,r3,r2
811022ac:	1021883a 	mov	r16,r2
811022b0:	2023883a 	mov	r17,r4
811022b4:	8804d13a 	srli	r2,r17,4
811022b8:	e0fff217 	ldw	r3,-56(fp)
811022bc:	1885883a 	add	r2,r3,r2
811022c0:	e0bff215 	stw	r2,-56(fp)
			ucPercentage += 5;
811022c4:	e0bff303 	ldbu	r2,-52(fp)
811022c8:	10800144 	addi	r2,r2,5
811022cc:	e0bff305 	stb	r2,-52(fp)
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
			puliDestination++) {
811022d0:	e0bff117 	ldw	r2,-60(fp)
811022d4:	10800104 	addi	r2,r2,4
811022d8:	e0bff115 	stw	r2,-60(fp)
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
			(alt_u32) puliDestination < uliMemoryEndAddress;
811022dc:	e0fff117 	ldw	r3,-60(fp)
#endif
	}
	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliDestination = (alt_u32*) uliDdr2Base;
811022e0:	e0bff517 	ldw	r2,-44(fp)
811022e4:	18bfd136 	bltu	r3,r2,8110222c <__reset+0xfb0e222c>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	alt_dcache_flush_all();
811022e8:	11324c80 	call	811324c8 <alt_dcache_flush_all>
	if (bVerbose == DDR2_VERBOSE) {
811022ec:	e0bffa17 	ldw	r2,-24(fp)
811022f0:	10800058 	cmpnei	r2,r2,1
811022f4:	10000a1e 	bne	r2,zero,81102320 <bDdr2MemoryRandomWriteTest+0x314>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
811022f8:	01604534 	movhi	r5,33044
811022fc:	295faa04 	addi	r5,r5,32424
81102300:	01204574 	movhi	r4,33045
81102304:	213b8b04 	addi	r4,r4,-4564
81102308:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, cDebugBuffer);
8110230c:	d0a05e17 	ldw	r2,-32392(gp)
81102310:	01604574 	movhi	r5,33045
81102314:	297b8b04 	addi	r5,r5,-4564
81102318:	1009883a 	mov	r4,r2
8110231c:	111ca180 	call	8111ca18 <fprintf>
#endif
	}

	if (bSuccess) {
81102320:	e0bff417 	ldw	r2,-48(fp)
81102324:	10003126 	beq	r2,zero,811023ec <bDdr2MemoryRandomWriteTest+0x3e0>
		if (bTime == TRUE) {
81102328:	e0bffb17 	ldw	r2,-20(fp)
8110232c:	10800058 	cmpnei	r2,r2,1
81102330:	1000221e 	bne	r2,zero,811023bc <bDdr2MemoryRandomWriteTest+0x3b0>
81102334:	d0e08517 	ldw	r3,-32236(gp)
			TimeElapsed = alt_nticks() - TimeStart;
81102338:	e0bff717 	ldw	r2,-36(fp)
8110233c:	1885c83a 	sub	r2,r3,r2
81102340:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
81102344:	e13ff617 	ldw	r4,-40(fp)
81102348:	111bc540 	call	8111bc54 <__floatsisf>
8110234c:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81102350:	d0a08417 	ldw	r2,-32240(gp)
81102354:	1009883a 	mov	r4,r2
81102358:	111bd800 	call	8111bd80 <__floatunsisf>
8110235c:	1007883a 	mov	r3,r2
81102360:	180b883a 	mov	r5,r3
81102364:	8009883a 	mov	r4,r16
81102368:	111b4080 	call	8111b408 <__divsf3>
8110236c:	1007883a 	mov	r3,r2
81102370:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
81102374:	1009883a 	mov	r4,r2
81102378:	111c5980 	call	8111c598 <__extendsfdf2>
8110237c:	1009883a 	mov	r4,r2
81102380:	180b883a 	mov	r5,r3
81102384:	d9400015 	stw	r5,0(sp)
81102388:	200f883a 	mov	r7,r4
8110238c:	e1bff017 	ldw	r6,-64(fp)
81102390:	01604534 	movhi	r5,33044
81102394:	295fad04 	addi	r5,r5,32436
81102398:	01204574 	movhi	r4,33045
8110239c:	213b8b04 	addi	r4,r4,-4564
811023a0:	111e3a80 	call	8111e3a8 <sprintf>
					"DDR2 write test pass, size=%ld bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
811023a4:	d0a05e17 	ldw	r2,-32392(gp)
811023a8:	01604574 	movhi	r5,33045
811023ac:	297b8b04 	addi	r5,r5,-4564
811023b0:	1009883a 	mov	r4,r2
811023b4:	111ca180 	call	8111ca18 <fprintf>
811023b8:	00001b06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 write test pass, size=%ld bytes\n",
811023bc:	e1bff017 	ldw	r6,-64(fp)
811023c0:	01604534 	movhi	r5,33044
811023c4:	295fb904 	addi	r5,r5,32484
811023c8:	01204574 	movhi	r4,33045
811023cc:	213b8b04 	addi	r4,r4,-4564
811023d0:	111e3a80 	call	8111e3a8 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
811023d4:	d0a05e17 	ldw	r2,-32392(gp)
811023d8:	01604574 	movhi	r5,33045
811023dc:	297b8b04 	addi	r5,r5,-4564
811023e0:	1009883a 	mov	r4,r2
811023e4:	111ca180 	call	8111ca18 <fprintf>
811023e8:	00000f06 	br	81102428 <bDdr2MemoryRandomWriteTest+0x41c>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 write test fail\n");
811023ec:	00e04574 	movhi	r3,33045
811023f0:	18fb8b04 	addi	r3,r3,-4564
811023f4:	00a04534 	movhi	r2,33044
811023f8:	109f5604 	addi	r2,r2,32088
811023fc:	1009883a 	mov	r4,r2
81102400:	00800584 	movi	r2,22
81102404:	100d883a 	mov	r6,r2
81102408:	200b883a 	mov	r5,r4
8110240c:	1809883a 	mov	r4,r3
81102410:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
81102414:	d0a05e17 	ldw	r2,-32392(gp)
81102418:	01604574 	movhi	r5,33045
8110241c:	297b8b04 	addi	r5,r5,-4564
81102420:	1009883a 	mov	r4,r2
81102424:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
81102428:	00a04574 	movhi	r2,33045
8110242c:	10bb8b04 	addi	r2,r2,-4564
81102430:	00c00284 	movi	r3,10
81102434:	10c00005 	stb	r3,0(r2)
81102438:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
8110243c:	d0a05e17 	ldw	r2,-32392(gp)
81102440:	01604574 	movhi	r5,33045
81102444:	297b8b04 	addi	r5,r5,-4564
81102448:	1009883a 	mov	r4,r2
8110244c:	111ca180 	call	8111ca18 <fprintf>
#endif

	return bSuccess;
81102450:	e0bff417 	ldw	r2,-48(fp)
}
81102454:	e6fffc04 	addi	sp,fp,-16
81102458:	dfc00517 	ldw	ra,20(sp)
8110245c:	df000417 	ldw	fp,16(sp)
81102460:	dcc00317 	ldw	r19,12(sp)
81102464:	dc800217 	ldw	r18,8(sp)
81102468:	dc400117 	ldw	r17,4(sp)
8110246c:	dc000017 	ldw	r16,0(sp)
81102470:	dec00604 	addi	sp,sp,24
81102474:	f800283a 	ret

81102478 <bDdr2MemoryRandomReadTest>:
 * @param [in] bTime  Controla se a durao da funo ser medida
 *
 * @retval TRUE : Sucesso
 *
 */
bool bDdr2MemoryRandomReadTest(alt_u8 ucMemoryId, bool bVerbose, bool bTime) {
81102478:	deffec04 	addi	sp,sp,-80
8110247c:	de00012e 	bgeu	sp,et,81102484 <bDdr2MemoryRandomReadTest+0xc>
81102480:	003b68fa 	trap	3
81102484:	dfc01315 	stw	ra,76(sp)
81102488:	df001215 	stw	fp,72(sp)
8110248c:	dcc01115 	stw	r19,68(sp)
81102490:	dc801015 	stw	r18,64(sp)
81102494:	dc400f15 	stw	r17,60(sp)
81102498:	dc000e15 	stw	r16,56(sp)
8110249c:	df001204 	addi	fp,sp,72
811024a0:	2005883a 	mov	r2,r4
811024a4:	e17ffa15 	stw	r5,-24(fp)
811024a8:	e1bffb15 	stw	r6,-20(fp)
811024ac:	e0bff905 	stb	r2,-28(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "===== DE4 DDR2 Memory Random Read Test =====\n");
811024b0:	00e04574 	movhi	r3,33045
811024b4:	18fb8b04 	addi	r3,r3,-4564
811024b8:	00a04534 	movhi	r2,33044
811024bc:	109fc304 	addi	r2,r2,32524
811024c0:	1009883a 	mov	r4,r2
811024c4:	00800b84 	movi	r2,46
811024c8:	100d883a 	mov	r6,r2
811024cc:	200b883a 	mov	r5,r4
811024d0:	1809883a 	mov	r4,r3
811024d4:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
811024d8:	d0a05e17 	ldw	r2,-32392(gp)
811024dc:	01604574 	movhi	r5,33045
811024e0:	297b8b04 	addi	r5,r5,-4564
811024e4:	1009883a 	mov	r4,r2
811024e8:	111ca180 	call	8111ca18 <fprintf>
#endif
	bool bSuccess;
	alt_u32 uliDdr2Base;
	alt_u32 uliByteLen;

	bSuccess = TRUE;
811024ec:	00800044 	movi	r2,1
811024f0:	e0bfef15 	stw	r2,-68(fp)
	switch (ucMemoryId) {
811024f4:	e0bff903 	ldbu	r2,-28(fp)
811024f8:	10000326 	beq	r2,zero,81102508 <bDdr2MemoryRandomReadTest+0x90>
811024fc:	10800060 	cmpeqi	r2,r2,1
81102500:	1000081e 	bne	r2,zero,81102524 <bDdr2MemoryRandomReadTest+0xac>
81102504:	00000e06 	br	81102540 <bDdr2MemoryRandomReadTest+0xc8>
	case DDR2_M1_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102508:	e0bff903 	ldbu	r2,-28(fp)
8110250c:	1009883a 	mov	r4,r2
81102510:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102514:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M1_MEMORY_SIZE;
81102518:	00a00034 	movhi	r2,32768
8110251c:	e0bff115 	stw	r2,-60(fp)
		break;
81102520:	00001906 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	case DDR2_M2_ID:
		bDdr2SwitchMemory(ucMemoryId);
81102524:	e0bff903 	ldbu	r2,-28(fp)
81102528:	1009883a 	mov	r4,r2
8110252c:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
		uliDdr2Base = DDR2_EXT_ADDR_WINDOWED_BASE;
81102530:	e03ff015 	stw	zero,-64(fp)
		uliByteLen = DDR2_M2_MEMORY_SIZE;
81102534:	00a00034 	movhi	r2,32768
81102538:	e0bff115 	stw	r2,-60(fp)
		break;
8110253c:	00001206 	br	81102588 <bDdr2MemoryRandomReadTest+0x110>
	default:
		bSuccess = FALSE;
81102540:	e03fef15 	stw	zero,-68(fp)
#ifdef DEBUG_ON
		sprintf(cDebugBuffer,
81102544:	00e04574 	movhi	r3,33045
81102548:	18fb8b04 	addi	r3,r3,-4564
8110254c:	00a04534 	movhi	r2,33044
81102550:	109d4404 	addi	r2,r2,29968
81102554:	1009883a 	mov	r4,r2
81102558:	00800bc4 	movi	r2,47
8110255c:	100d883a 	mov	r6,r2
81102560:	200b883a 	mov	r5,r4
81102564:	1809883a 	mov	r4,r3
81102568:	111dac80 	call	8111dac8 <memcpy>
				"DR2 Memory ID not identified!! Aborting Test \n");
		debug(fp, cDebugBuffer)
8110256c:	d0a05e17 	ldw	r2,-32392(gp)
81102570:	01604574 	movhi	r5,33045
81102574:	297b8b04 	addi	r5,r5,-4564
81102578:	1009883a 	mov	r4,r2
8110257c:	111ca180 	call	8111ca18 <fprintf>
		;
#endif
		return bSuccess;
81102580:	e0bfef17 	ldw	r2,-68(fp)
81102584:	0000d906 	br	811028ec <bDdr2MemoryRandomReadTest+0x474>
	}

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "DDR2 Size: %ld MBytes\n", uliByteLen / 1024 / 1024);
81102588:	e0bff117 	ldw	r2,-60(fp)
8110258c:	1004d53a 	srli	r2,r2,20
81102590:	100d883a 	mov	r6,r2
81102594:	01604534 	movhi	r5,33044
81102598:	295f3d04 	addi	r5,r5,31988
8110259c:	01204574 	movhi	r4,33045
811025a0:	213b8b04 	addi	r4,r4,-4564
811025a4:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
811025a8:	d0a05e17 	ldw	r2,-32392(gp)
811025ac:	01604574 	movhi	r5,33045
811025b0:	297b8b04 	addi	r5,r5,-4564
811025b4:	1009883a 	mov	r4,r2
811025b8:	111ca180 	call	8111ca18 <fprintf>
	alt_u32 uliCurrentState;
	alt_u32 uliMemoryEndAddress;
	alt_u32 uliNextMilestone;
	alt_u8 ucPercentage;

	uliCurrentState = uliInitialState;
811025bc:	d0a03717 	ldw	r2,-32548(gp)
811025c0:	e0bff815 	stw	r2,-32(fp)
	uliMemoryEndAddress = uliDdr2Base + uliByteLen;
811025c4:	e0fff017 	ldw	r3,-64(fp)
811025c8:	e0bff117 	ldw	r2,-60(fp)
811025cc:	1885883a 	add	r2,r3,r2
811025d0:	e0bff515 	stw	r2,-44(fp)
	uliNextMilestone = uliDdr2Base + uliByteLen / 20;
811025d4:	e0fff117 	ldw	r3,-60(fp)
811025d8:	00b33374 	movhi	r2,52429
811025dc:	10b33344 	addi	r2,r2,-13107
811025e0:	1888383a 	mulxuu	r4,r3,r2
811025e4:	1885383a 	mul	r2,r3,r2
811025e8:	1025883a 	mov	r18,r2
811025ec:	2027883a 	mov	r19,r4
811025f0:	9806d13a 	srli	r3,r19,4
811025f4:	e0bff017 	ldw	r2,-64(fp)
811025f8:	1885883a 	add	r2,r3,r2
811025fc:	e0bff315 	stw	r2,-52(fp)
	ucPercentage = 5;
81102600:	00800144 	movi	r2,5
81102604:	e0bff405 	stb	r2,-48(fp)
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "Reading from memory...\n");
81102608:	00e04574 	movhi	r3,33045
8110260c:	18fb8b04 	addi	r3,r3,-4564
81102610:	00a04534 	movhi	r2,33044
81102614:	109fcf04 	addi	r2,r2,32572
81102618:	1009883a 	mov	r4,r2
8110261c:	00800604 	movi	r2,24
81102620:	100d883a 	mov	r6,r2
81102624:	200b883a 	mov	r5,r4
81102628:	1809883a 	mov	r4,r3
8110262c:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
81102630:	d0a05e17 	ldw	r2,-32392(gp)
81102634:	01604574 	movhi	r5,33045
81102638:	297b8b04 	addi	r5,r5,-4564
8110263c:	1009883a 	mov	r4,r2
81102640:	111ca180 	call	8111ca18 <fprintf>
#endif
	if (bVerbose == DDR2_VERBOSE) {
81102644:	e0bffa17 	ldw	r2,-24(fp)
81102648:	10800058 	cmpnei	r2,r2,1
8110264c:	10000a1e 	bne	r2,zero,81102678 <bDdr2MemoryRandomReadTest+0x200>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "00%%..");
81102650:	01604534 	movhi	r5,33044
81102654:	295fa504 	addi	r5,r5,32404
81102658:	01204574 	movhi	r4,33045
8110265c:	213b8b04 	addi	r4,r4,-4564
81102660:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, cDebugBuffer);
81102664:	d0a05e17 	ldw	r2,-32392(gp)
81102668:	01604574 	movhi	r5,33045
8110266c:	297b8b04 	addi	r5,r5,-4564
81102670:	1009883a 	mov	r4,r2
81102674:	111ca180 	call	8111ca18 <fprintf>
#endif
	}

	int TimeStart, TimeElapsed = 0;
81102678:	e03ff615 	stw	zero,-40(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
8110267c:	d0a08517 	ldw	r2,-32236(gp)

	TimeStart = alt_nticks();
81102680:	e0bff715 	stw	r2,-36(fp)
	for (puliSource = (alt_u32*) uliDdr2Base;
81102684:	e0bff017 	ldw	r2,-64(fp)
81102688:	e0bff215 	stw	r2,-56(fp)
8110268c:	00003a06 	br	81102778 <bDdr2MemoryRandomReadTest+0x300>
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
		if (uliXorshift32(&uliCurrentState) != *puliSource) {
81102690:	e0bff804 	addi	r2,fp,-32
81102694:	1009883a 	mov	r4,r2
81102698:	11029100 	call	81102910 <uliXorshift32>
8110269c:	1007883a 	mov	r3,r2
811026a0:	e0bff217 	ldw	r2,-56(fp)
811026a4:	10800017 	ldw	r2,0(r2)
811026a8:	18801026 	beq	r3,r2,811026ec <bDdr2MemoryRandomReadTest+0x274>
			bSuccess = FALSE;
811026ac:	e03fef15 	stw	zero,-68(fp)
			if (bVerbose == DDR2_VERBOSE) {
811026b0:	e0bffa17 	ldw	r2,-24(fp)
811026b4:	10800058 	cmpnei	r2,r2,1
811026b8:	10000c1e 	bne	r2,zero,811026ec <bDdr2MemoryRandomReadTest+0x274>
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "Failed to read adress 0x%08lX\n",
811026bc:	e0bff217 	ldw	r2,-56(fp)
811026c0:	100d883a 	mov	r6,r2
811026c4:	01604534 	movhi	r5,33044
811026c8:	295fd504 	addi	r5,r5,32596
811026cc:	01204574 	movhi	r4,33045
811026d0:	213b8b04 	addi	r4,r4,-4564
811026d4:	111e3a80 	call	8111e3a8 <sprintf>
						(alt_u32)puliSource);
				debug(fp, cDebugBuffer);
811026d8:	d0a05e17 	ldw	r2,-32392(gp)
811026dc:	01604574 	movhi	r5,33045
811026e0:	297b8b04 	addi	r5,r5,-4564
811026e4:	1009883a 	mov	r4,r2
811026e8:	111ca180 	call	8111ca18 <fprintf>
#endif
			}
		}
		if ((bVerbose == DDR2_VERBOSE)
811026ec:	e0bffa17 	ldw	r2,-24(fp)
811026f0:	10800058 	cmpnei	r2,r2,1
811026f4:	10001d1e 	bne	r2,zero,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
				&& ((alt_u32) puliSource > uliNextMilestone)) {
811026f8:	e0bff217 	ldw	r2,-56(fp)
811026fc:	e0fff317 	ldw	r3,-52(fp)
81102700:	18801a2e 	bgeu	r3,r2,8110276c <bDdr2MemoryRandomReadTest+0x2f4>
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "..%02d%%..", ucPercentage);
81102704:	e0bff403 	ldbu	r2,-48(fp)
81102708:	100d883a 	mov	r6,r2
8110270c:	01604534 	movhi	r5,33044
81102710:	295fa704 	addi	r5,r5,32412
81102714:	01204574 	movhi	r4,33045
81102718:	213b8b04 	addi	r4,r4,-4564
8110271c:	111e3a80 	call	8111e3a8 <sprintf>
			debug(fp, cDebugBuffer);
81102720:	d0a05e17 	ldw	r2,-32392(gp)
81102724:	01604574 	movhi	r5,33045
81102728:	297b8b04 	addi	r5,r5,-4564
8110272c:	1009883a 	mov	r4,r2
81102730:	111ca180 	call	8111ca18 <fprintf>
#endif
			uliNextMilestone += uliByteLen / 20;
81102734:	e0fff117 	ldw	r3,-60(fp)
81102738:	00b33374 	movhi	r2,52429
8110273c:	10b33344 	addi	r2,r2,-13107
81102740:	1888383a 	mulxuu	r4,r3,r2
81102744:	1885383a 	mul	r2,r3,r2
81102748:	1021883a 	mov	r16,r2
8110274c:	2023883a 	mov	r17,r4
81102750:	8804d13a 	srli	r2,r17,4
81102754:	e0fff317 	ldw	r3,-52(fp)
81102758:	1885883a 	add	r2,r3,r2
8110275c:	e0bff315 	stw	r2,-52(fp)
			ucPercentage += 5;
81102760:	e0bff403 	ldbu	r2,-48(fp)
81102764:	10800144 	addi	r2,r2,5
81102768:	e0bff405 	stb	r2,-48(fp)

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
			(alt_u32) puliSource < uliMemoryEndAddress; puliSource++) {
8110276c:	e0bff217 	ldw	r2,-56(fp)
81102770:	10800104 	addi	r2,r2,4
81102774:	e0bff215 	stw	r2,-56(fp)
81102778:	e0fff217 	ldw	r3,-56(fp)
	}

	int TimeStart, TimeElapsed = 0;

	TimeStart = alt_nticks();
	for (puliSource = (alt_u32*) uliDdr2Base;
8110277c:	e0bff517 	ldw	r2,-44(fp)
81102780:	18bfc336 	bltu	r3,r2,81102690 <__reset+0xfb0e2690>
#endif
			uliNextMilestone += uliByteLen / 20;
			ucPercentage += 5;
		}
	}
	if (bVerbose == DDR2_VERBOSE) {
81102784:	e0bffa17 	ldw	r2,-24(fp)
81102788:	10800058 	cmpnei	r2,r2,1
8110278c:	10000a1e 	bne	r2,zero,811027b8 <bDdr2MemoryRandomReadTest+0x340>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "..100%%\n");
81102790:	01604534 	movhi	r5,33044
81102794:	295faa04 	addi	r5,r5,32424
81102798:	01204574 	movhi	r4,33045
8110279c:	213b8b04 	addi	r4,r4,-4564
811027a0:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, cDebugBuffer);
811027a4:	d0a05e17 	ldw	r2,-32392(gp)
811027a8:	01604574 	movhi	r5,33045
811027ac:	297b8b04 	addi	r5,r5,-4564
811027b0:	1009883a 	mov	r4,r2
811027b4:	111ca180 	call	8111ca18 <fprintf>
#endif
	}

	if (bSuccess) {
811027b8:	e0bfef17 	ldw	r2,-68(fp)
811027bc:	10003126 	beq	r2,zero,81102884 <bDdr2MemoryRandomReadTest+0x40c>
		if (bTime == TRUE) {
811027c0:	e0bffb17 	ldw	r2,-20(fp)
811027c4:	10800058 	cmpnei	r2,r2,1
811027c8:	1000221e 	bne	r2,zero,81102854 <bDdr2MemoryRandomReadTest+0x3dc>
811027cc:	d0e08517 	ldw	r3,-32236(gp)
			TimeElapsed = alt_nticks() - TimeStart;
811027d0:	e0bff717 	ldw	r2,-36(fp)
811027d4:	1885c83a 	sub	r2,r3,r2
811027d8:	e0bff615 	stw	r2,-40(fp)
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
811027dc:	e13ff617 	ldw	r4,-40(fp)
811027e0:	111bc540 	call	8111bc54 <__floatsisf>
811027e4:	1021883a 	mov	r16,r2
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
811027e8:	d0a08417 	ldw	r2,-32240(gp)
811027ec:	1009883a 	mov	r4,r2
811027f0:	111bd800 	call	8111bd80 <__floatunsisf>
811027f4:	1007883a 	mov	r3,r2
811027f8:	180b883a 	mov	r5,r3
811027fc:	8009883a 	mov	r4,r16
81102800:	111b4080 	call	8111b408 <__divsf3>
81102804:	1007883a 	mov	r3,r2
81102808:	1805883a 	mov	r2,r3

	if (bSuccess) {
		if (bTime == TRUE) {
			TimeElapsed = alt_nticks() - TimeStart;
#ifdef DEBUG_ON
			sprintf(cDebugBuffer,
8110280c:	1009883a 	mov	r4,r2
81102810:	111c5980 	call	8111c598 <__extendsfdf2>
81102814:	1009883a 	mov	r4,r2
81102818:	180b883a 	mov	r5,r3
8110281c:	d9400015 	stw	r5,0(sp)
81102820:	200f883a 	mov	r7,r4
81102824:	e1bff117 	ldw	r6,-60(fp)
81102828:	01604534 	movhi	r5,33044
8110282c:	295fdd04 	addi	r5,r5,32628
81102830:	01204574 	movhi	r4,33045
81102834:	213b8b04 	addi	r4,r4,-4564
81102838:	111e3a80 	call	8111e3a8 <sprintf>
					"DDR2 read test pass, size=%lu bytes, %.3f sec\n",
					uliByteLen,
					(float) TimeElapsed / (float) alt_ticks_per_second());
			debug(fp, cDebugBuffer);
8110283c:	d0a05e17 	ldw	r2,-32392(gp)
81102840:	01604574 	movhi	r5,33045
81102844:	297b8b04 	addi	r5,r5,-4564
81102848:	1009883a 	mov	r4,r2
8110284c:	111ca180 	call	8111ca18 <fprintf>
81102850:	00001b06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		} else {
#ifdef DEBUG_ON
			sprintf(cDebugBuffer, "DDR2 read test pass, size=%lu bytes\n",
81102854:	e1bff117 	ldw	r6,-60(fp)
81102858:	01604534 	movhi	r5,33044
8110285c:	295fe904 	addi	r5,r5,32676
81102860:	01204574 	movhi	r4,33045
81102864:	213b8b04 	addi	r4,r4,-4564
81102868:	111e3a80 	call	8111e3a8 <sprintf>
					uliByteLen);
			debug(fp, cDebugBuffer);
8110286c:	d0a05e17 	ldw	r2,-32392(gp)
81102870:	01604574 	movhi	r5,33045
81102874:	297b8b04 	addi	r5,r5,-4564
81102878:	1009883a 	mov	r4,r2
8110287c:	111ca180 	call	8111ca18 <fprintf>
81102880:	00000f06 	br	811028c0 <bDdr2MemoryRandomReadTest+0x448>
#endif
		}
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "DDR2 read test fail\n");
81102884:	00e04574 	movhi	r3,33045
81102888:	18fb8b04 	addi	r3,r3,-4564
8110288c:	00a04534 	movhi	r2,33044
81102890:	109f8d04 	addi	r2,r2,32308
81102894:	1009883a 	mov	r4,r2
81102898:	00800544 	movi	r2,21
8110289c:	100d883a 	mov	r6,r2
811028a0:	200b883a 	mov	r5,r4
811028a4:	1809883a 	mov	r4,r3
811028a8:	111dac80 	call	8111dac8 <memcpy>
		debug(fp, cDebugBuffer);
811028ac:	d0a05e17 	ldw	r2,-32392(gp)
811028b0:	01604574 	movhi	r5,33045
811028b4:	297b8b04 	addi	r5,r5,-4564
811028b8:	1009883a 	mov	r4,r2
811028bc:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "\n");
811028c0:	00a04574 	movhi	r2,33045
811028c4:	10bb8b04 	addi	r2,r2,-4564
811028c8:	00c00284 	movi	r3,10
811028cc:	10c00005 	stb	r3,0(r2)
811028d0:	10000045 	stb	zero,1(r2)
	debug(fp, cDebugBuffer);
811028d4:	d0a05e17 	ldw	r2,-32392(gp)
811028d8:	01604574 	movhi	r5,33045
811028dc:	297b8b04 	addi	r5,r5,-4564
811028e0:	1009883a 	mov	r4,r2
811028e4:	111ca180 	call	8111ca18 <fprintf>
#endif

	return bSuccess;
811028e8:	e0bfef17 	ldw	r2,-68(fp)
}
811028ec:	e6fffc04 	addi	sp,fp,-16
811028f0:	dfc00517 	ldw	ra,20(sp)
811028f4:	df000417 	ldw	fp,16(sp)
811028f8:	dcc00317 	ldw	r19,12(sp)
811028fc:	dc800217 	ldw	r18,8(sp)
81102900:	dc400117 	ldw	r17,4(sp)
81102904:	dc000017 	ldw	r16,0(sp)
81102908:	dec00604 	addi	sp,sp,24
8110290c:	f800283a 	ret

81102910 <uliXorshift32>:
 * @param [in] bDRIVE  Estado atual do RNG
 *
 * @retval Nmero aleatrio resultate do RNG
 *
 */
alt_u32 uliXorshift32(alt_u32 *puliState) {
81102910:	defffd04 	addi	sp,sp,-12
81102914:	de00012e 	bgeu	sp,et,8110291c <uliXorshift32+0xc>
81102918:	003b68fa 	trap	3
8110291c:	df000215 	stw	fp,8(sp)
81102920:	df000204 	addi	fp,sp,8
81102924:	e13fff15 	stw	r4,-4(fp)

	alt_u32 uliX = *puliState;
81102928:	e0bfff17 	ldw	r2,-4(fp)
8110292c:	10800017 	ldw	r2,0(r2)
81102930:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 13;
81102934:	e0bffe17 	ldw	r2,-8(fp)
81102938:	1004937a 	slli	r2,r2,13
8110293c:	e0fffe17 	ldw	r3,-8(fp)
81102940:	1884f03a 	xor	r2,r3,r2
81102944:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX >> 17;
81102948:	e0bffe17 	ldw	r2,-8(fp)
8110294c:	1004d47a 	srli	r2,r2,17
81102950:	e0fffe17 	ldw	r3,-8(fp)
81102954:	1884f03a 	xor	r2,r3,r2
81102958:	e0bffe15 	stw	r2,-8(fp)
	uliX ^= uliX << 5;
8110295c:	e0bffe17 	ldw	r2,-8(fp)
81102960:	1004917a 	slli	r2,r2,5
81102964:	e0fffe17 	ldw	r3,-8(fp)
81102968:	1884f03a 	xor	r2,r3,r2
8110296c:	e0bffe15 	stw	r2,-8(fp)
	*puliState = uliX;
81102970:	e0bfff17 	ldw	r2,-4(fp)
81102974:	e0fffe17 	ldw	r3,-8(fp)
81102978:	10c00015 	stw	r3,0(r2)

	return uliX;
8110297c:	e0bffe17 	ldw	r2,-8(fp)
}
81102980:	e037883a 	mov	sp,fp
81102984:	df000017 	ldw	fp,0(sp)
81102988:	dec00104 	addi	sp,sp,4
8110298c:	f800283a 	ret

81102990 <DMA_OPEN_DEVICE>:
 * @param [in] DmaName  String com o nome do DMA (XXX_CSR_NAME)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_OPEN_DEVICE(alt_msgdma_dev **DmaDevice, const char* DmaName){
81102990:	defffb04 	addi	sp,sp,-20
81102994:	de00012e 	bgeu	sp,et,8110299c <DMA_OPEN_DEVICE+0xc>
81102998:	003b68fa 	trap	3
8110299c:	dfc00415 	stw	ra,16(sp)
811029a0:	df000315 	stw	fp,12(sp)
811029a4:	df000304 	addi	fp,sp,12
811029a8:	e13ffe15 	stw	r4,-8(fp)
811029ac:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
811029b0:	00800044 	movi	r2,1
811029b4:	e0bffd15 	stw	r2,-12(fp)
  
  //Open DMA based on name

  *DmaDevice = alt_msgdma_open((char *)DmaName);
811029b8:	e13fff17 	ldw	r4,-4(fp)
811029bc:	1145d880 	call	81145d88 <alt_msgdma_open>
811029c0:	1007883a 	mov	r3,r2
811029c4:	e0bffe17 	ldw	r2,-8(fp)
811029c8:	10c00015 	stw	r3,0(r2)
  
  //Check if DMA opened correctly;
  if(*DmaDevice == NULL){
811029cc:	e0bffe17 	ldw	r2,-8(fp)
811029d0:	10800017 	ldw	r2,0(r2)
811029d4:	1000011e 	bne	r2,zero,811029dc <DMA_OPEN_DEVICE+0x4c>
    bSuccess = FALSE;
811029d8:	e03ffd15 	stw	zero,-12(fp)
  }
  
  return bSuccess;
811029dc:	e0bffd17 	ldw	r2,-12(fp)
}
811029e0:	e037883a 	mov	sp,fp
811029e4:	dfc00117 	ldw	ra,4(sp)
811029e8:	df000017 	ldw	fp,0(sp)
811029ec:	dec00204 	addi	sp,sp,8
811029f0:	f800283a 	ret

811029f4 <DMA_CONFIG>:
 * @param [in] ConfigMask  Mascara com as configuraes do DMA (overwrite)
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_CONFIG(alt_msgdma_dev *DmaDevice, alt_u32 ConfigMask){
811029f4:	defffc04 	addi	sp,sp,-16
811029f8:	de00012e 	bgeu	sp,et,81102a00 <DMA_CONFIG+0xc>
811029fc:	003b68fa 	trap	3
81102a00:	df000315 	stw	fp,12(sp)
81102a04:	df000304 	addi	fp,sp,12
81102a08:	e13ffe15 	stw	r4,-8(fp)
81102a0c:	e17fff15 	stw	r5,-4(fp)
  bool bSuccess = TRUE;
81102a10:	00800044 	movi	r2,1
81102a14:	e0bffd15 	stw	r2,-12(fp)
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ConfigMask);
81102a18:	e0bffe17 	ldw	r2,-8(fp)
81102a1c:	10800317 	ldw	r2,12(r2)
81102a20:	10800104 	addi	r2,r2,4
81102a24:	e0ffff17 	ldw	r3,-4(fp)
81102a28:	10c00035 	stwio	r3,0(r2)
  return bSuccess;
81102a2c:	e0bffd17 	ldw	r2,-12(fp)
}
81102a30:	e037883a 	mov	sp,fp
81102a34:	df000017 	ldw	fp,0(sp)
81102a38:	dec00104 	addi	sp,sp,4
81102a3c:	f800283a 	ret

81102a40 <DMA_BUSY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : DMA Ocupado
 *
 */
bool DMA_BUSY(alt_msgdma_dev *DmaDevice){
81102a40:	defffd04 	addi	sp,sp,-12
81102a44:	de00012e 	bgeu	sp,et,81102a4c <DMA_BUSY+0xc>
81102a48:	003b68fa 	trap	3
81102a4c:	df000215 	stw	fp,8(sp)
81102a50:	df000204 	addi	fp,sp,8
81102a54:	e13fff15 	stw	r4,-4(fp)
  bool bBusy = FALSE;
81102a58:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK){
81102a5c:	e0bfff17 	ldw	r2,-4(fp)
81102a60:	10800317 	ldw	r2,12(r2)
81102a64:	10800037 	ldwio	r2,0(r2)
81102a68:	1080004c 	andi	r2,r2,1
81102a6c:	10000226 	beq	r2,zero,81102a78 <DMA_BUSY+0x38>
    bBusy = TRUE;
81102a70:	00800044 	movi	r2,1
81102a74:	e0bffe15 	stw	r2,-8(fp)
  }
  return bBusy;
81102a78:	e0bffe17 	ldw	r2,-8(fp)
}
81102a7c:	e037883a 	mov	sp,fp
81102a80:	df000017 	ldw	fp,0(sp)
81102a84:	dec00104 	addi	sp,sp,4
81102a88:	f800283a 	ret

81102a8c <DMA_DESCRIPTOR_BUFFER_FULL>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Cheio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_FULL(alt_msgdma_dev *DmaDevice){
81102a8c:	defffd04 	addi	sp,sp,-12
81102a90:	de00012e 	bgeu	sp,et,81102a98 <DMA_DESCRIPTOR_BUFFER_FULL+0xc>
81102a94:	003b68fa 	trap	3
81102a98:	df000215 	stw	fp,8(sp)
81102a9c:	df000204 	addi	fp,sp,8
81102aa0:	e13fff15 	stw	r4,-4(fp)
  bool bFull = FALSE;
81102aa4:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK){
81102aa8:	e0bfff17 	ldw	r2,-4(fp)
81102aac:	10800317 	ldw	r2,12(r2)
81102ab0:	10800037 	ldwio	r2,0(r2)
81102ab4:	1080010c 	andi	r2,r2,4
81102ab8:	10000226 	beq	r2,zero,81102ac4 <DMA_DESCRIPTOR_BUFFER_FULL+0x38>
    bFull = TRUE;
81102abc:	00800044 	movi	r2,1
81102ac0:	e0bffe15 	stw	r2,-8(fp)
  }
  return bFull;
81102ac4:	e0bffe17 	ldw	r2,-8(fp)
}
81102ac8:	e037883a 	mov	sp,fp
81102acc:	df000017 	ldw	fp,0(sp)
81102ad0:	dec00104 	addi	sp,sp,4
81102ad4:	f800283a 	ret

81102ad8 <DMA_DESCRIPTOR_BUFFER_EMPTY>:
 * @param [in] DmaDevice  Ponteiro para o Device do DMA a ser utilizado
 *
 * @retval TRUE : Buffer Vazio
 *
 */
bool DMA_DESCRIPTOR_BUFFER_EMPTY(alt_msgdma_dev *DmaDevice){
81102ad8:	defffd04 	addi	sp,sp,-12
81102adc:	de00012e 	bgeu	sp,et,81102ae4 <DMA_DESCRIPTOR_BUFFER_EMPTY+0xc>
81102ae0:	003b68fa 	trap	3
81102ae4:	df000215 	stw	fp,8(sp)
81102ae8:	df000204 	addi	fp,sp,8
81102aec:	e13fff15 	stw	r4,-4(fp)
  bool bEmpty = FALSE;
81102af0:	e03ffe15 	stw	zero,-8(fp)
  if (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_EMPTY_MASK){
81102af4:	e0bfff17 	ldw	r2,-4(fp)
81102af8:	10800317 	ldw	r2,12(r2)
81102afc:	10800037 	ldwio	r2,0(r2)
81102b00:	1080008c 	andi	r2,r2,2
81102b04:	10000226 	beq	r2,zero,81102b10 <DMA_DESCRIPTOR_BUFFER_EMPTY+0x38>
    bEmpty = TRUE;
81102b08:	00800044 	movi	r2,1
81102b0c:	e0bffe15 	stw	r2,-8(fp)
  }
  return bEmpty;
81102b10:	e0bffe17 	ldw	r2,-8(fp)
}
81102b14:	e037883a 	mov	sp,fp
81102b18:	df000017 	ldw	fp,0(sp)
81102b1c:	dec00104 	addi	sp,sp,4
81102b20:	f800283a 	ret

81102b24 <DMA_DISPATCHER_STOP>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_STOP(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102b24:	defffa04 	addi	sp,sp,-24
81102b28:	de00012e 	bgeu	sp,et,81102b30 <DMA_DISPATCHER_STOP+0xc>
81102b2c:	003b68fa 	trap	3
81102b30:	dfc00515 	stw	ra,20(sp)
81102b34:	df000415 	stw	fp,16(sp)
81102b38:	df000404 	addi	fp,sp,16
81102b3c:	e13ffd15 	stw	r4,-12(fp)
81102b40:	e17ffe15 	stw	r5,-8(fp)
81102b44:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102b48:	00800044 	movi	r2,1
81102b4c:	e0bffc15 	stw	r2,-16(fp)
  
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
81102b50:	e0bffd17 	ldw	r2,-12(fp)
81102b54:	10800317 	ldw	r2,12(r2)
81102b58:	10800104 	addi	r2,r2,4
81102b5c:	00c00044 	movi	r3,1
81102b60:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102b64:	e0bffe17 	ldw	r2,-8(fp)
81102b68:	10800058 	cmpnei	r2,r2,1
81102b6c:	10000f1e 	bne	r2,zero,81102bac <DMA_DISPATCHER_STOP+0x88>
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b70:	00000806 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102b74:	e0bfff17 	ldw	r2,-4(fp)
81102b78:	1000031e 	bne	r2,zero,81102b88 <DMA_DISPATCHER_STOP+0x64>
        usleep(1);
81102b7c:	01000044 	movi	r4,1
81102b80:	1133cf00 	call	81133cf0 <usleep>
81102b84:	00000306 	br	81102b94 <DMA_DISPATCHER_STOP+0x70>
      } else {
        usleep(WaitPeriodUs);
81102b88:	e0bfff17 	ldw	r2,-4(fp)
81102b8c:	1009883a 	mov	r4,r2
81102b90:	1133cf00 	call	81133cf0 <usleep>
  //Send stop command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_STOP_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait stop to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_STOP_STATE_MASK) {
81102b94:	e0bffd17 	ldw	r2,-12(fp)
81102b98:	10800317 	ldw	r2,12(r2)
81102b9c:	10800037 	ldwio	r2,0(r2)
81102ba0:	1080080c 	andi	r2,r2,32
81102ba4:	103ff31e 	bne	r2,zero,81102b74 <__reset+0xfb0e2b74>
81102ba8:	00000206 	br	81102bb4 <DMA_DISPATCHER_STOP+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102bac:	e0bffc17 	ldw	r2,-16(fp)
81102bb0:	00000106 	br	81102bb8 <DMA_DISPATCHER_STOP+0x94>
  }
  
  return bSuccess;
81102bb4:	e0bffc17 	ldw	r2,-16(fp)
}
81102bb8:	e037883a 	mov	sp,fp
81102bbc:	dfc00117 	ldw	ra,4(sp)
81102bc0:	df000017 	ldw	fp,0(sp)
81102bc4:	dec00204 	addi	sp,sp,8
81102bc8:	f800283a 	ret

81102bcc <DMA_DISPATCHER_RESET>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_DISPATCHER_RESET(alt_msgdma_dev *DmaDevice, bool bWait, alt_32 WaitPeriodUs){
81102bcc:	defffa04 	addi	sp,sp,-24
81102bd0:	de00012e 	bgeu	sp,et,81102bd8 <DMA_DISPATCHER_RESET+0xc>
81102bd4:	003b68fa 	trap	3
81102bd8:	dfc00515 	stw	ra,20(sp)
81102bdc:	df000415 	stw	fp,16(sp)
81102be0:	df000404 	addi	fp,sp,16
81102be4:	e13ffd15 	stw	r4,-12(fp)
81102be8:	e17ffe15 	stw	r5,-8(fp)
81102bec:	e1bfff15 	stw	r6,-4(fp)
  bool bSuccess = TRUE;
81102bf0:	00800044 	movi	r2,1
81102bf4:	e0bffc15 	stw	r2,-16(fp)
  
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81102bf8:	e0bffd17 	ldw	r2,-12(fp)
81102bfc:	10800317 	ldw	r2,12(r2)
81102c00:	10800104 	addi	r2,r2,4
81102c04:	00c00084 	movi	r3,2
81102c08:	10c00035 	stwio	r3,0(r2)
  
  if (bWait == DMA_WAIT) {
81102c0c:	e0bffe17 	ldw	r2,-8(fp)
81102c10:	10800058 	cmpnei	r2,r2,1
81102c14:	10000f1e 	bne	r2,zero,81102c54 <DMA_DISPATCHER_RESET+0x88>
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c18:	00000806 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102c1c:	e0bfff17 	ldw	r2,-4(fp)
81102c20:	1000031e 	bne	r2,zero,81102c30 <DMA_DISPATCHER_RESET+0x64>
        usleep(1);
81102c24:	01000044 	movi	r4,1
81102c28:	1133cf00 	call	81133cf0 <usleep>
81102c2c:	00000306 	br	81102c3c <DMA_DISPATCHER_RESET+0x70>
      } else {
        usleep(WaitPeriodUs);
81102c30:	e0bfff17 	ldw	r2,-4(fp)
81102c34:	1009883a 	mov	r4,r2
81102c38:	1133cf00 	call	81133cf0 <usleep>
  //Send reset command
  IOWR_ALTERA_MSGDMA_CSR_CONTROL(DmaDevice->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
  
  if (bWait == DMA_WAIT) {
    //Wait reset to be finished
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81102c3c:	e0bffd17 	ldw	r2,-12(fp)
81102c40:	10800317 	ldw	r2,12(r2)
81102c44:	10800037 	ldwio	r2,0(r2)
81102c48:	1080100c 	andi	r2,r2,64
81102c4c:	103ff31e 	bne	r2,zero,81102c1c <__reset+0xfb0e2c1c>
81102c50:	00000206 	br	81102c5c <DMA_DISPATCHER_RESET+0x90>
      } else {
        usleep(WaitPeriodUs);
      }
    }
  } else {
    return bSuccess;
81102c54:	e0bffc17 	ldw	r2,-16(fp)
81102c58:	00000106 	br	81102c60 <DMA_DISPATCHER_RESET+0x94>
  }
  
  return bSuccess;
81102c5c:	e0bffc17 	ldw	r2,-16(fp)
}
81102c60:	e037883a 	mov	sp,fp
81102c64:	dfc00117 	ldw	ra,4(sp)
81102c68:	df000017 	ldw	fp,0(sp)
81102c6c:	dec00204 	addi	sp,sp,8
81102c70:	f800283a 	ret

81102c74 <DMA_SINGLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_SINGLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddress, alt_u32 DestinationAddress, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102c74:	defff604 	addi	sp,sp,-40
81102c78:	de00012e 	bgeu	sp,et,81102c80 <DMA_SINGLE_TRANSFER+0xc>
81102c7c:	003b68fa 	trap	3
81102c80:	dfc00915 	stw	ra,36(sp)
81102c84:	df000815 	stw	fp,32(sp)
81102c88:	dc000715 	stw	r16,28(sp)
81102c8c:	df000804 	addi	fp,sp,32
81102c90:	e13ffb15 	stw	r4,-20(fp)
81102c94:	e17ffc15 	stw	r5,-16(fp)
81102c98:	e1bffd15 	stw	r6,-12(fp)
81102c9c:	e1fffe15 	stw	r7,-8(fp)
81102ca0:	defff804 	addi	sp,sp,-32
81102ca4:	d8800204 	addi	r2,sp,8
81102ca8:	108003c4 	addi	r2,r2,15
81102cac:	1004d13a 	srli	r2,r2,4
81102cb0:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102cb4:	00800044 	movi	r2,1
81102cb8:	e0bffa15 	stw	r2,-24(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;

  if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddress, (alt_u32 *)DestinationAddress, TransferSize, ControlBits) != 0){
81102cbc:	e0fffc17 	ldw	r3,-16(fp)
81102cc0:	e13ffd17 	ldw	r4,-12(fp)
81102cc4:	e0800217 	ldw	r2,8(fp)
81102cc8:	d8800115 	stw	r2,4(sp)
81102ccc:	e0bffe17 	ldw	r2,-8(fp)
81102cd0:	d8800015 	stw	r2,0(sp)
81102cd4:	200f883a 	mov	r7,r4
81102cd8:	180d883a 	mov	r6,r3
81102cdc:	800b883a 	mov	r5,r16
81102ce0:	e13ffb17 	ldw	r4,-20(fp)
81102ce4:	1144d840 	call	81144d84 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102ce8:	10000326 	beq	r2,zero,81102cf8 <DMA_SINGLE_TRANSFER+0x84>
    bSuccess = FALSE;
81102cec:	e03ffa15 	stw	zero,-24(fp)
    return bSuccess;
81102cf0:	e0bffa17 	ldw	r2,-24(fp)
81102cf4:	00001e06 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
  } else {
    if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102cf8:	800b883a 	mov	r5,r16
81102cfc:	e13ffb17 	ldw	r4,-20(fp)
81102d00:	1145ff80 	call	81145ff8 <alt_msgdma_standard_descriptor_async_transfer>
81102d04:	10000326 	beq	r2,zero,81102d14 <DMA_SINGLE_TRANSFER+0xa0>
      bSuccess = FALSE;
81102d08:	e03ffa15 	stw	zero,-24(fp)
      return bSuccess;
81102d0c:	e0bffa17 	ldw	r2,-24(fp)
81102d10:	00001706 	br	81102d70 <DMA_SINGLE_TRANSFER+0xfc>
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102d14:	e0bffa17 	ldw	r2,-24(fp)
81102d18:	10800060 	cmpeqi	r2,r2,1
81102d1c:	1007883a 	mov	r3,r2
81102d20:	e0800317 	ldw	r2,12(fp)
81102d24:	10800060 	cmpeqi	r2,r2,1
81102d28:	1884703a 	and	r2,r3,r2
81102d2c:	10803fcc 	andi	r2,r2,255
81102d30:	10000e26 	beq	r2,zero,81102d6c <DMA_SINGLE_TRANSFER+0xf8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d34:	00000806 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102d38:	e0800417 	ldw	r2,16(fp)
81102d3c:	1000031e 	bne	r2,zero,81102d4c <DMA_SINGLE_TRANSFER+0xd8>
        usleep(1000);
81102d40:	0100fa04 	movi	r4,1000
81102d44:	1133cf00 	call	81133cf0 <usleep>
81102d48:	00000306 	br	81102d58 <DMA_SINGLE_TRANSFER+0xe4>
      } else {
        usleep(WaitPeriodUs);
81102d4c:	e0800417 	ldw	r2,16(fp)
81102d50:	1009883a 	mov	r4,r2
81102d54:	1133cf00 	call	81133cf0 <usleep>
      return bSuccess;
    }
  }
  
  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102d58:	e0bffb17 	ldw	r2,-20(fp)
81102d5c:	10800317 	ldw	r2,12(r2)
81102d60:	10800037 	ldwio	r2,0(r2)
81102d64:	1080004c 	andi	r2,r2,1
81102d68:	103ff31e 	bne	r2,zero,81102d38 <__reset+0xfb0e2d38>
        usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102d6c:	e0bffa17 	ldw	r2,-24(fp)
}
81102d70:	e6ffff04 	addi	sp,fp,-4
81102d74:	dfc00217 	ldw	ra,8(sp)
81102d78:	df000117 	ldw	fp,4(sp)
81102d7c:	dc000017 	ldw	r16,0(sp)
81102d80:	dec00304 	addi	sp,sp,12
81102d84:	f800283a 	ret

81102d88 <DMA_MULTIPLE_TRANSFER>:
 * @param [in] WaitPeriodUs  Define em qual intervalo de tempo a funo ir verificar se a transferencia foi concluida
 *
 * @retval TRUE : Sucesso
 *
 */
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
81102d88:	defff504 	addi	sp,sp,-44
81102d8c:	de00012e 	bgeu	sp,et,81102d94 <DMA_MULTIPLE_TRANSFER+0xc>
81102d90:	003b68fa 	trap	3
81102d94:	dfc00a15 	stw	ra,40(sp)
81102d98:	df000915 	stw	fp,36(sp)
81102d9c:	dc000815 	stw	r16,32(sp)
81102da0:	df000904 	addi	fp,sp,36
81102da4:	e13ffb15 	stw	r4,-20(fp)
81102da8:	e17ffc15 	stw	r5,-16(fp)
81102dac:	e1bffd15 	stw	r6,-12(fp)
81102db0:	3805883a 	mov	r2,r7
81102db4:	e0bffe05 	stb	r2,-8(fp)
81102db8:	defff804 	addi	sp,sp,-32
81102dbc:	d8800204 	addi	r2,sp,8
81102dc0:	108003c4 	addi	r2,r2,15
81102dc4:	1004d13a 	srli	r2,r2,4
81102dc8:	1020913a 	slli	r16,r2,4
  bool bSuccess = TRUE;
81102dcc:	00800044 	movi	r2,1
81102dd0:	e0bff915 	stw	r2,-28(fp)
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;
81102dd4:	e03ffa05 	stb	zero,-24(fp)

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102dd8:	00002506 	br	81102e70 <DMA_MULTIPLE_TRANSFER+0xe8>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, (ControlBits | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_EARLY_DONE_ENABLE_MASK)) != 0){
81102ddc:	e0bffa03 	ldbu	r2,-24(fp)
81102de0:	1085883a 	add	r2,r2,r2
81102de4:	1085883a 	add	r2,r2,r2
81102de8:	1007883a 	mov	r3,r2
81102dec:	e0bffc17 	ldw	r2,-16(fp)
81102df0:	10c5883a 	add	r2,r2,r3
81102df4:	10800017 	ldw	r2,0(r2)
81102df8:	1009883a 	mov	r4,r2
81102dfc:	e0bffa03 	ldbu	r2,-24(fp)
81102e00:	1085883a 	add	r2,r2,r2
81102e04:	1085883a 	add	r2,r2,r2
81102e08:	1007883a 	mov	r3,r2
81102e0c:	e0bffd17 	ldw	r2,-12(fp)
81102e10:	10c5883a 	add	r2,r2,r3
81102e14:	10800017 	ldw	r2,0(r2)
81102e18:	1007883a 	mov	r3,r2
81102e1c:	e0800317 	ldw	r2,12(fp)
81102e20:	10804034 	orhi	r2,r2,256
81102e24:	d8800115 	stw	r2,4(sp)
81102e28:	e0800217 	ldw	r2,8(fp)
81102e2c:	d8800015 	stw	r2,0(sp)
81102e30:	180f883a 	mov	r7,r3
81102e34:	200d883a 	mov	r6,r4
81102e38:	800b883a 	mov	r5,r16
81102e3c:	e13ffb17 	ldw	r4,-20(fp)
81102e40:	1144d840 	call	81144d84 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102e44:	10000226 	beq	r2,zero,81102e50 <DMA_MULTIPLE_TRANSFER+0xc8>
      bSuccess = FALSE;
81102e48:	e03ff915 	stw	zero,-28(fp)
81102e4c:	00000506 	br	81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102e50:	800b883a 	mov	r5,r16
81102e54:	e13ffb17 	ldw	r4,-20(fp)
81102e58:	1145ff80 	call	81145ff8 <alt_msgdma_standard_descriptor_async_transfer>
81102e5c:	10000126 	beq	r2,zero,81102e64 <DMA_MULTIPLE_TRANSFER+0xdc>
        bSuccess = FALSE;
81102e60:	e03ff915 	stw	zero,-28(fp)
      }
    }
	i++;
81102e64:	e0bffa03 	ldbu	r2,-24(fp)
81102e68:	10800044 	addi	r2,r2,1
81102e6c:	e0bffa05 	stb	r2,-24(fp)
bool DMA_MULTIPLE_TRANSFER(alt_msgdma_dev *DmaDevice, alt_u32 SourceAddressArray[], alt_u32 DestinationAddressArray[], alt_u8 TransferNumber, alt_u32 TransferSize, alt_u32 ControlBits, bool bWait, alt_32 WaitPeriodUs){
  bool bSuccess = TRUE;
  alt_msgdma_standard_descriptor DmaDescriptor;
  alt_u8 i = 0;

  while ((bSuccess == TRUE) & (i < (TransferNumber - 1))){
81102e70:	e0bff917 	ldw	r2,-28(fp)
81102e74:	10800060 	cmpeqi	r2,r2,1
81102e78:	1009883a 	mov	r4,r2
81102e7c:	e0fffa03 	ldbu	r3,-24(fp)
81102e80:	e0bffe03 	ldbu	r2,-8(fp)
81102e84:	10bfffc4 	addi	r2,r2,-1
81102e88:	1884803a 	cmplt	r2,r3,r2
81102e8c:	2084703a 	and	r2,r4,r2
81102e90:	10803fcc 	andi	r2,r2,255
81102e94:	103fd11e 	bne	r2,zero,81102ddc <__reset+0xfb0e2ddc>
        bSuccess = FALSE;
      }
    }
	i++;
  }
  if (bSuccess == TRUE){
81102e98:	e0bff917 	ldw	r2,-28(fp)
81102e9c:	10800058 	cmpnei	r2,r2,1
81102ea0:	1000211e 	bne	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    if (alt_msgdma_construct_standard_mm_to_mm_descriptor(DmaDevice, &DmaDescriptor, (alt_u32 *)SourceAddressArray[i], (alt_u32 *)DestinationAddressArray[i], TransferSize, ControlBits) != 0){
81102ea4:	e0bffa03 	ldbu	r2,-24(fp)
81102ea8:	1085883a 	add	r2,r2,r2
81102eac:	1085883a 	add	r2,r2,r2
81102eb0:	1007883a 	mov	r3,r2
81102eb4:	e0bffc17 	ldw	r2,-16(fp)
81102eb8:	10c5883a 	add	r2,r2,r3
81102ebc:	10800017 	ldw	r2,0(r2)
81102ec0:	1009883a 	mov	r4,r2
81102ec4:	e0bffa03 	ldbu	r2,-24(fp)
81102ec8:	1085883a 	add	r2,r2,r2
81102ecc:	1085883a 	add	r2,r2,r2
81102ed0:	1007883a 	mov	r3,r2
81102ed4:	e0bffd17 	ldw	r2,-12(fp)
81102ed8:	10c5883a 	add	r2,r2,r3
81102edc:	10800017 	ldw	r2,0(r2)
81102ee0:	1007883a 	mov	r3,r2
81102ee4:	e0800317 	ldw	r2,12(fp)
81102ee8:	d8800115 	stw	r2,4(sp)
81102eec:	e0800217 	ldw	r2,8(fp)
81102ef0:	d8800015 	stw	r2,0(sp)
81102ef4:	180f883a 	mov	r7,r3
81102ef8:	200d883a 	mov	r6,r4
81102efc:	800b883a 	mov	r5,r16
81102f00:	e13ffb17 	ldw	r4,-20(fp)
81102f04:	1144d840 	call	81144d84 <alt_msgdma_construct_standard_mm_to_mm_descriptor>
81102f08:	10000226 	beq	r2,zero,81102f14 <DMA_MULTIPLE_TRANSFER+0x18c>
      bSuccess = FALSE;
81102f0c:	e03ff915 	stw	zero,-28(fp)
81102f10:	00000506 	br	81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
    } else {
      if (alt_msgdma_standard_descriptor_async_transfer(DmaDevice, &DmaDescriptor) != 0) {
81102f14:	800b883a 	mov	r5,r16
81102f18:	e13ffb17 	ldw	r4,-20(fp)
81102f1c:	1145ff80 	call	81145ff8 <alt_msgdma_standard_descriptor_async_transfer>
81102f20:	10000126 	beq	r2,zero,81102f28 <DMA_MULTIPLE_TRANSFER+0x1a0>
        bSuccess = FALSE;
81102f24:	e03ff915 	stw	zero,-28(fp)
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
81102f28:	e0bff917 	ldw	r2,-28(fp)
81102f2c:	10800060 	cmpeqi	r2,r2,1
81102f30:	1007883a 	mov	r3,r2
81102f34:	e0800417 	ldw	r2,16(fp)
81102f38:	10800060 	cmpeqi	r2,r2,1
81102f3c:	1884703a 	and	r2,r3,r2
81102f40:	10803fcc 	andi	r2,r2,255
81102f44:	10000e26 	beq	r2,zero,81102f80 <DMA_MULTIPLE_TRANSFER+0x1f8>
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f48:	00000806 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      if (WaitPeriodUs == DMA_DEFAULT_WAIT_PERIOD){
81102f4c:	e0800517 	ldw	r2,20(fp)
81102f50:	1000031e 	bne	r2,zero,81102f60 <DMA_MULTIPLE_TRANSFER+0x1d8>
    	usleep(1000);
81102f54:	0100fa04 	movi	r4,1000
81102f58:	1133cf00 	call	81133cf0 <usleep>
81102f5c:	00000306 	br	81102f6c <DMA_MULTIPLE_TRANSFER+0x1e4>
      } else {
    	usleep(WaitPeriodUs);
81102f60:	e0800517 	ldw	r2,20(fp)
81102f64:	1009883a 	mov	r4,r2
81102f68:	1133cf00 	call	81133cf0 <usleep>
      }
    }
  }

  if ((bSuccess == TRUE) & (bWait == DMA_WAIT)) {
    while (IORD_ALTERA_MSGDMA_CSR_STATUS (DmaDevice->csr_base) & ALTERA_MSGDMA_CSR_BUSY_MASK) {
81102f6c:	e0bffb17 	ldw	r2,-20(fp)
81102f70:	10800317 	ldw	r2,12(r2)
81102f74:	10800037 	ldwio	r2,0(r2)
81102f78:	1080004c 	andi	r2,r2,1
81102f7c:	103ff31e 	bne	r2,zero,81102f4c <__reset+0xfb0e2f4c>
    	usleep(WaitPeriodUs);
      }
    }
  }
  
  return bSuccess;
81102f80:	e0bff917 	ldw	r2,-28(fp)
}
81102f84:	e6ffff04 	addi	sp,fp,-4
81102f88:	dfc00217 	ldw	ra,8(sp)
81102f8c:	df000117 	ldw	fp,4(sp)
81102f90:	dc000017 	ldw	r16,0(sp)
81102f94:	dec00304 	addi	sp,sp,12
81102f98:	f800283a 	ret

81102f9c <POWER_Read>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

bool POWER_Read(alt_u32 szVol[POWER_PORT_NUM]) {
81102f9c:	deffef04 	addi	sp,sp,-68
81102fa0:	de00012e 	bgeu	sp,et,81102fa8 <POWER_Read+0xc>
81102fa4:	003b68fa 	trap	3
81102fa8:	dfc01015 	stw	ra,64(sp)
81102fac:	df000f15 	stw	fp,60(sp)
81102fb0:	df000f04 	addi	fp,sp,60
81102fb4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = TRUE;
81102fb8:	00800044 	movi	r2,1
81102fbc:	e0bff315 	stw	r2,-52(fp)
	int i, c, nPortIndex = 0;
81102fc0:	e03ff615 	stw	zero,-40(fp)
	int szPortNum[] = { POWER_DEVICE0_PORT_NUM, POWER_DEVICE1_PORT_NUM };
81102fc4:	00800204 	movi	r2,8
81102fc8:	e0bffc15 	stw	r2,-16(fp)
81102fcc:	00800104 	movi	r2,4
81102fd0:	e0bffd15 	stw	r2,-12(fp)
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
81102fd4:	00800044 	movi	r2,1
81102fd8:	e0bff715 	stw	r2,-36(fp)
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
81102fdc:	00800044 	movi	r2,1
81102fe0:	e0bff815 	stw	r2,-32(fp)
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
81102fe4:	e03ff915 	stw	zero,-28(fp)
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
81102fe8:	e03ff515 	stw	zero,-44(fp)
81102fec:	00009206 	br	81103238 <POWER_Read+0x29c>
		NextChannel = 0;
81102ff0:	e03ffa05 	stb	zero,-24(fp)
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
81102ff4:	e0bff517 	ldw	r2,-44(fp)
81102ff8:	10c03fcc 	andi	r3,r2,255
81102ffc:	e13ffa03 	ldbu	r4,-24(fp)
81103000:	e0bfff17 	ldw	r2,-4(fp)
81103004:	d8800115 	stw	r2,4(sp)
81103008:	e0bff917 	ldw	r2,-28(fp)
8110300c:	d8800015 	stw	r2,0(sp)
81103010:	e1fff817 	ldw	r7,-32(fp)
81103014:	e1bff717 	ldw	r6,-36(fp)
81103018:	200b883a 	mov	r5,r4
8110301c:	1809883a 	mov	r4,r3
81103020:	110ae480 	call	8110ae48 <POWER_SPI_RW>
81103024:	e0bff315 	stw	r2,-52(fp)
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
81103028:	e03ff415 	stw	zero,-48(fp)
8110302c:	00007406 	br	81103200 <POWER_Read+0x264>
			NextChannel = i + 1;
81103030:	e0bff417 	ldw	r2,-48(fp)
81103034:	10800044 	addi	r2,r2,1
81103038:	e0bffa05 	stb	r2,-24(fp)
			bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &Value32);
8110303c:	e0bff517 	ldw	r2,-44(fp)
81103040:	10c03fcc 	andi	r3,r2,255
81103044:	e13ffa03 	ldbu	r4,-24(fp)
81103048:	e0bffe04 	addi	r2,fp,-8
8110304c:	d8800115 	stw	r2,4(sp)
81103050:	e0bff917 	ldw	r2,-28(fp)
81103054:	d8800015 	stw	r2,0(sp)
81103058:	e1fff817 	ldw	r7,-32(fp)
8110305c:	e1bff717 	ldw	r6,-36(fp)
81103060:	200b883a 	mov	r5,r4
81103064:	1809883a 	mov	r4,r3
81103068:	110ae480 	call	8110ae48 <POWER_SPI_RW>
8110306c:	e0bff315 	stw	r2,-52(fp)
			if (bSuccess) {
81103070:	e0bff317 	ldw	r2,-52(fp)
81103074:	10005026 	beq	r2,zero,811031b8 <POWER_Read+0x21c>
				HEAD = (Value32 >> 30) & 0x03;
81103078:	e0bffe17 	ldw	r2,-8(fp)
8110307c:	1004d7ba 	srli	r2,r2,30
81103080:	e0bffa45 	stb	r2,-23(fp)
				Channel = (Value32 >> 1) & 0x07;
81103084:	e0bffe17 	ldw	r2,-8(fp)
81103088:	1004d07a 	srli	r2,r2,1
8110308c:	108001cc 	andi	r2,r2,7
81103090:	e0bffa85 	stb	r2,-22(fp)
				SIGN = (Value32 >> 4) & 0x01;
81103094:	e0bffe17 	ldw	r2,-8(fp)
81103098:	1004d13a 	srli	r2,r2,4
8110309c:	1080004c 	andi	r2,r2,1
811030a0:	e0bffac5 	stb	r2,-21(fp)
				SGL = (Value32 >> 5) & 0x01;
811030a4:	e0bffe17 	ldw	r2,-8(fp)
811030a8:	1004d17a 	srli	r2,r2,5
811030ac:	1080004c 	andi	r2,r2,1
811030b0:	e0bffb05 	stb	r2,-20(fp)
				PARITY = Value32 & 0x01;
811030b4:	e0bffe17 	ldw	r2,-8(fp)
811030b8:	1080004c 	andi	r2,r2,1
811030bc:	e0bffb45 	stb	r2,-19(fp)
				if (HEAD != 0) {
811030c0:	e0bffa43 	ldbu	r2,-23(fp)
811030c4:	10000d26 	beq	r2,zero,811030fc <POWER_Read+0x160>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected HEAD\r\n", i);
811030c8:	e1bff417 	ldw	r6,-48(fp)
811030cc:	01604534 	movhi	r5,33044
811030d0:	295ff304 	addi	r5,r5,32716
811030d4:	01204574 	movhi	r4,33045
811030d8:	213b8b04 	addi	r4,r4,-4564
811030dc:	111e3a80 	call	8111e3a8 <sprintf>
					debug(fp, cDebugBuffer);
811030e0:	d0a05e17 	ldw	r2,-32392(gp)
811030e4:	01604574 	movhi	r5,33045
811030e8:	297b8b04 	addi	r5,r5,-4564
811030ec:	1009883a 	mov	r4,r2
811030f0:	111ca180 	call	8111ca18 <fprintf>
#endif
					bSuccess = FALSE;
811030f4:	e03ff315 	stw	zero,-52(fp)
811030f8:	00002206 	br	81103184 <POWER_Read+0x1e8>
				} else if (Channel != i) {
811030fc:	e0fffa83 	ldbu	r3,-22(fp)
81103100:	e0bff417 	ldw	r2,-48(fp)
81103104:	18801026 	beq	r3,r2,81103148 <POWER_Read+0x1ac>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer,
81103108:	e0bffa83 	ldbu	r2,-22(fp)
8110310c:	d8800015 	stw	r2,0(sp)
81103110:	e1fff417 	ldw	r7,-48(fp)
81103114:	e1bff417 	ldw	r6,-48(fp)
81103118:	01604534 	movhi	r5,33044
8110311c:	295ff904 	addi	r5,r5,32740
81103120:	01204574 	movhi	r4,33045
81103124:	213b8b04 	addi	r4,r4,-4564
81103128:	111e3a80 	call	8111e3a8 <sprintf>
							"[%d]Unexpected Channel. Expected:%d, Read:%d\r\n",
							i, i, Channel);
					debug(fp, cDebugBuffer);
8110312c:	d0a05e17 	ldw	r2,-32392(gp)
81103130:	01604574 	movhi	r5,33045
81103134:	297b8b04 	addi	r5,r5,-4564
81103138:	1009883a 	mov	r4,r2
8110313c:	111ca180 	call	8111ca18 <fprintf>
#endif
					bSuccess = FALSE;
81103140:	e03ff315 	stw	zero,-52(fp)
81103144:	00000f06 	br	81103184 <POWER_Read+0x1e8>
				} else if (SIGN ^ bSIGN) {
81103148:	e0fffac3 	ldbu	r3,-21(fp)
8110314c:	e0bff817 	ldw	r2,-32(fp)
81103150:	18800c26 	beq	r3,r2,81103184 <POWER_Read+0x1e8>
#ifdef DEBUG_ON
					sprintf(cDebugBuffer, "[%d]Unexpected SIGN\r\n", i);
81103154:	e1bff417 	ldw	r6,-48(fp)
81103158:	01604574 	movhi	r5,33045
8110315c:	29600504 	addi	r5,r5,-32748
81103160:	01204574 	movhi	r4,33045
81103164:	213b8b04 	addi	r4,r4,-4564
81103168:	111e3a80 	call	8111e3a8 <sprintf>
					debug(fp, cDebugBuffer);
8110316c:	d0a05e17 	ldw	r2,-32392(gp)
81103170:	01604574 	movhi	r5,33045
81103174:	297b8b04 	addi	r5,r5,-4564
81103178:	1009883a 	mov	r4,r2
8110317c:	111ca180 	call	8111ca18 <fprintf>
#endif
					bSuccess = FALSE;
81103180:	e03ff315 	stw	zero,-52(fp)
					sprintf(cDebugBuffer, "[%d]Unexpected SGL\r\n", i);
					debug(fp, cDebugBuffer);
#endif
					bSuccess = FALSE;
				}
				if (bSuccess)
81103184:	e0bff317 	ldw	r2,-52(fp)
81103188:	10001a26 	beq	r2,zero,811031f4 <POWER_Read+0x258>
					szVol[nPortIndex++] = Value32; //(Value32 >> 6) & 0xFFFFFF; // 24 bits
8110318c:	e0bff617 	ldw	r2,-40(fp)
81103190:	10c00044 	addi	r3,r2,1
81103194:	e0fff615 	stw	r3,-40(fp)
81103198:	1085883a 	add	r2,r2,r2
8110319c:	1085883a 	add	r2,r2,r2
811031a0:	1007883a 	mov	r3,r2
811031a4:	e0bfff17 	ldw	r2,-4(fp)
811031a8:	10c5883a 	add	r2,r2,r3
811031ac:	e0fffe17 	ldw	r3,-8(fp)
811031b0:	10c00015 	stw	r3,0(r2)
811031b4:	00000f06 	br	811031f4 <POWER_Read+0x258>
			} else {
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "SPI Read Error\r\n");
811031b8:	00e04574 	movhi	r3,33045
811031bc:	18fb8b04 	addi	r3,r3,-4564
811031c0:	00a04574 	movhi	r2,33045
811031c4:	10a00b04 	addi	r2,r2,-32724
811031c8:	1009883a 	mov	r4,r2
811031cc:	00800444 	movi	r2,17
811031d0:	100d883a 	mov	r6,r2
811031d4:	200b883a 	mov	r5,r4
811031d8:	1809883a 	mov	r4,r3
811031dc:	111dac80 	call	8111dac8 <memcpy>
				debug(fp, cDebugBuffer);
811031e0:	d0a05e17 	ldw	r2,-32392(gp)
811031e4:	01604574 	movhi	r5,33045
811031e8:	297b8b04 	addi	r5,r5,-4564
811031ec:	1009883a 	mov	r4,r2
811031f0:	111ca180 	call	8111ca18 <fprintf>
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
		NextChannel = 0;
		bSuccess = POWER_SPI_RW(c, NextChannel, bEN, bSIGN, bSGL, &szVol[0]); // set conversion channel: 0
		for (i = 0; i < szPortNum[c] && bSuccess; i++) {
811031f4:	e0bff417 	ldw	r2,-48(fp)
811031f8:	10800044 	addi	r2,r2,1
811031fc:	e0bff415 	stw	r2,-48(fp)
81103200:	e0bff517 	ldw	r2,-44(fp)
81103204:	1085883a 	add	r2,r2,r2
81103208:	1085883a 	add	r2,r2,r2
8110320c:	e0fff304 	addi	r3,fp,-52
81103210:	1885883a 	add	r2,r3,r2
81103214:	10800904 	addi	r2,r2,36
81103218:	10800017 	ldw	r2,0(r2)
8110321c:	e0fff417 	ldw	r3,-48(fp)
81103220:	1880020e 	bge	r3,r2,8110322c <POWER_Read+0x290>
81103224:	e0bff317 	ldw	r2,-52(fp)
81103228:	103f811e 	bne	r2,zero,81103030 <__reset+0xfb0e3030>
	alt_u32 Value32;
	alt_u8 NextChannel, Channel, HEAD, SIGN, SGL, PARITY;
	const bool bEN = TRUE; // alwasy update next conversion channel
	const bool bSIGN = TRUE; // VolDrop = CH1-CH0
	const bool bSGL = FALSE; // GSGL=FALSE: Diff
	for (c = 0; c < POWER_DEVICE_NUM && bSuccess; c++) {
8110322c:	e0bff517 	ldw	r2,-44(fp)
81103230:	10800044 	addi	r2,r2,1
81103234:	e0bff515 	stw	r2,-44(fp)
81103238:	e0bff517 	ldw	r2,-44(fp)
8110323c:	10800088 	cmpgei	r2,r2,2
81103240:	1000021e 	bne	r2,zero,8110324c <POWER_Read+0x2b0>
81103244:	e0bff317 	ldw	r2,-52(fp)
81103248:	103f691e 	bne	r2,zero,81102ff0 <__reset+0xfb0e2ff0>
				debug(fp, cDebugBuffer);
#endif
			}
		} // for i
	} // for c
	return bSuccess;
8110324c:	e0bff317 	ldw	r2,-52(fp)
}
81103250:	e037883a 	mov	sp,fp
81103254:	dfc00117 	ldw	ra,4(sp)
81103258:	df000017 	ldw	fp,0(sp)
8110325c:	dec00204 	addi	sp,sp,8
81103260:	f800283a 	ret

81103264 <TEMP_Read>:

bool TEMP_Read(alt_8 *pFpgaTemp, alt_8 *pBoardTemp) {
81103264:	defff904 	addi	sp,sp,-28
81103268:	de00012e 	bgeu	sp,et,81103270 <TEMP_Read+0xc>
8110326c:	003b68fa 	trap	3
81103270:	dfc00615 	stw	ra,24(sp)
81103274:	df000515 	stw	fp,20(sp)
81103278:	df000504 	addi	fp,sp,20
8110327c:	e13ffe15 	stw	r4,-8(fp)
81103280:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;
	const alt_u8 DeviceAddr = 0x30;
81103284:	00800c04 	movi	r2,48
81103288:	e0bffd85 	stb	r2,-10(fp)
	alt_8 FpgaTemp, BoardTemp;
	char Data;

	// read local temp
	bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x00,
8110328c:	e0bffd83 	ldbu	r2,-10(fp)
81103290:	10c03fcc 	andi	r3,r2,255
81103294:	18c0201c 	xori	r3,r3,128
81103298:	18ffe004 	addi	r3,r3,-128
8110329c:	e0bffdc4 	addi	r2,fp,-9
811032a0:	d8800015 	stw	r2,0(sp)
811032a4:	000f883a 	mov	r7,zero
811032a8:	180d883a 	mov	r6,r3
811032ac:	01600034 	movhi	r5,32768
811032b0:	29426004 	addi	r5,r5,2432
811032b4:	01200034 	movhi	r4,32768
811032b8:	21026404 	addi	r4,r4,2448
811032bc:	1109c400 	call	81109c40 <I2C_Read>
811032c0:	e0bffc15 	stw	r2,-16(fp)
			(alt_u8 *) &Data);
	if (bSuccess)
811032c4:	e0bffc17 	ldw	r2,-16(fp)
811032c8:	10000226 	beq	r2,zero,811032d4 <TEMP_Read+0x70>
		BoardTemp = Data;
811032cc:	e0bffdc3 	ldbu	r2,-9(fp)
811032d0:	e0bffd45 	stb	r2,-11(fp)

	// read remote temp
	if (bSuccess) {
811032d4:	e0bffc17 	ldw	r2,-16(fp)
811032d8:	10001226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
		bSuccess = I2C_Read(TEMP_SCL_BASE, TEMP_SDA_BASE, DeviceAddr, 0x01,
811032dc:	e0bffd83 	ldbu	r2,-10(fp)
811032e0:	10c03fcc 	andi	r3,r2,255
811032e4:	18c0201c 	xori	r3,r3,128
811032e8:	18ffe004 	addi	r3,r3,-128
811032ec:	e0bffdc4 	addi	r2,fp,-9
811032f0:	d8800015 	stw	r2,0(sp)
811032f4:	01c00044 	movi	r7,1
811032f8:	180d883a 	mov	r6,r3
811032fc:	01600034 	movhi	r5,32768
81103300:	29426004 	addi	r5,r5,2432
81103304:	01200034 	movhi	r4,32768
81103308:	21026404 	addi	r4,r4,2448
8110330c:	1109c400 	call	81109c40 <I2C_Read>
81103310:	e0bffc15 	stw	r2,-16(fp)
				(alt_u8 *) &Data);
		if (bSuccess)
81103314:	e0bffc17 	ldw	r2,-16(fp)
81103318:	10000226 	beq	r2,zero,81103324 <TEMP_Read+0xc0>
			FpgaTemp = Data;
8110331c:	e0bffdc3 	ldbu	r2,-9(fp)
81103320:	e0bffd05 	stb	r2,-12(fp)
	}
	//
	if (bSuccess) {
81103324:	e0bffc17 	ldw	r2,-16(fp)
81103328:	10000626 	beq	r2,zero,81103344 <TEMP_Read+0xe0>
		*pFpgaTemp = FpgaTemp;
8110332c:	e0bffe17 	ldw	r2,-8(fp)
81103330:	e0fffd03 	ldbu	r3,-12(fp)
81103334:	10c00005 	stb	r3,0(r2)
		*pBoardTemp = BoardTemp;
81103338:	e0bfff17 	ldw	r2,-4(fp)
8110333c:	e0fffd43 	ldbu	r3,-11(fp)
81103340:	10c00005 	stb	r3,0(r2)
	}

	return bSuccess;
81103344:	e0bffc17 	ldw	r2,-16(fp)
}
81103348:	e037883a 	mov	sp,fp
8110334c:	dfc00117 	ldw	ra,4(sp)
81103350:	df000017 	ldw	fp,0(sp)
81103354:	dec00204 	addi	sp,sp,8
81103358:	f800283a 	ret

8110335c <sense_log_temp>:

bool sense_log_temp(alt_u8 *FpgaTemp, alt_u8 *BoardTemp) {
8110335c:	defffb04 	addi	sp,sp,-20
81103360:	de00012e 	bgeu	sp,et,81103368 <sense_log_temp+0xc>
81103364:	003b68fa 	trap	3
81103368:	dfc00415 	stw	ra,16(sp)
8110336c:	df000315 	stw	fp,12(sp)
81103370:	df000304 	addi	fp,sp,12
81103374:	e13ffe15 	stw	r4,-8(fp)
81103378:	e17fff15 	stw	r5,-4(fp)
	bool bSuccess;

	// show temp
	bSuccess = TEMP_Read((alt_8*) FpgaTemp, (alt_8*) BoardTemp);
8110337c:	e17fff17 	ldw	r5,-4(fp)
81103380:	e13ffe17 	ldw	r4,-8(fp)
81103384:	11032640 	call	81103264 <TEMP_Read>
81103388:	e0bffd15 	stw	r2,-12(fp)

	return (bSuccess);
8110338c:	e0bffd17 	ldw	r2,-12(fp)
}
81103390:	e037883a 	mov	sp,fp
81103394:	dfc00117 	ldw	ra,4(sp)
81103398:	df000017 	ldw	fp,0(sp)
8110339c:	dec00204 	addi	sp,sp,8
811033a0:	f800283a 	ret

811033a4 <sense_log>:

void sense_log(void) {
811033a4:	deff0404 	addi	sp,sp,-1008
811033a8:	de00012e 	bgeu	sp,et,811033b0 <sense_log+0xc>
811033ac:	003b68fa 	trap	3
811033b0:	dfc0fb15 	stw	ra,1004(sp)
811033b4:	df00fa15 	stw	fp,1000(sp)
811033b8:	dd40f915 	stw	r21,996(sp)
811033bc:	dd00f815 	stw	r20,992(sp)
811033c0:	dcc0f715 	stw	r19,988(sp)
811033c4:	dc80f615 	stw	r18,984(sp)
811033c8:	dc40f515 	stw	r17,980(sp)
811033cc:	dc00f415 	stw	r16,976(sp)
811033d0:	df00fa04 	addi	fp,sp,1000
	bool bSuccess;
	int i;
	const float fRef = 5.0; // 5.0V
811033d4:	00902834 	movhi	r2,16544
811033d8:	e0bf0e15 	stw	r2,-968(fp)
	float fVolDrop, fCurrent, fPower, fVol;
	alt_u32 szVol[POWER_PORT_NUM];
	alt_u32 SIG, MSB, RESULT;
	float szRes[] = { 0.003, 0.001, 0.003, 0.003, 0.003, 0.003, 0.003, 0.003,
811033dc:	008ed174 	movhi	r2,15173
811033e0:	10a6e984 	addi	r2,r2,-25690
811033e4:	e0bf2215 	stw	r2,-888(fp)
811033e8:	008ea0f4 	movhi	r2,14979
811033ec:	10849bc4 	addi	r2,r2,4719
811033f0:	e0bf2315 	stw	r2,-884(fp)
811033f4:	008ed174 	movhi	r2,15173
811033f8:	10a6e984 	addi	r2,r2,-25690
811033fc:	e0bf2415 	stw	r2,-880(fp)
81103400:	008ed174 	movhi	r2,15173
81103404:	10a6e984 	addi	r2,r2,-25690
81103408:	e0bf2515 	stw	r2,-876(fp)
8110340c:	008ed174 	movhi	r2,15173
81103410:	10a6e984 	addi	r2,r2,-25690
81103414:	e0bf2615 	stw	r2,-872(fp)
81103418:	008ed174 	movhi	r2,15173
8110341c:	10a6e984 	addi	r2,r2,-25690
81103420:	e0bf2715 	stw	r2,-868(fp)
81103424:	008ed174 	movhi	r2,15173
81103428:	10a6e984 	addi	r2,r2,-25690
8110342c:	e0bf2815 	stw	r2,-864(fp)
81103430:	008ed174 	movhi	r2,15173
81103434:	10a6e984 	addi	r2,r2,-25690
81103438:	e0bf2915 	stw	r2,-860(fp)
8110343c:	008ed174 	movhi	r2,15173
81103440:	10a6e984 	addi	r2,r2,-25690
81103444:	e0bf2a15 	stw	r2,-856(fp)
81103448:	008ed174 	movhi	r2,15173
8110344c:	10a6e984 	addi	r2,r2,-25690
81103450:	e0bf2b15 	stw	r2,-852(fp)
81103454:	008ed174 	movhi	r2,15173
81103458:	10a6e984 	addi	r2,r2,-25690
8110345c:	e0bf2c15 	stw	r2,-848(fp)
81103460:	008ed174 	movhi	r2,15173
81103464:	10a6e984 	addi	r2,r2,-25690
81103468:	e0bf2d15 	stw	r2,-844(fp)
			0.003, 0.003, 0.003, 0.003 };
	float szRefVol[] = { 0.9, 0.9, 3.0, 0.9, 1.8, 2.5, 1.8, 2.5, 1.1, 1.4, 3.3,
8110346c:	008fd9b4 	movhi	r2,16230
81103470:	10999984 	addi	r2,r2,26214
81103474:	e0bf2e15 	stw	r2,-840(fp)
81103478:	008fd9b4 	movhi	r2,16230
8110347c:	10999984 	addi	r2,r2,26214
81103480:	e0bf2f15 	stw	r2,-836(fp)
81103484:	00901034 	movhi	r2,16448
81103488:	e0bf3015 	stw	r2,-832(fp)
8110348c:	008fd9b4 	movhi	r2,16230
81103490:	10999984 	addi	r2,r2,26214
81103494:	e0bf3115 	stw	r2,-828(fp)
81103498:	008ff9b4 	movhi	r2,16358
8110349c:	10999984 	addi	r2,r2,26214
811034a0:	e0bf3215 	stw	r2,-824(fp)
811034a4:	00900834 	movhi	r2,16416
811034a8:	e0bf3315 	stw	r2,-820(fp)
811034ac:	008ff9b4 	movhi	r2,16358
811034b0:	10999984 	addi	r2,r2,26214
811034b4:	e0bf3415 	stw	r2,-816(fp)
811034b8:	00900834 	movhi	r2,16416
811034bc:	e0bf3515 	stw	r2,-812(fp)
811034c0:	008fe374 	movhi	r2,16269
811034c4:	10b33344 	addi	r2,r2,-13107
811034c8:	e0bf3615 	stw	r2,-808(fp)
811034cc:	008fecf4 	movhi	r2,16307
811034d0:	108cccc4 	addi	r2,r2,13107
811034d4:	e0bf3715 	stw	r2,-804(fp)
811034d8:	009014f4 	movhi	r2,16467
811034dc:	108cccc4 	addi	r2,r2,13107
811034e0:	e0bf3815 	stw	r2,-800(fp)
811034e4:	00900834 	movhi	r2,16416
811034e8:	e0bf3915 	stw	r2,-796(fp)
			2.5 };
	char szName[][64] = { "VCCD_PLL", "VCC0P9", "GPIO_VCCIOPD", "VCCHIP",
811034ec:	00a04574 	movhi	r2,33045
811034f0:	10a04204 	addi	r2,r2,-32504
811034f4:	e0ff3a04 	addi	r3,fp,-792
811034f8:	1009883a 	mov	r4,r2
811034fc:	0080c004 	movi	r2,768
81103500:	100d883a 	mov	r6,r2
81103504:	200b883a 	mov	r5,r4
81103508:	1809883a 	mov	r4,r3
8110350c:	111dac80 	call	8111dac8 <memcpy>
			"VCC1P8_34R", "HSMA_VCCIO", "VCC1P8_78R", "VCCA_PLL", "VCCL_GXB",
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
81103510:	e0bf1604 	addi	r2,fp,-936
81103514:	1009883a 	mov	r4,r2
81103518:	1102f9c0 	call	81102f9c <POWER_Read>
8110351c:	e0bf0f15 	stw	r2,-964(fp)
	if (bSuccess) {
81103520:	e0bf0f17 	ldw	r2,-964(fp)
81103524:	10016026 	beq	r2,zero,81103aa8 <sense_log+0x704>
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103528:	e03f0c15 	stw	zero,-976(fp)
8110352c:	00014c06 	br	81103a60 <sense_log+0x6bc>
			SIG = (szVol[i] >> 29) & 0x01;
81103530:	e0bf0c17 	ldw	r2,-976(fp)
81103534:	1085883a 	add	r2,r2,r2
81103538:	1085883a 	add	r2,r2,r2
8110353c:	e0ff0c04 	addi	r3,fp,-976
81103540:	1885883a 	add	r2,r3,r2
81103544:	10800a04 	addi	r2,r2,40
81103548:	10800017 	ldw	r2,0(r2)
8110354c:	1004d77a 	srli	r2,r2,29
81103550:	1080004c 	andi	r2,r2,1
81103554:	e0bf1015 	stw	r2,-960(fp)
			MSB = (szVol[i] >> 28) & 0x01;
81103558:	e0bf0c17 	ldw	r2,-976(fp)
8110355c:	1085883a 	add	r2,r2,r2
81103560:	1085883a 	add	r2,r2,r2
81103564:	e0ff0c04 	addi	r3,fp,-976
81103568:	1885883a 	add	r2,r3,r2
8110356c:	10800a04 	addi	r2,r2,40
81103570:	10800017 	ldw	r2,0(r2)
81103574:	1004d73a 	srli	r2,r2,28
81103578:	1080004c 	andi	r2,r2,1
8110357c:	e0bf1115 	stw	r2,-956(fp)
			RESULT = (szVol[i] >> 6) & 0x3FFFFF; // 22 bits
81103580:	e0bf0c17 	ldw	r2,-976(fp)
81103584:	1085883a 	add	r2,r2,r2
81103588:	1085883a 	add	r2,r2,r2
8110358c:	e0ff0c04 	addi	r3,fp,-976
81103590:	1885883a 	add	r2,r3,r2
81103594:	10800a04 	addi	r2,r2,40
81103598:	10800017 	ldw	r2,0(r2)
8110359c:	1006d1ba 	srli	r3,r2,6
811035a0:	00801034 	movhi	r2,64
811035a4:	10bfffc4 	addi	r2,r2,-1
811035a8:	1884703a 	and	r2,r3,r2
811035ac:	e0bf1215 	stw	r2,-952(fp)
			if (MSB == 0)
811035b0:	e0bf1117 	ldw	r2,-956(fp)
811035b4:	1000091e 	bne	r2,zero,811035dc <sense_log+0x238>
				fVolDrop = (float) (RESULT) / (float) 0x400000;
811035b8:	e13f1217 	ldw	r4,-952(fp)
811035bc:	111bd800 	call	8111bd80 <__floatunsisf>
811035c0:	1007883a 	mov	r3,r2
811035c4:	0152a034 	movhi	r5,19072
811035c8:	1809883a 	mov	r4,r3
811035cc:	111b4080 	call	8111b408 <__divsf3>
811035d0:	1007883a 	mov	r3,r2
811035d4:	e0ff0d15 	stw	r3,-972(fp)
811035d8:	00000106 	br	811035e0 <sense_log+0x23c>
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
811035dc:	e03f0d15 	stw	zero,-972(fp)
			if (SIG && MSB) {
811035e0:	e0bf1017 	ldw	r2,-960(fp)
811035e4:	10002626 	beq	r2,zero,81103680 <sense_log+0x2dc>
811035e8:	e0bf1117 	ldw	r2,-956(fp)
811035ec:	10002426 	beq	r2,zero,81103680 <sense_log+0x2dc>
				fVol = fRef * 0.5;
811035f0:	014fc034 	movhi	r5,16128
811035f4:	e13f0e17 	ldw	r4,-968(fp)
811035f8:	111b8500 	call	8111b850 <__mulsf3>
811035fc:	1007883a 	mov	r3,r2
81103600:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
81103604:	e0ff3a04 	addi	r3,fp,-792
81103608:	e0bf0c17 	ldw	r2,-976(fp)
8110360c:	100491ba 	slli	r2,r2,6
81103610:	18a1883a 	add	r16,r3,r2
81103614:	e0bf0c17 	ldw	r2,-976(fp)
81103618:	1085883a 	add	r2,r2,r2
8110361c:	1085883a 	add	r2,r2,r2
81103620:	e0ff0c04 	addi	r3,fp,-976
81103624:	1885883a 	add	r2,r3,r2
81103628:	10800a04 	addi	r2,r2,40
8110362c:	10800017 	ldw	r2,0(r2)
			else
				fVolDrop = 0.0; //always be positive in schematic // -(float)(0x400000-RESULT)/(float)0x400000;
			if (SIG && MSB) {
				fVol = fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Over]\r\n  VolDrop:%f(V)\r\n",
81103630:	1023883a 	mov	r17,r2
81103634:	e13f1317 	ldw	r4,-948(fp)
81103638:	111c5980 	call	8111c598 <__extendsfdf2>
8110363c:	1009883a 	mov	r4,r2
81103640:	180b883a 	mov	r5,r3
81103644:	d9000015 	stw	r4,0(sp)
81103648:	d9400115 	stw	r5,4(sp)
8110364c:	880f883a 	mov	r7,r17
81103650:	800d883a 	mov	r6,r16
81103654:	01604574 	movhi	r5,33045
81103658:	29601004 	addi	r5,r5,-32704
8110365c:	01204574 	movhi	r4,33045
81103660:	213b8b04 	addi	r4,r4,-4564
81103664:	111e3a80 	call	8111e3a8 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103668:	d0a05e17 	ldw	r2,-32392(gp)
8110366c:	01604574 	movhi	r5,33045
81103670:	297b8b04 	addi	r5,r5,-4564
81103674:	1009883a 	mov	r4,r2
81103678:	111ca180 	call	8111ca18 <fprintf>
8110367c:	0000f506 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (SIG && !MSB) {
81103680:	e0bf1017 	ldw	r2,-960(fp)
81103684:	10006426 	beq	r2,zero,81103818 <sense_log+0x474>
81103688:	e0bf1117 	ldw	r2,-956(fp)
8110368c:	1000621e 	bne	r2,zero,81103818 <sense_log+0x474>
				fVol = fRef * 0.5 * fVolDrop;
81103690:	e13f0e17 	ldw	r4,-968(fp)
81103694:	111c5980 	call	8111c598 <__extendsfdf2>
81103698:	1011883a 	mov	r8,r2
8110369c:	1813883a 	mov	r9,r3
811036a0:	000d883a 	mov	r6,zero
811036a4:	01cff834 	movhi	r7,16352
811036a8:	4009883a 	mov	r4,r8
811036ac:	480b883a 	mov	r5,r9
811036b0:	111be780 	call	8111be78 <__muldf3>
811036b4:	1009883a 	mov	r4,r2
811036b8:	180b883a 	mov	r5,r3
811036bc:	2021883a 	mov	r16,r4
811036c0:	2823883a 	mov	r17,r5
811036c4:	e13f0d17 	ldw	r4,-972(fp)
811036c8:	111c5980 	call	8111c598 <__extendsfdf2>
811036cc:	1009883a 	mov	r4,r2
811036d0:	180b883a 	mov	r5,r3
811036d4:	200d883a 	mov	r6,r4
811036d8:	280f883a 	mov	r7,r5
811036dc:	8009883a 	mov	r4,r16
811036e0:	880b883a 	mov	r5,r17
811036e4:	111be780 	call	8111be78 <__muldf3>
811036e8:	1009883a 	mov	r4,r2
811036ec:	180b883a 	mov	r5,r3
811036f0:	2005883a 	mov	r2,r4
811036f4:	2807883a 	mov	r3,r5
811036f8:	1009883a 	mov	r4,r2
811036fc:	180b883a 	mov	r5,r3
81103700:	111c6b00 	call	8111c6b0 <__truncdfsf2>
81103704:	1007883a 	mov	r3,r2
81103708:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
8110370c:	e0bf0c17 	ldw	r2,-976(fp)
81103710:	1085883a 	add	r2,r2,r2
81103714:	1085883a 	add	r2,r2,r2
81103718:	e0ff0c04 	addi	r3,fp,-976
8110371c:	1885883a 	add	r2,r3,r2
81103720:	10801604 	addi	r2,r2,88
81103724:	10c00017 	ldw	r3,0(r2)
81103728:	180b883a 	mov	r5,r3
8110372c:	e13f0d17 	ldw	r4,-972(fp)
81103730:	111b4080 	call	8111b408 <__divsf3>
81103734:	1007883a 	mov	r3,r2
81103738:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
8110373c:	e0bf0c17 	ldw	r2,-976(fp)
81103740:	1085883a 	add	r2,r2,r2
81103744:	1085883a 	add	r2,r2,r2
81103748:	e0ff0c04 	addi	r3,fp,-976
8110374c:	1885883a 	add	r2,r3,r2
81103750:	10802204 	addi	r2,r2,136
81103754:	10c00017 	ldw	r3,0(r2)
81103758:	e17f1417 	ldw	r5,-944(fp)
8110375c:	1809883a 	mov	r4,r3
81103760:	111b8500 	call	8111b850 <__mulsf3>
81103764:	1007883a 	mov	r3,r2
81103768:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
8110376c:	e0ff3a04 	addi	r3,fp,-792
81103770:	e0bf0c17 	ldw	r2,-976(fp)
81103774:	100491ba 	slli	r2,r2,6
81103778:	18a9883a 	add	r20,r3,r2
8110377c:	e0bf0c17 	ldw	r2,-976(fp)
81103780:	1085883a 	add	r2,r2,r2
81103784:	1085883a 	add	r2,r2,r2
81103788:	e0ff0c04 	addi	r3,fp,-976
8110378c:	1885883a 	add	r2,r3,r2
81103790:	10800a04 	addi	r2,r2,40
81103794:	10800017 	ldw	r2,0(r2)
			} else if (SIG && !MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103798:	102b883a 	mov	r21,r2
8110379c:	e13f0d17 	ldw	r4,-972(fp)
811037a0:	111c5980 	call	8111c598 <__extendsfdf2>
811037a4:	1021883a 	mov	r16,r2
811037a8:	1823883a 	mov	r17,r3
811037ac:	e13f1417 	ldw	r4,-944(fp)
811037b0:	111c5980 	call	8111c598 <__extendsfdf2>
811037b4:	1025883a 	mov	r18,r2
811037b8:	1827883a 	mov	r19,r3
811037bc:	e13f1517 	ldw	r4,-940(fp)
811037c0:	111c5980 	call	8111c598 <__extendsfdf2>
811037c4:	1009883a 	mov	r4,r2
811037c8:	180b883a 	mov	r5,r3
811037cc:	d9000415 	stw	r4,16(sp)
811037d0:	d9400515 	stw	r5,20(sp)
811037d4:	dc800215 	stw	r18,8(sp)
811037d8:	dcc00315 	stw	r19,12(sp)
811037dc:	dc000015 	stw	r16,0(sp)
811037e0:	dc400115 	stw	r17,4(sp)
811037e4:	a80f883a 	mov	r7,r21
811037e8:	a00d883a 	mov	r6,r20
811037ec:	01604574 	movhi	r5,33045
811037f0:	29601904 	addi	r5,r5,-32668
811037f4:	01204574 	movhi	r4,33045
811037f8:	213b8b04 	addi	r4,r4,-4564
811037fc:	111e3a80 	call	8111e3a8 <sprintf>
						"[%s:%06XH,Pos]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103800:	d0a05e17 	ldw	r2,-32392(gp)
81103804:	01604574 	movhi	r5,33045
81103808:	297b8b04 	addi	r5,r5,-4564
8110380c:	1009883a 	mov	r4,r2
81103810:	111ca180 	call	8111ca18 <fprintf>
81103814:	00008f06 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && MSB) {
81103818:	e0bf1017 	ldw	r2,-960(fp)
8110381c:	1000641e 	bne	r2,zero,811039b0 <sense_log+0x60c>
81103820:	e0bf1117 	ldw	r2,-956(fp)
81103824:	10006226 	beq	r2,zero,811039b0 <sense_log+0x60c>
				fVol = fRef * 0.5 * fVolDrop;
81103828:	e13f0e17 	ldw	r4,-968(fp)
8110382c:	111c5980 	call	8111c598 <__extendsfdf2>
81103830:	1011883a 	mov	r8,r2
81103834:	1813883a 	mov	r9,r3
81103838:	000d883a 	mov	r6,zero
8110383c:	01cff834 	movhi	r7,16352
81103840:	4009883a 	mov	r4,r8
81103844:	480b883a 	mov	r5,r9
81103848:	111be780 	call	8111be78 <__muldf3>
8110384c:	1009883a 	mov	r4,r2
81103850:	180b883a 	mov	r5,r3
81103854:	2021883a 	mov	r16,r4
81103858:	2823883a 	mov	r17,r5
8110385c:	e13f0d17 	ldw	r4,-972(fp)
81103860:	111c5980 	call	8111c598 <__extendsfdf2>
81103864:	1009883a 	mov	r4,r2
81103868:	180b883a 	mov	r5,r3
8110386c:	200d883a 	mov	r6,r4
81103870:	280f883a 	mov	r7,r5
81103874:	8009883a 	mov	r4,r16
81103878:	880b883a 	mov	r5,r17
8110387c:	111be780 	call	8111be78 <__muldf3>
81103880:	1009883a 	mov	r4,r2
81103884:	180b883a 	mov	r5,r3
81103888:	2005883a 	mov	r2,r4
8110388c:	2807883a 	mov	r3,r5
81103890:	1009883a 	mov	r4,r2
81103894:	180b883a 	mov	r5,r3
81103898:	111c6b00 	call	8111c6b0 <__truncdfsf2>
8110389c:	1007883a 	mov	r3,r2
811038a0:	e0ff1315 	stw	r3,-948(fp)
				fCurrent = fVolDrop / szRes[i];
811038a4:	e0bf0c17 	ldw	r2,-976(fp)
811038a8:	1085883a 	add	r2,r2,r2
811038ac:	1085883a 	add	r2,r2,r2
811038b0:	e0ff0c04 	addi	r3,fp,-976
811038b4:	1885883a 	add	r2,r3,r2
811038b8:	10801604 	addi	r2,r2,88
811038bc:	10c00017 	ldw	r3,0(r2)
811038c0:	180b883a 	mov	r5,r3
811038c4:	e13f0d17 	ldw	r4,-972(fp)
811038c8:	111b4080 	call	8111b408 <__divsf3>
811038cc:	1007883a 	mov	r3,r2
811038d0:	e0ff1415 	stw	r3,-944(fp)
				fPower = szRefVol[i] * fCurrent;
811038d4:	e0bf0c17 	ldw	r2,-976(fp)
811038d8:	1085883a 	add	r2,r2,r2
811038dc:	1085883a 	add	r2,r2,r2
811038e0:	e0ff0c04 	addi	r3,fp,-976
811038e4:	1885883a 	add	r2,r3,r2
811038e8:	10802204 	addi	r2,r2,136
811038ec:	10c00017 	ldw	r3,0(r2)
811038f0:	e17f1417 	ldw	r5,-944(fp)
811038f4:	1809883a 	mov	r4,r3
811038f8:	111b8500 	call	8111b850 <__mulsf3>
811038fc:	1007883a 	mov	r3,r2
81103900:	e0ff1515 	stw	r3,-940(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
81103904:	e0ff3a04 	addi	r3,fp,-792
81103908:	e0bf0c17 	ldw	r2,-976(fp)
8110390c:	100491ba 	slli	r2,r2,6
81103910:	18a9883a 	add	r20,r3,r2
81103914:	e0bf0c17 	ldw	r2,-976(fp)
81103918:	1085883a 	add	r2,r2,r2
8110391c:	1085883a 	add	r2,r2,r2
81103920:	e0ff0c04 	addi	r3,fp,-976
81103924:	1885883a 	add	r2,r3,r2
81103928:	10800a04 	addi	r2,r2,40
8110392c:	10800017 	ldw	r2,0(r2)
			} else if (!SIG && MSB) {
				fVol = fRef * 0.5 * fVolDrop;
				fCurrent = fVolDrop / szRes[i];
				fPower = szRefVol[i] * fCurrent;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer,
81103930:	102b883a 	mov	r21,r2
81103934:	e13f0d17 	ldw	r4,-972(fp)
81103938:	111c5980 	call	8111c598 <__extendsfdf2>
8110393c:	1021883a 	mov	r16,r2
81103940:	1823883a 	mov	r17,r3
81103944:	e13f1417 	ldw	r4,-944(fp)
81103948:	111c5980 	call	8111c598 <__extendsfdf2>
8110394c:	1025883a 	mov	r18,r2
81103950:	1827883a 	mov	r19,r3
81103954:	e13f1517 	ldw	r4,-940(fp)
81103958:	111c5980 	call	8111c598 <__extendsfdf2>
8110395c:	1009883a 	mov	r4,r2
81103960:	180b883a 	mov	r5,r3
81103964:	d9000415 	stw	r4,16(sp)
81103968:	d9400515 	stw	r5,20(sp)
8110396c:	dc800215 	stw	r18,8(sp)
81103970:	dcc00315 	stw	r19,12(sp)
81103974:	dc000015 	stw	r16,0(sp)
81103978:	dc400115 	stw	r17,4(sp)
8110397c:	a80f883a 	mov	r7,r21
81103980:	a00d883a 	mov	r6,r20
81103984:	01604574 	movhi	r5,33045
81103988:	29602904 	addi	r5,r5,-32604
8110398c:	01204574 	movhi	r4,33045
81103990:	213b8b04 	addi	r4,r4,-4564
81103994:	111e3a80 	call	8111e3a8 <sprintf>
						"[%s:%06XH,Neg]\r\n  VolDrop:%f(V), Current:%f(A), Power:%f(W)\r\n",
						szName[i], (int) szVol[i], fVolDrop, fCurrent, fPower);
				debug(fp, cDebugBuffer);
81103998:	d0a05e17 	ldw	r2,-32392(gp)
8110399c:	01604574 	movhi	r5,33045
811039a0:	297b8b04 	addi	r5,r5,-4564
811039a4:	1009883a 	mov	r4,r2
811039a8:	111ca180 	call	8111ca18 <fprintf>
811039ac:	00002906 	br	81103a54 <sense_log+0x6b0>
#endif
			} else if (!SIG && !MSB) {
811039b0:	e0bf1017 	ldw	r2,-960(fp)
811039b4:	1000271e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
811039b8:	e0bf1117 	ldw	r2,-956(fp)
811039bc:	1000251e 	bne	r2,zero,81103a54 <sense_log+0x6b0>
				fVol = -fRef * 0.5;
811039c0:	e0bf0e17 	ldw	r2,-968(fp)
811039c4:	10a0003c 	xorhi	r2,r2,32768
811039c8:	014fc034 	movhi	r5,16128
811039cc:	1009883a 	mov	r4,r2
811039d0:	111b8500 	call	8111b850 <__mulsf3>
811039d4:	1007883a 	mov	r3,r2
811039d8:	e0ff1315 	stw	r3,-948(fp)
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
						szName[i], (int) szVol[i], fVol);
811039dc:	e0ff3a04 	addi	r3,fp,-792
811039e0:	e0bf0c17 	ldw	r2,-976(fp)
811039e4:	100491ba 	slli	r2,r2,6
811039e8:	18a1883a 	add	r16,r3,r2
811039ec:	e0bf0c17 	ldw	r2,-976(fp)
811039f0:	1085883a 	add	r2,r2,r2
811039f4:	1085883a 	add	r2,r2,r2
811039f8:	e0ff0c04 	addi	r3,fp,-976
811039fc:	1885883a 	add	r2,r3,r2
81103a00:	10800a04 	addi	r2,r2,40
81103a04:	10800017 	ldw	r2,0(r2)
				debug(fp, cDebugBuffer);
#endif
			} else if (!SIG && !MSB) {
				fVol = -fRef * 0.5;
#ifdef DEBUG_ON
				sprintf(cDebugBuffer, "[%s:%06XH,Under]\r\n  VolDrop:%f(V)\r\n",
81103a08:	1023883a 	mov	r17,r2
81103a0c:	e13f1317 	ldw	r4,-948(fp)
81103a10:	111c5980 	call	8111c598 <__extendsfdf2>
81103a14:	1009883a 	mov	r4,r2
81103a18:	180b883a 	mov	r5,r3
81103a1c:	d9000015 	stw	r4,0(sp)
81103a20:	d9400115 	stw	r5,4(sp)
81103a24:	880f883a 	mov	r7,r17
81103a28:	800d883a 	mov	r6,r16
81103a2c:	01604574 	movhi	r5,33045
81103a30:	29603904 	addi	r5,r5,-32540
81103a34:	01204574 	movhi	r4,33045
81103a38:	213b8b04 	addi	r4,r4,-4564
81103a3c:	111e3a80 	call	8111e3a8 <sprintf>
						szName[i], (int) szVol[i], fVol);
				debug(fp, cDebugBuffer);
81103a40:	d0a05e17 	ldw	r2,-32392(gp)
81103a44:	01604574 	movhi	r5,33045
81103a48:	297b8b04 	addi	r5,r5,-4564
81103a4c:	1009883a 	mov	r4,r2
81103a50:	111ca180 	call	8111ca18 <fprintf>
			"VCCH_GXB", "VCC3P3_HSMC", "HSMB_VCCIO", };

	// show power
	bSuccess = POWER_Read(szVol);
	if (bSuccess) {
		for (i = 0; i < POWER_PORT_NUM && bSuccess; i++) {
81103a54:	e0bf0c17 	ldw	r2,-976(fp)
81103a58:	10800044 	addi	r2,r2,1
81103a5c:	e0bf0c15 	stw	r2,-976(fp)
81103a60:	e0bf0c17 	ldw	r2,-976(fp)
81103a64:	10800308 	cmpgei	r2,r2,12
81103a68:	1000021e 	bne	r2,zero,81103a74 <sense_log+0x6d0>
81103a6c:	e0bf0f17 	ldw	r2,-964(fp)
81103a70:	103eaf1e 	bne	r2,zero,81103530 <__reset+0xfb0e3530>
				debug(fp, cDebugBuffer);
#endif
			}
		}
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "\r\n");
81103a74:	00a04574 	movhi	r2,33045
81103a78:	10bb8b04 	addi	r2,r2,-4564
81103a7c:	00c00344 	movi	r3,13
81103a80:	10c00005 	stb	r3,0(r2)
81103a84:	00c00284 	movi	r3,10
81103a88:	10c00045 	stb	r3,1(r2)
81103a8c:	10000085 	stb	zero,2(r2)
		debug(fp, cDebugBuffer);
81103a90:	d0a05e17 	ldw	r2,-32392(gp)
81103a94:	01604574 	movhi	r5,33045
81103a98:	297b8b04 	addi	r5,r5,-4564
81103a9c:	1009883a 	mov	r4,r2
81103aa0:	111ca180 	call	8111ca18 <fprintf>
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
		debug(fp, cDebugBuffer);
#endif
	}
}
81103aa4:	00001606 	br	81103b00 <sense_log+0x75c>
		sprintf(cDebugBuffer, "\r\n");
		debug(fp, cDebugBuffer);
#endif
	} else {
#ifdef DEBUG_ON
		sprintf(cDebugBuffer, "Error\r\n");
81103aa8:	00a04574 	movhi	r2,33045
81103aac:	10bb8b04 	addi	r2,r2,-4564
81103ab0:	00c01144 	movi	r3,69
81103ab4:	10c00005 	stb	r3,0(r2)
81103ab8:	00c01c84 	movi	r3,114
81103abc:	10c00045 	stb	r3,1(r2)
81103ac0:	00c01c84 	movi	r3,114
81103ac4:	10c00085 	stb	r3,2(r2)
81103ac8:	00c01bc4 	movi	r3,111
81103acc:	10c000c5 	stb	r3,3(r2)
81103ad0:	00c01c84 	movi	r3,114
81103ad4:	10c00105 	stb	r3,4(r2)
81103ad8:	00c00344 	movi	r3,13
81103adc:	10c00145 	stb	r3,5(r2)
81103ae0:	00c00284 	movi	r3,10
81103ae4:	10c00185 	stb	r3,6(r2)
81103ae8:	100001c5 	stb	zero,7(r2)
		debug(fp, cDebugBuffer);
81103aec:	d0a05e17 	ldw	r2,-32392(gp)
81103af0:	01604574 	movhi	r5,33045
81103af4:	297b8b04 	addi	r5,r5,-4564
81103af8:	1009883a 	mov	r4,r2
81103afc:	111ca180 	call	8111ca18 <fprintf>
#endif
	}
}
81103b00:	0001883a 	nop
81103b04:	e6fffa04 	addi	sp,fp,-24
81103b08:	dfc00717 	ldw	ra,28(sp)
81103b0c:	df000617 	ldw	fp,24(sp)
81103b10:	dd400517 	ldw	r21,20(sp)
81103b14:	dd000417 	ldw	r20,16(sp)
81103b18:	dcc00317 	ldw	r19,12(sp)
81103b1c:	dc800217 	ldw	r18,8(sp)
81103b20:	dc400117 	ldw	r17,4(sp)
81103b24:	dc000017 	ldw	r16,0(sp)
81103b28:	dec00804 	addi	sp,sp,32
81103b2c:	f800283a 	ret

81103b30 <bSdmaInitM1Dma>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSdmaInitM1Dma(void) {
81103b30:	defffc04 	addi	sp,sp,-16
81103b34:	de00012e 	bgeu	sp,et,81103b3c <bSdmaInitM1Dma+0xc>
81103b38:	003b68fa 	trap	3
81103b3c:	dfc00315 	stw	ra,12(sp)
81103b40:	df000215 	stw	fp,8(sp)
81103b44:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103b48:	00800044 	movi	r2,1
81103b4c:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103b50:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM1Dev = alt_msgdma_open((char *) SDMA_DMA_M1_NAME);
81103b54:	01204574 	movhi	r4,33045
81103b58:	21210204 	addi	r4,r4,-31736
81103b5c:	1145d880 	call	81145d88 <alt_msgdma_open>
81103b60:	d0a03915 	stw	r2,-32540(gp)

	// check if the device was opened
	if (pxDmaM1Dev == NULL) {
81103b64:	d0a03917 	ldw	r2,-32540(gp)
81103b68:	1000021e 	bne	r2,zero,81103b74 <bSdmaInitM1Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103b6c:	e03ffe15 	stw	zero,-8(fp)
81103b70:	00001506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
81103b74:	d0a03917 	ldw	r2,-32540(gp)
81103b78:	10800317 	ldw	r2,12(r2)
81103b7c:	10800104 	addi	r2,r2,4
81103b80:	00c00084 	movi	r3,2
81103b84:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103b88:	00000a06 	br	81103bb4 <bSdmaInitM1Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103b8c:	01000044 	movi	r4,1
81103b90:	1133cf00 	call	81133cf0 <usleep>
			usiCounter++;
81103b94:	e0bfff0b 	ldhu	r2,-4(fp)
81103b98:	10800044 	addi	r2,r2,1
81103b9c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103ba0:	e0bfff0b 	ldhu	r2,-4(fp)
81103ba4:	1084e230 	cmpltui	r2,r2,5000
81103ba8:	1000021e 	bne	r2,zero,81103bb4 <bSdmaInitM1Dma+0x84>
				bStatus = FALSE;
81103bac:	e03ffe15 	stw	zero,-8(fp)
				break;
81103bb0:	00000506 	br	81103bc8 <bSdmaInitM1Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bb4:	d0a03917 	ldw	r2,-32540(gp)
81103bb8:	10800317 	ldw	r2,12(r2)
81103bbc:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103bc0:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM1Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103bc4:	103ff11e 	bne	r2,zero,81103b8c <__reset+0xfb0e3b8c>
				break;
			}
		}
	}

	return bStatus;
81103bc8:	e0bffe17 	ldw	r2,-8(fp)
}
81103bcc:	e037883a 	mov	sp,fp
81103bd0:	dfc00117 	ldw	ra,4(sp)
81103bd4:	df000017 	ldw	fp,0(sp)
81103bd8:	dec00204 	addi	sp,sp,8
81103bdc:	f800283a 	ret

81103be0 <bSdmaInitM2Dma>:

bool bSdmaInitM2Dma(void) {
81103be0:	defffc04 	addi	sp,sp,-16
81103be4:	de00012e 	bgeu	sp,et,81103bec <bSdmaInitM2Dma+0xc>
81103be8:	003b68fa 	trap	3
81103bec:	dfc00315 	stw	ra,12(sp)
81103bf0:	df000215 	stw	fp,8(sp)
81103bf4:	df000204 	addi	fp,sp,8
	bool bStatus = TRUE;
81103bf8:	00800044 	movi	r2,1
81103bfc:	e0bffe15 	stw	r2,-8(fp)
	alt_u16 usiCounter = 0;
81103c00:	e03fff0d 	sth	zero,-4(fp)

	// open dma device
	pxDmaM2Dev = alt_msgdma_open((char *) SDMA_DMA_M2_NAME);
81103c04:	01204574 	movhi	r4,33045
81103c08:	21210704 	addi	r4,r4,-31716
81103c0c:	1145d880 	call	81145d88 <alt_msgdma_open>
81103c10:	d0a03a15 	stw	r2,-32536(gp)

	// check if the device was opened
	if (pxDmaM2Dev == NULL) {
81103c14:	d0a03a17 	ldw	r2,-32536(gp)
81103c18:	1000021e 	bne	r2,zero,81103c24 <bSdmaInitM2Dma+0x44>
		// device not opened
		bStatus = FALSE;
81103c1c:	e03ffe15 	stw	zero,-8(fp)
81103c20:	00001506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
81103c24:	d0a03a17 	ldw	r2,-32536(gp)
81103c28:	10800317 	ldw	r2,12(r2)
81103c2c:	10800104 	addi	r2,r2,4
81103c30:	00c00084 	movi	r3,2
81103c34:	10c00035 	stwio	r3,0(r2)
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c38:	00000a06 	br	81103c64 <bSdmaInitM2Dma+0x84>
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
			usleep(1);
81103c3c:	01000044 	movi	r4,1
81103c40:	1133cf00 	call	81133cf0 <usleep>
			usiCounter++;
81103c44:	e0bfff0b 	ldhu	r2,-4(fp)
81103c48:	10800044 	addi	r2,r2,1
81103c4c:	e0bfff0d 	sth	r2,-4(fp)
			if (5000 <= usiCounter) { //wait at most 5ms for the device to be reseted
81103c50:	e0bfff0b 	ldhu	r2,-4(fp)
81103c54:	1084e230 	cmpltui	r2,r2,5000
81103c58:	1000021e 	bne	r2,zero,81103c64 <bSdmaInitM2Dma+0x84>
				bStatus = FALSE;
81103c5c:	e03ffe15 	stw	zero,-8(fp)
				break;
81103c60:	00000506 	br	81103c78 <bSdmaInitM2Dma+0x98>
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c64:	d0a03a17 	ldw	r2,-32536(gp)
81103c68:	10800317 	ldw	r2,12(r2)
81103c6c:	10800037 	ldwio	r2,0(r2)
				& ALTERA_MSGDMA_CSR_RESET_STATE_MASK) {
81103c70:	1080100c 	andi	r2,r2,64
	} else {
		// device opened
		// reset the dispatcher
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(pxDmaM2Dev->csr_base,
				ALTERA_MSGDMA_CSR_RESET_MASK);
		while (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
81103c74:	103ff11e 	bne	r2,zero,81103c3c <__reset+0xfb0e3c3c>
				break;
			}
		}
	}

	return bStatus;
81103c78:	e0bffe17 	ldw	r2,-8(fp)
}
81103c7c:	e037883a 	mov	sp,fp
81103c80:	dfc00117 	ldw	ra,4(sp)
81103c84:	df000017 	ldw	fp,0(sp)
81103c88:	dec00204 	addi	sp,sp,8
81103c8c:	f800283a 	ret

81103c90 <bSdmaDmaM1Transfer>:

bool bSdmaDmaM1Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
81103c90:	deffe904 	addi	sp,sp,-92
81103c94:	de00012e 	bgeu	sp,et,81103c9c <bSdmaDmaM1Transfer+0xc>
81103c98:	003b68fa 	trap	3
81103c9c:	dfc01615 	stw	ra,88(sp)
81103ca0:	df001515 	stw	fp,84(sp)
81103ca4:	dc001415 	stw	r16,80(sp)
81103ca8:	df001504 	addi	fp,sp,84
81103cac:	e13ffb15 	stw	r4,-20(fp)
81103cb0:	2809883a 	mov	r4,r5
81103cb4:	3007883a 	mov	r3,r6
81103cb8:	3805883a 	mov	r2,r7
81103cbc:	e13ffc0d 	sth	r4,-16(fp)
81103cc0:	e0fffd05 	stb	r3,-12(fp)
81103cc4:	e0bffe05 	stb	r2,-8(fp)
81103cc8:	defff004 	addi	sp,sp,-64
81103ccc:	d8800904 	addi	r2,sp,36
81103cd0:	108007c4 	addi	r2,r2,31
81103cd4:	1004d17a 	srli	r2,r2,5
81103cd8:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
81103cdc:	00800044 	movi	r2,1
81103ce0:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
81103ce4:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
81103ce8:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
81103cec:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
81103cf0:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81103cf4:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81103cf8:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81103cfc:	e0bffe03 	ldbu	r2,-8(fp)
81103d00:	10c00228 	cmpgeui	r3,r2,8
81103d04:	18009c1e 	bne	r3,zero,81103f78 <bSdmaDmaM1Transfer+0x2e8>
81103d08:	100690ba 	slli	r3,r2,2
81103d0c:	00a04434 	movhi	r2,33040
81103d10:	108f4804 	addi	r2,r2,15648
81103d14:	1885883a 	add	r2,r3,r2
81103d18:	10800017 	ldw	r2,0(r2)
81103d1c:	1000683a 	jmp	r2
81103d20:	81103d40 	call	881103d4 <__reset+0x20f03d4>
81103d24:	81103d80 	call	881103d8 <__reset+0x20f03d8>
81103d28:	81103dc8 	cmpgei	r4,r16,16631
81103d2c:	81103e10 	cmplti	r4,r16,16632
81103d30:	81103e58 	cmpnei	r4,r16,16633
81103d34:	81103ea0 	cmpeqi	r4,r16,16634
81103d38:	81103ee8 	cmpgeui	r4,r16,16635
81103d3c:	81103f30 	cmpltui	r4,r16,16636
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
81103d40:	e0bffd03 	ldbu	r2,-12(fp)
81103d44:	10000626 	beq	r2,zero,81103d60 <bSdmaDmaM1Transfer+0xd0>
81103d48:	10800060 	cmpeqi	r2,r2,1
81103d4c:	10000926 	beq	r2,zero,81103d74 <bSdmaDmaM1Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
81103d50:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81103d54:	00800044 	movi	r2,1
81103d58:	e0bff715 	stw	r2,-36(fp)
			break;
81103d5c:	00000706 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
81103d60:	00800074 	movhi	r2,1
81103d64:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81103d68:	00800044 	movi	r2,1
81103d6c:	e0bff715 	stw	r2,-36(fp)
			break;
81103d70:	00000206 	br	81103d7c <bSdmaDmaM1Transfer+0xec>
		default:
			bStatus = FALSE;
81103d74:	e03ff415 	stw	zero,-48(fp)
			break;
81103d78:	0001883a 	nop
		}
		break;
81103d7c:	00008006 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
81103d80:	e0bffd03 	ldbu	r2,-12(fp)
81103d84:	10000726 	beq	r2,zero,81103da4 <bSdmaDmaM1Transfer+0x114>
81103d88:	10800060 	cmpeqi	r2,r2,1
81103d8c:	10000b26 	beq	r2,zero,81103dbc <bSdmaDmaM1Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
81103d90:	00880004 	movi	r2,8192
81103d94:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
81103d98:	00800044 	movi	r2,1
81103d9c:	e0bff715 	stw	r2,-36(fp)
			break;
81103da0:	00000806 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
81103da4:	00800074 	movhi	r2,1
81103da8:	10880004 	addi	r2,r2,8192
81103dac:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
81103db0:	00800044 	movi	r2,1
81103db4:	e0bff715 	stw	r2,-36(fp)
			break;
81103db8:	00000206 	br	81103dc4 <bSdmaDmaM1Transfer+0x134>
		default:
			bStatus = FALSE;
81103dbc:	e03ff415 	stw	zero,-48(fp)
			break;
81103dc0:	0001883a 	nop
		}
		break;
81103dc4:	00006e06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
81103dc8:	e0bffd03 	ldbu	r2,-12(fp)
81103dcc:	10000726 	beq	r2,zero,81103dec <bSdmaDmaM1Transfer+0x15c>
81103dd0:	10800060 	cmpeqi	r2,r2,1
81103dd4:	10000b26 	beq	r2,zero,81103e04 <bSdmaDmaM1Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
81103dd8:	00900004 	movi	r2,16384
81103ddc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
81103de0:	00800044 	movi	r2,1
81103de4:	e0bff715 	stw	r2,-36(fp)
			break;
81103de8:	00000806 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
81103dec:	00800074 	movhi	r2,1
81103df0:	10900004 	addi	r2,r2,16384
81103df4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81103df8:	00800044 	movi	r2,1
81103dfc:	e0bff715 	stw	r2,-36(fp)
			break;
81103e00:	00000206 	br	81103e0c <bSdmaDmaM1Transfer+0x17c>
		default:
			bStatus = FALSE;
81103e04:	e03ff415 	stw	zero,-48(fp)
			break;
81103e08:	0001883a 	nop
		}
		break;
81103e0c:	00005c06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
81103e10:	e0bffd03 	ldbu	r2,-12(fp)
81103e14:	10000726 	beq	r2,zero,81103e34 <bSdmaDmaM1Transfer+0x1a4>
81103e18:	10800060 	cmpeqi	r2,r2,1
81103e1c:	10000b26 	beq	r2,zero,81103e4c <bSdmaDmaM1Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
81103e20:	00980004 	movi	r2,24576
81103e24:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81103e28:	00800044 	movi	r2,1
81103e2c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e30:	00000806 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81103e34:	00800074 	movhi	r2,1
81103e38:	10980004 	addi	r2,r2,24576
81103e3c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
81103e40:	00800044 	movi	r2,1
81103e44:	e0bff715 	stw	r2,-36(fp)
			break;
81103e48:	00000206 	br	81103e54 <bSdmaDmaM1Transfer+0x1c4>
		default:
			bStatus = FALSE;
81103e4c:	e03ff415 	stw	zero,-48(fp)
			break;
81103e50:	0001883a 	nop
		}
		break;
81103e54:	00004a06 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81103e58:	e0bffd03 	ldbu	r2,-12(fp)
81103e5c:	10000726 	beq	r2,zero,81103e7c <bSdmaDmaM1Transfer+0x1ec>
81103e60:	10800060 	cmpeqi	r2,r2,1
81103e64:	10000b26 	beq	r2,zero,81103e94 <bSdmaDmaM1Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81103e68:	00a00014 	movui	r2,32768
81103e6c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
81103e70:	00800044 	movi	r2,1
81103e74:	e0bff715 	stw	r2,-36(fp)
			break;
81103e78:	00000806 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81103e7c:	008000b4 	movhi	r2,2
81103e80:	10a00004 	addi	r2,r2,-32768
81103e84:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81103e88:	00800044 	movi	r2,1
81103e8c:	e0bff715 	stw	r2,-36(fp)
			break;
81103e90:	00000206 	br	81103e9c <bSdmaDmaM1Transfer+0x20c>
		default:
			bStatus = FALSE;
81103e94:	e03ff415 	stw	zero,-48(fp)
			break;
81103e98:	0001883a 	nop
		}
		break;
81103e9c:	00003806 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
81103ea0:	e0bffd03 	ldbu	r2,-12(fp)
81103ea4:	10000726 	beq	r2,zero,81103ec4 <bSdmaDmaM1Transfer+0x234>
81103ea8:	10800060 	cmpeqi	r2,r2,1
81103eac:	10000b26 	beq	r2,zero,81103edc <bSdmaDmaM1Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
81103eb0:	00a80014 	movui	r2,40960
81103eb4:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
81103eb8:	00800044 	movi	r2,1
81103ebc:	e0bff715 	stw	r2,-36(fp)
			break;
81103ec0:	00000806 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
81103ec4:	008000b4 	movhi	r2,2
81103ec8:	10a80004 	addi	r2,r2,-24576
81103ecc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
81103ed0:	00800044 	movi	r2,1
81103ed4:	e0bff715 	stw	r2,-36(fp)
			break;
81103ed8:	00000206 	br	81103ee4 <bSdmaDmaM1Transfer+0x254>
		default:
			bStatus = FALSE;
81103edc:	e03ff415 	stw	zero,-48(fp)
			break;
81103ee0:	0001883a 	nop
		}
		break;
81103ee4:	00002606 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
81103ee8:	e0bffd03 	ldbu	r2,-12(fp)
81103eec:	10000726 	beq	r2,zero,81103f0c <bSdmaDmaM1Transfer+0x27c>
81103ef0:	10800060 	cmpeqi	r2,r2,1
81103ef4:	10000b26 	beq	r2,zero,81103f24 <bSdmaDmaM1Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81103ef8:	00b00014 	movui	r2,49152
81103efc:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
81103f00:	00800044 	movi	r2,1
81103f04:	e0bff715 	stw	r2,-36(fp)
			break;
81103f08:	00000806 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81103f0c:	008000b4 	movhi	r2,2
81103f10:	10b00004 	addi	r2,r2,-16384
81103f14:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81103f18:	00800044 	movi	r2,1
81103f1c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f20:	00000206 	br	81103f2c <bSdmaDmaM1Transfer+0x29c>
		default:
			bStatus = FALSE;
81103f24:	e03ff415 	stw	zero,-48(fp)
			break;
81103f28:	0001883a 	nop
		}
		break;
81103f2c:	00001406 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
81103f30:	e0bffd03 	ldbu	r2,-12(fp)
81103f34:	10000726 	beq	r2,zero,81103f54 <bSdmaDmaM1Transfer+0x2c4>
81103f38:	10800060 	cmpeqi	r2,r2,1
81103f3c:	10000b26 	beq	r2,zero,81103f6c <bSdmaDmaM1Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
81103f40:	00b80014 	movui	r2,57344
81103f44:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81103f48:	00800044 	movi	r2,1
81103f4c:	e0bff715 	stw	r2,-36(fp)
			break;
81103f50:	00000806 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81103f54:	008000b4 	movhi	r2,2
81103f58:	10b80004 	addi	r2,r2,-8192
81103f5c:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
81103f60:	00800044 	movi	r2,1
81103f64:	e0bff715 	stw	r2,-36(fp)
			break;
81103f68:	00000206 	br	81103f74 <bSdmaDmaM1Transfer+0x2e4>
		default:
			bStatus = FALSE;
81103f6c:	e03ff415 	stw	zero,-48(fp)
			break;
81103f70:	0001883a 	nop
		}
		break;
81103f74:	00000206 	br	81103f80 <bSdmaDmaM1Transfer+0x2f0>
	default:
		bStatus = FALSE;
81103f78:	e03ff415 	stw	zero,-48(fp)
		break;
81103f7c:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M1_BASE_ADDR_LOW
81103f80:	e0bffb17 	ldw	r2,-20(fp)
81103f84:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81103f88:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
81103f8c:	e0bff417 	ldw	r2,-48(fp)
81103f90:	10003b26 	beq	r2,zero,81104080 <bSdmaDmaM1Transfer+0x3f0>
		if (pxDmaM1Dev == NULL) {
81103f94:	d0a03917 	ldw	r2,-32540(gp)
81103f98:	1000021e 	bne	r2,zero,81103fa4 <bSdmaDmaM1Transfer+0x314>
			bStatus = FALSE;
81103f9c:	e03ff415 	stw	zero,-48(fp)
81103fa0:	00003706 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81103fa4:	e03ff50d 	sth	zero,-44(fp)
81103fa8:	00003206 	br	81104074 <bSdmaDmaM1Transfer+0x3e4>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
81103fac:	01000044 	movi	r4,1
81103fb0:	113227c0 	call	8113227c <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
81103fb4:	d0a03917 	ldw	r2,-32540(gp)
81103fb8:	10800317 	ldw	r2,12(r2)
81103fbc:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
81103fc0:	1080010c 	andi	r2,r2,4
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
81103fc4:	103ff91e 	bne	r2,zero,81103fac <__reset+0xfb0e3fac>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM1Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM1Dev,
81103fc8:	d2203917 	ldw	r8,-32540(gp)
81103fcc:	e17ff817 	ldw	r5,-32(fp)
81103fd0:	e1bff617 	ldw	r6,-40(fp)
81103fd4:	e0bff917 	ldw	r2,-28(fp)
81103fd8:	e0fff717 	ldw	r3,-36(fp)
81103fdc:	01000044 	movi	r4,1
81103fe0:	d9000815 	stw	r4,32(sp)
81103fe4:	01000044 	movi	r4,1
81103fe8:	d9000715 	stw	r4,28(sp)
81103fec:	01000044 	movi	r4,1
81103ff0:	d9000615 	stw	r4,24(sp)
81103ff4:	01000044 	movi	r4,1
81103ff8:	d9000515 	stw	r4,20(sp)
81103ffc:	01000044 	movi	r4,1
81104000:	d9000415 	stw	r4,16(sp)
81104004:	d8c00315 	stw	r3,12(sp)
81104008:	d8800215 	stw	r2,8(sp)
8110400c:	e0bffa17 	ldw	r2,-24(fp)
81104010:	d8800115 	stw	r2,4(sp)
81104014:	00802204 	movi	r2,136
81104018:	d8800015 	stw	r2,0(sp)
8110401c:	300f883a 	mov	r7,r6
81104020:	280d883a 	mov	r6,r5
81104024:	800b883a 	mov	r5,r16
81104028:	4009883a 	mov	r4,r8
8110402c:	110ad000 	call	8110ad00 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104030:	10000226 	beq	r2,zero,8110403c <bSdmaDmaM1Transfer+0x3ac>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104034:	e03ff415 	stw	zero,-48(fp)
					break;
81104038:	00001106 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM1Dev,
8110403c:	d0a03917 	ldw	r2,-32540(gp)
81104040:	800b883a 	mov	r5,r16
81104044:	1009883a 	mov	r4,r2
81104048:	110ae040 	call	8110ae04 <iMsgdmaExtendedDescriptorSyncTransfer>
8110404c:	10000226 	beq	r2,zero,81104058 <bSdmaDmaM1Transfer+0x3c8>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104050:	e03ff415 	stw	zero,-48(fp)
						break;
81104054:	00000a06 	br	81104080 <bSdmaDmaM1Transfer+0x3f0>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
81104058:	e0bff817 	ldw	r2,-32(fp)
8110405c:	10802204 	addi	r2,r2,136
81104060:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
81104064:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM1Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
81104068:	e0bff50b 	ldhu	r2,-44(fp)
8110406c:	10800044 	addi	r2,r2,1
81104070:	e0bff50d 	sth	r2,-44(fp)
81104074:	e0fff50b 	ldhu	r3,-44(fp)
81104078:	e0bffc0b 	ldhu	r2,-16(fp)
8110407c:	18bfcd36 	bltu	r3,r2,81103fb4 <__reset+0xfb0e3fb4>
					uliSrcAddrHigh = (alt_u32) SDMA_M1_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104080:	e0bff417 	ldw	r2,-48(fp)
}
81104084:	e6ffff04 	addi	sp,fp,-4
81104088:	dfc00217 	ldw	ra,8(sp)
8110408c:	df000117 	ldw	fp,4(sp)
81104090:	dc000017 	ldw	r16,0(sp)
81104094:	dec00304 	addi	sp,sp,12
81104098:	f800283a 	ret

8110409c <bSdmaDmaM2Transfer>:

bool bSdmaDmaM2Transfer(alt_u32 *uliDdrInitialAddr,
		alt_u16 usiTransferSizeInBlocks, alt_u8 ucBufferSide,
		alt_u8 ucChBufferId) {
8110409c:	deffe904 	addi	sp,sp,-92
811040a0:	de00012e 	bgeu	sp,et,811040a8 <bSdmaDmaM2Transfer+0xc>
811040a4:	003b68fa 	trap	3
811040a8:	dfc01615 	stw	ra,88(sp)
811040ac:	df001515 	stw	fp,84(sp)
811040b0:	dc001415 	stw	r16,80(sp)
811040b4:	df001504 	addi	fp,sp,84
811040b8:	e13ffb15 	stw	r4,-20(fp)
811040bc:	2809883a 	mov	r4,r5
811040c0:	3007883a 	mov	r3,r6
811040c4:	3805883a 	mov	r2,r7
811040c8:	e13ffc0d 	sth	r4,-16(fp)
811040cc:	e0fffd05 	stb	r3,-12(fp)
811040d0:	e0bffe05 	stb	r2,-8(fp)
811040d4:	defff004 	addi	sp,sp,-64
811040d8:	d8800904 	addi	r2,sp,36
811040dc:	108007c4 	addi	r2,r2,31
811040e0:	1004d17a 	srli	r2,r2,5
811040e4:	1020917a 	slli	r16,r2,5
	bool bStatus = TRUE;
811040e8:	00800044 	movi	r2,1
811040ec:	e0bff415 	stw	r2,-48(fp)
	alt_u16 usiCnt = 0;
811040f0:	e03ff50d 	sth	zero,-44(fp)

	alt_msgdma_extended_descriptor xDmaExtendedDescriptor;

	alt_u32 uliDestAddrLow = 0;
811040f4:	e03ff615 	stw	zero,-40(fp)
	alt_u32 uliDestAddrHigh = 0;
811040f8:	e03ff715 	stw	zero,-36(fp)

	alt_u32 uliSrcAddrLow = 0;
811040fc:	e03ff815 	stw	zero,-32(fp)
	alt_u32 uliSrcAddrHigh = 0;
81104100:	e03ff915 	stw	zero,-28(fp)

	alt_u32 uliControlBits = 0x00000000;
81104104:	e03ffa15 	stw	zero,-24(fp)

	switch (ucChBufferId) {
81104108:	e0bffe03 	ldbu	r2,-8(fp)
8110410c:	10c00228 	cmpgeui	r3,r2,8
81104110:	18009c1e 	bne	r3,zero,81104384 <bSdmaDmaM2Transfer+0x2e8>
81104114:	100690ba 	slli	r3,r2,2
81104118:	00a04434 	movhi	r2,33040
8110411c:	10904b04 	addi	r2,r2,16684
81104120:	1885883a 	add	r2,r3,r2
81104124:	10800017 	ldw	r2,0(r2)
81104128:	1000683a 	jmp	r2
8110412c:	8110414c 	andi	r4,r16,16645
81104130:	8110418c 	andi	r4,r16,16646
81104134:	811041d4 	ori	r4,r16,16647
81104138:	8110421c 	xori	r4,r16,16648
8110413c:	81104264 	muli	r4,r16,16649
81104140:	811042ac 	andhi	r4,r16,16650
81104144:	811042f4 	orhi	r4,r16,16651
81104148:	8110433c 	xorhi	r4,r16,16652
	case eSdmaCh1Buffer:
		switch (ucBufferSide) {
8110414c:	e0bffd03 	ldbu	r2,-12(fp)
81104150:	10000626 	beq	r2,zero,8110416c <bSdmaDmaM2Transfer+0xd0>
81104154:	10800060 	cmpeqi	r2,r2,1
81104158:	10000926 	beq	r2,zero,81104180 <bSdmaDmaM2Transfer+0xe4>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_LOW;
8110415c:	e03ff615 	stw	zero,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_R_BUFF_BASE_ADDR_HIGH;
81104160:	00800044 	movi	r2,1
81104164:	e0bff715 	stw	r2,-36(fp)
			break;
81104168:	00000706 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_LOW;
8110416c:	00800074 	movhi	r2,1
81104170:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_1_L_BUFF_BASE_ADDR_HIGH;
81104174:	00800044 	movi	r2,1
81104178:	e0bff715 	stw	r2,-36(fp)
			break;
8110417c:	00000206 	br	81104188 <bSdmaDmaM2Transfer+0xec>
		default:
			bStatus = FALSE;
81104180:	e03ff415 	stw	zero,-48(fp)
			break;
81104184:	0001883a 	nop
		}
		break;
81104188:	00008006 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh2Buffer:
		switch (ucBufferSide) {
8110418c:	e0bffd03 	ldbu	r2,-12(fp)
81104190:	10000726 	beq	r2,zero,811041b0 <bSdmaDmaM2Transfer+0x114>
81104194:	10800060 	cmpeqi	r2,r2,1
81104198:	10000b26 	beq	r2,zero,811041c8 <bSdmaDmaM2Transfer+0x12c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_LOW;
8110419c:	00880004 	movi	r2,8192
811041a0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_R_BUFF_BASE_ADDR_HIGH;
811041a4:	00800044 	movi	r2,1
811041a8:	e0bff715 	stw	r2,-36(fp)
			break;
811041ac:	00000806 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_LOW;
811041b0:	00800074 	movhi	r2,1
811041b4:	10880004 	addi	r2,r2,8192
811041b8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_2_L_BUFF_BASE_ADDR_HIGH;
811041bc:	00800044 	movi	r2,1
811041c0:	e0bff715 	stw	r2,-36(fp)
			break;
811041c4:	00000206 	br	811041d0 <bSdmaDmaM2Transfer+0x134>
		default:
			bStatus = FALSE;
811041c8:	e03ff415 	stw	zero,-48(fp)
			break;
811041cc:	0001883a 	nop
		}
		break;
811041d0:	00006e06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh3Buffer:
		switch (ucBufferSide) {
811041d4:	e0bffd03 	ldbu	r2,-12(fp)
811041d8:	10000726 	beq	r2,zero,811041f8 <bSdmaDmaM2Transfer+0x15c>
811041dc:	10800060 	cmpeqi	r2,r2,1
811041e0:	10000b26 	beq	r2,zero,81104210 <bSdmaDmaM2Transfer+0x174>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_LOW;
811041e4:	00900004 	movi	r2,16384
811041e8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_R_BUFF_BASE_ADDR_HIGH;
811041ec:	00800044 	movi	r2,1
811041f0:	e0bff715 	stw	r2,-36(fp)
			break;
811041f4:	00000806 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_LOW;
811041f8:	00800074 	movhi	r2,1
811041fc:	10900004 	addi	r2,r2,16384
81104200:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_3_L_BUFF_BASE_ADDR_HIGH;
81104204:	00800044 	movi	r2,1
81104208:	e0bff715 	stw	r2,-36(fp)
			break;
8110420c:	00000206 	br	81104218 <bSdmaDmaM2Transfer+0x17c>
		default:
			bStatus = FALSE;
81104210:	e03ff415 	stw	zero,-48(fp)
			break;
81104214:	0001883a 	nop
		}
		break;
81104218:	00005c06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh4Buffer:
		switch (ucBufferSide) {
8110421c:	e0bffd03 	ldbu	r2,-12(fp)
81104220:	10000726 	beq	r2,zero,81104240 <bSdmaDmaM2Transfer+0x1a4>
81104224:	10800060 	cmpeqi	r2,r2,1
81104228:	10000b26 	beq	r2,zero,81104258 <bSdmaDmaM2Transfer+0x1bc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_LOW;
8110422c:	00980004 	movi	r2,24576
81104230:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_R_BUFF_BASE_ADDR_HIGH;
81104234:	00800044 	movi	r2,1
81104238:	e0bff715 	stw	r2,-36(fp)
			break;
8110423c:	00000806 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_LOW;
81104240:	00800074 	movhi	r2,1
81104244:	10980004 	addi	r2,r2,24576
81104248:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_4_L_BUFF_BASE_ADDR_HIGH;
8110424c:	00800044 	movi	r2,1
81104250:	e0bff715 	stw	r2,-36(fp)
			break;
81104254:	00000206 	br	81104260 <bSdmaDmaM2Transfer+0x1c4>
		default:
			bStatus = FALSE;
81104258:	e03ff415 	stw	zero,-48(fp)
			break;
8110425c:	0001883a 	nop
		}
		break;
81104260:	00004a06 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh5Buffer:
		switch (ucBufferSide) {
81104264:	e0bffd03 	ldbu	r2,-12(fp)
81104268:	10000726 	beq	r2,zero,81104288 <bSdmaDmaM2Transfer+0x1ec>
8110426c:	10800060 	cmpeqi	r2,r2,1
81104270:	10000b26 	beq	r2,zero,811042a0 <bSdmaDmaM2Transfer+0x204>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_LOW;
81104274:	00a00014 	movui	r2,32768
81104278:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_R_BUFF_BASE_ADDR_HIGH;
8110427c:	00800044 	movi	r2,1
81104280:	e0bff715 	stw	r2,-36(fp)
			break;
81104284:	00000806 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_LOW;
81104288:	008000b4 	movhi	r2,2
8110428c:	10a00004 	addi	r2,r2,-32768
81104290:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_5_L_BUFF_BASE_ADDR_HIGH;
81104294:	00800044 	movi	r2,1
81104298:	e0bff715 	stw	r2,-36(fp)
			break;
8110429c:	00000206 	br	811042a8 <bSdmaDmaM2Transfer+0x20c>
		default:
			bStatus = FALSE;
811042a0:	e03ff415 	stw	zero,-48(fp)
			break;
811042a4:	0001883a 	nop
		}
		break;
811042a8:	00003806 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh6Buffer:
		switch (ucBufferSide) {
811042ac:	e0bffd03 	ldbu	r2,-12(fp)
811042b0:	10000726 	beq	r2,zero,811042d0 <bSdmaDmaM2Transfer+0x234>
811042b4:	10800060 	cmpeqi	r2,r2,1
811042b8:	10000b26 	beq	r2,zero,811042e8 <bSdmaDmaM2Transfer+0x24c>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_LOW;
811042bc:	00a80014 	movui	r2,40960
811042c0:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_R_BUFF_BASE_ADDR_HIGH;
811042c4:	00800044 	movi	r2,1
811042c8:	e0bff715 	stw	r2,-36(fp)
			break;
811042cc:	00000806 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_LOW;
811042d0:	008000b4 	movhi	r2,2
811042d4:	10a80004 	addi	r2,r2,-24576
811042d8:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_6_L_BUFF_BASE_ADDR_HIGH;
811042dc:	00800044 	movi	r2,1
811042e0:	e0bff715 	stw	r2,-36(fp)
			break;
811042e4:	00000206 	br	811042f0 <bSdmaDmaM2Transfer+0x254>
		default:
			bStatus = FALSE;
811042e8:	e03ff415 	stw	zero,-48(fp)
			break;
811042ec:	0001883a 	nop
		}
		break;
811042f0:	00002606 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh7Buffer:
		switch (ucBufferSide) {
811042f4:	e0bffd03 	ldbu	r2,-12(fp)
811042f8:	10000726 	beq	r2,zero,81104318 <bSdmaDmaM2Transfer+0x27c>
811042fc:	10800060 	cmpeqi	r2,r2,1
81104300:	10000b26 	beq	r2,zero,81104330 <bSdmaDmaM2Transfer+0x294>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_LOW;
81104304:	00b00014 	movui	r2,49152
81104308:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_R_BUFF_BASE_ADDR_HIGH;
8110430c:	00800044 	movi	r2,1
81104310:	e0bff715 	stw	r2,-36(fp)
			break;
81104314:	00000806 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_LOW;
81104318:	008000b4 	movhi	r2,2
8110431c:	10b00004 	addi	r2,r2,-16384
81104320:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_7_L_BUFF_BASE_ADDR_HIGH;
81104324:	00800044 	movi	r2,1
81104328:	e0bff715 	stw	r2,-36(fp)
			break;
8110432c:	00000206 	br	81104338 <bSdmaDmaM2Transfer+0x29c>
		default:
			bStatus = FALSE;
81104330:	e03ff415 	stw	zero,-48(fp)
			break;
81104334:	0001883a 	nop
		}
		break;
81104338:	00001406 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	case eSdmaCh8Buffer:
		switch (ucBufferSide) {
8110433c:	e0bffd03 	ldbu	r2,-12(fp)
81104340:	10000726 	beq	r2,zero,81104360 <bSdmaDmaM2Transfer+0x2c4>
81104344:	10800060 	cmpeqi	r2,r2,1
81104348:	10000b26 	beq	r2,zero,81104378 <bSdmaDmaM2Transfer+0x2dc>
		case eSdmaRightBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_LOW;
8110434c:	00b80014 	movui	r2,57344
81104350:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_R_BUFF_BASE_ADDR_HIGH;
81104354:	00800044 	movi	r2,1
81104358:	e0bff715 	stw	r2,-36(fp)
			break;
8110435c:	00000806 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		case eSdmaLeftBuffer:
			uliDestAddrLow = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_LOW;
81104360:	008000b4 	movhi	r2,2
81104364:	10b80004 	addi	r2,r2,-8192
81104368:	e0bff615 	stw	r2,-40(fp)
			uliDestAddrHigh = (alt_u32) SDMA_CH_8_L_BUFF_BASE_ADDR_HIGH;
8110436c:	00800044 	movi	r2,1
81104370:	e0bff715 	stw	r2,-36(fp)
			break;
81104374:	00000206 	br	81104380 <bSdmaDmaM2Transfer+0x2e4>
		default:
			bStatus = FALSE;
81104378:	e03ff415 	stw	zero,-48(fp)
			break;
8110437c:	0001883a 	nop
		}
		break;
81104380:	00000206 	br	8110438c <bSdmaDmaM2Transfer+0x2f0>
	default:
		bStatus = FALSE;
81104384:	e03ff415 	stw	zero,-48(fp)
		break;
81104388:	0001883a 	nop
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
			+ (alt_u32) uliDdrInitialAddr;
8110438c:	e0fffb17 	ldw	r3,-20(fp)
	default:
		bStatus = FALSE;
		break;
	}

	uliSrcAddrLow = (alt_u32) SDMA_M2_BASE_ADDR_LOW
81104390:	00a00034 	movhi	r2,32768
81104394:	1885883a 	add	r2,r3,r2
81104398:	e0bff815 	stw	r2,-32(fp)
			+ (alt_u32) uliDdrInitialAddr;
	uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
8110439c:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
811043a0:	e0bff417 	ldw	r2,-48(fp)
811043a4:	10003b26 	beq	r2,zero,81104494 <bSdmaDmaM2Transfer+0x3f8>
		if (pxDmaM2Dev == NULL) {
811043a8:	d0a03a17 	ldw	r2,-32536(gp)
811043ac:	1000021e 	bne	r2,zero,811043b8 <bSdmaDmaM2Transfer+0x31c>
			bStatus = FALSE;
811043b0:	e03ff415 	stw	zero,-48(fp)
811043b4:	00003706 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
811043b8:	e03ff50d 	sth	zero,-44(fp)
811043bc:	00003206 	br	81104488 <bSdmaDmaM2Transfer+0x3ec>
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
811043c0:	01000044 	movi	r4,1
811043c4:	113227c0 	call	8113227c <alt_busy_sleep>
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
811043c8:	d0a03a17 	ldw	r2,-32536(gp)
811043cc:	10800317 	ldw	r2,12(r2)
811043d0:	10800037 	ldwio	r2,0(r2)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
811043d4:	1080010c 	andi	r2,r2,4
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
				// hold transfers for descriptor fifo space
				while (0
811043d8:	103ff91e 	bne	r2,zero,811043c0 <__reset+0xfb0e43c0>
						!= (IORD_ALTERA_MSGDMA_CSR_STATUS(pxDmaM2Dev->csr_base)
								& ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
					alt_busy_sleep(1); /* delay 1us */
				}
				if (iMsgdmaConstructExtendedMmToMmDescriptor(pxDmaM2Dev,
811043dc:	d2203a17 	ldw	r8,-32536(gp)
811043e0:	e17ff817 	ldw	r5,-32(fp)
811043e4:	e1bff617 	ldw	r6,-40(fp)
811043e8:	e0bff917 	ldw	r2,-28(fp)
811043ec:	e0fff717 	ldw	r3,-36(fp)
811043f0:	01000044 	movi	r4,1
811043f4:	d9000815 	stw	r4,32(sp)
811043f8:	01000044 	movi	r4,1
811043fc:	d9000715 	stw	r4,28(sp)
81104400:	01000044 	movi	r4,1
81104404:	d9000615 	stw	r4,24(sp)
81104408:	01000044 	movi	r4,1
8110440c:	d9000515 	stw	r4,20(sp)
81104410:	01000044 	movi	r4,1
81104414:	d9000415 	stw	r4,16(sp)
81104418:	d8c00315 	stw	r3,12(sp)
8110441c:	d8800215 	stw	r2,8(sp)
81104420:	e0bffa17 	ldw	r2,-24(fp)
81104424:	d8800115 	stw	r2,4(sp)
81104428:	00802204 	movi	r2,136
8110442c:	d8800015 	stw	r2,0(sp)
81104430:	300f883a 	mov	r7,r6
81104434:	280d883a 	mov	r6,r5
81104438:	800b883a 	mov	r5,r16
8110443c:	4009883a 	mov	r4,r8
81104440:	110ad000 	call	8110ad00 <iMsgdmaConstructExtendedMmToMmDescriptor>
81104444:	10000226 	beq	r2,zero,81104450 <bSdmaDmaM2Transfer+0x3b4>
						&xDmaExtendedDescriptor, (alt_u32 *) uliSrcAddrLow,
						(alt_u32 *) uliDestAddrLow,
						SDMA_PIXEL_BLOCK_SIZE_BYTES, uliControlBits,
						(alt_u32 *) uliSrcAddrHigh, (alt_u32 *) uliDestAddrHigh,
						1, 1, 1, 1, 1)) {
					bStatus = FALSE;
81104448:	e03ff415 	stw	zero,-48(fp)
					break;
8110444c:	00001106 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
				} else {
					if (iMsgdmaExtendedDescriptorSyncTransfer(pxDmaM2Dev,
81104450:	d0a03a17 	ldw	r2,-32536(gp)
81104454:	800b883a 	mov	r5,r16
81104458:	1009883a 	mov	r4,r2
8110445c:	110ae040 	call	8110ae04 <iMsgdmaExtendedDescriptorSyncTransfer>
81104460:	10000226 	beq	r2,zero,8110446c <bSdmaDmaM2Transfer+0x3d0>
							&xDmaExtendedDescriptor)) {
						bStatus = FALSE;
81104464:	e03ff415 	stw	zero,-48(fp)
						break;
81104468:	00000a06 	br	81104494 <bSdmaDmaM2Transfer+0x3f8>
					}
					uliSrcAddrLow += (alt_u32) SDMA_PIXEL_BLOCK_SIZE_BYTES;
8110446c:	e0bff817 	ldw	r2,-32(fp)
81104470:	10802204 	addi	r2,r2,136
81104474:	e0bff815 	stw	r2,-32(fp)
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
81104478:	e03ff915 	stw	zero,-28(fp)

	if (bStatus) {
		if (pxDmaM2Dev == NULL) {
			bStatus = FALSE;
		} else {
			for (usiCnt = 0; usiCnt < usiTransferSizeInBlocks; usiCnt++) {
8110447c:	e0bff50b 	ldhu	r2,-44(fp)
81104480:	10800044 	addi	r2,r2,1
81104484:	e0bff50d 	sth	r2,-44(fp)
81104488:	e0fff50b 	ldhu	r3,-44(fp)
8110448c:	e0bffc0b 	ldhu	r2,-16(fp)
81104490:	18bfcd36 	bltu	r3,r2,811043c8 <__reset+0xfb0e43c8>
					uliSrcAddrHigh = (alt_u32) SDMA_M2_BASE_ADDR_HIGH;
				}
			}
		}
	}
	return bStatus;
81104494:	e0bff417 	ldw	r2,-48(fp)
}
81104498:	e6ffff04 	addi	sp,fp,-4
8110449c:	dfc00217 	ldw	ra,8(sp)
811044a0:	df000117 	ldw	fp,4(sp)
811044a4:	dc000017 	ldw	r16,0(sp)
811044a8:	dec00304 	addi	sp,sp,12
811044ac:	f800283a 	ret

811044b0 <bCommSetGlobalIrqEn>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bCommSetGlobalIrqEn(bool bGlobalIrqEnable, alt_u8 ucCommCh) {
811044b0:	defff904 	addi	sp,sp,-28
811044b4:	de00012e 	bgeu	sp,et,811044bc <bCommSetGlobalIrqEn+0xc>
811044b8:	003b68fa 	trap	3
811044bc:	dfc00615 	stw	ra,24(sp)
811044c0:	df000515 	stw	fp,20(sp)
811044c4:	df000504 	addi	fp,sp,20
811044c8:	e13ffe15 	stw	r4,-8(fp)
811044cc:	2805883a 	mov	r2,r5
811044d0:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
811044d4:	00800044 	movi	r2,1
811044d8:	e0bffb15 	stw	r2,-20(fp)
	alt_u32 uliReg = 0;
811044dc:	e03ffc15 	stw	zero,-16(fp)
	alt_u32 *puliCommAddr = 0;
811044e0:	e03ffd15 	stw	zero,-12(fp)

	switch (ucCommCh) {
811044e4:	e0bfff03 	ldbu	r2,-4(fp)
811044e8:	10c00228 	cmpgeui	r3,r2,8
811044ec:	18002e1e 	bne	r3,zero,811045a8 <bCommSetGlobalIrqEn+0xf8>
811044f0:	100690ba 	slli	r3,r2,2
811044f4:	00a04434 	movhi	r2,33040
811044f8:	10914204 	addi	r2,r2,17672
811044fc:	1885883a 	add	r2,r3,r2
81104500:	10800017 	ldw	r2,0(r2)
81104504:	1000683a 	jmp	r2
81104508:	81104528 	cmpgeui	r4,r16,16660
8110450c:	81104538 	rdprs	r4,r16,16660
81104510:	81104548 	cmpgei	r4,r16,16661
81104514:	81104558 	cmpnei	r4,r16,16661
81104518:	81104568 	cmpgeui	r4,r16,16661
8110451c:	81104578 	rdprs	r4,r16,16661
81104520:	81104588 	cmpgei	r4,r16,16662
81104524:	81104598 	cmpnei	r4,r16,16662
	case eCommSpwCh1:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104528:	00a04834 	movhi	r2,33056
8110452c:	108b0004 	addi	r2,r2,11264
81104530:	e0bffd15 	stw	r2,-12(fp)
		break;
81104534:	00001e06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh2:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104538:	00a04834 	movhi	r2,33056
8110453c:	108a0004 	addi	r2,r2,10240
81104540:	e0bffd15 	stw	r2,-12(fp)
		break;
81104544:	00001a06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh3:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104548:	00a04834 	movhi	r2,33056
8110454c:	10890004 	addi	r2,r2,9216
81104550:	e0bffd15 	stw	r2,-12(fp)
		break;
81104554:	00001606 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh4:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104558:	00a04834 	movhi	r2,33056
8110455c:	10880004 	addi	r2,r2,8192
81104560:	e0bffd15 	stw	r2,-12(fp)
		break;
81104564:	00001206 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh5:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104568:	00a04834 	movhi	r2,33056
8110456c:	10870004 	addi	r2,r2,7168
81104570:	e0bffd15 	stw	r2,-12(fp)
		break;
81104574:	00000e06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh6:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104578:	00a04834 	movhi	r2,33056
8110457c:	10860004 	addi	r2,r2,6144
81104580:	e0bffd15 	stw	r2,-12(fp)
		break;
81104584:	00000a06 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh7:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104588:	00a04834 	movhi	r2,33056
8110458c:	10850004 	addi	r2,r2,5120
81104590:	e0bffd15 	stw	r2,-12(fp)
		break;
81104594:	00000606 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	case eCommSpwCh8:
		puliCommAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104598:	00a04834 	movhi	r2,33056
8110459c:	10840004 	addi	r2,r2,4096
811045a0:	e0bffd15 	stw	r2,-12(fp)
		break;
811045a4:	00000206 	br	811045b0 <bCommSetGlobalIrqEn+0x100>
	default:
		bStatus = FALSE;
811045a8:	e03ffb15 	stw	zero,-20(fp)
		break;
811045ac:	0001883a 	nop
	}

	if (bStatus) {
811045b0:	e0bffb17 	ldw	r2,-20(fp)
811045b4:	10001326 	beq	r2,zero,81104604 <bCommSetGlobalIrqEn+0x154>
		uliReg = uliCommReadReg(puliCommAddr,
811045b8:	01400444 	movi	r5,17
811045bc:	e13ffd17 	ldw	r4,-12(fp)
811045c0:	110474c0 	call	8110474c <uliCommReadReg>
811045c4:	e0bffc15 	stw	r2,-16(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (bGlobalIrqEnable) {
811045c8:	e0bffe17 	ldw	r2,-8(fp)
811045cc:	10000426 	beq	r2,zero,811045e0 <bCommSetGlobalIrqEn+0x130>
			uliReg |= COMM_IRQ_GLOBAL_EN_MSK;
811045d0:	e0bffc17 	ldw	r2,-16(fp)
811045d4:	10800074 	orhi	r2,r2,1
811045d8:	e0bffc15 	stw	r2,-16(fp)
811045dc:	00000506 	br	811045f4 <bCommSetGlobalIrqEn+0x144>
		} else {
			uliReg &= (~COMM_IRQ_GLOBAL_EN_MSK);
811045e0:	e0fffc17 	ldw	r3,-16(fp)
811045e4:	00bffff4 	movhi	r2,65535
811045e8:	10bfffc4 	addi	r2,r2,-1
811045ec:	1884703a 	and	r2,r3,r2
811045f0:	e0bffc15 	stw	r2,-16(fp)
		}

		vCommWriteReg(puliCommAddr, COMM_IRQ_CONTROL_REG_OFST, uliReg);
811045f4:	e1bffc17 	ldw	r6,-16(fp)
811045f8:	01400444 	movi	r5,17
811045fc:	e13ffd17 	ldw	r4,-12(fp)
81104600:	11046f80 	call	811046f8 <vCommWriteReg>
	}

	return bStatus;
81104604:	e0bffb17 	ldw	r2,-20(fp)
}
81104608:	e037883a 	mov	sp,fp
8110460c:	dfc00117 	ldw	ra,4(sp)
81104610:	df000017 	ldw	fp,0(sp)
81104614:	dec00204 	addi	sp,sp,8
81104618:	f800283a 	ret

8110461c <bCommInitCh>:

bool bCommInitCh(TCommChannel *pxCommCh, alt_u8 ucCommCh) {
8110461c:	defffb04 	addi	sp,sp,-20
81104620:	de00012e 	bgeu	sp,et,81104628 <bCommInitCh+0xc>
81104624:	003b68fa 	trap	3
81104628:	dfc00415 	stw	ra,16(sp)
8110462c:	df000315 	stw	fp,12(sp)
81104630:	df000304 	addi	fp,sp,12
81104634:	e13ffe15 	stw	r4,-8(fp)
81104638:	2805883a 	mov	r2,r5
8110463c:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = TRUE;
81104640:	00800044 	movi	r2,1
81104644:	e0bffd15 	stw	r2,-12(fp)

	if (!bSpwcInitCh(&(pxCommCh->xSpacewire), ucCommCh)) {
81104648:	e0bffe17 	ldw	r2,-8(fp)
8110464c:	10805604 	addi	r2,r2,344
81104650:	e0ffff03 	ldbu	r3,-4(fp)
81104654:	180b883a 	mov	r5,r3
81104658:	1009883a 	mov	r4,r2
8110465c:	11096840 	call	81109684 <bSpwcInitCh>
81104660:	1000011e 	bne	r2,zero,81104668 <bCommInitCh+0x4c>
		bStatus = FALSE;
81104664:	e03ffd15 	stw	zero,-12(fp)
	}
	vFeebInitIrq(ucCommCh);
81104668:	e0bfff03 	ldbu	r2,-4(fp)
8110466c:	1009883a 	mov	r4,r2
81104670:	11058500 	call	81105850 <vFeebInitIrq>

	if (!bFeebInitCh(&(pxCommCh->xFeeBuffer), ucCommCh)) {
81104674:	e0bffe17 	ldw	r2,-8(fp)
81104678:	10800904 	addi	r2,r2,36
8110467c:	e0ffff03 	ldbu	r3,-4(fp)
81104680:	180b883a 	mov	r5,r3
81104684:	1009883a 	mov	r4,r2
81104688:	1105f480 	call	81105f48 <bFeebInitCh>
8110468c:	1000011e 	bne	r2,zero,81104694 <bCommInitCh+0x78>
		bStatus = FALSE;
81104690:	e03ffd15 	stw	zero,-12(fp)
	}
	if (!bRmapInitCh(&(pxCommCh->xRmap), ucCommCh)) {
81104694:	e0bffe17 	ldw	r2,-8(fp)
81104698:	10801004 	addi	r2,r2,64
8110469c:	e0ffff03 	ldbu	r3,-4(fp)
811046a0:	180b883a 	mov	r5,r3
811046a4:	1009883a 	mov	r4,r2
811046a8:	1108ce00 	call	81108ce0 <bRmapInitCh>
811046ac:	1000011e 	bne	r2,zero,811046b4 <bCommInitCh+0x98>
		bStatus = FALSE;
811046b0:	e03ffd15 	stw	zero,-12(fp)
	}
	vRmapInitIrq(ucCommCh);
811046b4:	e0bfff03 	ldbu	r2,-4(fp)
811046b8:	1009883a 	mov	r4,r2
811046bc:	1106b1c0 	call	81106b1c <vRmapInitIrq>

	if (!bDpktInitCh(&(pxCommCh->xDataPacket), ucCommCh)) {
811046c0:	e0bffe17 	ldw	r2,-8(fp)
811046c4:	10800104 	addi	r2,r2,4
811046c8:	e0ffff03 	ldbu	r3,-4(fp)
811046cc:	180b883a 	mov	r5,r3
811046d0:	1009883a 	mov	r4,r2
811046d4:	1104dc40 	call	81104dc4 <bDpktInitCh>
811046d8:	1000011e 	bne	r2,zero,811046e0 <bCommInitCh+0xc4>
		bStatus = FALSE;
811046dc:	e03ffd15 	stw	zero,-12(fp)
	}
	return bStatus;
811046e0:	e0bffd17 	ldw	r2,-12(fp)
}
811046e4:	e037883a 	mov	sp,fp
811046e8:	dfc00117 	ldw	ra,4(sp)
811046ec:	df000017 	ldw	fp,0(sp)
811046f0:	dec00204 	addi	sp,sp,8
811046f4:	f800283a 	ret

811046f8 <vCommWriteReg>:
//! [public functions]

//! [private functions]
static void vCommWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811046f8:	defffc04 	addi	sp,sp,-16
811046fc:	de00012e 	bgeu	sp,et,81104704 <vCommWriteReg+0xc>
81104700:	003b68fa 	trap	3
81104704:	df000315 	stw	fp,12(sp)
81104708:	df000304 	addi	fp,sp,12
8110470c:	e13ffd15 	stw	r4,-12(fp)
81104710:	e17ffe15 	stw	r5,-8(fp)
81104714:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104718:	e0bffe17 	ldw	r2,-8(fp)
8110471c:	1085883a 	add	r2,r2,r2
81104720:	1085883a 	add	r2,r2,r2
81104724:	1007883a 	mov	r3,r2
81104728:	e0bffd17 	ldw	r2,-12(fp)
8110472c:	10c5883a 	add	r2,r2,r3
81104730:	e0ffff17 	ldw	r3,-4(fp)
81104734:	10c00015 	stw	r3,0(r2)
}
81104738:	0001883a 	nop
8110473c:	e037883a 	mov	sp,fp
81104740:	df000017 	ldw	fp,0(sp)
81104744:	dec00104 	addi	sp,sp,4
81104748:	f800283a 	ret

8110474c <uliCommReadReg>:

static alt_u32 uliCommReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110474c:	defffc04 	addi	sp,sp,-16
81104750:	de00012e 	bgeu	sp,et,81104758 <uliCommReadReg+0xc>
81104754:	003b68fa 	trap	3
81104758:	df000315 	stw	fp,12(sp)
8110475c:	df000304 	addi	fp,sp,12
81104760:	e13ffe15 	stw	r4,-8(fp)
81104764:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104768:	e0bfff17 	ldw	r2,-4(fp)
8110476c:	1085883a 	add	r2,r2,r2
81104770:	1085883a 	add	r2,r2,r2
81104774:	1007883a 	mov	r3,r2
81104778:	e0bffe17 	ldw	r2,-8(fp)
8110477c:	10c5883a 	add	r2,r2,r3
81104780:	10800017 	ldw	r2,0(r2)
81104784:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104788:	e0bffd17 	ldw	r2,-12(fp)
}
8110478c:	e037883a 	mov	sp,fp
81104790:	df000017 	ldw	fp,0(sp)
81104794:	dec00104 	addi	sp,sp,4
81104798:	f800283a 	ret

8110479c <bDpktSetPacketConfig>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bDpktSetPacketConfig(TDpktChannel *pxDpktCh) {
8110479c:	defffb04 	addi	sp,sp,-20
811047a0:	de00012e 	bgeu	sp,et,811047a8 <bDpktSetPacketConfig+0xc>
811047a4:	003b68fa 	trap	3
811047a8:	dfc00415 	stw	ra,16(sp)
811047ac:	df000315 	stw	fp,12(sp)
811047b0:	df000304 	addi	fp,sp,12
811047b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811047b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811047bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811047c0:	e0bfff17 	ldw	r2,-4(fp)
811047c4:	10007a26 	beq	r2,zero,811049b0 <bDpktSetPacketConfig+0x214>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811047c8:	e0bfff17 	ldw	r2,-4(fp)
811047cc:	10800017 	ldw	r2,0(r2)
811047d0:	01400204 	movi	r5,8
811047d4:	1009883a 	mov	r4,r2
811047d8:	1104f8c0 	call	81104f8c <uliDpktReadReg>
811047dc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
811047e0:	e0bffe17 	ldw	r2,-8(fp)
811047e4:	10bfffec 	andhi	r2,r2,65535
811047e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
811047ec:	e0bfff17 	ldw	r2,-4(fp)
811047f0:	1080010b 	ldhu	r2,4(r2)
811047f4:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
811047f8:	e0fffe17 	ldw	r3,-8(fp)
811047fc:	1884b03a 	or	r2,r3,r2
81104800:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
81104804:	e0bffe17 	ldw	r2,-8(fp)
81104808:	10bfffcc 	andi	r2,r2,65535
8110480c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));
81104810:	e0bfff17 	ldw	r2,-4(fp)
81104814:	1080018b 	ldhu	r2,6(r2)
81104818:	10bfffcc 	andi	r2,r2,65535
8110481c:	1004943a 	slli	r2,r2,16
81104820:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_CCD_X_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_X_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdXSize << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_Y_SIZE_MSK
81104824:	e0bffe17 	ldw	r2,-8(fp)
81104828:	10c4b03a 	or	r2,r2,r3
8110482c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiCcdYSize << 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_1_REG_OFST,
81104830:	e0bfff17 	ldw	r2,-4(fp)
81104834:	10800017 	ldw	r2,0(r2)
81104838:	e1bffe17 	ldw	r6,-8(fp)
8110483c:	01400204 	movi	r5,8
81104840:	1009883a 	mov	r4,r2
81104844:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104848:	e0bfff17 	ldw	r2,-4(fp)
8110484c:	10800017 	ldw	r2,0(r2)
81104850:	01400244 	movi	r5,9
81104854:	1009883a 	mov	r4,r2
81104858:	1104f8c0 	call	81104f8c <uliDpktReadReg>
8110485c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
81104860:	e0bffe17 	ldw	r2,-8(fp)
81104864:	10bfffec 	andhi	r2,r2,65535
81104868:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
8110486c:	e0bfff17 	ldw	r2,-4(fp)
81104870:	1080020b 	ldhu	r2,8(r2)
81104874:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
81104878:	e0fffe17 	ldw	r3,-8(fp)
8110487c:	1884b03a 	or	r2,r3,r2
81104880:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
81104884:	e0bffe17 	ldw	r2,-8(fp)
81104888:	10bfffcc 	andi	r2,r2,65535
8110488c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
81104890:	e0bfff17 	ldw	r2,-4(fp)
81104894:	1080028b 	ldhu	r2,10(r2)
										<< 16));
81104898:	10bfffcc 	andi	r2,r2,65535
8110489c:	1004943a 	slli	r2,r2,16
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
811048a0:	1007883a 	mov	r3,r2

		uliReg &= (~COMM_DATA_PKT_DATA_Y_SIZE_MSK);
		uliReg |= (COMM_DATA_PKT_DATA_Y_SIZE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.usiDataYSize << 0));
		uliReg &= (~COMM_DATA_PKT_OVER_Y_SIZE_MSK);
		uliReg |=
811048a4:	e0bffe17 	ldw	r2,-8(fp)
811048a8:	10c4b03a 	or	r2,r2,r3
811048ac:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_OVER_Y_SIZE_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize
										<< 16));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_2_REG_OFST,
811048b0:	e0bfff17 	ldw	r2,-4(fp)
811048b4:	10800017 	ldw	r2,0(r2)
811048b8:	e1bffe17 	ldw	r6,-8(fp)
811048bc:	01400244 	movi	r5,9
811048c0:	1009883a 	mov	r4,r2
811048c4:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811048c8:	e0bfff17 	ldw	r2,-4(fp)
811048cc:	10800017 	ldw	r2,0(r2)
811048d0:	01400284 	movi	r5,10
811048d4:	1009883a 	mov	r4,r2
811048d8:	1104f8c0 	call	81104f8c <uliDpktReadReg>
811048dc:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
811048e0:	e0bffe17 	ldw	r2,-8(fp)
811048e4:	10bfffec 	andhi	r2,r2,65535
811048e8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
811048ec:	e0bfff17 	ldw	r2,-4(fp)
811048f0:	1080030b 	ldhu	r2,12(r2)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
811048f4:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LENGTH_MSK);
		uliReg |=
811048f8:	e0fffe17 	ldw	r3,-8(fp)
811048fc:	1884b03a 	or	r2,r3,r2
81104900:	e0bffe15 	stw	r2,-8(fp)
				(COMM_DATA_PKT_LENGTH_MSK
						& (alt_u32)(
								pxDpktCh->xDpktDataPacketConfig.usiPacketLength
										<< 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_3_REG_OFST,
81104904:	e0bfff17 	ldw	r2,-4(fp)
81104908:	10800017 	ldw	r2,0(r2)
8110490c:	e1bffe17 	ldw	r6,-8(fp)
81104910:	01400284 	movi	r5,10
81104914:	1009883a 	mov	r4,r2
81104918:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
8110491c:	e0bfff17 	ldw	r2,-4(fp)
81104920:	10800017 	ldw	r2,0(r2)
81104924:	014002c4 	movi	r5,11
81104928:	1009883a 	mov	r4,r2
8110492c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104930:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
81104934:	e0fffe17 	ldw	r3,-8(fp)
81104938:	00bfc004 	movi	r2,-256
8110493c:	1884703a 	and	r2,r3,r2
81104940:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
81104944:	e0bfff17 	ldw	r2,-4(fp)
81104948:	10800383 	ldbu	r2,14(r2)
8110494c:	10803fcc 	andi	r2,r2,255
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
81104950:	e0fffe17 	ldw	r3,-8(fp)
81104954:	1884b03a 	or	r2,r3,r2
81104958:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
8110495c:	e0fffe17 	ldw	r3,-8(fp)
81104960:	00bffff4 	movhi	r2,65535
81104964:	10803fc4 	addi	r2,r2,255
81104968:	1884703a 	and	r2,r3,r2
8110496c:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));
81104970:	e0bfff17 	ldw	r2,-4(fp)
81104974:	108003c3 	ldbu	r2,15(r2)
81104978:	10803fcc 	andi	r2,r2,255
8110497c:	1004923a 	slli	r2,r2,8
81104980:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_DATA_PKT_FEE_MODE_MSK);
		uliReg |= (COMM_DATA_PKT_FEE_MODE_MSK
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucFeeMode << 0));
		uliReg &= (~COMM_DATA_PKT_CCD_NUMBER_MSK);
		uliReg |= (COMM_DATA_PKT_CCD_NUMBER_MSK
81104984:	e0fffe17 	ldw	r3,-8(fp)
81104988:	1884b03a 	or	r2,r3,r2
8110498c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktDataPacketConfig.ucCcdNumber << 8));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_CFG_4_REG_OFST,
81104990:	e0bfff17 	ldw	r2,-4(fp)
81104994:	10800017 	ldw	r2,0(r2)
81104998:	e1bffe17 	ldw	r6,-8(fp)
8110499c:	014002c4 	movi	r5,11
811049a0:	1009883a 	mov	r4,r2
811049a4:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
811049a8:	00800044 	movi	r2,1
811049ac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811049b0:	e0bffd17 	ldw	r2,-12(fp)
}
811049b4:	e037883a 	mov	sp,fp
811049b8:	dfc00117 	ldw	ra,4(sp)
811049bc:	df000017 	ldw	fp,0(sp)
811049c0:	dec00204 	addi	sp,sp,8
811049c4:	f800283a 	ret

811049c8 <bDpktGetPacketConfig>:

bool bDpktGetPacketConfig(TDpktChannel *pxDpktCh) {
811049c8:	defffb04 	addi	sp,sp,-20
811049cc:	de00012e 	bgeu	sp,et,811049d4 <bDpktGetPacketConfig+0xc>
811049d0:	003b68fa 	trap	3
811049d4:	dfc00415 	stw	ra,16(sp)
811049d8:	df000315 	stw	fp,12(sp)
811049dc:	df000304 	addi	fp,sp,12
811049e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811049e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811049e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
811049ec:	e0bfff17 	ldw	r2,-4(fp)
811049f0:	10003a26 	beq	r2,zero,81104adc <bDpktGetPacketConfig+0x114>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
811049f4:	e0bfff17 	ldw	r2,-4(fp)
811049f8:	10800017 	ldw	r2,0(r2)
811049fc:	01400204 	movi	r5,8
81104a00:	1009883a 	mov	r4,r2
81104a04:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a08:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
81104a0c:	e0bffe17 	ldw	r2,-8(fp)
81104a10:	1007883a 	mov	r3,r2
81104a14:	e0bfff17 	ldw	r2,-4(fp)
81104a18:	10c0010d 	sth	r3,4(r2)
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);
81104a1c:	e0bffe17 	ldw	r2,-8(fp)
81104a20:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_1_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiCcdXSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_CCD_X_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiCcdYSize = (alt_u16)(
81104a24:	1007883a 	mov	r3,r2
81104a28:	e0bfff17 	ldw	r2,-4(fp)
81104a2c:	10c0018d 	sth	r3,6(r2)
				(uliReg & COMM_DATA_PKT_CCD_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a30:	e0bfff17 	ldw	r2,-4(fp)
81104a34:	10800017 	ldw	r2,0(r2)
81104a38:	01400244 	movi	r5,9
81104a3c:	1009883a 	mov	r4,r2
81104a40:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a44:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
81104a48:	e0bffe17 	ldw	r2,-8(fp)
81104a4c:	1007883a 	mov	r3,r2
81104a50:	e0bfff17 	ldw	r2,-4(fp)
81104a54:	10c0020d 	sth	r3,8(r2)
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);
81104a58:	e0bffe17 	ldw	r2,-8(fp)
81104a5c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_2_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiDataYSize = (alt_u16)(
				(uliReg & COMM_DATA_PKT_DATA_Y_SIZE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.usiOverscanYSize = (alt_u16)(
81104a60:	1007883a 	mov	r3,r2
81104a64:	e0bfff17 	ldw	r2,-4(fp)
81104a68:	10c0028d 	sth	r3,10(r2)
				(uliReg & COMM_DATA_PKT_OVER_Y_SIZE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a6c:	e0bfff17 	ldw	r2,-4(fp)
81104a70:	10800017 	ldw	r2,0(r2)
81104a74:	01400284 	movi	r5,10
81104a78:	1009883a 	mov	r4,r2
81104a7c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104a80:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_3_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.usiPacketLength = (alt_u16)(
81104a84:	e0bffe17 	ldw	r2,-8(fp)
81104a88:	1007883a 	mov	r3,r2
81104a8c:	e0bfff17 	ldw	r2,-4(fp)
81104a90:	10c0030d 	sth	r3,12(r2)
				(uliReg & COMM_DATA_PKT_LENGTH_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104a94:	e0bfff17 	ldw	r2,-4(fp)
81104a98:	10800017 	ldw	r2,0(r2)
81104a9c:	014002c4 	movi	r5,11
81104aa0:	1009883a 	mov	r4,r2
81104aa4:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104aa8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
81104aac:	e0bffe17 	ldw	r2,-8(fp)
81104ab0:	1007883a 	mov	r3,r2
81104ab4:	e0bfff17 	ldw	r2,-4(fp)
81104ab8:	10c00385 	stb	r3,14(r2)
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);
81104abc:	e0bffe17 	ldw	r2,-8(fp)
81104ac0:	10bfc00c 	andi	r2,r2,65280
81104ac4:	1004d23a 	srli	r2,r2,8
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_CFG_4_REG_OFST);

		pxDpktCh->xDpktDataPacketConfig.ucFeeMode= (alt_u8)(
				(uliReg & COMM_DATA_PKT_FEE_MODE_MSK) >> 0);
		pxDpktCh->xDpktDataPacketConfig.ucCcdNumber= (alt_u8)(
81104ac8:	1007883a 	mov	r3,r2
81104acc:	e0bfff17 	ldw	r2,-4(fp)
81104ad0:	10c003c5 	stb	r3,15(r2)
				(uliReg & COMM_DATA_PKT_CCD_NUMBER_MSK) >> 8);

		bStatus = TRUE;
81104ad4:	00800044 	movi	r2,1
81104ad8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104adc:	e0bffd17 	ldw	r2,-12(fp)
}
81104ae0:	e037883a 	mov	sp,fp
81104ae4:	dfc00117 	ldw	ra,4(sp)
81104ae8:	df000017 	ldw	fp,0(sp)
81104aec:	dec00204 	addi	sp,sp,8
81104af0:	f800283a 	ret

81104af4 <bDpktGetPacketHeader>:

bool bDpktGetPacketHeader(TDpktChannel *pxDpktCh) {
81104af4:	defffb04 	addi	sp,sp,-20
81104af8:	de00012e 	bgeu	sp,et,81104b00 <bDpktGetPacketHeader+0xc>
81104afc:	003b68fa 	trap	3
81104b00:	dfc00415 	stw	ra,16(sp)
81104b04:	df000315 	stw	fp,12(sp)
81104b08:	df000304 	addi	fp,sp,12
81104b0c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104b10:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104b14:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104b18:	e0bfff17 	ldw	r2,-4(fp)
81104b1c:	10002026 	beq	r2,zero,81104ba0 <bDpktGetPacketHeader+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b20:	e0bfff17 	ldw	r2,-4(fp)
81104b24:	10800017 	ldw	r2,0(r2)
81104b28:	01400304 	movi	r5,12
81104b2c:	1009883a 	mov	r4,r2
81104b30:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104b34:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
81104b38:	e0bffe17 	ldw	r2,-8(fp)
81104b3c:	1007883a 	mov	r3,r2
81104b40:	e0bfff17 	ldw	r2,-4(fp)
81104b44:	10c0040d 	sth	r3,16(r2)
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);
81104b48:	e0bffe17 	ldw	r2,-8(fp)
81104b4c:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_1_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiLength = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_LENGTH_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiType = (alt_u16)(
81104b50:	1007883a 	mov	r3,r2
81104b54:	e0bfff17 	ldw	r2,-4(fp)
81104b58:	10c0048d 	sth	r3,18(r2)
				(uliReg & COMM_DATA_PKT_HDR_TYPE_MSK) >> 16);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104b5c:	e0bfff17 	ldw	r2,-4(fp)
81104b60:	10800017 	ldw	r2,0(r2)
81104b64:	01400344 	movi	r5,13
81104b68:	1009883a 	mov	r4,r2
81104b6c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104b70:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
81104b74:	e0bffe17 	ldw	r2,-8(fp)
81104b78:	1007883a 	mov	r3,r2
81104b7c:	e0bfff17 	ldw	r2,-4(fp)
81104b80:	10c0050d 	sth	r3,20(r2)
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);
81104b84:	e0bffe17 	ldw	r2,-8(fp)
81104b88:	1004d43a 	srli	r2,r2,16
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_HDR_2_REG_OFST);

		pxDpktCh->xDpktDataPacketHeader.usiFrameCounter = (alt_u16)(
				(uliReg & COMM_DATA_PKT_HDR_FRAME_CNT_MSK) >> 0);
		pxDpktCh->xDpktDataPacketHeader.usiSequenceCounter = (alt_u16)(
81104b8c:	1007883a 	mov	r3,r2
81104b90:	e0bfff17 	ldw	r2,-4(fp)
81104b94:	10c0058d 	sth	r3,22(r2)
				(uliReg & COMM_DATA_PKT_SEQ_CNT_MSK) >> 16);

		bStatus = TRUE;
81104b98:	00800044 	movi	r2,1
81104b9c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ba0:	e0bffd17 	ldw	r2,-12(fp)
}
81104ba4:	e037883a 	mov	sp,fp
81104ba8:	dfc00117 	ldw	ra,4(sp)
81104bac:	df000017 	ldw	fp,0(sp)
81104bb0:	dec00204 	addi	sp,sp,8
81104bb4:	f800283a 	ret

81104bb8 <bDpktSetPixelDelay>:

bool bDpktSetPixelDelay(TDpktChannel *pxDpktCh) {
81104bb8:	defffb04 	addi	sp,sp,-20
81104bbc:	de00012e 	bgeu	sp,et,81104bc4 <bDpktSetPixelDelay+0xc>
81104bc0:	003b68fa 	trap	3
81104bc4:	dfc00415 	stw	ra,16(sp)
81104bc8:	df000315 	stw	fp,12(sp)
81104bcc:	df000304 	addi	fp,sp,12
81104bd0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104bd4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104bd8:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104bdc:	e0bfff17 	ldw	r2,-4(fp)
81104be0:	10004126 	beq	r2,zero,81104ce8 <bDpktSetPixelDelay+0x130>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104be4:	e0bfff17 	ldw	r2,-4(fp)
81104be8:	10800017 	ldw	r2,0(r2)
81104bec:	01400384 	movi	r5,14
81104bf0:	1009883a 	mov	r4,r2
81104bf4:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104bf8:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
81104bfc:	e0bffe17 	ldw	r2,-8(fp)
81104c00:	10bfffec 	andhi	r2,r2,65535
81104c04:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));
81104c08:	e0bfff17 	ldw	r2,-4(fp)
81104c0c:	1080060b 	ldhu	r2,24(r2)
81104c10:	10bfffcc 	andi	r2,r2,65535

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_LINE_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_LINE_DLY_MSK
81104c14:	e0fffe17 	ldw	r3,-8(fp)
81104c18:	1884b03a 	or	r2,r3,r2
81104c1c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiLineDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_1_REG_OFST,
81104c20:	e0bfff17 	ldw	r2,-4(fp)
81104c24:	10800017 	ldw	r2,0(r2)
81104c28:	e1bffe17 	ldw	r6,-8(fp)
81104c2c:	01400384 	movi	r5,14
81104c30:	1009883a 	mov	r4,r2
81104c34:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c38:	e0bfff17 	ldw	r2,-4(fp)
81104c3c:	10800017 	ldw	r2,0(r2)
81104c40:	014003c4 	movi	r5,15
81104c44:	1009883a 	mov	r4,r2
81104c48:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104c4c:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
81104c50:	e0bffe17 	ldw	r2,-8(fp)
81104c54:	10bfffec 	andhi	r2,r2,65535
81104c58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));
81104c5c:	e0bfff17 	ldw	r2,-4(fp)
81104c60:	1080068b 	ldhu	r2,26(r2)
81104c64:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_COLUMN_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_COLUMN_DLY_MSK
81104c68:	e0fffe17 	ldw	r3,-8(fp)
81104c6c:	1884b03a 	or	r2,r3,r2
81104c70:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiColumnDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_2_REG_OFST,
81104c74:	e0bfff17 	ldw	r2,-4(fp)
81104c78:	10800017 	ldw	r2,0(r2)
81104c7c:	e1bffe17 	ldw	r6,-8(fp)
81104c80:	014003c4 	movi	r5,15
81104c84:	1009883a 	mov	r4,r2
81104c88:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104c8c:	e0bfff17 	ldw	r2,-4(fp)
81104c90:	10800017 	ldw	r2,0(r2)
81104c94:	01400404 	movi	r5,16
81104c98:	1009883a 	mov	r4,r2
81104c9c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104ca0:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
81104ca4:	e0bffe17 	ldw	r2,-8(fp)
81104ca8:	10bfffec 	andhi	r2,r2,65535
81104cac:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));
81104cb0:	e0bfff17 	ldw	r2,-4(fp)
81104cb4:	1080070b 	ldhu	r2,28(r2)
81104cb8:	10bfffcc 	andi	r2,r2,65535
				uliReg);
		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		uliReg &= (~COMM_DATA_PKT_ADC_DLY_MSK);
		uliReg |= (COMM_DATA_PKT_ADC_DLY_MSK
81104cbc:	e0fffe17 	ldw	r3,-8(fp)
81104cc0:	1884b03a 	or	r2,r3,r2
81104cc4:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxDpktCh->xDpktPixelDelay.usiAdcDelay << 0));

		vDpktWriteReg(pxDpktCh->puliDpktChAddr, COMM_DATA_PKT_PX_DLY_3_REG_OFST,
81104cc8:	e0bfff17 	ldw	r2,-4(fp)
81104ccc:	10800017 	ldw	r2,0(r2)
81104cd0:	e1bffe17 	ldw	r6,-8(fp)
81104cd4:	01400404 	movi	r5,16
81104cd8:	1009883a 	mov	r4,r2
81104cdc:	1104f380 	call	81104f38 <vDpktWriteReg>
				uliReg);

		bStatus = TRUE;
81104ce0:	00800044 	movi	r2,1
81104ce4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104ce8:	e0bffd17 	ldw	r2,-12(fp)
}
81104cec:	e037883a 	mov	sp,fp
81104cf0:	dfc00117 	ldw	ra,4(sp)
81104cf4:	df000017 	ldw	fp,0(sp)
81104cf8:	dec00204 	addi	sp,sp,8
81104cfc:	f800283a 	ret

81104d00 <bDpktGetPixelDelay>:

bool bDpktGetPixelDelay(TDpktChannel *pxDpktCh) {
81104d00:	defffb04 	addi	sp,sp,-20
81104d04:	de00012e 	bgeu	sp,et,81104d0c <bDpktGetPixelDelay+0xc>
81104d08:	003b68fa 	trap	3
81104d0c:	dfc00415 	stw	ra,16(sp)
81104d10:	df000315 	stw	fp,12(sp)
81104d14:	df000304 	addi	fp,sp,12
81104d18:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81104d1c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81104d20:	e03ffe15 	stw	zero,-8(fp)

	if (pxDpktCh != NULL) {
81104d24:	e0bfff17 	ldw	r2,-4(fp)
81104d28:	10002026 	beq	r2,zero,81104dac <bDpktGetPixelDelay+0xac>

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d2c:	e0bfff17 	ldw	r2,-4(fp)
81104d30:	10800017 	ldw	r2,0(r2)
81104d34:	01400384 	movi	r5,14
81104d38:	1009883a 	mov	r4,r2
81104d3c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d40:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_1_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiLineDelay = (alt_u16)(
81104d44:	e0bffe17 	ldw	r2,-8(fp)
81104d48:	1007883a 	mov	r3,r2
81104d4c:	e0bfff17 	ldw	r2,-4(fp)
81104d50:	10c0060d 	sth	r3,24(r2)
				(uliReg & COMM_DATA_PKT_LINE_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d54:	e0bfff17 	ldw	r2,-4(fp)
81104d58:	10800017 	ldw	r2,0(r2)
81104d5c:	014003c4 	movi	r5,15
81104d60:	1009883a 	mov	r4,r2
81104d64:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d68:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_2_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiColumnDelay = (alt_u16)(
81104d6c:	e0bffe17 	ldw	r2,-8(fp)
81104d70:	1007883a 	mov	r3,r2
81104d74:	e0bfff17 	ldw	r2,-4(fp)
81104d78:	10c0068d 	sth	r3,26(r2)
				(uliReg & COMM_DATA_PKT_COLUMN_DLY_MSK) >> 0);

		uliReg = uliDpktReadReg(pxDpktCh->puliDpktChAddr,
81104d7c:	e0bfff17 	ldw	r2,-4(fp)
81104d80:	10800017 	ldw	r2,0(r2)
81104d84:	01400404 	movi	r5,16
81104d88:	1009883a 	mov	r4,r2
81104d8c:	1104f8c0 	call	81104f8c <uliDpktReadReg>
81104d90:	e0bffe15 	stw	r2,-8(fp)
				COMM_DATA_PKT_PX_DLY_3_REG_OFST);

		pxDpktCh->xDpktPixelDelay.usiAdcDelay = (alt_u16)(
81104d94:	e0bffe17 	ldw	r2,-8(fp)
81104d98:	1007883a 	mov	r3,r2
81104d9c:	e0bfff17 	ldw	r2,-4(fp)
81104da0:	10c0070d 	sth	r3,28(r2)
				(uliReg & COMM_DATA_PKT_ADC_DLY_MSK) >> 0);

		bStatus = TRUE;
81104da4:	00800044 	movi	r2,1
81104da8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81104dac:	e0bffd17 	ldw	r2,-12(fp)
}
81104db0:	e037883a 	mov	sp,fp
81104db4:	dfc00117 	ldw	ra,4(sp)
81104db8:	df000017 	ldw	fp,0(sp)
81104dbc:	dec00204 	addi	sp,sp,8
81104dc0:	f800283a 	ret

81104dc4 <bDpktInitCh>:

bool bDpktInitCh(TDpktChannel *pxDpktCh, alt_u8 ucCommCh) {
81104dc4:	defffb04 	addi	sp,sp,-20
81104dc8:	de00012e 	bgeu	sp,et,81104dd0 <bDpktInitCh+0xc>
81104dcc:	003b68fa 	trap	3
81104dd0:	dfc00415 	stw	ra,16(sp)
81104dd4:	df000315 	stw	fp,12(sp)
81104dd8:	df000304 	addi	fp,sp,12
81104ddc:	e13ffe15 	stw	r4,-8(fp)
81104de0:	2805883a 	mov	r2,r5
81104de4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81104de8:	e03ffd15 	stw	zero,-12(fp)

	if (pxDpktCh != NULL) {
81104dec:	e0bffe17 	ldw	r2,-8(fp)
81104df0:	10004b26 	beq	r2,zero,81104f20 <bDpktInitCh+0x15c>
		bStatus = TRUE;
81104df4:	00800044 	movi	r2,1
81104df8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81104dfc:	e0bfff03 	ldbu	r2,-4(fp)
81104e00:	10c00228 	cmpgeui	r3,r2,8
81104e04:	1800361e 	bne	r3,zero,81104ee0 <bDpktInitCh+0x11c>
81104e08:	100690ba 	slli	r3,r2,2
81104e0c:	00a04434 	movhi	r2,33040
81104e10:	10938804 	addi	r2,r2,20000
81104e14:	1885883a 	add	r2,r3,r2
81104e18:	10800017 	ldw	r2,0(r2)
81104e1c:	1000683a 	jmp	r2
81104e20:	81104e40 	call	881104e4 <__reset+0x20f04e4>
81104e24:	81104e54 	ori	r4,r16,16697
81104e28:	81104e68 	cmpgeui	r4,r16,16697
81104e2c:	81104e7c 	xorhi	r4,r16,16697
81104e30:	81104e90 	cmplti	r4,r16,16698
81104e34:	81104ea4 	muli	r4,r16,16698
81104e38:	81104eb8 	rdprs	r4,r16,16698
81104e3c:	81104ecc 	andi	r4,r16,16699
		case eCommSpwCh1:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81104e40:	e0fffe17 	ldw	r3,-8(fp)
81104e44:	00a04834 	movhi	r2,33056
81104e48:	108b0004 	addi	r2,r2,11264
81104e4c:	18800015 	stw	r2,0(r3)
			break;
81104e50:	00002506 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh2:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81104e54:	e0fffe17 	ldw	r3,-8(fp)
81104e58:	00a04834 	movhi	r2,33056
81104e5c:	108a0004 	addi	r2,r2,10240
81104e60:	18800015 	stw	r2,0(r3)
			break;
81104e64:	00002006 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh3:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81104e68:	e0fffe17 	ldw	r3,-8(fp)
81104e6c:	00a04834 	movhi	r2,33056
81104e70:	10890004 	addi	r2,r2,9216
81104e74:	18800015 	stw	r2,0(r3)
			break;
81104e78:	00001b06 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh4:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81104e7c:	e0fffe17 	ldw	r3,-8(fp)
81104e80:	00a04834 	movhi	r2,33056
81104e84:	10880004 	addi	r2,r2,8192
81104e88:	18800015 	stw	r2,0(r3)
			break;
81104e8c:	00001606 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh5:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81104e90:	e0fffe17 	ldw	r3,-8(fp)
81104e94:	00a04834 	movhi	r2,33056
81104e98:	10870004 	addi	r2,r2,7168
81104e9c:	18800015 	stw	r2,0(r3)
			break;
81104ea0:	00001106 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh6:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81104ea4:	e0fffe17 	ldw	r3,-8(fp)
81104ea8:	00a04834 	movhi	r2,33056
81104eac:	10860004 	addi	r2,r2,6144
81104eb0:	18800015 	stw	r2,0(r3)
			break;
81104eb4:	00000c06 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh7:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81104eb8:	e0fffe17 	ldw	r3,-8(fp)
81104ebc:	00a04834 	movhi	r2,33056
81104ec0:	10850004 	addi	r2,r2,5120
81104ec4:	18800015 	stw	r2,0(r3)
			break;
81104ec8:	00000706 	br	81104ee8 <bDpktInitCh+0x124>
		case eCommSpwCh8:
			pxDpktCh->puliDpktChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81104ecc:	e0fffe17 	ldw	r3,-8(fp)
81104ed0:	00a04834 	movhi	r2,33056
81104ed4:	10840004 	addi	r2,r2,4096
81104ed8:	18800015 	stw	r2,0(r3)
			break;
81104edc:	00000206 	br	81104ee8 <bDpktInitCh+0x124>
		default:
			bStatus = FALSE;
81104ee0:	e03ffd15 	stw	zero,-12(fp)
			break;
81104ee4:	0001883a 	nop
		}

		if (bStatus) {
81104ee8:	e0bffd17 	ldw	r2,-12(fp)
81104eec:	10000c26 	beq	r2,zero,81104f20 <bDpktInitCh+0x15c>
			if (!bDpktGetPacketConfig(pxDpktCh)) {
81104ef0:	e13ffe17 	ldw	r4,-8(fp)
81104ef4:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
81104ef8:	1000011e 	bne	r2,zero,81104f00 <bDpktInitCh+0x13c>
				bStatus = FALSE;
81104efc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPacketHeader(pxDpktCh)) {
81104f00:	e13ffe17 	ldw	r4,-8(fp)
81104f04:	1104af40 	call	81104af4 <bDpktGetPacketHeader>
81104f08:	1000011e 	bne	r2,zero,81104f10 <bDpktInitCh+0x14c>
				bStatus = FALSE;
81104f0c:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bDpktGetPixelDelay(pxDpktCh)) {
81104f10:	e13ffe17 	ldw	r4,-8(fp)
81104f14:	1104d000 	call	81104d00 <bDpktGetPixelDelay>
81104f18:	1000011e 	bne	r2,zero,81104f20 <bDpktInitCh+0x15c>
				bStatus = FALSE;
81104f1c:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81104f20:	e0bffd17 	ldw	r2,-12(fp)
}
81104f24:	e037883a 	mov	sp,fp
81104f28:	dfc00117 	ldw	ra,4(sp)
81104f2c:	df000017 	ldw	fp,0(sp)
81104f30:	dec00204 	addi	sp,sp,8
81104f34:	f800283a 	ret

81104f38 <vDpktWriteReg>:
//! [public functions]

//! [private functions]
static void vDpktWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81104f38:	defffc04 	addi	sp,sp,-16
81104f3c:	de00012e 	bgeu	sp,et,81104f44 <vDpktWriteReg+0xc>
81104f40:	003b68fa 	trap	3
81104f44:	df000315 	stw	fp,12(sp)
81104f48:	df000304 	addi	fp,sp,12
81104f4c:	e13ffd15 	stw	r4,-12(fp)
81104f50:	e17ffe15 	stw	r5,-8(fp)
81104f54:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81104f58:	e0bffe17 	ldw	r2,-8(fp)
81104f5c:	1085883a 	add	r2,r2,r2
81104f60:	1085883a 	add	r2,r2,r2
81104f64:	1007883a 	mov	r3,r2
81104f68:	e0bffd17 	ldw	r2,-12(fp)
81104f6c:	10c5883a 	add	r2,r2,r3
81104f70:	e0ffff17 	ldw	r3,-4(fp)
81104f74:	10c00015 	stw	r3,0(r2)
}
81104f78:	0001883a 	nop
81104f7c:	e037883a 	mov	sp,fp
81104f80:	df000017 	ldw	fp,0(sp)
81104f84:	dec00104 	addi	sp,sp,4
81104f88:	f800283a 	ret

81104f8c <uliDpktReadReg>:

static alt_u32 uliDpktReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81104f8c:	defffc04 	addi	sp,sp,-16
81104f90:	de00012e 	bgeu	sp,et,81104f98 <uliDpktReadReg+0xc>
81104f94:	003b68fa 	trap	3
81104f98:	df000315 	stw	fp,12(sp)
81104f9c:	df000304 	addi	fp,sp,12
81104fa0:	e13ffe15 	stw	r4,-8(fp)
81104fa4:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81104fa8:	e0bfff17 	ldw	r2,-4(fp)
81104fac:	1085883a 	add	r2,r2,r2
81104fb0:	1085883a 	add	r2,r2,r2
81104fb4:	1007883a 	mov	r3,r2
81104fb8:	e0bffe17 	ldw	r2,-8(fp)
81104fbc:	10c5883a 	add	r2,r2,r3
81104fc0:	10800017 	ldw	r2,0(r2)
81104fc4:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81104fc8:	e0bffd17 	ldw	r2,-12(fp)
}
81104fcc:	e037883a 	mov	sp,fp
81104fd0:	df000017 	ldw	fp,0(sp)
81104fd4:	dec00104 	addi	sp,sp,4
81104fd8:	f800283a 	ret

81104fdc <vFeebCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vFeebCh1HandleIrq(void* pvContext) {
81104fdc:	defffa04 	addi	sp,sp,-24
81104fe0:	de00012e 	bgeu	sp,et,81104fe8 <vFeebCh1HandleIrq+0xc>
81104fe4:	003b68fa 	trap	3
81104fe8:	dfc00515 	stw	ra,20(sp)
81104fec:	df000415 	stw	fp,16(sp)
81104ff0:	df000404 	addi	fp,sp,16
81104ff4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81104ff8:	e0bfff17 	ldw	r2,-4(fp)
81104ffc:	e0bffc15 	stw	r2,-16(fp)
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105000:	00800404 	movi	r2,16
81105004:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105008:	00bfe004 	movi	r2,-128
8110500c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105010:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 0;
81105014:	e03ffe05 	stb	zero,-8(fp)


	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105018:	d0a05917 	ldw	r2,-32412(gp)
8110501c:	e0fffe17 	ldw	r3,-8(fp)
81105020:	180b883a 	mov	r5,r3
81105024:	1009883a 	mov	r4,r2
81105028:	113a0040 	call	8113a004 <OSQPost>
8110502c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105030:	e0bffd03 	ldbu	r2,-12(fp)
81105034:	10000226 	beq	r2,zero,81105040 <vFeebCh1HandleIrq+0x64>
		vFailRequestDMAFromIRQ( 0 );
81105038:	0009883a 	mov	r4,zero
8110503c:	11195f80 	call	811195f8 <vFailRequestDMAFromIRQ>

	/* Make one requests for the Double buffer */
	/* Address of the NFEE is hard coded */


	vFeebCh1IrqFlagClrBufferEmpty();
81105040:	11053700 	call	81105370 <vFeebCh1IrqFlagClrBufferEmpty>
}
81105044:	0001883a 	nop
81105048:	e037883a 	mov	sp,fp
8110504c:	dfc00117 	ldw	ra,4(sp)
81105050:	df000017 	ldw	fp,0(sp)
81105054:	dec00204 	addi	sp,sp,8
81105058:	f800283a 	ret

8110505c <vFeebCh2HandleIrq>:

void vFeebCh2HandleIrq(void* pvContext) {
8110505c:	defffa04 	addi	sp,sp,-24
81105060:	de00012e 	bgeu	sp,et,81105068 <vFeebCh2HandleIrq+0xc>
81105064:	003b68fa 	trap	3
81105068:	dfc00515 	stw	ra,20(sp)
8110506c:	df000415 	stw	fp,16(sp)
81105070:	df000404 	addi	fp,sp,16
81105074:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105078:	e0bfff17 	ldw	r2,-4(fp)
8110507c:	e0bffc15 	stw	r2,-16(fp)

	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105080:	00800404 	movi	r2,16
81105084:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105088:	00bfe004 	movi	r2,-128
8110508c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105090:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 1;
81105094:	00800044 	movi	r2,1
81105098:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110509c:	d0a05917 	ldw	r2,-32412(gp)
811050a0:	e0fffe17 	ldw	r3,-8(fp)
811050a4:	180b883a 	mov	r5,r3
811050a8:	1009883a 	mov	r4,r2
811050ac:	113a0040 	call	8113a004 <OSQPost>
811050b0:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811050b4:	e0bffd03 	ldbu	r2,-12(fp)
811050b8:	10000226 	beq	r2,zero,811050c4 <vFeebCh2HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 1 );
811050bc:	01000044 	movi	r4,1
811050c0:	11195f80 	call	811195f8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh2IrqFlagClrBufferEmpty();
811050c4:	11053b40 	call	811053b4 <vFeebCh2IrqFlagClrBufferEmpty>
}
811050c8:	0001883a 	nop
811050cc:	e037883a 	mov	sp,fp
811050d0:	dfc00117 	ldw	ra,4(sp)
811050d4:	df000017 	ldw	fp,0(sp)
811050d8:	dec00204 	addi	sp,sp,8
811050dc:	f800283a 	ret

811050e0 <vFeebCh3HandleIrq>:

void vFeebCh3HandleIrq(void* pvContext) {
811050e0:	defffa04 	addi	sp,sp,-24
811050e4:	de00012e 	bgeu	sp,et,811050ec <vFeebCh3HandleIrq+0xc>
811050e8:	003b68fa 	trap	3
811050ec:	dfc00515 	stw	ra,20(sp)
811050f0:	df000415 	stw	fp,16(sp)
811050f4:	df000404 	addi	fp,sp,16
811050f8:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
811050fc:	e0bfff17 	ldw	r2,-4(fp)
81105100:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105104:	00800404 	movi	r2,16
81105108:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
8110510c:	00bfe004 	movi	r2,-128
81105110:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105114:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 2;
81105118:	00800084 	movi	r2,2
8110511c:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105120:	d0a05917 	ldw	r2,-32412(gp)
81105124:	e0fffe17 	ldw	r3,-8(fp)
81105128:	180b883a 	mov	r5,r3
8110512c:	1009883a 	mov	r4,r2
81105130:	113a0040 	call	8113a004 <OSQPost>
81105134:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105138:	e0bffd03 	ldbu	r2,-12(fp)
8110513c:	10000226 	beq	r2,zero,81105148 <vFeebCh3HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 2 );
81105140:	01000084 	movi	r4,2
81105144:	11195f80 	call	811195f8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh3IrqFlagClrBufferEmpty();
81105148:	11053f80 	call	811053f8 <vFeebCh3IrqFlagClrBufferEmpty>
}
8110514c:	0001883a 	nop
81105150:	e037883a 	mov	sp,fp
81105154:	dfc00117 	ldw	ra,4(sp)
81105158:	df000017 	ldw	fp,0(sp)
8110515c:	dec00204 	addi	sp,sp,8
81105160:	f800283a 	ret

81105164 <vFeebCh4HandleIrq>:

void vFeebCh4HandleIrq(void* pvContext) {
81105164:	defffa04 	addi	sp,sp,-24
81105168:	de00012e 	bgeu	sp,et,81105170 <vFeebCh4HandleIrq+0xc>
8110516c:	003b68fa 	trap	3
81105170:	dfc00515 	stw	ra,20(sp)
81105174:	df000415 	stw	fp,16(sp)
81105178:	df000404 	addi	fp,sp,16
8110517c:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105180:	e0bfff17 	ldw	r2,-4(fp)
81105184:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105188:	00800404 	movi	r2,16
8110518c:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105190:	00bfe004 	movi	r2,-128
81105194:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
81105198:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 3;
8110519c:	008000c4 	movi	r2,3
811051a0:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811051a4:	d0a05917 	ldw	r2,-32412(gp)
811051a8:	e0fffe17 	ldw	r3,-8(fp)
811051ac:	180b883a 	mov	r5,r3
811051b0:	1009883a 	mov	r4,r2
811051b4:	113a0040 	call	8113a004 <OSQPost>
811051b8:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811051bc:	e0bffd03 	ldbu	r2,-12(fp)
811051c0:	10000226 	beq	r2,zero,811051cc <vFeebCh4HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 3 );
811051c4:	010000c4 	movi	r4,3
811051c8:	11195f80 	call	811195f8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh4IrqFlagClrBufferEmpty();
811051cc:	110543c0 	call	8110543c <vFeebCh4IrqFlagClrBufferEmpty>
}
811051d0:	0001883a 	nop
811051d4:	e037883a 	mov	sp,fp
811051d8:	dfc00117 	ldw	ra,4(sp)
811051dc:	df000017 	ldw	fp,0(sp)
811051e0:	dec00204 	addi	sp,sp,8
811051e4:	f800283a 	ret

811051e8 <vFeebCh5HandleIrq>:

void vFeebCh5HandleIrq(void* pvContext) {
811051e8:	defffa04 	addi	sp,sp,-24
811051ec:	de00012e 	bgeu	sp,et,811051f4 <vFeebCh5HandleIrq+0xc>
811051f0:	003b68fa 	trap	3
811051f4:	dfc00515 	stw	ra,20(sp)
811051f8:	df000415 	stw	fp,16(sp)
811051fc:	df000404 	addi	fp,sp,16
81105200:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105204:	e0bfff17 	ldw	r2,-4(fp)
81105208:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110520c:	00800404 	movi	r2,16
81105210:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105214:	00bfe004 	movi	r2,-128
81105218:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
8110521c:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 4;
81105220:	00800104 	movi	r2,4
81105224:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
81105228:	d0a05917 	ldw	r2,-32412(gp)
8110522c:	e0fffe17 	ldw	r3,-8(fp)
81105230:	180b883a 	mov	r5,r3
81105234:	1009883a 	mov	r4,r2
81105238:	113a0040 	call	8113a004 <OSQPost>
8110523c:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
81105240:	e0bffd03 	ldbu	r2,-12(fp)
81105244:	10000226 	beq	r2,zero,81105250 <vFeebCh5HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 4 );
81105248:	01000104 	movi	r4,4
8110524c:	11195f80 	call	811195f8 <vFailRequestDMAFromIRQ>
	}

	vFeebCh5IrqFlagClrBufferEmpty();
81105250:	11054800 	call	81105480 <vFeebCh5IrqFlagClrBufferEmpty>
}
81105254:	0001883a 	nop
81105258:	e037883a 	mov	sp,fp
8110525c:	dfc00117 	ldw	ra,4(sp)
81105260:	df000017 	ldw	fp,0(sp)
81105264:	dec00204 	addi	sp,sp,8
81105268:	f800283a 	ret

8110526c <vFeebCh6HandleIrq>:

void vFeebCh6HandleIrq(void* pvContext) {
8110526c:	defffa04 	addi	sp,sp,-24
81105270:	de00012e 	bgeu	sp,et,81105278 <vFeebCh6HandleIrq+0xc>
81105274:	003b68fa 	trap	3
81105278:	dfc00515 	stw	ra,20(sp)
8110527c:	df000415 	stw	fp,16(sp)
81105280:	df000404 	addi	fp,sp,16
81105284:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
81105288:	e0bfff17 	ldw	r2,-4(fp)
8110528c:	e0bffc15 	stw	r2,-16(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81105290:	00800404 	movi	r2,16
81105294:	e0bffec5 	stb	r2,-5(fp)
	uiCmdtoSend.ucByte[2] = M_NFC_DMA_REQUEST;
81105298:	00bfe004 	movi	r2,-128
8110529c:	e0bffe85 	stb	r2,-6(fp)
	uiCmdtoSend.ucByte[1] = 0;
811052a0:	e03ffe45 	stb	zero,-7(fp)
	uiCmdtoSend.ucByte[0] = 5;
811052a4:	00800144 	movi	r2,5
811052a8:	e0bffe05 	stb	r2,-8(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
811052ac:	d0a05917 	ldw	r2,-32412(gp)
811052b0:	e0fffe17 	ldw	r3,-8(fp)
811052b4:	180b883a 	mov	r5,r3
811052b8:	1009883a 	mov	r4,r2
811052bc:	113a0040 	call	8113a004 <OSQPost>
811052c0:	e0bffd05 	stb	r2,-12(fp)
	if ( error_codel != OS_ERR_NONE ) {
811052c4:	e0bffd03 	ldbu	r2,-12(fp)
811052c8:	10000226 	beq	r2,zero,811052d4 <vFeebCh6HandleIrq+0x68>
		vFailRequestDMAFromIRQ( 5 );
811052cc:	01000144 	movi	r4,5
811052d0:	11195f80 	call	811195f8 <vFailRequestDMAFromIRQ>
	}


	vFeebCh6IrqFlagClrBufferEmpty();
811052d4:	11054c40 	call	811054c4 <vFeebCh6IrqFlagClrBufferEmpty>
}
811052d8:	0001883a 	nop
811052dc:	e037883a 	mov	sp,fp
811052e0:	dfc00117 	ldw	ra,4(sp)
811052e4:	df000017 	ldw	fp,0(sp)
811052e8:	dec00204 	addi	sp,sp,8
811052ec:	f800283a 	ret

811052f0 <vFeebCh7HandleIrq>:

void vFeebCh7HandleIrq(void* pvContext) {
811052f0:	defffc04 	addi	sp,sp,-16
811052f4:	de00012e 	bgeu	sp,et,811052fc <vFeebCh7HandleIrq+0xc>
811052f8:	003b68fa 	trap	3
811052fc:	dfc00315 	stw	ra,12(sp)
81105300:	df000215 	stw	fp,8(sp)
81105304:	df000204 	addi	fp,sp,8
81105308:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110530c:	e0bfff17 	ldw	r2,-4(fp)
81105310:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh7IrqFlagClrBufferEmpty();
81105314:	11055080 	call	81105508 <vFeebCh7IrqFlagClrBufferEmpty>
}
81105318:	0001883a 	nop
8110531c:	e037883a 	mov	sp,fp
81105320:	dfc00117 	ldw	ra,4(sp)
81105324:	df000017 	ldw	fp,0(sp)
81105328:	dec00204 	addi	sp,sp,8
8110532c:	f800283a 	ret

81105330 <vFeebCh8HandleIrq>:

void vFeebCh8HandleIrq(void* pvContext) {
81105330:	defffc04 	addi	sp,sp,-16
81105334:	de00012e 	bgeu	sp,et,8110533c <vFeebCh8HandleIrq+0xc>
81105338:	003b68fa 	trap	3
8110533c:	dfc00315 	stw	ra,12(sp)
81105340:	df000215 	stw	fp,8(sp)
81105344:	df000204 	addi	fp,sp,8
81105348:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110534c:	e0bfff17 	ldw	r2,-4(fp)
81105350:	e0bffe15 	stw	r2,-8(fp)


	vFeebCh8IrqFlagClrBufferEmpty();
81105354:	110554c0 	call	8110554c <vFeebCh8IrqFlagClrBufferEmpty>
}
81105358:	0001883a 	nop
8110535c:	e037883a 	mov	sp,fp
81105360:	dfc00117 	ldw	ra,4(sp)
81105364:	df000017 	ldw	fp,0(sp)
81105368:	dec00204 	addi	sp,sp,8
8110536c:	f800283a 	ret

81105370 <vFeebCh1IrqFlagClrBufferEmpty>:

void vFeebCh1IrqFlagClrBufferEmpty(void) {
81105370:	defffe04 	addi	sp,sp,-8
81105374:	de00012e 	bgeu	sp,et,8110537c <vFeebCh1IrqFlagClrBufferEmpty+0xc>
81105378:	003b68fa 	trap	3
8110537c:	dfc00115 	stw	ra,4(sp)
81105380:	df000015 	stw	fp,0(sp)
81105384:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81105388:	01804004 	movi	r6,256
8110538c:	014004c4 	movi	r5,19
81105390:	01204834 	movhi	r4,33056
81105394:	210b0004 	addi	r4,r4,11264
81105398:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
8110539c:	0001883a 	nop
811053a0:	e037883a 	mov	sp,fp
811053a4:	dfc00117 	ldw	ra,4(sp)
811053a8:	df000017 	ldw	fp,0(sp)
811053ac:	dec00204 	addi	sp,sp,8
811053b0:	f800283a 	ret

811053b4 <vFeebCh2IrqFlagClrBufferEmpty>:

void vFeebCh2IrqFlagClrBufferEmpty(void) {
811053b4:	defffe04 	addi	sp,sp,-8
811053b8:	de00012e 	bgeu	sp,et,811053c0 <vFeebCh2IrqFlagClrBufferEmpty+0xc>
811053bc:	003b68fa 	trap	3
811053c0:	dfc00115 	stw	ra,4(sp)
811053c4:	df000015 	stw	fp,0(sp)
811053c8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
811053cc:	01804004 	movi	r6,256
811053d0:	014004c4 	movi	r5,19
811053d4:	01204834 	movhi	r4,33056
811053d8:	210a0004 	addi	r4,r4,10240
811053dc:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811053e0:	0001883a 	nop
811053e4:	e037883a 	mov	sp,fp
811053e8:	dfc00117 	ldw	ra,4(sp)
811053ec:	df000017 	ldw	fp,0(sp)
811053f0:	dec00204 	addi	sp,sp,8
811053f4:	f800283a 	ret

811053f8 <vFeebCh3IrqFlagClrBufferEmpty>:

void vFeebCh3IrqFlagClrBufferEmpty(void) {
811053f8:	defffe04 	addi	sp,sp,-8
811053fc:	de00012e 	bgeu	sp,et,81105404 <vFeebCh3IrqFlagClrBufferEmpty+0xc>
81105400:	003b68fa 	trap	3
81105404:	dfc00115 	stw	ra,4(sp)
81105408:	df000015 	stw	fp,0(sp)
8110540c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105410:	01804004 	movi	r6,256
81105414:	014004c4 	movi	r5,19
81105418:	01204834 	movhi	r4,33056
8110541c:	21090004 	addi	r4,r4,9216
81105420:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105424:	0001883a 	nop
81105428:	e037883a 	mov	sp,fp
8110542c:	dfc00117 	ldw	ra,4(sp)
81105430:	df000017 	ldw	fp,0(sp)
81105434:	dec00204 	addi	sp,sp,8
81105438:	f800283a 	ret

8110543c <vFeebCh4IrqFlagClrBufferEmpty>:

void vFeebCh4IrqFlagClrBufferEmpty(void) {
8110543c:	defffe04 	addi	sp,sp,-8
81105440:	de00012e 	bgeu	sp,et,81105448 <vFeebCh4IrqFlagClrBufferEmpty+0xc>
81105444:	003b68fa 	trap	3
81105448:	dfc00115 	stw	ra,4(sp)
8110544c:	df000015 	stw	fp,0(sp)
81105450:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81105454:	01804004 	movi	r6,256
81105458:	014004c4 	movi	r5,19
8110545c:	01204834 	movhi	r4,33056
81105460:	21080004 	addi	r4,r4,8192
81105464:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105468:	0001883a 	nop
8110546c:	e037883a 	mov	sp,fp
81105470:	dfc00117 	ldw	ra,4(sp)
81105474:	df000017 	ldw	fp,0(sp)
81105478:	dec00204 	addi	sp,sp,8
8110547c:	f800283a 	ret

81105480 <vFeebCh5IrqFlagClrBufferEmpty>:

void vFeebCh5IrqFlagClrBufferEmpty(void) {
81105480:	defffe04 	addi	sp,sp,-8
81105484:	de00012e 	bgeu	sp,et,8110548c <vFeebCh5IrqFlagClrBufferEmpty+0xc>
81105488:	003b68fa 	trap	3
8110548c:	dfc00115 	stw	ra,4(sp)
81105490:	df000015 	stw	fp,0(sp)
81105494:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105498:	01804004 	movi	r6,256
8110549c:	014004c4 	movi	r5,19
811054a0:	01204834 	movhi	r4,33056
811054a4:	21070004 	addi	r4,r4,7168
811054a8:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054ac:	0001883a 	nop
811054b0:	e037883a 	mov	sp,fp
811054b4:	dfc00117 	ldw	ra,4(sp)
811054b8:	df000017 	ldw	fp,0(sp)
811054bc:	dec00204 	addi	sp,sp,8
811054c0:	f800283a 	ret

811054c4 <vFeebCh6IrqFlagClrBufferEmpty>:

void vFeebCh6IrqFlagClrBufferEmpty(void) {
811054c4:	defffe04 	addi	sp,sp,-8
811054c8:	de00012e 	bgeu	sp,et,811054d0 <vFeebCh6IrqFlagClrBufferEmpty+0xc>
811054cc:	003b68fa 	trap	3
811054d0:	dfc00115 	stw	ra,4(sp)
811054d4:	df000015 	stw	fp,0(sp)
811054d8:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811054dc:	01804004 	movi	r6,256
811054e0:	014004c4 	movi	r5,19
811054e4:	01204834 	movhi	r4,33056
811054e8:	21060004 	addi	r4,r4,6144
811054ec:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
811054f0:	0001883a 	nop
811054f4:	e037883a 	mov	sp,fp
811054f8:	dfc00117 	ldw	ra,4(sp)
811054fc:	df000017 	ldw	fp,0(sp)
81105500:	dec00204 	addi	sp,sp,8
81105504:	f800283a 	ret

81105508 <vFeebCh7IrqFlagClrBufferEmpty>:

void vFeebCh7IrqFlagClrBufferEmpty(void) {
81105508:	defffe04 	addi	sp,sp,-8
8110550c:	de00012e 	bgeu	sp,et,81105514 <vFeebCh7IrqFlagClrBufferEmpty+0xc>
81105510:	003b68fa 	trap	3
81105514:	dfc00115 	stw	ra,4(sp)
81105518:	df000015 	stw	fp,0(sp)
8110551c:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81105520:	01804004 	movi	r6,256
81105524:	014004c4 	movi	r5,19
81105528:	01204834 	movhi	r4,33056
8110552c:	21050004 	addi	r4,r4,5120
81105530:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105534:	0001883a 	nop
81105538:	e037883a 	mov	sp,fp
8110553c:	dfc00117 	ldw	ra,4(sp)
81105540:	df000017 	ldw	fp,0(sp)
81105544:	dec00204 	addi	sp,sp,8
81105548:	f800283a 	ret

8110554c <vFeebCh8IrqFlagClrBufferEmpty>:

void vFeebCh8IrqFlagClrBufferEmpty(void) {
8110554c:	defffe04 	addi	sp,sp,-8
81105550:	de00012e 	bgeu	sp,et,81105558 <vFeebCh8IrqFlagClrBufferEmpty+0xc>
81105554:	003b68fa 	trap	3
81105558:	dfc00115 	stw	ra,4(sp)
8110555c:	df000015 	stw	fp,0(sp)
81105560:	d839883a 	mov	fp,sp
	vFeebWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105564:	01804004 	movi	r6,256
81105568:	014004c4 	movi	r5,19
8110556c:	01204834 	movhi	r4,33056
81105570:	21040004 	addi	r4,r4,4096
81105574:	11060cc0 	call	811060cc <vFeebWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_BUFF_EPY_FLG_CLR_MSK);
}
81105578:	0001883a 	nop
8110557c:	e037883a 	mov	sp,fp
81105580:	dfc00117 	ldw	ra,4(sp)
81105584:	df000017 	ldw	fp,0(sp)
81105588:	dec00204 	addi	sp,sp,8
8110558c:	f800283a 	ret

81105590 <bFeebCh1IrqFlagBufferEmpty>:

bool bFeebCh1IrqFlagBufferEmpty(void) {
81105590:	defffd04 	addi	sp,sp,-12
81105594:	de00012e 	bgeu	sp,et,8110559c <bFeebCh1IrqFlagBufferEmpty+0xc>
81105598:	003b68fa 	trap	3
8110559c:	dfc00215 	stw	ra,8(sp)
811055a0:	df000115 	stw	fp,4(sp)
811055a4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811055a8:	01400484 	movi	r5,18
811055ac:	01204834 	movhi	r4,33056
811055b0:	210b0004 	addi	r4,r4,11264
811055b4:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811055b8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh1IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811055bc:	10000326 	beq	r2,zero,811055cc <bFeebCh1IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811055c0:	00800044 	movi	r2,1
811055c4:	e0bfff15 	stw	r2,-4(fp)
811055c8:	00000106 	br	811055d0 <bFeebCh1IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811055cc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811055d0:	e0bfff17 	ldw	r2,-4(fp)
}
811055d4:	e037883a 	mov	sp,fp
811055d8:	dfc00117 	ldw	ra,4(sp)
811055dc:	df000017 	ldw	fp,0(sp)
811055e0:	dec00204 	addi	sp,sp,8
811055e4:	f800283a 	ret

811055e8 <bFeebCh2IrqFlagBufferEmpty>:

bool bFeebCh2IrqFlagBufferEmpty(void) {
811055e8:	defffd04 	addi	sp,sp,-12
811055ec:	de00012e 	bgeu	sp,et,811055f4 <bFeebCh2IrqFlagBufferEmpty+0xc>
811055f0:	003b68fa 	trap	3
811055f4:	dfc00215 	stw	ra,8(sp)
811055f8:	df000115 	stw	fp,4(sp)
811055fc:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105600:	01400484 	movi	r5,18
81105604:	01204834 	movhi	r4,33056
81105608:	210a0004 	addi	r4,r4,10240
8110560c:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105610:	1080400c 	andi	r2,r2,256
}

bool bFeebCh2IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81105614:	10000326 	beq	r2,zero,81105624 <bFeebCh2IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105618:	00800044 	movi	r2,1
8110561c:	e0bfff15 	stw	r2,-4(fp)
81105620:	00000106 	br	81105628 <bFeebCh2IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105624:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105628:	e0bfff17 	ldw	r2,-4(fp)
}
8110562c:	e037883a 	mov	sp,fp
81105630:	dfc00117 	ldw	ra,4(sp)
81105634:	df000017 	ldw	fp,0(sp)
81105638:	dec00204 	addi	sp,sp,8
8110563c:	f800283a 	ret

81105640 <bFeebCh3IrqFlagBufferEmpty>:

bool bFeebCh3IrqFlagBufferEmpty(void) {
81105640:	defffd04 	addi	sp,sp,-12
81105644:	de00012e 	bgeu	sp,et,8110564c <bFeebCh3IrqFlagBufferEmpty+0xc>
81105648:	003b68fa 	trap	3
8110564c:	dfc00215 	stw	ra,8(sp)
81105650:	df000115 	stw	fp,4(sp)
81105654:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
81105658:	01400484 	movi	r5,18
8110565c:	01204834 	movhi	r4,33056
81105660:	21090004 	addi	r4,r4,9216
81105664:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105668:	1080400c 	andi	r2,r2,256
}

bool bFeebCh3IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110566c:	10000326 	beq	r2,zero,8110567c <bFeebCh3IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105670:	00800044 	movi	r2,1
81105674:	e0bfff15 	stw	r2,-4(fp)
81105678:	00000106 	br	81105680 <bFeebCh3IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110567c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105680:	e0bfff17 	ldw	r2,-4(fp)
}
81105684:	e037883a 	mov	sp,fp
81105688:	dfc00117 	ldw	ra,4(sp)
8110568c:	df000017 	ldw	fp,0(sp)
81105690:	dec00204 	addi	sp,sp,8
81105694:	f800283a 	ret

81105698 <bFeebCh4IrqFlagBufferEmpty>:

bool bFeebCh4IrqFlagBufferEmpty(void) {
81105698:	defffd04 	addi	sp,sp,-12
8110569c:	de00012e 	bgeu	sp,et,811056a4 <bFeebCh4IrqFlagBufferEmpty+0xc>
811056a0:	003b68fa 	trap	3
811056a4:	dfc00215 	stw	ra,8(sp)
811056a8:	df000115 	stw	fp,4(sp)
811056ac:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811056b0:	01400484 	movi	r5,18
811056b4:	01204834 	movhi	r4,33056
811056b8:	21080004 	addi	r4,r4,8192
811056bc:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811056c0:	1080400c 	andi	r2,r2,256
}

bool bFeebCh4IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811056c4:	10000326 	beq	r2,zero,811056d4 <bFeebCh4IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811056c8:	00800044 	movi	r2,1
811056cc:	e0bfff15 	stw	r2,-4(fp)
811056d0:	00000106 	br	811056d8 <bFeebCh4IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811056d4:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811056d8:	e0bfff17 	ldw	r2,-4(fp)
}
811056dc:	e037883a 	mov	sp,fp
811056e0:	dfc00117 	ldw	ra,4(sp)
811056e4:	df000017 	ldw	fp,0(sp)
811056e8:	dec00204 	addi	sp,sp,8
811056ec:	f800283a 	ret

811056f0 <bFeebCh5IrqFlagBufferEmpty>:

bool bFeebCh5IrqFlagBufferEmpty(void) {
811056f0:	defffd04 	addi	sp,sp,-12
811056f4:	de00012e 	bgeu	sp,et,811056fc <bFeebCh5IrqFlagBufferEmpty+0xc>
811056f8:	003b68fa 	trap	3
811056fc:	dfc00215 	stw	ra,8(sp)
81105700:	df000115 	stw	fp,4(sp)
81105704:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81105708:	01400484 	movi	r5,18
8110570c:	01204834 	movhi	r4,33056
81105710:	21070004 	addi	r4,r4,7168
81105714:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105718:	1080400c 	andi	r2,r2,256
}

bool bFeebCh5IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
8110571c:	10000326 	beq	r2,zero,8110572c <bFeebCh5IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105720:	00800044 	movi	r2,1
81105724:	e0bfff15 	stw	r2,-4(fp)
81105728:	00000106 	br	81105730 <bFeebCh5IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
8110572c:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105730:	e0bfff17 	ldw	r2,-4(fp)
}
81105734:	e037883a 	mov	sp,fp
81105738:	dfc00117 	ldw	ra,4(sp)
8110573c:	df000017 	ldw	fp,0(sp)
81105740:	dec00204 	addi	sp,sp,8
81105744:	f800283a 	ret

81105748 <bFeebCh6IrqFlagBufferEmpty>:

bool bFeebCh6IrqFlagBufferEmpty(void) {
81105748:	defffd04 	addi	sp,sp,-12
8110574c:	de00012e 	bgeu	sp,et,81105754 <bFeebCh6IrqFlagBufferEmpty+0xc>
81105750:	003b68fa 	trap	3
81105754:	dfc00215 	stw	ra,8(sp)
81105758:	df000115 	stw	fp,4(sp)
8110575c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105760:	01400484 	movi	r5,18
81105764:	01204834 	movhi	r4,33056
81105768:	21060004 	addi	r4,r4,6144
8110576c:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105770:	1080400c 	andi	r2,r2,256
}

bool bFeebCh6IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81105774:	10000326 	beq	r2,zero,81105784 <bFeebCh6IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105778:	00800044 	movi	r2,1
8110577c:	e0bfff15 	stw	r2,-4(fp)
81105780:	00000106 	br	81105788 <bFeebCh6IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105784:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105788:	e0bfff17 	ldw	r2,-4(fp)
}
8110578c:	e037883a 	mov	sp,fp
81105790:	dfc00117 	ldw	ra,4(sp)
81105794:	df000017 	ldw	fp,0(sp)
81105798:	dec00204 	addi	sp,sp,8
8110579c:	f800283a 	ret

811057a0 <bFeebCh7IrqFlagBufferEmpty>:

bool bFeebCh7IrqFlagBufferEmpty(void) {
811057a0:	defffd04 	addi	sp,sp,-12
811057a4:	de00012e 	bgeu	sp,et,811057ac <bFeebCh7IrqFlagBufferEmpty+0xc>
811057a8:	003b68fa 	trap	3
811057ac:	dfc00215 	stw	ra,8(sp)
811057b0:	df000115 	stw	fp,4(sp)
811057b4:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057b8:	01400484 	movi	r5,18
811057bc:	01204834 	movhi	r4,33056
811057c0:	21050004 	addi	r4,r4,5120
811057c4:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
811057c8:	1080400c 	andi	r2,r2,256
}

bool bFeebCh7IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
811057cc:	10000326 	beq	r2,zero,811057dc <bFeebCh7IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
811057d0:	00800044 	movi	r2,1
811057d4:	e0bfff15 	stw	r2,-4(fp)
811057d8:	00000106 	br	811057e0 <bFeebCh7IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
811057dc:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811057e0:	e0bfff17 	ldw	r2,-4(fp)
}
811057e4:	e037883a 	mov	sp,fp
811057e8:	dfc00117 	ldw	ra,4(sp)
811057ec:	df000017 	ldw	fp,0(sp)
811057f0:	dec00204 	addi	sp,sp,8
811057f4:	f800283a 	ret

811057f8 <bFeebCh8IrqFlagBufferEmpty>:

bool bFeebCh8IrqFlagBufferEmpty(void) {
811057f8:	defffd04 	addi	sp,sp,-12
811057fc:	de00012e 	bgeu	sp,et,81105804 <bFeebCh8IrqFlagBufferEmpty+0xc>
81105800:	003b68fa 	trap	3
81105804:	dfc00215 	stw	ra,8(sp)
81105808:	df000115 	stw	fp,4(sp)
8110580c:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105810:	01400484 	movi	r5,18
81105814:	01204834 	movhi	r4,33056
81105818:	21040004 	addi	r4,r4,4096
8110581c:	11061200 	call	81106120 <uliFeebReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105820:	1080400c 	andi	r2,r2,256
}

bool bFeebCh8IrqFlagBufferEmpty(void) {
	bool bFlag;

	if (uliFeebReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81105824:	10000326 	beq	r2,zero,81105834 <bFeebCh8IrqFlagBufferEmpty+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_BUFF_EPY_FLG_MSK) {
		bFlag = TRUE;
81105828:	00800044 	movi	r2,1
8110582c:	e0bfff15 	stw	r2,-4(fp)
81105830:	00000106 	br	81105838 <bFeebCh8IrqFlagBufferEmpty+0x40>
	} else {
		bFlag = FALSE;
81105834:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81105838:	e0bfff17 	ldw	r2,-4(fp)
}
8110583c:	e037883a 	mov	sp,fp
81105840:	dfc00117 	ldw	ra,4(sp)
81105844:	df000017 	ldw	fp,0(sp)
81105848:	dec00204 	addi	sp,sp,8
8110584c:	f800283a 	ret

81105850 <vFeebInitIrq>:

void vFeebInitIrq(alt_u8 ucCommCh) {
81105850:	defffc04 	addi	sp,sp,-16
81105854:	de00012e 	bgeu	sp,et,8110585c <vFeebInitIrq+0xc>
81105858:	003b68fa 	trap	3
8110585c:	dfc00315 	stw	ra,12(sp)
81105860:	df000215 	stw	fp,8(sp)
81105864:	df000204 	addi	fp,sp,8
81105868:	2005883a 	mov	r2,r4
8110586c:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81105870:	e0bfff03 	ldbu	r2,-4(fp)
81105874:	10c00228 	cmpgeui	r3,r2,8
81105878:	18004e1e 	bne	r3,zero,811059b4 <vFeebInitIrq+0x164>
8110587c:	100690ba 	slli	r3,r2,2
81105880:	00a04434 	movhi	r2,33040
81105884:	10962504 	addi	r2,r2,22676
81105888:	1885883a 	add	r2,r3,r2
8110588c:	10800017 	ldw	r2,0(r2)
81105890:	1000683a 	jmp	r2
81105894:	811058b4 	orhi	r4,r16,16738
81105898:	811058d4 	ori	r4,r16,16739
8110589c:	811058f4 	orhi	r4,r16,16739
811058a0:	81105914 	ori	r4,r16,16740
811058a4:	81105934 	orhi	r4,r16,16740
811058a8:	81105954 	ori	r4,r16,16741
811058ac:	81105974 	orhi	r4,r16,16741
811058b0:	81105994 	ori	r4,r16,16742
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
811058b4:	d0a03f04 	addi	r2,gp,-32516
811058b8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_BUFFERS_IRQ, pvHoldContext,
811058bc:	01a04434 	movhi	r6,33040
811058c0:	3193f704 	addi	r6,r6,20444
811058c4:	e17ffe17 	ldw	r5,-8(fp)
811058c8:	01000584 	movi	r4,22
811058cc:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh1HandleIrq);
		break;
811058d0:	00003806 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
811058d4:	d0a04004 	addi	r2,gp,-32512
811058d8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_BUFFERS_IRQ, pvHoldContext,
811058dc:	01a04434 	movhi	r6,33040
811058e0:	31941704 	addi	r6,r6,20572
811058e4:	e17ffe17 	ldw	r5,-8(fp)
811058e8:	01000504 	movi	r4,20
811058ec:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh2HandleIrq);
		break;
811058f0:	00003006 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
811058f4:	d0a04104 	addi	r2,gp,-32508
811058f8:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_BUFFERS_IRQ, pvHoldContext,
811058fc:	01a04434 	movhi	r6,33040
81105900:	31943804 	addi	r6,r6,20704
81105904:	e17ffe17 	ldw	r5,-8(fp)
81105908:	01000484 	movi	r4,18
8110590c:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh3HandleIrq);
		break;
81105910:	00002806 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81105914:	d0a04204 	addi	r2,gp,-32504
81105918:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_BUFFERS_IRQ, pvHoldContext,
8110591c:	01a04434 	movhi	r6,33040
81105920:	31945904 	addi	r6,r6,20836
81105924:	e17ffe17 	ldw	r5,-8(fp)
81105928:	01000404 	movi	r4,16
8110592c:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh4HandleIrq);
		break;
81105930:	00002006 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81105934:	d0a04304 	addi	r2,gp,-32500
81105938:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_BUFFERS_IRQ, pvHoldContext,
8110593c:	01a04434 	movhi	r6,33040
81105940:	31947a04 	addi	r6,r6,20968
81105944:	e17ffe17 	ldw	r5,-8(fp)
81105948:	01000204 	movi	r4,8
8110594c:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh5HandleIrq);
		break;
81105950:	00001806 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81105954:	d0a04404 	addi	r2,gp,-32496
81105958:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_BUFFERS_IRQ, pvHoldContext,
8110595c:	01a04434 	movhi	r6,33040
81105960:	31949b04 	addi	r6,r6,21100
81105964:	e17ffe17 	ldw	r5,-8(fp)
81105968:	01000184 	movi	r4,6
8110596c:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh6HandleIrq);
		break;
81105970:	00001006 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81105974:	d0a04504 	addi	r2,gp,-32492
81105978:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_BUFFERS_IRQ, pvHoldContext,
8110597c:	01a04434 	movhi	r6,33040
81105980:	3194bc04 	addi	r6,r6,21232
81105984:	e17ffe17 	ldw	r5,-8(fp)
81105988:	01000144 	movi	r4,5
8110598c:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh7HandleIrq);
		break;
81105990:	00000806 	br	811059b4 <vFeebInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81105994:	d0a04604 	addi	r2,gp,-32488
81105998:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_BUFFERS_IRQ, pvHoldContext,
8110599c:	01a04434 	movhi	r6,33040
811059a0:	3194cc04 	addi	r6,r6,21296
811059a4:	e17ffe17 	ldw	r5,-8(fp)
811059a8:	01000084 	movi	r4,2
811059ac:	11326200 	call	81132620 <alt_irq_register>
				vFeebCh8HandleIrq);
		break;
811059b0:	0001883a 	nop
	}
}
811059b4:	0001883a 	nop
811059b8:	e037883a 	mov	sp,fp
811059bc:	dfc00117 	ldw	ra,4(sp)
811059c0:	df000017 	ldw	fp,0(sp)
811059c4:	dec00204 	addi	sp,sp,8
811059c8:	f800283a 	ret

811059cc <bFeebSetIrqControl>:

bool bFeebSetIrqControl(TFeebChannel *pxFeebCh) {
811059cc:	defffb04 	addi	sp,sp,-20
811059d0:	de00012e 	bgeu	sp,et,811059d8 <bFeebSetIrqControl+0xc>
811059d4:	003b68fa 	trap	3
811059d8:	dfc00415 	stw	ra,16(sp)
811059dc:	df000315 	stw	fp,12(sp)
811059e0:	df000304 	addi	fp,sp,12
811059e4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811059e8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811059ec:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
811059f0:	e0bfff17 	ldw	r2,-4(fp)
811059f4:	10002426 	beq	r2,zero,81105a88 <bFeebSetIrqControl+0xbc>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
811059f8:	e0bfff17 	ldw	r2,-4(fp)
811059fc:	10800017 	ldw	r2,0(r2)
81105a00:	01400444 	movi	r5,17
81105a04:	1009883a 	mov	r4,r2
81105a08:	11061200 	call	81106120 <uliFeebReadReg>
81105a0c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxFeebCh->xIrqControl.bLeftBufferEmptyEn) {
81105a10:	e0bfff17 	ldw	r2,-4(fp)
81105a14:	10800217 	ldw	r2,8(r2)
81105a18:	10000426 	beq	r2,zero,81105a2c <bFeebSetIrqControl+0x60>
			uliReg |= COMM_IRQ_LEFT_BUFF_EPY_EN_MSK;
81105a1c:	e0bffe17 	ldw	r2,-8(fp)
81105a20:	10808014 	ori	r2,r2,512
81105a24:	e0bffe15 	stw	r2,-8(fp)
81105a28:	00000406 	br	81105a3c <bFeebSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_LEFT_BUFF_EPY_EN_MSK);
81105a2c:	e0fffe17 	ldw	r3,-8(fp)
81105a30:	00bf7fc4 	movi	r2,-513
81105a34:	1884703a 	and	r2,r3,r2
81105a38:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxFeebCh->xIrqControl.bRightBufferEmptyEn) {
81105a3c:	e0bfff17 	ldw	r2,-4(fp)
81105a40:	10800317 	ldw	r2,12(r2)
81105a44:	10000426 	beq	r2,zero,81105a58 <bFeebSetIrqControl+0x8c>
			uliReg |= COMM_IRQ_RIGH_BUFF_EPY_EN_MSK;
81105a48:	e0bffe17 	ldw	r2,-8(fp)
81105a4c:	10804014 	ori	r2,r2,256
81105a50:	e0bffe15 	stw	r2,-8(fp)
81105a54:	00000406 	br	81105a68 <bFeebSetIrqControl+0x9c>
		} else {
			uliReg &= (~COMM_IRQ_RIGH_BUFF_EPY_EN_MSK);
81105a58:	e0fffe17 	ldw	r3,-8(fp)
81105a5c:	00bfbfc4 	movi	r2,-257
81105a60:	1884703a 	and	r2,r3,r2
81105a64:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_IRQ_CONTROL_REG_OFST,
81105a68:	e0bfff17 	ldw	r2,-4(fp)
81105a6c:	10800017 	ldw	r2,0(r2)
81105a70:	e1bffe17 	ldw	r6,-8(fp)
81105a74:	01400444 	movi	r5,17
81105a78:	1009883a 	mov	r4,r2
81105a7c:	11060cc0 	call	811060cc <vFeebWriteReg>
				uliReg);
		bStatus = TRUE;
81105a80:	00800044 	movi	r2,1
81105a84:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105a88:	e0bffd17 	ldw	r2,-12(fp)
}
81105a8c:	e037883a 	mov	sp,fp
81105a90:	dfc00117 	ldw	ra,4(sp)
81105a94:	df000017 	ldw	fp,0(sp)
81105a98:	dec00204 	addi	sp,sp,8
81105a9c:	f800283a 	ret

81105aa0 <bFeebGetIrqControl>:

bool bFeebGetIrqControl(TFeebChannel *pxFeebCh) {
81105aa0:	defffb04 	addi	sp,sp,-20
81105aa4:	de00012e 	bgeu	sp,et,81105aac <bFeebGetIrqControl+0xc>
81105aa8:	003b68fa 	trap	3
81105aac:	dfc00415 	stw	ra,16(sp)
81105ab0:	df000315 	stw	fp,12(sp)
81105ab4:	df000304 	addi	fp,sp,12
81105ab8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105abc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ac0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105ac4:	e0bfff17 	ldw	r2,-4(fp)
81105ac8:	10001a26 	beq	r2,zero,81105b34 <bFeebGetIrqControl+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105acc:	e0bfff17 	ldw	r2,-4(fp)
81105ad0:	10800017 	ldw	r2,0(r2)
81105ad4:	01400444 	movi	r5,17
81105ad8:	1009883a 	mov	r4,r2
81105adc:	11061200 	call	81106120 <uliFeebReadReg>
81105ae0:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_LEFT_BUFF_EPY_EN_MSK) {
81105ae4:	e0bffe17 	ldw	r2,-8(fp)
81105ae8:	1080800c 	andi	r2,r2,512
81105aec:	10000426 	beq	r2,zero,81105b00 <bFeebGetIrqControl+0x60>
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
81105af0:	e0bfff17 	ldw	r2,-4(fp)
81105af4:	00c00044 	movi	r3,1
81105af8:	10c00215 	stw	r3,8(r2)
81105afc:	00000206 	br	81105b08 <bFeebGetIrqControl+0x68>
		} else {
			pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
81105b00:	e0bfff17 	ldw	r2,-4(fp)
81105b04:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_IRQ_RIGH_BUFF_EPY_EN_MSK) {
81105b08:	e0bffe17 	ldw	r2,-8(fp)
81105b0c:	1080400c 	andi	r2,r2,256
81105b10:	10000426 	beq	r2,zero,81105b24 <bFeebGetIrqControl+0x84>
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
81105b14:	e0bfff17 	ldw	r2,-4(fp)
81105b18:	00c00044 	movi	r3,1
81105b1c:	10c00315 	stw	r3,12(r2)
81105b20:	00000206 	br	81105b2c <bFeebGetIrqControl+0x8c>
		} else {
			pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
81105b24:	e0bfff17 	ldw	r2,-4(fp)
81105b28:	10000315 	stw	zero,12(r2)
		}

		bStatus = TRUE;
81105b2c:	00800044 	movi	r2,1
81105b30:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105b34:	e0bffd17 	ldw	r2,-12(fp)
}
81105b38:	e037883a 	mov	sp,fp
81105b3c:	dfc00117 	ldw	ra,4(sp)
81105b40:	df000017 	ldw	fp,0(sp)
81105b44:	dec00204 	addi	sp,sp,8
81105b48:	f800283a 	ret

81105b4c <bFeebGetIrqFlags>:

bool bFeebGetIrqFlags(TFeebChannel *pxFeebCh) {
81105b4c:	defffb04 	addi	sp,sp,-20
81105b50:	de00012e 	bgeu	sp,et,81105b58 <bFeebGetIrqFlags+0xc>
81105b54:	003b68fa 	trap	3
81105b58:	dfc00415 	stw	ra,16(sp)
81105b5c:	df000315 	stw	fp,12(sp)
81105b60:	df000304 	addi	fp,sp,12
81105b64:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105b68:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105b6c:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105b70:	e0bfff17 	ldw	r2,-4(fp)
81105b74:	10001126 	beq	r2,zero,81105bbc <bFeebGetIrqFlags+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105b78:	e0bfff17 	ldw	r2,-4(fp)
81105b7c:	10800017 	ldw	r2,0(r2)
81105b80:	01400484 	movi	r5,18
81105b84:	1009883a 	mov	r4,r2
81105b88:	11061200 	call	81106120 <uliFeebReadReg>
81105b8c:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_BUFF_EPY_FLG_MSK) {
81105b90:	e0bffe17 	ldw	r2,-8(fp)
81105b94:	1080400c 	andi	r2,r2,256
81105b98:	10000426 	beq	r2,zero,81105bac <bFeebGetIrqFlags+0x60>
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = TRUE;
81105b9c:	e0bfff17 	ldw	r2,-4(fp)
81105ba0:	00c00044 	movi	r3,1
81105ba4:	10c00415 	stw	r3,16(r2)
81105ba8:	00000206 	br	81105bb4 <bFeebGetIrqFlags+0x68>
		} else {
			pxFeebCh->xIrqFlag.bBufferEmptyFlag = FALSE;
81105bac:	e0bfff17 	ldw	r2,-4(fp)
81105bb0:	10000415 	stw	zero,16(r2)
		}

		bStatus = TRUE;
81105bb4:	00800044 	movi	r2,1
81105bb8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105bbc:	e0bffd17 	ldw	r2,-12(fp)
}
81105bc0:	e037883a 	mov	sp,fp
81105bc4:	dfc00117 	ldw	ra,4(sp)
81105bc8:	df000017 	ldw	fp,0(sp)
81105bcc:	dec00204 	addi	sp,sp,8
81105bd0:	f800283a 	ret

81105bd4 <bFeebGetBuffersStatus>:

bool bFeebGetBuffersStatus(TFeebChannel *pxFeebCh) {
81105bd4:	defffb04 	addi	sp,sp,-20
81105bd8:	de00012e 	bgeu	sp,et,81105be0 <bFeebGetBuffersStatus+0xc>
81105bdc:	003b68fa 	trap	3
81105be0:	dfc00415 	stw	ra,16(sp)
81105be4:	df000315 	stw	fp,12(sp)
81105be8:	df000304 	addi	fp,sp,12
81105bec:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105bf0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105bf4:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105bf8:	e0bfff17 	ldw	r2,-4(fp)
81105bfc:	10001a26 	beq	r2,zero,81105c68 <bFeebGetBuffersStatus+0x94>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105c00:	e0bfff17 	ldw	r2,-4(fp)
81105c04:	10800017 	ldw	r2,0(r2)
81105c08:	014000c4 	movi	r5,3
81105c0c:	1009883a 	mov	r4,r2
81105c10:	11061200 	call	81106120 <uliFeebReadReg>
81105c14:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_STAT_REG_OFST);

		if (uliReg & COMM_WIND_LEFT_BUFF_EMPTY_MSK) {
81105c18:	e0bffe17 	ldw	r2,-8(fp)
81105c1c:	1080008c 	andi	r2,r2,2
81105c20:	10000426 	beq	r2,zero,81105c34 <bFeebGetBuffersStatus+0x60>
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = TRUE;
81105c24:	e0bfff17 	ldw	r2,-4(fp)
81105c28:	00c00044 	movi	r3,1
81105c2c:	10c00515 	stw	r3,20(r2)
81105c30:	00000206 	br	81105c3c <bFeebGetBuffersStatus+0x68>
		} else {
			pxFeebCh->xBufferStatus.bLeftBufferEmpty = FALSE;
81105c34:	e0bfff17 	ldw	r2,-4(fp)
81105c38:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_WIND_RIGH_BUFF_EMPTY_MSK) {
81105c3c:	e0bffe17 	ldw	r2,-8(fp)
81105c40:	1080004c 	andi	r2,r2,1
81105c44:	10000426 	beq	r2,zero,81105c58 <bFeebGetBuffersStatus+0x84>
			pxFeebCh->xBufferStatus.bRightBufferEmpty = TRUE;
81105c48:	e0bfff17 	ldw	r2,-4(fp)
81105c4c:	00c00044 	movi	r3,1
81105c50:	10c00615 	stw	r3,24(r2)
81105c54:	00000206 	br	81105c60 <bFeebGetBuffersStatus+0x8c>
		} else {
			pxFeebCh->xBufferStatus.bRightBufferEmpty = FALSE;
81105c58:	e0bfff17 	ldw	r2,-4(fp)
81105c5c:	10000615 	stw	zero,24(r2)
		}

		bStatus = TRUE;
81105c60:	00800044 	movi	r2,1
81105c64:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105c68:	e0bffd17 	ldw	r2,-12(fp)
}
81105c6c:	e037883a 	mov	sp,fp
81105c70:	dfc00117 	ldw	ra,4(sp)
81105c74:	df000017 	ldw	fp,0(sp)
81105c78:	dec00204 	addi	sp,sp,8
81105c7c:	f800283a 	ret

81105c80 <bFeebSetWindowing>:

bool bFeebSetWindowing(TFeebChannel *pxFeebCh) {
81105c80:	defffb04 	addi	sp,sp,-20
81105c84:	de00012e 	bgeu	sp,et,81105c8c <bFeebSetWindowing+0xc>
81105c88:	003b68fa 	trap	3
81105c8c:	dfc00415 	stw	ra,16(sp)
81105c90:	df000315 	stw	fp,12(sp)
81105c94:	df000304 	addi	fp,sp,12
81105c98:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105c9c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ca0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105ca4:	e0bfff17 	ldw	r2,-4(fp)
81105ca8:	10001926 	beq	r2,zero,81105d10 <bFeebSetWindowing+0x90>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105cac:	e0bfff17 	ldw	r2,-4(fp)
81105cb0:	10800017 	ldw	r2,0(r2)
81105cb4:	01400084 	movi	r5,2
81105cb8:	1009883a 	mov	r4,r2
81105cbc:	11061200 	call	81106120 <uliFeebReadReg>
81105cc0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (pxFeebCh->xWindowingConfig.bMasking) {
81105cc4:	e0bfff17 	ldw	r2,-4(fp)
81105cc8:	10800117 	ldw	r2,4(r2)
81105ccc:	10000426 	beq	r2,zero,81105ce0 <bFeebSetWindowing+0x60>
			uliReg |= COMM_FEE_MASKING_EN_MSK;
81105cd0:	e0bffe17 	ldw	r2,-8(fp)
81105cd4:	10800214 	ori	r2,r2,8
81105cd8:	e0bffe15 	stw	r2,-8(fp)
81105cdc:	00000406 	br	81105cf0 <bFeebSetWindowing+0x70>
		} else {
			uliReg &= (~COMM_FEE_MASKING_EN_MSK);
81105ce0:	e0fffe17 	ldw	r3,-8(fp)
81105ce4:	00bffdc4 	movi	r2,-9
81105ce8:	1884703a 	and	r2,r3,r2
81105cec:	e0bffe15 	stw	r2,-8(fp)
		}

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105cf0:	e0bfff17 	ldw	r2,-4(fp)
81105cf4:	10800017 	ldw	r2,0(r2)
81105cf8:	e1bffe17 	ldw	r6,-8(fp)
81105cfc:	01400084 	movi	r5,2
81105d00:	1009883a 	mov	r4,r2
81105d04:	11060cc0 	call	811060cc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105d08:	00800044 	movi	r2,1
81105d0c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105d10:	e0bffd17 	ldw	r2,-12(fp)
}
81105d14:	e037883a 	mov	sp,fp
81105d18:	dfc00117 	ldw	ra,4(sp)
81105d1c:	df000017 	ldw	fp,0(sp)
81105d20:	dec00204 	addi	sp,sp,8
81105d24:	f800283a 	ret

81105d28 <bFeebGetWindowing>:

bool bFeebGetWindowing(TFeebChannel *pxFeebCh) {
81105d28:	defffb04 	addi	sp,sp,-20
81105d2c:	de00012e 	bgeu	sp,et,81105d34 <bFeebGetWindowing+0xc>
81105d30:	003b68fa 	trap	3
81105d34:	dfc00415 	stw	ra,16(sp)
81105d38:	df000315 	stw	fp,12(sp)
81105d3c:	df000304 	addi	fp,sp,12
81105d40:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105d44:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105d48:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105d4c:	e0bfff17 	ldw	r2,-4(fp)
81105d50:	10001126 	beq	r2,zero,81105d98 <bFeebGetWindowing+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105d54:	e0bfff17 	ldw	r2,-4(fp)
81105d58:	10800017 	ldw	r2,0(r2)
81105d5c:	01400084 	movi	r5,2
81105d60:	1009883a 	mov	r4,r2
81105d64:	11061200 	call	81106120 <uliFeebReadReg>
81105d68:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		if (uliReg & COMM_FEE_MASKING_EN_MSK) {
81105d6c:	e0bffe17 	ldw	r2,-8(fp)
81105d70:	1080020c 	andi	r2,r2,8
81105d74:	10000426 	beq	r2,zero,81105d88 <bFeebGetWindowing+0x60>
			pxFeebCh->xWindowingConfig.bMasking = TRUE;
81105d78:	e0bfff17 	ldw	r2,-4(fp)
81105d7c:	00c00044 	movi	r3,1
81105d80:	10c00115 	stw	r3,4(r2)
81105d84:	00000206 	br	81105d90 <bFeebGetWindowing+0x68>
		} else {
			pxFeebCh->xWindowingConfig.bMasking = FALSE;
81105d88:	e0bfff17 	ldw	r2,-4(fp)
81105d8c:	10000115 	stw	zero,4(r2)
		}

		bStatus = TRUE;
81105d90:	00800044 	movi	r2,1
81105d94:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105d98:	e0bffd17 	ldw	r2,-12(fp)
}
81105d9c:	e037883a 	mov	sp,fp
81105da0:	dfc00117 	ldw	ra,4(sp)
81105da4:	df000017 	ldw	fp,0(sp)
81105da8:	dec00204 	addi	sp,sp,8
81105dac:	f800283a 	ret

81105db0 <bFeebStartCh>:

bool bFeebStartCh(TFeebChannel *pxFeebCh) {
81105db0:	defffb04 	addi	sp,sp,-20
81105db4:	de00012e 	bgeu	sp,et,81105dbc <bFeebStartCh+0xc>
81105db8:	003b68fa 	trap	3
81105dbc:	dfc00415 	stw	ra,16(sp)
81105dc0:	df000315 	stw	fp,12(sp)
81105dc4:	df000304 	addi	fp,sp,12
81105dc8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105dcc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105dd0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105dd4:	e0bfff17 	ldw	r2,-4(fp)
81105dd8:	10001126 	beq	r2,zero,81105e20 <bFeebStartCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105ddc:	e0bfff17 	ldw	r2,-4(fp)
81105de0:	10800017 	ldw	r2,0(r2)
81105de4:	01400084 	movi	r5,2
81105de8:	1009883a 	mov	r4,r2
81105dec:	11061200 	call	81106120 <uliFeebReadReg>
81105df0:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_START_MSK;
81105df4:	e0bffe17 	ldw	r2,-8(fp)
81105df8:	10800114 	ori	r2,r2,4
81105dfc:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105e00:	e0bfff17 	ldw	r2,-4(fp)
81105e04:	10800017 	ldw	r2,0(r2)
81105e08:	e1bffe17 	ldw	r6,-8(fp)
81105e0c:	01400084 	movi	r5,2
81105e10:	1009883a 	mov	r4,r2
81105e14:	11060cc0 	call	811060cc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105e18:	00800044 	movi	r2,1
81105e1c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105e20:	e0bffd17 	ldw	r2,-12(fp)
}
81105e24:	e037883a 	mov	sp,fp
81105e28:	dfc00117 	ldw	ra,4(sp)
81105e2c:	df000017 	ldw	fp,0(sp)
81105e30:	dec00204 	addi	sp,sp,8
81105e34:	f800283a 	ret

81105e38 <bFeebStopCh>:

bool bFeebStopCh(TFeebChannel *pxFeebCh) {
81105e38:	defffb04 	addi	sp,sp,-20
81105e3c:	de00012e 	bgeu	sp,et,81105e44 <bFeebStopCh+0xc>
81105e40:	003b68fa 	trap	3
81105e44:	dfc00415 	stw	ra,16(sp)
81105e48:	df000315 	stw	fp,12(sp)
81105e4c:	df000304 	addi	fp,sp,12
81105e50:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105e54:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105e58:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105e5c:	e0bfff17 	ldw	r2,-4(fp)
81105e60:	10001126 	beq	r2,zero,81105ea8 <bFeebStopCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105e64:	e0bfff17 	ldw	r2,-4(fp)
81105e68:	10800017 	ldw	r2,0(r2)
81105e6c:	01400084 	movi	r5,2
81105e70:	1009883a 	mov	r4,r2
81105e74:	11061200 	call	81106120 <uliFeebReadReg>
81105e78:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_STOP_MSK;
81105e7c:	e0bffe17 	ldw	r2,-8(fp)
81105e80:	10800094 	ori	r2,r2,2
81105e84:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105e88:	e0bfff17 	ldw	r2,-4(fp)
81105e8c:	10800017 	ldw	r2,0(r2)
81105e90:	e1bffe17 	ldw	r6,-8(fp)
81105e94:	01400084 	movi	r5,2
81105e98:	1009883a 	mov	r4,r2
81105e9c:	11060cc0 	call	811060cc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105ea0:	00800044 	movi	r2,1
81105ea4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105ea8:	e0bffd17 	ldw	r2,-12(fp)
}
81105eac:	e037883a 	mov	sp,fp
81105eb0:	dfc00117 	ldw	ra,4(sp)
81105eb4:	df000017 	ldw	fp,0(sp)
81105eb8:	dec00204 	addi	sp,sp,8
81105ebc:	f800283a 	ret

81105ec0 <bFeebClrCh>:

bool bFeebClrCh(TFeebChannel *pxFeebCh) {
81105ec0:	defffb04 	addi	sp,sp,-20
81105ec4:	de00012e 	bgeu	sp,et,81105ecc <bFeebClrCh+0xc>
81105ec8:	003b68fa 	trap	3
81105ecc:	dfc00415 	stw	ra,16(sp)
81105ed0:	df000315 	stw	fp,12(sp)
81105ed4:	df000304 	addi	fp,sp,12
81105ed8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81105edc:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81105ee0:	e03ffe15 	stw	zero,-8(fp)

	if (pxFeebCh != NULL) {
81105ee4:	e0bfff17 	ldw	r2,-4(fp)
81105ee8:	10001126 	beq	r2,zero,81105f30 <bFeebClrCh+0x70>
		uliReg = uliFeebReadReg(pxFeebCh->puliFeebChAddr,
81105eec:	e0bfff17 	ldw	r2,-4(fp)
81105ef0:	10800017 	ldw	r2,0(r2)
81105ef4:	01400084 	movi	r5,2
81105ef8:	1009883a 	mov	r4,r2
81105efc:	11061200 	call	81106120 <uliFeebReadReg>
81105f00:	e0bffe15 	stw	r2,-8(fp)
		COMM_FEE_BUFF_CFG_REG_OFST);

		uliReg |= COMM_FEE_MACHINE_CLR_MSK;
81105f04:	e0bffe17 	ldw	r2,-8(fp)
81105f08:	10800054 	ori	r2,r2,1
81105f0c:	e0bffe15 	stw	r2,-8(fp)

		vFeebWriteReg(pxFeebCh->puliFeebChAddr, COMM_FEE_BUFF_CFG_REG_OFST,
81105f10:	e0bfff17 	ldw	r2,-4(fp)
81105f14:	10800017 	ldw	r2,0(r2)
81105f18:	e1bffe17 	ldw	r6,-8(fp)
81105f1c:	01400084 	movi	r5,2
81105f20:	1009883a 	mov	r4,r2
81105f24:	11060cc0 	call	811060cc <vFeebWriteReg>
				uliReg);

		bStatus = TRUE;
81105f28:	00800044 	movi	r2,1
81105f2c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81105f30:	e0bffd17 	ldw	r2,-12(fp)
}
81105f34:	e037883a 	mov	sp,fp
81105f38:	dfc00117 	ldw	ra,4(sp)
81105f3c:	df000017 	ldw	fp,0(sp)
81105f40:	dec00204 	addi	sp,sp,8
81105f44:	f800283a 	ret

81105f48 <bFeebInitCh>:

bool bFeebInitCh(TFeebChannel *pxFeebCh, alt_u8 ucCommCh) {
81105f48:	defffb04 	addi	sp,sp,-20
81105f4c:	de00012e 	bgeu	sp,et,81105f54 <bFeebInitCh+0xc>
81105f50:	003b68fa 	trap	3
81105f54:	dfc00415 	stw	ra,16(sp)
81105f58:	df000315 	stw	fp,12(sp)
81105f5c:	df000304 	addi	fp,sp,12
81105f60:	e13ffe15 	stw	r4,-8(fp)
81105f64:	2805883a 	mov	r2,r5
81105f68:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81105f6c:	e03ffd15 	stw	zero,-12(fp)

	if (pxFeebCh != NULL) {
81105f70:	e0bffe17 	ldw	r2,-8(fp)
81105f74:	10004f26 	beq	r2,zero,811060b4 <bFeebInitCh+0x16c>
		bStatus = TRUE;
81105f78:	00800044 	movi	r2,1
81105f7c:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81105f80:	e0bfff03 	ldbu	r2,-4(fp)
81105f84:	10c00228 	cmpgeui	r3,r2,8
81105f88:	1800361e 	bne	r3,zero,81106064 <bFeebInitCh+0x11c>
81105f8c:	100690ba 	slli	r3,r2,2
81105f90:	00a04434 	movhi	r2,33040
81105f94:	1097e904 	addi	r2,r2,24484
81105f98:	1885883a 	add	r2,r3,r2
81105f9c:	10800017 	ldw	r2,0(r2)
81105fa0:	1000683a 	jmp	r2
81105fa4:	81105fc4 	addi	r4,r16,16767
81105fa8:	81105fd8 	cmpnei	r4,r16,16767
81105fac:	81105fec 	andhi	r4,r16,16767
81105fb0:	81106000 	call	88110600 <__reset+0x20f0600>
81105fb4:	81106014 	ori	r4,r16,16768
81105fb8:	81106028 	cmpgeui	r4,r16,16768
81105fbc:	8110603c 	xorhi	r4,r16,16768
81105fc0:	81106050 	cmplti	r4,r16,16769
		case eCommSpwCh1:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81105fc4:	e0fffe17 	ldw	r3,-8(fp)
81105fc8:	00a04834 	movhi	r2,33056
81105fcc:	108b0004 	addi	r2,r2,11264
81105fd0:	18800015 	stw	r2,0(r3)
			break;
81105fd4:	00002506 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh2:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81105fd8:	e0fffe17 	ldw	r3,-8(fp)
81105fdc:	00a04834 	movhi	r2,33056
81105fe0:	108a0004 	addi	r2,r2,10240
81105fe4:	18800015 	stw	r2,0(r3)
			break;
81105fe8:	00002006 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh3:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81105fec:	e0fffe17 	ldw	r3,-8(fp)
81105ff0:	00a04834 	movhi	r2,33056
81105ff4:	10890004 	addi	r2,r2,9216
81105ff8:	18800015 	stw	r2,0(r3)
			break;
81105ffc:	00001b06 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh4:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81106000:	e0fffe17 	ldw	r3,-8(fp)
81106004:	00a04834 	movhi	r2,33056
81106008:	10880004 	addi	r2,r2,8192
8110600c:	18800015 	stw	r2,0(r3)
			break;
81106010:	00001606 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh5:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81106014:	e0fffe17 	ldw	r3,-8(fp)
81106018:	00a04834 	movhi	r2,33056
8110601c:	10870004 	addi	r2,r2,7168
81106020:	18800015 	stw	r2,0(r3)
			break;
81106024:	00001106 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh6:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81106028:	e0fffe17 	ldw	r3,-8(fp)
8110602c:	00a04834 	movhi	r2,33056
81106030:	10860004 	addi	r2,r2,6144
81106034:	18800015 	stw	r2,0(r3)
			break;
81106038:	00000c06 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh7:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
8110603c:	e0fffe17 	ldw	r3,-8(fp)
81106040:	00a04834 	movhi	r2,33056
81106044:	10850004 	addi	r2,r2,5120
81106048:	18800015 	stw	r2,0(r3)
			break;
8110604c:	00000706 	br	8110606c <bFeebInitCh+0x124>
		case eCommSpwCh8:
			pxFeebCh->puliFeebChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81106050:	e0fffe17 	ldw	r3,-8(fp)
81106054:	00a04834 	movhi	r2,33056
81106058:	10840004 	addi	r2,r2,4096
8110605c:	18800015 	stw	r2,0(r3)
			break;
81106060:	00000206 	br	8110606c <bFeebInitCh+0x124>
		default:
			bStatus = FALSE;
81106064:	e03ffd15 	stw	zero,-12(fp)
			break;
81106068:	0001883a 	nop
		}

		if (bStatus) {
8110606c:	e0bffd17 	ldw	r2,-12(fp)
81106070:	10001026 	beq	r2,zero,811060b4 <bFeebInitCh+0x16c>
			if (!bFeebGetIrqControl(pxFeebCh)) {
81106074:	e13ffe17 	ldw	r4,-8(fp)
81106078:	1105aa00 	call	81105aa0 <bFeebGetIrqControl>
8110607c:	1000011e 	bne	r2,zero,81106084 <bFeebInitCh+0x13c>
				bStatus = FALSE;
81106080:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetIrqFlags(pxFeebCh)) {
81106084:	e13ffe17 	ldw	r4,-8(fp)
81106088:	1105b4c0 	call	81105b4c <bFeebGetIrqFlags>
8110608c:	1000011e 	bne	r2,zero,81106094 <bFeebInitCh+0x14c>
				bStatus = FALSE;
81106090:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetBuffersStatus(pxFeebCh)) {
81106094:	e13ffe17 	ldw	r4,-8(fp)
81106098:	1105bd40 	call	81105bd4 <bFeebGetBuffersStatus>
8110609c:	1000011e 	bne	r2,zero,811060a4 <bFeebInitCh+0x15c>
				bStatus = FALSE;
811060a0:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bFeebGetWindowing(pxFeebCh)) {
811060a4:	e13ffe17 	ldw	r4,-8(fp)
811060a8:	1105d280 	call	81105d28 <bFeebGetWindowing>
811060ac:	1000011e 	bne	r2,zero,811060b4 <bFeebInitCh+0x16c>
				bStatus = FALSE;
811060b0:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
811060b4:	e0bffd17 	ldw	r2,-12(fp)
}
811060b8:	e037883a 	mov	sp,fp
811060bc:	dfc00117 	ldw	ra,4(sp)
811060c0:	df000017 	ldw	fp,0(sp)
811060c4:	dec00204 	addi	sp,sp,8
811060c8:	f800283a 	ret

811060cc <vFeebWriteReg>:

//! [public functions]

//! [private functions]
static void vFeebWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
811060cc:	defffc04 	addi	sp,sp,-16
811060d0:	de00012e 	bgeu	sp,et,811060d8 <vFeebWriteReg+0xc>
811060d4:	003b68fa 	trap	3
811060d8:	df000315 	stw	fp,12(sp)
811060dc:	df000304 	addi	fp,sp,12
811060e0:	e13ffd15 	stw	r4,-12(fp)
811060e4:	e17ffe15 	stw	r5,-8(fp)
811060e8:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
811060ec:	e0bffe17 	ldw	r2,-8(fp)
811060f0:	1085883a 	add	r2,r2,r2
811060f4:	1085883a 	add	r2,r2,r2
811060f8:	1007883a 	mov	r3,r2
811060fc:	e0bffd17 	ldw	r2,-12(fp)
81106100:	10c5883a 	add	r2,r2,r3
81106104:	e0ffff17 	ldw	r3,-4(fp)
81106108:	10c00015 	stw	r3,0(r2)
}
8110610c:	0001883a 	nop
81106110:	e037883a 	mov	sp,fp
81106114:	df000017 	ldw	fp,0(sp)
81106118:	dec00104 	addi	sp,sp,4
8110611c:	f800283a 	ret

81106120 <uliFeebReadReg>:

static alt_u32 uliFeebReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81106120:	defffc04 	addi	sp,sp,-16
81106124:	de00012e 	bgeu	sp,et,8110612c <uliFeebReadReg+0xc>
81106128:	003b68fa 	trap	3
8110612c:	df000315 	stw	fp,12(sp)
81106130:	df000304 	addi	fp,sp,12
81106134:	e13ffe15 	stw	r4,-8(fp)
81106138:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110613c:	e0bfff17 	ldw	r2,-4(fp)
81106140:	1085883a 	add	r2,r2,r2
81106144:	1085883a 	add	r2,r2,r2
81106148:	1007883a 	mov	r3,r2
8110614c:	e0bffe17 	ldw	r2,-8(fp)
81106150:	10c5883a 	add	r2,r2,r3
81106154:	10800017 	ldw	r2,0(r2)
81106158:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110615c:	e0bffd17 	ldw	r2,-12(fp)
}
81106160:	e037883a 	mov	sp,fp
81106164:	df000017 	ldw	fp,0(sp)
81106168:	dec00104 	addi	sp,sp,4
8110616c:	f800283a 	ret

81106170 <vRmapCh1HandleIrq>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRmapCh1HandleIrq(void* pvContext) {
81106170:	defffa04 	addi	sp,sp,-24
81106174:	de00012e 	bgeu	sp,et,8110617c <vRmapCh1HandleIrq+0xc>
81106178:	003b68fa 	trap	3
8110617c:	dfc00515 	stw	ra,20(sp)
81106180:	df000415 	stw	fp,16(sp)
81106184:	df000404 	addi	fp,sp,16
81106188:	e13fff15 	stw	r4,-4(fp)
	volatile int* pviHoldContext = (volatile int*) pvContext;
8110618c:	e0bfff17 	ldw	r2,-4(fp)
81106190:	e0bffc15 	stw	r2,-16(fp)
	tQMask uiCmdRmap;
	INT8U ucADDRReg;
	INT8U error_codel;

	/* Warnning simplification: For now all address is lower than 1 bytes  */
	ucADDRReg = (unsigned char)uliRmapCh1WriteCmdAddress();
81106194:	110689c0 	call	8110689c <uliRmapCh1WriteCmdAddress>
81106198:	e0bffd05 	stb	r2,-12(fp)


	uiCmdRmap.ucByte[3] = M_NFEE_BASE_ADDR + 0;
8110619c:	00800444 	movi	r2,17
811061a0:	e0bffec5 	stb	r2,-5(fp)
	uiCmdRmap.ucByte[2] = M_FEE_RMAP;
811061a4:	00bffc04 	movi	r2,-16
811061a8:	e0bffe85 	stb	r2,-6(fp)
	uiCmdRmap.ucByte[1] = ucADDRReg;
811061ac:	e0bffd03 	ldbu	r2,-12(fp)
811061b0:	e0bffe45 	stb	r2,-7(fp)
	uiCmdRmap.ucByte[0] = 0;
811061b4:	e03ffe05 	stb	zero,-8(fp)


	error_codel = OSQPost(xFeeQ[0], (void *)uiCmdRmap.ulWord);
811061b8:	d0a06617 	ldw	r2,-32360(gp)
811061bc:	e0fffe17 	ldw	r3,-8(fp)
811061c0:	180b883a 	mov	r5,r3
811061c4:	1009883a 	mov	r4,r2
811061c8:	113a0040 	call	8113a004 <OSQPost>
811061cc:	e0bffd45 	stb	r2,-11(fp)
	if ( error_codel != OS_ERR_NONE ) {
811061d0:	e0bffd43 	ldbu	r2,-11(fp)
811061d4:	10000226 	beq	r2,zero,811061e0 <vRmapCh1HandleIrq+0x70>
		vFailSendRMAPFromIRQ( 0 );
811061d8:	0009883a 	mov	r4,zero
811061dc:	111964c0 	call	8111964c <vFailSendRMAPFromIRQ>
	}

	vRmapCh1IrqFlagClrWriteCmd();
811061e0:	11063bc0 	call	811063bc <vRmapCh1IrqFlagClrWriteCmd>
}
811061e4:	0001883a 	nop
811061e8:	e037883a 	mov	sp,fp
811061ec:	dfc00117 	ldw	ra,4(sp)
811061f0:	df000017 	ldw	fp,0(sp)
811061f4:	dec00204 	addi	sp,sp,8
811061f8:	f800283a 	ret

811061fc <vRmapCh2HandleIrq>:

void vRmapCh2HandleIrq(void* pvContext) {
811061fc:	defffc04 	addi	sp,sp,-16
81106200:	de00012e 	bgeu	sp,et,81106208 <vRmapCh2HandleIrq+0xc>
81106204:	003b68fa 	trap	3
81106208:	dfc00315 	stw	ra,12(sp)
8110620c:	df000215 	stw	fp,8(sp)
81106210:	df000204 	addi	fp,sp,8
81106214:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106218:	e0bfff17 	ldw	r2,-4(fp)
8110621c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh2IrqFlagClrWriteCmd();
81106220:	11064000 	call	81106400 <vRmapCh2IrqFlagClrWriteCmd>
}
81106224:	0001883a 	nop
81106228:	e037883a 	mov	sp,fp
8110622c:	dfc00117 	ldw	ra,4(sp)
81106230:	df000017 	ldw	fp,0(sp)
81106234:	dec00204 	addi	sp,sp,8
81106238:	f800283a 	ret

8110623c <vRmapCh3HandleIrq>:

void vRmapCh3HandleIrq(void* pvContext) {
8110623c:	defffc04 	addi	sp,sp,-16
81106240:	de00012e 	bgeu	sp,et,81106248 <vRmapCh3HandleIrq+0xc>
81106244:	003b68fa 	trap	3
81106248:	dfc00315 	stw	ra,12(sp)
8110624c:	df000215 	stw	fp,8(sp)
81106250:	df000204 	addi	fp,sp,8
81106254:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106258:	e0bfff17 	ldw	r2,-4(fp)
8110625c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh3IrqFlagClrWriteCmd();
81106260:	11064440 	call	81106444 <vRmapCh3IrqFlagClrWriteCmd>
}
81106264:	0001883a 	nop
81106268:	e037883a 	mov	sp,fp
8110626c:	dfc00117 	ldw	ra,4(sp)
81106270:	df000017 	ldw	fp,0(sp)
81106274:	dec00204 	addi	sp,sp,8
81106278:	f800283a 	ret

8110627c <vRmapCh4HandleIrq>:

void vRmapCh4HandleIrq(void* pvContext) {
8110627c:	defffc04 	addi	sp,sp,-16
81106280:	de00012e 	bgeu	sp,et,81106288 <vRmapCh4HandleIrq+0xc>
81106284:	003b68fa 	trap	3
81106288:	dfc00315 	stw	ra,12(sp)
8110628c:	df000215 	stw	fp,8(sp)
81106290:	df000204 	addi	fp,sp,8
81106294:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106298:	e0bfff17 	ldw	r2,-4(fp)
8110629c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh4IrqFlagClrWriteCmd();
811062a0:	11064880 	call	81106488 <vRmapCh4IrqFlagClrWriteCmd>
}
811062a4:	0001883a 	nop
811062a8:	e037883a 	mov	sp,fp
811062ac:	dfc00117 	ldw	ra,4(sp)
811062b0:	df000017 	ldw	fp,0(sp)
811062b4:	dec00204 	addi	sp,sp,8
811062b8:	f800283a 	ret

811062bc <vRmapCh5HandleIrq>:

void vRmapCh5HandleIrq(void* pvContext) {
811062bc:	defffc04 	addi	sp,sp,-16
811062c0:	de00012e 	bgeu	sp,et,811062c8 <vRmapCh5HandleIrq+0xc>
811062c4:	003b68fa 	trap	3
811062c8:	dfc00315 	stw	ra,12(sp)
811062cc:	df000215 	stw	fp,8(sp)
811062d0:	df000204 	addi	fp,sp,8
811062d4:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
811062d8:	e0bfff17 	ldw	r2,-4(fp)
811062dc:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh5IrqFlagClrWriteCmd();
811062e0:	11064cc0 	call	811064cc <vRmapCh5IrqFlagClrWriteCmd>
}
811062e4:	0001883a 	nop
811062e8:	e037883a 	mov	sp,fp
811062ec:	dfc00117 	ldw	ra,4(sp)
811062f0:	df000017 	ldw	fp,0(sp)
811062f4:	dec00204 	addi	sp,sp,8
811062f8:	f800283a 	ret

811062fc <vRmapCh6HandleIrq>:

void vRmapCh6HandleIrq(void* pvContext) {
811062fc:	defffc04 	addi	sp,sp,-16
81106300:	de00012e 	bgeu	sp,et,81106308 <vRmapCh6HandleIrq+0xc>
81106304:	003b68fa 	trap	3
81106308:	dfc00315 	stw	ra,12(sp)
8110630c:	df000215 	stw	fp,8(sp)
81106310:	df000204 	addi	fp,sp,8
81106314:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106318:	e0bfff17 	ldw	r2,-4(fp)
8110631c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*hold_context_ptr = ...;
	// if (*hold_context_ptr == '0') {}...
	// App logic sequence...
	vRmapCh6IrqFlagClrWriteCmd();
81106320:	11065100 	call	81106510 <vRmapCh6IrqFlagClrWriteCmd>
}
81106324:	0001883a 	nop
81106328:	e037883a 	mov	sp,fp
8110632c:	dfc00117 	ldw	ra,4(sp)
81106330:	df000017 	ldw	fp,0(sp)
81106334:	dec00204 	addi	sp,sp,8
81106338:	f800283a 	ret

8110633c <vRmapCh7HandleIrq>:

void vRmapCh7HandleIrq(void* pvContext) {
8110633c:	defffc04 	addi	sp,sp,-16
81106340:	de00012e 	bgeu	sp,et,81106348 <vRmapCh7HandleIrq+0xc>
81106344:	003b68fa 	trap	3
81106348:	dfc00315 	stw	ra,12(sp)
8110634c:	df000215 	stw	fp,8(sp)
81106350:	df000204 	addi	fp,sp,8
81106354:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106358:	e0bfff17 	ldw	r2,-4(fp)
8110635c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh7IrqFlagClrWriteCmd();
81106360:	11065540 	call	81106554 <vRmapCh7IrqFlagClrWriteCmd>
}
81106364:	0001883a 	nop
81106368:	e037883a 	mov	sp,fp
8110636c:	dfc00117 	ldw	ra,4(sp)
81106370:	df000017 	ldw	fp,0(sp)
81106374:	dec00204 	addi	sp,sp,8
81106378:	f800283a 	ret

8110637c <vRmapCh8HandleIrq>:

void vRmapCh8HandleIrq(void* pvContext) {
8110637c:	defffc04 	addi	sp,sp,-16
81106380:	de00012e 	bgeu	sp,et,81106388 <vRmapCh8HandleIrq+0xc>
81106384:	003b68fa 	trap	3
81106388:	dfc00315 	stw	ra,12(sp)
8110638c:	df000215 	stw	fp,8(sp)
81106390:	df000204 	addi	fp,sp,8
81106394:	e13fff15 	stw	r4,-4(fp)
	// Cast context to hold_context's type. It is important that this be
	// declared volatile to avoid unwanted compiler optimization.
	volatile int* pviHoldContext = (volatile int*) pvContext;
81106398:	e0bfff17 	ldw	r2,-4(fp)
8110639c:	e0bffe15 	stw	r2,-8(fp)
	// Use context value according to your app logic...
	//*pviHoldContext = ...;
	// if (*pviHoldContext == '0') {}...
	// App logic sequence...
	vRmapCh8IrqFlagClrWriteCmd();
811063a0:	11065980 	call	81106598 <vRmapCh8IrqFlagClrWriteCmd>
}
811063a4:	0001883a 	nop
811063a8:	e037883a 	mov	sp,fp
811063ac:	dfc00117 	ldw	ra,4(sp)
811063b0:	df000017 	ldw	fp,0(sp)
811063b4:	dec00204 	addi	sp,sp,8
811063b8:	f800283a 	ret

811063bc <vRmapCh1IrqFlagClrWriteCmd>:

void vRmapCh1IrqFlagClrWriteCmd(void) {
811063bc:	defffe04 	addi	sp,sp,-8
811063c0:	de00012e 	bgeu	sp,et,811063c8 <vRmapCh1IrqFlagClrWriteCmd+0xc>
811063c4:	003b68fa 	trap	3
811063c8:	dfc00115 	stw	ra,4(sp)
811063cc:	df000015 	stw	fp,0(sp)
811063d0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811063d4:	01800044 	movi	r6,1
811063d8:	014004c4 	movi	r5,19
811063dc:	01204834 	movhi	r4,33056
811063e0:	210b0004 	addi	r4,r4,11264
811063e4:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811063e8:	0001883a 	nop
811063ec:	e037883a 	mov	sp,fp
811063f0:	dfc00117 	ldw	ra,4(sp)
811063f4:	df000017 	ldw	fp,0(sp)
811063f8:	dec00204 	addi	sp,sp,8
811063fc:	f800283a 	ret

81106400 <vRmapCh2IrqFlagClrWriteCmd>:

void vRmapCh2IrqFlagClrWriteCmd(void) {
81106400:	defffe04 	addi	sp,sp,-8
81106404:	de00012e 	bgeu	sp,et,8110640c <vRmapCh2IrqFlagClrWriteCmd+0xc>
81106408:	003b68fa 	trap	3
8110640c:	dfc00115 	stw	ra,4(sp)
81106410:	df000015 	stw	fp,0(sp)
81106414:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106418:	01800044 	movi	r6,1
8110641c:	014004c4 	movi	r5,19
81106420:	01204834 	movhi	r4,33056
81106424:	210a0004 	addi	r4,r4,10240
81106428:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110642c:	0001883a 	nop
81106430:	e037883a 	mov	sp,fp
81106434:	dfc00117 	ldw	ra,4(sp)
81106438:	df000017 	ldw	fp,0(sp)
8110643c:	dec00204 	addi	sp,sp,8
81106440:	f800283a 	ret

81106444 <vRmapCh3IrqFlagClrWriteCmd>:

void vRmapCh3IrqFlagClrWriteCmd(void) {
81106444:	defffe04 	addi	sp,sp,-8
81106448:	de00012e 	bgeu	sp,et,81106450 <vRmapCh3IrqFlagClrWriteCmd+0xc>
8110644c:	003b68fa 	trap	3
81106450:	dfc00115 	stw	ra,4(sp)
81106454:	df000015 	stw	fp,0(sp)
81106458:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
8110645c:	01800044 	movi	r6,1
81106460:	014004c4 	movi	r5,19
81106464:	01204834 	movhi	r4,33056
81106468:	21090004 	addi	r4,r4,9216
8110646c:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106470:	0001883a 	nop
81106474:	e037883a 	mov	sp,fp
81106478:	dfc00117 	ldw	ra,4(sp)
8110647c:	df000017 	ldw	fp,0(sp)
81106480:	dec00204 	addi	sp,sp,8
81106484:	f800283a 	ret

81106488 <vRmapCh4IrqFlagClrWriteCmd>:

void vRmapCh4IrqFlagClrWriteCmd(void) {
81106488:	defffe04 	addi	sp,sp,-8
8110648c:	de00012e 	bgeu	sp,et,81106494 <vRmapCh4IrqFlagClrWriteCmd+0xc>
81106490:	003b68fa 	trap	3
81106494:	dfc00115 	stw	ra,4(sp)
81106498:	df000015 	stw	fp,0(sp)
8110649c:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811064a0:	01800044 	movi	r6,1
811064a4:	014004c4 	movi	r5,19
811064a8:	01204834 	movhi	r4,33056
811064ac:	21080004 	addi	r4,r4,8192
811064b0:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811064b4:	0001883a 	nop
811064b8:	e037883a 	mov	sp,fp
811064bc:	dfc00117 	ldw	ra,4(sp)
811064c0:	df000017 	ldw	fp,0(sp)
811064c4:	dec00204 	addi	sp,sp,8
811064c8:	f800283a 	ret

811064cc <vRmapCh5IrqFlagClrWriteCmd>:

void vRmapCh5IrqFlagClrWriteCmd(void) {
811064cc:	defffe04 	addi	sp,sp,-8
811064d0:	de00012e 	bgeu	sp,et,811064d8 <vRmapCh5IrqFlagClrWriteCmd+0xc>
811064d4:	003b68fa 	trap	3
811064d8:	dfc00115 	stw	ra,4(sp)
811064dc:	df000015 	stw	fp,0(sp)
811064e0:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
811064e4:	01800044 	movi	r6,1
811064e8:	014004c4 	movi	r5,19
811064ec:	01204834 	movhi	r4,33056
811064f0:	21070004 	addi	r4,r4,7168
811064f4:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811064f8:	0001883a 	nop
811064fc:	e037883a 	mov	sp,fp
81106500:	dfc00117 	ldw	ra,4(sp)
81106504:	df000017 	ldw	fp,0(sp)
81106508:	dec00204 	addi	sp,sp,8
8110650c:	f800283a 	ret

81106510 <vRmapCh6IrqFlagClrWriteCmd>:

void vRmapCh6IrqFlagClrWriteCmd(void) {
81106510:	defffe04 	addi	sp,sp,-8
81106514:	de00012e 	bgeu	sp,et,8110651c <vRmapCh6IrqFlagClrWriteCmd+0xc>
81106518:	003b68fa 	trap	3
8110651c:	dfc00115 	stw	ra,4(sp)
81106520:	df000015 	stw	fp,0(sp)
81106524:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
81106528:	01800044 	movi	r6,1
8110652c:	014004c4 	movi	r5,19
81106530:	01204834 	movhi	r4,33056
81106534:	21060004 	addi	r4,r4,6144
81106538:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
8110653c:	0001883a 	nop
81106540:	e037883a 	mov	sp,fp
81106544:	dfc00117 	ldw	ra,4(sp)
81106548:	df000017 	ldw	fp,0(sp)
8110654c:	dec00204 	addi	sp,sp,8
81106550:	f800283a 	ret

81106554 <vRmapCh7IrqFlagClrWriteCmd>:

void vRmapCh7IrqFlagClrWriteCmd(void) {
81106554:	defffe04 	addi	sp,sp,-8
81106558:	de00012e 	bgeu	sp,et,81106560 <vRmapCh7IrqFlagClrWriteCmd+0xc>
8110655c:	003b68fa 	trap	3
81106560:	dfc00115 	stw	ra,4(sp)
81106564:	df000015 	stw	fp,0(sp)
81106568:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
8110656c:	01800044 	movi	r6,1
81106570:	014004c4 	movi	r5,19
81106574:	01204834 	movhi	r4,33056
81106578:	21050004 	addi	r4,r4,5120
8110657c:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
81106580:	0001883a 	nop
81106584:	e037883a 	mov	sp,fp
81106588:	dfc00117 	ldw	ra,4(sp)
8110658c:	df000017 	ldw	fp,0(sp)
81106590:	dec00204 	addi	sp,sp,8
81106594:	f800283a 	ret

81106598 <vRmapCh8IrqFlagClrWriteCmd>:

void vRmapCh8IrqFlagClrWriteCmd(void) {
81106598:	defffe04 	addi	sp,sp,-8
8110659c:	de00012e 	bgeu	sp,et,811065a4 <vRmapCh8IrqFlagClrWriteCmd+0xc>
811065a0:	003b68fa 	trap	3
811065a4:	dfc00115 	stw	ra,4(sp)
811065a8:	df000015 	stw	fp,0(sp)
811065ac:	d839883a 	mov	fp,sp
	vRmapWriteReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
811065b0:	01800044 	movi	r6,1
811065b4:	014004c4 	movi	r5,19
811065b8:	01204834 	movhi	r4,33056
811065bc:	21040004 	addi	r4,r4,4096
811065c0:	1108e840 	call	81108e84 <vRmapWriteReg>
	COMM_IRQ_FLAGS_CLR_REG_OFST, (alt_u32) COMM_IRQ_RMAP_WRCMD_FLG_CLR_MSK);
}
811065c4:	0001883a 	nop
811065c8:	e037883a 	mov	sp,fp
811065cc:	dfc00117 	ldw	ra,4(sp)
811065d0:	df000017 	ldw	fp,0(sp)
811065d4:	dec00204 	addi	sp,sp,8
811065d8:	f800283a 	ret

811065dc <bRmapCh1IrqFlagWriteCmd>:

bool bRmapCh1IrqFlagWriteCmd(void) {
811065dc:	defffd04 	addi	sp,sp,-12
811065e0:	de00012e 	bgeu	sp,et,811065e8 <bRmapCh1IrqFlagWriteCmd+0xc>
811065e4:	003b68fa 	trap	3
811065e8:	dfc00215 	stw	ra,8(sp)
811065ec:	df000115 	stw	fp,4(sp)
811065f0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
811065f4:	01400484 	movi	r5,18
811065f8:	01204834 	movhi	r4,33056
811065fc:	210b0004 	addi	r4,r4,11264
81106600:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106604:	1080004c 	andi	r2,r2,1
}

bool bRmapCh1IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_1_BASE_ADDR,
81106608:	10000326 	beq	r2,zero,81106618 <bRmapCh1IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110660c:	00800044 	movi	r2,1
81106610:	e0bfff15 	stw	r2,-4(fp)
81106614:	00000106 	br	8110661c <bRmapCh1IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106618:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110661c:	e0bfff17 	ldw	r2,-4(fp)
}
81106620:	e037883a 	mov	sp,fp
81106624:	dfc00117 	ldw	ra,4(sp)
81106628:	df000017 	ldw	fp,0(sp)
8110662c:	dec00204 	addi	sp,sp,8
81106630:	f800283a 	ret

81106634 <bRmapCh2IrqFlagWriteCmd>:

bool bRmapCh2IrqFlagWriteCmd(void) {
81106634:	defffd04 	addi	sp,sp,-12
81106638:	de00012e 	bgeu	sp,et,81106640 <bRmapCh2IrqFlagWriteCmd+0xc>
8110663c:	003b68fa 	trap	3
81106640:	dfc00215 	stw	ra,8(sp)
81106644:	df000115 	stw	fp,4(sp)
81106648:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
8110664c:	01400484 	movi	r5,18
81106650:	01204834 	movhi	r4,33056
81106654:	210a0004 	addi	r4,r4,10240
81106658:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110665c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh2IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_2_BASE_ADDR,
81106660:	10000326 	beq	r2,zero,81106670 <bRmapCh2IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106664:	00800044 	movi	r2,1
81106668:	e0bfff15 	stw	r2,-4(fp)
8110666c:	00000106 	br	81106674 <bRmapCh2IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106670:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106674:	e0bfff17 	ldw	r2,-4(fp)
}
81106678:	e037883a 	mov	sp,fp
8110667c:	dfc00117 	ldw	ra,4(sp)
81106680:	df000017 	ldw	fp,0(sp)
81106684:	dec00204 	addi	sp,sp,8
81106688:	f800283a 	ret

8110668c <bRmapCh3IrqFlagWriteCmd>:

bool bRmapCh3IrqFlagWriteCmd(void) {
8110668c:	defffd04 	addi	sp,sp,-12
81106690:	de00012e 	bgeu	sp,et,81106698 <bRmapCh3IrqFlagWriteCmd+0xc>
81106694:	003b68fa 	trap	3
81106698:	dfc00215 	stw	ra,8(sp)
8110669c:	df000115 	stw	fp,4(sp)
811066a0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811066a4:	01400484 	movi	r5,18
811066a8:	01204834 	movhi	r4,33056
811066ac:	21090004 	addi	r4,r4,9216
811066b0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811066b4:	1080004c 	andi	r2,r2,1
}

bool bRmapCh3IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_3_BASE_ADDR,
811066b8:	10000326 	beq	r2,zero,811066c8 <bRmapCh3IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811066bc:	00800044 	movi	r2,1
811066c0:	e0bfff15 	stw	r2,-4(fp)
811066c4:	00000106 	br	811066cc <bRmapCh3IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811066c8:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811066cc:	e0bfff17 	ldw	r2,-4(fp)
}
811066d0:	e037883a 	mov	sp,fp
811066d4:	dfc00117 	ldw	ra,4(sp)
811066d8:	df000017 	ldw	fp,0(sp)
811066dc:	dec00204 	addi	sp,sp,8
811066e0:	f800283a 	ret

811066e4 <bRmapCh4IrqFlagWriteCmd>:

bool bRmapCh4IrqFlagWriteCmd(void) {
811066e4:	defffd04 	addi	sp,sp,-12
811066e8:	de00012e 	bgeu	sp,et,811066f0 <bRmapCh4IrqFlagWriteCmd+0xc>
811066ec:	003b68fa 	trap	3
811066f0:	dfc00215 	stw	ra,8(sp)
811066f4:	df000115 	stw	fp,4(sp)
811066f8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
811066fc:	01400484 	movi	r5,18
81106700:	01204834 	movhi	r4,33056
81106704:	21080004 	addi	r4,r4,8192
81106708:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110670c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh4IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_4_BASE_ADDR,
81106710:	10000326 	beq	r2,zero,81106720 <bRmapCh4IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106714:	00800044 	movi	r2,1
81106718:	e0bfff15 	stw	r2,-4(fp)
8110671c:	00000106 	br	81106724 <bRmapCh4IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106720:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106724:	e0bfff17 	ldw	r2,-4(fp)
}
81106728:	e037883a 	mov	sp,fp
8110672c:	dfc00117 	ldw	ra,4(sp)
81106730:	df000017 	ldw	fp,0(sp)
81106734:	dec00204 	addi	sp,sp,8
81106738:	f800283a 	ret

8110673c <bRmapCh5IrqFlagWriteCmd>:

bool bRmapCh5IrqFlagWriteCmd(void) {
8110673c:	defffd04 	addi	sp,sp,-12
81106740:	de00012e 	bgeu	sp,et,81106748 <bRmapCh5IrqFlagWriteCmd+0xc>
81106744:	003b68fa 	trap	3
81106748:	dfc00215 	stw	ra,8(sp)
8110674c:	df000115 	stw	fp,4(sp)
81106750:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106754:	01400484 	movi	r5,18
81106758:	01204834 	movhi	r4,33056
8110675c:	21070004 	addi	r4,r4,7168
81106760:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106764:	1080004c 	andi	r2,r2,1
}

bool bRmapCh5IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_5_BASE_ADDR,
81106768:	10000326 	beq	r2,zero,81106778 <bRmapCh5IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110676c:	00800044 	movi	r2,1
81106770:	e0bfff15 	stw	r2,-4(fp)
81106774:	00000106 	br	8110677c <bRmapCh5IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106778:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110677c:	e0bfff17 	ldw	r2,-4(fp)
}
81106780:	e037883a 	mov	sp,fp
81106784:	dfc00117 	ldw	ra,4(sp)
81106788:	df000017 	ldw	fp,0(sp)
8110678c:	dec00204 	addi	sp,sp,8
81106790:	f800283a 	ret

81106794 <bRmapCh6IrqFlagWriteCmd>:

bool bRmapCh6IrqFlagWriteCmd(void) {
81106794:	defffd04 	addi	sp,sp,-12
81106798:	de00012e 	bgeu	sp,et,811067a0 <bRmapCh6IrqFlagWriteCmd+0xc>
8110679c:	003b68fa 	trap	3
811067a0:	dfc00215 	stw	ra,8(sp)
811067a4:	df000115 	stw	fp,4(sp)
811067a8:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811067ac:	01400484 	movi	r5,18
811067b0:	01204834 	movhi	r4,33056
811067b4:	21060004 	addi	r4,r4,6144
811067b8:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
811067bc:	1080004c 	andi	r2,r2,1
}

bool bRmapCh6IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_6_BASE_ADDR,
811067c0:	10000326 	beq	r2,zero,811067d0 <bRmapCh6IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
811067c4:	00800044 	movi	r2,1
811067c8:	e0bfff15 	stw	r2,-4(fp)
811067cc:	00000106 	br	811067d4 <bRmapCh6IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
811067d0:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
811067d4:	e0bfff17 	ldw	r2,-4(fp)
}
811067d8:	e037883a 	mov	sp,fp
811067dc:	dfc00117 	ldw	ra,4(sp)
811067e0:	df000017 	ldw	fp,0(sp)
811067e4:	dec00204 	addi	sp,sp,8
811067e8:	f800283a 	ret

811067ec <bRmapCh7IrqFlagWriteCmd>:

bool bRmapCh7IrqFlagWriteCmd(void) {
811067ec:	defffd04 	addi	sp,sp,-12
811067f0:	de00012e 	bgeu	sp,et,811067f8 <bRmapCh7IrqFlagWriteCmd+0xc>
811067f4:	003b68fa 	trap	3
811067f8:	dfc00215 	stw	ra,8(sp)
811067fc:	df000115 	stw	fp,4(sp)
81106800:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106804:	01400484 	movi	r5,18
81106808:	01204834 	movhi	r4,33056
8110680c:	21050004 	addi	r4,r4,5120
81106810:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106814:	1080004c 	andi	r2,r2,1
}

bool bRmapCh7IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_7_BASE_ADDR,
81106818:	10000326 	beq	r2,zero,81106828 <bRmapCh7IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
8110681c:	00800044 	movi	r2,1
81106820:	e0bfff15 	stw	r2,-4(fp)
81106824:	00000106 	br	8110682c <bRmapCh7IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106828:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110682c:	e0bfff17 	ldw	r2,-4(fp)
}
81106830:	e037883a 	mov	sp,fp
81106834:	dfc00117 	ldw	ra,4(sp)
81106838:	df000017 	ldw	fp,0(sp)
8110683c:	dec00204 	addi	sp,sp,8
81106840:	f800283a 	ret

81106844 <bRmapCh8IrqFlagWriteCmd>:

bool bRmapCh8IrqFlagWriteCmd(void) {
81106844:	defffd04 	addi	sp,sp,-12
81106848:	de00012e 	bgeu	sp,et,81106850 <bRmapCh8IrqFlagWriteCmd+0xc>
8110684c:	003b68fa 	trap	3
81106850:	dfc00215 	stw	ra,8(sp)
81106854:	df000115 	stw	fp,4(sp)
81106858:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
8110685c:	01400484 	movi	r5,18
81106860:	01204834 	movhi	r4,33056
81106864:	21040004 	addi	r4,r4,4096
81106868:	1108ed80 	call	81108ed8 <uliRmapReadReg>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
8110686c:	1080004c 	andi	r2,r2,1
}

bool bRmapCh8IrqFlagWriteCmd(void) {
	bool bFlag;

	if (uliRmapReadReg((alt_u32*) COMM_CHANNEL_8_BASE_ADDR,
81106870:	10000326 	beq	r2,zero,81106880 <bRmapCh8IrqFlagWriteCmd+0x3c>
	COMM_IRQ_FLAGS_REG_OFST) & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
		bFlag = TRUE;
81106874:	00800044 	movi	r2,1
81106878:	e0bfff15 	stw	r2,-4(fp)
8110687c:	00000106 	br	81106884 <bRmapCh8IrqFlagWriteCmd+0x40>
	} else {
		bFlag = FALSE;
81106880:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
81106884:	e0bfff17 	ldw	r2,-4(fp)
}
81106888:	e037883a 	mov	sp,fp
8110688c:	dfc00117 	ldw	ra,4(sp)
81106890:	df000017 	ldw	fp,0(sp)
81106894:	dec00204 	addi	sp,sp,8
81106898:	f800283a 	ret

8110689c <uliRmapCh1WriteCmdAddress>:

alt_u32 uliRmapCh1WriteCmdAddress(void) {
8110689c:	defffd04 	addi	sp,sp,-12
811068a0:	de00012e 	bgeu	sp,et,811068a8 <uliRmapCh1WriteCmdAddress+0xc>
811068a4:	003b68fa 	trap	3
811068a8:	dfc00215 	stw	ra,8(sp)
811068ac:	df000115 	stw	fp,4(sp)
811068b0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811068b4:	01400184 	movi	r5,6
811068b8:	01204834 	movhi	r4,33056
811068bc:	210b0004 	addi	r4,r4,11264
811068c0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811068c4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_1_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811068c8:	e13fff17 	ldw	r4,-4(fp)
811068cc:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
811068d0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811068d4:	e0bfff17 	ldw	r2,-4(fp)
}
811068d8:	e037883a 	mov	sp,fp
811068dc:	dfc00117 	ldw	ra,4(sp)
811068e0:	df000017 	ldw	fp,0(sp)
811068e4:	dec00204 	addi	sp,sp,8
811068e8:	f800283a 	ret

811068ec <uliRmapCh2WriteCmdAddress>:

alt_u32 uliRmapCh2WriteCmdAddress(void) {
811068ec:	defffd04 	addi	sp,sp,-12
811068f0:	de00012e 	bgeu	sp,et,811068f8 <uliRmapCh2WriteCmdAddress+0xc>
811068f4:	003b68fa 	trap	3
811068f8:	dfc00215 	stw	ra,8(sp)
811068fc:	df000115 	stw	fp,4(sp)
81106900:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106904:	01400184 	movi	r5,6
81106908:	01204834 	movhi	r4,33056
8110690c:	210a0004 	addi	r4,r4,10240
81106910:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106914:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_2_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106918:	e13fff17 	ldw	r4,-4(fp)
8110691c:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
81106920:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106924:	e0bfff17 	ldw	r2,-4(fp)
}
81106928:	e037883a 	mov	sp,fp
8110692c:	dfc00117 	ldw	ra,4(sp)
81106930:	df000017 	ldw	fp,0(sp)
81106934:	dec00204 	addi	sp,sp,8
81106938:	f800283a 	ret

8110693c <uliRmapCh3WriteCmdAddress>:

alt_u32 uliRmapCh3WriteCmdAddress(void) {
8110693c:	defffd04 	addi	sp,sp,-12
81106940:	de00012e 	bgeu	sp,et,81106948 <uliRmapCh3WriteCmdAddress+0xc>
81106944:	003b68fa 	trap	3
81106948:	dfc00215 	stw	ra,8(sp)
8110694c:	df000115 	stw	fp,4(sp)
81106950:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106954:	01400184 	movi	r5,6
81106958:	01204834 	movhi	r4,33056
8110695c:	21090004 	addi	r4,r4,9216
81106960:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106964:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_3_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106968:	e13fff17 	ldw	r4,-4(fp)
8110696c:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
81106970:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106974:	e0bfff17 	ldw	r2,-4(fp)
}
81106978:	e037883a 	mov	sp,fp
8110697c:	dfc00117 	ldw	ra,4(sp)
81106980:	df000017 	ldw	fp,0(sp)
81106984:	dec00204 	addi	sp,sp,8
81106988:	f800283a 	ret

8110698c <uliRmapCh4WriteCmdAddress>:

alt_u32 uliRmapCh4WriteCmdAddress(void) {
8110698c:	defffd04 	addi	sp,sp,-12
81106990:	de00012e 	bgeu	sp,et,81106998 <uliRmapCh4WriteCmdAddress+0xc>
81106994:	003b68fa 	trap	3
81106998:	dfc00215 	stw	ra,8(sp)
8110699c:	df000115 	stw	fp,4(sp)
811069a0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811069a4:	01400184 	movi	r5,6
811069a8:	01204834 	movhi	r4,33056
811069ac:	21080004 	addi	r4,r4,8192
811069b0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811069b4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_4_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
811069b8:	e13fff17 	ldw	r4,-4(fp)
811069bc:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
811069c0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
811069c4:	e0bfff17 	ldw	r2,-4(fp)
}
811069c8:	e037883a 	mov	sp,fp
811069cc:	dfc00117 	ldw	ra,4(sp)
811069d0:	df000017 	ldw	fp,0(sp)
811069d4:	dec00204 	addi	sp,sp,8
811069d8:	f800283a 	ret

811069dc <uliRmapCh5WriteCmdAddress>:

alt_u32 uliRmapCh5WriteCmdAddress(void) {
811069dc:	defffd04 	addi	sp,sp,-12
811069e0:	de00012e 	bgeu	sp,et,811069e8 <uliRmapCh5WriteCmdAddress+0xc>
811069e4:	003b68fa 	trap	3
811069e8:	dfc00215 	stw	ra,8(sp)
811069ec:	df000115 	stw	fp,4(sp)
811069f0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
811069f4:	01400184 	movi	r5,6
811069f8:	01204834 	movhi	r4,33056
811069fc:	21070004 	addi	r4,r4,7168
81106a00:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106a04:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_5_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106a08:	e13fff17 	ldw	r4,-4(fp)
81106a0c:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
81106a10:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106a14:	e0bfff17 	ldw	r2,-4(fp)
}
81106a18:	e037883a 	mov	sp,fp
81106a1c:	dfc00117 	ldw	ra,4(sp)
81106a20:	df000017 	ldw	fp,0(sp)
81106a24:	dec00204 	addi	sp,sp,8
81106a28:	f800283a 	ret

81106a2c <uliRmapCh6WriteCmdAddress>:

alt_u32 uliRmapCh6WriteCmdAddress(void) {
81106a2c:	defffd04 	addi	sp,sp,-12
81106a30:	de00012e 	bgeu	sp,et,81106a38 <uliRmapCh6WriteCmdAddress+0xc>
81106a34:	003b68fa 	trap	3
81106a38:	dfc00215 	stw	ra,8(sp)
81106a3c:	df000115 	stw	fp,4(sp)
81106a40:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106a44:	01400184 	movi	r5,6
81106a48:	01204834 	movhi	r4,33056
81106a4c:	21060004 	addi	r4,r4,6144
81106a50:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106a54:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_6_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106a58:	e13fff17 	ldw	r4,-4(fp)
81106a5c:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
81106a60:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106a64:	e0bfff17 	ldw	r2,-4(fp)
}
81106a68:	e037883a 	mov	sp,fp
81106a6c:	dfc00117 	ldw	ra,4(sp)
81106a70:	df000017 	ldw	fp,0(sp)
81106a74:	dec00204 	addi	sp,sp,8
81106a78:	f800283a 	ret

81106a7c <uliRmapCh7WriteCmdAddress>:

alt_u32 uliRmapCh7WriteCmdAddress(void) {
81106a7c:	defffd04 	addi	sp,sp,-12
81106a80:	de00012e 	bgeu	sp,et,81106a88 <uliRmapCh7WriteCmdAddress+0xc>
81106a84:	003b68fa 	trap	3
81106a88:	dfc00215 	stw	ra,8(sp)
81106a8c:	df000115 	stw	fp,4(sp)
81106a90:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106a94:	01400184 	movi	r5,6
81106a98:	01204834 	movhi	r4,33056
81106a9c:	21050004 	addi	r4,r4,5120
81106aa0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106aa4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_7_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106aa8:	e13fff17 	ldw	r4,-4(fp)
81106aac:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
81106ab0:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106ab4:	e0bfff17 	ldw	r2,-4(fp)
}
81106ab8:	e037883a 	mov	sp,fp
81106abc:	dfc00117 	ldw	ra,4(sp)
81106ac0:	df000017 	ldw	fp,0(sp)
81106ac4:	dec00204 	addi	sp,sp,8
81106ac8:	f800283a 	ret

81106acc <uliRmapCh8WriteCmdAddress>:

alt_u32 uliRmapCh8WriteCmdAddress(void) {
81106acc:	defffd04 	addi	sp,sp,-12
81106ad0:	de00012e 	bgeu	sp,et,81106ad8 <uliRmapCh8WriteCmdAddress+0xc>
81106ad4:	003b68fa 	trap	3
81106ad8:	dfc00215 	stw	ra,8(sp)
81106adc:	df000115 	stw	fp,4(sp)
81106ae0:	df000104 	addi	fp,sp,4
	alt_u32 uliWriteAddr;

	uliWriteAddr = uliRmapReadReg((alt_u32*)
81106ae4:	01400184 	movi	r5,6
81106ae8:	01204834 	movhi	r4,33056
81106aec:	21040004 	addi	r4,r4,4096
81106af0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106af4:	e0bfff15 	stw	r2,-4(fp)
	COMM_CHANNEL_8_BASE_ADDR, COMM_RMAP_LST_WR_ADDR_REG_OFST);

	uliWriteAddr = uliConvRmapCfgAddr(uliWriteAddr);
81106af8:	e13fff17 	ldw	r4,-4(fp)
81106afc:	1108f280 	call	81108f28 <uliConvRmapCfgAddr>
81106b00:	e0bfff15 	stw	r2,-4(fp)

	return uliWriteAddr;
81106b04:	e0bfff17 	ldw	r2,-4(fp)
}
81106b08:	e037883a 	mov	sp,fp
81106b0c:	dfc00117 	ldw	ra,4(sp)
81106b10:	df000017 	ldw	fp,0(sp)
81106b14:	dec00204 	addi	sp,sp,8
81106b18:	f800283a 	ret

81106b1c <vRmapInitIrq>:

void vRmapInitIrq(alt_u8 ucCommCh) {
81106b1c:	defffc04 	addi	sp,sp,-16
81106b20:	de00012e 	bgeu	sp,et,81106b28 <vRmapInitIrq+0xc>
81106b24:	003b68fa 	trap	3
81106b28:	dfc00315 	stw	ra,12(sp)
81106b2c:	df000215 	stw	fp,8(sp)
81106b30:	df000204 	addi	fp,sp,8
81106b34:	2005883a 	mov	r2,r4
81106b38:	e0bfff05 	stb	r2,-4(fp)
	void* pvHoldContext;
	switch (ucCommCh) {
81106b3c:	e0bfff03 	ldbu	r2,-4(fp)
81106b40:	10c00228 	cmpgeui	r3,r2,8
81106b44:	18004e1e 	bne	r3,zero,81106c80 <vRmapInitIrq+0x164>
81106b48:	100690ba 	slli	r3,r2,2
81106b4c:	00a04434 	movhi	r2,33040
81106b50:	109ad804 	addi	r2,r2,27488
81106b54:	1885883a 	add	r2,r3,r2
81106b58:	10800017 	ldw	r2,0(r2)
81106b5c:	1000683a 	jmp	r2
81106b60:	81106b80 	call	881106b8 <__reset+0x20f06b8>
81106b64:	81106ba0 	cmpeqi	r4,r16,16814
81106b68:	81106bc0 	call	881106bc <__reset+0x20f06bc>
81106b6c:	81106be0 	cmpeqi	r4,r16,16815
81106b70:	81106c00 	call	881106c0 <__reset+0x20f06c0>
81106b74:	81106c20 	cmpeqi	r4,r16,16816
81106b78:	81106c40 	call	881106c4 <__reset+0x20f06c4>
81106b7c:	81106c60 	cmpeqi	r4,r16,16817
	case eCommSpwCh1:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh1HoldContext;
81106b80:	d0a04704 	addi	r2,gp,-32484
81106b84:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_1_RMAP_IRQ, pvHoldContext, vRmapCh1HandleIrq);
81106b88:	01a04434 	movhi	r6,33040
81106b8c:	31985c04 	addi	r6,r6,24944
81106b90:	e17ffe17 	ldw	r5,-8(fp)
81106b94:	010005c4 	movi	r4,23
81106b98:	11326200 	call	81132620 <alt_irq_register>
		break;
81106b9c:	00003806 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh2:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh2HoldContext;
81106ba0:	d0a04804 	addi	r2,gp,-32480
81106ba4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_2_RMAP_IRQ, pvHoldContext, vRmapCh2HandleIrq);
81106ba8:	01a04434 	movhi	r6,33040
81106bac:	31987f04 	addi	r6,r6,25084
81106bb0:	e17ffe17 	ldw	r5,-8(fp)
81106bb4:	01000544 	movi	r4,21
81106bb8:	11326200 	call	81132620 <alt_irq_register>
		break;
81106bbc:	00003006 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh3:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh3HoldContext;
81106bc0:	d0a04904 	addi	r2,gp,-32476
81106bc4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_3_RMAP_IRQ, pvHoldContext, vRmapCh3HandleIrq);
81106bc8:	01a04434 	movhi	r6,33040
81106bcc:	31988f04 	addi	r6,r6,25148
81106bd0:	e17ffe17 	ldw	r5,-8(fp)
81106bd4:	010004c4 	movi	r4,19
81106bd8:	11326200 	call	81132620 <alt_irq_register>
		break;
81106bdc:	00002806 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh4:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh4HoldContext;
81106be0:	d0a04a04 	addi	r2,gp,-32472
81106be4:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_4_RMAP_IRQ, pvHoldContext, vRmapCh4HandleIrq);
81106be8:	01a04434 	movhi	r6,33040
81106bec:	31989f04 	addi	r6,r6,25212
81106bf0:	e17ffe17 	ldw	r5,-8(fp)
81106bf4:	01000444 	movi	r4,17
81106bf8:	11326200 	call	81132620 <alt_irq_register>
		break;
81106bfc:	00002006 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh5:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh5HoldContext;
81106c00:	d0a04b04 	addi	r2,gp,-32468
81106c04:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_5_RMAP_IRQ, pvHoldContext, vRmapCh5HandleIrq);
81106c08:	01a04434 	movhi	r6,33040
81106c0c:	3198af04 	addi	r6,r6,25276
81106c10:	e17ffe17 	ldw	r5,-8(fp)
81106c14:	01000244 	movi	r4,9
81106c18:	11326200 	call	81132620 <alt_irq_register>
		break;
81106c1c:	00001806 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh6:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh6HoldContext;
81106c20:	d0a04c04 	addi	r2,gp,-32464
81106c24:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_6_RMAP_IRQ, pvHoldContext, vRmapCh6HandleIrq);
81106c28:	01a04434 	movhi	r6,33040
81106c2c:	3198bf04 	addi	r6,r6,25340
81106c30:	e17ffe17 	ldw	r5,-8(fp)
81106c34:	010001c4 	movi	r4,7
81106c38:	11326200 	call	81132620 <alt_irq_register>
		break;
81106c3c:	00001006 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh7:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh7HoldContext;
81106c40:	d0a04d04 	addi	r2,gp,-32460
81106c44:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_7_RMAP_IRQ, pvHoldContext, vRmapCh7HandleIrq);
81106c48:	01a04434 	movhi	r6,33040
81106c4c:	3198cf04 	addi	r6,r6,25404
81106c50:	e17ffe17 	ldw	r5,-8(fp)
81106c54:	01000104 	movi	r4,4
81106c58:	11326200 	call	81132620 <alt_irq_register>
		break;
81106c5c:	00000806 	br	81106c80 <vRmapInitIrq+0x164>
	case eCommSpwCh8:
		// Recast the hold_context pointer to match the alt_irq_register() function
		// prototype.
		pvHoldContext = (void*) &viCh8HoldContext;
81106c60:	d0a04e04 	addi	r2,gp,-32456
81106c64:	e0bffe15 	stw	r2,-8(fp)
		// Register the interrupt handler
		alt_irq_register(COMM_CH_8_RMAP_IRQ, pvHoldContext, vRmapCh8HandleIrq);
81106c68:	01a04434 	movhi	r6,33040
81106c6c:	3198df04 	addi	r6,r6,25468
81106c70:	e17ffe17 	ldw	r5,-8(fp)
81106c74:	010000c4 	movi	r4,3
81106c78:	11326200 	call	81132620 <alt_irq_register>
		break;
81106c7c:	0001883a 	nop
	}
}
81106c80:	0001883a 	nop
81106c84:	e037883a 	mov	sp,fp
81106c88:	dfc00117 	ldw	ra,4(sp)
81106c8c:	df000017 	ldw	fp,0(sp)
81106c90:	dec00204 	addi	sp,sp,8
81106c94:	f800283a 	ret

81106c98 <bRmapSetIrqControl>:

bool bRmapSetIrqControl(TRmapChannel *pxRmapCh) {
81106c98:	defffb04 	addi	sp,sp,-20
81106c9c:	de00012e 	bgeu	sp,et,81106ca4 <bRmapSetIrqControl+0xc>
81106ca0:	003b68fa 	trap	3
81106ca4:	dfc00415 	stw	ra,16(sp)
81106ca8:	df000315 	stw	fp,12(sp)
81106cac:	df000304 	addi	fp,sp,12
81106cb0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106cb4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106cb8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106cbc:	e0bfff17 	ldw	r2,-4(fp)
81106cc0:	10001926 	beq	r2,zero,81106d28 <bRmapSetIrqControl+0x90>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106cc4:	e0bfff17 	ldw	r2,-4(fp)
81106cc8:	10800017 	ldw	r2,0(r2)
81106ccc:	01400444 	movi	r5,17
81106cd0:	1009883a 	mov	r4,r2
81106cd4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106cd8:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (pxRmapCh->xRmapIrqControl.bWriteCmdEn) {
81106cdc:	e0bfff17 	ldw	r2,-4(fp)
81106ce0:	10801017 	ldw	r2,64(r2)
81106ce4:	10000426 	beq	r2,zero,81106cf8 <bRmapSetIrqControl+0x60>
			uliReg |= COMM_IRQ_RMAP_WRCMD_EN_MSK;
81106ce8:	e0bffe17 	ldw	r2,-8(fp)
81106cec:	10800054 	ori	r2,r2,1
81106cf0:	e0bffe15 	stw	r2,-8(fp)
81106cf4:	00000406 	br	81106d08 <bRmapSetIrqControl+0x70>
		} else {
			uliReg &= (~COMM_IRQ_RMAP_WRCMD_EN_MSK);
81106cf8:	e0fffe17 	ldw	r3,-8(fp)
81106cfc:	00bfff84 	movi	r2,-2
81106d00:	1884703a 	and	r2,r3,r2
81106d04:	e0bffe15 	stw	r2,-8(fp)
		}

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_IRQ_CONTROL_REG_OFST,
81106d08:	e0bfff17 	ldw	r2,-4(fp)
81106d0c:	10800017 	ldw	r2,0(r2)
81106d10:	e1bffe17 	ldw	r6,-8(fp)
81106d14:	01400444 	movi	r5,17
81106d18:	1009883a 	mov	r4,r2
81106d1c:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);
		bStatus = TRUE;
81106d20:	00800044 	movi	r2,1
81106d24:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106d28:	e0bffd17 	ldw	r2,-12(fp)
}
81106d2c:	e037883a 	mov	sp,fp
81106d30:	dfc00117 	ldw	ra,4(sp)
81106d34:	df000017 	ldw	fp,0(sp)
81106d38:	dec00204 	addi	sp,sp,8
81106d3c:	f800283a 	ret

81106d40 <bRmapGetIrqControl>:

bool bRmapGetIrqControl(TRmapChannel *pxRmapCh) {
81106d40:	defffb04 	addi	sp,sp,-20
81106d44:	de00012e 	bgeu	sp,et,81106d4c <bRmapGetIrqControl+0xc>
81106d48:	003b68fa 	trap	3
81106d4c:	dfc00415 	stw	ra,16(sp)
81106d50:	df000315 	stw	fp,12(sp)
81106d54:	df000304 	addi	fp,sp,12
81106d58:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106d5c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106d60:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106d64:	e0bfff17 	ldw	r2,-4(fp)
81106d68:	10001126 	beq	r2,zero,81106db0 <bRmapGetIrqControl+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106d6c:	e0bfff17 	ldw	r2,-4(fp)
81106d70:	10800017 	ldw	r2,0(r2)
81106d74:	01400444 	movi	r5,17
81106d78:	1009883a 	mov	r4,r2
81106d7c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106d80:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_CONTROL_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_EN_MSK) {
81106d84:	e0bffe17 	ldw	r2,-8(fp)
81106d88:	1080004c 	andi	r2,r2,1
81106d8c:	10000426 	beq	r2,zero,81106da0 <bRmapGetIrqControl+0x60>
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
81106d90:	e0bfff17 	ldw	r2,-4(fp)
81106d94:	00c00044 	movi	r3,1
81106d98:	10c01015 	stw	r3,64(r2)
81106d9c:	00000206 	br	81106da8 <bRmapGetIrqControl+0x68>
		} else {
			pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
81106da0:	e0bfff17 	ldw	r2,-4(fp)
81106da4:	10001015 	stw	zero,64(r2)
		}

		bStatus = TRUE;
81106da8:	00800044 	movi	r2,1
81106dac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106db0:	e0bffd17 	ldw	r2,-12(fp)
}
81106db4:	e037883a 	mov	sp,fp
81106db8:	dfc00117 	ldw	ra,4(sp)
81106dbc:	df000017 	ldw	fp,0(sp)
81106dc0:	dec00204 	addi	sp,sp,8
81106dc4:	f800283a 	ret

81106dc8 <bRmapGetIrqFlags>:

bool bRmapGetIrqFlags(TRmapChannel *pxRmapCh) {
81106dc8:	defffb04 	addi	sp,sp,-20
81106dcc:	de00012e 	bgeu	sp,et,81106dd4 <bRmapGetIrqFlags+0xc>
81106dd0:	003b68fa 	trap	3
81106dd4:	dfc00415 	stw	ra,16(sp)
81106dd8:	df000315 	stw	fp,12(sp)
81106ddc:	df000304 	addi	fp,sp,12
81106de0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106de4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106de8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106dec:	e0bfff17 	ldw	r2,-4(fp)
81106df0:	10001126 	beq	r2,zero,81106e38 <bRmapGetIrqFlags+0x70>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106df4:	e0bfff17 	ldw	r2,-4(fp)
81106df8:	10800017 	ldw	r2,0(r2)
81106dfc:	01400484 	movi	r5,18
81106e00:	1009883a 	mov	r4,r2
81106e04:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106e08:	e0bffe15 	stw	r2,-8(fp)
		COMM_IRQ_FLAGS_REG_OFST);

		if (uliReg & COMM_IRQ_RMAP_WRCMD_FLG_MSK) {
81106e0c:	e0bffe17 	ldw	r2,-8(fp)
81106e10:	1080004c 	andi	r2,r2,1
81106e14:	10000426 	beq	r2,zero,81106e28 <bRmapGetIrqFlags+0x60>
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = TRUE;
81106e18:	e0bfff17 	ldw	r2,-4(fp)
81106e1c:	00c00044 	movi	r3,1
81106e20:	10c01115 	stw	r3,68(r2)
81106e24:	00000206 	br	81106e30 <bRmapGetIrqFlags+0x68>
		} else {
			pxRmapCh->xRmapIrqFlag.bWriteCmdFlag = FALSE;
81106e28:	e0bfff17 	ldw	r2,-4(fp)
81106e2c:	10001115 	stw	zero,68(r2)
		}

		bStatus = TRUE;
81106e30:	00800044 	movi	r2,1
81106e34:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106e38:	e0bffd17 	ldw	r2,-12(fp)
}
81106e3c:	e037883a 	mov	sp,fp
81106e40:	dfc00117 	ldw	ra,4(sp)
81106e44:	df000017 	ldw	fp,0(sp)
81106e48:	dec00204 	addi	sp,sp,8
81106e4c:	f800283a 	ret

81106e50 <bRmapSetCodecConfig>:

bool bRmapSetCodecConfig(TRmapChannel *pxRmapCh) {
81106e50:	defffb04 	addi	sp,sp,-20
81106e54:	de00012e 	bgeu	sp,et,81106e5c <bRmapSetCodecConfig+0xc>
81106e58:	003b68fa 	trap	3
81106e5c:	dfc00415 	stw	ra,16(sp)
81106e60:	df000315 	stw	fp,12(sp)
81106e64:	df000304 	addi	fp,sp,12
81106e68:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106e6c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106e70:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106e74:	e0bfff17 	ldw	r2,-4(fp)
81106e78:	10002526 	beq	r2,zero,81106f10 <bRmapSetCodecConfig+0xc0>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106e7c:	e0bfff17 	ldw	r2,-4(fp)
81106e80:	10800017 	ldw	r2,0(r2)
81106e84:	01400104 	movi	r5,4
81106e88:	1009883a 	mov	r4,r2
81106e8c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106e90:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
81106e94:	e0fffe17 	ldw	r3,-8(fp)
81106e98:	00bfc004 	movi	r2,-256
81106e9c:	1884703a 	and	r2,r3,r2
81106ea0:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
81106ea4:	e0bfff17 	ldw	r2,-4(fp)
81106ea8:	10800143 	ldbu	r2,5(r2)
81106eac:	10803fcc 	andi	r2,r2,255

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
81106eb0:	e0fffe17 	ldw	r3,-8(fp)
81106eb4:	1884b03a 	or	r2,r3,r2
81106eb8:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
81106ebc:	e0fffe17 	ldw	r3,-8(fp)
81106ec0:	00bffff4 	movhi	r2,65535
81106ec4:	10803fc4 	addi	r2,r2,255
81106ec8:	1884703a 	and	r2,r3,r2
81106ecc:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));
81106ed0:	e0bfff17 	ldw	r2,-4(fp)
81106ed4:	10800103 	ldbu	r2,4(r2)
81106ed8:	10803fcc 	andi	r2,r2,255
81106edc:	1004923a 	slli	r2,r2,8
81106ee0:	10bfffcc 	andi	r2,r2,65535

		uliReg &= (~COMM_RMAP_TARGET_LOG_ADDR_MSK);
		uliReg |= (COMM_RMAP_TARGET_LOG_ADDR_MSK
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucLogicalAddress << 0));
		uliReg &= (~COMM_RMAP_TARGET_KEY_MSK);
		uliReg |= (COMM_RMAP_TARGET_KEY_MSK
81106ee4:	e0fffe17 	ldw	r3,-8(fp)
81106ee8:	1884b03a 	or	r2,r3,r2
81106eec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapCodecConfig.ucKey << 8));

		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CODEC_CFG_REG_OFST,
81106ef0:	e0bfff17 	ldw	r2,-4(fp)
81106ef4:	10800017 	ldw	r2,0(r2)
81106ef8:	e1bffe17 	ldw	r6,-8(fp)
81106efc:	01400104 	movi	r5,4
81106f00:	1009883a 	mov	r4,r2
81106f04:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81106f08:	00800044 	movi	r2,1
81106f0c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106f10:	e0bffd17 	ldw	r2,-12(fp)
}
81106f14:	e037883a 	mov	sp,fp
81106f18:	dfc00117 	ldw	ra,4(sp)
81106f1c:	df000017 	ldw	fp,0(sp)
81106f20:	dec00204 	addi	sp,sp,8
81106f24:	f800283a 	ret

81106f28 <bRmapGetCodecConfig>:

bool bRmapGetCodecConfig(TRmapChannel *pxRmapCh) {
81106f28:	defffb04 	addi	sp,sp,-20
81106f2c:	de00012e 	bgeu	sp,et,81106f34 <bRmapGetCodecConfig+0xc>
81106f30:	003b68fa 	trap	3
81106f34:	dfc00415 	stw	ra,16(sp)
81106f38:	df000315 	stw	fp,12(sp)
81106f3c:	df000304 	addi	fp,sp,12
81106f40:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106f44:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106f48:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106f4c:	e0bfff17 	ldw	r2,-4(fp)
81106f50:	10001226 	beq	r2,zero,81106f9c <bRmapGetCodecConfig+0x74>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106f54:	e0bfff17 	ldw	r2,-4(fp)
81106f58:	10800017 	ldw	r2,0(r2)
81106f5c:	01400104 	movi	r5,4
81106f60:	1009883a 	mov	r4,r2
81106f64:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106f68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
81106f6c:	e0bffe17 	ldw	r2,-8(fp)
81106f70:	1007883a 	mov	r3,r2
81106f74:	e0bfff17 	ldw	r2,-4(fp)
81106f78:	10c00145 	stb	r3,5(r2)
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);
81106f7c:	e0bffe17 	ldw	r2,-8(fp)
81106f80:	10bfc00c 	andi	r2,r2,65280
81106f84:	1004d23a 	srli	r2,r2,8
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_CODEC_CFG_REG_OFST);

		pxRmapCh->xRmapCodecConfig.ucLogicalAddress = (alt_u8) ((uliReg
				& COMM_RMAP_TARGET_LOG_ADDR_MSK) >> 0);
		pxRmapCh->xRmapCodecConfig.ucKey = (alt_u8) ((uliReg
81106f88:	1007883a 	mov	r3,r2
81106f8c:	e0bfff17 	ldw	r2,-4(fp)
81106f90:	10c00105 	stb	r3,4(r2)
				& COMM_RMAP_TARGET_KEY_MSK) >> 8);

		bStatus = TRUE;
81106f94:	00800044 	movi	r2,1
81106f98:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81106f9c:	e0bffd17 	ldw	r2,-12(fp)
}
81106fa0:	e037883a 	mov	sp,fp
81106fa4:	dfc00117 	ldw	ra,4(sp)
81106fa8:	df000017 	ldw	fp,0(sp)
81106fac:	dec00204 	addi	sp,sp,8
81106fb0:	f800283a 	ret

81106fb4 <bRmapGetCodecStatus>:

bool bRmapGetCodecStatus(TRmapChannel *pxRmapCh) {
81106fb4:	defffb04 	addi	sp,sp,-20
81106fb8:	de00012e 	bgeu	sp,et,81106fc0 <bRmapGetCodecStatus+0xc>
81106fbc:	003b68fa 	trap	3
81106fc0:	dfc00415 	stw	ra,16(sp)
81106fc4:	df000315 	stw	fp,12(sp)
81106fc8:	df000304 	addi	fp,sp,12
81106fcc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81106fd0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81106fd4:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81106fd8:	e0bfff17 	ldw	r2,-4(fp)
81106fdc:	10004726 	beq	r2,zero,811070fc <bRmapGetCodecStatus+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81106fe0:	e0bfff17 	ldw	r2,-4(fp)
81106fe4:	10800017 	ldw	r2,0(r2)
81106fe8:	01400144 	movi	r5,5
81106fec:	1009883a 	mov	r4,r2
81106ff0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81106ff4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_STAT_CMD_RECEIVED_MSK) {
81106ff8:	e0bffe17 	ldw	r2,-8(fp)
81106ffc:	1080004c 	andi	r2,r2,1
81107000:	10000426 	beq	r2,zero,81107014 <bRmapGetCodecStatus+0x60>
			pxRmapCh->xRmapCodecStatus.bCommandReceived = TRUE;
81107004:	e0bfff17 	ldw	r2,-4(fp)
81107008:	00c00044 	movi	r3,1
8110700c:	10c00215 	stw	r3,8(r2)
81107010:	00000206 	br	8110701c <bRmapGetCodecStatus+0x68>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
81107014:	e0bfff17 	ldw	r2,-4(fp)
81107018:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_REQ_MSK) {
8110701c:	e0bffe17 	ldw	r2,-8(fp)
81107020:	1080008c 	andi	r2,r2,2
81107024:	10000426 	beq	r2,zero,81107038 <bRmapGetCodecStatus+0x84>
			pxRmapCh->xRmapCodecStatus.bWriteRequested = TRUE;
81107028:	e0bfff17 	ldw	r2,-4(fp)
8110702c:	00c00044 	movi	r3,1
81107030:	10c00315 	stw	r3,12(r2)
81107034:	00000206 	br	81107040 <bRmapGetCodecStatus+0x8c>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteRequested = FALSE;
81107038:	e0bfff17 	ldw	r2,-4(fp)
8110703c:	10000315 	stw	zero,12(r2)
		}
		if (uliReg & COMM_RMAP_STAT_WR_AUTH_MSK) {
81107040:	e0bffe17 	ldw	r2,-8(fp)
81107044:	1080010c 	andi	r2,r2,4
81107048:	10000426 	beq	r2,zero,8110705c <bRmapGetCodecStatus+0xa8>
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = TRUE;
8110704c:	e0bfff17 	ldw	r2,-4(fp)
81107050:	00c00044 	movi	r3,1
81107054:	10c00415 	stw	r3,16(r2)
81107058:	00000206 	br	81107064 <bRmapGetCodecStatus+0xb0>
		} else {
			pxRmapCh->xRmapCodecStatus.bWriteAuthorized = FALSE;
8110705c:	e0bfff17 	ldw	r2,-4(fp)
81107060:	10000415 	stw	zero,16(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_REQ_MSK) {
81107064:	e0bffe17 	ldw	r2,-8(fp)
81107068:	1080020c 	andi	r2,r2,8
8110706c:	10000426 	beq	r2,zero,81107080 <bRmapGetCodecStatus+0xcc>
			pxRmapCh->xRmapCodecStatus.bReadRequested = TRUE;
81107070:	e0bfff17 	ldw	r2,-4(fp)
81107074:	00c00044 	movi	r3,1
81107078:	10c00515 	stw	r3,20(r2)
8110707c:	00000206 	br	81107088 <bRmapGetCodecStatus+0xd4>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadRequested = FALSE;
81107080:	e0bfff17 	ldw	r2,-4(fp)
81107084:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_RMAP_STAT_RD_AUTH_MSK) {
81107088:	e0bffe17 	ldw	r2,-8(fp)
8110708c:	1080040c 	andi	r2,r2,16
81107090:	10000426 	beq	r2,zero,811070a4 <bRmapGetCodecStatus+0xf0>
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = TRUE;
81107094:	e0bfff17 	ldw	r2,-4(fp)
81107098:	00c00044 	movi	r3,1
8110709c:	10c00615 	stw	r3,24(r2)
811070a0:	00000206 	br	811070ac <bRmapGetCodecStatus+0xf8>
		} else {
			pxRmapCh->xRmapCodecStatus.bReadAuthorized = FALSE;
811070a4:	e0bfff17 	ldw	r2,-4(fp)
811070a8:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_RMAP_STAT_REPLY_SEND_MSK) {
811070ac:	e0bffe17 	ldw	r2,-8(fp)
811070b0:	1080080c 	andi	r2,r2,32
811070b4:	10000426 	beq	r2,zero,811070c8 <bRmapGetCodecStatus+0x114>
			pxRmapCh->xRmapCodecStatus.bReplySended = TRUE;
811070b8:	e0bfff17 	ldw	r2,-4(fp)
811070bc:	00c00044 	movi	r3,1
811070c0:	10c00715 	stw	r3,28(r2)
811070c4:	00000206 	br	811070d0 <bRmapGetCodecStatus+0x11c>
		} else {
			pxRmapCh->xRmapCodecStatus.bReplySended = FALSE;
811070c8:	e0bfff17 	ldw	r2,-4(fp)
811070cc:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_RMAP_STAT_DISCARD_PKG_MSK) {
811070d0:	e0bffe17 	ldw	r2,-8(fp)
811070d4:	1080100c 	andi	r2,r2,64
811070d8:	10000426 	beq	r2,zero,811070ec <bRmapGetCodecStatus+0x138>
			pxRmapCh->xRmapCodecStatus.bDiscardedPackage = TRUE;
811070dc:	e0bfff17 	ldw	r2,-4(fp)
811070e0:	00c00044 	movi	r3,1
811070e4:	10c00815 	stw	r3,32(r2)
811070e8:	00000206 	br	811070f4 <bRmapGetCodecStatus+0x140>
		} else {
			pxRmapCh->xRmapCodecStatus.bCommandReceived = FALSE;
811070ec:	e0bfff17 	ldw	r2,-4(fp)
811070f0:	10000215 	stw	zero,8(r2)
		}

		bStatus = TRUE;
811070f4:	00800044 	movi	r2,1
811070f8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811070fc:	e0bffd17 	ldw	r2,-12(fp)
}
81107100:	e037883a 	mov	sp,fp
81107104:	dfc00117 	ldw	ra,4(sp)
81107108:	df000017 	ldw	fp,0(sp)
8110710c:	dec00204 	addi	sp,sp,8
81107110:	f800283a 	ret

81107114 <bRmapGetCodecError>:

bool bRmapGetCodecError(TRmapChannel *pxRmapCh) {
81107114:	defffb04 	addi	sp,sp,-20
81107118:	de00012e 	bgeu	sp,et,81107120 <bRmapGetCodecError+0xc>
8110711c:	003b68fa 	trap	3
81107120:	dfc00415 	stw	ra,16(sp)
81107124:	df000315 	stw	fp,12(sp)
81107128:	df000304 	addi	fp,sp,12
8110712c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107130:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107134:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107138:	e0bfff17 	ldw	r2,-4(fp)
8110713c:	10004726 	beq	r2,zero,8110725c <bRmapGetCodecError+0x148>
		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107140:	e0bfff17 	ldw	r2,-4(fp)
81107144:	10800017 	ldw	r2,0(r2)
81107148:	01400144 	movi	r5,5
8110714c:	1009883a 	mov	r4,r2
81107150:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107154:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CODEC_STAT_REG_OFST);

		if (uliReg & COMM_RMAP_ERR_EARLY_EOP_MSK) {
81107158:	e0bffe17 	ldw	r2,-8(fp)
8110715c:	1080006c 	andhi	r2,r2,1
81107160:	10000426 	beq	r2,zero,81107174 <bRmapGetCodecError+0x60>
			pxRmapCh->xRmapCodecError.bEarlyEop = TRUE;
81107164:	e0bfff17 	ldw	r2,-4(fp)
81107168:	00c00044 	movi	r3,1
8110716c:	10c00915 	stw	r3,36(r2)
81107170:	00000206 	br	8110717c <bRmapGetCodecError+0x68>
		} else {
			pxRmapCh->xRmapCodecError.bEarlyEop = FALSE;
81107174:	e0bfff17 	ldw	r2,-4(fp)
81107178:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_RMAP_ERR_EEP_MSK) {
8110717c:	e0bffe17 	ldw	r2,-8(fp)
81107180:	108000ac 	andhi	r2,r2,2
81107184:	10000426 	beq	r2,zero,81107198 <bRmapGetCodecError+0x84>
			pxRmapCh->xRmapCodecError.bEep = TRUE;
81107188:	e0bfff17 	ldw	r2,-4(fp)
8110718c:	00c00044 	movi	r3,1
81107190:	10c00a15 	stw	r3,40(r2)
81107194:	00000206 	br	811071a0 <bRmapGetCodecError+0x8c>
		} else {
			pxRmapCh->xRmapCodecError.bEep = FALSE;
81107198:	e0bfff17 	ldw	r2,-4(fp)
8110719c:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_RMAP_ERR_HEADER_CRC_MSK) {
811071a0:	e0bffe17 	ldw	r2,-8(fp)
811071a4:	1080012c 	andhi	r2,r2,4
811071a8:	10000426 	beq	r2,zero,811071bc <bRmapGetCodecError+0xa8>
			pxRmapCh->xRmapCodecError.bHeaderCRC = TRUE;
811071ac:	e0bfff17 	ldw	r2,-4(fp)
811071b0:	00c00044 	movi	r3,1
811071b4:	10c00b15 	stw	r3,44(r2)
811071b8:	00000206 	br	811071c4 <bRmapGetCodecError+0xb0>
		} else {
			pxRmapCh->xRmapCodecError.bHeaderCRC = FALSE;
811071bc:	e0bfff17 	ldw	r2,-4(fp)
811071c0:	10000b15 	stw	zero,44(r2)
		}
		if (uliReg & COMM_RMAP_ERR_UNUSED_PKT_MSK) {
811071c4:	e0bffe17 	ldw	r2,-8(fp)
811071c8:	1080022c 	andhi	r2,r2,8
811071cc:	10000426 	beq	r2,zero,811071e0 <bRmapGetCodecError+0xcc>
			pxRmapCh->xRmapCodecError.bUnusedPacketType = TRUE;
811071d0:	e0bfff17 	ldw	r2,-4(fp)
811071d4:	00c00044 	movi	r3,1
811071d8:	10c00c15 	stw	r3,48(r2)
811071dc:	00000206 	br	811071e8 <bRmapGetCodecError+0xd4>
		} else {
			pxRmapCh->xRmapCodecError.bUnusedPacketType = FALSE;
811071e0:	e0bfff17 	ldw	r2,-4(fp)
811071e4:	10000c15 	stw	zero,48(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_CMD_MSK) {
811071e8:	e0bffe17 	ldw	r2,-8(fp)
811071ec:	1080042c 	andhi	r2,r2,16
811071f0:	10000426 	beq	r2,zero,81107204 <bRmapGetCodecError+0xf0>
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = TRUE;
811071f4:	e0bfff17 	ldw	r2,-4(fp)
811071f8:	00c00044 	movi	r3,1
811071fc:	10c00d15 	stw	r3,52(r2)
81107200:	00000206 	br	8110720c <bRmapGetCodecError+0xf8>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidCommandCode = FALSE;
81107204:	e0bfff17 	ldw	r2,-4(fp)
81107208:	10000d15 	stw	zero,52(r2)
		}
		if (uliReg & COMM_RMAP_ERR_TOO_MUCH_DATA_MSK) {
8110720c:	e0bffe17 	ldw	r2,-8(fp)
81107210:	1080082c 	andhi	r2,r2,32
81107214:	10000426 	beq	r2,zero,81107228 <bRmapGetCodecError+0x114>
			pxRmapCh->xRmapCodecError.bTooMuchData = TRUE;
81107218:	e0bfff17 	ldw	r2,-4(fp)
8110721c:	00c00044 	movi	r3,1
81107220:	10c00e15 	stw	r3,56(r2)
81107224:	00000206 	br	81107230 <bRmapGetCodecError+0x11c>
		} else {
			pxRmapCh->xRmapCodecError.bTooMuchData = FALSE;
81107228:	e0bfff17 	ldw	r2,-4(fp)
8110722c:	10000e15 	stw	zero,56(r2)
		}
		if (uliReg & COMM_RMAP_ERR_INVALID_DCRC_MSK) {
81107230:	e0bffe17 	ldw	r2,-8(fp)
81107234:	1080102c 	andhi	r2,r2,64
81107238:	10000426 	beq	r2,zero,8110724c <bRmapGetCodecError+0x138>
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = TRUE;
8110723c:	e0bfff17 	ldw	r2,-4(fp)
81107240:	00c00044 	movi	r3,1
81107244:	10c00f15 	stw	r3,60(r2)
81107248:	00000206 	br	81107254 <bRmapGetCodecError+0x140>
		} else {
			pxRmapCh->xRmapCodecError.bInvalidDataCrc = FALSE;
8110724c:	e0bfff17 	ldw	r2,-4(fp)
81107250:	10000f15 	stw	zero,60(r2)
		}

		bStatus = TRUE;
81107254:	00800044 	movi	r2,1
81107258:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110725c:	e0bffd17 	ldw	r2,-12(fp)
}
81107260:	e037883a 	mov	sp,fp
81107264:	dfc00117 	ldw	ra,4(sp)
81107268:	df000017 	ldw	fp,0(sp)
8110726c:	dec00204 	addi	sp,sp,8
81107270:	f800283a 	ret

81107274 <bRmapSetMemConfigArea>:

bool bRmapSetMemConfigArea(TRmapChannel *pxRmapCh) {
81107274:	defffb04 	addi	sp,sp,-20
81107278:	de00012e 	bgeu	sp,et,81107280 <bRmapSetMemConfigArea+0xc>
8110727c:	003b68fa 	trap	3
81107280:	dfc00415 	stw	ra,16(sp)
81107284:	df000315 	stw	fp,12(sp)
81107288:	df000304 	addi	fp,sp,12
8110728c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107290:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107294:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107298:	e0bfff17 	ldw	r2,-4(fp)
8110729c:	1000aa26 	beq	r2,zero,81107548 <bRmapSetMemConfigArea+0x2d4>

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config;
811072a0:	e0bfff17 	ldw	r2,-4(fp)
811072a4:	10801217 	ldw	r2,72(r2)
811072a8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_REGCLK_DIR_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 3));
//			uliReg &= (~COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 4));
//			uliReg &= (~COMM_RMAP_REGCLK_TRCNT_CTRL_MSK);
//			uliReg |= (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config. << 20));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811072ac:	e0bfff17 	ldw	r2,-4(fp)
811072b0:	10800017 	ldw	r2,0(r2)
811072b4:	e1bffe17 	ldw	r6,-8(fp)
811072b8:	01401004 	movi	r5,64
811072bc:	1009883a 	mov	r4,r2
811072c0:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config;
811072c4:	e0bfff17 	ldw	r2,-4(fp)
811072c8:	10801317 	ldw	r2,76(r2)
811072cc:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK);
//			uliReg |= (COMM_RMAP_SL_RDOUT_PAUSE_CNT_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811072d0:	e0bfff17 	ldw	r2,-4(fp)
811072d4:	10800017 	ldw	r2,0(r2)
811072d8:	e1bffe17 	ldw	r6,-8(fp)
811072dc:	01401044 	movi	r5,65
811072e0:	1009883a 	mov	r4,r2
811072e4:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config;
811072e8:	e0bfff17 	ldw	r2,-4(fp)
811072ec:	10801417 	ldw	r2,80(r2)
811072f0:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_DIGITISE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_CCD_DTRAN_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
//			uliReg &= (~COMM_RMAP_PACKET_SIZE_CTRL_MSK);
//			uliReg |= (COMM_RMAP_PACKET_SIZE_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811072f4:	e0bfff17 	ldw	r2,-4(fp)
811072f8:	10800017 	ldw	r2,0(r2)
811072fc:	e1bffe17 	ldw	r6,-8(fp)
81107300:	01401084 	movi	r5,66
81107304:	1009883a 	mov	r4,r2
81107308:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config;
8110730c:	e0bfff17 	ldw	r2,-4(fp)
81107310:	10801517 	ldw	r2,84(r2)
81107314:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107318:	e0bfff17 	ldw	r2,-4(fp)
8110731c:	10800017 	ldw	r2,0(r2)
81107320:	e1bffe17 	ldw	r6,-8(fp)
81107324:	014010c4 	movi	r5,67
81107328:	1009883a 	mov	r4,r2
8110732c:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
81107330:	e0bfff17 	ldw	r2,-4(fp)
81107334:	10802217 	ldw	r2,136(r2)
81107338:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110733c:	e0bfff17 	ldw	r2,-4(fp)
81107340:	10800017 	ldw	r2,0(r2)
81107344:	e1bffe17 	ldw	r6,-8(fp)
81107348:	01401104 	movi	r5,68
8110734c:	1009883a 	mov	r4,r2
81107350:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config;
81107354:	e0bfff17 	ldw	r2,-4(fp)
81107358:	10801717 	ldw	r2,92(r2)
8110735c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD1_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD1_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107360:	e0bfff17 	ldw	r2,-4(fp)
81107364:	10800017 	ldw	r2,0(r2)
81107368:	e1bffe17 	ldw	r6,-8(fp)
8110736c:	01401144 	movi	r5,69
81107370:	1009883a 	mov	r4,r2
81107374:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config;
81107378:	e0bfff17 	ldw	r2,-4(fp)
8110737c:	10801817 	ldw	r2,96(r2)
81107380:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107384:	e0bfff17 	ldw	r2,-4(fp)
81107388:	10800017 	ldw	r2,0(r2)
8110738c:	e1bffe17 	ldw	r6,-8(fp)
81107390:	01401184 	movi	r5,70
81107394:	1009883a 	mov	r4,r2
81107398:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config;
8110739c:	e0bfff17 	ldw	r2,-4(fp)
811073a0:	10801917 	ldw	r2,100(r2)
811073a4:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD2_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD2_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811073a8:	e0bfff17 	ldw	r2,-4(fp)
811073ac:	10800017 	ldw	r2,0(r2)
811073b0:	e1bffe17 	ldw	r6,-8(fp)
811073b4:	014011c4 	movi	r5,71
811073b8:	1009883a 	mov	r4,r2
811073bc:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config;
811073c0:	e0bfff17 	ldw	r2,-4(fp)
811073c4:	10801a17 	ldw	r2,104(r2)
811073c8:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811073cc:	e0bfff17 	ldw	r2,-4(fp)
811073d0:	10800017 	ldw	r2,0(r2)
811073d4:	e1bffe17 	ldw	r6,-8(fp)
811073d8:	01401204 	movi	r5,72
811073dc:	1009883a 	mov	r4,r2
811073e0:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config;
811073e4:	e0bfff17 	ldw	r2,-4(fp)
811073e8:	10801b17 	ldw	r2,108(r2)
811073ec:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD3_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD3_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811073f0:	e0bfff17 	ldw	r2,-4(fp)
811073f4:	10800017 	ldw	r2,0(r2)
811073f8:	e1bffe17 	ldw	r6,-8(fp)
811073fc:	01401244 	movi	r5,73
81107400:	1009883a 	mov	r4,r2
81107404:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST, uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107408:	e0bfff17 	ldw	r2,-4(fp)
8110740c:	10800017 	ldw	r2,0(r2)
81107410:	01401284 	movi	r5,74
81107414:	1009883a 	mov	r4,r2
81107418:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110741c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config;
81107420:	e0bfff17 	ldw	r2,-4(fp)
81107424:	10801c17 	ldw	r2,112(r2)
81107428:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_WLIST_P_IADDR_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_P_IADDR_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
8110742c:	e0bfff17 	ldw	r2,-4(fp)
81107430:	10800017 	ldw	r2,0(r2)
81107434:	e1bffe17 	ldw	r6,-8(fp)
81107438:	01401284 	movi	r5,74
8110743c:	1009883a 	mov	r4,r2
81107440:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config;
81107444:	e0bfff17 	ldw	r2,-4(fp)
81107448:	10801d17 	ldw	r2,116(r2)
8110744c:	e0bffe15 	stw	r2,-8(fp)
//			uliReg |= (COMM_RMAP_WINDOW_WIDTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WINDOW_HEIGHT_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
//			uliReg &= (~COMM_RMAP_WLIST_LENGTH_CCD4_MSK);
//			uliReg |= (COMM_RMAP_WLIST_LENGTH_CCD4_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
81107450:	e0bfff17 	ldw	r2,-4(fp)
81107454:	10800017 	ldw	r2,0(r2)
81107458:	e1bffe17 	ldw	r6,-8(fp)
8110745c:	014012c4 	movi	r5,75
81107460:	1009883a 	mov	r4,r2
81107464:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig;
81107468:	e0bfff17 	ldw	r2,-4(fp)
8110746c:	10801e17 	ldw	r2,120(r2)
81107470:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_MODE_SEL_CTRL_MSK);
//			uliReg |= (COMM_RMAP_MODE_SEL_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_OP_MODE_CFG_REG_OFST,
81107474:	e0bfff17 	ldw	r2,-4(fp)
81107478:	10800017 	ldw	r2,0(r2)
8110747c:	e1bffe17 	ldw	r6,-8(fp)
81107480:	01401304 	movi	r5,76
81107484:	1009883a 	mov	r4,r2
81107488:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliSyncConfig;
8110748c:	e0bfff17 	ldw	r2,-4(fp)
81107490:	10801f17 	ldw	r2,124(r2)
81107494:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_SYNC_CFG_MSK);
//			uliReg |= (COMM_RMAP_SYNC_CFG_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
//			uliReg &= (~COMM_RMAP_SELF_TRIGGER_CTRL_MSK);
//			uliReg |= (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliSyncConfig. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_SYNC_CFG_REG_OFST,
81107498:	e0bfff17 	ldw	r2,-4(fp)
8110749c:	10800017 	ldw	r2,0(r2)
811074a0:	e1bffe17 	ldw	r6,-8(fp)
811074a4:	01401344 	movi	r5,77
811074a8:	1009883a 	mov	r4,r2
811074ac:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliDacControl;
811074b0:	e0bfff17 	ldw	r2,-4(fp)
811074b4:	10802017 	ldw	r2,128(r2)
811074b8:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_DAC_CTRL_REG_OFST,
811074bc:	e0bfff17 	ldw	r2,-4(fp)
811074c0:	10800017 	ldw	r2,0(r2)
811074c4:	e1bffe17 	ldw	r6,-8(fp)
811074c8:	01401384 	movi	r5,78
811074cc:	1009883a 	mov	r4,r2
811074d0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811074d4:	e0bfff17 	ldw	r2,-4(fp)
811074d8:	10802217 	ldw	r2,136(r2)
811074dc:	e0bffe15 	stw	r2,-8(fp)
		vRmapWriteReg(pxRmapCh->puliRmapChAddr,
811074e0:	e0bfff17 	ldw	r2,-4(fp)
811074e4:	10800017 	ldw	r2,0(r2)
811074e8:	e1bffe17 	ldw	r6,-8(fp)
811074ec:	014013c4 	movi	r5,79
811074f0:	1009883a 	mov	r4,r2
811074f4:	1108e840 	call	81108e84 <vRmapWriteReg>
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST, uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliFrameNumber;
811074f8:	e0bfff17 	ldw	r2,-4(fp)
811074fc:	10802217 	ldw	r2,136(r2)
81107500:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_FRAME_NUMBER_MSK);
//			uliReg |= (COMM_RMAP_FRAME_NUMBER_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliFrameNumber. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_FRAME_NUMBER_REG_OFST,
81107504:	e0bfff17 	ldw	r2,-4(fp)
81107508:	10800017 	ldw	r2,0(r2)
8110750c:	e1bffe17 	ldw	r6,-8(fp)
81107510:	01401404 	movi	r5,80
81107514:	1009883a 	mov	r4,r2
81107518:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

//		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST);
		uliReg = pxRmapCh->xRmapMemConfigArea.uliCurrentMode;
8110751c:	e0bfff17 	ldw	r2,-4(fp)
81107520:	10802317 	ldw	r2,140(r2)
81107524:	e0bffe15 	stw	r2,-8(fp)
//			uliReg &= (~COMM_RMAP_CURRENT_MODE_MSK);
//			uliReg |= (COMM_RMAP_CURRENT_MODE_MSK & (alt_u32)(pxRmapCh->xRmapMemConfigArea.uliCurrentMode. << 0));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_CURRENT_MODE_REG_OFST,
81107528:	e0bfff17 	ldw	r2,-4(fp)
8110752c:	10800017 	ldw	r2,0(r2)
81107530:	e1bffe17 	ldw	r6,-8(fp)
81107534:	01401444 	movi	r5,81
81107538:	1009883a 	mov	r4,r2
8110753c:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
81107540:	00800044 	movi	r2,1
81107544:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81107548:	e0bffd17 	ldw	r2,-12(fp)
}
8110754c:	e037883a 	mov	sp,fp
81107550:	dfc00117 	ldw	ra,4(sp)
81107554:	df000017 	ldw	fp,0(sp)
81107558:	dec00204 	addi	sp,sp,8
8110755c:	f800283a 	ret

81107560 <bRmapGetMemConfigArea>:

bool bRmapGetMemConfigArea(TRmapChannel *pxRmapCh) {
81107560:	defffb04 	addi	sp,sp,-20
81107564:	de00012e 	bgeu	sp,et,8110756c <bRmapGetMemConfigArea+0xc>
81107568:	003b68fa 	trap	3
8110756c:	dfc00415 	stw	ra,16(sp)
81107570:	df000315 	stw	fp,12(sp)
81107574:	df000304 	addi	fp,sp,12
81107578:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
8110757c:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107580:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107584:	e0bfff17 	ldw	r2,-4(fp)
81107588:	1000a426 	beq	r2,zero,8110781c <bRmapGetMemConfigArea+0x2bc>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110758c:	e0bfff17 	ldw	r2,-4(fp)
81107590:	10800017 	ldw	r2,0(r2)
81107594:	01401004 	movi	r5,64
81107598:	1009883a 	mov	r4,r2
8110759c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811075a0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq1Config = uliReg;
811075a4:	e0bfff17 	ldw	r2,-4(fp)
811075a8:	e0fffe17 	ldw	r3,-8(fp)
811075ac:	10c01215 	stw	r3,72(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075b0:	e0bfff17 	ldw	r2,-4(fp)
811075b4:	10800017 	ldw	r2,0(r2)
811075b8:	01401044 	movi	r5,65
811075bc:	1009883a 	mov	r4,r2
811075c0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811075c4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_SEQ_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcdSeq2Config = uliReg;
811075c8:	e0bfff17 	ldw	r2,-4(fp)
811075cc:	e0fffe17 	ldw	r3,-8(fp)
811075d0:	10c01315 	stw	r3,76(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075d4:	e0bfff17 	ldw	r2,-4(fp)
811075d8:	10800017 	ldw	r2,0(r2)
811075dc:	01401084 	movi	r5,66
811075e0:	1009883a 	mov	r4,r2
811075e4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811075e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket1Config = uliReg;
811075ec:	e0bfff17 	ldw	r2,-4(fp)
811075f0:	e0fffe17 	ldw	r3,-8(fp)
811075f4:	10c01415 	stw	r3,80(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811075f8:	e0bfff17 	ldw	r2,-4(fp)
811075fc:	10800017 	ldw	r2,0(r2)
81107600:	014010c4 	movi	r5,67
81107604:	1009883a 	mov	r4,r2
81107608:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110760c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SPW_PKT_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSpwPacket2Config = uliReg;
81107610:	e0bfff17 	ldw	r2,-4(fp)
81107614:	e0fffe17 	ldw	r3,-8(fp)
81107618:	10c01515 	stw	r3,84(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110761c:	e0bfff17 	ldw	r2,-4(fp)
81107620:	10800017 	ldw	r2,0(r2)
81107624:	01401104 	movi	r5,68
81107628:	1009883a 	mov	r4,r2
8110762c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107630:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
81107634:	e0bfff17 	ldw	r2,-4(fp)
81107638:	e0fffe17 	ldw	r3,-8(fp)
8110763c:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107640:	e0bfff17 	ldw	r2,-4(fp)
81107644:	10800017 	ldw	r2,0(r2)
81107648:	01401144 	movi	r5,69
8110764c:	1009883a 	mov	r4,r2
81107650:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107654:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_1_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd1Windowing2Config = uliReg;
81107658:	e0bfff17 	ldw	r2,-4(fp)
8110765c:	e0fffe17 	ldw	r3,-8(fp)
81107660:	10c01715 	stw	r3,92(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107664:	e0bfff17 	ldw	r2,-4(fp)
81107668:	10800017 	ldw	r2,0(r2)
8110766c:	01401184 	movi	r5,70
81107670:	1009883a 	mov	r4,r2
81107674:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107678:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing1Config = uliReg;
8110767c:	e0bfff17 	ldw	r2,-4(fp)
81107680:	e0fffe17 	ldw	r3,-8(fp)
81107684:	10c01815 	stw	r3,96(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107688:	e0bfff17 	ldw	r2,-4(fp)
8110768c:	10800017 	ldw	r2,0(r2)
81107690:	014011c4 	movi	r5,71
81107694:	1009883a 	mov	r4,r2
81107698:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110769c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_2_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd2Windowing2Config = uliReg;
811076a0:	e0bfff17 	ldw	r2,-4(fp)
811076a4:	e0fffe17 	ldw	r3,-8(fp)
811076a8:	10c01915 	stw	r3,100(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076ac:	e0bfff17 	ldw	r2,-4(fp)
811076b0:	10800017 	ldw	r2,0(r2)
811076b4:	01401204 	movi	r5,72
811076b8:	1009883a 	mov	r4,r2
811076bc:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811076c0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing1Config = uliReg;
811076c4:	e0bfff17 	ldw	r2,-4(fp)
811076c8:	e0fffe17 	ldw	r3,-8(fp)
811076cc:	10c01a15 	stw	r3,104(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076d0:	e0bfff17 	ldw	r2,-4(fp)
811076d4:	10800017 	ldw	r2,0(r2)
811076d8:	01401244 	movi	r5,73
811076dc:	1009883a 	mov	r4,r2
811076e0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811076e4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_3_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd3Windowing2Config = uliReg;
811076e8:	e0bfff17 	ldw	r2,-4(fp)
811076ec:	e0fffe17 	ldw	r3,-8(fp)
811076f0:	10c01b15 	stw	r3,108(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811076f4:	e0bfff17 	ldw	r2,-4(fp)
811076f8:	10800017 	ldw	r2,0(r2)
811076fc:	01401284 	movi	r5,74
81107700:	1009883a 	mov	r4,r2
81107704:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107708:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_1_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing1Config = uliReg;
8110770c:	e0bfff17 	ldw	r2,-4(fp)
81107710:	e0fffe17 	ldw	r3,-8(fp)
81107714:	10c01c15 	stw	r3,112(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107718:	e0bfff17 	ldw	r2,-4(fp)
8110771c:	10800017 	ldw	r2,0(r2)
81107720:	014012c4 	movi	r5,75
81107724:	1009883a 	mov	r4,r2
81107728:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110772c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CCD_4_W_2_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCcd4Windowing2Config = uliReg;
81107730:	e0bfff17 	ldw	r2,-4(fp)
81107734:	e0fffe17 	ldw	r3,-8(fp)
81107738:	10c01d15 	stw	r3,116(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110773c:	e0bfff17 	ldw	r2,-4(fp)
81107740:	10800017 	ldw	r2,0(r2)
81107744:	01401304 	movi	r5,76
81107748:	1009883a 	mov	r4,r2
8110774c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107750:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_OP_MODE_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliOperationModeConfig = uliReg;
81107754:	e0bfff17 	ldw	r2,-4(fp)
81107758:	e0fffe17 	ldw	r3,-8(fp)
8110775c:	10c01e15 	stw	r3,120(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107760:	e0bfff17 	ldw	r2,-4(fp)
81107764:	10800017 	ldw	r2,0(r2)
81107768:	01401344 	movi	r5,77
8110776c:	1009883a 	mov	r4,r2
81107770:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107774:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_SYNC_CFG_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliSyncConfig = uliReg;
81107778:	e0bfff17 	ldw	r2,-4(fp)
8110777c:	e0fffe17 	ldw	r3,-8(fp)
81107780:	10c01f15 	stw	r3,124(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107784:	e0bfff17 	ldw	r2,-4(fp)
81107788:	10800017 	ldw	r2,0(r2)
8110778c:	01401384 	movi	r5,78
81107790:	1009883a 	mov	r4,r2
81107794:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107798:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_DAC_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliDacControl = uliReg;
8110779c:	e0bfff17 	ldw	r2,-4(fp)
811077a0:	e0fffe17 	ldw	r3,-8(fp)
811077a4:	10c02015 	stw	r3,128(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077a8:	e0bfff17 	ldw	r2,-4(fp)
811077ac:	10800017 	ldw	r2,0(r2)
811077b0:	014013c4 	movi	r5,79
811077b4:	1009883a 	mov	r4,r2
811077b8:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811077bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CLK_SRCE_CTRL_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811077c0:	e0bfff17 	ldw	r2,-4(fp)
811077c4:	e0fffe17 	ldw	r3,-8(fp)
811077c8:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077cc:	e0bfff17 	ldw	r2,-4(fp)
811077d0:	10800017 	ldw	r2,0(r2)
811077d4:	01401404 	movi	r5,80
811077d8:	1009883a 	mov	r4,r2
811077dc:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811077e0:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_FRAME_NUMBER_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliFrameNumber = uliReg;
811077e4:	e0bfff17 	ldw	r2,-4(fp)
811077e8:	e0fffe17 	ldw	r3,-8(fp)
811077ec:	10c02215 	stw	r3,136(r2)

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811077f0:	e0bfff17 	ldw	r2,-4(fp)
811077f4:	10800017 	ldw	r2,0(r2)
811077f8:	01401444 	movi	r5,81
811077fc:	1009883a 	mov	r4,r2
81107800:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107804:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_CURRENT_MODE_REG_OFST);
		pxRmapCh->xRmapMemConfigArea.uliCurrentMode = uliReg;
81107808:	e0bfff17 	ldw	r2,-4(fp)
8110780c:	e0fffe17 	ldw	r3,-8(fp)
81107810:	10c02315 	stw	r3,140(r2)

		bStatus = TRUE;
81107814:	00800044 	movi	r2,1
81107818:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110781c:	e0bffd17 	ldw	r2,-12(fp)
}
81107820:	e037883a 	mov	sp,fp
81107824:	dfc00117 	ldw	ra,4(sp)
81107828:	df000017 	ldw	fp,0(sp)
8110782c:	dec00204 	addi	sp,sp,8
81107830:	f800283a 	ret

81107834 <bRmapGetMemConfigStat>:

bool bRmapGetMemConfigStat(TRmapChannel *pxRmapCh) {
81107834:	defffb04 	addi	sp,sp,-20
81107838:	de00012e 	bgeu	sp,et,81107840 <bRmapGetMemConfigStat+0xc>
8110783c:	003b68fa 	trap	3
81107840:	dfc00415 	stw	ra,16(sp)
81107844:	df000315 	stw	fp,12(sp)
81107848:	df000304 	addi	fp,sp,12
8110784c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81107850:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81107854:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81107858:	e0bfff17 	ldw	r2,-4(fp)
8110785c:	10001426 	beq	r2,zero,811078b0 <bRmapGetMemConfigStat+0x7c>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107860:	e0bfff17 	ldw	r2,-4(fp)
81107864:	10800017 	ldw	r2,0(r2)
81107868:	014001c4 	movi	r5,7
8110786c:	1009883a 	mov	r4,r2
81107870:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107874:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_RD_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastReadAddress = (alt_u32) ((uliReg
81107878:	e0bfff17 	ldw	r2,-4(fp)
8110787c:	e0fffe17 	ldw	r3,-8(fp)
81107880:	10c02515 	stw	r3,148(r2)
				& COMM_RMAP_LST_RD_ADDR_MSK) >> 0);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107884:	e0bfff17 	ldw	r2,-4(fp)
81107888:	10800017 	ldw	r2,0(r2)
8110788c:	01400184 	movi	r5,6
81107890:	1009883a 	mov	r4,r2
81107894:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107898:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_LST_WR_ADDR_REG_OFST);

		pxRmapCh->xRmapMemConfigStat.uliLastWriteAddress = (alt_u32) ((uliReg
8110789c:	e0bfff17 	ldw	r2,-4(fp)
811078a0:	e0fffe17 	ldw	r3,-8(fp)
811078a4:	10c02415 	stw	r3,144(r2)
				& COMM_RMAP_LST_WR_ADDR_MSK) >> 0);

		bStatus = TRUE;
811078a8:	00800044 	movi	r2,1
811078ac:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811078b0:	e0bffd17 	ldw	r2,-12(fp)
}
811078b4:	e037883a 	mov	sp,fp
811078b8:	dfc00117 	ldw	ra,4(sp)
811078bc:	df000017 	ldw	fp,0(sp)
811078c0:	dec00204 	addi	sp,sp,8
811078c4:	f800283a 	ret

811078c8 <bRmapSetRmapMemHKArea>:

bool bRmapSetRmapMemHKArea(TRmapChannel *pxRmapCh) {
811078c8:	defffb04 	addi	sp,sp,-20
811078cc:	de00012e 	bgeu	sp,et,811078d4 <bRmapSetRmapMemHKArea+0xc>
811078d0:	003b68fa 	trap	3
811078d4:	dfc00415 	stw	ra,16(sp)
811078d8:	df000315 	stw	fp,12(sp)
811078dc:	df000304 	addi	fp,sp,12
811078e0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811078e4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811078e8:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
811078ec:	e0bfff17 	ldw	r2,-4(fp)
811078f0:	10030226 	beq	r2,zero,811084fc <bRmapSetRmapMemHKArea+0xc34>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811078f4:	e0bfff17 	ldw	r2,-4(fp)
811078f8:	10800017 	ldw	r2,0(r2)
811078fc:	01402804 	movi	r5,160
81107900:	1009883a 	mov	r4,r2
81107904:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107908:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
8110790c:	e0bffe17 	ldw	r2,-8(fp)
81107910:	10bfffec 	andhi	r2,r2,65535
81107914:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
81107918:	e0bfff17 	ldw	r2,-4(fp)
8110791c:	1080260b 	ldhu	r2,152(r2)
81107920:	10bfffcc 	andi	r2,r2,65535
	if (pxRmapCh != NULL) {

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_E_MSK
81107924:	e0fffe17 	ldw	r3,-8(fp)
81107928:	1884b03a 	or	r2,r3,r2
8110792c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD1_VOD_F_MSK);
81107930:	e0bffe17 	ldw	r2,-8(fp)
81107934:	10bfffcc 	andi	r2,r2,65535
81107938:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_0_REG_OFST,
8110793c:	e0bfff17 	ldw	r2,-4(fp)
81107940:	10800017 	ldw	r2,0(r2)
81107944:	e1bffe17 	ldw	r6,-8(fp)
81107948:	01402804 	movi	r5,160
8110794c:	1009883a 	mov	r4,r2
81107950:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107954:	e0bfff17 	ldw	r2,-4(fp)
81107958:	10800017 	ldw	r2,0(r2)
8110795c:	01402844 	movi	r5,161
81107960:	1009883a 	mov	r4,r2
81107964:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107968:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
8110796c:	e0bffe17 	ldw	r2,-8(fp)
81107970:	10bfffec 	andhi	r2,r2,65535
81107974:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
81107978:	e0bfff17 	ldw	r2,-4(fp)
8110797c:	1080270b 	ldhu	r2,156(r2)
81107980:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_VRD_MON_MSK
81107984:	e0fffe17 	ldw	r3,-8(fp)
81107988:	1884b03a 	or	r2,r3,r2
8110798c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_E_MSK);
81107990:	e0bffe17 	ldw	r2,-8(fp)
81107994:	10bfffcc 	andi	r2,r2,65535
81107998:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_1_REG_OFST,
8110799c:	e0bfff17 	ldw	r2,-4(fp)
811079a0:	10800017 	ldw	r2,0(r2)
811079a4:	e1bffe17 	ldw	r6,-8(fp)
811079a8:	01402844 	movi	r5,161
811079ac:	1009883a 	mov	r4,r2
811079b0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811079b4:	e0bfff17 	ldw	r2,-4(fp)
811079b8:	10800017 	ldw	r2,0(r2)
811079bc:	01402884 	movi	r5,162
811079c0:	1009883a 	mov	r4,r2
811079c4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811079c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
811079cc:	e0bffe17 	ldw	r2,-8(fp)
811079d0:	10bfffec 	andhi	r2,r2,65535
811079d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
811079d8:	e0bfff17 	ldw	r2,-4(fp)
811079dc:	1080280b 	ldhu	r2,160(r2)
811079e0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD2_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD2_VOD_F_MSK
811079e4:	e0fffe17 	ldw	r3,-8(fp)
811079e8:	1884b03a 	or	r2,r3,r2
811079ec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_VRD_MON_MSK);
811079f0:	e0bffe17 	ldw	r2,-8(fp)
811079f4:	10bfffcc 	andi	r2,r2,65535
811079f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_2_REG_OFST,
811079fc:	e0bfff17 	ldw	r2,-4(fp)
81107a00:	10800017 	ldw	r2,0(r2)
81107a04:	e1bffe17 	ldw	r6,-8(fp)
81107a08:	01402884 	movi	r5,162
81107a0c:	1009883a 	mov	r4,r2
81107a10:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a14:	e0bfff17 	ldw	r2,-4(fp)
81107a18:	10800017 	ldw	r2,0(r2)
81107a1c:	014028c4 	movi	r5,163
81107a20:	1009883a 	mov	r4,r2
81107a24:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107a28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
81107a2c:	e0bffe17 	ldw	r2,-8(fp)
81107a30:	10bfffec 	andhi	r2,r2,65535
81107a34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
81107a38:	e0bfff17 	ldw	r2,-4(fp)
81107a3c:	1080290b 	ldhu	r2,164(r2)
81107a40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_E_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_E_MSK
81107a44:	e0fffe17 	ldw	r3,-8(fp)
81107a48:	1884b03a 	or	r2,r3,r2
81107a4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD3_VOD_F_MSK);
81107a50:	e0bffe17 	ldw	r2,-8(fp)
81107a54:	10bfffcc 	andi	r2,r2,65535
81107a58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_3_REG_OFST,
81107a5c:	e0bfff17 	ldw	r2,-4(fp)
81107a60:	10800017 	ldw	r2,0(r2)
81107a64:	e1bffe17 	ldw	r6,-8(fp)
81107a68:	014028c4 	movi	r5,163
81107a6c:	1009883a 	mov	r4,r2
81107a70:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107a74:	e0bfff17 	ldw	r2,-4(fp)
81107a78:	10800017 	ldw	r2,0(r2)
81107a7c:	01402904 	movi	r5,164
81107a80:	1009883a 	mov	r4,r2
81107a84:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107a88:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
81107a8c:	e0bffe17 	ldw	r2,-8(fp)
81107a90:	10bfffec 	andhi	r2,r2,65535
81107a94:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
81107a98:	e0bfff17 	ldw	r2,-4(fp)
81107a9c:	10802a0b 	ldhu	r2,168(r2)
81107aa0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_VRD_MON_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_VRD_MON_MSK
81107aa4:	e0fffe17 	ldw	r3,-8(fp)
81107aa8:	1884b03a 	or	r2,r3,r2
81107aac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_E_MSK);
81107ab0:	e0bffe17 	ldw	r2,-8(fp)
81107ab4:	10bfffcc 	andi	r2,r2,65535
81107ab8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_4_REG_OFST,
81107abc:	e0bfff17 	ldw	r2,-4(fp)
81107ac0:	10800017 	ldw	r2,0(r2)
81107ac4:	e1bffe17 	ldw	r6,-8(fp)
81107ac8:	01402904 	movi	r5,164
81107acc:	1009883a 	mov	r4,r2
81107ad0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ad4:	e0bfff17 	ldw	r2,-4(fp)
81107ad8:	10800017 	ldw	r2,0(r2)
81107adc:	01402944 	movi	r5,165
81107ae0:	1009883a 	mov	r4,r2
81107ae4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107ae8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
81107aec:	e0bffe17 	ldw	r2,-8(fp)
81107af0:	10bfffec 	andhi	r2,r2,65535
81107af4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
81107af8:	e0bfff17 	ldw	r2,-4(fp)
81107afc:	10802b0b 	ldhu	r2,172(r2)
81107b00:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD4_VOD_F_MSK);
		uliReg |= (COMM_RMAP_HK_CCD4_VOD_F_MSK
81107b04:	e0fffe17 	ldw	r3,-8(fp)
81107b08:	1884b03a 	or	r2,r3,r2
81107b0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_VRD_MON_MSK);
81107b10:	e0bffe17 	ldw	r2,-8(fp)
81107b14:	10bfffcc 	andi	r2,r2,65535
81107b18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_VRD_MON_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_5_REG_OFST,
81107b1c:	e0bfff17 	ldw	r2,-4(fp)
81107b20:	10800017 	ldw	r2,0(r2)
81107b24:	e1bffe17 	ldw	r6,-8(fp)
81107b28:	01402944 	movi	r5,165
81107b2c:	1009883a 	mov	r4,r2
81107b30:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b34:	e0bfff17 	ldw	r2,-4(fp)
81107b38:	10800017 	ldw	r2,0(r2)
81107b3c:	01402984 	movi	r5,166
81107b40:	1009883a 	mov	r4,r2
81107b44:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107b48:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
81107b4c:	e0bffe17 	ldw	r2,-8(fp)
81107b50:	10bfffec 	andhi	r2,r2,65535
81107b54:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
81107b58:	e0bfff17 	ldw	r2,-4(fp)
81107b5c:	10802c0b 	ldhu	r2,176(r2)
81107b60:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_MSK
81107b64:	e0fffe17 	ldw	r3,-8(fp)
81107b68:	1884b03a 	or	r2,r3,r2
81107b6c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccd >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_MSK);
81107b70:	e0bffe17 	ldw	r2,-8(fp)
81107b74:	10bfffcc 	andi	r2,r2,65535
81107b78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclk >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_6_REG_OFST,
81107b7c:	e0bfff17 	ldw	r2,-4(fp)
81107b80:	10800017 	ldw	r2,0(r2)
81107b84:	e1bffe17 	ldw	r6,-8(fp)
81107b88:	01402984 	movi	r5,166
81107b8c:	1009883a 	mov	r4,r2
81107b90:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107b94:	e0bfff17 	ldw	r2,-4(fp)
81107b98:	10800017 	ldw	r2,0(r2)
81107b9c:	014029c4 	movi	r5,167
81107ba0:	1009883a 	mov	r4,r2
81107ba4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107ba8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
81107bac:	e0bffe17 	ldw	r2,-8(fp)
81107bb0:	10bfffec 	andhi	r2,r2,65535
81107bb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
81107bb8:	e0bfff17 	ldw	r2,-4(fp)
81107bbc:	10802d0b 	ldhu	r2,180(r2)
81107bc0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VICLK_MSK);
		uliReg |= (COMM_RMAP_HK_VICLK_MSK
81107bc4:	e0fffe17 	ldw	r3,-8(fp)
81107bc8:	1884b03a 	or	r2,r3,r2
81107bcc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclk >> 0));
		uliReg &= (~COMM_RMAP_HK_VRCLK_LOW_MSK);
81107bd0:	e0bffe17 	ldw	r2,-8(fp)
81107bd4:	10bfffcc 	andi	r2,r2,65535
81107bd8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VRCLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVrclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_7_REG_OFST,
81107bdc:	e0bfff17 	ldw	r2,-4(fp)
81107be0:	10800017 	ldw	r2,0(r2)
81107be4:	e1bffe17 	ldw	r6,-8(fp)
81107be8:	014029c4 	movi	r5,167
81107bec:	1009883a 	mov	r4,r2
81107bf0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107bf4:	e0bfff17 	ldw	r2,-4(fp)
81107bf8:	10800017 	ldw	r2,0(r2)
81107bfc:	01402a04 	movi	r5,168
81107c00:	1009883a 	mov	r4,r2
81107c04:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107c08:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
81107c0c:	e0bffe17 	ldw	r2,-8(fp)
81107c10:	10bfffec 	andhi	r2,r2,65535
81107c14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
81107c18:	e0bfff17 	ldw	r2,-4(fp)
81107c1c:	10802e0b 	ldhu	r2,184(r2)
81107c20:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_5VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_5VB_POS_MSK
81107c24:	e0fffe17 	ldw	r3,-8(fp)
81107c28:	1884b03a 	or	r2,r3,r2
81107c2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VB_NEG_MSK);
81107c30:	e0bffe17 	ldw	r2,-8(fp)
81107c34:	10bfffcc 	andi	r2,r2,65535
81107c38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VB_NEG_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vbNeg >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_8_REG_OFST,
81107c3c:	e0bfff17 	ldw	r2,-4(fp)
81107c40:	10800017 	ldw	r2,0(r2)
81107c44:	e1bffe17 	ldw	r6,-8(fp)
81107c48:	01402a04 	movi	r5,168
81107c4c:	1009883a 	mov	r4,r2
81107c50:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107c54:	e0bfff17 	ldw	r2,-4(fp)
81107c58:	10800017 	ldw	r2,0(r2)
81107c5c:	01402a44 	movi	r5,169
81107c60:	1009883a 	mov	r4,r2
81107c64:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107c68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
81107c6c:	e0bffe17 	ldw	r2,-8(fp)
81107c70:	10bfffec 	andhi	r2,r2,65535
81107c74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
81107c78:	e0bfff17 	ldw	r2,-4(fp)
81107c7c:	10802f0b 	ldhu	r2,188(r2)
81107c80:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VB_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VB_POS_MSK
81107c84:	e0fffe17 	ldw	r3,-8(fp)
81107c88:	1884b03a 	or	r2,r3,r2
81107c8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vbPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VA_POS_MSK);
81107c90:	e0bffe17 	ldw	r2,-8(fp)
81107c94:	10bfffcc 	andi	r2,r2,65535
81107c98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VA_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vaPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_9_REG_OFST,
81107c9c:	e0bfff17 	ldw	r2,-4(fp)
81107ca0:	10800017 	ldw	r2,0(r2)
81107ca4:	e1bffe17 	ldw	r6,-8(fp)
81107ca8:	01402a44 	movi	r5,169
81107cac:	1009883a 	mov	r4,r2
81107cb0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107cb4:	e0bfff17 	ldw	r2,-4(fp)
81107cb8:	10800017 	ldw	r2,0(r2)
81107cbc:	01402a84 	movi	r5,170
81107cc0:	1009883a 	mov	r4,r2
81107cc4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107cc8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
81107ccc:	e0bffe17 	ldw	r2,-8(fp)
81107cd0:	10bfffec 	andhi	r2,r2,65535
81107cd4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
81107cd8:	e0bfff17 	ldw	r2,-4(fp)
81107cdc:	1080300b 	ldhu	r2,192(r2)
81107ce0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_3_3VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_3_3VD_POS_MSK
81107ce4:	e0fffe17 	ldw	r3,-8(fp)
81107ce8:	1884b03a 	or	r2,r3,r2
81107cec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk33vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_2_5VD_POS_MSK);
81107cf0:	e0bffe17 	ldw	r2,-8(fp)
81107cf4:	10bfffcc 	andi	r2,r2,65535
81107cf8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_2_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk25vdPos >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_10_REG_OFST,
81107cfc:	e0bfff17 	ldw	r2,-4(fp)
81107d00:	10800017 	ldw	r2,0(r2)
81107d04:	e1bffe17 	ldw	r6,-8(fp)
81107d08:	01402a84 	movi	r5,170
81107d0c:	1009883a 	mov	r4,r2
81107d10:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d14:	e0bfff17 	ldw	r2,-4(fp)
81107d18:	10800017 	ldw	r2,0(r2)
81107d1c:	01402ac4 	movi	r5,171
81107d20:	1009883a 	mov	r4,r2
81107d24:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107d28:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
81107d2c:	e0bffe17 	ldw	r2,-8(fp)
81107d30:	10bfffec 	andhi	r2,r2,65535
81107d34:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
81107d38:	e0bfff17 	ldw	r2,-4(fp)
81107d3c:	1080310b 	ldhu	r2,196(r2)
81107d40:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_1_5VD_POS_MSK);
		uliReg |= (COMM_RMAP_HK_1_5VD_POS_MSK
81107d44:	e0fffe17 	ldw	r3,-8(fp)
81107d48:	1884b03a 	or	r2,r3,r2
81107d4c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk15vdPos >> 0));
		uliReg &= (~COMM_RMAP_HK_5VREF_MSK);
81107d50:	e0bffe17 	ldw	r2,-8(fp)
81107d54:	10bfffcc 	andi	r2,r2,65535
81107d58:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_5VREF_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHk5vref >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_11_REG_OFST,
81107d5c:	e0bfff17 	ldw	r2,-4(fp)
81107d60:	10800017 	ldw	r2,0(r2)
81107d64:	e1bffe17 	ldw	r6,-8(fp)
81107d68:	01402ac4 	movi	r5,171
81107d6c:	1009883a 	mov	r4,r2
81107d70:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107d74:	e0bfff17 	ldw	r2,-4(fp)
81107d78:	10800017 	ldw	r2,0(r2)
81107d7c:	01402b04 	movi	r5,172
81107d80:	1009883a 	mov	r4,r2
81107d84:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107d88:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
81107d8c:	e0bffe17 	ldw	r2,-8(fp)
81107d90:	10bfffec 	andhi	r2,r2,65535
81107d94:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
81107d98:	e0bfff17 	ldw	r2,-4(fp)
81107d9c:	1080320b 	ldhu	r2,200(r2)
81107da0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VCCD_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VCCD_POS_RAW_MSK
81107da4:	e0fffe17 	ldw	r3,-8(fp)
81107da8:	1884b03a 	or	r2,r3,r2
81107dac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VCLK_POS_RAW_MSK);
81107db0:	e0bffe17 	ldw	r2,-8(fp)
81107db4:	10bfffcc 	andi	r2,r2,65535
81107db8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VCLK_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_12_REG_OFST,
81107dbc:	e0bfff17 	ldw	r2,-4(fp)
81107dc0:	10800017 	ldw	r2,0(r2)
81107dc4:	e1bffe17 	ldw	r6,-8(fp)
81107dc8:	01402b04 	movi	r5,172
81107dcc:	1009883a 	mov	r4,r2
81107dd0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107dd4:	e0bfff17 	ldw	r2,-4(fp)
81107dd8:	10800017 	ldw	r2,0(r2)
81107ddc:	01402b44 	movi	r5,173
81107de0:	1009883a 	mov	r4,r2
81107de4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107de8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
81107dec:	e0bffe17 	ldw	r2,-8(fp)
81107df0:	10bfffec 	andhi	r2,r2,65535
81107df4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
81107df8:	e0bfff17 	ldw	r2,-4(fp)
81107dfc:	1080330b 	ldhu	r2,204(r2)
81107e00:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN1_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN1_POS_RAW_MSK
81107e04:	e0fffe17 	ldw	r3,-8(fp)
81107e08:	1884b03a 	or	r2,r3,r2
81107e0c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VAN3_NEG_RAW_MSK);
81107e10:	e0bffe17 	ldw	r2,-8(fp)
81107e14:	10bfffcc 	andi	r2,r2,65535
81107e18:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN3_NEG_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_13_REG_OFST,
81107e1c:	e0bfff17 	ldw	r2,-4(fp)
81107e20:	10800017 	ldw	r2,0(r2)
81107e24:	e1bffe17 	ldw	r6,-8(fp)
81107e28:	01402b44 	movi	r5,173
81107e2c:	1009883a 	mov	r4,r2
81107e30:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e34:	e0bfff17 	ldw	r2,-4(fp)
81107e38:	10800017 	ldw	r2,0(r2)
81107e3c:	01402b84 	movi	r5,174
81107e40:	1009883a 	mov	r4,r2
81107e44:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107e48:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
81107e4c:	e0bffe17 	ldw	r2,-8(fp)
81107e50:	10bfffec 	andhi	r2,r2,65535
81107e54:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
81107e58:	e0bfff17 	ldw	r2,-4(fp)
81107e5c:	1080340b 	ldhu	r2,208(r2)
81107e60:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VAN2_POS_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VAN2_POS_RAW_MSK
81107e64:	e0fffe17 	ldw	r3,-8(fp)
81107e68:	1884b03a 	or	r2,r3,r2
81107e6c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VDIG_FPGA_RAW_MSK);
81107e70:	e0bffe17 	ldw	r2,-8(fp)
81107e74:	10bfffcc 	andi	r2,r2,65535
81107e78:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_FPGA_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_14_REG_OFST,
81107e7c:	e0bfff17 	ldw	r2,-4(fp)
81107e80:	10800017 	ldw	r2,0(r2)
81107e84:	e1bffe17 	ldw	r6,-8(fp)
81107e88:	01402b84 	movi	r5,174
81107e8c:	1009883a 	mov	r4,r2
81107e90:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107e94:	e0bfff17 	ldw	r2,-4(fp)
81107e98:	10800017 	ldw	r2,0(r2)
81107e9c:	01402bc4 	movi	r5,175
81107ea0:	1009883a 	mov	r4,r2
81107ea4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107ea8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
81107eac:	e0bffe17 	ldw	r2,-8(fp)
81107eb0:	10bfffec 	andhi	r2,r2,65535
81107eb4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
81107eb8:	e0bfff17 	ldw	r2,-4(fp)
81107ebc:	1080350b 	ldhu	r2,212(r2)
81107ec0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_VDIG_SPW_RAW_MSK);
		uliReg |= (COMM_RMAP_HK_VDIG_SPW_RAW_MSK
81107ec4:	e0fffe17 	ldw	r3,-8(fp)
81107ec8:	1884b03a 	or	r2,r3,r2
81107ecc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw >> 0));
		uliReg &= (~COMM_RMAP_HK_VICLK_LOW_MSK);
81107ed0:	e0bffe17 	ldw	r2,-8(fp)
81107ed4:	10bfffcc 	andi	r2,r2,65535
81107ed8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_VICLK_LOW_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkViclkLow >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_15_REG_OFST,
81107edc:	e0bfff17 	ldw	r2,-4(fp)
81107ee0:	10800017 	ldw	r2,0(r2)
81107ee4:	e1bffe17 	ldw	r6,-8(fp)
81107ee8:	01402bc4 	movi	r5,175
81107eec:	1009883a 	mov	r4,r2
81107ef0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107ef4:	e0bfff17 	ldw	r2,-4(fp)
81107ef8:	10800017 	ldw	r2,0(r2)
81107efc:	01402c04 	movi	r5,176
81107f00:	1009883a 	mov	r4,r2
81107f04:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107f08:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
81107f0c:	e0bffe17 	ldw	r2,-8(fp)
81107f10:	10bfffec 	andhi	r2,r2,65535
81107f14:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
81107f18:	e0bfff17 	ldw	r2,-4(fp)
81107f1c:	1080360b 	ldhu	r2,216(r2)
81107f20:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_E_MSK);
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_E_MSK
81107f24:	e0fffe17 	ldw	r3,-8(fp)
81107f28:	1884b03a 	or	r2,r3,r2
81107f2c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE >> 0));
		uliReg &= (~COMM_RMAP_HK_ADC_TEMP_A_F_MSK);
81107f30:	e0bffe17 	ldw	r2,-8(fp)
81107f34:	10bfffcc 	andi	r2,r2,65535
81107f38:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_ADC_TEMP_A_F_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_16_REG_OFST,
81107f3c:	e0bfff17 	ldw	r2,-4(fp)
81107f40:	10800017 	ldw	r2,0(r2)
81107f44:	e1bffe17 	ldw	r6,-8(fp)
81107f48:	01402c04 	movi	r5,176
81107f4c:	1009883a 	mov	r4,r2
81107f50:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107f54:	e0bfff17 	ldw	r2,-4(fp)
81107f58:	10800017 	ldw	r2,0(r2)
81107f5c:	01402c44 	movi	r5,177
81107f60:	1009883a 	mov	r4,r2
81107f64:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107f68:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
81107f6c:	e0bffe17 	ldw	r2,-8(fp)
81107f70:	10bfffec 	andhi	r2,r2,65535
81107f74:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
81107f78:	e0bfff17 	ldw	r2,-4(fp)
81107f7c:	1080370b 	ldhu	r2,220(r2)
81107f80:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD1_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD1_TEMP_MSK
81107f84:	e0fffe17 	ldw	r3,-8(fp)
81107f88:	1884b03a 	or	r2,r3,r2
81107f8c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD2_TEMP_MSK);
81107f90:	e0bffe17 	ldw	r2,-8(fp)
81107f94:	10bfffcc 	andi	r2,r2,65535
81107f98:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD2_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_17_REG_OFST,
81107f9c:	e0bfff17 	ldw	r2,-4(fp)
81107fa0:	10800017 	ldw	r2,0(r2)
81107fa4:	e1bffe17 	ldw	r6,-8(fp)
81107fa8:	01402c44 	movi	r5,177
81107fac:	1009883a 	mov	r4,r2
81107fb0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81107fb4:	e0bfff17 	ldw	r2,-4(fp)
81107fb8:	10800017 	ldw	r2,0(r2)
81107fbc:	01402c84 	movi	r5,178
81107fc0:	1009883a 	mov	r4,r2
81107fc4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81107fc8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
81107fcc:	e0bffe17 	ldw	r2,-8(fp)
81107fd0:	10bfffec 	andhi	r2,r2,65535
81107fd4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
81107fd8:	e0bfff17 	ldw	r2,-4(fp)
81107fdc:	1080380b 	ldhu	r2,224(r2)
81107fe0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_CCD3_TEMP_MSK);
		uliReg |= (COMM_RMAP_HK_CCD3_TEMP_MSK
81107fe4:	e0fffe17 	ldw	r3,-8(fp)
81107fe8:	1884b03a 	or	r2,r3,r2
81107fec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp >> 0));
		uliReg &= (~COMM_RMAP_HK_CCD4_TEMP_MSK);
81107ff0:	e0bffe17 	ldw	r2,-8(fp)
81107ff4:	10bfffcc 	andi	r2,r2,65535
81107ff8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_CCD4_TEMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_18_REG_OFST,
81107ffc:	e0bfff17 	ldw	r2,-4(fp)
81108000:	10800017 	ldw	r2,0(r2)
81108004:	e1bffe17 	ldw	r6,-8(fp)
81108008:	01402c84 	movi	r5,178
8110800c:	1009883a 	mov	r4,r2
81108010:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108014:	e0bfff17 	ldw	r2,-4(fp)
81108018:	10800017 	ldw	r2,0(r2)
8110801c:	01402cc4 	movi	r5,179
81108020:	1009883a 	mov	r4,r2
81108024:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108028:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
8110802c:	e0bffe17 	ldw	r2,-8(fp)
81108030:	10bfffec 	andhi	r2,r2,65535
81108034:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
81108038:	e0bfff17 	ldw	r2,-4(fp)
8110803c:	1080390b 	ldhu	r2,228(r2)
81108040:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		uliReg &= (~COMM_RMAP_HK_WP605_SPARE_MSK);
		uliReg |= (COMM_RMAP_HK_WP605_SPARE_MSK
81108044:	e0fffe17 	ldw	r3,-8(fp)
81108048:	1884b03a 	or	r2,r3,r2
8110804c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiHkWp605Spare >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_0_MSK);
81108050:	e0bffe17 	ldw	r2,-8(fp)
81108054:	10bfffcc 	andi	r2,r2,65535
81108058:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_19_REG_OFST,
8110805c:	e0bfff17 	ldw	r2,-4(fp)
81108060:	10800017 	ldw	r2,0(r2)
81108064:	e1bffe17 	ldw	r6,-8(fp)
81108068:	01402cc4 	movi	r5,179
8110806c:	1009883a 	mov	r4,r2
81108070:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108074:	e0bfff17 	ldw	r2,-4(fp)
81108078:	10800017 	ldw	r2,0(r2)
8110807c:	01402d04 	movi	r5,180
81108080:	1009883a 	mov	r4,r2
81108084:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108088:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
8110808c:	e0bffe17 	ldw	r2,-8(fp)
81108090:	10bfffec 	andhi	r2,r2,65535
81108094:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
81108098:	e0bfff17 	ldw	r2,-4(fp)
8110809c:	10803a0b 	ldhu	r2,232(r2)
811080a0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_1_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_1_MSK
811080a4:	e0fffe17 	ldw	r3,-8(fp)
811080a8:	1884b03a 	or	r2,r3,r2
811080ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_2_MSK);
811080b0:	e0bffe17 	ldw	r2,-8(fp)
811080b4:	10bfffcc 	andi	r2,r2,65535
811080b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_20_REG_OFST,
811080bc:	e0bfff17 	ldw	r2,-4(fp)
811080c0:	10800017 	ldw	r2,0(r2)
811080c4:	e1bffe17 	ldw	r6,-8(fp)
811080c8:	01402d04 	movi	r5,180
811080cc:	1009883a 	mov	r4,r2
811080d0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811080d4:	e0bfff17 	ldw	r2,-4(fp)
811080d8:	10800017 	ldw	r2,0(r2)
811080dc:	01402d44 	movi	r5,181
811080e0:	1009883a 	mov	r4,r2
811080e4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811080e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
811080ec:	e0bffe17 	ldw	r2,-8(fp)
811080f0:	10bfffec 	andhi	r2,r2,65535
811080f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
811080f8:	e0bfff17 	ldw	r2,-4(fp)
811080fc:	10803b0b 	ldhu	r2,236(r2)
81108100:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_3_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_3_MSK
81108104:	e0fffe17 	ldw	r3,-8(fp)
81108108:	1884b03a 	or	r2,r3,r2
8110810c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_4_MSK);
81108110:	e0bffe17 	ldw	r2,-8(fp)
81108114:	10bfffcc 	andi	r2,r2,65535
81108118:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_21_REG_OFST,
8110811c:	e0bfff17 	ldw	r2,-4(fp)
81108120:	10800017 	ldw	r2,0(r2)
81108124:	e1bffe17 	ldw	r6,-8(fp)
81108128:	01402d44 	movi	r5,181
8110812c:	1009883a 	mov	r4,r2
81108130:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108134:	e0bfff17 	ldw	r2,-4(fp)
81108138:	10800017 	ldw	r2,0(r2)
8110813c:	01402d84 	movi	r5,182
81108140:	1009883a 	mov	r4,r2
81108144:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108148:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
8110814c:	e0bffe17 	ldw	r2,-8(fp)
81108150:	10bfffec 	andhi	r2,r2,65535
81108154:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
81108158:	e0bfff17 	ldw	r2,-4(fp)
8110815c:	10803c0b 	ldhu	r2,240(r2)
81108160:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_5_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_5_MSK
81108164:	e0fffe17 	ldw	r3,-8(fp)
81108168:	1884b03a 	or	r2,r3,r2
8110816c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_6_MSK);
81108170:	e0bffe17 	ldw	r2,-8(fp)
81108174:	10bfffcc 	andi	r2,r2,65535
81108178:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_22_REG_OFST,
8110817c:	e0bfff17 	ldw	r2,-4(fp)
81108180:	10800017 	ldw	r2,0(r2)
81108184:	e1bffe17 	ldw	r6,-8(fp)
81108188:	01402d84 	movi	r5,182
8110818c:	1009883a 	mov	r4,r2
81108190:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108194:	e0bfff17 	ldw	r2,-4(fp)
81108198:	10800017 	ldw	r2,0(r2)
8110819c:	01402dc4 	movi	r5,183
811081a0:	1009883a 	mov	r4,r2
811081a4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811081a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
811081ac:	e0bffe17 	ldw	r2,-8(fp)
811081b0:	10bfffec 	andhi	r2,r2,65535
811081b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
811081b8:	e0bfff17 	ldw	r2,-4(fp)
811081bc:	10803d0b 	ldhu	r2,244(r2)
811081c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_7_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_7_MSK
811081c4:	e0fffe17 	ldw	r3,-8(fp)
811081c8:	1884b03a 	or	r2,r3,r2
811081cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_8_MSK);
811081d0:	e0bffe17 	ldw	r2,-8(fp)
811081d4:	10bfffcc 	andi	r2,r2,65535
811081d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_8_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_23_REG_OFST,
811081dc:	e0bfff17 	ldw	r2,-4(fp)
811081e0:	10800017 	ldw	r2,0(r2)
811081e4:	e1bffe17 	ldw	r6,-8(fp)
811081e8:	01402dc4 	movi	r5,183
811081ec:	1009883a 	mov	r4,r2
811081f0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811081f4:	e0bfff17 	ldw	r2,-4(fp)
811081f8:	10800017 	ldw	r2,0(r2)
811081fc:	01402e04 	movi	r5,184
81108200:	1009883a 	mov	r4,r2
81108204:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108208:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
8110820c:	e0bffe17 	ldw	r2,-8(fp)
81108210:	10bfffec 	andhi	r2,r2,65535
81108214:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
81108218:	e0bfff17 	ldw	r2,-4(fp)
8110821c:	10803e0b 	ldhu	r2,248(r2)
81108220:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_9_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_9_MSK
81108224:	e0fffe17 	ldw	r3,-8(fp)
81108228:	1884b03a 	or	r2,r3,r2
8110822c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_10_MSK);
81108230:	e0bffe17 	ldw	r2,-8(fp)
81108234:	10bfffcc 	andi	r2,r2,65535
81108238:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_10_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_24_REG_OFST,
8110823c:	e0bfff17 	ldw	r2,-4(fp)
81108240:	10800017 	ldw	r2,0(r2)
81108244:	e1bffe17 	ldw	r6,-8(fp)
81108248:	01402e04 	movi	r5,184
8110824c:	1009883a 	mov	r4,r2
81108250:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108254:	e0bfff17 	ldw	r2,-4(fp)
81108258:	10800017 	ldw	r2,0(r2)
8110825c:	01402e44 	movi	r5,185
81108260:	1009883a 	mov	r4,r2
81108264:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108268:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
8110826c:	e0bffe17 	ldw	r2,-8(fp)
81108270:	10bfffec 	andhi	r2,r2,65535
81108274:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
81108278:	e0bfff17 	ldw	r2,-4(fp)
8110827c:	10803f0b 	ldhu	r2,252(r2)
81108280:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_11_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_11_MSK
81108284:	e0fffe17 	ldw	r3,-8(fp)
81108288:	1884b03a 	or	r2,r3,r2
8110828c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_12_MSK);
81108290:	e0bffe17 	ldw	r2,-8(fp)
81108294:	10bfffcc 	andi	r2,r2,65535
81108298:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_12_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_25_REG_OFST,
8110829c:	e0bfff17 	ldw	r2,-4(fp)
811082a0:	10800017 	ldw	r2,0(r2)
811082a4:	e1bffe17 	ldw	r6,-8(fp)
811082a8:	01402e44 	movi	r5,185
811082ac:	1009883a 	mov	r4,r2
811082b0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811082b4:	e0bfff17 	ldw	r2,-4(fp)
811082b8:	10800017 	ldw	r2,0(r2)
811082bc:	01402e84 	movi	r5,186
811082c0:	1009883a 	mov	r4,r2
811082c4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811082c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
811082cc:	e0bffe17 	ldw	r2,-8(fp)
811082d0:	10bfffec 	andhi	r2,r2,65535
811082d4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
811082d8:	e0bfff17 	ldw	r2,-4(fp)
811082dc:	1080400b 	ldhu	r2,256(r2)
811082e0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_13_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_13_MSK
811082e4:	e0fffe17 	ldw	r3,-8(fp)
811082e8:	1884b03a 	or	r2,r3,r2
811082ec:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 >> 0));
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_14_MSK);
811082f0:	e0bffe17 	ldw	r2,-8(fp)
811082f4:	10bfffcc 	andi	r2,r2,65535
811082f8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_14_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_26_REG_OFST,
811082fc:	e0bfff17 	ldw	r2,-4(fp)
81108300:	10800017 	ldw	r2,0(r2)
81108304:	e1bffe17 	ldw	r6,-8(fp)
81108308:	01402e84 	movi	r5,186
8110830c:	1009883a 	mov	r4,r2
81108310:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108314:	e0bfff17 	ldw	r2,-4(fp)
81108318:	10800017 	ldw	r2,0(r2)
8110831c:	01402ec4 	movi	r5,187
81108320:	1009883a 	mov	r4,r2
81108324:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108328:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
8110832c:	e0bffe17 	ldw	r2,-8(fp)
81108330:	10bfffec 	andhi	r2,r2,65535
81108334:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
81108338:	e0bfff17 	ldw	r2,-4(fp)
8110833c:	1080410b 	ldhu	r2,260(r2)
81108340:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		uliReg &= (~COMM_RMAP_LOWRES_PRT_A_15_MSK);
		uliReg |= (COMM_RMAP_LOWRES_PRT_A_15_MSK
81108344:	e0fffe17 	ldw	r3,-8(fp)
81108348:	1884b03a 	or	r2,r3,r2
8110834c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT0_MSK);
81108350:	e0bffe17 	ldw	r2,-8(fp)
81108354:	10bfffcc 	andi	r2,r2,65535
81108358:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT0_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_27_REG_OFST,
8110835c:	e0bfff17 	ldw	r2,-4(fp)
81108360:	10800017 	ldw	r2,0(r2)
81108364:	e1bffe17 	ldw	r6,-8(fp)
81108368:	01402ec4 	movi	r5,187
8110836c:	1009883a 	mov	r4,r2
81108370:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108374:	e0bfff17 	ldw	r2,-4(fp)
81108378:	10800017 	ldw	r2,0(r2)
8110837c:	01402f04 	movi	r5,188
81108380:	1009883a 	mov	r4,r2
81108384:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108388:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
8110838c:	e0bffe17 	ldw	r2,-8(fp)
81108390:	10bfffec 	andhi	r2,r2,65535
81108394:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
81108398:	e0bfff17 	ldw	r2,-4(fp)
8110839c:	1080420b 	ldhu	r2,264(r2)
811083a0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT1_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT1_MSK
811083a4:	e0fffe17 	ldw	r3,-8(fp)
811083a8:	1884b03a 	or	r2,r3,r2
811083ac:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT2_MSK);
811083b0:	e0bffe17 	ldw	r2,-8(fp)
811083b4:	10bfffcc 	andi	r2,r2,65535
811083b8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT2_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_28_REG_OFST,
811083bc:	e0bfff17 	ldw	r2,-4(fp)
811083c0:	10800017 	ldw	r2,0(r2)
811083c4:	e1bffe17 	ldw	r6,-8(fp)
811083c8:	01402f04 	movi	r5,188
811083cc:	1009883a 	mov	r4,r2
811083d0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811083d4:	e0bfff17 	ldw	r2,-4(fp)
811083d8:	10800017 	ldw	r2,0(r2)
811083dc:	01402f44 	movi	r5,189
811083e0:	1009883a 	mov	r4,r2
811083e4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811083e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
811083ec:	e0bffe17 	ldw	r2,-8(fp)
811083f0:	10bfffec 	andhi	r2,r2,65535
811083f4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
811083f8:	e0bfff17 	ldw	r2,-4(fp)
811083fc:	1080430b 	ldhu	r2,268(r2)
81108400:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT3_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT3_MSK
81108404:	e0fffe17 	ldw	r3,-8(fp)
81108408:	1884b03a 	or	r2,r3,r2
8110840c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT4_MSK);
81108410:	e0bffe17 	ldw	r2,-8(fp)
81108414:	10bfffcc 	andi	r2,r2,65535
81108418:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT4_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_29_REG_OFST,
8110841c:	e0bfff17 	ldw	r2,-4(fp)
81108420:	10800017 	ldw	r2,0(r2)
81108424:	e1bffe17 	ldw	r6,-8(fp)
81108428:	01402f44 	movi	r5,189
8110842c:	1009883a 	mov	r4,r2
81108430:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108434:	e0bfff17 	ldw	r2,-4(fp)
81108438:	10800017 	ldw	r2,0(r2)
8110843c:	01402f84 	movi	r5,190
81108440:	1009883a 	mov	r4,r2
81108444:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108448:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
8110844c:	e0bffe17 	ldw	r2,-8(fp)
81108450:	10bfffec 	andhi	r2,r2,65535
81108454:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
81108458:	e0bfff17 	ldw	r2,-4(fp)
8110845c:	1080440b 	ldhu	r2,272(r2)
81108460:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT5_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT5_MSK
81108464:	e0fffe17 	ldw	r3,-8(fp)
81108468:	1884b03a 	or	r2,r3,r2
8110846c:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 >> 0));
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT6_MSK);
81108470:	e0bffe17 	ldw	r2,-8(fp)
81108474:	10bfffcc 	andi	r2,r2,65535
81108478:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT6_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_30_REG_OFST,
8110847c:	e0bfff17 	ldw	r2,-4(fp)
81108480:	10800017 	ldw	r2,0(r2)
81108484:	e1bffe17 	ldw	r6,-8(fp)
81108488:	01402f84 	movi	r5,190
8110848c:	1009883a 	mov	r4,r2
81108490:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108494:	e0bfff17 	ldw	r2,-4(fp)
81108498:	10800017 	ldw	r2,0(r2)
8110849c:	01402fc4 	movi	r5,191
811084a0:	1009883a 	mov	r4,r2
811084a4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811084a8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
811084ac:	e0bffe17 	ldw	r2,-8(fp)
811084b0:	10bfffec 	andhi	r2,r2,65535
811084b4:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
811084b8:	e0bfff17 	ldw	r2,-4(fp)
811084bc:	1080450b 	ldhu	r2,276(r2)
811084c0:	10bfffcc 	andi	r2,r2,65535
				uliReg);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		uliReg &= (~COMM_RMAP_SEL_HIRES_PRT7_MSK);
		uliReg |= (COMM_RMAP_SEL_HIRES_PRT7_MSK
811084c4:	e0fffe17 	ldw	r3,-8(fp)
811084c8:	1884b03a 	or	r2,r3,r2
811084cc:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 >> 0));
		uliReg &= (~COMM_RMAP_ZERO_HIRES_AMP_MSK);
811084d0:	e0bffe17 	ldw	r2,-8(fp)
811084d4:	10bfffcc 	andi	r2,r2,65535
811084d8:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_RMAP_ZERO_HIRES_AMP_MSK
				& (alt_u32) (pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp >> 16));
		vRmapWriteReg(pxRmapCh->puliRmapChAddr, COMM_RMAP_HK_31_REG_OFST,
811084dc:	e0bfff17 	ldw	r2,-4(fp)
811084e0:	10800017 	ldw	r2,0(r2)
811084e4:	e1bffe17 	ldw	r6,-8(fp)
811084e8:	01402fc4 	movi	r5,191
811084ec:	1009883a 	mov	r4,r2
811084f0:	1108e840 	call	81108e84 <vRmapWriteReg>
				uliReg);

		bStatus = TRUE;
811084f4:	00800044 	movi	r2,1
811084f8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811084fc:	e0bffd17 	ldw	r2,-12(fp)
}
81108500:	e037883a 	mov	sp,fp
81108504:	dfc00117 	ldw	ra,4(sp)
81108508:	df000017 	ldw	fp,0(sp)
8110850c:	dec00204 	addi	sp,sp,8
81108510:	f800283a 	ret

81108514 <bRmapGetRmapMemHKArea>:

bool bRmapGetRmapMemHKArea(TRmapChannel *pxRmapCh) {
81108514:	defffb04 	addi	sp,sp,-20
81108518:	de00012e 	bgeu	sp,et,81108520 <bRmapGetRmapMemHKArea+0xc>
8110851c:	003b68fa 	trap	3
81108520:	dfc00415 	stw	ra,16(sp)
81108524:	df000315 	stw	fp,12(sp)
81108528:	df000304 	addi	fp,sp,12
8110852c:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81108530:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
81108534:	e03ffe15 	stw	zero,-8(fp)

	if (pxRmapCh != NULL) {
81108538:	e0bfff17 	ldw	r2,-4(fp)
8110853c:	1001e226 	beq	r2,zero,81108cc8 <bRmapGetRmapMemHKArea+0x7b4>

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108540:	e0bfff17 	ldw	r2,-4(fp)
81108544:	10800017 	ldw	r2,0(r2)
81108548:	01402804 	movi	r5,160
8110854c:	1009883a 	mov	r4,r2
81108550:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108554:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
81108558:	e0bffe17 	ldw	r2,-8(fp)
8110855c:	1007883a 	mov	r3,r2
81108560:	e0bfff17 	ldw	r2,-4(fp)
81108564:	10c0260d 	sth	r3,152(r2)
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);
81108568:	e0bffe17 	ldw	r2,-8(fp)
8110856c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_0_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VodF = (alt_u16) ((uliReg
81108570:	1007883a 	mov	r3,r2
81108574:	e0bfff17 	ldw	r2,-4(fp)
81108578:	10c0268d 	sth	r3,154(r2)
				& COMM_RMAP_HK_CCD1_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110857c:	e0bfff17 	ldw	r2,-4(fp)
81108580:	10800017 	ldw	r2,0(r2)
81108584:	01402844 	movi	r5,161
81108588:	1009883a 	mov	r4,r2
8110858c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108590:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
81108594:	e0bffe17 	ldw	r2,-8(fp)
81108598:	1007883a 	mov	r3,r2
8110859c:	e0bfff17 	ldw	r2,-4(fp)
811085a0:	10c0270d 	sth	r3,156(r2)
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);
811085a4:	e0bffe17 	ldw	r2,-8(fp)
811085a8:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_1_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodE = (alt_u16) ((uliReg
811085ac:	1007883a 	mov	r3,r2
811085b0:	e0bfff17 	ldw	r2,-4(fp)
811085b4:	10c0278d 	sth	r3,158(r2)
				& COMM_RMAP_HK_CCD2_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085b8:	e0bfff17 	ldw	r2,-4(fp)
811085bc:	10800017 	ldw	r2,0(r2)
811085c0:	01402884 	movi	r5,162
811085c4:	1009883a 	mov	r4,r2
811085c8:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811085cc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
811085d0:	e0bffe17 	ldw	r2,-8(fp)
811085d4:	1007883a 	mov	r3,r2
811085d8:	e0bfff17 	ldw	r2,-4(fp)
811085dc:	10c0280d 	sth	r3,160(r2)
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);
811085e0:	e0bffe17 	ldw	r2,-8(fp)
811085e4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_2_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2VrdMon = (alt_u16) ((uliReg
811085e8:	1007883a 	mov	r3,r2
811085ec:	e0bfff17 	ldw	r2,-4(fp)
811085f0:	10c0288d 	sth	r3,162(r2)
				& COMM_RMAP_HK_CCD2_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811085f4:	e0bfff17 	ldw	r2,-4(fp)
811085f8:	10800017 	ldw	r2,0(r2)
811085fc:	014028c4 	movi	r5,163
81108600:	1009883a 	mov	r4,r2
81108604:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108608:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
8110860c:	e0bffe17 	ldw	r2,-8(fp)
81108610:	1007883a 	mov	r3,r2
81108614:	e0bfff17 	ldw	r2,-4(fp)
81108618:	10c0290d 	sth	r3,164(r2)
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);
8110861c:	e0bffe17 	ldw	r2,-8(fp)
81108620:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_3_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VOD_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VodF = (alt_u16) ((uliReg
81108624:	1007883a 	mov	r3,r2
81108628:	e0bfff17 	ldw	r2,-4(fp)
8110862c:	10c0298d 	sth	r3,166(r2)
				& COMM_RMAP_HK_CCD3_VOD_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108630:	e0bfff17 	ldw	r2,-4(fp)
81108634:	10800017 	ldw	r2,0(r2)
81108638:	01402904 	movi	r5,164
8110863c:	1009883a 	mov	r4,r2
81108640:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108644:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
81108648:	e0bffe17 	ldw	r2,-8(fp)
8110864c:	1007883a 	mov	r3,r2
81108650:	e0bfff17 	ldw	r2,-4(fp)
81108654:	10c02a0d 	sth	r3,168(r2)
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);
81108658:	e0bffe17 	ldw	r2,-8(fp)
8110865c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_4_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_VRD_MON_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodE = (alt_u16) ((uliReg
81108660:	1007883a 	mov	r3,r2
81108664:	e0bfff17 	ldw	r2,-4(fp)
81108668:	10c02a8d 	sth	r3,170(r2)
				& COMM_RMAP_HK_CCD4_VOD_E_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110866c:	e0bfff17 	ldw	r2,-4(fp)
81108670:	10800017 	ldw	r2,0(r2)
81108674:	01402944 	movi	r5,165
81108678:	1009883a 	mov	r4,r2
8110867c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108680:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
81108684:	e0bffe17 	ldw	r2,-8(fp)
81108688:	1007883a 	mov	r3,r2
8110868c:	e0bfff17 	ldw	r2,-4(fp)
81108690:	10c02b0d 	sth	r3,172(r2)
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);
81108694:	e0bffe17 	ldw	r2,-8(fp)
81108698:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_5_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VodF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_VOD_F_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4VrdMon = (alt_u16) ((uliReg
8110869c:	1007883a 	mov	r3,r2
811086a0:	e0bfff17 	ldw	r2,-4(fp)
811086a4:	10c02b8d 	sth	r3,174(r2)
				& COMM_RMAP_HK_CCD4_VRD_MON_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086a8:	e0bfff17 	ldw	r2,-4(fp)
811086ac:	10800017 	ldw	r2,0(r2)
811086b0:	01402984 	movi	r5,166
811086b4:	1009883a 	mov	r4,r2
811086b8:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811086bc:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
811086c0:	e0bffe17 	ldw	r2,-8(fp)
811086c4:	1007883a 	mov	r3,r2
811086c8:	e0bfff17 	ldw	r2,-4(fp)
811086cc:	10c02c0d 	sth	r3,176(r2)
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);
811086d0:	e0bffe17 	ldw	r2,-8(fp)
811086d4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_6_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccd = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclk = (alt_u16) ((uliReg
811086d8:	1007883a 	mov	r3,r2
811086dc:	e0bfff17 	ldw	r2,-4(fp)
811086e0:	10c02c8d 	sth	r3,178(r2)
				& COMM_RMAP_HK_VRCLK_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811086e4:	e0bfff17 	ldw	r2,-4(fp)
811086e8:	10800017 	ldw	r2,0(r2)
811086ec:	014029c4 	movi	r5,167
811086f0:	1009883a 	mov	r4,r2
811086f4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811086f8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
811086fc:	e0bffe17 	ldw	r2,-8(fp)
81108700:	1007883a 	mov	r3,r2
81108704:	e0bfff17 	ldw	r2,-4(fp)
81108708:	10c02d0d 	sth	r3,180(r2)
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);
8110870c:	e0bffe17 	ldw	r2,-8(fp)
81108710:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_7_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkViclk = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVrclkLow = (alt_u16) ((uliReg
81108714:	1007883a 	mov	r3,r2
81108718:	e0bfff17 	ldw	r2,-4(fp)
8110871c:	10c02d8d 	sth	r3,182(r2)
				& COMM_RMAP_HK_VRCLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108720:	e0bfff17 	ldw	r2,-4(fp)
81108724:	10800017 	ldw	r2,0(r2)
81108728:	01402a04 	movi	r5,168
8110872c:	1009883a 	mov	r4,r2
81108730:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108734:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
81108738:	e0bffe17 	ldw	r2,-8(fp)
8110873c:	1007883a 	mov	r3,r2
81108740:	e0bfff17 	ldw	r2,-4(fp)
81108744:	10c02e0d 	sth	r3,184(r2)
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);
81108748:	e0bffe17 	ldw	r2,-8(fp)
8110874c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_8_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk5vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vbNeg = (alt_u16) ((uliReg
81108750:	1007883a 	mov	r3,r2
81108754:	e0bfff17 	ldw	r2,-4(fp)
81108758:	10c02e8d 	sth	r3,186(r2)
				& COMM_RMAP_HK_5VB_NEG_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110875c:	e0bfff17 	ldw	r2,-4(fp)
81108760:	10800017 	ldw	r2,0(r2)
81108764:	01402a44 	movi	r5,169
81108768:	1009883a 	mov	r4,r2
8110876c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108770:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
81108774:	e0bffe17 	ldw	r2,-8(fp)
81108778:	1007883a 	mov	r3,r2
8110877c:	e0bfff17 	ldw	r2,-4(fp)
81108780:	10c02f0d 	sth	r3,188(r2)
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);
81108784:	e0bffe17 	ldw	r2,-8(fp)
81108788:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_9_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vbPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VB_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vaPos = (alt_u16) ((uliReg
8110878c:	1007883a 	mov	r3,r2
81108790:	e0bfff17 	ldw	r2,-4(fp)
81108794:	10c02f8d 	sth	r3,190(r2)
				& COMM_RMAP_HK_2_5VA_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108798:	e0bfff17 	ldw	r2,-4(fp)
8110879c:	10800017 	ldw	r2,0(r2)
811087a0:	01402a84 	movi	r5,170
811087a4:	1009883a 	mov	r4,r2
811087a8:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811087ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
811087b0:	e0bffe17 	ldw	r2,-8(fp)
811087b4:	1007883a 	mov	r3,r2
811087b8:	e0bfff17 	ldw	r2,-4(fp)
811087bc:	10c0300d 	sth	r3,192(r2)
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);
811087c0:	e0bffe17 	ldw	r2,-8(fp)
811087c4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_10_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk33vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_3_3VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk25vdPos = (alt_u16) ((uliReg
811087c8:	1007883a 	mov	r3,r2
811087cc:	e0bfff17 	ldw	r2,-4(fp)
811087d0:	10c0308d 	sth	r3,194(r2)
				& COMM_RMAP_HK_2_5VD_POS_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811087d4:	e0bfff17 	ldw	r2,-4(fp)
811087d8:	10800017 	ldw	r2,0(r2)
811087dc:	01402ac4 	movi	r5,171
811087e0:	1009883a 	mov	r4,r2
811087e4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811087e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
811087ec:	e0bffe17 	ldw	r2,-8(fp)
811087f0:	1007883a 	mov	r3,r2
811087f4:	e0bfff17 	ldw	r2,-4(fp)
811087f8:	10c0310d 	sth	r3,196(r2)
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
				& COMM_RMAP_HK_5VREF_MSK) >> 16);
811087fc:	e0bffe17 	ldw	r2,-8(fp)
81108800:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_11_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHk15vdPos = (alt_u16) ((uliReg
				& COMM_RMAP_HK_1_5VD_POS_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHk5vref = (alt_u16) ((uliReg
81108804:	1007883a 	mov	r3,r2
81108808:	e0bfff17 	ldw	r2,-4(fp)
8110880c:	10c0318d 	sth	r3,198(r2)
				& COMM_RMAP_HK_5VREF_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108810:	e0bfff17 	ldw	r2,-4(fp)
81108814:	10800017 	ldw	r2,0(r2)
81108818:	01402b04 	movi	r5,172
8110881c:	1009883a 	mov	r4,r2
81108820:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108824:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
81108828:	e0bffe17 	ldw	r2,-8(fp)
8110882c:	1007883a 	mov	r3,r2
81108830:	e0bfff17 	ldw	r2,-4(fp)
81108834:	10c0320d 	sth	r3,200(r2)
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);
81108838:	e0bffe17 	ldw	r2,-8(fp)
8110883c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_12_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVccdPosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VCCD_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVclkPosRaw = (alt_u16) ((uliReg
81108840:	1007883a 	mov	r3,r2
81108844:	e0bfff17 	ldw	r2,-4(fp)
81108848:	10c0328d 	sth	r3,202(r2)
				& COMM_RMAP_HK_VCLK_POS_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110884c:	e0bfff17 	ldw	r2,-4(fp)
81108850:	10800017 	ldw	r2,0(r2)
81108854:	01402b44 	movi	r5,173
81108858:	1009883a 	mov	r4,r2
8110885c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108860:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
81108864:	e0bffe17 	ldw	r2,-8(fp)
81108868:	1007883a 	mov	r3,r2
8110886c:	e0bfff17 	ldw	r2,-4(fp)
81108870:	10c0330d 	sth	r3,204(r2)
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);
81108874:	e0bffe17 	ldw	r2,-8(fp)
81108878:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_13_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan1PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN1_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVan3NegRaw = (alt_u16) ((uliReg
8110887c:	1007883a 	mov	r3,r2
81108880:	e0bfff17 	ldw	r2,-4(fp)
81108884:	10c0338d 	sth	r3,206(r2)
				& COMM_RMAP_HK_VAN3_NEG_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108888:	e0bfff17 	ldw	r2,-4(fp)
8110888c:	10800017 	ldw	r2,0(r2)
81108890:	01402b84 	movi	r5,174
81108894:	1009883a 	mov	r4,r2
81108898:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110889c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
811088a0:	e0bffe17 	ldw	r2,-8(fp)
811088a4:	1007883a 	mov	r3,r2
811088a8:	e0bfff17 	ldw	r2,-4(fp)
811088ac:	10c0340d 	sth	r3,208(r2)
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);
811088b0:	e0bffe17 	ldw	r2,-8(fp)
811088b4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_14_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVan2PosRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VAN2_POS_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkVdigFpgaRaw = (alt_u16) ((uliReg
811088b8:	1007883a 	mov	r3,r2
811088bc:	e0bfff17 	ldw	r2,-4(fp)
811088c0:	10c0348d 	sth	r3,210(r2)
				& COMM_RMAP_HK_VDIG_FPGA_RAW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811088c4:	e0bfff17 	ldw	r2,-4(fp)
811088c8:	10800017 	ldw	r2,0(r2)
811088cc:	01402bc4 	movi	r5,175
811088d0:	1009883a 	mov	r4,r2
811088d4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811088d8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
811088dc:	e0bffe17 	ldw	r2,-8(fp)
811088e0:	1007883a 	mov	r3,r2
811088e4:	e0bfff17 	ldw	r2,-4(fp)
811088e8:	10c0350d 	sth	r3,212(r2)
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);
811088ec:	e0bffe17 	ldw	r2,-8(fp)
811088f0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_15_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkVdigSpwRaw = (alt_u16) ((uliReg
				& COMM_RMAP_HK_VDIG_SPW_RAW_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkViclkLow = (alt_u16) ((uliReg
811088f4:	1007883a 	mov	r3,r2
811088f8:	e0bfff17 	ldw	r2,-4(fp)
811088fc:	10c0358d 	sth	r3,214(r2)
				& COMM_RMAP_HK_VICLK_LOW_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108900:	e0bfff17 	ldw	r2,-4(fp)
81108904:	10800017 	ldw	r2,0(r2)
81108908:	01402c04 	movi	r5,176
8110890c:	1009883a 	mov	r4,r2
81108910:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108914:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
81108918:	e0bffe17 	ldw	r2,-8(fp)
8110891c:	1007883a 	mov	r3,r2
81108920:	e0bfff17 	ldw	r2,-4(fp)
81108924:	10c0360d 	sth	r3,216(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);
81108928:	e0bffe17 	ldw	r2,-8(fp)
8110892c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_16_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAE = (alt_u16) ((uliReg
				& COMM_RMAP_HK_ADC_TEMP_A_E_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkAdcTempAF = (alt_u16) ((uliReg
81108930:	1007883a 	mov	r3,r2
81108934:	e0bfff17 	ldw	r2,-4(fp)
81108938:	10c0368d 	sth	r3,218(r2)
				& COMM_RMAP_HK_ADC_TEMP_A_F_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
8110893c:	e0bfff17 	ldw	r2,-4(fp)
81108940:	10800017 	ldw	r2,0(r2)
81108944:	01402c44 	movi	r5,177
81108948:	1009883a 	mov	r4,r2
8110894c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108950:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
81108954:	e0bffe17 	ldw	r2,-8(fp)
81108958:	1007883a 	mov	r3,r2
8110895c:	e0bfff17 	ldw	r2,-4(fp)
81108960:	10c0370d 	sth	r3,220(r2)
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);
81108964:	e0bffe17 	ldw	r2,-8(fp)
81108968:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_17_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd1Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD1_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd2Temp = (alt_u16) ((uliReg
8110896c:	1007883a 	mov	r3,r2
81108970:	e0bfff17 	ldw	r2,-4(fp)
81108974:	10c0378d 	sth	r3,222(r2)
				& COMM_RMAP_HK_CCD2_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108978:	e0bfff17 	ldw	r2,-4(fp)
8110897c:	10800017 	ldw	r2,0(r2)
81108980:	01402c84 	movi	r5,178
81108984:	1009883a 	mov	r4,r2
81108988:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110898c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
81108990:	e0bffe17 	ldw	r2,-8(fp)
81108994:	1007883a 	mov	r3,r2
81108998:	e0bfff17 	ldw	r2,-4(fp)
8110899c:	10c0380d 	sth	r3,224(r2)
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);
811089a0:	e0bffe17 	ldw	r2,-8(fp)
811089a4:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_18_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkCcd3Temp = (alt_u16) ((uliReg
				& COMM_RMAP_HK_CCD3_TEMP_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiHkCcd4Temp = (alt_u16) ((uliReg
811089a8:	1007883a 	mov	r3,r2
811089ac:	e0bfff17 	ldw	r2,-4(fp)
811089b0:	10c0388d 	sth	r3,226(r2)
				& COMM_RMAP_HK_CCD4_TEMP_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089b4:	e0bfff17 	ldw	r2,-4(fp)
811089b8:	10800017 	ldw	r2,0(r2)
811089bc:	01402cc4 	movi	r5,179
811089c0:	1009883a 	mov	r4,r2
811089c4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
811089c8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
811089cc:	e0bffe17 	ldw	r2,-8(fp)
811089d0:	1007883a 	mov	r3,r2
811089d4:	e0bfff17 	ldw	r2,-4(fp)
811089d8:	10c0390d 	sth	r3,228(r2)
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);
811089dc:	e0bffe17 	ldw	r2,-8(fp)
811089e0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_19_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiHkWp605Spare = (alt_u16) ((uliReg
				& COMM_RMAP_HK_WP605_SPARE_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA0 = (alt_u16) ((uliReg
811089e4:	1007883a 	mov	r3,r2
811089e8:	e0bfff17 	ldw	r2,-4(fp)
811089ec:	10c0398d 	sth	r3,230(r2)
				& COMM_RMAP_LOWRES_PRT_A_0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
811089f0:	e0bfff17 	ldw	r2,-4(fp)
811089f4:	10800017 	ldw	r2,0(r2)
811089f8:	01402d04 	movi	r5,180
811089fc:	1009883a 	mov	r4,r2
81108a00:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108a04:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
81108a08:	e0bffe17 	ldw	r2,-8(fp)
81108a0c:	1007883a 	mov	r3,r2
81108a10:	e0bfff17 	ldw	r2,-4(fp)
81108a14:	10c03a0d 	sth	r3,232(r2)
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);
81108a18:	e0bffe17 	ldw	r2,-8(fp)
81108a1c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_20_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA1 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA2 = (alt_u16) ((uliReg
81108a20:	1007883a 	mov	r3,r2
81108a24:	e0bfff17 	ldw	r2,-4(fp)
81108a28:	10c03a8d 	sth	r3,234(r2)
				& COMM_RMAP_LOWRES_PRT_A_2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a2c:	e0bfff17 	ldw	r2,-4(fp)
81108a30:	10800017 	ldw	r2,0(r2)
81108a34:	01402d44 	movi	r5,181
81108a38:	1009883a 	mov	r4,r2
81108a3c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108a40:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
81108a44:	e0bffe17 	ldw	r2,-8(fp)
81108a48:	1007883a 	mov	r3,r2
81108a4c:	e0bfff17 	ldw	r2,-4(fp)
81108a50:	10c03b0d 	sth	r3,236(r2)
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);
81108a54:	e0bffe17 	ldw	r2,-8(fp)
81108a58:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_21_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA3 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA4 = (alt_u16) ((uliReg
81108a5c:	1007883a 	mov	r3,r2
81108a60:	e0bfff17 	ldw	r2,-4(fp)
81108a64:	10c03b8d 	sth	r3,238(r2)
				& COMM_RMAP_LOWRES_PRT_A_4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108a68:	e0bfff17 	ldw	r2,-4(fp)
81108a6c:	10800017 	ldw	r2,0(r2)
81108a70:	01402d84 	movi	r5,182
81108a74:	1009883a 	mov	r4,r2
81108a78:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108a7c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
81108a80:	e0bffe17 	ldw	r2,-8(fp)
81108a84:	1007883a 	mov	r3,r2
81108a88:	e0bfff17 	ldw	r2,-4(fp)
81108a8c:	10c03c0d 	sth	r3,240(r2)
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);
81108a90:	e0bffe17 	ldw	r2,-8(fp)
81108a94:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_22_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA5 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA6 = (alt_u16) ((uliReg
81108a98:	1007883a 	mov	r3,r2
81108a9c:	e0bfff17 	ldw	r2,-4(fp)
81108aa0:	10c03c8d 	sth	r3,242(r2)
				& COMM_RMAP_LOWRES_PRT_A_6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108aa4:	e0bfff17 	ldw	r2,-4(fp)
81108aa8:	10800017 	ldw	r2,0(r2)
81108aac:	01402dc4 	movi	r5,183
81108ab0:	1009883a 	mov	r4,r2
81108ab4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108ab8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
81108abc:	e0bffe17 	ldw	r2,-8(fp)
81108ac0:	1007883a 	mov	r3,r2
81108ac4:	e0bfff17 	ldw	r2,-4(fp)
81108ac8:	10c03d0d 	sth	r3,244(r2)
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);
81108acc:	e0bffe17 	ldw	r2,-8(fp)
81108ad0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_23_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA7 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA8 = (alt_u16) ((uliReg
81108ad4:	1007883a 	mov	r3,r2
81108ad8:	e0bfff17 	ldw	r2,-4(fp)
81108adc:	10c03d8d 	sth	r3,246(r2)
				& COMM_RMAP_LOWRES_PRT_A_8_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108ae0:	e0bfff17 	ldw	r2,-4(fp)
81108ae4:	10800017 	ldw	r2,0(r2)
81108ae8:	01402e04 	movi	r5,184
81108aec:	1009883a 	mov	r4,r2
81108af0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108af4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
81108af8:	e0bffe17 	ldw	r2,-8(fp)
81108afc:	1007883a 	mov	r3,r2
81108b00:	e0bfff17 	ldw	r2,-4(fp)
81108b04:	10c03e0d 	sth	r3,248(r2)
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);
81108b08:	e0bffe17 	ldw	r2,-8(fp)
81108b0c:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_24_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA9 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_9_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA10 = (alt_u16) ((uliReg
81108b10:	1007883a 	mov	r3,r2
81108b14:	e0bfff17 	ldw	r2,-4(fp)
81108b18:	10c03e8d 	sth	r3,250(r2)
				& COMM_RMAP_LOWRES_PRT_A_10_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b1c:	e0bfff17 	ldw	r2,-4(fp)
81108b20:	10800017 	ldw	r2,0(r2)
81108b24:	01402e44 	movi	r5,185
81108b28:	1009883a 	mov	r4,r2
81108b2c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108b30:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
81108b34:	e0bffe17 	ldw	r2,-8(fp)
81108b38:	1007883a 	mov	r3,r2
81108b3c:	e0bfff17 	ldw	r2,-4(fp)
81108b40:	10c03f0d 	sth	r3,252(r2)
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);
81108b44:	e0bffe17 	ldw	r2,-8(fp)
81108b48:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_25_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA11 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_11_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA12 = (alt_u16) ((uliReg
81108b4c:	1007883a 	mov	r3,r2
81108b50:	e0bfff17 	ldw	r2,-4(fp)
81108b54:	10c03f8d 	sth	r3,254(r2)
				& COMM_RMAP_LOWRES_PRT_A_12_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b58:	e0bfff17 	ldw	r2,-4(fp)
81108b5c:	10800017 	ldw	r2,0(r2)
81108b60:	01402e84 	movi	r5,186
81108b64:	1009883a 	mov	r4,r2
81108b68:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108b6c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
81108b70:	e0bffe17 	ldw	r2,-8(fp)
81108b74:	1007883a 	mov	r3,r2
81108b78:	e0bfff17 	ldw	r2,-4(fp)
81108b7c:	10c0400d 	sth	r3,256(r2)
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);
81108b80:	e0bffe17 	ldw	r2,-8(fp)
81108b84:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_26_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA13 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_13_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA14 = (alt_u16) ((uliReg
81108b88:	1007883a 	mov	r3,r2
81108b8c:	e0bfff17 	ldw	r2,-4(fp)
81108b90:	10c0408d 	sth	r3,258(r2)
				& COMM_RMAP_LOWRES_PRT_A_14_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108b94:	e0bfff17 	ldw	r2,-4(fp)
81108b98:	10800017 	ldw	r2,0(r2)
81108b9c:	01402ec4 	movi	r5,187
81108ba0:	1009883a 	mov	r4,r2
81108ba4:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108ba8:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
81108bac:	e0bffe17 	ldw	r2,-8(fp)
81108bb0:	1007883a 	mov	r3,r2
81108bb4:	e0bfff17 	ldw	r2,-4(fp)
81108bb8:	10c0410d 	sth	r3,260(r2)
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);
81108bbc:	e0bffe17 	ldw	r2,-8(fp)
81108bc0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_27_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiLowresPrtA15 = (alt_u16) ((uliReg
				& COMM_RMAP_LOWRES_PRT_A_15_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt0 = (alt_u16) ((uliReg
81108bc4:	1007883a 	mov	r3,r2
81108bc8:	e0bfff17 	ldw	r2,-4(fp)
81108bcc:	10c0418d 	sth	r3,262(r2)
				& COMM_RMAP_SEL_HIRES_PRT0_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108bd0:	e0bfff17 	ldw	r2,-4(fp)
81108bd4:	10800017 	ldw	r2,0(r2)
81108bd8:	01402f04 	movi	r5,188
81108bdc:	1009883a 	mov	r4,r2
81108be0:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108be4:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
81108be8:	e0bffe17 	ldw	r2,-8(fp)
81108bec:	1007883a 	mov	r3,r2
81108bf0:	e0bfff17 	ldw	r2,-4(fp)
81108bf4:	10c0420d 	sth	r3,264(r2)
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);
81108bf8:	e0bffe17 	ldw	r2,-8(fp)
81108bfc:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_28_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt1 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT1_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt2 = (alt_u16) ((uliReg
81108c00:	1007883a 	mov	r3,r2
81108c04:	e0bfff17 	ldw	r2,-4(fp)
81108c08:	10c0428d 	sth	r3,266(r2)
				& COMM_RMAP_SEL_HIRES_PRT2_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c0c:	e0bfff17 	ldw	r2,-4(fp)
81108c10:	10800017 	ldw	r2,0(r2)
81108c14:	01402f44 	movi	r5,189
81108c18:	1009883a 	mov	r4,r2
81108c1c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108c20:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
81108c24:	e0bffe17 	ldw	r2,-8(fp)
81108c28:	1007883a 	mov	r3,r2
81108c2c:	e0bfff17 	ldw	r2,-4(fp)
81108c30:	10c0430d 	sth	r3,268(r2)
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);
81108c34:	e0bffe17 	ldw	r2,-8(fp)
81108c38:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_29_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt3 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT3_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt4 = (alt_u16) ((uliReg
81108c3c:	1007883a 	mov	r3,r2
81108c40:	e0bfff17 	ldw	r2,-4(fp)
81108c44:	10c0438d 	sth	r3,270(r2)
				& COMM_RMAP_SEL_HIRES_PRT4_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c48:	e0bfff17 	ldw	r2,-4(fp)
81108c4c:	10800017 	ldw	r2,0(r2)
81108c50:	01402f84 	movi	r5,190
81108c54:	1009883a 	mov	r4,r2
81108c58:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108c5c:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
81108c60:	e0bffe17 	ldw	r2,-8(fp)
81108c64:	1007883a 	mov	r3,r2
81108c68:	e0bfff17 	ldw	r2,-4(fp)
81108c6c:	10c0440d 	sth	r3,272(r2)
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);
81108c70:	e0bffe17 	ldw	r2,-8(fp)
81108c74:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_30_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt5 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT5_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt6 = (alt_u16) ((uliReg
81108c78:	1007883a 	mov	r3,r2
81108c7c:	e0bfff17 	ldw	r2,-4(fp)
81108c80:	10c0448d 	sth	r3,274(r2)
				& COMM_RMAP_SEL_HIRES_PRT6_MSK) >> 16);

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
81108c84:	e0bfff17 	ldw	r2,-4(fp)
81108c88:	10800017 	ldw	r2,0(r2)
81108c8c:	01402fc4 	movi	r5,191
81108c90:	1009883a 	mov	r4,r2
81108c94:	1108ed80 	call	81108ed8 <uliRmapReadReg>
81108c98:	e0bffe15 	stw	r2,-8(fp)
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
81108c9c:	e0bffe17 	ldw	r2,-8(fp)
81108ca0:	1007883a 	mov	r3,r2
81108ca4:	e0bfff17 	ldw	r2,-4(fp)
81108ca8:	10c0450d 	sth	r3,276(r2)
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);
81108cac:	e0bffe17 	ldw	r2,-8(fp)
81108cb0:	1004d43a 	srli	r2,r2,16

		uliReg = uliRmapReadReg(pxRmapCh->puliRmapChAddr,
		COMM_RMAP_HK_31_REG_OFST);
		pxRmapCh->xRmapMemHKArea.usiSelHiresPrt7 = (alt_u16) ((uliReg
				& COMM_RMAP_SEL_HIRES_PRT7_MSK) >> 0);
		pxRmapCh->xRmapMemHKArea.usiZeroHiresAmp = (alt_u16) ((uliReg
81108cb4:	1007883a 	mov	r3,r2
81108cb8:	e0bfff17 	ldw	r2,-4(fp)
81108cbc:	10c0458d 	sth	r3,278(r2)
				& COMM_RMAP_ZERO_HIRES_AMP_MSK) >> 16);

		bStatus = TRUE;
81108cc0:	00800044 	movi	r2,1
81108cc4:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81108cc8:	e0bffd17 	ldw	r2,-12(fp)
}
81108ccc:	e037883a 	mov	sp,fp
81108cd0:	dfc00117 	ldw	ra,4(sp)
81108cd4:	df000017 	ldw	fp,0(sp)
81108cd8:	dec00204 	addi	sp,sp,8
81108cdc:	f800283a 	ret

81108ce0 <bRmapInitCh>:

bool bRmapInitCh(TRmapChannel *pxRmapCh, alt_u8 ucCommCh) {
81108ce0:	defffb04 	addi	sp,sp,-20
81108ce4:	de00012e 	bgeu	sp,et,81108cec <bRmapInitCh+0xc>
81108ce8:	003b68fa 	trap	3
81108cec:	dfc00415 	stw	ra,16(sp)
81108cf0:	df000315 	stw	fp,12(sp)
81108cf4:	df000304 	addi	fp,sp,12
81108cf8:	e13ffe15 	stw	r4,-8(fp)
81108cfc:	2805883a 	mov	r2,r5
81108d00:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
81108d04:	e03ffd15 	stw	zero,-12(fp)

	if (pxRmapCh != NULL) {
81108d08:	e0bffe17 	ldw	r2,-8(fp)
81108d0c:	10005726 	beq	r2,zero,81108e6c <bRmapInitCh+0x18c>
		bStatus = TRUE;
81108d10:	00800044 	movi	r2,1
81108d14:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
81108d18:	e0bfff03 	ldbu	r2,-4(fp)
81108d1c:	10c00228 	cmpgeui	r3,r2,8
81108d20:	1800361e 	bne	r3,zero,81108dfc <bRmapInitCh+0x11c>
81108d24:	100690ba 	slli	r3,r2,2
81108d28:	00a04474 	movhi	r2,33041
81108d2c:	10a34f04 	addi	r2,r2,-29380
81108d30:	1885883a 	add	r2,r3,r2
81108d34:	10800017 	ldw	r2,0(r2)
81108d38:	1000683a 	jmp	r2
81108d3c:	81108d5c 	xori	r4,r16,16949
81108d40:	81108d70 	cmpltui	r4,r16,16949
81108d44:	81108d84 	addi	r4,r16,16950
81108d48:	81108d98 	cmpnei	r4,r16,16950
81108d4c:	81108dac 	andhi	r4,r16,16950
81108d50:	81108dc0 	call	881108dc <__reset+0x20f08dc>
81108d54:	81108dd4 	ori	r4,r16,16951
81108d58:	81108de8 	cmpgeui	r4,r16,16951
		case eCommSpwCh1:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81108d5c:	e0fffe17 	ldw	r3,-8(fp)
81108d60:	00a04834 	movhi	r2,33056
81108d64:	108b0004 	addi	r2,r2,11264
81108d68:	18800015 	stw	r2,0(r3)
			break;
81108d6c:	00002506 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh2:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81108d70:	e0fffe17 	ldw	r3,-8(fp)
81108d74:	00a04834 	movhi	r2,33056
81108d78:	108a0004 	addi	r2,r2,10240
81108d7c:	18800015 	stw	r2,0(r3)
			break;
81108d80:	00002006 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh3:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81108d84:	e0fffe17 	ldw	r3,-8(fp)
81108d88:	00a04834 	movhi	r2,33056
81108d8c:	10890004 	addi	r2,r2,9216
81108d90:	18800015 	stw	r2,0(r3)
			break;
81108d94:	00001b06 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh4:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
81108d98:	e0fffe17 	ldw	r3,-8(fp)
81108d9c:	00a04834 	movhi	r2,33056
81108da0:	10880004 	addi	r2,r2,8192
81108da4:	18800015 	stw	r2,0(r3)
			break;
81108da8:	00001606 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh5:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81108dac:	e0fffe17 	ldw	r3,-8(fp)
81108db0:	00a04834 	movhi	r2,33056
81108db4:	10870004 	addi	r2,r2,7168
81108db8:	18800015 	stw	r2,0(r3)
			break;
81108dbc:	00001106 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh6:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81108dc0:	e0fffe17 	ldw	r3,-8(fp)
81108dc4:	00a04834 	movhi	r2,33056
81108dc8:	10860004 	addi	r2,r2,6144
81108dcc:	18800015 	stw	r2,0(r3)
			break;
81108dd0:	00000c06 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh7:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81108dd4:	e0fffe17 	ldw	r3,-8(fp)
81108dd8:	00a04834 	movhi	r2,33056
81108ddc:	10850004 	addi	r2,r2,5120
81108de0:	18800015 	stw	r2,0(r3)
			break;
81108de4:	00000706 	br	81108e04 <bRmapInitCh+0x124>
		case eCommSpwCh8:
			pxRmapCh->puliRmapChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
81108de8:	e0fffe17 	ldw	r3,-8(fp)
81108dec:	00a04834 	movhi	r2,33056
81108df0:	10840004 	addi	r2,r2,4096
81108df4:	18800015 	stw	r2,0(r3)
			break;
81108df8:	00000206 	br	81108e04 <bRmapInitCh+0x124>
		default:
			bStatus = FALSE;
81108dfc:	e03ffd15 	stw	zero,-12(fp)
			break;
81108e00:	0001883a 	nop
		}

		if (bStatus) {
81108e04:	e0bffd17 	ldw	r2,-12(fp)
81108e08:	10001826 	beq	r2,zero,81108e6c <bRmapInitCh+0x18c>
			if (!bRmapGetIrqControl(pxRmapCh)) {
81108e0c:	e13ffe17 	ldw	r4,-8(fp)
81108e10:	1106d400 	call	81106d40 <bRmapGetIrqControl>
81108e14:	1000011e 	bne	r2,zero,81108e1c <bRmapInitCh+0x13c>
				bStatus = FALSE;
81108e18:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecConfig(pxRmapCh)) {
81108e1c:	e13ffe17 	ldw	r4,-8(fp)
81108e20:	1106f280 	call	81106f28 <bRmapGetCodecConfig>
81108e24:	1000011e 	bne	r2,zero,81108e2c <bRmapInitCh+0x14c>
				bStatus = FALSE;
81108e28:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetCodecStatus(pxRmapCh)) {
81108e2c:	e13ffe17 	ldw	r4,-8(fp)
81108e30:	1106fb40 	call	81106fb4 <bRmapGetCodecStatus>
81108e34:	1000011e 	bne	r2,zero,81108e3c <bRmapInitCh+0x15c>
				bStatus = FALSE;
81108e38:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigArea(pxRmapCh)) {
81108e3c:	e13ffe17 	ldw	r4,-8(fp)
81108e40:	11075600 	call	81107560 <bRmapGetMemConfigArea>
81108e44:	1000011e 	bne	r2,zero,81108e4c <bRmapInitCh+0x16c>
				bStatus = FALSE;
81108e48:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetMemConfigStat(pxRmapCh)) {
81108e4c:	e13ffe17 	ldw	r4,-8(fp)
81108e50:	11078340 	call	81107834 <bRmapGetMemConfigStat>
81108e54:	1000011e 	bne	r2,zero,81108e5c <bRmapInitCh+0x17c>
				bStatus = FALSE;
81108e58:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bRmapGetRmapMemHKArea(pxRmapCh)) {
81108e5c:	e13ffe17 	ldw	r4,-8(fp)
81108e60:	11085140 	call	81108514 <bRmapGetRmapMemHKArea>
81108e64:	1000011e 	bne	r2,zero,81108e6c <bRmapInitCh+0x18c>
				bStatus = FALSE;
81108e68:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
81108e6c:	e0bffd17 	ldw	r2,-12(fp)
}
81108e70:	e037883a 	mov	sp,fp
81108e74:	dfc00117 	ldw	ra,4(sp)
81108e78:	df000017 	ldw	fp,0(sp)
81108e7c:	dec00204 	addi	sp,sp,8
81108e80:	f800283a 	ret

81108e84 <vRmapWriteReg>:
//! [public functions]

//! [private functions]
static void vRmapWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81108e84:	defffc04 	addi	sp,sp,-16
81108e88:	de00012e 	bgeu	sp,et,81108e90 <vRmapWriteReg+0xc>
81108e8c:	003b68fa 	trap	3
81108e90:	df000315 	stw	fp,12(sp)
81108e94:	df000304 	addi	fp,sp,12
81108e98:	e13ffd15 	stw	r4,-12(fp)
81108e9c:	e17ffe15 	stw	r5,-8(fp)
81108ea0:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81108ea4:	e0bffe17 	ldw	r2,-8(fp)
81108ea8:	1085883a 	add	r2,r2,r2
81108eac:	1085883a 	add	r2,r2,r2
81108eb0:	1007883a 	mov	r3,r2
81108eb4:	e0bffd17 	ldw	r2,-12(fp)
81108eb8:	10c5883a 	add	r2,r2,r3
81108ebc:	e0ffff17 	ldw	r3,-4(fp)
81108ec0:	10c00015 	stw	r3,0(r2)
}
81108ec4:	0001883a 	nop
81108ec8:	e037883a 	mov	sp,fp
81108ecc:	df000017 	ldw	fp,0(sp)
81108ed0:	dec00104 	addi	sp,sp,4
81108ed4:	f800283a 	ret

81108ed8 <uliRmapReadReg>:

alt_u32 uliRmapReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
81108ed8:	defffc04 	addi	sp,sp,-16
81108edc:	de00012e 	bgeu	sp,et,81108ee4 <uliRmapReadReg+0xc>
81108ee0:	003b68fa 	trap	3
81108ee4:	df000315 	stw	fp,12(sp)
81108ee8:	df000304 	addi	fp,sp,12
81108eec:	e13ffe15 	stw	r4,-8(fp)
81108ef0:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81108ef4:	e0bfff17 	ldw	r2,-4(fp)
81108ef8:	1085883a 	add	r2,r2,r2
81108efc:	1085883a 	add	r2,r2,r2
81108f00:	1007883a 	mov	r3,r2
81108f04:	e0bffe17 	ldw	r2,-8(fp)
81108f08:	10c5883a 	add	r2,r2,r3
81108f0c:	10800017 	ldw	r2,0(r2)
81108f10:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81108f14:	e0bffd17 	ldw	r2,-12(fp)
}
81108f18:	e037883a 	mov	sp,fp
81108f1c:	df000017 	ldw	fp,0(sp)
81108f20:	dec00104 	addi	sp,sp,4
81108f24:	f800283a 	ret

81108f28 <uliConvRmapCfgAddr>:

static alt_u32 uliConvRmapCfgAddr(alt_u32 puliRmapAddr) {
81108f28:	defffd04 	addi	sp,sp,-12
81108f2c:	de00012e 	bgeu	sp,et,81108f34 <uliConvRmapCfgAddr+0xc>
81108f30:	003b68fa 	trap	3
81108f34:	df000215 	stw	fp,8(sp)
81108f38:	df000204 	addi	fp,sp,8
81108f3c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliValue;

	switch (puliRmapAddr) {
81108f40:	e0bfff17 	ldw	r2,-4(fp)
81108f44:	10801368 	cmpgeui	r2,r2,77
81108f48:	10008a1e 	bne	r2,zero,81109174 <uliConvRmapCfgAddr+0x24c>
81108f4c:	e0bfff17 	ldw	r2,-4(fp)
81108f50:	100690ba 	slli	r3,r2,2
81108f54:	00a04474 	movhi	r2,33041
81108f58:	10a3da04 	addi	r2,r2,-28824
81108f5c:	1885883a 	add	r2,r3,r2
81108f60:	10800017 	ldw	r2,0(r2)
81108f64:	1000683a 	jmp	r2
81108f68:	8110909c 	xori	r4,r16,16962
81108f6c:	81109174 	orhi	r4,r16,16965
81108f70:	81109174 	orhi	r4,r16,16965
81108f74:	81109174 	orhi	r4,r16,16965
81108f78:	811090a8 	cmpgeui	r4,r16,16962
81108f7c:	81109174 	orhi	r4,r16,16965
81108f80:	81109174 	orhi	r4,r16,16965
81108f84:	81109174 	orhi	r4,r16,16965
81108f88:	811090b4 	orhi	r4,r16,16962
81108f8c:	81109174 	orhi	r4,r16,16965
81108f90:	81109174 	orhi	r4,r16,16965
81108f94:	81109174 	orhi	r4,r16,16965
81108f98:	811090c0 	call	8811090c <__reset+0x20f090c>
81108f9c:	81109174 	orhi	r4,r16,16965
81108fa0:	81109174 	orhi	r4,r16,16965
81108fa4:	81109174 	orhi	r4,r16,16965
81108fa8:	811090cc 	andi	r4,r16,16963
81108fac:	81109174 	orhi	r4,r16,16965
81108fb0:	81109174 	orhi	r4,r16,16965
81108fb4:	81109174 	orhi	r4,r16,16965
81108fb8:	811090d8 	cmpnei	r4,r16,16963
81108fbc:	81109174 	orhi	r4,r16,16965
81108fc0:	81109174 	orhi	r4,r16,16965
81108fc4:	81109174 	orhi	r4,r16,16965
81108fc8:	811090e4 	muli	r4,r16,16963
81108fcc:	81109174 	orhi	r4,r16,16965
81108fd0:	81109174 	orhi	r4,r16,16965
81108fd4:	81109174 	orhi	r4,r16,16965
81108fd8:	811090f0 	cmpltui	r4,r16,16963
81108fdc:	81109174 	orhi	r4,r16,16965
81108fe0:	81109174 	orhi	r4,r16,16965
81108fe4:	81109174 	orhi	r4,r16,16965
81108fe8:	811090fc 	xorhi	r4,r16,16963
81108fec:	81109174 	orhi	r4,r16,16965
81108ff0:	81109174 	orhi	r4,r16,16965
81108ff4:	81109174 	orhi	r4,r16,16965
81108ff8:	81109108 	cmpgei	r4,r16,16964
81108ffc:	81109174 	orhi	r4,r16,16965
81109000:	81109174 	orhi	r4,r16,16965
81109004:	81109174 	orhi	r4,r16,16965
81109008:	81109114 	ori	r4,r16,16964
8110900c:	81109174 	orhi	r4,r16,16965
81109010:	81109174 	orhi	r4,r16,16965
81109014:	81109174 	orhi	r4,r16,16965
81109018:	81109120 	cmpeqi	r4,r16,16964
8110901c:	81109174 	orhi	r4,r16,16965
81109020:	81109174 	orhi	r4,r16,16965
81109024:	81109174 	orhi	r4,r16,16965
81109028:	81109174 	orhi	r4,r16,16965
8110902c:	81109174 	orhi	r4,r16,16965
81109030:	81109174 	orhi	r4,r16,16965
81109034:	81109174 	orhi	r4,r16,16965
81109038:	81109174 	orhi	r4,r16,16965
8110903c:	81109174 	orhi	r4,r16,16965
81109040:	81109174 	orhi	r4,r16,16965
81109044:	81109174 	orhi	r4,r16,16965
81109048:	8110912c 	andhi	r4,r16,16964
8110904c:	81109174 	orhi	r4,r16,16965
81109050:	81109174 	orhi	r4,r16,16965
81109054:	81109174 	orhi	r4,r16,16965
81109058:	81109138 	rdprs	r4,r16,16964
8110905c:	81109174 	orhi	r4,r16,16965
81109060:	81109174 	orhi	r4,r16,16965
81109064:	81109174 	orhi	r4,r16,16965
81109068:	81109144 	addi	r4,r16,16965
8110906c:	81109174 	orhi	r4,r16,16965
81109070:	81109174 	orhi	r4,r16,16965
81109074:	81109174 	orhi	r4,r16,16965
81109078:	81109150 	cmplti	r4,r16,16965
8110907c:	81109174 	orhi	r4,r16,16965
81109080:	81109174 	orhi	r4,r16,16965
81109084:	81109174 	orhi	r4,r16,16965
81109088:	8110915c 	xori	r4,r16,16965
8110908c:	81109174 	orhi	r4,r16,16965
81109090:	81109174 	orhi	r4,r16,16965
81109094:	81109174 	orhi	r4,r16,16965
81109098:	81109168 	cmpgeui	r4,r16,16965
	case 0x00000000:
		uliValue = 0x00000040;
8110909c:	00801004 	movi	r2,64
811090a0:	e0bffe15 	stw	r2,-8(fp)
		break;
811090a4:	00003506 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000004:
		uliValue = 0x00000041;
811090a8:	00801044 	movi	r2,65
811090ac:	e0bffe15 	stw	r2,-8(fp)
		break;
811090b0:	00003206 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000008:
		uliValue = 0x00000042;
811090b4:	00801084 	movi	r2,66
811090b8:	e0bffe15 	stw	r2,-8(fp)
		break;
811090bc:	00002f06 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x0000000C:
		uliValue = 0x00000043;
811090c0:	008010c4 	movi	r2,67
811090c4:	e0bffe15 	stw	r2,-8(fp)
		break;
811090c8:	00002c06 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000010:
		uliValue = 0x00000044;
811090cc:	00801104 	movi	r2,68
811090d0:	e0bffe15 	stw	r2,-8(fp)
		break;
811090d4:	00002906 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000014:
		uliValue = 0x00000045;
811090d8:	00801144 	movi	r2,69
811090dc:	e0bffe15 	stw	r2,-8(fp)
		break;
811090e0:	00002606 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000018:
		uliValue = 0x00000046;
811090e4:	00801184 	movi	r2,70
811090e8:	e0bffe15 	stw	r2,-8(fp)
		break;
811090ec:	00002306 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x0000001C:
		uliValue = 0x00000047;
811090f0:	008011c4 	movi	r2,71
811090f4:	e0bffe15 	stw	r2,-8(fp)
		break;
811090f8:	00002006 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000020:
		uliValue = 0x00000048;
811090fc:	00801204 	movi	r2,72
81109100:	e0bffe15 	stw	r2,-8(fp)
		break;
81109104:	00001d06 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000024:
		uliValue = 0x00000049;
81109108:	00801244 	movi	r2,73
8110910c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109110:	00001a06 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000028:
		uliValue = 0x0000004A;
81109114:	00801284 	movi	r2,74
81109118:	e0bffe15 	stw	r2,-8(fp)
		break;
8110911c:	00001706 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x0000002C:
		uliValue = 0x0000004B;
81109120:	008012c4 	movi	r2,75
81109124:	e0bffe15 	stw	r2,-8(fp)
		break;
81109128:	00001406 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000038:
		uliValue = 0x0000004C;
8110912c:	00801304 	movi	r2,76
81109130:	e0bffe15 	stw	r2,-8(fp)
		break;
81109134:	00001106 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x0000003C:
		uliValue = 0x0000004D;
81109138:	00801344 	movi	r2,77
8110913c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109140:	00000e06 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000040:
		uliValue = 0x0000004E;
81109144:	00801384 	movi	r2,78
81109148:	e0bffe15 	stw	r2,-8(fp)
		break;
8110914c:	00000b06 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000044:
		uliValue = 0x0000004F;
81109150:	008013c4 	movi	r2,79
81109154:	e0bffe15 	stw	r2,-8(fp)
		break;
81109158:	00000806 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x00000048:
		uliValue = 0x00000050;
8110915c:	00801404 	movi	r2,80
81109160:	e0bffe15 	stw	r2,-8(fp)
		break;
81109164:	00000506 	br	8110917c <uliConvRmapCfgAddr+0x254>
	case 0x0000004C:
		uliValue = 0x00000051;
81109168:	00801444 	movi	r2,81
8110916c:	e0bffe15 	stw	r2,-8(fp)
		break;
81109170:	00000206 	br	8110917c <uliConvRmapCfgAddr+0x254>
	default:
		uliValue = 0x00000000;
81109174:	e03ffe15 	stw	zero,-8(fp)
		break;
81109178:	0001883a 	nop
	}

	return uliValue;
8110917c:	e0bffe17 	ldw	r2,-8(fp)
}
81109180:	e037883a 	mov	sp,fp
81109184:	df000017 	ldw	fp,0(sp)
81109188:	dec00104 	addi	sp,sp,4
8110918c:	f800283a 	ret

81109190 <bSpwcSetLink>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bSpwcSetLink(TSpwcChannel *pxSpwcCh) {
81109190:	defffb04 	addi	sp,sp,-20
81109194:	de00012e 	bgeu	sp,et,8110919c <bSpwcSetLink+0xc>
81109198:	003b68fa 	trap	3
8110919c:	dfc00415 	stw	ra,16(sp)
811091a0:	df000315 	stw	fp,12(sp)
811091a4:	df000304 	addi	fp,sp,12
811091a8:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811091ac:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811091b0:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811091b4:	e0bfff17 	ldw	r2,-4(fp)
811091b8:	10003c26 	beq	r2,zero,811092ac <bSpwcSetLink+0x11c>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811091bc:	e0bfff17 	ldw	r2,-4(fp)
811091c0:	10800017 	ldw	r2,0(r2)
811091c4:	000b883a 	mov	r5,zero
811091c8:	1009883a 	mov	r4,r2
811091cc:	110985c0 	call	8110985c <uliSpwcReadReg>
811091d0:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (pxSpwcCh->xLinkConfig.bAutostart) {
811091d4:	e0bfff17 	ldw	r2,-4(fp)
811091d8:	10800117 	ldw	r2,4(r2)
811091dc:	10000426 	beq	r2,zero,811091f0 <bSpwcSetLink+0x60>
			uliReg |= COMM_SPW_LNKCFG_AUTOSTART_MSK;
811091e0:	e0bffe17 	ldw	r2,-8(fp)
811091e4:	10800114 	ori	r2,r2,4
811091e8:	e0bffe15 	stw	r2,-8(fp)
811091ec:	00000406 	br	81109200 <bSpwcSetLink+0x70>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_AUTOSTART_MSK);
811091f0:	e0fffe17 	ldw	r3,-8(fp)
811091f4:	00bffec4 	movi	r2,-5
811091f8:	1884703a 	and	r2,r3,r2
811091fc:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bLinkStart) {
81109200:	e0bfff17 	ldw	r2,-4(fp)
81109204:	10800217 	ldw	r2,8(r2)
81109208:	10000426 	beq	r2,zero,8110921c <bSpwcSetLink+0x8c>
			uliReg |= COMM_SPW_LNKCFG_LINKSTART_MSK;
8110920c:	e0bffe17 	ldw	r2,-8(fp)
81109210:	10800094 	ori	r2,r2,2
81109214:	e0bffe15 	stw	r2,-8(fp)
81109218:	00000406 	br	8110922c <bSpwcSetLink+0x9c>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_LINKSTART_MSK);
8110921c:	e0fffe17 	ldw	r3,-8(fp)
81109220:	00bfff44 	movi	r2,-3
81109224:	1884703a 	and	r2,r3,r2
81109228:	e0bffe15 	stw	r2,-8(fp)
		}
		if (pxSpwcCh->xLinkConfig.bDisconnect) {
8110922c:	e0bfff17 	ldw	r2,-4(fp)
81109230:	10800317 	ldw	r2,12(r2)
81109234:	10000426 	beq	r2,zero,81109248 <bSpwcSetLink+0xb8>
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
81109238:	e0bffe17 	ldw	r2,-8(fp)
8110923c:	10800054 	ori	r2,r2,1
81109240:	e0bffe15 	stw	r2,-8(fp)
81109244:	00000406 	br	81109258 <bSpwcSetLink+0xc8>
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
81109248:	e0fffe17 	ldw	r3,-8(fp)
8110924c:	00bfff84 	movi	r2,-2
81109250:	1884703a 	and	r2,r3,r2
81109254:	e0bffe15 	stw	r2,-8(fp)
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
81109258:	e0fffe17 	ldw	r3,-8(fp)
8110925c:	00804034 	movhi	r2,256
81109260:	10bfffc4 	addi	r2,r2,-1
81109264:	1884703a 	and	r2,r3,r2
81109268:	e0bffe15 	stw	r2,-8(fp)
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));
8110926c:	e0bfff17 	ldw	r2,-4(fp)
81109270:	10800403 	ldbu	r2,16(r2)
81109274:	10803fcc 	andi	r2,r2,255
81109278:	1004963a 	slli	r2,r2,24
8110927c:	1007883a 	mov	r3,r2
			uliReg |= COMM_SPW_LNKCFG_DISCONNECT_MSK;
		} else {
			uliReg &= (~COMM_SPW_LNKCFG_DISCONNECT_MSK);
		}
		uliReg &= (~COMM_SPW_LNKCFG_TXDIVCNT_MSK);
		uliReg |= (COMM_SPW_LNKCFG_TXDIVCNT_MSK
81109280:	e0bffe17 	ldw	r2,-8(fp)
81109284:	10c4b03a 	or	r2,r2,r3
81109288:	e0bffe15 	stw	r2,-8(fp)
				& (alt_u32)(pxSpwcCh->xLinkConfig.ucTxDivCnt << 24));

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_LINK_CFG_STAT_REG_OFST,
8110928c:	e0bfff17 	ldw	r2,-4(fp)
81109290:	10800017 	ldw	r2,0(r2)
81109294:	e1bffe17 	ldw	r6,-8(fp)
81109298:	000b883a 	mov	r5,zero
8110929c:	1009883a 	mov	r4,r2
811092a0:	11098080 	call	81109808 <vSpwcWriteReg>
				uliReg);
		bStatus = TRUE;
811092a4:	00800044 	movi	r2,1
811092a8:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811092ac:	e0bffd17 	ldw	r2,-12(fp)
}
811092b0:	e037883a 	mov	sp,fp
811092b4:	dfc00117 	ldw	ra,4(sp)
811092b8:	df000017 	ldw	fp,0(sp)
811092bc:	dec00204 	addi	sp,sp,8
811092c0:	f800283a 	ret

811092c4 <bSpwcGetLink>:

bool bSpwcGetLink(TSpwcChannel *pxSpwcCh) {
811092c4:	defffb04 	addi	sp,sp,-20
811092c8:	de00012e 	bgeu	sp,et,811092d0 <bSpwcGetLink+0xc>
811092cc:	003b68fa 	trap	3
811092d0:	dfc00415 	stw	ra,16(sp)
811092d4:	df000315 	stw	fp,12(sp)
811092d8:	df000304 	addi	fp,sp,12
811092dc:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811092e0:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811092e4:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811092e8:	e0bfff17 	ldw	r2,-4(fp)
811092ec:	10002826 	beq	r2,zero,81109390 <bSpwcGetLink+0xcc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811092f0:	e0bfff17 	ldw	r2,-4(fp)
811092f4:	10800017 	ldw	r2,0(r2)
811092f8:	000b883a 	mov	r5,zero
811092fc:	1009883a 	mov	r4,r2
81109300:	110985c0 	call	8110985c <uliSpwcReadReg>
81109304:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKCFG_AUTOSTART_MSK) {
81109308:	e0bffe17 	ldw	r2,-8(fp)
8110930c:	1080010c 	andi	r2,r2,4
81109310:	10000426 	beq	r2,zero,81109324 <bSpwcGetLink+0x60>
			pxSpwcCh->xLinkConfig.bAutostart = TRUE;
81109314:	e0bfff17 	ldw	r2,-4(fp)
81109318:	00c00044 	movi	r3,1
8110931c:	10c00115 	stw	r3,4(r2)
81109320:	00000206 	br	8110932c <bSpwcGetLink+0x68>
		} else {
			pxSpwcCh->xLinkConfig.bAutostart = FALSE;
81109324:	e0bfff17 	ldw	r2,-4(fp)
81109328:	10000115 	stw	zero,4(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_LINKSTART_MSK) {
8110932c:	e0bffe17 	ldw	r2,-8(fp)
81109330:	1080008c 	andi	r2,r2,2
81109334:	10000426 	beq	r2,zero,81109348 <bSpwcGetLink+0x84>
			pxSpwcCh->xLinkConfig.bLinkStart = TRUE;
81109338:	e0bfff17 	ldw	r2,-4(fp)
8110933c:	00c00044 	movi	r3,1
81109340:	10c00215 	stw	r3,8(r2)
81109344:	00000206 	br	81109350 <bSpwcGetLink+0x8c>
		} else {
			pxSpwcCh->xLinkConfig.bLinkStart = FALSE;
81109348:	e0bfff17 	ldw	r2,-4(fp)
8110934c:	10000215 	stw	zero,8(r2)
		}
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
81109350:	e0bffe17 	ldw	r2,-8(fp)
81109354:	1080004c 	andi	r2,r2,1
81109358:	10000426 	beq	r2,zero,8110936c <bSpwcGetLink+0xa8>
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
8110935c:	e0bfff17 	ldw	r2,-4(fp)
81109360:	00c00044 	movi	r3,1
81109364:	10c00315 	stw	r3,12(r2)
81109368:	00000206 	br	81109374 <bSpwcGetLink+0xb0>
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
8110936c:	e0bfff17 	ldw	r2,-4(fp)
81109370:	10000315 	stw	zero,12(r2)
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);
81109374:	e0bffe17 	ldw	r2,-8(fp)
81109378:	1004d63a 	srli	r2,r2,24
		if (uliReg & COMM_SPW_LNKCFG_DISCONNECT_MSK) {
			pxSpwcCh->xLinkConfig.bDisconnect = TRUE;
		} else {
			pxSpwcCh->xLinkConfig.bDisconnect = FALSE;
		}
		pxSpwcCh->xLinkConfig.ucTxDivCnt= (alt_u8)(
8110937c:	1007883a 	mov	r3,r2
81109380:	e0bfff17 	ldw	r2,-4(fp)
81109384:	10c00405 	stb	r3,16(r2)
				(uliReg & COMM_SPW_LNKCFG_TXDIVCNT_MSK) >> 24);

		bStatus = TRUE;
81109388:	00800044 	movi	r2,1
8110938c:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109390:	e0bffd17 	ldw	r2,-12(fp)
}
81109394:	e037883a 	mov	sp,fp
81109398:	dfc00117 	ldw	ra,4(sp)
8110939c:	df000017 	ldw	fp,0(sp)
811093a0:	dec00204 	addi	sp,sp,8
811093a4:	f800283a 	ret

811093a8 <bSpwcGetLinkError>:

bool bSpwcGetLinkError(TSpwcChannel *pxSpwcCh) {
811093a8:	defffb04 	addi	sp,sp,-20
811093ac:	de00012e 	bgeu	sp,et,811093b4 <bSpwcGetLinkError+0xc>
811093b0:	003b68fa 	trap	3
811093b4:	dfc00415 	stw	ra,16(sp)
811093b8:	df000315 	stw	fp,12(sp)
811093bc:	df000304 	addi	fp,sp,12
811093c0:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811093c4:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811093c8:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811093cc:	e0bfff17 	ldw	r2,-4(fp)
811093d0:	10002c26 	beq	r2,zero,81109484 <bSpwcGetLinkError+0xdc>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811093d4:	e0bfff17 	ldw	r2,-4(fp)
811093d8:	10800017 	ldw	r2,0(r2)
811093dc:	000b883a 	mov	r5,zero
811093e0:	1009883a 	mov	r4,r2
811093e4:	110985c0 	call	8110985c <uliSpwcReadReg>
811093e8:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKERR_DISCONNECT_MSK) {
811093ec:	e0bffe17 	ldw	r2,-8(fp)
811093f0:	1080006c 	andhi	r2,r2,1
811093f4:	10000426 	beq	r2,zero,81109408 <bSpwcGetLinkError+0x60>
			pxSpwcCh->xLinkError.bDisconnect = TRUE;
811093f8:	e0bfff17 	ldw	r2,-4(fp)
811093fc:	00c00044 	movi	r3,1
81109400:	10c00515 	stw	r3,20(r2)
81109404:	00000206 	br	81109410 <bSpwcGetLinkError+0x68>
		} else {
			pxSpwcCh->xLinkError.bDisconnect = FALSE;
81109408:	e0bfff17 	ldw	r2,-4(fp)
8110940c:	10000515 	stw	zero,20(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_PARITY_MSK) {
81109410:	e0bffe17 	ldw	r2,-8(fp)
81109414:	108000ac 	andhi	r2,r2,2
81109418:	10000426 	beq	r2,zero,8110942c <bSpwcGetLinkError+0x84>
			pxSpwcCh->xLinkError.bParity = TRUE;
8110941c:	e0bfff17 	ldw	r2,-4(fp)
81109420:	00c00044 	movi	r3,1
81109424:	10c00615 	stw	r3,24(r2)
81109428:	00000206 	br	81109434 <bSpwcGetLinkError+0x8c>
		} else {
			pxSpwcCh->xLinkError.bParity = FALSE;
8110942c:	e0bfff17 	ldw	r2,-4(fp)
81109430:	10000615 	stw	zero,24(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_ESCAPE_MSK) {
81109434:	e0bffe17 	ldw	r2,-8(fp)
81109438:	1080012c 	andhi	r2,r2,4
8110943c:	10000426 	beq	r2,zero,81109450 <bSpwcGetLinkError+0xa8>
			pxSpwcCh->xLinkError.bEscape = TRUE;
81109440:	e0bfff17 	ldw	r2,-4(fp)
81109444:	00c00044 	movi	r3,1
81109448:	10c00715 	stw	r3,28(r2)
8110944c:	00000206 	br	81109458 <bSpwcGetLinkError+0xb0>
		} else {
			pxSpwcCh->xLinkError.bEscape = FALSE;
81109450:	e0bfff17 	ldw	r2,-4(fp)
81109454:	10000715 	stw	zero,28(r2)
		}
		if (uliReg & COMM_SPW_LNKERR_CREDIT_MSK) {
81109458:	e0bffe17 	ldw	r2,-8(fp)
8110945c:	1080022c 	andhi	r2,r2,8
81109460:	10000426 	beq	r2,zero,81109474 <bSpwcGetLinkError+0xcc>
			pxSpwcCh->xLinkError.bCredit = TRUE;
81109464:	e0bfff17 	ldw	r2,-4(fp)
81109468:	00c00044 	movi	r3,1
8110946c:	10c00815 	stw	r3,32(r2)
81109470:	00000206 	br	8110947c <bSpwcGetLinkError+0xd4>
		} else {
			pxSpwcCh->xLinkError.bCredit = FALSE;
81109474:	e0bfff17 	ldw	r2,-4(fp)
81109478:	10000815 	stw	zero,32(r2)
		}

		bStatus = TRUE;
8110947c:	00800044 	movi	r2,1
81109480:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109484:	e0bffd17 	ldw	r2,-12(fp)
}
81109488:	e037883a 	mov	sp,fp
8110948c:	dfc00117 	ldw	ra,4(sp)
81109490:	df000017 	ldw	fp,0(sp)
81109494:	dec00204 	addi	sp,sp,8
81109498:	f800283a 	ret

8110949c <bSpwcGetLinkStatus>:

bool bSpwcGetLinkStatus(TSpwcChannel *pxSpwcCh) {
8110949c:	defffb04 	addi	sp,sp,-20
811094a0:	de00012e 	bgeu	sp,et,811094a8 <bSpwcGetLinkStatus+0xc>
811094a4:	003b68fa 	trap	3
811094a8:	dfc00415 	stw	ra,16(sp)
811094ac:	df000315 	stw	fp,12(sp)
811094b0:	df000304 	addi	fp,sp,12
811094b4:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
811094b8:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
811094bc:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
811094c0:	e0bfff17 	ldw	r2,-4(fp)
811094c4:	10002326 	beq	r2,zero,81109554 <bSpwcGetLinkStatus+0xb8>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
811094c8:	e0bfff17 	ldw	r2,-4(fp)
811094cc:	10800017 	ldw	r2,0(r2)
811094d0:	000b883a 	mov	r5,zero
811094d4:	1009883a 	mov	r4,r2
811094d8:	110985c0 	call	8110985c <uliSpwcReadReg>
811094dc:	e0bffe15 	stw	r2,-8(fp)
		COMM_LINK_CFG_STAT_REG_OFST);

		if (uliReg & COMM_SPW_LNKSTAT_STARTED_MSK) {
811094e0:	e0bffe17 	ldw	r2,-8(fp)
811094e4:	1081000c 	andi	r2,r2,1024
811094e8:	10000426 	beq	r2,zero,811094fc <bSpwcGetLinkStatus+0x60>
			pxSpwcCh->xLinkStatus.bStarted = TRUE;
811094ec:	e0bfff17 	ldw	r2,-4(fp)
811094f0:	00c00044 	movi	r3,1
811094f4:	10c00915 	stw	r3,36(r2)
811094f8:	00000206 	br	81109504 <bSpwcGetLinkStatus+0x68>
		} else {
			pxSpwcCh->xLinkStatus.bStarted = FALSE;
811094fc:	e0bfff17 	ldw	r2,-4(fp)
81109500:	10000915 	stw	zero,36(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_CONNECTING_MSK) {
81109504:	e0bffe17 	ldw	r2,-8(fp)
81109508:	1080800c 	andi	r2,r2,512
8110950c:	10000426 	beq	r2,zero,81109520 <bSpwcGetLinkStatus+0x84>
			pxSpwcCh->xLinkStatus.bConnecting = TRUE;
81109510:	e0bfff17 	ldw	r2,-4(fp)
81109514:	00c00044 	movi	r3,1
81109518:	10c00a15 	stw	r3,40(r2)
8110951c:	00000206 	br	81109528 <bSpwcGetLinkStatus+0x8c>
		} else {
			pxSpwcCh->xLinkStatus.bConnecting = FALSE;
81109520:	e0bfff17 	ldw	r2,-4(fp)
81109524:	10000a15 	stw	zero,40(r2)
		}
		if (uliReg & COMM_SPW_LNKSTAT_RUNNING_MSK) {
81109528:	e0bffe17 	ldw	r2,-8(fp)
8110952c:	1080400c 	andi	r2,r2,256
81109530:	10000426 	beq	r2,zero,81109544 <bSpwcGetLinkStatus+0xa8>
			pxSpwcCh->xLinkStatus.bRunning = TRUE;
81109534:	e0bfff17 	ldw	r2,-4(fp)
81109538:	00c00044 	movi	r3,1
8110953c:	10c00b15 	stw	r3,44(r2)
81109540:	00000206 	br	8110954c <bSpwcGetLinkStatus+0xb0>
		} else {
			pxSpwcCh->xLinkStatus.bRunning = FALSE;
81109544:	e0bfff17 	ldw	r2,-4(fp)
81109548:	10000b15 	stw	zero,44(r2)
		}

		bStatus = TRUE;
8110954c:	00800044 	movi	r2,1
81109550:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
81109554:	e0bffd17 	ldw	r2,-12(fp)
}
81109558:	e037883a 	mov	sp,fp
8110955c:	dfc00117 	ldw	ra,4(sp)
81109560:	df000017 	ldw	fp,0(sp)
81109564:	dec00204 	addi	sp,sp,8
81109568:	f800283a 	ret

8110956c <bSpwcGetTimecode>:

bool bSpwcGetTimecode(TSpwcChannel *pxSpwcCh) {
8110956c:	defffb04 	addi	sp,sp,-20
81109570:	de00012e 	bgeu	sp,et,81109578 <bSpwcGetTimecode+0xc>
81109574:	003b68fa 	trap	3
81109578:	dfc00415 	stw	ra,16(sp)
8110957c:	df000315 	stw	fp,12(sp)
81109580:	df000304 	addi	fp,sp,12
81109584:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109588:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110958c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109590:	e0bfff17 	ldw	r2,-4(fp)
81109594:	10001326 	beq	r2,zero,811095e4 <bSpwcGetTimecode+0x78>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109598:	e0bfff17 	ldw	r2,-4(fp)
8110959c:	10800017 	ldw	r2,0(r2)
811095a0:	01400044 	movi	r5,1
811095a4:	1009883a 	mov	r4,r2
811095a8:	110985c0 	call	8110985c <uliSpwcReadReg>
811095ac:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
811095b0:	e0bffe17 	ldw	r2,-8(fp)
811095b4:	1080300c 	andi	r2,r2,192
811095b8:	1004d1ba 	srli	r2,r2,6

	if (pxSpwcCh != NULL) {
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
		COMM_TIMECODE_REG_OFST);

		pxSpwcCh->xTimecode.ucControl= (alt_u8)(
811095bc:	1007883a 	mov	r3,r2
811095c0:	e0bfff17 	ldw	r2,-4(fp)
811095c4:	10c00c05 	stb	r3,48(r2)
				(uliReg & COMM_TIMECODE_CONTROL_MSK) >> 6);
		pxSpwcCh->xTimecode.ucCounter= (alt_u8)(
811095c8:	e0bffe17 	ldw	r2,-8(fp)
811095cc:	10800fcc 	andi	r2,r2,63
811095d0:	1007883a 	mov	r3,r2
811095d4:	e0bfff17 	ldw	r2,-4(fp)
811095d8:	10c00c45 	stb	r3,49(r2)
				(uliReg & COMM_TIMECODE_TIME_MSK) >> 0);

		bStatus = TRUE;
811095dc:	00800044 	movi	r2,1
811095e0:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
811095e4:	e0bffd17 	ldw	r2,-12(fp)
}
811095e8:	e037883a 	mov	sp,fp
811095ec:	dfc00117 	ldw	ra,4(sp)
811095f0:	df000017 	ldw	fp,0(sp)
811095f4:	dec00204 	addi	sp,sp,8
811095f8:	f800283a 	ret

811095fc <bSpwcClearTimecode>:

bool bSpwcClearTimecode(TSpwcChannel *pxSpwcCh) {
811095fc:	defffb04 	addi	sp,sp,-20
81109600:	de00012e 	bgeu	sp,et,81109608 <bSpwcClearTimecode+0xc>
81109604:	003b68fa 	trap	3
81109608:	dfc00415 	stw	ra,16(sp)
8110960c:	df000315 	stw	fp,12(sp)
81109610:	df000304 	addi	fp,sp,12
81109614:	e13fff15 	stw	r4,-4(fp)
	bool bStatus = FALSE;
81109618:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 uliReg = 0;
8110961c:	e03ffe15 	stw	zero,-8(fp)

	if (pxSpwcCh != NULL) {
81109620:	e0bfff17 	ldw	r2,-4(fp)
81109624:	10001126 	beq	r2,zero,8110966c <bSpwcClearTimecode+0x70>
		uliReg = uliSpwcReadReg(pxSpwcCh->puliSpwcChAddr,
81109628:	e0bfff17 	ldw	r2,-4(fp)
8110962c:	10800017 	ldw	r2,0(r2)
81109630:	01400044 	movi	r5,1
81109634:	1009883a 	mov	r4,r2
81109638:	110985c0 	call	8110985c <uliSpwcReadReg>
8110963c:	e0bffe15 	stw	r2,-8(fp)
		COMM_TIMECODE_REG_OFST);

		uliReg |= COMM_TIMECODE_CLR_MSK;
81109640:	e0bffe17 	ldw	r2,-8(fp)
81109644:	10804014 	ori	r2,r2,256
81109648:	e0bffe15 	stw	r2,-8(fp)

		vSpwcWriteReg(pxSpwcCh->puliSpwcChAddr, COMM_TIMECODE_REG_OFST, uliReg);
8110964c:	e0bfff17 	ldw	r2,-4(fp)
81109650:	10800017 	ldw	r2,0(r2)
81109654:	e1bffe17 	ldw	r6,-8(fp)
81109658:	01400044 	movi	r5,1
8110965c:	1009883a 	mov	r4,r2
81109660:	11098080 	call	81109808 <vSpwcWriteReg>
		bStatus = TRUE;
81109664:	00800044 	movi	r2,1
81109668:	e0bffd15 	stw	r2,-12(fp)
	}

	return bStatus;
8110966c:	e0bffd17 	ldw	r2,-12(fp)
}
81109670:	e037883a 	mov	sp,fp
81109674:	dfc00117 	ldw	ra,4(sp)
81109678:	df000017 	ldw	fp,0(sp)
8110967c:	dec00204 	addi	sp,sp,8
81109680:	f800283a 	ret

81109684 <bSpwcInitCh>:

bool bSpwcInitCh(TSpwcChannel *pxSpwcCh, alt_u8 ucCommCh) {
81109684:	defffb04 	addi	sp,sp,-20
81109688:	de00012e 	bgeu	sp,et,81109690 <bSpwcInitCh+0xc>
8110968c:	003b68fa 	trap	3
81109690:	dfc00415 	stw	ra,16(sp)
81109694:	df000315 	stw	fp,12(sp)
81109698:	df000304 	addi	fp,sp,12
8110969c:	e13ffe15 	stw	r4,-8(fp)
811096a0:	2805883a 	mov	r2,r5
811096a4:	e0bfff05 	stb	r2,-4(fp)
	bool bStatus = FALSE;
811096a8:	e03ffd15 	stw	zero,-12(fp)

	if (pxSpwcCh != NULL) {
811096ac:	e0bffe17 	ldw	r2,-8(fp)
811096b0:	10004f26 	beq	r2,zero,811097f0 <bSpwcInitCh+0x16c>
		bStatus = TRUE;
811096b4:	00800044 	movi	r2,1
811096b8:	e0bffd15 	stw	r2,-12(fp)

		switch (ucCommCh) {
811096bc:	e0bfff03 	ldbu	r2,-4(fp)
811096c0:	10c00228 	cmpgeui	r3,r2,8
811096c4:	1800361e 	bne	r3,zero,811097a0 <bSpwcInitCh+0x11c>
811096c8:	100690ba 	slli	r3,r2,2
811096cc:	00a04474 	movhi	r2,33041
811096d0:	10a5b804 	addi	r2,r2,-26912
811096d4:	1885883a 	add	r2,r3,r2
811096d8:	10800017 	ldw	r2,0(r2)
811096dc:	1000683a 	jmp	r2
811096e0:	81109700 	call	88110970 <__reset+0x20f0970>
811096e4:	81109714 	ori	r4,r16,16988
811096e8:	81109728 	cmpgeui	r4,r16,16988
811096ec:	8110973c 	xorhi	r4,r16,16988
811096f0:	81109750 	cmplti	r4,r16,16989
811096f4:	81109764 	muli	r4,r16,16989
811096f8:	81109778 	rdprs	r4,r16,16989
811096fc:	8110978c 	andi	r4,r16,16990
		case eCommSpwCh1:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_1_BASE_ADDR;
81109700:	e0fffe17 	ldw	r3,-8(fp)
81109704:	00a04834 	movhi	r2,33056
81109708:	108b0004 	addi	r2,r2,11264
8110970c:	18800015 	stw	r2,0(r3)
			break;
81109710:	00002506 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh2:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_2_BASE_ADDR;
81109714:	e0fffe17 	ldw	r3,-8(fp)
81109718:	00a04834 	movhi	r2,33056
8110971c:	108a0004 	addi	r2,r2,10240
81109720:	18800015 	stw	r2,0(r3)
			break;
81109724:	00002006 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh3:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_3_BASE_ADDR;
81109728:	e0fffe17 	ldw	r3,-8(fp)
8110972c:	00a04834 	movhi	r2,33056
81109730:	10890004 	addi	r2,r2,9216
81109734:	18800015 	stw	r2,0(r3)
			break;
81109738:	00001b06 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh4:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_4_BASE_ADDR;
8110973c:	e0fffe17 	ldw	r3,-8(fp)
81109740:	00a04834 	movhi	r2,33056
81109744:	10880004 	addi	r2,r2,8192
81109748:	18800015 	stw	r2,0(r3)
			break;
8110974c:	00001606 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh5:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_5_BASE_ADDR;
81109750:	e0fffe17 	ldw	r3,-8(fp)
81109754:	00a04834 	movhi	r2,33056
81109758:	10870004 	addi	r2,r2,7168
8110975c:	18800015 	stw	r2,0(r3)
			break;
81109760:	00001106 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh6:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_6_BASE_ADDR;
81109764:	e0fffe17 	ldw	r3,-8(fp)
81109768:	00a04834 	movhi	r2,33056
8110976c:	10860004 	addi	r2,r2,6144
81109770:	18800015 	stw	r2,0(r3)
			break;
81109774:	00000c06 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh7:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_7_BASE_ADDR;
81109778:	e0fffe17 	ldw	r3,-8(fp)
8110977c:	00a04834 	movhi	r2,33056
81109780:	10850004 	addi	r2,r2,5120
81109784:	18800015 	stw	r2,0(r3)
			break;
81109788:	00000706 	br	811097a8 <bSpwcInitCh+0x124>
		case eCommSpwCh8:
			pxSpwcCh->puliSpwcChAddr = (alt_u32 *) COMM_CHANNEL_8_BASE_ADDR;
8110978c:	e0fffe17 	ldw	r3,-8(fp)
81109790:	00a04834 	movhi	r2,33056
81109794:	10840004 	addi	r2,r2,4096
81109798:	18800015 	stw	r2,0(r3)
			break;
8110979c:	00000206 	br	811097a8 <bSpwcInitCh+0x124>
		default:
			bStatus = FALSE;
811097a0:	e03ffd15 	stw	zero,-12(fp)
			break;
811097a4:	0001883a 	nop
		}

		if (bStatus) {
811097a8:	e0bffd17 	ldw	r2,-12(fp)
811097ac:	10001026 	beq	r2,zero,811097f0 <bSpwcInitCh+0x16c>
			if (!bSpwcGetLink(pxSpwcCh)) {
811097b0:	e13ffe17 	ldw	r4,-8(fp)
811097b4:	11092c40 	call	811092c4 <bSpwcGetLink>
811097b8:	1000011e 	bne	r2,zero,811097c0 <bSpwcInitCh+0x13c>
				bStatus = FALSE;
811097bc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkError(pxSpwcCh)) {
811097c0:	e13ffe17 	ldw	r4,-8(fp)
811097c4:	11093a80 	call	811093a8 <bSpwcGetLinkError>
811097c8:	1000011e 	bne	r2,zero,811097d0 <bSpwcInitCh+0x14c>
				bStatus = FALSE;
811097cc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetLinkStatus(pxSpwcCh)) {
811097d0:	e13ffe17 	ldw	r4,-8(fp)
811097d4:	110949c0 	call	8110949c <bSpwcGetLinkStatus>
811097d8:	1000011e 	bne	r2,zero,811097e0 <bSpwcInitCh+0x15c>
				bStatus = FALSE;
811097dc:	e03ffd15 	stw	zero,-12(fp)
			}
			if (!bSpwcGetTimecode(pxSpwcCh)) {
811097e0:	e13ffe17 	ldw	r4,-8(fp)
811097e4:	110956c0 	call	8110956c <bSpwcGetTimecode>
811097e8:	1000011e 	bne	r2,zero,811097f0 <bSpwcInitCh+0x16c>
				bStatus = FALSE;
811097ec:	e03ffd15 	stw	zero,-12(fp)
			}
		}
	}
	return bStatus;
811097f0:	e0bffd17 	ldw	r2,-12(fp)
}
811097f4:	e037883a 	mov	sp,fp
811097f8:	dfc00117 	ldw	ra,4(sp)
811097fc:	df000017 	ldw	fp,0(sp)
81109800:	dec00204 	addi	sp,sp,8
81109804:	f800283a 	ret

81109808 <vSpwcWriteReg>:
//! [public functions]

//! [private functions]
static void vSpwcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
81109808:	defffc04 	addi	sp,sp,-16
8110980c:	de00012e 	bgeu	sp,et,81109814 <vSpwcWriteReg+0xc>
81109810:	003b68fa 	trap	3
81109814:	df000315 	stw	fp,12(sp)
81109818:	df000304 	addi	fp,sp,12
8110981c:	e13ffd15 	stw	r4,-12(fp)
81109820:	e17ffe15 	stw	r5,-8(fp)
81109824:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
81109828:	e0bffe17 	ldw	r2,-8(fp)
8110982c:	1085883a 	add	r2,r2,r2
81109830:	1085883a 	add	r2,r2,r2
81109834:	1007883a 	mov	r3,r2
81109838:	e0bffd17 	ldw	r2,-12(fp)
8110983c:	10c5883a 	add	r2,r2,r3
81109840:	e0ffff17 	ldw	r3,-4(fp)
81109844:	10c00015 	stw	r3,0(r2)
}
81109848:	0001883a 	nop
8110984c:	e037883a 	mov	sp,fp
81109850:	df000017 	ldw	fp,0(sp)
81109854:	dec00104 	addi	sp,sp,4
81109858:	f800283a 	ret

8110985c <uliSpwcReadReg>:

static alt_u32 uliSpwcReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110985c:	defffc04 	addi	sp,sp,-16
81109860:	de00012e 	bgeu	sp,et,81109868 <uliSpwcReadReg+0xc>
81109864:	003b68fa 	trap	3
81109868:	df000315 	stw	fp,12(sp)
8110986c:	df000304 	addi	fp,sp,12
81109870:	e13ffe15 	stw	r4,-8(fp)
81109874:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
81109878:	e0bfff17 	ldw	r2,-4(fp)
8110987c:	1085883a 	add	r2,r2,r2
81109880:	1085883a 	add	r2,r2,r2
81109884:	1007883a 	mov	r3,r2
81109888:	e0bffe17 	ldw	r2,-8(fp)
8110988c:	10c5883a 	add	r2,r2,r3
81109890:	10800017 	ldw	r2,0(r2)
81109894:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
81109898:	e0bffd17 	ldw	r2,-12(fp)
}
8110989c:	e037883a 	mov	sp,fp
811098a0:	df000017 	ldw	fp,0(sp)
811098a4:	dec00104 	addi	sp,sp,4
811098a8:	f800283a 	ret

811098ac <bEnableIsoDrivers>:
//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
bool bEnableIsoDrivers(void)
{
811098ac:	defffe04 	addi	sp,sp,-8
811098b0:	de00012e 	bgeu	sp,et,811098b8 <bEnableIsoDrivers+0xc>
811098b4:	003b68fa 	trap	3
811098b8:	dfc00115 	stw	ra,4(sp)
811098bc:	df000015 	stw	fp,0(sp)
811098c0:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_EN_ISO_DRIVERS_MSK);
811098c4:	01400204 	movi	r5,8
811098c8:	01000044 	movi	r4,1
811098cc:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
  return  TRUE;
811098d0:	00800044 	movi	r2,1
}
811098d4:	e037883a 	mov	sp,fp
811098d8:	dfc00117 	ldw	ra,4(sp)
811098dc:	df000017 	ldw	fp,0(sp)
811098e0:	dec00204 	addi	sp,sp,8
811098e4:	f800283a 	ret

811098e8 <bDisableIsoDrivers>:

bool bDisableIsoDrivers(void)
{
811098e8:	defffe04 	addi	sp,sp,-8
811098ec:	de00012e 	bgeu	sp,et,811098f4 <bDisableIsoDrivers+0xc>
811098f0:	003b68fa 	trap	3
811098f4:	dfc00115 	stw	ra,4(sp)
811098f8:	df000015 	stw	fp,0(sp)
811098fc:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_EN_ISO_DRIVERS_MSK);
81109900:	01400204 	movi	r5,8
81109904:	0009883a 	mov	r4,zero
81109908:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
  return  TRUE;
8110990c:	00800044 	movi	r2,1
}
81109910:	e037883a 	mov	sp,fp
81109914:	dfc00117 	ldw	ra,4(sp)
81109918:	df000017 	ldw	fp,0(sp)
8110991c:	dec00204 	addi	sp,sp,8
81109920:	f800283a 	ret

81109924 <bEnableLvdsBoard>:

bool bEnableLvdsBoard(void)
{
81109924:	defffe04 	addi	sp,sp,-8
81109928:	de00012e 	bgeu	sp,et,81109930 <bEnableLvdsBoard+0xc>
8110992c:	003b68fa 	trap	3
81109930:	dfc00115 	stw	ra,4(sp)
81109934:	df000015 	stw	fp,0(sp)
81109938:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PWDN_MSK);
8110993c:	01400104 	movi	r5,4
81109940:	01000044 	movi	r4,1
81109944:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
  return  TRUE;
81109948:	00800044 	movi	r2,1
}
8110994c:	e037883a 	mov	sp,fp
81109950:	dfc00117 	ldw	ra,4(sp)
81109954:	df000017 	ldw	fp,0(sp)
81109958:	dec00204 	addi	sp,sp,8
8110995c:	f800283a 	ret

81109960 <bDisableLvdsBoard>:

bool bDisableLvdsBoard(void)
{
81109960:	defffe04 	addi	sp,sp,-8
81109964:	de00012e 	bgeu	sp,et,8110996c <bDisableLvdsBoard+0xc>
81109968:	003b68fa 	trap	3
8110996c:	dfc00115 	stw	ra,4(sp)
81109970:	df000015 	stw	fp,0(sp)
81109974:	d839883a 	mov	fp,sp
  bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PWDN_MSK);
81109978:	01400104 	movi	r5,4
8110997c:	0009883a 	mov	r4,zero
81109980:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
  return  TRUE;
81109984:	00800044 	movi	r2,1
}
81109988:	e037883a 	mov	sp,fp
8110998c:	dfc00117 	ldw	ra,4(sp)
81109990:	df000017 	ldw	fp,0(sp)
81109994:	dec00204 	addi	sp,sp,8
81109998:	f800283a 	ret

8110999c <bSetPreEmphasys>:

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
8110999c:	defffd04 	addi	sp,sp,-12
811099a0:	de00012e 	bgeu	sp,et,811099a8 <bSetPreEmphasys+0xc>
811099a4:	003b68fa 	trap	3
811099a8:	dfc00215 	stw	ra,8(sp)
811099ac:	df000115 	stw	fp,4(sp)
811099b0:	df000104 	addi	fp,sp,4
811099b4:	2005883a 	mov	r2,r4
811099b8:	e0bfff05 	stb	r2,-4(fp)
  switch (ucPemLevel) {
811099bc:	e0bfff03 	ldbu	r2,-4(fp)
811099c0:	10c00060 	cmpeqi	r3,r2,1
811099c4:	18000d1e 	bne	r3,zero,811099fc <bSetPreEmphasys+0x60>
811099c8:	10c00088 	cmpgei	r3,r2,2
811099cc:	1800021e 	bne	r3,zero,811099d8 <bSetPreEmphasys+0x3c>
811099d0:	10000626 	beq	r2,zero,811099ec <bSetPreEmphasys+0x50>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811099d4:	00001b06 	br	81109a44 <bSetPreEmphasys+0xa8>
  return  TRUE;
}

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
811099d8:	10c000a0 	cmpeqi	r3,r2,2
811099dc:	18000e1e 	bne	r3,zero,81109a18 <bSetPreEmphasys+0x7c>
811099e0:	108000e0 	cmpeqi	r2,r2,3
811099e4:	1000131e 	bne	r2,zero,81109a34 <bSetPreEmphasys+0x98>
      break;
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
      break;
    default:
      break;
811099e8:	00001606 	br	81109a44 <bSetPreEmphasys+0xa8>

bool bSetPreEmphasys(alt_u8 ucPemLevel)
{
  switch (ucPemLevel) {
    case LVDS_PEM_OFF:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
811099ec:	014000c4 	movi	r5,3
811099f0:	0009883a 	mov	r4,zero
811099f4:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
      break;
811099f8:	00001206 	br	81109a44 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_LO:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM1_MSK);
811099fc:	01400084 	movi	r5,2
81109a00:	0009883a 	mov	r4,zero
81109a04:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM0_MSK);
81109a08:	01400044 	movi	r5,1
81109a0c:	01000044 	movi	r4,1
81109a10:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
      break;
81109a14:	00000b06 	br	81109a44 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_MID:
      bCtrlIoLvdsDrive(LVDS_IO_OFF, LVDS_PEM0_MSK);
81109a18:	01400044 	movi	r5,1
81109a1c:	0009883a 	mov	r4,zero
81109a20:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
      bCtrlIoLvdsDrive(LVDS_IO_ON,  LVDS_PEM1_MSK);
81109a24:	01400084 	movi	r5,2
81109a28:	01000044 	movi	r4,1
81109a2c:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
      break;
81109a30:	00000406 	br	81109a44 <bSetPreEmphasys+0xa8>
    case LVDS_PEM_HI:
      bCtrlIoLvdsDrive(LVDS_IO_ON, LVDS_PEM1_MSK | LVDS_PEM0_MSK);
81109a34:	014000c4 	movi	r5,3
81109a38:	01000044 	movi	r4,1
81109a3c:	1109a5c0 	call	81109a5c <bCtrlIoLvdsDrive>
      break;
81109a40:	0001883a 	nop
    default:
      break;
  }
  return TRUE;
81109a44:	00800044 	movi	r2,1
}
81109a48:	e037883a 	mov	sp,fp
81109a4c:	dfc00117 	ldw	ra,4(sp)
81109a50:	df000017 	ldw	fp,0(sp)
81109a54:	dec00204 	addi	sp,sp,8
81109a58:	f800283a 	ret

81109a5c <bCtrlIoLvdsDrive>:
 * @param [in] ulliMask   -> mascara de i/os a serem alterados
 *
 * @retval TRUE -> sucesso
 */
static bool bCtrlIoLvdsDrive(bool bOnOff, alt_u8 ucMask)
{
81109a5c:	defffd04 	addi	sp,sp,-12
81109a60:	de00012e 	bgeu	sp,et,81109a68 <bCtrlIoLvdsDrive+0xc>
81109a64:	003b68fa 	trap	3
81109a68:	df000215 	stw	fp,8(sp)
81109a6c:	df000204 	addi	fp,sp,8
81109a70:	e13ffe15 	stw	r4,-8(fp)
81109a74:	2805883a 	mov	r2,r5
81109a78:	e0bfff05 	stb	r2,-4(fp)
  if (bOnOff == LVDS_IO_OFF) {
81109a7c:	e0bffe17 	ldw	r2,-8(fp)
81109a80:	1000071e 	bne	r2,zero,81109aa0 <bCtrlIoLvdsDrive+0x44>
	 ucIoValue &= (~ucMask);
81109a84:	e0bfff03 	ldbu	r2,-4(fp)
81109a88:	0084303a 	nor	r2,zero,r2
81109a8c:	1007883a 	mov	r3,r2
81109a90:	d0a00103 	ldbu	r2,-32764(gp)
81109a94:	1884703a 	and	r2,r3,r2
81109a98:	d0a00105 	stb	r2,-32764(gp)
81109a9c:	00000406 	br	81109ab0 <bCtrlIoLvdsDrive+0x54>
  }
  else {
	 ucIoValue |= ucMask;
81109aa0:	d0e00103 	ldbu	r3,-32764(gp)
81109aa4:	e0bfff03 	ldbu	r2,-4(fp)
81109aa8:	1884b03a 	or	r2,r3,r2
81109aac:	d0a00105 	stb	r2,-32764(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LVDS_CTRL_IO_LVDS_ADDR_BASE, ucIoValue);
81109ab0:	d0a00103 	ldbu	r2,-32764(gp)
81109ab4:	10c03fcc 	andi	r3,r2,255
81109ab8:	00a00034 	movhi	r2,32768
81109abc:	10822804 	addi	r2,r2,2208
81109ac0:	10c00035 	stwio	r3,0(r2)
  return TRUE;
81109ac4:	00800044 	movi	r2,1
}
81109ac8:	e037883a 	mov	sp,fp
81109acc:	df000017 	ldw	fp,0(sp)
81109ad0:	dec00104 	addi	sp,sp,4
81109ad4:	f800283a 	ret

81109ad8 <I2C_TestAdress>:
void i2c_start(alt_u32 clk_base, alt_u32 data_base);
void i2c_stop(alt_u32 clk_base, alt_u32 data_base);
bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data);
void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck);

bool I2C_TestAdress(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr){
81109ad8:	defffa04 	addi	sp,sp,-24
81109adc:	de00012e 	bgeu	sp,et,81109ae4 <I2C_TestAdress+0xc>
81109ae0:	003b68fa 	trap	3
81109ae4:	dfc00515 	stw	ra,20(sp)
81109ae8:	df000415 	stw	fp,16(sp)
81109aec:	df000404 	addi	fp,sp,16
81109af0:	e13ffd15 	stw	r4,-12(fp)
81109af4:	e17ffe15 	stw	r5,-8(fp)
81109af8:	3005883a 	mov	r2,r6
81109afc:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109b00:	00800044 	movi	r2,1
81109b04:	e0bffc15 	stw	r2,-16(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109b08:	e17ffe17 	ldw	r5,-8(fp)
81109b0c:	e13ffd17 	ldw	r4,-12(fp)
81109b10:	1109ea80 	call	81109ea8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109b14:	e0bfff03 	ldbu	r2,-4(fp)
81109b18:	10803fcc 	andi	r2,r2,255
81109b1c:	100d883a 	mov	r6,r2
81109b20:	e17ffe17 	ldw	r5,-8(fp)
81109b24:	e13ffd17 	ldw	r4,-12(fp)
81109b28:	1109fbc0 	call	81109fbc <i2c_write>
81109b2c:	1000011e 	bne	r2,zero,81109b34 <I2C_TestAdress+0x5c>
        bSuccess = FALSE;
81109b30:	e03ffc15 	stw	zero,-16(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109b34:	e17ffe17 	ldw	r5,-8(fp)
81109b38:	e13ffd17 	ldw	r4,-12(fp)
81109b3c:	1109f3c0 	call	81109f3c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81109b40:	0106d604 	movi	r4,7000
81109b44:	1133cf00 	call	81133cf0 <usleep>
    
    return bSuccess;
81109b48:	e0bffc17 	ldw	r2,-16(fp)

}
81109b4c:	e037883a 	mov	sp,fp
81109b50:	dfc00117 	ldw	ra,4(sp)
81109b54:	df000017 	ldw	fp,0(sp)
81109b58:	dec00204 	addi	sp,sp,8
81109b5c:	f800283a 	ret

81109b60 <I2C_Write>:

bool I2C_Write(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 ControlData){
81109b60:	defff804 	addi	sp,sp,-32
81109b64:	de00012e 	bgeu	sp,et,81109b6c <I2C_Write+0xc>
81109b68:	003b68fa 	trap	3
81109b6c:	dfc00715 	stw	ra,28(sp)
81109b70:	df000615 	stw	fp,24(sp)
81109b74:	df000604 	addi	fp,sp,24
81109b78:	e13ffb15 	stw	r4,-20(fp)
81109b7c:	e17ffc15 	stw	r5,-16(fp)
81109b80:	3009883a 	mov	r4,r6
81109b84:	3807883a 	mov	r3,r7
81109b88:	e0800217 	ldw	r2,8(fp)
81109b8c:	e13ffd05 	stb	r4,-12(fp)
81109b90:	e0fffe05 	stb	r3,-8(fp)
81109b94:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109b98:	00800044 	movi	r2,1
81109b9c:	e0bffa15 	stw	r2,-24(fp)
    //alt_u8 DeviceAddr;
    
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109ba0:	e17ffc17 	ldw	r5,-16(fp)
81109ba4:	e13ffb17 	ldw	r4,-20(fp)
81109ba8:	1109ea80 	call	81109ea8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109bac:	e0bffd03 	ldbu	r2,-12(fp)
81109bb0:	10803fcc 	andi	r2,r2,255
81109bb4:	100d883a 	mov	r6,r2
81109bb8:	e17ffc17 	ldw	r5,-16(fp)
81109bbc:	e13ffb17 	ldw	r4,-20(fp)
81109bc0:	1109fbc0 	call	81109fbc <i2c_write>
81109bc4:	1000011e 	bne	r2,zero,81109bcc <I2C_Write+0x6c>
        bSuccess = FALSE;
81109bc8:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109bcc:	e0bffa17 	ldw	r2,-24(fp)
81109bd0:	10000726 	beq	r2,zero,81109bf0 <I2C_Write+0x90>
81109bd4:	e0bffe03 	ldbu	r2,-8(fp)
81109bd8:	100d883a 	mov	r6,r2
81109bdc:	e17ffc17 	ldw	r5,-16(fp)
81109be0:	e13ffb17 	ldw	r4,-20(fp)
81109be4:	1109fbc0 	call	81109fbc <i2c_write>
81109be8:	1000011e 	bne	r2,zero,81109bf0 <I2C_Write+0x90>
        bSuccess = FALSE;
81109bec:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    if (bSuccess && !i2c_write(clk_base, data_base, ControlData)){  
81109bf0:	e0bffa17 	ldw	r2,-24(fp)
81109bf4:	10000726 	beq	r2,zero,81109c14 <I2C_Write+0xb4>
81109bf8:	e0bfff03 	ldbu	r2,-4(fp)
81109bfc:	100d883a 	mov	r6,r2
81109c00:	e17ffc17 	ldw	r5,-16(fp)
81109c04:	e13ffb17 	ldw	r4,-20(fp)
81109c08:	1109fbc0 	call	81109fbc <i2c_write>
81109c0c:	1000011e 	bne	r2,zero,81109c14 <I2C_Write+0xb4>
        bSuccess = FALSE;
81109c10:	e03ffa15 	stw	zero,-24(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: write NACK!\n"));
    }
    i2c_stop(clk_base, data_base);
81109c14:	e17ffc17 	ldw	r5,-16(fp)
81109c18:	e13ffb17 	ldw	r4,-20(fp)
81109c1c:	1109f3c0 	call	81109f3c <i2c_stop>
    
    usleep(7*1000); // delay to wait EE2 ready (at least 5 ms delay is required)
81109c20:	0106d604 	movi	r4,7000
81109c24:	1133cf00 	call	81133cf0 <usleep>
    
    return bSuccess;
81109c28:	e0bffa17 	ldw	r2,-24(fp)

}
81109c2c:	e037883a 	mov	sp,fp
81109c30:	dfc00117 	ldw	ra,4(sp)
81109c34:	df000017 	ldw	fp,0(sp)
81109c38:	dec00204 	addi	sp,sp,8
81109c3c:	f800283a 	ret

81109c40 <I2C_Read>:

bool I2C_Read(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 ControlAddr, alt_u8 *pControlData){
81109c40:	defff904 	addi	sp,sp,-28
81109c44:	de00012e 	bgeu	sp,et,81109c4c <I2C_Read+0xc>
81109c48:	003b68fa 	trap	3
81109c4c:	dfc00615 	stw	ra,24(sp)
81109c50:	df000515 	stw	fp,20(sp)
81109c54:	df000504 	addi	fp,sp,20
81109c58:	e13ffc15 	stw	r4,-16(fp)
81109c5c:	e17ffd15 	stw	r5,-12(fp)
81109c60:	3007883a 	mov	r3,r6
81109c64:	3805883a 	mov	r2,r7
81109c68:	e0fffe05 	stb	r3,-8(fp)
81109c6c:	e0bfff05 	stb	r2,-4(fp)
    bool bSuccess = TRUE;
81109c70:	00800044 	movi	r2,1
81109c74:	e0bffb15 	stw	r2,-20(fp)
    //alt_u8 DeviceAddr;
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109c78:	e17ffd17 	ldw	r5,-12(fp)
81109c7c:	e13ffc17 	ldw	r4,-16(fp)
81109c80:	1109ea80 	call	81109ea8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109c84:	e0bffe03 	ldbu	r2,-8(fp)
81109c88:	10803fcc 	andi	r2,r2,255
81109c8c:	100d883a 	mov	r6,r2
81109c90:	e17ffd17 	ldw	r5,-12(fp)
81109c94:	e13ffc17 	ldw	r4,-16(fp)
81109c98:	1109fbc0 	call	81109fbc <i2c_write>
81109c9c:	1000011e 	bne	r2,zero,81109ca4 <I2C_Read+0x64>
        bSuccess = FALSE;
81109ca0:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109ca4:	e0bffb17 	ldw	r2,-20(fp)
81109ca8:	10000726 	beq	r2,zero,81109cc8 <I2C_Read+0x88>
81109cac:	e0bfff03 	ldbu	r2,-4(fp)
81109cb0:	100d883a 	mov	r6,r2
81109cb4:	e17ffd17 	ldw	r5,-12(fp)
81109cb8:	e13ffc17 	ldw	r4,-16(fp)
81109cbc:	1109fbc0 	call	81109fbc <i2c_write>
81109cc0:	1000011e 	bne	r2,zero,81109cc8 <I2C_Read+0x88>
        bSuccess = FALSE;
81109cc4:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }            
    i2c_start(clk_base, data_base);  // restart
81109cc8:	e17ffd17 	ldw	r5,-12(fp)
81109ccc:	e13ffc17 	ldw	r4,-16(fp)
81109cd0:	1109ea80 	call	81109ea8 <i2c_start>
    DeviceAddr |= 1; // Read
81109cd4:	e0bffe03 	ldbu	r2,-8(fp)
81109cd8:	10800054 	ori	r2,r2,1
81109cdc:	e0bffe05 	stb	r2,-8(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109ce0:	e0bffb17 	ldw	r2,-20(fp)
81109ce4:	10000826 	beq	r2,zero,81109d08 <I2C_Read+0xc8>
81109ce8:	e0bffe03 	ldbu	r2,-8(fp)
81109cec:	10803fcc 	andi	r2,r2,255
81109cf0:	100d883a 	mov	r6,r2
81109cf4:	e17ffd17 	ldw	r5,-12(fp)
81109cf8:	e13ffc17 	ldw	r4,-16(fp)
81109cfc:	1109fbc0 	call	81109fbc <i2c_write>
81109d00:	1000011e 	bne	r2,zero,81109d08 <I2C_Read+0xc8>
        bSuccess = FALSE;
81109d04:	e03ffb15 	stw	zero,-20(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109d08:	e0bffb17 	ldw	r2,-20(fp)
81109d0c:	10000526 	beq	r2,zero,81109d24 <I2C_Read+0xe4>
        i2c_read(clk_base, data_base, pControlData, FALSE);  // read
81109d10:	000f883a 	mov	r7,zero
81109d14:	e1800217 	ldw	r6,8(fp)
81109d18:	e17ffd17 	ldw	r5,-12(fp)
81109d1c:	e13ffc17 	ldw	r4,-16(fp)
81109d20:	110a0f40 	call	8110a0f4 <i2c_read>
    }        
    i2c_stop(clk_base, data_base);
81109d24:	e17ffd17 	ldw	r5,-12(fp)
81109d28:	e13ffc17 	ldw	r4,-16(fp)
81109d2c:	1109f3c0 	call	81109f3c <i2c_stop>
    
    return bSuccess;
81109d30:	e0bffb17 	ldw	r2,-20(fp)
}
81109d34:	e037883a 	mov	sp,fp
81109d38:	dfc00117 	ldw	ra,4(sp)
81109d3c:	df000017 	ldw	fp,0(sp)
81109d40:	dec00204 	addi	sp,sp,8
81109d44:	f800283a 	ret

81109d48 <I2C_MultipleRead>:

bool I2C_MultipleRead(alt_u32 clk_base, alt_u32 data_base, alt_8 DeviceAddr, alt_u8 szData[], alt_u16 len){
81109d48:	defff604 	addi	sp,sp,-40
81109d4c:	de00012e 	bgeu	sp,et,81109d54 <I2C_MultipleRead+0xc>
81109d50:	003b68fa 	trap	3
81109d54:	dfc00915 	stw	ra,36(sp)
81109d58:	df000815 	stw	fp,32(sp)
81109d5c:	df000804 	addi	fp,sp,32
81109d60:	e13ffb15 	stw	r4,-20(fp)
81109d64:	e17ffc15 	stw	r5,-16(fp)
81109d68:	3007883a 	mov	r3,r6
81109d6c:	e1fffe15 	stw	r7,-8(fp)
81109d70:	e0800217 	ldw	r2,8(fp)
81109d74:	e0fffd05 	stb	r3,-12(fp)
81109d78:	e0bfff0d 	sth	r2,-4(fp)
    int i;
    bool bSuccess = TRUE;
81109d7c:	00800044 	movi	r2,1
81109d80:	e0bff915 	stw	r2,-28(fp)
    //alt_u8 DeviceAddr, 
    alt_u8 ControlAddr = 0;
81109d84:	e03ffa05 	stb	zero,-24(fp)
    
   
    // device id
    //DeviceAddr = HMB_E2_I2C_ID;

    i2c_start(clk_base, data_base);
81109d88:	e17ffc17 	ldw	r5,-16(fp)
81109d8c:	e13ffb17 	ldw	r4,-20(fp)
81109d90:	1109ea80 	call	81109ea8 <i2c_start>
    if (!i2c_write(clk_base, data_base, DeviceAddr)){  // send ID
81109d94:	e0bffd03 	ldbu	r2,-12(fp)
81109d98:	10803fcc 	andi	r2,r2,255
81109d9c:	100d883a 	mov	r6,r2
81109da0:	e17ffc17 	ldw	r5,-16(fp)
81109da4:	e13ffb17 	ldw	r4,-20(fp)
81109da8:	1109fbc0 	call	81109fbc <i2c_write>
81109dac:	1000011e 	bne	r2,zero,81109db4 <I2C_MultipleRead+0x6c>
        bSuccess = FALSE;
81109db0:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address NACK!\n"));
    }
    if (bSuccess && !i2c_write(clk_base, data_base, ControlAddr)){ // send sub-address
81109db4:	e0bff917 	ldw	r2,-28(fp)
81109db8:	10000726 	beq	r2,zero,81109dd8 <I2C_MultipleRead+0x90>
81109dbc:	e0bffa03 	ldbu	r2,-24(fp)
81109dc0:	100d883a 	mov	r6,r2
81109dc4:	e17ffc17 	ldw	r5,-16(fp)
81109dc8:	e13ffb17 	ldw	r4,-20(fp)
81109dcc:	1109fbc0 	call	81109fbc <i2c_write>
81109dd0:	1000011e 	bne	r2,zero,81109dd8 <I2C_MultipleRead+0x90>
        bSuccess = FALSE;
81109dd4:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: SubAddress NACK!\n"));
    }    
    if (bSuccess)        
81109dd8:	e0bff917 	ldw	r2,-28(fp)
81109ddc:	10000326 	beq	r2,zero,81109dec <I2C_MultipleRead+0xa4>
        i2c_start(clk_base, data_base);  // restart
81109de0:	e17ffc17 	ldw	r5,-16(fp)
81109de4:	e13ffb17 	ldw	r4,-20(fp)
81109de8:	1109ea80 	call	81109ea8 <i2c_start>
    DeviceAddr |= 1; // Read
81109dec:	e0bffd03 	ldbu	r2,-12(fp)
81109df0:	10800054 	ori	r2,r2,1
81109df4:	e0bffd05 	stb	r2,-12(fp)
    if (bSuccess && !i2c_write(clk_base, data_base, DeviceAddr)){  // send id
81109df8:	e0bff917 	ldw	r2,-28(fp)
81109dfc:	10000826 	beq	r2,zero,81109e20 <I2C_MultipleRead+0xd8>
81109e00:	e0bffd03 	ldbu	r2,-12(fp)
81109e04:	10803fcc 	andi	r2,r2,255
81109e08:	100d883a 	mov	r6,r2
81109e0c:	e17ffc17 	ldw	r5,-16(fp)
81109e10:	e13ffb17 	ldw	r4,-20(fp)
81109e14:	1109fbc0 	call	81109fbc <i2c_write>
81109e18:	1000011e 	bne	r2,zero,81109e20 <I2C_MultipleRead+0xd8>
        bSuccess = FALSE;
81109e1c:	e03ff915 	stw	zero,-28(fp)
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
81109e20:	e0bff917 	ldw	r2,-28(fp)
81109e24:	10001726 	beq	r2,zero,81109e84 <I2C_MultipleRead+0x13c>
        for(i=0;i<len && bSuccess;i++){
81109e28:	e03ff815 	stw	zero,-32(fp)
81109e2c:	00001006 	br	81109e70 <I2C_MultipleRead+0x128>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
81109e30:	e0bff817 	ldw	r2,-32(fp)
81109e34:	e0fffe17 	ldw	r3,-8(fp)
81109e38:	1889883a 	add	r4,r3,r2
81109e3c:	e0bfff0b 	ldhu	r2,-4(fp)
81109e40:	10ffffc4 	addi	r3,r2,-1
81109e44:	e0bff817 	ldw	r2,-32(fp)
81109e48:	1884c03a 	cmpne	r2,r3,r2
81109e4c:	10803fcc 	andi	r2,r2,255
81109e50:	100f883a 	mov	r7,r2
81109e54:	200d883a 	mov	r6,r4
81109e58:	e17ffc17 	ldw	r5,-16(fp)
81109e5c:	e13ffb17 	ldw	r4,-20(fp)
81109e60:	110a0f40 	call	8110a0f4 <i2c_read>
        bSuccess = FALSE;
        I2C_DEBUG(("I2C HMB_E2 Fail: Address+1 NACK!\n"));
    }
    
    if (bSuccess){
        for(i=0;i<len && bSuccess;i++){
81109e64:	e0bff817 	ldw	r2,-32(fp)
81109e68:	10800044 	addi	r2,r2,1
81109e6c:	e0bff815 	stw	r2,-32(fp)
81109e70:	e0bfff0b 	ldhu	r2,-4(fp)
81109e74:	e0fff817 	ldw	r3,-32(fp)
81109e78:	1880020e 	bge	r3,r2,81109e84 <I2C_MultipleRead+0x13c>
81109e7c:	e0bff917 	ldw	r2,-28(fp)
81109e80:	103feb1e 	bne	r2,zero,81109e30 <__reset+0xfb0e9e30>
            i2c_read(clk_base, data_base, &szData[i], (i==(len-1))?FALSE:TRUE);  // read
        }            
    }        
    i2c_stop(clk_base, data_base);
81109e84:	e17ffc17 	ldw	r5,-16(fp)
81109e88:	e13ffb17 	ldw	r4,-20(fp)
81109e8c:	1109f3c0 	call	81109f3c <i2c_stop>
    
    return bSuccess;    
81109e90:	e0bff917 	ldw	r2,-28(fp)
    
}
81109e94:	e037883a 	mov	sp,fp
81109e98:	dfc00117 	ldw	ra,4(sp)
81109e9c:	df000017 	ldw	fp,0(sp)
81109ea0:	dec00204 	addi	sp,sp,8
81109ea4:	f800283a 	ret

81109ea8 <i2c_start>:
///////////// Interncal function (i2cXXX) body //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////


//SDA 1->0 while SCL=1
void i2c_start(alt_u32 clk_base, alt_u32 data_base){
81109ea8:	defffc04 	addi	sp,sp,-16
81109eac:	de00012e 	bgeu	sp,et,81109eb4 <i2c_start+0xc>
81109eb0:	003b68fa 	trap	3
81109eb4:	dfc00315 	stw	ra,12(sp)
81109eb8:	df000215 	stw	fp,8(sp)
81109ebc:	df000204 	addi	fp,sp,8
81109ec0:	e13ffe15 	stw	r4,-8(fp)
81109ec4:	e17fff15 	stw	r5,-4(fp)
    
    // make sure it is in normal state
    SDA_DIR_OUT(data_base);  // data output enabled
81109ec8:	e0bfff17 	ldw	r2,-4(fp)
81109ecc:	10800104 	addi	r2,r2,4
81109ed0:	1007883a 	mov	r3,r2
81109ed4:	00800044 	movi	r2,1
81109ed8:	18800035 	stwio	r2,0(r3)
    
    
    
    // start condition
    SDA_HIGH(data_base); // data high
81109edc:	e0bfff17 	ldw	r2,-4(fp)
81109ee0:	00c00044 	movi	r3,1
81109ee4:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base);
81109ee8:	e0bffe17 	ldw	r2,-8(fp)
81109eec:	00c00044 	movi	r3,1
81109ef0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109ef4:	01000044 	movi	r4,1
81109ef8:	1133cf00 	call	81133cf0 <usleep>
     
    SDA_LOW(data_base); // data low
81109efc:	e0bfff17 	ldw	r2,-4(fp)
81109f00:	0007883a 	mov	r3,zero
81109f04:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; 
81109f08:	01000044 	movi	r4,1
81109f0c:	1133cf00 	call	81133cf0 <usleep>
    SCL_LOW(clk_base); // clock low
81109f10:	e0bffe17 	ldw	r2,-8(fp)
81109f14:	0007883a 	mov	r3,zero
81109f18:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;
81109f1c:	01000044 	movi	r4,1
81109f20:	1133cf00 	call	81133cf0 <usleep>
}
81109f24:	0001883a 	nop
81109f28:	e037883a 	mov	sp,fp
81109f2c:	dfc00117 	ldw	ra,4(sp)
81109f30:	df000017 	ldw	fp,0(sp)
81109f34:	dec00204 	addi	sp,sp,8
81109f38:	f800283a 	ret

81109f3c <i2c_stop>:

// SDA 0->1 while SCL=1
void i2c_stop(alt_u32 clk_base, alt_u32 data_base){
81109f3c:	defffc04 	addi	sp,sp,-16
81109f40:	de00012e 	bgeu	sp,et,81109f48 <i2c_stop+0xc>
81109f44:	003b68fa 	trap	3
81109f48:	dfc00315 	stw	ra,12(sp)
81109f4c:	df000215 	stw	fp,8(sp)
81109f50:	df000204 	addi	fp,sp,8
81109f54:	e13ffe15 	stw	r4,-8(fp)
81109f58:	e17fff15 	stw	r5,-4(fp)
    // assume SCL = 0
    
    SDA_DIR_OUT(data_base);  // data output enabled
81109f5c:	e0bfff17 	ldw	r2,-4(fp)
81109f60:	10800104 	addi	r2,r2,4
81109f64:	1007883a 	mov	r3,r2
81109f68:	00800044 	movi	r2,1
81109f6c:	18800035 	stwio	r2,0(r3)
    SDA_LOW(data_base); // Data Low
81109f70:	e0bfff17 	ldw	r2,-4(fp)
81109f74:	0007883a 	mov	r3,zero
81109f78:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY; 
    SCL_HIGH(clk_base);  // clock high
81109f7c:	e0bffe17 	ldw	r2,-8(fp)
81109f80:	00c00044 	movi	r3,1
81109f84:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high long delay
81109f88:	01000044 	movi	r4,1
81109f8c:	1133cf00 	call	81133cf0 <usleep>
    SDA_HIGH(data_base); // data high
81109f90:	e0bfff17 	ldw	r2,-4(fp)
81109f94:	00c00044 	movi	r3,1
81109f98:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data high delay
81109f9c:	01000044 	movi	r4,1
81109fa0:	1133cf00 	call	81133cf0 <usleep>
    

    
}
81109fa4:	0001883a 	nop
81109fa8:	e037883a 	mov	sp,fp
81109fac:	dfc00117 	ldw	ra,4(sp)
81109fb0:	df000017 	ldw	fp,0(sp)
81109fb4:	dec00204 	addi	sp,sp,8
81109fb8:	f800283a 	ret

81109fbc <i2c_write>:

bool i2c_write(alt_u32 clk_base, alt_u32 data_base, alt_u8 Data){ // return true if device response ack
81109fbc:	defff804 	addi	sp,sp,-32
81109fc0:	de00012e 	bgeu	sp,et,81109fc8 <i2c_write+0xc>
81109fc4:	003b68fa 	trap	3
81109fc8:	dfc00715 	stw	ra,28(sp)
81109fcc:	df000615 	stw	fp,24(sp)
81109fd0:	df000604 	addi	fp,sp,24
81109fd4:	e13ffd15 	stw	r4,-12(fp)
81109fd8:	e17ffe15 	stw	r5,-8(fp)
81109fdc:	3005883a 	mov	r2,r6
81109fe0:	e0bfff05 	stb	r2,-4(fp)
    alt_u8 Mask = 0x80;
81109fe4:	00bfe004 	movi	r2,-128
81109fe8:	e0bffa05 	stb	r2,-24(fp)
    bool bAck;
    int i;
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
81109fec:	e0bffe17 	ldw	r2,-8(fp)
81109ff0:	10800104 	addi	r2,r2,4
81109ff4:	1007883a 	mov	r3,r2
81109ff8:	00800044 	movi	r2,1
81109ffc:	18800035 	stwio	r2,0(r3)
    
    for(i=0;i<8;i++){
8110a000:	e03ffb15 	stw	zero,-20(fp)
8110a004:	00001f06 	br	8110a084 <i2c_write+0xc8>
        SCL_LOW(clk_base);  // new, make sure data change at clk low
8110a008:	e0bffd17 	ldw	r2,-12(fp)
8110a00c:	0007883a 	mov	r3,zero
8110a010:	10c00035 	stwio	r3,0(r2)
        // output data on bus
        if (Data & Mask){ // there is a delay in this command
8110a014:	e0ffff03 	ldbu	r3,-4(fp)
8110a018:	e0bffa03 	ldbu	r2,-24(fp)
8110a01c:	1884703a 	and	r2,r3,r2
8110a020:	10803fcc 	andi	r2,r2,255
8110a024:	10000426 	beq	r2,zero,8110a038 <i2c_write+0x7c>
            SDA_HIGH(data_base);
8110a028:	e0bffe17 	ldw	r2,-8(fp)
8110a02c:	00c00044 	movi	r3,1
8110a030:	10c00035 	stwio	r3,0(r2)
8110a034:	00000306 	br	8110a044 <i2c_write+0x88>
        }else{    
            SDA_LOW(data_base);
8110a038:	e0bffe17 	ldw	r2,-8(fp)
8110a03c:	0007883a 	mov	r3,zero
8110a040:	10c00035 	stwio	r3,0(r2)
        }
        Mask >>= 1; // there is a delay in this command
8110a044:	e0bffa03 	ldbu	r2,-24(fp)
8110a048:	1004d07a 	srli	r2,r2,1
8110a04c:	e0bffa05 	stb	r2,-24(fp)
        // clock high
        SCL_HIGH(clk_base);
8110a050:	e0bffd17 	ldw	r2,-12(fp)
8110a054:	00c00044 	movi	r3,1
8110a058:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a05c:	01000044 	movi	r4,1
8110a060:	1133cf00 	call	81133cf0 <usleep>
        SCL_LOW(clk_base);
8110a064:	e0bffd17 	ldw	r2,-12(fp)
8110a068:	0007883a 	mov	r3,zero
8110a06c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a070:	01000044 	movi	r4,1
8110a074:	1133cf00 	call	81133cf0 <usleep>
    
    // assume, SCL = 0
    
    SDA_DIR_OUT(data_base);  // data write mode
    
    for(i=0;i<8;i++){
8110a078:	e0bffb17 	ldw	r2,-20(fp)
8110a07c:	10800044 	addi	r2,r2,1
8110a080:	e0bffb15 	stw	r2,-20(fp)
8110a084:	e0bffb17 	ldw	r2,-20(fp)
8110a088:	10800210 	cmplti	r2,r2,8
8110a08c:	103fde1e 	bne	r2,zero,8110a008 <__reset+0xfb0ea008>
        SCL_LOW(clk_base);
        SCL_DELAY;
    }
    
    //===== get ack
    SDA_DIR_IN(data_base);  // data read mode
8110a090:	e0bffe17 	ldw	r2,-8(fp)
8110a094:	10800104 	addi	r2,r2,4
8110a098:	0007883a 	mov	r3,zero
8110a09c:	10c00035 	stwio	r3,0(r2)
    //SCL_DELAY;
    // clock high
    SCL_HIGH(clk_base);  // clock high
8110a0a0:	e0bffd17 	ldw	r2,-12(fp)
8110a0a4:	00c00044 	movi	r3,1
8110a0a8:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY;  // clock high delay
8110a0ac:	01000044 	movi	r4,1
8110a0b0:	1133cf00 	call	81133cf0 <usleep>
    bAck = SDA_READ(data_base)?FALSE:TRUE;  // get ack
8110a0b4:	e0bffe17 	ldw	r2,-8(fp)
8110a0b8:	10800037 	ldwio	r2,0(r2)
8110a0bc:	1005003a 	cmpeq	r2,r2,zero
8110a0c0:	10803fcc 	andi	r2,r2,255
8110a0c4:	e0bffc15 	stw	r2,-16(fp)
    //SCL_DELAY;
    //SDA_DIR_OUT;
    SCL_LOW(clk_base); // clock low         
8110a0c8:	e0bffd17 	ldw	r2,-12(fp)
8110a0cc:	0007883a 	mov	r3,zero
8110a0d0:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a0d4:	01000044 	movi	r4,1
8110a0d8:	1133cf00 	call	81133cf0 <usleep>
    return bAck;
8110a0dc:	e0bffc17 	ldw	r2,-16(fp)
}    
8110a0e0:	e037883a 	mov	sp,fp
8110a0e4:	dfc00117 	ldw	ra,4(sp)
8110a0e8:	df000017 	ldw	fp,0(sp)
8110a0ec:	dec00204 	addi	sp,sp,8
8110a0f0:	f800283a 	ret

8110a0f4 <i2c_read>:

void i2c_read(alt_u32 clk_base, alt_u32 data_base, alt_u8 *pData, bool bAck){ // return true if device response ack
8110a0f4:	defff804 	addi	sp,sp,-32
8110a0f8:	de00012e 	bgeu	sp,et,8110a100 <i2c_read+0xc>
8110a0fc:	003b68fa 	trap	3
8110a100:	dfc00715 	stw	ra,28(sp)
8110a104:	df000615 	stw	fp,24(sp)
8110a108:	df000604 	addi	fp,sp,24
8110a10c:	e13ffc15 	stw	r4,-16(fp)
8110a110:	e17ffd15 	stw	r5,-12(fp)
8110a114:	e1bffe15 	stw	r6,-8(fp)
8110a118:	e1ffff15 	stw	r7,-4(fp)
    alt_u8 Data=0;
8110a11c:	e03ffa05 	stb	zero,-24(fp)
    int i;
    
    // assume SCL = low
    
    SDA_DIR_IN(data_base);  // set data read mode
8110a120:	e0bffd17 	ldw	r2,-12(fp)
8110a124:	10800104 	addi	r2,r2,4
8110a128:	0007883a 	mov	r3,zero
8110a12c:	10c00035 	stwio	r3,0(r2)
    SCL_LOW(clk_base); // clock low
8110a130:	e0bffc17 	ldw	r2,-16(fp)
8110a134:	0007883a 	mov	r3,zero
8110a138:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a13c:	01000044 	movi	r4,1
8110a140:	1133cf00 	call	81133cf0 <usleep>

    for(i=0;i<8;i++){
8110a144:	e03ffb15 	stw	zero,-20(fp)
8110a148:	00001606 	br	8110a1a4 <i2c_read+0xb0>
        Data <<= 1;
8110a14c:	e0bffa03 	ldbu	r2,-24(fp)
8110a150:	1085883a 	add	r2,r2,r2
8110a154:	e0bffa05 	stb	r2,-24(fp)
        SCL_HIGH(clk_base);  // clock high
8110a158:	e0bffc17 	ldw	r2,-16(fp)
8110a15c:	00c00044 	movi	r3,1
8110a160:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a164:	01000044 	movi	r4,1
8110a168:	1133cf00 	call	81133cf0 <usleep>
        if (SDA_READ(data_base))  // read data   
8110a16c:	e0bffd17 	ldw	r2,-12(fp)
8110a170:	10800037 	ldwio	r2,0(r2)
8110a174:	10000326 	beq	r2,zero,8110a184 <i2c_read+0x90>
            Data |= 0x01;
8110a178:	e0bffa03 	ldbu	r2,-24(fp)
8110a17c:	10800054 	ori	r2,r2,1
8110a180:	e0bffa05 	stb	r2,-24(fp)
        SCL_LOW(clk_base);  // clock log  
8110a184:	e0bffc17 	ldw	r2,-16(fp)
8110a188:	0007883a 	mov	r3,zero
8110a18c:	10c00035 	stwio	r3,0(r2)
        SCL_DELAY;
8110a190:	01000044 	movi	r4,1
8110a194:	1133cf00 	call	81133cf0 <usleep>
    
    SDA_DIR_IN(data_base);  // set data read mode
    SCL_LOW(clk_base); // clock low
    SCL_DELAY; // clock low delay

    for(i=0;i<8;i++){
8110a198:	e0bffb17 	ldw	r2,-20(fp)
8110a19c:	10800044 	addi	r2,r2,1
8110a1a0:	e0bffb15 	stw	r2,-20(fp)
8110a1a4:	e0bffb17 	ldw	r2,-20(fp)
8110a1a8:	10800210 	cmplti	r2,r2,8
8110a1ac:	103fe71e 	bne	r2,zero,8110a14c <__reset+0xfb0ea14c>
        SCL_LOW(clk_base);  // clock log  
        SCL_DELAY;
    }
    
    // send ACK
    SCL_LOW(clk_base);  // new, make sure data change at clk low
8110a1b0:	e0bffc17 	ldw	r2,-16(fp)
8110a1b4:	0007883a 	mov	r3,zero
8110a1b8:	10c00035 	stwio	r3,0(r2)
    SDA_DIR_OUT(data_base);  // set data write mode
8110a1bc:	e0bffd17 	ldw	r2,-12(fp)
8110a1c0:	10800104 	addi	r2,r2,4
8110a1c4:	1007883a 	mov	r3,r2
8110a1c8:	00800044 	movi	r2,1
8110a1cc:	18800035 	stwio	r2,0(r3)
    if (bAck)
8110a1d0:	e0bfff17 	ldw	r2,-4(fp)
8110a1d4:	10000426 	beq	r2,zero,8110a1e8 <i2c_read+0xf4>
        SDA_LOW(data_base);
8110a1d8:	e0bffd17 	ldw	r2,-12(fp)
8110a1dc:	0007883a 	mov	r3,zero
8110a1e0:	10c00035 	stwio	r3,0(r2)
8110a1e4:	00000306 	br	8110a1f4 <i2c_read+0x100>
    else
        SDA_HIGH(data_base);
8110a1e8:	e0bffd17 	ldw	r2,-12(fp)
8110a1ec:	00c00044 	movi	r3,1
8110a1f0:	10c00035 	stwio	r3,0(r2)
    SCL_HIGH(clk_base); // clock high
8110a1f4:	e0bffc17 	ldw	r2,-16(fp)
8110a1f8:	00c00044 	movi	r3,1
8110a1fc:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock high  delay
8110a200:	01000044 	movi	r4,1
8110a204:	1133cf00 	call	81133cf0 <usleep>
    SCL_LOW(clk_base); // clock low
8110a208:	e0bffc17 	ldw	r2,-16(fp)
8110a20c:	0007883a 	mov	r3,zero
8110a210:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // clock low delay
8110a214:	01000044 	movi	r4,1
8110a218:	1133cf00 	call	81133cf0 <usleep>
    SDA_LOW(data_base);  // data low
8110a21c:	e0bffd17 	ldw	r2,-12(fp)
8110a220:	0007883a 	mov	r3,zero
8110a224:	10c00035 	stwio	r3,0(r2)
    SCL_DELAY; // data low delay
8110a228:	01000044 	movi	r4,1
8110a22c:	1133cf00 	call	81133cf0 <usleep>
//    SDA_DIR_IN;  // set data read mode
    
    *pData = Data;
8110a230:	e0bffe17 	ldw	r2,-8(fp)
8110a234:	e0fffa03 	ldbu	r3,-24(fp)
8110a238:	10c00005 	stb	r3,0(r2)
}
8110a23c:	0001883a 	nop
8110a240:	e037883a 	mov	sp,fp
8110a244:	dfc00117 	ldw	ra,4(sp)
8110a248:	df000017 	ldw	fp,0(sp)
8110a24c:	dec00204 	addi	sp,sp,8
8110a250:	f800283a 	ret

8110a254 <bSetBoardLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetBoardLeds(bool bDRIVE, alt_u8 LedsMask){
8110a254:	defffd04 	addi	sp,sp,-12
8110a258:	de00012e 	bgeu	sp,et,8110a260 <bSetBoardLeds+0xc>
8110a25c:	003b68fa 	trap	3
8110a260:	df000215 	stw	fp,8(sp)
8110a264:	df000204 	addi	fp,sp,8
8110a268:	e13ffe15 	stw	r4,-8(fp)
8110a26c:	2805883a 	mov	r2,r5
8110a270:	e0bfff05 	stb	r2,-4(fp)

  // Board LEDs state: ON = 0; OFF = 1;

  if (bDRIVE == LEDS_ON){
8110a274:	e0bffe17 	ldw	r2,-8(fp)
8110a278:	10800058 	cmpnei	r2,r2,1
8110a27c:	1000071e 	bne	r2,zero,8110a29c <bSetBoardLeds+0x48>
	LedsBoardControl &= (~LedsMask);
8110a280:	e0bfff03 	ldbu	r2,-4(fp)
8110a284:	0084303a 	nor	r2,zero,r2
8110a288:	1007883a 	mov	r3,r2
8110a28c:	d0a04f03 	ldbu	r2,-32452(gp)
8110a290:	1884703a 	and	r2,r3,r2
8110a294:	d0a04f05 	stb	r2,-32452(gp)
8110a298:	00000406 	br	8110a2ac <bSetBoardLeds+0x58>
  } else {
	LedsBoardControl |= LedsMask;
8110a29c:	d0e04f03 	ldbu	r3,-32452(gp)
8110a2a0:	e0bfff03 	ldbu	r2,-4(fp)
8110a2a4:	1884b03a 	or	r2,r3,r2
8110a2a8:	d0a04f05 	stb	r2,-32452(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_BOARD_BASE, LedsBoardControl);
8110a2ac:	d0a04f03 	ldbu	r2,-32452(gp)
8110a2b0:	10c03fcc 	andi	r3,r2,255
8110a2b4:	00a00034 	movhi	r2,32768
8110a2b8:	10827404 	addi	r2,r2,2512
8110a2bc:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110a2c0:	00800044 	movi	r2,1
}
8110a2c4:	e037883a 	mov	sp,fp
8110a2c8:	df000017 	ldw	fp,0(sp)
8110a2cc:	dec00104 	addi	sp,sp,4
8110a2d0:	f800283a 	ret

8110a2d4 <bSetPainelLeds>:
 * @param [in] LedsMask  Mascara de leds a serem modificados
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSetPainelLeds(bool bDRIVE, alt_u32 LedsMask){
8110a2d4:	defffd04 	addi	sp,sp,-12
8110a2d8:	de00012e 	bgeu	sp,et,8110a2e0 <bSetPainelLeds+0xc>
8110a2dc:	003b68fa 	trap	3
8110a2e0:	df000215 	stw	fp,8(sp)
8110a2e4:	df000204 	addi	fp,sp,8
8110a2e8:	e13ffe15 	stw	r4,-8(fp)
8110a2ec:	e17fff15 	stw	r5,-4(fp)

  // Painel LEDs state: ON = 1; OFF = 0;

  if (bDRIVE == LEDS_ON){
8110a2f0:	e0bffe17 	ldw	r2,-8(fp)
8110a2f4:	10800058 	cmpnei	r2,r2,1
8110a2f8:	1000051e 	bne	r2,zero,8110a310 <bSetPainelLeds+0x3c>
	LedsPainelControl |= LedsMask;
8110a2fc:	d0e00217 	ldw	r3,-32760(gp)
8110a300:	e0bfff17 	ldw	r2,-4(fp)
8110a304:	1884b03a 	or	r2,r3,r2
8110a308:	d0a00215 	stw	r2,-32760(gp)
8110a30c:	00000506 	br	8110a324 <bSetPainelLeds+0x50>
  } else {
	LedsPainelControl &= (~LedsMask);
8110a310:	e0bfff17 	ldw	r2,-4(fp)
8110a314:	0086303a 	nor	r3,zero,r2
8110a318:	d0a00217 	ldw	r2,-32760(gp)
8110a31c:	1884703a 	and	r2,r3,r2
8110a320:	d0a00215 	stw	r2,-32760(gp)
  }
  IOWR_ALTERA_AVALON_PIO_DATA(LEDS_PAINEL_BASE, LedsPainelControl);
8110a324:	d0a00217 	ldw	r2,-32760(gp)
8110a328:	1007883a 	mov	r3,r2
8110a32c:	00a00034 	movhi	r2,32768
8110a330:	10824004 	addi	r2,r2,2304
8110a334:	10c00035 	stwio	r3,0(r2)

  return TRUE;
8110a338:	00800044 	movi	r2,1
}
8110a33c:	e037883a 	mov	sp,fp
8110a340:	df000017 	ldw	fp,0(sp)
8110a344:	dec00104 	addi	sp,sp,4
8110a348:	f800283a 	ret

8110a34c <msgdma_write_extended_descriptor>:
/*
 * This function is used for writing extended descriptors to the dispatcher.  
 It handles only 32-bit descriptors.
 */
static int msgdma_write_extended_descriptor(alt_u32 *csr_base,
		alt_u32 *descriptor_base, alt_msgdma_extended_descriptor *descriptor) {
8110a34c:	defffc04 	addi	sp,sp,-16
8110a350:	de00012e 	bgeu	sp,et,8110a358 <msgdma_write_extended_descriptor+0xc>
8110a354:	003b68fa 	trap	3
8110a358:	df000315 	stw	fp,12(sp)
8110a35c:	df000304 	addi	fp,sp,12
8110a360:	e13ffd15 	stw	r4,-12(fp)
8110a364:	e17ffe15 	stw	r5,-8(fp)
8110a368:	e1bfff15 	stw	r6,-4(fp)
	if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) &
8110a36c:	e0bffd17 	ldw	r2,-12(fp)
8110a370:	10800037 	ldwio	r2,0(r2)
8110a374:	1080010c 	andi	r2,r2,4
8110a378:	10000226 	beq	r2,zero,8110a384 <msgdma_write_extended_descriptor+0x38>
	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK)) {
		/*at least one descriptor buffer is full, returning so that this function
		 is non-blocking*/
		return -ENOSPC;
8110a37c:	00bff904 	movi	r2,-28
8110a380:	00003d06 	br	8110a478 <msgdma_write_extended_descriptor+0x12c>
	}

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base,
8110a384:	e0bfff17 	ldw	r2,-4(fp)
8110a388:	10800017 	ldw	r2,0(r2)
8110a38c:	1007883a 	mov	r3,r2
8110a390:	e0bffe17 	ldw	r2,-8(fp)
8110a394:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base,
8110a398:	e0bffe17 	ldw	r2,-8(fp)
8110a39c:	10800104 	addi	r2,r2,4
8110a3a0:	e0ffff17 	ldw	r3,-4(fp)
8110a3a4:	18c00117 	ldw	r3,4(r3)
8110a3a8:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_low);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base,
8110a3ac:	e0bffe17 	ldw	r2,-8(fp)
8110a3b0:	10800204 	addi	r2,r2,8
8110a3b4:	e0ffff17 	ldw	r3,-4(fp)
8110a3b8:	18c00217 	ldw	r3,8(r3)
8110a3bc:	10c00035 	stwio	r3,0(r2)
			descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(descriptor_base,
8110a3c0:	e0bffe17 	ldw	r2,-8(fp)
8110a3c4:	10800304 	addi	r2,r2,12
8110a3c8:	e0ffff17 	ldw	r3,-4(fp)
8110a3cc:	18c0030b 	ldhu	r3,12(r3)
8110a3d0:	18ffffcc 	andi	r3,r3,65535
8110a3d4:	10c0002d 	sthio	r3,0(r2)
			descriptor->sequence_number);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(descriptor_base,
8110a3d8:	e0bffe17 	ldw	r2,-8(fp)
8110a3dc:	10800384 	addi	r2,r2,14
8110a3e0:	e0ffff17 	ldw	r3,-4(fp)
8110a3e4:	18c00383 	ldbu	r3,14(r3)
8110a3e8:	18c03fcc 	andi	r3,r3,255
8110a3ec:	10c00025 	stbio	r3,0(r2)
			descriptor->read_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(descriptor_base,
8110a3f0:	e0bffe17 	ldw	r2,-8(fp)
8110a3f4:	108003c4 	addi	r2,r2,15
8110a3f8:	e0ffff17 	ldw	r3,-4(fp)
8110a3fc:	18c003c3 	ldbu	r3,15(r3)
8110a400:	18c03fcc 	andi	r3,r3,255
8110a404:	10c00025 	stbio	r3,0(r2)
			descriptor->write_burst_count);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(descriptor_base,
8110a408:	e0bffe17 	ldw	r2,-8(fp)
8110a40c:	10800404 	addi	r2,r2,16
8110a410:	e0ffff17 	ldw	r3,-4(fp)
8110a414:	18c0040b 	ldhu	r3,16(r3)
8110a418:	18ffffcc 	andi	r3,r3,65535
8110a41c:	10c0002d 	sthio	r3,0(r2)
			descriptor->read_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(descriptor_base,
8110a420:	e0bffe17 	ldw	r2,-8(fp)
8110a424:	10800484 	addi	r2,r2,18
8110a428:	e0ffff17 	ldw	r3,-4(fp)
8110a42c:	18c0048b 	ldhu	r3,18(r3)
8110a430:	18ffffcc 	andi	r3,r3,65535
8110a434:	10c0002d 	sthio	r3,0(r2)
			descriptor->write_stride);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base,
8110a438:	e0bffe17 	ldw	r2,-8(fp)
8110a43c:	10800504 	addi	r2,r2,20
8110a440:	e0ffff17 	ldw	r3,-4(fp)
8110a444:	18c00517 	ldw	r3,20(r3)
8110a448:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->read_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base,
8110a44c:	e0bffe17 	ldw	r2,-8(fp)
8110a450:	10800604 	addi	r2,r2,24
8110a454:	e0ffff17 	ldw	r3,-4(fp)
8110a458:	18c00617 	ldw	r3,24(r3)
8110a45c:	10c00035 	stwio	r3,0(r2)
			(alt_u32 )descriptor->write_address_high);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(descriptor_base,
8110a460:	e0bffe17 	ldw	r2,-8(fp)
8110a464:	10800704 	addi	r2,r2,28
8110a468:	e0ffff17 	ldw	r3,-4(fp)
8110a46c:	18c00717 	ldw	r3,28(r3)
8110a470:	10c00035 	stwio	r3,0(r2)
			descriptor->control);
	return 0;
8110a474:	0005883a 	mov	r2,zero
}
8110a478:	e037883a 	mov	sp,fp
8110a47c:	df000017 	ldw	fp,0(sp)
8110a480:	dec00104 	addi	sp,sp,4
8110a484:	f800283a 	ret

8110a488 <msgdma_construct_extended_descriptor>:
static int msgdma_construct_extended_descriptor(alt_msgdma_dev *dev,
		alt_msgdma_extended_descriptor *descriptor, alt_u32 *read_address,
		alt_u32 *write_address, alt_u32 length, alt_u32 control,
		alt_u32 *read_address_high, alt_u32 *write_address_high,
		alt_u16 sequence_number, alt_u8 read_burst_count,
		alt_u8 write_burst_count, alt_u16 read_stride, alt_u16 write_stride) {
8110a488:	defff604 	addi	sp,sp,-40
8110a48c:	de00012e 	bgeu	sp,et,8110a494 <msgdma_construct_extended_descriptor+0xc>
8110a490:	003b68fa 	trap	3
8110a494:	df000915 	stw	fp,36(sp)
8110a498:	df000904 	addi	fp,sp,36
8110a49c:	e13ff715 	stw	r4,-36(fp)
8110a4a0:	e17ff815 	stw	r5,-32(fp)
8110a4a4:	e1bff915 	stw	r6,-28(fp)
8110a4a8:	e1fffa15 	stw	r7,-24(fp)
8110a4ac:	e1800517 	ldw	r6,20(fp)
8110a4b0:	e1400617 	ldw	r5,24(fp)
8110a4b4:	e1000717 	ldw	r4,28(fp)
8110a4b8:	e0c00817 	ldw	r3,32(fp)
8110a4bc:	e0800917 	ldw	r2,36(fp)
8110a4c0:	e1bffb0d 	sth	r6,-20(fp)
8110a4c4:	e17ffc05 	stb	r5,-16(fp)
8110a4c8:	e13ffd05 	stb	r4,-12(fp)
8110a4cc:	e0fffe0d 	sth	r3,-8(fp)
8110a4d0:	e0bfff0d 	sth	r2,-4(fp)
	if (dev->max_byte < length || dev->max_stride < read_stride
8110a4d4:	e0bff717 	ldw	r2,-36(fp)
8110a4d8:	10c01217 	ldw	r3,72(r2)
8110a4dc:	e0800117 	ldw	r2,4(fp)
8110a4e0:	18801936 	bltu	r3,r2,8110a548 <msgdma_construct_extended_descriptor+0xc0>
8110a4e4:	e13ff717 	ldw	r4,-36(fp)
8110a4e8:	20801317 	ldw	r2,76(r4)
8110a4ec:	20c01417 	ldw	r3,80(r4)
8110a4f0:	e13ffe0b 	ldhu	r4,-8(fp)
8110a4f4:	213fffcc 	andi	r4,r4,65535
8110a4f8:	2015883a 	mov	r10,r4
8110a4fc:	0017883a 	mov	r11,zero
8110a500:	1ac01136 	bltu	r3,r11,8110a548 <msgdma_construct_extended_descriptor+0xc0>
8110a504:	58c0011e 	bne	r11,r3,8110a50c <msgdma_construct_extended_descriptor+0x84>
8110a508:	12800f36 	bltu	r2,r10,8110a548 <msgdma_construct_extended_descriptor+0xc0>
			|| dev->max_stride < write_stride || dev->enhanced_features != 1) {
8110a50c:	e13ff717 	ldw	r4,-36(fp)
8110a510:	20801317 	ldw	r2,76(r4)
8110a514:	20c01417 	ldw	r3,80(r4)
8110a518:	e13fff0b 	ldhu	r4,-4(fp)
8110a51c:	213fffcc 	andi	r4,r4,65535
8110a520:	2011883a 	mov	r8,r4
8110a524:	0013883a 	mov	r9,zero
8110a528:	1a400736 	bltu	r3,r9,8110a548 <msgdma_construct_extended_descriptor+0xc0>
8110a52c:	48c0011e 	bne	r9,r3,8110a534 <msgdma_construct_extended_descriptor+0xac>
8110a530:	12000536 	bltu	r2,r8,8110a548 <msgdma_construct_extended_descriptor+0xc0>
8110a534:	e0bff717 	ldw	r2,-36(fp)
8110a538:	10801703 	ldbu	r2,92(r2)
8110a53c:	10803fcc 	andi	r2,r2,255
8110a540:	10800060 	cmpeqi	r2,r2,1
8110a544:	1000021e 	bne	r2,zero,8110a550 <msgdma_construct_extended_descriptor+0xc8>
		return -EINVAL;
8110a548:	00bffa84 	movi	r2,-22
8110a54c:	00002306 	br	8110a5dc <msgdma_construct_extended_descriptor+0x154>
	}

	descriptor->read_address_low = read_address;
8110a550:	e0bff817 	ldw	r2,-32(fp)
8110a554:	e0fff917 	ldw	r3,-28(fp)
8110a558:	10c00015 	stw	r3,0(r2)
	descriptor->write_address_low = write_address;
8110a55c:	e0bff817 	ldw	r2,-32(fp)
8110a560:	e0fffa17 	ldw	r3,-24(fp)
8110a564:	10c00115 	stw	r3,4(r2)
	descriptor->transfer_length = length;
8110a568:	e0bff817 	ldw	r2,-32(fp)
8110a56c:	e0c00117 	ldw	r3,4(fp)
8110a570:	10c00215 	stw	r3,8(r2)
	descriptor->sequence_number = sequence_number;
8110a574:	e0bff817 	ldw	r2,-32(fp)
8110a578:	e0fffb0b 	ldhu	r3,-20(fp)
8110a57c:	10c0030d 	sth	r3,12(r2)
	descriptor->read_burst_count = read_burst_count;
8110a580:	e0bff817 	ldw	r2,-32(fp)
8110a584:	e0fffc03 	ldbu	r3,-16(fp)
8110a588:	10c00385 	stb	r3,14(r2)
	descriptor->write_burst_count = write_burst_count;
8110a58c:	e0bff817 	ldw	r2,-32(fp)
8110a590:	e0fffd03 	ldbu	r3,-12(fp)
8110a594:	10c003c5 	stb	r3,15(r2)
	descriptor->read_stride = read_stride;
8110a598:	e0bff817 	ldw	r2,-32(fp)
8110a59c:	e0fffe0b 	ldhu	r3,-8(fp)
8110a5a0:	10c0040d 	sth	r3,16(r2)
	descriptor->write_stride = write_stride;
8110a5a4:	e0bff817 	ldw	r2,-32(fp)
8110a5a8:	e0ffff0b 	ldhu	r3,-4(fp)
8110a5ac:	10c0048d 	sth	r3,18(r2)
	descriptor->read_address_high = read_address_high;
8110a5b0:	e0bff817 	ldw	r2,-32(fp)
8110a5b4:	e0c00317 	ldw	r3,12(fp)
8110a5b8:	10c00515 	stw	r3,20(r2)
	descriptor->write_address_high = write_address_high;
8110a5bc:	e0bff817 	ldw	r2,-32(fp)
8110a5c0:	e0c00417 	ldw	r3,16(fp)
8110a5c4:	10c00615 	stw	r3,24(r2)
	descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
8110a5c8:	e0800217 	ldw	r2,8(fp)
8110a5cc:	10e00034 	orhi	r3,r2,32768
8110a5d0:	e0bff817 	ldw	r2,-32(fp)
8110a5d4:	10c00715 	stw	r3,28(r2)

	return 0;
8110a5d8:	0005883a 	mov	r2,zero

}
8110a5dc:	e037883a 	mov	sp,fp
8110a5e0:	df000017 	ldw	fp,0(sp)
8110a5e4:	dec00104 	addi	sp,sp,4
8110a5e8:	f800283a 	ret

8110a5ec <msgdma_descriptor_async_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_async_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a5ec:	deffee04 	addi	sp,sp,-72
8110a5f0:	de00012e 	bgeu	sp,et,8110a5f8 <msgdma_descriptor_async_transfer+0xc>
8110a5f4:	003b68fa 	trap	3
8110a5f8:	dfc01115 	stw	ra,68(sp)
8110a5fc:	df001015 	stw	fp,64(sp)
8110a600:	df001004 	addi	fp,sp,64
8110a604:	e13ffd15 	stw	r4,-12(fp)
8110a608:	e17ffe15 	stw	r5,-8(fp)
8110a60c:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a610:	e03ff115 	stw	zero,-60(fp)
	alt_irq_context context = 0;
8110a614:	e03ff215 	stw	zero,-56(fp)
	alt_u16 counter = 0;
8110a618:	e03ff00d 	sth	zero,-64(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a61c:	e0bffd17 	ldw	r2,-12(fp)
8110a620:	10800317 	ldw	r2,12(r2)
8110a624:	10800204 	addi	r2,r2,8
8110a628:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a62c:	10bfffcc 	andi	r2,r2,65535
8110a630:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a634:	e0bffd17 	ldw	r2,-12(fp)
8110a638:	10800317 	ldw	r2,12(r2)
8110a63c:	10800204 	addi	r2,r2,8
8110a640:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a644:	1004d43a 	srli	r2,r2,16
8110a648:	e0bff415 	stw	r2,-48(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a64c:	e0bffd17 	ldw	r2,-12(fp)
8110a650:	10800917 	ldw	r2,36(r2)
8110a654:	e0fff417 	ldw	r3,-48(fp)
8110a658:	1880042e 	bgeu	r3,r2,8110a66c <msgdma_descriptor_async_transfer+0x80>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a65c:	e0bffd17 	ldw	r2,-12(fp)
8110a660:	10800917 	ldw	r2,36(r2)
8110a664:	e0fff317 	ldw	r3,-52(fp)
8110a668:	18800236 	bltu	r3,r2,8110a674 <msgdma_descriptor_async_transfer+0x88>
		/*at least one write or read FIFO descriptor buffer is full,
		 returning so that this function is non-blocking*/
		return -ENOSPC;
8110a66c:	00bff904 	movi	r2,-28
8110a670:	00009f06 	br	8110a8f0 <msgdma_descriptor_async_transfer+0x304>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110a674:	e0bffd17 	ldw	r2,-12(fp)
8110a678:	10801817 	ldw	r2,96(r2)
8110a67c:	e0bff615 	stw	r2,-40(fp)
8110a680:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
8110a684:	e0bffc0b 	ldhu	r2,-16(fp)
8110a688:	e0fffc84 	addi	r3,fp,-14
8110a68c:	180d883a 	mov	r6,r3
8110a690:	100b883a 	mov	r5,r2
8110a694:	e13ff617 	ldw	r4,-40(fp)
8110a698:	113aaf40 	call	8113aaf4 <OSSemPend>

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8110a69c:	00800804 	movi	r2,32
8110a6a0:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a6a4:	0005303a 	rdctl	r2,status
8110a6a8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a6ac:	e0fff717 	ldw	r3,-36(fp)
8110a6b0:	00bfff84 	movi	r2,-2
8110a6b4:	1884703a 	and	r2,r3,r2
8110a6b8:	1001703a 	wrctl	status,r2
  
  return context;
8110a6bc:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110a6c0:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a6c4:	e0bffd17 	ldw	r2,-12(fp)
8110a6c8:	10800317 	ldw	r2,12(r2)
8110a6cc:	10800104 	addi	r2,r2,4
8110a6d0:	e0fff117 	ldw	r3,-60(fp)
8110a6d4:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110a6d8:	e0bffd17 	ldw	r2,-12(fp)
8110a6dc:	10800317 	ldw	r2,12(r2)
8110a6e0:	e0fffd17 	ldw	r3,-12(fp)
8110a6e4:	18c00317 	ldw	r3,12(r3)
8110a6e8:	18c00037 	ldwio	r3,0(r3)
8110a6ec:	10c00035 	stwio	r3,0(r2)
8110a6f0:	e0bff217 	ldw	r2,-56(fp)
8110a6f4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a6f8:	e0bffb17 	ldw	r2,-20(fp)
8110a6fc:	1001703a 	wrctl	status,r2
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

	if (NULL != standard_desc && NULL == extended_desc) {
8110a700:	e0bffe17 	ldw	r2,-8(fp)
8110a704:	10001026 	beq	r2,zero,8110a748 <msgdma_descriptor_async_transfer+0x15c>
8110a708:	e0bfff17 	ldw	r2,-4(fp)
8110a70c:	10000e1e 	bne	r2,zero,8110a748 <msgdma_descriptor_async_transfer+0x15c>
		counter = 0; /* reset counter */
8110a710:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110a714:	d0a05e17 	ldw	r2,-32392(gp)
8110a718:	100f883a 	mov	r7,r2
8110a71c:	01800784 	movi	r6,30
8110a720:	01400044 	movi	r5,1
8110a724:	01204574 	movhi	r4,33045
8110a728:	21210c04 	addi	r4,r4,-31696
8110a72c:	111d0b40 	call	8111d0b4 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a730:	e0bffd17 	ldw	r2,-12(fp)
8110a734:	10801817 	ldw	r2,96(r2)
8110a738:	1009883a 	mov	r4,r2
8110a73c:	113ae7c0 	call	8113ae7c <OSSemPost>

		return -ETIME;
8110a740:	00bff084 	movi	r2,-62
8110a744:	00006a06 	br	8110a8f0 <msgdma_descriptor_async_transfer+0x304>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a748:	e0bffe17 	ldw	r2,-8(fp)
8110a74c:	1000231e 	bne	r2,zero,8110a7dc <msgdma_descriptor_async_transfer+0x1f0>
8110a750:	e0bfff17 	ldw	r2,-4(fp)
8110a754:	10002126 	beq	r2,zero,8110a7dc <msgdma_descriptor_async_transfer+0x1f0>
		counter = 0; /* reset counter */
8110a758:	e03ff00d 	sth	zero,-64(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a75c:	00001506 	br	8110a7b4 <msgdma_descriptor_async_transfer+0x1c8>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110a760:	01000044 	movi	r4,1
8110a764:	113227c0 	call	8113227c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a768:	e0bff00b 	ldhu	r2,-64(fp)
8110a76c:	1084e230 	cmpltui	r2,r2,5000
8110a770:	10000d1e 	bne	r2,zero,8110a7a8 <msgdma_descriptor_async_transfer+0x1bc>
			{
#ifdef DEBUG_ON
				debug(fp,
8110a774:	d0a05e17 	ldw	r2,-32392(gp)
8110a778:	100f883a 	mov	r7,r2
8110a77c:	01801544 	movi	r6,85
8110a780:	01400044 	movi	r5,1
8110a784:	01204574 	movhi	r4,33045
8110a788:	21211404 	addi	r4,r4,-31664
8110a78c:	111d0b40 	call	8111d0b4 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110a790:	e0bffd17 	ldw	r2,-12(fp)
8110a794:	10801817 	ldw	r2,96(r2)
8110a798:	1009883a 	mov	r4,r2
8110a79c:	113ae7c0 	call	8113ae7c <OSSemPost>

				return -ETIME;
8110a7a0:	00bff084 	movi	r2,-62
8110a7a4:	00005206 	br	8110a8f0 <msgdma_descriptor_async_transfer+0x304>
			}
			counter++;
8110a7a8:	e0bff00b 	ldhu	r2,-64(fp)
8110a7ac:	10800044 	addi	r2,r2,1
8110a7b0:	e0bff00d 	sth	r2,-64(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110a7b4:	e0bffd17 	ldw	r2,-12(fp)
8110a7b8:	10c00317 	ldw	r3,12(r2)
8110a7bc:	e0bffd17 	ldw	r2,-12(fp)
8110a7c0:	10800417 	ldw	r2,16(r2)
8110a7c4:	e1bfff17 	ldw	r6,-4(fp)
8110a7c8:	100b883a 	mov	r5,r2
8110a7cc:	1809883a 	mov	r4,r3
8110a7d0:	110a34c0 	call	8110a34c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110a7d4:	103fe21e 	bne	r2,zero,8110a760 <__reset+0xfb0ea760>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110a7d8:	00000606 	br	8110a7f4 <msgdma_descriptor_async_transfer+0x208>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110a7dc:	e0bffd17 	ldw	r2,-12(fp)
8110a7e0:	10801817 	ldw	r2,96(r2)
8110a7e4:	1009883a 	mov	r4,r2
8110a7e8:	113ae7c0 	call	8113ae7c <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110a7ec:	00bfffc4 	movi	r2,-1
8110a7f0:	00003f06 	br	8110a8f0 <msgdma_descriptor_async_transfer+0x304>
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up controller to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if (dev->callback) {
8110a7f4:	e0bffd17 	ldw	r2,-12(fp)
8110a7f8:	10800b17 	ldw	r2,44(r2)
8110a7fc:	10001c26 	beq	r2,zero,8110a870 <msgdma_descriptor_async_transfer+0x284>

		control |= (dev->control |
8110a800:	e0bffd17 	ldw	r2,-12(fp)
8110a804:	10c00d17 	ldw	r3,52(r2)
8110a808:	e0bff117 	ldw	r2,-60(fp)
8110a80c:	1884b03a 	or	r2,r3,r2
8110a810:	10800514 	ori	r2,r2,20
8110a814:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
		ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
8110a818:	e0fff117 	ldw	r3,-60(fp)
8110a81c:	00bff7c4 	movi	r2,-33
8110a820:	1884703a 	and	r2,r3,r2
8110a824:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a828:	0005303a 	rdctl	r2,status
8110a82c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a830:	e0fff917 	ldw	r3,-28(fp)
8110a834:	00bfff84 	movi	r2,-2
8110a838:	1884703a 	and	r2,r3,r2
8110a83c:	1001703a 	wrctl	status,r2
  
  return context;
8110a840:	e0bff917 	ldw	r2,-28(fp)
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a844:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a848:	e0bffd17 	ldw	r2,-12(fp)
8110a84c:	10800317 	ldw	r2,12(r2)
8110a850:	10800104 	addi	r2,r2,4
8110a854:	e0fff117 	ldw	r3,-60(fp)
8110a858:	10c00035 	stwio	r3,0(r2)
8110a85c:	e0bff217 	ldw	r2,-56(fp)
8110a860:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a864:	e0bff517 	ldw	r2,-44(fp)
8110a868:	1001703a 	wrctl	status,r2
8110a86c:	00001b06 	br	8110a8dc <msgdma_descriptor_async_transfer+0x2f0>
	 *   - Run
	 *   - Stop on an error with any particular descriptor
	 *   - Disable interrupt generation
	 */
	else {
		control |= (dev->control |
8110a870:	e0bffd17 	ldw	r2,-12(fp)
8110a874:	10c00d17 	ldw	r3,52(r2)
8110a878:	e0bff117 	ldw	r2,-60(fp)
8110a87c:	1884b03a 	or	r2,r3,r2
8110a880:	10800114 	ori	r2,r2,4
8110a884:	e0bff115 	stw	r2,-60(fp)
		ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
		control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK)
8110a888:	e0fff117 	ldw	r3,-60(fp)
8110a88c:	00bff3c4 	movi	r2,-49
8110a890:	1884703a 	and	r2,r3,r2
8110a894:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110a898:	0005303a 	rdctl	r2,status
8110a89c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110a8a0:	e0fffa17 	ldw	r3,-24(fp)
8110a8a4:	00bfff84 	movi	r2,-2
8110a8a8:	1884703a 	and	r2,r3,r2
8110a8ac:	1001703a 	wrctl	status,r2
  
  return context;
8110a8b0:	e0bffa17 	ldw	r2,-24(fp)
				& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		/* making sure the read-modify-write below can't be pre-empted */
		context = alt_irq_disable_all();
8110a8b4:	e0bff215 	stw	r2,-56(fp)
		IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110a8b8:	e0bffd17 	ldw	r2,-12(fp)
8110a8bc:	10800317 	ldw	r2,12(r2)
8110a8c0:	10800104 	addi	r2,r2,4
8110a8c4:	e0fff117 	ldw	r3,-60(fp)
8110a8c8:	10c00035 	stwio	r3,0(r2)
8110a8cc:	e0bff217 	ldw	r2,-56(fp)
8110a8d0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110a8d4:	e0bff817 	ldw	r2,-32(fp)
8110a8d8:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110a8dc:	e0bffd17 	ldw	r2,-12(fp)
8110a8e0:	10801817 	ldw	r2,96(r2)
8110a8e4:	1009883a 	mov	r4,r2
8110a8e8:	113ae7c0 	call	8113ae7c <OSSemPost>

	return 0;
8110a8ec:	0005883a 	mov	r2,zero
}
8110a8f0:	e037883a 	mov	sp,fp
8110a8f4:	dfc00117 	ldw	ra,4(sp)
8110a8f8:	df000017 	ldw	fp,0(sp)
8110a8fc:	dec00204 	addi	sp,sp,8
8110a900:	f800283a 	ret

8110a904 <msgdma_descriptor_sync_transfer>:
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
static int msgdma_descriptor_sync_transfer(alt_msgdma_dev *dev,
		alt_msgdma_standard_descriptor *standard_desc,
		alt_msgdma_extended_descriptor *extended_desc) {
8110a904:	deffee04 	addi	sp,sp,-72
8110a908:	de00012e 	bgeu	sp,et,8110a910 <msgdma_descriptor_sync_transfer+0xc>
8110a90c:	003b68fa 	trap	3
8110a910:	dfc01115 	stw	ra,68(sp)
8110a914:	df001015 	stw	fp,64(sp)
8110a918:	df001004 	addi	fp,sp,64
8110a91c:	e13ffd15 	stw	r4,-12(fp)
8110a920:	e17ffe15 	stw	r5,-8(fp)
8110a924:	e1bfff15 	stw	r6,-4(fp)
	alt_u32 control = 0;
8110a928:	e03ff415 	stw	zero,-48(fp)
	alt_irq_context context = 0;
8110a92c:	e03ff515 	stw	zero,-44(fp)
	alt_u32 csr_status = 0;
8110a930:	e03ff015 	stw	zero,-64(fp)
	alt_u16 counter = 0;
8110a934:	e03ff10d 	sth	zero,-60(fp)
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a938:	e0bffd17 	ldw	r2,-12(fp)
8110a93c:	10800317 	ldw	r2,12(r2)
8110a940:	10800204 	addi	r2,r2,8
8110a944:	10800037 	ldwio	r2,0(r2)
		alt_msgdma_extended_descriptor *extended_desc) {
	alt_u32 control = 0;
	alt_irq_context context = 0;
	alt_u32 csr_status = 0;
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
8110a948:	10bfffcc 	andi	r2,r2,65535
8110a94c:	e0bff215 	stw	r2,-56(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a950:	e0bffd17 	ldw	r2,-12(fp)
8110a954:	10800317 	ldw	r2,12(r2)
8110a958:	10800204 	addi	r2,r2,8
8110a95c:	10800037 	ldwio	r2,0(r2)
	alt_u16 counter = 0;
	alt_u32 fifo_read_fill_level = (
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
	alt_u32 fifo_write_fill_level = (
8110a960:	1004d43a 	srli	r2,r2,16
8110a964:	e0bff315 	stw	r2,-52(fp)
	IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >>
	ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
	alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK |
8110a968:	00807804 	movi	r2,480
8110a96c:	e0bff615 	stw	r2,-40(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a970:	00001d06 	br	8110a9e8 <msgdma_descriptor_sync_transfer+0xe4>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
		alt_busy_sleep(1); /* delay 1us */
8110a974:	01000044 	movi	r4,1
8110a978:	113227c0 	call	8113227c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110a97c:	e0bff10b 	ldhu	r2,-60(fp)
8110a980:	1084e230 	cmpltui	r2,r2,5000
8110a984:	1000091e 	bne	r2,zero,8110a9ac <msgdma_descriptor_sync_transfer+0xa8>
		{
#ifdef DEBUG_ON
			debug(fp,
8110a988:	d0a05e17 	ldw	r2,-32392(gp)
8110a98c:	100f883a 	mov	r7,r2
8110a990:	01801304 	movi	r6,76
8110a994:	01400044 	movi	r5,1
8110a998:	01204574 	movhi	r4,33045
8110a99c:	21212a04 	addi	r4,r4,-31576
8110a9a0:	111d0b40 	call	8111d0b4 <fwrite>
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
8110a9a4:	00bff084 	movi	r2,-62
8110a9a8:	0000d006 	br	8110acec <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110a9ac:	e0bff10b 	ldhu	r2,-60(fp)
8110a9b0:	10800044 	addi	r2,r2,1
8110a9b4:	e0bff10d 	sth	r2,-60(fp)
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a9b8:	e0bffd17 	ldw	r2,-12(fp)
8110a9bc:	10800317 	ldw	r2,12(r2)
8110a9c0:	10800204 	addi	r2,r2,8
8110a9c4:	10800037 	ldwio	r2,0(r2)
					"time out after 5 msec while waiting free FIFO buffer for storing descriptor\n");
#endif
			return -ETIME;
		}
		counter++;
		fifo_read_fill_level = (
8110a9c8:	10bfffcc 	andi	r2,r2,65535
8110a9cc:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
8110a9d0:	e0bffd17 	ldw	r2,-12(fp)
8110a9d4:	10800317 	ldw	r2,12(r2)
8110a9d8:	10800204 	addi	r2,r2,8
8110a9dc:	10800037 	ldwio	r2,0(r2)
		counter++;
		fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) &
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >>
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
		fifo_write_fill_level = (
8110a9e0:	1004d43a 	srli	r2,r2,16
8110a9e4:	e0bff315 	stw	r2,-52(fp)
	ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
	ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
	ALTERA_MSGDMA_CSR_RESET_STATE_MASK;

	/* Wait for available FIFO buffer to store new descriptor*/
	while ((dev->descriptor_fifo_depth <= fifo_write_fill_level)
8110a9e8:	e0bffd17 	ldw	r2,-12(fp)
8110a9ec:	10800917 	ldw	r2,36(r2)
8110a9f0:	e0fff317 	ldw	r3,-52(fp)
8110a9f4:	18bfdf2e 	bgeu	r3,r2,8110a974 <__reset+0xfb0ea974>
			|| (dev->descriptor_fifo_depth <= fifo_read_fill_level)) {
8110a9f8:	e0bffd17 	ldw	r2,-12(fp)
8110a9fc:	10800917 	ldw	r2,36(r2)
8110aa00:	e0fff217 	ldw	r3,-56(fp)
8110aa04:	18bfdb2e 	bgeu	r3,r2,8110a974 <__reset+0xfb0ea974>

	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND(dev->regs_lock, 0);
8110aa08:	e0bffd17 	ldw	r2,-12(fp)
8110aa0c:	10801817 	ldw	r2,96(r2)
8110aa10:	e0bff815 	stw	r2,-32(fp)
8110aa14:	e03ffc0d 	sth	zero,-16(fp)
8110aa18:	e0bffc0b 	ldhu	r2,-16(fp)
8110aa1c:	e0fffc84 	addi	r3,fp,-14
8110aa20:	180d883a 	mov	r6,r3
8110aa24:	100b883a 	mov	r5,r2
8110aa28:	e13ff817 	ldw	r4,-32(fp)
8110aa2c:	113aaf40 	call	8113aaf4 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110aa30:	0005303a 	rdctl	r2,status
8110aa34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110aa38:	e0fffb17 	ldw	r3,-20(fp)
8110aa3c:	00bfff84 	movi	r2,-2
8110aa40:	1884703a 	and	r2,r3,r2
8110aa44:	1001703a 	wrctl	status,r2
  
  return context;
8110aa48:	e0bffb17 	ldw	r2,-20(fp)

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110aa4c:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110aa50:	e0bffd17 	ldw	r2,-12(fp)
8110aa54:	10800317 	ldw	r2,12(r2)
8110aa58:	10800104 	addi	r2,r2,4
8110aa5c:	00c00804 	movi	r3,32
8110aa60:	10c00035 	stwio	r3,0(r2)
			ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110aa64:	e0bffd17 	ldw	r2,-12(fp)
8110aa68:	10800317 	ldw	r2,12(r2)
8110aa6c:	e0fffd17 	ldw	r3,-12(fp)
8110aa70:	18c00317 	ldw	r3,12(r3)
8110aa74:	18c00037 	ldwio	r3,0(r3)
8110aa78:	10c00035 	stwio	r3,0(r2)
			IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

	if (NULL != standard_desc && NULL == extended_desc) {
8110aa7c:	e0bffe17 	ldw	r2,-8(fp)
8110aa80:	10001026 	beq	r2,zero,8110aac4 <msgdma_descriptor_sync_transfer+0x1c0>
8110aa84:	e0bfff17 	ldw	r2,-4(fp)
8110aa88:	10000e1e 	bne	r2,zero,8110aac4 <msgdma_descriptor_sync_transfer+0x1c0>
		counter = 0; /* reset counter */
8110aa8c:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
#ifdef DEBUG_ON
		debug(fp, "invalid dma descriptor option\n");
8110aa90:	d0a05e17 	ldw	r2,-32392(gp)
8110aa94:	100f883a 	mov	r7,r2
8110aa98:	01800784 	movi	r6,30
8110aa9c:	01400044 	movi	r5,1
8110aaa0:	01204574 	movhi	r4,33045
8110aaa4:	21210c04 	addi	r4,r4,-31696
8110aaa8:	111d0b40 	call	8111d0b4 <fwrite>
		/*
		 * Now that access to the registers is complete, release the
		 * registers semaphore so that other threads can access the
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110aaac:	e0bffd17 	ldw	r2,-12(fp)
8110aab0:	10801817 	ldw	r2,96(r2)
8110aab4:	1009883a 	mov	r4,r2
8110aab8:	113ae7c0 	call	8113ae7c <OSSemPost>

		return -ETIME;
8110aabc:	00bff084 	movi	r2,-62
8110aac0:	00008a06 	br	8110acec <msgdma_descriptor_sync_transfer+0x3e8>
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110aac4:	e0bffe17 	ldw	r2,-8(fp)
8110aac8:	1000231e 	bne	r2,zero,8110ab58 <msgdma_descriptor_sync_transfer+0x254>
8110aacc:	e0bfff17 	ldw	r2,-4(fp)
8110aad0:	10002126 	beq	r2,zero,8110ab58 <msgdma_descriptor_sync_transfer+0x254>
		counter = 0; /* reset counter */
8110aad4:	e03ff10d 	sth	zero,-60(fp)
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110aad8:	00001506 	br	8110ab30 <msgdma_descriptor_sync_transfer+0x22c>
				!= msgdma_write_extended_descriptor(dev->csr_base,
						dev->descriptor_base, extended_desc)) {
			alt_busy_sleep(1); /* delay 1us */
8110aadc:	01000044 	movi	r4,1
8110aae0:	113227c0 	call	8113227c <alt_busy_sleep>
			if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110aae4:	e0bff10b 	ldhu	r2,-60(fp)
8110aae8:	1084e230 	cmpltui	r2,r2,5000
8110aaec:	10000d1e 	bne	r2,zero,8110ab24 <msgdma_descriptor_sync_transfer+0x220>
			{
#ifdef DEBUG_ON
				debug(fp,
8110aaf0:	d0a05e17 	ldw	r2,-32392(gp)
8110aaf4:	100f883a 	mov	r7,r2
8110aaf8:	01801004 	movi	r6,64
8110aafc:	01400044 	movi	r5,1
8110ab00:	01204574 	movhi	r4,33045
8110ab04:	21213e04 	addi	r4,r4,-31496
8110ab08:	111d0b40 	call	8111d0b4 <fwrite>
				/*
				 * Now that access to the registers is complete, release the
				 * registers semaphore so that other threads can access the
				 * registers.
				 */
				ALT_SEM_POST(dev->regs_lock);
8110ab0c:	e0bffd17 	ldw	r2,-12(fp)
8110ab10:	10801817 	ldw	r2,96(r2)
8110ab14:	1009883a 	mov	r4,r2
8110ab18:	113ae7c0 	call	8113ae7c <OSSemPost>

				return -ETIME;
8110ab1c:	00bff084 	movi	r2,-62
8110ab20:	00007206 	br	8110acec <msgdma_descriptor_sync_transfer+0x3e8>
			}
			counter++;
8110ab24:	e0bff10b 	ldhu	r2,-60(fp)
8110ab28:	10800044 	addi	r2,r2,1
8110ab2c:	e0bff10d 	sth	r2,-60(fp)
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
				!= msgdma_write_extended_descriptor(dev->csr_base,
8110ab30:	e0bffd17 	ldw	r2,-12(fp)
8110ab34:	10c00317 	ldw	r3,12(r2)
8110ab38:	e0bffd17 	ldw	r2,-12(fp)
8110ab3c:	10800417 	ldw	r2,16(r2)
8110ab40:	e1bfff17 	ldw	r6,-4(fp)
8110ab44:	100b883a 	mov	r5,r2
8110ab48:	1809883a 	mov	r4,r3
8110ab4c:	110a34c0 	call	8110a34c <msgdma_write_extended_descriptor>
		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
		counter = 0; /* reset counter */
		/*writing descriptor structure to the dispatcher, wait until descriptor
		 write is succeed*/
		while (0
8110ab50:	103fe21e 	bne	r2,zero,8110aadc <__reset+0xfb0eaadc>
		 * registers.
		 */
		ALT_SEM_POST(dev->regs_lock);

		return -ETIME;
	} else if (NULL == standard_desc && NULL != extended_desc) {
8110ab54:	00000606 	br	8110ab70 <msgdma_descriptor_sync_transfer+0x26c>
	} else {
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110ab58:	e0bffd17 	ldw	r2,-12(fp)
8110ab5c:	10801817 	ldw	r2,96(r2)
8110ab60:	1009883a 	mov	r4,r2
8110ab64:	113ae7c0 	call	8113ae7c <OSSemPost>

		/* operation not permitted due to descriptor type conflict */
		return -EPERM;
8110ab68:	00bfffc4 	movi	r2,-1
8110ab6c:	00005f06 	br	8110acec <msgdma_descriptor_sync_transfer+0x3e8>
	 * Set up msgdma controller to:
	 * - Disable interrupt generation
	 * - Run once a valid descriptor is written to controller
	 * - Stop on an error with any particular descriptor
	 */
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
8110ab70:	e0bffd17 	ldw	r2,-12(fp)
8110ab74:	10800317 	ldw	r2,12(r2)
8110ab78:	10800104 	addi	r2,r2,4
8110ab7c:	e0fffd17 	ldw	r3,-12(fp)
8110ab80:	19000d17 	ldw	r4,52(r3)
8110ab84:	00fff2c4 	movi	r3,-53
8110ab88:	20c6703a 	and	r3,r4,r3
8110ab8c:	18c00114 	ori	r3,r3,4
8110ab90:	10c00035 	stwio	r3,0(r2)
8110ab94:	e0bff517 	ldw	r2,-44(fp)
8110ab98:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110ab9c:	e0bff717 	ldw	r2,-36(fp)
8110aba0:	1001703a 	wrctl	status,r2
			(dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK ) & (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK));

	alt_irq_enable_all(context);

	counter = 0; /* reset counter */
8110aba4:	e03ff10d 	sth	zero,-60(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110aba8:	e0bffd17 	ldw	r2,-12(fp)
8110abac:	10800317 	ldw	r2,12(r2)
8110abb0:	10800037 	ldwio	r2,0(r2)
8110abb4:	e0bff015 	stw	r2,-64(fp)

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110abb8:	00001906 	br	8110ac20 <msgdma_descriptor_sync_transfer+0x31c>
		alt_busy_sleep(1); /* delay 1us */
8110abbc:	01000044 	movi	r4,1
8110abc0:	113227c0 	call	8113227c <alt_busy_sleep>
		if (5000 <= counter) /* time_out if waiting longer than 5 msec */
8110abc4:	e0bff10b 	ldhu	r2,-60(fp)
8110abc8:	1084e230 	cmpltui	r2,r2,5000
8110abcc:	10000d1e 	bne	r2,zero,8110ac04 <msgdma_descriptor_sync_transfer+0x300>
		{
#ifdef DEBUG_ON
			debug(fp,
8110abd0:	d0a05e17 	ldw	r2,-32392(gp)
8110abd4:	100f883a 	mov	r7,r2
8110abd8:	01801184 	movi	r6,70
8110abdc:	01400044 	movi	r5,1
8110abe0:	01204574 	movhi	r4,33045
8110abe4:	21214f04 	addi	r4,r4,-31428
8110abe8:	111d0b40 	call	8111d0b4 <fwrite>

			/*
			 * Now that access to the registers is complete, release the registers
			 * semaphore so that other threads can access the registers.
			 */
			ALT_SEM_POST(dev->regs_lock);
8110abec:	e0bffd17 	ldw	r2,-12(fp)
8110abf0:	10801817 	ldw	r2,96(r2)
8110abf4:	1009883a 	mov	r4,r2
8110abf8:	113ae7c0 	call	8113ae7c <OSSemPost>

			return -ETIME;
8110abfc:	00bff084 	movi	r2,-62
8110ac00:	00003a06 	br	8110acec <msgdma_descriptor_sync_transfer+0x3e8>
		}
		counter++;
8110ac04:	e0bff10b 	ldhu	r2,-60(fp)
8110ac08:	10800044 	addi	r2,r2,1
8110ac0c:	e0bff10d 	sth	r2,-60(fp)
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
8110ac10:	e0bffd17 	ldw	r2,-12(fp)
8110ac14:	10800317 	ldw	r2,12(r2)
8110ac18:	10800037 	ldwio	r2,0(r2)
8110ac1c:	e0bff015 	stw	r2,-64(fp)

	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);

	/* Wait for any pending transfers to complete or checking any errors or
	 conditions causing descriptor to stop dispatching */
	while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK)) {
8110ac20:	e0fff017 	ldw	r3,-64(fp)
8110ac24:	e0bff617 	ldw	r2,-40(fp)
8110ac28:	1884703a 	and	r2,r3,r2
8110ac2c:	1000031e 	bne	r2,zero,8110ac3c <msgdma_descriptor_sync_transfer+0x338>
8110ac30:	e0bff017 	ldw	r2,-64(fp)
8110ac34:	1080004c 	andi	r2,r2,1
8110ac38:	103fe01e 	bne	r2,zero,8110abbc <__reset+0xfb0eabbc>
		csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	}

	/*Errors or conditions causing the dispatcher stopping issuing read/write
	 commands to masters*/
	if (0 != (csr_status & error)) {
8110ac3c:	e0fff017 	ldw	r3,-64(fp)
8110ac40:	e0bff617 	ldw	r2,-40(fp)
8110ac44:	1884703a 	and	r2,r3,r2
8110ac48:	10000626 	beq	r2,zero,8110ac64 <msgdma_descriptor_sync_transfer+0x360>
		/*
		 * Now that access to the registers is complete, release the registers
		 * semaphore so that other threads can access the registers.
		 */
		ALT_SEM_POST(dev->regs_lock);
8110ac4c:	e0bffd17 	ldw	r2,-12(fp)
8110ac50:	10801817 	ldw	r2,96(r2)
8110ac54:	1009883a 	mov	r4,r2
8110ac58:	113ae7c0 	call	8113ae7c <OSSemPost>

		return error;
8110ac5c:	e0bff617 	ldw	r2,-40(fp)
8110ac60:	00002206 	br	8110acec <msgdma_descriptor_sync_transfer+0x3e8>
	}

	/* Stop the msgdma dispatcher from issuing more descriptors to the
	 read or write masters  */
	/* stop issuing more descriptors */
	control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) |
8110ac64:	e0bffd17 	ldw	r2,-12(fp)
8110ac68:	10800317 	ldw	r2,12(r2)
8110ac6c:	10800104 	addi	r2,r2,4
8110ac70:	10800037 	ldwio	r2,0(r2)
8110ac74:	10800814 	ori	r2,r2,32
8110ac78:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8110ac7c:	0005303a 	rdctl	r2,status
8110ac80:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8110ac84:	e0fffa17 	ldw	r3,-24(fp)
8110ac88:	00bfff84 	movi	r2,-2
8110ac8c:	1884703a 	and	r2,r3,r2
8110ac90:	1001703a 	wrctl	status,r2
  
  return context;
8110ac94:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
8110ac98:	e0bff515 	stw	r2,-44(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
8110ac9c:	e0bffd17 	ldw	r2,-12(fp)
8110aca0:	10800317 	ldw	r2,12(r2)
8110aca4:	10800104 	addi	r2,r2,4
8110aca8:	e0fff417 	ldw	r3,-48(fp)
8110acac:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
8110acb0:	e0bffd17 	ldw	r2,-12(fp)
8110acb4:	10800317 	ldw	r2,12(r2)
8110acb8:	e0fffd17 	ldw	r3,-12(fp)
8110acbc:	18c00317 	ldw	r3,12(r3)
8110acc0:	18c00037 	ldwio	r3,0(r3)
8110acc4:	10c00035 	stwio	r3,0(r2)
8110acc8:	e0bff517 	ldw	r2,-44(fp)
8110accc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8110acd0:	e0bff917 	ldw	r2,-28(fp)
8110acd4:	1001703a 	wrctl	status,r2

	/*
	 * Now that access to the registers is complete, release the registers
	 * semaphore so that other threads can access the registers.
	 */
	ALT_SEM_POST(dev->regs_lock);
8110acd8:	e0bffd17 	ldw	r2,-12(fp)
8110acdc:	10801817 	ldw	r2,96(r2)
8110ace0:	1009883a 	mov	r4,r2
8110ace4:	113ae7c0 	call	8113ae7c <OSSemPost>

	return 0;
8110ace8:	0005883a 	mov	r2,zero

}
8110acec:	e037883a 	mov	sp,fp
8110acf0:	dfc00117 	ldw	ra,4(sp)
8110acf4:	df000017 	ldw	fp,0(sp)
8110acf8:	dec00204 	addi	sp,sp,8
8110acfc:	f800283a 	ret

8110ad00 <iMsgdmaConstructExtendedMmToMmDescriptor>:
int iMsgdmaConstructExtendedMmToMmDescriptor(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDescriptor, alt_u32 *puliReadAddress,
		alt_u32 *puliWriteAddress, alt_u32 uliLength, alt_u32 uliControl,
		alt_u32 *puliReadAddressHigh, alt_u32 *puliWriteAddressHigh,
		alt_u16 usiSequenceNumber, alt_u8 ucReadBurstCount,
		alt_u8 ucWriteBurstCount, alt_u16 usiReadStride, alt_u16 usiWriteStride) {
8110ad00:	deffec04 	addi	sp,sp,-80
8110ad04:	de00012e 	bgeu	sp,et,8110ad0c <iMsgdmaConstructExtendedMmToMmDescriptor+0xc>
8110ad08:	003b68fa 	trap	3
8110ad0c:	dfc01315 	stw	ra,76(sp)
8110ad10:	df001215 	stw	fp,72(sp)
8110ad14:	df001204 	addi	fp,sp,72
8110ad18:	e13ff715 	stw	r4,-36(fp)
8110ad1c:	e17ff815 	stw	r5,-32(fp)
8110ad20:	e1bff915 	stw	r6,-28(fp)
8110ad24:	e1fffa15 	stw	r7,-24(fp)
8110ad28:	e1800617 	ldw	r6,24(fp)
8110ad2c:	e1400717 	ldw	r5,28(fp)
8110ad30:	e1000817 	ldw	r4,32(fp)
8110ad34:	e0c00917 	ldw	r3,36(fp)
8110ad38:	e0800a17 	ldw	r2,40(fp)
8110ad3c:	e1bffb0d 	sth	r6,-20(fp)
8110ad40:	e17ffc05 	stb	r5,-16(fp)
8110ad44:	e13ffd05 	stb	r4,-12(fp)
8110ad48:	e0fffe0d 	sth	r3,-8(fp)
8110ad4c:	e0bfff0d 	sth	r2,-4(fp)
	return msgdma_construct_extended_descriptor(pxDev, pxDescriptor,
8110ad50:	e0bffb0b 	ldhu	r2,-20(fp)
8110ad54:	e0fffc03 	ldbu	r3,-16(fp)
8110ad58:	e13ffd03 	ldbu	r4,-12(fp)
8110ad5c:	e17ffe0b 	ldhu	r5,-8(fp)
8110ad60:	e1bfff0b 	ldhu	r6,-4(fp)
8110ad64:	d9800815 	stw	r6,32(sp)
8110ad68:	d9400715 	stw	r5,28(sp)
8110ad6c:	d9000615 	stw	r4,24(sp)
8110ad70:	d8c00515 	stw	r3,20(sp)
8110ad74:	d8800415 	stw	r2,16(sp)
8110ad78:	e0800517 	ldw	r2,20(fp)
8110ad7c:	d8800315 	stw	r2,12(sp)
8110ad80:	e0800417 	ldw	r2,16(fp)
8110ad84:	d8800215 	stw	r2,8(sp)
8110ad88:	e0800317 	ldw	r2,12(fp)
8110ad8c:	d8800115 	stw	r2,4(sp)
8110ad90:	e0800217 	ldw	r2,8(fp)
8110ad94:	d8800015 	stw	r2,0(sp)
8110ad98:	e1fffa17 	ldw	r7,-24(fp)
8110ad9c:	e1bff917 	ldw	r6,-28(fp)
8110ada0:	e17ff817 	ldw	r5,-32(fp)
8110ada4:	e13ff717 	ldw	r4,-36(fp)
8110ada8:	110a4880 	call	8110a488 <msgdma_construct_extended_descriptor>
			puliReadAddress, puliWriteAddress, uliLength, uliControl,
			puliReadAddressHigh, puliWriteAddressHigh, usiSequenceNumber,
			ucReadBurstCount, ucWriteBurstCount, usiReadStride, usiWriteStride);

}
8110adac:	e037883a 	mov	sp,fp
8110adb0:	dfc00117 	ldw	ra,4(sp)
8110adb4:	df000017 	ldw	fp,0(sp)
8110adb8:	dec00204 	addi	sp,sp,8
8110adbc:	f800283a 	ret

8110adc0 <iMsgdmaExtendedDescriptorAsyncTransfer>:
 * -ENOSPC -> FIFO descriptor buffer is full
 * -EPERM -> operation not permitted due to descriptor type conflict
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int iMsgdmaExtendedDescriptorAsyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110adc0:	defffc04 	addi	sp,sp,-16
8110adc4:	de00012e 	bgeu	sp,et,8110adcc <iMsgdmaExtendedDescriptorAsyncTransfer+0xc>
8110adc8:	003b68fa 	trap	3
8110adcc:	dfc00315 	stw	ra,12(sp)
8110add0:	df000215 	stw	fp,8(sp)
8110add4:	df000204 	addi	fp,sp,8
8110add8:	e13ffe15 	stw	r4,-8(fp)
8110addc:	e17fff15 	stw	r5,-4(fp)
	/*
	 * Error detection/handling should be performed at the application
	 * or callback level as appropriate.
	 */
	return msgdma_descriptor_async_transfer(pxDev, NULL, pxDesc);
8110ade0:	e1bfff17 	ldw	r6,-4(fp)
8110ade4:	000b883a 	mov	r5,zero
8110ade8:	e13ffe17 	ldw	r4,-8(fp)
8110adec:	110a5ec0 	call	8110a5ec <msgdma_descriptor_async_transfer>
}
8110adf0:	e037883a 	mov	sp,fp
8110adf4:	dfc00117 	ldw	ra,4(sp)
8110adf8:	df000017 	ldw	fp,0(sp)
8110adfc:	dec00204 	addi	sp,sp,8
8110ae00:	f800283a 	ret

8110ae04 <iMsgdmaExtendedDescriptorSyncTransfer>:
 *           return -EPERM (operation not permitted due to descriptor type 
 *		conflict)
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int iMsgdmaExtendedDescriptorSyncTransfer(alt_msgdma_dev *pxDev,
		alt_msgdma_extended_descriptor *pxDesc) {
8110ae04:	defffc04 	addi	sp,sp,-16
8110ae08:	de00012e 	bgeu	sp,et,8110ae10 <iMsgdmaExtendedDescriptorSyncTransfer+0xc>
8110ae0c:	003b68fa 	trap	3
8110ae10:	dfc00315 	stw	ra,12(sp)
8110ae14:	df000215 	stw	fp,8(sp)
8110ae18:	df000204 	addi	fp,sp,8
8110ae1c:	e13ffe15 	stw	r4,-8(fp)
8110ae20:	e17fff15 	stw	r5,-4(fp)
	return msgdma_descriptor_sync_transfer(pxDev, NULL, pxDesc);
8110ae24:	e1bfff17 	ldw	r6,-4(fp)
8110ae28:	000b883a 	mov	r5,zero
8110ae2c:	e13ffe17 	ldw	r4,-8(fp)
8110ae30:	110a9040 	call	8110a904 <msgdma_descriptor_sync_transfer>
}
8110ae34:	e037883a 	mov	sp,fp
8110ae38:	dfc00117 	ldw	ra,4(sp)
8110ae3c:	df000017 	ldw	fp,0(sp)
8110ae40:	dec00204 	addi	sp,sp,8
8110ae44:	f800283a 	ret

8110ae48 <POWER_SPI_RW>:
#define SPI_SDI(x)    IOWR_ALTERA_AVALON_PIO_DATA(CSENSE_SDI_BASE,x)
#define SPI_SDO       (IORD_ALTERA_AVALON_PIO_DATA(CSENSE_SDO_BASE) & 0x01)
#define SPI_DELAY     usleep(15)  // based on 50MHZ of CPU clock
// Note. SCK: typical 19.2KHZ (53 ms)
bool POWER_SPI_RW(alt_u8 IcIndex, alt_u8 NextChannel, bool bEN, bool bSIGN,
		bool bSGL, alt_u32 *pValue) {
8110ae48:	defff204 	addi	sp,sp,-56
8110ae4c:	de00012e 	bgeu	sp,et,8110ae54 <POWER_SPI_RW+0xc>
8110ae50:	003b68fa 	trap	3
8110ae54:	dfc00d15 	stw	ra,52(sp)
8110ae58:	df000c15 	stw	fp,48(sp)
8110ae5c:	df000c04 	addi	fp,sp,48
8110ae60:	2007883a 	mov	r3,r4
8110ae64:	2805883a 	mov	r2,r5
8110ae68:	e1bffe15 	stw	r6,-8(fp)
8110ae6c:	e1ffff15 	stw	r7,-4(fp)
8110ae70:	e0fffc05 	stb	r3,-16(fp)
8110ae74:	e0bffd05 	stb	r2,-12(fp)
	bool bSuccess;
	alt_u8 Config8;
	alt_u32 Value32 = 0, Mask32;
8110ae78:	e03ff515 	stw	zero,-44(fp)
	int i, nWait = 0, nZeroCnt;
8110ae7c:	e03ff815 	stw	zero,-32(fp)
	const int nMaxWait = 1000000;
8110ae80:	008003f4 	movhi	r2,15
8110ae84:	10909004 	addi	r2,r2,16960
8110ae88:	e0bffa15 	stw	r2,-24(fp)

	//
	Config8 = 0x80;
8110ae8c:	00bfe004 	movi	r2,-128
8110ae90:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bEN) ? 0x20 : 0x00;
8110ae94:	e0bffe17 	ldw	r2,-8(fp)
8110ae98:	10000226 	beq	r2,zero,8110aea4 <POWER_SPI_RW+0x5c>
8110ae9c:	00800804 	movi	r2,32
8110aea0:	00000106 	br	8110aea8 <POWER_SPI_RW+0x60>
8110aea4:	0005883a 	mov	r2,zero
8110aea8:	e0fff403 	ldbu	r3,-48(fp)
8110aeac:	10c4b03a 	or	r2,r2,r3
8110aeb0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSGL) ? 0x10 : 0x00;
8110aeb4:	e0800217 	ldw	r2,8(fp)
8110aeb8:	10000226 	beq	r2,zero,8110aec4 <POWER_SPI_RW+0x7c>
8110aebc:	00800404 	movi	r2,16
8110aec0:	00000106 	br	8110aec8 <POWER_SPI_RW+0x80>
8110aec4:	0005883a 	mov	r2,zero
8110aec8:	e0fff403 	ldbu	r3,-48(fp)
8110aecc:	10c4b03a 	or	r2,r2,r3
8110aed0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= (bSIGN) ? 0x08 : 0x00;
8110aed4:	e0bfff17 	ldw	r2,-4(fp)
8110aed8:	10000226 	beq	r2,zero,8110aee4 <POWER_SPI_RW+0x9c>
8110aedc:	00800204 	movi	r2,8
8110aee0:	00000106 	br	8110aee8 <POWER_SPI_RW+0xa0>
8110aee4:	0005883a 	mov	r2,zero
8110aee8:	e0fff403 	ldbu	r3,-48(fp)
8110aeec:	10c4b03a 	or	r2,r2,r3
8110aef0:	e0bff405 	stb	r2,-48(fp)
	Config8 |= NextChannel & 0x07; // channel
8110aef4:	e0bffd03 	ldbu	r2,-12(fp)
8110aef8:	108001cc 	andi	r2,r2,7
8110aefc:	1007883a 	mov	r3,r2
8110af00:	e0bff403 	ldbu	r2,-48(fp)
8110af04:	1884b03a 	or	r2,r3,r2
8110af08:	e0bff405 	stb	r2,-48(fp)

	SPI_FO(0); // use internal conversion clock
8110af0c:	0007883a 	mov	r3,zero
8110af10:	00a00034 	movhi	r2,32768
8110af14:	10824404 	addi	r2,r2,2320
8110af18:	10c00035 	stwio	r3,0(r2)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
8110af1c:	0007883a 	mov	r3,zero
8110af20:	00a00034 	movhi	r2,32768
8110af24:	10824c04 	addi	r2,r2,2352
8110af28:	10c00035 	stwio	r3,0(r2)
	SPI_CS_N(IcIndex, 0);  // chip select: active
8110af2c:	e0bffc03 	ldbu	r2,-16(fp)
8110af30:	1000021e 	bne	r2,zero,8110af3c <POWER_SPI_RW+0xf4>
8110af34:	00c00084 	movi	r3,2
8110af38:	00000106 	br	8110af40 <POWER_SPI_RW+0xf8>
8110af3c:	00c00044 	movi	r3,1
8110af40:	00a00034 	movhi	r2,32768
8110af44:	10824804 	addi	r2,r2,2336
8110af48:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110af4c:	010003c4 	movi	r4,15
8110af50:	1133cf00 	call	81133cf0 <usleep>

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110af54:	00000306 	br	8110af64 <POWER_SPI_RW+0x11c>
		nWait++;
8110af58:	e0bff817 	ldw	r2,-32(fp)
8110af5c:	10800044 	addi	r2,r2,1
8110af60:	e0bff815 	stw	r2,-32(fp)
	SPI_SCK(0);  // set low to active extenal serial clock mode.
	SPI_CS_N(IcIndex, 0);  // chip select: active
	SPI_DELAY;

	// wait for converion end (when conversion done, SPI_SDO is low)
	while (SPI_SDO && nWait < nMaxWait) {
8110af64:	00a00034 	movhi	r2,32768
8110af68:	10825404 	addi	r2,r2,2384
8110af6c:	10800037 	ldwio	r2,0(r2)
8110af70:	1080004c 	andi	r2,r2,1
8110af74:	10000326 	beq	r2,zero,8110af84 <POWER_SPI_RW+0x13c>
8110af78:	e0fff817 	ldw	r3,-32(fp)
8110af7c:	e0bffa17 	ldw	r2,-24(fp)
8110af80:	18bff516 	blt	r3,r2,8110af58 <__reset+0xfb0eaf58>
		nWait++;
	}

	if (SPI_SDO) {
8110af84:	00a00034 	movhi	r2,32768
8110af88:	10825404 	addi	r2,r2,2384
8110af8c:	10800037 	ldwio	r2,0(r2)
8110af90:	1080004c 	andi	r2,r2,1
8110af94:	10000626 	beq	r2,zero,8110afb0 <POWER_SPI_RW+0x168>
		SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110af98:	00c000c4 	movi	r3,3
8110af9c:	00a00034 	movhi	r2,32768
8110afa0:	10824804 	addi	r2,r2,2336
8110afa4:	10c00035 	stwio	r3,0(r2)
#ifdef DEBUG_ON
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
8110afa8:	0005883a 	mov	r2,zero
8110afac:	0000db06 	br	8110b31c <POWER_SPI_RW+0x4d4>
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110afb0:	e03ff715 	stw	zero,-36(fp)
8110afb4:	00002406 	br	8110b048 <POWER_SPI_RW+0x200>
			// ignore EOC/ and DMY bits
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0);    //sdi=nextch.7; // put data on pin
8110afb8:	e0bff403 	ldbu	r2,-48(fp)
8110afbc:	10803fcc 	andi	r2,r2,255
8110afc0:	1004d1fa 	srli	r2,r2,7
8110afc4:	10c03fcc 	andi	r3,r2,255
8110afc8:	00a00034 	movhi	r2,32768
8110afcc:	10825004 	addi	r2,r2,2368
8110afd0:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110afd4:	e0bff403 	ldbu	r2,-48(fp)
8110afd8:	1085883a 	add	r2,r2,r2
8110afdc:	e0bff405 	stb	r2,-48(fp)
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110afe0:	e0bff517 	ldw	r2,-44(fp)
8110afe4:	1085883a 	add	r2,r2,r2
8110afe8:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110afec:	00a00034 	movhi	r2,32768
8110aff0:	10825404 	addi	r2,r2,2384
8110aff4:	10800037 	ldwio	r2,0(r2)
8110aff8:	1080004c 	andi	r2,r2,1
8110affc:	1007883a 	mov	r3,r2
8110b000:	e0bff517 	ldw	r2,-44(fp)
8110b004:	10c4b03a 	or	r2,r2,r3
8110b008:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b00c:	00c00044 	movi	r3,1
8110b010:	00a00034 	movhi	r2,32768
8110b014:	10824c04 	addi	r2,r2,2352
8110b018:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b01c:	010003c4 	movi	r4,15
8110b020:	1133cf00 	call	81133cf0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b024:	0007883a 	mov	r3,zero
8110b028:	00a00034 	movhi	r2,32768
8110b02c:	10824c04 	addi	r2,r2,2352
8110b030:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b034:	010003c4 	movi	r4,15
8110b038:	1133cf00 	call	81133cf0 <usleep>
//		debug(fp, "Timeout \r\n");
#endif
		return FALSE;
	}

	for (i = 0; i < 2; i++) // send config bits 7:6,
8110b03c:	e0bff717 	ldw	r2,-36(fp)
8110b040:	10800044 	addi	r2,r2,1
8110b044:	e0bff715 	stw	r2,-36(fp)
8110b048:	e0bff717 	ldw	r2,-36(fp)
8110b04c:	10800090 	cmplti	r2,r2,2
8110b050:	103fd91e 	bne	r2,zero,8110afb8 <__reset+0xfb0eafb8>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110b054:	e03ff715 	stw	zero,-36(fp)
8110b058:	00002406 	br	8110b0ec <POWER_SPI_RW+0x2a4>
			{
		SPI_SDI((Config8 & 0x80) ? 1 : 0); //sdi=nextch.7; // put data on pin
8110b05c:	e0bff403 	ldbu	r2,-48(fp)
8110b060:	10803fcc 	andi	r2,r2,255
8110b064:	1004d1fa 	srli	r2,r2,7
8110b068:	10c03fcc 	andi	r3,r2,255
8110b06c:	00a00034 	movhi	r2,32768
8110b070:	10825004 	addi	r2,r2,2368
8110b074:	10c00035 	stwio	r3,0(r2)
		Config8 <<= 1; //nextch = rl(nextch); // get next config bit ready
8110b078:	e0bff403 	ldbu	r2,-48(fp)
8110b07c:	1085883a 	add	r2,r2,r2
8110b080:	e0bff405 	stb	r2,-48(fp)

		Value32 <<= 1; //result_3 = rl(result_3);// get ready to load lsb
8110b084:	e0bff517 	ldw	r2,-44(fp)
8110b088:	1085883a 	add	r2,r2,r2
8110b08c:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_3.0 = sdo; // load lsb
8110b090:	00a00034 	movhi	r2,32768
8110b094:	10825404 	addi	r2,r2,2384
8110b098:	10800037 	ldwio	r2,0(r2)
8110b09c:	1080004c 	andi	r2,r2,1
8110b0a0:	1007883a 	mov	r3,r2
8110b0a4:	e0bff517 	ldw	r2,-44(fp)
8110b0a8:	10c4b03a 	or	r2,r2,r3
8110b0ac:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b0b0:	00c00044 	movi	r3,1
8110b0b4:	00a00034 	movhi	r2,32768
8110b0b8:	10824c04 	addi	r2,r2,2352
8110b0bc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b0c0:	010003c4 	movi	r4,15
8110b0c4:	1133cf00 	call	81133cf0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b0c8:	0007883a 	mov	r3,zero
8110b0cc:	00a00034 	movhi	r2,32768
8110b0d0:	10824c04 	addi	r2,r2,2352
8110b0d4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b0d8:	010003c4 	movi	r4,15
8110b0dc:	1133cf00 	call	81133cf0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // send config, read byte 3
8110b0e0:	e0bff717 	ldw	r2,-36(fp)
8110b0e4:	10800044 	addi	r2,r2,1
8110b0e8:	e0bff715 	stw	r2,-36(fp)
8110b0ec:	e0bff717 	ldw	r2,-36(fp)
8110b0f0:	10800210 	cmplti	r2,r2,8
8110b0f4:	103fd91e 	bne	r2,zero,8110b05c <__reset+0xfb0eb05c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110b0f8:	e03ff715 	stw	zero,-36(fp)
8110b0fc:	00001a06 	br	8110b168 <POWER_SPI_RW+0x320>
			{
		Value32 <<= 1; //result_2 = rl(result_2);// get ready to load lsb
8110b100:	e0bff517 	ldw	r2,-44(fp)
8110b104:	1085883a 	add	r2,r2,r2
8110b108:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_2.0 = sdo; // load lsb
8110b10c:	00a00034 	movhi	r2,32768
8110b110:	10825404 	addi	r2,r2,2384
8110b114:	10800037 	ldwio	r2,0(r2)
8110b118:	1080004c 	andi	r2,r2,1
8110b11c:	1007883a 	mov	r3,r2
8110b120:	e0bff517 	ldw	r2,-44(fp)
8110b124:	10c4b03a 	or	r2,r2,r3
8110b128:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b12c:	00c00044 	movi	r3,1
8110b130:	00a00034 	movhi	r2,32768
8110b134:	10824c04 	addi	r2,r2,2352
8110b138:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b13c:	010003c4 	movi	r4,15
8110b140:	1133cf00 	call	81133cf0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b144:	0007883a 	mov	r3,zero
8110b148:	00a00034 	movhi	r2,32768
8110b14c:	10824c04 	addi	r2,r2,2352
8110b150:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b154:	010003c4 	movi	r4,15
8110b158:	1133cf00 	call	81133cf0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 2
8110b15c:	e0bff717 	ldw	r2,-36(fp)
8110b160:	10800044 	addi	r2,r2,1
8110b164:	e0bff715 	stw	r2,-36(fp)
8110b168:	e0bff717 	ldw	r2,-36(fp)
8110b16c:	10800210 	cmplti	r2,r2,8
8110b170:	103fe31e 	bne	r2,zero,8110b100 <__reset+0xfb0eb100>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110b174:	e03ff715 	stw	zero,-36(fp)
8110b178:	00001a06 	br	8110b1e4 <POWER_SPI_RW+0x39c>
			{
		Value32 <<= 1; //result_1 = rl(result_1);// get ready to load lsb
8110b17c:	e0bff517 	ldw	r2,-44(fp)
8110b180:	1085883a 	add	r2,r2,r2
8110b184:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_1.0 = sdo; // load lsb
8110b188:	00a00034 	movhi	r2,32768
8110b18c:	10825404 	addi	r2,r2,2384
8110b190:	10800037 	ldwio	r2,0(r2)
8110b194:	1080004c 	andi	r2,r2,1
8110b198:	1007883a 	mov	r3,r2
8110b19c:	e0bff517 	ldw	r2,-44(fp)
8110b1a0:	10c4b03a 	or	r2,r2,r3
8110b1a4:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b1a8:	00c00044 	movi	r3,1
8110b1ac:	00a00034 	movhi	r2,32768
8110b1b0:	10824c04 	addi	r2,r2,2352
8110b1b4:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b1b8:	010003c4 	movi	r4,15
8110b1bc:	1133cf00 	call	81133cf0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b1c0:	0007883a 	mov	r3,zero
8110b1c4:	00a00034 	movhi	r2,32768
8110b1c8:	10824c04 	addi	r2,r2,2352
8110b1cc:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b1d0:	010003c4 	movi	r4,15
8110b1d4:	1133cf00 	call	81133cf0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 8; i++) // read byte 1
8110b1d8:	e0bff717 	ldw	r2,-36(fp)
8110b1dc:	10800044 	addi	r2,r2,1
8110b1e0:	e0bff715 	stw	r2,-36(fp)
8110b1e4:	e0bff717 	ldw	r2,-36(fp)
8110b1e8:	10800210 	cmplti	r2,r2,8
8110b1ec:	103fe31e 	bne	r2,zero,8110b17c <__reset+0xfb0eb17c>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110b1f0:	e03ff715 	stw	zero,-36(fp)
8110b1f4:	00001a06 	br	8110b260 <POWER_SPI_RW+0x418>
			{
		Value32 <<= 1; //result_0 = rl(result_0);// get ready to load lsb
8110b1f8:	e0bff517 	ldw	r2,-44(fp)
8110b1fc:	1085883a 	add	r2,r2,r2
8110b200:	e0bff515 	stw	r2,-44(fp)
		Value32 |= SPI_SDO; //result_0.0 = sdo; // load lsb
8110b204:	00a00034 	movhi	r2,32768
8110b208:	10825404 	addi	r2,r2,2384
8110b20c:	10800037 	ldwio	r2,0(r2)
8110b210:	1080004c 	andi	r2,r2,1
8110b214:	1007883a 	mov	r3,r2
8110b218:	e0bff517 	ldw	r2,-44(fp)
8110b21c:	10c4b03a 	or	r2,r2,r3
8110b220:	e0bff515 	stw	r2,-44(fp)

		SPI_SCK(1); //sck=1; // clock high
8110b224:	00c00044 	movi	r3,1
8110b228:	00a00034 	movhi	r2,32768
8110b22c:	10824c04 	addi	r2,r2,2352
8110b230:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b234:	010003c4 	movi	r4,15
8110b238:	1133cf00 	call	81133cf0 <usleep>
		SPI_SCK(0); //sck=0; // clock low
8110b23c:	0007883a 	mov	r3,zero
8110b240:	00a00034 	movhi	r2,32768
8110b244:	10824c04 	addi	r2,r2,2352
8110b248:	10c00035 	stwio	r3,0(r2)
		SPI_DELAY;
8110b24c:	010003c4 	movi	r4,15
8110b250:	1133cf00 	call	81133cf0 <usleep>
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}

	for (i = 0; i < 6; i++) // read byte 0
8110b254:	e0bff717 	ldw	r2,-36(fp)
8110b258:	10800044 	addi	r2,r2,1
8110b25c:	e0bff715 	stw	r2,-36(fp)
8110b260:	e0bff717 	ldw	r2,-36(fp)
8110b264:	10800190 	cmplti	r2,r2,6
8110b268:	103fe31e 	bne	r2,zero,8110b1f8 <__reset+0xfb0eb1f8>
		SPI_SCK(1); //sck=1; // clock high
		SPI_DELAY;
		SPI_SCK(0); //sck=0; // clock low
		SPI_DELAY;
	}
	SPI_SCK(1);
8110b26c:	00c00044 	movi	r3,1
8110b270:	00a00034 	movhi	r2,32768
8110b274:	10824c04 	addi	r2,r2,2352
8110b278:	10c00035 	stwio	r3,0(r2)
	SPI_DELAY;
8110b27c:	010003c4 	movi	r4,15
8110b280:	1133cf00 	call	81133cf0 <usleep>
	SPI_CS_N(IcIndex, 1);  // chip select: inactive
8110b284:	00c000c4 	movi	r3,3
8110b288:	00a00034 	movhi	r2,32768
8110b28c:	10824804 	addi	r2,r2,2336
8110b290:	10c00035 	stwio	r3,0(r2)

	// check parity
	nZeroCnt = 0;
8110b294:	e03ff915 	stw	zero,-28(fp)
	Mask32 = 0x01;
8110b298:	00800044 	movi	r2,1
8110b29c:	e0bff615 	stw	r2,-40(fp)
	for (i = 0; i < 32; i++) {
8110b2a0:	e03ff715 	stw	zero,-36(fp)
8110b2a4:	00000d06 	br	8110b2dc <POWER_SPI_RW+0x494>
		if ((Value32 & Mask32) == 0x00) {
8110b2a8:	e0fff517 	ldw	r3,-44(fp)
8110b2ac:	e0bff617 	ldw	r2,-40(fp)
8110b2b0:	1884703a 	and	r2,r3,r2
8110b2b4:	1000031e 	bne	r2,zero,8110b2c4 <POWER_SPI_RW+0x47c>
			nZeroCnt++;
8110b2b8:	e0bff917 	ldw	r2,-28(fp)
8110b2bc:	10800044 	addi	r2,r2,1
8110b2c0:	e0bff915 	stw	r2,-28(fp)
		}
		Mask32 <<= 1;
8110b2c4:	e0bff617 	ldw	r2,-40(fp)
8110b2c8:	1085883a 	add	r2,r2,r2
8110b2cc:	e0bff615 	stw	r2,-40(fp)
	SPI_CS_N(IcIndex, 1);  // chip select: inactive

	// check parity
	nZeroCnt = 0;
	Mask32 = 0x01;
	for (i = 0; i < 32; i++) {
8110b2d0:	e0bff717 	ldw	r2,-36(fp)
8110b2d4:	10800044 	addi	r2,r2,1
8110b2d8:	e0bff715 	stw	r2,-36(fp)
8110b2dc:	e0bff717 	ldw	r2,-36(fp)
8110b2e0:	10800810 	cmplti	r2,r2,32
8110b2e4:	103ff01e 	bne	r2,zero,8110b2a8 <__reset+0xfb0eb2a8>
		if ((Value32 & Mask32) == 0x00) {
			nZeroCnt++;
		}
		Mask32 <<= 1;
	}
	bSuccess = (nZeroCnt & 0x01) ? FALSE : TRUE;
8110b2e8:	e0bff917 	ldw	r2,-28(fp)
8110b2ec:	1080004c 	andi	r2,r2,1
8110b2f0:	1005003a 	cmpeq	r2,r2,zero
8110b2f4:	10803fcc 	andi	r2,r2,255
8110b2f8:	e0bffb15 	stw	r2,-20(fp)
	if (!bSuccess) {
8110b2fc:	e0bffb17 	ldw	r2,-20(fp)
8110b300:	1000021e 	bne	r2,zero,8110b30c <POWER_SPI_RW+0x4c4>
#ifdef DEBUG_ON
//		debug(fp, "Parity Check Error \r\n");
#endif
		return FALSE;
8110b304:	0005883a 	mov	r2,zero
8110b308:	00000406 	br	8110b31c <POWER_SPI_RW+0x4d4>
	}

	*pValue = Value32;
8110b30c:	e0800317 	ldw	r2,12(fp)
8110b310:	e0fff517 	ldw	r3,-44(fp)
8110b314:	10c00015 	stw	r3,0(r2)

	return bSuccess;
8110b318:	e0bffb17 	ldw	r2,-20(fp)
}
8110b31c:	e037883a 	mov	sp,fp
8110b320:	dfc00117 	ldw	ra,4(sp)
8110b324:	df000017 	ldw	fp,0(sp)
8110b328:	dec00204 	addi	sp,sp,8
8110b32c:	f800283a 	ret

8110b330 <vRstcSimucamReset>:

//! [program memory private global variables]
//! [program memory private global variables]

//! [public functions]
void vRstcSimucamReset(alt_u16 usiRstCnt) {
8110b330:	defffc04 	addi	sp,sp,-16
8110b334:	de00012e 	bgeu	sp,et,8110b33c <vRstcSimucamReset+0xc>
8110b338:	003b68fa 	trap	3
8110b33c:	dfc00315 	stw	ra,12(sp)
8110b340:	df000215 	stw	fp,8(sp)
8110b344:	df000204 	addi	fp,sp,8
8110b348:	2005883a 	mov	r2,r4
8110b34c:	e0bfff0d 	sth	r2,-4(fp)
	alt_u32 uliReg = 0;
8110b350:	e03ffe15 	stw	zero,-8(fp)

	uliReg |= (alt_u32) (usiRstCnt & RSTC_SIMUCAM_RST_TMR_MSK);
8110b354:	e0bfff0b 	ldhu	r2,-4(fp)
8110b358:	e0fffe17 	ldw	r3,-8(fp)
8110b35c:	1884b03a 	or	r2,r3,r2
8110b360:	e0bffe15 	stw	r2,-8(fp)
	uliReg |= (alt_u32) RSTC_SIMUCAM_RST_CTRL_MSK;
8110b364:	e0bffe17 	ldw	r2,-8(fp)
8110b368:	10800074 	orhi	r2,r2,1
8110b36c:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b370:	e1bffe17 	ldw	r6,-8(fp)
8110b374:	000b883a 	mov	r5,zero
8110b378:	01200034 	movhi	r4,32768
8110b37c:	21020004 	addi	r4,r4,2048
8110b380:	110b4800 	call	8110b480 <vRstcWriteReg>
	RSTC_SIMUCAM_RESET_REG_OFFSET, uliReg);
}
8110b384:	0001883a 	nop
8110b388:	e037883a 	mov	sp,fp
8110b38c:	dfc00117 	ldw	ra,4(sp)
8110b390:	df000017 	ldw	fp,0(sp)
8110b394:	dec00204 	addi	sp,sp,8
8110b398:	f800283a 	ret

8110b39c <vRstcReleaseDeviceReset>:

void vRstcReleaseDeviceReset(alt_u32 usiRstMask) {
8110b39c:	defffc04 	addi	sp,sp,-16
8110b3a0:	de00012e 	bgeu	sp,et,8110b3a8 <vRstcReleaseDeviceReset+0xc>
8110b3a4:	003b68fa 	trap	3
8110b3a8:	dfc00315 	stw	ra,12(sp)
8110b3ac:	df000215 	stw	fp,8(sp)
8110b3b0:	df000204 	addi	fp,sp,8
8110b3b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b3b8:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b3bc:	01400044 	movi	r5,1
8110b3c0:	01200034 	movhi	r4,32768
8110b3c4:	21020004 	addi	r4,r4,2048
8110b3c8:	110b4d40 	call	8110b4d4 <uliRstReadReg>
8110b3cc:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg &= ~((alt_u32) usiRstMask);
8110b3d0:	e0bfff17 	ldw	r2,-4(fp)
8110b3d4:	0084303a 	nor	r2,zero,r2
8110b3d8:	e0fffe17 	ldw	r3,-8(fp)
8110b3dc:	1884703a 	and	r2,r3,r2
8110b3e0:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b3e4:	e1bffe17 	ldw	r6,-8(fp)
8110b3e8:	01400044 	movi	r5,1
8110b3ec:	01200034 	movhi	r4,32768
8110b3f0:	21020004 	addi	r4,r4,2048
8110b3f4:	110b4800 	call	8110b480 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b3f8:	0001883a 	nop
8110b3fc:	e037883a 	mov	sp,fp
8110b400:	dfc00117 	ldw	ra,4(sp)
8110b404:	df000017 	ldw	fp,0(sp)
8110b408:	dec00204 	addi	sp,sp,8
8110b40c:	f800283a 	ret

8110b410 <vRstcHoldDeviceReset>:

void vRstcHoldDeviceReset(alt_u32 usiRstMask) {
8110b410:	defffc04 	addi	sp,sp,-16
8110b414:	de00012e 	bgeu	sp,et,8110b41c <vRstcHoldDeviceReset+0xc>
8110b418:	003b68fa 	trap	3
8110b41c:	dfc00315 	stw	ra,12(sp)
8110b420:	df000215 	stw	fp,8(sp)
8110b424:	df000204 	addi	fp,sp,8
8110b428:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliReg = 0;
8110b42c:	e03ffe15 	stw	zero,-8(fp)

	uliReg = uliRstReadReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b430:	01400044 	movi	r5,1
8110b434:	01200034 	movhi	r4,32768
8110b438:	21020004 	addi	r4,r4,2048
8110b43c:	110b4d40 	call	8110b4d4 <uliRstReadReg>
8110b440:	e0bffe15 	stw	r2,-8(fp)
	RSTC_DEVICE_RESET_REG_OFFSET);
	uliReg |= (alt_u32) usiRstMask;
8110b444:	e0fffe17 	ldw	r3,-8(fp)
8110b448:	e0bfff17 	ldw	r2,-4(fp)
8110b44c:	1884b03a 	or	r2,r3,r2
8110b450:	e0bffe15 	stw	r2,-8(fp)
	vRstcWriteReg((alt_u32*) RSTC_CONTROLLER_BASE_ADDR,
8110b454:	e1bffe17 	ldw	r6,-8(fp)
8110b458:	01400044 	movi	r5,1
8110b45c:	01200034 	movhi	r4,32768
8110b460:	21020004 	addi	r4,r4,2048
8110b464:	110b4800 	call	8110b480 <vRstcWriteReg>
	RSTC_DEVICE_RESET_REG_OFFSET, uliReg);
}
8110b468:	0001883a 	nop
8110b46c:	e037883a 	mov	sp,fp
8110b470:	dfc00117 	ldw	ra,4(sp)
8110b474:	df000017 	ldw	fp,0(sp)
8110b478:	dec00204 	addi	sp,sp,8
8110b47c:	f800283a 	ret

8110b480 <vRstcWriteReg>:
//! [public functions]

//! [private functions]
static void vRstcWriteReg(alt_u32 *puliAddr, alt_u32 uliOffset,
		alt_u32 uliValue) {
8110b480:	defffc04 	addi	sp,sp,-16
8110b484:	de00012e 	bgeu	sp,et,8110b48c <vRstcWriteReg+0xc>
8110b488:	003b68fa 	trap	3
8110b48c:	df000315 	stw	fp,12(sp)
8110b490:	df000304 	addi	fp,sp,12
8110b494:	e13ffd15 	stw	r4,-12(fp)
8110b498:	e17ffe15 	stw	r5,-8(fp)
8110b49c:	e1bfff15 	stw	r6,-4(fp)
	*(puliAddr + uliOffset) = uliValue;
8110b4a0:	e0bffe17 	ldw	r2,-8(fp)
8110b4a4:	1085883a 	add	r2,r2,r2
8110b4a8:	1085883a 	add	r2,r2,r2
8110b4ac:	1007883a 	mov	r3,r2
8110b4b0:	e0bffd17 	ldw	r2,-12(fp)
8110b4b4:	10c5883a 	add	r2,r2,r3
8110b4b8:	e0ffff17 	ldw	r3,-4(fp)
8110b4bc:	10c00015 	stw	r3,0(r2)
}
8110b4c0:	0001883a 	nop
8110b4c4:	e037883a 	mov	sp,fp
8110b4c8:	df000017 	ldw	fp,0(sp)
8110b4cc:	dec00104 	addi	sp,sp,4
8110b4d0:	f800283a 	ret

8110b4d4 <uliRstReadReg>:

static alt_u32 uliRstReadReg(alt_u32 *puliAddr, alt_u32 uliOffset) {
8110b4d4:	defffc04 	addi	sp,sp,-16
8110b4d8:	de00012e 	bgeu	sp,et,8110b4e0 <uliRstReadReg+0xc>
8110b4dc:	003b68fa 	trap	3
8110b4e0:	df000315 	stw	fp,12(sp)
8110b4e4:	df000304 	addi	fp,sp,12
8110b4e8:	e13ffe15 	stw	r4,-8(fp)
8110b4ec:	e17fff15 	stw	r5,-4(fp)
	alt_u32 uliValue;

	uliValue = *(puliAddr + uliOffset);
8110b4f0:	e0bfff17 	ldw	r2,-4(fp)
8110b4f4:	1085883a 	add	r2,r2,r2
8110b4f8:	1085883a 	add	r2,r2,r2
8110b4fc:	1007883a 	mov	r3,r2
8110b500:	e0bffe17 	ldw	r2,-8(fp)
8110b504:	10c5883a 	add	r2,r2,r3
8110b508:	10800017 	ldw	r2,0(r2)
8110b50c:	e0bffd15 	stw	r2,-12(fp)
	return uliValue;
8110b510:	e0bffd17 	ldw	r2,-12(fp)
}
8110b514:	e037883a 	mov	sp,fp
8110b518:	df000017 	ldw	fp,0(sp)
8110b51c:	dec00104 	addi	sp,sp,4
8110b520:	f800283a 	ret

8110b524 <v_spi_start>:

#ifdef DEBUG_ON
char cDebugBuffer[256];
#endif

void v_spi_start(void){
8110b524:	defffe04 	addi	sp,sp,-8
8110b528:	de00012e 	bgeu	sp,et,8110b530 <v_spi_start+0xc>
8110b52c:	003b68fa 	trap	3
8110b530:	dfc00115 	stw	ra,4(sp)
8110b534:	df000015 	stw	fp,0(sp)
8110b538:	d839883a 	mov	fp,sp
    //Pull CS_n Low to start communication
    SPI_SCK(0);
8110b53c:	0007883a 	mov	r3,zero
8110b540:	00a00034 	movhi	r2,32768
8110b544:	10823004 	addi	r2,r2,2240
8110b548:	10c00035 	stwio	r3,0(r2)
    SPI_CS_N(0);
8110b54c:	0007883a 	mov	r3,zero
8110b550:	00a00034 	movhi	r2,32768
8110b554:	10822c04 	addi	r2,r2,2224
8110b558:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b55c:	01002584 	movi	r4,150
8110b560:	1133cf00 	call	81133cf0 <usleep>
}
8110b564:	0001883a 	nop
8110b568:	e037883a 	mov	sp,fp
8110b56c:	dfc00117 	ldw	ra,4(sp)
8110b570:	df000017 	ldw	fp,0(sp)
8110b574:	dec00204 	addi	sp,sp,8
8110b578:	f800283a 	ret

8110b57c <v_spi_send_byte>:

void v_spi_send_byte(alt_u8 uc_data){
8110b57c:	defffc04 	addi	sp,sp,-16
8110b580:	de00012e 	bgeu	sp,et,8110b588 <v_spi_send_byte+0xc>
8110b584:	003b68fa 	trap	3
8110b588:	dfc00315 	stw	ra,12(sp)
8110b58c:	df000215 	stw	fp,8(sp)
8110b590:	df000204 	addi	fp,sp,8
8110b594:	2005883a 	mov	r2,r4
8110b598:	e0bfff05 	stb	r2,-4(fp)

    alt_u8 i = 0;
8110b59c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_data_mask = 0x80;
8110b5a0:	00bfe004 	movi	r2,-128
8110b5a4:	e0bffe45 	stb	r2,-7(fp)

    for(i=0;i<8;i++)
8110b5a8:	e03ffe05 	stb	zero,-8(fp)
8110b5ac:	00001b06 	br	8110b61c <v_spi_send_byte+0xa0>
    {
        SPI_SDI((uc_data & uc_data_mask)?1:0);
8110b5b0:	e0ffff03 	ldbu	r3,-4(fp)
8110b5b4:	e0bffe43 	ldbu	r2,-7(fp)
8110b5b8:	1884703a 	and	r2,r3,r2
8110b5bc:	10803fcc 	andi	r2,r2,255
8110b5c0:	1004c03a 	cmpne	r2,r2,zero
8110b5c4:	10c03fcc 	andi	r3,r2,255
8110b5c8:	00a00034 	movhi	r2,32768
8110b5cc:	10823404 	addi	r2,r2,2256
8110b5d0:	10c00035 	stwio	r3,0(r2)
        uc_data_mask >>= 1;
8110b5d4:	e0bffe43 	ldbu	r2,-7(fp)
8110b5d8:	1004d07a 	srli	r2,r2,1
8110b5dc:	e0bffe45 	stb	r2,-7(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b5e0:	00c00044 	movi	r3,1
8110b5e4:	00a00034 	movhi	r2,32768
8110b5e8:	10823004 	addi	r2,r2,2240
8110b5ec:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b5f0:	01002584 	movi	r4,150
8110b5f4:	1133cf00 	call	81133cf0 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b5f8:	0007883a 	mov	r3,zero
8110b5fc:	00a00034 	movhi	r2,32768
8110b600:	10823004 	addi	r2,r2,2240
8110b604:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b608:	01002584 	movi	r4,150
8110b60c:	1133cf00 	call	81133cf0 <usleep>
void v_spi_send_byte(alt_u8 uc_data){

    alt_u8 i = 0;
    alt_u8 uc_data_mask = 0x80;

    for(i=0;i<8;i++)
8110b610:	e0bffe03 	ldbu	r2,-8(fp)
8110b614:	10800044 	addi	r2,r2,1
8110b618:	e0bffe05 	stb	r2,-8(fp)
8110b61c:	e0bffe03 	ldbu	r2,-8(fp)
8110b620:	10800230 	cmpltui	r2,r2,8
8110b624:	103fe21e 	bne	r2,zero,8110b5b0 <__reset+0xfb0eb5b0>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

}
8110b628:	0001883a 	nop
8110b62c:	e037883a 	mov	sp,fp
8110b630:	dfc00117 	ldw	ra,4(sp)
8110b634:	df000017 	ldw	fp,0(sp)
8110b638:	dec00204 	addi	sp,sp,8
8110b63c:	f800283a 	ret

8110b640 <uc_spi_get_byte>:

alt_u8 uc_spi_get_byte(void){
8110b640:	defffd04 	addi	sp,sp,-12
8110b644:	de00012e 	bgeu	sp,et,8110b64c <uc_spi_get_byte+0xc>
8110b648:	003b68fa 	trap	3
8110b64c:	dfc00215 	stw	ra,8(sp)
8110b650:	df000115 	stw	fp,4(sp)
8110b654:	df000104 	addi	fp,sp,4

    alt_u8 i = 0;
8110b658:	e03fff05 	stb	zero,-4(fp)
    alt_u8 uc_data = 0;
8110b65c:	e03fff45 	stb	zero,-3(fp)

    for(i=0;i<8;i++) // read byte
8110b660:	e03fff05 	stb	zero,-4(fp)
8110b664:	00001a06 	br	8110b6d0 <uc_spi_get_byte+0x90>
    {
        uc_data <<= 1;
8110b668:	e0bfff43 	ldbu	r2,-3(fp)
8110b66c:	1085883a 	add	r2,r2,r2
8110b670:	e0bfff45 	stb	r2,-3(fp)
        uc_data |= SPI_SDO;
8110b674:	00a00034 	movhi	r2,32768
8110b678:	10823804 	addi	r2,r2,2272
8110b67c:	10800037 	ldwio	r2,0(r2)
8110b680:	1080004c 	andi	r2,r2,1
8110b684:	1007883a 	mov	r3,r2
8110b688:	e0bfff43 	ldbu	r2,-3(fp)
8110b68c:	1884b03a 	or	r2,r3,r2
8110b690:	e0bfff45 	stb	r2,-3(fp)

        SPI_SCK(1);//sck=1; // clock high
8110b694:	00c00044 	movi	r3,1
8110b698:	00a00034 	movhi	r2,32768
8110b69c:	10823004 	addi	r2,r2,2240
8110b6a0:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b6a4:	01002584 	movi	r4,150
8110b6a8:	1133cf00 	call	81133cf0 <usleep>
        SPI_SCK(0);//sck=0; // clock low
8110b6ac:	0007883a 	mov	r3,zero
8110b6b0:	00a00034 	movhi	r2,32768
8110b6b4:	10823004 	addi	r2,r2,2240
8110b6b8:	10c00035 	stwio	r3,0(r2)
        SPI_DELAY;
8110b6bc:	01002584 	movi	r4,150
8110b6c0:	1133cf00 	call	81133cf0 <usleep>
alt_u8 uc_spi_get_byte(void){

    alt_u8 i = 0;
    alt_u8 uc_data = 0;

    for(i=0;i<8;i++) // read byte
8110b6c4:	e0bfff03 	ldbu	r2,-4(fp)
8110b6c8:	10800044 	addi	r2,r2,1
8110b6cc:	e0bfff05 	stb	r2,-4(fp)
8110b6d0:	e0bfff03 	ldbu	r2,-4(fp)
8110b6d4:	10800230 	cmpltui	r2,r2,8
8110b6d8:	103fe31e 	bne	r2,zero,8110b668 <__reset+0xfb0eb668>
        SPI_DELAY;
        SPI_SCK(0);//sck=0; // clock low
        SPI_DELAY;
    }

    return uc_data;
8110b6dc:	e0bfff43 	ldbu	r2,-3(fp)
}
8110b6e0:	e037883a 	mov	sp,fp
8110b6e4:	dfc00117 	ldw	ra,4(sp)
8110b6e8:	df000017 	ldw	fp,0(sp)
8110b6ec:	dec00204 	addi	sp,sp,8
8110b6f0:	f800283a 	ret

8110b6f4 <v_spi_end>:

void v_spi_end(void){
8110b6f4:	defffe04 	addi	sp,sp,-8
8110b6f8:	de00012e 	bgeu	sp,et,8110b700 <v_spi_end+0xc>
8110b6fc:	003b68fa 	trap	3
8110b700:	dfc00115 	stw	ra,4(sp)
8110b704:	df000015 	stw	fp,0(sp)
8110b708:	d839883a 	mov	fp,sp
    //Set CS_n to end communication
    SPI_SCK(0);
8110b70c:	0007883a 	mov	r3,zero
8110b710:	00a00034 	movhi	r2,32768
8110b714:	10823004 	addi	r2,r2,2240
8110b718:	10c00035 	stwio	r3,0(r2)
    SPI_DELAY;
8110b71c:	01002584 	movi	r4,150
8110b720:	1133cf00 	call	81133cf0 <usleep>
    SPI_CS_N(1);
8110b724:	00c00044 	movi	r3,1
8110b728:	00a00034 	movhi	r2,32768
8110b72c:	10822c04 	addi	r2,r2,2224
8110b730:	10c00035 	stwio	r3,0(r2)
}
8110b734:	0001883a 	nop
8110b738:	e037883a 	mov	sp,fp
8110b73c:	dfc00117 	ldw	ra,4(sp)
8110b740:	df000017 	ldw	fp,0(sp)
8110b744:	dec00204 	addi	sp,sp,8
8110b748:	f800283a 	ret

8110b74c <RTCC_SPI_R_MAC>:

// Note. SCK: typical 19.2KHZ (53 ms)
bool RTCC_SPI_R_MAC(alt_u8 uc_EUI48_array[6])
{
8110b74c:	defff604 	addi	sp,sp,-40
8110b750:	de00012e 	bgeu	sp,et,8110b758 <RTCC_SPI_R_MAC+0xc>
8110b754:	003b68fa 	trap	3
8110b758:	dfc00915 	stw	ra,36(sp)
8110b75c:	df000815 	stw	fp,32(sp)
8110b760:	df000804 	addi	fp,sp,32
8110b764:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
8110b768:	e03ffc15 	stw	zero,-16(fp)

    alt_u8 uc_EUI48_B0 = 0;
8110b76c:	e03ffd05 	stb	zero,-12(fp)
    alt_u8 uc_EUI48_B1 = 0;
8110b770:	e03ffd45 	stb	zero,-11(fp)
    alt_u8 uc_EUI48_B2 = 0;
8110b774:	e03ffd85 	stb	zero,-10(fp)
    alt_u8 uc_EUI48_B3 = 0;
8110b778:	e03ffdc5 	stb	zero,-9(fp)
    alt_u8 uc_EUI48_B4 = 0;
8110b77c:	e03ffe05 	stb	zero,-8(fp)
    alt_u8 uc_EUI48_B5 = 0;
8110b780:	e03ffe45 	stb	zero,-7(fp)

//    alt_u8 uc_sdi_mask;

    const alt_u8 uc_EUI48_B0_addr = 0x02;
8110b784:	00800084 	movi	r2,2
8110b788:	e0bffe85 	stb	r2,-6(fp)
//    const alt_u8 uc_EUI48_B2_addr = 0x04;
//    const alt_u8 uc_EUI48_B3_addr = 0x05;
//    const alt_u8 uc_EUI48_B4_addr = 0x06;
//    const alt_u8 uc_EUI48_B5_addr = 0x07;

    const alt_u8 uc_IDREAD_cmd = 0x33;
8110b78c:	00800cc4 	movi	r2,51
8110b790:	e0bffec5 	stb	r2,-5(fp)

//    int i = 0;
    
    // Start Communication
    v_spi_start();
8110b794:	110b5240 	call	8110b524 <v_spi_start>

    //Send IDREAD (0011 0011)
    v_spi_send_byte(uc_IDREAD_cmd);
8110b798:	e0bffec3 	ldbu	r2,-5(fp)
8110b79c:	1009883a 	mov	r4,r2
8110b7a0:	110b57c0 	call	8110b57c <v_spi_send_byte>

    //Send Address (0x02 - 0x07)
    v_spi_send_byte(uc_EUI48_B0_addr);
8110b7a4:	e0bffe83 	ldbu	r2,-6(fp)
8110b7a8:	1009883a 	mov	r4,r2
8110b7ac:	110b57c0 	call	8110b57c <v_spi_send_byte>

    //Read MAC (EUI-48, 6 bytes)
    uc_EUI48_B0 = uc_spi_get_byte();
8110b7b0:	110b6400 	call	8110b640 <uc_spi_get_byte>
8110b7b4:	e0bffd05 	stb	r2,-12(fp)
    uc_EUI48_B1 = uc_spi_get_byte();
8110b7b8:	110b6400 	call	8110b640 <uc_spi_get_byte>
8110b7bc:	e0bffd45 	stb	r2,-11(fp)
    uc_EUI48_B2 = uc_spi_get_byte();
8110b7c0:	110b6400 	call	8110b640 <uc_spi_get_byte>
8110b7c4:	e0bffd85 	stb	r2,-10(fp)
    uc_EUI48_B3 = uc_spi_get_byte();
8110b7c8:	110b6400 	call	8110b640 <uc_spi_get_byte>
8110b7cc:	e0bffdc5 	stb	r2,-9(fp)
    uc_EUI48_B4 = uc_spi_get_byte();
8110b7d0:	110b6400 	call	8110b640 <uc_spi_get_byte>
8110b7d4:	e0bffe05 	stb	r2,-8(fp)
    uc_EUI48_B5 = uc_spi_get_byte();
8110b7d8:	110b6400 	call	8110b640 <uc_spi_get_byte>
8110b7dc:	e0bffe45 	stb	r2,-7(fp)

    // End communication
    v_spi_end();
8110b7e0:	110b6f40 	call	8110b6f4 <v_spi_end>

    bSuccess = TRUE;
8110b7e4:	00800044 	movi	r2,1
8110b7e8:	e0bffc15 	stw	r2,-16(fp)
    
    uc_EUI48_array[0] = uc_EUI48_B0;
8110b7ec:	e0bfff17 	ldw	r2,-4(fp)
8110b7f0:	e0fffd03 	ldbu	r3,-12(fp)
8110b7f4:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[1] = uc_EUI48_B1;
8110b7f8:	e0bfff17 	ldw	r2,-4(fp)
8110b7fc:	10800044 	addi	r2,r2,1
8110b800:	e0fffd43 	ldbu	r3,-11(fp)
8110b804:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[2] = uc_EUI48_B2;
8110b808:	e0bfff17 	ldw	r2,-4(fp)
8110b80c:	10800084 	addi	r2,r2,2
8110b810:	e0fffd83 	ldbu	r3,-10(fp)
8110b814:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[3] = uc_EUI48_B3;
8110b818:	e0bfff17 	ldw	r2,-4(fp)
8110b81c:	108000c4 	addi	r2,r2,3
8110b820:	e0fffdc3 	ldbu	r3,-9(fp)
8110b824:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[4] = uc_EUI48_B4;
8110b828:	e0bfff17 	ldw	r2,-4(fp)
8110b82c:	10800104 	addi	r2,r2,4
8110b830:	e0fffe03 	ldbu	r3,-8(fp)
8110b834:	10c00005 	stb	r3,0(r2)
    uc_EUI48_array[5] = uc_EUI48_B5;
8110b838:	e0bfff17 	ldw	r2,-4(fp)
8110b83c:	10800144 	addi	r2,r2,5
8110b840:	e0fffe43 	ldbu	r3,-7(fp)
8110b844:	10c00005 	stb	r3,0(r2)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "RTCC EUI-48 MAC Address: 0x%02x:%02x:%02x:%02x:%02x:%02x \n", uc_EUI48_B0, uc_EUI48_B1, uc_EUI48_B2, uc_EUI48_B3, uc_EUI48_B4, uc_EUI48_B5);
8110b848:	e1bffd03 	ldbu	r6,-12(fp)
8110b84c:	e1fffd43 	ldbu	r7,-11(fp)
8110b850:	e0bffd83 	ldbu	r2,-10(fp)
8110b854:	e0fffdc3 	ldbu	r3,-9(fp)
8110b858:	e13ffe03 	ldbu	r4,-8(fp)
8110b85c:	e17ffe43 	ldbu	r5,-7(fp)
8110b860:	d9400315 	stw	r5,12(sp)
8110b864:	d9000215 	stw	r4,8(sp)
8110b868:	d8c00115 	stw	r3,4(sp)
8110b86c:	d8800015 	stw	r2,0(sp)
8110b870:	01604574 	movhi	r5,33045
8110b874:	29616104 	addi	r5,r5,-31356
8110b878:	01204574 	movhi	r4,33045
8110b87c:	213b8b04 	addi	r4,r4,-4564
8110b880:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
8110b884:	d0a05e17 	ldw	r2,-32392(gp)
8110b888:	01604574 	movhi	r5,33045
8110b88c:	297b8b04 	addi	r5,r5,-4564
8110b890:	1009883a 	mov	r4,r2
8110b894:	111ca180 	call	8111ca18 <fprintf>
#endif

    return bSuccess;
8110b898:	e0bffc17 	ldw	r2,-16(fp)
}
8110b89c:	e037883a 	mov	sp,fp
8110b8a0:	dfc00117 	ldw	ra,4(sp)
8110b8a4:	df000017 	ldw	fp,0(sp)
8110b8a8:	dec00204 	addi	sp,sp,8
8110b8ac:	f800283a 	ret

8110b8b0 <bSSDisplayConfig>:
 *
 * @retval TRUE : Sucesso
 * @retval FALSE : Configurao no especificada
 *
 */
bool bSSDisplayConfig(alt_u8 SsdpConfig){
8110b8b0:	defffd04 	addi	sp,sp,-12
8110b8b4:	de00012e 	bgeu	sp,et,8110b8bc <bSSDisplayConfig+0xc>
8110b8b8:	003b68fa 	trap	3
8110b8bc:	df000215 	stw	fp,8(sp)
8110b8c0:	df000204 	addi	fp,sp,8
8110b8c4:	2005883a 	mov	r2,r4
8110b8c8:	e0bfff05 	stb	r2,-4(fp)

    switch(SsdpConfig){
8110b8cc:	e0bfff03 	ldbu	r2,-4(fp)
8110b8d0:	10c00168 	cmpgeui	r3,r2,5
8110b8d4:	18001c1e 	bne	r3,zero,8110b948 <bSSDisplayConfig+0x98>
8110b8d8:	100690ba 	slli	r3,r2,2
8110b8dc:	00a04474 	movhi	r2,33041
8110b8e0:	10ae3c04 	addi	r2,r2,-18192
8110b8e4:	1885883a 	add	r2,r3,r2
8110b8e8:	10800017 	ldw	r2,0(r2)
8110b8ec:	1000683a 	jmp	r2
8110b8f0:	8110b904 	addi	r4,r16,17124
8110b8f4:	8110b910 	cmplti	r4,r16,17124
8110b8f8:	8110b91c 	xori	r4,r16,17124
8110b8fc:	8110b930 	cmpltui	r4,r16,17124
8110b900:	8110b940 	call	88110b94 <__reset+0x20f0b94>
	    case SSDP_NORMAL_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_UNLOCK_MASK);
8110b904:	00800cc4 	movi	r2,51
8110b908:	d0a04f45 	stb	r2,-32451(gp)
	    break;
8110b90c:	00001006 	br	8110b950 <bSSDisplayConfig+0xa0>
		
	    case SSDP_TEST_MODE:
	        SspdConfigControl = (SSDP_ON_MASK | SSDP_TEST_MASK);
8110b910:	00801544 	movi	r2,85
8110b914:	d0a04f45 	stb	r2,-32451(gp)
	    break;
8110b918:	00000d06 	br	8110b950 <bSSDisplayConfig+0xa0>
		
	    case SSDP_LOCK:
	        SspdConfigControl &= (~SSDP_UNLOCK_MASK);
8110b91c:	d0e04f43 	ldbu	r3,-32451(gp)
8110b920:	00bff744 	movi	r2,-35
8110b924:	1884703a 	and	r2,r3,r2
8110b928:	d0a04f45 	stb	r2,-32451(gp)
	    break;
8110b92c:	00000806 	br	8110b950 <bSSDisplayConfig+0xa0>
		
	    case SSDP_UNLOCK:
	        SspdConfigControl |= SSDP_UNLOCK_MASK;
8110b930:	d0a04f43 	ldbu	r2,-32451(gp)
8110b934:	10800894 	ori	r2,r2,34
8110b938:	d0a04f45 	stb	r2,-32451(gp)
	    break;
8110b93c:	00000406 	br	8110b950 <bSSDisplayConfig+0xa0>
		
	    case SSDP_OFF:
	        SspdConfigControl = SSDP_OFF_MASK;
8110b940:	d0204f45 	stb	zero,-32451(gp)
	    break;
8110b944:	00000206 	br	8110b950 <bSSDisplayConfig+0xa0>
		
		default:
		    return FALSE;
8110b948:	0005883a 	mov	r2,zero
8110b94c:	00000806 	br	8110b970 <bSSDisplayConfig+0xc0>
	}

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b950:	00a00034 	movhi	r2,32768
8110b954:	10828404 	addi	r2,r2,2576
8110b958:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_CONTROL_REG_OFFSET) = (alt_u32) SspdConfigControl;
8110b95c:	d0a04f43 	ldbu	r2,-32451(gp)
8110b960:	10c03fcc 	andi	r3,r2,255
8110b964:	e0bffe17 	ldw	r2,-8(fp)
8110b968:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b96c:	00800044 	movi	r2,1
}
8110b970:	e037883a 	mov	sp,fp
8110b974:	df000017 	ldw	fp,0(sp)
8110b978:	dec00104 	addi	sp,sp,4
8110b97c:	f800283a 	ret

8110b980 <bSSDisplayUpdate>:
 * @param [in] SsdpData Dado a ser colocado no display de sete segmentos, do tipo unsigned char (alt_u8)
 *
 * @retval TRUE : Sucesso
 *
 */
bool bSSDisplayUpdate(alt_u8 SsdpData){
8110b980:	defffd04 	addi	sp,sp,-12
8110b984:	de00012e 	bgeu	sp,et,8110b98c <bSSDisplayUpdate+0xc>
8110b988:	003b68fa 	trap	3
8110b98c:	df000215 	stw	fp,8(sp)
8110b990:	df000204 	addi	fp,sp,8
8110b994:	2005883a 	mov	r2,r4
8110b998:	e0bfff05 	stb	r2,-4(fp)

	alt_u32 *pSsdpAddr = (alt_u32 *)SSDP_BASE;
8110b99c:	00a00034 	movhi	r2,32768
8110b9a0:	10828404 	addi	r2,r2,2576
8110b9a4:	e0bffe15 	stw	r2,-8(fp)
	*(pSsdpAddr + SSDP_DATA_REG_OFFSET) = (alt_u32) SsdpData;
8110b9a8:	e0bffe17 	ldw	r2,-8(fp)
8110b9ac:	10800104 	addi	r2,r2,4
8110b9b0:	e0ffff03 	ldbu	r3,-4(fp)
8110b9b4:	10c00015 	stw	r3,0(r2)
	
	return TRUE;
8110b9b8:	00800044 	movi	r2,1
}
8110b9bc:	e037883a 	mov	sp,fp
8110b9c0:	df000017 	ldw	fp,0(sp)
8110b9c4:	dec00104 	addi	sp,sp,4
8110b9c8:	f800283a 	ret

8110b9cc <vSyncHandleIrq>:
 *
 * @param [in] void* context
 *
 * @retval void
 */
void vSyncHandleIrq(void* pvContext) {
8110b9cc:	defff904 	addi	sp,sp,-28
8110b9d0:	de00012e 	bgeu	sp,et,8110b9d8 <vSyncHandleIrq+0xc>
8110b9d4:	003b68fa 	trap	3
8110b9d8:	dfc00615 	stw	ra,24(sp)
8110b9dc:	df000515 	stw	fp,20(sp)
8110b9e0:	df000504 	addi	fp,sp,20
8110b9e4:	e13fff15 	stw	r4,-4(fp)
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	volatile int* pviHoldContext = (volatile int*) pvContext;
8110b9e8:	e0bfff17 	ldw	r2,-4(fp)
8110b9ec:	e0bffc15 	stw	r2,-16(fp)


	uiCmdtoSend.ulWord = 0;
8110b9f0:	e03ffe15 	stw	zero,-8(fp)
	/* MasterSync? */
	ucSyncL = (vucN % 4);
8110b9f4:	d0a05103 	ldbu	r2,-32444(gp)
8110b9f8:	108000cc 	andi	r2,r2,3
8110b9fc:	e0bffd05 	stb	r2,-12(fp)
	if ( ucSyncL == 0 ) {
8110ba00:	e0bffd03 	ldbu	r2,-12(fp)
8110ba04:	10000e1e 	bne	r2,zero,8110ba40 <vSyncHandleIrq+0x74>

		uiCmdtoSend.ucByte[3] = M_MEB_ADDR;
8110ba08:	00800044 	movi	r2,1
8110ba0c:	e0bffec5 	stb	r2,-5(fp)
		uiCmdtoSend.ucByte[2] = M_MASTER_SYNC;
8110ba10:	00bff804 	movi	r2,-32
8110ba14:	e0bffe85 	stb	r2,-6(fp)

		/* Send Priority message to the Meb Task to indicate the Master Sync */
		error_codel = OSQPostFront(xMebQ, (void *)uiCmdtoSend.ulWord);
8110ba18:	d0a06517 	ldw	r2,-32364(gp)
8110ba1c:	e0fffe17 	ldw	r3,-8(fp)
8110ba20:	180b883a 	mov	r5,r3
8110ba24:	1009883a 	mov	r4,r2
8110ba28:	113a1740 	call	8113a174 <OSQPostFront>
8110ba2c:	e0bffd45 	stb	r2,-11(fp)
		if ( error_codel != OS_ERR_NONE ) {
8110ba30:	e0bffd43 	ldbu	r2,-11(fp)
8110ba34:	10000426 	beq	r2,zero,8110ba48 <vSyncHandleIrq+0x7c>
			vFailSendMsgMasterSyncMeb( );
8110ba38:	11197480 	call	81119748 <vFailSendMsgMasterSyncMeb>
8110ba3c:	00000206 	br	8110ba48 <vSyncHandleIrq+0x7c>
		}

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;
8110ba40:	00bff844 	movi	r2,-31
8110ba44:	e0bffe85 	stb	r2,-6(fp)


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110ba48:	e03ffb05 	stb	zero,-20(fp)
8110ba4c:	00001f06 	br	8110bacc <vSyncHandleIrq+0x100>

		if ( xSimMeb.xFeeControl.xNfee[ucIL].xControl.bWatingSync == TRUE ) {
8110ba50:	e0fffb03 	ldbu	r3,-20(fp)
8110ba54:	00a04574 	movhi	r2,33045
8110ba58:	10921104 	addi	r2,r2,18500
8110ba5c:	18c09524 	muli	r3,r3,596
8110ba60:	10c5883a 	add	r2,r2,r3
8110ba64:	10803a04 	addi	r2,r2,232
8110ba68:	10800017 	ldw	r2,0(r2)
8110ba6c:	10800058 	cmpnei	r2,r2,1
8110ba70:	1000131e 	bne	r2,zero,8110bac0 <vSyncHandleIrq+0xf4>
			uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
8110ba74:	e0bffb03 	ldbu	r2,-20(fp)
8110ba78:	10800444 	addi	r2,r2,17
8110ba7c:	e0bffec5 	stb	r2,-5(fp)
			error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
8110ba80:	e0bffb03 	ldbu	r2,-20(fp)
8110ba84:	1085883a 	add	r2,r2,r2
8110ba88:	1087883a 	add	r3,r2,r2
8110ba8c:	d0a05804 	addi	r2,gp,-32416
8110ba90:	1885883a 	add	r2,r3,r2
8110ba94:	10800017 	ldw	r2,0(r2)
8110ba98:	e0fffe17 	ldw	r3,-8(fp)
8110ba9c:	180b883a 	mov	r5,r3
8110baa0:	1009883a 	mov	r4,r2
8110baa4:	113a0040 	call	8113a004 <OSQPost>
8110baa8:	e0bffd45 	stb	r2,-11(fp)
			if ( error_codel != OS_ERR_NONE ) {
8110baac:	e0bffd43 	ldbu	r2,-11(fp)
8110bab0:	10000326 	beq	r2,zero,8110bac0 <vSyncHandleIrq+0xf4>
				vFailSendMsgSync( ucIL );
8110bab4:	e0bffb03 	ldbu	r2,-20(fp)
8110bab8:	1009883a 	mov	r4,r2
8110babc:	11196a00 	call	811196a0 <vFailSendMsgSync>

	} else
		uiCmdtoSend.ucByte[2] = M_SYNC;


	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
8110bac0:	e0bffb03 	ldbu	r2,-20(fp)
8110bac4:	10800044 	addi	r2,r2,1
8110bac8:	e0bffb05 	stb	r2,-20(fp)
8110bacc:	e0bffb03 	ldbu	r2,-20(fp)
8110bad0:	103fdf26 	beq	r2,zero,8110ba50 <__reset+0xfb0eba50>
				vFailSendMsgSync( ucIL );
			}
		}
	}

	vucN += 1;
8110bad4:	d0a05103 	ldbu	r2,-32444(gp)
8110bad8:	10800044 	addi	r2,r2,1
8110badc:	d0a05105 	stb	r2,-32444(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"Sync %hu \n", ucSyncL);
8110bae0:	d0a05e17 	ldw	r2,-32392(gp)
8110bae4:	e0fffd03 	ldbu	r3,-12(fp)
8110bae8:	180d883a 	mov	r6,r3
8110baec:	01604574 	movhi	r5,33045
8110baf0:	29617004 	addi	r5,r5,-31296
8110baf4:	1009883a 	mov	r4,r2
8110baf8:	111ca180 	call	8111ca18 <fprintf>
	#endif

	vSyncIrqFlagClrSync();
8110bafc:	110bb900 	call	8110bb90 <vSyncIrqFlagClrSync>
}
8110bb00:	0001883a 	nop
8110bb04:	e037883a 	mov	sp,fp
8110bb08:	dfc00117 	ldw	ra,4(sp)
8110bb0c:	df000017 	ldw	fp,0(sp)
8110bb10:	dec00204 	addi	sp,sp,8
8110bb14:	f800283a 	ret

8110bb18 <vSyncClearCounter>:

void vSyncClearCounter(void) {
8110bb18:	deffff04 	addi	sp,sp,-4
8110bb1c:	de00012e 	bgeu	sp,et,8110bb24 <vSyncClearCounter+0xc>
8110bb20:	003b68fa 	trap	3
8110bb24:	df000015 	stw	fp,0(sp)
8110bb28:	d839883a 	mov	fp,sp
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	vucN = 0;
8110bb2c:	d0205105 	stb	zero,-32444(gp)
}
8110bb30:	0001883a 	nop
8110bb34:	e037883a 	mov	sp,fp
8110bb38:	df000017 	ldw	fp,0(sp)
8110bb3c:	dec00104 	addi	sp,sp,4
8110bb40:	f800283a 	ret

8110bb44 <vSyncInitIrq>:
 *
 * @param [in] void
 *
 * @retval void
 */
void vSyncInitIrq(void) {
8110bb44:	defffd04 	addi	sp,sp,-12
8110bb48:	de00012e 	bgeu	sp,et,8110bb50 <vSyncInitIrq+0xc>
8110bb4c:	003b68fa 	trap	3
8110bb50:	dfc00215 	stw	ra,8(sp)
8110bb54:	df000115 	stw	fp,4(sp)
8110bb58:	df000104 	addi	fp,sp,4
	// Recast the viHoldContext pointer to match the alt_irq_register() function
	// prototype.
	void* hold_context_ptr = (void*) &viHoldContext;
8110bb5c:	d0a05004 	addi	r2,gp,-32448
8110bb60:	e0bfff15 	stw	r2,-4(fp)
	// Register the interrupt handler
	alt_irq_register(SYNC_IRQ, hold_context_ptr, vSyncHandleIrq);
8110bb64:	01a04474 	movhi	r6,33041
8110bb68:	31ae7304 	addi	r6,r6,-17972
8110bb6c:	e17fff17 	ldw	r5,-4(fp)
8110bb70:	01000284 	movi	r4,10
8110bb74:	11326200 	call	81132620 <alt_irq_register>
}
8110bb78:	0001883a 	nop
8110bb7c:	e037883a 	mov	sp,fp
8110bb80:	dfc00117 	ldw	ra,4(sp)
8110bb84:	df000017 	ldw	fp,0(sp)
8110bb88:	dec00204 	addi	sp,sp,8
8110bb8c:	f800283a 	ret

8110bb90 <vSyncIrqFlagClrSync>:

void vSyncIrqFlagClrSync(void) {
8110bb90:	defffe04 	addi	sp,sp,-8
8110bb94:	de00012e 	bgeu	sp,et,8110bb9c <vSyncIrqFlagClrSync+0xc>
8110bb98:	003b68fa 	trap	3
8110bb9c:	dfc00115 	stw	ra,4(sp)
8110bba0:	df000015 	stw	fp,0(sp)
8110bba4:	d839883a 	mov	fp,sp
	bSyncWriteReg(SYNC_IRQ_FG_CLR_REG_OFFSET, (alt_u32) SYNC_IRQ_FG_CLR_MSK);
8110bba8:	01400044 	movi	r5,1
8110bbac:	010002c4 	movi	r4,11
8110bbb0:	110c9700 	call	8110c970 <bSyncWriteReg>
}
8110bbb4:	0001883a 	nop
8110bbb8:	e037883a 	mov	sp,fp
8110bbbc:	dfc00117 	ldw	ra,4(sp)
8110bbc0:	df000017 	ldw	fp,0(sp)
8110bbc4:	dec00204 	addi	sp,sp,8
8110bbc8:	f800283a 	ret

8110bbcc <bSyncIrqFlagSync>:

bool bSyncIrqFlagSync(void) {
8110bbcc:	defffd04 	addi	sp,sp,-12
8110bbd0:	de00012e 	bgeu	sp,et,8110bbd8 <bSyncIrqFlagSync+0xc>
8110bbd4:	003b68fa 	trap	3
8110bbd8:	dfc00215 	stw	ra,8(sp)
8110bbdc:	df000115 	stw	fp,4(sp)
8110bbe0:	df000104 	addi	fp,sp,4
	bool bFlag;

	if (uliSyncReadReg(SYNC_IRQ_FG_REG_OFFSET) & SYNC_IRQ_FG_MSK) {
8110bbe4:	01000304 	movi	r4,12
8110bbe8:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bbec:	1080004c 	andi	r2,r2,1
8110bbf0:	10000326 	beq	r2,zero,8110bc00 <bSyncIrqFlagSync+0x34>
		bFlag = TRUE;
8110bbf4:	00800044 	movi	r2,1
8110bbf8:	e0bfff15 	stw	r2,-4(fp)
8110bbfc:	00000106 	br	8110bc04 <bSyncIrqFlagSync+0x38>
	} else {
		bFlag = FALSE;
8110bc00:	e03fff15 	stw	zero,-4(fp)
	}

	return bFlag;
8110bc04:	e0bfff17 	ldw	r2,-4(fp)
}
8110bc08:	e037883a 	mov	sp,fp
8110bc0c:	dfc00117 	ldw	ra,4(sp)
8110bc10:	df000017 	ldw	fp,0(sp)
8110bc14:	dec00204 	addi	sp,sp,8
8110bc18:	f800283a 	ret

8110bc1c <bSyncStatusExtnIrq>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncStatusExtnIrq(void) {
8110bc1c:	defffc04 	addi	sp,sp,-16
8110bc20:	de00012e 	bgeu	sp,et,8110bc28 <bSyncStatusExtnIrq+0xc>
8110bc24:	003b68fa 	trap	3
8110bc28:	dfc00315 	stw	ra,12(sp)
8110bc2c:	df000215 	stw	fp,8(sp)
8110bc30:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bc34:	0009883a 	mov	r4,zero
8110bc38:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bc3c:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_STAT_EXTN_IRQ_MSK) {
8110bc40:	e0bfff17 	ldw	r2,-4(fp)
8110bc44:	1000030e 	bge	r2,zero,8110bc54 <bSyncStatusExtnIrq+0x38>
		bResult = TRUE;
8110bc48:	00800044 	movi	r2,1
8110bc4c:	e0bffe15 	stw	r2,-8(fp)
8110bc50:	00000106 	br	8110bc58 <bSyncStatusExtnIrq+0x3c>
	} else {
		bResult = FALSE;
8110bc54:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110bc58:	e0bffe17 	ldw	r2,-8(fp)
}
8110bc5c:	e037883a 	mov	sp,fp
8110bc60:	dfc00117 	ldw	ra,4(sp)
8110bc64:	df000017 	ldw	fp,0(sp)
8110bc68:	dec00204 	addi	sp,sp,8
8110bc6c:	f800283a 	ret

8110bc70 <ucSyncStatusState>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusState(void) {
8110bc70:	defffc04 	addi	sp,sp,-16
8110bc74:	de00012e 	bgeu	sp,et,8110bc7c <ucSyncStatusState+0xc>
8110bc78:	003b68fa 	trap	3
8110bc7c:	dfc00315 	stw	ra,12(sp)
8110bc80:	df000215 	stw	fp,8(sp)
8110bc84:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bc88:	0009883a 	mov	r4,zero
8110bc8c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bc90:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_STATE_MSK) >> 16);
8110bc94:	e0bffe17 	ldw	r2,-8(fp)
8110bc98:	10803fec 	andhi	r2,r2,255
8110bc9c:	1004d43a 	srli	r2,r2,16
8110bca0:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bca4:	e0bfff03 	ldbu	r2,-4(fp)
}
8110bca8:	e037883a 	mov	sp,fp
8110bcac:	dfc00117 	ldw	ra,4(sp)
8110bcb0:	df000017 	ldw	fp,0(sp)
8110bcb4:	dec00204 	addi	sp,sp,8
8110bcb8:	f800283a 	ret

8110bcbc <ucSyncStatusErrorCode>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusErrorCode(void) {
8110bcbc:	defffc04 	addi	sp,sp,-16
8110bcc0:	de00012e 	bgeu	sp,et,8110bcc8 <ucSyncStatusErrorCode+0xc>
8110bcc4:	003b68fa 	trap	3
8110bcc8:	dfc00315 	stw	ra,12(sp)
8110bccc:	df000215 	stw	fp,8(sp)
8110bcd0:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bcd4:	0009883a 	mov	r4,zero
8110bcd8:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bcdc:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_ERROR_CODE_MSK) >> 8);
8110bce0:	e0bffe17 	ldw	r2,-8(fp)
8110bce4:	10bfc00c 	andi	r2,r2,65280
8110bce8:	1004d23a 	srli	r2,r2,8
8110bcec:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bcf0:	e0bfff03 	ldbu	r2,-4(fp)
}
8110bcf4:	e037883a 	mov	sp,fp
8110bcf8:	dfc00117 	ldw	ra,4(sp)
8110bcfc:	df000017 	ldw	fp,0(sp)
8110bd00:	dec00204 	addi	sp,sp,8
8110bd04:	f800283a 	ret

8110bd08 <ucSyncStatusCycleNumber>:
 *
 * @param [in] void
 *
 * @retval alt_u8 result
 */
alt_u8 ucSyncStatusCycleNumber(void) {
8110bd08:	defffc04 	addi	sp,sp,-16
8110bd0c:	de00012e 	bgeu	sp,et,8110bd14 <ucSyncStatusCycleNumber+0xc>
8110bd10:	003b68fa 	trap	3
8110bd14:	dfc00315 	stw	ra,12(sp)
8110bd18:	df000215 	stw	fp,8(sp)
8110bd1c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	alt_u8 ucResult;

	uliAux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110bd20:	0009883a 	mov	r4,zero
8110bd24:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bd28:	e0bffe15 	stw	r2,-8(fp)
	ucResult = (alt_u8) ((uliAux & SYNC_STAT_CYCLE_NUMBER_MSK) >> 0);
8110bd2c:	e0bffe17 	ldw	r2,-8(fp)
8110bd30:	e0bfff05 	stb	r2,-4(fp)
	return ucResult;
8110bd34:	e0bfff03 	ldbu	r2,-4(fp)
}
8110bd38:	e037883a 	mov	sp,fp
8110bd3c:	dfc00117 	ldw	ra,4(sp)
8110bd40:	df000017 	ldw	fp,0(sp)
8110bd44:	dec00204 	addi	sp,sp,8
8110bd48:	f800283a 	ret

8110bd4c <bSyncSetMbt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetMbt(alt_u32 uliValue) {
8110bd4c:	defffd04 	addi	sp,sp,-12
8110bd50:	de00012e 	bgeu	sp,et,8110bd58 <bSyncSetMbt+0xc>
8110bd54:	003b68fa 	trap	3
8110bd58:	dfc00215 	stw	ra,8(sp)
8110bd5c:	df000115 	stw	fp,4(sp)
8110bd60:	df000104 	addi	fp,sp,4
8110bd64:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_MBT_REG_OFFSET, uliValue);
8110bd68:	e17fff17 	ldw	r5,-4(fp)
8110bd6c:	01000104 	movi	r4,4
8110bd70:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110bd74:	00800044 	movi	r2,1
}
8110bd78:	e037883a 	mov	sp,fp
8110bd7c:	dfc00117 	ldw	ra,4(sp)
8110bd80:	df000017 	ldw	fp,0(sp)
8110bd84:	dec00204 	addi	sp,sp,8
8110bd88:	f800283a 	ret

8110bd8c <bSyncSetBt>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetBt(alt_u32 uliValue) {
8110bd8c:	defffd04 	addi	sp,sp,-12
8110bd90:	de00012e 	bgeu	sp,et,8110bd98 <bSyncSetBt+0xc>
8110bd94:	003b68fa 	trap	3
8110bd98:	dfc00215 	stw	ra,8(sp)
8110bd9c:	df000115 	stw	fp,4(sp)
8110bda0:	df000104 	addi	fp,sp,4
8110bda4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_BT_REG_OFFSET, uliValue);
8110bda8:	e17fff17 	ldw	r5,-4(fp)
8110bdac:	01000144 	movi	r4,5
8110bdb0:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110bdb4:	00800044 	movi	r2,1
}
8110bdb8:	e037883a 	mov	sp,fp
8110bdbc:	dfc00117 	ldw	ra,4(sp)
8110bdc0:	df000017 	ldw	fp,0(sp)
8110bdc4:	dec00204 	addi	sp,sp,8
8110bdc8:	f800283a 	ret

8110bdcc <bSyncSetPer>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetPer(alt_u32 uliValue) {
8110bdcc:	defffd04 	addi	sp,sp,-12
8110bdd0:	de00012e 	bgeu	sp,et,8110bdd8 <bSyncSetPer+0xc>
8110bdd4:	003b68fa 	trap	3
8110bdd8:	dfc00215 	stw	ra,8(sp)
8110bddc:	df000115 	stw	fp,4(sp)
8110bde0:	df000104 	addi	fp,sp,4
8110bde4:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_PER_REG_OFFSET, uliValue);
8110bde8:	e17fff17 	ldw	r5,-4(fp)
8110bdec:	01000184 	movi	r4,6
8110bdf0:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110bdf4:	00800044 	movi	r2,1
}
8110bdf8:	e037883a 	mov	sp,fp
8110bdfc:	dfc00117 	ldw	ra,4(sp)
8110be00:	df000017 	ldw	fp,0(sp)
8110be04:	dec00204 	addi	sp,sp,8
8110be08:	f800283a 	ret

8110be0c <bSyncSetOst>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncSetOst(alt_u32 uliValue) {
8110be0c:	defffd04 	addi	sp,sp,-12
8110be10:	de00012e 	bgeu	sp,et,8110be18 <bSyncSetOst+0xc>
8110be14:	003b68fa 	trap	3
8110be18:	dfc00215 	stw	ra,8(sp)
8110be1c:	df000115 	stw	fp,4(sp)
8110be20:	df000104 	addi	fp,sp,4
8110be24:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_CONFIG_OST_REG_OFFSET, uliValue);
8110be28:	e17fff17 	ldw	r5,-4(fp)
8110be2c:	010001c4 	movi	r4,7
8110be30:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110be34:	00800044 	movi	r2,1
}
8110be38:	e037883a 	mov	sp,fp
8110be3c:	dfc00117 	ldw	ra,4(sp)
8110be40:	df000017 	ldw	fp,0(sp)
8110be44:	dec00204 	addi	sp,sp,8
8110be48:	f800283a 	ret

8110be4c <bSyncSetPolarity>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncSetPolarity(bool bValue) {
8110be4c:	defffc04 	addi	sp,sp,-16
8110be50:	de00012e 	bgeu	sp,et,8110be58 <bSyncSetPolarity+0xc>
8110be54:	003b68fa 	trap	3
8110be58:	dfc00315 	stw	ra,12(sp)
8110be5c:	df000215 	stw	fp,8(sp)
8110be60:	df000204 	addi	fp,sp,8
8110be64:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110be68:	01000204 	movi	r4,8
8110be6c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110be70:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110be74:	e0bfff17 	ldw	r2,-4(fp)
8110be78:	1000051e 	bne	r2,zero,8110be90 <bSyncSetPolarity+0x44>
		uliAux &= ~SYNC_CONFIG_GEN_POLARITY_MSK;
8110be7c:	e0fffe17 	ldw	r3,-8(fp)
8110be80:	00bfbfc4 	movi	r2,-257
8110be84:	1884703a 	and	r2,r3,r2
8110be88:	e0bffe15 	stw	r2,-8(fp)
8110be8c:	00000306 	br	8110be9c <bSyncSetPolarity+0x50>
	} else {
		uliAux |= SYNC_CONFIG_GEN_POLARITY_MSK;
8110be90:	e0bffe17 	ldw	r2,-8(fp)
8110be94:	10804014 	ori	r2,r2,256
8110be98:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110be9c:	e17ffe17 	ldw	r5,-8(fp)
8110bea0:	01000204 	movi	r4,8
8110bea4:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110bea8:	00800044 	movi	r2,1
}
8110beac:	e037883a 	mov	sp,fp
8110beb0:	dfc00117 	ldw	ra,4(sp)
8110beb4:	df000017 	ldw	fp,0(sp)
8110beb8:	dec00204 	addi	sp,sp,8
8110bebc:	f800283a 	ret

8110bec0 <bSyncSetNCycles>:
 *
 * @param [in] alt_u8 value
 *
 * @retval bool TRUE
 */
bool bSyncSetNCycles(alt_u8 ucValue) {
8110bec0:	defffc04 	addi	sp,sp,-16
8110bec4:	de00012e 	bgeu	sp,et,8110becc <bSyncSetNCycles+0xc>
8110bec8:	003b68fa 	trap	3
8110becc:	dfc00315 	stw	ra,12(sp)
8110bed0:	df000215 	stw	fp,8(sp)
8110bed4:	df000204 	addi	fp,sp,8
8110bed8:	2005883a 	mov	r2,r4
8110bedc:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110bee0:	01000204 	movi	r4,8
8110bee4:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bee8:	e0bffe15 	stw	r2,-8(fp)
	uliAux &= ~SYNC_CONFIG_GEN_N_CYCLES_MSK;
8110beec:	e0fffe17 	ldw	r3,-8(fp)
8110bef0:	00bfc004 	movi	r2,-256
8110bef4:	1884703a 	and	r2,r3,r2
8110bef8:	e0bffe15 	stw	r2,-8(fp)
	uliAux |= (alt_u32) ucValue;
8110befc:	e0bfff03 	ldbu	r2,-4(fp)
8110bf00:	e0fffe17 	ldw	r3,-8(fp)
8110bf04:	1884b03a 	or	r2,r3,r2
8110bf08:	e0bffe15 	stw	r2,-8(fp)

	bSyncWriteReg(SYNC_CONFIG_GENERAL_REG_OFFSET, uliAux);
8110bf0c:	e17ffe17 	ldw	r5,-8(fp)
8110bf10:	01000204 	movi	r4,8
8110bf14:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110bf18:	00800044 	movi	r2,1
}
8110bf1c:	e037883a 	mov	sp,fp
8110bf20:	dfc00117 	ldw	ra,4(sp)
8110bf24:	df000017 	ldw	fp,0(sp)
8110bf28:	dec00204 	addi	sp,sp,8
8110bf2c:	f800283a 	ret

8110bf30 <uliSyncGetMbt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetMbt(void) {
8110bf30:	defffd04 	addi	sp,sp,-12
8110bf34:	de00012e 	bgeu	sp,et,8110bf3c <uliSyncGetMbt+0xc>
8110bf38:	003b68fa 	trap	3
8110bf3c:	dfc00215 	stw	ra,8(sp)
8110bf40:	df000115 	stw	fp,4(sp)
8110bf44:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_MBT_REG_OFFSET);
8110bf48:	01000104 	movi	r4,4
8110bf4c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bf50:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bf54:	e0bfff17 	ldw	r2,-4(fp)
}
8110bf58:	e037883a 	mov	sp,fp
8110bf5c:	dfc00117 	ldw	ra,4(sp)
8110bf60:	df000017 	ldw	fp,0(sp)
8110bf64:	dec00204 	addi	sp,sp,8
8110bf68:	f800283a 	ret

8110bf6c <uliSyncGetBt>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetBt(void) {
8110bf6c:	defffd04 	addi	sp,sp,-12
8110bf70:	de00012e 	bgeu	sp,et,8110bf78 <uliSyncGetBt+0xc>
8110bf74:	003b68fa 	trap	3
8110bf78:	dfc00215 	stw	ra,8(sp)
8110bf7c:	df000115 	stw	fp,4(sp)
8110bf80:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_BT_REG_OFFSET);
8110bf84:	01000144 	movi	r4,5
8110bf88:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bf8c:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bf90:	e0bfff17 	ldw	r2,-4(fp)
}
8110bf94:	e037883a 	mov	sp,fp
8110bf98:	dfc00117 	ldw	ra,4(sp)
8110bf9c:	df000017 	ldw	fp,0(sp)
8110bfa0:	dec00204 	addi	sp,sp,8
8110bfa4:	f800283a 	ret

8110bfa8 <uliSyncGetPer>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetPer(void) {
8110bfa8:	defffd04 	addi	sp,sp,-12
8110bfac:	de00012e 	bgeu	sp,et,8110bfb4 <uliSyncGetPer+0xc>
8110bfb0:	003b68fa 	trap	3
8110bfb4:	dfc00215 	stw	ra,8(sp)
8110bfb8:	df000115 	stw	fp,4(sp)
8110bfbc:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_PER_REG_OFFSET);
8110bfc0:	01000184 	movi	r4,6
8110bfc4:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110bfc8:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110bfcc:	e0bfff17 	ldw	r2,-4(fp)
}
8110bfd0:	e037883a 	mov	sp,fp
8110bfd4:	dfc00117 	ldw	ra,4(sp)
8110bfd8:	df000017 	ldw	fp,0(sp)
8110bfdc:	dec00204 	addi	sp,sp,8
8110bfe0:	f800283a 	ret

8110bfe4 <uliSyncGetOst>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetOst(void) {
8110bfe4:	defffd04 	addi	sp,sp,-12
8110bfe8:	de00012e 	bgeu	sp,et,8110bff0 <uliSyncGetOst+0xc>
8110bfec:	003b68fa 	trap	3
8110bff0:	dfc00215 	stw	ra,8(sp)
8110bff4:	df000115 	stw	fp,4(sp)
8110bff8:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_OST_REG_OFFSET);
8110bffc:	010001c4 	movi	r4,7
8110c000:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c004:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c008:	e0bfff17 	ldw	r2,-4(fp)
}
8110c00c:	e037883a 	mov	sp,fp
8110c010:	dfc00117 	ldw	ra,4(sp)
8110c014:	df000017 	ldw	fp,0(sp)
8110c018:	dec00204 	addi	sp,sp,8
8110c01c:	f800283a 	ret

8110c020 <uliSyncGetGeneral>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetGeneral(void) {
8110c020:	defffd04 	addi	sp,sp,-12
8110c024:	de00012e 	bgeu	sp,et,8110c02c <uliSyncGetGeneral+0xc>
8110c028:	003b68fa 	trap	3
8110c02c:	dfc00215 	stw	ra,8(sp)
8110c030:	df000115 	stw	fp,4(sp)
8110c034:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CONFIG_GENERAL_REG_OFFSET);
8110c038:	01000204 	movi	r4,8
8110c03c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c040:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c044:	e0bfff17 	ldw	r2,-4(fp)
}
8110c048:	e037883a 	mov	sp,fp
8110c04c:	dfc00117 	ldw	ra,4(sp)
8110c050:	df000017 	ldw	fp,0(sp)
8110c054:	dec00204 	addi	sp,sp,8
8110c058:	f800283a 	ret

8110c05c <bSyncErrInj>:
 *
 * @param [in] alt_u32 value
 *
 * @retval bool TRUE
 */
bool bSyncErrInj(alt_u32 uliValue) {
8110c05c:	defffd04 	addi	sp,sp,-12
8110c060:	de00012e 	bgeu	sp,et,8110c068 <bSyncErrInj+0xc>
8110c064:	003b68fa 	trap	3
8110c068:	dfc00215 	stw	ra,8(sp)
8110c06c:	df000115 	stw	fp,4(sp)
8110c070:	df000104 	addi	fp,sp,4
8110c074:	e13fff15 	stw	r4,-4(fp)
	bSyncWriteReg(SYNC_ERR_INJ_REG_OFFSET, uliValue);
8110c078:	e17fff17 	ldw	r5,-4(fp)
8110c07c:	01000244 	movi	r4,9
8110c080:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c084:	00800044 	movi	r2,1
}
8110c088:	e037883a 	mov	sp,fp
8110c08c:	dfc00117 	ldw	ra,4(sp)
8110c090:	df000017 	ldw	fp,0(sp)
8110c094:	dec00204 	addi	sp,sp,8
8110c098:	f800283a 	ret

8110c09c <bSyncCtrExtnIrq>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrExtnIrq(bool bValue) {
8110c09c:	defffc04 	addi	sp,sp,-16
8110c0a0:	de00012e 	bgeu	sp,et,8110c0a8 <bSyncCtrExtnIrq+0xc>
8110c0a4:	003b68fa 	trap	3
8110c0a8:	dfc00315 	stw	ra,12(sp)
8110c0ac:	df000215 	stw	fp,8(sp)
8110c0b0:	df000204 	addi	fp,sp,8
8110c0b4:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c0b8:	01000284 	movi	r4,10
8110c0bc:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c0c0:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c0c4:	e0bfff17 	ldw	r2,-4(fp)
8110c0c8:	1000061e 	bne	r2,zero,8110c0e4 <bSyncCtrExtnIrq+0x48>
		uliAux &= ~SYNC_CTR_EXTN_INT_MSK;
8110c0cc:	e0fffe17 	ldw	r3,-8(fp)
8110c0d0:	00a00034 	movhi	r2,32768
8110c0d4:	10bfffc4 	addi	r2,r2,-1
8110c0d8:	1884703a 	and	r2,r3,r2
8110c0dc:	e0bffe15 	stw	r2,-8(fp)
8110c0e0:	00000306 	br	8110c0f0 <bSyncCtrExtnIrq+0x54>
	} else {
		uliAux |= SYNC_CTR_EXTN_INT_MSK;
8110c0e4:	e0bffe17 	ldw	r2,-8(fp)
8110c0e8:	10a00034 	orhi	r2,r2,32768
8110c0ec:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c0f0:	e17ffe17 	ldw	r5,-8(fp)
8110c0f4:	01000284 	movi	r4,10
8110c0f8:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c0fc:	00800044 	movi	r2,1
}
8110c100:	e037883a 	mov	sp,fp
8110c104:	dfc00117 	ldw	ra,4(sp)
8110c108:	df000017 	ldw	fp,0(sp)
8110c10c:	dec00204 	addi	sp,sp,8
8110c110:	f800283a 	ret

8110c114 <bSyncCtrStart>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrStart(void) {
8110c114:	defffd04 	addi	sp,sp,-12
8110c118:	de00012e 	bgeu	sp,et,8110c120 <bSyncCtrStart+0xc>
8110c11c:	003b68fa 	trap	3
8110c120:	dfc00215 	stw	ra,8(sp)
8110c124:	df000115 	stw	fp,4(sp)
8110c128:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c12c:	01000284 	movi	r4,10
8110c130:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c134:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_START_MSK;
8110c138:	e0bfff17 	ldw	r2,-4(fp)
8110c13c:	10800234 	orhi	r2,r2,8
8110c140:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c144:	e17fff17 	ldw	r5,-4(fp)
8110c148:	01000284 	movi	r4,10
8110c14c:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c150:	00800044 	movi	r2,1
}
8110c154:	e037883a 	mov	sp,fp
8110c158:	dfc00117 	ldw	ra,4(sp)
8110c15c:	df000017 	ldw	fp,0(sp)
8110c160:	dec00204 	addi	sp,sp,8
8110c164:	f800283a 	ret

8110c168 <bSyncCtrReset>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrReset(void) {
8110c168:	defffd04 	addi	sp,sp,-12
8110c16c:	de00012e 	bgeu	sp,et,8110c174 <bSyncCtrReset+0xc>
8110c170:	003b68fa 	trap	3
8110c174:	dfc00215 	stw	ra,8(sp)
8110c178:	df000115 	stw	fp,4(sp)
8110c17c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c180:	01000284 	movi	r4,10
8110c184:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c188:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_RESET_MSK;
8110c18c:	e0bfff17 	ldw	r2,-4(fp)
8110c190:	10800134 	orhi	r2,r2,4
8110c194:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c198:	e17fff17 	ldw	r5,-4(fp)
8110c19c:	01000284 	movi	r4,10
8110c1a0:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c1a4:	00800044 	movi	r2,1
}
8110c1a8:	e037883a 	mov	sp,fp
8110c1ac:	dfc00117 	ldw	ra,4(sp)
8110c1b0:	df000017 	ldw	fp,0(sp)
8110c1b4:	dec00204 	addi	sp,sp,8
8110c1b8:	f800283a 	ret

8110c1bc <bSyncCtrOneShot>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrOneShot(void) {
8110c1bc:	defffd04 	addi	sp,sp,-12
8110c1c0:	de00012e 	bgeu	sp,et,8110c1c8 <bSyncCtrOneShot+0xc>
8110c1c4:	003b68fa 	trap	3
8110c1c8:	dfc00215 	stw	ra,8(sp)
8110c1cc:	df000115 	stw	fp,4(sp)
8110c1d0:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c1d4:	01000284 	movi	r4,10
8110c1d8:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c1dc:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ONE_SHOT_MSK;
8110c1e0:	e0bfff17 	ldw	r2,-4(fp)
8110c1e4:	108000b4 	orhi	r2,r2,2
8110c1e8:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c1ec:	e17fff17 	ldw	r5,-4(fp)
8110c1f0:	01000284 	movi	r4,10
8110c1f4:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c1f8:	00800044 	movi	r2,1
}
8110c1fc:	e037883a 	mov	sp,fp
8110c200:	dfc00117 	ldw	ra,4(sp)
8110c204:	df000017 	ldw	fp,0(sp)
8110c208:	dec00204 	addi	sp,sp,8
8110c20c:	f800283a 	ret

8110c210 <bSyncCtrErrInj>:
 *
 * @param [in] void
 *
 * @retval bool TRUE
 */
bool bSyncCtrErrInj(void) {
8110c210:	defffd04 	addi	sp,sp,-12
8110c214:	de00012e 	bgeu	sp,et,8110c21c <bSyncCtrErrInj+0xc>
8110c218:	003b68fa 	trap	3
8110c21c:	dfc00215 	stw	ra,8(sp)
8110c220:	df000115 	stw	fp,4(sp)
8110c224:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c228:	01000284 	movi	r4,10
8110c22c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c230:	e0bfff15 	stw	r2,-4(fp)

	uliAux |= SYNC_CTR_ERR_INJ_MSK;
8110c234:	e0bfff17 	ldw	r2,-4(fp)
8110c238:	10800074 	orhi	r2,r2,1
8110c23c:	e0bfff15 	stw	r2,-4(fp)

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c240:	e17fff17 	ldw	r5,-4(fp)
8110c244:	01000284 	movi	r4,10
8110c248:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c24c:	00800044 	movi	r2,1
}
8110c250:	e037883a 	mov	sp,fp
8110c254:	dfc00117 	ldw	ra,4(sp)
8110c258:	df000017 	ldw	fp,0(sp)
8110c25c:	dec00204 	addi	sp,sp,8
8110c260:	f800283a 	ret

8110c264 <bSyncCtrSyncOutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrSyncOutEnable(bool bValue) {
8110c264:	defffc04 	addi	sp,sp,-16
8110c268:	de00012e 	bgeu	sp,et,8110c270 <bSyncCtrSyncOutEnable+0xc>
8110c26c:	003b68fa 	trap	3
8110c270:	dfc00315 	stw	ra,12(sp)
8110c274:	df000215 	stw	fp,8(sp)
8110c278:	df000204 	addi	fp,sp,8
8110c27c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c280:	01000284 	movi	r4,10
8110c284:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c288:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c28c:	e0bfff17 	ldw	r2,-4(fp)
8110c290:	1000051e 	bne	r2,zero,8110c2a8 <bSyncCtrSyncOutEnable+0x44>
		uliAux &= ~SYNC_CTR_SYNC_OUT_EN_MSK;
8110c294:	e0fffe17 	ldw	r3,-8(fp)
8110c298:	00bfbfc4 	movi	r2,-257
8110c29c:	1884703a 	and	r2,r3,r2
8110c2a0:	e0bffe15 	stw	r2,-8(fp)
8110c2a4:	00000306 	br	8110c2b4 <bSyncCtrSyncOutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_SYNC_OUT_EN_MSK;
8110c2a8:	e0bffe17 	ldw	r2,-8(fp)
8110c2ac:	10804014 	ori	r2,r2,256
8110c2b0:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c2b4:	e17ffe17 	ldw	r5,-8(fp)
8110c2b8:	01000284 	movi	r4,10
8110c2bc:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c2c0:	00800044 	movi	r2,1
}
8110c2c4:	e037883a 	mov	sp,fp
8110c2c8:	dfc00117 	ldw	ra,4(sp)
8110c2cc:	df000017 	ldw	fp,0(sp)
8110c2d0:	dec00204 	addi	sp,sp,8
8110c2d4:	f800283a 	ret

8110c2d8 <bSyncCtrCh1OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh1OutEnable(bool bValue) {
8110c2d8:	defffc04 	addi	sp,sp,-16
8110c2dc:	de00012e 	bgeu	sp,et,8110c2e4 <bSyncCtrCh1OutEnable+0xc>
8110c2e0:	003b68fa 	trap	3
8110c2e4:	dfc00315 	stw	ra,12(sp)
8110c2e8:	df000215 	stw	fp,8(sp)
8110c2ec:	df000204 	addi	fp,sp,8
8110c2f0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c2f4:	01000284 	movi	r4,10
8110c2f8:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c2fc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c300:	e0bfff17 	ldw	r2,-4(fp)
8110c304:	1000051e 	bne	r2,zero,8110c31c <bSyncCtrCh1OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHA_EN_MSK;
8110c308:	e0fffe17 	ldw	r3,-8(fp)
8110c30c:	00bfff84 	movi	r2,-2
8110c310:	1884703a 	and	r2,r3,r2
8110c314:	e0bffe15 	stw	r2,-8(fp)
8110c318:	00000306 	br	8110c328 <bSyncCtrCh1OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHA_EN_MSK;
8110c31c:	e0bffe17 	ldw	r2,-8(fp)
8110c320:	10800054 	ori	r2,r2,1
8110c324:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c328:	e17ffe17 	ldw	r5,-8(fp)
8110c32c:	01000284 	movi	r4,10
8110c330:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c334:	00800044 	movi	r2,1
}
8110c338:	e037883a 	mov	sp,fp
8110c33c:	dfc00117 	ldw	ra,4(sp)
8110c340:	df000017 	ldw	fp,0(sp)
8110c344:	dec00204 	addi	sp,sp,8
8110c348:	f800283a 	ret

8110c34c <bSyncCtrCh2OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh2OutEnable(bool bValue) {
8110c34c:	defffc04 	addi	sp,sp,-16
8110c350:	de00012e 	bgeu	sp,et,8110c358 <bSyncCtrCh2OutEnable+0xc>
8110c354:	003b68fa 	trap	3
8110c358:	dfc00315 	stw	ra,12(sp)
8110c35c:	df000215 	stw	fp,8(sp)
8110c360:	df000204 	addi	fp,sp,8
8110c364:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c368:	01000284 	movi	r4,10
8110c36c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c370:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c374:	e0bfff17 	ldw	r2,-4(fp)
8110c378:	1000051e 	bne	r2,zero,8110c390 <bSyncCtrCh2OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHB_EN_MSK;
8110c37c:	e0fffe17 	ldw	r3,-8(fp)
8110c380:	00bfff44 	movi	r2,-3
8110c384:	1884703a 	and	r2,r3,r2
8110c388:	e0bffe15 	stw	r2,-8(fp)
8110c38c:	00000306 	br	8110c39c <bSyncCtrCh2OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHB_EN_MSK;
8110c390:	e0bffe17 	ldw	r2,-8(fp)
8110c394:	10800094 	ori	r2,r2,2
8110c398:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c39c:	e17ffe17 	ldw	r5,-8(fp)
8110c3a0:	01000284 	movi	r4,10
8110c3a4:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c3a8:	00800044 	movi	r2,1
}
8110c3ac:	e037883a 	mov	sp,fp
8110c3b0:	dfc00117 	ldw	ra,4(sp)
8110c3b4:	df000017 	ldw	fp,0(sp)
8110c3b8:	dec00204 	addi	sp,sp,8
8110c3bc:	f800283a 	ret

8110c3c0 <bSyncCtrCh3OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh3OutEnable(bool bValue) {
8110c3c0:	defffc04 	addi	sp,sp,-16
8110c3c4:	de00012e 	bgeu	sp,et,8110c3cc <bSyncCtrCh3OutEnable+0xc>
8110c3c8:	003b68fa 	trap	3
8110c3cc:	dfc00315 	stw	ra,12(sp)
8110c3d0:	df000215 	stw	fp,8(sp)
8110c3d4:	df000204 	addi	fp,sp,8
8110c3d8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c3dc:	01000284 	movi	r4,10
8110c3e0:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c3e4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c3e8:	e0bfff17 	ldw	r2,-4(fp)
8110c3ec:	1000051e 	bne	r2,zero,8110c404 <bSyncCtrCh3OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHC_EN_MSK;
8110c3f0:	e0fffe17 	ldw	r3,-8(fp)
8110c3f4:	00bffec4 	movi	r2,-5
8110c3f8:	1884703a 	and	r2,r3,r2
8110c3fc:	e0bffe15 	stw	r2,-8(fp)
8110c400:	00000306 	br	8110c410 <bSyncCtrCh3OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHC_EN_MSK;
8110c404:	e0bffe17 	ldw	r2,-8(fp)
8110c408:	10800114 	ori	r2,r2,4
8110c40c:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c410:	e17ffe17 	ldw	r5,-8(fp)
8110c414:	01000284 	movi	r4,10
8110c418:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c41c:	00800044 	movi	r2,1
}
8110c420:	e037883a 	mov	sp,fp
8110c424:	dfc00117 	ldw	ra,4(sp)
8110c428:	df000017 	ldw	fp,0(sp)
8110c42c:	dec00204 	addi	sp,sp,8
8110c430:	f800283a 	ret

8110c434 <bSyncCtrCh4OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh4OutEnable(bool bValue) {
8110c434:	defffc04 	addi	sp,sp,-16
8110c438:	de00012e 	bgeu	sp,et,8110c440 <bSyncCtrCh4OutEnable+0xc>
8110c43c:	003b68fa 	trap	3
8110c440:	dfc00315 	stw	ra,12(sp)
8110c444:	df000215 	stw	fp,8(sp)
8110c448:	df000204 	addi	fp,sp,8
8110c44c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c450:	01000284 	movi	r4,10
8110c454:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c458:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c45c:	e0bfff17 	ldw	r2,-4(fp)
8110c460:	1000051e 	bne	r2,zero,8110c478 <bSyncCtrCh4OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHD_EN_MSK;
8110c464:	e0fffe17 	ldw	r3,-8(fp)
8110c468:	00bffdc4 	movi	r2,-9
8110c46c:	1884703a 	and	r2,r3,r2
8110c470:	e0bffe15 	stw	r2,-8(fp)
8110c474:	00000306 	br	8110c484 <bSyncCtrCh4OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHD_EN_MSK;
8110c478:	e0bffe17 	ldw	r2,-8(fp)
8110c47c:	10800214 	ori	r2,r2,8
8110c480:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c484:	e17ffe17 	ldw	r5,-8(fp)
8110c488:	01000284 	movi	r4,10
8110c48c:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c490:	00800044 	movi	r2,1
}
8110c494:	e037883a 	mov	sp,fp
8110c498:	dfc00117 	ldw	ra,4(sp)
8110c49c:	df000017 	ldw	fp,0(sp)
8110c4a0:	dec00204 	addi	sp,sp,8
8110c4a4:	f800283a 	ret

8110c4a8 <bSyncCtrCh5OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh5OutEnable(bool bValue) {
8110c4a8:	defffc04 	addi	sp,sp,-16
8110c4ac:	de00012e 	bgeu	sp,et,8110c4b4 <bSyncCtrCh5OutEnable+0xc>
8110c4b0:	003b68fa 	trap	3
8110c4b4:	dfc00315 	stw	ra,12(sp)
8110c4b8:	df000215 	stw	fp,8(sp)
8110c4bc:	df000204 	addi	fp,sp,8
8110c4c0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c4c4:	01000284 	movi	r4,10
8110c4c8:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c4cc:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c4d0:	e0bfff17 	ldw	r2,-4(fp)
8110c4d4:	1000051e 	bne	r2,zero,8110c4ec <bSyncCtrCh5OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHE_EN_MSK;
8110c4d8:	e0fffe17 	ldw	r3,-8(fp)
8110c4dc:	00bffbc4 	movi	r2,-17
8110c4e0:	1884703a 	and	r2,r3,r2
8110c4e4:	e0bffe15 	stw	r2,-8(fp)
8110c4e8:	00000306 	br	8110c4f8 <bSyncCtrCh5OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHE_EN_MSK;
8110c4ec:	e0bffe17 	ldw	r2,-8(fp)
8110c4f0:	10800414 	ori	r2,r2,16
8110c4f4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c4f8:	e17ffe17 	ldw	r5,-8(fp)
8110c4fc:	01000284 	movi	r4,10
8110c500:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c504:	00800044 	movi	r2,1
}
8110c508:	e037883a 	mov	sp,fp
8110c50c:	dfc00117 	ldw	ra,4(sp)
8110c510:	df000017 	ldw	fp,0(sp)
8110c514:	dec00204 	addi	sp,sp,8
8110c518:	f800283a 	ret

8110c51c <bSyncCtrCh6OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh6OutEnable(bool bValue) {
8110c51c:	defffc04 	addi	sp,sp,-16
8110c520:	de00012e 	bgeu	sp,et,8110c528 <bSyncCtrCh6OutEnable+0xc>
8110c524:	003b68fa 	trap	3
8110c528:	dfc00315 	stw	ra,12(sp)
8110c52c:	df000215 	stw	fp,8(sp)
8110c530:	df000204 	addi	fp,sp,8
8110c534:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c538:	01000284 	movi	r4,10
8110c53c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c540:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c544:	e0bfff17 	ldw	r2,-4(fp)
8110c548:	1000051e 	bne	r2,zero,8110c560 <bSyncCtrCh6OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHF_EN_MSK;
8110c54c:	e0fffe17 	ldw	r3,-8(fp)
8110c550:	00bff7c4 	movi	r2,-33
8110c554:	1884703a 	and	r2,r3,r2
8110c558:	e0bffe15 	stw	r2,-8(fp)
8110c55c:	00000306 	br	8110c56c <bSyncCtrCh6OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHF_EN_MSK;
8110c560:	e0bffe17 	ldw	r2,-8(fp)
8110c564:	10800814 	ori	r2,r2,32
8110c568:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c56c:	e17ffe17 	ldw	r5,-8(fp)
8110c570:	01000284 	movi	r4,10
8110c574:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c578:	00800044 	movi	r2,1
}
8110c57c:	e037883a 	mov	sp,fp
8110c580:	dfc00117 	ldw	ra,4(sp)
8110c584:	df000017 	ldw	fp,0(sp)
8110c588:	dec00204 	addi	sp,sp,8
8110c58c:	f800283a 	ret

8110c590 <bSyncCtrCh7OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh7OutEnable(bool bValue) {
8110c590:	defffc04 	addi	sp,sp,-16
8110c594:	de00012e 	bgeu	sp,et,8110c59c <bSyncCtrCh7OutEnable+0xc>
8110c598:	003b68fa 	trap	3
8110c59c:	dfc00315 	stw	ra,12(sp)
8110c5a0:	df000215 	stw	fp,8(sp)
8110c5a4:	df000204 	addi	fp,sp,8
8110c5a8:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c5ac:	01000284 	movi	r4,10
8110c5b0:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c5b4:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c5b8:	e0bfff17 	ldw	r2,-4(fp)
8110c5bc:	1000051e 	bne	r2,zero,8110c5d4 <bSyncCtrCh7OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHG_EN_MSK;
8110c5c0:	e0fffe17 	ldw	r3,-8(fp)
8110c5c4:	00bfefc4 	movi	r2,-65
8110c5c8:	1884703a 	and	r2,r3,r2
8110c5cc:	e0bffe15 	stw	r2,-8(fp)
8110c5d0:	00000306 	br	8110c5e0 <bSyncCtrCh7OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHG_EN_MSK;
8110c5d4:	e0bffe17 	ldw	r2,-8(fp)
8110c5d8:	10801014 	ori	r2,r2,64
8110c5dc:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c5e0:	e17ffe17 	ldw	r5,-8(fp)
8110c5e4:	01000284 	movi	r4,10
8110c5e8:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c5ec:	00800044 	movi	r2,1
}
8110c5f0:	e037883a 	mov	sp,fp
8110c5f4:	dfc00117 	ldw	ra,4(sp)
8110c5f8:	df000017 	ldw	fp,0(sp)
8110c5fc:	dec00204 	addi	sp,sp,8
8110c600:	f800283a 	ret

8110c604 <bSyncCtrCh8OutEnable>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncCtrCh8OutEnable(bool bValue) {
8110c604:	defffc04 	addi	sp,sp,-16
8110c608:	de00012e 	bgeu	sp,et,8110c610 <bSyncCtrCh8OutEnable+0xc>
8110c60c:	003b68fa 	trap	3
8110c610:	dfc00315 	stw	ra,12(sp)
8110c614:	df000215 	stw	fp,8(sp)
8110c618:	df000204 	addi	fp,sp,8
8110c61c:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c620:	01000284 	movi	r4,10
8110c624:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c628:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c62c:	e0bfff17 	ldw	r2,-4(fp)
8110c630:	1000051e 	bne	r2,zero,8110c648 <bSyncCtrCh8OutEnable+0x44>
		uliAux &= ~SYNC_CTR_CHH_EN_MSK;
8110c634:	e0fffe17 	ldw	r3,-8(fp)
8110c638:	00bfdfc4 	movi	r2,-129
8110c63c:	1884703a 	and	r2,r3,r2
8110c640:	e0bffe15 	stw	r2,-8(fp)
8110c644:	00000306 	br	8110c654 <bSyncCtrCh8OutEnable+0x50>
	} else {
		uliAux |= SYNC_CTR_CHH_EN_MSK;
8110c648:	e0bffe17 	ldw	r2,-8(fp)
8110c64c:	10802014 	ori	r2,r2,128
8110c650:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_CTR_REG_OFFSET, uliAux);
8110c654:	e17ffe17 	ldw	r5,-8(fp)
8110c658:	01000284 	movi	r4,10
8110c65c:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c660:	00800044 	movi	r2,1
}
8110c664:	e037883a 	mov	sp,fp
8110c668:	dfc00117 	ldw	ra,4(sp)
8110c66c:	df000017 	ldw	fp,0(sp)
8110c670:	dec00204 	addi	sp,sp,8
8110c674:	f800283a 	ret

8110c678 <bSyncIrqEnableError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableError(bool bValue) {
8110c678:	defffc04 	addi	sp,sp,-16
8110c67c:	de00012e 	bgeu	sp,et,8110c684 <bSyncIrqEnableError+0xc>
8110c680:	003b68fa 	trap	3
8110c684:	dfc00315 	stw	ra,12(sp)
8110c688:	df000215 	stw	fp,8(sp)
8110c68c:	df000204 	addi	fp,sp,8
8110c690:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c694:	01000044 	movi	r4,1
8110c698:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c69c:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c6a0:	e0bfff17 	ldw	r2,-4(fp)
8110c6a4:	1000051e 	bne	r2,zero,8110c6bc <bSyncIrqEnableError+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_ERROR_MSK;
8110c6a8:	e0fffe17 	ldw	r3,-8(fp)
8110c6ac:	00bfff44 	movi	r2,-3
8110c6b0:	1884703a 	and	r2,r3,r2
8110c6b4:	e0bffe15 	stw	r2,-8(fp)
8110c6b8:	00000306 	br	8110c6c8 <bSyncIrqEnableError+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_ERROR_MSK;
8110c6bc:	e0bffe17 	ldw	r2,-8(fp)
8110c6c0:	10800094 	ori	r2,r2,2
8110c6c4:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c6c8:	e17ffe17 	ldw	r5,-8(fp)
8110c6cc:	01000044 	movi	r4,1
8110c6d0:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c6d4:	00800044 	movi	r2,1
}
8110c6d8:	e037883a 	mov	sp,fp
8110c6dc:	dfc00117 	ldw	ra,4(sp)
8110c6e0:	df000017 	ldw	fp,0(sp)
8110c6e4:	dec00204 	addi	sp,sp,8
8110c6e8:	f800283a 	ret

8110c6ec <bSyncIrqEnableBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqEnableBlank(bool bValue) {
8110c6ec:	defffc04 	addi	sp,sp,-16
8110c6f0:	de00012e 	bgeu	sp,et,8110c6f8 <bSyncIrqEnableBlank+0xc>
8110c6f4:	003b68fa 	trap	3
8110c6f8:	dfc00315 	stw	ra,12(sp)
8110c6fc:	df000215 	stw	fp,8(sp)
8110c700:	df000204 	addi	fp,sp,8
8110c704:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_ENABLE_REG_OFFSET);
8110c708:	01000044 	movi	r4,1
8110c70c:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c710:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c714:	e0bfff17 	ldw	r2,-4(fp)
8110c718:	1000051e 	bne	r2,zero,8110c730 <bSyncIrqEnableBlank+0x44>
		uliAux &= ~SYNC_IRQ_ENABLE_BLANK_MSK;
8110c71c:	e0fffe17 	ldw	r3,-8(fp)
8110c720:	00bfff84 	movi	r2,-2
8110c724:	1884703a 	and	r2,r3,r2
8110c728:	e0bffe15 	stw	r2,-8(fp)
8110c72c:	00000306 	br	8110c73c <bSyncIrqEnableBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_ENABLE_BLANK_MSK;
8110c730:	e0bffe17 	ldw	r2,-8(fp)
8110c734:	10800054 	ori	r2,r2,1
8110c738:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_ENABLE_REG_OFFSET, uliAux);
8110c73c:	e17ffe17 	ldw	r5,-8(fp)
8110c740:	01000044 	movi	r4,1
8110c744:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c748:	00800044 	movi	r2,1
}
8110c74c:	e037883a 	mov	sp,fp
8110c750:	dfc00117 	ldw	ra,4(sp)
8110c754:	df000017 	ldw	fp,0(sp)
8110c758:	dec00204 	addi	sp,sp,8
8110c75c:	f800283a 	ret

8110c760 <bSyncIrqFlagClrError>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrError(bool bValue) {
8110c760:	defffc04 	addi	sp,sp,-16
8110c764:	de00012e 	bgeu	sp,et,8110c76c <bSyncIrqFlagClrError+0xc>
8110c768:	003b68fa 	trap	3
8110c76c:	dfc00315 	stw	ra,12(sp)
8110c770:	df000215 	stw	fp,8(sp)
8110c774:	df000204 	addi	fp,sp,8
8110c778:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c77c:	01000084 	movi	r4,2
8110c780:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c784:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c788:	e0bfff17 	ldw	r2,-4(fp)
8110c78c:	1000051e 	bne	r2,zero,8110c7a4 <bSyncIrqFlagClrError+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c790:	e0fffe17 	ldw	r3,-8(fp)
8110c794:	00bfff44 	movi	r2,-3
8110c798:	1884703a 	and	r2,r3,r2
8110c79c:	e0bffe15 	stw	r2,-8(fp)
8110c7a0:	00000306 	br	8110c7b0 <bSyncIrqFlagClrError+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_ERROR_MSK;
8110c7a4:	e0bffe17 	ldw	r2,-8(fp)
8110c7a8:	10800094 	ori	r2,r2,2
8110c7ac:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c7b0:	e17ffe17 	ldw	r5,-8(fp)
8110c7b4:	01000084 	movi	r4,2
8110c7b8:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c7bc:	00800044 	movi	r2,1
}
8110c7c0:	e037883a 	mov	sp,fp
8110c7c4:	dfc00117 	ldw	ra,4(sp)
8110c7c8:	df000017 	ldw	fp,0(sp)
8110c7cc:	dec00204 	addi	sp,sp,8
8110c7d0:	f800283a 	ret

8110c7d4 <bSyncIrqFlagClrBlank>:
 *
 * @param [in] bool value
 *
 * @retval bool TRUE
 */
bool bSyncIrqFlagClrBlank(bool bValue) {
8110c7d4:	defffc04 	addi	sp,sp,-16
8110c7d8:	de00012e 	bgeu	sp,et,8110c7e0 <bSyncIrqFlagClrBlank+0xc>
8110c7dc:	003b68fa 	trap	3
8110c7e0:	dfc00315 	stw	ra,12(sp)
8110c7e4:	df000215 	stw	fp,8(sp)
8110c7e8:	df000204 	addi	fp,sp,8
8110c7ec:	e13fff15 	stw	r4,-4(fp)
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET);
8110c7f0:	01000084 	movi	r4,2
8110c7f4:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c7f8:	e0bffe15 	stw	r2,-8(fp)

	if (bValue == SYNC_BIT_OFF) {
8110c7fc:	e0bfff17 	ldw	r2,-4(fp)
8110c800:	1000051e 	bne	r2,zero,8110c818 <bSyncIrqFlagClrBlank+0x44>
		uliAux &= ~SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c804:	e0fffe17 	ldw	r3,-8(fp)
8110c808:	00bfff84 	movi	r2,-2
8110c80c:	1884703a 	and	r2,r3,r2
8110c810:	e0bffe15 	stw	r2,-8(fp)
8110c814:	00000306 	br	8110c824 <bSyncIrqFlagClrBlank+0x50>
	} else {
		uliAux |= SYNC_IRQ_FLAG_CLR_BLANK_MSK;
8110c818:	e0bffe17 	ldw	r2,-8(fp)
8110c81c:	10800054 	ori	r2,r2,1
8110c820:	e0bffe15 	stw	r2,-8(fp)
	}

	bSyncWriteReg(SYNC_IRQ_FLAG_CLR_REG_OFFSET, uliAux);
8110c824:	e17ffe17 	ldw	r5,-8(fp)
8110c828:	01000084 	movi	r4,2
8110c82c:	110c9700 	call	8110c970 <bSyncWriteReg>
	return TRUE;
8110c830:	00800044 	movi	r2,1
}
8110c834:	e037883a 	mov	sp,fp
8110c838:	dfc00117 	ldw	ra,4(sp)
8110c83c:	df000017 	ldw	fp,0(sp)
8110c840:	dec00204 	addi	sp,sp,8
8110c844:	f800283a 	ret

8110c848 <bSyncIrqFlagError>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagError(void) {
8110c848:	defffc04 	addi	sp,sp,-16
8110c84c:	de00012e 	bgeu	sp,et,8110c854 <bSyncIrqFlagError+0xc>
8110c850:	003b68fa 	trap	3
8110c854:	dfc00315 	stw	ra,12(sp)
8110c858:	df000215 	stw	fp,8(sp)
8110c85c:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c860:	010000c4 	movi	r4,3
8110c864:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c868:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_ERROR_MSK) {
8110c86c:	e0bfff17 	ldw	r2,-4(fp)
8110c870:	1080008c 	andi	r2,r2,2
8110c874:	10000326 	beq	r2,zero,8110c884 <bSyncIrqFlagError+0x3c>
		bResult = TRUE;
8110c878:	00800044 	movi	r2,1
8110c87c:	e0bffe15 	stw	r2,-8(fp)
8110c880:	00000106 	br	8110c888 <bSyncIrqFlagError+0x40>
	} else {
		bResult = FALSE;
8110c884:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c888:	e0bffe17 	ldw	r2,-8(fp)
}
8110c88c:	e037883a 	mov	sp,fp
8110c890:	dfc00117 	ldw	ra,4(sp)
8110c894:	df000017 	ldw	fp,0(sp)
8110c898:	dec00204 	addi	sp,sp,8
8110c89c:	f800283a 	ret

8110c8a0 <bSyncIrqFlagBlank>:
 *
 * @param [in] void
 *
 * @retval bool result
 */
bool bSyncIrqFlagBlank(void) {
8110c8a0:	defffc04 	addi	sp,sp,-16
8110c8a4:	de00012e 	bgeu	sp,et,8110c8ac <bSyncIrqFlagBlank+0xc>
8110c8a8:	003b68fa 	trap	3
8110c8ac:	dfc00315 	stw	ra,12(sp)
8110c8b0:	df000215 	stw	fp,8(sp)
8110c8b4:	df000204 	addi	fp,sp,8
	alt_u32 uliAux;
	bool bResult;

	uliAux = uliSyncReadReg(SYNC_IRQ_FLAG_REG_OFFSET);
8110c8b8:	010000c4 	movi	r4,3
8110c8bc:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c8c0:	e0bfff15 	stw	r2,-4(fp)

	if (uliAux & SYNC_IRQ_FLAG_BLANK_MSK) {
8110c8c4:	e0bfff17 	ldw	r2,-4(fp)
8110c8c8:	1080004c 	andi	r2,r2,1
8110c8cc:	10000326 	beq	r2,zero,8110c8dc <bSyncIrqFlagBlank+0x3c>
		bResult = TRUE;
8110c8d0:	00800044 	movi	r2,1
8110c8d4:	e0bffe15 	stw	r2,-8(fp)
8110c8d8:	00000106 	br	8110c8e0 <bSyncIrqFlagBlank+0x40>
	} else {
		bResult = FALSE;
8110c8dc:	e03ffe15 	stw	zero,-8(fp)
	}
	return bResult;
8110c8e0:	e0bffe17 	ldw	r2,-8(fp)
}
8110c8e4:	e037883a 	mov	sp,fp
8110c8e8:	dfc00117 	ldw	ra,4(sp)
8110c8ec:	df000017 	ldw	fp,0(sp)
8110c8f0:	dec00204 	addi	sp,sp,8
8110c8f4:	f800283a 	ret

8110c8f8 <uliSyncGetCtr>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncGetCtr(void) {
8110c8f8:	defffd04 	addi	sp,sp,-12
8110c8fc:	de00012e 	bgeu	sp,et,8110c904 <uliSyncGetCtr+0xc>
8110c900:	003b68fa 	trap	3
8110c904:	dfc00215 	stw	ra,8(sp)
8110c908:	df000115 	stw	fp,4(sp)
8110c90c:	df000104 	addi	fp,sp,4
	alt_u32 uliAux;

	uliAux = uliSyncReadReg(SYNC_CTR_REG_OFFSET);
8110c910:	01000284 	movi	r4,10
8110c914:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c918:	e0bfff15 	stw	r2,-4(fp)
	return uliAux;
8110c91c:	e0bfff17 	ldw	r2,-4(fp)
}
8110c920:	e037883a 	mov	sp,fp
8110c924:	dfc00117 	ldw	ra,4(sp)
8110c928:	df000017 	ldw	fp,0(sp)
8110c92c:	dec00204 	addi	sp,sp,8
8110c930:	f800283a 	ret

8110c934 <uliSyncReadStatus>:
 *
 * @param [in] void
 *
 * @retval alt_u32 value
 */
alt_u32 uliSyncReadStatus(void) {
8110c934:	defffd04 	addi	sp,sp,-12
8110c938:	de00012e 	bgeu	sp,et,8110c940 <uliSyncReadStatus+0xc>
8110c93c:	003b68fa 	trap	3
8110c940:	dfc00215 	stw	ra,8(sp)
8110c944:	df000115 	stw	fp,4(sp)
8110c948:	df000104 	addi	fp,sp,4
	alt_u32 aux;

	aux = uliSyncReadReg(SYNC_STAT_REG_OFFSET);
8110c94c:	0009883a 	mov	r4,zero
8110c950:	110c9cc0 	call	8110c9cc <uliSyncReadReg>
8110c954:	e0bfff15 	stw	r2,-4(fp)
	return aux;
8110c958:	e0bfff17 	ldw	r2,-4(fp)
}
8110c95c:	e037883a 	mov	sp,fp
8110c960:	dfc00117 	ldw	ra,4(sp)
8110c964:	df000017 	ldw	fp,0(sp)
8110c968:	dec00204 	addi	sp,sp,8
8110c96c:	f800283a 	ret

8110c970 <bSyncWriteReg>:
 * @param [in] alt_u32 offset
 * @param [in] alt_u32 value
 *
 * @retval TRUE -> success
 */
bool bSyncWriteReg(alt_u32 uliOffset, alt_u32 uliValue) {
8110c970:	defffc04 	addi	sp,sp,-16
8110c974:	de00012e 	bgeu	sp,et,8110c97c <bSyncWriteReg+0xc>
8110c978:	003b68fa 	trap	3
8110c97c:	df000315 	stw	fp,12(sp)
8110c980:	df000304 	addi	fp,sp,12
8110c984:	e13ffe15 	stw	r4,-8(fp)
8110c988:	e17fff15 	stw	r5,-4(fp)
	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c98c:	00a00034 	movhi	r2,32768
8110c990:	10810004 	addi	r2,r2,1024
8110c994:	e0bffd15 	stw	r2,-12(fp)
	*(p_addr + uliOffset) = uliValue;
8110c998:	e0bffe17 	ldw	r2,-8(fp)
8110c99c:	1085883a 	add	r2,r2,r2
8110c9a0:	1085883a 	add	r2,r2,r2
8110c9a4:	1007883a 	mov	r3,r2
8110c9a8:	e0bffd17 	ldw	r2,-12(fp)
8110c9ac:	10c5883a 	add	r2,r2,r3
8110c9b0:	e0ffff17 	ldw	r3,-4(fp)
8110c9b4:	10c00015 	stw	r3,0(r2)
	return TRUE;
8110c9b8:	00800044 	movi	r2,1
}
8110c9bc:	e037883a 	mov	sp,fp
8110c9c0:	df000017 	ldw	fp,0(sp)
8110c9c4:	dec00104 	addi	sp,sp,4
8110c9c8:	f800283a 	ret

8110c9cc <uliSyncReadReg>:
 *
 * @param [in] alt_u32 offset
 *
 * @retval alt_u32 value -> reg
 */
alt_u32 uliSyncReadReg(alt_u32 uliOffset) {
8110c9cc:	defffc04 	addi	sp,sp,-16
8110c9d0:	de00012e 	bgeu	sp,et,8110c9d8 <uliSyncReadReg+0xc>
8110c9d4:	003b68fa 	trap	3
8110c9d8:	df000315 	stw	fp,12(sp)
8110c9dc:	df000304 	addi	fp,sp,12
8110c9e0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 value;

	alt_u32 *p_addr = (alt_u32 *) SYNC_BASE_ADDR;
8110c9e4:	00a00034 	movhi	r2,32768
8110c9e8:	10810004 	addi	r2,r2,1024
8110c9ec:	e0bffd15 	stw	r2,-12(fp)
	value = *(p_addr + uliOffset);
8110c9f0:	e0bfff17 	ldw	r2,-4(fp)
8110c9f4:	1085883a 	add	r2,r2,r2
8110c9f8:	1085883a 	add	r2,r2,r2
8110c9fc:	1007883a 	mov	r3,r2
8110ca00:	e0bffd17 	ldw	r2,-12(fp)
8110ca04:	10c5883a 	add	r2,r2,r3
8110ca08:	10800017 	ldw	r2,0(r2)
8110ca0c:	e0bffe15 	stw	r2,-8(fp)
	return value;
8110ca10:	e0bffe17 	ldw	r2,-8(fp)
}
8110ca14:	e037883a 	mov	sp,fp
8110ca18:	df000017 	ldw	fp,0(sp)
8110ca1c:	dec00104 	addi	sp,sp,4
8110ca20:	f800283a 	ret

8110ca24 <vDataControlTask>:


#include "data_control_task.h"

/* 0% Ready! */
void vDataControlTask(void *task_data) {
8110ca24:	defff804 	addi	sp,sp,-32
8110ca28:	de00012e 	bgeu	sp,et,8110ca30 <vDataControlTask+0xc>
8110ca2c:	003b68fa 	trap	3
8110ca30:	dfc00715 	stw	ra,28(sp)
8110ca34:	df000615 	stw	fp,24(sp)
8110ca38:	df000604 	addi	fp,sp,24
8110ca3c:	e13ffd15 	stw	r4,-12(fp)
	tQMask uiCmdDTC;
	INT8U error_code;
	TNData_Control *pxDataC;


	pxDataC = (TNData_Control *) task_data;
8110ca40:	e0bffd17 	ldw	r2,-12(fp)
8110ca44:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"Data Controller Task. (Task on)\n");
8110ca48:	d0a05e17 	ldw	r2,-32392(gp)
8110ca4c:	100f883a 	mov	r7,r2
8110ca50:	01800804 	movi	r6,32
8110ca54:	01400044 	movi	r5,1
8110ca58:	01204574 	movhi	r4,33045
8110ca5c:	21217304 	addi	r4,r4,-31284
8110ca60:	111d0b40 	call	8111d0b4 <fwrite>
    #endif

    pxDataC->bUpdateComplete = TRUE;
8110ca64:	e0bffa17 	ldw	r2,-24(fp)
8110ca68:	00c00044 	movi	r3,1
8110ca6c:	10c00515 	stw	r3,20(r2)

    error_code = OSQFlush(xQMaskDataCtrl);
8110ca70:	d0a05b17 	ldw	r2,-32404(gp)
8110ca74:	1009883a 	mov	r4,r2
8110ca78:	1139b3c0 	call	81139b3c <OSQFlush>
8110ca7c:	e0bffc05 	stb	r2,-16(fp)
	if ( error_code != OS_NO_ERR ) {
8110ca80:	e0bffc03 	ldbu	r2,-16(fp)
8110ca84:	10803fcc 	andi	r2,r2,255
8110ca88:	10000126 	beq	r2,zero,8110ca90 <vDataControlTask+0x6c>
		vFailFlushQueueData();
8110ca8c:	11198780 	call	81119878 <vFailFlushQueueData>
	}

	for (;;) {

		uiCmdDTC.ulWord = (unsigned int)OSQPend(xQMaskCMDNDataCtrlTBL, 0, &error_code); /* Blocking operation */
8110ca90:	e0bffc04 	addi	r2,fp,-16
8110ca94:	100d883a 	mov	r6,r2
8110ca98:	000b883a 	mov	r5,zero
8110ca9c:	01204574 	movhi	r4,33045
8110caa0:	211d1604 	addi	r4,r4,29784
8110caa4:	1139bfc0 	call	81139bfc <OSQPend>
8110caa8:	e0bffb15 	stw	r2,-20(fp)
			} else {

				/* todo: For now, do nothing */
			}
		}
		OSTimeDlyHMSM(0, 0, 5, 0); /*todo:Tirar depois do debug*/
8110caac:	000f883a 	mov	r7,zero
8110cab0:	01800144 	movi	r6,5
8110cab4:	000b883a 	mov	r5,zero
8110cab8:	0009883a 	mov	r4,zero
8110cabc:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
	}
8110cac0:	003ff306 	br	8110ca90 <__reset+0xfb0eca90>

8110cac4 <vFeeTask>:

#include "fee_task.h"

TRmapChannel RmapConfAreaL;

void vFeeTask(void *task_data) {
8110cac4:	defff604 	addi	sp,sp,-40
8110cac8:	de00012e 	bgeu	sp,et,8110cad0 <vFeeTask+0xc>
8110cacc:	003b68fa 	trap	3
8110cad0:	dfc00915 	stw	ra,36(sp)
8110cad4:	df000815 	stw	fp,32(sp)
8110cad8:	df000804 	addi	fp,sp,32
8110cadc:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess = FALSE;
8110cae0:	e03ffa15 	stw	zero,-24(fp)
	TCcdMemMap *xCcdMapLocal;
	unsigned char ucReadout;
	alt_u16 usiLengthBlocks;


	pxNFee = ( TNFee * ) task_data;
8110cae4:	e0bfff17 	ldw	r2,-4(fp)
8110cae8:	d0a05215 	stw	r2,-32440(gp)

	#ifdef DEBUG_ON
		fprintf(fp,"NFEE %hhu Task. (Task on)\n", pxNFee->ucId);
8110caec:	d0e05e17 	ldw	r3,-32392(gp)
8110caf0:	d0a05217 	ldw	r2,-32440(gp)
8110caf4:	10800003 	ldbu	r2,0(r2)
8110caf8:	10803fcc 	andi	r2,r2,255
8110cafc:	100d883a 	mov	r6,r2
8110cb00:	01604574 	movhi	r5,33045
8110cb04:	29617c04 	addi	r5,r5,-31248
8110cb08:	1809883a 	mov	r4,r3
8110cb0c:	111ca180 	call	8111ca18 <fprintf>
	#endif

	#ifdef DEBUG_ON
		vPrintConsoleNFee( pxNFee );
8110cb10:	d0a05217 	ldw	r2,-32440(gp)
8110cb14:	1009883a 	mov	r4,r2
8110cb18:	110e8d40 	call	8110e8d4 <vPrintConsoleNFee>
	#endif


	for(;;){

		switch ( pxNFee->xControl.eMode ) {
8110cb1c:	d0a05217 	ldw	r2,-32440(gp)
8110cb20:	10802c17 	ldw	r2,176(r2)
8110cb24:	10c00328 	cmpgeui	r3,r2,12
8110cb28:	18038b1e 	bne	r3,zero,8110d958 <vFeeTask+0xe94>
8110cb2c:	100690ba 	slli	r3,r2,2
8110cb30:	00a04474 	movhi	r2,33041
8110cb34:	10b2d104 	addi	r2,r2,-13500
8110cb38:	1885883a 	add	r2,r3,r2
8110cb3c:	10800017 	ldw	r2,0(r2)
8110cb40:	1000683a 	jmp	r2
8110cb44:	8110cb74 	orhi	r4,r16,17197
8110cb48:	8110ce84 	addi	r4,r16,17210
8110cb4c:	8110cf08 	cmpgei	r4,r16,17212
8110cb50:	8110cfc8 	cmpgei	r4,r16,17215
8110cb54:	8110d668 	cmpgeui	r4,r16,17241
8110cb58:	8110cc88 	cmpgei	r4,r16,17202
8110cb5c:	8110cf18 	cmpnei	r4,r16,17212
8110cb60:	8110d5fc 	xorhi	r4,r16,17239
8110cb64:	8110d958 	cmpnei	r4,r16,17253
8110cb68:	8110d98c 	andi	r4,r16,17254
8110cb6c:	8110d04c 	andi	r4,r16,17217
8110cb70:	8110d8d4 	ori	r4,r16,17251
			case sFeeInit:

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110cb74:	d0a05217 	ldw	r2,-32440(gp)
8110cb78:	10800003 	ldbu	r2,0(r2)
8110cb7c:	10803fcc 	andi	r2,r2,255
8110cb80:	1085883a 	add	r2,r2,r2
8110cb84:	1087883a 	add	r3,r2,r2
8110cb88:	d0a06604 	addi	r2,gp,-32360
8110cb8c:	1885883a 	add	r2,r3,r2
8110cb90:	10800017 	ldw	r2,0(r2)
8110cb94:	1009883a 	mov	r4,r2
8110cb98:	1139b3c0 	call	81139b3c <OSQFlush>
8110cb9c:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cba0:	e0bffd03 	ldbu	r2,-12(fp)
8110cba4:	10803fcc 	andi	r2,r2,255
8110cba8:	10000126 	beq	r2,zero,8110cbb0 <vFeeTask+0xec>
					vFailFlushNFEEQueue();
8110cbac:	11199100 	call	81119910 <vFailFlushNFEEQueue>
				}

				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110cbb0:	d0a05217 	ldw	r2,-32440(gp)
8110cbb4:	10800003 	ldbu	r2,0(r2)
8110cbb8:	10803fcc 	andi	r2,r2,255
8110cbbc:	1085883a 	add	r2,r2,r2
8110cbc0:	1087883a 	add	r3,r2,r2
8110cbc4:	d0a05804 	addi	r2,gp,-32416
8110cbc8:	1885883a 	add	r2,r3,r2
8110cbcc:	10800017 	ldw	r2,0(r2)
8110cbd0:	1009883a 	mov	r4,r2
8110cbd4:	1139b3c0 	call	81139b3c <OSQFlush>
8110cbd8:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cbdc:	e0bffd03 	ldbu	r2,-12(fp)
8110cbe0:	10803fcc 	andi	r2,r2,255
8110cbe4:	10000126 	beq	r2,zero,8110cbec <vFeeTask+0x128>
					vFailFlushNFEEQueue();
8110cbe8:	11199100 	call	81119910 <vFailFlushNFEEQueue>
				}				

				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110cbec:	d0a05217 	ldw	r2,-32440(gp)
8110cbf0:	10803304 	addi	r2,r2,204
8110cbf4:	1009883a 	mov	r4,r2
8110cbf8:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFee->xCcdInfo.usiHalfWidth;
8110cbfc:	d0a05217 	ldw	r2,-32440(gp)
8110cc00:	d0e05217 	ldw	r3,-32440(gp)
8110cc04:	18c0308b 	ldhu	r3,194(r3)
8110cc08:	10c0340d 	sth	r3,208(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFee->xCcdInfo.usiHeight;
8110cc0c:	d0a05217 	ldw	r2,-32440(gp)
8110cc10:	d0e05217 	ldw	r3,-32440(gp)
8110cc14:	18c0310b 	ldhu	r3,196(r3)
8110cc18:	10c0348d 	sth	r3,210(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFee->xCcdInfo.usiHeight - pxNFee->xCcdInfo.usiOLN;
8110cc1c:	d0a05217 	ldw	r2,-32440(gp)
8110cc20:	d0e05217 	ldw	r3,-32440(gp)
8110cc24:	1900310b 	ldhu	r4,196(r3)
8110cc28:	d0e05217 	ldw	r3,-32440(gp)
8110cc2c:	18c0300b 	ldhu	r3,192(r3)
8110cc30:	20c7c83a 	sub	r3,r4,r3
8110cc34:	10c0350d 	sth	r3,212(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiOverscanYSize = pxNFee->xCcdInfo.usiOLN;
8110cc38:	d0a05217 	ldw	r2,-32440(gp)
8110cc3c:	d0e05217 	ldw	r3,-32440(gp)
8110cc40:	18c0300b 	ldhu	r3,192(r3)
8110cc44:	10c0358d 	sth	r3,214(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = 32768;
8110cc48:	d0a05217 	ldw	r2,-32440(gp)
8110cc4c:	00e00004 	movi	r3,-32768
8110cc50:	10c0360d 	sth	r3,216(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = 0; /* 32 KB */
8110cc54:	d0a05217 	ldw	r2,-32440(gp)
8110cc58:	100036c5 	stb	zero,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110cc5c:	d0a05217 	ldw	r2,-32440(gp)
8110cc60:	00c00044 	movi	r3,1
8110cc64:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110cc68:	d0a05217 	ldw	r2,-32440(gp)
8110cc6c:	10803304 	addi	r2,r2,204
8110cc70:	1009883a 	mov	r4,r2
8110cc74:	110479c0 	call	8110479c <bDpktSetPacketConfig>


				pxNFee->xControl.eMode = sToFeeConfig;
8110cc78:	d0a05217 	ldw	r2,-32440(gp)
8110cc7c:	00c00144 	movi	r3,5
8110cc80:	10c02c15 	stw	r3,176(r2)

				break;
8110cc84:	00034406 	br	8110d998 <vFeeTask+0xed4>
			case sToFeeConfig: /* Transition */

				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110cc88:	d0a05217 	ldw	r2,-32440(gp)
8110cc8c:	10804204 	addi	r2,r2,264
8110cc90:	1009883a 	mov	r4,r2
8110cc94:	11075600 	call	81107560 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /*Off*/
8110cc98:	d0a05217 	ldw	r2,-32440(gp)
8110cc9c:	00c00184 	movi	r3,6
8110cca0:	10c06515 	stw	r3,404(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110cca4:	d0a05217 	ldw	r2,-32440(gp)
8110cca8:	10804204 	addi	r2,r2,264
8110ccac:	1009883a 	mov	r4,r2
8110ccb0:	11072740 	call	81107274 <bRmapSetMemConfigArea>

				/*  */
				switch ( pxNFee->xControl.eNextMode ) {
8110ccb4:	d0a05217 	ldw	r2,-32440(gp)
8110ccb8:	10802d17 	ldw	r2,180(r2)
8110ccbc:	10c002e8 	cmpgeui	r3,r2,11
8110ccc0:	1800191e 	bne	r3,zero,8110cd28 <vFeeTask+0x264>
8110ccc4:	100690ba 	slli	r3,r2,2
8110ccc8:	00a04474 	movhi	r2,33041
8110cccc:	10b33704 	addi	r2,r2,-13092
8110ccd0:	1885883a 	add	r2,r3,r2
8110ccd4:	10800017 	ldw	r2,0(r2)
8110ccd8:	1000683a 	jmp	r2
8110ccdc:	8110cd28 	cmpgeui	r4,r16,17204
8110cce0:	8110cd08 	cmpgei	r4,r16,17204
8110cce4:	8110cd28 	cmpgeui	r4,r16,17204
8110cce8:	8110cd28 	cmpgeui	r4,r16,17204
8110ccec:	8110cd18 	cmpnei	r4,r16,17204
8110ccf0:	8110cd08 	cmpgei	r4,r16,17204
8110ccf4:	8110cd28 	cmpgeui	r4,r16,17204
8110ccf8:	8110cd18 	cmpnei	r4,r16,17204
8110ccfc:	8110cd28 	cmpgeui	r4,r16,17204
8110cd00:	8110cd28 	cmpgeui	r4,r16,17204
8110cd04:	8110cd18 	cmpnei	r4,r16,17204
					case sToFeeConfig:
					case sFeeConfig:
						pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x06; /* Off-Mode */
8110cd08:	d0a05217 	ldw	r2,-32440(gp)
8110cd0c:	00c00184 	movi	r3,6
8110cd10:	10c06515 	stw	r3,404(r2)
						break;
8110cd14:	00000506 	br	8110cd2c <vFeeTask+0x268>

						break;
					case sSIMTestFullPattern:
					case sToTestFullPattern:
					case sFeeTestFullPattern:
						pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02;
8110cd18:	d0a05217 	ldw	r2,-32440(gp)
8110cd1c:	00c00084 	movi	r3,2
8110cd20:	10c06515 	stw	r3,404(r2)
						break;
8110cd24:	00000106 	br	8110cd2c <vFeeTask+0x268>
					default:
						break;
8110cd28:	0001883a 	nop
				}



				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Config Mode\n", pxNFee->ucId);
8110cd2c:	d0e05e17 	ldw	r3,-32392(gp)
8110cd30:	d0a05217 	ldw	r2,-32440(gp)
8110cd34:	10800003 	ldbu	r2,0(r2)
8110cd38:	10803fcc 	andi	r2,r2,255
8110cd3c:	100d883a 	mov	r6,r2
8110cd40:	01604574 	movhi	r5,33045
8110cd44:	29618304 	addi	r5,r5,-31220
8110cd48:	1809883a 	mov	r4,r3
8110cd4c:	111ca180 	call	8111ca18 <fprintf>
				#endif

				/* Complete when MUTEX were created */
				if ( pxNFee->xControl.bDMALocked == TRUE ) {
8110cd50:	d0a05217 	ldw	r2,-32440(gp)
8110cd54:	10802217 	ldw	r2,136(r2)
8110cd58:	10800058 	cmpnei	r2,r2,1
8110cd5c:	10000a1e 	bne	r2,zero,8110cd88 <vFeeTask+0x2c4>
					/* If is with the Mutex, should release */
					OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110cd60:	e0fff803 	ldbu	r3,-32(fp)
8110cd64:	00a045b4 	movhi	r2,33046
8110cd68:	10bc4804 	addi	r2,r2,-3808
8110cd6c:	180690fa 	slli	r3,r3,3
8110cd70:	10c5883a 	add	r2,r2,r3
8110cd74:	10800017 	ldw	r2,0(r2)
8110cd78:	1009883a 	mov	r4,r2
8110cd7c:	113908c0 	call	8113908c <OSMutexPost>
					pxNFee->xControl.bDMALocked = FALSE;
8110cd80:	d0a05217 	ldw	r2,-32440(gp)
8110cd84:	10002215 	stw	zero,136(r2)
				}

				/* End of simulation! Clear everything that is possible */
				pxNFee->xControl.bWatingSync = FALSE;
8110cd88:	d0a05217 	ldw	r2,-32440(gp)
8110cd8c:	10002815 	stw	zero,160(r2)
				pxNFee->xControl.bSimulating = FALSE;
8110cd90:	d0a05217 	ldw	r2,-32440(gp)
8110cd94:	10002715 	stw	zero,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110cd98:	d0a05217 	ldw	r2,-32440(gp)
8110cd9c:	10002315 	stw	zero,140(r2)
				pxNFee->xControl.bEnabled = TRUE;
8110cda0:	d0a05217 	ldw	r2,-32440(gp)
8110cda4:	00c00044 	movi	r3,1
8110cda8:	10c02115 	stw	r3,132(r2)
				pxNFee->xControl.ucTimeCode = 0;
8110cdac:	d0a05217 	ldw	r2,-32440(gp)
8110cdb0:	10002a05 	stb	zero,168(r2)

				error_code = OSQFlush( xFeeQ[ pxNFee->ucId ] );
8110cdb4:	d0a05217 	ldw	r2,-32440(gp)
8110cdb8:	10800003 	ldbu	r2,0(r2)
8110cdbc:	10803fcc 	andi	r2,r2,255
8110cdc0:	1085883a 	add	r2,r2,r2
8110cdc4:	1087883a 	add	r3,r2,r2
8110cdc8:	d0a06604 	addi	r2,gp,-32360
8110cdcc:	1885883a 	add	r2,r3,r2
8110cdd0:	10800017 	ldw	r2,0(r2)
8110cdd4:	1009883a 	mov	r4,r2
8110cdd8:	1139b3c0 	call	81139b3c <OSQFlush>
8110cddc:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110cde0:	e0bffd03 	ldbu	r2,-12(fp)
8110cde4:	10803fcc 	andi	r2,r2,255
8110cde8:	10000126 	beq	r2,zero,8110cdf0 <vFeeTask+0x32c>
					vFailFlushNFEEQueue();
8110cdec:	11199100 	call	81119910 <vFailFlushNFEEQueue>
				}

				/* Clear the Queue that indicates when Sync Signals occours */
				error_code = OSQFlush( xWaitSyncQFee[ pxNFee->ucId ] );
8110cdf0:	d0a05217 	ldw	r2,-32440(gp)
8110cdf4:	10800003 	ldbu	r2,0(r2)
8110cdf8:	10803fcc 	andi	r2,r2,255
8110cdfc:	1085883a 	add	r2,r2,r2
8110ce00:	1087883a 	add	r3,r2,r2
8110ce04:	d0a05804 	addi	r2,gp,-32416
8110ce08:	1885883a 	add	r2,r3,r2
8110ce0c:	10800017 	ldw	r2,0(r2)
8110ce10:	1009883a 	mov	r4,r2
8110ce14:	1139b3c0 	call	81139b3c <OSQFlush>
8110ce18:	e0bffd05 	stb	r2,-12(fp)
				if ( error_code != OS_NO_ERR ) {
8110ce1c:	e0bffd03 	ldbu	r2,-12(fp)
8110ce20:	10803fcc 	andi	r2,r2,255
8110ce24:	10000126 	beq	r2,zero,8110ce2c <vFeeTask+0x368>
					vFailFlushNFEEQueue();
8110ce28:	11199100 	call	81119910 <vFailFlushNFEEQueue>
				}

				/* Disable the link SPW */
				bDisableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110ce2c:	d0a05217 	ldw	r2,-32440(gp)
8110ce30:	10808804 	addi	r2,r2,544
8110ce34:	1009883a 	mov	r4,r2
8110ce38:	110e5e40 	call	8110e5e4 <bDisableSPWChannel>
				pxNFee->xControl.bChannelEnable = FALSE;
8110ce3c:	d0a05217 	ldw	r2,-32440(gp)
8110ce40:	10002615 	stw	zero,152(r2)


				/* Disable RMAP interrupts */
				bDisableRmapIRQ(&pxNFee->xChannel.xRmap);
8110ce44:	d0a05217 	ldw	r2,-32440(gp)
8110ce48:	10804204 	addi	r2,r2,264
8110ce4c:	1009883a 	mov	r4,r2
8110ce50:	110e53c0 	call	8110e53c <bDisableRmapIRQ>


				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110ce54:	d0a05217 	ldw	r2,-32440(gp)
8110ce58:	10803b04 	addi	r2,r2,236
8110ce5c:	1009883a 	mov	r4,r2
8110ce60:	110e7280 	call	8110e728 <bDisAndClrDbBuffer>


				/* Clear the timecode of the channel SPW (for now is for spw channel) */
				bSpwcClearTimecode(&pxNFee->xChannel.xSpacewire);
8110ce64:	d0a05217 	ldw	r2,-32440(gp)
8110ce68:	10808804 	addi	r2,r2,544
8110ce6c:	1009883a 	mov	r4,r2
8110ce70:	11095fc0 	call	811095fc <bSpwcClearTimecode>

				pxNFee->xControl.eMode = sFeeConfig;
8110ce74:	d0a05217 	ldw	r2,-32440(gp)
8110ce78:	00c00044 	movi	r3,1
8110ce7c:	10c02c15 	stw	r3,176(r2)
				break;
8110ce80:	0002c506 	br	8110d998 <vFeeTask+0xed4>


			case sFeeConfig: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110ce84:	d0a05217 	ldw	r2,-32440(gp)
8110ce88:	10800003 	ldbu	r2,0(r2)
8110ce8c:	10803fcc 	andi	r2,r2,255
8110ce90:	1085883a 	add	r2,r2,r2
8110ce94:	1087883a 	add	r3,r2,r2
8110ce98:	d0a06604 	addi	r2,gp,-32360
8110ce9c:	1885883a 	add	r2,r3,r2
8110cea0:	10800017 	ldw	r2,0(r2)
8110cea4:	e0fffd04 	addi	r3,fp,-12
8110cea8:	180d883a 	mov	r6,r3
8110ceac:	000b883a 	mov	r5,zero
8110ceb0:	1009883a 	mov	r4,r2
8110ceb4:	1139bfc0 	call	81139bfc <OSQPend>
8110ceb8:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110cebc:	e0bffd03 	ldbu	r2,-12(fp)
8110cec0:	10803fcc 	andi	r2,r2,255
8110cec4:	1000061e 	bne	r2,zero,8110cee0 <vFeeTask+0x41c>
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
8110cec8:	d0a05217 	ldw	r2,-32440(gp)
8110cecc:	e0fffe17 	ldw	r3,-8(fp)
8110ced0:	180b883a 	mov	r5,r3
8110ced4:	1009883a 	mov	r4,r2
8110ced8:	110d99c0 	call	8110d99c <vQCmdFEEinConfig>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110cedc:	0002ae06 	br	8110d998 <vFeeTask+0xed4>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinConfig( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110cee0:	d0e05e17 	ldw	r3,-32392(gp)
8110cee4:	d0a05217 	ldw	r2,-32440(gp)
8110cee8:	10800003 	ldbu	r2,0(r2)
8110ceec:	10803fcc 	andi	r2,r2,255
8110cef0:	100d883a 	mov	r6,r2
8110cef4:	01604574 	movhi	r5,33045
8110cef8:	29618a04 	addi	r5,r5,-31192
8110cefc:	1809883a 	mov	r4,r3
8110cf00:	111ca180 	call	8111ca18 <fprintf>
					#endif
				}

				break;
8110cf04:	0002a406 	br	8110d998 <vFeeTask+0xed4>
			case sFeeOn: /* Real mode */

				pxNFee->xControl.eMode = sToFeeStandBy;
8110cf08:	d0a05217 	ldw	r2,-32440(gp)
8110cf0c:	00c00184 	movi	r3,6
8110cf10:	10c02c15 	stw	r3,176(r2)
				break;
8110cf14:	0002a006 	br	8110d998 <vFeeTask+0xed4>
				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
			case sToFeeStandBy: /* Transition */
				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110cf18:	d0a05217 	ldw	r2,-32440(gp)
8110cf1c:	10804204 	addi	r2,r2,264
8110cf20:	1009883a 	mov	r4,r2
8110cf24:	11075600 	call	81107560 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x00; /*sToFeeStandBy*/
8110cf28:	d0a05217 	ldw	r2,-32440(gp)
8110cf2c:	10006515 	stw	zero,404(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110cf30:	d0a05217 	ldw	r2,-32440(gp)
8110cf34:	10804204 	addi	r2,r2,264
8110cf38:	1009883a 	mov	r4,r2
8110cf3c:	11072740 	call	81107274 <bRmapSetMemConfigArea>

				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Standby Mode\n", pxNFee->ucId);
8110cf40:	d0e05e17 	ldw	r3,-32392(gp)
8110cf44:	d0a05217 	ldw	r2,-32440(gp)
8110cf48:	10800003 	ldbu	r2,0(r2)
8110cf4c:	10803fcc 	andi	r2,r2,255
8110cf50:	100d883a 	mov	r6,r2
8110cf54:	01604574 	movhi	r5,33045
8110cf58:	29619604 	addi	r5,r5,-31144
8110cf5c:	1809883a 	mov	r4,r3
8110cf60:	111ca180 	call	8111ca18 <fprintf>
				#endif

				incrementador = 0; // remover !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
8110cf64:	d0205315 	stw	zero,-32436(gp)

				pxNFee->xControl.bSimulating = TRUE;
8110cf68:	d0a05217 	ldw	r2,-32440(gp)
8110cf6c:	00c00044 	movi	r3,1
8110cf70:	10c02715 	stw	r3,156(r2)
				pxNFee->xControl.bUsingDMA = FALSE;
8110cf74:	d0a05217 	ldw	r2,-32440(gp)
8110cf78:	10002315 	stw	zero,140(r2)

				/* Disable IRQ and clear the Double Buffer */
				bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110cf7c:	d0a05217 	ldw	r2,-32440(gp)
8110cf80:	10803b04 	addi	r2,r2,236
8110cf84:	1009883a 	mov	r4,r2
8110cf88:	110e7280 	call	8110e728 <bDisAndClrDbBuffer>


				/* Disable RMAP interrupts */
				bEnableRmapIRQ(&pxNFee->xChannel.xRmap);
8110cf8c:	d0a05217 	ldw	r2,-32440(gp)
8110cf90:	10804204 	addi	r2,r2,264
8110cf94:	1009883a 	mov	r4,r2
8110cf98:	110e5880 	call	8110e588 <bEnableRmapIRQ>

				/* Disable the link SPW */
				bEnableSPWChannel( &pxNFee->xChannel.xSpacewire );
8110cf9c:	d0a05217 	ldw	r2,-32440(gp)
8110cfa0:	10808804 	addi	r2,r2,544
8110cfa4:	1009883a 	mov	r4,r2
8110cfa8:	110e6440 	call	8110e644 <bEnableSPWChannel>
				pxNFee->xControl.bChannelEnable = TRUE;
8110cfac:	d0a05217 	ldw	r2,-32440(gp)
8110cfb0:	00c00044 	movi	r3,1
8110cfb4:	10c02615 	stw	r3,152(r2)

				pxNFee->xControl.eMode = sFeeStandBy;
8110cfb8:	d0a05217 	ldw	r2,-32440(gp)
8110cfbc:	00c000c4 	movi	r3,3
8110cfc0:	10c02c15 	stw	r3,176(r2)
				break;
8110cfc4:	00027406 	br	8110d998 <vFeeTask+0xed4>

			case sFeeStandBy: /* Real mode */

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110cfc8:	d0a05217 	ldw	r2,-32440(gp)
8110cfcc:	10800003 	ldbu	r2,0(r2)
8110cfd0:	10803fcc 	andi	r2,r2,255
8110cfd4:	1085883a 	add	r2,r2,r2
8110cfd8:	1087883a 	add	r3,r2,r2
8110cfdc:	d0a06604 	addi	r2,gp,-32360
8110cfe0:	1885883a 	add	r2,r3,r2
8110cfe4:	10800017 	ldw	r2,0(r2)
8110cfe8:	e0fffd04 	addi	r3,fp,-12
8110cfec:	180d883a 	mov	r6,r3
8110cff0:	000b883a 	mov	r5,zero
8110cff4:	1009883a 	mov	r4,r2
8110cff8:	1139bfc0 	call	81139bfc <OSQPend>
8110cffc:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d000:	e0bffd03 	ldbu	r2,-12(fp)
8110d004:	10803fcc 	andi	r2,r2,255
8110d008:	1000061e 	bne	r2,zero,8110d024 <vFeeTask+0x560>
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
8110d00c:	d0a05217 	ldw	r2,-32440(gp)
8110d010:	e0fffe17 	ldw	r3,-8(fp)
8110d014:	180b883a 	mov	r5,r3
8110d018:	1009883a 	mov	r4,r2
8110d01c:	110db4c0 	call	8110db4c <vQCmdFEEinStandBy>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d020:	00025d06 	br	8110d998 <vFeeTask+0xed4>
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
				if ( error_code == OS_ERR_NONE ) {
					vQCmdFEEinStandBy( pxNFee, uiCmdFEE.ulWord );
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d024:	d0e05e17 	ldw	r3,-32392(gp)
8110d028:	d0a05217 	ldw	r2,-32440(gp)
8110d02c:	10800003 	ldbu	r2,0(r2)
8110d030:	10803fcc 	andi	r2,r2,255
8110d034:	100d883a 	mov	r6,r2
8110d038:	01604574 	movhi	r5,33045
8110d03c:	29618a04 	addi	r5,r5,-31192
8110d040:	1809883a 	mov	r4,r3
8110d044:	111ca180 	call	8111ca18 <fprintf>
					#endif
				}

				break;
8110d048:	00025306 	br	8110d998 <vFeeTask+0xed4>
			case sSIMTestFullPattern:
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  ENTROU NO SIM TEST FULL\n ");
8110d04c:	d0a05e17 	ldw	r2,-32392(gp)
8110d050:	100f883a 	mov	r7,r2
8110d054:	01800944 	movi	r6,37
8110d058:	01400044 	movi	r5,1
8110d05c:	01204574 	movhi	r4,33045
8110d060:	21219e04 	addi	r4,r4,-31112
8110d064:	111d0b40 	call	8111d0b4 <fwrite>
#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110d068:	d0a05217 	ldw	r2,-32440(gp)
8110d06c:	00c00044 	movi	r3,1
8110d070:	10c02315 	stw	r3,140(r2)
				pxNFee->xControl.bSimulating = TRUE;
8110d074:	d0a05217 	ldw	r2,-32440(gp)
8110d078:	00c00044 	movi	r3,1
8110d07c:	10c02715 	stw	r3,156(r2)

				/* Enable IRQ and clear the Double Buffer */
				bEnableDbBuffer(&pxNFee->xChannel.xFeeBuffer);
8110d080:	d0a05217 	ldw	r2,-32440(gp)
8110d084:	10803b04 	addi	r2,r2,236
8110d088:	1009883a 	mov	r4,r2
8110d08c:	110e6a40 	call	8110e6a4 <bEnableDbBuffer>

				/* Configurar o tamanho normal do double buffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  */
				bSpwcGetTimecode(&pxNFee->xChannel.xSpacewire);
8110d090:	d0a05217 	ldw	r2,-32440(gp)
8110d094:	10808804 	addi	r2,r2,544
8110d098:	1009883a 	mov	r4,r2
8110d09c:	110956c0 	call	8110956c <bSpwcGetTimecode>
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  TIME CODE SPW: %hhu \n ", pxNFee->xChannel.xSpacewire.xTimecode.ucCounter);
8110d0a0:	d0e05e17 	ldw	r3,-32392(gp)
8110d0a4:	d0a05217 	ldw	r2,-32440(gp)
8110d0a8:	10809443 	ldbu	r2,593(r2)
8110d0ac:	10803fcc 	andi	r2,r2,255
8110d0b0:	100d883a 	mov	r6,r2
8110d0b4:	01604574 	movhi	r5,33045
8110d0b8:	2961a804 	addi	r5,r5,-31072
8110d0bc:	1809883a 	mov	r4,r3
8110d0c0:	111ca180 	call	8111ca18 <fprintf>
#endif
				tCodeNext = ( pxNFee->xChannel.xSpacewire.xTimecode.ucCounter + 1) % 4;
8110d0c4:	d0a05217 	ldw	r2,-32440(gp)
8110d0c8:	10809443 	ldbu	r2,593(r2)
8110d0cc:	10803fcc 	andi	r2,r2,255
8110d0d0:	10c00044 	addi	r3,r2,1
8110d0d4:	00a00034 	movhi	r2,32768
8110d0d8:	108000c4 	addi	r2,r2,3
8110d0dc:	1884703a 	and	r2,r3,r2
8110d0e0:	1000040e 	bge	r2,zero,8110d0f4 <vFeeTask+0x630>
8110d0e4:	10bfffc4 	addi	r2,r2,-1
8110d0e8:	00ffff04 	movi	r3,-4
8110d0ec:	10c4b03a 	or	r2,r2,r3
8110d0f0:	10800044 	addi	r2,r2,1
8110d0f4:	e0bffb15 	stw	r2,-20(fp)
				if ( tCodeNext == 0 ) {
8110d0f8:	e0bffb17 	ldw	r2,-20(fp)
8110d0fc:	10000f1e 	bne	r2,zero,8110d13c <vFeeTask+0x678>
					/* Should get Data from the another memory, because is a cicle start */
					ucMemUsing = (unsigned char) (( *pxNFee->xControl.pActualMem + 1 ) % 2) ; /* Select the other memory*/
8110d100:	d0a05217 	ldw	r2,-32440(gp)
8110d104:	10802917 	ldw	r2,164(r2)
8110d108:	10800003 	ldbu	r2,0(r2)
8110d10c:	10803fcc 	andi	r2,r2,255
8110d110:	10c00044 	addi	r3,r2,1
8110d114:	00a00034 	movhi	r2,32768
8110d118:	10800044 	addi	r2,r2,1
8110d11c:	1884703a 	and	r2,r3,r2
8110d120:	1000040e 	bge	r2,zero,8110d134 <vFeeTask+0x670>
8110d124:	10bfffc4 	addi	r2,r2,-1
8110d128:	00ffff84 	movi	r3,-2
8110d12c:	10c4b03a 	or	r2,r2,r3
8110d130:	10800044 	addi	r2,r2,1
8110d134:	e0bff805 	stb	r2,-32(fp)
8110d138:	00000406 	br	8110d14c <vFeeTask+0x688>
				} else {
					ucMemUsing = (unsigned char) *pxNFee->xControl.pActualMem ; /* Select the of the data control (te future)*/
8110d13c:	d0a05217 	ldw	r2,-32440(gp)
8110d140:	10802917 	ldw	r2,164(r2)
8110d144:	10800003 	ldbu	r2,0(r2)
8110d148:	e0bff805 	stb	r2,-32(fp)
				}

				ucReadout = pxNFee->xControl.ucROutOrder[tCodeNext];
8110d14c:	d0e05217 	ldw	r3,-32440(gp)
8110d150:	e0bffb17 	ldw	r2,-20(fp)
8110d154:	1885883a 	add	r2,r3,r2
8110d158:	10802a44 	addi	r2,r2,169
8110d15c:	10800003 	ldbu	r2,0(r2)
8110d160:	e0bffc05 	stb	r2,-16(fp)

				if ( pxNFee->xControl.eSide == sLeft )
8110d164:	d0a05217 	ldw	r2,-32440(gp)
8110d168:	10802e17 	ldw	r2,184(r2)
8110d16c:	1000071e 	bne	r2,zero,8110d18c <vFeeTask+0x6c8>
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xLeft;
8110d170:	d0e05217 	ldw	r3,-32440(gp)
8110d174:	e0bffc03 	ldbu	r2,-16(fp)
8110d178:	10800624 	muli	r2,r2,24
8110d17c:	10800904 	addi	r2,r2,36
8110d180:	1885883a 	add	r2,r3,r2
8110d184:	e0bff915 	stw	r2,-28(fp)
8110d188:	00000606 	br	8110d1a4 <vFeeTask+0x6e0>
				else
					xCcdMapLocal = &pxNFee->xMemMap.xCcd[ucReadout].xRight;
8110d18c:	d0e05217 	ldw	r3,-32440(gp)
8110d190:	e0bffc03 	ldbu	r2,-16(fp)
8110d194:	10800624 	muli	r2,r2,24
8110d198:	10800c04 	addi	r2,r2,48
8110d19c:	1885883a 	add	r2,r3,r2
8110d1a0:	e0bff915 	stw	r2,-28(fp)


				bDpktGetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d1a4:	d0a05217 	ldw	r2,-32440(gp)
8110d1a8:	10803304 	addi	r2,r2,204
8110d1ac:	1009883a 	mov	r4,r2
8110d1b0:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucCcdNumber = ucReadout;
8110d1b4:	d0a05217 	ldw	r2,-32440(gp)
8110d1b8:	e0fffc03 	ldbu	r3,-16(fp)
8110d1bc:	10c036c5 	stb	r3,219(r2)
				pxNFee->xChannel.xDataPacket.xDpktDataPacketConfig.ucFeeMode = eDpktFullImagePattern; /* todo:No esquecer de atualizar para o ENUM  */
8110d1c0:	d0a05217 	ldw	r2,-32440(gp)
8110d1c4:	00c00044 	movi	r3,1
8110d1c8:	10c03685 	stb	r3,218(r2)
				bDpktSetPacketConfig(&pxNFee->xChannel.xDataPacket);
8110d1cc:	d0a05217 	ldw	r2,-32440(gp)
8110d1d0:	10803304 	addi	r2,r2,204
8110d1d4:	1009883a 	mov	r4,r2
8110d1d8:	110479c0 	call	8110479c <bDpktSetPacketConfig>


				/* todo: resetar o tamanho do buffer size para o maximo !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  JA PEGOU A REFERENCIA DE ENDERECO, VAI MANDAR MENSAGEM REQUISITANDO DMA\n ");
8110d1dc:	d0a05e17 	ldw	r2,-32392(gp)
8110d1e0:	100f883a 	mov	r7,r2
8110d1e4:	01801544 	movi	r6,85
8110d1e8:	01400044 	movi	r5,1
8110d1ec:	01204574 	movhi	r4,33045
8110d1f0:	2121b104 	addi	r4,r4,-31036
8110d1f4:	111d0b40 	call	8111d0b4 <fwrite>
#endif

				/* Make one requests for the Double buffer */
				bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId);
8110d1f8:	d0a05217 	ldw	r2,-32440(gp)
8110d1fc:	10800003 	ldbu	r2,0(r2)
8110d200:	10803fcc 	andi	r2,r2,255
8110d204:	100d883a 	mov	r6,r2
8110d208:	000b883a 	mov	r5,zero
8110d20c:	01002004 	movi	r4,128
8110d210:	110e78c0 	call	8110e78c <bSendRequestNFeeCtrl>

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  ENVIOU MENSAGEM PARA O CONTROLLER PEDINDO DMA. AGUARDANDO NO xFeeQ\n ");
8110d214:	d0a05e17 	ldw	r2,-32392(gp)
8110d218:	100f883a 	mov	r7,r2
8110d21c:	01801404 	movi	r6,80
8110d220:	01400044 	movi	r5,1
8110d224:	01204574 	movhi	r4,33045
8110d228:	2121c704 	addi	r4,r4,-30948
8110d22c:	111d0b40 	call	8111d0b4 <fwrite>
#endif

				/* When get the mutex, perform two DMA writes in order to fill the "double" part of the double buffer */
				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d230:	d0a05217 	ldw	r2,-32440(gp)
8110d234:	10800003 	ldbu	r2,0(r2)
8110d238:	10803fcc 	andi	r2,r2,255
8110d23c:	1085883a 	add	r2,r2,r2
8110d240:	1087883a 	add	r3,r2,r2
8110d244:	d0a06604 	addi	r2,gp,-32360
8110d248:	1885883a 	add	r2,r3,r2
8110d24c:	10800017 	ldw	r2,0(r2)
8110d250:	e0fffd04 	addi	r3,fp,-12
8110d254:	180d883a 	mov	r6,r3
8110d258:	000b883a 	mov	r5,zero
8110d25c:	1009883a 	mov	r4,r2
8110d260:	1139bfc0 	call	81139bfc <OSQPend>
8110d264:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d268:	e0bffd03 	ldbu	r2,-12(fp)
8110d26c:	10803fcc 	andi	r2,r2,255
8110d270:	1000c71e 	bne	r2,zero,8110d590 <vFeeTask+0xacc>

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  RECEBEU MENSAGEM\n ");
8110d274:	d0a05e17 	ldw	r2,-32392(gp)
8110d278:	100f883a 	mov	r7,r2
8110d27c:	01800784 	movi	r6,30
8110d280:	01400044 	movi	r5,1
8110d284:	01204574 	movhi	r4,33045
8110d288:	2121dc04 	addi	r4,r4,-30864
8110d28c:	111d0b40 	call	8111d0b4 <fwrite>
#endif

					/* First Check if is access to the DMA (priority) */
					if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110d290:	e0bffe83 	ldbu	r2,-6(fp)
8110d294:	10803fcc 	andi	r2,r2,255
8110d298:	108023d8 	cmpnei	r2,r2,143
8110d29c:	1000b61e 	bne	r2,zero,8110d578 <vFeeTask+0xab4>
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  ERA DE ACESSO AO DMA\n ");
8110d2a0:	d0a05e17 	ldw	r2,-32392(gp)
8110d2a4:	100f883a 	mov	r7,r2
8110d2a8:	01800884 	movi	r6,34
8110d2ac:	01400044 	movi	r5,1
8110d2b0:	01204574 	movhi	r4,33045
8110d2b4:	2121e404 	addi	r4,r4,-30832
8110d2b8:	111d0b40 	call	8111d0b4 <fwrite>
#endif

						/* Try to get the Mutex */
	                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110d2bc:	e0fff803 	ldbu	r3,-32(fp)
8110d2c0:	00a045b4 	movhi	r2,33046
8110d2c4:	10bc4804 	addi	r2,r2,-3808
8110d2c8:	180690fa 	slli	r3,r3,3
8110d2cc:	10c5883a 	add	r2,r2,r3
8110d2d0:	10800017 	ldw	r2,0(r2)
8110d2d4:	e0fffd04 	addi	r3,fp,-12
8110d2d8:	180d883a 	mov	r6,r3
8110d2dc:	000b883a 	mov	r5,zero
8110d2e0:	1009883a 	mov	r4,r2
8110d2e4:	1138ae80 	call	81138ae8 <OSMutexPend>
	                    if ( error_code == OS_ERR_NONE ) {
8110d2e8:	e0bffd03 	ldbu	r2,-12(fp)
8110d2ec:	10803fcc 	andi	r2,r2,255
8110d2f0:	1000b01e 	bne	r2,zero,8110d5b4 <vFeeTask+0xaf0>
	                    	pxNFee->xControl.bDMALocked = TRUE;
8110d2f4:	d0a05217 	ldw	r2,-32440(gp)
8110d2f8:	00c00044 	movi	r3,1
8110d2fc:	10c02215 	stw	r3,136(r2)

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  PEGOU MUTEX\n ");
8110d300:	d0a05e17 	ldw	r2,-32392(gp)
8110d304:	100f883a 	mov	r7,r2
8110d308:	01800644 	movi	r6,25
8110d30c:	01400044 	movi	r5,1
8110d310:	01204574 	movhi	r4,33045
8110d314:	2121ed04 	addi	r4,r4,-30796
8110d318:	111d0b40 	call	8111d0b4 <fwrite>
#endif

						if (  ucMemUsing == 0  ) {
8110d31c:	e0bff803 	ldbu	r2,-32(fp)
8110d320:	10003f1e 	bne	r2,zero,8110d420 <vFeeTask+0x95c>
							/* Initializing the addr */
	                    	xCcdMapLocal->ulBlockI = 0;
8110d324:	e0bff917 	ldw	r2,-28(fp)
8110d328:	10000115 	stw	zero,4(r2)
							xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110d32c:	e0bff917 	ldw	r2,-28(fp)
8110d330:	10c00017 	ldw	r3,0(r2)
8110d334:	e0bff917 	ldw	r2,-28(fp)
8110d338:	10c00215 	stw	r3,8(r2)
							bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d33c:	e0bff917 	ldw	r2,-28(fp)
8110d340:	10800217 	ldw	r2,8(r2)
8110d344:	1009883a 	mov	r4,r2
8110d348:	d0a05217 	ldw	r2,-32440(gp)
8110d34c:	10802e17 	ldw	r2,184(r2)
8110d350:	10c03fcc 	andi	r3,r2,255
8110d354:	d0a05217 	ldw	r2,-32440(gp)
8110d358:	10800003 	ldbu	r2,0(r2)
8110d35c:	10803fcc 	andi	r2,r2,255
8110d360:	100f883a 	mov	r7,r2
8110d364:	180d883a 	mov	r6,r3
8110d368:	01400404 	movi	r5,16
8110d36c:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d370:	e0bff917 	ldw	r2,-28(fp)
8110d374:	10800217 	ldw	r2,8(r2)
8110d378:	10c22004 	addi	r3,r2,2176
8110d37c:	e0bff917 	ldw	r2,-28(fp)
8110d380:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d384:	e0bff917 	ldw	r2,-28(fp)
8110d388:	10800117 	ldw	r2,4(r2)
8110d38c:	10c00404 	addi	r3,r2,16
8110d390:	e0bff917 	ldw	r2,-28(fp)
8110d394:	10c00115 	stw	r3,4(r2)
							bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d398:	e0bff917 	ldw	r2,-28(fp)
8110d39c:	10800217 	ldw	r2,8(r2)
8110d3a0:	1009883a 	mov	r4,r2
8110d3a4:	d0a05217 	ldw	r2,-32440(gp)
8110d3a8:	10802e17 	ldw	r2,184(r2)
8110d3ac:	10c03fcc 	andi	r3,r2,255
8110d3b0:	d0a05217 	ldw	r2,-32440(gp)
8110d3b4:	10800003 	ldbu	r2,0(r2)
8110d3b8:	10803fcc 	andi	r2,r2,255
8110d3bc:	100f883a 	mov	r7,r2
8110d3c0:	180d883a 	mov	r6,r3
8110d3c4:	01400404 	movi	r5,16
8110d3c8:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d3cc:	e0bff917 	ldw	r2,-28(fp)
8110d3d0:	10800217 	ldw	r2,8(r2)
8110d3d4:	10c22004 	addi	r3,r2,2176
8110d3d8:	e0bff917 	ldw	r2,-28(fp)
8110d3dc:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d3e0:	e0bff917 	ldw	r2,-28(fp)
8110d3e4:	10800117 	ldw	r2,4(r2)
8110d3e8:	10c00404 	addi	r3,r2,16
8110d3ec:	e0bff917 	ldw	r2,-28(fp)
8110d3f0:	10c00115 	stw	r3,4(r2)
	                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d3f4:	e0fff803 	ldbu	r3,-32(fp)
8110d3f8:	00a045b4 	movhi	r2,33046
8110d3fc:	10bc4804 	addi	r2,r2,-3808
8110d400:	180690fa 	slli	r3,r3,3
8110d404:	10c5883a 	add	r2,r2,r3
8110d408:	10800017 	ldw	r2,0(r2)
8110d40c:	1009883a 	mov	r4,r2
8110d410:	113908c0 	call	8113908c <OSMutexPost>
	                        pxNFee->xControl.bDMALocked = FALSE;
8110d414:	d0a05217 	ldw	r2,-32440(gp)
8110d418:	10002215 	stw	zero,136(r2)
8110d41c:	00003e06 	br	8110d518 <vFeeTask+0xa54>
						} else {
							/* Initializing the addr */
	                    	xCcdMapLocal->ulBlockI = 0;
8110d420:	e0bff917 	ldw	r2,-28(fp)
8110d424:	10000115 	stw	zero,4(r2)
							xCcdMapLocal->ulAddrI = xCcdMapLocal->ulOffsetAddr;
8110d428:	e0bff917 	ldw	r2,-28(fp)
8110d42c:	10c00017 	ldw	r3,0(r2)
8110d430:	e0bff917 	ldw	r2,-28(fp)
8110d434:	10c00215 	stw	r3,8(r2)
							bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d438:	e0bff917 	ldw	r2,-28(fp)
8110d43c:	10800217 	ldw	r2,8(r2)
8110d440:	1009883a 	mov	r4,r2
8110d444:	d0a05217 	ldw	r2,-32440(gp)
8110d448:	10802e17 	ldw	r2,184(r2)
8110d44c:	10c03fcc 	andi	r3,r2,255
8110d450:	d0a05217 	ldw	r2,-32440(gp)
8110d454:	10800003 	ldbu	r2,0(r2)
8110d458:	10803fcc 	andi	r2,r2,255
8110d45c:	100f883a 	mov	r7,r2
8110d460:	180d883a 	mov	r6,r3
8110d464:	01400404 	movi	r5,16
8110d468:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d46c:	e0bff917 	ldw	r2,-28(fp)
8110d470:	10800217 	ldw	r2,8(r2)
8110d474:	10c22004 	addi	r3,r2,2176
8110d478:	e0bff917 	ldw	r2,-28(fp)
8110d47c:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d480:	e0bff917 	ldw	r2,-28(fp)
8110d484:	10800117 	ldw	r2,4(r2)
8110d488:	10c00404 	addi	r3,r2,16
8110d48c:	e0bff917 	ldw	r2,-28(fp)
8110d490:	10c00115 	stw	r3,4(r2)
							bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d494:	e0bff917 	ldw	r2,-28(fp)
8110d498:	10800217 	ldw	r2,8(r2)
8110d49c:	1009883a 	mov	r4,r2
8110d4a0:	d0a05217 	ldw	r2,-32440(gp)
8110d4a4:	10802e17 	ldw	r2,184(r2)
8110d4a8:	10c03fcc 	andi	r3,r2,255
8110d4ac:	d0a05217 	ldw	r2,-32440(gp)
8110d4b0:	10800003 	ldbu	r2,0(r2)
8110d4b4:	10803fcc 	andi	r2,r2,255
8110d4b8:	100f883a 	mov	r7,r2
8110d4bc:	180d883a 	mov	r6,r3
8110d4c0:	01400404 	movi	r5,16
8110d4c4:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
							//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
							xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d4c8:	e0bff917 	ldw	r2,-28(fp)
8110d4cc:	10800217 	ldw	r2,8(r2)
8110d4d0:	10c22004 	addi	r3,r2,2176
8110d4d4:	e0bff917 	ldw	r2,-28(fp)
8110d4d8:	10c00215 	stw	r3,8(r2)
							xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d4dc:	e0bff917 	ldw	r2,-28(fp)
8110d4e0:	10800117 	ldw	r2,4(r2)
8110d4e4:	10c00404 	addi	r3,r2,16
8110d4e8:	e0bff917 	ldw	r2,-28(fp)
8110d4ec:	10c00115 	stw	r3,4(r2)
	                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d4f0:	e0fff803 	ldbu	r3,-32(fp)
8110d4f4:	00a045b4 	movhi	r2,33046
8110d4f8:	10bc4804 	addi	r2,r2,-3808
8110d4fc:	180690fa 	slli	r3,r3,3
8110d500:	10c5883a 	add	r2,r2,r3
8110d504:	10800017 	ldw	r2,0(r2)
8110d508:	1009883a 	mov	r4,r2
8110d50c:	113908c0 	call	8113908c <OSMutexPost>
	                        pxNFee->xControl.bDMALocked = FALSE;
8110d510:	d0a05217 	ldw	r2,-32440(gp)
8110d514:	10002215 	stw	zero,136(r2)
						}

						incrementador = 2; // remover !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
8110d518:	00800084 	movi	r2,2
8110d51c:	d0a05315 	stw	r2,-32436(gp)

#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  MANDOU OS COMANDOS VIA DMA\n ");
8110d520:	d0a05e17 	ldw	r2,-32392(gp)
8110d524:	100f883a 	mov	r7,r2
8110d528:	01800a04 	movi	r6,40
8110d52c:	01400044 	movi	r5,1
8110d530:	01204574 	movhi	r4,33045
8110d534:	2121f404 	addi	r4,r4,-30768
8110d538:	111d0b40 	call	8111d0b4 <fwrite>
#endif

	                        /* Send message telling to controller that is not using the DMA any more */
							bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d53c:	d0a05217 	ldw	r2,-32440(gp)
8110d540:	10800003 	ldbu	r2,0(r2)
8110d544:	10803fcc 	andi	r2,r2,255
8110d548:	100d883a 	mov	r6,r2
8110d54c:	000b883a 	mov	r5,zero
8110d550:	01002044 	movi	r4,129
8110d554:	110e8300 	call	8110e830 <bSendGiveBackNFeeCtrl>
#ifdef DEBUG_ON
	fprintf(fp,"\nFEE TASK:  MSG PARA CONTROLER DEVOLVENDO DMA\n ");
8110d558:	d0a05e17 	ldw	r2,-32392(gp)
8110d55c:	100f883a 	mov	r7,r2
8110d560:	01800bc4 	movi	r6,47
8110d564:	01400044 	movi	r5,1
8110d568:	01204574 	movhi	r4,33045
8110d56c:	2121ff04 	addi	r4,r4,-30724
8110d570:	111d0b40 	call	8111d0b4 <fwrite>
8110d574:	00000f06 	br	8110d5b4 <vFeeTask+0xaf0>
#endif


	                    }
					} else {
						vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110d578:	d0a05217 	ldw	r2,-32440(gp)
8110d57c:	e0fffe17 	ldw	r3,-8(fp)
8110d580:	180b883a 	mov	r5,r3
8110d584:	1009883a 	mov	r4,r2
8110d588:	110dd080 	call	8110dd08 <vQCmdFEEinFullPattern>
8110d58c:	00000906 	br	8110d5b4 <vFeeTask+0xaf0>
					}
				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d590:	d0e05e17 	ldw	r3,-32392(gp)
8110d594:	d0a05217 	ldw	r2,-32440(gp)
8110d598:	10800003 	ldbu	r2,0(r2)
8110d59c:	10803fcc 	andi	r2,r2,255
8110d5a0:	100d883a 	mov	r6,r2
8110d5a4:	01604574 	movhi	r5,33045
8110d5a8:	29618a04 	addi	r5,r5,-31192
8110d5ac:	1809883a 	mov	r4,r3
8110d5b0:	111ca180 	call	8111ca18 <fprintf>
					#endif
				}

				if (pxNFee->xControl.bWatingSync==TRUE) {
8110d5b4:	d0a05217 	ldw	r2,-32440(gp)
8110d5b8:	10802817 	ldw	r2,160(r2)
8110d5bc:	10800058 	cmpnei	r2,r2,1
8110d5c0:	1000071e 	bne	r2,zero,8110d5e0 <vFeeTask+0xb1c>
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110d5c4:	d0a05217 	ldw	r2,-32440(gp)
8110d5c8:	00c001c4 	movi	r3,7
8110d5cc:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sFeeWaitingSync;
8110d5d0:	d0a05217 	ldw	r2,-32440(gp)
8110d5d4:	00c002c4 	movi	r3,11
8110d5d8:	10c02c15 	stw	r3,176(r2)
					pxNFee->xControl.eMode = sToTestFullPattern;
				}



				break;
8110d5dc:	0000ee06 	br	8110d998 <vFeeTask+0xed4>

				if (pxNFee->xControl.bWatingSync==TRUE) {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
					pxNFee->xControl.eMode = sFeeWaitingSync;
				} else {
					pxNFee->xControl.eNextMode = sToTestFullPattern;
8110d5e0:	d0a05217 	ldw	r2,-32440(gp)
8110d5e4:	00c001c4 	movi	r3,7
8110d5e8:	10c02d15 	stw	r3,180(r2)
					pxNFee->xControl.eMode = sToTestFullPattern;
8110d5ec:	d0a05217 	ldw	r2,-32440(gp)
8110d5f0:	00c001c4 	movi	r3,7
8110d5f4:	10c02c15 	stw	r3,176(r2)
				}



				break;
8110d5f8:	0000e706 	br	8110d998 <vFeeTask+0xed4>


			case sToTestFullPattern: /* Transition */
				/* Write in the RMAP - UCL- NFEE ICD p. 49*/
				bRmapGetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d5fc:	d0a05217 	ldw	r2,-32440(gp)
8110d600:	10804204 	addi	r2,r2,264
8110d604:	1009883a 	mov	r4,r2
8110d608:	11075600 	call	81107560 <bRmapGetMemConfigArea>
				pxNFee->xChannel.xRmap.xRmapMemConfigArea.uliCurrentMode = 0x02; /*Pattern Full Image*/
8110d60c:	d0a05217 	ldw	r2,-32440(gp)
8110d610:	00c00084 	movi	r3,2
8110d614:	10c06515 	stw	r3,404(r2)
				bRmapSetMemConfigArea(&pxNFee->xChannel.xRmap);
8110d618:	d0a05217 	ldw	r2,-32440(gp)
8110d61c:	10804204 	addi	r2,r2,264
8110d620:	1009883a 	mov	r4,r2
8110d624:	11072740 	call	81107274 <bRmapSetMemConfigArea>
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE-%hu Task: Full Image Pattern Mode\n", pxNFee->ucId);
8110d628:	d0e05e17 	ldw	r3,-32392(gp)
8110d62c:	d0a05217 	ldw	r2,-32440(gp)
8110d630:	10800003 	ldbu	r2,0(r2)
8110d634:	10803fcc 	andi	r2,r2,255
8110d638:	100d883a 	mov	r6,r2
8110d63c:	01604574 	movhi	r5,33045
8110d640:	29620b04 	addi	r5,r5,-30676
8110d644:	1809883a 	mov	r4,r3
8110d648:	111ca180 	call	8111ca18 <fprintf>
				#endif

				pxNFee->xControl.bUsingDMA = TRUE;
8110d64c:	d0a05217 	ldw	r2,-32440(gp)
8110d650:	00c00044 	movi	r3,1
8110d654:	10c02315 	stw	r3,140(r2)
				//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
				pxNFee->xControl.eMode = sFeeTestFullPattern;
8110d658:	d0a05217 	ldw	r2,-32440(gp)
8110d65c:	00c00104 	movi	r3,4
8110d660:	10c02c15 	stw	r3,176(r2)


				break;
8110d664:	0000cc06 	br	8110d998 <vFeeTask+0xed4>

#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  sFeeTestFullPattern\n ");
#endif

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xFeeQ[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d668:	d0a05217 	ldw	r2,-32440(gp)
8110d66c:	10800003 	ldbu	r2,0(r2)
8110d670:	10803fcc 	andi	r2,r2,255
8110d674:	1085883a 	add	r2,r2,r2
8110d678:	1087883a 	add	r3,r2,r2
8110d67c:	d0a06604 	addi	r2,gp,-32360
8110d680:	1885883a 	add	r2,r3,r2
8110d684:	10800017 	ldw	r2,0(r2)
8110d688:	e0fffd04 	addi	r3,fp,-12
8110d68c:	180d883a 	mov	r6,r3
8110d690:	000b883a 	mov	r5,zero
8110d694:	1009883a 	mov	r4,r2
8110d698:	1139bfc0 	call	81139bfc <OSQPend>
8110d69c:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code == OS_ERR_NONE ) {
8110d6a0:	e0bffd03 	ldbu	r2,-12(fp)
8110d6a4:	10803fcc 	andi	r2,r2,255
8110d6a8:	1000801e 	bne	r2,zero,8110d8ac <vFeeTask+0xde8>
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  RECEBEU COMANDO\n ");
#endif

					/* First Check if is access to the DMA (priority) */
						if ( uiCmdFEE.ucByte[2] == M_FEE_DMA_ACCESS ) {
8110d6ac:	e0bffe83 	ldbu	r2,-6(fp)
8110d6b0:	10803fcc 	andi	r2,r2,255
8110d6b4:	108023d8 	cmpnei	r2,r2,143
8110d6b8:	1000761e 	bne	r2,zero,8110d894 <vFeeTask+0xdd0>
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  ERA ACESSO AO DMA\n ");
#endif

							/* Try to get the Mutex */
		                    OSMutexPend(xDma[ucMemUsing].xMutexDMA, 0, &error_code); /* Blocking way */
8110d6bc:	e0fff803 	ldbu	r3,-32(fp)
8110d6c0:	00a045b4 	movhi	r2,33046
8110d6c4:	10bc4804 	addi	r2,r2,-3808
8110d6c8:	180690fa 	slli	r3,r3,3
8110d6cc:	10c5883a 	add	r2,r2,r3
8110d6d0:	10800017 	ldw	r2,0(r2)
8110d6d4:	e0fffd04 	addi	r3,fp,-12
8110d6d8:	180d883a 	mov	r6,r3
8110d6dc:	000b883a 	mov	r5,zero
8110d6e0:	1009883a 	mov	r4,r2
8110d6e4:	1138ae80 	call	81138ae8 <OSMutexPend>
		                    if ( error_code == OS_ERR_NONE ) {
8110d6e8:	e0bffd03 	ldbu	r2,-12(fp)
8110d6ec:	10803fcc 	andi	r2,r2,255
8110d6f0:	1000a81e 	bne	r2,zero,8110d994 <vFeeTask+0xed0>
		                    	pxNFee->xControl.bDMALocked = TRUE;
8110d6f4:	d0a05217 	ldw	r2,-32440(gp)
8110d6f8:	00c00044 	movi	r3,1
8110d6fc:	10c02215 	stw	r3,136(r2)
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  PEGOU MUTEX DO DMA\n ");
#endif

		                    	/* Is this the last block? */
		                    	if ( (xCcdMapLocal->ulBlockI+SDMA_MAX_BLOCKS) >= pxNFee->xMemMap.xCommon.usiNTotalBlocks ) {
8110d700:	e0bff917 	ldw	r2,-28(fp)
8110d704:	10800117 	ldw	r2,4(r2)
8110d708:	10c00404 	addi	r3,r2,16
8110d70c:	d0a05217 	ldw	r2,-32440(gp)
8110d710:	10800417 	ldw	r2,16(r2)
8110d714:	18801936 	bltu	r3,r2,8110d77c <vFeeTask+0xcb8>

		                    		/* todo: Configurar o tamanho do buffer para um numero menor = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI */
		                    		/* todo: Nao esquece  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		                    		usiLengthBlocks = pxNFee->xMemMap.xCommon.usiNTotalBlocks - xCcdMapLocal->ulBlockI;
8110d718:	d0a05217 	ldw	r2,-32440(gp)
8110d71c:	10800417 	ldw	r2,16(r2)
8110d720:	1007883a 	mov	r3,r2
8110d724:	e0bff917 	ldw	r2,-28(fp)
8110d728:	10800117 	ldw	r2,4(r2)
8110d72c:	1885c83a 	sub	r2,r3,r2
8110d730:	e0bffc8d 	sth	r2,-14(fp)
		                    		pxNFee->xControl.bWatingSync = TRUE;
8110d734:	d0a05217 	ldw	r2,-32440(gp)
8110d738:	00c00044 	movi	r3,1
8110d73c:	10c02815 	stw	r3,160(r2)
		                    		pxNFee->xControl.eMode = sSIMTestFullPattern;
8110d740:	d0a05217 	ldw	r2,-32440(gp)
8110d744:	00c00284 	movi	r3,10
8110d748:	10c02c15 	stw	r3,176(r2)
		                    		pxNFee->xControl.eNextMode = sSIMTestFullPattern;
8110d74c:	d0a05217 	ldw	r2,-32440(gp)
8110d750:	00c00284 	movi	r3,10
8110d754:	10c02d15 	stw	r3,180(r2)
		                    		pxNFee->xControl.bUsingDMA = FALSE;
8110d758:	d0a05217 	ldw	r2,-32440(gp)
8110d75c:	10002315 	stw	zero,140(r2)
		                    		pxNFee->xControl.eMode = sToFeeStandBy; /* todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
8110d760:	d0a05217 	ldw	r2,-32440(gp)
8110d764:	00c00184 	movi	r3,6
8110d768:	10c02c15 	stw	r3,176(r2)
		                    		pxNFee->xControl.eNextMode = sToFeeStandBy; /* todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
8110d76c:	d0a05217 	ldw	r2,-32440(gp)
8110d770:	00c00184 	movi	r3,6
8110d774:	10c02d15 	stw	r3,180(r2)
8110d778:	00000206 	br	8110d784 <vFeeTask+0xcc0>
		                    	} else {
		                    		usiLengthBlocks = SDMA_MAX_BLOCKS;
8110d77c:	00800404 	movi	r2,16
8110d780:	e0bffc8d 	sth	r2,-14(fp)
		                    		//bSendRequestNFeeCtrl( M_NFC_DMA_REQUEST, 0, pxNFee->ucId); /*todo:REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
		                    	}

		                    	if ( ucMemUsing == 0  ) {
8110d784:	e0bff803 	ldbu	r2,-32(fp)
8110d788:	10000e1e 	bne	r2,zero,8110d7c4 <vFeeTask+0xd00>

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bSdmaDmaM1Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d78c:	e0bff917 	ldw	r2,-28(fp)
8110d790:	10800217 	ldw	r2,8(r2)
8110d794:	1009883a 	mov	r4,r2
8110d798:	d0a05217 	ldw	r2,-32440(gp)
8110d79c:	10802e17 	ldw	r2,184(r2)
8110d7a0:	10c03fcc 	andi	r3,r2,255
8110d7a4:	d0a05217 	ldw	r2,-32440(gp)
8110d7a8:	10800003 	ldbu	r2,0(r2)
8110d7ac:	10803fcc 	andi	r2,r2,255
8110d7b0:	100f883a 	mov	r7,r2
8110d7b4:	180d883a 	mov	r6,r3
8110d7b8:	01400404 	movi	r5,16
8110d7bc:	1103c900 	call	81103c90 <bSdmaDmaM1Transfer>
8110d7c0:	00000d06 	br	8110d7f8 <vFeeTask+0xd34>
		                    	} else {

		                    		//(*xDma[ucMemUsing].pDmaTranfer)( xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId );
		                    		bSdmaDmaM2Transfer(xCcdMapLocal->ulAddrI,SDMA_MAX_BLOCKS, pxNFee->xControl.eSide, pxNFee->ucId);
8110d7c4:	e0bff917 	ldw	r2,-28(fp)
8110d7c8:	10800217 	ldw	r2,8(r2)
8110d7cc:	1009883a 	mov	r4,r2
8110d7d0:	d0a05217 	ldw	r2,-32440(gp)
8110d7d4:	10802e17 	ldw	r2,184(r2)
8110d7d8:	10c03fcc 	andi	r3,r2,255
8110d7dc:	d0a05217 	ldw	r2,-32440(gp)
8110d7e0:	10800003 	ldbu	r2,0(r2)
8110d7e4:	10803fcc 	andi	r2,r2,255
8110d7e8:	100f883a 	mov	r7,r2
8110d7ec:	180d883a 	mov	r6,r3
8110d7f0:	01400404 	movi	r5,16
8110d7f4:	110409c0 	call	8110409c <bSdmaDmaM2Transfer>
		                    	}


								/* Value of xCcdMapLocal->ulAddrI already set in the last iteration */

								xCcdMapLocal->ulAddrI += SDMA_BUFFER_SIZE_BYTES;
8110d7f8:	e0bff917 	ldw	r2,-28(fp)
8110d7fc:	10800217 	ldw	r2,8(r2)
8110d800:	10c22004 	addi	r3,r2,2176
8110d804:	e0bff917 	ldw	r2,-28(fp)
8110d808:	10c00215 	stw	r3,8(r2)
								xCcdMapLocal->ulBlockI += SDMA_MAX_BLOCKS;
8110d80c:	e0bff917 	ldw	r2,-28(fp)
8110d810:	10800117 	ldw	r2,4(r2)
8110d814:	10c00404 	addi	r3,r2,16
8110d818:	e0bff917 	ldw	r2,-28(fp)
8110d81c:	10c00115 	stw	r3,4(r2)
		                        OSMutexPost(xDma[ucMemUsing].xMutexDMA);
8110d820:	e0fff803 	ldbu	r3,-32(fp)
8110d824:	00a045b4 	movhi	r2,33046
8110d828:	10bc4804 	addi	r2,r2,-3808
8110d82c:	180690fa 	slli	r3,r3,3
8110d830:	10c5883a 	add	r2,r2,r3
8110d834:	10800017 	ldw	r2,0(r2)
8110d838:	1009883a 	mov	r4,r2
8110d83c:	113908c0 	call	8113908c <OSMutexPost>
		                        pxNFee->xControl.bDMALocked = FALSE;
8110d840:	d0a05217 	ldw	r2,-32440(gp)
8110d844:	10002215 	stw	zero,136(r2)
		                        //bDisAndClrDbBuffer(&pxNFee->xChannel.xFeeBuffer);

		                        incrementador++; // remover !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
8110d848:	d0a05317 	ldw	r2,-32436(gp)
8110d84c:	10800044 	addi	r2,r2,1
8110d850:	d0a05315 	stw	r2,-32436(gp)
#ifdef DEBUG_ON
	//fprintf(fp,"\nFEE TASK:  ENVIOU DADOS AO DMA\n ");
#endif
		                        /* Send message talling to controller that is not using the DMA any more */
								bSendGiveBackNFeeCtrl( M_NFC_DMA_GIVEBACK, 0, pxNFee->ucId);
8110d854:	d0a05217 	ldw	r2,-32440(gp)
8110d858:	10800003 	ldbu	r2,0(r2)
8110d85c:	10803fcc 	andi	r2,r2,255
8110d860:	100d883a 	mov	r6,r2
8110d864:	000b883a 	mov	r5,zero
8110d868:	01002044 	movi	r4,129
8110d86c:	110e8300 	call	8110e830 <bSendGiveBackNFeeCtrl>
	//fprintf(fp,"\nFEE TASK:  DEVOLVEU AO CONTROLLER\n ");
#endif

#ifdef DEBUG_ON
	//fprintf(fp,"\n    i: %u ",incrementador);
	fprintf(fp,"\nbs: %u ",xCcdMapLocal->ulBlockI);
8110d870:	d0e05e17 	ldw	r3,-32392(gp)
8110d874:	e0bff917 	ldw	r2,-28(fp)
8110d878:	10800117 	ldw	r2,4(r2)
8110d87c:	100d883a 	mov	r6,r2
8110d880:	01604574 	movhi	r5,33045
8110d884:	29621504 	addi	r5,r5,-30636
8110d888:	1809883a 	mov	r4,r3
8110d88c:	111ca180 	call	8111ca18 <fprintf>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d890:	00004006 	br	8110d994 <vFeeTask+0xed0>
#endif


                   }
						} else {
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
8110d894:	d0a05217 	ldw	r2,-32440(gp)
8110d898:	e0fffe17 	ldw	r3,-8(fp)
8110d89c:	180b883a 	mov	r5,r3
8110d8a0:	1009883a 	mov	r4,r2
8110d8a4:	110dd080 	call	8110dd08 <vQCmdFEEinFullPattern>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d8a8:	00003a06 	br	8110d994 <vFeeTask+0xed0>
							vQCmdFEEinFullPattern( pxNFee, uiCmdFEE.ulWord );
						}

				} else {
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
8110d8ac:	d0e05e17 	ldw	r3,-32392(gp)
8110d8b0:	d0a05217 	ldw	r2,-32440(gp)
8110d8b4:	10800003 	ldbu	r2,0(r2)
8110d8b8:	10803fcc 	andi	r2,r2,255
8110d8bc:	100d883a 	mov	r6,r2
8110d8c0:	01604574 	movhi	r5,33045
8110d8c4:	29618a04 	addi	r5,r5,-31192
8110d8c8:	1809883a 	mov	r4,r3
8110d8cc:	111ca180 	call	8111ca18 <fprintf>
					#endif
				}

				break;
8110d8d0:	00003006 	br	8110d994 <vFeeTask+0xed0>

			case sFeeWaitingSync:

				pxNFee->xControl.eMode = pxNFee->xControl.eNextMode;
8110d8d4:	d0a05217 	ldw	r2,-32440(gp)
8110d8d8:	d0e05217 	ldw	r3,-32440(gp)
8110d8dc:	18c02d17 	ldw	r3,180(r3)
8110d8e0:	10c02c15 	stw	r3,176(r2)

				uiCmdFEE.ulWord = (unsigned int)OSQPend(xWaitSyncQFee[ pxNFee->ucId ] , 0, &error_code); /* Blocking operation */
8110d8e4:	d0a05217 	ldw	r2,-32440(gp)
8110d8e8:	10800003 	ldbu	r2,0(r2)
8110d8ec:	10803fcc 	andi	r2,r2,255
8110d8f0:	1085883a 	add	r2,r2,r2
8110d8f4:	1087883a 	add	r3,r2,r2
8110d8f8:	d0a05804 	addi	r2,gp,-32416
8110d8fc:	1885883a 	add	r2,r3,r2
8110d900:	10800017 	ldw	r2,0(r2)
8110d904:	e0fffd04 	addi	r3,fp,-12
8110d908:	180d883a 	mov	r6,r3
8110d90c:	000b883a 	mov	r5,zero
8110d910:	1009883a 	mov	r4,r2
8110d914:	1139bfc0 	call	81139bfc <OSQPend>
8110d918:	e0bffe15 	stw	r2,-8(fp)
				if ( error_code != OS_ERR_NONE ) {
8110d91c:	e0bffd03 	ldbu	r2,-12(fp)
8110d920:	10803fcc 	andi	r2,r2,255
8110d924:	10000926 	beq	r2,zero,8110d94c <vFeeTask+0xe88>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xWaitSyncQFee\n", pxNFee->ucId);
8110d928:	d0e05e17 	ldw	r3,-32392(gp)
8110d92c:	d0a05217 	ldw	r2,-32440(gp)
8110d930:	10800003 	ldbu	r2,0(r2)
8110d934:	10803fcc 	andi	r2,r2,255
8110d938:	100d883a 	mov	r6,r2
8110d93c:	01604574 	movhi	r5,33045
8110d940:	29621804 	addi	r5,r5,-30624
8110d944:	1809883a 	mov	r4,r3
8110d948:	111ca180 	call	8111ca18 <fprintf>
					#endif
				}

				pxNFee->xControl.bWatingSync = FALSE;
8110d94c:	d0a05217 	ldw	r2,-32440(gp)
8110d950:	10002815 	stw	zero,160(r2)
				break;
8110d954:	00001006 	br	8110d998 <vFeeTask+0xed4>
			default:
				pxNFee->xControl.eMode = sToFeeConfig;
8110d958:	d0a05217 	ldw	r2,-32440(gp)
8110d95c:	00c00144 	movi	r3,5
8110d960:	10c02c15 	stw	r3,176(r2)
				#ifdef DEBUG_ON
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
8110d964:	d0e05e17 	ldw	r3,-32392(gp)
8110d968:	d0a05217 	ldw	r2,-32440(gp)
8110d96c:	10800003 	ldbu	r2,0(r2)
8110d970:	10803fcc 	andi	r2,r2,255
8110d974:	100d883a 	mov	r6,r2
8110d978:	01604574 	movhi	r5,33045
8110d97c:	29622604 	addi	r5,r5,-30568
8110d980:	1809883a 	mov	r4,r3
8110d984:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110d988:	00000306 	br	8110d998 <vFeeTask+0xed4>
				break;
			case sSIMFeeStandBy:

				//pxNFee->xControl.eMode = sToFeeConfig;

				break;
8110d98c:	0001883a 	nop
8110d990:	003c6206 	br	8110cb1c <__reset+0xfb0ecb1c>
					#ifdef DEBUG_ON
						fprintf(fp,"NFEE-%hu Task: Can't get cmd from Queue xFeeQ\n", pxNFee->ucId);
					#endif
				}

				break;
8110d994:	0001883a 	nop
					fprintf(fp,"\nNFEE %hhu Task: Unexpected mode (default)\n", pxNFee->ucId);
				#endif
				break;
		}

	}
8110d998:	003c6006 	br	8110cb1c <__reset+0xfb0ecb1c>

8110d99c <vQCmdFEEinConfig>:

}


void vQCmdFEEinConfig( TNFee *pxNFeeP, unsigned int cmd ) {
8110d99c:	defffb04 	addi	sp,sp,-20
8110d9a0:	de00012e 	bgeu	sp,et,8110d9a8 <vQCmdFEEinConfig+0xc>
8110d9a4:	003b68fa 	trap	3
8110d9a8:	dfc00415 	stw	ra,16(sp)
8110d9ac:	df000315 	stw	fp,12(sp)
8110d9b0:	df000304 	addi	fp,sp,12
8110d9b4:	e13ffe15 	stw	r4,-8(fp)
8110d9b8:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110d9bc:	e0bfff17 	ldw	r2,-4(fp)
8110d9c0:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110d9c4:	e0bffdc3 	ldbu	r2,-9(fp)
8110d9c8:	10c03fcc 	andi	r3,r2,255
8110d9cc:	e0bffe17 	ldw	r2,-8(fp)
8110d9d0:	10800003 	ldbu	r2,0(r2)
8110d9d4:	10803fcc 	andi	r2,r2,255
8110d9d8:	10800444 	addi	r2,r2,17
8110d9dc:	1880551e 	bne	r3,r2,8110db34 <vQCmdFEEinConfig+0x198>

		switch (uiCmdFEEL.ucByte[2]) {
8110d9e0:	e0bffd83 	ldbu	r2,-10(fp)
8110d9e4:	10803fcc 	andi	r2,r2,255
8110d9e8:	10c00220 	cmpeqi	r3,r2,8
8110d9ec:	1800321e 	bne	r3,zero,8110dab8 <vQCmdFEEinConfig+0x11c>
8110d9f0:	10c00248 	cmpgei	r3,r2,9
8110d9f4:	1800071e 	bne	r3,zero,8110da14 <vQCmdFEEinConfig+0x78>
8110d9f8:	10c000a0 	cmpeqi	r3,r2,2
8110d9fc:	18004c1e 	bne	r3,zero,8110db30 <vQCmdFEEinConfig+0x194>
8110da00:	10c00120 	cmpeqi	r3,r2,4
8110da04:	1800191e 	bne	r3,zero,8110da6c <vQCmdFEEinConfig+0xd0>
8110da08:	10800060 	cmpeqi	r2,r2,1
8110da0c:	10000d1e 	bne	r2,zero,8110da44 <vQCmdFEEinConfig+0xa8>
8110da10:	00003d06 	br	8110db08 <vQCmdFEEinConfig+0x16c>
8110da14:	10c02920 	cmpeqi	r3,r2,164
8110da18:	18001e1e 	bne	r3,zero,8110da94 <vQCmdFEEinConfig+0xf8>
8110da1c:	10c02948 	cmpgei	r3,r2,165
8110da20:	1800031e 	bne	r3,zero,8110da30 <vQCmdFEEinConfig+0x94>
8110da24:	10802860 	cmpeqi	r2,r2,161
8110da28:	1000061e 	bne	r2,zero,8110da44 <vQCmdFEEinConfig+0xa8>
8110da2c:	00003606 	br	8110db08 <vQCmdFEEinConfig+0x16c>
8110da30:	10c02a20 	cmpeqi	r3,r2,168
8110da34:	1800201e 	bne	r3,zero,8110dab8 <vQCmdFEEinConfig+0x11c>
8110da38:	10803c20 	cmpeqi	r2,r2,240
8110da3c:	1000281e 	bne	r2,zero,8110dae0 <vQCmdFEEinConfig+0x144>
8110da40:	00003106 	br	8110db08 <vQCmdFEEinConfig+0x16c>
			case M_FEE_CONFIG_FORCED:
			case M_FEE_CONFIG:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Config mode\n", pxNFeeP->ucId);
8110da44:	d0e05e17 	ldw	r3,-32392(gp)
8110da48:	e0bffe17 	ldw	r2,-8(fp)
8110da4c:	10800003 	ldbu	r2,0(r2)
8110da50:	10803fcc 	andi	r2,r2,255
8110da54:	100d883a 	mov	r6,r2
8110da58:	01604574 	movhi	r5,33045
8110da5c:	29623104 	addi	r5,r5,-30524
8110da60:	1809883a 	mov	r4,r3
8110da64:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110da68:	00003206 	br	8110db34 <vQCmdFEEinConfig+0x198>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110da6c:	e0bffe17 	ldw	r2,-8(fp)
8110da70:	00c00044 	movi	r3,1
8110da74:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110da78:	e0bffe17 	ldw	r2,-8(fp)
8110da7c:	00c002c4 	movi	r3,11
8110da80:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110da84:	e0bffe17 	ldw	r2,-8(fp)
8110da88:	00c00184 	movi	r3,6
8110da8c:	10c02d15 	stw	r3,180(r2)
				break;
8110da90:	00002806 	br	8110db34 <vQCmdFEEinConfig+0x198>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110da94:	e0bffe17 	ldw	r2,-8(fp)
8110da98:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110da9c:	e0bffe17 	ldw	r2,-8(fp)
8110daa0:	00c00184 	movi	r3,6
8110daa4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy;
8110daa8:	e0bffe17 	ldw	r2,-8(fp)
8110daac:	00c00184 	movi	r3,6
8110dab0:	10c02d15 	stw	r3,180(r2)
				break;				
8110dab4:	00001f06 	br	8110db34 <vQCmdFEEinConfig+0x198>
			case M_FEE_FULL_PATTERN_FORCED:
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Can't go to Full Image Pattern from Config mode\n", pxNFeeP->ucId);
8110dab8:	d0e05e17 	ldw	r3,-32392(gp)
8110dabc:	e0bffe17 	ldw	r2,-8(fp)
8110dac0:	10800003 	ldbu	r2,0(r2)
8110dac4:	10803fcc 	andi	r2,r2,255
8110dac8:	100d883a 	mov	r6,r2
8110dacc:	01604574 	movhi	r5,33045
8110dad0:	29623c04 	addi	r5,r5,-30480
8110dad4:	1809883a 	mov	r4,r3
8110dad8:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110dadc:	00001506 	br	8110db34 <vQCmdFEEinConfig+0x198>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: Shouldn't receive RMAP Messages in this mode (Config Mode)\n", pxNFeeP->ucId);
8110dae0:	d0e05e17 	ldw	r3,-32392(gp)
8110dae4:	e0bffe17 	ldw	r2,-8(fp)
8110dae8:	10800003 	ldbu	r2,0(r2)
8110daec:	10803fcc 	andi	r2,r2,255
8110daf0:	100d883a 	mov	r6,r2
8110daf4:	01604574 	movhi	r5,33045
8110daf8:	29624d04 	addi	r5,r5,-30412
8110dafc:	1809883a 	mov	r4,r3
8110db00:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110db04:	00000b06 	br	8110db34 <vQCmdFEEinConfig+0x198>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110db08:	d0e05e17 	ldw	r3,-32392(gp)
8110db0c:	e0bffe17 	ldw	r2,-8(fp)
8110db10:	10800003 	ldbu	r2,0(r2)
8110db14:	10803fcc 	andi	r2,r2,255
8110db18:	100d883a 	mov	r6,r2
8110db1c:	01604574 	movhi	r5,33045
8110db20:	29626004 	addi	r5,r5,-30336
8110db24:	1809883a 	mov	r4,r3
8110db28:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110db2c:	00000106 	br	8110db34 <vQCmdFEEinConfig+0x198>
				break;
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110db30:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110db34:	0001883a 	nop
8110db38:	e037883a 	mov	sp,fp
8110db3c:	dfc00117 	ldw	ra,4(sp)
8110db40:	df000017 	ldw	fp,0(sp)
8110db44:	dec00204 	addi	sp,sp,8
8110db48:	f800283a 	ret

8110db4c <vQCmdFEEinStandBy>:

void vQCmdFEEinStandBy( TNFee *pxNFeeP, unsigned int cmd ) {
8110db4c:	defffb04 	addi	sp,sp,-20
8110db50:	de00012e 	bgeu	sp,et,8110db58 <vQCmdFEEinStandBy+0xc>
8110db54:	003b68fa 	trap	3
8110db58:	dfc00415 	stw	ra,16(sp)
8110db5c:	df000315 	stw	fp,12(sp)
8110db60:	df000304 	addi	fp,sp,12
8110db64:	e13ffe15 	stw	r4,-8(fp)
8110db68:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110db6c:	e0bfff17 	ldw	r2,-4(fp)
8110db70:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110db74:	e0bffdc3 	ldbu	r2,-9(fp)
8110db78:	10c03fcc 	andi	r3,r2,255
8110db7c:	e0bffe17 	ldw	r2,-8(fp)
8110db80:	10800003 	ldbu	r2,0(r2)
8110db84:	10803fcc 	andi	r2,r2,255
8110db88:	10800444 	addi	r2,r2,17
8110db8c:	1880581e 	bne	r3,r2,8110dcf0 <vQCmdFEEinStandBy+0x1a4>

		switch (uiCmdFEEL.ucByte[2]) {
8110db90:	e0bffd83 	ldbu	r2,-10(fp)
8110db94:	10803fcc 	andi	r2,r2,255
8110db98:	10c00220 	cmpeqi	r3,r2,8
8110db9c:	1800321e 	bne	r3,zero,8110dc68 <vQCmdFEEinStandBy+0x11c>
8110dba0:	10c00248 	cmpgei	r3,r2,9
8110dba4:	1800071e 	bne	r3,zero,8110dbc4 <vQCmdFEEinStandBy+0x78>
8110dba8:	10c000a0 	cmpeqi	r3,r2,2
8110dbac:	18004f1e 	bne	r3,zero,8110dcec <vQCmdFEEinStandBy+0x1a0>
8110dbb0:	10c00120 	cmpeqi	r3,r2,4
8110dbb4:	1800221e 	bne	r3,zero,8110dc40 <vQCmdFEEinStandBy+0xf4>
8110dbb8:	10800060 	cmpeqi	r2,r2,1
8110dbbc:	10000d1e 	bne	r2,zero,8110dbf4 <vQCmdFEEinStandBy+0xa8>
8110dbc0:	00004006 	br	8110dcc4 <vQCmdFEEinStandBy+0x178>
8110dbc4:	10c02920 	cmpeqi	r3,r2,164
8110dbc8:	18001d1e 	bne	r3,zero,8110dc40 <vQCmdFEEinStandBy+0xf4>
8110dbcc:	10c02948 	cmpgei	r3,r2,165
8110dbd0:	1800031e 	bne	r3,zero,8110dbe0 <vQCmdFEEinStandBy+0x94>
8110dbd4:	10802860 	cmpeqi	r2,r2,161
8110dbd8:	1000101e 	bne	r2,zero,8110dc1c <vQCmdFEEinStandBy+0xd0>
8110dbdc:	00003906 	br	8110dcc4 <vQCmdFEEinStandBy+0x178>
8110dbe0:	10c02a20 	cmpeqi	r3,r2,168
8110dbe4:	1800201e 	bne	r3,zero,8110dc68 <vQCmdFEEinStandBy+0x11c>
8110dbe8:	10803c20 	cmpeqi	r2,r2,240
8110dbec:	1000281e 	bne	r2,zero,8110dc90 <vQCmdFEEinStandBy+0x144>
8110dbf0:	00003406 	br	8110dcc4 <vQCmdFEEinStandBy+0x178>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110dbf4:	e0bffe17 	ldw	r2,-8(fp)
8110dbf8:	00c00044 	movi	r3,1
8110dbfc:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110dc00:	e0bffe17 	ldw	r2,-8(fp)
8110dc04:	00c002c4 	movi	r3,11
8110dc08:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110dc0c:	e0bffe17 	ldw	r2,-8(fp)
8110dc10:	00c00144 	movi	r3,5
8110dc14:	10c02d15 	stw	r3,180(r2)
				break;
8110dc18:	00003506 	br	8110dcf0 <vQCmdFEEinStandBy+0x1a4>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110dc1c:	e0bffe17 	ldw	r2,-8(fp)
8110dc20:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110dc24:	e0bffe17 	ldw	r2,-8(fp)
8110dc28:	00c00144 	movi	r3,5
8110dc2c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig; /* To finish the actual transfer only when sync comes */
8110dc30:	e0bffe17 	ldw	r2,-8(fp)
8110dc34:	00c00144 	movi	r3,5
8110dc38:	10c02d15 	stw	r3,180(r2)
				break;				
8110dc3c:	00002c06 	br	8110dcf0 <vQCmdFEEinStandBy+0x1a4>
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY_FORCED:
			case M_FEE_STANDBY:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Stand by mode\n", pxNFeeP->ucId);
8110dc40:	d0e05e17 	ldw	r3,-32392(gp)
8110dc44:	e0bffe17 	ldw	r2,-8(fp)
8110dc48:	10800003 	ldbu	r2,0(r2)
8110dc4c:	10803fcc 	andi	r2,r2,255
8110dc50:	100d883a 	mov	r6,r2
8110dc54:	01604574 	movhi	r5,33045
8110dc58:	29627104 	addi	r5,r5,-30268
8110dc5c:	1809883a 	mov	r4,r3
8110dc60:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110dc64:	00002206 	br	8110dcf0 <vQCmdFEEinStandBy+0x1a4>
			case M_FEE_FULL_PATTERN:
			case M_FEE_FULL_PATTERN_FORCED:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110dc68:	e0bffe17 	ldw	r2,-8(fp)
8110dc6c:	00c00044 	movi	r3,1
8110dc70:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sSIMTestFullPattern; /*sSIMTestFullPattern*/
8110dc74:	e0bffe17 	ldw	r2,-8(fp)
8110dc78:	00c00284 	movi	r3,10
8110dc7c:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sSIMTestFullPattern;
8110dc80:	e0bffe17 	ldw	r2,-8(fp)
8110dc84:	00c00284 	movi	r3,10
8110dc88:	10c02d15 	stw	r3,180(r2)
				break;
8110dc8c:	00001806 	br	8110dcf0 <vQCmdFEEinStandBy+0x1a4>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110dc90:	d0e05e17 	ldw	r3,-32392(gp)
8110dc94:	e0bffe17 	ldw	r2,-8(fp)
8110dc98:	10800003 	ldbu	r2,0(r2)
8110dc9c:	10803fcc 	andi	r2,r2,255
8110dca0:	100d883a 	mov	r6,r2
8110dca4:	01604574 	movhi	r5,33045
8110dca8:	29627c04 	addi	r5,r5,-30224
8110dcac:	1809883a 	mov	r4,r3
8110dcb0:	111ca180 	call	8111ca18 <fprintf>
				#endif


				/* Perform some actions, check if is a valid command for this mode of opera  */
				vQCmdFeeRMAPinStandBy( pxNFeeP, cmd );
8110dcb4:	e17fff17 	ldw	r5,-4(fp)
8110dcb8:	e13ffe17 	ldw	r4,-8(fp)
8110dcbc:	110ded40 	call	8110ded4 <vQCmdFeeRMAPinStandBy>

				break;
8110dcc0:	00000b06 	br	8110dcf0 <vQCmdFEEinStandBy+0x1a4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
8110dcc4:	d0e05e17 	ldw	r3,-32392(gp)
8110dcc8:	e0bffe17 	ldw	r2,-8(fp)
8110dccc:	10800003 	ldbu	r2,0(r2)
8110dcd0:	10803fcc 	andi	r2,r2,255
8110dcd4:	100d883a 	mov	r6,r2
8110dcd8:	01604574 	movhi	r5,33045
8110dcdc:	29628604 	addi	r5,r5,-30184
8110dce0:	1809883a 	mov	r4,r3
8110dce4:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110dce8:	00000106 	br	8110dcf0 <vQCmdFEEinStandBy+0x1a4>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110dcec:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Config mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110dcf0:	0001883a 	nop
8110dcf4:	e037883a 	mov	sp,fp
8110dcf8:	dfc00117 	ldw	ra,4(sp)
8110dcfc:	df000017 	ldw	fp,0(sp)
8110dd00:	dec00204 	addi	sp,sp,8
8110dd04:	f800283a 	ret

8110dd08 <vQCmdFEEinFullPattern>:



void vQCmdFEEinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110dd08:	defffb04 	addi	sp,sp,-20
8110dd0c:	de00012e 	bgeu	sp,et,8110dd14 <vQCmdFEEinFullPattern+0xc>
8110dd10:	003b68fa 	trap	3
8110dd14:	dfc00415 	stw	ra,16(sp)
8110dd18:	df000315 	stw	fp,12(sp)
8110dd1c:	df000304 	addi	fp,sp,12
8110dd20:	e13ffe15 	stw	r4,-8(fp)
8110dd24:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdFEEL;

	uiCmdFEEL.ulWord = cmd;
8110dd28:	e0bfff17 	ldw	r2,-4(fp)
8110dd2c:	e0bffd15 	stw	r2,-12(fp)

	if ( (uiCmdFEEL.ucByte[3] == ( M_NFEE_BASE_ADDR + pxNFeeP->ucId)) ) {
8110dd30:	e0bffdc3 	ldbu	r2,-9(fp)
8110dd34:	10c03fcc 	andi	r3,r2,255
8110dd38:	e0bffe17 	ldw	r2,-8(fp)
8110dd3c:	10800003 	ldbu	r2,0(r2)
8110dd40:	10803fcc 	andi	r2,r2,255
8110dd44:	10800444 	addi	r2,r2,17
8110dd48:	18805c1e 	bne	r3,r2,8110debc <vQCmdFEEinFullPattern+0x1b4>

		switch (uiCmdFEEL.ucByte[2]) {
8110dd4c:	e0bffd83 	ldbu	r2,-10(fp)
8110dd50:	10803fcc 	andi	r2,r2,255
8110dd54:	10c00220 	cmpeqi	r3,r2,8
8110dd58:	1800361e 	bne	r3,zero,8110de34 <vQCmdFEEinFullPattern+0x12c>
8110dd5c:	10c00248 	cmpgei	r3,r2,9
8110dd60:	1800071e 	bne	r3,zero,8110dd80 <vQCmdFEEinFullPattern+0x78>
8110dd64:	10c000a0 	cmpeqi	r3,r2,2
8110dd68:	1800531e 	bne	r3,zero,8110deb8 <vQCmdFEEinFullPattern+0x1b0>
8110dd6c:	10c00120 	cmpeqi	r3,r2,4
8110dd70:	18001d1e 	bne	r3,zero,8110dde8 <vQCmdFEEinFullPattern+0xe0>
8110dd74:	10800060 	cmpeqi	r2,r2,1
8110dd78:	1000081e 	bne	r2,zero,8110dd9c <vQCmdFEEinFullPattern+0x94>
8110dd7c:	00004406 	br	8110de90 <vQCmdFEEinFullPattern+0x188>
8110dd80:	10c02920 	cmpeqi	r3,r2,164
8110dd84:	1800221e 	bne	r3,zero,8110de10 <vQCmdFEEinFullPattern+0x108>
8110dd88:	10c03c20 	cmpeqi	r3,r2,240
8110dd8c:	1800331e 	bne	r3,zero,8110de5c <vQCmdFEEinFullPattern+0x154>
8110dd90:	10802860 	cmpeqi	r2,r2,161
8110dd94:	10000b1e 	bne	r2,zero,8110ddc4 <vQCmdFEEinFullPattern+0xbc>
8110dd98:	00003d06 	br	8110de90 <vQCmdFEEinFullPattern+0x188>
			case M_FEE_CONFIG:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110dd9c:	e0bffe17 	ldw	r2,-8(fp)
8110dda0:	00c00044 	movi	r3,1
8110dda4:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110dda8:	e0bffe17 	ldw	r2,-8(fp)
8110ddac:	00c002c4 	movi	r3,11
8110ddb0:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ddb4:	e0bffe17 	ldw	r2,-8(fp)
8110ddb8:	00c00144 	movi	r3,5
8110ddbc:	10c02d15 	stw	r3,180(r2)
				break;
8110ddc0:	00003e06 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
			case M_FEE_CONFIG_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110ddc4:	e0bffe17 	ldw	r2,-8(fp)
8110ddc8:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeConfig;
8110ddcc:	e0bffe17 	ldw	r2,-8(fp)
8110ddd0:	00c00144 	movi	r3,5
8110ddd4:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeConfig;
8110ddd8:	e0bffe17 	ldw	r2,-8(fp)
8110dddc:	00c00144 	movi	r3,5
8110dde0:	10c02d15 	stw	r3,180(r2)
				break;				
8110dde4:	00003506 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
			case M_FEE_STANDBY:
				pxNFeeP->xControl.bWatingSync = TRUE;
8110dde8:	e0bffe17 	ldw	r2,-8(fp)
8110ddec:	00c00044 	movi	r3,1
8110ddf0:	10c02815 	stw	r3,160(r2)
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
8110ddf4:	e0bffe17 	ldw	r2,-8(fp)
8110ddf8:	00c002c4 	movi	r3,11
8110ddfc:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110de00:	e0bffe17 	ldw	r2,-8(fp)
8110de04:	00c00184 	movi	r3,6
8110de08:	10c02d15 	stw	r3,180(r2)
				break;
8110de0c:	00002b06 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
			case M_FEE_STANDBY_FORCED:
				pxNFeeP->xControl.bWatingSync = FALSE;
8110de10:	e0bffe17 	ldw	r2,-8(fp)
8110de14:	10002815 	stw	zero,160(r2)
				pxNFeeP->xControl.eMode = sToFeeStandBy;
8110de18:	e0bffe17 	ldw	r2,-8(fp)
8110de1c:	00c00184 	movi	r3,6
8110de20:	10c02c15 	stw	r3,176(r2)
				pxNFeeP->xControl.eNextMode = sToFeeStandBy; /* To finish the actual transfer only when sync comes */
8110de24:	e0bffe17 	ldw	r2,-8(fp)
8110de28:	00c00184 	movi	r3,6
8110de2c:	10c02d15 	stw	r3,180(r2)
				break;				
8110de30:	00002206 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
			case M_FEE_FULL_PATTERN:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Already in Full Image Pattern mode\n", pxNFeeP->ucId);
8110de34:	d0e05e17 	ldw	r3,-32392(gp)
8110de38:	e0bffe17 	ldw	r2,-8(fp)
8110de3c:	10800003 	ldbu	r2,0(r2)
8110de40:	10803fcc 	andi	r2,r2,255
8110de44:	100d883a 	mov	r6,r2
8110de48:	01604574 	movhi	r5,33045
8110de4c:	29629704 	addi	r5,r5,-30116
8110de50:	1809883a 	mov	r4,r3
8110de54:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110de58:	00001806 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
			case M_FEE_RMAP:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task: RMAP Message Received\n", pxNFeeP->ucId);
8110de5c:	d0e05e17 	ldw	r3,-32392(gp)
8110de60:	e0bffe17 	ldw	r2,-8(fp)
8110de64:	10800003 	ldbu	r2,0(r2)
8110de68:	10803fcc 	andi	r2,r2,255
8110de6c:	100d883a 	mov	r6,r2
8110de70:	01604574 	movhi	r5,33045
8110de74:	29627c04 	addi	r5,r5,-30224
8110de78:	1809883a 	mov	r4,r3
8110de7c:	111ca180 	call	8111ca18 <fprintf>
				#endif


				/* Perform some actions, check if is a valid command for this mode of opera  */
				vQCmdFeeRMAPinFullPattern( pxNFeeP, cmd );
8110de80:	e17fff17 	ldw	r5,-4(fp)
8110de84:	e13ffe17 	ldw	r4,-8(fp)
8110de88:	110e2800 	call	8110e280 <vQCmdFeeRMAPinFullPattern>

				break;
8110de8c:	00000b06 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
			default:
				#ifdef DEBUG_ON
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
8110de90:	d0e05e17 	ldw	r3,-32392(gp)
8110de94:	e0bffe17 	ldw	r2,-8(fp)
8110de98:	10800003 	ldbu	r2,0(r2)
8110de9c:	10803fcc 	andi	r2,r2,255
8110dea0:	100d883a 	mov	r6,r2
8110dea4:	01604574 	movhi	r5,33045
8110dea8:	29626004 	addi	r5,r5,-30336
8110deac:	1809883a 	mov	r4,r3
8110deb0:	111ca180 	call	8111ca18 <fprintf>
				#endif
				break;
8110deb4:	00000106 	br	8110debc <vQCmdFEEinFullPattern+0x1b4>
				break;				
			case M_FEE_RUN:
				/*pxNFeeP->xControl.bWatingSync = TRUE;
				pxNFeeP->xControl.eMode = sFeeWaitingSync;
				pxNFeeP->xControl.eNextMode = sFeeOn;*/
				break;
8110deb8:	0001883a 	nop
					fprintf(fp,"NFEE %hhu Task:  Unexpected command for this mode (in Confg mode)\n", pxNFeeP->ucId);
				#endif
				break;
		}
	}
}
8110debc:	0001883a 	nop
8110dec0:	e037883a 	mov	sp,fp
8110dec4:	dfc00117 	ldw	ra,4(sp)
8110dec8:	df000017 	ldw	fp,0(sp)
8110decc:	dec00204 	addi	sp,sp,8
8110ded0:	f800283a 	ret

8110ded4 <vQCmdFeeRMAPinStandBy>:



void vQCmdFeeRMAPinStandBy( TNFee *pxNFeeP, unsigned int cmd ){
8110ded4:	defff704 	addi	sp,sp,-36
8110ded8:	de00012e 	bgeu	sp,et,8110dee0 <vQCmdFeeRMAPinStandBy+0xc>
8110dedc:	003b68fa 	trap	3
8110dee0:	dfc00815 	stw	ra,32(sp)
8110dee4:	df000715 	stw	fp,28(sp)
8110dee8:	df000704 	addi	fp,sp,28
8110deec:	e13ffe15 	stw	r4,-8(fp)
8110def0:	e17fff15 	stw	r5,-4(fp)
	INT32U ucValueReg;
	INT32U ucValueMasked;
	INT32U ucValueMasked2;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received\n", pxNFeeP->ucId);
8110def4:	d0e05e17 	ldw	r3,-32392(gp)
8110def8:	e0bffe17 	ldw	r2,-8(fp)
8110defc:	10800003 	ldbu	r2,0(r2)
8110df00:	10803fcc 	andi	r2,r2,255
8110df04:	100d883a 	mov	r6,r2
8110df08:	01604574 	movhi	r5,33045
8110df0c:	2962a504 	addi	r5,r5,-30060
8110df10:	1809883a 	mov	r4,r3
8110df14:	111ca180 	call	8111ca18 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110df18:	e0bfff17 	ldw	r2,-4(fp)
8110df1c:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110df20:	e0bffd43 	ldbu	r2,-11(fp)
8110df24:	e0bff905 	stb	r2,-28(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110df28:	e0bffe17 	ldw	r2,-8(fp)
8110df2c:	10804217 	ldw	r2,264(r2)
8110df30:	e0fff903 	ldbu	r3,-28(fp)
8110df34:	180b883a 	mov	r5,r3
8110df38:	1009883a 	mov	r4,r2
8110df3c:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110df40:	e0bffa15 	stw	r2,-24(fp)


	switch (ucADDRReg) {
8110df44:	e0bff903 	ldbu	r2,-28(fp)
8110df48:	10bff004 	addi	r2,r2,-64
8110df4c:	10c003a8 	cmpgeui	r3,r2,14
8110df50:	1800ba1e 	bne	r3,zero,8110e23c <vQCmdFeeRMAPinStandBy+0x368>
8110df54:	100690ba 	slli	r3,r2,2
8110df58:	00a04474 	movhi	r2,33041
8110df5c:	10b7db04 	addi	r2,r2,-8340
8110df60:	1885883a 	add	r2,r3,r2
8110df64:	10800017 	ldw	r2,0(r2)
8110df68:	1000683a 	jmp	r2
8110df6c:	8110dfa4 	muli	r4,r16,17278
8110df70:	8110e25c 	xori	r4,r16,17289
8110df74:	8110e070 	cmpltui	r4,r16,17281
8110df78:	8110e0d8 	cmpnei	r4,r16,17283
8110df7c:	8110e0d8 	cmpnei	r4,r16,17283
8110df80:	8110e0d8 	cmpnei	r4,r16,17283
8110df84:	8110e0d8 	cmpnei	r4,r16,17283
8110df88:	8110e0d8 	cmpnei	r4,r16,17283
8110df8c:	8110e0d8 	cmpnei	r4,r16,17283
8110df90:	8110e0d8 	cmpnei	r4,r16,17283
8110df94:	8110e0d8 	cmpnei	r4,r16,17283
8110df98:	8110e0d8 	cmpnei	r4,r16,17283
8110df9c:	8110e0f4 	orhi	r4,r16,17283
8110dfa0:	8110e1cc 	andi	r4,r16,17287
		case 0x40://0x00000000: ccd_seq_1_config
			ucValueMasked = (COMM_RMAP_IMGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 4; /* Number of rows */
8110dfa4:	e0fffa17 	ldw	r3,-24(fp)
8110dfa8:	00800434 	movhi	r2,16
8110dfac:	10bffc04 	addi	r2,r2,-16
8110dfb0:	1884703a 	and	r2,r3,r2
8110dfb4:	1004d13a 	srli	r2,r2,4
8110dfb8:	e0bffb15 	stw	r2,-20(fp)
			ucValueMasked2 = (COMM_RMAP_REGCLK_TRCNT_CTRL_MSK & ucValueReg) >> 20; /* Number of columns */
8110dfbc:	e0bffa17 	ldw	r2,-24(fp)
8110dfc0:	1004d53a 	srli	r2,r2,20
8110dfc4:	e0bffc15 	stw	r2,-16(fp)

			/* upsate minha estrutura depois atualizar a do frana */

			pxNFeeP->xCcdInfo.usiHeight = ucValueMasked;
8110dfc8:	e0bffb17 	ldw	r2,-20(fp)
8110dfcc:	1007883a 	mov	r3,r2
8110dfd0:	e0bffe17 	ldw	r2,-8(fp)
8110dfd4:	10c0310d 	sth	r3,196(r2)
			pxNFeeP->xCcdInfo.usiHalfWidth = ucValueMasked2;
8110dfd8:	e0bffc17 	ldw	r2,-16(fp)
8110dfdc:	1007883a 	mov	r3,r2
8110dfe0:	e0bffe17 	ldw	r2,-8(fp)
8110dfe4:	10c0308d 	sth	r3,194(r2)
			vUpdateMemMapFEE(pxNFeeP);
8110dfe8:	e13ffe17 	ldw	r4,-8(fp)
8110dfec:	1119b9c0 	call	81119b9c <vUpdateMemMapFEE>

			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110dff0:	e0bffe17 	ldw	r2,-8(fp)
8110dff4:	10803304 	addi	r2,r2,204
8110dff8:	1009883a 	mov	r4,r2
8110dffc:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdXSize = pxNFeeP->xCcdInfo.usiHalfWidth;
8110e000:	e0bffe17 	ldw	r2,-8(fp)
8110e004:	10c0308b 	ldhu	r3,194(r2)
8110e008:	e0bffe17 	ldw	r2,-8(fp)
8110e00c:	10c0340d 	sth	r3,208(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiCcdYSize = pxNFeeP->xCcdInfo.usiHeight;
8110e010:	e0bffe17 	ldw	r2,-8(fp)
8110e014:	10c0310b 	ldhu	r3,196(r2)
8110e018:	e0bffe17 	ldw	r2,-8(fp)
8110e01c:	10c0348d 	sth	r3,210(r2)
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiDataYSize = pxNFeeP->xCcdInfo.usiHeight - pxNFeeP->xCcdInfo.usiOLN;
8110e020:	e0bffe17 	ldw	r2,-8(fp)
8110e024:	10c0310b 	ldhu	r3,196(r2)
8110e028:	e0bffe17 	ldw	r2,-8(fp)
8110e02c:	1080300b 	ldhu	r2,192(r2)
8110e030:	1885c83a 	sub	r2,r3,r2
8110e034:	1007883a 	mov	r3,r2
8110e038:	e0bffe17 	ldw	r2,-8(fp)
8110e03c:	10c0350d 	sth	r3,212(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110e040:	e0bffe17 	ldw	r2,-8(fp)
8110e044:	10803304 	addi	r2,r2,204
8110e048:	1009883a 	mov	r4,r2
8110e04c:	110479c0 	call	8110479c <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp," - Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110e050:	d0a05e17 	ldw	r2,-32392(gp)
8110e054:	e1fffc17 	ldw	r7,-16(fp)
8110e058:	e1bffb17 	ldw	r6,-20(fp)
8110e05c:	01604574 	movhi	r5,33045
8110e060:	2962ae04 	addi	r5,r5,-30024
8110e064:	1009883a 	mov	r4,r2
8110e068:	111ca180 	call	8111ca18 <fprintf>
			#endif

			break;
8110e06c:	00007e06 	br	8110e268 <vQCmdFeeRMAPinStandBy+0x394>
		case 0x041://0x00000004:ccd_seq_2_config
			break;
		case 0x042://0x00000008:spw_packet_1_config

			ucValueMasked = (ucValueReg & COMM_RMAP_PACKET_SIZE_CTRL_MSK) >> 4;
8110e070:	e0fffa17 	ldw	r3,-24(fp)
8110e074:	00800434 	movhi	r2,16
8110e078:	10bffc04 	addi	r2,r2,-16
8110e07c:	1884703a 	and	r2,r3,r2
8110e080:	1004d13a 	srli	r2,r2,4
8110e084:	e0bffb15 	stw	r2,-20(fp)
			bDpktGetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110e088:	e0bffe17 	ldw	r2,-8(fp)
8110e08c:	10803304 	addi	r2,r2,204
8110e090:	1009883a 	mov	r4,r2
8110e094:	11049c80 	call	811049c8 <bDpktGetPacketConfig>
			pxNFeeP->xChannel.xDataPacket.xDpktDataPacketConfig.usiPacketLength = ucValueMasked;
8110e098:	e0bffb17 	ldw	r2,-20(fp)
8110e09c:	1007883a 	mov	r3,r2
8110e0a0:	e0bffe17 	ldw	r2,-8(fp)
8110e0a4:	10c0360d 	sth	r3,216(r2)
			bDpktSetPacketConfig(&pxNFeeP->xChannel.xDataPacket);
8110e0a8:	e0bffe17 	ldw	r2,-8(fp)
8110e0ac:	10803304 	addi	r2,r2,204
8110e0b0:	1009883a 	mov	r4,r2
8110e0b4:	110479c0 	call	8110479c <bDpktSetPacketConfig>

			#ifdef DEBUG_ON
				fprintf(fp," - Pckt Length: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
8110e0b8:	d0a05e17 	ldw	r2,-32392(gp)
8110e0bc:	e1fffc17 	ldw	r7,-16(fp)
8110e0c0:	e1bffb17 	ldw	r6,-20(fp)
8110e0c4:	01604574 	movhi	r5,33045
8110e0c8:	2962b504 	addi	r5,r5,-29996
8110e0cc:	1009883a 	mov	r4,r2
8110e0d0:	111ca180 	call	8111ca18 <fprintf>
			#endif

			break;
8110e0d4:	00006406 	br	8110e268 <vQCmdFeeRMAPinStandBy+0x394>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
8110e0d8:	d0a05e17 	ldw	r2,-32392(gp)
8110e0dc:	e1bffb17 	ldw	r6,-20(fp)
8110e0e0:	01604574 	movhi	r5,33045
8110e0e4:	2962be04 	addi	r5,r5,-29960
8110e0e8:	1009883a 	mov	r4,r2
8110e0ec:	111ca180 	call	8111ca18 <fprintf>
			#endif
				break;
8110e0f0:	00005d06 	br	8110e268 <vQCmdFeeRMAPinStandBy+0x394>
		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110e0f4:	e0bffa17 	ldw	r2,-24(fp)
8110e0f8:	10803c0c 	andi	r2,r2,240
8110e0fc:	1004d13a 	srli	r2,r2,4
8110e100:	e0bffb15 	stw	r2,-20(fp)


			switch (ucValueMasked) {
8110e104:	e0bffb17 	ldw	r2,-20(fp)
8110e108:	10c000a0 	cmpeqi	r3,r2,2
8110e10c:	1800111e 	bne	r3,zero,8110e154 <vQCmdFeeRMAPinStandBy+0x280>
8110e110:	10c001a0 	cmpeqi	r3,r2,6
8110e114:	18001d1e 	bne	r3,zero,8110e18c <vQCmdFeeRMAPinStandBy+0x2b8>
8110e118:	1000241e 	bne	r2,zero,8110e1ac <vQCmdFeeRMAPinStandBy+0x2d8>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8110e11c:	d0a05e17 	ldw	r2,-32392(gp)
8110e120:	100f883a 	mov	r7,r2
8110e124:	01800384 	movi	r6,14
8110e128:	01400044 	movi	r5,1
8110e12c:	01204574 	movhi	r4,33045
8110e130:	2122c704 	addi	r4,r4,-29924
8110e134:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

					uiCmdFEEL.ucByte[2] = M_FEE_STANDBY;
8110e138:	00800104 	movi	r2,4
8110e13c:	e0bffd85 	stb	r2,-10(fp)
					vQCmdFEEinStandBy( pxNFeeP, uiCmdFEEL.ulWord);
8110e140:	e0bffd17 	ldw	r2,-12(fp)
8110e144:	100b883a 	mov	r5,r2
8110e148:	e13ffe17 	ldw	r4,-8(fp)
8110e14c:	110db4c0 	call	8110db4c <vQCmdFEEinStandBy>

					break;
8110e150:	00001d06 	br	8110e1c8 <vQCmdFeeRMAPinStandBy+0x2f4>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110e154:	d0a05e17 	ldw	r2,-32392(gp)
8110e158:	100f883a 	mov	r7,r2
8110e15c:	01800604 	movi	r6,24
8110e160:	01400044 	movi	r5,1
8110e164:	01204574 	movhi	r4,33045
8110e168:	2122cb04 	addi	r4,r4,-29908
8110e16c:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

					uiCmdFEEL.ucByte[2] = M_FEE_FULL_PATTERN;
8110e170:	00800204 	movi	r2,8
8110e174:	e0bffd85 	stb	r2,-10(fp)
					vQCmdFEEinStandBy( pxNFeeP, uiCmdFEEL.ulWord);
8110e178:	e0bffd17 	ldw	r2,-12(fp)
8110e17c:	100b883a 	mov	r5,r2
8110e180:	e13ffe17 	ldw	r4,-8(fp)
8110e184:	110db4c0 	call	8110db4c <vQCmdFEEinStandBy>

					break;
8110e188:	00000f06 	br	8110e1c8 <vQCmdFeeRMAPinStandBy+0x2f4>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8110e18c:	d0a05e17 	ldw	r2,-32392(gp)
8110e190:	100f883a 	mov	r7,r2
8110e194:	018005c4 	movi	r6,23
8110e198:	01400044 	movi	r5,1
8110e19c:	01204574 	movhi	r4,33045
8110e1a0:	2122d204 	addi	r4,r4,-29880
8110e1a4:	111d0b40 	call	8111d0b4 <fwrite>
				#endif
					break;
8110e1a8:	00000706 	br	8110e1c8 <vQCmdFeeRMAPinStandBy+0x2f4>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110e1ac:	d0a05e17 	ldw	r2,-32392(gp)
8110e1b0:	e1bffb17 	ldw	r6,-20(fp)
8110e1b4:	01604574 	movhi	r5,33045
8110e1b8:	2962d804 	addi	r5,r5,-29856
8110e1bc:	1009883a 	mov	r4,r2
8110e1c0:	111ca180 	call	8111ca18 <fprintf>
					#endif
					break;
8110e1c4:	0001883a 	nop
			}

			break;
8110e1c8:	00002706 	br	8110e268 <vQCmdFeeRMAPinStandBy+0x394>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110e1cc:	e0bffa17 	ldw	r2,-24(fp)
8110e1d0:	1080010c 	andi	r2,r2,4
8110e1d4:	1004d0ba 	srli	r2,r2,2
8110e1d8:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110e1dc:	e0bffb17 	ldw	r2,-20(fp)
8110e1e0:	10002026 	beq	r2,zero,8110e264 <vQCmdFeeRMAPinStandBy+0x390>
				#ifdef DEBUG_ON
					fprintf(fp," - operation not allowed (StandBy-Mode)\n");
8110e1e4:	d0a05e17 	ldw	r2,-32392(gp)
8110e1e8:	100f883a 	mov	r7,r2
8110e1ec:	01800a04 	movi	r6,40
8110e1f0:	01400044 	movi	r5,1
8110e1f4:	01204574 	movhi	r4,33045
8110e1f8:	2122e004 	addi	r4,r4,-29824
8110e1fc:	111d0b40 	call	8111d0b4 <fwrite>
				#endif
				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110e200:	e0bffe17 	ldw	r2,-8(fp)
8110e204:	10804204 	addi	r2,r2,264
8110e208:	1009883a 	mov	r4,r2
8110e20c:	11075600 	call	81107560 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110e210:	e0bffe17 	ldw	r2,-8(fp)
8110e214:	10c06117 	ldw	r3,388(r2)
8110e218:	00bffec4 	movi	r2,-5
8110e21c:	1886703a 	and	r3,r3,r2
8110e220:	e0bffe17 	ldw	r2,-8(fp)
8110e224:	10c06115 	stw	r3,388(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110e228:	e0bffe17 	ldw	r2,-8(fp)
8110e22c:	10804204 	addi	r2,r2,264
8110e230:	1009883a 	mov	r4,r2
8110e234:	11072740 	call	81107274 <bRmapSetMemConfigArea>
			}

			break;
8110e238:	00000a06 	br	8110e264 <vQCmdFeeRMAPinStandBy+0x390>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110e23c:	d0a05e17 	ldw	r2,-32392(gp)
8110e240:	e0fff903 	ldbu	r3,-28(fp)
8110e244:	180d883a 	mov	r6,r3
8110e248:	01604574 	movhi	r5,33045
8110e24c:	2962be04 	addi	r5,r5,-29960
8110e250:	1009883a 	mov	r4,r2
8110e254:	111ca180 	call	8111ca18 <fprintf>
			#endif
			break;
8110e258:	00000306 	br	8110e268 <vQCmdFeeRMAPinStandBy+0x394>
				fprintf(fp," - Rows: %u\n - Columns: %u\n", ucValueMasked, ucValueMasked2);
			#endif

			break;
		case 0x041://0x00000004:ccd_seq_2_config
			break;
8110e25c:	0001883a 	nop
8110e260:	00000106 	br	8110e268 <vQCmdFeeRMAPinStandBy+0x394>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110e264:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
			#endif
			break;
		}
}
8110e268:	0001883a 	nop
8110e26c:	e037883a 	mov	sp,fp
8110e270:	dfc00117 	ldw	ra,4(sp)
8110e274:	df000017 	ldw	fp,0(sp)
8110e278:	dec00204 	addi	sp,sp,8
8110e27c:	f800283a 	ret

8110e280 <vQCmdFeeRMAPinFullPattern>:

void vQCmdFeeRMAPinFullPattern( TNFee *pxNFeeP, unsigned int cmd ){
8110e280:	defff804 	addi	sp,sp,-32
8110e284:	de00012e 	bgeu	sp,et,8110e28c <vQCmdFeeRMAPinFullPattern+0xc>
8110e288:	003b68fa 	trap	3
8110e28c:	dfc00715 	stw	ra,28(sp)
8110e290:	df000615 	stw	fp,24(sp)
8110e294:	df000604 	addi	fp,sp,24
8110e298:	e13ffe15 	stw	r4,-8(fp)
8110e29c:	e17fff15 	stw	r5,-4(fp)
	INT8U ucADDRReg;
	INT8U ucValueReg;
	INT32U ucValueMasked;

	#ifdef DEBUG_ON
		fprintf(fp,"\nNFEE %hhu Task: RMAP msg received\n", pxNFeeP->ucId);
8110e2a0:	d0e05e17 	ldw	r3,-32392(gp)
8110e2a4:	e0bffe17 	ldw	r2,-8(fp)
8110e2a8:	10800003 	ldbu	r2,0(r2)
8110e2ac:	10803fcc 	andi	r2,r2,255
8110e2b0:	100d883a 	mov	r6,r2
8110e2b4:	01604574 	movhi	r5,33045
8110e2b8:	2962a504 	addi	r5,r5,-30060
8110e2bc:	1809883a 	mov	r4,r3
8110e2c0:	111ca180 	call	8111ca18 <fprintf>
	#endif

	uiCmdFEEL.ulWord = cmd;
8110e2c4:	e0bfff17 	ldw	r2,-4(fp)
8110e2c8:	e0bffd15 	stw	r2,-12(fp)

	ucADDRReg = uiCmdFEEL.ucByte[1];
8110e2cc:	e0bffd43 	ldbu	r2,-11(fp)
8110e2d0:	e0bffa05 	stb	r2,-24(fp)
	ucValueReg = uliRmapReadReg(pxNFeeP->xChannel.xRmap.puliRmapChAddr,  ucADDRReg);
8110e2d4:	e0bffe17 	ldw	r2,-8(fp)
8110e2d8:	10804217 	ldw	r2,264(r2)
8110e2dc:	e0fffa03 	ldbu	r3,-24(fp)
8110e2e0:	180b883a 	mov	r5,r3
8110e2e4:	1009883a 	mov	r4,r2
8110e2e8:	1108ed80 	call	81108ed8 <uliRmapReadReg>
8110e2ec:	e0bffa45 	stb	r2,-23(fp)


	switch (ucADDRReg) {
8110e2f0:	e0bffa03 	ldbu	r2,-24(fp)
8110e2f4:	10c01320 	cmpeqi	r3,r2,76
8110e2f8:	18000f1e 	bne	r3,zero,8110e338 <vQCmdFeeRMAPinFullPattern+0xb8>
8110e2fc:	10c01348 	cmpgei	r3,r2,77
8110e300:	1800031e 	bne	r3,zero,8110e310 <vQCmdFeeRMAPinFullPattern+0x90>
8110e304:	10801010 	cmplti	r2,r2,64
8110e308:	10007d1e 	bne	r2,zero,8110e500 <vQCmdFeeRMAPinFullPattern+0x280>
8110e30c:	00000306 	br	8110e31c <vQCmdFeeRMAPinFullPattern+0x9c>
8110e310:	10801360 	cmpeqi	r2,r2,77
8110e314:	10003e1e 	bne	r2,zero,8110e410 <vQCmdFeeRMAPinFullPattern+0x190>
8110e318:	00007906 	br	8110e500 <vQCmdFeeRMAPinFullPattern+0x280>
		case 0x48://0x00000020:CCD_3_windowing_1_config
		case 0x49://0x00000024:CCD_3_windowing_2_config
		case 0x4A://0x00000028:CCD_4_windowing_1_config
		case 0x4B://0x0000002C:CCD_4_windowing_2_config
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucValueMasked);
8110e31c:	d0a05e17 	ldw	r2,-32392(gp)
8110e320:	e1bffb17 	ldw	r6,-20(fp)
8110e324:	01604574 	movhi	r5,33045
8110e328:	2962be04 	addi	r5,r5,-29960
8110e32c:	1009883a 	mov	r4,r2
8110e330:	111ca180 	call	8111ca18 <fprintf>
			#endif
				break;
8110e334:	00007b06 	br	8110e524 <vQCmdFeeRMAPinFullPattern+0x2a4>

		case 0x0000004C://0x00000038:operation_mode_config
			/* Mode Selection */
			ucValueMasked = (COMM_RMAP_MODE_SEL_CTRL_MSK & ucValueReg) >>4;
8110e338:	e0bffa43 	ldbu	r2,-23(fp)
8110e33c:	1004d13a 	srli	r2,r2,4
8110e340:	10803fcc 	andi	r2,r2,255
8110e344:	e0bffb15 	stw	r2,-20(fp)

			switch (ucValueMasked) {
8110e348:	e0bffb17 	ldw	r2,-20(fp)
8110e34c:	10c000a0 	cmpeqi	r3,r2,2
8110e350:	1800111e 	bne	r3,zero,8110e398 <vQCmdFeeRMAPinFullPattern+0x118>
8110e354:	10c001a0 	cmpeqi	r3,r2,6
8110e358:	18001d1e 	bne	r3,zero,8110e3d0 <vQCmdFeeRMAPinFullPattern+0x150>
8110e35c:	1000241e 	bne	r2,zero,8110e3f0 <vQCmdFeeRMAPinFullPattern+0x170>
				case 0: /* Standby */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Stand-By\n");
8110e360:	d0a05e17 	ldw	r2,-32392(gp)
8110e364:	100f883a 	mov	r7,r2
8110e368:	01800384 	movi	r6,14
8110e36c:	01400044 	movi	r5,1
8110e370:	01204574 	movhi	r4,33045
8110e374:	2122c704 	addi	r4,r4,-29924
8110e378:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

					uiCmdFEEL.ucByte[2] = M_FEE_STANDBY;
8110e37c:	00800104 	movi	r2,4
8110e380:	e0bffd85 	stb	r2,-10(fp)
					vQCmdFEEinFullPattern( pxNFeeP, uiCmdFEEL.ulWord);
8110e384:	e0bffd17 	ldw	r2,-12(fp)
8110e388:	100b883a 	mov	r5,r2
8110e38c:	e13ffe17 	ldw	r4,-8(fp)
8110e390:	110dd080 	call	8110dd08 <vQCmdFEEinFullPattern>

					break;
8110e394:	00001d06 	br	8110e40c <vQCmdFeeRMAPinFullPattern+0x18c>
				case 2: /* PAttern Full image */
				#ifdef DEBUG_ON
					fprintf(fp,"- to Full-Image-Pattern\n");
8110e398:	d0a05e17 	ldw	r2,-32392(gp)
8110e39c:	100f883a 	mov	r7,r2
8110e3a0:	01800604 	movi	r6,24
8110e3a4:	01400044 	movi	r5,1
8110e3a8:	01204574 	movhi	r4,33045
8110e3ac:	2122cb04 	addi	r4,r4,-29908
8110e3b0:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

					uiCmdFEEL.ucByte[2] = M_FEE_FULL_PATTERN;
8110e3b4:	00800204 	movi	r2,8
8110e3b8:	e0bffd85 	stb	r2,-10(fp)
					vQCmdFEEinFullPattern( pxNFeeP, uiCmdFEEL.ulWord);
8110e3bc:	e0bffd17 	ldw	r2,-12(fp)
8110e3c0:	100b883a 	mov	r5,r2
8110e3c4:	e13ffe17 	ldw	r4,-8(fp)
8110e3c8:	110dd080 	call	8110dd08 <vQCmdFEEinFullPattern>

					break;
8110e3cc:	00000f06 	br	8110e40c <vQCmdFeeRMAPinFullPattern+0x18c>
				case 6:
				#ifdef DEBUG_ON
					fprintf(fp," Off-Mode not allowed.\n");
8110e3d0:	d0a05e17 	ldw	r2,-32392(gp)
8110e3d4:	100f883a 	mov	r7,r2
8110e3d8:	018005c4 	movi	r6,23
8110e3dc:	01400044 	movi	r5,1
8110e3e0:	01204574 	movhi	r4,33045
8110e3e4:	2122d204 	addi	r4,r4,-29880
8110e3e8:	111d0b40 	call	8111d0b4 <fwrite>
				#endif
					break;
8110e3ec:	00000706 	br	8110e40c <vQCmdFeeRMAPinFullPattern+0x18c>
				case 3:
				case 4:
				case 5:
				default:
					#ifdef DEBUG_ON
						fprintf(fp," mode not allowed yet ( %hhu )\n", ucValueMasked);
8110e3f0:	d0a05e17 	ldw	r2,-32392(gp)
8110e3f4:	e1bffb17 	ldw	r6,-20(fp)
8110e3f8:	01604574 	movhi	r5,33045
8110e3fc:	2962d804 	addi	r5,r5,-29856
8110e400:	1009883a 	mov	r4,r2
8110e404:	111ca180 	call	8111ca18 <fprintf>
					#endif
					break;
8110e408:	0001883a 	nop
			}

			break;
8110e40c:	00004506 	br	8110e524 <vQCmdFeeRMAPinFullPattern+0x2a4>
		case 0x0000004D://0x0000003C:sync_config

			ucValueMasked = (COMM_RMAP_SELF_TRIGGER_CTRL_MSK & ucValueReg) >> 2; /* Number of rows */
8110e410:	e0bffa43 	ldbu	r2,-23(fp)
8110e414:	1080010c 	andi	r2,r2,4
8110e418:	10803fcc 	andi	r2,r2,255
8110e41c:	1004d0ba 	srli	r2,r2,2
8110e420:	10803fcc 	andi	r2,r2,255
8110e424:	e0bffb15 	stw	r2,-20(fp)

			/* Cannot perform this operation */
			if ( ucValueMasked ) {
8110e428:	e0bffb17 	ldw	r2,-20(fp)
8110e42c:	10003c26 	beq	r2,zero,8110e520 <vQCmdFeeRMAPinFullPattern+0x2a0>

				if ( pxNFeeP->xControl.bWatingSync == TRUE ) {
8110e430:	e0bffe17 	ldw	r2,-8(fp)
8110e434:	10802817 	ldw	r2,160(r2)
8110e438:	10800058 	cmpnei	r2,r2,1
8110e43c:	1000211e 	bne	r2,zero,8110e4c4 <vQCmdFeeRMAPinFullPattern+0x244>
					uiCmdFEEL.ucByte[3] = M_NFEE_BASE_ADDR + pxNFeeP->ucId;
8110e440:	e0bffe17 	ldw	r2,-8(fp)
8110e444:	10800003 	ldbu	r2,0(r2)
8110e448:	10800444 	addi	r2,r2,17
8110e44c:	e0bffdc5 	stb	r2,-9(fp)
					uiCmdFEEL.ucByte[2] = M_SYNC;
8110e450:	00bff844 	movi	r2,-31
8110e454:	e0bffd85 	stb	r2,-10(fp)
					error_codel = OSQPost(xWaitSyncQFee[ pxNFeeP->ucId ], (void *)uiCmdFEEL.ulWord);
8110e458:	e0bffe17 	ldw	r2,-8(fp)
8110e45c:	10800003 	ldbu	r2,0(r2)
8110e460:	10803fcc 	andi	r2,r2,255
8110e464:	1085883a 	add	r2,r2,r2
8110e468:	1087883a 	add	r3,r2,r2
8110e46c:	d0a05804 	addi	r2,gp,-32416
8110e470:	1885883a 	add	r2,r3,r2
8110e474:	10800017 	ldw	r2,0(r2)
8110e478:	e0fffd17 	ldw	r3,-12(fp)
8110e47c:	180b883a 	mov	r5,r3
8110e480:	1009883a 	mov	r4,r2
8110e484:	113a0040 	call	8113a004 <OSQPost>
8110e488:	e0bffc05 	stb	r2,-16(fp)
					if ( error_codel != OS_ERR_NONE ) {
8110e48c:	e0bffc03 	ldbu	r2,-16(fp)
8110e490:	10000526 	beq	r2,zero,8110e4a8 <vQCmdFeeRMAPinFullPattern+0x228>
						vFailSendMsgSyncRMAPTRIGGER( pxNFeeP->ucId );
8110e494:	e0bffe17 	ldw	r2,-8(fp)
8110e498:	10800003 	ldbu	r2,0(r2)
8110e49c:	10803fcc 	andi	r2,r2,255
8110e4a0:	1009883a 	mov	r4,r2
8110e4a4:	11196f40 	call	811196f4 <vFailSendMsgSyncRMAPTRIGGER>
					}

					#ifdef DEBUG_ON
						fprintf(fp," - Mode Forced.\n");
8110e4a8:	d0a05e17 	ldw	r2,-32392(gp)
8110e4ac:	100f883a 	mov	r7,r2
8110e4b0:	01800404 	movi	r6,16
8110e4b4:	01400044 	movi	r5,1
8110e4b8:	01204574 	movhi	r4,33045
8110e4bc:	2122eb04 	addi	r4,r4,-29780
8110e4c0:	111d0b40 	call	8111d0b4 <fwrite>
					#endif
				}

				/* Clear the trigger */
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110e4c4:	e0bffe17 	ldw	r2,-8(fp)
8110e4c8:	10804204 	addi	r2,r2,264
8110e4cc:	1009883a 	mov	r4,r2
8110e4d0:	11075600 	call	81107560 <bRmapGetMemConfigArea>
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
8110e4d4:	e0bffe17 	ldw	r2,-8(fp)
8110e4d8:	10c06117 	ldw	r3,388(r2)
8110e4dc:	00bffec4 	movi	r2,-5
8110e4e0:	1886703a 	and	r3,r3,r2
8110e4e4:	e0bffe17 	ldw	r2,-8(fp)
8110e4e8:	10c06115 	stw	r3,388(r2)
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
8110e4ec:	e0bffe17 	ldw	r2,-8(fp)
8110e4f0:	10804204 	addi	r2,r2,264
8110e4f4:	1009883a 	mov	r4,r2
8110e4f8:	11072740 	call	81107274 <bRmapSetMemConfigArea>
			}

			break;
8110e4fc:	00000806 	br	8110e520 <vQCmdFeeRMAPinFullPattern+0x2a0>
		case 0x0000004F://0x00000044:clock_source_control
		case 0x00000050://0x00000048:frame_number
		case 0x00000051://0x0000004C:current_mode
		default:
			#ifdef DEBUG_ON
				fprintf(fp," Command not allowed yet ( %hhu )\n", ucADDRReg);
8110e500:	d0a05e17 	ldw	r2,-32392(gp)
8110e504:	e0fffa03 	ldbu	r3,-24(fp)
8110e508:	180d883a 	mov	r6,r3
8110e50c:	01604574 	movhi	r5,33045
8110e510:	2962be04 	addi	r5,r5,-29960
8110e514:	1009883a 	mov	r4,r2
8110e518:	111ca180 	call	8111ca18 <fprintf>
			#endif
			break;
8110e51c:	00000106 	br	8110e524 <vQCmdFeeRMAPinFullPattern+0x2a4>
				bRmapGetMemConfigArea(&pxNFeeP->xChannel.xRmap);
				pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig = ( pxNFeeP->xChannel.xRmap.xRmapMemConfigArea.uliSyncConfig & 0xFFFFFFFB);
				bRmapSetMemConfigArea(&pxNFeeP->xChannel.xRmap);
			}

			break;
8110e520:	0001883a 	nop
			break;
		}



}
8110e524:	0001883a 	nop
8110e528:	e037883a 	mov	sp,fp
8110e52c:	dfc00117 	ldw	ra,4(sp)
8110e530:	df000017 	ldw	fp,0(sp)
8110e534:	dec00204 	addi	sp,sp,8
8110e538:	f800283a 	ret

8110e53c <bDisableRmapIRQ>:





bool bDisableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110e53c:	defffd04 	addi	sp,sp,-12
8110e540:	de00012e 	bgeu	sp,et,8110e548 <bDisableRmapIRQ+0xc>
8110e544:	003b68fa 	trap	3
8110e548:	dfc00215 	stw	ra,8(sp)
8110e54c:	df000115 	stw	fp,4(sp)
8110e550:	df000104 	addi	fp,sp,4
8110e554:	e13fff15 	stw	r4,-4(fp)
	/* Disable RMAP channel */
	bRmapGetIrqControl(pxRmapCh);
8110e558:	e13fff17 	ldw	r4,-4(fp)
8110e55c:	1106d400 	call	81106d40 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = FALSE;
8110e560:	e0bfff17 	ldw	r2,-4(fp)
8110e564:	10001015 	stw	zero,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110e568:	e13fff17 	ldw	r4,-4(fp)
8110e56c:	1106c980 	call	81106c98 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110e570:	00800044 	movi	r2,1
}
8110e574:	e037883a 	mov	sp,fp
8110e578:	dfc00117 	ldw	ra,4(sp)
8110e57c:	df000017 	ldw	fp,0(sp)
8110e580:	dec00204 	addi	sp,sp,8
8110e584:	f800283a 	ret

8110e588 <bEnableRmapIRQ>:

bool bEnableRmapIRQ( TRmapChannel *pxRmapCh ) {
8110e588:	defffd04 	addi	sp,sp,-12
8110e58c:	de00012e 	bgeu	sp,et,8110e594 <bEnableRmapIRQ+0xc>
8110e590:	003b68fa 	trap	3
8110e594:	dfc00215 	stw	ra,8(sp)
8110e598:	df000115 	stw	fp,4(sp)
8110e59c:	df000104 	addi	fp,sp,4
8110e5a0:	e13fff15 	stw	r4,-4(fp)
	/* Enable RMAP */
	/* Before Enable the IRQ for Rmap, make a copy for compare when some command arrive */
	bRmapGetMemConfigArea(&RmapConfAreaL);
8110e5a4:	01204574 	movhi	r4,33045
8110e5a8:	213ccb04 	addi	r4,r4,-3284
8110e5ac:	11075600 	call	81107560 <bRmapGetMemConfigArea>

	bRmapGetIrqControl(pxRmapCh);
8110e5b0:	e13fff17 	ldw	r4,-4(fp)
8110e5b4:	1106d400 	call	81106d40 <bRmapGetIrqControl>
	pxRmapCh->xRmapIrqControl.bWriteCmdEn = TRUE;
8110e5b8:	e0bfff17 	ldw	r2,-4(fp)
8110e5bc:	00c00044 	movi	r3,1
8110e5c0:	10c01015 	stw	r3,64(r2)
	bRmapSetIrqControl(pxRmapCh);
8110e5c4:	e13fff17 	ldw	r4,-4(fp)
8110e5c8:	1106c980 	call	81106c98 <bRmapSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110e5cc:	00800044 	movi	r2,1
}
8110e5d0:	e037883a 	mov	sp,fp
8110e5d4:	dfc00117 	ldw	ra,4(sp)
8110e5d8:	df000017 	ldw	fp,0(sp)
8110e5dc:	dec00204 	addi	sp,sp,8
8110e5e0:	f800283a 	ret

8110e5e4 <bDisableSPWChannel>:

bool bDisableSPWChannel( TSpwcChannel *xSPW ) {
8110e5e4:	defffd04 	addi	sp,sp,-12
8110e5e8:	de00012e 	bgeu	sp,et,8110e5f0 <bDisableSPWChannel+0xc>
8110e5ec:	003b68fa 	trap	3
8110e5f0:	dfc00215 	stw	ra,8(sp)
8110e5f4:	df000115 	stw	fp,4(sp)
8110e5f8:	df000104 	addi	fp,sp,4
8110e5fc:	e13fff15 	stw	r4,-4(fp)
	/* Disable SPW channel */
	bSpwcGetLink(xSPW);
8110e600:	e13fff17 	ldw	r4,-4(fp)
8110e604:	11092c40 	call	811092c4 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110e608:	e0bfff17 	ldw	r2,-4(fp)
8110e60c:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = FALSE;
8110e610:	e0bfff17 	ldw	r2,-4(fp)
8110e614:	10000115 	stw	zero,4(r2)
	xSPW->xLinkConfig.bDisconnect = TRUE;
8110e618:	e0bfff17 	ldw	r2,-4(fp)
8110e61c:	00c00044 	movi	r3,1
8110e620:	10c00315 	stw	r3,12(r2)
	bSpwcSetLink(xSPW);
8110e624:	e13fff17 	ldw	r4,-4(fp)
8110e628:	11091900 	call	81109190 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110e62c:	00800044 	movi	r2,1
}
8110e630:	e037883a 	mov	sp,fp
8110e634:	dfc00117 	ldw	ra,4(sp)
8110e638:	df000017 	ldw	fp,0(sp)
8110e63c:	dec00204 	addi	sp,sp,8
8110e640:	f800283a 	ret

8110e644 <bEnableSPWChannel>:

bool bEnableSPWChannel( TSpwcChannel *xSPW ) {
8110e644:	defffd04 	addi	sp,sp,-12
8110e648:	de00012e 	bgeu	sp,et,8110e650 <bEnableSPWChannel+0xc>
8110e64c:	003b68fa 	trap	3
8110e650:	dfc00215 	stw	ra,8(sp)
8110e654:	df000115 	stw	fp,4(sp)
8110e658:	df000104 	addi	fp,sp,4
8110e65c:	e13fff15 	stw	r4,-4(fp)
	/* Enable SPW channel */
	bSpwcGetLink(xSPW);
8110e660:	e13fff17 	ldw	r4,-4(fp)
8110e664:	11092c40 	call	811092c4 <bSpwcGetLink>
	xSPW->xLinkConfig.bLinkStart = FALSE;
8110e668:	e0bfff17 	ldw	r2,-4(fp)
8110e66c:	10000215 	stw	zero,8(r2)
	xSPW->xLinkConfig.bAutostart = TRUE;
8110e670:	e0bfff17 	ldw	r2,-4(fp)
8110e674:	00c00044 	movi	r3,1
8110e678:	10c00115 	stw	r3,4(r2)
	xSPW->xLinkConfig.bDisconnect = FALSE;
8110e67c:	e0bfff17 	ldw	r2,-4(fp)
8110e680:	10000315 	stw	zero,12(r2)
	bSpwcSetLink(xSPW);
8110e684:	e13fff17 	ldw	r4,-4(fp)
8110e688:	11091900 	call	81109190 <bSpwcSetLink>

	/*todo: No treatment for now  */
	return TRUE;
8110e68c:	00800044 	movi	r2,1
}
8110e690:	e037883a 	mov	sp,fp
8110e694:	dfc00117 	ldw	ra,4(sp)
8110e698:	df000017 	ldw	fp,0(sp)
8110e69c:	dec00204 	addi	sp,sp,8
8110e6a0:	f800283a 	ret

8110e6a4 <bEnableDbBuffer>:

bool bEnableDbBuffer( TFeebChannel *pxFeebCh ) {
8110e6a4:	defffd04 	addi	sp,sp,-12
8110e6a8:	de00012e 	bgeu	sp,et,8110e6b0 <bEnableDbBuffer+0xc>
8110e6ac:	003b68fa 	trap	3
8110e6b0:	dfc00215 	stw	ra,8(sp)
8110e6b4:	df000115 	stw	fp,4(sp)
8110e6b8:	df000104 	addi	fp,sp,4
8110e6bc:	e13fff15 	stw	r4,-4(fp)

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110e6c0:	e13fff17 	ldw	r4,-4(fp)
8110e6c4:	1105ec00 	call	81105ec0 <bFeebClrCh>

	/* Start the module Double Buffer */
	bFeebStartCh(pxFeebCh);
8110e6c8:	e13fff17 	ldw	r4,-4(fp)
8110e6cc:	1105db00 	call	81105db0 <bFeebStartCh>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetWindowing(pxFeebCh);
8110e6d0:	e13fff17 	ldw	r4,-4(fp)
8110e6d4:	1105d280 	call	81105d28 <bFeebGetWindowing>
	pxFeebCh->xWindowingConfig.bMasking = DATA_PACKET;/* True= data packet;    FALSE= Transparent mode */
8110e6d8:	e0bfff17 	ldw	r2,-4(fp)
8110e6dc:	10000115 	stw	zero,4(r2)
	bFeebSetWindowing(pxFeebCh);
8110e6e0:	e13fff17 	ldw	r4,-4(fp)
8110e6e4:	1105c800 	call	81105c80 <bFeebSetWindowing>

	/*Enable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110e6e8:	e13fff17 	ldw	r4,-4(fp)
8110e6ec:	1105aa00 	call	81105aa0 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = TRUE;
8110e6f0:	e0bfff17 	ldw	r2,-4(fp)
8110e6f4:	00c00044 	movi	r3,1
8110e6f8:	10c00215 	stw	r3,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = TRUE;
8110e6fc:	e0bfff17 	ldw	r2,-4(fp)
8110e700:	00c00044 	movi	r3,1
8110e704:	10c00315 	stw	r3,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110e708:	e13fff17 	ldw	r4,-4(fp)
8110e70c:	11059cc0 	call	811059cc <bFeebSetIrqControl>

	/*todo: No treatment for now  */
	return TRUE;
8110e710:	00800044 	movi	r2,1
}
8110e714:	e037883a 	mov	sp,fp
8110e718:	dfc00117 	ldw	ra,4(sp)
8110e71c:	df000017 	ldw	fp,0(sp)
8110e720:	dec00204 	addi	sp,sp,8
8110e724:	f800283a 	ret

8110e728 <bDisAndClrDbBuffer>:


bool bDisAndClrDbBuffer( TFeebChannel *pxFeebCh ) {
8110e728:	defffd04 	addi	sp,sp,-12
8110e72c:	de00012e 	bgeu	sp,et,8110e734 <bDisAndClrDbBuffer+0xc>
8110e730:	003b68fa 	trap	3
8110e734:	dfc00215 	stw	ra,8(sp)
8110e738:	df000115 	stw	fp,4(sp)
8110e73c:	df000104 	addi	fp,sp,4
8110e740:	e13fff15 	stw	r4,-4(fp)

	/*Disable IRQ of FEE Buffer*/
	bFeebGetIrqControl(pxFeebCh);
8110e744:	e13fff17 	ldw	r4,-4(fp)
8110e748:	1105aa00 	call	81105aa0 <bFeebGetIrqControl>
	pxFeebCh->xIrqControl.bLeftBufferEmptyEn = FALSE;
8110e74c:	e0bfff17 	ldw	r2,-4(fp)
8110e750:	10000215 	stw	zero,8(r2)
	pxFeebCh->xIrqControl.bRightBufferEmptyEn = FALSE;
8110e754:	e0bfff17 	ldw	r2,-4(fp)
8110e758:	10000315 	stw	zero,12(r2)
	bFeebSetIrqControl(pxFeebCh);
8110e75c:	e13fff17 	ldw	r4,-4(fp)
8110e760:	11059cc0 	call	811059cc <bFeebSetIrqControl>

	/* Stop the module Double Buffer */
	bFeebStopCh(pxFeebCh);
8110e764:	e13fff17 	ldw	r4,-4(fp)
8110e768:	1105e380 	call	81105e38 <bFeebStopCh>

	/* Clear all buffer form the Double Buffer */
	bFeebClrCh(pxFeebCh);
8110e76c:	e13fff17 	ldw	r4,-4(fp)
8110e770:	1105ec00 	call	81105ec0 <bFeebClrCh>

	/*todo: No treatment for now  */
	return TRUE;
8110e774:	00800044 	movi	r2,1
}
8110e778:	e037883a 	mov	sp,fp
8110e77c:	dfc00117 	ldw	ra,4(sp)
8110e780:	df000017 	ldw	fp,0(sp)
8110e784:	dec00204 	addi	sp,sp,8
8110e788:	f800283a 	ret

8110e78c <bSendRequestNFeeCtrl>:

bool bSendRequestNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110e78c:	defff804 	addi	sp,sp,-32
8110e790:	de00012e 	bgeu	sp,et,8110e798 <bSendRequestNFeeCtrl+0xc>
8110e794:	003b68fa 	trap	3
8110e798:	dfc00715 	stw	ra,28(sp)
8110e79c:	df000615 	stw	fp,24(sp)
8110e7a0:	df000604 	addi	fp,sp,24
8110e7a4:	2807883a 	mov	r3,r5
8110e7a8:	3005883a 	mov	r2,r6
8110e7ac:	e13ffd05 	stb	r4,-12(fp)
8110e7b0:	e0fffe05 	stb	r3,-8(fp)
8110e7b4:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110e7b8:	00800404 	movi	r2,16
8110e7bc:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110e7c0:	e0bffd03 	ldbu	r2,-12(fp)
8110e7c4:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110e7c8:	e0bffe03 	ldbu	r2,-8(fp)
8110e7cc:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110e7d0:	e0bfff03 	ldbu	r2,-4(fp)
8110e7d4:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110e7d8:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xNfeeSchedule, (void *)uiCmdtoSend.ulWord);
8110e7dc:	d0a05917 	ldw	r2,-32412(gp)
8110e7e0:	e0fffc17 	ldw	r3,-16(fp)
8110e7e4:	180b883a 	mov	r5,r3
8110e7e8:	1009883a 	mov	r4,r2
8110e7ec:	113a0040 	call	8113a004 <OSQPost>
8110e7f0:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110e7f4:	e0bffb03 	ldbu	r2,-20(fp)
8110e7f8:	10000526 	beq	r2,zero,8110e810 <bSendRequestNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110e7fc:	e0bfff03 	ldbu	r2,-4(fp)
8110e800:	1009883a 	mov	r4,r2
8110e804:	11195a40 	call	811195a4 <vFailRequestDMA>
		bSuccesL = FALSE;
8110e808:	e03ffa15 	stw	zero,-24(fp)
8110e80c:	00000206 	br	8110e818 <bSendRequestNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110e810:	00800044 	movi	r2,1
8110e814:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110e818:	e0bffa17 	ldw	r2,-24(fp)
}
8110e81c:	e037883a 	mov	sp,fp
8110e820:	dfc00117 	ldw	ra,4(sp)
8110e824:	df000017 	ldw	fp,0(sp)
8110e828:	dec00204 	addi	sp,sp,8
8110e82c:	f800283a 	ret

8110e830 <bSendGiveBackNFeeCtrl>:


bool bSendGiveBackNFeeCtrl( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8110e830:	defff804 	addi	sp,sp,-32
8110e834:	de00012e 	bgeu	sp,et,8110e83c <bSendGiveBackNFeeCtrl+0xc>
8110e838:	003b68fa 	trap	3
8110e83c:	dfc00715 	stw	ra,28(sp)
8110e840:	df000615 	stw	fp,24(sp)
8110e844:	df000604 	addi	fp,sp,24
8110e848:	2807883a 	mov	r3,r5
8110e84c:	3005883a 	mov	r2,r6
8110e850:	e13ffd05 	stb	r4,-12(fp)
8110e854:	e0fffe05 	stb	r3,-8(fp)
8110e858:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
8110e85c:	00800404 	movi	r2,16
8110e860:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
8110e864:	e0bffd03 	ldbu	r2,-12(fp)
8110e868:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8110e86c:	e0bffe03 	ldbu	r2,-8(fp)
8110e870:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
8110e874:	e0bfff03 	ldbu	r2,-4(fp)
8110e878:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
8110e87c:	e03ffa15 	stw	zero,-24(fp)
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
8110e880:	d0a06c17 	ldw	r2,-32336(gp)
8110e884:	e0fffc17 	ldw	r3,-16(fp)
8110e888:	180b883a 	mov	r5,r3
8110e88c:	1009883a 	mov	r4,r2
8110e890:	113a0040 	call	8113a004 <OSQPost>
8110e894:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8110e898:	e0bffb03 	ldbu	r2,-20(fp)
8110e89c:	10000526 	beq	r2,zero,8110e8b4 <bSendGiveBackNFeeCtrl+0x84>
		vFailRequestDMA( ucValue );
8110e8a0:	e0bfff03 	ldbu	r2,-4(fp)
8110e8a4:	1009883a 	mov	r4,r2
8110e8a8:	11195a40 	call	811195a4 <vFailRequestDMA>
		bSuccesL = FALSE;
8110e8ac:	e03ffa15 	stw	zero,-24(fp)
8110e8b0:	00000206 	br	8110e8bc <bSendGiveBackNFeeCtrl+0x8c>
	} else {
		bSuccesL =  TRUE;
8110e8b4:	00800044 	movi	r2,1
8110e8b8:	e0bffa15 	stw	r2,-24(fp)
	}

	return bSuccesL;
8110e8bc:	e0bffa17 	ldw	r2,-24(fp)
}
8110e8c0:	e037883a 	mov	sp,fp
8110e8c4:	dfc00117 	ldw	ra,4(sp)
8110e8c8:	df000017 	ldw	fp,0(sp)
8110e8cc:	dec00204 	addi	sp,sp,8
8110e8d0:	f800283a 	ret

8110e8d4 <vPrintConsoleNFee>:




#ifdef DEBUG_ON
	void vPrintConsoleNFee( TNFee *pxNFeeI ) {
8110e8d4:	defffa04 	addi	sp,sp,-24
8110e8d8:	de00012e 	bgeu	sp,et,8110e8e0 <vPrintConsoleNFee+0xc>
8110e8dc:	003b68fa 	trap	3
8110e8e0:	dfc00515 	stw	ra,20(sp)
8110e8e4:	df000415 	stw	fp,16(sp)
8110e8e8:	df000404 	addi	fp,sp,16
8110e8ec:	e13fff15 	stw	r4,-4(fp)
		TNFee *pxNFee;

		pxNFee = pxNFeeI;
8110e8f0:	e0bfff17 	ldw	r2,-4(fp)
8110e8f4:	e0bffe15 	stw	r2,-8(fp)

		fprintf(fp,"=================================NFEE %hhu=====================================\n", pxNFee->ucId);
8110e8f8:	d0e05e17 	ldw	r3,-32392(gp)
8110e8fc:	e0bffe17 	ldw	r2,-8(fp)
8110e900:	10800003 	ldbu	r2,0(r2)
8110e904:	10803fcc 	andi	r2,r2,255
8110e908:	100d883a 	mov	r6,r2
8110e90c:	01604574 	movhi	r5,33045
8110e910:	2962f004 	addi	r5,r5,-29760
8110e914:	1809883a 	mov	r4,r3
8110e918:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110e91c:	d0a05e17 	ldw	r2,-32392(gp)
8110e920:	100b883a 	mov	r5,r2
8110e924:	01000284 	movi	r4,10
8110e928:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"NFEE %hhu CCD infos: \n", pxNFee->ucId);
8110e92c:	d0e05e17 	ldw	r3,-32392(gp)
8110e930:	e0bffe17 	ldw	r2,-8(fp)
8110e934:	10800003 	ldbu	r2,0(r2)
8110e938:	10803fcc 	andi	r2,r2,255
8110e93c:	100d883a 	mov	r6,r2
8110e940:	01604574 	movhi	r5,33045
8110e944:	29630504 	addi	r5,r5,-29676
8110e948:	1809883a 	mov	r4,r3
8110e94c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    PreScan = %hu \n", pxNFee->xCcdInfo.usiSPrescanN);
8110e950:	d0e05e17 	ldw	r3,-32392(gp)
8110e954:	e0bffe17 	ldw	r2,-8(fp)
8110e958:	10802f0b 	ldhu	r2,188(r2)
8110e95c:	10bfffcc 	andi	r2,r2,65535
8110e960:	100d883a 	mov	r6,r2
8110e964:	01604574 	movhi	r5,33045
8110e968:	29630b04 	addi	r5,r5,-29652
8110e96c:	1809883a 	mov	r4,r3
8110e970:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    OverScan = %hu \n", pxNFee->xCcdInfo.usiSOverscanN);
8110e974:	d0e05e17 	ldw	r3,-32392(gp)
8110e978:	e0bffe17 	ldw	r2,-8(fp)
8110e97c:	10802f8b 	ldhu	r2,190(r2)
8110e980:	10bfffcc 	andi	r2,r2,65535
8110e984:	100d883a 	mov	r6,r2
8110e988:	01604574 	movhi	r5,33045
8110e98c:	29631004 	addi	r5,r5,-29632
8110e990:	1809883a 	mov	r4,r3
8110e994:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    OLN = %hu \n", pxNFee->xCcdInfo.usiOLN);
8110e998:	d0e05e17 	ldw	r3,-32392(gp)
8110e99c:	e0bffe17 	ldw	r2,-8(fp)
8110e9a0:	1080300b 	ldhu	r2,192(r2)
8110e9a4:	10bfffcc 	andi	r2,r2,65535
8110e9a8:	100d883a 	mov	r6,r2
8110e9ac:	01604574 	movhi	r5,33045
8110e9b0:	29631604 	addi	r5,r5,-29608
8110e9b4:	1809883a 	mov	r4,r3
8110e9b8:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Half Width = %hu \n", pxNFee->xCcdInfo.usiHalfWidth);
8110e9bc:	d0e05e17 	ldw	r3,-32392(gp)
8110e9c0:	e0bffe17 	ldw	r2,-8(fp)
8110e9c4:	1080308b 	ldhu	r2,194(r2)
8110e9c8:	10bfffcc 	andi	r2,r2,65535
8110e9cc:	100d883a 	mov	r6,r2
8110e9d0:	01604574 	movhi	r5,33045
8110e9d4:	29631a04 	addi	r5,r5,-29592
8110e9d8:	1809883a 	mov	r4,r3
8110e9dc:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Height = %hu \n", pxNFee->xCcdInfo.usiHeight);
8110e9e0:	d0e05e17 	ldw	r3,-32392(gp)
8110e9e4:	e0bffe17 	ldw	r2,-8(fp)
8110e9e8:	1080310b 	ldhu	r2,196(r2)
8110e9ec:	10bfffcc 	andi	r2,r2,65535
8110e9f0:	100d883a 	mov	r6,r2
8110e9f4:	01604574 	movhi	r5,33045
8110e9f8:	29632004 	addi	r5,r5,-29568
8110e9fc:	1809883a 	mov	r4,r3
8110ea00:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110ea04:	d0a05e17 	ldw	r2,-32392(gp)
8110ea08:	100b883a 	mov	r5,r2
8110ea0c:	01000284 	movi	r4,10
8110ea10:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"NFEE %hhu Control: \n", pxNFee->ucId);
8110ea14:	d0e05e17 	ldw	r3,-32392(gp)
8110ea18:	e0bffe17 	ldw	r2,-8(fp)
8110ea1c:	10800003 	ldbu	r2,0(r2)
8110ea20:	10803fcc 	andi	r2,r2,255
8110ea24:	100d883a 	mov	r6,r2
8110ea28:	01604574 	movhi	r5,33045
8110ea2c:	29632504 	addi	r5,r5,-29548
8110ea30:	1809883a 	mov	r4,r3
8110ea34:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    NFEE State 	= %hu \n", pxNFee->xControl.eMode);
8110ea38:	d0e05e17 	ldw	r3,-32392(gp)
8110ea3c:	e0bffe17 	ldw	r2,-8(fp)
8110ea40:	10802c17 	ldw	r2,176(r2)
8110ea44:	100d883a 	mov	r6,r2
8110ea48:	01604574 	movhi	r5,33045
8110ea4c:	29632b04 	addi	r5,r5,-29524
8110ea50:	1809883a 	mov	r4,r3
8110ea54:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    NFEE Enable? = %hu \n", pxNFee->xControl.bEnabled);
8110ea58:	d0e05e17 	ldw	r3,-32392(gp)
8110ea5c:	e0bffe17 	ldw	r2,-8(fp)
8110ea60:	10802117 	ldw	r2,132(r2)
8110ea64:	100d883a 	mov	r6,r2
8110ea68:	01604574 	movhi	r5,33045
8110ea6c:	29633104 	addi	r5,r5,-29500
8110ea70:	1809883a 	mov	r4,r3
8110ea74:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Using DMA?   = %hu \n", pxNFee->xControl.bUsingDMA);
8110ea78:	d0e05e17 	ldw	r3,-32392(gp)
8110ea7c:	e0bffe17 	ldw	r2,-8(fp)
8110ea80:	10802317 	ldw	r2,140(r2)
8110ea84:	100d883a 	mov	r6,r2
8110ea88:	01604574 	movhi	r5,33045
8110ea8c:	29633804 	addi	r5,r5,-29472
8110ea90:	1809883a 	mov	r4,r3
8110ea94:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Logging?     = %hu \n", pxNFee->xControl.bLogging);
8110ea98:	d0e05e17 	ldw	r3,-32392(gp)
8110ea9c:	e0bffe17 	ldw	r2,-8(fp)
8110eaa0:	10802417 	ldw	r2,144(r2)
8110eaa4:	100d883a 	mov	r6,r2
8110eaa8:	01604574 	movhi	r5,33045
8110eaac:	29633f04 	addi	r5,r5,-29444
8110eab0:	1809883a 	mov	r4,r3
8110eab4:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Echoing?     = %hu \n", pxNFee->xControl.bEchoing);
8110eab8:	d0e05e17 	ldw	r3,-32392(gp)
8110eabc:	e0bffe17 	ldw	r2,-8(fp)
8110eac0:	10802517 	ldw	r2,148(r2)
8110eac4:	100d883a 	mov	r6,r2
8110eac8:	01604574 	movhi	r5,33045
8110eacc:	29634604 	addi	r5,r5,-29416
8110ead0:	1809883a 	mov	r4,r3
8110ead4:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Channel Enable? = %hu \n", pxNFee->xControl.bChannelEnable);
8110ead8:	d0e05e17 	ldw	r3,-32392(gp)
8110eadc:	e0bffe17 	ldw	r2,-8(fp)
8110eae0:	10802617 	ldw	r2,152(r2)
8110eae4:	100d883a 	mov	r6,r2
8110eae8:	01604574 	movhi	r5,33045
8110eaec:	29634d04 	addi	r5,r5,-29388
8110eaf0:	1809883a 	mov	r4,r3
8110eaf4:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Readout order = [ %hhu , %hhu , %hhu , %hhu ] \n", pxNFee->xControl.ucROutOrder[0], pxNFee->xControl.ucROutOrder[1], pxNFee->xControl.ucROutOrder[2], pxNFee->xControl.ucROutOrder[3]);
8110eaf8:	d1205e17 	ldw	r4,-32392(gp)
8110eafc:	e0bffe17 	ldw	r2,-8(fp)
8110eb00:	10802a43 	ldbu	r2,169(r2)
8110eb04:	11403fcc 	andi	r5,r2,255
8110eb08:	e0bffe17 	ldw	r2,-8(fp)
8110eb0c:	10802a83 	ldbu	r2,170(r2)
8110eb10:	11803fcc 	andi	r6,r2,255
8110eb14:	e0bffe17 	ldw	r2,-8(fp)
8110eb18:	10802ac3 	ldbu	r2,171(r2)
8110eb1c:	10803fcc 	andi	r2,r2,255
8110eb20:	e0fffe17 	ldw	r3,-8(fp)
8110eb24:	18c02b03 	ldbu	r3,172(r3)
8110eb28:	18c03fcc 	andi	r3,r3,255
8110eb2c:	d8c00115 	stw	r3,4(sp)
8110eb30:	d8800015 	stw	r2,0(sp)
8110eb34:	300f883a 	mov	r7,r6
8110eb38:	280d883a 	mov	r6,r5
8110eb3c:	01604574 	movhi	r5,33045
8110eb40:	29635404 	addi	r5,r5,-29360
8110eb44:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    CCD Side = = %hu \n", pxNFee->xControl.eSide);
8110eb48:	d0e05e17 	ldw	r3,-32392(gp)
8110eb4c:	e0bffe17 	ldw	r2,-8(fp)
8110eb50:	10802e17 	ldw	r2,184(r2)
8110eb54:	100d883a 	mov	r6,r2
8110eb58:	01604574 	movhi	r5,33045
8110eb5c:	29636104 	addi	r5,r5,-29308
8110eb60:	1809883a 	mov	r4,r3
8110eb64:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n\n");
8110eb68:	d0a05e17 	ldw	r2,-32392(gp)
8110eb6c:	100f883a 	mov	r7,r2
8110eb70:	01800084 	movi	r6,2
8110eb74:	01400044 	movi	r5,1
8110eb78:	01204574 	movhi	r4,33045
8110eb7c:	21236704 	addi	r4,r4,-29284
8110eb80:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"NFEE %hhu MEMORY MAP: \n", pxNFee->ucId);
8110eb84:	d0e05e17 	ldw	r3,-32392(gp)
8110eb88:	e0bffe17 	ldw	r2,-8(fp)
8110eb8c:	10800003 	ldbu	r2,0(r2)
8110eb90:	10803fcc 	andi	r2,r2,255
8110eb94:	100d883a 	mov	r6,r2
8110eb98:	01604574 	movhi	r5,33045
8110eb9c:	29636804 	addi	r5,r5,-29280
8110eba0:	1809883a 	mov	r4,r3
8110eba4:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    General Info: \n");
8110eba8:	d0a05e17 	ldw	r2,-32392(gp)
8110ebac:	100f883a 	mov	r7,r2
8110ebb0:	018004c4 	movi	r6,19
8110ebb4:	01400044 	movi	r5,1
8110ebb8:	01204574 	movhi	r4,33045
8110ebbc:	21236e04 	addi	r4,r4,-29256
8110ebc0:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"        Offset root 	= %lu \n", pxNFee->xMemMap.ulOffsetRoot);
8110ebc4:	d0e05e17 	ldw	r3,-32392(gp)
8110ebc8:	e0bffe17 	ldw	r2,-8(fp)
8110ebcc:	10800117 	ldw	r2,4(r2)
8110ebd0:	100d883a 	mov	r6,r2
8110ebd4:	01604574 	movhi	r5,33045
8110ebd8:	29637304 	addi	r5,r5,-29236
8110ebdc:	1809883a 	mov	r4,r3
8110ebe0:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Total Bytes 	= %lu \n", pxNFee->xMemMap.ulTotalBytes);
8110ebe4:	d0e05e17 	ldw	r3,-32392(gp)
8110ebe8:	e0bffe17 	ldw	r2,-8(fp)
8110ebec:	10800217 	ldw	r2,8(r2)
8110ebf0:	100d883a 	mov	r6,r2
8110ebf4:	01604574 	movhi	r5,33045
8110ebf8:	29637b04 	addi	r5,r5,-29204
8110ebfc:	1809883a 	mov	r4,r3
8110ec00:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        LUT ADDR 	= %lu \n", pxNFee->xMemMap.ulLUTAddr);
8110ec04:	d0e05e17 	ldw	r3,-32392(gp)
8110ec08:	e0bffe17 	ldw	r2,-8(fp)
8110ec0c:	10800317 	ldw	r2,12(r2)
8110ec10:	100d883a 	mov	r6,r2
8110ec14:	01604574 	movhi	r5,33045
8110ec18:	29638304 	addi	r5,r5,-29172
8110ec1c:	1809883a 	mov	r4,r3
8110ec20:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"    Common to all CCDs: \n");
8110ec24:	d0a05e17 	ldw	r2,-32392(gp)
8110ec28:	100f883a 	mov	r7,r2
8110ec2c:	01800644 	movi	r6,25
8110ec30:	01400044 	movi	r5,1
8110ec34:	01204574 	movhi	r4,33045
8110ec38:	21238a04 	addi	r4,r4,-29144
8110ec3c:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"        Total Bytes 	= %hu \n", pxNFee->xMemMap.xCommon.usiTotalBytes);
8110ec40:	d0e05e17 	ldw	r3,-32392(gp)
8110ec44:	e0bffe17 	ldw	r2,-8(fp)
8110ec48:	10800517 	ldw	r2,20(r2)
8110ec4c:	100d883a 	mov	r6,r2
8110ec50:	01604574 	movhi	r5,33045
8110ec54:	29639104 	addi	r5,r5,-29116
8110ec58:	1809883a 	mov	r4,r3
8110ec5c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Total of Blocks = %hu \n", pxNFee->xMemMap.xCommon.usiNTotalBlocks);
8110ec60:	d0e05e17 	ldw	r3,-32392(gp)
8110ec64:	e0bffe17 	ldw	r2,-8(fp)
8110ec68:	10800417 	ldw	r2,16(r2)
8110ec6c:	100d883a 	mov	r6,r2
8110ec70:	01604574 	movhi	r5,33045
8110ec74:	29639904 	addi	r5,r5,-29084
8110ec78:	1809883a 	mov	r4,r3
8110ec7c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Padding Bytes 	= %hhu\n", pxNFee->xMemMap.xCommon.ucPaddingBytes);
8110ec80:	d0e05e17 	ldw	r3,-32392(gp)
8110ec84:	e0bffe17 	ldw	r2,-8(fp)
8110ec88:	10800603 	ldbu	r2,24(r2)
8110ec8c:	10803fcc 	andi	r2,r2,255
8110ec90:	100d883a 	mov	r6,r2
8110ec94:	01604574 	movhi	r5,33045
8110ec98:	2963a104 	addi	r5,r5,-29052
8110ec9c:	1809883a 	mov	r4,r3
8110eca0:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Padding MASK 	= %llu\n", pxNFee->xMemMap.xCommon.ucPaddingMask.ullWord);
8110eca4:	d2205e17 	ldw	r8,-32392(gp)
8110eca8:	e13ffe17 	ldw	r4,-8(fp)
8110ecac:	20800717 	ldw	r2,28(r4)
8110ecb0:	20c00817 	ldw	r3,32(r4)
8110ecb4:	100d883a 	mov	r6,r2
8110ecb8:	180f883a 	mov	r7,r3
8110ecbc:	01604574 	movhi	r5,33045
8110ecc0:	2963a904 	addi	r5,r5,-29020
8110ecc4:	4009883a 	mov	r4,r8
8110ecc8:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110eccc:	d0a05e17 	ldw	r2,-32392(gp)
8110ecd0:	100b883a 	mov	r5,r2
8110ecd4:	01000284 	movi	r4,10
8110ecd8:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 0 , pxNFee->ucId);
8110ecdc:	d0e05e17 	ldw	r3,-32392(gp)
8110ece0:	e0bffe17 	ldw	r2,-8(fp)
8110ece4:	10800003 	ldbu	r2,0(r2)
8110ece8:	10803fcc 	andi	r2,r2,255
8110ecec:	100f883a 	mov	r7,r2
8110ecf0:	000d883a 	mov	r6,zero
8110ecf4:	01604574 	movhi	r5,33045
8110ecf8:	2963b104 	addi	r5,r5,-28988
8110ecfc:	1809883a 	mov	r4,r3
8110ed00:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Left side \n");
8110ed04:	d0a05e17 	ldw	r2,-32392(gp)
8110ed08:	100f883a 	mov	r7,r2
8110ed0c:	018004c4 	movi	r6,19
8110ed10:	01400044 	movi	r5,1
8110ed14:	01204574 	movhi	r4,33045
8110ed18:	2123bb04 	addi	r4,r4,-28948
8110ed1c:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulOffsetAddr);
8110ed20:	d0e05e17 	ldw	r3,-32392(gp)
8110ed24:	e0bffe17 	ldw	r2,-8(fp)
8110ed28:	10800917 	ldw	r2,36(r2)
8110ed2c:	100d883a 	mov	r6,r2
8110ed30:	01604574 	movhi	r5,33045
8110ed34:	2963c004 	addi	r5,r5,-28928
8110ed38:	1809883a 	mov	r4,r3
8110ed3c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulBlockI);
8110ed40:	d0e05e17 	ldw	r3,-32392(gp)
8110ed44:	e0bffe17 	ldw	r2,-8(fp)
8110ed48:	10800a17 	ldw	r2,40(r2)
8110ed4c:	100d883a 	mov	r6,r2
8110ed50:	01604574 	movhi	r5,33045
8110ed54:	2963c904 	addi	r5,r5,-28892
8110ed58:	1809883a 	mov	r4,r3
8110ed5c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xLeft.ulAddrI);
8110ed60:	d0e05e17 	ldw	r3,-32392(gp)
8110ed64:	e0bffe17 	ldw	r2,-8(fp)
8110ed68:	10800b17 	ldw	r2,44(r2)
8110ed6c:	100d883a 	mov	r6,r2
8110ed70:	01604574 	movhi	r5,33045
8110ed74:	2963d404 	addi	r5,r5,-28848
8110ed78:	1809883a 	mov	r4,r3
8110ed7c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Right side \n");
8110ed80:	d0a05e17 	ldw	r2,-32392(gp)
8110ed84:	100f883a 	mov	r7,r2
8110ed88:	01800504 	movi	r6,20
8110ed8c:	01400044 	movi	r5,1
8110ed90:	01204574 	movhi	r4,33045
8110ed94:	2123e004 	addi	r4,r4,-28800
8110ed98:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulOffsetAddr);
8110ed9c:	d0e05e17 	ldw	r3,-32392(gp)
8110eda0:	e0bffe17 	ldw	r2,-8(fp)
8110eda4:	10800c17 	ldw	r2,48(r2)
8110eda8:	100d883a 	mov	r6,r2
8110edac:	01604574 	movhi	r5,33045
8110edb0:	2963c004 	addi	r5,r5,-28928
8110edb4:	1809883a 	mov	r4,r3
8110edb8:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulBlockI);
8110edbc:	d0e05e17 	ldw	r3,-32392(gp)
8110edc0:	e0bffe17 	ldw	r2,-8(fp)
8110edc4:	10800d17 	ldw	r2,52(r2)
8110edc8:	100d883a 	mov	r6,r2
8110edcc:	01604574 	movhi	r5,33045
8110edd0:	2963c904 	addi	r5,r5,-28892
8110edd4:	1809883a 	mov	r4,r3
8110edd8:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[0].xRight.ulAddrI);
8110eddc:	d0e05e17 	ldw	r3,-32392(gp)
8110ede0:	e0bffe17 	ldw	r2,-8(fp)
8110ede4:	10800e17 	ldw	r2,56(r2)
8110ede8:	100d883a 	mov	r6,r2
8110edec:	01604574 	movhi	r5,33045
8110edf0:	2963d404 	addi	r5,r5,-28848
8110edf4:	1809883a 	mov	r4,r3
8110edf8:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110edfc:	d0a05e17 	ldw	r2,-32392(gp)
8110ee00:	100b883a 	mov	r5,r2
8110ee04:	01000284 	movi	r4,10
8110ee08:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 1 , pxNFee->ucId);
8110ee0c:	d0e05e17 	ldw	r3,-32392(gp)
8110ee10:	e0bffe17 	ldw	r2,-8(fp)
8110ee14:	10800003 	ldbu	r2,0(r2)
8110ee18:	10803fcc 	andi	r2,r2,255
8110ee1c:	100f883a 	mov	r7,r2
8110ee20:	01800044 	movi	r6,1
8110ee24:	01604574 	movhi	r5,33045
8110ee28:	2963b104 	addi	r5,r5,-28988
8110ee2c:	1809883a 	mov	r4,r3
8110ee30:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Left side \n");
8110ee34:	d0a05e17 	ldw	r2,-32392(gp)
8110ee38:	100f883a 	mov	r7,r2
8110ee3c:	018004c4 	movi	r6,19
8110ee40:	01400044 	movi	r5,1
8110ee44:	01204574 	movhi	r4,33045
8110ee48:	2123bb04 	addi	r4,r4,-28948
8110ee4c:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulOffsetAddr);
8110ee50:	d0e05e17 	ldw	r3,-32392(gp)
8110ee54:	e0bffe17 	ldw	r2,-8(fp)
8110ee58:	10800f17 	ldw	r2,60(r2)
8110ee5c:	100d883a 	mov	r6,r2
8110ee60:	01604574 	movhi	r5,33045
8110ee64:	2963c004 	addi	r5,r5,-28928
8110ee68:	1809883a 	mov	r4,r3
8110ee6c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulBlockI);
8110ee70:	d0e05e17 	ldw	r3,-32392(gp)
8110ee74:	e0bffe17 	ldw	r2,-8(fp)
8110ee78:	10801017 	ldw	r2,64(r2)
8110ee7c:	100d883a 	mov	r6,r2
8110ee80:	01604574 	movhi	r5,33045
8110ee84:	2963c904 	addi	r5,r5,-28892
8110ee88:	1809883a 	mov	r4,r3
8110ee8c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xLeft.ulAddrI);
8110ee90:	d0e05e17 	ldw	r3,-32392(gp)
8110ee94:	e0bffe17 	ldw	r2,-8(fp)
8110ee98:	10801117 	ldw	r2,68(r2)
8110ee9c:	100d883a 	mov	r6,r2
8110eea0:	01604574 	movhi	r5,33045
8110eea4:	2963d404 	addi	r5,r5,-28848
8110eea8:	1809883a 	mov	r4,r3
8110eeac:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Right side \n");
8110eeb0:	d0a05e17 	ldw	r2,-32392(gp)
8110eeb4:	100f883a 	mov	r7,r2
8110eeb8:	01800504 	movi	r6,20
8110eebc:	01400044 	movi	r5,1
8110eec0:	01204574 	movhi	r4,33045
8110eec4:	2123e004 	addi	r4,r4,-28800
8110eec8:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulOffsetAddr);
8110eecc:	d0e05e17 	ldw	r3,-32392(gp)
8110eed0:	e0bffe17 	ldw	r2,-8(fp)
8110eed4:	10801217 	ldw	r2,72(r2)
8110eed8:	100d883a 	mov	r6,r2
8110eedc:	01604574 	movhi	r5,33045
8110eee0:	2963c004 	addi	r5,r5,-28928
8110eee4:	1809883a 	mov	r4,r3
8110eee8:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulBlockI);
8110eeec:	d0e05e17 	ldw	r3,-32392(gp)
8110eef0:	e0bffe17 	ldw	r2,-8(fp)
8110eef4:	10801317 	ldw	r2,76(r2)
8110eef8:	100d883a 	mov	r6,r2
8110eefc:	01604574 	movhi	r5,33045
8110ef00:	2963c904 	addi	r5,r5,-28892
8110ef04:	1809883a 	mov	r4,r3
8110ef08:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[1].xRight.ulAddrI);
8110ef0c:	d0e05e17 	ldw	r3,-32392(gp)
8110ef10:	e0bffe17 	ldw	r2,-8(fp)
8110ef14:	10801417 	ldw	r2,80(r2)
8110ef18:	100d883a 	mov	r6,r2
8110ef1c:	01604574 	movhi	r5,33045
8110ef20:	2963d404 	addi	r5,r5,-28848
8110ef24:	1809883a 	mov	r4,r3
8110ef28:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110ef2c:	d0a05e17 	ldw	r2,-32392(gp)
8110ef30:	100b883a 	mov	r5,r2
8110ef34:	01000284 	movi	r4,10
8110ef38:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 2 , pxNFee->ucId);
8110ef3c:	d0e05e17 	ldw	r3,-32392(gp)
8110ef40:	e0bffe17 	ldw	r2,-8(fp)
8110ef44:	10800003 	ldbu	r2,0(r2)
8110ef48:	10803fcc 	andi	r2,r2,255
8110ef4c:	100f883a 	mov	r7,r2
8110ef50:	01800084 	movi	r6,2
8110ef54:	01604574 	movhi	r5,33045
8110ef58:	2963b104 	addi	r5,r5,-28988
8110ef5c:	1809883a 	mov	r4,r3
8110ef60:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Left side \n");
8110ef64:	d0a05e17 	ldw	r2,-32392(gp)
8110ef68:	100f883a 	mov	r7,r2
8110ef6c:	018004c4 	movi	r6,19
8110ef70:	01400044 	movi	r5,1
8110ef74:	01204574 	movhi	r4,33045
8110ef78:	2123bb04 	addi	r4,r4,-28948
8110ef7c:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulOffsetAddr);
8110ef80:	d0e05e17 	ldw	r3,-32392(gp)
8110ef84:	e0bffe17 	ldw	r2,-8(fp)
8110ef88:	10801517 	ldw	r2,84(r2)
8110ef8c:	100d883a 	mov	r6,r2
8110ef90:	01604574 	movhi	r5,33045
8110ef94:	2963c004 	addi	r5,r5,-28928
8110ef98:	1809883a 	mov	r4,r3
8110ef9c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulBlockI);
8110efa0:	d0e05e17 	ldw	r3,-32392(gp)
8110efa4:	e0bffe17 	ldw	r2,-8(fp)
8110efa8:	10801617 	ldw	r2,88(r2)
8110efac:	100d883a 	mov	r6,r2
8110efb0:	01604574 	movhi	r5,33045
8110efb4:	2963c904 	addi	r5,r5,-28892
8110efb8:	1809883a 	mov	r4,r3
8110efbc:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xLeft.ulAddrI);
8110efc0:	d0e05e17 	ldw	r3,-32392(gp)
8110efc4:	e0bffe17 	ldw	r2,-8(fp)
8110efc8:	10801717 	ldw	r2,92(r2)
8110efcc:	100d883a 	mov	r6,r2
8110efd0:	01604574 	movhi	r5,33045
8110efd4:	2963d404 	addi	r5,r5,-28848
8110efd8:	1809883a 	mov	r4,r3
8110efdc:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Right side \n");
8110efe0:	d0a05e17 	ldw	r2,-32392(gp)
8110efe4:	100f883a 	mov	r7,r2
8110efe8:	01800504 	movi	r6,20
8110efec:	01400044 	movi	r5,1
8110eff0:	01204574 	movhi	r4,33045
8110eff4:	2123e004 	addi	r4,r4,-28800
8110eff8:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulOffsetAddr);
8110effc:	d0e05e17 	ldw	r3,-32392(gp)
8110f000:	e0bffe17 	ldw	r2,-8(fp)
8110f004:	10801817 	ldw	r2,96(r2)
8110f008:	100d883a 	mov	r6,r2
8110f00c:	01604574 	movhi	r5,33045
8110f010:	2963c004 	addi	r5,r5,-28928
8110f014:	1809883a 	mov	r4,r3
8110f018:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulBlockI);
8110f01c:	d0e05e17 	ldw	r3,-32392(gp)
8110f020:	e0bffe17 	ldw	r2,-8(fp)
8110f024:	10801917 	ldw	r2,100(r2)
8110f028:	100d883a 	mov	r6,r2
8110f02c:	01604574 	movhi	r5,33045
8110f030:	2963c904 	addi	r5,r5,-28892
8110f034:	1809883a 	mov	r4,r3
8110f038:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[2].xRight.ulAddrI);
8110f03c:	d0e05e17 	ldw	r3,-32392(gp)
8110f040:	e0bffe17 	ldw	r2,-8(fp)
8110f044:	10801a17 	ldw	r2,104(r2)
8110f048:	100d883a 	mov	r6,r2
8110f04c:	01604574 	movhi	r5,33045
8110f050:	2963d404 	addi	r5,r5,-28848
8110f054:	1809883a 	mov	r4,r3
8110f058:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110f05c:	d0a05e17 	ldw	r2,-32392(gp)
8110f060:	100b883a 	mov	r5,r2
8110f064:	01000284 	movi	r4,10
8110f068:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"    CCD %hhu - NFEE %hhu MEMORY MAP: \n", 3 , pxNFee->ucId);
8110f06c:	d0e05e17 	ldw	r3,-32392(gp)
8110f070:	e0bffe17 	ldw	r2,-8(fp)
8110f074:	10800003 	ldbu	r2,0(r2)
8110f078:	10803fcc 	andi	r2,r2,255
8110f07c:	100f883a 	mov	r7,r2
8110f080:	018000c4 	movi	r6,3
8110f084:	01604574 	movhi	r5,33045
8110f088:	2963b104 	addi	r5,r5,-28988
8110f08c:	1809883a 	mov	r4,r3
8110f090:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Left side \n");
8110f094:	d0a05e17 	ldw	r2,-32392(gp)
8110f098:	100f883a 	mov	r7,r2
8110f09c:	018004c4 	movi	r6,19
8110f0a0:	01400044 	movi	r5,1
8110f0a4:	01204574 	movhi	r4,33045
8110f0a8:	2123bb04 	addi	r4,r4,-28948
8110f0ac:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulOffsetAddr);
8110f0b0:	d0e05e17 	ldw	r3,-32392(gp)
8110f0b4:	e0bffe17 	ldw	r2,-8(fp)
8110f0b8:	10801b17 	ldw	r2,108(r2)
8110f0bc:	100d883a 	mov	r6,r2
8110f0c0:	01604574 	movhi	r5,33045
8110f0c4:	2963c004 	addi	r5,r5,-28928
8110f0c8:	1809883a 	mov	r4,r3
8110f0cc:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulBlockI);
8110f0d0:	d0e05e17 	ldw	r3,-32392(gp)
8110f0d4:	e0bffe17 	ldw	r2,-8(fp)
8110f0d8:	10801c17 	ldw	r2,112(r2)
8110f0dc:	100d883a 	mov	r6,r2
8110f0e0:	01604574 	movhi	r5,33045
8110f0e4:	2963c904 	addi	r5,r5,-28892
8110f0e8:	1809883a 	mov	r4,r3
8110f0ec:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xLeft.ulAddrI);
8110f0f0:	d0e05e17 	ldw	r3,-32392(gp)
8110f0f4:	e0bffe17 	ldw	r2,-8(fp)
8110f0f8:	10801d17 	ldw	r2,116(r2)
8110f0fc:	100d883a 	mov	r6,r2
8110f100:	01604574 	movhi	r5,33045
8110f104:	2963d404 	addi	r5,r5,-28848
8110f108:	1809883a 	mov	r4,r3
8110f10c:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"        Right side \n");
8110f110:	d0a05e17 	ldw	r2,-32392(gp)
8110f114:	100f883a 	mov	r7,r2
8110f118:	01800504 	movi	r6,20
8110f11c:	01400044 	movi	r5,1
8110f120:	01204574 	movhi	r4,33045
8110f124:	2123e004 	addi	r4,r4,-28800
8110f128:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"            Offset (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulOffsetAddr);
8110f12c:	d0e05e17 	ldw	r3,-32392(gp)
8110f130:	e0bffe17 	ldw	r2,-8(fp)
8110f134:	10801e17 	ldw	r2,120(r2)
8110f138:	100d883a 	mov	r6,r2
8110f13c:	01604574 	movhi	r5,33045
8110f140:	2963c004 	addi	r5,r5,-28928
8110f144:	1809883a 	mov	r4,r3
8110f148:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Block index (Blocks) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulBlockI);
8110f14c:	d0e05e17 	ldw	r3,-32392(gp)
8110f150:	e0bffe17 	ldw	r2,-8(fp)
8110f154:	10801f17 	ldw	r2,124(r2)
8110f158:	100d883a 	mov	r6,r2
8110f15c:	01604574 	movhi	r5,33045
8110f160:	2963c904 	addi	r5,r5,-28892
8110f164:	1809883a 	mov	r4,r3
8110f168:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"            Initial next block (Bytes) = %lu \n", pxNFee->xMemMap.xCcd[3].xRight.ulAddrI);
8110f16c:	d0e05e17 	ldw	r3,-32392(gp)
8110f170:	e0bffe17 	ldw	r2,-8(fp)
8110f174:	10802017 	ldw	r2,128(r2)
8110f178:	100d883a 	mov	r6,r2
8110f17c:	01604574 	movhi	r5,33045
8110f180:	2963d404 	addi	r5,r5,-28848
8110f184:	1809883a 	mov	r4,r3
8110f188:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"\n");
8110f18c:	d0a05e17 	ldw	r2,-32392(gp)
8110f190:	100b883a 	mov	r5,r2
8110f194:	01000284 	movi	r4,10
8110f198:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"==============================================================================\n");
8110f19c:	d0a05e17 	ldw	r2,-32392(gp)
8110f1a0:	100f883a 	mov	r7,r2
8110f1a4:	018013c4 	movi	r6,79
8110f1a8:	01400044 	movi	r5,1
8110f1ac:	01204574 	movhi	r4,33045
8110f1b0:	2123e604 	addi	r4,r4,-28776
8110f1b4:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"==============================================================================\n");
8110f1b8:	d0a05e17 	ldw	r2,-32392(gp)
8110f1bc:	100f883a 	mov	r7,r2
8110f1c0:	018013c4 	movi	r6,79
8110f1c4:	01400044 	movi	r5,1
8110f1c8:	01204574 	movhi	r4,33045
8110f1cc:	2123e604 	addi	r4,r4,-28776
8110f1d0:	111d0b40 	call	8111d0b4 <fwrite>
		fprintf(fp,"\n");
8110f1d4:	d0a05e17 	ldw	r2,-32392(gp)
8110f1d8:	100b883a 	mov	r5,r2
8110f1dc:	01000284 	movi	r4,10
8110f1e0:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"\n");
8110f1e4:	d0a05e17 	ldw	r2,-32392(gp)
8110f1e8:	100b883a 	mov	r5,r2
8110f1ec:	01000284 	movi	r4,10
8110f1f0:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"\n");
8110f1f4:	d0a05e17 	ldw	r2,-32392(gp)
8110f1f8:	100b883a 	mov	r5,r2
8110f1fc:	01000284 	movi	r4,10
8110f200:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"\n");
8110f204:	d0a05e17 	ldw	r2,-32392(gp)
8110f208:	100b883a 	mov	r5,r2
8110f20c:	01000284 	movi	r4,10
8110f210:	111ca900 	call	8111ca90 <fputc>
		fprintf(fp,"\n");
8110f214:	d0a05e17 	ldw	r2,-32392(gp)
8110f218:	100b883a 	mov	r5,r2
8110f21c:	01000284 	movi	r4,10
8110f220:	111ca900 	call	8111ca90 <fputc>
	}
8110f224:	0001883a 	nop
8110f228:	e037883a 	mov	sp,fp
8110f22c:	dfc00117 	ldw	ra,4(sp)
8110f230:	df000017 	ldw	fp,0(sp)
8110f234:	dec00204 	addi	sp,sp,8
8110f238:	f800283a 	ret

8110f23c <vInAckHandlerTaskV2>:


#include "in_ack_handler_task.h"


void vInAckHandlerTaskV2(void *task_data) {
8110f23c:	defff604 	addi	sp,sp,-40
8110f240:	de00012e 	bgeu	sp,et,8110f248 <vInAckHandlerTaskV2+0xc>
8110f244:	003b68fa 	trap	3
8110f248:	dfc00915 	stw	ra,36(sp)
8110f24c:	df000815 	stw	fp,32(sp)
8110f250:	df000804 	addi	fp,sp,32
8110f254:	e13fff15 	stw	r4,-4(fp)

	bool bFound = FALSE;
8110f258:	e03ff815 	stw	zero,-32(fp)
    bool bFinished32 = FALSE;
8110f25c:	e03ffb15 	stw	zero,-20(fp)
    bool bFinished64 = FALSE;
8110f260:	e03ffc15 	stw	zero,-16(fp)
    bool bFinished128 = FALSE;
8110f264:	e03ffd15 	stw	zero,-12(fp)
	INT8U error_code;
	tReceiverACKState eReceiverAckState;
	static txReceivedACK xRAckLocal;
    unsigned char ucHashVerification = 0;
8110f268:	e03ffa85 	stb	zero,-22(fp)
    unsigned char ucCountRetries = 0;
8110f26c:	e03ffa05 	stb	zero,-24(fp)
    unsigned char i = 0;
8110f270:	e03ffa45 	stb	zero,-23(fp)

    #ifdef DEBUG_ON
        debug(fp,"In Ack Handler Task. (Task on)\n");
8110f274:	d0a05e17 	ldw	r2,-32392(gp)
8110f278:	100f883a 	mov	r7,r2
8110f27c:	018007c4 	movi	r6,31
8110f280:	01400044 	movi	r5,1
8110f284:	01204574 	movhi	r4,33045
8110f288:	2123fa04 	addi	r4,r4,-28696
8110f28c:	111d0b40 	call	8111d0b4 <fwrite>
    #endif

	eReceiverAckState = sRAConfiguring;
8110f290:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eReceiverAckState) {
8110f294:	e0bff917 	ldw	r2,-28(fp)
8110f298:	10c00060 	cmpeqi	r3,r2,1
8110f29c:	1800071e 	bne	r3,zero,8110f2bc <vInAckHandlerTaskV2+0x80>
8110f2a0:	0080032e 	bgeu	zero,r2,8110f2b0 <vInAckHandlerTaskV2+0x74>
8110f2a4:	108000a0 	cmpeqi	r2,r2,2
8110f2a8:	10004a1e 	bne	r2,zero,8110f3d4 <vInAckHandlerTaskV2+0x198>
8110f2ac:	0000ac06 	br	8110f560 <vInAckHandlerTaskV2+0x324>
			case sRAConfiguring:
                /*For future implementations*/
                eReceiverAckState = sRAGettingACK;
8110f2b0:	00800044 	movi	r2,1
8110f2b4:	e0bff915 	stw	r2,-28(fp)
				break;
8110f2b8:	0000b306 	br	8110f588 <vInAckHandlerTaskV2+0x34c>
            case sRAGettingACK:
                eReceiverAckState = sRAGettingACK;
8110f2bc:	00800044 	movi	r2,1
8110f2c0:	e0bff915 	stw	r2,-28(fp)
                /* Waits the semaphore that indicates there are some ack message was received*/
                OSSemPend(xSemCountReceivedACK, 0, &error_code);
8110f2c4:	d0a06217 	ldw	r2,-32376(gp)
8110f2c8:	e0fffe04 	addi	r3,fp,-8
8110f2cc:	180d883a 	mov	r6,r3
8110f2d0:	000b883a 	mov	r5,zero
8110f2d4:	1009883a 	mov	r4,r2
8110f2d8:	113aaf40 	call	8113aaf4 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8110f2dc:	e0bffe03 	ldbu	r2,-8(fp)
8110f2e0:	10803fcc 	andi	r2,r2,255
8110f2e4:	1000391e 	bne	r2,zero,8110f3cc <vInAckHandlerTaskV2+0x190>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
8110f2e8:	d0a06117 	ldw	r2,-32380(gp)
8110f2ec:	e0fffe04 	addi	r3,fp,-8
8110f2f0:	180d883a 	mov	r6,r3
8110f2f4:	000b883a 	mov	r5,zero
8110f2f8:	1009883a 	mov	r4,r2
8110f2fc:	1138ae80 	call	81138ae8 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
8110f300:	e0bffe03 	ldbu	r2,-8(fp)
8110f304:	10803fcc 	andi	r2,r2,255
8110f308:	10002b1e 	bne	r2,zero,8110f3b8 <vInAckHandlerTaskV2+0x17c>

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110f30c:	e03ffa45 	stb	zero,-23(fp)
8110f310:	00002206 	br	8110f39c <vInAckHandlerTaskV2+0x160>
                        {
                            if ( xReceivedACK[i].cType != 0 ) {
8110f314:	e0fffa43 	ldbu	r3,-23(fp)
8110f318:	00a045b4 	movhi	r2,33046
8110f31c:	10b24204 	addi	r2,r2,-14072
8110f320:	18c7883a 	add	r3,r3,r3
8110f324:	18c7883a 	add	r3,r3,r3
8110f328:	10c5883a 	add	r2,r2,r3
8110f32c:	10800003 	ldbu	r2,0(r2)
8110f330:	10803fcc 	andi	r2,r2,255
8110f334:	1080201c 	xori	r2,r2,128
8110f338:	10bfe004 	addi	r2,r2,-128
8110f33c:	10001426 	beq	r2,zero,8110f390 <vInAckHandlerTaskV2+0x154>

                                /*  Nack don't get here */
                                xRAckLocal = xReceivedACK[i];
8110f340:	e0fffa43 	ldbu	r3,-23(fp)
8110f344:	00a045b4 	movhi	r2,33046
8110f348:	10b24204 	addi	r2,r2,-14072
8110f34c:	18c7883a 	add	r3,r3,r3
8110f350:	18c7883a 	add	r3,r3,r3
8110f354:	10c5883a 	add	r2,r2,r3
8110f358:	10c0000b 	ldhu	r3,0(r2)
8110f35c:	d0e0540d 	sth	r3,-32432(gp)
8110f360:	1080008b 	ldhu	r2,2(r2)
8110f364:	d0a0548d 	sth	r2,-32430(gp)
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
8110f368:	e0fffa43 	ldbu	r3,-23(fp)
8110f36c:	00a045b4 	movhi	r2,33046
8110f370:	10b24204 	addi	r2,r2,-14072
8110f374:	18c7883a 	add	r3,r3,r3
8110f378:	18c7883a 	add	r3,r3,r3
8110f37c:	10c5883a 	add	r2,r2,r3
8110f380:	10000005 	stb	zero,0(r2)
                                eReceiverAckState = sRACleanningBuffer;
8110f384:	00800084 	movi	r2,2
8110f388:	e0bff915 	stw	r2,-28(fp)
                                break;                                
8110f38c:	00000606 	br	8110f3a8 <vInAckHandlerTaskV2+0x16c>

                    OSMutexPend(xMutexReceivedACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {

                        /*Search for the ack*/
                        for(i = 0; i < N_ACKS_RECEIVED; i++)
8110f390:	e0bffa43 	ldbu	r2,-23(fp)
8110f394:	10800044 	addi	r2,r2,1
8110f398:	e0bffa45 	stb	r2,-23(fp)
8110f39c:	e0bffa43 	ldbu	r2,-23(fp)
8110f3a0:	108001b0 	cmpltui	r2,r2,6
8110f3a4:	103fdb1e 	bne	r2,zero,8110f314 <__reset+0xfb0ef314>
                                xReceivedACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                eReceiverAckState = sRACleanningBuffer;
                                break;                                
                            }
                        }
                        OSMutexPost(xMutexReceivedACK);
8110f3a8:	d0a06117 	ldw	r2,-32380(gp)
8110f3ac:	1009883a 	mov	r4,r2
8110f3b0:	113908c0 	call	8113908c <OSMutexPost>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110f3b4:	00007406 	br	8110f588 <vInAckHandlerTaskV2+0x34c>
                        OSMutexPost(xMutexReceivedACK);

                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                    	OSSemPost(xSemCountReceivedACK);
8110f3b8:	d0a06217 	ldw	r2,-32376(gp)
8110f3bc:	1009883a 	mov	r4,r2
8110f3c0:	113ae7c0 	call	8113ae7c <OSSemPost>
                    	vFailGetMutexReceiverTask();
8110f3c4:	1117e340 	call	81117e34 <vFailGetMutexReceiverTask>
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
                }
                break;
8110f3c8:	00006f06 	br	8110f588 <vInAckHandlerTaskV2+0x34c>
                    	vFailGetMutexReceiverTask();
                    }
                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreReceiverTask();
8110f3cc:	1117dcc0 	call	81117dcc <vFailGetCountSemaphoreReceiverTask>
                }
                break;
8110f3d0:	00006d06 	br	8110f588 <vInAckHandlerTaskV2+0x34c>
			case sRACleanningBuffer:
                /* Now a search will be performed in the three output buffer in order to find
                   the (re)transmission buffer identified by the id and erase it. */
                
                ucHashVerification = 0;
8110f3d4:	e03ffa85 	stb	zero,-22(fp)
                ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
8110f3d8:	d0a06483 	ldbu	r2,-32366(gp)
8110f3dc:	10803fcc 	andi	r2,r2,255
8110f3e0:	10800218 	cmpnei	r2,r2,8
8110f3e4:	1000021e 	bne	r2,zero,8110f3f0 <vInAckHandlerTaskV2+0x1b4>
8110f3e8:	00c00104 	movi	r3,4
8110f3ec:	00000106 	br	8110f3f4 <vInAckHandlerTaskV2+0x1b8>
8110f3f0:	0007883a 	mov	r3,zero
8110f3f4:	d0a07103 	ldbu	r2,-32316(gp)
8110f3f8:	10803fcc 	andi	r2,r2,255
8110f3fc:	10800218 	cmpnei	r2,r2,8
8110f400:	1000021e 	bne	r2,zero,8110f40c <vInAckHandlerTaskV2+0x1d0>
8110f404:	00800084 	movi	r2,2
8110f408:	00000106 	br	8110f410 <vInAckHandlerTaskV2+0x1d4>
8110f40c:	0005883a 	mov	r2,zero
8110f410:	1884b03a 	or	r2,r3,r2
8110f414:	1007883a 	mov	r3,r2
8110f418:	d0a07143 	ldbu	r2,-32315(gp)
8110f41c:	10803fcc 	andi	r2,r2,255
8110f420:	108001a0 	cmpeqi	r2,r2,6
8110f424:	1884b03a 	or	r2,r3,r2
8110f428:	1007883a 	mov	r3,r2
8110f42c:	e0bffa83 	ldbu	r2,-22(fp)
8110f430:	1884b03a 	or	r2,r3,r2
8110f434:	e0bffa85 	stb	r2,-22(fp)

                bFound = FALSE;
8110f438:	e03ff815 	stw	zero,-32(fp)
                bFinished32=FALSE;
8110f43c:	e03ffb15 	stw	zero,-20(fp)
                bFinished64=FALSE;
8110f440:	e03ffc15 	stw	zero,-16(fp)
                bFinished128=FALSE;
8110f444:	e03ffd15 	stw	zero,-12(fp)
                ucCountRetries = 0;
8110f448:	e03ffa05 	stb	zero,-24(fp)
                do
                {
                    ucCountRetries++;
8110f44c:	e0bffa03 	ldbu	r2,-24(fp)
8110f450:	10800044 	addi	r2,r2,1
8110f454:	e0bffa05 	stb	r2,-24(fp)

                    /* There are any spot used in the xBuffer128? */
                    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
8110f458:	e0bffa83 	ldbu	r2,-22(fp)
8110f45c:	1080004c 	andi	r2,r2,1
8110f460:	10803fcc 	andi	r2,r2,255
8110f464:	1000061e 	bne	r2,zero,8110f480 <vInAckHandlerTaskV2+0x244>
                        bFound = bCheckInAck128( &xRAckLocal, &bFinished128  );
8110f468:	e0bffd04 	addi	r2,fp,-12
8110f46c:	100b883a 	mov	r5,r2
8110f470:	d1205404 	addi	r4,gp,-32432
8110f474:	110f58c0 	call	8110f58c <bCheckInAck128>
8110f478:	e0bff815 	stw	r2,-32(fp)
8110f47c:	00000206 	br	8110f488 <vInAckHandlerTaskV2+0x24c>
                    else
                        bFinished128 = TRUE;
8110f480:	00800044 	movi	r2,1
8110f484:	e0bffd15 	stw	r2,-12(fp)

                    /* There are any spot used in the xBuffer64? */
                    if ( (0b00000010 != (0b00000010 & ucHashVerification )) && (bFound ==FALSE ) )
8110f488:	e0bffa83 	ldbu	r2,-22(fp)
8110f48c:	1080008c 	andi	r2,r2,2
8110f490:	10803fcc 	andi	r2,r2,255
8110f494:	1000081e 	bne	r2,zero,8110f4b8 <vInAckHandlerTaskV2+0x27c>
8110f498:	e0bff817 	ldw	r2,-32(fp)
8110f49c:	1000061e 	bne	r2,zero,8110f4b8 <vInAckHandlerTaskV2+0x27c>
                        bFound = bCheckInAck64( &xRAckLocal, &bFinished64 );
8110f4a0:	e0bffc04 	addi	r2,fp,-16
8110f4a4:	100b883a 	mov	r5,r2
8110f4a8:	d1205404 	addi	r4,gp,-32432
8110f4ac:	110f6d40 	call	8110f6d4 <bCheckInAck64>
8110f4b0:	e0bff815 	stw	r2,-32(fp)
8110f4b4:	00000206 	br	8110f4c0 <vInAckHandlerTaskV2+0x284>
                    else
                        bFinished64 = TRUE;
8110f4b8:	00800044 	movi	r2,1
8110f4bc:	e0bffc15 	stw	r2,-16(fp)

                    /* There are any spot used in the xBuffer32? */
                    if ( (0b00000100 != (0b00000100 & ucHashVerification ) ) && (bFound ==FALSE ) )
8110f4c0:	e0bffa83 	ldbu	r2,-22(fp)
8110f4c4:	1080010c 	andi	r2,r2,4
8110f4c8:	10803fcc 	andi	r2,r2,255
8110f4cc:	1000081e 	bne	r2,zero,8110f4f0 <vInAckHandlerTaskV2+0x2b4>
8110f4d0:	e0bff817 	ldw	r2,-32(fp)
8110f4d4:	1000061e 	bne	r2,zero,8110f4f0 <vInAckHandlerTaskV2+0x2b4>
                        bFound = bCheckInAck32( &xRAckLocal, &bFinished32  );
8110f4d8:	e0bffb04 	addi	r2,fp,-20
8110f4dc:	100b883a 	mov	r5,r2
8110f4e0:	d1205404 	addi	r4,gp,-32432
8110f4e4:	110f8200 	call	8110f820 <bCheckInAck32>
8110f4e8:	e0bff815 	stw	r2,-32(fp)
8110f4ec:	00000206 	br	8110f4f8 <vInAckHandlerTaskV2+0x2bc>
                    else
                        bFinished32 = TRUE;
8110f4f0:	00800044 	movi	r2,1
8110f4f4:	e0bffb15 	stw	r2,-20(fp)

                } while ( ((ucCountRetries++ < MAX_RETRIES_ACK_IN) && (bFound == FALSE) && ((bFinished32 == FALSE) | (bFinished64 == FALSE) | (bFinished128 == FALSE))) );
8110f4f8:	e0bffa03 	ldbu	r2,-24(fp)
8110f4fc:	10c00044 	addi	r3,r2,1
8110f500:	e0fffa05 	stb	r3,-24(fp)
8110f504:	10803fcc 	andi	r2,r2,255
8110f508:	10800ca8 	cmpgeui	r2,r2,50
8110f50c:	10000e1e 	bne	r2,zero,8110f548 <vInAckHandlerTaskV2+0x30c>
8110f510:	e0bff817 	ldw	r2,-32(fp)
8110f514:	10000c1e 	bne	r2,zero,8110f548 <vInAckHandlerTaskV2+0x30c>
8110f518:	e0bffb17 	ldw	r2,-20(fp)
8110f51c:	1005003a 	cmpeq	r2,r2,zero
8110f520:	1007883a 	mov	r3,r2
8110f524:	e0bffc17 	ldw	r2,-16(fp)
8110f528:	1005003a 	cmpeq	r2,r2,zero
8110f52c:	1884b03a 	or	r2,r3,r2
8110f530:	10c03fcc 	andi	r3,r2,255
8110f534:	e0bffd17 	ldw	r2,-12(fp)
8110f538:	1005003a 	cmpeq	r2,r2,zero
8110f53c:	10803fcc 	andi	r2,r2,255
8110f540:	1884b03a 	or	r2,r3,r2
8110f544:	103fc11e 	bne	r2,zero,8110f44c <__reset+0xfb0ef44c>
                
                if (bFound == FALSE) {
8110f548:	e0bff817 	ldw	r2,-32(fp)
8110f54c:	1000011e 	bne	r2,zero,8110f554 <vInAckHandlerTaskV2+0x318>
                    /* Could not found the buffer with the id received in the ack packet*/
                    vFailFoundBufferRetransmission();
8110f550:	11182f00 	call	811182f0 <vFailFoundBufferRetransmission>
                }

                eReceiverAckState = sRAGettingACK;
8110f554:	00800044 	movi	r2,1
8110f558:	e0bff915 	stw	r2,-28(fp)
				break;
8110f55c:	00000a06 	br	8110f588 <vInAckHandlerTaskV2+0x34c>
			default:
                #ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vInAckHandlerTaskV2)\n");
8110f560:	d0a05e17 	ldw	r2,-32392(gp)
8110f564:	100f883a 	mov	r7,r2
8110f568:	01801144 	movi	r6,69
8110f56c:	01400044 	movi	r5,1
8110f570:	01204574 	movhi	r4,33045
8110f574:	21240204 	addi	r4,r4,-28664
8110f578:	111d0b40 	call	8111d0b4 <fwrite>
	            #endif
                eReceiverAckState = sRAGettingACK;
8110f57c:	00800044 	movi	r2,1
8110f580:	e0bff915 	stw	r2,-28(fp)
				break;
8110f584:	0001883a 	nop
		}
	}
8110f588:	003f4206 	br	8110f294 <__reset+0xfb0ef294>

8110f58c <bCheckInAck128>:
}


bool bCheckInAck128( txReceivedACK *xRecAckL , bool *bFinished ) {
8110f58c:	defffa04 	addi	sp,sp,-24
8110f590:	de00012e 	bgeu	sp,et,8110f598 <bCheckInAck128+0xc>
8110f594:	003b68fa 	trap	3
8110f598:	dfc00515 	stw	ra,20(sp)
8110f59c:	df000415 	stw	fp,16(sp)
8110f5a0:	df000404 	addi	fp,sp,16
8110f5a4:	e13ffe15 	stw	r4,-8(fp)
8110f5a8:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110f5ac:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110f5b0:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110f5b4:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110f5b8:	e0bfff17 	ldw	r2,-4(fp)
8110f5bc:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer128, 5, &error_code); /* Mas wait 1 tick = 1 ms */
8110f5c0:	d0a06a17 	ldw	r2,-32344(gp)
8110f5c4:	e0fffd44 	addi	r3,fp,-11
8110f5c8:	180d883a 	mov	r6,r3
8110f5cc:	01400144 	movi	r5,5
8110f5d0:	1009883a 	mov	r4,r2
8110f5d4:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110f5d8:	e0bffd43 	ldbu	r2,-11(fp)
8110f5dc:	10803fcc 	andi	r2,r2,255
8110f5e0:	10000226 	beq	r2,zero,8110f5ec <bCheckInAck128+0x60>
        return bFound;
8110f5e4:	e0bffc17 	ldw	r2,-16(fp)
8110f5e8:	00003506 	br	8110f6c0 <bCheckInAck128+0x134>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110f5ec:	e03ffd05 	stb	zero,-12(fp)
8110f5f0:	00002706 	br	8110f690 <bCheckInAck128+0x104>
    {
        if ( xBuffer128[ucIL].usiId == xRecAckL->usiId ) {
8110f5f4:	e0fffd03 	ldbu	r3,-12(fp)
8110f5f8:	00a045b4 	movhi	r2,33046
8110f5fc:	10a95004 	addi	r2,r2,-23232
8110f600:	18c02324 	muli	r3,r3,140
8110f604:	10c5883a 	add	r2,r2,r3
8110f608:	10802104 	addi	r2,r2,132
8110f60c:	10c0000b 	ldhu	r3,0(r2)
8110f610:	e0bffe17 	ldw	r2,-8(fp)
8110f614:	1080008b 	ldhu	r2,2(r2)
8110f618:	18ffffcc 	andi	r3,r3,65535
8110f61c:	10bfffcc 	andi	r2,r2,65535
8110f620:	1880181e 	bne	r3,r2,8110f684 <bCheckInAck128+0xf8>
            bFound = TRUE;
8110f624:	00800044 	movi	r2,1
8110f628:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b128[ucIL] = FALSE;
8110f62c:	e0fffd03 	ldbu	r3,-12(fp)
8110f630:	00a045b4 	movhi	r2,33046
8110f634:	10a93204 	addi	r2,r2,-23352
8110f638:	18c7883a 	add	r3,r3,r3
8110f63c:	18c7883a 	add	r3,r3,r3
8110f640:	10c5883a 	add	r2,r2,r3
8110f644:	10000015 	stw	zero,0(r2)
            SemCount128++;
8110f648:	d0a07143 	ldbu	r2,-32315(gp)
8110f64c:	10800044 	addi	r2,r2,1
8110f650:	d0a07145 	stb	r2,-32315(gp)
            error_code = OSSemPost(xSemCountBuffer128);
8110f654:	d0a05f17 	ldw	r2,-32388(gp)
8110f658:	1009883a 	mov	r4,r2
8110f65c:	113ae7c0 	call	8113ae7c <OSSemPost>
8110f660:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110f664:	e0bffd43 	ldbu	r2,-11(fp)
8110f668:	10803fcc 	andi	r2,r2,255
8110f66c:	10000c26 	beq	r2,zero,8110f6a0 <bCheckInAck128+0x114>
                SemCount128--;
8110f670:	d0a07143 	ldbu	r2,-32315(gp)
8110f674:	10bfffc4 	addi	r2,r2,-1
8110f678:	d0a07145 	stb	r2,-32315(gp)
                vFailSetCountSemaphorexBuffer128();
8110f67c:	11181500 	call	81118150 <vFailSetCountSemaphorexBuffer128>
            }
            break;
8110f680:	00000706 	br	8110f6a0 <bCheckInAck128+0x114>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_128; ucIL++)
8110f684:	e0bffd03 	ldbu	r2,-12(fp)
8110f688:	10800044 	addi	r2,r2,1
8110f68c:	e0bffd05 	stb	r2,-12(fp)
8110f690:	e0bffd03 	ldbu	r2,-12(fp)
8110f694:	108001b0 	cmpltui	r2,r2,6
8110f698:	103fd61e 	bne	r2,zero,8110f5f4 <__reset+0xfb0ef5f4>
8110f69c:	00000106 	br	8110f6a4 <bCheckInAck128+0x118>
            error_code = OSSemPost(xSemCountBuffer128);
            if ( error_code != OS_ERR_NONE ) {
                SemCount128--;
                vFailSetCountSemaphorexBuffer128();
            }
            break;
8110f6a0:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
8110f6a4:	d0a06a17 	ldw	r2,-32344(gp)
8110f6a8:	1009883a 	mov	r4,r2
8110f6ac:	113908c0 	call	8113908c <OSMutexPost>
    (*bFinished) = TRUE;
8110f6b0:	e0bfff17 	ldw	r2,-4(fp)
8110f6b4:	00c00044 	movi	r3,1
8110f6b8:	10c00015 	stw	r3,0(r2)

    return bFound;
8110f6bc:	e0bffc17 	ldw	r2,-16(fp)
}
8110f6c0:	e037883a 	mov	sp,fp
8110f6c4:	dfc00117 	ldw	ra,4(sp)
8110f6c8:	df000017 	ldw	fp,0(sp)
8110f6cc:	dec00204 	addi	sp,sp,8
8110f6d0:	f800283a 	ret

8110f6d4 <bCheckInAck64>:


bool bCheckInAck64( txReceivedACK *xRecAckL , bool *bFinished ) {
8110f6d4:	defffa04 	addi	sp,sp,-24
8110f6d8:	de00012e 	bgeu	sp,et,8110f6e0 <bCheckInAck64+0xc>
8110f6dc:	003b68fa 	trap	3
8110f6e0:	dfc00515 	stw	ra,20(sp)
8110f6e4:	df000415 	stw	fp,16(sp)
8110f6e8:	df000404 	addi	fp,sp,16
8110f6ec:	e13ffe15 	stw	r4,-8(fp)
8110f6f0:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110f6f4:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110f6f8:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110f6fc:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110f700:	e0bfff17 	ldw	r2,-4(fp)
8110f704:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer64, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110f708:	d0a06d17 	ldw	r2,-32332(gp)
8110f70c:	e0fffd44 	addi	r3,fp,-11
8110f710:	180d883a 	mov	r6,r3
8110f714:	01400044 	movi	r5,1
8110f718:	1009883a 	mov	r4,r2
8110f71c:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110f720:	e0bffd43 	ldbu	r2,-11(fp)
8110f724:	10803fcc 	andi	r2,r2,255
8110f728:	10000226 	beq	r2,zero,8110f734 <bCheckInAck64+0x60>
        return bFound;
8110f72c:	e0bffc17 	ldw	r2,-16(fp)
8110f730:	00003606 	br	8110f80c <bCheckInAck64+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110f734:	e03ffd05 	stb	zero,-12(fp)
8110f738:	00002806 	br	8110f7dc <bCheckInAck64+0x108>
    {
        if ( xBuffer64[ucIL].usiId == xRecAckL->usiId ) {
8110f73c:	e0fffd03 	ldbu	r3,-12(fp)
8110f740:	00a04574 	movhi	r2,33045
8110f744:	10851104 	addi	r2,r2,5188
8110f748:	18c01324 	muli	r3,r3,76
8110f74c:	10c5883a 	add	r2,r2,r3
8110f750:	10801104 	addi	r2,r2,68
8110f754:	10c0000b 	ldhu	r3,0(r2)
8110f758:	e0bffe17 	ldw	r2,-8(fp)
8110f75c:	1080008b 	ldhu	r2,2(r2)
8110f760:	18ffffcc 	andi	r3,r3,65535
8110f764:	10bfffcc 	andi	r2,r2,65535
8110f768:	1880191e 	bne	r3,r2,8110f7d0 <bCheckInAck64+0xfc>
            bFound = TRUE;
8110f76c:	00800044 	movi	r2,1
8110f770:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b64[ucIL] = FALSE;
8110f774:	e0fffd03 	ldbu	r3,-12(fp)
8110f778:	00a045b4 	movhi	r2,33046
8110f77c:	10a93204 	addi	r2,r2,-23352
8110f780:	18c00184 	addi	r3,r3,6
8110f784:	18c7883a 	add	r3,r3,r3
8110f788:	18c7883a 	add	r3,r3,r3
8110f78c:	10c5883a 	add	r2,r2,r3
8110f790:	10000015 	stw	zero,0(r2)
            SemCount64++;
8110f794:	d0a07103 	ldbu	r2,-32316(gp)
8110f798:	10800044 	addi	r2,r2,1
8110f79c:	d0a07105 	stb	r2,-32316(gp)
            error_code = OSSemPost(xSemCountBuffer64);
8110f7a0:	d0a05a17 	ldw	r2,-32408(gp)
8110f7a4:	1009883a 	mov	r4,r2
8110f7a8:	113ae7c0 	call	8113ae7c <OSSemPost>
8110f7ac:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110f7b0:	e0bffd43 	ldbu	r2,-11(fp)
8110f7b4:	10803fcc 	andi	r2,r2,255
8110f7b8:	10000c26 	beq	r2,zero,8110f7ec <bCheckInAck64+0x118>
                SemCount64--;
8110f7bc:	d0a07103 	ldbu	r2,-32316(gp)
8110f7c0:	10bfffc4 	addi	r2,r2,-1
8110f7c4:	d0a07105 	stb	r2,-32316(gp)
                vFailSetCountSemaphorexBuffer64();
8110f7c8:	11180e80 	call	811180e8 <vFailSetCountSemaphorexBuffer64>
            }
            break;
8110f7cc:	00000706 	br	8110f7ec <bCheckInAck64+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_64; ucIL++)
8110f7d0:	e0bffd03 	ldbu	r2,-12(fp)
8110f7d4:	10800044 	addi	r2,r2,1
8110f7d8:	e0bffd05 	stb	r2,-12(fp)
8110f7dc:	e0bffd03 	ldbu	r2,-12(fp)
8110f7e0:	10800230 	cmpltui	r2,r2,8
8110f7e4:	103fd51e 	bne	r2,zero,8110f73c <__reset+0xfb0ef73c>
8110f7e8:	00000106 	br	8110f7f0 <bCheckInAck64+0x11c>
            error_code = OSSemPost(xSemCountBuffer64);
            if ( error_code != OS_ERR_NONE ) {
                SemCount64--;
                vFailSetCountSemaphorexBuffer64();
            }
            break;
8110f7ec:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer128*/
8110f7f0:	d0a06d17 	ldw	r2,-32332(gp)
8110f7f4:	1009883a 	mov	r4,r2
8110f7f8:	113908c0 	call	8113908c <OSMutexPost>
    (*bFinished) = TRUE;
8110f7fc:	e0bfff17 	ldw	r2,-4(fp)
8110f800:	00c00044 	movi	r3,1
8110f804:	10c00015 	stw	r3,0(r2)

    return bFound;
8110f808:	e0bffc17 	ldw	r2,-16(fp)
}
8110f80c:	e037883a 	mov	sp,fp
8110f810:	dfc00117 	ldw	ra,4(sp)
8110f814:	df000017 	ldw	fp,0(sp)
8110f818:	dec00204 	addi	sp,sp,8
8110f81c:	f800283a 	ret

8110f820 <bCheckInAck32>:



bool bCheckInAck32( txReceivedACK *xRecAckL , bool *bFinished ) {
8110f820:	defffa04 	addi	sp,sp,-24
8110f824:	de00012e 	bgeu	sp,et,8110f82c <bCheckInAck32+0xc>
8110f828:	003b68fa 	trap	3
8110f82c:	dfc00515 	stw	ra,20(sp)
8110f830:	df000415 	stw	fp,16(sp)
8110f834:	df000404 	addi	fp,sp,16
8110f838:	e13ffe15 	stw	r4,-8(fp)
8110f83c:	e17fff15 	stw	r5,-4(fp)
	bool bFound = FALSE;
8110f840:	e03ffc15 	stw	zero,-16(fp)
	INT8U error_code;
    unsigned char ucIL = 0;
8110f844:	e03ffd05 	stb	zero,-12(fp)

    bFound = FALSE;
8110f848:	e03ffc15 	stw	zero,-16(fp)
    *bFinished = FALSE;
8110f84c:	e0bfff17 	ldw	r2,-4(fp)
8110f850:	10000015 	stw	zero,0(r2)
    OSMutexPend(xMutexBuffer32, 1, &error_code); /* Mas wait 1 tick = 1 ms */
8110f854:	d0a06817 	ldw	r2,-32352(gp)
8110f858:	e0fffd44 	addi	r3,fp,-11
8110f85c:	180d883a 	mov	r6,r3
8110f860:	01400044 	movi	r5,1
8110f864:	1009883a 	mov	r4,r2
8110f868:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code != OS_NO_ERR )
8110f86c:	e0bffd43 	ldbu	r2,-11(fp)
8110f870:	10803fcc 	andi	r2,r2,255
8110f874:	10000226 	beq	r2,zero,8110f880 <bCheckInAck32+0x60>
        return bFound;
8110f878:	e0bffc17 	ldw	r2,-16(fp)
8110f87c:	00003606 	br	8110f958 <bCheckInAck32+0x138>

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110f880:	e03ffd05 	stb	zero,-12(fp)
8110f884:	00002806 	br	8110f928 <bCheckInAck32+0x108>
    {
        if ( xBuffer32[ucIL].usiId == xRecAckL->usiId ) {
8110f888:	e0fffd03 	ldbu	r3,-12(fp)
8110f88c:	00a04574 	movhi	r2,33045
8110f890:	1096be04 	addi	r2,r2,23288
8110f894:	18c00b24 	muli	r3,r3,44
8110f898:	10c5883a 	add	r2,r2,r3
8110f89c:	10800904 	addi	r2,r2,36
8110f8a0:	10c0000b 	ldhu	r3,0(r2)
8110f8a4:	e0bffe17 	ldw	r2,-8(fp)
8110f8a8:	1080008b 	ldhu	r2,2(r2)
8110f8ac:	18ffffcc 	andi	r3,r3,65535
8110f8b0:	10bfffcc 	andi	r2,r2,65535
8110f8b4:	1880191e 	bne	r3,r2,8110f91c <bCheckInAck32+0xfc>
            bFound = TRUE;
8110f8b8:	00800044 	movi	r2,1
8110f8bc:	e0bffc15 	stw	r2,-16(fp)
            /* Free the slot with the index ucIL */
            xInUseRetrans.b32[ucIL] = FALSE;
8110f8c0:	e0fffd03 	ldbu	r3,-12(fp)
8110f8c4:	00a045b4 	movhi	r2,33046
8110f8c8:	10a93204 	addi	r2,r2,-23352
8110f8cc:	18c00384 	addi	r3,r3,14
8110f8d0:	18c7883a 	add	r3,r3,r3
8110f8d4:	18c7883a 	add	r3,r3,r3
8110f8d8:	10c5883a 	add	r2,r2,r3
8110f8dc:	10000015 	stw	zero,0(r2)
            SemCount32++;
8110f8e0:	d0a06483 	ldbu	r2,-32366(gp)
8110f8e4:	10800044 	addi	r2,r2,1
8110f8e8:	d0a06485 	stb	r2,-32366(gp)
            error_code = OSSemPost(xSemCountBuffer32);
8110f8ec:	d0a06b17 	ldw	r2,-32340(gp)
8110f8f0:	1009883a 	mov	r4,r2
8110f8f4:	113ae7c0 	call	8113ae7c <OSSemPost>
8110f8f8:	e0bffd45 	stb	r2,-11(fp)
            if ( error_code != OS_ERR_NONE ) {
8110f8fc:	e0bffd43 	ldbu	r2,-11(fp)
8110f900:	10803fcc 	andi	r2,r2,255
8110f904:	10000c26 	beq	r2,zero,8110f938 <bCheckInAck32+0x118>
                SemCount32--;
8110f908:	d0a06483 	ldbu	r2,-32366(gp)
8110f90c:	10bfffc4 	addi	r2,r2,-1
8110f910:	d0a06485 	stb	r2,-32366(gp)
                vFailSetCountSemaphorexBuffer32();
8110f914:	11180800 	call	81118080 <vFailSetCountSemaphorexBuffer32>
            }
            break;
8110f918:	00000706 	br	8110f938 <bCheckInAck32+0x118>
    if ( error_code != OS_NO_ERR )
        return bFound;

    /* ---> At this point we have access to xBuffer128 */

    for(ucIL = 0; ucIL < N_32; ucIL++)
8110f91c:	e0bffd03 	ldbu	r2,-12(fp)
8110f920:	10800044 	addi	r2,r2,1
8110f924:	e0bffd05 	stb	r2,-12(fp)
8110f928:	e0bffd03 	ldbu	r2,-12(fp)
8110f92c:	10800230 	cmpltui	r2,r2,8
8110f930:	103fd51e 	bne	r2,zero,8110f888 <__reset+0xfb0ef888>
8110f934:	00000106 	br	8110f93c <bCheckInAck32+0x11c>
            error_code = OSSemPost(xSemCountBuffer32);
            if ( error_code != OS_ERR_NONE ) {
                SemCount32--;
                vFailSetCountSemaphorexBuffer32();
            }
            break;
8110f938:	0001883a 	nop
        }
    }
    OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32*/
8110f93c:	d0a06817 	ldw	r2,-32352(gp)
8110f940:	1009883a 	mov	r4,r2
8110f944:	113908c0 	call	8113908c <OSMutexPost>
    (*bFinished) = TRUE;
8110f948:	e0bfff17 	ldw	r2,-4(fp)
8110f94c:	00c00044 	movi	r3,1
8110f950:	10c00015 	stw	r3,0(r2)

    return bFound;
8110f954:	e0bffc17 	ldw	r2,-16(fp)
}
8110f958:	e037883a 	mov	sp,fp
8110f95c:	dfc00117 	ldw	ra,4(sp)
8110f960:	df000017 	ldw	fp,0(sp)
8110f964:	dec00204 	addi	sp,sp,8
8110f968:	f800283a 	ret

8110f96c <vInitialTask>:

#include "initialization_task.h"


void vInitialTask(void *task_data)
{
8110f96c:	defff704 	addi	sp,sp,-36
8110f970:	de00012e 	bgeu	sp,et,8110f978 <vInitialTask+0xc>
8110f974:	003b68fa 	trap	3
8110f978:	dfc00815 	stw	ra,32(sp)
8110f97c:	df000715 	stw	fp,28(sp)
8110f980:	df000704 	addi	fp,sp,28
8110f984:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_ERR_NONE;
8110f988:	e03ffe05 	stb	zero,-8(fp)
									vFeeTask0_stk,
									FEES_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vFeeTask,
8110f98c:	d8000415 	stw	zero,16(sp)
8110f990:	d8000315 	stw	zero,12(sp)
8110f994:	00810004 	movi	r2,1024
8110f998:	d8800215 	stw	r2,8(sp)
8110f99c:	00a04574 	movhi	r2,33045
8110f9a0:	10bd1104 	addi	r2,r2,-3004
8110f9a4:	d8800115 	stw	r2,4(sp)
8110f9a8:	008002c4 	movi	r2,11
8110f9ac:	d8800015 	stw	r2,0(sp)
8110f9b0:	01c002c4 	movi	r7,11
8110f9b4:	01a04574 	movhi	r6,33045
8110f9b8:	31811004 	addi	r6,r6,1088
8110f9bc:	01604574 	movhi	r5,33045
8110f9c0:	29522304 	addi	r5,r5,18572
8110f9c4:	01204474 	movhi	r4,33041
8110f9c8:	2132b104 	addi	r4,r4,-13628
8110f9cc:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110f9d0:	e0bffe05 	stb	r2,-8(fp)
									FEES_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110f9d4:	e0bffe03 	ldbu	r2,-8(fp)
8110f9d8:	10803fcc 	andi	r2,r2,255
8110f9dc:	10000526 	beq	r2,zero,8110f9f4 <vInitialTask+0x88>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110f9e0:	e0bffe03 	ldbu	r2,-8(fp)
8110f9e4:	10803fcc 	andi	r2,r2,255
8110f9e8:	1009883a 	mov	r4,r2
8110f9ec:	11179fc0 	call	811179fc <printErrorTask>
		#endif
			vCoudlNotCreateNFee0Task();
8110f9f0:	1118ea80 	call	81118ea8 <vCoudlNotCreateNFee0Task>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110f9f4:	01c17704 	movi	r7,1500
8110f9f8:	000d883a 	mov	r6,zero
8110f9fc:	000b883a 	mov	r5,zero
8110fa00:	0009883a 	mov	r4,zero
8110fa04:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vDataControlTask_stk,
									DATA_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vDataControlTask,
8110fa08:	d8000415 	stw	zero,16(sp)
8110fa0c:	d8000315 	stw	zero,12(sp)
8110fa10:	00810004 	movi	r2,1024
8110fa14:	d8800215 	stw	r2,8(sp)
8110fa18:	00a04574 	movhi	r2,33045
8110fa1c:	108e1104 	addi	r2,r2,14404
8110fa20:	d8800115 	stw	r2,4(sp)
8110fa24:	00800284 	movi	r2,10
8110fa28:	d8800015 	stw	r2,0(sp)
8110fa2c:	01c00284 	movi	r7,10
8110fa30:	01a04574 	movhi	r6,33045
8110fa34:	31921004 	addi	r6,r6,18496
8110fa38:	01604574 	movhi	r5,33045
8110fa3c:	29521b04 	addi	r5,r5,18540
8110fa40:	01204474 	movhi	r4,33041
8110fa44:	21328904 	addi	r4,r4,-13788
8110fa48:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fa4c:	e0bffe05 	stb	r2,-8(fp)
									DATA_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fa50:	e0bffe03 	ldbu	r2,-8(fp)
8110fa54:	10803fcc 	andi	r2,r2,255
8110fa58:	10000526 	beq	r2,zero,8110fa70 <vInitialTask+0x104>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fa5c:	e0bffe03 	ldbu	r2,-8(fp)
8110fa60:	10803fcc 	andi	r2,r2,255
8110fa64:	1009883a 	mov	r4,r2
8110fa68:	11179fc0 	call	811179fc <printErrorTask>
		#endif
			vCoudlNotCreateDataControllerTask();
8110fa6c:	11191800 	call	81119180 <vCoudlNotCreateDataControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110fa70:	01c17704 	movi	r7,1500
8110fa74:	000d883a 	mov	r6,zero
8110fa78:	000b883a 	mov	r5,zero
8110fa7c:	0009883a 	mov	r4,zero
8110fa80:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vNFeeControlTask_stk,
									FEE_CONTROL_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vNFeeControlTask,
8110fa84:	d8000415 	stw	zero,16(sp)
8110fa88:	d8000315 	stw	zero,12(sp)
8110fa8c:	00810004 	movi	r2,1024
8110fa90:	d8800215 	stw	r2,8(sp)
8110fa94:	00a045b4 	movhi	r2,33046
8110fa98:	10aa3604 	addi	r2,r2,-22312
8110fa9c:	d8800115 	stw	r2,4(sp)
8110faa0:	00800244 	movi	r2,9
8110faa4:	d8800015 	stw	r2,0(sp)
8110faa8:	01c00244 	movi	r7,9
8110faac:	01a045b4 	movhi	r6,33046
8110fab0:	31ae3504 	addi	r6,r6,-18220
8110fab4:	01604574 	movhi	r5,33045
8110fab8:	29522304 	addi	r5,r5,18572
8110fabc:	01204474 	movhi	r4,33041
8110fac0:	213fbc04 	addi	r4,r4,-272
8110fac4:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fac8:	e0bffe05 	stb	r2,-8(fp)
									FEE_CONTROL_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110facc:	e0bffe03 	ldbu	r2,-8(fp)
8110fad0:	10803fcc 	andi	r2,r2,255
8110fad4:	10000526 	beq	r2,zero,8110faec <vInitialTask+0x180>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fad8:	e0bffe03 	ldbu	r2,-8(fp)
8110fadc:	10803fcc 	andi	r2,r2,255
8110fae0:	1009883a 	mov	r4,r2
8110fae4:	11179fc0 	call	811179fc <printErrorTask>
		#endif
			vCoudlNotCreateNFeeControllerTask();
8110fae8:	11191180 	call	81119118 <vCoudlNotCreateNFeeControllerTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110faec:	01c17704 	movi	r7,1500
8110faf0:	000d883a 	mov	r6,zero
8110faf4:	000b883a 	mov	r5,zero
8110faf8:	0009883a 	mov	r4,zero
8110fafc:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vSimMebTask_stk,
									MEB_STACK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSimMebTask,
8110fb00:	d8000415 	stw	zero,16(sp)
8110fb04:	d8000315 	stw	zero,12(sp)
8110fb08:	00810004 	movi	r2,1024
8110fb0c:	d8800215 	stw	r2,8(sp)
8110fb10:	00a045b4 	movhi	r2,33046
8110fb14:	10bc4c04 	addi	r2,r2,-3792
8110fb18:	d8800115 	stw	r2,4(sp)
8110fb1c:	00800204 	movi	r2,8
8110fb20:	d8800015 	stw	r2,0(sp)
8110fb24:	01c00204 	movi	r7,8
8110fb28:	01a045b4 	movhi	r6,33046
8110fb2c:	31804b04 	addi	r6,r6,300
8110fb30:	01604574 	movhi	r5,33045
8110fb34:	29521104 	addi	r5,r5,18500
8110fb38:	01204474 	movhi	r4,33041
8110fb3c:	21092304 	addi	r4,r4,9356
8110fb40:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fb44:	e0bffe05 	stb	r2,-8(fp)
									MEB_STACK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fb48:	e0bffe03 	ldbu	r2,-8(fp)
8110fb4c:	10803fcc 	andi	r2,r2,255
8110fb50:	10000526 	beq	r2,zero,8110fb68 <vInitialTask+0x1fc>
		/* Can't create Task */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fb54:	e0bffe03 	ldbu	r2,-8(fp)
8110fb58:	10803fcc 	andi	r2,r2,255
8110fb5c:	1009883a 	mov	r4,r2
8110fb60:	11179fc0 	call	811179fc <printErrorTask>
		#endif
			vCoudlNotCreateMebTask();
8110fb64:	11191e80 	call	811191e8 <vCoudlNotCreateMebTask>
	}


	OSTimeDlyHMSM(0, 0, 0, 1500);
8110fb68:	01c17704 	movi	r7,1500
8110fb6c:	000d883a 	mov	r6,zero
8110fb70:	000b883a 	mov	r5,zero
8110fb74:	0009883a 	mov	r4,zero
8110fb78:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vTimeoutCheckerTask_stk,
									TIMEOUT_CHECKER_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vTimeoutCheckerTaskv2,
8110fb7c:	d8000415 	stw	zero,16(sp)
8110fb80:	d8000315 	stw	zero,12(sp)
8110fb84:	00810004 	movi	r2,1024
8110fb88:	d8800215 	stw	r2,8(sp)
8110fb8c:	00a04574 	movhi	r2,33045
8110fb90:	108a1104 	addi	r2,r2,10308
8110fb94:	d8800115 	stw	r2,4(sp)
8110fb98:	00800784 	movi	r2,30
8110fb9c:	d8800015 	stw	r2,0(sp)
8110fba0:	01c00784 	movi	r7,30
8110fba4:	01a04574 	movhi	r6,33045
8110fba8:	318e1004 	addi	r6,r6,14400
8110fbac:	000b883a 	mov	r5,zero
8110fbb0:	01204474 	movhi	r4,33041
8110fbb4:	210fc804 	addi	r4,r4,16160
8110fbb8:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fbbc:	e0bffe05 	stb	r2,-8(fp)
									TIMEOUT_CHECKER_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fbc0:	e0bffe03 	ldbu	r2,-8(fp)
8110fbc4:	10803fcc 	andi	r2,r2,255
8110fbc8:	10000526 	beq	r2,zero,8110fbe0 <vInitialTask+0x274>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fbcc:	e0bffe03 	ldbu	r2,-8(fp)
8110fbd0:	10803fcc 	andi	r2,r2,255
8110fbd4:	1009883a 	mov	r4,r2
8110fbd8:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailTimeoutCheckerTaskCreate();
8110fbdc:	11188140 	call	81118814 <vFailTimeoutCheckerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110fbe0:	01c03204 	movi	r7,200
8110fbe4:	000d883a 	mov	r6,zero
8110fbe8:	000b883a 	mov	r5,zero
8110fbec:	0009883a 	mov	r4,zero
8110fbf0:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vOutAckHandlerTask_stk,
									OUT_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vOutAckHandlerTask,
8110fbf4:	d8000415 	stw	zero,16(sp)
8110fbf8:	d8000315 	stw	zero,12(sp)
8110fbfc:	00810004 	movi	r2,1024
8110fc00:	d8800215 	stw	r2,8(sp)
8110fc04:	00a04574 	movhi	r2,33045
8110fc08:	109d2604 	addi	r2,r2,29848
8110fc0c:	d8800115 	stw	r2,4(sp)
8110fc10:	008006c4 	movi	r2,27
8110fc14:	d8800015 	stw	r2,0(sp)
8110fc18:	01c006c4 	movi	r7,27
8110fc1c:	01a045b4 	movhi	r6,33046
8110fc20:	31a12504 	addi	r6,r6,-31596
8110fc24:	000b883a 	mov	r5,zero
8110fc28:	01204474 	movhi	r4,33041
8110fc2c:	21016904 	addi	r4,r4,1444
8110fc30:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fc34:	e0bffe05 	stb	r2,-8(fp)
									OUT_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fc38:	e0bffe03 	ldbu	r2,-8(fp)
8110fc3c:	10803fcc 	andi	r2,r2,255
8110fc40:	10000526 	beq	r2,zero,8110fc58 <vInitialTask+0x2ec>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fc44:	e0bffe03 	ldbu	r2,-8(fp)
8110fc48:	10803fcc 	andi	r2,r2,255
8110fc4c:	1009883a 	mov	r4,r2
8110fc50:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailOutAckHandlerTaskCreate();
8110fc54:	11187300 	call	81118730 <vFailOutAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110fc58:	01c03204 	movi	r7,200
8110fc5c:	000d883a 	mov	r6,zero
8110fc60:	000b883a 	mov	r5,zero
8110fc64:	0009883a 	mov	r4,zero
8110fc68:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vInAckHandlerTask_stk,
									IN_ACK_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInAckHandlerTaskV2,
8110fc6c:	d8000415 	stw	zero,16(sp)
8110fc70:	d8000315 	stw	zero,12(sp)
8110fc74:	00810004 	movi	r2,1024
8110fc78:	d8800215 	stw	r2,8(sp)
8110fc7c:	00a04574 	movhi	r2,33045
8110fc80:	10811104 	addi	r2,r2,1092
8110fc84:	d8800115 	stw	r2,4(sp)
8110fc88:	00800644 	movi	r2,25
8110fc8c:	d8800015 	stw	r2,0(sp)
8110fc90:	01c00644 	movi	r7,25
8110fc94:	01a04574 	movhi	r6,33045
8110fc98:	31851004 	addi	r6,r6,5184
8110fc9c:	000b883a 	mov	r5,zero
8110fca0:	01204474 	movhi	r4,33041
8110fca4:	213c8f04 	addi	r4,r4,-3524
8110fca8:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fcac:	e0bffe05 	stb	r2,-8(fp)
									IN_ACK_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fcb0:	e0bffe03 	ldbu	r2,-8(fp)
8110fcb4:	10803fcc 	andi	r2,r2,255
8110fcb8:	10000526 	beq	r2,zero,8110fcd0 <vInitialTask+0x364>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fcbc:	e0bffe03 	ldbu	r2,-8(fp)
8110fcc0:	10803fcc 	andi	r2,r2,255
8110fcc4:	1009883a 	mov	r4,r2
8110fcc8:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailInAckHandlerTaskCreate();
8110fccc:	11186e40 	call	811186e4 <vFailInAckHandlerTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110fcd0:	01c03204 	movi	r7,200
8110fcd4:	000d883a 	mov	r6,zero
8110fcd8:	000b883a 	mov	r5,zero
8110fcdc:	0009883a 	mov	r4,zero
8110fce0:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vParserCommTask_stk,
									PARSER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vParserCommTask,
8110fce4:	d8000415 	stw	zero,16(sp)
8110fce8:	d8000315 	stw	zero,12(sp)
8110fcec:	00818004 	movi	r2,1536
8110fcf0:	d8800215 	stw	r2,8(sp)
8110fcf4:	00a045b4 	movhi	r2,33046
8110fcf8:	10b64804 	addi	r2,r2,-9952
8110fcfc:	d8800115 	stw	r2,4(sp)
8110fd00:	00800704 	movi	r2,28
8110fd04:	d8800015 	stw	r2,0(sp)
8110fd08:	01c00704 	movi	r7,28
8110fd0c:	01a045b4 	movhi	r6,33046
8110fd10:	31bc4704 	addi	r6,r6,-3812
8110fd14:	000b883a 	mov	r5,zero
8110fd18:	01204474 	movhi	r4,33041
8110fd1c:	21022704 	addi	r4,r4,2204
8110fd20:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fd24:	e0bffe05 	stb	r2,-8(fp)
									PARSER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fd28:	e0bffe03 	ldbu	r2,-8(fp)
8110fd2c:	10803fcc 	andi	r2,r2,255
8110fd30:	10000526 	beq	r2,zero,8110fd48 <vInitialTask+0x3dc>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );
8110fd34:	e0bffe03 	ldbu	r2,-8(fp)
8110fd38:	10803fcc 	andi	r2,r2,255
8110fd3c:	1009883a 	mov	r4,r2
8110fd40:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailParserCommTaskCreate();
8110fd44:	11186980 	call	81118698 <vFailParserCommTaskCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110fd48:	01c03204 	movi	r7,200
8110fd4c:	000d883a 	mov	r6,zero
8110fd50:	000b883a 	mov	r5,zero
8110fd54:	0009883a 	mov	r4,zero
8110fd58:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									vReceiverUartTask_stk,
									RECEIVER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CHK + OS_TASK_OPT_STK_CLR);
	#else
		error_code = OSTaskCreateExt(vReceiverUartTask,
8110fd5c:	d8000415 	stw	zero,16(sp)
8110fd60:	d8000315 	stw	zero,12(sp)
8110fd64:	00818004 	movi	r2,1536
8110fd68:	d8800215 	stw	r2,8(sp)
8110fd6c:	00a04574 	movhi	r2,33045
8110fd70:	10971604 	addi	r2,r2,23640
8110fd74:	d8800115 	stw	r2,4(sp)
8110fd78:	00800804 	movi	r2,32
8110fd7c:	d8800015 	stw	r2,0(sp)
8110fd80:	01c00804 	movi	r7,32
8110fd84:	01a04574 	movhi	r6,33045
8110fd88:	319d1504 	addi	r6,r6,29780
8110fd8c:	000b883a 	mov	r5,zero
8110fd90:	01204474 	movhi	r4,33041
8110fd94:	21064304 	addi	r4,r4,6412
8110fd98:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fd9c:	e0bffe05 	stb	r2,-8(fp)
									RECEIVER_TASK_SIZE,
									NULL,
									0);
	#endif

	if ( error_code != OS_ERR_NONE) {
8110fda0:	e0bffe03 	ldbu	r2,-8(fp)
8110fda4:	10803fcc 	andi	r2,r2,255
8110fda8:	10000526 	beq	r2,zero,8110fdc0 <vInitialTask+0x454>
		/* Can't create Task for receive comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110fdac:	e0bffe03 	ldbu	r2,-8(fp)
8110fdb0:	10803fcc 	andi	r2,r2,255
8110fdb4:	1009883a 	mov	r4,r2
8110fdb8:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailReceiverCreate();
8110fdbc:	1117f9c0 	call	81117f9c <vFailReceiverCreate>
	}


	OSTimeDlyHMSM(0, 0, 0, 200);
8110fdc0:	01c03204 	movi	r7,200
8110fdc4:	000d883a 	mov	r6,zero
8110fdc8:	000b883a 	mov	r5,zero
8110fdcc:	0009883a 	mov	r4,zero
8110fdd0:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									senderTask_stk,
									SENDER_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vSenderComTask,
8110fdd4:	d8000415 	stw	zero,16(sp)
8110fdd8:	d8000315 	stw	zero,12(sp)
8110fddc:	00810004 	movi	r2,1024
8110fde0:	d8800215 	stw	r2,8(sp)
8110fde4:	00a04574 	movhi	r2,33045
8110fde8:	10860504 	addi	r2,r2,6164
8110fdec:	d8800115 	stw	r2,4(sp)
8110fdf0:	00800684 	movi	r2,26
8110fdf4:	d8800015 	stw	r2,0(sp)
8110fdf8:	01c00684 	movi	r7,26
8110fdfc:	01a04574 	movhi	r6,33045
8110fe00:	318a0404 	addi	r6,r6,10256
8110fe04:	000b883a 	mov	r5,zero
8110fe08:	01204474 	movhi	r4,33041
8110fe0c:	2108c504 	addi	r4,r4,8980
8110fe10:	113b8600 	call	8113b860 <OSTaskCreateExt>
8110fe14:	e0bffe05 	stb	r2,-8(fp)
									0);
	#endif



	OSTimeDlyHMSM(0, 0, 0, 200);
8110fe18:	01c03204 	movi	r7,200
8110fe1c:	000d883a 	mov	r6,zero
8110fe20:	000b883a 	mov	r5,zero
8110fe24:	0009883a 	mov	r4,zero
8110fe28:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
									OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK);
	#endif



	if ( error_code != OS_ERR_NONE) {
8110fe2c:	e0bffe03 	ldbu	r2,-8(fp)
8110fe30:	10803fcc 	andi	r2,r2,255
8110fe34:	10000526 	beq	r2,zero,8110fe4c <vInitialTask+0x4e0>
		/* Can't create Task for sender comm packets */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110fe38:	e0bffe03 	ldbu	r2,-8(fp)
8110fe3c:	10803fcc 	andi	r2,r2,255
8110fe40:	1009883a 	mov	r4,r2
8110fe44:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailSenderCreate();
8110fe48:	1117fe80 	call	81117fe8 <vFailSenderCreate>
	}

	/*	This is the timer that's trigger the task that implements the timeout/retransmission logic*/
	OSTmrStart ((OS_TMR *)xTimerRetransmission, (INT8U  *)&error_code);
8110fe4c:	d0a06917 	ldw	r2,-32348(gp)
8110fe50:	e17ffe04 	addi	r5,fp,-8
8110fe54:	1009883a 	mov	r4,r2
8110fe58:	113d5800 	call	8113d580 <OSTmrStart>
	if ( error_code != OS_ERR_NONE) {
8110fe5c:	e0bffe03 	ldbu	r2,-8(fp)
8110fe60:	10803fcc 	andi	r2,r2,255
8110fe64:	10000126 	beq	r2,zero,8110fe6c <vInitialTask+0x500>
		/*	Could not create the timer that syncs the task that is responsible to retransmit the packets*/
		vFailStartTimerRetransmission();
8110fe68:	1118ad00 	call	81118ad0 <vFailStartTimerRetransmission>
	}


	OSTimeDlyHMSM(0, 0, 30, 2); /* todo:debug REMOVER*/
8110fe6c:	01c00084 	movi	r7,2
8110fe70:	01800784 	movi	r6,30
8110fe74:	000b883a 	mov	r5,zero
8110fe78:	0009883a 	mov	r4,zero
8110fe7c:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>


	/* Delete the Initialization Task  */
	error_code = OSTaskDel(OS_PRIO_SELF); /* OS_PRIO_SELF = Means task self priority */
8110fe80:	01003fc4 	movi	r4,255
8110fe84:	113ba4c0 	call	8113ba4c <OSTaskDel>
8110fe88:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE) {
8110fe8c:	e0bffe03 	ldbu	r2,-8(fp)
8110fe90:	10803fcc 	andi	r2,r2,255
8110fe94:	10001026 	beq	r2,zero,8110fed8 <vInitialTask+0x56c>
		/*	Can't delete the initialization task, the problem is that the priority of this
			is that the PRIO is so high that will cause starvation if not deleted */
		#ifdef DEBUG_ON
			printErrorTask( error_code );		
8110fe98:	e0bffe03 	ldbu	r2,-8(fp)
8110fe9c:	10803fcc 	andi	r2,r2,255
8110fea0:	1009883a 	mov	r4,r2
8110fea4:	11179fc0 	call	811179fc <printErrorTask>
		#endif
		vFailDeleteInitialization();
8110fea8:	11180340 	call	81118034 <vFailDeleteInitialization>
		/*	To not exit the intire application, the PRIO of this task will be lowered*/
		OSTaskChangePrio( INITIALIZATION_TASK_PRIO , INITIALIZATION_TASK_PRIO_FAIL );
8110feac:	014009c4 	movi	r5,39
8110feb0:	01000044 	movi	r4,1
8110feb4:	113b1b40 	call	8113b1b4 <OSTaskChangePrio>

		for(;;) { /* Correct Program Flow should never get here */
			OSTaskDel(OS_PRIO_SELF); /* Try to delete it self */
8110feb8:	01003fc4 	movi	r4,255
8110febc:	113ba4c0 	call	8113ba4c <OSTaskDel>
			OSTimeDlyHMSM(0,0,10,0); /* 1 sec */
8110fec0:	000f883a 	mov	r7,zero
8110fec4:	01800284 	movi	r6,10
8110fec8:	000b883a 	mov	r5,zero
8110fecc:	0009883a 	mov	r4,zero
8110fed0:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
		}
8110fed4:	003ff806 	br	8110feb8 <__reset+0xfb0efeb8>
	}

}
8110fed8:	0001883a 	nop
8110fedc:	e037883a 	mov	sp,fp
8110fee0:	dfc00117 	ldw	ra,4(sp)
8110fee4:	df000017 	ldw	fp,0(sp)
8110fee8:	dec00204 	addi	sp,sp,8
8110feec:	f800283a 	ret

8110fef0 <vNFeeControlTask>:


#include "nfee_control_task.h"


void vNFeeControlTask(void *task_data) {
8110fef0:	defff704 	addi	sp,sp,-36
8110fef4:	de00012e 	bgeu	sp,et,8110fefc <vNFeeControlTask+0xc>
8110fef8:	003b68fa 	trap	3
8110fefc:	dfc00815 	stw	ra,32(sp)
8110ff00:	df000715 	stw	fp,28(sp)
8110ff04:	df000704 	addi	fp,sp,28
8110ff08:	e13fff15 	stw	r4,-4(fp)
	INT8U error_codeCtrl;
	unsigned char ucFeeInstL;
	static bool bDmaBack;
	unsigned char ucIL;

	pxFeeC = (TNFee_Control *) task_data;
8110ff0c:	e0bfff17 	ldw	r2,-4(fp)
8110ff10:	e0bffa15 	stw	r2,-24(fp)

	#ifdef DEBUG_ON
        debug(fp,"NFee Controller Task. (Task on)\n");
8110ff14:	d0a05e17 	ldw	r2,-32392(gp)
8110ff18:	100f883a 	mov	r7,r2
8110ff1c:	01800804 	movi	r6,32
8110ff20:	01400044 	movi	r5,1
8110ff24:	01204574 	movhi	r4,33045
8110ff28:	21241404 	addi	r4,r4,-28592
8110ff2c:	111d0b40 	call	8111d0b4 <fwrite>
    #endif

	for (;;) {

		switch (pxFeeC->sMode)
8110ff30:	e0bffa17 	ldw	r2,-24(fp)
8110ff34:	10809917 	ldw	r2,612(r2)
8110ff38:	10c00168 	cmpgeui	r3,r2,5
8110ff3c:	1800de1e 	bne	r3,zero,811102b8 <vNFeeControlTask+0x3c8>
8110ff40:	100690ba 	slli	r3,r2,2
8110ff44:	00a04474 	movhi	r2,33041
8110ff48:	10bfd604 	addi	r2,r2,-168
8110ff4c:	1885883a 	add	r2,r3,r2
8110ff50:	10800017 	ldw	r2,0(r2)
8110ff54:	1000683a 	jmp	r2
8110ff58:	8110ff6c 	andhi	r4,r16,17405
8110ff5c:	8110ffa8 	cmpgeui	r4,r16,17406
8110ff60:	8110fffc 	xorhi	r4,r16,17407
8110ff64:	811100b0 	cmpltui	r4,r16,17410
8110ff68:	8111012c 	andhi	r4,r16,17412
		{
			case sMebInit:
				/* Starting the NFEE Controller */

				/* Clear in CMD Queue  */
				error_codeCtrl = OSQFlush(xQMaskFeeCtrl);
8110ff6c:	d0a06c17 	ldw	r2,-32336(gp)
8110ff70:	1009883a 	mov	r4,r2
8110ff74:	1139b3c0 	call	81139b3c <OSQFlush>
8110ff78:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110ff7c:	e0bffe03 	ldbu	r2,-8(fp)
8110ff80:	10803fcc 	andi	r2,r2,255
8110ff84:	10000126 	beq	r2,zero,8110ff8c <vNFeeControlTask+0x9c>
					vFailFlushQueue();
8110ff88:	111982c0 	call	8111982c <vFailFlushQueue>
				}

				bCmdSent = FALSE;
8110ff8c:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
8110ff90:	00800044 	movi	r2,1
8110ff94:	d0a05515 	stw	r2,-32428(gp)
				pxFeeC->sMode = sMebToConfig;
8110ff98:	e0bffa17 	ldw	r2,-24(fp)
8110ff9c:	00c00044 	movi	r3,1
8110ffa0:	10c09915 	stw	r3,612(r2)
				break;
8110ffa4:	0000cf06 	br	811102e4 <vNFeeControlTask+0x3f4>


			case sMebToConfig:
				/* Transition state */
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: Config Mode\n");
8110ffa8:	d0a05e17 	ldw	r2,-32392(gp)
8110ffac:	100f883a 	mov	r7,r2
8110ffb0:	018008c4 	movi	r6,35
8110ffb4:	01400044 	movi	r5,1
8110ffb8:	01204574 	movhi	r4,33045
8110ffbc:	21241d04 	addi	r4,r4,-28556
8110ffc0:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8110ffc4:	d0a05917 	ldw	r2,-32412(gp)
8110ffc8:	1009883a 	mov	r4,r2
8110ffcc:	1139b3c0 	call	81139b3c <OSQFlush>
8110ffd0:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8110ffd4:	e0bffe03 	ldbu	r2,-8(fp)
8110ffd8:	10803fcc 	andi	r2,r2,255
8110ffdc:	10000126 	beq	r2,zero,8110ffe4 <vNFeeControlTask+0xf4>
					vFailFlushQueue();
8110ffe0:	111982c0 	call	8111982c <vFailFlushQueue>
				}

				pxFeeC->ucTimeCode = 0;
8110ffe4:	e0bffa17 	ldw	r2,-24(fp)
8110ffe8:	10009805 	stb	zero,608(r2)
				pxFeeC->sMode = sMebConfig;
8110ffec:	e0bffa17 	ldw	r2,-24(fp)
8110fff0:	00c000c4 	movi	r3,3
8110fff4:	10c09915 	stw	r3,612(r2)
				break;
8110fff8:	0000ba06 	br	811102e4 <vNFeeControlTask+0x3f4>


			case sMebToRun:
				/* Transition state */
				vEvtChangeFeeControllerMode();
8110fffc:	11199840 	call	81119984 <vEvtChangeFeeControllerMode>
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task:: RUN Mode\n");
81110000:	d0a05e17 	ldw	r2,-32392(gp)
81110004:	100f883a 	mov	r7,r2
81110008:	01800804 	movi	r6,32
8111000c:	01400044 	movi	r5,1
81110010:	01204574 	movhi	r4,33045
81110014:	21242604 	addi	r4,r4,-28520
81110018:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

				/* Clear Queue that is responsible to schedule the DMA access */
				error_codeCtrl = OSQFlush(xNfeeSchedule);
8111001c:	d0a05917 	ldw	r2,-32412(gp)
81110020:	1009883a 	mov	r4,r2
81110024:	1139b3c0 	call	81139b3c <OSQFlush>
81110028:	e0bffe05 	stb	r2,-8(fp)
				if ( error_codeCtrl != OS_NO_ERR ) {
8111002c:	e0bffe03 	ldbu	r2,-8(fp)
81110030:	10803fcc 	andi	r2,r2,255
81110034:	10000126 	beq	r2,zero,8111003c <vNFeeControlTask+0x14c>
					vFailFlushQueue();
81110038:	111982c0 	call	8111982c <vFailFlushQueue>
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
8111003c:	e03ff905 	stb	zero,-28(fp)
81110040:	00001006 	br	81110084 <vNFeeControlTask+0x194>
				{
					error_codeCtrl = OSQFlush( xFeeQ[ ucIL ] );
81110044:	e0bff903 	ldbu	r2,-28(fp)
81110048:	1085883a 	add	r2,r2,r2
8111004c:	1087883a 	add	r3,r2,r2
81110050:	d0a06604 	addi	r2,gp,-32360
81110054:	1885883a 	add	r2,r3,r2
81110058:	10800017 	ldw	r2,0(r2)
8111005c:	1009883a 	mov	r4,r2
81110060:	1139b3c0 	call	81139b3c <OSQFlush>
81110064:	e0bffe05 	stb	r2,-8(fp)
					if ( error_codeCtrl != OS_NO_ERR ) {
81110068:	e0bffe03 	ldbu	r2,-8(fp)
8111006c:	10803fcc 	andi	r2,r2,255
81110070:	10000126 	beq	r2,zero,81110078 <vNFeeControlTask+0x188>
						vFailFlushQueue();
81110074:	111982c0 	call	8111982c <vFailFlushQueue>
				if ( error_codeCtrl != OS_NO_ERR ) {
					vFailFlushQueue();
				}

				/* Clear message that maybe is in the FEEs Queues */
				for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++)
81110078:	e0bff903 	ldbu	r2,-28(fp)
8111007c:	10800044 	addi	r2,r2,1
81110080:	e0bff905 	stb	r2,-28(fp)
81110084:	e0bff903 	ldbu	r2,-28(fp)
81110088:	103fee26 	beq	r2,zero,81110044 <__reset+0xfb0f0044>
						vFailFlushQueue();
					}
				}


				pxFeeC->ucTimeCode = 0;
8111008c:	e0bffa17 	ldw	r2,-24(fp)
81110090:	10009805 	stb	zero,608(r2)

				bCmdSent = FALSE;
81110094:	e03ffb15 	stw	zero,-20(fp)
				bDmaBack = TRUE;
81110098:	00800044 	movi	r2,1
8111009c:	d0a05515 	stw	r2,-32428(gp)
				pxFeeC->sMode = sMebRun;
811100a0:	e0bffa17 	ldw	r2,-24(fp)
811100a4:	00c00104 	movi	r3,4
811100a8:	10c09915 	stw	r3,612(r2)
				break;
811100ac:	00008d06 	br	811102e4 <vNFeeControlTask+0x3f4>


			case sMebConfig:
				
				uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl); /* Blocking operation */
811100b0:	d0a06c17 	ldw	r2,-32336(gp)
811100b4:	e0fffe04 	addi	r3,fp,-8
811100b8:	180d883a 	mov	r6,r3
811100bc:	000b883a 	mov	r5,zero
811100c0:	1009883a 	mov	r4,r2
811100c4:	1139bfc0 	call	81139bfc <OSQPend>
811100c8:	e0bffd15 	stw	r2,-12(fp)
				if ( error_codeCtrl == OS_ERR_NONE ) {
811100cc:	e0bffe03 	ldbu	r2,-8(fp)
811100d0:	10803fcc 	andi	r2,r2,255
811100d4:	1000131e 	bne	r2,zero,81110124 <vNFeeControlTask+0x234>

					/* Check if the command is for NFEE Controller */
					if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
811100d8:	e0bffdc3 	ldbu	r2,-9(fp)
811100dc:	10803fcc 	andi	r2,r2,255
811100e0:	10800418 	cmpnei	r2,r2,16
811100e4:	1000051e 	bne	r2,zero,811100fc <vNFeeControlTask+0x20c>
						
						vPerformActionNFCConfig(uiCmdNFC.ulWord, pxFeeC);
811100e8:	e0bffd17 	ldw	r2,-12(fp)
811100ec:	e17ffa17 	ldw	r5,-24(fp)
811100f0:	1009883a 	mov	r4,r2
811100f4:	11102e80 	call	811102e8 <vPerformActionNFCConfig>
811100f8:	00000706 	br	81110118 <vNFeeControlTask+0x228>

					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"Provavel para FEE (Remover)\n");
811100fc:	d0a05e17 	ldw	r2,-32392(gp)
81110100:	100f883a 	mov	r7,r2
81110104:	01800704 	movi	r6,28
81110108:	01400044 	movi	r5,1
8111010c:	01204574 	movhi	r4,33045
81110110:	21242f04 	addi	r4,r4,-28484
81110114:	111d0b40 	call	8111d0b4 <fwrite>
						#endif
					}

					bDmaBack = TRUE;
81110118:	00800044 	movi	r2,1
8111011c:	d0a05515 	stw	r2,-32428(gp)
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
				}
				break;
81110120:	00007006 	br	811102e4 <vNFeeControlTask+0x3f4>
					}

					bDmaBack = TRUE;
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetQueueMaskNfeeCtrl();
81110124:	11194800 	call	81119480 <vCouldNotGetQueueMaskNfeeCtrl>
				}
				break;
81110128:	00006e06 	br	811102e4 <vNFeeControlTask+0x3f4>
					xQMaskFeeCtrl is How NFEE Controller receive Commands in a fat way and 
					xNfeeSchedule that has the schedule of access to the DMA (this has priority)*/
				

				/* Get the id of the FEE that wants DMA access */
				if ( bDmaBack == TRUE ) {
8111012c:	d0a05517 	ldw	r2,-32428(gp)
81110130:	10800058 	cmpnei	r2,r2,1
81110134:	1000201e 	bne	r2,zero,811101b8 <vNFeeControlTask+0x2c8>

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xNfeeSchedule, 4, &error_codeCtrl);
81110138:	d0a05917 	ldw	r2,-32412(gp)
8111013c:	e0fffe04 	addi	r3,fp,-8
81110140:	180d883a 	mov	r6,r3
81110144:	01400104 	movi	r5,4
81110148:	1009883a 	mov	r4,r2
8111014c:	1139bfc0 	call	81139bfc <OSQPend>
81110150:	e0bffd15 	stw	r2,-12(fp)
					if ( error_codeCtrl == OS_ERR_NONE ) {
81110154:	e0bffe03 	ldbu	r2,-8(fp)
81110158:	10803fcc 	andi	r2,r2,255
8111015c:	1000161e 	bne	r2,zero,811101b8 <vNFeeControlTask+0x2c8>
						ucFeeInstL = uiCmdNFC.ucByte[0];
81110160:	e0bffd03 	ldbu	r2,-12(fp)
81110164:	e0bffc05 	stb	r2,-16(fp)
#ifdef DEBUG_ON
	//fprintf(fp,"\nController: chegou agendamento ( %hhu )\n",ucFeeInstL);
#endif

						if (  pxFeeC->xNfee[ucFeeInstL].xControl.bUsingDMA == TRUE ) {
81110168:	e0bffc03 	ldbu	r2,-16(fp)
8111016c:	e0fffa17 	ldw	r3,-24(fp)
81110170:	10809524 	muli	r2,r2,596
81110174:	1885883a 	add	r2,r3,r2
81110178:	10802304 	addi	r2,r2,140
8111017c:	10800017 	ldw	r2,0(r2)
81110180:	10800058 	cmpnei	r2,r2,1
81110184:	10000c1e 	bne	r2,zero,811101b8 <vNFeeControlTask+0x2c8>
							bCmdSent = bSendCmdQToNFeeInst( ucFeeInstL, M_FEE_DMA_ACCESS, 0, ucFeeInstL );
81110188:	e0bffc03 	ldbu	r2,-16(fp)
8111018c:	e0fffc03 	ldbu	r3,-16(fp)
81110190:	180f883a 	mov	r7,r3
81110194:	000d883a 	mov	r6,zero
81110198:	014023c4 	movi	r5,143
8111019c:	1009883a 	mov	r4,r2
811101a0:	11104dc0 	call	811104dc <bSendCmdQToNFeeInst>
811101a4:	e0bffb15 	stw	r2,-20(fp)
							if ( bCmdSent == TRUE ) {
811101a8:	e0bffb17 	ldw	r2,-20(fp)
811101ac:	10800058 	cmpnei	r2,r2,1
811101b0:	1000011e 	bne	r2,zero,811101b8 <vNFeeControlTask+0x2c8>
								bDmaBack = FALSE;
811101b4:	d0205515 	stw	zero,-32428(gp)
							}
						}
					}
				} 

				if ( bDmaBack == FALSE ) {
811101b8:	d0a05517 	ldw	r2,-32428(gp)
811101bc:	1000081e 	bne	r2,zero,811101e0 <vNFeeControlTask+0x2f0>
#ifdef DEBUG_ON
	//fprintf(fp,"\nController: Esperando bloqueado FORVA pelo dma de volta na fila xQMaskFeeCtrl\n ");
#endif
					/* DMA with some NFEE instance */
					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 0, &error_codeCtrl);
811101c0:	d0a06c17 	ldw	r2,-32336(gp)
811101c4:	e0fffe04 	addi	r3,fp,-8
811101c8:	180d883a 	mov	r6,r3
811101cc:	000b883a 	mov	r5,zero
811101d0:	1009883a 	mov	r4,r2
811101d4:	1139bfc0 	call	81139bfc <OSQPend>
811101d8:	e0bffd15 	stw	r2,-12(fp)
811101dc:	00000706 	br	811101fc <vNFeeControlTask+0x30c>
				} else {
					/* If No FEE has the DMA */

					uiCmdNFC.ulWord = (unsigned int)OSQPend(xQMaskFeeCtrl, 4, &error_codeCtrl);
811101e0:	d0a06c17 	ldw	r2,-32336(gp)
811101e4:	e0fffe04 	addi	r3,fp,-8
811101e8:	180d883a 	mov	r6,r3
811101ec:	01400104 	movi	r5,4
811101f0:	1009883a 	mov	r4,r2
811101f4:	1139bfc0 	call	81139bfc <OSQPend>
811101f8:	e0bffd15 	stw	r2,-12(fp)
				}

				if ( error_codeCtrl == OS_ERR_NONE ){
811101fc:	e0bffe03 	ldbu	r2,-8(fp)
81110200:	10803fcc 	andi	r2,r2,255
81110204:	1000261e 	bne	r2,zero,811102a0 <vNFeeControlTask+0x3b0>
					/* Check if is some FEE giving the DMA back */
					if ( uiCmdNFC.ucByte[2] == M_NFC_DMA_GIVEBACK ) {
81110208:	e0bffd83 	ldbu	r2,-10(fp)
8111020c:	10803fcc 	andi	r2,r2,255
81110210:	10802058 	cmpnei	r2,r2,129
81110214:	1000031e 	bne	r2,zero,81110224 <vNFeeControlTask+0x334>
						bDmaBack = TRUE;
81110218:	00800044 	movi	r2,1
8111021c:	d0a05515 	stw	r2,-32428(gp)
81110220:	00001f06 	br	811102a0 <vNFeeControlTask+0x3b0>
//	fprintf(fp,"\nController: Devolveram o dma\n");
#endif
					} else {

						/* Check if the command is for NFEE Controller */
						if ( uiCmdNFC.ucByte[3] == M_FEE_CTRL_ADDR ) {
81110224:	e0bffdc3 	ldbu	r2,-9(fp)
81110228:	10803fcc 	andi	r2,r2,255
8111022c:	10800418 	cmpnei	r2,r2,16
81110230:	1000051e 	bne	r2,zero,81110248 <vNFeeControlTask+0x358>
							
#ifdef DEBUG_ON
	//fprintf(fp,"\nController:  Mensagem normal para FEE controller\n ");
#endif
							vPerformActionNFCRunning(uiCmdNFC.ulWord, pxFeeC);
81110234:	e0bffd17 	ldw	r2,-12(fp)
81110238:	e17ffa17 	ldw	r5,-24(fp)
8111023c:	1009883a 	mov	r4,r2
81110240:	11103b00 	call	811103b0 <vPerformActionNFCRunning>
81110244:	00001606 	br	811102a0 <vNFeeControlTask+0x3b0>

						} else {
							/* Check if the message if for any one of the instances of NFEE */
							if ( (uiCmdNFC.ucByte[3] >= M_NFEE_BASE_ADDR) && ( uiCmdNFC.ucByte[3] <= (M_NFEE_BASE_ADDR+N_OF_NFEE) ) ) {
81110248:	e0bffdc3 	ldbu	r2,-9(fp)
8111024c:	10803fcc 	andi	r2,r2,255
81110250:	10800470 	cmpltui	r2,r2,17
81110254:	1000121e 	bne	r2,zero,811102a0 <vNFeeControlTask+0x3b0>
81110258:	e0bffdc3 	ldbu	r2,-9(fp)
8111025c:	10803fcc 	andi	r2,r2,255
81110260:	108004e8 	cmpgeui	r2,r2,19
81110264:	10000e1e 	bne	r2,zero,811102a0 <vNFeeControlTask+0x3b0>

								//todo: tratar retorno
								bSendCmdQToNFeeInst( (uiCmdNFC.ucByte[3]-M_NFEE_BASE_ADDR), uiCmdNFC.ucByte[2], uiCmdNFC.ucByte[1], uiCmdNFC.ucByte[0] );
81110268:	e0bffdc3 	ldbu	r2,-9(fp)
8111026c:	10bffbc4 	addi	r2,r2,-17
81110270:	10803fcc 	andi	r2,r2,255
81110274:	e0fffd83 	ldbu	r3,-10(fp)
81110278:	18c03fcc 	andi	r3,r3,255
8111027c:	e13ffd43 	ldbu	r4,-11(fp)
81110280:	21003fcc 	andi	r4,r4,255
81110284:	e17ffd03 	ldbu	r5,-12(fp)
81110288:	29403fcc 	andi	r5,r5,255
8111028c:	280f883a 	mov	r7,r5
81110290:	200d883a 	mov	r6,r4
81110294:	180b883a 	mov	r5,r3
81110298:	1009883a 	mov	r4,r2
8111029c:	11104dc0 	call	811104dc <bSendCmdQToNFeeInst>

							}
						}
					}
				}
				OSTimeDlyHMSM(0,0,0,20); /*remover!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/
811102a0:	01c00504 	movi	r7,20
811102a4:	000d883a 	mov	r6,zero
811102a8:	000b883a 	mov	r5,zero
811102ac:	0009883a 	mov	r4,zero
811102b0:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
				break;		
811102b4:	00000b06 	br	811102e4 <vNFeeControlTask+0x3f4>
			default:
				#ifdef DEBUG_ON
					debug(fp,"NFEE Controller Task: Unknown state, backing to Config Mode.\n");
811102b8:	d0a05e17 	ldw	r2,-32392(gp)
811102bc:	100f883a 	mov	r7,r2
811102c0:	01800f44 	movi	r6,61
811102c4:	01400044 	movi	r5,1
811102c8:	01204574 	movhi	r4,33045
811102cc:	21243704 	addi	r4,r4,-28452
811102d0:	111d0b40 	call	8111d0b4 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxFeeC->sMode = sMebConfig;
811102d4:	e0bffa17 	ldw	r2,-24(fp)
811102d8:	00c000c4 	movi	r3,3
811102dc:	10c09915 	stw	r3,612(r2)
				break;
811102e0:	0001883a 	nop
		}
	}
811102e4:	003f1206 	br	8110ff30 <__reset+0xfb0eff30>

811102e8 <vPerformActionNFCConfig>:
}


void vPerformActionNFCConfig( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
811102e8:	defffb04 	addi	sp,sp,-20
811102ec:	de00012e 	bgeu	sp,et,811102f4 <vPerformActionNFCConfig+0xc>
811102f0:	003b68fa 	trap	3
811102f4:	dfc00415 	stw	ra,16(sp)
811102f8:	df000315 	stw	fp,12(sp)
811102fc:	df000304 	addi	fp,sp,12
81110300:	e13ffe15 	stw	r4,-8(fp)
81110304:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	INT8U errorCodeL;
	unsigned char i;

	uiCmdLocal.ulWord = uiCmdParam;
81110308:	e0bffe17 	ldw	r2,-8(fp)
8111030c:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
81110310:	e0bffd83 	ldbu	r2,-10(fp)
81110314:	10803fcc 	andi	r2,r2,255
81110318:	10c000a0 	cmpeqi	r3,r2,2
8111031c:	1800121e 	bne	r3,zero,81110368 <vPerformActionNFCConfig+0x80>
81110320:	10c000c8 	cmpgei	r3,r2,3
81110324:	1800031e 	bne	r3,zero,81110334 <vPerformActionNFCConfig+0x4c>
81110328:	10800060 	cmpeqi	r2,r2,1
8111032c:	1000061e 	bne	r2,zero,81110348 <vPerformActionNFCConfig+0x60>
81110330:	00001106 	br	81110378 <vPerformActionNFCConfig+0x90>
81110334:	10c02860 	cmpeqi	r3,r2,161
81110338:	1800031e 	bne	r3,zero,81110348 <vPerformActionNFCConfig+0x60>
8111033c:	108028a0 	cmpeqi	r2,r2,162
81110340:	1000091e 	bne	r2,zero,81110368 <vPerformActionNFCConfig+0x80>
81110344:	00000c06 	br	81110378 <vPerformActionNFCConfig+0x90>
		case M_NFC_CONFIG_FORCED:
		case M_NFC_CONFIG:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Config Mode\n");
81110348:	d0a05e17 	ldw	r2,-32392(gp)
8111034c:	100f883a 	mov	r7,r2
81110350:	01800d44 	movi	r6,53
81110354:	01400044 	movi	r5,1
81110358:	01204574 	movhi	r4,33045
8111035c:	21244704 	addi	r4,r4,-28388
81110360:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			/* Do nothing for now */
			break;
81110364:	00000c06 	br	81110398 <vPerformActionNFCConfig+0xb0>

		case M_NFC_RUN_FORCED:
		case M_NFC_RUN:
			pxFeeCP->sMode = sMebToRun;
81110368:	e0bfff17 	ldw	r2,-4(fp)
8111036c:	00c00084 	movi	r3,2
81110370:	10c09915 	stw	r3,612(r2)
			break;
81110374:	00000806 	br	81110398 <vPerformActionNFCConfig+0xb0>

		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknown Command.\n");
81110378:	d0a05e17 	ldw	r2,-32392(gp)
8111037c:	100f883a 	mov	r7,r2
81110380:	018009c4 	movi	r6,39
81110384:	01400044 	movi	r5,1
81110388:	01204574 	movhi	r4,33045
8111038c:	21245504 	addi	r4,r4,-28332
81110390:	111d0b40 	call	8111d0b4 <fwrite>
			#endif	
			break;
81110394:	0001883a 	nop
	}

}
81110398:	0001883a 	nop
8111039c:	e037883a 	mov	sp,fp
811103a0:	dfc00117 	ldw	ra,4(sp)
811103a4:	df000017 	ldw	fp,0(sp)
811103a8:	dec00204 	addi	sp,sp,8
811103ac:	f800283a 	ret

811103b0 <vPerformActionNFCRunning>:

void vPerformActionNFCRunning( unsigned int uiCmdParam, TNFee_Control *pxFeeCP ) {
811103b0:	defffa04 	addi	sp,sp,-24
811103b4:	de00012e 	bgeu	sp,et,811103bc <vPerformActionNFCRunning+0xc>
811103b8:	003b68fa 	trap	3
811103bc:	dfc00515 	stw	ra,20(sp)
811103c0:	df000415 	stw	fp,16(sp)
811103c4:	df000404 	addi	fp,sp,16
811103c8:	e13ffe15 	stw	r4,-8(fp)
811103cc:	e17fff15 	stw	r5,-4(fp)
	tQMask uiCmdLocal;
	unsigned char i;
	bool bCheckSimulation;

	uiCmdLocal.ulWord = uiCmdParam;
811103d0:	e0bffe17 	ldw	r2,-8(fp)
811103d4:	e0bffd15 	stw	r2,-12(fp)

	switch (uiCmdLocal.ucByte[2]) {
811103d8:	e0bffd83 	ldbu	r2,-10(fp)
811103dc:	10803fcc 	andi	r2,r2,255
811103e0:	10c000a0 	cmpeqi	r3,r2,2
811103e4:	1800271e 	bne	r3,zero,81110484 <vPerformActionNFCRunning+0xd4>
811103e8:	10c02860 	cmpeqi	r3,r2,161
811103ec:	1800021e 	bne	r3,zero,811103f8 <vPerformActionNFCRunning+0x48>
811103f0:	10800060 	cmpeqi	r2,r2,1
811103f4:	10002b26 	beq	r2,zero,811104a4 <vPerformActionNFCRunning+0xf4>
		case M_NFC_CONFIG:
		case M_NFC_CONFIG_FORCED:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Changing to Config Mode\n");
811103f8:	d0a05e17 	ldw	r2,-32392(gp)
811103fc:	100f883a 	mov	r7,r2
81110400:	01800b84 	movi	r6,46
81110404:	01400044 	movi	r5,1
81110408:	01204574 	movhi	r4,33045
8111040c:	21245f04 	addi	r4,r4,-28292
81110410:	111d0b40 	call	8111d0b4 <fwrite>
			#endif

			pxFeeCP->sMode = sMebToConfig;
81110414:	e0bfff17 	ldw	r2,-4(fp)
81110418:	00c00044 	movi	r3,1
8111041c:	10c09915 	stw	r3,612(r2)

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
81110420:	e03ffc05 	stb	zero,-16(fp)
81110424:	00001406 	br	81110478 <vPerformActionNFCRunning+0xc8>
			{
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
81110428:	e0bffc03 	ldbu	r2,-16(fp)
8111042c:	e0ffff17 	ldw	r3,-4(fp)
81110430:	10802584 	addi	r2,r2,150
81110434:	1085883a 	add	r2,r2,r2
81110438:	1085883a 	add	r2,r2,r2
8111043c:	1885883a 	add	r2,r3,r2
81110440:	10800017 	ldw	r2,0(r2)
81110444:	10800017 	ldw	r2,0(r2)
81110448:	10800058 	cmpnei	r2,r2,1
8111044c:	1000071e 	bne	r2,zero,8111046c <vPerformActionNFCRunning+0xbc>
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
81110450:	e0bffc03 	ldbu	r2,-16(fp)
81110454:	e0fffc03 	ldbu	r3,-16(fp)
81110458:	180f883a 	mov	r7,r3
8111045c:	000d883a 	mov	r6,zero
81110460:	01402844 	movi	r5,161
81110464:	1009883a 	mov	r4,r2
81110468:	11104dc0 	call	811104dc <bSendCmdQToNFeeInst>
			#endif

			pxFeeCP->sMode = sMebToConfig;

			/* Change all NFEEs to Config mode */
			for( i = 0; i < N_OF_NFEE; i++)
8111046c:	e0bffc03 	ldbu	r2,-16(fp)
81110470:	10800044 	addi	r2,r2,1
81110474:	e0bffc05 	stb	r2,-16(fp)
81110478:	e0bffc03 	ldbu	r2,-16(fp)
8111047c:	103fea26 	beq	r2,zero,81110428 <__reset+0xfb0f0428>
				if ( (*pxFeeCP->pbEnabledNFEEs[i]) == TRUE ) {
					bSendCmdQToNFeeInst( i, M_FEE_CONFIG_FORCED, 0, i  );
				}
			}

			break;
81110480:	00001006 	br	811104c4 <vPerformActionNFCRunning+0x114>
		case M_NFC_RUN:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: NFC already in the Running Mode\n");
81110484:	d0a05e17 	ldw	r2,-32392(gp)
81110488:	100f883a 	mov	r7,r2
8111048c:	01800d84 	movi	r6,54
81110490:	01400044 	movi	r5,1
81110494:	01204574 	movhi	r4,33045
81110498:	21246b04 	addi	r4,r4,-28244
8111049c:	111d0b40 	call	8111d0b4 <fwrite>
			#endif		
			/* Do nothing for now */

			break;		
811104a0:	00000806 	br	811104c4 <vPerformActionNFCRunning+0x114>
		default:
			#ifdef DEBUG_ON
				debug(fp,"NFEE Controller Task: Unknow Command.\n");
811104a4:	d0a05e17 	ldw	r2,-32392(gp)
811104a8:	100f883a 	mov	r7,r2
811104ac:	01800984 	movi	r6,38
811104b0:	01400044 	movi	r5,1
811104b4:	01204574 	movhi	r4,33045
811104b8:	21247904 	addi	r4,r4,-28188
811104bc:	111d0b40 	call	8111d0b4 <fwrite>
			#endif	
			break;
811104c0:	0001883a 	nop
	}
}
811104c4:	0001883a 	nop
811104c8:	e037883a 	mov	sp,fp
811104cc:	dfc00117 	ldw	ra,4(sp)
811104d0:	df000017 	ldw	fp,0(sp)
811104d4:	dec00204 	addi	sp,sp,8
811104d8:	f800283a 	ret

811104dc <bSendCmdQToNFeeInst>:


bool bSendCmdQToNFeeInst( unsigned char ucFeeInstP, unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811104dc:	defff704 	addi	sp,sp,-36
811104e0:	de00012e 	bgeu	sp,et,811104e8 <bSendCmdQToNFeeInst+0xc>
811104e4:	003b68fa 	trap	3
811104e8:	dfc00815 	stw	ra,32(sp)
811104ec:	df000715 	stw	fp,28(sp)
811104f0:	df000704 	addi	fp,sp,28
811104f4:	2011883a 	mov	r8,r4
811104f8:	2809883a 	mov	r4,r5
811104fc:	3007883a 	mov	r3,r6
81110500:	3805883a 	mov	r2,r7
81110504:	e23ffc05 	stb	r8,-16(fp)
81110508:	e13ffd05 	stb	r4,-12(fp)
8111050c:	e0fffe05 	stb	r3,-8(fp)
81110510:	e0bfff05 	stb	r2,-4(fp)
	bool bSuccesL;
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucFeeInstP;
81110514:	e0bffc03 	ldbu	r2,-16(fp)
81110518:	10800444 	addi	r2,r2,17
8111051c:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81110520:	e0bffd03 	ldbu	r2,-12(fp)
81110524:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81110528:	e0bffe03 	ldbu	r2,-8(fp)
8111052c:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81110530:	e0bfff03 	ldbu	r2,-4(fp)
81110534:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	bSuccesL = FALSE;
81110538:	e03ff915 	stw	zero,-28(fp)
	error_codel = OSQPost(xFeeQ[ ucFeeInstP ], (void *)uiCmdtoSend.ulWord);
8111053c:	e0bffc03 	ldbu	r2,-16(fp)
81110540:	1085883a 	add	r2,r2,r2
81110544:	1087883a 	add	r3,r2,r2
81110548:	d0a06604 	addi	r2,gp,-32360
8111054c:	1885883a 	add	r2,r3,r2
81110550:	10800017 	ldw	r2,0(r2)
81110554:	e0fffb17 	ldw	r3,-20(fp)
81110558:	180b883a 	mov	r5,r3
8111055c:	1009883a 	mov	r4,r2
81110560:	113a0040 	call	8113a004 <OSQPost>
81110564:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
81110568:	e0bffa03 	ldbu	r2,-24(fp)
8111056c:	10000526 	beq	r2,zero,81110584 <bSendCmdQToNFeeInst+0xa8>
		vFailSendMsgAccessDMA( ucFeeInstP );
81110570:	e0bffc03 	ldbu	r2,-16(fp)
81110574:	1009883a 	mov	r4,r2
81110578:	11195500 	call	81119550 <vFailSendMsgAccessDMA>
		bSuccesL = FALSE;
8111057c:	e03ff915 	stw	zero,-28(fp)
81110580:	00000206 	br	8111058c <bSendCmdQToNFeeInst+0xb0>
	} else {
		bSuccesL =  TRUE;
81110584:	00800044 	movi	r2,1
81110588:	e0bff915 	stw	r2,-28(fp)
	}

	return bSuccesL;
8111058c:	e0bff917 	ldw	r2,-28(fp)
}
81110590:	e037883a 	mov	sp,fp
81110594:	dfc00117 	ldw	ra,4(sp)
81110598:	df000017 	ldw	fp,0(sp)
8111059c:	dec00204 	addi	sp,sp,8
811105a0:	f800283a 	ret

811105a4 <vOutAckHandlerTask>:
 */

#include "out_ack_handler_task.h"


void vOutAckHandlerTask(void *task_data) {
811105a4:	defff704 	addi	sp,sp,-36
811105a8:	de00012e 	bgeu	sp,et,811105b0 <vOutAckHandlerTask+0xc>
811105ac:	003b68fa 	trap	3
811105b0:	dfc00815 	stw	ra,32(sp)
811105b4:	df000715 	stw	fp,28(sp)
811105b8:	df000704 	addi	fp,sp,28
811105bc:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;
	tSerderACKState eSenderAckState;
	static txSenderACKs xSAckLocal;
    char cBufferAck[16] = "";
811105c0:	e03ffac5 	stb	zero,-21(fp)
811105c4:	e03ffb05 	stb	zero,-20(fp)
811105c8:	e03ffb45 	stb	zero,-19(fp)
811105cc:	e03ffb85 	stb	zero,-18(fp)
811105d0:	e03ffbc5 	stb	zero,-17(fp)
811105d4:	e03ffc05 	stb	zero,-16(fp)
811105d8:	e03ffc45 	stb	zero,-15(fp)
811105dc:	e03ffc85 	stb	zero,-14(fp)
811105e0:	e03ffcc5 	stb	zero,-13(fp)
811105e4:	e03ffd05 	stb	zero,-12(fp)
811105e8:	e03ffd45 	stb	zero,-11(fp)
811105ec:	e03ffd85 	stb	zero,-10(fp)
811105f0:	e03ffdc5 	stb	zero,-9(fp)
811105f4:	e03ffe05 	stb	zero,-8(fp)
811105f8:	e03ffe45 	stb	zero,-7(fp)
811105fc:	e03ffe85 	stb	zero,-6(fp)
    unsigned char crc = 0;
81110600:	e03ffa45 	stb	zero,-23(fp)

	#ifdef DEBUG_ON
		debug(fp,"Out Ack Handler Task. (Task on)\n");
81110604:	d0a05e17 	ldw	r2,-32392(gp)
81110608:	100f883a 	mov	r7,r2
8111060c:	01800804 	movi	r6,32
81110610:	01400044 	movi	r5,1
81110614:	01204574 	movhi	r4,33045
81110618:	21248304 	addi	r4,r4,-28148
8111061c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	eSenderAckState = sSAConfiguring;
81110620:	e03ff915 	stw	zero,-28(fp)

	for(;;){

		switch (eSenderAckState) {
81110624:	e0bff917 	ldw	r2,-28(fp)
81110628:	10c00060 	cmpeqi	r3,r2,1
8111062c:	1800071e 	bne	r3,zero,8111064c <vOutAckHandlerTask+0xa8>
81110630:	0080032e 	bgeu	zero,r2,81110640 <vOutAckHandlerTask+0x9c>
81110634:	108000a0 	cmpeqi	r2,r2,2
81110638:	1000471e 	bne	r2,zero,81110758 <vOutAckHandlerTask+0x1b4>
8111063c:	00008c06 	br	81110870 <vOutAckHandlerTask+0x2cc>
			case sSAConfiguring:
                /*For future implementations*/
                eSenderAckState = sSAGettingACK;
81110640:	00800044 	movi	r2,1
81110644:	e0bff915 	stw	r2,-28(fp)
				break;
81110648:	00009306 	br	81110898 <vOutAckHandlerTask+0x2f4>
            case sSAGettingACK:
                /* Waits the semaphore that indicates there are some ack message to send*/
                eSenderAckState = sSAGettingACK;
8111064c:	00800044 	movi	r2,1
81110650:	e0bff915 	stw	r2,-28(fp)
                OSSemPend(xSemCountSenderACK, 0, &error_code);
81110654:	d0a05d17 	ldw	r2,-32396(gp)
81110658:	e0fffa84 	addi	r3,fp,-22
8111065c:	180d883a 	mov	r6,r3
81110660:	000b883a 	mov	r5,zero
81110664:	1009883a 	mov	r4,r2
81110668:	113aaf40 	call	8113aaf4 <OSSemPend>
                if ( error_code == OS_ERR_NONE ) {
8111066c:	e0bffa83 	ldbu	r2,-22(fp)
81110670:	10803fcc 	andi	r2,r2,255
81110674:	1000361e 	bne	r2,zero,81110750 <vOutAckHandlerTask+0x1ac>

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
81110678:	d0a06e17 	ldw	r2,-32328(gp)
8111067c:	e0fffa84 	addi	r3,fp,-22
81110680:	180d883a 	mov	r6,r3
81110684:	000b883a 	mov	r5,zero
81110688:	1009883a 	mov	r4,r2
8111068c:	1138ae80 	call	81138ae8 <OSMutexPend>
                    if ( error_code == OS_ERR_NONE ) {
81110690:	e0bffa83 	ldbu	r2,-22(fp)
81110694:	10803fcc 	andi	r2,r2,255
81110698:	10002b1e 	bne	r2,zero,81110748 <vOutAckHandlerTask+0x1a4>
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
8111069c:	e03ffa05 	stb	zero,-24(fp)
811106a0:	00002206 	br	8111072c <vOutAckHandlerTask+0x188>
                        {
                            if ( xSenderACK[i].cType != 0 ) {
811106a4:	e0fffa03 	ldbu	r3,-24(fp)
811106a8:	00a045b4 	movhi	r2,33046
811106ac:	10885004 	addi	r2,r2,8512
811106b0:	18c7883a 	add	r3,r3,r3
811106b4:	18c7883a 	add	r3,r3,r3
811106b8:	10c5883a 	add	r2,r2,r3
811106bc:	10800003 	ldbu	r2,0(r2)
811106c0:	10803fcc 	andi	r2,r2,255
811106c4:	1080201c 	xori	r2,r2,128
811106c8:	10bfe004 	addi	r2,r2,-128
811106cc:	10001426 	beq	r2,zero,81110720 <vOutAckHandlerTask+0x17c>
                                /* Locate the message, copy for the local variable in order to free the mutex. */
                                xSAckLocal = xSenderACK[i];
811106d0:	e0fffa03 	ldbu	r3,-24(fp)
811106d4:	00a045b4 	movhi	r2,33046
811106d8:	10885004 	addi	r2,r2,8512
811106dc:	18c7883a 	add	r3,r3,r3
811106e0:	18c7883a 	add	r3,r3,r3
811106e4:	10c5883a 	add	r2,r2,r3
811106e8:	10c0000b 	ldhu	r3,0(r2)
811106ec:	d0e0560d 	sth	r3,-32424(gp)
811106f0:	1080008b 	ldhu	r2,2(r2)
811106f4:	d0a0568d 	sth	r2,-32422(gp)
                                eSenderAckState = sSASending;
811106f8:	00800084 	movi	r2,2
811106fc:	e0bff915 	stw	r2,-28(fp)
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
81110700:	e0fffa03 	ldbu	r3,-24(fp)
81110704:	00a045b4 	movhi	r2,33046
81110708:	10885004 	addi	r2,r2,8512
8111070c:	18c7883a 	add	r3,r3,r3
81110710:	18c7883a 	add	r3,r3,r3
81110714:	10c5883a 	add	r2,r2,r3
81110718:	10000005 	stb	zero,0(r2)
                                break;
8111071c:	00000606 	br	81110738 <vOutAckHandlerTask+0x194>
                if ( error_code == OS_ERR_NONE ) {

                    OSMutexPend(xMutexSenderACK, 0, &error_code);
                    if ( error_code == OS_ERR_NONE ) {
                        /*Search for the ack*/
                        for(unsigned char i = 0; i < N_ACKS_SENDER; i++)
81110720:	e0bffa03 	ldbu	r2,-24(fp)
81110724:	10800044 	addi	r2,r2,1
81110728:	e0bffa05 	stb	r2,-24(fp)
8111072c:	e0bffa03 	ldbu	r2,-24(fp)
81110730:	10800230 	cmpltui	r2,r2,8
81110734:	103fdb1e 	bne	r2,zero,811106a4 <__reset+0xfb0f06a4>
                                eSenderAckState = sSASending;
                                xSenderACK[i].cType = 0; /* indicates that this position now can be used by other message*/
                                break;
                            }
                        }
                        OSMutexPost(xMutexSenderACK);
81110738:	d0a06e17 	ldw	r2,-32328(gp)
8111073c:	1009883a 	mov	r4,r2
81110740:	113908c0 	call	8113908c <OSMutexPost>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
81110744:	00005406 	br	81110898 <vOutAckHandlerTask+0x2f4>
                        }
                        OSMutexPost(xMutexSenderACK);
                    } else {
                        /*  Should never get here, will wait without timeout for the semaphore.
                            But if some error accours we will do nothing but print in the console */
                        vFailGetMutexSenderTask();
81110748:	1117d640 	call	81117d64 <vFailGetMutexSenderTask>
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
                }

                break;
8111074c:	00005206 	br	81110898 <vOutAckHandlerTask+0x2f4>
                    }

                } else {
                    /*  Should never get here, will wait without timeout for the semaphore.
                        But if some error accours we will do nothing but print in the console */
                    vFailGetCountSemaphoreSenderTask();
81110750:	1117cfc0 	call	81117cfc <vFailGetCountSemaphoreSenderTask>
                }

                break;
81110754:	00005006 	br	81110898 <vOutAckHandlerTask+0x2f4>
			case sSASending:
                
                /* First check if is an NACK packet that should be sent */
                if ( xSAckLocal.cType != '#' ) {
81110758:	d0a05603 	ldbu	r2,-32424(gp)
8111075c:	10803fcc 	andi	r2,r2,255
81110760:	1080201c 	xori	r2,r2,128
81110764:	10bfe004 	addi	r2,r2,-128
81110768:	108008e0 	cmpeqi	r2,r2,35
8111076c:	1000201e 	bne	r2,zero,811107f0 <vOutAckHandlerTask+0x24c>
                    /* In this state has a parsed ack packet in the variable xSAckLocal
                    we just need to calc the crc8 and create the uart packet to send. */
                    sprintf(cBufferAck, ACK_SPRINTF, xSAckLocal.cCommand, xSAckLocal.usiId);
81110770:	d0a05643 	ldbu	r2,-32423(gp)
81110774:	10c03fcc 	andi	r3,r2,255
81110778:	18c0201c 	xori	r3,r3,128
8111077c:	18ffe004 	addi	r3,r3,-128
81110780:	d0a0568b 	ldhu	r2,-32422(gp)
81110784:	113fffcc 	andi	r4,r2,65535
81110788:	e0bffac4 	addi	r2,fp,-21
8111078c:	200f883a 	mov	r7,r4
81110790:	180d883a 	mov	r6,r3
81110794:	01604574 	movhi	r5,33045
81110798:	29648c04 	addi	r5,r5,-28112
8111079c:	1009883a 	mov	r4,r2
811107a0:	111e3a80 	call	8111e3a8 <sprintf>
                    crc = ucCrc8wInit( cBufferAck , strlen(cBufferAck));
811107a4:	e0bffac4 	addi	r2,fp,-21
811107a8:	1009883a 	mov	r4,r2
811107ac:	111e5bc0 	call	8111e5bc <strlen>
811107b0:	1007883a 	mov	r3,r2
811107b4:	e0bffac4 	addi	r2,fp,-21
811107b8:	180b883a 	mov	r5,r3
811107bc:	1009883a 	mov	r4,r2
811107c0:	11178c00 	call	811178c0 <ucCrc8wInit>
811107c4:	e0bffa45 	stb	r2,-23(fp)
                    sprintf(cBufferAck, "%s|%hhu;", cBufferAck, crc);
811107c8:	e13ffa43 	ldbu	r4,-23(fp)
811107cc:	e0fffac4 	addi	r3,fp,-21
811107d0:	e0bffac4 	addi	r2,fp,-21
811107d4:	200f883a 	mov	r7,r4
811107d8:	180d883a 	mov	r6,r3
811107dc:	01604574 	movhi	r5,33045
811107e0:	29648e04 	addi	r5,r5,-28104
811107e4:	1009883a 	mov	r4,r2
811107e8:	111e3a80 	call	8111e3a8 <sprintf>
811107ec:	00000c06 	br	81110820 <vOutAckHandlerTask+0x27c>
                } else {
                    /* Nack */
                    sprintf(cBufferAck, "%s", NACK_SEQUENCE);
811107f0:	e0bffac4 	addi	r2,fp,-21
811107f4:	00c008c4 	movi	r3,35
811107f8:	10c00005 	stb	r3,0(r2)
811107fc:	00c01f04 	movi	r3,124
81110800:	10c00045 	stb	r3,1(r2)
81110804:	00c00d44 	movi	r3,53
81110808:	10c00085 	stb	r3,2(r2)
8111080c:	00c00d04 	movi	r3,52
81110810:	10c000c5 	stb	r3,3(r2)
81110814:	00c00ec4 	movi	r3,59
81110818:	10c00105 	stb	r3,4(r2)
8111081c:	10000145 	stb	zero,5(r2)
                }


                OSMutexPend(xTxUARTMutex, 100, &error_code); /* Wait max 100 ticks = 100 ms */
81110820:	d0a07017 	ldw	r2,-32320(gp)
81110824:	e0fffa84 	addi	r3,fp,-22
81110828:	180d883a 	mov	r6,r3
8111082c:	01401904 	movi	r5,100
81110830:	1009883a 	mov	r4,r2
81110834:	1138ae80 	call	81138ae8 <OSMutexPend>
                if ( error_code == OS_NO_ERR ) {
81110838:	e0bffa83 	ldbu	r2,-22(fp)
8111083c:	10803fcc 	andi	r2,r2,255
81110840:	1000071e 	bne	r2,zero,81110860 <vOutAckHandlerTask+0x2bc>
                    puts(cBufferAck);
81110844:	e0bffac4 	addi	r2,fp,-21
81110848:	1009883a 	mov	r4,r2
8111084c:	111e0640 	call	8111e064 <puts>
                    OSMutexPost(xTxUARTMutex);
81110850:	d0a07017 	ldw	r2,-32320(gp)
81110854:	1009883a 	mov	r4,r2
81110858:	113908c0 	call	8113908c <OSMutexPost>
8111085c:	00000106 	br	81110864 <vOutAckHandlerTask+0x2c0>
                } else
                    vFailGetMutexTxUARTSenderTask(); /* Could not use the uart tx buffer to send the ack*/
81110860:	1117e9c0 	call	81117e9c <vFailGetMutexTxUARTSenderTask>

                eSenderAckState = sSAGettingACK;
81110864:	00800044 	movi	r2,1
81110868:	e0bff915 	stw	r2,-28(fp)
                
				break;
8111086c:	00000a06 	br	81110898 <vOutAckHandlerTask+0x2f4>
			default:
            	#ifdef DEBUG_ON
		            debug(fp,"Critical: Default State. Should never get here.(vOutAckHandlerTask)\n");
81110870:	d0a05e17 	ldw	r2,-32392(gp)
81110874:	100f883a 	mov	r7,r2
81110878:	01801104 	movi	r6,68
8111087c:	01400044 	movi	r5,1
81110880:	01204574 	movhi	r4,33045
81110884:	21249104 	addi	r4,r4,-28092
81110888:	111d0b40 	call	8111d0b4 <fwrite>
	            #endif
                eSenderAckState = sSAGettingACK;
8111088c:	00800044 	movi	r2,1
81110890:	e0bff915 	stw	r2,-28(fp)
				break;
81110894:	0001883a 	nop
		}
	}
81110898:	003f6206 	br	81110624 <__reset+0xfb0f0624>

8111089c <vParserCommTask>:


#include "parser_comm_task.h"


void vParserCommTask(void *task_data) {
8111089c:	deffd704 	addi	sp,sp,-164
811108a0:	de00012e 	bgeu	sp,et,811108a8 <vParserCommTask+0xc>
811108a4:	003b68fa 	trap	3
811108a8:	dfc02815 	stw	ra,160(sp)
811108ac:	df002715 	stw	fp,156(sp)
811108b0:	df002704 	addi	fp,sp,156
811108b4:	e13fff15 	stw	r4,-4(fp)
	unsigned short int usiFeeInstL;
	bool bSuccess = FALSE;
811108b8:	e03fdd15 	stw	zero,-140(fp)
	#ifdef DEBUG_ON
		char cPUSDebug[128];
	#endif

    #ifdef DEBUG_ON
        debug(fp,"Parser Comm Task. (Task on)\n");
811108bc:	d0a05e17 	ldw	r2,-32392(gp)
811108c0:	100f883a 	mov	r7,r2
811108c4:	01800704 	movi	r6,28
811108c8:	01400044 	movi	r5,1
811108cc:	01204574 	movhi	r4,33045
811108d0:	2124a304 	addi	r4,r4,-28020
811108d4:	111d0b40 	call	8111d0b4 <fwrite>
    #endif

	eParserMode = sConfiguring;
811108d8:	e03fdc15 	stw	zero,-144(fp)

	for(;;){

		switch (eParserMode) {
811108dc:	e0bfdc17 	ldw	r2,-144(fp)
811108e0:	10800168 	cmpgeui	r2,r2,5
811108e4:	1003651e 	bne	r2,zero,8111167c <vParserCommTask+0xde0>
811108e8:	e0bfdc17 	ldw	r2,-144(fp)
811108ec:	100690ba 	slli	r3,r2,2
811108f0:	00a04474 	movhi	r2,33041
811108f4:	10824104 	addi	r2,r2,2308
811108f8:	1885883a 	add	r2,r3,r2
811108fc:	10800017 	ldw	r2,0(r2)
81110900:	1000683a 	jmp	r2
81110904:	81110918 	cmpnei	r4,r16,17444
81110908:	81110924 	muli	r4,r16,17444
8111090c:	811109b8 	rdprs	r4,r16,17446
81110910:	81110b1c 	xori	r4,r16,17452
81110914:	81110b60 	cmpeqi	r4,r16,17453
			case sConfiguring:
				/*For future implementations*/
				eParserMode = sWaitingMessage;
81110918:	00800044 	movi	r2,1
8111091c:	e0bfdc15 	stw	r2,-144(fp)
				break;
81110920:	00035906 	br	81111688 <vParserCommTask+0xdec>
			case sWaitingMessage:

				bSuccess = FALSE;
81110924:	e03fdd15 	stw	zero,-140(fp)
				eParserMode = sWaitingMessage;
81110928:	00800044 	movi	r2,1
8111092c:	e0bfdc15 	stw	r2,-144(fp)

				OSSemPend(xSemCountPreParsed, 0, &error_code); /*Blocking*/
81110930:	d0a06017 	ldw	r2,-32384(gp)
81110934:	e0ffde84 	addi	r3,fp,-134
81110938:	180d883a 	mov	r6,r3
8111093c:	000b883a 	mov	r5,zero
81110940:	1009883a 	mov	r4,r2
81110944:	113aaf40 	call	8113aaf4 <OSSemPend>
				if ( error_code == OS_ERR_NONE ) {
81110948:	e0bfde83 	ldbu	r2,-134(fp)
8111094c:	10803fcc 	andi	r2,r2,255
81110950:	1000171e 	bne	r2,zero,811109b0 <vParserCommTask+0x114>
					/* There's command waiting to be threat */

					bSuccess = getPreParsedPacket(&PreParsedLocal); /*Blocking*/
81110954:	01204574 	movhi	r4,33045
81110958:	213b3104 	addi	r4,r4,-4924
8111095c:	111168c0 	call	8111168c <getPreParsedPacket>
81110960:	e0bfdd15 	stw	r2,-140(fp)
					if (bSuccess == TRUE) {
81110964:	e0bfdd17 	ldw	r2,-140(fp)
81110968:	10800058 	cmpnei	r2,r2,1
8111096c:	10000e1e 	bne	r2,zero,811109a8 <vParserCommTask+0x10c>
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
81110970:	00a04574 	movhi	r2,33045
81110974:	10bb3104 	addi	r2,r2,-4924
81110978:	10800103 	ldbu	r2,4(r2)
8111097c:	10803fcc 	andi	r2,r2,255
81110980:	1080201c 	xori	r2,r2,128
81110984:	10bfe004 	addi	r2,r2,-128
81110988:	10800858 	cmpnei	r2,r2,33
8111098c:	1000031e 	bne	r2,zero,8111099c <vParserCommTask+0x100>
							eParserMode = sReplyParsing;
81110990:	008000c4 	movi	r2,3
81110994:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
81110998:	00033b06 	br	81111688 <vParserCommTask+0xdec>
					if (bSuccess == TRUE) {
						/* PreParsed Content copied to the local variable */
						if ( PreParsedLocal.cType == START_REPLY_CHAR )
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
8111099c:	00800084 	movi	r2,2
811109a0:	e0bfdc15 	stw	r2,-144(fp)
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811109a4:	00033806 	br	81111688 <vParserCommTask+0xdec>
							eParserMode = sReplyParsing;
						else
							eParserMode = sRequestParsing;
					} else {
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
811109a8:	11184280 	call	81118428 <vNoContentInPreParsedBuffer>
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
				}
				break;
811109ac:	00033606 	br	81111688 <vParserCommTask+0xdec>
						/* Semaphore was post by some task but has no message in the PreParsedBuffer*/
						vNoContentInPreParsedBuffer();
					}

				} else {
					vFailGetCountSemaphorePreParsedBuffer();
811109b0:	11183580 	call	81118358 <vFailGetCountSemaphorePreParsedBuffer>
				}
				break;
811109b4:	00033406 	br	81111688 <vParserCommTask+0xdec>
			case sRequestParsing:
				/* Final parssing after identify that is a request packet */
				/* ATTENTION: In order to avoid overhead of process the response to NUC of simple Requests
				   will be threat here, and send from here the parser_rx.*/
			   	switch (PreParsedLocal.cCommand)
811109b8:	00a04574 	movhi	r2,33045
811109bc:	10bb3104 	addi	r2,r2,-4924
811109c0:	10800143 	ldbu	r2,5(r2)
811109c4:	10803fcc 	andi	r2,r2,255
811109c8:	1080201c 	xori	r2,r2,128
811109cc:	10bfe004 	addi	r2,r2,-128
811109d0:	10c010e0 	cmpeqi	r3,r2,67
811109d4:	1800031e 	bne	r3,zero,811109e4 <vParserCommTask+0x148>
811109d8:	10801420 	cmpeqi	r2,r2,80
811109dc:	1000051e 	bne	r2,zero,811109f4 <vParserCommTask+0x158>
811109e0:	00004a06 	br	81110b0c <vParserCommTask+0x270>
				{
					case ETH_CMD: /*NUC requested the ETH Configuration*/
						vSendEthConf();
811109e4:	11160900 	call	81116090 <vSendEthConf>
						eParserMode = sWaitingMessage;
811109e8:	00800044 	movi	r2,1
811109ec:	e0bfdc15 	stw	r2,-144(fp)
						break;
811109f0:	00004906 	br	81110b18 <vParserCommTask+0x27c>
                    case PUS_CMD: /*PUS command to MEB - TC*/

						#ifdef DEBUG_ON
							memset(cPUSDebug,0,128);
811109f4:	e0bfdec4 	addi	r2,fp,-133
811109f8:	01802004 	movi	r6,128
811109fc:	000b883a 	mov	r5,zero
81110a00:	1009883a 	mov	r4,r2
81110a04:	111dc180 	call	8111dc18 <memset>
							sprintf(cPUSDebug, "\nParser Task: TC-> pid: %hu; pcat: %hu; srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", PreParsedLocal.usiValues[1], PreParsedLocal.usiValues[2], PreParsedLocal.usiValues[3], PreParsedLocal.usiValues[4], PreParsedLocal.usiValues[5]);
81110a08:	00a04574 	movhi	r2,33045
81110a0c:	10bb3104 	addi	r2,r2,-4924
81110a10:	1080028b 	ldhu	r2,10(r2)
81110a14:	117fffcc 	andi	r5,r2,65535
81110a18:	00a04574 	movhi	r2,33045
81110a1c:	10bb3104 	addi	r2,r2,-4924
81110a20:	1080030b 	ldhu	r2,12(r2)
81110a24:	11bfffcc 	andi	r6,r2,65535
81110a28:	00a04574 	movhi	r2,33045
81110a2c:	10bb3104 	addi	r2,r2,-4924
81110a30:	1080038b 	ldhu	r2,14(r2)
81110a34:	10ffffcc 	andi	r3,r2,65535
81110a38:	00a04574 	movhi	r2,33045
81110a3c:	10bb3104 	addi	r2,r2,-4924
81110a40:	1080040b 	ldhu	r2,16(r2)
81110a44:	113fffcc 	andi	r4,r2,65535
81110a48:	00a04574 	movhi	r2,33045
81110a4c:	10bb3104 	addi	r2,r2,-4924
81110a50:	1080048b 	ldhu	r2,18(r2)
81110a54:	10bfffcc 	andi	r2,r2,65535
81110a58:	e23fdec4 	addi	r8,fp,-133
81110a5c:	d8800215 	stw	r2,8(sp)
81110a60:	d9000115 	stw	r4,4(sp)
81110a64:	d8c00015 	stw	r3,0(sp)
81110a68:	300f883a 	mov	r7,r6
81110a6c:	280d883a 	mov	r6,r5
81110a70:	01604574 	movhi	r5,33045
81110a74:	2964ab04 	addi	r5,r5,-27988
81110a78:	4009883a 	mov	r4,r8
81110a7c:	111e3a80 	call	8111e3a8 <sprintf>
							debug(fp, cPUSDebug );
81110a80:	d0a05e17 	ldw	r2,-32392(gp)
81110a84:	e0ffdec4 	addi	r3,fp,-133
81110a88:	180b883a 	mov	r5,r3
81110a8c:	1009883a 	mov	r4,r2
81110a90:	111ca180 	call	8111ca18 <fprintf>
						#endif
	
						xTcPusL.usiCat	= PreParsedLocal.usiValues[2];
81110a94:	00a04574 	movhi	r2,33045
81110a98:	10bb3104 	addi	r2,r2,-4924
81110a9c:	10c0030b 	ldhu	r3,12(r2)
81110aa0:	00a04574 	movhi	r2,33045
81110aa4:	10bb4404 	addi	r2,r2,-4848
81110aa8:	10c0028d 	sth	r3,10(r2)
						xTcPusL.usiType = PreParsedLocal.usiValues[3];
81110aac:	00a04574 	movhi	r2,33045
81110ab0:	10bb3104 	addi	r2,r2,-4924
81110ab4:	10c0038b 	ldhu	r3,14(r2)
81110ab8:	00a04574 	movhi	r2,33045
81110abc:	10bb4404 	addi	r2,r2,-4848
81110ac0:	10c0030d 	sth	r3,12(r2)
						xTcPusL.usiSubType = PreParsedLocal.usiValues[4];
81110ac4:	00a04574 	movhi	r2,33045
81110ac8:	10bb3104 	addi	r2,r2,-4924
81110acc:	10c0040b 	ldhu	r3,16(r2)
81110ad0:	00a04574 	movhi	r2,33045
81110ad4:	10bb4404 	addi	r2,r2,-4848
81110ad8:	10c0038d 	sth	r3,14(r2)
						xTcPusL.usiPusId = PreParsedLocal.usiValues[5];
81110adc:	00a04574 	movhi	r2,33045
81110ae0:	10bb3104 	addi	r2,r2,-4924
81110ae4:	10c0048b 	ldhu	r3,18(r2)
81110ae8:	00a04574 	movhi	r2,33045
81110aec:	10bb4404 	addi	r2,r2,-4848
81110af0:	10c0040d 	sth	r3,16(r2)
						xTcPusL.ucNofValues = 0; /* Don't assume that has values */
81110af4:	00a04574 	movhi	r2,33045
81110af8:	10bb4404 	addi	r2,r2,-4848
81110afc:	10000485 	stb	zero,18(r2)

						eParserMode = sPusHandling;
81110b00:	00800104 	movi	r2,4
81110b04:	e0bfdc15 	stw	r2,-144(fp)
                        break;						
81110b08:	00000306 	br	81110b18 <vParserCommTask+0x27c>
					default:
						eParserMode = sWaitingMessage;
81110b0c:	00800044 	movi	r2,1
81110b10:	e0bfdc15 	stw	r2,-144(fp)
						break;
81110b14:	0001883a 	nop
				}
				break;
81110b18:	0002db06 	br	81111688 <vParserCommTask+0xdec>
			case sReplyParsing:
				eParserMode = sWaitingMessage;
81110b1c:	00800044 	movi	r2,1
81110b20:	e0bfdc15 	stw	r2,-144(fp)
                switch ( xTcPusL.usiType )
81110b24:	00a04574 	movhi	r2,33045
81110b28:	10bb4404 	addi	r2,r2,-4848
81110b2c:	1080030b 	ldhu	r2,12(r2)
81110b30:	10bfffcc 	andi	r2,r2,65535
81110b34:	10c01220 	cmpeqi	r3,r2,72
81110b38:	1800051e 	bne	r3,zero,81110b50 <vParserCommTask+0x2b4>
81110b3c:	108014e0 	cmpeqi	r2,r2,83
81110b40:	1000051e 	bne	r2,zero,81110b58 <vParserCommTask+0x2bc>
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
                    default:
						eParserMode = sWaitingMessage;
81110b44:	00800044 	movi	r2,1
81110b48:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81110b4c:	00000306 	br	81110b5c <vParserCommTask+0x2c0>
						
                        break;
                    case HEART_BEAT_CMD: /*Heart beating (NUC are you there?)*/

						
                        break;
81110b50:	0001883a 	nop
81110b54:	0002cc06 	br	81111688 <vParserCommTask+0xdec>
                switch ( xTcPusL.usiType )
                {
                    case NUC_STATUS_CMD: /*Status from NUC*/

						
                        break;
81110b58:	0001883a 	nop
                        break;
                    default:
						eParserMode = sWaitingMessage;
                        break;
                }
				break;
81110b5c:	0002ca06 	br	81111688 <vParserCommTask+0xdec>
			case sPusHandling:
				eParserMode = sWaitingMessage;
81110b60:	00800044 	movi	r2,1
81110b64:	e0bfdc15 	stw	r2,-144(fp)
				
                switch ( xTcPusL.usiType )
81110b68:	00a04574 	movhi	r2,33045
81110b6c:	10bb4404 	addi	r2,r2,-4848
81110b70:	1080030b 	ldhu	r2,12(r2)
81110b74:	10bfffcc 	andi	r2,r2,65535
81110b78:	10c03ea0 	cmpeqi	r3,r2,250
81110b7c:	1800401e 	bne	r3,zero,81110c80 <vParserCommTask+0x3e4>
81110b80:	10c03ec8 	cmpgei	r3,r2,251
81110b84:	1800031e 	bne	r3,zero,81110b94 <vParserCommTask+0x2f8>
81110b88:	10800460 	cmpeqi	r2,r2,17
81110b8c:	1000061e 	bne	r2,zero,81110ba8 <vParserCommTask+0x30c>
81110b90:	0002b606 	br	8111166c <vParserCommTask+0xdd0>
81110b94:	10c03ee0 	cmpeqi	r3,r2,251
81110b98:	18009d1e 	bne	r3,zero,81110e10 <vParserCommTask+0x574>
81110b9c:	10803f20 	cmpeqi	r2,r2,252
81110ba0:	1001321e 	bne	r2,zero,8111106c <vParserCommTask+0x7d0>
81110ba4:	0002b106 	br	8111166c <vParserCommTask+0xdd0>
                {
                    case 17: /* srv-Type = 17 */
						switch ( xTcPusL.usiSubType )
81110ba8:	00a04574 	movhi	r2,33045
81110bac:	10bb4404 	addi	r2,r2,-4848
81110bb0:	1080038b 	ldhu	r2,14(r2)
81110bb4:	10bfffcc 	andi	r2,r2,65535
81110bb8:	10800060 	cmpeqi	r2,r2,1
81110bbc:	10000e26 	beq	r2,zero,81110bf8 <vParserCommTask+0x35c>
						{
							case 1: /* TC_SCAM_TEST_CONNECTION */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TEST_CONNECTION\n");
81110bc0:	d0a05e17 	ldw	r2,-32392(gp)
81110bc4:	100f883a 	mov	r7,r2
81110bc8:	01800944 	movi	r6,37
81110bcc:	01400044 	movi	r5,1
81110bd0:	01204574 	movhi	r4,33045
81110bd4:	2124c104 	addi	r4,r4,-27900
81110bd8:	111d0b40 	call	8111d0b4 <fwrite>
								#endif

								/* Reply with the TM os connection */
								vTMPusTestConnection( xTcPusL.usiPusId );
81110bdc:	00a04574 	movhi	r2,33045
81110be0:	10bb4404 	addi	r2,r2,-4848
81110be4:	1080040b 	ldhu	r2,16(r2)
81110be8:	10bfffcc 	andi	r2,r2,65535
81110bec:	1009883a 	mov	r4,r2
81110bf0:	1116a900 	call	81116a90 <vTMPusTestConnection>

								break;
81110bf4:	00002106 	br	81110c7c <vParserCommTask+0x3e0>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110bf8:	e0bfdec4 	addi	r2,fp,-133
81110bfc:	01802004 	movi	r6,128
81110c00:	000b883a 	mov	r5,zero
81110c04:	1009883a 	mov	r4,r2
81110c08:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81110c0c:	00a04574 	movhi	r2,33045
81110c10:	10bb4404 	addi	r2,r2,-4848
81110c14:	1080030b 	ldhu	r2,12(r2)
81110c18:	113fffcc 	andi	r4,r2,65535
81110c1c:	00a04574 	movhi	r2,33045
81110c20:	10bb4404 	addi	r2,r2,-4848
81110c24:	1080038b 	ldhu	r2,14(r2)
81110c28:	117fffcc 	andi	r5,r2,65535
81110c2c:	00a04574 	movhi	r2,33045
81110c30:	10bb4404 	addi	r2,r2,-4848
81110c34:	1080040b 	ldhu	r2,16(r2)
81110c38:	10bfffcc 	andi	r2,r2,65535
81110c3c:	e0ffdec4 	addi	r3,fp,-133
81110c40:	d8800015 	stw	r2,0(sp)
81110c44:	280f883a 	mov	r7,r5
81110c48:	200d883a 	mov	r6,r4
81110c4c:	01604574 	movhi	r5,33045
81110c50:	2964cb04 	addi	r5,r5,-27860
81110c54:	1809883a 	mov	r4,r3
81110c58:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81110c5c:	d0a05e17 	ldw	r2,-32392(gp)
81110c60:	e0ffdec4 	addi	r3,fp,-133
81110c64:	180b883a 	mov	r5,r3
81110c68:	1009883a 	mov	r4,r2
81110c6c:	111ca180 	call	8111ca18 <fprintf>
								#endif
								eParserMode = sWaitingMessage;
81110c70:	00800044 	movi	r2,1
81110c74:	e0bfdc15 	stw	r2,-144(fp)
								break;
81110c78:	0001883a 	nop
						}
                        break;
81110c7c:	00027e06 	br	81111678 <vParserCommTask+0xddc>


                    case 250: /* srv-Type = 250 */
						switch ( xTcPusL.usiSubType )
81110c80:	00a04574 	movhi	r2,33045
81110c84:	10bb4404 	addi	r2,r2,-4848
81110c88:	1080038b 	ldhu	r2,14(r2)
81110c8c:	10bfffcc 	andi	r2,r2,65535
81110c90:	10c00f20 	cmpeqi	r3,r2,60
81110c94:	18001a1e 	bne	r3,zero,81110d00 <vParserCommTask+0x464>
81110c98:	10c00f48 	cmpgei	r3,r2,61
81110c9c:	1800031e 	bne	r3,zero,81110cac <vParserCommTask+0x410>
81110ca0:	10800ee0 	cmpeqi	r2,r2,59
81110ca4:	1000061e 	bne	r2,zero,81110cc0 <vParserCommTask+0x424>
81110ca8:	00003706 	br	81110d88 <vParserCommTask+0x4ec>
81110cac:	10c00f60 	cmpeqi	r3,r2,61
81110cb0:	18001e1e 	bne	r3,zero,81110d2c <vParserCommTask+0x490>
81110cb4:	10800fa0 	cmpeqi	r2,r2,62
81110cb8:	1000271e 	bne	r2,zero,81110d58 <vParserCommTask+0x4bc>
81110cbc:	00003206 	br	81110d88 <vParserCommTask+0x4ec>
						{
							case 59: /* TC_SCAM_RESET */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RESET\n");
81110cc0:	d0a05e17 	ldw	r2,-32392(gp)
81110cc4:	100f883a 	mov	r7,r2
81110cc8:	018006c4 	movi	r6,27
81110ccc:	01400044 	movi	r5,1
81110cd0:	01204574 	movhi	r4,33045
81110cd4:	2124de04 	addi	r4,r4,-27784
81110cd8:	111d0b40 	call	8111d0b4 <fwrite>
								#endif
								vSendReset();
81110cdc:	11164380 	call	81116438 <vSendReset>
								/*Just Reset the Simucam, what do with the NUC?*/
								OSTimeDlyHMSM(0,0,3,0);
81110ce0:	000f883a 	mov	r7,zero
81110ce4:	018000c4 	movi	r6,3
81110ce8:	000b883a 	mov	r5,zero
81110cec:	0009883a 	mov	r4,zero
81110cf0:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
								vRstcSimucamReset( 5000 );
81110cf4:	0104e204 	movi	r4,5000
81110cf8:	110b3300 	call	8110b330 <vRstcSimucamReset>

								break;
81110cfc:	00004306 	br	81110e0c <vParserCommTask+0x570>
							case 60: /* TC_SCAM_CONFIG */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_CONFIG\n");
81110d00:	d0a05e17 	ldw	r2,-32392(gp)
81110d04:	100f883a 	mov	r7,r2
81110d08:	01800704 	movi	r6,28
81110d0c:	01400044 	movi	r5,1
81110d10:	01204574 	movhi	r4,33045
81110d14:	2124e504 	addi	r4,r4,-27756
81110d18:	111d0b40 	call	8111d0b4 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81110d1c:	01204574 	movhi	r4,33045
81110d20:	213b4404 	addi	r4,r4,-4848
81110d24:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

								break;
81110d28:	00003806 	br	81110e0c <vParserCommTask+0x570>
							case 61: /* TC_SCAM_RUN */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_RUN\n");
81110d2c:	d0a05e17 	ldw	r2,-32392(gp)
81110d30:	100f883a 	mov	r7,r2
81110d34:	01800644 	movi	r6,25
81110d38:	01400044 	movi	r5,1
81110d3c:	01204574 	movhi	r4,33045
81110d40:	2124ed04 	addi	r4,r4,-27724
81110d44:	111d0b40 	call	8111d0b4 <fwrite>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
81110d48:	01204574 	movhi	r4,33045
81110d4c:	213b4404 	addi	r4,r4,-4848
81110d50:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

								break;
81110d54:	00002d06 	br	81110e0c <vParserCommTask+0x570>
							case 62: /* TC_SCAM_TURNOFF */
								#ifdef DEBUG_ON
									debug(fp,"Parser Task: TC_SCAM_TURNOFF\n");
81110d58:	d0a05e17 	ldw	r2,-32392(gp)
81110d5c:	100f883a 	mov	r7,r2
81110d60:	01800744 	movi	r6,29
81110d64:	01400044 	movi	r5,1
81110d68:	01204574 	movhi	r4,33045
81110d6c:	2124f404 	addi	r4,r4,-27696
81110d70:	111d0b40 	call	8111d0b4 <fwrite>
								#endif
								vSendTurnOff();
81110d74:	11163200 	call	81116320 <vSendTurnOff>

								/* Send to Meb the shutdown command */
								bSendMessagePUStoMebTask(&xTcPusL);
81110d78:	01204574 	movhi	r4,33045
81110d7c:	213b4404 	addi	r4,r4,-4848
81110d80:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

								break;
81110d84:	00002106 	br	81110e0c <vParserCommTask+0x570>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81110d88:	e0bfdec4 	addi	r2,fp,-133
81110d8c:	01802004 	movi	r6,128
81110d90:	000b883a 	mov	r5,zero
81110d94:	1009883a 	mov	r4,r2
81110d98:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81110d9c:	00a04574 	movhi	r2,33045
81110da0:	10bb4404 	addi	r2,r2,-4848
81110da4:	1080030b 	ldhu	r2,12(r2)
81110da8:	113fffcc 	andi	r4,r2,65535
81110dac:	00a04574 	movhi	r2,33045
81110db0:	10bb4404 	addi	r2,r2,-4848
81110db4:	1080038b 	ldhu	r2,14(r2)
81110db8:	117fffcc 	andi	r5,r2,65535
81110dbc:	00a04574 	movhi	r2,33045
81110dc0:	10bb4404 	addi	r2,r2,-4848
81110dc4:	1080040b 	ldhu	r2,16(r2)
81110dc8:	10bfffcc 	andi	r2,r2,65535
81110dcc:	e0ffdec4 	addi	r3,fp,-133
81110dd0:	d8800015 	stw	r2,0(sp)
81110dd4:	280f883a 	mov	r7,r5
81110dd8:	200d883a 	mov	r6,r4
81110ddc:	01604574 	movhi	r5,33045
81110de0:	2964cb04 	addi	r5,r5,-27860
81110de4:	1809883a 	mov	r4,r3
81110de8:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81110dec:	d0a05e17 	ldw	r2,-32392(gp)
81110df0:	e0ffdec4 	addi	r3,fp,-133
81110df4:	180b883a 	mov	r5,r3
81110df8:	1009883a 	mov	r4,r2
81110dfc:	111ca180 	call	8111ca18 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
81110e00:	00800044 	movi	r2,1
81110e04:	e0bfdc15 	stw	r2,-144(fp)
								break;
81110e08:	0001883a 	nop
						}
                        break;
81110e0c:	00021a06 	br	81111678 <vParserCommTask+0xddc>


                    case 251: /* srv-Type = 251 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
81110e10:	00a04574 	movhi	r2,33045
81110e14:	10bb3104 	addi	r2,r2,-4924
81110e18:	1080050b 	ldhu	r2,20(r2)
81110e1c:	e0bfde0d 	sth	r2,-136(fp)

						if ( usiFeeInstL > N_OF_NFEE ) {
81110e20:	e0bfde0b 	ldhu	r2,-136(fp)
81110e24:	108000b0 	cmpltui	r2,r2,2
81110e28:	1000121e 	bne	r2,zero,81110e74 <vParserCommTask+0x5d8>
							#ifdef DEBUG_ON
								memset(cPUSDebug,0,128);
81110e2c:	e0bfdec4 	addi	r2,fp,-133
81110e30:	01802004 	movi	r6,128
81110e34:	000b883a 	mov	r5,zero
81110e38:	1009883a 	mov	r4,r2
81110e3c:	111dc180 	call	8111dc18 <memset>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
81110e40:	e0ffde0b 	ldhu	r3,-136(fp)
81110e44:	e0bfdec4 	addi	r2,fp,-133
81110e48:	180d883a 	mov	r6,r3
81110e4c:	01604574 	movhi	r5,33045
81110e50:	2964fc04 	addi	r5,r5,-27664
81110e54:	1009883a 	mov	r4,r2
81110e58:	111e3a80 	call	8111e3a8 <sprintf>
								debug(fp, cPUSDebug );
81110e5c:	d0a05e17 	ldw	r2,-32392(gp)
81110e60:	e0ffdec4 	addi	r3,fp,-133
81110e64:	180b883a 	mov	r5,r3
81110e68:	1009883a 	mov	r4,r2
81110e6c:	111ca180 	call	8111ca18 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
									break;
							}
						}
                        break;
81110e70:	00020106 	br	81111678 <vParserCommTask+0xddc>
								sprintf(cPUSDebug, "Parser Task: Doesn't exist the Fee Instance number: %hu;\n", usiFeeInstL );
								debug(fp, cPUSDebug );
							#endif
							/* todo: Enviar mensagem de erro se aplicavel */
						} else {
							xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
81110e74:	00a04574 	movhi	r2,33045
81110e78:	10bb4404 	addi	r2,r2,-4848
81110e7c:	10800483 	ldbu	r2,18(r2)
81110e80:	10c03fcc 	andi	r3,r2,255
81110e84:	00a04574 	movhi	r2,33045
81110e88:	10bb4404 	addi	r2,r2,-4848
81110e8c:	18c00284 	addi	r3,r3,10
81110e90:	18c7883a 	add	r3,r3,r3
81110e94:	10c5883a 	add	r2,r2,r3
81110e98:	e0ffde0b 	ldhu	r3,-136(fp)
81110e9c:	10c0000d 	sth	r3,0(r2)
							xTcPusL.ucNofValues++;
81110ea0:	00a04574 	movhi	r2,33045
81110ea4:	10bb4404 	addi	r2,r2,-4848
81110ea8:	10800483 	ldbu	r2,18(r2)
81110eac:	10800044 	addi	r2,r2,1
81110eb0:	1007883a 	mov	r3,r2
81110eb4:	00a04574 	movhi	r2,33045
81110eb8:	10bb4404 	addi	r2,r2,-4848
81110ebc:	10c00485 	stb	r3,18(r2)

							switch ( xTcPusL.usiSubType )
81110ec0:	00a04574 	movhi	r2,33045
81110ec4:	10bb4404 	addi	r2,r2,-4848
81110ec8:	1080038b 	ldhu	r2,14(r2)
81110ecc:	10bfffcc 	andi	r2,r2,65535
81110ed0:	10c000a0 	cmpeqi	r3,r2,2
81110ed4:	1800191e 	bne	r3,zero,81110f3c <vParserCommTask+0x6a0>
81110ed8:	10c00160 	cmpeqi	r3,r2,5
81110edc:	18002c1e 	bne	r3,zero,81110f90 <vParserCommTask+0x6f4>
81110ee0:	10800060 	cmpeqi	r2,r2,1
81110ee4:	10003f26 	beq	r2,zero,81110fe4 <vParserCommTask+0x748>
							{
								case 1: /* TC_SCAM_FEE_CONFIG_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110ee8:	e0bfdec4 	addi	r2,fp,-133
81110eec:	01802004 	movi	r6,128
81110ef0:	000b883a 	mov	r5,zero
81110ef4:	1009883a 	mov	r4,r2
81110ef8:	111dc180 	call	8111dc18 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CONFIG_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81110efc:	e0ffde0b 	ldhu	r3,-136(fp)
81110f00:	e0bfdec4 	addi	r2,fp,-133
81110f04:	180d883a 	mov	r6,r3
81110f08:	01604574 	movhi	r5,33045
81110f0c:	29650b04 	addi	r5,r5,-27604
81110f10:	1009883a 	mov	r4,r2
81110f14:	111e3a80 	call	8111e3a8 <sprintf>
										debug(fp, cPUSDebug );
81110f18:	d0a05e17 	ldw	r2,-32392(gp)
81110f1c:	e0ffdec4 	addi	r3,fp,-133
81110f20:	180b883a 	mov	r5,r3
81110f24:	1009883a 	mov	r4,r2
81110f28:	111ca180 	call	8111ca18 <fprintf>
									#endif							
									bSendMessagePUStoMebTask(&xTcPusL);
81110f2c:	01204574 	movhi	r4,33045
81110f30:	213b4404 	addi	r4,r4,-4848
81110f34:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

									break;
81110f38:	00004b06 	br	81111068 <vParserCommTask+0x7cc>
								case 2: /* TC_SCAM_FEE_STANDBY_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110f3c:	e0bfdec4 	addi	r2,fp,-133
81110f40:	01802004 	movi	r6,128
81110f44:	000b883a 	mov	r5,zero
81110f48:	1009883a 	mov	r4,r2
81110f4c:	111dc180 	call	8111dc18 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_STANDBY_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81110f50:	e0ffde0b 	ldhu	r3,-136(fp)
81110f54:	e0bfdec4 	addi	r2,fp,-133
81110f58:	180d883a 	mov	r6,r3
81110f5c:	01604574 	movhi	r5,33045
81110f60:	29651b04 	addi	r5,r5,-27540
81110f64:	1009883a 	mov	r4,r2
81110f68:	111e3a80 	call	8111e3a8 <sprintf>
										debug(fp, cPUSDebug );
81110f6c:	d0a05e17 	ldw	r2,-32392(gp)
81110f70:	e0ffdec4 	addi	r3,fp,-133
81110f74:	180b883a 	mov	r5,r3
81110f78:	1009883a 	mov	r4,r2
81110f7c:	111ca180 	call	8111ca18 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81110f80:	01204574 	movhi	r4,33045
81110f84:	213b4404 	addi	r4,r4,-4848
81110f88:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

									break;
81110f8c:	00003606 	br	81111068 <vParserCommTask+0x7cc>
								case 5: /* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110f90:	e0bfdec4 	addi	r2,fp,-133
81110f94:	01802004 	movi	r6,128
81110f98:	000b883a 	mov	r5,zero
81110f9c:	1009883a 	mov	r4,r2
81110fa0:	111dc180 	call	8111dc18 <memset>
										sprintf(cPUSDebug, "Parser Task: TC_SCAM_FEE_CALIBRATION_TEST_ENTER (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81110fa4:	e0ffde0b 	ldhu	r3,-136(fp)
81110fa8:	e0bfdec4 	addi	r2,fp,-133
81110fac:	180d883a 	mov	r6,r3
81110fb0:	01604574 	movhi	r5,33045
81110fb4:	29652b04 	addi	r5,r5,-27476
81110fb8:	1009883a 	mov	r4,r2
81110fbc:	111e3a80 	call	8111e3a8 <sprintf>
										debug(fp, cPUSDebug );
81110fc0:	d0a05e17 	ldw	r2,-32392(gp)
81110fc4:	e0ffdec4 	addi	r3,fp,-133
81110fc8:	180b883a 	mov	r5,r3
81110fcc:	1009883a 	mov	r4,r2
81110fd0:	111ca180 	call	8111ca18 <fprintf>
									#endif
									bSendMessagePUStoMebTask(&xTcPusL);
81110fd4:	01204574 	movhi	r4,33045
81110fd8:	213b4404 	addi	r4,r4,-4848
81110fdc:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

									break;
81110fe0:	00002106 	br	81111068 <vParserCommTask+0x7cc>
								default:
									#ifdef DEBUG_ON
										memset(cPUSDebug,0,128);
81110fe4:	e0bfdec4 	addi	r2,fp,-133
81110fe8:	01802004 	movi	r6,128
81110fec:	000b883a 	mov	r5,zero
81110ff0:	1009883a 	mov	r4,r2
81110ff4:	111dc180 	call	8111dc18 <memset>
										sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
81110ff8:	00a04574 	movhi	r2,33045
81110ffc:	10bb4404 	addi	r2,r2,-4848
81111000:	1080030b 	ldhu	r2,12(r2)
81111004:	113fffcc 	andi	r4,r2,65535
81111008:	00a04574 	movhi	r2,33045
8111100c:	10bb4404 	addi	r2,r2,-4848
81111010:	1080038b 	ldhu	r2,14(r2)
81111014:	117fffcc 	andi	r5,r2,65535
81111018:	00a04574 	movhi	r2,33045
8111101c:	10bb4404 	addi	r2,r2,-4848
81111020:	1080040b 	ldhu	r2,16(r2)
81111024:	10bfffcc 	andi	r2,r2,65535
81111028:	e0ffdec4 	addi	r3,fp,-133
8111102c:	d8800015 	stw	r2,0(sp)
81111030:	280f883a 	mov	r7,r5
81111034:	200d883a 	mov	r6,r4
81111038:	01604574 	movhi	r5,33045
8111103c:	2964cb04 	addi	r5,r5,-27860
81111040:	1809883a 	mov	r4,r3
81111044:	111e3a80 	call	8111e3a8 <sprintf>
										debug(fp, cPUSDebug );
81111048:	d0a05e17 	ldw	r2,-32392(gp)
8111104c:	e0ffdec4 	addi	r3,fp,-133
81111050:	180b883a 	mov	r5,r3
81111054:	1009883a 	mov	r4,r2
81111058:	111ca180 	call	8111ca18 <fprintf>
									#endif							
									eParserMode = sWaitingMessage;
8111105c:	00800044 	movi	r2,1
81111060:	e0bfdc15 	stw	r2,-144(fp)
									break;
81111064:	0001883a 	nop
							}
						}
                        break;
81111068:	00018306 	br	81111678 <vParserCommTask+0xddc>


					case 252: /* srv-Type = 252 */
						usiFeeInstL = PreParsedLocal.usiValues[6];
8111106c:	00a04574 	movhi	r2,33045
81111070:	10bb3104 	addi	r2,r2,-4924
81111074:	1080050b 	ldhu	r2,20(r2)
81111078:	e0bfde0d 	sth	r2,-136(fp)
						xTcPusL.usiValues[xTcPusL.ucNofValues] = usiFeeInstL;
8111107c:	00a04574 	movhi	r2,33045
81111080:	10bb4404 	addi	r2,r2,-4848
81111084:	10800483 	ldbu	r2,18(r2)
81111088:	10c03fcc 	andi	r3,r2,255
8111108c:	00a04574 	movhi	r2,33045
81111090:	10bb4404 	addi	r2,r2,-4848
81111094:	18c00284 	addi	r3,r3,10
81111098:	18c7883a 	add	r3,r3,r3
8111109c:	10c5883a 	add	r2,r2,r3
811110a0:	e0ffde0b 	ldhu	r3,-136(fp)
811110a4:	10c0000d 	sth	r3,0(r2)
						xTcPusL.ucNofValues++;
811110a8:	00a04574 	movhi	r2,33045
811110ac:	10bb4404 	addi	r2,r2,-4848
811110b0:	10800483 	ldbu	r2,18(r2)
811110b4:	10800044 	addi	r2,r2,1
811110b8:	1007883a 	mov	r3,r2
811110bc:	00a04574 	movhi	r2,33045
811110c0:	10bb4404 	addi	r2,r2,-4848
811110c4:	10c00485 	stb	r3,18(r2)

						switch ( xTcPusL.usiSubType )
811110c8:	00a04574 	movhi	r2,33045
811110cc:	10bb4404 	addi	r2,r2,-4848
811110d0:	1080038b 	ldhu	r2,14(r2)
811110d4:	10bfffcc 	andi	r2,r2,65535
811110d8:	10c000e0 	cmpeqi	r3,r2,3
811110dc:	18000a1e 	bne	r3,zero,81111108 <vParserCommTask+0x86c>
811110e0:	10c00108 	cmpgei	r3,r2,4
811110e4:	1800031e 	bne	r3,zero,811110f4 <vParserCommTask+0x858>
811110e8:	108000a0 	cmpeqi	r2,r2,2
811110ec:	1000451e 	bne	r2,zero,81111204 <vParserCommTask+0x968>
811110f0:	00013c06 	br	811115e4 <vParserCommTask+0xd48>
811110f4:	10c00120 	cmpeqi	r3,r2,4
811110f8:	1800181e 	bne	r3,zero,8111115c <vParserCommTask+0x8c0>
811110fc:	10800160 	cmpeqi	r2,r2,5
81111100:	10002b1e 	bne	r2,zero,811111b0 <vParserCommTask+0x914>
81111104:	00013706 	br	811115e4 <vParserCommTask+0xd48>
						{					
							case 3: /* TC_SCAM_SPW_LINK_ENABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
81111108:	e0bfdec4 	addi	r2,fp,-133
8111110c:	01802004 	movi	r6,128
81111110:	000b883a 	mov	r5,zero
81111114:	1009883a 	mov	r4,r2
81111118:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_ENABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
8111111c:	e0ffde0b 	ldhu	r3,-136(fp)
81111120:	e0bfdec4 	addi	r2,fp,-133
81111124:	180d883a 	mov	r6,r3
81111128:	01604574 	movhi	r5,33045
8111112c:	29653d04 	addi	r5,r5,-27404
81111130:	1009883a 	mov	r4,r2
81111134:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81111138:	d0a05e17 	ldw	r2,-32392(gp)
8111113c:	e0ffdec4 	addi	r3,fp,-133
81111140:	180b883a 	mov	r5,r3
81111144:	1009883a 	mov	r4,r2
81111148:	111ca180 	call	8111ca18 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
8111114c:	01204574 	movhi	r4,33045
81111150:	213b4404 	addi	r4,r4,-4848
81111154:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

								break;
81111158:	00014306 	br	81111668 <vParserCommTask+0xdcc>
							case 4: /* TC_SCAM_SPW_LINK_DISABLE */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
8111115c:	e0bfdec4 	addi	r2,fp,-133
81111160:	01802004 	movi	r6,128
81111164:	000b883a 	mov	r5,zero
81111168:	1009883a 	mov	r4,r2
8111116c:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_DISABLE (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
81111170:	e0ffde0b 	ldhu	r3,-136(fp)
81111174:	e0bfdec4 	addi	r2,fp,-133
81111178:	180d883a 	mov	r6,r3
8111117c:	01604574 	movhi	r5,33045
81111180:	29654d04 	addi	r5,r5,-27340
81111184:	1009883a 	mov	r4,r2
81111188:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
8111118c:	d0a05e17 	ldw	r2,-32392(gp)
81111190:	e0ffdec4 	addi	r3,fp,-133
81111194:	180b883a 	mov	r5,r3
81111198:	1009883a 	mov	r4,r2
8111119c:	111ca180 	call	8111ca18 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811111a0:	01204574 	movhi	r4,33045
811111a4:	213b4404 	addi	r4,r4,-4848
811111a8:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

								break;
811111ac:	00012e06 	br	81111668 <vParserCommTask+0xdcc>
							case 5: /* TC_SCAM_SPW_LINK_RESET */
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811111b0:	e0bfdec4 	addi	r2,fp,-133
811111b4:	01802004 	movi	r6,128
811111b8:	000b883a 	mov	r5,zero
811111bc:	1009883a 	mov	r4,r2
811111c0:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_LINK_RESET (FEESIM_INSTANCE: %hu)\n", usiFeeInstL );
811111c4:	e0ffde0b 	ldhu	r3,-136(fp)
811111c8:	e0bfdec4 	addi	r2,fp,-133
811111cc:	180d883a 	mov	r6,r3
811111d0:	01604574 	movhi	r5,33045
811111d4:	29655d04 	addi	r5,r5,-27276
811111d8:	1009883a 	mov	r4,r2
811111dc:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
811111e0:	d0a05e17 	ldw	r2,-32392(gp)
811111e4:	e0ffdec4 	addi	r3,fp,-133
811111e8:	180b883a 	mov	r5,r3
811111ec:	1009883a 	mov	r4,r2
811111f0:	111ca180 	call	8111ca18 <fprintf>
								#endif
								bSendMessagePUStoMebTask(&xTcPusL);
811111f4:	01204574 	movhi	r4,33045
811111f8:	213b4404 	addi	r4,r4,-4848
811111fc:	11117a40 	call	811117a4 <bSendMessagePUStoMebTask>

								break;
81111200:	00011906 	br	81111668 <vParserCommTask+0xdcc>
							case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[7];
81111204:	00a04574 	movhi	r2,33045
81111208:	10bb4404 	addi	r2,r2,-4848
8111120c:	10800483 	ldbu	r2,18(r2)
81111210:	10c03fcc 	andi	r3,r2,255
81111214:	00a04574 	movhi	r2,33045
81111218:	10bb3104 	addi	r2,r2,-4924
8111121c:	1100058b 	ldhu	r4,22(r2)
81111220:	00a04574 	movhi	r2,33045
81111224:	10bb4404 	addi	r2,r2,-4848
81111228:	18c00284 	addi	r3,r3,10
8111122c:	18c7883a 	add	r3,r3,r3
81111230:	10c5883a 	add	r2,r2,r3
81111234:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111238:	00a04574 	movhi	r2,33045
8111123c:	10bb4404 	addi	r2,r2,-4848
81111240:	10800483 	ldbu	r2,18(r2)
81111244:	10800044 	addi	r2,r2,1
81111248:	1007883a 	mov	r3,r2
8111124c:	00a04574 	movhi	r2,33045
81111250:	10bb4404 	addi	r2,r2,-4848
81111254:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[8];
81111258:	00a04574 	movhi	r2,33045
8111125c:	10bb4404 	addi	r2,r2,-4848
81111260:	10800483 	ldbu	r2,18(r2)
81111264:	10c03fcc 	andi	r3,r2,255
81111268:	00a04574 	movhi	r2,33045
8111126c:	10bb3104 	addi	r2,r2,-4924
81111270:	1100060b 	ldhu	r4,24(r2)
81111274:	00a04574 	movhi	r2,33045
81111278:	10bb4404 	addi	r2,r2,-4848
8111127c:	18c00284 	addi	r3,r3,10
81111280:	18c7883a 	add	r3,r3,r3
81111284:	10c5883a 	add	r2,r2,r3
81111288:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
8111128c:	00a04574 	movhi	r2,33045
81111290:	10bb4404 	addi	r2,r2,-4848
81111294:	10800483 	ldbu	r2,18(r2)
81111298:	10800044 	addi	r2,r2,1
8111129c:	1007883a 	mov	r3,r2
811112a0:	00a04574 	movhi	r2,33045
811112a4:	10bb4404 	addi	r2,r2,-4848
811112a8:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[9];
811112ac:	00a04574 	movhi	r2,33045
811112b0:	10bb4404 	addi	r2,r2,-4848
811112b4:	10800483 	ldbu	r2,18(r2)
811112b8:	10c03fcc 	andi	r3,r2,255
811112bc:	00a04574 	movhi	r2,33045
811112c0:	10bb3104 	addi	r2,r2,-4924
811112c4:	1100068b 	ldhu	r4,26(r2)
811112c8:	00a04574 	movhi	r2,33045
811112cc:	10bb4404 	addi	r2,r2,-4848
811112d0:	18c00284 	addi	r3,r3,10
811112d4:	18c7883a 	add	r3,r3,r3
811112d8:	10c5883a 	add	r2,r2,r3
811112dc:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811112e0:	00a04574 	movhi	r2,33045
811112e4:	10bb4404 	addi	r2,r2,-4848
811112e8:	10800483 	ldbu	r2,18(r2)
811112ec:	10800044 	addi	r2,r2,1
811112f0:	1007883a 	mov	r3,r2
811112f4:	00a04574 	movhi	r2,33045
811112f8:	10bb4404 	addi	r2,r2,-4848
811112fc:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[10];
81111300:	00a04574 	movhi	r2,33045
81111304:	10bb4404 	addi	r2,r2,-4848
81111308:	10800483 	ldbu	r2,18(r2)
8111130c:	10c03fcc 	andi	r3,r2,255
81111310:	00a04574 	movhi	r2,33045
81111314:	10bb3104 	addi	r2,r2,-4924
81111318:	1100070b 	ldhu	r4,28(r2)
8111131c:	00a04574 	movhi	r2,33045
81111320:	10bb4404 	addi	r2,r2,-4848
81111324:	18c00284 	addi	r3,r3,10
81111328:	18c7883a 	add	r3,r3,r3
8111132c:	10c5883a 	add	r2,r2,r3
81111330:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111334:	00a04574 	movhi	r2,33045
81111338:	10bb4404 	addi	r2,r2,-4848
8111133c:	10800483 	ldbu	r2,18(r2)
81111340:	10800044 	addi	r2,r2,1
81111344:	1007883a 	mov	r3,r2
81111348:	00a04574 	movhi	r2,33045
8111134c:	10bb4404 	addi	r2,r2,-4848
81111350:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[11];
81111354:	00a04574 	movhi	r2,33045
81111358:	10bb4404 	addi	r2,r2,-4848
8111135c:	10800483 	ldbu	r2,18(r2)
81111360:	10c03fcc 	andi	r3,r2,255
81111364:	00a04574 	movhi	r2,33045
81111368:	10bb3104 	addi	r2,r2,-4924
8111136c:	1100078b 	ldhu	r4,30(r2)
81111370:	00a04574 	movhi	r2,33045
81111374:	10bb4404 	addi	r2,r2,-4848
81111378:	18c00284 	addi	r3,r3,10
8111137c:	18c7883a 	add	r3,r3,r3
81111380:	10c5883a 	add	r2,r2,r3
81111384:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
81111388:	00a04574 	movhi	r2,33045
8111138c:	10bb4404 	addi	r2,r2,-4848
81111390:	10800483 	ldbu	r2,18(r2)
81111394:	10800044 	addi	r2,r2,1
81111398:	1007883a 	mov	r3,r2
8111139c:	00a04574 	movhi	r2,33045
811113a0:	10bb4404 	addi	r2,r2,-4848
811113a4:	10c00485 	stb	r3,18(r2)
								xTcPusL.usiValues[xTcPusL.ucNofValues] = PreParsedLocal.usiValues[12];
811113a8:	00a04574 	movhi	r2,33045
811113ac:	10bb4404 	addi	r2,r2,-4848
811113b0:	10800483 	ldbu	r2,18(r2)
811113b4:	10c03fcc 	andi	r3,r2,255
811113b8:	00a04574 	movhi	r2,33045
811113bc:	10bb3104 	addi	r2,r2,-4924
811113c0:	1100080b 	ldhu	r4,32(r2)
811113c4:	00a04574 	movhi	r2,33045
811113c8:	10bb4404 	addi	r2,r2,-4848
811113cc:	18c00284 	addi	r3,r3,10
811113d0:	18c7883a 	add	r3,r3,r3
811113d4:	10c5883a 	add	r2,r2,r3
811113d8:	1100000d 	sth	r4,0(r2)
								xTcPusL.ucNofValues++;
811113dc:	00a04574 	movhi	r2,33045
811113e0:	10bb4404 	addi	r2,r2,-4848
811113e4:	10800483 	ldbu	r2,18(r2)
811113e8:	10800044 	addi	r2,r2,1
811113ec:	1007883a 	mov	r3,r2
811113f0:	00a04574 	movhi	r2,33045
811113f4:	10bb4404 	addi	r2,r2,-4848
811113f8:	10c00485 	stb	r3,18(r2)


								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811113fc:	e0bfdec4 	addi	r2,fp,-133
81111400:	01802004 	movi	r6,128
81111404:	000b883a 	mov	r5,zero
81111408:	1009883a 	mov	r4,r2
8111140c:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: TC_SCAM_SPW_RMAP_CONFIG_UPDATE:\n");
81111410:	e0ffdec4 	addi	r3,fp,-133
81111414:	00a04574 	movhi	r2,33045
81111418:	10a56c04 	addi	r2,r2,-27216
8111141c:	1009883a 	mov	r4,r2
81111420:	00800b84 	movi	r2,46
81111424:	100d883a 	mov	r6,r2
81111428:	200b883a 	mov	r5,r4
8111142c:	1809883a 	mov	r4,r3
81111430:	111dac80 	call	8111dac8 <memcpy>
									debug(fp, cPUSDebug );
81111434:	d0a05e17 	ldw	r2,-32392(gp)
81111438:	e0ffdec4 	addi	r3,fp,-133
8111143c:	180b883a 	mov	r5,r3
81111440:	1009883a 	mov	r4,r2
81111444:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- FEESIM_INSTANCE: %hu;\n", usiFeeInstL );
81111448:	e0ffde0b 	ldhu	r3,-136(fp)
8111144c:	e0bfdec4 	addi	r2,fp,-133
81111450:	180d883a 	mov	r6,r3
81111454:	01604574 	movhi	r5,33045
81111458:	29657804 	addi	r5,r5,-27168
8111145c:	1009883a 	mov	r4,r2
81111460:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81111464:	d0a05e17 	ldw	r2,-32392(gp)
81111468:	e0ffdec4 	addi	r3,fp,-133
8111146c:	180b883a 	mov	r5,r3
81111470:	1009883a 	mov	r4,r2
81111474:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- MODE: %hu;\n", PreParsedLocal.usiValues[7] );
81111478:	00a04574 	movhi	r2,33045
8111147c:	10bb3104 	addi	r2,r2,-4924
81111480:	1080058b 	ldhu	r2,22(r2)
81111484:	10ffffcc 	andi	r3,r2,65535
81111488:	e0bfdec4 	addi	r2,fp,-133
8111148c:	180d883a 	mov	r6,r3
81111490:	01604574 	movhi	r5,33045
81111494:	29657f04 	addi	r5,r5,-27140
81111498:	1009883a 	mov	r4,r2
8111149c:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
811114a0:	d0a05e17 	ldw	r2,-32392(gp)
811114a4:	e0ffdec4 	addi	r3,fp,-133
811114a8:	180b883a 	mov	r5,r3
811114ac:	1009883a 	mov	r4,r2
811114b0:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- LINK_SPEED: %hu;\n", PreParsedLocal.usiValues[8] );
811114b4:	00a04574 	movhi	r2,33045
811114b8:	10bb3104 	addi	r2,r2,-4924
811114bc:	1080060b 	ldhu	r2,24(r2)
811114c0:	10ffffcc 	andi	r3,r2,65535
811114c4:	e0bfdec4 	addi	r2,fp,-133
811114c8:	180d883a 	mov	r6,r3
811114cc:	01604574 	movhi	r5,33045
811114d0:	29658304 	addi	r5,r5,-27124
811114d4:	1009883a 	mov	r4,r2
811114d8:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
811114dc:	d0a05e17 	ldw	r2,-32392(gp)
811114e0:	e0ffdec4 	addi	r3,fp,-133
811114e4:	180b883a 	mov	r5,r3
811114e8:	1009883a 	mov	r4,r2
811114ec:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- LOGICAL_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[9] );
811114f0:	00a04574 	movhi	r2,33045
811114f4:	10bb3104 	addi	r2,r2,-4924
811114f8:	1080068b 	ldhu	r2,26(r2)
811114fc:	10ffffcc 	andi	r3,r2,65535
81111500:	e0bfdec4 	addi	r2,fp,-133
81111504:	180d883a 	mov	r6,r3
81111508:	01604574 	movhi	r5,33045
8111150c:	29658804 	addi	r5,r5,-27104
81111510:	1009883a 	mov	r4,r2
81111514:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81111518:	d0a05e17 	ldw	r2,-32392(gp)
8111151c:	e0ffdec4 	addi	r3,fp,-133
81111520:	180b883a 	mov	r5,r3
81111524:	1009883a 	mov	r4,r2
81111528:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- DEST_NODE_ADDR: 0x%02X;\n", PreParsedLocal.usiValues[10] );
8111152c:	00a04574 	movhi	r2,33045
81111530:	10bb3104 	addi	r2,r2,-4924
81111534:	1080070b 	ldhu	r2,28(r2)
81111538:	10ffffcc 	andi	r3,r2,65535
8111153c:	e0bfdec4 	addi	r2,fp,-133
81111540:	180d883a 	mov	r6,r3
81111544:	01604574 	movhi	r5,33045
81111548:	29658f04 	addi	r5,r5,-27076
8111154c:	1009883a 	mov	r4,r2
81111550:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81111554:	d0a05e17 	ldw	r2,-32392(gp)
81111558:	e0ffdec4 	addi	r3,fp,-133
8111155c:	180b883a 	mov	r5,r3
81111560:	1009883a 	mov	r4,r2
81111564:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- TIME_CODE_GEN: %hu;\n", PreParsedLocal.usiValues[11] );
81111568:	00a04574 	movhi	r2,33045
8111156c:	10bb3104 	addi	r2,r2,-4924
81111570:	1080078b 	ldhu	r2,30(r2)
81111574:	10ffffcc 	andi	r3,r2,65535
81111578:	e0bfdec4 	addi	r2,fp,-133
8111157c:	180d883a 	mov	r6,r3
81111580:	01604574 	movhi	r5,33045
81111584:	29659604 	addi	r5,r5,-27048
81111588:	1009883a 	mov	r4,r2
8111158c:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81111590:	d0a05e17 	ldw	r2,-32392(gp)
81111594:	e0ffdec4 	addi	r3,fp,-133
81111598:	180b883a 	mov	r5,r3
8111159c:	1009883a 	mov	r4,r2
811115a0:	111ca180 	call	8111ca18 <fprintf>
									sprintf(cPUSDebug, "- RMAP_KEY: 0x%02X;\n", PreParsedLocal.usiValues[12] );
811115a4:	00a04574 	movhi	r2,33045
811115a8:	10bb3104 	addi	r2,r2,-4924
811115ac:	1080080b 	ldhu	r2,32(r2)
811115b0:	10ffffcc 	andi	r3,r2,65535
811115b4:	e0bfdec4 	addi	r2,fp,-133
811115b8:	180d883a 	mov	r6,r3
811115bc:	01604574 	movhi	r5,33045
811115c0:	29659c04 	addi	r5,r5,-27024
811115c4:	1009883a 	mov	r4,r2
811115c8:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
811115cc:	d0a05e17 	ldw	r2,-32392(gp)
811115d0:	e0ffdec4 	addi	r3,fp,-133
811115d4:	180b883a 	mov	r5,r3
811115d8:	1009883a 	mov	r4,r2
811115dc:	111ca180 	call	8111ca18 <fprintf>
								#endif

								break;
811115e0:	00002106 	br	81111668 <vParserCommTask+0xdcc>
							default:
								#ifdef DEBUG_ON
									memset(cPUSDebug,0,128);
811115e4:	e0bfdec4 	addi	r2,fp,-133
811115e8:	01802004 	movi	r6,128
811115ec:	000b883a 	mov	r5,zero
811115f0:	1009883a 	mov	r4,r2
811115f4:	111dc180 	call	8111dc18 <memset>
									sprintf(cPUSDebug, "Parser Task: Default - TC-> srv-type: %hu; srv-subtype: %hu; pus-id: %hu;\n", xTcPusL.usiType, xTcPusL.usiSubType, xTcPusL.usiPusId );
811115f8:	00a04574 	movhi	r2,33045
811115fc:	10bb4404 	addi	r2,r2,-4848
81111600:	1080030b 	ldhu	r2,12(r2)
81111604:	113fffcc 	andi	r4,r2,65535
81111608:	00a04574 	movhi	r2,33045
8111160c:	10bb4404 	addi	r2,r2,-4848
81111610:	1080038b 	ldhu	r2,14(r2)
81111614:	117fffcc 	andi	r5,r2,65535
81111618:	00a04574 	movhi	r2,33045
8111161c:	10bb4404 	addi	r2,r2,-4848
81111620:	1080040b 	ldhu	r2,16(r2)
81111624:	10bfffcc 	andi	r2,r2,65535
81111628:	e0ffdec4 	addi	r3,fp,-133
8111162c:	d8800015 	stw	r2,0(sp)
81111630:	280f883a 	mov	r7,r5
81111634:	200d883a 	mov	r6,r4
81111638:	01604574 	movhi	r5,33045
8111163c:	2964cb04 	addi	r5,r5,-27860
81111640:	1809883a 	mov	r4,r3
81111644:	111e3a80 	call	8111e3a8 <sprintf>
									debug(fp, cPUSDebug );
81111648:	d0a05e17 	ldw	r2,-32392(gp)
8111164c:	e0ffdec4 	addi	r3,fp,-133
81111650:	180b883a 	mov	r5,r3
81111654:	1009883a 	mov	r4,r2
81111658:	111ca180 	call	8111ca18 <fprintf>
								#endif							
								eParserMode = sWaitingMessage;
8111165c:	00800044 	movi	r2,1
81111660:	e0bfdc15 	stw	r2,-144(fp)
								break;
81111664:	0001883a 	nop
						}
                        break;
81111668:	00000306 	br	81111678 <vParserCommTask+0xddc>
                    default:
						eParserMode = sWaitingMessage;
8111166c:	00800044 	movi	r2,1
81111670:	e0bfdc15 	stw	r2,-144(fp)
                        break;
81111674:	0001883a 	nop
                }
				break;				
81111678:	00000306 	br	81111688 <vParserCommTask+0xdec>
			default:
				eParserMode = sWaitingMessage;
8111167c:	00800044 	movi	r2,1
81111680:	e0bfdc15 	stw	r2,-144(fp)
				break;
81111684:	0001883a 	nop
		}
	}
81111688:	003c9406 	br	811108dc <__reset+0xfb0f08dc>

8111168c <getPreParsedPacket>:
}

bool getPreParsedPacket( tPreParsed *xPreParsedParser ) {
8111168c:	defffb04 	addi	sp,sp,-20
81111690:	de00012e 	bgeu	sp,et,81111698 <getPreParsedPacket+0xc>
81111694:	003b68fa 	trap	3
81111698:	dfc00415 	stw	ra,16(sp)
8111169c:	df000315 	stw	fp,12(sp)
811116a0:	df000304 	addi	fp,sp,12
811116a4:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811116a8:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i;

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
811116ac:	d0a06717 	ldw	r2,-32356(gp)
811116b0:	e0fffe44 	addi	r3,fp,-7
811116b4:	180d883a 	mov	r6,r3
811116b8:	000b883a 	mov	r5,zero
811116bc:	1009883a 	mov	r4,r2
811116c0:	1138ae80 	call	81138ae8 <OSMutexPend>
	if (error_code == OS_ERR_NONE) {
811116c4:	e0bffe43 	ldbu	r2,-7(fp)
811116c8:	10803fcc 	andi	r2,r2,255
811116cc:	10002e1e 	bne	r2,zero,81111788 <getPreParsedPacket+0xfc>
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
811116d0:	e03ffe05 	stb	zero,-8(fp)
811116d4:	00002506 	br	8111176c <getPreParsedPacket+0xe0>
		{

            if ( xPreParsed[i].cType != 0 ) {
811116d8:	e0fffe03 	ldbu	r3,-8(fp)
811116dc:	00a045b4 	movhi	r2,33046
811116e0:	10885804 	addi	r2,r2,8544
811116e4:	18c01324 	muli	r3,r3,76
811116e8:	10c5883a 	add	r2,r2,r3
811116ec:	10800104 	addi	r2,r2,4
811116f0:	10800003 	ldbu	r2,0(r2)
811116f4:	10803fcc 	andi	r2,r2,255
811116f8:	1080201c 	xori	r2,r2,128
811116fc:	10bfe004 	addi	r2,r2,-128
81111700:	10001726 	beq	r2,zero,81111760 <getPreParsedPacket+0xd4>
                /* Locate a filled PreParsed variable in the array*/
            	/* Perform a copy to a local variable */
            	(*xPreParsedParser) = xPreParsed[i];
81111704:	e0fffe03 	ldbu	r3,-8(fp)
81111708:	e13fff17 	ldw	r4,-4(fp)
8111170c:	00a045b4 	movhi	r2,33046
81111710:	10885804 	addi	r2,r2,8544
81111714:	18c01324 	muli	r3,r3,76
81111718:	10c5883a 	add	r2,r2,r3
8111171c:	2007883a 	mov	r3,r4
81111720:	1009883a 	mov	r4,r2
81111724:	00801304 	movi	r2,76
81111728:	100d883a 	mov	r6,r2
8111172c:	200b883a 	mov	r5,r4
81111730:	1809883a 	mov	r4,r3
81111734:	111dac80 	call	8111dac8 <memcpy>
                bSuccess = TRUE;
81111738:	00800044 	movi	r2,1
8111173c:	e0bffd15 	stw	r2,-12(fp)
                xPreParsed[i].cType = 0;
81111740:	e0fffe03 	ldbu	r3,-8(fp)
81111744:	00a045b4 	movhi	r2,33046
81111748:	10885804 	addi	r2,r2,8544
8111174c:	18c01324 	muli	r3,r3,76
81111750:	10c5883a 	add	r2,r2,r3
81111754:	10800104 	addi	r2,r2,4
81111758:	10000005 	stb	zero,0(r2)
                break;
8111175c:	00000606 	br	81111778 <getPreParsedPacket+0xec>

	OSMutexPend(xMutexPreParsed, 0, &error_code); /*Blocking*/
	if (error_code == OS_ERR_NONE) {
		/* Got the Mutex */
		/*For now, will only get the first, not the packet that is waiting for longer time*/
		for( i = 0; i < N_PREPARSED_ENTRIES; i++)
81111760:	e0bffe03 	ldbu	r2,-8(fp)
81111764:	10800044 	addi	r2,r2,1
81111768:	e0bffe05 	stb	r2,-8(fp)
8111176c:	e0bffe03 	ldbu	r2,-8(fp)
81111770:	10800230 	cmpltui	r2,r2,8
81111774:	103fd81e 	bne	r2,zero,811116d8 <__reset+0xfb0f16d8>
                bSuccess = TRUE;
                xPreParsed[i].cType = 0;
                break;
            }
		}
		OSMutexPost(xMutexPreParsed);
81111778:	d0a06717 	ldw	r2,-32356(gp)
8111177c:	1009883a 	mov	r4,r2
81111780:	113908c0 	call	8113908c <OSMutexPost>
81111784:	00000106 	br	8111178c <getPreParsedPacket+0x100>
	} else {
		/* Couldn't get Mutex. (Should not get here since is a blocking call without timeout)*/
		vFailGetxMutexPreParsedParserRxTask();
81111788:	11183c00 	call	811183c0 <vFailGetxMutexPreParsedParserRxTask>
	}
	return bSuccess;
8111178c:	e0bffd17 	ldw	r2,-12(fp)
}
81111790:	e037883a 	mov	sp,fp
81111794:	dfc00117 	ldw	ra,4(sp)
81111798:	df000017 	ldw	fp,0(sp)
8111179c:	dec00204 	addi	sp,sp,8
811117a0:	f800283a 	ret

811117a4 <bSendMessagePUStoMebTask>:

/* Search for some free location in the xPus array to put the full command to send to the meb task */
bool bSendMessagePUStoMebTask( tTMPus *xPusL ) {
811117a4:	defffa04 	addi	sp,sp,-24
811117a8:	de00012e 	bgeu	sp,et,811117b0 <bSendMessagePUStoMebTask+0xc>
811117ac:	003b68fa 	trap	3
811117b0:	dfc00515 	stw	ra,20(sp)
811117b4:	df000415 	stw	fp,16(sp)
811117b8:	df000404 	addi	fp,sp,16
811117bc:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
811117c0:	e03ffc15 	stw	zero,-16(fp)
    INT8U error_code;
    tQMask xCdmLocal;
    unsigned char i = 0;
811117c4:	e03ffd05 	stb	zero,-12(fp)

    bSuccess = FALSE;
811117c8:	e03ffc15 	stw	zero,-16(fp)
    xCdmLocal.ulWord = 0;
811117cc:	e03ffe15 	stw	zero,-8(fp)
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
811117d0:	d0a06f17 	ldw	r2,-32324(gp)
811117d4:	e0fffd44 	addi	r3,fp,-11
811117d8:	180d883a 	mov	r6,r3
811117dc:	01400284 	movi	r5,10
811117e0:	1009883a 	mov	r4,r2
811117e4:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
811117e8:	e0bffd43 	ldbu	r2,-11(fp)
811117ec:	10803fcc 	andi	r2,r2,255
811117f0:	1000401e 	bne	r2,zero,811118f4 <bSendMessagePUStoMebTask+0x150>

        for(i = 0; i < N_PUS_PIPE; i++)
811117f4:	e03ffd05 	stb	zero,-12(fp)
811117f8:	00003806 	br	811118dc <bSendMessagePUStoMebTask+0x138>
        {
            if ( xPus[i].bInUse == FALSE ) {
811117fc:	e0fffd03 	ldbu	r3,-12(fp)
81111800:	00a04574 	movhi	r2,33045
81111804:	1085a904 	addi	r2,r2,5796
81111808:	18c01524 	muli	r3,r3,84
8111180c:	10c5883a 	add	r2,r2,r3
81111810:	10800104 	addi	r2,r2,4
81111814:	10800017 	ldw	r2,0(r2)
81111818:	10002d1e 	bne	r2,zero,811118d0 <bSendMessagePUStoMebTask+0x12c>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
            	xPus[i] = (*xPusL);
8111181c:	e0fffd03 	ldbu	r3,-12(fp)
81111820:	00a04574 	movhi	r2,33045
81111824:	1085a904 	addi	r2,r2,5796
81111828:	18c01524 	muli	r3,r3,84
8111182c:	10c7883a 	add	r3,r2,r3
81111830:	e0bfff17 	ldw	r2,-4(fp)
81111834:	1009883a 	mov	r4,r2
81111838:	00801504 	movi	r2,84
8111183c:	100d883a 	mov	r6,r2
81111840:	200b883a 	mov	r5,r4
81111844:	1809883a 	mov	r4,r3
81111848:	111dac80 	call	8111dac8 <memcpy>
            	xPus[i].bInUse = TRUE;
8111184c:	e0fffd03 	ldbu	r3,-12(fp)
81111850:	00a04574 	movhi	r2,33045
81111854:	1085a904 	addi	r2,r2,5796
81111858:	18c01524 	muli	r3,r3,84
8111185c:	10c5883a 	add	r2,r2,r3
81111860:	10800104 	addi	r2,r2,4
81111864:	00c00044 	movi	r3,1
81111868:	10c00015 	stw	r3,0(r2)

            	/* Build the command to Meb using the Mask Queue */
            	xCdmLocal.ucByte[3] = M_MEB_ADDR;
8111186c:	00800044 	movi	r2,1
81111870:	e0bffec5 	stb	r2,-5(fp)
            	xCdmLocal.ucByte[2] = Q_MEB_PUS;
81111874:	00800044 	movi	r2,1
81111878:	e0bffe85 	stb	r2,-6(fp)

            	/* Sync the Meb task and tell that has a PUS command waiting */
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
8111187c:	d0a06517 	ldw	r2,-32364(gp)
81111880:	e0fffe17 	ldw	r3,-8(fp)
81111884:	180b883a 	mov	r5,r3
81111888:	1009883a 	mov	r4,r2
8111188c:	113a0040 	call	8113a004 <OSQPost>
81111890:	e0bffd45 	stb	r2,-11(fp)
                if ( error_code != OS_ERR_NONE ) {
81111894:	e0bffd43 	ldbu	r2,-11(fp)
81111898:	10803fcc 	andi	r2,r2,255
8111189c:	10000926 	beq	r2,zero,811118c4 <bSendMessagePUStoMebTask+0x120>
                	vFailSendPUStoMebTask();
811118a0:	11192b00 	call	811192b0 <vFailSendPUStoMebTask>
                	xPus[i].bInUse = FALSE;
811118a4:	e0fffd03 	ldbu	r3,-12(fp)
811118a8:	00a04574 	movhi	r2,33045
811118ac:	1085a904 	addi	r2,r2,5796
811118b0:	18c01524 	muli	r3,r3,84
811118b4:	10c5883a 	add	r2,r2,r3
811118b8:	10800104 	addi	r2,r2,4
811118bc:	10000015 	stw	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
811118c0:	00000906 	br	811118e8 <bSendMessagePUStoMebTask+0x144>
            	error_code = OSQPost(xMebQ, (void *)xCdmLocal.ulWord);
                if ( error_code != OS_ERR_NONE ) {
                	vFailSendPUStoMebTask();
                	xPus[i].bInUse = FALSE;
                } else
                    bSuccess = TRUE;
811118c4:	00800044 	movi	r2,1
811118c8:	e0bffc15 	stw	r2,-16(fp)
                break;
811118cc:	00000606 	br	811118e8 <bSendMessagePUStoMebTask+0x144>
    bSuccess = FALSE;
    xCdmLocal.ulWord = 0;
    OSMutexPend(xMutexPus, 10, &error_code); /* Try to get mutex that protects the xPus buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {

        for(i = 0; i < N_PUS_PIPE; i++)
811118d0:	e0bffd03 	ldbu	r2,-12(fp)
811118d4:	10800044 	addi	r2,r2,1
811118d8:	e0bffd05 	stb	r2,-12(fp)
811118dc:	e0bffd03 	ldbu	r2,-12(fp)
811118e0:	10800130 	cmpltui	r2,r2,4
811118e4:	103fc51e 	bne	r2,zero,811117fc <__reset+0xfb0f17fc>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexPus);
811118e8:	d0a06f17 	ldw	r2,-32324(gp)
811118ec:	1009883a 	mov	r4,r2
811118f0:	113908c0 	call	8113908c <OSMutexPost>
    }

    return bSuccess;
811118f4:	e0bffc17 	ldw	r2,-16(fp)
}
811118f8:	e037883a 	mov	sp,fp
811118fc:	dfc00117 	ldw	ra,4(sp)
81111900:	df000017 	ldw	fp,0(sp)
81111904:	dec00204 	addi	sp,sp,8
81111908:	f800283a 	ret

8111190c <vReceiverUartTask>:


#include "receiver_uart_task.h"


void vReceiverUartTask(void *task_data) {
8111190c:	deffab04 	addi	sp,sp,-340
81111910:	de00012e 	bgeu	sp,et,81111918 <vReceiverUartTask+0xc>
81111914:	003b68fa 	trap	3
81111918:	dfc05415 	stw	ra,336(sp)
8111191c:	df005315 	stw	fp,332(sp)
81111920:	df005304 	addi	fp,sp,332
81111924:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81111928:	e03fae15 	stw	zero,-328(fp)
    char cReceive[SIZE_RCV_BUFFER+64];
    tReaderStates eReaderRXMode;
    static tPreParsed xPreParsedReader;

    #ifdef DEBUG_ON
        debug(fp,"Receiver UART Task. (Task on)\n");
8111192c:	d0a05e17 	ldw	r2,-32392(gp)
81111930:	100f883a 	mov	r7,r2
81111934:	01800784 	movi	r6,30
81111938:	01400044 	movi	r5,1
8111193c:	01204574 	movhi	r4,33045
81111940:	2125a204 	addi	r4,r4,-27000
81111944:	111d0b40 	call	8111d0b4 <fwrite>
    #endif

    eReaderRXMode = sRConfiguring;
81111948:	e03fad15 	stw	zero,-332(fp)

    for(;;) {

        switch (eReaderRXMode)
8111194c:	e0bfad17 	ldw	r2,-332(fp)
81111950:	10c00060 	cmpeqi	r3,r2,1
81111954:	1800091e 	bne	r3,zero,8111197c <vReceiverUartTask+0x70>
81111958:	0080052e 	bgeu	zero,r2,81111970 <vReceiverUartTask+0x64>
8111195c:	10c000a0 	cmpeqi	r3,r2,2
81111960:	18005d1e 	bne	r3,zero,81111ad8 <vReceiverUartTask+0x1cc>
81111964:	108000e0 	cmpeqi	r2,r2,3
81111968:	10006e1e 	bne	r2,zero,81111b24 <vReceiverUartTask+0x218>
8111196c:	00007706 	br	81111b4c <vReceiverUartTask+0x240>
        {
            case sRConfiguring:
                /* For future implementations */
                eReaderRXMode = sGetRxUart;
81111970:	00800044 	movi	r2,1
81111974:	e0bfad15 	stw	r2,-332(fp)
                break;
81111978:	00007706 	br	81111b58 <vReceiverUartTask+0x24c>
            case sGetRxUart:

                memset(cReceiveBuffer, 0, SIZE_RCV_BUFFER);
8111197c:	e0bfaf04 	addi	r2,fp,-324
81111980:	01802004 	movi	r6,128
81111984:	000b883a 	mov	r5,zero
81111988:	1009883a 	mov	r4,r2
8111198c:	111dc180 	call	8111dc18 <memset>
                scanf("%s", cReceive);
81111990:	e0bfcf04 	addi	r2,fp,-196
81111994:	100b883a 	mov	r5,r2
81111998:	01204574 	movhi	r4,33045
8111199c:	2125aa04 	addi	r4,r4,-26968
811119a0:	111e2cc0 	call	8111e2cc <scanf>
                memcpy(cReceiveBuffer, cReceive, (SIZE_RCV_BUFFER -1) ); /* Make that there's a zero terminator */
811119a4:	e0ffcf04 	addi	r3,fp,-196
811119a8:	e0bfaf04 	addi	r2,fp,-324
811119ac:	01801fc4 	movi	r6,127
811119b0:	180b883a 	mov	r5,r3
811119b4:	1009883a 	mov	r4,r2
811119b8:	111dac80 	call	8111dac8 <memcpy>
                bSuccess = bPreParserV2( cReceiveBuffer , &xPreParsedReader );
811119bc:	e0bfaf04 	addi	r2,fp,-324
811119c0:	01604574 	movhi	r5,33045
811119c4:	297b5904 	addi	r5,r5,-4764
811119c8:	1009883a 	mov	r4,r2
811119cc:	1111fb00 	call	81111fb0 <bPreParserV2>
811119d0:	e0bfae15 	stw	r2,-328(fp)

                if ( bSuccess == TRUE ) {
811119d4:	e0bfae17 	ldw	r2,-328(fp)
811119d8:	10800058 	cmpnei	r2,r2,1
811119dc:	1000281e 	bne	r2,zero,81111a80 <vReceiverUartTask+0x174>

                    if ( (xPreParsedReader.cType == START_REQUEST_CHAR) || (xPreParsedReader.cType == START_REPLY_CHAR) ) {
811119e0:	00a04574 	movhi	r2,33045
811119e4:	10bb5904 	addi	r2,r2,-4764
811119e8:	10800103 	ldbu	r2,4(r2)
811119ec:	10803fcc 	andi	r2,r2,255
811119f0:	1080201c 	xori	r2,r2,128
811119f4:	10bfe004 	addi	r2,r2,-128
811119f8:	10800fe0 	cmpeqi	r2,r2,63
811119fc:	1000081e 	bne	r2,zero,81111a20 <vReceiverUartTask+0x114>
81111a00:	00a04574 	movhi	r2,33045
81111a04:	10bb5904 	addi	r2,r2,-4764
81111a08:	10800103 	ldbu	r2,4(r2)
81111a0c:	10803fcc 	andi	r2,r2,255
81111a10:	1080201c 	xori	r2,r2,128
81111a14:	10bfe004 	addi	r2,r2,-128
81111a18:	10800858 	cmpnei	r2,r2,33
81111a1c:	1000031e 	bne	r2,zero,81111a2c <vReceiverUartTask+0x120>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
81111a20:	00800084 	movi	r2,2
81111a24:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81111a28:	00004b06 	br	81111b58 <vReceiverUartTask+0x24c>
                        /* The packet is a request or reply sent by the NUC*/
                        eReaderRXMode = sSendToParser;
                    } else {
                        /* The packet is an ACK or NACK sent by the NUC*/
                        /* If is a Nack, do nothing. The packet will be retransmited by the timeout checker. */
                        if ( xPreParsedReader.cType == NACK_CHAR ) {
81111a2c:	00a04574 	movhi	r2,33045
81111a30:	10bb5904 	addi	r2,r2,-4764
81111a34:	10800103 	ldbu	r2,4(r2)
81111a38:	10803fcc 	andi	r2,r2,255
81111a3c:	1080201c 	xori	r2,r2,128
81111a40:	10bfe004 	addi	r2,r2,-128
81111a44:	108008d8 	cmpnei	r2,r2,35
81111a48:	10000a1e 	bne	r2,zero,81111a74 <vReceiverUartTask+0x168>
                            eReaderRXMode = sGetRxUart;
81111a4c:	00800044 	movi	r2,1
81111a50:	e0bfad15 	stw	r2,-332(fp)
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
81111a54:	d0a05e17 	ldw	r2,-32392(gp)
81111a58:	100f883a 	mov	r7,r2
81111a5c:	018006c4 	movi	r6,27
81111a60:	01400044 	movi	r5,1
81111a64:	01204574 	movhi	r4,33045
81111a68:	2125ab04 	addi	r4,r4,-26964
81111a6c:	111d0b40 	call	8111d0b4 <fwrite>
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81111a70:	00003906 	br	81111b58 <vReceiverUartTask+0x24c>
                            eReaderRXMode = sGetRxUart;
                            #ifdef DEBUG_ON
                                debug(fp,"Nack Received. Do nothing!\n");
                            #endif
                        } else
                            eReaderRXMode = sSendToACKReceiver;
81111a74:	008000c4 	movi	r2,3
81111a78:	e0bfad15 	stw	r2,-332(fp)
                        vFailSendNack();
                    }
                    eReaderRXMode = sGetRxUart;
                }

                break;
81111a7c:	00003606 	br	81111b58 <vReceiverUartTask+0x24c>

                    }

                } else {
                    /*Should Send NACK - Mocking value the only parte that metters is the "cType = '#'" part */
                    xPreParsedReader.cType = '#';
81111a80:	00a04574 	movhi	r2,33045
81111a84:	10bb5904 	addi	r2,r2,-4764
81111a88:	00c008c4 	movi	r3,35
81111a8c:	10c00105 	stb	r3,4(r2)
                    xPreParsedReader.cCommand = '.';
81111a90:	00a04574 	movhi	r2,33045
81111a94:	10bb5904 	addi	r2,r2,-4764
81111a98:	00c00b84 	movi	r3,46
81111a9c:	10c00145 	stb	r3,5(r2)
                    xPreParsedReader.usiValues[0] = 1;
81111aa0:	00a04574 	movhi	r2,33045
81111aa4:	10bb5904 	addi	r2,r2,-4764
81111aa8:	00c00044 	movi	r3,1
81111aac:	10c0020d 	sth	r3,8(r2)

                    /*Try to send ack to the Ack Sender Task*/
                    bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81111ab0:	01204574 	movhi	r4,33045
81111ab4:	213b5904 	addi	r4,r4,-4764
81111ab8:	1111c980 	call	81111c98 <setPreAckSenderFreePos>
81111abc:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81111ac0:	e0bfae17 	ldw	r2,-328(fp)
81111ac4:	1000011e 	bne	r2,zero,81111acc <vReceiverUartTask+0x1c0>
                        vFailSendNack();
81111ac8:	11184f80 	call	811184f8 <vFailSendNack>
                    }
                    eReaderRXMode = sGetRxUart;
81111acc:	00800044 	movi	r2,1
81111ad0:	e0bfad15 	stw	r2,-332(fp)
                }

                break;
81111ad4:	00002006 	br	81111b58 <vReceiverUartTask+0x24c>
            case sSendToParser:

                /* Try to send ack to the Ack Sender Task*/
                bSuccess = setPreAckSenderFreePos( &xPreParsedReader );
81111ad8:	01204574 	movhi	r4,33045
81111adc:	213b5904 	addi	r4,r4,-4764
81111ae0:	1111c980 	call	81111c98 <setPreAckSenderFreePos>
81111ae4:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == TRUE ) {
81111ae8:	e0bfae17 	ldw	r2,-328(fp)
81111aec:	10800058 	cmpnei	r2,r2,1
81111af0:	1000081e 	bne	r2,zero,81111b14 <vReceiverUartTask+0x208>
                    /* If was possible to send ack, then try to send the command to the Parser Task*/
                    bSuccess = setPreParsedFreePos( &xPreParsedReader );
81111af4:	01204574 	movhi	r4,33045
81111af8:	213b5904 	addi	r4,r4,-4764
81111afc:	1111b5c0 	call	81111b5c <setPreParsedFreePos>
81111b00:	e0bfae15 	stw	r2,-328(fp)
                    if ( bSuccess == FALSE ) {
81111b04:	e0bfae17 	ldw	r2,-328(fp)
81111b08:	1000031e 	bne	r2,zero,81111b18 <vReceiverUartTask+0x20c>
                        //TODO
                        /* At this point ack was sent but the command was not sent to the Parser task
                           should sent an error message for the NUC and maye to the SGSE*/
                        vFailSetPreParsedBuffer();
81111b0c:	11185c80 	call	811185c8 <vFailSetPreParsedBuffer>
81111b10:	00000106 	br	81111b18 <vReceiverUartTask+0x20c>
                    }
                } else {
                    vFailSetPreAckSenderBuffer();
81111b14:	11185600 	call	81118560 <vFailSetPreAckSenderBuffer>
                }
                /* If is not possible to send the ACK for this command then we don't process the command,
                   because it will be sent again by the NUC and we won't wast processing performing the command twice.*/
                eReaderRXMode = sGetRxUart;
81111b18:	00800044 	movi	r2,1
81111b1c:	e0bfad15 	stw	r2,-332(fp)
                break;
81111b20:	00000d06 	br	81111b58 <vReceiverUartTask+0x24c>
            case sSendToACKReceiver:

                bSuccess = setPreAckReceiverFreePos( &xPreParsedReader );
81111b24:	01204574 	movhi	r4,33045
81111b28:	213b5904 	addi	r4,r4,-4764
81111b2c:	1111e140 	call	81111e14 <setPreAckReceiverFreePos>
81111b30:	e0bfae15 	stw	r2,-328(fp)
                if ( bSuccess == FALSE ) {
81111b34:	e0bfae17 	ldw	r2,-328(fp)
81111b38:	1000011e 	bne	r2,zero,81111b40 <vReceiverUartTask+0x234>
                    /*If was not possible to receive the ack do nothing.*/
                    vFailSetPreAckReceiverBuffer();
81111b3c:	11186300 	call	81118630 <vFailSetPreAckReceiverBuffer>
                }
                eReaderRXMode = sGetRxUart;
81111b40:	00800044 	movi	r2,1
81111b44:	e0bfad15 	stw	r2,-332(fp)
                break;
81111b48:	00000306 	br	81111b58 <vReceiverUartTask+0x24c>
            default:
                eReaderRXMode = sGetRxUart;
81111b4c:	00800044 	movi	r2,1
81111b50:	e0bfad15 	stw	r2,-332(fp)
                break;
81111b54:	0001883a 	nop
        }

    }
81111b58:	003f7c06 	br	8111194c <__reset+0xfb0f194c>

81111b5c <setPreParsedFreePos>:
}


/* Search for a Free location to put the pre parsed packet in the pipe for the ParserTask */
bool setPreParsedFreePos( tPreParsed *xPrePReader ) {
81111b5c:	defffb04 	addi	sp,sp,-20
81111b60:	de00012e 	bgeu	sp,et,81111b68 <setPreParsedFreePos+0xc>
81111b64:	003b68fa 	trap	3
81111b68:	dfc00415 	stw	ra,16(sp)
81111b6c:	df000315 	stw	fp,12(sp)
81111b70:	df000304 	addi	fp,sp,12
81111b74:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81111b78:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81111b7c:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81111b80:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81111b84:	d0a06717 	ldw	r2,-32356(gp)
81111b88:	e0fffe44 	addi	r3,fp,-7
81111b8c:	180d883a 	mov	r6,r3
81111b90:	01400284 	movi	r5,10
81111b94:	1009883a 	mov	r4,r2
81111b98:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111b9c:	e0bffe43 	ldbu	r2,-7(fp)
81111ba0:	10803fcc 	andi	r2,r2,255
81111ba4:	1000361e 	bne	r2,zero,81111c80 <setPreParsedFreePos+0x124>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81111ba8:	e03ffe05 	stb	zero,-8(fp)
81111bac:	00002e06 	br	81111c68 <setPreParsedFreePos+0x10c>
        {
            if ( xPreParsed[i].cType == 0 ) {
81111bb0:	e0fffe03 	ldbu	r3,-8(fp)
81111bb4:	00a045b4 	movhi	r2,33046
81111bb8:	10885804 	addi	r2,r2,8544
81111bbc:	18c01324 	muli	r3,r3,76
81111bc0:	10c5883a 	add	r2,r2,r3
81111bc4:	10800104 	addi	r2,r2,4
81111bc8:	10800003 	ldbu	r2,0(r2)
81111bcc:	10803fcc 	andi	r2,r2,255
81111bd0:	1080201c 	xori	r2,r2,128
81111bd4:	10bfe004 	addi	r2,r2,-128
81111bd8:	1000201e 	bne	r2,zero,81111c5c <setPreParsedFreePos+0x100>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xPreParsed[i] = (*xPrePReader);
81111bdc:	e0fffe03 	ldbu	r3,-8(fp)
81111be0:	00a045b4 	movhi	r2,33046
81111be4:	10885804 	addi	r2,r2,8544
81111be8:	18c01324 	muli	r3,r3,76
81111bec:	10c7883a 	add	r3,r2,r3
81111bf0:	e0bfff17 	ldw	r2,-4(fp)
81111bf4:	1009883a 	mov	r4,r2
81111bf8:	00801304 	movi	r2,76
81111bfc:	100d883a 	mov	r6,r2
81111c00:	200b883a 	mov	r5,r4
81111c04:	1809883a 	mov	r4,r3
81111c08:	111dac80 	call	8111dac8 <memcpy>
                error_code = OSSemPost(xSemCountPreParsed);
81111c0c:	d0a06017 	ldw	r2,-32384(gp)
81111c10:	1009883a 	mov	r4,r2
81111c14:	113ae7c0 	call	8113ae7c <OSSemPost>
81111c18:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81111c1c:	e0bffe43 	ldbu	r2,-7(fp)
81111c20:	10803fcc 	andi	r2,r2,255
81111c24:	1000031e 	bne	r2,zero,81111c34 <setPreParsedFreePos+0xd8>
                    bSuccess = TRUE;
81111c28:	00800044 	movi	r2,1
81111c2c:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreParsedSemaphore();
                    xPreParsed[i].cType = 0;
                    bSuccess = FALSE;
                }
                break;
81111c30:	00001006 	br	81111c74 <setPreParsedFreePos+0x118>
                xPreParsed[i] = (*xPrePReader);
                error_code = OSSemPost(xSemCountPreParsed);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreParsedSemaphore();
81111c34:	1117c180 	call	81117c18 <vFailSendPreParsedSemaphore>
                    xPreParsed[i].cType = 0;
81111c38:	e0fffe03 	ldbu	r3,-8(fp)
81111c3c:	00a045b4 	movhi	r2,33046
81111c40:	10885804 	addi	r2,r2,8544
81111c44:	18c01324 	muli	r3,r3,76
81111c48:	10c5883a 	add	r2,r2,r3
81111c4c:	10800104 	addi	r2,r2,4
81111c50:	10000005 	stb	zero,0(r2)
                    bSuccess = FALSE;
81111c54:	e03ffd15 	stw	zero,-12(fp)
                }
                break;
81111c58:	00000606 	br	81111c74 <setPreParsedFreePos+0x118>
    bSuccess = FALSE;
    OSMutexPend(xMutexPreParsed, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_PREPARSED_ENTRIES; i++ )
81111c5c:	e0bffe03 	ldbu	r2,-8(fp)
81111c60:	10800044 	addi	r2,r2,1
81111c64:	e0bffe05 	stb	r2,-8(fp)
81111c68:	e0bffe03 	ldbu	r2,-8(fp)
81111c6c:	10800230 	cmpltui	r2,r2,8
81111c70:	103fcf1e 	bne	r2,zero,81111bb0 <__reset+0xfb0f1bb0>
                    bSuccess = FALSE;
                }
                break;
            }
        }
        OSMutexPost(xMutexPreParsed);
81111c74:	d0a06717 	ldw	r2,-32356(gp)
81111c78:	1009883a 	mov	r4,r2
81111c7c:	113908c0 	call	8113908c <OSMutexPost>
    }
    return bSuccess;
81111c80:	e0bffd17 	ldw	r2,-12(fp)
}
81111c84:	e037883a 	mov	sp,fp
81111c88:	dfc00117 	ldw	ra,4(sp)
81111c8c:	df000017 	ldw	fp,0(sp)
81111c90:	dec00204 	addi	sp,sp,8
81111c94:	f800283a 	ret

81111c98 <setPreAckSenderFreePos>:



/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckSenderFreePos( tPreParsed *xPrePReader ) {
81111c98:	defffb04 	addi	sp,sp,-20
81111c9c:	de00012e 	bgeu	sp,et,81111ca4 <setPreAckSenderFreePos+0xc>
81111ca0:	003b68fa 	trap	3
81111ca4:	dfc00415 	stw	ra,16(sp)
81111ca8:	df000315 	stw	fp,12(sp)
81111cac:	df000304 	addi	fp,sp,12
81111cb0:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81111cb4:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81111cb8:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81111cbc:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
81111cc0:	d0a06e17 	ldw	r2,-32328(gp)
81111cc4:	e0fffe44 	addi	r3,fp,-7
81111cc8:	180d883a 	mov	r6,r3
81111ccc:	01400284 	movi	r5,10
81111cd0:	1009883a 	mov	r4,r2
81111cd4:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111cd8:	e0bffe43 	ldbu	r2,-7(fp)
81111cdc:	10803fcc 	andi	r2,r2,255
81111ce0:	1000461e 	bne	r2,zero,81111dfc <setPreAckSenderFreePos+0x164>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81111ce4:	e03ffe05 	stb	zero,-8(fp)
81111ce8:	00003e06 	br	81111de4 <setPreAckSenderFreePos+0x14c>
        {
            if ( xSenderACK[i].cType == 0 ) {
81111cec:	e0fffe03 	ldbu	r3,-8(fp)
81111cf0:	00a045b4 	movhi	r2,33046
81111cf4:	10885004 	addi	r2,r2,8512
81111cf8:	18c7883a 	add	r3,r3,r3
81111cfc:	18c7883a 	add	r3,r3,r3
81111d00:	10c5883a 	add	r2,r2,r3
81111d04:	10800003 	ldbu	r2,0(r2)
81111d08:	10803fcc 	andi	r2,r2,255
81111d0c:	1080201c 	xori	r2,r2,128
81111d10:	10bfe004 	addi	r2,r2,-128
81111d14:	1000301e 	bne	r2,zero,81111dd8 <setPreAckSenderFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xSenderACK[i].cType = xPrePReader->cType;
81111d18:	e0fffe03 	ldbu	r3,-8(fp)
81111d1c:	e0bfff17 	ldw	r2,-4(fp)
81111d20:	11000103 	ldbu	r4,4(r2)
81111d24:	00a045b4 	movhi	r2,33046
81111d28:	10885004 	addi	r2,r2,8512
81111d2c:	18c7883a 	add	r3,r3,r3
81111d30:	18c7883a 	add	r3,r3,r3
81111d34:	10c5883a 	add	r2,r2,r3
81111d38:	11000005 	stb	r4,0(r2)
                xSenderACK[i].cCommand = xPrePReader->cCommand;
81111d3c:	e0fffe03 	ldbu	r3,-8(fp)
81111d40:	e0bfff17 	ldw	r2,-4(fp)
81111d44:	11000143 	ldbu	r4,5(r2)
81111d48:	00a045b4 	movhi	r2,33046
81111d4c:	10885004 	addi	r2,r2,8512
81111d50:	18c7883a 	add	r3,r3,r3
81111d54:	18c7883a 	add	r3,r3,r3
81111d58:	10c5883a 	add	r2,r2,r3
81111d5c:	10800044 	addi	r2,r2,1
81111d60:	11000005 	stb	r4,0(r2)
                xSenderACK[i].usiId = xPrePReader->usiValues[0]; /*The first value is always the command id*/
81111d64:	e0fffe03 	ldbu	r3,-8(fp)
81111d68:	e0bfff17 	ldw	r2,-4(fp)
81111d6c:	1100020b 	ldhu	r4,8(r2)
81111d70:	00a045b4 	movhi	r2,33046
81111d74:	10885004 	addi	r2,r2,8512
81111d78:	18c7883a 	add	r3,r3,r3
81111d7c:	18c7883a 	add	r3,r3,r3
81111d80:	10c5883a 	add	r2,r2,r3
81111d84:	10800084 	addi	r2,r2,2
81111d88:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountSenderACK);
81111d8c:	d0a05d17 	ldw	r2,-32396(gp)
81111d90:	1009883a 	mov	r4,r2
81111d94:	113ae7c0 	call	8113ae7c <OSSemPost>
81111d98:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code != OS_ERR_NONE ) {
81111d9c:	e0bffe43 	ldbu	r2,-7(fp)
81111da0:	10803fcc 	andi	r2,r2,255
81111da4:	10000926 	beq	r2,zero,81111dcc <setPreAckSenderFreePos+0x134>
                    vFailSendPreAckSenderSemaphore();
81111da8:	1117cb00 	call	81117cb0 <vFailSendPreAckSenderSemaphore>
                    xSenderACK[i].cType = 0;
81111dac:	e0fffe03 	ldbu	r3,-8(fp)
81111db0:	00a045b4 	movhi	r2,33046
81111db4:	10885004 	addi	r2,r2,8512
81111db8:	18c7883a 	add	r3,r3,r3
81111dbc:	18c7883a 	add	r3,r3,r3
81111dc0:	10c5883a 	add	r2,r2,r3
81111dc4:	10000005 	stb	zero,0(r2)
                } else
                    bSuccess = TRUE;
                break;
81111dc8:	00000906 	br	81111df0 <setPreAckSenderFreePos+0x158>
                error_code = OSSemPost(xSemCountSenderACK);
                if ( error_code != OS_ERR_NONE ) {
                    vFailSendPreAckSenderSemaphore();
                    xSenderACK[i].cType = 0;
                } else
                    bSuccess = TRUE;
81111dcc:	00800044 	movi	r2,1
81111dd0:	e0bffd15 	stw	r2,-12(fp)
                break;
81111dd4:	00000606 	br	81111df0 <setPreAckSenderFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexSenderACK, 10, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait max 10 ticks = 10 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for(i = 0; i < N_ACKS_SENDER; i++)
81111dd8:	e0bffe03 	ldbu	r2,-8(fp)
81111ddc:	10800044 	addi	r2,r2,1
81111de0:	e0bffe05 	stb	r2,-8(fp)
81111de4:	e0bffe03 	ldbu	r2,-8(fp)
81111de8:	10800230 	cmpltui	r2,r2,8
81111dec:	103fbf1e 	bne	r2,zero,81111cec <__reset+0xfb0f1cec>
                } else
                    bSuccess = TRUE;
                break;
            }
        }
        OSMutexPost(xMutexSenderACK);
81111df0:	d0a06e17 	ldw	r2,-32328(gp)
81111df4:	1009883a 	mov	r4,r2
81111df8:	113908c0 	call	8113908c <OSMutexPost>
    }

    return bSuccess;
81111dfc:	e0bffd17 	ldw	r2,-12(fp)
}
81111e00:	e037883a 	mov	sp,fp
81111e04:	dfc00117 	ldw	ra,4(sp)
81111e08:	df000017 	ldw	fp,0(sp)
81111e0c:	dec00204 	addi	sp,sp,8
81111e10:	f800283a 	ret

81111e14 <setPreAckReceiverFreePos>:

/* Search for some free location in the xSenderACK array, that comunicates with the AckSenderTask */
bool setPreAckReceiverFreePos( tPreParsed *xPrePReader ) {
81111e14:	defffb04 	addi	sp,sp,-20
81111e18:	de00012e 	bgeu	sp,et,81111e20 <setPreAckReceiverFreePos+0xc>
81111e1c:	003b68fa 	trap	3
81111e20:	dfc00415 	stw	ra,16(sp)
81111e24:	df000315 	stw	fp,12(sp)
81111e28:	df000304 	addi	fp,sp,12
81111e2c:	e13fff15 	stw	r4,-4(fp)
    bool bSuccess = FALSE;
81111e30:	e03ffd15 	stw	zero,-12(fp)
    INT8U error_code;
    unsigned char i = 0;
81111e34:	e03ffe05 	stb	zero,-8(fp)

    bSuccess = FALSE;
81111e38:	e03ffd15 	stw	zero,-12(fp)
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
81111e3c:	d0a06117 	ldw	r2,-32380(gp)
81111e40:	e0fffe44 	addi	r3,fp,-7
81111e44:	180d883a 	mov	r6,r3
81111e48:	01400504 	movi	r5,20
81111e4c:	1009883a 	mov	r4,r2
81111e50:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( error_code == OS_NO_ERR ) {
81111e54:	e0bffe43 	ldbu	r2,-7(fp)
81111e58:	10803fcc 	andi	r2,r2,255
81111e5c:	1000471e 	bne	r2,zero,81111f7c <setPreAckReceiverFreePos+0x168>
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81111e60:	e03ffe05 	stb	zero,-8(fp)
81111e64:	00003e06 	br	81111f60 <setPreAckReceiverFreePos+0x14c>
        {
            if ( xReceivedACK[i].cType == 0 ) {
81111e68:	e0fffe03 	ldbu	r3,-8(fp)
81111e6c:	00a045b4 	movhi	r2,33046
81111e70:	10b24204 	addi	r2,r2,-14072
81111e74:	18c7883a 	add	r3,r3,r3
81111e78:	18c7883a 	add	r3,r3,r3
81111e7c:	10c5883a 	add	r2,r2,r3
81111e80:	10800003 	ldbu	r2,0(r2)
81111e84:	10803fcc 	andi	r2,r2,255
81111e88:	1080201c 	xori	r2,r2,128
81111e8c:	10bfe004 	addi	r2,r2,-128
81111e90:	1000301e 	bne	r2,zero,81111f54 <setPreAckReceiverFreePos+0x140>
                /* Locate a free place*/
                /* Need to check if the performance is the same as memcpy*/
                xReceivedACK[i].cType = xPrePReader->cType;
81111e94:	e0fffe03 	ldbu	r3,-8(fp)
81111e98:	e0bfff17 	ldw	r2,-4(fp)
81111e9c:	11000103 	ldbu	r4,4(r2)
81111ea0:	00a045b4 	movhi	r2,33046
81111ea4:	10b24204 	addi	r2,r2,-14072
81111ea8:	18c7883a 	add	r3,r3,r3
81111eac:	18c7883a 	add	r3,r3,r3
81111eb0:	10c5883a 	add	r2,r2,r3
81111eb4:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].cCommand = xPrePReader->cCommand;
81111eb8:	e0fffe03 	ldbu	r3,-8(fp)
81111ebc:	e0bfff17 	ldw	r2,-4(fp)
81111ec0:	11000143 	ldbu	r4,5(r2)
81111ec4:	00a045b4 	movhi	r2,33046
81111ec8:	10b24204 	addi	r2,r2,-14072
81111ecc:	18c7883a 	add	r3,r3,r3
81111ed0:	18c7883a 	add	r3,r3,r3
81111ed4:	10c5883a 	add	r2,r2,r3
81111ed8:	10800044 	addi	r2,r2,1
81111edc:	11000005 	stb	r4,0(r2)
                xReceivedACK[i].usiId = xPrePReader->usiValues[0];
81111ee0:	e0fffe03 	ldbu	r3,-8(fp)
81111ee4:	e0bfff17 	ldw	r2,-4(fp)
81111ee8:	1100020b 	ldhu	r4,8(r2)
81111eec:	00a045b4 	movhi	r2,33046
81111ef0:	10b24204 	addi	r2,r2,-14072
81111ef4:	18c7883a 	add	r3,r3,r3
81111ef8:	18c7883a 	add	r3,r3,r3
81111efc:	10c5883a 	add	r2,r2,r3
81111f00:	10800084 	addi	r2,r2,2
81111f04:	1100000d 	sth	r4,0(r2)

                error_code = OSSemPost(xSemCountReceivedACK);
81111f08:	d0a06217 	ldw	r2,-32376(gp)
81111f0c:	1009883a 	mov	r4,r2
81111f10:	113ae7c0 	call	8113ae7c <OSSemPost>
81111f14:	e0bffe45 	stb	r2,-7(fp)
                if ( error_code == OS_ERR_NONE ) {
81111f18:	e0bffe43 	ldbu	r2,-7(fp)
81111f1c:	10803fcc 	andi	r2,r2,255
81111f20:	1000031e 	bne	r2,zero,81111f30 <setPreAckReceiverFreePos+0x11c>
                    bSuccess = TRUE;
81111f24:	00800044 	movi	r2,1
81111f28:	e0bffd15 	stw	r2,-12(fp)
                } else {
                    vFailSendPreAckReceiverSemaphore();
                    xReceivedACK[i].cType = 0;
                }
                break;
81111f2c:	00000f06 	br	81111f6c <setPreAckReceiverFreePos+0x158>

                error_code = OSSemPost(xSemCountReceivedACK);
                if ( error_code == OS_ERR_NONE ) {
                    bSuccess = TRUE;
                } else {
                    vFailSendPreAckReceiverSemaphore();
81111f30:	1117c640 	call	81117c64 <vFailSendPreAckReceiverSemaphore>
                    xReceivedACK[i].cType = 0;
81111f34:	e0fffe03 	ldbu	r3,-8(fp)
81111f38:	00a045b4 	movhi	r2,33046
81111f3c:	10b24204 	addi	r2,r2,-14072
81111f40:	18c7883a 	add	r3,r3,r3
81111f44:	18c7883a 	add	r3,r3,r3
81111f48:	10c5883a 	add	r2,r2,r3
81111f4c:	10000005 	stb	zero,0(r2)
                }
                break;
81111f50:	00000606 	br	81111f6c <setPreAckReceiverFreePos+0x158>
    bSuccess = FALSE;
    OSMutexPend(xMutexReceivedACK, 20, &error_code); /* Try to get mutex that protects the preparsed buffer. Wait 20 ticks = 20 ms */
    if ( error_code == OS_NO_ERR ) {
        /* Have free access to the buffer, check if there's any no threated command using the cType  */

        for( i = 0; i < N_ACKS_RECEIVED; i++ )
81111f54:	e0bffe03 	ldbu	r2,-8(fp)
81111f58:	10800044 	addi	r2,r2,1
81111f5c:	e0bffe05 	stb	r2,-8(fp)
81111f60:	e0bffe03 	ldbu	r2,-8(fp)
81111f64:	108001b0 	cmpltui	r2,r2,6
81111f68:	103fbf1e 	bne	r2,zero,81111e68 <__reset+0xfb0f1e68>
                    xReceivedACK[i].cType = 0;
                }
                break;
            }
        }
        OSMutexPost(xMutexReceivedACK);
81111f6c:	d0a06117 	ldw	r2,-32380(gp)
81111f70:	1009883a 	mov	r4,r2
81111f74:	113908c0 	call	8113908c <OSMutexPost>
81111f78:	00000706 	br	81111f98 <setPreAckReceiverFreePos+0x184>
    } else {
        /* Could not  */
        #ifdef DEBUG_ON
            debug(fp,"Could not put the ack packet receiveid in the queue. (setPreAckReceiverFreePos)\n");
81111f7c:	d0a05e17 	ldw	r2,-32392(gp)
81111f80:	100f883a 	mov	r7,r2
81111f84:	01801404 	movi	r6,80
81111f88:	01400044 	movi	r5,1
81111f8c:	01204574 	movhi	r4,33045
81111f90:	2125b204 	addi	r4,r4,-26936
81111f94:	111d0b40 	call	8111d0b4 <fwrite>
        #endif
    }

    return bSuccess;
81111f98:	e0bffd17 	ldw	r2,-12(fp)
}
81111f9c:	e037883a 	mov	sp,fp
81111fa0:	dfc00117 	ldw	ra,4(sp)
81111fa4:	df000017 	ldw	fp,0(sp)
81111fa8:	dec00204 	addi	sp,sp,8
81111fac:	f800283a 	ret

81111fb0 <bPreParserV2>:
/*  This function will parse the buffer into a command, will identify if is an request or reply
    also will separate all the values separated by ':'. If the command isn't complete (';' in the final)
    it will return false. */
    /* Max size of parsed value is 6 digits, for now*/
bool bPreParserV2( char *buffer, tPreParsed *xPerParcedBuffer )
{
81111fb0:	defff404 	addi	sp,sp,-48
81111fb4:	de00012e 	bgeu	sp,et,81111fbc <bPreParserV2+0xc>
81111fb8:	003b68fa 	trap	3
81111fbc:	dfc00b15 	stw	ra,44(sp)
81111fc0:	df000a15 	stw	fp,40(sp)
81111fc4:	dc000915 	stw	r16,36(sp)
81111fc8:	df000a04 	addi	fp,sp,40
81111fcc:	e13ffd15 	stw	r4,-12(fp)
81111fd0:	e17ffe15 	stw	r5,-8(fp)
    bool bSuccess = FALSE;
81111fd4:	e03ff615 	stw	zero,-40(fp)
    unsigned char i;
	char c, *p_inteiro;
	char inteiro[6]; /* Max size of parsed value is 6 digits, for now */


    bSuccess = FALSE;
81111fd8:	e03ff615 	stw	zero,-40(fp)

    siStrLen = strnlen(buffer, SIZE_RCV_BUFFER);
81111fdc:	01402004 	movi	r5,128
81111fe0:	e13ffd17 	ldw	r4,-12(fp)
81111fe4:	111e6540 	call	8111e654 <strnlen>
81111fe8:	e0bff90d 	sth	r2,-28(fp)
    siTeminador = siPosStr(buffer, FINAL_CHAR);
81111fec:	01400ec4 	movi	r5,59
81111ff0:	e13ffd17 	ldw	r4,-12(fp)
81111ff4:	11166a00 	call	811166a0 <siPosStr>
81111ff8:	e0bff98d 	sth	r2,-26(fp)

    /* Check the protocol terminator char ';' */
    if ( (siTeminador != (siStrLen-1)) )
81111ffc:	e0fff98f 	ldh	r3,-26(fp)
81112000:	e0bff90f 	ldh	r2,-28(fp)
81112004:	10bfffc4 	addi	r2,r2,-1
81112008:	18800226 	beq	r3,r2,81112014 <bPreParserV2+0x64>
        return bSuccess;
8111200c:	e0bff617 	ldw	r2,-40(fp)
81112010:	0000ba06 	br	811122fc <bPreParserV2+0x34c>

    siCRC = siPosStr(buffer, SEPARATOR_CRC);
81112014:	01401f04 	movi	r5,124
81112018:	e13ffd17 	ldw	r4,-12(fp)
8111201c:	11166a00 	call	811166a0 <siPosStr>
81112020:	e0bffa0d 	sth	r2,-24(fp)

    /* Check if there's an CRC char */
    if ( siCRC > siTeminador )
81112024:	e0bffa0f 	ldh	r2,-24(fp)
81112028:	e0fff98f 	ldh	r3,-26(fp)
8111202c:	1880020e 	bge	r3,r2,81112038 <bPreParserV2+0x88>
        return bSuccess;
81112030:	e0bff617 	ldw	r2,-40(fp)
81112034:	0000b106 	br	811122fc <bPreParserV2+0x34c>

    siIni = strcspn( buffer , ALL_INI_CHAR ); /* Verify if there's any one of the initial characters */
81112038:	01604574 	movhi	r5,33045
8111203c:	2965c704 	addi	r5,r5,-26852
81112040:	e13ffd17 	ldw	r4,-12(fp)
81112044:	111e5700 	call	8111e570 <strcspn>
81112048:	e0bffa8d 	sth	r2,-22(fp)

    /* Check if there's any initial char protocol and if is before the crc char */
    if ( siIni > siCRC)
8111204c:	e0bffa8f 	ldh	r2,-22(fp)
81112050:	e0fffa0f 	ldh	r3,-24(fp)
81112054:	1880020e 	bge	r3,r2,81112060 <bPreParserV2+0xb0>
        return bSuccess;
81112058:	e0bff617 	ldw	r2,-40(fp)
8111205c:	0000a706 	br	811122fc <bPreParserV2+0x34c>

    
    /*" ---> At this point we validate the existence and position of all characters in for the protocol in the message "*/


    xPerParcedBuffer->cType = buffer[siIni];
81112060:	e0bffa8f 	ldh	r2,-22(fp)
81112064:	e0fffd17 	ldw	r3,-12(fp)
81112068:	1885883a 	add	r2,r3,r2
8111206c:	10c00003 	ldbu	r3,0(r2)
81112070:	e0bffe17 	ldw	r2,-8(fp)
81112074:	10c00105 	stb	r3,4(r2)
    if (xPerParcedBuffer->cType == NACK_CHAR ) {
81112078:	e0bffe17 	ldw	r2,-8(fp)
8111207c:	10800103 	ldbu	r2,4(r2)
81112080:	10803fcc 	andi	r2,r2,255
81112084:	1080201c 	xori	r2,r2,128
81112088:	10bfe004 	addi	r2,r2,-128
8111208c:	108008d8 	cmpnei	r2,r2,35
81112090:	1000041e 	bne	r2,zero,811120a4 <bPreParserV2+0xf4>
        bSuccess = TRUE;
81112094:	00800044 	movi	r2,1
81112098:	e0bff615 	stw	r2,-40(fp)
        return bSuccess;
8111209c:	e0bff617 	ldw	r2,-40(fp)
811120a0:	00009606 	br	811122fc <bPreParserV2+0x34c>


    /*" ---> At this point the packet is a Resquest, Reply or ACK packet"*/


    xPerParcedBuffer->ucCalculatedCRC8 = ucCrc8wInit( &buffer[siIni] , (siCRC - siIni) );
811120a4:	e0bffa8f 	ldh	r2,-22(fp)
811120a8:	e0fffd17 	ldw	r3,-12(fp)
811120ac:	1889883a 	add	r4,r3,r2
811120b0:	e0fffa0f 	ldh	r3,-24(fp)
811120b4:	e0bffa8f 	ldh	r2,-22(fp)
811120b8:	1885c83a 	sub	r2,r3,r2
811120bc:	100b883a 	mov	r5,r2
811120c0:	11178c00 	call	811178c0 <ucCrc8wInit>
811120c4:	1007883a 	mov	r3,r2
811120c8:	e0bffe17 	ldw	r2,-8(fp)
811120cc:	10c01205 	stb	r3,72(r2)

    xPerParcedBuffer->cCommand = buffer[siIni+1];
811120d0:	e0bffa8f 	ldh	r2,-22(fp)
811120d4:	10800044 	addi	r2,r2,1
811120d8:	e0fffd17 	ldw	r3,-12(fp)
811120dc:	1885883a 	add	r2,r3,r2
811120e0:	10c00003 	ldbu	r3,0(r2)
811120e4:	e0bffe17 	ldw	r2,-8(fp)
811120e8:	10c00145 	stb	r3,5(r2)
    xPerParcedBuffer->ucNofBytes = 0;
811120ec:	e0bffe17 	ldw	r2,-8(fp)
811120f0:	10000185 	stb	zero,6(r2)

    memset( xPerParcedBuffer->usiValues , 0x00 , sizeof(xPerParcedBuffer->usiValues) );
811120f4:	e0bffe17 	ldw	r2,-8(fp)
811120f8:	10800204 	addi	r2,r2,8
811120fc:	01801004 	movi	r6,64
81112100:	000b883a 	mov	r5,zero
81112104:	1009883a 	mov	r4,r2
81112108:	111dc180 	call	8111dc18 <memset>

    i = siIni + 3; /* "?C:i..." */
8111210c:	e0bffa8b 	ldhu	r2,-22(fp)
81112110:	108000c4 	addi	r2,r2,3
81112114:	e0bff705 	stb	r2,-36(fp)
    do {
        p_inteiro = inteiro;
81112118:	e0bffb44 	addi	r2,fp,-19
8111211c:	e0bff815 	stw	r2,-32(fp)
        memset( &(inteiro) , 0 , sizeof( inteiro ) );
81112120:	e0bffb44 	addi	r2,fp,-19
81112124:	01800184 	movi	r6,6
81112128:	000b883a 	mov	r5,zero
8111212c:	1009883a 	mov	r4,r2
81112130:	111dc180 	call	8111dc18 <memset>
        do {
            c = buffer[i];
81112134:	e0bff703 	ldbu	r2,-36(fp)
81112138:	e0fffd17 	ldw	r3,-12(fp)
8111213c:	1885883a 	add	r2,r3,r2
81112140:	10800003 	ldbu	r2,0(r2)
81112144:	e0bffb05 	stb	r2,-20(fp)
            if ( isdigit( c ) ) {
81112148:	d0e00317 	ldw	r3,-32756(gp)
8111214c:	e0bffb07 	ldb	r2,-20(fp)
81112150:	10800044 	addi	r2,r2,1
81112154:	1885883a 	add	r2,r3,r2
81112158:	10800003 	ldbu	r2,0(r2)
8111215c:	10803fcc 	andi	r2,r2,255
81112160:	1080010c 	andi	r2,r2,4
81112164:	10000626 	beq	r2,zero,81112180 <bPreParserV2+0x1d0>
                (*p_inteiro) = c;
81112168:	e0bff817 	ldw	r2,-32(fp)
8111216c:	e0fffb03 	ldbu	r3,-20(fp)
81112170:	10c00005 	stb	r3,0(r2)
                p_inteiro++;
81112174:	e0bff817 	ldw	r2,-32(fp)
81112178:	10800044 	addi	r2,r2,1
8111217c:	e0bff815 	stw	r2,-32(fp)
            }
            i++;
81112180:	e0bff703 	ldbu	r2,-36(fp)
81112184:	10800044 	addi	r2,r2,1
81112188:	e0bff705 	stb	r2,-36(fp)
        } while ( (siStrLen>i) && ( ( c != SEPARATOR_CHAR ) && ( c != FINAL_CHAR ) && ( c != SEPARATOR_CRC )) ); //ASCII: 58 = ':' 59 = ';' and '|'
8111218c:	e0bff90f 	ldh	r2,-28(fp)
81112190:	e0fff703 	ldbu	r3,-36(fp)
81112194:	1880090e 	bge	r3,r2,811121bc <bPreParserV2+0x20c>
81112198:	e0bffb07 	ldb	r2,-20(fp)
8111219c:	10800ea0 	cmpeqi	r2,r2,58
811121a0:	1000061e 	bne	r2,zero,811121bc <bPreParserV2+0x20c>
811121a4:	e0bffb07 	ldb	r2,-20(fp)
811121a8:	10800ee0 	cmpeqi	r2,r2,59
811121ac:	1000031e 	bne	r2,zero,811121bc <bPreParserV2+0x20c>
811121b0:	e0bffb07 	ldb	r2,-20(fp)
811121b4:	10801f18 	cmpnei	r2,r2,124
811121b8:	103fde1e 	bne	r2,zero,81112134 <__reset+0xfb0f2134>
        (*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811121bc:	e0bff817 	ldw	r2,-32(fp)
811121c0:	00c00284 	movi	r3,10
811121c4:	10c00005 	stb	r3,0(r2)

        if ( ( c == SEPARATOR_CHAR ) || ( c == SEPARATOR_CRC ) ) {
811121c8:	e0bffb07 	ldb	r2,-20(fp)
811121cc:	10800ea0 	cmpeqi	r2,r2,58
811121d0:	1000031e 	bne	r2,zero,811121e0 <bPreParserV2+0x230>
811121d4:	e0bffb07 	ldb	r2,-20(fp)
811121d8:	10801f18 	cmpnei	r2,r2,124
811121dc:	10001a1e 	bne	r2,zero,81112248 <bPreParserV2+0x298>
            xPerParcedBuffer->usiValues[min_sim(xPerParcedBuffer->ucNofBytes,SIZE_UCVALUES)] = (unsigned short int)atoi( inteiro );
811121e0:	e0bffe17 	ldw	r2,-8(fp)
811121e4:	10800183 	ldbu	r2,6(r2)
811121e8:	10803fcc 	andi	r2,r2,255
811121ec:	10800828 	cmpgeui	r2,r2,32
811121f0:	1000041e 	bne	r2,zero,81112204 <bPreParserV2+0x254>
811121f4:	e0bffe17 	ldw	r2,-8(fp)
811121f8:	10800183 	ldbu	r2,6(r2)
811121fc:	14003fcc 	andi	r16,r2,255
81112200:	00000106 	br	81112208 <bPreParserV2+0x258>
81112204:	04000804 	movi	r16,32
81112208:	e0bffb44 	addi	r2,fp,-19
8111220c:	1009883a 	mov	r4,r2
81112210:	111c8bc0 	call	8111c8bc <atoi>
81112214:	1009883a 	mov	r4,r2
81112218:	e0fffe17 	ldw	r3,-8(fp)
8111221c:	80800104 	addi	r2,r16,4
81112220:	1085883a 	add	r2,r2,r2
81112224:	1885883a 	add	r2,r3,r2
81112228:	1100000d 	sth	r4,0(r2)
            xPerParcedBuffer->ucNofBytes++;
8111222c:	e0bffe17 	ldw	r2,-8(fp)
81112230:	10800183 	ldbu	r2,6(r2)
81112234:	10800044 	addi	r2,r2,1
81112238:	1007883a 	mov	r3,r2
8111223c:	e0bffe17 	ldw	r2,-8(fp)
81112240:	10c00185 	stb	r3,6(r2)
81112244:	00000906 	br	8111226c <bPreParserV2+0x2bc>
        }
        else if ( c == FINAL_CHAR )
81112248:	e0bffb07 	ldb	r2,-20(fp)
8111224c:	10800ed8 	cmpnei	r2,r2,59
81112250:	1000061e 	bne	r2,zero,8111226c <bPreParserV2+0x2bc>
        {
            xPerParcedBuffer->ucMessageCRC8 = (unsigned char)atoi( inteiro );
81112254:	e0bffb44 	addi	r2,fp,-19
81112258:	1009883a 	mov	r4,r2
8111225c:	111c8bc0 	call	8111c8bc <atoi>
81112260:	1007883a 	mov	r3,r2
81112264:	e0bffe17 	ldw	r2,-8(fp)
81112268:	10c01245 	stb	r3,73(r2)
        }

    } while ( (c != FINAL_CHAR) && (siStrLen>i) );
8111226c:	e0bffb07 	ldb	r2,-20(fp)
81112270:	10800ee0 	cmpeqi	r2,r2,59
81112274:	1000031e 	bne	r2,zero,81112284 <bPreParserV2+0x2d4>
81112278:	e0bff90f 	ldh	r2,-28(fp)
8111227c:	e0fff703 	ldbu	r3,-36(fp)
81112280:	18bfa516 	blt	r3,r2,81112118 <__reset+0xfb0f2118>


    if ( c == FINAL_CHAR )
81112284:	e0bffb07 	ldb	r2,-20(fp)
81112288:	10800ed8 	cmpnei	r2,r2,59
8111228c:	1000191e 	bne	r2,zero,811122f4 <bPreParserV2+0x344>
        if ( xPerParcedBuffer->ucMessageCRC8 == xPerParcedBuffer->ucCalculatedCRC8 ){
81112290:	e0bffe17 	ldw	r2,-8(fp)
81112294:	10c01243 	ldbu	r3,73(r2)
81112298:	e0bffe17 	ldw	r2,-8(fp)
8111229c:	10801203 	ldbu	r2,72(r2)
811122a0:	18c03fcc 	andi	r3,r3,255
811122a4:	10803fcc 	andi	r2,r2,255
811122a8:	1880031e 	bne	r3,r2,811122b8 <bPreParserV2+0x308>
            bSuccess = TRUE;
811122ac:	00800044 	movi	r2,1
811122b0:	e0bff615 	stw	r2,-40(fp)
811122b4:	00001006 	br	811122f8 <bPreParserV2+0x348>
        } else {
            /* Wrong CRC */
            #ifdef DEBUG_ON
                fprintf(fp,"Wrong CRC. Expected = %hhu, received = %hhu\n", xPerParcedBuffer->ucCalculatedCRC8, xPerParcedBuffer->ucMessageCRC8 );
811122b8:	d0e05e17 	ldw	r3,-32392(gp)
811122bc:	e0bffe17 	ldw	r2,-8(fp)
811122c0:	10801203 	ldbu	r2,72(r2)
811122c4:	11003fcc 	andi	r4,r2,255
811122c8:	e0bffe17 	ldw	r2,-8(fp)
811122cc:	10801243 	ldbu	r2,73(r2)
811122d0:	10803fcc 	andi	r2,r2,255
811122d4:	100f883a 	mov	r7,r2
811122d8:	200d883a 	mov	r6,r4
811122dc:	01604574 	movhi	r5,33045
811122e0:	2965c904 	addi	r5,r5,-26844
811122e4:	1809883a 	mov	r4,r3
811122e8:	111ca180 	call	8111ca18 <fprintf>
            #endif
            bSuccess = FALSE;
811122ec:	e03ff615 	stw	zero,-40(fp)
811122f0:	00000106 	br	811122f8 <bPreParserV2+0x348>
        }
    else
        bSuccess = FALSE; /* Index overflow in the buffer */
811122f4:	e03ff615 	stw	zero,-40(fp)


    return bSuccess;
811122f8:	e0bff617 	ldw	r2,-40(fp)
}
811122fc:	e6ffff04 	addi	sp,fp,-4
81112300:	dfc00217 	ldw	ra,8(sp)
81112304:	df000117 	ldw	fp,4(sp)
81112308:	dc000017 	ldw	r16,0(sp)
8111230c:	dec00304 	addi	sp,sp,12
81112310:	f800283a 	ret

81112314 <vSenderComTask>:


OS_STK_DATA *pdata;

void vSenderComTask(void *task_data)
{
81112314:	defffb04 	addi	sp,sp,-20
81112318:	de00012e 	bgeu	sp,et,81112320 <vSenderComTask+0xc>
8111231c:	003b68fa 	trap	3
81112320:	dfc00415 	stw	ra,16(sp)
81112324:	df000315 	stw	fp,12(sp)
81112328:	df000304 	addi	fp,sp,12
8111232c:	e13fff15 	stw	r4,-4(fp)
    tSenderStates eSenderMode;
    bool bSuccess;

    eSenderMode = sConfiguringSender;
81112330:	e03ffd15 	stw	zero,-12(fp)

    #ifdef DEBUG_ON
        debug(fp,"Sender Comm Task. (Task on)\n");
81112334:	d0a05e17 	ldw	r2,-32392(gp)
81112338:	100f883a 	mov	r7,r2
8111233c:	01800704 	movi	r6,28
81112340:	01400044 	movi	r5,1
81112344:	01204574 	movhi	r4,33045
81112348:	2125d504 	addi	r4,r4,-26796
8111234c:	111d0b40 	call	8111d0b4 <fwrite>
    #endif

    for (;;){
        
        switch (eSenderMode)
81112350:	e0bffd17 	ldw	r2,-12(fp)
81112354:	10c00060 	cmpeqi	r3,r2,1
81112358:	1800091e 	bne	r3,zero,81112380 <vSenderComTask+0x6c>
8111235c:	0080052e 	bgeu	zero,r2,81112374 <vSenderComTask+0x60>
81112360:	10c000a0 	cmpeqi	r3,r2,2
81112364:	1800471e 	bne	r3,zero,81112484 <vSenderComTask+0x170>
81112368:	10800160 	cmpeqi	r2,r2,5
8111236c:	10002c1e 	bne	r2,zero,81112420 <vSenderComTask+0x10c>
81112370:	00003a06 	br	8111245c <vSenderComTask+0x148>
        {
            case sConfiguringSender:
                /* For future implementations. */
                eSenderMode = sStartingConnSender;
81112374:	00800044 	movi	r2,1
81112378:	e0bffd15 	stw	r2,-12(fp)
                break;
8111237c:	00004206 	br	81112488 <vSenderComTask+0x174>
                /*  This semaphore will return a non-zero value if the NUC communicate with the MEB 
                    vReceiverComTask is responsible to send this semaphore.
                    OSSemAccept -> Non blocking Pend*/

                #ifdef DEBUG_ON
                    debug(fp,"Preparing the Start Sequence.\n");
81112380:	d0a05e17 	ldw	r2,-32392(gp)
81112384:	100f883a 	mov	r7,r2
81112388:	01800784 	movi	r6,30
8111238c:	01400044 	movi	r5,1
81112390:	01204574 	movhi	r4,33045
81112394:	2125dd04 	addi	r4,r4,-26764
81112398:	111d0b40 	call	8111d0b4 <fwrite>
                #endif

                /* id of the first message will be 1 */
                bSuccess = bSendUART32v2(START_STATUS_SEQUENCE, 1);
8111239c:	01400044 	movi	r5,1
811123a0:	01204574 	movhi	r4,33045
811123a4:	2125e504 	addi	r4,r4,-26732
811123a8:	1115d980 	call	81115d98 <bSendUART32v2>
811123ac:	e0bffe15 	stw	r2,-8(fp)
                if ( bSuccess == TRUE ) {
811123b0:	e0bffe17 	ldw	r2,-8(fp)
811123b4:	10800058 	cmpnei	r2,r2,1
811123b8:	10000a1e 	bne	r2,zero,811123e4 <vSenderComTask+0xd0>
                    eSenderMode = sDummySender;
811123bc:	00800144 	movi	r2,5
811123c0:	e0bffd15 	stw	r2,-12(fp)
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
811123c4:	d0a05e17 	ldw	r2,-32392(gp)
811123c8:	100f883a 	mov	r7,r2
811123cc:	01800d44 	movi	r6,53
811123d0:	01400044 	movi	r5,1
811123d4:	01204574 	movhi	r4,33045
811123d8:	2125e804 	addi	r4,r4,-26720
811123dc:	111d0b40 	call	8111d0b4 <fwrite>
                        debug(fp,"Fail, try again in 5 seconds.\n");
                    #endif 
                    eSenderMode = sStartingConnSender;
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
                }
                break;
811123e0:	00002906 	br	81112488 <vSenderComTask+0x174>
                    #ifdef DEBUG_ON
                        debug(fp,"Success, start message in the retransmission buffer.\n");
                    #endif                    
                } else {
                    #ifdef DEBUG_ON
                        debug(fp,"Fail, try again in 5 seconds.\n");
811123e4:	d0a05e17 	ldw	r2,-32392(gp)
811123e8:	100f883a 	mov	r7,r2
811123ec:	01800784 	movi	r6,30
811123f0:	01400044 	movi	r5,1
811123f4:	01204574 	movhi	r4,33045
811123f8:	2125f604 	addi	r4,r4,-26664
811123fc:	111d0b40 	call	8111d0b4 <fwrite>
                    #endif 
                    eSenderMode = sStartingConnSender;
81112400:	00800044 	movi	r2,1
81112404:	e0bffd15 	stw	r2,-12(fp)
                    OSTimeDlyHMSM(0, 0, 5, 0); /*Sleeps for 5 second*/
81112408:	000f883a 	mov	r7,zero
8111240c:	01800144 	movi	r6,5
81112410:	000b883a 	mov	r5,zero
81112414:	0009883a 	mov	r4,zero
81112418:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
                }
                break;
8111241c:	00001a06 	br	81112488 <vSenderComTask+0x174>
                

                break;
            case sDummySender:
                /* code */
                eSenderMode = sDummySender;
81112420:	00800144 	movi	r2,5
81112424:	e0bffd15 	stw	r2,-12(fp)

                #ifdef DEBUG_ON
                    debug(fp,"Working...\n");
81112428:	d0a05e17 	ldw	r2,-32392(gp)
8111242c:	100f883a 	mov	r7,r2
81112430:	018002c4 	movi	r6,11
81112434:	01400044 	movi	r5,1
81112438:	01204574 	movhi	r4,33045
8111243c:	2125fe04 	addi	r4,r4,-26632
81112440:	111d0b40 	call	8111d0b4 <fwrite>
                #endif

				OSTimeDlyHMSM(0, 0, 25, 0); /*Sleeps for 3 second*/
81112444:	000f883a 	mov	r7,zero
81112448:	01800644 	movi	r6,25
8111244c:	000b883a 	mov	r5,zero
81112450:	0009883a 	mov	r4,zero
81112454:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>

                break;
81112458:	00000b06 	br	81112488 <vSenderComTask+0x174>
            default:
                #ifdef DEBUG_ON
                    debug(fp,"Sender default\n");
8111245c:	d0a05e17 	ldw	r2,-32392(gp)
81112460:	100f883a 	mov	r7,r2
81112464:	018003c4 	movi	r6,15
81112468:	01400044 	movi	r5,1
8111246c:	01204574 	movhi	r4,33045
81112470:	21260104 	addi	r4,r4,-26620
81112474:	111d0b40 	call	8111d0b4 <fwrite>
                #endif
                eSenderMode = sDummySender;
81112478:	00800144 	movi	r2,5
8111247c:	e0bffd15 	stw	r2,-12(fp)
                break;
81112480:	00000106 	br	81112488 <vSenderComTask+0x174>

                //pPointer = OSQPend(xQSenderTask, 0, &error_code);

                

                break;
81112484:	0001883a 	nop
                #endif
                eSenderMode = sDummySender;
                break;
        }

    }
81112488:	003fb106 	br	81112350 <__reset+0xfb0f2350>

8111248c <vSimMebTask>:

#include "sim_meb_task.h"

/* All commands should pass through the MEB, it is the instance that hould know everything, and also know the self state and what is allowed to be performed or not */

void vSimMebTask(void *task_data) {
8111248c:	defffa04 	addi	sp,sp,-24
81112490:	de00012e 	bgeu	sp,et,81112498 <vSimMebTask+0xc>
81112494:	003b68fa 	trap	3
81112498:	dfc00515 	stw	ra,20(sp)
8111249c:	df000415 	stw	fp,16(sp)
811124a0:	df000404 	addi	fp,sp,16
811124a4:	e13fff15 	stw	r4,-4(fp)
	TSimucam_MEB *pxMebC;
	tQMask uiCmdMeb;
	INT8U error_code;

	pxMebC = (TSimucam_MEB *) task_data;
811124a8:	e0bfff17 	ldw	r2,-4(fp)
811124ac:	e0bffc15 	stw	r2,-16(fp)

	#ifdef DEBUG_ON
        debug(fp,"Sim-Meb Controller Task. (Task on)\n");
811124b0:	d0a05e17 	ldw	r2,-32392(gp)
811124b4:	100f883a 	mov	r7,r2
811124b8:	018008c4 	movi	r6,35
811124bc:	01400044 	movi	r5,1
811124c0:	01204574 	movhi	r4,33045
811124c4:	21260504 	addi	r4,r4,-26604
811124c8:	111d0b40 	call	8111d0b4 <fwrite>
    #endif


	for (;;) {
		switch ( pxMebC->eMode ) {
811124cc:	e0bffc17 	ldw	r2,-16(fp)
811124d0:	10800117 	ldw	r2,4(r2)
811124d4:	10c00168 	cmpgeui	r3,r2,5
811124d8:	1800ac1e 	bne	r3,zero,8111278c <vSimMebTask+0x300>
811124dc:	100690ba 	slli	r3,r2,2
811124e0:	00a04474 	movhi	r2,33041
811124e4:	10893d04 	addi	r2,r2,9460
811124e8:	1885883a 	add	r2,r3,r2
811124ec:	10800017 	ldw	r2,0(r2)
811124f0:	1000683a 	jmp	r2
811124f4:	81112508 	cmpgei	r4,r16,17556
811124f8:	81112520 	cmpeqi	r4,r16,17556
811124fc:	811125a0 	cmpeqi	r4,r16,17558
81112500:	81112618 	cmpnei	r4,r16,17560
81112504:	811126f0 	cmpltui	r4,r16,17563
			case sMebInit:
				/* Turn on Meb */
				vMebInit( pxMebC );
81112508:	e13ffc17 	ldw	r4,-16(fp)
8111250c:	11135300 	call	81113530 <vMebInit>
				pxMebC->eMode = sMebToConfig;
81112510:	e0bffc17 	ldw	r2,-16(fp)
81112514:	00c00044 	movi	r3,1
81112518:	10c00115 	stw	r3,4(r2)
				break;
8111251c:	0000a606 	br	811127b8 <vSimMebTask+0x32c>


			case sMebToConfig:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Config Mode\n");
81112520:	d0a05e17 	ldw	r2,-32392(gp)
81112524:	100f883a 	mov	r7,r2
81112528:	01800584 	movi	r6,22
8111252c:	01400044 	movi	r5,1
81112530:	01204574 	movhi	r4,33045
81112534:	21260e04 	addi	r4,r4,-26568
81112538:	111d0b40 	call	8111d0b4 <fwrite>
				#endif

				/* Stop the Sync (Stopping the simulation) */
				bStopSync();
8111253c:	111aec00 	call	8111aec0 <bStopSync>
				vSyncClearCounter();
81112540:	110bb180 	call	8110bb18 <vSyncClearCounter>

				/* If any Task is locked waiting Sync, should be released */
				vReleaseSyncMessages();
81112544:	11136a00 	call	811136a0 <vReleaseSyncMessages>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 10);
81112548:	01c00284 	movi	r7,10
8111254c:	000d883a 	mov	r6,zero
81112550:	000b883a 	mov	r5,zero
81112554:	0009883a 	mov	r4,zero
81112558:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>

				/* Transition to Config Mode (Ending the simulation) */
				/* Send a message to the NFEE Controller forcing the mode */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_CONFIG_FORCED, 0, 0 );
8111255c:	000d883a 	mov	r6,zero
81112560:	000b883a 	mov	r5,zero
81112564:	01002844 	movi	r4,161
81112568:	11133040 	call	81113304 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_CONFIG_FORCED, 0, 0 );
8111256c:	000d883a 	mov	r6,zero
81112570:	000b883a 	mov	r5,zero
81112574:	01002844 	movi	r4,161
81112578:	11134a80 	call	811134a8 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, 250);
8111257c:	01c03e84 	movi	r7,250
81112580:	000d883a 	mov	r6,zero
81112584:	000b883a 	mov	r5,zero
81112588:	0009883a 	mov	r4,zero
8111258c:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>

				pxMebC->eMode = sMebConfig;
81112590:	e0bffc17 	ldw	r2,-16(fp)
81112594:	00c000c4 	movi	r3,3
81112598:	10c00115 	stw	r3,4(r2)
				break;
8111259c:	00008606 	br	811127b8 <vSimMebTask+0x32c>


			case sMebToRun:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Run Mode\n");
811125a0:	d0a05e17 	ldw	r2,-32392(gp)
811125a4:	100f883a 	mov	r7,r2
811125a8:	018004c4 	movi	r6,19
811125ac:	01400044 	movi	r5,1
811125b0:	01204574 	movhi	r4,33045
811125b4:	21261404 	addi	r4,r4,-26544
811125b8:	111d0b40 	call	8111d0b4 <fwrite>
				#endif
				/* Transition to Run Mode (Starting the Simulation) */
				vSendCmdQToNFeeCTRL_PRIO( M_NFC_RUN_FORCED, 0, 0 );
811125bc:	000d883a 	mov	r6,zero
811125c0:	000b883a 	mov	r5,zero
811125c4:	01002884 	movi	r4,162
811125c8:	11133040 	call	81113304 <vSendCmdQToNFeeCTRL_PRIO>
				vSendCmdQToDataCTRL_PRIO( M_DATA_RUN_FORCED, 0, 0 );
811125cc:	000d883a 	mov	r6,zero
811125d0:	000b883a 	mov	r5,zero
811125d4:	01002884 	movi	r4,162
811125d8:	11134a80 	call	811134a8 <vSendCmdQToDataCTRL_PRIO>

				/* Give time to all tasks receive the command */
				OSTimeDlyHMSM(0, 0, 0, pxMebC->usiDelaySyncReset);
811125dc:	e0bffc17 	ldw	r2,-16(fp)
811125e0:	1080050b 	ldhu	r2,20(r2)
811125e4:	10bfffcc 	andi	r2,r2,65535
811125e8:	100f883a 	mov	r7,r2
811125ec:	000d883a 	mov	r6,zero
811125f0:	000b883a 	mov	r5,zero
811125f4:	0009883a 	mov	r4,zero
811125f8:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
				vSyncClearCounter();
811125fc:	110bb180 	call	8110bb18 <vSyncClearCounter>
				bStartSync();
81112600:	111ae880 	call	8111ae88 <bStartSync>

				vEvtChangeMebMode();
81112604:	111995c0 	call	8111995c <vEvtChangeMebMode>
				pxMebC->eMode = sMebRun;
81112608:	e0bffc17 	ldw	r2,-16(fp)
8111260c:	00c00104 	movi	r3,4
81112610:	10c00115 	stw	r3,4(r2)
				break;
81112614:	00006806 	br	811127b8 <vSimMebTask+0x32c>


			case sMebConfig:

				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
81112618:	d0a06517 	ldw	r2,-32364(gp)
8111261c:	e0fffe04 	addi	r3,fp,-8
81112620:	180d883a 	mov	r6,r3
81112624:	000b883a 	mov	r5,zero
81112628:	1009883a 	mov	r4,r2
8111262c:	1139bfc0 	call	81139bfc <OSQPend>
81112630:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
81112634:	e0bffe03 	ldbu	r2,-8(fp)
81112638:	10803fcc 	andi	r2,r2,255
8111263c:	1000291e 	bne	r2,zero,811126e4 <vSimMebTask+0x258>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81112640:	e0bffdc3 	ldbu	r2,-9(fp)
81112644:	10803fcc 	andi	r2,r2,255
81112648:	10800058 	cmpnei	r2,r2,1
8111264c:	10001c1e 	bne	r2,zero,811126c0 <vSimMebTask+0x234>
						/* Parse the cmd that comes in the Queue */
						switch ( uiCmdMeb.ucByte[2] ) {
81112650:	e0bffd83 	ldbu	r2,-10(fp)
81112654:	10803fcc 	andi	r2,r2,255
81112658:	10c00060 	cmpeqi	r3,r2,1
8111265c:	1800031e 	bne	r3,zero,8111266c <vSimMebTask+0x1e0>
81112660:	10803820 	cmpeqi	r2,r2,224
81112664:	1000041e 	bne	r2,zero,81112678 <vSimMebTask+0x1ec>
81112668:	00000b06 	br	81112698 <vSimMebTask+0x20c>
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
8111266c:	e13ffc17 	ldw	r4,-16(fp)
81112670:	11127bc0 	call	811127bc <vPusMebTask>
								break;
81112674:	00001d06 	br	811126ec <vSimMebTask+0x260>
							case M_MASTER_SYNC:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: WARNING Should not have sync in Meb Config Mode (Check it please)");
81112678:	d0a05e17 	ldw	r2,-32392(gp)
8111267c:	100f883a 	mov	r7,r2
81112680:	018012c4 	movi	r6,75
81112684:	01400044 	movi	r5,1
81112688:	01204574 	movhi	r4,33045
8111268c:	21261904 	addi	r4,r4,-26524
81112690:	111d0b40 	call	8111d0b4 <fwrite>
								#endif
								break;
81112694:	00001506 	br	811126ec <vSimMebTask+0x260>
							default:
								#ifdef DEBUG_ON
									fprintf(fp,"MEB Task: Unknown command for the Config Mode (Queue xMebQ, cmd= %hhu)\n", uiCmdMeb.ucByte[2]);
81112698:	d0a05e17 	ldw	r2,-32392(gp)
8111269c:	e0fffd83 	ldbu	r3,-10(fp)
811126a0:	18c03fcc 	andi	r3,r3,255
811126a4:	180d883a 	mov	r6,r3
811126a8:	01604574 	movhi	r5,33045
811126ac:	29662c04 	addi	r5,r5,-26448
811126b0:	1009883a 	mov	r4,r2
811126b4:	111ca180 	call	8111ca18 <fprintf>
								#endif
								break;
811126b8:	0001883a 	nop
811126bc:	00000b06 	br	811126ec <vSimMebTask+0x260>
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
811126c0:	d0a05e17 	ldw	r2,-32392(gp)
811126c4:	e0fffdc3 	ldbu	r3,-9(fp)
811126c8:	18c03fcc 	andi	r3,r3,255
811126cc:	180d883a 	mov	r6,r3
811126d0:	01604574 	movhi	r5,33045
811126d4:	29663e04 	addi	r5,r5,-26376
811126d8:	1009883a 	mov	r4,r2
811126dc:	111ca180 	call	8111ca18 <fprintf>
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}

				break;
811126e0:	00003506 	br	811127b8 <vSimMebTask+0x32c>
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
						#endif
					}
				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
811126e4:	11192fc0 	call	811192fc <vCouldNotGetCmdQueueMeb>
				}

				break;
811126e8:	00003306 	br	811127b8 <vSimMebTask+0x32c>
811126ec:	00003206 	br	811127b8 <vSimMebTask+0x32c>

			case sMebRun:
				uiCmdMeb.ulWord = (unsigned int)OSQPend(xMebQ, 0, &error_code); /* Blocking operation */
811126f0:	d0a06517 	ldw	r2,-32364(gp)
811126f4:	e0fffe04 	addi	r3,fp,-8
811126f8:	180d883a 	mov	r6,r3
811126fc:	000b883a 	mov	r5,zero
81112700:	1009883a 	mov	r4,r2
81112704:	1139bfc0 	call	81139bfc <OSQPend>
81112708:	e0bffd15 	stw	r2,-12(fp)
				if ( error_code == OS_ERR_NONE ) {
8111270c:	e0bffe03 	ldbu	r2,-8(fp)
81112710:	10803fcc 	andi	r2,r2,255
81112714:	10001a1e 	bne	r2,zero,81112780 <vSimMebTask+0x2f4>

					/* Check if the command is for MEB */
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
81112718:	e0bffdc3 	ldbu	r2,-9(fp)
8111271c:	10803fcc 	andi	r2,r2,255
81112720:	10800058 	cmpnei	r2,r2,1
81112724:	10000d1e 	bne	r2,zero,8111275c <vSimMebTask+0x2d0>
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
81112728:	e0bffd83 	ldbu	r2,-10(fp)
8111272c:	10803fcc 	andi	r2,r2,255
81112730:	10c00060 	cmpeqi	r3,r2,1
81112734:	1800031e 	bne	r3,zero,81112744 <vSimMebTask+0x2b8>
81112738:	10803820 	cmpeqi	r2,r2,224
8111273c:	1000041e 	bne	r2,zero,81112750 <vSimMebTask+0x2c4>
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);

								break;
							default:
								break;
81112740:	00001106 	br	81112788 <vSimMebTask+0x2fc>
					if ( uiCmdMeb.ucByte[3] == M_MEB_ADDR ) {
						/* Parse the cmd that comes in the Queue */
						switch (uiCmdMeb.ucByte[2]) {
							/* Receive a PUS command */
							case Q_MEB_PUS:
								vPusMebTask( pxMebC );
81112744:	e13ffc17 	ldw	r4,-16(fp)
81112748:	11127bc0 	call	811127bc <vPusMebTask>
								break;
8111274c:	00000e06 	br	81112788 <vSimMebTask+0x2fc>
							case M_MASTER_SYNC:
								/* Perform memory SWAP */
								vSwapMemmory(pxMebC);
81112750:	e13ffc17 	ldw	r4,-16(fp)
81112754:	11135940 	call	81113594 <vSwapMemmory>

								break;
81112758:	00000b06 	br	81112788 <vSimMebTask+0x2fc>
							default:
								break;
						}
					} else {
						#ifdef DEBUG_ON
							fprintf(fp,"MEB Task: Command Ignored wrong address (ADDR= %hhu)\n", uiCmdMeb.ucByte[3]);
8111275c:	d0a05e17 	ldw	r2,-32392(gp)
81112760:	e0fffdc3 	ldbu	r3,-9(fp)
81112764:	18c03fcc 	andi	r3,r3,255
81112768:	180d883a 	mov	r6,r3
8111276c:	01604574 	movhi	r5,33045
81112770:	29663e04 	addi	r5,r5,-26376
81112774:	1009883a 	mov	r4,r2
81112778:	111ca180 	call	8111ca18 <fprintf>

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
				}			
				break;
8111277c:	00000e06 	br	811127b8 <vSimMebTask+0x32c>
						#endif
					}

				} else {
					/* Should never get here (blocking operation), critical fail */
					vCouldNotGetCmdQueueMeb();
81112780:	11192fc0 	call	811192fc <vCouldNotGetCmdQueueMeb>
				}			
				break;
81112784:	00000c06 	br	811127b8 <vSimMebTask+0x32c>
81112788:	00000b06 	br	811127b8 <vSimMebTask+0x32c>

			default:
				#ifdef DEBUG_ON
					debug(fp,"MEB Task: Unknow state, backing to Config Mode\n");
8111278c:	d0a05e17 	ldw	r2,-32392(gp)
81112790:	100f883a 	mov	r7,r2
81112794:	01800bc4 	movi	r6,47
81112798:	01400044 	movi	r5,1
8111279c:	01204574 	movhi	r4,33045
811127a0:	21264c04 	addi	r4,r4,-26320
811127a4:	111d0b40 	call	8111d0b4 <fwrite>
				#endif
				
				/* todo:Aplicar toda logica de mudana de esteado aqui */
				pxMebC->eMode = sMebToConfig;
811127a8:	e0bffc17 	ldw	r2,-16(fp)
811127ac:	00c00044 	movi	r3,1
811127b0:	10c00115 	stw	r3,4(r2)
				break;
811127b4:	0001883a 	nop
		}
	}
811127b8:	003f4406 	br	811124cc <__reset+0xfb0f24cc>

811127bc <vPusMebTask>:
}

void vPusMebTask( TSimucam_MEB *pxMebCLocal ) {
811127bc:	defffb04 	addi	sp,sp,-20
811127c0:	de00012e 	bgeu	sp,et,811127c8 <vPusMebTask+0xc>
811127c4:	003b68fa 	trap	3
811127c8:	dfc00415 	stw	ra,16(sp)
811127cc:	df000315 	stw	fp,12(sp)
811127d0:	df000304 	addi	fp,sp,12
811127d4:	e13fff15 	stw	r4,-4(fp)
	bool bSuccess;
	INT8U error_code;
	unsigned char ucIL;
	static tTMPus xPusLocal;

	bSuccess = FALSE;
811127d8:	e03ffd15 	stw	zero,-12(fp)
	OSMutexPend(xMutexPus, 2, &error_code);
811127dc:	d0a06f17 	ldw	r2,-32324(gp)
811127e0:	e0fffe44 	addi	r3,fp,-7
811127e4:	180d883a 	mov	r6,r3
811127e8:	01400084 	movi	r5,2
811127ec:	1009883a 	mov	r4,r2
811127f0:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( error_code == OS_ERR_NONE ) {
811127f4:	e0bffe43 	ldbu	r2,-7(fp)
811127f8:	10803fcc 	andi	r2,r2,255
811127fc:	10002c1e 	bne	r2,zero,811128b0 <vPusMebTask+0xf4>

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81112800:	e03ffe05 	stb	zero,-8(fp)
81112804:	00002306 	br	81112894 <vPusMebTask+0xd8>
	    {
            if ( xPus[ucIL].bInUse == TRUE ) {
81112808:	e0fffe03 	ldbu	r3,-8(fp)
8111280c:	00a04574 	movhi	r2,33045
81112810:	1085a904 	addi	r2,r2,5796
81112814:	18c01524 	muli	r3,r3,84
81112818:	10c5883a 	add	r2,r2,r3
8111281c:	10800104 	addi	r2,r2,4
81112820:	10800017 	ldw	r2,0(r2)
81112824:	10800058 	cmpnei	r2,r2,1
81112828:	1000171e 	bne	r2,zero,81112888 <vPusMebTask+0xcc>
                /* Need to check if the performance is the same as memcpy*/
            	xPusLocal = xPus[ucIL];
8111282c:	e13ffe03 	ldbu	r4,-8(fp)
81112830:	00e04574 	movhi	r3,33045
81112834:	18fb6c04 	addi	r3,r3,-4688
81112838:	00a04574 	movhi	r2,33045
8111283c:	1085a904 	addi	r2,r2,5796
81112840:	21001524 	muli	r4,r4,84
81112844:	1105883a 	add	r2,r2,r4
81112848:	1009883a 	mov	r4,r2
8111284c:	00801504 	movi	r2,84
81112850:	100d883a 	mov	r6,r2
81112854:	200b883a 	mov	r5,r4
81112858:	1809883a 	mov	r4,r3
8111285c:	111dac80 	call	8111dac8 <memcpy>
            	xPus[ucIL].bInUse = FALSE;
81112860:	e0fffe03 	ldbu	r3,-8(fp)
81112864:	00a04574 	movhi	r2,33045
81112868:	1085a904 	addi	r2,r2,5796
8111286c:	18c01524 	muli	r3,r3,84
81112870:	10c5883a 	add	r2,r2,r3
81112874:	10800104 	addi	r2,r2,4
81112878:	10000015 	stw	zero,0(r2)
            	bSuccess = TRUE;
8111287c:	00800044 	movi	r2,1
81112880:	e0bffd15 	stw	r2,-12(fp)
                break;
81112884:	00000606 	br	811128a0 <vPusMebTask+0xe4>
	bSuccess = FALSE;
	OSMutexPend(xMutexPus, 2, &error_code);
	if ( error_code == OS_ERR_NONE ) {

	    /*Search for the PUS command*/
	    for(ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81112888:	e0bffe03 	ldbu	r2,-8(fp)
8111288c:	10800044 	addi	r2,r2,1
81112890:	e0bffe05 	stb	r2,-8(fp)
81112894:	e0bffe03 	ldbu	r2,-8(fp)
81112898:	10800130 	cmpltui	r2,r2,4
8111289c:	103fda1e 	bne	r2,zero,81112808 <__reset+0xfb0f2808>
            	xPus[ucIL].bInUse = FALSE;
            	bSuccess = TRUE;
                break;
            }
	    }
	    OSMutexPost(xMutexPus);
811128a0:	d0a06f17 	ldw	r2,-32324(gp)
811128a4:	1009883a 	mov	r4,r2
811128a8:	113908c0 	call	8113908c <OSMutexPost>
811128ac:	00000106 	br	811128b4 <vPusMebTask+0xf8>
	} else {
		vCouldNotGetMutexMebPus();
811128b0:	11193640 	call	81119364 <vCouldNotGetMutexMebPus>
	}

	if ( bSuccess ) {
811128b4:	e0bffd17 	ldw	r2,-12(fp)
811128b8:	10001126 	beq	r2,zero,81112900 <vPusMebTask+0x144>

		switch (pxMebCLocal->eMode) {
811128bc:	e0bfff17 	ldw	r2,-4(fp)
811128c0:	10800117 	ldw	r2,4(r2)
811128c4:	10c000e0 	cmpeqi	r3,r2,3
811128c8:	1800031e 	bne	r3,zero,811128d8 <vPusMebTask+0x11c>
811128cc:	10800120 	cmpeqi	r2,r2,4
811128d0:	1000061e 	bne	r2,zero,811128ec <vPusMebTask+0x130>
				break;
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
				break;
			default:
				break;
811128d4:	00000a06 	br	81112900 <vPusMebTask+0x144>

	if ( bSuccess ) {

		switch (pxMebCLocal->eMode) {
			case sMebConfig:
				vPusMebInTaskConfigMode(pxMebCLocal, &xPusLocal);
811128d8:	01604574 	movhi	r5,33045
811128dc:	297b6c04 	addi	r5,r5,-4688
811128e0:	e13fff17 	ldw	r4,-4(fp)
811128e4:	11129180 	call	81112918 <vPusMebInTaskConfigMode>
				break;
811128e8:	00000506 	br	81112900 <vPusMebTask+0x144>
			case sMebRun:
				vPusMebInTaskRunningMode(pxMebCLocal, &xPusLocal);
811128ec:	01604574 	movhi	r5,33045
811128f0:	297b6c04 	addi	r5,r5,-4688
811128f4:	e13fff17 	ldw	r4,-4(fp)
811128f8:	1112ca80 	call	81112ca8 <vPusMebInTaskRunningMode>
				break;
811128fc:	0001883a 	nop
			default:
				break;
		}
	}
}
81112900:	0001883a 	nop
81112904:	e037883a 	mov	sp,fp
81112908:	dfc00117 	ldw	ra,4(sp)
8111290c:	df000017 	ldw	fp,0(sp)
81112910:	dec00204 	addi	sp,sp,8
81112914:	f800283a 	ret

81112918 <vPusMebInTaskConfigMode>:


/* This function should treat the PUS command in the Config Mode, need check all the things that is possible to update in this mode */
/* In the Config Mode the MEb takes control and change all values freely */
void vPusMebInTaskConfigMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112918:	defffc04 	addi	sp,sp,-16
8111291c:	de00012e 	bgeu	sp,et,81112924 <vPusMebInTaskConfigMode+0xc>
81112920:	003b68fa 	trap	3
81112924:	dfc00315 	stw	ra,12(sp)
81112928:	df000215 	stw	fp,8(sp)
8111292c:	df000204 	addi	fp,sp,8
81112930:	e13ffe15 	stw	r4,-8(fp)
81112934:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81112938:	e0bfff17 	ldw	r2,-4(fp)
8111293c:	1080030b 	ldhu	r2,12(r2)
81112940:	10bfffcc 	andi	r2,r2,65535
81112944:	10c03ee0 	cmpeqi	r3,r2,251
81112948:	1800081e 	bne	r3,zero,8111296c <vPusMebInTaskConfigMode+0x54>
8111294c:	10c03f20 	cmpeqi	r3,r2,252
81112950:	18000a1e 	bne	r3,zero,8111297c <vPusMebInTaskConfigMode+0x64>
81112954:	10803ea0 	cmpeqi	r2,r2,250
81112958:	10000c26 	beq	r2,zero,8111298c <vPusMebInTaskConfigMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250conf(pxMebCLocal, xPusL);
8111295c:	e17fff17 	ldw	r5,-4(fp)
81112960:	e13ffe17 	ldw	r4,-8(fp)
81112964:	11129c40 	call	811129c4 <vPusType250conf>
			break;
81112968:	00001006 	br	811129ac <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251conf(pxMebCLocal, xPusL);
8111296c:	e17fff17 	ldw	r5,-4(fp)
81112970:	e13ffe17 	ldw	r4,-8(fp)
81112974:	1112a500 	call	81112a50 <vPusType251conf>
			break;
81112978:	00000c06 	br	811129ac <vPusMebInTaskConfigMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252conf(pxMebCLocal, xPusL);
8111297c:	e17fff17 	ldw	r5,-4(fp)
81112980:	e13ffe17 	ldw	r4,-8(fp)
81112984:	1112aa40 	call	81112aa4 <vPusType252conf>
			break;
81112988:	00000806 	br	811129ac <vPusMebInTaskConfigMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (CONFIG)\n\n" );
8111298c:	d0a05e17 	ldw	r2,-32392(gp)
81112990:	100f883a 	mov	r7,r2
81112994:	01800d84 	movi	r6,54
81112998:	01400044 	movi	r5,1
8111299c:	01204574 	movhi	r4,33045
811129a0:	21265804 	addi	r4,r4,-26272
811129a4:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
811129a8:	0001883a 	nop
	}
}
811129ac:	0001883a 	nop
811129b0:	e037883a 	mov	sp,fp
811129b4:	dfc00117 	ldw	ra,4(sp)
811129b8:	df000017 	ldw	fp,0(sp)
811129bc:	dec00204 	addi	sp,sp,8
811129c0:	f800283a 	ret

811129c4 <vPusType250conf>:

void vPusType250conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
811129c4:	defffc04 	addi	sp,sp,-16
811129c8:	de00012e 	bgeu	sp,et,811129d0 <vPusType250conf+0xc>
811129cc:	003b68fa 	trap	3
811129d0:	dfc00315 	stw	ra,12(sp)
811129d4:	df000215 	stw	fp,8(sp)
811129d8:	df000204 	addi	fp,sp,8
811129dc:	e13ffe15 	stw	r4,-8(fp)
811129e0:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
811129e4:	e0bfff17 	ldw	r2,-4(fp)
811129e8:	1080038b 	ldhu	r2,14(r2)
811129ec:	10bfffcc 	andi	r2,r2,65535
811129f0:	10c00f60 	cmpeqi	r3,r2,61
811129f4:	1800031e 	bne	r3,zero,81112a04 <vPusType250conf+0x40>
811129f8:	10800fa0 	cmpeqi	r2,r2,62
811129fc:	10000d1e 	bne	r2,zero,81112a34 <vPusType250conf+0x70>
81112a00:	00000406 	br	81112a14 <vPusType250conf+0x50>
		/* TC_SCAM_RUN */
		case 61:
			pxMebCLocal->eMode = sMebToRun;
81112a04:	e0bffe17 	ldw	r2,-8(fp)
81112a08:	00c00084 	movi	r3,2
81112a0c:	10c00115 	stw	r3,4(r2)
			break;
81112a10:	00000906 	br	81112a38 <vPusType250conf+0x74>
			break;
		/* TC_SCAM_CONFIG */
		case 60:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81112a14:	d0a05e17 	ldw	r2,-32392(gp)
81112a18:	100f883a 	mov	r7,r2
81112a1c:	01800b04 	movi	r6,44
81112a20:	01400044 	movi	r5,1
81112a24:	01204574 	movhi	r4,33045
81112a28:	21266604 	addi	r4,r4,-26216
81112a2c:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
81112a30:	00000106 	br	81112a38 <vPusType250conf+0x74>
			pxMebCLocal->eMode = sMebToRun;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81112a34:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
			#endif
			break;
	}
}
81112a38:	0001883a 	nop
81112a3c:	e037883a 	mov	sp,fp
81112a40:	dfc00117 	ldw	ra,4(sp)
81112a44:	df000017 	ldw	fp,0(sp)
81112a48:	dec00204 	addi	sp,sp,8
81112a4c:	f800283a 	ret

81112a50 <vPusType251conf>:

void vPusType251conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112a50:	defffc04 	addi	sp,sp,-16
81112a54:	de00012e 	bgeu	sp,et,81112a5c <vPusType251conf+0xc>
81112a58:	003b68fa 	trap	3
81112a5c:	dfc00315 	stw	ra,12(sp)
81112a60:	df000215 	stw	fp,8(sp)
81112a64:	df000204 	addi	fp,sp,8
81112a68:	e13ffe15 	stw	r4,-8(fp)
81112a6c:	e17fff15 	stw	r5,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp, "MEB Task: Can't change the mode of the NFEE while MEB is Config mode\n\n" );
81112a70:	d0a05e17 	ldw	r2,-32392(gp)
81112a74:	100f883a 	mov	r7,r2
81112a78:	01801184 	movi	r6,70
81112a7c:	01400044 	movi	r5,1
81112a80:	01204574 	movhi	r4,33045
81112a84:	21267204 	addi	r4,r4,-26168
81112a88:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
}
81112a8c:	0001883a 	nop
81112a90:	e037883a 	mov	sp,fp
81112a94:	dfc00117 	ldw	ra,4(sp)
81112a98:	df000017 	ldw	fp,0(sp)
81112a9c:	dec00204 	addi	sp,sp,8
81112aa0:	f800283a 	ret

81112aa4 <vPusType252conf>:

void vPusType252conf( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112aa4:	defffb04 	addi	sp,sp,-20
81112aa8:	de00012e 	bgeu	sp,et,81112ab0 <vPusType252conf+0xc>
81112aac:	003b68fa 	trap	3
81112ab0:	dfc00415 	stw	ra,16(sp)
81112ab4:	df000315 	stw	fp,12(sp)
81112ab8:	df000304 	addi	fp,sp,12
81112abc:	e13ffe15 	stw	r4,-8(fp)
81112ac0:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81112ac4:	e0bfff17 	ldw	r2,-4(fp)
81112ac8:	1080050b 	ldhu	r2,20(r2)
81112acc:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81112ad0:	e0bfff17 	ldw	r2,-4(fp)
81112ad4:	1080038b 	ldhu	r2,14(r2)
81112ad8:	10bfffcc 	andi	r2,r2,65535
81112adc:	10c000a0 	cmpeqi	r3,r2,2
81112ae0:	18000c1e 	bne	r3,zero,81112b14 <vPusType252conf+0x70>
81112ae4:	10c00090 	cmplti	r3,r2,2
81112ae8:	1800611e 	bne	r3,zero,81112c70 <vPusType252conf+0x1cc>
81112aec:	10800188 	cmpgei	r2,r2,6
81112af0:	10005f1e 	bne	r2,zero,81112c70 <vPusType252conf+0x1cc>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
		case 5: /* TC_SCAM_SPW_LINK_RESET */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Can't perform this operation in the Link while Meb is Config mode \n\n");
81112af4:	d0a05e17 	ldw	r2,-32392(gp)
81112af8:	100f883a 	mov	r7,r2
81112afc:	01801384 	movi	r6,78
81112b00:	01400044 	movi	r5,1
81112b04:	01204574 	movhi	r4,33045
81112b08:	21268404 	addi	r4,r4,-26096
81112b0c:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
81112b10:	00005f06 	br	81112c90 <vPusType252conf+0x1ec>
		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */

			/* Disable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112b14:	e0bffd0b 	ldhu	r2,-12(fp)
81112b18:	10809524 	muli	r2,r2,596
81112b1c:	10805404 	addi	r2,r2,336
81112b20:	e0fffe17 	ldw	r3,-8(fp)
81112b24:	1885883a 	add	r2,r3,r2
81112b28:	1009883a 	mov	r4,r2
81112b2c:	1106d400 	call	81106d40 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
81112b30:	e0bffd0b 	ldhu	r2,-12(fp)
81112b34:	e0fffe17 	ldw	r3,-8(fp)
81112b38:	10809524 	muli	r2,r2,596
81112b3c:	1885883a 	add	r2,r3,r2
81112b40:	10806404 	addi	r2,r2,400
81112b44:	10000015 	stw	zero,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112b48:	e0bffd0b 	ldhu	r2,-12(fp)
81112b4c:	10809524 	muli	r2,r2,596
81112b50:	10805404 	addi	r2,r2,336
81112b54:	e0fffe17 	ldw	r3,-8(fp)
81112b58:	1885883a 	add	r2,r3,r2
81112b5c:	1009883a 	mov	r4,r2
81112b60:	1106c980 	call	81106c98 <bRmapSetIrqControl>

			/* Change the configuration */
			bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81112b64:	e0bffd0b 	ldhu	r2,-12(fp)
81112b68:	10809524 	muli	r2,r2,596
81112b6c:	10805404 	addi	r2,r2,336
81112b70:	e0fffe17 	ldw	r3,-8(fp)
81112b74:	1885883a 	add	r2,r3,r2
81112b78:	1009883a 	mov	r4,r2
81112b7c:	1106f280 	call	81106f28 <bRmapGetCodecConfig>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81112b80:	e0bffd0b 	ldhu	r2,-12(fp)
81112b84:	e0ffff17 	ldw	r3,-4(fp)
81112b88:	18c00b0b 	ldhu	r3,44(r3)
81112b8c:	1809883a 	mov	r4,r3
81112b90:	e0fffe17 	ldw	r3,-8(fp)
81112b94:	10809524 	muli	r2,r2,596
81112b98:	1885883a 	add	r2,r3,r2
81112b9c:	10805504 	addi	r2,r2,340
81112ba0:	11000005 	stb	r4,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81112ba4:	e0bffd0b 	ldhu	r2,-12(fp)
81112ba8:	e0ffff17 	ldw	r3,-4(fp)
81112bac:	18c0098b 	ldhu	r3,38(r3)
81112bb0:	1809883a 	mov	r4,r3
81112bb4:	e0fffe17 	ldw	r3,-8(fp)
81112bb8:	10809524 	muli	r2,r2,596
81112bbc:	1885883a 	add	r2,r3,r2
81112bc0:	10805544 	addi	r2,r2,341
81112bc4:	11000005 	stb	r4,0(r2)
			bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81112bc8:	e0bffd0b 	ldhu	r2,-12(fp)
81112bcc:	10809524 	muli	r2,r2,596
81112bd0:	10805404 	addi	r2,r2,336
81112bd4:	e0fffe17 	ldw	r3,-8(fp)
81112bd8:	1885883a 	add	r2,r3,r2
81112bdc:	1009883a 	mov	r4,r2
81112be0:	1106e500 	call	81106e50 <bRmapSetCodecConfig>


			/* Enable the RMAP interrupt */
			bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112be4:	e0bffd0b 	ldhu	r2,-12(fp)
81112be8:	10809524 	muli	r2,r2,596
81112bec:	10805404 	addi	r2,r2,336
81112bf0:	e0fffe17 	ldw	r3,-8(fp)
81112bf4:	1885883a 	add	r2,r3,r2
81112bf8:	1009883a 	mov	r4,r2
81112bfc:	1106d400 	call	81106d40 <bRmapGetIrqControl>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
81112c00:	e0bffd0b 	ldhu	r2,-12(fp)
81112c04:	e0fffe17 	ldw	r3,-8(fp)
81112c08:	10809524 	muli	r2,r2,596
81112c0c:	1885883a 	add	r2,r3,r2
81112c10:	10806404 	addi	r2,r2,400
81112c14:	00c00044 	movi	r3,1
81112c18:	10c00015 	stw	r3,0(r2)
			bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81112c1c:	e0bffd0b 	ldhu	r2,-12(fp)
81112c20:	10809524 	muli	r2,r2,596
81112c24:	10805404 	addi	r2,r2,336
81112c28:	e0fffe17 	ldw	r3,-8(fp)
81112c2c:	1885883a 	add	r2,r3,r2
81112c30:	1009883a 	mov	r4,r2
81112c34:	1106c980 	call	81106c98 <bRmapSetIrqControl>

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81112c38:	d0e05e17 	ldw	r3,-32392(gp)
81112c3c:	e0bfff17 	ldw	r2,-4(fp)
81112c40:	10800b0b 	ldhu	r2,44(r2)
81112c44:	113fffcc 	andi	r4,r2,65535
81112c48:	e0bfff17 	ldw	r2,-4(fp)
81112c4c:	1080098b 	ldhu	r2,38(r2)
81112c50:	10bfffcc 	andi	r2,r2,65535
81112c54:	100f883a 	mov	r7,r2
81112c58:	200d883a 	mov	r6,r4
81112c5c:	01604574 	movhi	r5,33045
81112c60:	29669804 	addi	r5,r5,-26016
81112c64:	1809883a 	mov	r4,r3
81112c68:	111ca180 	call	8111ca18 <fprintf>
			#endif

			break;
81112c6c:	00000806 	br	81112c90 <vPusType252conf+0x1ec>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode\n\n" );
81112c70:	d0a05e17 	ldw	r2,-32392(gp)
81112c74:	100f883a 	mov	r7,r2
81112c78:	01800b04 	movi	r6,44
81112c7c:	01400044 	movi	r5,1
81112c80:	01204574 	movhi	r4,33045
81112c84:	21266604 	addi	r4,r4,-26216
81112c88:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
81112c8c:	0001883a 	nop
	}
}
81112c90:	0001883a 	nop
81112c94:	e037883a 	mov	sp,fp
81112c98:	dfc00117 	ldw	ra,4(sp)
81112c9c:	df000017 	ldw	fp,0(sp)
81112ca0:	dec00204 	addi	sp,sp,8
81112ca4:	f800283a 	ret

81112ca8 <vPusMebInTaskRunningMode>:




/* This function should treat the PUS command in the Running Mode, need check all the things that is possible to update in this mode */
void vPusMebInTaskRunningMode( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112ca8:	defffc04 	addi	sp,sp,-16
81112cac:	de00012e 	bgeu	sp,et,81112cb4 <vPusMebInTaskRunningMode+0xc>
81112cb0:	003b68fa 	trap	3
81112cb4:	dfc00315 	stw	ra,12(sp)
81112cb8:	df000215 	stw	fp,8(sp)
81112cbc:	df000204 	addi	fp,sp,8
81112cc0:	e13ffe15 	stw	r4,-8(fp)
81112cc4:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiType) {
81112cc8:	e0bfff17 	ldw	r2,-4(fp)
81112ccc:	1080030b 	ldhu	r2,12(r2)
81112cd0:	10bfffcc 	andi	r2,r2,65535
81112cd4:	10c03ee0 	cmpeqi	r3,r2,251
81112cd8:	1800081e 	bne	r3,zero,81112cfc <vPusMebInTaskRunningMode+0x54>
81112cdc:	10c03f20 	cmpeqi	r3,r2,252
81112ce0:	18000a1e 	bne	r3,zero,81112d0c <vPusMebInTaskRunningMode+0x64>
81112ce4:	10803ea0 	cmpeqi	r2,r2,250
81112ce8:	10000c26 	beq	r2,zero,81112d1c <vPusMebInTaskRunningMode+0x74>
		/* srv-Type = 250 */
		case 250:
			vPusType250run(pxMebCLocal, xPusL);
81112cec:	e17fff17 	ldw	r5,-4(fp)
81112cf0:	e13ffe17 	ldw	r4,-8(fp)
81112cf4:	1112d540 	call	81112d54 <vPusType250run>
			break;
81112cf8:	00001006 	br	81112d3c <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 251 */
		case 251:
			vPusType251run(pxMebCLocal, xPusL);
81112cfc:	e17fff17 	ldw	r5,-4(fp)
81112d00:	e13ffe17 	ldw	r4,-8(fp)
81112d04:	1112de00 	call	81112de0 <vPusType251run>
			break;
81112d08:	00000c06 	br	81112d3c <vPusMebInTaskRunningMode+0x94>
		/* srv-Type = 252 */
		case 252:
			vPusType252run(pxMebCLocal, xPusL);
81112d0c:	e17fff17 	ldw	r5,-4(fp)
81112d10:	e13ffe17 	ldw	r4,-8(fp)
81112d14:	1112ef40 	call	81112ef4 <vPusType252run>
			break;
81112d18:	00000806 	br	81112d3c <vPusMebInTaskRunningMode+0x94>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Srv-Type not allowed in this mode (RUN)\n\n" );
81112d1c:	d0a05e17 	ldw	r2,-32392(gp)
81112d20:	100f883a 	mov	r7,r2
81112d24:	01800cc4 	movi	r6,51
81112d28:	01400044 	movi	r5,1
81112d2c:	01204574 	movhi	r4,33045
81112d30:	2126a804 	addi	r4,r4,-25952
81112d34:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
81112d38:	0001883a 	nop
	}
}
81112d3c:	0001883a 	nop
81112d40:	e037883a 	mov	sp,fp
81112d44:	dfc00117 	ldw	ra,4(sp)
81112d48:	df000017 	ldw	fp,0(sp)
81112d4c:	dec00204 	addi	sp,sp,8
81112d50:	f800283a 	ret

81112d54 <vPusType250run>:


void vPusType250run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112d54:	defffc04 	addi	sp,sp,-16
81112d58:	de00012e 	bgeu	sp,et,81112d60 <vPusType250run+0xc>
81112d5c:	003b68fa 	trap	3
81112d60:	dfc00315 	stw	ra,12(sp)
81112d64:	df000215 	stw	fp,8(sp)
81112d68:	df000204 	addi	fp,sp,8
81112d6c:	e13ffe15 	stw	r4,-8(fp)
81112d70:	e17fff15 	stw	r5,-4(fp)

	switch (xPusL->usiSubType) {
81112d74:	e0bfff17 	ldw	r2,-4(fp)
81112d78:	1080038b 	ldhu	r2,14(r2)
81112d7c:	10bfffcc 	andi	r2,r2,65535
81112d80:	10c00f20 	cmpeqi	r3,r2,60
81112d84:	1800031e 	bne	r3,zero,81112d94 <vPusType250run+0x40>
81112d88:	10800fa0 	cmpeqi	r2,r2,62
81112d8c:	10000d1e 	bne	r2,zero,81112dc4 <vPusType250run+0x70>
81112d90:	00000406 	br	81112da4 <vPusType250run+0x50>
		/* TC_SCAM_CONFIG */
		case 60:
			pxMebCLocal->eMode = sMebToConfig;
81112d94:	e0bffe17 	ldw	r2,-8(fp)
81112d98:	00c00044 	movi	r3,1
81112d9c:	10c00115 	stw	r3,4(r2)
			break;
81112da0:	00000906 	br	81112dc8 <vPusType250run+0x74>
			break;
		/* TC_SCAM_RUN */
		case 61:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81112da4:	d0a05e17 	ldw	r2,-32392(gp)
81112da8:	100f883a 	mov	r7,r2
81112dac:	01800c84 	movi	r6,50
81112db0:	01400044 	movi	r5,1
81112db4:	01204574 	movhi	r4,33045
81112db8:	2126b504 	addi	r4,r4,-25900
81112dbc:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
81112dc0:	00000106 	br	81112dc8 <vPusType250run+0x74>
			pxMebCLocal->eMode = sMebToConfig;
			break;
		/* TC_SCAM_TURNOFF */
		case 62:
			/*todo: Do nothing for now */
			break;
81112dc4:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81112dc8:	0001883a 	nop
81112dcc:	e037883a 	mov	sp,fp
81112dd0:	dfc00117 	ldw	ra,4(sp)
81112dd4:	df000017 	ldw	fp,0(sp)
81112dd8:	dec00204 	addi	sp,sp,8
81112ddc:	f800283a 	ret

81112de0 <vPusType251run>:

void vPusType251run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112de0:	defffb04 	addi	sp,sp,-20
81112de4:	de00012e 	bgeu	sp,et,81112dec <vPusType251run+0xc>
81112de8:	003b68fa 	trap	3
81112dec:	dfc00415 	stw	ra,16(sp)
81112df0:	df000315 	stw	fp,12(sp)
81112df4:	df000304 	addi	fp,sp,12
81112df8:	e13ffe15 	stw	r4,-8(fp)
81112dfc:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81112e00:	e0bfff17 	ldw	r2,-4(fp)
81112e04:	1080050b 	ldhu	r2,20(r2)
81112e08:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81112e0c:	e0bfff17 	ldw	r2,-4(fp)
81112e10:	1080038b 	ldhu	r2,14(r2)
81112e14:	10bfffcc 	andi	r2,r2,65535
81112e18:	10c000a0 	cmpeqi	r3,r2,2
81112e1c:	18000f1e 	bne	r3,zero,81112e5c <vPusType251run+0x7c>
81112e20:	10c00160 	cmpeqi	r3,r2,5
81112e24:	1800181e 	bne	r3,zero,81112e88 <vPusType251run+0xa8>
81112e28:	10800060 	cmpeqi	r2,r2,1
81112e2c:	10002126 	beq	r2,zero,81112eb4 <vPusType251run+0xd4>
		/* TC_SCAM_FEE_CONFIG_ENTER */
		case 1:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_CONFIG, 0, usiFeeInstL );
81112e30:	e0bffd0b 	ldhu	r2,-12(fp)
81112e34:	10800444 	addi	r2,r2,17
81112e38:	10803fcc 	andi	r2,r2,255
81112e3c:	e0fffd0b 	ldhu	r3,-12(fp)
81112e40:	18c03fcc 	andi	r3,r3,255
81112e44:	180f883a 	mov	r7,r3
81112e48:	000d883a 	mov	r6,zero
81112e4c:	01400044 	movi	r5,1
81112e50:	1009883a 	mov	r4,r2
81112e54:	111338c0 	call	8111338c <vSendCmdQToNFeeCTRL_GEN>
			break;
81112e58:	00002006 	br	81112edc <vPusType251run+0xfc>
		/* TC_SCAM_FEE_STANDBY_ENTER */
		case 2:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_STANDBY, 0, usiFeeInstL );
81112e5c:	e0bffd0b 	ldhu	r2,-12(fp)
81112e60:	10800444 	addi	r2,r2,17
81112e64:	10803fcc 	andi	r2,r2,255
81112e68:	e0fffd0b 	ldhu	r3,-12(fp)
81112e6c:	18c03fcc 	andi	r3,r3,255
81112e70:	180f883a 	mov	r7,r3
81112e74:	000d883a 	mov	r6,zero
81112e78:	01400104 	movi	r5,4
81112e7c:	1009883a 	mov	r4,r2
81112e80:	111338c0 	call	8111338c <vSendCmdQToNFeeCTRL_GEN>
			break;
81112e84:	00001506 	br	81112edc <vPusType251run+0xfc>
		/* TC_SCAM_FEE_CALIBRATION_TEST_ENTER */
		case 5:
			/* Using QMASK send to NfeeControl that will foward */
			vSendCmdQToNFeeCTRL_GEN((M_NFEE_BASE_ADDR+usiFeeInstL), M_FEE_FULL_PATTERN, 0, usiFeeInstL );
81112e88:	e0bffd0b 	ldhu	r2,-12(fp)
81112e8c:	10800444 	addi	r2,r2,17
81112e90:	10803fcc 	andi	r2,r2,255
81112e94:	e0fffd0b 	ldhu	r3,-12(fp)
81112e98:	18c03fcc 	andi	r3,r3,255
81112e9c:	180f883a 	mov	r7,r3
81112ea0:	000d883a 	mov	r6,zero
81112ea4:	01400204 	movi	r5,8
81112ea8:	1009883a 	mov	r4,r2
81112eac:	111338c0 	call	8111338c <vSendCmdQToNFeeCTRL_GEN>
			break;
81112eb0:	00000a06 	br	81112edc <vPusType251run+0xfc>
		case 3:
		case 4:
		case 6:
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not implemented yet (SubType:%hu)\n\n",xPusL->usiSubType );
81112eb4:	d0e05e17 	ldw	r3,-32392(gp)
81112eb8:	e0bfff17 	ldw	r2,-4(fp)
81112ebc:	1080038b 	ldhu	r2,14(r2)
81112ec0:	10bfffcc 	andi	r2,r2,65535
81112ec4:	100d883a 	mov	r6,r2
81112ec8:	01604574 	movhi	r5,33045
81112ecc:	2966c204 	addi	r5,r5,-25848
81112ed0:	1809883a 	mov	r4,r3
81112ed4:	111ca180 	call	8111ca18 <fprintf>
			#endif
			break;
81112ed8:	0001883a 	nop
	}
}
81112edc:	0001883a 	nop
81112ee0:	e037883a 	mov	sp,fp
81112ee4:	dfc00117 	ldw	ra,4(sp)
81112ee8:	df000017 	ldw	fp,0(sp)
81112eec:	dec00204 	addi	sp,sp,8
81112ef0:	f800283a 	ret

81112ef4 <vPusType252run>:

void vPusType252run( TSimucam_MEB *pxMebCLocal, tTMPus *xPusL ) {
81112ef4:	defffb04 	addi	sp,sp,-20
81112ef8:	de00012e 	bgeu	sp,et,81112f00 <vPusType252run+0xc>
81112efc:	003b68fa 	trap	3
81112f00:	dfc00415 	stw	ra,16(sp)
81112f04:	df000315 	stw	fp,12(sp)
81112f08:	df000304 	addi	fp,sp,12
81112f0c:	e13ffe15 	stw	r4,-8(fp)
81112f10:	e17fff15 	stw	r5,-4(fp)
	unsigned short int usiFeeInstL;

	usiFeeInstL = xPusL->usiValues[0];
81112f14:	e0bfff17 	ldw	r2,-4(fp)
81112f18:	1080050b 	ldhu	r2,20(r2)
81112f1c:	e0bffd0d 	sth	r2,-12(fp)
	switch (xPusL->usiSubType) {
81112f20:	e0bfff17 	ldw	r2,-4(fp)
81112f24:	1080038b 	ldhu	r2,14(r2)
81112f28:	10bfffcc 	andi	r2,r2,65535
81112f2c:	10c000e0 	cmpeqi	r3,r2,3
81112f30:	18000a1e 	bne	r3,zero,81112f5c <vPusType252run+0x68>
81112f34:	10c00108 	cmpgei	r3,r2,4
81112f38:	1800031e 	bne	r3,zero,81112f48 <vPusType252run+0x54>
81112f3c:	108000a0 	cmpeqi	r2,r2,2
81112f40:	1000581e 	bne	r2,zero,811130a4 <vPusType252run+0x1b0>
81112f44:	0000be06 	br	81113240 <vPusType252run+0x34c>
81112f48:	10c00120 	cmpeqi	r3,r2,4
81112f4c:	18002c1e 	bne	r3,zero,81113000 <vPusType252run+0x10c>
81112f50:	10800160 	cmpeqi	r2,r2,5
81112f54:	1000c21e 	bne	r2,zero,81113260 <vPusType252run+0x36c>
81112f58:	0000b906 	br	81113240 <vPusType252run+0x34c>
		case 3: /* TC_SCAM_SPW_LINK_ENABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112f5c:	e0bffd0b 	ldhu	r2,-12(fp)
81112f60:	10809524 	muli	r2,r2,596
81112f64:	10809a04 	addi	r2,r2,616
81112f68:	e0fffe17 	ldw	r3,-8(fp)
81112f6c:	1885883a 	add	r2,r3,r2
81112f70:	1009883a 	mov	r4,r2
81112f74:	11092c40 	call	811092c4 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
81112f78:	e0bffd0b 	ldhu	r2,-12(fp)
81112f7c:	e0fffe17 	ldw	r3,-8(fp)
81112f80:	10809524 	muli	r2,r2,596
81112f84:	1885883a 	add	r2,r3,r2
81112f88:	10809c04 	addi	r2,r2,624
81112f8c:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = TRUE;
81112f90:	e0bffd0b 	ldhu	r2,-12(fp)
81112f94:	e0fffe17 	ldw	r3,-8(fp)
81112f98:	10809524 	muli	r2,r2,596
81112f9c:	1885883a 	add	r2,r3,r2
81112fa0:	10809b04 	addi	r2,r2,620
81112fa4:	00c00044 	movi	r3,1
81112fa8:	10c00015 	stw	r3,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = FALSE;
81112fac:	e0bffd0b 	ldhu	r2,-12(fp)
81112fb0:	e0fffe17 	ldw	r3,-8(fp)
81112fb4:	10809524 	muli	r2,r2,596
81112fb8:	1885883a 	add	r2,r3,r2
81112fbc:	10809d04 	addi	r2,r2,628
81112fc0:	10000015 	stw	zero,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81112fc4:	e0bffd0b 	ldhu	r2,-12(fp)
81112fc8:	10809524 	muli	r2,r2,596
81112fcc:	10809a04 	addi	r2,r2,616
81112fd0:	e0fffe17 	ldw	r3,-8(fp)
81112fd4:	1885883a 	add	r2,r3,r2
81112fd8:	1009883a 	mov	r4,r2
81112fdc:	11091900 	call	81109190 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link enable (NFEE-%hu)\n\n", usiFeeInstL);
81112fe0:	d0a05e17 	ldw	r2,-32392(gp)
81112fe4:	e0fffd0b 	ldhu	r3,-12(fp)
81112fe8:	180d883a 	mov	r6,r3
81112fec:	01604574 	movhi	r5,33045
81112ff0:	2966d004 	addi	r5,r5,-25792
81112ff4:	1009883a 	mov	r4,r2
81112ff8:	111ca180 	call	8111ca18 <fprintf>
			#endif

			break;
81112ffc:	00009906 	br	81113264 <vPusType252run+0x370>

		case 4: /* TC_SCAM_SPW_LINK_DISABLE */
			bSpwcGetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81113000:	e0bffd0b 	ldhu	r2,-12(fp)
81113004:	10809524 	muli	r2,r2,596
81113008:	10809a04 	addi	r2,r2,616
8111300c:	e0fffe17 	ldw	r3,-8(fp)
81113010:	1885883a 	add	r2,r3,r2
81113014:	1009883a 	mov	r4,r2
81113018:	11092c40 	call	811092c4 <bSpwcGetLink>
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bLinkStart = FALSE;
8111301c:	e0bffd0b 	ldhu	r2,-12(fp)
81113020:	e0fffe17 	ldw	r3,-8(fp)
81113024:	10809524 	muli	r2,r2,596
81113028:	1885883a 	add	r2,r3,r2
8111302c:	10809c04 	addi	r2,r2,624
81113030:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bAutostart = FALSE;
81113034:	e0bffd0b 	ldhu	r2,-12(fp)
81113038:	e0fffe17 	ldw	r3,-8(fp)
8111303c:	10809524 	muli	r2,r2,596
81113040:	1885883a 	add	r2,r3,r2
81113044:	10809b04 	addi	r2,r2,620
81113048:	10000015 	stw	zero,0(r2)
			pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire.xLinkConfig.bDisconnect = TRUE;
8111304c:	e0bffd0b 	ldhu	r2,-12(fp)
81113050:	e0fffe17 	ldw	r3,-8(fp)
81113054:	10809524 	muli	r2,r2,596
81113058:	1885883a 	add	r2,r3,r2
8111305c:	10809d04 	addi	r2,r2,628
81113060:	00c00044 	movi	r3,1
81113064:	10c00015 	stw	r3,0(r2)
			bSpwcSetLink(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xSpacewire);
81113068:	e0bffd0b 	ldhu	r2,-12(fp)
8111306c:	10809524 	muli	r2,r2,596
81113070:	10809a04 	addi	r2,r2,616
81113074:	e0fffe17 	ldw	r3,-8(fp)
81113078:	1885883a 	add	r2,r3,r2
8111307c:	1009883a 	mov	r4,r2
81113080:	11091900 	call	81109190 <bSpwcSetLink>
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: Link disable (NFEE-%hu)\n\n", usiFeeInstL);
81113084:	d0a05e17 	ldw	r2,-32392(gp)
81113088:	e0fffd0b 	ldhu	r3,-12(fp)
8111308c:	180d883a 	mov	r6,r3
81113090:	01604574 	movhi	r5,33045
81113094:	2966d904 	addi	r5,r5,-25756
81113098:	1009883a 	mov	r4,r2
8111309c:	111ca180 	call	8111ca18 <fprintf>
			#endif

			break;
811130a0:	00007006 	br	81113264 <vPusType252run+0x370>
			break;

		case 2: /* TC_SCAM_SPW_RMAP_CONFIG_UPDATE */

			/* todo: For now we can only update the Logical Address and the RAMP Key */
			if ( pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xControl.eMode == sFeeConfig ) {
811130a4:	e0bffd0b 	ldhu	r2,-12(fp)
811130a8:	e0fffe17 	ldw	r3,-8(fp)
811130ac:	10809524 	muli	r2,r2,596
811130b0:	1885883a 	add	r2,r3,r2
811130b4:	10803e04 	addi	r2,r2,248
811130b8:	10800017 	ldw	r2,0(r2)
811130bc:	10800058 	cmpnei	r2,r2,1
811130c0:	10004a1e 	bne	r2,zero,811131ec <vPusType252run+0x2f8>
				/* Disable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811130c4:	e0bffd0b 	ldhu	r2,-12(fp)
811130c8:	10809524 	muli	r2,r2,596
811130cc:	10805404 	addi	r2,r2,336
811130d0:	e0fffe17 	ldw	r3,-8(fp)
811130d4:	1885883a 	add	r2,r3,r2
811130d8:	1009883a 	mov	r4,r2
811130dc:	1106d400 	call	81106d40 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = FALSE;
811130e0:	e0bffd0b 	ldhu	r2,-12(fp)
811130e4:	e0fffe17 	ldw	r3,-8(fp)
811130e8:	10809524 	muli	r2,r2,596
811130ec:	1885883a 	add	r2,r3,r2
811130f0:	10806404 	addi	r2,r2,400
811130f4:	10000015 	stw	zero,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811130f8:	e0bffd0b 	ldhu	r2,-12(fp)
811130fc:	10809524 	muli	r2,r2,596
81113100:	10805404 	addi	r2,r2,336
81113104:	e0fffe17 	ldw	r3,-8(fp)
81113108:	1885883a 	add	r2,r3,r2
8111310c:	1009883a 	mov	r4,r2
81113110:	1106c980 	call	81106c98 <bRmapSetIrqControl>

				/* Change the configuration */
				bRmapGetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81113114:	e0bffd0b 	ldhu	r2,-12(fp)
81113118:	10809524 	muli	r2,r2,596
8111311c:	10805404 	addi	r2,r2,336
81113120:	e0fffe17 	ldw	r3,-8(fp)
81113124:	1885883a 	add	r2,r3,r2
81113128:	1009883a 	mov	r4,r2
8111312c:	1106f280 	call	81106f28 <bRmapGetCodecConfig>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucKey = (unsigned char)xPusL->usiValues[12];
81113130:	e0bffd0b 	ldhu	r2,-12(fp)
81113134:	e0ffff17 	ldw	r3,-4(fp)
81113138:	18c00b0b 	ldhu	r3,44(r3)
8111313c:	1809883a 	mov	r4,r3
81113140:	e0fffe17 	ldw	r3,-8(fp)
81113144:	10809524 	muli	r2,r2,596
81113148:	1885883a 	add	r2,r3,r2
8111314c:	10805504 	addi	r2,r2,340
81113150:	11000005 	stb	r4,0(r2)
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapCodecConfig.ucLogicalAddress = (unsigned char)xPusL->usiValues[9];
81113154:	e0bffd0b 	ldhu	r2,-12(fp)
81113158:	e0ffff17 	ldw	r3,-4(fp)
8111315c:	18c0098b 	ldhu	r3,38(r3)
81113160:	1809883a 	mov	r4,r3
81113164:	e0fffe17 	ldw	r3,-8(fp)
81113168:	10809524 	muli	r2,r2,596
8111316c:	1885883a 	add	r2,r3,r2
81113170:	10805544 	addi	r2,r2,341
81113174:	11000005 	stb	r4,0(r2)
				bRmapSetCodecConfig( &pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap );
81113178:	e0bffd0b 	ldhu	r2,-12(fp)
8111317c:	10809524 	muli	r2,r2,596
81113180:	10805404 	addi	r2,r2,336
81113184:	e0fffe17 	ldw	r3,-8(fp)
81113188:	1885883a 	add	r2,r3,r2
8111318c:	1009883a 	mov	r4,r2
81113190:	1106e500 	call	81106e50 <bRmapSetCodecConfig>


				/* Enable the RMAP interrupt */
				bRmapGetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
81113194:	e0bffd0b 	ldhu	r2,-12(fp)
81113198:	10809524 	muli	r2,r2,596
8111319c:	10805404 	addi	r2,r2,336
811131a0:	e0fffe17 	ldw	r3,-8(fp)
811131a4:	1885883a 	add	r2,r3,r2
811131a8:	1009883a 	mov	r4,r2
811131ac:	1106d400 	call	81106d40 <bRmapGetIrqControl>
				pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap.xRmapIrqControl.bWriteCmdEn = TRUE;
811131b0:	e0bffd0b 	ldhu	r2,-12(fp)
811131b4:	e0fffe17 	ldw	r3,-8(fp)
811131b8:	10809524 	muli	r2,r2,596
811131bc:	1885883a 	add	r2,r3,r2
811131c0:	10806404 	addi	r2,r2,400
811131c4:	00c00044 	movi	r3,1
811131c8:	10c00015 	stw	r3,0(r2)
				bRmapSetIrqControl(&pxMebCLocal->xFeeControl.xNfee[usiFeeInstL].xChannel.xRmap);
811131cc:	e0bffd0b 	ldhu	r2,-12(fp)
811131d0:	10809524 	muli	r2,r2,596
811131d4:	10805404 	addi	r2,r2,336
811131d8:	e0fffe17 	ldw	r3,-8(fp)
811131dc:	1885883a 	add	r2,r3,r2
811131e0:	1009883a 	mov	r4,r2
811131e4:	1106c980 	call	81106c98 <bRmapSetIrqControl>
811131e8:	00000706 	br	81113208 <vPusType252run+0x314>
			} else {
				#ifdef DEBUG_ON
					fprintf(fp,"MEB Task: NFEE-%hu is not in the Config Mode ( Changes not performed )\n\n", usiFeeInstL);
811131ec:	d0a05e17 	ldw	r2,-32392(gp)
811131f0:	e0fffd0b 	ldhu	r3,-12(fp)
811131f4:	180d883a 	mov	r6,r3
811131f8:	01604574 	movhi	r5,33045
811131fc:	2966e204 	addi	r5,r5,-25720
81113200:	1009883a 	mov	r4,r2
81113204:	111ca180 	call	8111ca18 <fprintf>
				#endif
			}

			/* todo: Need to treat all the returns */
			#ifdef DEBUG_ON
				fprintf(fp,"MEB Task: RMAP KEY: %hu     L. ADDR: %hu (Change performed) \n\n", xPusL->usiValues[12] , xPusL->usiValues[9]);
81113208:	d0e05e17 	ldw	r3,-32392(gp)
8111320c:	e0bfff17 	ldw	r2,-4(fp)
81113210:	10800b0b 	ldhu	r2,44(r2)
81113214:	113fffcc 	andi	r4,r2,65535
81113218:	e0bfff17 	ldw	r2,-4(fp)
8111321c:	1080098b 	ldhu	r2,38(r2)
81113220:	10bfffcc 	andi	r2,r2,65535
81113224:	100f883a 	mov	r7,r2
81113228:	200d883a 	mov	r6,r4
8111322c:	01604574 	movhi	r5,33045
81113230:	29669804 	addi	r5,r5,-26016
81113234:	1809883a 	mov	r4,r3
81113238:	111ca180 	call	8111ca18 <fprintf>
			#endif
			break;
8111323c:	00000906 	br	81113264 <vPusType252run+0x370>
		default:
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
81113240:	d0a05e17 	ldw	r2,-32392(gp)
81113244:	100f883a 	mov	r7,r2
81113248:	01800c84 	movi	r6,50
8111324c:	01400044 	movi	r5,1
81113250:	01204574 	movhi	r4,33045
81113254:	2126b504 	addi	r4,r4,-25900
81113258:	111d0b40 	call	8111d0b4 <fwrite>
			#endif
			break;
8111325c:	00000106 	br	81113264 <vPusType252run+0x370>

			break;

		case 5: /* TC_SCAM_SPW_LINK_RESET */
			/* todo:Do nothing, don't know what is reset spw link */
			break;
81113260:	0001883a 	nop
			#ifdef DEBUG_ON
				fprintf(fp, "MEB Task: Command not allowed in this mode (RUN)\n\n" );
			#endif
			break;
	}
}
81113264:	0001883a 	nop
81113268:	e037883a 	mov	sp,fp
8111326c:	dfc00117 	ldw	ra,4(sp)
81113270:	df000017 	ldw	fp,0(sp)
81113274:	dec00204 	addi	sp,sp,8
81113278:	f800283a 	ret

8111327c <vSendCmdQToNFeeCTRL>:



void vSendCmdQToNFeeCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111327c:	defff904 	addi	sp,sp,-28
81113280:	de00012e 	bgeu	sp,et,81113288 <vSendCmdQToNFeeCTRL+0xc>
81113284:	003b68fa 	trap	3
81113288:	dfc00615 	stw	ra,24(sp)
8111328c:	df000515 	stw	fp,20(sp)
81113290:	df000504 	addi	fp,sp,20
81113294:	2807883a 	mov	r3,r5
81113298:	3005883a 	mov	r2,r6
8111329c:	e13ffd05 	stb	r4,-12(fp)
811132a0:	e0fffe05 	stb	r3,-8(fp)
811132a4:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811132a8:	00800404 	movi	r2,16
811132ac:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811132b0:	e0bffd03 	ldbu	r2,-12(fp)
811132b4:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811132b8:	e0bffe03 	ldbu	r2,-8(fp)
811132bc:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811132c0:	e0bfff03 	ldbu	r2,-4(fp)
811132c4:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811132c8:	d0a06c17 	ldw	r2,-32336(gp)
811132cc:	e0fffc17 	ldw	r3,-16(fp)
811132d0:	180b883a 	mov	r5,r3
811132d4:	1009883a 	mov	r4,r2
811132d8:	113a0040 	call	8113a004 <OSQPost>
811132dc:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
811132e0:	e0bffb03 	ldbu	r2,-20(fp)
811132e4:	10000126 	beq	r2,zero,811132ec <vSendCmdQToNFeeCTRL+0x70>
		vFailSendMsgFeeCTRL();
811132e8:	11197940 	call	81119794 <vFailSendMsgFeeCTRL>
	}
}
811132ec:	0001883a 	nop
811132f0:	e037883a 	mov	sp,fp
811132f4:	dfc00117 	ldw	ra,4(sp)
811132f8:	df000017 	ldw	fp,0(sp)
811132fc:	dec00204 	addi	sp,sp,8
81113300:	f800283a 	ret

81113304 <vSendCmdQToNFeeCTRL_PRIO>:

void vSendCmdQToNFeeCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113304:	defff904 	addi	sp,sp,-28
81113308:	de00012e 	bgeu	sp,et,81113310 <vSendCmdQToNFeeCTRL_PRIO+0xc>
8111330c:	003b68fa 	trap	3
81113310:	dfc00615 	stw	ra,24(sp)
81113314:	df000515 	stw	fp,20(sp)
81113318:	df000504 	addi	fp,sp,20
8111331c:	2807883a 	mov	r3,r5
81113320:	3005883a 	mov	r2,r6
81113324:	e13ffd05 	stb	r4,-12(fp)
81113328:	e0fffe05 	stb	r3,-8(fp)
8111332c:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
81113330:	00800404 	movi	r2,16
81113334:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81113338:	e0bffd03 	ldbu	r2,-12(fp)
8111333c:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
81113340:	e0bffe03 	ldbu	r2,-8(fp)
81113344:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113348:	e0bfff03 	ldbu	r2,-4(fp)
8111334c:	e0bffc05 	stb	r2,-16(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPostFront(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
81113350:	d0a06c17 	ldw	r2,-32336(gp)
81113354:	e0fffc17 	ldw	r3,-16(fp)
81113358:	180b883a 	mov	r5,r3
8111335c:	1009883a 	mov	r4,r2
81113360:	113a1740 	call	8113a174 <OSQPostFront>
81113364:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113368:	e0bffb03 	ldbu	r2,-20(fp)
8111336c:	10000126 	beq	r2,zero,81113374 <vSendCmdQToNFeeCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81113370:	11197940 	call	81119794 <vFailSendMsgFeeCTRL>
	}
}
81113374:	0001883a 	nop
81113378:	e037883a 	mov	sp,fp
8111337c:	dfc00117 	ldw	ra,4(sp)
81113380:	df000017 	ldw	fp,0(sp)
81113384:	dec00204 	addi	sp,sp,8
81113388:	f800283a 	ret

8111338c <vSendCmdQToNFeeCTRL_GEN>:


/* Send to FEEs using the NFEE Controller */
void vSendCmdQToNFeeCTRL_GEN( unsigned char ADDR,unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
8111338c:	defff804 	addi	sp,sp,-32
81113390:	de00012e 	bgeu	sp,et,81113398 <vSendCmdQToNFeeCTRL_GEN+0xc>
81113394:	003b68fa 	trap	3
81113398:	dfc00715 	stw	ra,28(sp)
8111339c:	df000615 	stw	fp,24(sp)
811133a0:	df000604 	addi	fp,sp,24
811133a4:	2011883a 	mov	r8,r4
811133a8:	2809883a 	mov	r4,r5
811133ac:	3007883a 	mov	r3,r6
811133b0:	3805883a 	mov	r2,r7
811133b4:	e23ffc05 	stb	r8,-16(fp)
811133b8:	e13ffd05 	stb	r4,-12(fp)
811133bc:	e0fffe05 	stb	r3,-8(fp)
811133c0:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = ADDR;
811133c4:	e0bffc03 	ldbu	r2,-16(fp)
811133c8:	e0bffbc5 	stb	r2,-17(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811133cc:	e0bffd03 	ldbu	r2,-12(fp)
811133d0:	e0bffb85 	stb	r2,-18(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811133d4:	e0bffe03 	ldbu	r2,-8(fp)
811133d8:	e0bffb45 	stb	r2,-19(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811133dc:	e0bfff03 	ldbu	r2,-4(fp)
811133e0:	e0bffb05 	stb	r2,-20(fp)

	/* Sync the Meb task and tell that has a PUS command waiting */
	error_codel = OSQPost(xQMaskFeeCtrl, (void *)uiCmdtoSend.ulWord);
811133e4:	d0a06c17 	ldw	r2,-32336(gp)
811133e8:	e0fffb17 	ldw	r3,-20(fp)
811133ec:	180b883a 	mov	r5,r3
811133f0:	1009883a 	mov	r4,r2
811133f4:	113a0040 	call	8113a004 <OSQPost>
811133f8:	e0bffa05 	stb	r2,-24(fp)
	if ( error_codel != OS_ERR_NONE ) {
811133fc:	e0bffa03 	ldbu	r2,-24(fp)
81113400:	10000126 	beq	r2,zero,81113408 <vSendCmdQToNFeeCTRL_GEN+0x7c>
		vFailSendMsgFeeCTRL();
81113404:	11197940 	call	81119794 <vFailSendMsgFeeCTRL>
	}
}
81113408:	0001883a 	nop
8111340c:	e037883a 	mov	sp,fp
81113410:	dfc00117 	ldw	ra,4(sp)
81113414:	df000017 	ldw	fp,0(sp)
81113418:	dec00204 	addi	sp,sp,8
8111341c:	f800283a 	ret

81113420 <vSendCmdQToDataCTRL>:


void vSendCmdQToDataCTRL( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
81113420:	defff904 	addi	sp,sp,-28
81113424:	de00012e 	bgeu	sp,et,8111342c <vSendCmdQToDataCTRL+0xc>
81113428:	003b68fa 	trap	3
8111342c:	dfc00615 	stw	ra,24(sp)
81113430:	df000515 	stw	fp,20(sp)
81113434:	df000504 	addi	fp,sp,20
81113438:	2807883a 	mov	r3,r5
8111343c:	3005883a 	mov	r2,r6
81113440:	e13ffd05 	stb	r4,-12(fp)
81113444:	e0fffe05 	stb	r3,-8(fp)
81113448:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_DATA_CTRL_ADDR;
8111344c:	00800804 	movi	r2,32
81113450:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
81113454:	e0bffd03 	ldbu	r2,-12(fp)
81113458:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
8111345c:	e0bffe03 	ldbu	r2,-8(fp)
81113460:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
81113464:	e0bfff03 	ldbu	r2,-4(fp)
81113468:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPost(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
8111346c:	d0a05b17 	ldw	r2,-32404(gp)
81113470:	e0fffc17 	ldw	r3,-16(fp)
81113474:	180b883a 	mov	r5,r3
81113478:	1009883a 	mov	r4,r2
8111347c:	113a0040 	call	8113a004 <OSQPost>
81113480:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
81113484:	e0bffb03 	ldbu	r2,-20(fp)
81113488:	10000126 	beq	r2,zero,81113490 <vSendCmdQToDataCTRL+0x70>
		vFailSendMsgDataCTRL();
8111348c:	11197e00 	call	811197e0 <vFailSendMsgDataCTRL>
	}
}
81113490:	0001883a 	nop
81113494:	e037883a 	mov	sp,fp
81113498:	dfc00117 	ldw	ra,4(sp)
8111349c:	df000017 	ldw	fp,0(sp)
811134a0:	dec00204 	addi	sp,sp,8
811134a4:	f800283a 	ret

811134a8 <vSendCmdQToDataCTRL_PRIO>:

void vSendCmdQToDataCTRL_PRIO( unsigned char ucCMD, unsigned char ucSUBType, unsigned char ucValue )
{
811134a8:	defff904 	addi	sp,sp,-28
811134ac:	de00012e 	bgeu	sp,et,811134b4 <vSendCmdQToDataCTRL_PRIO+0xc>
811134b0:	003b68fa 	trap	3
811134b4:	dfc00615 	stw	ra,24(sp)
811134b8:	df000515 	stw	fp,20(sp)
811134bc:	df000504 	addi	fp,sp,20
811134c0:	2807883a 	mov	r3,r5
811134c4:	3005883a 	mov	r2,r6
811134c8:	e13ffd05 	stb	r4,-12(fp)
811134cc:	e0fffe05 	stb	r3,-8(fp)
811134d0:	e0bfff05 	stb	r2,-4(fp)
	INT8U error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ucByte[3] = M_FEE_CTRL_ADDR;
811134d4:	00800404 	movi	r2,16
811134d8:	e0bffcc5 	stb	r2,-13(fp)
	uiCmdtoSend.ucByte[2] = ucCMD;
811134dc:	e0bffd03 	ldbu	r2,-12(fp)
811134e0:	e0bffc85 	stb	r2,-14(fp)
	uiCmdtoSend.ucByte[1] = ucSUBType;
811134e4:	e0bffe03 	ldbu	r2,-8(fp)
811134e8:	e0bffc45 	stb	r2,-15(fp)
	uiCmdtoSend.ucByte[0] = ucValue;
811134ec:	e0bfff03 	ldbu	r2,-4(fp)
811134f0:	e0bffc05 	stb	r2,-16(fp)

	/*Send a command to other entities (Data Controller) */
	error_codel = OSQPostFront(xQMaskDataCtrl, (void *)uiCmdtoSend.ulWord);
811134f4:	d0a05b17 	ldw	r2,-32404(gp)
811134f8:	e0fffc17 	ldw	r3,-16(fp)
811134fc:	180b883a 	mov	r5,r3
81113500:	1009883a 	mov	r4,r2
81113504:	113a1740 	call	8113a174 <OSQPostFront>
81113508:	e0bffb05 	stb	r2,-20(fp)
	if ( error_codel != OS_ERR_NONE ) {
8111350c:	e0bffb03 	ldbu	r2,-20(fp)
81113510:	10000126 	beq	r2,zero,81113518 <vSendCmdQToDataCTRL_PRIO+0x70>
		vFailSendMsgFeeCTRL();
81113514:	11197940 	call	81119794 <vFailSendMsgFeeCTRL>
	}
}
81113518:	0001883a 	nop
8111351c:	e037883a 	mov	sp,fp
81113520:	dfc00117 	ldw	ra,4(sp)
81113524:	df000017 	ldw	fp,0(sp)
81113528:	dec00204 	addi	sp,sp,8
8111352c:	f800283a 	ret

81113530 <vMebInit>:


void vMebInit(TSimucam_MEB *pxMebCLocal) {
81113530:	defffc04 	addi	sp,sp,-16
81113534:	de00012e 	bgeu	sp,et,8111353c <vMebInit+0xc>
81113538:	003b68fa 	trap	3
8111353c:	dfc00315 	stw	ra,12(sp)
81113540:	df000215 	stw	fp,8(sp)
81113544:	df000204 	addi	fp,sp,8
81113548:	e13fff15 	stw	r4,-4(fp)
	INT8U errorCodeL;

	pxMebCLocal->ucActualDDR = 0;
8111354c:	e0bfff17 	ldw	r2,-4(fp)
81113550:	10000205 	stb	zero,8(r2)
	pxMebCLocal->ucNextDDR = 1;
81113554:	e0bfff17 	ldw	r2,-4(fp)
81113558:	00c00044 	movi	r3,1
8111355c:	10c00245 	stb	r3,9(r2)
	/* Flush all communication Queues */
	errorCodeL = OSQFlush(xMebQ);
81113560:	d0a06517 	ldw	r2,-32364(gp)
81113564:	1009883a 	mov	r4,r2
81113568:	1139b3c0 	call	81139b3c <OSQFlush>
8111356c:	e0bffe05 	stb	r2,-8(fp)
	if ( errorCodeL != OS_NO_ERR ) {
81113570:	e0bffe03 	ldbu	r2,-8(fp)
81113574:	10000126 	beq	r2,zero,8111357c <vMebInit+0x4c>
		vFailFlushMEBQueue();
81113578:	11198c40 	call	811198c4 <vFailFlushMEBQueue>
	}
}
8111357c:	0001883a 	nop
81113580:	e037883a 	mov	sp,fp
81113584:	dfc00117 	ldw	ra,4(sp)
81113588:	df000017 	ldw	fp,0(sp)
8111358c:	dec00204 	addi	sp,sp,8
81113590:	f800283a 	ret

81113594 <vSwapMemmory>:

/* Swap memory reference */
void vSwapMemmory(TSimucam_MEB *pxMebCLocal) {
81113594:	defffc04 	addi	sp,sp,-16
81113598:	de00012e 	bgeu	sp,et,811135a0 <vSwapMemmory+0xc>
8111359c:	003b68fa 	trap	3
811135a0:	dfc00315 	stw	ra,12(sp)
811135a4:	df000215 	stw	fp,8(sp)
811135a8:	df000204 	addi	fp,sp,8
811135ac:	e13fff15 	stw	r4,-4(fp)
	/*todo: Apenas para teste !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!*/



	/* Configurar o tamanho normal do double buffer !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  */
	bSpwcGetTimecode(&pxMebCLocal->xFeeControl.xNfee[0].xChannel.xSpacewire);
811135b0:	e0bfff17 	ldw	r2,-4(fp)
811135b4:	10809a04 	addi	r2,r2,616
811135b8:	1009883a 	mov	r4,r2
811135bc:	110956c0 	call	8110956c <bSpwcGetTimecode>
	tCode = ( pxMebCLocal->xFeeControl.xNfee[0].xChannel.xSpacewire.xTimecode.ucCounter);
811135c0:	e0bfff17 	ldw	r2,-4(fp)
811135c4:	1080a643 	ldbu	r2,665(r2)
811135c8:	e0bffe05 	stb	r2,-8(fp)
	tCodeNext = ( tCode ) % 4;
811135cc:	e0bffe03 	ldbu	r2,-8(fp)
811135d0:	108000cc 	andi	r2,r2,3
811135d4:	e0bffe45 	stb	r2,-7(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"\n\nMEB TASK:  TIME CODE: %hhu \n ", tCode);
811135d8:	d0a05e17 	ldw	r2,-32392(gp)
811135dc:	e0fffe03 	ldbu	r3,-8(fp)
811135e0:	180d883a 	mov	r6,r3
811135e4:	01604574 	movhi	r5,33045
811135e8:	2966f504 	addi	r5,r5,-25644
811135ec:	1009883a 	mov	r4,r2
811135f0:	111ca180 	call	8111ca18 <fprintf>
		fprintf(fp,"MEB TASK:  MODULUS: %hhu \n\n ", tCodeNext);
811135f4:	d0a05e17 	ldw	r2,-32392(gp)
811135f8:	e0fffe43 	ldbu	r3,-7(fp)
811135fc:	180d883a 	mov	r6,r3
81113600:	01604574 	movhi	r5,33045
81113604:	2966fd04 	addi	r5,r5,-25612
81113608:	1009883a 	mov	r4,r2
8111360c:	111ca180 	call	8111ca18 <fprintf>
	#endif


	pxMebCLocal->ucActualDDR = (pxMebCLocal->ucActualDDR + 1) % 2 ;
81113610:	e0bfff17 	ldw	r2,-4(fp)
81113614:	10800203 	ldbu	r2,8(r2)
81113618:	10803fcc 	andi	r2,r2,255
8111361c:	10c00044 	addi	r3,r2,1
81113620:	00a00034 	movhi	r2,32768
81113624:	10800044 	addi	r2,r2,1
81113628:	1884703a 	and	r2,r3,r2
8111362c:	1000040e 	bge	r2,zero,81113640 <vSwapMemmory+0xac>
81113630:	10bfffc4 	addi	r2,r2,-1
81113634:	00ffff84 	movi	r3,-2
81113638:	10c4b03a 	or	r2,r2,r3
8111363c:	10800044 	addi	r2,r2,1
81113640:	1007883a 	mov	r3,r2
81113644:	e0bfff17 	ldw	r2,-4(fp)
81113648:	10c00205 	stb	r3,8(r2)
	pxMebCLocal->ucNextDDR = (pxMebCLocal->ucNextDDR + 1) % 2 ;
8111364c:	e0bfff17 	ldw	r2,-4(fp)
81113650:	10800243 	ldbu	r2,9(r2)
81113654:	10803fcc 	andi	r2,r2,255
81113658:	10c00044 	addi	r3,r2,1
8111365c:	00a00034 	movhi	r2,32768
81113660:	10800044 	addi	r2,r2,1
81113664:	1884703a 	and	r2,r3,r2
81113668:	1000040e 	bge	r2,zero,8111367c <vSwapMemmory+0xe8>
8111366c:	10bfffc4 	addi	r2,r2,-1
81113670:	00ffff84 	movi	r3,-2
81113674:	10c4b03a 	or	r2,r2,r3
81113678:	10800044 	addi	r2,r2,1
8111367c:	1007883a 	mov	r3,r2
81113680:	e0bfff17 	ldw	r2,-4(fp)
81113684:	10c00245 	stb	r3,9(r2)

}
81113688:	0001883a 	nop
8111368c:	e037883a 	mov	sp,fp
81113690:	dfc00117 	ldw	ra,4(sp)
81113694:	df000017 	ldw	fp,0(sp)
81113698:	dec00204 	addi	sp,sp,8
8111369c:	f800283a 	ret

811136a0 <vReleaseSyncMessages>:

/* After stop the Sync signal generation, maybe some FEE task could be locked waiting for this signal. So we send to everyone, and after that they will flush the queue */
void vReleaseSyncMessages(void) {
811136a0:	defffc04 	addi	sp,sp,-16
811136a4:	de00012e 	bgeu	sp,et,811136ac <vReleaseSyncMessages+0xc>
811136a8:	003b68fa 	trap	3
811136ac:	dfc00315 	stw	ra,12(sp)
811136b0:	df000215 	stw	fp,8(sp)
811136b4:	df000204 	addi	fp,sp,8
	unsigned char ucIL;
	unsigned char ucSyncL;
	unsigned char error_codel;
	tQMask uiCmdtoSend;

	uiCmdtoSend.ulWord = 0;
811136b8:	e03fff15 	stw	zero,-4(fp)
	uiCmdtoSend.ucByte[2] = M_SYNC;
811136bc:	00bff844 	movi	r2,-31
811136c0:	e0bfff85 	stb	r2,-2(fp)
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
811136c4:	e03ffe05 	stb	zero,-8(fp)
811136c8:	00001606 	br	81113724 <vReleaseSyncMessages+0x84>
		uiCmdtoSend.ucByte[3] = M_NFEE_BASE_ADDR + ucIL;
811136cc:	e0bffe03 	ldbu	r2,-8(fp)
811136d0:	10800444 	addi	r2,r2,17
811136d4:	e0bfffc5 	stb	r2,-1(fp)
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
811136d8:	e0bffe03 	ldbu	r2,-8(fp)
811136dc:	1085883a 	add	r2,r2,r2
811136e0:	1087883a 	add	r3,r2,r2
811136e4:	d0a05804 	addi	r2,gp,-32416
811136e8:	1885883a 	add	r2,r3,r2
811136ec:	10800017 	ldw	r2,0(r2)
811136f0:	e0ffff17 	ldw	r3,-4(fp)
811136f4:	180b883a 	mov	r5,r3
811136f8:	1009883a 	mov	r4,r2
811136fc:	113a0040 	call	8113a004 <OSQPost>
81113700:	e0bffe45 	stb	r2,-7(fp)
		if ( error_codel != OS_ERR_NONE ) {
81113704:	e0bffe43 	ldbu	r2,-7(fp)
81113708:	10000326 	beq	r2,zero,81113718 <vReleaseSyncMessages+0x78>
			vFailSendMsgSync( ucIL );
8111370c:	e0bffe03 	ldbu	r2,-8(fp)
81113710:	1009883a 	mov	r4,r2
81113714:	11196a00 	call	811196a0 <vFailSendMsgSync>

	uiCmdtoSend.ulWord = 0;
	uiCmdtoSend.ucByte[2] = M_SYNC;
	/* MasterSync? */

	for( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ){
81113718:	e0bffe03 	ldbu	r2,-8(fp)
8111371c:	10800044 	addi	r2,r2,1
81113720:	e0bffe05 	stb	r2,-8(fp)
81113724:	e0bffe03 	ldbu	r2,-8(fp)
81113728:	103fe826 	beq	r2,zero,811136cc <__reset+0xfb0f36cc>
		error_codel = OSQPost(xWaitSyncQFee[ ucIL ], (void *)uiCmdtoSend.ulWord);
		if ( error_codel != OS_ERR_NONE ) {
			vFailSendMsgSync( ucIL );
		}
	}
}
8111372c:	0001883a 	nop
81113730:	e037883a 	mov	sp,fp
81113734:	dfc00117 	ldw	ra,4(sp)
81113738:	df000017 	ldw	fp,0(sp)
8111373c:	dec00204 	addi	sp,sp,8
81113740:	f800283a 	ret

81113744 <vStackMonitor>:
    }
}

#else
#ifdef DEBUG_ON
void vStackMonitor(void *task_data) {
81113744:	defff804 	addi	sp,sp,-32
81113748:	de00012e 	bgeu	sp,et,81113750 <vStackMonitor+0xc>
8111374c:	003b68fa 	trap	3
81113750:	dfc00715 	stw	ra,28(sp)
81113754:	df000615 	stw	fp,24(sp)
81113758:	df000604 	addi	fp,sp,24
8111375c:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81113760:	e03ffc05 	stb	zero,-16(fp)
	OS_STK_DATA data;


        debug(fp,"vStackMonitor, enter task.\n");
81113764:	d0a05e17 	ldw	r2,-32392(gp)
81113768:	100f883a 	mov	r7,r2
8111376c:	018006c4 	movi	r6,27
81113770:	01400044 	movi	r5,1
81113774:	01204574 	movhi	r4,33045
81113778:	21270504 	addi	r4,r4,-25580
8111377c:	111d0b40 	call	8111d0b4 <fwrite>


    for (;;) {

    	fprintf(fp, "=========== STACK MONITOR =================\n" );
81113780:	d0a05e17 	ldw	r2,-32392(gp)
81113784:	100f883a 	mov	r7,r2
81113788:	01800b04 	movi	r6,44
8111378c:	01400044 	movi	r5,1
81113790:	01204574 	movhi	r4,33045
81113794:	21270c04 	addi	r4,r4,-25552
81113798:	111d0b40 	call	8111d0b4 <fwrite>
    	fprintf(fp, " Task           Total               Free             In use  \n" );
8111379c:	d0a05e17 	ldw	r2,-32392(gp)
811137a0:	100f883a 	mov	r7,r2
811137a4:	01800f84 	movi	r6,62
811137a8:	01400044 	movi	r5,1
811137ac:	01204574 	movhi	r4,33045
811137b0:	21271804 	addi	r4,r4,-25504
811137b4:	111d0b40 	call	8111d0b4 <fwrite>

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
811137b8:	e0bffd04 	addi	r2,fp,-12
811137bc:	100b883a 	mov	r5,r2
811137c0:	01000804 	movi	r4,32
811137c4:	113c4280 	call	8113c428 <OSTaskStkChk>
811137c8:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE ) {
811137cc:	e0bffc03 	ldbu	r2,-16(fp)
811137d0:	10000f1e 	bne	r2,zero,81113810 <vStackMonitor+0xcc>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811137d4:	d1205e17 	ldw	r4,-32392(gp)
    				"RECEIVER_TASK",
    				data.OSFree + data.OSUsed,
811137d8:	e0fffd17 	ldw	r3,-12(fp)
811137dc:	e0bffe17 	ldw	r2,-8(fp)
    	fprintf(fp, " Task           Total               Free             In use  \n" );

    	ucErrorCode = OSTaskStkChk( RECEIVER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811137e0:	188b883a 	add	r5,r3,r2
811137e4:	e0bffd17 	ldw	r2,-12(fp)
811137e8:	e0fffe17 	ldw	r3,-8(fp)
811137ec:	d8c00115 	stw	r3,4(sp)
811137f0:	d8800015 	stw	r2,0(sp)
811137f4:	280f883a 	mov	r7,r5
811137f8:	01a04574 	movhi	r6,33045
811137fc:	31a72804 	addi	r6,r6,-25440
81113800:	01604574 	movhi	r5,33045
81113804:	29672c04 	addi	r5,r5,-25424
81113808:	111ca180 	call	8111ca18 <fprintf>
8111380c:	00000706 	br	8111382c <vStackMonitor+0xe8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get RECEIVER_TASK stack \n" );
81113810:	d0a05e17 	ldw	r2,-32392(gp)
81113814:	100f883a 	mov	r7,r2
81113818:	01800904 	movi	r6,36
8111381c:	01400044 	movi	r5,1
81113820:	01204574 	movhi	r4,33045
81113824:	21273b04 	addi	r4,r4,-25364
81113828:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
8111382c:	e0bffd04 	addi	r2,fp,-12
81113830:	100b883a 	mov	r5,r2
81113834:	01000784 	movi	r4,30
81113838:	113c4280 	call	8113c428 <OSTaskStkChk>
8111383c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113840:	e0bffc03 	ldbu	r2,-16(fp)
81113844:	10000f1e 	bne	r2,zero,81113884 <vStackMonitor+0x140>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113848:	d1205e17 	ldw	r4,-32392(gp)
    				"TIMEOUT_CHECKER",
    				data.OSFree + data.OSUsed,
8111384c:	e0fffd17 	ldw	r3,-12(fp)
81113850:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( TIMEOUT_CHECKER_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113854:	188b883a 	add	r5,r3,r2
81113858:	e0bffd17 	ldw	r2,-12(fp)
8111385c:	e0fffe17 	ldw	r3,-8(fp)
81113860:	d8c00115 	stw	r3,4(sp)
81113864:	d8800015 	stw	r2,0(sp)
81113868:	280f883a 	mov	r7,r5
8111386c:	01a04574 	movhi	r6,33045
81113870:	31a74504 	addi	r6,r6,-25324
81113874:	01604574 	movhi	r5,33045
81113878:	29672c04 	addi	r5,r5,-25424
8111387c:	111ca180 	call	8111ca18 <fprintf>
81113880:	00000706 	br	811138a0 <vStackMonitor+0x15c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get TIMEOUT_CHECKER stack \n" );
81113884:	d0a05e17 	ldw	r2,-32392(gp)
81113888:	100f883a 	mov	r7,r2
8111388c:	01800984 	movi	r6,38
81113890:	01400044 	movi	r5,1
81113894:	01204574 	movhi	r4,33045
81113898:	21274904 	addi	r4,r4,-25308
8111389c:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
811138a0:	e0bffd04 	addi	r2,fp,-12
811138a4:	100b883a 	mov	r5,r2
811138a8:	01000704 	movi	r4,28
811138ac:	113c4280 	call	8113c428 <OSTaskStkChk>
811138b0:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
811138b4:	e0bffc03 	ldbu	r2,-16(fp)
811138b8:	10000f1e 	bne	r2,zero,811138f8 <vStackMonitor+0x1b4>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811138bc:	d1205e17 	ldw	r4,-32392(gp)
    				"PARSER_TASK",
    				data.OSFree + data.OSUsed,
811138c0:	e0fffd17 	ldw	r3,-12(fp)
811138c4:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( PARSER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811138c8:	188b883a 	add	r5,r3,r2
811138cc:	e0bffd17 	ldw	r2,-12(fp)
811138d0:	e0fffe17 	ldw	r3,-8(fp)
811138d4:	d8c00115 	stw	r3,4(sp)
811138d8:	d8800015 	stw	r2,0(sp)
811138dc:	280f883a 	mov	r7,r5
811138e0:	01a04574 	movhi	r6,33045
811138e4:	31a75304 	addi	r6,r6,-25268
811138e8:	01604574 	movhi	r5,33045
811138ec:	29672c04 	addi	r5,r5,-25424
811138f0:	111ca180 	call	8111ca18 <fprintf>
811138f4:	00000706 	br	81113914 <vStackMonitor+0x1d0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get PARSER_TASK stack \n" );
811138f8:	d0a05e17 	ldw	r2,-32392(gp)
811138fc:	100f883a 	mov	r7,r2
81113900:	01800884 	movi	r6,34
81113904:	01400044 	movi	r5,1
81113908:	01204574 	movhi	r4,33045
8111390c:	21275604 	addi	r4,r4,-25256
81113910:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
81113914:	e0bffd04 	addi	r2,fp,-12
81113918:	100b883a 	mov	r5,r2
8111391c:	010006c4 	movi	r4,27
81113920:	113c4280 	call	8113c428 <OSTaskStkChk>
81113924:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113928:	e0bffc03 	ldbu	r2,-16(fp)
8111392c:	10000f1e 	bne	r2,zero,8111396c <vStackMonitor+0x228>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113930:	d1205e17 	ldw	r4,-32392(gp)
    				"OUT_ACK_TASK",
    				data.OSFree + data.OSUsed,
81113934:	e0fffd17 	ldw	r3,-12(fp)
81113938:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( OUT_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
8111393c:	188b883a 	add	r5,r3,r2
81113940:	e0bffd17 	ldw	r2,-12(fp)
81113944:	e0fffe17 	ldw	r3,-8(fp)
81113948:	d8c00115 	stw	r3,4(sp)
8111394c:	d8800015 	stw	r2,0(sp)
81113950:	280f883a 	mov	r7,r5
81113954:	01a04574 	movhi	r6,33045
81113958:	31a75f04 	addi	r6,r6,-25220
8111395c:	01604574 	movhi	r5,33045
81113960:	29672c04 	addi	r5,r5,-25424
81113964:	111ca180 	call	8111ca18 <fprintf>
81113968:	00000706 	br	81113988 <vStackMonitor+0x244>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get OUT_ACK_TASK stack \n" );
8111396c:	d0a05e17 	ldw	r2,-32392(gp)
81113970:	100f883a 	mov	r7,r2
81113974:	018008c4 	movi	r6,35
81113978:	01400044 	movi	r5,1
8111397c:	01204574 	movhi	r4,33045
81113980:	21276304 	addi	r4,r4,-25204
81113984:	111d0b40 	call	8111d0b4 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
81113988:	e0bffd04 	addi	r2,fp,-12
8111398c:	100b883a 	mov	r5,r2
81113990:	01000684 	movi	r4,26
81113994:	113c4280 	call	8113c428 <OSTaskStkChk>
81113998:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
8111399c:	e0bffc03 	ldbu	r2,-16(fp)
811139a0:	10000f1e 	bne	r2,zero,811139e0 <vStackMonitor+0x29c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811139a4:	d1205e17 	ldw	r4,-32392(gp)
    				"SENDER_TASK",
    				data.OSFree + data.OSUsed,
811139a8:	e0fffd17 	ldw	r3,-12(fp)
811139ac:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( SENDER_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
811139b0:	188b883a 	add	r5,r3,r2
811139b4:	e0bffd17 	ldw	r2,-12(fp)
811139b8:	e0fffe17 	ldw	r3,-8(fp)
811139bc:	d8c00115 	stw	r3,4(sp)
811139c0:	d8800015 	stw	r2,0(sp)
811139c4:	280f883a 	mov	r7,r5
811139c8:	01a04574 	movhi	r6,33045
811139cc:	31a76c04 	addi	r6,r6,-25168
811139d0:	01604574 	movhi	r5,33045
811139d4:	29672c04 	addi	r5,r5,-25424
811139d8:	111ca180 	call	8111ca18 <fprintf>
811139dc:	00000706 	br	811139fc <vStackMonitor+0x2b8>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get SENDER_TASK stack \n" );
811139e0:	d0a05e17 	ldw	r2,-32392(gp)
811139e4:	100f883a 	mov	r7,r2
811139e8:	01800884 	movi	r6,34
811139ec:	01400044 	movi	r5,1
811139f0:	01204574 	movhi	r4,33045
811139f4:	21276f04 	addi	r4,r4,-25156
811139f8:	111d0b40 	call	8111d0b4 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
811139fc:	e0bffd04 	addi	r2,fp,-12
81113a00:	100b883a 	mov	r5,r2
81113a04:	01000644 	movi	r4,25
81113a08:	113c4280 	call	8113c428 <OSTaskStkChk>
81113a0c:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113a10:	e0bffc03 	ldbu	r2,-16(fp)
81113a14:	10000f1e 	bne	r2,zero,81113a54 <vStackMonitor+0x310>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113a18:	d1205e17 	ldw	r4,-32392(gp)
    				"IN_ACK_TASK",
    				data.OSFree + data.OSUsed,
81113a1c:	e0fffd17 	ldw	r3,-12(fp)
81113a20:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( IN_ACK_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113a24:	188b883a 	add	r5,r3,r2
81113a28:	e0bffd17 	ldw	r2,-12(fp)
81113a2c:	e0fffe17 	ldw	r3,-8(fp)
81113a30:	d8c00115 	stw	r3,4(sp)
81113a34:	d8800015 	stw	r2,0(sp)
81113a38:	280f883a 	mov	r7,r5
81113a3c:	01a04574 	movhi	r6,33045
81113a40:	31a77804 	addi	r6,r6,-25120
81113a44:	01604574 	movhi	r5,33045
81113a48:	29672c04 	addi	r5,r5,-25424
81113a4c:	111ca180 	call	8111ca18 <fprintf>
81113a50:	00000706 	br	81113a70 <vStackMonitor+0x32c>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get IN_ACK_TASK stack \n" );
81113a54:	d0a05e17 	ldw	r2,-32392(gp)
81113a58:	100f883a 	mov	r7,r2
81113a5c:	01800884 	movi	r6,34
81113a60:	01400044 	movi	r5,1
81113a64:	01204574 	movhi	r4,33045
81113a68:	21277b04 	addi	r4,r4,-25108
81113a6c:	111d0b40 	call	8111d0b4 <fwrite>
    	}

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
81113a70:	e0bffd04 	addi	r2,fp,-12
81113a74:	100b883a 	mov	r5,r2
81113a78:	01000044 	movi	r4,1
81113a7c:	113c4280 	call	8113c428 <OSTaskStkChk>
81113a80:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113a84:	e0bffc03 	ldbu	r2,-16(fp)
81113a88:	10000f1e 	bne	r2,zero,81113ac8 <vStackMonitor+0x384>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113a8c:	d1205e17 	ldw	r4,-32392(gp)
    				"INITI_TASK",
    				data.OSFree + data.OSUsed,
81113a90:	e0fffd17 	ldw	r3,-12(fp)
81113a94:	e0bffe17 	ldw	r2,-8(fp)

 
    	ucErrorCode = OSTaskStkChk( INITIALIZATION_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113a98:	188b883a 	add	r5,r3,r2
81113a9c:	e0bffd17 	ldw	r2,-12(fp)
81113aa0:	e0fffe17 	ldw	r3,-8(fp)
81113aa4:	d8c00115 	stw	r3,4(sp)
81113aa8:	d8800015 	stw	r2,0(sp)
81113aac:	280f883a 	mov	r7,r5
81113ab0:	01a04574 	movhi	r6,33045
81113ab4:	31a78404 	addi	r6,r6,-25072
81113ab8:	01604574 	movhi	r5,33045
81113abc:	29672c04 	addi	r5,r5,-25424
81113ac0:	111ca180 	call	8111ca18 <fprintf>
81113ac4:	00000706 	br	81113ae4 <vStackMonitor+0x3a0>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get INIT_TASK stack \n" );
81113ac8:	d0a05e17 	ldw	r2,-32392(gp)
81113acc:	100f883a 	mov	r7,r2
81113ad0:	01800804 	movi	r6,32
81113ad4:	01400044 	movi	r5,1
81113ad8:	01204574 	movhi	r4,33045
81113adc:	21278704 	addi	r4,r4,-25060
81113ae0:	111d0b40 	call	8111d0b4 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
81113ae4:	e0bffd04 	addi	r2,fp,-12
81113ae8:	100b883a 	mov	r5,r2
81113aec:	010002c4 	movi	r4,11
81113af0:	113c4280 	call	8113c428 <OSTaskStkChk>
81113af4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113af8:	e0bffc03 	ldbu	r2,-16(fp)
81113afc:	10000f1e 	bne	r2,zero,81113b3c <vStackMonitor+0x3f8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113b00:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_TASK-0",
    				data.OSFree + data.OSUsed,
81113b04:	e0fffd17 	ldw	r3,-12(fp)
81113b08:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113b0c:	188b883a 	add	r5,r3,r2
81113b10:	e0bffd17 	ldw	r2,-12(fp)
81113b14:	e0fffe17 	ldw	r3,-8(fp)
81113b18:	d8c00115 	stw	r3,4(sp)
81113b1c:	d8800015 	stw	r2,0(sp)
81113b20:	280f883a 	mov	r7,r5
81113b24:	01a04574 	movhi	r6,33045
81113b28:	31a79004 	addi	r6,r6,-25024
81113b2c:	01604574 	movhi	r5,33045
81113b30:	29672c04 	addi	r5,r5,-25424
81113b34:	111ca180 	call	8111ca18 <fprintf>
81113b38:	00000706 	br	81113b58 <vStackMonitor+0x414>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 0 stack \n" );
81113b3c:	d0a05e17 	ldw	r2,-32392(gp)
81113b40:	100f883a 	mov	r7,r2
81113b44:	018008c4 	movi	r6,35
81113b48:	01400044 	movi	r5,1
81113b4c:	01204574 	movhi	r4,33045
81113b50:	21279304 	addi	r4,r4,-25012
81113b54:	111d0b40 	call	8111d0b4 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
81113b58:	e0bffd04 	addi	r2,fp,-12
81113b5c:	100b883a 	mov	r5,r2
81113b60:	01000304 	movi	r4,12
81113b64:	113c4280 	call	8113c428 <OSTaskStkChk>
81113b68:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113b6c:	e0bffc03 	ldbu	r2,-16(fp)
81113b70:	10000f1e 	bne	r2,zero,81113bb0 <vStackMonitor+0x46c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113b74:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_TASK-1",
    				data.OSFree + data.OSUsed,
81113b78:	e0fffd17 	ldw	r3,-12(fp)
81113b7c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+1 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113b80:	188b883a 	add	r5,r3,r2
81113b84:	e0bffd17 	ldw	r2,-12(fp)
81113b88:	e0fffe17 	ldw	r3,-8(fp)
81113b8c:	d8c00115 	stw	r3,4(sp)
81113b90:	d8800015 	stw	r2,0(sp)
81113b94:	280f883a 	mov	r7,r5
81113b98:	01a04574 	movhi	r6,33045
81113b9c:	31a79c04 	addi	r6,r6,-24976
81113ba0:	01604574 	movhi	r5,33045
81113ba4:	29672c04 	addi	r5,r5,-25424
81113ba8:	111ca180 	call	8111ca18 <fprintf>
81113bac:	00000706 	br	81113bcc <vStackMonitor+0x488>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 1 stack \n" );
81113bb0:	d0a05e17 	ldw	r2,-32392(gp)
81113bb4:	100f883a 	mov	r7,r2
81113bb8:	018008c4 	movi	r6,35
81113bbc:	01400044 	movi	r5,1
81113bc0:	01204574 	movhi	r4,33045
81113bc4:	21279f04 	addi	r4,r4,-24964
81113bc8:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
81113bcc:	e0bffd04 	addi	r2,fp,-12
81113bd0:	100b883a 	mov	r5,r2
81113bd4:	01000344 	movi	r4,13
81113bd8:	113c4280 	call	8113c428 <OSTaskStkChk>
81113bdc:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113be0:	e0bffc03 	ldbu	r2,-16(fp)
81113be4:	10000f1e 	bne	r2,zero,81113c24 <vStackMonitor+0x4e0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113be8:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_TASK-2",
    				data.OSFree + data.OSUsed,
81113bec:	e0fffd17 	ldw	r3,-12(fp)
81113bf0:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+2 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113bf4:	188b883a 	add	r5,r3,r2
81113bf8:	e0bffd17 	ldw	r2,-12(fp)
81113bfc:	e0fffe17 	ldw	r3,-8(fp)
81113c00:	d8c00115 	stw	r3,4(sp)
81113c04:	d8800015 	stw	r2,0(sp)
81113c08:	280f883a 	mov	r7,r5
81113c0c:	01a04574 	movhi	r6,33045
81113c10:	31a7a804 	addi	r6,r6,-24928
81113c14:	01604574 	movhi	r5,33045
81113c18:	29672c04 	addi	r5,r5,-25424
81113c1c:	111ca180 	call	8111ca18 <fprintf>
81113c20:	00000706 	br	81113c40 <vStackMonitor+0x4fc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 2 stack \n" );
81113c24:	d0a05e17 	ldw	r2,-32392(gp)
81113c28:	100f883a 	mov	r7,r2
81113c2c:	018008c4 	movi	r6,35
81113c30:	01400044 	movi	r5,1
81113c34:	01204574 	movhi	r4,33045
81113c38:	2127ab04 	addi	r4,r4,-24916
81113c3c:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
81113c40:	e0bffd04 	addi	r2,fp,-12
81113c44:	100b883a 	mov	r5,r2
81113c48:	01000384 	movi	r4,14
81113c4c:	113c4280 	call	8113c428 <OSTaskStkChk>
81113c50:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113c54:	e0bffc03 	ldbu	r2,-16(fp)
81113c58:	10000f1e 	bne	r2,zero,81113c98 <vStackMonitor+0x554>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113c5c:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_TASK-3",
    				data.OSFree + data.OSUsed,
81113c60:	e0fffd17 	ldw	r3,-12(fp)
81113c64:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+3 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113c68:	188b883a 	add	r5,r3,r2
81113c6c:	e0bffd17 	ldw	r2,-12(fp)
81113c70:	e0fffe17 	ldw	r3,-8(fp)
81113c74:	d8c00115 	stw	r3,4(sp)
81113c78:	d8800015 	stw	r2,0(sp)
81113c7c:	280f883a 	mov	r7,r5
81113c80:	01a04574 	movhi	r6,33045
81113c84:	31a7b404 	addi	r6,r6,-24880
81113c88:	01604574 	movhi	r5,33045
81113c8c:	29672c04 	addi	r5,r5,-25424
81113c90:	111ca180 	call	8111ca18 <fprintf>
81113c94:	00000706 	br	81113cb4 <vStackMonitor+0x570>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 3 stack \n" );
81113c98:	d0a05e17 	ldw	r2,-32392(gp)
81113c9c:	100f883a 	mov	r7,r2
81113ca0:	018008c4 	movi	r6,35
81113ca4:	01400044 	movi	r5,1
81113ca8:	01204574 	movhi	r4,33045
81113cac:	2127b704 	addi	r4,r4,-24868
81113cb0:	111d0b40 	call	8111d0b4 <fwrite>
    	}



    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
81113cb4:	e0bffd04 	addi	r2,fp,-12
81113cb8:	100b883a 	mov	r5,r2
81113cbc:	010003c4 	movi	r4,15
81113cc0:	113c4280 	call	8113c428 <OSTaskStkChk>
81113cc4:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113cc8:	e0bffc03 	ldbu	r2,-16(fp)
81113ccc:	10000f1e 	bne	r2,zero,81113d0c <vStackMonitor+0x5c8>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113cd0:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_TASK-4",
    				data.OSFree + data.OSUsed,
81113cd4:	e0fffd17 	ldw	r3,-12(fp)
81113cd8:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+4 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113cdc:	188b883a 	add	r5,r3,r2
81113ce0:	e0bffd17 	ldw	r2,-12(fp)
81113ce4:	e0fffe17 	ldw	r3,-8(fp)
81113ce8:	d8c00115 	stw	r3,4(sp)
81113cec:	d8800015 	stw	r2,0(sp)
81113cf0:	280f883a 	mov	r7,r5
81113cf4:	01a04574 	movhi	r6,33045
81113cf8:	31a7c004 	addi	r6,r6,-24832
81113cfc:	01604574 	movhi	r5,33045
81113d00:	29672c04 	addi	r5,r5,-25424
81113d04:	111ca180 	call	8111ca18 <fprintf>
81113d08:	00000706 	br	81113d28 <vStackMonitor+0x5e4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 4 stack \n" );
81113d0c:	d0a05e17 	ldw	r2,-32392(gp)
81113d10:	100f883a 	mov	r7,r2
81113d14:	018008c4 	movi	r6,35
81113d18:	01400044 	movi	r5,1
81113d1c:	01204574 	movhi	r4,33045
81113d20:	2127c304 	addi	r4,r4,-24820
81113d24:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
81113d28:	e0bffd04 	addi	r2,fp,-12
81113d2c:	100b883a 	mov	r5,r2
81113d30:	01000404 	movi	r4,16
81113d34:	113c4280 	call	8113c428 <OSTaskStkChk>
81113d38:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113d3c:	e0bffc03 	ldbu	r2,-16(fp)
81113d40:	10000f1e 	bne	r2,zero,81113d80 <vStackMonitor+0x63c>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113d44:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_TASK-5",
    				data.OSFree + data.OSUsed,
81113d48:	e0fffd17 	ldw	r3,-12(fp)
81113d4c:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( NFEE_TASK_BASE_PRIO+5 , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113d50:	188b883a 	add	r5,r3,r2
81113d54:	e0bffd17 	ldw	r2,-12(fp)
81113d58:	e0fffe17 	ldw	r3,-8(fp)
81113d5c:	d8c00115 	stw	r3,4(sp)
81113d60:	d8800015 	stw	r2,0(sp)
81113d64:	280f883a 	mov	r7,r5
81113d68:	01a04574 	movhi	r6,33045
81113d6c:	31a7cc04 	addi	r6,r6,-24784
81113d70:	01604574 	movhi	r5,33045
81113d74:	29672c04 	addi	r5,r5,-25424
81113d78:	111ca180 	call	8111ca18 <fprintf>
81113d7c:	00000706 	br	81113d9c <vStackMonitor+0x658>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_TASK - 5 stack \n" );
81113d80:	d0a05e17 	ldw	r2,-32392(gp)
81113d84:	100f883a 	mov	r7,r2
81113d88:	018008c4 	movi	r6,35
81113d8c:	01400044 	movi	r5,1
81113d90:	01204574 	movhi	r4,33045
81113d94:	2127cf04 	addi	r4,r4,-24772
81113d98:	111d0b40 	call	8111d0b4 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
81113d9c:	e0bffd04 	addi	r2,fp,-12
81113da0:	100b883a 	mov	r5,r2
81113da4:	01000284 	movi	r4,10
81113da8:	113c4280 	call	8113c428 <OSTaskStkChk>
81113dac:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113db0:	e0bffc03 	ldbu	r2,-16(fp)
81113db4:	10000f1e 	bne	r2,zero,81113df4 <vStackMonitor+0x6b0>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113db8:	d1205e17 	ldw	r4,-32392(gp)
    				"DATA_COTROL",
    				data.OSFree + data.OSUsed,
81113dbc:	e0fffd17 	ldw	r3,-12(fp)
81113dc0:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( DATA_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113dc4:	188b883a 	add	r5,r3,r2
81113dc8:	e0bffd17 	ldw	r2,-12(fp)
81113dcc:	e0fffe17 	ldw	r3,-8(fp)
81113dd0:	d8c00115 	stw	r3,4(sp)
81113dd4:	d8800015 	stw	r2,0(sp)
81113dd8:	280f883a 	mov	r7,r5
81113ddc:	01a04574 	movhi	r6,33045
81113de0:	31a7d804 	addi	r6,r6,-24736
81113de4:	01604574 	movhi	r5,33045
81113de8:	29672c04 	addi	r5,r5,-25424
81113dec:	111ca180 	call	8111ca18 <fprintf>
81113df0:	00000706 	br	81113e10 <vStackMonitor+0x6cc>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get DATA_COTROL stack \n" );
81113df4:	d0a05e17 	ldw	r2,-32392(gp)
81113df8:	100f883a 	mov	r7,r2
81113dfc:	01800884 	movi	r6,34
81113e00:	01400044 	movi	r5,1
81113e04:	01204574 	movhi	r4,33045
81113e08:	2127db04 	addi	r4,r4,-24724
81113e0c:	111d0b40 	call	8111d0b4 <fwrite>
    	}


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
81113e10:	e0bffd04 	addi	r2,fp,-12
81113e14:	100b883a 	mov	r5,r2
81113e18:	01000244 	movi	r4,9
81113e1c:	113c4280 	call	8113c428 <OSTaskStkChk>
81113e20:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113e24:	e0bffc03 	ldbu	r2,-16(fp)
81113e28:	10000f1e 	bne	r2,zero,81113e68 <vStackMonitor+0x724>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113e2c:	d1205e17 	ldw	r4,-32392(gp)
    				"FEE_COTROL",
    				data.OSFree + data.OSUsed,
81113e30:	e0fffd17 	ldw	r3,-12(fp)
81113e34:	e0bffe17 	ldw	r2,-8(fp)


    	ucErrorCode = OSTaskStkChk( FEE_COTROL_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113e38:	188b883a 	add	r5,r3,r2
81113e3c:	e0bffd17 	ldw	r2,-12(fp)
81113e40:	e0fffe17 	ldw	r3,-8(fp)
81113e44:	d8c00115 	stw	r3,4(sp)
81113e48:	d8800015 	stw	r2,0(sp)
81113e4c:	280f883a 	mov	r7,r5
81113e50:	01a04574 	movhi	r6,33045
81113e54:	31a7e404 	addi	r6,r6,-24688
81113e58:	01604574 	movhi	r5,33045
81113e5c:	29672c04 	addi	r5,r5,-25424
81113e60:	111ca180 	call	8111ca18 <fprintf>
81113e64:	00000706 	br	81113e84 <vStackMonitor+0x740>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get FEE_COTROL stack \n" );
81113e68:	d0a05e17 	ldw	r2,-32392(gp)
81113e6c:	100f883a 	mov	r7,r2
81113e70:	01800844 	movi	r6,33
81113e74:	01400044 	movi	r5,1
81113e78:	01204574 	movhi	r4,33045
81113e7c:	2127e704 	addi	r4,r4,-24676
81113e80:	111d0b40 	call	8111d0b4 <fwrite>
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
81113e84:	e0bffd04 	addi	r2,fp,-12
81113e88:	100b883a 	mov	r5,r2
81113e8c:	01000204 	movi	r4,8
81113e90:	113c4280 	call	8113c428 <OSTaskStkChk>
81113e94:	e0bffc05 	stb	r2,-16(fp)
    	if ( ucErrorCode == OS_ERR_NONE  ) {
81113e98:	e0bffc03 	ldbu	r2,-16(fp)
81113e9c:	10000f1e 	bne	r2,zero,81113edc <vStackMonitor+0x798>

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113ea0:	d1205e17 	ldw	r4,-32392(gp)
    				"MEB_TASK",
    				data.OSFree + data.OSUsed,
81113ea4:	e0fffd17 	ldw	r3,-12(fp)
81113ea8:	e0bffe17 	ldw	r2,-8(fp)
    	}

    	ucErrorCode = OSTaskStkChk( MEB_TASK_PRIO , &data);
    	if ( ucErrorCode == OS_ERR_NONE  ) {

    		fprintf(fp, " %s           %4ld              %4ld              %4ld  \n",
81113eac:	188b883a 	add	r5,r3,r2
81113eb0:	e0bffd17 	ldw	r2,-12(fp)
81113eb4:	e0fffe17 	ldw	r3,-8(fp)
81113eb8:	d8c00115 	stw	r3,4(sp)
81113ebc:	d8800015 	stw	r2,0(sp)
81113ec0:	280f883a 	mov	r7,r5
81113ec4:	01a04574 	movhi	r6,33045
81113ec8:	31a7f004 	addi	r6,r6,-24640
81113ecc:	01604574 	movhi	r5,33045
81113ed0:	29672c04 	addi	r5,r5,-25424
81113ed4:	111ca180 	call	8111ca18 <fprintf>
81113ed8:	00000706 	br	81113ef8 <vStackMonitor+0x7b4>
    				data.OSFree + data.OSUsed,
                    data.OSFree,
                    data.OSUsed );

    	} else {
    		fprintf(fp, " Could not get MEB_TASK stack \n" );
81113edc:	d0a05e17 	ldw	r2,-32392(gp)
81113ee0:	100f883a 	mov	r7,r2
81113ee4:	018007c4 	movi	r6,31
81113ee8:	01400044 	movi	r5,1
81113eec:	01204574 	movhi	r4,33045
81113ef0:	2127f304 	addi	r4,r4,-24628
81113ef4:	111d0b40 	call	8111d0b4 <fwrite>
    	}		


    	fprintf(fp, "\n" );
81113ef8:	d0a05e17 	ldw	r2,-32392(gp)
81113efc:	100b883a 	mov	r5,r2
81113f00:	01000284 	movi	r4,10
81113f04:	111ca900 	call	8111ca90 <fputc>

    	OSTimeDlyHMSM(0, 0, 10, 0);
81113f08:	000f883a 	mov	r7,zero
81113f0c:	01800284 	movi	r6,10
81113f10:	000b883a 	mov	r5,zero
81113f14:	0009883a 	mov	r4,zero
81113f18:	113ca8c0 	call	8113ca8c <OSTimeDlyHMSM>
    }
81113f1c:	003e1806 	br	81113780 <__reset+0xfb0f3780>

81113f20 <vTimeoutCheckerTaskv2>:

#include "timeout_checker_ack_task.h"



void vTimeoutCheckerTaskv2(void *task_data) {
81113f20:	defffc04 	addi	sp,sp,-16
81113f24:	de00012e 	bgeu	sp,et,81113f2c <vTimeoutCheckerTaskv2+0xc>
81113f28:	003b68fa 	trap	3
81113f2c:	dfc00315 	stw	ra,12(sp)
81113f30:	df000215 	stw	fp,8(sp)
81113f34:	df000204 	addi	fp,sp,8
81113f38:	e13fff15 	stw	r4,-4(fp)
	INT8U ucErrorCode = 0;
81113f3c:	e03ffe05 	stb	zero,-8(fp)

    #ifdef DEBUG_ON
        debug(fp,"vTimeoutCheckerTask, enter task.\n");
81113f40:	d0a05e17 	ldw	r2,-32392(gp)
81113f44:	100f883a 	mov	r7,r2
81113f48:	01800844 	movi	r6,33
81113f4c:	01400044 	movi	r5,1
81113f50:	01204574 	movhi	r4,33045
81113f54:	2127fb04 	addi	r4,r4,-24596
81113f58:	111d0b40 	call	8111d0b4 <fwrite>
    #endif   

    for (;;) {
        OSSemPend(xSemTimeoutChecker, 0, &ucErrorCode);
81113f5c:	d0a06317 	ldw	r2,-32372(gp)
81113f60:	e1bffe04 	addi	r6,fp,-8
81113f64:	000b883a 	mov	r5,zero
81113f68:	1009883a 	mov	r4,r2
81113f6c:	113aaf40 	call	8113aaf4 <OSSemPend>
        if ( ucErrorCode == OS_NO_ERR ) {
81113f70:	e0bffe03 	ldbu	r2,-8(fp)
81113f74:	10803fcc 	andi	r2,r2,255
81113f78:	1000021e 	bne	r2,zero,81113f84 <vTimeoutCheckerTaskv2+0x64>
            /* Just check the restransmission buffer */
            vCheck();
81113f7c:	1113f8c0 	call	81113f8c <vCheck>
81113f80:	003ff606 	br	81113f5c <__reset+0xfb0f3f5c>
        } else {
            /* Should not get here, is a blocking semaphore for sync.*/
            vFailGetBlockingSemTimeoutTask();
81113f84:	11188600 	call	81118860 <vFailGetBlockingSemTimeoutTask>
        }
    }
81113f88:	003ff406 	br	81113f5c <__reset+0xfb0f3f5c>

81113f8c <vCheck>:
}


void vCheck( void ) {
81113f8c:	defffd04 	addi	sp,sp,-12
81113f90:	de00012e 	bgeu	sp,et,81113f98 <vCheck+0xc>
81113f94:	003b68fa 	trap	3
81113f98:	dfc00215 	stw	ra,8(sp)
81113f9c:	df000115 	stw	fp,4(sp)
81113fa0:	df000104 	addi	fp,sp,4
	INT8U ucErrorCode = 0;
81113fa4:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucHashVerification = 0;
81113fa8:	e03fff05 	stb	zero,-4(fp)

    ucHashVerification = 0;
81113fac:	e03fff05 	stb	zero,-4(fp)
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);
81113fb0:	d0a06483 	ldbu	r2,-32366(gp)
81113fb4:	10803fcc 	andi	r2,r2,255
81113fb8:	10800218 	cmpnei	r2,r2,8
81113fbc:	1000021e 	bne	r2,zero,81113fc8 <vCheck+0x3c>
81113fc0:	00c00104 	movi	r3,4
81113fc4:	00000106 	br	81113fcc <vCheck+0x40>
81113fc8:	0007883a 	mov	r3,zero
81113fcc:	d0a07103 	ldbu	r2,-32316(gp)
81113fd0:	10803fcc 	andi	r2,r2,255
81113fd4:	10800218 	cmpnei	r2,r2,8
81113fd8:	1000021e 	bne	r2,zero,81113fe4 <vCheck+0x58>
81113fdc:	00800084 	movi	r2,2
81113fe0:	00000106 	br	81113fe8 <vCheck+0x5c>
81113fe4:	0005883a 	mov	r2,zero
81113fe8:	1884b03a 	or	r2,r3,r2
81113fec:	1007883a 	mov	r3,r2
81113ff0:	d0a07143 	ldbu	r2,-32315(gp)
81113ff4:	10803fcc 	andi	r2,r2,255
81113ff8:	108001a0 	cmpeqi	r2,r2,6
81113ffc:	1884b03a 	or	r2,r3,r2
81114000:	1007883a 	mov	r3,r2
81114004:	e0bfff03 	ldbu	r2,-4(fp)
81114008:	1884b03a 	or	r2,r3,r2
8111400c:	e0bfff05 	stb	r2,-4(fp)

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
81114010:	e0bfff03 	ldbu	r2,-4(fp)
81114014:	108001d8 	cmpnei	r2,r2,7
81114018:	10003726 	beq	r2,zero,811140f8 <vCheck+0x16c>
        return;

    /* Try to get the Mutex of the UART */
	OSMutexPend(xTxUARTMutex, 0, &ucErrorCode); /* Blocking */
8111401c:	d0a07017 	ldw	r2,-32320(gp)
81114020:	e0ffff44 	addi	r3,fp,-3
81114024:	180d883a 	mov	r6,r3
81114028:	000b883a 	mov	r5,zero
8111402c:	1009883a 	mov	r4,r2
81114030:	1138ae80 	call	81138ae8 <OSMutexPend>
    if ( ucErrorCode != OS_NO_ERR ) {
81114034:	e0bfff43 	ldbu	r2,-3(fp)
81114038:	10803fcc 	andi	r2,r2,255
8111403c:	10000826 	beq	r2,zero,81114060 <vCheck+0xd4>
        /* Should never get here, is a blocking operation */
		#ifdef DEBUG_ON
			debug(fp,"Should never get here. Trying to get xTxUARTMutex. (vCheck)\n");
81114040:	d0a05e17 	ldw	r2,-32392(gp)
81114044:	100f883a 	mov	r7,r2
81114048:	01800f04 	movi	r6,60
8111404c:	01400044 	movi	r5,1
81114050:	01204574 	movhi	r4,33045
81114054:	21280404 	addi	r4,r4,-24560
81114058:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
        return;
8111405c:	00002706 	br	811140fc <vCheck+0x170>

    /* ---> At this point we have the Mutex of TX UART, let's try to get the mutex of all retransmission buffer. */


    /* There are any spot used in the xBuffer128? */
    if ( 0b00000001 != (0b00000001 & ucHashVerification ) )
81114060:	e0bfff03 	ldbu	r2,-4(fp)
81114064:	1080004c 	andi	r2,r2,1
81114068:	10803fcc 	andi	r2,r2,255
8111406c:	1000021e 	bne	r2,zero,81114078 <vCheck+0xec>
        vCheckRetransmission128();
81114070:	11141100 	call	81114110 <vCheckRetransmission128>
81114074:	00000506 	br	8111408c <vCheck+0x100>
    else
    	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128)); /* For consistency with SemCount128 */
81114078:	01800604 	movi	r6,24
8111407c:	000b883a 	mov	r5,zero
81114080:	012045b4 	movhi	r4,33046
81114084:	21293204 	addi	r4,r4,-23352
81114088:	111dc180 	call	8111dc18 <memset>


        /* There are any spot used in the xBuffer64? */
    if ( 0b00000010 != (0b00000010 & ucHashVerification ) )
8111408c:	e0bfff03 	ldbu	r2,-4(fp)
81114090:	1080008c 	andi	r2,r2,2
81114094:	10803fcc 	andi	r2,r2,255
81114098:	1000021e 	bne	r2,zero,811140a4 <vCheck+0x118>
        vCheckRetransmission64();
8111409c:	11143940 	call	81114394 <vCheckRetransmission64>
811140a0:	00000506 	br	811140b8 <vCheck+0x12c>
    else
        memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64)); /* For consistency with SemCount64 */
811140a4:	01800804 	movi	r6,32
811140a8:	000b883a 	mov	r5,zero
811140ac:	012045b4 	movhi	r4,33046
811140b0:	21293804 	addi	r4,r4,-23328
811140b4:	111dc180 	call	8111dc18 <memset>

    /* There are any spot used in the xBuffer32? */
    if ( 0b00000100 != (0b00000100 & ucHashVerification ) )
811140b8:	e0bfff03 	ldbu	r2,-4(fp)
811140bc:	1080010c 	andi	r2,r2,4
811140c0:	10803fcc 	andi	r2,r2,255
811140c4:	1000021e 	bne	r2,zero,811140d0 <vCheck+0x144>
        vCheckRetransmission32();
811140c8:	11146200 	call	81114620 <vCheckRetransmission32>
811140cc:	00000506 	br	811140e4 <vCheck+0x158>
    else
    	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32)); /* For consistency with SemCount32 */
811140d0:	01800804 	movi	r6,32
811140d4:	000b883a 	mov	r5,zero
811140d8:	012045b4 	movhi	r4,33046
811140dc:	21294004 	addi	r4,r4,-23296
811140e0:	111dc180 	call	8111dc18 <memset>


    OSMutexPost(xTxUARTMutex);
811140e4:	d0a07017 	ldw	r2,-32320(gp)
811140e8:	1009883a 	mov	r4,r2
811140ec:	113908c0 	call	8113908c <OSMutexPost>

    return;
811140f0:	0001883a 	nop
811140f4:	00000106 	br	811140fc <vCheck+0x170>
    ucHashVerification = 0;
    ucHashVerification |= (( SemCount32 == N_32 ) << 2) | ( ( SemCount64 == N_64 ) << 1 ) | (( SemCount128 == N_128 ) << 0);

    /* Nothing in the (re)transmission buffer */
    if ( ucHashVerification == 0b00000111 )
        return;
811140f8:	0001883a 	nop


    OSMutexPost(xTxUARTMutex);

    return;
}
811140fc:	e037883a 	mov	sp,fp
81114100:	dfc00117 	ldw	ra,4(sp)
81114104:	df000017 	ldw	fp,0(sp)
81114108:	dec00204 	addi	sp,sp,8
8111410c:	f800283a 	ret

81114110 <vCheckRetransmission128>:

inline void vCheckRetransmission128( void ) {
81114110:	defffd04 	addi	sp,sp,-12
81114114:	de00012e 	bgeu	sp,et,8111411c <vCheckRetransmission128+0xc>
81114118:	003b68fa 	trap	3
8111411c:	dfc00215 	stw	ra,8(sp)
81114120:	df000115 	stw	fp,4(sp)
81114124:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81114128:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
8111412c:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81114130:	d0a06a17 	ldw	r2,-32344(gp)
81114134:	e0ffff44 	addi	r3,fp,-3
81114138:	180b883a 	mov	r5,r3
8111413c:	1009883a 	mov	r4,r2
81114140:	11384680 	call	81138468 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81114144:	e0bfff43 	ldbu	r2,-3(fp)
81114148:	10803fcc 	andi	r2,r2,255
8111414c:	10008b1e 	bne	r2,zero,8111437c <vCheckRetransmission128+0x26c>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81114150:	e03fff05 	stb	zero,-4(fp)
81114154:	00008106 	br	8111435c <vCheckRetransmission128+0x24c>
        /* Check if in use */
        if ( xInUseRetrans.b128[ucIL] == TRUE ) {
81114158:	e0ffff03 	ldbu	r3,-4(fp)
8111415c:	00a045b4 	movhi	r2,33046
81114160:	10a93204 	addi	r2,r2,-23352
81114164:	18c7883a 	add	r3,r3,r3
81114168:	18c7883a 	add	r3,r3,r3
8111416c:	10c5883a 	add	r2,r2,r3
81114170:	10800017 	ldw	r2,0(r2)
81114174:	10800058 	cmpnei	r2,r2,1
81114178:	1000751e 	bne	r2,zero,81114350 <vCheckRetransmission128+0x240>

            if ( xBuffer128[ucIL].bSent == TRUE )
8111417c:	e0ffff03 	ldbu	r3,-4(fp)
81114180:	00a045b4 	movhi	r2,33046
81114184:	10a95004 	addi	r2,r2,-23232
81114188:	18c02324 	muli	r3,r3,140
8111418c:	10c5883a 	add	r2,r2,r3
81114190:	10802004 	addi	r2,r2,128
81114194:	10800017 	ldw	r2,0(r2)
81114198:	10800058 	cmpnei	r2,r2,1
8111419c:	1000211e 	bne	r2,zero,81114224 <vCheckRetransmission128+0x114>
                if ( ++xBuffer128[ucIL].usiTimeOut > TIMEOUT_COUNT )
811141a0:	e0ffff03 	ldbu	r3,-4(fp)
811141a4:	00a045b4 	movhi	r2,33046
811141a8:	10a95004 	addi	r2,r2,-23232
811141ac:	19002324 	muli	r4,r3,140
811141b0:	1105883a 	add	r2,r2,r4
811141b4:	10802184 	addi	r2,r2,134
811141b8:	1080000b 	ldhu	r2,0(r2)
811141bc:	10800044 	addi	r2,r2,1
811141c0:	100b883a 	mov	r5,r2
811141c4:	00a045b4 	movhi	r2,33046
811141c8:	10a95004 	addi	r2,r2,-23232
811141cc:	19002324 	muli	r4,r3,140
811141d0:	1105883a 	add	r2,r2,r4
811141d4:	10802184 	addi	r2,r2,134
811141d8:	1140000d 	sth	r5,0(r2)
811141dc:	00a045b4 	movhi	r2,33046
811141e0:	10a95004 	addi	r2,r2,-23232
811141e4:	18c02324 	muli	r3,r3,140
811141e8:	10c5883a 	add	r2,r2,r3
811141ec:	10802184 	addi	r2,r2,134
811141f0:	1080000b 	ldhu	r2,0(r2)
811141f4:	10bfffcc 	andi	r2,r2,65535
811141f8:	10a0001c 	xori	r2,r2,32768
811141fc:	10a00004 	addi	r2,r2,-32768
81114200:	10800090 	cmplti	r2,r2,2
81114204:	1000071e 	bne	r2,zero,81114224 <vCheckRetransmission128+0x114>
                    xBuffer128[ucIL].bSent = FALSE;
81114208:	e0ffff03 	ldbu	r3,-4(fp)
8111420c:	00a045b4 	movhi	r2,33046
81114210:	10a95004 	addi	r2,r2,-23232
81114214:	18c02324 	muli	r3,r3,140
81114218:	10c5883a 	add	r2,r2,r3
8111421c:	10802004 	addi	r2,r2,128
81114220:	10000015 	stw	zero,0(r2)

            if ( xBuffer128[ucIL].bSent == FALSE ) {
81114224:	e0ffff03 	ldbu	r3,-4(fp)
81114228:	00a045b4 	movhi	r2,33046
8111422c:	10a95004 	addi	r2,r2,-23232
81114230:	18c02324 	muli	r3,r3,140
81114234:	10c5883a 	add	r2,r2,r3
81114238:	10802004 	addi	r2,r2,128
8111423c:	10800017 	ldw	r2,0(r2)
81114240:	1000431e 	bne	r2,zero,81114350 <vCheckRetransmission128+0x240>
                puts(xBuffer128[ucIL].buffer);
81114244:	e0bfff03 	ldbu	r2,-4(fp)
81114248:	10c02324 	muli	r3,r2,140
8111424c:	00a045b4 	movhi	r2,33046
81114250:	10a95004 	addi	r2,r2,-23232
81114254:	1885883a 	add	r2,r3,r2
81114258:	1009883a 	mov	r4,r2
8111425c:	111e0640 	call	8111e064 <puts>
                xBuffer128[ucIL].bSent = TRUE;
81114260:	e0ffff03 	ldbu	r3,-4(fp)
81114264:	00a045b4 	movhi	r2,33046
81114268:	10a95004 	addi	r2,r2,-23232
8111426c:	18c02324 	muli	r3,r3,140
81114270:	10c5883a 	add	r2,r2,r3
81114274:	10802004 	addi	r2,r2,128
81114278:	00c00044 	movi	r3,1
8111427c:	10c00015 	stw	r3,0(r2)
                xBuffer128[ucIL].usiTimeOut = 0;
81114280:	e0ffff03 	ldbu	r3,-4(fp)
81114284:	00a045b4 	movhi	r2,33046
81114288:	10a95004 	addi	r2,r2,-23232
8111428c:	18c02324 	muli	r3,r3,140
81114290:	10c5883a 	add	r2,r2,r3
81114294:	10802184 	addi	r2,r2,134
81114298:	1000000d 	sth	zero,0(r2)

                /* Check if already tried all the times */
                if ( ++xBuffer128[ucIL].ucNofRetries > N_RETRIES_COMM ) {
8111429c:	e0ffff03 	ldbu	r3,-4(fp)
811142a0:	00a045b4 	movhi	r2,33046
811142a4:	10a95004 	addi	r2,r2,-23232
811142a8:	19002324 	muli	r4,r3,140
811142ac:	1105883a 	add	r2,r2,r4
811142b0:	10802204 	addi	r2,r2,136
811142b4:	10800003 	ldbu	r2,0(r2)
811142b8:	10800044 	addi	r2,r2,1
811142bc:	100b883a 	mov	r5,r2
811142c0:	00a045b4 	movhi	r2,33046
811142c4:	10a95004 	addi	r2,r2,-23232
811142c8:	19002324 	muli	r4,r3,140
811142cc:	1105883a 	add	r2,r2,r4
811142d0:	10802204 	addi	r2,r2,136
811142d4:	11400005 	stb	r5,0(r2)
811142d8:	00a045b4 	movhi	r2,33046
811142dc:	10a95004 	addi	r2,r2,-23232
811142e0:	18c02324 	muli	r3,r3,140
811142e4:	10c5883a 	add	r2,r2,r3
811142e8:	10802204 	addi	r2,r2,136
811142ec:	10800003 	ldbu	r2,0(r2)
811142f0:	10803fcc 	andi	r2,r2,255
811142f4:	108000b0 	cmpltui	r2,r2,2
811142f8:	1000151e 	bne	r2,zero,81114350 <vCheckRetransmission128+0x240>
                    /* Now it is a Free place */
                    xInUseRetrans.b128[ucIL] = FALSE;
811142fc:	e0ffff03 	ldbu	r3,-4(fp)
81114300:	00a045b4 	movhi	r2,33046
81114304:	10a93204 	addi	r2,r2,-23352
81114308:	18c7883a 	add	r3,r3,r3
8111430c:	18c7883a 	add	r3,r3,r3
81114310:	10c5883a 	add	r2,r2,r3
81114314:	10000015 	stw	zero,0(r2)
                    SemCount128++;
81114318:	d0a07143 	ldbu	r2,-32315(gp)
8111431c:	10800044 	addi	r2,r2,1
81114320:	d0a07145 	stb	r2,-32315(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer128);
81114324:	d0a05f17 	ldw	r2,-32388(gp)
81114328:	1009883a 	mov	r4,r2
8111432c:	113ae7c0 	call	8113ae7c <OSSemPost>
81114330:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81114334:	e0bfff43 	ldbu	r2,-3(fp)
81114338:	10803fcc 	andi	r2,r2,255
8111433c:	10000426 	beq	r2,zero,81114350 <vCheckRetransmission128+0x240>
                        SemCount128--;
81114340:	d0a07143 	ldbu	r2,-32315(gp)
81114344:	10bfffc4 	addi	r2,r2,-1
81114348:	d0a07145 	stb	r2,-32315(gp)
                        vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
8111434c:	11181500 	call	81118150 <vFailSetCountSemaphorexBuffer128>
    

    /* ---> At this point we have access to the xBuffer128*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_128; ucIL++) {
81114350:	e0bfff03 	ldbu	r2,-4(fp)
81114354:	10800044 	addi	r2,r2,1
81114358:	e0bfff05 	stb	r2,-4(fp)
8111435c:	e0bfff03 	ldbu	r2,-4(fp)
81114360:	108001b0 	cmpltui	r2,r2,6
81114364:	103f7c1e 	bne	r2,zero,81114158 <__reset+0xfb0f4158>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer128);
81114368:	d0a06a17 	ldw	r2,-32344(gp)
8111436c:	1009883a 	mov	r4,r2
81114370:	113908c0 	call	8113908c <OSMutexPost>

    return;
81114374:	0001883a 	nop
81114378:	00000106 	br	81114380 <vCheckRetransmission128+0x270>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer128, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
8111437c:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer128);

    return;
}
81114380:	e037883a 	mov	sp,fp
81114384:	dfc00117 	ldw	ra,4(sp)
81114388:	df000017 	ldw	fp,0(sp)
8111438c:	dec00204 	addi	sp,sp,8
81114390:	f800283a 	ret

81114394 <vCheckRetransmission64>:

inline void vCheckRetransmission64( void ) {
81114394:	defffd04 	addi	sp,sp,-12
81114398:	de00012e 	bgeu	sp,et,811143a0 <vCheckRetransmission64+0xc>
8111439c:	003b68fa 	trap	3
811143a0:	dfc00215 	stw	ra,8(sp)
811143a4:	df000115 	stw	fp,4(sp)
811143a8:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
811143ac:	e03fff45 	stb	zero,-3(fp)
    unsigned char ucIL = 0;
811143b0:	e03fff05 	stb	zero,-4(fp)

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
811143b4:	d0a06d17 	ldw	r2,-32332(gp)
811143b8:	e0ffff44 	addi	r3,fp,-3
811143bc:	180b883a 	mov	r5,r3
811143c0:	1009883a 	mov	r4,r2
811143c4:	11384680 	call	81138468 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
811143c8:	e0bfff43 	ldbu	r2,-3(fp)
811143cc:	10803fcc 	andi	r2,r2,255
811143d0:	10008d1e 	bne	r2,zero,81114608 <vCheckRetransmission64+0x274>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811143d4:	e03fff05 	stb	zero,-4(fp)
811143d8:	00008306 	br	811145e8 <vCheckRetransmission64+0x254>
        /* Check if in use */
        if ( xInUseRetrans.b64[ucIL] == TRUE ) {
811143dc:	e0ffff03 	ldbu	r3,-4(fp)
811143e0:	00a045b4 	movhi	r2,33046
811143e4:	10a93204 	addi	r2,r2,-23352
811143e8:	18c00184 	addi	r3,r3,6
811143ec:	18c7883a 	add	r3,r3,r3
811143f0:	18c7883a 	add	r3,r3,r3
811143f4:	10c5883a 	add	r2,r2,r3
811143f8:	10800017 	ldw	r2,0(r2)
811143fc:	10800058 	cmpnei	r2,r2,1
81114400:	1000761e 	bne	r2,zero,811145dc <vCheckRetransmission64+0x248>

            if ( xBuffer64[ucIL].bSent == TRUE )
81114404:	e0ffff03 	ldbu	r3,-4(fp)
81114408:	00a04574 	movhi	r2,33045
8111440c:	10851104 	addi	r2,r2,5188
81114410:	18c01324 	muli	r3,r3,76
81114414:	10c5883a 	add	r2,r2,r3
81114418:	10801004 	addi	r2,r2,64
8111441c:	10800017 	ldw	r2,0(r2)
81114420:	10800058 	cmpnei	r2,r2,1
81114424:	1000211e 	bne	r2,zero,811144ac <vCheckRetransmission64+0x118>
                if ( ++xBuffer64[ucIL].usiTimeOut > TIMEOUT_COUNT )
81114428:	e0ffff03 	ldbu	r3,-4(fp)
8111442c:	00a04574 	movhi	r2,33045
81114430:	10851104 	addi	r2,r2,5188
81114434:	19001324 	muli	r4,r3,76
81114438:	1105883a 	add	r2,r2,r4
8111443c:	10801184 	addi	r2,r2,70
81114440:	1080000b 	ldhu	r2,0(r2)
81114444:	10800044 	addi	r2,r2,1
81114448:	100b883a 	mov	r5,r2
8111444c:	00a04574 	movhi	r2,33045
81114450:	10851104 	addi	r2,r2,5188
81114454:	19001324 	muli	r4,r3,76
81114458:	1105883a 	add	r2,r2,r4
8111445c:	10801184 	addi	r2,r2,70
81114460:	1140000d 	sth	r5,0(r2)
81114464:	00a04574 	movhi	r2,33045
81114468:	10851104 	addi	r2,r2,5188
8111446c:	18c01324 	muli	r3,r3,76
81114470:	10c5883a 	add	r2,r2,r3
81114474:	10801184 	addi	r2,r2,70
81114478:	1080000b 	ldhu	r2,0(r2)
8111447c:	10bfffcc 	andi	r2,r2,65535
81114480:	10a0001c 	xori	r2,r2,32768
81114484:	10a00004 	addi	r2,r2,-32768
81114488:	10800090 	cmplti	r2,r2,2
8111448c:	1000071e 	bne	r2,zero,811144ac <vCheckRetransmission64+0x118>
                    xBuffer64[ucIL].bSent = FALSE;
81114490:	e0ffff03 	ldbu	r3,-4(fp)
81114494:	00a04574 	movhi	r2,33045
81114498:	10851104 	addi	r2,r2,5188
8111449c:	18c01324 	muli	r3,r3,76
811144a0:	10c5883a 	add	r2,r2,r3
811144a4:	10801004 	addi	r2,r2,64
811144a8:	10000015 	stw	zero,0(r2)

            if ( xBuffer64[ucIL].bSent == FALSE ) {
811144ac:	e0ffff03 	ldbu	r3,-4(fp)
811144b0:	00a04574 	movhi	r2,33045
811144b4:	10851104 	addi	r2,r2,5188
811144b8:	18c01324 	muli	r3,r3,76
811144bc:	10c5883a 	add	r2,r2,r3
811144c0:	10801004 	addi	r2,r2,64
811144c4:	10800017 	ldw	r2,0(r2)
811144c8:	1000441e 	bne	r2,zero,811145dc <vCheckRetransmission64+0x248>
                puts(xBuffer64[ucIL].buffer);
811144cc:	e0bfff03 	ldbu	r2,-4(fp)
811144d0:	10c01324 	muli	r3,r2,76
811144d4:	00a04574 	movhi	r2,33045
811144d8:	10851104 	addi	r2,r2,5188
811144dc:	1885883a 	add	r2,r3,r2
811144e0:	1009883a 	mov	r4,r2
811144e4:	111e0640 	call	8111e064 <puts>
                xBuffer64[ucIL].bSent = TRUE;
811144e8:	e0ffff03 	ldbu	r3,-4(fp)
811144ec:	00a04574 	movhi	r2,33045
811144f0:	10851104 	addi	r2,r2,5188
811144f4:	18c01324 	muli	r3,r3,76
811144f8:	10c5883a 	add	r2,r2,r3
811144fc:	10801004 	addi	r2,r2,64
81114500:	00c00044 	movi	r3,1
81114504:	10c00015 	stw	r3,0(r2)
                xBuffer64[ucIL].usiTimeOut = 0;
81114508:	e0ffff03 	ldbu	r3,-4(fp)
8111450c:	00a04574 	movhi	r2,33045
81114510:	10851104 	addi	r2,r2,5188
81114514:	18c01324 	muli	r3,r3,76
81114518:	10c5883a 	add	r2,r2,r3
8111451c:	10801184 	addi	r2,r2,70
81114520:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */
                if ( ++xBuffer64[ucIL].ucNofRetries > N_RETRIES_COMM ) {
81114524:	e0ffff03 	ldbu	r3,-4(fp)
81114528:	00a04574 	movhi	r2,33045
8111452c:	10851104 	addi	r2,r2,5188
81114530:	19001324 	muli	r4,r3,76
81114534:	1105883a 	add	r2,r2,r4
81114538:	10801204 	addi	r2,r2,72
8111453c:	10800003 	ldbu	r2,0(r2)
81114540:	10800044 	addi	r2,r2,1
81114544:	100b883a 	mov	r5,r2
81114548:	00a04574 	movhi	r2,33045
8111454c:	10851104 	addi	r2,r2,5188
81114550:	19001324 	muli	r4,r3,76
81114554:	1105883a 	add	r2,r2,r4
81114558:	10801204 	addi	r2,r2,72
8111455c:	11400005 	stb	r5,0(r2)
81114560:	00a04574 	movhi	r2,33045
81114564:	10851104 	addi	r2,r2,5188
81114568:	18c01324 	muli	r3,r3,76
8111456c:	10c5883a 	add	r2,r2,r3
81114570:	10801204 	addi	r2,r2,72
81114574:	10800003 	ldbu	r2,0(r2)
81114578:	10803fcc 	andi	r2,r2,255
8111457c:	108000b0 	cmpltui	r2,r2,2
81114580:	1000161e 	bne	r2,zero,811145dc <vCheckRetransmission64+0x248>
                    /* Now it is a Free place */
                    xInUseRetrans.b64[ucIL] = FALSE;
81114584:	e0ffff03 	ldbu	r3,-4(fp)
81114588:	00a045b4 	movhi	r2,33046
8111458c:	10a93204 	addi	r2,r2,-23352
81114590:	18c00184 	addi	r3,r3,6
81114594:	18c7883a 	add	r3,r3,r3
81114598:	18c7883a 	add	r3,r3,r3
8111459c:	10c5883a 	add	r2,r2,r3
811145a0:	10000015 	stw	zero,0(r2)
                    SemCount64++;
811145a4:	d0a07103 	ldbu	r2,-32316(gp)
811145a8:	10800044 	addi	r2,r2,1
811145ac:	d0a07105 	stb	r2,-32316(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer64);
811145b0:	d0a05a17 	ldw	r2,-32408(gp)
811145b4:	1009883a 	mov	r4,r2
811145b8:	113ae7c0 	call	8113ae7c <OSSemPost>
811145bc:	e0bfff45 	stb	r2,-3(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
811145c0:	e0bfff43 	ldbu	r2,-3(fp)
811145c4:	10803fcc 	andi	r2,r2,255
811145c8:	10000426 	beq	r2,zero,811145dc <vCheckRetransmission64+0x248>
                        SemCount64--;
811145cc:	d0a07103 	ldbu	r2,-32316(gp)
811145d0:	10bfffc4 	addi	r2,r2,-1
811145d4:	d0a07105 	stb	r2,-32316(gp)
                        vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
811145d8:	11180e80 	call	811180e8 <vFailSetCountSemaphorexBuffer64>
    

    /* ---> At this point we have access to the xBuffer64*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_64; ucIL++) {
811145dc:	e0bfff03 	ldbu	r2,-4(fp)
811145e0:	10800044 	addi	r2,r2,1
811145e4:	e0bfff05 	stb	r2,-4(fp)
811145e8:	e0bfff03 	ldbu	r2,-4(fp)
811145ec:	10800230 	cmpltui	r2,r2,8
811145f0:	103f7a1e 	bne	r2,zero,811143dc <__reset+0xfb0f43dc>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer64);
811145f4:	d0a06d17 	ldw	r2,-32332(gp)
811145f8:	1009883a 	mov	r4,r2
811145fc:	113908c0 	call	8113908c <OSMutexPost>

    return;
81114600:	0001883a 	nop
81114604:	00000106 	br	8111460c <vCheckRetransmission64+0x278>
    unsigned char ucIL = 0;

    OSMutexAccept(xMutexBuffer64, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
81114608:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer64);

    return;
}
8111460c:	e037883a 	mov	sp,fp
81114610:	dfc00117 	ldw	ra,4(sp)
81114614:	df000017 	ldw	fp,0(sp)
81114618:	dec00204 	addi	sp,sp,8
8111461c:	f800283a 	ret

81114620 <vCheckRetransmission32>:


inline void vCheckRetransmission32( void ) {
81114620:	defffd04 	addi	sp,sp,-12
81114624:	de00012e 	bgeu	sp,et,8111462c <vCheckRetransmission32+0xc>
81114628:	003b68fa 	trap	3
8111462c:	dfc00215 	stw	ra,8(sp)
81114630:	df000115 	stw	fp,4(sp)
81114634:	df000104 	addi	fp,sp,4
    INT8U ucErrorCodeL = 0;
81114638:	e03fff85 	stb	zero,-2(fp)
    unsigned char ucIL = 0;
8111463c:	e03fff05 	stb	zero,-4(fp)
    unsigned char ucMax = 0;
81114640:	e03fff45 	stb	zero,-3(fp)

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
81114644:	d0a06817 	ldw	r2,-32352(gp)
81114648:	e0ffff84 	addi	r3,fp,-2
8111464c:	180b883a 	mov	r5,r3
81114650:	1009883a 	mov	r4,r2
81114654:	11384680 	call	81138468 <OSMutexAccept>
    if ( ucErrorCodeL != OS_NO_ERR ) {
81114658:	e0bfff83 	ldbu	r2,-2(fp)
8111465c:	10803fcc 	andi	r2,r2,255
81114660:	10009b1e 	bne	r2,zero,811148d0 <vCheckRetransmission32+0x2b0>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
81114664:	e03fff05 	stb	zero,-4(fp)
81114668:	00009106 	br	811148b0 <vCheckRetransmission32+0x290>
        /* Check if in use */
        if ( xInUseRetrans.b32[ucIL] == TRUE ) {
8111466c:	e0ffff03 	ldbu	r3,-4(fp)
81114670:	00a045b4 	movhi	r2,33046
81114674:	10a93204 	addi	r2,r2,-23352
81114678:	18c00384 	addi	r3,r3,14
8111467c:	18c7883a 	add	r3,r3,r3
81114680:	18c7883a 	add	r3,r3,r3
81114684:	10c5883a 	add	r2,r2,r3
81114688:	10800017 	ldw	r2,0(r2)
8111468c:	10800058 	cmpnei	r2,r2,1
81114690:	1000841e 	bne	r2,zero,811148a4 <vCheckRetransmission32+0x284>

            if ( xBuffer32[ucIL].bSent == TRUE )
81114694:	e0ffff03 	ldbu	r3,-4(fp)
81114698:	00a04574 	movhi	r2,33045
8111469c:	1096be04 	addi	r2,r2,23288
811146a0:	18c00b24 	muli	r3,r3,44
811146a4:	10c5883a 	add	r2,r2,r3
811146a8:	10800804 	addi	r2,r2,32
811146ac:	10800017 	ldw	r2,0(r2)
811146b0:	10800058 	cmpnei	r2,r2,1
811146b4:	1000211e 	bne	r2,zero,8111473c <vCheckRetransmission32+0x11c>
                if ( ++xBuffer32[ucIL].usiTimeOut > TIMEOUT_COUNT )
811146b8:	e0ffff03 	ldbu	r3,-4(fp)
811146bc:	00a04574 	movhi	r2,33045
811146c0:	1096be04 	addi	r2,r2,23288
811146c4:	19000b24 	muli	r4,r3,44
811146c8:	1105883a 	add	r2,r2,r4
811146cc:	10800984 	addi	r2,r2,38
811146d0:	1080000b 	ldhu	r2,0(r2)
811146d4:	10800044 	addi	r2,r2,1
811146d8:	100b883a 	mov	r5,r2
811146dc:	00a04574 	movhi	r2,33045
811146e0:	1096be04 	addi	r2,r2,23288
811146e4:	19000b24 	muli	r4,r3,44
811146e8:	1105883a 	add	r2,r2,r4
811146ec:	10800984 	addi	r2,r2,38
811146f0:	1140000d 	sth	r5,0(r2)
811146f4:	00a04574 	movhi	r2,33045
811146f8:	1096be04 	addi	r2,r2,23288
811146fc:	18c00b24 	muli	r3,r3,44
81114700:	10c5883a 	add	r2,r2,r3
81114704:	10800984 	addi	r2,r2,38
81114708:	1080000b 	ldhu	r2,0(r2)
8111470c:	10bfffcc 	andi	r2,r2,65535
81114710:	10a0001c 	xori	r2,r2,32768
81114714:	10a00004 	addi	r2,r2,-32768
81114718:	10800090 	cmplti	r2,r2,2
8111471c:	1000071e 	bne	r2,zero,8111473c <vCheckRetransmission32+0x11c>
                    xBuffer32[ucIL].bSent = FALSE;
81114720:	e0ffff03 	ldbu	r3,-4(fp)
81114724:	00a04574 	movhi	r2,33045
81114728:	1096be04 	addi	r2,r2,23288
8111472c:	18c00b24 	muli	r3,r3,44
81114730:	10c5883a 	add	r2,r2,r3
81114734:	10800804 	addi	r2,r2,32
81114738:	10000015 	stw	zero,0(r2)

            if ( xBuffer32[ucIL].bSent == FALSE ) {
8111473c:	e0ffff03 	ldbu	r3,-4(fp)
81114740:	00a04574 	movhi	r2,33045
81114744:	1096be04 	addi	r2,r2,23288
81114748:	18c00b24 	muli	r3,r3,44
8111474c:	10c5883a 	add	r2,r2,r3
81114750:	10800804 	addi	r2,r2,32
81114754:	10800017 	ldw	r2,0(r2)
81114758:	1000521e 	bne	r2,zero,811148a4 <vCheckRetransmission32+0x284>
                puts(xBuffer32[ucIL].buffer);
8111475c:	e0bfff03 	ldbu	r2,-4(fp)
81114760:	10c00b24 	muli	r3,r2,44
81114764:	00a04574 	movhi	r2,33045
81114768:	1096be04 	addi	r2,r2,23288
8111476c:	1885883a 	add	r2,r3,r2
81114770:	1009883a 	mov	r4,r2
81114774:	111e0640 	call	8111e064 <puts>
                xBuffer32[ucIL].bSent = TRUE;
81114778:	e0ffff03 	ldbu	r3,-4(fp)
8111477c:	00a04574 	movhi	r2,33045
81114780:	1096be04 	addi	r2,r2,23288
81114784:	18c00b24 	muli	r3,r3,44
81114788:	10c5883a 	add	r2,r2,r3
8111478c:	10800804 	addi	r2,r2,32
81114790:	00c00044 	movi	r3,1
81114794:	10c00015 	stw	r3,0(r2)
                xBuffer32[ucIL].usiTimeOut = 0;
81114798:	e0ffff03 	ldbu	r3,-4(fp)
8111479c:	00a04574 	movhi	r2,33045
811147a0:	1096be04 	addi	r2,r2,23288
811147a4:	18c00b24 	muli	r3,r3,44
811147a8:	10c5883a 	add	r2,r2,r3
811147ac:	10800984 	addi	r2,r2,38
811147b0:	1000000d 	sth	zero,0(r2)
                /* Check if already tried all the times */

                ucMax = ( xBuffer32[ucIL].usiId == 1 ) ? N_RETRIES_INI_INF : N_RETRIES_COMM;
811147b4:	e0ffff03 	ldbu	r3,-4(fp)
811147b8:	00a04574 	movhi	r2,33045
811147bc:	1096be04 	addi	r2,r2,23288
811147c0:	18c00b24 	muli	r3,r3,44
811147c4:	10c5883a 	add	r2,r2,r3
811147c8:	10800904 	addi	r2,r2,36
811147cc:	1080000b 	ldhu	r2,0(r2)
811147d0:	10bfffcc 	andi	r2,r2,65535
811147d4:	10800058 	cmpnei	r2,r2,1
811147d8:	1000021e 	bne	r2,zero,811147e4 <vCheckRetransmission32+0x1c4>
811147dc:	00bffe84 	movi	r2,-6
811147e0:	00000106 	br	811147e8 <vCheckRetransmission32+0x1c8>
811147e4:	00800044 	movi	r2,1
811147e8:	e0bfff45 	stb	r2,-3(fp)

                if ( ++xBuffer32[ucIL].ucNofRetries > ucMax ) {
811147ec:	e0ffff03 	ldbu	r3,-4(fp)
811147f0:	00a04574 	movhi	r2,33045
811147f4:	1096be04 	addi	r2,r2,23288
811147f8:	19000b24 	muli	r4,r3,44
811147fc:	1105883a 	add	r2,r2,r4
81114800:	10800a04 	addi	r2,r2,40
81114804:	10800003 	ldbu	r2,0(r2)
81114808:	10800044 	addi	r2,r2,1
8111480c:	100b883a 	mov	r5,r2
81114810:	00a04574 	movhi	r2,33045
81114814:	1096be04 	addi	r2,r2,23288
81114818:	19000b24 	muli	r4,r3,44
8111481c:	1105883a 	add	r2,r2,r4
81114820:	10800a04 	addi	r2,r2,40
81114824:	11400005 	stb	r5,0(r2)
81114828:	00a04574 	movhi	r2,33045
8111482c:	1096be04 	addi	r2,r2,23288
81114830:	18c00b24 	muli	r3,r3,44
81114834:	10c5883a 	add	r2,r2,r3
81114838:	10800a04 	addi	r2,r2,40
8111483c:	10800003 	ldbu	r2,0(r2)
81114840:	10803fcc 	andi	r2,r2,255
81114844:	e0ffff43 	ldbu	r3,-3(fp)
81114848:	1880162e 	bgeu	r3,r2,811148a4 <vCheckRetransmission32+0x284>
                    /* Now it is a Free place */
                    xInUseRetrans.b32[ucIL] = FALSE;
8111484c:	e0ffff03 	ldbu	r3,-4(fp)
81114850:	00a045b4 	movhi	r2,33046
81114854:	10a93204 	addi	r2,r2,-23352
81114858:	18c00384 	addi	r3,r3,14
8111485c:	18c7883a 	add	r3,r3,r3
81114860:	18c7883a 	add	r3,r3,r3
81114864:	10c5883a 	add	r2,r2,r3
81114868:	10000015 	stw	zero,0(r2)
                    SemCount32++;
8111486c:	d0a06483 	ldbu	r2,-32366(gp)
81114870:	10800044 	addi	r2,r2,1
81114874:	d0a06485 	stb	r2,-32366(gp)
                    ucErrorCodeL = OSSemPost(xSemCountBuffer32);
81114878:	d0a06b17 	ldw	r2,-32340(gp)
8111487c:	1009883a 	mov	r4,r2
81114880:	113ae7c0 	call	8113ae7c <OSSemPost>
81114884:	e0bfff85 	stb	r2,-2(fp)
                    if ( ucErrorCodeL != OS_ERR_NONE ) {
81114888:	e0bfff83 	ldbu	r2,-2(fp)
8111488c:	10803fcc 	andi	r2,r2,255
81114890:	10000426 	beq	r2,zero,811148a4 <vCheckRetransmission32+0x284>
                        SemCount32--;
81114894:	d0a06483 	ldbu	r2,-32366(gp)
81114898:	10bfffc4 	addi	r2,r2,-1
8111489c:	d0a06485 	stb	r2,-32366(gp)
                        vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
811148a0:	11180800 	call	81118080 <vFailSetCountSemaphorexBuffer32>
    

    /* ---> At this point we have access to the xBuffer32*/

    /* Search the one that if in use */
	for( ucIL = 0; ucIL < N_32; ucIL++) {
811148a4:	e0bfff03 	ldbu	r2,-4(fp)
811148a8:	10800044 	addi	r2,r2,1
811148ac:	e0bfff05 	stb	r2,-4(fp)
811148b0:	e0bfff03 	ldbu	r2,-4(fp)
811148b4:	10800230 	cmpltui	r2,r2,8
811148b8:	103f6c1e 	bne	r2,zero,8111466c <__reset+0xfb0f466c>
                    }                    
                }
            }   
        }
	}
    OSMutexPost(xMutexBuffer32);
811148bc:	d0a06817 	ldw	r2,-32352(gp)
811148c0:	1009883a 	mov	r4,r2
811148c4:	113908c0 	call	8113908c <OSMutexPost>

    return;
811148c8:	0001883a 	nop
811148cc:	00000106 	br	811148d4 <vCheckRetransmission32+0x2b4>
    unsigned char ucMax = 0;

    OSMutexAccept(xMutexBuffer32, &ucErrorCodeL); /* Just check the the mutex (non blocking) */
    if ( ucErrorCodeL != OS_NO_ERR ) {
        /* Could not get the Mutex at this time, not critical it will try again later */
        return;
811148d0:	0001883a 	nop
        }
	}
    OSMutexPost(xMutexBuffer32);

    return;
}
811148d4:	e037883a 	mov	sp,fp
811148d8:	dfc00117 	ldw	ra,4(sp)
811148dc:	df000017 	ldw	fp,0(sp)
811148e0:	dec00204 	addi	sp,sp,8
811148e4:	f800283a 	ret

811148e8 <bResourcesInitRTOS>:
 */
TSimucam_MEB xSimMeb; /* Struct */
tDmaSim xDma[2];		  /* Control of the DMA */

/* Instanceatin and Initialization of the resources for the RTOS */
bool bResourcesInitRTOS( void ) {
811148e8:	defff904 	addi	sp,sp,-28
811148ec:	de00012e 	bgeu	sp,et,811148f4 <bResourcesInitRTOS+0xc>
811148f0:	003b68fa 	trap	3
811148f4:	dfc00615 	stw	ra,24(sp)
811148f8:	df000515 	stw	fp,20(sp)
811148fc:	df000504 	addi	fp,sp,20
	bool bSuccess = TRUE;
81114900:	00800044 	movi	r2,1
81114904:	e0bffe15 	stw	r2,-8(fp)
	INT8U err;

	/* This semaphore in the sincronization of the task receiver_com_task with sender_com_task*/
	xSemCommInit = OSSemCreate(0);
81114908:	0009883a 	mov	r4,zero
8111490c:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114910:	d0a05c15 	stw	r2,-32400(gp)
	if (!xSemCommInit) {
81114914:	d0a05c17 	ldw	r2,-32400(gp)
81114918:	1000021e 	bne	r2,zero,81114924 <bResourcesInitRTOS+0x3c>
		vFailCreateSemaphoreResources();
8111491c:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114920:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of tx buffer, between SenderTask and Acks from ReceiverTask*/
	xTxUARTMutex = OSMutexCreate(PCP_MUTEX_TX_UART_PRIO, &err);
81114924:	e0bfff04 	addi	r2,fp,-4
81114928:	100b883a 	mov	r5,r2
8111492c:	01000444 	movi	r4,17
81114930:	11386140 	call	81138614 <OSMutexCreate>
81114934:	d0a07015 	stw	r2,-32320(gp)
	if ( err != OS_ERR_NONE ) {
81114938:	e0bfff03 	ldbu	r2,-4(fp)
8111493c:	10803fcc 	andi	r2,r2,255
81114940:	10000526 	beq	r2,zero,81114958 <bResourcesInitRTOS+0x70>
		vFailCreateMutexSResources(err);
81114944:	e0bfff03 	ldbu	r2,-4(fp)
81114948:	10803fcc 	andi	r2,r2,255
8111494c:	1009883a 	mov	r4,r2
81114950:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114954:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "big" buffer of 128 characters*/
	xMutexBuffer128 = OSMutexCreate(PCP_MUTEX_B128_PRIO, &err);
81114958:	e0bfff04 	addi	r2,fp,-4
8111495c:	100b883a 	mov	r5,r2
81114960:	01000504 	movi	r4,20
81114964:	11386140 	call	81138614 <OSMutexCreate>
81114968:	d0a06a15 	stw	r2,-32344(gp)
	if ( err != OS_ERR_NONE ) {
8111496c:	e0bfff03 	ldbu	r2,-4(fp)
81114970:	10803fcc 	andi	r2,r2,255
81114974:	10000526 	beq	r2,zero,8111498c <bResourcesInitRTOS+0xa4>
		vFailCreateMutexSResources(err);
81114978:	e0bfff03 	ldbu	r2,-4(fp)
8111497c:	10803fcc 	andi	r2,r2,255
81114980:	1009883a 	mov	r4,r2
81114984:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114988:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "medium" buffer of 64 characters*/
	xMutexBuffer64 = OSMutexCreate(PCP_MUTEX_B64_PRIO, &err);
8111498c:	e0bfff04 	addi	r2,fp,-4
81114990:	100b883a 	mov	r5,r2
81114994:	01000544 	movi	r4,21
81114998:	11386140 	call	81138614 <OSMutexCreate>
8111499c:	d0a06d15 	stw	r2,-32332(gp)
	if ( err != OS_ERR_NONE ) {
811149a0:	e0bfff03 	ldbu	r2,-4(fp)
811149a4:	10803fcc 	andi	r2,r2,255
811149a8:	10000526 	beq	r2,zero,811149c0 <bResourcesInitRTOS+0xd8>
		vFailCreateMutexSResources(err);
811149ac:	e0bfff03 	ldbu	r2,-4(fp)
811149b0:	10803fcc 	andi	r2,r2,255
811149b4:	1009883a 	mov	r4,r2
811149b8:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
811149bc:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This mutex will protect the access of the (re)transmission "small" buffer of 32 characters*/
	xMutexBuffer32 = OSMutexCreate(PCP_MUTEX_B32_PRIO, &err);
811149c0:	e0bfff04 	addi	r2,fp,-4
811149c4:	100b883a 	mov	r5,r2
811149c8:	01000584 	movi	r4,22
811149cc:	11386140 	call	81138614 <OSMutexCreate>
811149d0:	d0a06815 	stw	r2,-32352(gp)
	if ( err != OS_ERR_NONE ) {
811149d4:	e0bfff03 	ldbu	r2,-4(fp)
811149d8:	10803fcc 	andi	r2,r2,255
811149dc:	10000526 	beq	r2,zero,811149f4 <bResourcesInitRTOS+0x10c>
		vFailCreateMutexSResources(err);
811149e0:	e0bfff03 	ldbu	r2,-4(fp)
811149e4:	10803fcc 	andi	r2,r2,255
811149e8:	1009883a 	mov	r4,r2
811149ec:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
811149f0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "big" buffer of 128 characters*/
	SemCount128 = N_128;
811149f4:	00800184 	movi	r2,6
811149f8:	d0a07145 	stb	r2,-32315(gp)
	xSemCountBuffer128 = OSSemCreate(N_128);
811149fc:	01000184 	movi	r4,6
81114a00:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114a04:	d0a05f15 	stw	r2,-32388(gp)
	if (!xSemCountBuffer128) {
81114a08:	d0a05f17 	ldw	r2,-32388(gp)
81114a0c:	1000031e 	bne	r2,zero,81114a1c <bResourcesInitRTOS+0x134>
		SemCount128 = 0;
81114a10:	d0207145 	stb	zero,-32315(gp)
		vFailCreateSemaphoreResources();
81114a14:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114a18:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "medium" buffer of 64 characters*/
	SemCount64 = N_64;
81114a1c:	00800204 	movi	r2,8
81114a20:	d0a07105 	stb	r2,-32316(gp)
	xSemCountBuffer64 = OSSemCreate(N_64);
81114a24:	01000204 	movi	r4,8
81114a28:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114a2c:	d0a05a15 	stw	r2,-32408(gp)
	if (!xSemCountBuffer64) {
81114a30:	d0a05a17 	ldw	r2,-32408(gp)
81114a34:	1000031e 	bne	r2,zero,81114a44 <bResourcesInitRTOS+0x15c>
		SemCount64 = 0;
81114a38:	d0207105 	stb	zero,-32316(gp)
		vFailCreateSemaphoreResources();
81114a3c:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114a40:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This semaphore will count the number of positions available in the "small" buffer of 32 characters*/
	SemCount32 = N_32;
81114a44:	00800204 	movi	r2,8
81114a48:	d0a06485 	stb	r2,-32366(gp)
	xSemCountBuffer32 = OSSemCreate(N_32);
81114a4c:	01000204 	movi	r4,8
81114a50:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114a54:	d0a06b15 	stw	r2,-32340(gp)
	if (!xSemCountBuffer32) {
81114a58:	d0a06b17 	ldw	r2,-32340(gp)
81114a5c:	1000031e 	bne	r2,zero,81114a6c <bResourcesInitRTOS+0x184>
		SemCount32 = 0;
81114a60:	d0206485 	stb	zero,-32366(gp)
		vFailCreateSemaphoreResources();
81114a64:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114a68:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexReceivedACK = OSMutexCreate(PCP_MUTEX_RECEIVER_ACK, &err);
81114a6c:	e0bfff04 	addi	r2,fp,-4
81114a70:	100b883a 	mov	r5,r2
81114a74:	010004c4 	movi	r4,19
81114a78:	11386140 	call	81138614 <OSMutexCreate>
81114a7c:	d0a06115 	stw	r2,-32380(gp)
	if ( err != OS_ERR_NONE ) {
81114a80:	e0bfff03 	ldbu	r2,-4(fp)
81114a84:	10803fcc 	andi	r2,r2,255
81114a88:	10000526 	beq	r2,zero,81114aa0 <bResourcesInitRTOS+0x1b8>
		vFailCreateMutexSResources(err);
81114a8c:	e0bfff03 	ldbu	r2,-4(fp)
81114a90:	10803fcc 	andi	r2,r2,255
81114a94:	1009883a 	mov	r4,r2
81114a98:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114a9c:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex for Reader -> Parser*/
	xMutexPreParsed = OSMutexCreate(PCP_MUTEX_PrePareseds, &err);
81114aa0:	e0bfff04 	addi	r2,fp,-4
81114aa4:	100b883a 	mov	r5,r2
81114aa8:	010005c4 	movi	r4,23
81114aac:	11386140 	call	81138614 <OSMutexCreate>
81114ab0:	d0a06715 	stw	r2,-32356(gp)
	if ( err != OS_ERR_NONE ) {
81114ab4:	e0bfff03 	ldbu	r2,-4(fp)
81114ab8:	10803fcc 	andi	r2,r2,255
81114abc:	10000526 	beq	r2,zero,81114ad4 <bResourcesInitRTOS+0x1ec>
		vFailCreateMutexSResources(err);
81114ac0:	e0bfff03 	ldbu	r2,-4(fp)
81114ac4:	10803fcc 	andi	r2,r2,255
81114ac8:	1009883a 	mov	r4,r2
81114acc:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114ad0:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountReceivedACK = OSSemCreate(0);
81114ad4:	0009883a 	mov	r4,zero
81114ad8:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114adc:	d0a06215 	stw	r2,-32376(gp)
	if (!xSemCountReceivedACK) {
81114ae0:	d0a06217 	ldw	r2,-32376(gp)
81114ae4:	1000021e 	bne	r2,zero,81114af0 <bResourcesInitRTOS+0x208>
		vFailCreateSemaphoreResources();
81114ae8:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114aec:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemCountPreParsed = OSSemCreate(0);
81114af0:	0009883a 	mov	r4,zero
81114af4:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114af8:	d0a06015 	stw	r2,-32384(gp)
	if (!xSemCountPreParsed) {
81114afc:	d0a06017 	ldw	r2,-32384(gp)
81114b00:	1000021e 	bne	r2,zero,81114b0c <bResourcesInitRTOS+0x224>
		vFailCreateSemaphoreResources();
81114b04:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114b08:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphore to AckSenderTask*/
	xSemCountSenderACK = OSSemCreate(0);
81114b0c:	0009883a 	mov	r4,zero
81114b10:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114b14:	d0a05d15 	stw	r2,-32396(gp)
	if (!xSemCountSenderACK) {
81114b18:	d0a05d17 	ldw	r2,-32396(gp)
81114b1c:	1000021e 	bne	r2,zero,81114b28 <bResourcesInitRTOS+0x240>
		vFailCreateSemaphoreResources();
81114b20:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114b24:	e03ffe15 	stw	zero,-8(fp)
	}

	xMutexSenderACK = OSMutexCreate(PCP_MUTEX_SENDER_ACK, &err);
81114b28:	e0bfff04 	addi	r2,fp,-4
81114b2c:	100b883a 	mov	r5,r2
81114b30:	01000484 	movi	r4,18
81114b34:	11386140 	call	81138614 <OSMutexCreate>
81114b38:	d0a06e15 	stw	r2,-32328(gp)
	if ( err != OS_ERR_NONE ) {
81114b3c:	e0bfff03 	ldbu	r2,-4(fp)
81114b40:	10803fcc 	andi	r2,r2,255
81114b44:	10000526 	beq	r2,zero,81114b5c <bResourcesInitRTOS+0x274>
		vFailCreateMutexSResources(err);
81114b48:	e0bfff03 	ldbu	r2,-4(fp)
81114b4c:	10803fcc 	andi	r2,r2,255
81114b50:	1009883a 	mov	r4,r2
81114b54:	1117a6c0 	call	81117a6c <vFailCreateMutexSResources>
		bSuccess = FALSE;
81114b58:	e03ffe15 	stw	zero,-8(fp)
	}

	xSemTimeoutChecker = OSSemCreate(0);
81114b5c:	0009883a 	mov	r4,zero
81114b60:	113a7cc0 	call	8113a7cc <OSSemCreate>
81114b64:	d0a06315 	stw	r2,-32372(gp)
	if (!xSemTimeoutChecker) {
81114b68:	d0a06317 	ldw	r2,-32372(gp)
81114b6c:	1000021e 	bne	r2,zero,81114b78 <bResourcesInitRTOS+0x290>
		vFailCreateSemaphoreResources();
81114b70:	1117b180 	call	81117b18 <vFailCreateSemaphoreResources>
		bSuccess = FALSE;
81114b74:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Create the timer that will be used to count the timeout for the retransmission*/
	xTimerRetransmission = OSTmrCreate(	(INT32U         )DLY_TIMER,  /* 200 ticks = 200 millisec */
81114b78:	e0bfff04 	addi	r2,fp,-4
81114b7c:	d8800215 	stw	r2,8(sp)
81114b80:	00a04574 	movhi	r2,33045
81114b84:	10a81404 	addi	r2,r2,-24496
81114b88:	d8800115 	stw	r2,4(sp)
81114b8c:	d8000015 	stw	zero,0(sp)
81114b90:	01e04474 	movhi	r7,33041
81114b94:	39d9bc04 	addi	r7,r7,26352
81114b98:	01800084 	movi	r6,2
81114b9c:	01400104 	movi	r5,4
81114ba0:	01000284 	movi	r4,10
81114ba4:	113ce980 	call	8113ce98 <OSTmrCreate>
81114ba8:	d0a06915 	stw	r2,-32348(gp)
										(INT8U          )OS_TMR_OPT_PERIODIC,
										(OS_TMR_CALLBACK)vTimeoutCheck,
										(void          *)0,
										(INT8U         *)"timer timeout",
										(INT8U         *)&err);	
	if ( err != OS_ERR_NONE ) {
81114bac:	e0bfff03 	ldbu	r2,-4(fp)
81114bb0:	10803fcc 	andi	r2,r2,255
81114bb4:	10000226 	beq	r2,zero,81114bc0 <bResourcesInitRTOS+0x2d8>
		vFailCreateTimerRetransmisison();
81114bb8:	111877c0 	call	8111877c <vFailCreateTimerRetransmisison>
		bSuccess = FALSE;
81114bbc:	e03ffe15 	stw	zero,-8(fp)
	}

	xNfeeSchedule = OSQCreate(&xNfeeScheduleTBL[0], N_OF_MSG_QUEUE);
81114bc0:	01400304 	movi	r5,12
81114bc4:	01204574 	movhi	r4,33045
81114bc8:	210a0504 	addi	r4,r4,10260
81114bcc:	11397000 	call	81139700 <OSQCreate>
81114bd0:	d0a05915 	stw	r2,-32412(gp)
	if ( xNfeeSchedule == NULL ) {
81114bd4:	d0a05917 	ldw	r2,-32412(gp)
81114bd8:	1000021e 	bne	r2,zero,81114be4 <bResourcesInitRTOS+0x2fc>
		vFailCreateScheduleQueue();
81114bdc:	1118d600 	call	81118d60 <vFailCreateScheduleQueue>
		bSuccess = FALSE;		
81114be0:	e03ffe15 	stw	zero,-8(fp)
	}

	xFeeQ[0] = OSQCreate(&xFeeQueueTBL0[0], N_MSG_FEE);
81114be4:	01400104 	movi	r5,4
81114be8:	012045b4 	movhi	r4,33046
81114bec:	2108f004 	addi	r4,r4,9152
81114bf0:	11397000 	call	81139700 <OSQCreate>
81114bf4:	d0a06615 	stw	r2,-32360(gp)
	if ( xFeeQ[0] == NULL ) {
81114bf8:	d0a06617 	ldw	r2,-32360(gp)
81114bfc:	1000031e 	bne	r2,zero,81114c0c <bResourcesInitRTOS+0x324>
		vFailCreateNFEEQueue( 0 );
81114c00:	0009883a 	mov	r4,zero
81114c04:	1118dc80 	call	81118dc8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81114c08:	e03ffe15 	stw	zero,-8(fp)
		bSuccess = FALSE;		
	}
*/


	xWaitSyncQFee[0] = OSQCreate(&SyncTBL0[0], N_MSG_SYNC);
81114c0c:	01400104 	movi	r5,4
81114c10:	012045b4 	movhi	r4,33046
81114c14:	212e3e04 	addi	r4,r4,-18184
81114c18:	11397000 	call	81139700 <OSQCreate>
81114c1c:	d0a05815 	stw	r2,-32416(gp)
	if ( xWaitSyncQFee[0] == NULL ) {
81114c20:	d0a05817 	ldw	r2,-32416(gp)
81114c24:	1000031e 	bne	r2,zero,81114c34 <bResourcesInitRTOS+0x34c>
		vFailCreateNFEESyncQueue( 0 );
81114c28:	0009883a 	mov	r4,zero
81114c2c:	1118e380 	call	81118e38 <vFailCreateNFEESyncQueue>
		bSuccess = FALSE;
81114c30:	e03ffe15 	stw	zero,-8(fp)
	}


	/* Syncronization (no THE sync) of the meb and signalization that has to wakeup */
	xMebQ = OSQCreate(&xMebQTBL[0], N_OF_MEB_MSG_QUEUE);
81114c34:	01400204 	movi	r5,8
81114c38:	012045b4 	movhi	r4,33046
81114c3c:	21294804 	addi	r4,r4,-23264
81114c40:	11397000 	call	81139700 <OSQCreate>
81114c44:	d0a06515 	stw	r2,-32364(gp)
	if ( xMebQ == NULL ) {
81114c48:	d0a06517 	ldw	r2,-32364(gp)
81114c4c:	1000031e 	bne	r2,zero,81114c5c <bResourcesInitRTOS+0x374>
		vFailCreateNFEEQueue( 5 );
81114c50:	01000144 	movi	r4,5
81114c54:	1118dc80 	call	81118dc8 <vFailCreateNFEEQueue>
		bSuccess = FALSE;		
81114c58:	e03ffe15 	stw	zero,-8(fp)
	}

	/* Mutex and Semaphores to control the communication of FastReaderTask */
	xMutexPus = OSMutexCreate(PCP_MUTEX_PUS_QUEUE, &err);
81114c5c:	e0bfff04 	addi	r2,fp,-4
81114c60:	100b883a 	mov	r5,r2
81114c64:	010001c4 	movi	r4,7
81114c68:	11386140 	call	81138614 <OSMutexCreate>
81114c6c:	d0a06f15 	stw	r2,-32324(gp)
	if ( err != OS_ERR_NONE ) {
81114c70:	e0bfff03 	ldbu	r2,-4(fp)
81114c74:	10803fcc 	andi	r2,r2,255
81114c78:	10000526 	beq	r2,zero,81114c90 <bResourcesInitRTOS+0x3a8>
		vFailCreateMutexSPUSQueueMeb(err);
81114c7c:	e0bfff03 	ldbu	r2,-4(fp)
81114c80:	10803fcc 	andi	r2,r2,255
81114c84:	1009883a 	mov	r4,r2
81114c88:	11192500 	call	81119250 <vFailCreateMutexSPUSQueueMeb>
		bSuccess = FALSE;
81114c8c:	e03ffe15 	stw	zero,-8(fp)
	}


	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskFeeCtrl = OSQCreate(&xQMaskCMDNFeeCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81114c90:	01400404 	movi	r5,16
81114c94:	012045b4 	movhi	r4,33046
81114c98:	212a2204 	addi	r4,r4,-22392
81114c9c:	11397000 	call	81139700 <OSQCreate>
81114ca0:	d0a06c15 	stw	r2,-32336(gp)
	if ( xQMaskFeeCtrl == NULL ) {
81114ca4:	d0a06c17 	ldw	r2,-32336(gp)
81114ca8:	1000021e 	bne	r2,zero,81114cb4 <bResourcesInitRTOS+0x3cc>
		vCouldNotCreateQueueMaskNfeeCtrl( );
81114cac:	11193b00 	call	811193b0 <vCouldNotCreateQueueMaskNfeeCtrl>
		bSuccess = FALSE;		
81114cb0:	e03ffe15 	stw	zero,-8(fp)
	}

	/* This Queue is the fast way to comunicate with NFEE Controller task, the communication will be done by sending ints using MASKs*/
	xQMaskDataCtrl = OSQCreate(&xQMaskCMDNDataCtrlTBL[0], N_OF_MSG_QUEUE_MASK);
81114cb4:	01400404 	movi	r5,16
81114cb8:	01204574 	movhi	r4,33045
81114cbc:	211d1604 	addi	r4,r4,29784
81114cc0:	11397000 	call	81139700 <OSQCreate>
81114cc4:	d0a05b15 	stw	r2,-32404(gp)
	if ( xQMaskDataCtrl == NULL ) {
81114cc8:	d0a05b17 	ldw	r2,-32404(gp)
81114ccc:	1000021e 	bne	r2,zero,81114cd8 <bResourcesInitRTOS+0x3f0>
		vCouldNotCreateQueueMaskDataCtrl( );
81114cd0:	11194180 	call	81119418 <vCouldNotCreateQueueMaskDataCtrl>
		bSuccess = FALSE;		
81114cd4:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[0].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_0, &err);
81114cd8:	e0bfff04 	addi	r2,fp,-4
81114cdc:	100b883a 	mov	r5,r2
81114ce0:	01000104 	movi	r4,4
81114ce4:	11386140 	call	81138614 <OSMutexCreate>
81114ce8:	1007883a 	mov	r3,r2
81114cec:	00a045b4 	movhi	r2,33046
81114cf0:	10bc4804 	addi	r2,r2,-3808
81114cf4:	10c00015 	stw	r3,0(r2)
	if ( err != OS_ERR_NONE ) {
81114cf8:	e0bfff03 	ldbu	r2,-4(fp)
81114cfc:	10803fcc 	andi	r2,r2,255
81114d00:	10000226 	beq	r2,zero,81114d0c <bResourcesInitRTOS+0x424>
		vFailCreateMutexDMA();
81114d04:	1117acc0 	call	81117acc <vFailCreateMutexDMA>
		bSuccess = FALSE;
81114d08:	e03ffe15 	stw	zero,-8(fp)
	}

	xDma[1].xMutexDMA = OSMutexCreate(PCP_MUTEX_DMA_1, &err);
81114d0c:	e0bfff04 	addi	r2,fp,-4
81114d10:	100b883a 	mov	r5,r2
81114d14:	01000184 	movi	r4,6
81114d18:	11386140 	call	81138614 <OSMutexCreate>
81114d1c:	1007883a 	mov	r3,r2
81114d20:	00a045b4 	movhi	r2,33046
81114d24:	10bc4804 	addi	r2,r2,-3808
81114d28:	10c00215 	stw	r3,8(r2)
	if ( err != OS_ERR_NONE ) {
81114d2c:	e0bfff03 	ldbu	r2,-4(fp)
81114d30:	10803fcc 	andi	r2,r2,255
81114d34:	10000226 	beq	r2,zero,81114d40 <bResourcesInitRTOS+0x458>
		vFailCreateMutexDMA();
81114d38:	1117acc0 	call	81117acc <vFailCreateMutexDMA>
		bSuccess = FALSE;
81114d3c:	e03ffe15 	stw	zero,-8(fp)
	}	

	return bSuccess;
81114d40:	e0bffe17 	ldw	r2,-8(fp)
}
81114d44:	e037883a 	mov	sp,fp
81114d48:	dfc00117 	ldw	ra,4(sp)
81114d4c:	df000017 	ldw	fp,0(sp)
81114d50:	dec00204 	addi	sp,sp,8
81114d54:	f800283a 	ret

81114d58 <vVariablesInitialization>:

/* Global variables already initialized with zero. But better safe than I'm sorry. */
void vVariablesInitialization ( void ) {
81114d58:	defffd04 	addi	sp,sp,-12
81114d5c:	de00012e 	bgeu	sp,et,81114d64 <vVariablesInitialization+0xc>
81114d60:	003b68fa 	trap	3
81114d64:	dfc00215 	stw	ra,8(sp)
81114d68:	df000115 	stw	fp,4(sp)
81114d6c:	df000104 	addi	fp,sp,4
	unsigned char ucIL = 0;
81114d70:	e03fff05 	stb	zero,-4(fp)

	usiIdCMD = 2;
81114d74:	00800084 	movi	r2,2
81114d78:	d0a0640d 	sth	r2,-32368(gp)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
81114d7c:	01800604 	movi	r6,24
81114d80:	000b883a 	mov	r5,zero
81114d84:	012045b4 	movhi	r4,33046
81114d88:	21293204 	addi	r4,r4,-23352
81114d8c:	111dc180 	call	8111dc18 <memset>
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
81114d90:	01800804 	movi	r6,32
81114d94:	000b883a 	mov	r5,zero
81114d98:	012045b4 	movhi	r4,33046
81114d9c:	21293804 	addi	r4,r4,-23328
81114da0:	111dc180 	call	8111dc18 <memset>
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
81114da4:	01800804 	movi	r6,32
81114da8:	000b883a 	mov	r5,zero
81114dac:	012045b4 	movhi	r4,33046
81114db0:	21294004 	addi	r4,r4,-23296
81114db4:	111dc180 	call	8111dc18 <memset>
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114db8:	e03fff05 	stb	zero,-4(fp)
81114dbc:	00002806 	br	81114e60 <vVariablesInitialization+0x108>
	{
		memset( xBuffer128[ucIL].buffer, 0, 128);
81114dc0:	e0bfff03 	ldbu	r2,-4(fp)
81114dc4:	10c02324 	muli	r3,r2,140
81114dc8:	00a045b4 	movhi	r2,33046
81114dcc:	10a95004 	addi	r2,r2,-23232
81114dd0:	1885883a 	add	r2,r3,r2
81114dd4:	01802004 	movi	r6,128
81114dd8:	000b883a 	mov	r5,zero
81114ddc:	1009883a 	mov	r4,r2
81114de0:	111dc180 	call	8111dc18 <memset>
		xBuffer128[ucIL].bSent = FALSE;
81114de4:	e0ffff03 	ldbu	r3,-4(fp)
81114de8:	00a045b4 	movhi	r2,33046
81114dec:	10a95004 	addi	r2,r2,-23232
81114df0:	18c02324 	muli	r3,r3,140
81114df4:	10c5883a 	add	r2,r2,r3
81114df8:	10802004 	addi	r2,r2,128
81114dfc:	10000015 	stw	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
81114e00:	e0ffff03 	ldbu	r3,-4(fp)
81114e04:	00a045b4 	movhi	r2,33046
81114e08:	10a95004 	addi	r2,r2,-23232
81114e0c:	18c02324 	muli	r3,r3,140
81114e10:	10c5883a 	add	r2,r2,r3
81114e14:	10802104 	addi	r2,r2,132
81114e18:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].usiTimeOut = 0;
81114e1c:	e0ffff03 	ldbu	r3,-4(fp)
81114e20:	00a045b4 	movhi	r2,33046
81114e24:	10a95004 	addi	r2,r2,-23232
81114e28:	18c02324 	muli	r3,r3,140
81114e2c:	10c5883a 	add	r2,r2,r3
81114e30:	10802184 	addi	r2,r2,134
81114e34:	1000000d 	sth	zero,0(r2)
		xBuffer128[ucIL].ucNofRetries = 0;
81114e38:	e0ffff03 	ldbu	r3,-4(fp)
81114e3c:	00a045b4 	movhi	r2,33046
81114e40:	10a95004 	addi	r2,r2,-23232
81114e44:	18c02324 	muli	r3,r3,140
81114e48:	10c5883a 	add	r2,r2,r3
81114e4c:	10802204 	addi	r2,r2,136
81114e50:	10000005 	stb	zero,0(r2)

	memset( xInUseRetrans.b128 , FALSE , sizeof(xInUseRetrans.b128));
	memset( xInUseRetrans.b64 , FALSE , sizeof(xInUseRetrans.b64));
	memset( xInUseRetrans.b32 , FALSE , sizeof(xInUseRetrans.b32));
	
	for( ucIL = 0; ucIL < N_128; ucIL++)
81114e54:	e0bfff03 	ldbu	r2,-4(fp)
81114e58:	10800044 	addi	r2,r2,1
81114e5c:	e0bfff05 	stb	r2,-4(fp)
81114e60:	e0bfff03 	ldbu	r2,-4(fp)
81114e64:	108001b0 	cmpltui	r2,r2,6
81114e68:	103fd51e 	bne	r2,zero,81114dc0 <__reset+0xfb0f4dc0>
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81114e6c:	e03fff05 	stb	zero,-4(fp)
81114e70:	00002806 	br	81114f14 <vVariablesInitialization+0x1bc>
	{
		memset( xBuffer64[ucIL].buffer, 0, 64);
81114e74:	e0bfff03 	ldbu	r2,-4(fp)
81114e78:	10c01324 	muli	r3,r2,76
81114e7c:	00a04574 	movhi	r2,33045
81114e80:	10851104 	addi	r2,r2,5188
81114e84:	1885883a 	add	r2,r3,r2
81114e88:	01801004 	movi	r6,64
81114e8c:	000b883a 	mov	r5,zero
81114e90:	1009883a 	mov	r4,r2
81114e94:	111dc180 	call	8111dc18 <memset>
		xBuffer64[ucIL].bSent = FALSE;
81114e98:	e0ffff03 	ldbu	r3,-4(fp)
81114e9c:	00a04574 	movhi	r2,33045
81114ea0:	10851104 	addi	r2,r2,5188
81114ea4:	18c01324 	muli	r3,r3,76
81114ea8:	10c5883a 	add	r2,r2,r3
81114eac:	10801004 	addi	r2,r2,64
81114eb0:	10000015 	stw	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
81114eb4:	e0ffff03 	ldbu	r3,-4(fp)
81114eb8:	00a04574 	movhi	r2,33045
81114ebc:	10851104 	addi	r2,r2,5188
81114ec0:	18c01324 	muli	r3,r3,76
81114ec4:	10c5883a 	add	r2,r2,r3
81114ec8:	10801104 	addi	r2,r2,68
81114ecc:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].usiTimeOut = 0;
81114ed0:	e0ffff03 	ldbu	r3,-4(fp)
81114ed4:	00a04574 	movhi	r2,33045
81114ed8:	10851104 	addi	r2,r2,5188
81114edc:	18c01324 	muli	r3,r3,76
81114ee0:	10c5883a 	add	r2,r2,r3
81114ee4:	10801184 	addi	r2,r2,70
81114ee8:	1000000d 	sth	zero,0(r2)
		xBuffer64[ucIL].ucNofRetries = 0;
81114eec:	e0ffff03 	ldbu	r3,-4(fp)
81114ef0:	00a04574 	movhi	r2,33045
81114ef4:	10851104 	addi	r2,r2,5188
81114ef8:	18c01324 	muli	r3,r3,76
81114efc:	10c5883a 	add	r2,r2,r3
81114f00:	10801204 	addi	r2,r2,72
81114f04:	10000005 	stb	zero,0(r2)
		xBuffer128[ucIL].usiId = 0;
		xBuffer128[ucIL].usiTimeOut = 0;
		xBuffer128[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_64; ucIL++)
81114f08:	e0bfff03 	ldbu	r2,-4(fp)
81114f0c:	10800044 	addi	r2,r2,1
81114f10:	e0bfff05 	stb	r2,-4(fp)
81114f14:	e0bfff03 	ldbu	r2,-4(fp)
81114f18:	10800230 	cmpltui	r2,r2,8
81114f1c:	103fd51e 	bne	r2,zero,81114e74 <__reset+0xfb0f4e74>
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81114f20:	e03fff05 	stb	zero,-4(fp)
81114f24:	00002806 	br	81114fc8 <vVariablesInitialization+0x270>
	{
		memset( xBuffer32[ucIL].buffer, 0, 32);
81114f28:	e0bfff03 	ldbu	r2,-4(fp)
81114f2c:	10c00b24 	muli	r3,r2,44
81114f30:	00a04574 	movhi	r2,33045
81114f34:	1096be04 	addi	r2,r2,23288
81114f38:	1885883a 	add	r2,r3,r2
81114f3c:	01800804 	movi	r6,32
81114f40:	000b883a 	mov	r5,zero
81114f44:	1009883a 	mov	r4,r2
81114f48:	111dc180 	call	8111dc18 <memset>
		xBuffer32[ucIL].bSent = FALSE;
81114f4c:	e0ffff03 	ldbu	r3,-4(fp)
81114f50:	00a04574 	movhi	r2,33045
81114f54:	1096be04 	addi	r2,r2,23288
81114f58:	18c00b24 	muli	r3,r3,44
81114f5c:	10c5883a 	add	r2,r2,r3
81114f60:	10800804 	addi	r2,r2,32
81114f64:	10000015 	stw	zero,0(r2)
		xBuffer32[ucIL].usiId = 0;
81114f68:	e0ffff03 	ldbu	r3,-4(fp)
81114f6c:	00a04574 	movhi	r2,33045
81114f70:	1096be04 	addi	r2,r2,23288
81114f74:	18c00b24 	muli	r3,r3,44
81114f78:	10c5883a 	add	r2,r2,r3
81114f7c:	10800904 	addi	r2,r2,36
81114f80:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].usiTimeOut = 0;
81114f84:	e0ffff03 	ldbu	r3,-4(fp)
81114f88:	00a04574 	movhi	r2,33045
81114f8c:	1096be04 	addi	r2,r2,23288
81114f90:	18c00b24 	muli	r3,r3,44
81114f94:	10c5883a 	add	r2,r2,r3
81114f98:	10800984 	addi	r2,r2,38
81114f9c:	1000000d 	sth	zero,0(r2)
		xBuffer32[ucIL].ucNofRetries = 0;
81114fa0:	e0ffff03 	ldbu	r3,-4(fp)
81114fa4:	00a04574 	movhi	r2,33045
81114fa8:	1096be04 	addi	r2,r2,23288
81114fac:	18c00b24 	muli	r3,r3,44
81114fb0:	10c5883a 	add	r2,r2,r3
81114fb4:	10800a04 	addi	r2,r2,40
81114fb8:	10000005 	stb	zero,0(r2)
		xBuffer64[ucIL].usiId = 0;
		xBuffer64[ucIL].usiTimeOut = 0;
		xBuffer64[ucIL].ucNofRetries = 0;
	}

	for( ucIL = 0; ucIL < N_32; ucIL++)
81114fbc:	e0bfff03 	ldbu	r2,-4(fp)
81114fc0:	10800044 	addi	r2,r2,1
81114fc4:	e0bfff05 	stb	r2,-4(fp)
81114fc8:	e0bfff03 	ldbu	r2,-4(fp)
81114fcc:	10800230 	cmpltui	r2,r2,8
81114fd0:	103fd51e 	bne	r2,zero,81114f28 <__reset+0xfb0f4f28>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
81114fd4:	e03fff05 	stb	zero,-4(fp)
81114fd8:	00001b06 	br	81115048 <vVariablesInitialization+0x2f0>
	{
		xPus[ucIL].bInUse = FALSE;
81114fdc:	e0ffff03 	ldbu	r3,-4(fp)
81114fe0:	00a04574 	movhi	r2,33045
81114fe4:	1085a904 	addi	r2,r2,5796
81114fe8:	18c01524 	muli	r3,r3,84
81114fec:	10c5883a 	add	r2,r2,r3
81114ff0:	10800104 	addi	r2,r2,4
81114ff4:	10000015 	stw	zero,0(r2)
		xPus[ucIL].ucNofValues = 0;
81114ff8:	e0ffff03 	ldbu	r3,-4(fp)
81114ffc:	00a04574 	movhi	r2,33045
81115000:	1085a904 	addi	r2,r2,5796
81115004:	18c01524 	muli	r3,r3,84
81115008:	10c5883a 	add	r2,r2,r3
8111500c:	10800484 	addi	r2,r2,18
81115010:	10000005 	stb	zero,0(r2)
		memset( xPus[ucIL].usiValues, 0, sizeof(xPus[ucIL].usiValues));
81115014:	e0bfff03 	ldbu	r2,-4(fp)
81115018:	10801524 	muli	r2,r2,84
8111501c:	10c00504 	addi	r3,r2,20
81115020:	00a04574 	movhi	r2,33045
81115024:	1085a904 	addi	r2,r2,5796
81115028:	1885883a 	add	r2,r3,r2
8111502c:	01801004 	movi	r6,64
81115030:	000b883a 	mov	r5,zero
81115034:	1009883a 	mov	r4,r2
81115038:	111dc180 	call	8111dc18 <memset>
		xBuffer32[ucIL].usiTimeOut = 0;
		xBuffer32[ucIL].ucNofRetries = 0;
	}


	for( ucIL = 0; ucIL < N_PUS_PIPE; ucIL++)
8111503c:	e0bfff03 	ldbu	r2,-4(fp)
81115040:	10800044 	addi	r2,r2,1
81115044:	e0bfff05 	stb	r2,-4(fp)
81115048:	e0bfff03 	ldbu	r2,-4(fp)
8111504c:	10800130 	cmpltui	r2,r2,4
81115050:	103fe21e 	bne	r2,zero,81114fdc <__reset+0xfb0f4fdc>

txSenderACKs xSenderACK[N_ACKS_SENDER];

*/

}
81115054:	0001883a 	nop
81115058:	e037883a 	mov	sp,fp
8111505c:	dfc00117 	ldw	ra,4(sp)
81115060:	df000017 	ldw	fp,0(sp)
81115064:	dec00204 	addi	sp,sp,8
81115068:	f800283a 	ret

8111506c <main>:
void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL );


/* Entry point */
int main(void)
{
8111506c:	defff704 	addi	sp,sp,-36
81115070:	de00012e 	bgeu	sp,et,81115078 <main+0xc>
81115074:	003b68fa 	trap	3
81115078:	dfc00815 	stw	ra,32(sp)
8111507c:	df000715 	stw	fp,28(sp)
81115080:	df000704 	addi	fp,sp,28
	INT8U error_code;
	bool bIniSimucamStatus = FALSE;
81115084:	e03ffe15 	stw	zero,-8(fp)
	
	OSInit();
81115088:	1134ab00 	call	81134ab0 <OSInit>

	/* Debug device initialization - JTAG USB */
	#ifdef DEBUG_ON
		fp = fopen(JTAG_UART_0_NAME, "r+");
8111508c:	01604574 	movhi	r5,33045
81115090:	29681804 	addi	r5,r5,-24480
81115094:	01204574 	movhi	r4,33045
81115098:	21281904 	addi	r4,r4,-24476
8111509c:	111c9d00 	call	8111c9d0 <fopen>
811150a0:	d0a05e15 	stw	r2,-32392(gp)
	#endif	

	#ifdef DEBUG_ON
		debug(fp, "Main entry point.\n");
811150a4:	d0a05e17 	ldw	r2,-32392(gp)
811150a8:	100f883a 	mov	r7,r2
811150ac:	01800484 	movi	r6,18
811150b0:	01400044 	movi	r5,1
811150b4:	01204574 	movhi	r4,33045
811150b8:	21281e04 	addi	r4,r4,-24456
811150bc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	/* Initialization of basic HW */
	vInitSimucamBasicHW();
811150c0:	111a2e40 	call	8111a2e4 <vInitSimucamBasicHW>

	/* Test of some critical IPCores HW interfaces in the Simucam */
	bIniSimucamStatus = bTestSimucamCriticalHW();
811150c4:	111af240 	call	8111af24 <bTestSimucamCriticalHW>
811150c8:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811150cc:	e0bffe17 	ldw	r2,-8(fp)
811150d0:	1000031e 	bne	r2,zero,811150e0 <main+0x74>
		vFailTestCriticasParts();
811150d4:	1117b640 	call	81117b64 <vFailTestCriticasParts>
		return -1;
811150d8:	00bfffc4 	movi	r2,-1
811150dc:	00004106 	br	811151e4 <main+0x178>
	}


	/* Log file Initialization in the SDCard */
	bIniSimucamStatus = bInitializeSDCard();
811150e0:	111aa640 	call	8111aa64 <bInitializeSDCard>
811150e4:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
811150e8:	e0bffe17 	ldw	r2,-8(fp)
811150ec:	1000031e 	bne	r2,zero,811150fc <main+0x90>
		vFailTestCriticasParts();
811150f0:	1117b640 	call	81117b64 <vFailTestCriticasParts>
		return -1;
811150f4:	00bfffc4 	movi	r2,-1
811150f8:	00003a06 	br	811151e4 <main+0x178>
	}

	bIniSimucamStatus = vLoadDefaultETHConf();
811150fc:	1116b180 	call	81116b18 <vLoadDefaultETHConf>
81115100:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
81115104:	e0bffe17 	ldw	r2,-8(fp)
81115108:	1000091e 	bne	r2,zero,81115130 <main+0xc4>
		/* Default configuration for eth connection loaded */
		#ifdef DEBUG_ON
			debug(fp, "Didn't load ETH configuration from SDCard. Default configuration will be loaded. (exit) \n");
8111510c:	d0a05e17 	ldw	r2,-32392(gp)
81115110:	100f883a 	mov	r7,r2
81115114:	01801644 	movi	r6,89
81115118:	01400044 	movi	r5,1
8111511c:	01204574 	movhi	r4,33045
81115120:	21282304 	addi	r4,r4,-24436
81115124:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return -1;
81115128:	00bfffc4 	movi	r2,-1
8111512c:	00002d06 	br	811151e4 <main+0x178>
	}

	/* If debug is enable, will print the eth configuration in the*/
	#ifdef DEBUG_ON
		vShowEthConfig();
81115130:	11174ec0 	call	811174ec <vShowEthConfig>
	#endif


	/* This function creates all resources needed by the RTOS*/
	bIniSimucamStatus = bResourcesInitRTOS();
81115134:	11148e80 	call	811148e8 <bResourcesInitRTOS>
81115138:	e0bffe15 	stw	r2,-8(fp)
	if (bIniSimucamStatus == FALSE) {
8111513c:	e0bffe17 	ldw	r2,-8(fp)
81115140:	1000091e 	bne	r2,zero,81115168 <main+0xfc>
		/* Default configuration for eth connection loaded */
		debug(fp, "Can't allocate resources for RTOS. (exit) \n");
81115144:	d0a05e17 	ldw	r2,-32392(gp)
81115148:	100f883a 	mov	r7,r2
8111514c:	01800ac4 	movi	r6,43
81115150:	01400044 	movi	r5,1
81115154:	01204574 	movhi	r4,33045
81115158:	21283a04 	addi	r4,r4,-24344
8111515c:	111d0b40 	call	8111d0b4 <fwrite>
		return -1;
81115160:	00bfffc4 	movi	r2,-1
81115164:	00001f06 	br	811151e4 <main+0x178>
	}

	/* Start the structure of control of the Simucam Application, including all FEEs instances */
	vSimucamStructureInit( &xSimMeb );
81115168:	01204574 	movhi	r4,33045
8111516c:	21121104 	addi	r4,r4,18500
81115170:	111a4240 	call	8111a424 <vSimucamStructureInit>

	vVariablesInitialization();
81115174:	1114d580 	call	81114d58 <vVariablesInitialization>

	bInitSync();
81115178:	111ac180 	call	8111ac18 <bInitSync>

	vFillMemmoryPattern( &xSimMeb );
8111517c:	01204574 	movhi	r4,33045
81115180:	21121104 	addi	r4,r4,18500
81115184:	11151f80 	call	811151f8 <vFillMemmoryPattern>
									vInitialTask_stk,
									INITIALIZATION_TASK_SIZE,
									NULL,
									OS_TASK_OPT_STK_CLR + OS_TASK_OPT_STK_CHK);
	#else
		error_code = OSTaskCreateExt(vInitialTask,
81115188:	d8000415 	stw	zero,16(sp)
8111518c:	d8000315 	stw	zero,12(sp)
81115190:	00810004 	movi	r2,1024
81115194:	d8800215 	stw	r2,8(sp)
81115198:	00a045b4 	movhi	r2,33046
8111519c:	10a12e04 	addi	r2,r2,-31560
811151a0:	d8800115 	stw	r2,4(sp)
811151a4:	00800044 	movi	r2,1
811151a8:	d8800015 	stw	r2,0(sp)
811151ac:	01c00044 	movi	r7,1
811151b0:	01a045b4 	movhi	r6,33046
811151b4:	31a52d04 	addi	r6,r6,-27468
811151b8:	000b883a 	mov	r5,zero
811151bc:	01204474 	movhi	r4,33041
811151c0:	213e5b04 	addi	r4,r4,-1684
811151c4:	113b8600 	call	8113b860 <OSTaskCreateExt>
811151c8:	e0bfff05 	stb	r2,-4(fp)
									NULL,
									0);
	#endif


	if ( error_code == OS_ERR_NONE ) {
811151cc:	e0bfff03 	ldbu	r2,-4(fp)
811151d0:	1000021e 	bne	r2,zero,811151dc <main+0x170>
		/* Start the scheduler (start the Real Time Application) */
		OSStart();
811151d4:	1134de00 	call	81134de0 <OSStart>
811151d8:	00000106 	br	811151e0 <main+0x174>
	} else {
		/* Some error occurs in the creation of the Initialization Task */
		vFailInitialization();
811151dc:	1117f500 	call	81117f50 <vFailInitialization>
	}
  
	return 0;
811151e0:	0005883a 	mov	r2,zero
}
811151e4:	e037883a 	mov	sp,fp
811151e8:	dfc00117 	ldw	ra,4(sp)
811151ec:	df000017 	ldw	fp,0(sp)
811151f0:	dec00204 	addi	sp,sp,8
811151f4:	f800283a 	ret

811151f8 <vFillMemmoryPattern>:


void vFillMemmoryPattern( TSimucam_MEB *xSimMebL ) {
811151f8:	defff604 	addi	sp,sp,-40
811151fc:	de00012e 	bgeu	sp,et,81115204 <vFillMemmoryPattern+0xc>
81115200:	003b68fa 	trap	3
81115204:	dfc00915 	stw	ra,36(sp)
81115208:	df000815 	stw	fp,32(sp)
8111520c:	df000804 	addi	fp,sp,32
81115210:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81115214:	00800044 	movi	r2,1
81115218:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
8111521c:	d0a05e17 	ldw	r2,-32392(gp)
81115220:	100f883a 	mov	r7,r2
81115224:	018009c4 	movi	r6,39
81115228:	01400044 	movi	r5,1
8111522c:	01204574 	movhi	r4,33045
81115230:	21284504 	addi	r4,r4,-24300
81115234:	111d0b40 	call	8111d0b4 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81115238:	e03ffa05 	stb	zero,-24(fp)
8111523c:	00007606 	br	81115418 <vFillMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81115240:	e03ffc85 	stb	zero,-14(fp)
81115244:	00006706 	br	811153e4 <vFillMemmoryPattern+0x1ec>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
81115248:	e0bffc83 	ldbu	r2,-14(fp)
8111524c:	e0ffff17 	ldw	r3,-4(fp)
81115250:	10809524 	muli	r2,r2,596
81115254:	1885883a 	add	r2,r3,r2
81115258:	10804304 	addi	r2,r2,268
8111525c:	1080000b 	ldhu	r2,0(r2)
81115260:	10ffffcc 	andi	r3,r2,65535
81115264:	e0bffc83 	ldbu	r2,-14(fp)
81115268:	e13fff17 	ldw	r4,-4(fp)
8111526c:	10809524 	muli	r2,r2,596
81115270:	2085883a 	add	r2,r4,r2
81115274:	10804204 	addi	r2,r2,264
81115278:	1080000b 	ldhu	r2,0(r2)
8111527c:	10bfffcc 	andi	r2,r2,65535
81115280:	1885883a 	add	r2,r3,r2
81115284:	e0bffd15 	stw	r2,-12(fp)
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
81115288:	e0bffc83 	ldbu	r2,-14(fp)
8111528c:	e0ffff17 	ldw	r3,-4(fp)
81115290:	10809524 	muli	r2,r2,596
81115294:	1885883a 	add	r2,r3,r2
81115298:	10804284 	addi	r2,r2,266
8111529c:	1080000b 	ldhu	r2,0(r2)
811152a0:	10ffffcc 	andi	r3,r2,65535
811152a4:	e0bffc83 	ldbu	r2,-14(fp)
811152a8:	e13fff17 	ldw	r4,-4(fp)
811152ac:	10809524 	muli	r2,r2,596
811152b0:	2085883a 	add	r2,r4,r2
811152b4:	10804184 	addi	r2,r2,262
811152b8:	1080000b 	ldhu	r2,0(r2)
811152bc:	10bfffcc 	andi	r2,r2,65535
811152c0:	1887883a 	add	r3,r3,r2
811152c4:	e0bffc83 	ldbu	r2,-14(fp)
811152c8:	e13fff17 	ldw	r4,-4(fp)
811152cc:	10809524 	muli	r2,r2,596
811152d0:	2085883a 	add	r2,r4,r2
811152d4:	10804104 	addi	r2,r2,260
811152d8:	1080000b 	ldhu	r2,0(r2)
811152dc:	10bfffcc 	andi	r2,r2,65535
811152e0:	1885883a 	add	r2,r3,r2
811152e4:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811152e8:	e03ffc05 	stb	zero,-16(fp)
811152ec:	00003706 	br	811153cc <vFillMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811152f0:	e03ffc45 	stb	zero,-15(fp)
811152f4:	00002606 	br	81115390 <vFillMemmoryPattern+0x198>
					if (ccd_side == 0){
811152f8:	e0bffc43 	ldbu	r2,-15(fp)
811152fc:	10000b1e 	bne	r2,zero,8111532c <vFillMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81115300:	e0bffc83 	ldbu	r2,-14(fp)
81115304:	e13ffc03 	ldbu	r4,-16(fp)
81115308:	e0ffff17 	ldw	r3,-4(fp)
8111530c:	21000624 	muli	r4,r4,24
81115310:	10809524 	muli	r2,r2,596
81115314:	2085883a 	add	r2,r4,r2
81115318:	1885883a 	add	r2,r3,r2
8111531c:	10801b04 	addi	r2,r2,108
81115320:	10800017 	ldw	r2,0(r2)
81115324:	e0bffb15 	stw	r2,-20(fp)
81115328:	00000a06 	br	81115354 <vFillMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8111532c:	e0bffc83 	ldbu	r2,-14(fp)
81115330:	e13ffc03 	ldbu	r4,-16(fp)
81115334:	e0ffff17 	ldw	r3,-4(fp)
81115338:	21000624 	muli	r4,r4,24
8111533c:	10809524 	muli	r2,r2,596
81115340:	2085883a 	add	r2,r4,r2
81115344:	1885883a 	add	r2,r3,r2
81115348:	10801e04 	addi	r2,r2,120
8111534c:	10800017 	ldw	r2,0(r2)
81115350:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
81115354:	e0fffa03 	ldbu	r3,-24(fp)
81115358:	e13ffc03 	ldbu	r4,-16(fp)
8111535c:	e17ffc43 	ldbu	r5,-15(fp)
81115360:	e0bffd17 	ldw	r2,-12(fp)
81115364:	d8800115 	stw	r2,4(sp)
81115368:	e0bffe17 	ldw	r2,-8(fp)
8111536c:	d8800015 	stw	r2,0(sp)
81115370:	280f883a 	mov	r7,r5
81115374:	200d883a 	mov	r6,r4
81115378:	e17ffb17 	ldw	r5,-20(fp)
8111537c:	1809883a 	mov	r4,r3
81115380:	111a7e80 	call	8111a7e8 <pattern_createPattern>
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81115384:	e0bffc43 	ldbu	r2,-15(fp)
81115388:	10800044 	addi	r2,r2,1
8111538c:	e0bffc45 	stb	r2,-15(fp)
81115390:	e0bffc43 	ldbu	r2,-15(fp)
81115394:	108000b0 	cmpltui	r2,r2,2
81115398:	103fd71e 	bne	r2,zero,811152f8 <__reset+0xfb0f52f8>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
8111539c:	d0a05e17 	ldw	r2,-32392(gp)
811153a0:	e0fffc83 	ldbu	r3,-14(fp)
811153a4:	e13ffc03 	ldbu	r4,-16(fp)
811153a8:	200f883a 	mov	r7,r4
811153ac:	180d883a 	mov	r6,r3
811153b0:	01604574 	movhi	r5,33045
811153b4:	29684f04 	addi	r5,r5,-24260
811153b8:	1009883a 	mov	r4,r2
811153bc:	111ca180 	call	8111ca18 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
811153c0:	e0bffc03 	ldbu	r2,-16(fp)
811153c4:	10800044 	addi	r2,r2,1
811153c8:	e0bffc05 	stb	r2,-16(fp)
811153cc:	e0bffc03 	ldbu	r2,-16(fp)
811153d0:	10800130 	cmpltui	r2,r2,4
811153d4:	103fc61e 	bne	r2,zero,811152f0 <__reset+0xfb0f52f0>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811153d8:	e0bffc83 	ldbu	r2,-14(fp)
811153dc:	10800044 	addi	r2,r2,1
811153e0:	e0bffc85 	stb	r2,-14(fp)
811153e4:	e0fffc83 	ldbu	r3,-14(fp)
811153e8:	e0bffcc3 	ldbu	r2,-13(fp)
811153ec:	18bf9636 	bltu	r3,r2,81115248 <__reset+0xfb0f5248>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
811153f0:	d0a05e17 	ldw	r2,-32392(gp)
811153f4:	e0fffa03 	ldbu	r3,-24(fp)
811153f8:	180d883a 	mov	r6,r3
811153fc:	01604574 	movhi	r5,33045
81115400:	29685404 	addi	r5,r5,-24240
81115404:	1009883a 	mov	r4,r2
81115408:	111ca180 	call	8111ca18 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8111540c:	e0bffa03 	ldbu	r2,-24(fp)
81115410:	10800044 	addi	r2,r2,1
81115414:	e0bffa05 	stb	r2,-24(fp)
81115418:	e0bffa03 	ldbu	r2,-24(fp)
8111541c:	108000b0 	cmpltui	r2,r2,2
81115420:	103f871e 	bne	r2,zero,81115240 <__reset+0xfb0f5240>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81115424:	d0a05e17 	ldw	r2,-32392(gp)
81115428:	100f883a 	mov	r7,r2
8111542c:	01800404 	movi	r6,16
81115430:	01400044 	movi	r5,1
81115434:	01204574 	movhi	r4,33045
81115438:	21285804 	addi	r4,r4,-24224
8111543c:	111d0b40 	call	8111d0b4 <fwrite>
#endif


}
81115440:	0001883a 	nop
81115444:	e037883a 	mov	sp,fp
81115448:	dfc00117 	ldw	ra,4(sp)
8111544c:	df000017 	ldw	fp,0(sp)
81115450:	dec00204 	addi	sp,sp,8
81115454:	f800283a 	ret

81115458 <vPrintMemmoryPattern>:

void vPrintMemmoryPattern( TSimucam_MEB *xSimMebL ) {
81115458:	defff604 	addi	sp,sp,-40
8111545c:	de00012e 	bgeu	sp,et,81115464 <vPrintMemmoryPattern+0xc>
81115460:	003b68fa 	trap	3
81115464:	dfc00915 	stw	ra,36(sp)
81115468:	df000815 	stw	fp,32(sp)
8111546c:	df000804 	addi	fp,sp,32
81115470:	e13fff15 	stw	r4,-4(fp)
	alt_u32 width_cols;
	alt_u32 height_rows;
	alt_u8 n_of_NFEE_in_mem;
	alt_u8 NFee_i;

	n_of_NFEE_in_mem = 1;
81115474:	00800044 	movi	r2,1
81115478:	e0bffcc5 	stb	r2,-13(fp)

#ifdef DEBUG_ON
	debug(fp, "Start to fill the memory with Pattern.\n");
8111547c:	d0a05e17 	ldw	r2,-32392(gp)
81115480:	100f883a 	mov	r7,r2
81115484:	018009c4 	movi	r6,39
81115488:	01400044 	movi	r5,1
8111548c:	01204574 	movhi	r4,33045
81115490:	21284504 	addi	r4,r4,-24300
81115494:	111d0b40 	call	8111d0b4 <fwrite>
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
81115498:	e03ffa05 	stb	zero,-24(fp)
8111549c:	00007606 	br	81115678 <vPrintMemmoryPattern+0x220>
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
811154a0:	e03ffc85 	stb	zero,-14(fp)
811154a4:	00006706 	br	81115644 <vPrintMemmoryPattern+0x1ec>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
811154a8:	e0bffc83 	ldbu	r2,-14(fp)
811154ac:	e0ffff17 	ldw	r3,-4(fp)
811154b0:	10809524 	muli	r2,r2,596
811154b4:	1885883a 	add	r2,r3,r2
811154b8:	10804304 	addi	r2,r2,268
811154bc:	1080000b 	ldhu	r2,0(r2)
811154c0:	10ffffcc 	andi	r3,r2,65535
811154c4:	e0bffc83 	ldbu	r2,-14(fp)
811154c8:	e13fff17 	ldw	r4,-4(fp)
811154cc:	10809524 	muli	r2,r2,596
811154d0:	2085883a 	add	r2,r4,r2
811154d4:	10804204 	addi	r2,r2,264
811154d8:	1080000b 	ldhu	r2,0(r2)
811154dc:	10bfffcc 	andi	r2,r2,65535
811154e0:	1885883a 	add	r2,r3,r2
811154e4:	e0bffd15 	stw	r2,-12(fp)
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
811154e8:	e0bffc83 	ldbu	r2,-14(fp)
811154ec:	e0ffff17 	ldw	r3,-4(fp)
811154f0:	10809524 	muli	r2,r2,596
811154f4:	1885883a 	add	r2,r3,r2
811154f8:	10804284 	addi	r2,r2,266
811154fc:	1080000b 	ldhu	r2,0(r2)
81115500:	10ffffcc 	andi	r3,r2,65535
81115504:	e0bffc83 	ldbu	r2,-14(fp)
81115508:	e13fff17 	ldw	r4,-4(fp)
8111550c:	10809524 	muli	r2,r2,596
81115510:	2085883a 	add	r2,r4,r2
81115514:	10804184 	addi	r2,r2,262
81115518:	1080000b 	ldhu	r2,0(r2)
8111551c:	10bfffcc 	andi	r2,r2,65535
81115520:	1887883a 	add	r3,r3,r2
81115524:	e0bffc83 	ldbu	r2,-14(fp)
81115528:	e13fff17 	ldw	r4,-4(fp)
8111552c:	10809524 	muli	r2,r2,596
81115530:	2085883a 	add	r2,r4,r2
81115534:	10804104 	addi	r2,r2,260
81115538:	1080000b 	ldhu	r2,0(r2)
8111553c:	10bfffcc 	andi	r2,r2,65535
81115540:	1885883a 	add	r2,r3,r2
81115544:	e0bffe15 	stw	r2,-8(fp)
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81115548:	e03ffc05 	stb	zero,-16(fp)
8111554c:	00003706 	br	8111562c <vPrintMemmoryPattern+0x1d4>

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
81115550:	e03ffc45 	stb	zero,-15(fp)
81115554:	00002606 	br	811155f0 <vPrintMemmoryPattern+0x198>
					if (ccd_side == 0){
81115558:	e0bffc43 	ldbu	r2,-15(fp)
8111555c:	10000b1e 	bne	r2,zero,8111558c <vPrintMemmoryPattern+0x134>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xLeft.ulOffsetAddr;
81115560:	e0bffc83 	ldbu	r2,-14(fp)
81115564:	e13ffc03 	ldbu	r4,-16(fp)
81115568:	e0ffff17 	ldw	r3,-4(fp)
8111556c:	21000624 	muli	r4,r4,24
81115570:	10809524 	muli	r2,r2,596
81115574:	2085883a 	add	r2,r4,r2
81115578:	1885883a 	add	r2,r3,r2
8111557c:	10801b04 	addi	r2,r2,108
81115580:	10800017 	ldw	r2,0(r2)
81115584:	e0bffb15 	stw	r2,-20(fp)
81115588:	00000a06 	br	811155b4 <vPrintMemmoryPattern+0x15c>
					} else {
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
8111558c:	e0bffc83 	ldbu	r2,-14(fp)
81115590:	e13ffc03 	ldbu	r4,-16(fp)
81115594:	e0ffff17 	ldw	r3,-4(fp)
81115598:	21000624 	muli	r4,r4,24
8111559c:	10809524 	muli	r2,r2,596
811155a0:	2085883a 	add	r2,r4,r2
811155a4:	1885883a 	add	r2,r3,r2
811155a8:	10801e04 	addi	r2,r2,120
811155ac:	10800017 	ldw	r2,0(r2)
811155b0:	e0bffb15 	stw	r2,-20(fp)
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
811155b4:	e0fffa03 	ldbu	r3,-24(fp)
811155b8:	e13ffc03 	ldbu	r4,-16(fp)
811155bc:	e17ffc43 	ldbu	r5,-15(fp)
811155c0:	e0bffe17 	ldw	r2,-8(fp)
811155c4:	d8800115 	stw	r2,4(sp)
811155c8:	e0bffd17 	ldw	r2,-12(fp)
811155cc:	d8800015 	stw	r2,0(sp)
811155d0:	280f883a 	mov	r7,r5
811155d4:	200d883a 	mov	r6,r4
811155d8:	e17ffb17 	ldw	r5,-20(fp)
811155dc:	1809883a 	mov	r4,r3
811155e0:	111a7e80 	call	8111a7e8 <pattern_createPattern>
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {

				for( ccd_side = 0; ccd_side < 2; ccd_side++ ) {
811155e4:	e0bffc43 	ldbu	r2,-15(fp)
811155e8:	10800044 	addi	r2,r2,1
811155ec:	e0bffc45 	stb	r2,-15(fp)
811155f0:	e0bffc43 	ldbu	r2,-15(fp)
811155f4:	108000b0 	cmpltui	r2,r2,2
811155f8:	103fd71e 	bne	r2,zero,81115558 <__reset+0xfb0f5558>
						mem_offset = xSimMebL->xFeeControl.xNfee[NFee_i].xMemMap.xCcd[ccd_number].xRight.ulOffsetAddr;
					}
					pattern_createPattern(mem_number, mem_offset, ccd_number, ccd_side, width_cols, height_rows);
				}
				#ifdef DEBUG_ON
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
811155fc:	d0a05e17 	ldw	r2,-32392(gp)
81115600:	e0fffc83 	ldbu	r3,-14(fp)
81115604:	e13ffc03 	ldbu	r4,-16(fp)
81115608:	200f883a 	mov	r7,r4
8111560c:	180d883a 	mov	r6,r3
81115610:	01604574 	movhi	r5,33045
81115614:	29684f04 	addi	r5,r5,-24260
81115618:	1009883a 	mov	r4,r2
8111561c:	111ca180 	call	8111ca18 <fprintf>

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
			/* 4 CCDs */
			width_cols = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHeight + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiOLN;
			height_rows = xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiHalfWidth + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSOverscanN + xSimMebL->xFeeControl.xNfee[NFee_i].xCcdInfo.usiSPrescanN;
			for( ccd_number = 0; ccd_number < 4; ccd_number++ ) {
81115620:	e0bffc03 	ldbu	r2,-16(fp)
81115624:	10800044 	addi	r2,r2,1
81115628:	e0bffc05 	stb	r2,-16(fp)
8111562c:	e0bffc03 	ldbu	r2,-16(fp)
81115630:	10800130 	cmpltui	r2,r2,4
81115634:	103fc61e 	bne	r2,zero,81115550 <__reset+0xfb0f5550>

	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
		/* n NFEE */

		for( NFee_i = 0; NFee_i < n_of_NFEE_in_mem; NFee_i++ ) {
81115638:	e0bffc83 	ldbu	r2,-14(fp)
8111563c:	10800044 	addi	r2,r2,1
81115640:	e0bffc85 	stb	r2,-14(fp)
81115644:	e0fffc83 	ldbu	r3,-14(fp)
81115648:	e0bffcc3 	ldbu	r2,-13(fp)
8111564c:	18bf9636 	bltu	r3,r2,811154a8 <__reset+0xfb0f54a8>
					fprintf(fp, "NFEE %i - CCD %i. \n", NFee_i, ccd_number);
				#endif
			}
		}
		#ifdef DEBUG_ON
			fprintf(fp, "Memory %i. \n",mem_number);
81115650:	d0a05e17 	ldw	r2,-32392(gp)
81115654:	e0fffa03 	ldbu	r3,-24(fp)
81115658:	180d883a 	mov	r6,r3
8111565c:	01604574 	movhi	r5,33045
81115660:	29685404 	addi	r5,r5,-24240
81115664:	1009883a 	mov	r4,r2
81115668:	111ca180 	call	8111ca18 <fprintf>
	debug(fp, "Start to fill the memory with Pattern.\n");
#endif


	/* memory 0 and 1*/
	for ( mem_number = 0; mem_number < 2; mem_number++ ){
8111566c:	e0bffa03 	ldbu	r2,-24(fp)
81115670:	10800044 	addi	r2,r2,1
81115674:	e0bffa05 	stb	r2,-24(fp)
81115678:	e0bffa03 	ldbu	r2,-24(fp)
8111567c:	108000b0 	cmpltui	r2,r2,2
81115680:	103f871e 	bne	r2,zero,811154a0 <__reset+0xfb0f54a0>
			fprintf(fp, "Memory %i. \n",mem_number);
		#endif
	}

#ifdef DEBUG_ON
	debug(fp, "Memory Filled. \n");
81115684:	d0a05e17 	ldw	r2,-32392(gp)
81115688:	100f883a 	mov	r7,r2
8111568c:	01800404 	movi	r6,16
81115690:	01400044 	movi	r5,1
81115694:	01204574 	movhi	r4,33045
81115698:	21285804 	addi	r4,r4,-24224
8111569c:	111d0b40 	call	8111d0b4 <fwrite>
#endif


}
811156a0:	0001883a 	nop
811156a4:	e037883a 	mov	sp,fp
811156a8:	dfc00117 	ldw	ra,4(sp)
811156ac:	df000017 	ldw	fp,0(sp)
811156b0:	dec00204 	addi	sp,sp,8
811156b4:	f800283a 	ret

811156b8 <vCCDLoadDefaultValues>:
 */

#include "ccd.h"


void vCCDLoadDefaultValues( TCcdInfos *ccdDef ) {
811156b8:	defffe04 	addi	sp,sp,-8
811156bc:	de00012e 	bgeu	sp,et,811156c4 <vCCDLoadDefaultValues+0xc>
811156c0:	003b68fa 	trap	3
811156c4:	df000115 	stw	fp,4(sp)
811156c8:	df000104 	addi	fp,sp,4
811156cc:	e13fff15 	stw	r4,-4(fp)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadCcdDefsSDCard();

	ccdDef->usiHeight = 4510;
811156d0:	e0bfff17 	ldw	r2,-4(fp)
811156d4:	00c46784 	movi	r3,4510
811156d8:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = 30;
811156dc:	e0bfff17 	ldw	r2,-4(fp)
811156e0:	00c00784 	movi	r3,30
811156e4:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = 2255;
811156e8:	e0bfff17 	ldw	r2,-4(fp)
811156ec:	00c233c4 	movi	r3,2255
811156f0:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = 15;
811156f4:	e0bfff17 	ldw	r2,-4(fp)
811156f8:	00c003c4 	movi	r3,15
811156fc:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = 25;
81115700:	e0bfff17 	ldw	r2,-4(fp)
81115704:	00c00644 	movi	r3,25
81115708:	10c0000d 	sth	r3,0(r2)
}
8111570c:	0001883a 	nop
81115710:	e037883a 	mov	sp,fp
81115714:	df000017 	ldw	fp,0(sp)
81115718:	dec00104 	addi	sp,sp,4
8111571c:	f800283a 	ret

81115720 <vCCDChangeValues>:

/* Only in NFEE_CONFIG of NFEE_STAND_BY */
/* Used to change de values of the CCD definitions from any source */
void vCCDChangeValues( TCcdInfos *ccdDef, unsigned short int usiHeight, unsigned short int usiOLN, unsigned short int usiHalfWidth,
                                unsigned short int usiSOverscanN, unsigned short int usiSPrescanN  ) {
81115720:	defff904 	addi	sp,sp,-28
81115724:	de00012e 	bgeu	sp,et,8111572c <vCCDChangeValues+0xc>
81115728:	003b68fa 	trap	3
8111572c:	df000615 	stw	fp,24(sp)
81115730:	df000604 	addi	fp,sp,24
81115734:	e13ffa15 	stw	r4,-24(fp)
81115738:	2811883a 	mov	r8,r5
8111573c:	300b883a 	mov	r5,r6
81115740:	3809883a 	mov	r4,r7
81115744:	e0c00117 	ldw	r3,4(fp)
81115748:	e0800217 	ldw	r2,8(fp)
8111574c:	e23ffb0d 	sth	r8,-20(fp)
81115750:	e17ffc0d 	sth	r5,-16(fp)
81115754:	e13ffd0d 	sth	r4,-12(fp)
81115758:	e0fffe0d 	sth	r3,-8(fp)
8111575c:	e0bfff0d 	sth	r2,-4(fp)

	ccdDef->usiHeight = usiHeight;
81115760:	e0bffa17 	ldw	r2,-24(fp)
81115764:	e0fffb0b 	ldhu	r3,-20(fp)
81115768:	10c0020d 	sth	r3,8(r2)
	ccdDef->usiOLN = usiOLN;
8111576c:	e0bffa17 	ldw	r2,-24(fp)
81115770:	e0fffc0b 	ldhu	r3,-16(fp)
81115774:	10c0010d 	sth	r3,4(r2)
	ccdDef->usiHalfWidth = usiHalfWidth;
81115778:	e0bffa17 	ldw	r2,-24(fp)
8111577c:	e0fffd0b 	ldhu	r3,-12(fp)
81115780:	10c0018d 	sth	r3,6(r2)
	ccdDef->usiSOverscanN = usiSOverscanN;
81115784:	e0bffa17 	ldw	r2,-24(fp)
81115788:	e0fffe0b 	ldhu	r3,-8(fp)
8111578c:	10c0008d 	sth	r3,2(r2)
	ccdDef->usiSPrescanN = usiSPrescanN;
81115790:	e0bffa17 	ldw	r2,-24(fp)
81115794:	e0ffff0b 	ldhu	r3,-4(fp)
81115798:	10c0000d 	sth	r3,0(r2)
}
8111579c:	0001883a 	nop
811157a0:	e037883a 	mov	sp,fp
811157a4:	df000017 	ldw	fp,0(sp)
811157a8:	dec00104 	addi	sp,sp,4
811157ac:	f800283a 	ret

811157b0 <bSendUART128v2>:
#include "communication_utils.h"


/* Make sure that there is only 127 characters to send */
/* Always, ALWAYS send only an char[128] that you first did a memset(cBuffer,0,128), before put some string on it. */
bool bSendUART128v2 ( char *cBuffer, short int siIdMessage ) {
811157b0:	defff904 	addi	sp,sp,-28
811157b4:	de00012e 	bgeu	sp,et,811157bc <bSendUART128v2+0xc>
811157b8:	003b68fa 	trap	3
811157bc:	dfc00615 	stw	ra,24(sp)
811157c0:	df000515 	stw	fp,20(sp)
811157c4:	df000504 	addi	fp,sp,20
811157c8:	e13ffe15 	stw	r4,-8(fp)
811157cc:	2805883a 	mov	r2,r5
811157d0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;;
811157d4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
811157d8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
811157dc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
811157e0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer128, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
811157e4:	d0a05f17 	ldw	r2,-32388(gp)
811157e8:	e0fffd04 	addi	r3,fp,-12
811157ec:	180d883a 	mov	r6,r3
811157f0:	01400504 	movi	r5,20
811157f4:	1009883a 	mov	r4,r2
811157f8:	113aaf40 	call	8113aaf4 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
811157fc:	e0bffd03 	ldbu	r2,-12(fp)
81115800:	10803fcc 	andi	r2,r2,255
81115804:	10000326 	beq	r2,zero,81115814 <bSendUART128v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81115808:	11181b80 	call	811181b8 <vFailGetCountSemaphorexBuffer128>
		return bSuccessL;
8111580c:	e0bffc17 	ldw	r2,-16(fp)
81115810:	00009e06 	br	81115a8c <bSendUART128v2+0x2dc>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer128 */
	OSMutexPend(xMutexBuffer128, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81115814:	d0a06a17 	ldw	r2,-32344(gp)
81115818:	e0fffd04 	addi	r3,fp,-12
8111581c:	180d883a 	mov	r6,r3
81115820:	01400104 	movi	r5,4
81115824:	1009883a 	mov	r4,r2
81115828:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
8111582c:	e0bffd03 	ldbu	r2,-12(fp)
81115830:	10803fcc 	andi	r2,r2,255
81115834:	10001126 	beq	r2,zero,8111587c <bSendUART128v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer128 that protect xBuffer128. (bSendUART128v2)\n");
81115838:	d0a05e17 	ldw	r2,-32392(gp)
8111583c:	100f883a 	mov	r7,r2
81115840:	01801484 	movi	r6,82
81115844:	01400044 	movi	r5,1
81115848:	01204574 	movhi	r4,33045
8111584c:	21285d04 	addi	r4,r4,-24204
81115850:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer128);
81115854:	d0a05f17 	ldw	r2,-32388(gp)
81115858:	1009883a 	mov	r4,r2
8111585c:	113ae7c0 	call	8113ae7c <OSSemPost>
81115860:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81115864:	e0bffd03 	ldbu	r2,-12(fp)
81115868:	10803fcc 	andi	r2,r2,255
8111586c:	10000126 	beq	r2,zero,81115874 <bSendUART128v2+0xc4>
			vFailSetCountSemaphorexBuffer128(); /*Could not send back the semaphore, this is critical.*/
81115870:	11181500 	call	81118150 <vFailSetCountSemaphorexBuffer128>
		}

		return bSuccessL;
81115874:	e0bffc17 	ldw	r2,-16(fp)
81115878:	00008406 	br	81115a8c <bSendUART128v2+0x2dc>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
8111587c:	e03ffb05 	stb	zero,-20(fp)
81115880:	00004306 	br	81115990 <bSendUART128v2+0x1e0>
	{
		if ( xInUseRetrans.b128[ucIL] == FALSE ) {
81115884:	e0fffb03 	ldbu	r3,-20(fp)
81115888:	00a045b4 	movhi	r2,33046
8111588c:	10a93204 	addi	r2,r2,-23352
81115890:	18c7883a 	add	r3,r3,r3
81115894:	18c7883a 	add	r3,r3,r3
81115898:	10c5883a 	add	r2,r2,r3
8111589c:	10800017 	ldw	r2,0(r2)
811158a0:	1000381e 	bne	r2,zero,81115984 <bSendUART128v2+0x1d4>
			/* Clear the buffer */
			memset(xBuffer128[ucIL].buffer, 0, 128);
811158a4:	e0bffb03 	ldbu	r2,-20(fp)
811158a8:	10c02324 	muli	r3,r2,140
811158ac:	00a045b4 	movhi	r2,33046
811158b0:	10a95004 	addi	r2,r2,-23232
811158b4:	1885883a 	add	r2,r3,r2
811158b8:	01802004 	movi	r6,128
811158bc:	000b883a 	mov	r5,zero
811158c0:	1009883a 	mov	r4,r2
811158c4:	111dc180 	call	8111dc18 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer128[ucIL].buffer, cBuffer, 127);
811158c8:	e0bffb03 	ldbu	r2,-20(fp)
811158cc:	10c02324 	muli	r3,r2,140
811158d0:	00a045b4 	movhi	r2,33046
811158d4:	10a95004 	addi	r2,r2,-23232
811158d8:	1885883a 	add	r2,r3,r2
811158dc:	01801fc4 	movi	r6,127
811158e0:	e17ffe17 	ldw	r5,-8(fp)
811158e4:	1009883a 	mov	r4,r2
811158e8:	111dac80 	call	8111dac8 <memcpy>
			xBuffer128[ucIL].usiId = siIdMessage;
811158ec:	e13ffb03 	ldbu	r4,-20(fp)
811158f0:	e0ffff0b 	ldhu	r3,-4(fp)
811158f4:	00a045b4 	movhi	r2,33046
811158f8:	10a95004 	addi	r2,r2,-23232
811158fc:	21002324 	muli	r4,r4,140
81115900:	1105883a 	add	r2,r2,r4
81115904:	10802104 	addi	r2,r2,132
81115908:	10c0000d 	sth	r3,0(r2)
			xBuffer128[ucIL].ucNofRetries = 0;
8111590c:	e0fffb03 	ldbu	r3,-20(fp)
81115910:	00a045b4 	movhi	r2,33046
81115914:	10a95004 	addi	r2,r2,-23232
81115918:	18c02324 	muli	r3,r3,140
8111591c:	10c5883a 	add	r2,r2,r3
81115920:	10802204 	addi	r2,r2,136
81115924:	10000005 	stb	zero,0(r2)
			xBuffer128[ucIL].usiTimeOut = 0;
81115928:	e0fffb03 	ldbu	r3,-20(fp)
8111592c:	00a045b4 	movhi	r2,33046
81115930:	10a95004 	addi	r2,r2,-23232
81115934:	18c02324 	muli	r3,r3,140
81115938:	10c5883a 	add	r2,r2,r3
8111593c:	10802184 	addi	r2,r2,134
81115940:	1000000d 	sth	zero,0(r2)
			xBuffer128[ucIL].bSent = FALSE;
81115944:	e0fffb03 	ldbu	r3,-20(fp)
81115948:	00a045b4 	movhi	r2,33046
8111594c:	10a95004 	addi	r2,r2,-23232
81115950:	18c02324 	muli	r3,r3,140
81115954:	10c5883a 	add	r2,r2,r3
81115958:	10802004 	addi	r2,r2,128
8111595c:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b128[ucIL] = TRUE;
81115960:	e0fffb03 	ldbu	r3,-20(fp)
81115964:	00a045b4 	movhi	r2,33046
81115968:	10a93204 	addi	r2,r2,-23352
8111596c:	18c7883a 	add	r3,r3,r3
81115970:	18c7883a 	add	r3,r3,r3
81115974:	10c5883a 	add	r2,r2,r3
81115978:	00c00044 	movi	r3,1
8111597c:	10c00015 	stw	r3,0(r2)
			break;
81115980:	00000606 	br	8111599c <bSendUART128v2+0x1ec>
	/* ---> At this point we Have the mutex of the xBuffer128, and we can use it freely */


	
	/* Search for space */
	for( ucIL = 0; ucIL < N_128; ucIL++)
81115984:	e0bffb03 	ldbu	r2,-20(fp)
81115988:	10800044 	addi	r2,r2,1
8111598c:	e0bffb05 	stb	r2,-20(fp)
81115990:	e0bffb03 	ldbu	r2,-20(fp)
81115994:	108001b0 	cmpltui	r2,r2,6
81115998:	103fba1e 	bne	r2,zero,81115884 <__reset+0xfb0f5884>
			xInUseRetrans.b128[ucIL] = TRUE;
			break;
		}
	}

	if ( ucIL >= N_128 ) {
8111599c:	e0bffb03 	ldbu	r2,-20(fp)
811159a0:	108001b0 	cmpltui	r2,r2,6
811159a4:	1000091e 	bne	r2,zero,811159cc <bSendUART128v2+0x21c>
		ucErrorCode = OSSemPost(xSemCountBuffer128);
811159a8:	d0a05f17 	ldw	r2,-32388(gp)
811159ac:	1009883a 	mov	r4,r2
811159b0:	113ae7c0 	call	8113ae7c <OSSemPost>
811159b4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer128);
811159b8:	d0a06a17 	ldw	r2,-32344(gp)
811159bc:	1009883a 	mov	r4,r2
811159c0:	113908c0 	call	8113908c <OSMutexPost>
		return bSuccessL;
811159c4:	e0bffc17 	ldw	r2,-16(fp)
811159c8:	00003006 	br	81115a8c <bSendUART128v2+0x2dc>
	}

	bSuccessL = TRUE;
811159cc:	00800044 	movi	r2,1
811159d0:	e0bffc15 	stw	r2,-16(fp)
	SemCount128--; /* Sure that you get the semaphore */
811159d4:	d0a07143 	ldbu	r2,-32315(gp)
811159d8:	10bfffc4 	addi	r2,r2,-1
811159dc:	d0a07145 	stb	r2,-32315(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
811159e0:	d0a07017 	ldw	r2,-32320(gp)
811159e4:	e0fffd04 	addi	r3,fp,-12
811159e8:	180d883a 	mov	r6,r3
811159ec:	01400084 	movi	r5,2
811159f0:	1009883a 	mov	r4,r2
811159f4:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
811159f8:	e0bffd03 	ldbu	r2,-12(fp)
811159fc:	10803fcc 	andi	r2,r2,255
81115a00:	10000c26 	beq	r2,zero,81115a34 <bSendUART128v2+0x284>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART128v2)\n");
81115a04:	d0a05e17 	ldw	r2,-32392(gp)
81115a08:	100f883a 	mov	r7,r2
81115a0c:	01801c04 	movi	r6,112
81115a10:	01400044 	movi	r5,1
81115a14:	01204574 	movhi	r4,33045
81115a18:	21287204 	addi	r4,r4,-24120
81115a1c:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer128 */
		OSMutexPost(xMutexBuffer128); /* Free the Mutex after use the xBuffer128*/
81115a20:	d0a06a17 	ldw	r2,-32344(gp)
81115a24:	1009883a 	mov	r4,r2
81115a28:	113908c0 	call	8113908c <OSMutexPost>
		return bSuccessL;
81115a2c:	e0bffc17 	ldw	r2,-16(fp)
81115a30:	00001606 	br	81115a8c <bSendUART128v2+0x2dc>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer128[ucIL].buffer);
81115a34:	e0bffb03 	ldbu	r2,-20(fp)
81115a38:	10c02324 	muli	r3,r2,140
81115a3c:	00a045b4 	movhi	r2,33046
81115a40:	10a95004 	addi	r2,r2,-23232
81115a44:	1885883a 	add	r2,r3,r2
81115a48:	1009883a 	mov	r4,r2
81115a4c:	111e0640 	call	8111e064 <puts>
	xBuffer128[ucIL].bSent = TRUE;
81115a50:	e0fffb03 	ldbu	r3,-20(fp)
81115a54:	00a045b4 	movhi	r2,33046
81115a58:	10a95004 	addi	r2,r2,-23232
81115a5c:	18c02324 	muli	r3,r3,140
81115a60:	10c5883a 	add	r2,r2,r3
81115a64:	10802004 	addi	r2,r2,128
81115a68:	00c00044 	movi	r3,1
81115a6c:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */

	OSMutexPost(xTxUARTMutex);
81115a70:	d0a07017 	ldw	r2,-32320(gp)
81115a74:	1009883a 	mov	r4,r2
81115a78:	113908c0 	call	8113908c <OSMutexPost>
	OSMutexPost(xMutexBuffer128);
81115a7c:	d0a06a17 	ldw	r2,-32344(gp)
81115a80:	1009883a 	mov	r4,r2
81115a84:	113908c0 	call	8113908c <OSMutexPost>

	return bSuccessL;
81115a88:	e0bffc17 	ldw	r2,-16(fp)
}
81115a8c:	e037883a 	mov	sp,fp
81115a90:	dfc00117 	ldw	ra,4(sp)
81115a94:	df000017 	ldw	fp,0(sp)
81115a98:	dec00204 	addi	sp,sp,8
81115a9c:	f800283a 	ret

81115aa0 <bSendUART64v2>:



/* Make sure that there is only 63 characters to send */
/* Always, ALWAYS send only an char[64] that you first did a memset(cBuffer,0,64), before put some string on it. */
bool bSendUART64v2 ( char *cBuffer, short int siIdMessage ) {
81115aa0:	defff904 	addi	sp,sp,-28
81115aa4:	de00012e 	bgeu	sp,et,81115aac <bSendUART64v2+0xc>
81115aa8:	003b68fa 	trap	3
81115aac:	dfc00615 	stw	ra,24(sp)
81115ab0:	df000515 	stw	fp,20(sp)
81115ab4:	df000504 	addi	fp,sp,20
81115ab8:	e13ffe15 	stw	r4,-8(fp)
81115abc:	2805883a 	mov	r2,r5
81115ac0:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81115ac4:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81115ac8:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81115acc:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81115ad0:	e03ffc15 	stw	zero,-16(fp)

	OSSemPend(xSemCountBuffer64, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81115ad4:	d0a05a17 	ldw	r2,-32408(gp)
81115ad8:	e0fffd04 	addi	r3,fp,-12
81115adc:	180d883a 	mov	r6,r3
81115ae0:	01400504 	movi	r5,20
81115ae4:	1009883a 	mov	r4,r2
81115ae8:	113aaf40 	call	8113aaf4 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81115aec:	e0bffd03 	ldbu	r2,-12(fp)
81115af0:	10803fcc 	andi	r2,r2,255
81115af4:	10000326 	beq	r2,zero,81115b04 <bSendUART64v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81115af8:	11182200 	call	81118220 <vFailGetCountSemaphorexBuffer64>
		return bSuccessL;
81115afc:	e0bffc17 	ldw	r2,-16(fp)
81115b00:	0000a006 	br	81115d84 <bSendUART64v2+0x2e4>
	/* ---> At this point we know that there is some space in the buffer */

	
	
	/* Need to get the Mutex that protects xBuffer64 */
	OSMutexPend(xMutexBuffer64, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81115b04:	d0a06d17 	ldw	r2,-32332(gp)
81115b08:	e0fffd04 	addi	r3,fp,-12
81115b0c:	180d883a 	mov	r6,r3
81115b10:	01400104 	movi	r5,4
81115b14:	1009883a 	mov	r4,r2
81115b18:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81115b1c:	e0bffd03 	ldbu	r2,-12(fp)
81115b20:	10803fcc 	andi	r2,r2,255
81115b24:	10001126 	beq	r2,zero,81115b6c <bSendUART64v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer64 that protect xBuffer64. (bSendUART64v2)\n");
81115b28:	d0a05e17 	ldw	r2,-32392(gp)
81115b2c:	100f883a 	mov	r7,r2
81115b30:	018013c4 	movi	r6,79
81115b34:	01400044 	movi	r5,1
81115b38:	01204574 	movhi	r4,33045
81115b3c:	21288f04 	addi	r4,r4,-24004
81115b40:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81115b44:	d0a05a17 	ldw	r2,-32408(gp)
81115b48:	1009883a 	mov	r4,r2
81115b4c:	113ae7c0 	call	8113ae7c <OSSemPost>
81115b50:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81115b54:	e0bffd03 	ldbu	r2,-12(fp)
81115b58:	10803fcc 	andi	r2,r2,255
81115b5c:	10000126 	beq	r2,zero,81115b64 <bSendUART64v2+0xc4>
			vFailSetCountSemaphorexBuffer64(); /*Could not send back the semaphore, this is critical.*/
81115b60:	11180e80 	call	811180e8 <vFailSetCountSemaphorexBuffer64>
		}

		return bSuccessL;
81115b64:	e0bffc17 	ldw	r2,-16(fp)
81115b68:	00008606 	br	81115d84 <bSendUART64v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81115b6c:	e03ffb05 	stb	zero,-20(fp)
81115b70:	00004506 	br	81115c88 <bSendUART64v2+0x1e8>
	{
		if ( xInUseRetrans.b64[ucIL] == FALSE ) {
81115b74:	e0fffb03 	ldbu	r3,-20(fp)
81115b78:	00a045b4 	movhi	r2,33046
81115b7c:	10a93204 	addi	r2,r2,-23352
81115b80:	18c00184 	addi	r3,r3,6
81115b84:	18c7883a 	add	r3,r3,r3
81115b88:	18c7883a 	add	r3,r3,r3
81115b8c:	10c5883a 	add	r2,r2,r3
81115b90:	10800017 	ldw	r2,0(r2)
81115b94:	1000391e 	bne	r2,zero,81115c7c <bSendUART64v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer64[ucIL].buffer, 0, 64);
81115b98:	e0bffb03 	ldbu	r2,-20(fp)
81115b9c:	10c01324 	muli	r3,r2,76
81115ba0:	00a04574 	movhi	r2,33045
81115ba4:	10851104 	addi	r2,r2,5188
81115ba8:	1885883a 	add	r2,r3,r2
81115bac:	01801004 	movi	r6,64
81115bb0:	000b883a 	mov	r5,zero
81115bb4:	1009883a 	mov	r4,r2
81115bb8:	111dc180 	call	8111dc18 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer64[ucIL].buffer, cBuffer, 63);
81115bbc:	e0bffb03 	ldbu	r2,-20(fp)
81115bc0:	10c01324 	muli	r3,r2,76
81115bc4:	00a04574 	movhi	r2,33045
81115bc8:	10851104 	addi	r2,r2,5188
81115bcc:	1885883a 	add	r2,r3,r2
81115bd0:	01800fc4 	movi	r6,63
81115bd4:	e17ffe17 	ldw	r5,-8(fp)
81115bd8:	1009883a 	mov	r4,r2
81115bdc:	111dac80 	call	8111dac8 <memcpy>
			xBuffer64[ucIL].usiId = siIdMessage;
81115be0:	e13ffb03 	ldbu	r4,-20(fp)
81115be4:	e0ffff0b 	ldhu	r3,-4(fp)
81115be8:	00a04574 	movhi	r2,33045
81115bec:	10851104 	addi	r2,r2,5188
81115bf0:	21001324 	muli	r4,r4,76
81115bf4:	1105883a 	add	r2,r2,r4
81115bf8:	10801104 	addi	r2,r2,68
81115bfc:	10c0000d 	sth	r3,0(r2)
			xBuffer64[ucIL].ucNofRetries = 0;
81115c00:	e0fffb03 	ldbu	r3,-20(fp)
81115c04:	00a04574 	movhi	r2,33045
81115c08:	10851104 	addi	r2,r2,5188
81115c0c:	18c01324 	muli	r3,r3,76
81115c10:	10c5883a 	add	r2,r2,r3
81115c14:	10801204 	addi	r2,r2,72
81115c18:	10000005 	stb	zero,0(r2)
			xBuffer64[ucIL].usiTimeOut = 0;
81115c1c:	e0fffb03 	ldbu	r3,-20(fp)
81115c20:	00a04574 	movhi	r2,33045
81115c24:	10851104 	addi	r2,r2,5188
81115c28:	18c01324 	muli	r3,r3,76
81115c2c:	10c5883a 	add	r2,r2,r3
81115c30:	10801184 	addi	r2,r2,70
81115c34:	1000000d 	sth	zero,0(r2)
			xBuffer64[ucIL].bSent = FALSE;
81115c38:	e0fffb03 	ldbu	r3,-20(fp)
81115c3c:	00a04574 	movhi	r2,33045
81115c40:	10851104 	addi	r2,r2,5188
81115c44:	18c01324 	muli	r3,r3,76
81115c48:	10c5883a 	add	r2,r2,r3
81115c4c:	10801004 	addi	r2,r2,64
81115c50:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b64[ucIL] = TRUE;
81115c54:	e0fffb03 	ldbu	r3,-20(fp)
81115c58:	00a045b4 	movhi	r2,33046
81115c5c:	10a93204 	addi	r2,r2,-23352
81115c60:	18c00184 	addi	r3,r3,6
81115c64:	18c7883a 	add	r3,r3,r3
81115c68:	18c7883a 	add	r3,r3,r3
81115c6c:	10c5883a 	add	r2,r2,r3
81115c70:	00c00044 	movi	r3,1
81115c74:	10c00015 	stw	r3,0(r2)
			break;
81115c78:	00000606 	br	81115c94 <bSendUART64v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_64; ucIL++)
81115c7c:	e0bffb03 	ldbu	r2,-20(fp)
81115c80:	10800044 	addi	r2,r2,1
81115c84:	e0bffb05 	stb	r2,-20(fp)
81115c88:	e0bffb03 	ldbu	r2,-20(fp)
81115c8c:	10800230 	cmpltui	r2,r2,8
81115c90:	103fb81e 	bne	r2,zero,81115b74 <__reset+0xfb0f5b74>
			break;
		}
	}


	if ( ucIL >= N_64 ) {
81115c94:	e0bffb03 	ldbu	r2,-20(fp)
81115c98:	10800230 	cmpltui	r2,r2,8
81115c9c:	1000091e 	bne	r2,zero,81115cc4 <bSendUART64v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer64);
81115ca0:	d0a05a17 	ldw	r2,-32408(gp)
81115ca4:	1009883a 	mov	r4,r2
81115ca8:	113ae7c0 	call	8113ae7c <OSSemPost>
81115cac:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer64);
81115cb0:	d0a06d17 	ldw	r2,-32332(gp)
81115cb4:	1009883a 	mov	r4,r2
81115cb8:	113908c0 	call	8113908c <OSMutexPost>
		return bSuccessL;
81115cbc:	e0bffc17 	ldw	r2,-16(fp)
81115cc0:	00003006 	br	81115d84 <bSendUART64v2+0x2e4>
	}

	bSuccessL = TRUE;
81115cc4:	00800044 	movi	r2,1
81115cc8:	e0bffc15 	stw	r2,-16(fp)
	SemCount64--; /* Sure that you get the semaphore */
81115ccc:	d0a07103 	ldbu	r2,-32316(gp)
81115cd0:	10bfffc4 	addi	r2,r2,-1
81115cd4:	d0a07105 	stb	r2,-32316(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81115cd8:	d0a07017 	ldw	r2,-32320(gp)
81115cdc:	e0fffd04 	addi	r3,fp,-12
81115ce0:	180d883a 	mov	r6,r3
81115ce4:	01400084 	movi	r5,2
81115ce8:	1009883a 	mov	r4,r2
81115cec:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81115cf0:	e0bffd03 	ldbu	r2,-12(fp)
81115cf4:	10803fcc 	andi	r2,r2,255
81115cf8:	10000c26 	beq	r2,zero,81115d2c <bSendUART64v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART64v2)\n");
81115cfc:	d0a05e17 	ldw	r2,-32392(gp)
81115d00:	100f883a 	mov	r7,r2
81115d04:	01801bc4 	movi	r6,111
81115d08:	01400044 	movi	r5,1
81115d0c:	01204574 	movhi	r4,33045
81115d10:	2128a304 	addi	r4,r4,-23924
81115d14:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer64); /* Free the Mutex after use the xBuffer64 */
81115d18:	d0a06d17 	ldw	r2,-32332(gp)
81115d1c:	1009883a 	mov	r4,r2
81115d20:	113908c0 	call	8113908c <OSMutexPost>
		return bSuccessL;
81115d24:	e0bffc17 	ldw	r2,-16(fp)
81115d28:	00001606 	br	81115d84 <bSendUART64v2+0x2e4>


	/* ---> At this point we have all resources to send the message */


	puts(xBuffer64[ucIL].buffer);
81115d2c:	e0bffb03 	ldbu	r2,-20(fp)
81115d30:	10c01324 	muli	r3,r2,76
81115d34:	00a04574 	movhi	r2,33045
81115d38:	10851104 	addi	r2,r2,5188
81115d3c:	1885883a 	add	r2,r3,r2
81115d40:	1009883a 	mov	r4,r2
81115d44:	111e0640 	call	8111e064 <puts>
	xBuffer64[ucIL].bSent = TRUE;
81115d48:	e0fffb03 	ldbu	r3,-20(fp)
81115d4c:	00a04574 	movhi	r2,33045
81115d50:	10851104 	addi	r2,r2,5188
81115d54:	18c01324 	muli	r3,r3,76
81115d58:	10c5883a 	add	r2,r2,r3
81115d5c:	10801004 	addi	r2,r2,64
81115d60:	00c00044 	movi	r3,1
81115d64:	10c00015 	stw	r3,0(r2)


	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */
	OSMutexPost(xTxUARTMutex);
81115d68:	d0a07017 	ldw	r2,-32320(gp)
81115d6c:	1009883a 	mov	r4,r2
81115d70:	113908c0 	call	8113908c <OSMutexPost>
	OSMutexPost(xMutexBuffer64);
81115d74:	d0a06d17 	ldw	r2,-32332(gp)
81115d78:	1009883a 	mov	r4,r2
81115d7c:	113908c0 	call	8113908c <OSMutexPost>

	return bSuccessL;
81115d80:	e0bffc17 	ldw	r2,-16(fp)
}
81115d84:	e037883a 	mov	sp,fp
81115d88:	dfc00117 	ldw	ra,4(sp)
81115d8c:	df000017 	ldw	fp,0(sp)
81115d90:	dec00204 	addi	sp,sp,8
81115d94:	f800283a 	ret

81115d98 <bSendUART32v2>:



/* Make sure that there is only 31 characters to send */
/* Always, ALWAYS send only an char[32] that you first did a memset(cBuffer,0,32), before put some string on it. */
bool bSendUART32v2 ( char *cBuffer, short int siIdMessage ) {
81115d98:	defff904 	addi	sp,sp,-28
81115d9c:	de00012e 	bgeu	sp,et,81115da4 <bSendUART32v2+0xc>
81115da0:	003b68fa 	trap	3
81115da4:	dfc00615 	stw	ra,24(sp)
81115da8:	df000515 	stw	fp,20(sp)
81115dac:	df000504 	addi	fp,sp,20
81115db0:	e13ffe15 	stw	r4,-8(fp)
81115db4:	2805883a 	mov	r2,r5
81115db8:	e0bfff0d 	sth	r2,-4(fp)
	INT8U ucErrorCode = 0;
81115dbc:	e03ffd05 	stb	zero,-12(fp)
	unsigned char ucIL = 0;
81115dc0:	e03ffb05 	stb	zero,-20(fp)
	bool bSuccessL = FALSE;
81115dc4:	e03ffc15 	stw	zero,-16(fp)
	

	bSuccessL = FALSE;
81115dc8:	e03ffc15 	stw	zero,-16(fp)
	
	OSSemPend(xSemCountBuffer32, TICKS_WAITING_FOR_SPACE, &ucErrorCode);
81115dcc:	d0a06b17 	ldw	r2,-32340(gp)
81115dd0:	e0fffd04 	addi	r3,fp,-12
81115dd4:	180d883a 	mov	r6,r3
81115dd8:	01400504 	movi	r5,20
81115ddc:	1009883a 	mov	r4,r2
81115de0:	113aaf40 	call	8113aaf4 <OSSemPend>
	/* Check if gets The semaphore, if yes means that are some space in the (re)transmission buffer */
	if ( ucErrorCode != OS_NO_ERR ) {
81115de4:	e0bffd03 	ldbu	r2,-12(fp)
81115de8:	10803fcc 	andi	r2,r2,255
81115dec:	10000326 	beq	r2,zero,81115dfc <bSendUART32v2+0x64>
		/* No space in the transmission buffer */
		vFailGetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81115df0:	11182880 	call	81118288 <vFailGetCountSemaphorexBuffer32>
		return bSuccessL;
81115df4:	e0bffc17 	ldw	r2,-16(fp)
81115df8:	0000a006 	br	8111607c <bSendUART32v2+0x2e4>

	/* ---> At this point we know that there is some space in the buffer */


	/* Need to get the Mutex that protects xBuffer32 */
	OSMutexPend(xMutexBuffer32, TICKS_WAITING_MUTEX_RETRANS, &ucErrorCode); /* Wait X ticks = X ms */
81115dfc:	d0a06817 	ldw	r2,-32352(gp)
81115e00:	e0fffd04 	addi	r3,fp,-12
81115e04:	180d883a 	mov	r6,r3
81115e08:	01400104 	movi	r5,4
81115e0c:	1009883a 	mov	r4,r2
81115e10:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81115e14:	e0bffd03 	ldbu	r2,-12(fp)
81115e18:	10803fcc 	andi	r2,r2,255
81115e1c:	10001126 	beq	r2,zero,81115e64 <bSendUART32v2+0xcc>
		/* Could not get the mutex, so we need to give the semaphore back */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xMutexBuffer32 that protect xBuffer32. (bSendUART32v2)\n");
81115e20:	d0a05e17 	ldw	r2,-32392(gp)
81115e24:	100f883a 	mov	r7,r2
81115e28:	018013c4 	movi	r6,79
81115e2c:	01400044 	movi	r5,1
81115e30:	01204574 	movhi	r4,33045
81115e34:	2128bf04 	addi	r4,r4,-23812
81115e38:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81115e3c:	d0a06b17 	ldw	r2,-32340(gp)
81115e40:	1009883a 	mov	r4,r2
81115e44:	113ae7c0 	call	8113ae7c <OSSemPost>
81115e48:	e0bffd05 	stb	r2,-12(fp)
		if ( ucErrorCode != OS_ERR_NONE ) {
81115e4c:	e0bffd03 	ldbu	r2,-12(fp)
81115e50:	10803fcc 	andi	r2,r2,255
81115e54:	10000126 	beq	r2,zero,81115e5c <bSendUART32v2+0xc4>
			vFailSetCountSemaphorexBuffer32(); /*Could not send back the semaphore, this is critical.*/
81115e58:	11180800 	call	81118080 <vFailSetCountSemaphorexBuffer32>
		}

		return bSuccessL;
81115e5c:	e0bffc17 	ldw	r2,-16(fp)
81115e60:	00008606 	br	8111607c <bSendUART32v2+0x2e4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81115e64:	e03ffb05 	stb	zero,-20(fp)
81115e68:	00004506 	br	81115f80 <bSendUART32v2+0x1e8>
	{
		if ( xInUseRetrans.b32[ucIL] == FALSE ) {
81115e6c:	e0fffb03 	ldbu	r3,-20(fp)
81115e70:	00a045b4 	movhi	r2,33046
81115e74:	10a93204 	addi	r2,r2,-23352
81115e78:	18c00384 	addi	r3,r3,14
81115e7c:	18c7883a 	add	r3,r3,r3
81115e80:	18c7883a 	add	r3,r3,r3
81115e84:	10c5883a 	add	r2,r2,r3
81115e88:	10800017 	ldw	r2,0(r2)
81115e8c:	1000391e 	bne	r2,zero,81115f74 <bSendUART32v2+0x1dc>
			/* Clear the buffer */
			memset(xBuffer32[ucIL].buffer, 0, 32);
81115e90:	e0bffb03 	ldbu	r2,-20(fp)
81115e94:	10c00b24 	muli	r3,r2,44
81115e98:	00a04574 	movhi	r2,33045
81115e9c:	1096be04 	addi	r2,r2,23288
81115ea0:	1885883a 	add	r2,r3,r2
81115ea4:	01800804 	movi	r6,32
81115ea8:	000b883a 	mov	r5,zero
81115eac:	1009883a 	mov	r4,r2
81115eb0:	111dc180 	call	8111dc18 <memset>
			/* Making sure that will have some \0 */
			memcpy(xBuffer32[ucIL].buffer, cBuffer, 31);
81115eb4:	e0bffb03 	ldbu	r2,-20(fp)
81115eb8:	10c00b24 	muli	r3,r2,44
81115ebc:	00a04574 	movhi	r2,33045
81115ec0:	1096be04 	addi	r2,r2,23288
81115ec4:	1885883a 	add	r2,r3,r2
81115ec8:	018007c4 	movi	r6,31
81115ecc:	e17ffe17 	ldw	r5,-8(fp)
81115ed0:	1009883a 	mov	r4,r2
81115ed4:	111dac80 	call	8111dac8 <memcpy>
			xBuffer32[ucIL].usiId = siIdMessage;
81115ed8:	e13ffb03 	ldbu	r4,-20(fp)
81115edc:	e0ffff0b 	ldhu	r3,-4(fp)
81115ee0:	00a04574 	movhi	r2,33045
81115ee4:	1096be04 	addi	r2,r2,23288
81115ee8:	21000b24 	muli	r4,r4,44
81115eec:	1105883a 	add	r2,r2,r4
81115ef0:	10800904 	addi	r2,r2,36
81115ef4:	10c0000d 	sth	r3,0(r2)
			xBuffer32[ucIL].ucNofRetries = 0;
81115ef8:	e0fffb03 	ldbu	r3,-20(fp)
81115efc:	00a04574 	movhi	r2,33045
81115f00:	1096be04 	addi	r2,r2,23288
81115f04:	18c00b24 	muli	r3,r3,44
81115f08:	10c5883a 	add	r2,r2,r3
81115f0c:	10800a04 	addi	r2,r2,40
81115f10:	10000005 	stb	zero,0(r2)
			xBuffer32[ucIL].usiTimeOut = 0;
81115f14:	e0fffb03 	ldbu	r3,-20(fp)
81115f18:	00a04574 	movhi	r2,33045
81115f1c:	1096be04 	addi	r2,r2,23288
81115f20:	18c00b24 	muli	r3,r3,44
81115f24:	10c5883a 	add	r2,r2,r3
81115f28:	10800984 	addi	r2,r2,38
81115f2c:	1000000d 	sth	zero,0(r2)
			xBuffer32[ucIL].bSent = FALSE;
81115f30:	e0fffb03 	ldbu	r3,-20(fp)
81115f34:	00a04574 	movhi	r2,33045
81115f38:	1096be04 	addi	r2,r2,23288
81115f3c:	18c00b24 	muli	r3,r3,44
81115f40:	10c5883a 	add	r2,r2,r3
81115f44:	10800804 	addi	r2,r2,32
81115f48:	10000015 	stw	zero,0(r2)
			xInUseRetrans.b32[ucIL] = TRUE;
81115f4c:	e0fffb03 	ldbu	r3,-20(fp)
81115f50:	00a045b4 	movhi	r2,33046
81115f54:	10a93204 	addi	r2,r2,-23352
81115f58:	18c00384 	addi	r3,r3,14
81115f5c:	18c7883a 	add	r3,r3,r3
81115f60:	18c7883a 	add	r3,r3,r3
81115f64:	10c5883a 	add	r2,r2,r3
81115f68:	00c00044 	movi	r3,1
81115f6c:	10c00015 	stw	r3,0(r2)
			break;
81115f70:	00000606 	br	81115f8c <bSendUART32v2+0x1f4>
	

	/* ---> At this point we Have the mutex of the xBuffer64, and we can use it freely */


	for( ucIL = 0; ucIL < N_32; ucIL++)
81115f74:	e0bffb03 	ldbu	r2,-20(fp)
81115f78:	10800044 	addi	r2,r2,1
81115f7c:	e0bffb05 	stb	r2,-20(fp)
81115f80:	e0bffb03 	ldbu	r2,-20(fp)
81115f84:	10800230 	cmpltui	r2,r2,8
81115f88:	103fb81e 	bne	r2,zero,81115e6c <__reset+0xfb0f5e6c>
			xInUseRetrans.b32[ucIL] = TRUE;
			break;
		}
	}	

	if ( ucIL >= N_32 ) {
81115f8c:	e0bffb03 	ldbu	r2,-20(fp)
81115f90:	10800230 	cmpltui	r2,r2,8
81115f94:	1000091e 	bne	r2,zero,81115fbc <bSendUART32v2+0x224>
		ucErrorCode = OSSemPost(xSemCountBuffer32);
81115f98:	d0a06b17 	ldw	r2,-32340(gp)
81115f9c:	1009883a 	mov	r4,r2
81115fa0:	113ae7c0 	call	8113ae7c <OSSemPost>
81115fa4:	e0bffd05 	stb	r2,-12(fp)
		OSMutexPost(xMutexBuffer32);
81115fa8:	d0a06817 	ldw	r2,-32352(gp)
81115fac:	1009883a 	mov	r4,r2
81115fb0:	113908c0 	call	8113908c <OSMutexPost>
		return bSuccessL;
81115fb4:	e0bffc17 	ldw	r2,-16(fp)
81115fb8:	00003006 	br	8111607c <bSendUART32v2+0x2e4>
	}
	
	bSuccessL = TRUE;
81115fbc:	00800044 	movi	r2,1
81115fc0:	e0bffc15 	stw	r2,-16(fp)
	SemCount32--; /* Sure that you get the semaphore */
81115fc4:	d0a06483 	ldbu	r2,-32366(gp)
81115fc8:	10bfffc4 	addi	r2,r2,-1
81115fcc:	d0a06485 	stb	r2,-32366(gp)


	/* ---> Now try to get the Mutex that protects the TX of the UART to transmit the message */


	OSMutexPend(xTxUARTMutex, TICKS_WAITING_MUTEX_TX, &ucErrorCode); /* Wait X ticks = X ms */
81115fd0:	d0a07017 	ldw	r2,-32320(gp)
81115fd4:	e0fffd04 	addi	r3,fp,-12
81115fd8:	180d883a 	mov	r6,r3
81115fdc:	01400084 	movi	r5,2
81115fe0:	1009883a 	mov	r4,r2
81115fe4:	1138ae80 	call	81138ae8 <OSMutexPend>
	if ( ucErrorCode != OS_NO_ERR ) {
81115fe8:	e0bffd03 	ldbu	r2,-12(fp)
81115fec:	10803fcc 	andi	r2,r2,255
81115ff0:	10000c26 	beq	r2,zero,81116024 <bSendUART32v2+0x28c>
		/* Could not get the mutex of TX */
		/* That's ok, as the message was already put in the retransmission buffer it will be sent by the checker timeout task */
		#ifdef DEBUG_ON
			debug(fp,"Could not get the mutex xTxUARTMutex, but the message is already in the retransmission buffer. (bSendUART32v2)\n");
81115ff4:	d0a05e17 	ldw	r2,-32392(gp)
81115ff8:	100f883a 	mov	r7,r2
81115ffc:	01801bc4 	movi	r6,111
81116000:	01400044 	movi	r5,1
81116004:	01204574 	movhi	r4,33045
81116008:	2128d304 	addi	r4,r4,-23732
8111600c:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		/* Indicates that this buffer already has a message that should be sent by the retransmission immediately */
		/* Free the Mutex of the xBuffer64 */
		OSMutexPost(xMutexBuffer32); /* Free the Mutex after use the xMutexBuffer32 */
81116010:	d0a06817 	ldw	r2,-32352(gp)
81116014:	1009883a 	mov	r4,r2
81116018:	113908c0 	call	8113908c <OSMutexPost>
		return bSuccessL;
8111601c:	e0bffc17 	ldw	r2,-16(fp)
81116020:	00001606 	br	8111607c <bSendUART32v2+0x2e4>
	}


	/* ---> At this point we have all resources to send the message */

	puts(xBuffer32[ucIL].buffer);
81116024:	e0bffb03 	ldbu	r2,-20(fp)
81116028:	10c00b24 	muli	r3,r2,44
8111602c:	00a04574 	movhi	r2,33045
81116030:	1096be04 	addi	r2,r2,23288
81116034:	1885883a 	add	r2,r3,r2
81116038:	1009883a 	mov	r4,r2
8111603c:	111e0640 	call	8111e064 <puts>
	xBuffer32[ucIL].bSent = TRUE;
81116040:	e0fffb03 	ldbu	r3,-20(fp)
81116044:	00a04574 	movhi	r2,33045
81116048:	1096be04 	addi	r2,r2,23288
8111604c:	18c00b24 	muli	r3,r3,44
81116050:	10c5883a 	add	r2,r2,r3
81116054:	10800804 	addi	r2,r2,32
81116058:	00c00044 	movi	r3,1
8111605c:	10c00015 	stw	r3,0(r2)

	/* ---> Best scenario, giving the mutexes back in the inverse order to avoid deadlock */


	OSMutexPost(xTxUARTMutex);
81116060:	d0a07017 	ldw	r2,-32320(gp)
81116064:	1009883a 	mov	r4,r2
81116068:	113908c0 	call	8113908c <OSMutexPost>
	OSMutexPost(xMutexBuffer32);
8111606c:	d0a06817 	ldw	r2,-32352(gp)
81116070:	1009883a 	mov	r4,r2
81116074:	113908c0 	call	8113908c <OSMutexPost>

	return bSuccessL;
81116078:	e0bffc17 	ldw	r2,-16(fp)
}
8111607c:	e037883a 	mov	sp,fp
81116080:	dfc00117 	ldw	ra,4(sp)
81116084:	df000017 	ldw	fp,0(sp)
81116088:	dec00204 	addi	sp,sp,8
8111608c:	f800283a 	ret

81116090 <vSendEthConf>:


void vSendEthConf ( void ) {
81116090:	deffc304 	addi	sp,sp,-244
81116094:	de00012e 	bgeu	sp,et,8111609c <vSendEthConf+0xc>
81116098:	003b68fa 	trap	3
8111609c:	dfc03c15 	stw	ra,240(sp)
811160a0:	df003b15 	stw	fp,236(sp)
811160a4:	dd403a15 	stw	r21,232(sp)
811160a8:	dd003915 	stw	r20,228(sp)
811160ac:	dcc03815 	stw	r19,224(sp)
811160b0:	dc803715 	stw	r18,220(sp)
811160b4:	dc403615 	stw	r17,216(sp)
811160b8:	dc003515 	stw	r16,212(sp)
811160bc:	df003b04 	addi	fp,sp,236
    char cBufferETH[128] = "";
811160c0:	e03fd98d 	sth	zero,-154(fp)
811160c4:	e03fda0d 	sth	zero,-152(fp)
811160c8:	e0bfda84 	addi	r2,fp,-150
811160cc:	00c01f04 	movi	r3,124
811160d0:	180d883a 	mov	r6,r3
811160d4:	000b883a 	mov	r5,zero
811160d8:	1009883a 	mov	r4,r2
811160dc:	111dc180 	call	8111dc18 <memset>
    unsigned char crc = 0;
811160e0:	e03fd705 	stb	zero,-164(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
811160e4:	e03fd815 	stw	zero,-160(fp)

    usiIdCMDLocal = usiGetIdCMD();
811160e8:	11166500 	call	81116650 <usiGetIdCMD>
811160ec:	e0bfd90d 	sth	r2,-156(fp)

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811160f0:	e57fd90b 	ldhu	r21,-156(fp)
811160f4:	00a045b4 	movhi	r2,33046
811160f8:	1088f804 	addi	r2,r2,9184
811160fc:	10c00617 	ldw	r3,24(r2)
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116100:	00a045b4 	movhi	r2,33046
81116104:	1088f804 	addi	r2,r2,9184
81116108:	10800003 	ldbu	r2,0(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111610c:	11003fcc 	andi	r4,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116110:	00a045b4 	movhi	r2,33046
81116114:	1088f804 	addi	r2,r2,9184
81116118:	10800043 	ldbu	r2,1(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111611c:	11403fcc 	andi	r5,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116120:	00a045b4 	movhi	r2,33046
81116124:	1088f804 	addi	r2,r2,9184
81116128:	10800083 	ldbu	r2,2(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111612c:	11803fcc 	andi	r6,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
81116130:	00a045b4 	movhi	r2,33046
81116134:	1088f804 	addi	r2,r2,9184
81116138:	108000c3 	ldbu	r2,3(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111613c:	11c03fcc 	andi	r7,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116140:	00a045b4 	movhi	r2,33046
81116144:	1088f804 	addi	r2,r2,9184
81116148:	10800203 	ldbu	r2,8(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111614c:	12003fcc 	andi	r8,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116150:	00a045b4 	movhi	r2,33046
81116154:	1088f804 	addi	r2,r2,9184
81116158:	10800243 	ldbu	r2,9(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111615c:	12403fcc 	andi	r9,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116160:	00a045b4 	movhi	r2,33046
81116164:	1088f804 	addi	r2,r2,9184
81116168:	10800283 	ldbu	r2,10(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111616c:	12803fcc 	andi	r10,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
81116170:	00a045b4 	movhi	r2,33046
81116174:	1088f804 	addi	r2,r2,9184
81116178:	108002c3 	ldbu	r2,11(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111617c:	12c03fcc 	andi	r11,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81116180:	00a045b4 	movhi	r2,33046
81116184:	1088f804 	addi	r2,r2,9184
81116188:	10800103 	ldbu	r2,4(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111618c:	13003fcc 	andi	r12,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
81116190:	00a045b4 	movhi	r2,33046
81116194:	1088f804 	addi	r2,r2,9184
81116198:	10800143 	ldbu	r2,5(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111619c:	13403fcc 	andi	r13,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
811161a0:	00a045b4 	movhi	r2,33046
811161a4:	1088f804 	addi	r2,r2,9184
811161a8:	10800183 	ldbu	r2,6(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811161ac:	13803fcc 	andi	r14,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
811161b0:	00a045b4 	movhi	r2,33046
811161b4:	1088f804 	addi	r2,r2,9184
811161b8:	108001c3 	ldbu	r2,7(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811161bc:	13c03fcc 	andi	r15,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811161c0:	00a045b4 	movhi	r2,33046
811161c4:	1088f804 	addi	r2,r2,9184
811161c8:	10800303 	ldbu	r2,12(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811161cc:	14003fcc 	andi	r16,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811161d0:	00a045b4 	movhi	r2,33046
811161d4:	1088f804 	addi	r2,r2,9184
811161d8:	10800343 	ldbu	r2,13(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811161dc:	14403fcc 	andi	r17,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811161e0:	00a045b4 	movhi	r2,33046
811161e4:	1088f804 	addi	r2,r2,9184
811161e8:	10800383 	ldbu	r2,14(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811161ec:	14803fcc 	andi	r18,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
811161f0:	00a045b4 	movhi	r2,33046
811161f4:	1088f804 	addi	r2,r2,9184
811161f8:	108003c3 	ldbu	r2,15(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
811161fc:	14c03fcc 	andi	r19,r2,255
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
81116200:	00a045b4 	movhi	r2,33046
81116204:	1088f804 	addi	r2,r2,9184
81116208:	1080058b 	ldhu	r2,22(r2)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;

    usiIdCMDLocal = usiGetIdCMD();

    sprintf(cBufferETH, ETH_SPRINTF, ETH_CMD, usiIdCMDLocal, xConfEth.bDHCP,
8111620c:	10bfffcc 	andi	r2,r2,65535
81116210:	e53fd984 	addi	r20,fp,-154
81116214:	d8801115 	stw	r2,68(sp)
81116218:	dcc01015 	stw	r19,64(sp)
8111621c:	dc800f15 	stw	r18,60(sp)
81116220:	dc400e15 	stw	r17,56(sp)
81116224:	dc000d15 	stw	r16,52(sp)
81116228:	dbc00c15 	stw	r15,48(sp)
8111622c:	db800b15 	stw	r14,44(sp)
81116230:	db400a15 	stw	r13,40(sp)
81116234:	db000915 	stw	r12,36(sp)
81116238:	dac00815 	stw	r11,32(sp)
8111623c:	da800715 	stw	r10,28(sp)
81116240:	da400615 	stw	r9,24(sp)
81116244:	da000515 	stw	r8,20(sp)
81116248:	d9c00415 	stw	r7,16(sp)
8111624c:	d9800315 	stw	r6,12(sp)
81116250:	d9400215 	stw	r5,8(sp)
81116254:	d9000115 	stw	r4,4(sp)
81116258:	d8c00015 	stw	r3,0(sp)
8111625c:	a80f883a 	mov	r7,r21
81116260:	018010c4 	movi	r6,67
81116264:	01604574 	movhi	r5,33045
81116268:	2968ef04 	addi	r5,r5,-23620
8111626c:	a009883a 	mov	r4,r20
81116270:	111e3a80 	call	8111e3a8 <sprintf>
                        xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3],
                        xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3],
                        xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3],
                        xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3],
                        xConfEth.siPortPUS);
    crc = ucCrc8wInit( cBufferETH , strlen(cBufferETH));
81116274:	e0bfd984 	addi	r2,fp,-154
81116278:	1009883a 	mov	r4,r2
8111627c:	111e5bc0 	call	8111e5bc <strlen>
81116280:	1007883a 	mov	r3,r2
81116284:	e0bfd984 	addi	r2,fp,-154
81116288:	180b883a 	mov	r5,r3
8111628c:	1009883a 	mov	r4,r2
81116290:	11178c00 	call	811178c0 <ucCrc8wInit>
81116294:	e0bfd705 	stb	r2,-164(fp)
    sprintf(cBufferETH, "%s|%hhu;", cBufferETH, crc );
81116298:	e13fd703 	ldbu	r4,-164(fp)
8111629c:	e0ffd984 	addi	r3,fp,-154
811162a0:	e0bfd984 	addi	r2,fp,-154
811162a4:	200f883a 	mov	r7,r4
811162a8:	180d883a 	mov	r6,r3
811162ac:	01604574 	movhi	r5,33045
811162b0:	29690704 	addi	r5,r5,-23524
811162b4:	1009883a 	mov	r4,r2
811162b8:	111e3a80 	call	8111e3a8 <sprintf>

	bSuccees = bSendUART128v2(cBufferETH, usiIdCMDLocal);
811162bc:	e0bfd90b 	ldhu	r2,-156(fp)
811162c0:	10ffffcc 	andi	r3,r2,65535
811162c4:	18e0001c 	xori	r3,r3,32768
811162c8:	18e00004 	addi	r3,r3,-32768
811162cc:	e0bfd984 	addi	r2,fp,-154
811162d0:	180b883a 	mov	r5,r3
811162d4:	1009883a 	mov	r4,r2
811162d8:	11157b00 	call	811157b0 <bSendUART128v2>
811162dc:	e0bfd815 	stw	r2,-160(fp)

	if ( bSuccees != TRUE ) {
811162e0:	e0bfd817 	ldw	r2,-160(fp)
811162e4:	10800060 	cmpeqi	r2,r2,1
811162e8:	1000011e 	bne	r2,zero,811162f0 <vSendEthConf+0x260>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendEthConfUART();
811162ec:	11184900 	call	81118490 <vCouldNotSendEthConfUART>
	}
}
811162f0:	0001883a 	nop
811162f4:	e6fffa04 	addi	sp,fp,-24
811162f8:	dfc00717 	ldw	ra,28(sp)
811162fc:	df000617 	ldw	fp,24(sp)
81116300:	dd400517 	ldw	r21,20(sp)
81116304:	dd000417 	ldw	r20,16(sp)
81116308:	dcc00317 	ldw	r19,12(sp)
8111630c:	dc800217 	ldw	r18,8(sp)
81116310:	dc400117 	ldw	r17,4(sp)
81116314:	dc000017 	ldw	r16,0(sp)
81116318:	dec00804 	addi	sp,sp,32
8111631c:	f800283a 	ret

81116320 <vSendTurnOff>:


void vSendTurnOff ( void ) {
81116320:	defff304 	addi	sp,sp,-52
81116324:	de00012e 	bgeu	sp,et,8111632c <vSendTurnOff+0xc>
81116328:	003b68fa 	trap	3
8111632c:	dfc00c15 	stw	ra,48(sp)
81116330:	df000b15 	stw	fp,44(sp)
81116334:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81116338:	e03ff78d 	sth	zero,-34(fp)
8111633c:	e03ff80d 	sth	zero,-32(fp)
81116340:	e03ff88d 	sth	zero,-30(fp)
81116344:	e03ff90d 	sth	zero,-28(fp)
81116348:	e03ff98d 	sth	zero,-26(fp)
8111634c:	e03ffa0d 	sth	zero,-24(fp)
81116350:	e03ffa8d 	sth	zero,-22(fp)
81116354:	e03ffb0d 	sth	zero,-20(fp)
81116358:	e03ffb8d 	sth	zero,-18(fp)
8111635c:	e03ffc0d 	sth	zero,-16(fp)
81116360:	e03ffc8d 	sth	zero,-14(fp)
81116364:	e03ffd0d 	sth	zero,-12(fp)
81116368:	e03ffd8d 	sth	zero,-10(fp)
8111636c:	e03ffe0d 	sth	zero,-8(fp)
81116370:	e03ffe8d 	sth	zero,-6(fp)
81116374:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81116378:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
8111637c:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116380:	11166500 	call	81116650 <usiGetIdCMD>
81116384:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, TURNOFF_SPRINTF, usiIdCMDLocal);
81116388:	e0fff70b 	ldhu	r3,-36(fp)
8111638c:	e0bff784 	addi	r2,fp,-34
81116390:	180d883a 	mov	r6,r3
81116394:	01604574 	movhi	r5,33045
81116398:	29690a04 	addi	r5,r5,-23512
8111639c:	1009883a 	mov	r4,r2
811163a0:	111e3a80 	call	8111e3a8 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811163a4:	e0bff784 	addi	r2,fp,-34
811163a8:	1009883a 	mov	r4,r2
811163ac:	111e5bc0 	call	8111e5bc <strlen>
811163b0:	1007883a 	mov	r3,r2
811163b4:	e0bff784 	addi	r2,fp,-34
811163b8:	180b883a 	mov	r5,r3
811163bc:	1009883a 	mov	r4,r2
811163c0:	11178c00 	call	811178c0 <ucCrc8wInit>
811163c4:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811163c8:	e13ff503 	ldbu	r4,-44(fp)
811163cc:	e0fff784 	addi	r3,fp,-34
811163d0:	e0bff784 	addi	r2,fp,-34
811163d4:	200f883a 	mov	r7,r4
811163d8:	180d883a 	mov	r6,r3
811163dc:	01604574 	movhi	r5,33045
811163e0:	29690704 	addi	r5,r5,-23524
811163e4:	1009883a 	mov	r4,r2
811163e8:	111e3a80 	call	8111e3a8 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
811163ec:	e0bff70b 	ldhu	r2,-36(fp)
811163f0:	10ffffcc 	andi	r3,r2,65535
811163f4:	18e0001c 	xori	r3,r3,32768
811163f8:	18e00004 	addi	r3,r3,-32768
811163fc:	e0bff784 	addi	r2,fp,-34
81116400:	180b883a 	mov	r5,r3
81116404:	1009883a 	mov	r4,r2
81116408:	1115d980 	call	81115d98 <bSendUART32v2>
8111640c:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81116410:	e0bff617 	ldw	r2,-40(fp)
81116414:	10800060 	cmpeqi	r2,r2,1
81116418:	1000011e 	bne	r2,zero,81116420 <vSendTurnOff+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
8111641c:	1118b380 	call	81118b38 <vCouldNotSendTurnOff>
	}
}
81116420:	0001883a 	nop
81116424:	e037883a 	mov	sp,fp
81116428:	dfc00117 	ldw	ra,4(sp)
8111642c:	df000017 	ldw	fp,0(sp)
81116430:	dec00204 	addi	sp,sp,8
81116434:	f800283a 	ret

81116438 <vSendReset>:

void vSendReset ( void ) {
81116438:	defff304 	addi	sp,sp,-52
8111643c:	de00012e 	bgeu	sp,et,81116444 <vSendReset+0xc>
81116440:	003b68fa 	trap	3
81116444:	dfc00c15 	stw	ra,48(sp)
81116448:	df000b15 	stw	fp,44(sp)
8111644c:	df000b04 	addi	fp,sp,44
    char cBufferTurnOff[32] = "";
81116450:	e03ff78d 	sth	zero,-34(fp)
81116454:	e03ff80d 	sth	zero,-32(fp)
81116458:	e03ff88d 	sth	zero,-30(fp)
8111645c:	e03ff90d 	sth	zero,-28(fp)
81116460:	e03ff98d 	sth	zero,-26(fp)
81116464:	e03ffa0d 	sth	zero,-24(fp)
81116468:	e03ffa8d 	sth	zero,-22(fp)
8111646c:	e03ffb0d 	sth	zero,-20(fp)
81116470:	e03ffb8d 	sth	zero,-18(fp)
81116474:	e03ffc0d 	sth	zero,-16(fp)
81116478:	e03ffc8d 	sth	zero,-14(fp)
8111647c:	e03ffd0d 	sth	zero,-12(fp)
81116480:	e03ffd8d 	sth	zero,-10(fp)
81116484:	e03ffe0d 	sth	zero,-8(fp)
81116488:	e03ffe8d 	sth	zero,-6(fp)
8111648c:	e03fff0d 	sth	zero,-4(fp)
    unsigned char crc = 0;
81116490:	e03ff505 	stb	zero,-44(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81116494:	e03ff615 	stw	zero,-40(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116498:	11166500 	call	81116650 <usiGetIdCMD>
8111649c:	e0bff70d 	sth	r2,-36(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferTurnOff, RESET_SPRINTF, usiIdCMDLocal);
811164a0:	e0fff70b 	ldhu	r3,-36(fp)
811164a4:	e0bff784 	addi	r2,fp,-34
811164a8:	180d883a 	mov	r6,r3
811164ac:	01604574 	movhi	r5,33045
811164b0:	29690c04 	addi	r5,r5,-23504
811164b4:	1009883a 	mov	r4,r2
811164b8:	111e3a80 	call	8111e3a8 <sprintf>
    crc = ucCrc8wInit( cBufferTurnOff , strlen(cBufferTurnOff));
811164bc:	e0bff784 	addi	r2,fp,-34
811164c0:	1009883a 	mov	r4,r2
811164c4:	111e5bc0 	call	8111e5bc <strlen>
811164c8:	1007883a 	mov	r3,r2
811164cc:	e0bff784 	addi	r2,fp,-34
811164d0:	180b883a 	mov	r5,r3
811164d4:	1009883a 	mov	r4,r2
811164d8:	11178c00 	call	811178c0 <ucCrc8wInit>
811164dc:	e0bff505 	stb	r2,-44(fp)
    sprintf(cBufferTurnOff, "%s|%hhu;", cBufferTurnOff, crc );
811164e0:	e13ff503 	ldbu	r4,-44(fp)
811164e4:	e0fff784 	addi	r3,fp,-34
811164e8:	e0bff784 	addi	r2,fp,-34
811164ec:	200f883a 	mov	r7,r4
811164f0:	180d883a 	mov	r6,r3
811164f4:	01604574 	movhi	r5,33045
811164f8:	29690704 	addi	r5,r5,-23524
811164fc:	1009883a 	mov	r4,r2
81116500:	111e3a80 	call	8111e3a8 <sprintf>

	bSuccees = bSendUART32v2(cBufferTurnOff, usiIdCMDLocal);
81116504:	e0bff70b 	ldhu	r2,-36(fp)
81116508:	10ffffcc 	andi	r3,r2,65535
8111650c:	18e0001c 	xori	r3,r3,32768
81116510:	18e00004 	addi	r3,r3,-32768
81116514:	e0bff784 	addi	r2,fp,-34
81116518:	180b883a 	mov	r5,r3
8111651c:	1009883a 	mov	r4,r2
81116520:	1115d980 	call	81115d98 <bSendUART32v2>
81116524:	e0bff615 	stw	r2,-40(fp)

	if ( bSuccees != TRUE ) {
81116528:	e0bff617 	ldw	r2,-40(fp)
8111652c:	10800060 	cmpeqi	r2,r2,1
81116530:	1000011e 	bne	r2,zero,81116538 <vSendReset+0x100>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTurnOff();
81116534:	1118b380 	call	81118b38 <vCouldNotSendTurnOff>
	}
}
81116538:	0001883a 	nop
8111653c:	e037883a 	mov	sp,fp
81116540:	dfc00117 	ldw	ra,4(sp)
81116544:	df000017 	ldw	fp,0(sp)
81116548:	dec00204 	addi	sp,sp,8
8111654c:	f800283a 	ret

81116550 <vSendLog>:

void vSendLog ( const char * cDataIn ) {
81116550:	deffda04 	addi	sp,sp,-152
81116554:	de00012e 	bgeu	sp,et,8111655c <vSendLog+0xc>
81116558:	003b68fa 	trap	3
8111655c:	dfc02515 	stw	ra,148(sp)
81116560:	df002415 	stw	fp,144(sp)
81116564:	df002404 	addi	fp,sp,144
81116568:	e13fff15 	stw	r4,-4(fp)
    char cBufferLog[128] = "";
8111656c:	e03fde8d 	sth	zero,-134(fp)
81116570:	e03fdf0d 	sth	zero,-132(fp)
81116574:	e0bfdf84 	addi	r2,fp,-130
81116578:	00c01f04 	movi	r3,124
8111657c:	180d883a 	mov	r6,r3
81116580:	000b883a 	mov	r5,zero
81116584:	1009883a 	mov	r4,r2
81116588:	111dc180 	call	8111dc18 <memset>
    unsigned char crc = 0;
8111658c:	e03fdc05 	stb	zero,-144(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81116590:	e03fdd15 	stw	zero,-140(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116594:	11166500 	call	81116650 <usiGetIdCMD>
81116598:	e0bfde0d 	sth	r2,-136(fp)

	/* Creating the packet with the CRC */
    sprintf(cBufferLog, LOG_SPRINTF, usiIdCMDLocal, cDataIn);
8111659c:	e0ffde0b 	ldhu	r3,-136(fp)
811165a0:	e0bfde84 	addi	r2,fp,-134
811165a4:	e1ffff17 	ldw	r7,-4(fp)
811165a8:	180d883a 	mov	r6,r3
811165ac:	01604574 	movhi	r5,33045
811165b0:	29690e04 	addi	r5,r5,-23496
811165b4:	1009883a 	mov	r4,r2
811165b8:	111e3a80 	call	8111e3a8 <sprintf>
    crc = ucCrc8wInit( cBufferLog , strlen(cBufferLog));
811165bc:	e0bfde84 	addi	r2,fp,-134
811165c0:	1009883a 	mov	r4,r2
811165c4:	111e5bc0 	call	8111e5bc <strlen>
811165c8:	1007883a 	mov	r3,r2
811165cc:	e0bfde84 	addi	r2,fp,-134
811165d0:	180b883a 	mov	r5,r3
811165d4:	1009883a 	mov	r4,r2
811165d8:	11178c00 	call	811178c0 <ucCrc8wInit>
811165dc:	e0bfdc05 	stb	r2,-144(fp)
    sprintf(cBufferLog, "%s|%hhu;", cBufferLog, crc );
811165e0:	e13fdc03 	ldbu	r4,-144(fp)
811165e4:	e0ffde84 	addi	r3,fp,-134
811165e8:	e0bfde84 	addi	r2,fp,-134
811165ec:	200f883a 	mov	r7,r4
811165f0:	180d883a 	mov	r6,r3
811165f4:	01604574 	movhi	r5,33045
811165f8:	29690704 	addi	r5,r5,-23524
811165fc:	1009883a 	mov	r4,r2
81116600:	111e3a80 	call	8111e3a8 <sprintf>

	bSuccees = bSendUART128v2(cBufferLog, usiIdCMDLocal);
81116604:	e0bfde0b 	ldhu	r2,-136(fp)
81116608:	10ffffcc 	andi	r3,r2,65535
8111660c:	18e0001c 	xori	r3,r3,32768
81116610:	18e00004 	addi	r3,r3,-32768
81116614:	e0bfde84 	addi	r2,fp,-134
81116618:	180b883a 	mov	r5,r3
8111661c:	1009883a 	mov	r4,r2
81116620:	11157b00 	call	811157b0 <bSendUART128v2>
81116624:	e0bfdd15 	stw	r2,-140(fp)

	if ( bSuccees != TRUE ) {
81116628:	e0bfdd17 	ldw	r2,-140(fp)
8111662c:	10800060 	cmpeqi	r2,r2,1
81116630:	1000011e 	bne	r2,zero,81116638 <vSendLog+0xe8>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendLog();
81116634:	1118c080 	call	81118c08 <vCouldNotSendLog>
	}
}
81116638:	0001883a 	nop
8111663c:	e037883a 	mov	sp,fp
81116640:	dfc00117 	ldw	ra,4(sp)
81116644:	df000017 	ldw	fp,0(sp)
81116648:	dec00204 	addi	sp,sp,8
8111664c:	f800283a 	ret

81116650 <usiGetIdCMD>:

unsigned short int usiGetIdCMD ( void ) {
81116650:	deffff04 	addi	sp,sp,-4
81116654:	de00012e 	bgeu	sp,et,8111665c <usiGetIdCMD+0xc>
81116658:	003b68fa 	trap	3
8111665c:	df000015 	stw	fp,0(sp)
81116660:	d839883a 	mov	fp,sp
    if ( usiIdCMD > 65534 )
81116664:	d0a0640b 	ldhu	r2,-32368(gp)
81116668:	10ffffcc 	andi	r3,r2,65535
8111666c:	00bfffd4 	movui	r2,65535
81116670:	1880031e 	bne	r3,r2,81116680 <usiGetIdCMD+0x30>
        usiIdCMD = 2;
81116674:	00800084 	movi	r2,2
81116678:	d0a0640d 	sth	r2,-32368(gp)
8111667c:	00000306 	br	8111668c <usiGetIdCMD+0x3c>
    else
        usiIdCMD++;
81116680:	d0a0640b 	ldhu	r2,-32368(gp)
81116684:	10800044 	addi	r2,r2,1
81116688:	d0a0640d 	sth	r2,-32368(gp)

    return usiIdCMD;
8111668c:	d0a0640b 	ldhu	r2,-32368(gp)
}
81116690:	e037883a 	mov	sp,fp
81116694:	df000017 	ldw	fp,0(sp)
81116698:	dec00104 	addi	sp,sp,4
8111669c:	f800283a 	ret

811166a0 <siPosStr>:

inline short int siPosStr( char *buffer, char cValue) {
811166a0:	defffb04 	addi	sp,sp,-20
811166a4:	de00012e 	bgeu	sp,et,811166ac <siPosStr+0xc>
811166a8:	003b68fa 	trap	3
811166ac:	dfc00415 	stw	ra,16(sp)
811166b0:	df000315 	stw	fp,12(sp)
811166b4:	df000304 	addi	fp,sp,12
811166b8:	e13ffe15 	stw	r4,-8(fp)
811166bc:	2805883a 	mov	r2,r5
811166c0:	e0bfff05 	stb	r2,-4(fp)
    char cTempChar[2] = "";
811166c4:	e03ffd0d 	sth	zero,-12(fp)
    cTempChar[0] = cValue; /* This step was add for performance. The command strcspn needs "" (const char *) */
811166c8:	e0bfff03 	ldbu	r2,-4(fp)
811166cc:	e0bffd05 	stb	r2,-12(fp)
    return strcspn(buffer, cTempChar);
811166d0:	e17ffd04 	addi	r5,fp,-12
811166d4:	e13ffe17 	ldw	r4,-8(fp)
811166d8:	111e5700 	call	8111e570 <strcspn>
}
811166dc:	e037883a 	mov	sp,fp
811166e0:	dfc00117 	ldw	ra,4(sp)
811166e4:	df000017 	ldw	fp,0(sp)
811166e8:	dec00204 	addi	sp,sp,8
811166ec:	f800283a 	ret

811166f0 <vTimeoutCheck>:


void vTimeoutCheck (void *p_arg)
{
811166f0:	defffc04 	addi	sp,sp,-16
811166f4:	de00012e 	bgeu	sp,et,811166fc <vTimeoutCheck+0xc>
811166f8:	003b68fa 	trap	3
811166fc:	dfc00315 	stw	ra,12(sp)
81116700:	df000215 	stw	fp,8(sp)
81116704:	df000204 	addi	fp,sp,8
81116708:	e13fff15 	stw	r4,-4(fp)
	INT8U error_code;

	/* Time to check the (re)transmission buffers, posting a semaphore to sync the task that will threat timeout logic (vTimeoutCheckerTask) */
	error_code = OSSemPost(xSemTimeoutChecker);
8111670c:	d0a06317 	ldw	r2,-32372(gp)
81116710:	1009883a 	mov	r4,r2
81116714:	113ae7c0 	call	8113ae7c <OSSemPost>
81116718:	e0bffe05 	stb	r2,-8(fp)
	if ( error_code != OS_ERR_NONE ) {
8111671c:	e0bffe03 	ldbu	r2,-8(fp)
81116720:	10000126 	beq	r2,zero,81116728 <vTimeoutCheck+0x38>
		vFailPostBlockingSemTimeoutTask();
81116724:	11188c80 	call	811188c8 <vFailPostBlockingSemTimeoutTask>
	}
}
81116728:	0001883a 	nop
8111672c:	e037883a 	mov	sp,fp
81116730:	dfc00117 	ldw	ra,4(sp)
81116734:	df000017 	ldw	fp,0(sp)
81116738:	dec00204 	addi	sp,sp,8
8111673c:	f800283a 	ret

81116740 <vSendPusTM64>:


/* Send through a medium buffer */
void vSendPusTM64 ( tTMPus xPcktPus ) {
81116740:	deffe304 	addi	sp,sp,-116
81116744:	de00012e 	bgeu	sp,et,8111674c <vSendPusTM64+0xc>
81116748:	003b68fa 	trap	3
8111674c:	dfc01815 	stw	ra,96(sp)
81116750:	df001715 	stw	fp,92(sp)
81116754:	df001704 	addi	fp,sp,92
81116758:	e1000215 	stw	r4,8(fp)
8111675c:	e1400315 	stw	r5,12(fp)
81116760:	e1800415 	stw	r6,16(fp)
81116764:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[64] = "";
81116768:	e03fef8d 	sth	zero,-66(fp)
8111676c:	e03ff00d 	sth	zero,-64(fp)
81116770:	e0bff084 	addi	r2,fp,-62
81116774:	00c00f04 	movi	r3,60
81116778:	180d883a 	mov	r6,r3
8111677c:	000b883a 	mov	r5,zero
81116780:	1009883a 	mov	r4,r2
81116784:	111dc180 	call	8111dc18 <memset>
    unsigned char crc = 0;
81116788:	e03fed45 	stb	zero,-75(fp)
	unsigned char ucIL = 0;
8111678c:	e03fed05 	stb	zero,-76(fp)
    unsigned short int  usiIdCMDLocal;
	bool bSuccees = FALSE;
81116790:	e03fee15 	stw	zero,-72(fp)

    usiIdCMDLocal = usiGetIdCMD();
81116794:	11166500 	call	81116650 <usiGetIdCMD>
81116798:	e0bfef0d 	sth	r2,-68(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
8111679c:	e1bfef0b 	ldhu	r6,-68(fp)
811167a0:	e080040b 	ldhu	r2,16(fp)
811167a4:	11ffffcc 	andi	r7,r2,65535
811167a8:	e080048b 	ldhu	r2,18(fp)
811167ac:	10bfffcc 	andi	r2,r2,65535
811167b0:	e0c0050b 	ldhu	r3,20(fp)
811167b4:	18ffffcc 	andi	r3,r3,65535
811167b8:	e100058b 	ldhu	r4,22(fp)
811167bc:	213fffcc 	andi	r4,r4,65535
811167c0:	e140060b 	ldhu	r5,24(fp)
811167c4:	297fffcc 	andi	r5,r5,65535
811167c8:	e23fef84 	addi	r8,fp,-66
811167cc:	d9400315 	stw	r5,12(sp)
811167d0:	d9000215 	stw	r4,8(sp)
811167d4:	d8c00115 	stw	r3,4(sp)
811167d8:	d8800015 	stw	r2,0(sp)
811167dc:	01604574 	movhi	r5,33045
811167e0:	29691104 	addi	r5,r5,-23484
811167e4:	4009883a 	mov	r4,r8
811167e8:	111e3a80 	call	8111e3a8 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811167ec:	e03fed05 	stb	zero,-76(fp)
811167f0:	00001206 	br	8111683c <vSendPusTM64+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
811167f4:	e0bfed03 	ldbu	r2,-76(fp)
811167f8:	10800284 	addi	r2,r2,10
811167fc:	1085883a 	add	r2,r2,r2
81116800:	e0c00204 	addi	r3,fp,8
81116804:	1885883a 	add	r2,r3,r2
81116808:	1080000b 	ldhu	r2,0(r2)
8111680c:	113fffcc 	andi	r4,r2,65535
81116810:	e0ffef84 	addi	r3,fp,-66
81116814:	e0bfef84 	addi	r2,fp,-66
81116818:	200f883a 	mov	r7,r4
8111681c:	180d883a 	mov	r6,r3
81116820:	01604574 	movhi	r5,33045
81116824:	29691804 	addi	r5,r5,-23456
81116828:	1009883a 	mov	r4,r2
8111682c:	111e3a80 	call	8111e3a8 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81116830:	e0bfed03 	ldbu	r2,-76(fp)
81116834:	10800044 	addi	r2,r2,1
81116838:	e0bfed05 	stb	r2,-76(fp)
8111683c:	e0800683 	ldbu	r2,26(fp)
81116840:	10803fcc 	andi	r2,r2,255
81116844:	e0ffed03 	ldbu	r3,-76(fp)
81116848:	18bfea36 	bltu	r3,r2,811167f4 <__reset+0xfb0f67f4>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
8111684c:	e0bfef84 	addi	r2,fp,-66
81116850:	1009883a 	mov	r4,r2
81116854:	111e5bc0 	call	8111e5bc <strlen>
81116858:	1007883a 	mov	r3,r2
8111685c:	e0bfef84 	addi	r2,fp,-66
81116860:	180b883a 	mov	r5,r3
81116864:	1009883a 	mov	r4,r2
81116868:	11178c00 	call	811178c0 <ucCrc8wInit>
8111686c:	e0bfed45 	stb	r2,-75(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81116870:	e13fed43 	ldbu	r4,-75(fp)
81116874:	e0ffef84 	addi	r3,fp,-66
81116878:	e0bfef84 	addi	r2,fp,-66
8111687c:	200f883a 	mov	r7,r4
81116880:	180d883a 	mov	r6,r3
81116884:	01604574 	movhi	r5,33045
81116888:	29690704 	addi	r5,r5,-23524
8111688c:	1009883a 	mov	r4,r2
81116890:	111e3a80 	call	8111e3a8 <sprintf>

	bSuccees = bSendUART64v2(cBufferPus, usiIdCMDLocal);
81116894:	e0bfef0b 	ldhu	r2,-68(fp)
81116898:	10ffffcc 	andi	r3,r2,65535
8111689c:	18e0001c 	xori	r3,r3,32768
811168a0:	18e00004 	addi	r3,r3,-32768
811168a4:	e0bfef84 	addi	r2,fp,-66
811168a8:	180b883a 	mov	r5,r3
811168ac:	1009883a 	mov	r4,r2
811168b0:	1115aa00 	call	81115aa0 <bSendUART64v2>
811168b4:	e0bfee15 	stw	r2,-72(fp)

	if ( bSuccees != TRUE ) {
811168b8:	e0bfee17 	ldw	r2,-72(fp)
811168bc:	10800060 	cmpeqi	r2,r2,1
811168c0:	1000031e 	bne	r2,zero,811168d0 <vSendPusTM64+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
811168c4:	e0bfef84 	addi	r2,fp,-66
811168c8:	1009883a 	mov	r4,r2
811168cc:	1118c700 	call	81118c70 <vCouldNotSendTMPusCommand>
	}
}
811168d0:	0001883a 	nop
811168d4:	e037883a 	mov	sp,fp
811168d8:	dfc00117 	ldw	ra,4(sp)
811168dc:	df000017 	ldw	fp,0(sp)
811168e0:	dec00604 	addi	sp,sp,24
811168e4:	f800283a 	ret

811168e8 <vSendPusTM128>:

/* Send through a big buffer */
void vSendPusTM128 ( tTMPus xPcktPus ) {
811168e8:	deffd304 	addi	sp,sp,-180
811168ec:	de00012e 	bgeu	sp,et,811168f4 <vSendPusTM128+0xc>
811168f0:	003b68fa 	trap	3
811168f4:	dfc02815 	stw	ra,160(sp)
811168f8:	df002715 	stw	fp,156(sp)
811168fc:	df002704 	addi	fp,sp,156
81116900:	e1000215 	stw	r4,8(fp)
81116904:	e1400315 	stw	r5,12(fp)
81116908:	e1800415 	stw	r6,16(fp)
8111690c:	e1c00515 	stw	r7,20(fp)
    char cBufferPus[128] = "";
81116910:	e03fdf8d 	sth	zero,-130(fp)
81116914:	e03fe00d 	sth	zero,-128(fp)
81116918:	e0bfe084 	addi	r2,fp,-126
8111691c:	00c01f04 	movi	r3,124
81116920:	180d883a 	mov	r6,r3
81116924:	000b883a 	mov	r5,zero
81116928:	1009883a 	mov	r4,r2
8111692c:	111dc180 	call	8111dc18 <memset>
    unsigned char crc = 0;
81116930:	e03fdd45 	stb	zero,-139(fp)
	unsigned char ucIL = 0;
81116934:	e03fdd05 	stb	zero,-140(fp)
    unsigned short int usiIdCMDLocal;
	bool bSuccees = FALSE;
81116938:	e03fde15 	stw	zero,-136(fp)

    usiIdCMDLocal = usiGetIdCMD();
8111693c:	11166500 	call	81116650 <usiGetIdCMD>
81116940:	e0bfdf0d 	sth	r2,-132(fp)

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
81116944:	e1bfdf0b 	ldhu	r6,-132(fp)
81116948:	e080040b 	ldhu	r2,16(fp)
8111694c:	11ffffcc 	andi	r7,r2,65535
81116950:	e080048b 	ldhu	r2,18(fp)
81116954:	10bfffcc 	andi	r2,r2,65535
81116958:	e0c0050b 	ldhu	r3,20(fp)
8111695c:	18ffffcc 	andi	r3,r3,65535
81116960:	e100058b 	ldhu	r4,22(fp)
81116964:	213fffcc 	andi	r4,r4,65535
81116968:	e140060b 	ldhu	r5,24(fp)
8111696c:	297fffcc 	andi	r5,r5,65535
81116970:	e23fdf84 	addi	r8,fp,-130
81116974:	d9400315 	stw	r5,12(sp)
81116978:	d9000215 	stw	r4,8(sp)
8111697c:	d8c00115 	stw	r3,4(sp)
81116980:	d8800015 	stw	r2,0(sp)
81116984:	01604574 	movhi	r5,33045
81116988:	29691104 	addi	r5,r5,-23484
8111698c:	4009883a 	mov	r4,r8
81116990:	111e3a80 	call	8111e3a8 <sprintf>
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
81116994:	e03fdd05 	stb	zero,-140(fp)
81116998:	00001206 	br	811169e4 <vSendPusTM128+0xfc>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
8111699c:	e0bfdd03 	ldbu	r2,-140(fp)
811169a0:	10800284 	addi	r2,r2,10
811169a4:	1085883a 	add	r2,r2,r2
811169a8:	e0c00204 	addi	r3,fp,8
811169ac:	1885883a 	add	r2,r3,r2
811169b0:	1080000b 	ldhu	r2,0(r2)
811169b4:	113fffcc 	andi	r4,r2,65535
811169b8:	e0ffdf84 	addi	r3,fp,-130
811169bc:	e0bfdf84 	addi	r2,fp,-130
811169c0:	200f883a 	mov	r7,r4
811169c4:	180d883a 	mov	r6,r3
811169c8:	01604574 	movhi	r5,33045
811169cc:	29691804 	addi	r5,r5,-23456
811169d0:	1009883a 	mov	r4,r2
811169d4:	111e3a80 	call	8111e3a8 <sprintf>
    usiIdCMDLocal = usiGetIdCMD();

	/* Start with the beginning of the PUS header values */
	sprintf(cBufferPus, PUS_TM_SPRINTF, usiIdCMDLocal, xPcktPus.usiPid, xPcktPus.usiCat, xPcktPus.usiType, xPcktPus.usiSubType, xPcktPus.usiPusId );
	/* Add how many parameters need to send in the command */
	for(ucIL = 0; ucIL < xPcktPus.ucNofValues; ucIL++)
811169d8:	e0bfdd03 	ldbu	r2,-140(fp)
811169dc:	10800044 	addi	r2,r2,1
811169e0:	e0bfdd05 	stb	r2,-140(fp)
811169e4:	e0800683 	ldbu	r2,26(fp)
811169e8:	10803fcc 	andi	r2,r2,255
811169ec:	e0ffdd03 	ldbu	r3,-140(fp)
811169f0:	18bfea36 	bltu	r3,r2,8111699c <__reset+0xfb0f699c>
	{
		sprintf(cBufferPus, PUS_ADDER_SPRINTF, cBufferPus, xPcktPus.usiValues[ucIL] );
	}
	/* Calculate the crc, append it and finish the string with ";" character */
    crc = ucCrc8wInit( cBufferPus , strlen(cBufferPus));
811169f4:	e0bfdf84 	addi	r2,fp,-130
811169f8:	1009883a 	mov	r4,r2
811169fc:	111e5bc0 	call	8111e5bc <strlen>
81116a00:	1007883a 	mov	r3,r2
81116a04:	e0bfdf84 	addi	r2,fp,-130
81116a08:	180b883a 	mov	r5,r3
81116a0c:	1009883a 	mov	r4,r2
81116a10:	11178c00 	call	811178c0 <ucCrc8wInit>
81116a14:	e0bfdd45 	stb	r2,-139(fp)
    sprintf(cBufferPus, "%s|%hhu;", cBufferPus, crc );
81116a18:	e13fdd43 	ldbu	r4,-139(fp)
81116a1c:	e0ffdf84 	addi	r3,fp,-130
81116a20:	e0bfdf84 	addi	r2,fp,-130
81116a24:	200f883a 	mov	r7,r4
81116a28:	180d883a 	mov	r6,r3
81116a2c:	01604574 	movhi	r5,33045
81116a30:	29690704 	addi	r5,r5,-23524
81116a34:	1009883a 	mov	r4,r2
81116a38:	111e3a80 	call	8111e3a8 <sprintf>

	bSuccees = bSendUART128v2(cBufferPus, usiIdCMDLocal);
81116a3c:	e0bfdf0b 	ldhu	r2,-132(fp)
81116a40:	10ffffcc 	andi	r3,r2,65535
81116a44:	18e0001c 	xori	r3,r3,32768
81116a48:	18e00004 	addi	r3,r3,-32768
81116a4c:	e0bfdf84 	addi	r2,fp,-130
81116a50:	180b883a 	mov	r5,r3
81116a54:	1009883a 	mov	r4,r2
81116a58:	11157b00 	call	811157b0 <bSendUART128v2>
81116a5c:	e0bfde15 	stw	r2,-136(fp)

	if ( bSuccees != TRUE ) {
81116a60:	e0bfde17 	ldw	r2,-136(fp)
81116a64:	10800060 	cmpeqi	r2,r2,1
81116a68:	1000031e 	bne	r2,zero,81116a78 <vSendPusTM128+0x190>
		/*	Message wasn't send or could not insert in the (re)transmission buffer
			this will not be returned, because the system should keep working, an error function shoudl be called
			in order to print a message in the console, and maybe further implementation in the future*/
			vCouldNotSendTMPusCommand( cBufferPus );
81116a6c:	e0bfdf84 	addi	r2,fp,-130
81116a70:	1009883a 	mov	r4,r2
81116a74:	1118c700 	call	81118c70 <vCouldNotSendTMPusCommand>
	}
}
81116a78:	0001883a 	nop
81116a7c:	e037883a 	mov	sp,fp
81116a80:	dfc00117 	ldw	ra,4(sp)
81116a84:	df000017 	ldw	fp,0(sp)
81116a88:	dec00604 	addi	sp,sp,24
81116a8c:	f800283a 	ret

81116a90 <vTMPusTestConnection>:
/* TM_SCAM_TEST_CONNECTION */
/* 
hp-pck-type		hp-pid		hp-pcat		hp-srv-type		hp-srv-subtype
0				112			0			17				2
*/
void vTMPusTestConnection( unsigned short int usiPusId ) {
81116a90:	deffd704 	addi	sp,sp,-164
81116a94:	de00012e 	bgeu	sp,et,81116a9c <vTMPusTestConnection+0xc>
81116a98:	003b68fa 	trap	3
81116a9c:	dfc02815 	stw	ra,160(sp)
81116aa0:	df002715 	stw	fp,156(sp)
81116aa4:	df002704 	addi	fp,sp,156
81116aa8:	2005883a 	mov	r2,r4
81116aac:	e0bfff0d 	sth	r2,-4(fp)
	tTMPus xTmPusL;

	/* For now is hardcoded after full release of the pus I will create defines */
	xTmPusL.usiPusId = usiPusId;
81116ab0:	e0bfff0b 	ldhu	r2,-4(fp)
81116ab4:	e0bfee0d 	sth	r2,-72(fp)
	xTmPusL.usiPid = 112;
81116ab8:	00801c04 	movi	r2,112
81116abc:	e0bfec0d 	sth	r2,-80(fp)
	xTmPusL.usiCat = 0;
81116ac0:	e03fec8d 	sth	zero,-78(fp)
	xTmPusL.usiType = 17;
81116ac4:	00800444 	movi	r2,17
81116ac8:	e0bfed0d 	sth	r2,-76(fp)
	xTmPusL.usiSubType = 2;
81116acc:	00800084 	movi	r2,2
81116ad0:	e0bfed8d 	sth	r2,-74(fp)

	vSendPusTM64( xTmPusL );
81116ad4:	d809883a 	mov	r4,sp
81116ad8:	e0bfee04 	addi	r2,fp,-72
81116adc:	00c01104 	movi	r3,68
81116ae0:	180d883a 	mov	r6,r3
81116ae4:	100b883a 	mov	r5,r2
81116ae8:	111dac80 	call	8111dac8 <memcpy>
81116aec:	e13fea17 	ldw	r4,-88(fp)
81116af0:	e17feb17 	ldw	r5,-84(fp)
81116af4:	e1bfec17 	ldw	r6,-80(fp)
81116af8:	e1ffed17 	ldw	r7,-76(fp)
81116afc:	11167400 	call	81116740 <vSendPusTM64>
}
81116b00:	0001883a 	nop
81116b04:	e037883a 	mov	sp,fp
81116b08:	dfc00117 	ldw	ra,4(sp)
81116b0c:	df000017 	ldw	fp,0(sp)
81116b10:	dec00204 	addi	sp,sp,8
81116b14:	f800283a 	ret

81116b18 <vLoadDefaultETHConf>:

/*Configuration related to the eth connection*/
TConfEth xConfEth;


bool vLoadDefaultETHConf( void ){
81116b18:	defff504 	addi	sp,sp,-44
81116b1c:	de00012e 	bgeu	sp,et,81116b24 <vLoadDefaultETHConf+0xc>
81116b20:	003b68fa 	trap	3
81116b24:	dfc00a15 	stw	ra,40(sp)
81116b28:	df000915 	stw	fp,36(sp)
81116b2c:	dc000815 	stw	r16,32(sp)
81116b30:	df000904 	addi	fp,sp,36
	short int siFile, sidhcpTemp;
	bool bSuccess = FALSE;
81116b34:	e03ff715 	stw	zero,-36(fp)
	bool bEOF = FALSE;
81116b38:	e03ff815 	stw	zero,-32(fp)
	bool close = FALSE;
81116b3c:	e03ffb15 	stw	zero,-20(fp)
	unsigned char ucParser;
	char c, *p_inteiro;
	char inteiro[8];


	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){
81116b40:	d0a07217 	ldw	r2,-32312(gp)
81116b44:	10800058 	cmpnei	r2,r2,1
81116b48:	1002041e 	bne	r2,zero,8111735c <vLoadDefaultETHConf+0x844>
81116b4c:	111aa040 	call	8111aa04 <bSDcardIsPresent>
81116b50:	10020226 	beq	r2,zero,8111735c <vLoadDefaultETHConf+0x844>
81116b54:	111aa340 	call	8111aa34 <bSDcardFAT16Check>
81116b58:	10020026 	beq	r2,zero,8111735c <vLoadDefaultETHConf+0x844>

		siFile = siOpenFile( ETH_FILE_NAME );
81116b5c:	01204574 	movhi	r4,33045
81116b60:	21291a04 	addi	r4,r4,-23448
81116b64:	111ab5c0 	call	8111ab5c <siOpenFile>
81116b68:	e0bffc0d 	sth	r2,-16(fp)

		if ( siFile >= 0 ){
81116b6c:	e0bffc0f 	ldh	r2,-16(fp)
81116b70:	1001f216 	blt	r2,zero,8111733c <vLoadDefaultETHConf+0x824>

			memset( &(inteiro) , 10 , sizeof( inteiro ) );
81116b74:	e0bffd04 	addi	r2,fp,-12
81116b78:	01800204 	movi	r6,8
81116b7c:	01400284 	movi	r5,10
81116b80:	1009883a 	mov	r4,r2
81116b84:	111dc180 	call	8111dc18 <memset>
			p_inteiro = inteiro;
81116b88:	e0bffd04 	addi	r2,fp,-12
81116b8c:	e0bffa15 	stw	r2,-24(fp)

			do {
				c = cGetNextChar(siFile);
81116b90:	e0bffc0f 	ldh	r2,-16(fp)
81116b94:	1009883a 	mov	r4,r2
81116b98:	111abd80 	call	8111abd8 <cGetNextChar>
81116b9c:	e0bff945 	stb	r2,-27(fp)
				//printf("%c \n", c);
				switch (c) {
81116ba0:	e0bff947 	ldb	r2,-27(fp)
81116ba4:	10800084 	addi	r2,r2,2
81116ba8:	10c015a8 	cmpgeui	r3,r2,86
81116bac:	1801d71e 	bne	r3,zero,8111730c <vLoadDefaultETHConf+0x7f4>
81116bb0:	100690ba 	slli	r3,r2,2
81116bb4:	00a04474 	movhi	r2,33041
81116bb8:	109af204 	addi	r2,r2,27592
81116bbc:	1885883a 	add	r2,r3,r2
81116bc0:	10800017 	ldw	r2,0(r2)
81116bc4:	1000683a 	jmp	r2
81116bc8:	81116d60 	cmpeqi	r4,r16,17845
81116bcc:	81116d54 	ori	r4,r16,17845
81116bd0:	8111730c 	andi	r4,r16,17868
81116bd4:	8111730c 	andi	r4,r16,17868
81116bd8:	8111730c 	andi	r4,r16,17868
81116bdc:	8111730c 	andi	r4,r16,17868
81116be0:	8111730c 	andi	r4,r16,17868
81116be4:	8111730c 	andi	r4,r16,17868
81116be8:	8111730c 	andi	r4,r16,17868
81116bec:	8111730c 	andi	r4,r16,17868
81116bf0:	8111730c 	andi	r4,r16,17868
81116bf4:	8111730c 	andi	r4,r16,17868
81116bf8:	8111732c 	andhi	r4,r16,17868
81116bfc:	8111730c 	andi	r4,r16,17868
81116c00:	8111730c 	andi	r4,r16,17868
81116c04:	8111732c 	andhi	r4,r16,17868
81116c08:	8111730c 	andi	r4,r16,17868
81116c0c:	8111730c 	andi	r4,r16,17868
81116c10:	8111730c 	andi	r4,r16,17868
81116c14:	8111730c 	andi	r4,r16,17868
81116c18:	8111730c 	andi	r4,r16,17868
81116c1c:	8111730c 	andi	r4,r16,17868
81116c20:	8111730c 	andi	r4,r16,17868
81116c24:	8111730c 	andi	r4,r16,17868
81116c28:	8111730c 	andi	r4,r16,17868
81116c2c:	8111730c 	andi	r4,r16,17868
81116c30:	8111730c 	andi	r4,r16,17868
81116c34:	8111730c 	andi	r4,r16,17868
81116c38:	8111730c 	andi	r4,r16,17868
81116c3c:	8111730c 	andi	r4,r16,17868
81116c40:	8111730c 	andi	r4,r16,17868
81116c44:	8111730c 	andi	r4,r16,17868
81116c48:	8111730c 	andi	r4,r16,17868
81116c4c:	8111730c 	andi	r4,r16,17868
81116c50:	8111732c 	andhi	r4,r16,17868
81116c54:	8111730c 	andi	r4,r16,17868
81116c58:	8111730c 	andi	r4,r16,17868
81116c5c:	8111730c 	andi	r4,r16,17868
81116c60:	8111730c 	andi	r4,r16,17868
81116c64:	8111730c 	andi	r4,r16,17868
81116c68:	8111730c 	andi	r4,r16,17868
81116c6c:	81116d20 	cmpeqi	r4,r16,17844
81116c70:	8111730c 	andi	r4,r16,17868
81116c74:	8111730c 	andi	r4,r16,17868
81116c78:	8111730c 	andi	r4,r16,17868
81116c7c:	8111730c 	andi	r4,r16,17868
81116c80:	8111730c 	andi	r4,r16,17868
81116c84:	8111730c 	andi	r4,r16,17868
81116c88:	8111730c 	andi	r4,r16,17868
81116c8c:	8111730c 	andi	r4,r16,17868
81116c90:	8111730c 	andi	r4,r16,17868
81116c94:	8111730c 	andi	r4,r16,17868
81116c98:	8111730c 	andi	r4,r16,17868
81116c9c:	8111730c 	andi	r4,r16,17868
81116ca0:	8111730c 	andi	r4,r16,17868
81116ca4:	8111730c 	andi	r4,r16,17868
81116ca8:	8111730c 	andi	r4,r16,17868
81116cac:	8111730c 	andi	r4,r16,17868
81116cb0:	8111730c 	andi	r4,r16,17868
81116cb4:	8111730c 	andi	r4,r16,17868
81116cb8:	8111730c 	andi	r4,r16,17868
81116cbc:	8111730c 	andi	r4,r16,17868
81116cc0:	811172c4 	addi	r4,r16,17867
81116cc4:	8111730c 	andi	r4,r16,17868
81116cc8:	8111730c 	andi	r4,r16,17868
81116ccc:	8111730c 	andi	r4,r16,17868
81116cd0:	8111730c 	andi	r4,r16,17868
81116cd4:	8111730c 	andi	r4,r16,17868
81116cd8:	8111730c 	andi	r4,r16,17868
81116cdc:	8111730c 	andi	r4,r16,17868
81116ce0:	811170c4 	addi	r4,r16,17859
81116ce4:	8111730c 	andi	r4,r16,17868
81116ce8:	8111730c 	andi	r4,r16,17868
81116cec:	81116f24 	muli	r4,r16,17852
81116cf0:	8111721c 	xori	r4,r16,17864
81116cf4:	81116e58 	cmpnei	r4,r16,17849
81116cf8:	8111730c 	andi	r4,r16,17868
81116cfc:	8111730c 	andi	r4,r16,17868
81116d00:	8111730c 	andi	r4,r16,17868
81116d04:	81116d88 	cmpgei	r4,r16,17846
81116d08:	8111730c 	andi	r4,r16,17868
81116d0c:	8111730c 	andi	r4,r16,17868
81116d10:	81117194 	ori	r4,r16,17862
81116d14:	8111730c 	andi	r4,r16,17868
81116d18:	8111730c 	andi	r4,r16,17868
81116d1c:	81116ff4 	orhi	r4,r16,17855
					case 39:// single quote '
						c = cGetNextChar(siFile);
81116d20:	e0bffc0f 	ldh	r2,-16(fp)
81116d24:	1009883a 	mov	r4,r2
81116d28:	111abd80 	call	8111abd8 <cGetNextChar>
81116d2c:	e0bff945 	stb	r2,-27(fp)
						while ( c != 39 ){
81116d30:	00000406 	br	81116d44 <vLoadDefaultETHConf+0x22c>
							c = cGetNextChar(siFile);
81116d34:	e0bffc0f 	ldh	r2,-16(fp)
81116d38:	1009883a 	mov	r4,r2
81116d3c:	111abd80 	call	8111abd8 <cGetNextChar>
81116d40:	e0bff945 	stb	r2,-27(fp)
				c = cGetNextChar(siFile);
				//printf("%c \n", c);
				switch (c) {
					case 39:// single quote '
						c = cGetNextChar(siFile);
						while ( c != 39 ){
81116d44:	e0bff947 	ldb	r2,-27(fp)
81116d48:	108009d8 	cmpnei	r2,r2,39
81116d4c:	103ff91e 	bne	r2,zero,81116d34 <__reset+0xfb0f6d34>
							c = cGetNextChar(siFile);
						}
						break;
81116d50:	00017706 	br	81117330 <vLoadDefaultETHConf+0x818>
					case -1: 	//EOF
						bEOF = TRUE;
81116d54:	00800044 	movi	r2,1
81116d58:	e0bff815 	stw	r2,-32(fp)
						break;
81116d5c:	00017406 	br	81117330 <vLoadDefaultETHConf+0x818>
					case -2: 	//EOF
						#ifdef DEBUG_ON
							debug(fp,"SDCard: Problem with SDCard");
81116d60:	d0a05e17 	ldw	r2,-32392(gp)
81116d64:	100f883a 	mov	r7,r2
81116d68:	018006c4 	movi	r6,27
81116d6c:	01400044 	movi	r5,1
81116d70:	01204574 	movhi	r4,33045
81116d74:	21291c04 	addi	r4,r4,-23440
81116d78:	111d0b40 	call	8111d0b4 <fwrite>
						#endif
						bEOF = TRUE;
81116d7c:	00800044 	movi	r2,1
81116d80:	e0bff815 	stw	r2,-32(fp)
						break;
81116d84:	00016a06 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
					case 'M':

						ucParser = 0;
81116d88:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116d8c:	e0bffc0f 	ldh	r2,-16(fp)
81116d90:	1009883a 	mov	r4,r2
81116d94:	111abd80 	call	8111abd8 <cGetNextChar>
81116d98:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116d9c:	d0e00317 	ldw	r3,-32756(gp)
81116da0:	e0bff947 	ldb	r2,-27(fp)
81116da4:	10800044 	addi	r2,r2,1
81116da8:	1885883a 	add	r2,r3,r2
81116dac:	10800003 	ldbu	r2,0(r2)
81116db0:	10803fcc 	andi	r2,r2,255
81116db4:	1080010c 	andi	r2,r2,4
81116db8:	10000626 	beq	r2,zero,81116dd4 <vLoadDefaultETHConf+0x2bc>
									(*p_inteiro) = c;
81116dbc:	e0bffa17 	ldw	r2,-24(fp)
81116dc0:	e0fff943 	ldbu	r3,-27(fp)
81116dc4:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116dc8:	e0bffa17 	ldw	r2,-24(fp)
81116dcc:	10800044 	addi	r2,r2,1
81116dd0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=58) && (c !=59) ); //ASCII: 58 = ':' 59 = ';'
81116dd4:	e0bff947 	ldb	r2,-27(fp)
81116dd8:	10800ea0 	cmpeqi	r2,r2,58
81116ddc:	1000031e 	bne	r2,zero,81116dec <vLoadDefaultETHConf+0x2d4>
81116de0:	e0bff947 	ldb	r2,-27(fp)
81116de4:	10800ed8 	cmpnei	r2,r2,59
81116de8:	103fe81e 	bne	r2,zero,81116d8c <__reset+0xfb0f6d8c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116dec:	e0bffa17 	ldw	r2,-24(fp)
81116df0:	00c00284 	movi	r3,10
81116df4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucMAC[min_sim(ucParser,5)] = atoi( inteiro );
81116df8:	e0bff903 	ldbu	r2,-28(fp)
81116dfc:	10800168 	cmpgeui	r2,r2,5
81116e00:	1000021e 	bne	r2,zero,81116e0c <vLoadDefaultETHConf+0x2f4>
81116e04:	e43ff903 	ldbu	r16,-28(fp)
81116e08:	00000106 	br	81116e10 <vLoadDefaultETHConf+0x2f8>
81116e0c:	04000144 	movi	r16,5
81116e10:	e0bffd04 	addi	r2,fp,-12
81116e14:	1009883a 	mov	r4,r2
81116e18:	111c8bc0 	call	8111c8bc <atoi>
81116e1c:	1007883a 	mov	r3,r2
81116e20:	00a045b4 	movhi	r2,33046
81116e24:	1088f804 	addi	r2,r2,9184
81116e28:	1405883a 	add	r2,r2,r16
81116e2c:	10800404 	addi	r2,r2,16
81116e30:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81116e34:	e0bffd04 	addi	r2,fp,-12
81116e38:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116e3c:	e0bff903 	ldbu	r2,-28(fp)
81116e40:	10800044 	addi	r2,r2,1
81116e44:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116e48:	e0bff947 	ldb	r2,-27(fp)
81116e4c:	10800ed8 	cmpnei	r2,r2,59
81116e50:	103fce1e 	bne	r2,zero,81116d8c <__reset+0xfb0f6d8c>

						break;
81116e54:	00013606 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 'I':

						ucParser = 0;
81116e58:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116e5c:	e0bffc0f 	ldh	r2,-16(fp)
81116e60:	1009883a 	mov	r4,r2
81116e64:	111abd80 	call	8111abd8 <cGetNextChar>
81116e68:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116e6c:	d0e00317 	ldw	r3,-32756(gp)
81116e70:	e0bff947 	ldb	r2,-27(fp)
81116e74:	10800044 	addi	r2,r2,1
81116e78:	1885883a 	add	r2,r3,r2
81116e7c:	10800003 	ldbu	r2,0(r2)
81116e80:	10803fcc 	andi	r2,r2,255
81116e84:	1080010c 	andi	r2,r2,4
81116e88:	10000626 	beq	r2,zero,81116ea4 <vLoadDefaultETHConf+0x38c>
									(*p_inteiro) = c;
81116e8c:	e0bffa17 	ldw	r2,-24(fp)
81116e90:	e0fff943 	ldbu	r3,-27(fp)
81116e94:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116e98:	e0bffa17 	ldw	r2,-24(fp)
81116e9c:	10800044 	addi	r2,r2,1
81116ea0:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81116ea4:	e0bff947 	ldb	r2,-27(fp)
81116ea8:	10800ba0 	cmpeqi	r2,r2,46
81116eac:	1000031e 	bne	r2,zero,81116ebc <vLoadDefaultETHConf+0x3a4>
81116eb0:	e0bff947 	ldb	r2,-27(fp)
81116eb4:	10800ed8 	cmpnei	r2,r2,59
81116eb8:	103fe81e 	bne	r2,zero,81116e5c <__reset+0xfb0f6e5c>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116ebc:	e0bffa17 	ldw	r2,-24(fp)
81116ec0:	00c00284 	movi	r3,10
81116ec4:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucIP[min_sim(ucParser,3)] = atoi( inteiro );
81116ec8:	e0bff903 	ldbu	r2,-28(fp)
81116ecc:	108000e8 	cmpgeui	r2,r2,3
81116ed0:	1000021e 	bne	r2,zero,81116edc <vLoadDefaultETHConf+0x3c4>
81116ed4:	e43ff903 	ldbu	r16,-28(fp)
81116ed8:	00000106 	br	81116ee0 <vLoadDefaultETHConf+0x3c8>
81116edc:	040000c4 	movi	r16,3
81116ee0:	e0bffd04 	addi	r2,fp,-12
81116ee4:	1009883a 	mov	r4,r2
81116ee8:	111c8bc0 	call	8111c8bc <atoi>
81116eec:	1007883a 	mov	r3,r2
81116ef0:	00a045b4 	movhi	r2,33046
81116ef4:	1088f804 	addi	r2,r2,9184
81116ef8:	1405883a 	add	r2,r2,r16
81116efc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81116f00:	e0bffd04 	addi	r2,fp,-12
81116f04:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116f08:	e0bff903 	ldbu	r2,-28(fp)
81116f0c:	10800044 	addi	r2,r2,1
81116f10:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116f14:	e0bff947 	ldb	r2,-27(fp)
81116f18:	10800ed8 	cmpnei	r2,r2,59
81116f1c:	103fcf1e 	bne	r2,zero,81116e5c <__reset+0xfb0f6e5c>

						break;
81116f20:	00010306 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 'G':

						ucParser = 0;
81116f24:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116f28:	e0bffc0f 	ldh	r2,-16(fp)
81116f2c:	1009883a 	mov	r4,r2
81116f30:	111abd80 	call	8111abd8 <cGetNextChar>
81116f34:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81116f38:	d0e00317 	ldw	r3,-32756(gp)
81116f3c:	e0bff947 	ldb	r2,-27(fp)
81116f40:	10800044 	addi	r2,r2,1
81116f44:	1885883a 	add	r2,r3,r2
81116f48:	10800003 	ldbu	r2,0(r2)
81116f4c:	10803fcc 	andi	r2,r2,255
81116f50:	1080010c 	andi	r2,r2,4
81116f54:	10000626 	beq	r2,zero,81116f70 <vLoadDefaultETHConf+0x458>
									(*p_inteiro) = c;
81116f58:	e0bffa17 	ldw	r2,-24(fp)
81116f5c:	e0fff943 	ldbu	r3,-27(fp)
81116f60:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81116f64:	e0bffa17 	ldw	r2,-24(fp)
81116f68:	10800044 	addi	r2,r2,1
81116f6c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81116f70:	e0bff947 	ldb	r2,-27(fp)
81116f74:	10800ba0 	cmpeqi	r2,r2,46
81116f78:	1000031e 	bne	r2,zero,81116f88 <vLoadDefaultETHConf+0x470>
81116f7c:	e0bff947 	ldb	r2,-27(fp)
81116f80:	10800ed8 	cmpnei	r2,r2,59
81116f84:	103fe81e 	bne	r2,zero,81116f28 <__reset+0xfb0f6f28>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81116f88:	e0bffa17 	ldw	r2,-24(fp)
81116f8c:	00c00284 	movi	r3,10
81116f90:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucGTW[min_sim(ucParser,3)] = atoi( inteiro );
81116f94:	e0bff903 	ldbu	r2,-28(fp)
81116f98:	108000e8 	cmpgeui	r2,r2,3
81116f9c:	1000021e 	bne	r2,zero,81116fa8 <vLoadDefaultETHConf+0x490>
81116fa0:	e43ff903 	ldbu	r16,-28(fp)
81116fa4:	00000106 	br	81116fac <vLoadDefaultETHConf+0x494>
81116fa8:	040000c4 	movi	r16,3
81116fac:	e0bffd04 	addi	r2,fp,-12
81116fb0:	1009883a 	mov	r4,r2
81116fb4:	111c8bc0 	call	8111c8bc <atoi>
81116fb8:	1007883a 	mov	r3,r2
81116fbc:	00a045b4 	movhi	r2,33046
81116fc0:	1088f804 	addi	r2,r2,9184
81116fc4:	1405883a 	add	r2,r2,r16
81116fc8:	10800104 	addi	r2,r2,4
81116fcc:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81116fd0:	e0bffd04 	addi	r2,fp,-12
81116fd4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81116fd8:	e0bff903 	ldbu	r2,-28(fp)
81116fdc:	10800044 	addi	r2,r2,1
81116fe0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81116fe4:	e0bff947 	ldb	r2,-27(fp)
81116fe8:	10800ed8 	cmpnei	r2,r2,59
81116fec:	103fce1e 	bne	r2,zero,81116f28 <__reset+0xfb0f6f28>

						break;
81116ff0:	0000cf06 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 'S':

						ucParser = 0;
81116ff4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
81116ff8:	e0bffc0f 	ldh	r2,-16(fp)
81116ffc:	1009883a 	mov	r4,r2
81117000:	111abd80 	call	8111abd8 <cGetNextChar>
81117004:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
81117008:	d0e00317 	ldw	r3,-32756(gp)
8111700c:	e0bff947 	ldb	r2,-27(fp)
81117010:	10800044 	addi	r2,r2,1
81117014:	1885883a 	add	r2,r3,r2
81117018:	10800003 	ldbu	r2,0(r2)
8111701c:	10803fcc 	andi	r2,r2,255
81117020:	1080010c 	andi	r2,r2,4
81117024:	10000626 	beq	r2,zero,81117040 <vLoadDefaultETHConf+0x528>
									(*p_inteiro) = c;
81117028:	e0bffa17 	ldw	r2,-24(fp)
8111702c:	e0fff943 	ldbu	r3,-27(fp)
81117030:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81117034:	e0bffa17 	ldw	r2,-24(fp)
81117038:	10800044 	addi	r2,r2,1
8111703c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81117040:	e0bff947 	ldb	r2,-27(fp)
81117044:	10800ba0 	cmpeqi	r2,r2,46
81117048:	1000031e 	bne	r2,zero,81117058 <vLoadDefaultETHConf+0x540>
8111704c:	e0bff947 	ldb	r2,-27(fp)
81117050:	10800ed8 	cmpnei	r2,r2,59
81117054:	103fe81e 	bne	r2,zero,81116ff8 <__reset+0xfb0f6ff8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117058:	e0bffa17 	ldw	r2,-24(fp)
8111705c:	00c00284 	movi	r3,10
81117060:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucSubNet[min_sim(ucParser,3)] = atoi( inteiro );
81117064:	e0bff903 	ldbu	r2,-28(fp)
81117068:	108000e8 	cmpgeui	r2,r2,3
8111706c:	1000021e 	bne	r2,zero,81117078 <vLoadDefaultETHConf+0x560>
81117070:	e43ff903 	ldbu	r16,-28(fp)
81117074:	00000106 	br	8111707c <vLoadDefaultETHConf+0x564>
81117078:	040000c4 	movi	r16,3
8111707c:	e0bffd04 	addi	r2,fp,-12
81117080:	1009883a 	mov	r4,r2
81117084:	111c8bc0 	call	8111c8bc <atoi>
81117088:	1007883a 	mov	r3,r2
8111708c:	00a045b4 	movhi	r2,33046
81117090:	1088f804 	addi	r2,r2,9184
81117094:	1405883a 	add	r2,r2,r16
81117098:	10800204 	addi	r2,r2,8
8111709c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
811170a0:	e0bffd04 	addi	r2,fp,-12
811170a4:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
811170a8:	e0bff903 	ldbu	r2,-28(fp)
811170ac:	10800044 	addi	r2,r2,1
811170b0:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
811170b4:	e0bff947 	ldb	r2,-27(fp)
811170b8:	10800ed8 	cmpnei	r2,r2,59
811170bc:	103fce1e 	bne	r2,zero,81116ff8 <__reset+0xfb0f6ff8>

						break;
811170c0:	00009b06 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 'D':

						ucParser = 0;
811170c4:	e03ff905 	stb	zero,-28(fp)
						do {
							do {
								c = cGetNextChar(siFile);
811170c8:	e0bffc0f 	ldh	r2,-16(fp)
811170cc:	1009883a 	mov	r4,r2
811170d0:	111abd80 	call	8111abd8 <cGetNextChar>
811170d4:	e0bff945 	stb	r2,-27(fp)
								if ( isdigit( c ) ) {
811170d8:	d0e00317 	ldw	r3,-32756(gp)
811170dc:	e0bff947 	ldb	r2,-27(fp)
811170e0:	10800044 	addi	r2,r2,1
811170e4:	1885883a 	add	r2,r3,r2
811170e8:	10800003 	ldbu	r2,0(r2)
811170ec:	10803fcc 	andi	r2,r2,255
811170f0:	1080010c 	andi	r2,r2,4
811170f4:	10000626 	beq	r2,zero,81117110 <vLoadDefaultETHConf+0x5f8>
									(*p_inteiro) = c;
811170f8:	e0bffa17 	ldw	r2,-24(fp)
811170fc:	e0fff943 	ldbu	r3,-27(fp)
81117100:	10c00005 	stb	r3,0(r2)
									p_inteiro++;
81117104:	e0bffa17 	ldw	r2,-24(fp)
81117108:	10800044 	addi	r2,r2,1
8111710c:	e0bffa15 	stw	r2,-24(fp)
								}
							} while ( (c !=46) && (c !=59) ); //ASCII: 46 = '.' 59 = ';'
81117110:	e0bff947 	ldb	r2,-27(fp)
81117114:	10800ba0 	cmpeqi	r2,r2,46
81117118:	1000031e 	bne	r2,zero,81117128 <vLoadDefaultETHConf+0x610>
8111711c:	e0bff947 	ldb	r2,-27(fp)
81117120:	10800ed8 	cmpnei	r2,r2,59
81117124:	103fe81e 	bne	r2,zero,811170c8 <__reset+0xfb0f70c8>
							(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117128:	e0bffa17 	ldw	r2,-24(fp)
8111712c:	00c00284 	movi	r3,10
81117130:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							xConfEth.ucDNS[min_sim(ucParser,3)] = atoi( inteiro );
81117134:	e0bff903 	ldbu	r2,-28(fp)
81117138:	108000e8 	cmpgeui	r2,r2,3
8111713c:	1000021e 	bne	r2,zero,81117148 <vLoadDefaultETHConf+0x630>
81117140:	e43ff903 	ldbu	r16,-28(fp)
81117144:	00000106 	br	8111714c <vLoadDefaultETHConf+0x634>
81117148:	040000c4 	movi	r16,3
8111714c:	e0bffd04 	addi	r2,fp,-12
81117150:	1009883a 	mov	r4,r2
81117154:	111c8bc0 	call	8111c8bc <atoi>
81117158:	1007883a 	mov	r3,r2
8111715c:	00a045b4 	movhi	r2,33046
81117160:	1088f804 	addi	r2,r2,9184
81117164:	1405883a 	add	r2,r2,r16
81117168:	10800304 	addi	r2,r2,12
8111716c:	10c00005 	stb	r3,0(r2)
							/*Tiago: Proteger com mutex*/
							p_inteiro = inteiro;
81117170:	e0bffd04 	addi	r2,fp,-12
81117174:	e0bffa15 	stw	r2,-24(fp)
							ucParser++;
81117178:	e0bff903 	ldbu	r2,-28(fp)
8111717c:	10800044 	addi	r2,r2,1
81117180:	e0bff905 	stb	r2,-28(fp)
						} while ( (c !=59) );
81117184:	e0bff947 	ldb	r2,-27(fp)
81117188:	10800ed8 	cmpnei	r2,r2,59
8111718c:	103fce1e 	bne	r2,zero,811170c8 <__reset+0xfb0f70c8>

						break;						
81117190:	00006706 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 'P':

						do {
							c = cGetNextChar(siFile);
81117194:	e0bffc0f 	ldh	r2,-16(fp)
81117198:	1009883a 	mov	r4,r2
8111719c:	111abd80 	call	8111abd8 <cGetNextChar>
811171a0:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
811171a4:	d0e00317 	ldw	r3,-32756(gp)
811171a8:	e0bff947 	ldb	r2,-27(fp)
811171ac:	10800044 	addi	r2,r2,1
811171b0:	1885883a 	add	r2,r3,r2
811171b4:	10800003 	ldbu	r2,0(r2)
811171b8:	10803fcc 	andi	r2,r2,255
811171bc:	1080010c 	andi	r2,r2,4
811171c0:	10000626 	beq	r2,zero,811171dc <vLoadDefaultETHConf+0x6c4>
								(*p_inteiro) = c;
811171c4:	e0bffa17 	ldw	r2,-24(fp)
811171c8:	e0fff943 	ldbu	r3,-27(fp)
811171cc:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
811171d0:	e0bffa17 	ldw	r2,-24(fp)
811171d4:	10800044 	addi	r2,r2,1
811171d8:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
811171dc:	e0bff947 	ldb	r2,-27(fp)
811171e0:	10800ed8 	cmpnei	r2,r2,59
811171e4:	103feb1e 	bne	r2,zero,81117194 <__reset+0xfb0f7194>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
811171e8:	e0bffa17 	ldw	r2,-24(fp)
811171ec:	00c00284 	movi	r3,10
811171f0:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						xConfEth.siPortPUS = atoi( inteiro );
811171f4:	e0bffd04 	addi	r2,fp,-12
811171f8:	1009883a 	mov	r4,r2
811171fc:	111c8bc0 	call	8111c8bc <atoi>
81117200:	1007883a 	mov	r3,r2
81117204:	00a045b4 	movhi	r2,33046
81117208:	1088f804 	addi	r2,r2,9184
8111720c:	10c0058d 	sth	r3,22(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
81117210:	e0bffd04 	addi	r2,fp,-12
81117214:	e0bffa15 	stw	r2,-24(fp)

						break;
81117218:	00004506 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 'H':

						do {
							c = cGetNextChar(siFile);
8111721c:	e0bffc0f 	ldh	r2,-16(fp)
81117220:	1009883a 	mov	r4,r2
81117224:	111abd80 	call	8111abd8 <cGetNextChar>
81117228:	e0bff945 	stb	r2,-27(fp)
							if ( isdigit( c ) ) {
8111722c:	d0e00317 	ldw	r3,-32756(gp)
81117230:	e0bff947 	ldb	r2,-27(fp)
81117234:	10800044 	addi	r2,r2,1
81117238:	1885883a 	add	r2,r3,r2
8111723c:	10800003 	ldbu	r2,0(r2)
81117240:	10803fcc 	andi	r2,r2,255
81117244:	1080010c 	andi	r2,r2,4
81117248:	10000626 	beq	r2,zero,81117264 <vLoadDefaultETHConf+0x74c>
								(*p_inteiro) = c;
8111724c:	e0bffa17 	ldw	r2,-24(fp)
81117250:	e0fff943 	ldbu	r3,-27(fp)
81117254:	10c00005 	stb	r3,0(r2)
								p_inteiro++;
81117258:	e0bffa17 	ldw	r2,-24(fp)
8111725c:	10800044 	addi	r2,r2,1
81117260:	e0bffa15 	stw	r2,-24(fp)
							}
						} while ( c !=59 ); //ASCII: 59 = ';'
81117264:	e0bff947 	ldb	r2,-27(fp)
81117268:	10800ed8 	cmpnei	r2,r2,59
8111726c:	103feb1e 	bne	r2,zero,8111721c <__reset+0xfb0f721c>
						(*p_inteiro) = 10; // Adding LN -> ASCII: 10 = LINE FEED
81117270:	e0bffa17 	ldw	r2,-24(fp)
81117274:	00c00284 	movi	r3,10
81117278:	10c00005 	stb	r3,0(r2)
						/*Tiago: Proteger com mutex*/
						sidhcpTemp = atoi( inteiro );
8111727c:	e0bffd04 	addi	r2,fp,-12
81117280:	1009883a 	mov	r4,r2
81117284:	111c8bc0 	call	8111c8bc <atoi>
81117288:	e0bffc8d 	sth	r2,-14(fp)
						if (sidhcpTemp == 1)
8111728c:	e0bffc8f 	ldh	r2,-14(fp)
81117290:	10800058 	cmpnei	r2,r2,1
81117294:	1000051e 	bne	r2,zero,811172ac <vLoadDefaultETHConf+0x794>
							xConfEth.bDHCP = TRUE;
81117298:	00a045b4 	movhi	r2,33046
8111729c:	1088f804 	addi	r2,r2,9184
811172a0:	00c00044 	movi	r3,1
811172a4:	10c00615 	stw	r3,24(r2)
811172a8:	00000306 	br	811172b8 <vLoadDefaultETHConf+0x7a0>
						else
							xConfEth.bDHCP = FALSE;
811172ac:	00a045b4 	movhi	r2,33046
811172b0:	1088f804 	addi	r2,r2,9184
811172b4:	10000615 	stw	zero,24(r2)
						/*Tiago: Proteger com mutex*/
						p_inteiro = inteiro;
811172b8:	e0bffd04 	addi	r2,fp,-12
811172bc:	e0bffa15 	stw	r2,-24(fp)

						break;
811172c0:	00001b06 	br	81117330 <vLoadDefaultETHConf+0x818>
					case 0x3C: //"<"
						close = siCloseFile(siFile);
811172c4:	e0bffc0f 	ldh	r2,-16(fp)
811172c8:	1009883a 	mov	r4,r2
811172cc:	111ab980 	call	8111ab98 <siCloseFile>
811172d0:	e0bffb15 	stw	r2,-20(fp)
						if (close == FALSE){
811172d4:	e0bffb17 	ldw	r2,-20(fp)
811172d8:	1000071e 	bne	r2,zero,811172f8 <vLoadDefaultETHConf+0x7e0>
							#ifdef DEBUG_ON
								debug(fp,"SDCard: Can't close the file.\n");
811172dc:	d0a05e17 	ldw	r2,-32392(gp)
811172e0:	100f883a 	mov	r7,r2
811172e4:	01800784 	movi	r6,30
811172e8:	01400044 	movi	r5,1
811172ec:	01204574 	movhi	r4,33045
811172f0:	21292304 	addi	r4,r4,-23412
811172f4:	111d0b40 	call	8111d0b4 <fwrite>
							#endif
						}
						/* End of Parser File */
						bEOF = TRUE;
811172f8:	00800044 	movi	r2,1
811172fc:	e0bff815 	stw	r2,-32(fp)
						bSuccess = TRUE; //pensar melhor
81117300:	00800044 	movi	r2,1
81117304:	e0bff715 	stw	r2,-36(fp)
						break;
81117308:	00000906 	br	81117330 <vLoadDefaultETHConf+0x818>
					default:
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
8111730c:	d0a05e17 	ldw	r2,-32392(gp)
81117310:	100f883a 	mov	r7,r2
81117314:	01800844 	movi	r6,33
81117318:	01400044 	movi	r5,1
8111731c:	01204574 	movhi	r4,33045
81117320:	21292b04 	addi	r4,r4,-23380
81117324:	111d0b40 	call	8111d0b4 <fwrite>
						#endif
						break;
81117328:	00000106 	br	81117330 <vLoadDefaultETHConf+0x818>
						bEOF = TRUE;
						break;
					case 0x20: 	//ASCII: 0x20 = space
					case 10: 	//ASCII: 10 = LN
					case 13: 	//ASCII: 13 = CR
						break;
8111732c:	0001883a 	nop
						#ifdef DEBUG_ON
							fprintf(fp,"SDCard: Problem with the parser.\n");
						#endif
						break;
				}
			} while ( bEOF == FALSE );
81117330:	e0bff817 	ldw	r2,-32(fp)
81117334:	103e1626 	beq	r2,zero,81116b90 <__reset+0xfb0f6b90>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81117338:	00000f06 	br	81117378 <vLoadDefaultETHConf+0x860>
						break;
				}
			} while ( bEOF == FALSE );
		} else {
			#ifdef DEBUG_ON
				fprintf(fp,"SDCard: File not found.\n");
8111733c:	d0a05e17 	ldw	r2,-32392(gp)
81117340:	100f883a 	mov	r7,r2
81117344:	01800604 	movi	r6,24
81117348:	01400044 	movi	r5,1
8111734c:	01204574 	movhi	r4,33045
81117350:	21293404 	addi	r4,r4,-23344
81117354:	111d0b40 	call	8111d0b4 <fwrite>

	if ( (xSdHandle.connected == TRUE) && (bSDcardIsPresent()) && (bSDcardFAT16Check()) ){

		siFile = siOpenFile( ETH_FILE_NAME );

		if ( siFile >= 0 ){
81117358:	00000706 	br	81117378 <vLoadDefaultETHConf+0x860>
				fprintf(fp,"SDCard: File not found.\n");
			#endif
		}
	} else {
		#ifdef DEBUG_ON
			fprintf(fp,"SDCard: No SDCard.\n");
8111735c:	d0a05e17 	ldw	r2,-32392(gp)
81117360:	100f883a 	mov	r7,r2
81117364:	018004c4 	movi	r6,19
81117368:	01400044 	movi	r5,1
8111736c:	01204574 	movhi	r4,33045
81117370:	21293b04 	addi	r4,r4,-23316
81117374:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
	}
	/* Load the default configuration if not successful in read the SDCard */
	if ( bSuccess == FALSE ) {
81117378:	e0bff717 	ldw	r2,-36(fp)
8111737c:	1000541e 	bne	r2,zero,811174d0 <vLoadDefaultETHConf+0x9b8>
		/*Enviar mensagem que e gravar log que no encontrou o arquivo e comeara a utilizar o padrao*/
		printf("Ateno: Arquivo de conexo no foi encontrado. Carregando conf padrao\n");
81117380:	01204574 	movhi	r4,33045
81117384:	21294004 	addi	r4,r4,-23296
81117388:	111e0640 	call	8111e064 <puts>
		printf("No encontrou:'%s'.\n", ETH_FILE_NAME);
8111738c:	01604574 	movhi	r5,33045
81117390:	29691a04 	addi	r5,r5,-23448
81117394:	01204574 	movhi	r4,33045
81117398:	21295404 	addi	r4,r4,-23216
8111739c:	111dde00 	call	8111dde0 <printf>


		xConfEth.siPortPUS = 17000;
811173a0:	00a045b4 	movhi	r2,33046
811173a4:	1088f804 	addi	r2,r2,9184
811173a8:	00d09a04 	movi	r3,17000
811173ac:	10c0058d 	sth	r3,22(r2)
		/*ucIP[0].ucIP[1].ucIP[2].ucIP[3]
		 *192.168.0.5*/
		xConfEth.ucIP[0] = 192;
811173b0:	00a045b4 	movhi	r2,33046
811173b4:	1088f804 	addi	r2,r2,9184
811173b8:	00fff004 	movi	r3,-64
811173bc:	10c00005 	stb	r3,0(r2)
		xConfEth.ucIP[1] = 168;
811173c0:	00a045b4 	movhi	r2,33046
811173c4:	1088f804 	addi	r2,r2,9184
811173c8:	00ffea04 	movi	r3,-88
811173cc:	10c00045 	stb	r3,1(r2)
		xConfEth.ucIP[2] = 0;
811173d0:	00a045b4 	movhi	r2,33046
811173d4:	1088f804 	addi	r2,r2,9184
811173d8:	10000085 	stb	zero,2(r2)
		xConfEth.ucIP[3] = 5;
811173dc:	00a045b4 	movhi	r2,33046
811173e0:	1088f804 	addi	r2,r2,9184
811173e4:	00c00144 	movi	r3,5
811173e8:	10c000c5 	stb	r3,3(r2)

		/*ucGTW[0].ucGTW[1].ucGTW[2].ucGTW[3]
		 *192.168.0.1*/
		xConfEth.ucGTW[0] = 192;
811173ec:	00a045b4 	movhi	r2,33046
811173f0:	1088f804 	addi	r2,r2,9184
811173f4:	00fff004 	movi	r3,-64
811173f8:	10c00105 	stb	r3,4(r2)
		xConfEth.ucGTW[1] = 168;
811173fc:	00a045b4 	movhi	r2,33046
81117400:	1088f804 	addi	r2,r2,9184
81117404:	00ffea04 	movi	r3,-88
81117408:	10c00145 	stb	r3,5(r2)
		xConfEth.ucGTW[2] = 0;
8111740c:	00a045b4 	movhi	r2,33046
81117410:	1088f804 	addi	r2,r2,9184
81117414:	10000185 	stb	zero,6(r2)
		xConfEth.ucGTW[3] = 1;
81117418:	00a045b4 	movhi	r2,33046
8111741c:	1088f804 	addi	r2,r2,9184
81117420:	00c00044 	movi	r3,1
81117424:	10c001c5 	stb	r3,7(r2)

		/*ucSubNet[0].ucSubNet[1].ucSubNet[2].ucSubNet[3]
		 *192.168.0.5*/
		xConfEth.ucSubNet[0] = 255;
81117428:	00a045b4 	movhi	r2,33046
8111742c:	1088f804 	addi	r2,r2,9184
81117430:	00ffffc4 	movi	r3,-1
81117434:	10c00205 	stb	r3,8(r2)
		xConfEth.ucSubNet[1] = 255;
81117438:	00a045b4 	movhi	r2,33046
8111743c:	1088f804 	addi	r2,r2,9184
81117440:	00ffffc4 	movi	r3,-1
81117444:	10c00245 	stb	r3,9(r2)
		xConfEth.ucSubNet[2] = 255;
81117448:	00a045b4 	movhi	r2,33046
8111744c:	1088f804 	addi	r2,r2,9184
81117450:	00ffffc4 	movi	r3,-1
81117454:	10c00285 	stb	r3,10(r2)
		xConfEth.ucSubNet[3] = 0;
81117458:	00a045b4 	movhi	r2,33046
8111745c:	1088f804 	addi	r2,r2,9184
81117460:	100002c5 	stb	zero,11(r2)


		/*ucMAC[0]:ucMAC[1]:ucMAC[2]:ucMAC[3]:ucMAC[4]:ucMAC[5]
		 *fc:f7:63:4d:1f:42*/
		xConfEth.ucMAC[0] = 0xFC;
81117464:	00a045b4 	movhi	r2,33046
81117468:	1088f804 	addi	r2,r2,9184
8111746c:	00ffff04 	movi	r3,-4
81117470:	10c00405 	stb	r3,16(r2)
		xConfEth.ucMAC[1] = 0xF7;
81117474:	00a045b4 	movhi	r2,33046
81117478:	1088f804 	addi	r2,r2,9184
8111747c:	00fffdc4 	movi	r3,-9
81117480:	10c00445 	stb	r3,17(r2)
		xConfEth.ucMAC[2] = 0x63;
81117484:	00a045b4 	movhi	r2,33046
81117488:	1088f804 	addi	r2,r2,9184
8111748c:	00c018c4 	movi	r3,99
81117490:	10c00485 	stb	r3,18(r2)
		xConfEth.ucMAC[3] = 0x4D;
81117494:	00a045b4 	movhi	r2,33046
81117498:	1088f804 	addi	r2,r2,9184
8111749c:	00c01344 	movi	r3,77
811174a0:	10c004c5 	stb	r3,19(r2)
		xConfEth.ucMAC[4] = 0x1F;
811174a4:	00a045b4 	movhi	r2,33046
811174a8:	1088f804 	addi	r2,r2,9184
811174ac:	00c007c4 	movi	r3,31
811174b0:	10c00505 	stb	r3,20(r2)
		xConfEth.ucMAC[5] = 0x42;
811174b4:	00a045b4 	movhi	r2,33046
811174b8:	1088f804 	addi	r2,r2,9184
811174bc:	00c01084 	movi	r3,66
811174c0:	10c00545 	stb	r3,21(r2)

		xConfEth.bDHCP = FALSE;
811174c4:	00a045b4 	movhi	r2,33046
811174c8:	1088f804 	addi	r2,r2,9184
811174cc:	10000615 	stw	zero,24(r2)

	}

	return bSuccess;
811174d0:	e0bff717 	ldw	r2,-36(fp)
}
811174d4:	e6ffff04 	addi	sp,fp,-4
811174d8:	dfc00217 	ldw	ra,8(sp)
811174dc:	df000117 	ldw	fp,4(sp)
811174e0:	dc000017 	ldw	r16,0(sp)
811174e4:	dec00304 	addi	sp,sp,12
811174e8:	f800283a 	ret

811174ec <vShowEthConfig>:

#ifdef DEBUG_ON
	void vShowEthConfig( void ) {
811174ec:	defff004 	addi	sp,sp,-64
811174f0:	de00012e 	bgeu	sp,et,811174f8 <vShowEthConfig+0xc>
811174f4:	003b68fa 	trap	3
811174f8:	dfc00f15 	stw	ra,60(sp)
811174fc:	df000e15 	stw	fp,56(sp)
81117500:	df000e04 	addi	fp,sp,56
		char buffer[40];

		debug(fp, "Ethernet loaded configuration.\n");
81117504:	d0a05e17 	ldw	r2,-32392(gp)
81117508:	100f883a 	mov	r7,r2
8111750c:	018007c4 	movi	r6,31
81117510:	01400044 	movi	r5,1
81117514:	01204574 	movhi	r4,33045
81117518:	21295a04 	addi	r4,r4,-23192
8111751c:	111d0b40 	call	8111d0b4 <fwrite>

		memset(buffer,0,40);
81117520:	01800a04 	movi	r6,40
81117524:	000b883a 	mov	r5,zero
81117528:	e13ff604 	addi	r4,fp,-40
8111752c:	111dc180 	call	8111dc18 <memset>
		sprintf(buffer, "MAC: %x : %x : %x : %x : %x : %x \n", xConfEth.ucMAC[0], xConfEth.ucMAC[1], xConfEth.ucMAC[2], xConfEth.ucMAC[3], xConfEth.ucMAC[4], xConfEth.ucMAC[5]);
81117530:	00a045b4 	movhi	r2,33046
81117534:	1088f804 	addi	r2,r2,9184
81117538:	10800403 	ldbu	r2,16(r2)
8111753c:	11803fcc 	andi	r6,r2,255
81117540:	00a045b4 	movhi	r2,33046
81117544:	1088f804 	addi	r2,r2,9184
81117548:	10800443 	ldbu	r2,17(r2)
8111754c:	11c03fcc 	andi	r7,r2,255
81117550:	00a045b4 	movhi	r2,33046
81117554:	1088f804 	addi	r2,r2,9184
81117558:	10800483 	ldbu	r2,18(r2)
8111755c:	10c03fcc 	andi	r3,r2,255
81117560:	00a045b4 	movhi	r2,33046
81117564:	1088f804 	addi	r2,r2,9184
81117568:	108004c3 	ldbu	r2,19(r2)
8111756c:	11003fcc 	andi	r4,r2,255
81117570:	00a045b4 	movhi	r2,33046
81117574:	1088f804 	addi	r2,r2,9184
81117578:	10800503 	ldbu	r2,20(r2)
8111757c:	11403fcc 	andi	r5,r2,255
81117580:	00a045b4 	movhi	r2,33046
81117584:	1088f804 	addi	r2,r2,9184
81117588:	10800543 	ldbu	r2,21(r2)
8111758c:	10803fcc 	andi	r2,r2,255
81117590:	d8800315 	stw	r2,12(sp)
81117594:	d9400215 	stw	r5,8(sp)
81117598:	d9000115 	stw	r4,4(sp)
8111759c:	d8c00015 	stw	r3,0(sp)
811175a0:	01604574 	movhi	r5,33045
811175a4:	29696204 	addi	r5,r5,-23160
811175a8:	e13ff604 	addi	r4,fp,-40
811175ac:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer );
811175b0:	d0a05e17 	ldw	r2,-32392(gp)
811175b4:	e17ff604 	addi	r5,fp,-40
811175b8:	1009883a 	mov	r4,r2
811175bc:	111ca180 	call	8111ca18 <fprintf>

		memset(buffer,0,40);
811175c0:	01800a04 	movi	r6,40
811175c4:	000b883a 	mov	r5,zero
811175c8:	e13ff604 	addi	r4,fp,-40
811175cc:	111dc180 	call	8111dc18 <memset>
		sprintf(buffer, "IP: %i . %i . %i . %i \n",xConfEth.ucIP[0], xConfEth.ucIP[1], xConfEth.ucIP[2], xConfEth.ucIP[3] );
811175d0:	00a045b4 	movhi	r2,33046
811175d4:	1088f804 	addi	r2,r2,9184
811175d8:	10800003 	ldbu	r2,0(r2)
811175dc:	11003fcc 	andi	r4,r2,255
811175e0:	00a045b4 	movhi	r2,33046
811175e4:	1088f804 	addi	r2,r2,9184
811175e8:	10800043 	ldbu	r2,1(r2)
811175ec:	11403fcc 	andi	r5,r2,255
811175f0:	00a045b4 	movhi	r2,33046
811175f4:	1088f804 	addi	r2,r2,9184
811175f8:	10800083 	ldbu	r2,2(r2)
811175fc:	10c03fcc 	andi	r3,r2,255
81117600:	00a045b4 	movhi	r2,33046
81117604:	1088f804 	addi	r2,r2,9184
81117608:	108000c3 	ldbu	r2,3(r2)
8111760c:	10803fcc 	andi	r2,r2,255
81117610:	d8800115 	stw	r2,4(sp)
81117614:	d8c00015 	stw	r3,0(sp)
81117618:	280f883a 	mov	r7,r5
8111761c:	200d883a 	mov	r6,r4
81117620:	01604574 	movhi	r5,33045
81117624:	29696b04 	addi	r5,r5,-23124
81117628:	e13ff604 	addi	r4,fp,-40
8111762c:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer );
81117630:	d0a05e17 	ldw	r2,-32392(gp)
81117634:	e17ff604 	addi	r5,fp,-40
81117638:	1009883a 	mov	r4,r2
8111763c:	111ca180 	call	8111ca18 <fprintf>

		memset(buffer,0,40);
81117640:	01800a04 	movi	r6,40
81117644:	000b883a 	mov	r5,zero
81117648:	e13ff604 	addi	r4,fp,-40
8111764c:	111dc180 	call	8111dc18 <memset>
		sprintf(buffer, "GTW: %i . %i . %i . %i \n",xConfEth.ucGTW[0], xConfEth.ucGTW[1], xConfEth.ucGTW[2], xConfEth.ucGTW[3] );
81117650:	00a045b4 	movhi	r2,33046
81117654:	1088f804 	addi	r2,r2,9184
81117658:	10800103 	ldbu	r2,4(r2)
8111765c:	11003fcc 	andi	r4,r2,255
81117660:	00a045b4 	movhi	r2,33046
81117664:	1088f804 	addi	r2,r2,9184
81117668:	10800143 	ldbu	r2,5(r2)
8111766c:	11403fcc 	andi	r5,r2,255
81117670:	00a045b4 	movhi	r2,33046
81117674:	1088f804 	addi	r2,r2,9184
81117678:	10800183 	ldbu	r2,6(r2)
8111767c:	10c03fcc 	andi	r3,r2,255
81117680:	00a045b4 	movhi	r2,33046
81117684:	1088f804 	addi	r2,r2,9184
81117688:	108001c3 	ldbu	r2,7(r2)
8111768c:	10803fcc 	andi	r2,r2,255
81117690:	d8800115 	stw	r2,4(sp)
81117694:	d8c00015 	stw	r3,0(sp)
81117698:	280f883a 	mov	r7,r5
8111769c:	200d883a 	mov	r6,r4
811176a0:	01604574 	movhi	r5,33045
811176a4:	29697104 	addi	r5,r5,-23100
811176a8:	e13ff604 	addi	r4,fp,-40
811176ac:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer );
811176b0:	d0a05e17 	ldw	r2,-32392(gp)
811176b4:	e17ff604 	addi	r5,fp,-40
811176b8:	1009883a 	mov	r4,r2
811176bc:	111ca180 	call	8111ca18 <fprintf>

		memset(buffer,0,40);
811176c0:	01800a04 	movi	r6,40
811176c4:	000b883a 	mov	r5,zero
811176c8:	e13ff604 	addi	r4,fp,-40
811176cc:	111dc180 	call	8111dc18 <memset>
		sprintf(buffer, "Sub: %i . %i . %i . %i \n",xConfEth.ucSubNet[0], xConfEth.ucSubNet[1], xConfEth.ucSubNet[2], xConfEth.ucSubNet[3] );
811176d0:	00a045b4 	movhi	r2,33046
811176d4:	1088f804 	addi	r2,r2,9184
811176d8:	10800203 	ldbu	r2,8(r2)
811176dc:	11003fcc 	andi	r4,r2,255
811176e0:	00a045b4 	movhi	r2,33046
811176e4:	1088f804 	addi	r2,r2,9184
811176e8:	10800243 	ldbu	r2,9(r2)
811176ec:	11403fcc 	andi	r5,r2,255
811176f0:	00a045b4 	movhi	r2,33046
811176f4:	1088f804 	addi	r2,r2,9184
811176f8:	10800283 	ldbu	r2,10(r2)
811176fc:	10c03fcc 	andi	r3,r2,255
81117700:	00a045b4 	movhi	r2,33046
81117704:	1088f804 	addi	r2,r2,9184
81117708:	108002c3 	ldbu	r2,11(r2)
8111770c:	10803fcc 	andi	r2,r2,255
81117710:	d8800115 	stw	r2,4(sp)
81117714:	d8c00015 	stw	r3,0(sp)
81117718:	280f883a 	mov	r7,r5
8111771c:	200d883a 	mov	r6,r4
81117720:	01604574 	movhi	r5,33045
81117724:	29697804 	addi	r5,r5,-23072
81117728:	e13ff604 	addi	r4,fp,-40
8111772c:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer );
81117730:	d0a05e17 	ldw	r2,-32392(gp)
81117734:	e17ff604 	addi	r5,fp,-40
81117738:	1009883a 	mov	r4,r2
8111773c:	111ca180 	call	8111ca18 <fprintf>

		memset(buffer,0,40);
81117740:	01800a04 	movi	r6,40
81117744:	000b883a 	mov	r5,zero
81117748:	e13ff604 	addi	r4,fp,-40
8111774c:	111dc180 	call	8111dc18 <memset>
		sprintf(buffer, "DNS: %i . %i . %i . %i \n",xConfEth.ucDNS[0], xConfEth.ucDNS[1], xConfEth.ucDNS[2], xConfEth.ucDNS[3] );
81117750:	00a045b4 	movhi	r2,33046
81117754:	1088f804 	addi	r2,r2,9184
81117758:	10800303 	ldbu	r2,12(r2)
8111775c:	11003fcc 	andi	r4,r2,255
81117760:	00a045b4 	movhi	r2,33046
81117764:	1088f804 	addi	r2,r2,9184
81117768:	10800343 	ldbu	r2,13(r2)
8111776c:	11403fcc 	andi	r5,r2,255
81117770:	00a045b4 	movhi	r2,33046
81117774:	1088f804 	addi	r2,r2,9184
81117778:	10800383 	ldbu	r2,14(r2)
8111777c:	10c03fcc 	andi	r3,r2,255
81117780:	00a045b4 	movhi	r2,33046
81117784:	1088f804 	addi	r2,r2,9184
81117788:	108003c3 	ldbu	r2,15(r2)
8111778c:	10803fcc 	andi	r2,r2,255
81117790:	d8800115 	stw	r2,4(sp)
81117794:	d8c00015 	stw	r3,0(sp)
81117798:	280f883a 	mov	r7,r5
8111779c:	200d883a 	mov	r6,r4
811177a0:	01604574 	movhi	r5,33045
811177a4:	29697f04 	addi	r5,r5,-23044
811177a8:	e13ff604 	addi	r4,fp,-40
811177ac:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer );
811177b0:	d0a05e17 	ldw	r2,-32392(gp)
811177b4:	e17ff604 	addi	r5,fp,-40
811177b8:	1009883a 	mov	r4,r2
811177bc:	111ca180 	call	8111ca18 <fprintf>

		memset(buffer,0,40);
811177c0:	01800a04 	movi	r6,40
811177c4:	000b883a 	mov	r5,zero
811177c8:	e13ff604 	addi	r4,fp,-40
811177cc:	111dc180 	call	8111dc18 <memset>
		sprintf(buffer, "Porta PUS: %i\n", xConfEth.siPortPUS );
811177d0:	00a045b4 	movhi	r2,33046
811177d4:	1088f804 	addi	r2,r2,9184
811177d8:	1080058b 	ldhu	r2,22(r2)
811177dc:	10bfffcc 	andi	r2,r2,65535
811177e0:	100d883a 	mov	r6,r2
811177e4:	01604574 	movhi	r5,33045
811177e8:	29698604 	addi	r5,r5,-23016
811177ec:	e13ff604 	addi	r4,fp,-40
811177f0:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer );
811177f4:	d0a05e17 	ldw	r2,-32392(gp)
811177f8:	e17ff604 	addi	r5,fp,-40
811177fc:	1009883a 	mov	r4,r2
81117800:	111ca180 	call	8111ca18 <fprintf>

	}
81117804:	0001883a 	nop
81117808:	e037883a 	mov	sp,fp
8111780c:	dfc00117 	ldw	ra,4(sp)
81117810:	df000017 	ldw	fp,0(sp)
81117814:	dec00204 	addi	sp,sp,8
81117818:	f800283a 	ret

8111781c <ucCrc8>:

#include "crc8.h"


unsigned char ucCrc8(unsigned crc, unsigned char const *data, size_t len)
{
8111781c:	defffb04 	addi	sp,sp,-20
81117820:	de00012e 	bgeu	sp,et,81117828 <ucCrc8+0xc>
81117824:	003b68fa 	trap	3
81117828:	df000415 	stw	fp,16(sp)
8111782c:	df000404 	addi	fp,sp,16
81117830:	e13ffd15 	stw	r4,-12(fp)
81117834:	e17ffe15 	stw	r5,-8(fp)
81117838:	e1bfff15 	stw	r6,-4(fp)
    if (data == NULL)
8111783c:	e0bffe17 	ldw	r2,-8(fp)
81117840:	1000021e 	bne	r2,zero,8111784c <ucCrc8+0x30>
        return 0;
81117844:	0005883a 	mov	r2,zero
81117848:	00001906 	br	811178b0 <ucCrc8+0x94>
    crc &= 0xff;
8111784c:	e0bffd17 	ldw	r2,-12(fp)
81117850:	10803fcc 	andi	r2,r2,255
81117854:	e0bffd15 	stw	r2,-12(fp)
    unsigned char const *end = data + len;
81117858:	e0fffe17 	ldw	r3,-8(fp)
8111785c:	e0bfff17 	ldw	r2,-4(fp)
81117860:	1885883a 	add	r2,r3,r2
81117864:	e0bffc15 	stw	r2,-16(fp)
    while (data < end)
81117868:	00000d06 	br	811178a0 <ucCrc8+0x84>
        crc = crc8_table[crc ^ *data++];
8111786c:	e0bffe17 	ldw	r2,-8(fp)
81117870:	10c00044 	addi	r3,r2,1
81117874:	e0fffe15 	stw	r3,-8(fp)
81117878:	10800003 	ldbu	r2,0(r2)
8111787c:	10c03fcc 	andi	r3,r2,255
81117880:	e0bffd17 	ldw	r2,-12(fp)
81117884:	1886f03a 	xor	r3,r3,r2
81117888:	00a04574 	movhi	r2,33045
8111788c:	10a989c4 	addi	r2,r2,-23001
81117890:	10c5883a 	add	r2,r2,r3
81117894:	10800003 	ldbu	r2,0(r2)
81117898:	10803fcc 	andi	r2,r2,255
8111789c:	e0bffd15 	stw	r2,-12(fp)
{
    if (data == NULL)
        return 0;
    crc &= 0xff;
    unsigned char const *end = data + len;
    while (data < end)
811178a0:	e0fffe17 	ldw	r3,-8(fp)
811178a4:	e0bffc17 	ldw	r2,-16(fp)
811178a8:	18bff036 	bltu	r3,r2,8111786c <__reset+0xfb0f786c>
        crc = crc8_table[crc ^ *data++];
    return crc;
811178ac:	e0bffd17 	ldw	r2,-12(fp)
}
811178b0:	e037883a 	mov	sp,fp
811178b4:	df000017 	ldw	fp,0(sp)
811178b8:	dec00104 	addi	sp,sp,4
811178bc:	f800283a 	ret

811178c0 <ucCrc8wInit>:

unsigned char ucCrc8wInit(char const *data, size_t len)
{
811178c0:	defffb04 	addi	sp,sp,-20
811178c4:	de00012e 	bgeu	sp,et,811178cc <ucCrc8wInit+0xc>
811178c8:	003b68fa 	trap	3
811178cc:	dfc00415 	stw	ra,16(sp)
811178d0:	df000315 	stw	fp,12(sp)
811178d4:	df000304 	addi	fp,sp,12
811178d8:	e13ffe15 	stw	r4,-8(fp)
811178dc:	e17fff15 	stw	r5,-4(fp)
	unsigned char crc;

	crc = ucCrc8(0, NULL, 0);
811178e0:	000d883a 	mov	r6,zero
811178e4:	000b883a 	mov	r5,zero
811178e8:	0009883a 	mov	r4,zero
811178ec:	111781c0 	call	8111781c <ucCrc8>
811178f0:	e0bffd05 	stb	r2,-12(fp)
	return ucCrc8(crc, (unsigned char const *)data, len);
811178f4:	e0bffd03 	ldbu	r2,-12(fp)
811178f8:	e1bfff17 	ldw	r6,-4(fp)
811178fc:	e17ffe17 	ldw	r5,-8(fp)
81117900:	1009883a 	mov	r4,r2
81117904:	111781c0 	call	8111781c <ucCrc8>
}
81117908:	e037883a 	mov	sp,fp
8111790c:	dfc00117 	ldw	ra,4(sp)
81117910:	df000017 	ldw	fp,0(sp)
81117914:	dec00204 	addi	sp,sp,8
81117918:	f800283a 	ret

8111791c <vDataControllerInit>:


#include "data_controller.h"


void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
8111791c:	defffc04 	addi	sp,sp,-16
81117920:	de00012e 	bgeu	sp,et,81117928 <vDataControllerInit+0xc>
81117924:	003b68fa 	trap	3
81117928:	df000315 	stw	fp,12(sp)
8111792c:	df000304 	addi	fp,sp,12
81117930:	e13ffe15 	stw	r4,-8(fp)
81117934:	e17fff15 	stw	r5,-4(fp)
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;
81117938:	e0bffe17 	ldw	r2,-8(fp)
8111793c:	10000615 	stw	zero,24(r2)

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
81117940:	e03ffd05 	stb	zero,-12(fp)
81117944:	00001c06 	br	811179b8 <vDataControllerInit+0x9c>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
81117948:	e0bffd03 	ldbu	r2,-12(fp)
8111794c:	e0fffd03 	ldbu	r3,-12(fp)
81117950:	18c09524 	muli	r3,r3,596
81117954:	e13fff17 	ldw	r4,-4(fp)
81117958:	20c7883a 	add	r3,r4,r3
8111795c:	e13ffe17 	ldw	r4,-8(fp)
81117960:	10800084 	addi	r2,r2,2
81117964:	1085883a 	add	r2,r2,r2
81117968:	1085883a 	add	r2,r2,r2
8111796c:	2085883a 	add	r2,r4,r2
81117970:	10c00015 	stw	r3,0(r2)
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
81117974:	e17ffd03 	ldbu	r5,-12(fp)
81117978:	e0bffd03 	ldbu	r2,-12(fp)
8111797c:	e0ffff17 	ldw	r3,-4(fp)
81117980:	10802584 	addi	r2,r2,150
81117984:	1085883a 	add	r2,r2,r2
81117988:	1085883a 	add	r2,r2,r2
8111798c:	1885883a 	add	r2,r3,r2
81117990:	10c00017 	ldw	r3,0(r2)
81117994:	e13ffe17 	ldw	r4,-8(fp)
81117998:	288000c4 	addi	r2,r5,3
8111799c:	1085883a 	add	r2,r2,r2
811179a0:	1085883a 	add	r2,r2,r2
811179a4:	2085883a 	add	r2,r4,r2
811179a8:	10c00015 	stw	r3,0(r2)
void vDataControllerInit( TNData_Control *xDataControlL, TNFee_Control *xNfeeCOntrolL ) {
	unsigned char ucIL;

	xDataControlL->sMode = sMebInit;

	for ( ucIL = 0 ; ucIL < N_OF_NFEE; ucIL++ ) {
811179ac:	e0bffd03 	ldbu	r2,-12(fp)
811179b0:	10800044 	addi	r2,r2,1
811179b4:	e0bffd05 	stb	r2,-12(fp)
811179b8:	e0bffd03 	ldbu	r2,-12(fp)
811179bc:	103fe226 	beq	r2,zero,81117948 <__reset+0xfb0f7948>
		xDataControlL->xReadOnlyFeeControl.xNfee[ucIL] = &xNfeeCOntrolL->xNfee[ucIL];
		xDataControlL->xReadOnlyFeeControl.pbEnabledNFEEs[ucIL] = xNfeeCOntrolL->pbEnabledNFEEs[ucIL];
	}
	
	xDataControlL->xReadOnlyFeeControl.ucTimeCode = &xNfeeCOntrolL->ucTimeCode;
811179c0:	e0bfff17 	ldw	r2,-4(fp)
811179c4:	10c09804 	addi	r3,r2,608
811179c8:	e0bffe17 	ldw	r2,-8(fp)
811179cc:	10c00415 	stw	r3,16(r2)
	xDataControlL->bUpdateComplete = FALSE;
811179d0:	e0bffe17 	ldw	r2,-8(fp)
811179d4:	10000515 	stw	zero,20(r2)


	/* The only inverse attribution */
	/* This variable indicates when the DataControl finishs to use the RAM, then FeeControl can start fill the buffer to the next MasterSync */
	xNfeeCOntrolL->pbUpdateCReadOnly = &xDataControlL->bUpdateComplete;
811179d8:	e0bffe17 	ldw	r2,-8(fp)
811179dc:	10c00504 	addi	r3,r2,20
811179e0:	e0bfff17 	ldw	r2,-4(fp)
811179e4:	10c09a15 	stw	r3,616(r2)
}
811179e8:	0001883a 	nop
811179ec:	e037883a 	mov	sp,fp
811179f0:	df000017 	ldw	fp,0(sp)
811179f4:	dec00104 	addi	sp,sp,4
811179f8:	f800283a 	ret

811179fc <printErrorTask>:

#include "error_handler_simucam.h"


#ifdef DEBUG_ON
    void printErrorTask( INT8U error_code ) {
811179fc:	defff904 	addi	sp,sp,-28
81117a00:	de00012e 	bgeu	sp,et,81117a08 <printErrorTask+0xc>
81117a04:	003b68fa 	trap	3
81117a08:	dfc00615 	stw	ra,24(sp)
81117a0c:	df000515 	stw	fp,20(sp)
81117a10:	df000504 	addi	fp,sp,20
81117a14:	2005883a 	mov	r2,r4
81117a18:	e0bfff05 	stb	r2,-4(fp)
		char buffer[16] = "";
81117a1c:	e03ffb15 	stw	zero,-20(fp)
81117a20:	e03ffc15 	stw	zero,-16(fp)
81117a24:	e03ffd15 	stw	zero,-12(fp)
81117a28:	e03ffe15 	stw	zero,-8(fp)
		
		sprintf(buffer, "Err: %d\n", error_code);
81117a2c:	e0bfff03 	ldbu	r2,-4(fp)
81117a30:	100d883a 	mov	r6,r2
81117a34:	01604574 	movhi	r5,33045
81117a38:	2969ca04 	addi	r5,r5,-22744
81117a3c:	e13ffb04 	addi	r4,fp,-20
81117a40:	111e3a80 	call	8111e3a8 <sprintf>
		debug(fp, buffer);
81117a44:	d0a05e17 	ldw	r2,-32392(gp)
81117a48:	e17ffb04 	addi	r5,fp,-20
81117a4c:	1009883a 	mov	r4,r2
81117a50:	111ca180 	call	8111ca18 <fprintf>
	}
81117a54:	0001883a 	nop
81117a58:	e037883a 	mov	sp,fp
81117a5c:	dfc00117 	ldw	ra,4(sp)
81117a60:	df000017 	ldw	fp,0(sp)
81117a64:	dec00204 	addi	sp,sp,8
81117a68:	f800283a 	ret

81117a6c <vFailCreateMutexSResources>:
#endif

void vFailCreateMutexSResources( INT8U error_code )
{
81117a6c:	defffd04 	addi	sp,sp,-12
81117a70:	de00012e 	bgeu	sp,et,81117a78 <vFailCreateMutexSResources+0xc>
81117a74:	003b68fa 	trap	3
81117a78:	dfc00215 	stw	ra,8(sp)
81117a7c:	df000115 	stw	fp,4(sp)
81117a80:	df000104 	addi	fp,sp,4
81117a84:	2005883a 	mov	r2,r4
81117a88:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSResources. (exit)\n");
81117a8c:	d0a05e17 	ldw	r2,-32392(gp)
81117a90:	100f883a 	mov	r7,r2
81117a94:	018008c4 	movi	r6,35
81117a98:	01400044 	movi	r5,1
81117a9c:	01204574 	movhi	r4,33045
81117aa0:	2129cd04 	addi	r4,r4,-22732
81117aa4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
81117aa8:	e0bfff03 	ldbu	r2,-4(fp)
81117aac:	1009883a 	mov	r4,r2
81117ab0:	11179fc0 	call	811179fc <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ab4:	0001883a 	nop
81117ab8:	e037883a 	mov	sp,fp
81117abc:	dfc00117 	ldw	ra,4(sp)
81117ac0:	df000017 	ldw	fp,0(sp)
81117ac4:	dec00204 	addi	sp,sp,8
81117ac8:	f800283a 	ret

81117acc <vFailCreateMutexDMA>:

void vFailCreateMutexDMA( void )
{
81117acc:	defffe04 	addi	sp,sp,-8
81117ad0:	de00012e 	bgeu	sp,et,81117ad8 <vFailCreateMutexDMA+0xc>
81117ad4:	003b68fa 	trap	3
81117ad8:	dfc00115 	stw	ra,4(sp)
81117adc:	df000015 	stw	fp,0(sp)
81117ae0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp," CRITICAL: vFailCreateMutexDMA. (exit)\n");
81117ae4:	d0a05e17 	ldw	r2,-32392(gp)
81117ae8:	100f883a 	mov	r7,r2
81117aec:	018009c4 	movi	r6,39
81117af0:	01400044 	movi	r5,1
81117af4:	01204574 	movhi	r4,33045
81117af8:	2129d604 	addi	r4,r4,-22696
81117afc:	111d0b40 	call	8111d0b4 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b00:	0001883a 	nop
81117b04:	e037883a 	mov	sp,fp
81117b08:	dfc00117 	ldw	ra,4(sp)
81117b0c:	df000017 	ldw	fp,0(sp)
81117b10:	dec00204 	addi	sp,sp,8
81117b14:	f800283a 	ret

81117b18 <vFailCreateSemaphoreResources>:

void vFailCreateSemaphoreResources( void )
{
81117b18:	defffe04 	addi	sp,sp,-8
81117b1c:	de00012e 	bgeu	sp,et,81117b24 <vFailCreateSemaphoreResources+0xc>
81117b20:	003b68fa 	trap	3
81117b24:	dfc00115 	stw	ra,4(sp)
81117b28:	df000015 	stw	fp,0(sp)
81117b2c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateSemaphoreResources. (exit)\n");
81117b30:	d0a05e17 	ldw	r2,-32392(gp)
81117b34:	100f883a 	mov	r7,r2
81117b38:	01800984 	movi	r6,38
81117b3c:	01400044 	movi	r5,1
81117b40:	01204574 	movhi	r4,33045
81117b44:	2129e004 	addi	r4,r4,-22656
81117b48:	111d0b40 	call	8111d0b4 <fwrite>

	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b4c:	0001883a 	nop
81117b50:	e037883a 	mov	sp,fp
81117b54:	dfc00117 	ldw	ra,4(sp)
81117b58:	df000017 	ldw	fp,0(sp)
81117b5c:	dec00204 	addi	sp,sp,8
81117b60:	f800283a 	ret

81117b64 <vFailTestCriticasParts>:


void vFailTestCriticasParts( void )
{
81117b64:	defffe04 	addi	sp,sp,-8
81117b68:	de00012e 	bgeu	sp,et,81117b70 <vFailTestCriticasParts+0xc>
81117b6c:	003b68fa 	trap	3
81117b70:	dfc00115 	stw	ra,4(sp)
81117b74:	df000015 	stw	fp,0(sp)
81117b78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTestCriticasParts. (exit)\n");
81117b7c:	d0a05e17 	ldw	r2,-32392(gp)
81117b80:	100f883a 	mov	r7,r2
81117b84:	018007c4 	movi	r6,31
81117b88:	01400044 	movi	r5,1
81117b8c:	01204574 	movhi	r4,33045
81117b90:	2129ea04 	addi	r4,r4,-22616
81117b94:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117b98:	0001883a 	nop
81117b9c:	e037883a 	mov	sp,fp
81117ba0:	dfc00117 	ldw	ra,4(sp)
81117ba4:	df000017 	ldw	fp,0(sp)
81117ba8:	dec00204 	addi	sp,sp,8
81117bac:	f800283a 	ret

81117bb0 <vFailSendxSemCommInit>:


void vFailSendxSemCommInit( void )
{
81117bb0:	defffe04 	addi	sp,sp,-8
81117bb4:	de00012e 	bgeu	sp,et,81117bbc <vFailSendxSemCommInit+0xc>
81117bb8:	003b68fa 	trap	3
81117bbc:	dfc00115 	stw	ra,4(sp)
81117bc0:	df000015 	stw	fp,0(sp)
81117bc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendxSemCommInit. (exit)");
81117bc8:	d0a05e17 	ldw	r2,-32392(gp)
81117bcc:	100f883a 	mov	r7,r2
81117bd0:	01800744 	movi	r6,29
81117bd4:	01400044 	movi	r5,1
81117bd8:	01204574 	movhi	r4,33045
81117bdc:	2129f204 	addi	r4,r4,-22584
81117be0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the vParserRXTask. (exit)\n");
81117be4:	d0a05e17 	ldw	r2,-32392(gp)
81117be8:	100f883a 	mov	r7,r2
81117bec:	01800a44 	movi	r6,41
81117bf0:	01400044 	movi	r5,1
81117bf4:	01204574 	movhi	r4,33045
81117bf8:	2129fa04 	addi	r4,r4,-22552
81117bfc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c00:	0001883a 	nop
81117c04:	e037883a 	mov	sp,fp
81117c08:	dfc00117 	ldw	ra,4(sp)
81117c0c:	df000017 	ldw	fp,0(sp)
81117c10:	dec00204 	addi	sp,sp,8
81117c14:	f800283a 	ret

81117c18 <vFailSendPreParsedSemaphore>:

void vFailSendPreParsedSemaphore( void )
{
81117c18:	defffe04 	addi	sp,sp,-8
81117c1c:	de00012e 	bgeu	sp,et,81117c24 <vFailSendPreParsedSemaphore+0xc>
81117c20:	003b68fa 	trap	3
81117c24:	dfc00115 	stw	ra,4(sp)
81117c28:	df000015 	stw	fp,0(sp)
81117c2c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreParsedSemaphore. (exit)\n");
81117c30:	d0a05e17 	ldw	r2,-32392(gp)
81117c34:	100f883a 	mov	r7,r2
81117c38:	01800904 	movi	r6,36
81117c3c:	01400044 	movi	r5,1
81117c40:	01204574 	movhi	r4,33045
81117c44:	212a0504 	addi	r4,r4,-22508
81117c48:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c4c:	0001883a 	nop
81117c50:	e037883a 	mov	sp,fp
81117c54:	dfc00117 	ldw	ra,4(sp)
81117c58:	df000017 	ldw	fp,0(sp)
81117c5c:	dec00204 	addi	sp,sp,8
81117c60:	f800283a 	ret

81117c64 <vFailSendPreAckReceiverSemaphore>:

void vFailSendPreAckReceiverSemaphore( void )
{
81117c64:	defffe04 	addi	sp,sp,-8
81117c68:	de00012e 	bgeu	sp,et,81117c70 <vFailSendPreAckReceiverSemaphore+0xc>
81117c6c:	003b68fa 	trap	3
81117c70:	dfc00115 	stw	ra,4(sp)
81117c74:	df000015 	stw	fp,0(sp)
81117c78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckReceiverSemaphore. (exit)\n");
81117c7c:	d0a05e17 	ldw	r2,-32392(gp)
81117c80:	100f883a 	mov	r7,r2
81117c84:	01800a44 	movi	r6,41
81117c88:	01400044 	movi	r5,1
81117c8c:	01204574 	movhi	r4,33045
81117c90:	212a0f04 	addi	r4,r4,-22468
81117c94:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117c98:	0001883a 	nop
81117c9c:	e037883a 	mov	sp,fp
81117ca0:	dfc00117 	ldw	ra,4(sp)
81117ca4:	df000017 	ldw	fp,0(sp)
81117ca8:	dec00204 	addi	sp,sp,8
81117cac:	f800283a 	ret

81117cb0 <vFailSendPreAckSenderSemaphore>:


void vFailSendPreAckSenderSemaphore( void )
{
81117cb0:	defffe04 	addi	sp,sp,-8
81117cb4:	de00012e 	bgeu	sp,et,81117cbc <vFailSendPreAckSenderSemaphore+0xc>
81117cb8:	003b68fa 	trap	3
81117cbc:	dfc00115 	stw	ra,4(sp)
81117cc0:	df000015 	stw	fp,0(sp)
81117cc4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPreAckSenderSemaphore. (exit)\n");
81117cc8:	d0a05e17 	ldw	r2,-32392(gp)
81117ccc:	100f883a 	mov	r7,r2
81117cd0:	018009c4 	movi	r6,39
81117cd4:	01400044 	movi	r5,1
81117cd8:	01204574 	movhi	r4,33045
81117cdc:	212a1a04 	addi	r4,r4,-22424
81117ce0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117ce4:	0001883a 	nop
81117ce8:	e037883a 	mov	sp,fp
81117cec:	dfc00117 	ldw	ra,4(sp)
81117cf0:	df000017 	ldw	fp,0(sp)
81117cf4:	dec00204 	addi	sp,sp,8
81117cf8:	f800283a 	ret

81117cfc <vFailGetCountSemaphoreSenderTask>:


void vFailGetCountSemaphoreSenderTask( void )
{
81117cfc:	defffe04 	addi	sp,sp,-8
81117d00:	de00012e 	bgeu	sp,et,81117d08 <vFailGetCountSemaphoreSenderTask+0xc>
81117d04:	003b68fa 	trap	3
81117d08:	dfc00115 	stw	ra,4(sp)
81117d0c:	df000015 	stw	fp,0(sp)
81117d10:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreSenderTask. (exit)\n");
81117d14:	d0a05e17 	ldw	r2,-32392(gp)
81117d18:	100f883a 	mov	r7,r2
81117d1c:	01800a44 	movi	r6,41
81117d20:	01400044 	movi	r5,1
81117d24:	01204574 	movhi	r4,33045
81117d28:	212a2404 	addi	r4,r4,-22384
81117d2c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vSenderAckTask)\n");
81117d30:	d0a05e17 	ldw	r2,-32392(gp)
81117d34:	100f883a 	mov	r7,r2
81117d38:	01801104 	movi	r6,68
81117d3c:	01400044 	movi	r5,1
81117d40:	01204574 	movhi	r4,33045
81117d44:	212a2f04 	addi	r4,r4,-22340
81117d48:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117d4c:	0001883a 	nop
81117d50:	e037883a 	mov	sp,fp
81117d54:	dfc00117 	ldw	ra,4(sp)
81117d58:	df000017 	ldw	fp,0(sp)
81117d5c:	dec00204 	addi	sp,sp,8
81117d60:	f800283a 	ret

81117d64 <vFailGetMutexSenderTask>:

void vFailGetMutexSenderTask( void )
{
81117d64:	defffe04 	addi	sp,sp,-8
81117d68:	de00012e 	bgeu	sp,et,81117d70 <vFailGetMutexSenderTask+0xc>
81117d6c:	003b68fa 	trap	3
81117d70:	dfc00115 	stw	ra,4(sp)
81117d74:	df000015 	stw	fp,0(sp)
81117d78:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexSenderTask. (exit)\n");
81117d7c:	d0a05e17 	ldw	r2,-32392(gp)
81117d80:	100f883a 	mov	r7,r2
81117d84:	01800804 	movi	r6,32
81117d88:	01400044 	movi	r5,1
81117d8c:	01204574 	movhi	r4,33045
81117d90:	212a4104 	addi	r4,r4,-22268
81117d94:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vSenderAckTask)\n");
81117d98:	d0a05e17 	ldw	r2,-32392(gp)
81117d9c:	100f883a 	mov	r7,r2
81117da0:	01801084 	movi	r6,66
81117da4:	01400044 	movi	r5,1
81117da8:	01204574 	movhi	r4,33045
81117dac:	212a4a04 	addi	r4,r4,-22232
81117db0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117db4:	0001883a 	nop
81117db8:	e037883a 	mov	sp,fp
81117dbc:	dfc00117 	ldw	ra,4(sp)
81117dc0:	df000017 	ldw	fp,0(sp)
81117dc4:	dec00204 	addi	sp,sp,8
81117dc8:	f800283a 	ret

81117dcc <vFailGetCountSemaphoreReceiverTask>:


void vFailGetCountSemaphoreReceiverTask( void )
{
81117dcc:	defffe04 	addi	sp,sp,-8
81117dd0:	de00012e 	bgeu	sp,et,81117dd8 <vFailGetCountSemaphoreReceiverTask+0xc>
81117dd4:	003b68fa 	trap	3
81117dd8:	dfc00115 	stw	ra,4(sp)
81117ddc:	df000015 	stw	fp,0(sp)
81117de0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphoreReceiverTask. (exit)\n");
81117de4:	d0a05e17 	ldw	r2,-32392(gp)
81117de8:	100f883a 	mov	r7,r2
81117dec:	01800ac4 	movi	r6,43
81117df0:	01400044 	movi	r5,1
81117df4:	01204574 	movhi	r4,33045
81117df8:	212a5b04 	addi	r4,r4,-22164
81117dfc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vReceiverAckTask)\n");
81117e00:	d0a05e17 	ldw	r2,-32392(gp)
81117e04:	100f883a 	mov	r7,r2
81117e08:	01801184 	movi	r6,70
81117e0c:	01400044 	movi	r5,1
81117e10:	01204574 	movhi	r4,33045
81117e14:	212a6604 	addi	r4,r4,-22120
81117e18:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e1c:	0001883a 	nop
81117e20:	e037883a 	mov	sp,fp
81117e24:	dfc00117 	ldw	ra,4(sp)
81117e28:	df000017 	ldw	fp,0(sp)
81117e2c:	dec00204 	addi	sp,sp,8
81117e30:	f800283a 	ret

81117e34 <vFailGetMutexReceiverTask>:

void vFailGetMutexReceiverTask( void )
{
81117e34:	defffe04 	addi	sp,sp,-8
81117e38:	de00012e 	bgeu	sp,et,81117e40 <vFailGetMutexReceiverTask+0xc>
81117e3c:	003b68fa 	trap	3
81117e40:	dfc00115 	stw	ra,4(sp)
81117e44:	df000015 	stw	fp,0(sp)
81117e48:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexReceiverTask. (exit)\n");
81117e4c:	d0a05e17 	ldw	r2,-32392(gp)
81117e50:	100f883a 	mov	r7,r2
81117e54:	01800884 	movi	r6,34
81117e58:	01400044 	movi	r5,1
81117e5c:	01204574 	movhi	r4,33045
81117e60:	212a7804 	addi	r4,r4,-22048
81117e64:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the xSenderACK.(vReceiverAckTask)\n");
81117e68:	d0a05e17 	ldw	r2,-32392(gp)
81117e6c:	100f883a 	mov	r7,r2
81117e70:	01801104 	movi	r6,68
81117e74:	01400044 	movi	r5,1
81117e78:	01204574 	movhi	r4,33045
81117e7c:	212a8104 	addi	r4,r4,-22012
81117e80:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117e84:	0001883a 	nop
81117e88:	e037883a 	mov	sp,fp
81117e8c:	dfc00117 	ldw	ra,4(sp)
81117e90:	df000017 	ldw	fp,0(sp)
81117e94:	dec00204 	addi	sp,sp,8
81117e98:	f800283a 	ret

81117e9c <vFailGetMutexTxUARTSenderTask>:


void vFailGetMutexTxUARTSenderTask( void )
{
81117e9c:	defffe04 	addi	sp,sp,-8
81117ea0:	de00012e 	bgeu	sp,et,81117ea8 <vFailGetMutexTxUARTSenderTask+0xc>
81117ea4:	003b68fa 	trap	3
81117ea8:	dfc00115 	stw	ra,4(sp)
81117eac:	df000015 	stw	fp,0(sp)
81117eb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMutexTxUARTSenderTask. (exit)\n");
81117eb4:	d0a05e17 	ldw	r2,-32392(gp)
81117eb8:	100f883a 	mov	r7,r2
81117ebc:	01800984 	movi	r6,38
81117ec0:	01400044 	movi	r5,1
81117ec4:	01204574 	movhi	r4,33045
81117ec8:	212a9304 	addi	r4,r4,-21940
81117ecc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get mutex that protects the tx buffer.(vSenderAckTask)\n");
81117ed0:	d0a05e17 	ldw	r2,-32392(gp)
81117ed4:	100f883a 	mov	r7,r2
81117ed8:	01801044 	movi	r6,65
81117edc:	01400044 	movi	r5,1
81117ee0:	01204574 	movhi	r4,33045
81117ee4:	212a9d04 	addi	r4,r4,-21900
81117ee8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117eec:	0001883a 	nop
81117ef0:	e037883a 	mov	sp,fp
81117ef4:	dfc00117 	ldw	ra,4(sp)
81117ef8:	df000017 	ldw	fp,0(sp)
81117efc:	dec00204 	addi	sp,sp,8
81117f00:	f800283a 	ret

81117f04 <vFailGetMacRTC>:


void vFailGetMacRTC( void )
{
81117f04:	defffe04 	addi	sp,sp,-8
81117f08:	de00012e 	bgeu	sp,et,81117f10 <vFailGetMacRTC+0xc>
81117f0c:	003b68fa 	trap	3
81117f10:	dfc00115 	stw	ra,4(sp)
81117f14:	df000015 	stw	fp,0(sp)
81117f18:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetMacRTC\n");
81117f1c:	d0a05e17 	ldw	r2,-32392(gp)
81117f20:	100f883a 	mov	r7,r2
81117f24:	018003c4 	movi	r6,15
81117f28:	01400044 	movi	r5,1
81117f2c:	01204574 	movhi	r4,33045
81117f30:	212aae04 	addi	r4,r4,-21832
81117f34:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f38:	0001883a 	nop
81117f3c:	e037883a 	mov	sp,fp
81117f40:	dfc00117 	ldw	ra,4(sp)
81117f44:	df000017 	ldw	fp,0(sp)
81117f48:	dec00204 	addi	sp,sp,8
81117f4c:	f800283a 	ret

81117f50 <vFailInitialization>:


void vFailInitialization( void )
{
81117f50:	defffe04 	addi	sp,sp,-8
81117f54:	de00012e 	bgeu	sp,et,81117f5c <vFailInitialization+0xc>
81117f58:	003b68fa 	trap	3
81117f5c:	dfc00115 	stw	ra,4(sp)
81117f60:	df000015 	stw	fp,0(sp)
81117f64:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInitialization\n");
81117f68:	d0a05e17 	ldw	r2,-32392(gp)
81117f6c:	100f883a 	mov	r7,r2
81117f70:	01800504 	movi	r6,20
81117f74:	01400044 	movi	r5,1
81117f78:	01204574 	movhi	r4,33045
81117f7c:	212ab204 	addi	r4,r4,-21816
81117f80:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117f84:	0001883a 	nop
81117f88:	e037883a 	mov	sp,fp
81117f8c:	dfc00117 	ldw	ra,4(sp)
81117f90:	df000017 	ldw	fp,0(sp)
81117f94:	dec00204 	addi	sp,sp,8
81117f98:	f800283a 	ret

81117f9c <vFailReceiverCreate>:


void vFailReceiverCreate( void )
{
81117f9c:	defffe04 	addi	sp,sp,-8
81117fa0:	de00012e 	bgeu	sp,et,81117fa8 <vFailReceiverCreate+0xc>
81117fa4:	003b68fa 	trap	3
81117fa8:	dfc00115 	stw	ra,4(sp)
81117fac:	df000015 	stw	fp,0(sp)
81117fb0:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vReceiverUartTask\n");
81117fb4:	d0a05e17 	ldw	r2,-32392(gp)
81117fb8:	100f883a 	mov	r7,r2
81117fbc:	01800484 	movi	r6,18
81117fc0:	01400044 	movi	r5,1
81117fc4:	01204574 	movhi	r4,33045
81117fc8:	212ab804 	addi	r4,r4,-21792
81117fcc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81117fd0:	0001883a 	nop
81117fd4:	e037883a 	mov	sp,fp
81117fd8:	dfc00117 	ldw	ra,4(sp)
81117fdc:	df000017 	ldw	fp,0(sp)
81117fe0:	dec00204 	addi	sp,sp,8
81117fe4:	f800283a 	ret

81117fe8 <vFailSenderCreate>:


void vFailSenderCreate( void )
{
81117fe8:	defffe04 	addi	sp,sp,-8
81117fec:	de00012e 	bgeu	sp,et,81117ff4 <vFailSenderCreate+0xc>
81117ff0:	003b68fa 	trap	3
81117ff4:	dfc00115 	stw	ra,4(sp)
81117ff8:	df000015 	stw	fp,0(sp)
81117ffc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSenderCreate\n");
81118000:	d0a05e17 	ldw	r2,-32392(gp)
81118004:	100f883a 	mov	r7,r2
81118008:	01800484 	movi	r6,18
8111800c:	01400044 	movi	r5,1
81118010:	01204574 	movhi	r4,33045
81118014:	212abd04 	addi	r4,r4,-21772
81118018:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111801c:	0001883a 	nop
81118020:	e037883a 	mov	sp,fp
81118024:	dfc00117 	ldw	ra,4(sp)
81118028:	df000017 	ldw	fp,0(sp)
8111802c:	dec00204 	addi	sp,sp,8
81118030:	f800283a 	ret

81118034 <vFailDeleteInitialization>:


void vFailDeleteInitialization( void )
{
81118034:	defffe04 	addi	sp,sp,-8
81118038:	de00012e 	bgeu	sp,et,81118040 <vFailDeleteInitialization+0xc>
8111803c:	003b68fa 	trap	3
81118040:	dfc00115 	stw	ra,4(sp)
81118044:	df000015 	stw	fp,0(sp)
81118048:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailDeleteInitialization\n");
8111804c:	d0a05e17 	ldw	r2,-32392(gp)
81118050:	100f883a 	mov	r7,r2
81118054:	01800684 	movi	r6,26
81118058:	01400044 	movi	r5,1
8111805c:	01204574 	movhi	r4,33045
81118060:	212ac204 	addi	r4,r4,-21752
81118064:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118068:	0001883a 	nop
8111806c:	e037883a 	mov	sp,fp
81118070:	dfc00117 	ldw	ra,4(sp)
81118074:	df000017 	ldw	fp,0(sp)
81118078:	dec00204 	addi	sp,sp,8
8111807c:	f800283a 	ret

81118080 <vFailSetCountSemaphorexBuffer32>:


void vFailSetCountSemaphorexBuffer32( void )
{
81118080:	defffe04 	addi	sp,sp,-8
81118084:	de00012e 	bgeu	sp,et,8111808c <vFailSetCountSemaphorexBuffer32+0xc>
81118088:	003b68fa 	trap	3
8111808c:	dfc00115 	stw	ra,4(sp)
81118090:	df000015 	stw	fp,0(sp)
81118094:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer32. (exit)\n");
81118098:	d0a05e17 	ldw	r2,-32392(gp)
8111809c:	100f883a 	mov	r7,r2
811180a0:	01800a04 	movi	r6,40
811180a4:	01400044 	movi	r5,1
811180a8:	01204574 	movhi	r4,33045
811180ac:	212ac904 	addi	r4,r4,-21724
811180b0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
811180b4:	d0a05e17 	ldw	r2,-32392(gp)
811180b8:	100f883a 	mov	r7,r2
811180bc:	018008c4 	movi	r6,35
811180c0:	01400044 	movi	r5,1
811180c4:	01204574 	movhi	r4,33045
811180c8:	212ad404 	addi	r4,r4,-21680
811180cc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811180d0:	0001883a 	nop
811180d4:	e037883a 	mov	sp,fp
811180d8:	dfc00117 	ldw	ra,4(sp)
811180dc:	df000017 	ldw	fp,0(sp)
811180e0:	dec00204 	addi	sp,sp,8
811180e4:	f800283a 	ret

811180e8 <vFailSetCountSemaphorexBuffer64>:

void vFailSetCountSemaphorexBuffer64( void )
{
811180e8:	defffe04 	addi	sp,sp,-8
811180ec:	de00012e 	bgeu	sp,et,811180f4 <vFailSetCountSemaphorexBuffer64+0xc>
811180f0:	003b68fa 	trap	3
811180f4:	dfc00115 	stw	ra,4(sp)
811180f8:	df000015 	stw	fp,0(sp)
811180fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer64. (exit)\n");
81118100:	d0a05e17 	ldw	r2,-32392(gp)
81118104:	100f883a 	mov	r7,r2
81118108:	01800a04 	movi	r6,40
8111810c:	01400044 	movi	r5,1
81118110:	01204574 	movhi	r4,33045
81118114:	212add04 	addi	r4,r4,-21644
81118118:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
8111811c:	d0a05e17 	ldw	r2,-32392(gp)
81118120:	100f883a 	mov	r7,r2
81118124:	018008c4 	movi	r6,35
81118128:	01400044 	movi	r5,1
8111812c:	01204574 	movhi	r4,33045
81118130:	212ad404 	addi	r4,r4,-21680
81118134:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118138:	0001883a 	nop
8111813c:	e037883a 	mov	sp,fp
81118140:	dfc00117 	ldw	ra,4(sp)
81118144:	df000017 	ldw	fp,0(sp)
81118148:	dec00204 	addi	sp,sp,8
8111814c:	f800283a 	ret

81118150 <vFailSetCountSemaphorexBuffer128>:

/*CRITICAL*/
void vFailSetCountSemaphorexBuffer128( void )
{
81118150:	defffe04 	addi	sp,sp,-8
81118154:	de00012e 	bgeu	sp,et,8111815c <vFailSetCountSemaphorexBuffer128+0xc>
81118158:	003b68fa 	trap	3
8111815c:	dfc00115 	stw	ra,4(sp)
81118160:	df000015 	stw	fp,0(sp)
81118164:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetCountSemaphorexBuffer128. (exit)\n");
81118168:	d0a05e17 	ldw	r2,-32392(gp)
8111816c:	100f883a 	mov	r7,r2
81118170:	01800a44 	movi	r6,41
81118174:	01400044 	movi	r5,1
81118178:	01204574 	movhi	r4,33045
8111817c:	212ae804 	addi	r4,r4,-21600
81118180:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not post to the semaphore.()\n");
81118184:	d0a05e17 	ldw	r2,-32392(gp)
81118188:	100f883a 	mov	r7,r2
8111818c:	018008c4 	movi	r6,35
81118190:	01400044 	movi	r5,1
81118194:	01204574 	movhi	r4,33045
81118198:	212ad404 	addi	r4,r4,-21680
8111819c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811181a0:	0001883a 	nop
811181a4:	e037883a 	mov	sp,fp
811181a8:	dfc00117 	ldw	ra,4(sp)
811181ac:	df000017 	ldw	fp,0(sp)
811181b0:	dec00204 	addi	sp,sp,8
811181b4:	f800283a 	ret

811181b8 <vFailGetCountSemaphorexBuffer128>:

void vFailGetCountSemaphorexBuffer128( void )
{
811181b8:	defffe04 	addi	sp,sp,-8
811181bc:	de00012e 	bgeu	sp,et,811181c4 <vFailGetCountSemaphorexBuffer128+0xc>
811181c0:	003b68fa 	trap	3
811181c4:	dfc00115 	stw	ra,4(sp)
811181c8:	df000015 	stw	fp,0(sp)
811181cc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer128. (exit)\n");
811181d0:	d0a05e17 	ldw	r2,-32392(gp)
811181d4:	100f883a 	mov	r7,r2
811181d8:	01800a44 	movi	r6,41
811181dc:	01400044 	movi	r5,1
811181e0:	01204574 	movhi	r4,33045
811181e4:	212af304 	addi	r4,r4,-21556
811181e8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
811181ec:	d0a05e17 	ldw	r2,-32392(gp)
811181f0:	100f883a 	mov	r7,r2
811181f4:	01800884 	movi	r6,34
811181f8:	01400044 	movi	r5,1
811181fc:	01204574 	movhi	r4,33045
81118200:	212afe04 	addi	r4,r4,-21512
81118204:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118208:	0001883a 	nop
8111820c:	e037883a 	mov	sp,fp
81118210:	dfc00117 	ldw	ra,4(sp)
81118214:	df000017 	ldw	fp,0(sp)
81118218:	dec00204 	addi	sp,sp,8
8111821c:	f800283a 	ret

81118220 <vFailGetCountSemaphorexBuffer64>:

void vFailGetCountSemaphorexBuffer64( void )
{
81118220:	defffe04 	addi	sp,sp,-8
81118224:	de00012e 	bgeu	sp,et,8111822c <vFailGetCountSemaphorexBuffer64+0xc>
81118228:	003b68fa 	trap	3
8111822c:	dfc00115 	stw	ra,4(sp)
81118230:	df000015 	stw	fp,0(sp)
81118234:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer64. (exit)\n");
81118238:	d0a05e17 	ldw	r2,-32392(gp)
8111823c:	100f883a 	mov	r7,r2
81118240:	01800a04 	movi	r6,40
81118244:	01400044 	movi	r5,1
81118248:	01204574 	movhi	r4,33045
8111824c:	212b0704 	addi	r4,r4,-21476
81118250:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
81118254:	d0a05e17 	ldw	r2,-32392(gp)
81118258:	100f883a 	mov	r7,r2
8111825c:	01800884 	movi	r6,34
81118260:	01400044 	movi	r5,1
81118264:	01204574 	movhi	r4,33045
81118268:	212afe04 	addi	r4,r4,-21512
8111826c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118270:	0001883a 	nop
81118274:	e037883a 	mov	sp,fp
81118278:	dfc00117 	ldw	ra,4(sp)
8111827c:	df000017 	ldw	fp,0(sp)
81118280:	dec00204 	addi	sp,sp,8
81118284:	f800283a 	ret

81118288 <vFailGetCountSemaphorexBuffer32>:

void vFailGetCountSemaphorexBuffer32( void )
{
81118288:	defffe04 	addi	sp,sp,-8
8111828c:	de00012e 	bgeu	sp,et,81118294 <vFailGetCountSemaphorexBuffer32+0xc>
81118290:	003b68fa 	trap	3
81118294:	dfc00115 	stw	ra,4(sp)
81118298:	df000015 	stw	fp,0(sp)
8111829c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorexBuffer32. (exit)\n");
811182a0:	d0a05e17 	ldw	r2,-32392(gp)
811182a4:	100f883a 	mov	r7,r2
811182a8:	01800a04 	movi	r6,40
811182ac:	01400044 	movi	r5,1
811182b0:	01204574 	movhi	r4,33045
811182b4:	212b1204 	addi	r4,r4,-21432
811182b8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get to the semaphore.()\n");
811182bc:	d0a05e17 	ldw	r2,-32392(gp)
811182c0:	100f883a 	mov	r7,r2
811182c4:	01800884 	movi	r6,34
811182c8:	01400044 	movi	r5,1
811182cc:	01204574 	movhi	r4,33045
811182d0:	212afe04 	addi	r4,r4,-21512
811182d4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811182d8:	0001883a 	nop
811182dc:	e037883a 	mov	sp,fp
811182e0:	dfc00117 	ldw	ra,4(sp)
811182e4:	df000017 	ldw	fp,0(sp)
811182e8:	dec00204 	addi	sp,sp,8
811182ec:	f800283a 	ret

811182f0 <vFailFoundBufferRetransmission>:

void vFailFoundBufferRetransmission( void )
{
811182f0:	defffe04 	addi	sp,sp,-8
811182f4:	de00012e 	bgeu	sp,et,811182fc <vFailFoundBufferRetransmission+0xc>
811182f8:	003b68fa 	trap	3
811182fc:	dfc00115 	stw	ra,4(sp)
81118300:	df000015 	stw	fp,0(sp)
81118304:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"Warning: Incomming Ack id doesn't exists.\n");
81118308:	d0a05e17 	ldw	r2,-32392(gp)
8111830c:	100f883a 	mov	r7,r2
81118310:	01800a84 	movi	r6,42
81118314:	01400044 	movi	r5,1
81118318:	01204574 	movhi	r4,33045
8111831c:	212b1d04 	addi	r4,r4,-21388
81118320:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not found the id in the (re)transmission buffers.(In Ack Handler)\n");
81118324:	d0a05e17 	ldw	r2,-32392(gp)
81118328:	100f883a 	mov	r7,r2
8111832c:	01801204 	movi	r6,72
81118330:	01400044 	movi	r5,1
81118334:	01204574 	movhi	r4,33045
81118338:	212b2804 	addi	r4,r4,-21344
8111833c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118340:	0001883a 	nop
81118344:	e037883a 	mov	sp,fp
81118348:	dfc00117 	ldw	ra,4(sp)
8111834c:	df000017 	ldw	fp,0(sp)
81118350:	dec00204 	addi	sp,sp,8
81118354:	f800283a 	ret

81118358 <vFailGetCountSemaphorePreParsedBuffer>:


void vFailGetCountSemaphorePreParsedBuffer( void )
{
81118358:	defffe04 	addi	sp,sp,-8
8111835c:	de00012e 	bgeu	sp,et,81118364 <vFailGetCountSemaphorePreParsedBuffer+0xc>
81118360:	003b68fa 	trap	3
81118364:	dfc00115 	stw	ra,4(sp)
81118368:	df000015 	stw	fp,0(sp)
8111836c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetCountSemaphorePreParsedBuffer. (exit)\n");
81118370:	d0a05e17 	ldw	r2,-32392(gp)
81118374:	100f883a 	mov	r7,r2
81118378:	01800b84 	movi	r6,46
8111837c:	01400044 	movi	r5,1
81118380:	01204574 	movhi	r4,33045
81118384:	212b3b04 	addi	r4,r4,-21268
81118388:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the semaphore and some error happens.(vParserRXTask)\n");
8111838c:	d0a05e17 	ldw	r2,-32392(gp)
81118390:	100f883a 	mov	r7,r2
81118394:	018010c4 	movi	r6,67
81118398:	01400044 	movi	r5,1
8111839c:	01204574 	movhi	r4,33045
811183a0:	212b4704 	addi	r4,r4,-21220
811183a4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811183a8:	0001883a 	nop
811183ac:	e037883a 	mov	sp,fp
811183b0:	dfc00117 	ldw	ra,4(sp)
811183b4:	df000017 	ldw	fp,0(sp)
811183b8:	dec00204 	addi	sp,sp,8
811183bc:	f800283a 	ret

811183c0 <vFailGetxMutexPreParsedParserRxTask>:


void vFailGetxMutexPreParsedParserRxTask( void )
{
811183c0:	defffe04 	addi	sp,sp,-8
811183c4:	de00012e 	bgeu	sp,et,811183cc <vFailGetxMutexPreParsedParserRxTask+0xc>
811183c8:	003b68fa 	trap	3
811183cc:	dfc00115 	stw	ra,4(sp)
811183d0:	df000015 	stw	fp,0(sp)
811183d4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetxMutexPreParsedParserRxTask. (exit)\n");
811183d8:	d0a05e17 	ldw	r2,-32392(gp)
811183dc:	100f883a 	mov	r7,r2
811183e0:	01800b04 	movi	r6,44
811183e4:	01400044 	movi	r5,1
811183e8:	01204574 	movhi	r4,33045
811183ec:	212b5804 	addi	r4,r4,-21152
811183f0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get the mutex and some error happens.(vParserRXTask)\n");
811183f4:	d0a05e17 	ldw	r2,-32392(gp)
811183f8:	100f883a 	mov	r7,r2
811183fc:	01800fc4 	movi	r6,63
81118400:	01400044 	movi	r5,1
81118404:	01204574 	movhi	r4,33045
81118408:	212b6404 	addi	r4,r4,-21104
8111840c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118410:	0001883a 	nop
81118414:	e037883a 	mov	sp,fp
81118418:	dfc00117 	ldw	ra,4(sp)
8111841c:	df000017 	ldw	fp,0(sp)
81118420:	dec00204 	addi	sp,sp,8
81118424:	f800283a 	ret

81118428 <vNoContentInPreParsedBuffer>:


void vNoContentInPreParsedBuffer( void )
{
81118428:	defffe04 	addi	sp,sp,-8
8111842c:	de00012e 	bgeu	sp,et,81118434 <vNoContentInPreParsedBuffer+0xc>
81118430:	003b68fa 	trap	3
81118434:	dfc00115 	stw	ra,4(sp)
81118438:	df000015 	stw	fp,0(sp)
8111843c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vNoContentInPreParsedBuffer. (exit)\n");
81118440:	d0a05e17 	ldw	r2,-32392(gp)
81118444:	100f883a 	mov	r7,r2
81118448:	01800904 	movi	r6,36
8111844c:	01400044 	movi	r5,1
81118450:	01204574 	movhi	r4,33045
81118454:	212b7404 	addi	r4,r4,-21040
81118458:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Semaphore was post by some task but has no message in the PreParsedBuffer.(vParserRXTask)\n");
8111845c:	d0a05e17 	ldw	r2,-32392(gp)
81118460:	100f883a 	mov	r7,r2
81118464:	01801684 	movi	r6,90
81118468:	01400044 	movi	r5,1
8111846c:	01204574 	movhi	r4,33045
81118470:	212b7e04 	addi	r4,r4,-21000
81118474:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118478:	0001883a 	nop
8111847c:	e037883a 	mov	sp,fp
81118480:	dfc00117 	ldw	ra,4(sp)
81118484:	df000017 	ldw	fp,0(sp)
81118488:	dec00204 	addi	sp,sp,8
8111848c:	f800283a 	ret

81118490 <vCouldNotSendEthConfUART>:


void vCouldNotSendEthConfUART( void )
{
81118490:	defffe04 	addi	sp,sp,-8
81118494:	de00012e 	bgeu	sp,et,8111849c <vCouldNotSendEthConfUART+0xc>
81118498:	003b68fa 	trap	3
8111849c:	dfc00115 	stw	ra,4(sp)
811184a0:	df000015 	stw	fp,0(sp)
811184a4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendEthConfUART. (exit)\n");
811184a8:	d0a05e17 	ldw	r2,-32392(gp)
811184ac:	100f883a 	mov	r7,r2
811184b0:	01800844 	movi	r6,33
811184b4:	01400044 	movi	r5,1
811184b8:	01204574 	movhi	r4,33045
811184bc:	212b9504 	addi	r4,r4,-20908
811184c0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send or not write ETH conf of the NUC in the (re)transmission buffer.(vSendEthConf)\n");
811184c4:	d0a05e17 	ldw	r2,-32392(gp)
811184c8:	100f883a 	mov	r7,r2
811184cc:	01801784 	movi	r6,94
811184d0:	01400044 	movi	r5,1
811184d4:	01204574 	movhi	r4,33045
811184d8:	212b9e04 	addi	r4,r4,-20872
811184dc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811184e0:	0001883a 	nop
811184e4:	e037883a 	mov	sp,fp
811184e8:	dfc00117 	ldw	ra,4(sp)
811184ec:	df000017 	ldw	fp,0(sp)
811184f0:	dec00204 	addi	sp,sp,8
811184f4:	f800283a 	ret

811184f8 <vFailSendNack>:

void vFailSendNack( void )
{
811184f8:	defffe04 	addi	sp,sp,-8
811184fc:	de00012e 	bgeu	sp,et,81118504 <vFailSendNack+0xc>
81118500:	003b68fa 	trap	3
81118504:	dfc00115 	stw	ra,4(sp)
81118508:	df000015 	stw	fp,0(sp)
8111850c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendNack. (exit)\n");
81118510:	d0a05e17 	ldw	r2,-32392(gp)
81118514:	100f883a 	mov	r7,r2
81118518:	01800584 	movi	r6,22
8111851c:	01400044 	movi	r5,1
81118520:	01204574 	movhi	r4,33045
81118524:	212bb604 	addi	r4,r4,-20776
81118528:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Send Nack using the PreAckSender buffer. \n");
8111852c:	d0a05e17 	ldw	r2,-32392(gp)
81118530:	100f883a 	mov	r7,r2
81118534:	01800a84 	movi	r6,42
81118538:	01400044 	movi	r5,1
8111853c:	01204574 	movhi	r4,33045
81118540:	212bbc04 	addi	r4,r4,-20752
81118544:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118548:	0001883a 	nop
8111854c:	e037883a 	mov	sp,fp
81118550:	dfc00117 	ldw	ra,4(sp)
81118554:	df000017 	ldw	fp,0(sp)
81118558:	dec00204 	addi	sp,sp,8
8111855c:	f800283a 	ret

81118560 <vFailSetPreAckSenderBuffer>:

void vFailSetPreAckSenderBuffer( void )
{
81118560:	defffe04 	addi	sp,sp,-8
81118564:	de00012e 	bgeu	sp,et,8111856c <vFailSetPreAckSenderBuffer+0xc>
81118568:	003b68fa 	trap	3
8111856c:	dfc00115 	stw	ra,4(sp)
81118570:	df000015 	stw	fp,0(sp)
81118574:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckSenderBuffer. (exit)\n");
81118578:	d0a05e17 	ldw	r2,-32392(gp)
8111857c:	100f883a 	mov	r7,r2
81118580:	018008c4 	movi	r6,35
81118584:	01400044 	movi	r5,1
81118588:	01204574 	movhi	r4,33045
8111858c:	212bc704 	addi	r4,r4,-20708
81118590:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task out_ack_handler using the PreAckSender buffer.\n");
81118594:	d0a05e17 	ldw	r2,-32392(gp)
81118598:	100f883a 	mov	r7,r2
8111859c:	01801584 	movi	r6,86
811185a0:	01400044 	movi	r5,1
811185a4:	01204574 	movhi	r4,33045
811185a8:	212bd004 	addi	r4,r4,-20672
811185ac:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811185b0:	0001883a 	nop
811185b4:	e037883a 	mov	sp,fp
811185b8:	dfc00117 	ldw	ra,4(sp)
811185bc:	df000017 	ldw	fp,0(sp)
811185c0:	dec00204 	addi	sp,sp,8
811185c4:	f800283a 	ret

811185c8 <vFailSetPreParsedBuffer>:

void vFailSetPreParsedBuffer( void )
{
811185c8:	defffe04 	addi	sp,sp,-8
811185cc:	de00012e 	bgeu	sp,et,811185d4 <vFailSetPreParsedBuffer+0xc>
811185d0:	003b68fa 	trap	3
811185d4:	dfc00115 	stw	ra,4(sp)
811185d8:	df000015 	stw	fp,0(sp)
811185dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreParsedBuffer. (exit)\n");
811185e0:	d0a05e17 	ldw	r2,-32392(gp)
811185e4:	100f883a 	mov	r7,r2
811185e8:	01800804 	movi	r6,32
811185ec:	01400044 	movi	r5,1
811185f0:	01204574 	movhi	r4,33045
811185f4:	212be604 	addi	r4,r4,-20584
811185f8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task parser_comm using the PreParsed buffer.\n");
811185fc:	d0a05e17 	ldw	r2,-32392(gp)
81118600:	100f883a 	mov	r7,r2
81118604:	018013c4 	movi	r6,79
81118608:	01400044 	movi	r5,1
8111860c:	01204574 	movhi	r4,33045
81118610:	212bef04 	addi	r4,r4,-20548
81118614:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118618:	0001883a 	nop
8111861c:	e037883a 	mov	sp,fp
81118620:	dfc00117 	ldw	ra,4(sp)
81118624:	df000017 	ldw	fp,0(sp)
81118628:	dec00204 	addi	sp,sp,8
8111862c:	f800283a 	ret

81118630 <vFailSetPreAckReceiverBuffer>:


void vFailSetPreAckReceiverBuffer( void )
{
81118630:	defffe04 	addi	sp,sp,-8
81118634:	de00012e 	bgeu	sp,et,8111863c <vFailSetPreAckReceiverBuffer+0xc>
81118638:	003b68fa 	trap	3
8111863c:	dfc00115 	stw	ra,4(sp)
81118640:	df000015 	stw	fp,0(sp)
81118644:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSetPreAckReceiverBuffer. (exit)\n");
81118648:	d0a05e17 	ldw	r2,-32392(gp)
8111864c:	100f883a 	mov	r7,r2
81118650:	01800944 	movi	r6,37
81118654:	01400044 	movi	r5,1
81118658:	01204574 	movhi	r4,33045
8111865c:	212c0304 	addi	r4,r4,-20468
81118660:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the message to the task in_out_handler using the PreAckReceiver buffer.\n");
81118664:	d0a05e17 	ldw	r2,-32392(gp)
81118668:	100f883a 	mov	r7,r2
8111866c:	018015c4 	movi	r6,87
81118670:	01400044 	movi	r5,1
81118674:	01204574 	movhi	r4,33045
81118678:	212c0d04 	addi	r4,r4,-20428
8111867c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118680:	0001883a 	nop
81118684:	e037883a 	mov	sp,fp
81118688:	dfc00117 	ldw	ra,4(sp)
8111868c:	df000017 	ldw	fp,0(sp)
81118690:	dec00204 	addi	sp,sp,8
81118694:	f800283a 	ret

81118698 <vFailParserCommTaskCreate>:


void vFailParserCommTaskCreate( void )
{
81118698:	defffe04 	addi	sp,sp,-8
8111869c:	de00012e 	bgeu	sp,et,811186a4 <vFailParserCommTaskCreate+0xc>
811186a0:	003b68fa 	trap	3
811186a4:	dfc00115 	stw	ra,4(sp)
811186a8:	df000015 	stw	fp,0(sp)
811186ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailParserCommTaskCreate\n");
811186b0:	d0a05e17 	ldw	r2,-32392(gp)
811186b4:	100f883a 	mov	r7,r2
811186b8:	01800684 	movi	r6,26
811186bc:	01400044 	movi	r5,1
811186c0:	01204574 	movhi	r4,33045
811186c4:	212c2304 	addi	r4,r4,-20340
811186c8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811186cc:	0001883a 	nop
811186d0:	e037883a 	mov	sp,fp
811186d4:	dfc00117 	ldw	ra,4(sp)
811186d8:	df000017 	ldw	fp,0(sp)
811186dc:	dec00204 	addi	sp,sp,8
811186e0:	f800283a 	ret

811186e4 <vFailInAckHandlerTaskCreate>:

void vFailInAckHandlerTaskCreate( void )
{
811186e4:	defffe04 	addi	sp,sp,-8
811186e8:	de00012e 	bgeu	sp,et,811186f0 <vFailInAckHandlerTaskCreate+0xc>
811186ec:	003b68fa 	trap	3
811186f0:	dfc00115 	stw	ra,4(sp)
811186f4:	df000015 	stw	fp,0(sp)
811186f8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
811186fc:	d0a05e17 	ldw	r2,-32392(gp)
81118700:	100f883a 	mov	r7,r2
81118704:	01800704 	movi	r6,28
81118708:	01400044 	movi	r5,1
8111870c:	01204574 	movhi	r4,33045
81118710:	212c2a04 	addi	r4,r4,-20312
81118714:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118718:	0001883a 	nop
8111871c:	e037883a 	mov	sp,fp
81118720:	dfc00117 	ldw	ra,4(sp)
81118724:	df000017 	ldw	fp,0(sp)
81118728:	dec00204 	addi	sp,sp,8
8111872c:	f800283a 	ret

81118730 <vFailOutAckHandlerTaskCreate>:

void vFailOutAckHandlerTaskCreate( void )
{
81118730:	defffe04 	addi	sp,sp,-8
81118734:	de00012e 	bgeu	sp,et,8111873c <vFailOutAckHandlerTaskCreate+0xc>
81118738:	003b68fa 	trap	3
8111873c:	dfc00115 	stw	ra,4(sp)
81118740:	df000015 	stw	fp,0(sp)
81118744:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailInAckHandlerTaskCreate\n");
81118748:	d0a05e17 	ldw	r2,-32392(gp)
8111874c:	100f883a 	mov	r7,r2
81118750:	01800704 	movi	r6,28
81118754:	01400044 	movi	r5,1
81118758:	01204574 	movhi	r4,33045
8111875c:	212c2a04 	addi	r4,r4,-20312
81118760:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118764:	0001883a 	nop
81118768:	e037883a 	mov	sp,fp
8111876c:	dfc00117 	ldw	ra,4(sp)
81118770:	df000017 	ldw	fp,0(sp)
81118774:	dec00204 	addi	sp,sp,8
81118778:	f800283a 	ret

8111877c <vFailCreateTimerRetransmisison>:


void vFailCreateTimerRetransmisison( void )
{
8111877c:	defffe04 	addi	sp,sp,-8
81118780:	de00012e 	bgeu	sp,et,81118788 <vFailCreateTimerRetransmisison+0xc>
81118784:	003b68fa 	trap	3
81118788:	dfc00115 	stw	ra,4(sp)
8111878c:	df000015 	stw	fp,0(sp)
81118790:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateTimerRetransmisison\n");
81118794:	d0a05e17 	ldw	r2,-32392(gp)
81118798:	100f883a 	mov	r7,r2
8111879c:	018007c4 	movi	r6,31
811187a0:	01400044 	movi	r5,1
811187a4:	01204574 	movhi	r4,33045
811187a8:	212c3204 	addi	r4,r4,-20280
811187ac:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811187b0:	0001883a 	nop
811187b4:	e037883a 	mov	sp,fp
811187b8:	dfc00117 	ldw	ra,4(sp)
811187bc:	df000017 	ldw	fp,0(sp)
811187c0:	dec00204 	addi	sp,sp,8
811187c4:	f800283a 	ret

811187c8 <vCouldNotCheckBufferTimeOutFunction>:


void vCouldNotCheckBufferTimeOutFunction( void )
{
811187c8:	defffe04 	addi	sp,sp,-8
811187cc:	de00012e 	bgeu	sp,et,811187d4 <vCouldNotCheckBufferTimeOutFunction+0xc>
811187d0:	003b68fa 	trap	3
811187d4:	dfc00115 	stw	ra,4(sp)
811187d8:	df000015 	stw	fp,0(sp)
811187dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCheckBufferTimeOutFunction\n");
811187e0:	d0a05e17 	ldw	r2,-32392(gp)
811187e4:	100f883a 	mov	r7,r2
811187e8:	01800904 	movi	r6,36
811187ec:	01400044 	movi	r5,1
811187f0:	01204574 	movhi	r4,33045
811187f4:	212c3a04 	addi	r4,r4,-20248
811187f8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811187fc:	0001883a 	nop
81118800:	e037883a 	mov	sp,fp
81118804:	dfc00117 	ldw	ra,4(sp)
81118808:	df000017 	ldw	fp,0(sp)
8111880c:	dec00204 	addi	sp,sp,8
81118810:	f800283a 	ret

81118814 <vFailTimeoutCheckerTaskCreate>:

/* Critico */
void vFailTimeoutCheckerTaskCreate( void )
{
81118814:	defffe04 	addi	sp,sp,-8
81118818:	de00012e 	bgeu	sp,et,81118820 <vFailTimeoutCheckerTaskCreate+0xc>
8111881c:	003b68fa 	trap	3
81118820:	dfc00115 	stw	ra,4(sp)
81118824:	df000015 	stw	fp,0(sp)
81118828:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailTimeoutCheckerTaskCreate (Critico)\n");
8111882c:	d0a05e17 	ldw	r2,-32392(gp)
81118830:	100f883a 	mov	r7,r2
81118834:	01800a04 	movi	r6,40
81118838:	01400044 	movi	r5,1
8111883c:	01204574 	movhi	r4,33045
81118840:	212c4404 	addi	r4,r4,-20208
81118844:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118848:	0001883a 	nop
8111884c:	e037883a 	mov	sp,fp
81118850:	dfc00117 	ldw	ra,4(sp)
81118854:	df000017 	ldw	fp,0(sp)
81118858:	dec00204 	addi	sp,sp,8
8111885c:	f800283a 	ret

81118860 <vFailGetBlockingSemTimeoutTask>:


void vFailGetBlockingSemTimeoutTask( void )
{
81118860:	defffe04 	addi	sp,sp,-8
81118864:	de00012e 	bgeu	sp,et,8111886c <vFailGetBlockingSemTimeoutTask+0xc>
81118868:	003b68fa 	trap	3
8111886c:	dfc00115 	stw	ra,4(sp)
81118870:	df000015 	stw	fp,0(sp)
81118874:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailGetBlockingSemTimeoutTask. (exit)\n");
81118878:	d0a05e17 	ldw	r2,-32392(gp)
8111887c:	100f883a 	mov	r7,r2
81118880:	018009c4 	movi	r6,39
81118884:	01400044 	movi	r5,1
81118888:	01204574 	movhi	r4,33045
8111888c:	212c4f04 	addi	r4,r4,-20164
81118890:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Retrun from a blocking (0) OSSemPend with a error.\n");
81118894:	d0a05e17 	ldw	r2,-32392(gp)
81118898:	100f883a 	mov	r7,r2
8111889c:	01800cc4 	movi	r6,51
811188a0:	01400044 	movi	r5,1
811188a4:	01204574 	movhi	r4,33045
811188a8:	212c5904 	addi	r4,r4,-20124
811188ac:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811188b0:	0001883a 	nop
811188b4:	e037883a 	mov	sp,fp
811188b8:	dfc00117 	ldw	ra,4(sp)
811188bc:	df000017 	ldw	fp,0(sp)
811188c0:	dec00204 	addi	sp,sp,8
811188c4:	f800283a 	ret

811188c8 <vFailPostBlockingSemTimeoutTask>:

void vFailPostBlockingSemTimeoutTask( void )
{
811188c8:	defffe04 	addi	sp,sp,-8
811188cc:	de00012e 	bgeu	sp,et,811188d4 <vFailPostBlockingSemTimeoutTask+0xc>
811188d0:	003b68fa 	trap	3
811188d4:	dfc00115 	stw	ra,4(sp)
811188d8:	df000015 	stw	fp,0(sp)
811188dc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailPostBlockingSemTimeoutTask. (exit)\n");
811188e0:	d0a05e17 	ldw	r2,-32392(gp)
811188e4:	100f883a 	mov	r7,r2
811188e8:	01800a04 	movi	r6,40
811188ec:	01400044 	movi	r5,1
811188f0:	01204574 	movhi	r4,33045
811188f4:	212c6604 	addi	r4,r4,-20072
811188f8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Post the semaphore for the TimeoutTask.\n");
811188fc:	d0a05e17 	ldw	r2,-32392(gp)
81118900:	100f883a 	mov	r7,r2
81118904:	01800c84 	movi	r6,50
81118908:	01400044 	movi	r5,1
8111890c:	01204574 	movhi	r4,33045
81118910:	212c7104 	addi	r4,r4,-20028
81118914:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118918:	0001883a 	nop
8111891c:	e037883a 	mov	sp,fp
81118920:	dfc00117 	ldw	ra,4(sp)
81118924:	df000017 	ldw	fp,0(sp)
81118928:	dec00204 	addi	sp,sp,8
8111892c:	f800283a 	ret

81118930 <vFailCouldNotRetransmitTimeoutTask>:


void vFailCouldNotRetransmitTimeoutTask( void )
{
81118930:	defffe04 	addi	sp,sp,-8
81118934:	de00012e 	bgeu	sp,et,8111893c <vFailCouldNotRetransmitTimeoutTask+0xc>
81118938:	003b68fa 	trap	3
8111893c:	dfc00115 	stw	ra,4(sp)
81118940:	df000015 	stw	fp,0(sp)
81118944:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCouldNotRetransmitTimeoutTask. (exit)\n");
81118948:	d0a05e17 	ldw	r2,-32392(gp)
8111894c:	100f883a 	mov	r7,r2
81118950:	01800ac4 	movi	r6,43
81118954:	01400044 	movi	r5,1
81118958:	01204574 	movhi	r4,33045
8111895c:	212c7e04 	addi	r4,r4,-19976
81118960:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"After sleep for 50 ticks, could not get access to the tx uart. No retransmission occurs.\n");
81118964:	d0a05e17 	ldw	r2,-32392(gp)
81118968:	100f883a 	mov	r7,r2
8111896c:	01801644 	movi	r6,89
81118970:	01400044 	movi	r5,1
81118974:	01204574 	movhi	r4,33045
81118978:	212c8904 	addi	r4,r4,-19932
8111897c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118980:	0001883a 	nop
81118984:	e037883a 	mov	sp,fp
81118988:	dfc00117 	ldw	ra,4(sp)
8111898c:	df000017 	ldw	fp,0(sp)
81118990:	dec00204 	addi	sp,sp,8
81118994:	f800283a 	ret

81118998 <vCouldNotRetransmitB32TimeoutTask>:


void vCouldNotRetransmitB32TimeoutTask( void )
{
81118998:	defffe04 	addi	sp,sp,-8
8111899c:	de00012e 	bgeu	sp,et,811189a4 <vCouldNotRetransmitB32TimeoutTask+0xc>
811189a0:	003b68fa 	trap	3
811189a4:	dfc00115 	stw	ra,4(sp)
811189a8:	df000015 	stw	fp,0(sp)
811189ac:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB32TimeoutTask. (exit)\n");
811189b0:	d0a05e17 	ldw	r2,-32392(gp)
811189b4:	100f883a 	mov	r7,r2
811189b8:	01800a84 	movi	r6,42
811189bc:	01400044 	movi	r5,1
811189c0:	01204574 	movhi	r4,33045
811189c4:	212ca004 	addi	r4,r4,-19840
811189c8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (32).\n");
811189cc:	d0a05e17 	ldw	r2,-32392(gp)
811189d0:	100f883a 	mov	r7,r2
811189d4:	01801444 	movi	r6,81
811189d8:	01400044 	movi	r5,1
811189dc:	01204574 	movhi	r4,33045
811189e0:	212cab04 	addi	r4,r4,-19796
811189e4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811189e8:	0001883a 	nop
811189ec:	e037883a 	mov	sp,fp
811189f0:	dfc00117 	ldw	ra,4(sp)
811189f4:	df000017 	ldw	fp,0(sp)
811189f8:	dec00204 	addi	sp,sp,8
811189fc:	f800283a 	ret

81118a00 <vCouldNotRetransmitB64TimeoutTask>:

void vCouldNotRetransmitB64TimeoutTask( void )
{
81118a00:	defffe04 	addi	sp,sp,-8
81118a04:	de00012e 	bgeu	sp,et,81118a0c <vCouldNotRetransmitB64TimeoutTask+0xc>
81118a08:	003b68fa 	trap	3
81118a0c:	dfc00115 	stw	ra,4(sp)
81118a10:	df000015 	stw	fp,0(sp)
81118a14:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB64TimeoutTask. (exit)\n");
81118a18:	d0a05e17 	ldw	r2,-32392(gp)
81118a1c:	100f883a 	mov	r7,r2
81118a20:	01800a84 	movi	r6,42
81118a24:	01400044 	movi	r5,1
81118a28:	01204574 	movhi	r4,33045
81118a2c:	212cc004 	addi	r4,r4,-19712
81118a30:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (64).\n");
81118a34:	d0a05e17 	ldw	r2,-32392(gp)
81118a38:	100f883a 	mov	r7,r2
81118a3c:	01801444 	movi	r6,81
81118a40:	01400044 	movi	r5,1
81118a44:	01204574 	movhi	r4,33045
81118a48:	212ccb04 	addi	r4,r4,-19668
81118a4c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118a50:	0001883a 	nop
81118a54:	e037883a 	mov	sp,fp
81118a58:	dfc00117 	ldw	ra,4(sp)
81118a5c:	df000017 	ldw	fp,0(sp)
81118a60:	dec00204 	addi	sp,sp,8
81118a64:	f800283a 	ret

81118a68 <vCouldNotRetransmitB128TimeoutTask>:

void vCouldNotRetransmitB128TimeoutTask( void )
{
81118a68:	defffe04 	addi	sp,sp,-8
81118a6c:	de00012e 	bgeu	sp,et,81118a74 <vCouldNotRetransmitB128TimeoutTask+0xc>
81118a70:	003b68fa 	trap	3
81118a74:	dfc00115 	stw	ra,4(sp)
81118a78:	df000015 	stw	fp,0(sp)
81118a7c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotRetransmitB128TimeoutTask. (exit)\n");
81118a80:	d0a05e17 	ldw	r2,-32392(gp)
81118a84:	100f883a 	mov	r7,r2
81118a88:	01800ac4 	movi	r6,43
81118a8c:	01400044 	movi	r5,1
81118a90:	01204574 	movhi	r4,33045
81118a94:	212ce004 	addi	r4,r4,-19584
81118a98:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"There's something to retransmit but could not get the mutex for the buffer (128).\n");
81118a9c:	d0a05e17 	ldw	r2,-32392(gp)
81118aa0:	100f883a 	mov	r7,r2
81118aa4:	01801484 	movi	r6,82
81118aa8:	01400044 	movi	r5,1
81118aac:	01204574 	movhi	r4,33045
81118ab0:	212ceb04 	addi	r4,r4,-19540
81118ab4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ab8:	0001883a 	nop
81118abc:	e037883a 	mov	sp,fp
81118ac0:	dfc00117 	ldw	ra,4(sp)
81118ac4:	df000017 	ldw	fp,0(sp)
81118ac8:	dec00204 	addi	sp,sp,8
81118acc:	f800283a 	ret

81118ad0 <vFailStartTimerRetransmission>:


void vFailStartTimerRetransmission( void )
{
81118ad0:	defffe04 	addi	sp,sp,-8
81118ad4:	de00012e 	bgeu	sp,et,81118adc <vFailStartTimerRetransmission+0xc>
81118ad8:	003b68fa 	trap	3
81118adc:	dfc00115 	stw	ra,4(sp)
81118ae0:	df000015 	stw	fp,0(sp)
81118ae4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailStartTimerRetransmission. (exit)\n");
81118ae8:	d0a05e17 	ldw	r2,-32392(gp)
81118aec:	100f883a 	mov	r7,r2
81118af0:	01800984 	movi	r6,38
81118af4:	01400044 	movi	r5,1
81118af8:	01204574 	movhi	r4,33045
81118afc:	212d0004 	addi	r4,r4,-19456
81118b00:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Fail trying to start the timer xTimerRetransmission.\n");
81118b04:	d0a05e17 	ldw	r2,-32392(gp)
81118b08:	100f883a 	mov	r7,r2
81118b0c:	01800d44 	movi	r6,53
81118b10:	01400044 	movi	r5,1
81118b14:	01204574 	movhi	r4,33045
81118b18:	212d0a04 	addi	r4,r4,-19416
81118b1c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118b20:	0001883a 	nop
81118b24:	e037883a 	mov	sp,fp
81118b28:	dfc00117 	ldw	ra,4(sp)
81118b2c:	df000017 	ldw	fp,0(sp)
81118b30:	dec00204 	addi	sp,sp,8
81118b34:	f800283a 	ret

81118b38 <vCouldNotSendTurnOff>:


void vCouldNotSendTurnOff( void )
{
81118b38:	defffe04 	addi	sp,sp,-8
81118b3c:	de00012e 	bgeu	sp,et,81118b44 <vCouldNotSendTurnOff+0xc>
81118b40:	003b68fa 	trap	3
81118b44:	dfc00115 	stw	ra,4(sp)
81118b48:	df000015 	stw	fp,0(sp)
81118b4c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTurnOff. (exit)\n");
81118b50:	d0a05e17 	ldw	r2,-32392(gp)
81118b54:	100f883a 	mov	r7,r2
81118b58:	01800744 	movi	r6,29
81118b5c:	01400044 	movi	r5,1
81118b60:	01204574 	movhi	r4,33045
81118b64:	212d1804 	addi	r4,r4,-19360
81118b68:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the turn off command. \n");
81118b6c:	d0a05e17 	ldw	r2,-32392(gp)
81118b70:	100f883a 	mov	r7,r2
81118b74:	01800984 	movi	r6,38
81118b78:	01400044 	movi	r5,1
81118b7c:	01204574 	movhi	r4,33045
81118b80:	212d2004 	addi	r4,r4,-19328
81118b84:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118b88:	0001883a 	nop
81118b8c:	e037883a 	mov	sp,fp
81118b90:	dfc00117 	ldw	ra,4(sp)
81118b94:	df000017 	ldw	fp,0(sp)
81118b98:	dec00204 	addi	sp,sp,8
81118b9c:	f800283a 	ret

81118ba0 <vCouldNotSendReset>:

void vCouldNotSendReset( void )
{
81118ba0:	defffe04 	addi	sp,sp,-8
81118ba4:	de00012e 	bgeu	sp,et,81118bac <vCouldNotSendReset+0xc>
81118ba8:	003b68fa 	trap	3
81118bac:	dfc00115 	stw	ra,4(sp)
81118bb0:	df000015 	stw	fp,0(sp)
81118bb4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendReset. (exit)\n");
81118bb8:	d0a05e17 	ldw	r2,-32392(gp)
81118bbc:	100f883a 	mov	r7,r2
81118bc0:	018006c4 	movi	r6,27
81118bc4:	01400044 	movi	r5,1
81118bc8:	01204574 	movhi	r4,33045
81118bcc:	212d2a04 	addi	r4,r4,-19288
81118bd0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the reset command. \n");
81118bd4:	d0a05e17 	ldw	r2,-32392(gp)
81118bd8:	100f883a 	mov	r7,r2
81118bdc:	018008c4 	movi	r6,35
81118be0:	01400044 	movi	r5,1
81118be4:	01204574 	movhi	r4,33045
81118be8:	212d3104 	addi	r4,r4,-19260
81118bec:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118bf0:	0001883a 	nop
81118bf4:	e037883a 	mov	sp,fp
81118bf8:	dfc00117 	ldw	ra,4(sp)
81118bfc:	df000017 	ldw	fp,0(sp)
81118c00:	dec00204 	addi	sp,sp,8
81118c04:	f800283a 	ret

81118c08 <vCouldNotSendLog>:

void vCouldNotSendLog( void )
{
81118c08:	defffe04 	addi	sp,sp,-8
81118c0c:	de00012e 	bgeu	sp,et,81118c14 <vCouldNotSendLog+0xc>
81118c10:	003b68fa 	trap	3
81118c14:	dfc00115 	stw	ra,4(sp)
81118c18:	df000015 	stw	fp,0(sp)
81118c1c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendLog. (exit)\n");
81118c20:	d0a05e17 	ldw	r2,-32392(gp)
81118c24:	100f883a 	mov	r7,r2
81118c28:	01800644 	movi	r6,25
81118c2c:	01400044 	movi	r5,1
81118c30:	01204574 	movhi	r4,33045
81118c34:	212d3a04 	addi	r4,r4,-19224
81118c38:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send log packet to NUC. \n");
81118c3c:	d0a05e17 	ldw	r2,-32392(gp)
81118c40:	100f883a 	mov	r7,r2
81118c44:	018008c4 	movi	r6,35
81118c48:	01400044 	movi	r5,1
81118c4c:	01204574 	movhi	r4,33045
81118c50:	212d4104 	addi	r4,r4,-19196
81118c54:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118c58:	0001883a 	nop
81118c5c:	e037883a 	mov	sp,fp
81118c60:	dfc00117 	ldw	ra,4(sp)
81118c64:	df000017 	ldw	fp,0(sp)
81118c68:	dec00204 	addi	sp,sp,8
81118c6c:	f800283a 	ret

81118c70 <vCouldNotSendTMPusCommand>:


void vCouldNotSendTMPusCommand( const char *cData )
{
81118c70:	defffd04 	addi	sp,sp,-12
81118c74:	de00012e 	bgeu	sp,et,81118c7c <vCouldNotSendTMPusCommand+0xc>
81118c78:	003b68fa 	trap	3
81118c7c:	dfc00215 	stw	ra,8(sp)
81118c80:	df000115 	stw	fp,4(sp)
81118c84:	df000104 	addi	fp,sp,4
81118c88:	e13fff15 	stw	r4,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotSendTMPusCommand. (exit)\n");
81118c8c:	d0a05e17 	ldw	r2,-32392(gp)
81118c90:	100f883a 	mov	r7,r2
81118c94:	01800884 	movi	r6,34
81118c98:	01400044 	movi	r5,1
81118c9c:	01204574 	movhi	r4,33045
81118ca0:	212d4a04 	addi	r4,r4,-19160
81118ca4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not send the TM PUS command to NUC. \n");
81118ca8:	d0a05e17 	ldw	r2,-32392(gp)
81118cac:	100f883a 	mov	r7,r2
81118cb0:	01800ac4 	movi	r6,43
81118cb4:	01400044 	movi	r5,1
81118cb8:	01204574 	movhi	r4,33045
81118cbc:	212d5304 	addi	r4,r4,-19124
81118cc0:	111d0b40 	call	8111d0b4 <fwrite>
		debug(fp,"cData");
81118cc4:	d0a05e17 	ldw	r2,-32392(gp)
81118cc8:	100f883a 	mov	r7,r2
81118ccc:	01800144 	movi	r6,5
81118cd0:	01400044 	movi	r5,1
81118cd4:	01204574 	movhi	r4,33045
81118cd8:	212d5e04 	addi	r4,r4,-19080
81118cdc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ce0:	0001883a 	nop
81118ce4:	e037883a 	mov	sp,fp
81118ce8:	dfc00117 	ldw	ra,4(sp)
81118cec:	df000017 	ldw	fp,0(sp)
81118cf0:	dec00204 	addi	sp,sp,8
81118cf4:	f800283a 	ret

81118cf8 <vWarnCouldNotgetMutexRetrans128>:

/* Not send message is bad but the Simucam will continue to work. */
void vWarnCouldNotgetMutexRetrans128( void )
{
81118cf8:	defffe04 	addi	sp,sp,-8
81118cfc:	de00012e 	bgeu	sp,et,81118d04 <vWarnCouldNotgetMutexRetrans128+0xc>
81118d00:	003b68fa 	trap	3
81118d04:	dfc00115 	stw	ra,4(sp)
81118d08:	df000015 	stw	fp,0(sp)
81118d0c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vWarnCouldNotgetMutexRetrans128. (exit)\n");
81118d10:	d0a05e17 	ldw	r2,-32392(gp)
81118d14:	100f883a 	mov	r7,r2
81118d18:	01800a04 	movi	r6,40
81118d1c:	01400044 	movi	r5,1
81118d20:	01204574 	movhi	r4,33045
81118d24:	212d6004 	addi	r4,r4,-19072
81118d28:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Warning: Could not get the mutex for the retransmission. The message will be lost.\n");
81118d2c:	d0a05e17 	ldw	r2,-32392(gp)
81118d30:	100f883a 	mov	r7,r2
81118d34:	018014c4 	movi	r6,83
81118d38:	01400044 	movi	r5,1
81118d3c:	01204574 	movhi	r4,33045
81118d40:	212d6b04 	addi	r4,r4,-19028
81118d44:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118d48:	0001883a 	nop
81118d4c:	e037883a 	mov	sp,fp
81118d50:	dfc00117 	ldw	ra,4(sp)
81118d54:	df000017 	ldw	fp,0(sp)
81118d58:	dec00204 	addi	sp,sp,8
81118d5c:	f800283a 	ret

81118d60 <vFailCreateScheduleQueue>:


/* CRITICAL. */
void vFailCreateScheduleQueue( void )
{
81118d60:	defffe04 	addi	sp,sp,-8
81118d64:	de00012e 	bgeu	sp,et,81118d6c <vFailCreateScheduleQueue+0xc>
81118d68:	003b68fa 	trap	3
81118d6c:	dfc00115 	stw	ra,4(sp)
81118d70:	df000015 	stw	fp,0(sp)
81118d74:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateScheduleQueue. (exit)\n");
81118d78:	d0a05e17 	ldw	r2,-32392(gp)
81118d7c:	100f883a 	mov	r7,r2
81118d80:	01800844 	movi	r6,33
81118d84:	01400044 	movi	r5,1
81118d88:	01204574 	movhi	r4,33045
81118d8c:	212d8004 	addi	r4,r4,-18944
81118d90:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: Could not create the Queue to shcedule the access to the DMA.\n");
81118d94:	d0a05e17 	ldw	r2,-32392(gp)
81118d98:	100f883a 	mov	r7,r2
81118d9c:	01801204 	movi	r6,72
81118da0:	01400044 	movi	r5,1
81118da4:	01204574 	movhi	r4,33045
81118da8:	212d8904 	addi	r4,r4,-18908
81118dac:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118db0:	0001883a 	nop
81118db4:	e037883a 	mov	sp,fp
81118db8:	dfc00117 	ldw	ra,4(sp)
81118dbc:	df000017 	ldw	fp,0(sp)
81118dc0:	dec00204 	addi	sp,sp,8
81118dc4:	f800283a 	ret

81118dc8 <vFailCreateNFEEQueue>:

/* CRITICAL. */
void vFailCreateNFEEQueue( unsigned char ucID )
{
81118dc8:	defffd04 	addi	sp,sp,-12
81118dcc:	de00012e 	bgeu	sp,et,81118dd4 <vFailCreateNFEEQueue+0xc>
81118dd0:	003b68fa 	trap	3
81118dd4:	dfc00215 	stw	ra,8(sp)
81118dd8:	df000115 	stw	fp,4(sp)
81118ddc:	df000104 	addi	fp,sp,4
81118de0:	2005883a 	mov	r2,r4
81118de4:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEEQueue. (exit)\n");
81118de8:	d0a05e17 	ldw	r2,-32392(gp)
81118dec:	100f883a 	mov	r7,r2
81118df0:	01800744 	movi	r6,29
81118df4:	01400044 	movi	r5,1
81118df8:	01204574 	movhi	r4,33045
81118dfc:	212d9c04 	addi	r4,r4,-18832
81118e00:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NSEE %hhu.\n",ucID);
81118e04:	d0a05e17 	ldw	r2,-32392(gp)
81118e08:	e0ffff03 	ldbu	r3,-4(fp)
81118e0c:	180d883a 	mov	r6,r3
81118e10:	01604574 	movhi	r5,33045
81118e14:	296da404 	addi	r5,r5,-18800
81118e18:	1009883a 	mov	r4,r2
81118e1c:	111dde00 	call	8111dde0 <printf>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118e20:	0001883a 	nop
81118e24:	e037883a 	mov	sp,fp
81118e28:	dfc00117 	ldw	ra,4(sp)
81118e2c:	df000017 	ldw	fp,0(sp)
81118e30:	dec00204 	addi	sp,sp,8
81118e34:	f800283a 	ret

81118e38 <vFailCreateNFEESyncQueue>:

/* CRITICAL. */
void vFailCreateNFEESyncQueue( unsigned char ucID )
{
81118e38:	defffd04 	addi	sp,sp,-12
81118e3c:	de00012e 	bgeu	sp,et,81118e44 <vFailCreateNFEESyncQueue+0xc>
81118e40:	003b68fa 	trap	3
81118e44:	dfc00215 	stw	ra,8(sp)
81118e48:	df000115 	stw	fp,4(sp)
81118e4c:	df000104 	addi	fp,sp,4
81118e50:	2005883a 	mov	r2,r4
81118e54:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateNFEESyncQueue. (exit)\n");
81118e58:	d0a05e17 	ldw	r2,-32392(gp)
81118e5c:	100f883a 	mov	r7,r2
81118e60:	01800844 	movi	r6,33
81118e64:	01400044 	movi	r5,1
81118e68:	01204574 	movhi	r4,33045
81118e6c:	212db204 	addi	r4,r4,-18744
81118e70:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		printf(fp,"CRITICAL: Could not create the Queue to the NFEE %hhu.\n",ucID);
81118e74:	d0a05e17 	ldw	r2,-32392(gp)
81118e78:	e0ffff03 	ldbu	r3,-4(fp)
81118e7c:	180d883a 	mov	r6,r3
81118e80:	01604574 	movhi	r5,33045
81118e84:	296dbb04 	addi	r5,r5,-18708
81118e88:	1009883a 	mov	r4,r2
81118e8c:	111dde00 	call	8111dde0 <printf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118e90:	0001883a 	nop
81118e94:	e037883a 	mov	sp,fp
81118e98:	dfc00117 	ldw	ra,4(sp)
81118e9c:	df000017 	ldw	fp,0(sp)
81118ea0:	dec00204 	addi	sp,sp,8
81118ea4:	f800283a 	ret

81118ea8 <vCoudlNotCreateNFee0Task>:

void vCoudlNotCreateNFee0Task( void )
{
81118ea8:	defffe04 	addi	sp,sp,-8
81118eac:	de00012e 	bgeu	sp,et,81118eb4 <vCoudlNotCreateNFee0Task+0xc>
81118eb0:	003b68fa 	trap	3
81118eb4:	dfc00115 	stw	ra,4(sp)
81118eb8:	df000015 	stw	fp,0(sp)
81118ebc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee0Task. (exit)\n");
81118ec0:	d0a05e17 	ldw	r2,-32392(gp)
81118ec4:	100f883a 	mov	r7,r2
81118ec8:	01800844 	movi	r6,33
81118ecc:	01400044 	movi	r5,1
81118ed0:	01204574 	movhi	r4,33045
81118ed4:	212dc904 	addi	r4,r4,-18652
81118ed8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 0 Task.\n");
81118edc:	d0a05e17 	ldw	r2,-32392(gp)
81118ee0:	100f883a 	mov	r7,r2
81118ee4:	01800784 	movi	r6,30
81118ee8:	01400044 	movi	r5,1
81118eec:	01204574 	movhi	r4,33045
81118ef0:	212dd204 	addi	r4,r4,-18616
81118ef4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118ef8:	0001883a 	nop
81118efc:	e037883a 	mov	sp,fp
81118f00:	dfc00117 	ldw	ra,4(sp)
81118f04:	df000017 	ldw	fp,0(sp)
81118f08:	dec00204 	addi	sp,sp,8
81118f0c:	f800283a 	ret

81118f10 <vCoudlNotCreateNFee1Task>:


void vCoudlNotCreateNFee1Task( void )
{
81118f10:	defffe04 	addi	sp,sp,-8
81118f14:	de00012e 	bgeu	sp,et,81118f1c <vCoudlNotCreateNFee1Task+0xc>
81118f18:	003b68fa 	trap	3
81118f1c:	dfc00115 	stw	ra,4(sp)
81118f20:	df000015 	stw	fp,0(sp)
81118f24:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee1Task. (exit)\n");
81118f28:	d0a05e17 	ldw	r2,-32392(gp)
81118f2c:	100f883a 	mov	r7,r2
81118f30:	01800844 	movi	r6,33
81118f34:	01400044 	movi	r5,1
81118f38:	01204574 	movhi	r4,33045
81118f3c:	212dda04 	addi	r4,r4,-18584
81118f40:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 1 Task.\n");
81118f44:	d0a05e17 	ldw	r2,-32392(gp)
81118f48:	100f883a 	mov	r7,r2
81118f4c:	01800784 	movi	r6,30
81118f50:	01400044 	movi	r5,1
81118f54:	01204574 	movhi	r4,33045
81118f58:	212de304 	addi	r4,r4,-18548
81118f5c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118f60:	0001883a 	nop
81118f64:	e037883a 	mov	sp,fp
81118f68:	dfc00117 	ldw	ra,4(sp)
81118f6c:	df000017 	ldw	fp,0(sp)
81118f70:	dec00204 	addi	sp,sp,8
81118f74:	f800283a 	ret

81118f78 <vCoudlNotCreateNFee2Task>:

void vCoudlNotCreateNFee2Task( void )
{
81118f78:	defffe04 	addi	sp,sp,-8
81118f7c:	de00012e 	bgeu	sp,et,81118f84 <vCoudlNotCreateNFee2Task+0xc>
81118f80:	003b68fa 	trap	3
81118f84:	dfc00115 	stw	ra,4(sp)
81118f88:	df000015 	stw	fp,0(sp)
81118f8c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee2Task. (exit)\n");
81118f90:	d0a05e17 	ldw	r2,-32392(gp)
81118f94:	100f883a 	mov	r7,r2
81118f98:	01800844 	movi	r6,33
81118f9c:	01400044 	movi	r5,1
81118fa0:	01204574 	movhi	r4,33045
81118fa4:	212deb04 	addi	r4,r4,-18516
81118fa8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 2 Task.\n");
81118fac:	d0a05e17 	ldw	r2,-32392(gp)
81118fb0:	100f883a 	mov	r7,r2
81118fb4:	01800784 	movi	r6,30
81118fb8:	01400044 	movi	r5,1
81118fbc:	01204574 	movhi	r4,33045
81118fc0:	212df404 	addi	r4,r4,-18480
81118fc4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81118fc8:	0001883a 	nop
81118fcc:	e037883a 	mov	sp,fp
81118fd0:	dfc00117 	ldw	ra,4(sp)
81118fd4:	df000017 	ldw	fp,0(sp)
81118fd8:	dec00204 	addi	sp,sp,8
81118fdc:	f800283a 	ret

81118fe0 <vCoudlNotCreateNFee3Task>:

void vCoudlNotCreateNFee3Task( void )
{
81118fe0:	defffe04 	addi	sp,sp,-8
81118fe4:	de00012e 	bgeu	sp,et,81118fec <vCoudlNotCreateNFee3Task+0xc>
81118fe8:	003b68fa 	trap	3
81118fec:	dfc00115 	stw	ra,4(sp)
81118ff0:	df000015 	stw	fp,0(sp)
81118ff4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee3Task. (exit)\n");
81118ff8:	d0a05e17 	ldw	r2,-32392(gp)
81118ffc:	100f883a 	mov	r7,r2
81119000:	01800844 	movi	r6,33
81119004:	01400044 	movi	r5,1
81119008:	01204574 	movhi	r4,33045
8111900c:	212dfc04 	addi	r4,r4,-18448
81119010:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 3 Task.\n");
81119014:	d0a05e17 	ldw	r2,-32392(gp)
81119018:	100f883a 	mov	r7,r2
8111901c:	01800784 	movi	r6,30
81119020:	01400044 	movi	r5,1
81119024:	01204574 	movhi	r4,33045
81119028:	212e0504 	addi	r4,r4,-18412
8111902c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119030:	0001883a 	nop
81119034:	e037883a 	mov	sp,fp
81119038:	dfc00117 	ldw	ra,4(sp)
8111903c:	df000017 	ldw	fp,0(sp)
81119040:	dec00204 	addi	sp,sp,8
81119044:	f800283a 	ret

81119048 <vCoudlNotCreateNFee4Task>:

void vCoudlNotCreateNFee4Task( void )
{
81119048:	defffe04 	addi	sp,sp,-8
8111904c:	de00012e 	bgeu	sp,et,81119054 <vCoudlNotCreateNFee4Task+0xc>
81119050:	003b68fa 	trap	3
81119054:	dfc00115 	stw	ra,4(sp)
81119058:	df000015 	stw	fp,0(sp)
8111905c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee4Task. (exit)\n");
81119060:	d0a05e17 	ldw	r2,-32392(gp)
81119064:	100f883a 	mov	r7,r2
81119068:	01800844 	movi	r6,33
8111906c:	01400044 	movi	r5,1
81119070:	01204574 	movhi	r4,33045
81119074:	212e0d04 	addi	r4,r4,-18380
81119078:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 4 Task.\n");
8111907c:	d0a05e17 	ldw	r2,-32392(gp)
81119080:	100f883a 	mov	r7,r2
81119084:	01800784 	movi	r6,30
81119088:	01400044 	movi	r5,1
8111908c:	01204574 	movhi	r4,33045
81119090:	212e1604 	addi	r4,r4,-18344
81119094:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119098:	0001883a 	nop
8111909c:	e037883a 	mov	sp,fp
811190a0:	dfc00117 	ldw	ra,4(sp)
811190a4:	df000017 	ldw	fp,0(sp)
811190a8:	dec00204 	addi	sp,sp,8
811190ac:	f800283a 	ret

811190b0 <vCoudlNotCreateNFee5Task>:

void vCoudlNotCreateNFee5Task( void )
{
811190b0:	defffe04 	addi	sp,sp,-8
811190b4:	de00012e 	bgeu	sp,et,811190bc <vCoudlNotCreateNFee5Task+0xc>
811190b8:	003b68fa 	trap	3
811190bc:	dfc00115 	stw	ra,4(sp)
811190c0:	df000015 	stw	fp,0(sp)
811190c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFee5Task. (exit)\n");
811190c8:	d0a05e17 	ldw	r2,-32392(gp)
811190cc:	100f883a 	mov	r7,r2
811190d0:	01800844 	movi	r6,33
811190d4:	01400044 	movi	r5,1
811190d8:	01204574 	movhi	r4,33045
811190dc:	212e1e04 	addi	r4,r4,-18312
811190e0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE 5 Task.\n");
811190e4:	d0a05e17 	ldw	r2,-32392(gp)
811190e8:	100f883a 	mov	r7,r2
811190ec:	01800784 	movi	r6,30
811190f0:	01400044 	movi	r5,1
811190f4:	01204574 	movhi	r4,33045
811190f8:	212e2704 	addi	r4,r4,-18276
811190fc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119100:	0001883a 	nop
81119104:	e037883a 	mov	sp,fp
81119108:	dfc00117 	ldw	ra,4(sp)
8111910c:	df000017 	ldw	fp,0(sp)
81119110:	dec00204 	addi	sp,sp,8
81119114:	f800283a 	ret

81119118 <vCoudlNotCreateNFeeControllerTask>:


void vCoudlNotCreateNFeeControllerTask( void )
{
81119118:	defffe04 	addi	sp,sp,-8
8111911c:	de00012e 	bgeu	sp,et,81119124 <vCoudlNotCreateNFeeControllerTask+0xc>
81119120:	003b68fa 	trap	3
81119124:	dfc00115 	stw	ra,4(sp)
81119128:	df000015 	stw	fp,0(sp)
8111912c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateNFeeControllerTask. (exit)\n");
81119130:	d0a05e17 	ldw	r2,-32392(gp)
81119134:	100f883a 	mov	r7,r2
81119138:	01800a84 	movi	r6,42
8111913c:	01400044 	movi	r5,1
81119140:	01204574 	movhi	r4,33045
81119144:	212e2f04 	addi	r4,r4,-18244
81119148:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create NFEE Controller Task.\n");
8111914c:	d0a05e17 	ldw	r2,-32392(gp)
81119150:	100f883a 	mov	r7,r2
81119154:	018009c4 	movi	r6,39
81119158:	01400044 	movi	r5,1
8111915c:	01204574 	movhi	r4,33045
81119160:	212e3a04 	addi	r4,r4,-18200
81119164:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119168:	0001883a 	nop
8111916c:	e037883a 	mov	sp,fp
81119170:	dfc00117 	ldw	ra,4(sp)
81119174:	df000017 	ldw	fp,0(sp)
81119178:	dec00204 	addi	sp,sp,8
8111917c:	f800283a 	ret

81119180 <vCoudlNotCreateDataControllerTask>:


void vCoudlNotCreateDataControllerTask( void )
{
81119180:	defffe04 	addi	sp,sp,-8
81119184:	de00012e 	bgeu	sp,et,8111918c <vCoudlNotCreateDataControllerTask+0xc>
81119188:	003b68fa 	trap	3
8111918c:	dfc00115 	stw	ra,4(sp)
81119190:	df000015 	stw	fp,0(sp)
81119194:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateDataControllerTask. (exit)\n");
81119198:	d0a05e17 	ldw	r2,-32392(gp)
8111919c:	100f883a 	mov	r7,r2
811191a0:	01800a84 	movi	r6,42
811191a4:	01400044 	movi	r5,1
811191a8:	01204574 	movhi	r4,33045
811191ac:	212e4404 	addi	r4,r4,-18160
811191b0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Data Controller Task.\n");
811191b4:	d0a05e17 	ldw	r2,-32392(gp)
811191b8:	100f883a 	mov	r7,r2
811191bc:	018009c4 	movi	r6,39
811191c0:	01400044 	movi	r5,1
811191c4:	01204574 	movhi	r4,33045
811191c8:	212e4f04 	addi	r4,r4,-18116
811191cc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811191d0:	0001883a 	nop
811191d4:	e037883a 	mov	sp,fp
811191d8:	dfc00117 	ldw	ra,4(sp)
811191dc:	df000017 	ldw	fp,0(sp)
811191e0:	dec00204 	addi	sp,sp,8
811191e4:	f800283a 	ret

811191e8 <vCoudlNotCreateMebTask>:


void vCoudlNotCreateMebTask( void )
{
811191e8:	defffe04 	addi	sp,sp,-8
811191ec:	de00012e 	bgeu	sp,et,811191f4 <vCoudlNotCreateMebTask+0xc>
811191f0:	003b68fa 	trap	3
811191f4:	dfc00115 	stw	ra,4(sp)
811191f8:	df000015 	stw	fp,0(sp)
811191fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCoudlNotCreateMebTask. (exit)\n");
81119200:	d0a05e17 	ldw	r2,-32392(gp)
81119204:	100f883a 	mov	r7,r2
81119208:	018007c4 	movi	r6,31
8111920c:	01400044 	movi	r5,1
81119210:	01204574 	movhi	r4,33045
81119214:	212e5904 	addi	r4,r4,-18076
81119218:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not create Meb Task.\n");
8111921c:	d0a05e17 	ldw	r2,-32392(gp)
81119220:	100f883a 	mov	r7,r2
81119224:	018006c4 	movi	r6,27
81119228:	01400044 	movi	r5,1
8111922c:	01204574 	movhi	r4,33045
81119230:	212e6104 	addi	r4,r4,-18044
81119234:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119238:	0001883a 	nop
8111923c:	e037883a 	mov	sp,fp
81119240:	dfc00117 	ldw	ra,4(sp)
81119244:	df000017 	ldw	fp,0(sp)
81119248:	dec00204 	addi	sp,sp,8
8111924c:	f800283a 	ret

81119250 <vFailCreateMutexSPUSQueueMeb>:


void vFailCreateMutexSPUSQueueMeb( INT8U error_code )
{
81119250:	defffd04 	addi	sp,sp,-12
81119254:	de00012e 	bgeu	sp,et,8111925c <vFailCreateMutexSPUSQueueMeb+0xc>
81119258:	003b68fa 	trap	3
8111925c:	dfc00215 	stw	ra,8(sp)
81119260:	df000115 	stw	fp,4(sp)
81119264:	df000104 	addi	fp,sp,4
81119268:	2005883a 	mov	r2,r4
8111926c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		debug(fp,"vFailCreateMutexSPUSQueueMeb. (exit)\n");
81119270:	d0a05e17 	ldw	r2,-32392(gp)
81119274:	100f883a 	mov	r7,r2
81119278:	01800944 	movi	r6,37
8111927c:	01400044 	movi	r5,1
81119280:	01204574 	movhi	r4,33045
81119284:	212e6804 	addi	r4,r4,-18016
81119288:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	#ifdef DEBUG_ON
		printErrorTask(error_code);
8111928c:	e0bfff03 	ldbu	r2,-4(fp)
81119290:	1009883a 	mov	r4,r2
81119294:	11179fc0 	call	811179fc <printErrorTask>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119298:	0001883a 	nop
8111929c:	e037883a 	mov	sp,fp
811192a0:	dfc00117 	ldw	ra,4(sp)
811192a4:	df000017 	ldw	fp,0(sp)
811192a8:	dec00204 	addi	sp,sp,8
811192ac:	f800283a 	ret

811192b0 <vFailSendPUStoMebTask>:

void vFailSendPUStoMebTask( void )
{
811192b0:	defffe04 	addi	sp,sp,-8
811192b4:	de00012e 	bgeu	sp,et,811192bc <vFailSendPUStoMebTask+0xc>
811192b8:	003b68fa 	trap	3
811192bc:	dfc00115 	stw	ra,4(sp)
811192c0:	df000015 	stw	fp,0(sp)
811192c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendPUStoMebTask. (exit)\n");
811192c8:	d0a05e17 	ldw	r2,-32392(gp)
811192cc:	100f883a 	mov	r7,r2
811192d0:	01800784 	movi	r6,30
811192d4:	01400044 	movi	r5,1
811192d8:	01204574 	movhi	r4,33045
811192dc:	212e7204 	addi	r4,r4,-17976
811192e0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811192e4:	0001883a 	nop
811192e8:	e037883a 	mov	sp,fp
811192ec:	dfc00117 	ldw	ra,4(sp)
811192f0:	df000017 	ldw	fp,0(sp)
811192f4:	dec00204 	addi	sp,sp,8
811192f8:	f800283a 	ret

811192fc <vCouldNotGetCmdQueueMeb>:

void vCouldNotGetCmdQueueMeb( void )
{
811192fc:	defffe04 	addi	sp,sp,-8
81119300:	de00012e 	bgeu	sp,et,81119308 <vCouldNotGetCmdQueueMeb+0xc>
81119304:	003b68fa 	trap	3
81119308:	dfc00115 	stw	ra,4(sp)
8111930c:	df000015 	stw	fp,0(sp)
81119310:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vCouldNotGetCmdQueueMeb. (exit)\n");
81119314:	d0a05e17 	ldw	r2,-32392(gp)
81119318:	100f883a 	mov	r7,r2
8111931c:	01800a84 	movi	r6,42
81119320:	01400044 	movi	r5,1
81119324:	01204574 	movhi	r4,33045
81119328:	212e7a04 	addi	r4,r4,-17944
8111932c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get COmmand from Queue in the Meb Task. \n");
81119330:	d0a05e17 	ldw	r2,-32392(gp)
81119334:	100f883a 	mov	r7,r2
81119338:	01800cc4 	movi	r6,51
8111933c:	01400044 	movi	r5,1
81119340:	01204574 	movhi	r4,33045
81119344:	212e8504 	addi	r4,r4,-17900
81119348:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111934c:	0001883a 	nop
81119350:	e037883a 	mov	sp,fp
81119354:	dfc00117 	ldw	ra,4(sp)
81119358:	df000017 	ldw	fp,0(sp)
8111935c:	dec00204 	addi	sp,sp,8
81119360:	f800283a 	ret

81119364 <vCouldNotGetMutexMebPus>:


void vCouldNotGetMutexMebPus( void )
{
81119364:	defffe04 	addi	sp,sp,-8
81119368:	de00012e 	bgeu	sp,et,81119370 <vCouldNotGetMutexMebPus+0xc>
8111936c:	003b68fa 	trap	3
81119370:	dfc00115 	stw	ra,4(sp)
81119374:	df000015 	stw	fp,0(sp)
81119378:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetMutexMebPus. (exit)\n");
8111937c:	d0a05e17 	ldw	r2,-32392(gp)
81119380:	100f883a 	mov	r7,r2
81119384:	01800804 	movi	r6,32
81119388:	01400044 	movi	r5,1
8111938c:	01204574 	movhi	r4,33045
81119390:	212e9204 	addi	r4,r4,-17848
81119394:	111d0b40 	call	8111d0b4 <fwrite>
	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119398:	0001883a 	nop
8111939c:	e037883a 	mov	sp,fp
811193a0:	dfc00117 	ldw	ra,4(sp)
811193a4:	df000017 	ldw	fp,0(sp)
811193a8:	dec00204 	addi	sp,sp,8
811193ac:	f800283a 	ret

811193b0 <vCouldNotCreateQueueMaskNfeeCtrl>:

void vCouldNotCreateQueueMaskNfeeCtrl( void )
{
811193b0:	defffe04 	addi	sp,sp,-8
811193b4:	de00012e 	bgeu	sp,et,811193bc <vCouldNotCreateQueueMaskNfeeCtrl+0xc>
811193b8:	003b68fa 	trap	3
811193bc:	dfc00115 	stw	ra,4(sp)
811193c0:	df000015 	stw	fp,0(sp)
811193c4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskNfeeCtrl. (exit)\n");
811193c8:	d0a05e17 	ldw	r2,-32392(gp)
811193cc:	100f883a 	mov	r7,r2
811193d0:	01800a44 	movi	r6,41
811193d4:	01400044 	movi	r5,1
811193d8:	01204574 	movhi	r4,33045
811193dc:	212e9b04 	addi	r4,r4,-17812
811193e0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for NFEE Controller. \n");
811193e4:	d0a05e17 	ldw	r2,-32392(gp)
811193e8:	100f883a 	mov	r7,r2
811193ec:	01800c84 	movi	r6,50
811193f0:	01400044 	movi	r5,1
811193f4:	01204574 	movhi	r4,33045
811193f8:	212ea604 	addi	r4,r4,-17768
811193fc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119400:	0001883a 	nop
81119404:	e037883a 	mov	sp,fp
81119408:	dfc00117 	ldw	ra,4(sp)
8111940c:	df000017 	ldw	fp,0(sp)
81119410:	dec00204 	addi	sp,sp,8
81119414:	f800283a 	ret

81119418 <vCouldNotCreateQueueMaskDataCtrl>:

void vCouldNotCreateQueueMaskDataCtrl( void )
{
81119418:	defffe04 	addi	sp,sp,-8
8111941c:	de00012e 	bgeu	sp,et,81119424 <vCouldNotCreateQueueMaskDataCtrl+0xc>
81119420:	003b68fa 	trap	3
81119424:	dfc00115 	stw	ra,4(sp)
81119428:	df000015 	stw	fp,0(sp)
8111942c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotCreateQueueMaskDataCtrl. (exit)\n");
81119430:	d0a05e17 	ldw	r2,-32392(gp)
81119434:	100f883a 	mov	r7,r2
81119438:	01800a44 	movi	r6,41
8111943c:	01400044 	movi	r5,1
81119440:	01204574 	movhi	r4,33045
81119444:	212eb304 	addi	r4,r4,-17716
81119448:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not Create Queue Mask for Data Controller. \n");
8111944c:	d0a05e17 	ldw	r2,-32392(gp)
81119450:	100f883a 	mov	r7,r2
81119454:	01800c84 	movi	r6,50
81119458:	01400044 	movi	r5,1
8111945c:	01204574 	movhi	r4,33045
81119460:	212ebe04 	addi	r4,r4,-17672
81119464:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119468:	0001883a 	nop
8111946c:	e037883a 	mov	sp,fp
81119470:	dfc00117 	ldw	ra,4(sp)
81119474:	df000017 	ldw	fp,0(sp)
81119478:	dec00204 	addi	sp,sp,8
8111947c:	f800283a 	ret

81119480 <vCouldNotGetQueueMaskNfeeCtrl>:

void vCouldNotGetQueueMaskNfeeCtrl( void )
{
81119480:	defffe04 	addi	sp,sp,-8
81119484:	de00012e 	bgeu	sp,et,8111948c <vCouldNotGetQueueMaskNfeeCtrl+0xc>
81119488:	003b68fa 	trap	3
8111948c:	dfc00115 	stw	ra,4(sp)
81119490:	df000015 	stw	fp,0(sp)
81119494:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskNfeeCtrl. (exit)\n");
81119498:	d0a05e17 	ldw	r2,-32392(gp)
8111949c:	100f883a 	mov	r7,r2
811194a0:	01800984 	movi	r6,38
811194a4:	01400044 	movi	r5,1
811194a8:	01204574 	movhi	r4,33045
811194ac:	212ecb04 	addi	r4,r4,-17620
811194b0:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for NFEE Controller. \n");
811194b4:	d0a05e17 	ldw	r2,-32392(gp)
811194b8:	100f883a 	mov	r7,r2
811194bc:	01800bc4 	movi	r6,47
811194c0:	01400044 	movi	r5,1
811194c4:	01204574 	movhi	r4,33045
811194c8:	212ed504 	addi	r4,r4,-17580
811194cc:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811194d0:	0001883a 	nop
811194d4:	e037883a 	mov	sp,fp
811194d8:	dfc00117 	ldw	ra,4(sp)
811194dc:	df000017 	ldw	fp,0(sp)
811194e0:	dec00204 	addi	sp,sp,8
811194e4:	f800283a 	ret

811194e8 <vCouldNotGetQueueMaskDataCtrl>:

void vCouldNotGetQueueMaskDataCtrl( void )
{
811194e8:	defffe04 	addi	sp,sp,-8
811194ec:	de00012e 	bgeu	sp,et,811194f4 <vCouldNotGetQueueMaskDataCtrl+0xc>
811194f0:	003b68fa 	trap	3
811194f4:	dfc00115 	stw	ra,4(sp)
811194f8:	df000015 	stw	fp,0(sp)
811194fc:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vCouldNotGetQueueMaskDataCtrl. (exit)\n");
81119500:	d0a05e17 	ldw	r2,-32392(gp)
81119504:	100f883a 	mov	r7,r2
81119508:	01800984 	movi	r6,38
8111950c:	01400044 	movi	r5,1
81119510:	01204574 	movhi	r4,33045
81119514:	212ee104 	addi	r4,r4,-17532
81119518:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	#ifdef DEBUG_ON
		debug(fp,"Could not get Queue Mask for Data Controller. \n");
8111951c:	d0a05e17 	ldw	r2,-32392(gp)
81119520:	100f883a 	mov	r7,r2
81119524:	01800bc4 	movi	r6,47
81119528:	01400044 	movi	r5,1
8111952c:	01204574 	movhi	r4,33045
81119530:	212eeb04 	addi	r4,r4,-17492
81119534:	111d0b40 	call	8111d0b4 <fwrite>
	#endif	
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119538:	0001883a 	nop
8111953c:	e037883a 	mov	sp,fp
81119540:	dfc00117 	ldw	ra,4(sp)
81119544:	df000017 	ldw	fp,0(sp)
81119548:	dec00204 	addi	sp,sp,8
8111954c:	f800283a 	ret

81119550 <vFailSendMsgAccessDMA>:


void vFailSendMsgAccessDMA( unsigned char ucTemp)
{
81119550:	defffd04 	addi	sp,sp,-12
81119554:	de00012e 	bgeu	sp,et,8111955c <vFailSendMsgAccessDMA+0xc>
81119558:	003b68fa 	trap	3
8111955c:	dfc00215 	stw	ra,8(sp)
81119560:	df000115 	stw	fp,4(sp)
81119564:	df000104 	addi	fp,sp,4
81119568:	2005883a 	mov	r2,r4
8111956c:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgAccessDMA. FEE n: \n", ucTemp);
81119570:	d0a05e17 	ldw	r2,-32392(gp)
81119574:	e0ffff03 	ldbu	r3,-4(fp)
81119578:	180d883a 	mov	r6,r3
8111957c:	01604574 	movhi	r5,33045
81119580:	296ef704 	addi	r5,r5,-17444
81119584:	1009883a 	mov	r4,r2
81119588:	111ca180 	call	8111ca18 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111958c:	0001883a 	nop
81119590:	e037883a 	mov	sp,fp
81119594:	dfc00117 	ldw	ra,4(sp)
81119598:	df000017 	ldw	fp,0(sp)
8111959c:	dec00204 	addi	sp,sp,8
811195a0:	f800283a 	ret

811195a4 <vFailRequestDMA>:

void vFailRequestDMA( unsigned char ucTemp)
{
811195a4:	defffd04 	addi	sp,sp,-12
811195a8:	de00012e 	bgeu	sp,et,811195b0 <vFailRequestDMA+0xc>
811195ac:	003b68fa 	trap	3
811195b0:	dfc00215 	stw	ra,8(sp)
811195b4:	df000115 	stw	fp,4(sp)
811195b8:	df000104 	addi	fp,sp,4
811195bc:	2005883a 	mov	r2,r4
811195c0:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
811195c4:	d0a05e17 	ldw	r2,-32392(gp)
811195c8:	e0ffff03 	ldbu	r3,-4(fp)
811195cc:	180d883a 	mov	r6,r3
811195d0:	01604574 	movhi	r5,33045
811195d4:	296eff04 	addi	r5,r5,-17412
811195d8:	1009883a 	mov	r4,r2
811195dc:	111ca180 	call	8111ca18 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811195e0:	0001883a 	nop
811195e4:	e037883a 	mov	sp,fp
811195e8:	dfc00117 	ldw	ra,4(sp)
811195ec:	df000017 	ldw	fp,0(sp)
811195f0:	dec00204 	addi	sp,sp,8
811195f4:	f800283a 	ret

811195f8 <vFailRequestDMAFromIRQ>:

void vFailRequestDMAFromIRQ( unsigned char ucTemp)
{
811195f8:	defffd04 	addi	sp,sp,-12
811195fc:	de00012e 	bgeu	sp,et,81119604 <vFailRequestDMAFromIRQ+0xc>
81119600:	003b68fa 	trap	3
81119604:	dfc00215 	stw	ra,8(sp)
81119608:	df000115 	stw	fp,4(sp)
8111960c:	df000104 	addi	fp,sp,4
81119610:	2005883a 	mov	r2,r4
81119614:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailRequestDMA. FEE n: \n", ucTemp);
81119618:	d0a05e17 	ldw	r2,-32392(gp)
8111961c:	e0ffff03 	ldbu	r3,-4(fp)
81119620:	180d883a 	mov	r6,r3
81119624:	01604574 	movhi	r5,33045
81119628:	296eff04 	addi	r5,r5,-17412
8111962c:	1009883a 	mov	r4,r2
81119630:	111ca180 	call	8111ca18 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119634:	0001883a 	nop
81119638:	e037883a 	mov	sp,fp
8111963c:	dfc00117 	ldw	ra,4(sp)
81119640:	df000017 	ldw	fp,0(sp)
81119644:	dec00204 	addi	sp,sp,8
81119648:	f800283a 	ret

8111964c <vFailSendRMAPFromIRQ>:


void vFailSendRMAPFromIRQ( unsigned char ucTemp)
{
8111964c:	defffd04 	addi	sp,sp,-12
81119650:	de00012e 	bgeu	sp,et,81119658 <vFailSendRMAPFromIRQ+0xc>
81119654:	003b68fa 	trap	3
81119658:	dfc00215 	stw	ra,8(sp)
8111965c:	df000115 	stw	fp,4(sp)
81119660:	df000104 	addi	fp,sp,4
81119664:	2005883a 	mov	r2,r4
81119668:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendRMAPFromIRQ. FEE n: \n", ucTemp);
8111966c:	d0a05e17 	ldw	r2,-32392(gp)
81119670:	e0ffff03 	ldbu	r3,-4(fp)
81119674:	180d883a 	mov	r6,r3
81119678:	01604574 	movhi	r5,33045
8111967c:	296f0604 	addi	r5,r5,-17384
81119680:	1009883a 	mov	r4,r2
81119684:	111ca180 	call	8111ca18 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119688:	0001883a 	nop
8111968c:	e037883a 	mov	sp,fp
81119690:	dfc00117 	ldw	ra,4(sp)
81119694:	df000017 	ldw	fp,0(sp)
81119698:	dec00204 	addi	sp,sp,8
8111969c:	f800283a 	ret

811196a0 <vFailSendMsgSync>:


void vFailSendMsgSync( unsigned char ucTemp)
{
811196a0:	defffd04 	addi	sp,sp,-12
811196a4:	de00012e 	bgeu	sp,et,811196ac <vFailSendMsgSync+0xc>
811196a8:	003b68fa 	trap	3
811196ac:	dfc00215 	stw	ra,8(sp)
811196b0:	df000115 	stw	fp,4(sp)
811196b4:	df000104 	addi	fp,sp,4
811196b8:	2005883a 	mov	r2,r4
811196bc:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSync. FEE n: \n", ucTemp);
811196c0:	d0a05e17 	ldw	r2,-32392(gp)
811196c4:	e0ffff03 	ldbu	r3,-4(fp)
811196c8:	180d883a 	mov	r6,r3
811196cc:	01604574 	movhi	r5,33045
811196d0:	296f0e04 	addi	r5,r5,-17352
811196d4:	1009883a 	mov	r4,r2
811196d8:	111ca180 	call	8111ca18 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811196dc:	0001883a 	nop
811196e0:	e037883a 	mov	sp,fp
811196e4:	dfc00117 	ldw	ra,4(sp)
811196e8:	df000017 	ldw	fp,0(sp)
811196ec:	dec00204 	addi	sp,sp,8
811196f0:	f800283a 	ret

811196f4 <vFailSendMsgSyncRMAPTRIGGER>:

void vFailSendMsgSyncRMAPTRIGGER( unsigned char ucTemp)
{
811196f4:	defffd04 	addi	sp,sp,-12
811196f8:	de00012e 	bgeu	sp,et,81119700 <vFailSendMsgSyncRMAPTRIGGER+0xc>
811196fc:	003b68fa 	trap	3
81119700:	dfc00215 	stw	ra,8(sp)
81119704:	df000115 	stw	fp,4(sp)
81119708:	df000104 	addi	fp,sp,4
8111970c:	2005883a 	mov	r2,r4
81119710:	e0bfff05 	stb	r2,-4(fp)
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgSyncRMAPTRIGGER (FORCED MODE). FEE n: \n", ucTemp);
81119714:	d0a05e17 	ldw	r2,-32392(gp)
81119718:	e0ffff03 	ldbu	r3,-4(fp)
8111971c:	180d883a 	mov	r6,r3
81119720:	01604574 	movhi	r5,33045
81119724:	296f1504 	addi	r5,r5,-17324
81119728:	1009883a 	mov	r4,r2
8111972c:	111ca180 	call	8111ca18 <fprintf>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119730:	0001883a 	nop
81119734:	e037883a 	mov	sp,fp
81119738:	dfc00117 	ldw	ra,4(sp)
8111973c:	df000017 	ldw	fp,0(sp)
81119740:	dec00204 	addi	sp,sp,8
81119744:	f800283a 	ret

81119748 <vFailSendMsgMasterSyncMeb>:

void vFailSendMsgMasterSyncMeb( void )
{
81119748:	defffe04 	addi	sp,sp,-8
8111974c:	de00012e 	bgeu	sp,et,81119754 <vFailSendMsgMasterSyncMeb+0xc>
81119750:	003b68fa 	trap	3
81119754:	dfc00115 	stw	ra,4(sp)
81119758:	df000015 	stw	fp,0(sp)
8111975c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		fprintf(fp,"vFailSendMsgMasterSyncMeb \n");
81119760:	d0a05e17 	ldw	r2,-32392(gp)
81119764:	100f883a 	mov	r7,r2
81119768:	018006c4 	movi	r6,27
8111976c:	01400044 	movi	r5,1
81119770:	01204574 	movhi	r4,33045
81119774:	212f2204 	addi	r4,r4,-17272
81119778:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
8111977c:	0001883a 	nop
81119780:	e037883a 	mov	sp,fp
81119784:	dfc00117 	ldw	ra,4(sp)
81119788:	df000017 	ldw	fp,0(sp)
8111978c:	dec00204 	addi	sp,sp,8
81119790:	f800283a 	ret

81119794 <vFailSendMsgFeeCTRL>:

void vFailSendMsgFeeCTRL( void )
{
81119794:	defffe04 	addi	sp,sp,-8
81119798:	de00012e 	bgeu	sp,et,811197a0 <vFailSendMsgFeeCTRL+0xc>
8111979c:	003b68fa 	trap	3
811197a0:	dfc00115 	stw	ra,4(sp)
811197a4:	df000015 	stw	fp,0(sp)
811197a8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgFeeCTRL.  \n");
811197ac:	d0a05e17 	ldw	r2,-32392(gp)
811197b0:	100f883a 	mov	r7,r2
811197b4:	018005c4 	movi	r6,23
811197b8:	01400044 	movi	r5,1
811197bc:	01204574 	movhi	r4,33045
811197c0:	212f2904 	addi	r4,r4,-17244
811197c4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811197c8:	0001883a 	nop
811197cc:	e037883a 	mov	sp,fp
811197d0:	dfc00117 	ldw	ra,4(sp)
811197d4:	df000017 	ldw	fp,0(sp)
811197d8:	dec00204 	addi	sp,sp,8
811197dc:	f800283a 	ret

811197e0 <vFailSendMsgDataCTRL>:

void vFailSendMsgDataCTRL( void )
{
811197e0:	defffe04 	addi	sp,sp,-8
811197e4:	de00012e 	bgeu	sp,et,811197ec <vFailSendMsgDataCTRL+0xc>
811197e8:	003b68fa 	trap	3
811197ec:	dfc00115 	stw	ra,4(sp)
811197f0:	df000015 	stw	fp,0(sp)
811197f4:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"vFailSendMsgDataCTRL.  \n");
811197f8:	d0a05e17 	ldw	r2,-32392(gp)
811197fc:	100f883a 	mov	r7,r2
81119800:	01800604 	movi	r6,24
81119804:	01400044 	movi	r5,1
81119808:	01204574 	movhi	r4,33045
8111980c:	212f2f04 	addi	r4,r4,-17220
81119810:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119814:	0001883a 	nop
81119818:	e037883a 	mov	sp,fp
8111981c:	dfc00117 	ldw	ra,4(sp)
81119820:	df000017 	ldw	fp,0(sp)
81119824:	dec00204 	addi	sp,sp,8
81119828:	f800283a 	ret

8111982c <vFailFlushQueue>:

void vFailFlushQueue( void )
{
8111982c:	defffe04 	addi	sp,sp,-8
81119830:	de00012e 	bgeu	sp,et,81119838 <vFailFlushQueue+0xc>
81119834:	003b68fa 	trap	3
81119838:	dfc00115 	stw	ra,4(sp)
8111983c:	df000015 	stw	fp,0(sp)
81119840:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueue.  \n");
81119844:	d0a05e17 	ldw	r2,-32392(gp)
81119848:	100f883a 	mov	r7,r2
8111984c:	01800744 	movi	r6,29
81119850:	01400044 	movi	r5,1
81119854:	01204574 	movhi	r4,33045
81119858:	212f3604 	addi	r4,r4,-17192
8111985c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119860:	0001883a 	nop
81119864:	e037883a 	mov	sp,fp
81119868:	dfc00117 	ldw	ra,4(sp)
8111986c:	df000017 	ldw	fp,0(sp)
81119870:	dec00204 	addi	sp,sp,8
81119874:	f800283a 	ret

81119878 <vFailFlushQueueData>:

void vFailFlushQueueData( void )
{
81119878:	defffe04 	addi	sp,sp,-8
8111987c:	de00012e 	bgeu	sp,et,81119884 <vFailFlushQueueData+0xc>
81119880:	003b68fa 	trap	3
81119884:	dfc00115 	stw	ra,4(sp)
81119888:	df000015 	stw	fp,0(sp)
8111988c:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushQueueData.  \n");
81119890:	d0a05e17 	ldw	r2,-32392(gp)
81119894:	100f883a 	mov	r7,r2
81119898:	01800844 	movi	r6,33
8111989c:	01400044 	movi	r5,1
811198a0:	01204574 	movhi	r4,33045
811198a4:	212f3e04 	addi	r4,r4,-17160
811198a8:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811198ac:	0001883a 	nop
811198b0:	e037883a 	mov	sp,fp
811198b4:	dfc00117 	ldw	ra,4(sp)
811198b8:	df000017 	ldw	fp,0(sp)
811198bc:	dec00204 	addi	sp,sp,8
811198c0:	f800283a 	ret

811198c4 <vFailFlushMEBQueue>:


void vFailFlushMEBQueue( void )
{
811198c4:	defffe04 	addi	sp,sp,-8
811198c8:	de00012e 	bgeu	sp,et,811198d0 <vFailFlushMEBQueue+0xc>
811198cc:	003b68fa 	trap	3
811198d0:	dfc00115 	stw	ra,4(sp)
811198d4:	df000015 	stw	fp,0(sp)
811198d8:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushMEBQueue.  \n");
811198dc:	d0a05e17 	ldw	r2,-32392(gp)
811198e0:	100f883a 	mov	r7,r2
811198e4:	01800804 	movi	r6,32
811198e8:	01400044 	movi	r5,1
811198ec:	01204574 	movhi	r4,33045
811198f0:	212f4704 	addi	r4,r4,-17124
811198f4:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
811198f8:	0001883a 	nop
811198fc:	e037883a 	mov	sp,fp
81119900:	dfc00117 	ldw	ra,4(sp)
81119904:	df000017 	ldw	fp,0(sp)
81119908:	dec00204 	addi	sp,sp,8
8111990c:	f800283a 	ret

81119910 <vFailFlushNFEEQueue>:

void vFailFlushNFEEQueue( void )
{
81119910:	defffe04 	addi	sp,sp,-8
81119914:	de00012e 	bgeu	sp,et,8111991c <vFailFlushNFEEQueue+0xc>
81119918:	003b68fa 	trap	3
8111991c:	dfc00115 	stw	ra,4(sp)
81119920:	df000015 	stw	fp,0(sp)
81119924:	d839883a 	mov	fp,sp
	#ifdef DEBUG_ON
		debug(fp,"CRITICAL: vFailFlushNFEEQueue.  \n");
81119928:	d0a05e17 	ldw	r2,-32392(gp)
8111992c:	100f883a 	mov	r7,r2
81119930:	01800844 	movi	r6,33
81119934:	01400044 	movi	r5,1
81119938:	01204574 	movhi	r4,33045
8111993c:	212f5004 	addi	r4,r4,-17088
81119940:	111d0b40 	call	8111d0b4 <fwrite>
	#endif
	/*
	 * Implementao de indicao de falha antes de finalizar a execuo
	 * Indicar falha com LEDs pois  o unico HW inicializada at o momento
	 */
}
81119944:	0001883a 	nop
81119948:	e037883a 	mov	sp,fp
8111994c:	dfc00117 	ldw	ra,4(sp)
81119950:	df000017 	ldw	fp,0(sp)
81119954:	dec00204 	addi	sp,sp,8
81119958:	f800283a 	ret

8111995c <vEvtChangeMebMode>:


#include "events_handler.h"


void vEvtChangeMebMode( void ) {
8111995c:	deffff04 	addi	sp,sp,-4
81119960:	de00012e 	bgeu	sp,et,81119968 <vEvtChangeMebMode+0xc>
81119964:	003b68fa 	trap	3
81119968:	df000015 	stw	fp,0(sp)
8111996c:	d839883a 	mov	fp,sp

	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81119970:	0001883a 	nop
81119974:	e037883a 	mov	sp,fp
81119978:	df000017 	ldw	fp,0(sp)
8111997c:	dec00104 	addi	sp,sp,4
81119980:	f800283a 	ret

81119984 <vEvtChangeFeeControllerMode>:


void vEvtChangeFeeControllerMode( void ) {
81119984:	deffff04 	addi	sp,sp,-4
81119988:	de00012e 	bgeu	sp,et,81119990 <vEvtChangeFeeControllerMode+0xc>
8111998c:	003b68fa 	trap	3
81119990:	df000015 	stw	fp,0(sp)
81119994:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
81119998:	0001883a 	nop
8111999c:	e037883a 	mov	sp,fp
811199a0:	df000017 	ldw	fp,0(sp)
811199a4:	dec00104 	addi	sp,sp,4
811199a8:	f800283a 	ret

811199ac <vEvtChangeDataControllerMode>:


void vEvtChangeDataControllerMode( void ) {
811199ac:	deffff04 	addi	sp,sp,-4
811199b0:	de00012e 	bgeu	sp,et,811199b8 <vEvtChangeDataControllerMode+0xc>
811199b4:	003b68fa 	trap	3
811199b8:	df000015 	stw	fp,0(sp)
811199bc:	d839883a 	mov	fp,sp


	/*todo: Realizar qualquer acao relacionado ao evento: Sinalizacao com LED ou enviar pacote PUS caso cadastrado etc */
}
811199c0:	0001883a 	nop
811199c4:	e037883a 	mov	sp,fp
811199c8:	df000017 	ldw	fp,0(sp)
811199cc:	dec00104 	addi	sp,sp,4
811199d0:	f800283a 	ret

811199d4 <vNFeeNotInUse>:
 *      Author: Tiago-Low
 */

#include "fee.h"

void vNFeeNotInUse( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
811199d4:	defffd04 	addi	sp,sp,-12
811199d8:	de00012e 	bgeu	sp,et,811199e0 <vNFeeNotInUse+0xc>
811199dc:	003b68fa 	trap	3
811199e0:	df000215 	stw	fp,8(sp)
811199e4:	df000204 	addi	fp,sp,8
811199e8:	e13ffe15 	stw	r4,-8(fp)
811199ec:	2805883a 	mov	r2,r5
811199f0:	e0bfff05 	stb	r2,-4(fp)

    /* NFEE id [0..7] */
    pxNfeeL->ucId = ucIdNFEE;
811199f4:	e0bffe17 	ldw	r2,-8(fp)
811199f8:	e0ffff03 	ldbu	r3,-4(fp)
811199fc:	10c00005 	stb	r3,0(r2)
    pxNfeeL->xControl.bEnabled = FALSE;
81119a00:	e0bffe17 	ldw	r2,-8(fp)
81119a04:	10002115 	stw	zero,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81119a08:	e0bffe17 	ldw	r2,-8(fp)
81119a0c:	10002315 	stw	zero,140(r2)
}
81119a10:	0001883a 	nop
81119a14:	e037883a 	mov	sp,fp
81119a18:	df000017 	ldw	fp,0(sp)
81119a1c:	dec00104 	addi	sp,sp,4
81119a20:	f800283a 	ret

81119a24 <vNFeeStructureInit>:


/* Initialize the structure of control of NFEE with the default Configurations */
void vNFeeStructureInit( TNFee *pxNfeeL, unsigned char ucIdNFEE ) {
81119a24:	defffb04 	addi	sp,sp,-20
81119a28:	de00012e 	bgeu	sp,et,81119a30 <vNFeeStructureInit+0xc>
81119a2c:	003b68fa 	trap	3
81119a30:	dfc00415 	stw	ra,16(sp)
81119a34:	df000315 	stw	fp,12(sp)
81119a38:	df000304 	addi	fp,sp,12
81119a3c:	e13ffe15 	stw	r4,-8(fp)
81119a40:	2805883a 	mov	r2,r5
81119a44:	e0bfff05 	stb	r2,-4(fp)
    unsigned char ucIL = 0;
81119a48:	e03ffd05 	stb	zero,-12(fp)

    /* NFEE id [0..5] */
    pxNfeeL->ucId = ucIdNFEE;
81119a4c:	e0bffe17 	ldw	r2,-8(fp)
81119a50:	e0ffff03 	ldbu	r3,-4(fp)
81119a54:	10c00005 	stb	r3,0(r2)

    /* Load the default values of the CCDs regarding pixels configuration */
    vCCDLoadDefaultValues(&pxNfeeL->xCcdInfo);
81119a58:	e0bffe17 	ldw	r2,-8(fp)
81119a5c:	10802f04 	addi	r2,r2,188
81119a60:	1009883a 	mov	r4,r2
81119a64:	11156b80 	call	811156b8 <vCCDLoadDefaultValues>

    /* Update the values of memory mapping for this FEE */
    vUpdateMemMapFEE(pxNfeeL);
81119a68:	e13ffe17 	ldw	r4,-8(fp)
81119a6c:	1119b9c0 	call	81119b9c <vUpdateMemMapFEE>

    /* Initilizing control variables */
    pxNfeeL->xControl.bEnabled = TRUE;
81119a70:	e0bffe17 	ldw	r2,-8(fp)
81119a74:	00c00044 	movi	r3,1
81119a78:	10c02115 	stw	r3,132(r2)
    pxNfeeL->xControl.bUsingDMA = FALSE;
81119a7c:	e0bffe17 	ldw	r2,-8(fp)
81119a80:	10002315 	stw	zero,140(r2)
    pxNfeeL->xControl.bChannelEnable = FALSE;
81119a84:	e0bffe17 	ldw	r2,-8(fp)
81119a88:	10002615 	stw	zero,152(r2)
    pxNfeeL->xControl.bSimulating = FALSE;
81119a8c:	e0bffe17 	ldw	r2,-8(fp)
81119a90:	10002715 	stw	zero,156(r2)
    pxNfeeL->xControl.bWatingSync = FALSE;
81119a94:	e0bffe17 	ldw	r2,-8(fp)
81119a98:	10002815 	stw	zero,160(r2)
    pxNfeeL->xControl.bEchoing = FALSE;
81119a9c:	e0bffe17 	ldw	r2,-8(fp)
81119aa0:	10002515 	stw	zero,148(r2)
    pxNfeeL->xControl.bLogging = FALSE;
81119aa4:	e0bffe17 	ldw	r2,-8(fp)
81119aa8:	10002415 	stw	zero,144(r2)
    pxNfeeL->xControl.bDMALocked = FALSE;
81119aac:	e0bffe17 	ldw	r2,-8(fp)
81119ab0:	10002215 	stw	zero,136(r2)
    /* The default side is left */
    pxNfeeL->xControl.eSide = sLeft;
81119ab4:	e0bffe17 	ldw	r2,-8(fp)
81119ab8:	10002e15 	stw	zero,184(r2)
    pxNfeeL->xControl.ucTimeCode = 0;
81119abc:	e0bffe17 	ldw	r2,-8(fp)
81119ac0:	10002a05 	stb	zero,168(r2)
    

    /* The NFEE initialize in the Config mode by default */
    pxNfeeL->xControl.eMode = sFeeInit;
81119ac4:	e0bffe17 	ldw	r2,-8(fp)
81119ac8:	10002c15 	stw	zero,176(r2)
    pxNfeeL->xControl.eNextMode = sFeeInit;
81119acc:	e0bffe17 	ldw	r2,-8(fp)
81119ad0:	10002d15 	stw	zero,180(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81119ad4:	e03ffd05 	stb	zero,-12(fp)
81119ad8:	00000906 	br	81119b00 <vNFeeStructureInit+0xdc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;
81119adc:	e0bffd03 	ldbu	r2,-12(fp)
81119ae0:	e0fffe17 	ldw	r3,-8(fp)
81119ae4:	1885883a 	add	r2,r3,r2
81119ae8:	10802a44 	addi	r2,r2,169
81119aec:	e0fffd03 	ldbu	r3,-12(fp)
81119af0:	10c00005 	stb	r3,0(r2)

    /*  todo: This function supposed to load the values from a SD Card in the future, for now it will load
        hard coded values */
    //bLoadNFEEDefsSDCard(); !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    /* Set the default redout order [ 0, 1, 2, 3 ] */
    for ( ucIL = 0; ucIL < 4; ucIL++) 
81119af4:	e0bffd03 	ldbu	r2,-12(fp)
81119af8:	10800044 	addi	r2,r2,1
81119afc:	e0bffd05 	stb	r2,-12(fp)
81119b00:	e0bffd03 	ldbu	r2,-12(fp)
81119b04:	10800130 	cmpltui	r2,r2,4
81119b08:	103ff41e 	bne	r2,zero,81119adc <__reset+0xfb0f9adc>
        pxNfeeL->xControl.ucROutOrder[ucIL] = ucIL;

    /* Initialize the structs of the Channel, Double Buffer, RMAP and Data packet */
    if ( bCommInitCh(&pxNfeeL->xChannel, ucIdNFEE ) == FALSE ) {
81119b0c:	e0bffe17 	ldw	r2,-8(fp)
81119b10:	10803204 	addi	r2,r2,200
81119b14:	e0ffff03 	ldbu	r3,-4(fp)
81119b18:	180b883a 	mov	r5,r3
81119b1c:	1009883a 	mov	r4,r2
81119b20:	110461c0 	call	8110461c <bCommInitCh>
81119b24:	1000091e 	bne	r2,zero,81119b4c <vNFeeStructureInit+0x128>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Initialized SPW Channel %i \n", pxNfeeL->ucId);
81119b28:	d0e05e17 	ldw	r3,-32392(gp)
81119b2c:	e0bffe17 	ldw	r2,-8(fp)
81119b30:	10800003 	ldbu	r2,0(r2)
81119b34:	10803fcc 	andi	r2,r2,255
81119b38:	100d883a 	mov	r6,r2
81119b3c:	01604574 	movhi	r5,33045
81119b40:	296f5904 	addi	r5,r5,-17052
81119b44:	1809883a 	mov	r4,r3
81119b48:	111ca180 	call	8111ca18 <fprintf>
		#endif
    }

    if ( bCommSetGlobalIrqEn( TRUE, ucIdNFEE ) == FALSE ) {
81119b4c:	e0bfff03 	ldbu	r2,-4(fp)
81119b50:	100b883a 	mov	r5,r2
81119b54:	01000044 	movi	r4,1
81119b58:	11044b00 	call	811044b0 <bCommSetGlobalIrqEn>
81119b5c:	1000091e 	bne	r2,zero,81119b84 <vNFeeStructureInit+0x160>
		#ifdef DEBUG_ON
			fprintf(fp, "\n CRITICAL! Can't Enable global interrupt for the channel %i \n", pxNfeeL->ucId);
81119b60:	d0e05e17 	ldw	r3,-32392(gp)
81119b64:	e0bffe17 	ldw	r2,-8(fp)
81119b68:	10800003 	ldbu	r2,0(r2)
81119b6c:	10803fcc 	andi	r2,r2,255
81119b70:	100d883a 	mov	r6,r2
81119b74:	01604574 	movhi	r5,33045
81119b78:	296f6504 	addi	r5,r5,-17004
81119b7c:	1809883a 	mov	r4,r3
81119b80:	111ca180 	call	8111ca18 <fprintf>
		#endif
    }

}
81119b84:	0001883a 	nop
81119b88:	e037883a 	mov	sp,fp
81119b8c:	dfc00117 	ldw	ra,4(sp)
81119b90:	df000017 	ldw	fp,0(sp)
81119b94:	dec00204 	addi	sp,sp,8
81119b98:	f800283a 	ret

81119b9c <vUpdateMemMapFEE>:

/* Update the memory mapping for the FEE due to the CCD informations */
void vUpdateMemMapFEE( TNFee *pxNfeeL ) {
81119b9c:	defff404 	addi	sp,sp,-48
81119ba0:	de00012e 	bgeu	sp,et,81119ba8 <vUpdateMemMapFEE+0xc>
81119ba4:	003b68fa 	trap	3
81119ba8:	df000b15 	stw	fp,44(sp)
81119bac:	df000b04 	addi	fp,sp,44
81119bb0:	e13fff15 	stw	r4,-4(fp)
    unsigned long ulTotalSizeL = 0; /* pixels */
81119bb4:	e03ffa15 	stw	zero,-24(fp)
    unsigned long ulMemLinesL = 0; /* mem lines */
81119bb8:	e03ff515 	stw	zero,-44(fp)
    unsigned long ulTotalMemLinesL = 0;
81119bbc:	e03ff615 	stw	zero,-40(fp)
    unsigned long ulMemLeftBytesL = 0; /* bytes */
81119bc0:	e03ffb15 	stw	zero,-20(fp)
    unsigned long ulMemLeftLinesL = 0; /* mem lines */
81119bc4:	e03ffc15 	stw	zero,-16(fp)
    unsigned long ulMaskMemLinesL = 0; /* mem lines */
81119bc8:	e03ff715 	stw	zero,-36(fp)
    unsigned char ucPixelsInLastBlockL = 0;
81119bcc:	e03ff805 	stb	zero,-32(fp)
    unsigned char ucShiftsL = 0;
81119bd0:	e03ffd05 	stb	zero,-12(fp)
    unsigned char ucIL = 0;
81119bd4:	e03ff845 	stb	zero,-31(fp)
    unsigned long ulLastOffset = 0;
81119bd8:	e03ff915 	stw	zero,-28(fp)
    unsigned long ulStepHalfCCD = 0;
81119bdc:	e03ffe15 	stw	zero,-8(fp)


    /* Size of the footprint of the CCD in the DDR memory */
    pxNfeeL->xMemMap.ulTotalBytes = ( OFFSET_STEP_FEE );
81119be0:	e17fff17 	ldw	r5,-4(fp)
81119be4:	01035a34 	movhi	r4,3432
81119be8:	21348c04 	addi	r4,r4,-11728
81119bec:	29000215 	stw	r4,8(r5)

    /* Offset of the FEE in the DDR memory */
    pxNfeeL->xMemMap.ulOffsetRoot = OFFSET_STEP_FEE * pxNfeeL->ucId;
81119bf0:	e13fff17 	ldw	r4,-4(fp)
81119bf4:	21000003 	ldbu	r4,0(r4)
81119bf8:	21403fcc 	andi	r5,r4,255
81119bfc:	01035a34 	movhi	r4,3432
81119c00:	21348c04 	addi	r4,r4,-11728
81119c04:	2909383a 	mul	r4,r5,r4
81119c08:	200b883a 	mov	r5,r4
81119c0c:	e13fff17 	ldw	r4,-4(fp)
81119c10:	21400115 	stw	r5,4(r4)

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;
81119c14:	e13fff17 	ldw	r4,-4(fp)
81119c18:	21400117 	ldw	r5,4(r4)
81119c1c:	01033234 	movhi	r4,3272
81119c20:	21348c04 	addi	r4,r4,-11728
81119c24:	290b883a 	add	r5,r5,r4
81119c28:	e13fff17 	ldw	r4,-4(fp)
81119c2c:	21400315 	stw	r5,12(r4)

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81119c30:	e13fff17 	ldw	r4,-4(fp)
81119c34:	2100310b 	ldhu	r4,196(r4)
81119c38:	217fffcc 	andi	r5,r4,65535
81119c3c:	e13fff17 	ldw	r4,-4(fp)
81119c40:	2100300b 	ldhu	r4,192(r4)
81119c44:	213fffcc 	andi	r4,r4,65535
81119c48:	290b883a 	add	r5,r5,r4
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );
81119c4c:	e13fff17 	ldw	r4,-4(fp)
81119c50:	2100308b 	ldhu	r4,194(r4)
81119c54:	21bfffcc 	andi	r6,r4,65535
81119c58:	e13fff17 	ldw	r4,-4(fp)
81119c5c:	21002f8b 	ldhu	r4,190(r4)
81119c60:	213fffcc 	andi	r4,r4,65535
81119c64:	310d883a 	add	r6,r6,r4
81119c68:	e13fff17 	ldw	r4,-4(fp)
81119c6c:	21002f0b 	ldhu	r4,188(r4)
81119c70:	213fffcc 	andi	r4,r4,65535
81119c74:	3109883a 	add	r4,r6,r4

    /* LUT Addrs */
    pxNfeeL->xMemMap.ulLUTAddr = LUT_INITIAL_ADDR + pxNfeeL->xMemMap.ulOffsetRoot;

    /* (HEIGHT + usiOLN)*(usiSPrescanN + usiSOverscanN + usiHalfWidth) */
    ulTotalSizeL =  ( pxNfeeL->xCcdInfo.usiHeight + pxNfeeL->xCcdInfo.usiOLN ) *
81119c78:	2909383a 	mul	r4,r5,r4
81119c7c:	e13ffa15 	stw	r4,-24(fp)
                    ( pxNfeeL->xCcdInfo.usiHalfWidth + pxNfeeL->xCcdInfo.usiSOverscanN + pxNfeeL->xCcdInfo.usiSPrescanN );

    /* Total size in Bytes of a half CCD */
    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalSizeL * BYTES_PER_PIXEL;
81119c80:	e13ffa17 	ldw	r4,-24(fp)
81119c84:	2109883a 	add	r4,r4,r4
81119c88:	200b883a 	mov	r5,r4
81119c8c:	e13fff17 	ldw	r4,-4(fp)
81119c90:	21400515 	stw	r5,20(r4)

    /* Total of Memory lines (64 bits memory) */
    ulMemLinesL = (unsigned long) pxNfeeL->xMemMap.xCommon.usiTotalBytes / BYTES_PER_MEM_LINE;
81119c94:	e13fff17 	ldw	r4,-4(fp)
81119c98:	21000517 	ldw	r4,20(r4)
81119c9c:	2008d0fa 	srli	r4,r4,3
81119ca0:	e13ff515 	stw	r4,-44(fp)
    ulMemLeftBytesL = pxNfeeL->xMemMap.xCommon.usiTotalBytes % BYTES_PER_MEM_LINE;   /* Word memory Alignment check: how much bytes left not align in the last word of the memory */
81119ca4:	e13fff17 	ldw	r4,-4(fp)
81119ca8:	21000517 	ldw	r4,20(r4)
81119cac:	210001cc 	andi	r4,r4,7
81119cb0:	e13ffb15 	stw	r4,-20(fp)
    if ( ulMemLeftBytesL > 0 ) {
81119cb4:	e13ffb17 	ldw	r4,-20(fp)
81119cb8:	20001226 	beq	r4,zero,81119d04 <vUpdateMemMapFEE+0x168>
        ulMemLinesL = ulMemLinesL + 1;
81119cbc:	e13ff517 	ldw	r4,-44(fp)
81119cc0:	21000044 	addi	r4,r4,1
81119cc4:	e13ff515 	stw	r4,-44(fp)
        pxNfeeL->xMemMap.xCommon.usiTotalBytes = pxNfeeL->xMemMap.xCommon.usiTotalBytes - ulMemLeftBytesL + BYTES_PER_MEM_LINE; /* Add a full line, after will be filled with zero padding */
81119cc8:	e13fff17 	ldw	r4,-4(fp)
81119ccc:	21400517 	ldw	r5,20(r4)
81119cd0:	e13ffb17 	ldw	r4,-20(fp)
81119cd4:	2909c83a 	sub	r4,r5,r4
81119cd8:	21400204 	addi	r5,r4,8
81119cdc:	e13fff17 	ldw	r4,-4(fp)
81119ce0:	21400515 	stw	r5,20(r4)
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = BYTES_PER_MEM_LINE - ulMemLeftBytesL;
81119ce4:	e13ffb17 	ldw	r4,-20(fp)
81119ce8:	200b883a 	mov	r5,r4
81119cec:	01000204 	movi	r4,8
81119cf0:	2149c83a 	sub	r4,r4,r5
81119cf4:	200b883a 	mov	r5,r4
81119cf8:	e13fff17 	ldw	r4,-4(fp)
81119cfc:	21400605 	stb	r5,24(r4)
81119d00:	00000206 	br	81119d0c <vUpdateMemMapFEE+0x170>
    } else {
        pxNfeeL->xMemMap.xCommon.ucPaddingBytes = 0;
81119d04:	e13fff17 	ldw	r4,-4(fp)
81119d08:	20000605 	stb	zero,24(r4)
    }

    /* At this point we have mapping the pixel in the CCD and calculate the zero padding for the last WORD of the line memory of the half ccd */

    /* For every 16 mem line will be 1 mask mem line */
    ulMaskMemLinesL = (unsigned long) ulMemLinesL / BLOCK_MEM_SIZE;
81119d0c:	e13ff517 	ldw	r4,-44(fp)
81119d10:	2008d13a 	srli	r4,r4,4
81119d14:	e13ff715 	stw	r4,-36(fp)
    ulMemLeftLinesL = ulMemLinesL % BLOCK_MEM_SIZE;
81119d18:	e13ff517 	ldw	r4,-44(fp)
81119d1c:	210003cc 	andi	r4,r4,15
81119d20:	e13ffc15 	stw	r4,-16(fp)
    if ( ulMemLeftLinesL >= 1 ) {
81119d24:	e13ffc17 	ldw	r4,-16(fp)
81119d28:	20000b26 	beq	r4,zero,81119d58 <vUpdateMemMapFEE+0x1bc>
        ulMaskMemLinesL = ulMaskMemLinesL + 1;
81119d2c:	e13ff717 	ldw	r4,-36(fp)
81119d30:	21000044 	addi	r4,r4,1
81119d34:	e13ff715 	stw	r4,-36(fp)
        ulTotalMemLinesL = ( ulMemLinesL - ulMemLeftLinesL + BLOCK_MEM_SIZE ) + ulMaskMemLinesL; /* One extra 16 sized block, will be filled with zero padding the ret os spare lines */
81119d38:	e17ff517 	ldw	r5,-44(fp)
81119d3c:	e13ffc17 	ldw	r4,-16(fp)
81119d40:	290bc83a 	sub	r5,r5,r4
81119d44:	e13ff717 	ldw	r4,-36(fp)
81119d48:	2909883a 	add	r4,r5,r4
81119d4c:	21000404 	addi	r4,r4,16
81119d50:	e13ff615 	stw	r4,-40(fp)
81119d54:	00000406 	br	81119d68 <vUpdateMemMapFEE+0x1cc>
    } else {
        ulTotalMemLinesL = ulMemLinesL + ulMaskMemLinesL;
81119d58:	e17ff517 	ldw	r5,-44(fp)
81119d5c:	e13ff717 	ldw	r4,-36(fp)
81119d60:	2909883a 	add	r4,r5,r4
81119d64:	e13ff615 	stw	r4,-40(fp)
    }

    pxNfeeL->xMemMap.xCommon.usiTotalBytes = ulTotalMemLinesL * BYTES_PER_MEM_LINE;
81119d68:	e13ff617 	ldw	r4,-40(fp)
81119d6c:	200a90fa 	slli	r5,r4,3
81119d70:	e13fff17 	ldw	r4,-4(fp)
81119d74:	21400515 	stw	r5,20(r4)

    /* Calculating how is the final mask with zero padding */
    if ( ulMemLeftBytesL >= 1 ) {
81119d78:	e13ffb17 	ldw	r4,-20(fp)
81119d7c:	20000926 	beq	r4,zero,81119da4 <vUpdateMemMapFEE+0x208>
        ucPixelsInLastBlockL = (unsigned char) (( ulMemLeftLinesL * PIXEL_PER_MEM_LINE ) + (unsigned int) ( ulMemLeftBytesL / BYTES_PER_PIXEL ));
81119d80:	e13ffc17 	ldw	r4,-16(fp)
81119d84:	2109883a 	add	r4,r4,r4
81119d88:	2109883a 	add	r4,r4,r4
81119d8c:	200b883a 	mov	r5,r4
81119d90:	e13ffb17 	ldw	r4,-20(fp)
81119d94:	2008d07a 	srli	r4,r4,1
81119d98:	2909883a 	add	r4,r5,r4
81119d9c:	e13ff805 	stb	r4,-32(fp)
81119da0:	00000406 	br	81119db4 <vUpdateMemMapFEE+0x218>
    } else {
        ucPixelsInLastBlockL = (unsigned char) ( ulMemLeftLinesL * PIXEL_PER_MEM_LINE );
81119da4:	e13ffc17 	ldw	r4,-16(fp)
81119da8:	2109883a 	add	r4,r4,r4
81119dac:	2109883a 	add	r4,r4,r4
81119db0:	e13ff805 	stb	r4,-32(fp)
    }

    /* 16 * 4 = 64 - (number of pixels in the last block)) */
    ucShiftsL = ( BLOCK_MEM_SIZE * PIXEL_PER_MEM_LINE ) - ucPixelsInLastBlockL;
81119db4:	e13ff803 	ldbu	r4,-32(fp)
81119db8:	01401004 	movi	r5,64
81119dbc:	2909c83a 	sub	r4,r5,r4
81119dc0:	e13ffd05 	stb	r4,-12(fp)

    /* WARNING: Verify the memory alocation (endianess) */
    pxNfeeL->xMemMap.xCommon.ucPaddingMask.ullWord = (unsigned long long)(0xFFFFFFFFFFFFFFFF >> ucShiftsL);
81119dc4:	e13ffd03 	ldbu	r4,-12(fp)
81119dc8:	217ff804 	addi	r5,r4,-32
81119dcc:	28000416 	blt	r5,zero,81119de0 <vUpdateMemMapFEE+0x244>
81119dd0:	013fffc4 	movi	r4,-1
81119dd4:	2144d83a 	srl	r2,r4,r5
81119dd8:	0007883a 	mov	r3,zero
81119ddc:	00000a06 	br	81119e08 <vUpdateMemMapFEE+0x26c>
81119de0:	017fffc4 	movi	r5,-1
81119de4:	280c907a 	slli	r6,r5,1
81119de8:	014007c4 	movi	r5,31
81119dec:	290bc83a 	sub	r5,r5,r4
81119df0:	314a983a 	sll	r5,r6,r5
81119df4:	01bfffc4 	movi	r6,-1
81119df8:	3104d83a 	srl	r2,r6,r4
81119dfc:	2884b03a 	or	r2,r5,r2
81119e00:	017fffc4 	movi	r5,-1
81119e04:	2906d83a 	srl	r3,r5,r4
81119e08:	e13fff17 	ldw	r4,-4(fp)
81119e0c:	20800715 	stw	r2,28(r4)
81119e10:	20c00815 	stw	r3,32(r4)

    /* Number of block is te same as the number of line masks in the memory */
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;
81119e14:	e0bfff17 	ldw	r2,-4(fp)
81119e18:	e0fff717 	ldw	r3,-36(fp)
81119e1c:	10c00415 	stw	r3,16(r2)

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
81119e20:	e0bfff17 	ldw	r2,-4(fp)
81119e24:	10c00117 	ldw	r3,4(r2)
81119e28:	008004b4 	movhi	r2,18
81119e2c:	10a40004 	addi	r2,r2,-28672
81119e30:	1885883a 	add	r2,r3,r2
81119e34:	e0bff915 	stw	r2,-28(fp)
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
81119e38:	e0bfff17 	ldw	r2,-4(fp)
81119e3c:	10c00517 	ldw	r3,20(r2)
81119e40:	008000b4 	movhi	r2,2
81119e44:	10a40004 	addi	r2,r2,-28672
81119e48:	1885883a 	add	r2,r3,r2
81119e4c:	e0bffe15 	stw	r2,-8(fp)
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81119e50:	e03ff845 	stb	zero,-31(fp)
81119e54:	00001906 	br	81119ebc <vUpdateMemMapFEE+0x320>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
81119e58:	e0bff843 	ldbu	r2,-31(fp)
81119e5c:	e0ffff17 	ldw	r3,-4(fp)
81119e60:	10800624 	muli	r2,r2,24
81119e64:	1885883a 	add	r2,r3,r2
81119e68:	10800904 	addi	r2,r2,36
81119e6c:	e0fff917 	ldw	r3,-28(fp)
81119e70:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81119e74:	e0fff917 	ldw	r3,-28(fp)
81119e78:	e0bffe17 	ldw	r2,-8(fp)
81119e7c:	1885883a 	add	r2,r3,r2
81119e80:	e0bff915 	stw	r2,-28(fp)
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
81119e84:	e0bff843 	ldbu	r2,-31(fp)
81119e88:	e0ffff17 	ldw	r3,-4(fp)
81119e8c:	10800624 	muli	r2,r2,24
81119e90:	1885883a 	add	r2,r3,r2
81119e94:	10800c04 	addi	r2,r2,48
81119e98:	e0fff917 	ldw	r3,-28(fp)
81119e9c:	10c00015 	stw	r3,0(r2)
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
81119ea0:	e0fff917 	ldw	r3,-28(fp)
81119ea4:	e0bffe17 	ldw	r2,-8(fp)
81119ea8:	1885883a 	add	r2,r3,r2
81119eac:	e0bff915 	stw	r2,-28(fp)
    pxNfeeL->xMemMap.xCommon.usiNTotalBlocks = ulMaskMemLinesL;

    /* Set the addr for every CCD of the FEE, left and right sides */
    ulLastOffset = pxNfeeL->xMemMap.ulOffsetRoot + RESERVED_FEE_X + RESERVED_HALF_CCD_X;
    ulStepHalfCCD = RESERVED_HALF_CCD_X + pxNfeeL->xMemMap.xCommon.usiTotalBytes;
    for ( ucIL = 0; ucIL < 4; ucIL++ ) {
81119eb0:	e0bff843 	ldbu	r2,-31(fp)
81119eb4:	10800044 	addi	r2,r2,1
81119eb8:	e0bff845 	stb	r2,-31(fp)
81119ebc:	e0bff843 	ldbu	r2,-31(fp)
81119ec0:	10800130 	cmpltui	r2,r2,4
81119ec4:	103fe41e 	bne	r2,zero,81119e58 <__reset+0xfb0f9e58>
        pxNfeeL->xMemMap.xCcd[ ucIL ].xLeft.ulOffsetAddr = ulLastOffset;
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
        pxNfeeL->xMemMap.xCcd[ ucIL ].xRight.ulOffsetAddr = ulLastOffset; 
        ulLastOffset = ulLastOffset + ulStepHalfCCD;
    }
}
81119ec8:	0001883a 	nop
81119ecc:	e037883a 	mov	sp,fp
81119ed0:	df000017 	ldw	fp,0(sp)
81119ed4:	dec00104 	addi	sp,sp,4
81119ed8:	f800283a 	ret

81119edc <vFeeSpwRMAPLoadDefault>:

/* Load the default configuration of the SPW/RMAP */
void vFeeSpwRMAPLoadDefault( TNFee *pxNfeeL ) {
81119edc:	defffe04 	addi	sp,sp,-8
81119ee0:	de00012e 	bgeu	sp,et,81119ee8 <vFeeSpwRMAPLoadDefault+0xc>
81119ee4:	003b68fa 	trap	3
81119ee8:	df000115 	stw	fp,4(sp)
81119eec:	df000104 	addi	fp,sp,4
81119ef0:	e13fff15 	stw	r4,-4(fp)
    //bGetSpwRmapSDCard();
    //todo: For now is hardcoded
    //todo: Verificar qual a estrutura usar para as configuraes
}
81119ef4:	0001883a 	nop
81119ef8:	e037883a 	mov	sp,fp
81119efc:	df000017 	ldw	fp,0(sp)
81119f00:	dec00104 	addi	sp,sp,4
81119f04:	f800283a 	ret

81119f08 <vFeeSpwRMAPChangeConfig>:

/* Only in NFEE_CONFIG */
/* Change the active configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeConfig( TNFee *pxNfeeL ) {
81119f08:	defffe04 	addi	sp,sp,-8
81119f0c:	de00012e 	bgeu	sp,et,81119f14 <vFeeSpwRMAPChangeConfig+0xc>
81119f10:	003b68fa 	trap	3
81119f14:	df000115 	stw	fp,4(sp)
81119f18:	df000104 	addi	fp,sp,4
81119f1c:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar qual a estrutura usar para as configuraes
}
81119f20:	0001883a 	nop
81119f24:	e037883a 	mov	sp,fp
81119f28:	df000017 	ldw	fp,0(sp)
81119f2c:	dec00104 	addi	sp,sp,4
81119f30:	f800283a 	ret

81119f34 <vFeeSpwRMAPChangeDefault>:

/* Only in NFEE_CONFIG */
/* Change the default configuration of the SPW/RMAP */
void vFeeSpwRMAPChangeDefault( TNFee *pxNfeeL ) {
81119f34:	defffe04 	addi	sp,sp,-8
81119f38:	de00012e 	bgeu	sp,et,81119f40 <vFeeSpwRMAPChangeDefault+0xc>
81119f3c:	003b68fa 	trap	3
81119f40:	df000115 	stw	fp,4(sp)
81119f44:	df000104 	addi	fp,sp,4
81119f48:	e13fff15 	stw	r4,-4(fp)
    //bSaveSpwRmapSDCard();
    //todo: Verificar qual a estrutura usar para as configuraes, enviar o numero do FEE tbm
}
81119f4c:	0001883a 	nop
81119f50:	e037883a 	mov	sp,fp
81119f54:	df000017 	ldw	fp,0(sp)
81119f58:	dec00104 	addi	sp,sp,4
81119f5c:	f800283a 	ret

81119f60 <cFeeSpwChannelEnable>:

/* Any mode */
/* Enable SPW channel for the FEE */
void cFeeSpwChannelEnable( TNFee *pxNfeeL ) {
81119f60:	defffe04 	addi	sp,sp,-8
81119f64:	de00012e 	bgeu	sp,et,81119f6c <cFeeSpwChannelEnable+0xc>
81119f68:	003b68fa 	trap	3
81119f6c:	df000115 	stw	fp,4(sp)
81119f70:	df000104 	addi	fp,sp,4
81119f74:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81119f78:	0001883a 	nop
81119f7c:	e037883a 	mov	sp,fp
81119f80:	df000017 	ldw	fp,0(sp)
81119f84:	dec00104 	addi	sp,sp,4
81119f88:	f800283a 	ret

81119f8c <cFeeSpwChannelDisable>:

/* Any mode */
/* Disable SPW channel for the FEE */
void cFeeSpwChannelDisable( TNFee *pxNfeeL ) {
81119f8c:	defffe04 	addi	sp,sp,-8
81119f90:	de00012e 	bgeu	sp,et,81119f98 <cFeeSpwChannelDisable+0xc>
81119f94:	003b68fa 	trap	3
81119f98:	df000115 	stw	fp,4(sp)
81119f9c:	df000104 	addi	fp,sp,4
81119fa0:	e13fff15 	stw	r4,-4(fp)
    //todo: Verificar com o Frana
}
81119fa4:	0001883a 	nop
81119fa8:	e037883a 	mov	sp,fp
81119fac:	df000017 	ldw	fp,0(sp)
81119fb0:	dec00104 	addi	sp,sp,4
81119fb4:	f800283a 	ret

81119fb8 <cFeeRMAPDump>:

/* Any mode */
/* Dump and send using PUS the RMAP Configuration areas [NFEESIM-UR-699] */
void cFeeRMAPDump( TNFee *pxNfeeL ) {
81119fb8:	defffe04 	addi	sp,sp,-8
81119fbc:	de00012e 	bgeu	sp,et,81119fc4 <cFeeRMAPDump+0xc>
81119fc0:	003b68fa 	trap	3
81119fc4:	df000115 	stw	fp,4(sp)
81119fc8:	df000104 	addi	fp,sp,4
81119fcc:	e13fff15 	stw	r4,-4(fp)

    //todo: ler as areas de memoria do RMAP e enviar via ethernet

}
81119fd0:	0001883a 	nop
81119fd4:	e037883a 	mov	sp,fp
81119fd8:	df000017 	ldw	fp,0(sp)
81119fdc:	dec00104 	addi	sp,sp,4
81119fe0:	f800283a 	ret

81119fe4 <cFeeRMAPEchoingEnable>:

/* Any mode */
/* Allow the user to activate the echo mode for RMAP [NFEESIM-UR-588]  */
void cFeeRMAPEchoingEnable( TNFee *pxNfeeL ) {
81119fe4:	defffe04 	addi	sp,sp,-8
81119fe8:	de00012e 	bgeu	sp,et,81119ff0 <cFeeRMAPEchoingEnable+0xc>
81119fec:	003b68fa 	trap	3
81119ff0:	df000115 	stw	fp,4(sp)
81119ff4:	df000104 	addi	fp,sp,4
81119ff8:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = TRUE;
81119ffc:	e0bfff17 	ldw	r2,-4(fp)
8111a000:	00c00044 	movi	r3,1
8111a004:	10c02515 	stw	r3,148(r2)
}
8111a008:	0001883a 	nop
8111a00c:	e037883a 	mov	sp,fp
8111a010:	df000017 	ldw	fp,0(sp)
8111a014:	dec00104 	addi	sp,sp,4
8111a018:	f800283a 	ret

8111a01c <cFeeRMAPEchoingDisable>:

/* Any mode */
/* Allow the user to disable the echo mode for RMAP [NFEESIM-UR-589]  */
void cFeeRMAPEchoingDisable( TNFee *pxNfeeL ) {
8111a01c:	defffe04 	addi	sp,sp,-8
8111a020:	de00012e 	bgeu	sp,et,8111a028 <cFeeRMAPEchoingDisable+0xc>
8111a024:	003b68fa 	trap	3
8111a028:	df000115 	stw	fp,4(sp)
8111a02c:	df000104 	addi	fp,sp,4
8111a030:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bEchoing = FALSE;
8111a034:	e0bfff17 	ldw	r2,-4(fp)
8111a038:	10002515 	stw	zero,148(r2)
}
8111a03c:	0001883a 	nop
8111a040:	e037883a 	mov	sp,fp
8111a044:	df000017 	ldw	fp,0(sp)
8111a048:	dec00104 	addi	sp,sp,4
8111a04c:	f800283a 	ret

8111a050 <cFeeRMAPLogEnable>:

/* Any mode */
/* Allow the user to activate the log of RMAP [NFEESIM-UR-588]  */
void cFeeRMAPLogEnable( TNFee *pxNfeeL ) {
8111a050:	defffe04 	addi	sp,sp,-8
8111a054:	de00012e 	bgeu	sp,et,8111a05c <cFeeRMAPLogEnable+0xc>
8111a058:	003b68fa 	trap	3
8111a05c:	df000115 	stw	fp,4(sp)
8111a060:	df000104 	addi	fp,sp,4
8111a064:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = TRUE;
8111a068:	e0bfff17 	ldw	r2,-4(fp)
8111a06c:	00c00044 	movi	r3,1
8111a070:	10c02415 	stw	r3,144(r2)
}
8111a074:	0001883a 	nop
8111a078:	e037883a 	mov	sp,fp
8111a07c:	df000017 	ldw	fp,0(sp)
8111a080:	dec00104 	addi	sp,sp,4
8111a084:	f800283a 	ret

8111a088 <cFeeRMAPLogDisable>:

/* Any mode */
/* Allow the user to disable the log of RMAP [NFEESIM-UR-589]  */
void cFeeRMAPLogDisable( TNFee *pxNfeeL ) {
8111a088:	defffe04 	addi	sp,sp,-8
8111a08c:	de00012e 	bgeu	sp,et,8111a094 <cFeeRMAPLogDisable+0xc>
8111a090:	003b68fa 	trap	3
8111a094:	df000115 	stw	fp,4(sp)
8111a098:	df000104 	addi	fp,sp,4
8111a09c:	e13fff15 	stw	r4,-4(fp)
    pxNfeeL->xControl.bLogging = FALSE;
8111a0a0:	e0bfff17 	ldw	r2,-4(fp)
8111a0a4:	10002415 	stw	zero,144(r2)
}
8111a0a8:	0001883a 	nop
8111a0ac:	e037883a 	mov	sp,fp
8111a0b0:	df000017 	ldw	fp,0(sp)
8111a0b4:	dec00104 	addi	sp,sp,4
8111a0b8:	f800283a 	ret

8111a0bc <vNFeeControlInit>:
 */


#include "fee_controller.h"

void vNFeeControlInit( TNFee_Control *xFeeControlL ) {
8111a0bc:	defffc04 	addi	sp,sp,-16
8111a0c0:	de00012e 	bgeu	sp,et,8111a0c8 <vNFeeControlInit+0xc>
8111a0c4:	003b68fa 	trap	3
8111a0c8:	dfc00315 	stw	ra,12(sp)
8111a0cc:	df000215 	stw	fp,8(sp)
8111a0d0:	df000204 	addi	fp,sp,8
8111a0d4:	e13fff15 	stw	r4,-4(fp)
    unsigned char ucIL = 0;
8111a0d8:	e03ffe05 	stb	zero,-8(fp)
    
    /* Reset TimeCode */
    vResetTimeCode( xFeeControlL );
8111a0dc:	e13fff17 	ldw	r4,-4(fp)
8111a0e0:	111a2080 	call	8111a208 <vResetTimeCode>
    /* Load Default Id for NFEE master */
    vLoadDefaultIdNFEEMaster( xFeeControlL );
8111a0e4:	e13fff17 	ldw	r4,-4(fp)
8111a0e8:	111a23c0 	call	8111a23c <vLoadDefaultIdNFEEMaster>

    xFeeControlL->sMode = sMebInit;
8111a0ec:	e0bfff17 	ldw	r2,-4(fp)
8111a0f0:	10009915 	stw	zero,612(r2)

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111a0f4:	e03ffe05 	stb	zero,-8(fp)
8111a0f8:	00002b06 	br	8111a1a8 <vNFeeControlInit+0xec>
        vNFeeStructureInit( &xFeeControlL->xNfee[ ucIL ], ucIL);
8111a0fc:	e0bffe03 	ldbu	r2,-8(fp)
8111a100:	10809524 	muli	r2,r2,596
8111a104:	e0ffff17 	ldw	r3,-4(fp)
8111a108:	1885883a 	add	r2,r3,r2
8111a10c:	e0fffe03 	ldbu	r3,-8(fp)
8111a110:	180b883a 	mov	r5,r3
8111a114:	1009883a 	mov	r4,r2
8111a118:	1119a240 	call	81119a24 <vNFeeStructureInit>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
8111a11c:	e0bffe03 	ldbu	r2,-8(fp)
8111a120:	e0fffe03 	ldbu	r3,-8(fp)
8111a124:	18c09524 	muli	r3,r3,596
8111a128:	18c02104 	addi	r3,r3,132
8111a12c:	e13fff17 	ldw	r4,-4(fp)
8111a130:	20c7883a 	add	r3,r4,r3
8111a134:	e13fff17 	ldw	r4,-4(fp)
8111a138:	10802584 	addi	r2,r2,150
8111a13c:	1085883a 	add	r2,r2,r2
8111a140:	1085883a 	add	r2,r2,r2
8111a144:	2085883a 	add	r2,r4,r2
8111a148:	10c00015 	stw	r3,0(r2)
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
8111a14c:	e0bffe03 	ldbu	r2,-8(fp)
8111a150:	e0fffe03 	ldbu	r3,-8(fp)
8111a154:	18c09524 	muli	r3,r3,596
8111a158:	18c02704 	addi	r3,r3,156
8111a15c:	e13fff17 	ldw	r4,-4(fp)
8111a160:	20c7883a 	add	r3,r4,r3
8111a164:	e13fff17 	ldw	r4,-4(fp)
8111a168:	108025c4 	addi	r2,r2,151
8111a16c:	1085883a 	add	r2,r2,r2
8111a170:	1085883a 	add	r2,r2,r2
8111a174:	2085883a 	add	r2,r4,r2
8111a178:	10c00015 	stw	r3,0(r2)
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
8111a17c:	e0bffe03 	ldbu	r2,-8(fp)
8111a180:	e0ffff17 	ldw	r3,-4(fp)
8111a184:	18c09517 	ldw	r3,596(r3)
8111a188:	e13fff17 	ldw	r4,-4(fp)
8111a18c:	10809524 	muli	r2,r2,596
8111a190:	2085883a 	add	r2,r4,r2
8111a194:	10802904 	addi	r2,r2,164
8111a198:	10c00015 	stw	r3,0(r2)
    vLoadDefaultIdNFEEMaster( xFeeControlL );

    xFeeControlL->sMode = sMebInit;

    /* Calculate the */
    for ( ucIL = 0; ucIL < N_OF_NFEE; ucIL++ ) {
8111a19c:	e0bffe03 	ldbu	r2,-8(fp)
8111a1a0:	10800044 	addi	r2,r2,1
8111a1a4:	e0bffe05 	stb	r2,-8(fp)
8111a1a8:	e0bffe03 	ldbu	r2,-8(fp)
8111a1ac:	103fd326 	beq	r2,zero,8111a0fc <__reset+0xfb0fa0fc>
        xFeeControlL->pbEnabledNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bEnabled;
        xFeeControlL->pbSimulatingNFEEs[ ucIL ] = &xFeeControlL->xNfee[ ucIL ].xControl.bSimulating;
        xFeeControlL->xNfee[ ucIL ].xControl.pActualMem = xFeeControlL->pActualMem;
    }

}
8111a1b0:	0001883a 	nop
8111a1b4:	e037883a 	mov	sp,fp
8111a1b8:	dfc00117 	ldw	ra,4(sp)
8111a1bc:	df000017 	ldw	fp,0(sp)
8111a1c0:	dec00204 	addi	sp,sp,8
8111a1c4:	f800283a 	ret

8111a1c8 <vSetTimeCode>:

/* Any mode */
/* Set the time code of the Simucam */
void vSetTimeCode( TNFee_Control *xFeeControlL, unsigned char ucTime ) {
8111a1c8:	defffd04 	addi	sp,sp,-12
8111a1cc:	de00012e 	bgeu	sp,et,8111a1d4 <vSetTimeCode+0xc>
8111a1d0:	003b68fa 	trap	3
8111a1d4:	df000215 	stw	fp,8(sp)
8111a1d8:	df000204 	addi	fp,sp,8
8111a1dc:	e13ffe15 	stw	r4,-8(fp)
8111a1e0:	2805883a 	mov	r2,r5
8111a1e4:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucTimeCode = ucTime;
8111a1e8:	e0bffe17 	ldw	r2,-8(fp)
8111a1ec:	e0ffff03 	ldbu	r3,-4(fp)
8111a1f0:	10c09805 	stb	r3,608(r2)
}
8111a1f4:	0001883a 	nop
8111a1f8:	e037883a 	mov	sp,fp
8111a1fc:	df000017 	ldw	fp,0(sp)
8111a200:	dec00104 	addi	sp,sp,4
8111a204:	f800283a 	ret

8111a208 <vResetTimeCode>:

/* Reset the time code of the Simucam */
void vResetTimeCode( TNFee_Control *xFeeControlL ) {
8111a208:	defffe04 	addi	sp,sp,-8
8111a20c:	de00012e 	bgeu	sp,et,8111a214 <vResetTimeCode+0xc>
8111a210:	003b68fa 	trap	3
8111a214:	df000115 	stw	fp,4(sp)
8111a218:	df000104 	addi	fp,sp,4
8111a21c:	e13fff15 	stw	r4,-4(fp)
    xFeeControlL->ucTimeCode = 0;
8111a220:	e0bfff17 	ldw	r2,-4(fp)
8111a224:	10009805 	stb	zero,608(r2)
}
8111a228:	0001883a 	nop
8111a22c:	e037883a 	mov	sp,fp
8111a230:	df000017 	ldw	fp,0(sp)
8111a234:	dec00104 	addi	sp,sp,4
8111a238:	f800283a 	ret

8111a23c <vLoadDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Load Default Config for IdNFEEMaster */
void vLoadDefaultIdNFEEMaster( TNFee_Control *xFeeControlL ) {
8111a23c:	defffe04 	addi	sp,sp,-8
8111a240:	de00012e 	bgeu	sp,et,8111a248 <vLoadDefaultIdNFEEMaster+0xc>
8111a244:	003b68fa 	trap	3
8111a248:	df000115 	stw	fp,4(sp)
8111a24c:	df000104 	addi	fp,sp,4
8111a250:	e13fff15 	stw	r4,-4(fp)
    //bGetIdNFEEMasterSDCard();
    //todo: For now is hardcoded
    xFeeControlL->ucIdNFEEMaster = 0;
8111a254:	e0bfff17 	ldw	r2,-4(fp)
8111a258:	10009845 	stb	zero,609(r2)
}
8111a25c:	0001883a 	nop
8111a260:	e037883a 	mov	sp,fp
8111a264:	df000017 	ldw	fp,0(sp)
8111a268:	dec00104 	addi	sp,sp,4
8111a26c:	f800283a 	ret

8111a270 <vChangeIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Config for IdNFEEMaster*/
void vChangeIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111a270:	defffd04 	addi	sp,sp,-12
8111a274:	de00012e 	bgeu	sp,et,8111a27c <vChangeIdNFEEMaster+0xc>
8111a278:	003b68fa 	trap	3
8111a27c:	df000215 	stw	fp,8(sp)
8111a280:	df000204 	addi	fp,sp,8
8111a284:	e13ffe15 	stw	r4,-8(fp)
8111a288:	2805883a 	mov	r2,r5
8111a28c:	e0bfff05 	stb	r2,-4(fp)
    xFeeControlL->ucIdNFEEMaster = ucIdMaster;
8111a290:	e0bffe17 	ldw	r2,-8(fp)
8111a294:	e0ffff03 	ldbu	r3,-4(fp)
8111a298:	10c09845 	stb	r3,609(r2)
}
8111a29c:	0001883a 	nop
8111a2a0:	e037883a 	mov	sp,fp
8111a2a4:	df000017 	ldw	fp,0(sp)
8111a2a8:	dec00104 	addi	sp,sp,4
8111a2ac:	f800283a 	ret

8111a2b0 <vChangeDefaultIdNFEEMaster>:

/* Only in MEB_CONFIG */
/* Change the Default Config for IdNFEEMaster */
void vChangeDefaultIdNFEEMaster( TNFee_Control *xFeeControlL, unsigned char ucIdMaster ) {
8111a2b0:	defffd04 	addi	sp,sp,-12
8111a2b4:	de00012e 	bgeu	sp,et,8111a2bc <vChangeDefaultIdNFEEMaster+0xc>
8111a2b8:	003b68fa 	trap	3
8111a2bc:	df000215 	stw	fp,8(sp)
8111a2c0:	df000204 	addi	fp,sp,8
8111a2c4:	e13ffe15 	stw	r4,-8(fp)
8111a2c8:	2805883a 	mov	r2,r5
8111a2cc:	e0bfff05 	stb	r2,-4(fp)
    //bSaveIdNFEEMasterSDCard(ucIdMaster);
}
8111a2d0:	0001883a 	nop
8111a2d4:	e037883a 	mov	sp,fp
8111a2d8:	df000017 	ldw	fp,0(sp)
8111a2dc:	dec00104 	addi	sp,sp,4
8111a2e0:	f800283a 	ret

8111a2e4 <vInitSimucamBasicHW>:

#include "initialization_simucam.h"


void vInitSimucamBasicHW(void)
{
8111a2e4:	defffe04 	addi	sp,sp,-8
8111a2e8:	de00012e 	bgeu	sp,et,8111a2f0 <vInitSimucamBasicHW+0xc>
8111a2ec:	003b68fa 	trap	3
8111a2f0:	dfc00115 	stw	ra,4(sp)
8111a2f4:	df000015 	stw	fp,0(sp)
8111a2f8:	d839883a 	mov	fp,sp

	/* Turn Off all LEDs */
	bSetBoardLeds(LEDS_OFF, LEDS_BOARD_ALL_MASK);
8111a2fc:	01403fc4 	movi	r5,255
8111a300:	0009883a 	mov	r4,zero
8111a304:	110a2540 	call	8110a254 <bSetBoardLeds>
	bSetPainelLeds(LEDS_OFF, LEDS_PAINEL_ALL_MASK);
8111a308:	01400834 	movhi	r5,32
8111a30c:	297fffc4 	addi	r5,r5,-1
8111a310:	0009883a 	mov	r4,zero
8111a314:	110a2d40 	call	8110a2d4 <bSetPainelLeds>

	/* Turn On Power LED */
	bSetPainelLeds(LEDS_ON, LEDS_POWER_MASK);
8111a318:	01400074 	movhi	r5,1
8111a31c:	01000044 	movi	r4,1
8111a320:	110a2d40 	call	8110a2d4 <bSetPainelLeds>

	/* Configure Seven Segments Display */
	bSSDisplayConfig(SSDP_NORMAL_MODE);
8111a324:	0009883a 	mov	r4,zero
8111a328:	110b8b00 	call	8110b8b0 <bSSDisplayConfig>
	bSSDisplayUpdate(0);
8111a32c:	0009883a 	mov	r4,zero
8111a330:	110b9800 	call	8110b980 <bSSDisplayUpdate>

	vRstcHoldDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111a334:	01008004 	movi	r4,512
8111a338:	110b4100 	call	8110b410 <vRstcHoldDeviceReset>
	vRstcReleaseDeviceReset(RSTC_DEV_RS232_RST_CTRL_MSK);
8111a33c:	01008004 	movi	r4,512
8111a340:	110b39c0 	call	8110b39c <vRstcReleaseDeviceReset>

}
8111a344:	0001883a 	nop
8111a348:	e037883a 	mov	sp,fp
8111a34c:	dfc00117 	ldw	ra,4(sp)
8111a350:	df000017 	ldw	fp,0(sp)
8111a354:	dec00204 	addi	sp,sp,8
8111a358:	f800283a 	ret

8111a35c <bLogWriteSDCard>:

#include "log_manager_simucam.h"


bool bLogWriteSDCard ( const char * cDataIn, const char * cFilename )
{
8111a35c:	defffd04 	addi	sp,sp,-12
8111a360:	de00012e 	bgeu	sp,et,8111a368 <bLogWriteSDCard+0xc>
8111a364:	003b68fa 	trap	3
8111a368:	df000215 	stw	fp,8(sp)
8111a36c:	df000204 	addi	fp,sp,8
8111a370:	e13ffe15 	stw	r4,-8(fp)
8111a374:	e17fff15 	stw	r5,-4(fp)

	return TRUE;
8111a378:	00800044 	movi	r2,1
}
8111a37c:	e037883a 	mov	sp,fp
8111a380:	df000017 	ldw	fp,0(sp)
8111a384:	dec00104 	addi	sp,sp,4
8111a388:	f800283a 	ret

8111a38c <vLogWriteNUC>:

/* Prefer to use directly vSendLog, if there's any error use this function */
void vLogWriteNUC ( const char * cDataIn )
{
8111a38c:	deffe004 	addi	sp,sp,-128
8111a390:	de00012e 	bgeu	sp,et,8111a398 <vLogWriteNUC+0xc>
8111a394:	003b68fa 	trap	3
8111a398:	dfc01f15 	stw	ra,124(sp)
8111a39c:	df001e15 	stw	fp,120(sp)
8111a3a0:	df001e04 	addi	fp,sp,120
8111a3a4:	e13fff15 	stw	r4,-4(fp)
	char cTemp[114] = "";
8111a3a8:	e03fe215 	stw	zero,-120(fp)
8111a3ac:	e0bfe304 	addi	r2,fp,-116
8111a3b0:	00c01b84 	movi	r3,110
8111a3b4:	180d883a 	mov	r6,r3
8111a3b8:	000b883a 	mov	r5,zero
8111a3bc:	1009883a 	mov	r4,r2
8111a3c0:	111dc180 	call	8111dc18 <memset>
	memset(cTemp,0,114);
8111a3c4:	01801c84 	movi	r6,114
8111a3c8:	000b883a 	mov	r5,zero
8111a3cc:	e13fe204 	addi	r4,fp,-120
8111a3d0:	111dc180 	call	8111dc18 <memset>
	memcpy(cTemp,cDataIn, min_sim( strlen(cDataIn), 113 ) ); /* 113 to let a zero terminator in the worst case (truc the message) */
8111a3d4:	e13fff17 	ldw	r4,-4(fp)
8111a3d8:	111e5bc0 	call	8111e5bc <strlen>
8111a3dc:	10801c68 	cmpgeui	r2,r2,113
8111a3e0:	1000031e 	bne	r2,zero,8111a3f0 <vLogWriteNUC+0x64>
8111a3e4:	e13fff17 	ldw	r4,-4(fp)
8111a3e8:	111e5bc0 	call	8111e5bc <strlen>
8111a3ec:	00000106 	br	8111a3f4 <vLogWriteNUC+0x68>
8111a3f0:	00801c44 	movi	r2,113
8111a3f4:	100d883a 	mov	r6,r2
8111a3f8:	e17fff17 	ldw	r5,-4(fp)
8111a3fc:	e13fe204 	addi	r4,fp,-120
8111a400:	111dac80 	call	8111dac8 <memcpy>
	vSendLog ( cDataIn );
8111a404:	e13fff17 	ldw	r4,-4(fp)
8111a408:	11165500 	call	81116550 <vSendLog>
}
8111a40c:	0001883a 	nop
8111a410:	e037883a 	mov	sp,fp
8111a414:	dfc00117 	ldw	ra,4(sp)
8111a418:	df000017 	ldw	fp,0(sp)
8111a41c:	dec00204 	addi	sp,sp,8
8111a420:	f800283a 	ret

8111a424 <vSimucamStructureInit>:
 */


#include "meb.h"

void vSimucamStructureInit( TSimucam_MEB *xMeb ) {
8111a424:	defffd04 	addi	sp,sp,-12
8111a428:	de00012e 	bgeu	sp,et,8111a430 <vSimucamStructureInit+0xc>
8111a42c:	003b68fa 	trap	3
8111a430:	dfc00215 	stw	ra,8(sp)
8111a434:	df000115 	stw	fp,4(sp)
8111a438:	df000104 	addi	fp,sp,4
8111a43c:	e13fff15 	stw	r4,-4(fp)
    // LoadTypeOfFeeSDCard();
    // todo: Load from SDCard for now is Hardcoded to Normal FEE
    xMeb->eType = sNormalFEE;
8111a440:	e0bfff17 	ldw	r2,-4(fp)
8111a444:	10000015 	stw	zero,0(r2)
    
    /* Simucam start in the Meb Config Mode */
    xMeb->eMode = sMebInit;
8111a448:	e0bfff17 	ldw	r2,-4(fp)
8111a44c:	10000115 	stw	zero,4(r2)

    /* Load EP */
    vLoadDefaultEPValue( xMeb );
8111a450:	e13fff17 	ldw	r4,-4(fp)
8111a454:	111a5100 	call	8111a510 <vLoadDefaultEPValue>
    /* Load RT */
    vLoadDefaultRTValue( xMeb );
8111a458:	e13fff17 	ldw	r4,-4(fp)
8111a45c:	111a5b40 	call	8111a5b4 <vLoadDefaultRTValue>
    /* Load SyncSource */
    vLoadDefaultSyncSource( xMeb );
8111a460:	e13fff17 	ldw	r4,-4(fp)
8111a464:	111a65c0 	call	8111a65c <vLoadDefaultSyncSource>
    /* Load Default Config for Auto Reset Mode */
    vLoadDefaultAutoResetSync( xMeb );
8111a468:	e13fff17 	ldw	r4,-4(fp)
8111a46c:	111a6fc0 	call	8111a6fc <vLoadDefaultAutoResetSync>

    /* todo: Change for change functions */
    xMeb->fLineTransferTime = 0;
8111a470:	e0bfff17 	ldw	r2,-4(fp)
8111a474:	10000615 	stw	zero,24(r2)
    xMeb->fPixelTransferTime = 0;
8111a478:	e0bfff17 	ldw	r2,-4(fp)
8111a47c:	10000715 	stw	zero,28(r2)
    xMeb->usiDelaySyncReset = 500; /* milliseconds */
8111a480:	e0bfff17 	ldw	r2,-4(fp)
8111a484:	00c07d04 	movi	r3,500
8111a488:	10c0050d 	sth	r3,20(r2)

    /* Reseting swap memory mechanism */
    xMeb->ucActualDDR = 0;
8111a48c:	e0bfff17 	ldw	r2,-4(fp)
8111a490:	10000205 	stb	zero,8(r2)
    xMeb->ucNextDDR = 1;
8111a494:	e0bfff17 	ldw	r2,-4(fp)
8111a498:	00c00044 	movi	r3,1
8111a49c:	10c00245 	stb	r3,9(r2)

    xMeb->xFeeControl.pActualMem = &xMeb->ucActualDDR;
8111a4a0:	e0bfff17 	ldw	r2,-4(fp)
8111a4a4:	10c00204 	addi	r3,r2,8
8111a4a8:	e0bfff17 	ldw	r2,-4(fp)
8111a4ac:	10c0a715 	stw	r3,668(r2)
    xMeb->xDataControl.pNextMem = &xMeb->ucNextDDR;
8111a4b0:	e0bfff17 	ldw	r2,-4(fp)
8111a4b4:	10c00244 	addi	r3,r2,9
8111a4b8:	e0bfff17 	ldw	r2,-4(fp)
8111a4bc:	10c01115 	stw	r3,68(r2)

    /* Verify if if a Fast or Normal */
    if ( xMeb->eType == sNormalFEE ) {
8111a4c0:	e0bfff17 	ldw	r2,-4(fp)
8111a4c4:	10800017 	ldw	r2,0(r2)
8111a4c8:	10000b1e 	bne	r2,zero,8111a4f8 <vSimucamStructureInit+0xd4>
        /* Are Normal Fee instances */
    	vNFeeControlInit( &xMeb->xFeeControl );
8111a4cc:	e0bfff17 	ldw	r2,-4(fp)
8111a4d0:	10801204 	addi	r2,r2,72
8111a4d4:	1009883a 	mov	r4,r2
8111a4d8:	111a0bc0 	call	8111a0bc <vNFeeControlInit>
        vDataControllerInit( &xMeb->xDataControl, &xMeb->xFeeControl );
8111a4dc:	e0bfff17 	ldw	r2,-4(fp)
8111a4e0:	10c00a04 	addi	r3,r2,40
8111a4e4:	e0bfff17 	ldw	r2,-4(fp)
8111a4e8:	10801204 	addi	r2,r2,72
8111a4ec:	100b883a 	mov	r5,r2
8111a4f0:	1809883a 	mov	r4,r3
8111a4f4:	111791c0 	call	8111791c <vDataControllerInit>


    /* At this point all structures that manage the aplication of Simucam and FEE are initialized, the tasks could start now */


}
8111a4f8:	0001883a 	nop
8111a4fc:	e037883a 	mov	sp,fp
8111a500:	dfc00117 	ldw	ra,4(sp)
8111a504:	df000017 	ldw	fp,0(sp)
8111a508:	dec00204 	addi	sp,sp,8
8111a50c:	f800283a 	ret

8111a510 <vLoadDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultEPValue( TSimucam_MEB *xMeb ) {
8111a510:	defffe04 	addi	sp,sp,-8
8111a514:	de00012e 	bgeu	sp,et,8111a51c <vLoadDefaultEPValue+0xc>
8111a518:	003b68fa 	trap	3
8111a51c:	df000115 	stw	fp,4(sp)
8111a520:	df000104 	addi	fp,sp,4
8111a524:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucEP = 25;
8111a528:	e0bfff17 	ldw	r2,-4(fp)
8111a52c:	00d07234 	movhi	r3,16840
8111a530:	10c00315 	stw	r3,12(r2)
}
8111a534:	0001883a 	nop
8111a538:	e037883a 	mov	sp,fp
8111a53c:	df000017 	ldw	fp,0(sp)
8111a540:	dec00104 	addi	sp,sp,4
8111a544:	f800283a 	ret

8111a548 <vChangeEPValue>:

/* Only in MEB_CONFIG */
/* Change the active value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111a548:	defffd04 	addi	sp,sp,-12
8111a54c:	de00012e 	bgeu	sp,et,8111a554 <vChangeEPValue+0xc>
8111a550:	003b68fa 	trap	3
8111a554:	df000215 	stw	fp,8(sp)
8111a558:	df000204 	addi	fp,sp,8
8111a55c:	e13ffe15 	stw	r4,-8(fp)
8111a560:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucEP = ucValue;
8111a564:	e0bffe17 	ldw	r2,-8(fp)
8111a568:	e0ffff17 	ldw	r3,-4(fp)
8111a56c:	10c00315 	stw	r3,12(r2)
}
8111a570:	0001883a 	nop
8111a574:	e037883a 	mov	sp,fp
8111a578:	df000017 	ldw	fp,0(sp)
8111a57c:	dec00104 	addi	sp,sp,4
8111a580:	f800283a 	ret

8111a584 <vChangeDefaultEPValue>:

/* Only in MEB_CONFIG */
/* Change the default value of EP - Exposure period [NFEESIM-UR-447] */
void vChangeDefaultEPValue( TSimucam_MEB *xMeb, float ucValue ) {
8111a584:	defffd04 	addi	sp,sp,-12
8111a588:	de00012e 	bgeu	sp,et,8111a590 <vChangeDefaultEPValue+0xc>
8111a58c:	003b68fa 	trap	3
8111a590:	df000215 	stw	fp,8(sp)
8111a594:	df000204 	addi	fp,sp,8
8111a598:	e13ffe15 	stw	r4,-8(fp)
8111a59c:	e17fff15 	stw	r5,-4(fp)
    //bSaveEPSDCard(ucValue);
}
8111a5a0:	0001883a 	nop
8111a5a4:	e037883a 	mov	sp,fp
8111a5a8:	df000017 	ldw	fp,0(sp)
8111a5ac:	dec00104 	addi	sp,sp,4
8111a5b0:	f800283a 	ret

8111a5b4 <vLoadDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Load Default value of EP - Exposure period [NFEESIM-UR-447] */
void vLoadDefaultRTValue( TSimucam_MEB *xMeb ) {
8111a5b4:	defffe04 	addi	sp,sp,-8
8111a5b8:	de00012e 	bgeu	sp,et,8111a5c0 <vLoadDefaultRTValue+0xc>
8111a5bc:	003b68fa 	trap	3
8111a5c0:	df000115 	stw	fp,4(sp)
8111a5c4:	df000104 	addi	fp,sp,4
8111a5c8:	e13fff15 	stw	r4,-4(fp)
    //bGetEPSDCard();
    //todo: For now is hardcoded
    xMeb->ucRT = 3.9;
8111a5cc:	e0ffff17 	ldw	r3,-4(fp)
8111a5d0:	00901eb4 	movhi	r2,16506
8111a5d4:	10a66684 	addi	r2,r2,-26214
8111a5d8:	18800415 	stw	r2,16(r3)
}
8111a5dc:	0001883a 	nop
8111a5e0:	e037883a 	mov	sp,fp
8111a5e4:	df000017 	ldw	fp,0(sp)
8111a5e8:	dec00104 	addi	sp,sp,4
8111a5ec:	f800283a 	ret

8111a5f0 <vChangeRTValue>:

/* Only in MEB_CONFIG */
/* Change the active value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111a5f0:	defffd04 	addi	sp,sp,-12
8111a5f4:	de00012e 	bgeu	sp,et,8111a5fc <vChangeRTValue+0xc>
8111a5f8:	003b68fa 	trap	3
8111a5fc:	df000215 	stw	fp,8(sp)
8111a600:	df000204 	addi	fp,sp,8
8111a604:	e13ffe15 	stw	r4,-8(fp)
8111a608:	e17fff15 	stw	r5,-4(fp)
    xMeb->ucRT = ucValue;
8111a60c:	e0bffe17 	ldw	r2,-8(fp)
8111a610:	e0ffff17 	ldw	r3,-4(fp)
8111a614:	10c00415 	stw	r3,16(r2)
}
8111a618:	0001883a 	nop
8111a61c:	e037883a 	mov	sp,fp
8111a620:	df000017 	ldw	fp,0(sp)
8111a624:	dec00104 	addi	sp,sp,4
8111a628:	f800283a 	ret

8111a62c <vChangeDefaultRTValue>:

/* Only in MEB_CONFIG */
/* Change the default value of RT - CCD readout time [NFEESIM-UR-447] */
void vChangeDefaultRTValue( TSimucam_MEB *xMeb, float ucValue ) {
8111a62c:	defffd04 	addi	sp,sp,-12
8111a630:	de00012e 	bgeu	sp,et,8111a638 <vChangeDefaultRTValue+0xc>
8111a634:	003b68fa 	trap	3
8111a638:	df000215 	stw	fp,8(sp)
8111a63c:	df000204 	addi	fp,sp,8
8111a640:	e13ffe15 	stw	r4,-8(fp)
8111a644:	e17fff15 	stw	r5,-4(fp)
    //bSaveRTSDCard(ucValue);
}
8111a648:	0001883a 	nop
8111a64c:	e037883a 	mov	sp,fp
8111a650:	df000017 	ldw	fp,0(sp)
8111a654:	dec00104 	addi	sp,sp,4
8111a658:	f800283a 	ret

8111a65c <vLoadDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Load Default Config Sync - Internal or external */
void vLoadDefaultSyncSource( TSimucam_MEB *xMeb ) {
8111a65c:	defffe04 	addi	sp,sp,-8
8111a660:	de00012e 	bgeu	sp,et,8111a668 <vLoadDefaultSyncSource+0xc>
8111a664:	003b68fa 	trap	3
8111a668:	df000115 	stw	fp,4(sp)
8111a66c:	df000104 	addi	fp,sp,4
8111a670:	e13fff15 	stw	r4,-4(fp)
    //bGetSyncSourceSDCard();
    //todo: For now is hardcoded
    xMeb->eSync = sInternal;
8111a674:	e0bfff17 	ldw	r2,-4(fp)
8111a678:	10000815 	stw	zero,32(r2)
}
8111a67c:	0001883a 	nop
8111a680:	e037883a 	mov	sp,fp
8111a684:	df000017 	ldw	fp,0(sp)
8111a688:	dec00104 	addi	sp,sp,4
8111a68c:	f800283a 	ret

8111a690 <vChangeSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Active Config Sync - Internal or external */
void vChangeSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111a690:	defffd04 	addi	sp,sp,-12
8111a694:	de00012e 	bgeu	sp,et,8111a69c <vChangeSyncSource+0xc>
8111a698:	003b68fa 	trap	3
8111a69c:	df000215 	stw	fp,8(sp)
8111a6a0:	df000204 	addi	fp,sp,8
8111a6a4:	e13ffe15 	stw	r4,-8(fp)
8111a6a8:	e17fff15 	stw	r5,-4(fp)
    xMeb->eSync = eSource;
8111a6ac:	e0bffe17 	ldw	r2,-8(fp)
8111a6b0:	e0ffff17 	ldw	r3,-4(fp)
8111a6b4:	10c00815 	stw	r3,32(r2)
}
8111a6b8:	0001883a 	nop
8111a6bc:	e037883a 	mov	sp,fp
8111a6c0:	df000017 	ldw	fp,0(sp)
8111a6c4:	dec00104 	addi	sp,sp,4
8111a6c8:	f800283a 	ret

8111a6cc <vChangeDefaultSyncSource>:

/* Only in MEB_CONFIG */
/* Change the Default Config Sync - Internal or external */
void vChangeDefaultSyncSource( TSimucam_MEB *xMeb, tSimucamSync eSource ) {
8111a6cc:	defffd04 	addi	sp,sp,-12
8111a6d0:	de00012e 	bgeu	sp,et,8111a6d8 <vChangeDefaultSyncSource+0xc>
8111a6d4:	003b68fa 	trap	3
8111a6d8:	df000215 	stw	fp,8(sp)
8111a6dc:	df000204 	addi	fp,sp,8
8111a6e0:	e13ffe15 	stw	r4,-8(fp)
8111a6e4:	e17fff15 	stw	r5,-4(fp)
    //bSaveSyncSourceSDCard(eSource);
}
8111a6e8:	0001883a 	nop
8111a6ec:	e037883a 	mov	sp,fp
8111a6f0:	df000017 	ldw	fp,0(sp)
8111a6f4:	dec00104 	addi	sp,sp,4
8111a6f8:	f800283a 	ret

8111a6fc <vLoadDefaultAutoResetSync>:


/* Only in MEB_CONFIG */
/* Load Default Config for AutoResetSync */
void vLoadDefaultAutoResetSync( TSimucam_MEB *xMeb ) {
8111a6fc:	defffe04 	addi	sp,sp,-8
8111a700:	de00012e 	bgeu	sp,et,8111a708 <vLoadDefaultAutoResetSync+0xc>
8111a704:	003b68fa 	trap	3
8111a708:	df000115 	stw	fp,4(sp)
8111a70c:	df000104 	addi	fp,sp,4
8111a710:	e13fff15 	stw	r4,-4(fp)
    //bGetAutoResetSyncSDCard();
    //todo: For now is hardcoded
    xMeb->bAutoResetSyncMode = TRUE;
8111a714:	e0bfff17 	ldw	r2,-4(fp)
8111a718:	00c00044 	movi	r3,1
8111a71c:	10c00915 	stw	r3,36(r2)
}
8111a720:	0001883a 	nop
8111a724:	e037883a 	mov	sp,fp
8111a728:	df000017 	ldw	fp,0(sp)
8111a72c:	dec00104 	addi	sp,sp,4
8111a730:	f800283a 	ret

8111a734 <vChangeAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Config for AutoResetSync*/
void vChangeAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111a734:	defffd04 	addi	sp,sp,-12
8111a738:	de00012e 	bgeu	sp,et,8111a740 <vChangeAutoResetSync+0xc>
8111a73c:	003b68fa 	trap	3
8111a740:	df000215 	stw	fp,8(sp)
8111a744:	df000204 	addi	fp,sp,8
8111a748:	e13ffe15 	stw	r4,-8(fp)
8111a74c:	e17fff15 	stw	r5,-4(fp)
    xMeb->bAutoResetSyncMode = bAutoReset;
8111a750:	e0bffe17 	ldw	r2,-8(fp)
8111a754:	e0ffff17 	ldw	r3,-4(fp)
8111a758:	10c00915 	stw	r3,36(r2)
}
8111a75c:	0001883a 	nop
8111a760:	e037883a 	mov	sp,fp
8111a764:	df000017 	ldw	fp,0(sp)
8111a768:	dec00104 	addi	sp,sp,4
8111a76c:	f800283a 	ret

8111a770 <vChangeDefaultAutoResetSync>:

/* Only in MEB_CONFIG */
/* Change the Default Config for AutoResetSync */
void vChangeDefaultAutoResetSync( TSimucam_MEB *xMeb, bool bAutoReset ) {
8111a770:	defffd04 	addi	sp,sp,-12
8111a774:	de00012e 	bgeu	sp,et,8111a77c <vChangeDefaultAutoResetSync+0xc>
8111a778:	003b68fa 	trap	3
8111a77c:	df000215 	stw	fp,8(sp)
8111a780:	df000204 	addi	fp,sp,8
8111a784:	e13ffe15 	stw	r4,-8(fp)
8111a788:	e17fff15 	stw	r5,-4(fp)
    //bSaveAutoResetSyncSDCard(bAutoReset);
}
8111a78c:	0001883a 	nop
8111a790:	e037883a 	mov	sp,fp
8111a794:	df000017 	ldw	fp,0(sp)
8111a798:	dec00104 	addi	sp,sp,4
8111a79c:	f800283a 	ret

8111a7a0 <vSyncReset>:


/* Any mode */
/* Synchronization Reset */
void vSyncReset( TSimucam_MEB *xMeb, float ufSynchDelay ) {
8111a7a0:	defffc04 	addi	sp,sp,-16
8111a7a4:	de00012e 	bgeu	sp,et,8111a7ac <vSyncReset+0xc>
8111a7a8:	003b68fa 	trap	3
8111a7ac:	dfc00315 	stw	ra,12(sp)
8111a7b0:	df000215 	stw	fp,8(sp)
8111a7b4:	df000204 	addi	fp,sp,8
8111a7b8:	e13ffe15 	stw	r4,-8(fp)
8111a7bc:	e17fff15 	stw	r5,-4(fp)
    // Stop all transmission

    // Put all NFEE in Stand-by mode, if not in Config mode

    // Reset the time code
    vResetTimeCode(&xMeb->xFeeControl);
8111a7c0:	e0bffe17 	ldw	r2,-8(fp)
8111a7c4:	10801204 	addi	r2,r2,72
8111a7c8:	1009883a 	mov	r4,r2
8111a7cc:	111a2080 	call	8111a208 <vResetTimeCode>

    // Release a synchronization signal

    // Start new cycle

}
8111a7d0:	0001883a 	nop
8111a7d4:	e037883a 	mov	sp,fp
8111a7d8:	dfc00117 	ldw	ra,4(sp)
8111a7dc:	df000017 	ldw	fp,0(sp)
8111a7e0:	dec00204 	addi	sp,sp,8
8111a7e4:	f800283a 	ret

8111a7e8 <pattern_createPattern>:
#include "pattern.h"

alt_u32 pattern_createPattern(alt_u8 mem_number, alt_u32 mem_offset, alt_u8 ccd_number, alt_u8 ccd_side, alt_u32 width_cols, alt_u32 height_rows)
{
8111a7e8:	defff004 	addi	sp,sp,-64
8111a7ec:	de00012e 	bgeu	sp,et,8111a7f4 <pattern_createPattern+0xc>
8111a7f0:	003b68fa 	trap	3
8111a7f4:	dfc00f15 	stw	ra,60(sp)
8111a7f8:	df000e15 	stw	fp,56(sp)
8111a7fc:	dcc00d15 	stw	r19,52(sp)
8111a800:	dc800c15 	stw	r18,48(sp)
8111a804:	dc400b15 	stw	r17,44(sp)
8111a808:	dc000a15 	stw	r16,40(sp)
8111a80c:	df000e04 	addi	fp,sp,56
8111a810:	e17ff915 	stw	r5,-28(fp)
8111a814:	3007883a 	mov	r3,r6
8111a818:	3805883a 	mov	r2,r7
8111a81c:	e13ff805 	stb	r4,-32(fp)
8111a820:	e0fffa05 	stb	r3,-24(fp)
8111a824:	e0bffb05 	stb	r2,-20(fp)
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
8111a828:	e0bff803 	ldbu	r2,-32(fp)
8111a82c:	1009883a 	mov	r4,r2
8111a830:	11014c80 	call	811014c8 <bDdr2SwitchMemory>
	alt_u32 offset = mem_offset;
8111a834:	e0bff917 	ldw	r2,-28(fp)
8111a838:	e0bff215 	stw	r2,-56(fp)
	alt_u8 i = 0;
8111a83c:	e03ff305 	stb	zero,-52(fp)
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
8111a840:	e0bff217 	ldw	r2,-56(fp)
8111a844:	e0bff415 	stw	r2,-48(fp)
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111a848:	e03ff515 	stw	zero,-44(fp)
8111a84c:	00003606 	br	8111a928 <pattern_createPattern+0x140>
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111a850:	e03ff615 	stw	zero,-40(fp)
8111a854:	00002e06 	br	8111a910 <pattern_createPattern+0x128>
		{
			if (i == 64) // filled one block of memory, time to save full pattern and readress the structure
8111a858:	e0bff303 	ldbu	r2,-52(fp)
8111a85c:	10801018 	cmpnei	r2,r2,64
8111a860:	10000b1e 	bne	r2,zero,8111a890 <pattern_createPattern+0xa8>
			{
				pxPixelData->ulliMask = PATTERN_MEMORY_FULLMASK;
8111a864:	e0bff417 	ldw	r2,-48(fp)
8111a868:	00ffffc4 	movi	r3,-1
8111a86c:	10c02015 	stw	r3,128(r2)
8111a870:	00ffffc4 	movi	r3,-1
8111a874:	10c02115 	stw	r3,132(r2)
				offset += sizeof(TSdmaPixelDataBlock);
8111a878:	e0bff217 	ldw	r2,-56(fp)
8111a87c:	10802204 	addi	r2,r2,136
8111a880:	e0bff215 	stw	r2,-56(fp)
				pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset);
8111a884:	e0bff217 	ldw	r2,-56(fp)
8111a888:	e0bff415 	stw	r2,-48(fp)
				i = 0;
8111a88c:	e03ff305 	stb	zero,-52(fp)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
8111a890:	e0bff303 	ldbu	r2,-52(fp)
8111a894:	10c00044 	addi	r3,r2,1
8111a898:	e0fff305 	stb	r3,-52(fp)
8111a89c:	10803fcc 	andi	r2,r2,255
8111a8a0:	e0fffa03 	ldbu	r3,-24(fp)
8111a8a4:	18c000cc 	andi	r3,r3,3
8111a8a8:	180692fa 	slli	r3,r3,11
8111a8ac:	1809883a 	mov	r4,r3
8111a8b0:	00f80004 	movi	r3,-8192
8111a8b4:	20c6b03a 	or	r3,r4,r3
8111a8b8:	1809883a 	mov	r4,r3
8111a8bc:	e0fffb03 	ldbu	r3,-20(fp)
8111a8c0:	18c0004c 	andi	r3,r3,1
8111a8c4:	180692ba 	slli	r3,r3,10
8111a8c8:	20c6b03a 	or	r3,r4,r3
8111a8cc:	1809883a 	mov	r4,r3
8111a8d0:	e0fff517 	ldw	r3,-44(fp)
8111a8d4:	18c007cc 	andi	r3,r3,31
8111a8d8:	1806917a 	slli	r3,r3,5
8111a8dc:	20c6b03a 	or	r3,r4,r3
8111a8e0:	1809883a 	mov	r4,r3
8111a8e4:	e0fff617 	ldw	r3,-40(fp)
8111a8e8:	18c007cc 	andi	r3,r3,31
8111a8ec:	20c6b03a 	or	r3,r4,r3
8111a8f0:	1809883a 	mov	r4,r3
8111a8f4:	e0fff417 	ldw	r3,-48(fp)
8111a8f8:	1085883a 	add	r2,r2,r2
8111a8fc:	1885883a 	add	r2,r3,r2
8111a900:	1100000d 	sth	r4,0(r2)
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
	{
		for (alt_u32 col = 0; col < width_cols; col++) // column sweep
8111a904:	e0bff617 	ldw	r2,-40(fp)
8111a908:	10800044 	addi	r2,r2,1
8111a90c:	e0bff615 	stw	r2,-40(fp)
8111a910:	e0fff617 	ldw	r3,-40(fp)
8111a914:	e0800217 	ldw	r2,8(fp)
8111a918:	18bfcf36 	bltu	r3,r2,8111a858 <__reset+0xfb0fa858>
{
	bDdr2SwitchMemory(mem_number); // Switch to the desired memory
	alt_u32 offset = mem_offset;
	alt_u8 i = 0;
	TSdmaPixelDataBlock *pxPixelData = (TSdmaPixelDataBlock *) (DDR2_EXT_ADDR_WINDOWED_BASE + offset); // Address the structure
	for (alt_u32 row = 0; row < height_rows; row++) // row sweep
8111a91c:	e0bff517 	ldw	r2,-44(fp)
8111a920:	10800044 	addi	r2,r2,1
8111a924:	e0bff515 	stw	r2,-44(fp)
8111a928:	e0fff517 	ldw	r3,-44(fp)
8111a92c:	e0800317 	ldw	r2,12(fp)
8111a930:	18bfc736 	bltu	r3,r2,8111a850 <__reset+0xfb0fa850>
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111a934:	e0bff303 	ldbu	r2,-52(fp)
8111a938:	e0bff705 	stb	r2,-36(fp)
8111a93c:	00000806 	br	8111a960 <pattern_createPattern+0x178>
	{
		pxPixelData->usiPixel[j] = 0;
8111a940:	e0bff703 	ldbu	r2,-36(fp)
8111a944:	e0fff417 	ldw	r3,-48(fp)
8111a948:	1085883a 	add	r2,r2,r2
8111a94c:	1885883a 	add	r2,r3,r2
8111a950:	1000000d 	sth	zero,0(r2)
			}
			// Generate pattern pixel (16-bits)
			pxPixelData->usiPixel[i++] = PATTERN_MASK_TIMECODE(PATTERN_TIMECODE_VALUE) | PATTERN_MASK_CCDNUMBER(ccd_number) | PATTERN_MASK_CCDSIDE(ccd_side) | PATTERN_MASK_ROW(row) | PATTERN_MASK_COLUMN(col);
		}
	}
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
8111a954:	e0bff703 	ldbu	r2,-36(fp)
8111a958:	10800044 	addi	r2,r2,1
8111a95c:	e0bff705 	stb	r2,-36(fp)
8111a960:	e0bff703 	ldbu	r2,-36(fp)
8111a964:	10801030 	cmpltui	r2,r2,64
8111a968:	103ff51e 	bne	r2,zero,8111a940 <__reset+0xfb0fa940>
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
8111a96c:	e0bff417 	ldw	r2,-48(fp)
8111a970:	10002015 	stw	zero,128(r2)
8111a974:	10002115 	stw	zero,132(r2)
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111a978:	e03ff745 	stb	zero,-35(fp)
8111a97c:	00001106 	br	8111a9c4 <pattern_createPattern+0x1dc>
	{
		pxPixelData->ulliMask |= 1 << j;
8111a980:	e13ff417 	ldw	r4,-48(fp)
8111a984:	20802017 	ldw	r2,128(r4)
8111a988:	20c02117 	ldw	r3,132(r4)
8111a98c:	e13ff743 	ldbu	r4,-35(fp)
8111a990:	01400044 	movi	r5,1
8111a994:	2908983a 	sll	r4,r5,r4
8111a998:	2025883a 	mov	r18,r4
8111a99c:	2009d7fa 	srai	r4,r4,31
8111a9a0:	2027883a 	mov	r19,r4
8111a9a4:	14a0b03a 	or	r16,r2,r18
8111a9a8:	1ce2b03a 	or	r17,r3,r19
8111a9ac:	e0bff417 	ldw	r2,-48(fp)
8111a9b0:	14002015 	stw	r16,128(r2)
8111a9b4:	14402115 	stw	r17,132(r2)
	for (alt_u8 j = i; j < 64; j++) // fill the rest of memory block with zeroes
	{
		pxPixelData->usiPixel[j] = 0;
	}
	pxPixelData->ulliMask = 0;
	for (alt_u8 j = 0; j < i; j++) // create the mask (i.e.: if i stops at block 3 , the mask will be 0b00...0111)
8111a9b8:	e0bff743 	ldbu	r2,-35(fp)
8111a9bc:	10800044 	addi	r2,r2,1
8111a9c0:	e0bff745 	stb	r2,-35(fp)
8111a9c4:	e0fff743 	ldbu	r3,-35(fp)
8111a9c8:	e0bff303 	ldbu	r2,-52(fp)
8111a9cc:	18bfec36 	bltu	r3,r2,8111a980 <__reset+0xfb0fa980>
	{
		pxPixelData->ulliMask |= 1 << j;
	}
	offset += sizeof(TSdmaPixelDataBlock); // increment offset so we return the next available memory block
8111a9d0:	e0bff217 	ldw	r2,-56(fp)
8111a9d4:	10802204 	addi	r2,r2,136
8111a9d8:	e0bff215 	stw	r2,-56(fp)
	return offset;
8111a9dc:	e0bff217 	ldw	r2,-56(fp)
}
8111a9e0:	e6fffc04 	addi	sp,fp,-16
8111a9e4:	dfc00517 	ldw	ra,20(sp)
8111a9e8:	df000417 	ldw	fp,16(sp)
8111a9ec:	dcc00317 	ldw	r19,12(sp)
8111a9f0:	dc800217 	ldw	r18,8(sp)
8111a9f4:	dc400117 	ldw	r17,4(sp)
8111a9f8:	dc000017 	ldw	r16,0(sp)
8111a9fc:	dec00604 	addi	sp,sp,24
8111aa00:	f800283a 	ret

8111aa04 <bSDcardIsPresent>:
#include "sdcard_file_manager.h"


TSDHandle xSdHandle;

bool bSDcardIsPresent( void ){
8111aa04:	defffe04 	addi	sp,sp,-8
8111aa08:	de00012e 	bgeu	sp,et,8111aa10 <bSDcardIsPresent+0xc>
8111aa0c:	003b68fa 	trap	3
8111aa10:	dfc00115 	stw	ra,4(sp)
8111aa14:	df000015 	stw	fp,0(sp)
8111aa18:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_Present();
8111aa1c:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
}
8111aa20:	e037883a 	mov	sp,fp
8111aa24:	dfc00117 	ldw	ra,4(sp)
8111aa28:	df000017 	ldw	fp,0(sp)
8111aa2c:	dec00204 	addi	sp,sp,8
8111aa30:	f800283a 	ret

8111aa34 <bSDcardFAT16Check>:

bool bSDcardFAT16Check( void ){
8111aa34:	defffe04 	addi	sp,sp,-8
8111aa38:	de00012e 	bgeu	sp,et,8111aa40 <bSDcardFAT16Check+0xc>
8111aa3c:	003b68fa 	trap	3
8111aa40:	dfc00115 	stw	ra,4(sp)
8111aa44:	df000015 	stw	fp,0(sp)
8111aa48:	d839883a 	mov	fp,sp
	return alt_up_sd_card_is_FAT16();
8111aa4c:	11410000 	call	81141000 <alt_up_sd_card_is_FAT16>
}
8111aa50:	e037883a 	mov	sp,fp
8111aa54:	dfc00117 	ldw	ra,4(sp)
8111aa58:	df000017 	ldw	fp,0(sp)
8111aa5c:	dec00204 	addi	sp,sp,8
8111aa60:	f800283a 	ret

8111aa64 <bInitializeSDCard>:

bool bInitializeSDCard( void ){
8111aa64:	defffd04 	addi	sp,sp,-12
8111aa68:	de00012e 	bgeu	sp,et,8111aa70 <bInitializeSDCard+0xc>
8111aa6c:	003b68fa 	trap	3
8111aa70:	dfc00215 	stw	ra,8(sp)
8111aa74:	df000115 	stw	fp,4(sp)
8111aa78:	df000104 	addi	fp,sp,4
	bool bSucess = FALSE;
8111aa7c:	e03fff15 	stw	zero,-4(fp)
	xSdHandle.deviceHandle = NULL;
8111aa80:	d0207315 	stw	zero,-32308(gp)

	xSdHandle.deviceHandle = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
8111aa84:	01204574 	movhi	r4,33045
8111aa88:	212f7504 	addi	r4,r4,-16940
8111aa8c:	1140e700 	call	81140e70 <alt_up_sd_card_open_dev>
8111aa90:	d0a07315 	stw	r2,-32308(gp)
	if ( xSdHandle.deviceHandle != NULL ) {
8111aa94:	d0a07317 	ldw	r2,-32308(gp)
8111aa98:	10002226 	beq	r2,zero,8111ab24 <bInitializeSDCard+0xc0>

		bSucess = bSDcardIsPresent();
8111aa9c:	111aa040 	call	8111aa04 <bSDcardIsPresent>
8111aaa0:	e0bfff15 	stw	r2,-4(fp)
		if ( bSucess ) {
8111aaa4:	e0bfff17 	ldw	r2,-4(fp)
8111aaa8:	10001626 	beq	r2,zero,8111ab04 <bInitializeSDCard+0xa0>
			bSucess = bSDcardFAT16Check();
8111aaac:	111aa340 	call	8111aa34 <bSDcardFAT16Check>
8111aab0:	e0bfff15 	stw	r2,-4(fp)
			if ( bSucess ) {
8111aab4:	e0bfff17 	ldw	r2,-4(fp)
8111aab8:	10000a26 	beq	r2,zero,8111aae4 <bInitializeSDCard+0x80>
				xSdHandle.connected = TRUE;
8111aabc:	00800044 	movi	r2,1
8111aac0:	d0a07215 	stw	r2,-32312(gp)
				debug(fp, "SD is up.\r\n");
8111aac4:	d0a05e17 	ldw	r2,-32392(gp)
8111aac8:	100f883a 	mov	r7,r2
8111aacc:	018002c4 	movi	r6,11
8111aad0:	01400044 	movi	r5,1
8111aad4:	01204574 	movhi	r4,33045
8111aad8:	212f8004 	addi	r4,r4,-16896
8111aadc:	111d0b40 	call	8111d0b4 <fwrite>
8111aae0:	00001806 	br	8111ab44 <bInitializeSDCard+0xe0>
			} else {
				/* SD isn't in FAT16 format*/
				debug(fp, "SD Card should be formated in FAT16.\r\n");
8111aae4:	d0a05e17 	ldw	r2,-32392(gp)
8111aae8:	100f883a 	mov	r7,r2
8111aaec:	01800984 	movi	r6,38
8111aaf0:	01400044 	movi	r5,1
8111aaf4:	01204574 	movhi	r4,33045
8111aaf8:	212f8304 	addi	r4,r4,-16884
8111aafc:	111d0b40 	call	8111d0b4 <fwrite>
8111ab00:	00001006 	br	8111ab44 <bInitializeSDCard+0xe0>
			}
		} else {
			/* There's no SDCard in the slot */
			debug(fp, "There is no SD in the slot.\r\n");
8111ab04:	d0a05e17 	ldw	r2,-32392(gp)
8111ab08:	100f883a 	mov	r7,r2
8111ab0c:	01800744 	movi	r6,29
8111ab10:	01400044 	movi	r5,1
8111ab14:	01204574 	movhi	r4,33045
8111ab18:	212f8d04 	addi	r4,r4,-16844
8111ab1c:	111d0b40 	call	8111d0b4 <fwrite>
8111ab20:	00000806 	br	8111ab44 <bInitializeSDCard+0xe0>
		}

	} else {
		/* Unable to open the SDCard device. */
		bSucess = FALSE;
8111ab24:	e03fff15 	stw	zero,-4(fp)
		debug(fp, "Unable to open the SDCard device.\r\n");
8111ab28:	d0a05e17 	ldw	r2,-32392(gp)
8111ab2c:	100f883a 	mov	r7,r2
8111ab30:	018008c4 	movi	r6,35
8111ab34:	01400044 	movi	r5,1
8111ab38:	01204574 	movhi	r4,33045
8111ab3c:	212f9504 	addi	r4,r4,-16812
8111ab40:	111d0b40 	call	8111d0b4 <fwrite>
	}

	return bSucess;
8111ab44:	e0bfff17 	ldw	r2,-4(fp)
}
8111ab48:	e037883a 	mov	sp,fp
8111ab4c:	dfc00117 	ldw	ra,4(sp)
8111ab50:	df000017 	ldw	fp,0(sp)
8111ab54:	dec00204 	addi	sp,sp,8
8111ab58:	f800283a 	ret

8111ab5c <siOpenFile>:
	}
	return (char)readCharacter;
}
*/

short int siOpenFile( char *filename ) {
8111ab5c:	defffd04 	addi	sp,sp,-12
8111ab60:	de00012e 	bgeu	sp,et,8111ab68 <siOpenFile+0xc>
8111ab64:	003b68fa 	trap	3
8111ab68:	dfc00215 	stw	ra,8(sp)
8111ab6c:	df000115 	stw	fp,4(sp)
8111ab70:	df000104 	addi	fp,sp,4
8111ab74:	e13fff15 	stw	r4,-4(fp)
	return alt_up_sd_card_fopen( filename, FALSE );
8111ab78:	000b883a 	mov	r5,zero
8111ab7c:	e13fff17 	ldw	r4,-4(fp)
8111ab80:	114150c0 	call	8114150c <alt_up_sd_card_fopen>
}
8111ab84:	e037883a 	mov	sp,fp
8111ab88:	dfc00117 	ldw	ra,4(sp)
8111ab8c:	df000017 	ldw	fp,0(sp)
8111ab90:	dec00204 	addi	sp,sp,8
8111ab94:	f800283a 	ret

8111ab98 <siCloseFile>:

bool siCloseFile( short int file_handle ) {
8111ab98:	defffd04 	addi	sp,sp,-12
8111ab9c:	de00012e 	bgeu	sp,et,8111aba4 <siCloseFile+0xc>
8111aba0:	003b68fa 	trap	3
8111aba4:	dfc00215 	stw	ra,8(sp)
8111aba8:	df000115 	stw	fp,4(sp)
8111abac:	df000104 	addi	fp,sp,4
8111abb0:	2005883a 	mov	r2,r4
8111abb4:	e0bfff0d 	sth	r2,-4(fp)
	return alt_up_sd_card_fclose( file_handle );
8111abb8:	e0bfff0f 	ldh	r2,-4(fp)
8111abbc:	1009883a 	mov	r4,r2
8111abc0:	11423580 	call	81142358 <alt_up_sd_card_fclose>
}
8111abc4:	e037883a 	mov	sp,fp
8111abc8:	dfc00117 	ldw	ra,4(sp)
8111abcc:	df000017 	ldw	fp,0(sp)
8111abd0:	dec00204 	addi	sp,sp,8
8111abd4:	f800283a 	ret

8111abd8 <cGetNextChar>:

char cGetNextChar( short int file_handle ) {
8111abd8:	defffd04 	addi	sp,sp,-12
8111abdc:	de00012e 	bgeu	sp,et,8111abe4 <cGetNextChar+0xc>
8111abe0:	003b68fa 	trap	3
8111abe4:	dfc00215 	stw	ra,8(sp)
8111abe8:	df000115 	stw	fp,4(sp)
8111abec:	df000104 	addi	fp,sp,4
8111abf0:	2005883a 	mov	r2,r4
8111abf4:	e0bfff0d 	sth	r2,-4(fp)
	return (char)alt_up_sd_card_read( file_handle );
8111abf8:	e0bfff0f 	ldh	r2,-4(fp)
8111abfc:	1009883a 	mov	r4,r2
8111ac00:	11419b00 	call	811419b0 <alt_up_sd_card_read>
}
8111ac04:	e037883a 	mov	sp,fp
8111ac08:	dfc00117 	ldw	ra,4(sp)
8111ac0c:	df000017 	ldw	fp,0(sp)
8111ac10:	dec00204 	addi	sp,sp,8
8111ac14:	f800283a 	ret

8111ac18 <bInitSync>:

#include "sync_handler.h"

/* todo: Create a struct that will contain all config, and pass as parameter to the functions */

bool bInitSync( void ) {
8111ac18:	defffc04 	addi	sp,sp,-16
8111ac1c:	de00012e 	bgeu	sp,et,8111ac24 <bInitSync+0xc>
8111ac20:	003b68fa 	trap	3
8111ac24:	dfc00315 	stw	ra,12(sp)
8111ac28:	df000215 	stw	fp,8(sp)
8111ac2c:	df000204 	addi	fp,sp,8
	bool	bSuccess;
	alt_u32	aux_32;

	vSyncInitIrq();
8111ac30:	110bb440 	call	8110bb44 <vSyncInitIrq>

	#ifdef DEBUG_ON
		debug(fp, "Initializing Sync Module.\n");
8111ac34:	d0a05e17 	ldw	r2,-32392(gp)
8111ac38:	100f883a 	mov	r7,r2
8111ac3c:	01800684 	movi	r6,26
8111ac40:	01400044 	movi	r5,1
8111ac44:	01204574 	movhi	r4,33045
8111ac48:	212f9e04 	addi	r4,r4,-16776
8111ac4c:	111d0b40 	call	8111d0b4 <fwrite>
	#endif

	// Configura um padro de sync interno
	// MBT => 400 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetMbt(MBT);
8111ac50:	01004c74 	movhi	r4,305
8111ac54:	210b4004 	addi	r4,r4,11520
8111ac58:	110bd4c0 	call	8110bd4c <bSyncSetMbt>
8111ac5c:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ac60:	e0bffe17 	ldw	r2,-8(fp)
8111ac64:	1000091e 	bne	r2,zero,8111ac8c <bInitSync+0x74>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ac68:	d0a05e17 	ldw	r2,-32392(gp)
8111ac6c:	100f883a 	mov	r7,r2
8111ac70:	018005c4 	movi	r6,23
8111ac74:	01400044 	movi	r5,1
8111ac78:	01204574 	movhi	r4,33045
8111ac7c:	212fa504 	addi	r4,r4,-16748
8111ac80:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ac84:	e0bffe17 	ldw	r2,-8(fp)
8111ac88:	00007a06 	br	8111ae74 <bInitSync+0x25c>
	}

	// BT => 200 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetBt(BT);
8111ac8c:	01002674 	movhi	r4,153
8111ac90:	2125a004 	addi	r4,r4,-27008
8111ac94:	110bd8c0 	call	8110bd8c <bSyncSetBt>
8111ac98:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ac9c:	e0bffe17 	ldw	r2,-8(fp)
8111aca0:	1000091e 	bne	r2,zero,8111acc8 <bInitSync+0xb0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111aca4:	d0a05e17 	ldw	r2,-32392(gp)
8111aca8:	100f883a 	mov	r7,r2
8111acac:	018005c4 	movi	r6,23
8111acb0:	01400044 	movi	r5,1
8111acb4:	01204574 	movhi	r4,33045
8111acb8:	212fa504 	addi	r4,r4,-16748
8111acbc:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111acc0:	e0bffe17 	ldw	r2,-8(fp)
8111acc4:	00006b06 	br	8111ae74 <bInitSync+0x25c>
	}

	// PER => 6,25s @ 20 ns (50 MHz)
	bSuccess = bSyncSetPer((alt_u32)PER);
8111acc8:	0112a074 	movhi	r4,19073
8111accc:	211f2004 	addi	r4,r4,31872
8111acd0:	110bdcc0 	call	8110bdcc <bSyncSetPer>
8111acd4:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111acd8:	e0bffe17 	ldw	r2,-8(fp)
8111acdc:	1000091e 	bne	r2,zero,8111ad04 <bInitSync+0xec>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ace0:	d0a05e17 	ldw	r2,-32392(gp)
8111ace4:	100f883a 	mov	r7,r2
8111ace8:	018005c4 	movi	r6,23
8111acec:	01400044 	movi	r5,1
8111acf0:	01204574 	movhi	r4,33045
8111acf4:	212fa504 	addi	r4,r4,-16748
8111acf8:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111acfc:	e0bffe17 	ldw	r2,-8(fp)
8111ad00:	00005c06 	br	8111ae74 <bInitSync+0x25c>
	}

	// OST => 500 ms @ 20 ns (50 MHz)
	bSuccess = bSyncSetOst(OST);
8111ad04:	01005f74 	movhi	r4,381
8111ad08:	211e1004 	addi	r4,r4,30784
8111ad0c:	110be0c0 	call	8110be0c <bSyncSetOst>
8111ad10:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ad14:	e0bffe17 	ldw	r2,-8(fp)
8111ad18:	1000091e 	bne	r2,zero,8111ad40 <bInitSync+0x128>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ad1c:	d0a05e17 	ldw	r2,-32392(gp)
8111ad20:	100f883a 	mov	r7,r2
8111ad24:	018005c4 	movi	r6,23
8111ad28:	01400044 	movi	r5,1
8111ad2c:	01204574 	movhi	r4,33045
8111ad30:	212fa504 	addi	r4,r4,-16748
8111ad34:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ad38:	e0bffe17 	ldw	r2,-8(fp)
8111ad3c:	00004d06 	br	8111ae74 <bInitSync+0x25c>
	}


	// Polaridade
	bSuccess = bSyncSetPolarity(POL);
8111ad40:	0009883a 	mov	r4,zero
8111ad44:	110be4c0 	call	8110be4c <bSyncSetPolarity>
8111ad48:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ad4c:	e0bffe17 	ldw	r2,-8(fp)
8111ad50:	1000091e 	bne	r2,zero,8111ad78 <bInitSync+0x160>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ad54:	d0a05e17 	ldw	r2,-32392(gp)
8111ad58:	100f883a 	mov	r7,r2
8111ad5c:	018005c4 	movi	r6,23
8111ad60:	01400044 	movi	r5,1
8111ad64:	01204574 	movhi	r4,33045
8111ad68:	212fa504 	addi	r4,r4,-16748
8111ad6c:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ad70:	e0bffe17 	ldw	r2,-8(fp)
8111ad74:	00003f06 	br	8111ae74 <bInitSync+0x25c>
	}

	// N. de ciclos
	bSuccess = bSyncSetNCycles(N_CICLOS);
8111ad78:	01000104 	movi	r4,4
8111ad7c:	110bec00 	call	8110bec0 <bSyncSetNCycles>
8111ad80:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ad84:	e0bffe17 	ldw	r2,-8(fp)
8111ad88:	1000091e 	bne	r2,zero,8111adb0 <bInitSync+0x198>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ad8c:	d0a05e17 	ldw	r2,-32392(gp)
8111ad90:	100f883a 	mov	r7,r2
8111ad94:	018005c4 	movi	r6,23
8111ad98:	01400044 	movi	r5,1
8111ad9c:	01204574 	movhi	r4,33045
8111ada0:	212fa504 	addi	r4,r4,-16748
8111ada4:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ada8:	e0bffe17 	ldw	r2,-8(fp)
8111adac:	00003106 	br	8111ae74 <bInitSync+0x25c>
	}

	// Altera mux para sync interno
	bSuccess = bSyncCtrExtnIrq(TRUE);
8111adb0:	01000044 	movi	r4,1
8111adb4:	110c09c0 	call	8110c09c <bSyncCtrExtnIrq>
8111adb8:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111adbc:	e0bffe17 	ldw	r2,-8(fp)
8111adc0:	1000091e 	bne	r2,zero,8111ade8 <bInitSync+0x1d0>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111adc4:	d0a05e17 	ldw	r2,-32392(gp)
8111adc8:	100f883a 	mov	r7,r2
8111adcc:	018005c4 	movi	r6,23
8111add0:	01400044 	movi	r5,1
8111add4:	01204574 	movhi	r4,33045
8111add8:	212fa504 	addi	r4,r4,-16748
8111addc:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ade0:	e0bffe17 	ldw	r2,-8(fp)
8111ade4:	00002306 	br	8111ae74 <bInitSync+0x25c>
	}

	// Habilita sync_out enable (deve aparecer na sada o sync int.)
	bSuccess = bSyncCtrSyncOutEnable(TRUE);
8111ade8:	01000044 	movi	r4,1
8111adec:	110c2640 	call	8110c264 <bSyncCtrSyncOutEnable>
8111adf0:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111adf4:	e0bffe17 	ldw	r2,-8(fp)
8111adf8:	1000091e 	bne	r2,zero,8111ae20 <bInitSync+0x208>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111adfc:	d0a05e17 	ldw	r2,-32392(gp)
8111ae00:	100f883a 	mov	r7,r2
8111ae04:	018005c4 	movi	r6,23
8111ae08:	01400044 	movi	r5,1
8111ae0c:	01204574 	movhi	r4,33045
8111ae10:	212fa504 	addi	r4,r4,-16748
8111ae14:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ae18:	e0bffe17 	ldw	r2,-8(fp)
8111ae1c:	00001506 	br	8111ae74 <bInitSync+0x25c>
	}

	// Habilita sync_out_ch1 enable (libera sync para o Ch 1)
	bSuccess = bSyncCtrCh1OutEnable(TRUE);
8111ae20:	01000044 	movi	r4,1
8111ae24:	110c2d80 	call	8110c2d8 <bSyncCtrCh1OutEnable>
8111ae28:	e0bffe15 	stw	r2,-8(fp)
	if ( bSuccess == FALSE ) {
8111ae2c:	e0bffe17 	ldw	r2,-8(fp)
8111ae30:	1000091e 	bne	r2,zero,8111ae58 <bInitSync+0x240>
		#ifdef DEBUG_ON
			debug(fp, "Sync Init: Temp Error.\n");
8111ae34:	d0a05e17 	ldw	r2,-32392(gp)
8111ae38:	100f883a 	mov	r7,r2
8111ae3c:	018005c4 	movi	r6,23
8111ae40:	01400044 	movi	r5,1
8111ae44:	01204574 	movhi	r4,33045
8111ae48:	212fa504 	addi	r4,r4,-16748
8111ae4c:	111d0b40 	call	8111d0b4 <fwrite>
		#endif
		return bSuccess;
8111ae50:	e0bffe17 	ldw	r2,-8(fp)
8111ae54:	00000706 	br	8111ae74 <bInitSync+0x25c>
	}

	bSuccess = bSyncCtrStart();
8111ae58:	110c1140 	call	8110c114 <bSyncCtrStart>
8111ae5c:	e0bffe15 	stw	r2,-8(fp)
	bSyncCtrReset();
8111ae60:	110c1680 	call	8110c168 <bSyncCtrReset>
	aux_32 = bSyncIrqEnableBlank(TRUE);
8111ae64:	01000044 	movi	r4,1
8111ae68:	110c6ec0 	call	8110c6ec <bSyncIrqEnableBlank>
8111ae6c:	e0bfff15 	stw	r2,-4(fp)


	return bSuccess;
8111ae70:	e0bffe17 	ldw	r2,-8(fp)
}
8111ae74:	e037883a 	mov	sp,fp
8111ae78:	dfc00117 	ldw	ra,4(sp)
8111ae7c:	df000017 	ldw	fp,0(sp)
8111ae80:	dec00204 	addi	sp,sp,8
8111ae84:	f800283a 	ret

8111ae88 <bStartSync>:


bool bStartSync(void) {
8111ae88:	defffd04 	addi	sp,sp,-12
8111ae8c:	de00012e 	bgeu	sp,et,8111ae94 <bStartSync+0xc>
8111ae90:	003b68fa 	trap	3
8111ae94:	dfc00215 	stw	ra,8(sp)
8111ae98:	df000115 	stw	fp,4(sp)
8111ae9c:	df000104 	addi	fp,sp,4

	bool bSuccess;
	bSuccess = bSyncCtrStart();
8111aea0:	110c1140 	call	8110c114 <bSyncCtrStart>
8111aea4:	e0bfff15 	stw	r2,-4(fp)

	return bSuccess;
8111aea8:	e0bfff17 	ldw	r2,-4(fp)
}
8111aeac:	e037883a 	mov	sp,fp
8111aeb0:	dfc00117 	ldw	ra,4(sp)
8111aeb4:	df000017 	ldw	fp,0(sp)
8111aeb8:	dec00204 	addi	sp,sp,8
8111aebc:	f800283a 	ret

8111aec0 <bStopSync>:

bool bStopSync(void) {
8111aec0:	defffe04 	addi	sp,sp,-8
8111aec4:	de00012e 	bgeu	sp,et,8111aecc <bStopSync+0xc>
8111aec8:	003b68fa 	trap	3
8111aecc:	dfc00115 	stw	ra,4(sp)
8111aed0:	df000015 	stw	fp,0(sp)
8111aed4:	d839883a 	mov	fp,sp
	return bSyncCtrReset();
8111aed8:	110c1680 	call	8110c168 <bSyncCtrReset>
}
8111aedc:	e037883a 	mov	sp,fp
8111aee0:	dfc00117 	ldw	ra,4(sp)
8111aee4:	df000017 	ldw	fp,0(sp)
8111aee8:	dec00204 	addi	sp,sp,8
8111aeec:	f800283a 	ret

8111aef0 <bClearCounterSync>:

void bClearCounterSync(void) {
8111aef0:	defffe04 	addi	sp,sp,-8
8111aef4:	de00012e 	bgeu	sp,et,8111aefc <bClearCounterSync+0xc>
8111aef8:	003b68fa 	trap	3
8111aefc:	dfc00115 	stw	ra,4(sp)
8111af00:	df000015 	stw	fp,0(sp)
8111af04:	d839883a 	mov	fp,sp

	vSyncClearCounter();
8111af08:	110bb180 	call	8110bb18 <vSyncClearCounter>
}
8111af0c:	0001883a 	nop
8111af10:	e037883a 	mov	sp,fp
8111af14:	dfc00117 	ldw	ra,4(sp)
8111af18:	df000017 	ldw	fp,0(sp)
8111af1c:	dec00204 	addi	sp,sp,8
8111af20:	f800283a 	ret

8111af24 <bTestSimucamCriticalHW>:
 */


#include "test_module_simucam.h"

bool bTestSimucamCriticalHW( void ) {
8111af24:	defffd04 	addi	sp,sp,-12
8111af28:	de00012e 	bgeu	sp,et,8111af30 <bTestSimucamCriticalHW+0xc>
8111af2c:	003b68fa 	trap	3
8111af30:	dfc00215 	stw	ra,8(sp)
8111af34:	df000115 	stw	fp,4(sp)
8111af38:	df000104 	addi	fp,sp,4
	/*
	 * Verificar com Frana quais testes podemos realizar aqui
	 * SDcard para criar logs e pegar defaults
	 */

	bSuccess = bSdmaInitM1Dma();
8111af3c:	1103b300 	call	81103b30 <bSdmaInitM1Dma>
8111af40:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111af44:	e0bfff17 	ldw	r2,-4(fp)
8111af48:	1000021e 	bne	r2,zero,8111af54 <bTestSimucamCriticalHW+0x30>
		return bSuccess;
8111af4c:	e0bfff17 	ldw	r2,-4(fp)
8111af50:	00001106 	br	8111af98 <bTestSimucamCriticalHW+0x74>
	}

	bSuccess = bSdmaInitM2Dma();
8111af54:	1103be00 	call	81103be0 <bSdmaInitM2Dma>
8111af58:	e0bfff15 	stw	r2,-4(fp)
	if (bSuccess==FALSE) {
8111af5c:	e0bfff17 	ldw	r2,-4(fp)
8111af60:	1000021e 	bne	r2,zero,8111af6c <bTestSimucamCriticalHW+0x48>
		return bSuccess;
8111af64:	e0bfff17 	ldw	r2,-4(fp)
8111af68:	00000b06 	br	8111af98 <bTestSimucamCriticalHW+0x74>
	}

	xDma[0].pDmaTranfer = bSdmaDmaM1Transfer;
8111af6c:	00a045b4 	movhi	r2,33046
8111af70:	10bc4804 	addi	r2,r2,-3808
8111af74:	00e04434 	movhi	r3,33040
8111af78:	18cf2404 	addi	r3,r3,15504
8111af7c:	10c00115 	stw	r3,4(r2)
	xDma[0].pDmaTranfer = bSdmaDmaM2Transfer;
8111af80:	00a045b4 	movhi	r2,33046
8111af84:	10bc4804 	addi	r2,r2,-3808
8111af88:	00e04434 	movhi	r3,33040
8111af8c:	18d02704 	addi	r3,r3,16540
8111af90:	10c00115 	stw	r3,4(r2)


	return TRUE;
8111af94:	00800044 	movi	r2,1
}
8111af98:	e037883a 	mov	sp,fp
8111af9c:	dfc00117 	ldw	ra,4(sp)
8111afa0:	df000017 	ldw	fp,0(sp)
8111afa4:	dec00204 	addi	sp,sp,8
8111afa8:	f800283a 	ret

8111afac <_reg_write>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_write(int BASE_ADD, alt_32 REG_ADD, alt_32 REG_Dado) {
8111afac:	defffc04 	addi	sp,sp,-16
8111afb0:	de00012e 	bgeu	sp,et,8111afb8 <_reg_write+0xc>
8111afb4:	003b68fa 	trap	3
8111afb8:	df000315 	stw	fp,12(sp)
8111afbc:	df000304 	addi	fp,sp,12
8111afc0:	e13ffd15 	stw	r4,-12(fp)
8111afc4:	e17ffe15 	stw	r5,-8(fp)
8111afc8:	e1bfff15 	stw	r6,-4(fp)

	IOWR_32DIRECT(BASE_ADD, REG_ADD << 2, REG_Dado);
8111afcc:	e0bffe17 	ldw	r2,-8(fp)
8111afd0:	1085883a 	add	r2,r2,r2
8111afd4:	1085883a 	add	r2,r2,r2
8111afd8:	1007883a 	mov	r3,r2
8111afdc:	e0bffd17 	ldw	r2,-12(fp)
8111afe0:	1885883a 	add	r2,r3,r2
8111afe4:	1007883a 	mov	r3,r2
8111afe8:	e0bfff17 	ldw	r2,-4(fp)
8111afec:	18800035 	stwio	r2,0(r3)
	return 1;
8111aff0:	00800044 	movi	r2,1

}
8111aff4:	e037883a 	mov	sp,fp
8111aff8:	df000017 	ldw	fp,0(sp)
8111affc:	dec00104 	addi	sp,sp,4
8111b000:	f800283a 	ret

8111b004 <_reg_read>:
 *
 * @retval 1 : Sucesso 
 *
 */

alt_32 _reg_read(int BASE_ADD, alt_32 REG_ADD, alt_32 *REG_Dado) {
8111b004:	defffc04 	addi	sp,sp,-16
8111b008:	de00012e 	bgeu	sp,et,8111b010 <_reg_read+0xc>
8111b00c:	003b68fa 	trap	3
8111b010:	df000315 	stw	fp,12(sp)
8111b014:	df000304 	addi	fp,sp,12
8111b018:	e13ffd15 	stw	r4,-12(fp)
8111b01c:	e17ffe15 	stw	r5,-8(fp)
8111b020:	e1bfff15 	stw	r6,-4(fp)

	*REG_Dado = IORD_32DIRECT(BASE_ADD, REG_ADD << 2);
8111b024:	e0bffe17 	ldw	r2,-8(fp)
8111b028:	1085883a 	add	r2,r2,r2
8111b02c:	1085883a 	add	r2,r2,r2
8111b030:	1007883a 	mov	r3,r2
8111b034:	e0bffd17 	ldw	r2,-12(fp)
8111b038:	1885883a 	add	r2,r3,r2
8111b03c:	10c00037 	ldwio	r3,0(r2)
8111b040:	e0bfff17 	ldw	r2,-4(fp)
8111b044:	10c00015 	stw	r3,0(r2)
	return 1;
8111b048:	00800044 	movi	r2,1

}
8111b04c:	e037883a 	mov	sp,fp
8111b050:	df000017 	ldw	fp,0(sp)
8111b054:	dec00104 	addi	sp,sp,4
8111b058:	f800283a 	ret

8111b05c <_print_codec_status>:
 * @param [in] codec_status
 * *
 * @retval 1 : Sucesso
 *
 */
void _print_codec_status(int codec_status) {
8111b05c:	defffa04 	addi	sp,sp,-24
8111b060:	de00012e 	bgeu	sp,et,8111b068 <_print_codec_status+0xc>
8111b064:	003b68fa 	trap	3
8111b068:	dfc00515 	stw	ra,20(sp)
8111b06c:	df000415 	stw	fp,16(sp)
8111b070:	df000404 	addi	fp,sp,16
8111b074:	e13fff15 	stw	r4,-4(fp)
	int started = (int) ((codec_status >> 6) & 1);
8111b078:	e0bfff17 	ldw	r2,-4(fp)
8111b07c:	1005d1ba 	srai	r2,r2,6
8111b080:	1080004c 	andi	r2,r2,1
8111b084:	e0bffc15 	stw	r2,-16(fp)
	int connecting = (int) ((codec_status >> 5) & 1);
8111b088:	e0bfff17 	ldw	r2,-4(fp)
8111b08c:	1005d17a 	srai	r2,r2,5
8111b090:	1080004c 	andi	r2,r2,1
8111b094:	e0bffd15 	stw	r2,-12(fp)
	int running = (int) ((codec_status >> 4) & 1);
8111b098:	e0bfff17 	ldw	r2,-4(fp)
8111b09c:	1005d13a 	srai	r2,r2,4
8111b0a0:	1080004c 	andi	r2,r2,1
8111b0a4:	e0bffe15 	stw	r2,-8(fp)

#ifdef DEBUG_ON
	sprintf(cDebugBuffer, "-------- link status \n");
8111b0a8:	00e04574 	movhi	r3,33045
8111b0ac:	18fb8b04 	addi	r3,r3,-4564
8111b0b0:	00a04574 	movhi	r2,33045
8111b0b4:	10afab04 	addi	r2,r2,-16724
8111b0b8:	1009883a 	mov	r4,r2
8111b0bc:	008005c4 	movi	r2,23
8111b0c0:	100d883a 	mov	r6,r2
8111b0c4:	200b883a 	mov	r5,r4
8111b0c8:	1809883a 	mov	r4,r3
8111b0cc:	111dac80 	call	8111dac8 <memcpy>
	debug(fp, cDebugBuffer);
8111b0d0:	d0a05e17 	ldw	r2,-32392(gp)
8111b0d4:	01604574 	movhi	r5,33045
8111b0d8:	297b8b04 	addi	r5,r5,-4564
8111b0dc:	1009883a 	mov	r4,r2
8111b0e0:	111ca180 	call	8111ca18 <fprintf>
	sprintf(cDebugBuffer, "Link started    : %s \n", (started == 1) ? "S" : "N");
8111b0e4:	e0bffc17 	ldw	r2,-16(fp)
8111b0e8:	10800058 	cmpnei	r2,r2,1
8111b0ec:	1000031e 	bne	r2,zero,8111b0fc <_print_codec_status+0xa0>
8111b0f0:	00a04574 	movhi	r2,33045
8111b0f4:	10afb104 	addi	r2,r2,-16700
8111b0f8:	00000206 	br	8111b104 <_print_codec_status+0xa8>
8111b0fc:	00a04574 	movhi	r2,33045
8111b100:	10afb204 	addi	r2,r2,-16696
8111b104:	100d883a 	mov	r6,r2
8111b108:	01604574 	movhi	r5,33045
8111b10c:	296fb304 	addi	r5,r5,-16692
8111b110:	01204574 	movhi	r4,33045
8111b114:	213b8b04 	addi	r4,r4,-4564
8111b118:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
8111b11c:	d0a05e17 	ldw	r2,-32392(gp)
8111b120:	01604574 	movhi	r5,33045
8111b124:	297b8b04 	addi	r5,r5,-4564
8111b128:	1009883a 	mov	r4,r2
8111b12c:	111ca180 	call	8111ca18 <fprintf>
	sprintf(cDebugBuffer, "Link connecting : %s \n", (connecting == 1) ? "S" : "N");
8111b130:	e0bffd17 	ldw	r2,-12(fp)
8111b134:	10800058 	cmpnei	r2,r2,1
8111b138:	1000031e 	bne	r2,zero,8111b148 <_print_codec_status+0xec>
8111b13c:	00a04574 	movhi	r2,33045
8111b140:	10afb104 	addi	r2,r2,-16700
8111b144:	00000206 	br	8111b150 <_print_codec_status+0xf4>
8111b148:	00a04574 	movhi	r2,33045
8111b14c:	10afb204 	addi	r2,r2,-16696
8111b150:	100d883a 	mov	r6,r2
8111b154:	01604574 	movhi	r5,33045
8111b158:	296fb904 	addi	r5,r5,-16668
8111b15c:	01204574 	movhi	r4,33045
8111b160:	213b8b04 	addi	r4,r4,-4564
8111b164:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
8111b168:	d0a05e17 	ldw	r2,-32392(gp)
8111b16c:	01604574 	movhi	r5,33045
8111b170:	297b8b04 	addi	r5,r5,-4564
8111b174:	1009883a 	mov	r4,r2
8111b178:	111ca180 	call	8111ca18 <fprintf>
	sprintf(cDebugBuffer, "Link running    : %s \n", (running == 1) ? "S" : "N");
8111b17c:	e0bffe17 	ldw	r2,-8(fp)
8111b180:	10800058 	cmpnei	r2,r2,1
8111b184:	1000031e 	bne	r2,zero,8111b194 <_print_codec_status+0x138>
8111b188:	00a04574 	movhi	r2,33045
8111b18c:	10afb104 	addi	r2,r2,-16700
8111b190:	00000206 	br	8111b19c <_print_codec_status+0x140>
8111b194:	00a04574 	movhi	r2,33045
8111b198:	10afb204 	addi	r2,r2,-16696
8111b19c:	100d883a 	mov	r6,r2
8111b1a0:	01604574 	movhi	r5,33045
8111b1a4:	296fbf04 	addi	r5,r5,-16644
8111b1a8:	01204574 	movhi	r4,33045
8111b1ac:	213b8b04 	addi	r4,r4,-4564
8111b1b0:	111e3a80 	call	8111e3a8 <sprintf>
	debug(fp, cDebugBuffer);
8111b1b4:	d0a05e17 	ldw	r2,-32392(gp)
8111b1b8:	01604574 	movhi	r5,33045
8111b1bc:	297b8b04 	addi	r5,r5,-4564
8111b1c0:	1009883a 	mov	r4,r2
8111b1c4:	111ca180 	call	8111ca18 <fprintf>
	sprintf(cDebugBuffer, "--------  \n");
8111b1c8:	00a04574 	movhi	r2,33045
8111b1cc:	10bb8b04 	addi	r2,r2,-4564
8111b1d0:	00c00b44 	movi	r3,45
8111b1d4:	10c00005 	stb	r3,0(r2)
8111b1d8:	00c00b44 	movi	r3,45
8111b1dc:	10c00045 	stb	r3,1(r2)
8111b1e0:	00c00b44 	movi	r3,45
8111b1e4:	10c00085 	stb	r3,2(r2)
8111b1e8:	00c00b44 	movi	r3,45
8111b1ec:	10c000c5 	stb	r3,3(r2)
8111b1f0:	00c00b44 	movi	r3,45
8111b1f4:	10c00105 	stb	r3,4(r2)
8111b1f8:	00c00b44 	movi	r3,45
8111b1fc:	10c00145 	stb	r3,5(r2)
8111b200:	00c00b44 	movi	r3,45
8111b204:	10c00185 	stb	r3,6(r2)
8111b208:	00c00b44 	movi	r3,45
8111b20c:	10c001c5 	stb	r3,7(r2)
8111b210:	00c00804 	movi	r3,32
8111b214:	10c00205 	stb	r3,8(r2)
8111b218:	00c00804 	movi	r3,32
8111b21c:	10c00245 	stb	r3,9(r2)
8111b220:	00c00284 	movi	r3,10
8111b224:	10c00285 	stb	r3,10(r2)
8111b228:	100002c5 	stb	zero,11(r2)
	debug(fp, cDebugBuffer);
8111b22c:	d0a05e17 	ldw	r2,-32392(gp)
8111b230:	01604574 	movhi	r5,33045
8111b234:	297b8b04 	addi	r5,r5,-4564
8111b238:	1009883a 	mov	r4,r2
8111b23c:	111ca180 	call	8111ca18 <fprintf>
#endif
}
8111b240:	0001883a 	nop
8111b244:	e037883a 	mov	sp,fp
8111b248:	dfc00117 	ldw	ra,4(sp)
8111b24c:	df000017 	ldw	fp,0(sp)
8111b250:	dec00204 	addi	sp,sp,8
8111b254:	f800283a 	ret

8111b258 <_split_codec_status>:
 * *
 * @retval 1 : Sucesso
 *
 */
void _split_codec_status(int codec_status, int *started, int *connecting,
		int *running) {
8111b258:	defffb04 	addi	sp,sp,-20
8111b25c:	de00012e 	bgeu	sp,et,8111b264 <_split_codec_status+0xc>
8111b260:	003b68fa 	trap	3
8111b264:	df000415 	stw	fp,16(sp)
8111b268:	df000404 	addi	fp,sp,16
8111b26c:	e13ffc15 	stw	r4,-16(fp)
8111b270:	e17ffd15 	stw	r5,-12(fp)
8111b274:	e1bffe15 	stw	r6,-8(fp)
8111b278:	e1ffff15 	stw	r7,-4(fp)
	*started = (int) ((codec_status >> 6) & 1);
8111b27c:	e0bffc17 	ldw	r2,-16(fp)
8111b280:	1005d1ba 	srai	r2,r2,6
8111b284:	10c0004c 	andi	r3,r2,1
8111b288:	e0bffd17 	ldw	r2,-12(fp)
8111b28c:	10c00015 	stw	r3,0(r2)
	*connecting = (int) ((codec_status >> 5) & 1);
8111b290:	e0bffc17 	ldw	r2,-16(fp)
8111b294:	1005d17a 	srai	r2,r2,5
8111b298:	10c0004c 	andi	r3,r2,1
8111b29c:	e0bffe17 	ldw	r2,-8(fp)
8111b2a0:	10c00015 	stw	r3,0(r2)
	*running = (int) ((codec_status >> 4) & 1);
8111b2a4:	e0bffc17 	ldw	r2,-16(fp)
8111b2a8:	1005d13a 	srai	r2,r2,4
8111b2ac:	10c0004c 	andi	r3,r2,1
8111b2b0:	e0bfff17 	ldw	r2,-4(fp)
8111b2b4:	10c00015 	stw	r3,0(r2)
}
8111b2b8:	0001883a 	nop
8111b2bc:	e037883a 	mov	sp,fp
8111b2c0:	df000017 	ldw	fp,0(sp)
8111b2c4:	dec00104 	addi	sp,sp,4
8111b2c8:	f800283a 	ret

8111b2cc <aatoh>:
 * @param [in] &char[n]
 * *
 * @retval INT8U of hecadecimal value
 *
 */
alt_u8 aatoh(alt_u8 *buffer) {
8111b2cc:	defffc04 	addi	sp,sp,-16
8111b2d0:	de00012e 	bgeu	sp,et,8111b2d8 <aatoh+0xc>
8111b2d4:	003b68fa 	trap	3
8111b2d8:	df000315 	stw	fp,12(sp)
8111b2dc:	df000304 	addi	fp,sp,12
8111b2e0:	e13fff15 	stw	r4,-4(fp)
	alt_u8* a;
	alt_u8 v;
	a = buffer;
8111b2e4:	e0bfff17 	ldw	r2,-4(fp)
8111b2e8:	e0bffd15 	stw	r2,-12(fp)
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111b2ec:	e0bffd17 	ldw	r2,-12(fp)
8111b2f0:	10c00003 	ldbu	r3,0(r2)
8111b2f4:	e0bffd17 	ldw	r2,-12(fp)
8111b2f8:	10800003 	ldbu	r2,0(r2)
8111b2fc:	10803fcc 	andi	r2,r2,255
8111b300:	10800eb0 	cmpltui	r2,r2,58
8111b304:	1000021e 	bne	r2,zero,8111b310 <aatoh+0x44>
8111b308:	00800dc4 	movi	r2,55
8111b30c:	00000106 	br	8111b314 <aatoh+0x48>
8111b310:	00800c04 	movi	r2,48
8111b314:	1885c83a 	sub	r2,r3,r2
8111b318:	1004913a 	slli	r2,r2,4
8111b31c:	1009883a 	mov	r4,r2
			+ (a[1] - (48 + 7 * (a[1] > 57)));
8111b320:	e0bffd17 	ldw	r2,-12(fp)
8111b324:	10800044 	addi	r2,r2,1
8111b328:	10c00003 	ldbu	r3,0(r2)
8111b32c:	e0bffd17 	ldw	r2,-12(fp)
8111b330:	10800044 	addi	r2,r2,1
8111b334:	10800003 	ldbu	r2,0(r2)
 */
alt_u8 aatoh(alt_u8 *buffer) {
	alt_u8* a;
	alt_u8 v;
	a = buffer;
	v = ((a[0] - (48 + 7 * (a[0] > 57))) << 4)
8111b338:	10803fcc 	andi	r2,r2,255
8111b33c:	10800eb0 	cmpltui	r2,r2,58
8111b340:	1000021e 	bne	r2,zero,8111b34c <aatoh+0x80>
8111b344:	00800dc4 	movi	r2,55
8111b348:	00000106 	br	8111b350 <aatoh+0x84>
8111b34c:	00800c04 	movi	r2,48
8111b350:	1885c83a 	sub	r2,r3,r2
8111b354:	2085883a 	add	r2,r4,r2
8111b358:	e0bffe05 	stb	r2,-8(fp)
			+ (a[1] - (48 + 7 * (a[1] > 57)));
	return v;
8111b35c:	e0bffe03 	ldbu	r2,-8(fp)
}
8111b360:	e037883a 	mov	sp,fp
8111b364:	df000017 	ldw	fp,0(sp)
8111b368:	dec00104 	addi	sp,sp,4
8111b36c:	f800283a 	ret

8111b370 <Verif_Error>:
 * *
 * @retval int
 *
 */

alt_u8 Verif_Error(alt_u8 error_code) {
8111b370:	defffd04 	addi	sp,sp,-12
8111b374:	de00012e 	bgeu	sp,et,8111b37c <Verif_Error+0xc>
8111b378:	003b68fa 	trap	3
8111b37c:	dfc00215 	stw	ra,8(sp)
8111b380:	df000115 	stw	fp,4(sp)
8111b384:	df000104 	addi	fp,sp,4
8111b388:	2005883a 	mov	r2,r4
8111b38c:	e0bfff05 	stb	r2,-4(fp)
	if (!error_code) {
8111b390:	e0bfff03 	ldbu	r2,-4(fp)
8111b394:	1000091e 	bne	r2,zero,8111b3bc <Verif_Error+0x4c>
#ifdef DEBUG_ON
	debug(fp, "ERROR\n\r");
8111b398:	d0a05e17 	ldw	r2,-32392(gp)
8111b39c:	100f883a 	mov	r7,r2
8111b3a0:	018001c4 	movi	r6,7
8111b3a4:	01400044 	movi	r5,1
8111b3a8:	01204574 	movhi	r4,33045
8111b3ac:	212fc504 	addi	r4,r4,-16620
8111b3b0:	111d0b40 	call	8111d0b4 <fwrite>
#endif
		return 0;
8111b3b4:	0005883a 	mov	r2,zero
8111b3b8:	00000106 	br	8111b3c0 <Verif_Error+0x50>
	} else
		return 1;
8111b3bc:	00800044 	movi	r2,1
}
8111b3c0:	e037883a 	mov	sp,fp
8111b3c4:	dfc00117 	ldw	ra,4(sp)
8111b3c8:	df000017 	ldw	fp,0(sp)
8111b3cc:	dec00204 	addi	sp,sp,8
8111b3d0:	f800283a 	ret

8111b3d4 <toInt>:
 * *
 * @retval int
 *
 */

alt_u8 toInt(alt_u8 ascii) {
8111b3d4:	defffe04 	addi	sp,sp,-8
8111b3d8:	de00012e 	bgeu	sp,et,8111b3e0 <toInt+0xc>
8111b3dc:	003b68fa 	trap	3
8111b3e0:	df000115 	stw	fp,4(sp)
8111b3e4:	df000104 	addi	fp,sp,4
8111b3e8:	2005883a 	mov	r2,r4
8111b3ec:	e0bfff05 	stb	r2,-4(fp)
	return (int) ascii - 48;
8111b3f0:	e0bfff03 	ldbu	r2,-4(fp)
8111b3f4:	10bff404 	addi	r2,r2,-48
}
8111b3f8:	e037883a 	mov	sp,fp
8111b3fc:	df000017 	ldw	fp,0(sp)
8111b400:	dec00104 	addi	sp,sp,4
8111b404:	f800283a 	ret

8111b408 <__divsf3>:
8111b408:	defff504 	addi	sp,sp,-44
8111b40c:	200cd5fa 	srli	r6,r4,23
8111b410:	de00012e 	bgeu	sp,et,8111b418 <__divsf3+0x10>
8111b414:	003b68fa 	trap	3
8111b418:	dcc00415 	stw	r19,16(sp)
8111b41c:	2026d7fa 	srli	r19,r4,31
8111b420:	00c02034 	movhi	r3,128
8111b424:	dd800715 	stw	r22,28(sp)
8111b428:	dd000515 	stw	r20,20(sp)
8111b42c:	dc800315 	stw	r18,12(sp)
8111b430:	18ffffc4 	addi	r3,r3,-1
8111b434:	dfc00a15 	stw	ra,40(sp)
8111b438:	df000915 	stw	fp,36(sp)
8111b43c:	ddc00815 	stw	r23,32(sp)
8111b440:	dd400615 	stw	r21,24(sp)
8111b444:	dc400215 	stw	r17,8(sp)
8111b448:	dc000115 	stw	r16,4(sp)
8111b44c:	35003fcc 	andi	r20,r6,255
8111b450:	1924703a 	and	r18,r3,r4
8111b454:	9d803fcc 	andi	r22,r19,255
8111b458:	a0005226 	beq	r20,zero,8111b5a4 <__divsf3+0x19c>
8111b45c:	00803fc4 	movi	r2,255
8111b460:	a0802e26 	beq	r20,r2,8111b51c <__divsf3+0x114>
8111b464:	91002034 	orhi	r4,r18,128
8111b468:	202490fa 	slli	r18,r4,3
8111b46c:	a53fe044 	addi	r20,r20,-127
8111b470:	0021883a 	mov	r16,zero
8111b474:	002f883a 	mov	r23,zero
8111b478:	280cd5fa 	srli	r6,r5,23
8111b47c:	282ad7fa 	srli	r21,r5,31
8111b480:	00c02034 	movhi	r3,128
8111b484:	18ffffc4 	addi	r3,r3,-1
8111b488:	31803fcc 	andi	r6,r6,255
8111b48c:	1962703a 	and	r17,r3,r5
8111b490:	af003fcc 	andi	fp,r21,255
8111b494:	30004a26 	beq	r6,zero,8111b5c0 <__divsf3+0x1b8>
8111b498:	00803fc4 	movi	r2,255
8111b49c:	30804526 	beq	r6,r2,8111b5b4 <__divsf3+0x1ac>
8111b4a0:	89402034 	orhi	r5,r17,128
8111b4a4:	282290fa 	slli	r17,r5,3
8111b4a8:	31bfe044 	addi	r6,r6,-127
8111b4ac:	000b883a 	mov	r5,zero
8111b4b0:	2c20b03a 	or	r16,r5,r16
8111b4b4:	802090ba 	slli	r16,r16,2
8111b4b8:	00a044b4 	movhi	r2,33042
8111b4bc:	10ad3704 	addi	r2,r2,-19236
8111b4c0:	80a1883a 	add	r16,r16,r2
8111b4c4:	81000017 	ldw	r4,0(r16)
8111b4c8:	9d46f03a 	xor	r3,r19,r21
8111b4cc:	180f883a 	mov	r7,r3
8111b4d0:	18803fcc 	andi	r2,r3,255
8111b4d4:	a18dc83a 	sub	r6,r20,r6
8111b4d8:	2000683a 	jmp	r4
8111b4dc:	8111b6c0 	call	88111b6c <__reset+0x20f1b6c>
8111b4e0:	8111b544 	addi	r4,r16,18133
8111b4e4:	8111b6b4 	orhi	r4,r16,18138
8111b4e8:	8111b530 	cmpltui	r4,r16,18132
8111b4ec:	8111b6b4 	orhi	r4,r16,18138
8111b4f0:	8111b68c 	andi	r4,r16,18138
8111b4f4:	8111b6b4 	orhi	r4,r16,18138
8111b4f8:	8111b530 	cmpltui	r4,r16,18132
8111b4fc:	8111b544 	addi	r4,r16,18133
8111b500:	8111b544 	addi	r4,r16,18133
8111b504:	8111b68c 	andi	r4,r16,18138
8111b508:	8111b530 	cmpltui	r4,r16,18132
8111b50c:	8111b7a0 	cmpeqi	r4,r16,18142
8111b510:	8111b7a0 	cmpeqi	r4,r16,18142
8111b514:	8111b7a0 	cmpeqi	r4,r16,18142
8111b518:	8111b754 	ori	r4,r16,18141
8111b51c:	9000581e 	bne	r18,zero,8111b680 <__divsf3+0x278>
8111b520:	04000204 	movi	r16,8
8111b524:	05c00084 	movi	r23,2
8111b528:	003fd306 	br	8111b478 <__reset+0xfb0fb478>
8111b52c:	0023883a 	mov	r17,zero
8111b530:	e02d883a 	mov	r22,fp
8111b534:	282f883a 	mov	r23,r5
8111b538:	00800084 	movi	r2,2
8111b53c:	b8808f1e 	bne	r23,r2,8111b77c <__divsf3+0x374>
8111b540:	b005883a 	mov	r2,r22
8111b544:	11c0004c 	andi	r7,r2,1
8111b548:	013fffc4 	movi	r4,-1
8111b54c:	000d883a 	mov	r6,zero
8111b550:	21003fcc 	andi	r4,r4,255
8111b554:	200895fa 	slli	r4,r4,23
8111b558:	38803fcc 	andi	r2,r7,255
8111b55c:	00c02034 	movhi	r3,128
8111b560:	100497fa 	slli	r2,r2,31
8111b564:	18ffffc4 	addi	r3,r3,-1
8111b568:	30c6703a 	and	r3,r6,r3
8111b56c:	1906b03a 	or	r3,r3,r4
8111b570:	1884b03a 	or	r2,r3,r2
8111b574:	dfc00a17 	ldw	ra,40(sp)
8111b578:	df000917 	ldw	fp,36(sp)
8111b57c:	ddc00817 	ldw	r23,32(sp)
8111b580:	dd800717 	ldw	r22,28(sp)
8111b584:	dd400617 	ldw	r21,24(sp)
8111b588:	dd000517 	ldw	r20,20(sp)
8111b58c:	dcc00417 	ldw	r19,16(sp)
8111b590:	dc800317 	ldw	r18,12(sp)
8111b594:	dc400217 	ldw	r17,8(sp)
8111b598:	dc000117 	ldw	r16,4(sp)
8111b59c:	dec00b04 	addi	sp,sp,44
8111b5a0:	f800283a 	ret
8111b5a4:	90002b1e 	bne	r18,zero,8111b654 <__divsf3+0x24c>
8111b5a8:	04000104 	movi	r16,4
8111b5ac:	05c00044 	movi	r23,1
8111b5b0:	003fb106 	br	8111b478 <__reset+0xfb0fb478>
8111b5b4:	8800251e 	bne	r17,zero,8111b64c <__divsf3+0x244>
8111b5b8:	01400084 	movi	r5,2
8111b5bc:	00000206 	br	8111b5c8 <__divsf3+0x1c0>
8111b5c0:	88001a1e 	bne	r17,zero,8111b62c <__divsf3+0x224>
8111b5c4:	01400044 	movi	r5,1
8111b5c8:	8160b03a 	or	r16,r16,r5
8111b5cc:	802090ba 	slli	r16,r16,2
8111b5d0:	00e044b4 	movhi	r3,33042
8111b5d4:	18ed7b04 	addi	r3,r3,-18964
8111b5d8:	80e1883a 	add	r16,r16,r3
8111b5dc:	80c00017 	ldw	r3,0(r16)
8111b5e0:	9d44f03a 	xor	r2,r19,r21
8111b5e4:	a18dc83a 	sub	r6,r20,r6
8111b5e8:	1800683a 	jmp	r3
8111b5ec:	8111b544 	addi	r4,r16,18133
8111b5f0:	8111b544 	addi	r4,r16,18133
8111b5f4:	8111b790 	cmplti	r4,r16,18142
8111b5f8:	8111b52c 	andhi	r4,r16,18132
8111b5fc:	8111b790 	cmplti	r4,r16,18142
8111b600:	8111b68c 	andi	r4,r16,18138
8111b604:	8111b790 	cmplti	r4,r16,18142
8111b608:	8111b52c 	andhi	r4,r16,18132
8111b60c:	8111b544 	addi	r4,r16,18133
8111b610:	8111b544 	addi	r4,r16,18133
8111b614:	8111b68c 	andi	r4,r16,18138
8111b618:	8111b52c 	andhi	r4,r16,18132
8111b61c:	8111b7a0 	cmpeqi	r4,r16,18142
8111b620:	8111b7a0 	cmpeqi	r4,r16,18142
8111b624:	8111b7a0 	cmpeqi	r4,r16,18142
8111b628:	8111b7b8 	rdprs	r4,r16,18142
8111b62c:	8809883a 	mov	r4,r17
8111b630:	111c8580 	call	8111c858 <__clzsi2>
8111b634:	10fffec4 	addi	r3,r2,-5
8111b638:	10801d84 	addi	r2,r2,118
8111b63c:	88e2983a 	sll	r17,r17,r3
8111b640:	008dc83a 	sub	r6,zero,r2
8111b644:	000b883a 	mov	r5,zero
8111b648:	003f9906 	br	8111b4b0 <__reset+0xfb0fb4b0>
8111b64c:	014000c4 	movi	r5,3
8111b650:	003f9706 	br	8111b4b0 <__reset+0xfb0fb4b0>
8111b654:	9009883a 	mov	r4,r18
8111b658:	d9400015 	stw	r5,0(sp)
8111b65c:	111c8580 	call	8111c858 <__clzsi2>
8111b660:	10fffec4 	addi	r3,r2,-5
8111b664:	11801d84 	addi	r6,r2,118
8111b668:	90e4983a 	sll	r18,r18,r3
8111b66c:	01a9c83a 	sub	r20,zero,r6
8111b670:	0021883a 	mov	r16,zero
8111b674:	002f883a 	mov	r23,zero
8111b678:	d9400017 	ldw	r5,0(sp)
8111b67c:	003f7e06 	br	8111b478 <__reset+0xfb0fb478>
8111b680:	04000304 	movi	r16,12
8111b684:	05c000c4 	movi	r23,3
8111b688:	003f7b06 	br	8111b478 <__reset+0xfb0fb478>
8111b68c:	01802034 	movhi	r6,128
8111b690:	000f883a 	mov	r7,zero
8111b694:	31bfffc4 	addi	r6,r6,-1
8111b698:	013fffc4 	movi	r4,-1
8111b69c:	003fac06 	br	8111b550 <__reset+0xfb0fb550>
8111b6a0:	01400044 	movi	r5,1
8111b6a4:	2909c83a 	sub	r4,r5,r4
8111b6a8:	00c006c4 	movi	r3,27
8111b6ac:	19004b0e 	bge	r3,r4,8111b7dc <__divsf3+0x3d4>
8111b6b0:	114e703a 	and	r7,r2,r5
8111b6b4:	0009883a 	mov	r4,zero
8111b6b8:	000d883a 	mov	r6,zero
8111b6bc:	003fa406 	br	8111b550 <__reset+0xfb0fb550>
8111b6c0:	9006917a 	slli	r3,r18,5
8111b6c4:	8822917a 	slli	r17,r17,5
8111b6c8:	1c40372e 	bgeu	r3,r17,8111b7a8 <__divsf3+0x3a0>
8111b6cc:	31bfffc4 	addi	r6,r6,-1
8111b6d0:	010006c4 	movi	r4,27
8111b6d4:	000b883a 	mov	r5,zero
8111b6d8:	180f883a 	mov	r7,r3
8111b6dc:	294b883a 	add	r5,r5,r5
8111b6e0:	18c7883a 	add	r3,r3,r3
8111b6e4:	38000116 	blt	r7,zero,8111b6ec <__divsf3+0x2e4>
8111b6e8:	1c400236 	bltu	r3,r17,8111b6f4 <__divsf3+0x2ec>
8111b6ec:	1c47c83a 	sub	r3,r3,r17
8111b6f0:	29400054 	ori	r5,r5,1
8111b6f4:	213fffc4 	addi	r4,r4,-1
8111b6f8:	203ff71e 	bne	r4,zero,8111b6d8 <__reset+0xfb0fb6d8>
8111b6fc:	1806c03a 	cmpne	r3,r3,zero
8111b700:	1962b03a 	or	r17,r3,r5
8111b704:	31001fc4 	addi	r4,r6,127
8111b708:	013fe50e 	bge	zero,r4,8111b6a0 <__reset+0xfb0fb6a0>
8111b70c:	88c001cc 	andi	r3,r17,7
8111b710:	18000426 	beq	r3,zero,8111b724 <__divsf3+0x31c>
8111b714:	88c003cc 	andi	r3,r17,15
8111b718:	01400104 	movi	r5,4
8111b71c:	19400126 	beq	r3,r5,8111b724 <__divsf3+0x31c>
8111b720:	8963883a 	add	r17,r17,r5
8111b724:	88c2002c 	andhi	r3,r17,2048
8111b728:	18000426 	beq	r3,zero,8111b73c <__divsf3+0x334>
8111b72c:	00fe0034 	movhi	r3,63488
8111b730:	18ffffc4 	addi	r3,r3,-1
8111b734:	31002004 	addi	r4,r6,128
8111b738:	88e2703a 	and	r17,r17,r3
8111b73c:	00c03f84 	movi	r3,254
8111b740:	193f8016 	blt	r3,r4,8111b544 <__reset+0xfb0fb544>
8111b744:	880c91ba 	slli	r6,r17,6
8111b748:	11c0004c 	andi	r7,r2,1
8111b74c:	300cd27a 	srli	r6,r6,9
8111b750:	003f7f06 	br	8111b550 <__reset+0xfb0fb550>
8111b754:	9080102c 	andhi	r2,r18,64
8111b758:	10000226 	beq	r2,zero,8111b764 <__divsf3+0x35c>
8111b75c:	8880102c 	andhi	r2,r17,64
8111b760:	10001826 	beq	r2,zero,8111b7c4 <__divsf3+0x3bc>
8111b764:	00802034 	movhi	r2,128
8111b768:	91801034 	orhi	r6,r18,64
8111b76c:	10bfffc4 	addi	r2,r2,-1
8111b770:	980f883a 	mov	r7,r19
8111b774:	308c703a 	and	r6,r6,r2
8111b778:	003fc706 	br	8111b698 <__reset+0xfb0fb698>
8111b77c:	008000c4 	movi	r2,3
8111b780:	b8802d26 	beq	r23,r2,8111b838 <__divsf3+0x430>
8111b784:	00c00044 	movi	r3,1
8111b788:	b005883a 	mov	r2,r22
8111b78c:	b8ffdd1e 	bne	r23,r3,8111b704 <__reset+0xfb0fb704>
8111b790:	11c0004c 	andi	r7,r2,1
8111b794:	0009883a 	mov	r4,zero
8111b798:	000d883a 	mov	r6,zero
8111b79c:	003f6c06 	br	8111b550 <__reset+0xfb0fb550>
8111b7a0:	9023883a 	mov	r17,r18
8111b7a4:	003f6406 	br	8111b538 <__reset+0xfb0fb538>
8111b7a8:	1c47c83a 	sub	r3,r3,r17
8111b7ac:	01000684 	movi	r4,26
8111b7b0:	01400044 	movi	r5,1
8111b7b4:	003fc806 	br	8111b6d8 <__reset+0xfb0fb6d8>
8111b7b8:	9080102c 	andhi	r2,r18,64
8111b7bc:	103fe926 	beq	r2,zero,8111b764 <__reset+0xfb0fb764>
8111b7c0:	0023883a 	mov	r17,zero
8111b7c4:	00802034 	movhi	r2,128
8111b7c8:	89801034 	orhi	r6,r17,64
8111b7cc:	10bfffc4 	addi	r2,r2,-1
8111b7d0:	a80f883a 	mov	r7,r21
8111b7d4:	308c703a 	and	r6,r6,r2
8111b7d8:	003faf06 	br	8111b698 <__reset+0xfb0fb698>
8111b7dc:	01c00804 	movi	r7,32
8111b7e0:	390fc83a 	sub	r7,r7,r4
8111b7e4:	89ce983a 	sll	r7,r17,r7
8111b7e8:	890ad83a 	srl	r5,r17,r4
8111b7ec:	380ec03a 	cmpne	r7,r7,zero
8111b7f0:	29cab03a 	or	r5,r5,r7
8111b7f4:	28c001cc 	andi	r3,r5,7
8111b7f8:	18000426 	beq	r3,zero,8111b80c <__divsf3+0x404>
8111b7fc:	28c003cc 	andi	r3,r5,15
8111b800:	01000104 	movi	r4,4
8111b804:	19000126 	beq	r3,r4,8111b80c <__divsf3+0x404>
8111b808:	290b883a 	add	r5,r5,r4
8111b80c:	28c1002c 	andhi	r3,r5,1024
8111b810:	18000426 	beq	r3,zero,8111b824 <__divsf3+0x41c>
8111b814:	11c0004c 	andi	r7,r2,1
8111b818:	01000044 	movi	r4,1
8111b81c:	000d883a 	mov	r6,zero
8111b820:	003f4b06 	br	8111b550 <__reset+0xfb0fb550>
8111b824:	280a91ba 	slli	r5,r5,6
8111b828:	11c0004c 	andi	r7,r2,1
8111b82c:	0009883a 	mov	r4,zero
8111b830:	280cd27a 	srli	r6,r5,9
8111b834:	003f4606 	br	8111b550 <__reset+0xfb0fb550>
8111b838:	00802034 	movhi	r2,128
8111b83c:	89801034 	orhi	r6,r17,64
8111b840:	10bfffc4 	addi	r2,r2,-1
8111b844:	b00f883a 	mov	r7,r22
8111b848:	308c703a 	and	r6,r6,r2
8111b84c:	003f9206 	br	8111b698 <__reset+0xfb0fb698>

8111b850 <__mulsf3>:
8111b850:	defff504 	addi	sp,sp,-44
8111b854:	de00012e 	bgeu	sp,et,8111b85c <__mulsf3+0xc>
8111b858:	003b68fa 	trap	3
8111b85c:	dc000115 	stw	r16,4(sp)
8111b860:	2020d5fa 	srli	r16,r4,23
8111b864:	dd400615 	stw	r21,24(sp)
8111b868:	202ad7fa 	srli	r21,r4,31
8111b86c:	dc800315 	stw	r18,12(sp)
8111b870:	04802034 	movhi	r18,128
8111b874:	df000915 	stw	fp,36(sp)
8111b878:	dd000515 	stw	r20,20(sp)
8111b87c:	94bfffc4 	addi	r18,r18,-1
8111b880:	dfc00a15 	stw	ra,40(sp)
8111b884:	ddc00815 	stw	r23,32(sp)
8111b888:	dd800715 	stw	r22,28(sp)
8111b88c:	dcc00415 	stw	r19,16(sp)
8111b890:	dc400215 	stw	r17,8(sp)
8111b894:	84003fcc 	andi	r16,r16,255
8111b898:	9124703a 	and	r18,r18,r4
8111b89c:	a829883a 	mov	r20,r21
8111b8a0:	af003fcc 	andi	fp,r21,255
8111b8a4:	80005426 	beq	r16,zero,8111b9f8 <__mulsf3+0x1a8>
8111b8a8:	00803fc4 	movi	r2,255
8111b8ac:	80802f26 	beq	r16,r2,8111b96c <__mulsf3+0x11c>
8111b8b0:	91002034 	orhi	r4,r18,128
8111b8b4:	202490fa 	slli	r18,r4,3
8111b8b8:	843fe044 	addi	r16,r16,-127
8111b8bc:	0023883a 	mov	r17,zero
8111b8c0:	002f883a 	mov	r23,zero
8111b8c4:	2804d5fa 	srli	r2,r5,23
8111b8c8:	282cd7fa 	srli	r22,r5,31
8111b8cc:	01002034 	movhi	r4,128
8111b8d0:	213fffc4 	addi	r4,r4,-1
8111b8d4:	10803fcc 	andi	r2,r2,255
8111b8d8:	2166703a 	and	r19,r4,r5
8111b8dc:	b1803fcc 	andi	r6,r22,255
8111b8e0:	10004c26 	beq	r2,zero,8111ba14 <__mulsf3+0x1c4>
8111b8e4:	00c03fc4 	movi	r3,255
8111b8e8:	10c04726 	beq	r2,r3,8111ba08 <__mulsf3+0x1b8>
8111b8ec:	99002034 	orhi	r4,r19,128
8111b8f0:	202690fa 	slli	r19,r4,3
8111b8f4:	10bfe044 	addi	r2,r2,-127
8111b8f8:	0007883a 	mov	r3,zero
8111b8fc:	80a1883a 	add	r16,r16,r2
8111b900:	010003c4 	movi	r4,15
8111b904:	1c44b03a 	or	r2,r3,r17
8111b908:	b56af03a 	xor	r21,r22,r21
8111b90c:	81c00044 	addi	r7,r16,1
8111b910:	20806b36 	bltu	r4,r2,8111bac0 <__mulsf3+0x270>
8111b914:	100490ba 	slli	r2,r2,2
8111b918:	012044b4 	movhi	r4,33042
8111b91c:	212e4b04 	addi	r4,r4,-18132
8111b920:	1105883a 	add	r2,r2,r4
8111b924:	10800017 	ldw	r2,0(r2)
8111b928:	1000683a 	jmp	r2
8111b92c:	8111bac0 	call	88111bac <__reset+0x20f1bac>
8111b930:	8111b980 	call	88111b98 <__reset+0x20f1b98>
8111b934:	8111b980 	call	88111b98 <__reset+0x20f1b98>
8111b938:	8111b97c 	xorhi	r4,r16,18149
8111b93c:	8111baa4 	muli	r4,r16,18154
8111b940:	8111baa4 	muli	r4,r16,18154
8111b944:	8111ba90 	cmplti	r4,r16,18154
8111b948:	8111b97c 	xorhi	r4,r16,18149
8111b94c:	8111baa4 	muli	r4,r16,18154
8111b950:	8111ba90 	cmplti	r4,r16,18154
8111b954:	8111baa4 	muli	r4,r16,18154
8111b958:	8111b97c 	xorhi	r4,r16,18149
8111b95c:	8111bab0 	cmpltui	r4,r16,18154
8111b960:	8111bab0 	cmpltui	r4,r16,18154
8111b964:	8111bab0 	cmpltui	r4,r16,18154
8111b968:	8111bb8c 	andi	r4,r16,18158
8111b96c:	90003b1e 	bne	r18,zero,8111ba5c <__mulsf3+0x20c>
8111b970:	04400204 	movi	r17,8
8111b974:	05c00084 	movi	r23,2
8111b978:	003fd206 	br	8111b8c4 <__reset+0xfb0fb8c4>
8111b97c:	302b883a 	mov	r21,r6
8111b980:	00800084 	movi	r2,2
8111b984:	18802626 	beq	r3,r2,8111ba20 <__mulsf3+0x1d0>
8111b988:	008000c4 	movi	r2,3
8111b98c:	1880ab26 	beq	r3,r2,8111bc3c <__mulsf3+0x3ec>
8111b990:	00800044 	movi	r2,1
8111b994:	1880a21e 	bne	r3,r2,8111bc20 <__mulsf3+0x3d0>
8111b998:	a829883a 	mov	r20,r21
8111b99c:	0007883a 	mov	r3,zero
8111b9a0:	0009883a 	mov	r4,zero
8111b9a4:	18803fcc 	andi	r2,r3,255
8111b9a8:	100695fa 	slli	r3,r2,23
8111b9ac:	a0803fcc 	andi	r2,r20,255
8111b9b0:	100a97fa 	slli	r5,r2,31
8111b9b4:	00802034 	movhi	r2,128
8111b9b8:	10bfffc4 	addi	r2,r2,-1
8111b9bc:	2084703a 	and	r2,r4,r2
8111b9c0:	10c4b03a 	or	r2,r2,r3
8111b9c4:	1144b03a 	or	r2,r2,r5
8111b9c8:	dfc00a17 	ldw	ra,40(sp)
8111b9cc:	df000917 	ldw	fp,36(sp)
8111b9d0:	ddc00817 	ldw	r23,32(sp)
8111b9d4:	dd800717 	ldw	r22,28(sp)
8111b9d8:	dd400617 	ldw	r21,24(sp)
8111b9dc:	dd000517 	ldw	r20,20(sp)
8111b9e0:	dcc00417 	ldw	r19,16(sp)
8111b9e4:	dc800317 	ldw	r18,12(sp)
8111b9e8:	dc400217 	ldw	r17,8(sp)
8111b9ec:	dc000117 	ldw	r16,4(sp)
8111b9f0:	dec00b04 	addi	sp,sp,44
8111b9f4:	f800283a 	ret
8111b9f8:	90000d1e 	bne	r18,zero,8111ba30 <__mulsf3+0x1e0>
8111b9fc:	04400104 	movi	r17,4
8111ba00:	05c00044 	movi	r23,1
8111ba04:	003faf06 	br	8111b8c4 <__reset+0xfb0fb8c4>
8111ba08:	9806c03a 	cmpne	r3,r19,zero
8111ba0c:	18c00084 	addi	r3,r3,2
8111ba10:	003fba06 	br	8111b8fc <__reset+0xfb0fb8fc>
8111ba14:	9800141e 	bne	r19,zero,8111ba68 <__mulsf3+0x218>
8111ba18:	00c00044 	movi	r3,1
8111ba1c:	003fb706 	br	8111b8fc <__reset+0xfb0fb8fc>
8111ba20:	a829883a 	mov	r20,r21
8111ba24:	00ffffc4 	movi	r3,-1
8111ba28:	0009883a 	mov	r4,zero
8111ba2c:	003fdd06 	br	8111b9a4 <__reset+0xfb0fb9a4>
8111ba30:	9009883a 	mov	r4,r18
8111ba34:	d9400015 	stw	r5,0(sp)
8111ba38:	111c8580 	call	8111c858 <__clzsi2>
8111ba3c:	10fffec4 	addi	r3,r2,-5
8111ba40:	10801d84 	addi	r2,r2,118
8111ba44:	90e4983a 	sll	r18,r18,r3
8111ba48:	00a1c83a 	sub	r16,zero,r2
8111ba4c:	0023883a 	mov	r17,zero
8111ba50:	002f883a 	mov	r23,zero
8111ba54:	d9400017 	ldw	r5,0(sp)
8111ba58:	003f9a06 	br	8111b8c4 <__reset+0xfb0fb8c4>
8111ba5c:	04400304 	movi	r17,12
8111ba60:	05c000c4 	movi	r23,3
8111ba64:	003f9706 	br	8111b8c4 <__reset+0xfb0fb8c4>
8111ba68:	9809883a 	mov	r4,r19
8111ba6c:	d9800015 	stw	r6,0(sp)
8111ba70:	111c8580 	call	8111c858 <__clzsi2>
8111ba74:	10fffec4 	addi	r3,r2,-5
8111ba78:	10801d84 	addi	r2,r2,118
8111ba7c:	98e6983a 	sll	r19,r19,r3
8111ba80:	0085c83a 	sub	r2,zero,r2
8111ba84:	0007883a 	mov	r3,zero
8111ba88:	d9800017 	ldw	r6,0(sp)
8111ba8c:	003f9b06 	br	8111b8fc <__reset+0xfb0fb8fc>
8111ba90:	01002034 	movhi	r4,128
8111ba94:	0029883a 	mov	r20,zero
8111ba98:	213fffc4 	addi	r4,r4,-1
8111ba9c:	00ffffc4 	movi	r3,-1
8111baa0:	003fc006 	br	8111b9a4 <__reset+0xfb0fb9a4>
8111baa4:	9027883a 	mov	r19,r18
8111baa8:	b807883a 	mov	r3,r23
8111baac:	003fb406 	br	8111b980 <__reset+0xfb0fb980>
8111bab0:	9027883a 	mov	r19,r18
8111bab4:	e02b883a 	mov	r21,fp
8111bab8:	b807883a 	mov	r3,r23
8111babc:	003fb006 	br	8111b980 <__reset+0xfb0fb980>
8111bac0:	9004d43a 	srli	r2,r18,16
8111bac4:	9810d43a 	srli	r8,r19,16
8111bac8:	94bfffcc 	andi	r18,r18,65535
8111bacc:	993fffcc 	andi	r4,r19,65535
8111bad0:	910d383a 	mul	r6,r18,r4
8111bad4:	20a7383a 	mul	r19,r4,r2
8111bad8:	9225383a 	mul	r18,r18,r8
8111badc:	3006d43a 	srli	r3,r6,16
8111bae0:	1211383a 	mul	r8,r2,r8
8111bae4:	94e5883a 	add	r18,r18,r19
8111bae8:	1c87883a 	add	r3,r3,r18
8111baec:	1cc0022e 	bgeu	r3,r19,8111baf8 <__mulsf3+0x2a8>
8111baf0:	00800074 	movhi	r2,1
8111baf4:	4091883a 	add	r8,r8,r2
8111baf8:	1804943a 	slli	r2,r3,16
8111bafc:	31bfffcc 	andi	r6,r6,65535
8111bb00:	1806d43a 	srli	r3,r3,16
8111bb04:	1185883a 	add	r2,r2,r6
8111bb08:	102691ba 	slli	r19,r2,6
8111bb0c:	1a07883a 	add	r3,r3,r8
8111bb10:	1004d6ba 	srli	r2,r2,26
8111bb14:	180891ba 	slli	r4,r3,6
8111bb18:	9826c03a 	cmpne	r19,r19,zero
8111bb1c:	9884b03a 	or	r2,r19,r2
8111bb20:	1126b03a 	or	r19,r2,r4
8111bb24:	9882002c 	andhi	r2,r19,2048
8111bb28:	10000426 	beq	r2,zero,8111bb3c <__mulsf3+0x2ec>
8111bb2c:	9804d07a 	srli	r2,r19,1
8111bb30:	9900004c 	andi	r4,r19,1
8111bb34:	3821883a 	mov	r16,r7
8111bb38:	1126b03a 	or	r19,r2,r4
8111bb3c:	80c01fc4 	addi	r3,r16,127
8111bb40:	00c0210e 	bge	zero,r3,8111bbc8 <__mulsf3+0x378>
8111bb44:	988001cc 	andi	r2,r19,7
8111bb48:	10000426 	beq	r2,zero,8111bb5c <__mulsf3+0x30c>
8111bb4c:	988003cc 	andi	r2,r19,15
8111bb50:	01000104 	movi	r4,4
8111bb54:	11000126 	beq	r2,r4,8111bb5c <__mulsf3+0x30c>
8111bb58:	9927883a 	add	r19,r19,r4
8111bb5c:	9882002c 	andhi	r2,r19,2048
8111bb60:	10000426 	beq	r2,zero,8111bb74 <__mulsf3+0x324>
8111bb64:	00be0034 	movhi	r2,63488
8111bb68:	10bfffc4 	addi	r2,r2,-1
8111bb6c:	80c02004 	addi	r3,r16,128
8111bb70:	98a6703a 	and	r19,r19,r2
8111bb74:	00803f84 	movi	r2,254
8111bb78:	10ffa916 	blt	r2,r3,8111ba20 <__reset+0xfb0fba20>
8111bb7c:	980891ba 	slli	r4,r19,6
8111bb80:	a829883a 	mov	r20,r21
8111bb84:	2008d27a 	srli	r4,r4,9
8111bb88:	003f8606 	br	8111b9a4 <__reset+0xfb0fb9a4>
8111bb8c:	9080102c 	andhi	r2,r18,64
8111bb90:	10000826 	beq	r2,zero,8111bbb4 <__mulsf3+0x364>
8111bb94:	9880102c 	andhi	r2,r19,64
8111bb98:	1000061e 	bne	r2,zero,8111bbb4 <__mulsf3+0x364>
8111bb9c:	00802034 	movhi	r2,128
8111bba0:	99001034 	orhi	r4,r19,64
8111bba4:	10bfffc4 	addi	r2,r2,-1
8111bba8:	b029883a 	mov	r20,r22
8111bbac:	2088703a 	and	r4,r4,r2
8111bbb0:	003fba06 	br	8111ba9c <__reset+0xfb0fba9c>
8111bbb4:	00802034 	movhi	r2,128
8111bbb8:	91001034 	orhi	r4,r18,64
8111bbbc:	10bfffc4 	addi	r2,r2,-1
8111bbc0:	2088703a 	and	r4,r4,r2
8111bbc4:	003fb506 	br	8111ba9c <__reset+0xfb0fba9c>
8111bbc8:	00800044 	movi	r2,1
8111bbcc:	10c7c83a 	sub	r3,r2,r3
8111bbd0:	008006c4 	movi	r2,27
8111bbd4:	10ff7016 	blt	r2,r3,8111b998 <__reset+0xfb0fb998>
8111bbd8:	00800804 	movi	r2,32
8111bbdc:	10c5c83a 	sub	r2,r2,r3
8111bbe0:	9884983a 	sll	r2,r19,r2
8111bbe4:	98c6d83a 	srl	r3,r19,r3
8111bbe8:	1004c03a 	cmpne	r2,r2,zero
8111bbec:	1884b03a 	or	r2,r3,r2
8111bbf0:	10c001cc 	andi	r3,r2,7
8111bbf4:	18000426 	beq	r3,zero,8111bc08 <__mulsf3+0x3b8>
8111bbf8:	10c003cc 	andi	r3,r2,15
8111bbfc:	01000104 	movi	r4,4
8111bc00:	19000126 	beq	r3,r4,8111bc08 <__mulsf3+0x3b8>
8111bc04:	1105883a 	add	r2,r2,r4
8111bc08:	10c1002c 	andhi	r3,r2,1024
8111bc0c:	18000626 	beq	r3,zero,8111bc28 <__mulsf3+0x3d8>
8111bc10:	a829883a 	mov	r20,r21
8111bc14:	00c00044 	movi	r3,1
8111bc18:	0009883a 	mov	r4,zero
8111bc1c:	003f6106 	br	8111b9a4 <__reset+0xfb0fb9a4>
8111bc20:	3821883a 	mov	r16,r7
8111bc24:	003fc506 	br	8111bb3c <__reset+0xfb0fbb3c>
8111bc28:	100491ba 	slli	r2,r2,6
8111bc2c:	a829883a 	mov	r20,r21
8111bc30:	0007883a 	mov	r3,zero
8111bc34:	1008d27a 	srli	r4,r2,9
8111bc38:	003f5a06 	br	8111b9a4 <__reset+0xfb0fb9a4>
8111bc3c:	00802034 	movhi	r2,128
8111bc40:	99001034 	orhi	r4,r19,64
8111bc44:	10bfffc4 	addi	r2,r2,-1
8111bc48:	a829883a 	mov	r20,r21
8111bc4c:	2088703a 	and	r4,r4,r2
8111bc50:	003f9206 	br	8111ba9c <__reset+0xfb0fba9c>

8111bc54 <__floatsisf>:
8111bc54:	defffd04 	addi	sp,sp,-12
8111bc58:	de00012e 	bgeu	sp,et,8111bc60 <__floatsisf+0xc>
8111bc5c:	003b68fa 	trap	3
8111bc60:	dfc00215 	stw	ra,8(sp)
8111bc64:	dc400115 	stw	r17,4(sp)
8111bc68:	dc000015 	stw	r16,0(sp)
8111bc6c:	20003526 	beq	r4,zero,8111bd44 <__floatsisf+0xf0>
8111bc70:	2021883a 	mov	r16,r4
8111bc74:	2022d7fa 	srli	r17,r4,31
8111bc78:	20003616 	blt	r4,zero,8111bd54 <__floatsisf+0x100>
8111bc7c:	8009883a 	mov	r4,r16
8111bc80:	111c8580 	call	8111c858 <__clzsi2>
8111bc84:	00c02784 	movi	r3,158
8111bc88:	1887c83a 	sub	r3,r3,r2
8111bc8c:	01002584 	movi	r4,150
8111bc90:	20c01416 	blt	r4,r3,8111bce4 <__floatsisf+0x90>
8111bc94:	20c9c83a 	sub	r4,r4,r3
8111bc98:	8120983a 	sll	r16,r16,r4
8111bc9c:	00802034 	movhi	r2,128
8111bca0:	10bfffc4 	addi	r2,r2,-1
8111bca4:	8809883a 	mov	r4,r17
8111bca8:	80a0703a 	and	r16,r16,r2
8111bcac:	18803fcc 	andi	r2,r3,255
8111bcb0:	100695fa 	slli	r3,r2,23
8111bcb4:	20803fcc 	andi	r2,r4,255
8111bcb8:	100897fa 	slli	r4,r2,31
8111bcbc:	00802034 	movhi	r2,128
8111bcc0:	10bfffc4 	addi	r2,r2,-1
8111bcc4:	8084703a 	and	r2,r16,r2
8111bcc8:	10c4b03a 	or	r2,r2,r3
8111bccc:	1104b03a 	or	r2,r2,r4
8111bcd0:	dfc00217 	ldw	ra,8(sp)
8111bcd4:	dc400117 	ldw	r17,4(sp)
8111bcd8:	dc000017 	ldw	r16,0(sp)
8111bcdc:	dec00304 	addi	sp,sp,12
8111bce0:	f800283a 	ret
8111bce4:	01002644 	movi	r4,153
8111bce8:	20c01c16 	blt	r4,r3,8111bd5c <__floatsisf+0x108>
8111bcec:	20c9c83a 	sub	r4,r4,r3
8111bcf0:	8120983a 	sll	r16,r16,r4
8111bcf4:	013f0034 	movhi	r4,64512
8111bcf8:	213fffc4 	addi	r4,r4,-1
8111bcfc:	814001cc 	andi	r5,r16,7
8111bd00:	8108703a 	and	r4,r16,r4
8111bd04:	28000426 	beq	r5,zero,8111bd18 <__floatsisf+0xc4>
8111bd08:	840003cc 	andi	r16,r16,15
8111bd0c:	01400104 	movi	r5,4
8111bd10:	81400126 	beq	r16,r5,8111bd18 <__floatsisf+0xc4>
8111bd14:	2149883a 	add	r4,r4,r5
8111bd18:	2141002c 	andhi	r5,r4,1024
8111bd1c:	28000526 	beq	r5,zero,8111bd34 <__floatsisf+0xe0>
8111bd20:	00c027c4 	movi	r3,159
8111bd24:	1887c83a 	sub	r3,r3,r2
8111bd28:	00bf0034 	movhi	r2,64512
8111bd2c:	10bfffc4 	addi	r2,r2,-1
8111bd30:	2088703a 	and	r4,r4,r2
8111bd34:	202091ba 	slli	r16,r4,6
8111bd38:	8809883a 	mov	r4,r17
8111bd3c:	8020d27a 	srli	r16,r16,9
8111bd40:	003fda06 	br	8111bcac <__reset+0xfb0fbcac>
8111bd44:	0009883a 	mov	r4,zero
8111bd48:	0007883a 	mov	r3,zero
8111bd4c:	0021883a 	mov	r16,zero
8111bd50:	003fd606 	br	8111bcac <__reset+0xfb0fbcac>
8111bd54:	0121c83a 	sub	r16,zero,r4
8111bd58:	003fc806 	br	8111bc7c <__reset+0xfb0fbc7c>
8111bd5c:	01002e44 	movi	r4,185
8111bd60:	20c9c83a 	sub	r4,r4,r3
8111bd64:	01400144 	movi	r5,5
8111bd68:	8108983a 	sll	r4,r16,r4
8111bd6c:	288bc83a 	sub	r5,r5,r2
8111bd70:	8160d83a 	srl	r16,r16,r5
8111bd74:	2008c03a 	cmpne	r4,r4,zero
8111bd78:	8120b03a 	or	r16,r16,r4
8111bd7c:	003fdd06 	br	8111bcf4 <__reset+0xfb0fbcf4>

8111bd80 <__floatunsisf>:
8111bd80:	defffe04 	addi	sp,sp,-8
8111bd84:	de00012e 	bgeu	sp,et,8111bd8c <__floatunsisf+0xc>
8111bd88:	003b68fa 	trap	3
8111bd8c:	dfc00115 	stw	ra,4(sp)
8111bd90:	dc000015 	stw	r16,0(sp)
8111bd94:	20002c26 	beq	r4,zero,8111be48 <__floatunsisf+0xc8>
8111bd98:	2021883a 	mov	r16,r4
8111bd9c:	111c8580 	call	8111c858 <__clzsi2>
8111bda0:	00c02784 	movi	r3,158
8111bda4:	1887c83a 	sub	r3,r3,r2
8111bda8:	01002584 	movi	r4,150
8111bdac:	20c00f16 	blt	r4,r3,8111bdec <__floatunsisf+0x6c>
8111bdb0:	20c9c83a 	sub	r4,r4,r3
8111bdb4:	8108983a 	sll	r4,r16,r4
8111bdb8:	00802034 	movhi	r2,128
8111bdbc:	10bfffc4 	addi	r2,r2,-1
8111bdc0:	2088703a 	and	r4,r4,r2
8111bdc4:	18803fcc 	andi	r2,r3,255
8111bdc8:	100695fa 	slli	r3,r2,23
8111bdcc:	00802034 	movhi	r2,128
8111bdd0:	10bfffc4 	addi	r2,r2,-1
8111bdd4:	2084703a 	and	r2,r4,r2
8111bdd8:	10c4b03a 	or	r2,r2,r3
8111bddc:	dfc00117 	ldw	ra,4(sp)
8111bde0:	dc000017 	ldw	r16,0(sp)
8111bde4:	dec00204 	addi	sp,sp,8
8111bde8:	f800283a 	ret
8111bdec:	01002644 	movi	r4,153
8111bdf0:	20c01816 	blt	r4,r3,8111be54 <__floatunsisf+0xd4>
8111bdf4:	20c9c83a 	sub	r4,r4,r3
8111bdf8:	8108983a 	sll	r4,r16,r4
8111bdfc:	017f0034 	movhi	r5,64512
8111be00:	297fffc4 	addi	r5,r5,-1
8111be04:	218001cc 	andi	r6,r4,7
8111be08:	214a703a 	and	r5,r4,r5
8111be0c:	30000426 	beq	r6,zero,8111be20 <__floatunsisf+0xa0>
8111be10:	210003cc 	andi	r4,r4,15
8111be14:	01800104 	movi	r6,4
8111be18:	21800126 	beq	r4,r6,8111be20 <__floatunsisf+0xa0>
8111be1c:	298b883a 	add	r5,r5,r6
8111be20:	2901002c 	andhi	r4,r5,1024
8111be24:	20000526 	beq	r4,zero,8111be3c <__floatunsisf+0xbc>
8111be28:	00c027c4 	movi	r3,159
8111be2c:	1887c83a 	sub	r3,r3,r2
8111be30:	00bf0034 	movhi	r2,64512
8111be34:	10bfffc4 	addi	r2,r2,-1
8111be38:	288a703a 	and	r5,r5,r2
8111be3c:	280891ba 	slli	r4,r5,6
8111be40:	2008d27a 	srli	r4,r4,9
8111be44:	003fdf06 	br	8111bdc4 <__reset+0xfb0fbdc4>
8111be48:	0007883a 	mov	r3,zero
8111be4c:	0009883a 	mov	r4,zero
8111be50:	003fdc06 	br	8111bdc4 <__reset+0xfb0fbdc4>
8111be54:	01402e44 	movi	r5,185
8111be58:	28cbc83a 	sub	r5,r5,r3
8111be5c:	01000144 	movi	r4,5
8111be60:	2089c83a 	sub	r4,r4,r2
8111be64:	814a983a 	sll	r5,r16,r5
8111be68:	8108d83a 	srl	r4,r16,r4
8111be6c:	2820c03a 	cmpne	r16,r5,zero
8111be70:	2408b03a 	or	r4,r4,r16
8111be74:	003fe106 	br	8111bdfc <__reset+0xfb0fbdfc>

8111be78 <__muldf3>:
8111be78:	defff304 	addi	sp,sp,-52
8111be7c:	2804d53a 	srli	r2,r5,20
8111be80:	de00012e 	bgeu	sp,et,8111be88 <__muldf3+0x10>
8111be84:	003b68fa 	trap	3
8111be88:	dd800915 	stw	r22,36(sp)
8111be8c:	282cd7fa 	srli	r22,r5,31
8111be90:	dc000315 	stw	r16,12(sp)
8111be94:	04000434 	movhi	r16,16
8111be98:	dd400815 	stw	r21,32(sp)
8111be9c:	dc800515 	stw	r18,20(sp)
8111bea0:	843fffc4 	addi	r16,r16,-1
8111bea4:	dfc00c15 	stw	ra,48(sp)
8111bea8:	df000b15 	stw	fp,44(sp)
8111beac:	ddc00a15 	stw	r23,40(sp)
8111beb0:	dd000715 	stw	r20,28(sp)
8111beb4:	dcc00615 	stw	r19,24(sp)
8111beb8:	dc400415 	stw	r17,16(sp)
8111bebc:	1481ffcc 	andi	r18,r2,2047
8111bec0:	2c20703a 	and	r16,r5,r16
8111bec4:	b02b883a 	mov	r21,r22
8111bec8:	b2403fcc 	andi	r9,r22,255
8111becc:	90006026 	beq	r18,zero,8111c050 <__muldf3+0x1d8>
8111bed0:	0081ffc4 	movi	r2,2047
8111bed4:	2029883a 	mov	r20,r4
8111bed8:	90803626 	beq	r18,r2,8111bfb4 <__muldf3+0x13c>
8111bedc:	80800434 	orhi	r2,r16,16
8111bee0:	100490fa 	slli	r2,r2,3
8111bee4:	2020d77a 	srli	r16,r4,29
8111bee8:	202890fa 	slli	r20,r4,3
8111beec:	94bf0044 	addi	r18,r18,-1023
8111bef0:	80a0b03a 	or	r16,r16,r2
8111bef4:	0027883a 	mov	r19,zero
8111bef8:	0039883a 	mov	fp,zero
8111befc:	3804d53a 	srli	r2,r7,20
8111bf00:	382ed7fa 	srli	r23,r7,31
8111bf04:	04400434 	movhi	r17,16
8111bf08:	8c7fffc4 	addi	r17,r17,-1
8111bf0c:	1081ffcc 	andi	r2,r2,2047
8111bf10:	3011883a 	mov	r8,r6
8111bf14:	3c62703a 	and	r17,r7,r17
8111bf18:	ba803fcc 	andi	r10,r23,255
8111bf1c:	10006d26 	beq	r2,zero,8111c0d4 <__muldf3+0x25c>
8111bf20:	00c1ffc4 	movi	r3,2047
8111bf24:	10c06526 	beq	r2,r3,8111c0bc <__muldf3+0x244>
8111bf28:	88c00434 	orhi	r3,r17,16
8111bf2c:	180690fa 	slli	r3,r3,3
8111bf30:	3022d77a 	srli	r17,r6,29
8111bf34:	301090fa 	slli	r8,r6,3
8111bf38:	10bf0044 	addi	r2,r2,-1023
8111bf3c:	88e2b03a 	or	r17,r17,r3
8111bf40:	000b883a 	mov	r5,zero
8111bf44:	9085883a 	add	r2,r18,r2
8111bf48:	2cc8b03a 	or	r4,r5,r19
8111bf4c:	00c003c4 	movi	r3,15
8111bf50:	bdacf03a 	xor	r22,r23,r22
8111bf54:	12c00044 	addi	r11,r2,1
8111bf58:	19009936 	bltu	r3,r4,8111c1c0 <__muldf3+0x348>
8111bf5c:	200890ba 	slli	r4,r4,2
8111bf60:	00e044b4 	movhi	r3,33042
8111bf64:	18efdd04 	addi	r3,r3,-16524
8111bf68:	20c9883a 	add	r4,r4,r3
8111bf6c:	20c00017 	ldw	r3,0(r4)
8111bf70:	1800683a 	jmp	r3
8111bf74:	8111c1c0 	call	88111c1c <__reset+0x20f1c1c>
8111bf78:	8111bfd4 	ori	r4,r16,18175
8111bf7c:	8111bfd4 	ori	r4,r16,18175
8111bf80:	8111bfd0 	cmplti	r4,r16,18175
8111bf84:	8111c19c 	xori	r4,r16,18182
8111bf88:	8111c19c 	xori	r4,r16,18182
8111bf8c:	8111c184 	addi	r4,r16,18182
8111bf90:	8111bfd0 	cmplti	r4,r16,18175
8111bf94:	8111c19c 	xori	r4,r16,18182
8111bf98:	8111c184 	addi	r4,r16,18182
8111bf9c:	8111c19c 	xori	r4,r16,18182
8111bfa0:	8111bfd0 	cmplti	r4,r16,18175
8111bfa4:	8111c1ac 	andhi	r4,r16,18182
8111bfa8:	8111c1ac 	andhi	r4,r16,18182
8111bfac:	8111c1ac 	andhi	r4,r16,18182
8111bfb0:	8111c3c8 	cmpgei	r4,r16,18191
8111bfb4:	2404b03a 	or	r2,r4,r16
8111bfb8:	10006f1e 	bne	r2,zero,8111c178 <__muldf3+0x300>
8111bfbc:	04c00204 	movi	r19,8
8111bfc0:	0021883a 	mov	r16,zero
8111bfc4:	0029883a 	mov	r20,zero
8111bfc8:	07000084 	movi	fp,2
8111bfcc:	003fcb06 	br	8111befc <__reset+0xfb0fbefc>
8111bfd0:	502d883a 	mov	r22,r10
8111bfd4:	00800084 	movi	r2,2
8111bfd8:	28805726 	beq	r5,r2,8111c138 <__muldf3+0x2c0>
8111bfdc:	008000c4 	movi	r2,3
8111bfe0:	28816626 	beq	r5,r2,8111c57c <__muldf3+0x704>
8111bfe4:	00800044 	movi	r2,1
8111bfe8:	2881411e 	bne	r5,r2,8111c4f0 <__muldf3+0x678>
8111bfec:	b02b883a 	mov	r21,r22
8111bff0:	0005883a 	mov	r2,zero
8111bff4:	000b883a 	mov	r5,zero
8111bff8:	0029883a 	mov	r20,zero
8111bffc:	1004953a 	slli	r2,r2,20
8111c000:	a8c03fcc 	andi	r3,r21,255
8111c004:	04400434 	movhi	r17,16
8111c008:	8c7fffc4 	addi	r17,r17,-1
8111c00c:	180697fa 	slli	r3,r3,31
8111c010:	2c4a703a 	and	r5,r5,r17
8111c014:	288ab03a 	or	r5,r5,r2
8111c018:	28c6b03a 	or	r3,r5,r3
8111c01c:	a005883a 	mov	r2,r20
8111c020:	dfc00c17 	ldw	ra,48(sp)
8111c024:	df000b17 	ldw	fp,44(sp)
8111c028:	ddc00a17 	ldw	r23,40(sp)
8111c02c:	dd800917 	ldw	r22,36(sp)
8111c030:	dd400817 	ldw	r21,32(sp)
8111c034:	dd000717 	ldw	r20,28(sp)
8111c038:	dcc00617 	ldw	r19,24(sp)
8111c03c:	dc800517 	ldw	r18,20(sp)
8111c040:	dc400417 	ldw	r17,16(sp)
8111c044:	dc000317 	ldw	r16,12(sp)
8111c048:	dec00d04 	addi	sp,sp,52
8111c04c:	f800283a 	ret
8111c050:	2404b03a 	or	r2,r4,r16
8111c054:	2027883a 	mov	r19,r4
8111c058:	10004226 	beq	r2,zero,8111c164 <__muldf3+0x2ec>
8111c05c:	8000fc26 	beq	r16,zero,8111c450 <__muldf3+0x5d8>
8111c060:	8009883a 	mov	r4,r16
8111c064:	d9800215 	stw	r6,8(sp)
8111c068:	d9c00015 	stw	r7,0(sp)
8111c06c:	da400115 	stw	r9,4(sp)
8111c070:	111c8580 	call	8111c858 <__clzsi2>
8111c074:	d9800217 	ldw	r6,8(sp)
8111c078:	d9c00017 	ldw	r7,0(sp)
8111c07c:	da400117 	ldw	r9,4(sp)
8111c080:	113ffd44 	addi	r4,r2,-11
8111c084:	00c00704 	movi	r3,28
8111c088:	1900ed16 	blt	r3,r4,8111c440 <__muldf3+0x5c8>
8111c08c:	00c00744 	movi	r3,29
8111c090:	147ffe04 	addi	r17,r2,-8
8111c094:	1907c83a 	sub	r3,r3,r4
8111c098:	8460983a 	sll	r16,r16,r17
8111c09c:	98c6d83a 	srl	r3,r19,r3
8111c0a0:	9c68983a 	sll	r20,r19,r17
8111c0a4:	1c20b03a 	or	r16,r3,r16
8111c0a8:	1080fcc4 	addi	r2,r2,1011
8111c0ac:	00a5c83a 	sub	r18,zero,r2
8111c0b0:	0027883a 	mov	r19,zero
8111c0b4:	0039883a 	mov	fp,zero
8111c0b8:	003f9006 	br	8111befc <__reset+0xfb0fbefc>
8111c0bc:	3446b03a 	or	r3,r6,r17
8111c0c0:	1800261e 	bne	r3,zero,8111c15c <__muldf3+0x2e4>
8111c0c4:	0023883a 	mov	r17,zero
8111c0c8:	0011883a 	mov	r8,zero
8111c0cc:	01400084 	movi	r5,2
8111c0d0:	003f9c06 	br	8111bf44 <__reset+0xfb0fbf44>
8111c0d4:	3446b03a 	or	r3,r6,r17
8111c0d8:	18001c26 	beq	r3,zero,8111c14c <__muldf3+0x2d4>
8111c0dc:	8800ce26 	beq	r17,zero,8111c418 <__muldf3+0x5a0>
8111c0e0:	8809883a 	mov	r4,r17
8111c0e4:	d9800215 	stw	r6,8(sp)
8111c0e8:	da400115 	stw	r9,4(sp)
8111c0ec:	da800015 	stw	r10,0(sp)
8111c0f0:	111c8580 	call	8111c858 <__clzsi2>
8111c0f4:	d9800217 	ldw	r6,8(sp)
8111c0f8:	da400117 	ldw	r9,4(sp)
8111c0fc:	da800017 	ldw	r10,0(sp)
8111c100:	113ffd44 	addi	r4,r2,-11
8111c104:	00c00704 	movi	r3,28
8111c108:	1900bf16 	blt	r3,r4,8111c408 <__muldf3+0x590>
8111c10c:	00c00744 	movi	r3,29
8111c110:	123ffe04 	addi	r8,r2,-8
8111c114:	1907c83a 	sub	r3,r3,r4
8111c118:	8a22983a 	sll	r17,r17,r8
8111c11c:	30c6d83a 	srl	r3,r6,r3
8111c120:	3210983a 	sll	r8,r6,r8
8111c124:	1c62b03a 	or	r17,r3,r17
8111c128:	1080fcc4 	addi	r2,r2,1011
8111c12c:	0085c83a 	sub	r2,zero,r2
8111c130:	000b883a 	mov	r5,zero
8111c134:	003f8306 	br	8111bf44 <__reset+0xfb0fbf44>
8111c138:	b02b883a 	mov	r21,r22
8111c13c:	0081ffc4 	movi	r2,2047
8111c140:	000b883a 	mov	r5,zero
8111c144:	0029883a 	mov	r20,zero
8111c148:	003fac06 	br	8111bffc <__reset+0xfb0fbffc>
8111c14c:	0023883a 	mov	r17,zero
8111c150:	0011883a 	mov	r8,zero
8111c154:	01400044 	movi	r5,1
8111c158:	003f7a06 	br	8111bf44 <__reset+0xfb0fbf44>
8111c15c:	014000c4 	movi	r5,3
8111c160:	003f7806 	br	8111bf44 <__reset+0xfb0fbf44>
8111c164:	04c00104 	movi	r19,4
8111c168:	0021883a 	mov	r16,zero
8111c16c:	0029883a 	mov	r20,zero
8111c170:	07000044 	movi	fp,1
8111c174:	003f6106 	br	8111befc <__reset+0xfb0fbefc>
8111c178:	04c00304 	movi	r19,12
8111c17c:	070000c4 	movi	fp,3
8111c180:	003f5e06 	br	8111befc <__reset+0xfb0fbefc>
8111c184:	01400434 	movhi	r5,16
8111c188:	002b883a 	mov	r21,zero
8111c18c:	297fffc4 	addi	r5,r5,-1
8111c190:	053fffc4 	movi	r20,-1
8111c194:	0081ffc4 	movi	r2,2047
8111c198:	003f9806 	br	8111bffc <__reset+0xfb0fbffc>
8111c19c:	8023883a 	mov	r17,r16
8111c1a0:	a011883a 	mov	r8,r20
8111c1a4:	e00b883a 	mov	r5,fp
8111c1a8:	003f8a06 	br	8111bfd4 <__reset+0xfb0fbfd4>
8111c1ac:	8023883a 	mov	r17,r16
8111c1b0:	a011883a 	mov	r8,r20
8111c1b4:	482d883a 	mov	r22,r9
8111c1b8:	e00b883a 	mov	r5,fp
8111c1bc:	003f8506 	br	8111bfd4 <__reset+0xfb0fbfd4>
8111c1c0:	a00ad43a 	srli	r5,r20,16
8111c1c4:	401ad43a 	srli	r13,r8,16
8111c1c8:	a53fffcc 	andi	r20,r20,65535
8111c1cc:	423fffcc 	andi	r8,r8,65535
8111c1d0:	4519383a 	mul	r12,r8,r20
8111c1d4:	4147383a 	mul	r3,r8,r5
8111c1d8:	6d09383a 	mul	r4,r13,r20
8111c1dc:	600cd43a 	srli	r6,r12,16
8111c1e0:	2b5d383a 	mul	r14,r5,r13
8111c1e4:	20c9883a 	add	r4,r4,r3
8111c1e8:	310d883a 	add	r6,r6,r4
8111c1ec:	30c0022e 	bgeu	r6,r3,8111c1f8 <__muldf3+0x380>
8111c1f0:	00c00074 	movhi	r3,1
8111c1f4:	70dd883a 	add	r14,r14,r3
8111c1f8:	8826d43a 	srli	r19,r17,16
8111c1fc:	8bffffcc 	andi	r15,r17,65535
8111c200:	7d23383a 	mul	r17,r15,r20
8111c204:	7949383a 	mul	r4,r15,r5
8111c208:	9d29383a 	mul	r20,r19,r20
8111c20c:	8814d43a 	srli	r10,r17,16
8111c210:	3012943a 	slli	r9,r6,16
8111c214:	a129883a 	add	r20,r20,r4
8111c218:	633fffcc 	andi	r12,r12,65535
8111c21c:	5515883a 	add	r10,r10,r20
8111c220:	3006d43a 	srli	r3,r6,16
8111c224:	4b13883a 	add	r9,r9,r12
8111c228:	2ccb383a 	mul	r5,r5,r19
8111c22c:	5100022e 	bgeu	r10,r4,8111c238 <__muldf3+0x3c0>
8111c230:	01000074 	movhi	r4,1
8111c234:	290b883a 	add	r5,r5,r4
8111c238:	802ad43a 	srli	r21,r16,16
8111c23c:	843fffcc 	andi	r16,r16,65535
8111c240:	440d383a 	mul	r6,r8,r16
8111c244:	4565383a 	mul	r18,r8,r21
8111c248:	8349383a 	mul	r4,r16,r13
8111c24c:	500e943a 	slli	r7,r10,16
8111c250:	3010d43a 	srli	r8,r6,16
8111c254:	5028d43a 	srli	r20,r10,16
8111c258:	2489883a 	add	r4,r4,r18
8111c25c:	8abfffcc 	andi	r10,r17,65535
8111c260:	3a95883a 	add	r10,r7,r10
8111c264:	4119883a 	add	r12,r8,r4
8111c268:	a169883a 	add	r20,r20,r5
8111c26c:	1a87883a 	add	r3,r3,r10
8111c270:	6d5b383a 	mul	r13,r13,r21
8111c274:	6480022e 	bgeu	r12,r18,8111c280 <__muldf3+0x408>
8111c278:	01000074 	movhi	r4,1
8111c27c:	691b883a 	add	r13,r13,r4
8111c280:	7c25383a 	mul	r18,r15,r16
8111c284:	7d4b383a 	mul	r5,r15,r21
8111c288:	84cf383a 	mul	r7,r16,r19
8111c28c:	901ed43a 	srli	r15,r18,16
8111c290:	6008d43a 	srli	r4,r12,16
8111c294:	6010943a 	slli	r8,r12,16
8111c298:	394f883a 	add	r7,r7,r5
8111c29c:	333fffcc 	andi	r12,r6,65535
8111c2a0:	79df883a 	add	r15,r15,r7
8111c2a4:	235b883a 	add	r13,r4,r13
8111c2a8:	9d63383a 	mul	r17,r19,r21
8111c2ac:	4309883a 	add	r4,r8,r12
8111c2b0:	7940022e 	bgeu	r15,r5,8111c2bc <__muldf3+0x444>
8111c2b4:	01400074 	movhi	r5,1
8111c2b8:	8963883a 	add	r17,r17,r5
8111c2bc:	780a943a 	slli	r5,r15,16
8111c2c0:	91bfffcc 	andi	r6,r18,65535
8111c2c4:	70c7883a 	add	r3,r14,r3
8111c2c8:	298d883a 	add	r6,r5,r6
8111c2cc:	1a8f803a 	cmpltu	r7,r3,r10
8111c2d0:	350b883a 	add	r5,r6,r20
8111c2d4:	20c7883a 	add	r3,r4,r3
8111c2d8:	3955883a 	add	r10,r7,r5
8111c2dc:	1909803a 	cmpltu	r4,r3,r4
8111c2e0:	6a91883a 	add	r8,r13,r10
8111c2e4:	780cd43a 	srli	r6,r15,16
8111c2e8:	2219883a 	add	r12,r4,r8
8111c2ec:	2d0b803a 	cmpltu	r5,r5,r20
8111c2f0:	51cf803a 	cmpltu	r7,r10,r7
8111c2f4:	29ceb03a 	or	r7,r5,r7
8111c2f8:	4351803a 	cmpltu	r8,r8,r13
8111c2fc:	610b803a 	cmpltu	r5,r12,r4
8111c300:	4148b03a 	or	r4,r8,r5
8111c304:	398f883a 	add	r7,r7,r6
8111c308:	3909883a 	add	r4,r7,r4
8111c30c:	1810927a 	slli	r8,r3,9
8111c310:	2449883a 	add	r4,r4,r17
8111c314:	2008927a 	slli	r4,r4,9
8111c318:	6022d5fa 	srli	r17,r12,23
8111c31c:	1806d5fa 	srli	r3,r3,23
8111c320:	4252b03a 	or	r9,r8,r9
8111c324:	600a927a 	slli	r5,r12,9
8111c328:	4810c03a 	cmpne	r8,r9,zero
8111c32c:	2462b03a 	or	r17,r4,r17
8111c330:	40c6b03a 	or	r3,r8,r3
8111c334:	8900402c 	andhi	r4,r17,256
8111c338:	1950b03a 	or	r8,r3,r5
8111c33c:	20000726 	beq	r4,zero,8111c35c <__muldf3+0x4e4>
8111c340:	4006d07a 	srli	r3,r8,1
8111c344:	880497fa 	slli	r2,r17,31
8111c348:	4200004c 	andi	r8,r8,1
8111c34c:	8822d07a 	srli	r17,r17,1
8111c350:	1a10b03a 	or	r8,r3,r8
8111c354:	1210b03a 	or	r8,r2,r8
8111c358:	5805883a 	mov	r2,r11
8111c35c:	1140ffc4 	addi	r5,r2,1023
8111c360:	0140440e 	bge	zero,r5,8111c474 <__muldf3+0x5fc>
8111c364:	40c001cc 	andi	r3,r8,7
8111c368:	18000726 	beq	r3,zero,8111c388 <__muldf3+0x510>
8111c36c:	40c003cc 	andi	r3,r8,15
8111c370:	01000104 	movi	r4,4
8111c374:	19000426 	beq	r3,r4,8111c388 <__muldf3+0x510>
8111c378:	4107883a 	add	r3,r8,r4
8111c37c:	1a11803a 	cmpltu	r8,r3,r8
8111c380:	8a23883a 	add	r17,r17,r8
8111c384:	1811883a 	mov	r8,r3
8111c388:	88c0402c 	andhi	r3,r17,256
8111c38c:	18000426 	beq	r3,zero,8111c3a0 <__muldf3+0x528>
8111c390:	11410004 	addi	r5,r2,1024
8111c394:	00bfc034 	movhi	r2,65280
8111c398:	10bfffc4 	addi	r2,r2,-1
8111c39c:	88a2703a 	and	r17,r17,r2
8111c3a0:	0081ff84 	movi	r2,2046
8111c3a4:	117f6416 	blt	r2,r5,8111c138 <__reset+0xfb0fc138>
8111c3a8:	8828977a 	slli	r20,r17,29
8111c3ac:	4010d0fa 	srli	r8,r8,3
8111c3b0:	8822927a 	slli	r17,r17,9
8111c3b4:	2881ffcc 	andi	r2,r5,2047
8111c3b8:	a228b03a 	or	r20,r20,r8
8111c3bc:	880ad33a 	srli	r5,r17,12
8111c3c0:	b02b883a 	mov	r21,r22
8111c3c4:	003f0d06 	br	8111bffc <__reset+0xfb0fbffc>
8111c3c8:	8080022c 	andhi	r2,r16,8
8111c3cc:	10000926 	beq	r2,zero,8111c3f4 <__muldf3+0x57c>
8111c3d0:	8880022c 	andhi	r2,r17,8
8111c3d4:	1000071e 	bne	r2,zero,8111c3f4 <__muldf3+0x57c>
8111c3d8:	00800434 	movhi	r2,16
8111c3dc:	89400234 	orhi	r5,r17,8
8111c3e0:	10bfffc4 	addi	r2,r2,-1
8111c3e4:	b82b883a 	mov	r21,r23
8111c3e8:	288a703a 	and	r5,r5,r2
8111c3ec:	4029883a 	mov	r20,r8
8111c3f0:	003f6806 	br	8111c194 <__reset+0xfb0fc194>
8111c3f4:	00800434 	movhi	r2,16
8111c3f8:	81400234 	orhi	r5,r16,8
8111c3fc:	10bfffc4 	addi	r2,r2,-1
8111c400:	288a703a 	and	r5,r5,r2
8111c404:	003f6306 	br	8111c194 <__reset+0xfb0fc194>
8111c408:	147ff604 	addi	r17,r2,-40
8111c40c:	3462983a 	sll	r17,r6,r17
8111c410:	0011883a 	mov	r8,zero
8111c414:	003f4406 	br	8111c128 <__reset+0xfb0fc128>
8111c418:	3009883a 	mov	r4,r6
8111c41c:	d9800215 	stw	r6,8(sp)
8111c420:	da400115 	stw	r9,4(sp)
8111c424:	da800015 	stw	r10,0(sp)
8111c428:	111c8580 	call	8111c858 <__clzsi2>
8111c42c:	10800804 	addi	r2,r2,32
8111c430:	da800017 	ldw	r10,0(sp)
8111c434:	da400117 	ldw	r9,4(sp)
8111c438:	d9800217 	ldw	r6,8(sp)
8111c43c:	003f3006 	br	8111c100 <__reset+0xfb0fc100>
8111c440:	143ff604 	addi	r16,r2,-40
8111c444:	9c20983a 	sll	r16,r19,r16
8111c448:	0029883a 	mov	r20,zero
8111c44c:	003f1606 	br	8111c0a8 <__reset+0xfb0fc0a8>
8111c450:	d9800215 	stw	r6,8(sp)
8111c454:	d9c00015 	stw	r7,0(sp)
8111c458:	da400115 	stw	r9,4(sp)
8111c45c:	111c8580 	call	8111c858 <__clzsi2>
8111c460:	10800804 	addi	r2,r2,32
8111c464:	da400117 	ldw	r9,4(sp)
8111c468:	d9c00017 	ldw	r7,0(sp)
8111c46c:	d9800217 	ldw	r6,8(sp)
8111c470:	003f0306 	br	8111c080 <__reset+0xfb0fc080>
8111c474:	00c00044 	movi	r3,1
8111c478:	1947c83a 	sub	r3,r3,r5
8111c47c:	00800e04 	movi	r2,56
8111c480:	10feda16 	blt	r2,r3,8111bfec <__reset+0xfb0fbfec>
8111c484:	008007c4 	movi	r2,31
8111c488:	10c01b16 	blt	r2,r3,8111c4f8 <__muldf3+0x680>
8111c48c:	00800804 	movi	r2,32
8111c490:	10c5c83a 	sub	r2,r2,r3
8111c494:	888a983a 	sll	r5,r17,r2
8111c498:	40c8d83a 	srl	r4,r8,r3
8111c49c:	4084983a 	sll	r2,r8,r2
8111c4a0:	88e2d83a 	srl	r17,r17,r3
8111c4a4:	2906b03a 	or	r3,r5,r4
8111c4a8:	1004c03a 	cmpne	r2,r2,zero
8111c4ac:	1886b03a 	or	r3,r3,r2
8111c4b0:	188001cc 	andi	r2,r3,7
8111c4b4:	10000726 	beq	r2,zero,8111c4d4 <__muldf3+0x65c>
8111c4b8:	188003cc 	andi	r2,r3,15
8111c4bc:	01000104 	movi	r4,4
8111c4c0:	11000426 	beq	r2,r4,8111c4d4 <__muldf3+0x65c>
8111c4c4:	1805883a 	mov	r2,r3
8111c4c8:	10c00104 	addi	r3,r2,4
8111c4cc:	1885803a 	cmpltu	r2,r3,r2
8111c4d0:	88a3883a 	add	r17,r17,r2
8111c4d4:	8880202c 	andhi	r2,r17,128
8111c4d8:	10001c26 	beq	r2,zero,8111c54c <__muldf3+0x6d4>
8111c4dc:	b02b883a 	mov	r21,r22
8111c4e0:	00800044 	movi	r2,1
8111c4e4:	000b883a 	mov	r5,zero
8111c4e8:	0029883a 	mov	r20,zero
8111c4ec:	003ec306 	br	8111bffc <__reset+0xfb0fbffc>
8111c4f0:	5805883a 	mov	r2,r11
8111c4f4:	003f9906 	br	8111c35c <__reset+0xfb0fc35c>
8111c4f8:	00bff844 	movi	r2,-31
8111c4fc:	1145c83a 	sub	r2,r2,r5
8111c500:	8888d83a 	srl	r4,r17,r2
8111c504:	00800804 	movi	r2,32
8111c508:	18801a26 	beq	r3,r2,8111c574 <__muldf3+0x6fc>
8111c50c:	00801004 	movi	r2,64
8111c510:	10c5c83a 	sub	r2,r2,r3
8111c514:	8884983a 	sll	r2,r17,r2
8111c518:	1204b03a 	or	r2,r2,r8
8111c51c:	1004c03a 	cmpne	r2,r2,zero
8111c520:	2084b03a 	or	r2,r4,r2
8111c524:	144001cc 	andi	r17,r2,7
8111c528:	88000d1e 	bne	r17,zero,8111c560 <__muldf3+0x6e8>
8111c52c:	000b883a 	mov	r5,zero
8111c530:	1028d0fa 	srli	r20,r2,3
8111c534:	b02b883a 	mov	r21,r22
8111c538:	0005883a 	mov	r2,zero
8111c53c:	a468b03a 	or	r20,r20,r17
8111c540:	003eae06 	br	8111bffc <__reset+0xfb0fbffc>
8111c544:	1007883a 	mov	r3,r2
8111c548:	0023883a 	mov	r17,zero
8111c54c:	880a927a 	slli	r5,r17,9
8111c550:	1805883a 	mov	r2,r3
8111c554:	8822977a 	slli	r17,r17,29
8111c558:	280ad33a 	srli	r5,r5,12
8111c55c:	003ff406 	br	8111c530 <__reset+0xfb0fc530>
8111c560:	10c003cc 	andi	r3,r2,15
8111c564:	01000104 	movi	r4,4
8111c568:	193ff626 	beq	r3,r4,8111c544 <__reset+0xfb0fc544>
8111c56c:	0023883a 	mov	r17,zero
8111c570:	003fd506 	br	8111c4c8 <__reset+0xfb0fc4c8>
8111c574:	0005883a 	mov	r2,zero
8111c578:	003fe706 	br	8111c518 <__reset+0xfb0fc518>
8111c57c:	00800434 	movhi	r2,16
8111c580:	89400234 	orhi	r5,r17,8
8111c584:	10bfffc4 	addi	r2,r2,-1
8111c588:	b02b883a 	mov	r21,r22
8111c58c:	288a703a 	and	r5,r5,r2
8111c590:	4029883a 	mov	r20,r8
8111c594:	003eff06 	br	8111c194 <__reset+0xfb0fc194>

8111c598 <__extendsfdf2>:
8111c598:	200ad5fa 	srli	r5,r4,23
8111c59c:	defffd04 	addi	sp,sp,-12
8111c5a0:	de00012e 	bgeu	sp,et,8111c5a8 <__extendsfdf2+0x10>
8111c5a4:	003b68fa 	trap	3
8111c5a8:	29403fcc 	andi	r5,r5,255
8111c5ac:	dc400115 	stw	r17,4(sp)
8111c5b0:	29800044 	addi	r6,r5,1
8111c5b4:	04402034 	movhi	r17,128
8111c5b8:	dc000015 	stw	r16,0(sp)
8111c5bc:	8c7fffc4 	addi	r17,r17,-1
8111c5c0:	dfc00215 	stw	ra,8(sp)
8111c5c4:	31803fcc 	andi	r6,r6,255
8111c5c8:	00800044 	movi	r2,1
8111c5cc:	8922703a 	and	r17,r17,r4
8111c5d0:	2020d7fa 	srli	r16,r4,31
8111c5d4:	1180110e 	bge	r2,r6,8111c61c <__extendsfdf2+0x84>
8111c5d8:	880cd0fa 	srli	r6,r17,3
8111c5dc:	8822977a 	slli	r17,r17,29
8111c5e0:	2940e004 	addi	r5,r5,896
8111c5e4:	2941ffcc 	andi	r5,r5,2047
8111c5e8:	2804953a 	slli	r2,r5,20
8111c5ec:	01400434 	movhi	r5,16
8111c5f0:	800697fa 	slli	r3,r16,31
8111c5f4:	297fffc4 	addi	r5,r5,-1
8111c5f8:	314a703a 	and	r5,r6,r5
8111c5fc:	288ab03a 	or	r5,r5,r2
8111c600:	28c6b03a 	or	r3,r5,r3
8111c604:	8805883a 	mov	r2,r17
8111c608:	dfc00217 	ldw	ra,8(sp)
8111c60c:	dc400117 	ldw	r17,4(sp)
8111c610:	dc000017 	ldw	r16,0(sp)
8111c614:	dec00304 	addi	sp,sp,12
8111c618:	f800283a 	ret
8111c61c:	2800111e 	bne	r5,zero,8111c664 <__extendsfdf2+0xcc>
8111c620:	88001c26 	beq	r17,zero,8111c694 <__extendsfdf2+0xfc>
8111c624:	8809883a 	mov	r4,r17
8111c628:	111c8580 	call	8111c858 <__clzsi2>
8111c62c:	00c00284 	movi	r3,10
8111c630:	18801b16 	blt	r3,r2,8111c6a0 <__extendsfdf2+0x108>
8111c634:	018002c4 	movi	r6,11
8111c638:	308dc83a 	sub	r6,r6,r2
8111c63c:	11000544 	addi	r4,r2,21
8111c640:	8986d83a 	srl	r3,r17,r6
8111c644:	8922983a 	sll	r17,r17,r4
8111c648:	0180e244 	movi	r6,905
8111c64c:	01400434 	movhi	r5,16
8111c650:	3085c83a 	sub	r2,r6,r2
8111c654:	297fffc4 	addi	r5,r5,-1
8111c658:	194c703a 	and	r6,r3,r5
8111c65c:	1141ffcc 	andi	r5,r2,2047
8111c660:	003fe006 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c664:	88000826 	beq	r17,zero,8111c688 <__extendsfdf2+0xf0>
8111c668:	880cd0fa 	srli	r6,r17,3
8111c66c:	00800434 	movhi	r2,16
8111c670:	10bfffc4 	addi	r2,r2,-1
8111c674:	31800234 	orhi	r6,r6,8
8111c678:	8822977a 	slli	r17,r17,29
8111c67c:	308c703a 	and	r6,r6,r2
8111c680:	0141ffc4 	movi	r5,2047
8111c684:	003fd706 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c688:	0141ffc4 	movi	r5,2047
8111c68c:	000d883a 	mov	r6,zero
8111c690:	003fd406 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c694:	000b883a 	mov	r5,zero
8111c698:	000d883a 	mov	r6,zero
8111c69c:	003fd106 	br	8111c5e4 <__reset+0xfb0fc5e4>
8111c6a0:	11bffd44 	addi	r6,r2,-11
8111c6a4:	8986983a 	sll	r3,r17,r6
8111c6a8:	0023883a 	mov	r17,zero
8111c6ac:	003fe606 	br	8111c648 <__reset+0xfb0fc648>

8111c6b0 <__truncdfsf2>:
8111c6b0:	2810d53a 	srli	r8,r5,20
8111c6b4:	01c00434 	movhi	r7,16
8111c6b8:	39ffffc4 	addi	r7,r7,-1
8111c6bc:	29ce703a 	and	r7,r5,r7
8111c6c0:	4201ffcc 	andi	r8,r8,2047
8111c6c4:	380e90fa 	slli	r7,r7,3
8111c6c8:	200cd77a 	srli	r6,r4,29
8111c6cc:	42400044 	addi	r9,r8,1
8111c6d0:	4a41ffcc 	andi	r9,r9,2047
8111c6d4:	00c00044 	movi	r3,1
8111c6d8:	280ad7fa 	srli	r5,r5,31
8111c6dc:	31ceb03a 	or	r7,r6,r7
8111c6e0:	200490fa 	slli	r2,r4,3
8111c6e4:	1a40230e 	bge	r3,r9,8111c774 <__truncdfsf2+0xc4>
8111c6e8:	40ff2004 	addi	r3,r8,-896
8111c6ec:	01803f84 	movi	r6,254
8111c6f0:	30c01516 	blt	r6,r3,8111c748 <__truncdfsf2+0x98>
8111c6f4:	00c0380e 	bge	zero,r3,8111c7d8 <__truncdfsf2+0x128>
8111c6f8:	200c91ba 	slli	r6,r4,6
8111c6fc:	380e90fa 	slli	r7,r7,3
8111c700:	1004d77a 	srli	r2,r2,29
8111c704:	300cc03a 	cmpne	r6,r6,zero
8111c708:	31ccb03a 	or	r6,r6,r7
8111c70c:	308cb03a 	or	r6,r6,r2
8111c710:	308001cc 	andi	r2,r6,7
8111c714:	10000426 	beq	r2,zero,8111c728 <__truncdfsf2+0x78>
8111c718:	308003cc 	andi	r2,r6,15
8111c71c:	01000104 	movi	r4,4
8111c720:	11000126 	beq	r2,r4,8111c728 <__truncdfsf2+0x78>
8111c724:	31800104 	addi	r6,r6,4
8111c728:	3081002c 	andhi	r2,r6,1024
8111c72c:	10001626 	beq	r2,zero,8111c788 <__truncdfsf2+0xd8>
8111c730:	18c00044 	addi	r3,r3,1
8111c734:	00803fc4 	movi	r2,255
8111c738:	18800326 	beq	r3,r2,8111c748 <__truncdfsf2+0x98>
8111c73c:	300c91ba 	slli	r6,r6,6
8111c740:	300cd27a 	srli	r6,r6,9
8111c744:	00000206 	br	8111c750 <__truncdfsf2+0xa0>
8111c748:	00ffffc4 	movi	r3,-1
8111c74c:	000d883a 	mov	r6,zero
8111c750:	18c03fcc 	andi	r3,r3,255
8111c754:	180895fa 	slli	r4,r3,23
8111c758:	00c02034 	movhi	r3,128
8111c75c:	280a97fa 	slli	r5,r5,31
8111c760:	18ffffc4 	addi	r3,r3,-1
8111c764:	30c6703a 	and	r3,r6,r3
8111c768:	1906b03a 	or	r3,r3,r4
8111c76c:	1944b03a 	or	r2,r3,r5
8111c770:	f800283a 	ret
8111c774:	40000b1e 	bne	r8,zero,8111c7a4 <__truncdfsf2+0xf4>
8111c778:	388cb03a 	or	r6,r7,r2
8111c77c:	0007883a 	mov	r3,zero
8111c780:	30000426 	beq	r6,zero,8111c794 <__truncdfsf2+0xe4>
8111c784:	01800144 	movi	r6,5
8111c788:	00803fc4 	movi	r2,255
8111c78c:	300cd0fa 	srli	r6,r6,3
8111c790:	18800a26 	beq	r3,r2,8111c7bc <__truncdfsf2+0x10c>
8111c794:	00802034 	movhi	r2,128
8111c798:	10bfffc4 	addi	r2,r2,-1
8111c79c:	308c703a 	and	r6,r6,r2
8111c7a0:	003feb06 	br	8111c750 <__reset+0xfb0fc750>
8111c7a4:	3888b03a 	or	r4,r7,r2
8111c7a8:	203fe726 	beq	r4,zero,8111c748 <__reset+0xfb0fc748>
8111c7ac:	380c90fa 	slli	r6,r7,3
8111c7b0:	00c03fc4 	movi	r3,255
8111c7b4:	31808034 	orhi	r6,r6,512
8111c7b8:	003fd506 	br	8111c710 <__reset+0xfb0fc710>
8111c7bc:	303fe226 	beq	r6,zero,8111c748 <__reset+0xfb0fc748>
8111c7c0:	00802034 	movhi	r2,128
8111c7c4:	31801034 	orhi	r6,r6,64
8111c7c8:	10bfffc4 	addi	r2,r2,-1
8111c7cc:	00ffffc4 	movi	r3,-1
8111c7d0:	308c703a 	and	r6,r6,r2
8111c7d4:	003fde06 	br	8111c750 <__reset+0xfb0fc750>
8111c7d8:	013ffa44 	movi	r4,-23
8111c7dc:	19000e16 	blt	r3,r4,8111c818 <__truncdfsf2+0x168>
8111c7e0:	01000784 	movi	r4,30
8111c7e4:	20c9c83a 	sub	r4,r4,r3
8111c7e8:	018007c4 	movi	r6,31
8111c7ec:	39c02034 	orhi	r7,r7,128
8111c7f0:	31000b16 	blt	r6,r4,8111c820 <__truncdfsf2+0x170>
8111c7f4:	423f2084 	addi	r8,r8,-894
8111c7f8:	120c983a 	sll	r6,r2,r8
8111c7fc:	3a0e983a 	sll	r7,r7,r8
8111c800:	1104d83a 	srl	r2,r2,r4
8111c804:	300cc03a 	cmpne	r6,r6,zero
8111c808:	31ceb03a 	or	r7,r6,r7
8111c80c:	388cb03a 	or	r6,r7,r2
8111c810:	0007883a 	mov	r3,zero
8111c814:	003fbe06 	br	8111c710 <__reset+0xfb0fc710>
8111c818:	0007883a 	mov	r3,zero
8111c81c:	003fd906 	br	8111c784 <__reset+0xfb0fc784>
8111c820:	01bfff84 	movi	r6,-2
8111c824:	30cdc83a 	sub	r6,r6,r3
8111c828:	00c00804 	movi	r3,32
8111c82c:	398cd83a 	srl	r6,r7,r6
8111c830:	20c00726 	beq	r4,r3,8111c850 <__truncdfsf2+0x1a0>
8111c834:	423f2884 	addi	r8,r8,-862
8111c838:	3a0e983a 	sll	r7,r7,r8
8111c83c:	3884b03a 	or	r2,r7,r2
8111c840:	1004c03a 	cmpne	r2,r2,zero
8111c844:	118cb03a 	or	r6,r2,r6
8111c848:	0007883a 	mov	r3,zero
8111c84c:	003fb006 	br	8111c710 <__reset+0xfb0fc710>
8111c850:	000f883a 	mov	r7,zero
8111c854:	003ff906 	br	8111c83c <__reset+0xfb0fc83c>

8111c858 <__clzsi2>:
8111c858:	00bfffd4 	movui	r2,65535
8111c85c:	11000536 	bltu	r2,r4,8111c874 <__clzsi2+0x1c>
8111c860:	00803fc4 	movi	r2,255
8111c864:	11000f36 	bltu	r2,r4,8111c8a4 <__clzsi2+0x4c>
8111c868:	00800804 	movi	r2,32
8111c86c:	0007883a 	mov	r3,zero
8111c870:	00000506 	br	8111c888 <__clzsi2+0x30>
8111c874:	00804034 	movhi	r2,256
8111c878:	10bfffc4 	addi	r2,r2,-1
8111c87c:	11000c2e 	bgeu	r2,r4,8111c8b0 <__clzsi2+0x58>
8111c880:	00800204 	movi	r2,8
8111c884:	00c00604 	movi	r3,24
8111c888:	20c8d83a 	srl	r4,r4,r3
8111c88c:	00e04574 	movhi	r3,33045
8111c890:	18efc704 	addi	r3,r3,-16612
8111c894:	1909883a 	add	r4,r3,r4
8111c898:	20c00003 	ldbu	r3,0(r4)
8111c89c:	10c5c83a 	sub	r2,r2,r3
8111c8a0:	f800283a 	ret
8111c8a4:	00800604 	movi	r2,24
8111c8a8:	00c00204 	movi	r3,8
8111c8ac:	003ff606 	br	8111c888 <__reset+0xfb0fc888>
8111c8b0:	00800404 	movi	r2,16
8111c8b4:	1007883a 	mov	r3,r2
8111c8b8:	003ff306 	br	8111c888 <__reset+0xfb0fc888>

8111c8bc <atoi>:
8111c8bc:	01800284 	movi	r6,10
8111c8c0:	000b883a 	mov	r5,zero
8111c8c4:	111e8d81 	jmpi	8111e8d8 <strtol>

8111c8c8 <_atoi_r>:
8111c8c8:	01c00284 	movi	r7,10
8111c8cc:	000d883a 	mov	r6,zero
8111c8d0:	111e6981 	jmpi	8111e698 <_strtol_r>

8111c8d4 <_fopen_r>:
8111c8d4:	defffa04 	addi	sp,sp,-24
8111c8d8:	3005883a 	mov	r2,r6
8111c8dc:	de00012e 	bgeu	sp,et,8111c8e4 <_fopen_r+0x10>
8111c8e0:	003b68fa 	trap	3
8111c8e4:	d80d883a 	mov	r6,sp
8111c8e8:	dcc00415 	stw	r19,16(sp)
8111c8ec:	2827883a 	mov	r19,r5
8111c8f0:	100b883a 	mov	r5,r2
8111c8f4:	dc800315 	stw	r18,12(sp)
8111c8f8:	dfc00515 	stw	ra,20(sp)
8111c8fc:	dc400215 	stw	r17,8(sp)
8111c900:	dc000115 	stw	r16,4(sp)
8111c904:	2025883a 	mov	r18,r4
8111c908:	11268e00 	call	811268e0 <__sflags>
8111c90c:	10002726 	beq	r2,zero,8111c9ac <_fopen_r+0xd8>
8111c910:	9009883a 	mov	r4,r18
8111c914:	1023883a 	mov	r17,r2
8111c918:	11267580 	call	81126758 <__sfp>
8111c91c:	1021883a 	mov	r16,r2
8111c920:	10002226 	beq	r2,zero,8111c9ac <_fopen_r+0xd8>
8111c924:	d9800017 	ldw	r6,0(sp)
8111c928:	01c06d84 	movi	r7,438
8111c92c:	980b883a 	mov	r5,r19
8111c930:	9009883a 	mov	r4,r18
8111c934:	111dd400 	call	8111dd40 <_open_r>
8111c938:	10001916 	blt	r2,zero,8111c9a0 <_fopen_r+0xcc>
8111c93c:	8080038d 	sth	r2,14(r16)
8111c940:	00a044b4 	movhi	r2,33042
8111c944:	10b90704 	addi	r2,r2,-7140
8111c948:	80800815 	stw	r2,32(r16)
8111c94c:	00a044b4 	movhi	r2,33042
8111c950:	10b92004 	addi	r2,r2,-7040
8111c954:	80800915 	stw	r2,36(r16)
8111c958:	00a044b4 	movhi	r2,33042
8111c95c:	10b94104 	addi	r2,r2,-6908
8111c960:	80800a15 	stw	r2,40(r16)
8111c964:	00a044b4 	movhi	r2,33042
8111c968:	10b95a04 	addi	r2,r2,-6808
8111c96c:	8440030d 	sth	r17,12(r16)
8111c970:	84000715 	stw	r16,28(r16)
8111c974:	80800b15 	stw	r2,44(r16)
8111c978:	8c40400c 	andi	r17,r17,256
8111c97c:	88000d1e 	bne	r17,zero,8111c9b4 <_fopen_r+0xe0>
8111c980:	8005883a 	mov	r2,r16
8111c984:	dfc00517 	ldw	ra,20(sp)
8111c988:	dcc00417 	ldw	r19,16(sp)
8111c98c:	dc800317 	ldw	r18,12(sp)
8111c990:	dc400217 	ldw	r17,8(sp)
8111c994:	dc000117 	ldw	r16,4(sp)
8111c998:	dec00604 	addi	sp,sp,24
8111c99c:	f800283a 	ret
8111c9a0:	11268a00 	call	811268a0 <__sfp_lock_acquire>
8111c9a4:	8000030d 	sth	zero,12(r16)
8111c9a8:	11268a40 	call	811268a4 <__sfp_lock_release>
8111c9ac:	0005883a 	mov	r2,zero
8111c9b0:	003ff406 	br	8111c984 <__reset+0xfb0fc984>
8111c9b4:	01c00084 	movi	r7,2
8111c9b8:	000d883a 	mov	r6,zero
8111c9bc:	800b883a 	mov	r5,r16
8111c9c0:	9009883a 	mov	r4,r18
8111c9c4:	111caf40 	call	8111caf4 <_fseek_r>
8111c9c8:	8005883a 	mov	r2,r16
8111c9cc:	003fed06 	br	8111c984 <__reset+0xfb0fc984>

8111c9d0 <fopen>:
8111c9d0:	00a04574 	movhi	r2,33045
8111c9d4:	10ba8204 	addi	r2,r2,-5624
8111c9d8:	280d883a 	mov	r6,r5
8111c9dc:	200b883a 	mov	r5,r4
8111c9e0:	11000017 	ldw	r4,0(r2)
8111c9e4:	111c8d41 	jmpi	8111c8d4 <_fopen_r>

8111c9e8 <_fprintf_r>:
8111c9e8:	defffe04 	addi	sp,sp,-8
8111c9ec:	2809883a 	mov	r4,r5
8111c9f0:	300b883a 	mov	r5,r6
8111c9f4:	de00012e 	bgeu	sp,et,8111c9fc <_fprintf_r+0x14>
8111c9f8:	003b68fa 	trap	3
8111c9fc:	dfc00015 	stw	ra,0(sp)
8111ca00:	d9c00115 	stw	r7,4(sp)
8111ca04:	d9800104 	addi	r6,sp,4
8111ca08:	1122cd40 	call	81122cd4 <__vfprintf_internal>
8111ca0c:	dfc00017 	ldw	ra,0(sp)
8111ca10:	dec00204 	addi	sp,sp,8
8111ca14:	f800283a 	ret

8111ca18 <fprintf>:
8111ca18:	defffd04 	addi	sp,sp,-12
8111ca1c:	de00012e 	bgeu	sp,et,8111ca24 <fprintf+0xc>
8111ca20:	003b68fa 	trap	3
8111ca24:	dfc00015 	stw	ra,0(sp)
8111ca28:	d9800115 	stw	r6,4(sp)
8111ca2c:	d9c00215 	stw	r7,8(sp)
8111ca30:	d9800104 	addi	r6,sp,4
8111ca34:	1122cd40 	call	81122cd4 <__vfprintf_internal>
8111ca38:	dfc00017 	ldw	ra,0(sp)
8111ca3c:	dec00304 	addi	sp,sp,12
8111ca40:	f800283a 	ret

8111ca44 <_fputc_r>:
8111ca44:	defffc04 	addi	sp,sp,-16
8111ca48:	de00012e 	bgeu	sp,et,8111ca50 <_fputc_r+0xc>
8111ca4c:	003b68fa 	trap	3
8111ca50:	dc000215 	stw	r16,8(sp)
8111ca54:	dfc00315 	stw	ra,12(sp)
8111ca58:	2021883a 	mov	r16,r4
8111ca5c:	20000726 	beq	r4,zero,8111ca7c <_fputc_r+0x38>
8111ca60:	20800e17 	ldw	r2,56(r4)
8111ca64:	1000051e 	bne	r2,zero,8111ca7c <_fputc_r+0x38>
8111ca68:	d9400015 	stw	r5,0(sp)
8111ca6c:	d9800115 	stw	r6,4(sp)
8111ca70:	11268900 	call	81126890 <__sinit>
8111ca74:	d9800117 	ldw	r6,4(sp)
8111ca78:	d9400017 	ldw	r5,0(sp)
8111ca7c:	8009883a 	mov	r4,r16
8111ca80:	dfc00317 	ldw	ra,12(sp)
8111ca84:	dc000217 	ldw	r16,8(sp)
8111ca88:	dec00404 	addi	sp,sp,16
8111ca8c:	111de241 	jmpi	8111de24 <_putc_r>

8111ca90 <fputc>:
8111ca90:	00a04574 	movhi	r2,33045
8111ca94:	defffc04 	addi	sp,sp,-16
8111ca98:	10ba8204 	addi	r2,r2,-5624
8111ca9c:	de00012e 	bgeu	sp,et,8111caa4 <fputc+0x14>
8111caa0:	003b68fa 	trap	3
8111caa4:	dc000115 	stw	r16,4(sp)
8111caa8:	14000017 	ldw	r16,0(r2)
8111caac:	dc400215 	stw	r17,8(sp)
8111cab0:	dfc00315 	stw	ra,12(sp)
8111cab4:	2023883a 	mov	r17,r4
8111cab8:	80000626 	beq	r16,zero,8111cad4 <fputc+0x44>
8111cabc:	80800e17 	ldw	r2,56(r16)
8111cac0:	1000041e 	bne	r2,zero,8111cad4 <fputc+0x44>
8111cac4:	8009883a 	mov	r4,r16
8111cac8:	d9400015 	stw	r5,0(sp)
8111cacc:	11268900 	call	81126890 <__sinit>
8111cad0:	d9400017 	ldw	r5,0(sp)
8111cad4:	280d883a 	mov	r6,r5
8111cad8:	8009883a 	mov	r4,r16
8111cadc:	880b883a 	mov	r5,r17
8111cae0:	dfc00317 	ldw	ra,12(sp)
8111cae4:	dc400217 	ldw	r17,8(sp)
8111cae8:	dc000117 	ldw	r16,4(sp)
8111caec:	dec00404 	addi	sp,sp,16
8111caf0:	111de241 	jmpi	8111de24 <_putc_r>

8111caf4 <_fseek_r>:
8111caf4:	111cb141 	jmpi	8111cb14 <_fseeko_r>

8111caf8 <fseek>:
8111caf8:	00a04574 	movhi	r2,33045
8111cafc:	10ba8204 	addi	r2,r2,-5624
8111cb00:	300f883a 	mov	r7,r6
8111cb04:	280d883a 	mov	r6,r5
8111cb08:	200b883a 	mov	r5,r4
8111cb0c:	11000017 	ldw	r4,0(r2)
8111cb10:	111cb141 	jmpi	8111cb14 <_fseeko_r>

8111cb14 <_fseeko_r>:
8111cb14:	deffe804 	addi	sp,sp,-96
8111cb18:	de00012e 	bgeu	sp,et,8111cb20 <_fseeko_r+0xc>
8111cb1c:	003b68fa 	trap	3
8111cb20:	dd401415 	stw	r21,80(sp)
8111cb24:	dc801115 	stw	r18,68(sp)
8111cb28:	dc401015 	stw	r17,64(sp)
8111cb2c:	dc000f15 	stw	r16,60(sp)
8111cb30:	dfc01715 	stw	ra,92(sp)
8111cb34:	ddc01615 	stw	r23,88(sp)
8111cb38:	dd801515 	stw	r22,84(sp)
8111cb3c:	dd001315 	stw	r20,76(sp)
8111cb40:	dcc01215 	stw	r19,72(sp)
8111cb44:	2023883a 	mov	r17,r4
8111cb48:	2821883a 	mov	r16,r5
8111cb4c:	302b883a 	mov	r21,r6
8111cb50:	3825883a 	mov	r18,r7
8111cb54:	20000226 	beq	r4,zero,8111cb60 <_fseeko_r+0x4c>
8111cb58:	20800e17 	ldw	r2,56(r4)
8111cb5c:	10005a26 	beq	r2,zero,8111ccc8 <_fseeko_r+0x1b4>
8111cb60:	8080030b 	ldhu	r2,12(r16)
8111cb64:	00c04204 	movi	r3,264
8111cb68:	1080420c 	andi	r2,r2,264
8111cb6c:	10c05b26 	beq	r2,r3,8111ccdc <_fseeko_r+0x1c8>
8111cb70:	85000a17 	ldw	r20,40(r16)
8111cb74:	a000f626 	beq	r20,zero,8111cf50 <_fseeko_r+0x43c>
8111cb78:	00800044 	movi	r2,1
8111cb7c:	90803e26 	beq	r18,r2,8111cc78 <_fseeko_r+0x164>
8111cb80:	00800084 	movi	r2,2
8111cb84:	90801026 	beq	r18,r2,8111cbc8 <_fseeko_r+0xb4>
8111cb88:	90000f26 	beq	r18,zero,8111cbc8 <_fseeko_r+0xb4>
8111cb8c:	00800584 	movi	r2,22
8111cb90:	88800015 	stw	r2,0(r17)
8111cb94:	04ffffc4 	movi	r19,-1
8111cb98:	9805883a 	mov	r2,r19
8111cb9c:	dfc01717 	ldw	ra,92(sp)
8111cba0:	ddc01617 	ldw	r23,88(sp)
8111cba4:	dd801517 	ldw	r22,84(sp)
8111cba8:	dd401417 	ldw	r21,80(sp)
8111cbac:	dd001317 	ldw	r20,76(sp)
8111cbb0:	dcc01217 	ldw	r19,72(sp)
8111cbb4:	dc801117 	ldw	r18,68(sp)
8111cbb8:	dc401017 	ldw	r17,64(sp)
8111cbbc:	dc000f17 	ldw	r16,60(sp)
8111cbc0:	dec01804 	addi	sp,sp,96
8111cbc4:	f800283a 	ret
8111cbc8:	80800417 	ldw	r2,16(r16)
8111cbcc:	002f883a 	mov	r23,zero
8111cbd0:	0027883a 	mov	r19,zero
8111cbd4:	1000cb26 	beq	r2,zero,8111cf04 <_fseeko_r+0x3f0>
8111cbd8:	8080030b 	ldhu	r2,12(r16)
8111cbdc:	10c2068c 	andi	r3,r2,2074
8111cbe0:	1800071e 	bne	r3,zero,8111cc00 <_fseeko_r+0xec>
8111cbe4:	10c1000c 	andi	r3,r2,1024
8111cbe8:	1800451e 	bne	r3,zero,8111cd00 <_fseeko_r+0x1ec>
8111cbec:	00e044b4 	movhi	r3,33042
8111cbf0:	18f94104 	addi	r3,r3,-6908
8111cbf4:	a0c0b726 	beq	r20,r3,8111ced4 <_fseeko_r+0x3c0>
8111cbf8:	10820014 	ori	r2,r2,2048
8111cbfc:	8080030d 	sth	r2,12(r16)
8111cc00:	800b883a 	mov	r5,r16
8111cc04:	8809883a 	mov	r4,r17
8111cc08:	11264940 	call	81126494 <_fflush_r>
8111cc0c:	1027883a 	mov	r19,r2
8111cc10:	103fe01e 	bne	r2,zero,8111cb94 <__reset+0xfb0fcb94>
8111cc14:	81400717 	ldw	r5,28(r16)
8111cc18:	900f883a 	mov	r7,r18
8111cc1c:	a80d883a 	mov	r6,r21
8111cc20:	8809883a 	mov	r4,r17
8111cc24:	a03ee83a 	callr	r20
8111cc28:	00ffffc4 	movi	r3,-1
8111cc2c:	10ffd926 	beq	r2,r3,8111cb94 <__reset+0xfb0fcb94>
8111cc30:	81400c17 	ldw	r5,48(r16)
8111cc34:	28000526 	beq	r5,zero,8111cc4c <_fseeko_r+0x138>
8111cc38:	80801004 	addi	r2,r16,64
8111cc3c:	28800226 	beq	r5,r2,8111cc48 <_fseeko_r+0x134>
8111cc40:	8809883a 	mov	r4,r17
8111cc44:	1126d280 	call	81126d28 <_free_r>
8111cc48:	80000c15 	stw	zero,48(r16)
8111cc4c:	8080030b 	ldhu	r2,12(r16)
8111cc50:	80c00417 	ldw	r3,16(r16)
8111cc54:	80000115 	stw	zero,4(r16)
8111cc58:	10bdf7cc 	andi	r2,r2,63455
8111cc5c:	80c00015 	stw	r3,0(r16)
8111cc60:	8080030d 	sth	r2,12(r16)
8111cc64:	01800204 	movi	r6,8
8111cc68:	000b883a 	mov	r5,zero
8111cc6c:	81001704 	addi	r4,r16,92
8111cc70:	111dc180 	call	8111dc18 <memset>
8111cc74:	003fc806 	br	8111cb98 <__reset+0xfb0fcb98>
8111cc78:	800b883a 	mov	r5,r16
8111cc7c:	8809883a 	mov	r4,r17
8111cc80:	11264940 	call	81126494 <_fflush_r>
8111cc84:	8080030b 	ldhu	r2,12(r16)
8111cc88:	10c4000c 	andi	r3,r2,4096
8111cc8c:	18008726 	beq	r3,zero,8111ceac <_fseeko_r+0x398>
8111cc90:	84c01417 	ldw	r19,80(r16)
8111cc94:	10c0010c 	andi	r3,r2,4
8111cc98:	1800431e 	bne	r3,zero,8111cda8 <_fseeko_r+0x294>
8111cc9c:	1080020c 	andi	r2,r2,8
8111cca0:	10008026 	beq	r2,zero,8111cea4 <_fseeko_r+0x390>
8111cca4:	80c00017 	ldw	r3,0(r16)
8111cca8:	80800417 	ldw	r2,16(r16)
8111ccac:	18000226 	beq	r3,zero,8111ccb8 <_fseeko_r+0x1a4>
8111ccb0:	1887c83a 	sub	r3,r3,r2
8111ccb4:	98e7883a 	add	r19,r19,r3
8111ccb8:	aceb883a 	add	r21,r21,r19
8111ccbc:	05c00044 	movi	r23,1
8111ccc0:	0025883a 	mov	r18,zero
8111ccc4:	003fc306 	br	8111cbd4 <__reset+0xfb0fcbd4>
8111ccc8:	11268900 	call	81126890 <__sinit>
8111cccc:	8080030b 	ldhu	r2,12(r16)
8111ccd0:	00c04204 	movi	r3,264
8111ccd4:	1080420c 	andi	r2,r2,264
8111ccd8:	10ffa51e 	bne	r2,r3,8111cb70 <__reset+0xfb0fcb70>
8111ccdc:	800b883a 	mov	r5,r16
8111cce0:	8809883a 	mov	r4,r17
8111cce4:	11264940 	call	81126494 <_fflush_r>
8111cce8:	003fa106 	br	8111cb70 <__reset+0xfb0fcb70>
8111ccec:	8080030b 	ldhu	r2,12(r16)
8111ccf0:	00c10004 	movi	r3,1024
8111ccf4:	80c01315 	stw	r3,76(r16)
8111ccf8:	10c4b03a 	or	r2,r2,r3
8111ccfc:	8080030d 	sth	r2,12(r16)
8111cd00:	9000311e 	bne	r18,zero,8111cdc8 <_fseeko_r+0x2b4>
8111cd04:	a82d883a 	mov	r22,r21
8111cd08:	b800371e 	bne	r23,zero,8111cde8 <_fseeko_r+0x2d4>
8111cd0c:	8080030b 	ldhu	r2,12(r16)
8111cd10:	1084000c 	andi	r2,r2,4096
8111cd14:	10007f26 	beq	r2,zero,8111cf14 <_fseeko_r+0x400>
8111cd18:	80801417 	ldw	r2,80(r16)
8111cd1c:	81800117 	ldw	r6,4(r16)
8111cd20:	81400c17 	ldw	r5,48(r16)
8111cd24:	11a7c83a 	sub	r19,r2,r6
8111cd28:	28008226 	beq	r5,zero,8111cf34 <_fseeko_r+0x420>
8111cd2c:	81c00f17 	ldw	r7,60(r16)
8111cd30:	99e7c83a 	sub	r19,r19,r7
8111cd34:	81000e17 	ldw	r4,56(r16)
8111cd38:	80800417 	ldw	r2,16(r16)
8111cd3c:	99a7883a 	add	r19,r19,r6
8111cd40:	2087c83a 	sub	r3,r4,r2
8111cd44:	98e7c83a 	sub	r19,r19,r3
8111cd48:	38c7883a 	add	r3,r7,r3
8111cd4c:	b4c02b16 	blt	r22,r19,8111cdfc <_fseeko_r+0x2e8>
8111cd50:	98c9883a 	add	r4,r19,r3
8111cd54:	b100292e 	bgeu	r22,r4,8111cdfc <_fseeko_r+0x2e8>
8111cd58:	b4e7c83a 	sub	r19,r22,r19
8111cd5c:	14c5883a 	add	r2,r2,r19
8111cd60:	1ce7c83a 	sub	r19,r3,r19
8111cd64:	80800015 	stw	r2,0(r16)
8111cd68:	84c00115 	stw	r19,4(r16)
8111cd6c:	28000526 	beq	r5,zero,8111cd84 <_fseeko_r+0x270>
8111cd70:	80801004 	addi	r2,r16,64
8111cd74:	28800226 	beq	r5,r2,8111cd80 <_fseeko_r+0x26c>
8111cd78:	8809883a 	mov	r4,r17
8111cd7c:	1126d280 	call	81126d28 <_free_r>
8111cd80:	80000c15 	stw	zero,48(r16)
8111cd84:	8080030b 	ldhu	r2,12(r16)
8111cd88:	01800204 	movi	r6,8
8111cd8c:	000b883a 	mov	r5,zero
8111cd90:	10bff7cc 	andi	r2,r2,65503
8111cd94:	8080030d 	sth	r2,12(r16)
8111cd98:	81001704 	addi	r4,r16,92
8111cd9c:	111dc180 	call	8111dc18 <memset>
8111cda0:	0027883a 	mov	r19,zero
8111cda4:	003f7c06 	br	8111cb98 <__reset+0xfb0fcb98>
8111cda8:	80c00117 	ldw	r3,4(r16)
8111cdac:	80800c17 	ldw	r2,48(r16)
8111cdb0:	98e7c83a 	sub	r19,r19,r3
8111cdb4:	10003b26 	beq	r2,zero,8111cea4 <_fseeko_r+0x390>
8111cdb8:	80c00f17 	ldw	r3,60(r16)
8111cdbc:	80800417 	ldw	r2,16(r16)
8111cdc0:	98e7c83a 	sub	r19,r19,r3
8111cdc4:	003fbc06 	br	8111ccb8 <__reset+0xfb0fccb8>
8111cdc8:	8140038f 	ldh	r5,14(r16)
8111cdcc:	d80d883a 	mov	r6,sp
8111cdd0:	8809883a 	mov	r4,r17
8111cdd4:	111cf7c0 	call	8111cf7c <_fstat_r>
8111cdd8:	103f891e 	bne	r2,zero,8111cc00 <__reset+0xfb0fcc00>
8111cddc:	dd800417 	ldw	r22,16(sp)
8111cde0:	adad883a 	add	r22,r21,r22
8111cde4:	b83fc926 	beq	r23,zero,8111cd0c <__reset+0xfb0fcd0c>
8111cde8:	81400c17 	ldw	r5,48(r16)
8111cdec:	81800117 	ldw	r6,4(r16)
8111cdf0:	28005026 	beq	r5,zero,8111cf34 <_fseeko_r+0x420>
8111cdf4:	81c00f17 	ldw	r7,60(r16)
8111cdf8:	003fce06 	br	8111cd34 <__reset+0xfb0fcd34>
8111cdfc:	84c01317 	ldw	r19,76(r16)
8111ce00:	81400717 	ldw	r5,28(r16)
8111ce04:	000f883a 	mov	r7,zero
8111ce08:	04e7c83a 	sub	r19,zero,r19
8111ce0c:	9da6703a 	and	r19,r19,r22
8111ce10:	980d883a 	mov	r6,r19
8111ce14:	8809883a 	mov	r4,r17
8111ce18:	a03ee83a 	callr	r20
8111ce1c:	00ffffc4 	movi	r3,-1
8111ce20:	10ff7726 	beq	r2,r3,8111cc00 <__reset+0xfb0fcc00>
8111ce24:	80800417 	ldw	r2,16(r16)
8111ce28:	81400c17 	ldw	r5,48(r16)
8111ce2c:	80000115 	stw	zero,4(r16)
8111ce30:	80800015 	stw	r2,0(r16)
8111ce34:	28000526 	beq	r5,zero,8111ce4c <_fseeko_r+0x338>
8111ce38:	80801004 	addi	r2,r16,64
8111ce3c:	28800226 	beq	r5,r2,8111ce48 <_fseeko_r+0x334>
8111ce40:	8809883a 	mov	r4,r17
8111ce44:	1126d280 	call	81126d28 <_free_r>
8111ce48:	80000c15 	stw	zero,48(r16)
8111ce4c:	8080030b 	ldhu	r2,12(r16)
8111ce50:	b4e7c83a 	sub	r19,r22,r19
8111ce54:	10bff7cc 	andi	r2,r2,65503
8111ce58:	8080030d 	sth	r2,12(r16)
8111ce5c:	98000b26 	beq	r19,zero,8111ce8c <_fseeko_r+0x378>
8111ce60:	800b883a 	mov	r5,r16
8111ce64:	8809883a 	mov	r4,r17
8111ce68:	111e0940 	call	8111e094 <__srefill_r>
8111ce6c:	103f641e 	bne	r2,zero,8111cc00 <__reset+0xfb0fcc00>
8111ce70:	80800117 	ldw	r2,4(r16)
8111ce74:	14ff6236 	bltu	r2,r19,8111cc00 <__reset+0xfb0fcc00>
8111ce78:	80c00017 	ldw	r3,0(r16)
8111ce7c:	14c5c83a 	sub	r2,r2,r19
8111ce80:	80800115 	stw	r2,4(r16)
8111ce84:	1ce7883a 	add	r19,r3,r19
8111ce88:	84c00015 	stw	r19,0(r16)
8111ce8c:	01800204 	movi	r6,8
8111ce90:	000b883a 	mov	r5,zero
8111ce94:	81001704 	addi	r4,r16,92
8111ce98:	111dc180 	call	8111dc18 <memset>
8111ce9c:	0027883a 	mov	r19,zero
8111cea0:	003f3d06 	br	8111cb98 <__reset+0xfb0fcb98>
8111cea4:	80800417 	ldw	r2,16(r16)
8111cea8:	003f8306 	br	8111ccb8 <__reset+0xfb0fccb8>
8111ceac:	81400717 	ldw	r5,28(r16)
8111ceb0:	900f883a 	mov	r7,r18
8111ceb4:	000d883a 	mov	r6,zero
8111ceb8:	8809883a 	mov	r4,r17
8111cebc:	a03ee83a 	callr	r20
8111cec0:	1027883a 	mov	r19,r2
8111cec4:	00bfffc4 	movi	r2,-1
8111cec8:	98bf3226 	beq	r19,r2,8111cb94 <__reset+0xfb0fcb94>
8111cecc:	8080030b 	ldhu	r2,12(r16)
8111ced0:	003f7006 	br	8111cc94 <__reset+0xfb0fcc94>
8111ced4:	8140038f 	ldh	r5,14(r16)
8111ced8:	283f4716 	blt	r5,zero,8111cbf8 <__reset+0xfb0fcbf8>
8111cedc:	d80d883a 	mov	r6,sp
8111cee0:	8809883a 	mov	r4,r17
8111cee4:	111cf7c0 	call	8111cf7c <_fstat_r>
8111cee8:	1000041e 	bne	r2,zero,8111cefc <_fseeko_r+0x3e8>
8111ceec:	d8800117 	ldw	r2,4(sp)
8111cef0:	00e00014 	movui	r3,32768
8111cef4:	10bc000c 	andi	r2,r2,61440
8111cef8:	10ff7c26 	beq	r2,r3,8111ccec <__reset+0xfb0fccec>
8111cefc:	8080030b 	ldhu	r2,12(r16)
8111cf00:	003f3d06 	br	8111cbf8 <__reset+0xfb0fcbf8>
8111cf04:	800b883a 	mov	r5,r16
8111cf08:	8809883a 	mov	r4,r17
8111cf0c:	111d0f00 	call	8111d0f0 <__smakebuf_r>
8111cf10:	003f3106 	br	8111cbd8 <__reset+0xfb0fcbd8>
8111cf14:	81400717 	ldw	r5,28(r16)
8111cf18:	01c00044 	movi	r7,1
8111cf1c:	000d883a 	mov	r6,zero
8111cf20:	8809883a 	mov	r4,r17
8111cf24:	a03ee83a 	callr	r20
8111cf28:	00ffffc4 	movi	r3,-1
8111cf2c:	10ff7b1e 	bne	r2,r3,8111cd1c <__reset+0xfb0fcd1c>
8111cf30:	003f3306 	br	8111cc00 <__reset+0xfb0fcc00>
8111cf34:	80c00017 	ldw	r3,0(r16)
8111cf38:	80800417 	ldw	r2,16(r16)
8111cf3c:	000b883a 	mov	r5,zero
8111cf40:	1887c83a 	sub	r3,r3,r2
8111cf44:	98e7c83a 	sub	r19,r19,r3
8111cf48:	30c7883a 	add	r3,r6,r3
8111cf4c:	003f7f06 	br	8111cd4c <__reset+0xfb0fcd4c>
8111cf50:	00800744 	movi	r2,29
8111cf54:	88800015 	stw	r2,0(r17)
8111cf58:	04ffffc4 	movi	r19,-1
8111cf5c:	003f0e06 	br	8111cb98 <__reset+0xfb0fcb98>

8111cf60 <fseeko>:
8111cf60:	00a04574 	movhi	r2,33045
8111cf64:	10ba8204 	addi	r2,r2,-5624
8111cf68:	300f883a 	mov	r7,r6
8111cf6c:	280d883a 	mov	r6,r5
8111cf70:	200b883a 	mov	r5,r4
8111cf74:	11000017 	ldw	r4,0(r2)
8111cf78:	111cb141 	jmpi	8111cb14 <_fseeko_r>

8111cf7c <_fstat_r>:
8111cf7c:	defffd04 	addi	sp,sp,-12
8111cf80:	de00012e 	bgeu	sp,et,8111cf88 <_fstat_r+0xc>
8111cf84:	003b68fa 	trap	3
8111cf88:	2805883a 	mov	r2,r5
8111cf8c:	dc000015 	stw	r16,0(sp)
8111cf90:	04204574 	movhi	r16,33045
8111cf94:	dc400115 	stw	r17,4(sp)
8111cf98:	843af104 	addi	r16,r16,-5180
8111cf9c:	2023883a 	mov	r17,r4
8111cfa0:	300b883a 	mov	r5,r6
8111cfa4:	1009883a 	mov	r4,r2
8111cfa8:	dfc00215 	stw	ra,8(sp)
8111cfac:	80000015 	stw	zero,0(r16)
8111cfb0:	11325680 	call	81132568 <fstat>
8111cfb4:	00ffffc4 	movi	r3,-1
8111cfb8:	10c00526 	beq	r2,r3,8111cfd0 <_fstat_r+0x54>
8111cfbc:	dfc00217 	ldw	ra,8(sp)
8111cfc0:	dc400117 	ldw	r17,4(sp)
8111cfc4:	dc000017 	ldw	r16,0(sp)
8111cfc8:	dec00304 	addi	sp,sp,12
8111cfcc:	f800283a 	ret
8111cfd0:	80c00017 	ldw	r3,0(r16)
8111cfd4:	183ff926 	beq	r3,zero,8111cfbc <__reset+0xfb0fcfbc>
8111cfd8:	88c00015 	stw	r3,0(r17)
8111cfdc:	003ff706 	br	8111cfbc <__reset+0xfb0fcfbc>

8111cfe0 <_fwrite_r>:
8111cfe0:	defff504 	addi	sp,sp,-44
8111cfe4:	de00012e 	bgeu	sp,et,8111cfec <_fwrite_r+0xc>
8111cfe8:	003b68fa 	trap	3
8111cfec:	dc800815 	stw	r18,32(sp)
8111cff0:	39a5383a 	mul	r18,r7,r6
8111cff4:	d8800304 	addi	r2,sp,12
8111cff8:	d8800015 	stw	r2,0(sp)
8111cffc:	00800044 	movi	r2,1
8111d000:	dcc00915 	stw	r19,36(sp)
8111d004:	dc400715 	stw	r17,28(sp)
8111d008:	dc000615 	stw	r16,24(sp)
8111d00c:	d9400315 	stw	r5,12(sp)
8111d010:	dfc00a15 	stw	ra,40(sp)
8111d014:	dc800415 	stw	r18,16(sp)
8111d018:	dc800215 	stw	r18,8(sp)
8111d01c:	d8800115 	stw	r2,4(sp)
8111d020:	3027883a 	mov	r19,r6
8111d024:	3821883a 	mov	r16,r7
8111d028:	2023883a 	mov	r17,r4
8111d02c:	d9400b17 	ldw	r5,44(sp)
8111d030:	20000226 	beq	r4,zero,8111d03c <_fwrite_r+0x5c>
8111d034:	20800e17 	ldw	r2,56(r4)
8111d038:	10001a26 	beq	r2,zero,8111d0a4 <_fwrite_r+0xc4>
8111d03c:	2880030b 	ldhu	r2,12(r5)
8111d040:	10c8000c 	andi	r3,r2,8192
8111d044:	1800061e 	bne	r3,zero,8111d060 <_fwrite_r+0x80>
8111d048:	29001917 	ldw	r4,100(r5)
8111d04c:	00f7ffc4 	movi	r3,-8193
8111d050:	10880014 	ori	r2,r2,8192
8111d054:	20c6703a 	and	r3,r4,r3
8111d058:	2880030d 	sth	r2,12(r5)
8111d05c:	28c01915 	stw	r3,100(r5)
8111d060:	d80d883a 	mov	r6,sp
8111d064:	8809883a 	mov	r4,r17
8111d068:	11270400 	call	81127040 <__sfvwrite_r>
8111d06c:	10000b26 	beq	r2,zero,8111d09c <_fwrite_r+0xbc>
8111d070:	d9000217 	ldw	r4,8(sp)
8111d074:	980b883a 	mov	r5,r19
8111d078:	9109c83a 	sub	r4,r18,r4
8111d07c:	11300b00 	call	811300b0 <__udivsi3>
8111d080:	dfc00a17 	ldw	ra,40(sp)
8111d084:	dcc00917 	ldw	r19,36(sp)
8111d088:	dc800817 	ldw	r18,32(sp)
8111d08c:	dc400717 	ldw	r17,28(sp)
8111d090:	dc000617 	ldw	r16,24(sp)
8111d094:	dec00b04 	addi	sp,sp,44
8111d098:	f800283a 	ret
8111d09c:	8005883a 	mov	r2,r16
8111d0a0:	003ff706 	br	8111d080 <__reset+0xfb0fd080>
8111d0a4:	d9400515 	stw	r5,20(sp)
8111d0a8:	11268900 	call	81126890 <__sinit>
8111d0ac:	d9400517 	ldw	r5,20(sp)
8111d0b0:	003fe206 	br	8111d03c <__reset+0xfb0fd03c>

8111d0b4 <fwrite>:
8111d0b4:	defffe04 	addi	sp,sp,-8
8111d0b8:	00a04574 	movhi	r2,33045
8111d0bc:	de00012e 	bgeu	sp,et,8111d0c4 <fwrite+0x10>
8111d0c0:	003b68fa 	trap	3
8111d0c4:	10ba8204 	addi	r2,r2,-5624
8111d0c8:	d9c00015 	stw	r7,0(sp)
8111d0cc:	300f883a 	mov	r7,r6
8111d0d0:	280d883a 	mov	r6,r5
8111d0d4:	200b883a 	mov	r5,r4
8111d0d8:	11000017 	ldw	r4,0(r2)
8111d0dc:	dfc00115 	stw	ra,4(sp)
8111d0e0:	111cfe00 	call	8111cfe0 <_fwrite_r>
8111d0e4:	dfc00117 	ldw	ra,4(sp)
8111d0e8:	dec00204 	addi	sp,sp,8
8111d0ec:	f800283a 	ret

8111d0f0 <__smakebuf_r>:
8111d0f0:	2880030b 	ldhu	r2,12(r5)
8111d0f4:	10c0008c 	andi	r3,r2,2
8111d0f8:	1800431e 	bne	r3,zero,8111d208 <__smakebuf_r+0x118>
8111d0fc:	deffec04 	addi	sp,sp,-80
8111d100:	de00012e 	bgeu	sp,et,8111d108 <__smakebuf_r+0x18>
8111d104:	003b68fa 	trap	3
8111d108:	dc000f15 	stw	r16,60(sp)
8111d10c:	2821883a 	mov	r16,r5
8111d110:	2940038f 	ldh	r5,14(r5)
8111d114:	dc401015 	stw	r17,64(sp)
8111d118:	dfc01315 	stw	ra,76(sp)
8111d11c:	dcc01215 	stw	r19,72(sp)
8111d120:	dc801115 	stw	r18,68(sp)
8111d124:	2023883a 	mov	r17,r4
8111d128:	28001c16 	blt	r5,zero,8111d19c <__smakebuf_r+0xac>
8111d12c:	d80d883a 	mov	r6,sp
8111d130:	111cf7c0 	call	8111cf7c <_fstat_r>
8111d134:	10001816 	blt	r2,zero,8111d198 <__smakebuf_r+0xa8>
8111d138:	d8800117 	ldw	r2,4(sp)
8111d13c:	00e00014 	movui	r3,32768
8111d140:	10bc000c 	andi	r2,r2,61440
8111d144:	14c80020 	cmpeqi	r19,r2,8192
8111d148:	10c03726 	beq	r2,r3,8111d228 <__smakebuf_r+0x138>
8111d14c:	80c0030b 	ldhu	r3,12(r16)
8111d150:	18c20014 	ori	r3,r3,2048
8111d154:	80c0030d 	sth	r3,12(r16)
8111d158:	00c80004 	movi	r3,8192
8111d15c:	10c0521e 	bne	r2,r3,8111d2a8 <__smakebuf_r+0x1b8>
8111d160:	8140038f 	ldh	r5,14(r16)
8111d164:	8809883a 	mov	r4,r17
8111d168:	112769c0 	call	8112769c <_isatty_r>
8111d16c:	10004c26 	beq	r2,zero,8111d2a0 <__smakebuf_r+0x1b0>
8111d170:	8080030b 	ldhu	r2,12(r16)
8111d174:	80c010c4 	addi	r3,r16,67
8111d178:	80c00015 	stw	r3,0(r16)
8111d17c:	10800054 	ori	r2,r2,1
8111d180:	8080030d 	sth	r2,12(r16)
8111d184:	00800044 	movi	r2,1
8111d188:	80c00415 	stw	r3,16(r16)
8111d18c:	80800515 	stw	r2,20(r16)
8111d190:	04810004 	movi	r18,1024
8111d194:	00000706 	br	8111d1b4 <__smakebuf_r+0xc4>
8111d198:	8080030b 	ldhu	r2,12(r16)
8111d19c:	10c0200c 	andi	r3,r2,128
8111d1a0:	18001f1e 	bne	r3,zero,8111d220 <__smakebuf_r+0x130>
8111d1a4:	04810004 	movi	r18,1024
8111d1a8:	10820014 	ori	r2,r2,2048
8111d1ac:	8080030d 	sth	r2,12(r16)
8111d1b0:	0027883a 	mov	r19,zero
8111d1b4:	900b883a 	mov	r5,r18
8111d1b8:	8809883a 	mov	r4,r17
8111d1bc:	111d2b40 	call	8111d2b4 <_malloc_r>
8111d1c0:	10002c26 	beq	r2,zero,8111d274 <__smakebuf_r+0x184>
8111d1c4:	80c0030b 	ldhu	r3,12(r16)
8111d1c8:	012044b4 	movhi	r4,33042
8111d1cc:	21194c04 	addi	r4,r4,25904
8111d1d0:	89000f15 	stw	r4,60(r17)
8111d1d4:	18c02014 	ori	r3,r3,128
8111d1d8:	80c0030d 	sth	r3,12(r16)
8111d1dc:	80800015 	stw	r2,0(r16)
8111d1e0:	80800415 	stw	r2,16(r16)
8111d1e4:	84800515 	stw	r18,20(r16)
8111d1e8:	98001a1e 	bne	r19,zero,8111d254 <__smakebuf_r+0x164>
8111d1ec:	dfc01317 	ldw	ra,76(sp)
8111d1f0:	dcc01217 	ldw	r19,72(sp)
8111d1f4:	dc801117 	ldw	r18,68(sp)
8111d1f8:	dc401017 	ldw	r17,64(sp)
8111d1fc:	dc000f17 	ldw	r16,60(sp)
8111d200:	dec01404 	addi	sp,sp,80
8111d204:	f800283a 	ret
8111d208:	288010c4 	addi	r2,r5,67
8111d20c:	28800015 	stw	r2,0(r5)
8111d210:	28800415 	stw	r2,16(r5)
8111d214:	00800044 	movi	r2,1
8111d218:	28800515 	stw	r2,20(r5)
8111d21c:	f800283a 	ret
8111d220:	04801004 	movi	r18,64
8111d224:	003fe006 	br	8111d1a8 <__reset+0xfb0fd1a8>
8111d228:	81000a17 	ldw	r4,40(r16)
8111d22c:	00e044b4 	movhi	r3,33042
8111d230:	18f94104 	addi	r3,r3,-6908
8111d234:	20ffc51e 	bne	r4,r3,8111d14c <__reset+0xfb0fd14c>
8111d238:	8080030b 	ldhu	r2,12(r16)
8111d23c:	04810004 	movi	r18,1024
8111d240:	84801315 	stw	r18,76(r16)
8111d244:	1484b03a 	or	r2,r2,r18
8111d248:	8080030d 	sth	r2,12(r16)
8111d24c:	0027883a 	mov	r19,zero
8111d250:	003fd806 	br	8111d1b4 <__reset+0xfb0fd1b4>
8111d254:	8140038f 	ldh	r5,14(r16)
8111d258:	8809883a 	mov	r4,r17
8111d25c:	112769c0 	call	8112769c <_isatty_r>
8111d260:	103fe226 	beq	r2,zero,8111d1ec <__reset+0xfb0fd1ec>
8111d264:	8080030b 	ldhu	r2,12(r16)
8111d268:	10800054 	ori	r2,r2,1
8111d26c:	8080030d 	sth	r2,12(r16)
8111d270:	003fde06 	br	8111d1ec <__reset+0xfb0fd1ec>
8111d274:	8080030b 	ldhu	r2,12(r16)
8111d278:	10c0800c 	andi	r3,r2,512
8111d27c:	183fdb1e 	bne	r3,zero,8111d1ec <__reset+0xfb0fd1ec>
8111d280:	10800094 	ori	r2,r2,2
8111d284:	80c010c4 	addi	r3,r16,67
8111d288:	8080030d 	sth	r2,12(r16)
8111d28c:	00800044 	movi	r2,1
8111d290:	80c00015 	stw	r3,0(r16)
8111d294:	80c00415 	stw	r3,16(r16)
8111d298:	80800515 	stw	r2,20(r16)
8111d29c:	003fd306 	br	8111d1ec <__reset+0xfb0fd1ec>
8111d2a0:	04810004 	movi	r18,1024
8111d2a4:	003fc306 	br	8111d1b4 <__reset+0xfb0fd1b4>
8111d2a8:	0027883a 	mov	r19,zero
8111d2ac:	04810004 	movi	r18,1024
8111d2b0:	003fc006 	br	8111d1b4 <__reset+0xfb0fd1b4>

8111d2b4 <_malloc_r>:
8111d2b4:	defff504 	addi	sp,sp,-44
8111d2b8:	de00012e 	bgeu	sp,et,8111d2c0 <_malloc_r+0xc>
8111d2bc:	003b68fa 	trap	3
8111d2c0:	288002c4 	addi	r2,r5,11
8111d2c4:	dc800315 	stw	r18,12(sp)
8111d2c8:	dfc00a15 	stw	ra,40(sp)
8111d2cc:	df000915 	stw	fp,36(sp)
8111d2d0:	ddc00815 	stw	r23,32(sp)
8111d2d4:	dd800715 	stw	r22,28(sp)
8111d2d8:	dd400615 	stw	r21,24(sp)
8111d2dc:	dd000515 	stw	r20,20(sp)
8111d2e0:	dcc00415 	stw	r19,16(sp)
8111d2e4:	dc400215 	stw	r17,8(sp)
8111d2e8:	dc000115 	stw	r16,4(sp)
8111d2ec:	00c00584 	movi	r3,22
8111d2f0:	2025883a 	mov	r18,r4
8111d2f4:	18807f2e 	bgeu	r3,r2,8111d4f4 <_malloc_r+0x240>
8111d2f8:	047ffe04 	movi	r17,-8
8111d2fc:	1462703a 	and	r17,r2,r17
8111d300:	8800a316 	blt	r17,zero,8111d590 <_malloc_r+0x2dc>
8111d304:	8940a236 	bltu	r17,r5,8111d590 <_malloc_r+0x2dc>
8111d308:	11340b00 	call	811340b0 <__malloc_lock>
8111d30c:	00807dc4 	movi	r2,503
8111d310:	1441e92e 	bgeu	r2,r17,8111dab8 <_malloc_r+0x804>
8111d314:	8804d27a 	srli	r2,r17,9
8111d318:	1000a126 	beq	r2,zero,8111d5a0 <_malloc_r+0x2ec>
8111d31c:	00c00104 	movi	r3,4
8111d320:	18811e36 	bltu	r3,r2,8111d79c <_malloc_r+0x4e8>
8111d324:	8804d1ba 	srli	r2,r17,6
8111d328:	12000e44 	addi	r8,r2,57
8111d32c:	11c00e04 	addi	r7,r2,56
8111d330:	4209883a 	add	r4,r8,r8
8111d334:	04e04574 	movhi	r19,33045
8111d338:	2109883a 	add	r4,r4,r4
8111d33c:	9cf44004 	addi	r19,r19,-12032
8111d340:	2109883a 	add	r4,r4,r4
8111d344:	9909883a 	add	r4,r19,r4
8111d348:	24000117 	ldw	r16,4(r4)
8111d34c:	213ffe04 	addi	r4,r4,-8
8111d350:	24009726 	beq	r4,r16,8111d5b0 <_malloc_r+0x2fc>
8111d354:	80800117 	ldw	r2,4(r16)
8111d358:	01bfff04 	movi	r6,-4
8111d35c:	014003c4 	movi	r5,15
8111d360:	1184703a 	and	r2,r2,r6
8111d364:	1447c83a 	sub	r3,r2,r17
8111d368:	28c00716 	blt	r5,r3,8111d388 <_malloc_r+0xd4>
8111d36c:	1800920e 	bge	r3,zero,8111d5b8 <_malloc_r+0x304>
8111d370:	84000317 	ldw	r16,12(r16)
8111d374:	24008e26 	beq	r4,r16,8111d5b0 <_malloc_r+0x2fc>
8111d378:	80800117 	ldw	r2,4(r16)
8111d37c:	1184703a 	and	r2,r2,r6
8111d380:	1447c83a 	sub	r3,r2,r17
8111d384:	28fff90e 	bge	r5,r3,8111d36c <__reset+0xfb0fd36c>
8111d388:	3809883a 	mov	r4,r7
8111d38c:	01a04574 	movhi	r6,33045
8111d390:	9c000417 	ldw	r16,16(r19)
8111d394:	31b44004 	addi	r6,r6,-12032
8111d398:	32000204 	addi	r8,r6,8
8111d39c:	82013426 	beq	r16,r8,8111d870 <_malloc_r+0x5bc>
8111d3a0:	80c00117 	ldw	r3,4(r16)
8111d3a4:	00bfff04 	movi	r2,-4
8111d3a8:	188e703a 	and	r7,r3,r2
8111d3ac:	3c45c83a 	sub	r2,r7,r17
8111d3b0:	00c003c4 	movi	r3,15
8111d3b4:	18811f16 	blt	r3,r2,8111d834 <_malloc_r+0x580>
8111d3b8:	32000515 	stw	r8,20(r6)
8111d3bc:	32000415 	stw	r8,16(r6)
8111d3c0:	10007f0e 	bge	r2,zero,8111d5c0 <_malloc_r+0x30c>
8111d3c4:	00807fc4 	movi	r2,511
8111d3c8:	11c0fd36 	bltu	r2,r7,8111d7c0 <_malloc_r+0x50c>
8111d3cc:	3806d0fa 	srli	r3,r7,3
8111d3d0:	01c00044 	movi	r7,1
8111d3d4:	30800117 	ldw	r2,4(r6)
8111d3d8:	19400044 	addi	r5,r3,1
8111d3dc:	294b883a 	add	r5,r5,r5
8111d3e0:	1807d0ba 	srai	r3,r3,2
8111d3e4:	294b883a 	add	r5,r5,r5
8111d3e8:	294b883a 	add	r5,r5,r5
8111d3ec:	298b883a 	add	r5,r5,r6
8111d3f0:	38c6983a 	sll	r3,r7,r3
8111d3f4:	29c00017 	ldw	r7,0(r5)
8111d3f8:	2a7ffe04 	addi	r9,r5,-8
8111d3fc:	1886b03a 	or	r3,r3,r2
8111d400:	82400315 	stw	r9,12(r16)
8111d404:	81c00215 	stw	r7,8(r16)
8111d408:	30c00115 	stw	r3,4(r6)
8111d40c:	2c000015 	stw	r16,0(r5)
8111d410:	3c000315 	stw	r16,12(r7)
8111d414:	2005d0ba 	srai	r2,r4,2
8111d418:	01400044 	movi	r5,1
8111d41c:	288a983a 	sll	r5,r5,r2
8111d420:	19406f36 	bltu	r3,r5,8111d5e0 <_malloc_r+0x32c>
8111d424:	28c4703a 	and	r2,r5,r3
8111d428:	10000a1e 	bne	r2,zero,8111d454 <_malloc_r+0x1a0>
8111d42c:	00bfff04 	movi	r2,-4
8111d430:	294b883a 	add	r5,r5,r5
8111d434:	2088703a 	and	r4,r4,r2
8111d438:	28c4703a 	and	r2,r5,r3
8111d43c:	21000104 	addi	r4,r4,4
8111d440:	1000041e 	bne	r2,zero,8111d454 <_malloc_r+0x1a0>
8111d444:	294b883a 	add	r5,r5,r5
8111d448:	28c4703a 	and	r2,r5,r3
8111d44c:	21000104 	addi	r4,r4,4
8111d450:	103ffc26 	beq	r2,zero,8111d444 <__reset+0xfb0fd444>
8111d454:	02bfff04 	movi	r10,-4
8111d458:	024003c4 	movi	r9,15
8111d45c:	21800044 	addi	r6,r4,1
8111d460:	318d883a 	add	r6,r6,r6
8111d464:	318d883a 	add	r6,r6,r6
8111d468:	318d883a 	add	r6,r6,r6
8111d46c:	998d883a 	add	r6,r19,r6
8111d470:	333ffe04 	addi	r12,r6,-8
8111d474:	2017883a 	mov	r11,r4
8111d478:	31800104 	addi	r6,r6,4
8111d47c:	34000017 	ldw	r16,0(r6)
8111d480:	31fffd04 	addi	r7,r6,-12
8111d484:	81c0041e 	bne	r16,r7,8111d498 <_malloc_r+0x1e4>
8111d488:	0000fb06 	br	8111d878 <_malloc_r+0x5c4>
8111d48c:	1801030e 	bge	r3,zero,8111d89c <_malloc_r+0x5e8>
8111d490:	84000317 	ldw	r16,12(r16)
8111d494:	81c0f826 	beq	r16,r7,8111d878 <_malloc_r+0x5c4>
8111d498:	80800117 	ldw	r2,4(r16)
8111d49c:	1284703a 	and	r2,r2,r10
8111d4a0:	1447c83a 	sub	r3,r2,r17
8111d4a4:	48fff90e 	bge	r9,r3,8111d48c <__reset+0xfb0fd48c>
8111d4a8:	80800317 	ldw	r2,12(r16)
8111d4ac:	81000217 	ldw	r4,8(r16)
8111d4b0:	89400054 	ori	r5,r17,1
8111d4b4:	81400115 	stw	r5,4(r16)
8111d4b8:	20800315 	stw	r2,12(r4)
8111d4bc:	11000215 	stw	r4,8(r2)
8111d4c0:	8463883a 	add	r17,r16,r17
8111d4c4:	9c400515 	stw	r17,20(r19)
8111d4c8:	9c400415 	stw	r17,16(r19)
8111d4cc:	18800054 	ori	r2,r3,1
8111d4d0:	88800115 	stw	r2,4(r17)
8111d4d4:	8a000315 	stw	r8,12(r17)
8111d4d8:	8a000215 	stw	r8,8(r17)
8111d4dc:	88e3883a 	add	r17,r17,r3
8111d4e0:	88c00015 	stw	r3,0(r17)
8111d4e4:	9009883a 	mov	r4,r18
8111d4e8:	11341d80 	call	811341d8 <__malloc_unlock>
8111d4ec:	80800204 	addi	r2,r16,8
8111d4f0:	00001b06 	br	8111d560 <_malloc_r+0x2ac>
8111d4f4:	04400404 	movi	r17,16
8111d4f8:	89402536 	bltu	r17,r5,8111d590 <_malloc_r+0x2dc>
8111d4fc:	11340b00 	call	811340b0 <__malloc_lock>
8111d500:	00800184 	movi	r2,6
8111d504:	01000084 	movi	r4,2
8111d508:	04e04574 	movhi	r19,33045
8111d50c:	1085883a 	add	r2,r2,r2
8111d510:	9cf44004 	addi	r19,r19,-12032
8111d514:	1085883a 	add	r2,r2,r2
8111d518:	9885883a 	add	r2,r19,r2
8111d51c:	14000117 	ldw	r16,4(r2)
8111d520:	10fffe04 	addi	r3,r2,-8
8111d524:	80c0d926 	beq	r16,r3,8111d88c <_malloc_r+0x5d8>
8111d528:	80c00117 	ldw	r3,4(r16)
8111d52c:	81000317 	ldw	r4,12(r16)
8111d530:	00bfff04 	movi	r2,-4
8111d534:	1884703a 	and	r2,r3,r2
8111d538:	81400217 	ldw	r5,8(r16)
8111d53c:	8085883a 	add	r2,r16,r2
8111d540:	10c00117 	ldw	r3,4(r2)
8111d544:	29000315 	stw	r4,12(r5)
8111d548:	21400215 	stw	r5,8(r4)
8111d54c:	18c00054 	ori	r3,r3,1
8111d550:	10c00115 	stw	r3,4(r2)
8111d554:	9009883a 	mov	r4,r18
8111d558:	11341d80 	call	811341d8 <__malloc_unlock>
8111d55c:	80800204 	addi	r2,r16,8
8111d560:	dfc00a17 	ldw	ra,40(sp)
8111d564:	df000917 	ldw	fp,36(sp)
8111d568:	ddc00817 	ldw	r23,32(sp)
8111d56c:	dd800717 	ldw	r22,28(sp)
8111d570:	dd400617 	ldw	r21,24(sp)
8111d574:	dd000517 	ldw	r20,20(sp)
8111d578:	dcc00417 	ldw	r19,16(sp)
8111d57c:	dc800317 	ldw	r18,12(sp)
8111d580:	dc400217 	ldw	r17,8(sp)
8111d584:	dc000117 	ldw	r16,4(sp)
8111d588:	dec00b04 	addi	sp,sp,44
8111d58c:	f800283a 	ret
8111d590:	00800304 	movi	r2,12
8111d594:	90800015 	stw	r2,0(r18)
8111d598:	0005883a 	mov	r2,zero
8111d59c:	003ff006 	br	8111d560 <__reset+0xfb0fd560>
8111d5a0:	01002004 	movi	r4,128
8111d5a4:	02001004 	movi	r8,64
8111d5a8:	01c00fc4 	movi	r7,63
8111d5ac:	003f6106 	br	8111d334 <__reset+0xfb0fd334>
8111d5b0:	4009883a 	mov	r4,r8
8111d5b4:	003f7506 	br	8111d38c <__reset+0xfb0fd38c>
8111d5b8:	81000317 	ldw	r4,12(r16)
8111d5bc:	003fde06 	br	8111d538 <__reset+0xfb0fd538>
8111d5c0:	81c5883a 	add	r2,r16,r7
8111d5c4:	11400117 	ldw	r5,4(r2)
8111d5c8:	9009883a 	mov	r4,r18
8111d5cc:	29400054 	ori	r5,r5,1
8111d5d0:	11400115 	stw	r5,4(r2)
8111d5d4:	11341d80 	call	811341d8 <__malloc_unlock>
8111d5d8:	80800204 	addi	r2,r16,8
8111d5dc:	003fe006 	br	8111d560 <__reset+0xfb0fd560>
8111d5e0:	9c000217 	ldw	r16,8(r19)
8111d5e4:	00bfff04 	movi	r2,-4
8111d5e8:	85800117 	ldw	r22,4(r16)
8111d5ec:	b0ac703a 	and	r22,r22,r2
8111d5f0:	b4400336 	bltu	r22,r17,8111d600 <_malloc_r+0x34c>
8111d5f4:	b445c83a 	sub	r2,r22,r17
8111d5f8:	00c003c4 	movi	r3,15
8111d5fc:	18805d16 	blt	r3,r2,8111d774 <_malloc_r+0x4c0>
8111d600:	05e04574 	movhi	r23,33045
8111d604:	00a04574 	movhi	r2,33045
8111d608:	10baf404 	addi	r2,r2,-5168
8111d60c:	bdfa8304 	addi	r23,r23,-5620
8111d610:	15400017 	ldw	r21,0(r2)
8111d614:	b8c00017 	ldw	r3,0(r23)
8111d618:	00bfffc4 	movi	r2,-1
8111d61c:	858d883a 	add	r6,r16,r22
8111d620:	8d6b883a 	add	r21,r17,r21
8111d624:	1880ea26 	beq	r3,r2,8111d9d0 <_malloc_r+0x71c>
8111d628:	ad4403c4 	addi	r21,r21,4111
8111d62c:	00bc0004 	movi	r2,-4096
8111d630:	a8aa703a 	and	r21,r21,r2
8111d634:	a80b883a 	mov	r5,r21
8111d638:	9009883a 	mov	r4,r18
8111d63c:	d9800015 	stw	r6,0(sp)
8111d640:	111e2700 	call	8111e270 <_sbrk_r>
8111d644:	1029883a 	mov	r20,r2
8111d648:	00bfffc4 	movi	r2,-1
8111d64c:	d9800017 	ldw	r6,0(sp)
8111d650:	a080e826 	beq	r20,r2,8111d9f4 <_malloc_r+0x740>
8111d654:	a180a636 	bltu	r20,r6,8111d8f0 <_malloc_r+0x63c>
8111d658:	07204574 	movhi	fp,33045
8111d65c:	e73b8104 	addi	fp,fp,-4604
8111d660:	e0800017 	ldw	r2,0(fp)
8111d664:	a887883a 	add	r3,r21,r2
8111d668:	e0c00015 	stw	r3,0(fp)
8111d66c:	3500e626 	beq	r6,r20,8111da08 <_malloc_r+0x754>
8111d670:	b9000017 	ldw	r4,0(r23)
8111d674:	00bfffc4 	movi	r2,-1
8111d678:	2080ee26 	beq	r4,r2,8111da34 <_malloc_r+0x780>
8111d67c:	a185c83a 	sub	r2,r20,r6
8111d680:	10c5883a 	add	r2,r2,r3
8111d684:	e0800015 	stw	r2,0(fp)
8111d688:	a0c001cc 	andi	r3,r20,7
8111d68c:	1800bc26 	beq	r3,zero,8111d980 <_malloc_r+0x6cc>
8111d690:	a0e9c83a 	sub	r20,r20,r3
8111d694:	00840204 	movi	r2,4104
8111d698:	a5000204 	addi	r20,r20,8
8111d69c:	10c7c83a 	sub	r3,r2,r3
8111d6a0:	a545883a 	add	r2,r20,r21
8111d6a4:	1083ffcc 	andi	r2,r2,4095
8111d6a8:	18abc83a 	sub	r21,r3,r2
8111d6ac:	a80b883a 	mov	r5,r21
8111d6b0:	9009883a 	mov	r4,r18
8111d6b4:	111e2700 	call	8111e270 <_sbrk_r>
8111d6b8:	00ffffc4 	movi	r3,-1
8111d6bc:	10c0e126 	beq	r2,r3,8111da44 <_malloc_r+0x790>
8111d6c0:	1505c83a 	sub	r2,r2,r20
8111d6c4:	1545883a 	add	r2,r2,r21
8111d6c8:	10800054 	ori	r2,r2,1
8111d6cc:	e0c00017 	ldw	r3,0(fp)
8111d6d0:	9d000215 	stw	r20,8(r19)
8111d6d4:	a0800115 	stw	r2,4(r20)
8111d6d8:	a8c7883a 	add	r3,r21,r3
8111d6dc:	e0c00015 	stw	r3,0(fp)
8111d6e0:	84c00e26 	beq	r16,r19,8111d71c <_malloc_r+0x468>
8111d6e4:	018003c4 	movi	r6,15
8111d6e8:	3580a72e 	bgeu	r6,r22,8111d988 <_malloc_r+0x6d4>
8111d6ec:	81400117 	ldw	r5,4(r16)
8111d6f0:	013ffe04 	movi	r4,-8
8111d6f4:	b0bffd04 	addi	r2,r22,-12
8111d6f8:	1104703a 	and	r2,r2,r4
8111d6fc:	2900004c 	andi	r4,r5,1
8111d700:	2088b03a 	or	r4,r4,r2
8111d704:	81000115 	stw	r4,4(r16)
8111d708:	01400144 	movi	r5,5
8111d70c:	8089883a 	add	r4,r16,r2
8111d710:	21400115 	stw	r5,4(r4)
8111d714:	21400215 	stw	r5,8(r4)
8111d718:	3080cd36 	bltu	r6,r2,8111da50 <_malloc_r+0x79c>
8111d71c:	00a04574 	movhi	r2,33045
8111d720:	10baf304 	addi	r2,r2,-5172
8111d724:	11000017 	ldw	r4,0(r2)
8111d728:	20c0012e 	bgeu	r4,r3,8111d730 <_malloc_r+0x47c>
8111d72c:	10c00015 	stw	r3,0(r2)
8111d730:	00a04574 	movhi	r2,33045
8111d734:	10baf204 	addi	r2,r2,-5176
8111d738:	11000017 	ldw	r4,0(r2)
8111d73c:	9c000217 	ldw	r16,8(r19)
8111d740:	20c0012e 	bgeu	r4,r3,8111d748 <_malloc_r+0x494>
8111d744:	10c00015 	stw	r3,0(r2)
8111d748:	80c00117 	ldw	r3,4(r16)
8111d74c:	00bfff04 	movi	r2,-4
8111d750:	1886703a 	and	r3,r3,r2
8111d754:	1c45c83a 	sub	r2,r3,r17
8111d758:	1c400236 	bltu	r3,r17,8111d764 <_malloc_r+0x4b0>
8111d75c:	00c003c4 	movi	r3,15
8111d760:	18800416 	blt	r3,r2,8111d774 <_malloc_r+0x4c0>
8111d764:	9009883a 	mov	r4,r18
8111d768:	11341d80 	call	811341d8 <__malloc_unlock>
8111d76c:	0005883a 	mov	r2,zero
8111d770:	003f7b06 	br	8111d560 <__reset+0xfb0fd560>
8111d774:	88c00054 	ori	r3,r17,1
8111d778:	80c00115 	stw	r3,4(r16)
8111d77c:	8463883a 	add	r17,r16,r17
8111d780:	10800054 	ori	r2,r2,1
8111d784:	9c400215 	stw	r17,8(r19)
8111d788:	88800115 	stw	r2,4(r17)
8111d78c:	9009883a 	mov	r4,r18
8111d790:	11341d80 	call	811341d8 <__malloc_unlock>
8111d794:	80800204 	addi	r2,r16,8
8111d798:	003f7106 	br	8111d560 <__reset+0xfb0fd560>
8111d79c:	00c00504 	movi	r3,20
8111d7a0:	18804a2e 	bgeu	r3,r2,8111d8cc <_malloc_r+0x618>
8111d7a4:	00c01504 	movi	r3,84
8111d7a8:	18806e36 	bltu	r3,r2,8111d964 <_malloc_r+0x6b0>
8111d7ac:	8804d33a 	srli	r2,r17,12
8111d7b0:	12001bc4 	addi	r8,r2,111
8111d7b4:	11c01b84 	addi	r7,r2,110
8111d7b8:	4209883a 	add	r4,r8,r8
8111d7bc:	003edd06 	br	8111d334 <__reset+0xfb0fd334>
8111d7c0:	3804d27a 	srli	r2,r7,9
8111d7c4:	00c00104 	movi	r3,4
8111d7c8:	1880442e 	bgeu	r3,r2,8111d8dc <_malloc_r+0x628>
8111d7cc:	00c00504 	movi	r3,20
8111d7d0:	18808136 	bltu	r3,r2,8111d9d8 <_malloc_r+0x724>
8111d7d4:	11401704 	addi	r5,r2,92
8111d7d8:	10c016c4 	addi	r3,r2,91
8111d7dc:	294b883a 	add	r5,r5,r5
8111d7e0:	294b883a 	add	r5,r5,r5
8111d7e4:	294b883a 	add	r5,r5,r5
8111d7e8:	994b883a 	add	r5,r19,r5
8111d7ec:	28800017 	ldw	r2,0(r5)
8111d7f0:	01a04574 	movhi	r6,33045
8111d7f4:	297ffe04 	addi	r5,r5,-8
8111d7f8:	31b44004 	addi	r6,r6,-12032
8111d7fc:	28806526 	beq	r5,r2,8111d994 <_malloc_r+0x6e0>
8111d800:	01bfff04 	movi	r6,-4
8111d804:	10c00117 	ldw	r3,4(r2)
8111d808:	1986703a 	and	r3,r3,r6
8111d80c:	38c0022e 	bgeu	r7,r3,8111d818 <_malloc_r+0x564>
8111d810:	10800217 	ldw	r2,8(r2)
8111d814:	28bffb1e 	bne	r5,r2,8111d804 <__reset+0xfb0fd804>
8111d818:	11400317 	ldw	r5,12(r2)
8111d81c:	98c00117 	ldw	r3,4(r19)
8111d820:	81400315 	stw	r5,12(r16)
8111d824:	80800215 	stw	r2,8(r16)
8111d828:	2c000215 	stw	r16,8(r5)
8111d82c:	14000315 	stw	r16,12(r2)
8111d830:	003ef806 	br	8111d414 <__reset+0xfb0fd414>
8111d834:	88c00054 	ori	r3,r17,1
8111d838:	80c00115 	stw	r3,4(r16)
8111d83c:	8463883a 	add	r17,r16,r17
8111d840:	34400515 	stw	r17,20(r6)
8111d844:	34400415 	stw	r17,16(r6)
8111d848:	10c00054 	ori	r3,r2,1
8111d84c:	8a000315 	stw	r8,12(r17)
8111d850:	8a000215 	stw	r8,8(r17)
8111d854:	88c00115 	stw	r3,4(r17)
8111d858:	88a3883a 	add	r17,r17,r2
8111d85c:	88800015 	stw	r2,0(r17)
8111d860:	9009883a 	mov	r4,r18
8111d864:	11341d80 	call	811341d8 <__malloc_unlock>
8111d868:	80800204 	addi	r2,r16,8
8111d86c:	003f3c06 	br	8111d560 <__reset+0xfb0fd560>
8111d870:	30c00117 	ldw	r3,4(r6)
8111d874:	003ee706 	br	8111d414 <__reset+0xfb0fd414>
8111d878:	5ac00044 	addi	r11,r11,1
8111d87c:	588000cc 	andi	r2,r11,3
8111d880:	31800204 	addi	r6,r6,8
8111d884:	103efd1e 	bne	r2,zero,8111d47c <__reset+0xfb0fd47c>
8111d888:	00002406 	br	8111d91c <_malloc_r+0x668>
8111d88c:	14000317 	ldw	r16,12(r2)
8111d890:	143f251e 	bne	r2,r16,8111d528 <__reset+0xfb0fd528>
8111d894:	21000084 	addi	r4,r4,2
8111d898:	003ebc06 	br	8111d38c <__reset+0xfb0fd38c>
8111d89c:	8085883a 	add	r2,r16,r2
8111d8a0:	10c00117 	ldw	r3,4(r2)
8111d8a4:	81000317 	ldw	r4,12(r16)
8111d8a8:	81400217 	ldw	r5,8(r16)
8111d8ac:	18c00054 	ori	r3,r3,1
8111d8b0:	10c00115 	stw	r3,4(r2)
8111d8b4:	29000315 	stw	r4,12(r5)
8111d8b8:	21400215 	stw	r5,8(r4)
8111d8bc:	9009883a 	mov	r4,r18
8111d8c0:	11341d80 	call	811341d8 <__malloc_unlock>
8111d8c4:	80800204 	addi	r2,r16,8
8111d8c8:	003f2506 	br	8111d560 <__reset+0xfb0fd560>
8111d8cc:	12001704 	addi	r8,r2,92
8111d8d0:	11c016c4 	addi	r7,r2,91
8111d8d4:	4209883a 	add	r4,r8,r8
8111d8d8:	003e9606 	br	8111d334 <__reset+0xfb0fd334>
8111d8dc:	3804d1ba 	srli	r2,r7,6
8111d8e0:	11400e44 	addi	r5,r2,57
8111d8e4:	10c00e04 	addi	r3,r2,56
8111d8e8:	294b883a 	add	r5,r5,r5
8111d8ec:	003fbc06 	br	8111d7e0 <__reset+0xfb0fd7e0>
8111d8f0:	84ff5926 	beq	r16,r19,8111d658 <__reset+0xfb0fd658>
8111d8f4:	00a04574 	movhi	r2,33045
8111d8f8:	10b44004 	addi	r2,r2,-12032
8111d8fc:	14000217 	ldw	r16,8(r2)
8111d900:	00bfff04 	movi	r2,-4
8111d904:	80c00117 	ldw	r3,4(r16)
8111d908:	1886703a 	and	r3,r3,r2
8111d90c:	003f9106 	br	8111d754 <__reset+0xfb0fd754>
8111d910:	60800217 	ldw	r2,8(r12)
8111d914:	213fffc4 	addi	r4,r4,-1
8111d918:	1300651e 	bne	r2,r12,8111dab0 <_malloc_r+0x7fc>
8111d91c:	208000cc 	andi	r2,r4,3
8111d920:	633ffe04 	addi	r12,r12,-8
8111d924:	103ffa1e 	bne	r2,zero,8111d910 <__reset+0xfb0fd910>
8111d928:	98800117 	ldw	r2,4(r19)
8111d92c:	0146303a 	nor	r3,zero,r5
8111d930:	1884703a 	and	r2,r3,r2
8111d934:	98800115 	stw	r2,4(r19)
8111d938:	294b883a 	add	r5,r5,r5
8111d93c:	117f2836 	bltu	r2,r5,8111d5e0 <__reset+0xfb0fd5e0>
8111d940:	283f2726 	beq	r5,zero,8111d5e0 <__reset+0xfb0fd5e0>
8111d944:	2886703a 	and	r3,r5,r2
8111d948:	5809883a 	mov	r4,r11
8111d94c:	183ec31e 	bne	r3,zero,8111d45c <__reset+0xfb0fd45c>
8111d950:	294b883a 	add	r5,r5,r5
8111d954:	2886703a 	and	r3,r5,r2
8111d958:	21000104 	addi	r4,r4,4
8111d95c:	183ffc26 	beq	r3,zero,8111d950 <__reset+0xfb0fd950>
8111d960:	003ebe06 	br	8111d45c <__reset+0xfb0fd45c>
8111d964:	00c05504 	movi	r3,340
8111d968:	18801236 	bltu	r3,r2,8111d9b4 <_malloc_r+0x700>
8111d96c:	8804d3fa 	srli	r2,r17,15
8111d970:	12001e04 	addi	r8,r2,120
8111d974:	11c01dc4 	addi	r7,r2,119
8111d978:	4209883a 	add	r4,r8,r8
8111d97c:	003e6d06 	br	8111d334 <__reset+0xfb0fd334>
8111d980:	00c40004 	movi	r3,4096
8111d984:	003f4606 	br	8111d6a0 <__reset+0xfb0fd6a0>
8111d988:	00800044 	movi	r2,1
8111d98c:	a0800115 	stw	r2,4(r20)
8111d990:	003f7406 	br	8111d764 <__reset+0xfb0fd764>
8111d994:	1805d0ba 	srai	r2,r3,2
8111d998:	01c00044 	movi	r7,1
8111d99c:	30c00117 	ldw	r3,4(r6)
8111d9a0:	388e983a 	sll	r7,r7,r2
8111d9a4:	2805883a 	mov	r2,r5
8111d9a8:	38c6b03a 	or	r3,r7,r3
8111d9ac:	30c00115 	stw	r3,4(r6)
8111d9b0:	003f9b06 	br	8111d820 <__reset+0xfb0fd820>
8111d9b4:	00c15504 	movi	r3,1364
8111d9b8:	18801a36 	bltu	r3,r2,8111da24 <_malloc_r+0x770>
8111d9bc:	8804d4ba 	srli	r2,r17,18
8111d9c0:	12001f44 	addi	r8,r2,125
8111d9c4:	11c01f04 	addi	r7,r2,124
8111d9c8:	4209883a 	add	r4,r8,r8
8111d9cc:	003e5906 	br	8111d334 <__reset+0xfb0fd334>
8111d9d0:	ad400404 	addi	r21,r21,16
8111d9d4:	003f1706 	br	8111d634 <__reset+0xfb0fd634>
8111d9d8:	00c01504 	movi	r3,84
8111d9dc:	18802336 	bltu	r3,r2,8111da6c <_malloc_r+0x7b8>
8111d9e0:	3804d33a 	srli	r2,r7,12
8111d9e4:	11401bc4 	addi	r5,r2,111
8111d9e8:	10c01b84 	addi	r3,r2,110
8111d9ec:	294b883a 	add	r5,r5,r5
8111d9f0:	003f7b06 	br	8111d7e0 <__reset+0xfb0fd7e0>
8111d9f4:	9c000217 	ldw	r16,8(r19)
8111d9f8:	00bfff04 	movi	r2,-4
8111d9fc:	80c00117 	ldw	r3,4(r16)
8111da00:	1886703a 	and	r3,r3,r2
8111da04:	003f5306 	br	8111d754 <__reset+0xfb0fd754>
8111da08:	3083ffcc 	andi	r2,r6,4095
8111da0c:	103f181e 	bne	r2,zero,8111d670 <__reset+0xfb0fd670>
8111da10:	99000217 	ldw	r4,8(r19)
8111da14:	b545883a 	add	r2,r22,r21
8111da18:	10800054 	ori	r2,r2,1
8111da1c:	20800115 	stw	r2,4(r4)
8111da20:	003f3e06 	br	8111d71c <__reset+0xfb0fd71c>
8111da24:	01003f84 	movi	r4,254
8111da28:	02001fc4 	movi	r8,127
8111da2c:	01c01f84 	movi	r7,126
8111da30:	003e4006 	br	8111d334 <__reset+0xfb0fd334>
8111da34:	00a04574 	movhi	r2,33045
8111da38:	10ba8304 	addi	r2,r2,-5620
8111da3c:	15000015 	stw	r20,0(r2)
8111da40:	003f1106 	br	8111d688 <__reset+0xfb0fd688>
8111da44:	00800044 	movi	r2,1
8111da48:	002b883a 	mov	r21,zero
8111da4c:	003f1f06 	br	8111d6cc <__reset+0xfb0fd6cc>
8111da50:	81400204 	addi	r5,r16,8
8111da54:	9009883a 	mov	r4,r18
8111da58:	1126d280 	call	81126d28 <_free_r>
8111da5c:	00a04574 	movhi	r2,33045
8111da60:	10bb8104 	addi	r2,r2,-4604
8111da64:	10c00017 	ldw	r3,0(r2)
8111da68:	003f2c06 	br	8111d71c <__reset+0xfb0fd71c>
8111da6c:	00c05504 	movi	r3,340
8111da70:	18800536 	bltu	r3,r2,8111da88 <_malloc_r+0x7d4>
8111da74:	3804d3fa 	srli	r2,r7,15
8111da78:	11401e04 	addi	r5,r2,120
8111da7c:	10c01dc4 	addi	r3,r2,119
8111da80:	294b883a 	add	r5,r5,r5
8111da84:	003f5606 	br	8111d7e0 <__reset+0xfb0fd7e0>
8111da88:	00c15504 	movi	r3,1364
8111da8c:	18800536 	bltu	r3,r2,8111daa4 <_malloc_r+0x7f0>
8111da90:	3804d4ba 	srli	r2,r7,18
8111da94:	11401f44 	addi	r5,r2,125
8111da98:	10c01f04 	addi	r3,r2,124
8111da9c:	294b883a 	add	r5,r5,r5
8111daa0:	003f4f06 	br	8111d7e0 <__reset+0xfb0fd7e0>
8111daa4:	01403f84 	movi	r5,254
8111daa8:	00c01f84 	movi	r3,126
8111daac:	003f4c06 	br	8111d7e0 <__reset+0xfb0fd7e0>
8111dab0:	98800117 	ldw	r2,4(r19)
8111dab4:	003fa006 	br	8111d938 <__reset+0xfb0fd938>
8111dab8:	8808d0fa 	srli	r4,r17,3
8111dabc:	20800044 	addi	r2,r4,1
8111dac0:	1085883a 	add	r2,r2,r2
8111dac4:	003e9006 	br	8111d508 <__reset+0xfb0fd508>

8111dac8 <memcpy>:
8111dac8:	defffd04 	addi	sp,sp,-12
8111dacc:	de00012e 	bgeu	sp,et,8111dad4 <memcpy+0xc>
8111dad0:	003b68fa 	trap	3
8111dad4:	00c003c4 	movi	r3,15
8111dad8:	dfc00215 	stw	ra,8(sp)
8111dadc:	dc400115 	stw	r17,4(sp)
8111dae0:	dc000015 	stw	r16,0(sp)
8111dae4:	2005883a 	mov	r2,r4
8111dae8:	1980452e 	bgeu	r3,r6,8111dc00 <memcpy+0x138>
8111daec:	2906b03a 	or	r3,r5,r4
8111daf0:	18c000cc 	andi	r3,r3,3
8111daf4:	1800441e 	bne	r3,zero,8111dc08 <memcpy+0x140>
8111daf8:	347ffc04 	addi	r17,r6,-16
8111dafc:	8822d13a 	srli	r17,r17,4
8111db00:	28c00104 	addi	r3,r5,4
8111db04:	23400104 	addi	r13,r4,4
8111db08:	8820913a 	slli	r16,r17,4
8111db0c:	2b000204 	addi	r12,r5,8
8111db10:	22c00204 	addi	r11,r4,8
8111db14:	84000504 	addi	r16,r16,20
8111db18:	2a800304 	addi	r10,r5,12
8111db1c:	22400304 	addi	r9,r4,12
8111db20:	2c21883a 	add	r16,r5,r16
8111db24:	2811883a 	mov	r8,r5
8111db28:	200f883a 	mov	r7,r4
8111db2c:	41000017 	ldw	r4,0(r8)
8111db30:	1fc00017 	ldw	ra,0(r3)
8111db34:	63c00017 	ldw	r15,0(r12)
8111db38:	39000015 	stw	r4,0(r7)
8111db3c:	53800017 	ldw	r14,0(r10)
8111db40:	6fc00015 	stw	ra,0(r13)
8111db44:	5bc00015 	stw	r15,0(r11)
8111db48:	4b800015 	stw	r14,0(r9)
8111db4c:	18c00404 	addi	r3,r3,16
8111db50:	39c00404 	addi	r7,r7,16
8111db54:	42000404 	addi	r8,r8,16
8111db58:	6b400404 	addi	r13,r13,16
8111db5c:	63000404 	addi	r12,r12,16
8111db60:	5ac00404 	addi	r11,r11,16
8111db64:	52800404 	addi	r10,r10,16
8111db68:	4a400404 	addi	r9,r9,16
8111db6c:	1c3fef1e 	bne	r3,r16,8111db2c <__reset+0xfb0fdb2c>
8111db70:	89c00044 	addi	r7,r17,1
8111db74:	380e913a 	slli	r7,r7,4
8111db78:	310003cc 	andi	r4,r6,15
8111db7c:	02c000c4 	movi	r11,3
8111db80:	11c7883a 	add	r3,r2,r7
8111db84:	29cb883a 	add	r5,r5,r7
8111db88:	5900212e 	bgeu	r11,r4,8111dc10 <memcpy+0x148>
8111db8c:	1813883a 	mov	r9,r3
8111db90:	2811883a 	mov	r8,r5
8111db94:	200f883a 	mov	r7,r4
8111db98:	42800017 	ldw	r10,0(r8)
8111db9c:	4a400104 	addi	r9,r9,4
8111dba0:	39ffff04 	addi	r7,r7,-4
8111dba4:	4abfff15 	stw	r10,-4(r9)
8111dba8:	42000104 	addi	r8,r8,4
8111dbac:	59fffa36 	bltu	r11,r7,8111db98 <__reset+0xfb0fdb98>
8111dbb0:	213fff04 	addi	r4,r4,-4
8111dbb4:	2008d0ba 	srli	r4,r4,2
8111dbb8:	318000cc 	andi	r6,r6,3
8111dbbc:	21000044 	addi	r4,r4,1
8111dbc0:	2109883a 	add	r4,r4,r4
8111dbc4:	2109883a 	add	r4,r4,r4
8111dbc8:	1907883a 	add	r3,r3,r4
8111dbcc:	290b883a 	add	r5,r5,r4
8111dbd0:	30000626 	beq	r6,zero,8111dbec <memcpy+0x124>
8111dbd4:	198d883a 	add	r6,r3,r6
8111dbd8:	29c00003 	ldbu	r7,0(r5)
8111dbdc:	18c00044 	addi	r3,r3,1
8111dbe0:	29400044 	addi	r5,r5,1
8111dbe4:	19ffffc5 	stb	r7,-1(r3)
8111dbe8:	19bffb1e 	bne	r3,r6,8111dbd8 <__reset+0xfb0fdbd8>
8111dbec:	dfc00217 	ldw	ra,8(sp)
8111dbf0:	dc400117 	ldw	r17,4(sp)
8111dbf4:	dc000017 	ldw	r16,0(sp)
8111dbf8:	dec00304 	addi	sp,sp,12
8111dbfc:	f800283a 	ret
8111dc00:	2007883a 	mov	r3,r4
8111dc04:	003ff206 	br	8111dbd0 <__reset+0xfb0fdbd0>
8111dc08:	2007883a 	mov	r3,r4
8111dc0c:	003ff106 	br	8111dbd4 <__reset+0xfb0fdbd4>
8111dc10:	200d883a 	mov	r6,r4
8111dc14:	003fee06 	br	8111dbd0 <__reset+0xfb0fdbd0>

8111dc18 <memset>:
8111dc18:	20c000cc 	andi	r3,r4,3
8111dc1c:	2005883a 	mov	r2,r4
8111dc20:	18004426 	beq	r3,zero,8111dd34 <memset+0x11c>
8111dc24:	31ffffc4 	addi	r7,r6,-1
8111dc28:	30004026 	beq	r6,zero,8111dd2c <memset+0x114>
8111dc2c:	2813883a 	mov	r9,r5
8111dc30:	200d883a 	mov	r6,r4
8111dc34:	2007883a 	mov	r3,r4
8111dc38:	00000406 	br	8111dc4c <memset+0x34>
8111dc3c:	3a3fffc4 	addi	r8,r7,-1
8111dc40:	31800044 	addi	r6,r6,1
8111dc44:	38003926 	beq	r7,zero,8111dd2c <memset+0x114>
8111dc48:	400f883a 	mov	r7,r8
8111dc4c:	18c00044 	addi	r3,r3,1
8111dc50:	32400005 	stb	r9,0(r6)
8111dc54:	1a0000cc 	andi	r8,r3,3
8111dc58:	403ff81e 	bne	r8,zero,8111dc3c <__reset+0xfb0fdc3c>
8111dc5c:	010000c4 	movi	r4,3
8111dc60:	21c02d2e 	bgeu	r4,r7,8111dd18 <memset+0x100>
8111dc64:	29003fcc 	andi	r4,r5,255
8111dc68:	200c923a 	slli	r6,r4,8
8111dc6c:	3108b03a 	or	r4,r6,r4
8111dc70:	200c943a 	slli	r6,r4,16
8111dc74:	218cb03a 	or	r6,r4,r6
8111dc78:	010003c4 	movi	r4,15
8111dc7c:	21c0182e 	bgeu	r4,r7,8111dce0 <memset+0xc8>
8111dc80:	3b3ffc04 	addi	r12,r7,-16
8111dc84:	6018d13a 	srli	r12,r12,4
8111dc88:	1a000104 	addi	r8,r3,4
8111dc8c:	1ac00204 	addi	r11,r3,8
8111dc90:	6008913a 	slli	r4,r12,4
8111dc94:	1a800304 	addi	r10,r3,12
8111dc98:	1813883a 	mov	r9,r3
8111dc9c:	21000504 	addi	r4,r4,20
8111dca0:	1909883a 	add	r4,r3,r4
8111dca4:	49800015 	stw	r6,0(r9)
8111dca8:	41800015 	stw	r6,0(r8)
8111dcac:	59800015 	stw	r6,0(r11)
8111dcb0:	51800015 	stw	r6,0(r10)
8111dcb4:	42000404 	addi	r8,r8,16
8111dcb8:	4a400404 	addi	r9,r9,16
8111dcbc:	5ac00404 	addi	r11,r11,16
8111dcc0:	52800404 	addi	r10,r10,16
8111dcc4:	413ff71e 	bne	r8,r4,8111dca4 <__reset+0xfb0fdca4>
8111dcc8:	63000044 	addi	r12,r12,1
8111dccc:	6018913a 	slli	r12,r12,4
8111dcd0:	39c003cc 	andi	r7,r7,15
8111dcd4:	010000c4 	movi	r4,3
8111dcd8:	1b07883a 	add	r3,r3,r12
8111dcdc:	21c00e2e 	bgeu	r4,r7,8111dd18 <memset+0x100>
8111dce0:	1813883a 	mov	r9,r3
8111dce4:	3811883a 	mov	r8,r7
8111dce8:	010000c4 	movi	r4,3
8111dcec:	49800015 	stw	r6,0(r9)
8111dcf0:	423fff04 	addi	r8,r8,-4
8111dcf4:	4a400104 	addi	r9,r9,4
8111dcf8:	223ffc36 	bltu	r4,r8,8111dcec <__reset+0xfb0fdcec>
8111dcfc:	393fff04 	addi	r4,r7,-4
8111dd00:	2008d0ba 	srli	r4,r4,2
8111dd04:	39c000cc 	andi	r7,r7,3
8111dd08:	21000044 	addi	r4,r4,1
8111dd0c:	2109883a 	add	r4,r4,r4
8111dd10:	2109883a 	add	r4,r4,r4
8111dd14:	1907883a 	add	r3,r3,r4
8111dd18:	38000526 	beq	r7,zero,8111dd30 <memset+0x118>
8111dd1c:	19cf883a 	add	r7,r3,r7
8111dd20:	19400005 	stb	r5,0(r3)
8111dd24:	18c00044 	addi	r3,r3,1
8111dd28:	38fffd1e 	bne	r7,r3,8111dd20 <__reset+0xfb0fdd20>
8111dd2c:	f800283a 	ret
8111dd30:	f800283a 	ret
8111dd34:	2007883a 	mov	r3,r4
8111dd38:	300f883a 	mov	r7,r6
8111dd3c:	003fc706 	br	8111dc5c <__reset+0xfb0fdc5c>

8111dd40 <_open_r>:
8111dd40:	defffd04 	addi	sp,sp,-12
8111dd44:	de00012e 	bgeu	sp,et,8111dd4c <_open_r+0xc>
8111dd48:	003b68fa 	trap	3
8111dd4c:	2805883a 	mov	r2,r5
8111dd50:	dc000015 	stw	r16,0(sp)
8111dd54:	04204574 	movhi	r16,33045
8111dd58:	dc400115 	stw	r17,4(sp)
8111dd5c:	300b883a 	mov	r5,r6
8111dd60:	843af104 	addi	r16,r16,-5180
8111dd64:	2023883a 	mov	r17,r4
8111dd68:	380d883a 	mov	r6,r7
8111dd6c:	1009883a 	mov	r4,r2
8111dd70:	dfc00215 	stw	ra,8(sp)
8111dd74:	80000015 	stw	zero,0(r16)
8111dd78:	11337300 	call	81133730 <open>
8111dd7c:	00ffffc4 	movi	r3,-1
8111dd80:	10c00526 	beq	r2,r3,8111dd98 <_open_r+0x58>
8111dd84:	dfc00217 	ldw	ra,8(sp)
8111dd88:	dc400117 	ldw	r17,4(sp)
8111dd8c:	dc000017 	ldw	r16,0(sp)
8111dd90:	dec00304 	addi	sp,sp,12
8111dd94:	f800283a 	ret
8111dd98:	80c00017 	ldw	r3,0(r16)
8111dd9c:	183ff926 	beq	r3,zero,8111dd84 <__reset+0xfb0fdd84>
8111dda0:	88c00015 	stw	r3,0(r17)
8111dda4:	003ff706 	br	8111dd84 <__reset+0xfb0fdd84>

8111dda8 <_printf_r>:
8111dda8:	defffd04 	addi	sp,sp,-12
8111ddac:	2805883a 	mov	r2,r5
8111ddb0:	de00012e 	bgeu	sp,et,8111ddb8 <_printf_r+0x10>
8111ddb4:	003b68fa 	trap	3
8111ddb8:	dfc00015 	stw	ra,0(sp)
8111ddbc:	d9800115 	stw	r6,4(sp)
8111ddc0:	d9c00215 	stw	r7,8(sp)
8111ddc4:	21400217 	ldw	r5,8(r4)
8111ddc8:	d9c00104 	addi	r7,sp,4
8111ddcc:	100d883a 	mov	r6,r2
8111ddd0:	1120ad40 	call	81120ad4 <___vfprintf_internal_r>
8111ddd4:	dfc00017 	ldw	ra,0(sp)
8111ddd8:	dec00304 	addi	sp,sp,12
8111dddc:	f800283a 	ret

8111dde0 <printf>:
8111dde0:	defffc04 	addi	sp,sp,-16
8111dde4:	de00012e 	bgeu	sp,et,8111ddec <printf+0xc>
8111dde8:	003b68fa 	trap	3
8111ddec:	dfc00015 	stw	ra,0(sp)
8111ddf0:	d9400115 	stw	r5,4(sp)
8111ddf4:	d9800215 	stw	r6,8(sp)
8111ddf8:	d9c00315 	stw	r7,12(sp)
8111ddfc:	00a04574 	movhi	r2,33045
8111de00:	10ba8204 	addi	r2,r2,-5624
8111de04:	10800017 	ldw	r2,0(r2)
8111de08:	200b883a 	mov	r5,r4
8111de0c:	d9800104 	addi	r6,sp,4
8111de10:	11000217 	ldw	r4,8(r2)
8111de14:	1122cd40 	call	81122cd4 <__vfprintf_internal>
8111de18:	dfc00017 	ldw	ra,0(sp)
8111de1c:	dec00404 	addi	sp,sp,16
8111de20:	f800283a 	ret

8111de24 <_putc_r>:
8111de24:	defffc04 	addi	sp,sp,-16
8111de28:	de00012e 	bgeu	sp,et,8111de30 <_putc_r+0xc>
8111de2c:	003b68fa 	trap	3
8111de30:	dc000215 	stw	r16,8(sp)
8111de34:	dfc00315 	stw	ra,12(sp)
8111de38:	2021883a 	mov	r16,r4
8111de3c:	20000226 	beq	r4,zero,8111de48 <_putc_r+0x24>
8111de40:	20800e17 	ldw	r2,56(r4)
8111de44:	10001b26 	beq	r2,zero,8111deb4 <_putc_r+0x90>
8111de48:	30800217 	ldw	r2,8(r6)
8111de4c:	10bfffc4 	addi	r2,r2,-1
8111de50:	30800215 	stw	r2,8(r6)
8111de54:	10000a16 	blt	r2,zero,8111de80 <_putc_r+0x5c>
8111de58:	30800017 	ldw	r2,0(r6)
8111de5c:	11400005 	stb	r5,0(r2)
8111de60:	30800017 	ldw	r2,0(r6)
8111de64:	10c00044 	addi	r3,r2,1
8111de68:	30c00015 	stw	r3,0(r6)
8111de6c:	10800003 	ldbu	r2,0(r2)
8111de70:	dfc00317 	ldw	ra,12(sp)
8111de74:	dc000217 	ldw	r16,8(sp)
8111de78:	dec00404 	addi	sp,sp,16
8111de7c:	f800283a 	ret
8111de80:	30c00617 	ldw	r3,24(r6)
8111de84:	10c00616 	blt	r2,r3,8111dea0 <_putc_r+0x7c>
8111de88:	30800017 	ldw	r2,0(r6)
8111de8c:	00c00284 	movi	r3,10
8111de90:	11400005 	stb	r5,0(r2)
8111de94:	30800017 	ldw	r2,0(r6)
8111de98:	11400003 	ldbu	r5,0(r2)
8111de9c:	28fff11e 	bne	r5,r3,8111de64 <__reset+0xfb0fde64>
8111dea0:	8009883a 	mov	r4,r16
8111dea4:	dfc00317 	ldw	ra,12(sp)
8111dea8:	dc000217 	ldw	r16,8(sp)
8111deac:	dec00404 	addi	sp,sp,16
8111deb0:	11246581 	jmpi	81124658 <__swbuf_r>
8111deb4:	d9400015 	stw	r5,0(sp)
8111deb8:	d9800115 	stw	r6,4(sp)
8111debc:	11268900 	call	81126890 <__sinit>
8111dec0:	d9800117 	ldw	r6,4(sp)
8111dec4:	d9400017 	ldw	r5,0(sp)
8111dec8:	003fdf06 	br	8111de48 <__reset+0xfb0fde48>

8111decc <putc>:
8111decc:	00a04574 	movhi	r2,33045
8111ded0:	defffc04 	addi	sp,sp,-16
8111ded4:	10ba8204 	addi	r2,r2,-5624
8111ded8:	de00012e 	bgeu	sp,et,8111dee0 <putc+0x14>
8111dedc:	003b68fa 	trap	3
8111dee0:	dc000115 	stw	r16,4(sp)
8111dee4:	14000017 	ldw	r16,0(r2)
8111dee8:	dc400215 	stw	r17,8(sp)
8111deec:	dfc00315 	stw	ra,12(sp)
8111def0:	2023883a 	mov	r17,r4
8111def4:	80000226 	beq	r16,zero,8111df00 <putc+0x34>
8111def8:	80800e17 	ldw	r2,56(r16)
8111defc:	10001a26 	beq	r2,zero,8111df68 <putc+0x9c>
8111df00:	28800217 	ldw	r2,8(r5)
8111df04:	10bfffc4 	addi	r2,r2,-1
8111df08:	28800215 	stw	r2,8(r5)
8111df0c:	10000b16 	blt	r2,zero,8111df3c <putc+0x70>
8111df10:	28800017 	ldw	r2,0(r5)
8111df14:	14400005 	stb	r17,0(r2)
8111df18:	28800017 	ldw	r2,0(r5)
8111df1c:	10c00044 	addi	r3,r2,1
8111df20:	28c00015 	stw	r3,0(r5)
8111df24:	10800003 	ldbu	r2,0(r2)
8111df28:	dfc00317 	ldw	ra,12(sp)
8111df2c:	dc400217 	ldw	r17,8(sp)
8111df30:	dc000117 	ldw	r16,4(sp)
8111df34:	dec00404 	addi	sp,sp,16
8111df38:	f800283a 	ret
8111df3c:	28c00617 	ldw	r3,24(r5)
8111df40:	10c00e16 	blt	r2,r3,8111df7c <putc+0xb0>
8111df44:	28800017 	ldw	r2,0(r5)
8111df48:	01000284 	movi	r4,10
8111df4c:	14400005 	stb	r17,0(r2)
8111df50:	28800017 	ldw	r2,0(r5)
8111df54:	10c00003 	ldbu	r3,0(r2)
8111df58:	193ff01e 	bne	r3,r4,8111df1c <__reset+0xfb0fdf1c>
8111df5c:	280d883a 	mov	r6,r5
8111df60:	180b883a 	mov	r5,r3
8111df64:	00000706 	br	8111df84 <putc+0xb8>
8111df68:	8009883a 	mov	r4,r16
8111df6c:	d9400015 	stw	r5,0(sp)
8111df70:	11268900 	call	81126890 <__sinit>
8111df74:	d9400017 	ldw	r5,0(sp)
8111df78:	003fe106 	br	8111df00 <__reset+0xfb0fdf00>
8111df7c:	280d883a 	mov	r6,r5
8111df80:	880b883a 	mov	r5,r17
8111df84:	8009883a 	mov	r4,r16
8111df88:	dfc00317 	ldw	ra,12(sp)
8111df8c:	dc400217 	ldw	r17,8(sp)
8111df90:	dc000117 	ldw	r16,4(sp)
8111df94:	dec00404 	addi	sp,sp,16
8111df98:	11246581 	jmpi	81124658 <__swbuf_r>

8111df9c <_puts_r>:
8111df9c:	defff604 	addi	sp,sp,-40
8111dfa0:	de00012e 	bgeu	sp,et,8111dfa8 <_puts_r+0xc>
8111dfa4:	003b68fa 	trap	3
8111dfa8:	dc000715 	stw	r16,28(sp)
8111dfac:	2021883a 	mov	r16,r4
8111dfb0:	2809883a 	mov	r4,r5
8111dfb4:	dc400815 	stw	r17,32(sp)
8111dfb8:	dfc00915 	stw	ra,36(sp)
8111dfbc:	2823883a 	mov	r17,r5
8111dfc0:	111e5bc0 	call	8111e5bc <strlen>
8111dfc4:	10c00044 	addi	r3,r2,1
8111dfc8:	d8800115 	stw	r2,4(sp)
8111dfcc:	00a04574 	movhi	r2,33045
8111dfd0:	10b0a904 	addi	r2,r2,-15708
8111dfd4:	d8800215 	stw	r2,8(sp)
8111dfd8:	00800044 	movi	r2,1
8111dfdc:	d8800315 	stw	r2,12(sp)
8111dfe0:	00800084 	movi	r2,2
8111dfe4:	dc400015 	stw	r17,0(sp)
8111dfe8:	d8c00615 	stw	r3,24(sp)
8111dfec:	dec00415 	stw	sp,16(sp)
8111dff0:	d8800515 	stw	r2,20(sp)
8111dff4:	80000226 	beq	r16,zero,8111e000 <_puts_r+0x64>
8111dff8:	80800e17 	ldw	r2,56(r16)
8111dffc:	10001426 	beq	r2,zero,8111e050 <_puts_r+0xb4>
8111e000:	81400217 	ldw	r5,8(r16)
8111e004:	2880030b 	ldhu	r2,12(r5)
8111e008:	10c8000c 	andi	r3,r2,8192
8111e00c:	1800061e 	bne	r3,zero,8111e028 <_puts_r+0x8c>
8111e010:	29001917 	ldw	r4,100(r5)
8111e014:	00f7ffc4 	movi	r3,-8193
8111e018:	10880014 	ori	r2,r2,8192
8111e01c:	20c6703a 	and	r3,r4,r3
8111e020:	2880030d 	sth	r2,12(r5)
8111e024:	28c01915 	stw	r3,100(r5)
8111e028:	d9800404 	addi	r6,sp,16
8111e02c:	8009883a 	mov	r4,r16
8111e030:	11270400 	call	81127040 <__sfvwrite_r>
8111e034:	1000091e 	bne	r2,zero,8111e05c <_puts_r+0xc0>
8111e038:	00800284 	movi	r2,10
8111e03c:	dfc00917 	ldw	ra,36(sp)
8111e040:	dc400817 	ldw	r17,32(sp)
8111e044:	dc000717 	ldw	r16,28(sp)
8111e048:	dec00a04 	addi	sp,sp,40
8111e04c:	f800283a 	ret
8111e050:	8009883a 	mov	r4,r16
8111e054:	11268900 	call	81126890 <__sinit>
8111e058:	003fe906 	br	8111e000 <__reset+0xfb0fe000>
8111e05c:	00bfffc4 	movi	r2,-1
8111e060:	003ff606 	br	8111e03c <__reset+0xfb0fe03c>

8111e064 <puts>:
8111e064:	00a04574 	movhi	r2,33045
8111e068:	10ba8204 	addi	r2,r2,-5624
8111e06c:	200b883a 	mov	r5,r4
8111e070:	11000017 	ldw	r4,0(r2)
8111e074:	111df9c1 	jmpi	8111df9c <_puts_r>

8111e078 <lflush>:
8111e078:	2080030b 	ldhu	r2,12(r4)
8111e07c:	00c00244 	movi	r3,9
8111e080:	1080024c 	andi	r2,r2,9
8111e084:	10c00226 	beq	r2,r3,8111e090 <lflush+0x18>
8111e088:	0005883a 	mov	r2,zero
8111e08c:	f800283a 	ret
8111e090:	11264f81 	jmpi	811264f8 <fflush>

8111e094 <__srefill_r>:
8111e094:	defffc04 	addi	sp,sp,-16
8111e098:	de00012e 	bgeu	sp,et,8111e0a0 <__srefill_r+0xc>
8111e09c:	003b68fa 	trap	3
8111e0a0:	dc400115 	stw	r17,4(sp)
8111e0a4:	dc000015 	stw	r16,0(sp)
8111e0a8:	dfc00315 	stw	ra,12(sp)
8111e0ac:	dc800215 	stw	r18,8(sp)
8111e0b0:	2023883a 	mov	r17,r4
8111e0b4:	2821883a 	mov	r16,r5
8111e0b8:	20000226 	beq	r4,zero,8111e0c4 <__srefill_r+0x30>
8111e0bc:	20800e17 	ldw	r2,56(r4)
8111e0c0:	10003c26 	beq	r2,zero,8111e1b4 <__srefill_r+0x120>
8111e0c4:	80c0030b 	ldhu	r3,12(r16)
8111e0c8:	1908000c 	andi	r4,r3,8192
8111e0cc:	1805883a 	mov	r2,r3
8111e0d0:	2000071e 	bne	r4,zero,8111e0f0 <__srefill_r+0x5c>
8111e0d4:	81001917 	ldw	r4,100(r16)
8111e0d8:	18880014 	ori	r2,r3,8192
8111e0dc:	00f7ffc4 	movi	r3,-8193
8111e0e0:	20c8703a 	and	r4,r4,r3
8111e0e4:	8080030d 	sth	r2,12(r16)
8111e0e8:	1007883a 	mov	r3,r2
8111e0ec:	81001915 	stw	r4,100(r16)
8111e0f0:	80000115 	stw	zero,4(r16)
8111e0f4:	1100080c 	andi	r4,r2,32
8111e0f8:	2000571e 	bne	r4,zero,8111e258 <__srefill_r+0x1c4>
8111e0fc:	1100010c 	andi	r4,r2,4
8111e100:	20001f26 	beq	r4,zero,8111e180 <__srefill_r+0xec>
8111e104:	81400c17 	ldw	r5,48(r16)
8111e108:	28000826 	beq	r5,zero,8111e12c <__srefill_r+0x98>
8111e10c:	80801004 	addi	r2,r16,64
8111e110:	28800226 	beq	r5,r2,8111e11c <__srefill_r+0x88>
8111e114:	8809883a 	mov	r4,r17
8111e118:	1126d280 	call	81126d28 <_free_r>
8111e11c:	80800f17 	ldw	r2,60(r16)
8111e120:	80000c15 	stw	zero,48(r16)
8111e124:	80800115 	stw	r2,4(r16)
8111e128:	1000391e 	bne	r2,zero,8111e210 <__srefill_r+0x17c>
8111e12c:	80800417 	ldw	r2,16(r16)
8111e130:	10004b26 	beq	r2,zero,8111e260 <__srefill_r+0x1cc>
8111e134:	8480030b 	ldhu	r18,12(r16)
8111e138:	908000cc 	andi	r2,r18,3
8111e13c:	10001f1e 	bne	r2,zero,8111e1bc <__srefill_r+0x128>
8111e140:	81800417 	ldw	r6,16(r16)
8111e144:	80800817 	ldw	r2,32(r16)
8111e148:	81c00517 	ldw	r7,20(r16)
8111e14c:	81400717 	ldw	r5,28(r16)
8111e150:	81800015 	stw	r6,0(r16)
8111e154:	8809883a 	mov	r4,r17
8111e158:	103ee83a 	callr	r2
8111e15c:	80800115 	stw	r2,4(r16)
8111e160:	00800e0e 	bge	zero,r2,8111e19c <__srefill_r+0x108>
8111e164:	0005883a 	mov	r2,zero
8111e168:	dfc00317 	ldw	ra,12(sp)
8111e16c:	dc800217 	ldw	r18,8(sp)
8111e170:	dc400117 	ldw	r17,4(sp)
8111e174:	dc000017 	ldw	r16,0(sp)
8111e178:	dec00404 	addi	sp,sp,16
8111e17c:	f800283a 	ret
8111e180:	1100040c 	andi	r4,r2,16
8111e184:	20003026 	beq	r4,zero,8111e248 <__srefill_r+0x1b4>
8111e188:	1080020c 	andi	r2,r2,8
8111e18c:	1000241e 	bne	r2,zero,8111e220 <__srefill_r+0x18c>
8111e190:	18c00114 	ori	r3,r3,4
8111e194:	80c0030d 	sth	r3,12(r16)
8111e198:	003fe406 	br	8111e12c <__reset+0xfb0fe12c>
8111e19c:	80c0030b 	ldhu	r3,12(r16)
8111e1a0:	1000161e 	bne	r2,zero,8111e1fc <__srefill_r+0x168>
8111e1a4:	18c00814 	ori	r3,r3,32
8111e1a8:	00bfffc4 	movi	r2,-1
8111e1ac:	80c0030d 	sth	r3,12(r16)
8111e1b0:	003fed06 	br	8111e168 <__reset+0xfb0fe168>
8111e1b4:	11268900 	call	81126890 <__sinit>
8111e1b8:	003fc206 	br	8111e0c4 <__reset+0xfb0fe0c4>
8111e1bc:	00a04574 	movhi	r2,33045
8111e1c0:	10ba8104 	addi	r2,r2,-5628
8111e1c4:	11000017 	ldw	r4,0(r2)
8111e1c8:	016044b4 	movhi	r5,33042
8111e1cc:	00800044 	movi	r2,1
8111e1d0:	29781e04 	addi	r5,r5,-8072
8111e1d4:	8080030d 	sth	r2,12(r16)
8111e1d8:	11275040 	call	81127504 <_fwalk>
8111e1dc:	00800244 	movi	r2,9
8111e1e0:	8480030d 	sth	r18,12(r16)
8111e1e4:	9480024c 	andi	r18,r18,9
8111e1e8:	90bfd51e 	bne	r18,r2,8111e140 <__reset+0xfb0fe140>
8111e1ec:	800b883a 	mov	r5,r16
8111e1f0:	8809883a 	mov	r4,r17
8111e1f4:	11262700 	call	81126270 <__sflush_r>
8111e1f8:	003fd106 	br	8111e140 <__reset+0xfb0fe140>
8111e1fc:	18c01014 	ori	r3,r3,64
8111e200:	80000115 	stw	zero,4(r16)
8111e204:	00bfffc4 	movi	r2,-1
8111e208:	80c0030d 	sth	r3,12(r16)
8111e20c:	003fd606 	br	8111e168 <__reset+0xfb0fe168>
8111e210:	80c00e17 	ldw	r3,56(r16)
8111e214:	0005883a 	mov	r2,zero
8111e218:	80c00015 	stw	r3,0(r16)
8111e21c:	003fd206 	br	8111e168 <__reset+0xfb0fe168>
8111e220:	800b883a 	mov	r5,r16
8111e224:	8809883a 	mov	r4,r17
8111e228:	11264940 	call	81126494 <_fflush_r>
8111e22c:	10000a1e 	bne	r2,zero,8111e258 <__srefill_r+0x1c4>
8111e230:	8080030b 	ldhu	r2,12(r16)
8111e234:	00fffdc4 	movi	r3,-9
8111e238:	80000215 	stw	zero,8(r16)
8111e23c:	1886703a 	and	r3,r3,r2
8111e240:	80000615 	stw	zero,24(r16)
8111e244:	003fd206 	br	8111e190 <__reset+0xfb0fe190>
8111e248:	00800244 	movi	r2,9
8111e24c:	88800015 	stw	r2,0(r17)
8111e250:	18c01014 	ori	r3,r3,64
8111e254:	80c0030d 	sth	r3,12(r16)
8111e258:	00bfffc4 	movi	r2,-1
8111e25c:	003fc206 	br	8111e168 <__reset+0xfb0fe168>
8111e260:	800b883a 	mov	r5,r16
8111e264:	8809883a 	mov	r4,r17
8111e268:	111d0f00 	call	8111d0f0 <__smakebuf_r>
8111e26c:	003fb106 	br	8111e134 <__reset+0xfb0fe134>

8111e270 <_sbrk_r>:
8111e270:	defffd04 	addi	sp,sp,-12
8111e274:	de00012e 	bgeu	sp,et,8111e27c <_sbrk_r+0xc>
8111e278:	003b68fa 	trap	3
8111e27c:	dc000015 	stw	r16,0(sp)
8111e280:	04204574 	movhi	r16,33045
8111e284:	dc400115 	stw	r17,4(sp)
8111e288:	843af104 	addi	r16,r16,-5180
8111e28c:	2023883a 	mov	r17,r4
8111e290:	2809883a 	mov	r4,r5
8111e294:	dfc00215 	stw	ra,8(sp)
8111e298:	80000015 	stw	zero,0(r16)
8111e29c:	1133a400 	call	81133a40 <sbrk>
8111e2a0:	00ffffc4 	movi	r3,-1
8111e2a4:	10c00526 	beq	r2,r3,8111e2bc <_sbrk_r+0x4c>
8111e2a8:	dfc00217 	ldw	ra,8(sp)
8111e2ac:	dc400117 	ldw	r17,4(sp)
8111e2b0:	dc000017 	ldw	r16,0(sp)
8111e2b4:	dec00304 	addi	sp,sp,12
8111e2b8:	f800283a 	ret
8111e2bc:	80c00017 	ldw	r3,0(r16)
8111e2c0:	183ff926 	beq	r3,zero,8111e2a8 <__reset+0xfb0fe2a8>
8111e2c4:	88c00015 	stw	r3,0(r17)
8111e2c8:	003ff706 	br	8111e2a8 <__reset+0xfb0fe2a8>

8111e2cc <scanf>:
8111e2cc:	defffc04 	addi	sp,sp,-16
8111e2d0:	de00012e 	bgeu	sp,et,8111e2d8 <scanf+0xc>
8111e2d4:	003b68fa 	trap	3
8111e2d8:	dfc00015 	stw	ra,0(sp)
8111e2dc:	d9400115 	stw	r5,4(sp)
8111e2e0:	d9800215 	stw	r6,8(sp)
8111e2e4:	d9c00315 	stw	r7,12(sp)
8111e2e8:	00a04574 	movhi	r2,33045
8111e2ec:	10ba8204 	addi	r2,r2,-5624
8111e2f0:	200d883a 	mov	r6,r4
8111e2f4:	11000017 	ldw	r4,0(r2)
8111e2f8:	d9c00104 	addi	r7,sp,4
8111e2fc:	21400117 	ldw	r5,4(r4)
8111e300:	11246040 	call	81124604 <_vfscanf_r>
8111e304:	dfc00017 	ldw	ra,0(sp)
8111e308:	dec00404 	addi	sp,sp,16
8111e30c:	f800283a 	ret

8111e310 <_scanf_r>:
8111e310:	defffd04 	addi	sp,sp,-12
8111e314:	2805883a 	mov	r2,r5
8111e318:	de00012e 	bgeu	sp,et,8111e320 <_scanf_r+0x10>
8111e31c:	003b68fa 	trap	3
8111e320:	dfc00015 	stw	ra,0(sp)
8111e324:	d9800115 	stw	r6,4(sp)
8111e328:	d9c00215 	stw	r7,8(sp)
8111e32c:	21400117 	ldw	r5,4(r4)
8111e330:	d9c00104 	addi	r7,sp,4
8111e334:	100d883a 	mov	r6,r2
8111e338:	11246040 	call	81124604 <_vfscanf_r>
8111e33c:	dfc00017 	ldw	ra,0(sp)
8111e340:	dec00304 	addi	sp,sp,12
8111e344:	f800283a 	ret

8111e348 <_sprintf_r>:
8111e348:	deffe404 	addi	sp,sp,-112
8111e34c:	2807883a 	mov	r3,r5
8111e350:	de00012e 	bgeu	sp,et,8111e358 <_sprintf_r+0x10>
8111e354:	003b68fa 	trap	3
8111e358:	dfc01a15 	stw	ra,104(sp)
8111e35c:	d9c01b15 	stw	r7,108(sp)
8111e360:	00a00034 	movhi	r2,32768
8111e364:	10bfffc4 	addi	r2,r2,-1
8111e368:	02008204 	movi	r8,520
8111e36c:	d8800215 	stw	r2,8(sp)
8111e370:	d8800515 	stw	r2,20(sp)
8111e374:	d9c01b04 	addi	r7,sp,108
8111e378:	d80b883a 	mov	r5,sp
8111e37c:	00bfffc4 	movi	r2,-1
8111e380:	d8c00015 	stw	r3,0(sp)
8111e384:	d8c00415 	stw	r3,16(sp)
8111e388:	da00030d 	sth	r8,12(sp)
8111e38c:	d880038d 	sth	r2,14(sp)
8111e390:	111e8f40 	call	8111e8f4 <___svfprintf_internal_r>
8111e394:	d8c00017 	ldw	r3,0(sp)
8111e398:	18000005 	stb	zero,0(r3)
8111e39c:	dfc01a17 	ldw	ra,104(sp)
8111e3a0:	dec01c04 	addi	sp,sp,112
8111e3a4:	f800283a 	ret

8111e3a8 <sprintf>:
8111e3a8:	deffe304 	addi	sp,sp,-116
8111e3ac:	2007883a 	mov	r3,r4
8111e3b0:	de00012e 	bgeu	sp,et,8111e3b8 <sprintf+0x10>
8111e3b4:	003b68fa 	trap	3
8111e3b8:	dfc01a15 	stw	ra,104(sp)
8111e3bc:	d9801b15 	stw	r6,108(sp)
8111e3c0:	d9c01c15 	stw	r7,112(sp)
8111e3c4:	01204574 	movhi	r4,33045
8111e3c8:	213a8204 	addi	r4,r4,-5624
8111e3cc:	21000017 	ldw	r4,0(r4)
8111e3d0:	00a00034 	movhi	r2,32768
8111e3d4:	10bfffc4 	addi	r2,r2,-1
8111e3d8:	280d883a 	mov	r6,r5
8111e3dc:	02008204 	movi	r8,520
8111e3e0:	d8800215 	stw	r2,8(sp)
8111e3e4:	d8800515 	stw	r2,20(sp)
8111e3e8:	d9c01b04 	addi	r7,sp,108
8111e3ec:	d80b883a 	mov	r5,sp
8111e3f0:	00bfffc4 	movi	r2,-1
8111e3f4:	d8c00015 	stw	r3,0(sp)
8111e3f8:	d8c00415 	stw	r3,16(sp)
8111e3fc:	da00030d 	sth	r8,12(sp)
8111e400:	d880038d 	sth	r2,14(sp)
8111e404:	111e8f40 	call	8111e8f4 <___svfprintf_internal_r>
8111e408:	d8c00017 	ldw	r3,0(sp)
8111e40c:	18000005 	stb	zero,0(r3)
8111e410:	dfc01a17 	ldw	ra,104(sp)
8111e414:	dec01d04 	addi	sp,sp,116
8111e418:	f800283a 	ret

8111e41c <__sread>:
8111e41c:	defffe04 	addi	sp,sp,-8
8111e420:	de00012e 	bgeu	sp,et,8111e428 <__sread+0xc>
8111e424:	003b68fa 	trap	3
8111e428:	dc000015 	stw	r16,0(sp)
8111e42c:	2821883a 	mov	r16,r5
8111e430:	2940038f 	ldh	r5,14(r5)
8111e434:	dfc00115 	stw	ra,4(sp)
8111e438:	1128d540 	call	81128d54 <_read_r>
8111e43c:	10000716 	blt	r2,zero,8111e45c <__sread+0x40>
8111e440:	80c01417 	ldw	r3,80(r16)
8111e444:	1887883a 	add	r3,r3,r2
8111e448:	80c01415 	stw	r3,80(r16)
8111e44c:	dfc00117 	ldw	ra,4(sp)
8111e450:	dc000017 	ldw	r16,0(sp)
8111e454:	dec00204 	addi	sp,sp,8
8111e458:	f800283a 	ret
8111e45c:	80c0030b 	ldhu	r3,12(r16)
8111e460:	18fbffcc 	andi	r3,r3,61439
8111e464:	80c0030d 	sth	r3,12(r16)
8111e468:	dfc00117 	ldw	ra,4(sp)
8111e46c:	dc000017 	ldw	r16,0(sp)
8111e470:	dec00204 	addi	sp,sp,8
8111e474:	f800283a 	ret

8111e478 <__seofread>:
8111e478:	0005883a 	mov	r2,zero
8111e47c:	f800283a 	ret

8111e480 <__swrite>:
8111e480:	defffb04 	addi	sp,sp,-20
8111e484:	de00012e 	bgeu	sp,et,8111e48c <__swrite+0xc>
8111e488:	003b68fa 	trap	3
8111e48c:	2880030b 	ldhu	r2,12(r5)
8111e490:	dcc00315 	stw	r19,12(sp)
8111e494:	dc800215 	stw	r18,8(sp)
8111e498:	dc400115 	stw	r17,4(sp)
8111e49c:	dc000015 	stw	r16,0(sp)
8111e4a0:	dfc00415 	stw	ra,16(sp)
8111e4a4:	10c0400c 	andi	r3,r2,256
8111e4a8:	2821883a 	mov	r16,r5
8111e4ac:	2023883a 	mov	r17,r4
8111e4b0:	3025883a 	mov	r18,r6
8111e4b4:	3827883a 	mov	r19,r7
8111e4b8:	18000526 	beq	r3,zero,8111e4d0 <__swrite+0x50>
8111e4bc:	2940038f 	ldh	r5,14(r5)
8111e4c0:	01c00084 	movi	r7,2
8111e4c4:	000d883a 	mov	r6,zero
8111e4c8:	112780c0 	call	8112780c <_lseek_r>
8111e4cc:	8080030b 	ldhu	r2,12(r16)
8111e4d0:	8140038f 	ldh	r5,14(r16)
8111e4d4:	10bbffcc 	andi	r2,r2,61439
8111e4d8:	980f883a 	mov	r7,r19
8111e4dc:	900d883a 	mov	r6,r18
8111e4e0:	8809883a 	mov	r4,r17
8111e4e4:	8080030d 	sth	r2,12(r16)
8111e4e8:	dfc00417 	ldw	ra,16(sp)
8111e4ec:	dcc00317 	ldw	r19,12(sp)
8111e4f0:	dc800217 	ldw	r18,8(sp)
8111e4f4:	dc400117 	ldw	r17,4(sp)
8111e4f8:	dc000017 	ldw	r16,0(sp)
8111e4fc:	dec00504 	addi	sp,sp,20
8111e500:	11247b81 	jmpi	811247b8 <_write_r>

8111e504 <__sseek>:
8111e504:	defffe04 	addi	sp,sp,-8
8111e508:	de00012e 	bgeu	sp,et,8111e510 <__sseek+0xc>
8111e50c:	003b68fa 	trap	3
8111e510:	dc000015 	stw	r16,0(sp)
8111e514:	2821883a 	mov	r16,r5
8111e518:	2940038f 	ldh	r5,14(r5)
8111e51c:	dfc00115 	stw	ra,4(sp)
8111e520:	112780c0 	call	8112780c <_lseek_r>
8111e524:	00ffffc4 	movi	r3,-1
8111e528:	10c00826 	beq	r2,r3,8111e54c <__sseek+0x48>
8111e52c:	80c0030b 	ldhu	r3,12(r16)
8111e530:	80801415 	stw	r2,80(r16)
8111e534:	18c40014 	ori	r3,r3,4096
8111e538:	80c0030d 	sth	r3,12(r16)
8111e53c:	dfc00117 	ldw	ra,4(sp)
8111e540:	dc000017 	ldw	r16,0(sp)
8111e544:	dec00204 	addi	sp,sp,8
8111e548:	f800283a 	ret
8111e54c:	80c0030b 	ldhu	r3,12(r16)
8111e550:	18fbffcc 	andi	r3,r3,61439
8111e554:	80c0030d 	sth	r3,12(r16)
8111e558:	dfc00117 	ldw	ra,4(sp)
8111e55c:	dc000017 	ldw	r16,0(sp)
8111e560:	dec00204 	addi	sp,sp,8
8111e564:	f800283a 	ret

8111e568 <__sclose>:
8111e568:	2940038f 	ldh	r5,14(r5)
8111e56c:	112497c1 	jmpi	8112497c <_close_r>

8111e570 <strcspn>:
8111e570:	21c00007 	ldb	r7,0(r4)
8111e574:	38000f26 	beq	r7,zero,8111e5b4 <strcspn+0x44>
8111e578:	2a000007 	ldb	r8,0(r5)
8111e57c:	2005883a 	mov	r2,r4
8111e580:	40000726 	beq	r8,zero,8111e5a0 <strcspn+0x30>
8111e584:	3a000926 	beq	r7,r8,8111e5ac <strcspn+0x3c>
8111e588:	2807883a 	mov	r3,r5
8111e58c:	00000106 	br	8111e594 <strcspn+0x24>
8111e590:	31c00626 	beq	r6,r7,8111e5ac <strcspn+0x3c>
8111e594:	18c00044 	addi	r3,r3,1
8111e598:	19800007 	ldb	r6,0(r3)
8111e59c:	303ffc1e 	bne	r6,zero,8111e590 <__reset+0xfb0fe590>
8111e5a0:	10800044 	addi	r2,r2,1
8111e5a4:	11c00007 	ldb	r7,0(r2)
8111e5a8:	383ff51e 	bne	r7,zero,8111e580 <__reset+0xfb0fe580>
8111e5ac:	1105c83a 	sub	r2,r2,r4
8111e5b0:	f800283a 	ret
8111e5b4:	0005883a 	mov	r2,zero
8111e5b8:	f800283a 	ret

8111e5bc <strlen>:
8111e5bc:	208000cc 	andi	r2,r4,3
8111e5c0:	10002026 	beq	r2,zero,8111e644 <strlen+0x88>
8111e5c4:	20800007 	ldb	r2,0(r4)
8111e5c8:	10002026 	beq	r2,zero,8111e64c <strlen+0x90>
8111e5cc:	2005883a 	mov	r2,r4
8111e5d0:	00000206 	br	8111e5dc <strlen+0x20>
8111e5d4:	10c00007 	ldb	r3,0(r2)
8111e5d8:	18001826 	beq	r3,zero,8111e63c <strlen+0x80>
8111e5dc:	10800044 	addi	r2,r2,1
8111e5e0:	10c000cc 	andi	r3,r2,3
8111e5e4:	183ffb1e 	bne	r3,zero,8111e5d4 <__reset+0xfb0fe5d4>
8111e5e8:	10c00017 	ldw	r3,0(r2)
8111e5ec:	01ffbff4 	movhi	r7,65279
8111e5f0:	39ffbfc4 	addi	r7,r7,-257
8111e5f4:	00ca303a 	nor	r5,zero,r3
8111e5f8:	01a02074 	movhi	r6,32897
8111e5fc:	19c7883a 	add	r3,r3,r7
8111e600:	31a02004 	addi	r6,r6,-32640
8111e604:	1946703a 	and	r3,r3,r5
8111e608:	1986703a 	and	r3,r3,r6
8111e60c:	1800091e 	bne	r3,zero,8111e634 <strlen+0x78>
8111e610:	10800104 	addi	r2,r2,4
8111e614:	10c00017 	ldw	r3,0(r2)
8111e618:	19cb883a 	add	r5,r3,r7
8111e61c:	00c6303a 	nor	r3,zero,r3
8111e620:	28c6703a 	and	r3,r5,r3
8111e624:	1986703a 	and	r3,r3,r6
8111e628:	183ff926 	beq	r3,zero,8111e610 <__reset+0xfb0fe610>
8111e62c:	00000106 	br	8111e634 <strlen+0x78>
8111e630:	10800044 	addi	r2,r2,1
8111e634:	10c00007 	ldb	r3,0(r2)
8111e638:	183ffd1e 	bne	r3,zero,8111e630 <__reset+0xfb0fe630>
8111e63c:	1105c83a 	sub	r2,r2,r4
8111e640:	f800283a 	ret
8111e644:	2005883a 	mov	r2,r4
8111e648:	003fe706 	br	8111e5e8 <__reset+0xfb0fe5e8>
8111e64c:	0005883a 	mov	r2,zero
8111e650:	f800283a 	ret

8111e654 <strnlen>:
8111e654:	28000e26 	beq	r5,zero,8111e690 <strnlen+0x3c>
8111e658:	20800007 	ldb	r2,0(r4)
8111e65c:	10000c26 	beq	r2,zero,8111e690 <strnlen+0x3c>
8111e660:	20c00044 	addi	r3,r4,1
8111e664:	214b883a 	add	r5,r4,r5
8111e668:	28c00526 	beq	r5,r3,8111e680 <strnlen+0x2c>
8111e66c:	19800007 	ldb	r6,0(r3)
8111e670:	19c00044 	addi	r7,r3,1
8111e674:	30000426 	beq	r6,zero,8111e688 <strnlen+0x34>
8111e678:	3807883a 	mov	r3,r7
8111e67c:	28fffb1e 	bne	r5,r3,8111e66c <__reset+0xfb0fe66c>
8111e680:	2905c83a 	sub	r2,r5,r4
8111e684:	f800283a 	ret
8111e688:	1905c83a 	sub	r2,r3,r4
8111e68c:	f800283a 	ret
8111e690:	0005883a 	mov	r2,zero
8111e694:	f800283a 	ret

8111e698 <_strtol_r>:
8111e698:	00a04574 	movhi	r2,33045
8111e69c:	defff404 	addi	sp,sp,-48
8111e6a0:	10ba8004 	addi	r2,r2,-5632
8111e6a4:	de00012e 	bgeu	sp,et,8111e6ac <_strtol_r+0x14>
8111e6a8:	003b68fa 	trap	3
8111e6ac:	dd400715 	stw	r21,28(sp)
8111e6b0:	15400017 	ldw	r21,0(r2)
8111e6b4:	dd800815 	stw	r22,32(sp)
8111e6b8:	dd000615 	stw	r20,24(sp)
8111e6bc:	dcc00515 	stw	r19,20(sp)
8111e6c0:	d9000015 	stw	r4,0(sp)
8111e6c4:	dfc00b15 	stw	ra,44(sp)
8111e6c8:	df000a15 	stw	fp,40(sp)
8111e6cc:	ddc00915 	stw	r23,36(sp)
8111e6d0:	dc800415 	stw	r18,16(sp)
8111e6d4:	dc400315 	stw	r17,12(sp)
8111e6d8:	dc000215 	stw	r16,8(sp)
8111e6dc:	2829883a 	mov	r20,r5
8111e6e0:	3027883a 	mov	r19,r6
8111e6e4:	382d883a 	mov	r22,r7
8111e6e8:	2809883a 	mov	r4,r5
8111e6ec:	24000003 	ldbu	r16,0(r4)
8111e6f0:	24400044 	addi	r17,r4,1
8111e6f4:	2007883a 	mov	r3,r4
8111e6f8:	ac05883a 	add	r2,r21,r16
8111e6fc:	10800043 	ldbu	r2,1(r2)
8111e700:	8809883a 	mov	r4,r17
8111e704:	1080020c 	andi	r2,r2,8
8111e708:	103ff81e 	bne	r2,zero,8111e6ec <__reset+0xfb0fe6ec>
8111e70c:	00800b44 	movi	r2,45
8111e710:	80805826 	beq	r16,r2,8111e874 <_strtol_r+0x1dc>
8111e714:	00800ac4 	movi	r2,43
8111e718:	80805a26 	beq	r16,r2,8111e884 <_strtol_r+0x1ec>
8111e71c:	0039883a 	mov	fp,zero
8111e720:	b0004426 	beq	r22,zero,8111e834 <_strtol_r+0x19c>
8111e724:	00800404 	movi	r2,16
8111e728:	b0806026 	beq	r22,r2,8111e8ac <_strtol_r+0x214>
8111e72c:	b02f883a 	mov	r23,r22
8111e730:	00a00034 	movhi	r2,32768
8111e734:	e025003a 	cmpeq	r18,fp,zero
8111e738:	14a5c83a 	sub	r18,r2,r18
8111e73c:	b80b883a 	mov	r5,r23
8111e740:	9009883a 	mov	r4,r18
8111e744:	11301140 	call	81130114 <__umodsi3>
8111e748:	b80b883a 	mov	r5,r23
8111e74c:	9009883a 	mov	r4,r18
8111e750:	d8800115 	stw	r2,4(sp)
8111e754:	11300b00 	call	811300b0 <__udivsi3>
8111e758:	ac07883a 	add	r3,r21,r16
8111e75c:	18c00043 	ldbu	r3,1(r3)
8111e760:	880b883a 	mov	r5,r17
8111e764:	000d883a 	mov	r6,zero
8111e768:	1a00010c 	andi	r8,r3,4
8111e76c:	0009883a 	mov	r4,zero
8111e770:	02800044 	movi	r10,1
8111e774:	027fffc4 	movi	r9,-1
8111e778:	d9c00117 	ldw	r7,4(sp)
8111e77c:	40000e26 	beq	r8,zero,8111e7b8 <_strtol_r+0x120>
8111e780:	843ff404 	addi	r16,r16,-48
8111e784:	8580120e 	bge	r16,r22,8111e7d0 <_strtol_r+0x138>
8111e788:	32400526 	beq	r6,r9,8111e7a0 <_strtol_r+0x108>
8111e78c:	11002536 	bltu	r2,r4,8111e824 <_strtol_r+0x18c>
8111e790:	20802326 	beq	r4,r2,8111e820 <_strtol_r+0x188>
8111e794:	25c9383a 	mul	r4,r4,r23
8111e798:	01800044 	movi	r6,1
8111e79c:	8109883a 	add	r4,r16,r4
8111e7a0:	2c000003 	ldbu	r16,0(r5)
8111e7a4:	29400044 	addi	r5,r5,1
8111e7a8:	ac07883a 	add	r3,r21,r16
8111e7ac:	18c00043 	ldbu	r3,1(r3)
8111e7b0:	1a00010c 	andi	r8,r3,4
8111e7b4:	403ff21e 	bne	r8,zero,8111e780 <__reset+0xfb0fe780>
8111e7b8:	18c000cc 	andi	r3,r3,3
8111e7bc:	18000426 	beq	r3,zero,8111e7d0 <_strtol_r+0x138>
8111e7c0:	1a801a26 	beq	r3,r10,8111e82c <_strtol_r+0x194>
8111e7c4:	00c015c4 	movi	r3,87
8111e7c8:	80e1c83a 	sub	r16,r16,r3
8111e7cc:	85bfee16 	blt	r16,r22,8111e788 <__reset+0xfb0fe788>
8111e7d0:	00bfffc4 	movi	r2,-1
8111e7d4:	30801e26 	beq	r6,r2,8111e850 <_strtol_r+0x1b8>
8111e7d8:	e0001b1e 	bne	fp,zero,8111e848 <_strtol_r+0x1b0>
8111e7dc:	2005883a 	mov	r2,r4
8111e7e0:	98000326 	beq	r19,zero,8111e7f0 <_strtol_r+0x158>
8111e7e4:	3000211e 	bne	r6,zero,8111e86c <_strtol_r+0x1d4>
8111e7e8:	a00b883a 	mov	r5,r20
8111e7ec:	99400015 	stw	r5,0(r19)
8111e7f0:	dfc00b17 	ldw	ra,44(sp)
8111e7f4:	df000a17 	ldw	fp,40(sp)
8111e7f8:	ddc00917 	ldw	r23,36(sp)
8111e7fc:	dd800817 	ldw	r22,32(sp)
8111e800:	dd400717 	ldw	r21,28(sp)
8111e804:	dd000617 	ldw	r20,24(sp)
8111e808:	dcc00517 	ldw	r19,20(sp)
8111e80c:	dc800417 	ldw	r18,16(sp)
8111e810:	dc400317 	ldw	r17,12(sp)
8111e814:	dc000217 	ldw	r16,8(sp)
8111e818:	dec00c04 	addi	sp,sp,48
8111e81c:	f800283a 	ret
8111e820:	3c3fdc0e 	bge	r7,r16,8111e794 <__reset+0xfb0fe794>
8111e824:	01bfffc4 	movi	r6,-1
8111e828:	003fdd06 	br	8111e7a0 <__reset+0xfb0fe7a0>
8111e82c:	00c00dc4 	movi	r3,55
8111e830:	003fe506 	br	8111e7c8 <__reset+0xfb0fe7c8>
8111e834:	00800c04 	movi	r2,48
8111e838:	80801626 	beq	r16,r2,8111e894 <_strtol_r+0x1fc>
8111e83c:	05800284 	movi	r22,10
8111e840:	b02f883a 	mov	r23,r22
8111e844:	003fba06 	br	8111e730 <__reset+0xfb0fe730>
8111e848:	0109c83a 	sub	r4,zero,r4
8111e84c:	003fe306 	br	8111e7dc <__reset+0xfb0fe7dc>
8111e850:	d9000017 	ldw	r4,0(sp)
8111e854:	00c00884 	movi	r3,34
8111e858:	e005003a 	cmpeq	r2,fp,zero
8111e85c:	20c00015 	stw	r3,0(r4)
8111e860:	00e00034 	movhi	r3,32768
8111e864:	1885c83a 	sub	r2,r3,r2
8111e868:	983fe126 	beq	r19,zero,8111e7f0 <__reset+0xfb0fe7f0>
8111e86c:	297fffc4 	addi	r5,r5,-1
8111e870:	003fde06 	br	8111e7ec <__reset+0xfb0fe7ec>
8111e874:	1c400084 	addi	r17,r3,2
8111e878:	1c000043 	ldbu	r16,1(r3)
8111e87c:	07000044 	movi	fp,1
8111e880:	003fa706 	br	8111e720 <__reset+0xfb0fe720>
8111e884:	1c400084 	addi	r17,r3,2
8111e888:	1c000043 	ldbu	r16,1(r3)
8111e88c:	0039883a 	mov	fp,zero
8111e890:	003fa306 	br	8111e720 <__reset+0xfb0fe720>
8111e894:	88800003 	ldbu	r2,0(r17)
8111e898:	00c01604 	movi	r3,88
8111e89c:	108037cc 	andi	r2,r2,223
8111e8a0:	10c00826 	beq	r2,r3,8111e8c4 <_strtol_r+0x22c>
8111e8a4:	05800204 	movi	r22,8
8111e8a8:	003fa006 	br	8111e72c <__reset+0xfb0fe72c>
8111e8ac:	00800c04 	movi	r2,48
8111e8b0:	80bf9e1e 	bne	r16,r2,8111e72c <__reset+0xfb0fe72c>
8111e8b4:	88800003 	ldbu	r2,0(r17)
8111e8b8:	00c01604 	movi	r3,88
8111e8bc:	108037cc 	andi	r2,r2,223
8111e8c0:	10ff9a1e 	bne	r2,r3,8111e72c <__reset+0xfb0fe72c>
8111e8c4:	05c00404 	movi	r23,16
8111e8c8:	8c000043 	ldbu	r16,1(r17)
8111e8cc:	b82d883a 	mov	r22,r23
8111e8d0:	8c400084 	addi	r17,r17,2
8111e8d4:	003f9606 	br	8111e730 <__reset+0xfb0fe730>

8111e8d8 <strtol>:
8111e8d8:	00a04574 	movhi	r2,33045
8111e8dc:	10ba8204 	addi	r2,r2,-5624
8111e8e0:	300f883a 	mov	r7,r6
8111e8e4:	280d883a 	mov	r6,r5
8111e8e8:	200b883a 	mov	r5,r4
8111e8ec:	11000017 	ldw	r4,0(r2)
8111e8f0:	111e6981 	jmpi	8111e698 <_strtol_r>

8111e8f4 <___svfprintf_internal_r>:
8111e8f4:	deffb704 	addi	sp,sp,-292
8111e8f8:	de00012e 	bgeu	sp,et,8111e900 <___svfprintf_internal_r+0xc>
8111e8fc:	003b68fa 	trap	3
8111e900:	dfc04815 	stw	ra,288(sp)
8111e904:	ddc04615 	stw	r23,280(sp)
8111e908:	d9402c15 	stw	r5,176(sp)
8111e90c:	d9003915 	stw	r4,228(sp)
8111e910:	302f883a 	mov	r23,r6
8111e914:	d9c02d15 	stw	r7,180(sp)
8111e918:	df004715 	stw	fp,284(sp)
8111e91c:	dd804515 	stw	r22,276(sp)
8111e920:	dd404415 	stw	r21,272(sp)
8111e924:	dd004315 	stw	r20,268(sp)
8111e928:	dcc04215 	stw	r19,264(sp)
8111e92c:	dc804115 	stw	r18,260(sp)
8111e930:	dc404015 	stw	r17,256(sp)
8111e934:	dc003f15 	stw	r16,252(sp)
8111e938:	11277dc0 	call	811277dc <_localeconv_r>
8111e93c:	10800017 	ldw	r2,0(r2)
8111e940:	1009883a 	mov	r4,r2
8111e944:	d8803415 	stw	r2,208(sp)
8111e948:	111e5bc0 	call	8111e5bc <strlen>
8111e94c:	d8c02c17 	ldw	r3,176(sp)
8111e950:	d8803815 	stw	r2,224(sp)
8111e954:	1880030b 	ldhu	r2,12(r3)
8111e958:	1080200c 	andi	r2,r2,128
8111e95c:	10000226 	beq	r2,zero,8111e968 <___svfprintf_internal_r+0x74>
8111e960:	18800417 	ldw	r2,16(r3)
8111e964:	10067f26 	beq	r2,zero,81120364 <___svfprintf_internal_r+0x1a70>
8111e968:	dcc03917 	ldw	r19,228(sp)
8111e96c:	d8c00404 	addi	r3,sp,16
8111e970:	05604574 	movhi	r21,33045
8111e974:	d9001e04 	addi	r4,sp,120
8111e978:	ad70ba84 	addi	r21,r21,-15638
8111e97c:	d8c01e15 	stw	r3,120(sp)
8111e980:	d8002015 	stw	zero,128(sp)
8111e984:	d8001f15 	stw	zero,124(sp)
8111e988:	d8003315 	stw	zero,204(sp)
8111e98c:	d8003615 	stw	zero,216(sp)
8111e990:	d8003715 	stw	zero,220(sp)
8111e994:	1811883a 	mov	r8,r3
8111e998:	d8003a15 	stw	zero,232(sp)
8111e99c:	d8003b15 	stw	zero,236(sp)
8111e9a0:	d8002f15 	stw	zero,188(sp)
8111e9a4:	d9002815 	stw	r4,160(sp)
8111e9a8:	b8800007 	ldb	r2,0(r23)
8111e9ac:	10026726 	beq	r2,zero,8111f34c <___svfprintf_internal_r+0xa58>
8111e9b0:	00c00944 	movi	r3,37
8111e9b4:	b821883a 	mov	r16,r23
8111e9b8:	10c0021e 	bne	r2,r3,8111e9c4 <___svfprintf_internal_r+0xd0>
8111e9bc:	00001406 	br	8111ea10 <___svfprintf_internal_r+0x11c>
8111e9c0:	10c00326 	beq	r2,r3,8111e9d0 <___svfprintf_internal_r+0xdc>
8111e9c4:	84000044 	addi	r16,r16,1
8111e9c8:	80800007 	ldb	r2,0(r16)
8111e9cc:	103ffc1e 	bne	r2,zero,8111e9c0 <__reset+0xfb0fe9c0>
8111e9d0:	85e3c83a 	sub	r17,r16,r23
8111e9d4:	88000e26 	beq	r17,zero,8111ea10 <___svfprintf_internal_r+0x11c>
8111e9d8:	d8c02017 	ldw	r3,128(sp)
8111e9dc:	d8801f17 	ldw	r2,124(sp)
8111e9e0:	45c00015 	stw	r23,0(r8)
8111e9e4:	1c47883a 	add	r3,r3,r17
8111e9e8:	10800044 	addi	r2,r2,1
8111e9ec:	d8c02015 	stw	r3,128(sp)
8111e9f0:	44400115 	stw	r17,4(r8)
8111e9f4:	d8801f15 	stw	r2,124(sp)
8111e9f8:	00c001c4 	movi	r3,7
8111e9fc:	18809716 	blt	r3,r2,8111ec5c <___svfprintf_internal_r+0x368>
8111ea00:	42000204 	addi	r8,r8,8
8111ea04:	d9402f17 	ldw	r5,188(sp)
8111ea08:	2c4b883a 	add	r5,r5,r17
8111ea0c:	d9402f15 	stw	r5,188(sp)
8111ea10:	80800007 	ldb	r2,0(r16)
8111ea14:	10009826 	beq	r2,zero,8111ec78 <___svfprintf_internal_r+0x384>
8111ea18:	84400047 	ldb	r17,1(r16)
8111ea1c:	00bfffc4 	movi	r2,-1
8111ea20:	85c00044 	addi	r23,r16,1
8111ea24:	d8002785 	stb	zero,158(sp)
8111ea28:	0007883a 	mov	r3,zero
8111ea2c:	000f883a 	mov	r7,zero
8111ea30:	d8802915 	stw	r2,164(sp)
8111ea34:	d8003115 	stw	zero,196(sp)
8111ea38:	0025883a 	mov	r18,zero
8111ea3c:	01401604 	movi	r5,88
8111ea40:	01800244 	movi	r6,9
8111ea44:	02800a84 	movi	r10,42
8111ea48:	02401b04 	movi	r9,108
8111ea4c:	bdc00044 	addi	r23,r23,1
8111ea50:	88bff804 	addi	r2,r17,-32
8111ea54:	2882f036 	bltu	r5,r2,8111f618 <___svfprintf_internal_r+0xd24>
8111ea58:	100490ba 	slli	r2,r2,2
8111ea5c:	012044b4 	movhi	r4,33042
8111ea60:	213a9c04 	addi	r4,r4,-5520
8111ea64:	1105883a 	add	r2,r2,r4
8111ea68:	10800017 	ldw	r2,0(r2)
8111ea6c:	1000683a 	jmp	r2
8111ea70:	8111f580 	call	88111f58 <__reset+0x20f1f58>
8111ea74:	8111f618 	cmpnei	r4,r16,18392
8111ea78:	8111f618 	cmpnei	r4,r16,18392
8111ea7c:	8111f574 	orhi	r4,r16,18389
8111ea80:	8111f618 	cmpnei	r4,r16,18392
8111ea84:	8111f618 	cmpnei	r4,r16,18392
8111ea88:	8111f618 	cmpnei	r4,r16,18392
8111ea8c:	8111f618 	cmpnei	r4,r16,18392
8111ea90:	8111f618 	cmpnei	r4,r16,18392
8111ea94:	8111f618 	cmpnei	r4,r16,18392
8111ea98:	8111ecd4 	ori	r4,r16,18355
8111ea9c:	8111f4b0 	cmpltui	r4,r16,18386
8111eaa0:	8111f618 	cmpnei	r4,r16,18392
8111eaa4:	8111ebe4 	muli	r4,r16,18351
8111eaa8:	8111ecfc 	xorhi	r4,r16,18355
8111eaac:	8111f618 	cmpnei	r4,r16,18392
8111eab0:	8111ed70 	cmpltui	r4,r16,18357
8111eab4:	8111ed3c 	xorhi	r4,r16,18356
8111eab8:	8111ed3c 	xorhi	r4,r16,18356
8111eabc:	8111ed3c 	xorhi	r4,r16,18356
8111eac0:	8111ed3c 	xorhi	r4,r16,18356
8111eac4:	8111ed3c 	xorhi	r4,r16,18356
8111eac8:	8111ed3c 	xorhi	r4,r16,18356
8111eacc:	8111ed3c 	xorhi	r4,r16,18356
8111ead0:	8111ed3c 	xorhi	r4,r16,18356
8111ead4:	8111ed3c 	xorhi	r4,r16,18356
8111ead8:	8111f618 	cmpnei	r4,r16,18392
8111eadc:	8111f618 	cmpnei	r4,r16,18392
8111eae0:	8111f618 	cmpnei	r4,r16,18392
8111eae4:	8111f618 	cmpnei	r4,r16,18392
8111eae8:	8111f618 	cmpnei	r4,r16,18392
8111eaec:	8111f618 	cmpnei	r4,r16,18392
8111eaf0:	8111f618 	cmpnei	r4,r16,18392
8111eaf4:	8111f618 	cmpnei	r4,r16,18392
8111eaf8:	8111f618 	cmpnei	r4,r16,18392
8111eafc:	8111f618 	cmpnei	r4,r16,18392
8111eb00:	8111ee28 	cmpgeui	r4,r16,18360
8111eb04:	8111ed7c 	xorhi	r4,r16,18357
8111eb08:	8111f618 	cmpnei	r4,r16,18392
8111eb0c:	8111ed7c 	xorhi	r4,r16,18357
8111eb10:	8111f618 	cmpnei	r4,r16,18392
8111eb14:	8111f618 	cmpnei	r4,r16,18392
8111eb18:	8111f618 	cmpnei	r4,r16,18392
8111eb1c:	8111f618 	cmpnei	r4,r16,18392
8111eb20:	8111ee1c 	xori	r4,r16,18360
8111eb24:	8111f618 	cmpnei	r4,r16,18392
8111eb28:	8111f618 	cmpnei	r4,r16,18392
8111eb2c:	8111eee4 	muli	r4,r16,18363
8111eb30:	8111f618 	cmpnei	r4,r16,18392
8111eb34:	8111f618 	cmpnei	r4,r16,18392
8111eb38:	8111f618 	cmpnei	r4,r16,18392
8111eb3c:	8111f618 	cmpnei	r4,r16,18392
8111eb40:	8111f618 	cmpnei	r4,r16,18392
8111eb44:	8111f354 	ori	r4,r16,18381
8111eb48:	8111f618 	cmpnei	r4,r16,18392
8111eb4c:	8111f618 	cmpnei	r4,r16,18392
8111eb50:	8111f3b4 	orhi	r4,r16,18382
8111eb54:	8111f618 	cmpnei	r4,r16,18392
8111eb58:	8111f618 	cmpnei	r4,r16,18392
8111eb5c:	8111f618 	cmpnei	r4,r16,18392
8111eb60:	8111f618 	cmpnei	r4,r16,18392
8111eb64:	8111f618 	cmpnei	r4,r16,18392
8111eb68:	8111f618 	cmpnei	r4,r16,18392
8111eb6c:	8111f618 	cmpnei	r4,r16,18392
8111eb70:	8111f618 	cmpnei	r4,r16,18392
8111eb74:	8111f618 	cmpnei	r4,r16,18392
8111eb78:	8111f618 	cmpnei	r4,r16,18392
8111eb7c:	8111f464 	muli	r4,r16,18385
8111eb80:	8111f5a0 	cmpeqi	r4,r16,18390
8111eb84:	8111ed7c 	xorhi	r4,r16,18357
8111eb88:	8111ed7c 	xorhi	r4,r16,18357
8111eb8c:	8111ed7c 	xorhi	r4,r16,18357
8111eb90:	8111f5f4 	orhi	r4,r16,18391
8111eb94:	8111f5a0 	cmpeqi	r4,r16,18390
8111eb98:	8111f618 	cmpnei	r4,r16,18392
8111eb9c:	8111f618 	cmpnei	r4,r16,18392
8111eba0:	8111f5b0 	cmpltui	r4,r16,18390
8111eba4:	8111f618 	cmpnei	r4,r16,18392
8111eba8:	8111f5c0 	call	88111f5c <__reset+0x20f1f5c>
8111ebac:	8111f4a0 	cmpeqi	r4,r16,18386
8111ebb0:	8111ebf0 	cmpltui	r4,r16,18351
8111ebb4:	8111f4c0 	call	88111f4c <__reset+0x20f1f4c>
8111ebb8:	8111f618 	cmpnei	r4,r16,18392
8111ebbc:	8111f4cc 	andi	r4,r16,18387
8111ebc0:	8111f618 	cmpnei	r4,r16,18392
8111ebc4:	8111f528 	cmpgeui	r4,r16,18388
8111ebc8:	8111f618 	cmpnei	r4,r16,18392
8111ebcc:	8111f618 	cmpnei	r4,r16,18392
8111ebd0:	8111f538 	rdprs	r4,r16,18388
8111ebd4:	d9003117 	ldw	r4,196(sp)
8111ebd8:	d8802d15 	stw	r2,180(sp)
8111ebdc:	0109c83a 	sub	r4,zero,r4
8111ebe0:	d9003115 	stw	r4,196(sp)
8111ebe4:	94800114 	ori	r18,r18,4
8111ebe8:	bc400007 	ldb	r17,0(r23)
8111ebec:	003f9706 	br	8111ea4c <__reset+0xfb0fea4c>
8111ebf0:	00800c04 	movi	r2,48
8111ebf4:	d9002d17 	ldw	r4,180(sp)
8111ebf8:	d9402917 	ldw	r5,164(sp)
8111ebfc:	d8802705 	stb	r2,156(sp)
8111ec00:	00801e04 	movi	r2,120
8111ec04:	d8802745 	stb	r2,157(sp)
8111ec08:	d8002785 	stb	zero,158(sp)
8111ec0c:	20c00104 	addi	r3,r4,4
8111ec10:	25000017 	ldw	r20,0(r4)
8111ec14:	002d883a 	mov	r22,zero
8111ec18:	90800094 	ori	r2,r18,2
8111ec1c:	28028616 	blt	r5,zero,8111f638 <___svfprintf_internal_r+0xd44>
8111ec20:	00bfdfc4 	movi	r2,-129
8111ec24:	90a4703a 	and	r18,r18,r2
8111ec28:	d8c02d15 	stw	r3,180(sp)
8111ec2c:	94800094 	ori	r18,r18,2
8111ec30:	a002731e 	bne	r20,zero,8111f600 <___svfprintf_internal_r+0xd0c>
8111ec34:	00a04574 	movhi	r2,33045
8111ec38:	10b0b304 	addi	r2,r2,-15668
8111ec3c:	d8803a15 	stw	r2,232(sp)
8111ec40:	04401e04 	movi	r17,120
8111ec44:	d8c02917 	ldw	r3,164(sp)
8111ec48:	0039883a 	mov	fp,zero
8111ec4c:	1801d526 	beq	r3,zero,8111f3a4 <___svfprintf_internal_r+0xab0>
8111ec50:	0029883a 	mov	r20,zero
8111ec54:	002d883a 	mov	r22,zero
8111ec58:	0001f106 	br	8111f420 <___svfprintf_internal_r+0xb2c>
8111ec5c:	d9402c17 	ldw	r5,176(sp)
8111ec60:	d9801e04 	addi	r6,sp,120
8111ec64:	9809883a 	mov	r4,r19
8111ec68:	112b5140 	call	8112b514 <__ssprint_r>
8111ec6c:	1000081e 	bne	r2,zero,8111ec90 <___svfprintf_internal_r+0x39c>
8111ec70:	da000404 	addi	r8,sp,16
8111ec74:	003f6306 	br	8111ea04 <__reset+0xfb0fea04>
8111ec78:	d8802017 	ldw	r2,128(sp)
8111ec7c:	10000426 	beq	r2,zero,8111ec90 <___svfprintf_internal_r+0x39c>
8111ec80:	d9402c17 	ldw	r5,176(sp)
8111ec84:	d9003917 	ldw	r4,228(sp)
8111ec88:	d9801e04 	addi	r6,sp,120
8111ec8c:	112b5140 	call	8112b514 <__ssprint_r>
8111ec90:	d8802c17 	ldw	r2,176(sp)
8111ec94:	10c0030b 	ldhu	r3,12(r2)
8111ec98:	d8802f17 	ldw	r2,188(sp)
8111ec9c:	18c0100c 	andi	r3,r3,64
8111eca0:	1805f51e 	bne	r3,zero,81120478 <___svfprintf_internal_r+0x1b84>
8111eca4:	dfc04817 	ldw	ra,288(sp)
8111eca8:	df004717 	ldw	fp,284(sp)
8111ecac:	ddc04617 	ldw	r23,280(sp)
8111ecb0:	dd804517 	ldw	r22,276(sp)
8111ecb4:	dd404417 	ldw	r21,272(sp)
8111ecb8:	dd004317 	ldw	r20,268(sp)
8111ecbc:	dcc04217 	ldw	r19,264(sp)
8111ecc0:	dc804117 	ldw	r18,260(sp)
8111ecc4:	dc404017 	ldw	r17,256(sp)
8111ecc8:	dc003f17 	ldw	r16,252(sp)
8111eccc:	dec04904 	addi	sp,sp,292
8111ecd0:	f800283a 	ret
8111ecd4:	d8802d17 	ldw	r2,180(sp)
8111ecd8:	d9002d17 	ldw	r4,180(sp)
8111ecdc:	10800017 	ldw	r2,0(r2)
8111ece0:	d8803115 	stw	r2,196(sp)
8111ece4:	20800104 	addi	r2,r4,4
8111ece8:	d9003117 	ldw	r4,196(sp)
8111ecec:	203fb916 	blt	r4,zero,8111ebd4 <__reset+0xfb0febd4>
8111ecf0:	d8802d15 	stw	r2,180(sp)
8111ecf4:	bc400007 	ldb	r17,0(r23)
8111ecf8:	003f5406 	br	8111ea4c <__reset+0xfb0fea4c>
8111ecfc:	bc400007 	ldb	r17,0(r23)
8111ed00:	bac00044 	addi	r11,r23,1
8111ed04:	8a873926 	beq	r17,r10,811209ec <___svfprintf_internal_r+0x20f8>
8111ed08:	88bff404 	addi	r2,r17,-48
8111ed0c:	0009883a 	mov	r4,zero
8111ed10:	30868836 	bltu	r6,r2,81120734 <___svfprintf_internal_r+0x1e40>
8111ed14:	5c400007 	ldb	r17,0(r11)
8111ed18:	210002a4 	muli	r4,r4,10
8111ed1c:	5dc00044 	addi	r23,r11,1
8111ed20:	b817883a 	mov	r11,r23
8111ed24:	2089883a 	add	r4,r4,r2
8111ed28:	88bff404 	addi	r2,r17,-48
8111ed2c:	30bff92e 	bgeu	r6,r2,8111ed14 <__reset+0xfb0fed14>
8111ed30:	2005d716 	blt	r4,zero,81120490 <___svfprintf_internal_r+0x1b9c>
8111ed34:	d9002915 	stw	r4,164(sp)
8111ed38:	003f4506 	br	8111ea50 <__reset+0xfb0fea50>
8111ed3c:	b809883a 	mov	r4,r23
8111ed40:	d8003115 	stw	zero,196(sp)
8111ed44:	88bff404 	addi	r2,r17,-48
8111ed48:	0017883a 	mov	r11,zero
8111ed4c:	24400007 	ldb	r17,0(r4)
8111ed50:	5ac002a4 	muli	r11,r11,10
8111ed54:	bdc00044 	addi	r23,r23,1
8111ed58:	b809883a 	mov	r4,r23
8111ed5c:	12d7883a 	add	r11,r2,r11
8111ed60:	88bff404 	addi	r2,r17,-48
8111ed64:	30bff92e 	bgeu	r6,r2,8111ed4c <__reset+0xfb0fed4c>
8111ed68:	dac03115 	stw	r11,196(sp)
8111ed6c:	003f3806 	br	8111ea50 <__reset+0xfb0fea50>
8111ed70:	94802014 	ori	r18,r18,128
8111ed74:	bc400007 	ldb	r17,0(r23)
8111ed78:	003f3406 	br	8111ea4c <__reset+0xfb0fea4c>
8111ed7c:	18c03fcc 	andi	r3,r3,255
8111ed80:	1807471e 	bne	r3,zero,81120aa0 <___svfprintf_internal_r+0x21ac>
8111ed84:	9080020c 	andi	r2,r18,8
8111ed88:	10047d26 	beq	r2,zero,8111ff80 <___svfprintf_internal_r+0x168c>
8111ed8c:	d8c02d17 	ldw	r3,180(sp)
8111ed90:	d9002d17 	ldw	r4,180(sp)
8111ed94:	d9402d17 	ldw	r5,180(sp)
8111ed98:	18c00017 	ldw	r3,0(r3)
8111ed9c:	21000117 	ldw	r4,4(r4)
8111eda0:	29400204 	addi	r5,r5,8
8111eda4:	d8c03615 	stw	r3,216(sp)
8111eda8:	d9003715 	stw	r4,220(sp)
8111edac:	d9402d15 	stw	r5,180(sp)
8111edb0:	d9003617 	ldw	r4,216(sp)
8111edb4:	d9403717 	ldw	r5,220(sp)
8111edb8:	da003e15 	stw	r8,248(sp)
8111edbc:	04000044 	movi	r16,1
8111edc0:	11293280 	call	81129328 <__fpclassifyd>
8111edc4:	da003e17 	ldw	r8,248(sp)
8111edc8:	14044b1e 	bne	r2,r16,8111fef8 <___svfprintf_internal_r+0x1604>
8111edcc:	d9003617 	ldw	r4,216(sp)
8111edd0:	d9403717 	ldw	r5,220(sp)
8111edd4:	000d883a 	mov	r6,zero
8111edd8:	000f883a 	mov	r7,zero
8111eddc:	11316700 	call	81131670 <__ledf2>
8111ede0:	da003e17 	ldw	r8,248(sp)
8111ede4:	1005f316 	blt	r2,zero,811205b4 <___svfprintf_internal_r+0x1cc0>
8111ede8:	df002783 	ldbu	fp,158(sp)
8111edec:	008011c4 	movi	r2,71
8111edf0:	1445590e 	bge	r2,r17,81120358 <___svfprintf_internal_r+0x1a64>
8111edf4:	04204574 	movhi	r16,33045
8111edf8:	8430ab04 	addi	r16,r16,-15700
8111edfc:	00c000c4 	movi	r3,3
8111ee00:	00bfdfc4 	movi	r2,-129
8111ee04:	d8c02a15 	stw	r3,168(sp)
8111ee08:	90a4703a 	and	r18,r18,r2
8111ee0c:	d8c02e15 	stw	r3,184(sp)
8111ee10:	d8002915 	stw	zero,164(sp)
8111ee14:	d8003215 	stw	zero,200(sp)
8111ee18:	00006606 	br	8111efb4 <___svfprintf_internal_r+0x6c0>
8111ee1c:	94800214 	ori	r18,r18,8
8111ee20:	bc400007 	ldb	r17,0(r23)
8111ee24:	003f0906 	br	8111ea4c <__reset+0xfb0fea4c>
8111ee28:	18c03fcc 	andi	r3,r3,255
8111ee2c:	1807181e 	bne	r3,zero,81120a90 <___svfprintf_internal_r+0x219c>
8111ee30:	94800414 	ori	r18,r18,16
8111ee34:	9080080c 	andi	r2,r18,32
8111ee38:	10039626 	beq	r2,zero,8111fc94 <___svfprintf_internal_r+0x13a0>
8111ee3c:	d9402d17 	ldw	r5,180(sp)
8111ee40:	28800117 	ldw	r2,4(r5)
8111ee44:	2d000017 	ldw	r20,0(r5)
8111ee48:	29400204 	addi	r5,r5,8
8111ee4c:	d9402d15 	stw	r5,180(sp)
8111ee50:	102d883a 	mov	r22,r2
8111ee54:	10039816 	blt	r2,zero,8111fcb8 <___svfprintf_internal_r+0x13c4>
8111ee58:	d9402917 	ldw	r5,164(sp)
8111ee5c:	df002783 	ldbu	fp,158(sp)
8111ee60:	2803ab16 	blt	r5,zero,8111fd10 <___svfprintf_internal_r+0x141c>
8111ee64:	00ffdfc4 	movi	r3,-129
8111ee68:	a584b03a 	or	r2,r20,r22
8111ee6c:	90e4703a 	and	r18,r18,r3
8111ee70:	10014a26 	beq	r2,zero,8111f39c <___svfprintf_internal_r+0xaa8>
8111ee74:	b0034b26 	beq	r22,zero,8111fba4 <___svfprintf_internal_r+0x12b0>
8111ee78:	dc402a15 	stw	r17,168(sp)
8111ee7c:	dc001e04 	addi	r16,sp,120
8111ee80:	b023883a 	mov	r17,r22
8111ee84:	402d883a 	mov	r22,r8
8111ee88:	a009883a 	mov	r4,r20
8111ee8c:	880b883a 	mov	r5,r17
8111ee90:	01800284 	movi	r6,10
8111ee94:	000f883a 	mov	r7,zero
8111ee98:	112fa780 	call	8112fa78 <__umoddi3>
8111ee9c:	10800c04 	addi	r2,r2,48
8111eea0:	843fffc4 	addi	r16,r16,-1
8111eea4:	a009883a 	mov	r4,r20
8111eea8:	880b883a 	mov	r5,r17
8111eeac:	80800005 	stb	r2,0(r16)
8111eeb0:	01800284 	movi	r6,10
8111eeb4:	000f883a 	mov	r7,zero
8111eeb8:	112f4f80 	call	8112f4f8 <__udivdi3>
8111eebc:	1029883a 	mov	r20,r2
8111eec0:	10c4b03a 	or	r2,r2,r3
8111eec4:	1823883a 	mov	r17,r3
8111eec8:	103fef1e 	bne	r2,zero,8111ee88 <__reset+0xfb0fee88>
8111eecc:	d8c02817 	ldw	r3,160(sp)
8111eed0:	dc402a17 	ldw	r17,168(sp)
8111eed4:	b011883a 	mov	r8,r22
8111eed8:	1c07c83a 	sub	r3,r3,r16
8111eedc:	d8c02e15 	stw	r3,184(sp)
8111eee0:	00002e06 	br	8111ef9c <___svfprintf_internal_r+0x6a8>
8111eee4:	18c03fcc 	andi	r3,r3,255
8111eee8:	1806e71e 	bne	r3,zero,81120a88 <___svfprintf_internal_r+0x2194>
8111eeec:	94800414 	ori	r18,r18,16
8111eef0:	9080080c 	andi	r2,r18,32
8111eef4:	1002d426 	beq	r2,zero,8111fa48 <___svfprintf_internal_r+0x1154>
8111eef8:	d9402d17 	ldw	r5,180(sp)
8111eefc:	d8c02917 	ldw	r3,164(sp)
8111ef00:	d8002785 	stb	zero,158(sp)
8111ef04:	28800204 	addi	r2,r5,8
8111ef08:	2d000017 	ldw	r20,0(r5)
8111ef0c:	2d800117 	ldw	r22,4(r5)
8111ef10:	18041516 	blt	r3,zero,8111ff68 <___svfprintf_internal_r+0x1674>
8111ef14:	013fdfc4 	movi	r4,-129
8111ef18:	a586b03a 	or	r3,r20,r22
8111ef1c:	d8802d15 	stw	r2,180(sp)
8111ef20:	9124703a 	and	r18,r18,r4
8111ef24:	1802d51e 	bne	r3,zero,8111fa7c <___svfprintf_internal_r+0x1188>
8111ef28:	d9402917 	ldw	r5,164(sp)
8111ef2c:	0039883a 	mov	fp,zero
8111ef30:	2806be26 	beq	r5,zero,81120a2c <___svfprintf_internal_r+0x2138>
8111ef34:	0029883a 	mov	r20,zero
8111ef38:	002d883a 	mov	r22,zero
8111ef3c:	dc001e04 	addi	r16,sp,120
8111ef40:	a006d0fa 	srli	r3,r20,3
8111ef44:	b008977a 	slli	r4,r22,29
8111ef48:	b02cd0fa 	srli	r22,r22,3
8111ef4c:	a50001cc 	andi	r20,r20,7
8111ef50:	a0800c04 	addi	r2,r20,48
8111ef54:	843fffc4 	addi	r16,r16,-1
8111ef58:	20e8b03a 	or	r20,r4,r3
8111ef5c:	80800005 	stb	r2,0(r16)
8111ef60:	a586b03a 	or	r3,r20,r22
8111ef64:	183ff61e 	bne	r3,zero,8111ef40 <__reset+0xfb0fef40>
8111ef68:	90c0004c 	andi	r3,r18,1
8111ef6c:	18013926 	beq	r3,zero,8111f454 <___svfprintf_internal_r+0xb60>
8111ef70:	10803fcc 	andi	r2,r2,255
8111ef74:	1080201c 	xori	r2,r2,128
8111ef78:	10bfe004 	addi	r2,r2,-128
8111ef7c:	00c00c04 	movi	r3,48
8111ef80:	10c13426 	beq	r2,r3,8111f454 <___svfprintf_internal_r+0xb60>
8111ef84:	80ffffc5 	stb	r3,-1(r16)
8111ef88:	d8c02817 	ldw	r3,160(sp)
8111ef8c:	80bfffc4 	addi	r2,r16,-1
8111ef90:	1021883a 	mov	r16,r2
8111ef94:	1887c83a 	sub	r3,r3,r2
8111ef98:	d8c02e15 	stw	r3,184(sp)
8111ef9c:	d8802e17 	ldw	r2,184(sp)
8111efa0:	d9002917 	ldw	r4,164(sp)
8111efa4:	1100010e 	bge	r2,r4,8111efac <___svfprintf_internal_r+0x6b8>
8111efa8:	2005883a 	mov	r2,r4
8111efac:	d8802a15 	stw	r2,168(sp)
8111efb0:	d8003215 	stw	zero,200(sp)
8111efb4:	e7003fcc 	andi	fp,fp,255
8111efb8:	e700201c 	xori	fp,fp,128
8111efbc:	e73fe004 	addi	fp,fp,-128
8111efc0:	e0000326 	beq	fp,zero,8111efd0 <___svfprintf_internal_r+0x6dc>
8111efc4:	d8c02a17 	ldw	r3,168(sp)
8111efc8:	18c00044 	addi	r3,r3,1
8111efcc:	d8c02a15 	stw	r3,168(sp)
8111efd0:	90c0008c 	andi	r3,r18,2
8111efd4:	d8c02b15 	stw	r3,172(sp)
8111efd8:	18000326 	beq	r3,zero,8111efe8 <___svfprintf_internal_r+0x6f4>
8111efdc:	d8c02a17 	ldw	r3,168(sp)
8111efe0:	18c00084 	addi	r3,r3,2
8111efe4:	d8c02a15 	stw	r3,168(sp)
8111efe8:	90c0210c 	andi	r3,r18,132
8111efec:	d8c03015 	stw	r3,192(sp)
8111eff0:	1801a11e 	bne	r3,zero,8111f678 <___svfprintf_internal_r+0xd84>
8111eff4:	d9003117 	ldw	r4,196(sp)
8111eff8:	d8c02a17 	ldw	r3,168(sp)
8111effc:	20e9c83a 	sub	r20,r4,r3
8111f000:	05019d0e 	bge	zero,r20,8111f678 <___svfprintf_internal_r+0xd84>
8111f004:	02400404 	movi	r9,16
8111f008:	d8c02017 	ldw	r3,128(sp)
8111f00c:	d8801f17 	ldw	r2,124(sp)
8111f010:	4d051b0e 	bge	r9,r20,81120480 <___svfprintf_internal_r+0x1b8c>
8111f014:	01604574 	movhi	r5,33045
8111f018:	2970be84 	addi	r5,r5,-15622
8111f01c:	dc403c15 	stw	r17,240(sp)
8111f020:	d9403515 	stw	r5,212(sp)
8111f024:	a023883a 	mov	r17,r20
8111f028:	482d883a 	mov	r22,r9
8111f02c:	9029883a 	mov	r20,r18
8111f030:	070001c4 	movi	fp,7
8111f034:	8025883a 	mov	r18,r16
8111f038:	dc002c17 	ldw	r16,176(sp)
8111f03c:	00000306 	br	8111f04c <___svfprintf_internal_r+0x758>
8111f040:	8c7ffc04 	addi	r17,r17,-16
8111f044:	42000204 	addi	r8,r8,8
8111f048:	b440130e 	bge	r22,r17,8111f098 <___svfprintf_internal_r+0x7a4>
8111f04c:	01204574 	movhi	r4,33045
8111f050:	18c00404 	addi	r3,r3,16
8111f054:	10800044 	addi	r2,r2,1
8111f058:	2130be84 	addi	r4,r4,-15622
8111f05c:	41000015 	stw	r4,0(r8)
8111f060:	45800115 	stw	r22,4(r8)
8111f064:	d8c02015 	stw	r3,128(sp)
8111f068:	d8801f15 	stw	r2,124(sp)
8111f06c:	e0bff40e 	bge	fp,r2,8111f040 <__reset+0xfb0ff040>
8111f070:	d9801e04 	addi	r6,sp,120
8111f074:	800b883a 	mov	r5,r16
8111f078:	9809883a 	mov	r4,r19
8111f07c:	112b5140 	call	8112b514 <__ssprint_r>
8111f080:	103f031e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f084:	8c7ffc04 	addi	r17,r17,-16
8111f088:	d8c02017 	ldw	r3,128(sp)
8111f08c:	d8801f17 	ldw	r2,124(sp)
8111f090:	da000404 	addi	r8,sp,16
8111f094:	b47fed16 	blt	r22,r17,8111f04c <__reset+0xfb0ff04c>
8111f098:	9021883a 	mov	r16,r18
8111f09c:	a025883a 	mov	r18,r20
8111f0a0:	8829883a 	mov	r20,r17
8111f0a4:	dc403c17 	ldw	r17,240(sp)
8111f0a8:	d9403517 	ldw	r5,212(sp)
8111f0ac:	a0c7883a 	add	r3,r20,r3
8111f0b0:	10800044 	addi	r2,r2,1
8111f0b4:	41400015 	stw	r5,0(r8)
8111f0b8:	45000115 	stw	r20,4(r8)
8111f0bc:	d8c02015 	stw	r3,128(sp)
8111f0c0:	d8801f15 	stw	r2,124(sp)
8111f0c4:	010001c4 	movi	r4,7
8111f0c8:	20829f16 	blt	r4,r2,8111fb48 <___svfprintf_internal_r+0x1254>
8111f0cc:	df002787 	ldb	fp,158(sp)
8111f0d0:	42000204 	addi	r8,r8,8
8111f0d4:	e0000c26 	beq	fp,zero,8111f108 <___svfprintf_internal_r+0x814>
8111f0d8:	d8801f17 	ldw	r2,124(sp)
8111f0dc:	d9002784 	addi	r4,sp,158
8111f0e0:	18c00044 	addi	r3,r3,1
8111f0e4:	10800044 	addi	r2,r2,1
8111f0e8:	41000015 	stw	r4,0(r8)
8111f0ec:	01000044 	movi	r4,1
8111f0f0:	41000115 	stw	r4,4(r8)
8111f0f4:	d8c02015 	stw	r3,128(sp)
8111f0f8:	d8801f15 	stw	r2,124(sp)
8111f0fc:	010001c4 	movi	r4,7
8111f100:	20823816 	blt	r4,r2,8111f9e4 <___svfprintf_internal_r+0x10f0>
8111f104:	42000204 	addi	r8,r8,8
8111f108:	d8802b17 	ldw	r2,172(sp)
8111f10c:	10000c26 	beq	r2,zero,8111f140 <___svfprintf_internal_r+0x84c>
8111f110:	d8801f17 	ldw	r2,124(sp)
8111f114:	d9002704 	addi	r4,sp,156
8111f118:	18c00084 	addi	r3,r3,2
8111f11c:	10800044 	addi	r2,r2,1
8111f120:	41000015 	stw	r4,0(r8)
8111f124:	01000084 	movi	r4,2
8111f128:	41000115 	stw	r4,4(r8)
8111f12c:	d8c02015 	stw	r3,128(sp)
8111f130:	d8801f15 	stw	r2,124(sp)
8111f134:	010001c4 	movi	r4,7
8111f138:	20823216 	blt	r4,r2,8111fa04 <___svfprintf_internal_r+0x1110>
8111f13c:	42000204 	addi	r8,r8,8
8111f140:	d9003017 	ldw	r4,192(sp)
8111f144:	00802004 	movi	r2,128
8111f148:	20819726 	beq	r4,r2,8111f7a8 <___svfprintf_internal_r+0xeb4>
8111f14c:	d9402917 	ldw	r5,164(sp)
8111f150:	d8802e17 	ldw	r2,184(sp)
8111f154:	28adc83a 	sub	r22,r5,r2
8111f158:	05802f0e 	bge	zero,r22,8111f218 <___svfprintf_internal_r+0x924>
8111f15c:	07000404 	movi	fp,16
8111f160:	d8801f17 	ldw	r2,124(sp)
8111f164:	e583c00e 	bge	fp,r22,81120068 <___svfprintf_internal_r+0x1774>
8111f168:	01604574 	movhi	r5,33045
8111f16c:	2970ba84 	addi	r5,r5,-15638
8111f170:	dc402915 	stw	r17,164(sp)
8111f174:	d9402b15 	stw	r5,172(sp)
8111f178:	b023883a 	mov	r17,r22
8111f17c:	050001c4 	movi	r20,7
8111f180:	902d883a 	mov	r22,r18
8111f184:	8025883a 	mov	r18,r16
8111f188:	dc002c17 	ldw	r16,176(sp)
8111f18c:	00000306 	br	8111f19c <___svfprintf_internal_r+0x8a8>
8111f190:	8c7ffc04 	addi	r17,r17,-16
8111f194:	42000204 	addi	r8,r8,8
8111f198:	e440110e 	bge	fp,r17,8111f1e0 <___svfprintf_internal_r+0x8ec>
8111f19c:	18c00404 	addi	r3,r3,16
8111f1a0:	10800044 	addi	r2,r2,1
8111f1a4:	45400015 	stw	r21,0(r8)
8111f1a8:	47000115 	stw	fp,4(r8)
8111f1ac:	d8c02015 	stw	r3,128(sp)
8111f1b0:	d8801f15 	stw	r2,124(sp)
8111f1b4:	a0bff60e 	bge	r20,r2,8111f190 <__reset+0xfb0ff190>
8111f1b8:	d9801e04 	addi	r6,sp,120
8111f1bc:	800b883a 	mov	r5,r16
8111f1c0:	9809883a 	mov	r4,r19
8111f1c4:	112b5140 	call	8112b514 <__ssprint_r>
8111f1c8:	103eb11e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f1cc:	8c7ffc04 	addi	r17,r17,-16
8111f1d0:	d8c02017 	ldw	r3,128(sp)
8111f1d4:	d8801f17 	ldw	r2,124(sp)
8111f1d8:	da000404 	addi	r8,sp,16
8111f1dc:	e47fef16 	blt	fp,r17,8111f19c <__reset+0xfb0ff19c>
8111f1e0:	9021883a 	mov	r16,r18
8111f1e4:	b025883a 	mov	r18,r22
8111f1e8:	882d883a 	mov	r22,r17
8111f1ec:	dc402917 	ldw	r17,164(sp)
8111f1f0:	d9002b17 	ldw	r4,172(sp)
8111f1f4:	1d87883a 	add	r3,r3,r22
8111f1f8:	10800044 	addi	r2,r2,1
8111f1fc:	41000015 	stw	r4,0(r8)
8111f200:	45800115 	stw	r22,4(r8)
8111f204:	d8c02015 	stw	r3,128(sp)
8111f208:	d8801f15 	stw	r2,124(sp)
8111f20c:	010001c4 	movi	r4,7
8111f210:	2081ec16 	blt	r4,r2,8111f9c4 <___svfprintf_internal_r+0x10d0>
8111f214:	42000204 	addi	r8,r8,8
8111f218:	9080400c 	andi	r2,r18,256
8111f21c:	1001181e 	bne	r2,zero,8111f680 <___svfprintf_internal_r+0xd8c>
8111f220:	d9402e17 	ldw	r5,184(sp)
8111f224:	d8801f17 	ldw	r2,124(sp)
8111f228:	44000015 	stw	r16,0(r8)
8111f22c:	1947883a 	add	r3,r3,r5
8111f230:	10800044 	addi	r2,r2,1
8111f234:	41400115 	stw	r5,4(r8)
8111f238:	d8c02015 	stw	r3,128(sp)
8111f23c:	d8801f15 	stw	r2,124(sp)
8111f240:	010001c4 	movi	r4,7
8111f244:	2081d116 	blt	r4,r2,8111f98c <___svfprintf_internal_r+0x1098>
8111f248:	42000204 	addi	r8,r8,8
8111f24c:	9480010c 	andi	r18,r18,4
8111f250:	90003226 	beq	r18,zero,8111f31c <___svfprintf_internal_r+0xa28>
8111f254:	d9403117 	ldw	r5,196(sp)
8111f258:	d8802a17 	ldw	r2,168(sp)
8111f25c:	28a1c83a 	sub	r16,r5,r2
8111f260:	04002e0e 	bge	zero,r16,8111f31c <___svfprintf_internal_r+0xa28>
8111f264:	04400404 	movi	r17,16
8111f268:	d8801f17 	ldw	r2,124(sp)
8111f26c:	8c04b90e 	bge	r17,r16,81120554 <___svfprintf_internal_r+0x1c60>
8111f270:	01604574 	movhi	r5,33045
8111f274:	2970be84 	addi	r5,r5,-15622
8111f278:	d9403515 	stw	r5,212(sp)
8111f27c:	048001c4 	movi	r18,7
8111f280:	dd002c17 	ldw	r20,176(sp)
8111f284:	00000306 	br	8111f294 <___svfprintf_internal_r+0x9a0>
8111f288:	843ffc04 	addi	r16,r16,-16
8111f28c:	42000204 	addi	r8,r8,8
8111f290:	8c00130e 	bge	r17,r16,8111f2e0 <___svfprintf_internal_r+0x9ec>
8111f294:	01204574 	movhi	r4,33045
8111f298:	18c00404 	addi	r3,r3,16
8111f29c:	10800044 	addi	r2,r2,1
8111f2a0:	2130be84 	addi	r4,r4,-15622
8111f2a4:	41000015 	stw	r4,0(r8)
8111f2a8:	44400115 	stw	r17,4(r8)
8111f2ac:	d8c02015 	stw	r3,128(sp)
8111f2b0:	d8801f15 	stw	r2,124(sp)
8111f2b4:	90bff40e 	bge	r18,r2,8111f288 <__reset+0xfb0ff288>
8111f2b8:	d9801e04 	addi	r6,sp,120
8111f2bc:	a00b883a 	mov	r5,r20
8111f2c0:	9809883a 	mov	r4,r19
8111f2c4:	112b5140 	call	8112b514 <__ssprint_r>
8111f2c8:	103e711e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f2cc:	843ffc04 	addi	r16,r16,-16
8111f2d0:	d8c02017 	ldw	r3,128(sp)
8111f2d4:	d8801f17 	ldw	r2,124(sp)
8111f2d8:	da000404 	addi	r8,sp,16
8111f2dc:	8c3fed16 	blt	r17,r16,8111f294 <__reset+0xfb0ff294>
8111f2e0:	d9403517 	ldw	r5,212(sp)
8111f2e4:	1c07883a 	add	r3,r3,r16
8111f2e8:	10800044 	addi	r2,r2,1
8111f2ec:	41400015 	stw	r5,0(r8)
8111f2f0:	44000115 	stw	r16,4(r8)
8111f2f4:	d8c02015 	stw	r3,128(sp)
8111f2f8:	d8801f15 	stw	r2,124(sp)
8111f2fc:	010001c4 	movi	r4,7
8111f300:	2080060e 	bge	r4,r2,8111f31c <___svfprintf_internal_r+0xa28>
8111f304:	d9402c17 	ldw	r5,176(sp)
8111f308:	d9801e04 	addi	r6,sp,120
8111f30c:	9809883a 	mov	r4,r19
8111f310:	112b5140 	call	8112b514 <__ssprint_r>
8111f314:	103e5e1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f318:	d8c02017 	ldw	r3,128(sp)
8111f31c:	d8803117 	ldw	r2,196(sp)
8111f320:	d9002a17 	ldw	r4,168(sp)
8111f324:	1100010e 	bge	r2,r4,8111f32c <___svfprintf_internal_r+0xa38>
8111f328:	2005883a 	mov	r2,r4
8111f32c:	d9402f17 	ldw	r5,188(sp)
8111f330:	288b883a 	add	r5,r5,r2
8111f334:	d9402f15 	stw	r5,188(sp)
8111f338:	18019c1e 	bne	r3,zero,8111f9ac <___svfprintf_internal_r+0x10b8>
8111f33c:	b8800007 	ldb	r2,0(r23)
8111f340:	d8001f15 	stw	zero,124(sp)
8111f344:	da000404 	addi	r8,sp,16
8111f348:	103d991e 	bne	r2,zero,8111e9b0 <__reset+0xfb0fe9b0>
8111f34c:	b821883a 	mov	r16,r23
8111f350:	003daf06 	br	8111ea10 <__reset+0xfb0fea10>
8111f354:	18c03fcc 	andi	r3,r3,255
8111f358:	1805c71e 	bne	r3,zero,81120a78 <___svfprintf_internal_r+0x2184>
8111f35c:	94800414 	ori	r18,r18,16
8111f360:	9080080c 	andi	r2,r18,32
8111f364:	10020126 	beq	r2,zero,8111fb6c <___svfprintf_internal_r+0x1278>
8111f368:	d8802d17 	ldw	r2,180(sp)
8111f36c:	d9002917 	ldw	r4,164(sp)
8111f370:	d8002785 	stb	zero,158(sp)
8111f374:	10c00204 	addi	r3,r2,8
8111f378:	15000017 	ldw	r20,0(r2)
8111f37c:	15800117 	ldw	r22,4(r2)
8111f380:	20038e16 	blt	r4,zero,811201bc <___svfprintf_internal_r+0x18c8>
8111f384:	013fdfc4 	movi	r4,-129
8111f388:	a584b03a 	or	r2,r20,r22
8111f38c:	d8c02d15 	stw	r3,180(sp)
8111f390:	9124703a 	and	r18,r18,r4
8111f394:	0039883a 	mov	fp,zero
8111f398:	103eb61e 	bne	r2,zero,8111ee74 <__reset+0xfb0fee74>
8111f39c:	d8802917 	ldw	r2,164(sp)
8111f3a0:	1002c81e 	bne	r2,zero,8111fec4 <___svfprintf_internal_r+0x15d0>
8111f3a4:	d8002915 	stw	zero,164(sp)
8111f3a8:	d8002e15 	stw	zero,184(sp)
8111f3ac:	dc001e04 	addi	r16,sp,120
8111f3b0:	003efa06 	br	8111ef9c <__reset+0xfb0fef9c>
8111f3b4:	18c03fcc 	andi	r3,r3,255
8111f3b8:	1805ad1e 	bne	r3,zero,81120a70 <___svfprintf_internal_r+0x217c>
8111f3bc:	01604574 	movhi	r5,33045
8111f3c0:	2970ae04 	addi	r5,r5,-15688
8111f3c4:	d9403a15 	stw	r5,232(sp)
8111f3c8:	9080080c 	andi	r2,r18,32
8111f3cc:	10006126 	beq	r2,zero,8111f554 <___svfprintf_internal_r+0xc60>
8111f3d0:	d8802d17 	ldw	r2,180(sp)
8111f3d4:	15000017 	ldw	r20,0(r2)
8111f3d8:	15800117 	ldw	r22,4(r2)
8111f3dc:	10800204 	addi	r2,r2,8
8111f3e0:	d8802d15 	stw	r2,180(sp)
8111f3e4:	9080004c 	andi	r2,r18,1
8111f3e8:	10018e26 	beq	r2,zero,8111fa24 <___svfprintf_internal_r+0x1130>
8111f3ec:	a584b03a 	or	r2,r20,r22
8111f3f0:	10030926 	beq	r2,zero,81120018 <___svfprintf_internal_r+0x1724>
8111f3f4:	d8c02917 	ldw	r3,164(sp)
8111f3f8:	00800c04 	movi	r2,48
8111f3fc:	d8802705 	stb	r2,156(sp)
8111f400:	dc402745 	stb	r17,157(sp)
8111f404:	d8002785 	stb	zero,158(sp)
8111f408:	90800094 	ori	r2,r18,2
8111f40c:	18048716 	blt	r3,zero,8112062c <___svfprintf_internal_r+0x1d38>
8111f410:	00bfdfc4 	movi	r2,-129
8111f414:	90a4703a 	and	r18,r18,r2
8111f418:	94800094 	ori	r18,r18,2
8111f41c:	0039883a 	mov	fp,zero
8111f420:	d9003a17 	ldw	r4,232(sp)
8111f424:	dc001e04 	addi	r16,sp,120
8111f428:	a08003cc 	andi	r2,r20,15
8111f42c:	b006973a 	slli	r3,r22,28
8111f430:	2085883a 	add	r2,r4,r2
8111f434:	a028d13a 	srli	r20,r20,4
8111f438:	10800003 	ldbu	r2,0(r2)
8111f43c:	b02cd13a 	srli	r22,r22,4
8111f440:	843fffc4 	addi	r16,r16,-1
8111f444:	1d28b03a 	or	r20,r3,r20
8111f448:	80800005 	stb	r2,0(r16)
8111f44c:	a584b03a 	or	r2,r20,r22
8111f450:	103ff51e 	bne	r2,zero,8111f428 <__reset+0xfb0ff428>
8111f454:	d8c02817 	ldw	r3,160(sp)
8111f458:	1c07c83a 	sub	r3,r3,r16
8111f45c:	d8c02e15 	stw	r3,184(sp)
8111f460:	003ece06 	br	8111ef9c <__reset+0xfb0fef9c>
8111f464:	d8c02d17 	ldw	r3,180(sp)
8111f468:	d9002d17 	ldw	r4,180(sp)
8111f46c:	d8002785 	stb	zero,158(sp)
8111f470:	18800017 	ldw	r2,0(r3)
8111f474:	21000104 	addi	r4,r4,4
8111f478:	00c00044 	movi	r3,1
8111f47c:	d8c02a15 	stw	r3,168(sp)
8111f480:	d8801405 	stb	r2,80(sp)
8111f484:	d9002d15 	stw	r4,180(sp)
8111f488:	d8c02e15 	stw	r3,184(sp)
8111f48c:	d8002915 	stw	zero,164(sp)
8111f490:	d8003215 	stw	zero,200(sp)
8111f494:	dc001404 	addi	r16,sp,80
8111f498:	0039883a 	mov	fp,zero
8111f49c:	003ecc06 	br	8111efd0 <__reset+0xfb0fefd0>
8111f4a0:	18c03fcc 	andi	r3,r3,255
8111f4a4:	183e9226 	beq	r3,zero,8111eef0 <__reset+0xfb0feef0>
8111f4a8:	d9c02785 	stb	r7,158(sp)
8111f4ac:	003e9006 	br	8111eef0 <__reset+0xfb0feef0>
8111f4b0:	00c00044 	movi	r3,1
8111f4b4:	01c00ac4 	movi	r7,43
8111f4b8:	bc400007 	ldb	r17,0(r23)
8111f4bc:	003d6306 	br	8111ea4c <__reset+0xfb0fea4c>
8111f4c0:	94800814 	ori	r18,r18,32
8111f4c4:	bc400007 	ldb	r17,0(r23)
8111f4c8:	003d6006 	br	8111ea4c <__reset+0xfb0fea4c>
8111f4cc:	d8c02d17 	ldw	r3,180(sp)
8111f4d0:	d8002785 	stb	zero,158(sp)
8111f4d4:	1c000017 	ldw	r16,0(r3)
8111f4d8:	1d000104 	addi	r20,r3,4
8111f4dc:	80040f26 	beq	r16,zero,8112051c <___svfprintf_internal_r+0x1c28>
8111f4e0:	d9002917 	ldw	r4,164(sp)
8111f4e4:	2003dc16 	blt	r4,zero,81120458 <___svfprintf_internal_r+0x1b64>
8111f4e8:	200d883a 	mov	r6,r4
8111f4ec:	000b883a 	mov	r5,zero
8111f4f0:	8009883a 	mov	r4,r16
8111f4f4:	da003e15 	stw	r8,248(sp)
8111f4f8:	1127ab80 	call	81127ab8 <memchr>
8111f4fc:	da003e17 	ldw	r8,248(sp)
8111f500:	10045826 	beq	r2,zero,81120664 <___svfprintf_internal_r+0x1d70>
8111f504:	1405c83a 	sub	r2,r2,r16
8111f508:	d8802e15 	stw	r2,184(sp)
8111f50c:	1003d816 	blt	r2,zero,81120470 <___svfprintf_internal_r+0x1b7c>
8111f510:	df002783 	ldbu	fp,158(sp)
8111f514:	d8802a15 	stw	r2,168(sp)
8111f518:	dd002d15 	stw	r20,180(sp)
8111f51c:	d8002915 	stw	zero,164(sp)
8111f520:	d8003215 	stw	zero,200(sp)
8111f524:	003ea306 	br	8111efb4 <__reset+0xfb0fefb4>
8111f528:	18c03fcc 	andi	r3,r3,255
8111f52c:	183f8c26 	beq	r3,zero,8111f360 <__reset+0xfb0ff360>
8111f530:	d9c02785 	stb	r7,158(sp)
8111f534:	003f8a06 	br	8111f360 <__reset+0xfb0ff360>
8111f538:	18c03fcc 	andi	r3,r3,255
8111f53c:	1805631e 	bne	r3,zero,81120acc <___svfprintf_internal_r+0x21d8>
8111f540:	01604574 	movhi	r5,33045
8111f544:	2970b304 	addi	r5,r5,-15668
8111f548:	d9403a15 	stw	r5,232(sp)
8111f54c:	9080080c 	andi	r2,r18,32
8111f550:	103f9f1e 	bne	r2,zero,8111f3d0 <__reset+0xfb0ff3d0>
8111f554:	9080040c 	andi	r2,r18,16
8111f558:	10029c26 	beq	r2,zero,8111ffcc <___svfprintf_internal_r+0x16d8>
8111f55c:	d8c02d17 	ldw	r3,180(sp)
8111f560:	002d883a 	mov	r22,zero
8111f564:	1d000017 	ldw	r20,0(r3)
8111f568:	18c00104 	addi	r3,r3,4
8111f56c:	d8c02d15 	stw	r3,180(sp)
8111f570:	003f9c06 	br	8111f3e4 <__reset+0xfb0ff3e4>
8111f574:	94800054 	ori	r18,r18,1
8111f578:	bc400007 	ldb	r17,0(r23)
8111f57c:	003d3306 	br	8111ea4c <__reset+0xfb0fea4c>
8111f580:	38803fcc 	andi	r2,r7,255
8111f584:	1080201c 	xori	r2,r2,128
8111f588:	10bfe004 	addi	r2,r2,-128
8111f58c:	1002971e 	bne	r2,zero,8111ffec <___svfprintf_internal_r+0x16f8>
8111f590:	00c00044 	movi	r3,1
8111f594:	01c00804 	movi	r7,32
8111f598:	bc400007 	ldb	r17,0(r23)
8111f59c:	003d2b06 	br	8111ea4c <__reset+0xfb0fea4c>
8111f5a0:	18c03fcc 	andi	r3,r3,255
8111f5a4:	183e2326 	beq	r3,zero,8111ee34 <__reset+0xfb0fee34>
8111f5a8:	d9c02785 	stb	r7,158(sp)
8111f5ac:	003e2106 	br	8111ee34 <__reset+0xfb0fee34>
8111f5b0:	bc400007 	ldb	r17,0(r23)
8111f5b4:	8a430426 	beq	r17,r9,811201c8 <___svfprintf_internal_r+0x18d4>
8111f5b8:	94800414 	ori	r18,r18,16
8111f5bc:	003d2306 	br	8111ea4c <__reset+0xfb0fea4c>
8111f5c0:	18c03fcc 	andi	r3,r3,255
8111f5c4:	18053f1e 	bne	r3,zero,81120ac4 <___svfprintf_internal_r+0x21d0>
8111f5c8:	9080080c 	andi	r2,r18,32
8111f5cc:	10028926 	beq	r2,zero,8111fff4 <___svfprintf_internal_r+0x1700>
8111f5d0:	d9402d17 	ldw	r5,180(sp)
8111f5d4:	d9002f17 	ldw	r4,188(sp)
8111f5d8:	28800017 	ldw	r2,0(r5)
8111f5dc:	2007d7fa 	srai	r3,r4,31
8111f5e0:	29400104 	addi	r5,r5,4
8111f5e4:	d9402d15 	stw	r5,180(sp)
8111f5e8:	11000015 	stw	r4,0(r2)
8111f5ec:	10c00115 	stw	r3,4(r2)
8111f5f0:	003ced06 	br	8111e9a8 <__reset+0xfb0fe9a8>
8111f5f4:	94801014 	ori	r18,r18,64
8111f5f8:	bc400007 	ldb	r17,0(r23)
8111f5fc:	003d1306 	br	8111ea4c <__reset+0xfb0fea4c>
8111f600:	01204574 	movhi	r4,33045
8111f604:	2130b304 	addi	r4,r4,-15668
8111f608:	0039883a 	mov	fp,zero
8111f60c:	d9003a15 	stw	r4,232(sp)
8111f610:	04401e04 	movi	r17,120
8111f614:	003f8206 	br	8111f420 <__reset+0xfb0ff420>
8111f618:	18c03fcc 	andi	r3,r3,255
8111f61c:	1805221e 	bne	r3,zero,81120aa8 <___svfprintf_internal_r+0x21b4>
8111f620:	883d9526 	beq	r17,zero,8111ec78 <__reset+0xfb0fec78>
8111f624:	00c00044 	movi	r3,1
8111f628:	d8c02a15 	stw	r3,168(sp)
8111f62c:	dc401405 	stb	r17,80(sp)
8111f630:	d8002785 	stb	zero,158(sp)
8111f634:	003f9406 	br	8111f488 <__reset+0xfb0ff488>
8111f638:	01204574 	movhi	r4,33045
8111f63c:	2130b304 	addi	r4,r4,-15668
8111f640:	d9003a15 	stw	r4,232(sp)
8111f644:	d8c02d15 	stw	r3,180(sp)
8111f648:	1025883a 	mov	r18,r2
8111f64c:	04401e04 	movi	r17,120
8111f650:	a584b03a 	or	r2,r20,r22
8111f654:	1000fa1e 	bne	r2,zero,8111fa40 <___svfprintf_internal_r+0x114c>
8111f658:	0039883a 	mov	fp,zero
8111f65c:	00800084 	movi	r2,2
8111f660:	10803fcc 	andi	r2,r2,255
8111f664:	00c00044 	movi	r3,1
8111f668:	10c21626 	beq	r2,r3,8111fec4 <___svfprintf_internal_r+0x15d0>
8111f66c:	00c00084 	movi	r3,2
8111f670:	10fe301e 	bne	r2,r3,8111ef34 <__reset+0xfb0fef34>
8111f674:	003d7606 	br	8111ec50 <__reset+0xfb0fec50>
8111f678:	d8c02017 	ldw	r3,128(sp)
8111f67c:	003e9506 	br	8111f0d4 <__reset+0xfb0ff0d4>
8111f680:	00801944 	movi	r2,101
8111f684:	14407c0e 	bge	r2,r17,8111f878 <___svfprintf_internal_r+0xf84>
8111f688:	d9003617 	ldw	r4,216(sp)
8111f68c:	d9403717 	ldw	r5,220(sp)
8111f690:	000d883a 	mov	r6,zero
8111f694:	000f883a 	mov	r7,zero
8111f698:	d8c03d15 	stw	r3,244(sp)
8111f69c:	da003e15 	stw	r8,248(sp)
8111f6a0:	113150c0 	call	8113150c <__eqdf2>
8111f6a4:	d8c03d17 	ldw	r3,244(sp)
8111f6a8:	da003e17 	ldw	r8,248(sp)
8111f6ac:	1000f51e 	bne	r2,zero,8111fa84 <___svfprintf_internal_r+0x1190>
8111f6b0:	d8801f17 	ldw	r2,124(sp)
8111f6b4:	01204574 	movhi	r4,33045
8111f6b8:	2130ba04 	addi	r4,r4,-15640
8111f6bc:	18c00044 	addi	r3,r3,1
8111f6c0:	10800044 	addi	r2,r2,1
8111f6c4:	41000015 	stw	r4,0(r8)
8111f6c8:	01000044 	movi	r4,1
8111f6cc:	41000115 	stw	r4,4(r8)
8111f6d0:	d8c02015 	stw	r3,128(sp)
8111f6d4:	d8801f15 	stw	r2,124(sp)
8111f6d8:	010001c4 	movi	r4,7
8111f6dc:	20826616 	blt	r4,r2,81120078 <___svfprintf_internal_r+0x1784>
8111f6e0:	42000204 	addi	r8,r8,8
8111f6e4:	d8802617 	ldw	r2,152(sp)
8111f6e8:	d9403317 	ldw	r5,204(sp)
8111f6ec:	11400216 	blt	r2,r5,8111f6f8 <___svfprintf_internal_r+0xe04>
8111f6f0:	9080004c 	andi	r2,r18,1
8111f6f4:	103ed526 	beq	r2,zero,8111f24c <__reset+0xfb0ff24c>
8111f6f8:	d8803817 	ldw	r2,224(sp)
8111f6fc:	d9003417 	ldw	r4,208(sp)
8111f700:	d9403817 	ldw	r5,224(sp)
8111f704:	1887883a 	add	r3,r3,r2
8111f708:	d8801f17 	ldw	r2,124(sp)
8111f70c:	41000015 	stw	r4,0(r8)
8111f710:	41400115 	stw	r5,4(r8)
8111f714:	10800044 	addi	r2,r2,1
8111f718:	d8c02015 	stw	r3,128(sp)
8111f71c:	d8801f15 	stw	r2,124(sp)
8111f720:	010001c4 	movi	r4,7
8111f724:	2082af16 	blt	r4,r2,811201e4 <___svfprintf_internal_r+0x18f0>
8111f728:	42000204 	addi	r8,r8,8
8111f72c:	d8803317 	ldw	r2,204(sp)
8111f730:	143fffc4 	addi	r16,r2,-1
8111f734:	043ec50e 	bge	zero,r16,8111f24c <__reset+0xfb0ff24c>
8111f738:	04400404 	movi	r17,16
8111f73c:	d8801f17 	ldw	r2,124(sp)
8111f740:	8c00860e 	bge	r17,r16,8111f95c <___svfprintf_internal_r+0x1068>
8111f744:	01604574 	movhi	r5,33045
8111f748:	2970ba84 	addi	r5,r5,-15638
8111f74c:	d9402b15 	stw	r5,172(sp)
8111f750:	058001c4 	movi	r22,7
8111f754:	dd002c17 	ldw	r20,176(sp)
8111f758:	00000306 	br	8111f768 <___svfprintf_internal_r+0xe74>
8111f75c:	42000204 	addi	r8,r8,8
8111f760:	843ffc04 	addi	r16,r16,-16
8111f764:	8c00800e 	bge	r17,r16,8111f968 <___svfprintf_internal_r+0x1074>
8111f768:	18c00404 	addi	r3,r3,16
8111f76c:	10800044 	addi	r2,r2,1
8111f770:	45400015 	stw	r21,0(r8)
8111f774:	44400115 	stw	r17,4(r8)
8111f778:	d8c02015 	stw	r3,128(sp)
8111f77c:	d8801f15 	stw	r2,124(sp)
8111f780:	b0bff60e 	bge	r22,r2,8111f75c <__reset+0xfb0ff75c>
8111f784:	d9801e04 	addi	r6,sp,120
8111f788:	a00b883a 	mov	r5,r20
8111f78c:	9809883a 	mov	r4,r19
8111f790:	112b5140 	call	8112b514 <__ssprint_r>
8111f794:	103d3e1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f798:	d8c02017 	ldw	r3,128(sp)
8111f79c:	d8801f17 	ldw	r2,124(sp)
8111f7a0:	da000404 	addi	r8,sp,16
8111f7a4:	003fee06 	br	8111f760 <__reset+0xfb0ff760>
8111f7a8:	d9403117 	ldw	r5,196(sp)
8111f7ac:	d8802a17 	ldw	r2,168(sp)
8111f7b0:	28adc83a 	sub	r22,r5,r2
8111f7b4:	05be650e 	bge	zero,r22,8111f14c <__reset+0xfb0ff14c>
8111f7b8:	07000404 	movi	fp,16
8111f7bc:	d8801f17 	ldw	r2,124(sp)
8111f7c0:	e583a20e 	bge	fp,r22,8112064c <___svfprintf_internal_r+0x1d58>
8111f7c4:	01604574 	movhi	r5,33045
8111f7c8:	2970ba84 	addi	r5,r5,-15638
8111f7cc:	dc403015 	stw	r17,192(sp)
8111f7d0:	d9402b15 	stw	r5,172(sp)
8111f7d4:	b023883a 	mov	r17,r22
8111f7d8:	050001c4 	movi	r20,7
8111f7dc:	902d883a 	mov	r22,r18
8111f7e0:	8025883a 	mov	r18,r16
8111f7e4:	dc002c17 	ldw	r16,176(sp)
8111f7e8:	00000306 	br	8111f7f8 <___svfprintf_internal_r+0xf04>
8111f7ec:	8c7ffc04 	addi	r17,r17,-16
8111f7f0:	42000204 	addi	r8,r8,8
8111f7f4:	e440110e 	bge	fp,r17,8111f83c <___svfprintf_internal_r+0xf48>
8111f7f8:	18c00404 	addi	r3,r3,16
8111f7fc:	10800044 	addi	r2,r2,1
8111f800:	45400015 	stw	r21,0(r8)
8111f804:	47000115 	stw	fp,4(r8)
8111f808:	d8c02015 	stw	r3,128(sp)
8111f80c:	d8801f15 	stw	r2,124(sp)
8111f810:	a0bff60e 	bge	r20,r2,8111f7ec <__reset+0xfb0ff7ec>
8111f814:	d9801e04 	addi	r6,sp,120
8111f818:	800b883a 	mov	r5,r16
8111f81c:	9809883a 	mov	r4,r19
8111f820:	112b5140 	call	8112b514 <__ssprint_r>
8111f824:	103d1a1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f828:	8c7ffc04 	addi	r17,r17,-16
8111f82c:	d8c02017 	ldw	r3,128(sp)
8111f830:	d8801f17 	ldw	r2,124(sp)
8111f834:	da000404 	addi	r8,sp,16
8111f838:	e47fef16 	blt	fp,r17,8111f7f8 <__reset+0xfb0ff7f8>
8111f83c:	9021883a 	mov	r16,r18
8111f840:	b025883a 	mov	r18,r22
8111f844:	882d883a 	mov	r22,r17
8111f848:	dc403017 	ldw	r17,192(sp)
8111f84c:	d9002b17 	ldw	r4,172(sp)
8111f850:	1d87883a 	add	r3,r3,r22
8111f854:	10800044 	addi	r2,r2,1
8111f858:	41000015 	stw	r4,0(r8)
8111f85c:	45800115 	stw	r22,4(r8)
8111f860:	d8c02015 	stw	r3,128(sp)
8111f864:	d8801f15 	stw	r2,124(sp)
8111f868:	010001c4 	movi	r4,7
8111f86c:	20819a16 	blt	r4,r2,8111fed8 <___svfprintf_internal_r+0x15e4>
8111f870:	42000204 	addi	r8,r8,8
8111f874:	003e3506 	br	8111f14c <__reset+0xfb0ff14c>
8111f878:	d9403317 	ldw	r5,204(sp)
8111f87c:	00800044 	movi	r2,1
8111f880:	18c00044 	addi	r3,r3,1
8111f884:	1141710e 	bge	r2,r5,8111fe4c <___svfprintf_internal_r+0x1558>
8111f888:	dc401f17 	ldw	r17,124(sp)
8111f88c:	00800044 	movi	r2,1
8111f890:	40800115 	stw	r2,4(r8)
8111f894:	8c400044 	addi	r17,r17,1
8111f898:	44000015 	stw	r16,0(r8)
8111f89c:	d8c02015 	stw	r3,128(sp)
8111f8a0:	dc401f15 	stw	r17,124(sp)
8111f8a4:	008001c4 	movi	r2,7
8111f8a8:	14417416 	blt	r2,r17,8111fe7c <___svfprintf_internal_r+0x1588>
8111f8ac:	42000204 	addi	r8,r8,8
8111f8b0:	d8803817 	ldw	r2,224(sp)
8111f8b4:	d9003417 	ldw	r4,208(sp)
8111f8b8:	8c400044 	addi	r17,r17,1
8111f8bc:	10c7883a 	add	r3,r2,r3
8111f8c0:	40800115 	stw	r2,4(r8)
8111f8c4:	41000015 	stw	r4,0(r8)
8111f8c8:	d8c02015 	stw	r3,128(sp)
8111f8cc:	dc401f15 	stw	r17,124(sp)
8111f8d0:	008001c4 	movi	r2,7
8111f8d4:	14417216 	blt	r2,r17,8111fea0 <___svfprintf_internal_r+0x15ac>
8111f8d8:	45800204 	addi	r22,r8,8
8111f8dc:	d9003617 	ldw	r4,216(sp)
8111f8e0:	d9403717 	ldw	r5,220(sp)
8111f8e4:	000d883a 	mov	r6,zero
8111f8e8:	000f883a 	mov	r7,zero
8111f8ec:	d8c03d15 	stw	r3,244(sp)
8111f8f0:	113150c0 	call	8113150c <__eqdf2>
8111f8f4:	d8c03d17 	ldw	r3,244(sp)
8111f8f8:	1000b326 	beq	r2,zero,8111fbc8 <___svfprintf_internal_r+0x12d4>
8111f8fc:	d9403317 	ldw	r5,204(sp)
8111f900:	84000044 	addi	r16,r16,1
8111f904:	8c400044 	addi	r17,r17,1
8111f908:	28bfffc4 	addi	r2,r5,-1
8111f90c:	1887883a 	add	r3,r3,r2
8111f910:	b0800115 	stw	r2,4(r22)
8111f914:	b4000015 	stw	r16,0(r22)
8111f918:	d8c02015 	stw	r3,128(sp)
8111f91c:	dc401f15 	stw	r17,124(sp)
8111f920:	008001c4 	movi	r2,7
8111f924:	1440d216 	blt	r2,r17,8111fc70 <___svfprintf_internal_r+0x137c>
8111f928:	b5800204 	addi	r22,r22,8
8111f92c:	d9003b17 	ldw	r4,236(sp)
8111f930:	df0022c4 	addi	fp,sp,139
8111f934:	8c400044 	addi	r17,r17,1
8111f938:	20c7883a 	add	r3,r4,r3
8111f93c:	b7000015 	stw	fp,0(r22)
8111f940:	b1000115 	stw	r4,4(r22)
8111f944:	d8c02015 	stw	r3,128(sp)
8111f948:	dc401f15 	stw	r17,124(sp)
8111f94c:	008001c4 	movi	r2,7
8111f950:	14400e16 	blt	r2,r17,8111f98c <___svfprintf_internal_r+0x1098>
8111f954:	b2000204 	addi	r8,r22,8
8111f958:	003e3c06 	br	8111f24c <__reset+0xfb0ff24c>
8111f95c:	01204574 	movhi	r4,33045
8111f960:	2130ba84 	addi	r4,r4,-15638
8111f964:	d9002b15 	stw	r4,172(sp)
8111f968:	d9002b17 	ldw	r4,172(sp)
8111f96c:	1c07883a 	add	r3,r3,r16
8111f970:	44000115 	stw	r16,4(r8)
8111f974:	41000015 	stw	r4,0(r8)
8111f978:	10800044 	addi	r2,r2,1
8111f97c:	d8c02015 	stw	r3,128(sp)
8111f980:	d8801f15 	stw	r2,124(sp)
8111f984:	010001c4 	movi	r4,7
8111f988:	20be2f0e 	bge	r4,r2,8111f248 <__reset+0xfb0ff248>
8111f98c:	d9402c17 	ldw	r5,176(sp)
8111f990:	d9801e04 	addi	r6,sp,120
8111f994:	9809883a 	mov	r4,r19
8111f998:	112b5140 	call	8112b514 <__ssprint_r>
8111f99c:	103cbc1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f9a0:	d8c02017 	ldw	r3,128(sp)
8111f9a4:	da000404 	addi	r8,sp,16
8111f9a8:	003e2806 	br	8111f24c <__reset+0xfb0ff24c>
8111f9ac:	d9402c17 	ldw	r5,176(sp)
8111f9b0:	d9801e04 	addi	r6,sp,120
8111f9b4:	9809883a 	mov	r4,r19
8111f9b8:	112b5140 	call	8112b514 <__ssprint_r>
8111f9bc:	103e5f26 	beq	r2,zero,8111f33c <__reset+0xfb0ff33c>
8111f9c0:	003cb306 	br	8111ec90 <__reset+0xfb0fec90>
8111f9c4:	d9402c17 	ldw	r5,176(sp)
8111f9c8:	d9801e04 	addi	r6,sp,120
8111f9cc:	9809883a 	mov	r4,r19
8111f9d0:	112b5140 	call	8112b514 <__ssprint_r>
8111f9d4:	103cae1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f9d8:	d8c02017 	ldw	r3,128(sp)
8111f9dc:	da000404 	addi	r8,sp,16
8111f9e0:	003e0d06 	br	8111f218 <__reset+0xfb0ff218>
8111f9e4:	d9402c17 	ldw	r5,176(sp)
8111f9e8:	d9801e04 	addi	r6,sp,120
8111f9ec:	9809883a 	mov	r4,r19
8111f9f0:	112b5140 	call	8112b514 <__ssprint_r>
8111f9f4:	103ca61e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111f9f8:	d8c02017 	ldw	r3,128(sp)
8111f9fc:	da000404 	addi	r8,sp,16
8111fa00:	003dc106 	br	8111f108 <__reset+0xfb0ff108>
8111fa04:	d9402c17 	ldw	r5,176(sp)
8111fa08:	d9801e04 	addi	r6,sp,120
8111fa0c:	9809883a 	mov	r4,r19
8111fa10:	112b5140 	call	8112b514 <__ssprint_r>
8111fa14:	103c9e1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fa18:	d8c02017 	ldw	r3,128(sp)
8111fa1c:	da000404 	addi	r8,sp,16
8111fa20:	003dc706 	br	8111f140 <__reset+0xfb0ff140>
8111fa24:	d8802917 	ldw	r2,164(sp)
8111fa28:	d8002785 	stb	zero,158(sp)
8111fa2c:	103f0816 	blt	r2,zero,8111f650 <__reset+0xfb0ff650>
8111fa30:	00ffdfc4 	movi	r3,-129
8111fa34:	a584b03a 	or	r2,r20,r22
8111fa38:	90e4703a 	and	r18,r18,r3
8111fa3c:	103c8126 	beq	r2,zero,8111ec44 <__reset+0xfb0fec44>
8111fa40:	0039883a 	mov	fp,zero
8111fa44:	003e7606 	br	8111f420 <__reset+0xfb0ff420>
8111fa48:	9080040c 	andi	r2,r18,16
8111fa4c:	10013d26 	beq	r2,zero,8111ff44 <___svfprintf_internal_r+0x1650>
8111fa50:	d9002d17 	ldw	r4,180(sp)
8111fa54:	d9402917 	ldw	r5,164(sp)
8111fa58:	d8002785 	stb	zero,158(sp)
8111fa5c:	20800104 	addi	r2,r4,4
8111fa60:	25000017 	ldw	r20,0(r4)
8111fa64:	002d883a 	mov	r22,zero
8111fa68:	28013f16 	blt	r5,zero,8111ff68 <___svfprintf_internal_r+0x1674>
8111fa6c:	00ffdfc4 	movi	r3,-129
8111fa70:	d8802d15 	stw	r2,180(sp)
8111fa74:	90e4703a 	and	r18,r18,r3
8111fa78:	a03d2b26 	beq	r20,zero,8111ef28 <__reset+0xfb0fef28>
8111fa7c:	0039883a 	mov	fp,zero
8111fa80:	003d2e06 	br	8111ef3c <__reset+0xfb0fef3c>
8111fa84:	dc402617 	ldw	r17,152(sp)
8111fa88:	0441830e 	bge	zero,r17,81120098 <___svfprintf_internal_r+0x17a4>
8111fa8c:	dc403217 	ldw	r17,200(sp)
8111fa90:	d8803317 	ldw	r2,204(sp)
8111fa94:	1440010e 	bge	r2,r17,8111fa9c <___svfprintf_internal_r+0x11a8>
8111fa98:	1023883a 	mov	r17,r2
8111fa9c:	04400a0e 	bge	zero,r17,8111fac8 <___svfprintf_internal_r+0x11d4>
8111faa0:	d8801f17 	ldw	r2,124(sp)
8111faa4:	1c47883a 	add	r3,r3,r17
8111faa8:	44000015 	stw	r16,0(r8)
8111faac:	10800044 	addi	r2,r2,1
8111fab0:	44400115 	stw	r17,4(r8)
8111fab4:	d8c02015 	stw	r3,128(sp)
8111fab8:	d8801f15 	stw	r2,124(sp)
8111fabc:	010001c4 	movi	r4,7
8111fac0:	20827516 	blt	r4,r2,81120498 <___svfprintf_internal_r+0x1ba4>
8111fac4:	42000204 	addi	r8,r8,8
8111fac8:	88027b16 	blt	r17,zero,811204b8 <___svfprintf_internal_r+0x1bc4>
8111facc:	d9003217 	ldw	r4,200(sp)
8111fad0:	2463c83a 	sub	r17,r4,r17
8111fad4:	0440990e 	bge	zero,r17,8111fd3c <___svfprintf_internal_r+0x1448>
8111fad8:	05800404 	movi	r22,16
8111fadc:	d8801f17 	ldw	r2,124(sp)
8111fae0:	b441530e 	bge	r22,r17,81120030 <___svfprintf_internal_r+0x173c>
8111fae4:	01204574 	movhi	r4,33045
8111fae8:	2130ba84 	addi	r4,r4,-15638
8111faec:	d9002b15 	stw	r4,172(sp)
8111faf0:	070001c4 	movi	fp,7
8111faf4:	dd002c17 	ldw	r20,176(sp)
8111faf8:	00000306 	br	8111fb08 <___svfprintf_internal_r+0x1214>
8111fafc:	42000204 	addi	r8,r8,8
8111fb00:	8c7ffc04 	addi	r17,r17,-16
8111fb04:	b4414d0e 	bge	r22,r17,8112003c <___svfprintf_internal_r+0x1748>
8111fb08:	18c00404 	addi	r3,r3,16
8111fb0c:	10800044 	addi	r2,r2,1
8111fb10:	45400015 	stw	r21,0(r8)
8111fb14:	45800115 	stw	r22,4(r8)
8111fb18:	d8c02015 	stw	r3,128(sp)
8111fb1c:	d8801f15 	stw	r2,124(sp)
8111fb20:	e0bff60e 	bge	fp,r2,8111fafc <__reset+0xfb0ffafc>
8111fb24:	d9801e04 	addi	r6,sp,120
8111fb28:	a00b883a 	mov	r5,r20
8111fb2c:	9809883a 	mov	r4,r19
8111fb30:	112b5140 	call	8112b514 <__ssprint_r>
8111fb34:	103c561e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fb38:	d8c02017 	ldw	r3,128(sp)
8111fb3c:	d8801f17 	ldw	r2,124(sp)
8111fb40:	da000404 	addi	r8,sp,16
8111fb44:	003fee06 	br	8111fb00 <__reset+0xfb0ffb00>
8111fb48:	d9402c17 	ldw	r5,176(sp)
8111fb4c:	d9801e04 	addi	r6,sp,120
8111fb50:	9809883a 	mov	r4,r19
8111fb54:	112b5140 	call	8112b514 <__ssprint_r>
8111fb58:	103c4d1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fb5c:	d8c02017 	ldw	r3,128(sp)
8111fb60:	df002787 	ldb	fp,158(sp)
8111fb64:	da000404 	addi	r8,sp,16
8111fb68:	003d5a06 	br	8111f0d4 <__reset+0xfb0ff0d4>
8111fb6c:	9080040c 	andi	r2,r18,16
8111fb70:	10005c26 	beq	r2,zero,8111fce4 <___svfprintf_internal_r+0x13f0>
8111fb74:	d9402d17 	ldw	r5,180(sp)
8111fb78:	d8c02917 	ldw	r3,164(sp)
8111fb7c:	d8002785 	stb	zero,158(sp)
8111fb80:	28800104 	addi	r2,r5,4
8111fb84:	2d000017 	ldw	r20,0(r5)
8111fb88:	002d883a 	mov	r22,zero
8111fb8c:	18005e16 	blt	r3,zero,8111fd08 <___svfprintf_internal_r+0x1414>
8111fb90:	00ffdfc4 	movi	r3,-129
8111fb94:	d8802d15 	stw	r2,180(sp)
8111fb98:	90e4703a 	and	r18,r18,r3
8111fb9c:	0039883a 	mov	fp,zero
8111fba0:	a03dfe26 	beq	r20,zero,8111f39c <__reset+0xfb0ff39c>
8111fba4:	00800244 	movi	r2,9
8111fba8:	153cb336 	bltu	r2,r20,8111ee78 <__reset+0xfb0fee78>
8111fbac:	a5000c04 	addi	r20,r20,48
8111fbb0:	dc001dc4 	addi	r16,sp,119
8111fbb4:	dd001dc5 	stb	r20,119(sp)
8111fbb8:	d8c02817 	ldw	r3,160(sp)
8111fbbc:	1c07c83a 	sub	r3,r3,r16
8111fbc0:	d8c02e15 	stw	r3,184(sp)
8111fbc4:	003cf506 	br	8111ef9c <__reset+0xfb0fef9c>
8111fbc8:	d8803317 	ldw	r2,204(sp)
8111fbcc:	143fffc4 	addi	r16,r2,-1
8111fbd0:	043f560e 	bge	zero,r16,8111f92c <__reset+0xfb0ff92c>
8111fbd4:	07000404 	movi	fp,16
8111fbd8:	e403530e 	bge	fp,r16,81120928 <___svfprintf_internal_r+0x2034>
8111fbdc:	01604574 	movhi	r5,33045
8111fbe0:	2970ba84 	addi	r5,r5,-15638
8111fbe4:	d9402b15 	stw	r5,172(sp)
8111fbe8:	01c001c4 	movi	r7,7
8111fbec:	dd002c17 	ldw	r20,176(sp)
8111fbf0:	00000306 	br	8111fc00 <___svfprintf_internal_r+0x130c>
8111fbf4:	843ffc04 	addi	r16,r16,-16
8111fbf8:	b5800204 	addi	r22,r22,8
8111fbfc:	e400130e 	bge	fp,r16,8111fc4c <___svfprintf_internal_r+0x1358>
8111fc00:	18c00404 	addi	r3,r3,16
8111fc04:	8c400044 	addi	r17,r17,1
8111fc08:	b5400015 	stw	r21,0(r22)
8111fc0c:	b7000115 	stw	fp,4(r22)
8111fc10:	d8c02015 	stw	r3,128(sp)
8111fc14:	dc401f15 	stw	r17,124(sp)
8111fc18:	3c7ff60e 	bge	r7,r17,8111fbf4 <__reset+0xfb0ffbf4>
8111fc1c:	d9801e04 	addi	r6,sp,120
8111fc20:	a00b883a 	mov	r5,r20
8111fc24:	9809883a 	mov	r4,r19
8111fc28:	d9c03d15 	stw	r7,244(sp)
8111fc2c:	112b5140 	call	8112b514 <__ssprint_r>
8111fc30:	d9c03d17 	ldw	r7,244(sp)
8111fc34:	103c161e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fc38:	843ffc04 	addi	r16,r16,-16
8111fc3c:	d8c02017 	ldw	r3,128(sp)
8111fc40:	dc401f17 	ldw	r17,124(sp)
8111fc44:	dd800404 	addi	r22,sp,16
8111fc48:	e43fed16 	blt	fp,r16,8111fc00 <__reset+0xfb0ffc00>
8111fc4c:	d8802b17 	ldw	r2,172(sp)
8111fc50:	1c07883a 	add	r3,r3,r16
8111fc54:	8c400044 	addi	r17,r17,1
8111fc58:	b0800015 	stw	r2,0(r22)
8111fc5c:	b4000115 	stw	r16,4(r22)
8111fc60:	d8c02015 	stw	r3,128(sp)
8111fc64:	dc401f15 	stw	r17,124(sp)
8111fc68:	008001c4 	movi	r2,7
8111fc6c:	147f2e0e 	bge	r2,r17,8111f928 <__reset+0xfb0ff928>
8111fc70:	d9402c17 	ldw	r5,176(sp)
8111fc74:	d9801e04 	addi	r6,sp,120
8111fc78:	9809883a 	mov	r4,r19
8111fc7c:	112b5140 	call	8112b514 <__ssprint_r>
8111fc80:	103c031e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fc84:	d8c02017 	ldw	r3,128(sp)
8111fc88:	dc401f17 	ldw	r17,124(sp)
8111fc8c:	dd800404 	addi	r22,sp,16
8111fc90:	003f2606 	br	8111f92c <__reset+0xfb0ff92c>
8111fc94:	9080040c 	andi	r2,r18,16
8111fc98:	1000c326 	beq	r2,zero,8111ffa8 <___svfprintf_internal_r+0x16b4>
8111fc9c:	d8802d17 	ldw	r2,180(sp)
8111fca0:	15000017 	ldw	r20,0(r2)
8111fca4:	10800104 	addi	r2,r2,4
8111fca8:	d8802d15 	stw	r2,180(sp)
8111fcac:	a02dd7fa 	srai	r22,r20,31
8111fcb0:	b005883a 	mov	r2,r22
8111fcb4:	103c680e 	bge	r2,zero,8111ee58 <__reset+0xfb0fee58>
8111fcb8:	0529c83a 	sub	r20,zero,r20
8111fcbc:	a004c03a 	cmpne	r2,r20,zero
8111fcc0:	05adc83a 	sub	r22,zero,r22
8111fcc4:	b0adc83a 	sub	r22,r22,r2
8111fcc8:	d8802917 	ldw	r2,164(sp)
8111fccc:	07000b44 	movi	fp,45
8111fcd0:	df002785 	stb	fp,158(sp)
8111fcd4:	10022e16 	blt	r2,zero,81120590 <___svfprintf_internal_r+0x1c9c>
8111fcd8:	00bfdfc4 	movi	r2,-129
8111fcdc:	90a4703a 	and	r18,r18,r2
8111fce0:	003c6406 	br	8111ee74 <__reset+0xfb0fee74>
8111fce4:	9080100c 	andi	r2,r18,64
8111fce8:	d8002785 	stb	zero,158(sp)
8111fcec:	10012526 	beq	r2,zero,81120184 <___svfprintf_internal_r+0x1890>
8111fcf0:	d9002d17 	ldw	r4,180(sp)
8111fcf4:	d9402917 	ldw	r5,164(sp)
8111fcf8:	002d883a 	mov	r22,zero
8111fcfc:	20800104 	addi	r2,r4,4
8111fd00:	2500000b 	ldhu	r20,0(r4)
8111fd04:	283fa20e 	bge	r5,zero,8111fb90 <__reset+0xfb0ffb90>
8111fd08:	d8802d15 	stw	r2,180(sp)
8111fd0c:	0039883a 	mov	fp,zero
8111fd10:	a584b03a 	or	r2,r20,r22
8111fd14:	103c571e 	bne	r2,zero,8111ee74 <__reset+0xfb0fee74>
8111fd18:	00800044 	movi	r2,1
8111fd1c:	003e5006 	br	8111f660 <__reset+0xfb0ff660>
8111fd20:	d9402c17 	ldw	r5,176(sp)
8111fd24:	d9801e04 	addi	r6,sp,120
8111fd28:	9809883a 	mov	r4,r19
8111fd2c:	112b5140 	call	8112b514 <__ssprint_r>
8111fd30:	103bd71e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fd34:	d8c02017 	ldw	r3,128(sp)
8111fd38:	da000404 	addi	r8,sp,16
8111fd3c:	d9003217 	ldw	r4,200(sp)
8111fd40:	d8802617 	ldw	r2,152(sp)
8111fd44:	d9403317 	ldw	r5,204(sp)
8111fd48:	8123883a 	add	r17,r16,r4
8111fd4c:	11400216 	blt	r2,r5,8111fd58 <___svfprintf_internal_r+0x1464>
8111fd50:	9100004c 	andi	r4,r18,1
8111fd54:	20000d26 	beq	r4,zero,8111fd8c <___svfprintf_internal_r+0x1498>
8111fd58:	d9003817 	ldw	r4,224(sp)
8111fd5c:	d9403417 	ldw	r5,208(sp)
8111fd60:	1907883a 	add	r3,r3,r4
8111fd64:	d9001f17 	ldw	r4,124(sp)
8111fd68:	41400015 	stw	r5,0(r8)
8111fd6c:	d9403817 	ldw	r5,224(sp)
8111fd70:	21000044 	addi	r4,r4,1
8111fd74:	d8c02015 	stw	r3,128(sp)
8111fd78:	41400115 	stw	r5,4(r8)
8111fd7c:	d9001f15 	stw	r4,124(sp)
8111fd80:	014001c4 	movi	r5,7
8111fd84:	2901dc16 	blt	r5,r4,811204f8 <___svfprintf_internal_r+0x1c04>
8111fd88:	42000204 	addi	r8,r8,8
8111fd8c:	d9003317 	ldw	r4,204(sp)
8111fd90:	8121883a 	add	r16,r16,r4
8111fd94:	2085c83a 	sub	r2,r4,r2
8111fd98:	8461c83a 	sub	r16,r16,r17
8111fd9c:	1400010e 	bge	r2,r16,8111fda4 <___svfprintf_internal_r+0x14b0>
8111fda0:	1021883a 	mov	r16,r2
8111fda4:	04000a0e 	bge	zero,r16,8111fdd0 <___svfprintf_internal_r+0x14dc>
8111fda8:	d9001f17 	ldw	r4,124(sp)
8111fdac:	1c07883a 	add	r3,r3,r16
8111fdb0:	44400015 	stw	r17,0(r8)
8111fdb4:	21000044 	addi	r4,r4,1
8111fdb8:	44000115 	stw	r16,4(r8)
8111fdbc:	d8c02015 	stw	r3,128(sp)
8111fdc0:	d9001f15 	stw	r4,124(sp)
8111fdc4:	014001c4 	movi	r5,7
8111fdc8:	2901e616 	blt	r5,r4,81120564 <___svfprintf_internal_r+0x1c70>
8111fdcc:	42000204 	addi	r8,r8,8
8111fdd0:	8001f616 	blt	r16,zero,811205ac <___svfprintf_internal_r+0x1cb8>
8111fdd4:	1421c83a 	sub	r16,r2,r16
8111fdd8:	043d1c0e 	bge	zero,r16,8111f24c <__reset+0xfb0ff24c>
8111fddc:	04400404 	movi	r17,16
8111fde0:	d8801f17 	ldw	r2,124(sp)
8111fde4:	8c3edd0e 	bge	r17,r16,8111f95c <__reset+0xfb0ff95c>
8111fde8:	01604574 	movhi	r5,33045
8111fdec:	2970ba84 	addi	r5,r5,-15638
8111fdf0:	d9402b15 	stw	r5,172(sp)
8111fdf4:	058001c4 	movi	r22,7
8111fdf8:	dd002c17 	ldw	r20,176(sp)
8111fdfc:	00000306 	br	8111fe0c <___svfprintf_internal_r+0x1518>
8111fe00:	42000204 	addi	r8,r8,8
8111fe04:	843ffc04 	addi	r16,r16,-16
8111fe08:	8c3ed70e 	bge	r17,r16,8111f968 <__reset+0xfb0ff968>
8111fe0c:	18c00404 	addi	r3,r3,16
8111fe10:	10800044 	addi	r2,r2,1
8111fe14:	45400015 	stw	r21,0(r8)
8111fe18:	44400115 	stw	r17,4(r8)
8111fe1c:	d8c02015 	stw	r3,128(sp)
8111fe20:	d8801f15 	stw	r2,124(sp)
8111fe24:	b0bff60e 	bge	r22,r2,8111fe00 <__reset+0xfb0ffe00>
8111fe28:	d9801e04 	addi	r6,sp,120
8111fe2c:	a00b883a 	mov	r5,r20
8111fe30:	9809883a 	mov	r4,r19
8111fe34:	112b5140 	call	8112b514 <__ssprint_r>
8111fe38:	103b951e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fe3c:	d8c02017 	ldw	r3,128(sp)
8111fe40:	d8801f17 	ldw	r2,124(sp)
8111fe44:	da000404 	addi	r8,sp,16
8111fe48:	003fee06 	br	8111fe04 <__reset+0xfb0ffe04>
8111fe4c:	9088703a 	and	r4,r18,r2
8111fe50:	203e8d1e 	bne	r4,zero,8111f888 <__reset+0xfb0ff888>
8111fe54:	dc401f17 	ldw	r17,124(sp)
8111fe58:	40800115 	stw	r2,4(r8)
8111fe5c:	44000015 	stw	r16,0(r8)
8111fe60:	8c400044 	addi	r17,r17,1
8111fe64:	d8c02015 	stw	r3,128(sp)
8111fe68:	dc401f15 	stw	r17,124(sp)
8111fe6c:	008001c4 	movi	r2,7
8111fe70:	147f7f16 	blt	r2,r17,8111fc70 <__reset+0xfb0ffc70>
8111fe74:	45800204 	addi	r22,r8,8
8111fe78:	003eac06 	br	8111f92c <__reset+0xfb0ff92c>
8111fe7c:	d9402c17 	ldw	r5,176(sp)
8111fe80:	d9801e04 	addi	r6,sp,120
8111fe84:	9809883a 	mov	r4,r19
8111fe88:	112b5140 	call	8112b514 <__ssprint_r>
8111fe8c:	103b801e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111fe90:	d8c02017 	ldw	r3,128(sp)
8111fe94:	dc401f17 	ldw	r17,124(sp)
8111fe98:	da000404 	addi	r8,sp,16
8111fe9c:	003e8406 	br	8111f8b0 <__reset+0xfb0ff8b0>
8111fea0:	d9402c17 	ldw	r5,176(sp)
8111fea4:	d9801e04 	addi	r6,sp,120
8111fea8:	9809883a 	mov	r4,r19
8111feac:	112b5140 	call	8112b514 <__ssprint_r>
8111feb0:	103b771e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111feb4:	d8c02017 	ldw	r3,128(sp)
8111feb8:	dc401f17 	ldw	r17,124(sp)
8111febc:	dd800404 	addi	r22,sp,16
8111fec0:	003e8606 	br	8111f8dc <__reset+0xfb0ff8dc>
8111fec4:	0029883a 	mov	r20,zero
8111fec8:	a5000c04 	addi	r20,r20,48
8111fecc:	dc001dc4 	addi	r16,sp,119
8111fed0:	dd001dc5 	stb	r20,119(sp)
8111fed4:	003f3806 	br	8111fbb8 <__reset+0xfb0ffbb8>
8111fed8:	d9402c17 	ldw	r5,176(sp)
8111fedc:	d9801e04 	addi	r6,sp,120
8111fee0:	9809883a 	mov	r4,r19
8111fee4:	112b5140 	call	8112b514 <__ssprint_r>
8111fee8:	103b691e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8111feec:	d8c02017 	ldw	r3,128(sp)
8111fef0:	da000404 	addi	r8,sp,16
8111fef4:	003c9506 	br	8111f14c <__reset+0xfb0ff14c>
8111fef8:	d9003617 	ldw	r4,216(sp)
8111fefc:	d9403717 	ldw	r5,220(sp)
8111ff00:	da003e15 	stw	r8,248(sp)
8111ff04:	11293280 	call	81129328 <__fpclassifyd>
8111ff08:	da003e17 	ldw	r8,248(sp)
8111ff0c:	1000bd1e 	bne	r2,zero,81120204 <___svfprintf_internal_r+0x1910>
8111ff10:	008011c4 	movi	r2,71
8111ff14:	14411e0e 	bge	r2,r17,81120390 <___svfprintf_internal_r+0x1a9c>
8111ff18:	04204574 	movhi	r16,33045
8111ff1c:	8430ad04 	addi	r16,r16,-15692
8111ff20:	00c000c4 	movi	r3,3
8111ff24:	00bfdfc4 	movi	r2,-129
8111ff28:	d8c02a15 	stw	r3,168(sp)
8111ff2c:	90a4703a 	and	r18,r18,r2
8111ff30:	df002783 	ldbu	fp,158(sp)
8111ff34:	d8c02e15 	stw	r3,184(sp)
8111ff38:	d8002915 	stw	zero,164(sp)
8111ff3c:	d8003215 	stw	zero,200(sp)
8111ff40:	003c1c06 	br	8111efb4 <__reset+0xfb0fefb4>
8111ff44:	9080100c 	andi	r2,r18,64
8111ff48:	d8002785 	stb	zero,158(sp)
8111ff4c:	10009426 	beq	r2,zero,811201a0 <___svfprintf_internal_r+0x18ac>
8111ff50:	d8c02d17 	ldw	r3,180(sp)
8111ff54:	d9002917 	ldw	r4,164(sp)
8111ff58:	002d883a 	mov	r22,zero
8111ff5c:	18800104 	addi	r2,r3,4
8111ff60:	1d00000b 	ldhu	r20,0(r3)
8111ff64:	203ec10e 	bge	r4,zero,8111fa6c <__reset+0xfb0ffa6c>
8111ff68:	a586b03a 	or	r3,r20,r22
8111ff6c:	d8802d15 	stw	r2,180(sp)
8111ff70:	183ec21e 	bne	r3,zero,8111fa7c <__reset+0xfb0ffa7c>
8111ff74:	0039883a 	mov	fp,zero
8111ff78:	0005883a 	mov	r2,zero
8111ff7c:	003db806 	br	8111f660 <__reset+0xfb0ff660>
8111ff80:	d8802d17 	ldw	r2,180(sp)
8111ff84:	d8c02d17 	ldw	r3,180(sp)
8111ff88:	d9002d17 	ldw	r4,180(sp)
8111ff8c:	10800017 	ldw	r2,0(r2)
8111ff90:	18c00117 	ldw	r3,4(r3)
8111ff94:	21000204 	addi	r4,r4,8
8111ff98:	d8803615 	stw	r2,216(sp)
8111ff9c:	d8c03715 	stw	r3,220(sp)
8111ffa0:	d9002d15 	stw	r4,180(sp)
8111ffa4:	003b8206 	br	8111edb0 <__reset+0xfb0fedb0>
8111ffa8:	9080100c 	andi	r2,r18,64
8111ffac:	10010726 	beq	r2,zero,811203cc <___svfprintf_internal_r+0x1ad8>
8111ffb0:	d8c02d17 	ldw	r3,180(sp)
8111ffb4:	1d00000f 	ldh	r20,0(r3)
8111ffb8:	18c00104 	addi	r3,r3,4
8111ffbc:	d8c02d15 	stw	r3,180(sp)
8111ffc0:	a02dd7fa 	srai	r22,r20,31
8111ffc4:	b005883a 	mov	r2,r22
8111ffc8:	003ba206 	br	8111ee54 <__reset+0xfb0fee54>
8111ffcc:	9080100c 	andi	r2,r18,64
8111ffd0:	10010526 	beq	r2,zero,811203e8 <___svfprintf_internal_r+0x1af4>
8111ffd4:	d9002d17 	ldw	r4,180(sp)
8111ffd8:	002d883a 	mov	r22,zero
8111ffdc:	2500000b 	ldhu	r20,0(r4)
8111ffe0:	21000104 	addi	r4,r4,4
8111ffe4:	d9002d15 	stw	r4,180(sp)
8111ffe8:	003cfe06 	br	8111f3e4 <__reset+0xfb0ff3e4>
8111ffec:	bc400007 	ldb	r17,0(r23)
8111fff0:	003a9606 	br	8111ea4c <__reset+0xfb0fea4c>
8111fff4:	9080040c 	andi	r2,r18,16
8111fff8:	10010126 	beq	r2,zero,81120400 <___svfprintf_internal_r+0x1b0c>
8111fffc:	d9402d17 	ldw	r5,180(sp)
81120000:	d8c02f17 	ldw	r3,188(sp)
81120004:	28800017 	ldw	r2,0(r5)
81120008:	29400104 	addi	r5,r5,4
8112000c:	d9402d15 	stw	r5,180(sp)
81120010:	10c00015 	stw	r3,0(r2)
81120014:	003a6406 	br	8111e9a8 <__reset+0xfb0fe9a8>
81120018:	d9002917 	ldw	r4,164(sp)
8112001c:	d8002785 	stb	zero,158(sp)
81120020:	203d8d16 	blt	r4,zero,8111f658 <__reset+0xfb0ff658>
81120024:	00bfdfc4 	movi	r2,-129
81120028:	90a4703a 	and	r18,r18,r2
8112002c:	003b0506 	br	8111ec44 <__reset+0xfb0fec44>
81120030:	01604574 	movhi	r5,33045
81120034:	2970ba84 	addi	r5,r5,-15638
81120038:	d9402b15 	stw	r5,172(sp)
8112003c:	d9402b17 	ldw	r5,172(sp)
81120040:	1c47883a 	add	r3,r3,r17
81120044:	10800044 	addi	r2,r2,1
81120048:	41400015 	stw	r5,0(r8)
8112004c:	44400115 	stw	r17,4(r8)
81120050:	d8c02015 	stw	r3,128(sp)
81120054:	d8801f15 	stw	r2,124(sp)
81120058:	010001c4 	movi	r4,7
8112005c:	20bf3016 	blt	r4,r2,8111fd20 <__reset+0xfb0ffd20>
81120060:	42000204 	addi	r8,r8,8
81120064:	003f3506 	br	8111fd3c <__reset+0xfb0ffd3c>
81120068:	01204574 	movhi	r4,33045
8112006c:	2130ba84 	addi	r4,r4,-15638
81120070:	d9002b15 	stw	r4,172(sp)
81120074:	003c5e06 	br	8111f1f0 <__reset+0xfb0ff1f0>
81120078:	d9402c17 	ldw	r5,176(sp)
8112007c:	d9801e04 	addi	r6,sp,120
81120080:	9809883a 	mov	r4,r19
81120084:	112b5140 	call	8112b514 <__ssprint_r>
81120088:	103b011e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8112008c:	d8c02017 	ldw	r3,128(sp)
81120090:	da000404 	addi	r8,sp,16
81120094:	003d9306 	br	8111f6e4 <__reset+0xfb0ff6e4>
81120098:	d8801f17 	ldw	r2,124(sp)
8112009c:	01604574 	movhi	r5,33045
811200a0:	01000044 	movi	r4,1
811200a4:	18c00044 	addi	r3,r3,1
811200a8:	10800044 	addi	r2,r2,1
811200ac:	2970ba04 	addi	r5,r5,-15640
811200b0:	41000115 	stw	r4,4(r8)
811200b4:	41400015 	stw	r5,0(r8)
811200b8:	d8c02015 	stw	r3,128(sp)
811200bc:	d8801f15 	stw	r2,124(sp)
811200c0:	010001c4 	movi	r4,7
811200c4:	2080b516 	blt	r4,r2,8112039c <___svfprintf_internal_r+0x1aa8>
811200c8:	42000204 	addi	r8,r8,8
811200cc:	8800041e 	bne	r17,zero,811200e0 <___svfprintf_internal_r+0x17ec>
811200d0:	d8803317 	ldw	r2,204(sp)
811200d4:	1000021e 	bne	r2,zero,811200e0 <___svfprintf_internal_r+0x17ec>
811200d8:	9080004c 	andi	r2,r18,1
811200dc:	103c5b26 	beq	r2,zero,8111f24c <__reset+0xfb0ff24c>
811200e0:	d9003817 	ldw	r4,224(sp)
811200e4:	d8801f17 	ldw	r2,124(sp)
811200e8:	d9403417 	ldw	r5,208(sp)
811200ec:	20c7883a 	add	r3,r4,r3
811200f0:	10800044 	addi	r2,r2,1
811200f4:	41000115 	stw	r4,4(r8)
811200f8:	41400015 	stw	r5,0(r8)
811200fc:	d8c02015 	stw	r3,128(sp)
81120100:	d8801f15 	stw	r2,124(sp)
81120104:	010001c4 	movi	r4,7
81120108:	20818016 	blt	r4,r2,8112070c <___svfprintf_internal_r+0x1e18>
8112010c:	42000204 	addi	r8,r8,8
81120110:	0463c83a 	sub	r17,zero,r17
81120114:	0440cb0e 	bge	zero,r17,81120444 <___svfprintf_internal_r+0x1b50>
81120118:	05800404 	movi	r22,16
8112011c:	b440e80e 	bge	r22,r17,811204c0 <___svfprintf_internal_r+0x1bcc>
81120120:	01604574 	movhi	r5,33045
81120124:	2970ba84 	addi	r5,r5,-15638
81120128:	d9402b15 	stw	r5,172(sp)
8112012c:	070001c4 	movi	fp,7
81120130:	dd002c17 	ldw	r20,176(sp)
81120134:	00000306 	br	81120144 <___svfprintf_internal_r+0x1850>
81120138:	42000204 	addi	r8,r8,8
8112013c:	8c7ffc04 	addi	r17,r17,-16
81120140:	b440e20e 	bge	r22,r17,811204cc <___svfprintf_internal_r+0x1bd8>
81120144:	18c00404 	addi	r3,r3,16
81120148:	10800044 	addi	r2,r2,1
8112014c:	45400015 	stw	r21,0(r8)
81120150:	45800115 	stw	r22,4(r8)
81120154:	d8c02015 	stw	r3,128(sp)
81120158:	d8801f15 	stw	r2,124(sp)
8112015c:	e0bff60e 	bge	fp,r2,81120138 <__reset+0xfb100138>
81120160:	d9801e04 	addi	r6,sp,120
81120164:	a00b883a 	mov	r5,r20
81120168:	9809883a 	mov	r4,r19
8112016c:	112b5140 	call	8112b514 <__ssprint_r>
81120170:	103ac71e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
81120174:	d8c02017 	ldw	r3,128(sp)
81120178:	d8801f17 	ldw	r2,124(sp)
8112017c:	da000404 	addi	r8,sp,16
81120180:	003fee06 	br	8112013c <__reset+0xfb10013c>
81120184:	d8c02d17 	ldw	r3,180(sp)
81120188:	d9002917 	ldw	r4,164(sp)
8112018c:	002d883a 	mov	r22,zero
81120190:	18800104 	addi	r2,r3,4
81120194:	1d000017 	ldw	r20,0(r3)
81120198:	203e7d0e 	bge	r4,zero,8111fb90 <__reset+0xfb0ffb90>
8112019c:	003eda06 	br	8111fd08 <__reset+0xfb0ffd08>
811201a0:	d9402d17 	ldw	r5,180(sp)
811201a4:	d8c02917 	ldw	r3,164(sp)
811201a8:	002d883a 	mov	r22,zero
811201ac:	28800104 	addi	r2,r5,4
811201b0:	2d000017 	ldw	r20,0(r5)
811201b4:	183e2d0e 	bge	r3,zero,8111fa6c <__reset+0xfb0ffa6c>
811201b8:	003f6b06 	br	8111ff68 <__reset+0xfb0fff68>
811201bc:	d8c02d15 	stw	r3,180(sp)
811201c0:	0039883a 	mov	fp,zero
811201c4:	003ed206 	br	8111fd10 <__reset+0xfb0ffd10>
811201c8:	bc400043 	ldbu	r17,1(r23)
811201cc:	94800814 	ori	r18,r18,32
811201d0:	bdc00044 	addi	r23,r23,1
811201d4:	8c403fcc 	andi	r17,r17,255
811201d8:	8c40201c 	xori	r17,r17,128
811201dc:	8c7fe004 	addi	r17,r17,-128
811201e0:	003a1a06 	br	8111ea4c <__reset+0xfb0fea4c>
811201e4:	d9402c17 	ldw	r5,176(sp)
811201e8:	d9801e04 	addi	r6,sp,120
811201ec:	9809883a 	mov	r4,r19
811201f0:	112b5140 	call	8112b514 <__ssprint_r>
811201f4:	103aa61e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
811201f8:	d8c02017 	ldw	r3,128(sp)
811201fc:	da000404 	addi	r8,sp,16
81120200:	003d4a06 	br	8111f72c <__reset+0xfb0ff72c>
81120204:	d9002917 	ldw	r4,164(sp)
81120208:	05bff7c4 	movi	r22,-33
8112020c:	00bfffc4 	movi	r2,-1
81120210:	8dac703a 	and	r22,r17,r22
81120214:	20806a26 	beq	r4,r2,811203c0 <___svfprintf_internal_r+0x1acc>
81120218:	008011c4 	movi	r2,71
8112021c:	b0813726 	beq	r22,r2,811206fc <___svfprintf_internal_r+0x1e08>
81120220:	d9003717 	ldw	r4,220(sp)
81120224:	90c04014 	ori	r3,r18,256
81120228:	d8c02b15 	stw	r3,172(sp)
8112022c:	20015d16 	blt	r4,zero,811207a4 <___svfprintf_internal_r+0x1eb0>
81120230:	dd003717 	ldw	r20,220(sp)
81120234:	d8002a05 	stb	zero,168(sp)
81120238:	00801984 	movi	r2,102
8112023c:	88814026 	beq	r17,r2,81120740 <___svfprintf_internal_r+0x1e4c>
81120240:	00801184 	movi	r2,70
81120244:	88817126 	beq	r17,r2,8112080c <___svfprintf_internal_r+0x1f18>
81120248:	00801144 	movi	r2,69
8112024c:	b0816226 	beq	r22,r2,811207d8 <___svfprintf_internal_r+0x1ee4>
81120250:	d8c02917 	ldw	r3,164(sp)
81120254:	d8802104 	addi	r2,sp,132
81120258:	d8800315 	stw	r2,12(sp)
8112025c:	d9403617 	ldw	r5,216(sp)
81120260:	d8802504 	addi	r2,sp,148
81120264:	d8800215 	stw	r2,8(sp)
81120268:	d8802604 	addi	r2,sp,152
8112026c:	d8c00015 	stw	r3,0(sp)
81120270:	d8800115 	stw	r2,4(sp)
81120274:	01c00084 	movi	r7,2
81120278:	a00d883a 	mov	r6,r20
8112027c:	9809883a 	mov	r4,r19
81120280:	d8c03d15 	stw	r3,244(sp)
81120284:	da003e15 	stw	r8,248(sp)
81120288:	1124be00 	call	81124be0 <_dtoa_r>
8112028c:	1021883a 	mov	r16,r2
81120290:	008019c4 	movi	r2,103
81120294:	d8c03d17 	ldw	r3,244(sp)
81120298:	da003e17 	ldw	r8,248(sp)
8112029c:	8880e726 	beq	r17,r2,8112063c <___svfprintf_internal_r+0x1d48>
811202a0:	008011c4 	movi	r2,71
811202a4:	8880d426 	beq	r17,r2,811205f8 <___svfprintf_internal_r+0x1d04>
811202a8:	80f9883a 	add	fp,r16,r3
811202ac:	d9003617 	ldw	r4,216(sp)
811202b0:	000d883a 	mov	r6,zero
811202b4:	000f883a 	mov	r7,zero
811202b8:	a00b883a 	mov	r5,r20
811202bc:	da003e15 	stw	r8,248(sp)
811202c0:	113150c0 	call	8113150c <__eqdf2>
811202c4:	da003e17 	ldw	r8,248(sp)
811202c8:	1000e426 	beq	r2,zero,8112065c <___svfprintf_internal_r+0x1d68>
811202cc:	d8802117 	ldw	r2,132(sp)
811202d0:	1700062e 	bgeu	r2,fp,811202ec <___svfprintf_internal_r+0x19f8>
811202d4:	01000c04 	movi	r4,48
811202d8:	10c00044 	addi	r3,r2,1
811202dc:	d8c02115 	stw	r3,132(sp)
811202e0:	11000005 	stb	r4,0(r2)
811202e4:	d8802117 	ldw	r2,132(sp)
811202e8:	173ffb36 	bltu	r2,fp,811202d8 <__reset+0xfb1002d8>
811202ec:	1405c83a 	sub	r2,r2,r16
811202f0:	d8803315 	stw	r2,204(sp)
811202f4:	008011c4 	movi	r2,71
811202f8:	b080c526 	beq	r22,r2,81120610 <___svfprintf_internal_r+0x1d1c>
811202fc:	00801944 	movi	r2,101
81120300:	1441d90e 	bge	r2,r17,81120a68 <___svfprintf_internal_r+0x2174>
81120304:	d8c02617 	ldw	r3,152(sp)
81120308:	00801984 	movi	r2,102
8112030c:	d8c03215 	stw	r3,200(sp)
81120310:	88813426 	beq	r17,r2,811207e4 <___svfprintf_internal_r+0x1ef0>
81120314:	d8c03217 	ldw	r3,200(sp)
81120318:	d9003317 	ldw	r4,204(sp)
8112031c:	19012516 	blt	r3,r4,811207b4 <___svfprintf_internal_r+0x1ec0>
81120320:	9480004c 	andi	r18,r18,1
81120324:	9001841e 	bne	r18,zero,81120938 <___svfprintf_internal_r+0x2044>
81120328:	1805883a 	mov	r2,r3
8112032c:	1801cc16 	blt	r3,zero,81120a60 <___svfprintf_internal_r+0x216c>
81120330:	d8c03217 	ldw	r3,200(sp)
81120334:	044019c4 	movi	r17,103
81120338:	d8c02e15 	stw	r3,184(sp)
8112033c:	df002a07 	ldb	fp,168(sp)
81120340:	e000a61e 	bne	fp,zero,811205dc <___svfprintf_internal_r+0x1ce8>
81120344:	df002783 	ldbu	fp,158(sp)
81120348:	d8802a15 	stw	r2,168(sp)
8112034c:	dc802b17 	ldw	r18,172(sp)
81120350:	d8002915 	stw	zero,164(sp)
81120354:	003b1706 	br	8111efb4 <__reset+0xfb0fefb4>
81120358:	04204574 	movhi	r16,33045
8112035c:	8430aa04 	addi	r16,r16,-15704
81120360:	003aa606 	br	8111edfc <__reset+0xfb0fedfc>
81120364:	d9003917 	ldw	r4,228(sp)
81120368:	04001004 	movi	r16,64
8112036c:	800b883a 	mov	r5,r16
81120370:	111d2b40 	call	8111d2b4 <_malloc_r>
81120374:	d9002c17 	ldw	r4,176(sp)
81120378:	20800015 	stw	r2,0(r4)
8112037c:	20800415 	stw	r2,16(r4)
81120380:	1001cb26 	beq	r2,zero,81120ab0 <___svfprintf_internal_r+0x21bc>
81120384:	d8802c17 	ldw	r2,176(sp)
81120388:	14000515 	stw	r16,20(r2)
8112038c:	00397606 	br	8111e968 <__reset+0xfb0fe968>
81120390:	04204574 	movhi	r16,33045
81120394:	8430ac04 	addi	r16,r16,-15696
81120398:	003ee106 	br	8111ff20 <__reset+0xfb0fff20>
8112039c:	d9402c17 	ldw	r5,176(sp)
811203a0:	d9801e04 	addi	r6,sp,120
811203a4:	9809883a 	mov	r4,r19
811203a8:	112b5140 	call	8112b514 <__ssprint_r>
811203ac:	103a381e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
811203b0:	dc402617 	ldw	r17,152(sp)
811203b4:	d8c02017 	ldw	r3,128(sp)
811203b8:	da000404 	addi	r8,sp,16
811203bc:	003f4306 	br	811200cc <__reset+0xfb1000cc>
811203c0:	01400184 	movi	r5,6
811203c4:	d9402915 	stw	r5,164(sp)
811203c8:	003f9506 	br	81120220 <__reset+0xfb100220>
811203cc:	d9002d17 	ldw	r4,180(sp)
811203d0:	25000017 	ldw	r20,0(r4)
811203d4:	21000104 	addi	r4,r4,4
811203d8:	d9002d15 	stw	r4,180(sp)
811203dc:	a02dd7fa 	srai	r22,r20,31
811203e0:	b005883a 	mov	r2,r22
811203e4:	003a9b06 	br	8111ee54 <__reset+0xfb0fee54>
811203e8:	d9402d17 	ldw	r5,180(sp)
811203ec:	002d883a 	mov	r22,zero
811203f0:	2d000017 	ldw	r20,0(r5)
811203f4:	29400104 	addi	r5,r5,4
811203f8:	d9402d15 	stw	r5,180(sp)
811203fc:	003bf906 	br	8111f3e4 <__reset+0xfb0ff3e4>
81120400:	9480100c 	andi	r18,r18,64
81120404:	90006e26 	beq	r18,zero,811205c0 <___svfprintf_internal_r+0x1ccc>
81120408:	d9002d17 	ldw	r4,180(sp)
8112040c:	d9402f17 	ldw	r5,188(sp)
81120410:	20800017 	ldw	r2,0(r4)
81120414:	21000104 	addi	r4,r4,4
81120418:	d9002d15 	stw	r4,180(sp)
8112041c:	1140000d 	sth	r5,0(r2)
81120420:	00396106 	br	8111e9a8 <__reset+0xfb0fe9a8>
81120424:	d9402c17 	ldw	r5,176(sp)
81120428:	d9801e04 	addi	r6,sp,120
8112042c:	9809883a 	mov	r4,r19
81120430:	112b5140 	call	8112b514 <__ssprint_r>
81120434:	103a161e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
81120438:	d8c02017 	ldw	r3,128(sp)
8112043c:	d8801f17 	ldw	r2,124(sp)
81120440:	da000404 	addi	r8,sp,16
81120444:	d9403317 	ldw	r5,204(sp)
81120448:	10800044 	addi	r2,r2,1
8112044c:	44000015 	stw	r16,0(r8)
81120450:	28c7883a 	add	r3,r5,r3
81120454:	003b7706 	br	8111f234 <__reset+0xfb0ff234>
81120458:	8009883a 	mov	r4,r16
8112045c:	da003e15 	stw	r8,248(sp)
81120460:	111e5bc0 	call	8111e5bc <strlen>
81120464:	d8802e15 	stw	r2,184(sp)
81120468:	da003e17 	ldw	r8,248(sp)
8112046c:	103c280e 	bge	r2,zero,8111f510 <__reset+0xfb0ff510>
81120470:	0005883a 	mov	r2,zero
81120474:	003c2606 	br	8111f510 <__reset+0xfb0ff510>
81120478:	00bfffc4 	movi	r2,-1
8112047c:	003a0906 	br	8111eca4 <__reset+0xfb0feca4>
81120480:	01204574 	movhi	r4,33045
81120484:	2130be84 	addi	r4,r4,-15622
81120488:	d9003515 	stw	r4,212(sp)
8112048c:	003b0606 	br	8111f0a8 <__reset+0xfb0ff0a8>
81120490:	013fffc4 	movi	r4,-1
81120494:	003a2706 	br	8111ed34 <__reset+0xfb0fed34>
81120498:	d9402c17 	ldw	r5,176(sp)
8112049c:	d9801e04 	addi	r6,sp,120
811204a0:	9809883a 	mov	r4,r19
811204a4:	112b5140 	call	8112b514 <__ssprint_r>
811204a8:	1039f91e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
811204ac:	d8c02017 	ldw	r3,128(sp)
811204b0:	da000404 	addi	r8,sp,16
811204b4:	003d8406 	br	8111fac8 <__reset+0xfb0ffac8>
811204b8:	0023883a 	mov	r17,zero
811204bc:	003d8306 	br	8111facc <__reset+0xfb0ffacc>
811204c0:	01204574 	movhi	r4,33045
811204c4:	2130ba84 	addi	r4,r4,-15638
811204c8:	d9002b15 	stw	r4,172(sp)
811204cc:	d9002b17 	ldw	r4,172(sp)
811204d0:	1c47883a 	add	r3,r3,r17
811204d4:	10800044 	addi	r2,r2,1
811204d8:	41000015 	stw	r4,0(r8)
811204dc:	44400115 	stw	r17,4(r8)
811204e0:	d8c02015 	stw	r3,128(sp)
811204e4:	d8801f15 	stw	r2,124(sp)
811204e8:	010001c4 	movi	r4,7
811204ec:	20bfcd16 	blt	r4,r2,81120424 <__reset+0xfb100424>
811204f0:	42000204 	addi	r8,r8,8
811204f4:	003fd306 	br	81120444 <__reset+0xfb100444>
811204f8:	d9402c17 	ldw	r5,176(sp)
811204fc:	d9801e04 	addi	r6,sp,120
81120500:	9809883a 	mov	r4,r19
81120504:	112b5140 	call	8112b514 <__ssprint_r>
81120508:	1039e11e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
8112050c:	d8802617 	ldw	r2,152(sp)
81120510:	d8c02017 	ldw	r3,128(sp)
81120514:	da000404 	addi	r8,sp,16
81120518:	003e1c06 	br	8111fd8c <__reset+0xfb0ffd8c>
8112051c:	d8802917 	ldw	r2,164(sp)
81120520:	00c00184 	movi	r3,6
81120524:	1880012e 	bgeu	r3,r2,8112052c <___svfprintf_internal_r+0x1c38>
81120528:	1805883a 	mov	r2,r3
8112052c:	d8802e15 	stw	r2,184(sp)
81120530:	1000f316 	blt	r2,zero,81120900 <___svfprintf_internal_r+0x200c>
81120534:	04204574 	movhi	r16,33045
81120538:	d8802a15 	stw	r2,168(sp)
8112053c:	dd002d15 	stw	r20,180(sp)
81120540:	d8002915 	stw	zero,164(sp)
81120544:	d8003215 	stw	zero,200(sp)
81120548:	8430b804 	addi	r16,r16,-15648
8112054c:	0039883a 	mov	fp,zero
81120550:	003a9f06 	br	8111efd0 <__reset+0xfb0fefd0>
81120554:	01204574 	movhi	r4,33045
81120558:	2130be84 	addi	r4,r4,-15622
8112055c:	d9003515 	stw	r4,212(sp)
81120560:	003b5f06 	br	8111f2e0 <__reset+0xfb0ff2e0>
81120564:	d9402c17 	ldw	r5,176(sp)
81120568:	d9801e04 	addi	r6,sp,120
8112056c:	9809883a 	mov	r4,r19
81120570:	112b5140 	call	8112b514 <__ssprint_r>
81120574:	1039c61e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
81120578:	d8802617 	ldw	r2,152(sp)
8112057c:	d9403317 	ldw	r5,204(sp)
81120580:	d8c02017 	ldw	r3,128(sp)
81120584:	da000404 	addi	r8,sp,16
81120588:	2885c83a 	sub	r2,r5,r2
8112058c:	003e1006 	br	8111fdd0 <__reset+0xfb0ffdd0>
81120590:	00800044 	movi	r2,1
81120594:	10803fcc 	andi	r2,r2,255
81120598:	00c00044 	movi	r3,1
8112059c:	10fa3526 	beq	r2,r3,8111ee74 <__reset+0xfb0fee74>
811205a0:	00c00084 	movi	r3,2
811205a4:	10fb9e26 	beq	r2,r3,8111f420 <__reset+0xfb0ff420>
811205a8:	003a6406 	br	8111ef3c <__reset+0xfb0fef3c>
811205ac:	0021883a 	mov	r16,zero
811205b0:	003e0806 	br	8111fdd4 <__reset+0xfb0ffdd4>
811205b4:	07000b44 	movi	fp,45
811205b8:	df002785 	stb	fp,158(sp)
811205bc:	003a0b06 	br	8111edec <__reset+0xfb0fedec>
811205c0:	d8c02d17 	ldw	r3,180(sp)
811205c4:	d9002f17 	ldw	r4,188(sp)
811205c8:	18800017 	ldw	r2,0(r3)
811205cc:	18c00104 	addi	r3,r3,4
811205d0:	d8c02d15 	stw	r3,180(sp)
811205d4:	11000015 	stw	r4,0(r2)
811205d8:	0038f306 	br	8111e9a8 <__reset+0xfb0fe9a8>
811205dc:	00c00b44 	movi	r3,45
811205e0:	d8c02785 	stb	r3,158(sp)
811205e4:	d8802a15 	stw	r2,168(sp)
811205e8:	dc802b17 	ldw	r18,172(sp)
811205ec:	d8002915 	stw	zero,164(sp)
811205f0:	07000b44 	movi	fp,45
811205f4:	003a7306 	br	8111efc4 <__reset+0xfb0fefc4>
811205f8:	9080004c 	andi	r2,r18,1
811205fc:	1000941e 	bne	r2,zero,81120850 <___svfprintf_internal_r+0x1f5c>
81120600:	d8802117 	ldw	r2,132(sp)
81120604:	1405c83a 	sub	r2,r2,r16
81120608:	d8803315 	stw	r2,204(sp)
8112060c:	b441161e 	bne	r22,r17,81120a68 <___svfprintf_internal_r+0x2174>
81120610:	dd802617 	ldw	r22,152(sp)
81120614:	00bfff44 	movi	r2,-3
81120618:	b0801a16 	blt	r22,r2,81120684 <___svfprintf_internal_r+0x1d90>
8112061c:	d9402917 	ldw	r5,164(sp)
81120620:	2d801816 	blt	r5,r22,81120684 <___svfprintf_internal_r+0x1d90>
81120624:	dd803215 	stw	r22,200(sp)
81120628:	003f3a06 	br	81120314 <__reset+0xfb100314>
8112062c:	1025883a 	mov	r18,r2
81120630:	0039883a 	mov	fp,zero
81120634:	00800084 	movi	r2,2
81120638:	003fd606 	br	81120594 <__reset+0xfb100594>
8112063c:	9080004c 	andi	r2,r18,1
81120640:	103f191e 	bne	r2,zero,811202a8 <__reset+0xfb1002a8>
81120644:	d8802117 	ldw	r2,132(sp)
81120648:	003f2806 	br	811202ec <__reset+0xfb1002ec>
8112064c:	01204574 	movhi	r4,33045
81120650:	2130ba84 	addi	r4,r4,-15638
81120654:	d9002b15 	stw	r4,172(sp)
81120658:	003c7c06 	br	8111f84c <__reset+0xfb0ff84c>
8112065c:	e005883a 	mov	r2,fp
81120660:	003f2206 	br	811202ec <__reset+0xfb1002ec>
81120664:	d9402917 	ldw	r5,164(sp)
81120668:	df002783 	ldbu	fp,158(sp)
8112066c:	dd002d15 	stw	r20,180(sp)
81120670:	d9402a15 	stw	r5,168(sp)
81120674:	d9402e15 	stw	r5,184(sp)
81120678:	d8002915 	stw	zero,164(sp)
8112067c:	d8003215 	stw	zero,200(sp)
81120680:	003a4c06 	br	8111efb4 <__reset+0xfb0fefb4>
81120684:	8c7fff84 	addi	r17,r17,-2
81120688:	b5bfffc4 	addi	r22,r22,-1
8112068c:	dd802615 	stw	r22,152(sp)
81120690:	dc4022c5 	stb	r17,139(sp)
81120694:	b000c316 	blt	r22,zero,811209a4 <___svfprintf_internal_r+0x20b0>
81120698:	00800ac4 	movi	r2,43
8112069c:	d8802305 	stb	r2,140(sp)
811206a0:	00800244 	movi	r2,9
811206a4:	15806e16 	blt	r2,r22,81120860 <___svfprintf_internal_r+0x1f6c>
811206a8:	00800c04 	movi	r2,48
811206ac:	b5800c04 	addi	r22,r22,48
811206b0:	d8802345 	stb	r2,141(sp)
811206b4:	dd802385 	stb	r22,142(sp)
811206b8:	d88023c4 	addi	r2,sp,143
811206bc:	df0022c4 	addi	fp,sp,139
811206c0:	d8c03317 	ldw	r3,204(sp)
811206c4:	1739c83a 	sub	fp,r2,fp
811206c8:	d9003317 	ldw	r4,204(sp)
811206cc:	e0c7883a 	add	r3,fp,r3
811206d0:	df003b15 	stw	fp,236(sp)
811206d4:	d8c02e15 	stw	r3,184(sp)
811206d8:	00800044 	movi	r2,1
811206dc:	1100b70e 	bge	r2,r4,811209bc <___svfprintf_internal_r+0x20c8>
811206e0:	d8c02e17 	ldw	r3,184(sp)
811206e4:	18c00044 	addi	r3,r3,1
811206e8:	d8c02e15 	stw	r3,184(sp)
811206ec:	1805883a 	mov	r2,r3
811206f0:	1800b016 	blt	r3,zero,811209b4 <___svfprintf_internal_r+0x20c0>
811206f4:	d8003215 	stw	zero,200(sp)
811206f8:	003f1006 	br	8112033c <__reset+0xfb10033c>
811206fc:	d8802917 	ldw	r2,164(sp)
81120700:	103ec71e 	bne	r2,zero,81120220 <__reset+0xfb100220>
81120704:	dc002915 	stw	r16,164(sp)
81120708:	003ec506 	br	81120220 <__reset+0xfb100220>
8112070c:	d9402c17 	ldw	r5,176(sp)
81120710:	d9801e04 	addi	r6,sp,120
81120714:	9809883a 	mov	r4,r19
81120718:	112b5140 	call	8112b514 <__ssprint_r>
8112071c:	10395c1e 	bne	r2,zero,8111ec90 <__reset+0xfb0fec90>
81120720:	dc402617 	ldw	r17,152(sp)
81120724:	d8c02017 	ldw	r3,128(sp)
81120728:	d8801f17 	ldw	r2,124(sp)
8112072c:	da000404 	addi	r8,sp,16
81120730:	003e7706 	br	81120110 <__reset+0xfb100110>
81120734:	582f883a 	mov	r23,r11
81120738:	d8002915 	stw	zero,164(sp)
8112073c:	0038c406 	br	8111ea50 <__reset+0xfb0fea50>
81120740:	d8c02917 	ldw	r3,164(sp)
81120744:	d8802104 	addi	r2,sp,132
81120748:	d8800315 	stw	r2,12(sp)
8112074c:	d9403617 	ldw	r5,216(sp)
81120750:	d8802504 	addi	r2,sp,148
81120754:	d8800215 	stw	r2,8(sp)
81120758:	d8802604 	addi	r2,sp,152
8112075c:	d8c00015 	stw	r3,0(sp)
81120760:	9809883a 	mov	r4,r19
81120764:	d8800115 	stw	r2,4(sp)
81120768:	01c000c4 	movi	r7,3
8112076c:	a00d883a 	mov	r6,r20
81120770:	da003e15 	stw	r8,248(sp)
81120774:	1124be00 	call	81124be0 <_dtoa_r>
81120778:	d9002917 	ldw	r4,164(sp)
8112077c:	da003e17 	ldw	r8,248(sp)
81120780:	1021883a 	mov	r16,r2
81120784:	1139883a 	add	fp,r2,r4
81120788:	2007883a 	mov	r3,r4
8112078c:	81000007 	ldb	r4,0(r16)
81120790:	00800c04 	movi	r2,48
81120794:	20806f26 	beq	r4,r2,81120954 <___svfprintf_internal_r+0x2060>
81120798:	d8c02617 	ldw	r3,152(sp)
8112079c:	e0f9883a 	add	fp,fp,r3
811207a0:	003ec206 	br	811202ac <__reset+0xfb1002ac>
811207a4:	00c00b44 	movi	r3,45
811207a8:	2520003c 	xorhi	r20,r4,32768
811207ac:	d8c02a05 	stb	r3,168(sp)
811207b0:	003ea106 	br	81120238 <__reset+0xfb100238>
811207b4:	d8c03217 	ldw	r3,200(sp)
811207b8:	00c0890e 	bge	zero,r3,811209e0 <___svfprintf_internal_r+0x20ec>
811207bc:	00800044 	movi	r2,1
811207c0:	d9003317 	ldw	r4,204(sp)
811207c4:	1105883a 	add	r2,r2,r4
811207c8:	d8802e15 	stw	r2,184(sp)
811207cc:	10005f16 	blt	r2,zero,8112094c <___svfprintf_internal_r+0x2058>
811207d0:	044019c4 	movi	r17,103
811207d4:	003ed906 	br	8112033c <__reset+0xfb10033c>
811207d8:	d9002917 	ldw	r4,164(sp)
811207dc:	20c00044 	addi	r3,r4,1
811207e0:	003e9c06 	br	81120254 <__reset+0xfb100254>
811207e4:	d9002917 	ldw	r4,164(sp)
811207e8:	00c0680e 	bge	zero,r3,8112098c <___svfprintf_internal_r+0x2098>
811207ec:	2000461e 	bne	r4,zero,81120908 <___svfprintf_internal_r+0x2014>
811207f0:	9480004c 	andi	r18,r18,1
811207f4:	9000441e 	bne	r18,zero,81120908 <___svfprintf_internal_r+0x2014>
811207f8:	1805883a 	mov	r2,r3
811207fc:	1800a016 	blt	r3,zero,81120a80 <___svfprintf_internal_r+0x218c>
81120800:	d8c03217 	ldw	r3,200(sp)
81120804:	d8c02e15 	stw	r3,184(sp)
81120808:	003ecc06 	br	8112033c <__reset+0xfb10033c>
8112080c:	d9402917 	ldw	r5,164(sp)
81120810:	d8802104 	addi	r2,sp,132
81120814:	d8800315 	stw	r2,12(sp)
81120818:	d9400015 	stw	r5,0(sp)
8112081c:	d8802504 	addi	r2,sp,148
81120820:	d9403617 	ldw	r5,216(sp)
81120824:	d8800215 	stw	r2,8(sp)
81120828:	d8802604 	addi	r2,sp,152
8112082c:	d8800115 	stw	r2,4(sp)
81120830:	01c000c4 	movi	r7,3
81120834:	a00d883a 	mov	r6,r20
81120838:	9809883a 	mov	r4,r19
8112083c:	da003e15 	stw	r8,248(sp)
81120840:	1124be00 	call	81124be0 <_dtoa_r>
81120844:	d8c02917 	ldw	r3,164(sp)
81120848:	da003e17 	ldw	r8,248(sp)
8112084c:	1021883a 	mov	r16,r2
81120850:	00801184 	movi	r2,70
81120854:	80f9883a 	add	fp,r16,r3
81120858:	88bfcc26 	beq	r17,r2,8112078c <__reset+0xfb10078c>
8112085c:	003e9306 	br	811202ac <__reset+0xfb1002ac>
81120860:	df0022c4 	addi	fp,sp,139
81120864:	dc002915 	stw	r16,164(sp)
81120868:	9829883a 	mov	r20,r19
8112086c:	e021883a 	mov	r16,fp
81120870:	4027883a 	mov	r19,r8
81120874:	b009883a 	mov	r4,r22
81120878:	01400284 	movi	r5,10
8112087c:	113003c0 	call	8113003c <__modsi3>
81120880:	10800c04 	addi	r2,r2,48
81120884:	843fffc4 	addi	r16,r16,-1
81120888:	b009883a 	mov	r4,r22
8112088c:	01400284 	movi	r5,10
81120890:	80800005 	stb	r2,0(r16)
81120894:	112ffb80 	call	8112ffb8 <__divsi3>
81120898:	102d883a 	mov	r22,r2
8112089c:	00800244 	movi	r2,9
811208a0:	15bff416 	blt	r2,r22,81120874 <__reset+0xfb100874>
811208a4:	9811883a 	mov	r8,r19
811208a8:	b0800c04 	addi	r2,r22,48
811208ac:	a027883a 	mov	r19,r20
811208b0:	8029883a 	mov	r20,r16
811208b4:	a17fffc4 	addi	r5,r20,-1
811208b8:	a0bfffc5 	stb	r2,-1(r20)
811208bc:	dc002917 	ldw	r16,164(sp)
811208c0:	2f00752e 	bgeu	r5,fp,81120a98 <___svfprintf_internal_r+0x21a4>
811208c4:	d9c02384 	addi	r7,sp,142
811208c8:	3d0fc83a 	sub	r7,r7,r20
811208cc:	d9002344 	addi	r4,sp,141
811208d0:	e1cf883a 	add	r7,fp,r7
811208d4:	00000106 	br	811208dc <___svfprintf_internal_r+0x1fe8>
811208d8:	28800003 	ldbu	r2,0(r5)
811208dc:	20800005 	stb	r2,0(r4)
811208e0:	21000044 	addi	r4,r4,1
811208e4:	29400044 	addi	r5,r5,1
811208e8:	21fffb1e 	bne	r4,r7,811208d8 <__reset+0xfb1008d8>
811208ec:	d8802304 	addi	r2,sp,140
811208f0:	1505c83a 	sub	r2,r2,r20
811208f4:	d8c02344 	addi	r3,sp,141
811208f8:	1885883a 	add	r2,r3,r2
811208fc:	003f7006 	br	811206c0 <__reset+0xfb1006c0>
81120900:	0005883a 	mov	r2,zero
81120904:	003f0b06 	br	81120534 <__reset+0xfb100534>
81120908:	d9002917 	ldw	r4,164(sp)
8112090c:	d8c03217 	ldw	r3,200(sp)
81120910:	20800044 	addi	r2,r4,1
81120914:	1885883a 	add	r2,r3,r2
81120918:	d8802e15 	stw	r2,184(sp)
8112091c:	103e870e 	bge	r2,zero,8112033c <__reset+0xfb10033c>
81120920:	0005883a 	mov	r2,zero
81120924:	003e8506 	br	8112033c <__reset+0xfb10033c>
81120928:	01204574 	movhi	r4,33045
8112092c:	2130ba84 	addi	r4,r4,-15638
81120930:	d9002b15 	stw	r4,172(sp)
81120934:	003cc506 	br	8111fc4c <__reset+0xfb0ffc4c>
81120938:	d8c03217 	ldw	r3,200(sp)
8112093c:	18c00044 	addi	r3,r3,1
81120940:	d8c02e15 	stw	r3,184(sp)
81120944:	1805883a 	mov	r2,r3
81120948:	183fa10e 	bge	r3,zero,811207d0 <__reset+0xfb1007d0>
8112094c:	0005883a 	mov	r2,zero
81120950:	003f9f06 	br	811207d0 <__reset+0xfb1007d0>
81120954:	d9003617 	ldw	r4,216(sp)
81120958:	000d883a 	mov	r6,zero
8112095c:	000f883a 	mov	r7,zero
81120960:	a00b883a 	mov	r5,r20
81120964:	d8c03d15 	stw	r3,244(sp)
81120968:	da003e15 	stw	r8,248(sp)
8112096c:	113150c0 	call	8113150c <__eqdf2>
81120970:	d8c03d17 	ldw	r3,244(sp)
81120974:	da003e17 	ldw	r8,248(sp)
81120978:	103f8726 	beq	r2,zero,81120798 <__reset+0xfb100798>
8112097c:	00800044 	movi	r2,1
81120980:	10c7c83a 	sub	r3,r2,r3
81120984:	d8c02615 	stw	r3,152(sp)
81120988:	003f8406 	br	8112079c <__reset+0xfb10079c>
8112098c:	20000e1e 	bne	r4,zero,811209c8 <___svfprintf_internal_r+0x20d4>
81120990:	9480004c 	andi	r18,r18,1
81120994:	90000c1e 	bne	r18,zero,811209c8 <___svfprintf_internal_r+0x20d4>
81120998:	00800044 	movi	r2,1
8112099c:	d8802e15 	stw	r2,184(sp)
811209a0:	003e6606 	br	8112033c <__reset+0xfb10033c>
811209a4:	00800b44 	movi	r2,45
811209a8:	05adc83a 	sub	r22,zero,r22
811209ac:	d8802305 	stb	r2,140(sp)
811209b0:	003f3b06 	br	811206a0 <__reset+0xfb1006a0>
811209b4:	0005883a 	mov	r2,zero
811209b8:	003f4e06 	br	811206f4 <__reset+0xfb1006f4>
811209bc:	90a4703a 	and	r18,r18,r2
811209c0:	903f4a26 	beq	r18,zero,811206ec <__reset+0xfb1006ec>
811209c4:	003f4606 	br	811206e0 <__reset+0xfb1006e0>
811209c8:	d8c02917 	ldw	r3,164(sp)
811209cc:	18c00084 	addi	r3,r3,2
811209d0:	d8c02e15 	stw	r3,184(sp)
811209d4:	1805883a 	mov	r2,r3
811209d8:	183e580e 	bge	r3,zero,8112033c <__reset+0xfb10033c>
811209dc:	003fd006 	br	81120920 <__reset+0xfb100920>
811209e0:	00800084 	movi	r2,2
811209e4:	10c5c83a 	sub	r2,r2,r3
811209e8:	003f7506 	br	811207c0 <__reset+0xfb1007c0>
811209ec:	d8802d17 	ldw	r2,180(sp)
811209f0:	d9002d17 	ldw	r4,180(sp)
811209f4:	bc400043 	ldbu	r17,1(r23)
811209f8:	10800017 	ldw	r2,0(r2)
811209fc:	582f883a 	mov	r23,r11
81120a00:	d8802915 	stw	r2,164(sp)
81120a04:	20800104 	addi	r2,r4,4
81120a08:	d9002917 	ldw	r4,164(sp)
81120a0c:	d8802d15 	stw	r2,180(sp)
81120a10:	203df00e 	bge	r4,zero,811201d4 <__reset+0xfb1001d4>
81120a14:	8c403fcc 	andi	r17,r17,255
81120a18:	00bfffc4 	movi	r2,-1
81120a1c:	8c40201c 	xori	r17,r17,128
81120a20:	d8802915 	stw	r2,164(sp)
81120a24:	8c7fe004 	addi	r17,r17,-128
81120a28:	00380806 	br	8111ea4c <__reset+0xfb0fea4c>
81120a2c:	9080004c 	andi	r2,r18,1
81120a30:	0039883a 	mov	fp,zero
81120a34:	10000726 	beq	r2,zero,81120a54 <___svfprintf_internal_r+0x2160>
81120a38:	d8c02817 	ldw	r3,160(sp)
81120a3c:	dc001dc4 	addi	r16,sp,119
81120a40:	00800c04 	movi	r2,48
81120a44:	1c07c83a 	sub	r3,r3,r16
81120a48:	d8801dc5 	stb	r2,119(sp)
81120a4c:	d8c02e15 	stw	r3,184(sp)
81120a50:	00395206 	br	8111ef9c <__reset+0xfb0fef9c>
81120a54:	d8002e15 	stw	zero,184(sp)
81120a58:	dc001e04 	addi	r16,sp,120
81120a5c:	00394f06 	br	8111ef9c <__reset+0xfb0fef9c>
81120a60:	0005883a 	mov	r2,zero
81120a64:	003e3206 	br	81120330 <__reset+0xfb100330>
81120a68:	dd802617 	ldw	r22,152(sp)
81120a6c:	003f0606 	br	81120688 <__reset+0xfb100688>
81120a70:	d9c02785 	stb	r7,158(sp)
81120a74:	003a5106 	br	8111f3bc <__reset+0xfb0ff3bc>
81120a78:	d9c02785 	stb	r7,158(sp)
81120a7c:	003a3706 	br	8111f35c <__reset+0xfb0ff35c>
81120a80:	0005883a 	mov	r2,zero
81120a84:	003f5e06 	br	81120800 <__reset+0xfb100800>
81120a88:	d9c02785 	stb	r7,158(sp)
81120a8c:	00391706 	br	8111eeec <__reset+0xfb0feeec>
81120a90:	d9c02785 	stb	r7,158(sp)
81120a94:	0038e606 	br	8111ee30 <__reset+0xfb0fee30>
81120a98:	d8802344 	addi	r2,sp,141
81120a9c:	003f0806 	br	811206c0 <__reset+0xfb1006c0>
81120aa0:	d9c02785 	stb	r7,158(sp)
81120aa4:	0038b706 	br	8111ed84 <__reset+0xfb0fed84>
81120aa8:	d9c02785 	stb	r7,158(sp)
81120aac:	003adc06 	br	8111f620 <__reset+0xfb0ff620>
81120ab0:	d9403917 	ldw	r5,228(sp)
81120ab4:	00800304 	movi	r2,12
81120ab8:	28800015 	stw	r2,0(r5)
81120abc:	00bfffc4 	movi	r2,-1
81120ac0:	00387806 	br	8111eca4 <__reset+0xfb0feca4>
81120ac4:	d9c02785 	stb	r7,158(sp)
81120ac8:	003abf06 	br	8111f5c8 <__reset+0xfb0ff5c8>
81120acc:	d9c02785 	stb	r7,158(sp)
81120ad0:	003a9b06 	br	8111f540 <__reset+0xfb0ff540>

81120ad4 <___vfprintf_internal_r>:
81120ad4:	deffb804 	addi	sp,sp,-288
81120ad8:	de00012e 	bgeu	sp,et,81120ae0 <___vfprintf_internal_r+0xc>
81120adc:	003b68fa 	trap	3
81120ae0:	dfc04715 	stw	ra,284(sp)
81120ae4:	ddc04515 	stw	r23,276(sp)
81120ae8:	dd404315 	stw	r21,268(sp)
81120aec:	d9002c15 	stw	r4,176(sp)
81120af0:	282f883a 	mov	r23,r5
81120af4:	302b883a 	mov	r21,r6
81120af8:	d9c02d15 	stw	r7,180(sp)
81120afc:	df004615 	stw	fp,280(sp)
81120b00:	dd804415 	stw	r22,272(sp)
81120b04:	dd004215 	stw	r20,264(sp)
81120b08:	dcc04115 	stw	r19,260(sp)
81120b0c:	dc804015 	stw	r18,256(sp)
81120b10:	dc403f15 	stw	r17,252(sp)
81120b14:	dc003e15 	stw	r16,248(sp)
81120b18:	11277dc0 	call	811277dc <_localeconv_r>
81120b1c:	10800017 	ldw	r2,0(r2)
81120b20:	1009883a 	mov	r4,r2
81120b24:	d8803415 	stw	r2,208(sp)
81120b28:	111e5bc0 	call	8111e5bc <strlen>
81120b2c:	d8803715 	stw	r2,220(sp)
81120b30:	d8802c17 	ldw	r2,176(sp)
81120b34:	10000226 	beq	r2,zero,81120b40 <___vfprintf_internal_r+0x6c>
81120b38:	10800e17 	ldw	r2,56(r2)
81120b3c:	1000f926 	beq	r2,zero,81120f24 <___vfprintf_internal_r+0x450>
81120b40:	b880030b 	ldhu	r2,12(r23)
81120b44:	10c8000c 	andi	r3,r2,8192
81120b48:	1800061e 	bne	r3,zero,81120b64 <___vfprintf_internal_r+0x90>
81120b4c:	b9001917 	ldw	r4,100(r23)
81120b50:	00f7ffc4 	movi	r3,-8193
81120b54:	10880014 	ori	r2,r2,8192
81120b58:	20c6703a 	and	r3,r4,r3
81120b5c:	b880030d 	sth	r2,12(r23)
81120b60:	b8c01915 	stw	r3,100(r23)
81120b64:	10c0020c 	andi	r3,r2,8
81120b68:	1800c126 	beq	r3,zero,81120e70 <___vfprintf_internal_r+0x39c>
81120b6c:	b8c00417 	ldw	r3,16(r23)
81120b70:	1800bf26 	beq	r3,zero,81120e70 <___vfprintf_internal_r+0x39c>
81120b74:	1080068c 	andi	r2,r2,26
81120b78:	00c00284 	movi	r3,10
81120b7c:	10c0c426 	beq	r2,r3,81120e90 <___vfprintf_internal_r+0x3bc>
81120b80:	d8c00404 	addi	r3,sp,16
81120b84:	05204574 	movhi	r20,33045
81120b88:	d9001e04 	addi	r4,sp,120
81120b8c:	a530c284 	addi	r20,r20,-15606
81120b90:	d8c01e15 	stw	r3,120(sp)
81120b94:	d8002015 	stw	zero,128(sp)
81120b98:	d8001f15 	stw	zero,124(sp)
81120b9c:	d8003315 	stw	zero,204(sp)
81120ba0:	d8003615 	stw	zero,216(sp)
81120ba4:	d8003815 	stw	zero,224(sp)
81120ba8:	1811883a 	mov	r8,r3
81120bac:	d8003915 	stw	zero,228(sp)
81120bb0:	d8003a15 	stw	zero,232(sp)
81120bb4:	d8002f15 	stw	zero,188(sp)
81120bb8:	d9002815 	stw	r4,160(sp)
81120bbc:	a8800007 	ldb	r2,0(r21)
81120bc0:	10027b26 	beq	r2,zero,811215b0 <___vfprintf_internal_r+0xadc>
81120bc4:	00c00944 	movi	r3,37
81120bc8:	a821883a 	mov	r16,r21
81120bcc:	10c0021e 	bne	r2,r3,81120bd8 <___vfprintf_internal_r+0x104>
81120bd0:	00001406 	br	81120c24 <___vfprintf_internal_r+0x150>
81120bd4:	10c00326 	beq	r2,r3,81120be4 <___vfprintf_internal_r+0x110>
81120bd8:	84000044 	addi	r16,r16,1
81120bdc:	80800007 	ldb	r2,0(r16)
81120be0:	103ffc1e 	bne	r2,zero,81120bd4 <__reset+0xfb100bd4>
81120be4:	8563c83a 	sub	r17,r16,r21
81120be8:	88000e26 	beq	r17,zero,81120c24 <___vfprintf_internal_r+0x150>
81120bec:	d8c02017 	ldw	r3,128(sp)
81120bf0:	d8801f17 	ldw	r2,124(sp)
81120bf4:	45400015 	stw	r21,0(r8)
81120bf8:	1c47883a 	add	r3,r3,r17
81120bfc:	10800044 	addi	r2,r2,1
81120c00:	d8c02015 	stw	r3,128(sp)
81120c04:	44400115 	stw	r17,4(r8)
81120c08:	d8801f15 	stw	r2,124(sp)
81120c0c:	00c001c4 	movi	r3,7
81120c10:	1880a716 	blt	r3,r2,81120eb0 <___vfprintf_internal_r+0x3dc>
81120c14:	42000204 	addi	r8,r8,8
81120c18:	d9402f17 	ldw	r5,188(sp)
81120c1c:	2c4b883a 	add	r5,r5,r17
81120c20:	d9402f15 	stw	r5,188(sp)
81120c24:	80800007 	ldb	r2,0(r16)
81120c28:	1000a826 	beq	r2,zero,81120ecc <___vfprintf_internal_r+0x3f8>
81120c2c:	84400047 	ldb	r17,1(r16)
81120c30:	00bfffc4 	movi	r2,-1
81120c34:	85400044 	addi	r21,r16,1
81120c38:	d8002785 	stb	zero,158(sp)
81120c3c:	0007883a 	mov	r3,zero
81120c40:	000f883a 	mov	r7,zero
81120c44:	d8802915 	stw	r2,164(sp)
81120c48:	d8003115 	stw	zero,196(sp)
81120c4c:	0025883a 	mov	r18,zero
81120c50:	01401604 	movi	r5,88
81120c54:	01800244 	movi	r6,9
81120c58:	02800a84 	movi	r10,42
81120c5c:	02401b04 	movi	r9,108
81120c60:	ad400044 	addi	r21,r21,1
81120c64:	88bff804 	addi	r2,r17,-32
81120c68:	28830436 	bltu	r5,r2,8112187c <___vfprintf_internal_r+0xda8>
81120c6c:	100490ba 	slli	r2,r2,2
81120c70:	012044b4 	movhi	r4,33042
81120c74:	21032104 	addi	r4,r4,3204
81120c78:	1105883a 	add	r2,r2,r4
81120c7c:	10800017 	ldw	r2,0(r2)
81120c80:	1000683a 	jmp	r2
81120c84:	8112179c 	xori	r4,r16,18526
81120c88:	8112187c 	xorhi	r4,r16,18529
81120c8c:	8112187c 	xorhi	r4,r16,18529
81120c90:	811217bc 	xorhi	r4,r16,18526
81120c94:	8112187c 	xorhi	r4,r16,18529
81120c98:	8112187c 	xorhi	r4,r16,18529
81120c9c:	8112187c 	xorhi	r4,r16,18529
81120ca0:	8112187c 	xorhi	r4,r16,18529
81120ca4:	8112187c 	xorhi	r4,r16,18529
81120ca8:	8112187c 	xorhi	r4,r16,18529
81120cac:	81120f30 	cmpltui	r4,r16,18492
81120cb0:	811216d8 	cmpnei	r4,r16,18523
81120cb4:	8112187c 	xorhi	r4,r16,18529
81120cb8:	81120df8 	rdprs	r4,r16,18487
81120cbc:	81120f58 	cmpnei	r4,r16,18493
81120cc0:	8112187c 	xorhi	r4,r16,18529
81120cc4:	81120f98 	cmpnei	r4,r16,18494
81120cc8:	81120fa4 	muli	r4,r16,18494
81120ccc:	81120fa4 	muli	r4,r16,18494
81120cd0:	81120fa4 	muli	r4,r16,18494
81120cd4:	81120fa4 	muli	r4,r16,18494
81120cd8:	81120fa4 	muli	r4,r16,18494
81120cdc:	81120fa4 	muli	r4,r16,18494
81120ce0:	81120fa4 	muli	r4,r16,18494
81120ce4:	81120fa4 	muli	r4,r16,18494
81120ce8:	81120fa4 	muli	r4,r16,18494
81120cec:	8112187c 	xorhi	r4,r16,18529
81120cf0:	8112187c 	xorhi	r4,r16,18529
81120cf4:	8112187c 	xorhi	r4,r16,18529
81120cf8:	8112187c 	xorhi	r4,r16,18529
81120cfc:	8112187c 	xorhi	r4,r16,18529
81120d00:	8112187c 	xorhi	r4,r16,18529
81120d04:	8112187c 	xorhi	r4,r16,18529
81120d08:	8112187c 	xorhi	r4,r16,18529
81120d0c:	8112187c 	xorhi	r4,r16,18529
81120d10:	8112187c 	xorhi	r4,r16,18529
81120d14:	81120fd8 	cmpnei	r4,r16,18495
81120d18:	81121094 	ori	r4,r16,18498
81120d1c:	8112187c 	xorhi	r4,r16,18529
81120d20:	81121094 	ori	r4,r16,18498
81120d24:	8112187c 	xorhi	r4,r16,18529
81120d28:	8112187c 	xorhi	r4,r16,18529
81120d2c:	8112187c 	xorhi	r4,r16,18529
81120d30:	8112187c 	xorhi	r4,r16,18529
81120d34:	81121134 	orhi	r4,r16,18500
81120d38:	8112187c 	xorhi	r4,r16,18529
81120d3c:	8112187c 	xorhi	r4,r16,18529
81120d40:	81121140 	call	88112114 <__reset+0x20f2114>
81120d44:	8112187c 	xorhi	r4,r16,18529
81120d48:	8112187c 	xorhi	r4,r16,18529
81120d4c:	8112187c 	xorhi	r4,r16,18529
81120d50:	8112187c 	xorhi	r4,r16,18529
81120d54:	8112187c 	xorhi	r4,r16,18529
81120d58:	811215b8 	rdprs	r4,r16,18518
81120d5c:	8112187c 	xorhi	r4,r16,18529
81120d60:	8112187c 	xorhi	r4,r16,18529
81120d64:	81121618 	cmpnei	r4,r16,18520
81120d68:	8112187c 	xorhi	r4,r16,18529
81120d6c:	8112187c 	xorhi	r4,r16,18529
81120d70:	8112187c 	xorhi	r4,r16,18529
81120d74:	8112187c 	xorhi	r4,r16,18529
81120d78:	8112187c 	xorhi	r4,r16,18529
81120d7c:	8112187c 	xorhi	r4,r16,18529
81120d80:	8112187c 	xorhi	r4,r16,18529
81120d84:	8112187c 	xorhi	r4,r16,18529
81120d88:	8112187c 	xorhi	r4,r16,18529
81120d8c:	8112187c 	xorhi	r4,r16,18529
81120d90:	81121828 	cmpgeui	r4,r16,18528
81120d94:	811217c8 	cmpgei	r4,r16,18527
81120d98:	81121094 	ori	r4,r16,18498
81120d9c:	81121094 	ori	r4,r16,18498
81120da0:	81121094 	ori	r4,r16,18498
81120da4:	811217d8 	cmpnei	r4,r16,18527
81120da8:	811217c8 	cmpgei	r4,r16,18527
81120dac:	8112187c 	xorhi	r4,r16,18529
81120db0:	8112187c 	xorhi	r4,r16,18529
81120db4:	811217e4 	muli	r4,r16,18527
81120db8:	8112187c 	xorhi	r4,r16,18529
81120dbc:	811217f4 	orhi	r4,r16,18527
81120dc0:	811216c8 	cmpgei	r4,r16,18523
81120dc4:	81120e04 	addi	r4,r16,18488
81120dc8:	811216e8 	cmpgeui	r4,r16,18523
81120dcc:	8112187c 	xorhi	r4,r16,18529
81120dd0:	811216f4 	orhi	r4,r16,18523
81120dd4:	8112187c 	xorhi	r4,r16,18529
81120dd8:	81121750 	cmplti	r4,r16,18525
81120ddc:	8112187c 	xorhi	r4,r16,18529
81120de0:	8112187c 	xorhi	r4,r16,18529
81120de4:	81121760 	cmpeqi	r4,r16,18525
81120de8:	d9003117 	ldw	r4,196(sp)
81120dec:	d8802d15 	stw	r2,180(sp)
81120df0:	0109c83a 	sub	r4,zero,r4
81120df4:	d9003115 	stw	r4,196(sp)
81120df8:	94800114 	ori	r18,r18,4
81120dfc:	ac400007 	ldb	r17,0(r21)
81120e00:	003f9706 	br	81120c60 <__reset+0xfb100c60>
81120e04:	00800c04 	movi	r2,48
81120e08:	d9002d17 	ldw	r4,180(sp)
81120e0c:	d9402917 	ldw	r5,164(sp)
81120e10:	d8802705 	stb	r2,156(sp)
81120e14:	00801e04 	movi	r2,120
81120e18:	d8802745 	stb	r2,157(sp)
81120e1c:	d8002785 	stb	zero,158(sp)
81120e20:	20c00104 	addi	r3,r4,4
81120e24:	24c00017 	ldw	r19,0(r4)
81120e28:	002d883a 	mov	r22,zero
81120e2c:	90800094 	ori	r2,r18,2
81120e30:	28029a16 	blt	r5,zero,8112189c <___vfprintf_internal_r+0xdc8>
81120e34:	00bfdfc4 	movi	r2,-129
81120e38:	90a4703a 	and	r18,r18,r2
81120e3c:	d8c02d15 	stw	r3,180(sp)
81120e40:	94800094 	ori	r18,r18,2
81120e44:	9802871e 	bne	r19,zero,81121864 <___vfprintf_internal_r+0xd90>
81120e48:	00a04574 	movhi	r2,33045
81120e4c:	10b0b304 	addi	r2,r2,-15668
81120e50:	d8803915 	stw	r2,228(sp)
81120e54:	04401e04 	movi	r17,120
81120e58:	d8802917 	ldw	r2,164(sp)
81120e5c:	0039883a 	mov	fp,zero
81120e60:	1001e926 	beq	r2,zero,81121608 <___vfprintf_internal_r+0xb34>
81120e64:	0027883a 	mov	r19,zero
81120e68:	002d883a 	mov	r22,zero
81120e6c:	00020506 	br	81121684 <___vfprintf_internal_r+0xbb0>
81120e70:	d9002c17 	ldw	r4,176(sp)
81120e74:	b80b883a 	mov	r5,r23
81120e78:	11248200 	call	81124820 <__swsetup_r>
81120e7c:	1005ac1e 	bne	r2,zero,81122530 <___vfprintf_internal_r+0x1a5c>
81120e80:	b880030b 	ldhu	r2,12(r23)
81120e84:	00c00284 	movi	r3,10
81120e88:	1080068c 	andi	r2,r2,26
81120e8c:	10ff3c1e 	bne	r2,r3,81120b80 <__reset+0xfb100b80>
81120e90:	b880038f 	ldh	r2,14(r23)
81120e94:	103f3a16 	blt	r2,zero,81120b80 <__reset+0xfb100b80>
81120e98:	d9c02d17 	ldw	r7,180(sp)
81120e9c:	d9002c17 	ldw	r4,176(sp)
81120ea0:	a80d883a 	mov	r6,r21
81120ea4:	b80b883a 	mov	r5,r23
81120ea8:	1122cf00 	call	81122cf0 <__sbprintf>
81120eac:	00001106 	br	81120ef4 <___vfprintf_internal_r+0x420>
81120eb0:	d9002c17 	ldw	r4,176(sp)
81120eb4:	d9801e04 	addi	r6,sp,120
81120eb8:	b80b883a 	mov	r5,r23
81120ebc:	112ccc40 	call	8112ccc4 <__sprint_r>
81120ec0:	1000081e 	bne	r2,zero,81120ee4 <___vfprintf_internal_r+0x410>
81120ec4:	da000404 	addi	r8,sp,16
81120ec8:	003f5306 	br	81120c18 <__reset+0xfb100c18>
81120ecc:	d8802017 	ldw	r2,128(sp)
81120ed0:	10000426 	beq	r2,zero,81120ee4 <___vfprintf_internal_r+0x410>
81120ed4:	d9002c17 	ldw	r4,176(sp)
81120ed8:	d9801e04 	addi	r6,sp,120
81120edc:	b80b883a 	mov	r5,r23
81120ee0:	112ccc40 	call	8112ccc4 <__sprint_r>
81120ee4:	b880030b 	ldhu	r2,12(r23)
81120ee8:	1080100c 	andi	r2,r2,64
81120eec:	1005901e 	bne	r2,zero,81122530 <___vfprintf_internal_r+0x1a5c>
81120ef0:	d8802f17 	ldw	r2,188(sp)
81120ef4:	dfc04717 	ldw	ra,284(sp)
81120ef8:	df004617 	ldw	fp,280(sp)
81120efc:	ddc04517 	ldw	r23,276(sp)
81120f00:	dd804417 	ldw	r22,272(sp)
81120f04:	dd404317 	ldw	r21,268(sp)
81120f08:	dd004217 	ldw	r20,264(sp)
81120f0c:	dcc04117 	ldw	r19,260(sp)
81120f10:	dc804017 	ldw	r18,256(sp)
81120f14:	dc403f17 	ldw	r17,252(sp)
81120f18:	dc003e17 	ldw	r16,248(sp)
81120f1c:	dec04804 	addi	sp,sp,288
81120f20:	f800283a 	ret
81120f24:	d9002c17 	ldw	r4,176(sp)
81120f28:	11268900 	call	81126890 <__sinit>
81120f2c:	003f0406 	br	81120b40 <__reset+0xfb100b40>
81120f30:	d8802d17 	ldw	r2,180(sp)
81120f34:	d9002d17 	ldw	r4,180(sp)
81120f38:	10800017 	ldw	r2,0(r2)
81120f3c:	d8803115 	stw	r2,196(sp)
81120f40:	20800104 	addi	r2,r4,4
81120f44:	d9003117 	ldw	r4,196(sp)
81120f48:	203fa716 	blt	r4,zero,81120de8 <__reset+0xfb100de8>
81120f4c:	d8802d15 	stw	r2,180(sp)
81120f50:	ac400007 	ldb	r17,0(r21)
81120f54:	003f4206 	br	81120c60 <__reset+0xfb100c60>
81120f58:	ac400007 	ldb	r17,0(r21)
81120f5c:	aac00044 	addi	r11,r21,1
81120f60:	8a872826 	beq	r17,r10,81122c04 <___vfprintf_internal_r+0x2130>
81120f64:	88bff404 	addi	r2,r17,-48
81120f68:	0009883a 	mov	r4,zero
81120f6c:	30867d36 	bltu	r6,r2,81122964 <___vfprintf_internal_r+0x1e90>
81120f70:	5c400007 	ldb	r17,0(r11)
81120f74:	210002a4 	muli	r4,r4,10
81120f78:	5d400044 	addi	r21,r11,1
81120f7c:	a817883a 	mov	r11,r21
81120f80:	2089883a 	add	r4,r4,r2
81120f84:	88bff404 	addi	r2,r17,-48
81120f88:	30bff92e 	bgeu	r6,r2,81120f70 <__reset+0xfb100f70>
81120f8c:	2005c916 	blt	r4,zero,811226b4 <___vfprintf_internal_r+0x1be0>
81120f90:	d9002915 	stw	r4,164(sp)
81120f94:	003f3306 	br	81120c64 <__reset+0xfb100c64>
81120f98:	94802014 	ori	r18,r18,128
81120f9c:	ac400007 	ldb	r17,0(r21)
81120fa0:	003f2f06 	br	81120c60 <__reset+0xfb100c60>
81120fa4:	a809883a 	mov	r4,r21
81120fa8:	d8003115 	stw	zero,196(sp)
81120fac:	88bff404 	addi	r2,r17,-48
81120fb0:	0017883a 	mov	r11,zero
81120fb4:	24400007 	ldb	r17,0(r4)
81120fb8:	5ac002a4 	muli	r11,r11,10
81120fbc:	ad400044 	addi	r21,r21,1
81120fc0:	a809883a 	mov	r4,r21
81120fc4:	12d7883a 	add	r11,r2,r11
81120fc8:	88bff404 	addi	r2,r17,-48
81120fcc:	30bff92e 	bgeu	r6,r2,81120fb4 <__reset+0xfb100fb4>
81120fd0:	dac03115 	stw	r11,196(sp)
81120fd4:	003f2306 	br	81120c64 <__reset+0xfb100c64>
81120fd8:	18c03fcc 	andi	r3,r3,255
81120fdc:	18072b1e 	bne	r3,zero,81122c8c <___vfprintf_internal_r+0x21b8>
81120fe0:	94800414 	ori	r18,r18,16
81120fe4:	9080080c 	andi	r2,r18,32
81120fe8:	10037b26 	beq	r2,zero,81121dd8 <___vfprintf_internal_r+0x1304>
81120fec:	d9402d17 	ldw	r5,180(sp)
81120ff0:	28800117 	ldw	r2,4(r5)
81120ff4:	2cc00017 	ldw	r19,0(r5)
81120ff8:	29400204 	addi	r5,r5,8
81120ffc:	d9402d15 	stw	r5,180(sp)
81121000:	102d883a 	mov	r22,r2
81121004:	10044b16 	blt	r2,zero,81122134 <___vfprintf_internal_r+0x1660>
81121008:	d9402917 	ldw	r5,164(sp)
8112100c:	df002783 	ldbu	fp,158(sp)
81121010:	2803bc16 	blt	r5,zero,81121f04 <___vfprintf_internal_r+0x1430>
81121014:	00ffdfc4 	movi	r3,-129
81121018:	9d84b03a 	or	r2,r19,r22
8112101c:	90e4703a 	and	r18,r18,r3
81121020:	10017726 	beq	r2,zero,81121600 <___vfprintf_internal_r+0xb2c>
81121024:	b0038326 	beq	r22,zero,81121e34 <___vfprintf_internal_r+0x1360>
81121028:	dc402a15 	stw	r17,168(sp)
8112102c:	dc001e04 	addi	r16,sp,120
81121030:	b023883a 	mov	r17,r22
81121034:	402d883a 	mov	r22,r8
81121038:	9809883a 	mov	r4,r19
8112103c:	880b883a 	mov	r5,r17
81121040:	01800284 	movi	r6,10
81121044:	000f883a 	mov	r7,zero
81121048:	112fa780 	call	8112fa78 <__umoddi3>
8112104c:	10800c04 	addi	r2,r2,48
81121050:	843fffc4 	addi	r16,r16,-1
81121054:	9809883a 	mov	r4,r19
81121058:	880b883a 	mov	r5,r17
8112105c:	80800005 	stb	r2,0(r16)
81121060:	01800284 	movi	r6,10
81121064:	000f883a 	mov	r7,zero
81121068:	112f4f80 	call	8112f4f8 <__udivdi3>
8112106c:	1027883a 	mov	r19,r2
81121070:	10c4b03a 	or	r2,r2,r3
81121074:	1823883a 	mov	r17,r3
81121078:	103fef1e 	bne	r2,zero,81121038 <__reset+0xfb101038>
8112107c:	d8c02817 	ldw	r3,160(sp)
81121080:	dc402a17 	ldw	r17,168(sp)
81121084:	b011883a 	mov	r8,r22
81121088:	1c07c83a 	sub	r3,r3,r16
8112108c:	d8c02e15 	stw	r3,184(sp)
81121090:	00005906 	br	811211f8 <___vfprintf_internal_r+0x724>
81121094:	18c03fcc 	andi	r3,r3,255
81121098:	1806fa1e 	bne	r3,zero,81122c84 <___vfprintf_internal_r+0x21b0>
8112109c:	9080020c 	andi	r2,r18,8
811210a0:	10048a26 	beq	r2,zero,811222cc <___vfprintf_internal_r+0x17f8>
811210a4:	d8c02d17 	ldw	r3,180(sp)
811210a8:	d9002d17 	ldw	r4,180(sp)
811210ac:	d9402d17 	ldw	r5,180(sp)
811210b0:	18c00017 	ldw	r3,0(r3)
811210b4:	21000117 	ldw	r4,4(r4)
811210b8:	29400204 	addi	r5,r5,8
811210bc:	d8c03615 	stw	r3,216(sp)
811210c0:	d9003815 	stw	r4,224(sp)
811210c4:	d9402d15 	stw	r5,180(sp)
811210c8:	d9003617 	ldw	r4,216(sp)
811210cc:	d9403817 	ldw	r5,224(sp)
811210d0:	da003d15 	stw	r8,244(sp)
811210d4:	04000044 	movi	r16,1
811210d8:	11293280 	call	81129328 <__fpclassifyd>
811210dc:	da003d17 	ldw	r8,244(sp)
811210e0:	14041f1e 	bne	r2,r16,81122160 <___vfprintf_internal_r+0x168c>
811210e4:	d9003617 	ldw	r4,216(sp)
811210e8:	d9403817 	ldw	r5,224(sp)
811210ec:	000d883a 	mov	r6,zero
811210f0:	000f883a 	mov	r7,zero
811210f4:	11316700 	call	81131670 <__ledf2>
811210f8:	da003d17 	ldw	r8,244(sp)
811210fc:	1005be16 	blt	r2,zero,811227f8 <___vfprintf_internal_r+0x1d24>
81121100:	df002783 	ldbu	fp,158(sp)
81121104:	008011c4 	movi	r2,71
81121108:	1445330e 	bge	r2,r17,811225d8 <___vfprintf_internal_r+0x1b04>
8112110c:	04204574 	movhi	r16,33045
81121110:	8430ab04 	addi	r16,r16,-15700
81121114:	00c000c4 	movi	r3,3
81121118:	00bfdfc4 	movi	r2,-129
8112111c:	d8c02a15 	stw	r3,168(sp)
81121120:	90a4703a 	and	r18,r18,r2
81121124:	d8c02e15 	stw	r3,184(sp)
81121128:	d8002915 	stw	zero,164(sp)
8112112c:	d8003215 	stw	zero,200(sp)
81121130:	00003706 	br	81121210 <___vfprintf_internal_r+0x73c>
81121134:	94800214 	ori	r18,r18,8
81121138:	ac400007 	ldb	r17,0(r21)
8112113c:	003ec806 	br	81120c60 <__reset+0xfb100c60>
81121140:	18c03fcc 	andi	r3,r3,255
81121144:	1806db1e 	bne	r3,zero,81122cb4 <___vfprintf_internal_r+0x21e0>
81121148:	94800414 	ori	r18,r18,16
8112114c:	9080080c 	andi	r2,r18,32
81121150:	1002d826 	beq	r2,zero,81121cb4 <___vfprintf_internal_r+0x11e0>
81121154:	d9402d17 	ldw	r5,180(sp)
81121158:	d8c02917 	ldw	r3,164(sp)
8112115c:	d8002785 	stb	zero,158(sp)
81121160:	28800204 	addi	r2,r5,8
81121164:	2cc00017 	ldw	r19,0(r5)
81121168:	2d800117 	ldw	r22,4(r5)
8112116c:	18048f16 	blt	r3,zero,811223ac <___vfprintf_internal_r+0x18d8>
81121170:	013fdfc4 	movi	r4,-129
81121174:	9d86b03a 	or	r3,r19,r22
81121178:	d8802d15 	stw	r2,180(sp)
8112117c:	9124703a 	and	r18,r18,r4
81121180:	1802d91e 	bne	r3,zero,81121ce8 <___vfprintf_internal_r+0x1214>
81121184:	d8c02917 	ldw	r3,164(sp)
81121188:	0039883a 	mov	fp,zero
8112118c:	1805c326 	beq	r3,zero,8112289c <___vfprintf_internal_r+0x1dc8>
81121190:	0027883a 	mov	r19,zero
81121194:	002d883a 	mov	r22,zero
81121198:	dc001e04 	addi	r16,sp,120
8112119c:	9806d0fa 	srli	r3,r19,3
811211a0:	b008977a 	slli	r4,r22,29
811211a4:	b02cd0fa 	srli	r22,r22,3
811211a8:	9cc001cc 	andi	r19,r19,7
811211ac:	98800c04 	addi	r2,r19,48
811211b0:	843fffc4 	addi	r16,r16,-1
811211b4:	20e6b03a 	or	r19,r4,r3
811211b8:	80800005 	stb	r2,0(r16)
811211bc:	9d86b03a 	or	r3,r19,r22
811211c0:	183ff61e 	bne	r3,zero,8112119c <__reset+0xfb10119c>
811211c4:	90c0004c 	andi	r3,r18,1
811211c8:	18013b26 	beq	r3,zero,811216b8 <___vfprintf_internal_r+0xbe4>
811211cc:	10803fcc 	andi	r2,r2,255
811211d0:	1080201c 	xori	r2,r2,128
811211d4:	10bfe004 	addi	r2,r2,-128
811211d8:	00c00c04 	movi	r3,48
811211dc:	10c13626 	beq	r2,r3,811216b8 <___vfprintf_internal_r+0xbe4>
811211e0:	80ffffc5 	stb	r3,-1(r16)
811211e4:	d8c02817 	ldw	r3,160(sp)
811211e8:	80bfffc4 	addi	r2,r16,-1
811211ec:	1021883a 	mov	r16,r2
811211f0:	1887c83a 	sub	r3,r3,r2
811211f4:	d8c02e15 	stw	r3,184(sp)
811211f8:	d8802e17 	ldw	r2,184(sp)
811211fc:	d9002917 	ldw	r4,164(sp)
81121200:	1100010e 	bge	r2,r4,81121208 <___vfprintf_internal_r+0x734>
81121204:	2005883a 	mov	r2,r4
81121208:	d8802a15 	stw	r2,168(sp)
8112120c:	d8003215 	stw	zero,200(sp)
81121210:	e7003fcc 	andi	fp,fp,255
81121214:	e700201c 	xori	fp,fp,128
81121218:	e73fe004 	addi	fp,fp,-128
8112121c:	e0000326 	beq	fp,zero,8112122c <___vfprintf_internal_r+0x758>
81121220:	d8c02a17 	ldw	r3,168(sp)
81121224:	18c00044 	addi	r3,r3,1
81121228:	d8c02a15 	stw	r3,168(sp)
8112122c:	90c0008c 	andi	r3,r18,2
81121230:	d8c02b15 	stw	r3,172(sp)
81121234:	18000326 	beq	r3,zero,81121244 <___vfprintf_internal_r+0x770>
81121238:	d8c02a17 	ldw	r3,168(sp)
8112123c:	18c00084 	addi	r3,r3,2
81121240:	d8c02a15 	stw	r3,168(sp)
81121244:	90c0210c 	andi	r3,r18,132
81121248:	d8c03015 	stw	r3,192(sp)
8112124c:	1801a31e 	bne	r3,zero,811218dc <___vfprintf_internal_r+0xe08>
81121250:	d9003117 	ldw	r4,196(sp)
81121254:	d8c02a17 	ldw	r3,168(sp)
81121258:	20e7c83a 	sub	r19,r4,r3
8112125c:	04c19f0e 	bge	zero,r19,811218dc <___vfprintf_internal_r+0xe08>
81121260:	02400404 	movi	r9,16
81121264:	d8c02017 	ldw	r3,128(sp)
81121268:	d8801f17 	ldw	r2,124(sp)
8112126c:	4cc50d0e 	bge	r9,r19,811226a4 <___vfprintf_internal_r+0x1bd0>
81121270:	01604574 	movhi	r5,33045
81121274:	2970c684 	addi	r5,r5,-15590
81121278:	dc403b15 	stw	r17,236(sp)
8112127c:	d9403515 	stw	r5,212(sp)
81121280:	9823883a 	mov	r17,r19
81121284:	482d883a 	mov	r22,r9
81121288:	9027883a 	mov	r19,r18
8112128c:	070001c4 	movi	fp,7
81121290:	8025883a 	mov	r18,r16
81121294:	dc002c17 	ldw	r16,176(sp)
81121298:	00000306 	br	811212a8 <___vfprintf_internal_r+0x7d4>
8112129c:	8c7ffc04 	addi	r17,r17,-16
811212a0:	42000204 	addi	r8,r8,8
811212a4:	b440130e 	bge	r22,r17,811212f4 <___vfprintf_internal_r+0x820>
811212a8:	01204574 	movhi	r4,33045
811212ac:	18c00404 	addi	r3,r3,16
811212b0:	10800044 	addi	r2,r2,1
811212b4:	2130c684 	addi	r4,r4,-15590
811212b8:	41000015 	stw	r4,0(r8)
811212bc:	45800115 	stw	r22,4(r8)
811212c0:	d8c02015 	stw	r3,128(sp)
811212c4:	d8801f15 	stw	r2,124(sp)
811212c8:	e0bff40e 	bge	fp,r2,8112129c <__reset+0xfb10129c>
811212cc:	d9801e04 	addi	r6,sp,120
811212d0:	b80b883a 	mov	r5,r23
811212d4:	8009883a 	mov	r4,r16
811212d8:	112ccc40 	call	8112ccc4 <__sprint_r>
811212dc:	103f011e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811212e0:	8c7ffc04 	addi	r17,r17,-16
811212e4:	d8c02017 	ldw	r3,128(sp)
811212e8:	d8801f17 	ldw	r2,124(sp)
811212ec:	da000404 	addi	r8,sp,16
811212f0:	b47fed16 	blt	r22,r17,811212a8 <__reset+0xfb1012a8>
811212f4:	9021883a 	mov	r16,r18
811212f8:	9825883a 	mov	r18,r19
811212fc:	8827883a 	mov	r19,r17
81121300:	dc403b17 	ldw	r17,236(sp)
81121304:	d9403517 	ldw	r5,212(sp)
81121308:	98c7883a 	add	r3,r19,r3
8112130c:	10800044 	addi	r2,r2,1
81121310:	41400015 	stw	r5,0(r8)
81121314:	44c00115 	stw	r19,4(r8)
81121318:	d8c02015 	stw	r3,128(sp)
8112131c:	d8801f15 	stw	r2,124(sp)
81121320:	010001c4 	movi	r4,7
81121324:	2082a316 	blt	r4,r2,81121db4 <___vfprintf_internal_r+0x12e0>
81121328:	df002787 	ldb	fp,158(sp)
8112132c:	42000204 	addi	r8,r8,8
81121330:	e0000c26 	beq	fp,zero,81121364 <___vfprintf_internal_r+0x890>
81121334:	d8801f17 	ldw	r2,124(sp)
81121338:	d9002784 	addi	r4,sp,158
8112133c:	18c00044 	addi	r3,r3,1
81121340:	10800044 	addi	r2,r2,1
81121344:	41000015 	stw	r4,0(r8)
81121348:	01000044 	movi	r4,1
8112134c:	41000115 	stw	r4,4(r8)
81121350:	d8c02015 	stw	r3,128(sp)
81121354:	d8801f15 	stw	r2,124(sp)
81121358:	010001c4 	movi	r4,7
8112135c:	20823c16 	blt	r4,r2,81121c50 <___vfprintf_internal_r+0x117c>
81121360:	42000204 	addi	r8,r8,8
81121364:	d8802b17 	ldw	r2,172(sp)
81121368:	10000c26 	beq	r2,zero,8112139c <___vfprintf_internal_r+0x8c8>
8112136c:	d8801f17 	ldw	r2,124(sp)
81121370:	d9002704 	addi	r4,sp,156
81121374:	18c00084 	addi	r3,r3,2
81121378:	10800044 	addi	r2,r2,1
8112137c:	41000015 	stw	r4,0(r8)
81121380:	01000084 	movi	r4,2
81121384:	41000115 	stw	r4,4(r8)
81121388:	d8c02015 	stw	r3,128(sp)
8112138c:	d8801f15 	stw	r2,124(sp)
81121390:	010001c4 	movi	r4,7
81121394:	20823616 	blt	r4,r2,81121c70 <___vfprintf_internal_r+0x119c>
81121398:	42000204 	addi	r8,r8,8
8112139c:	d9003017 	ldw	r4,192(sp)
811213a0:	00802004 	movi	r2,128
811213a4:	20819926 	beq	r4,r2,81121a0c <___vfprintf_internal_r+0xf38>
811213a8:	d9402917 	ldw	r5,164(sp)
811213ac:	d8802e17 	ldw	r2,184(sp)
811213b0:	28adc83a 	sub	r22,r5,r2
811213b4:	0580310e 	bge	zero,r22,8112147c <___vfprintf_internal_r+0x9a8>
811213b8:	07000404 	movi	fp,16
811213bc:	d8801f17 	ldw	r2,124(sp)
811213c0:	e584140e 	bge	fp,r22,81122414 <___vfprintf_internal_r+0x1940>
811213c4:	01604574 	movhi	r5,33045
811213c8:	2970c284 	addi	r5,r5,-15606
811213cc:	dc402915 	stw	r17,164(sp)
811213d0:	d9402b15 	stw	r5,172(sp)
811213d4:	b023883a 	mov	r17,r22
811213d8:	04c001c4 	movi	r19,7
811213dc:	a82d883a 	mov	r22,r21
811213e0:	902b883a 	mov	r21,r18
811213e4:	8025883a 	mov	r18,r16
811213e8:	dc002c17 	ldw	r16,176(sp)
811213ec:	00000306 	br	811213fc <___vfprintf_internal_r+0x928>
811213f0:	8c7ffc04 	addi	r17,r17,-16
811213f4:	42000204 	addi	r8,r8,8
811213f8:	e440110e 	bge	fp,r17,81121440 <___vfprintf_internal_r+0x96c>
811213fc:	18c00404 	addi	r3,r3,16
81121400:	10800044 	addi	r2,r2,1
81121404:	45000015 	stw	r20,0(r8)
81121408:	47000115 	stw	fp,4(r8)
8112140c:	d8c02015 	stw	r3,128(sp)
81121410:	d8801f15 	stw	r2,124(sp)
81121414:	98bff60e 	bge	r19,r2,811213f0 <__reset+0xfb1013f0>
81121418:	d9801e04 	addi	r6,sp,120
8112141c:	b80b883a 	mov	r5,r23
81121420:	8009883a 	mov	r4,r16
81121424:	112ccc40 	call	8112ccc4 <__sprint_r>
81121428:	103eae1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
8112142c:	8c7ffc04 	addi	r17,r17,-16
81121430:	d8c02017 	ldw	r3,128(sp)
81121434:	d8801f17 	ldw	r2,124(sp)
81121438:	da000404 	addi	r8,sp,16
8112143c:	e47fef16 	blt	fp,r17,811213fc <__reset+0xfb1013fc>
81121440:	9021883a 	mov	r16,r18
81121444:	a825883a 	mov	r18,r21
81121448:	b02b883a 	mov	r21,r22
8112144c:	882d883a 	mov	r22,r17
81121450:	dc402917 	ldw	r17,164(sp)
81121454:	d9002b17 	ldw	r4,172(sp)
81121458:	1d87883a 	add	r3,r3,r22
8112145c:	10800044 	addi	r2,r2,1
81121460:	41000015 	stw	r4,0(r8)
81121464:	45800115 	stw	r22,4(r8)
81121468:	d8c02015 	stw	r3,128(sp)
8112146c:	d8801f15 	stw	r2,124(sp)
81121470:	010001c4 	movi	r4,7
81121474:	2081ee16 	blt	r4,r2,81121c30 <___vfprintf_internal_r+0x115c>
81121478:	42000204 	addi	r8,r8,8
8112147c:	9080400c 	andi	r2,r18,256
81121480:	1001181e 	bne	r2,zero,811218e4 <___vfprintf_internal_r+0xe10>
81121484:	d9402e17 	ldw	r5,184(sp)
81121488:	d8801f17 	ldw	r2,124(sp)
8112148c:	44000015 	stw	r16,0(r8)
81121490:	1947883a 	add	r3,r3,r5
81121494:	10800044 	addi	r2,r2,1
81121498:	41400115 	stw	r5,4(r8)
8112149c:	d8c02015 	stw	r3,128(sp)
811214a0:	d8801f15 	stw	r2,124(sp)
811214a4:	010001c4 	movi	r4,7
811214a8:	2081d316 	blt	r4,r2,81121bf8 <___vfprintf_internal_r+0x1124>
811214ac:	42000204 	addi	r8,r8,8
811214b0:	9480010c 	andi	r18,r18,4
811214b4:	90003226 	beq	r18,zero,81121580 <___vfprintf_internal_r+0xaac>
811214b8:	d9403117 	ldw	r5,196(sp)
811214bc:	d8802a17 	ldw	r2,168(sp)
811214c0:	28a1c83a 	sub	r16,r5,r2
811214c4:	04002e0e 	bge	zero,r16,81121580 <___vfprintf_internal_r+0xaac>
811214c8:	04400404 	movi	r17,16
811214cc:	d8801f17 	ldw	r2,124(sp)
811214d0:	8c04a20e 	bge	r17,r16,8112275c <___vfprintf_internal_r+0x1c88>
811214d4:	01604574 	movhi	r5,33045
811214d8:	2970c684 	addi	r5,r5,-15590
811214dc:	d9403515 	stw	r5,212(sp)
811214e0:	048001c4 	movi	r18,7
811214e4:	dcc02c17 	ldw	r19,176(sp)
811214e8:	00000306 	br	811214f8 <___vfprintf_internal_r+0xa24>
811214ec:	843ffc04 	addi	r16,r16,-16
811214f0:	42000204 	addi	r8,r8,8
811214f4:	8c00130e 	bge	r17,r16,81121544 <___vfprintf_internal_r+0xa70>
811214f8:	01204574 	movhi	r4,33045
811214fc:	18c00404 	addi	r3,r3,16
81121500:	10800044 	addi	r2,r2,1
81121504:	2130c684 	addi	r4,r4,-15590
81121508:	41000015 	stw	r4,0(r8)
8112150c:	44400115 	stw	r17,4(r8)
81121510:	d8c02015 	stw	r3,128(sp)
81121514:	d8801f15 	stw	r2,124(sp)
81121518:	90bff40e 	bge	r18,r2,811214ec <__reset+0xfb1014ec>
8112151c:	d9801e04 	addi	r6,sp,120
81121520:	b80b883a 	mov	r5,r23
81121524:	9809883a 	mov	r4,r19
81121528:	112ccc40 	call	8112ccc4 <__sprint_r>
8112152c:	103e6d1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121530:	843ffc04 	addi	r16,r16,-16
81121534:	d8c02017 	ldw	r3,128(sp)
81121538:	d8801f17 	ldw	r2,124(sp)
8112153c:	da000404 	addi	r8,sp,16
81121540:	8c3fed16 	blt	r17,r16,811214f8 <__reset+0xfb1014f8>
81121544:	d9403517 	ldw	r5,212(sp)
81121548:	1c07883a 	add	r3,r3,r16
8112154c:	10800044 	addi	r2,r2,1
81121550:	41400015 	stw	r5,0(r8)
81121554:	44000115 	stw	r16,4(r8)
81121558:	d8c02015 	stw	r3,128(sp)
8112155c:	d8801f15 	stw	r2,124(sp)
81121560:	010001c4 	movi	r4,7
81121564:	2080060e 	bge	r4,r2,81121580 <___vfprintf_internal_r+0xaac>
81121568:	d9002c17 	ldw	r4,176(sp)
8112156c:	d9801e04 	addi	r6,sp,120
81121570:	b80b883a 	mov	r5,r23
81121574:	112ccc40 	call	8112ccc4 <__sprint_r>
81121578:	103e5a1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
8112157c:	d8c02017 	ldw	r3,128(sp)
81121580:	d8803117 	ldw	r2,196(sp)
81121584:	d9002a17 	ldw	r4,168(sp)
81121588:	1100010e 	bge	r2,r4,81121590 <___vfprintf_internal_r+0xabc>
8112158c:	2005883a 	mov	r2,r4
81121590:	d9402f17 	ldw	r5,188(sp)
81121594:	288b883a 	add	r5,r5,r2
81121598:	d9402f15 	stw	r5,188(sp)
8112159c:	18019e1e 	bne	r3,zero,81121c18 <___vfprintf_internal_r+0x1144>
811215a0:	a8800007 	ldb	r2,0(r21)
811215a4:	d8001f15 	stw	zero,124(sp)
811215a8:	da000404 	addi	r8,sp,16
811215ac:	103d851e 	bne	r2,zero,81120bc4 <__reset+0xfb100bc4>
811215b0:	a821883a 	mov	r16,r21
811215b4:	003d9b06 	br	81120c24 <__reset+0xfb100c24>
811215b8:	18c03fcc 	andi	r3,r3,255
811215bc:	1805c11e 	bne	r3,zero,81122cc4 <___vfprintf_internal_r+0x21f0>
811215c0:	94800414 	ori	r18,r18,16
811215c4:	9080080c 	andi	r2,r18,32
811215c8:	10020c26 	beq	r2,zero,81121dfc <___vfprintf_internal_r+0x1328>
811215cc:	d8802d17 	ldw	r2,180(sp)
811215d0:	d9002917 	ldw	r4,164(sp)
811215d4:	d8002785 	stb	zero,158(sp)
811215d8:	10c00204 	addi	r3,r2,8
811215dc:	14c00017 	ldw	r19,0(r2)
811215e0:	15800117 	ldw	r22,4(r2)
811215e4:	20040f16 	blt	r4,zero,81122624 <___vfprintf_internal_r+0x1b50>
811215e8:	013fdfc4 	movi	r4,-129
811215ec:	9d84b03a 	or	r2,r19,r22
811215f0:	d8c02d15 	stw	r3,180(sp)
811215f4:	9124703a 	and	r18,r18,r4
811215f8:	0039883a 	mov	fp,zero
811215fc:	103e891e 	bne	r2,zero,81121024 <__reset+0xfb101024>
81121600:	d9002917 	ldw	r4,164(sp)
81121604:	2002c11e 	bne	r4,zero,8112210c <___vfprintf_internal_r+0x1638>
81121608:	d8002915 	stw	zero,164(sp)
8112160c:	d8002e15 	stw	zero,184(sp)
81121610:	dc001e04 	addi	r16,sp,120
81121614:	003ef806 	br	811211f8 <__reset+0xfb1011f8>
81121618:	18c03fcc 	andi	r3,r3,255
8112161c:	18059d1e 	bne	r3,zero,81122c94 <___vfprintf_internal_r+0x21c0>
81121620:	01604574 	movhi	r5,33045
81121624:	2970ae04 	addi	r5,r5,-15688
81121628:	d9403915 	stw	r5,228(sp)
8112162c:	9080080c 	andi	r2,r18,32
81121630:	10005226 	beq	r2,zero,8112177c <___vfprintf_internal_r+0xca8>
81121634:	d8802d17 	ldw	r2,180(sp)
81121638:	14c00017 	ldw	r19,0(r2)
8112163c:	15800117 	ldw	r22,4(r2)
81121640:	10800204 	addi	r2,r2,8
81121644:	d8802d15 	stw	r2,180(sp)
81121648:	9080004c 	andi	r2,r18,1
8112164c:	10019026 	beq	r2,zero,81121c90 <___vfprintf_internal_r+0x11bc>
81121650:	9d84b03a 	or	r2,r19,r22
81121654:	10036926 	beq	r2,zero,811223fc <___vfprintf_internal_r+0x1928>
81121658:	d8c02917 	ldw	r3,164(sp)
8112165c:	00800c04 	movi	r2,48
81121660:	d8802705 	stb	r2,156(sp)
81121664:	dc402745 	stb	r17,157(sp)
81121668:	d8002785 	stb	zero,158(sp)
8112166c:	90800094 	ori	r2,r18,2
81121670:	18045d16 	blt	r3,zero,811227e8 <___vfprintf_internal_r+0x1d14>
81121674:	00bfdfc4 	movi	r2,-129
81121678:	90a4703a 	and	r18,r18,r2
8112167c:	94800094 	ori	r18,r18,2
81121680:	0039883a 	mov	fp,zero
81121684:	d9003917 	ldw	r4,228(sp)
81121688:	dc001e04 	addi	r16,sp,120
8112168c:	988003cc 	andi	r2,r19,15
81121690:	b006973a 	slli	r3,r22,28
81121694:	2085883a 	add	r2,r4,r2
81121698:	9826d13a 	srli	r19,r19,4
8112169c:	10800003 	ldbu	r2,0(r2)
811216a0:	b02cd13a 	srli	r22,r22,4
811216a4:	843fffc4 	addi	r16,r16,-1
811216a8:	1ce6b03a 	or	r19,r3,r19
811216ac:	80800005 	stb	r2,0(r16)
811216b0:	9d84b03a 	or	r2,r19,r22
811216b4:	103ff51e 	bne	r2,zero,8112168c <__reset+0xfb10168c>
811216b8:	d8c02817 	ldw	r3,160(sp)
811216bc:	1c07c83a 	sub	r3,r3,r16
811216c0:	d8c02e15 	stw	r3,184(sp)
811216c4:	003ecc06 	br	811211f8 <__reset+0xfb1011f8>
811216c8:	18c03fcc 	andi	r3,r3,255
811216cc:	183e9f26 	beq	r3,zero,8112114c <__reset+0xfb10114c>
811216d0:	d9c02785 	stb	r7,158(sp)
811216d4:	003e9d06 	br	8112114c <__reset+0xfb10114c>
811216d8:	00c00044 	movi	r3,1
811216dc:	01c00ac4 	movi	r7,43
811216e0:	ac400007 	ldb	r17,0(r21)
811216e4:	003d5e06 	br	81120c60 <__reset+0xfb100c60>
811216e8:	94800814 	ori	r18,r18,32
811216ec:	ac400007 	ldb	r17,0(r21)
811216f0:	003d5b06 	br	81120c60 <__reset+0xfb100c60>
811216f4:	d8c02d17 	ldw	r3,180(sp)
811216f8:	d8002785 	stb	zero,158(sp)
811216fc:	1c000017 	ldw	r16,0(r3)
81121700:	1cc00104 	addi	r19,r3,4
81121704:	80041926 	beq	r16,zero,8112276c <___vfprintf_internal_r+0x1c98>
81121708:	d9002917 	ldw	r4,164(sp)
8112170c:	2003d016 	blt	r4,zero,81122650 <___vfprintf_internal_r+0x1b7c>
81121710:	200d883a 	mov	r6,r4
81121714:	000b883a 	mov	r5,zero
81121718:	8009883a 	mov	r4,r16
8112171c:	da003d15 	stw	r8,244(sp)
81121720:	1127ab80 	call	81127ab8 <memchr>
81121724:	da003d17 	ldw	r8,244(sp)
81121728:	10045426 	beq	r2,zero,8112287c <___vfprintf_internal_r+0x1da8>
8112172c:	1405c83a 	sub	r2,r2,r16
81121730:	d8802e15 	stw	r2,184(sp)
81121734:	1003cc16 	blt	r2,zero,81122668 <___vfprintf_internal_r+0x1b94>
81121738:	df002783 	ldbu	fp,158(sp)
8112173c:	d8802a15 	stw	r2,168(sp)
81121740:	dcc02d15 	stw	r19,180(sp)
81121744:	d8002915 	stw	zero,164(sp)
81121748:	d8003215 	stw	zero,200(sp)
8112174c:	003eb006 	br	81121210 <__reset+0xfb101210>
81121750:	18c03fcc 	andi	r3,r3,255
81121754:	183f9b26 	beq	r3,zero,811215c4 <__reset+0xfb1015c4>
81121758:	d9c02785 	stb	r7,158(sp)
8112175c:	003f9906 	br	811215c4 <__reset+0xfb1015c4>
81121760:	18c03fcc 	andi	r3,r3,255
81121764:	1805551e 	bne	r3,zero,81122cbc <___vfprintf_internal_r+0x21e8>
81121768:	01604574 	movhi	r5,33045
8112176c:	2970b304 	addi	r5,r5,-15668
81121770:	d9403915 	stw	r5,228(sp)
81121774:	9080080c 	andi	r2,r18,32
81121778:	103fae1e 	bne	r2,zero,81121634 <__reset+0xfb101634>
8112177c:	9080040c 	andi	r2,r18,16
81121780:	1002de26 	beq	r2,zero,811222fc <___vfprintf_internal_r+0x1828>
81121784:	d8c02d17 	ldw	r3,180(sp)
81121788:	002d883a 	mov	r22,zero
8112178c:	1cc00017 	ldw	r19,0(r3)
81121790:	18c00104 	addi	r3,r3,4
81121794:	d8c02d15 	stw	r3,180(sp)
81121798:	003fab06 	br	81121648 <__reset+0xfb101648>
8112179c:	38803fcc 	andi	r2,r7,255
811217a0:	1080201c 	xori	r2,r2,128
811217a4:	10bfe004 	addi	r2,r2,-128
811217a8:	1002d21e 	bne	r2,zero,811222f4 <___vfprintf_internal_r+0x1820>
811217ac:	00c00044 	movi	r3,1
811217b0:	01c00804 	movi	r7,32
811217b4:	ac400007 	ldb	r17,0(r21)
811217b8:	003d2906 	br	81120c60 <__reset+0xfb100c60>
811217bc:	94800054 	ori	r18,r18,1
811217c0:	ac400007 	ldb	r17,0(r21)
811217c4:	003d2606 	br	81120c60 <__reset+0xfb100c60>
811217c8:	18c03fcc 	andi	r3,r3,255
811217cc:	183e0526 	beq	r3,zero,81120fe4 <__reset+0xfb100fe4>
811217d0:	d9c02785 	stb	r7,158(sp)
811217d4:	003e0306 	br	81120fe4 <__reset+0xfb100fe4>
811217d8:	94801014 	ori	r18,r18,64
811217dc:	ac400007 	ldb	r17,0(r21)
811217e0:	003d1f06 	br	81120c60 <__reset+0xfb100c60>
811217e4:	ac400007 	ldb	r17,0(r21)
811217e8:	8a438726 	beq	r17,r9,81122608 <___vfprintf_internal_r+0x1b34>
811217ec:	94800414 	ori	r18,r18,16
811217f0:	003d1b06 	br	81120c60 <__reset+0xfb100c60>
811217f4:	18c03fcc 	andi	r3,r3,255
811217f8:	1805341e 	bne	r3,zero,81122ccc <___vfprintf_internal_r+0x21f8>
811217fc:	9080080c 	andi	r2,r18,32
81121800:	1002cd26 	beq	r2,zero,81122338 <___vfprintf_internal_r+0x1864>
81121804:	d9402d17 	ldw	r5,180(sp)
81121808:	d9002f17 	ldw	r4,188(sp)
8112180c:	28800017 	ldw	r2,0(r5)
81121810:	2007d7fa 	srai	r3,r4,31
81121814:	29400104 	addi	r5,r5,4
81121818:	d9402d15 	stw	r5,180(sp)
8112181c:	11000015 	stw	r4,0(r2)
81121820:	10c00115 	stw	r3,4(r2)
81121824:	003ce506 	br	81120bbc <__reset+0xfb100bbc>
81121828:	d8c02d17 	ldw	r3,180(sp)
8112182c:	d9002d17 	ldw	r4,180(sp)
81121830:	d8002785 	stb	zero,158(sp)
81121834:	18800017 	ldw	r2,0(r3)
81121838:	21000104 	addi	r4,r4,4
8112183c:	00c00044 	movi	r3,1
81121840:	d8c02a15 	stw	r3,168(sp)
81121844:	d8801405 	stb	r2,80(sp)
81121848:	d9002d15 	stw	r4,180(sp)
8112184c:	d8c02e15 	stw	r3,184(sp)
81121850:	d8002915 	stw	zero,164(sp)
81121854:	d8003215 	stw	zero,200(sp)
81121858:	dc001404 	addi	r16,sp,80
8112185c:	0039883a 	mov	fp,zero
81121860:	003e7206 	br	8112122c <__reset+0xfb10122c>
81121864:	01204574 	movhi	r4,33045
81121868:	2130b304 	addi	r4,r4,-15668
8112186c:	0039883a 	mov	fp,zero
81121870:	d9003915 	stw	r4,228(sp)
81121874:	04401e04 	movi	r17,120
81121878:	003f8206 	br	81121684 <__reset+0xfb101684>
8112187c:	18c03fcc 	andi	r3,r3,255
81121880:	1805061e 	bne	r3,zero,81122c9c <___vfprintf_internal_r+0x21c8>
81121884:	883d9126 	beq	r17,zero,81120ecc <__reset+0xfb100ecc>
81121888:	00c00044 	movi	r3,1
8112188c:	d8c02a15 	stw	r3,168(sp)
81121890:	dc401405 	stb	r17,80(sp)
81121894:	d8002785 	stb	zero,158(sp)
81121898:	003fec06 	br	8112184c <__reset+0xfb10184c>
8112189c:	01604574 	movhi	r5,33045
811218a0:	2970b304 	addi	r5,r5,-15668
811218a4:	d9403915 	stw	r5,228(sp)
811218a8:	d8c02d15 	stw	r3,180(sp)
811218ac:	1025883a 	mov	r18,r2
811218b0:	04401e04 	movi	r17,120
811218b4:	9d84b03a 	or	r2,r19,r22
811218b8:	1000fc1e 	bne	r2,zero,81121cac <___vfprintf_internal_r+0x11d8>
811218bc:	0039883a 	mov	fp,zero
811218c0:	00800084 	movi	r2,2
811218c4:	10803fcc 	andi	r2,r2,255
811218c8:	00c00044 	movi	r3,1
811218cc:	10c20f26 	beq	r2,r3,8112210c <___vfprintf_internal_r+0x1638>
811218d0:	00c00084 	movi	r3,2
811218d4:	10fd6326 	beq	r2,r3,81120e64 <__reset+0xfb100e64>
811218d8:	003e2d06 	br	81121190 <__reset+0xfb101190>
811218dc:	d8c02017 	ldw	r3,128(sp)
811218e0:	003e9306 	br	81121330 <__reset+0xfb101330>
811218e4:	00801944 	movi	r2,101
811218e8:	14407e0e 	bge	r2,r17,81121ae4 <___vfprintf_internal_r+0x1010>
811218ec:	d9003617 	ldw	r4,216(sp)
811218f0:	d9403817 	ldw	r5,224(sp)
811218f4:	000d883a 	mov	r6,zero
811218f8:	000f883a 	mov	r7,zero
811218fc:	d8c03c15 	stw	r3,240(sp)
81121900:	da003d15 	stw	r8,244(sp)
81121904:	113150c0 	call	8113150c <__eqdf2>
81121908:	d8c03c17 	ldw	r3,240(sp)
8112190c:	da003d17 	ldw	r8,244(sp)
81121910:	1000f71e 	bne	r2,zero,81121cf0 <___vfprintf_internal_r+0x121c>
81121914:	d8801f17 	ldw	r2,124(sp)
81121918:	01204574 	movhi	r4,33045
8112191c:	2130ba04 	addi	r4,r4,-15640
81121920:	18c00044 	addi	r3,r3,1
81121924:	10800044 	addi	r2,r2,1
81121928:	41000015 	stw	r4,0(r8)
8112192c:	01000044 	movi	r4,1
81121930:	41000115 	stw	r4,4(r8)
81121934:	d8c02015 	stw	r3,128(sp)
81121938:	d8801f15 	stw	r2,124(sp)
8112193c:	010001c4 	movi	r4,7
81121940:	2082b816 	blt	r4,r2,81122424 <___vfprintf_internal_r+0x1950>
81121944:	42000204 	addi	r8,r8,8
81121948:	d8802617 	ldw	r2,152(sp)
8112194c:	d9403317 	ldw	r5,204(sp)
81121950:	11400216 	blt	r2,r5,8112195c <___vfprintf_internal_r+0xe88>
81121954:	9080004c 	andi	r2,r18,1
81121958:	103ed526 	beq	r2,zero,811214b0 <__reset+0xfb1014b0>
8112195c:	d8803717 	ldw	r2,220(sp)
81121960:	d9003417 	ldw	r4,208(sp)
81121964:	d9403717 	ldw	r5,220(sp)
81121968:	1887883a 	add	r3,r3,r2
8112196c:	d8801f17 	ldw	r2,124(sp)
81121970:	41000015 	stw	r4,0(r8)
81121974:	41400115 	stw	r5,4(r8)
81121978:	10800044 	addi	r2,r2,1
8112197c:	d8c02015 	stw	r3,128(sp)
81121980:	d8801f15 	stw	r2,124(sp)
81121984:	010001c4 	movi	r4,7
81121988:	20832916 	blt	r4,r2,81122630 <___vfprintf_internal_r+0x1b5c>
8112198c:	42000204 	addi	r8,r8,8
81121990:	d8803317 	ldw	r2,204(sp)
81121994:	143fffc4 	addi	r16,r2,-1
81121998:	043ec50e 	bge	zero,r16,811214b0 <__reset+0xfb1014b0>
8112199c:	04400404 	movi	r17,16
811219a0:	d8801f17 	ldw	r2,124(sp)
811219a4:	8c00880e 	bge	r17,r16,81121bc8 <___vfprintf_internal_r+0x10f4>
811219a8:	01604574 	movhi	r5,33045
811219ac:	2970c284 	addi	r5,r5,-15606
811219b0:	d9402b15 	stw	r5,172(sp)
811219b4:	058001c4 	movi	r22,7
811219b8:	dcc02c17 	ldw	r19,176(sp)
811219bc:	00000306 	br	811219cc <___vfprintf_internal_r+0xef8>
811219c0:	42000204 	addi	r8,r8,8
811219c4:	843ffc04 	addi	r16,r16,-16
811219c8:	8c00820e 	bge	r17,r16,81121bd4 <___vfprintf_internal_r+0x1100>
811219cc:	18c00404 	addi	r3,r3,16
811219d0:	10800044 	addi	r2,r2,1
811219d4:	45000015 	stw	r20,0(r8)
811219d8:	44400115 	stw	r17,4(r8)
811219dc:	d8c02015 	stw	r3,128(sp)
811219e0:	d8801f15 	stw	r2,124(sp)
811219e4:	b0bff60e 	bge	r22,r2,811219c0 <__reset+0xfb1019c0>
811219e8:	d9801e04 	addi	r6,sp,120
811219ec:	b80b883a 	mov	r5,r23
811219f0:	9809883a 	mov	r4,r19
811219f4:	112ccc40 	call	8112ccc4 <__sprint_r>
811219f8:	103d3a1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811219fc:	d8c02017 	ldw	r3,128(sp)
81121a00:	d8801f17 	ldw	r2,124(sp)
81121a04:	da000404 	addi	r8,sp,16
81121a08:	003fee06 	br	811219c4 <__reset+0xfb1019c4>
81121a0c:	d9403117 	ldw	r5,196(sp)
81121a10:	d8802a17 	ldw	r2,168(sp)
81121a14:	28adc83a 	sub	r22,r5,r2
81121a18:	05be630e 	bge	zero,r22,811213a8 <__reset+0xfb1013a8>
81121a1c:	07000404 	movi	fp,16
81121a20:	d8801f17 	ldw	r2,124(sp)
81121a24:	e5838f0e 	bge	fp,r22,81122864 <___vfprintf_internal_r+0x1d90>
81121a28:	01604574 	movhi	r5,33045
81121a2c:	2970c284 	addi	r5,r5,-15606
81121a30:	dc403015 	stw	r17,192(sp)
81121a34:	d9402b15 	stw	r5,172(sp)
81121a38:	b023883a 	mov	r17,r22
81121a3c:	04c001c4 	movi	r19,7
81121a40:	a82d883a 	mov	r22,r21
81121a44:	902b883a 	mov	r21,r18
81121a48:	8025883a 	mov	r18,r16
81121a4c:	dc002c17 	ldw	r16,176(sp)
81121a50:	00000306 	br	81121a60 <___vfprintf_internal_r+0xf8c>
81121a54:	8c7ffc04 	addi	r17,r17,-16
81121a58:	42000204 	addi	r8,r8,8
81121a5c:	e440110e 	bge	fp,r17,81121aa4 <___vfprintf_internal_r+0xfd0>
81121a60:	18c00404 	addi	r3,r3,16
81121a64:	10800044 	addi	r2,r2,1
81121a68:	45000015 	stw	r20,0(r8)
81121a6c:	47000115 	stw	fp,4(r8)
81121a70:	d8c02015 	stw	r3,128(sp)
81121a74:	d8801f15 	stw	r2,124(sp)
81121a78:	98bff60e 	bge	r19,r2,81121a54 <__reset+0xfb101a54>
81121a7c:	d9801e04 	addi	r6,sp,120
81121a80:	b80b883a 	mov	r5,r23
81121a84:	8009883a 	mov	r4,r16
81121a88:	112ccc40 	call	8112ccc4 <__sprint_r>
81121a8c:	103d151e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121a90:	8c7ffc04 	addi	r17,r17,-16
81121a94:	d8c02017 	ldw	r3,128(sp)
81121a98:	d8801f17 	ldw	r2,124(sp)
81121a9c:	da000404 	addi	r8,sp,16
81121aa0:	e47fef16 	blt	fp,r17,81121a60 <__reset+0xfb101a60>
81121aa4:	9021883a 	mov	r16,r18
81121aa8:	a825883a 	mov	r18,r21
81121aac:	b02b883a 	mov	r21,r22
81121ab0:	882d883a 	mov	r22,r17
81121ab4:	dc403017 	ldw	r17,192(sp)
81121ab8:	d9002b17 	ldw	r4,172(sp)
81121abc:	1d87883a 	add	r3,r3,r22
81121ac0:	10800044 	addi	r2,r2,1
81121ac4:	41000015 	stw	r4,0(r8)
81121ac8:	45800115 	stw	r22,4(r8)
81121acc:	d8c02015 	stw	r3,128(sp)
81121ad0:	d8801f15 	stw	r2,124(sp)
81121ad4:	010001c4 	movi	r4,7
81121ad8:	20818e16 	blt	r4,r2,81122114 <___vfprintf_internal_r+0x1640>
81121adc:	42000204 	addi	r8,r8,8
81121ae0:	003e3106 	br	811213a8 <__reset+0xfb1013a8>
81121ae4:	d9403317 	ldw	r5,204(sp)
81121ae8:	00800044 	movi	r2,1
81121aec:	18c00044 	addi	r3,r3,1
81121af0:	1141530e 	bge	r2,r5,81122040 <___vfprintf_internal_r+0x156c>
81121af4:	dc401f17 	ldw	r17,124(sp)
81121af8:	00800044 	movi	r2,1
81121afc:	40800115 	stw	r2,4(r8)
81121b00:	8c400044 	addi	r17,r17,1
81121b04:	44000015 	stw	r16,0(r8)
81121b08:	d8c02015 	stw	r3,128(sp)
81121b0c:	dc401f15 	stw	r17,124(sp)
81121b10:	008001c4 	movi	r2,7
81121b14:	14416b16 	blt	r2,r17,811220c4 <___vfprintf_internal_r+0x15f0>
81121b18:	42000204 	addi	r8,r8,8
81121b1c:	d8803717 	ldw	r2,220(sp)
81121b20:	d9003417 	ldw	r4,208(sp)
81121b24:	8c400044 	addi	r17,r17,1
81121b28:	10c7883a 	add	r3,r2,r3
81121b2c:	40800115 	stw	r2,4(r8)
81121b30:	41000015 	stw	r4,0(r8)
81121b34:	d8c02015 	stw	r3,128(sp)
81121b38:	dc401f15 	stw	r17,124(sp)
81121b3c:	008001c4 	movi	r2,7
81121b40:	14416916 	blt	r2,r17,811220e8 <___vfprintf_internal_r+0x1614>
81121b44:	45800204 	addi	r22,r8,8
81121b48:	d9003617 	ldw	r4,216(sp)
81121b4c:	d9403817 	ldw	r5,224(sp)
81121b50:	000d883a 	mov	r6,zero
81121b54:	000f883a 	mov	r7,zero
81121b58:	d8c03c15 	stw	r3,240(sp)
81121b5c:	113150c0 	call	8113150c <__eqdf2>
81121b60:	d8c03c17 	ldw	r3,240(sp)
81121b64:	1000bc26 	beq	r2,zero,81121e58 <___vfprintf_internal_r+0x1384>
81121b68:	d9403317 	ldw	r5,204(sp)
81121b6c:	84000044 	addi	r16,r16,1
81121b70:	8c400044 	addi	r17,r17,1
81121b74:	28bfffc4 	addi	r2,r5,-1
81121b78:	1887883a 	add	r3,r3,r2
81121b7c:	b0800115 	stw	r2,4(r22)
81121b80:	b4000015 	stw	r16,0(r22)
81121b84:	d8c02015 	stw	r3,128(sp)
81121b88:	dc401f15 	stw	r17,124(sp)
81121b8c:	008001c4 	movi	r2,7
81121b90:	14414316 	blt	r2,r17,811220a0 <___vfprintf_internal_r+0x15cc>
81121b94:	b5800204 	addi	r22,r22,8
81121b98:	d9003a17 	ldw	r4,232(sp)
81121b9c:	df0022c4 	addi	fp,sp,139
81121ba0:	8c400044 	addi	r17,r17,1
81121ba4:	20c7883a 	add	r3,r4,r3
81121ba8:	b7000015 	stw	fp,0(r22)
81121bac:	b1000115 	stw	r4,4(r22)
81121bb0:	d8c02015 	stw	r3,128(sp)
81121bb4:	dc401f15 	stw	r17,124(sp)
81121bb8:	008001c4 	movi	r2,7
81121bbc:	14400e16 	blt	r2,r17,81121bf8 <___vfprintf_internal_r+0x1124>
81121bc0:	b2000204 	addi	r8,r22,8
81121bc4:	003e3a06 	br	811214b0 <__reset+0xfb1014b0>
81121bc8:	01204574 	movhi	r4,33045
81121bcc:	2130c284 	addi	r4,r4,-15606
81121bd0:	d9002b15 	stw	r4,172(sp)
81121bd4:	d9002b17 	ldw	r4,172(sp)
81121bd8:	1c07883a 	add	r3,r3,r16
81121bdc:	44000115 	stw	r16,4(r8)
81121be0:	41000015 	stw	r4,0(r8)
81121be4:	10800044 	addi	r2,r2,1
81121be8:	d8c02015 	stw	r3,128(sp)
81121bec:	d8801f15 	stw	r2,124(sp)
81121bf0:	010001c4 	movi	r4,7
81121bf4:	20be2d0e 	bge	r4,r2,811214ac <__reset+0xfb1014ac>
81121bf8:	d9002c17 	ldw	r4,176(sp)
81121bfc:	d9801e04 	addi	r6,sp,120
81121c00:	b80b883a 	mov	r5,r23
81121c04:	112ccc40 	call	8112ccc4 <__sprint_r>
81121c08:	103cb61e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121c0c:	d8c02017 	ldw	r3,128(sp)
81121c10:	da000404 	addi	r8,sp,16
81121c14:	003e2606 	br	811214b0 <__reset+0xfb1014b0>
81121c18:	d9002c17 	ldw	r4,176(sp)
81121c1c:	d9801e04 	addi	r6,sp,120
81121c20:	b80b883a 	mov	r5,r23
81121c24:	112ccc40 	call	8112ccc4 <__sprint_r>
81121c28:	103e5d26 	beq	r2,zero,811215a0 <__reset+0xfb1015a0>
81121c2c:	003cad06 	br	81120ee4 <__reset+0xfb100ee4>
81121c30:	d9002c17 	ldw	r4,176(sp)
81121c34:	d9801e04 	addi	r6,sp,120
81121c38:	b80b883a 	mov	r5,r23
81121c3c:	112ccc40 	call	8112ccc4 <__sprint_r>
81121c40:	103ca81e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121c44:	d8c02017 	ldw	r3,128(sp)
81121c48:	da000404 	addi	r8,sp,16
81121c4c:	003e0b06 	br	8112147c <__reset+0xfb10147c>
81121c50:	d9002c17 	ldw	r4,176(sp)
81121c54:	d9801e04 	addi	r6,sp,120
81121c58:	b80b883a 	mov	r5,r23
81121c5c:	112ccc40 	call	8112ccc4 <__sprint_r>
81121c60:	103ca01e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121c64:	d8c02017 	ldw	r3,128(sp)
81121c68:	da000404 	addi	r8,sp,16
81121c6c:	003dbd06 	br	81121364 <__reset+0xfb101364>
81121c70:	d9002c17 	ldw	r4,176(sp)
81121c74:	d9801e04 	addi	r6,sp,120
81121c78:	b80b883a 	mov	r5,r23
81121c7c:	112ccc40 	call	8112ccc4 <__sprint_r>
81121c80:	103c981e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121c84:	d8c02017 	ldw	r3,128(sp)
81121c88:	da000404 	addi	r8,sp,16
81121c8c:	003dc306 	br	8112139c <__reset+0xfb10139c>
81121c90:	d8802917 	ldw	r2,164(sp)
81121c94:	d8002785 	stb	zero,158(sp)
81121c98:	103f0616 	blt	r2,zero,811218b4 <__reset+0xfb1018b4>
81121c9c:	00ffdfc4 	movi	r3,-129
81121ca0:	9d84b03a 	or	r2,r19,r22
81121ca4:	90e4703a 	and	r18,r18,r3
81121ca8:	103c6b26 	beq	r2,zero,81120e58 <__reset+0xfb100e58>
81121cac:	0039883a 	mov	fp,zero
81121cb0:	003e7406 	br	81121684 <__reset+0xfb101684>
81121cb4:	9080040c 	andi	r2,r18,16
81121cb8:	1001b326 	beq	r2,zero,81122388 <___vfprintf_internal_r+0x18b4>
81121cbc:	d9002d17 	ldw	r4,180(sp)
81121cc0:	d9402917 	ldw	r5,164(sp)
81121cc4:	d8002785 	stb	zero,158(sp)
81121cc8:	20800104 	addi	r2,r4,4
81121ccc:	24c00017 	ldw	r19,0(r4)
81121cd0:	002d883a 	mov	r22,zero
81121cd4:	2801b516 	blt	r5,zero,811223ac <___vfprintf_internal_r+0x18d8>
81121cd8:	00ffdfc4 	movi	r3,-129
81121cdc:	d8802d15 	stw	r2,180(sp)
81121ce0:	90e4703a 	and	r18,r18,r3
81121ce4:	983d2726 	beq	r19,zero,81121184 <__reset+0xfb101184>
81121ce8:	0039883a 	mov	fp,zero
81121cec:	003d2a06 	br	81121198 <__reset+0xfb101198>
81121cf0:	dc402617 	ldw	r17,152(sp)
81121cf4:	0441d30e 	bge	zero,r17,81122444 <___vfprintf_internal_r+0x1970>
81121cf8:	dc403217 	ldw	r17,200(sp)
81121cfc:	d8803317 	ldw	r2,204(sp)
81121d00:	1440010e 	bge	r2,r17,81121d08 <___vfprintf_internal_r+0x1234>
81121d04:	1023883a 	mov	r17,r2
81121d08:	04400a0e 	bge	zero,r17,81121d34 <___vfprintf_internal_r+0x1260>
81121d0c:	d8801f17 	ldw	r2,124(sp)
81121d10:	1c47883a 	add	r3,r3,r17
81121d14:	44000015 	stw	r16,0(r8)
81121d18:	10800044 	addi	r2,r2,1
81121d1c:	44400115 	stw	r17,4(r8)
81121d20:	d8c02015 	stw	r3,128(sp)
81121d24:	d8801f15 	stw	r2,124(sp)
81121d28:	010001c4 	movi	r4,7
81121d2c:	20826516 	blt	r4,r2,811226c4 <___vfprintf_internal_r+0x1bf0>
81121d30:	42000204 	addi	r8,r8,8
81121d34:	88026116 	blt	r17,zero,811226bc <___vfprintf_internal_r+0x1be8>
81121d38:	d9003217 	ldw	r4,200(sp)
81121d3c:	2463c83a 	sub	r17,r4,r17
81121d40:	04407b0e 	bge	zero,r17,81121f30 <___vfprintf_internal_r+0x145c>
81121d44:	05800404 	movi	r22,16
81121d48:	d8801f17 	ldw	r2,124(sp)
81121d4c:	b4419d0e 	bge	r22,r17,811223c4 <___vfprintf_internal_r+0x18f0>
81121d50:	01204574 	movhi	r4,33045
81121d54:	2130c284 	addi	r4,r4,-15606
81121d58:	d9002b15 	stw	r4,172(sp)
81121d5c:	070001c4 	movi	fp,7
81121d60:	dcc02c17 	ldw	r19,176(sp)
81121d64:	00000306 	br	81121d74 <___vfprintf_internal_r+0x12a0>
81121d68:	42000204 	addi	r8,r8,8
81121d6c:	8c7ffc04 	addi	r17,r17,-16
81121d70:	b441970e 	bge	r22,r17,811223d0 <___vfprintf_internal_r+0x18fc>
81121d74:	18c00404 	addi	r3,r3,16
81121d78:	10800044 	addi	r2,r2,1
81121d7c:	45000015 	stw	r20,0(r8)
81121d80:	45800115 	stw	r22,4(r8)
81121d84:	d8c02015 	stw	r3,128(sp)
81121d88:	d8801f15 	stw	r2,124(sp)
81121d8c:	e0bff60e 	bge	fp,r2,81121d68 <__reset+0xfb101d68>
81121d90:	d9801e04 	addi	r6,sp,120
81121d94:	b80b883a 	mov	r5,r23
81121d98:	9809883a 	mov	r4,r19
81121d9c:	112ccc40 	call	8112ccc4 <__sprint_r>
81121da0:	103c501e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121da4:	d8c02017 	ldw	r3,128(sp)
81121da8:	d8801f17 	ldw	r2,124(sp)
81121dac:	da000404 	addi	r8,sp,16
81121db0:	003fee06 	br	81121d6c <__reset+0xfb101d6c>
81121db4:	d9002c17 	ldw	r4,176(sp)
81121db8:	d9801e04 	addi	r6,sp,120
81121dbc:	b80b883a 	mov	r5,r23
81121dc0:	112ccc40 	call	8112ccc4 <__sprint_r>
81121dc4:	103c471e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121dc8:	d8c02017 	ldw	r3,128(sp)
81121dcc:	df002787 	ldb	fp,158(sp)
81121dd0:	da000404 	addi	r8,sp,16
81121dd4:	003d5606 	br	81121330 <__reset+0xfb101330>
81121dd8:	9080040c 	andi	r2,r18,16
81121ddc:	10016126 	beq	r2,zero,81122364 <___vfprintf_internal_r+0x1890>
81121de0:	d8802d17 	ldw	r2,180(sp)
81121de4:	14c00017 	ldw	r19,0(r2)
81121de8:	10800104 	addi	r2,r2,4
81121dec:	d8802d15 	stw	r2,180(sp)
81121df0:	982dd7fa 	srai	r22,r19,31
81121df4:	b005883a 	mov	r2,r22
81121df8:	003c8206 	br	81121004 <__reset+0xfb101004>
81121dfc:	9080040c 	andi	r2,r18,16
81121e00:	10003526 	beq	r2,zero,81121ed8 <___vfprintf_internal_r+0x1404>
81121e04:	d9402d17 	ldw	r5,180(sp)
81121e08:	d8c02917 	ldw	r3,164(sp)
81121e0c:	d8002785 	stb	zero,158(sp)
81121e10:	28800104 	addi	r2,r5,4
81121e14:	2cc00017 	ldw	r19,0(r5)
81121e18:	002d883a 	mov	r22,zero
81121e1c:	18003716 	blt	r3,zero,81121efc <___vfprintf_internal_r+0x1428>
81121e20:	00ffdfc4 	movi	r3,-129
81121e24:	d8802d15 	stw	r2,180(sp)
81121e28:	90e4703a 	and	r18,r18,r3
81121e2c:	0039883a 	mov	fp,zero
81121e30:	983df326 	beq	r19,zero,81121600 <__reset+0xfb101600>
81121e34:	00800244 	movi	r2,9
81121e38:	14fc7b36 	bltu	r2,r19,81121028 <__reset+0xfb101028>
81121e3c:	d8c02817 	ldw	r3,160(sp)
81121e40:	dc001dc4 	addi	r16,sp,119
81121e44:	9cc00c04 	addi	r19,r19,48
81121e48:	1c07c83a 	sub	r3,r3,r16
81121e4c:	dcc01dc5 	stb	r19,119(sp)
81121e50:	d8c02e15 	stw	r3,184(sp)
81121e54:	003ce806 	br	811211f8 <__reset+0xfb1011f8>
81121e58:	d8803317 	ldw	r2,204(sp)
81121e5c:	143fffc4 	addi	r16,r2,-1
81121e60:	043f4d0e 	bge	zero,r16,81121b98 <__reset+0xfb101b98>
81121e64:	07000404 	movi	fp,16
81121e68:	e400810e 	bge	fp,r16,81122070 <___vfprintf_internal_r+0x159c>
81121e6c:	01604574 	movhi	r5,33045
81121e70:	2970c284 	addi	r5,r5,-15606
81121e74:	d9402b15 	stw	r5,172(sp)
81121e78:	01c001c4 	movi	r7,7
81121e7c:	dcc02c17 	ldw	r19,176(sp)
81121e80:	00000306 	br	81121e90 <___vfprintf_internal_r+0x13bc>
81121e84:	b5800204 	addi	r22,r22,8
81121e88:	843ffc04 	addi	r16,r16,-16
81121e8c:	e4007b0e 	bge	fp,r16,8112207c <___vfprintf_internal_r+0x15a8>
81121e90:	18c00404 	addi	r3,r3,16
81121e94:	8c400044 	addi	r17,r17,1
81121e98:	b5000015 	stw	r20,0(r22)
81121e9c:	b7000115 	stw	fp,4(r22)
81121ea0:	d8c02015 	stw	r3,128(sp)
81121ea4:	dc401f15 	stw	r17,124(sp)
81121ea8:	3c7ff60e 	bge	r7,r17,81121e84 <__reset+0xfb101e84>
81121eac:	d9801e04 	addi	r6,sp,120
81121eb0:	b80b883a 	mov	r5,r23
81121eb4:	9809883a 	mov	r4,r19
81121eb8:	d9c03c15 	stw	r7,240(sp)
81121ebc:	112ccc40 	call	8112ccc4 <__sprint_r>
81121ec0:	d9c03c17 	ldw	r7,240(sp)
81121ec4:	103c071e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121ec8:	d8c02017 	ldw	r3,128(sp)
81121ecc:	dc401f17 	ldw	r17,124(sp)
81121ed0:	dd800404 	addi	r22,sp,16
81121ed4:	003fec06 	br	81121e88 <__reset+0xfb101e88>
81121ed8:	9080100c 	andi	r2,r18,64
81121edc:	d8002785 	stb	zero,158(sp)
81121ee0:	10010e26 	beq	r2,zero,8112231c <___vfprintf_internal_r+0x1848>
81121ee4:	d9002d17 	ldw	r4,180(sp)
81121ee8:	d9402917 	ldw	r5,164(sp)
81121eec:	002d883a 	mov	r22,zero
81121ef0:	20800104 	addi	r2,r4,4
81121ef4:	24c0000b 	ldhu	r19,0(r4)
81121ef8:	283fc90e 	bge	r5,zero,81121e20 <__reset+0xfb101e20>
81121efc:	d8802d15 	stw	r2,180(sp)
81121f00:	0039883a 	mov	fp,zero
81121f04:	9d84b03a 	or	r2,r19,r22
81121f08:	103c461e 	bne	r2,zero,81121024 <__reset+0xfb101024>
81121f0c:	00800044 	movi	r2,1
81121f10:	003e6c06 	br	811218c4 <__reset+0xfb1018c4>
81121f14:	d9002c17 	ldw	r4,176(sp)
81121f18:	d9801e04 	addi	r6,sp,120
81121f1c:	b80b883a 	mov	r5,r23
81121f20:	112ccc40 	call	8112ccc4 <__sprint_r>
81121f24:	103bef1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81121f28:	d8c02017 	ldw	r3,128(sp)
81121f2c:	da000404 	addi	r8,sp,16
81121f30:	d9003217 	ldw	r4,200(sp)
81121f34:	d8802617 	ldw	r2,152(sp)
81121f38:	d9403317 	ldw	r5,204(sp)
81121f3c:	8123883a 	add	r17,r16,r4
81121f40:	11400216 	blt	r2,r5,81121f4c <___vfprintf_internal_r+0x1478>
81121f44:	9100004c 	andi	r4,r18,1
81121f48:	20000d26 	beq	r4,zero,81121f80 <___vfprintf_internal_r+0x14ac>
81121f4c:	d9003717 	ldw	r4,220(sp)
81121f50:	d9403417 	ldw	r5,208(sp)
81121f54:	1907883a 	add	r3,r3,r4
81121f58:	d9001f17 	ldw	r4,124(sp)
81121f5c:	41400015 	stw	r5,0(r8)
81121f60:	d9403717 	ldw	r5,220(sp)
81121f64:	21000044 	addi	r4,r4,1
81121f68:	d8c02015 	stw	r3,128(sp)
81121f6c:	41400115 	stw	r5,4(r8)
81121f70:	d9001f15 	stw	r4,124(sp)
81121f74:	014001c4 	movi	r5,7
81121f78:	2901e816 	blt	r5,r4,8112271c <___vfprintf_internal_r+0x1c48>
81121f7c:	42000204 	addi	r8,r8,8
81121f80:	d9003317 	ldw	r4,204(sp)
81121f84:	8121883a 	add	r16,r16,r4
81121f88:	2085c83a 	sub	r2,r4,r2
81121f8c:	8461c83a 	sub	r16,r16,r17
81121f90:	1400010e 	bge	r2,r16,81121f98 <___vfprintf_internal_r+0x14c4>
81121f94:	1021883a 	mov	r16,r2
81121f98:	04000a0e 	bge	zero,r16,81121fc4 <___vfprintf_internal_r+0x14f0>
81121f9c:	d9001f17 	ldw	r4,124(sp)
81121fa0:	1c07883a 	add	r3,r3,r16
81121fa4:	44400015 	stw	r17,0(r8)
81121fa8:	21000044 	addi	r4,r4,1
81121fac:	44000115 	stw	r16,4(r8)
81121fb0:	d8c02015 	stw	r3,128(sp)
81121fb4:	d9001f15 	stw	r4,124(sp)
81121fb8:	014001c4 	movi	r5,7
81121fbc:	2901fb16 	blt	r5,r4,811227ac <___vfprintf_internal_r+0x1cd8>
81121fc0:	42000204 	addi	r8,r8,8
81121fc4:	8001f716 	blt	r16,zero,811227a4 <___vfprintf_internal_r+0x1cd0>
81121fc8:	1421c83a 	sub	r16,r2,r16
81121fcc:	043d380e 	bge	zero,r16,811214b0 <__reset+0xfb1014b0>
81121fd0:	04400404 	movi	r17,16
81121fd4:	d8801f17 	ldw	r2,124(sp)
81121fd8:	8c3efb0e 	bge	r17,r16,81121bc8 <__reset+0xfb101bc8>
81121fdc:	01604574 	movhi	r5,33045
81121fe0:	2970c284 	addi	r5,r5,-15606
81121fe4:	d9402b15 	stw	r5,172(sp)
81121fe8:	058001c4 	movi	r22,7
81121fec:	dcc02c17 	ldw	r19,176(sp)
81121ff0:	00000306 	br	81122000 <___vfprintf_internal_r+0x152c>
81121ff4:	42000204 	addi	r8,r8,8
81121ff8:	843ffc04 	addi	r16,r16,-16
81121ffc:	8c3ef50e 	bge	r17,r16,81121bd4 <__reset+0xfb101bd4>
81122000:	18c00404 	addi	r3,r3,16
81122004:	10800044 	addi	r2,r2,1
81122008:	45000015 	stw	r20,0(r8)
8112200c:	44400115 	stw	r17,4(r8)
81122010:	d8c02015 	stw	r3,128(sp)
81122014:	d8801f15 	stw	r2,124(sp)
81122018:	b0bff60e 	bge	r22,r2,81121ff4 <__reset+0xfb101ff4>
8112201c:	d9801e04 	addi	r6,sp,120
81122020:	b80b883a 	mov	r5,r23
81122024:	9809883a 	mov	r4,r19
81122028:	112ccc40 	call	8112ccc4 <__sprint_r>
8112202c:	103bad1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122030:	d8c02017 	ldw	r3,128(sp)
81122034:	d8801f17 	ldw	r2,124(sp)
81122038:	da000404 	addi	r8,sp,16
8112203c:	003fee06 	br	81121ff8 <__reset+0xfb101ff8>
81122040:	9088703a 	and	r4,r18,r2
81122044:	203eab1e 	bne	r4,zero,81121af4 <__reset+0xfb101af4>
81122048:	dc401f17 	ldw	r17,124(sp)
8112204c:	40800115 	stw	r2,4(r8)
81122050:	44000015 	stw	r16,0(r8)
81122054:	8c400044 	addi	r17,r17,1
81122058:	d8c02015 	stw	r3,128(sp)
8112205c:	dc401f15 	stw	r17,124(sp)
81122060:	008001c4 	movi	r2,7
81122064:	14400e16 	blt	r2,r17,811220a0 <___vfprintf_internal_r+0x15cc>
81122068:	45800204 	addi	r22,r8,8
8112206c:	003eca06 	br	81121b98 <__reset+0xfb101b98>
81122070:	01204574 	movhi	r4,33045
81122074:	2130c284 	addi	r4,r4,-15606
81122078:	d9002b15 	stw	r4,172(sp)
8112207c:	d8802b17 	ldw	r2,172(sp)
81122080:	1c07883a 	add	r3,r3,r16
81122084:	8c400044 	addi	r17,r17,1
81122088:	b0800015 	stw	r2,0(r22)
8112208c:	b4000115 	stw	r16,4(r22)
81122090:	d8c02015 	stw	r3,128(sp)
81122094:	dc401f15 	stw	r17,124(sp)
81122098:	008001c4 	movi	r2,7
8112209c:	147ebd0e 	bge	r2,r17,81121b94 <__reset+0xfb101b94>
811220a0:	d9002c17 	ldw	r4,176(sp)
811220a4:	d9801e04 	addi	r6,sp,120
811220a8:	b80b883a 	mov	r5,r23
811220ac:	112ccc40 	call	8112ccc4 <__sprint_r>
811220b0:	103b8c1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811220b4:	d8c02017 	ldw	r3,128(sp)
811220b8:	dc401f17 	ldw	r17,124(sp)
811220bc:	dd800404 	addi	r22,sp,16
811220c0:	003eb506 	br	81121b98 <__reset+0xfb101b98>
811220c4:	d9002c17 	ldw	r4,176(sp)
811220c8:	d9801e04 	addi	r6,sp,120
811220cc:	b80b883a 	mov	r5,r23
811220d0:	112ccc40 	call	8112ccc4 <__sprint_r>
811220d4:	103b831e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811220d8:	d8c02017 	ldw	r3,128(sp)
811220dc:	dc401f17 	ldw	r17,124(sp)
811220e0:	da000404 	addi	r8,sp,16
811220e4:	003e8d06 	br	81121b1c <__reset+0xfb101b1c>
811220e8:	d9002c17 	ldw	r4,176(sp)
811220ec:	d9801e04 	addi	r6,sp,120
811220f0:	b80b883a 	mov	r5,r23
811220f4:	112ccc40 	call	8112ccc4 <__sprint_r>
811220f8:	103b7a1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811220fc:	d8c02017 	ldw	r3,128(sp)
81122100:	dc401f17 	ldw	r17,124(sp)
81122104:	dd800404 	addi	r22,sp,16
81122108:	003e8f06 	br	81121b48 <__reset+0xfb101b48>
8112210c:	0027883a 	mov	r19,zero
81122110:	003f4a06 	br	81121e3c <__reset+0xfb101e3c>
81122114:	d9002c17 	ldw	r4,176(sp)
81122118:	d9801e04 	addi	r6,sp,120
8112211c:	b80b883a 	mov	r5,r23
81122120:	112ccc40 	call	8112ccc4 <__sprint_r>
81122124:	103b6f1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122128:	d8c02017 	ldw	r3,128(sp)
8112212c:	da000404 	addi	r8,sp,16
81122130:	003c9d06 	br	811213a8 <__reset+0xfb1013a8>
81122134:	04e7c83a 	sub	r19,zero,r19
81122138:	9804c03a 	cmpne	r2,r19,zero
8112213c:	05adc83a 	sub	r22,zero,r22
81122140:	b0adc83a 	sub	r22,r22,r2
81122144:	d8802917 	ldw	r2,164(sp)
81122148:	07000b44 	movi	fp,45
8112214c:	df002785 	stb	fp,158(sp)
81122150:	10017b16 	blt	r2,zero,81122740 <___vfprintf_internal_r+0x1c6c>
81122154:	00bfdfc4 	movi	r2,-129
81122158:	90a4703a 	and	r18,r18,r2
8112215c:	003bb106 	br	81121024 <__reset+0xfb101024>
81122160:	d9003617 	ldw	r4,216(sp)
81122164:	d9403817 	ldw	r5,224(sp)
81122168:	da003d15 	stw	r8,244(sp)
8112216c:	11293280 	call	81129328 <__fpclassifyd>
81122170:	da003d17 	ldw	r8,244(sp)
81122174:	1000f026 	beq	r2,zero,81122538 <___vfprintf_internal_r+0x1a64>
81122178:	d9002917 	ldw	r4,164(sp)
8112217c:	05bff7c4 	movi	r22,-33
81122180:	00bfffc4 	movi	r2,-1
81122184:	8dac703a 	and	r22,r17,r22
81122188:	20820026 	beq	r4,r2,8112298c <___vfprintf_internal_r+0x1eb8>
8112218c:	008011c4 	movi	r2,71
81122190:	b081f726 	beq	r22,r2,81122970 <___vfprintf_internal_r+0x1e9c>
81122194:	d9003817 	ldw	r4,224(sp)
81122198:	90c04014 	ori	r3,r18,256
8112219c:	d8c02b15 	stw	r3,172(sp)
811221a0:	20021516 	blt	r4,zero,811229f8 <___vfprintf_internal_r+0x1f24>
811221a4:	dcc03817 	ldw	r19,224(sp)
811221a8:	d8002a05 	stb	zero,168(sp)
811221ac:	00801984 	movi	r2,102
811221b0:	8881f926 	beq	r17,r2,81122998 <___vfprintf_internal_r+0x1ec4>
811221b4:	00801184 	movi	r2,70
811221b8:	88821c26 	beq	r17,r2,81122a2c <___vfprintf_internal_r+0x1f58>
811221bc:	00801144 	movi	r2,69
811221c0:	b081ef26 	beq	r22,r2,81122980 <___vfprintf_internal_r+0x1eac>
811221c4:	d8c02917 	ldw	r3,164(sp)
811221c8:	d8802104 	addi	r2,sp,132
811221cc:	d8800315 	stw	r2,12(sp)
811221d0:	d9403617 	ldw	r5,216(sp)
811221d4:	d8802504 	addi	r2,sp,148
811221d8:	d9002c17 	ldw	r4,176(sp)
811221dc:	d8800215 	stw	r2,8(sp)
811221e0:	d8802604 	addi	r2,sp,152
811221e4:	d8c00015 	stw	r3,0(sp)
811221e8:	d8800115 	stw	r2,4(sp)
811221ec:	01c00084 	movi	r7,2
811221f0:	980d883a 	mov	r6,r19
811221f4:	d8c03c15 	stw	r3,240(sp)
811221f8:	da003d15 	stw	r8,244(sp)
811221fc:	1124be00 	call	81124be0 <_dtoa_r>
81122200:	1021883a 	mov	r16,r2
81122204:	008019c4 	movi	r2,103
81122208:	d8c03c17 	ldw	r3,240(sp)
8112220c:	da003d17 	ldw	r8,244(sp)
81122210:	88817126 	beq	r17,r2,811227d8 <___vfprintf_internal_r+0x1d04>
81122214:	008011c4 	movi	r2,71
81122218:	88829226 	beq	r17,r2,81122c64 <___vfprintf_internal_r+0x2190>
8112221c:	80f9883a 	add	fp,r16,r3
81122220:	d9003617 	ldw	r4,216(sp)
81122224:	000d883a 	mov	r6,zero
81122228:	000f883a 	mov	r7,zero
8112222c:	980b883a 	mov	r5,r19
81122230:	da003d15 	stw	r8,244(sp)
81122234:	113150c0 	call	8113150c <__eqdf2>
81122238:	da003d17 	ldw	r8,244(sp)
8112223c:	10018d26 	beq	r2,zero,81122874 <___vfprintf_internal_r+0x1da0>
81122240:	d8802117 	ldw	r2,132(sp)
81122244:	1700062e 	bgeu	r2,fp,81122260 <___vfprintf_internal_r+0x178c>
81122248:	01000c04 	movi	r4,48
8112224c:	10c00044 	addi	r3,r2,1
81122250:	d8c02115 	stw	r3,132(sp)
81122254:	11000005 	stb	r4,0(r2)
81122258:	d8802117 	ldw	r2,132(sp)
8112225c:	173ffb36 	bltu	r2,fp,8112224c <__reset+0xfb10224c>
81122260:	1405c83a 	sub	r2,r2,r16
81122264:	d8803315 	stw	r2,204(sp)
81122268:	008011c4 	movi	r2,71
8112226c:	b0817626 	beq	r22,r2,81122848 <___vfprintf_internal_r+0x1d74>
81122270:	00801944 	movi	r2,101
81122274:	1442810e 	bge	r2,r17,81122c7c <___vfprintf_internal_r+0x21a8>
81122278:	d8c02617 	ldw	r3,152(sp)
8112227c:	00801984 	movi	r2,102
81122280:	d8c03215 	stw	r3,200(sp)
81122284:	8881fe26 	beq	r17,r2,81122a80 <___vfprintf_internal_r+0x1fac>
81122288:	d8c03217 	ldw	r3,200(sp)
8112228c:	d9003317 	ldw	r4,204(sp)
81122290:	1901dd16 	blt	r3,r4,81122a08 <___vfprintf_internal_r+0x1f34>
81122294:	9480004c 	andi	r18,r18,1
81122298:	90022b1e 	bne	r18,zero,81122b48 <___vfprintf_internal_r+0x2074>
8112229c:	1805883a 	mov	r2,r3
811222a0:	18028016 	blt	r3,zero,81122ca4 <___vfprintf_internal_r+0x21d0>
811222a4:	d8c03217 	ldw	r3,200(sp)
811222a8:	044019c4 	movi	r17,103
811222ac:	d8c02e15 	stw	r3,184(sp)
811222b0:	df002a07 	ldb	fp,168(sp)
811222b4:	e001531e 	bne	fp,zero,81122804 <___vfprintf_internal_r+0x1d30>
811222b8:	df002783 	ldbu	fp,158(sp)
811222bc:	d8802a15 	stw	r2,168(sp)
811222c0:	dc802b17 	ldw	r18,172(sp)
811222c4:	d8002915 	stw	zero,164(sp)
811222c8:	003bd106 	br	81121210 <__reset+0xfb101210>
811222cc:	d8802d17 	ldw	r2,180(sp)
811222d0:	d8c02d17 	ldw	r3,180(sp)
811222d4:	d9002d17 	ldw	r4,180(sp)
811222d8:	10800017 	ldw	r2,0(r2)
811222dc:	18c00117 	ldw	r3,4(r3)
811222e0:	21000204 	addi	r4,r4,8
811222e4:	d8803615 	stw	r2,216(sp)
811222e8:	d8c03815 	stw	r3,224(sp)
811222ec:	d9002d15 	stw	r4,180(sp)
811222f0:	003b7506 	br	811210c8 <__reset+0xfb1010c8>
811222f4:	ac400007 	ldb	r17,0(r21)
811222f8:	003a5906 	br	81120c60 <__reset+0xfb100c60>
811222fc:	9080100c 	andi	r2,r18,64
81122300:	1000a826 	beq	r2,zero,811225a4 <___vfprintf_internal_r+0x1ad0>
81122304:	d9002d17 	ldw	r4,180(sp)
81122308:	002d883a 	mov	r22,zero
8112230c:	24c0000b 	ldhu	r19,0(r4)
81122310:	21000104 	addi	r4,r4,4
81122314:	d9002d15 	stw	r4,180(sp)
81122318:	003ccb06 	br	81121648 <__reset+0xfb101648>
8112231c:	d8c02d17 	ldw	r3,180(sp)
81122320:	d9002917 	ldw	r4,164(sp)
81122324:	002d883a 	mov	r22,zero
81122328:	18800104 	addi	r2,r3,4
8112232c:	1cc00017 	ldw	r19,0(r3)
81122330:	203ebb0e 	bge	r4,zero,81121e20 <__reset+0xfb101e20>
81122334:	003ef106 	br	81121efc <__reset+0xfb101efc>
81122338:	9080040c 	andi	r2,r18,16
8112233c:	1000921e 	bne	r2,zero,81122588 <___vfprintf_internal_r+0x1ab4>
81122340:	9480100c 	andi	r18,r18,64
81122344:	90013926 	beq	r18,zero,8112282c <___vfprintf_internal_r+0x1d58>
81122348:	d9002d17 	ldw	r4,180(sp)
8112234c:	d9402f17 	ldw	r5,188(sp)
81122350:	20800017 	ldw	r2,0(r4)
81122354:	21000104 	addi	r4,r4,4
81122358:	d9002d15 	stw	r4,180(sp)
8112235c:	1140000d 	sth	r5,0(r2)
81122360:	003a1606 	br	81120bbc <__reset+0xfb100bbc>
81122364:	9080100c 	andi	r2,r18,64
81122368:	10008026 	beq	r2,zero,8112256c <___vfprintf_internal_r+0x1a98>
8112236c:	d8c02d17 	ldw	r3,180(sp)
81122370:	1cc0000f 	ldh	r19,0(r3)
81122374:	18c00104 	addi	r3,r3,4
81122378:	d8c02d15 	stw	r3,180(sp)
8112237c:	982dd7fa 	srai	r22,r19,31
81122380:	b005883a 	mov	r2,r22
81122384:	003b1f06 	br	81121004 <__reset+0xfb101004>
81122388:	9080100c 	andi	r2,r18,64
8112238c:	d8002785 	stb	zero,158(sp)
81122390:	10008a1e 	bne	r2,zero,811225bc <___vfprintf_internal_r+0x1ae8>
81122394:	d9402d17 	ldw	r5,180(sp)
81122398:	d8c02917 	ldw	r3,164(sp)
8112239c:	002d883a 	mov	r22,zero
811223a0:	28800104 	addi	r2,r5,4
811223a4:	2cc00017 	ldw	r19,0(r5)
811223a8:	183e4b0e 	bge	r3,zero,81121cd8 <__reset+0xfb101cd8>
811223ac:	9d86b03a 	or	r3,r19,r22
811223b0:	d8802d15 	stw	r2,180(sp)
811223b4:	183e4c1e 	bne	r3,zero,81121ce8 <__reset+0xfb101ce8>
811223b8:	0039883a 	mov	fp,zero
811223bc:	0005883a 	mov	r2,zero
811223c0:	003d4006 	br	811218c4 <__reset+0xfb1018c4>
811223c4:	01604574 	movhi	r5,33045
811223c8:	2970c284 	addi	r5,r5,-15606
811223cc:	d9402b15 	stw	r5,172(sp)
811223d0:	d9402b17 	ldw	r5,172(sp)
811223d4:	1c47883a 	add	r3,r3,r17
811223d8:	10800044 	addi	r2,r2,1
811223dc:	41400015 	stw	r5,0(r8)
811223e0:	44400115 	stw	r17,4(r8)
811223e4:	d8c02015 	stw	r3,128(sp)
811223e8:	d8801f15 	stw	r2,124(sp)
811223ec:	010001c4 	movi	r4,7
811223f0:	20bec816 	blt	r4,r2,81121f14 <__reset+0xfb101f14>
811223f4:	42000204 	addi	r8,r8,8
811223f8:	003ecd06 	br	81121f30 <__reset+0xfb101f30>
811223fc:	d9002917 	ldw	r4,164(sp)
81122400:	d8002785 	stb	zero,158(sp)
81122404:	203d2d16 	blt	r4,zero,811218bc <__reset+0xfb1018bc>
81122408:	00bfdfc4 	movi	r2,-129
8112240c:	90a4703a 	and	r18,r18,r2
81122410:	003a9106 	br	81120e58 <__reset+0xfb100e58>
81122414:	01204574 	movhi	r4,33045
81122418:	2130c284 	addi	r4,r4,-15606
8112241c:	d9002b15 	stw	r4,172(sp)
81122420:	003c0c06 	br	81121454 <__reset+0xfb101454>
81122424:	d9002c17 	ldw	r4,176(sp)
81122428:	d9801e04 	addi	r6,sp,120
8112242c:	b80b883a 	mov	r5,r23
81122430:	112ccc40 	call	8112ccc4 <__sprint_r>
81122434:	103aab1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122438:	d8c02017 	ldw	r3,128(sp)
8112243c:	da000404 	addi	r8,sp,16
81122440:	003d4106 	br	81121948 <__reset+0xfb101948>
81122444:	d8801f17 	ldw	r2,124(sp)
81122448:	01604574 	movhi	r5,33045
8112244c:	01000044 	movi	r4,1
81122450:	18c00044 	addi	r3,r3,1
81122454:	10800044 	addi	r2,r2,1
81122458:	2970ba04 	addi	r5,r5,-15640
8112245c:	41000115 	stw	r4,4(r8)
81122460:	41400015 	stw	r5,0(r8)
81122464:	d8c02015 	stw	r3,128(sp)
81122468:	d8801f15 	stw	r2,124(sp)
8112246c:	010001c4 	movi	r4,7
81122470:	20805c16 	blt	r4,r2,811225e4 <___vfprintf_internal_r+0x1b10>
81122474:	42000204 	addi	r8,r8,8
81122478:	8800041e 	bne	r17,zero,8112248c <___vfprintf_internal_r+0x19b8>
8112247c:	d8803317 	ldw	r2,204(sp)
81122480:	1000021e 	bne	r2,zero,8112248c <___vfprintf_internal_r+0x19b8>
81122484:	9080004c 	andi	r2,r18,1
81122488:	103c0926 	beq	r2,zero,811214b0 <__reset+0xfb1014b0>
8112248c:	d9003717 	ldw	r4,220(sp)
81122490:	d8801f17 	ldw	r2,124(sp)
81122494:	d9403417 	ldw	r5,208(sp)
81122498:	20c7883a 	add	r3,r4,r3
8112249c:	10800044 	addi	r2,r2,1
811224a0:	41000115 	stw	r4,4(r8)
811224a4:	41400015 	stw	r5,0(r8)
811224a8:	d8c02015 	stw	r3,128(sp)
811224ac:	d8801f15 	stw	r2,124(sp)
811224b0:	010001c4 	movi	r4,7
811224b4:	20812116 	blt	r4,r2,8112293c <___vfprintf_internal_r+0x1e68>
811224b8:	42000204 	addi	r8,r8,8
811224bc:	0463c83a 	sub	r17,zero,r17
811224c0:	0440730e 	bge	zero,r17,81122690 <___vfprintf_internal_r+0x1bbc>
811224c4:	05800404 	movi	r22,16
811224c8:	b440860e 	bge	r22,r17,811226e4 <___vfprintf_internal_r+0x1c10>
811224cc:	01604574 	movhi	r5,33045
811224d0:	2970c284 	addi	r5,r5,-15606
811224d4:	d9402b15 	stw	r5,172(sp)
811224d8:	070001c4 	movi	fp,7
811224dc:	dcc02c17 	ldw	r19,176(sp)
811224e0:	00000306 	br	811224f0 <___vfprintf_internal_r+0x1a1c>
811224e4:	42000204 	addi	r8,r8,8
811224e8:	8c7ffc04 	addi	r17,r17,-16
811224ec:	b440800e 	bge	r22,r17,811226f0 <___vfprintf_internal_r+0x1c1c>
811224f0:	18c00404 	addi	r3,r3,16
811224f4:	10800044 	addi	r2,r2,1
811224f8:	45000015 	stw	r20,0(r8)
811224fc:	45800115 	stw	r22,4(r8)
81122500:	d8c02015 	stw	r3,128(sp)
81122504:	d8801f15 	stw	r2,124(sp)
81122508:	e0bff60e 	bge	fp,r2,811224e4 <__reset+0xfb1024e4>
8112250c:	d9801e04 	addi	r6,sp,120
81122510:	b80b883a 	mov	r5,r23
81122514:	9809883a 	mov	r4,r19
81122518:	112ccc40 	call	8112ccc4 <__sprint_r>
8112251c:	103a711e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122520:	d8c02017 	ldw	r3,128(sp)
81122524:	d8801f17 	ldw	r2,124(sp)
81122528:	da000404 	addi	r8,sp,16
8112252c:	003fee06 	br	811224e8 <__reset+0xfb1024e8>
81122530:	00bfffc4 	movi	r2,-1
81122534:	003a6f06 	br	81120ef4 <__reset+0xfb100ef4>
81122538:	008011c4 	movi	r2,71
8112253c:	1440b816 	blt	r2,r17,81122820 <___vfprintf_internal_r+0x1d4c>
81122540:	04204574 	movhi	r16,33045
81122544:	8430ac04 	addi	r16,r16,-15696
81122548:	00c000c4 	movi	r3,3
8112254c:	00bfdfc4 	movi	r2,-129
81122550:	d8c02a15 	stw	r3,168(sp)
81122554:	90a4703a 	and	r18,r18,r2
81122558:	df002783 	ldbu	fp,158(sp)
8112255c:	d8c02e15 	stw	r3,184(sp)
81122560:	d8002915 	stw	zero,164(sp)
81122564:	d8003215 	stw	zero,200(sp)
81122568:	003b2906 	br	81121210 <__reset+0xfb101210>
8112256c:	d9002d17 	ldw	r4,180(sp)
81122570:	24c00017 	ldw	r19,0(r4)
81122574:	21000104 	addi	r4,r4,4
81122578:	d9002d15 	stw	r4,180(sp)
8112257c:	982dd7fa 	srai	r22,r19,31
81122580:	b005883a 	mov	r2,r22
81122584:	003a9f06 	br	81121004 <__reset+0xfb101004>
81122588:	d9402d17 	ldw	r5,180(sp)
8112258c:	d8c02f17 	ldw	r3,188(sp)
81122590:	28800017 	ldw	r2,0(r5)
81122594:	29400104 	addi	r5,r5,4
81122598:	d9402d15 	stw	r5,180(sp)
8112259c:	10c00015 	stw	r3,0(r2)
811225a0:	00398606 	br	81120bbc <__reset+0xfb100bbc>
811225a4:	d9402d17 	ldw	r5,180(sp)
811225a8:	002d883a 	mov	r22,zero
811225ac:	2cc00017 	ldw	r19,0(r5)
811225b0:	29400104 	addi	r5,r5,4
811225b4:	d9402d15 	stw	r5,180(sp)
811225b8:	003c2306 	br	81121648 <__reset+0xfb101648>
811225bc:	d8c02d17 	ldw	r3,180(sp)
811225c0:	d9002917 	ldw	r4,164(sp)
811225c4:	002d883a 	mov	r22,zero
811225c8:	18800104 	addi	r2,r3,4
811225cc:	1cc0000b 	ldhu	r19,0(r3)
811225d0:	203dc10e 	bge	r4,zero,81121cd8 <__reset+0xfb101cd8>
811225d4:	003f7506 	br	811223ac <__reset+0xfb1023ac>
811225d8:	04204574 	movhi	r16,33045
811225dc:	8430aa04 	addi	r16,r16,-15704
811225e0:	003acc06 	br	81121114 <__reset+0xfb101114>
811225e4:	d9002c17 	ldw	r4,176(sp)
811225e8:	d9801e04 	addi	r6,sp,120
811225ec:	b80b883a 	mov	r5,r23
811225f0:	112ccc40 	call	8112ccc4 <__sprint_r>
811225f4:	103a3b1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811225f8:	dc402617 	ldw	r17,152(sp)
811225fc:	d8c02017 	ldw	r3,128(sp)
81122600:	da000404 	addi	r8,sp,16
81122604:	003f9c06 	br	81122478 <__reset+0xfb102478>
81122608:	ac400043 	ldbu	r17,1(r21)
8112260c:	94800814 	ori	r18,r18,32
81122610:	ad400044 	addi	r21,r21,1
81122614:	8c403fcc 	andi	r17,r17,255
81122618:	8c40201c 	xori	r17,r17,128
8112261c:	8c7fe004 	addi	r17,r17,-128
81122620:	00398f06 	br	81120c60 <__reset+0xfb100c60>
81122624:	d8c02d15 	stw	r3,180(sp)
81122628:	0039883a 	mov	fp,zero
8112262c:	003e3506 	br	81121f04 <__reset+0xfb101f04>
81122630:	d9002c17 	ldw	r4,176(sp)
81122634:	d9801e04 	addi	r6,sp,120
81122638:	b80b883a 	mov	r5,r23
8112263c:	112ccc40 	call	8112ccc4 <__sprint_r>
81122640:	103a281e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122644:	d8c02017 	ldw	r3,128(sp)
81122648:	da000404 	addi	r8,sp,16
8112264c:	003cd006 	br	81121990 <__reset+0xfb101990>
81122650:	8009883a 	mov	r4,r16
81122654:	da003d15 	stw	r8,244(sp)
81122658:	111e5bc0 	call	8111e5bc <strlen>
8112265c:	d8802e15 	stw	r2,184(sp)
81122660:	da003d17 	ldw	r8,244(sp)
81122664:	103c340e 	bge	r2,zero,81121738 <__reset+0xfb101738>
81122668:	0005883a 	mov	r2,zero
8112266c:	003c3206 	br	81121738 <__reset+0xfb101738>
81122670:	d9002c17 	ldw	r4,176(sp)
81122674:	d9801e04 	addi	r6,sp,120
81122678:	b80b883a 	mov	r5,r23
8112267c:	112ccc40 	call	8112ccc4 <__sprint_r>
81122680:	103a181e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122684:	d8c02017 	ldw	r3,128(sp)
81122688:	d8801f17 	ldw	r2,124(sp)
8112268c:	da000404 	addi	r8,sp,16
81122690:	d9403317 	ldw	r5,204(sp)
81122694:	10800044 	addi	r2,r2,1
81122698:	44000015 	stw	r16,0(r8)
8112269c:	28c7883a 	add	r3,r5,r3
811226a0:	003b7d06 	br	81121498 <__reset+0xfb101498>
811226a4:	01204574 	movhi	r4,33045
811226a8:	2130c684 	addi	r4,r4,-15590
811226ac:	d9003515 	stw	r4,212(sp)
811226b0:	003b1406 	br	81121304 <__reset+0xfb101304>
811226b4:	013fffc4 	movi	r4,-1
811226b8:	003a3506 	br	81120f90 <__reset+0xfb100f90>
811226bc:	0023883a 	mov	r17,zero
811226c0:	003d9d06 	br	81121d38 <__reset+0xfb101d38>
811226c4:	d9002c17 	ldw	r4,176(sp)
811226c8:	d9801e04 	addi	r6,sp,120
811226cc:	b80b883a 	mov	r5,r23
811226d0:	112ccc40 	call	8112ccc4 <__sprint_r>
811226d4:	103a031e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811226d8:	d8c02017 	ldw	r3,128(sp)
811226dc:	da000404 	addi	r8,sp,16
811226e0:	003d9406 	br	81121d34 <__reset+0xfb101d34>
811226e4:	01204574 	movhi	r4,33045
811226e8:	2130c284 	addi	r4,r4,-15606
811226ec:	d9002b15 	stw	r4,172(sp)
811226f0:	d9002b17 	ldw	r4,172(sp)
811226f4:	1c47883a 	add	r3,r3,r17
811226f8:	10800044 	addi	r2,r2,1
811226fc:	41000015 	stw	r4,0(r8)
81122700:	44400115 	stw	r17,4(r8)
81122704:	d8c02015 	stw	r3,128(sp)
81122708:	d8801f15 	stw	r2,124(sp)
8112270c:	010001c4 	movi	r4,7
81122710:	20bfd716 	blt	r4,r2,81122670 <__reset+0xfb102670>
81122714:	42000204 	addi	r8,r8,8
81122718:	003fdd06 	br	81122690 <__reset+0xfb102690>
8112271c:	d9002c17 	ldw	r4,176(sp)
81122720:	d9801e04 	addi	r6,sp,120
81122724:	b80b883a 	mov	r5,r23
81122728:	112ccc40 	call	8112ccc4 <__sprint_r>
8112272c:	1039ed1e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122730:	d8802617 	ldw	r2,152(sp)
81122734:	d8c02017 	ldw	r3,128(sp)
81122738:	da000404 	addi	r8,sp,16
8112273c:	003e1006 	br	81121f80 <__reset+0xfb101f80>
81122740:	00800044 	movi	r2,1
81122744:	10803fcc 	andi	r2,r2,255
81122748:	00c00044 	movi	r3,1
8112274c:	10fa3526 	beq	r2,r3,81121024 <__reset+0xfb101024>
81122750:	00c00084 	movi	r3,2
81122754:	10fbcb26 	beq	r2,r3,81121684 <__reset+0xfb101684>
81122758:	003a8f06 	br	81121198 <__reset+0xfb101198>
8112275c:	01204574 	movhi	r4,33045
81122760:	2130c684 	addi	r4,r4,-15590
81122764:	d9003515 	stw	r4,212(sp)
81122768:	003b7606 	br	81121544 <__reset+0xfb101544>
8112276c:	d8802917 	ldw	r2,164(sp)
81122770:	00c00184 	movi	r3,6
81122774:	1880012e 	bgeu	r3,r2,8112277c <___vfprintf_internal_r+0x1ca8>
81122778:	1805883a 	mov	r2,r3
8112277c:	d8802e15 	stw	r2,184(sp)
81122780:	1000ef16 	blt	r2,zero,81122b40 <___vfprintf_internal_r+0x206c>
81122784:	04204574 	movhi	r16,33045
81122788:	d8802a15 	stw	r2,168(sp)
8112278c:	dcc02d15 	stw	r19,180(sp)
81122790:	d8002915 	stw	zero,164(sp)
81122794:	d8003215 	stw	zero,200(sp)
81122798:	8430b804 	addi	r16,r16,-15648
8112279c:	0039883a 	mov	fp,zero
811227a0:	003aa206 	br	8112122c <__reset+0xfb10122c>
811227a4:	0021883a 	mov	r16,zero
811227a8:	003e0706 	br	81121fc8 <__reset+0xfb101fc8>
811227ac:	d9002c17 	ldw	r4,176(sp)
811227b0:	d9801e04 	addi	r6,sp,120
811227b4:	b80b883a 	mov	r5,r23
811227b8:	112ccc40 	call	8112ccc4 <__sprint_r>
811227bc:	1039c91e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
811227c0:	d8802617 	ldw	r2,152(sp)
811227c4:	d9403317 	ldw	r5,204(sp)
811227c8:	d8c02017 	ldw	r3,128(sp)
811227cc:	da000404 	addi	r8,sp,16
811227d0:	2885c83a 	sub	r2,r5,r2
811227d4:	003dfb06 	br	81121fc4 <__reset+0xfb101fc4>
811227d8:	9080004c 	andi	r2,r18,1
811227dc:	103e8f1e 	bne	r2,zero,8112221c <__reset+0xfb10221c>
811227e0:	d8802117 	ldw	r2,132(sp)
811227e4:	003e9e06 	br	81122260 <__reset+0xfb102260>
811227e8:	1025883a 	mov	r18,r2
811227ec:	0039883a 	mov	fp,zero
811227f0:	00800084 	movi	r2,2
811227f4:	003fd306 	br	81122744 <__reset+0xfb102744>
811227f8:	07000b44 	movi	fp,45
811227fc:	df002785 	stb	fp,158(sp)
81122800:	003a4006 	br	81121104 <__reset+0xfb101104>
81122804:	00c00b44 	movi	r3,45
81122808:	d8c02785 	stb	r3,158(sp)
8112280c:	d8802a15 	stw	r2,168(sp)
81122810:	dc802b17 	ldw	r18,172(sp)
81122814:	d8002915 	stw	zero,164(sp)
81122818:	07000b44 	movi	fp,45
8112281c:	003a8006 	br	81121220 <__reset+0xfb101220>
81122820:	04204574 	movhi	r16,33045
81122824:	8430ad04 	addi	r16,r16,-15692
81122828:	003f4706 	br	81122548 <__reset+0xfb102548>
8112282c:	d8c02d17 	ldw	r3,180(sp)
81122830:	d9002f17 	ldw	r4,188(sp)
81122834:	18800017 	ldw	r2,0(r3)
81122838:	18c00104 	addi	r3,r3,4
8112283c:	d8c02d15 	stw	r3,180(sp)
81122840:	11000015 	stw	r4,0(r2)
81122844:	0038dd06 	br	81120bbc <__reset+0xfb100bbc>
81122848:	dd802617 	ldw	r22,152(sp)
8112284c:	00bfff44 	movi	r2,-3
81122850:	b0801c16 	blt	r22,r2,811228c4 <___vfprintf_internal_r+0x1df0>
81122854:	d9402917 	ldw	r5,164(sp)
81122858:	2d801a16 	blt	r5,r22,811228c4 <___vfprintf_internal_r+0x1df0>
8112285c:	dd803215 	stw	r22,200(sp)
81122860:	003e8906 	br	81122288 <__reset+0xfb102288>
81122864:	01204574 	movhi	r4,33045
81122868:	2130c284 	addi	r4,r4,-15606
8112286c:	d9002b15 	stw	r4,172(sp)
81122870:	003c9106 	br	81121ab8 <__reset+0xfb101ab8>
81122874:	e005883a 	mov	r2,fp
81122878:	003e7906 	br	81122260 <__reset+0xfb102260>
8112287c:	d9402917 	ldw	r5,164(sp)
81122880:	df002783 	ldbu	fp,158(sp)
81122884:	dcc02d15 	stw	r19,180(sp)
81122888:	d9402a15 	stw	r5,168(sp)
8112288c:	d9402e15 	stw	r5,184(sp)
81122890:	d8002915 	stw	zero,164(sp)
81122894:	d8003215 	stw	zero,200(sp)
81122898:	003a5d06 	br	81121210 <__reset+0xfb101210>
8112289c:	9080004c 	andi	r2,r18,1
811228a0:	0039883a 	mov	fp,zero
811228a4:	10000426 	beq	r2,zero,811228b8 <___vfprintf_internal_r+0x1de4>
811228a8:	00800c04 	movi	r2,48
811228ac:	dc001dc4 	addi	r16,sp,119
811228b0:	d8801dc5 	stb	r2,119(sp)
811228b4:	003b8006 	br	811216b8 <__reset+0xfb1016b8>
811228b8:	d8002e15 	stw	zero,184(sp)
811228bc:	dc001e04 	addi	r16,sp,120
811228c0:	003a4d06 	br	811211f8 <__reset+0xfb1011f8>
811228c4:	8c7fff84 	addi	r17,r17,-2
811228c8:	b5bfffc4 	addi	r22,r22,-1
811228cc:	dd802615 	stw	r22,152(sp)
811228d0:	dc4022c5 	stb	r17,139(sp)
811228d4:	b000bf16 	blt	r22,zero,81122bd4 <___vfprintf_internal_r+0x2100>
811228d8:	00800ac4 	movi	r2,43
811228dc:	d8802305 	stb	r2,140(sp)
811228e0:	00800244 	movi	r2,9
811228e4:	15807016 	blt	r2,r22,81122aa8 <___vfprintf_internal_r+0x1fd4>
811228e8:	00800c04 	movi	r2,48
811228ec:	b5800c04 	addi	r22,r22,48
811228f0:	d8802345 	stb	r2,141(sp)
811228f4:	dd802385 	stb	r22,142(sp)
811228f8:	d88023c4 	addi	r2,sp,143
811228fc:	df0022c4 	addi	fp,sp,139
81122900:	d8c03317 	ldw	r3,204(sp)
81122904:	1739c83a 	sub	fp,r2,fp
81122908:	d9003317 	ldw	r4,204(sp)
8112290c:	e0c7883a 	add	r3,fp,r3
81122910:	df003a15 	stw	fp,232(sp)
81122914:	d8c02e15 	stw	r3,184(sp)
81122918:	00800044 	movi	r2,1
8112291c:	1100b30e 	bge	r2,r4,81122bec <___vfprintf_internal_r+0x2118>
81122920:	d8c02e17 	ldw	r3,184(sp)
81122924:	18c00044 	addi	r3,r3,1
81122928:	d8c02e15 	stw	r3,184(sp)
8112292c:	1805883a 	mov	r2,r3
81122930:	1800ac16 	blt	r3,zero,81122be4 <___vfprintf_internal_r+0x2110>
81122934:	d8003215 	stw	zero,200(sp)
81122938:	003e5d06 	br	811222b0 <__reset+0xfb1022b0>
8112293c:	d9002c17 	ldw	r4,176(sp)
81122940:	d9801e04 	addi	r6,sp,120
81122944:	b80b883a 	mov	r5,r23
81122948:	112ccc40 	call	8112ccc4 <__sprint_r>
8112294c:	1039651e 	bne	r2,zero,81120ee4 <__reset+0xfb100ee4>
81122950:	dc402617 	ldw	r17,152(sp)
81122954:	d8c02017 	ldw	r3,128(sp)
81122958:	d8801f17 	ldw	r2,124(sp)
8112295c:	da000404 	addi	r8,sp,16
81122960:	003ed606 	br	811224bc <__reset+0xfb1024bc>
81122964:	582b883a 	mov	r21,r11
81122968:	d8002915 	stw	zero,164(sp)
8112296c:	0038bd06 	br	81120c64 <__reset+0xfb100c64>
81122970:	d8802917 	ldw	r2,164(sp)
81122974:	103e071e 	bne	r2,zero,81122194 <__reset+0xfb102194>
81122978:	dc002915 	stw	r16,164(sp)
8112297c:	003e0506 	br	81122194 <__reset+0xfb102194>
81122980:	d9002917 	ldw	r4,164(sp)
81122984:	20c00044 	addi	r3,r4,1
81122988:	003e0f06 	br	811221c8 <__reset+0xfb1021c8>
8112298c:	01400184 	movi	r5,6
81122990:	d9402915 	stw	r5,164(sp)
81122994:	003dff06 	br	81122194 <__reset+0xfb102194>
81122998:	d8802104 	addi	r2,sp,132
8112299c:	d8800315 	stw	r2,12(sp)
811229a0:	d8802504 	addi	r2,sp,148
811229a4:	d8800215 	stw	r2,8(sp)
811229a8:	d8802604 	addi	r2,sp,152
811229ac:	d8800115 	stw	r2,4(sp)
811229b0:	d8802917 	ldw	r2,164(sp)
811229b4:	d9403617 	ldw	r5,216(sp)
811229b8:	d9002c17 	ldw	r4,176(sp)
811229bc:	d8800015 	stw	r2,0(sp)
811229c0:	01c000c4 	movi	r7,3
811229c4:	980d883a 	mov	r6,r19
811229c8:	da003d15 	stw	r8,244(sp)
811229cc:	1124be00 	call	81124be0 <_dtoa_r>
811229d0:	d8c02917 	ldw	r3,164(sp)
811229d4:	da003d17 	ldw	r8,244(sp)
811229d8:	1021883a 	mov	r16,r2
811229dc:	10f9883a 	add	fp,r2,r3
811229e0:	81000007 	ldb	r4,0(r16)
811229e4:	00800c04 	movi	r2,48
811229e8:	20805e26 	beq	r4,r2,81122b64 <___vfprintf_internal_r+0x2090>
811229ec:	d8c02617 	ldw	r3,152(sp)
811229f0:	e0f9883a 	add	fp,fp,r3
811229f4:	003e0a06 	br	81122220 <__reset+0xfb102220>
811229f8:	00c00b44 	movi	r3,45
811229fc:	24e0003c 	xorhi	r19,r4,32768
81122a00:	d8c02a05 	stb	r3,168(sp)
81122a04:	003de906 	br	811221ac <__reset+0xfb1021ac>
81122a08:	d8c03217 	ldw	r3,200(sp)
81122a0c:	00c07a0e 	bge	zero,r3,81122bf8 <___vfprintf_internal_r+0x2124>
81122a10:	00800044 	movi	r2,1
81122a14:	d9003317 	ldw	r4,204(sp)
81122a18:	1105883a 	add	r2,r2,r4
81122a1c:	d8802e15 	stw	r2,184(sp)
81122a20:	10004e16 	blt	r2,zero,81122b5c <___vfprintf_internal_r+0x2088>
81122a24:	044019c4 	movi	r17,103
81122a28:	003e2106 	br	811222b0 <__reset+0xfb1022b0>
81122a2c:	d9002917 	ldw	r4,164(sp)
81122a30:	d8802104 	addi	r2,sp,132
81122a34:	d8800315 	stw	r2,12(sp)
81122a38:	d9000015 	stw	r4,0(sp)
81122a3c:	d8802504 	addi	r2,sp,148
81122a40:	d9403617 	ldw	r5,216(sp)
81122a44:	d9002c17 	ldw	r4,176(sp)
81122a48:	d8800215 	stw	r2,8(sp)
81122a4c:	d8802604 	addi	r2,sp,152
81122a50:	d8800115 	stw	r2,4(sp)
81122a54:	01c000c4 	movi	r7,3
81122a58:	980d883a 	mov	r6,r19
81122a5c:	da003d15 	stw	r8,244(sp)
81122a60:	1124be00 	call	81124be0 <_dtoa_r>
81122a64:	d8c02917 	ldw	r3,164(sp)
81122a68:	da003d17 	ldw	r8,244(sp)
81122a6c:	1021883a 	mov	r16,r2
81122a70:	00801184 	movi	r2,70
81122a74:	80f9883a 	add	fp,r16,r3
81122a78:	88bfd926 	beq	r17,r2,811229e0 <__reset+0xfb1029e0>
81122a7c:	003de806 	br	81122220 <__reset+0xfb102220>
81122a80:	d9002917 	ldw	r4,164(sp)
81122a84:	00c04d0e 	bge	zero,r3,81122bbc <___vfprintf_internal_r+0x20e8>
81122a88:	2000441e 	bne	r4,zero,81122b9c <___vfprintf_internal_r+0x20c8>
81122a8c:	9480004c 	andi	r18,r18,1
81122a90:	9000421e 	bne	r18,zero,81122b9c <___vfprintf_internal_r+0x20c8>
81122a94:	1805883a 	mov	r2,r3
81122a98:	18007016 	blt	r3,zero,81122c5c <___vfprintf_internal_r+0x2188>
81122a9c:	d8c03217 	ldw	r3,200(sp)
81122aa0:	d8c02e15 	stw	r3,184(sp)
81122aa4:	003e0206 	br	811222b0 <__reset+0xfb1022b0>
81122aa8:	df0022c4 	addi	fp,sp,139
81122aac:	dc002915 	stw	r16,164(sp)
81122ab0:	4027883a 	mov	r19,r8
81122ab4:	e021883a 	mov	r16,fp
81122ab8:	b009883a 	mov	r4,r22
81122abc:	01400284 	movi	r5,10
81122ac0:	113003c0 	call	8113003c <__modsi3>
81122ac4:	10800c04 	addi	r2,r2,48
81122ac8:	843fffc4 	addi	r16,r16,-1
81122acc:	b009883a 	mov	r4,r22
81122ad0:	01400284 	movi	r5,10
81122ad4:	80800005 	stb	r2,0(r16)
81122ad8:	112ffb80 	call	8112ffb8 <__divsi3>
81122adc:	102d883a 	mov	r22,r2
81122ae0:	00800244 	movi	r2,9
81122ae4:	15bff416 	blt	r2,r22,81122ab8 <__reset+0xfb102ab8>
81122ae8:	9811883a 	mov	r8,r19
81122aec:	b0800c04 	addi	r2,r22,48
81122af0:	8027883a 	mov	r19,r16
81122af4:	997fffc4 	addi	r5,r19,-1
81122af8:	98bfffc5 	stb	r2,-1(r19)
81122afc:	dc002917 	ldw	r16,164(sp)
81122b00:	2f006a2e 	bgeu	r5,fp,81122cac <___vfprintf_internal_r+0x21d8>
81122b04:	d9c02384 	addi	r7,sp,142
81122b08:	3ccfc83a 	sub	r7,r7,r19
81122b0c:	d9002344 	addi	r4,sp,141
81122b10:	e1cf883a 	add	r7,fp,r7
81122b14:	00000106 	br	81122b1c <___vfprintf_internal_r+0x2048>
81122b18:	28800003 	ldbu	r2,0(r5)
81122b1c:	20800005 	stb	r2,0(r4)
81122b20:	21000044 	addi	r4,r4,1
81122b24:	29400044 	addi	r5,r5,1
81122b28:	393ffb1e 	bne	r7,r4,81122b18 <__reset+0xfb102b18>
81122b2c:	d8802304 	addi	r2,sp,140
81122b30:	14c5c83a 	sub	r2,r2,r19
81122b34:	d8c02344 	addi	r3,sp,141
81122b38:	1885883a 	add	r2,r3,r2
81122b3c:	003f7006 	br	81122900 <__reset+0xfb102900>
81122b40:	0005883a 	mov	r2,zero
81122b44:	003f0f06 	br	81122784 <__reset+0xfb102784>
81122b48:	d8c03217 	ldw	r3,200(sp)
81122b4c:	18c00044 	addi	r3,r3,1
81122b50:	d8c02e15 	stw	r3,184(sp)
81122b54:	1805883a 	mov	r2,r3
81122b58:	183fb20e 	bge	r3,zero,81122a24 <__reset+0xfb102a24>
81122b5c:	0005883a 	mov	r2,zero
81122b60:	003fb006 	br	81122a24 <__reset+0xfb102a24>
81122b64:	d9003617 	ldw	r4,216(sp)
81122b68:	000d883a 	mov	r6,zero
81122b6c:	000f883a 	mov	r7,zero
81122b70:	980b883a 	mov	r5,r19
81122b74:	d8c03c15 	stw	r3,240(sp)
81122b78:	da003d15 	stw	r8,244(sp)
81122b7c:	113150c0 	call	8113150c <__eqdf2>
81122b80:	d8c03c17 	ldw	r3,240(sp)
81122b84:	da003d17 	ldw	r8,244(sp)
81122b88:	103f9826 	beq	r2,zero,811229ec <__reset+0xfb1029ec>
81122b8c:	00800044 	movi	r2,1
81122b90:	10c7c83a 	sub	r3,r2,r3
81122b94:	d8c02615 	stw	r3,152(sp)
81122b98:	003f9506 	br	811229f0 <__reset+0xfb1029f0>
81122b9c:	d9002917 	ldw	r4,164(sp)
81122ba0:	d8c03217 	ldw	r3,200(sp)
81122ba4:	20800044 	addi	r2,r4,1
81122ba8:	1885883a 	add	r2,r3,r2
81122bac:	d8802e15 	stw	r2,184(sp)
81122bb0:	103dbf0e 	bge	r2,zero,811222b0 <__reset+0xfb1022b0>
81122bb4:	0005883a 	mov	r2,zero
81122bb8:	003dbd06 	br	811222b0 <__reset+0xfb1022b0>
81122bbc:	2000211e 	bne	r4,zero,81122c44 <___vfprintf_internal_r+0x2170>
81122bc0:	9480004c 	andi	r18,r18,1
81122bc4:	90001f1e 	bne	r18,zero,81122c44 <___vfprintf_internal_r+0x2170>
81122bc8:	00800044 	movi	r2,1
81122bcc:	d8802e15 	stw	r2,184(sp)
81122bd0:	003db706 	br	811222b0 <__reset+0xfb1022b0>
81122bd4:	00800b44 	movi	r2,45
81122bd8:	05adc83a 	sub	r22,zero,r22
81122bdc:	d8802305 	stb	r2,140(sp)
81122be0:	003f3f06 	br	811228e0 <__reset+0xfb1028e0>
81122be4:	0005883a 	mov	r2,zero
81122be8:	003f5206 	br	81122934 <__reset+0xfb102934>
81122bec:	90a4703a 	and	r18,r18,r2
81122bf0:	903f4e26 	beq	r18,zero,8112292c <__reset+0xfb10292c>
81122bf4:	003f4a06 	br	81122920 <__reset+0xfb102920>
81122bf8:	00800084 	movi	r2,2
81122bfc:	10c5c83a 	sub	r2,r2,r3
81122c00:	003f8406 	br	81122a14 <__reset+0xfb102a14>
81122c04:	d8802d17 	ldw	r2,180(sp)
81122c08:	d9002d17 	ldw	r4,180(sp)
81122c0c:	ac400043 	ldbu	r17,1(r21)
81122c10:	10800017 	ldw	r2,0(r2)
81122c14:	582b883a 	mov	r21,r11
81122c18:	d8802915 	stw	r2,164(sp)
81122c1c:	20800104 	addi	r2,r4,4
81122c20:	d9002917 	ldw	r4,164(sp)
81122c24:	d8802d15 	stw	r2,180(sp)
81122c28:	203e7a0e 	bge	r4,zero,81122614 <__reset+0xfb102614>
81122c2c:	8c403fcc 	andi	r17,r17,255
81122c30:	00bfffc4 	movi	r2,-1
81122c34:	8c40201c 	xori	r17,r17,128
81122c38:	d8802915 	stw	r2,164(sp)
81122c3c:	8c7fe004 	addi	r17,r17,-128
81122c40:	00380706 	br	81120c60 <__reset+0xfb100c60>
81122c44:	d8c02917 	ldw	r3,164(sp)
81122c48:	18c00084 	addi	r3,r3,2
81122c4c:	d8c02e15 	stw	r3,184(sp)
81122c50:	1805883a 	mov	r2,r3
81122c54:	183d960e 	bge	r3,zero,811222b0 <__reset+0xfb1022b0>
81122c58:	003fd606 	br	81122bb4 <__reset+0xfb102bb4>
81122c5c:	0005883a 	mov	r2,zero
81122c60:	003f8e06 	br	81122a9c <__reset+0xfb102a9c>
81122c64:	9080004c 	andi	r2,r18,1
81122c68:	103f811e 	bne	r2,zero,81122a70 <__reset+0xfb102a70>
81122c6c:	d8802117 	ldw	r2,132(sp)
81122c70:	1405c83a 	sub	r2,r2,r16
81122c74:	d8803315 	stw	r2,204(sp)
81122c78:	b47ef326 	beq	r22,r17,81122848 <__reset+0xfb102848>
81122c7c:	dd802617 	ldw	r22,152(sp)
81122c80:	003f1106 	br	811228c8 <__reset+0xfb1028c8>
81122c84:	d9c02785 	stb	r7,158(sp)
81122c88:	00390406 	br	8112109c <__reset+0xfb10109c>
81122c8c:	d9c02785 	stb	r7,158(sp)
81122c90:	0038d306 	br	81120fe0 <__reset+0xfb100fe0>
81122c94:	d9c02785 	stb	r7,158(sp)
81122c98:	003a6106 	br	81121620 <__reset+0xfb101620>
81122c9c:	d9c02785 	stb	r7,158(sp)
81122ca0:	003af806 	br	81121884 <__reset+0xfb101884>
81122ca4:	0005883a 	mov	r2,zero
81122ca8:	003d7e06 	br	811222a4 <__reset+0xfb1022a4>
81122cac:	d8802344 	addi	r2,sp,141
81122cb0:	003f1306 	br	81122900 <__reset+0xfb102900>
81122cb4:	d9c02785 	stb	r7,158(sp)
81122cb8:	00392306 	br	81121148 <__reset+0xfb101148>
81122cbc:	d9c02785 	stb	r7,158(sp)
81122cc0:	003aa906 	br	81121768 <__reset+0xfb101768>
81122cc4:	d9c02785 	stb	r7,158(sp)
81122cc8:	003a3d06 	br	811215c0 <__reset+0xfb1015c0>
81122ccc:	d9c02785 	stb	r7,158(sp)
81122cd0:	003aca06 	br	811217fc <__reset+0xfb1017fc>

81122cd4 <__vfprintf_internal>:
81122cd4:	00a04574 	movhi	r2,33045
81122cd8:	10ba8204 	addi	r2,r2,-5624
81122cdc:	300f883a 	mov	r7,r6
81122ce0:	280d883a 	mov	r6,r5
81122ce4:	200b883a 	mov	r5,r4
81122ce8:	11000017 	ldw	r4,0(r2)
81122cec:	1120ad41 	jmpi	81120ad4 <___vfprintf_internal_r>

81122cf0 <__sbprintf>:
81122cf0:	defee204 	addi	sp,sp,-1144
81122cf4:	de00012e 	bgeu	sp,et,81122cfc <__sbprintf+0xc>
81122cf8:	003b68fa 	trap	3
81122cfc:	2880030b 	ldhu	r2,12(r5)
81122d00:	2ac01917 	ldw	r11,100(r5)
81122d04:	2a80038b 	ldhu	r10,14(r5)
81122d08:	2a400717 	ldw	r9,28(r5)
81122d0c:	2a000917 	ldw	r8,36(r5)
81122d10:	00c10004 	movi	r3,1024
81122d14:	dc011a15 	stw	r16,1128(sp)
81122d18:	10bfff4c 	andi	r2,r2,65533
81122d1c:	2821883a 	mov	r16,r5
81122d20:	d8cb883a 	add	r5,sp,r3
81122d24:	dc811c15 	stw	r18,1136(sp)
81122d28:	dc411b15 	stw	r17,1132(sp)
81122d2c:	dfc11d15 	stw	ra,1140(sp)
81122d30:	2025883a 	mov	r18,r4
81122d34:	d881030d 	sth	r2,1036(sp)
81122d38:	dac11915 	stw	r11,1124(sp)
81122d3c:	da81038d 	sth	r10,1038(sp)
81122d40:	da410715 	stw	r9,1052(sp)
81122d44:	da010915 	stw	r8,1060(sp)
81122d48:	dec10015 	stw	sp,1024(sp)
81122d4c:	dec10415 	stw	sp,1040(sp)
81122d50:	d8c10215 	stw	r3,1032(sp)
81122d54:	d8c10515 	stw	r3,1044(sp)
81122d58:	d8010615 	stw	zero,1048(sp)
81122d5c:	1120ad40 	call	81120ad4 <___vfprintf_internal_r>
81122d60:	1023883a 	mov	r17,r2
81122d64:	10000416 	blt	r2,zero,81122d78 <__sbprintf+0x88>
81122d68:	d9410004 	addi	r5,sp,1024
81122d6c:	9009883a 	mov	r4,r18
81122d70:	11264940 	call	81126494 <_fflush_r>
81122d74:	10000d1e 	bne	r2,zero,81122dac <__sbprintf+0xbc>
81122d78:	d881030b 	ldhu	r2,1036(sp)
81122d7c:	1080100c 	andi	r2,r2,64
81122d80:	10000326 	beq	r2,zero,81122d90 <__sbprintf+0xa0>
81122d84:	8080030b 	ldhu	r2,12(r16)
81122d88:	10801014 	ori	r2,r2,64
81122d8c:	8080030d 	sth	r2,12(r16)
81122d90:	8805883a 	mov	r2,r17
81122d94:	dfc11d17 	ldw	ra,1140(sp)
81122d98:	dc811c17 	ldw	r18,1136(sp)
81122d9c:	dc411b17 	ldw	r17,1132(sp)
81122da0:	dc011a17 	ldw	r16,1128(sp)
81122da4:	dec11e04 	addi	sp,sp,1144
81122da8:	f800283a 	ret
81122dac:	047fffc4 	movi	r17,-1
81122db0:	003ff106 	br	81122d78 <__reset+0xfb102d78>

81122db4 <__svfscanf_r>:
81122db4:	deff4b04 	addi	sp,sp,-724
81122db8:	de00012e 	bgeu	sp,et,81122dc0 <__svfscanf_r+0xc>
81122dbc:	003b68fa 	trap	3
81122dc0:	2880030b 	ldhu	r2,12(r5)
81122dc4:	df00b315 	stw	fp,716(sp)
81122dc8:	dd80b115 	stw	r22,708(sp)
81122dcc:	dfc0b415 	stw	ra,720(sp)
81122dd0:	ddc0b215 	stw	r23,712(sp)
81122dd4:	dd40b015 	stw	r21,704(sp)
81122dd8:	dd00af15 	stw	r20,700(sp)
81122ddc:	dcc0ae15 	stw	r19,696(sp)
81122de0:	dc80ad15 	stw	r18,692(sp)
81122de4:	dc40ac15 	stw	r17,688(sp)
81122de8:	dc00ab15 	stw	r16,684(sp)
81122dec:	10c8000c 	andi	r3,r2,8192
81122df0:	d9c09c15 	stw	r7,624(sp)
81122df4:	2839883a 	mov	fp,r5
81122df8:	202d883a 	mov	r22,r4
81122dfc:	1800061e 	bne	r3,zero,81122e18 <__svfscanf_r+0x64>
81122e00:	29001917 	ldw	r4,100(r5)
81122e04:	00f7ffc4 	movi	r3,-8193
81122e08:	10880014 	ori	r2,r2,8192
81122e0c:	20c6703a 	and	r3,r4,r3
81122e10:	2880030d 	sth	r2,12(r5)
81122e14:	28c01915 	stw	r3,100(r5)
81122e18:	30800003 	ldbu	r2,0(r6)
81122e1c:	0021883a 	mov	r16,zero
81122e20:	05e04574 	movhi	r23,33045
81122e24:	d800a115 	stw	zero,644(sp)
81122e28:	d8009e15 	stw	zero,632(sp)
81122e2c:	d800a015 	stw	zero,640(sp)
81122e30:	d8809b15 	stw	r2,620(sp)
81122e34:	bdfa8004 	addi	r23,r23,-5632
81122e38:	8025883a 	mov	r18,r16
81122e3c:	35000044 	addi	r20,r6,1
81122e40:	10001e26 	beq	r2,zero,81122ebc <__svfscanf_r+0x108>
81122e44:	b9c00017 	ldw	r7,0(r23)
81122e48:	3887883a 	add	r3,r7,r2
81122e4c:	18c00043 	ldbu	r3,1(r3)
81122e50:	18c0020c 	andi	r3,r3,8
81122e54:	18001b26 	beq	r3,zero,81122ec4 <__svfscanf_r+0x110>
81122e58:	e0800117 	ldw	r2,4(fp)
81122e5c:	00800e0e 	bge	zero,r2,81122e98 <__svfscanf_r+0xe4>
81122e60:	e0c00017 	ldw	r3,0(fp)
81122e64:	b9000017 	ldw	r4,0(r23)
81122e68:	18800003 	ldbu	r2,0(r3)
81122e6c:	2085883a 	add	r2,r4,r2
81122e70:	10800043 	ldbu	r2,1(r2)
81122e74:	1080020c 	andi	r2,r2,8
81122e78:	10000b26 	beq	r2,zero,81122ea8 <__svfscanf_r+0xf4>
81122e7c:	e0800117 	ldw	r2,4(fp)
81122e80:	18c00044 	addi	r3,r3,1
81122e84:	e0c00015 	stw	r3,0(fp)
81122e88:	10bfffc4 	addi	r2,r2,-1
81122e8c:	e0800115 	stw	r2,4(fp)
81122e90:	94800044 	addi	r18,r18,1
81122e94:	00bff216 	blt	zero,r2,81122e60 <__reset+0xfb102e60>
81122e98:	e00b883a 	mov	r5,fp
81122e9c:	b009883a 	mov	r4,r22
81122ea0:	111e0940 	call	8111e094 <__srefill_r>
81122ea4:	103fee26 	beq	r2,zero,81122e60 <__reset+0xfb102e60>
81122ea8:	a00d883a 	mov	r6,r20
81122eac:	30800003 	ldbu	r2,0(r6)
81122eb0:	35000044 	addi	r20,r6,1
81122eb4:	d8809b15 	stw	r2,620(sp)
81122eb8:	103fe21e 	bne	r2,zero,81122e44 <__reset+0xfb102e44>
81122ebc:	d880a017 	ldw	r2,640(sp)
81122ec0:	00009906 	br	81123128 <__svfscanf_r+0x374>
81122ec4:	00c00944 	movi	r3,37
81122ec8:	10c0881e 	bne	r2,r3,811230ec <__svfscanf_r+0x338>
81122ecc:	30c00043 	ldbu	r3,1(r6)
81122ed0:	0023883a 	mov	r17,zero
81122ed4:	0027883a 	mov	r19,zero
81122ed8:	01001e04 	movi	r4,120
81122edc:	01401b04 	movi	r5,108
81122ee0:	a1800044 	addi	r6,r20,1
81122ee4:	20c0a236 	bltu	r4,r3,81123170 <__svfscanf_r+0x3bc>
81122ee8:	180490ba 	slli	r2,r3,2
81122eec:	022044b4 	movhi	r8,33042
81122ef0:	420bc004 	addi	r8,r8,12032
81122ef4:	1205883a 	add	r2,r2,r8
81122ef8:	10800017 	ldw	r2,0(r2)
81122efc:	1000683a 	jmp	r2
81122f00:	81123124 	muli	r4,r16,18628
81122f04:	81123170 	cmpltui	r4,r16,18629
81122f08:	81123170 	cmpltui	r4,r16,18629
81122f0c:	81123170 	cmpltui	r4,r16,18629
81122f10:	81123170 	cmpltui	r4,r16,18629
81122f14:	81123170 	cmpltui	r4,r16,18629
81122f18:	81123170 	cmpltui	r4,r16,18629
81122f1c:	81123170 	cmpltui	r4,r16,18629
81122f20:	81123170 	cmpltui	r4,r16,18629
81122f24:	81123170 	cmpltui	r4,r16,18629
81122f28:	81123170 	cmpltui	r4,r16,18629
81122f2c:	81123170 	cmpltui	r4,r16,18629
81122f30:	81123170 	cmpltui	r4,r16,18629
81122f34:	81123170 	cmpltui	r4,r16,18629
81122f38:	81123170 	cmpltui	r4,r16,18629
81122f3c:	81123170 	cmpltui	r4,r16,18629
81122f40:	81123170 	cmpltui	r4,r16,18629
81122f44:	81123170 	cmpltui	r4,r16,18629
81122f48:	81123170 	cmpltui	r4,r16,18629
81122f4c:	81123170 	cmpltui	r4,r16,18629
81122f50:	81123170 	cmpltui	r4,r16,18629
81122f54:	81123170 	cmpltui	r4,r16,18629
81122f58:	81123170 	cmpltui	r4,r16,18629
81122f5c:	81123170 	cmpltui	r4,r16,18629
81122f60:	81123170 	cmpltui	r4,r16,18629
81122f64:	81123170 	cmpltui	r4,r16,18629
81122f68:	81123170 	cmpltui	r4,r16,18629
81122f6c:	81123170 	cmpltui	r4,r16,18629
81122f70:	81123170 	cmpltui	r4,r16,18629
81122f74:	81123170 	cmpltui	r4,r16,18629
81122f78:	81123170 	cmpltui	r4,r16,18629
81122f7c:	81123170 	cmpltui	r4,r16,18629
81122f80:	81123170 	cmpltui	r4,r16,18629
81122f84:	81123170 	cmpltui	r4,r16,18629
81122f88:	81123170 	cmpltui	r4,r16,18629
81122f8c:	81123170 	cmpltui	r4,r16,18629
81122f90:	81123170 	cmpltui	r4,r16,18629
81122f94:	811230e4 	muli	r4,r16,18627
81122f98:	81123170 	cmpltui	r4,r16,18629
81122f9c:	81123170 	cmpltui	r4,r16,18629
81122fa0:	81123170 	cmpltui	r4,r16,18629
81122fa4:	81123170 	cmpltui	r4,r16,18629
81122fa8:	81123158 	cmpnei	r4,r16,18629
81122fac:	81123170 	cmpltui	r4,r16,18629
81122fb0:	81123170 	cmpltui	r4,r16,18629
81122fb4:	81123170 	cmpltui	r4,r16,18629
81122fb8:	81123170 	cmpltui	r4,r16,18629
81122fbc:	81123170 	cmpltui	r4,r16,18629
81122fc0:	8112328c 	andi	r4,r16,18634
81122fc4:	8112328c 	andi	r4,r16,18634
81122fc8:	8112328c 	andi	r4,r16,18634
81122fcc:	8112328c 	andi	r4,r16,18634
81122fd0:	8112328c 	andi	r4,r16,18634
81122fd4:	8112328c 	andi	r4,r16,18634
81122fd8:	8112328c 	andi	r4,r16,18634
81122fdc:	8112328c 	andi	r4,r16,18634
81122fe0:	8112328c 	andi	r4,r16,18634
81122fe4:	8112328c 	andi	r4,r16,18634
81122fe8:	81123170 	cmpltui	r4,r16,18629
81122fec:	81123170 	cmpltui	r4,r16,18629
81122ff0:	81123170 	cmpltui	r4,r16,18629
81122ff4:	81123170 	cmpltui	r4,r16,18629
81122ff8:	81123170 	cmpltui	r4,r16,18629
81122ffc:	81123170 	cmpltui	r4,r16,18629
81123000:	81123170 	cmpltui	r4,r16,18629
81123004:	81123170 	cmpltui	r4,r16,18629
81123008:	81123170 	cmpltui	r4,r16,18629
8112300c:	81123170 	cmpltui	r4,r16,18629
81123010:	81123260 	cmpeqi	r4,r16,18633
81123014:	81123310 	cmplti	r4,r16,18636
81123018:	81123170 	cmpltui	r4,r16,18629
8112301c:	81123310 	cmplti	r4,r16,18636
81123020:	81123170 	cmpltui	r4,r16,18629
81123024:	81123170 	cmpltui	r4,r16,18629
81123028:	81123170 	cmpltui	r4,r16,18629
8112302c:	81123170 	cmpltui	r4,r16,18629
81123030:	811232fc 	xorhi	r4,r16,18635
81123034:	81123170 	cmpltui	r4,r16,18629
81123038:	81123170 	cmpltui	r4,r16,18629
8112303c:	811232d0 	cmplti	r4,r16,18635
81123040:	81123170 	cmpltui	r4,r16,18629
81123044:	81123170 	cmpltui	r4,r16,18629
81123048:	81123170 	cmpltui	r4,r16,18629
8112304c:	81123170 	cmpltui	r4,r16,18629
81123050:	81123170 	cmpltui	r4,r16,18629
81123054:	81123170 	cmpltui	r4,r16,18629
81123058:	81123170 	cmpltui	r4,r16,18629
8112305c:	81123170 	cmpltui	r4,r16,18629
81123060:	811232a8 	cmpgeui	r4,r16,18634
81123064:	81123170 	cmpltui	r4,r16,18629
81123068:	81123170 	cmpltui	r4,r16,18629
8112306c:	81123444 	addi	r4,r16,18641
81123070:	81123170 	cmpltui	r4,r16,18629
81123074:	81123170 	cmpltui	r4,r16,18629
81123078:	81123170 	cmpltui	r4,r16,18629
8112307c:	81123170 	cmpltui	r4,r16,18629
81123080:	81123170 	cmpltui	r4,r16,18629
81123084:	81123170 	cmpltui	r4,r16,18629
81123088:	81123170 	cmpltui	r4,r16,18629
8112308c:	811233c8 	cmpgei	r4,r16,18639
81123090:	811233a0 	cmpeqi	r4,r16,18638
81123094:	81123310 	cmplti	r4,r16,18636
81123098:	81123310 	cmplti	r4,r16,18636
8112309c:	81123310 	cmplti	r4,r16,18636
811230a0:	8112338c 	andi	r4,r16,18638
811230a4:	811234d0 	cmplti	r4,r16,18643
811230a8:	81123170 	cmpltui	r4,r16,18629
811230ac:	81123170 	cmpltui	r4,r16,18629
811230b0:	81123378 	rdprs	r4,r16,18637
811230b4:	81123170 	cmpltui	r4,r16,18629
811230b8:	81123348 	cmpgei	r4,r16,18637
811230bc:	81123324 	muli	r4,r16,18636
811230c0:	81123234 	orhi	r4,r16,18632
811230c4:	81123170 	cmpltui	r4,r16,18629
811230c8:	81123170 	cmpltui	r4,r16,18629
811230cc:	81123220 	cmpeqi	r4,r16,18632
811230d0:	81123170 	cmpltui	r4,r16,18629
811230d4:	811231a8 	cmpgeui	r4,r16,18630
811230d8:	81123170 	cmpltui	r4,r16,18629
811230dc:	81123170 	cmpltui	r4,r16,18629
811230e0:	811232a8 	cmpgeui	r4,r16,18634
811230e4:	d9809d15 	stw	r6,628(sp)
811230e8:	3029883a 	mov	r20,r6
811230ec:	e0800117 	ldw	r2,4(fp)
811230f0:	0081aa0e 	bge	zero,r2,8112379c <__svfscanf_r+0x9e8>
811230f4:	e0800017 	ldw	r2,0(fp)
811230f8:	a0ffffc3 	ldbu	r3,-1(r20)
811230fc:	11000003 	ldbu	r4,0(r2)
81123100:	20ff6e1e 	bne	r4,r3,81122ebc <__reset+0xfb102ebc>
81123104:	e0c00117 	ldw	r3,4(fp)
81123108:	10800044 	addi	r2,r2,1
8112310c:	e0800015 	stw	r2,0(fp)
81123110:	18bfffc4 	addi	r2,r3,-1
81123114:	e0800115 	stw	r2,4(fp)
81123118:	94800044 	addi	r18,r18,1
8112311c:	a00d883a 	mov	r6,r20
81123120:	003f6206 	br	81122eac <__reset+0xfb102eac>
81123124:	00bfffc4 	movi	r2,-1
81123128:	dfc0b417 	ldw	ra,720(sp)
8112312c:	df00b317 	ldw	fp,716(sp)
81123130:	ddc0b217 	ldw	r23,712(sp)
81123134:	dd80b117 	ldw	r22,708(sp)
81123138:	dd40b017 	ldw	r21,704(sp)
8112313c:	dd00af17 	ldw	r20,700(sp)
81123140:	dcc0ae17 	ldw	r19,696(sp)
81123144:	dc80ad17 	ldw	r18,692(sp)
81123148:	dc40ac17 	ldw	r17,688(sp)
8112314c:	dc00ab17 	ldw	r16,684(sp)
81123150:	dec0b504 	addi	sp,sp,724
81123154:	f800283a 	ret
81123158:	a0800043 	ldbu	r2,1(r20)
8112315c:	3029883a 	mov	r20,r6
81123160:	8c400414 	ori	r17,r17,16
81123164:	10c03fcc 	andi	r3,r2,255
81123168:	a1800044 	addi	r6,r20,1
8112316c:	20ff5e2e 	bgeu	r4,r3,81122ee8 <__reset+0xfb102ee8>
81123170:	38c7883a 	add	r3,r7,r3
81123174:	18800043 	ldbu	r2,1(r3)
81123178:	d9809d15 	stw	r6,628(sp)
8112317c:	00c00044 	movi	r3,1
81123180:	108000cc 	andi	r2,r2,3
81123184:	10c18f26 	beq	r2,r3,811237c4 <__svfscanf_r+0xa10>
81123188:	e0800117 	ldw	r2,4(fp)
8112318c:	00808716 	blt	zero,r2,811233ac <__svfscanf_r+0x5f8>
81123190:	e00b883a 	mov	r5,fp
81123194:	b009883a 	mov	r4,r22
81123198:	111e0940 	call	8111e094 <__srefill_r>
8112319c:	1001431e 	bne	r2,zero,811236ac <__svfscanf_r+0x8f8>
811231a0:	b9c00017 	ldw	r7,0(r23)
811231a4:	00008106 	br	811233ac <__svfscanf_r+0x5f8>
811231a8:	e0800117 	ldw	r2,4(fp)
811231ac:	d9809d15 	stw	r6,628(sp)
811231b0:	0081a30e 	bge	zero,r2,81123840 <__svfscanf_r+0xa8c>
811231b4:	00a044f4 	movhi	r2,33043
811231b8:	10abf104 	addi	r2,r2,-20540
811231bc:	02000284 	movi	r8,10
811231c0:	d880a115 	stw	r2,644(sp)
811231c4:	da009e15 	stw	r8,632(sp)
811231c8:	050000c4 	movi	r20,3
811231cc:	e0c00017 	ldw	r3,0(fp)
811231d0:	00000206 	br	811231dc <__svfscanf_r+0x428>
811231d4:	18c00044 	addi	r3,r3,1
811231d8:	e0c00015 	stw	r3,0(fp)
811231dc:	19000003 	ldbu	r4,0(r3)
811231e0:	20803fcc 	andi	r2,r4,255
811231e4:	3885883a 	add	r2,r7,r2
811231e8:	10800043 	ldbu	r2,1(r2)
811231ec:	1140020c 	andi	r5,r2,8
811231f0:	2801ab26 	beq	r5,zero,811238a0 <__svfscanf_r+0xaec>
811231f4:	e0800117 	ldw	r2,4(fp)
811231f8:	94800044 	addi	r18,r18,1
811231fc:	10bfffc4 	addi	r2,r2,-1
81123200:	e0800115 	stw	r2,4(fp)
81123204:	00bff316 	blt	zero,r2,811231d4 <__reset+0xfb1031d4>
81123208:	e00b883a 	mov	r5,fp
8112320c:	b009883a 	mov	r4,r22
81123210:	111e0940 	call	8111e094 <__srefill_r>
81123214:	1001251e 	bne	r2,zero,811236ac <__svfscanf_r+0x8f8>
81123218:	b9c00017 	ldw	r7,0(r23)
8112321c:	003feb06 	br	811231cc <__reset+0xfb1031cc>
81123220:	e0800117 	ldw	r2,4(fp)
81123224:	d9809d15 	stw	r6,628(sp)
81123228:	00818b0e 	bge	zero,r2,81123858 <__svfscanf_r+0xaa4>
8112322c:	05000084 	movi	r20,2
81123230:	003fe606 	br	811231cc <__reset+0xfb1031cc>
81123234:	e0800117 	ldw	r2,4(fp)
81123238:	d9809d15 	stw	r6,628(sp)
8112323c:	8c408814 	ori	r17,r17,544
81123240:	00801d0e 	bge	zero,r2,811232b8 <__svfscanf_r+0x504>
81123244:	00a044f4 	movhi	r2,33043
81123248:	10abf104 	addi	r2,r2,-20540
8112324c:	02000404 	movi	r8,16
81123250:	d880a115 	stw	r2,644(sp)
81123254:	da009e15 	stw	r8,632(sp)
81123258:	050000c4 	movi	r20,3
8112325c:	003fdb06 	br	811231cc <__reset+0xfb1031cc>
81123260:	e0800117 	ldw	r2,4(fp)
81123264:	d9809d15 	stw	r6,628(sp)
81123268:	8c400054 	ori	r17,r17,1
8112326c:	00bfc80e 	bge	zero,r2,81123190 <__reset+0xfb103190>
81123270:	00e044b4 	movhi	r3,33042
81123274:	18f9a604 	addi	r3,r3,-6504
81123278:	02000284 	movi	r8,10
8112327c:	d8c0a115 	stw	r3,644(sp)
81123280:	da009e15 	stw	r8,632(sp)
81123284:	050000c4 	movi	r20,3
81123288:	003fd006 	br	811231cc <__reset+0xfb1031cc>
8112328c:	9cc002a4 	muli	r19,r19,10
81123290:	a0800043 	ldbu	r2,1(r20)
81123294:	3029883a 	mov	r20,r6
81123298:	98e7883a 	add	r19,r19,r3
8112329c:	9cfff404 	addi	r19,r19,-48
811232a0:	10c03fcc 	andi	r3,r2,255
811232a4:	003f0e06 	br	81122ee0 <__reset+0xfb102ee0>
811232a8:	e0800117 	ldw	r2,4(fp)
811232ac:	d9809d15 	stw	r6,628(sp)
811232b0:	8c408014 	ori	r17,r17,512
811232b4:	00bfe316 	blt	zero,r2,81123244 <__reset+0xfb103244>
811232b8:	e00b883a 	mov	r5,fp
811232bc:	b009883a 	mov	r4,r22
811232c0:	111e0940 	call	8111e094 <__srefill_r>
811232c4:	1000f91e 	bne	r2,zero,811236ac <__svfscanf_r+0x8f8>
811232c8:	b9c00017 	ldw	r7,0(r23)
811232cc:	003fdd06 	br	81123244 <__reset+0xfb103244>
811232d0:	e0800117 	ldw	r2,4(fp)
811232d4:	d9809d15 	stw	r6,628(sp)
811232d8:	8c400054 	ori	r17,r17,1
811232dc:	0080140e 	bge	zero,r2,81123330 <__svfscanf_r+0x57c>
811232e0:	00a044f4 	movhi	r2,33043
811232e4:	10abf104 	addi	r2,r2,-20540
811232e8:	02000204 	movi	r8,8
811232ec:	d880a115 	stw	r2,644(sp)
811232f0:	da009e15 	stw	r8,632(sp)
811232f4:	050000c4 	movi	r20,3
811232f8:	003fb406 	br	811231cc <__reset+0xfb1031cc>
811232fc:	a0800043 	ldbu	r2,1(r20)
81123300:	8c400094 	ori	r17,r17,2
81123304:	3029883a 	mov	r20,r6
81123308:	10c03fcc 	andi	r3,r2,255
8112330c:	003ef406 	br	81122ee0 <__reset+0xfb102ee0>
81123310:	e0800117 	ldw	r2,4(fp)
81123314:	d9809d15 	stw	r6,628(sp)
81123318:	0081420e 	bge	zero,r2,81123824 <__svfscanf_r+0xa70>
8112331c:	05000104 	movi	r20,4
81123320:	003faa06 	br	811231cc <__reset+0xfb1031cc>
81123324:	e0800117 	ldw	r2,4(fp)
81123328:	d9809d15 	stw	r6,628(sp)
8112332c:	00bfec16 	blt	zero,r2,811232e0 <__reset+0xfb1032e0>
81123330:	e00b883a 	mov	r5,fp
81123334:	b009883a 	mov	r4,r22
81123338:	111e0940 	call	8111e094 <__srefill_r>
8112333c:	1000db1e 	bne	r2,zero,811236ac <__svfscanf_r+0x8f8>
81123340:	b9c00017 	ldw	r7,0(r23)
81123344:	003fe606 	br	811232e0 <__reset+0xfb1032e0>
81123348:	d9809d15 	stw	r6,628(sp)
8112334c:	8880040c 	andi	r2,r17,16
81123350:	10009c1e 	bne	r2,zero,811235c4 <__svfscanf_r+0x810>
81123354:	8880010c 	andi	r2,r17,4
81123358:	10011e26 	beq	r2,zero,811237d4 <__svfscanf_r+0xa20>
8112335c:	da009c17 	ldw	r8,624(sp)
81123360:	3029883a 	mov	r20,r6
81123364:	40800017 	ldw	r2,0(r8)
81123368:	42000104 	addi	r8,r8,4
8112336c:	da009c15 	stw	r8,624(sp)
81123370:	1480000d 	sth	r18,0(r2)
81123374:	003ecc06 	br	81122ea8 <__reset+0xfb102ea8>
81123378:	a0c00043 	ldbu	r3,1(r20)
8112337c:	19410c26 	beq	r3,r5,811237b0 <__svfscanf_r+0x9fc>
81123380:	8c400054 	ori	r17,r17,1
81123384:	3029883a 	mov	r20,r6
81123388:	003ed506 	br	81122ee0 <__reset+0xfb102ee0>
8112338c:	a0800043 	ldbu	r2,1(r20)
81123390:	8c400114 	ori	r17,r17,4
81123394:	3029883a 	mov	r20,r6
81123398:	10c03fcc 	andi	r3,r2,255
8112339c:	003ed006 	br	81122ee0 <__reset+0xfb102ee0>
811233a0:	e0800117 	ldw	r2,4(fp)
811233a4:	d9809d15 	stw	r6,628(sp)
811233a8:	00bf790e 	bge	zero,r2,81123190 <__reset+0xfb103190>
811233ac:	00a044b4 	movhi	r2,33042
811233b0:	10b9a604 	addi	r2,r2,-6504
811233b4:	02000284 	movi	r8,10
811233b8:	d880a115 	stw	r2,644(sp)
811233bc:	da009e15 	stw	r8,632(sp)
811233c0:	050000c4 	movi	r20,3
811233c4:	003f8106 	br	811231cc <__reset+0xfb1031cc>
811233c8:	e0800117 	ldw	r2,4(fp)
811233cc:	d9809d15 	stw	r6,628(sp)
811233d0:	0080c40e 	bge	zero,r2,811236e4 <__svfscanf_r+0x930>
811233d4:	9800011e 	bne	r19,zero,811233dc <__svfscanf_r+0x628>
811233d8:	04c00044 	movi	r19,1
811233dc:	8880004c 	andi	r2,r17,1
811233e0:	1000441e 	bne	r2,zero,811234f4 <__svfscanf_r+0x740>
811233e4:	8c40040c 	andi	r17,r17,16
811233e8:	8800da26 	beq	r17,zero,81123754 <__svfscanf_r+0x9a0>
811233ec:	0021883a 	mov	r16,zero
811233f0:	00000806 	br	81123414 <__svfscanf_r+0x660>
811233f4:	1887883a 	add	r3,r3,r2
811233f8:	e00b883a 	mov	r5,fp
811233fc:	b009883a 	mov	r4,r22
81123400:	e0c00015 	stw	r3,0(fp)
81123404:	80a1883a 	add	r16,r16,r2
81123408:	98a7c83a 	sub	r19,r19,r2
8112340c:	111e0940 	call	8111e094 <__srefill_r>
81123410:	1000ca1e 	bne	r2,zero,8112373c <__svfscanf_r+0x988>
81123414:	e0800117 	ldw	r2,4(fp)
81123418:	e0c00017 	ldw	r3,0(fp)
8112341c:	14fff516 	blt	r2,r19,811233f4 <__reset+0xfb1033f4>
81123420:	14c5c83a 	sub	r2,r2,r19
81123424:	1cd5883a 	add	r10,r3,r19
81123428:	84e1883a 	add	r16,r16,r19
8112342c:	e0800115 	stw	r2,4(fp)
81123430:	e2800015 	stw	r10,0(fp)
81123434:	dd009d17 	ldw	r20,628(sp)
81123438:	9425883a 	add	r18,r18,r16
8112343c:	a00d883a 	mov	r6,r20
81123440:	003e9a06 	br	81122eac <__reset+0xfb102eac>
81123444:	300b883a 	mov	r5,r6
81123448:	d9005884 	addi	r4,sp,354
8112344c:	d9809d15 	stw	r6,628(sp)
81123450:	112939c0 	call	8112939c <__sccl>
81123454:	1029883a 	mov	r20,r2
81123458:	e0800117 	ldw	r2,4(fp)
8112345c:	0081050e 	bge	zero,r2,81123874 <__svfscanf_r+0xac0>
81123460:	e1000017 	ldw	r4,0(fp)
81123464:	20800003 	ldbu	r2,0(r4)
81123468:	98005926 	beq	r19,zero,811235d0 <__svfscanf_r+0x81c>
8112346c:	8c40040c 	andi	r17,r17,16
81123470:	88005a26 	beq	r17,zero,811235dc <__svfscanf_r+0x828>
81123474:	9823883a 	mov	r17,r19
81123478:	0021883a 	mov	r16,zero
8112347c:	00000106 	br	81123484 <__svfscanf_r+0x6d0>
81123480:	20800003 	ldbu	r2,0(r4)
81123484:	10803fcc 	andi	r2,r2,255
81123488:	d8c05884 	addi	r3,sp,354
8112348c:	1885883a 	add	r2,r3,r2
81123490:	10800007 	ldb	r2,0(r2)
81123494:	1000ad26 	beq	r2,zero,8112374c <__svfscanf_r+0x998>
81123498:	e0800117 	ldw	r2,4(fp)
8112349c:	21000044 	addi	r4,r4,1
811234a0:	84000044 	addi	r16,r16,1
811234a4:	10bfffc4 	addi	r2,r2,-1
811234a8:	e0800115 	stw	r2,4(fp)
811234ac:	e1000015 	stw	r4,0(fp)
811234b0:	84c0a026 	beq	r16,r19,81123734 <__svfscanf_r+0x980>
811234b4:	00bff216 	blt	zero,r2,81123480 <__reset+0xfb103480>
811234b8:	e00b883a 	mov	r5,fp
811234bc:	b009883a 	mov	r4,r22
811234c0:	111e0940 	call	8111e094 <__srefill_r>
811234c4:	10009a1e 	bne	r2,zero,81123730 <__svfscanf_r+0x97c>
811234c8:	e1000017 	ldw	r4,0(fp)
811234cc:	003fec06 	br	81123480 <__reset+0xfb103480>
811234d0:	e0800117 	ldw	r2,4(fp)
811234d4:	d9809d15 	stw	r6,628(sp)
811234d8:	0080eb0e 	bge	zero,r2,81123888 <__svfscanf_r+0xad4>
811234dc:	00a044b4 	movhi	r2,33042
811234e0:	10b9a604 	addi	r2,r2,-6504
811234e4:	d880a115 	stw	r2,644(sp)
811234e8:	d8009e15 	stw	zero,632(sp)
811234ec:	050000c4 	movi	r20,3
811234f0:	003f3606 	br	811231cc <__reset+0xfb1031cc>
811234f4:	dd409904 	addi	r21,sp,612
811234f8:	8c40040c 	andi	r17,r17,16
811234fc:	01800204 	movi	r6,8
81123500:	000b883a 	mov	r5,zero
81123504:	a809883a 	mov	r4,r21
81123508:	dc409f15 	stw	r17,636(sp)
8112350c:	111dc180 	call	8111dc18 <memset>
81123510:	dc409f17 	ldw	r17,636(sp)
81123514:	88006e26 	beq	r17,zero,811236d0 <__svfscanf_r+0x91c>
81123518:	0029883a 	mov	r20,zero
8112351c:	0023883a 	mov	r17,zero
81123520:	11277b80 	call	811277b8 <__locale_mb_cur_max>
81123524:	14406126 	beq	r2,r17,811236ac <__svfscanf_r+0x8f8>
81123528:	e0800017 	ldw	r2,0(fp)
8112352c:	e0c00117 	ldw	r3,4(fp)
81123530:	d9000104 	addi	r4,sp,4
81123534:	12000003 	ldbu	r8,0(r2)
81123538:	18ffffc4 	addi	r3,r3,-1
8112353c:	10800044 	addi	r2,r2,1
81123540:	e0c00115 	stw	r3,4(fp)
81123544:	e0800015 	stw	r2,0(fp)
81123548:	8c000044 	addi	r16,r17,1
8112354c:	dd400015 	stw	r21,0(sp)
81123550:	2463883a 	add	r17,r4,r17
81123554:	200d883a 	mov	r6,r4
81123558:	a00b883a 	mov	r5,r20
8112355c:	800f883a 	mov	r7,r16
81123560:	b009883a 	mov	r4,r22
81123564:	8a000005 	stb	r8,0(r17)
81123568:	11278740 	call	81127874 <_mbrtowc_r>
8112356c:	017fffc4 	movi	r5,-1
81123570:	11404e26 	beq	r2,r5,811236ac <__svfscanf_r+0x8f8>
81123574:	1000601e 	bne	r2,zero,811236f8 <__svfscanf_r+0x944>
81123578:	da009f17 	ldw	r8,636(sp)
8112357c:	4000641e 	bne	r8,zero,81123710 <__svfscanf_r+0x95c>
81123580:	a0000015 	stw	zero,0(r20)
81123584:	9425883a 	add	r18,r18,r16
81123588:	9967883a 	add	r19,r19,r5
8112358c:	a5000104 	addi	r20,r20,4
81123590:	e0800117 	ldw	r2,4(fp)
81123594:	0023883a 	mov	r17,zero
81123598:	00804b16 	blt	zero,r2,811236c8 <__svfscanf_r+0x914>
8112359c:	e00b883a 	mov	r5,fp
811235a0:	b009883a 	mov	r4,r22
811235a4:	111e0940 	call	8111e094 <__srefill_r>
811235a8:	10004726 	beq	r2,zero,811236c8 <__svfscanf_r+0x914>
811235ac:	88003f1e 	bne	r17,zero,811236ac <__svfscanf_r+0x8f8>
811235b0:	d8c09f17 	ldw	r3,636(sp)
811235b4:	1800031e 	bne	r3,zero,811235c4 <__svfscanf_r+0x810>
811235b8:	da00a017 	ldw	r8,640(sp)
811235bc:	42000044 	addi	r8,r8,1
811235c0:	da00a015 	stw	r8,640(sp)
811235c4:	dd009d17 	ldw	r20,628(sp)
811235c8:	a00d883a 	mov	r6,r20
811235cc:	003e3706 	br	81122eac <__reset+0xfb102eac>
811235d0:	8c40040c 	andi	r17,r17,16
811235d4:	04ffffc4 	movi	r19,-1
811235d8:	883fa61e 	bne	r17,zero,81123474 <__reset+0xfb103474>
811235dc:	da009c17 	ldw	r8,624(sp)
811235e0:	9abfffc4 	addi	r10,r19,-1
811235e4:	44000017 	ldw	r16,0(r8)
811235e8:	44400104 	addi	r17,r8,4
811235ec:	8007883a 	mov	r3,r16
811235f0:	82ab883a 	add	r21,r16,r10
811235f4:	00000306 	br	81123604 <__svfscanf_r+0x850>
811235f8:	e1000017 	ldw	r4,0(fp)
811235fc:	9807883a 	mov	r3,r19
81123600:	20800003 	ldbu	r2,0(r4)
81123604:	10803fcc 	andi	r2,r2,255
81123608:	d9405884 	addi	r5,sp,354
8112360c:	2885883a 	add	r2,r5,r2
81123610:	10800007 	ldb	r2,0(r2)
81123614:	10004b26 	beq	r2,zero,81123744 <__svfscanf_r+0x990>
81123618:	e0800117 	ldw	r2,4(fp)
8112361c:	21400044 	addi	r5,r4,1
81123620:	e1400015 	stw	r5,0(fp)
81123624:	10bfffc4 	addi	r2,r2,-1
81123628:	e0800115 	stw	r2,4(fp)
8112362c:	20800003 	ldbu	r2,0(r4)
81123630:	1cc00044 	addi	r19,r3,1
81123634:	18800005 	stb	r2,0(r3)
81123638:	1d400726 	beq	r3,r21,81123658 <__svfscanf_r+0x8a4>
8112363c:	e0800117 	ldw	r2,4(fp)
81123640:	00bfed16 	blt	zero,r2,811235f8 <__reset+0xfb1035f8>
81123644:	e00b883a 	mov	r5,fp
81123648:	b009883a 	mov	r4,r22
8112364c:	111e0940 	call	8111e094 <__srefill_r>
81123650:	103fe926 	beq	r2,zero,811235f8 <__reset+0xfb1035f8>
81123654:	84c01526 	beq	r16,r19,811236ac <__svfscanf_r+0x8f8>
81123658:	9c21c83a 	sub	r16,r19,r16
8112365c:	803e1726 	beq	r16,zero,81122ebc <__reset+0xfb102ebc>
81123660:	da00a017 	ldw	r8,640(sp)
81123664:	98000005 	stb	zero,0(r19)
81123668:	dc409c15 	stw	r17,624(sp)
8112366c:	42000044 	addi	r8,r8,1
81123670:	da00a015 	stw	r8,640(sp)
81123674:	9425883a 	add	r18,r18,r16
81123678:	a00d883a 	mov	r6,r20
8112367c:	003e0b06 	br	81122eac <__reset+0xfb102eac>
81123680:	017fff84 	movi	r5,-2
81123684:	11439b1e 	bne	r2,r5,811244f4 <__svfscanf_r+0x1740>
81123688:	8821883a 	mov	r16,r17
8112368c:	e0800117 	ldw	r2,4(fp)
81123690:	0082e516 	blt	zero,r2,81124228 <__svfscanf_r+0x1474>
81123694:	e00b883a 	mov	r5,fp
81123698:	b009883a 	mov	r4,r22
8112369c:	111e0940 	call	8111e094 <__srefill_r>
811236a0:	1002e126 	beq	r2,zero,81124228 <__svfscanf_r+0x1474>
811236a4:	dc409f17 	ldw	r17,636(sp)
811236a8:	8002e826 	beq	r16,zero,8112424c <__svfscanf_r+0x1498>
811236ac:	da00a017 	ldw	r8,640(sp)
811236b0:	403e9c26 	beq	r8,zero,81123124 <__reset+0xfb103124>
811236b4:	e080030b 	ldhu	r2,12(fp)
811236b8:	1080100c 	andi	r2,r2,64
811236bc:	103e991e 	bne	r2,zero,81123124 <__reset+0xfb103124>
811236c0:	4005883a 	mov	r2,r8
811236c4:	003e9806 	br	81123128 <__reset+0xfb103128>
811236c8:	983f951e 	bne	r19,zero,81123520 <__reset+0xfb103520>
811236cc:	003fb806 	br	811235b0 <__reset+0xfb1035b0>
811236d0:	da009c17 	ldw	r8,624(sp)
811236d4:	45000017 	ldw	r20,0(r8)
811236d8:	42000104 	addi	r8,r8,4
811236dc:	da009c15 	stw	r8,624(sp)
811236e0:	003f8e06 	br	8112351c <__reset+0xfb10351c>
811236e4:	e00b883a 	mov	r5,fp
811236e8:	b009883a 	mov	r4,r22
811236ec:	111e0940 	call	8111e094 <__srefill_r>
811236f0:	103f3826 	beq	r2,zero,811233d4 <__reset+0xfb1033d4>
811236f4:	003fed06 	br	811236ac <__reset+0xfb1036ac>
811236f8:	00ffff84 	movi	r3,-2
811236fc:	10c0071e 	bne	r2,r3,8112371c <__svfscanf_r+0x968>
81123700:	e0800117 	ldw	r2,4(fp)
81123704:	8023883a 	mov	r17,r16
81123708:	00bf8516 	blt	zero,r2,81123520 <__reset+0xfb103520>
8112370c:	003fa306 	br	8112359c <__reset+0xfb10359c>
81123710:	9425883a 	add	r18,r18,r16
81123714:	9cffffc4 	addi	r19,r19,-1
81123718:	003f9d06 	br	81123590 <__reset+0xfb103590>
8112371c:	da009f17 	ldw	r8,636(sp)
81123720:	9425883a 	add	r18,r18,r16
81123724:	9cffffc4 	addi	r19,r19,-1
81123728:	403f9826 	beq	r8,zero,8112358c <__reset+0xfb10358c>
8112372c:	003f9806 	br	81123590 <__reset+0xfb103590>
81123730:	8023883a 	mov	r17,r16
81123734:	8821883a 	mov	r16,r17
81123738:	003fce06 	br	81123674 <__reset+0xfb103674>
8112373c:	803f3d1e 	bne	r16,zero,81123434 <__reset+0xfb103434>
81123740:	003fda06 	br	811236ac <__reset+0xfb1036ac>
81123744:	1827883a 	mov	r19,r3
81123748:	003fc306 	br	81123658 <__reset+0xfb103658>
8112374c:	803fc91e 	bne	r16,zero,81123674 <__reset+0xfb103674>
81123750:	003dda06 	br	81122ebc <__reset+0xfb102ebc>
81123754:	da009c17 	ldw	r8,624(sp)
81123758:	df000015 	stw	fp,0(sp)
8112375c:	980f883a 	mov	r7,r19
81123760:	41400017 	ldw	r5,0(r8)
81123764:	01800044 	movi	r6,1
81123768:	b009883a 	mov	r4,r22
8112376c:	112698c0 	call	8112698c <_fread_r>
81123770:	da009c17 	ldw	r8,624(sp)
81123774:	40c00104 	addi	r3,r8,4
81123778:	103fcc26 	beq	r2,zero,811236ac <__reset+0xfb1036ac>
8112377c:	da00a017 	ldw	r8,640(sp)
81123780:	dd009d17 	ldw	r20,628(sp)
81123784:	90a5883a 	add	r18,r18,r2
81123788:	42000044 	addi	r8,r8,1
8112378c:	da00a015 	stw	r8,640(sp)
81123790:	d8c09c15 	stw	r3,624(sp)
81123794:	a00d883a 	mov	r6,r20
81123798:	003dc406 	br	81122eac <__reset+0xfb102eac>
8112379c:	e00b883a 	mov	r5,fp
811237a0:	b009883a 	mov	r4,r22
811237a4:	111e0940 	call	8111e094 <__srefill_r>
811237a8:	103e5226 	beq	r2,zero,811230f4 <__reset+0xfb1030f4>
811237ac:	003fbf06 	br	811236ac <__reset+0xfb1036ac>
811237b0:	a0800083 	ldbu	r2,2(r20)
811237b4:	8c400094 	ori	r17,r17,2
811237b8:	a5000084 	addi	r20,r20,2
811237bc:	10c03fcc 	andi	r3,r2,255
811237c0:	003dc706 	br	81122ee0 <__reset+0xfb102ee0>
811237c4:	e0800117 	ldw	r2,4(fp)
811237c8:	88e2b03a 	or	r17,r17,r3
811237cc:	00bef716 	blt	zero,r2,811233ac <__reset+0xfb1033ac>
811237d0:	003e6f06 	br	81123190 <__reset+0xfb103190>
811237d4:	8880004c 	andi	r2,r17,1
811237d8:	10000b1e 	bne	r2,zero,81123808 <__svfscanf_r+0xa54>
811237dc:	8c40008c 	andi	r17,r17,2
811237e0:	88000926 	beq	r17,zero,81123808 <__svfscanf_r+0xa54>
811237e4:	da009c17 	ldw	r8,624(sp)
811237e8:	9007d7fa 	srai	r3,r18,31
811237ec:	dd009d17 	ldw	r20,628(sp)
811237f0:	40800017 	ldw	r2,0(r8)
811237f4:	42000104 	addi	r8,r8,4
811237f8:	da009c15 	stw	r8,624(sp)
811237fc:	14800015 	stw	r18,0(r2)
81123800:	10c00115 	stw	r3,4(r2)
81123804:	003da806 	br	81122ea8 <__reset+0xfb102ea8>
81123808:	da009c17 	ldw	r8,624(sp)
8112380c:	dd009d17 	ldw	r20,628(sp)
81123810:	40800017 	ldw	r2,0(r8)
81123814:	42000104 	addi	r8,r8,4
81123818:	da009c15 	stw	r8,624(sp)
8112381c:	14800015 	stw	r18,0(r2)
81123820:	003da106 	br	81122ea8 <__reset+0xfb102ea8>
81123824:	e00b883a 	mov	r5,fp
81123828:	b009883a 	mov	r4,r22
8112382c:	111e0940 	call	8111e094 <__srefill_r>
81123830:	103f9e1e 	bne	r2,zero,811236ac <__reset+0xfb1036ac>
81123834:	b9c00017 	ldw	r7,0(r23)
81123838:	05000104 	movi	r20,4
8112383c:	003e6306 	br	811231cc <__reset+0xfb1031cc>
81123840:	e00b883a 	mov	r5,fp
81123844:	b009883a 	mov	r4,r22
81123848:	111e0940 	call	8111e094 <__srefill_r>
8112384c:	103f971e 	bne	r2,zero,811236ac <__reset+0xfb1036ac>
81123850:	b9c00017 	ldw	r7,0(r23)
81123854:	003e5706 	br	811231b4 <__reset+0xfb1031b4>
81123858:	e00b883a 	mov	r5,fp
8112385c:	b009883a 	mov	r4,r22
81123860:	111e0940 	call	8111e094 <__srefill_r>
81123864:	103f911e 	bne	r2,zero,811236ac <__reset+0xfb1036ac>
81123868:	b9c00017 	ldw	r7,0(r23)
8112386c:	05000084 	movi	r20,2
81123870:	003e5606 	br	811231cc <__reset+0xfb1031cc>
81123874:	e00b883a 	mov	r5,fp
81123878:	b009883a 	mov	r4,r22
8112387c:	111e0940 	call	8111e094 <__srefill_r>
81123880:	103ef726 	beq	r2,zero,81123460 <__reset+0xfb103460>
81123884:	003f8906 	br	811236ac <__reset+0xfb1036ac>
81123888:	e00b883a 	mov	r5,fp
8112388c:	b009883a 	mov	r4,r22
81123890:	111e0940 	call	8111e094 <__srefill_r>
81123894:	103f851e 	bne	r2,zero,811236ac <__reset+0xfb1036ac>
81123898:	b9c00017 	ldw	r7,0(r23)
8112389c:	003f0f06 	br	811234dc <__reset+0xfb1034dc>
811238a0:	014000c4 	movi	r5,3
811238a4:	a1414a26 	beq	r20,r5,81123dd0 <__svfscanf_r+0x101c>
811238a8:	01000104 	movi	r4,4
811238ac:	a101f11e 	bne	r20,r4,81124074 <__svfscanf_r+0x12c0>
811238b0:	b009883a 	mov	r4,r22
811238b4:	11277dc0 	call	811277dc <_localeconv_r>
811238b8:	10800017 	ldw	r2,0(r2)
811238bc:	98ffffc4 	addi	r3,r19,-1
811238c0:	d880a315 	stw	r2,652(sp)
811238c4:	00805704 	movi	r2,348
811238c8:	10c21e2e 	bgeu	r2,r3,81124144 <__svfscanf_r+0x1390>
811238cc:	9cffa8c4 	addi	r19,r19,-349
811238d0:	dcc0a215 	stw	r19,648(sp)
811238d4:	04c05744 	movi	r19,349
811238d8:	8d01e014 	ori	r20,r17,1920
811238dc:	0023883a 	mov	r17,zero
811238e0:	dc000104 	addi	r16,sp,4
811238e4:	8805883a 	mov	r2,r17
811238e8:	0019883a 	mov	r12,zero
811238ec:	8023883a 	mov	r17,r16
811238f0:	b007883a 	mov	r3,r22
811238f4:	9821883a 	mov	r16,r19
811238f8:	002b883a 	mov	r21,zero
811238fc:	d800a515 	stw	zero,660(sp)
81123900:	d800a415 	stw	zero,656(sp)
81123904:	d8009f15 	stw	zero,636(sp)
81123908:	01c01384 	movi	r7,78
8112390c:	602d883a 	mov	r22,r12
81123910:	1027883a 	mov	r19,r2
81123914:	e1000017 	ldw	r4,0(fp)
81123918:	21400003 	ldbu	r5,0(r4)
8112391c:	28bff544 	addi	r2,r5,-43
81123920:	10803fcc 	andi	r2,r2,255
81123924:	38810e36 	bltu	r7,r2,81123d60 <__svfscanf_r+0xfac>
81123928:	100490ba 	slli	r2,r2,2
8112392c:	01a044b4 	movhi	r6,33042
81123930:	318e5004 	addi	r6,r6,14656
81123934:	1185883a 	add	r2,r2,r6
81123938:	10800017 	ldw	r2,0(r2)
8112393c:	1000683a 	jmp	r2
81123940:	81123c38 	rdprs	r4,r16,18672
81123944:	81123d60 	cmpeqi	r4,r16,18677
81123948:	81123c38 	rdprs	r4,r16,18672
8112394c:	81123d60 	cmpeqi	r4,r16,18677
81123950:	81123d60 	cmpeqi	r4,r16,18677
81123954:	81123c0c 	andi	r4,r16,18672
81123958:	81123a7c 	xorhi	r4,r16,18665
8112395c:	81123a7c 	xorhi	r4,r16,18665
81123960:	81123a7c 	xorhi	r4,r16,18665
81123964:	81123a7c 	xorhi	r4,r16,18665
81123968:	81123a7c 	xorhi	r4,r16,18665
8112396c:	81123a7c 	xorhi	r4,r16,18665
81123970:	81123a7c 	xorhi	r4,r16,18665
81123974:	81123a7c 	xorhi	r4,r16,18665
81123978:	81123a7c 	xorhi	r4,r16,18665
8112397c:	81123d60 	cmpeqi	r4,r16,18677
81123980:	81123d60 	cmpeqi	r4,r16,18677
81123984:	81123d60 	cmpeqi	r4,r16,18677
81123988:	81123d60 	cmpeqi	r4,r16,18677
8112398c:	81123d60 	cmpeqi	r4,r16,18677
81123990:	81123d60 	cmpeqi	r4,r16,18677
81123994:	81123d60 	cmpeqi	r4,r16,18677
81123998:	81123d50 	cmplti	r4,r16,18677
8112399c:	81123d60 	cmpeqi	r4,r16,18677
811239a0:	81123d60 	cmpeqi	r4,r16,18677
811239a4:	81123d60 	cmpeqi	r4,r16,18677
811239a8:	81123d0c 	andi	r4,r16,18676
811239ac:	81123cf0 	cmpltui	r4,r16,18675
811239b0:	81123d60 	cmpeqi	r4,r16,18677
811239b4:	81123d60 	cmpeqi	r4,r16,18677
811239b8:	81123cbc 	xorhi	r4,r16,18674
811239bc:	81123d60 	cmpeqi	r4,r16,18677
811239c0:	81123d60 	cmpeqi	r4,r16,18677
811239c4:	81123d60 	cmpeqi	r4,r16,18677
811239c8:	81123d60 	cmpeqi	r4,r16,18677
811239cc:	81123c84 	addi	r4,r16,18674
811239d0:	81123d60 	cmpeqi	r4,r16,18677
811239d4:	81123d60 	cmpeqi	r4,r16,18677
811239d8:	81123d60 	cmpeqi	r4,r16,18677
811239dc:	81123d60 	cmpeqi	r4,r16,18677
811239e0:	81123d60 	cmpeqi	r4,r16,18677
811239e4:	81123c68 	cmpgeui	r4,r16,18673
811239e8:	81123d60 	cmpeqi	r4,r16,18677
811239ec:	81123d60 	cmpeqi	r4,r16,18677
811239f0:	81123d60 	cmpeqi	r4,r16,18677
811239f4:	81123d60 	cmpeqi	r4,r16,18677
811239f8:	81123c4c 	andi	r4,r16,18673
811239fc:	81123d60 	cmpeqi	r4,r16,18677
81123a00:	81123d60 	cmpeqi	r4,r16,18677
81123a04:	81123d60 	cmpeqi	r4,r16,18677
81123a08:	81123d60 	cmpeqi	r4,r16,18677
81123a0c:	81123d60 	cmpeqi	r4,r16,18677
81123a10:	81123d60 	cmpeqi	r4,r16,18677
81123a14:	81123d60 	cmpeqi	r4,r16,18677
81123a18:	81123d50 	cmplti	r4,r16,18677
81123a1c:	81123d60 	cmpeqi	r4,r16,18677
81123a20:	81123d60 	cmpeqi	r4,r16,18677
81123a24:	81123d60 	cmpeqi	r4,r16,18677
81123a28:	81123d0c 	andi	r4,r16,18676
81123a2c:	81123cf0 	cmpltui	r4,r16,18675
81123a30:	81123d60 	cmpeqi	r4,r16,18677
81123a34:	81123d60 	cmpeqi	r4,r16,18677
81123a38:	81123cbc 	xorhi	r4,r16,18674
81123a3c:	81123d60 	cmpeqi	r4,r16,18677
81123a40:	81123d60 	cmpeqi	r4,r16,18677
81123a44:	81123d60 	cmpeqi	r4,r16,18677
81123a48:	81123d60 	cmpeqi	r4,r16,18677
81123a4c:	81123c84 	addi	r4,r16,18674
81123a50:	81123d60 	cmpeqi	r4,r16,18677
81123a54:	81123d60 	cmpeqi	r4,r16,18677
81123a58:	81123d60 	cmpeqi	r4,r16,18677
81123a5c:	81123d60 	cmpeqi	r4,r16,18677
81123a60:	81123d60 	cmpeqi	r4,r16,18677
81123a64:	81123c68 	cmpgeui	r4,r16,18673
81123a68:	81123d60 	cmpeqi	r4,r16,18677
81123a6c:	81123d60 	cmpeqi	r4,r16,18677
81123a70:	81123d60 	cmpeqi	r4,r16,18677
81123a74:	81123d60 	cmpeqi	r4,r16,18677
81123a78:	81123c4c 	andi	r4,r16,18673
81123a7c:	a8803fcc 	andi	r2,r21,255
81123a80:	1080201c 	xori	r2,r2,128
81123a84:	10bfe004 	addi	r2,r2,-128
81123a88:	b085883a 	add	r2,r22,r2
81123a8c:	10000d1e 	bne	r2,zero,81123ac4 <__svfscanf_r+0xd10>
81123a90:	00bf9fc4 	movi	r2,-385
81123a94:	a0a8703a 	and	r20,r20,r2
81123a98:	89400005 	stb	r5,0(r17)
81123a9c:	8c400044 	addi	r17,r17,1
81123aa0:	e0800117 	ldw	r2,4(fp)
81123aa4:	843fffc4 	addi	r16,r16,-1
81123aa8:	94800044 	addi	r18,r18,1
81123aac:	10bfffc4 	addi	r2,r2,-1
81123ab0:	e0800115 	stw	r2,4(fp)
81123ab4:	0080b40e 	bge	zero,r2,81123d88 <__svfscanf_r+0xfd4>
81123ab8:	21000044 	addi	r4,r4,1
81123abc:	e1000015 	stw	r4,0(fp)
81123ac0:	803f941e 	bne	r16,zero,81123914 <__reset+0xfb103914>
81123ac4:	8821883a 	mov	r16,r17
81123ac8:	b019883a 	mov	r12,r22
81123acc:	9823883a 	mov	r17,r19
81123ad0:	182d883a 	mov	r22,r3
81123ad4:	9801961e 	bne	r19,zero,81124130 <__svfscanf_r+0x137c>
81123ad8:	633fffc4 	addi	r12,r12,-1
81123adc:	00800044 	movi	r2,1
81123ae0:	1302882e 	bgeu	r2,r12,81124504 <__svfscanf_r+0x1750>
81123ae4:	a8803fcc 	andi	r2,r21,255
81123ae8:	1080201c 	xori	r2,r2,128
81123aec:	10bfe004 	addi	r2,r2,-128
81123af0:	113fffc4 	addi	r4,r2,-1
81123af4:	01400184 	movi	r5,6
81123af8:	29001136 	bltu	r5,r4,81123b40 <__svfscanf_r+0xd8c>
81123afc:	01000084 	movi	r4,2
81123b00:	2082900e 	bge	r4,r2,81124544 <__svfscanf_r+0x1790>
81123b04:	00c000c4 	movi	r3,3
81123b08:	10c00d26 	beq	r2,r3,81123b40 <__svfscanf_r+0xd8c>
81123b0c:	9425c83a 	sub	r18,r18,r16
81123b10:	1827883a 	mov	r19,r3
81123b14:	843fffc4 	addi	r16,r16,-1
81123b18:	81400007 	ldb	r5,0(r16)
81123b1c:	e00d883a 	mov	r6,fp
81123b20:	b009883a 	mov	r4,r22
81123b24:	112ca0c0 	call	8112ca0c <_ungetc_r>
81123b28:	a8bfffc4 	addi	r2,r21,-1
81123b2c:	10c03fcc 	andi	r3,r2,255
81123b30:	8493883a 	add	r9,r16,r18
81123b34:	102b883a 	mov	r21,r2
81123b38:	98fff636 	bltu	r19,r3,81123b14 <__reset+0xfb103b14>
81123b3c:	4825883a 	mov	r18,r9
81123b40:	a080400c 	andi	r2,r20,256
81123b44:	10001426 	beq	r2,zero,81123b98 <__svfscanf_r+0xde4>
81123b48:	a081000c 	andi	r2,r20,1024
81123b4c:	1002571e 	bne	r2,zero,811244ac <__svfscanf_r+0x16f8>
81123b50:	817fffc7 	ldb	r5,-1(r16)
81123b54:	00801944 	movi	r2,101
81123b58:	84ffffc4 	addi	r19,r16,-1
81123b5c:	957fffc4 	addi	r21,r18,-1
81123b60:	28800826 	beq	r5,r2,81123b84 <__svfscanf_r+0xdd0>
81123b64:	00801144 	movi	r2,69
81123b68:	28800626 	beq	r5,r2,81123b84 <__svfscanf_r+0xdd0>
81123b6c:	e00d883a 	mov	r6,fp
81123b70:	b009883a 	mov	r4,r22
81123b74:	112ca0c0 	call	8112ca0c <_ungetc_r>
81123b78:	817fff87 	ldb	r5,-2(r16)
81123b7c:	84ffff84 	addi	r19,r16,-2
81123b80:	957fff84 	addi	r21,r18,-2
81123b84:	e00d883a 	mov	r6,fp
81123b88:	b009883a 	mov	r4,r22
81123b8c:	112ca0c0 	call	8112ca0c <_ungetc_r>
81123b90:	a825883a 	mov	r18,r21
81123b94:	9821883a 	mov	r16,r19
81123b98:	a080040c 	andi	r2,r20,16
81123b9c:	103e891e 	bne	r2,zero,811235c4 <__reset+0xfb1035c4>
81123ba0:	80000005 	stb	zero,0(r16)
81123ba4:	a081800c 	andi	r2,r20,1536
81123ba8:	01010004 	movi	r4,1024
81123bac:	1101dd26 	beq	r2,r4,81124324 <__svfscanf_r+0x1570>
81123bb0:	da00a417 	ldw	r8,656(sp)
81123bb4:	4001e71e 	bne	r8,zero,81124354 <__svfscanf_r+0x15a0>
81123bb8:	000d883a 	mov	r6,zero
81123bbc:	d9400104 	addi	r5,sp,4
81123bc0:	b009883a 	mov	r4,r22
81123bc4:	11295bc0 	call	811295bc <_strtod_r>
81123bc8:	1021883a 	mov	r16,r2
81123bcc:	a080004c 	andi	r2,r20,1
81123bd0:	1000021e 	bne	r2,zero,81123bdc <__svfscanf_r+0xe28>
81123bd4:	a2c0008c 	andi	r11,r20,2
81123bd8:	5801e826 	beq	r11,zero,8112437c <__svfscanf_r+0x15c8>
81123bdc:	da009c17 	ldw	r8,624(sp)
81123be0:	40800017 	ldw	r2,0(r8)
81123be4:	42000104 	addi	r8,r8,4
81123be8:	da009c15 	stw	r8,624(sp)
81123bec:	14000015 	stw	r16,0(r2)
81123bf0:	10c00115 	stw	r3,4(r2)
81123bf4:	da00a017 	ldw	r8,640(sp)
81123bf8:	dd009d17 	ldw	r20,628(sp)
81123bfc:	42000044 	addi	r8,r8,1
81123c00:	da00a015 	stw	r8,640(sp)
81123c04:	a00d883a 	mov	r6,r20
81123c08:	003ca806 	br	81122eac <__reset+0xfb102eac>
81123c0c:	a080400c 	andi	r2,r20,256
81123c10:	103f9a26 	beq	r2,zero,81123a7c <__reset+0xfb103a7c>
81123c14:	da00a217 	ldw	r8,648(sp)
81123c18:	00bfdfc4 	movi	r2,-129
81123c1c:	a0a8703a 	and	r20,r20,r2
81123c20:	9cc00044 	addi	r19,r19,1
81123c24:	403f9e26 	beq	r8,zero,81123aa0 <__reset+0xfb103aa0>
81123c28:	423fffc4 	addi	r8,r8,-1
81123c2c:	da00a215 	stw	r8,648(sp)
81123c30:	84000044 	addi	r16,r16,1
81123c34:	003f9a06 	br	81123aa0 <__reset+0xfb103aa0>
81123c38:	a080200c 	andi	r2,r20,128
81123c3c:	103fa126 	beq	r2,zero,81123ac4 <__reset+0xfb103ac4>
81123c40:	00bfdfc4 	movi	r2,-129
81123c44:	a0a8703a 	and	r20,r20,r2
81123c48:	003f9306 	br	81123a98 <__reset+0xfb103a98>
81123c4c:	a8803fcc 	andi	r2,r21,255
81123c50:	1080201c 	xori	r2,r2,128
81123c54:	10bfe004 	addi	r2,r2,-128
81123c58:	020001c4 	movi	r8,7
81123c5c:	123f991e 	bne	r2,r8,81123ac4 <__reset+0xfb103ac4>
81123c60:	05400204 	movi	r21,8
81123c64:	003f8c06 	br	81123a98 <__reset+0xfb103a98>
81123c68:	a8803fcc 	andi	r2,r21,255
81123c6c:	1080201c 	xori	r2,r2,128
81123c70:	10bfe004 	addi	r2,r2,-128
81123c74:	01800184 	movi	r6,6
81123c78:	11bf921e 	bne	r2,r6,81123ac4 <__reset+0xfb103ac4>
81123c7c:	054001c4 	movi	r21,7
81123c80:	003f8506 	br	81123a98 <__reset+0xfb103a98>
81123c84:	b000491e 	bne	r22,zero,81123dac <__svfscanf_r+0xff8>
81123c88:	9800031e 	bne	r19,zero,81123c98 <__svfscanf_r+0xee4>
81123c8c:	a081c00c 	andi	r2,r20,1792
81123c90:	0181c004 	movi	r6,1792
81123c94:	11819f26 	beq	r2,r6,81124314 <__svfscanf_r+0x1560>
81123c98:	a8803fcc 	andi	r2,r21,255
81123c9c:	1080201c 	xori	r2,r2,128
81123ca0:	10bfe004 	addi	r2,r2,-128
81123ca4:	01800044 	movi	r6,1
81123ca8:	11800226 	beq	r2,r6,81123cb4 <__svfscanf_r+0xf00>
81123cac:	01800104 	movi	r6,4
81123cb0:	11bf841e 	bne	r2,r6,81123ac4 <__reset+0xfb103ac4>
81123cb4:	ad400044 	addi	r21,r21,1
81123cb8:	003f7706 	br	81123a98 <__reset+0xfb103a98>
81123cbc:	a8803fcc 	andi	r2,r21,255
81123cc0:	1080201c 	xori	r2,r2,128
81123cc4:	10bfe004 	addi	r2,r2,-128
81123cc8:	10003c1e 	bne	r2,zero,81123dbc <__svfscanf_r+0x1008>
81123ccc:	9801141e 	bne	r19,zero,81124120 <__svfscanf_r+0x136c>
81123cd0:	a081c00c 	andi	r2,r20,1792
81123cd4:	0181c004 	movi	r6,1792
81123cd8:	11818226 	beq	r2,r6,811242e4 <__svfscanf_r+0x1530>
81123cdc:	8821883a 	mov	r16,r17
81123ce0:	b019883a 	mov	r12,r22
81123ce4:	9823883a 	mov	r17,r19
81123ce8:	182d883a 	mov	r22,r3
81123cec:	003f7a06 	br	81123ad8 <__reset+0xfb103ad8>
81123cf0:	a8803fcc 	andi	r2,r21,255
81123cf4:	1080201c 	xori	r2,r2,128
81123cf8:	10bfe004 	addi	r2,r2,-128
81123cfc:	01800084 	movi	r6,2
81123d00:	11bf701e 	bne	r2,r6,81123ac4 <__reset+0xfb103ac4>
81123d04:	054000c4 	movi	r21,3
81123d08:	003f6306 	br	81123a98 <__reset+0xfb103a98>
81123d0c:	a081400c 	andi	r2,r20,1280
81123d10:	01810004 	movi	r6,1024
81123d14:	11800326 	beq	r2,r6,81123d24 <__svfscanf_r+0xf70>
81123d18:	a184703a 	and	r2,r20,r6
81123d1c:	103f6926 	beq	r2,zero,81123ac4 <__reset+0xfb103ac4>
81123d20:	983fee26 	beq	r19,zero,81123cdc <__reset+0xfb103cdc>
81123d24:	a080800c 	andi	r2,r20,512
81123d28:	1000041e 	bne	r2,zero,81123d3c <__svfscanf_r+0xf88>
81123d2c:	da009f17 	ldw	r8,636(sp)
81123d30:	dc40a515 	stw	r17,660(sp)
81123d34:	9a27c83a 	sub	r19,r19,r8
81123d38:	dcc0a415 	stw	r19,656(sp)
81123d3c:	00be1fc4 	movi	r2,-1921
81123d40:	a0a8703a 	and	r20,r20,r2
81123d44:	a5006014 	ori	r20,r20,384
81123d48:	0027883a 	mov	r19,zero
81123d4c:	003f5206 	br	81123a98 <__reset+0xfb103a98>
81123d50:	00800044 	movi	r2,1
81123d54:	b0bf5b1e 	bne	r22,r2,81123ac4 <__reset+0xfb103ac4>
81123d58:	05800084 	movi	r22,2
81123d5c:	003f4e06 	br	81123a98 <__reset+0xfb103a98>
81123d60:	d980a317 	ldw	r6,652(sp)
81123d64:	30800003 	ldbu	r2,0(r6)
81123d68:	29803fcc 	andi	r6,r5,255
81123d6c:	30bf551e 	bne	r6,r2,81123ac4 <__reset+0xfb103ac4>
81123d70:	a080800c 	andi	r2,r20,512
81123d74:	103f5326 	beq	r2,zero,81123ac4 <__reset+0xfb103ac4>
81123d78:	023f5fc4 	movi	r8,-641
81123d7c:	a228703a 	and	r20,r20,r8
81123d80:	dcc09f15 	stw	r19,636(sp)
81123d84:	003f4406 	br	81123a98 <__reset+0xfb103a98>
81123d88:	1809883a 	mov	r4,r3
81123d8c:	e00b883a 	mov	r5,fp
81123d90:	d8c0a615 	stw	r3,664(sp)
81123d94:	d9c0aa15 	stw	r7,680(sp)
81123d98:	111e0940 	call	8111e094 <__srefill_r>
81123d9c:	d8c0a617 	ldw	r3,664(sp)
81123da0:	d9c0aa17 	ldw	r7,680(sp)
81123da4:	103f4626 	beq	r2,zero,81123ac0 <__reset+0xfb103ac0>
81123da8:	003f4606 	br	81123ac4 <__reset+0xfb103ac4>
81123dac:	00800084 	movi	r2,2
81123db0:	b0bfb91e 	bne	r22,r2,81123c98 <__reset+0xfb103c98>
81123db4:	058000c4 	movi	r22,3
81123db8:	003f3706 	br	81123a98 <__reset+0xfb103a98>
81123dbc:	018000c4 	movi	r6,3
81123dc0:	11bfbc26 	beq	r2,r6,81123cb4 <__reset+0xfb103cb4>
81123dc4:	01800144 	movi	r6,5
81123dc8:	11bfba26 	beq	r2,r6,81123cb4 <__reset+0xfb103cb4>
81123dcc:	003f3d06 	br	81123ac4 <__reset+0xfb103ac4>
81123dd0:	98bfffc4 	addi	r2,r19,-1
81123dd4:	01405704 	movi	r5,348
81123dd8:	2880d82e 	bgeu	r5,r2,8112413c <__svfscanf_r+0x1388>
81123ddc:	99ffa8c4 	addi	r7,r19,-349
81123de0:	04c05744 	movi	r19,349
81123de4:	8c436014 	ori	r17,r17,3456
81123de8:	9013883a 	mov	r9,r18
81123dec:	8825883a 	mov	r18,r17
81123df0:	dc409e17 	ldw	r17,632(sp)
81123df4:	0029883a 	mov	r20,zero
81123df8:	dc000104 	addi	r16,sp,4
81123dfc:	05401344 	movi	r21,77
81123e00:	02c08004 	movi	r11,512
81123e04:	01bf7fc4 	movi	r6,-513
81123e08:	023fdfc4 	movi	r8,-129
81123e0c:	20bff544 	addi	r2,r4,-43
81123e10:	10803fcc 	andi	r2,r2,255
81123e14:	a8807236 	bltu	r21,r2,81123fe0 <__svfscanf_r+0x122c>
81123e18:	100490ba 	slli	r2,r2,2
81123e1c:	016044b4 	movhi	r5,33042
81123e20:	294f8c04 	addi	r5,r5,15920
81123e24:	1145883a 	add	r2,r2,r5
81123e28:	10800017 	ldw	r2,0(r2)
81123e2c:	1000683a 	jmp	r2
81123e30:	81124064 	muli	r4,r16,18689
81123e34:	81123fe0 	cmpeqi	r4,r16,18687
81123e38:	81124064 	muli	r4,r16,18689
81123e3c:	81123fe0 	cmpeqi	r4,r16,18687
81123e40:	81123fe0 	cmpeqi	r4,r16,18687
81123e44:	8112403c 	xorhi	r4,r16,18688
81123e48:	8112401c 	xori	r4,r16,18688
81123e4c:	8112401c 	xori	r4,r16,18688
81123e50:	8112401c 	xori	r4,r16,18688
81123e54:	8112401c 	xori	r4,r16,18688
81123e58:	8112401c 	xori	r4,r16,18688
81123e5c:	8112401c 	xori	r4,r16,18688
81123e60:	8112401c 	xori	r4,r16,18688
81123e64:	81123fc4 	addi	r4,r16,18687
81123e68:	81123fc4 	addi	r4,r16,18687
81123e6c:	81123fe0 	cmpeqi	r4,r16,18687
81123e70:	81123fe0 	cmpeqi	r4,r16,18687
81123e74:	81123fe0 	cmpeqi	r4,r16,18687
81123e78:	81123fe0 	cmpeqi	r4,r16,18687
81123e7c:	81123fe0 	cmpeqi	r4,r16,18687
81123e80:	81123fe0 	cmpeqi	r4,r16,18687
81123e84:	81123fe0 	cmpeqi	r4,r16,18687
81123e88:	81123fb0 	cmpltui	r4,r16,18686
81123e8c:	81123fb0 	cmpltui	r4,r16,18686
81123e90:	81123fb0 	cmpltui	r4,r16,18686
81123e94:	81123fb0 	cmpltui	r4,r16,18686
81123e98:	81123fb0 	cmpltui	r4,r16,18686
81123e9c:	81123fb0 	cmpltui	r4,r16,18686
81123ea0:	81123fe0 	cmpeqi	r4,r16,18687
81123ea4:	81123fe0 	cmpeqi	r4,r16,18687
81123ea8:	81123fe0 	cmpeqi	r4,r16,18687
81123eac:	81123fe0 	cmpeqi	r4,r16,18687
81123eb0:	81123fe0 	cmpeqi	r4,r16,18687
81123eb4:	81123fe0 	cmpeqi	r4,r16,18687
81123eb8:	81123fe0 	cmpeqi	r4,r16,18687
81123ebc:	81123fe0 	cmpeqi	r4,r16,18687
81123ec0:	81123fe0 	cmpeqi	r4,r16,18687
81123ec4:	81123fe0 	cmpeqi	r4,r16,18687
81123ec8:	81123fe0 	cmpeqi	r4,r16,18687
81123ecc:	81123fe0 	cmpeqi	r4,r16,18687
81123ed0:	81123fe0 	cmpeqi	r4,r16,18687
81123ed4:	81123fe0 	cmpeqi	r4,r16,18687
81123ed8:	81123fe0 	cmpeqi	r4,r16,18687
81123edc:	81123fe0 	cmpeqi	r4,r16,18687
81123ee0:	81123fe0 	cmpeqi	r4,r16,18687
81123ee4:	81123f68 	cmpgeui	r4,r16,18685
81123ee8:	81123fe0 	cmpeqi	r4,r16,18687
81123eec:	81123fe0 	cmpeqi	r4,r16,18687
81123ef0:	81123fe0 	cmpeqi	r4,r16,18687
81123ef4:	81123fe0 	cmpeqi	r4,r16,18687
81123ef8:	81123fe0 	cmpeqi	r4,r16,18687
81123efc:	81123fe0 	cmpeqi	r4,r16,18687
81123f00:	81123fe0 	cmpeqi	r4,r16,18687
81123f04:	81123fe0 	cmpeqi	r4,r16,18687
81123f08:	81123fb0 	cmpltui	r4,r16,18686
81123f0c:	81123fb0 	cmpltui	r4,r16,18686
81123f10:	81123fb0 	cmpltui	r4,r16,18686
81123f14:	81123fb0 	cmpltui	r4,r16,18686
81123f18:	81123fb0 	cmpltui	r4,r16,18686
81123f1c:	81123fb0 	cmpltui	r4,r16,18686
81123f20:	81123fe0 	cmpeqi	r4,r16,18687
81123f24:	81123fe0 	cmpeqi	r4,r16,18687
81123f28:	81123fe0 	cmpeqi	r4,r16,18687
81123f2c:	81123fe0 	cmpeqi	r4,r16,18687
81123f30:	81123fe0 	cmpeqi	r4,r16,18687
81123f34:	81123fe0 	cmpeqi	r4,r16,18687
81123f38:	81123fe0 	cmpeqi	r4,r16,18687
81123f3c:	81123fe0 	cmpeqi	r4,r16,18687
81123f40:	81123fe0 	cmpeqi	r4,r16,18687
81123f44:	81123fe0 	cmpeqi	r4,r16,18687
81123f48:	81123fe0 	cmpeqi	r4,r16,18687
81123f4c:	81123fe0 	cmpeqi	r4,r16,18687
81123f50:	81123fe0 	cmpeqi	r4,r16,18687
81123f54:	81123fe0 	cmpeqi	r4,r16,18687
81123f58:	81123fe0 	cmpeqi	r4,r16,18687
81123f5c:	81123fe0 	cmpeqi	r4,r16,18687
81123f60:	81123fe0 	cmpeqi	r4,r16,18687
81123f64:	81123f68 	cmpgeui	r4,r16,18685
81123f68:	9081800c 	andi	r2,r18,1536
81123f6c:	12c01c1e 	bne	r2,r11,81123fe0 <__svfscanf_r+0x122c>
81123f70:	91a4703a 	and	r18,r18,r6
81123f74:	94814014 	ori	r18,r18,1280
81123f78:	04400404 	movi	r17,16
81123f7c:	81000005 	stb	r4,0(r16)
81123f80:	84000044 	addi	r16,r16,1
81123f84:	e0800117 	ldw	r2,4(fp)
81123f88:	10bfffc4 	addi	r2,r2,-1
81123f8c:	e0800115 	stw	r2,4(fp)
81123f90:	0080540e 	bge	zero,r2,811240e4 <__svfscanf_r+0x1330>
81123f94:	18c00044 	addi	r3,r3,1
81123f98:	e0c00015 	stw	r3,0(fp)
81123f9c:	9cffffc4 	addi	r19,r19,-1
81123fa0:	98000f26 	beq	r19,zero,81123fe0 <__svfscanf_r+0x122c>
81123fa4:	e0c00017 	ldw	r3,0(fp)
81123fa8:	19000003 	ldbu	r4,0(r3)
81123fac:	003f9706 	br	81123e0c <__reset+0xfb103e0c>
81123fb0:	00800284 	movi	r2,10
81123fb4:	14400a0e 	bge	r2,r17,81123fe0 <__svfscanf_r+0x122c>
81123fb8:	00bd1fc4 	movi	r2,-2945
81123fbc:	90a4703a 	and	r18,r18,r2
81123fc0:	003fee06 	br	81123f7c <__reset+0xfb103f7c>
81123fc4:	01604574 	movhi	r5,33045
81123fc8:	8c63883a 	add	r17,r17,r17
81123fcc:	2970cc84 	addi	r5,r5,-15566
81123fd0:	2c45883a 	add	r2,r5,r17
81123fd4:	1440000f 	ldh	r17,0(r2)
81123fd8:	00800204 	movi	r2,8
81123fdc:	147ff616 	blt	r2,r17,81123fb8 <__reset+0xfb103fb8>
81123fe0:	dc409e15 	stw	r17,632(sp)
81123fe4:	9023883a 	mov	r17,r18
81123fe8:	8880400c 	andi	r2,r17,256
81123fec:	4825883a 	mov	r18,r9
81123ff0:	10000426 	beq	r2,zero,81124004 <__svfscanf_r+0x1250>
81123ff4:	d9800104 	addi	r6,sp,4
81123ff8:	3400be36 	bltu	r6,r16,811242f4 <__svfscanf_r+0x1540>
81123ffc:	da000104 	addi	r8,sp,4
81124000:	443bae26 	beq	r8,r16,81122ebc <__reset+0xfb102ebc>
81124004:	8880040c 	andi	r2,r17,16
81124008:	10009326 	beq	r2,zero,81124258 <__svfscanf_r+0x14a4>
8112400c:	d8800104 	addi	r2,sp,4
81124010:	80a1c83a 	sub	r16,r16,r2
81124014:	8521883a 	add	r16,r16,r20
81124018:	003d0606 	br	81123434 <__reset+0xfb103434>
8112401c:	01604574 	movhi	r5,33045
81124020:	8c63883a 	add	r17,r17,r17
81124024:	2970cc84 	addi	r5,r5,-15566
81124028:	2c45883a 	add	r2,r5,r17
8112402c:	1440000f 	ldh	r17,0(r2)
81124030:	00bd1fc4 	movi	r2,-2945
81124034:	90a4703a 	and	r18,r18,r2
81124038:	003fd006 	br	81123f7c <__reset+0xfb103f7c>
8112403c:	9082000c 	andi	r2,r18,2048
81124040:	103fce26 	beq	r2,zero,81123f7c <__reset+0xfb103f7c>
81124044:	8800021e 	bne	r17,zero,81124050 <__svfscanf_r+0x129c>
81124048:	94808014 	ori	r18,r18,512
8112404c:	04400204 	movi	r17,8
81124050:	9081000c 	andi	r2,r18,1024
81124054:	10009426 	beq	r2,zero,811242a8 <__svfscanf_r+0x14f4>
81124058:	00be9fc4 	movi	r2,-1409
8112405c:	90a4703a 	and	r18,r18,r2
81124060:	003fc606 	br	81123f7c <__reset+0xfb103f7c>
81124064:	9080200c 	andi	r2,r18,128
81124068:	103fdd26 	beq	r2,zero,81123fe0 <__reset+0xfb103fe0>
8112406c:	9224703a 	and	r18,r18,r8
81124070:	003fc206 	br	81123f7c <__reset+0xfb103f7c>
81124074:	9800011e 	bne	r19,zero,8112407c <__svfscanf_r+0x12c8>
81124078:	04ffffc4 	movi	r19,-1
8112407c:	8900004c 	andi	r4,r17,1
81124080:	20005b1e 	bne	r4,zero,811241f0 <__svfscanf_r+0x143c>
81124084:	8c40040c 	andi	r17,r17,16
81124088:	88003026 	beq	r17,zero,8112414c <__svfscanf_r+0x1398>
8112408c:	0021883a 	mov	r16,zero
81124090:	00000306 	br	811240a0 <__svfscanf_r+0x12ec>
81124094:	18800003 	ldbu	r2,0(r3)
81124098:	3885883a 	add	r2,r7,r2
8112409c:	10800043 	ldbu	r2,1(r2)
811240a0:	1080020c 	andi	r2,r2,8
811240a4:	103ce31e 	bne	r2,zero,81123434 <__reset+0xfb103434>
811240a8:	e0800117 	ldw	r2,4(fp)
811240ac:	18c00044 	addi	r3,r3,1
811240b0:	84000044 	addi	r16,r16,1
811240b4:	10bfffc4 	addi	r2,r2,-1
811240b8:	e0800115 	stw	r2,4(fp)
811240bc:	e0c00015 	stw	r3,0(fp)
811240c0:	84fcdc26 	beq	r16,r19,81123434 <__reset+0xfb103434>
811240c4:	00bff316 	blt	zero,r2,81124094 <__reset+0xfb104094>
811240c8:	e00b883a 	mov	r5,fp
811240cc:	b009883a 	mov	r4,r22
811240d0:	111e0940 	call	8111e094 <__srefill_r>
811240d4:	103cd71e 	bne	r2,zero,81123434 <__reset+0xfb103434>
811240d8:	b9c00017 	ldw	r7,0(r23)
811240dc:	e0c00017 	ldw	r3,0(fp)
811240e0:	003fec06 	br	81124094 <__reset+0xfb104094>
811240e4:	e00b883a 	mov	r5,fp
811240e8:	b009883a 	mov	r4,r22
811240ec:	d980a715 	stw	r6,668(sp)
811240f0:	d9c0aa15 	stw	r7,680(sp)
811240f4:	da00a815 	stw	r8,672(sp)
811240f8:	da40a915 	stw	r9,676(sp)
811240fc:	dac0a615 	stw	r11,664(sp)
81124100:	111e0940 	call	8111e094 <__srefill_r>
81124104:	d980a717 	ldw	r6,668(sp)
81124108:	d9c0aa17 	ldw	r7,680(sp)
8112410c:	da00a817 	ldw	r8,672(sp)
81124110:	da40a917 	ldw	r9,676(sp)
81124114:	dac0a617 	ldw	r11,664(sp)
81124118:	103fa026 	beq	r2,zero,81123f9c <__reset+0xfb103f9c>
8112411c:	003fb006 	br	81123fe0 <__reset+0xfb103fe0>
81124120:	8821883a 	mov	r16,r17
81124124:	b019883a 	mov	r12,r22
81124128:	9823883a 	mov	r17,r19
8112412c:	182d883a 	mov	r22,r3
81124130:	00bfbfc4 	movi	r2,-257
81124134:	a0a8703a 	and	r20,r20,r2
81124138:	003e6706 	br	81123ad8 <__reset+0xfb103ad8>
8112413c:	000f883a 	mov	r7,zero
81124140:	003f2806 	br	81123de4 <__reset+0xfb103de4>
81124144:	d800a215 	stw	zero,648(sp)
81124148:	003de306 	br	811238d8 <__reset+0xfb1038d8>
8112414c:	da009c17 	ldw	r8,624(sp)
81124150:	9abfffc4 	addi	r10,r19,-1
81124154:	44400017 	ldw	r17,0(r8)
81124158:	44000104 	addi	r16,r8,4
8112415c:	880b883a 	mov	r5,r17
81124160:	8aa9883a 	add	r20,r17,r10
81124164:	00000606 	br	81124180 <__svfscanf_r+0x13cc>
81124168:	e0c00017 	ldw	r3,0(fp)
8112416c:	b9000017 	ldw	r4,0(r23)
81124170:	a80b883a 	mov	r5,r21
81124174:	18800003 	ldbu	r2,0(r3)
81124178:	2085883a 	add	r2,r4,r2
8112417c:	10800043 	ldbu	r2,1(r2)
81124180:	1080020c 	andi	r2,r2,8
81124184:	1000551e 	bne	r2,zero,811242dc <__svfscanf_r+0x1528>
81124188:	e0800117 	ldw	r2,4(fp)
8112418c:	19000044 	addi	r4,r3,1
81124190:	e1000015 	stw	r4,0(fp)
81124194:	10bfffc4 	addi	r2,r2,-1
81124198:	e0800115 	stw	r2,4(fp)
8112419c:	18800003 	ldbu	r2,0(r3)
811241a0:	2d400044 	addi	r21,r5,1
811241a4:	a827883a 	mov	r19,r21
811241a8:	28800005 	stb	r2,0(r5)
811241ac:	2d000626 	beq	r5,r20,811241c8 <__svfscanf_r+0x1414>
811241b0:	e0800117 	ldw	r2,4(fp)
811241b4:	00bfec16 	blt	zero,r2,81124168 <__reset+0xfb104168>
811241b8:	e00b883a 	mov	r5,fp
811241bc:	b009883a 	mov	r4,r22
811241c0:	111e0940 	call	8111e094 <__srefill_r>
811241c4:	103fe826 	beq	r2,zero,81124168 <__reset+0xfb104168>
811241c8:	da00a017 	ldw	r8,640(sp)
811241cc:	dd009d17 	ldw	r20,628(sp)
811241d0:	9c63c83a 	sub	r17,r19,r17
811241d4:	42000044 	addi	r8,r8,1
811241d8:	98000005 	stb	zero,0(r19)
811241dc:	9465883a 	add	r18,r18,r17
811241e0:	da00a015 	stw	r8,640(sp)
811241e4:	dc009c15 	stw	r16,624(sp)
811241e8:	a00d883a 	mov	r6,r20
811241ec:	003b2f06 	br	81122eac <__reset+0xfb102eac>
811241f0:	dd409904 	addi	r21,sp,612
811241f4:	8c40040c 	andi	r17,r17,16
811241f8:	01800204 	movi	r6,8
811241fc:	000b883a 	mov	r5,zero
81124200:	a809883a 	mov	r4,r21
81124204:	111dc180 	call	8111dc18 <memset>
81124208:	8800401e 	bne	r17,zero,8112430c <__svfscanf_r+0x1558>
8112420c:	da009c17 	ldw	r8,624(sp)
81124210:	45000017 	ldw	r20,0(r8)
81124214:	42000104 	addi	r8,r8,4
81124218:	da009c15 	stw	r8,624(sp)
8112421c:	000d883a 	mov	r6,zero
81124220:	3021883a 	mov	r16,r6
81124224:	dc409f15 	stw	r17,636(sp)
81124228:	e0800017 	ldw	r2,0(fp)
8112422c:	b8c00017 	ldw	r3,0(r23)
81124230:	10800003 	ldbu	r2,0(r2)
81124234:	1885883a 	add	r2,r3,r2
81124238:	10800043 	ldbu	r2,1(r2)
8112423c:	1080020c 	andi	r2,r2,8
81124240:	1000011e 	bne	r2,zero,81124248 <__svfscanf_r+0x1494>
81124244:	9800701e 	bne	r19,zero,81124408 <__svfscanf_r+0x1654>
81124248:	dc409f17 	ldw	r17,636(sp)
8112424c:	883cdd1e 	bne	r17,zero,811235c4 <__reset+0xfb1035c4>
81124250:	a0000015 	stw	zero,0(r20)
81124254:	003cd806 	br	811235b8 <__reset+0xfb1035b8>
81124258:	d9c09e17 	ldw	r7,632(sp)
8112425c:	da00a117 	ldw	r8,644(sp)
81124260:	000d883a 	mov	r6,zero
81124264:	d9400104 	addi	r5,sp,4
81124268:	b009883a 	mov	r4,r22
8112426c:	80000005 	stb	zero,0(r16)
81124270:	403ee83a 	callr	r8
81124274:	88c0080c 	andi	r3,r17,32
81124278:	1800121e 	bne	r3,zero,811242c4 <__svfscanf_r+0x1510>
8112427c:	88c0010c 	andi	r3,r17,4
81124280:	18004d26 	beq	r3,zero,811243b8 <__svfscanf_r+0x1604>
81124284:	da009c17 	ldw	r8,624(sp)
81124288:	40c00017 	ldw	r3,0(r8)
8112428c:	42000104 	addi	r8,r8,4
81124290:	da009c15 	stw	r8,624(sp)
81124294:	1880000d 	sth	r2,0(r3)
81124298:	da00a017 	ldw	r8,640(sp)
8112429c:	42000044 	addi	r8,r8,1
811242a0:	da00a015 	stw	r8,640(sp)
811242a4:	003f5906 	br	8112400c <__reset+0xfb10400c>
811242a8:	00bf1fc4 	movi	r2,-897
811242ac:	90a4703a 	and	r18,r18,r2
811242b0:	38000226 	beq	r7,zero,811242bc <__svfscanf_r+0x1508>
811242b4:	39ffffc4 	addi	r7,r7,-1
811242b8:	9cc00044 	addi	r19,r19,1
811242bc:	a5000044 	addi	r20,r20,1
811242c0:	003f3006 	br	81123f84 <__reset+0xfb103f84>
811242c4:	da009c17 	ldw	r8,624(sp)
811242c8:	40c00017 	ldw	r3,0(r8)
811242cc:	42000104 	addi	r8,r8,4
811242d0:	da009c15 	stw	r8,624(sp)
811242d4:	18800015 	stw	r2,0(r3)
811242d8:	003fef06 	br	81124298 <__reset+0xfb104298>
811242dc:	2827883a 	mov	r19,r5
811242e0:	003fb906 	br	811241c8 <__reset+0xfb1041c8>
811242e4:	01be1fc4 	movi	r6,-1921
811242e8:	a1a8703a 	and	r20,r20,r6
811242ec:	05400044 	movi	r21,1
811242f0:	003de906 	br	81123a98 <__reset+0xfb103a98>
811242f4:	817fffc7 	ldb	r5,-1(r16)
811242f8:	e00d883a 	mov	r6,fp
811242fc:	b009883a 	mov	r4,r22
81124300:	843fffc4 	addi	r16,r16,-1
81124304:	112ca0c0 	call	8112ca0c <_ungetc_r>
81124308:	003f3c06 	br	81123ffc <__reset+0xfb103ffc>
8112430c:	dd009b04 	addi	r20,sp,620
81124310:	003fc206 	br	8112421c <__reset+0xfb10421c>
81124314:	00be1fc4 	movi	r2,-1921
81124318:	a0a8703a 	and	r20,r20,r2
8112431c:	05800044 	movi	r22,1
81124320:	003ddd06 	br	81123a98 <__reset+0xfb103a98>
81124324:	d8c09f17 	ldw	r3,636(sp)
81124328:	88e3c83a 	sub	r17,r17,r3
8112432c:	044dc83a 	sub	r6,zero,r17
81124330:	883e2126 	beq	r17,zero,81123bb8 <__reset+0xfb103bb8>
81124334:	d88055c4 	addi	r2,sp,343
81124338:	80800136 	bltu	r16,r2,81124340 <__svfscanf_r+0x158c>
8112433c:	dc005584 	addi	r16,sp,342
81124340:	01604574 	movhi	r5,33045
81124344:	2970cb04 	addi	r5,r5,-15572
81124348:	8009883a 	mov	r4,r16
8112434c:	111e3a80 	call	8111e3a8 <sprintf>
81124350:	003e1906 	br	81123bb8 <__reset+0xfb103bb8>
81124354:	d8c0a517 	ldw	r3,660(sp)
81124358:	000d883a 	mov	r6,zero
8112435c:	01c00284 	movi	r7,10
81124360:	19400044 	addi	r5,r3,1
81124364:	b009883a 	mov	r4,r22
81124368:	111e6980 	call	8111e698 <_strtol_r>
8112436c:	da00a417 	ldw	r8,656(sp)
81124370:	dc00a517 	ldw	r16,660(sp)
81124374:	120dc83a 	sub	r6,r2,r8
81124378:	003fee06 	br	81124334 <__reset+0xfb104334>
8112437c:	da009c17 	ldw	r8,624(sp)
81124380:	180b883a 	mov	r5,r3
81124384:	8009883a 	mov	r4,r16
81124388:	45000017 	ldw	r20,0(r8)
8112438c:	44400104 	addi	r17,r8,4
81124390:	d8c0a615 	stw	r3,664(sp)
81124394:	11293280 	call	81129328 <__fpclassifyd>
81124398:	d8c0a617 	ldw	r3,664(sp)
8112439c:	10006426 	beq	r2,zero,81124530 <__svfscanf_r+0x177c>
811243a0:	8009883a 	mov	r4,r16
811243a4:	180b883a 	mov	r5,r3
811243a8:	111c6b00 	call	8111c6b0 <__truncdfsf2>
811243ac:	a0800015 	stw	r2,0(r20)
811243b0:	dc409c15 	stw	r17,624(sp)
811243b4:	003e0f06 	br	81123bf4 <__reset+0xfb103bf4>
811243b8:	88c0004c 	andi	r3,r17,1
811243bc:	183fc11e 	bne	r3,zero,811242c4 <__reset+0xfb1042c4>
811243c0:	8c40008c 	andi	r17,r17,2
811243c4:	883fbf26 	beq	r17,zero,811242c4 <__reset+0xfb1042c4>
811243c8:	da00a117 	ldw	r8,644(sp)
811243cc:	00a044f4 	movhi	r2,33043
811243d0:	10abf104 	addi	r2,r2,-20540
811243d4:	d9c09e17 	ldw	r7,632(sp)
811243d8:	000d883a 	mov	r6,zero
811243dc:	d9400104 	addi	r5,sp,4
811243e0:	b009883a 	mov	r4,r22
811243e4:	40806226 	beq	r8,r2,81124570 <__svfscanf_r+0x17bc>
811243e8:	112acdc0 	call	8112acdc <_strtoll_r>
811243ec:	da009c17 	ldw	r8,624(sp)
811243f0:	41000017 	ldw	r4,0(r8)
811243f4:	42000104 	addi	r8,r8,4
811243f8:	da009c15 	stw	r8,624(sp)
811243fc:	20800015 	stw	r2,0(r4)
81124400:	20c00115 	stw	r3,4(r4)
81124404:	003fa406 	br	81124298 <__reset+0xfb104298>
81124408:	11277b80 	call	811277b8 <__locale_mb_cur_max>
8112440c:	80bca726 	beq	r16,r2,811236ac <__reset+0xfb1036ac>
81124410:	e0800017 	ldw	r2,0(fp)
81124414:	e1000117 	ldw	r4,4(fp)
81124418:	d8c00104 	addi	r3,sp,4
8112441c:	12000003 	ldbu	r8,0(r2)
81124420:	213fffc4 	addi	r4,r4,-1
81124424:	10800044 	addi	r2,r2,1
81124428:	e1000115 	stw	r4,4(fp)
8112442c:	e0800015 	stw	r2,0(fp)
81124430:	84400044 	addi	r17,r16,1
81124434:	dd400015 	stw	r21,0(sp)
81124438:	1c21883a 	add	r16,r3,r16
8112443c:	b009883a 	mov	r4,r22
81124440:	880f883a 	mov	r7,r17
81124444:	180d883a 	mov	r6,r3
81124448:	a00b883a 	mov	r5,r20
8112444c:	82000005 	stb	r8,0(r16)
81124450:	11278740 	call	81127874 <_mbrtowc_r>
81124454:	013fffc4 	movi	r4,-1
81124458:	113c9426 	beq	r2,r4,811236ac <__reset+0xfb1036ac>
8112445c:	103c881e 	bne	r2,zero,81123680 <__reset+0xfb103680>
81124460:	a0000015 	stw	zero,0(r20)
81124464:	0009883a 	mov	r4,zero
81124468:	11276f80 	call	811276f8 <iswspace>
8112446c:	10001a26 	beq	r2,zero,811244d8 <__svfscanf_r+0x1724>
81124470:	8821883a 	mov	r16,r17
81124474:	dc409f17 	ldw	r17,636(sp)
81124478:	803f7426 	beq	r16,zero,8112424c <__reset+0xfb10424c>
8112447c:	843fffc4 	addi	r16,r16,-1
81124480:	d9800104 	addi	r6,sp,4
81124484:	342b883a 	add	r21,r6,r16
81124488:	00000106 	br	81124490 <__svfscanf_r+0x16dc>
8112448c:	843fffc4 	addi	r16,r16,-1
81124490:	a9400003 	ldbu	r5,0(r21)
81124494:	e00d883a 	mov	r6,fp
81124498:	b009883a 	mov	r4,r22
8112449c:	112ca0c0 	call	8112ca0c <_ungetc_r>
811244a0:	ad7fffc4 	addi	r21,r21,-1
811244a4:	803ff91e 	bne	r16,zero,8112448c <__reset+0xfb10448c>
811244a8:	003f6806 	br	8112424c <__reset+0xfb10424c>
811244ac:	d9800104 	addi	r6,sp,4
811244b0:	802b883a 	mov	r21,r16
811244b4:	343a812e 	bgeu	r6,r16,81122ebc <__reset+0xfb102ebc>
811244b8:	ad7fffc4 	addi	r21,r21,-1
811244bc:	a9400007 	ldb	r5,0(r21)
811244c0:	e00d883a 	mov	r6,fp
811244c4:	b009883a 	mov	r4,r22
811244c8:	112ca0c0 	call	8112ca0c <_ungetc_r>
811244cc:	da000104 	addi	r8,sp,4
811244d0:	457ff91e 	bne	r8,r21,811244b8 <__reset+0xfb1044b8>
811244d4:	003a7906 	br	81122ebc <__reset+0xfb102ebc>
811244d8:	da009f17 	ldw	r8,636(sp)
811244dc:	9465883a 	add	r18,r18,r17
811244e0:	9cffffc4 	addi	r19,r19,-1
811244e4:	4000051e 	bne	r8,zero,811244fc <__svfscanf_r+0x1748>
811244e8:	a5000104 	addi	r20,r20,4
811244ec:	0021883a 	mov	r16,zero
811244f0:	003c6606 	br	8112368c <__reset+0xfb10368c>
811244f4:	a1000017 	ldw	r4,0(r20)
811244f8:	003fdb06 	br	81124468 <__reset+0xfb104468>
811244fc:	0021883a 	mov	r16,zero
81124500:	003c6206 	br	8112368c <__reset+0xfb10368c>
81124504:	d8800104 	addi	r2,sp,4
81124508:	802b883a 	mov	r21,r16
8112450c:	143a6b2e 	bgeu	r2,r16,81122ebc <__reset+0xfb102ebc>
81124510:	ad7fffc4 	addi	r21,r21,-1
81124514:	a9400007 	ldb	r5,0(r21)
81124518:	e00d883a 	mov	r6,fp
8112451c:	b009883a 	mov	r4,r22
81124520:	112ca0c0 	call	8112ca0c <_ungetc_r>
81124524:	d8c00104 	addi	r3,sp,4
81124528:	1d7ff91e 	bne	r3,r21,81124510 <__reset+0xfb104510>
8112452c:	003a6306 	br	81122ebc <__reset+0xfb102ebc>
81124530:	0009883a 	mov	r4,zero
81124534:	112946c0 	call	8112946c <nanf>
81124538:	a0800015 	stw	r2,0(r20)
8112453c:	dc409c15 	stw	r17,624(sp)
81124540:	003dac06 	br	81123bf4 <__reset+0xfb103bf4>
81124544:	d9000104 	addi	r4,sp,4
81124548:	802b883a 	mov	r21,r16
8112454c:	243a5b2e 	bgeu	r4,r16,81122ebc <__reset+0xfb102ebc>
81124550:	ad7fffc4 	addi	r21,r21,-1
81124554:	a9400007 	ldb	r5,0(r21)
81124558:	e00d883a 	mov	r6,fp
8112455c:	b009883a 	mov	r4,r22
81124560:	112ca0c0 	call	8112ca0c <_ungetc_r>
81124564:	d9400104 	addi	r5,sp,4
81124568:	2d7ff91e 	bne	r5,r21,81124550 <__reset+0xfb104550>
8112456c:	003a5306 	br	81122ebc <__reset+0xfb102ebc>
81124570:	112b2340 	call	8112b234 <_strtoull_r>
81124574:	003f9d06 	br	811243ec <__reset+0xfb1043ec>

81124578 <vfscanf>:
81124578:	00a04574 	movhi	r2,33045
8112457c:	defffb04 	addi	sp,sp,-20
81124580:	10ba8204 	addi	r2,r2,-5624
81124584:	de00012e 	bgeu	sp,et,8112458c <vfscanf+0x14>
81124588:	003b68fa 	trap	3
8112458c:	dc000215 	stw	r16,8(sp)
81124590:	14000017 	ldw	r16,0(r2)
81124594:	dc400315 	stw	r17,12(sp)
81124598:	dfc00415 	stw	ra,16(sp)
8112459c:	2023883a 	mov	r17,r4
811245a0:	80000826 	beq	r16,zero,811245c4 <vfscanf+0x4c>
811245a4:	80800e17 	ldw	r2,56(r16)
811245a8:	1000061e 	bne	r2,zero,811245c4 <vfscanf+0x4c>
811245ac:	8009883a 	mov	r4,r16
811245b0:	d9400015 	stw	r5,0(sp)
811245b4:	d9800115 	stw	r6,4(sp)
811245b8:	11268900 	call	81126890 <__sinit>
811245bc:	d9800117 	ldw	r6,4(sp)
811245c0:	d9400017 	ldw	r5,0(sp)
811245c4:	300f883a 	mov	r7,r6
811245c8:	8009883a 	mov	r4,r16
811245cc:	280d883a 	mov	r6,r5
811245d0:	880b883a 	mov	r5,r17
811245d4:	dfc00417 	ldw	ra,16(sp)
811245d8:	dc400317 	ldw	r17,12(sp)
811245dc:	dc000217 	ldw	r16,8(sp)
811245e0:	dec00504 	addi	sp,sp,20
811245e4:	1122db41 	jmpi	81122db4 <__svfscanf_r>

811245e8 <__svfscanf>:
811245e8:	00a04574 	movhi	r2,33045
811245ec:	10ba8204 	addi	r2,r2,-5624
811245f0:	300f883a 	mov	r7,r6
811245f4:	280d883a 	mov	r6,r5
811245f8:	200b883a 	mov	r5,r4
811245fc:	11000017 	ldw	r4,0(r2)
81124600:	1122db41 	jmpi	81122db4 <__svfscanf_r>

81124604 <_vfscanf_r>:
81124604:	defffb04 	addi	sp,sp,-20
81124608:	de00012e 	bgeu	sp,et,81124610 <_vfscanf_r+0xc>
8112460c:	003b68fa 	trap	3
81124610:	dc000315 	stw	r16,12(sp)
81124614:	dfc00415 	stw	ra,16(sp)
81124618:	2021883a 	mov	r16,r4
8112461c:	20000926 	beq	r4,zero,81124644 <_vfscanf_r+0x40>
81124620:	20800e17 	ldw	r2,56(r4)
81124624:	1000071e 	bne	r2,zero,81124644 <_vfscanf_r+0x40>
81124628:	d9400015 	stw	r5,0(sp)
8112462c:	d9800115 	stw	r6,4(sp)
81124630:	d9c00215 	stw	r7,8(sp)
81124634:	11268900 	call	81126890 <__sinit>
81124638:	d9c00217 	ldw	r7,8(sp)
8112463c:	d9800117 	ldw	r6,4(sp)
81124640:	d9400017 	ldw	r5,0(sp)
81124644:	8009883a 	mov	r4,r16
81124648:	dfc00417 	ldw	ra,16(sp)
8112464c:	dc000317 	ldw	r16,12(sp)
81124650:	dec00504 	addi	sp,sp,20
81124654:	1122db41 	jmpi	81122db4 <__svfscanf_r>

81124658 <__swbuf_r>:
81124658:	defffb04 	addi	sp,sp,-20
8112465c:	de00012e 	bgeu	sp,et,81124664 <__swbuf_r+0xc>
81124660:	003b68fa 	trap	3
81124664:	dcc00315 	stw	r19,12(sp)
81124668:	dc800215 	stw	r18,8(sp)
8112466c:	dc000015 	stw	r16,0(sp)
81124670:	dfc00415 	stw	ra,16(sp)
81124674:	dc400115 	stw	r17,4(sp)
81124678:	2025883a 	mov	r18,r4
8112467c:	2827883a 	mov	r19,r5
81124680:	3021883a 	mov	r16,r6
81124684:	20000226 	beq	r4,zero,81124690 <__swbuf_r+0x38>
81124688:	20800e17 	ldw	r2,56(r4)
8112468c:	10004226 	beq	r2,zero,81124798 <__swbuf_r+0x140>
81124690:	80800617 	ldw	r2,24(r16)
81124694:	8100030b 	ldhu	r4,12(r16)
81124698:	80800215 	stw	r2,8(r16)
8112469c:	2080020c 	andi	r2,r4,8
811246a0:	10003626 	beq	r2,zero,8112477c <__swbuf_r+0x124>
811246a4:	80c00417 	ldw	r3,16(r16)
811246a8:	18003426 	beq	r3,zero,8112477c <__swbuf_r+0x124>
811246ac:	2088000c 	andi	r2,r4,8192
811246b0:	9c403fcc 	andi	r17,r19,255
811246b4:	10001a26 	beq	r2,zero,81124720 <__swbuf_r+0xc8>
811246b8:	80800017 	ldw	r2,0(r16)
811246bc:	81000517 	ldw	r4,20(r16)
811246c0:	10c7c83a 	sub	r3,r2,r3
811246c4:	1900200e 	bge	r3,r4,81124748 <__swbuf_r+0xf0>
811246c8:	18c00044 	addi	r3,r3,1
811246cc:	81000217 	ldw	r4,8(r16)
811246d0:	11400044 	addi	r5,r2,1
811246d4:	81400015 	stw	r5,0(r16)
811246d8:	213fffc4 	addi	r4,r4,-1
811246dc:	81000215 	stw	r4,8(r16)
811246e0:	14c00005 	stb	r19,0(r2)
811246e4:	80800517 	ldw	r2,20(r16)
811246e8:	10c01e26 	beq	r2,r3,81124764 <__swbuf_r+0x10c>
811246ec:	8080030b 	ldhu	r2,12(r16)
811246f0:	1080004c 	andi	r2,r2,1
811246f4:	10000226 	beq	r2,zero,81124700 <__swbuf_r+0xa8>
811246f8:	00800284 	movi	r2,10
811246fc:	88801926 	beq	r17,r2,81124764 <__swbuf_r+0x10c>
81124700:	8805883a 	mov	r2,r17
81124704:	dfc00417 	ldw	ra,16(sp)
81124708:	dcc00317 	ldw	r19,12(sp)
8112470c:	dc800217 	ldw	r18,8(sp)
81124710:	dc400117 	ldw	r17,4(sp)
81124714:	dc000017 	ldw	r16,0(sp)
81124718:	dec00504 	addi	sp,sp,20
8112471c:	f800283a 	ret
81124720:	81401917 	ldw	r5,100(r16)
81124724:	00b7ffc4 	movi	r2,-8193
81124728:	21080014 	ori	r4,r4,8192
8112472c:	2884703a 	and	r2,r5,r2
81124730:	80801915 	stw	r2,100(r16)
81124734:	80800017 	ldw	r2,0(r16)
81124738:	8100030d 	sth	r4,12(r16)
8112473c:	81000517 	ldw	r4,20(r16)
81124740:	10c7c83a 	sub	r3,r2,r3
81124744:	193fe016 	blt	r3,r4,811246c8 <__reset+0xfb1046c8>
81124748:	800b883a 	mov	r5,r16
8112474c:	9009883a 	mov	r4,r18
81124750:	11264940 	call	81126494 <_fflush_r>
81124754:	1000071e 	bne	r2,zero,81124774 <__swbuf_r+0x11c>
81124758:	80800017 	ldw	r2,0(r16)
8112475c:	00c00044 	movi	r3,1
81124760:	003fda06 	br	811246cc <__reset+0xfb1046cc>
81124764:	800b883a 	mov	r5,r16
81124768:	9009883a 	mov	r4,r18
8112476c:	11264940 	call	81126494 <_fflush_r>
81124770:	103fe326 	beq	r2,zero,81124700 <__reset+0xfb104700>
81124774:	00bfffc4 	movi	r2,-1
81124778:	003fe206 	br	81124704 <__reset+0xfb104704>
8112477c:	800b883a 	mov	r5,r16
81124780:	9009883a 	mov	r4,r18
81124784:	11248200 	call	81124820 <__swsetup_r>
81124788:	103ffa1e 	bne	r2,zero,81124774 <__reset+0xfb104774>
8112478c:	8100030b 	ldhu	r4,12(r16)
81124790:	80c00417 	ldw	r3,16(r16)
81124794:	003fc506 	br	811246ac <__reset+0xfb1046ac>
81124798:	11268900 	call	81126890 <__sinit>
8112479c:	003fbc06 	br	81124690 <__reset+0xfb104690>

811247a0 <__swbuf>:
811247a0:	00a04574 	movhi	r2,33045
811247a4:	10ba8204 	addi	r2,r2,-5624
811247a8:	280d883a 	mov	r6,r5
811247ac:	200b883a 	mov	r5,r4
811247b0:	11000017 	ldw	r4,0(r2)
811247b4:	11246581 	jmpi	81124658 <__swbuf_r>

811247b8 <_write_r>:
811247b8:	defffd04 	addi	sp,sp,-12
811247bc:	de00012e 	bgeu	sp,et,811247c4 <_write_r+0xc>
811247c0:	003b68fa 	trap	3
811247c4:	2805883a 	mov	r2,r5
811247c8:	dc000015 	stw	r16,0(sp)
811247cc:	04204574 	movhi	r16,33045
811247d0:	dc400115 	stw	r17,4(sp)
811247d4:	300b883a 	mov	r5,r6
811247d8:	843af104 	addi	r16,r16,-5180
811247dc:	2023883a 	mov	r17,r4
811247e0:	380d883a 	mov	r6,r7
811247e4:	1009883a 	mov	r4,r2
811247e8:	dfc00215 	stw	ra,8(sp)
811247ec:	80000015 	stw	zero,0(r16)
811247f0:	1133e700 	call	81133e70 <write>
811247f4:	00ffffc4 	movi	r3,-1
811247f8:	10c00526 	beq	r2,r3,81124810 <_write_r+0x58>
811247fc:	dfc00217 	ldw	ra,8(sp)
81124800:	dc400117 	ldw	r17,4(sp)
81124804:	dc000017 	ldw	r16,0(sp)
81124808:	dec00304 	addi	sp,sp,12
8112480c:	f800283a 	ret
81124810:	80c00017 	ldw	r3,0(r16)
81124814:	183ff926 	beq	r3,zero,811247fc <__reset+0xfb1047fc>
81124818:	88c00015 	stw	r3,0(r17)
8112481c:	003ff706 	br	811247fc <__reset+0xfb1047fc>

81124820 <__swsetup_r>:
81124820:	00a04574 	movhi	r2,33045
81124824:	defffd04 	addi	sp,sp,-12
81124828:	10ba8204 	addi	r2,r2,-5624
8112482c:	de00012e 	bgeu	sp,et,81124834 <__swsetup_r+0x14>
81124830:	003b68fa 	trap	3
81124834:	dc400115 	stw	r17,4(sp)
81124838:	2023883a 	mov	r17,r4
8112483c:	11000017 	ldw	r4,0(r2)
81124840:	dc000015 	stw	r16,0(sp)
81124844:	dfc00215 	stw	ra,8(sp)
81124848:	2821883a 	mov	r16,r5
8112484c:	20000226 	beq	r4,zero,81124858 <__swsetup_r+0x38>
81124850:	20800e17 	ldw	r2,56(r4)
81124854:	10003126 	beq	r2,zero,8112491c <__swsetup_r+0xfc>
81124858:	8080030b 	ldhu	r2,12(r16)
8112485c:	10c0020c 	andi	r3,r2,8
81124860:	1009883a 	mov	r4,r2
81124864:	18000f26 	beq	r3,zero,811248a4 <__swsetup_r+0x84>
81124868:	80c00417 	ldw	r3,16(r16)
8112486c:	18001526 	beq	r3,zero,811248c4 <__swsetup_r+0xa4>
81124870:	1100004c 	andi	r4,r2,1
81124874:	20001c1e 	bne	r4,zero,811248e8 <__swsetup_r+0xc8>
81124878:	1080008c 	andi	r2,r2,2
8112487c:	1000291e 	bne	r2,zero,81124924 <__swsetup_r+0x104>
81124880:	80800517 	ldw	r2,20(r16)
81124884:	80800215 	stw	r2,8(r16)
81124888:	18001c26 	beq	r3,zero,811248fc <__swsetup_r+0xdc>
8112488c:	0005883a 	mov	r2,zero
81124890:	dfc00217 	ldw	ra,8(sp)
81124894:	dc400117 	ldw	r17,4(sp)
81124898:	dc000017 	ldw	r16,0(sp)
8112489c:	dec00304 	addi	sp,sp,12
811248a0:	f800283a 	ret
811248a4:	2080040c 	andi	r2,r4,16
811248a8:	10002e26 	beq	r2,zero,81124964 <__swsetup_r+0x144>
811248ac:	2080010c 	andi	r2,r4,4
811248b0:	10001e1e 	bne	r2,zero,8112492c <__swsetup_r+0x10c>
811248b4:	80c00417 	ldw	r3,16(r16)
811248b8:	20800214 	ori	r2,r4,8
811248bc:	8080030d 	sth	r2,12(r16)
811248c0:	183feb1e 	bne	r3,zero,81124870 <__reset+0xfb104870>
811248c4:	1100a00c 	andi	r4,r2,640
811248c8:	01408004 	movi	r5,512
811248cc:	217fe826 	beq	r4,r5,81124870 <__reset+0xfb104870>
811248d0:	800b883a 	mov	r5,r16
811248d4:	8809883a 	mov	r4,r17
811248d8:	111d0f00 	call	8111d0f0 <__smakebuf_r>
811248dc:	8080030b 	ldhu	r2,12(r16)
811248e0:	80c00417 	ldw	r3,16(r16)
811248e4:	003fe206 	br	81124870 <__reset+0xfb104870>
811248e8:	80800517 	ldw	r2,20(r16)
811248ec:	80000215 	stw	zero,8(r16)
811248f0:	0085c83a 	sub	r2,zero,r2
811248f4:	80800615 	stw	r2,24(r16)
811248f8:	183fe41e 	bne	r3,zero,8112488c <__reset+0xfb10488c>
811248fc:	80c0030b 	ldhu	r3,12(r16)
81124900:	0005883a 	mov	r2,zero
81124904:	1900200c 	andi	r4,r3,128
81124908:	203fe126 	beq	r4,zero,81124890 <__reset+0xfb104890>
8112490c:	18c01014 	ori	r3,r3,64
81124910:	80c0030d 	sth	r3,12(r16)
81124914:	00bfffc4 	movi	r2,-1
81124918:	003fdd06 	br	81124890 <__reset+0xfb104890>
8112491c:	11268900 	call	81126890 <__sinit>
81124920:	003fcd06 	br	81124858 <__reset+0xfb104858>
81124924:	0005883a 	mov	r2,zero
81124928:	003fd606 	br	81124884 <__reset+0xfb104884>
8112492c:	81400c17 	ldw	r5,48(r16)
81124930:	28000626 	beq	r5,zero,8112494c <__swsetup_r+0x12c>
81124934:	80801004 	addi	r2,r16,64
81124938:	28800326 	beq	r5,r2,81124948 <__swsetup_r+0x128>
8112493c:	8809883a 	mov	r4,r17
81124940:	1126d280 	call	81126d28 <_free_r>
81124944:	8100030b 	ldhu	r4,12(r16)
81124948:	80000c15 	stw	zero,48(r16)
8112494c:	80c00417 	ldw	r3,16(r16)
81124950:	00bff6c4 	movi	r2,-37
81124954:	1108703a 	and	r4,r2,r4
81124958:	80000115 	stw	zero,4(r16)
8112495c:	80c00015 	stw	r3,0(r16)
81124960:	003fd506 	br	811248b8 <__reset+0xfb1048b8>
81124964:	00800244 	movi	r2,9
81124968:	88800015 	stw	r2,0(r17)
8112496c:	20801014 	ori	r2,r4,64
81124970:	8080030d 	sth	r2,12(r16)
81124974:	00bfffc4 	movi	r2,-1
81124978:	003fc506 	br	81124890 <__reset+0xfb104890>

8112497c <_close_r>:
8112497c:	defffd04 	addi	sp,sp,-12
81124980:	de00012e 	bgeu	sp,et,81124988 <_close_r+0xc>
81124984:	003b68fa 	trap	3
81124988:	dc000015 	stw	r16,0(sp)
8112498c:	04204574 	movhi	r16,33045
81124990:	dc400115 	stw	r17,4(sp)
81124994:	843af104 	addi	r16,r16,-5180
81124998:	2023883a 	mov	r17,r4
8112499c:	2809883a 	mov	r4,r5
811249a0:	dfc00215 	stw	ra,8(sp)
811249a4:	80000015 	stw	zero,0(r16)
811249a8:	11323f00 	call	811323f0 <close>
811249ac:	00ffffc4 	movi	r3,-1
811249b0:	10c00526 	beq	r2,r3,811249c8 <_close_r+0x4c>
811249b4:	dfc00217 	ldw	ra,8(sp)
811249b8:	dc400117 	ldw	r17,4(sp)
811249bc:	dc000017 	ldw	r16,0(sp)
811249c0:	dec00304 	addi	sp,sp,12
811249c4:	f800283a 	ret
811249c8:	80c00017 	ldw	r3,0(r16)
811249cc:	183ff926 	beq	r3,zero,811249b4 <__reset+0xfb1049b4>
811249d0:	88c00015 	stw	r3,0(r17)
811249d4:	003ff706 	br	811249b4 <__reset+0xfb1049b4>

811249d8 <quorem>:
811249d8:	defff704 	addi	sp,sp,-36
811249dc:	de00012e 	bgeu	sp,et,811249e4 <quorem+0xc>
811249e0:	003b68fa 	trap	3
811249e4:	dc800215 	stw	r18,8(sp)
811249e8:	20800417 	ldw	r2,16(r4)
811249ec:	2c800417 	ldw	r18,16(r5)
811249f0:	dfc00815 	stw	ra,32(sp)
811249f4:	ddc00715 	stw	r23,28(sp)
811249f8:	dd800615 	stw	r22,24(sp)
811249fc:	dd400515 	stw	r21,20(sp)
81124a00:	dd000415 	stw	r20,16(sp)
81124a04:	dcc00315 	stw	r19,12(sp)
81124a08:	dc400115 	stw	r17,4(sp)
81124a0c:	dc000015 	stw	r16,0(sp)
81124a10:	14807116 	blt	r2,r18,81124bd8 <quorem+0x200>
81124a14:	94bfffc4 	addi	r18,r18,-1
81124a18:	94ad883a 	add	r22,r18,r18
81124a1c:	b5ad883a 	add	r22,r22,r22
81124a20:	2c400504 	addi	r17,r5,20
81124a24:	8da9883a 	add	r20,r17,r22
81124a28:	25400504 	addi	r21,r4,20
81124a2c:	282f883a 	mov	r23,r5
81124a30:	adad883a 	add	r22,r21,r22
81124a34:	a1400017 	ldw	r5,0(r20)
81124a38:	2021883a 	mov	r16,r4
81124a3c:	b1000017 	ldw	r4,0(r22)
81124a40:	29400044 	addi	r5,r5,1
81124a44:	11300b00 	call	811300b0 <__udivsi3>
81124a48:	1027883a 	mov	r19,r2
81124a4c:	10002c26 	beq	r2,zero,81124b00 <quorem+0x128>
81124a50:	a813883a 	mov	r9,r21
81124a54:	880b883a 	mov	r5,r17
81124a58:	0009883a 	mov	r4,zero
81124a5c:	000d883a 	mov	r6,zero
81124a60:	2a000017 	ldw	r8,0(r5)
81124a64:	49c00017 	ldw	r7,0(r9)
81124a68:	29400104 	addi	r5,r5,4
81124a6c:	40bfffcc 	andi	r2,r8,65535
81124a70:	14c5383a 	mul	r2,r2,r19
81124a74:	4010d43a 	srli	r8,r8,16
81124a78:	38ffffcc 	andi	r3,r7,65535
81124a7c:	1105883a 	add	r2,r2,r4
81124a80:	1008d43a 	srli	r4,r2,16
81124a84:	44d1383a 	mul	r8,r8,r19
81124a88:	198d883a 	add	r6,r3,r6
81124a8c:	10ffffcc 	andi	r3,r2,65535
81124a90:	30c7c83a 	sub	r3,r6,r3
81124a94:	380ed43a 	srli	r7,r7,16
81124a98:	4105883a 	add	r2,r8,r4
81124a9c:	180dd43a 	srai	r6,r3,16
81124aa0:	113fffcc 	andi	r4,r2,65535
81124aa4:	390fc83a 	sub	r7,r7,r4
81124aa8:	398d883a 	add	r6,r7,r6
81124aac:	300e943a 	slli	r7,r6,16
81124ab0:	18ffffcc 	andi	r3,r3,65535
81124ab4:	1008d43a 	srli	r4,r2,16
81124ab8:	38ceb03a 	or	r7,r7,r3
81124abc:	49c00015 	stw	r7,0(r9)
81124ac0:	300dd43a 	srai	r6,r6,16
81124ac4:	4a400104 	addi	r9,r9,4
81124ac8:	a17fe52e 	bgeu	r20,r5,81124a60 <__reset+0xfb104a60>
81124acc:	b0800017 	ldw	r2,0(r22)
81124ad0:	10000b1e 	bne	r2,zero,81124b00 <quorem+0x128>
81124ad4:	b0bfff04 	addi	r2,r22,-4
81124ad8:	a880082e 	bgeu	r21,r2,81124afc <quorem+0x124>
81124adc:	b0ffff17 	ldw	r3,-4(r22)
81124ae0:	18000326 	beq	r3,zero,81124af0 <quorem+0x118>
81124ae4:	00000506 	br	81124afc <quorem+0x124>
81124ae8:	10c00017 	ldw	r3,0(r2)
81124aec:	1800031e 	bne	r3,zero,81124afc <quorem+0x124>
81124af0:	10bfff04 	addi	r2,r2,-4
81124af4:	94bfffc4 	addi	r18,r18,-1
81124af8:	a8bffb36 	bltu	r21,r2,81124ae8 <__reset+0xfb104ae8>
81124afc:	84800415 	stw	r18,16(r16)
81124b00:	b80b883a 	mov	r5,r23
81124b04:	8009883a 	mov	r4,r16
81124b08:	11285f80 	call	811285f8 <__mcmp>
81124b0c:	10002616 	blt	r2,zero,81124ba8 <quorem+0x1d0>
81124b10:	9cc00044 	addi	r19,r19,1
81124b14:	a805883a 	mov	r2,r21
81124b18:	000b883a 	mov	r5,zero
81124b1c:	11000017 	ldw	r4,0(r2)
81124b20:	89800017 	ldw	r6,0(r17)
81124b24:	10800104 	addi	r2,r2,4
81124b28:	20ffffcc 	andi	r3,r4,65535
81124b2c:	194b883a 	add	r5,r3,r5
81124b30:	30ffffcc 	andi	r3,r6,65535
81124b34:	28c7c83a 	sub	r3,r5,r3
81124b38:	300cd43a 	srli	r6,r6,16
81124b3c:	2008d43a 	srli	r4,r4,16
81124b40:	180bd43a 	srai	r5,r3,16
81124b44:	18ffffcc 	andi	r3,r3,65535
81124b48:	2189c83a 	sub	r4,r4,r6
81124b4c:	2149883a 	add	r4,r4,r5
81124b50:	200c943a 	slli	r6,r4,16
81124b54:	8c400104 	addi	r17,r17,4
81124b58:	200bd43a 	srai	r5,r4,16
81124b5c:	30c6b03a 	or	r3,r6,r3
81124b60:	10ffff15 	stw	r3,-4(r2)
81124b64:	a47fed2e 	bgeu	r20,r17,81124b1c <__reset+0xfb104b1c>
81124b68:	9485883a 	add	r2,r18,r18
81124b6c:	1085883a 	add	r2,r2,r2
81124b70:	a887883a 	add	r3,r21,r2
81124b74:	18800017 	ldw	r2,0(r3)
81124b78:	10000b1e 	bne	r2,zero,81124ba8 <quorem+0x1d0>
81124b7c:	18bfff04 	addi	r2,r3,-4
81124b80:	a880082e 	bgeu	r21,r2,81124ba4 <quorem+0x1cc>
81124b84:	18ffff17 	ldw	r3,-4(r3)
81124b88:	18000326 	beq	r3,zero,81124b98 <quorem+0x1c0>
81124b8c:	00000506 	br	81124ba4 <quorem+0x1cc>
81124b90:	10c00017 	ldw	r3,0(r2)
81124b94:	1800031e 	bne	r3,zero,81124ba4 <quorem+0x1cc>
81124b98:	10bfff04 	addi	r2,r2,-4
81124b9c:	94bfffc4 	addi	r18,r18,-1
81124ba0:	a8bffb36 	bltu	r21,r2,81124b90 <__reset+0xfb104b90>
81124ba4:	84800415 	stw	r18,16(r16)
81124ba8:	9805883a 	mov	r2,r19
81124bac:	dfc00817 	ldw	ra,32(sp)
81124bb0:	ddc00717 	ldw	r23,28(sp)
81124bb4:	dd800617 	ldw	r22,24(sp)
81124bb8:	dd400517 	ldw	r21,20(sp)
81124bbc:	dd000417 	ldw	r20,16(sp)
81124bc0:	dcc00317 	ldw	r19,12(sp)
81124bc4:	dc800217 	ldw	r18,8(sp)
81124bc8:	dc400117 	ldw	r17,4(sp)
81124bcc:	dc000017 	ldw	r16,0(sp)
81124bd0:	dec00904 	addi	sp,sp,36
81124bd4:	f800283a 	ret
81124bd8:	0005883a 	mov	r2,zero
81124bdc:	003ff306 	br	81124bac <__reset+0xfb104bac>

81124be0 <_dtoa_r>:
81124be0:	deffde04 	addi	sp,sp,-136
81124be4:	de00012e 	bgeu	sp,et,81124bec <_dtoa_r+0xc>
81124be8:	003b68fa 	trap	3
81124bec:	20801017 	ldw	r2,64(r4)
81124bf0:	df002015 	stw	fp,128(sp)
81124bf4:	dcc01b15 	stw	r19,108(sp)
81124bf8:	dc801a15 	stw	r18,104(sp)
81124bfc:	dc401915 	stw	r17,100(sp)
81124c00:	dc001815 	stw	r16,96(sp)
81124c04:	dfc02115 	stw	ra,132(sp)
81124c08:	ddc01f15 	stw	r23,124(sp)
81124c0c:	dd801e15 	stw	r22,120(sp)
81124c10:	dd401d15 	stw	r21,116(sp)
81124c14:	dd001c15 	stw	r20,112(sp)
81124c18:	d9c00315 	stw	r7,12(sp)
81124c1c:	2039883a 	mov	fp,r4
81124c20:	3023883a 	mov	r17,r6
81124c24:	2825883a 	mov	r18,r5
81124c28:	dc002417 	ldw	r16,144(sp)
81124c2c:	3027883a 	mov	r19,r6
81124c30:	10000826 	beq	r2,zero,81124c54 <_dtoa_r+0x74>
81124c34:	21801117 	ldw	r6,68(r4)
81124c38:	00c00044 	movi	r3,1
81124c3c:	100b883a 	mov	r5,r2
81124c40:	1986983a 	sll	r3,r3,r6
81124c44:	11800115 	stw	r6,4(r2)
81124c48:	10c00215 	stw	r3,8(r2)
81124c4c:	1127da80 	call	81127da8 <_Bfree>
81124c50:	e0001015 	stw	zero,64(fp)
81124c54:	88002e16 	blt	r17,zero,81124d10 <_dtoa_r+0x130>
81124c58:	80000015 	stw	zero,0(r16)
81124c5c:	889ffc2c 	andhi	r2,r17,32752
81124c60:	00dffc34 	movhi	r3,32752
81124c64:	10c01c26 	beq	r2,r3,81124cd8 <_dtoa_r+0xf8>
81124c68:	000d883a 	mov	r6,zero
81124c6c:	000f883a 	mov	r7,zero
81124c70:	9009883a 	mov	r4,r18
81124c74:	980b883a 	mov	r5,r19
81124c78:	113150c0 	call	8113150c <__eqdf2>
81124c7c:	10002b1e 	bne	r2,zero,81124d2c <_dtoa_r+0x14c>
81124c80:	d9c02317 	ldw	r7,140(sp)
81124c84:	00800044 	movi	r2,1
81124c88:	38800015 	stw	r2,0(r7)
81124c8c:	d8802517 	ldw	r2,148(sp)
81124c90:	10019e26 	beq	r2,zero,8112530c <_dtoa_r+0x72c>
81124c94:	d8c02517 	ldw	r3,148(sp)
81124c98:	00a04574 	movhi	r2,33045
81124c9c:	10b0ba44 	addi	r2,r2,-15639
81124ca0:	18800015 	stw	r2,0(r3)
81124ca4:	10bfffc4 	addi	r2,r2,-1
81124ca8:	dfc02117 	ldw	ra,132(sp)
81124cac:	df002017 	ldw	fp,128(sp)
81124cb0:	ddc01f17 	ldw	r23,124(sp)
81124cb4:	dd801e17 	ldw	r22,120(sp)
81124cb8:	dd401d17 	ldw	r21,116(sp)
81124cbc:	dd001c17 	ldw	r20,112(sp)
81124cc0:	dcc01b17 	ldw	r19,108(sp)
81124cc4:	dc801a17 	ldw	r18,104(sp)
81124cc8:	dc401917 	ldw	r17,100(sp)
81124ccc:	dc001817 	ldw	r16,96(sp)
81124cd0:	dec02204 	addi	sp,sp,136
81124cd4:	f800283a 	ret
81124cd8:	d8c02317 	ldw	r3,140(sp)
81124cdc:	0089c3c4 	movi	r2,9999
81124ce0:	18800015 	stw	r2,0(r3)
81124ce4:	90017726 	beq	r18,zero,811252c4 <_dtoa_r+0x6e4>
81124ce8:	00a04574 	movhi	r2,33045
81124cec:	10b0d804 	addi	r2,r2,-15520
81124cf0:	d9002517 	ldw	r4,148(sp)
81124cf4:	203fec26 	beq	r4,zero,81124ca8 <__reset+0xfb104ca8>
81124cf8:	10c000c7 	ldb	r3,3(r2)
81124cfc:	1801781e 	bne	r3,zero,811252e0 <_dtoa_r+0x700>
81124d00:	10c000c4 	addi	r3,r2,3
81124d04:	d9802517 	ldw	r6,148(sp)
81124d08:	30c00015 	stw	r3,0(r6)
81124d0c:	003fe606 	br	81124ca8 <__reset+0xfb104ca8>
81124d10:	04e00034 	movhi	r19,32768
81124d14:	9cffffc4 	addi	r19,r19,-1
81124d18:	00800044 	movi	r2,1
81124d1c:	8ce6703a 	and	r19,r17,r19
81124d20:	80800015 	stw	r2,0(r16)
81124d24:	9823883a 	mov	r17,r19
81124d28:	003fcc06 	br	81124c5c <__reset+0xfb104c5c>
81124d2c:	d8800204 	addi	r2,sp,8
81124d30:	d8800015 	stw	r2,0(sp)
81124d34:	d9c00104 	addi	r7,sp,4
81124d38:	900b883a 	mov	r5,r18
81124d3c:	980d883a 	mov	r6,r19
81124d40:	e009883a 	mov	r4,fp
81124d44:	8820d53a 	srli	r16,r17,20
81124d48:	11289d40 	call	811289d4 <__d2b>
81124d4c:	d8800915 	stw	r2,36(sp)
81124d50:	8001651e 	bne	r16,zero,811252e8 <_dtoa_r+0x708>
81124d54:	dd800217 	ldw	r22,8(sp)
81124d58:	dc000117 	ldw	r16,4(sp)
81124d5c:	00800804 	movi	r2,32
81124d60:	b421883a 	add	r16,r22,r16
81124d64:	80c10c84 	addi	r3,r16,1074
81124d68:	10c2d10e 	bge	r2,r3,811258b0 <_dtoa_r+0xcd0>
81124d6c:	00801004 	movi	r2,64
81124d70:	81010484 	addi	r4,r16,1042
81124d74:	10c7c83a 	sub	r3,r2,r3
81124d78:	9108d83a 	srl	r4,r18,r4
81124d7c:	88e2983a 	sll	r17,r17,r3
81124d80:	2448b03a 	or	r4,r4,r17
81124d84:	11321cc0 	call	811321cc <__floatunsidf>
81124d88:	017f8434 	movhi	r5,65040
81124d8c:	01800044 	movi	r6,1
81124d90:	1009883a 	mov	r4,r2
81124d94:	194b883a 	add	r5,r3,r5
81124d98:	843fffc4 	addi	r16,r16,-1
81124d9c:	d9801115 	stw	r6,68(sp)
81124da0:	000d883a 	mov	r6,zero
81124da4:	01cffe34 	movhi	r7,16376
81124da8:	11317640 	call	81131764 <__subdf3>
81124dac:	0198dbf4 	movhi	r6,25455
81124db0:	01cff4f4 	movhi	r7,16339
81124db4:	3190d844 	addi	r6,r6,17249
81124db8:	39e1e9c4 	addi	r7,r7,-30809
81124dbc:	1009883a 	mov	r4,r2
81124dc0:	180b883a 	mov	r5,r3
81124dc4:	111be780 	call	8111be78 <__muldf3>
81124dc8:	01a2d874 	movhi	r6,35681
81124dcc:	01cff1f4 	movhi	r7,16327
81124dd0:	31b22cc4 	addi	r6,r6,-14157
81124dd4:	39e28a04 	addi	r7,r7,-30168
81124dd8:	180b883a 	mov	r5,r3
81124ddc:	1009883a 	mov	r4,r2
81124de0:	11303680 	call	81130368 <__adddf3>
81124de4:	8009883a 	mov	r4,r16
81124de8:	1029883a 	mov	r20,r2
81124dec:	1823883a 	mov	r17,r3
81124df0:	11320e80 	call	811320e8 <__floatsidf>
81124df4:	019427f4 	movhi	r6,20639
81124df8:	01cff4f4 	movhi	r7,16339
81124dfc:	319e7ec4 	addi	r6,r6,31227
81124e00:	39d104c4 	addi	r7,r7,17427
81124e04:	1009883a 	mov	r4,r2
81124e08:	180b883a 	mov	r5,r3
81124e0c:	111be780 	call	8111be78 <__muldf3>
81124e10:	100d883a 	mov	r6,r2
81124e14:	180f883a 	mov	r7,r3
81124e18:	a009883a 	mov	r4,r20
81124e1c:	880b883a 	mov	r5,r17
81124e20:	11303680 	call	81130368 <__adddf3>
81124e24:	1009883a 	mov	r4,r2
81124e28:	180b883a 	mov	r5,r3
81124e2c:	1029883a 	mov	r20,r2
81124e30:	1823883a 	mov	r17,r3
81124e34:	11320680 	call	81132068 <__fixdfsi>
81124e38:	000d883a 	mov	r6,zero
81124e3c:	000f883a 	mov	r7,zero
81124e40:	a009883a 	mov	r4,r20
81124e44:	880b883a 	mov	r5,r17
81124e48:	d8800515 	stw	r2,20(sp)
81124e4c:	11316700 	call	81131670 <__ledf2>
81124e50:	10028716 	blt	r2,zero,81125870 <_dtoa_r+0xc90>
81124e54:	d8c00517 	ldw	r3,20(sp)
81124e58:	00800584 	movi	r2,22
81124e5c:	10c27536 	bltu	r2,r3,81125834 <_dtoa_r+0xc54>
81124e60:	180490fa 	slli	r2,r3,3
81124e64:	00e04574 	movhi	r3,33045
81124e68:	18f0f304 	addi	r3,r3,-15412
81124e6c:	1885883a 	add	r2,r3,r2
81124e70:	11000017 	ldw	r4,0(r2)
81124e74:	11400117 	ldw	r5,4(r2)
81124e78:	900d883a 	mov	r6,r18
81124e7c:	980f883a 	mov	r7,r19
81124e80:	11315940 	call	81131594 <__gedf2>
81124e84:	00828d0e 	bge	zero,r2,811258bc <_dtoa_r+0xcdc>
81124e88:	d9000517 	ldw	r4,20(sp)
81124e8c:	d8000e15 	stw	zero,56(sp)
81124e90:	213fffc4 	addi	r4,r4,-1
81124e94:	d9000515 	stw	r4,20(sp)
81124e98:	b42dc83a 	sub	r22,r22,r16
81124e9c:	b5bfffc4 	addi	r22,r22,-1
81124ea0:	b0026f16 	blt	r22,zero,81125860 <_dtoa_r+0xc80>
81124ea4:	d8000815 	stw	zero,32(sp)
81124ea8:	d9c00517 	ldw	r7,20(sp)
81124eac:	38026416 	blt	r7,zero,81125840 <_dtoa_r+0xc60>
81124eb0:	b1ed883a 	add	r22,r22,r7
81124eb4:	d9c00d15 	stw	r7,52(sp)
81124eb8:	d8000a15 	stw	zero,40(sp)
81124ebc:	d9800317 	ldw	r6,12(sp)
81124ec0:	00800244 	movi	r2,9
81124ec4:	11811436 	bltu	r2,r6,81125318 <_dtoa_r+0x738>
81124ec8:	00800144 	movi	r2,5
81124ecc:	1184e10e 	bge	r2,r6,81126254 <_dtoa_r+0x1674>
81124ed0:	31bfff04 	addi	r6,r6,-4
81124ed4:	d9800315 	stw	r6,12(sp)
81124ed8:	0023883a 	mov	r17,zero
81124edc:	d9800317 	ldw	r6,12(sp)
81124ee0:	008000c4 	movi	r2,3
81124ee4:	30836726 	beq	r6,r2,81125c84 <_dtoa_r+0x10a4>
81124ee8:	1183410e 	bge	r2,r6,81125bf0 <_dtoa_r+0x1010>
81124eec:	d9c00317 	ldw	r7,12(sp)
81124ef0:	00800104 	movi	r2,4
81124ef4:	38827c26 	beq	r7,r2,811258e8 <_dtoa_r+0xd08>
81124ef8:	00800144 	movi	r2,5
81124efc:	3884c41e 	bne	r7,r2,81126210 <_dtoa_r+0x1630>
81124f00:	00800044 	movi	r2,1
81124f04:	d8800b15 	stw	r2,44(sp)
81124f08:	d8c00517 	ldw	r3,20(sp)
81124f0c:	d9002217 	ldw	r4,136(sp)
81124f10:	1907883a 	add	r3,r3,r4
81124f14:	19800044 	addi	r6,r3,1
81124f18:	d8c00c15 	stw	r3,48(sp)
81124f1c:	d9800615 	stw	r6,24(sp)
81124f20:	0183a40e 	bge	zero,r6,81125db4 <_dtoa_r+0x11d4>
81124f24:	d9800617 	ldw	r6,24(sp)
81124f28:	3021883a 	mov	r16,r6
81124f2c:	e0001115 	stw	zero,68(fp)
81124f30:	008005c4 	movi	r2,23
81124f34:	1184c92e 	bgeu	r2,r6,8112625c <_dtoa_r+0x167c>
81124f38:	00c00044 	movi	r3,1
81124f3c:	00800104 	movi	r2,4
81124f40:	1085883a 	add	r2,r2,r2
81124f44:	11000504 	addi	r4,r2,20
81124f48:	180b883a 	mov	r5,r3
81124f4c:	18c00044 	addi	r3,r3,1
81124f50:	313ffb2e 	bgeu	r6,r4,81124f40 <__reset+0xfb104f40>
81124f54:	e1401115 	stw	r5,68(fp)
81124f58:	e009883a 	mov	r4,fp
81124f5c:	1127cf80 	call	81127cf8 <_Balloc>
81124f60:	d8800715 	stw	r2,28(sp)
81124f64:	e0801015 	stw	r2,64(fp)
81124f68:	00800384 	movi	r2,14
81124f6c:	1400f736 	bltu	r2,r16,8112534c <_dtoa_r+0x76c>
81124f70:	8800f626 	beq	r17,zero,8112534c <_dtoa_r+0x76c>
81124f74:	d9c00517 	ldw	r7,20(sp)
81124f78:	01c39a0e 	bge	zero,r7,81125de4 <_dtoa_r+0x1204>
81124f7c:	388003cc 	andi	r2,r7,15
81124f80:	100490fa 	slli	r2,r2,3
81124f84:	382bd13a 	srai	r21,r7,4
81124f88:	00e04574 	movhi	r3,33045
81124f8c:	18f0f304 	addi	r3,r3,-15412
81124f90:	1885883a 	add	r2,r3,r2
81124f94:	a8c0040c 	andi	r3,r21,16
81124f98:	12400017 	ldw	r9,0(r2)
81124f9c:	12000117 	ldw	r8,4(r2)
81124fa0:	18037926 	beq	r3,zero,81125d88 <_dtoa_r+0x11a8>
81124fa4:	00a04574 	movhi	r2,33045
81124fa8:	10b0e904 	addi	r2,r2,-15452
81124fac:	11800817 	ldw	r6,32(r2)
81124fb0:	11c00917 	ldw	r7,36(r2)
81124fb4:	9009883a 	mov	r4,r18
81124fb8:	980b883a 	mov	r5,r19
81124fbc:	da001715 	stw	r8,92(sp)
81124fc0:	da401615 	stw	r9,88(sp)
81124fc4:	1130c1c0 	call	81130c1c <__divdf3>
81124fc8:	da001717 	ldw	r8,92(sp)
81124fcc:	da401617 	ldw	r9,88(sp)
81124fd0:	ad4003cc 	andi	r21,r21,15
81124fd4:	040000c4 	movi	r16,3
81124fd8:	1023883a 	mov	r17,r2
81124fdc:	1829883a 	mov	r20,r3
81124fe0:	a8001126 	beq	r21,zero,81125028 <_dtoa_r+0x448>
81124fe4:	05e04574 	movhi	r23,33045
81124fe8:	bdf0e904 	addi	r23,r23,-15452
81124fec:	4805883a 	mov	r2,r9
81124ff0:	4007883a 	mov	r3,r8
81124ff4:	a980004c 	andi	r6,r21,1
81124ff8:	1009883a 	mov	r4,r2
81124ffc:	a82bd07a 	srai	r21,r21,1
81125000:	180b883a 	mov	r5,r3
81125004:	30000426 	beq	r6,zero,81125018 <_dtoa_r+0x438>
81125008:	b9800017 	ldw	r6,0(r23)
8112500c:	b9c00117 	ldw	r7,4(r23)
81125010:	84000044 	addi	r16,r16,1
81125014:	111be780 	call	8111be78 <__muldf3>
81125018:	bdc00204 	addi	r23,r23,8
8112501c:	a83ff51e 	bne	r21,zero,81124ff4 <__reset+0xfb104ff4>
81125020:	1013883a 	mov	r9,r2
81125024:	1811883a 	mov	r8,r3
81125028:	480d883a 	mov	r6,r9
8112502c:	400f883a 	mov	r7,r8
81125030:	8809883a 	mov	r4,r17
81125034:	a00b883a 	mov	r5,r20
81125038:	1130c1c0 	call	81130c1c <__divdf3>
8112503c:	d8800f15 	stw	r2,60(sp)
81125040:	d8c01015 	stw	r3,64(sp)
81125044:	d8c00e17 	ldw	r3,56(sp)
81125048:	18000626 	beq	r3,zero,81125064 <_dtoa_r+0x484>
8112504c:	d9000f17 	ldw	r4,60(sp)
81125050:	d9401017 	ldw	r5,64(sp)
81125054:	000d883a 	mov	r6,zero
81125058:	01cffc34 	movhi	r7,16368
8112505c:	11316700 	call	81131670 <__ledf2>
81125060:	10040b16 	blt	r2,zero,81126090 <_dtoa_r+0x14b0>
81125064:	8009883a 	mov	r4,r16
81125068:	11320e80 	call	811320e8 <__floatsidf>
8112506c:	d9800f17 	ldw	r6,60(sp)
81125070:	d9c01017 	ldw	r7,64(sp)
81125074:	1009883a 	mov	r4,r2
81125078:	180b883a 	mov	r5,r3
8112507c:	111be780 	call	8111be78 <__muldf3>
81125080:	000d883a 	mov	r6,zero
81125084:	01d00734 	movhi	r7,16412
81125088:	1009883a 	mov	r4,r2
8112508c:	180b883a 	mov	r5,r3
81125090:	11303680 	call	81130368 <__adddf3>
81125094:	1021883a 	mov	r16,r2
81125098:	d8800617 	ldw	r2,24(sp)
8112509c:	047f3034 	movhi	r17,64704
811250a0:	1c63883a 	add	r17,r3,r17
811250a4:	10031826 	beq	r2,zero,81125d08 <_dtoa_r+0x1128>
811250a8:	d8c00517 	ldw	r3,20(sp)
811250ac:	db000617 	ldw	r12,24(sp)
811250b0:	d8c01315 	stw	r3,76(sp)
811250b4:	d9000b17 	ldw	r4,44(sp)
811250b8:	20038f26 	beq	r4,zero,81125ef8 <_dtoa_r+0x1318>
811250bc:	60bfffc4 	addi	r2,r12,-1
811250c0:	100490fa 	slli	r2,r2,3
811250c4:	00e04574 	movhi	r3,33045
811250c8:	18f0f304 	addi	r3,r3,-15412
811250cc:	1885883a 	add	r2,r3,r2
811250d0:	11800017 	ldw	r6,0(r2)
811250d4:	11c00117 	ldw	r7,4(r2)
811250d8:	d8800717 	ldw	r2,28(sp)
811250dc:	0009883a 	mov	r4,zero
811250e0:	014ff834 	movhi	r5,16352
811250e4:	db001615 	stw	r12,88(sp)
811250e8:	15c00044 	addi	r23,r2,1
811250ec:	1130c1c0 	call	81130c1c <__divdf3>
811250f0:	800d883a 	mov	r6,r16
811250f4:	880f883a 	mov	r7,r17
811250f8:	1009883a 	mov	r4,r2
811250fc:	180b883a 	mov	r5,r3
81125100:	11317640 	call	81131764 <__subdf3>
81125104:	d9401017 	ldw	r5,64(sp)
81125108:	d9000f17 	ldw	r4,60(sp)
8112510c:	102b883a 	mov	r21,r2
81125110:	d8c01215 	stw	r3,72(sp)
81125114:	11320680 	call	81132068 <__fixdfsi>
81125118:	1009883a 	mov	r4,r2
8112511c:	1029883a 	mov	r20,r2
81125120:	11320e80 	call	811320e8 <__floatsidf>
81125124:	d9000f17 	ldw	r4,60(sp)
81125128:	d9401017 	ldw	r5,64(sp)
8112512c:	100d883a 	mov	r6,r2
81125130:	180f883a 	mov	r7,r3
81125134:	11317640 	call	81131764 <__subdf3>
81125138:	1823883a 	mov	r17,r3
8112513c:	d8c00717 	ldw	r3,28(sp)
81125140:	d9401217 	ldw	r5,72(sp)
81125144:	a2000c04 	addi	r8,r20,48
81125148:	1021883a 	mov	r16,r2
8112514c:	1a000005 	stb	r8,0(r3)
81125150:	800d883a 	mov	r6,r16
81125154:	880f883a 	mov	r7,r17
81125158:	a809883a 	mov	r4,r21
8112515c:	4029883a 	mov	r20,r8
81125160:	11315940 	call	81131594 <__gedf2>
81125164:	00841d16 	blt	zero,r2,811261dc <_dtoa_r+0x15fc>
81125168:	800d883a 	mov	r6,r16
8112516c:	880f883a 	mov	r7,r17
81125170:	0009883a 	mov	r4,zero
81125174:	014ffc34 	movhi	r5,16368
81125178:	11317640 	call	81131764 <__subdf3>
8112517c:	d9401217 	ldw	r5,72(sp)
81125180:	100d883a 	mov	r6,r2
81125184:	180f883a 	mov	r7,r3
81125188:	a809883a 	mov	r4,r21
8112518c:	11315940 	call	81131594 <__gedf2>
81125190:	db001617 	ldw	r12,88(sp)
81125194:	00840e16 	blt	zero,r2,811261d0 <_dtoa_r+0x15f0>
81125198:	00800044 	movi	r2,1
8112519c:	13006b0e 	bge	r2,r12,8112534c <_dtoa_r+0x76c>
811251a0:	d9000717 	ldw	r4,28(sp)
811251a4:	dd800f15 	stw	r22,60(sp)
811251a8:	dcc01015 	stw	r19,64(sp)
811251ac:	2319883a 	add	r12,r4,r12
811251b0:	dcc01217 	ldw	r19,72(sp)
811251b4:	602d883a 	mov	r22,r12
811251b8:	dc801215 	stw	r18,72(sp)
811251bc:	b825883a 	mov	r18,r23
811251c0:	00000906 	br	811251e8 <_dtoa_r+0x608>
811251c4:	11317640 	call	81131764 <__subdf3>
811251c8:	a80d883a 	mov	r6,r21
811251cc:	980f883a 	mov	r7,r19
811251d0:	1009883a 	mov	r4,r2
811251d4:	180b883a 	mov	r5,r3
811251d8:	11316700 	call	81131670 <__ledf2>
811251dc:	1003e816 	blt	r2,zero,81126180 <_dtoa_r+0x15a0>
811251e0:	b825883a 	mov	r18,r23
811251e4:	bd83e926 	beq	r23,r22,8112618c <_dtoa_r+0x15ac>
811251e8:	a809883a 	mov	r4,r21
811251ec:	980b883a 	mov	r5,r19
811251f0:	000d883a 	mov	r6,zero
811251f4:	01d00934 	movhi	r7,16420
811251f8:	111be780 	call	8111be78 <__muldf3>
811251fc:	000d883a 	mov	r6,zero
81125200:	01d00934 	movhi	r7,16420
81125204:	8009883a 	mov	r4,r16
81125208:	880b883a 	mov	r5,r17
8112520c:	102b883a 	mov	r21,r2
81125210:	1827883a 	mov	r19,r3
81125214:	111be780 	call	8111be78 <__muldf3>
81125218:	180b883a 	mov	r5,r3
8112521c:	1009883a 	mov	r4,r2
81125220:	1821883a 	mov	r16,r3
81125224:	1023883a 	mov	r17,r2
81125228:	11320680 	call	81132068 <__fixdfsi>
8112522c:	1009883a 	mov	r4,r2
81125230:	1029883a 	mov	r20,r2
81125234:	11320e80 	call	811320e8 <__floatsidf>
81125238:	8809883a 	mov	r4,r17
8112523c:	800b883a 	mov	r5,r16
81125240:	100d883a 	mov	r6,r2
81125244:	180f883a 	mov	r7,r3
81125248:	11317640 	call	81131764 <__subdf3>
8112524c:	a5000c04 	addi	r20,r20,48
81125250:	a80d883a 	mov	r6,r21
81125254:	980f883a 	mov	r7,r19
81125258:	1009883a 	mov	r4,r2
8112525c:	180b883a 	mov	r5,r3
81125260:	95000005 	stb	r20,0(r18)
81125264:	1021883a 	mov	r16,r2
81125268:	1823883a 	mov	r17,r3
8112526c:	11316700 	call	81131670 <__ledf2>
81125270:	bdc00044 	addi	r23,r23,1
81125274:	800d883a 	mov	r6,r16
81125278:	880f883a 	mov	r7,r17
8112527c:	0009883a 	mov	r4,zero
81125280:	014ffc34 	movhi	r5,16368
81125284:	103fcf0e 	bge	r2,zero,811251c4 <__reset+0xfb1051c4>
81125288:	d8c01317 	ldw	r3,76(sp)
8112528c:	d8c00515 	stw	r3,20(sp)
81125290:	d9400917 	ldw	r5,36(sp)
81125294:	e009883a 	mov	r4,fp
81125298:	1127da80 	call	81127da8 <_Bfree>
8112529c:	d9000517 	ldw	r4,20(sp)
811252a0:	d9802317 	ldw	r6,140(sp)
811252a4:	d9c02517 	ldw	r7,148(sp)
811252a8:	b8000005 	stb	zero,0(r23)
811252ac:	20800044 	addi	r2,r4,1
811252b0:	30800015 	stw	r2,0(r6)
811252b4:	3802aa26 	beq	r7,zero,81125d60 <_dtoa_r+0x1180>
811252b8:	3dc00015 	stw	r23,0(r7)
811252bc:	d8800717 	ldw	r2,28(sp)
811252c0:	003e7906 	br	81124ca8 <__reset+0xfb104ca8>
811252c4:	00800434 	movhi	r2,16
811252c8:	10bfffc4 	addi	r2,r2,-1
811252cc:	88a2703a 	and	r17,r17,r2
811252d0:	883e851e 	bne	r17,zero,81124ce8 <__reset+0xfb104ce8>
811252d4:	00a04574 	movhi	r2,33045
811252d8:	10b0d504 	addi	r2,r2,-15532
811252dc:	003e8406 	br	81124cf0 <__reset+0xfb104cf0>
811252e0:	10c00204 	addi	r3,r2,8
811252e4:	003e8706 	br	81124d04 <__reset+0xfb104d04>
811252e8:	01400434 	movhi	r5,16
811252ec:	297fffc4 	addi	r5,r5,-1
811252f0:	994a703a 	and	r5,r19,r5
811252f4:	9009883a 	mov	r4,r18
811252f8:	843f0044 	addi	r16,r16,-1023
811252fc:	294ffc34 	orhi	r5,r5,16368
81125300:	dd800217 	ldw	r22,8(sp)
81125304:	d8001115 	stw	zero,68(sp)
81125308:	003ea506 	br	81124da0 <__reset+0xfb104da0>
8112530c:	00a04574 	movhi	r2,33045
81125310:	10b0ba04 	addi	r2,r2,-15640
81125314:	003e6406 	br	81124ca8 <__reset+0xfb104ca8>
81125318:	e0001115 	stw	zero,68(fp)
8112531c:	000b883a 	mov	r5,zero
81125320:	e009883a 	mov	r4,fp
81125324:	1127cf80 	call	81127cf8 <_Balloc>
81125328:	01bfffc4 	movi	r6,-1
8112532c:	01c00044 	movi	r7,1
81125330:	d8800715 	stw	r2,28(sp)
81125334:	d9800c15 	stw	r6,48(sp)
81125338:	e0801015 	stw	r2,64(fp)
8112533c:	d8000315 	stw	zero,12(sp)
81125340:	d9c00b15 	stw	r7,44(sp)
81125344:	d9800615 	stw	r6,24(sp)
81125348:	d8002215 	stw	zero,136(sp)
8112534c:	d8800117 	ldw	r2,4(sp)
81125350:	10008916 	blt	r2,zero,81125578 <_dtoa_r+0x998>
81125354:	d9000517 	ldw	r4,20(sp)
81125358:	00c00384 	movi	r3,14
8112535c:	19008616 	blt	r3,r4,81125578 <_dtoa_r+0x998>
81125360:	200490fa 	slli	r2,r4,3
81125364:	00e04574 	movhi	r3,33045
81125368:	d9802217 	ldw	r6,136(sp)
8112536c:	18f0f304 	addi	r3,r3,-15412
81125370:	1885883a 	add	r2,r3,r2
81125374:	14000017 	ldw	r16,0(r2)
81125378:	14400117 	ldw	r17,4(r2)
8112537c:	30016316 	blt	r6,zero,8112590c <_dtoa_r+0xd2c>
81125380:	800d883a 	mov	r6,r16
81125384:	880f883a 	mov	r7,r17
81125388:	9009883a 	mov	r4,r18
8112538c:	980b883a 	mov	r5,r19
81125390:	1130c1c0 	call	81130c1c <__divdf3>
81125394:	180b883a 	mov	r5,r3
81125398:	1009883a 	mov	r4,r2
8112539c:	11320680 	call	81132068 <__fixdfsi>
811253a0:	1009883a 	mov	r4,r2
811253a4:	102b883a 	mov	r21,r2
811253a8:	11320e80 	call	811320e8 <__floatsidf>
811253ac:	800d883a 	mov	r6,r16
811253b0:	880f883a 	mov	r7,r17
811253b4:	1009883a 	mov	r4,r2
811253b8:	180b883a 	mov	r5,r3
811253bc:	111be780 	call	8111be78 <__muldf3>
811253c0:	100d883a 	mov	r6,r2
811253c4:	180f883a 	mov	r7,r3
811253c8:	9009883a 	mov	r4,r18
811253cc:	980b883a 	mov	r5,r19
811253d0:	11317640 	call	81131764 <__subdf3>
811253d4:	d9c00717 	ldw	r7,28(sp)
811253d8:	1009883a 	mov	r4,r2
811253dc:	a8800c04 	addi	r2,r21,48
811253e0:	38800005 	stb	r2,0(r7)
811253e4:	3dc00044 	addi	r23,r7,1
811253e8:	d9c00617 	ldw	r7,24(sp)
811253ec:	01800044 	movi	r6,1
811253f0:	180b883a 	mov	r5,r3
811253f4:	2005883a 	mov	r2,r4
811253f8:	39803826 	beq	r7,r6,811254dc <_dtoa_r+0x8fc>
811253fc:	000d883a 	mov	r6,zero
81125400:	01d00934 	movhi	r7,16420
81125404:	111be780 	call	8111be78 <__muldf3>
81125408:	000d883a 	mov	r6,zero
8112540c:	000f883a 	mov	r7,zero
81125410:	1009883a 	mov	r4,r2
81125414:	180b883a 	mov	r5,r3
81125418:	1025883a 	mov	r18,r2
8112541c:	1827883a 	mov	r19,r3
81125420:	113150c0 	call	8113150c <__eqdf2>
81125424:	103f9a26 	beq	r2,zero,81125290 <__reset+0xfb105290>
81125428:	d9c00617 	ldw	r7,24(sp)
8112542c:	d8c00717 	ldw	r3,28(sp)
81125430:	b829883a 	mov	r20,r23
81125434:	38bfffc4 	addi	r2,r7,-1
81125438:	18ad883a 	add	r22,r3,r2
8112543c:	00000a06 	br	81125468 <_dtoa_r+0x888>
81125440:	111be780 	call	8111be78 <__muldf3>
81125444:	000d883a 	mov	r6,zero
81125448:	000f883a 	mov	r7,zero
8112544c:	1009883a 	mov	r4,r2
81125450:	180b883a 	mov	r5,r3
81125454:	1025883a 	mov	r18,r2
81125458:	1827883a 	mov	r19,r3
8112545c:	b829883a 	mov	r20,r23
81125460:	113150c0 	call	8113150c <__eqdf2>
81125464:	103f8a26 	beq	r2,zero,81125290 <__reset+0xfb105290>
81125468:	800d883a 	mov	r6,r16
8112546c:	880f883a 	mov	r7,r17
81125470:	9009883a 	mov	r4,r18
81125474:	980b883a 	mov	r5,r19
81125478:	1130c1c0 	call	81130c1c <__divdf3>
8112547c:	180b883a 	mov	r5,r3
81125480:	1009883a 	mov	r4,r2
81125484:	11320680 	call	81132068 <__fixdfsi>
81125488:	1009883a 	mov	r4,r2
8112548c:	102b883a 	mov	r21,r2
81125490:	11320e80 	call	811320e8 <__floatsidf>
81125494:	800d883a 	mov	r6,r16
81125498:	880f883a 	mov	r7,r17
8112549c:	1009883a 	mov	r4,r2
811254a0:	180b883a 	mov	r5,r3
811254a4:	111be780 	call	8111be78 <__muldf3>
811254a8:	100d883a 	mov	r6,r2
811254ac:	180f883a 	mov	r7,r3
811254b0:	9009883a 	mov	r4,r18
811254b4:	980b883a 	mov	r5,r19
811254b8:	11317640 	call	81131764 <__subdf3>
811254bc:	aa000c04 	addi	r8,r21,48
811254c0:	a2000005 	stb	r8,0(r20)
811254c4:	000d883a 	mov	r6,zero
811254c8:	01d00934 	movhi	r7,16420
811254cc:	1009883a 	mov	r4,r2
811254d0:	180b883a 	mov	r5,r3
811254d4:	a5c00044 	addi	r23,r20,1
811254d8:	b53fd91e 	bne	r22,r20,81125440 <__reset+0xfb105440>
811254dc:	100d883a 	mov	r6,r2
811254e0:	180f883a 	mov	r7,r3
811254e4:	1009883a 	mov	r4,r2
811254e8:	180b883a 	mov	r5,r3
811254ec:	11303680 	call	81130368 <__adddf3>
811254f0:	100d883a 	mov	r6,r2
811254f4:	180f883a 	mov	r7,r3
811254f8:	8009883a 	mov	r4,r16
811254fc:	880b883a 	mov	r5,r17
81125500:	1027883a 	mov	r19,r2
81125504:	1825883a 	mov	r18,r3
81125508:	11316700 	call	81131670 <__ledf2>
8112550c:	10000816 	blt	r2,zero,81125530 <_dtoa_r+0x950>
81125510:	980d883a 	mov	r6,r19
81125514:	900f883a 	mov	r7,r18
81125518:	8009883a 	mov	r4,r16
8112551c:	880b883a 	mov	r5,r17
81125520:	113150c0 	call	8113150c <__eqdf2>
81125524:	103f5a1e 	bne	r2,zero,81125290 <__reset+0xfb105290>
81125528:	ad40004c 	andi	r21,r21,1
8112552c:	a83f5826 	beq	r21,zero,81125290 <__reset+0xfb105290>
81125530:	bd3fffc3 	ldbu	r20,-1(r23)
81125534:	b8bfffc4 	addi	r2,r23,-1
81125538:	1007883a 	mov	r3,r2
8112553c:	01400e44 	movi	r5,57
81125540:	d9800717 	ldw	r6,28(sp)
81125544:	00000506 	br	8112555c <_dtoa_r+0x97c>
81125548:	18ffffc4 	addi	r3,r3,-1
8112554c:	11824726 	beq	r2,r6,81125e6c <_dtoa_r+0x128c>
81125550:	1d000003 	ldbu	r20,0(r3)
81125554:	102f883a 	mov	r23,r2
81125558:	10bfffc4 	addi	r2,r2,-1
8112555c:	a1003fcc 	andi	r4,r20,255
81125560:	2100201c 	xori	r4,r4,128
81125564:	213fe004 	addi	r4,r4,-128
81125568:	217ff726 	beq	r4,r5,81125548 <__reset+0xfb105548>
8112556c:	a2000044 	addi	r8,r20,1
81125570:	12000005 	stb	r8,0(r2)
81125574:	003f4606 	br	81125290 <__reset+0xfb105290>
81125578:	d9000b17 	ldw	r4,44(sp)
8112557c:	2000c826 	beq	r4,zero,811258a0 <_dtoa_r+0xcc0>
81125580:	d9800317 	ldw	r6,12(sp)
81125584:	00c00044 	movi	r3,1
81125588:	1980f90e 	bge	r3,r6,81125970 <_dtoa_r+0xd90>
8112558c:	d8800617 	ldw	r2,24(sp)
81125590:	d8c00a17 	ldw	r3,40(sp)
81125594:	157fffc4 	addi	r21,r2,-1
81125598:	1d41f316 	blt	r3,r21,81125d68 <_dtoa_r+0x1188>
8112559c:	1d6bc83a 	sub	r21,r3,r21
811255a0:	d9c00617 	ldw	r7,24(sp)
811255a4:	3802aa16 	blt	r7,zero,81126050 <_dtoa_r+0x1470>
811255a8:	dd000817 	ldw	r20,32(sp)
811255ac:	d8800617 	ldw	r2,24(sp)
811255b0:	d8c00817 	ldw	r3,32(sp)
811255b4:	01400044 	movi	r5,1
811255b8:	e009883a 	mov	r4,fp
811255bc:	1887883a 	add	r3,r3,r2
811255c0:	d8c00815 	stw	r3,32(sp)
811255c4:	b0ad883a 	add	r22,r22,r2
811255c8:	112811c0 	call	8112811c <__i2b>
811255cc:	1023883a 	mov	r17,r2
811255d0:	a0000826 	beq	r20,zero,811255f4 <_dtoa_r+0xa14>
811255d4:	0580070e 	bge	zero,r22,811255f4 <_dtoa_r+0xa14>
811255d8:	a005883a 	mov	r2,r20
811255dc:	b500b916 	blt	r22,r20,811258c4 <_dtoa_r+0xce4>
811255e0:	d9000817 	ldw	r4,32(sp)
811255e4:	a0a9c83a 	sub	r20,r20,r2
811255e8:	b0adc83a 	sub	r22,r22,r2
811255ec:	2089c83a 	sub	r4,r4,r2
811255f0:	d9000815 	stw	r4,32(sp)
811255f4:	d9800a17 	ldw	r6,40(sp)
811255f8:	0181810e 	bge	zero,r6,81125c00 <_dtoa_r+0x1020>
811255fc:	d9c00b17 	ldw	r7,44(sp)
81125600:	3800b326 	beq	r7,zero,811258d0 <_dtoa_r+0xcf0>
81125604:	a800b226 	beq	r21,zero,811258d0 <_dtoa_r+0xcf0>
81125608:	880b883a 	mov	r5,r17
8112560c:	a80d883a 	mov	r6,r21
81125610:	e009883a 	mov	r4,fp
81125614:	11283600 	call	81128360 <__pow5mult>
81125618:	d9800917 	ldw	r6,36(sp)
8112561c:	100b883a 	mov	r5,r2
81125620:	e009883a 	mov	r4,fp
81125624:	1023883a 	mov	r17,r2
81125628:	11281600 	call	81128160 <__multiply>
8112562c:	1021883a 	mov	r16,r2
81125630:	d8800a17 	ldw	r2,40(sp)
81125634:	d9400917 	ldw	r5,36(sp)
81125638:	e009883a 	mov	r4,fp
8112563c:	1545c83a 	sub	r2,r2,r21
81125640:	d8800a15 	stw	r2,40(sp)
81125644:	1127da80 	call	81127da8 <_Bfree>
81125648:	d8c00a17 	ldw	r3,40(sp)
8112564c:	18009f1e 	bne	r3,zero,811258cc <_dtoa_r+0xcec>
81125650:	05c00044 	movi	r23,1
81125654:	e009883a 	mov	r4,fp
81125658:	b80b883a 	mov	r5,r23
8112565c:	112811c0 	call	8112811c <__i2b>
81125660:	d9000d17 	ldw	r4,52(sp)
81125664:	102b883a 	mov	r21,r2
81125668:	2000ce26 	beq	r4,zero,811259a4 <_dtoa_r+0xdc4>
8112566c:	200d883a 	mov	r6,r4
81125670:	100b883a 	mov	r5,r2
81125674:	e009883a 	mov	r4,fp
81125678:	11283600 	call	81128360 <__pow5mult>
8112567c:	d9800317 	ldw	r6,12(sp)
81125680:	102b883a 	mov	r21,r2
81125684:	b981810e 	bge	r23,r6,81125c8c <_dtoa_r+0x10ac>
81125688:	0027883a 	mov	r19,zero
8112568c:	a8800417 	ldw	r2,16(r21)
81125690:	05c00804 	movi	r23,32
81125694:	10800104 	addi	r2,r2,4
81125698:	1085883a 	add	r2,r2,r2
8112569c:	1085883a 	add	r2,r2,r2
811256a0:	a885883a 	add	r2,r21,r2
811256a4:	11000017 	ldw	r4,0(r2)
811256a8:	11280040 	call	81128004 <__hi0bits>
811256ac:	b885c83a 	sub	r2,r23,r2
811256b0:	1585883a 	add	r2,r2,r22
811256b4:	108007cc 	andi	r2,r2,31
811256b8:	1000b326 	beq	r2,zero,81125988 <_dtoa_r+0xda8>
811256bc:	00c00804 	movi	r3,32
811256c0:	1887c83a 	sub	r3,r3,r2
811256c4:	01000104 	movi	r4,4
811256c8:	20c2cd0e 	bge	r4,r3,81126200 <_dtoa_r+0x1620>
811256cc:	00c00704 	movi	r3,28
811256d0:	1885c83a 	sub	r2,r3,r2
811256d4:	d8c00817 	ldw	r3,32(sp)
811256d8:	a0a9883a 	add	r20,r20,r2
811256dc:	b0ad883a 	add	r22,r22,r2
811256e0:	1887883a 	add	r3,r3,r2
811256e4:	d8c00815 	stw	r3,32(sp)
811256e8:	d9800817 	ldw	r6,32(sp)
811256ec:	0180040e 	bge	zero,r6,81125700 <_dtoa_r+0xb20>
811256f0:	800b883a 	mov	r5,r16
811256f4:	e009883a 	mov	r4,fp
811256f8:	11284a80 	call	811284a8 <__lshift>
811256fc:	1021883a 	mov	r16,r2
81125700:	0580050e 	bge	zero,r22,81125718 <_dtoa_r+0xb38>
81125704:	a80b883a 	mov	r5,r21
81125708:	b00d883a 	mov	r6,r22
8112570c:	e009883a 	mov	r4,fp
81125710:	11284a80 	call	811284a8 <__lshift>
81125714:	102b883a 	mov	r21,r2
81125718:	d9c00e17 	ldw	r7,56(sp)
8112571c:	3801211e 	bne	r7,zero,81125ba4 <_dtoa_r+0xfc4>
81125720:	d9800617 	ldw	r6,24(sp)
81125724:	0181380e 	bge	zero,r6,81125c08 <_dtoa_r+0x1028>
81125728:	d8c00b17 	ldw	r3,44(sp)
8112572c:	1800ab1e 	bne	r3,zero,811259dc <_dtoa_r+0xdfc>
81125730:	dc800717 	ldw	r18,28(sp)
81125734:	dcc00617 	ldw	r19,24(sp)
81125738:	9029883a 	mov	r20,r18
8112573c:	00000206 	br	81125748 <_dtoa_r+0xb68>
81125740:	1127dd00 	call	81127dd0 <__multadd>
81125744:	1021883a 	mov	r16,r2
81125748:	a80b883a 	mov	r5,r21
8112574c:	8009883a 	mov	r4,r16
81125750:	11249d80 	call	811249d8 <quorem>
81125754:	10800c04 	addi	r2,r2,48
81125758:	90800005 	stb	r2,0(r18)
8112575c:	94800044 	addi	r18,r18,1
81125760:	9507c83a 	sub	r3,r18,r20
81125764:	000f883a 	mov	r7,zero
81125768:	01800284 	movi	r6,10
8112576c:	800b883a 	mov	r5,r16
81125770:	e009883a 	mov	r4,fp
81125774:	1cfff216 	blt	r3,r19,81125740 <__reset+0xfb105740>
81125778:	1011883a 	mov	r8,r2
8112577c:	d8800617 	ldw	r2,24(sp)
81125780:	0082370e 	bge	zero,r2,81126060 <_dtoa_r+0x1480>
81125784:	d9000717 	ldw	r4,28(sp)
81125788:	0025883a 	mov	r18,zero
8112578c:	20af883a 	add	r23,r4,r2
81125790:	01800044 	movi	r6,1
81125794:	800b883a 	mov	r5,r16
81125798:	e009883a 	mov	r4,fp
8112579c:	da001715 	stw	r8,92(sp)
811257a0:	11284a80 	call	811284a8 <__lshift>
811257a4:	a80b883a 	mov	r5,r21
811257a8:	1009883a 	mov	r4,r2
811257ac:	d8800915 	stw	r2,36(sp)
811257b0:	11285f80 	call	811285f8 <__mcmp>
811257b4:	da001717 	ldw	r8,92(sp)
811257b8:	0081800e 	bge	zero,r2,81125dbc <_dtoa_r+0x11dc>
811257bc:	b93fffc3 	ldbu	r4,-1(r23)
811257c0:	b8bfffc4 	addi	r2,r23,-1
811257c4:	1007883a 	mov	r3,r2
811257c8:	01800e44 	movi	r6,57
811257cc:	d9c00717 	ldw	r7,28(sp)
811257d0:	00000506 	br	811257e8 <_dtoa_r+0xc08>
811257d4:	18ffffc4 	addi	r3,r3,-1
811257d8:	11c12326 	beq	r2,r7,81125c68 <_dtoa_r+0x1088>
811257dc:	19000003 	ldbu	r4,0(r3)
811257e0:	102f883a 	mov	r23,r2
811257e4:	10bfffc4 	addi	r2,r2,-1
811257e8:	21403fcc 	andi	r5,r4,255
811257ec:	2940201c 	xori	r5,r5,128
811257f0:	297fe004 	addi	r5,r5,-128
811257f4:	29bff726 	beq	r5,r6,811257d4 <__reset+0xfb1057d4>
811257f8:	21000044 	addi	r4,r4,1
811257fc:	11000005 	stb	r4,0(r2)
81125800:	a80b883a 	mov	r5,r21
81125804:	e009883a 	mov	r4,fp
81125808:	1127da80 	call	81127da8 <_Bfree>
8112580c:	883ea026 	beq	r17,zero,81125290 <__reset+0xfb105290>
81125810:	90000426 	beq	r18,zero,81125824 <_dtoa_r+0xc44>
81125814:	94400326 	beq	r18,r17,81125824 <_dtoa_r+0xc44>
81125818:	900b883a 	mov	r5,r18
8112581c:	e009883a 	mov	r4,fp
81125820:	1127da80 	call	81127da8 <_Bfree>
81125824:	880b883a 	mov	r5,r17
81125828:	e009883a 	mov	r4,fp
8112582c:	1127da80 	call	81127da8 <_Bfree>
81125830:	003e9706 	br	81125290 <__reset+0xfb105290>
81125834:	01800044 	movi	r6,1
81125838:	d9800e15 	stw	r6,56(sp)
8112583c:	003d9606 	br	81124e98 <__reset+0xfb104e98>
81125840:	d8800817 	ldw	r2,32(sp)
81125844:	d8c00517 	ldw	r3,20(sp)
81125848:	d8000d15 	stw	zero,52(sp)
8112584c:	10c5c83a 	sub	r2,r2,r3
81125850:	00c9c83a 	sub	r4,zero,r3
81125854:	d8800815 	stw	r2,32(sp)
81125858:	d9000a15 	stw	r4,40(sp)
8112585c:	003d9706 	br	81124ebc <__reset+0xfb104ebc>
81125860:	05adc83a 	sub	r22,zero,r22
81125864:	dd800815 	stw	r22,32(sp)
81125868:	002d883a 	mov	r22,zero
8112586c:	003d8e06 	br	81124ea8 <__reset+0xfb104ea8>
81125870:	d9000517 	ldw	r4,20(sp)
81125874:	11320e80 	call	811320e8 <__floatsidf>
81125878:	100d883a 	mov	r6,r2
8112587c:	180f883a 	mov	r7,r3
81125880:	a009883a 	mov	r4,r20
81125884:	880b883a 	mov	r5,r17
81125888:	113150c0 	call	8113150c <__eqdf2>
8112588c:	103d7126 	beq	r2,zero,81124e54 <__reset+0xfb104e54>
81125890:	d9c00517 	ldw	r7,20(sp)
81125894:	39ffffc4 	addi	r7,r7,-1
81125898:	d9c00515 	stw	r7,20(sp)
8112589c:	003d6d06 	br	81124e54 <__reset+0xfb104e54>
811258a0:	dd400a17 	ldw	r21,40(sp)
811258a4:	dd000817 	ldw	r20,32(sp)
811258a8:	0023883a 	mov	r17,zero
811258ac:	003f4806 	br	811255d0 <__reset+0xfb1055d0>
811258b0:	10e3c83a 	sub	r17,r2,r3
811258b4:	9448983a 	sll	r4,r18,r17
811258b8:	003d3206 	br	81124d84 <__reset+0xfb104d84>
811258bc:	d8000e15 	stw	zero,56(sp)
811258c0:	003d7506 	br	81124e98 <__reset+0xfb104e98>
811258c4:	b005883a 	mov	r2,r22
811258c8:	003f4506 	br	811255e0 <__reset+0xfb1055e0>
811258cc:	dc000915 	stw	r16,36(sp)
811258d0:	d9800a17 	ldw	r6,40(sp)
811258d4:	d9400917 	ldw	r5,36(sp)
811258d8:	e009883a 	mov	r4,fp
811258dc:	11283600 	call	81128360 <__pow5mult>
811258e0:	1021883a 	mov	r16,r2
811258e4:	003f5a06 	br	81125650 <__reset+0xfb105650>
811258e8:	01c00044 	movi	r7,1
811258ec:	d9c00b15 	stw	r7,44(sp)
811258f0:	d8802217 	ldw	r2,136(sp)
811258f4:	0081280e 	bge	zero,r2,81125d98 <_dtoa_r+0x11b8>
811258f8:	100d883a 	mov	r6,r2
811258fc:	1021883a 	mov	r16,r2
81125900:	d8800c15 	stw	r2,48(sp)
81125904:	d8800615 	stw	r2,24(sp)
81125908:	003d8806 	br	81124f2c <__reset+0xfb104f2c>
8112590c:	d8800617 	ldw	r2,24(sp)
81125910:	00be9b16 	blt	zero,r2,81125380 <__reset+0xfb105380>
81125914:	10010f1e 	bne	r2,zero,81125d54 <_dtoa_r+0x1174>
81125918:	880b883a 	mov	r5,r17
8112591c:	000d883a 	mov	r6,zero
81125920:	01d00534 	movhi	r7,16404
81125924:	8009883a 	mov	r4,r16
81125928:	111be780 	call	8111be78 <__muldf3>
8112592c:	900d883a 	mov	r6,r18
81125930:	980f883a 	mov	r7,r19
81125934:	1009883a 	mov	r4,r2
81125938:	180b883a 	mov	r5,r3
8112593c:	11315940 	call	81131594 <__gedf2>
81125940:	002b883a 	mov	r21,zero
81125944:	0023883a 	mov	r17,zero
81125948:	1000bf16 	blt	r2,zero,81125c48 <_dtoa_r+0x1068>
8112594c:	d9802217 	ldw	r6,136(sp)
81125950:	ddc00717 	ldw	r23,28(sp)
81125954:	018c303a 	nor	r6,zero,r6
81125958:	d9800515 	stw	r6,20(sp)
8112595c:	a80b883a 	mov	r5,r21
81125960:	e009883a 	mov	r4,fp
81125964:	1127da80 	call	81127da8 <_Bfree>
81125968:	883e4926 	beq	r17,zero,81125290 <__reset+0xfb105290>
8112596c:	003fad06 	br	81125824 <__reset+0xfb105824>
81125970:	d9c01117 	ldw	r7,68(sp)
81125974:	3801bc26 	beq	r7,zero,81126068 <_dtoa_r+0x1488>
81125978:	10810cc4 	addi	r2,r2,1075
8112597c:	dd400a17 	ldw	r21,40(sp)
81125980:	dd000817 	ldw	r20,32(sp)
81125984:	003f0a06 	br	811255b0 <__reset+0xfb1055b0>
81125988:	00800704 	movi	r2,28
8112598c:	d9000817 	ldw	r4,32(sp)
81125990:	a0a9883a 	add	r20,r20,r2
81125994:	b0ad883a 	add	r22,r22,r2
81125998:	2089883a 	add	r4,r4,r2
8112599c:	d9000815 	stw	r4,32(sp)
811259a0:	003f5106 	br	811256e8 <__reset+0xfb1056e8>
811259a4:	d8c00317 	ldw	r3,12(sp)
811259a8:	b8c1fc0e 	bge	r23,r3,8112619c <_dtoa_r+0x15bc>
811259ac:	0027883a 	mov	r19,zero
811259b0:	b805883a 	mov	r2,r23
811259b4:	003f3e06 	br	811256b0 <__reset+0xfb1056b0>
811259b8:	880b883a 	mov	r5,r17
811259bc:	e009883a 	mov	r4,fp
811259c0:	000f883a 	mov	r7,zero
811259c4:	01800284 	movi	r6,10
811259c8:	1127dd00 	call	81127dd0 <__multadd>
811259cc:	d9000c17 	ldw	r4,48(sp)
811259d0:	1023883a 	mov	r17,r2
811259d4:	0102040e 	bge	zero,r4,811261e8 <_dtoa_r+0x1608>
811259d8:	d9000615 	stw	r4,24(sp)
811259dc:	0500050e 	bge	zero,r20,811259f4 <_dtoa_r+0xe14>
811259e0:	880b883a 	mov	r5,r17
811259e4:	a00d883a 	mov	r6,r20
811259e8:	e009883a 	mov	r4,fp
811259ec:	11284a80 	call	811284a8 <__lshift>
811259f0:	1023883a 	mov	r17,r2
811259f4:	9801241e 	bne	r19,zero,81125e88 <_dtoa_r+0x12a8>
811259f8:	8829883a 	mov	r20,r17
811259fc:	d9000617 	ldw	r4,24(sp)
81125a00:	dcc00717 	ldw	r19,28(sp)
81125a04:	9480004c 	andi	r18,r18,1
81125a08:	20bfffc4 	addi	r2,r4,-1
81125a0c:	9885883a 	add	r2,r19,r2
81125a10:	d8800415 	stw	r2,16(sp)
81125a14:	dc800615 	stw	r18,24(sp)
81125a18:	a80b883a 	mov	r5,r21
81125a1c:	8009883a 	mov	r4,r16
81125a20:	11249d80 	call	811249d8 <quorem>
81125a24:	880b883a 	mov	r5,r17
81125a28:	8009883a 	mov	r4,r16
81125a2c:	102f883a 	mov	r23,r2
81125a30:	11285f80 	call	811285f8 <__mcmp>
81125a34:	a80b883a 	mov	r5,r21
81125a38:	a00d883a 	mov	r6,r20
81125a3c:	e009883a 	mov	r4,fp
81125a40:	102d883a 	mov	r22,r2
81125a44:	11286580 	call	81128658 <__mdiff>
81125a48:	1007883a 	mov	r3,r2
81125a4c:	10800317 	ldw	r2,12(r2)
81125a50:	bc800c04 	addi	r18,r23,48
81125a54:	180b883a 	mov	r5,r3
81125a58:	10004e1e 	bne	r2,zero,81125b94 <_dtoa_r+0xfb4>
81125a5c:	8009883a 	mov	r4,r16
81125a60:	d8c01615 	stw	r3,88(sp)
81125a64:	11285f80 	call	811285f8 <__mcmp>
81125a68:	d8c01617 	ldw	r3,88(sp)
81125a6c:	e009883a 	mov	r4,fp
81125a70:	d8801615 	stw	r2,88(sp)
81125a74:	180b883a 	mov	r5,r3
81125a78:	1127da80 	call	81127da8 <_Bfree>
81125a7c:	d8801617 	ldw	r2,88(sp)
81125a80:	1000041e 	bne	r2,zero,81125a94 <_dtoa_r+0xeb4>
81125a84:	d9800317 	ldw	r6,12(sp)
81125a88:	3000021e 	bne	r6,zero,81125a94 <_dtoa_r+0xeb4>
81125a8c:	d8c00617 	ldw	r3,24(sp)
81125a90:	18003726 	beq	r3,zero,81125b70 <_dtoa_r+0xf90>
81125a94:	b0002016 	blt	r22,zero,81125b18 <_dtoa_r+0xf38>
81125a98:	b000041e 	bne	r22,zero,81125aac <_dtoa_r+0xecc>
81125a9c:	d9000317 	ldw	r4,12(sp)
81125aa0:	2000021e 	bne	r4,zero,81125aac <_dtoa_r+0xecc>
81125aa4:	d8c00617 	ldw	r3,24(sp)
81125aa8:	18001b26 	beq	r3,zero,81125b18 <_dtoa_r+0xf38>
81125aac:	00810716 	blt	zero,r2,81125ecc <_dtoa_r+0x12ec>
81125ab0:	d8c00417 	ldw	r3,16(sp)
81125ab4:	9d800044 	addi	r22,r19,1
81125ab8:	9c800005 	stb	r18,0(r19)
81125abc:	b02f883a 	mov	r23,r22
81125ac0:	98c10626 	beq	r19,r3,81125edc <_dtoa_r+0x12fc>
81125ac4:	800b883a 	mov	r5,r16
81125ac8:	000f883a 	mov	r7,zero
81125acc:	01800284 	movi	r6,10
81125ad0:	e009883a 	mov	r4,fp
81125ad4:	1127dd00 	call	81127dd0 <__multadd>
81125ad8:	1021883a 	mov	r16,r2
81125adc:	000f883a 	mov	r7,zero
81125ae0:	01800284 	movi	r6,10
81125ae4:	880b883a 	mov	r5,r17
81125ae8:	e009883a 	mov	r4,fp
81125aec:	8d002526 	beq	r17,r20,81125b84 <_dtoa_r+0xfa4>
81125af0:	1127dd00 	call	81127dd0 <__multadd>
81125af4:	a00b883a 	mov	r5,r20
81125af8:	000f883a 	mov	r7,zero
81125afc:	01800284 	movi	r6,10
81125b00:	e009883a 	mov	r4,fp
81125b04:	1023883a 	mov	r17,r2
81125b08:	1127dd00 	call	81127dd0 <__multadd>
81125b0c:	1029883a 	mov	r20,r2
81125b10:	b027883a 	mov	r19,r22
81125b14:	003fc006 	br	81125a18 <__reset+0xfb105a18>
81125b18:	9011883a 	mov	r8,r18
81125b1c:	00800e0e 	bge	zero,r2,81125b58 <_dtoa_r+0xf78>
81125b20:	800b883a 	mov	r5,r16
81125b24:	01800044 	movi	r6,1
81125b28:	e009883a 	mov	r4,fp
81125b2c:	da001715 	stw	r8,92(sp)
81125b30:	11284a80 	call	811284a8 <__lshift>
81125b34:	a80b883a 	mov	r5,r21
81125b38:	1009883a 	mov	r4,r2
81125b3c:	1021883a 	mov	r16,r2
81125b40:	11285f80 	call	811285f8 <__mcmp>
81125b44:	da001717 	ldw	r8,92(sp)
81125b48:	0081960e 	bge	zero,r2,811261a4 <_dtoa_r+0x15c4>
81125b4c:	00800e44 	movi	r2,57
81125b50:	40817026 	beq	r8,r2,81126114 <_dtoa_r+0x1534>
81125b54:	ba000c44 	addi	r8,r23,49
81125b58:	8825883a 	mov	r18,r17
81125b5c:	9dc00044 	addi	r23,r19,1
81125b60:	9a000005 	stb	r8,0(r19)
81125b64:	a023883a 	mov	r17,r20
81125b68:	dc000915 	stw	r16,36(sp)
81125b6c:	003f2406 	br	81125800 <__reset+0xfb105800>
81125b70:	00800e44 	movi	r2,57
81125b74:	9011883a 	mov	r8,r18
81125b78:	90816626 	beq	r18,r2,81126114 <_dtoa_r+0x1534>
81125b7c:	05bff516 	blt	zero,r22,81125b54 <__reset+0xfb105b54>
81125b80:	003ff506 	br	81125b58 <__reset+0xfb105b58>
81125b84:	1127dd00 	call	81127dd0 <__multadd>
81125b88:	1023883a 	mov	r17,r2
81125b8c:	1029883a 	mov	r20,r2
81125b90:	003fdf06 	br	81125b10 <__reset+0xfb105b10>
81125b94:	e009883a 	mov	r4,fp
81125b98:	1127da80 	call	81127da8 <_Bfree>
81125b9c:	00800044 	movi	r2,1
81125ba0:	003fbc06 	br	81125a94 <__reset+0xfb105a94>
81125ba4:	a80b883a 	mov	r5,r21
81125ba8:	8009883a 	mov	r4,r16
81125bac:	11285f80 	call	811285f8 <__mcmp>
81125bb0:	103edb0e 	bge	r2,zero,81125720 <__reset+0xfb105720>
81125bb4:	800b883a 	mov	r5,r16
81125bb8:	000f883a 	mov	r7,zero
81125bbc:	01800284 	movi	r6,10
81125bc0:	e009883a 	mov	r4,fp
81125bc4:	1127dd00 	call	81127dd0 <__multadd>
81125bc8:	1021883a 	mov	r16,r2
81125bcc:	d8800517 	ldw	r2,20(sp)
81125bd0:	d8c00b17 	ldw	r3,44(sp)
81125bd4:	10bfffc4 	addi	r2,r2,-1
81125bd8:	d8800515 	stw	r2,20(sp)
81125bdc:	183f761e 	bne	r3,zero,811259b8 <__reset+0xfb1059b8>
81125be0:	d9000c17 	ldw	r4,48(sp)
81125be4:	0101730e 	bge	zero,r4,811261b4 <_dtoa_r+0x15d4>
81125be8:	d9000615 	stw	r4,24(sp)
81125bec:	003ed006 	br	81125730 <__reset+0xfb105730>
81125bf0:	00800084 	movi	r2,2
81125bf4:	3081861e 	bne	r6,r2,81126210 <_dtoa_r+0x1630>
81125bf8:	d8000b15 	stw	zero,44(sp)
81125bfc:	003f3c06 	br	811258f0 <__reset+0xfb1058f0>
81125c00:	dc000917 	ldw	r16,36(sp)
81125c04:	003e9206 	br	81125650 <__reset+0xfb105650>
81125c08:	d9c00317 	ldw	r7,12(sp)
81125c0c:	00800084 	movi	r2,2
81125c10:	11fec50e 	bge	r2,r7,81125728 <__reset+0xfb105728>
81125c14:	d9000617 	ldw	r4,24(sp)
81125c18:	20013c1e 	bne	r4,zero,8112610c <_dtoa_r+0x152c>
81125c1c:	a80b883a 	mov	r5,r21
81125c20:	000f883a 	mov	r7,zero
81125c24:	01800144 	movi	r6,5
81125c28:	e009883a 	mov	r4,fp
81125c2c:	1127dd00 	call	81127dd0 <__multadd>
81125c30:	100b883a 	mov	r5,r2
81125c34:	8009883a 	mov	r4,r16
81125c38:	102b883a 	mov	r21,r2
81125c3c:	11285f80 	call	811285f8 <__mcmp>
81125c40:	dc000915 	stw	r16,36(sp)
81125c44:	00bf410e 	bge	zero,r2,8112594c <__reset+0xfb10594c>
81125c48:	d9c00717 	ldw	r7,28(sp)
81125c4c:	00800c44 	movi	r2,49
81125c50:	38800005 	stb	r2,0(r7)
81125c54:	d8800517 	ldw	r2,20(sp)
81125c58:	3dc00044 	addi	r23,r7,1
81125c5c:	10800044 	addi	r2,r2,1
81125c60:	d8800515 	stw	r2,20(sp)
81125c64:	003f3d06 	br	8112595c <__reset+0xfb10595c>
81125c68:	d9800517 	ldw	r6,20(sp)
81125c6c:	d9c00717 	ldw	r7,28(sp)
81125c70:	00800c44 	movi	r2,49
81125c74:	31800044 	addi	r6,r6,1
81125c78:	d9800515 	stw	r6,20(sp)
81125c7c:	38800005 	stb	r2,0(r7)
81125c80:	003edf06 	br	81125800 <__reset+0xfb105800>
81125c84:	d8000b15 	stw	zero,44(sp)
81125c88:	003c9f06 	br	81124f08 <__reset+0xfb104f08>
81125c8c:	903e7e1e 	bne	r18,zero,81125688 <__reset+0xfb105688>
81125c90:	00800434 	movhi	r2,16
81125c94:	10bfffc4 	addi	r2,r2,-1
81125c98:	9884703a 	and	r2,r19,r2
81125c9c:	1000ea1e 	bne	r2,zero,81126048 <_dtoa_r+0x1468>
81125ca0:	9cdffc2c 	andhi	r19,r19,32752
81125ca4:	9800e826 	beq	r19,zero,81126048 <_dtoa_r+0x1468>
81125ca8:	d9c00817 	ldw	r7,32(sp)
81125cac:	b5800044 	addi	r22,r22,1
81125cb0:	04c00044 	movi	r19,1
81125cb4:	39c00044 	addi	r7,r7,1
81125cb8:	d9c00815 	stw	r7,32(sp)
81125cbc:	d8800d17 	ldw	r2,52(sp)
81125cc0:	103e721e 	bne	r2,zero,8112568c <__reset+0xfb10568c>
81125cc4:	00800044 	movi	r2,1
81125cc8:	003e7906 	br	811256b0 <__reset+0xfb1056b0>
81125ccc:	8009883a 	mov	r4,r16
81125cd0:	11320e80 	call	811320e8 <__floatsidf>
81125cd4:	d9800f17 	ldw	r6,60(sp)
81125cd8:	d9c01017 	ldw	r7,64(sp)
81125cdc:	1009883a 	mov	r4,r2
81125ce0:	180b883a 	mov	r5,r3
81125ce4:	111be780 	call	8111be78 <__muldf3>
81125ce8:	000d883a 	mov	r6,zero
81125cec:	01d00734 	movhi	r7,16412
81125cf0:	1009883a 	mov	r4,r2
81125cf4:	180b883a 	mov	r5,r3
81125cf8:	11303680 	call	81130368 <__adddf3>
81125cfc:	047f3034 	movhi	r17,64704
81125d00:	1021883a 	mov	r16,r2
81125d04:	1c63883a 	add	r17,r3,r17
81125d08:	d9000f17 	ldw	r4,60(sp)
81125d0c:	d9401017 	ldw	r5,64(sp)
81125d10:	000d883a 	mov	r6,zero
81125d14:	01d00534 	movhi	r7,16404
81125d18:	11317640 	call	81131764 <__subdf3>
81125d1c:	800d883a 	mov	r6,r16
81125d20:	880f883a 	mov	r7,r17
81125d24:	1009883a 	mov	r4,r2
81125d28:	180b883a 	mov	r5,r3
81125d2c:	102b883a 	mov	r21,r2
81125d30:	1829883a 	mov	r20,r3
81125d34:	11315940 	call	81131594 <__gedf2>
81125d38:	00806c16 	blt	zero,r2,81125eec <_dtoa_r+0x130c>
81125d3c:	89e0003c 	xorhi	r7,r17,32768
81125d40:	800d883a 	mov	r6,r16
81125d44:	a809883a 	mov	r4,r21
81125d48:	a00b883a 	mov	r5,r20
81125d4c:	11316700 	call	81131670 <__ledf2>
81125d50:	103d7e0e 	bge	r2,zero,8112534c <__reset+0xfb10534c>
81125d54:	002b883a 	mov	r21,zero
81125d58:	0023883a 	mov	r17,zero
81125d5c:	003efb06 	br	8112594c <__reset+0xfb10594c>
81125d60:	d8800717 	ldw	r2,28(sp)
81125d64:	003bd006 	br	81124ca8 <__reset+0xfb104ca8>
81125d68:	d9000a17 	ldw	r4,40(sp)
81125d6c:	d9800d17 	ldw	r6,52(sp)
81125d70:	dd400a15 	stw	r21,40(sp)
81125d74:	a905c83a 	sub	r2,r21,r4
81125d78:	308d883a 	add	r6,r6,r2
81125d7c:	d9800d15 	stw	r6,52(sp)
81125d80:	002b883a 	mov	r21,zero
81125d84:	003e0606 	br	811255a0 <__reset+0xfb1055a0>
81125d88:	9023883a 	mov	r17,r18
81125d8c:	9829883a 	mov	r20,r19
81125d90:	04000084 	movi	r16,2
81125d94:	003c9206 	br	81124fe0 <__reset+0xfb104fe0>
81125d98:	04000044 	movi	r16,1
81125d9c:	dc000c15 	stw	r16,48(sp)
81125da0:	dc000615 	stw	r16,24(sp)
81125da4:	dc002215 	stw	r16,136(sp)
81125da8:	e0001115 	stw	zero,68(fp)
81125dac:	000b883a 	mov	r5,zero
81125db0:	003c6906 	br	81124f58 <__reset+0xfb104f58>
81125db4:	3021883a 	mov	r16,r6
81125db8:	003ffb06 	br	81125da8 <__reset+0xfb105da8>
81125dbc:	1000021e 	bne	r2,zero,81125dc8 <_dtoa_r+0x11e8>
81125dc0:	4200004c 	andi	r8,r8,1
81125dc4:	403e7d1e 	bne	r8,zero,811257bc <__reset+0xfb1057bc>
81125dc8:	01000c04 	movi	r4,48
81125dcc:	00000106 	br	81125dd4 <_dtoa_r+0x11f4>
81125dd0:	102f883a 	mov	r23,r2
81125dd4:	b8bfffc4 	addi	r2,r23,-1
81125dd8:	10c00007 	ldb	r3,0(r2)
81125ddc:	193ffc26 	beq	r3,r4,81125dd0 <__reset+0xfb105dd0>
81125de0:	003e8706 	br	81125800 <__reset+0xfb105800>
81125de4:	d8800517 	ldw	r2,20(sp)
81125de8:	00a3c83a 	sub	r17,zero,r2
81125dec:	8800a426 	beq	r17,zero,81126080 <_dtoa_r+0x14a0>
81125df0:	888003cc 	andi	r2,r17,15
81125df4:	100490fa 	slli	r2,r2,3
81125df8:	00e04574 	movhi	r3,33045
81125dfc:	18f0f304 	addi	r3,r3,-15412
81125e00:	1885883a 	add	r2,r3,r2
81125e04:	11800017 	ldw	r6,0(r2)
81125e08:	11c00117 	ldw	r7,4(r2)
81125e0c:	9009883a 	mov	r4,r18
81125e10:	980b883a 	mov	r5,r19
81125e14:	8823d13a 	srai	r17,r17,4
81125e18:	111be780 	call	8111be78 <__muldf3>
81125e1c:	d8800f15 	stw	r2,60(sp)
81125e20:	d8c01015 	stw	r3,64(sp)
81125e24:	8800e826 	beq	r17,zero,811261c8 <_dtoa_r+0x15e8>
81125e28:	05204574 	movhi	r20,33045
81125e2c:	a530e904 	addi	r20,r20,-15452
81125e30:	04000084 	movi	r16,2
81125e34:	8980004c 	andi	r6,r17,1
81125e38:	1009883a 	mov	r4,r2
81125e3c:	8823d07a 	srai	r17,r17,1
81125e40:	180b883a 	mov	r5,r3
81125e44:	30000426 	beq	r6,zero,81125e58 <_dtoa_r+0x1278>
81125e48:	a1800017 	ldw	r6,0(r20)
81125e4c:	a1c00117 	ldw	r7,4(r20)
81125e50:	84000044 	addi	r16,r16,1
81125e54:	111be780 	call	8111be78 <__muldf3>
81125e58:	a5000204 	addi	r20,r20,8
81125e5c:	883ff51e 	bne	r17,zero,81125e34 <__reset+0xfb105e34>
81125e60:	d8800f15 	stw	r2,60(sp)
81125e64:	d8c01015 	stw	r3,64(sp)
81125e68:	003c7606 	br	81125044 <__reset+0xfb105044>
81125e6c:	00c00c04 	movi	r3,48
81125e70:	10c00005 	stb	r3,0(r2)
81125e74:	d8c00517 	ldw	r3,20(sp)
81125e78:	bd3fffc3 	ldbu	r20,-1(r23)
81125e7c:	18c00044 	addi	r3,r3,1
81125e80:	d8c00515 	stw	r3,20(sp)
81125e84:	003db906 	br	8112556c <__reset+0xfb10556c>
81125e88:	89400117 	ldw	r5,4(r17)
81125e8c:	e009883a 	mov	r4,fp
81125e90:	1127cf80 	call	81127cf8 <_Balloc>
81125e94:	89800417 	ldw	r6,16(r17)
81125e98:	89400304 	addi	r5,r17,12
81125e9c:	11000304 	addi	r4,r2,12
81125ea0:	31800084 	addi	r6,r6,2
81125ea4:	318d883a 	add	r6,r6,r6
81125ea8:	318d883a 	add	r6,r6,r6
81125eac:	1027883a 	mov	r19,r2
81125eb0:	111dac80 	call	8111dac8 <memcpy>
81125eb4:	01800044 	movi	r6,1
81125eb8:	980b883a 	mov	r5,r19
81125ebc:	e009883a 	mov	r4,fp
81125ec0:	11284a80 	call	811284a8 <__lshift>
81125ec4:	1029883a 	mov	r20,r2
81125ec8:	003ecc06 	br	811259fc <__reset+0xfb1059fc>
81125ecc:	00800e44 	movi	r2,57
81125ed0:	90809026 	beq	r18,r2,81126114 <_dtoa_r+0x1534>
81125ed4:	92000044 	addi	r8,r18,1
81125ed8:	003f1f06 	br	81125b58 <__reset+0xfb105b58>
81125edc:	9011883a 	mov	r8,r18
81125ee0:	8825883a 	mov	r18,r17
81125ee4:	a023883a 	mov	r17,r20
81125ee8:	003e2906 	br	81125790 <__reset+0xfb105790>
81125eec:	002b883a 	mov	r21,zero
81125ef0:	0023883a 	mov	r17,zero
81125ef4:	003f5406 	br	81125c48 <__reset+0xfb105c48>
81125ef8:	61bfffc4 	addi	r6,r12,-1
81125efc:	300490fa 	slli	r2,r6,3
81125f00:	00e04574 	movhi	r3,33045
81125f04:	18f0f304 	addi	r3,r3,-15412
81125f08:	1885883a 	add	r2,r3,r2
81125f0c:	11000017 	ldw	r4,0(r2)
81125f10:	11400117 	ldw	r5,4(r2)
81125f14:	d8800717 	ldw	r2,28(sp)
81125f18:	880f883a 	mov	r7,r17
81125f1c:	d9801215 	stw	r6,72(sp)
81125f20:	800d883a 	mov	r6,r16
81125f24:	db001615 	stw	r12,88(sp)
81125f28:	15c00044 	addi	r23,r2,1
81125f2c:	111be780 	call	8111be78 <__muldf3>
81125f30:	d9401017 	ldw	r5,64(sp)
81125f34:	d9000f17 	ldw	r4,60(sp)
81125f38:	d8c01515 	stw	r3,84(sp)
81125f3c:	d8801415 	stw	r2,80(sp)
81125f40:	11320680 	call	81132068 <__fixdfsi>
81125f44:	1009883a 	mov	r4,r2
81125f48:	1021883a 	mov	r16,r2
81125f4c:	11320e80 	call	811320e8 <__floatsidf>
81125f50:	d9000f17 	ldw	r4,60(sp)
81125f54:	d9401017 	ldw	r5,64(sp)
81125f58:	100d883a 	mov	r6,r2
81125f5c:	180f883a 	mov	r7,r3
81125f60:	11317640 	call	81131764 <__subdf3>
81125f64:	1829883a 	mov	r20,r3
81125f68:	d8c00717 	ldw	r3,28(sp)
81125f6c:	84000c04 	addi	r16,r16,48
81125f70:	1023883a 	mov	r17,r2
81125f74:	1c000005 	stb	r16,0(r3)
81125f78:	db001617 	ldw	r12,88(sp)
81125f7c:	00800044 	movi	r2,1
81125f80:	60802226 	beq	r12,r2,8112600c <_dtoa_r+0x142c>
81125f84:	d9c00717 	ldw	r7,28(sp)
81125f88:	8805883a 	mov	r2,r17
81125f8c:	b82b883a 	mov	r21,r23
81125f90:	3b19883a 	add	r12,r7,r12
81125f94:	6023883a 	mov	r17,r12
81125f98:	a007883a 	mov	r3,r20
81125f9c:	dc800f15 	stw	r18,60(sp)
81125fa0:	000d883a 	mov	r6,zero
81125fa4:	01d00934 	movhi	r7,16420
81125fa8:	1009883a 	mov	r4,r2
81125fac:	180b883a 	mov	r5,r3
81125fb0:	111be780 	call	8111be78 <__muldf3>
81125fb4:	180b883a 	mov	r5,r3
81125fb8:	1009883a 	mov	r4,r2
81125fbc:	1829883a 	mov	r20,r3
81125fc0:	1025883a 	mov	r18,r2
81125fc4:	11320680 	call	81132068 <__fixdfsi>
81125fc8:	1009883a 	mov	r4,r2
81125fcc:	1021883a 	mov	r16,r2
81125fd0:	11320e80 	call	811320e8 <__floatsidf>
81125fd4:	100d883a 	mov	r6,r2
81125fd8:	180f883a 	mov	r7,r3
81125fdc:	9009883a 	mov	r4,r18
81125fe0:	a00b883a 	mov	r5,r20
81125fe4:	84000c04 	addi	r16,r16,48
81125fe8:	11317640 	call	81131764 <__subdf3>
81125fec:	ad400044 	addi	r21,r21,1
81125ff0:	ac3fffc5 	stb	r16,-1(r21)
81125ff4:	ac7fea1e 	bne	r21,r17,81125fa0 <__reset+0xfb105fa0>
81125ff8:	1023883a 	mov	r17,r2
81125ffc:	d8801217 	ldw	r2,72(sp)
81126000:	dc800f17 	ldw	r18,60(sp)
81126004:	1829883a 	mov	r20,r3
81126008:	b8af883a 	add	r23,r23,r2
8112600c:	d9001417 	ldw	r4,80(sp)
81126010:	d9401517 	ldw	r5,84(sp)
81126014:	000d883a 	mov	r6,zero
81126018:	01cff834 	movhi	r7,16352
8112601c:	11303680 	call	81130368 <__adddf3>
81126020:	880d883a 	mov	r6,r17
81126024:	a00f883a 	mov	r7,r20
81126028:	1009883a 	mov	r4,r2
8112602c:	180b883a 	mov	r5,r3
81126030:	11316700 	call	81131670 <__ledf2>
81126034:	10003e0e 	bge	r2,zero,81126130 <_dtoa_r+0x1550>
81126038:	d9001317 	ldw	r4,76(sp)
8112603c:	bd3fffc3 	ldbu	r20,-1(r23)
81126040:	d9000515 	stw	r4,20(sp)
81126044:	003d3b06 	br	81125534 <__reset+0xfb105534>
81126048:	0027883a 	mov	r19,zero
8112604c:	003f1b06 	br	81125cbc <__reset+0xfb105cbc>
81126050:	d8800817 	ldw	r2,32(sp)
81126054:	11e9c83a 	sub	r20,r2,r7
81126058:	0005883a 	mov	r2,zero
8112605c:	003d5406 	br	811255b0 <__reset+0xfb1055b0>
81126060:	00800044 	movi	r2,1
81126064:	003dc706 	br	81125784 <__reset+0xfb105784>
81126068:	d8c00217 	ldw	r3,8(sp)
8112606c:	00800d84 	movi	r2,54
81126070:	dd400a17 	ldw	r21,40(sp)
81126074:	10c5c83a 	sub	r2,r2,r3
81126078:	dd000817 	ldw	r20,32(sp)
8112607c:	003d4c06 	br	811255b0 <__reset+0xfb1055b0>
81126080:	dc800f15 	stw	r18,60(sp)
81126084:	dcc01015 	stw	r19,64(sp)
81126088:	04000084 	movi	r16,2
8112608c:	003bed06 	br	81125044 <__reset+0xfb105044>
81126090:	d9000617 	ldw	r4,24(sp)
81126094:	203f0d26 	beq	r4,zero,81125ccc <__reset+0xfb105ccc>
81126098:	d9800c17 	ldw	r6,48(sp)
8112609c:	01bcab0e 	bge	zero,r6,8112534c <__reset+0xfb10534c>
811260a0:	d9401017 	ldw	r5,64(sp)
811260a4:	d9000f17 	ldw	r4,60(sp)
811260a8:	000d883a 	mov	r6,zero
811260ac:	01d00934 	movhi	r7,16420
811260b0:	111be780 	call	8111be78 <__muldf3>
811260b4:	81000044 	addi	r4,r16,1
811260b8:	d8800f15 	stw	r2,60(sp)
811260bc:	d8c01015 	stw	r3,64(sp)
811260c0:	11320e80 	call	811320e8 <__floatsidf>
811260c4:	d9800f17 	ldw	r6,60(sp)
811260c8:	d9c01017 	ldw	r7,64(sp)
811260cc:	1009883a 	mov	r4,r2
811260d0:	180b883a 	mov	r5,r3
811260d4:	111be780 	call	8111be78 <__muldf3>
811260d8:	01d00734 	movhi	r7,16412
811260dc:	000d883a 	mov	r6,zero
811260e0:	1009883a 	mov	r4,r2
811260e4:	180b883a 	mov	r5,r3
811260e8:	11303680 	call	81130368 <__adddf3>
811260ec:	d9c00517 	ldw	r7,20(sp)
811260f0:	047f3034 	movhi	r17,64704
811260f4:	1021883a 	mov	r16,r2
811260f8:	39ffffc4 	addi	r7,r7,-1
811260fc:	d9c01315 	stw	r7,76(sp)
81126100:	1c63883a 	add	r17,r3,r17
81126104:	db000c17 	ldw	r12,48(sp)
81126108:	003bea06 	br	811250b4 <__reset+0xfb1050b4>
8112610c:	dc000915 	stw	r16,36(sp)
81126110:	003e0e06 	br	8112594c <__reset+0xfb10594c>
81126114:	01000e44 	movi	r4,57
81126118:	8825883a 	mov	r18,r17
8112611c:	9dc00044 	addi	r23,r19,1
81126120:	99000005 	stb	r4,0(r19)
81126124:	a023883a 	mov	r17,r20
81126128:	dc000915 	stw	r16,36(sp)
8112612c:	003da406 	br	811257c0 <__reset+0xfb1057c0>
81126130:	d9801417 	ldw	r6,80(sp)
81126134:	d9c01517 	ldw	r7,84(sp)
81126138:	0009883a 	mov	r4,zero
8112613c:	014ff834 	movhi	r5,16352
81126140:	11317640 	call	81131764 <__subdf3>
81126144:	880d883a 	mov	r6,r17
81126148:	a00f883a 	mov	r7,r20
8112614c:	1009883a 	mov	r4,r2
81126150:	180b883a 	mov	r5,r3
81126154:	11315940 	call	81131594 <__gedf2>
81126158:	00bc7c0e 	bge	zero,r2,8112534c <__reset+0xfb10534c>
8112615c:	01000c04 	movi	r4,48
81126160:	00000106 	br	81126168 <_dtoa_r+0x1588>
81126164:	102f883a 	mov	r23,r2
81126168:	b8bfffc4 	addi	r2,r23,-1
8112616c:	10c00007 	ldb	r3,0(r2)
81126170:	193ffc26 	beq	r3,r4,81126164 <__reset+0xfb106164>
81126174:	d9801317 	ldw	r6,76(sp)
81126178:	d9800515 	stw	r6,20(sp)
8112617c:	003c4406 	br	81125290 <__reset+0xfb105290>
81126180:	d9801317 	ldw	r6,76(sp)
81126184:	d9800515 	stw	r6,20(sp)
81126188:	003cea06 	br	81125534 <__reset+0xfb105534>
8112618c:	dd800f17 	ldw	r22,60(sp)
81126190:	dcc01017 	ldw	r19,64(sp)
81126194:	dc801217 	ldw	r18,72(sp)
81126198:	003c6c06 	br	8112534c <__reset+0xfb10534c>
8112619c:	903e031e 	bne	r18,zero,811259ac <__reset+0xfb1059ac>
811261a0:	003ebb06 	br	81125c90 <__reset+0xfb105c90>
811261a4:	103e6c1e 	bne	r2,zero,81125b58 <__reset+0xfb105b58>
811261a8:	4080004c 	andi	r2,r8,1
811261ac:	103e6a26 	beq	r2,zero,81125b58 <__reset+0xfb105b58>
811261b0:	003e6606 	br	81125b4c <__reset+0xfb105b4c>
811261b4:	d8c00317 	ldw	r3,12(sp)
811261b8:	00800084 	movi	r2,2
811261bc:	10c02916 	blt	r2,r3,81126264 <_dtoa_r+0x1684>
811261c0:	d9000c17 	ldw	r4,48(sp)
811261c4:	003e8806 	br	81125be8 <__reset+0xfb105be8>
811261c8:	04000084 	movi	r16,2
811261cc:	003b9d06 	br	81125044 <__reset+0xfb105044>
811261d0:	d9001317 	ldw	r4,76(sp)
811261d4:	d9000515 	stw	r4,20(sp)
811261d8:	003cd606 	br	81125534 <__reset+0xfb105534>
811261dc:	d8801317 	ldw	r2,76(sp)
811261e0:	d8800515 	stw	r2,20(sp)
811261e4:	003c2a06 	br	81125290 <__reset+0xfb105290>
811261e8:	d9800317 	ldw	r6,12(sp)
811261ec:	00800084 	movi	r2,2
811261f0:	11801516 	blt	r2,r6,81126248 <_dtoa_r+0x1668>
811261f4:	d9c00c17 	ldw	r7,48(sp)
811261f8:	d9c00615 	stw	r7,24(sp)
811261fc:	003df706 	br	811259dc <__reset+0xfb1059dc>
81126200:	193d3926 	beq	r3,r4,811256e8 <__reset+0xfb1056e8>
81126204:	00c00f04 	movi	r3,60
81126208:	1885c83a 	sub	r2,r3,r2
8112620c:	003ddf06 	br	8112598c <__reset+0xfb10598c>
81126210:	e009883a 	mov	r4,fp
81126214:	e0001115 	stw	zero,68(fp)
81126218:	000b883a 	mov	r5,zero
8112621c:	1127cf80 	call	81127cf8 <_Balloc>
81126220:	d8800715 	stw	r2,28(sp)
81126224:	d8c00717 	ldw	r3,28(sp)
81126228:	00bfffc4 	movi	r2,-1
8112622c:	01000044 	movi	r4,1
81126230:	d8800c15 	stw	r2,48(sp)
81126234:	e0c01015 	stw	r3,64(fp)
81126238:	d9000b15 	stw	r4,44(sp)
8112623c:	d8800615 	stw	r2,24(sp)
81126240:	d8002215 	stw	zero,136(sp)
81126244:	003c4106 	br	8112534c <__reset+0xfb10534c>
81126248:	d8c00c17 	ldw	r3,48(sp)
8112624c:	d8c00615 	stw	r3,24(sp)
81126250:	003e7006 	br	81125c14 <__reset+0xfb105c14>
81126254:	04400044 	movi	r17,1
81126258:	003b2006 	br	81124edc <__reset+0xfb104edc>
8112625c:	000b883a 	mov	r5,zero
81126260:	003b3d06 	br	81124f58 <__reset+0xfb104f58>
81126264:	d8800c17 	ldw	r2,48(sp)
81126268:	d8800615 	stw	r2,24(sp)
8112626c:	003e6906 	br	81125c14 <__reset+0xfb105c14>

81126270 <__sflush_r>:
81126270:	defffb04 	addi	sp,sp,-20
81126274:	de00012e 	bgeu	sp,et,8112627c <__sflush_r+0xc>
81126278:	003b68fa 	trap	3
8112627c:	2880030b 	ldhu	r2,12(r5)
81126280:	dcc00315 	stw	r19,12(sp)
81126284:	dc400115 	stw	r17,4(sp)
81126288:	dfc00415 	stw	ra,16(sp)
8112628c:	dc800215 	stw	r18,8(sp)
81126290:	dc000015 	stw	r16,0(sp)
81126294:	10c0020c 	andi	r3,r2,8
81126298:	2823883a 	mov	r17,r5
8112629c:	2027883a 	mov	r19,r4
811262a0:	1800311e 	bne	r3,zero,81126368 <__sflush_r+0xf8>
811262a4:	28c00117 	ldw	r3,4(r5)
811262a8:	10820014 	ori	r2,r2,2048
811262ac:	2880030d 	sth	r2,12(r5)
811262b0:	00c04b0e 	bge	zero,r3,811263e0 <__sflush_r+0x170>
811262b4:	8a000a17 	ldw	r8,40(r17)
811262b8:	40002326 	beq	r8,zero,81126348 <__sflush_r+0xd8>
811262bc:	9c000017 	ldw	r16,0(r19)
811262c0:	10c4000c 	andi	r3,r2,4096
811262c4:	98000015 	stw	zero,0(r19)
811262c8:	18004826 	beq	r3,zero,811263ec <__sflush_r+0x17c>
811262cc:	89801417 	ldw	r6,80(r17)
811262d0:	10c0010c 	andi	r3,r2,4
811262d4:	18000626 	beq	r3,zero,811262f0 <__sflush_r+0x80>
811262d8:	88c00117 	ldw	r3,4(r17)
811262dc:	88800c17 	ldw	r2,48(r17)
811262e0:	30cdc83a 	sub	r6,r6,r3
811262e4:	10000226 	beq	r2,zero,811262f0 <__sflush_r+0x80>
811262e8:	88800f17 	ldw	r2,60(r17)
811262ec:	308dc83a 	sub	r6,r6,r2
811262f0:	89400717 	ldw	r5,28(r17)
811262f4:	000f883a 	mov	r7,zero
811262f8:	9809883a 	mov	r4,r19
811262fc:	403ee83a 	callr	r8
81126300:	00ffffc4 	movi	r3,-1
81126304:	10c04426 	beq	r2,r3,81126418 <__sflush_r+0x1a8>
81126308:	88c0030b 	ldhu	r3,12(r17)
8112630c:	89000417 	ldw	r4,16(r17)
81126310:	88000115 	stw	zero,4(r17)
81126314:	197dffcc 	andi	r5,r3,63487
81126318:	8940030d 	sth	r5,12(r17)
8112631c:	89000015 	stw	r4,0(r17)
81126320:	18c4000c 	andi	r3,r3,4096
81126324:	18002c1e 	bne	r3,zero,811263d8 <__sflush_r+0x168>
81126328:	89400c17 	ldw	r5,48(r17)
8112632c:	9c000015 	stw	r16,0(r19)
81126330:	28000526 	beq	r5,zero,81126348 <__sflush_r+0xd8>
81126334:	88801004 	addi	r2,r17,64
81126338:	28800226 	beq	r5,r2,81126344 <__sflush_r+0xd4>
8112633c:	9809883a 	mov	r4,r19
81126340:	1126d280 	call	81126d28 <_free_r>
81126344:	88000c15 	stw	zero,48(r17)
81126348:	0005883a 	mov	r2,zero
8112634c:	dfc00417 	ldw	ra,16(sp)
81126350:	dcc00317 	ldw	r19,12(sp)
81126354:	dc800217 	ldw	r18,8(sp)
81126358:	dc400117 	ldw	r17,4(sp)
8112635c:	dc000017 	ldw	r16,0(sp)
81126360:	dec00504 	addi	sp,sp,20
81126364:	f800283a 	ret
81126368:	2c800417 	ldw	r18,16(r5)
8112636c:	903ff626 	beq	r18,zero,81126348 <__reset+0xfb106348>
81126370:	2c000017 	ldw	r16,0(r5)
81126374:	108000cc 	andi	r2,r2,3
81126378:	2c800015 	stw	r18,0(r5)
8112637c:	84a1c83a 	sub	r16,r16,r18
81126380:	1000131e 	bne	r2,zero,811263d0 <__sflush_r+0x160>
81126384:	28800517 	ldw	r2,20(r5)
81126388:	88800215 	stw	r2,8(r17)
8112638c:	04000316 	blt	zero,r16,8112639c <__sflush_r+0x12c>
81126390:	003fed06 	br	81126348 <__reset+0xfb106348>
81126394:	90a5883a 	add	r18,r18,r2
81126398:	043feb0e 	bge	zero,r16,81126348 <__reset+0xfb106348>
8112639c:	88800917 	ldw	r2,36(r17)
811263a0:	89400717 	ldw	r5,28(r17)
811263a4:	800f883a 	mov	r7,r16
811263a8:	900d883a 	mov	r6,r18
811263ac:	9809883a 	mov	r4,r19
811263b0:	103ee83a 	callr	r2
811263b4:	80a1c83a 	sub	r16,r16,r2
811263b8:	00bff616 	blt	zero,r2,81126394 <__reset+0xfb106394>
811263bc:	88c0030b 	ldhu	r3,12(r17)
811263c0:	00bfffc4 	movi	r2,-1
811263c4:	18c01014 	ori	r3,r3,64
811263c8:	88c0030d 	sth	r3,12(r17)
811263cc:	003fdf06 	br	8112634c <__reset+0xfb10634c>
811263d0:	0005883a 	mov	r2,zero
811263d4:	003fec06 	br	81126388 <__reset+0xfb106388>
811263d8:	88801415 	stw	r2,80(r17)
811263dc:	003fd206 	br	81126328 <__reset+0xfb106328>
811263e0:	28c00f17 	ldw	r3,60(r5)
811263e4:	00ffb316 	blt	zero,r3,811262b4 <__reset+0xfb1062b4>
811263e8:	003fd706 	br	81126348 <__reset+0xfb106348>
811263ec:	89400717 	ldw	r5,28(r17)
811263f0:	000d883a 	mov	r6,zero
811263f4:	01c00044 	movi	r7,1
811263f8:	9809883a 	mov	r4,r19
811263fc:	403ee83a 	callr	r8
81126400:	100d883a 	mov	r6,r2
81126404:	00bfffc4 	movi	r2,-1
81126408:	30801426 	beq	r6,r2,8112645c <__sflush_r+0x1ec>
8112640c:	8880030b 	ldhu	r2,12(r17)
81126410:	8a000a17 	ldw	r8,40(r17)
81126414:	003fae06 	br	811262d0 <__reset+0xfb1062d0>
81126418:	98c00017 	ldw	r3,0(r19)
8112641c:	183fba26 	beq	r3,zero,81126308 <__reset+0xfb106308>
81126420:	01000744 	movi	r4,29
81126424:	19000626 	beq	r3,r4,81126440 <__sflush_r+0x1d0>
81126428:	01000584 	movi	r4,22
8112642c:	19000426 	beq	r3,r4,81126440 <__sflush_r+0x1d0>
81126430:	88c0030b 	ldhu	r3,12(r17)
81126434:	18c01014 	ori	r3,r3,64
81126438:	88c0030d 	sth	r3,12(r17)
8112643c:	003fc306 	br	8112634c <__reset+0xfb10634c>
81126440:	8880030b 	ldhu	r2,12(r17)
81126444:	88c00417 	ldw	r3,16(r17)
81126448:	88000115 	stw	zero,4(r17)
8112644c:	10bdffcc 	andi	r2,r2,63487
81126450:	8880030d 	sth	r2,12(r17)
81126454:	88c00015 	stw	r3,0(r17)
81126458:	003fb306 	br	81126328 <__reset+0xfb106328>
8112645c:	98800017 	ldw	r2,0(r19)
81126460:	103fea26 	beq	r2,zero,8112640c <__reset+0xfb10640c>
81126464:	00c00744 	movi	r3,29
81126468:	10c00226 	beq	r2,r3,81126474 <__sflush_r+0x204>
8112646c:	00c00584 	movi	r3,22
81126470:	10c0031e 	bne	r2,r3,81126480 <__sflush_r+0x210>
81126474:	9c000015 	stw	r16,0(r19)
81126478:	0005883a 	mov	r2,zero
8112647c:	003fb306 	br	8112634c <__reset+0xfb10634c>
81126480:	88c0030b 	ldhu	r3,12(r17)
81126484:	3005883a 	mov	r2,r6
81126488:	18c01014 	ori	r3,r3,64
8112648c:	88c0030d 	sth	r3,12(r17)
81126490:	003fae06 	br	8112634c <__reset+0xfb10634c>

81126494 <_fflush_r>:
81126494:	defffd04 	addi	sp,sp,-12
81126498:	de00012e 	bgeu	sp,et,811264a0 <_fflush_r+0xc>
8112649c:	003b68fa 	trap	3
811264a0:	dc000115 	stw	r16,4(sp)
811264a4:	dfc00215 	stw	ra,8(sp)
811264a8:	2021883a 	mov	r16,r4
811264ac:	20000226 	beq	r4,zero,811264b8 <_fflush_r+0x24>
811264b0:	20800e17 	ldw	r2,56(r4)
811264b4:	10000c26 	beq	r2,zero,811264e8 <_fflush_r+0x54>
811264b8:	2880030f 	ldh	r2,12(r5)
811264bc:	1000051e 	bne	r2,zero,811264d4 <_fflush_r+0x40>
811264c0:	0005883a 	mov	r2,zero
811264c4:	dfc00217 	ldw	ra,8(sp)
811264c8:	dc000117 	ldw	r16,4(sp)
811264cc:	dec00304 	addi	sp,sp,12
811264d0:	f800283a 	ret
811264d4:	8009883a 	mov	r4,r16
811264d8:	dfc00217 	ldw	ra,8(sp)
811264dc:	dc000117 	ldw	r16,4(sp)
811264e0:	dec00304 	addi	sp,sp,12
811264e4:	11262701 	jmpi	81126270 <__sflush_r>
811264e8:	d9400015 	stw	r5,0(sp)
811264ec:	11268900 	call	81126890 <__sinit>
811264f0:	d9400017 	ldw	r5,0(sp)
811264f4:	003ff006 	br	811264b8 <__reset+0xfb1064b8>

811264f8 <fflush>:
811264f8:	20000526 	beq	r4,zero,81126510 <fflush+0x18>
811264fc:	00a04574 	movhi	r2,33045
81126500:	10ba8204 	addi	r2,r2,-5624
81126504:	200b883a 	mov	r5,r4
81126508:	11000017 	ldw	r4,0(r2)
8112650c:	11264941 	jmpi	81126494 <_fflush_r>
81126510:	00a04574 	movhi	r2,33045
81126514:	10ba8104 	addi	r2,r2,-5628
81126518:	11000017 	ldw	r4,0(r2)
8112651c:	016044b4 	movhi	r5,33042
81126520:	29592504 	addi	r5,r5,25748
81126524:	11275d01 	jmpi	811275d0 <_fwalk_reent>

81126528 <__fp_unlock>:
81126528:	0005883a 	mov	r2,zero
8112652c:	f800283a 	ret

81126530 <_cleanup_r>:
81126530:	016044f4 	movhi	r5,33043
81126534:	2978bb04 	addi	r5,r5,-7444
81126538:	11275d01 	jmpi	811275d0 <_fwalk_reent>

8112653c <__sinit.part.1>:
8112653c:	defff704 	addi	sp,sp,-36
81126540:	00e044b4 	movhi	r3,33042
81126544:	de00012e 	bgeu	sp,et,8112654c <__sinit.part.1+0x10>
81126548:	003b68fa 	trap	3
8112654c:	18d94c04 	addi	r3,r3,25904
81126550:	dfc00815 	stw	ra,32(sp)
81126554:	ddc00715 	stw	r23,28(sp)
81126558:	dd800615 	stw	r22,24(sp)
8112655c:	dd400515 	stw	r21,20(sp)
81126560:	dd000415 	stw	r20,16(sp)
81126564:	dcc00315 	stw	r19,12(sp)
81126568:	dc800215 	stw	r18,8(sp)
8112656c:	dc400115 	stw	r17,4(sp)
81126570:	dc000015 	stw	r16,0(sp)
81126574:	24000117 	ldw	r16,4(r4)
81126578:	20c00f15 	stw	r3,60(r4)
8112657c:	2080bb04 	addi	r2,r4,748
81126580:	00c000c4 	movi	r3,3
81126584:	20c0b915 	stw	r3,740(r4)
81126588:	2080ba15 	stw	r2,744(r4)
8112658c:	2000b815 	stw	zero,736(r4)
81126590:	05c00204 	movi	r23,8
81126594:	00800104 	movi	r2,4
81126598:	2025883a 	mov	r18,r4
8112659c:	b80d883a 	mov	r6,r23
811265a0:	81001704 	addi	r4,r16,92
811265a4:	000b883a 	mov	r5,zero
811265a8:	80000015 	stw	zero,0(r16)
811265ac:	80000115 	stw	zero,4(r16)
811265b0:	80000215 	stw	zero,8(r16)
811265b4:	8080030d 	sth	r2,12(r16)
811265b8:	80001915 	stw	zero,100(r16)
811265bc:	8000038d 	sth	zero,14(r16)
811265c0:	80000415 	stw	zero,16(r16)
811265c4:	80000515 	stw	zero,20(r16)
811265c8:	80000615 	stw	zero,24(r16)
811265cc:	111dc180 	call	8111dc18 <memset>
811265d0:	05a044b4 	movhi	r22,33042
811265d4:	94400217 	ldw	r17,8(r18)
811265d8:	056044b4 	movhi	r21,33042
811265dc:	052044b4 	movhi	r20,33042
811265e0:	04e044b4 	movhi	r19,33042
811265e4:	b5b90704 	addi	r22,r22,-7140
811265e8:	ad792004 	addi	r21,r21,-7040
811265ec:	a5394104 	addi	r20,r20,-6908
811265f0:	9cf95a04 	addi	r19,r19,-6808
811265f4:	85800815 	stw	r22,32(r16)
811265f8:	85400915 	stw	r21,36(r16)
811265fc:	85000a15 	stw	r20,40(r16)
81126600:	84c00b15 	stw	r19,44(r16)
81126604:	84000715 	stw	r16,28(r16)
81126608:	00800284 	movi	r2,10
8112660c:	8880030d 	sth	r2,12(r17)
81126610:	00800044 	movi	r2,1
81126614:	b80d883a 	mov	r6,r23
81126618:	89001704 	addi	r4,r17,92
8112661c:	000b883a 	mov	r5,zero
81126620:	88000015 	stw	zero,0(r17)
81126624:	88000115 	stw	zero,4(r17)
81126628:	88000215 	stw	zero,8(r17)
8112662c:	88001915 	stw	zero,100(r17)
81126630:	8880038d 	sth	r2,14(r17)
81126634:	88000415 	stw	zero,16(r17)
81126638:	88000515 	stw	zero,20(r17)
8112663c:	88000615 	stw	zero,24(r17)
81126640:	111dc180 	call	8111dc18 <memset>
81126644:	94000317 	ldw	r16,12(r18)
81126648:	00800484 	movi	r2,18
8112664c:	8c400715 	stw	r17,28(r17)
81126650:	8d800815 	stw	r22,32(r17)
81126654:	8d400915 	stw	r21,36(r17)
81126658:	8d000a15 	stw	r20,40(r17)
8112665c:	8cc00b15 	stw	r19,44(r17)
81126660:	8080030d 	sth	r2,12(r16)
81126664:	00800084 	movi	r2,2
81126668:	80000015 	stw	zero,0(r16)
8112666c:	80000115 	stw	zero,4(r16)
81126670:	80000215 	stw	zero,8(r16)
81126674:	80001915 	stw	zero,100(r16)
81126678:	8080038d 	sth	r2,14(r16)
8112667c:	80000415 	stw	zero,16(r16)
81126680:	80000515 	stw	zero,20(r16)
81126684:	80000615 	stw	zero,24(r16)
81126688:	b80d883a 	mov	r6,r23
8112668c:	000b883a 	mov	r5,zero
81126690:	81001704 	addi	r4,r16,92
81126694:	111dc180 	call	8111dc18 <memset>
81126698:	00800044 	movi	r2,1
8112669c:	84000715 	stw	r16,28(r16)
811266a0:	85800815 	stw	r22,32(r16)
811266a4:	85400915 	stw	r21,36(r16)
811266a8:	85000a15 	stw	r20,40(r16)
811266ac:	84c00b15 	stw	r19,44(r16)
811266b0:	90800e15 	stw	r2,56(r18)
811266b4:	dfc00817 	ldw	ra,32(sp)
811266b8:	ddc00717 	ldw	r23,28(sp)
811266bc:	dd800617 	ldw	r22,24(sp)
811266c0:	dd400517 	ldw	r21,20(sp)
811266c4:	dd000417 	ldw	r20,16(sp)
811266c8:	dcc00317 	ldw	r19,12(sp)
811266cc:	dc800217 	ldw	r18,8(sp)
811266d0:	dc400117 	ldw	r17,4(sp)
811266d4:	dc000017 	ldw	r16,0(sp)
811266d8:	dec00904 	addi	sp,sp,36
811266dc:	f800283a 	ret

811266e0 <__fp_lock>:
811266e0:	0005883a 	mov	r2,zero
811266e4:	f800283a 	ret

811266e8 <__sfmoreglue>:
811266e8:	defffc04 	addi	sp,sp,-16
811266ec:	de00012e 	bgeu	sp,et,811266f4 <__sfmoreglue+0xc>
811266f0:	003b68fa 	trap	3
811266f4:	dc400115 	stw	r17,4(sp)
811266f8:	2c7fffc4 	addi	r17,r5,-1
811266fc:	8c401a24 	muli	r17,r17,104
81126700:	dc800215 	stw	r18,8(sp)
81126704:	2825883a 	mov	r18,r5
81126708:	89401d04 	addi	r5,r17,116
8112670c:	dc000015 	stw	r16,0(sp)
81126710:	dfc00315 	stw	ra,12(sp)
81126714:	111d2b40 	call	8111d2b4 <_malloc_r>
81126718:	1021883a 	mov	r16,r2
8112671c:	10000726 	beq	r2,zero,8112673c <__sfmoreglue+0x54>
81126720:	11000304 	addi	r4,r2,12
81126724:	10000015 	stw	zero,0(r2)
81126728:	14800115 	stw	r18,4(r2)
8112672c:	11000215 	stw	r4,8(r2)
81126730:	89801a04 	addi	r6,r17,104
81126734:	000b883a 	mov	r5,zero
81126738:	111dc180 	call	8111dc18 <memset>
8112673c:	8005883a 	mov	r2,r16
81126740:	dfc00317 	ldw	ra,12(sp)
81126744:	dc800217 	ldw	r18,8(sp)
81126748:	dc400117 	ldw	r17,4(sp)
8112674c:	dc000017 	ldw	r16,0(sp)
81126750:	dec00404 	addi	sp,sp,16
81126754:	f800283a 	ret

81126758 <__sfp>:
81126758:	defffb04 	addi	sp,sp,-20
8112675c:	de00012e 	bgeu	sp,et,81126764 <__sfp+0xc>
81126760:	003b68fa 	trap	3
81126764:	dc000015 	stw	r16,0(sp)
81126768:	04204574 	movhi	r16,33045
8112676c:	843a8104 	addi	r16,r16,-5628
81126770:	dcc00315 	stw	r19,12(sp)
81126774:	2027883a 	mov	r19,r4
81126778:	81000017 	ldw	r4,0(r16)
8112677c:	dfc00415 	stw	ra,16(sp)
81126780:	dc800215 	stw	r18,8(sp)
81126784:	20800e17 	ldw	r2,56(r4)
81126788:	dc400115 	stw	r17,4(sp)
8112678c:	1000021e 	bne	r2,zero,81126798 <__sfp+0x40>
81126790:	112653c0 	call	8112653c <__sinit.part.1>
81126794:	81000017 	ldw	r4,0(r16)
81126798:	2480b804 	addi	r18,r4,736
8112679c:	047fffc4 	movi	r17,-1
811267a0:	91000117 	ldw	r4,4(r18)
811267a4:	94000217 	ldw	r16,8(r18)
811267a8:	213fffc4 	addi	r4,r4,-1
811267ac:	20000a16 	blt	r4,zero,811267d8 <__sfp+0x80>
811267b0:	8080030f 	ldh	r2,12(r16)
811267b4:	10000c26 	beq	r2,zero,811267e8 <__sfp+0x90>
811267b8:	80c01d04 	addi	r3,r16,116
811267bc:	00000206 	br	811267c8 <__sfp+0x70>
811267c0:	18bfe60f 	ldh	r2,-104(r3)
811267c4:	10000826 	beq	r2,zero,811267e8 <__sfp+0x90>
811267c8:	213fffc4 	addi	r4,r4,-1
811267cc:	1c3ffd04 	addi	r16,r3,-12
811267d0:	18c01a04 	addi	r3,r3,104
811267d4:	247ffa1e 	bne	r4,r17,811267c0 <__reset+0xfb1067c0>
811267d8:	90800017 	ldw	r2,0(r18)
811267dc:	10001d26 	beq	r2,zero,81126854 <__sfp+0xfc>
811267e0:	1025883a 	mov	r18,r2
811267e4:	003fee06 	br	811267a0 <__reset+0xfb1067a0>
811267e8:	00bfffc4 	movi	r2,-1
811267ec:	8080038d 	sth	r2,14(r16)
811267f0:	00800044 	movi	r2,1
811267f4:	8080030d 	sth	r2,12(r16)
811267f8:	80001915 	stw	zero,100(r16)
811267fc:	80000015 	stw	zero,0(r16)
81126800:	80000215 	stw	zero,8(r16)
81126804:	80000115 	stw	zero,4(r16)
81126808:	80000415 	stw	zero,16(r16)
8112680c:	80000515 	stw	zero,20(r16)
81126810:	80000615 	stw	zero,24(r16)
81126814:	01800204 	movi	r6,8
81126818:	000b883a 	mov	r5,zero
8112681c:	81001704 	addi	r4,r16,92
81126820:	111dc180 	call	8111dc18 <memset>
81126824:	8005883a 	mov	r2,r16
81126828:	80000c15 	stw	zero,48(r16)
8112682c:	80000d15 	stw	zero,52(r16)
81126830:	80001115 	stw	zero,68(r16)
81126834:	80001215 	stw	zero,72(r16)
81126838:	dfc00417 	ldw	ra,16(sp)
8112683c:	dcc00317 	ldw	r19,12(sp)
81126840:	dc800217 	ldw	r18,8(sp)
81126844:	dc400117 	ldw	r17,4(sp)
81126848:	dc000017 	ldw	r16,0(sp)
8112684c:	dec00504 	addi	sp,sp,20
81126850:	f800283a 	ret
81126854:	01400104 	movi	r5,4
81126858:	9809883a 	mov	r4,r19
8112685c:	11266e80 	call	811266e8 <__sfmoreglue>
81126860:	90800015 	stw	r2,0(r18)
81126864:	103fde1e 	bne	r2,zero,811267e0 <__reset+0xfb1067e0>
81126868:	00800304 	movi	r2,12
8112686c:	98800015 	stw	r2,0(r19)
81126870:	0005883a 	mov	r2,zero
81126874:	003ff006 	br	81126838 <__reset+0xfb106838>

81126878 <_cleanup>:
81126878:	00a04574 	movhi	r2,33045
8112687c:	10ba8104 	addi	r2,r2,-5628
81126880:	11000017 	ldw	r4,0(r2)
81126884:	016044f4 	movhi	r5,33043
81126888:	2978bb04 	addi	r5,r5,-7444
8112688c:	11275d01 	jmpi	811275d0 <_fwalk_reent>

81126890 <__sinit>:
81126890:	20800e17 	ldw	r2,56(r4)
81126894:	10000126 	beq	r2,zero,8112689c <__sinit+0xc>
81126898:	f800283a 	ret
8112689c:	112653c1 	jmpi	8112653c <__sinit.part.1>

811268a0 <__sfp_lock_acquire>:
811268a0:	f800283a 	ret

811268a4 <__sfp_lock_release>:
811268a4:	f800283a 	ret

811268a8 <__sinit_lock_acquire>:
811268a8:	f800283a 	ret

811268ac <__sinit_lock_release>:
811268ac:	f800283a 	ret

811268b0 <__fp_lock_all>:
811268b0:	00a04574 	movhi	r2,33045
811268b4:	10ba8204 	addi	r2,r2,-5624
811268b8:	11000017 	ldw	r4,0(r2)
811268bc:	016044b4 	movhi	r5,33042
811268c0:	2959b804 	addi	r5,r5,26336
811268c4:	11275041 	jmpi	81127504 <_fwalk>

811268c8 <__fp_unlock_all>:
811268c8:	00a04574 	movhi	r2,33045
811268cc:	10ba8204 	addi	r2,r2,-5624
811268d0:	11000017 	ldw	r4,0(r2)
811268d4:	016044b4 	movhi	r5,33042
811268d8:	29594a04 	addi	r5,r5,25896
811268dc:	11275041 	jmpi	81127504 <_fwalk>

811268e0 <__sflags>:
811268e0:	28800007 	ldb	r2,0(r5)
811268e4:	00c01c84 	movi	r3,114
811268e8:	10c02426 	beq	r2,r3,8112697c <__sflags+0x9c>
811268ec:	00c01dc4 	movi	r3,119
811268f0:	10c01e26 	beq	r2,r3,8112696c <__sflags+0x8c>
811268f4:	00c01844 	movi	r3,97
811268f8:	10c00426 	beq	r2,r3,8112690c <__sflags+0x2c>
811268fc:	00800584 	movi	r2,22
81126900:	20800015 	stw	r2,0(r4)
81126904:	0005883a 	mov	r2,zero
81126908:	f800283a 	ret
8112690c:	02c08204 	movi	r11,520
81126910:	01000044 	movi	r4,1
81126914:	00804204 	movi	r2,264
81126918:	01c00ac4 	movi	r7,43
8112691c:	02bff8c4 	movi	r10,-29
81126920:	027fff04 	movi	r9,-4
81126924:	02001e04 	movi	r8,120
81126928:	29400044 	addi	r5,r5,1
8112692c:	28c00007 	ldb	r3,0(r5)
81126930:	18000626 	beq	r3,zero,8112694c <__sflags+0x6c>
81126934:	19c00826 	beq	r3,r7,81126958 <__sflags+0x78>
81126938:	1a3ffb1e 	bne	r3,r8,81126928 <__reset+0xfb106928>
8112693c:	29400044 	addi	r5,r5,1
81126940:	28c00007 	ldb	r3,0(r5)
81126944:	21020014 	ori	r4,r4,2048
81126948:	183ffa1e 	bne	r3,zero,81126934 <__reset+0xfb106934>
8112694c:	22c8b03a 	or	r4,r4,r11
81126950:	31000015 	stw	r4,0(r6)
81126954:	f800283a 	ret
81126958:	1284703a 	and	r2,r2,r10
8112695c:	2248703a 	and	r4,r4,r9
81126960:	10800414 	ori	r2,r2,16
81126964:	21000094 	ori	r4,r4,2
81126968:	003fef06 	br	81126928 <__reset+0xfb106928>
8112696c:	02c18004 	movi	r11,1536
81126970:	01000044 	movi	r4,1
81126974:	00800204 	movi	r2,8
81126978:	003fe706 	br	81126918 <__reset+0xfb106918>
8112697c:	0017883a 	mov	r11,zero
81126980:	0009883a 	mov	r4,zero
81126984:	00800104 	movi	r2,4
81126988:	003fe306 	br	81126918 <__reset+0xfb106918>

8112698c <_fread_r>:
8112698c:	defff404 	addi	sp,sp,-48
81126990:	de00012e 	bgeu	sp,et,81126998 <_fread_r+0xc>
81126994:	003b68fa 	trap	3
81126998:	dd800815 	stw	r22,32(sp)
8112699c:	39ad383a 	mul	r22,r7,r6
811269a0:	dc000215 	stw	r16,8(sp)
811269a4:	dfc00b15 	stw	ra,44(sp)
811269a8:	df000a15 	stw	fp,40(sp)
811269ac:	ddc00915 	stw	r23,36(sp)
811269b0:	dd400715 	stw	r21,28(sp)
811269b4:	dd000615 	stw	r20,24(sp)
811269b8:	dcc00515 	stw	r19,20(sp)
811269bc:	dc800415 	stw	r18,16(sp)
811269c0:	dc400315 	stw	r17,12(sp)
811269c4:	dc000c17 	ldw	r16,48(sp)
811269c8:	b0003b26 	beq	r22,zero,81126ab8 <_fread_r+0x12c>
811269cc:	302f883a 	mov	r23,r6
811269d0:	382b883a 	mov	r21,r7
811269d4:	2029883a 	mov	r20,r4
811269d8:	2827883a 	mov	r19,r5
811269dc:	20000226 	beq	r4,zero,811269e8 <_fread_r+0x5c>
811269e0:	20800e17 	ldw	r2,56(r4)
811269e4:	10006e26 	beq	r2,zero,81126ba0 <_fread_r+0x214>
811269e8:	8080030b 	ldhu	r2,12(r16)
811269ec:	10c8000c 	andi	r3,r2,8192
811269f0:	1800061e 	bne	r3,zero,81126a0c <_fread_r+0x80>
811269f4:	81001917 	ldw	r4,100(r16)
811269f8:	00f7ffc4 	movi	r3,-8193
811269fc:	10880014 	ori	r2,r2,8192
81126a00:	20c6703a 	and	r3,r4,r3
81126a04:	8080030d 	sth	r2,12(r16)
81126a08:	80c01915 	stw	r3,100(r16)
81126a0c:	84400117 	ldw	r17,4(r16)
81126a10:	88005f16 	blt	r17,zero,81126b90 <_fread_r+0x204>
81126a14:	8809883a 	mov	r4,r17
81126a18:	1080008c 	andi	r2,r2,2
81126a1c:	1000281e 	bne	r2,zero,81126ac0 <_fread_r+0x134>
81126a20:	b025883a 	mov	r18,r22
81126a24:	00000b06 	br	81126a54 <_fread_r+0xc8>
81126a28:	111dac80 	call	8111dac8 <memcpy>
81126a2c:	80800017 	ldw	r2,0(r16)
81126a30:	9c67883a 	add	r19,r19,r17
81126a34:	9465c83a 	sub	r18,r18,r17
81126a38:	1463883a 	add	r17,r2,r17
81126a3c:	800b883a 	mov	r5,r16
81126a40:	a009883a 	mov	r4,r20
81126a44:	84400015 	stw	r17,0(r16)
81126a48:	111e0940 	call	8111e094 <__srefill_r>
81126a4c:	10004c1e 	bne	r2,zero,81126b80 <_fread_r+0x1f4>
81126a50:	84400117 	ldw	r17,4(r16)
81126a54:	880d883a 	mov	r6,r17
81126a58:	9809883a 	mov	r4,r19
81126a5c:	81400017 	ldw	r5,0(r16)
81126a60:	8cbff136 	bltu	r17,r18,81126a28 <__reset+0xfb106a28>
81126a64:	900d883a 	mov	r6,r18
81126a68:	111dac80 	call	8111dac8 <memcpy>
81126a6c:	80c00117 	ldw	r3,4(r16)
81126a70:	81000017 	ldw	r4,0(r16)
81126a74:	a805883a 	mov	r2,r21
81126a78:	1c87c83a 	sub	r3,r3,r18
81126a7c:	24a5883a 	add	r18,r4,r18
81126a80:	80c00115 	stw	r3,4(r16)
81126a84:	84800015 	stw	r18,0(r16)
81126a88:	dfc00b17 	ldw	ra,44(sp)
81126a8c:	df000a17 	ldw	fp,40(sp)
81126a90:	ddc00917 	ldw	r23,36(sp)
81126a94:	dd800817 	ldw	r22,32(sp)
81126a98:	dd400717 	ldw	r21,28(sp)
81126a9c:	dd000617 	ldw	r20,24(sp)
81126aa0:	dcc00517 	ldw	r19,20(sp)
81126aa4:	dc800417 	ldw	r18,16(sp)
81126aa8:	dc400317 	ldw	r17,12(sp)
81126aac:	dc000217 	ldw	r16,8(sp)
81126ab0:	dec00c04 	addi	sp,sp,48
81126ab4:	f800283a 	ret
81126ab8:	0005883a 	mov	r2,zero
81126abc:	003ff206 	br	81126a88 <__reset+0xfb106a88>
81126ac0:	b007883a 	mov	r3,r22
81126ac4:	2580012e 	bgeu	r4,r22,81126acc <_fread_r+0x140>
81126ac8:	2007883a 	mov	r3,r4
81126acc:	81400017 	ldw	r5,0(r16)
81126ad0:	180d883a 	mov	r6,r3
81126ad4:	9809883a 	mov	r4,r19
81126ad8:	d8c00115 	stw	r3,4(sp)
81126adc:	111dac80 	call	8111dac8 <memcpy>
81126ae0:	d8c00117 	ldw	r3,4(sp)
81126ae4:	84400017 	ldw	r17,0(r16)
81126ae8:	80800117 	ldw	r2,4(r16)
81126aec:	81400c17 	ldw	r5,48(r16)
81126af0:	88e3883a 	add	r17,r17,r3
81126af4:	10c5c83a 	sub	r2,r2,r3
81126af8:	84400015 	stw	r17,0(r16)
81126afc:	80800115 	stw	r2,4(r16)
81126b00:	b0e5c83a 	sub	r18,r22,r3
81126b04:	28002b26 	beq	r5,zero,81126bb4 <_fread_r+0x228>
81126b08:	90002b26 	beq	r18,zero,81126bb8 <_fread_r+0x22c>
81126b0c:	80801004 	addi	r2,r16,64
81126b10:	28800526 	beq	r5,r2,81126b28 <_fread_r+0x19c>
81126b14:	a009883a 	mov	r4,r20
81126b18:	d8c00115 	stw	r3,4(sp)
81126b1c:	1126d280 	call	81126d28 <_free_r>
81126b20:	d8c00117 	ldw	r3,4(sp)
81126b24:	84400017 	ldw	r17,0(r16)
81126b28:	80000c15 	stw	zero,48(r16)
81126b2c:	80800517 	ldw	r2,20(r16)
81126b30:	87000417 	ldw	fp,16(r16)
81126b34:	98e7883a 	add	r19,r19,r3
81126b38:	d8800015 	stw	r2,0(sp)
81126b3c:	00000106 	br	81126b44 <_fread_r+0x1b8>
81126b40:	90001d26 	beq	r18,zero,81126bb8 <_fread_r+0x22c>
81126b44:	84c00415 	stw	r19,16(r16)
81126b48:	84800515 	stw	r18,20(r16)
81126b4c:	84c00015 	stw	r19,0(r16)
81126b50:	a009883a 	mov	r4,r20
81126b54:	800b883a 	mov	r5,r16
81126b58:	111e0940 	call	8111e094 <__srefill_r>
81126b5c:	d9000017 	ldw	r4,0(sp)
81126b60:	80c00117 	ldw	r3,4(r16)
81126b64:	87000415 	stw	fp,16(r16)
81126b68:	81000515 	stw	r4,20(r16)
81126b6c:	84400015 	stw	r17,0(r16)
81126b70:	80000115 	stw	zero,4(r16)
81126b74:	90e5c83a 	sub	r18,r18,r3
81126b78:	98e7883a 	add	r19,r19,r3
81126b7c:	103ff026 	beq	r2,zero,81126b40 <__reset+0xfb106b40>
81126b80:	b80b883a 	mov	r5,r23
81126b84:	b489c83a 	sub	r4,r22,r18
81126b88:	11300b00 	call	811300b0 <__udivsi3>
81126b8c:	003fbe06 	br	81126a88 <__reset+0xfb106a88>
81126b90:	80000115 	stw	zero,4(r16)
81126b94:	0009883a 	mov	r4,zero
81126b98:	0023883a 	mov	r17,zero
81126b9c:	003f9e06 	br	81126a18 <__reset+0xfb106a18>
81126ba0:	11268900 	call	81126890 <__sinit>
81126ba4:	8080030b 	ldhu	r2,12(r16)
81126ba8:	10c8000c 	andi	r3,r2,8192
81126bac:	183f971e 	bne	r3,zero,81126a0c <__reset+0xfb106a0c>
81126bb0:	003f9006 	br	811269f4 <__reset+0xfb1069f4>
81126bb4:	903fdd1e 	bne	r18,zero,81126b2c <__reset+0xfb106b2c>
81126bb8:	a805883a 	mov	r2,r21
81126bbc:	003fb206 	br	81126a88 <__reset+0xfb106a88>

81126bc0 <fread>:
81126bc0:	defffe04 	addi	sp,sp,-8
81126bc4:	00a04574 	movhi	r2,33045
81126bc8:	de00012e 	bgeu	sp,et,81126bd0 <fread+0x10>
81126bcc:	003b68fa 	trap	3
81126bd0:	10ba8204 	addi	r2,r2,-5624
81126bd4:	d9c00015 	stw	r7,0(sp)
81126bd8:	300f883a 	mov	r7,r6
81126bdc:	280d883a 	mov	r6,r5
81126be0:	200b883a 	mov	r5,r4
81126be4:	11000017 	ldw	r4,0(r2)
81126be8:	dfc00115 	stw	ra,4(sp)
81126bec:	112698c0 	call	8112698c <_fread_r>
81126bf0:	dfc00117 	ldw	ra,4(sp)
81126bf4:	dec00204 	addi	sp,sp,8
81126bf8:	f800283a 	ret

81126bfc <_malloc_trim_r>:
81126bfc:	defffb04 	addi	sp,sp,-20
81126c00:	de00012e 	bgeu	sp,et,81126c08 <_malloc_trim_r+0xc>
81126c04:	003b68fa 	trap	3
81126c08:	dcc00315 	stw	r19,12(sp)
81126c0c:	04e04574 	movhi	r19,33045
81126c10:	dc800215 	stw	r18,8(sp)
81126c14:	dc400115 	stw	r17,4(sp)
81126c18:	dc000015 	stw	r16,0(sp)
81126c1c:	dfc00415 	stw	ra,16(sp)
81126c20:	2821883a 	mov	r16,r5
81126c24:	9cf44004 	addi	r19,r19,-12032
81126c28:	2025883a 	mov	r18,r4
81126c2c:	11340b00 	call	811340b0 <__malloc_lock>
81126c30:	98800217 	ldw	r2,8(r19)
81126c34:	14400117 	ldw	r17,4(r2)
81126c38:	00bfff04 	movi	r2,-4
81126c3c:	88a2703a 	and	r17,r17,r2
81126c40:	8c21c83a 	sub	r16,r17,r16
81126c44:	8403fbc4 	addi	r16,r16,4079
81126c48:	8020d33a 	srli	r16,r16,12
81126c4c:	0083ffc4 	movi	r2,4095
81126c50:	843fffc4 	addi	r16,r16,-1
81126c54:	8020933a 	slli	r16,r16,12
81126c58:	1400060e 	bge	r2,r16,81126c74 <_malloc_trim_r+0x78>
81126c5c:	000b883a 	mov	r5,zero
81126c60:	9009883a 	mov	r4,r18
81126c64:	111e2700 	call	8111e270 <_sbrk_r>
81126c68:	98c00217 	ldw	r3,8(r19)
81126c6c:	1c47883a 	add	r3,r3,r17
81126c70:	10c00a26 	beq	r2,r3,81126c9c <_malloc_trim_r+0xa0>
81126c74:	9009883a 	mov	r4,r18
81126c78:	11341d80 	call	811341d8 <__malloc_unlock>
81126c7c:	0005883a 	mov	r2,zero
81126c80:	dfc00417 	ldw	ra,16(sp)
81126c84:	dcc00317 	ldw	r19,12(sp)
81126c88:	dc800217 	ldw	r18,8(sp)
81126c8c:	dc400117 	ldw	r17,4(sp)
81126c90:	dc000017 	ldw	r16,0(sp)
81126c94:	dec00504 	addi	sp,sp,20
81126c98:	f800283a 	ret
81126c9c:	040bc83a 	sub	r5,zero,r16
81126ca0:	9009883a 	mov	r4,r18
81126ca4:	111e2700 	call	8111e270 <_sbrk_r>
81126ca8:	00ffffc4 	movi	r3,-1
81126cac:	10c00d26 	beq	r2,r3,81126ce4 <_malloc_trim_r+0xe8>
81126cb0:	00e04574 	movhi	r3,33045
81126cb4:	18fb8104 	addi	r3,r3,-4604
81126cb8:	18800017 	ldw	r2,0(r3)
81126cbc:	99000217 	ldw	r4,8(r19)
81126cc0:	8c23c83a 	sub	r17,r17,r16
81126cc4:	8c400054 	ori	r17,r17,1
81126cc8:	1421c83a 	sub	r16,r2,r16
81126ccc:	24400115 	stw	r17,4(r4)
81126cd0:	9009883a 	mov	r4,r18
81126cd4:	1c000015 	stw	r16,0(r3)
81126cd8:	11341d80 	call	811341d8 <__malloc_unlock>
81126cdc:	00800044 	movi	r2,1
81126ce0:	003fe706 	br	81126c80 <__reset+0xfb106c80>
81126ce4:	000b883a 	mov	r5,zero
81126ce8:	9009883a 	mov	r4,r18
81126cec:	111e2700 	call	8111e270 <_sbrk_r>
81126cf0:	99000217 	ldw	r4,8(r19)
81126cf4:	014003c4 	movi	r5,15
81126cf8:	1107c83a 	sub	r3,r2,r4
81126cfc:	28ffdd0e 	bge	r5,r3,81126c74 <__reset+0xfb106c74>
81126d00:	01604574 	movhi	r5,33045
81126d04:	297a8304 	addi	r5,r5,-5620
81126d08:	29400017 	ldw	r5,0(r5)
81126d0c:	18c00054 	ori	r3,r3,1
81126d10:	20c00115 	stw	r3,4(r4)
81126d14:	00e04574 	movhi	r3,33045
81126d18:	1145c83a 	sub	r2,r2,r5
81126d1c:	18fb8104 	addi	r3,r3,-4604
81126d20:	18800015 	stw	r2,0(r3)
81126d24:	003fd306 	br	81126c74 <__reset+0xfb106c74>

81126d28 <_free_r>:
81126d28:	28004326 	beq	r5,zero,81126e38 <_free_r+0x110>
81126d2c:	defffd04 	addi	sp,sp,-12
81126d30:	de00012e 	bgeu	sp,et,81126d38 <_free_r+0x10>
81126d34:	003b68fa 	trap	3
81126d38:	dc400115 	stw	r17,4(sp)
81126d3c:	dc000015 	stw	r16,0(sp)
81126d40:	2023883a 	mov	r17,r4
81126d44:	2821883a 	mov	r16,r5
81126d48:	dfc00215 	stw	ra,8(sp)
81126d4c:	11340b00 	call	811340b0 <__malloc_lock>
81126d50:	81ffff17 	ldw	r7,-4(r16)
81126d54:	00bfff84 	movi	r2,-2
81126d58:	01204574 	movhi	r4,33045
81126d5c:	81bffe04 	addi	r6,r16,-8
81126d60:	3884703a 	and	r2,r7,r2
81126d64:	21344004 	addi	r4,r4,-12032
81126d68:	308b883a 	add	r5,r6,r2
81126d6c:	2a400117 	ldw	r9,4(r5)
81126d70:	22000217 	ldw	r8,8(r4)
81126d74:	00ffff04 	movi	r3,-4
81126d78:	48c6703a 	and	r3,r9,r3
81126d7c:	2a005726 	beq	r5,r8,81126edc <_free_r+0x1b4>
81126d80:	28c00115 	stw	r3,4(r5)
81126d84:	39c0004c 	andi	r7,r7,1
81126d88:	3800091e 	bne	r7,zero,81126db0 <_free_r+0x88>
81126d8c:	823ffe17 	ldw	r8,-8(r16)
81126d90:	22400204 	addi	r9,r4,8
81126d94:	320dc83a 	sub	r6,r6,r8
81126d98:	31c00217 	ldw	r7,8(r6)
81126d9c:	1205883a 	add	r2,r2,r8
81126da0:	3a406526 	beq	r7,r9,81126f38 <_free_r+0x210>
81126da4:	32000317 	ldw	r8,12(r6)
81126da8:	3a000315 	stw	r8,12(r7)
81126dac:	41c00215 	stw	r7,8(r8)
81126db0:	28cf883a 	add	r7,r5,r3
81126db4:	39c00117 	ldw	r7,4(r7)
81126db8:	39c0004c 	andi	r7,r7,1
81126dbc:	38003a26 	beq	r7,zero,81126ea8 <_free_r+0x180>
81126dc0:	10c00054 	ori	r3,r2,1
81126dc4:	30c00115 	stw	r3,4(r6)
81126dc8:	3087883a 	add	r3,r6,r2
81126dcc:	18800015 	stw	r2,0(r3)
81126dd0:	00c07fc4 	movi	r3,511
81126dd4:	18801936 	bltu	r3,r2,81126e3c <_free_r+0x114>
81126dd8:	1004d0fa 	srli	r2,r2,3
81126ddc:	01c00044 	movi	r7,1
81126de0:	21400117 	ldw	r5,4(r4)
81126de4:	10c00044 	addi	r3,r2,1
81126de8:	18c7883a 	add	r3,r3,r3
81126dec:	1005d0ba 	srai	r2,r2,2
81126df0:	18c7883a 	add	r3,r3,r3
81126df4:	18c7883a 	add	r3,r3,r3
81126df8:	1907883a 	add	r3,r3,r4
81126dfc:	3884983a 	sll	r2,r7,r2
81126e00:	19c00017 	ldw	r7,0(r3)
81126e04:	1a3ffe04 	addi	r8,r3,-8
81126e08:	1144b03a 	or	r2,r2,r5
81126e0c:	32000315 	stw	r8,12(r6)
81126e10:	31c00215 	stw	r7,8(r6)
81126e14:	20800115 	stw	r2,4(r4)
81126e18:	19800015 	stw	r6,0(r3)
81126e1c:	39800315 	stw	r6,12(r7)
81126e20:	8809883a 	mov	r4,r17
81126e24:	dfc00217 	ldw	ra,8(sp)
81126e28:	dc400117 	ldw	r17,4(sp)
81126e2c:	dc000017 	ldw	r16,0(sp)
81126e30:	dec00304 	addi	sp,sp,12
81126e34:	11341d81 	jmpi	811341d8 <__malloc_unlock>
81126e38:	f800283a 	ret
81126e3c:	100ad27a 	srli	r5,r2,9
81126e40:	00c00104 	movi	r3,4
81126e44:	19404a36 	bltu	r3,r5,81126f70 <_free_r+0x248>
81126e48:	100ad1ba 	srli	r5,r2,6
81126e4c:	28c00e44 	addi	r3,r5,57
81126e50:	18c7883a 	add	r3,r3,r3
81126e54:	29400e04 	addi	r5,r5,56
81126e58:	18c7883a 	add	r3,r3,r3
81126e5c:	18c7883a 	add	r3,r3,r3
81126e60:	1909883a 	add	r4,r3,r4
81126e64:	20c00017 	ldw	r3,0(r4)
81126e68:	01e04574 	movhi	r7,33045
81126e6c:	213ffe04 	addi	r4,r4,-8
81126e70:	39f44004 	addi	r7,r7,-12032
81126e74:	20c04426 	beq	r4,r3,81126f88 <_free_r+0x260>
81126e78:	01ffff04 	movi	r7,-4
81126e7c:	19400117 	ldw	r5,4(r3)
81126e80:	29ca703a 	and	r5,r5,r7
81126e84:	1140022e 	bgeu	r2,r5,81126e90 <_free_r+0x168>
81126e88:	18c00217 	ldw	r3,8(r3)
81126e8c:	20fffb1e 	bne	r4,r3,81126e7c <__reset+0xfb106e7c>
81126e90:	19000317 	ldw	r4,12(r3)
81126e94:	31000315 	stw	r4,12(r6)
81126e98:	30c00215 	stw	r3,8(r6)
81126e9c:	21800215 	stw	r6,8(r4)
81126ea0:	19800315 	stw	r6,12(r3)
81126ea4:	003fde06 	br	81126e20 <__reset+0xfb106e20>
81126ea8:	29c00217 	ldw	r7,8(r5)
81126eac:	10c5883a 	add	r2,r2,r3
81126eb0:	00e04574 	movhi	r3,33045
81126eb4:	18f44204 	addi	r3,r3,-12024
81126eb8:	38c03b26 	beq	r7,r3,81126fa8 <_free_r+0x280>
81126ebc:	2a000317 	ldw	r8,12(r5)
81126ec0:	11400054 	ori	r5,r2,1
81126ec4:	3087883a 	add	r3,r6,r2
81126ec8:	3a000315 	stw	r8,12(r7)
81126ecc:	41c00215 	stw	r7,8(r8)
81126ed0:	31400115 	stw	r5,4(r6)
81126ed4:	18800015 	stw	r2,0(r3)
81126ed8:	003fbd06 	br	81126dd0 <__reset+0xfb106dd0>
81126edc:	39c0004c 	andi	r7,r7,1
81126ee0:	10c5883a 	add	r2,r2,r3
81126ee4:	3800071e 	bne	r7,zero,81126f04 <_free_r+0x1dc>
81126ee8:	81fffe17 	ldw	r7,-8(r16)
81126eec:	31cdc83a 	sub	r6,r6,r7
81126ef0:	30c00317 	ldw	r3,12(r6)
81126ef4:	31400217 	ldw	r5,8(r6)
81126ef8:	11c5883a 	add	r2,r2,r7
81126efc:	28c00315 	stw	r3,12(r5)
81126f00:	19400215 	stw	r5,8(r3)
81126f04:	10c00054 	ori	r3,r2,1
81126f08:	30c00115 	stw	r3,4(r6)
81126f0c:	00e04574 	movhi	r3,33045
81126f10:	18fa8404 	addi	r3,r3,-5616
81126f14:	18c00017 	ldw	r3,0(r3)
81126f18:	21800215 	stw	r6,8(r4)
81126f1c:	10ffc036 	bltu	r2,r3,81126e20 <__reset+0xfb106e20>
81126f20:	00a04574 	movhi	r2,33045
81126f24:	10baf404 	addi	r2,r2,-5168
81126f28:	11400017 	ldw	r5,0(r2)
81126f2c:	8809883a 	mov	r4,r17
81126f30:	1126bfc0 	call	81126bfc <_malloc_trim_r>
81126f34:	003fba06 	br	81126e20 <__reset+0xfb106e20>
81126f38:	28c9883a 	add	r4,r5,r3
81126f3c:	21000117 	ldw	r4,4(r4)
81126f40:	2100004c 	andi	r4,r4,1
81126f44:	2000391e 	bne	r4,zero,8112702c <_free_r+0x304>
81126f48:	29c00217 	ldw	r7,8(r5)
81126f4c:	29000317 	ldw	r4,12(r5)
81126f50:	1885883a 	add	r2,r3,r2
81126f54:	10c00054 	ori	r3,r2,1
81126f58:	39000315 	stw	r4,12(r7)
81126f5c:	21c00215 	stw	r7,8(r4)
81126f60:	30c00115 	stw	r3,4(r6)
81126f64:	308d883a 	add	r6,r6,r2
81126f68:	30800015 	stw	r2,0(r6)
81126f6c:	003fac06 	br	81126e20 <__reset+0xfb106e20>
81126f70:	00c00504 	movi	r3,20
81126f74:	19401536 	bltu	r3,r5,81126fcc <_free_r+0x2a4>
81126f78:	28c01704 	addi	r3,r5,92
81126f7c:	18c7883a 	add	r3,r3,r3
81126f80:	294016c4 	addi	r5,r5,91
81126f84:	003fb406 	br	81126e58 <__reset+0xfb106e58>
81126f88:	280bd0ba 	srai	r5,r5,2
81126f8c:	00c00044 	movi	r3,1
81126f90:	38800117 	ldw	r2,4(r7)
81126f94:	194a983a 	sll	r5,r3,r5
81126f98:	2007883a 	mov	r3,r4
81126f9c:	2884b03a 	or	r2,r5,r2
81126fa0:	38800115 	stw	r2,4(r7)
81126fa4:	003fbb06 	br	81126e94 <__reset+0xfb106e94>
81126fa8:	21800515 	stw	r6,20(r4)
81126fac:	21800415 	stw	r6,16(r4)
81126fb0:	10c00054 	ori	r3,r2,1
81126fb4:	31c00315 	stw	r7,12(r6)
81126fb8:	31c00215 	stw	r7,8(r6)
81126fbc:	30c00115 	stw	r3,4(r6)
81126fc0:	308d883a 	add	r6,r6,r2
81126fc4:	30800015 	stw	r2,0(r6)
81126fc8:	003f9506 	br	81126e20 <__reset+0xfb106e20>
81126fcc:	00c01504 	movi	r3,84
81126fd0:	19400536 	bltu	r3,r5,81126fe8 <_free_r+0x2c0>
81126fd4:	100ad33a 	srli	r5,r2,12
81126fd8:	28c01bc4 	addi	r3,r5,111
81126fdc:	18c7883a 	add	r3,r3,r3
81126fe0:	29401b84 	addi	r5,r5,110
81126fe4:	003f9c06 	br	81126e58 <__reset+0xfb106e58>
81126fe8:	00c05504 	movi	r3,340
81126fec:	19400536 	bltu	r3,r5,81127004 <_free_r+0x2dc>
81126ff0:	100ad3fa 	srli	r5,r2,15
81126ff4:	28c01e04 	addi	r3,r5,120
81126ff8:	18c7883a 	add	r3,r3,r3
81126ffc:	29401dc4 	addi	r5,r5,119
81127000:	003f9506 	br	81126e58 <__reset+0xfb106e58>
81127004:	00c15504 	movi	r3,1364
81127008:	19400536 	bltu	r3,r5,81127020 <_free_r+0x2f8>
8112700c:	100ad4ba 	srli	r5,r2,18
81127010:	28c01f44 	addi	r3,r5,125
81127014:	18c7883a 	add	r3,r3,r3
81127018:	29401f04 	addi	r5,r5,124
8112701c:	003f8e06 	br	81126e58 <__reset+0xfb106e58>
81127020:	00c03f84 	movi	r3,254
81127024:	01401f84 	movi	r5,126
81127028:	003f8b06 	br	81126e58 <__reset+0xfb106e58>
8112702c:	10c00054 	ori	r3,r2,1
81127030:	30c00115 	stw	r3,4(r6)
81127034:	308d883a 	add	r6,r6,r2
81127038:	30800015 	stw	r2,0(r6)
8112703c:	003f7806 	br	81126e20 <__reset+0xfb106e20>

81127040 <__sfvwrite_r>:
81127040:	30800217 	ldw	r2,8(r6)
81127044:	10006926 	beq	r2,zero,811271ec <__sfvwrite_r+0x1ac>
81127048:	defff404 	addi	sp,sp,-48
8112704c:	de00012e 	bgeu	sp,et,81127054 <__sfvwrite_r+0x14>
81127050:	003b68fa 	trap	3
81127054:	28c0030b 	ldhu	r3,12(r5)
81127058:	dd400715 	stw	r21,28(sp)
8112705c:	dd000615 	stw	r20,24(sp)
81127060:	dc000215 	stw	r16,8(sp)
81127064:	dfc00b15 	stw	ra,44(sp)
81127068:	df000a15 	stw	fp,40(sp)
8112706c:	ddc00915 	stw	r23,36(sp)
81127070:	dd800815 	stw	r22,32(sp)
81127074:	dcc00515 	stw	r19,20(sp)
81127078:	dc800415 	stw	r18,16(sp)
8112707c:	dc400315 	stw	r17,12(sp)
81127080:	1880020c 	andi	r2,r3,8
81127084:	2821883a 	mov	r16,r5
81127088:	202b883a 	mov	r21,r4
8112708c:	3029883a 	mov	r20,r6
81127090:	10002726 	beq	r2,zero,81127130 <__sfvwrite_r+0xf0>
81127094:	28800417 	ldw	r2,16(r5)
81127098:	10002526 	beq	r2,zero,81127130 <__sfvwrite_r+0xf0>
8112709c:	1880008c 	andi	r2,r3,2
811270a0:	a4400017 	ldw	r17,0(r20)
811270a4:	10002a26 	beq	r2,zero,81127150 <__sfvwrite_r+0x110>
811270a8:	05a00034 	movhi	r22,32768
811270ac:	0027883a 	mov	r19,zero
811270b0:	0025883a 	mov	r18,zero
811270b4:	b5bf0004 	addi	r22,r22,-1024
811270b8:	980d883a 	mov	r6,r19
811270bc:	a809883a 	mov	r4,r21
811270c0:	90004626 	beq	r18,zero,811271dc <__sfvwrite_r+0x19c>
811270c4:	900f883a 	mov	r7,r18
811270c8:	b480022e 	bgeu	r22,r18,811270d4 <__sfvwrite_r+0x94>
811270cc:	01e00034 	movhi	r7,32768
811270d0:	39ff0004 	addi	r7,r7,-1024
811270d4:	80800917 	ldw	r2,36(r16)
811270d8:	81400717 	ldw	r5,28(r16)
811270dc:	103ee83a 	callr	r2
811270e0:	0080570e 	bge	zero,r2,81127240 <__sfvwrite_r+0x200>
811270e4:	a0c00217 	ldw	r3,8(r20)
811270e8:	98a7883a 	add	r19,r19,r2
811270ec:	90a5c83a 	sub	r18,r18,r2
811270f0:	1885c83a 	sub	r2,r3,r2
811270f4:	a0800215 	stw	r2,8(r20)
811270f8:	103fef1e 	bne	r2,zero,811270b8 <__reset+0xfb1070b8>
811270fc:	0005883a 	mov	r2,zero
81127100:	dfc00b17 	ldw	ra,44(sp)
81127104:	df000a17 	ldw	fp,40(sp)
81127108:	ddc00917 	ldw	r23,36(sp)
8112710c:	dd800817 	ldw	r22,32(sp)
81127110:	dd400717 	ldw	r21,28(sp)
81127114:	dd000617 	ldw	r20,24(sp)
81127118:	dcc00517 	ldw	r19,20(sp)
8112711c:	dc800417 	ldw	r18,16(sp)
81127120:	dc400317 	ldw	r17,12(sp)
81127124:	dc000217 	ldw	r16,8(sp)
81127128:	dec00c04 	addi	sp,sp,48
8112712c:	f800283a 	ret
81127130:	800b883a 	mov	r5,r16
81127134:	a809883a 	mov	r4,r21
81127138:	11248200 	call	81124820 <__swsetup_r>
8112713c:	1000eb1e 	bne	r2,zero,811274ec <__sfvwrite_r+0x4ac>
81127140:	80c0030b 	ldhu	r3,12(r16)
81127144:	a4400017 	ldw	r17,0(r20)
81127148:	1880008c 	andi	r2,r3,2
8112714c:	103fd61e 	bne	r2,zero,811270a8 <__reset+0xfb1070a8>
81127150:	1880004c 	andi	r2,r3,1
81127154:	10003f1e 	bne	r2,zero,81127254 <__sfvwrite_r+0x214>
81127158:	0039883a 	mov	fp,zero
8112715c:	0025883a 	mov	r18,zero
81127160:	90001a26 	beq	r18,zero,811271cc <__sfvwrite_r+0x18c>
81127164:	1880800c 	andi	r2,r3,512
81127168:	84c00217 	ldw	r19,8(r16)
8112716c:	10002126 	beq	r2,zero,811271f4 <__sfvwrite_r+0x1b4>
81127170:	982f883a 	mov	r23,r19
81127174:	94c09336 	bltu	r18,r19,811273c4 <__sfvwrite_r+0x384>
81127178:	1881200c 	andi	r2,r3,1152
8112717c:	10009e1e 	bne	r2,zero,811273f8 <__sfvwrite_r+0x3b8>
81127180:	81000017 	ldw	r4,0(r16)
81127184:	b80d883a 	mov	r6,r23
81127188:	e00b883a 	mov	r5,fp
8112718c:	1127b9c0 	call	81127b9c <memmove>
81127190:	80c00217 	ldw	r3,8(r16)
81127194:	81000017 	ldw	r4,0(r16)
81127198:	9005883a 	mov	r2,r18
8112719c:	1ce7c83a 	sub	r19,r3,r19
811271a0:	25cf883a 	add	r7,r4,r23
811271a4:	84c00215 	stw	r19,8(r16)
811271a8:	81c00015 	stw	r7,0(r16)
811271ac:	a0c00217 	ldw	r3,8(r20)
811271b0:	e0b9883a 	add	fp,fp,r2
811271b4:	90a5c83a 	sub	r18,r18,r2
811271b8:	18a7c83a 	sub	r19,r3,r2
811271bc:	a4c00215 	stw	r19,8(r20)
811271c0:	983fce26 	beq	r19,zero,811270fc <__reset+0xfb1070fc>
811271c4:	80c0030b 	ldhu	r3,12(r16)
811271c8:	903fe61e 	bne	r18,zero,81127164 <__reset+0xfb107164>
811271cc:	8f000017 	ldw	fp,0(r17)
811271d0:	8c800117 	ldw	r18,4(r17)
811271d4:	8c400204 	addi	r17,r17,8
811271d8:	003fe106 	br	81127160 <__reset+0xfb107160>
811271dc:	8cc00017 	ldw	r19,0(r17)
811271e0:	8c800117 	ldw	r18,4(r17)
811271e4:	8c400204 	addi	r17,r17,8
811271e8:	003fb306 	br	811270b8 <__reset+0xfb1070b8>
811271ec:	0005883a 	mov	r2,zero
811271f0:	f800283a 	ret
811271f4:	81000017 	ldw	r4,0(r16)
811271f8:	80800417 	ldw	r2,16(r16)
811271fc:	11005736 	bltu	r2,r4,8112735c <__sfvwrite_r+0x31c>
81127200:	85c00517 	ldw	r23,20(r16)
81127204:	95c05536 	bltu	r18,r23,8112735c <__sfvwrite_r+0x31c>
81127208:	00a00034 	movhi	r2,32768
8112720c:	10bfffc4 	addi	r2,r2,-1
81127210:	9009883a 	mov	r4,r18
81127214:	1480012e 	bgeu	r2,r18,8112721c <__sfvwrite_r+0x1dc>
81127218:	1009883a 	mov	r4,r2
8112721c:	b80b883a 	mov	r5,r23
81127220:	112ffb80 	call	8112ffb8 <__divsi3>
81127224:	15cf383a 	mul	r7,r2,r23
81127228:	81400717 	ldw	r5,28(r16)
8112722c:	80800917 	ldw	r2,36(r16)
81127230:	e00d883a 	mov	r6,fp
81127234:	a809883a 	mov	r4,r21
81127238:	103ee83a 	callr	r2
8112723c:	00bfdb16 	blt	zero,r2,811271ac <__reset+0xfb1071ac>
81127240:	8080030b 	ldhu	r2,12(r16)
81127244:	10801014 	ori	r2,r2,64
81127248:	8080030d 	sth	r2,12(r16)
8112724c:	00bfffc4 	movi	r2,-1
81127250:	003fab06 	br	81127100 <__reset+0xfb107100>
81127254:	0027883a 	mov	r19,zero
81127258:	0011883a 	mov	r8,zero
8112725c:	0039883a 	mov	fp,zero
81127260:	0025883a 	mov	r18,zero
81127264:	90001f26 	beq	r18,zero,811272e4 <__sfvwrite_r+0x2a4>
81127268:	40005a26 	beq	r8,zero,811273d4 <__sfvwrite_r+0x394>
8112726c:	982d883a 	mov	r22,r19
81127270:	94c0012e 	bgeu	r18,r19,81127278 <__sfvwrite_r+0x238>
81127274:	902d883a 	mov	r22,r18
81127278:	81000017 	ldw	r4,0(r16)
8112727c:	80800417 	ldw	r2,16(r16)
81127280:	b02f883a 	mov	r23,r22
81127284:	81c00517 	ldw	r7,20(r16)
81127288:	1100032e 	bgeu	r2,r4,81127298 <__sfvwrite_r+0x258>
8112728c:	80c00217 	ldw	r3,8(r16)
81127290:	38c7883a 	add	r3,r7,r3
81127294:	1d801816 	blt	r3,r22,811272f8 <__sfvwrite_r+0x2b8>
81127298:	b1c03e16 	blt	r22,r7,81127394 <__sfvwrite_r+0x354>
8112729c:	80800917 	ldw	r2,36(r16)
811272a0:	81400717 	ldw	r5,28(r16)
811272a4:	e00d883a 	mov	r6,fp
811272a8:	da000115 	stw	r8,4(sp)
811272ac:	a809883a 	mov	r4,r21
811272b0:	103ee83a 	callr	r2
811272b4:	102f883a 	mov	r23,r2
811272b8:	da000117 	ldw	r8,4(sp)
811272bc:	00bfe00e 	bge	zero,r2,81127240 <__reset+0xfb107240>
811272c0:	9de7c83a 	sub	r19,r19,r23
811272c4:	98001f26 	beq	r19,zero,81127344 <__sfvwrite_r+0x304>
811272c8:	a0800217 	ldw	r2,8(r20)
811272cc:	e5f9883a 	add	fp,fp,r23
811272d0:	95e5c83a 	sub	r18,r18,r23
811272d4:	15efc83a 	sub	r23,r2,r23
811272d8:	a5c00215 	stw	r23,8(r20)
811272dc:	b83f8726 	beq	r23,zero,811270fc <__reset+0xfb1070fc>
811272e0:	903fe11e 	bne	r18,zero,81127268 <__reset+0xfb107268>
811272e4:	8f000017 	ldw	fp,0(r17)
811272e8:	8c800117 	ldw	r18,4(r17)
811272ec:	0011883a 	mov	r8,zero
811272f0:	8c400204 	addi	r17,r17,8
811272f4:	003fdb06 	br	81127264 <__reset+0xfb107264>
811272f8:	180d883a 	mov	r6,r3
811272fc:	e00b883a 	mov	r5,fp
81127300:	da000115 	stw	r8,4(sp)
81127304:	d8c00015 	stw	r3,0(sp)
81127308:	1127b9c0 	call	81127b9c <memmove>
8112730c:	d8c00017 	ldw	r3,0(sp)
81127310:	80800017 	ldw	r2,0(r16)
81127314:	800b883a 	mov	r5,r16
81127318:	a809883a 	mov	r4,r21
8112731c:	10c5883a 	add	r2,r2,r3
81127320:	80800015 	stw	r2,0(r16)
81127324:	d8c00015 	stw	r3,0(sp)
81127328:	11264940 	call	81126494 <_fflush_r>
8112732c:	d8c00017 	ldw	r3,0(sp)
81127330:	da000117 	ldw	r8,4(sp)
81127334:	103fc21e 	bne	r2,zero,81127240 <__reset+0xfb107240>
81127338:	182f883a 	mov	r23,r3
8112733c:	9de7c83a 	sub	r19,r19,r23
81127340:	983fe11e 	bne	r19,zero,811272c8 <__reset+0xfb1072c8>
81127344:	800b883a 	mov	r5,r16
81127348:	a809883a 	mov	r4,r21
8112734c:	11264940 	call	81126494 <_fflush_r>
81127350:	103fbb1e 	bne	r2,zero,81127240 <__reset+0xfb107240>
81127354:	0011883a 	mov	r8,zero
81127358:	003fdb06 	br	811272c8 <__reset+0xfb1072c8>
8112735c:	94c0012e 	bgeu	r18,r19,81127364 <__sfvwrite_r+0x324>
81127360:	9027883a 	mov	r19,r18
81127364:	980d883a 	mov	r6,r19
81127368:	e00b883a 	mov	r5,fp
8112736c:	1127b9c0 	call	81127b9c <memmove>
81127370:	80800217 	ldw	r2,8(r16)
81127374:	80c00017 	ldw	r3,0(r16)
81127378:	14c5c83a 	sub	r2,r2,r19
8112737c:	1cc7883a 	add	r3,r3,r19
81127380:	80800215 	stw	r2,8(r16)
81127384:	80c00015 	stw	r3,0(r16)
81127388:	10004326 	beq	r2,zero,81127498 <__sfvwrite_r+0x458>
8112738c:	9805883a 	mov	r2,r19
81127390:	003f8606 	br	811271ac <__reset+0xfb1071ac>
81127394:	b00d883a 	mov	r6,r22
81127398:	e00b883a 	mov	r5,fp
8112739c:	da000115 	stw	r8,4(sp)
811273a0:	1127b9c0 	call	81127b9c <memmove>
811273a4:	80800217 	ldw	r2,8(r16)
811273a8:	80c00017 	ldw	r3,0(r16)
811273ac:	da000117 	ldw	r8,4(sp)
811273b0:	1585c83a 	sub	r2,r2,r22
811273b4:	1dad883a 	add	r22,r3,r22
811273b8:	80800215 	stw	r2,8(r16)
811273bc:	85800015 	stw	r22,0(r16)
811273c0:	003fbf06 	br	811272c0 <__reset+0xfb1072c0>
811273c4:	81000017 	ldw	r4,0(r16)
811273c8:	9027883a 	mov	r19,r18
811273cc:	902f883a 	mov	r23,r18
811273d0:	003f6c06 	br	81127184 <__reset+0xfb107184>
811273d4:	900d883a 	mov	r6,r18
811273d8:	01400284 	movi	r5,10
811273dc:	e009883a 	mov	r4,fp
811273e0:	1127ab80 	call	81127ab8 <memchr>
811273e4:	10003e26 	beq	r2,zero,811274e0 <__sfvwrite_r+0x4a0>
811273e8:	10800044 	addi	r2,r2,1
811273ec:	1727c83a 	sub	r19,r2,fp
811273f0:	02000044 	movi	r8,1
811273f4:	003f9d06 	br	8112726c <__reset+0xfb10726c>
811273f8:	80800517 	ldw	r2,20(r16)
811273fc:	81400417 	ldw	r5,16(r16)
81127400:	81c00017 	ldw	r7,0(r16)
81127404:	10a7883a 	add	r19,r2,r2
81127408:	9885883a 	add	r2,r19,r2
8112740c:	1026d7fa 	srli	r19,r2,31
81127410:	396dc83a 	sub	r22,r7,r5
81127414:	b1000044 	addi	r4,r22,1
81127418:	9885883a 	add	r2,r19,r2
8112741c:	1027d07a 	srai	r19,r2,1
81127420:	2485883a 	add	r2,r4,r18
81127424:	980d883a 	mov	r6,r19
81127428:	9880022e 	bgeu	r19,r2,81127434 <__sfvwrite_r+0x3f4>
8112742c:	1027883a 	mov	r19,r2
81127430:	100d883a 	mov	r6,r2
81127434:	18c1000c 	andi	r3,r3,1024
81127438:	18001c26 	beq	r3,zero,811274ac <__sfvwrite_r+0x46c>
8112743c:	300b883a 	mov	r5,r6
81127440:	a809883a 	mov	r4,r21
81127444:	111d2b40 	call	8111d2b4 <_malloc_r>
81127448:	102f883a 	mov	r23,r2
8112744c:	10002926 	beq	r2,zero,811274f4 <__sfvwrite_r+0x4b4>
81127450:	81400417 	ldw	r5,16(r16)
81127454:	b00d883a 	mov	r6,r22
81127458:	1009883a 	mov	r4,r2
8112745c:	111dac80 	call	8111dac8 <memcpy>
81127460:	8080030b 	ldhu	r2,12(r16)
81127464:	00fedfc4 	movi	r3,-1153
81127468:	10c4703a 	and	r2,r2,r3
8112746c:	10802014 	ori	r2,r2,128
81127470:	8080030d 	sth	r2,12(r16)
81127474:	bd89883a 	add	r4,r23,r22
81127478:	9d8fc83a 	sub	r7,r19,r22
8112747c:	85c00415 	stw	r23,16(r16)
81127480:	84c00515 	stw	r19,20(r16)
81127484:	81000015 	stw	r4,0(r16)
81127488:	9027883a 	mov	r19,r18
8112748c:	81c00215 	stw	r7,8(r16)
81127490:	902f883a 	mov	r23,r18
81127494:	003f3b06 	br	81127184 <__reset+0xfb107184>
81127498:	800b883a 	mov	r5,r16
8112749c:	a809883a 	mov	r4,r21
811274a0:	11264940 	call	81126494 <_fflush_r>
811274a4:	103fb926 	beq	r2,zero,8112738c <__reset+0xfb10738c>
811274a8:	003f6506 	br	81127240 <__reset+0xfb107240>
811274ac:	a809883a 	mov	r4,r21
811274b0:	1128dbc0 	call	81128dbc <_realloc_r>
811274b4:	102f883a 	mov	r23,r2
811274b8:	103fee1e 	bne	r2,zero,81127474 <__reset+0xfb107474>
811274bc:	81400417 	ldw	r5,16(r16)
811274c0:	a809883a 	mov	r4,r21
811274c4:	1126d280 	call	81126d28 <_free_r>
811274c8:	8080030b 	ldhu	r2,12(r16)
811274cc:	00ffdfc4 	movi	r3,-129
811274d0:	1884703a 	and	r2,r3,r2
811274d4:	00c00304 	movi	r3,12
811274d8:	a8c00015 	stw	r3,0(r21)
811274dc:	003f5906 	br	81127244 <__reset+0xfb107244>
811274e0:	94c00044 	addi	r19,r18,1
811274e4:	02000044 	movi	r8,1
811274e8:	003f6006 	br	8112726c <__reset+0xfb10726c>
811274ec:	00bfffc4 	movi	r2,-1
811274f0:	003f0306 	br	81127100 <__reset+0xfb107100>
811274f4:	00800304 	movi	r2,12
811274f8:	a8800015 	stw	r2,0(r21)
811274fc:	8080030b 	ldhu	r2,12(r16)
81127500:	003f5006 	br	81127244 <__reset+0xfb107244>

81127504 <_fwalk>:
81127504:	defff704 	addi	sp,sp,-36
81127508:	de00012e 	bgeu	sp,et,81127510 <_fwalk+0xc>
8112750c:	003b68fa 	trap	3
81127510:	dd000415 	stw	r20,16(sp)
81127514:	dfc00815 	stw	ra,32(sp)
81127518:	ddc00715 	stw	r23,28(sp)
8112751c:	dd800615 	stw	r22,24(sp)
81127520:	dd400515 	stw	r21,20(sp)
81127524:	dcc00315 	stw	r19,12(sp)
81127528:	dc800215 	stw	r18,8(sp)
8112752c:	dc400115 	stw	r17,4(sp)
81127530:	dc000015 	stw	r16,0(sp)
81127534:	2500b804 	addi	r20,r4,736
81127538:	a0002326 	beq	r20,zero,811275c8 <_fwalk+0xc4>
8112753c:	282b883a 	mov	r21,r5
81127540:	002f883a 	mov	r23,zero
81127544:	05800044 	movi	r22,1
81127548:	04ffffc4 	movi	r19,-1
8112754c:	a4400117 	ldw	r17,4(r20)
81127550:	a4800217 	ldw	r18,8(r20)
81127554:	8c7fffc4 	addi	r17,r17,-1
81127558:	88000d16 	blt	r17,zero,81127590 <_fwalk+0x8c>
8112755c:	94000304 	addi	r16,r18,12
81127560:	94800384 	addi	r18,r18,14
81127564:	8080000b 	ldhu	r2,0(r16)
81127568:	8c7fffc4 	addi	r17,r17,-1
8112756c:	813ffd04 	addi	r4,r16,-12
81127570:	b080042e 	bgeu	r22,r2,81127584 <_fwalk+0x80>
81127574:	9080000f 	ldh	r2,0(r18)
81127578:	14c00226 	beq	r2,r19,81127584 <_fwalk+0x80>
8112757c:	a83ee83a 	callr	r21
81127580:	b8aeb03a 	or	r23,r23,r2
81127584:	84001a04 	addi	r16,r16,104
81127588:	94801a04 	addi	r18,r18,104
8112758c:	8cfff51e 	bne	r17,r19,81127564 <__reset+0xfb107564>
81127590:	a5000017 	ldw	r20,0(r20)
81127594:	a03fed1e 	bne	r20,zero,8112754c <__reset+0xfb10754c>
81127598:	b805883a 	mov	r2,r23
8112759c:	dfc00817 	ldw	ra,32(sp)
811275a0:	ddc00717 	ldw	r23,28(sp)
811275a4:	dd800617 	ldw	r22,24(sp)
811275a8:	dd400517 	ldw	r21,20(sp)
811275ac:	dd000417 	ldw	r20,16(sp)
811275b0:	dcc00317 	ldw	r19,12(sp)
811275b4:	dc800217 	ldw	r18,8(sp)
811275b8:	dc400117 	ldw	r17,4(sp)
811275bc:	dc000017 	ldw	r16,0(sp)
811275c0:	dec00904 	addi	sp,sp,36
811275c4:	f800283a 	ret
811275c8:	002f883a 	mov	r23,zero
811275cc:	003ff206 	br	81127598 <__reset+0xfb107598>

811275d0 <_fwalk_reent>:
811275d0:	defff704 	addi	sp,sp,-36
811275d4:	de00012e 	bgeu	sp,et,811275dc <_fwalk_reent+0xc>
811275d8:	003b68fa 	trap	3
811275dc:	dd000415 	stw	r20,16(sp)
811275e0:	dfc00815 	stw	ra,32(sp)
811275e4:	ddc00715 	stw	r23,28(sp)
811275e8:	dd800615 	stw	r22,24(sp)
811275ec:	dd400515 	stw	r21,20(sp)
811275f0:	dcc00315 	stw	r19,12(sp)
811275f4:	dc800215 	stw	r18,8(sp)
811275f8:	dc400115 	stw	r17,4(sp)
811275fc:	dc000015 	stw	r16,0(sp)
81127600:	2500b804 	addi	r20,r4,736
81127604:	a0002326 	beq	r20,zero,81127694 <_fwalk_reent+0xc4>
81127608:	282b883a 	mov	r21,r5
8112760c:	2027883a 	mov	r19,r4
81127610:	002f883a 	mov	r23,zero
81127614:	05800044 	movi	r22,1
81127618:	04bfffc4 	movi	r18,-1
8112761c:	a4400117 	ldw	r17,4(r20)
81127620:	a4000217 	ldw	r16,8(r20)
81127624:	8c7fffc4 	addi	r17,r17,-1
81127628:	88000c16 	blt	r17,zero,8112765c <_fwalk_reent+0x8c>
8112762c:	84000304 	addi	r16,r16,12
81127630:	8080000b 	ldhu	r2,0(r16)
81127634:	8c7fffc4 	addi	r17,r17,-1
81127638:	817ffd04 	addi	r5,r16,-12
8112763c:	b080052e 	bgeu	r22,r2,81127654 <_fwalk_reent+0x84>
81127640:	8080008f 	ldh	r2,2(r16)
81127644:	9809883a 	mov	r4,r19
81127648:	14800226 	beq	r2,r18,81127654 <_fwalk_reent+0x84>
8112764c:	a83ee83a 	callr	r21
81127650:	b8aeb03a 	or	r23,r23,r2
81127654:	84001a04 	addi	r16,r16,104
81127658:	8cbff51e 	bne	r17,r18,81127630 <__reset+0xfb107630>
8112765c:	a5000017 	ldw	r20,0(r20)
81127660:	a03fee1e 	bne	r20,zero,8112761c <__reset+0xfb10761c>
81127664:	b805883a 	mov	r2,r23
81127668:	dfc00817 	ldw	ra,32(sp)
8112766c:	ddc00717 	ldw	r23,28(sp)
81127670:	dd800617 	ldw	r22,24(sp)
81127674:	dd400517 	ldw	r21,20(sp)
81127678:	dd000417 	ldw	r20,16(sp)
8112767c:	dcc00317 	ldw	r19,12(sp)
81127680:	dc800217 	ldw	r18,8(sp)
81127684:	dc400117 	ldw	r17,4(sp)
81127688:	dc000017 	ldw	r16,0(sp)
8112768c:	dec00904 	addi	sp,sp,36
81127690:	f800283a 	ret
81127694:	002f883a 	mov	r23,zero
81127698:	003ff206 	br	81127664 <__reset+0xfb107664>

8112769c <_isatty_r>:
8112769c:	defffd04 	addi	sp,sp,-12
811276a0:	de00012e 	bgeu	sp,et,811276a8 <_isatty_r+0xc>
811276a4:	003b68fa 	trap	3
811276a8:	dc000015 	stw	r16,0(sp)
811276ac:	04204574 	movhi	r16,33045
811276b0:	dc400115 	stw	r17,4(sp)
811276b4:	843af104 	addi	r16,r16,-5180
811276b8:	2023883a 	mov	r17,r4
811276bc:	2809883a 	mov	r4,r5
811276c0:	dfc00215 	stw	ra,8(sp)
811276c4:	80000015 	stw	zero,0(r16)
811276c8:	11327ec0 	call	811327ec <isatty>
811276cc:	00ffffc4 	movi	r3,-1
811276d0:	10c00526 	beq	r2,r3,811276e8 <_isatty_r+0x4c>
811276d4:	dfc00217 	ldw	ra,8(sp)
811276d8:	dc400117 	ldw	r17,4(sp)
811276dc:	dc000017 	ldw	r16,0(sp)
811276e0:	dec00304 	addi	sp,sp,12
811276e4:	f800283a 	ret
811276e8:	80c00017 	ldw	r3,0(r16)
811276ec:	183ff926 	beq	r3,zero,811276d4 <__reset+0xfb1076d4>
811276f0:	88c00015 	stw	r3,0(r17)
811276f4:	003ff706 	br	811276d4 <__reset+0xfb1076d4>

811276f8 <iswspace>:
811276f8:	00803fc4 	movi	r2,255
811276fc:	11000836 	bltu	r2,r4,81127720 <iswspace+0x28>
81127700:	00a04574 	movhi	r2,33045
81127704:	10ba8004 	addi	r2,r2,-5632
81127708:	10800017 	ldw	r2,0(r2)
8112770c:	1109883a 	add	r4,r2,r4
81127710:	20800043 	ldbu	r2,1(r4)
81127714:	1080020c 	andi	r2,r2,8
81127718:	10803fcc 	andi	r2,r2,255
8112771c:	f800283a 	ret
81127720:	0005883a 	mov	r2,zero
81127724:	f800283a 	ret

81127728 <_setlocale_r>:
81127728:	30001d26 	beq	r6,zero,811277a0 <_setlocale_r+0x78>
8112772c:	01604574 	movhi	r5,33045
81127730:	defffe04 	addi	sp,sp,-8
81127734:	2970d904 	addi	r5,r5,-15516
81127738:	3009883a 	mov	r4,r6
8112773c:	de00012e 	bgeu	sp,et,81127744 <_setlocale_r+0x1c>
81127740:	003b68fa 	trap	3
81127744:	dc000015 	stw	r16,0(sp)
81127748:	dfc00115 	stw	ra,4(sp)
8112774c:	3021883a 	mov	r16,r6
81127750:	11294740 	call	81129474 <strcmp>
81127754:	1000061e 	bne	r2,zero,81127770 <_setlocale_r+0x48>
81127758:	00a04574 	movhi	r2,33045
8112775c:	10b0a804 	addi	r2,r2,-15712
81127760:	dfc00117 	ldw	ra,4(sp)
81127764:	dc000017 	ldw	r16,0(sp)
81127768:	dec00204 	addi	sp,sp,8
8112776c:	f800283a 	ret
81127770:	01604574 	movhi	r5,33045
81127774:	2970a804 	addi	r5,r5,-15712
81127778:	8009883a 	mov	r4,r16
8112777c:	11294740 	call	81129474 <strcmp>
81127780:	103ff526 	beq	r2,zero,81127758 <__reset+0xfb107758>
81127784:	01604574 	movhi	r5,33045
81127788:	2970b204 	addi	r5,r5,-15672
8112778c:	8009883a 	mov	r4,r16
81127790:	11294740 	call	81129474 <strcmp>
81127794:	103ff026 	beq	r2,zero,81127758 <__reset+0xfb107758>
81127798:	0005883a 	mov	r2,zero
8112779c:	003ff006 	br	81127760 <__reset+0xfb107760>
811277a0:	00a04574 	movhi	r2,33045
811277a4:	10b0a804 	addi	r2,r2,-15712
811277a8:	f800283a 	ret

811277ac <__locale_charset>:
811277ac:	00a04574 	movhi	r2,33045
811277b0:	10b54a04 	addi	r2,r2,-10968
811277b4:	f800283a 	ret

811277b8 <__locale_mb_cur_max>:
811277b8:	00a04574 	movhi	r2,33045
811277bc:	10ba8504 	addi	r2,r2,-5612
811277c0:	10800017 	ldw	r2,0(r2)
811277c4:	f800283a 	ret

811277c8 <__locale_msgcharset>:
811277c8:	00a04574 	movhi	r2,33045
811277cc:	10b54204 	addi	r2,r2,-11000
811277d0:	f800283a 	ret

811277d4 <__locale_cjk_lang>:
811277d4:	0005883a 	mov	r2,zero
811277d8:	f800283a 	ret

811277dc <_localeconv_r>:
811277dc:	00a04574 	movhi	r2,33045
811277e0:	10b55204 	addi	r2,r2,-10936
811277e4:	f800283a 	ret

811277e8 <setlocale>:
811277e8:	00a04574 	movhi	r2,33045
811277ec:	10ba8204 	addi	r2,r2,-5624
811277f0:	280d883a 	mov	r6,r5
811277f4:	200b883a 	mov	r5,r4
811277f8:	11000017 	ldw	r4,0(r2)
811277fc:	11277281 	jmpi	81127728 <_setlocale_r>

81127800 <localeconv>:
81127800:	00a04574 	movhi	r2,33045
81127804:	10b55204 	addi	r2,r2,-10936
81127808:	f800283a 	ret

8112780c <_lseek_r>:
8112780c:	defffd04 	addi	sp,sp,-12
81127810:	de00012e 	bgeu	sp,et,81127818 <_lseek_r+0xc>
81127814:	003b68fa 	trap	3
81127818:	2805883a 	mov	r2,r5
8112781c:	dc000015 	stw	r16,0(sp)
81127820:	04204574 	movhi	r16,33045
81127824:	dc400115 	stw	r17,4(sp)
81127828:	300b883a 	mov	r5,r6
8112782c:	843af104 	addi	r16,r16,-5180
81127830:	2023883a 	mov	r17,r4
81127834:	380d883a 	mov	r6,r7
81127838:	1009883a 	mov	r4,r2
8112783c:	dfc00215 	stw	ra,8(sp)
81127840:	80000015 	stw	zero,0(r16)
81127844:	11333e80 	call	811333e8 <lseek>
81127848:	00ffffc4 	movi	r3,-1
8112784c:	10c00526 	beq	r2,r3,81127864 <_lseek_r+0x58>
81127850:	dfc00217 	ldw	ra,8(sp)
81127854:	dc400117 	ldw	r17,4(sp)
81127858:	dc000017 	ldw	r16,0(sp)
8112785c:	dec00304 	addi	sp,sp,12
81127860:	f800283a 	ret
81127864:	80c00017 	ldw	r3,0(r16)
81127868:	183ff926 	beq	r3,zero,81127850 <__reset+0xfb107850>
8112786c:	88c00015 	stw	r3,0(r17)
81127870:	003ff706 	br	81127850 <__reset+0xfb107850>

81127874 <_mbrtowc_r>:
81127874:	defff704 	addi	sp,sp,-36
81127878:	00a04574 	movhi	r2,33045
8112787c:	de00012e 	bgeu	sp,et,81127884 <_mbrtowc_r+0x10>
81127880:	003b68fa 	trap	3
81127884:	10ba8604 	addi	r2,r2,-5608
81127888:	dc800715 	stw	r18,28(sp)
8112788c:	dc400615 	stw	r17,24(sp)
81127890:	dc000515 	stw	r16,20(sp)
81127894:	dfc00815 	stw	ra,32(sp)
81127898:	2021883a 	mov	r16,r4
8112789c:	dc400917 	ldw	r17,36(sp)
811278a0:	14800017 	ldw	r18,0(r2)
811278a4:	30001626 	beq	r6,zero,81127900 <_mbrtowc_r+0x8c>
811278a8:	d9400215 	stw	r5,8(sp)
811278ac:	d9800315 	stw	r6,12(sp)
811278b0:	d9c00415 	stw	r7,16(sp)
811278b4:	11277ac0 	call	811277ac <__locale_charset>
811278b8:	d9c00417 	ldw	r7,16(sp)
811278bc:	d9800317 	ldw	r6,12(sp)
811278c0:	d9400217 	ldw	r5,8(sp)
811278c4:	d8800015 	stw	r2,0(sp)
811278c8:	dc400115 	stw	r17,4(sp)
811278cc:	8009883a 	mov	r4,r16
811278d0:	903ee83a 	callr	r18
811278d4:	00ffffc4 	movi	r3,-1
811278d8:	10c0031e 	bne	r2,r3,811278e8 <_mbrtowc_r+0x74>
811278dc:	88000015 	stw	zero,0(r17)
811278e0:	00c02284 	movi	r3,138
811278e4:	80c00015 	stw	r3,0(r16)
811278e8:	dfc00817 	ldw	ra,32(sp)
811278ec:	dc800717 	ldw	r18,28(sp)
811278f0:	dc400617 	ldw	r17,24(sp)
811278f4:	dc000517 	ldw	r16,20(sp)
811278f8:	dec00904 	addi	sp,sp,36
811278fc:	f800283a 	ret
81127900:	11277ac0 	call	811277ac <__locale_charset>
81127904:	01a04574 	movhi	r6,33045
81127908:	31b0b204 	addi	r6,r6,-15672
8112790c:	dc400115 	stw	r17,4(sp)
81127910:	d8800015 	stw	r2,0(sp)
81127914:	01c00044 	movi	r7,1
81127918:	000b883a 	mov	r5,zero
8112791c:	8009883a 	mov	r4,r16
81127920:	903ee83a 	callr	r18
81127924:	003feb06 	br	811278d4 <__reset+0xfb1078d4>

81127928 <mbrtowc>:
81127928:	defff704 	addi	sp,sp,-36
8112792c:	00a04574 	movhi	r2,33045
81127930:	de00012e 	bgeu	sp,et,81127938 <mbrtowc+0x10>
81127934:	003b68fa 	trap	3
81127938:	10ba8204 	addi	r2,r2,-5624
8112793c:	dc800415 	stw	r18,16(sp)
81127940:	dc400315 	stw	r17,12(sp)
81127944:	dfc00815 	stw	ra,32(sp)
81127948:	dd400715 	stw	r21,28(sp)
8112794c:	dd000615 	stw	r20,24(sp)
81127950:	dcc00515 	stw	r19,20(sp)
81127954:	dc000215 	stw	r16,8(sp)
81127958:	3825883a 	mov	r18,r7
8112795c:	14400017 	ldw	r17,0(r2)
81127960:	28001c26 	beq	r5,zero,811279d4 <mbrtowc+0xac>
81127964:	00a04574 	movhi	r2,33045
81127968:	10ba8604 	addi	r2,r2,-5608
8112796c:	15400017 	ldw	r21,0(r2)
81127970:	2821883a 	mov	r16,r5
81127974:	2027883a 	mov	r19,r4
81127978:	3029883a 	mov	r20,r6
8112797c:	11277ac0 	call	811277ac <__locale_charset>
81127980:	d8800015 	stw	r2,0(sp)
81127984:	dc800115 	stw	r18,4(sp)
81127988:	a00f883a 	mov	r7,r20
8112798c:	800d883a 	mov	r6,r16
81127990:	980b883a 	mov	r5,r19
81127994:	8809883a 	mov	r4,r17
81127998:	a83ee83a 	callr	r21
8112799c:	00ffffc4 	movi	r3,-1
811279a0:	10c0031e 	bne	r2,r3,811279b0 <mbrtowc+0x88>
811279a4:	90000015 	stw	zero,0(r18)
811279a8:	00c02284 	movi	r3,138
811279ac:	88c00015 	stw	r3,0(r17)
811279b0:	dfc00817 	ldw	ra,32(sp)
811279b4:	dd400717 	ldw	r21,28(sp)
811279b8:	dd000617 	ldw	r20,24(sp)
811279bc:	dcc00517 	ldw	r19,20(sp)
811279c0:	dc800417 	ldw	r18,16(sp)
811279c4:	dc400317 	ldw	r17,12(sp)
811279c8:	dc000217 	ldw	r16,8(sp)
811279cc:	dec00904 	addi	sp,sp,36
811279d0:	f800283a 	ret
811279d4:	00a04574 	movhi	r2,33045
811279d8:	10ba8604 	addi	r2,r2,-5608
811279dc:	14000017 	ldw	r16,0(r2)
811279e0:	11277ac0 	call	811277ac <__locale_charset>
811279e4:	01a04574 	movhi	r6,33045
811279e8:	31b0b204 	addi	r6,r6,-15672
811279ec:	dc800115 	stw	r18,4(sp)
811279f0:	d8800015 	stw	r2,0(sp)
811279f4:	01c00044 	movi	r7,1
811279f8:	000b883a 	mov	r5,zero
811279fc:	8809883a 	mov	r4,r17
81127a00:	803ee83a 	callr	r16
81127a04:	003fe506 	br	8112799c <__reset+0xfb10799c>

81127a08 <__ascii_mbtowc>:
81127a08:	deffff04 	addi	sp,sp,-4
81127a0c:	de00012e 	bgeu	sp,et,81127a14 <__ascii_mbtowc+0xc>
81127a10:	003b68fa 	trap	3
81127a14:	28000826 	beq	r5,zero,81127a38 <__ascii_mbtowc+0x30>
81127a18:	30000926 	beq	r6,zero,81127a40 <__ascii_mbtowc+0x38>
81127a1c:	38000b26 	beq	r7,zero,81127a4c <__ascii_mbtowc+0x44>
81127a20:	30800003 	ldbu	r2,0(r6)
81127a24:	28800015 	stw	r2,0(r5)
81127a28:	30800003 	ldbu	r2,0(r6)
81127a2c:	1004c03a 	cmpne	r2,r2,zero
81127a30:	dec00104 	addi	sp,sp,4
81127a34:	f800283a 	ret
81127a38:	d80b883a 	mov	r5,sp
81127a3c:	303ff71e 	bne	r6,zero,81127a1c <__reset+0xfb107a1c>
81127a40:	0005883a 	mov	r2,zero
81127a44:	dec00104 	addi	sp,sp,4
81127a48:	f800283a 	ret
81127a4c:	00bfff84 	movi	r2,-2
81127a50:	003ff706 	br	81127a30 <__reset+0xfb107a30>

81127a54 <_mbtowc_r>:
81127a54:	00a04574 	movhi	r2,33045
81127a58:	defff804 	addi	sp,sp,-32
81127a5c:	10ba8604 	addi	r2,r2,-5608
81127a60:	de00012e 	bgeu	sp,et,81127a68 <_mbtowc_r+0x14>
81127a64:	003b68fa 	trap	3
81127a68:	dfc00715 	stw	ra,28(sp)
81127a6c:	dc000615 	stw	r16,24(sp)
81127a70:	14000017 	ldw	r16,0(r2)
81127a74:	d9000215 	stw	r4,8(sp)
81127a78:	d9400315 	stw	r5,12(sp)
81127a7c:	d9800415 	stw	r6,16(sp)
81127a80:	d9c00515 	stw	r7,20(sp)
81127a84:	11277ac0 	call	811277ac <__locale_charset>
81127a88:	d8800015 	stw	r2,0(sp)
81127a8c:	d8800817 	ldw	r2,32(sp)
81127a90:	d9c00517 	ldw	r7,20(sp)
81127a94:	d9800417 	ldw	r6,16(sp)
81127a98:	d9400317 	ldw	r5,12(sp)
81127a9c:	d9000217 	ldw	r4,8(sp)
81127aa0:	d8800115 	stw	r2,4(sp)
81127aa4:	803ee83a 	callr	r16
81127aa8:	dfc00717 	ldw	ra,28(sp)
81127aac:	dc000617 	ldw	r16,24(sp)
81127ab0:	dec00804 	addi	sp,sp,32
81127ab4:	f800283a 	ret

81127ab8 <memchr>:
81127ab8:	208000cc 	andi	r2,r4,3
81127abc:	280f883a 	mov	r7,r5
81127ac0:	10003426 	beq	r2,zero,81127b94 <memchr+0xdc>
81127ac4:	30bfffc4 	addi	r2,r6,-1
81127ac8:	30001a26 	beq	r6,zero,81127b34 <memchr+0x7c>
81127acc:	20c00003 	ldbu	r3,0(r4)
81127ad0:	29803fcc 	andi	r6,r5,255
81127ad4:	30c0051e 	bne	r6,r3,81127aec <memchr+0x34>
81127ad8:	00001806 	br	81127b3c <memchr+0x84>
81127adc:	10001526 	beq	r2,zero,81127b34 <memchr+0x7c>
81127ae0:	20c00003 	ldbu	r3,0(r4)
81127ae4:	10bfffc4 	addi	r2,r2,-1
81127ae8:	30c01426 	beq	r6,r3,81127b3c <memchr+0x84>
81127aec:	21000044 	addi	r4,r4,1
81127af0:	20c000cc 	andi	r3,r4,3
81127af4:	183ff91e 	bne	r3,zero,81127adc <__reset+0xfb107adc>
81127af8:	020000c4 	movi	r8,3
81127afc:	40801136 	bltu	r8,r2,81127b44 <memchr+0x8c>
81127b00:	10000c26 	beq	r2,zero,81127b34 <memchr+0x7c>
81127b04:	20c00003 	ldbu	r3,0(r4)
81127b08:	29403fcc 	andi	r5,r5,255
81127b0c:	28c00b26 	beq	r5,r3,81127b3c <memchr+0x84>
81127b10:	20c00044 	addi	r3,r4,1
81127b14:	39803fcc 	andi	r6,r7,255
81127b18:	2089883a 	add	r4,r4,r2
81127b1c:	00000306 	br	81127b2c <memchr+0x74>
81127b20:	18c00044 	addi	r3,r3,1
81127b24:	197fffc3 	ldbu	r5,-1(r3)
81127b28:	31400526 	beq	r6,r5,81127b40 <memchr+0x88>
81127b2c:	1805883a 	mov	r2,r3
81127b30:	20fffb1e 	bne	r4,r3,81127b20 <__reset+0xfb107b20>
81127b34:	0005883a 	mov	r2,zero
81127b38:	f800283a 	ret
81127b3c:	2005883a 	mov	r2,r4
81127b40:	f800283a 	ret
81127b44:	28c03fcc 	andi	r3,r5,255
81127b48:	1812923a 	slli	r9,r3,8
81127b4c:	02ffbff4 	movhi	r11,65279
81127b50:	02a02074 	movhi	r10,32897
81127b54:	48d2b03a 	or	r9,r9,r3
81127b58:	4806943a 	slli	r3,r9,16
81127b5c:	5affbfc4 	addi	r11,r11,-257
81127b60:	52a02004 	addi	r10,r10,-32640
81127b64:	48d2b03a 	or	r9,r9,r3
81127b68:	20c00017 	ldw	r3,0(r4)
81127b6c:	48c6f03a 	xor	r3,r9,r3
81127b70:	1acd883a 	add	r6,r3,r11
81127b74:	00c6303a 	nor	r3,zero,r3
81127b78:	30c6703a 	and	r3,r6,r3
81127b7c:	1a86703a 	and	r3,r3,r10
81127b80:	183fe01e 	bne	r3,zero,81127b04 <__reset+0xfb107b04>
81127b84:	10bfff04 	addi	r2,r2,-4
81127b88:	21000104 	addi	r4,r4,4
81127b8c:	40bff636 	bltu	r8,r2,81127b68 <__reset+0xfb107b68>
81127b90:	003fdb06 	br	81127b00 <__reset+0xfb107b00>
81127b94:	3005883a 	mov	r2,r6
81127b98:	003fd706 	br	81127af8 <__reset+0xfb107af8>

81127b9c <memmove>:
81127b9c:	2005883a 	mov	r2,r4
81127ba0:	29000b2e 	bgeu	r5,r4,81127bd0 <memmove+0x34>
81127ba4:	298f883a 	add	r7,r5,r6
81127ba8:	21c0092e 	bgeu	r4,r7,81127bd0 <memmove+0x34>
81127bac:	2187883a 	add	r3,r4,r6
81127bb0:	198bc83a 	sub	r5,r3,r6
81127bb4:	30004826 	beq	r6,zero,81127cd8 <memmove+0x13c>
81127bb8:	39ffffc4 	addi	r7,r7,-1
81127bbc:	39000003 	ldbu	r4,0(r7)
81127bc0:	18ffffc4 	addi	r3,r3,-1
81127bc4:	19000005 	stb	r4,0(r3)
81127bc8:	28fffb1e 	bne	r5,r3,81127bb8 <__reset+0xfb107bb8>
81127bcc:	f800283a 	ret
81127bd0:	00c003c4 	movi	r3,15
81127bd4:	1980412e 	bgeu	r3,r6,81127cdc <memmove+0x140>
81127bd8:	2886b03a 	or	r3,r5,r2
81127bdc:	18c000cc 	andi	r3,r3,3
81127be0:	1800401e 	bne	r3,zero,81127ce4 <memmove+0x148>
81127be4:	33fffc04 	addi	r15,r6,-16
81127be8:	781ed13a 	srli	r15,r15,4
81127bec:	28c00104 	addi	r3,r5,4
81127bf0:	13400104 	addi	r13,r2,4
81127bf4:	781c913a 	slli	r14,r15,4
81127bf8:	2b000204 	addi	r12,r5,8
81127bfc:	12c00204 	addi	r11,r2,8
81127c00:	73800504 	addi	r14,r14,20
81127c04:	2a800304 	addi	r10,r5,12
81127c08:	12400304 	addi	r9,r2,12
81127c0c:	2b9d883a 	add	r14,r5,r14
81127c10:	2811883a 	mov	r8,r5
81127c14:	100f883a 	mov	r7,r2
81127c18:	41000017 	ldw	r4,0(r8)
81127c1c:	39c00404 	addi	r7,r7,16
81127c20:	18c00404 	addi	r3,r3,16
81127c24:	393ffc15 	stw	r4,-16(r7)
81127c28:	193ffc17 	ldw	r4,-16(r3)
81127c2c:	6b400404 	addi	r13,r13,16
81127c30:	5ac00404 	addi	r11,r11,16
81127c34:	693ffc15 	stw	r4,-16(r13)
81127c38:	61000017 	ldw	r4,0(r12)
81127c3c:	4a400404 	addi	r9,r9,16
81127c40:	42000404 	addi	r8,r8,16
81127c44:	593ffc15 	stw	r4,-16(r11)
81127c48:	51000017 	ldw	r4,0(r10)
81127c4c:	63000404 	addi	r12,r12,16
81127c50:	52800404 	addi	r10,r10,16
81127c54:	493ffc15 	stw	r4,-16(r9)
81127c58:	1bbfef1e 	bne	r3,r14,81127c18 <__reset+0xfb107c18>
81127c5c:	79000044 	addi	r4,r15,1
81127c60:	2008913a 	slli	r4,r4,4
81127c64:	328003cc 	andi	r10,r6,15
81127c68:	02c000c4 	movi	r11,3
81127c6c:	1107883a 	add	r3,r2,r4
81127c70:	290b883a 	add	r5,r5,r4
81127c74:	5a801e2e 	bgeu	r11,r10,81127cf0 <memmove+0x154>
81127c78:	1813883a 	mov	r9,r3
81127c7c:	2811883a 	mov	r8,r5
81127c80:	500f883a 	mov	r7,r10
81127c84:	41000017 	ldw	r4,0(r8)
81127c88:	4a400104 	addi	r9,r9,4
81127c8c:	39ffff04 	addi	r7,r7,-4
81127c90:	493fff15 	stw	r4,-4(r9)
81127c94:	42000104 	addi	r8,r8,4
81127c98:	59fffa36 	bltu	r11,r7,81127c84 <__reset+0xfb107c84>
81127c9c:	513fff04 	addi	r4,r10,-4
81127ca0:	2008d0ba 	srli	r4,r4,2
81127ca4:	318000cc 	andi	r6,r6,3
81127ca8:	21000044 	addi	r4,r4,1
81127cac:	2109883a 	add	r4,r4,r4
81127cb0:	2109883a 	add	r4,r4,r4
81127cb4:	1907883a 	add	r3,r3,r4
81127cb8:	290b883a 	add	r5,r5,r4
81127cbc:	30000b26 	beq	r6,zero,81127cec <memmove+0x150>
81127cc0:	198d883a 	add	r6,r3,r6
81127cc4:	29c00003 	ldbu	r7,0(r5)
81127cc8:	18c00044 	addi	r3,r3,1
81127ccc:	29400044 	addi	r5,r5,1
81127cd0:	19ffffc5 	stb	r7,-1(r3)
81127cd4:	19bffb1e 	bne	r3,r6,81127cc4 <__reset+0xfb107cc4>
81127cd8:	f800283a 	ret
81127cdc:	1007883a 	mov	r3,r2
81127ce0:	003ff606 	br	81127cbc <__reset+0xfb107cbc>
81127ce4:	1007883a 	mov	r3,r2
81127ce8:	003ff506 	br	81127cc0 <__reset+0xfb107cc0>
81127cec:	f800283a 	ret
81127cf0:	500d883a 	mov	r6,r10
81127cf4:	003ff106 	br	81127cbc <__reset+0xfb107cbc>

81127cf8 <_Balloc>:
81127cf8:	defffc04 	addi	sp,sp,-16
81127cfc:	de00012e 	bgeu	sp,et,81127d04 <_Balloc+0xc>
81127d00:	003b68fa 	trap	3
81127d04:	20801317 	ldw	r2,76(r4)
81127d08:	dc400115 	stw	r17,4(sp)
81127d0c:	dc000015 	stw	r16,0(sp)
81127d10:	dfc00315 	stw	ra,12(sp)
81127d14:	dc800215 	stw	r18,8(sp)
81127d18:	2023883a 	mov	r17,r4
81127d1c:	2821883a 	mov	r16,r5
81127d20:	10000f26 	beq	r2,zero,81127d60 <_Balloc+0x68>
81127d24:	8407883a 	add	r3,r16,r16
81127d28:	18c7883a 	add	r3,r3,r3
81127d2c:	10c7883a 	add	r3,r2,r3
81127d30:	18800017 	ldw	r2,0(r3)
81127d34:	10001126 	beq	r2,zero,81127d7c <_Balloc+0x84>
81127d38:	11000017 	ldw	r4,0(r2)
81127d3c:	19000015 	stw	r4,0(r3)
81127d40:	10000415 	stw	zero,16(r2)
81127d44:	10000315 	stw	zero,12(r2)
81127d48:	dfc00317 	ldw	ra,12(sp)
81127d4c:	dc800217 	ldw	r18,8(sp)
81127d50:	dc400117 	ldw	r17,4(sp)
81127d54:	dc000017 	ldw	r16,0(sp)
81127d58:	dec00404 	addi	sp,sp,16
81127d5c:	f800283a 	ret
81127d60:	01800844 	movi	r6,33
81127d64:	01400104 	movi	r5,4
81127d68:	112e2200 	call	8112e220 <_calloc_r>
81127d6c:	88801315 	stw	r2,76(r17)
81127d70:	103fec1e 	bne	r2,zero,81127d24 <__reset+0xfb107d24>
81127d74:	0005883a 	mov	r2,zero
81127d78:	003ff306 	br	81127d48 <__reset+0xfb107d48>
81127d7c:	01400044 	movi	r5,1
81127d80:	2c24983a 	sll	r18,r5,r16
81127d84:	8809883a 	mov	r4,r17
81127d88:	91800144 	addi	r6,r18,5
81127d8c:	318d883a 	add	r6,r6,r6
81127d90:	318d883a 	add	r6,r6,r6
81127d94:	112e2200 	call	8112e220 <_calloc_r>
81127d98:	103ff626 	beq	r2,zero,81127d74 <__reset+0xfb107d74>
81127d9c:	14000115 	stw	r16,4(r2)
81127da0:	14800215 	stw	r18,8(r2)
81127da4:	003fe606 	br	81127d40 <__reset+0xfb107d40>

81127da8 <_Bfree>:
81127da8:	28000826 	beq	r5,zero,81127dcc <_Bfree+0x24>
81127dac:	28c00117 	ldw	r3,4(r5)
81127db0:	20801317 	ldw	r2,76(r4)
81127db4:	18c7883a 	add	r3,r3,r3
81127db8:	18c7883a 	add	r3,r3,r3
81127dbc:	10c5883a 	add	r2,r2,r3
81127dc0:	10c00017 	ldw	r3,0(r2)
81127dc4:	28c00015 	stw	r3,0(r5)
81127dc8:	11400015 	stw	r5,0(r2)
81127dcc:	f800283a 	ret

81127dd0 <__multadd>:
81127dd0:	defffa04 	addi	sp,sp,-24
81127dd4:	de00012e 	bgeu	sp,et,81127ddc <__multadd+0xc>
81127dd8:	003b68fa 	trap	3
81127ddc:	0011883a 	mov	r8,zero
81127de0:	dc800315 	stw	r18,12(sp)
81127de4:	dc400215 	stw	r17,8(sp)
81127de8:	dc000115 	stw	r16,4(sp)
81127dec:	2823883a 	mov	r17,r5
81127df0:	2c000417 	ldw	r16,16(r5)
81127df4:	dfc00515 	stw	ra,20(sp)
81127df8:	dcc00415 	stw	r19,16(sp)
81127dfc:	2025883a 	mov	r18,r4
81127e00:	29400504 	addi	r5,r5,20
81127e04:	28c00017 	ldw	r3,0(r5)
81127e08:	29400104 	addi	r5,r5,4
81127e0c:	42000044 	addi	r8,r8,1
81127e10:	18bfffcc 	andi	r2,r3,65535
81127e14:	1185383a 	mul	r2,r2,r6
81127e18:	1806d43a 	srli	r3,r3,16
81127e1c:	11cf883a 	add	r7,r2,r7
81127e20:	3808d43a 	srli	r4,r7,16
81127e24:	1987383a 	mul	r3,r3,r6
81127e28:	38bfffcc 	andi	r2,r7,65535
81127e2c:	1907883a 	add	r3,r3,r4
81127e30:	1808943a 	slli	r4,r3,16
81127e34:	180ed43a 	srli	r7,r3,16
81127e38:	2085883a 	add	r2,r4,r2
81127e3c:	28bfff15 	stw	r2,-4(r5)
81127e40:	443ff016 	blt	r8,r16,81127e04 <__reset+0xfb107e04>
81127e44:	38000926 	beq	r7,zero,81127e6c <__multadd+0x9c>
81127e48:	88800217 	ldw	r2,8(r17)
81127e4c:	80800f0e 	bge	r16,r2,81127e8c <__multadd+0xbc>
81127e50:	80800144 	addi	r2,r16,5
81127e54:	1085883a 	add	r2,r2,r2
81127e58:	1085883a 	add	r2,r2,r2
81127e5c:	8885883a 	add	r2,r17,r2
81127e60:	11c00015 	stw	r7,0(r2)
81127e64:	84000044 	addi	r16,r16,1
81127e68:	8c000415 	stw	r16,16(r17)
81127e6c:	8805883a 	mov	r2,r17
81127e70:	dfc00517 	ldw	ra,20(sp)
81127e74:	dcc00417 	ldw	r19,16(sp)
81127e78:	dc800317 	ldw	r18,12(sp)
81127e7c:	dc400217 	ldw	r17,8(sp)
81127e80:	dc000117 	ldw	r16,4(sp)
81127e84:	dec00604 	addi	sp,sp,24
81127e88:	f800283a 	ret
81127e8c:	89400117 	ldw	r5,4(r17)
81127e90:	9009883a 	mov	r4,r18
81127e94:	d9c00015 	stw	r7,0(sp)
81127e98:	29400044 	addi	r5,r5,1
81127e9c:	1127cf80 	call	81127cf8 <_Balloc>
81127ea0:	89800417 	ldw	r6,16(r17)
81127ea4:	89400304 	addi	r5,r17,12
81127ea8:	11000304 	addi	r4,r2,12
81127eac:	31800084 	addi	r6,r6,2
81127eb0:	318d883a 	add	r6,r6,r6
81127eb4:	318d883a 	add	r6,r6,r6
81127eb8:	1027883a 	mov	r19,r2
81127ebc:	111dac80 	call	8111dac8 <memcpy>
81127ec0:	d9c00017 	ldw	r7,0(sp)
81127ec4:	88000a26 	beq	r17,zero,81127ef0 <__multadd+0x120>
81127ec8:	88c00117 	ldw	r3,4(r17)
81127ecc:	90801317 	ldw	r2,76(r18)
81127ed0:	18c7883a 	add	r3,r3,r3
81127ed4:	18c7883a 	add	r3,r3,r3
81127ed8:	10c5883a 	add	r2,r2,r3
81127edc:	10c00017 	ldw	r3,0(r2)
81127ee0:	88c00015 	stw	r3,0(r17)
81127ee4:	14400015 	stw	r17,0(r2)
81127ee8:	9823883a 	mov	r17,r19
81127eec:	003fd806 	br	81127e50 <__reset+0xfb107e50>
81127ef0:	9823883a 	mov	r17,r19
81127ef4:	003fd606 	br	81127e50 <__reset+0xfb107e50>

81127ef8 <__s2b>:
81127ef8:	defff904 	addi	sp,sp,-28
81127efc:	de00012e 	bgeu	sp,et,81127f04 <__s2b+0xc>
81127f00:	003b68fa 	trap	3
81127f04:	dc400115 	stw	r17,4(sp)
81127f08:	dc000015 	stw	r16,0(sp)
81127f0c:	2023883a 	mov	r17,r4
81127f10:	2821883a 	mov	r16,r5
81127f14:	39000204 	addi	r4,r7,8
81127f18:	01400244 	movi	r5,9
81127f1c:	dcc00315 	stw	r19,12(sp)
81127f20:	dc800215 	stw	r18,8(sp)
81127f24:	dfc00615 	stw	ra,24(sp)
81127f28:	dd400515 	stw	r21,20(sp)
81127f2c:	dd000415 	stw	r20,16(sp)
81127f30:	3825883a 	mov	r18,r7
81127f34:	3027883a 	mov	r19,r6
81127f38:	112ffb80 	call	8112ffb8 <__divsi3>
81127f3c:	00c00044 	movi	r3,1
81127f40:	000b883a 	mov	r5,zero
81127f44:	1880030e 	bge	r3,r2,81127f54 <__s2b+0x5c>
81127f48:	18c7883a 	add	r3,r3,r3
81127f4c:	29400044 	addi	r5,r5,1
81127f50:	18bffd16 	blt	r3,r2,81127f48 <__reset+0xfb107f48>
81127f54:	8809883a 	mov	r4,r17
81127f58:	1127cf80 	call	81127cf8 <_Balloc>
81127f5c:	d8c00717 	ldw	r3,28(sp)
81127f60:	10c00515 	stw	r3,20(r2)
81127f64:	00c00044 	movi	r3,1
81127f68:	10c00415 	stw	r3,16(r2)
81127f6c:	00c00244 	movi	r3,9
81127f70:	1cc0210e 	bge	r3,r19,81127ff8 <__s2b+0x100>
81127f74:	80eb883a 	add	r21,r16,r3
81127f78:	a829883a 	mov	r20,r21
81127f7c:	84e1883a 	add	r16,r16,r19
81127f80:	a1c00007 	ldb	r7,0(r20)
81127f84:	01800284 	movi	r6,10
81127f88:	a5000044 	addi	r20,r20,1
81127f8c:	100b883a 	mov	r5,r2
81127f90:	39fff404 	addi	r7,r7,-48
81127f94:	8809883a 	mov	r4,r17
81127f98:	1127dd00 	call	81127dd0 <__multadd>
81127f9c:	a43ff81e 	bne	r20,r16,81127f80 <__reset+0xfb107f80>
81127fa0:	ace1883a 	add	r16,r21,r19
81127fa4:	843ffe04 	addi	r16,r16,-8
81127fa8:	9c800a0e 	bge	r19,r18,81127fd4 <__s2b+0xdc>
81127fac:	94e5c83a 	sub	r18,r18,r19
81127fb0:	84a5883a 	add	r18,r16,r18
81127fb4:	81c00007 	ldb	r7,0(r16)
81127fb8:	01800284 	movi	r6,10
81127fbc:	84000044 	addi	r16,r16,1
81127fc0:	100b883a 	mov	r5,r2
81127fc4:	39fff404 	addi	r7,r7,-48
81127fc8:	8809883a 	mov	r4,r17
81127fcc:	1127dd00 	call	81127dd0 <__multadd>
81127fd0:	84bff81e 	bne	r16,r18,81127fb4 <__reset+0xfb107fb4>
81127fd4:	dfc00617 	ldw	ra,24(sp)
81127fd8:	dd400517 	ldw	r21,20(sp)
81127fdc:	dd000417 	ldw	r20,16(sp)
81127fe0:	dcc00317 	ldw	r19,12(sp)
81127fe4:	dc800217 	ldw	r18,8(sp)
81127fe8:	dc400117 	ldw	r17,4(sp)
81127fec:	dc000017 	ldw	r16,0(sp)
81127ff0:	dec00704 	addi	sp,sp,28
81127ff4:	f800283a 	ret
81127ff8:	84000284 	addi	r16,r16,10
81127ffc:	1827883a 	mov	r19,r3
81128000:	003fe906 	br	81127fa8 <__reset+0xfb107fa8>

81128004 <__hi0bits>:
81128004:	20bfffec 	andhi	r2,r4,65535
81128008:	1000141e 	bne	r2,zero,8112805c <__hi0bits+0x58>
8112800c:	2008943a 	slli	r4,r4,16
81128010:	00800404 	movi	r2,16
81128014:	20ffc02c 	andhi	r3,r4,65280
81128018:	1800021e 	bne	r3,zero,81128024 <__hi0bits+0x20>
8112801c:	2008923a 	slli	r4,r4,8
81128020:	10800204 	addi	r2,r2,8
81128024:	20fc002c 	andhi	r3,r4,61440
81128028:	1800021e 	bne	r3,zero,81128034 <__hi0bits+0x30>
8112802c:	2008913a 	slli	r4,r4,4
81128030:	10800104 	addi	r2,r2,4
81128034:	20f0002c 	andhi	r3,r4,49152
81128038:	1800031e 	bne	r3,zero,81128048 <__hi0bits+0x44>
8112803c:	2109883a 	add	r4,r4,r4
81128040:	10800084 	addi	r2,r2,2
81128044:	2109883a 	add	r4,r4,r4
81128048:	20000316 	blt	r4,zero,81128058 <__hi0bits+0x54>
8112804c:	2110002c 	andhi	r4,r4,16384
81128050:	2000041e 	bne	r4,zero,81128064 <__hi0bits+0x60>
81128054:	00800804 	movi	r2,32
81128058:	f800283a 	ret
8112805c:	0005883a 	mov	r2,zero
81128060:	003fec06 	br	81128014 <__reset+0xfb108014>
81128064:	10800044 	addi	r2,r2,1
81128068:	f800283a 	ret

8112806c <__lo0bits>:
8112806c:	20c00017 	ldw	r3,0(r4)
81128070:	188001cc 	andi	r2,r3,7
81128074:	10000826 	beq	r2,zero,81128098 <__lo0bits+0x2c>
81128078:	1880004c 	andi	r2,r3,1
8112807c:	1000211e 	bne	r2,zero,81128104 <__lo0bits+0x98>
81128080:	1880008c 	andi	r2,r3,2
81128084:	1000211e 	bne	r2,zero,8112810c <__lo0bits+0xa0>
81128088:	1806d0ba 	srli	r3,r3,2
8112808c:	00800084 	movi	r2,2
81128090:	20c00015 	stw	r3,0(r4)
81128094:	f800283a 	ret
81128098:	18bfffcc 	andi	r2,r3,65535
8112809c:	10001326 	beq	r2,zero,811280ec <__lo0bits+0x80>
811280a0:	0005883a 	mov	r2,zero
811280a4:	19403fcc 	andi	r5,r3,255
811280a8:	2800021e 	bne	r5,zero,811280b4 <__lo0bits+0x48>
811280ac:	1806d23a 	srli	r3,r3,8
811280b0:	10800204 	addi	r2,r2,8
811280b4:	194003cc 	andi	r5,r3,15
811280b8:	2800021e 	bne	r5,zero,811280c4 <__lo0bits+0x58>
811280bc:	1806d13a 	srli	r3,r3,4
811280c0:	10800104 	addi	r2,r2,4
811280c4:	194000cc 	andi	r5,r3,3
811280c8:	2800021e 	bne	r5,zero,811280d4 <__lo0bits+0x68>
811280cc:	1806d0ba 	srli	r3,r3,2
811280d0:	10800084 	addi	r2,r2,2
811280d4:	1940004c 	andi	r5,r3,1
811280d8:	2800081e 	bne	r5,zero,811280fc <__lo0bits+0x90>
811280dc:	1806d07a 	srli	r3,r3,1
811280e0:	1800051e 	bne	r3,zero,811280f8 <__lo0bits+0x8c>
811280e4:	00800804 	movi	r2,32
811280e8:	f800283a 	ret
811280ec:	1806d43a 	srli	r3,r3,16
811280f0:	00800404 	movi	r2,16
811280f4:	003feb06 	br	811280a4 <__reset+0xfb1080a4>
811280f8:	10800044 	addi	r2,r2,1
811280fc:	20c00015 	stw	r3,0(r4)
81128100:	f800283a 	ret
81128104:	0005883a 	mov	r2,zero
81128108:	f800283a 	ret
8112810c:	1806d07a 	srli	r3,r3,1
81128110:	00800044 	movi	r2,1
81128114:	20c00015 	stw	r3,0(r4)
81128118:	f800283a 	ret

8112811c <__i2b>:
8112811c:	defffd04 	addi	sp,sp,-12
81128120:	de00012e 	bgeu	sp,et,81128128 <__i2b+0xc>
81128124:	003b68fa 	trap	3
81128128:	dc000015 	stw	r16,0(sp)
8112812c:	04000044 	movi	r16,1
81128130:	dc400115 	stw	r17,4(sp)
81128134:	2823883a 	mov	r17,r5
81128138:	800b883a 	mov	r5,r16
8112813c:	dfc00215 	stw	ra,8(sp)
81128140:	1127cf80 	call	81127cf8 <_Balloc>
81128144:	14400515 	stw	r17,20(r2)
81128148:	14000415 	stw	r16,16(r2)
8112814c:	dfc00217 	ldw	ra,8(sp)
81128150:	dc400117 	ldw	r17,4(sp)
81128154:	dc000017 	ldw	r16,0(sp)
81128158:	dec00304 	addi	sp,sp,12
8112815c:	f800283a 	ret

81128160 <__multiply>:
81128160:	defffa04 	addi	sp,sp,-24
81128164:	de00012e 	bgeu	sp,et,8112816c <__multiply+0xc>
81128168:	003b68fa 	trap	3
8112816c:	dcc00315 	stw	r19,12(sp)
81128170:	dc800215 	stw	r18,8(sp)
81128174:	34c00417 	ldw	r19,16(r6)
81128178:	2c800417 	ldw	r18,16(r5)
8112817c:	dd000415 	stw	r20,16(sp)
81128180:	dc400115 	stw	r17,4(sp)
81128184:	dfc00515 	stw	ra,20(sp)
81128188:	dc000015 	stw	r16,0(sp)
8112818c:	2829883a 	mov	r20,r5
81128190:	3023883a 	mov	r17,r6
81128194:	94c0050e 	bge	r18,r19,811281ac <__multiply+0x4c>
81128198:	9007883a 	mov	r3,r18
8112819c:	3029883a 	mov	r20,r6
811281a0:	9825883a 	mov	r18,r19
811281a4:	2823883a 	mov	r17,r5
811281a8:	1827883a 	mov	r19,r3
811281ac:	a0800217 	ldw	r2,8(r20)
811281b0:	94e1883a 	add	r16,r18,r19
811281b4:	a1400117 	ldw	r5,4(r20)
811281b8:	1400010e 	bge	r2,r16,811281c0 <__multiply+0x60>
811281bc:	29400044 	addi	r5,r5,1
811281c0:	1127cf80 	call	81127cf8 <_Balloc>
811281c4:	8415883a 	add	r10,r16,r16
811281c8:	12c00504 	addi	r11,r2,20
811281cc:	5295883a 	add	r10,r10,r10
811281d0:	5a95883a 	add	r10,r11,r10
811281d4:	5807883a 	mov	r3,r11
811281d8:	5a80032e 	bgeu	r11,r10,811281e8 <__multiply+0x88>
811281dc:	18000015 	stw	zero,0(r3)
811281e0:	18c00104 	addi	r3,r3,4
811281e4:	1abffd36 	bltu	r3,r10,811281dc <__reset+0xfb1081dc>
811281e8:	9ce7883a 	add	r19,r19,r19
811281ec:	94a5883a 	add	r18,r18,r18
811281f0:	89800504 	addi	r6,r17,20
811281f4:	9ce7883a 	add	r19,r19,r19
811281f8:	a3400504 	addi	r13,r20,20
811281fc:	94a5883a 	add	r18,r18,r18
81128200:	34d9883a 	add	r12,r6,r19
81128204:	6c93883a 	add	r9,r13,r18
81128208:	3300422e 	bgeu	r6,r12,81128314 <__multiply+0x1b4>
8112820c:	37c00017 	ldw	ra,0(r6)
81128210:	fbffffcc 	andi	r15,ra,65535
81128214:	78001b26 	beq	r15,zero,81128284 <__multiply+0x124>
81128218:	5811883a 	mov	r8,r11
8112821c:	681d883a 	mov	r14,r13
81128220:	000f883a 	mov	r7,zero
81128224:	71000017 	ldw	r4,0(r14)
81128228:	40c00017 	ldw	r3,0(r8)
8112822c:	73800104 	addi	r14,r14,4
81128230:	217fffcc 	andi	r5,r4,65535
81128234:	2bcb383a 	mul	r5,r5,r15
81128238:	2008d43a 	srli	r4,r4,16
8112823c:	1c7fffcc 	andi	r17,r3,65535
81128240:	2c4b883a 	add	r5,r5,r17
81128244:	29cb883a 	add	r5,r5,r7
81128248:	23c9383a 	mul	r4,r4,r15
8112824c:	1806d43a 	srli	r3,r3,16
81128250:	280ed43a 	srli	r7,r5,16
81128254:	297fffcc 	andi	r5,r5,65535
81128258:	20c7883a 	add	r3,r4,r3
8112825c:	19c7883a 	add	r3,r3,r7
81128260:	1808943a 	slli	r4,r3,16
81128264:	4023883a 	mov	r17,r8
81128268:	180ed43a 	srli	r7,r3,16
8112826c:	214ab03a 	or	r5,r4,r5
81128270:	41400015 	stw	r5,0(r8)
81128274:	42000104 	addi	r8,r8,4
81128278:	727fea36 	bltu	r14,r9,81128224 <__reset+0xfb108224>
8112827c:	89c00115 	stw	r7,4(r17)
81128280:	37c00017 	ldw	ra,0(r6)
81128284:	f83ed43a 	srli	ra,ra,16
81128288:	f8001f26 	beq	ra,zero,81128308 <__multiply+0x1a8>
8112828c:	58c00017 	ldw	r3,0(r11)
81128290:	681d883a 	mov	r14,r13
81128294:	581f883a 	mov	r15,r11
81128298:	1811883a 	mov	r8,r3
8112829c:	5825883a 	mov	r18,r11
811282a0:	000f883a 	mov	r7,zero
811282a4:	00000106 	br	811282ac <__multiply+0x14c>
811282a8:	8825883a 	mov	r18,r17
811282ac:	7140000b 	ldhu	r5,0(r14)
811282b0:	4010d43a 	srli	r8,r8,16
811282b4:	193fffcc 	andi	r4,r3,65535
811282b8:	2fcb383a 	mul	r5,r5,ra
811282bc:	7bc00104 	addi	r15,r15,4
811282c0:	73800104 	addi	r14,r14,4
811282c4:	2a0b883a 	add	r5,r5,r8
811282c8:	29cb883a 	add	r5,r5,r7
811282cc:	2806943a 	slli	r3,r5,16
811282d0:	94400104 	addi	r17,r18,4
811282d4:	280ad43a 	srli	r5,r5,16
811282d8:	1908b03a 	or	r4,r3,r4
811282dc:	793fff15 	stw	r4,-4(r15)
811282e0:	70ffff17 	ldw	r3,-4(r14)
811282e4:	8a000017 	ldw	r8,0(r17)
811282e8:	1806d43a 	srli	r3,r3,16
811282ec:	413fffcc 	andi	r4,r8,65535
811282f0:	1fc7383a 	mul	r3,r3,ra
811282f4:	1907883a 	add	r3,r3,r4
811282f8:	1947883a 	add	r3,r3,r5
811282fc:	180ed43a 	srli	r7,r3,16
81128300:	727fe936 	bltu	r14,r9,811282a8 <__reset+0xfb1082a8>
81128304:	90c00115 	stw	r3,4(r18)
81128308:	31800104 	addi	r6,r6,4
8112830c:	5ac00104 	addi	r11,r11,4
81128310:	333fbe36 	bltu	r6,r12,8112820c <__reset+0xfb10820c>
81128314:	0400090e 	bge	zero,r16,8112833c <__multiply+0x1dc>
81128318:	50ffff17 	ldw	r3,-4(r10)
8112831c:	52bfff04 	addi	r10,r10,-4
81128320:	18000326 	beq	r3,zero,81128330 <__multiply+0x1d0>
81128324:	00000506 	br	8112833c <__multiply+0x1dc>
81128328:	50c00017 	ldw	r3,0(r10)
8112832c:	1800031e 	bne	r3,zero,8112833c <__multiply+0x1dc>
81128330:	843fffc4 	addi	r16,r16,-1
81128334:	52bfff04 	addi	r10,r10,-4
81128338:	803ffb1e 	bne	r16,zero,81128328 <__reset+0xfb108328>
8112833c:	14000415 	stw	r16,16(r2)
81128340:	dfc00517 	ldw	ra,20(sp)
81128344:	dd000417 	ldw	r20,16(sp)
81128348:	dcc00317 	ldw	r19,12(sp)
8112834c:	dc800217 	ldw	r18,8(sp)
81128350:	dc400117 	ldw	r17,4(sp)
81128354:	dc000017 	ldw	r16,0(sp)
81128358:	dec00604 	addi	sp,sp,24
8112835c:	f800283a 	ret

81128360 <__pow5mult>:
81128360:	defffa04 	addi	sp,sp,-24
81128364:	de00012e 	bgeu	sp,et,8112836c <__pow5mult+0xc>
81128368:	003b68fa 	trap	3
8112836c:	308000cc 	andi	r2,r6,3
81128370:	dcc00315 	stw	r19,12(sp)
81128374:	dc000015 	stw	r16,0(sp)
81128378:	dfc00515 	stw	ra,20(sp)
8112837c:	dd000415 	stw	r20,16(sp)
81128380:	dc800215 	stw	r18,8(sp)
81128384:	dc400115 	stw	r17,4(sp)
81128388:	3021883a 	mov	r16,r6
8112838c:	2027883a 	mov	r19,r4
81128390:	10002f1e 	bne	r2,zero,81128450 <__pow5mult+0xf0>
81128394:	2825883a 	mov	r18,r5
81128398:	8021d0ba 	srai	r16,r16,2
8112839c:	80001a26 	beq	r16,zero,81128408 <__pow5mult+0xa8>
811283a0:	9c401217 	ldw	r17,72(r19)
811283a4:	8800061e 	bne	r17,zero,811283c0 <__pow5mult+0x60>
811283a8:	00003406 	br	8112847c <__pow5mult+0x11c>
811283ac:	8021d07a 	srai	r16,r16,1
811283b0:	80001526 	beq	r16,zero,81128408 <__pow5mult+0xa8>
811283b4:	88800017 	ldw	r2,0(r17)
811283b8:	10001c26 	beq	r2,zero,8112842c <__pow5mult+0xcc>
811283bc:	1023883a 	mov	r17,r2
811283c0:	8080004c 	andi	r2,r16,1
811283c4:	103ff926 	beq	r2,zero,811283ac <__reset+0xfb1083ac>
811283c8:	880d883a 	mov	r6,r17
811283cc:	900b883a 	mov	r5,r18
811283d0:	9809883a 	mov	r4,r19
811283d4:	11281600 	call	81128160 <__multiply>
811283d8:	90001b26 	beq	r18,zero,81128448 <__pow5mult+0xe8>
811283dc:	91000117 	ldw	r4,4(r18)
811283e0:	98c01317 	ldw	r3,76(r19)
811283e4:	8021d07a 	srai	r16,r16,1
811283e8:	2109883a 	add	r4,r4,r4
811283ec:	2109883a 	add	r4,r4,r4
811283f0:	1907883a 	add	r3,r3,r4
811283f4:	19000017 	ldw	r4,0(r3)
811283f8:	91000015 	stw	r4,0(r18)
811283fc:	1c800015 	stw	r18,0(r3)
81128400:	1025883a 	mov	r18,r2
81128404:	803feb1e 	bne	r16,zero,811283b4 <__reset+0xfb1083b4>
81128408:	9005883a 	mov	r2,r18
8112840c:	dfc00517 	ldw	ra,20(sp)
81128410:	dd000417 	ldw	r20,16(sp)
81128414:	dcc00317 	ldw	r19,12(sp)
81128418:	dc800217 	ldw	r18,8(sp)
8112841c:	dc400117 	ldw	r17,4(sp)
81128420:	dc000017 	ldw	r16,0(sp)
81128424:	dec00604 	addi	sp,sp,24
81128428:	f800283a 	ret
8112842c:	880d883a 	mov	r6,r17
81128430:	880b883a 	mov	r5,r17
81128434:	9809883a 	mov	r4,r19
81128438:	11281600 	call	81128160 <__multiply>
8112843c:	88800015 	stw	r2,0(r17)
81128440:	10000015 	stw	zero,0(r2)
81128444:	003fdd06 	br	811283bc <__reset+0xfb1083bc>
81128448:	1025883a 	mov	r18,r2
8112844c:	003fd706 	br	811283ac <__reset+0xfb1083ac>
81128450:	10bfffc4 	addi	r2,r2,-1
81128454:	1085883a 	add	r2,r2,r2
81128458:	00e04574 	movhi	r3,33045
8112845c:	18f0dc04 	addi	r3,r3,-15504
81128460:	1085883a 	add	r2,r2,r2
81128464:	1885883a 	add	r2,r3,r2
81128468:	11800017 	ldw	r6,0(r2)
8112846c:	000f883a 	mov	r7,zero
81128470:	1127dd00 	call	81127dd0 <__multadd>
81128474:	1025883a 	mov	r18,r2
81128478:	003fc706 	br	81128398 <__reset+0xfb108398>
8112847c:	05000044 	movi	r20,1
81128480:	a00b883a 	mov	r5,r20
81128484:	9809883a 	mov	r4,r19
81128488:	1127cf80 	call	81127cf8 <_Balloc>
8112848c:	1023883a 	mov	r17,r2
81128490:	00809c44 	movi	r2,625
81128494:	88800515 	stw	r2,20(r17)
81128498:	8d000415 	stw	r20,16(r17)
8112849c:	9c401215 	stw	r17,72(r19)
811284a0:	88000015 	stw	zero,0(r17)
811284a4:	003fc606 	br	811283c0 <__reset+0xfb1083c0>

811284a8 <__lshift>:
811284a8:	defff904 	addi	sp,sp,-28
811284ac:	de00012e 	bgeu	sp,et,811284b4 <__lshift+0xc>
811284b0:	003b68fa 	trap	3
811284b4:	dd400515 	stw	r21,20(sp)
811284b8:	dcc00315 	stw	r19,12(sp)
811284bc:	302bd17a 	srai	r21,r6,5
811284c0:	2cc00417 	ldw	r19,16(r5)
811284c4:	28800217 	ldw	r2,8(r5)
811284c8:	dd000415 	stw	r20,16(sp)
811284cc:	ace7883a 	add	r19,r21,r19
811284d0:	dc800215 	stw	r18,8(sp)
811284d4:	dc400115 	stw	r17,4(sp)
811284d8:	dc000015 	stw	r16,0(sp)
811284dc:	dfc00615 	stw	ra,24(sp)
811284e0:	9c000044 	addi	r16,r19,1
811284e4:	2823883a 	mov	r17,r5
811284e8:	3029883a 	mov	r20,r6
811284ec:	2025883a 	mov	r18,r4
811284f0:	29400117 	ldw	r5,4(r5)
811284f4:	1400030e 	bge	r2,r16,81128504 <__lshift+0x5c>
811284f8:	1085883a 	add	r2,r2,r2
811284fc:	29400044 	addi	r5,r5,1
81128500:	143ffd16 	blt	r2,r16,811284f8 <__reset+0xfb1084f8>
81128504:	9009883a 	mov	r4,r18
81128508:	1127cf80 	call	81127cf8 <_Balloc>
8112850c:	10c00504 	addi	r3,r2,20
81128510:	0540070e 	bge	zero,r21,81128530 <__lshift+0x88>
81128514:	ad6b883a 	add	r21,r21,r21
81128518:	ad6b883a 	add	r21,r21,r21
8112851c:	1809883a 	mov	r4,r3
81128520:	1d47883a 	add	r3,r3,r21
81128524:	20000015 	stw	zero,0(r4)
81128528:	21000104 	addi	r4,r4,4
8112852c:	193ffd1e 	bne	r3,r4,81128524 <__reset+0xfb108524>
81128530:	8a000417 	ldw	r8,16(r17)
81128534:	89000504 	addi	r4,r17,20
81128538:	a18007cc 	andi	r6,r20,31
8112853c:	4211883a 	add	r8,r8,r8
81128540:	4211883a 	add	r8,r8,r8
81128544:	2211883a 	add	r8,r4,r8
81128548:	30002326 	beq	r6,zero,811285d8 <__lshift+0x130>
8112854c:	02400804 	movi	r9,32
81128550:	4993c83a 	sub	r9,r9,r6
81128554:	000b883a 	mov	r5,zero
81128558:	21c00017 	ldw	r7,0(r4)
8112855c:	1815883a 	mov	r10,r3
81128560:	18c00104 	addi	r3,r3,4
81128564:	398e983a 	sll	r7,r7,r6
81128568:	21000104 	addi	r4,r4,4
8112856c:	394ab03a 	or	r5,r7,r5
81128570:	197fff15 	stw	r5,-4(r3)
81128574:	217fff17 	ldw	r5,-4(r4)
81128578:	2a4ad83a 	srl	r5,r5,r9
8112857c:	223ff636 	bltu	r4,r8,81128558 <__reset+0xfb108558>
81128580:	51400115 	stw	r5,4(r10)
81128584:	28001a1e 	bne	r5,zero,811285f0 <__lshift+0x148>
81128588:	843fffc4 	addi	r16,r16,-1
8112858c:	14000415 	stw	r16,16(r2)
81128590:	88000826 	beq	r17,zero,811285b4 <__lshift+0x10c>
81128594:	89000117 	ldw	r4,4(r17)
81128598:	90c01317 	ldw	r3,76(r18)
8112859c:	2109883a 	add	r4,r4,r4
811285a0:	2109883a 	add	r4,r4,r4
811285a4:	1907883a 	add	r3,r3,r4
811285a8:	19000017 	ldw	r4,0(r3)
811285ac:	89000015 	stw	r4,0(r17)
811285b0:	1c400015 	stw	r17,0(r3)
811285b4:	dfc00617 	ldw	ra,24(sp)
811285b8:	dd400517 	ldw	r21,20(sp)
811285bc:	dd000417 	ldw	r20,16(sp)
811285c0:	dcc00317 	ldw	r19,12(sp)
811285c4:	dc800217 	ldw	r18,8(sp)
811285c8:	dc400117 	ldw	r17,4(sp)
811285cc:	dc000017 	ldw	r16,0(sp)
811285d0:	dec00704 	addi	sp,sp,28
811285d4:	f800283a 	ret
811285d8:	21400017 	ldw	r5,0(r4)
811285dc:	18c00104 	addi	r3,r3,4
811285e0:	21000104 	addi	r4,r4,4
811285e4:	197fff15 	stw	r5,-4(r3)
811285e8:	223ffb36 	bltu	r4,r8,811285d8 <__reset+0xfb1085d8>
811285ec:	003fe606 	br	81128588 <__reset+0xfb108588>
811285f0:	9c000084 	addi	r16,r19,2
811285f4:	003fe406 	br	81128588 <__reset+0xfb108588>

811285f8 <__mcmp>:
811285f8:	20800417 	ldw	r2,16(r4)
811285fc:	28c00417 	ldw	r3,16(r5)
81128600:	10c5c83a 	sub	r2,r2,r3
81128604:	1000111e 	bne	r2,zero,8112864c <__mcmp+0x54>
81128608:	18c7883a 	add	r3,r3,r3
8112860c:	18c7883a 	add	r3,r3,r3
81128610:	21000504 	addi	r4,r4,20
81128614:	29400504 	addi	r5,r5,20
81128618:	20c5883a 	add	r2,r4,r3
8112861c:	28cb883a 	add	r5,r5,r3
81128620:	00000106 	br	81128628 <__mcmp+0x30>
81128624:	20800a2e 	bgeu	r4,r2,81128650 <__mcmp+0x58>
81128628:	10bfff04 	addi	r2,r2,-4
8112862c:	297fff04 	addi	r5,r5,-4
81128630:	11800017 	ldw	r6,0(r2)
81128634:	28c00017 	ldw	r3,0(r5)
81128638:	30fffa26 	beq	r6,r3,81128624 <__reset+0xfb108624>
8112863c:	30c00236 	bltu	r6,r3,81128648 <__mcmp+0x50>
81128640:	00800044 	movi	r2,1
81128644:	f800283a 	ret
81128648:	00bfffc4 	movi	r2,-1
8112864c:	f800283a 	ret
81128650:	0005883a 	mov	r2,zero
81128654:	f800283a 	ret

81128658 <__mdiff>:
81128658:	defffa04 	addi	sp,sp,-24
8112865c:	de00012e 	bgeu	sp,et,81128664 <__mdiff+0xc>
81128660:	003b68fa 	trap	3
81128664:	28c00417 	ldw	r3,16(r5)
81128668:	30800417 	ldw	r2,16(r6)
8112866c:	dcc00315 	stw	r19,12(sp)
81128670:	dc800215 	stw	r18,8(sp)
81128674:	dfc00515 	stw	ra,20(sp)
81128678:	dd000415 	stw	r20,16(sp)
8112867c:	dc400115 	stw	r17,4(sp)
81128680:	dc000015 	stw	r16,0(sp)
81128684:	1887c83a 	sub	r3,r3,r2
81128688:	2825883a 	mov	r18,r5
8112868c:	3027883a 	mov	r19,r6
81128690:	1800141e 	bne	r3,zero,811286e4 <__mdiff+0x8c>
81128694:	1085883a 	add	r2,r2,r2
81128698:	1085883a 	add	r2,r2,r2
8112869c:	2a000504 	addi	r8,r5,20
811286a0:	34000504 	addi	r16,r6,20
811286a4:	4087883a 	add	r3,r8,r2
811286a8:	8085883a 	add	r2,r16,r2
811286ac:	00000106 	br	811286b4 <__mdiff+0x5c>
811286b0:	40c0592e 	bgeu	r8,r3,81128818 <__mdiff+0x1c0>
811286b4:	18ffff04 	addi	r3,r3,-4
811286b8:	10bfff04 	addi	r2,r2,-4
811286bc:	19c00017 	ldw	r7,0(r3)
811286c0:	11400017 	ldw	r5,0(r2)
811286c4:	397ffa26 	beq	r7,r5,811286b0 <__reset+0xfb1086b0>
811286c8:	3940592e 	bgeu	r7,r5,81128830 <__mdiff+0x1d8>
811286cc:	9005883a 	mov	r2,r18
811286d0:	4023883a 	mov	r17,r8
811286d4:	9825883a 	mov	r18,r19
811286d8:	05000044 	movi	r20,1
811286dc:	1027883a 	mov	r19,r2
811286e0:	00000406 	br	811286f4 <__mdiff+0x9c>
811286e4:	18005616 	blt	r3,zero,81128840 <__mdiff+0x1e8>
811286e8:	34400504 	addi	r17,r6,20
811286ec:	2c000504 	addi	r16,r5,20
811286f0:	0029883a 	mov	r20,zero
811286f4:	91400117 	ldw	r5,4(r18)
811286f8:	1127cf80 	call	81127cf8 <_Balloc>
811286fc:	92400417 	ldw	r9,16(r18)
81128700:	9b000417 	ldw	r12,16(r19)
81128704:	12c00504 	addi	r11,r2,20
81128708:	4a51883a 	add	r8,r9,r9
8112870c:	6319883a 	add	r12,r12,r12
81128710:	4211883a 	add	r8,r8,r8
81128714:	6319883a 	add	r12,r12,r12
81128718:	15000315 	stw	r20,12(r2)
8112871c:	8211883a 	add	r8,r16,r8
81128720:	8b19883a 	add	r12,r17,r12
81128724:	0007883a 	mov	r3,zero
81128728:	81400017 	ldw	r5,0(r16)
8112872c:	89c00017 	ldw	r7,0(r17)
81128730:	59800104 	addi	r6,r11,4
81128734:	293fffcc 	andi	r4,r5,65535
81128738:	20c7883a 	add	r3,r4,r3
8112873c:	393fffcc 	andi	r4,r7,65535
81128740:	1909c83a 	sub	r4,r3,r4
81128744:	280ad43a 	srli	r5,r5,16
81128748:	380ed43a 	srli	r7,r7,16
8112874c:	2007d43a 	srai	r3,r4,16
81128750:	213fffcc 	andi	r4,r4,65535
81128754:	29cbc83a 	sub	r5,r5,r7
81128758:	28c7883a 	add	r3,r5,r3
8112875c:	180a943a 	slli	r5,r3,16
81128760:	8c400104 	addi	r17,r17,4
81128764:	84000104 	addi	r16,r16,4
81128768:	2908b03a 	or	r4,r5,r4
8112876c:	59000015 	stw	r4,0(r11)
81128770:	1807d43a 	srai	r3,r3,16
81128774:	3015883a 	mov	r10,r6
81128778:	3017883a 	mov	r11,r6
8112877c:	8b3fea36 	bltu	r17,r12,81128728 <__reset+0xfb108728>
81128780:	8200162e 	bgeu	r16,r8,811287dc <__mdiff+0x184>
81128784:	8017883a 	mov	r11,r16
81128788:	59400017 	ldw	r5,0(r11)
8112878c:	31800104 	addi	r6,r6,4
81128790:	5ac00104 	addi	r11,r11,4
81128794:	293fffcc 	andi	r4,r5,65535
81128798:	20c7883a 	add	r3,r4,r3
8112879c:	280ed43a 	srli	r7,r5,16
811287a0:	180bd43a 	srai	r5,r3,16
811287a4:	193fffcc 	andi	r4,r3,65535
811287a8:	3947883a 	add	r3,r7,r5
811287ac:	180a943a 	slli	r5,r3,16
811287b0:	1807d43a 	srai	r3,r3,16
811287b4:	2908b03a 	or	r4,r5,r4
811287b8:	313fff15 	stw	r4,-4(r6)
811287bc:	5a3ff236 	bltu	r11,r8,81128788 <__reset+0xfb108788>
811287c0:	0406303a 	nor	r3,zero,r16
811287c4:	1a07883a 	add	r3,r3,r8
811287c8:	1806d0ba 	srli	r3,r3,2
811287cc:	18c00044 	addi	r3,r3,1
811287d0:	18c7883a 	add	r3,r3,r3
811287d4:	18c7883a 	add	r3,r3,r3
811287d8:	50d5883a 	add	r10,r10,r3
811287dc:	50ffff04 	addi	r3,r10,-4
811287e0:	2000041e 	bne	r4,zero,811287f4 <__mdiff+0x19c>
811287e4:	18ffff04 	addi	r3,r3,-4
811287e8:	19000017 	ldw	r4,0(r3)
811287ec:	4a7fffc4 	addi	r9,r9,-1
811287f0:	203ffc26 	beq	r4,zero,811287e4 <__reset+0xfb1087e4>
811287f4:	12400415 	stw	r9,16(r2)
811287f8:	dfc00517 	ldw	ra,20(sp)
811287fc:	dd000417 	ldw	r20,16(sp)
81128800:	dcc00317 	ldw	r19,12(sp)
81128804:	dc800217 	ldw	r18,8(sp)
81128808:	dc400117 	ldw	r17,4(sp)
8112880c:	dc000017 	ldw	r16,0(sp)
81128810:	dec00604 	addi	sp,sp,24
81128814:	f800283a 	ret
81128818:	000b883a 	mov	r5,zero
8112881c:	1127cf80 	call	81127cf8 <_Balloc>
81128820:	00c00044 	movi	r3,1
81128824:	10c00415 	stw	r3,16(r2)
81128828:	10000515 	stw	zero,20(r2)
8112882c:	003ff206 	br	811287f8 <__reset+0xfb1087f8>
81128830:	8023883a 	mov	r17,r16
81128834:	0029883a 	mov	r20,zero
81128838:	4021883a 	mov	r16,r8
8112883c:	003fad06 	br	811286f4 <__reset+0xfb1086f4>
81128840:	9005883a 	mov	r2,r18
81128844:	94400504 	addi	r17,r18,20
81128848:	9c000504 	addi	r16,r19,20
8112884c:	9825883a 	mov	r18,r19
81128850:	05000044 	movi	r20,1
81128854:	1027883a 	mov	r19,r2
81128858:	003fa606 	br	811286f4 <__reset+0xfb1086f4>

8112885c <__ulp>:
8112885c:	295ffc2c 	andhi	r5,r5,32752
81128860:	00bf3034 	movhi	r2,64704
81128864:	2887883a 	add	r3,r5,r2
81128868:	00c0020e 	bge	zero,r3,81128874 <__ulp+0x18>
8112886c:	0005883a 	mov	r2,zero
81128870:	f800283a 	ret
81128874:	00c7c83a 	sub	r3,zero,r3
81128878:	1807d53a 	srai	r3,r3,20
8112887c:	008004c4 	movi	r2,19
81128880:	10c00b0e 	bge	r2,r3,811288b0 <__ulp+0x54>
81128884:	18bffb04 	addi	r2,r3,-20
81128888:	01000784 	movi	r4,30
8112888c:	0007883a 	mov	r3,zero
81128890:	20800516 	blt	r4,r2,811288a8 <__ulp+0x4c>
81128894:	010007c4 	movi	r4,31
81128898:	2089c83a 	sub	r4,r4,r2
8112889c:	00800044 	movi	r2,1
811288a0:	1104983a 	sll	r2,r2,r4
811288a4:	f800283a 	ret
811288a8:	00800044 	movi	r2,1
811288ac:	f800283a 	ret
811288b0:	01400234 	movhi	r5,8
811288b4:	28c7d83a 	sra	r3,r5,r3
811288b8:	0005883a 	mov	r2,zero
811288bc:	f800283a 	ret

811288c0 <__b2d>:
811288c0:	defffa04 	addi	sp,sp,-24
811288c4:	de00012e 	bgeu	sp,et,811288cc <__b2d+0xc>
811288c8:	003b68fa 	trap	3
811288cc:	dc000015 	stw	r16,0(sp)
811288d0:	24000417 	ldw	r16,16(r4)
811288d4:	dc400115 	stw	r17,4(sp)
811288d8:	24400504 	addi	r17,r4,20
811288dc:	8421883a 	add	r16,r16,r16
811288e0:	8421883a 	add	r16,r16,r16
811288e4:	8c21883a 	add	r16,r17,r16
811288e8:	dc800215 	stw	r18,8(sp)
811288ec:	84bfff17 	ldw	r18,-4(r16)
811288f0:	dd000415 	stw	r20,16(sp)
811288f4:	dcc00315 	stw	r19,12(sp)
811288f8:	9009883a 	mov	r4,r18
811288fc:	2829883a 	mov	r20,r5
81128900:	dfc00515 	stw	ra,20(sp)
81128904:	11280040 	call	81128004 <__hi0bits>
81128908:	00c00804 	movi	r3,32
8112890c:	1889c83a 	sub	r4,r3,r2
81128910:	a1000015 	stw	r4,0(r20)
81128914:	01000284 	movi	r4,10
81128918:	84ffff04 	addi	r19,r16,-4
8112891c:	20801216 	blt	r4,r2,81128968 <__b2d+0xa8>
81128920:	018002c4 	movi	r6,11
81128924:	308dc83a 	sub	r6,r6,r2
81128928:	9186d83a 	srl	r3,r18,r6
8112892c:	18cffc34 	orhi	r3,r3,16368
81128930:	8cc0212e 	bgeu	r17,r19,811289b8 <__b2d+0xf8>
81128934:	813ffe17 	ldw	r4,-8(r16)
81128938:	218cd83a 	srl	r6,r4,r6
8112893c:	10800544 	addi	r2,r2,21
81128940:	9084983a 	sll	r2,r18,r2
81128944:	1184b03a 	or	r2,r2,r6
81128948:	dfc00517 	ldw	ra,20(sp)
8112894c:	dd000417 	ldw	r20,16(sp)
81128950:	dcc00317 	ldw	r19,12(sp)
81128954:	dc800217 	ldw	r18,8(sp)
81128958:	dc400117 	ldw	r17,4(sp)
8112895c:	dc000017 	ldw	r16,0(sp)
81128960:	dec00604 	addi	sp,sp,24
81128964:	f800283a 	ret
81128968:	8cc00f2e 	bgeu	r17,r19,811289a8 <__b2d+0xe8>
8112896c:	117ffd44 	addi	r5,r2,-11
81128970:	80bffe17 	ldw	r2,-8(r16)
81128974:	28000e26 	beq	r5,zero,811289b0 <__b2d+0xf0>
81128978:	1949c83a 	sub	r4,r3,r5
8112897c:	9164983a 	sll	r18,r18,r5
81128980:	1106d83a 	srl	r3,r2,r4
81128984:	81bffe04 	addi	r6,r16,-8
81128988:	948ffc34 	orhi	r18,r18,16368
8112898c:	90c6b03a 	or	r3,r18,r3
81128990:	89800e2e 	bgeu	r17,r6,811289cc <__b2d+0x10c>
81128994:	81bffd17 	ldw	r6,-12(r16)
81128998:	1144983a 	sll	r2,r2,r5
8112899c:	310ad83a 	srl	r5,r6,r4
811289a0:	2884b03a 	or	r2,r5,r2
811289a4:	003fe806 	br	81128948 <__reset+0xfb108948>
811289a8:	10bffd44 	addi	r2,r2,-11
811289ac:	1000041e 	bne	r2,zero,811289c0 <__b2d+0x100>
811289b0:	90cffc34 	orhi	r3,r18,16368
811289b4:	003fe406 	br	81128948 <__reset+0xfb108948>
811289b8:	000d883a 	mov	r6,zero
811289bc:	003fdf06 	br	8112893c <__reset+0xfb10893c>
811289c0:	90a4983a 	sll	r18,r18,r2
811289c4:	0005883a 	mov	r2,zero
811289c8:	003ff906 	br	811289b0 <__reset+0xfb1089b0>
811289cc:	1144983a 	sll	r2,r2,r5
811289d0:	003fdd06 	br	81128948 <__reset+0xfb108948>

811289d4 <__d2b>:
811289d4:	defff804 	addi	sp,sp,-32
811289d8:	de00012e 	bgeu	sp,et,811289e0 <__d2b+0xc>
811289dc:	003b68fa 	trap	3
811289e0:	dc000215 	stw	r16,8(sp)
811289e4:	3021883a 	mov	r16,r6
811289e8:	dc400315 	stw	r17,12(sp)
811289ec:	8022907a 	slli	r17,r16,1
811289f0:	dd000615 	stw	r20,24(sp)
811289f4:	2829883a 	mov	r20,r5
811289f8:	01400044 	movi	r5,1
811289fc:	dcc00515 	stw	r19,20(sp)
81128a00:	dc800415 	stw	r18,16(sp)
81128a04:	dfc00715 	stw	ra,28(sp)
81128a08:	3825883a 	mov	r18,r7
81128a0c:	8822d57a 	srli	r17,r17,21
81128a10:	1127cf80 	call	81127cf8 <_Balloc>
81128a14:	1027883a 	mov	r19,r2
81128a18:	00800434 	movhi	r2,16
81128a1c:	10bfffc4 	addi	r2,r2,-1
81128a20:	808c703a 	and	r6,r16,r2
81128a24:	88000126 	beq	r17,zero,81128a2c <__d2b+0x58>
81128a28:	31800434 	orhi	r6,r6,16
81128a2c:	d9800015 	stw	r6,0(sp)
81128a30:	a0002426 	beq	r20,zero,81128ac4 <__d2b+0xf0>
81128a34:	d9000104 	addi	r4,sp,4
81128a38:	dd000115 	stw	r20,4(sp)
81128a3c:	112806c0 	call	8112806c <__lo0bits>
81128a40:	d8c00017 	ldw	r3,0(sp)
81128a44:	10002f1e 	bne	r2,zero,81128b04 <__d2b+0x130>
81128a48:	d9000117 	ldw	r4,4(sp)
81128a4c:	99000515 	stw	r4,20(r19)
81128a50:	1821003a 	cmpeq	r16,r3,zero
81128a54:	01000084 	movi	r4,2
81128a58:	2421c83a 	sub	r16,r4,r16
81128a5c:	98c00615 	stw	r3,24(r19)
81128a60:	9c000415 	stw	r16,16(r19)
81128a64:	88001f1e 	bne	r17,zero,81128ae4 <__d2b+0x110>
81128a68:	10bef384 	addi	r2,r2,-1074
81128a6c:	90800015 	stw	r2,0(r18)
81128a70:	00900034 	movhi	r2,16384
81128a74:	10bfffc4 	addi	r2,r2,-1
81128a78:	8085883a 	add	r2,r16,r2
81128a7c:	1085883a 	add	r2,r2,r2
81128a80:	1085883a 	add	r2,r2,r2
81128a84:	9885883a 	add	r2,r19,r2
81128a88:	11000517 	ldw	r4,20(r2)
81128a8c:	8020917a 	slli	r16,r16,5
81128a90:	11280040 	call	81128004 <__hi0bits>
81128a94:	d8c00817 	ldw	r3,32(sp)
81128a98:	8085c83a 	sub	r2,r16,r2
81128a9c:	18800015 	stw	r2,0(r3)
81128aa0:	9805883a 	mov	r2,r19
81128aa4:	dfc00717 	ldw	ra,28(sp)
81128aa8:	dd000617 	ldw	r20,24(sp)
81128aac:	dcc00517 	ldw	r19,20(sp)
81128ab0:	dc800417 	ldw	r18,16(sp)
81128ab4:	dc400317 	ldw	r17,12(sp)
81128ab8:	dc000217 	ldw	r16,8(sp)
81128abc:	dec00804 	addi	sp,sp,32
81128ac0:	f800283a 	ret
81128ac4:	d809883a 	mov	r4,sp
81128ac8:	112806c0 	call	8112806c <__lo0bits>
81128acc:	d8c00017 	ldw	r3,0(sp)
81128ad0:	04000044 	movi	r16,1
81128ad4:	9c000415 	stw	r16,16(r19)
81128ad8:	98c00515 	stw	r3,20(r19)
81128adc:	10800804 	addi	r2,r2,32
81128ae0:	883fe126 	beq	r17,zero,81128a68 <__reset+0xfb108a68>
81128ae4:	00c00d44 	movi	r3,53
81128ae8:	8c7ef344 	addi	r17,r17,-1075
81128aec:	88a3883a 	add	r17,r17,r2
81128af0:	1885c83a 	sub	r2,r3,r2
81128af4:	d8c00817 	ldw	r3,32(sp)
81128af8:	94400015 	stw	r17,0(r18)
81128afc:	18800015 	stw	r2,0(r3)
81128b00:	003fe706 	br	81128aa0 <__reset+0xfb108aa0>
81128b04:	01000804 	movi	r4,32
81128b08:	2089c83a 	sub	r4,r4,r2
81128b0c:	1908983a 	sll	r4,r3,r4
81128b10:	d9400117 	ldw	r5,4(sp)
81128b14:	1886d83a 	srl	r3,r3,r2
81128b18:	2148b03a 	or	r4,r4,r5
81128b1c:	99000515 	stw	r4,20(r19)
81128b20:	d8c00015 	stw	r3,0(sp)
81128b24:	003fca06 	br	81128a50 <__reset+0xfb108a50>

81128b28 <__ratio>:
81128b28:	defff904 	addi	sp,sp,-28
81128b2c:	de00012e 	bgeu	sp,et,81128b34 <__ratio+0xc>
81128b30:	003b68fa 	trap	3
81128b34:	dc400315 	stw	r17,12(sp)
81128b38:	2823883a 	mov	r17,r5
81128b3c:	d9400104 	addi	r5,sp,4
81128b40:	dfc00615 	stw	ra,24(sp)
81128b44:	dcc00515 	stw	r19,20(sp)
81128b48:	dc800415 	stw	r18,16(sp)
81128b4c:	2027883a 	mov	r19,r4
81128b50:	dc000215 	stw	r16,8(sp)
81128b54:	11288c00 	call	811288c0 <__b2d>
81128b58:	d80b883a 	mov	r5,sp
81128b5c:	8809883a 	mov	r4,r17
81128b60:	1025883a 	mov	r18,r2
81128b64:	1821883a 	mov	r16,r3
81128b68:	11288c00 	call	811288c0 <__b2d>
81128b6c:	8a000417 	ldw	r8,16(r17)
81128b70:	99000417 	ldw	r4,16(r19)
81128b74:	d9400117 	ldw	r5,4(sp)
81128b78:	2209c83a 	sub	r4,r4,r8
81128b7c:	2010917a 	slli	r8,r4,5
81128b80:	d9000017 	ldw	r4,0(sp)
81128b84:	2909c83a 	sub	r4,r5,r4
81128b88:	4109883a 	add	r4,r8,r4
81128b8c:	01000e0e 	bge	zero,r4,81128bc8 <__ratio+0xa0>
81128b90:	2008953a 	slli	r4,r4,20
81128b94:	2421883a 	add	r16,r4,r16
81128b98:	100d883a 	mov	r6,r2
81128b9c:	180f883a 	mov	r7,r3
81128ba0:	9009883a 	mov	r4,r18
81128ba4:	800b883a 	mov	r5,r16
81128ba8:	1130c1c0 	call	81130c1c <__divdf3>
81128bac:	dfc00617 	ldw	ra,24(sp)
81128bb0:	dcc00517 	ldw	r19,20(sp)
81128bb4:	dc800417 	ldw	r18,16(sp)
81128bb8:	dc400317 	ldw	r17,12(sp)
81128bbc:	dc000217 	ldw	r16,8(sp)
81128bc0:	dec00704 	addi	sp,sp,28
81128bc4:	f800283a 	ret
81128bc8:	2008953a 	slli	r4,r4,20
81128bcc:	1907c83a 	sub	r3,r3,r4
81128bd0:	003ff106 	br	81128b98 <__reset+0xfb108b98>

81128bd4 <_mprec_log10>:
81128bd4:	defffe04 	addi	sp,sp,-8
81128bd8:	de00012e 	bgeu	sp,et,81128be0 <_mprec_log10+0xc>
81128bdc:	003b68fa 	trap	3
81128be0:	008005c4 	movi	r2,23
81128be4:	dc000015 	stw	r16,0(sp)
81128be8:	dfc00115 	stw	ra,4(sp)
81128bec:	2021883a 	mov	r16,r4
81128bf0:	11000d0e 	bge	r2,r4,81128c28 <_mprec_log10+0x54>
81128bf4:	0005883a 	mov	r2,zero
81128bf8:	00cffc34 	movhi	r3,16368
81128bfc:	843fffc4 	addi	r16,r16,-1
81128c00:	000d883a 	mov	r6,zero
81128c04:	01d00934 	movhi	r7,16420
81128c08:	1009883a 	mov	r4,r2
81128c0c:	180b883a 	mov	r5,r3
81128c10:	111be780 	call	8111be78 <__muldf3>
81128c14:	803ff91e 	bne	r16,zero,81128bfc <__reset+0xfb108bfc>
81128c18:	dfc00117 	ldw	ra,4(sp)
81128c1c:	dc000017 	ldw	r16,0(sp)
81128c20:	dec00204 	addi	sp,sp,8
81128c24:	f800283a 	ret
81128c28:	202090fa 	slli	r16,r4,3
81128c2c:	00a04574 	movhi	r2,33045
81128c30:	10b0f304 	addi	r2,r2,-15412
81128c34:	1421883a 	add	r16,r2,r16
81128c38:	80800017 	ldw	r2,0(r16)
81128c3c:	80c00117 	ldw	r3,4(r16)
81128c40:	dfc00117 	ldw	ra,4(sp)
81128c44:	dc000017 	ldw	r16,0(sp)
81128c48:	dec00204 	addi	sp,sp,8
81128c4c:	f800283a 	ret

81128c50 <__copybits>:
81128c50:	297fffc4 	addi	r5,r5,-1
81128c54:	280fd17a 	srai	r7,r5,5
81128c58:	30c00417 	ldw	r3,16(r6)
81128c5c:	30800504 	addi	r2,r6,20
81128c60:	39c00044 	addi	r7,r7,1
81128c64:	18c7883a 	add	r3,r3,r3
81128c68:	39cf883a 	add	r7,r7,r7
81128c6c:	18c7883a 	add	r3,r3,r3
81128c70:	39cf883a 	add	r7,r7,r7
81128c74:	10c7883a 	add	r3,r2,r3
81128c78:	21cf883a 	add	r7,r4,r7
81128c7c:	10c00d2e 	bgeu	r2,r3,81128cb4 <__copybits+0x64>
81128c80:	200b883a 	mov	r5,r4
81128c84:	12000017 	ldw	r8,0(r2)
81128c88:	29400104 	addi	r5,r5,4
81128c8c:	10800104 	addi	r2,r2,4
81128c90:	2a3fff15 	stw	r8,-4(r5)
81128c94:	10fffb36 	bltu	r2,r3,81128c84 <__reset+0xfb108c84>
81128c98:	1985c83a 	sub	r2,r3,r6
81128c9c:	10bffac4 	addi	r2,r2,-21
81128ca0:	1004d0ba 	srli	r2,r2,2
81128ca4:	10800044 	addi	r2,r2,1
81128ca8:	1085883a 	add	r2,r2,r2
81128cac:	1085883a 	add	r2,r2,r2
81128cb0:	2089883a 	add	r4,r4,r2
81128cb4:	21c0032e 	bgeu	r4,r7,81128cc4 <__copybits+0x74>
81128cb8:	20000015 	stw	zero,0(r4)
81128cbc:	21000104 	addi	r4,r4,4
81128cc0:	21fffd36 	bltu	r4,r7,81128cb8 <__reset+0xfb108cb8>
81128cc4:	f800283a 	ret

81128cc8 <__any_on>:
81128cc8:	20c00417 	ldw	r3,16(r4)
81128ccc:	2805d17a 	srai	r2,r5,5
81128cd0:	21000504 	addi	r4,r4,20
81128cd4:	18800d0e 	bge	r3,r2,81128d0c <__any_on+0x44>
81128cd8:	18c7883a 	add	r3,r3,r3
81128cdc:	18c7883a 	add	r3,r3,r3
81128ce0:	20c7883a 	add	r3,r4,r3
81128ce4:	20c0192e 	bgeu	r4,r3,81128d4c <__any_on+0x84>
81128ce8:	18bfff17 	ldw	r2,-4(r3)
81128cec:	18ffff04 	addi	r3,r3,-4
81128cf0:	1000041e 	bne	r2,zero,81128d04 <__any_on+0x3c>
81128cf4:	20c0142e 	bgeu	r4,r3,81128d48 <__any_on+0x80>
81128cf8:	18ffff04 	addi	r3,r3,-4
81128cfc:	19400017 	ldw	r5,0(r3)
81128d00:	283ffc26 	beq	r5,zero,81128cf4 <__reset+0xfb108cf4>
81128d04:	00800044 	movi	r2,1
81128d08:	f800283a 	ret
81128d0c:	10c00a0e 	bge	r2,r3,81128d38 <__any_on+0x70>
81128d10:	1085883a 	add	r2,r2,r2
81128d14:	1085883a 	add	r2,r2,r2
81128d18:	294007cc 	andi	r5,r5,31
81128d1c:	2087883a 	add	r3,r4,r2
81128d20:	283ff026 	beq	r5,zero,81128ce4 <__reset+0xfb108ce4>
81128d24:	19800017 	ldw	r6,0(r3)
81128d28:	3144d83a 	srl	r2,r6,r5
81128d2c:	114a983a 	sll	r5,r2,r5
81128d30:	317ff41e 	bne	r6,r5,81128d04 <__reset+0xfb108d04>
81128d34:	003feb06 	br	81128ce4 <__reset+0xfb108ce4>
81128d38:	1085883a 	add	r2,r2,r2
81128d3c:	1085883a 	add	r2,r2,r2
81128d40:	2087883a 	add	r3,r4,r2
81128d44:	003fe706 	br	81128ce4 <__reset+0xfb108ce4>
81128d48:	f800283a 	ret
81128d4c:	0005883a 	mov	r2,zero
81128d50:	f800283a 	ret

81128d54 <_read_r>:
81128d54:	defffd04 	addi	sp,sp,-12
81128d58:	de00012e 	bgeu	sp,et,81128d60 <_read_r+0xc>
81128d5c:	003b68fa 	trap	3
81128d60:	2805883a 	mov	r2,r5
81128d64:	dc000015 	stw	r16,0(sp)
81128d68:	04204574 	movhi	r16,33045
81128d6c:	dc400115 	stw	r17,4(sp)
81128d70:	300b883a 	mov	r5,r6
81128d74:	843af104 	addi	r16,r16,-5180
81128d78:	2023883a 	mov	r17,r4
81128d7c:	380d883a 	mov	r6,r7
81128d80:	1009883a 	mov	r4,r2
81128d84:	dfc00215 	stw	ra,8(sp)
81128d88:	80000015 	stw	zero,0(r16)
81128d8c:	11338d00 	call	811338d0 <read>
81128d90:	00ffffc4 	movi	r3,-1
81128d94:	10c00526 	beq	r2,r3,81128dac <_read_r+0x58>
81128d98:	dfc00217 	ldw	ra,8(sp)
81128d9c:	dc400117 	ldw	r17,4(sp)
81128da0:	dc000017 	ldw	r16,0(sp)
81128da4:	dec00304 	addi	sp,sp,12
81128da8:	f800283a 	ret
81128dac:	80c00017 	ldw	r3,0(r16)
81128db0:	183ff926 	beq	r3,zero,81128d98 <__reset+0xfb108d98>
81128db4:	88c00015 	stw	r3,0(r17)
81128db8:	003ff706 	br	81128d98 <__reset+0xfb108d98>

81128dbc <_realloc_r>:
81128dbc:	defff604 	addi	sp,sp,-40
81128dc0:	de00012e 	bgeu	sp,et,81128dc8 <_realloc_r+0xc>
81128dc4:	003b68fa 	trap	3
81128dc8:	dc800215 	stw	r18,8(sp)
81128dcc:	dfc00915 	stw	ra,36(sp)
81128dd0:	df000815 	stw	fp,32(sp)
81128dd4:	ddc00715 	stw	r23,28(sp)
81128dd8:	dd800615 	stw	r22,24(sp)
81128ddc:	dd400515 	stw	r21,20(sp)
81128de0:	dd000415 	stw	r20,16(sp)
81128de4:	dcc00315 	stw	r19,12(sp)
81128de8:	dc400115 	stw	r17,4(sp)
81128dec:	dc000015 	stw	r16,0(sp)
81128df0:	3025883a 	mov	r18,r6
81128df4:	2800b726 	beq	r5,zero,811290d4 <_realloc_r+0x318>
81128df8:	282b883a 	mov	r21,r5
81128dfc:	2029883a 	mov	r20,r4
81128e00:	11340b00 	call	811340b0 <__malloc_lock>
81128e04:	a8bfff17 	ldw	r2,-4(r21)
81128e08:	043fff04 	movi	r16,-4
81128e0c:	90c002c4 	addi	r3,r18,11
81128e10:	01000584 	movi	r4,22
81128e14:	acfffe04 	addi	r19,r21,-8
81128e18:	1420703a 	and	r16,r2,r16
81128e1c:	20c0332e 	bgeu	r4,r3,81128eec <_realloc_r+0x130>
81128e20:	047ffe04 	movi	r17,-8
81128e24:	1c62703a 	and	r17,r3,r17
81128e28:	8807883a 	mov	r3,r17
81128e2c:	88005816 	blt	r17,zero,81128f90 <_realloc_r+0x1d4>
81128e30:	8c805736 	bltu	r17,r18,81128f90 <_realloc_r+0x1d4>
81128e34:	80c0300e 	bge	r16,r3,81128ef8 <_realloc_r+0x13c>
81128e38:	07204574 	movhi	fp,33045
81128e3c:	e7344004 	addi	fp,fp,-12032
81128e40:	e1c00217 	ldw	r7,8(fp)
81128e44:	9c09883a 	add	r4,r19,r16
81128e48:	22000117 	ldw	r8,4(r4)
81128e4c:	21c06326 	beq	r4,r7,81128fdc <_realloc_r+0x220>
81128e50:	017fff84 	movi	r5,-2
81128e54:	414a703a 	and	r5,r8,r5
81128e58:	214b883a 	add	r5,r4,r5
81128e5c:	29800117 	ldw	r6,4(r5)
81128e60:	3180004c 	andi	r6,r6,1
81128e64:	30003f26 	beq	r6,zero,81128f64 <_realloc_r+0x1a8>
81128e68:	1080004c 	andi	r2,r2,1
81128e6c:	10008326 	beq	r2,zero,8112907c <_realloc_r+0x2c0>
81128e70:	900b883a 	mov	r5,r18
81128e74:	a009883a 	mov	r4,r20
81128e78:	111d2b40 	call	8111d2b4 <_malloc_r>
81128e7c:	1025883a 	mov	r18,r2
81128e80:	10011e26 	beq	r2,zero,811292fc <_realloc_r+0x540>
81128e84:	a93fff17 	ldw	r4,-4(r21)
81128e88:	10fffe04 	addi	r3,r2,-8
81128e8c:	00bfff84 	movi	r2,-2
81128e90:	2084703a 	and	r2,r4,r2
81128e94:	9885883a 	add	r2,r19,r2
81128e98:	1880ee26 	beq	r3,r2,81129254 <_realloc_r+0x498>
81128e9c:	81bfff04 	addi	r6,r16,-4
81128ea0:	00800904 	movi	r2,36
81128ea4:	1180b836 	bltu	r2,r6,81129188 <_realloc_r+0x3cc>
81128ea8:	00c004c4 	movi	r3,19
81128eac:	19809636 	bltu	r3,r6,81129108 <_realloc_r+0x34c>
81128eb0:	9005883a 	mov	r2,r18
81128eb4:	a807883a 	mov	r3,r21
81128eb8:	19000017 	ldw	r4,0(r3)
81128ebc:	11000015 	stw	r4,0(r2)
81128ec0:	19000117 	ldw	r4,4(r3)
81128ec4:	11000115 	stw	r4,4(r2)
81128ec8:	18c00217 	ldw	r3,8(r3)
81128ecc:	10c00215 	stw	r3,8(r2)
81128ed0:	a80b883a 	mov	r5,r21
81128ed4:	a009883a 	mov	r4,r20
81128ed8:	1126d280 	call	81126d28 <_free_r>
81128edc:	a009883a 	mov	r4,r20
81128ee0:	11341d80 	call	811341d8 <__malloc_unlock>
81128ee4:	9005883a 	mov	r2,r18
81128ee8:	00001206 	br	81128f34 <_realloc_r+0x178>
81128eec:	00c00404 	movi	r3,16
81128ef0:	1823883a 	mov	r17,r3
81128ef4:	003fce06 	br	81128e30 <__reset+0xfb108e30>
81128ef8:	a825883a 	mov	r18,r21
81128efc:	8445c83a 	sub	r2,r16,r17
81128f00:	00c003c4 	movi	r3,15
81128f04:	18802636 	bltu	r3,r2,81128fa0 <_realloc_r+0x1e4>
81128f08:	99800117 	ldw	r6,4(r19)
81128f0c:	9c07883a 	add	r3,r19,r16
81128f10:	3180004c 	andi	r6,r6,1
81128f14:	3420b03a 	or	r16,r6,r16
81128f18:	9c000115 	stw	r16,4(r19)
81128f1c:	18800117 	ldw	r2,4(r3)
81128f20:	10800054 	ori	r2,r2,1
81128f24:	18800115 	stw	r2,4(r3)
81128f28:	a009883a 	mov	r4,r20
81128f2c:	11341d80 	call	811341d8 <__malloc_unlock>
81128f30:	9005883a 	mov	r2,r18
81128f34:	dfc00917 	ldw	ra,36(sp)
81128f38:	df000817 	ldw	fp,32(sp)
81128f3c:	ddc00717 	ldw	r23,28(sp)
81128f40:	dd800617 	ldw	r22,24(sp)
81128f44:	dd400517 	ldw	r21,20(sp)
81128f48:	dd000417 	ldw	r20,16(sp)
81128f4c:	dcc00317 	ldw	r19,12(sp)
81128f50:	dc800217 	ldw	r18,8(sp)
81128f54:	dc400117 	ldw	r17,4(sp)
81128f58:	dc000017 	ldw	r16,0(sp)
81128f5c:	dec00a04 	addi	sp,sp,40
81128f60:	f800283a 	ret
81128f64:	017fff04 	movi	r5,-4
81128f68:	414a703a 	and	r5,r8,r5
81128f6c:	814d883a 	add	r6,r16,r5
81128f70:	30c01f16 	blt	r6,r3,81128ff0 <_realloc_r+0x234>
81128f74:	20800317 	ldw	r2,12(r4)
81128f78:	20c00217 	ldw	r3,8(r4)
81128f7c:	a825883a 	mov	r18,r21
81128f80:	3021883a 	mov	r16,r6
81128f84:	18800315 	stw	r2,12(r3)
81128f88:	10c00215 	stw	r3,8(r2)
81128f8c:	003fdb06 	br	81128efc <__reset+0xfb108efc>
81128f90:	00800304 	movi	r2,12
81128f94:	a0800015 	stw	r2,0(r20)
81128f98:	0005883a 	mov	r2,zero
81128f9c:	003fe506 	br	81128f34 <__reset+0xfb108f34>
81128fa0:	98c00117 	ldw	r3,4(r19)
81128fa4:	9c4b883a 	add	r5,r19,r17
81128fa8:	11000054 	ori	r4,r2,1
81128fac:	18c0004c 	andi	r3,r3,1
81128fb0:	1c62b03a 	or	r17,r3,r17
81128fb4:	9c400115 	stw	r17,4(r19)
81128fb8:	29000115 	stw	r4,4(r5)
81128fbc:	2885883a 	add	r2,r5,r2
81128fc0:	10c00117 	ldw	r3,4(r2)
81128fc4:	29400204 	addi	r5,r5,8
81128fc8:	a009883a 	mov	r4,r20
81128fcc:	18c00054 	ori	r3,r3,1
81128fd0:	10c00115 	stw	r3,4(r2)
81128fd4:	1126d280 	call	81126d28 <_free_r>
81128fd8:	003fd306 	br	81128f28 <__reset+0xfb108f28>
81128fdc:	017fff04 	movi	r5,-4
81128fe0:	414a703a 	and	r5,r8,r5
81128fe4:	89800404 	addi	r6,r17,16
81128fe8:	8151883a 	add	r8,r16,r5
81128fec:	4180590e 	bge	r8,r6,81129154 <_realloc_r+0x398>
81128ff0:	1080004c 	andi	r2,r2,1
81128ff4:	103f9e1e 	bne	r2,zero,81128e70 <__reset+0xfb108e70>
81128ff8:	adbffe17 	ldw	r22,-8(r21)
81128ffc:	00bfff04 	movi	r2,-4
81129000:	9dadc83a 	sub	r22,r19,r22
81129004:	b1800117 	ldw	r6,4(r22)
81129008:	3084703a 	and	r2,r6,r2
8112900c:	20002026 	beq	r4,zero,81129090 <_realloc_r+0x2d4>
81129010:	80af883a 	add	r23,r16,r2
81129014:	b96f883a 	add	r23,r23,r5
81129018:	21c05f26 	beq	r4,r7,81129198 <_realloc_r+0x3dc>
8112901c:	b8c01c16 	blt	r23,r3,81129090 <_realloc_r+0x2d4>
81129020:	20800317 	ldw	r2,12(r4)
81129024:	20c00217 	ldw	r3,8(r4)
81129028:	81bfff04 	addi	r6,r16,-4
8112902c:	01000904 	movi	r4,36
81129030:	18800315 	stw	r2,12(r3)
81129034:	10c00215 	stw	r3,8(r2)
81129038:	b0c00217 	ldw	r3,8(r22)
8112903c:	b0800317 	ldw	r2,12(r22)
81129040:	b4800204 	addi	r18,r22,8
81129044:	18800315 	stw	r2,12(r3)
81129048:	10c00215 	stw	r3,8(r2)
8112904c:	21801b36 	bltu	r4,r6,811290bc <_realloc_r+0x300>
81129050:	008004c4 	movi	r2,19
81129054:	1180352e 	bgeu	r2,r6,8112912c <_realloc_r+0x370>
81129058:	a8800017 	ldw	r2,0(r21)
8112905c:	b0800215 	stw	r2,8(r22)
81129060:	a8800117 	ldw	r2,4(r21)
81129064:	b0800315 	stw	r2,12(r22)
81129068:	008006c4 	movi	r2,27
8112906c:	11807f36 	bltu	r2,r6,8112926c <_realloc_r+0x4b0>
81129070:	b0800404 	addi	r2,r22,16
81129074:	ad400204 	addi	r21,r21,8
81129078:	00002d06 	br	81129130 <_realloc_r+0x374>
8112907c:	adbffe17 	ldw	r22,-8(r21)
81129080:	00bfff04 	movi	r2,-4
81129084:	9dadc83a 	sub	r22,r19,r22
81129088:	b1000117 	ldw	r4,4(r22)
8112908c:	2084703a 	and	r2,r4,r2
81129090:	b03f7726 	beq	r22,zero,81128e70 <__reset+0xfb108e70>
81129094:	80af883a 	add	r23,r16,r2
81129098:	b8ff7516 	blt	r23,r3,81128e70 <__reset+0xfb108e70>
8112909c:	b0800317 	ldw	r2,12(r22)
811290a0:	b0c00217 	ldw	r3,8(r22)
811290a4:	81bfff04 	addi	r6,r16,-4
811290a8:	01000904 	movi	r4,36
811290ac:	18800315 	stw	r2,12(r3)
811290b0:	10c00215 	stw	r3,8(r2)
811290b4:	b4800204 	addi	r18,r22,8
811290b8:	21bfe52e 	bgeu	r4,r6,81129050 <__reset+0xfb109050>
811290bc:	a80b883a 	mov	r5,r21
811290c0:	9009883a 	mov	r4,r18
811290c4:	1127b9c0 	call	81127b9c <memmove>
811290c8:	b821883a 	mov	r16,r23
811290cc:	b027883a 	mov	r19,r22
811290d0:	003f8a06 	br	81128efc <__reset+0xfb108efc>
811290d4:	300b883a 	mov	r5,r6
811290d8:	dfc00917 	ldw	ra,36(sp)
811290dc:	df000817 	ldw	fp,32(sp)
811290e0:	ddc00717 	ldw	r23,28(sp)
811290e4:	dd800617 	ldw	r22,24(sp)
811290e8:	dd400517 	ldw	r21,20(sp)
811290ec:	dd000417 	ldw	r20,16(sp)
811290f0:	dcc00317 	ldw	r19,12(sp)
811290f4:	dc800217 	ldw	r18,8(sp)
811290f8:	dc400117 	ldw	r17,4(sp)
811290fc:	dc000017 	ldw	r16,0(sp)
81129100:	dec00a04 	addi	sp,sp,40
81129104:	111d2b41 	jmpi	8111d2b4 <_malloc_r>
81129108:	a8c00017 	ldw	r3,0(r21)
8112910c:	90c00015 	stw	r3,0(r18)
81129110:	a8c00117 	ldw	r3,4(r21)
81129114:	90c00115 	stw	r3,4(r18)
81129118:	00c006c4 	movi	r3,27
8112911c:	19804536 	bltu	r3,r6,81129234 <_realloc_r+0x478>
81129120:	90800204 	addi	r2,r18,8
81129124:	a8c00204 	addi	r3,r21,8
81129128:	003f6306 	br	81128eb8 <__reset+0xfb108eb8>
8112912c:	9005883a 	mov	r2,r18
81129130:	a8c00017 	ldw	r3,0(r21)
81129134:	b821883a 	mov	r16,r23
81129138:	b027883a 	mov	r19,r22
8112913c:	10c00015 	stw	r3,0(r2)
81129140:	a8c00117 	ldw	r3,4(r21)
81129144:	10c00115 	stw	r3,4(r2)
81129148:	a8c00217 	ldw	r3,8(r21)
8112914c:	10c00215 	stw	r3,8(r2)
81129150:	003f6a06 	br	81128efc <__reset+0xfb108efc>
81129154:	9c67883a 	add	r19,r19,r17
81129158:	4445c83a 	sub	r2,r8,r17
8112915c:	e4c00215 	stw	r19,8(fp)
81129160:	10800054 	ori	r2,r2,1
81129164:	98800115 	stw	r2,4(r19)
81129168:	a8bfff17 	ldw	r2,-4(r21)
8112916c:	a009883a 	mov	r4,r20
81129170:	1080004c 	andi	r2,r2,1
81129174:	1462b03a 	or	r17,r2,r17
81129178:	ac7fff15 	stw	r17,-4(r21)
8112917c:	11341d80 	call	811341d8 <__malloc_unlock>
81129180:	a805883a 	mov	r2,r21
81129184:	003f6b06 	br	81128f34 <__reset+0xfb108f34>
81129188:	a80b883a 	mov	r5,r21
8112918c:	9009883a 	mov	r4,r18
81129190:	1127b9c0 	call	81127b9c <memmove>
81129194:	003f4e06 	br	81128ed0 <__reset+0xfb108ed0>
81129198:	89000404 	addi	r4,r17,16
8112919c:	b93fbc16 	blt	r23,r4,81129090 <__reset+0xfb109090>
811291a0:	b0800317 	ldw	r2,12(r22)
811291a4:	b0c00217 	ldw	r3,8(r22)
811291a8:	81bfff04 	addi	r6,r16,-4
811291ac:	01000904 	movi	r4,36
811291b0:	18800315 	stw	r2,12(r3)
811291b4:	10c00215 	stw	r3,8(r2)
811291b8:	b4800204 	addi	r18,r22,8
811291bc:	21804336 	bltu	r4,r6,811292cc <_realloc_r+0x510>
811291c0:	008004c4 	movi	r2,19
811291c4:	11803f2e 	bgeu	r2,r6,811292c4 <_realloc_r+0x508>
811291c8:	a8800017 	ldw	r2,0(r21)
811291cc:	b0800215 	stw	r2,8(r22)
811291d0:	a8800117 	ldw	r2,4(r21)
811291d4:	b0800315 	stw	r2,12(r22)
811291d8:	008006c4 	movi	r2,27
811291dc:	11803f36 	bltu	r2,r6,811292dc <_realloc_r+0x520>
811291e0:	b0800404 	addi	r2,r22,16
811291e4:	ad400204 	addi	r21,r21,8
811291e8:	a8c00017 	ldw	r3,0(r21)
811291ec:	10c00015 	stw	r3,0(r2)
811291f0:	a8c00117 	ldw	r3,4(r21)
811291f4:	10c00115 	stw	r3,4(r2)
811291f8:	a8c00217 	ldw	r3,8(r21)
811291fc:	10c00215 	stw	r3,8(r2)
81129200:	b447883a 	add	r3,r22,r17
81129204:	bc45c83a 	sub	r2,r23,r17
81129208:	e0c00215 	stw	r3,8(fp)
8112920c:	10800054 	ori	r2,r2,1
81129210:	18800115 	stw	r2,4(r3)
81129214:	b0800117 	ldw	r2,4(r22)
81129218:	a009883a 	mov	r4,r20
8112921c:	1080004c 	andi	r2,r2,1
81129220:	1462b03a 	or	r17,r2,r17
81129224:	b4400115 	stw	r17,4(r22)
81129228:	11341d80 	call	811341d8 <__malloc_unlock>
8112922c:	9005883a 	mov	r2,r18
81129230:	003f4006 	br	81128f34 <__reset+0xfb108f34>
81129234:	a8c00217 	ldw	r3,8(r21)
81129238:	90c00215 	stw	r3,8(r18)
8112923c:	a8c00317 	ldw	r3,12(r21)
81129240:	90c00315 	stw	r3,12(r18)
81129244:	30801126 	beq	r6,r2,8112928c <_realloc_r+0x4d0>
81129248:	90800404 	addi	r2,r18,16
8112924c:	a8c00404 	addi	r3,r21,16
81129250:	003f1906 	br	81128eb8 <__reset+0xfb108eb8>
81129254:	90ffff17 	ldw	r3,-4(r18)
81129258:	00bfff04 	movi	r2,-4
8112925c:	a825883a 	mov	r18,r21
81129260:	1884703a 	and	r2,r3,r2
81129264:	80a1883a 	add	r16,r16,r2
81129268:	003f2406 	br	81128efc <__reset+0xfb108efc>
8112926c:	a8800217 	ldw	r2,8(r21)
81129270:	b0800415 	stw	r2,16(r22)
81129274:	a8800317 	ldw	r2,12(r21)
81129278:	b0800515 	stw	r2,20(r22)
8112927c:	31000a26 	beq	r6,r4,811292a8 <_realloc_r+0x4ec>
81129280:	b0800604 	addi	r2,r22,24
81129284:	ad400404 	addi	r21,r21,16
81129288:	003fa906 	br	81129130 <__reset+0xfb109130>
8112928c:	a9000417 	ldw	r4,16(r21)
81129290:	90800604 	addi	r2,r18,24
81129294:	a8c00604 	addi	r3,r21,24
81129298:	91000415 	stw	r4,16(r18)
8112929c:	a9000517 	ldw	r4,20(r21)
811292a0:	91000515 	stw	r4,20(r18)
811292a4:	003f0406 	br	81128eb8 <__reset+0xfb108eb8>
811292a8:	a8c00417 	ldw	r3,16(r21)
811292ac:	ad400604 	addi	r21,r21,24
811292b0:	b0800804 	addi	r2,r22,32
811292b4:	b0c00615 	stw	r3,24(r22)
811292b8:	a8ffff17 	ldw	r3,-4(r21)
811292bc:	b0c00715 	stw	r3,28(r22)
811292c0:	003f9b06 	br	81129130 <__reset+0xfb109130>
811292c4:	9005883a 	mov	r2,r18
811292c8:	003fc706 	br	811291e8 <__reset+0xfb1091e8>
811292cc:	a80b883a 	mov	r5,r21
811292d0:	9009883a 	mov	r4,r18
811292d4:	1127b9c0 	call	81127b9c <memmove>
811292d8:	003fc906 	br	81129200 <__reset+0xfb109200>
811292dc:	a8800217 	ldw	r2,8(r21)
811292e0:	b0800415 	stw	r2,16(r22)
811292e4:	a8800317 	ldw	r2,12(r21)
811292e8:	b0800515 	stw	r2,20(r22)
811292ec:	31000726 	beq	r6,r4,8112930c <_realloc_r+0x550>
811292f0:	b0800604 	addi	r2,r22,24
811292f4:	ad400404 	addi	r21,r21,16
811292f8:	003fbb06 	br	811291e8 <__reset+0xfb1091e8>
811292fc:	a009883a 	mov	r4,r20
81129300:	11341d80 	call	811341d8 <__malloc_unlock>
81129304:	0005883a 	mov	r2,zero
81129308:	003f0a06 	br	81128f34 <__reset+0xfb108f34>
8112930c:	a8c00417 	ldw	r3,16(r21)
81129310:	ad400604 	addi	r21,r21,24
81129314:	b0800804 	addi	r2,r22,32
81129318:	b0c00615 	stw	r3,24(r22)
8112931c:	a8ffff17 	ldw	r3,-4(r21)
81129320:	b0c00715 	stw	r3,28(r22)
81129324:	003fb006 	br	811291e8 <__reset+0xfb1091e8>

81129328 <__fpclassifyd>:
81129328:	00a00034 	movhi	r2,32768
8112932c:	10bfffc4 	addi	r2,r2,-1
81129330:	2884703a 	and	r2,r5,r2
81129334:	10000726 	beq	r2,zero,81129354 <__fpclassifyd+0x2c>
81129338:	00fffc34 	movhi	r3,65520
8112933c:	019ff834 	movhi	r6,32736
81129340:	28c7883a 	add	r3,r5,r3
81129344:	31bfffc4 	addi	r6,r6,-1
81129348:	30c00536 	bltu	r6,r3,81129360 <__fpclassifyd+0x38>
8112934c:	00800104 	movi	r2,4
81129350:	f800283a 	ret
81129354:	2000021e 	bne	r4,zero,81129360 <__fpclassifyd+0x38>
81129358:	00800084 	movi	r2,2
8112935c:	f800283a 	ret
81129360:	00dffc34 	movhi	r3,32752
81129364:	019ff834 	movhi	r6,32736
81129368:	28cb883a 	add	r5,r5,r3
8112936c:	31bfffc4 	addi	r6,r6,-1
81129370:	317ff62e 	bgeu	r6,r5,8112934c <__reset+0xfb10934c>
81129374:	01400434 	movhi	r5,16
81129378:	297fffc4 	addi	r5,r5,-1
8112937c:	28800236 	bltu	r5,r2,81129388 <__fpclassifyd+0x60>
81129380:	008000c4 	movi	r2,3
81129384:	f800283a 	ret
81129388:	10c00226 	beq	r2,r3,81129394 <__fpclassifyd+0x6c>
8112938c:	0005883a 	mov	r2,zero
81129390:	f800283a 	ret
81129394:	2005003a 	cmpeq	r2,r4,zero
81129398:	f800283a 	ret

8112939c <__sccl>:
8112939c:	2a000003 	ldbu	r8,0(r5)
811293a0:	00801784 	movi	r2,94
811293a4:	40802a26 	beq	r8,r2,81129450 <__sccl+0xb4>
811293a8:	29400044 	addi	r5,r5,1
811293ac:	000f883a 	mov	r7,zero
811293b0:	0013883a 	mov	r9,zero
811293b4:	2007883a 	mov	r3,r4
811293b8:	21804004 	addi	r6,r4,256
811293bc:	19c00005 	stb	r7,0(r3)
811293c0:	18c00044 	addi	r3,r3,1
811293c4:	19bffd1e 	bne	r3,r6,811293bc <__reset+0xfb1093bc>
811293c8:	40001126 	beq	r8,zero,81129410 <__sccl+0x74>
811293cc:	00800044 	movi	r2,1
811293d0:	124fc83a 	sub	r7,r2,r9
811293d4:	02800b44 	movi	r10,45
811293d8:	02c01744 	movi	r11,93
811293dc:	2205883a 	add	r2,r4,r8
811293e0:	11c00005 	stb	r7,0(r2)
811293e4:	28800044 	addi	r2,r5,1
811293e8:	28c00003 	ldbu	r3,0(r5)
811293ec:	1a800a26 	beq	r3,r10,81129418 <__sccl+0x7c>
811293f0:	1ac00426 	beq	r3,r11,81129404 <__sccl+0x68>
811293f4:	18000426 	beq	r3,zero,81129408 <__sccl+0x6c>
811293f8:	1811883a 	mov	r8,r3
811293fc:	100b883a 	mov	r5,r2
81129400:	003ff606 	br	811293dc <__reset+0xfb1093dc>
81129404:	f800283a 	ret
81129408:	2805883a 	mov	r2,r5
8112940c:	f800283a 	ret
81129410:	28bfffc4 	addi	r2,r5,-1
81129414:	f800283a 	ret
81129418:	12400003 	ldbu	r9,0(r2)
8112941c:	4ac01126 	beq	r9,r11,81129464 <__sccl+0xc8>
81129420:	4a001016 	blt	r9,r8,81129464 <__sccl+0xc8>
81129424:	41800044 	addi	r6,r8,1
81129428:	29400084 	addi	r5,r5,2
8112942c:	2187883a 	add	r3,r4,r6
81129430:	00000106 	br	81129438 <__sccl+0x9c>
81129434:	31800044 	addi	r6,r6,1
81129438:	19c00005 	stb	r7,0(r3)
8112943c:	3011883a 	mov	r8,r6
81129440:	18c00044 	addi	r3,r3,1
81129444:	327ffb16 	blt	r6,r9,81129434 <__reset+0xfb109434>
81129448:	10800084 	addi	r2,r2,2
8112944c:	003fe606 	br	811293e8 <__reset+0xfb1093e8>
81129450:	2a000043 	ldbu	r8,1(r5)
81129454:	01c00044 	movi	r7,1
81129458:	29400084 	addi	r5,r5,2
8112945c:	02400044 	movi	r9,1
81129460:	003fd406 	br	811293b4 <__reset+0xfb1093b4>
81129464:	5011883a 	mov	r8,r10
81129468:	003fe406 	br	811293fc <__reset+0xfb1093fc>

8112946c <nanf>:
8112946c:	009ff034 	movhi	r2,32704
81129470:	f800283a 	ret

81129474 <strcmp>:
81129474:	2144b03a 	or	r2,r4,r5
81129478:	108000cc 	andi	r2,r2,3
8112947c:	1000171e 	bne	r2,zero,811294dc <strcmp+0x68>
81129480:	20800017 	ldw	r2,0(r4)
81129484:	28c00017 	ldw	r3,0(r5)
81129488:	10c0141e 	bne	r2,r3,811294dc <strcmp+0x68>
8112948c:	027fbff4 	movhi	r9,65279
81129490:	4a7fbfc4 	addi	r9,r9,-257
81129494:	0086303a 	nor	r3,zero,r2
81129498:	02202074 	movhi	r8,32897
8112949c:	1245883a 	add	r2,r2,r9
811294a0:	42202004 	addi	r8,r8,-32640
811294a4:	10c4703a 	and	r2,r2,r3
811294a8:	1204703a 	and	r2,r2,r8
811294ac:	10000226 	beq	r2,zero,811294b8 <strcmp+0x44>
811294b0:	00002306 	br	81129540 <strcmp+0xcc>
811294b4:	1000221e 	bne	r2,zero,81129540 <strcmp+0xcc>
811294b8:	21000104 	addi	r4,r4,4
811294bc:	20c00017 	ldw	r3,0(r4)
811294c0:	29400104 	addi	r5,r5,4
811294c4:	29800017 	ldw	r6,0(r5)
811294c8:	1a4f883a 	add	r7,r3,r9
811294cc:	00c4303a 	nor	r2,zero,r3
811294d0:	3884703a 	and	r2,r7,r2
811294d4:	1204703a 	and	r2,r2,r8
811294d8:	19bff626 	beq	r3,r6,811294b4 <__reset+0xfb1094b4>
811294dc:	20800003 	ldbu	r2,0(r4)
811294e0:	10c03fcc 	andi	r3,r2,255
811294e4:	18c0201c 	xori	r3,r3,128
811294e8:	18ffe004 	addi	r3,r3,-128
811294ec:	18000c26 	beq	r3,zero,81129520 <strcmp+0xac>
811294f0:	29800007 	ldb	r6,0(r5)
811294f4:	19800326 	beq	r3,r6,81129504 <strcmp+0x90>
811294f8:	00001306 	br	81129548 <strcmp+0xd4>
811294fc:	29800007 	ldb	r6,0(r5)
81129500:	11800b1e 	bne	r2,r6,81129530 <strcmp+0xbc>
81129504:	21000044 	addi	r4,r4,1
81129508:	20c00003 	ldbu	r3,0(r4)
8112950c:	29400044 	addi	r5,r5,1
81129510:	18803fcc 	andi	r2,r3,255
81129514:	1080201c 	xori	r2,r2,128
81129518:	10bfe004 	addi	r2,r2,-128
8112951c:	103ff71e 	bne	r2,zero,811294fc <__reset+0xfb1094fc>
81129520:	0007883a 	mov	r3,zero
81129524:	28800003 	ldbu	r2,0(r5)
81129528:	1885c83a 	sub	r2,r3,r2
8112952c:	f800283a 	ret
81129530:	28800003 	ldbu	r2,0(r5)
81129534:	18c03fcc 	andi	r3,r3,255
81129538:	1885c83a 	sub	r2,r3,r2
8112953c:	f800283a 	ret
81129540:	0005883a 	mov	r2,zero
81129544:	f800283a 	ret
81129548:	10c03fcc 	andi	r3,r2,255
8112954c:	003ff506 	br	81129524 <__reset+0xfb109524>

81129550 <sulp>:
81129550:	defffd04 	addi	sp,sp,-12
81129554:	de00012e 	bgeu	sp,et,8112955c <sulp+0xc>
81129558:	003b68fa 	trap	3
8112955c:	dc400115 	stw	r17,4(sp)
81129560:	3023883a 	mov	r17,r6
81129564:	dc000015 	stw	r16,0(sp)
81129568:	dfc00215 	stw	ra,8(sp)
8112956c:	2821883a 	mov	r16,r5
81129570:	112885c0 	call	8112885c <__ulp>
81129574:	88000c26 	beq	r17,zero,811295a8 <sulp+0x58>
81129578:	841ffc2c 	andhi	r16,r16,32752
8112957c:	8020d53a 	srli	r16,r16,20
81129580:	01c01ac4 	movi	r7,107
81129584:	3c21c83a 	sub	r16,r7,r16
81129588:	0400070e 	bge	zero,r16,811295a8 <sulp+0x58>
8112958c:	8020953a 	slli	r16,r16,20
81129590:	01cffc34 	movhi	r7,16368
81129594:	000d883a 	mov	r6,zero
81129598:	81cf883a 	add	r7,r16,r7
8112959c:	1009883a 	mov	r4,r2
811295a0:	180b883a 	mov	r5,r3
811295a4:	111be780 	call	8111be78 <__muldf3>
811295a8:	dfc00217 	ldw	ra,8(sp)
811295ac:	dc400117 	ldw	r17,4(sp)
811295b0:	dc000017 	ldw	r16,0(sp)
811295b4:	dec00304 	addi	sp,sp,12
811295b8:	f800283a 	ret

811295bc <_strtod_r>:
811295bc:	deffe204 	addi	sp,sp,-120
811295c0:	de00012e 	bgeu	sp,et,811295c8 <_strtod_r+0xc>
811295c4:	003b68fa 	trap	3
811295c8:	ddc01b15 	stw	r23,108(sp)
811295cc:	dd001815 	stw	r20,96(sp)
811295d0:	dc801615 	stw	r18,88(sp)
811295d4:	dc401515 	stw	r17,84(sp)
811295d8:	dc001415 	stw	r16,80(sp)
811295dc:	d9400615 	stw	r5,24(sp)
811295e0:	dfc01d15 	stw	ra,116(sp)
811295e4:	df001c15 	stw	fp,112(sp)
811295e8:	dd801a15 	stw	r22,104(sp)
811295ec:	dd401915 	stw	r21,100(sp)
811295f0:	dcc01715 	stw	r19,92(sp)
811295f4:	2021883a 	mov	r16,r4
811295f8:	d8000515 	stw	zero,20(sp)
811295fc:	2809883a 	mov	r4,r5
81129600:	20800003 	ldbu	r2,0(r4)
81129604:	01e044f4 	movhi	r7,33043
81129608:	282f883a 	mov	r23,r5
8112960c:	10c03fcc 	andi	r3,r2,255
81129610:	01400b44 	movi	r5,45
81129614:	39e58e04 	addi	r7,r7,-27080
81129618:	3029883a 	mov	r20,r6
8112961c:	0025883a 	mov	r18,zero
81129620:	0023883a 	mov	r17,zero
81129624:	28c0ba36 	bltu	r5,r3,81129910 <_strtod_r+0x354>
81129628:	180690ba 	slli	r3,r3,2
8112962c:	19c7883a 	add	r3,r3,r7
81129630:	18c00017 	ldw	r3,0(r3)
81129634:	1800683a 	jmp	r3
81129638:	811296f8 	rdprs	r4,r16,19035
8112963c:	81129910 	cmplti	r4,r16,19044
81129640:	81129910 	cmplti	r4,r16,19044
81129644:	81129910 	cmplti	r4,r16,19044
81129648:	81129910 	cmplti	r4,r16,19044
8112964c:	81129910 	cmplti	r4,r16,19044
81129650:	81129910 	cmplti	r4,r16,19044
81129654:	81129910 	cmplti	r4,r16,19044
81129658:	81129910 	cmplti	r4,r16,19044
8112965c:	811298fc 	xorhi	r4,r16,19043
81129660:	811298fc 	xorhi	r4,r16,19043
81129664:	811298fc 	xorhi	r4,r16,19043
81129668:	811298fc 	xorhi	r4,r16,19043
8112966c:	811298fc 	xorhi	r4,r16,19043
81129670:	81129910 	cmplti	r4,r16,19044
81129674:	81129910 	cmplti	r4,r16,19044
81129678:	81129910 	cmplti	r4,r16,19044
8112967c:	81129910 	cmplti	r4,r16,19044
81129680:	81129910 	cmplti	r4,r16,19044
81129684:	81129910 	cmplti	r4,r16,19044
81129688:	81129910 	cmplti	r4,r16,19044
8112968c:	81129910 	cmplti	r4,r16,19044
81129690:	81129910 	cmplti	r4,r16,19044
81129694:	81129910 	cmplti	r4,r16,19044
81129698:	81129910 	cmplti	r4,r16,19044
8112969c:	81129910 	cmplti	r4,r16,19044
811296a0:	81129910 	cmplti	r4,r16,19044
811296a4:	81129910 	cmplti	r4,r16,19044
811296a8:	81129910 	cmplti	r4,r16,19044
811296ac:	81129910 	cmplti	r4,r16,19044
811296b0:	81129910 	cmplti	r4,r16,19044
811296b4:	81129910 	cmplti	r4,r16,19044
811296b8:	811298fc 	xorhi	r4,r16,19043
811296bc:	81129910 	cmplti	r4,r16,19044
811296c0:	81129910 	cmplti	r4,r16,19044
811296c4:	81129910 	cmplti	r4,r16,19044
811296c8:	81129910 	cmplti	r4,r16,19044
811296cc:	81129910 	cmplti	r4,r16,19044
811296d0:	81129910 	cmplti	r4,r16,19044
811296d4:	81129910 	cmplti	r4,r16,19044
811296d8:	81129910 	cmplti	r4,r16,19044
811296dc:	81129910 	cmplti	r4,r16,19044
811296e0:	81129910 	cmplti	r4,r16,19044
811296e4:	81129750 	cmplti	r4,r16,19037
811296e8:	81129910 	cmplti	r4,r16,19044
811296ec:	811298f0 	cmpltui	r4,r16,19043
811296f0:	00801244 	movi	r2,73
811296f4:	88843526 	beq	r17,r2,8112a7cc <_strtod_r+0x1210>
811296f8:	002b883a 	mov	r21,zero
811296fc:	002d883a 	mov	r22,zero
81129700:	a0000526 	beq	r20,zero,81129718 <_strtod_r+0x15c>
81129704:	d8000715 	stw	zero,28(sp)
81129708:	a5c00015 	stw	r23,0(r20)
8112970c:	d9000717 	ldw	r4,28(sp)
81129710:	20000126 	beq	r4,zero,81129718 <_strtod_r+0x15c>
81129714:	b5a0003c 	xorhi	r22,r22,32768
81129718:	a805883a 	mov	r2,r21
8112971c:	b007883a 	mov	r3,r22
81129720:	dfc01d17 	ldw	ra,116(sp)
81129724:	df001c17 	ldw	fp,112(sp)
81129728:	ddc01b17 	ldw	r23,108(sp)
8112972c:	dd801a17 	ldw	r22,104(sp)
81129730:	dd401917 	ldw	r21,100(sp)
81129734:	dd001817 	ldw	r20,96(sp)
81129738:	dcc01717 	ldw	r19,92(sp)
8112973c:	dc801617 	ldw	r18,88(sp)
81129740:	dc401517 	ldw	r17,84(sp)
81129744:	dc001417 	ldw	r16,80(sp)
81129748:	dec01e04 	addi	sp,sp,120
8112974c:	f800283a 	ret
81129750:	d8000715 	stw	zero,28(sp)
81129754:	24c00044 	addi	r19,r4,1
81129758:	dcc00615 	stw	r19,24(sp)
8112975c:	20800043 	ldbu	r2,1(r4)
81129760:	10c03fcc 	andi	r3,r2,255
81129764:	18c0201c 	xori	r3,r3,128
81129768:	18ffe004 	addi	r3,r3,-128
8112976c:	183fe226 	beq	r3,zero,811296f8 <__reset+0xfb1096f8>
81129770:	11403fcc 	andi	r5,r2,255
81129774:	2940201c 	xori	r5,r5,128
81129778:	297fe004 	addi	r5,r5,-128
8112977c:	00c00c04 	movi	r3,48
81129780:	28c0e526 	beq	r5,r3,81129b18 <_strtod_r+0x55c>
81129784:	dcc00815 	stw	r19,32(sp)
81129788:	0025883a 	mov	r18,zero
8112978c:	10fff404 	addi	r3,r2,-48
81129790:	18c03fcc 	andi	r3,r3,255
81129794:	01000244 	movi	r4,9
81129798:	20c37536 	bltu	r4,r3,8112a570 <_strtod_r+0xfb4>
8112979c:	dd400817 	ldw	r21,32(sp)
811297a0:	0027883a 	mov	r19,zero
811297a4:	0039883a 	mov	fp,zero
811297a8:	002d883a 	mov	r22,zero
811297ac:	01400204 	movi	r5,8
811297b0:	2d805a16 	blt	r5,r22,8112991c <_strtod_r+0x360>
811297b4:	e70002a4 	muli	fp,fp,10
811297b8:	10c03fcc 	andi	r3,r2,255
811297bc:	18c0201c 	xori	r3,r3,128
811297c0:	18ffe004 	addi	r3,r3,-128
811297c4:	e0f9883a 	add	fp,fp,r3
811297c8:	e73ff404 	addi	fp,fp,-48
811297cc:	ad400044 	addi	r21,r21,1
811297d0:	dd400615 	stw	r21,24(sp)
811297d4:	a8800003 	ldbu	r2,0(r21)
811297d8:	b5800044 	addi	r22,r22,1
811297dc:	10fff404 	addi	r3,r2,-48
811297e0:	18c03fcc 	andi	r3,r3,255
811297e4:	20fff22e 	bgeu	r4,r3,811297b0 <__reset+0xfb1097b0>
811297e8:	14403fcc 	andi	r17,r2,255
811297ec:	8c40201c 	xori	r17,r17,128
811297f0:	8c7fe004 	addi	r17,r17,-128
811297f4:	8009883a 	mov	r4,r16
811297f8:	11277dc0 	call	811277dc <_localeconv_r>
811297fc:	11400017 	ldw	r5,0(r2)
81129800:	8009883a 	mov	r4,r16
81129804:	d9401315 	stw	r5,76(sp)
81129808:	11277dc0 	call	811277dc <_localeconv_r>
8112980c:	11000017 	ldw	r4,0(r2)
81129810:	111e5bc0 	call	8111e5bc <strlen>
81129814:	d9401317 	ldw	r5,76(sp)
81129818:	100d883a 	mov	r6,r2
8112981c:	a809883a 	mov	r4,r21
81129820:	112f1ac0 	call	8112f1ac <strncmp>
81129824:	1000ce26 	beq	r2,zero,81129b60 <_strtod_r+0x5a4>
81129828:	b013883a 	mov	r9,r22
8112982c:	000b883a 	mov	r5,zero
81129830:	0015883a 	mov	r10,zero
81129834:	0017883a 	mov	r11,zero
81129838:	00801944 	movi	r2,101
8112983c:	88807826 	beq	r17,r2,81129a20 <_strtod_r+0x464>
81129840:	00801144 	movi	r2,69
81129844:	88807626 	beq	r17,r2,81129a20 <_strtod_r+0x464>
81129848:	002b883a 	mov	r21,zero
8112984c:	48003d1e 	bne	r9,zero,81129944 <_strtod_r+0x388>
81129850:	2800391e 	bne	r5,zero,81129938 <_strtod_r+0x37c>
81129854:	9000381e 	bne	r18,zero,81129938 <_strtod_r+0x37c>
81129858:	583fa71e 	bne	r11,zero,811296f8 <__reset+0xfb1096f8>
8112985c:	00801384 	movi	r2,78
81129860:	88800526 	beq	r17,r2,81129878 <_strtod_r+0x2bc>
81129864:	147fa20e 	bge	r2,r17,811296f0 <__reset+0xfb1096f0>
81129868:	00801a44 	movi	r2,105
8112986c:	8883d726 	beq	r17,r2,8112a7cc <_strtod_r+0x1210>
81129870:	00801b84 	movi	r2,110
81129874:	88bfa01e 	bne	r17,r2,811296f8 <__reset+0xfb1096f8>
81129878:	01604574 	movhi	r5,33045
8112987c:	d9000617 	ldw	r4,24(sp)
81129880:	29712804 	addi	r5,r5,-15200
81129884:	01c00644 	movi	r7,25
81129888:	00000b06 	br	811298b8 <_strtod_r+0x2fc>
8112988c:	21000044 	addi	r4,r4,1
81129890:	20800003 	ldbu	r2,0(r4)
81129894:	10ffefc4 	addi	r3,r2,-65
81129898:	10803fcc 	andi	r2,r2,255
8112989c:	1080201c 	xori	r2,r2,128
811298a0:	18c03fcc 	andi	r3,r3,255
811298a4:	10bfe004 	addi	r2,r2,-128
811298a8:	38c00136 	bltu	r7,r3,811298b0 <_strtod_r+0x2f4>
811298ac:	10800804 	addi	r2,r2,32
811298b0:	29400044 	addi	r5,r5,1
811298b4:	11bf901e 	bne	r2,r6,811296f8 <__reset+0xfb1096f8>
811298b8:	29800007 	ldb	r6,0(r5)
811298bc:	303ff31e 	bne	r6,zero,8112988c <__reset+0xfb10988c>
811298c0:	20800044 	addi	r2,r4,1
811298c4:	d8800615 	stw	r2,24(sp)
811298c8:	20c00047 	ldb	r3,1(r4)
811298cc:	00800a04 	movi	r2,40
811298d0:	18849d26 	beq	r3,r2,8112ab48 <_strtod_r+0x158c>
811298d4:	047ffe34 	movhi	r17,65528
811298d8:	0025883a 	mov	r18,zero
811298dc:	902b883a 	mov	r21,r18
811298e0:	882d883a 	mov	r22,r17
811298e4:	a03f8926 	beq	r20,zero,8112970c <__reset+0xfb10970c>
811298e8:	ddc00617 	ldw	r23,24(sp)
811298ec:	003f8606 	br	81129708 <__reset+0xfb109708>
811298f0:	00800044 	movi	r2,1
811298f4:	d8800715 	stw	r2,28(sp)
811298f8:	003f9606 	br	81129754 <__reset+0xfb109754>
811298fc:	21000044 	addi	r4,r4,1
81129900:	d9000615 	stw	r4,24(sp)
81129904:	20800003 	ldbu	r2,0(r4)
81129908:	10c03fcc 	andi	r3,r2,255
8112990c:	28ff462e 	bgeu	r5,r3,81129628 <__reset+0xfb109628>
81129910:	2027883a 	mov	r19,r4
81129914:	d8000715 	stw	zero,28(sp)
81129918:	003f9506 	br	81129770 <__reset+0xfb109770>
8112991c:	9cc002a4 	muli	r19,r19,10
81129920:	10803fcc 	andi	r2,r2,255
81129924:	1080201c 	xori	r2,r2,128
81129928:	10bfe004 	addi	r2,r2,-128
8112992c:	9885883a 	add	r2,r19,r2
81129930:	14fff404 	addi	r19,r2,-48
81129934:	003fa506 	br	811297cc <__reset+0xfb1097cc>
81129938:	002b883a 	mov	r21,zero
8112993c:	002d883a 	mov	r22,zero
81129940:	003fe806 	br	811298e4 <__reset+0xfb1098e4>
81129944:	aaabc83a 	sub	r21,r21,r10
81129948:	b000011e 	bne	r22,zero,81129950 <_strtod_r+0x394>
8112994c:	482d883a 	mov	r22,r9
81129950:	00800404 	movi	r2,16
81129954:	482f883a 	mov	r23,r9
81129958:	1240010e 	bge	r2,r9,81129960 <_strtod_r+0x3a4>
8112995c:	102f883a 	mov	r23,r2
81129960:	e009883a 	mov	r4,fp
81129964:	da401315 	stw	r9,76(sp)
81129968:	11321cc0 	call	811321cc <__floatunsidf>
8112996c:	1025883a 	mov	r18,r2
81129970:	00800244 	movi	r2,9
81129974:	1823883a 	mov	r17,r3
81129978:	da401317 	ldw	r9,76(sp)
8112997c:	15c0160e 	bge	r2,r23,811299d8 <_strtod_r+0x41c>
81129980:	b8bffdc4 	addi	r2,r23,-9
81129984:	100490fa 	slli	r2,r2,3
81129988:	180b883a 	mov	r5,r3
8112998c:	00e04574 	movhi	r3,33045
81129990:	18f0f304 	addi	r3,r3,-15412
81129994:	1885883a 	add	r2,r3,r2
81129998:	11800017 	ldw	r6,0(r2)
8112999c:	11c00117 	ldw	r7,4(r2)
811299a0:	9009883a 	mov	r4,r18
811299a4:	111be780 	call	8111be78 <__muldf3>
811299a8:	9809883a 	mov	r4,r19
811299ac:	1025883a 	mov	r18,r2
811299b0:	1823883a 	mov	r17,r3
811299b4:	11321cc0 	call	811321cc <__floatunsidf>
811299b8:	9009883a 	mov	r4,r18
811299bc:	880b883a 	mov	r5,r17
811299c0:	100d883a 	mov	r6,r2
811299c4:	180f883a 	mov	r7,r3
811299c8:	11303680 	call	81130368 <__adddf3>
811299cc:	da401317 	ldw	r9,76(sp)
811299d0:	1025883a 	mov	r18,r2
811299d4:	1823883a 	mov	r17,r3
811299d8:	008003c4 	movi	r2,15
811299dc:	12407b16 	blt	r2,r9,81129bcc <_strtod_r+0x610>
811299e0:	a83fbe26 	beq	r21,zero,811298dc <__reset+0xfb1098dc>
811299e4:	0543670e 	bge	zero,r21,8112a784 <_strtod_r+0x11c8>
811299e8:	00c00584 	movi	r3,22
811299ec:	1d42e816 	blt	r3,r21,8112a590 <_strtod_r+0xfd4>
811299f0:	a82a90fa 	slli	r21,r21,3
811299f4:	00a04574 	movhi	r2,33045
811299f8:	10b0f304 	addi	r2,r2,-15412
811299fc:	1545883a 	add	r2,r2,r21
81129a00:	11000017 	ldw	r4,0(r2)
81129a04:	11400117 	ldw	r5,4(r2)
81129a08:	900d883a 	mov	r6,r18
81129a0c:	880f883a 	mov	r7,r17
81129a10:	111be780 	call	8111be78 <__muldf3>
81129a14:	102b883a 	mov	r21,r2
81129a18:	182d883a 	mov	r22,r3
81129a1c:	003fb106 	br	811298e4 <__reset+0xfb1098e4>
81129a20:	4801b526 	beq	r9,zero,8112a0f8 <_strtod_r+0xb3c>
81129a24:	ddc00617 	ldw	r23,24(sp)
81129a28:	00c00ac4 	movi	r3,43
81129a2c:	b8800044 	addi	r2,r23,1
81129a30:	d8800615 	stw	r2,24(sp)
81129a34:	b8800047 	ldb	r2,1(r23)
81129a38:	10c1e926 	beq	r2,r3,8112a1e0 <_strtod_r+0xc24>
81129a3c:	00c00b44 	movi	r3,45
81129a40:	10c1ec26 	beq	r2,r3,8112a1f4 <_strtod_r+0xc38>
81129a44:	1023883a 	mov	r17,r2
81129a48:	0019883a 	mov	r12,zero
81129a4c:	88bff404 	addi	r2,r17,-48
81129a50:	00c00244 	movi	r3,9
81129a54:	1881b736 	bltu	r3,r2,8112a134 <_strtod_r+0xb78>
81129a58:	00800c04 	movi	r2,48
81129a5c:	8880071e 	bne	r17,r2,81129a7c <_strtod_r+0x4c0>
81129a60:	d8800617 	ldw	r2,24(sp)
81129a64:	8807883a 	mov	r3,r17
81129a68:	10800044 	addi	r2,r2,1
81129a6c:	d8800615 	stw	r2,24(sp)
81129a70:	14400007 	ldb	r17,0(r2)
81129a74:	10800044 	addi	r2,r2,1
81129a78:	88fffc26 	beq	r17,r3,81129a6c <__reset+0xfb109a6c>
81129a7c:	88bff3c4 	addi	r2,r17,-49
81129a80:	00c00204 	movi	r3,8
81129a84:	18bf7036 	bltu	r3,r2,81129848 <__reset+0xfb109848>
81129a88:	db800617 	ldw	r14,24(sp)
81129a8c:	88bff404 	addi	r2,r17,-48
81129a90:	03400244 	movi	r13,9
81129a94:	71c00044 	addi	r7,r14,1
81129a98:	d9c00615 	stw	r7,24(sp)
81129a9c:	74400043 	ldbu	r17,1(r14)
81129aa0:	88fff404 	addi	r3,r17,-48
81129aa4:	8c403fcc 	andi	r17,r17,255
81129aa8:	8c40201c 	xori	r17,r17,128
81129aac:	18c03fcc 	andi	r3,r3,255
81129ab0:	8c7fe004 	addi	r17,r17,-128
81129ab4:	68c00e36 	bltu	r13,r3,81129af0 <_strtod_r+0x534>
81129ab8:	71000084 	addi	r4,r14,2
81129abc:	d9000615 	stw	r4,24(sp)
81129ac0:	108002a4 	muli	r2,r2,10
81129ac4:	21800003 	ldbu	r6,0(r4)
81129ac8:	200f883a 	mov	r7,r4
81129acc:	1463883a 	add	r17,r2,r17
81129ad0:	30fff404 	addi	r3,r6,-48
81129ad4:	88bff404 	addi	r2,r17,-48
81129ad8:	34403fcc 	andi	r17,r6,255
81129adc:	8c40201c 	xori	r17,r17,128
81129ae0:	18c03fcc 	andi	r3,r3,255
81129ae4:	8c7fe004 	addi	r17,r17,-128
81129ae8:	21000044 	addi	r4,r4,1
81129aec:	68fff32e 	bgeu	r13,r3,81129abc <__reset+0xfb109abc>
81129af0:	3b8fc83a 	sub	r7,r7,r14
81129af4:	00c00204 	movi	r3,8
81129af8:	19c29716 	blt	r3,r7,8112a558 <_strtod_r+0xf9c>
81129afc:	102b883a 	mov	r21,r2
81129b00:	009387c4 	movi	r2,19999
81129b04:	1540010e 	bge	r2,r21,81129b0c <_strtod_r+0x550>
81129b08:	102b883a 	mov	r21,r2
81129b0c:	603f4f26 	beq	r12,zero,8112984c <__reset+0xfb10984c>
81129b10:	056bc83a 	sub	r21,zero,r21
81129b14:	003f4d06 	br	8112984c <__reset+0xfb10984c>
81129b18:	98800047 	ldb	r2,1(r19)
81129b1c:	00c01604 	movi	r3,88
81129b20:	10c1de26 	beq	r2,r3,8112a29c <_strtod_r+0xce0>
81129b24:	00c01e04 	movi	r3,120
81129b28:	10c1dc26 	beq	r2,r3,8112a29c <_strtod_r+0xce0>
81129b2c:	98c00044 	addi	r3,r19,1
81129b30:	1827883a 	mov	r19,r3
81129b34:	d8c00615 	stw	r3,24(sp)
81129b38:	18c00044 	addi	r3,r3,1
81129b3c:	18bfffc3 	ldbu	r2,-1(r3)
81129b40:	11003fcc 	andi	r4,r2,255
81129b44:	2100201c 	xori	r4,r4,128
81129b48:	213fe004 	addi	r4,r4,-128
81129b4c:	217ff826 	beq	r4,r5,81129b30 <__reset+0xfb109b30>
81129b50:	203f7926 	beq	r4,zero,81129938 <__reset+0xfb109938>
81129b54:	dcc00815 	stw	r19,32(sp)
81129b58:	04800044 	movi	r18,1
81129b5c:	003f0b06 	br	8112978c <__reset+0xfb10978c>
81129b60:	8009883a 	mov	r4,r16
81129b64:	11277dc0 	call	811277dc <_localeconv_r>
81129b68:	11000017 	ldw	r4,0(r2)
81129b6c:	111e5bc0 	call	8111e5bc <strlen>
81129b70:	d8c00617 	ldw	r3,24(sp)
81129b74:	1885883a 	add	r2,r3,r2
81129b78:	d8800615 	stw	r2,24(sp)
81129b7c:	14400007 	ldb	r17,0(r2)
81129b80:	b001881e 	bne	r22,zero,8112a1a4 <_strtod_r+0xbe8>
81129b84:	00c00c04 	movi	r3,48
81129b88:	88c3391e 	bne	r17,r3,8112a870 <_strtod_r+0x12b4>
81129b8c:	10c00044 	addi	r3,r2,1
81129b90:	8809883a 	mov	r4,r17
81129b94:	d8c00615 	stw	r3,24(sp)
81129b98:	1c400007 	ldb	r17,0(r3)
81129b9c:	188bc83a 	sub	r5,r3,r2
81129ba0:	18c00044 	addi	r3,r3,1
81129ba4:	893ffb26 	beq	r17,r4,81129b94 <__reset+0xfb109b94>
81129ba8:	88bff3c4 	addi	r2,r17,-49
81129bac:	00c00204 	movi	r3,8
81129bb0:	1882e72e 	bgeu	r3,r2,8112a750 <_strtod_r+0x1194>
81129bb4:	00801944 	movi	r2,101
81129bb8:	88814d26 	beq	r17,r2,8112a0f0 <_strtod_r+0xb34>
81129bbc:	0013883a 	mov	r9,zero
81129bc0:	0015883a 	mov	r10,zero
81129bc4:	02c00044 	movi	r11,1
81129bc8:	003f1d06 	br	81129840 <__reset+0xfb109840>
81129bcc:	4defc83a 	sub	r23,r9,r23
81129bd0:	bd6f883a 	add	r23,r23,r21
81129bd4:	05c21e0e 	bge	zero,r23,8112a450 <_strtod_r+0xe94>
81129bd8:	b88003cc 	andi	r2,r23,15
81129bdc:	10000d26 	beq	r2,zero,81129c14 <_strtod_r+0x658>
81129be0:	100490fa 	slli	r2,r2,3
81129be4:	00e04574 	movhi	r3,33045
81129be8:	18f0f304 	addi	r3,r3,-15412
81129bec:	1885883a 	add	r2,r3,r2
81129bf0:	11000017 	ldw	r4,0(r2)
81129bf4:	11400117 	ldw	r5,4(r2)
81129bf8:	900d883a 	mov	r6,r18
81129bfc:	880f883a 	mov	r7,r17
81129c00:	da401315 	stw	r9,76(sp)
81129c04:	111be780 	call	8111be78 <__muldf3>
81129c08:	da401317 	ldw	r9,76(sp)
81129c0c:	1025883a 	mov	r18,r2
81129c10:	1823883a 	mov	r17,r3
81129c14:	023ffc04 	movi	r8,-16
81129c18:	ba10703a 	and	r8,r23,r8
81129c1c:	40003c26 	beq	r8,zero,81129d10 <_strtod_r+0x754>
81129c20:	00804d04 	movi	r2,308
81129c24:	1201cd16 	blt	r2,r8,8112a35c <_strtod_r+0xda0>
81129c28:	4011d13a 	srai	r8,r8,4
81129c2c:	03000044 	movi	r12,1
81129c30:	62037c0e 	bge	r12,r8,8112aa24 <_strtod_r+0x1468>
81129c34:	01204574 	movhi	r4,33045
81129c38:	2130e904 	addi	r4,r4,-15452
81129c3c:	2015883a 	mov	r10,r4
81129c40:	0027883a 	mov	r19,zero
81129c44:	d9000915 	stw	r4,36(sp)
81129c48:	9005883a 	mov	r2,r18
81129c4c:	8807883a 	mov	r3,r17
81129c50:	dc000c15 	stw	r16,48(sp)
81129c54:	dc800e15 	stw	r18,56(sp)
81129c58:	9821883a 	mov	r16,r19
81129c5c:	0009883a 	mov	r4,zero
81129c60:	8827883a 	mov	r19,r17
81129c64:	602f883a 	mov	r23,r12
81129c68:	da400a15 	stw	r9,40(sp)
81129c6c:	5025883a 	mov	r18,r10
81129c70:	4023883a 	mov	r17,r8
81129c74:	8980004c 	andi	r6,r17,1
81129c78:	30000626 	beq	r6,zero,81129c94 <_strtod_r+0x6d8>
81129c7c:	91800017 	ldw	r6,0(r18)
81129c80:	91c00117 	ldw	r7,4(r18)
81129c84:	1009883a 	mov	r4,r2
81129c88:	180b883a 	mov	r5,r3
81129c8c:	111be780 	call	8111be78 <__muldf3>
81129c90:	01000044 	movi	r4,1
81129c94:	8823d07a 	srai	r17,r17,1
81129c98:	84000044 	addi	r16,r16,1
81129c9c:	94800204 	addi	r18,r18,8
81129ca0:	8dfff41e 	bne	r17,r23,81129c74 <__reset+0xfb109c74>
81129ca4:	21003fcc 	andi	r4,r4,255
81129ca8:	9823883a 	mov	r17,r19
81129cac:	da400a17 	ldw	r9,40(sp)
81129cb0:	8027883a 	mov	r19,r16
81129cb4:	dc800e17 	ldw	r18,56(sp)
81129cb8:	dc000c17 	ldw	r16,48(sp)
81129cbc:	2003b11e 	bne	r4,zero,8112ab84 <_strtod_r+0x15c8>
81129cc0:	981690fa 	slli	r11,r19,3
81129cc4:	d8800917 	ldw	r2,36(sp)
81129cc8:	01ff2c34 	movhi	r7,64688
81129ccc:	900d883a 	mov	r6,r18
81129cd0:	12ef883a 	add	r23,r2,r11
81129cd4:	b9000017 	ldw	r4,0(r23)
81129cd8:	b9400117 	ldw	r5,4(r23)
81129cdc:	89cf883a 	add	r7,r17,r7
81129ce0:	da401315 	stw	r9,76(sp)
81129ce4:	111be780 	call	8111be78 <__muldf3>
81129ce8:	1025883a 	mov	r18,r2
81129cec:	011f2834 	movhi	r4,31904
81129cf0:	189ffc2c 	andhi	r2,r3,32752
81129cf4:	da401317 	ldw	r9,76(sp)
81129cf8:	20819836 	bltu	r4,r2,8112a35c <_strtod_r+0xda0>
81129cfc:	011f2434 	movhi	r4,31888
81129d00:	2083382e 	bgeu	r4,r2,8112a9e4 <_strtod_r+0x1428>
81129d04:	045ffc34 	movhi	r17,32752
81129d08:	8c7fffc4 	addi	r17,r17,-1
81129d0c:	04bfffc4 	movi	r18,-1
81129d10:	d8000915 	stw	zero,36(sp)
81129d14:	d9400817 	ldw	r5,32(sp)
81129d18:	df000015 	stw	fp,0(sp)
81129d1c:	480f883a 	mov	r7,r9
81129d20:	b00d883a 	mov	r6,r22
81129d24:	8009883a 	mov	r4,r16
81129d28:	1127ef80 	call	81127ef8 <__s2b>
81129d2c:	d8800815 	stw	r2,32(sp)
81129d30:	10018a26 	beq	r2,zero,8112a35c <_strtod_r+0xda0>
81129d34:	a807d7fa 	srai	r3,r21,31
81129d38:	0545c83a 	sub	r2,zero,r21
81129d3c:	dd400a15 	stw	r21,40(sp)
81129d40:	1886703a 	and	r3,r3,r2
81129d44:	d8c00c15 	stw	r3,48(sp)
81129d48:	a8013516 	blt	r21,zero,8112a220 <_strtod_r+0xc64>
81129d4c:	d9400817 	ldw	r5,32(sp)
81129d50:	0011883a 	mov	r8,zero
81129d54:	0027883a 	mov	r19,zero
81129d58:	29400304 	addi	r5,r5,12
81129d5c:	d9400f15 	stw	r5,60(sp)
81129d60:	402b883a 	mov	r21,r8
81129d64:	dd001215 	stw	r20,72(sp)
81129d68:	d8800817 	ldw	r2,32(sp)
81129d6c:	8009883a 	mov	r4,r16
81129d70:	11400117 	ldw	r5,4(r2)
81129d74:	1127cf80 	call	81127cf8 <_Balloc>
81129d78:	1029883a 	mov	r20,r2
81129d7c:	10012d26 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129d80:	d8c00817 	ldw	r3,32(sp)
81129d84:	d9400f17 	ldw	r5,60(sp)
81129d88:	11000304 	addi	r4,r2,12
81129d8c:	19800417 	ldw	r6,16(r3)
81129d90:	31800084 	addi	r6,r6,2
81129d94:	318d883a 	add	r6,r6,r6
81129d98:	318d883a 	add	r6,r6,r6
81129d9c:	111dac80 	call	8111dac8 <memcpy>
81129da0:	d9000204 	addi	r4,sp,8
81129da4:	d9000015 	stw	r4,0(sp)
81129da8:	d9c00404 	addi	r7,sp,16
81129dac:	900b883a 	mov	r5,r18
81129db0:	880d883a 	mov	r6,r17
81129db4:	8009883a 	mov	r4,r16
81129db8:	11289d40 	call	811289d4 <__d2b>
81129dbc:	d8800515 	stw	r2,20(sp)
81129dc0:	dc801115 	stw	r18,68(sp)
81129dc4:	dc401015 	stw	r17,64(sp)
81129dc8:	10027c26 	beq	r2,zero,8112a7bc <_strtod_r+0x1200>
81129dcc:	01400044 	movi	r5,1
81129dd0:	8009883a 	mov	r4,r16
81129dd4:	112811c0 	call	8112811c <__i2b>
81129dd8:	1027883a 	mov	r19,r2
81129ddc:	10011526 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129de0:	d8800417 	ldw	r2,16(sp)
81129de4:	1000c816 	blt	r2,zero,8112a108 <_strtod_r+0xb4c>
81129de8:	d9400c17 	ldw	r5,48(sp)
81129dec:	d9000a17 	ldw	r4,40(sp)
81129df0:	28ad883a 	add	r22,r5,r2
81129df4:	d9400917 	ldw	r5,36(sp)
81129df8:	df000217 	ldw	fp,8(sp)
81129dfc:	05ff0084 	movi	r23,-1022
81129e00:	1147c83a 	sub	r3,r2,r5
81129e04:	1f07883a 	add	r3,r3,fp
81129e08:	00800d84 	movi	r2,54
81129e0c:	18ffffc4 	addi	r3,r3,-1
81129e10:	1739c83a 	sub	fp,r2,fp
81129e14:	1dc0a50e 	bge	r3,r23,8112a0ac <_strtod_r+0xaf0>
81129e18:	b8efc83a 	sub	r23,r23,r3
81129e1c:	008007c4 	movi	r2,31
81129e20:	e5f9c83a 	sub	fp,fp,r23
81129e24:	15c0bc16 	blt	r2,r23,8112a118 <_strtod_r+0xb5c>
81129e28:	00800044 	movi	r2,1
81129e2c:	15c4983a 	sll	r2,r2,r23
81129e30:	d8000b15 	stw	zero,44(sp)
81129e34:	d8800d15 	stw	r2,52(sp)
81129e38:	2707883a 	add	r3,r4,fp
81129e3c:	d9000917 	ldw	r4,36(sp)
81129e40:	b739883a 	add	fp,r22,fp
81129e44:	20ef883a 	add	r23,r4,r3
81129e48:	b009883a 	mov	r4,r22
81129e4c:	e580010e 	bge	fp,r22,81129e54 <_strtod_r+0x898>
81129e50:	e009883a 	mov	r4,fp
81129e54:	b805883a 	mov	r2,r23
81129e58:	25c0010e 	bge	r4,r23,81129e60 <_strtod_r+0x8a4>
81129e5c:	2005883a 	mov	r2,r4
81129e60:	0080030e 	bge	zero,r2,81129e70 <_strtod_r+0x8b4>
81129e64:	e0b9c83a 	sub	fp,fp,r2
81129e68:	b8afc83a 	sub	r23,r23,r2
81129e6c:	b0adc83a 	sub	r22,r22,r2
81129e70:	d9400c17 	ldw	r5,48(sp)
81129e74:	28001126 	beq	r5,zero,81129ebc <_strtod_r+0x900>
81129e78:	280d883a 	mov	r6,r5
81129e7c:	8009883a 	mov	r4,r16
81129e80:	980b883a 	mov	r5,r19
81129e84:	11283600 	call	81128360 <__pow5mult>
81129e88:	1027883a 	mov	r19,r2
81129e8c:	1000e926 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129e90:	d9800517 	ldw	r6,20(sp)
81129e94:	100b883a 	mov	r5,r2
81129e98:	8009883a 	mov	r4,r16
81129e9c:	11281600 	call	81128160 <__multiply>
81129ea0:	1000e426 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129ea4:	d9400517 	ldw	r5,20(sp)
81129ea8:	8009883a 	mov	r4,r16
81129eac:	d8801315 	stw	r2,76(sp)
81129eb0:	1127da80 	call	81127da8 <_Bfree>
81129eb4:	d8801317 	ldw	r2,76(sp)
81129eb8:	d8800515 	stw	r2,20(sp)
81129ebc:	0700060e 	bge	zero,fp,81129ed8 <_strtod_r+0x91c>
81129ec0:	d9400517 	ldw	r5,20(sp)
81129ec4:	e00d883a 	mov	r6,fp
81129ec8:	8009883a 	mov	r4,r16
81129ecc:	11284a80 	call	811284a8 <__lshift>
81129ed0:	d8800515 	stw	r2,20(sp)
81129ed4:	10023926 	beq	r2,zero,8112a7bc <_strtod_r+0x1200>
81129ed8:	d8800a17 	ldw	r2,40(sp)
81129edc:	10000626 	beq	r2,zero,81129ef8 <_strtod_r+0x93c>
81129ee0:	d9800a17 	ldw	r6,40(sp)
81129ee4:	a00b883a 	mov	r5,r20
81129ee8:	8009883a 	mov	r4,r16
81129eec:	11283600 	call	81128360 <__pow5mult>
81129ef0:	1029883a 	mov	r20,r2
81129ef4:	1000cf26 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129ef8:	05c0060e 	bge	zero,r23,81129f14 <_strtod_r+0x958>
81129efc:	a00b883a 	mov	r5,r20
81129f00:	b80d883a 	mov	r6,r23
81129f04:	8009883a 	mov	r4,r16
81129f08:	11284a80 	call	811284a8 <__lshift>
81129f0c:	1029883a 	mov	r20,r2
81129f10:	1000c826 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129f14:	0580060e 	bge	zero,r22,81129f30 <_strtod_r+0x974>
81129f18:	980b883a 	mov	r5,r19
81129f1c:	b00d883a 	mov	r6,r22
81129f20:	8009883a 	mov	r4,r16
81129f24:	11284a80 	call	811284a8 <__lshift>
81129f28:	1027883a 	mov	r19,r2
81129f2c:	1000c126 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129f30:	d9400517 	ldw	r5,20(sp)
81129f34:	a00d883a 	mov	r6,r20
81129f38:	8009883a 	mov	r4,r16
81129f3c:	11286580 	call	81128658 <__mdiff>
81129f40:	102b883a 	mov	r21,r2
81129f44:	1000bb26 	beq	r2,zero,8112a234 <_strtod_r+0xc78>
81129f48:	10c00317 	ldw	r3,12(r2)
81129f4c:	980b883a 	mov	r5,r19
81129f50:	10000315 	stw	zero,12(r2)
81129f54:	1009883a 	mov	r4,r2
81129f58:	d8c00e15 	stw	r3,56(sp)
81129f5c:	11285f80 	call	811285f8 <__mcmp>
81129f60:	10027616 	blt	r2,zero,8112a93c <_strtod_r+0x1380>
81129f64:	10024426 	beq	r2,zero,8112a878 <_strtod_r+0x12bc>
81129f68:	980b883a 	mov	r5,r19
81129f6c:	a809883a 	mov	r4,r21
81129f70:	1128b280 	call	81128b28 <__ratio>
81129f74:	000d883a 	mov	r6,zero
81129f78:	01d00034 	movhi	r7,16384
81129f7c:	1009883a 	mov	r4,r2
81129f80:	180b883a 	mov	r5,r3
81129f84:	102f883a 	mov	r23,r2
81129f88:	182d883a 	mov	r22,r3
81129f8c:	11316700 	call	81131670 <__ledf2>
81129f90:	00804a16 	blt	zero,r2,8112a0bc <_strtod_r+0xb00>
81129f94:	d9400e17 	ldw	r5,56(sp)
81129f98:	28006b26 	beq	r5,zero,8112a148 <_strtod_r+0xb8c>
81129f9c:	058ffc34 	movhi	r22,16368
81129fa0:	d8000b15 	stw	zero,44(sp)
81129fa4:	d8000d15 	stw	zero,52(sp)
81129fa8:	b02f883a 	mov	r23,r22
81129fac:	8f1ffc2c 	andhi	fp,r17,32752
81129fb0:	009ff834 	movhi	r2,32736
81129fb4:	e080cd26 	beq	fp,r2,8112a2ec <_strtod_r+0xd30>
81129fb8:	d9400917 	ldw	r5,36(sp)
81129fbc:	28001a26 	beq	r5,zero,8112a028 <_strtod_r+0xa6c>
81129fc0:	0081a834 	movhi	r2,1696
81129fc4:	17001836 	bltu	r2,fp,8112a028 <_strtod_r+0xa6c>
81129fc8:	d9000d17 	ldw	r4,52(sp)
81129fcc:	01d07834 	movhi	r7,16864
81129fd0:	39ffffc4 	addi	r7,r7,-1
81129fd4:	01bff034 	movhi	r6,65472
81129fd8:	b80b883a 	mov	r5,r23
81129fdc:	11316700 	call	81131670 <__ledf2>
81129fe0:	00800e16 	blt	zero,r2,8112a01c <_strtod_r+0xa60>
81129fe4:	d9000d17 	ldw	r4,52(sp)
81129fe8:	b80b883a 	mov	r5,r23
81129fec:	112f47c0 	call	8112f47c <__fixunsdfsi>
81129ff0:	10018126 	beq	r2,zero,8112a5f8 <_strtod_r+0x103c>
81129ff4:	1009883a 	mov	r4,r2
81129ff8:	11321cc0 	call	811321cc <__floatunsidf>
81129ffc:	d8800d15 	stw	r2,52(sp)
8112a000:	182f883a 	mov	r23,r3
8112a004:	d8800e17 	ldw	r2,56(sp)
8112a008:	1001791e 	bne	r2,zero,8112a5f0 <_strtod_r+0x1034>
8112a00c:	ba20003c 	xorhi	r8,r23,32768
8112a010:	d8c00d17 	ldw	r3,52(sp)
8112a014:	402d883a 	mov	r22,r8
8112a018:	d8c00b15 	stw	r3,44(sp)
8112a01c:	0081ac34 	movhi	r2,1712
8112a020:	b091883a 	add	r8,r22,r2
8112a024:	472dc83a 	sub	r22,r8,fp
8112a028:	9009883a 	mov	r4,r18
8112a02c:	880b883a 	mov	r5,r17
8112a030:	112885c0 	call	8112885c <__ulp>
8112a034:	d9000b17 	ldw	r4,44(sp)
8112a038:	b00b883a 	mov	r5,r22
8112a03c:	100d883a 	mov	r6,r2
8112a040:	180f883a 	mov	r7,r3
8112a044:	111be780 	call	8111be78 <__muldf3>
8112a048:	900d883a 	mov	r6,r18
8112a04c:	880f883a 	mov	r7,r17
8112a050:	1009883a 	mov	r4,r2
8112a054:	180b883a 	mov	r5,r3
8112a058:	11303680 	call	81130368 <__adddf3>
8112a05c:	1025883a 	mov	r18,r2
8112a060:	1823883a 	mov	r17,r3
8112a064:	182d883a 	mov	r22,r3
8112a068:	d9000917 	ldw	r4,36(sp)
8112a06c:	2000021e 	bne	r4,zero,8112a078 <_strtod_r+0xabc>
8112a070:	b09ffc2c 	andhi	r2,r22,32752
8112a074:	e080be26 	beq	fp,r2,8112a370 <_strtod_r+0xdb4>
8112a078:	d9400517 	ldw	r5,20(sp)
8112a07c:	8009883a 	mov	r4,r16
8112a080:	1127da80 	call	81127da8 <_Bfree>
8112a084:	a00b883a 	mov	r5,r20
8112a088:	8009883a 	mov	r4,r16
8112a08c:	1127da80 	call	81127da8 <_Bfree>
8112a090:	980b883a 	mov	r5,r19
8112a094:	8009883a 	mov	r4,r16
8112a098:	1127da80 	call	81127da8 <_Bfree>
8112a09c:	a80b883a 	mov	r5,r21
8112a0a0:	8009883a 	mov	r4,r16
8112a0a4:	1127da80 	call	81127da8 <_Bfree>
8112a0a8:	003f2f06 	br	81129d68 <__reset+0xfb109d68>
8112a0ac:	00c00044 	movi	r3,1
8112a0b0:	d8000b15 	stw	zero,44(sp)
8112a0b4:	d8c00d15 	stw	r3,52(sp)
8112a0b8:	003f5f06 	br	81129e38 <__reset+0xfb109e38>
8112a0bc:	b809883a 	mov	r4,r23
8112a0c0:	000d883a 	mov	r6,zero
8112a0c4:	01cff834 	movhi	r7,16352
8112a0c8:	b00b883a 	mov	r5,r22
8112a0cc:	111be780 	call	8111be78 <__muldf3>
8112a0d0:	d9000e17 	ldw	r4,56(sp)
8112a0d4:	d8800d15 	stw	r2,52(sp)
8112a0d8:	182f883a 	mov	r23,r3
8112a0dc:	2000181e 	bne	r4,zero,8112a140 <_strtod_r+0xb84>
8112a0e0:	1a20003c 	xorhi	r8,r3,32768
8112a0e4:	d8800b15 	stw	r2,44(sp)
8112a0e8:	402d883a 	mov	r22,r8
8112a0ec:	003faf06 	br	81129fac <__reset+0xfb109fac>
8112a0f0:	0015883a 	mov	r10,zero
8112a0f4:	02c00044 	movi	r11,1
8112a0f8:	2800011e 	bne	r5,zero,8112a100 <_strtod_r+0xb44>
8112a0fc:	903d7e26 	beq	r18,zero,811296f8 <__reset+0xfb1096f8>
8112a100:	0013883a 	mov	r9,zero
8112a104:	003e4706 	br	81129a24 <__reset+0xfb109a24>
8112a108:	d8c00a17 	ldw	r3,40(sp)
8112a10c:	dd800c17 	ldw	r22,48(sp)
8112a110:	1889c83a 	sub	r4,r3,r2
8112a114:	003f3706 	br	81129df4 <__reset+0xfb109df4>
8112a118:	00bef884 	movi	r2,-1054
8112a11c:	05c00044 	movi	r23,1
8112a120:	10c5c83a 	sub	r2,r2,r3
8112a124:	b884983a 	sll	r2,r23,r2
8112a128:	ddc00d15 	stw	r23,52(sp)
8112a12c:	d8800b15 	stw	r2,44(sp)
8112a130:	003f4106 	br	81129e38 <__reset+0xfb109e38>
8112a134:	ddc00615 	stw	r23,24(sp)
8112a138:	002b883a 	mov	r21,zero
8112a13c:	003dc306 	br	8112984c <__reset+0xfb10984c>
8112a140:	1811883a 	mov	r8,r3
8112a144:	003fe706 	br	8112a0e4 <__reset+0xfb10a0e4>
8112a148:	90002e1e 	bne	r18,zero,8112a204 <_strtod_r+0xc48>
8112a14c:	00c00434 	movhi	r3,16
8112a150:	18ffffc4 	addi	r3,r3,-1
8112a154:	88c4703a 	and	r2,r17,r3
8112a158:	10002c1e 	bne	r2,zero,8112a20c <_strtod_r+0xc50>
8112a15c:	000d883a 	mov	r6,zero
8112a160:	01cffc34 	movhi	r7,16368
8112a164:	b809883a 	mov	r4,r23
8112a168:	b00b883a 	mov	r5,r22
8112a16c:	11316700 	call	81131670 <__ledf2>
8112a170:	10021716 	blt	r2,zero,8112a9d0 <_strtod_r+0x1414>
8112a174:	b809883a 	mov	r4,r23
8112a178:	b00b883a 	mov	r5,r22
8112a17c:	000d883a 	mov	r6,zero
8112a180:	01cff834 	movhi	r7,16352
8112a184:	111be780 	call	8111be78 <__muldf3>
8112a188:	d8800d15 	stw	r2,52(sp)
8112a18c:	182f883a 	mov	r23,r3
8112a190:	102d883a 	mov	r22,r2
8112a194:	1a20003c 	xorhi	r8,r3,32768
8112a198:	dd800b15 	stw	r22,44(sp)
8112a19c:	402d883a 	mov	r22,r8
8112a1a0:	003f8206 	br	81129fac <__reset+0xfb109fac>
8112a1a4:	b013883a 	mov	r9,r22
8112a1a8:	000b883a 	mov	r5,zero
8112a1ac:	0015883a 	mov	r10,zero
8112a1b0:	893ff404 	addi	r4,r17,-48
8112a1b4:	00800244 	movi	r2,9
8112a1b8:	11001036 	bltu	r2,r4,8112a1fc <_strtod_r+0xc40>
8112a1bc:	28c00044 	addi	r3,r5,1
8112a1c0:	2023883a 	mov	r17,r4
8112a1c4:	20014d1e 	bne	r4,zero,8112a6fc <_strtod_r+0x1140>
8112a1c8:	d9800617 	ldw	r6,24(sp)
8112a1cc:	180b883a 	mov	r5,r3
8112a1d0:	30800044 	addi	r2,r6,1
8112a1d4:	d8800615 	stw	r2,24(sp)
8112a1d8:	34400047 	ldb	r17,1(r6)
8112a1dc:	003ff406 	br	8112a1b0 <__reset+0xfb10a1b0>
8112a1e0:	0019883a 	mov	r12,zero
8112a1e4:	b8800084 	addi	r2,r23,2
8112a1e8:	d8800615 	stw	r2,24(sp)
8112a1ec:	bc400087 	ldb	r17,2(r23)
8112a1f0:	003e1606 	br	81129a4c <__reset+0xfb109a4c>
8112a1f4:	03000044 	movi	r12,1
8112a1f8:	003ffa06 	br	8112a1e4 <__reset+0xfb10a1e4>
8112a1fc:	02c00044 	movi	r11,1
8112a200:	003d8d06 	br	81129838 <__reset+0xfb109838>
8112a204:	00800044 	movi	r2,1
8112a208:	9080fe26 	beq	r18,r2,8112a604 <_strtod_r+0x1048>
8112a20c:	d8000b15 	stw	zero,44(sp)
8112a210:	05affc34 	movhi	r22,49136
8112a214:	d8000d15 	stw	zero,52(sp)
8112a218:	05cffc34 	movhi	r23,16368
8112a21c:	003f6306 	br	81129fac <__reset+0xfb109fac>
8112a220:	d8000a15 	stw	zero,40(sp)
8112a224:	003ec906 	br	81129d4c <__reset+0xfb109d4c>
8112a228:	d9001117 	ldw	r4,68(sp)
8112a22c:	00bfffc4 	movi	r2,-1
8112a230:	2080461e 	bne	r4,r2,8112a34c <_strtod_r+0xd90>
8112a234:	dd000a15 	stw	r20,40(sp)
8112a238:	dd001217 	ldw	r20,72(sp)
8112a23c:	a811883a 	mov	r8,r21
8112a240:	d8800517 	ldw	r2,20(sp)
8112a244:	00c00884 	movi	r3,34
8112a248:	80c00015 	stw	r3,0(r16)
8112a24c:	002b883a 	mov	r21,zero
8112a250:	059ffc34 	movhi	r22,32752
8112a254:	100b883a 	mov	r5,r2
8112a258:	8009883a 	mov	r4,r16
8112a25c:	da001315 	stw	r8,76(sp)
8112a260:	1127da80 	call	81127da8 <_Bfree>
8112a264:	d9400a17 	ldw	r5,40(sp)
8112a268:	8009883a 	mov	r4,r16
8112a26c:	1127da80 	call	81127da8 <_Bfree>
8112a270:	980b883a 	mov	r5,r19
8112a274:	8009883a 	mov	r4,r16
8112a278:	1127da80 	call	81127da8 <_Bfree>
8112a27c:	d9400817 	ldw	r5,32(sp)
8112a280:	8009883a 	mov	r4,r16
8112a284:	1127da80 	call	81127da8 <_Bfree>
8112a288:	da001317 	ldw	r8,76(sp)
8112a28c:	8009883a 	mov	r4,r16
8112a290:	400b883a 	mov	r5,r8
8112a294:	1127da80 	call	81127da8 <_Bfree>
8112a298:	003d9206 	br	811298e4 <__reset+0xfb1098e4>
8112a29c:	d8c00717 	ldw	r3,28(sp)
8112a2a0:	d8800504 	addi	r2,sp,20
8112a2a4:	01a04574 	movhi	r6,33045
8112a2a8:	31b12e04 	addi	r6,r6,-15176
8112a2ac:	d8c00115 	stw	r3,4(sp)
8112a2b0:	d8800015 	stw	r2,0(sp)
8112a2b4:	d9c00404 	addi	r7,sp,16
8112a2b8:	d9400604 	addi	r5,sp,24
8112a2bc:	8009883a 	mov	r4,r16
8112a2c0:	112e7100 	call	8112e710 <__gethex>
8112a2c4:	154001cc 	andi	r21,r2,7
8112a2c8:	a83d9b26 	beq	r21,zero,81129938 <__reset+0xfb109938>
8112a2cc:	00c00184 	movi	r3,6
8112a2d0:	a8c0d61e 	bne	r21,r3,8112a62c <_strtod_r+0x1070>
8112a2d4:	9cc00044 	addi	r19,r19,1
8112a2d8:	dcc00615 	stw	r19,24(sp)
8112a2dc:	002b883a 	mov	r21,zero
8112a2e0:	002d883a 	mov	r22,zero
8112a2e4:	d8000715 	stw	zero,28(sp)
8112a2e8:	003d7e06 	br	811298e4 <__reset+0xfb1098e4>
8112a2ec:	00bf2c34 	movhi	r2,64688
8112a2f0:	88a3883a 	add	r17,r17,r2
8112a2f4:	9009883a 	mov	r4,r18
8112a2f8:	880b883a 	mov	r5,r17
8112a2fc:	112885c0 	call	8112885c <__ulp>
8112a300:	d9000b17 	ldw	r4,44(sp)
8112a304:	100d883a 	mov	r6,r2
8112a308:	180f883a 	mov	r7,r3
8112a30c:	b00b883a 	mov	r5,r22
8112a310:	111be780 	call	8111be78 <__muldf3>
8112a314:	900d883a 	mov	r6,r18
8112a318:	180b883a 	mov	r5,r3
8112a31c:	880f883a 	mov	r7,r17
8112a320:	1009883a 	mov	r4,r2
8112a324:	11303680 	call	81130368 <__adddf3>
8112a328:	015f2834 	movhi	r5,31904
8112a32c:	1025883a 	mov	r18,r2
8112a330:	297fffc4 	addi	r5,r5,-1
8112a334:	189ffc2c 	andhi	r2,r3,32752
8112a338:	2880892e 	bgeu	r5,r2,8112a560 <_strtod_r+0xfa4>
8112a33c:	d8801017 	ldw	r2,64(sp)
8112a340:	00dffc34 	movhi	r3,32752
8112a344:	18ffffc4 	addi	r3,r3,-1
8112a348:	10ffb726 	beq	r2,r3,8112a228 <__reset+0xfb10a228>
8112a34c:	045ffc34 	movhi	r17,32752
8112a350:	8c7fffc4 	addi	r17,r17,-1
8112a354:	04bfffc4 	movi	r18,-1
8112a358:	003f4706 	br	8112a078 <__reset+0xfb10a078>
8112a35c:	00800884 	movi	r2,34
8112a360:	80800015 	stw	r2,0(r16)
8112a364:	002b883a 	mov	r21,zero
8112a368:	059ffc34 	movhi	r22,32752
8112a36c:	003d5d06 	br	811298e4 <__reset+0xfb1098e4>
8112a370:	d9000d17 	ldw	r4,52(sp)
8112a374:	b80b883a 	mov	r5,r23
8112a378:	11320680 	call	81132068 <__fixdfsi>
8112a37c:	1009883a 	mov	r4,r2
8112a380:	11320e80 	call	811320e8 <__floatsidf>
8112a384:	d9000d17 	ldw	r4,52(sp)
8112a388:	b80b883a 	mov	r5,r23
8112a38c:	100d883a 	mov	r6,r2
8112a390:	180f883a 	mov	r7,r3
8112a394:	11317640 	call	81131764 <__subdf3>
8112a398:	d9400e17 	ldw	r5,56(sp)
8112a39c:	1039883a 	mov	fp,r2
8112a3a0:	182f883a 	mov	r23,r3
8112a3a4:	2800141e 	bne	r5,zero,8112a3f8 <_strtod_r+0xe3c>
8112a3a8:	9000131e 	bne	r18,zero,8112a3f8 <_strtod_r+0xe3c>
8112a3ac:	00800434 	movhi	r2,16
8112a3b0:	10bfffc4 	addi	r2,r2,-1
8112a3b4:	b0ac703a 	and	r22,r22,r2
8112a3b8:	b0000f1e 	bne	r22,zero,8112a3f8 <_strtod_r+0xe3c>
8112a3bc:	01a52834 	movhi	r6,38048
8112a3c0:	01cff434 	movhi	r7,16336
8112a3c4:	318d6544 	addi	r6,r6,13717
8112a3c8:	39ffffc4 	addi	r7,r7,-1
8112a3cc:	e009883a 	mov	r4,fp
8112a3d0:	180b883a 	mov	r5,r3
8112a3d4:	11316700 	call	81131670 <__ledf2>
8112a3d8:	103f270e 	bge	r2,zero,8112a078 <__reset+0xfb10a078>
8112a3dc:	dd000a15 	stw	r20,40(sp)
8112a3e0:	a811883a 	mov	r8,r21
8112a3e4:	dd001217 	ldw	r20,72(sp)
8112a3e8:	d8800517 	ldw	r2,20(sp)
8112a3ec:	002b883a 	mov	r21,zero
8112a3f0:	882d883a 	mov	r22,r17
8112a3f4:	003f9706 	br	8112a254 <__reset+0xfb10a254>
8112a3f8:	01a52834 	movhi	r6,38048
8112a3fc:	01cff834 	movhi	r7,16352
8112a400:	318d6544 	addi	r6,r6,13717
8112a404:	39ffffc4 	addi	r7,r7,-1
8112a408:	e009883a 	mov	r4,fp
8112a40c:	b80b883a 	mov	r5,r23
8112a410:	11316700 	call	81131670 <__ledf2>
8112a414:	10000716 	blt	r2,zero,8112a434 <_strtod_r+0xe78>
8112a418:	018d6c34 	movhi	r6,13744
8112a41c:	31b94d44 	addi	r6,r6,-6859
8112a420:	01cff834 	movhi	r7,16352
8112a424:	e009883a 	mov	r4,fp
8112a428:	b80b883a 	mov	r5,r23
8112a42c:	11315940 	call	81131594 <__gedf2>
8112a430:	00bf110e 	bge	zero,r2,8112a078 <__reset+0xfb10a078>
8112a434:	dd000a15 	stw	r20,40(sp)
8112a438:	a811883a 	mov	r8,r21
8112a43c:	dd001217 	ldw	r20,72(sp)
8112a440:	d8800517 	ldw	r2,20(sp)
8112a444:	902b883a 	mov	r21,r18
8112a448:	882d883a 	mov	r22,r17
8112a44c:	003f8106 	br	8112a254 <__reset+0xfb10a254>
8112a450:	b83e2f26 	beq	r23,zero,81129d10 <__reset+0xfb109d10>
8112a454:	05efc83a 	sub	r23,zero,r23
8112a458:	b88003cc 	andi	r2,r23,15
8112a45c:	10000d26 	beq	r2,zero,8112a494 <_strtod_r+0xed8>
8112a460:	100490fa 	slli	r2,r2,3
8112a464:	00e04574 	movhi	r3,33045
8112a468:	18f0f304 	addi	r3,r3,-15412
8112a46c:	1885883a 	add	r2,r3,r2
8112a470:	11800017 	ldw	r6,0(r2)
8112a474:	11c00117 	ldw	r7,4(r2)
8112a478:	9009883a 	mov	r4,r18
8112a47c:	880b883a 	mov	r5,r17
8112a480:	da401315 	stw	r9,76(sp)
8112a484:	1130c1c0 	call	81130c1c <__divdf3>
8112a488:	da401317 	ldw	r9,76(sp)
8112a48c:	1025883a 	mov	r18,r2
8112a490:	1823883a 	mov	r17,r3
8112a494:	b82fd13a 	srai	r23,r23,4
8112a498:	b83e1d26 	beq	r23,zero,81129d10 <__reset+0xfb109d10>
8112a49c:	008007c4 	movi	r2,31
8112a4a0:	15c02816 	blt	r2,r23,8112a544 <_strtod_r+0xf88>
8112a4a4:	b880040c 	andi	r2,r23,16
8112a4a8:	10019726 	beq	r2,zero,8112ab08 <_strtod_r+0x154c>
8112a4ac:	05c1880e 	bge	zero,r23,8112aad0 <_strtod_r+0x1514>
8112a4b0:	00c01a84 	movi	r3,106
8112a4b4:	d8c00915 	stw	r3,36(sp)
8112a4b8:	04e04574 	movhi	r19,33045
8112a4bc:	9cf13304 	addi	r19,r19,-15156
8112a4c0:	8807883a 	mov	r3,r17
8112a4c4:	9005883a 	mov	r2,r18
8112a4c8:	8023883a 	mov	r17,r16
8112a4cc:	0009883a 	mov	r4,zero
8112a4d0:	9821883a 	mov	r16,r19
8112a4d4:	da400a15 	stw	r9,40(sp)
8112a4d8:	1827883a 	mov	r19,r3
8112a4dc:	b980004c 	andi	r6,r23,1
8112a4e0:	30000626 	beq	r6,zero,8112a4fc <_strtod_r+0xf40>
8112a4e4:	81800017 	ldw	r6,0(r16)
8112a4e8:	81c00117 	ldw	r7,4(r16)
8112a4ec:	1009883a 	mov	r4,r2
8112a4f0:	180b883a 	mov	r5,r3
8112a4f4:	111be780 	call	8111be78 <__muldf3>
8112a4f8:	01000044 	movi	r4,1
8112a4fc:	b82fd07a 	srai	r23,r23,1
8112a500:	84000204 	addi	r16,r16,8
8112a504:	b83ff51e 	bne	r23,zero,8112a4dc <__reset+0xfb10a4dc>
8112a508:	21003fcc 	andi	r4,r4,255
8112a50c:	8821883a 	mov	r16,r17
8112a510:	da400a17 	ldw	r9,40(sp)
8112a514:	9823883a 	mov	r17,r19
8112a518:	2001a51e 	bne	r4,zero,8112abb0 <_strtod_r+0x15f4>
8112a51c:	d9000917 	ldw	r4,36(sp)
8112a520:	20016d1e 	bne	r4,zero,8112aad8 <_strtod_r+0x151c>
8112a524:	000d883a 	mov	r6,zero
8112a528:	000f883a 	mov	r7,zero
8112a52c:	9009883a 	mov	r4,r18
8112a530:	880b883a 	mov	r5,r17
8112a534:	da401315 	stw	r9,76(sp)
8112a538:	113150c0 	call	8113150c <__eqdf2>
8112a53c:	da401317 	ldw	r9,76(sp)
8112a540:	103df41e 	bne	r2,zero,81129d14 <__reset+0xfb109d14>
8112a544:	00800884 	movi	r2,34
8112a548:	80800015 	stw	r2,0(r16)
8112a54c:	002b883a 	mov	r21,zero
8112a550:	002d883a 	mov	r22,zero
8112a554:	003ce306 	br	811298e4 <__reset+0xfb1098e4>
8112a558:	055387c4 	movi	r21,19999
8112a55c:	003d6b06 	br	81129b0c <__reset+0xfb109b0c>
8112a560:	0440d434 	movhi	r17,848
8112a564:	1c63883a 	add	r17,r3,r17
8112a568:	882d883a 	mov	r22,r17
8112a56c:	003ebe06 	br	8112a068 <__reset+0xfb10a068>
8112a570:	14403fcc 	andi	r17,r2,255
8112a574:	8c40201c 	xori	r17,r17,128
8112a578:	8c7fe004 	addi	r17,r17,-128
8112a57c:	dd400817 	ldw	r21,32(sp)
8112a580:	0027883a 	mov	r19,zero
8112a584:	0039883a 	mov	fp,zero
8112a588:	002d883a 	mov	r22,zero
8112a58c:	003c9906 	br	811297f4 <__reset+0xfb1097f4>
8112a590:	00c00944 	movi	r3,37
8112a594:	1a47c83a 	sub	r3,r3,r9
8112a598:	1d7d8c16 	blt	r3,r21,81129bcc <__reset+0xfb109bcc>
8112a59c:	1261c83a 	sub	r16,r2,r9
8112a5a0:	800490fa 	slli	r2,r16,3
8112a5a4:	04e04574 	movhi	r19,33045
8112a5a8:	9cf0f304 	addi	r19,r19,-15412
8112a5ac:	9885883a 	add	r2,r19,r2
8112a5b0:	11000017 	ldw	r4,0(r2)
8112a5b4:	11400117 	ldw	r5,4(r2)
8112a5b8:	900d883a 	mov	r6,r18
8112a5bc:	880f883a 	mov	r7,r17
8112a5c0:	111be780 	call	8111be78 <__muldf3>
8112a5c4:	ac0dc83a 	sub	r6,r21,r16
8112a5c8:	300c90fa 	slli	r6,r6,3
8112a5cc:	1009883a 	mov	r4,r2
8112a5d0:	180b883a 	mov	r5,r3
8112a5d4:	9985883a 	add	r2,r19,r6
8112a5d8:	11800017 	ldw	r6,0(r2)
8112a5dc:	11c00117 	ldw	r7,4(r2)
8112a5e0:	111be780 	call	8111be78 <__muldf3>
8112a5e4:	102b883a 	mov	r21,r2
8112a5e8:	182d883a 	mov	r22,r3
8112a5ec:	003cbd06 	br	811298e4 <__reset+0xfb1098e4>
8112a5f0:	b811883a 	mov	r8,r23
8112a5f4:	003e8606 	br	8112a010 <__reset+0xfb10a010>
8112a5f8:	d8000d15 	stw	zero,52(sp)
8112a5fc:	05cffc34 	movhi	r23,16368
8112a600:	003e8006 	br	8112a004 <__reset+0xfb10a004>
8112a604:	883f011e 	bne	r17,zero,8112a20c <__reset+0xfb10a20c>
8112a608:	dd000a15 	stw	r20,40(sp)
8112a60c:	dd001217 	ldw	r20,72(sp)
8112a610:	a811883a 	mov	r8,r21
8112a614:	00800884 	movi	r2,34
8112a618:	80800015 	stw	r2,0(r16)
8112a61c:	002b883a 	mov	r21,zero
8112a620:	d8800517 	ldw	r2,20(sp)
8112a624:	002d883a 	mov	r22,zero
8112a628:	003f0a06 	br	8112a254 <__reset+0xfb10a254>
8112a62c:	d9800517 	ldw	r6,20(sp)
8112a630:	30000826 	beq	r6,zero,8112a654 <_strtod_r+0x1098>
8112a634:	01400d44 	movi	r5,53
8112a638:	d9000204 	addi	r4,sp,8
8112a63c:	d8801315 	stw	r2,76(sp)
8112a640:	1128c500 	call	81128c50 <__copybits>
8112a644:	d9400517 	ldw	r5,20(sp)
8112a648:	8009883a 	mov	r4,r16
8112a64c:	1127da80 	call	81127da8 <_Bfree>
8112a650:	d8801317 	ldw	r2,76(sp)
8112a654:	00c00184 	movi	r3,6
8112a658:	1d400f36 	bltu	r3,r21,8112a698 <_strtod_r+0x10dc>
8112a65c:	a82a90ba 	slli	r21,r21,2
8112a660:	00e044f4 	movhi	r3,33043
8112a664:	18e99d04 	addi	r3,r3,-22924
8112a668:	a8eb883a 	add	r21,r21,r3
8112a66c:	a8c00017 	ldw	r3,0(r21)
8112a670:	1800683a 	jmp	r3
8112a674:	8112a6f0 	cmpltui	r4,r16,19099
8112a678:	8112a6c8 	cmpgei	r4,r16,19099
8112a67c:	8112a6ac 	andhi	r4,r16,19098
8112a680:	8112a690 	cmplti	r4,r16,19098
8112a684:	8112a6b8 	rdprs	r4,r16,19098
8112a688:	8112a6c8 	cmpgei	r4,r16,19099
8112a68c:	8112a6f0 	cmpltui	r4,r16,19099
8112a690:	045ffc34 	movhi	r17,32752
8112a694:	0025883a 	mov	r18,zero
8112a698:	1080020c 	andi	r2,r2,8
8112a69c:	902b883a 	mov	r21,r18
8112a6a0:	103c8f26 	beq	r2,zero,811298e0 <__reset+0xfb1098e0>
8112a6a4:	8da00034 	orhi	r22,r17,32768
8112a6a8:	003c8e06 	br	811298e4 <__reset+0xfb1098e4>
8112a6ac:	dc800217 	ldw	r18,8(sp)
8112a6b0:	dc400317 	ldw	r17,12(sp)
8112a6b4:	003ff806 	br	8112a698 <__reset+0xfb10a698>
8112a6b8:	04600034 	movhi	r17,32768
8112a6bc:	8c7fffc4 	addi	r17,r17,-1
8112a6c0:	04bfffc4 	movi	r18,-1
8112a6c4:	003ff406 	br	8112a698 <__reset+0xfb10a698>
8112a6c8:	d8c00417 	ldw	r3,16(sp)
8112a6cc:	dc400317 	ldw	r17,12(sp)
8112a6d0:	013ffc34 	movhi	r4,65520
8112a6d4:	18c10cc4 	addi	r3,r3,1075
8112a6d8:	1806953a 	slli	r3,r3,20
8112a6dc:	213fffc4 	addi	r4,r4,-1
8112a6e0:	8922703a 	and	r17,r17,r4
8112a6e4:	dc800217 	ldw	r18,8(sp)
8112a6e8:	88e2b03a 	or	r17,r17,r3
8112a6ec:	003fea06 	br	8112a698 <__reset+0xfb10a698>
8112a6f0:	0023883a 	mov	r17,zero
8112a6f4:	0025883a 	mov	r18,zero
8112a6f8:	003fe706 	br	8112a698 <__reset+0xfb10a698>
8112a6fc:	01800044 	movi	r6,1
8112a700:	50d5883a 	add	r10,r10,r3
8112a704:	2a4b883a 	add	r5,r5,r9
8112a708:	19811a26 	beq	r3,r6,8112ab74 <_strtod_r+0x15b8>
8112a70c:	01800204 	movi	r6,8
8112a710:	01c00404 	movi	r7,16
8112a714:	4a400044 	addi	r9,r9,1
8112a718:	48bfffc4 	addi	r2,r9,-1
8112a71c:	30801616 	blt	r6,r2,8112a778 <_strtod_r+0x11bc>
8112a720:	e70002a4 	muli	fp,fp,10
8112a724:	497ffb1e 	bne	r9,r5,8112a714 <__reset+0xfb10a714>
8112a728:	d9800617 	ldw	r6,24(sp)
8112a72c:	4a400044 	addi	r9,r9,1
8112a730:	00c00204 	movi	r3,8
8112a734:	19400c0e 	bge	r3,r5,8112a768 <_strtod_r+0x11ac>
8112a738:	00800404 	movi	r2,16
8112a73c:	000b883a 	mov	r5,zero
8112a740:	127ea316 	blt	r2,r9,8112a1d0 <__reset+0xfb10a1d0>
8112a744:	988002a4 	muli	r2,r19,10
8112a748:	20a7883a 	add	r19,r4,r2
8112a74c:	003ea006 	br	8112a1d0 <__reset+0xfb10a1d0>
8112a750:	d8800617 	ldw	r2,24(sp)
8112a754:	8c7ff404 	addi	r17,r17,-48
8112a758:	2a800044 	addi	r10,r5,1
8112a75c:	d8800815 	stw	r2,32(sp)
8112a760:	100d883a 	mov	r6,r2
8112a764:	02400044 	movi	r9,1
8112a768:	e08002a4 	muli	r2,fp,10
8112a76c:	000b883a 	mov	r5,zero
8112a770:	88b9883a 	add	fp,r17,r2
8112a774:	003e9606 	br	8112a1d0 <__reset+0xfb10a1d0>
8112a778:	3a7fea16 	blt	r7,r9,8112a724 <__reset+0xfb10a724>
8112a77c:	9cc002a4 	muli	r19,r19,10
8112a780:	003fe806 	br	8112a724 <__reset+0xfb10a724>
8112a784:	00bffa84 	movi	r2,-22
8112a788:	a8bd1016 	blt	r21,r2,81129bcc <__reset+0xfb109bcc>
8112a78c:	a82a90fa 	slli	r21,r21,3
8112a790:	00a04574 	movhi	r2,33045
8112a794:	10b0f304 	addi	r2,r2,-15412
8112a798:	1545c83a 	sub	r2,r2,r21
8112a79c:	11800017 	ldw	r6,0(r2)
8112a7a0:	11c00117 	ldw	r7,4(r2)
8112a7a4:	9009883a 	mov	r4,r18
8112a7a8:	880b883a 	mov	r5,r17
8112a7ac:	1130c1c0 	call	81130c1c <__divdf3>
8112a7b0:	102b883a 	mov	r21,r2
8112a7b4:	182d883a 	mov	r22,r3
8112a7b8:	003c4a06 	br	811298e4 <__reset+0xfb1098e4>
8112a7bc:	dd000a15 	stw	r20,40(sp)
8112a7c0:	a811883a 	mov	r8,r21
8112a7c4:	dd001217 	ldw	r20,72(sp)
8112a7c8:	003e9e06 	br	8112a244 <__reset+0xfb10a244>
8112a7cc:	01604574 	movhi	r5,33045
8112a7d0:	d9000617 	ldw	r4,24(sp)
8112a7d4:	29712504 	addi	r5,r5,-15212
8112a7d8:	01c00644 	movi	r7,25
8112a7dc:	00000b06 	br	8112a80c <_strtod_r+0x1250>
8112a7e0:	21000044 	addi	r4,r4,1
8112a7e4:	20800003 	ldbu	r2,0(r4)
8112a7e8:	10ffefc4 	addi	r3,r2,-65
8112a7ec:	10803fcc 	andi	r2,r2,255
8112a7f0:	1080201c 	xori	r2,r2,128
8112a7f4:	18c03fcc 	andi	r3,r3,255
8112a7f8:	10bfe004 	addi	r2,r2,-128
8112a7fc:	38c00136 	bltu	r7,r3,8112a804 <_strtod_r+0x1248>
8112a800:	10800804 	addi	r2,r2,32
8112a804:	29400044 	addi	r5,r5,1
8112a808:	11bbbb1e 	bne	r2,r6,811296f8 <__reset+0xfb1096f8>
8112a80c:	29800007 	ldb	r6,0(r5)
8112a810:	303ff31e 	bne	r6,zero,8112a7e0 <__reset+0xfb10a7e0>
8112a814:	01a04574 	movhi	r6,33045
8112a818:	d9000615 	stw	r4,24(sp)
8112a81c:	31b12604 	addi	r6,r6,-15208
8112a820:	200b883a 	mov	r5,r4
8112a824:	02000644 	movi	r8,25
8112a828:	00000a06 	br	8112a854 <_strtod_r+0x1298>
8112a82c:	28800003 	ldbu	r2,0(r5)
8112a830:	10ffefc4 	addi	r3,r2,-65
8112a834:	10803fcc 	andi	r2,r2,255
8112a838:	1080201c 	xori	r2,r2,128
8112a83c:	18c03fcc 	andi	r3,r3,255
8112a840:	10bfe004 	addi	r2,r2,-128
8112a844:	40c00136 	bltu	r8,r3,8112a84c <_strtod_r+0x1290>
8112a848:	10800804 	addi	r2,r2,32
8112a84c:	31800044 	addi	r6,r6,1
8112a850:	11c0711e 	bne	r2,r7,8112aa18 <_strtod_r+0x145c>
8112a854:	31c00007 	ldb	r7,0(r6)
8112a858:	29400044 	addi	r5,r5,1
8112a85c:	383ff31e 	bne	r7,zero,8112a82c <__reset+0xfb10a82c>
8112a860:	d9400615 	stw	r5,24(sp)
8112a864:	045ffc34 	movhi	r17,32752
8112a868:	0025883a 	mov	r18,zero
8112a86c:	003c1b06 	br	811298dc <__reset+0xfb1098dc>
8112a870:	000b883a 	mov	r5,zero
8112a874:	003ccc06 	br	81129ba8 <__reset+0xfb109ba8>
8112a878:	d9400e17 	ldw	r5,56(sp)
8112a87c:	dd000a15 	stw	r20,40(sp)
8112a880:	00800434 	movhi	r2,16
8112a884:	a811883a 	mov	r8,r21
8112a888:	dd001217 	ldw	r20,72(sp)
8112a88c:	dd401117 	ldw	r21,68(sp)
8112a890:	dd801017 	ldw	r22,64(sp)
8112a894:	10bfffc4 	addi	r2,r2,-1
8112a898:	28005626 	beq	r5,zero,8112a9f4 <_strtod_r+0x1438>
8112a89c:	8886703a 	and	r3,r17,r2
8112a8a0:	18807826 	beq	r3,r2,8112aa84 <_strtod_r+0x14c8>
8112a8a4:	d8c00b17 	ldw	r3,44(sp)
8112a8a8:	18005726 	beq	r3,zero,8112aa08 <_strtod_r+0x144c>
8112a8ac:	1c44703a 	and	r2,r3,r17
8112a8b0:	10000f26 	beq	r2,zero,8112a8f0 <_strtod_r+0x1334>
8112a8b4:	d9000e17 	ldw	r4,56(sp)
8112a8b8:	d9800917 	ldw	r6,36(sp)
8112a8bc:	20005e26 	beq	r4,zero,8112aa38 <_strtod_r+0x147c>
8112a8c0:	9009883a 	mov	r4,r18
8112a8c4:	880b883a 	mov	r5,r17
8112a8c8:	da001315 	stw	r8,76(sp)
8112a8cc:	11295500 	call	81129550 <sulp>
8112a8d0:	100d883a 	mov	r6,r2
8112a8d4:	180f883a 	mov	r7,r3
8112a8d8:	9009883a 	mov	r4,r18
8112a8dc:	880b883a 	mov	r5,r17
8112a8e0:	11303680 	call	81130368 <__adddf3>
8112a8e4:	da001317 	ldw	r8,76(sp)
8112a8e8:	102b883a 	mov	r21,r2
8112a8ec:	182d883a 	mov	r22,r3
8112a8f0:	d8c00917 	ldw	r3,36(sp)
8112a8f4:	18000f26 	beq	r3,zero,8112a934 <_strtod_r+0x1378>
8112a8f8:	a809883a 	mov	r4,r21
8112a8fc:	b00b883a 	mov	r5,r22
8112a900:	000d883a 	mov	r6,zero
8112a904:	01ce5434 	movhi	r7,14672
8112a908:	da001315 	stw	r8,76(sp)
8112a90c:	111be780 	call	8111be78 <__muldf3>
8112a910:	102b883a 	mov	r21,r2
8112a914:	182d883a 	mov	r22,r3
8112a918:	da001317 	ldw	r8,76(sp)
8112a91c:	1800051e 	bne	r3,zero,8112a934 <_strtod_r+0x1378>
8112a920:	d8800517 	ldw	r2,20(sp)
8112a924:	a83e4b1e 	bne	r21,zero,8112a254 <__reset+0xfb10a254>
8112a928:	00c00884 	movi	r3,34
8112a92c:	80c00015 	stw	r3,0(r16)
8112a930:	003e4806 	br	8112a254 <__reset+0xfb10a254>
8112a934:	d8800517 	ldw	r2,20(sp)
8112a938:	003e4606 	br	8112a254 <__reset+0xfb10a254>
8112a93c:	d9000e17 	ldw	r4,56(sp)
8112a940:	dd000a15 	stw	r20,40(sp)
8112a944:	a811883a 	mov	r8,r21
8112a948:	dd001217 	ldw	r20,72(sp)
8112a94c:	dd401117 	ldw	r21,68(sp)
8112a950:	dd801017 	ldw	r22,64(sp)
8112a954:	203fe61e 	bne	r4,zero,8112a8f0 <__reset+0xfb10a8f0>
8112a958:	903fe51e 	bne	r18,zero,8112a8f0 <__reset+0xfb10a8f0>
8112a95c:	00800434 	movhi	r2,16
8112a960:	10bfffc4 	addi	r2,r2,-1
8112a964:	8884703a 	and	r2,r17,r2
8112a968:	103fe11e 	bne	r2,zero,8112a8f0 <__reset+0xfb10a8f0>
8112a96c:	8ddffc2c 	andhi	r23,r17,32752
8112a970:	0081ac34 	movhi	r2,1712
8112a974:	15ffde2e 	bgeu	r2,r23,8112a8f0 <__reset+0xfb10a8f0>
8112a978:	40800517 	ldw	r2,20(r8)
8112a97c:	1000031e 	bne	r2,zero,8112a98c <_strtod_r+0x13d0>
8112a980:	40800417 	ldw	r2,16(r8)
8112a984:	00c00044 	movi	r3,1
8112a988:	18bfd90e 	bge	r3,r2,8112a8f0 <__reset+0xfb10a8f0>
8112a98c:	400b883a 	mov	r5,r8
8112a990:	01800044 	movi	r6,1
8112a994:	8009883a 	mov	r4,r16
8112a998:	11284a80 	call	811284a8 <__lshift>
8112a99c:	980b883a 	mov	r5,r19
8112a9a0:	1009883a 	mov	r4,r2
8112a9a4:	d8801315 	stw	r2,76(sp)
8112a9a8:	11285f80 	call	811285f8 <__mcmp>
8112a9ac:	da001317 	ldw	r8,76(sp)
8112a9b0:	00bfcf0e 	bge	zero,r2,8112a8f0 <__reset+0xfb10a8f0>
8112a9b4:	d8c00917 	ldw	r3,36(sp)
8112a9b8:	18005c26 	beq	r3,zero,8112ab2c <_strtod_r+0x1570>
8112a9bc:	0081ac34 	movhi	r2,1712
8112a9c0:	15c05a16 	blt	r2,r23,8112ab2c <_strtod_r+0x1570>
8112a9c4:	0080dc34 	movhi	r2,880
8112a9c8:	15ffcb16 	blt	r2,r23,8112a8f8 <__reset+0xfb10a8f8>
8112a9cc:	003f1106 	br	8112a614 <__reset+0xfb10a614>
8112a9d0:	002d883a 	mov	r22,zero
8112a9d4:	022ff834 	movhi	r8,49120
8112a9d8:	d8000d15 	stw	zero,52(sp)
8112a9dc:	05cff834 	movhi	r23,16352
8112a9e0:	003ded06 	br	8112a198 <__reset+0xfb10a198>
8112a9e4:	0440d434 	movhi	r17,848
8112a9e8:	1c63883a 	add	r17,r3,r17
8112a9ec:	d8000915 	stw	zero,36(sp)
8112a9f0:	003cc806 	br	81129d14 <__reset+0xfb109d14>
8112a9f4:	8884703a 	and	r2,r17,r2
8112a9f8:	103faa1e 	bne	r2,zero,8112a8a4 <__reset+0xfb10a8a4>
8112a9fc:	903fa91e 	bne	r18,zero,8112a8a4 <__reset+0xfb10a8a4>
8112aa00:	8ddffc2c 	andhi	r23,r17,32752
8112aa04:	003feb06 	br	8112a9b4 <__reset+0xfb10a9b4>
8112aa08:	d8c00d17 	ldw	r3,52(sp)
8112aa0c:	1cae703a 	and	r23,r3,r18
8112aa10:	b83fb726 	beq	r23,zero,8112a8f0 <__reset+0xfb10a8f0>
8112aa14:	003fa706 	br	8112a8b4 <__reset+0xfb10a8b4>
8112aa18:	21000044 	addi	r4,r4,1
8112aa1c:	d9000615 	stw	r4,24(sp)
8112aa20:	003f9006 	br	8112a864 <__reset+0xfb10a864>
8112aa24:	01604574 	movhi	r5,33045
8112aa28:	2970e904 	addi	r5,r5,-15452
8112aa2c:	d9400915 	stw	r5,36(sp)
8112aa30:	0027883a 	mov	r19,zero
8112aa34:	003ca206 	br	81129cc0 <__reset+0xfb109cc0>
8112aa38:	9009883a 	mov	r4,r18
8112aa3c:	880b883a 	mov	r5,r17
8112aa40:	da001315 	stw	r8,76(sp)
8112aa44:	11295500 	call	81129550 <sulp>
8112aa48:	100d883a 	mov	r6,r2
8112aa4c:	180f883a 	mov	r7,r3
8112aa50:	9009883a 	mov	r4,r18
8112aa54:	880b883a 	mov	r5,r17
8112aa58:	11317640 	call	81131764 <__subdf3>
8112aa5c:	000d883a 	mov	r6,zero
8112aa60:	000f883a 	mov	r7,zero
8112aa64:	1009883a 	mov	r4,r2
8112aa68:	180b883a 	mov	r5,r3
8112aa6c:	102b883a 	mov	r21,r2
8112aa70:	182d883a 	mov	r22,r3
8112aa74:	113150c0 	call	8113150c <__eqdf2>
8112aa78:	da001317 	ldw	r8,76(sp)
8112aa7c:	103ee526 	beq	r2,zero,8112a614 <__reset+0xfb10a614>
8112aa80:	003f9b06 	br	8112a8f0 <__reset+0xfb10a8f0>
8112aa84:	d8800917 	ldw	r2,36(sp)
8112aa88:	10002226 	beq	r2,zero,8112ab14 <_strtod_r+0x1558>
8112aa8c:	889ffc2c 	andhi	r2,r17,32752
8112aa90:	00c1a834 	movhi	r3,1696
8112aa94:	18801f36 	bltu	r3,r2,8112ab14 <_strtod_r+0x1558>
8112aa98:	1004d53a 	srli	r2,r2,20
8112aa9c:	00c01ac4 	movi	r3,107
8112aaa0:	1887c83a 	sub	r3,r3,r2
8112aaa4:	00bfffc4 	movi	r2,-1
8112aaa8:	10c4983a 	sll	r2,r2,r3
8112aaac:	14bf7d1e 	bne	r2,r18,8112a8a4 <__reset+0xfb10a8a4>
8112aab0:	00dffc34 	movhi	r3,32752
8112aab4:	18ffffc4 	addi	r3,r3,-1
8112aab8:	88c03526 	beq	r17,r3,8112ab90 <_strtod_r+0x15d4>
8112aabc:	8c5ffc2c 	andhi	r17,r17,32752
8112aac0:	00800434 	movhi	r2,16
8112aac4:	002b883a 	mov	r21,zero
8112aac8:	88ad883a 	add	r22,r17,r2
8112aacc:	003f8806 	br	8112a8f0 <__reset+0xfb10a8f0>
8112aad0:	01401a84 	movi	r5,106
8112aad4:	d9400915 	stw	r5,36(sp)
8112aad8:	8ddffc2c 	andhi	r23,r17,32752
8112aadc:	b82ed53a 	srli	r23,r23,20
8112aae0:	00801ac4 	movi	r2,107
8112aae4:	15c5c83a 	sub	r2,r2,r23
8112aae8:	00be8e0e 	bge	zero,r2,8112a524 <__reset+0xfb10a524>
8112aaec:	00c007c4 	movi	r3,31
8112aaf0:	18800a0e 	bge	r3,r2,8112ab1c <_strtod_r+0x1560>
8112aaf4:	00c00d04 	movi	r3,52
8112aaf8:	0025883a 	mov	r18,zero
8112aafc:	1880270e 	bge	r3,r2,8112ab9c <_strtod_r+0x15e0>
8112ab00:	0440dc34 	movhi	r17,880
8112ab04:	003e8706 	br	8112a524 <__reset+0xfb10a524>
8112ab08:	d8000915 	stw	zero,36(sp)
8112ab0c:	05fe6a16 	blt	zero,r23,8112a4b8 <__reset+0xfb10a4b8>
8112ab10:	003e8406 	br	8112a524 <__reset+0xfb10a524>
8112ab14:	00bfffc4 	movi	r2,-1
8112ab18:	003fe406 	br	8112aaac <__reset+0xfb10aaac>
8112ab1c:	00ffffc4 	movi	r3,-1
8112ab20:	1884983a 	sll	r2,r3,r2
8112ab24:	14a4703a 	and	r18,r2,r18
8112ab28:	003e7e06 	br	8112a524 <__reset+0xfb10a524>
8112ab2c:	00bffc34 	movhi	r2,65520
8112ab30:	b8af883a 	add	r23,r23,r2
8112ab34:	057fffc4 	movi	r21,-1
8112ab38:	00800434 	movhi	r2,16
8112ab3c:	1545883a 	add	r2,r2,r21
8112ab40:	b8acb03a 	or	r22,r23,r2
8112ab44:	003f6a06 	br	8112a8f0 <__reset+0xfb10a8f0>
8112ab48:	01604574 	movhi	r5,33045
8112ab4c:	29712904 	addi	r5,r5,-15196
8112ab50:	d9800204 	addi	r6,sp,8
8112ab54:	d9000604 	addi	r4,sp,24
8112ab58:	112ef480 	call	8112ef48 <__hexnan>
8112ab5c:	00c00144 	movi	r3,5
8112ab60:	10fb5c1e 	bne	r2,r3,811298d4 <__reset+0xfb1098d4>
8112ab64:	dc400317 	ldw	r17,12(sp)
8112ab68:	dc800217 	ldw	r18,8(sp)
8112ab6c:	8c5ffc34 	orhi	r17,r17,32752
8112ab70:	003b5a06 	br	811298dc <__reset+0xfb1098dc>
8112ab74:	480b883a 	mov	r5,r9
8112ab78:	d9800617 	ldw	r6,24(sp)
8112ab7c:	4a400044 	addi	r9,r9,1
8112ab80:	003eeb06 	br	8112a730 <__reset+0xfb10a730>
8112ab84:	1025883a 	mov	r18,r2
8112ab88:	1823883a 	mov	r17,r3
8112ab8c:	003c4c06 	br	81129cc0 <__reset+0xfb109cc0>
8112ab90:	00ffffc4 	movi	r3,-1
8112ab94:	10ffc91e 	bne	r2,r3,8112aabc <__reset+0xfb10aabc>
8112ab98:	003da906 	br	8112a240 <__reset+0xfb10a240>
8112ab9c:	10bff804 	addi	r2,r2,-32
8112aba0:	00ffffc4 	movi	r3,-1
8112aba4:	1884983a 	sll	r2,r3,r2
8112aba8:	1462703a 	and	r17,r2,r17
8112abac:	003e5d06 	br	8112a524 <__reset+0xfb10a524>
8112abb0:	1025883a 	mov	r18,r2
8112abb4:	1823883a 	mov	r17,r3
8112abb8:	003e5806 	br	8112a51c <__reset+0xfb10a51c>

8112abbc <strtod>:
8112abbc:	00a04574 	movhi	r2,33045
8112abc0:	10ba8204 	addi	r2,r2,-5624
8112abc4:	280d883a 	mov	r6,r5
8112abc8:	200b883a 	mov	r5,r4
8112abcc:	11000017 	ldw	r4,0(r2)
8112abd0:	11295bc1 	jmpi	811295bc <_strtod_r>

8112abd4 <strtof>:
8112abd4:	defffb04 	addi	sp,sp,-20
8112abd8:	de00012e 	bgeu	sp,et,8112abe0 <strtof+0xc>
8112abdc:	003b68fa 	trap	3
8112abe0:	dcc00315 	stw	r19,12(sp)
8112abe4:	04e04574 	movhi	r19,33045
8112abe8:	9cfa8204 	addi	r19,r19,-5624
8112abec:	280d883a 	mov	r6,r5
8112abf0:	200b883a 	mov	r5,r4
8112abf4:	99000017 	ldw	r4,0(r19)
8112abf8:	dfc00415 	stw	ra,16(sp)
8112abfc:	dc800215 	stw	r18,8(sp)
8112ac00:	dc400115 	stw	r17,4(sp)
8112ac04:	dc000015 	stw	r16,0(sp)
8112ac08:	11295bc0 	call	811295bc <_strtod_r>
8112ac0c:	1009883a 	mov	r4,r2
8112ac10:	180b883a 	mov	r5,r3
8112ac14:	1025883a 	mov	r18,r2
8112ac18:	1823883a 	mov	r17,r3
8112ac1c:	111c6b00 	call	8111c6b0 <__truncdfsf2>
8112ac20:	000b883a 	mov	r5,zero
8112ac24:	1009883a 	mov	r4,r2
8112ac28:	1021883a 	mov	r16,r2
8112ac2c:	113016c0 	call	8113016c <__eqsf2>
8112ac30:	1000111e 	bne	r2,zero,8112ac78 <strtof+0xa4>
8112ac34:	000d883a 	mov	r6,zero
8112ac38:	000f883a 	mov	r7,zero
8112ac3c:	9009883a 	mov	r4,r18
8112ac40:	880b883a 	mov	r5,r17
8112ac44:	113150c0 	call	8113150c <__eqdf2>
8112ac48:	10000b26 	beq	r2,zero,8112ac78 <strtof+0xa4>
8112ac4c:	98800017 	ldw	r2,0(r19)
8112ac50:	00c00884 	movi	r3,34
8112ac54:	10c00015 	stw	r3,0(r2)
8112ac58:	8005883a 	mov	r2,r16
8112ac5c:	dfc00417 	ldw	ra,16(sp)
8112ac60:	dcc00317 	ldw	r19,12(sp)
8112ac64:	dc800217 	ldw	r18,8(sp)
8112ac68:	dc400117 	ldw	r17,4(sp)
8112ac6c:	dc000017 	ldw	r16,0(sp)
8112ac70:	dec00504 	addi	sp,sp,20
8112ac74:	f800283a 	ret
8112ac78:	015fe034 	movhi	r5,32640
8112ac7c:	297fffc4 	addi	r5,r5,-1
8112ac80:	8009883a 	mov	r4,r16
8112ac84:	11301e40 	call	811301e4 <__gesf2>
8112ac88:	0080070e 	bge	zero,r2,8112aca8 <strtof+0xd4>
8112ac8c:	01dffc34 	movhi	r7,32752
8112ac90:	39ffffc4 	addi	r7,r7,-1
8112ac94:	01bfffc4 	movi	r6,-1
8112ac98:	9009883a 	mov	r4,r18
8112ac9c:	880b883a 	mov	r5,r17
8112aca0:	11315940 	call	81131594 <__gedf2>
8112aca4:	00bfe90e 	bge	zero,r2,8112ac4c <__reset+0xfb10ac4c>
8112aca8:	017fe034 	movhi	r5,65408
8112acac:	297fffc4 	addi	r5,r5,-1
8112acb0:	8009883a 	mov	r4,r16
8112acb4:	11302a00 	call	811302a0 <__lesf2>
8112acb8:	103fe70e 	bge	r2,zero,8112ac58 <__reset+0xfb10ac58>
8112acbc:	01fffc34 	movhi	r7,65520
8112acc0:	39ffffc4 	addi	r7,r7,-1
8112acc4:	01bfffc4 	movi	r6,-1
8112acc8:	9009883a 	mov	r4,r18
8112accc:	880b883a 	mov	r5,r17
8112acd0:	11316700 	call	81131670 <__ledf2>
8112acd4:	103fdd0e 	bge	r2,zero,8112ac4c <__reset+0xfb10ac4c>
8112acd8:	003fdf06 	br	8112ac58 <__reset+0xfb10ac58>

8112acdc <_strtoll_r>:
8112acdc:	00a04574 	movhi	r2,33045
8112ace0:	defff304 	addi	sp,sp,-52
8112ace4:	10ba8004 	addi	r2,r2,-5632
8112ace8:	de00012e 	bgeu	sp,et,8112acf0 <_strtoll_r+0x14>
8112acec:	003b68fa 	trap	3
8112acf0:	dc800515 	stw	r18,20(sp)
8112acf4:	14800017 	ldw	r18,0(r2)
8112acf8:	dd800915 	stw	r22,36(sp)
8112acfc:	dd400815 	stw	r21,32(sp)
8112ad00:	dcc00615 	stw	r19,24(sp)
8112ad04:	d9000015 	stw	r4,0(sp)
8112ad08:	dfc00c15 	stw	ra,48(sp)
8112ad0c:	df000b15 	stw	fp,44(sp)
8112ad10:	ddc00a15 	stw	r23,40(sp)
8112ad14:	dd000715 	stw	r20,28(sp)
8112ad18:	dc400415 	stw	r17,16(sp)
8112ad1c:	dc000315 	stw	r16,12(sp)
8112ad20:	282d883a 	mov	r22,r5
8112ad24:	302b883a 	mov	r21,r6
8112ad28:	3827883a 	mov	r19,r7
8112ad2c:	2809883a 	mov	r4,r5
8112ad30:	24000003 	ldbu	r16,0(r4)
8112ad34:	24400044 	addi	r17,r4,1
8112ad38:	2007883a 	mov	r3,r4
8112ad3c:	9405883a 	add	r2,r18,r16
8112ad40:	10800043 	ldbu	r2,1(r2)
8112ad44:	8809883a 	mov	r4,r17
8112ad48:	1080020c 	andi	r2,r2,8
8112ad4c:	103ff81e 	bne	r2,zero,8112ad30 <__reset+0xfb10ad30>
8112ad50:	00800b44 	movi	r2,45
8112ad54:	80807826 	beq	r16,r2,8112af38 <_strtoll_r+0x25c>
8112ad58:	00800ac4 	movi	r2,43
8112ad5c:	80807a26 	beq	r16,r2,8112af48 <_strtoll_r+0x26c>
8112ad60:	0039883a 	mov	fp,zero
8112ad64:	98004e26 	beq	r19,zero,8112aea0 <_strtoll_r+0x1c4>
8112ad68:	00800404 	movi	r2,16
8112ad6c:	98808226 	beq	r19,r2,8112af78 <_strtoll_r+0x29c>
8112ad70:	982fd7fa 	srai	r23,r19,31
8112ad74:	9829883a 	mov	r20,r19
8112ad78:	e0004f26 	beq	fp,zero,8112aeb8 <_strtoll_r+0x1dc>
8112ad7c:	0017883a 	mov	r11,zero
8112ad80:	02a00034 	movhi	r10,32768
8112ad84:	5809883a 	mov	r4,r11
8112ad88:	500b883a 	mov	r5,r10
8112ad8c:	a00d883a 	mov	r6,r20
8112ad90:	b80f883a 	mov	r7,r23
8112ad94:	da800215 	stw	r10,8(sp)
8112ad98:	dac00115 	stw	r11,4(sp)
8112ad9c:	112fa780 	call	8112fa78 <__umoddi3>
8112ada0:	dac00117 	ldw	r11,4(sp)
8112ada4:	da800217 	ldw	r10,8(sp)
8112ada8:	a00d883a 	mov	r6,r20
8112adac:	5809883a 	mov	r4,r11
8112adb0:	500b883a 	mov	r5,r10
8112adb4:	b80f883a 	mov	r7,r23
8112adb8:	d8800115 	stw	r2,4(sp)
8112adbc:	112f4f80 	call	8112f4f8 <__udivdi3>
8112adc0:	9409883a 	add	r4,r18,r16
8112adc4:	21000043 	ldbu	r4,1(r4)
8112adc8:	1019883a 	mov	r12,r2
8112adcc:	880b883a 	mov	r5,r17
8112add0:	2240010c 	andi	r9,r4,4
8112add4:	0015883a 	mov	r10,zero
8112add8:	000d883a 	mov	r6,zero
8112addc:	000f883a 	mov	r7,zero
8112ade0:	03400044 	movi	r13,1
8112ade4:	02ffffc4 	movi	r11,-1
8112ade8:	da000117 	ldw	r8,4(sp)
8112adec:	48000d26 	beq	r9,zero,8112ae24 <_strtoll_r+0x148>
8112adf0:	843ff404 	addi	r16,r16,-48
8112adf4:	84c0110e 	bge	r16,r19,8112ae3c <_strtoll_r+0x160>
8112adf8:	52c00426 	beq	r10,r11,8112ae0c <_strtoll_r+0x130>
8112adfc:	19c00236 	bltu	r3,r7,8112ae08 <_strtoll_r+0x12c>
8112ae00:	38c0311e 	bne	r7,r3,8112aec8 <_strtoll_r+0x1ec>
8112ae04:	6180302e 	bgeu	r12,r6,8112aec8 <_strtoll_r+0x1ec>
8112ae08:	02bfffc4 	movi	r10,-1
8112ae0c:	2c000003 	ldbu	r16,0(r5)
8112ae10:	29400044 	addi	r5,r5,1
8112ae14:	9409883a 	add	r4,r18,r16
8112ae18:	21000043 	ldbu	r4,1(r4)
8112ae1c:	2240010c 	andi	r9,r4,4
8112ae20:	483ff31e 	bne	r9,zero,8112adf0 <__reset+0xfb10adf0>
8112ae24:	210000cc 	andi	r4,r4,3
8112ae28:	20000426 	beq	r4,zero,8112ae3c <_strtoll_r+0x160>
8112ae2c:	23403426 	beq	r4,r13,8112af00 <_strtoll_r+0x224>
8112ae30:	008015c4 	movi	r2,87
8112ae34:	80a1c83a 	sub	r16,r16,r2
8112ae38:	84ffef16 	blt	r16,r19,8112adf8 <__reset+0xfb10adf8>
8112ae3c:	00bfffc4 	movi	r2,-1
8112ae40:	50803426 	beq	r10,r2,8112af14 <_strtoll_r+0x238>
8112ae44:	e0000426 	beq	fp,zero,8112ae58 <_strtoll_r+0x17c>
8112ae48:	018dc83a 	sub	r6,zero,r6
8112ae4c:	3004c03a 	cmpne	r2,r6,zero
8112ae50:	01e1c83a 	sub	r16,zero,r7
8112ae54:	808fc83a 	sub	r7,r16,r2
8112ae58:	3005883a 	mov	r2,r6
8112ae5c:	3807883a 	mov	r3,r7
8112ae60:	a8000326 	beq	r21,zero,8112ae70 <_strtoll_r+0x194>
8112ae64:	5000321e 	bne	r10,zero,8112af30 <_strtoll_r+0x254>
8112ae68:	b00b883a 	mov	r5,r22
8112ae6c:	a9400015 	stw	r5,0(r21)
8112ae70:	dfc00c17 	ldw	ra,48(sp)
8112ae74:	df000b17 	ldw	fp,44(sp)
8112ae78:	ddc00a17 	ldw	r23,40(sp)
8112ae7c:	dd800917 	ldw	r22,36(sp)
8112ae80:	dd400817 	ldw	r21,32(sp)
8112ae84:	dd000717 	ldw	r20,28(sp)
8112ae88:	dcc00617 	ldw	r19,24(sp)
8112ae8c:	dc800517 	ldw	r18,20(sp)
8112ae90:	dc400417 	ldw	r17,16(sp)
8112ae94:	dc000317 	ldw	r16,12(sp)
8112ae98:	dec00d04 	addi	sp,sp,52
8112ae9c:	f800283a 	ret
8112aea0:	00800c04 	movi	r2,48
8112aea4:	80802c26 	beq	r16,r2,8112af58 <_strtoll_r+0x27c>
8112aea8:	05000284 	movi	r20,10
8112aeac:	002f883a 	mov	r23,zero
8112aeb0:	a027883a 	mov	r19,r20
8112aeb4:	e03fb11e 	bne	fp,zero,8112ad7c <__reset+0xfb10ad7c>
8112aeb8:	02a00034 	movhi	r10,32768
8112aebc:	52bfffc4 	addi	r10,r10,-1
8112aec0:	02ffffc4 	movi	r11,-1
8112aec4:	003faf06 	br	8112ad84 <__reset+0xfb10ad84>
8112aec8:	33000f26 	beq	r6,r12,8112af08 <_strtoll_r+0x22c>
8112aecc:	b985383a 	mul	r2,r23,r6
8112aed0:	3d0f383a 	mul	r7,r7,r20
8112aed4:	3508383a 	mulxuu	r4,r6,r20
8112aed8:	350d383a 	mul	r6,r6,r20
8112aedc:	8013d7fa 	srai	r9,r16,31
8112aee0:	388f883a 	add	r7,r7,r2
8112aee4:	818d883a 	add	r6,r16,r6
8112aee8:	390f883a 	add	r7,r7,r4
8112aeec:	3421803a 	cmpltu	r16,r6,r16
8112aef0:	49cf883a 	add	r7,r9,r7
8112aef4:	81cf883a 	add	r7,r16,r7
8112aef8:	02800044 	movi	r10,1
8112aefc:	003fc306 	br	8112ae0c <__reset+0xfb10ae0c>
8112af00:	00800dc4 	movi	r2,55
8112af04:	003fcb06 	br	8112ae34 <__reset+0xfb10ae34>
8112af08:	38fff01e 	bne	r7,r3,8112aecc <__reset+0xfb10aecc>
8112af0c:	443fbe16 	blt	r8,r16,8112ae08 <__reset+0xfb10ae08>
8112af10:	003fee06 	br	8112aecc <__reset+0xfb10aecc>
8112af14:	e0002426 	beq	fp,zero,8112afa8 <_strtoll_r+0x2cc>
8112af18:	0005883a 	mov	r2,zero
8112af1c:	00e00034 	movhi	r3,32768
8112af20:	d9800017 	ldw	r6,0(sp)
8112af24:	01000884 	movi	r4,34
8112af28:	31000015 	stw	r4,0(r6)
8112af2c:	a83fd026 	beq	r21,zero,8112ae70 <__reset+0xfb10ae70>
8112af30:	297fffc4 	addi	r5,r5,-1
8112af34:	003fcd06 	br	8112ae6c <__reset+0xfb10ae6c>
8112af38:	1c400084 	addi	r17,r3,2
8112af3c:	1c000043 	ldbu	r16,1(r3)
8112af40:	07000044 	movi	fp,1
8112af44:	003f8706 	br	8112ad64 <__reset+0xfb10ad64>
8112af48:	1c400084 	addi	r17,r3,2
8112af4c:	1c000043 	ldbu	r16,1(r3)
8112af50:	0039883a 	mov	fp,zero
8112af54:	003f8306 	br	8112ad64 <__reset+0xfb10ad64>
8112af58:	88800003 	ldbu	r2,0(r17)
8112af5c:	00c01604 	movi	r3,88
8112af60:	108037cc 	andi	r2,r2,223
8112af64:	10c00a26 	beq	r2,r3,8112af90 <_strtoll_r+0x2b4>
8112af68:	05000204 	movi	r20,8
8112af6c:	002f883a 	mov	r23,zero
8112af70:	a027883a 	mov	r19,r20
8112af74:	003f8006 	br	8112ad78 <__reset+0xfb10ad78>
8112af78:	00800c04 	movi	r2,48
8112af7c:	80800e1e 	bne	r16,r2,8112afb8 <_strtoll_r+0x2dc>
8112af80:	88800003 	ldbu	r2,0(r17)
8112af84:	00c01604 	movi	r3,88
8112af88:	108037cc 	andi	r2,r2,223
8112af8c:	10c00a1e 	bne	r2,r3,8112afb8 <_strtoll_r+0x2dc>
8112af90:	05000404 	movi	r20,16
8112af94:	8c000043 	ldbu	r16,1(r17)
8112af98:	002f883a 	mov	r23,zero
8112af9c:	8c400084 	addi	r17,r17,2
8112afa0:	a027883a 	mov	r19,r20
8112afa4:	003f7406 	br	8112ad78 <__reset+0xfb10ad78>
8112afa8:	00e00034 	movhi	r3,32768
8112afac:	18ffffc4 	addi	r3,r3,-1
8112afb0:	5005883a 	mov	r2,r10
8112afb4:	003fda06 	br	8112af20 <__reset+0xfb10af20>
8112afb8:	9829883a 	mov	r20,r19
8112afbc:	002f883a 	mov	r23,zero
8112afc0:	003f6d06 	br	8112ad78 <__reset+0xfb10ad78>

8112afc4 <_strtoul_r>:
8112afc4:	00a04574 	movhi	r2,33045
8112afc8:	defff604 	addi	sp,sp,-40
8112afcc:	10ba8004 	addi	r2,r2,-5632
8112afd0:	de00012e 	bgeu	sp,et,8112afd8 <_strtoul_r+0x14>
8112afd4:	003b68fa 	trap	3
8112afd8:	dc800315 	stw	r18,12(sp)
8112afdc:	14800017 	ldw	r18,0(r2)
8112afe0:	dd400615 	stw	r21,24(sp)
8112afe4:	dd000515 	stw	r20,20(sp)
8112afe8:	dcc00415 	stw	r19,16(sp)
8112afec:	2029883a 	mov	r20,r4
8112aff0:	dfc00915 	stw	ra,36(sp)
8112aff4:	ddc00815 	stw	r23,32(sp)
8112aff8:	dd800715 	stw	r22,28(sp)
8112affc:	dc400215 	stw	r17,8(sp)
8112b000:	dc000115 	stw	r16,4(sp)
8112b004:	2827883a 	mov	r19,r5
8112b008:	382b883a 	mov	r21,r7
8112b00c:	2809883a 	mov	r4,r5
8112b010:	24000003 	ldbu	r16,0(r4)
8112b014:	24400044 	addi	r17,r4,1
8112b018:	2007883a 	mov	r3,r4
8112b01c:	9405883a 	add	r2,r18,r16
8112b020:	10800043 	ldbu	r2,1(r2)
8112b024:	8809883a 	mov	r4,r17
8112b028:	1080020c 	andi	r2,r2,8
8112b02c:	103ff81e 	bne	r2,zero,8112b010 <__reset+0xfb10b010>
8112b030:	00800b44 	movi	r2,45
8112b034:	80805326 	beq	r16,r2,8112b184 <_strtoul_r+0x1c0>
8112b038:	00800ac4 	movi	r2,43
8112b03c:	80805526 	beq	r16,r2,8112b194 <_strtoul_r+0x1d0>
8112b040:	002f883a 	mov	r23,zero
8112b044:	a8000f26 	beq	r21,zero,8112b084 <_strtoul_r+0xc0>
8112b048:	00800404 	movi	r2,16
8112b04c:	a8805f26 	beq	r21,r2,8112b1cc <_strtoul_r+0x208>
8112b050:	013fffc4 	movi	r4,-1
8112b054:	a80b883a 	mov	r5,r21
8112b058:	d9800015 	stw	r6,0(sp)
8112b05c:	11300b00 	call	811300b0 <__udivsi3>
8112b060:	a80b883a 	mov	r5,r21
8112b064:	013fffc4 	movi	r4,-1
8112b068:	102d883a 	mov	r22,r2
8112b06c:	11301140 	call	81130114 <__umodsi3>
8112b070:	d9800017 	ldw	r6,0(sp)
8112b074:	1019883a 	mov	r12,r2
8112b078:	a817883a 	mov	r11,r21
8112b07c:	b00f883a 	mov	r7,r22
8112b080:	00000706 	br	8112b0a0 <_strtoul_r+0xdc>
8112b084:	00800c04 	movi	r2,48
8112b088:	80804626 	beq	r16,r2,8112b1a4 <_strtoul_r+0x1e0>
8112b08c:	05400284 	movi	r21,10
8112b090:	01c666b4 	movhi	r7,6554
8112b094:	03000144 	movi	r12,5
8112b098:	39e66644 	addi	r7,r7,-26215
8112b09c:	a817883a 	mov	r11,r21
8112b0a0:	9407883a 	add	r3,r18,r16
8112b0a4:	18c00043 	ldbu	r3,1(r3)
8112b0a8:	8809883a 	mov	r4,r17
8112b0ac:	0011883a 	mov	r8,zero
8112b0b0:	1940010c 	andi	r5,r3,4
8112b0b4:	0005883a 	mov	r2,zero
8112b0b8:	02800044 	movi	r10,1
8112b0bc:	027fffc4 	movi	r9,-1
8112b0c0:	28000e26 	beq	r5,zero,8112b0fc <_strtoul_r+0x138>
8112b0c4:	843ff404 	addi	r16,r16,-48
8112b0c8:	8540120e 	bge	r16,r21,8112b114 <_strtoul_r+0x150>
8112b0cc:	42400526 	beq	r8,r9,8112b0e4 <_strtoul_r+0x120>
8112b0d0:	38802236 	bltu	r7,r2,8112b15c <_strtoul_r+0x198>
8112b0d4:	11c02026 	beq	r2,r7,8112b158 <_strtoul_r+0x194>
8112b0d8:	12c5383a 	mul	r2,r2,r11
8112b0dc:	02000044 	movi	r8,1
8112b0e0:	8085883a 	add	r2,r16,r2
8112b0e4:	24000003 	ldbu	r16,0(r4)
8112b0e8:	21000044 	addi	r4,r4,1
8112b0ec:	9407883a 	add	r3,r18,r16
8112b0f0:	18c00043 	ldbu	r3,1(r3)
8112b0f4:	1940010c 	andi	r5,r3,4
8112b0f8:	283ff21e 	bne	r5,zero,8112b0c4 <__reset+0xfb10b0c4>
8112b0fc:	18c000cc 	andi	r3,r3,3
8112b100:	18000426 	beq	r3,zero,8112b114 <_strtoul_r+0x150>
8112b104:	1a801726 	beq	r3,r10,8112b164 <_strtoul_r+0x1a0>
8112b108:	00c015c4 	movi	r3,87
8112b10c:	80e1c83a 	sub	r16,r16,r3
8112b110:	857fee16 	blt	r16,r21,8112b0cc <__reset+0xfb10b0cc>
8112b114:	40001516 	blt	r8,zero,8112b16c <_strtoul_r+0x1a8>
8112b118:	b8000126 	beq	r23,zero,8112b120 <_strtoul_r+0x15c>
8112b11c:	0085c83a 	sub	r2,zero,r2
8112b120:	30000226 	beq	r6,zero,8112b12c <_strtoul_r+0x168>
8112b124:	4000151e 	bne	r8,zero,8112b17c <_strtoul_r+0x1b8>
8112b128:	34c00015 	stw	r19,0(r6)
8112b12c:	dfc00917 	ldw	ra,36(sp)
8112b130:	ddc00817 	ldw	r23,32(sp)
8112b134:	dd800717 	ldw	r22,28(sp)
8112b138:	dd400617 	ldw	r21,24(sp)
8112b13c:	dd000517 	ldw	r20,20(sp)
8112b140:	dcc00417 	ldw	r19,16(sp)
8112b144:	dc800317 	ldw	r18,12(sp)
8112b148:	dc400217 	ldw	r17,8(sp)
8112b14c:	dc000117 	ldw	r16,4(sp)
8112b150:	dec00a04 	addi	sp,sp,40
8112b154:	f800283a 	ret
8112b158:	643fdf0e 	bge	r12,r16,8112b0d8 <__reset+0xfb10b0d8>
8112b15c:	023fffc4 	movi	r8,-1
8112b160:	003fe006 	br	8112b0e4 <__reset+0xfb10b0e4>
8112b164:	00c00dc4 	movi	r3,55
8112b168:	003fe806 	br	8112b10c <__reset+0xfb10b10c>
8112b16c:	00800884 	movi	r2,34
8112b170:	a0800015 	stw	r2,0(r20)
8112b174:	00bfffc4 	movi	r2,-1
8112b178:	303fec26 	beq	r6,zero,8112b12c <__reset+0xfb10b12c>
8112b17c:	24ffffc4 	addi	r19,r4,-1
8112b180:	003fe906 	br	8112b128 <__reset+0xfb10b128>
8112b184:	1c400084 	addi	r17,r3,2
8112b188:	1c000043 	ldbu	r16,1(r3)
8112b18c:	05c00044 	movi	r23,1
8112b190:	003fac06 	br	8112b044 <__reset+0xfb10b044>
8112b194:	1c400084 	addi	r17,r3,2
8112b198:	1c000043 	ldbu	r16,1(r3)
8112b19c:	002f883a 	mov	r23,zero
8112b1a0:	003fa806 	br	8112b044 <__reset+0xfb10b044>
8112b1a4:	88800003 	ldbu	r2,0(r17)
8112b1a8:	00c01604 	movi	r3,88
8112b1ac:	108037cc 	andi	r2,r2,223
8112b1b0:	10c00c26 	beq	r2,r3,8112b1e4 <_strtoul_r+0x220>
8112b1b4:	05400204 	movi	r21,8
8112b1b8:	01c80034 	movhi	r7,8192
8112b1bc:	030001c4 	movi	r12,7
8112b1c0:	39ffffc4 	addi	r7,r7,-1
8112b1c4:	a817883a 	mov	r11,r21
8112b1c8:	003fb506 	br	8112b0a0 <__reset+0xfb10b0a0>
8112b1cc:	00800c04 	movi	r2,48
8112b1d0:	80800c1e 	bne	r16,r2,8112b204 <_strtoul_r+0x240>
8112b1d4:	88800003 	ldbu	r2,0(r17)
8112b1d8:	00c01604 	movi	r3,88
8112b1dc:	108037cc 	andi	r2,r2,223
8112b1e0:	10c0081e 	bne	r2,r3,8112b204 <_strtoul_r+0x240>
8112b1e4:	02c00404 	movi	r11,16
8112b1e8:	05840034 	movhi	r22,4096
8112b1ec:	8c000043 	ldbu	r16,1(r17)
8112b1f0:	030003c4 	movi	r12,15
8112b1f4:	8c400084 	addi	r17,r17,2
8112b1f8:	b5bfffc4 	addi	r22,r22,-1
8112b1fc:	582b883a 	mov	r21,r11
8112b200:	003f9e06 	br	8112b07c <__reset+0xfb10b07c>
8112b204:	01c40034 	movhi	r7,4096
8112b208:	030003c4 	movi	r12,15
8112b20c:	39ffffc4 	addi	r7,r7,-1
8112b210:	a817883a 	mov	r11,r21
8112b214:	003fa206 	br	8112b0a0 <__reset+0xfb10b0a0>

8112b218 <strtoul>:
8112b218:	00a04574 	movhi	r2,33045
8112b21c:	10ba8204 	addi	r2,r2,-5624
8112b220:	300f883a 	mov	r7,r6
8112b224:	280d883a 	mov	r6,r5
8112b228:	200b883a 	mov	r5,r4
8112b22c:	11000017 	ldw	r4,0(r2)
8112b230:	112afc41 	jmpi	8112afc4 <_strtoul_r>

8112b234 <_strtoull_r>:
8112b234:	00a04574 	movhi	r2,33045
8112b238:	defff404 	addi	sp,sp,-48
8112b23c:	10ba8004 	addi	r2,r2,-5632
8112b240:	de00012e 	bgeu	sp,et,8112b248 <_strtoull_r+0x14>
8112b244:	003b68fa 	trap	3
8112b248:	dc400315 	stw	r17,12(sp)
8112b24c:	14400017 	ldw	r17,0(r2)
8112b250:	dd400715 	stw	r21,28(sp)
8112b254:	dd000615 	stw	r20,24(sp)
8112b258:	dcc00515 	stw	r19,20(sp)
8112b25c:	dc800415 	stw	r18,16(sp)
8112b260:	dfc00b15 	stw	ra,44(sp)
8112b264:	df000a15 	stw	fp,40(sp)
8112b268:	ddc00915 	stw	r23,36(sp)
8112b26c:	dd800815 	stw	r22,32(sp)
8112b270:	dc000215 	stw	r16,8(sp)
8112b274:	2827883a 	mov	r19,r5
8112b278:	202b883a 	mov	r21,r4
8112b27c:	3029883a 	mov	r20,r6
8112b280:	3825883a 	mov	r18,r7
8112b284:	2807883a 	mov	r3,r5
8112b288:	1c000003 	ldbu	r16,0(r3)
8112b28c:	1f000044 	addi	fp,r3,1
8112b290:	1809883a 	mov	r4,r3
8112b294:	8c05883a 	add	r2,r17,r16
8112b298:	10800043 	ldbu	r2,1(r2)
8112b29c:	e007883a 	mov	r3,fp
8112b2a0:	1080020c 	andi	r2,r2,8
8112b2a4:	103ff81e 	bne	r2,zero,8112b288 <__reset+0xfb10b288>
8112b2a8:	00800b44 	movi	r2,45
8112b2ac:	80806e26 	beq	r16,r2,8112b468 <_strtoull_r+0x234>
8112b2b0:	00800ac4 	movi	r2,43
8112b2b4:	80807026 	beq	r16,r2,8112b478 <_strtoull_r+0x244>
8112b2b8:	002f883a 	mov	r23,zero
8112b2bc:	90001426 	beq	r18,zero,8112b310 <_strtoull_r+0xdc>
8112b2c0:	00800404 	movi	r2,16
8112b2c4:	90807c26 	beq	r18,r2,8112b4b8 <_strtoull_r+0x284>
8112b2c8:	902dd7fa 	srai	r22,r18,31
8112b2cc:	013fffc4 	movi	r4,-1
8112b2d0:	200b883a 	mov	r5,r4
8112b2d4:	900d883a 	mov	r6,r18
8112b2d8:	b00f883a 	mov	r7,r22
8112b2dc:	112f4f80 	call	8112f4f8 <__udivdi3>
8112b2e0:	013fffc4 	movi	r4,-1
8112b2e4:	900d883a 	mov	r6,r18
8112b2e8:	b00f883a 	mov	r7,r22
8112b2ec:	200b883a 	mov	r5,r4
8112b2f0:	d8c00115 	stw	r3,4(sp)
8112b2f4:	d8800015 	stw	r2,0(sp)
8112b2f8:	112fa780 	call	8112fa78 <__umoddi3>
8112b2fc:	101b883a 	mov	r13,r2
8112b300:	9015883a 	mov	r10,r18
8112b304:	dac00017 	ldw	r11,0(sp)
8112b308:	da000117 	ldw	r8,4(sp)
8112b30c:	00000a06 	br	8112b338 <_strtoull_r+0x104>
8112b310:	00800c04 	movi	r2,48
8112b314:	80805c26 	beq	r16,r2,8112b488 <_strtoull_r+0x254>
8112b318:	02800284 	movi	r10,10
8112b31c:	02e666b4 	movhi	r11,39322
8112b320:	020666b4 	movhi	r8,6554
8112b324:	03400144 	movi	r13,5
8112b328:	5ae66644 	addi	r11,r11,-26215
8112b32c:	42266644 	addi	r8,r8,-26215
8112b330:	002d883a 	mov	r22,zero
8112b334:	5025883a 	mov	r18,r10
8112b338:	8c0b883a 	add	r5,r17,r16
8112b33c:	29400043 	ldbu	r5,1(r5)
8112b340:	e009883a 	mov	r4,fp
8112b344:	000f883a 	mov	r7,zero
8112b348:	2980010c 	andi	r6,r5,4
8112b34c:	0005883a 	mov	r2,zero
8112b350:	0007883a 	mov	r3,zero
8112b354:	03000044 	movi	r12,1
8112b358:	027fffc4 	movi	r9,-1
8112b35c:	30000d26 	beq	r6,zero,8112b394 <_strtoull_r+0x160>
8112b360:	843ff404 	addi	r16,r16,-48
8112b364:	8480110e 	bge	r16,r18,8112b3ac <_strtoull_r+0x178>
8112b368:	3a400426 	beq	r7,r9,8112b37c <_strtoull_r+0x148>
8112b36c:	40c00236 	bltu	r8,r3,8112b378 <_strtoull_r+0x144>
8112b370:	1a00231e 	bne	r3,r8,8112b400 <_strtoull_r+0x1cc>
8112b374:	5880222e 	bgeu	r11,r2,8112b400 <_strtoull_r+0x1cc>
8112b378:	01ffffc4 	movi	r7,-1
8112b37c:	24000003 	ldbu	r16,0(r4)
8112b380:	21000044 	addi	r4,r4,1
8112b384:	8c0b883a 	add	r5,r17,r16
8112b388:	29400043 	ldbu	r5,1(r5)
8112b38c:	2980010c 	andi	r6,r5,4
8112b390:	303ff31e 	bne	r6,zero,8112b360 <__reset+0xfb10b360>
8112b394:	294000cc 	andi	r5,r5,3
8112b398:	28000426 	beq	r5,zero,8112b3ac <_strtoull_r+0x178>
8112b39c:	2b002626 	beq	r5,r12,8112b438 <_strtoull_r+0x204>
8112b3a0:	014015c4 	movi	r5,87
8112b3a4:	8161c83a 	sub	r16,r16,r5
8112b3a8:	84bfef16 	blt	r16,r18,8112b368 <__reset+0xfb10b368>
8112b3ac:	38002716 	blt	r7,zero,8112b44c <_strtoull_r+0x218>
8112b3b0:	b8000426 	beq	r23,zero,8112b3c4 <_strtoull_r+0x190>
8112b3b4:	0085c83a 	sub	r2,zero,r2
8112b3b8:	100ac03a 	cmpne	r5,r2,zero
8112b3bc:	00e1c83a 	sub	r16,zero,r3
8112b3c0:	8147c83a 	sub	r3,r16,r5
8112b3c4:	a0000226 	beq	r20,zero,8112b3d0 <_strtoull_r+0x19c>
8112b3c8:	3800251e 	bne	r7,zero,8112b460 <_strtoull_r+0x22c>
8112b3cc:	a4c00015 	stw	r19,0(r20)
8112b3d0:	dfc00b17 	ldw	ra,44(sp)
8112b3d4:	df000a17 	ldw	fp,40(sp)
8112b3d8:	ddc00917 	ldw	r23,36(sp)
8112b3dc:	dd800817 	ldw	r22,32(sp)
8112b3e0:	dd400717 	ldw	r21,28(sp)
8112b3e4:	dd000617 	ldw	r20,24(sp)
8112b3e8:	dcc00517 	ldw	r19,20(sp)
8112b3ec:	dc800417 	ldw	r18,16(sp)
8112b3f0:	dc400317 	ldw	r17,12(sp)
8112b3f4:	dc000217 	ldw	r16,8(sp)
8112b3f8:	dec00c04 	addi	sp,sp,48
8112b3fc:	f800283a 	ret
8112b400:	12c00f26 	beq	r2,r11,8112b440 <_strtoull_r+0x20c>
8112b404:	b08d383a 	mul	r6,r22,r2
8112b408:	1a87383a 	mul	r3,r3,r10
8112b40c:	128a383a 	mulxuu	r5,r2,r10
8112b410:	1285383a 	mul	r2,r2,r10
8112b414:	800fd7fa 	srai	r7,r16,31
8112b418:	1987883a 	add	r3,r3,r6
8112b41c:	8085883a 	add	r2,r16,r2
8112b420:	1947883a 	add	r3,r3,r5
8112b424:	38c7883a 	add	r3,r7,r3
8112b428:	1421803a 	cmpltu	r16,r2,r16
8112b42c:	80c7883a 	add	r3,r16,r3
8112b430:	01c00044 	movi	r7,1
8112b434:	003fd106 	br	8112b37c <__reset+0xfb10b37c>
8112b438:	01400dc4 	movi	r5,55
8112b43c:	003fd906 	br	8112b3a4 <__reset+0xfb10b3a4>
8112b440:	1a3ff01e 	bne	r3,r8,8112b404 <__reset+0xfb10b404>
8112b444:	6c3fcc16 	blt	r13,r16,8112b378 <__reset+0xfb10b378>
8112b448:	003fee06 	br	8112b404 <__reset+0xfb10b404>
8112b44c:	00800884 	movi	r2,34
8112b450:	a8800015 	stw	r2,0(r21)
8112b454:	00bfffc4 	movi	r2,-1
8112b458:	1007883a 	mov	r3,r2
8112b45c:	a03fdc26 	beq	r20,zero,8112b3d0 <__reset+0xfb10b3d0>
8112b460:	24ffffc4 	addi	r19,r4,-1
8112b464:	003fd906 	br	8112b3cc <__reset+0xfb10b3cc>
8112b468:	27000084 	addi	fp,r4,2
8112b46c:	24000043 	ldbu	r16,1(r4)
8112b470:	05c00044 	movi	r23,1
8112b474:	003f9106 	br	8112b2bc <__reset+0xfb10b2bc>
8112b478:	27000084 	addi	fp,r4,2
8112b47c:	24000043 	ldbu	r16,1(r4)
8112b480:	002f883a 	mov	r23,zero
8112b484:	003f8d06 	br	8112b2bc <__reset+0xfb10b2bc>
8112b488:	e0800003 	ldbu	r2,0(fp)
8112b48c:	00c01604 	movi	r3,88
8112b490:	108037cc 	andi	r2,r2,223
8112b494:	10c00e26 	beq	r2,r3,8112b4d0 <_strtoull_r+0x29c>
8112b498:	02800204 	movi	r10,8
8112b49c:	02ffffc4 	movi	r11,-1
8112b4a0:	02080034 	movhi	r8,8192
8112b4a4:	034001c4 	movi	r13,7
8112b4a8:	42d1883a 	add	r8,r8,r11
8112b4ac:	002d883a 	mov	r22,zero
8112b4b0:	5025883a 	mov	r18,r10
8112b4b4:	003fa006 	br	8112b338 <__reset+0xfb10b338>
8112b4b8:	00800c04 	movi	r2,48
8112b4bc:	80800e1e 	bne	r16,r2,8112b4f8 <_strtoull_r+0x2c4>
8112b4c0:	e0800003 	ldbu	r2,0(fp)
8112b4c4:	00c01604 	movi	r3,88
8112b4c8:	108037cc 	andi	r2,r2,223
8112b4cc:	10c00a1e 	bne	r2,r3,8112b4f8 <_strtoull_r+0x2c4>
8112b4d0:	02800404 	movi	r10,16
8112b4d4:	02ffffc4 	movi	r11,-1
8112b4d8:	02040034 	movhi	r8,4096
8112b4dc:	e4000043 	ldbu	r16,1(fp)
8112b4e0:	034003c4 	movi	r13,15
8112b4e4:	e7000084 	addi	fp,fp,2
8112b4e8:	42d1883a 	add	r8,r8,r11
8112b4ec:	002d883a 	mov	r22,zero
8112b4f0:	5025883a 	mov	r18,r10
8112b4f4:	003f9006 	br	8112b338 <__reset+0xfb10b338>
8112b4f8:	02ffffc4 	movi	r11,-1
8112b4fc:	02040034 	movhi	r8,4096
8112b500:	034003c4 	movi	r13,15
8112b504:	42d1883a 	add	r8,r8,r11
8112b508:	9015883a 	mov	r10,r18
8112b50c:	002d883a 	mov	r22,zero
8112b510:	003f8906 	br	8112b338 <__reset+0xfb10b338>

8112b514 <__ssprint_r>:
8112b514:	defff604 	addi	sp,sp,-40
8112b518:	de00012e 	bgeu	sp,et,8112b520 <__ssprint_r+0xc>
8112b51c:	003b68fa 	trap	3
8112b520:	30800217 	ldw	r2,8(r6)
8112b524:	dc800215 	stw	r18,8(sp)
8112b528:	dfc00915 	stw	ra,36(sp)
8112b52c:	df000815 	stw	fp,32(sp)
8112b530:	ddc00715 	stw	r23,28(sp)
8112b534:	dd800615 	stw	r22,24(sp)
8112b538:	dd400515 	stw	r21,20(sp)
8112b53c:	dd000415 	stw	r20,16(sp)
8112b540:	dcc00315 	stw	r19,12(sp)
8112b544:	dc400115 	stw	r17,4(sp)
8112b548:	dc000015 	stw	r16,0(sp)
8112b54c:	3025883a 	mov	r18,r6
8112b550:	10005826 	beq	r2,zero,8112b6b4 <__ssprint_r+0x1a0>
8112b554:	2027883a 	mov	r19,r4
8112b558:	35c00017 	ldw	r23,0(r6)
8112b55c:	29000017 	ldw	r4,0(r5)
8112b560:	28800217 	ldw	r2,8(r5)
8112b564:	2823883a 	mov	r17,r5
8112b568:	0039883a 	mov	fp,zero
8112b56c:	0021883a 	mov	r16,zero
8112b570:	80003926 	beq	r16,zero,8112b658 <__ssprint_r+0x144>
8112b574:	102b883a 	mov	r21,r2
8112b578:	102d883a 	mov	r22,r2
8112b57c:	80803a36 	bltu	r16,r2,8112b668 <__ssprint_r+0x154>
8112b580:	88c0030b 	ldhu	r3,12(r17)
8112b584:	1881200c 	andi	r2,r3,1152
8112b588:	10002626 	beq	r2,zero,8112b624 <__ssprint_r+0x110>
8112b58c:	88800517 	ldw	r2,20(r17)
8112b590:	89400417 	ldw	r5,16(r17)
8112b594:	81800044 	addi	r6,r16,1
8112b598:	108f883a 	add	r7,r2,r2
8112b59c:	3885883a 	add	r2,r7,r2
8112b5a0:	100ed7fa 	srli	r7,r2,31
8112b5a4:	216dc83a 	sub	r22,r4,r5
8112b5a8:	3589883a 	add	r4,r6,r22
8112b5ac:	3885883a 	add	r2,r7,r2
8112b5b0:	102bd07a 	srai	r21,r2,1
8112b5b4:	a80d883a 	mov	r6,r21
8112b5b8:	a900022e 	bgeu	r21,r4,8112b5c4 <__ssprint_r+0xb0>
8112b5bc:	202b883a 	mov	r21,r4
8112b5c0:	200d883a 	mov	r6,r4
8112b5c4:	18c1000c 	andi	r3,r3,1024
8112b5c8:	18002a26 	beq	r3,zero,8112b674 <__ssprint_r+0x160>
8112b5cc:	300b883a 	mov	r5,r6
8112b5d0:	9809883a 	mov	r4,r19
8112b5d4:	111d2b40 	call	8111d2b4 <_malloc_r>
8112b5d8:	1029883a 	mov	r20,r2
8112b5dc:	10002c26 	beq	r2,zero,8112b690 <__ssprint_r+0x17c>
8112b5e0:	89400417 	ldw	r5,16(r17)
8112b5e4:	b00d883a 	mov	r6,r22
8112b5e8:	1009883a 	mov	r4,r2
8112b5ec:	111dac80 	call	8111dac8 <memcpy>
8112b5f0:	8880030b 	ldhu	r2,12(r17)
8112b5f4:	00fedfc4 	movi	r3,-1153
8112b5f8:	10c4703a 	and	r2,r2,r3
8112b5fc:	10802014 	ori	r2,r2,128
8112b600:	8880030d 	sth	r2,12(r17)
8112b604:	a589883a 	add	r4,r20,r22
8112b608:	adadc83a 	sub	r22,r21,r22
8112b60c:	8d400515 	stw	r21,20(r17)
8112b610:	8d800215 	stw	r22,8(r17)
8112b614:	8d000415 	stw	r20,16(r17)
8112b618:	89000015 	stw	r4,0(r17)
8112b61c:	802b883a 	mov	r21,r16
8112b620:	802d883a 	mov	r22,r16
8112b624:	b00d883a 	mov	r6,r22
8112b628:	e00b883a 	mov	r5,fp
8112b62c:	1127b9c0 	call	81127b9c <memmove>
8112b630:	88800217 	ldw	r2,8(r17)
8112b634:	89000017 	ldw	r4,0(r17)
8112b638:	90c00217 	ldw	r3,8(r18)
8112b63c:	1545c83a 	sub	r2,r2,r21
8112b640:	2589883a 	add	r4,r4,r22
8112b644:	88800215 	stw	r2,8(r17)
8112b648:	89000015 	stw	r4,0(r17)
8112b64c:	1c21c83a 	sub	r16,r3,r16
8112b650:	94000215 	stw	r16,8(r18)
8112b654:	80001726 	beq	r16,zero,8112b6b4 <__ssprint_r+0x1a0>
8112b658:	bf000017 	ldw	fp,0(r23)
8112b65c:	bc000117 	ldw	r16,4(r23)
8112b660:	bdc00204 	addi	r23,r23,8
8112b664:	003fc206 	br	8112b570 <__reset+0xfb10b570>
8112b668:	802b883a 	mov	r21,r16
8112b66c:	802d883a 	mov	r22,r16
8112b670:	003fec06 	br	8112b624 <__reset+0xfb10b624>
8112b674:	9809883a 	mov	r4,r19
8112b678:	1128dbc0 	call	81128dbc <_realloc_r>
8112b67c:	1029883a 	mov	r20,r2
8112b680:	103fe01e 	bne	r2,zero,8112b604 <__reset+0xfb10b604>
8112b684:	89400417 	ldw	r5,16(r17)
8112b688:	9809883a 	mov	r4,r19
8112b68c:	1126d280 	call	81126d28 <_free_r>
8112b690:	88c0030b 	ldhu	r3,12(r17)
8112b694:	00800304 	movi	r2,12
8112b698:	98800015 	stw	r2,0(r19)
8112b69c:	18c01014 	ori	r3,r3,64
8112b6a0:	88c0030d 	sth	r3,12(r17)
8112b6a4:	00bfffc4 	movi	r2,-1
8112b6a8:	90000215 	stw	zero,8(r18)
8112b6ac:	90000115 	stw	zero,4(r18)
8112b6b0:	00000206 	br	8112b6bc <__ssprint_r+0x1a8>
8112b6b4:	90000115 	stw	zero,4(r18)
8112b6b8:	0005883a 	mov	r2,zero
8112b6bc:	dfc00917 	ldw	ra,36(sp)
8112b6c0:	df000817 	ldw	fp,32(sp)
8112b6c4:	ddc00717 	ldw	r23,28(sp)
8112b6c8:	dd800617 	ldw	r22,24(sp)
8112b6cc:	dd400517 	ldw	r21,20(sp)
8112b6d0:	dd000417 	ldw	r20,16(sp)
8112b6d4:	dcc00317 	ldw	r19,12(sp)
8112b6d8:	dc800217 	ldw	r18,8(sp)
8112b6dc:	dc400117 	ldw	r17,4(sp)
8112b6e0:	dc000017 	ldw	r16,0(sp)
8112b6e4:	dec00a04 	addi	sp,sp,40
8112b6e8:	f800283a 	ret

8112b6ec <___svfiprintf_internal_r>:
8112b6ec:	deffc804 	addi	sp,sp,-224
8112b6f0:	de00012e 	bgeu	sp,et,8112b6f8 <___svfiprintf_internal_r+0xc>
8112b6f4:	003b68fa 	trap	3
8112b6f8:	2880030b 	ldhu	r2,12(r5)
8112b6fc:	dcc03115 	stw	r19,196(sp)
8112b700:	dfc03715 	stw	ra,220(sp)
8112b704:	df003615 	stw	fp,216(sp)
8112b708:	ddc03515 	stw	r23,212(sp)
8112b70c:	dd803415 	stw	r22,208(sp)
8112b710:	dd403315 	stw	r21,204(sp)
8112b714:	dd003215 	stw	r20,200(sp)
8112b718:	dc803015 	stw	r18,192(sp)
8112b71c:	dc402f15 	stw	r17,188(sp)
8112b720:	dc002e15 	stw	r16,184(sp)
8112b724:	d9402715 	stw	r5,156(sp)
8112b728:	d9002a15 	stw	r4,168(sp)
8112b72c:	1080200c 	andi	r2,r2,128
8112b730:	d9c02315 	stw	r7,140(sp)
8112b734:	3027883a 	mov	r19,r6
8112b738:	10000226 	beq	r2,zero,8112b744 <___svfiprintf_internal_r+0x58>
8112b73c:	28800417 	ldw	r2,16(r5)
8112b740:	10041d26 	beq	r2,zero,8112c7b8 <___svfiprintf_internal_r+0x10cc>
8112b744:	dac01a04 	addi	r11,sp,104
8112b748:	dac01e15 	stw	r11,120(sp)
8112b74c:	d8801e17 	ldw	r2,120(sp)
8112b750:	dac019c4 	addi	r11,sp,103
8112b754:	dd402a17 	ldw	r21,168(sp)
8112b758:	ddc02717 	ldw	r23,156(sp)
8112b75c:	05a04574 	movhi	r22,33045
8112b760:	05204574 	movhi	r20,33045
8112b764:	dac01f15 	stw	r11,124(sp)
8112b768:	12d7c83a 	sub	r11,r2,r11
8112b76c:	b5b14104 	addi	r22,r22,-15100
8112b770:	a5313d04 	addi	r20,r20,-15116
8112b774:	dec01a15 	stw	sp,104(sp)
8112b778:	d8001c15 	stw	zero,112(sp)
8112b77c:	d8001b15 	stw	zero,108(sp)
8112b780:	d811883a 	mov	r8,sp
8112b784:	d8002915 	stw	zero,164(sp)
8112b788:	d8002515 	stw	zero,148(sp)
8112b78c:	dac02b15 	stw	r11,172(sp)
8112b790:	98800007 	ldb	r2,0(r19)
8112b794:	1002dd26 	beq	r2,zero,8112c30c <___svfiprintf_internal_r+0xc20>
8112b798:	00c00944 	movi	r3,37
8112b79c:	9823883a 	mov	r17,r19
8112b7a0:	10c0021e 	bne	r2,r3,8112b7ac <___svfiprintf_internal_r+0xc0>
8112b7a4:	00001406 	br	8112b7f8 <___svfiprintf_internal_r+0x10c>
8112b7a8:	10c00326 	beq	r2,r3,8112b7b8 <___svfiprintf_internal_r+0xcc>
8112b7ac:	8c400044 	addi	r17,r17,1
8112b7b0:	88800007 	ldb	r2,0(r17)
8112b7b4:	103ffc1e 	bne	r2,zero,8112b7a8 <__reset+0xfb10b7a8>
8112b7b8:	8ce1c83a 	sub	r16,r17,r19
8112b7bc:	80000e26 	beq	r16,zero,8112b7f8 <___svfiprintf_internal_r+0x10c>
8112b7c0:	d8c01c17 	ldw	r3,112(sp)
8112b7c4:	d8801b17 	ldw	r2,108(sp)
8112b7c8:	44c00015 	stw	r19,0(r8)
8112b7cc:	1c07883a 	add	r3,r3,r16
8112b7d0:	10800044 	addi	r2,r2,1
8112b7d4:	d8c01c15 	stw	r3,112(sp)
8112b7d8:	44000115 	stw	r16,4(r8)
8112b7dc:	d8801b15 	stw	r2,108(sp)
8112b7e0:	00c001c4 	movi	r3,7
8112b7e4:	18831e16 	blt	r3,r2,8112c460 <___svfiprintf_internal_r+0xd74>
8112b7e8:	42000204 	addi	r8,r8,8
8112b7ec:	dac02517 	ldw	r11,148(sp)
8112b7f0:	5c17883a 	add	r11,r11,r16
8112b7f4:	dac02515 	stw	r11,148(sp)
8112b7f8:	88800007 	ldb	r2,0(r17)
8112b7fc:	1002c526 	beq	r2,zero,8112c314 <___svfiprintf_internal_r+0xc28>
8112b800:	88c00047 	ldb	r3,1(r17)
8112b804:	8cc00044 	addi	r19,r17,1
8112b808:	d8001d85 	stb	zero,118(sp)
8112b80c:	0009883a 	mov	r4,zero
8112b810:	000f883a 	mov	r7,zero
8112b814:	043fffc4 	movi	r16,-1
8112b818:	d8002415 	stw	zero,144(sp)
8112b81c:	0025883a 	mov	r18,zero
8112b820:	01401604 	movi	r5,88
8112b824:	01800244 	movi	r6,9
8112b828:	02800a84 	movi	r10,42
8112b82c:	02401b04 	movi	r9,108
8112b830:	9cc00044 	addi	r19,r19,1
8112b834:	18bff804 	addi	r2,r3,-32
8112b838:	2881dd36 	bltu	r5,r2,8112bfb0 <___svfiprintf_internal_r+0x8c4>
8112b83c:	100490ba 	slli	r2,r2,2
8112b840:	02e044f4 	movhi	r11,33043
8112b844:	5aee1504 	addi	r11,r11,-18348
8112b848:	12c5883a 	add	r2,r2,r11
8112b84c:	10800017 	ldw	r2,0(r2)
8112b850:	1000683a 	jmp	r2
8112b854:	8112ba50 	cmplti	r4,r16,19177
8112b858:	8112bfb0 	cmpltui	r4,r16,19198
8112b85c:	8112bfb0 	cmpltui	r4,r16,19198
8112b860:	8112ba44 	addi	r4,r16,19177
8112b864:	8112bfb0 	cmpltui	r4,r16,19198
8112b868:	8112bfb0 	cmpltui	r4,r16,19198
8112b86c:	8112bfb0 	cmpltui	r4,r16,19198
8112b870:	8112bfb0 	cmpltui	r4,r16,19198
8112b874:	8112bfb0 	cmpltui	r4,r16,19198
8112b878:	8112bfb0 	cmpltui	r4,r16,19198
8112b87c:	8112b9b8 	rdprs	r4,r16,19174
8112b880:	8112bb94 	ori	r4,r16,19182
8112b884:	8112bfb0 	cmpltui	r4,r16,19198
8112b888:	8112b9e4 	muli	r4,r16,19175
8112b88c:	8112bfe4 	muli	r4,r16,19199
8112b890:	8112bfb0 	cmpltui	r4,r16,19198
8112b894:	8112bfd8 	cmpnei	r4,r16,19199
8112b898:	8112bf78 	rdprs	r4,r16,19197
8112b89c:	8112bf78 	rdprs	r4,r16,19197
8112b8a0:	8112bf78 	rdprs	r4,r16,19197
8112b8a4:	8112bf78 	rdprs	r4,r16,19197
8112b8a8:	8112bf78 	rdprs	r4,r16,19197
8112b8ac:	8112bf78 	rdprs	r4,r16,19197
8112b8b0:	8112bf78 	rdprs	r4,r16,19197
8112b8b4:	8112bf78 	rdprs	r4,r16,19197
8112b8b8:	8112bf78 	rdprs	r4,r16,19197
8112b8bc:	8112bfb0 	cmpltui	r4,r16,19198
8112b8c0:	8112bfb0 	cmpltui	r4,r16,19198
8112b8c4:	8112bfb0 	cmpltui	r4,r16,19198
8112b8c8:	8112bfb0 	cmpltui	r4,r16,19198
8112b8cc:	8112bfb0 	cmpltui	r4,r16,19198
8112b8d0:	8112bfb0 	cmpltui	r4,r16,19198
8112b8d4:	8112bfb0 	cmpltui	r4,r16,19198
8112b8d8:	8112bfb0 	cmpltui	r4,r16,19198
8112b8dc:	8112bfb0 	cmpltui	r4,r16,19198
8112b8e0:	8112bfb0 	cmpltui	r4,r16,19198
8112b8e4:	8112bf14 	ori	r4,r16,19196
8112b8e8:	8112bfb0 	cmpltui	r4,r16,19198
8112b8ec:	8112bfb0 	cmpltui	r4,r16,19198
8112b8f0:	8112bfb0 	cmpltui	r4,r16,19198
8112b8f4:	8112bfb0 	cmpltui	r4,r16,19198
8112b8f8:	8112bfb0 	cmpltui	r4,r16,19198
8112b8fc:	8112bfb0 	cmpltui	r4,r16,19198
8112b900:	8112bfb0 	cmpltui	r4,r16,19198
8112b904:	8112bfb0 	cmpltui	r4,r16,19198
8112b908:	8112bfb0 	cmpltui	r4,r16,19198
8112b90c:	8112bfb0 	cmpltui	r4,r16,19198
8112b910:	8112c08c 	andi	r4,r16,19202
8112b914:	8112bfb0 	cmpltui	r4,r16,19198
8112b918:	8112bfb0 	cmpltui	r4,r16,19198
8112b91c:	8112bfb0 	cmpltui	r4,r16,19198
8112b920:	8112bfb0 	cmpltui	r4,r16,19198
8112b924:	8112bfb0 	cmpltui	r4,r16,19198
8112b928:	8112c024 	muli	r4,r16,19200
8112b92c:	8112bfb0 	cmpltui	r4,r16,19198
8112b930:	8112bfb0 	cmpltui	r4,r16,19198
8112b934:	8112bd58 	cmpnei	r4,r16,19189
8112b938:	8112bfb0 	cmpltui	r4,r16,19198
8112b93c:	8112bfb0 	cmpltui	r4,r16,19198
8112b940:	8112bfb0 	cmpltui	r4,r16,19198
8112b944:	8112bfb0 	cmpltui	r4,r16,19198
8112b948:	8112bfb0 	cmpltui	r4,r16,19198
8112b94c:	8112bfb0 	cmpltui	r4,r16,19198
8112b950:	8112bfb0 	cmpltui	r4,r16,19198
8112b954:	8112bfb0 	cmpltui	r4,r16,19198
8112b958:	8112bfb0 	cmpltui	r4,r16,19198
8112b95c:	8112bfb0 	cmpltui	r4,r16,19198
8112b960:	8112bc48 	cmpgei	r4,r16,19185
8112b964:	8112bdf4 	orhi	r4,r16,19191
8112b968:	8112bfb0 	cmpltui	r4,r16,19198
8112b96c:	8112bfb0 	cmpltui	r4,r16,19198
8112b970:	8112bfb0 	cmpltui	r4,r16,19198
8112b974:	8112bde8 	cmpgeui	r4,r16,19191
8112b978:	8112bdf4 	orhi	r4,r16,19191
8112b97c:	8112bfb0 	cmpltui	r4,r16,19198
8112b980:	8112bfb0 	cmpltui	r4,r16,19198
8112b984:	8112bdd8 	cmpnei	r4,r16,19191
8112b988:	8112bfb0 	cmpltui	r4,r16,19198
8112b98c:	8112bd9c 	xori	r4,r16,19190
8112b990:	8112bba4 	muli	r4,r16,19182
8112b994:	8112b9f0 	cmpltui	r4,r16,19175
8112b998:	8112bf08 	cmpgei	r4,r16,19196
8112b99c:	8112bfb0 	cmpltui	r4,r16,19198
8112b9a0:	8112bebc 	xorhi	r4,r16,19194
8112b9a4:	8112bfb0 	cmpltui	r4,r16,19198
8112b9a8:	8112bb14 	ori	r4,r16,19180
8112b9ac:	8112bfb0 	cmpltui	r4,r16,19198
8112b9b0:	8112bfb0 	cmpltui	r4,r16,19198
8112b9b4:	8112ba70 	cmpltui	r4,r16,19177
8112b9b8:	dac02317 	ldw	r11,140(sp)
8112b9bc:	5ac00017 	ldw	r11,0(r11)
8112b9c0:	dac02415 	stw	r11,144(sp)
8112b9c4:	dac02317 	ldw	r11,140(sp)
8112b9c8:	58800104 	addi	r2,r11,4
8112b9cc:	dac02417 	ldw	r11,144(sp)
8112b9d0:	5802e90e 	bge	r11,zero,8112c578 <___svfiprintf_internal_r+0xe8c>
8112b9d4:	dac02417 	ldw	r11,144(sp)
8112b9d8:	d8802315 	stw	r2,140(sp)
8112b9dc:	02d7c83a 	sub	r11,zero,r11
8112b9e0:	dac02415 	stw	r11,144(sp)
8112b9e4:	94800114 	ori	r18,r18,4
8112b9e8:	98c00007 	ldb	r3,0(r19)
8112b9ec:	003f9006 	br	8112b830 <__reset+0xfb10b830>
8112b9f0:	00800c04 	movi	r2,48
8112b9f4:	dac02317 	ldw	r11,140(sp)
8112b9f8:	d8801d05 	stb	r2,116(sp)
8112b9fc:	00801e04 	movi	r2,120
8112ba00:	d8801d45 	stb	r2,117(sp)
8112ba04:	d8001d85 	stb	zero,118(sp)
8112ba08:	58c00104 	addi	r3,r11,4
8112ba0c:	5f000017 	ldw	fp,0(r11)
8112ba10:	0013883a 	mov	r9,zero
8112ba14:	90800094 	ori	r2,r18,2
8112ba18:	80032b16 	blt	r16,zero,8112c6c8 <___svfiprintf_internal_r+0xfdc>
8112ba1c:	00bfdfc4 	movi	r2,-129
8112ba20:	90a4703a 	and	r18,r18,r2
8112ba24:	d8c02315 	stw	r3,140(sp)
8112ba28:	94800094 	ori	r18,r18,2
8112ba2c:	e002dc26 	beq	fp,zero,8112c5a0 <___svfiprintf_internal_r+0xeb4>
8112ba30:	01204574 	movhi	r4,33045
8112ba34:	2130b304 	addi	r4,r4,-15668
8112ba38:	0015883a 	mov	r10,zero
8112ba3c:	d9002915 	stw	r4,164(sp)
8112ba40:	00002306 	br	8112bad0 <___svfiprintf_internal_r+0x3e4>
8112ba44:	94800054 	ori	r18,r18,1
8112ba48:	98c00007 	ldb	r3,0(r19)
8112ba4c:	003f7806 	br	8112b830 <__reset+0xfb10b830>
8112ba50:	38803fcc 	andi	r2,r7,255
8112ba54:	1080201c 	xori	r2,r2,128
8112ba58:	10bfe004 	addi	r2,r2,-128
8112ba5c:	1002f31e 	bne	r2,zero,8112c62c <___svfiprintf_internal_r+0xf40>
8112ba60:	01000044 	movi	r4,1
8112ba64:	01c00804 	movi	r7,32
8112ba68:	98c00007 	ldb	r3,0(r19)
8112ba6c:	003f7006 	br	8112b830 <__reset+0xfb10b830>
8112ba70:	21003fcc 	andi	r4,r4,255
8112ba74:	2003aa1e 	bne	r4,zero,8112c920 <___svfiprintf_internal_r+0x1234>
8112ba78:	00a04574 	movhi	r2,33045
8112ba7c:	10b0b304 	addi	r2,r2,-15668
8112ba80:	d8802915 	stw	r2,164(sp)
8112ba84:	9080080c 	andi	r2,r18,32
8112ba88:	1000ba26 	beq	r2,zero,8112bd74 <___svfiprintf_internal_r+0x688>
8112ba8c:	dac02317 	ldw	r11,140(sp)
8112ba90:	5f000017 	ldw	fp,0(r11)
8112ba94:	5a400117 	ldw	r9,4(r11)
8112ba98:	5ac00204 	addi	r11,r11,8
8112ba9c:	dac02315 	stw	r11,140(sp)
8112baa0:	9080004c 	andi	r2,r18,1
8112baa4:	10029026 	beq	r2,zero,8112c4e8 <___svfiprintf_internal_r+0xdfc>
8112baa8:	e244b03a 	or	r2,fp,r9
8112baac:	1002d41e 	bne	r2,zero,8112c600 <___svfiprintf_internal_r+0xf14>
8112bab0:	d8001d85 	stb	zero,118(sp)
8112bab4:	80030b16 	blt	r16,zero,8112c6e4 <___svfiprintf_internal_r+0xff8>
8112bab8:	00bfdfc4 	movi	r2,-129
8112babc:	90a4703a 	and	r18,r18,r2
8112bac0:	0015883a 	mov	r10,zero
8112bac4:	80002426 	beq	r16,zero,8112bb58 <___svfiprintf_internal_r+0x46c>
8112bac8:	0039883a 	mov	fp,zero
8112bacc:	0013883a 	mov	r9,zero
8112bad0:	d9002917 	ldw	r4,164(sp)
8112bad4:	dc401a04 	addi	r17,sp,104
8112bad8:	e08003cc 	andi	r2,fp,15
8112badc:	4806973a 	slli	r3,r9,28
8112bae0:	2085883a 	add	r2,r4,r2
8112bae4:	e038d13a 	srli	fp,fp,4
8112bae8:	10800003 	ldbu	r2,0(r2)
8112baec:	4812d13a 	srli	r9,r9,4
8112baf0:	8c7fffc4 	addi	r17,r17,-1
8112baf4:	1f38b03a 	or	fp,r3,fp
8112baf8:	88800005 	stb	r2,0(r17)
8112bafc:	e244b03a 	or	r2,fp,r9
8112bb00:	103ff51e 	bne	r2,zero,8112bad8 <__reset+0xfb10bad8>
8112bb04:	dac01e17 	ldw	r11,120(sp)
8112bb08:	5c57c83a 	sub	r11,r11,r17
8112bb0c:	dac02115 	stw	r11,132(sp)
8112bb10:	00001406 	br	8112bb64 <___svfiprintf_internal_r+0x478>
8112bb14:	21003fcc 	andi	r4,r4,255
8112bb18:	2003741e 	bne	r4,zero,8112c8ec <___svfiprintf_internal_r+0x1200>
8112bb1c:	9080080c 	andi	r2,r18,32
8112bb20:	10014526 	beq	r2,zero,8112c038 <___svfiprintf_internal_r+0x94c>
8112bb24:	dac02317 	ldw	r11,140(sp)
8112bb28:	d8001d85 	stb	zero,118(sp)
8112bb2c:	58c00204 	addi	r3,r11,8
8112bb30:	5f000017 	ldw	fp,0(r11)
8112bb34:	5a400117 	ldw	r9,4(r11)
8112bb38:	8002d916 	blt	r16,zero,8112c6a0 <___svfiprintf_internal_r+0xfb4>
8112bb3c:	013fdfc4 	movi	r4,-129
8112bb40:	e244b03a 	or	r2,fp,r9
8112bb44:	d8c02315 	stw	r3,140(sp)
8112bb48:	9124703a 	and	r18,r18,r4
8112bb4c:	0015883a 	mov	r10,zero
8112bb50:	1000b91e 	bne	r2,zero,8112be38 <___svfiprintf_internal_r+0x74c>
8112bb54:	8002e61e 	bne	r16,zero,8112c6f0 <___svfiprintf_internal_r+0x1004>
8112bb58:	0021883a 	mov	r16,zero
8112bb5c:	d8002115 	stw	zero,132(sp)
8112bb60:	dc401a04 	addi	r17,sp,104
8112bb64:	d8c02117 	ldw	r3,132(sp)
8112bb68:	dc002015 	stw	r16,128(sp)
8112bb6c:	80c0010e 	bge	r16,r3,8112bb74 <___svfiprintf_internal_r+0x488>
8112bb70:	d8c02015 	stw	r3,128(sp)
8112bb74:	52803fcc 	andi	r10,r10,255
8112bb78:	5280201c 	xori	r10,r10,128
8112bb7c:	52bfe004 	addi	r10,r10,-128
8112bb80:	50003c26 	beq	r10,zero,8112bc74 <___svfiprintf_internal_r+0x588>
8112bb84:	dac02017 	ldw	r11,128(sp)
8112bb88:	5ac00044 	addi	r11,r11,1
8112bb8c:	dac02015 	stw	r11,128(sp)
8112bb90:	00003806 	br	8112bc74 <___svfiprintf_internal_r+0x588>
8112bb94:	01000044 	movi	r4,1
8112bb98:	01c00ac4 	movi	r7,43
8112bb9c:	98c00007 	ldb	r3,0(r19)
8112bba0:	003f2306 	br	8112b830 <__reset+0xfb10b830>
8112bba4:	21003fcc 	andi	r4,r4,255
8112bba8:	2003481e 	bne	r4,zero,8112c8cc <___svfiprintf_internal_r+0x11e0>
8112bbac:	9080080c 	andi	r2,r18,32
8112bbb0:	10013b26 	beq	r2,zero,8112c0a0 <___svfiprintf_internal_r+0x9b4>
8112bbb4:	dac02317 	ldw	r11,140(sp)
8112bbb8:	d8001d85 	stb	zero,118(sp)
8112bbbc:	58800204 	addi	r2,r11,8
8112bbc0:	5f000017 	ldw	fp,0(r11)
8112bbc4:	5a400117 	ldw	r9,4(r11)
8112bbc8:	8002a816 	blt	r16,zero,8112c66c <___svfiprintf_internal_r+0xf80>
8112bbcc:	013fdfc4 	movi	r4,-129
8112bbd0:	e246b03a 	or	r3,fp,r9
8112bbd4:	d8802315 	stw	r2,140(sp)
8112bbd8:	9124703a 	and	r18,r18,r4
8112bbdc:	18013c26 	beq	r3,zero,8112c0d0 <___svfiprintf_internal_r+0x9e4>
8112bbe0:	0015883a 	mov	r10,zero
8112bbe4:	dc401a04 	addi	r17,sp,104
8112bbe8:	e006d0fa 	srli	r3,fp,3
8112bbec:	4808977a 	slli	r4,r9,29
8112bbf0:	4812d0fa 	srli	r9,r9,3
8112bbf4:	e70001cc 	andi	fp,fp,7
8112bbf8:	e0800c04 	addi	r2,fp,48
8112bbfc:	8c7fffc4 	addi	r17,r17,-1
8112bc00:	20f8b03a 	or	fp,r4,r3
8112bc04:	88800005 	stb	r2,0(r17)
8112bc08:	e246b03a 	or	r3,fp,r9
8112bc0c:	183ff61e 	bne	r3,zero,8112bbe8 <__reset+0xfb10bbe8>
8112bc10:	90c0004c 	andi	r3,r18,1
8112bc14:	1800a526 	beq	r3,zero,8112beac <___svfiprintf_internal_r+0x7c0>
8112bc18:	10803fcc 	andi	r2,r2,255
8112bc1c:	1080201c 	xori	r2,r2,128
8112bc20:	10bfe004 	addi	r2,r2,-128
8112bc24:	00c00c04 	movi	r3,48
8112bc28:	10ffb626 	beq	r2,r3,8112bb04 <__reset+0xfb10bb04>
8112bc2c:	88ffffc5 	stb	r3,-1(r17)
8112bc30:	d8c01e17 	ldw	r3,120(sp)
8112bc34:	88bfffc4 	addi	r2,r17,-1
8112bc38:	1023883a 	mov	r17,r2
8112bc3c:	1887c83a 	sub	r3,r3,r2
8112bc40:	d8c02115 	stw	r3,132(sp)
8112bc44:	003fc706 	br	8112bb64 <__reset+0xfb10bb64>
8112bc48:	dac02317 	ldw	r11,140(sp)
8112bc4c:	00c00044 	movi	r3,1
8112bc50:	d8c02015 	stw	r3,128(sp)
8112bc54:	58800017 	ldw	r2,0(r11)
8112bc58:	5ac00104 	addi	r11,r11,4
8112bc5c:	d8001d85 	stb	zero,118(sp)
8112bc60:	d8801005 	stb	r2,64(sp)
8112bc64:	dac02315 	stw	r11,140(sp)
8112bc68:	d8c02115 	stw	r3,132(sp)
8112bc6c:	dc401004 	addi	r17,sp,64
8112bc70:	0021883a 	mov	r16,zero
8112bc74:	90c0008c 	andi	r3,r18,2
8112bc78:	d8c02215 	stw	r3,136(sp)
8112bc7c:	18000326 	beq	r3,zero,8112bc8c <___svfiprintf_internal_r+0x5a0>
8112bc80:	dac02017 	ldw	r11,128(sp)
8112bc84:	5ac00084 	addi	r11,r11,2
8112bc88:	dac02015 	stw	r11,128(sp)
8112bc8c:	90c0210c 	andi	r3,r18,132
8112bc90:	d8c02615 	stw	r3,152(sp)
8112bc94:	1801131e 	bne	r3,zero,8112c0e4 <___svfiprintf_internal_r+0x9f8>
8112bc98:	dac02417 	ldw	r11,144(sp)
8112bc9c:	d8c02017 	ldw	r3,128(sp)
8112bca0:	58f9c83a 	sub	fp,r11,r3
8112bca4:	07010f0e 	bge	zero,fp,8112c0e4 <___svfiprintf_internal_r+0x9f8>
8112bca8:	02400404 	movi	r9,16
8112bcac:	d8c01c17 	ldw	r3,112(sp)
8112bcb0:	d8801b17 	ldw	r2,108(sp)
8112bcb4:	4f02d60e 	bge	r9,fp,8112c810 <___svfiprintf_internal_r+0x1124>
8112bcb8:	01604574 	movhi	r5,33045
8112bcbc:	29714104 	addi	r5,r5,-15100
8112bcc0:	d9402815 	stw	r5,160(sp)
8112bcc4:	028001c4 	movi	r10,7
8112bcc8:	00000306 	br	8112bcd8 <___svfiprintf_internal_r+0x5ec>
8112bccc:	e73ffc04 	addi	fp,fp,-16
8112bcd0:	42000204 	addi	r8,r8,8
8112bcd4:	4f00150e 	bge	r9,fp,8112bd2c <___svfiprintf_internal_r+0x640>
8112bcd8:	18c00404 	addi	r3,r3,16
8112bcdc:	10800044 	addi	r2,r2,1
8112bce0:	45800015 	stw	r22,0(r8)
8112bce4:	42400115 	stw	r9,4(r8)
8112bce8:	d8c01c15 	stw	r3,112(sp)
8112bcec:	d8801b15 	stw	r2,108(sp)
8112bcf0:	50bff60e 	bge	r10,r2,8112bccc <__reset+0xfb10bccc>
8112bcf4:	d9801a04 	addi	r6,sp,104
8112bcf8:	b80b883a 	mov	r5,r23
8112bcfc:	a809883a 	mov	r4,r21
8112bd00:	da402c15 	stw	r9,176(sp)
8112bd04:	da802d15 	stw	r10,180(sp)
8112bd08:	112b5140 	call	8112b514 <__ssprint_r>
8112bd0c:	da402c17 	ldw	r9,176(sp)
8112bd10:	da802d17 	ldw	r10,180(sp)
8112bd14:	1001851e 	bne	r2,zero,8112c32c <___svfiprintf_internal_r+0xc40>
8112bd18:	e73ffc04 	addi	fp,fp,-16
8112bd1c:	d8c01c17 	ldw	r3,112(sp)
8112bd20:	d8801b17 	ldw	r2,108(sp)
8112bd24:	d811883a 	mov	r8,sp
8112bd28:	4f3feb16 	blt	r9,fp,8112bcd8 <__reset+0xfb10bcd8>
8112bd2c:	dac02817 	ldw	r11,160(sp)
8112bd30:	e0c7883a 	add	r3,fp,r3
8112bd34:	10800044 	addi	r2,r2,1
8112bd38:	42c00015 	stw	r11,0(r8)
8112bd3c:	47000115 	stw	fp,4(r8)
8112bd40:	d8c01c15 	stw	r3,112(sp)
8112bd44:	d8801b15 	stw	r2,108(sp)
8112bd48:	010001c4 	movi	r4,7
8112bd4c:	2081ee16 	blt	r4,r2,8112c508 <___svfiprintf_internal_r+0xe1c>
8112bd50:	42000204 	addi	r8,r8,8
8112bd54:	0000e506 	br	8112c0ec <___svfiprintf_internal_r+0xa00>
8112bd58:	21003fcc 	andi	r4,r4,255
8112bd5c:	2002dd1e 	bne	r4,zero,8112c8d4 <___svfiprintf_internal_r+0x11e8>
8112bd60:	00a04574 	movhi	r2,33045
8112bd64:	10b0ae04 	addi	r2,r2,-15688
8112bd68:	d8802915 	stw	r2,164(sp)
8112bd6c:	9080080c 	andi	r2,r18,32
8112bd70:	103f461e 	bne	r2,zero,8112ba8c <__reset+0xfb10ba8c>
8112bd74:	9080040c 	andi	r2,r18,16
8112bd78:	10022e1e 	bne	r2,zero,8112c634 <___svfiprintf_internal_r+0xf48>
8112bd7c:	9080100c 	andi	r2,r18,64
8112bd80:	dac02317 	ldw	r11,140(sp)
8112bd84:	10027326 	beq	r2,zero,8112c754 <___svfiprintf_internal_r+0x1068>
8112bd88:	5f00000b 	ldhu	fp,0(r11)
8112bd8c:	5ac00104 	addi	r11,r11,4
8112bd90:	0013883a 	mov	r9,zero
8112bd94:	dac02315 	stw	r11,140(sp)
8112bd98:	003f4106 	br	8112baa0 <__reset+0xfb10baa0>
8112bd9c:	21003fcc 	andi	r4,r4,255
8112bda0:	2002e11e 	bne	r4,zero,8112c928 <___svfiprintf_internal_r+0x123c>
8112bda4:	9080080c 	andi	r2,r18,32
8112bda8:	1002011e 	bne	r2,zero,8112c5b0 <___svfiprintf_internal_r+0xec4>
8112bdac:	9080040c 	andi	r2,r18,16
8112bdb0:	10023e1e 	bne	r2,zero,8112c6ac <___svfiprintf_internal_r+0xfc0>
8112bdb4:	9480100c 	andi	r18,r18,64
8112bdb8:	90023c26 	beq	r18,zero,8112c6ac <___svfiprintf_internal_r+0xfc0>
8112bdbc:	dac02317 	ldw	r11,140(sp)
8112bdc0:	58800017 	ldw	r2,0(r11)
8112bdc4:	5ac00104 	addi	r11,r11,4
8112bdc8:	dac02315 	stw	r11,140(sp)
8112bdcc:	dac02517 	ldw	r11,148(sp)
8112bdd0:	12c0000d 	sth	r11,0(r2)
8112bdd4:	003e6e06 	br	8112b790 <__reset+0xfb10b790>
8112bdd8:	98c00007 	ldb	r3,0(r19)
8112bddc:	1a422926 	beq	r3,r9,8112c684 <___svfiprintf_internal_r+0xf98>
8112bde0:	94800414 	ori	r18,r18,16
8112bde4:	003e9206 	br	8112b830 <__reset+0xfb10b830>
8112bde8:	94801014 	ori	r18,r18,64
8112bdec:	98c00007 	ldb	r3,0(r19)
8112bdf0:	003e8f06 	br	8112b830 <__reset+0xfb10b830>
8112bdf4:	21003fcc 	andi	r4,r4,255
8112bdf8:	2002c71e 	bne	r4,zero,8112c918 <___svfiprintf_internal_r+0x122c>
8112bdfc:	9080080c 	andi	r2,r18,32
8112be00:	10004926 	beq	r2,zero,8112bf28 <___svfiprintf_internal_r+0x83c>
8112be04:	dac02317 	ldw	r11,140(sp)
8112be08:	58800117 	ldw	r2,4(r11)
8112be0c:	5f000017 	ldw	fp,0(r11)
8112be10:	5ac00204 	addi	r11,r11,8
8112be14:	dac02315 	stw	r11,140(sp)
8112be18:	1013883a 	mov	r9,r2
8112be1c:	10004b16 	blt	r2,zero,8112bf4c <___svfiprintf_internal_r+0x860>
8112be20:	da801d83 	ldbu	r10,118(sp)
8112be24:	8001cb16 	blt	r16,zero,8112c554 <___svfiprintf_internal_r+0xe68>
8112be28:	00ffdfc4 	movi	r3,-129
8112be2c:	e244b03a 	or	r2,fp,r9
8112be30:	90e4703a 	and	r18,r18,r3
8112be34:	103f4726 	beq	r2,zero,8112bb54 <__reset+0xfb10bb54>
8112be38:	48008c26 	beq	r9,zero,8112c06c <___svfiprintf_internal_r+0x980>
8112be3c:	dc802015 	stw	r18,128(sp)
8112be40:	dc002115 	stw	r16,132(sp)
8112be44:	dc401a04 	addi	r17,sp,104
8112be48:	e021883a 	mov	r16,fp
8112be4c:	da002215 	stw	r8,136(sp)
8112be50:	5039883a 	mov	fp,r10
8112be54:	4825883a 	mov	r18,r9
8112be58:	8009883a 	mov	r4,r16
8112be5c:	900b883a 	mov	r5,r18
8112be60:	01800284 	movi	r6,10
8112be64:	000f883a 	mov	r7,zero
8112be68:	112fa780 	call	8112fa78 <__umoddi3>
8112be6c:	10800c04 	addi	r2,r2,48
8112be70:	8c7fffc4 	addi	r17,r17,-1
8112be74:	8009883a 	mov	r4,r16
8112be78:	900b883a 	mov	r5,r18
8112be7c:	88800005 	stb	r2,0(r17)
8112be80:	01800284 	movi	r6,10
8112be84:	000f883a 	mov	r7,zero
8112be88:	112f4f80 	call	8112f4f8 <__udivdi3>
8112be8c:	1021883a 	mov	r16,r2
8112be90:	10c4b03a 	or	r2,r2,r3
8112be94:	1825883a 	mov	r18,r3
8112be98:	103fef1e 	bne	r2,zero,8112be58 <__reset+0xfb10be58>
8112be9c:	dc802017 	ldw	r18,128(sp)
8112bea0:	dc002117 	ldw	r16,132(sp)
8112bea4:	da002217 	ldw	r8,136(sp)
8112bea8:	e015883a 	mov	r10,fp
8112beac:	d8c01e17 	ldw	r3,120(sp)
8112beb0:	1c47c83a 	sub	r3,r3,r17
8112beb4:	d8c02115 	stw	r3,132(sp)
8112beb8:	003f2a06 	br	8112bb64 <__reset+0xfb10bb64>
8112bebc:	dac02317 	ldw	r11,140(sp)
8112bec0:	d8001d85 	stb	zero,118(sp)
8112bec4:	5c400017 	ldw	r17,0(r11)
8112bec8:	5f000104 	addi	fp,r11,4
8112becc:	88022f26 	beq	r17,zero,8112c78c <___svfiprintf_internal_r+0x10a0>
8112bed0:	80022516 	blt	r16,zero,8112c768 <___svfiprintf_internal_r+0x107c>
8112bed4:	800d883a 	mov	r6,r16
8112bed8:	000b883a 	mov	r5,zero
8112bedc:	8809883a 	mov	r4,r17
8112bee0:	da002c15 	stw	r8,176(sp)
8112bee4:	1127ab80 	call	81127ab8 <memchr>
8112bee8:	da002c17 	ldw	r8,176(sp)
8112beec:	10026426 	beq	r2,zero,8112c880 <___svfiprintf_internal_r+0x1194>
8112bef0:	1445c83a 	sub	r2,r2,r17
8112bef4:	d8802115 	stw	r2,132(sp)
8112bef8:	da801d83 	ldbu	r10,118(sp)
8112befc:	df002315 	stw	fp,140(sp)
8112bf00:	0021883a 	mov	r16,zero
8112bf04:	003f1706 	br	8112bb64 <__reset+0xfb10bb64>
8112bf08:	94800814 	ori	r18,r18,32
8112bf0c:	98c00007 	ldb	r3,0(r19)
8112bf10:	003e4706 	br	8112b830 <__reset+0xfb10b830>
8112bf14:	21003fcc 	andi	r4,r4,255
8112bf18:	2002701e 	bne	r4,zero,8112c8dc <___svfiprintf_internal_r+0x11f0>
8112bf1c:	94800414 	ori	r18,r18,16
8112bf20:	9080080c 	andi	r2,r18,32
8112bf24:	103fb71e 	bne	r2,zero,8112be04 <__reset+0xfb10be04>
8112bf28:	9080040c 	andi	r2,r18,16
8112bf2c:	1001ab26 	beq	r2,zero,8112c5dc <___svfiprintf_internal_r+0xef0>
8112bf30:	dac02317 	ldw	r11,140(sp)
8112bf34:	5f000017 	ldw	fp,0(r11)
8112bf38:	5ac00104 	addi	r11,r11,4
8112bf3c:	dac02315 	stw	r11,140(sp)
8112bf40:	e013d7fa 	srai	r9,fp,31
8112bf44:	4805883a 	mov	r2,r9
8112bf48:	103fb50e 	bge	r2,zero,8112be20 <__reset+0xfb10be20>
8112bf4c:	0739c83a 	sub	fp,zero,fp
8112bf50:	02800b44 	movi	r10,45
8112bf54:	e004c03a 	cmpne	r2,fp,zero
8112bf58:	0253c83a 	sub	r9,zero,r9
8112bf5c:	da801d85 	stb	r10,118(sp)
8112bf60:	4893c83a 	sub	r9,r9,r2
8112bf64:	80023016 	blt	r16,zero,8112c828 <___svfiprintf_internal_r+0x113c>
8112bf68:	00bfdfc4 	movi	r2,-129
8112bf6c:	90a4703a 	and	r18,r18,r2
8112bf70:	483fb21e 	bne	r9,zero,8112be3c <__reset+0xfb10be3c>
8112bf74:	00003d06 	br	8112c06c <___svfiprintf_internal_r+0x980>
8112bf78:	9817883a 	mov	r11,r19
8112bf7c:	d8002415 	stw	zero,144(sp)
8112bf80:	18bff404 	addi	r2,r3,-48
8112bf84:	0019883a 	mov	r12,zero
8112bf88:	58c00007 	ldb	r3,0(r11)
8112bf8c:	630002a4 	muli	r12,r12,10
8112bf90:	9cc00044 	addi	r19,r19,1
8112bf94:	9817883a 	mov	r11,r19
8112bf98:	1319883a 	add	r12,r2,r12
8112bf9c:	18bff404 	addi	r2,r3,-48
8112bfa0:	30bff92e 	bgeu	r6,r2,8112bf88 <__reset+0xfb10bf88>
8112bfa4:	db002415 	stw	r12,144(sp)
8112bfa8:	18bff804 	addi	r2,r3,-32
8112bfac:	28be232e 	bgeu	r5,r2,8112b83c <__reset+0xfb10b83c>
8112bfb0:	21003fcc 	andi	r4,r4,255
8112bfb4:	20024b1e 	bne	r4,zero,8112c8e4 <___svfiprintf_internal_r+0x11f8>
8112bfb8:	1800d626 	beq	r3,zero,8112c314 <___svfiprintf_internal_r+0xc28>
8112bfbc:	02c00044 	movi	r11,1
8112bfc0:	dac02015 	stw	r11,128(sp)
8112bfc4:	d8c01005 	stb	r3,64(sp)
8112bfc8:	d8001d85 	stb	zero,118(sp)
8112bfcc:	dac02115 	stw	r11,132(sp)
8112bfd0:	dc401004 	addi	r17,sp,64
8112bfd4:	003f2606 	br	8112bc70 <__reset+0xfb10bc70>
8112bfd8:	94802014 	ori	r18,r18,128
8112bfdc:	98c00007 	ldb	r3,0(r19)
8112bfe0:	003e1306 	br	8112b830 <__reset+0xfb10b830>
8112bfe4:	98c00007 	ldb	r3,0(r19)
8112bfe8:	9ac00044 	addi	r11,r19,1
8112bfec:	1a822b26 	beq	r3,r10,8112c89c <___svfiprintf_internal_r+0x11b0>
8112bff0:	18bff404 	addi	r2,r3,-48
8112bff4:	0021883a 	mov	r16,zero
8112bff8:	30821e36 	bltu	r6,r2,8112c874 <___svfiprintf_internal_r+0x1188>
8112bffc:	58c00007 	ldb	r3,0(r11)
8112c000:	840002a4 	muli	r16,r16,10
8112c004:	5cc00044 	addi	r19,r11,1
8112c008:	9817883a 	mov	r11,r19
8112c00c:	80a1883a 	add	r16,r16,r2
8112c010:	18bff404 	addi	r2,r3,-48
8112c014:	30bff92e 	bgeu	r6,r2,8112bffc <__reset+0xfb10bffc>
8112c018:	803e060e 	bge	r16,zero,8112b834 <__reset+0xfb10b834>
8112c01c:	043fffc4 	movi	r16,-1
8112c020:	003e0406 	br	8112b834 <__reset+0xfb10b834>
8112c024:	21003fcc 	andi	r4,r4,255
8112c028:	2002371e 	bne	r4,zero,8112c908 <___svfiprintf_internal_r+0x121c>
8112c02c:	94800414 	ori	r18,r18,16
8112c030:	9080080c 	andi	r2,r18,32
8112c034:	103ebb1e 	bne	r2,zero,8112bb24 <__reset+0xfb10bb24>
8112c038:	9080040c 	andi	r2,r18,16
8112c03c:	10013b26 	beq	r2,zero,8112c52c <___svfiprintf_internal_r+0xe40>
8112c040:	dac02317 	ldw	r11,140(sp)
8112c044:	d8001d85 	stb	zero,118(sp)
8112c048:	0013883a 	mov	r9,zero
8112c04c:	58800104 	addi	r2,r11,4
8112c050:	5f000017 	ldw	fp,0(r11)
8112c054:	80013d16 	blt	r16,zero,8112c54c <___svfiprintf_internal_r+0xe60>
8112c058:	00ffdfc4 	movi	r3,-129
8112c05c:	d8802315 	stw	r2,140(sp)
8112c060:	90e4703a 	and	r18,r18,r3
8112c064:	0015883a 	mov	r10,zero
8112c068:	e03eba26 	beq	fp,zero,8112bb54 <__reset+0xfb10bb54>
8112c06c:	00800244 	movi	r2,9
8112c070:	173f7236 	bltu	r2,fp,8112be3c <__reset+0xfb10be3c>
8112c074:	dac02b17 	ldw	r11,172(sp)
8112c078:	e7000c04 	addi	fp,fp,48
8112c07c:	df0019c5 	stb	fp,103(sp)
8112c080:	dac02115 	stw	r11,132(sp)
8112c084:	dc4019c4 	addi	r17,sp,103
8112c088:	003eb606 	br	8112bb64 <__reset+0xfb10bb64>
8112c08c:	21003fcc 	andi	r4,r4,255
8112c090:	20021f1e 	bne	r4,zero,8112c910 <___svfiprintf_internal_r+0x1224>
8112c094:	94800414 	ori	r18,r18,16
8112c098:	9080080c 	andi	r2,r18,32
8112c09c:	103ec51e 	bne	r2,zero,8112bbb4 <__reset+0xfb10bbb4>
8112c0a0:	9080040c 	andi	r2,r18,16
8112c0a4:	10016926 	beq	r2,zero,8112c64c <___svfiprintf_internal_r+0xf60>
8112c0a8:	dac02317 	ldw	r11,140(sp)
8112c0ac:	d8001d85 	stb	zero,118(sp)
8112c0b0:	0013883a 	mov	r9,zero
8112c0b4:	58800104 	addi	r2,r11,4
8112c0b8:	5f000017 	ldw	fp,0(r11)
8112c0bc:	80016b16 	blt	r16,zero,8112c66c <___svfiprintf_internal_r+0xf80>
8112c0c0:	00ffdfc4 	movi	r3,-129
8112c0c4:	d8802315 	stw	r2,140(sp)
8112c0c8:	90e4703a 	and	r18,r18,r3
8112c0cc:	e03ec41e 	bne	fp,zero,8112bbe0 <__reset+0xfb10bbe0>
8112c0d0:	0015883a 	mov	r10,zero
8112c0d4:	8001c226 	beq	r16,zero,8112c7e0 <___svfiprintf_internal_r+0x10f4>
8112c0d8:	0039883a 	mov	fp,zero
8112c0dc:	0013883a 	mov	r9,zero
8112c0e0:	003ec006 	br	8112bbe4 <__reset+0xfb10bbe4>
8112c0e4:	d8c01c17 	ldw	r3,112(sp)
8112c0e8:	d8801b17 	ldw	r2,108(sp)
8112c0ec:	d9001d87 	ldb	r4,118(sp)
8112c0f0:	20000b26 	beq	r4,zero,8112c120 <___svfiprintf_internal_r+0xa34>
8112c0f4:	d9001d84 	addi	r4,sp,118
8112c0f8:	18c00044 	addi	r3,r3,1
8112c0fc:	10800044 	addi	r2,r2,1
8112c100:	41000015 	stw	r4,0(r8)
8112c104:	01000044 	movi	r4,1
8112c108:	41000115 	stw	r4,4(r8)
8112c10c:	d8c01c15 	stw	r3,112(sp)
8112c110:	d8801b15 	stw	r2,108(sp)
8112c114:	010001c4 	movi	r4,7
8112c118:	2080e116 	blt	r4,r2,8112c4a0 <___svfiprintf_internal_r+0xdb4>
8112c11c:	42000204 	addi	r8,r8,8
8112c120:	dac02217 	ldw	r11,136(sp)
8112c124:	58000b26 	beq	r11,zero,8112c154 <___svfiprintf_internal_r+0xa68>
8112c128:	d9001d04 	addi	r4,sp,116
8112c12c:	18c00084 	addi	r3,r3,2
8112c130:	10800044 	addi	r2,r2,1
8112c134:	41000015 	stw	r4,0(r8)
8112c138:	01000084 	movi	r4,2
8112c13c:	41000115 	stw	r4,4(r8)
8112c140:	d8c01c15 	stw	r3,112(sp)
8112c144:	d8801b15 	stw	r2,108(sp)
8112c148:	010001c4 	movi	r4,7
8112c14c:	2080dd16 	blt	r4,r2,8112c4c4 <___svfiprintf_internal_r+0xdd8>
8112c150:	42000204 	addi	r8,r8,8
8112c154:	dac02617 	ldw	r11,152(sp)
8112c158:	01002004 	movi	r4,128
8112c15c:	59008426 	beq	r11,r4,8112c370 <___svfiprintf_internal_r+0xc84>
8112c160:	dac02117 	ldw	r11,132(sp)
8112c164:	82e1c83a 	sub	r16,r16,r11
8112c168:	0400270e 	bge	zero,r16,8112c208 <___svfiprintf_internal_r+0xb1c>
8112c16c:	01c00404 	movi	r7,16
8112c170:	3c016a0e 	bge	r7,r16,8112c71c <___svfiprintf_internal_r+0x1030>
8112c174:	01604574 	movhi	r5,33045
8112c178:	29713d04 	addi	r5,r5,-15116
8112c17c:	d9402215 	stw	r5,136(sp)
8112c180:	070001c4 	movi	fp,7
8112c184:	00000306 	br	8112c194 <___svfiprintf_internal_r+0xaa8>
8112c188:	843ffc04 	addi	r16,r16,-16
8112c18c:	42000204 	addi	r8,r8,8
8112c190:	3c00130e 	bge	r7,r16,8112c1e0 <___svfiprintf_internal_r+0xaf4>
8112c194:	18c00404 	addi	r3,r3,16
8112c198:	10800044 	addi	r2,r2,1
8112c19c:	45000015 	stw	r20,0(r8)
8112c1a0:	41c00115 	stw	r7,4(r8)
8112c1a4:	d8c01c15 	stw	r3,112(sp)
8112c1a8:	d8801b15 	stw	r2,108(sp)
8112c1ac:	e0bff60e 	bge	fp,r2,8112c188 <__reset+0xfb10c188>
8112c1b0:	d9801a04 	addi	r6,sp,104
8112c1b4:	b80b883a 	mov	r5,r23
8112c1b8:	a809883a 	mov	r4,r21
8112c1bc:	d9c02c15 	stw	r7,176(sp)
8112c1c0:	112b5140 	call	8112b514 <__ssprint_r>
8112c1c4:	d9c02c17 	ldw	r7,176(sp)
8112c1c8:	1000581e 	bne	r2,zero,8112c32c <___svfiprintf_internal_r+0xc40>
8112c1cc:	843ffc04 	addi	r16,r16,-16
8112c1d0:	d8c01c17 	ldw	r3,112(sp)
8112c1d4:	d8801b17 	ldw	r2,108(sp)
8112c1d8:	d811883a 	mov	r8,sp
8112c1dc:	3c3fed16 	blt	r7,r16,8112c194 <__reset+0xfb10c194>
8112c1e0:	dac02217 	ldw	r11,136(sp)
8112c1e4:	1c07883a 	add	r3,r3,r16
8112c1e8:	10800044 	addi	r2,r2,1
8112c1ec:	42c00015 	stw	r11,0(r8)
8112c1f0:	44000115 	stw	r16,4(r8)
8112c1f4:	d8c01c15 	stw	r3,112(sp)
8112c1f8:	d8801b15 	stw	r2,108(sp)
8112c1fc:	010001c4 	movi	r4,7
8112c200:	20809e16 	blt	r4,r2,8112c47c <___svfiprintf_internal_r+0xd90>
8112c204:	42000204 	addi	r8,r8,8
8112c208:	dac02117 	ldw	r11,132(sp)
8112c20c:	10800044 	addi	r2,r2,1
8112c210:	44400015 	stw	r17,0(r8)
8112c214:	58c7883a 	add	r3,r11,r3
8112c218:	42c00115 	stw	r11,4(r8)
8112c21c:	d8c01c15 	stw	r3,112(sp)
8112c220:	d8801b15 	stw	r2,108(sp)
8112c224:	010001c4 	movi	r4,7
8112c228:	20807f16 	blt	r4,r2,8112c428 <___svfiprintf_internal_r+0xd3c>
8112c22c:	42000204 	addi	r8,r8,8
8112c230:	9480010c 	andi	r18,r18,4
8112c234:	90002926 	beq	r18,zero,8112c2dc <___svfiprintf_internal_r+0xbf0>
8112c238:	dac02417 	ldw	r11,144(sp)
8112c23c:	d8802017 	ldw	r2,128(sp)
8112c240:	58a1c83a 	sub	r16,r11,r2
8112c244:	0400250e 	bge	zero,r16,8112c2dc <___svfiprintf_internal_r+0xbf0>
8112c248:	04400404 	movi	r17,16
8112c24c:	d8801b17 	ldw	r2,108(sp)
8112c250:	8c017c0e 	bge	r17,r16,8112c844 <___svfiprintf_internal_r+0x1158>
8112c254:	01604574 	movhi	r5,33045
8112c258:	29714104 	addi	r5,r5,-15100
8112c25c:	d9402815 	stw	r5,160(sp)
8112c260:	048001c4 	movi	r18,7
8112c264:	00000306 	br	8112c274 <___svfiprintf_internal_r+0xb88>
8112c268:	843ffc04 	addi	r16,r16,-16
8112c26c:	42000204 	addi	r8,r8,8
8112c270:	8c00110e 	bge	r17,r16,8112c2b8 <___svfiprintf_internal_r+0xbcc>
8112c274:	18c00404 	addi	r3,r3,16
8112c278:	10800044 	addi	r2,r2,1
8112c27c:	45800015 	stw	r22,0(r8)
8112c280:	44400115 	stw	r17,4(r8)
8112c284:	d8c01c15 	stw	r3,112(sp)
8112c288:	d8801b15 	stw	r2,108(sp)
8112c28c:	90bff60e 	bge	r18,r2,8112c268 <__reset+0xfb10c268>
8112c290:	d9801a04 	addi	r6,sp,104
8112c294:	b80b883a 	mov	r5,r23
8112c298:	a809883a 	mov	r4,r21
8112c29c:	112b5140 	call	8112b514 <__ssprint_r>
8112c2a0:	1000221e 	bne	r2,zero,8112c32c <___svfiprintf_internal_r+0xc40>
8112c2a4:	843ffc04 	addi	r16,r16,-16
8112c2a8:	d8c01c17 	ldw	r3,112(sp)
8112c2ac:	d8801b17 	ldw	r2,108(sp)
8112c2b0:	d811883a 	mov	r8,sp
8112c2b4:	8c3fef16 	blt	r17,r16,8112c274 <__reset+0xfb10c274>
8112c2b8:	dac02817 	ldw	r11,160(sp)
8112c2bc:	1c07883a 	add	r3,r3,r16
8112c2c0:	10800044 	addi	r2,r2,1
8112c2c4:	42c00015 	stw	r11,0(r8)
8112c2c8:	44000115 	stw	r16,4(r8)
8112c2cc:	d8c01c15 	stw	r3,112(sp)
8112c2d0:	d8801b15 	stw	r2,108(sp)
8112c2d4:	010001c4 	movi	r4,7
8112c2d8:	2080aa16 	blt	r4,r2,8112c584 <___svfiprintf_internal_r+0xe98>
8112c2dc:	d8802417 	ldw	r2,144(sp)
8112c2e0:	dac02017 	ldw	r11,128(sp)
8112c2e4:	12c0010e 	bge	r2,r11,8112c2ec <___svfiprintf_internal_r+0xc00>
8112c2e8:	5805883a 	mov	r2,r11
8112c2ec:	dac02517 	ldw	r11,148(sp)
8112c2f0:	5897883a 	add	r11,r11,r2
8112c2f4:	dac02515 	stw	r11,148(sp)
8112c2f8:	1800531e 	bne	r3,zero,8112c448 <___svfiprintf_internal_r+0xd5c>
8112c2fc:	98800007 	ldb	r2,0(r19)
8112c300:	d8001b15 	stw	zero,108(sp)
8112c304:	d811883a 	mov	r8,sp
8112c308:	103d231e 	bne	r2,zero,8112b798 <__reset+0xfb10b798>
8112c30c:	9823883a 	mov	r17,r19
8112c310:	003d3906 	br	8112b7f8 <__reset+0xfb10b7f8>
8112c314:	d8801c17 	ldw	r2,112(sp)
8112c318:	10000426 	beq	r2,zero,8112c32c <___svfiprintf_internal_r+0xc40>
8112c31c:	d9402717 	ldw	r5,156(sp)
8112c320:	d9002a17 	ldw	r4,168(sp)
8112c324:	d9801a04 	addi	r6,sp,104
8112c328:	112b5140 	call	8112b514 <__ssprint_r>
8112c32c:	dac02717 	ldw	r11,156(sp)
8112c330:	d8802517 	ldw	r2,148(sp)
8112c334:	58c0030b 	ldhu	r3,12(r11)
8112c338:	18c0100c 	andi	r3,r3,64
8112c33c:	1801381e 	bne	r3,zero,8112c820 <___svfiprintf_internal_r+0x1134>
8112c340:	dfc03717 	ldw	ra,220(sp)
8112c344:	df003617 	ldw	fp,216(sp)
8112c348:	ddc03517 	ldw	r23,212(sp)
8112c34c:	dd803417 	ldw	r22,208(sp)
8112c350:	dd403317 	ldw	r21,204(sp)
8112c354:	dd003217 	ldw	r20,200(sp)
8112c358:	dcc03117 	ldw	r19,196(sp)
8112c35c:	dc803017 	ldw	r18,192(sp)
8112c360:	dc402f17 	ldw	r17,188(sp)
8112c364:	dc002e17 	ldw	r16,184(sp)
8112c368:	dec03804 	addi	sp,sp,224
8112c36c:	f800283a 	ret
8112c370:	dac02417 	ldw	r11,144(sp)
8112c374:	d9002017 	ldw	r4,128(sp)
8112c378:	5939c83a 	sub	fp,r11,r4
8112c37c:	073f780e 	bge	zero,fp,8112c160 <__reset+0xfb10c160>
8112c380:	02400404 	movi	r9,16
8112c384:	4f01370e 	bge	r9,fp,8112c864 <___svfiprintf_internal_r+0x1178>
8112c388:	02e04574 	movhi	r11,33045
8112c38c:	5af13d04 	addi	r11,r11,-15116
8112c390:	dac02215 	stw	r11,136(sp)
8112c394:	028001c4 	movi	r10,7
8112c398:	00000306 	br	8112c3a8 <___svfiprintf_internal_r+0xcbc>
8112c39c:	e73ffc04 	addi	fp,fp,-16
8112c3a0:	42000204 	addi	r8,r8,8
8112c3a4:	4f00150e 	bge	r9,fp,8112c3fc <___svfiprintf_internal_r+0xd10>
8112c3a8:	18c00404 	addi	r3,r3,16
8112c3ac:	10800044 	addi	r2,r2,1
8112c3b0:	45000015 	stw	r20,0(r8)
8112c3b4:	42400115 	stw	r9,4(r8)
8112c3b8:	d8c01c15 	stw	r3,112(sp)
8112c3bc:	d8801b15 	stw	r2,108(sp)
8112c3c0:	50bff60e 	bge	r10,r2,8112c39c <__reset+0xfb10c39c>
8112c3c4:	d9801a04 	addi	r6,sp,104
8112c3c8:	b80b883a 	mov	r5,r23
8112c3cc:	a809883a 	mov	r4,r21
8112c3d0:	da402c15 	stw	r9,176(sp)
8112c3d4:	da802d15 	stw	r10,180(sp)
8112c3d8:	112b5140 	call	8112b514 <__ssprint_r>
8112c3dc:	da402c17 	ldw	r9,176(sp)
8112c3e0:	da802d17 	ldw	r10,180(sp)
8112c3e4:	103fd11e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c3e8:	e73ffc04 	addi	fp,fp,-16
8112c3ec:	d8c01c17 	ldw	r3,112(sp)
8112c3f0:	d8801b17 	ldw	r2,108(sp)
8112c3f4:	d811883a 	mov	r8,sp
8112c3f8:	4f3feb16 	blt	r9,fp,8112c3a8 <__reset+0xfb10c3a8>
8112c3fc:	dac02217 	ldw	r11,136(sp)
8112c400:	1f07883a 	add	r3,r3,fp
8112c404:	10800044 	addi	r2,r2,1
8112c408:	42c00015 	stw	r11,0(r8)
8112c40c:	47000115 	stw	fp,4(r8)
8112c410:	d8c01c15 	stw	r3,112(sp)
8112c414:	d8801b15 	stw	r2,108(sp)
8112c418:	010001c4 	movi	r4,7
8112c41c:	2080b616 	blt	r4,r2,8112c6f8 <___svfiprintf_internal_r+0x100c>
8112c420:	42000204 	addi	r8,r8,8
8112c424:	003f4e06 	br	8112c160 <__reset+0xfb10c160>
8112c428:	d9801a04 	addi	r6,sp,104
8112c42c:	b80b883a 	mov	r5,r23
8112c430:	a809883a 	mov	r4,r21
8112c434:	112b5140 	call	8112b514 <__ssprint_r>
8112c438:	103fbc1e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c43c:	d8c01c17 	ldw	r3,112(sp)
8112c440:	d811883a 	mov	r8,sp
8112c444:	003f7a06 	br	8112c230 <__reset+0xfb10c230>
8112c448:	d9801a04 	addi	r6,sp,104
8112c44c:	b80b883a 	mov	r5,r23
8112c450:	a809883a 	mov	r4,r21
8112c454:	112b5140 	call	8112b514 <__ssprint_r>
8112c458:	103fa826 	beq	r2,zero,8112c2fc <__reset+0xfb10c2fc>
8112c45c:	003fb306 	br	8112c32c <__reset+0xfb10c32c>
8112c460:	d9801a04 	addi	r6,sp,104
8112c464:	b80b883a 	mov	r5,r23
8112c468:	a809883a 	mov	r4,r21
8112c46c:	112b5140 	call	8112b514 <__ssprint_r>
8112c470:	103fae1e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c474:	d811883a 	mov	r8,sp
8112c478:	003cdc06 	br	8112b7ec <__reset+0xfb10b7ec>
8112c47c:	d9801a04 	addi	r6,sp,104
8112c480:	b80b883a 	mov	r5,r23
8112c484:	a809883a 	mov	r4,r21
8112c488:	112b5140 	call	8112b514 <__ssprint_r>
8112c48c:	103fa71e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c490:	d8c01c17 	ldw	r3,112(sp)
8112c494:	d8801b17 	ldw	r2,108(sp)
8112c498:	d811883a 	mov	r8,sp
8112c49c:	003f5a06 	br	8112c208 <__reset+0xfb10c208>
8112c4a0:	d9801a04 	addi	r6,sp,104
8112c4a4:	b80b883a 	mov	r5,r23
8112c4a8:	a809883a 	mov	r4,r21
8112c4ac:	112b5140 	call	8112b514 <__ssprint_r>
8112c4b0:	103f9e1e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c4b4:	d8c01c17 	ldw	r3,112(sp)
8112c4b8:	d8801b17 	ldw	r2,108(sp)
8112c4bc:	d811883a 	mov	r8,sp
8112c4c0:	003f1706 	br	8112c120 <__reset+0xfb10c120>
8112c4c4:	d9801a04 	addi	r6,sp,104
8112c4c8:	b80b883a 	mov	r5,r23
8112c4cc:	a809883a 	mov	r4,r21
8112c4d0:	112b5140 	call	8112b514 <__ssprint_r>
8112c4d4:	103f951e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c4d8:	d8c01c17 	ldw	r3,112(sp)
8112c4dc:	d8801b17 	ldw	r2,108(sp)
8112c4e0:	d811883a 	mov	r8,sp
8112c4e4:	003f1b06 	br	8112c154 <__reset+0xfb10c154>
8112c4e8:	d8001d85 	stb	zero,118(sp)
8112c4ec:	80007b16 	blt	r16,zero,8112c6dc <___svfiprintf_internal_r+0xff0>
8112c4f0:	00ffdfc4 	movi	r3,-129
8112c4f4:	e244b03a 	or	r2,fp,r9
8112c4f8:	90e4703a 	and	r18,r18,r3
8112c4fc:	103d7026 	beq	r2,zero,8112bac0 <__reset+0xfb10bac0>
8112c500:	0015883a 	mov	r10,zero
8112c504:	003d7206 	br	8112bad0 <__reset+0xfb10bad0>
8112c508:	d9801a04 	addi	r6,sp,104
8112c50c:	b80b883a 	mov	r5,r23
8112c510:	a809883a 	mov	r4,r21
8112c514:	112b5140 	call	8112b514 <__ssprint_r>
8112c518:	103f841e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c51c:	d8c01c17 	ldw	r3,112(sp)
8112c520:	d8801b17 	ldw	r2,108(sp)
8112c524:	d811883a 	mov	r8,sp
8112c528:	003ef006 	br	8112c0ec <__reset+0xfb10c0ec>
8112c52c:	9080100c 	andi	r2,r18,64
8112c530:	d8001d85 	stb	zero,118(sp)
8112c534:	dac02317 	ldw	r11,140(sp)
8112c538:	10008126 	beq	r2,zero,8112c740 <___svfiprintf_internal_r+0x1054>
8112c53c:	58800104 	addi	r2,r11,4
8112c540:	5f00000b 	ldhu	fp,0(r11)
8112c544:	0013883a 	mov	r9,zero
8112c548:	803ec30e 	bge	r16,zero,8112c058 <__reset+0xfb10c058>
8112c54c:	d8802315 	stw	r2,140(sp)
8112c550:	0015883a 	mov	r10,zero
8112c554:	e244b03a 	or	r2,fp,r9
8112c558:	103e371e 	bne	r2,zero,8112be38 <__reset+0xfb10be38>
8112c55c:	00800044 	movi	r2,1
8112c560:	10803fcc 	andi	r2,r2,255
8112c564:	00c00044 	movi	r3,1
8112c568:	10c06126 	beq	r2,r3,8112c6f0 <___svfiprintf_internal_r+0x1004>
8112c56c:	00c00084 	movi	r3,2
8112c570:	10fd5526 	beq	r2,r3,8112bac8 <__reset+0xfb10bac8>
8112c574:	003ed806 	br	8112c0d8 <__reset+0xfb10c0d8>
8112c578:	d8802315 	stw	r2,140(sp)
8112c57c:	98c00007 	ldb	r3,0(r19)
8112c580:	003cab06 	br	8112b830 <__reset+0xfb10b830>
8112c584:	d9801a04 	addi	r6,sp,104
8112c588:	b80b883a 	mov	r5,r23
8112c58c:	a809883a 	mov	r4,r21
8112c590:	112b5140 	call	8112b514 <__ssprint_r>
8112c594:	103f651e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c598:	d8c01c17 	ldw	r3,112(sp)
8112c59c:	003f4f06 	br	8112c2dc <__reset+0xfb10c2dc>
8112c5a0:	00a04574 	movhi	r2,33045
8112c5a4:	10b0b304 	addi	r2,r2,-15668
8112c5a8:	d8802915 	stw	r2,164(sp)
8112c5ac:	003d4406 	br	8112bac0 <__reset+0xfb10bac0>
8112c5b0:	dac02317 	ldw	r11,140(sp)
8112c5b4:	58800017 	ldw	r2,0(r11)
8112c5b8:	dac02517 	ldw	r11,148(sp)
8112c5bc:	5807d7fa 	srai	r3,r11,31
8112c5c0:	dac02317 	ldw	r11,140(sp)
8112c5c4:	10c00115 	stw	r3,4(r2)
8112c5c8:	5ac00104 	addi	r11,r11,4
8112c5cc:	dac02315 	stw	r11,140(sp)
8112c5d0:	dac02517 	ldw	r11,148(sp)
8112c5d4:	12c00015 	stw	r11,0(r2)
8112c5d8:	003c6d06 	br	8112b790 <__reset+0xfb10b790>
8112c5dc:	9080100c 	andi	r2,r18,64
8112c5e0:	dac02317 	ldw	r11,140(sp)
8112c5e4:	103e5326 	beq	r2,zero,8112bf34 <__reset+0xfb10bf34>
8112c5e8:	5f00000f 	ldh	fp,0(r11)
8112c5ec:	5ac00104 	addi	r11,r11,4
8112c5f0:	dac02315 	stw	r11,140(sp)
8112c5f4:	e013d7fa 	srai	r9,fp,31
8112c5f8:	4805883a 	mov	r2,r9
8112c5fc:	003e0706 	br	8112be1c <__reset+0xfb10be1c>
8112c600:	00800c04 	movi	r2,48
8112c604:	d8801d05 	stb	r2,116(sp)
8112c608:	d8c01d45 	stb	r3,117(sp)
8112c60c:	d8001d85 	stb	zero,118(sp)
8112c610:	90800094 	ori	r2,r18,2
8112c614:	80008f16 	blt	r16,zero,8112c854 <___svfiprintf_internal_r+0x1168>
8112c618:	00bfdfc4 	movi	r2,-129
8112c61c:	90a4703a 	and	r18,r18,r2
8112c620:	94800094 	ori	r18,r18,2
8112c624:	0015883a 	mov	r10,zero
8112c628:	003d2906 	br	8112bad0 <__reset+0xfb10bad0>
8112c62c:	98c00007 	ldb	r3,0(r19)
8112c630:	003c7f06 	br	8112b830 <__reset+0xfb10b830>
8112c634:	dac02317 	ldw	r11,140(sp)
8112c638:	0013883a 	mov	r9,zero
8112c63c:	5f000017 	ldw	fp,0(r11)
8112c640:	5ac00104 	addi	r11,r11,4
8112c644:	dac02315 	stw	r11,140(sp)
8112c648:	003d1506 	br	8112baa0 <__reset+0xfb10baa0>
8112c64c:	9080100c 	andi	r2,r18,64
8112c650:	d8001d85 	stb	zero,118(sp)
8112c654:	dac02317 	ldw	r11,140(sp)
8112c658:	10003426 	beq	r2,zero,8112c72c <___svfiprintf_internal_r+0x1040>
8112c65c:	58800104 	addi	r2,r11,4
8112c660:	5f00000b 	ldhu	fp,0(r11)
8112c664:	0013883a 	mov	r9,zero
8112c668:	803e950e 	bge	r16,zero,8112c0c0 <__reset+0xfb10c0c0>
8112c66c:	e246b03a 	or	r3,fp,r9
8112c670:	d8802315 	stw	r2,140(sp)
8112c674:	183d5a1e 	bne	r3,zero,8112bbe0 <__reset+0xfb10bbe0>
8112c678:	0015883a 	mov	r10,zero
8112c67c:	0005883a 	mov	r2,zero
8112c680:	003fb706 	br	8112c560 <__reset+0xfb10c560>
8112c684:	98c00043 	ldbu	r3,1(r19)
8112c688:	94800814 	ori	r18,r18,32
8112c68c:	9cc00044 	addi	r19,r19,1
8112c690:	18c03fcc 	andi	r3,r3,255
8112c694:	18c0201c 	xori	r3,r3,128
8112c698:	18ffe004 	addi	r3,r3,-128
8112c69c:	003c6406 	br	8112b830 <__reset+0xfb10b830>
8112c6a0:	d8c02315 	stw	r3,140(sp)
8112c6a4:	0015883a 	mov	r10,zero
8112c6a8:	003faa06 	br	8112c554 <__reset+0xfb10c554>
8112c6ac:	dac02317 	ldw	r11,140(sp)
8112c6b0:	58800017 	ldw	r2,0(r11)
8112c6b4:	5ac00104 	addi	r11,r11,4
8112c6b8:	dac02315 	stw	r11,140(sp)
8112c6bc:	dac02517 	ldw	r11,148(sp)
8112c6c0:	12c00015 	stw	r11,0(r2)
8112c6c4:	003c3206 	br	8112b790 <__reset+0xfb10b790>
8112c6c8:	01204574 	movhi	r4,33045
8112c6cc:	2130b304 	addi	r4,r4,-15668
8112c6d0:	d9002915 	stw	r4,164(sp)
8112c6d4:	d8c02315 	stw	r3,140(sp)
8112c6d8:	1025883a 	mov	r18,r2
8112c6dc:	e244b03a 	or	r2,fp,r9
8112c6e0:	103f871e 	bne	r2,zero,8112c500 <__reset+0xfb10c500>
8112c6e4:	0015883a 	mov	r10,zero
8112c6e8:	00800084 	movi	r2,2
8112c6ec:	003f9c06 	br	8112c560 <__reset+0xfb10c560>
8112c6f0:	0039883a 	mov	fp,zero
8112c6f4:	003e5f06 	br	8112c074 <__reset+0xfb10c074>
8112c6f8:	d9801a04 	addi	r6,sp,104
8112c6fc:	b80b883a 	mov	r5,r23
8112c700:	a809883a 	mov	r4,r21
8112c704:	112b5140 	call	8112b514 <__ssprint_r>
8112c708:	103f081e 	bne	r2,zero,8112c32c <__reset+0xfb10c32c>
8112c70c:	d8c01c17 	ldw	r3,112(sp)
8112c710:	d8801b17 	ldw	r2,108(sp)
8112c714:	d811883a 	mov	r8,sp
8112c718:	003e9106 	br	8112c160 <__reset+0xfb10c160>
8112c71c:	01204574 	movhi	r4,33045
8112c720:	21313d04 	addi	r4,r4,-15116
8112c724:	d9002215 	stw	r4,136(sp)
8112c728:	003ead06 	br	8112c1e0 <__reset+0xfb10c1e0>
8112c72c:	58800104 	addi	r2,r11,4
8112c730:	5f000017 	ldw	fp,0(r11)
8112c734:	0013883a 	mov	r9,zero
8112c738:	803e610e 	bge	r16,zero,8112c0c0 <__reset+0xfb10c0c0>
8112c73c:	003fcb06 	br	8112c66c <__reset+0xfb10c66c>
8112c740:	58800104 	addi	r2,r11,4
8112c744:	5f000017 	ldw	fp,0(r11)
8112c748:	0013883a 	mov	r9,zero
8112c74c:	803e420e 	bge	r16,zero,8112c058 <__reset+0xfb10c058>
8112c750:	003f7e06 	br	8112c54c <__reset+0xfb10c54c>
8112c754:	5f000017 	ldw	fp,0(r11)
8112c758:	5ac00104 	addi	r11,r11,4
8112c75c:	0013883a 	mov	r9,zero
8112c760:	dac02315 	stw	r11,140(sp)
8112c764:	003cce06 	br	8112baa0 <__reset+0xfb10baa0>
8112c768:	8809883a 	mov	r4,r17
8112c76c:	da002c15 	stw	r8,176(sp)
8112c770:	111e5bc0 	call	8111e5bc <strlen>
8112c774:	d8802115 	stw	r2,132(sp)
8112c778:	da801d83 	ldbu	r10,118(sp)
8112c77c:	df002315 	stw	fp,140(sp)
8112c780:	0021883a 	mov	r16,zero
8112c784:	da002c17 	ldw	r8,176(sp)
8112c788:	003cf606 	br	8112bb64 <__reset+0xfb10bb64>
8112c78c:	00800184 	movi	r2,6
8112c790:	1400012e 	bgeu	r2,r16,8112c798 <___svfiprintf_internal_r+0x10ac>
8112c794:	1021883a 	mov	r16,r2
8112c798:	dc002115 	stw	r16,132(sp)
8112c79c:	8005883a 	mov	r2,r16
8112c7a0:	80003c16 	blt	r16,zero,8112c894 <___svfiprintf_internal_r+0x11a8>
8112c7a4:	04604574 	movhi	r17,33045
8112c7a8:	d8802015 	stw	r2,128(sp)
8112c7ac:	df002315 	stw	fp,140(sp)
8112c7b0:	8c70b804 	addi	r17,r17,-15648
8112c7b4:	003d2e06 	br	8112bc70 <__reset+0xfb10bc70>
8112c7b8:	04001004 	movi	r16,64
8112c7bc:	800b883a 	mov	r5,r16
8112c7c0:	111d2b40 	call	8111d2b4 <_malloc_r>
8112c7c4:	dac02717 	ldw	r11,156(sp)
8112c7c8:	58800015 	stw	r2,0(r11)
8112c7cc:	58800415 	stw	r2,16(r11)
8112c7d0:	10004826 	beq	r2,zero,8112c8f4 <___svfiprintf_internal_r+0x1208>
8112c7d4:	dac02717 	ldw	r11,156(sp)
8112c7d8:	5c000515 	stw	r16,20(r11)
8112c7dc:	003bd906 	br	8112b744 <__reset+0xfb10b744>
8112c7e0:	9080004c 	andi	r2,r18,1
8112c7e4:	0015883a 	mov	r10,zero
8112c7e8:	10000626 	beq	r2,zero,8112c804 <___svfiprintf_internal_r+0x1118>
8112c7ec:	dac02b17 	ldw	r11,172(sp)
8112c7f0:	00800c04 	movi	r2,48
8112c7f4:	d88019c5 	stb	r2,103(sp)
8112c7f8:	dac02115 	stw	r11,132(sp)
8112c7fc:	dc4019c4 	addi	r17,sp,103
8112c800:	003cd806 	br	8112bb64 <__reset+0xfb10bb64>
8112c804:	d8002115 	stw	zero,132(sp)
8112c808:	dc401a04 	addi	r17,sp,104
8112c80c:	003cd506 	br	8112bb64 <__reset+0xfb10bb64>
8112c810:	01204574 	movhi	r4,33045
8112c814:	21314104 	addi	r4,r4,-15100
8112c818:	d9002815 	stw	r4,160(sp)
8112c81c:	003d4306 	br	8112bd2c <__reset+0xfb10bd2c>
8112c820:	00bfffc4 	movi	r2,-1
8112c824:	003ec606 	br	8112c340 <__reset+0xfb10c340>
8112c828:	00800044 	movi	r2,1
8112c82c:	10803fcc 	andi	r2,r2,255
8112c830:	00c00044 	movi	r3,1
8112c834:	10fd8026 	beq	r2,r3,8112be38 <__reset+0xfb10be38>
8112c838:	00c00084 	movi	r3,2
8112c83c:	10fca426 	beq	r2,r3,8112bad0 <__reset+0xfb10bad0>
8112c840:	003ce806 	br	8112bbe4 <__reset+0xfb10bbe4>
8112c844:	01204574 	movhi	r4,33045
8112c848:	21314104 	addi	r4,r4,-15100
8112c84c:	d9002815 	stw	r4,160(sp)
8112c850:	003e9906 	br	8112c2b8 <__reset+0xfb10c2b8>
8112c854:	1025883a 	mov	r18,r2
8112c858:	0015883a 	mov	r10,zero
8112c85c:	00800084 	movi	r2,2
8112c860:	003ff206 	br	8112c82c <__reset+0xfb10c82c>
8112c864:	01604574 	movhi	r5,33045
8112c868:	29713d04 	addi	r5,r5,-15116
8112c86c:	d9402215 	stw	r5,136(sp)
8112c870:	003ee206 	br	8112c3fc <__reset+0xfb10c3fc>
8112c874:	5827883a 	mov	r19,r11
8112c878:	0021883a 	mov	r16,zero
8112c87c:	003bed06 	br	8112b834 <__reset+0xfb10b834>
8112c880:	dc002115 	stw	r16,132(sp)
8112c884:	da801d83 	ldbu	r10,118(sp)
8112c888:	df002315 	stw	fp,140(sp)
8112c88c:	0021883a 	mov	r16,zero
8112c890:	003cb406 	br	8112bb64 <__reset+0xfb10bb64>
8112c894:	0005883a 	mov	r2,zero
8112c898:	003fc206 	br	8112c7a4 <__reset+0xfb10c7a4>
8112c89c:	d8802317 	ldw	r2,140(sp)
8112c8a0:	98c00043 	ldbu	r3,1(r19)
8112c8a4:	5827883a 	mov	r19,r11
8112c8a8:	14000017 	ldw	r16,0(r2)
8112c8ac:	10800104 	addi	r2,r2,4
8112c8b0:	d8802315 	stw	r2,140(sp)
8112c8b4:	803f760e 	bge	r16,zero,8112c690 <__reset+0xfb10c690>
8112c8b8:	18c03fcc 	andi	r3,r3,255
8112c8bc:	18c0201c 	xori	r3,r3,128
8112c8c0:	043fffc4 	movi	r16,-1
8112c8c4:	18ffe004 	addi	r3,r3,-128
8112c8c8:	003bd906 	br	8112b830 <__reset+0xfb10b830>
8112c8cc:	d9c01d85 	stb	r7,118(sp)
8112c8d0:	003cb606 	br	8112bbac <__reset+0xfb10bbac>
8112c8d4:	d9c01d85 	stb	r7,118(sp)
8112c8d8:	003d2106 	br	8112bd60 <__reset+0xfb10bd60>
8112c8dc:	d9c01d85 	stb	r7,118(sp)
8112c8e0:	003d8e06 	br	8112bf1c <__reset+0xfb10bf1c>
8112c8e4:	d9c01d85 	stb	r7,118(sp)
8112c8e8:	003db306 	br	8112bfb8 <__reset+0xfb10bfb8>
8112c8ec:	d9c01d85 	stb	r7,118(sp)
8112c8f0:	003c8a06 	br	8112bb1c <__reset+0xfb10bb1c>
8112c8f4:	dac02a17 	ldw	r11,168(sp)
8112c8f8:	00800304 	movi	r2,12
8112c8fc:	58800015 	stw	r2,0(r11)
8112c900:	00bfffc4 	movi	r2,-1
8112c904:	003e8e06 	br	8112c340 <__reset+0xfb10c340>
8112c908:	d9c01d85 	stb	r7,118(sp)
8112c90c:	003dc706 	br	8112c02c <__reset+0xfb10c02c>
8112c910:	d9c01d85 	stb	r7,118(sp)
8112c914:	003ddf06 	br	8112c094 <__reset+0xfb10c094>
8112c918:	d9c01d85 	stb	r7,118(sp)
8112c91c:	003d3706 	br	8112bdfc <__reset+0xfb10bdfc>
8112c920:	d9c01d85 	stb	r7,118(sp)
8112c924:	003c5406 	br	8112ba78 <__reset+0xfb10ba78>
8112c928:	d9c01d85 	stb	r7,118(sp)
8112c92c:	003d1d06 	br	8112bda4 <__reset+0xfb10bda4>

8112c930 <__submore>:
8112c930:	defffa04 	addi	sp,sp,-24
8112c934:	de00012e 	bgeu	sp,et,8112c93c <__submore+0xc>
8112c938:	003b68fa 	trap	3
8112c93c:	dc000015 	stw	r16,0(sp)
8112c940:	2821883a 	mov	r16,r5
8112c944:	29400c17 	ldw	r5,48(r5)
8112c948:	dfc00515 	stw	ra,20(sp)
8112c94c:	dd000415 	stw	r20,16(sp)
8112c950:	dcc00315 	stw	r19,12(sp)
8112c954:	dc800215 	stw	r18,8(sp)
8112c958:	dc400115 	stw	r17,4(sp)
8112c95c:	80801004 	addi	r2,r16,64
8112c960:	28801726 	beq	r5,r2,8112c9c0 <__submore+0x90>
8112c964:	84400d17 	ldw	r17,52(r16)
8112c968:	8c67883a 	add	r19,r17,r17
8112c96c:	980d883a 	mov	r6,r19
8112c970:	1128dbc0 	call	81128dbc <_realloc_r>
8112c974:	1025883a 	mov	r18,r2
8112c978:	10002226 	beq	r2,zero,8112ca04 <__submore+0xd4>
8112c97c:	1469883a 	add	r20,r2,r17
8112c980:	880d883a 	mov	r6,r17
8112c984:	100b883a 	mov	r5,r2
8112c988:	a009883a 	mov	r4,r20
8112c98c:	111dac80 	call	8111dac8 <memcpy>
8112c990:	0005883a 	mov	r2,zero
8112c994:	85000015 	stw	r20,0(r16)
8112c998:	84800c15 	stw	r18,48(r16)
8112c99c:	84c00d15 	stw	r19,52(r16)
8112c9a0:	dfc00517 	ldw	ra,20(sp)
8112c9a4:	dd000417 	ldw	r20,16(sp)
8112c9a8:	dcc00317 	ldw	r19,12(sp)
8112c9ac:	dc800217 	ldw	r18,8(sp)
8112c9b0:	dc400117 	ldw	r17,4(sp)
8112c9b4:	dc000017 	ldw	r16,0(sp)
8112c9b8:	dec00604 	addi	sp,sp,24
8112c9bc:	f800283a 	ret
8112c9c0:	04410004 	movi	r17,1024
8112c9c4:	880b883a 	mov	r5,r17
8112c9c8:	111d2b40 	call	8111d2b4 <_malloc_r>
8112c9cc:	1007883a 	mov	r3,r2
8112c9d0:	10000c26 	beq	r2,zero,8112ca04 <__submore+0xd4>
8112c9d4:	80801083 	ldbu	r2,66(r16)
8112c9d8:	80c00c15 	stw	r3,48(r16)
8112c9dc:	84400d15 	stw	r17,52(r16)
8112c9e0:	1880ffc5 	stb	r2,1023(r3)
8112c9e4:	81401043 	ldbu	r5,65(r16)
8112c9e8:	1900ff44 	addi	r4,r3,1021
8112c9ec:	0005883a 	mov	r2,zero
8112c9f0:	1940ff85 	stb	r5,1022(r3)
8112c9f4:	81401003 	ldbu	r5,64(r16)
8112c9f8:	1940ff45 	stb	r5,1021(r3)
8112c9fc:	81000015 	stw	r4,0(r16)
8112ca00:	003fe706 	br	8112c9a0 <__reset+0xfb10c9a0>
8112ca04:	00bfffc4 	movi	r2,-1
8112ca08:	003fe506 	br	8112c9a0 <__reset+0xfb10c9a0>

8112ca0c <_ungetc_r>:
8112ca0c:	00bfffc4 	movi	r2,-1
8112ca10:	28806326 	beq	r5,r2,8112cba0 <_ungetc_r+0x194>
8112ca14:	defffb04 	addi	sp,sp,-20
8112ca18:	de00012e 	bgeu	sp,et,8112ca20 <_ungetc_r+0x14>
8112ca1c:	003b68fa 	trap	3
8112ca20:	dcc00315 	stw	r19,12(sp)
8112ca24:	dc400115 	stw	r17,4(sp)
8112ca28:	dc000015 	stw	r16,0(sp)
8112ca2c:	dfc00415 	stw	ra,16(sp)
8112ca30:	dc800215 	stw	r18,8(sp)
8112ca34:	2023883a 	mov	r17,r4
8112ca38:	3021883a 	mov	r16,r6
8112ca3c:	2827883a 	mov	r19,r5
8112ca40:	20000226 	beq	r4,zero,8112ca4c <_ungetc_r+0x40>
8112ca44:	20800e17 	ldw	r2,56(r4)
8112ca48:	10002e26 	beq	r2,zero,8112cb04 <_ungetc_r+0xf8>
8112ca4c:	80c0030b 	ldhu	r3,12(r16)
8112ca50:	1888000c 	andi	r2,r3,8192
8112ca54:	1000051e 	bne	r2,zero,8112ca6c <_ungetc_r+0x60>
8112ca58:	81001917 	ldw	r4,100(r16)
8112ca5c:	00b7ffc4 	movi	r2,-8193
8112ca60:	18c80014 	ori	r3,r3,8192
8112ca64:	2084703a 	and	r2,r4,r2
8112ca68:	80801915 	stw	r2,100(r16)
8112ca6c:	00bff7c4 	movi	r2,-33
8112ca70:	1884703a 	and	r2,r3,r2
8112ca74:	8080030d 	sth	r2,12(r16)
8112ca78:	1900010c 	andi	r4,r3,4
8112ca7c:	2000061e 	bne	r4,zero,8112ca98 <_ungetc_r+0x8c>
8112ca80:	1900040c 	andi	r4,r3,16
8112ca84:	20001d26 	beq	r4,zero,8112cafc <_ungetc_r+0xf0>
8112ca88:	18c0020c 	andi	r3,r3,8
8112ca8c:	1800331e 	bne	r3,zero,8112cb5c <_ungetc_r+0x150>
8112ca90:	10800114 	ori	r2,r2,4
8112ca94:	8080030d 	sth	r2,12(r16)
8112ca98:	80800c17 	ldw	r2,48(r16)
8112ca9c:	9c803fcc 	andi	r18,r19,255
8112caa0:	10001a26 	beq	r2,zero,8112cb0c <_ungetc_r+0x100>
8112caa4:	80c00117 	ldw	r3,4(r16)
8112caa8:	80800d17 	ldw	r2,52(r16)
8112caac:	18800f0e 	bge	r3,r2,8112caec <_ungetc_r+0xe0>
8112cab0:	80c00017 	ldw	r3,0(r16)
8112cab4:	9005883a 	mov	r2,r18
8112cab8:	193fffc4 	addi	r4,r3,-1
8112cabc:	81000015 	stw	r4,0(r16)
8112cac0:	1cffffc5 	stb	r19,-1(r3)
8112cac4:	80c00117 	ldw	r3,4(r16)
8112cac8:	18c00044 	addi	r3,r3,1
8112cacc:	80c00115 	stw	r3,4(r16)
8112cad0:	dfc00417 	ldw	ra,16(sp)
8112cad4:	dcc00317 	ldw	r19,12(sp)
8112cad8:	dc800217 	ldw	r18,8(sp)
8112cadc:	dc400117 	ldw	r17,4(sp)
8112cae0:	dc000017 	ldw	r16,0(sp)
8112cae4:	dec00504 	addi	sp,sp,20
8112cae8:	f800283a 	ret
8112caec:	800b883a 	mov	r5,r16
8112caf0:	8809883a 	mov	r4,r17
8112caf4:	112c9300 	call	8112c930 <__submore>
8112caf8:	103fed26 	beq	r2,zero,8112cab0 <__reset+0xfb10cab0>
8112cafc:	00bfffc4 	movi	r2,-1
8112cb00:	003ff306 	br	8112cad0 <__reset+0xfb10cad0>
8112cb04:	11268900 	call	81126890 <__sinit>
8112cb08:	003fd006 	br	8112ca4c <__reset+0xfb10ca4c>
8112cb0c:	80c00417 	ldw	r3,16(r16)
8112cb10:	80800017 	ldw	r2,0(r16)
8112cb14:	18000326 	beq	r3,zero,8112cb24 <_ungetc_r+0x118>
8112cb18:	1880022e 	bgeu	r3,r2,8112cb24 <_ungetc_r+0x118>
8112cb1c:	10ffffc3 	ldbu	r3,-1(r2)
8112cb20:	90c01826 	beq	r18,r3,8112cb84 <_ungetc_r+0x178>
8112cb24:	81400117 	ldw	r5,4(r16)
8112cb28:	80800e15 	stw	r2,56(r16)
8112cb2c:	008000c4 	movi	r2,3
8112cb30:	81001004 	addi	r4,r16,64
8112cb34:	80c01084 	addi	r3,r16,66
8112cb38:	80800d15 	stw	r2,52(r16)
8112cb3c:	00800044 	movi	r2,1
8112cb40:	80800115 	stw	r2,4(r16)
8112cb44:	81400f15 	stw	r5,60(r16)
8112cb48:	81000c15 	stw	r4,48(r16)
8112cb4c:	84c01085 	stb	r19,66(r16)
8112cb50:	80c00015 	stw	r3,0(r16)
8112cb54:	9005883a 	mov	r2,r18
8112cb58:	003fdd06 	br	8112cad0 <__reset+0xfb10cad0>
8112cb5c:	800b883a 	mov	r5,r16
8112cb60:	8809883a 	mov	r4,r17
8112cb64:	11264940 	call	81126494 <_fflush_r>
8112cb68:	103fe41e 	bne	r2,zero,8112cafc <__reset+0xfb10cafc>
8112cb6c:	8080030b 	ldhu	r2,12(r16)
8112cb70:	00fffdc4 	movi	r3,-9
8112cb74:	80000215 	stw	zero,8(r16)
8112cb78:	1884703a 	and	r2,r3,r2
8112cb7c:	80000615 	stw	zero,24(r16)
8112cb80:	003fc306 	br	8112ca90 <__reset+0xfb10ca90>
8112cb84:	80c00117 	ldw	r3,4(r16)
8112cb88:	10bfffc4 	addi	r2,r2,-1
8112cb8c:	80800015 	stw	r2,0(r16)
8112cb90:	18800044 	addi	r2,r3,1
8112cb94:	80800115 	stw	r2,4(r16)
8112cb98:	9005883a 	mov	r2,r18
8112cb9c:	003fcc06 	br	8112cad0 <__reset+0xfb10cad0>
8112cba0:	00bfffc4 	movi	r2,-1
8112cba4:	f800283a 	ret

8112cba8 <ungetc>:
8112cba8:	00a04574 	movhi	r2,33045
8112cbac:	10ba8204 	addi	r2,r2,-5624
8112cbb0:	280d883a 	mov	r6,r5
8112cbb4:	200b883a 	mov	r5,r4
8112cbb8:	11000017 	ldw	r4,0(r2)
8112cbbc:	112ca0c1 	jmpi	8112ca0c <_ungetc_r>

8112cbc0 <__sprint_r.part.0>:
8112cbc0:	defff604 	addi	sp,sp,-40
8112cbc4:	de00012e 	bgeu	sp,et,8112cbcc <__sprint_r.part.0+0xc>
8112cbc8:	003b68fa 	trap	3
8112cbcc:	28801917 	ldw	r2,100(r5)
8112cbd0:	dd400515 	stw	r21,20(sp)
8112cbd4:	dfc00915 	stw	ra,36(sp)
8112cbd8:	df000815 	stw	fp,32(sp)
8112cbdc:	ddc00715 	stw	r23,28(sp)
8112cbe0:	dd800615 	stw	r22,24(sp)
8112cbe4:	dd000415 	stw	r20,16(sp)
8112cbe8:	dcc00315 	stw	r19,12(sp)
8112cbec:	dc800215 	stw	r18,8(sp)
8112cbf0:	dc400115 	stw	r17,4(sp)
8112cbf4:	dc000015 	stw	r16,0(sp)
8112cbf8:	1088000c 	andi	r2,r2,8192
8112cbfc:	302b883a 	mov	r21,r6
8112cc00:	10002e26 	beq	r2,zero,8112ccbc <__sprint_r.part.0+0xfc>
8112cc04:	30800217 	ldw	r2,8(r6)
8112cc08:	35800017 	ldw	r22,0(r6)
8112cc0c:	10002926 	beq	r2,zero,8112ccb4 <__sprint_r.part.0+0xf4>
8112cc10:	2827883a 	mov	r19,r5
8112cc14:	2029883a 	mov	r20,r4
8112cc18:	b5c00104 	addi	r23,r22,4
8112cc1c:	04bfffc4 	movi	r18,-1
8112cc20:	bc400017 	ldw	r17,0(r23)
8112cc24:	b4000017 	ldw	r16,0(r22)
8112cc28:	0039883a 	mov	fp,zero
8112cc2c:	8822d0ba 	srli	r17,r17,2
8112cc30:	8800031e 	bne	r17,zero,8112cc40 <__sprint_r.part.0+0x80>
8112cc34:	00001806 	br	8112cc98 <__sprint_r.part.0+0xd8>
8112cc38:	84000104 	addi	r16,r16,4
8112cc3c:	8f001526 	beq	r17,fp,8112cc94 <__sprint_r.part.0+0xd4>
8112cc40:	81400017 	ldw	r5,0(r16)
8112cc44:	980d883a 	mov	r6,r19
8112cc48:	a009883a 	mov	r4,r20
8112cc4c:	112e5640 	call	8112e564 <_fputwc_r>
8112cc50:	e7000044 	addi	fp,fp,1
8112cc54:	14bff81e 	bne	r2,r18,8112cc38 <__reset+0xfb10cc38>
8112cc58:	9005883a 	mov	r2,r18
8112cc5c:	a8000215 	stw	zero,8(r21)
8112cc60:	a8000115 	stw	zero,4(r21)
8112cc64:	dfc00917 	ldw	ra,36(sp)
8112cc68:	df000817 	ldw	fp,32(sp)
8112cc6c:	ddc00717 	ldw	r23,28(sp)
8112cc70:	dd800617 	ldw	r22,24(sp)
8112cc74:	dd400517 	ldw	r21,20(sp)
8112cc78:	dd000417 	ldw	r20,16(sp)
8112cc7c:	dcc00317 	ldw	r19,12(sp)
8112cc80:	dc800217 	ldw	r18,8(sp)
8112cc84:	dc400117 	ldw	r17,4(sp)
8112cc88:	dc000017 	ldw	r16,0(sp)
8112cc8c:	dec00a04 	addi	sp,sp,40
8112cc90:	f800283a 	ret
8112cc94:	a8800217 	ldw	r2,8(r21)
8112cc98:	8c63883a 	add	r17,r17,r17
8112cc9c:	8c63883a 	add	r17,r17,r17
8112cca0:	1445c83a 	sub	r2,r2,r17
8112cca4:	a8800215 	stw	r2,8(r21)
8112cca8:	b5800204 	addi	r22,r22,8
8112ccac:	bdc00204 	addi	r23,r23,8
8112ccb0:	103fdb1e 	bne	r2,zero,8112cc20 <__reset+0xfb10cc20>
8112ccb4:	0005883a 	mov	r2,zero
8112ccb8:	003fe806 	br	8112cc5c <__reset+0xfb10cc5c>
8112ccbc:	11270400 	call	81127040 <__sfvwrite_r>
8112ccc0:	003fe606 	br	8112cc5c <__reset+0xfb10cc5c>

8112ccc4 <__sprint_r>:
8112ccc4:	30c00217 	ldw	r3,8(r6)
8112ccc8:	18000126 	beq	r3,zero,8112ccd0 <__sprint_r+0xc>
8112cccc:	112cbc01 	jmpi	8112cbc0 <__sprint_r.part.0>
8112ccd0:	30000115 	stw	zero,4(r6)
8112ccd4:	0005883a 	mov	r2,zero
8112ccd8:	f800283a 	ret

8112ccdc <___vfiprintf_internal_r>:
8112ccdc:	deffc904 	addi	sp,sp,-220
8112cce0:	de00012e 	bgeu	sp,et,8112cce8 <___vfiprintf_internal_r+0xc>
8112cce4:	003b68fa 	trap	3
8112cce8:	df003515 	stw	fp,212(sp)
8112ccec:	dd003115 	stw	r20,196(sp)
8112ccf0:	dfc03615 	stw	ra,216(sp)
8112ccf4:	ddc03415 	stw	r23,208(sp)
8112ccf8:	dd803315 	stw	r22,204(sp)
8112ccfc:	dd403215 	stw	r21,200(sp)
8112cd00:	dcc03015 	stw	r19,192(sp)
8112cd04:	dc802f15 	stw	r18,188(sp)
8112cd08:	dc402e15 	stw	r17,184(sp)
8112cd0c:	dc002d15 	stw	r16,180(sp)
8112cd10:	d9002015 	stw	r4,128(sp)
8112cd14:	d9c02215 	stw	r7,136(sp)
8112cd18:	2829883a 	mov	r20,r5
8112cd1c:	3039883a 	mov	fp,r6
8112cd20:	20000226 	beq	r4,zero,8112cd2c <___vfiprintf_internal_r+0x50>
8112cd24:	20800e17 	ldw	r2,56(r4)
8112cd28:	1000cf26 	beq	r2,zero,8112d068 <___vfiprintf_internal_r+0x38c>
8112cd2c:	a080030b 	ldhu	r2,12(r20)
8112cd30:	10c8000c 	andi	r3,r2,8192
8112cd34:	1800061e 	bne	r3,zero,8112cd50 <___vfiprintf_internal_r+0x74>
8112cd38:	a1001917 	ldw	r4,100(r20)
8112cd3c:	00f7ffc4 	movi	r3,-8193
8112cd40:	10880014 	ori	r2,r2,8192
8112cd44:	20c6703a 	and	r3,r4,r3
8112cd48:	a080030d 	sth	r2,12(r20)
8112cd4c:	a0c01915 	stw	r3,100(r20)
8112cd50:	10c0020c 	andi	r3,r2,8
8112cd54:	1800a926 	beq	r3,zero,8112cffc <___vfiprintf_internal_r+0x320>
8112cd58:	a0c00417 	ldw	r3,16(r20)
8112cd5c:	1800a726 	beq	r3,zero,8112cffc <___vfiprintf_internal_r+0x320>
8112cd60:	1080068c 	andi	r2,r2,26
8112cd64:	00c00284 	movi	r3,10
8112cd68:	10c0ac26 	beq	r2,r3,8112d01c <___vfiprintf_internal_r+0x340>
8112cd6c:	da801a04 	addi	r10,sp,104
8112cd70:	da801e15 	stw	r10,120(sp)
8112cd74:	d8801e17 	ldw	r2,120(sp)
8112cd78:	da8019c4 	addi	r10,sp,103
8112cd7c:	05a04574 	movhi	r22,33045
8112cd80:	05e04574 	movhi	r23,33045
8112cd84:	da801f15 	stw	r10,124(sp)
8112cd88:	1295c83a 	sub	r10,r2,r10
8112cd8c:	b5b14904 	addi	r22,r22,-15068
8112cd90:	bdf14504 	addi	r23,r23,-15084
8112cd94:	dec01a15 	stw	sp,104(sp)
8112cd98:	d8001c15 	stw	zero,112(sp)
8112cd9c:	d8001b15 	stw	zero,108(sp)
8112cda0:	d8002615 	stw	zero,152(sp)
8112cda4:	d8002315 	stw	zero,140(sp)
8112cda8:	da802715 	stw	r10,156(sp)
8112cdac:	d811883a 	mov	r8,sp
8112cdb0:	dd002115 	stw	r20,132(sp)
8112cdb4:	e021883a 	mov	r16,fp
8112cdb8:	80800007 	ldb	r2,0(r16)
8112cdbc:	1003ea26 	beq	r2,zero,8112dd68 <___vfiprintf_internal_r+0x108c>
8112cdc0:	00c00944 	movi	r3,37
8112cdc4:	8025883a 	mov	r18,r16
8112cdc8:	10c0021e 	bne	r2,r3,8112cdd4 <___vfiprintf_internal_r+0xf8>
8112cdcc:	00001606 	br	8112ce28 <___vfiprintf_internal_r+0x14c>
8112cdd0:	10c00326 	beq	r2,r3,8112cde0 <___vfiprintf_internal_r+0x104>
8112cdd4:	94800044 	addi	r18,r18,1
8112cdd8:	90800007 	ldb	r2,0(r18)
8112cddc:	103ffc1e 	bne	r2,zero,8112cdd0 <__reset+0xfb10cdd0>
8112cde0:	9423c83a 	sub	r17,r18,r16
8112cde4:	88001026 	beq	r17,zero,8112ce28 <___vfiprintf_internal_r+0x14c>
8112cde8:	d8c01c17 	ldw	r3,112(sp)
8112cdec:	d8801b17 	ldw	r2,108(sp)
8112cdf0:	44000015 	stw	r16,0(r8)
8112cdf4:	88c7883a 	add	r3,r17,r3
8112cdf8:	10800044 	addi	r2,r2,1
8112cdfc:	44400115 	stw	r17,4(r8)
8112ce00:	d8c01c15 	stw	r3,112(sp)
8112ce04:	d8801b15 	stw	r2,108(sp)
8112ce08:	010001c4 	movi	r4,7
8112ce0c:	2080760e 	bge	r4,r2,8112cfe8 <___vfiprintf_internal_r+0x30c>
8112ce10:	1803821e 	bne	r3,zero,8112dc1c <___vfiprintf_internal_r+0xf40>
8112ce14:	da802317 	ldw	r10,140(sp)
8112ce18:	d8001b15 	stw	zero,108(sp)
8112ce1c:	d811883a 	mov	r8,sp
8112ce20:	5455883a 	add	r10,r10,r17
8112ce24:	da802315 	stw	r10,140(sp)
8112ce28:	90800007 	ldb	r2,0(r18)
8112ce2c:	10044626 	beq	r2,zero,8112df48 <___vfiprintf_internal_r+0x126c>
8112ce30:	90c00047 	ldb	r3,1(r18)
8112ce34:	94000044 	addi	r16,r18,1
8112ce38:	d8001d85 	stb	zero,118(sp)
8112ce3c:	0009883a 	mov	r4,zero
8112ce40:	000f883a 	mov	r7,zero
8112ce44:	027fffc4 	movi	r9,-1
8112ce48:	0023883a 	mov	r17,zero
8112ce4c:	0029883a 	mov	r20,zero
8112ce50:	01401604 	movi	r5,88
8112ce54:	01800244 	movi	r6,9
8112ce58:	03400a84 	movi	r13,42
8112ce5c:	03001b04 	movi	r12,108
8112ce60:	84000044 	addi	r16,r16,1
8112ce64:	18bff804 	addi	r2,r3,-32
8112ce68:	28827336 	bltu	r5,r2,8112d838 <___vfiprintf_internal_r+0xb5c>
8112ce6c:	100490ba 	slli	r2,r2,2
8112ce70:	02a044f4 	movhi	r10,33043
8112ce74:	52b3a104 	addi	r10,r10,-12668
8112ce78:	1285883a 	add	r2,r2,r10
8112ce7c:	10800017 	ldw	r2,0(r2)
8112ce80:	1000683a 	jmp	r2
8112ce84:	8112d56c 	andhi	r4,r16,19285
8112ce88:	8112d838 	rdprs	r4,r16,19296
8112ce8c:	8112d838 	rdprs	r4,r16,19296
8112ce90:	8112d58c 	andi	r4,r16,19286
8112ce94:	8112d838 	rdprs	r4,r16,19296
8112ce98:	8112d838 	rdprs	r4,r16,19296
8112ce9c:	8112d838 	rdprs	r4,r16,19296
8112cea0:	8112d838 	rdprs	r4,r16,19296
8112cea4:	8112d838 	rdprs	r4,r16,19296
8112cea8:	8112d838 	rdprs	r4,r16,19296
8112ceac:	8112d774 	orhi	r4,r16,19293
8112ceb0:	8112d790 	cmplti	r4,r16,19294
8112ceb4:	8112d838 	rdprs	r4,r16,19296
8112ceb8:	8112d078 	rdprs	r4,r16,19265
8112cebc:	8112d7a0 	cmpeqi	r4,r16,19294
8112cec0:	8112d838 	rdprs	r4,r16,19296
8112cec4:	8112d598 	cmpnei	r4,r16,19286
8112cec8:	8112d5a4 	muli	r4,r16,19286
8112cecc:	8112d5a4 	muli	r4,r16,19286
8112ced0:	8112d5a4 	muli	r4,r16,19286
8112ced4:	8112d5a4 	muli	r4,r16,19286
8112ced8:	8112d5a4 	muli	r4,r16,19286
8112cedc:	8112d5a4 	muli	r4,r16,19286
8112cee0:	8112d5a4 	muli	r4,r16,19286
8112cee4:	8112d5a4 	muli	r4,r16,19286
8112cee8:	8112d5a4 	muli	r4,r16,19286
8112ceec:	8112d838 	rdprs	r4,r16,19296
8112cef0:	8112d838 	rdprs	r4,r16,19296
8112cef4:	8112d838 	rdprs	r4,r16,19296
8112cef8:	8112d838 	rdprs	r4,r16,19296
8112cefc:	8112d838 	rdprs	r4,r16,19296
8112cf00:	8112d838 	rdprs	r4,r16,19296
8112cf04:	8112d838 	rdprs	r4,r16,19296
8112cf08:	8112d838 	rdprs	r4,r16,19296
8112cf0c:	8112d838 	rdprs	r4,r16,19296
8112cf10:	8112d838 	rdprs	r4,r16,19296
8112cf14:	8112d5d0 	cmplti	r4,r16,19287
8112cf18:	8112d838 	rdprs	r4,r16,19296
8112cf1c:	8112d838 	rdprs	r4,r16,19296
8112cf20:	8112d838 	rdprs	r4,r16,19296
8112cf24:	8112d838 	rdprs	r4,r16,19296
8112cf28:	8112d838 	rdprs	r4,r16,19296
8112cf2c:	8112d838 	rdprs	r4,r16,19296
8112cf30:	8112d838 	rdprs	r4,r16,19296
8112cf34:	8112d838 	rdprs	r4,r16,19296
8112cf38:	8112d838 	rdprs	r4,r16,19296
8112cf3c:	8112d838 	rdprs	r4,r16,19296
8112cf40:	8112d608 	cmpgei	r4,r16,19288
8112cf44:	8112d838 	rdprs	r4,r16,19296
8112cf48:	8112d838 	rdprs	r4,r16,19296
8112cf4c:	8112d838 	rdprs	r4,r16,19296
8112cf50:	8112d838 	rdprs	r4,r16,19296
8112cf54:	8112d838 	rdprs	r4,r16,19296
8112cf58:	8112d660 	cmpeqi	r4,r16,19289
8112cf5c:	8112d838 	rdprs	r4,r16,19296
8112cf60:	8112d838 	rdprs	r4,r16,19296
8112cf64:	8112d6d0 	cmplti	r4,r16,19291
8112cf68:	8112d838 	rdprs	r4,r16,19296
8112cf6c:	8112d838 	rdprs	r4,r16,19296
8112cf70:	8112d838 	rdprs	r4,r16,19296
8112cf74:	8112d838 	rdprs	r4,r16,19296
8112cf78:	8112d838 	rdprs	r4,r16,19296
8112cf7c:	8112d838 	rdprs	r4,r16,19296
8112cf80:	8112d838 	rdprs	r4,r16,19296
8112cf84:	8112d838 	rdprs	r4,r16,19296
8112cf88:	8112d838 	rdprs	r4,r16,19296
8112cf8c:	8112d838 	rdprs	r4,r16,19296
8112cf90:	8112d47c 	xorhi	r4,r16,19281
8112cf94:	8112d4a8 	cmpgeui	r4,r16,19282
8112cf98:	8112d838 	rdprs	r4,r16,19296
8112cf9c:	8112d838 	rdprs	r4,r16,19296
8112cfa0:	8112d838 	rdprs	r4,r16,19296
8112cfa4:	8112d7e0 	cmpeqi	r4,r16,19295
8112cfa8:	8112d4a8 	cmpgeui	r4,r16,19282
8112cfac:	8112d838 	rdprs	r4,r16,19296
8112cfb0:	8112d838 	rdprs	r4,r16,19296
8112cfb4:	8112d33c 	xorhi	r4,r16,19276
8112cfb8:	8112d838 	rdprs	r4,r16,19296
8112cfbc:	8112d34c 	andi	r4,r16,19277
8112cfc0:	8112d388 	cmpgei	r4,r16,19278
8112cfc4:	8112d084 	addi	r4,r16,19266
8112cfc8:	8112d330 	cmpltui	r4,r16,19276
8112cfcc:	8112d838 	rdprs	r4,r16,19296
8112cfd0:	8112d70c 	andi	r4,r16,19292
8112cfd4:	8112d838 	rdprs	r4,r16,19296
8112cfd8:	8112d764 	muli	r4,r16,19293
8112cfdc:	8112d838 	rdprs	r4,r16,19296
8112cfe0:	8112d838 	rdprs	r4,r16,19296
8112cfe4:	8112d428 	cmpgeui	r4,r16,19280
8112cfe8:	42000204 	addi	r8,r8,8
8112cfec:	da802317 	ldw	r10,140(sp)
8112cff0:	5455883a 	add	r10,r10,r17
8112cff4:	da802315 	stw	r10,140(sp)
8112cff8:	003f8b06 	br	8112ce28 <__reset+0xfb10ce28>
8112cffc:	d9002017 	ldw	r4,128(sp)
8112d000:	a00b883a 	mov	r5,r20
8112d004:	11248200 	call	81124820 <__swsetup_r>
8112d008:	1003b11e 	bne	r2,zero,8112ded0 <___vfiprintf_internal_r+0x11f4>
8112d00c:	a080030b 	ldhu	r2,12(r20)
8112d010:	00c00284 	movi	r3,10
8112d014:	1080068c 	andi	r2,r2,26
8112d018:	10ff541e 	bne	r2,r3,8112cd6c <__reset+0xfb10cd6c>
8112d01c:	a080038f 	ldh	r2,14(r20)
8112d020:	103f5216 	blt	r2,zero,8112cd6c <__reset+0xfb10cd6c>
8112d024:	d9c02217 	ldw	r7,136(sp)
8112d028:	d9002017 	ldw	r4,128(sp)
8112d02c:	e00d883a 	mov	r6,fp
8112d030:	a00b883a 	mov	r5,r20
8112d034:	112e15c0 	call	8112e15c <__sbprintf>
8112d038:	dfc03617 	ldw	ra,216(sp)
8112d03c:	df003517 	ldw	fp,212(sp)
8112d040:	ddc03417 	ldw	r23,208(sp)
8112d044:	dd803317 	ldw	r22,204(sp)
8112d048:	dd403217 	ldw	r21,200(sp)
8112d04c:	dd003117 	ldw	r20,196(sp)
8112d050:	dcc03017 	ldw	r19,192(sp)
8112d054:	dc802f17 	ldw	r18,188(sp)
8112d058:	dc402e17 	ldw	r17,184(sp)
8112d05c:	dc002d17 	ldw	r16,180(sp)
8112d060:	dec03704 	addi	sp,sp,220
8112d064:	f800283a 	ret
8112d068:	11268900 	call	81126890 <__sinit>
8112d06c:	003f2f06 	br	8112cd2c <__reset+0xfb10cd2c>
8112d070:	0463c83a 	sub	r17,zero,r17
8112d074:	d8802215 	stw	r2,136(sp)
8112d078:	a5000114 	ori	r20,r20,4
8112d07c:	80c00007 	ldb	r3,0(r16)
8112d080:	003f7706 	br	8112ce60 <__reset+0xfb10ce60>
8112d084:	00800c04 	movi	r2,48
8112d088:	da802217 	ldw	r10,136(sp)
8112d08c:	d8801d05 	stb	r2,116(sp)
8112d090:	00801e04 	movi	r2,120
8112d094:	d8801d45 	stb	r2,117(sp)
8112d098:	d8001d85 	stb	zero,118(sp)
8112d09c:	50c00104 	addi	r3,r10,4
8112d0a0:	54800017 	ldw	r18,0(r10)
8112d0a4:	0027883a 	mov	r19,zero
8112d0a8:	a0800094 	ori	r2,r20,2
8112d0ac:	48030b16 	blt	r9,zero,8112dcdc <___vfiprintf_internal_r+0x1000>
8112d0b0:	00bfdfc4 	movi	r2,-129
8112d0b4:	a096703a 	and	r11,r20,r2
8112d0b8:	d8c02215 	stw	r3,136(sp)
8112d0bc:	5d000094 	ori	r20,r11,2
8112d0c0:	90032b1e 	bne	r18,zero,8112dd70 <___vfiprintf_internal_r+0x1094>
8112d0c4:	00a04574 	movhi	r2,33045
8112d0c8:	10b0b304 	addi	r2,r2,-15668
8112d0cc:	d8802615 	stw	r2,152(sp)
8112d0d0:	0039883a 	mov	fp,zero
8112d0d4:	48017b1e 	bne	r9,zero,8112d6c4 <___vfiprintf_internal_r+0x9e8>
8112d0d8:	0013883a 	mov	r9,zero
8112d0dc:	0027883a 	mov	r19,zero
8112d0e0:	dd401a04 	addi	r21,sp,104
8112d0e4:	4825883a 	mov	r18,r9
8112d0e8:	4cc0010e 	bge	r9,r19,8112d0f0 <___vfiprintf_internal_r+0x414>
8112d0ec:	9825883a 	mov	r18,r19
8112d0f0:	e7003fcc 	andi	fp,fp,255
8112d0f4:	e700201c 	xori	fp,fp,128
8112d0f8:	e73fe004 	addi	fp,fp,-128
8112d0fc:	e0000126 	beq	fp,zero,8112d104 <___vfiprintf_internal_r+0x428>
8112d100:	94800044 	addi	r18,r18,1
8112d104:	a380008c 	andi	r14,r20,2
8112d108:	70000126 	beq	r14,zero,8112d110 <___vfiprintf_internal_r+0x434>
8112d10c:	94800084 	addi	r18,r18,2
8112d110:	a700210c 	andi	fp,r20,132
8112d114:	e001df1e 	bne	fp,zero,8112d894 <___vfiprintf_internal_r+0xbb8>
8112d118:	8c87c83a 	sub	r3,r17,r18
8112d11c:	00c1dd0e 	bge	zero,r3,8112d894 <___vfiprintf_internal_r+0xbb8>
8112d120:	01c00404 	movi	r7,16
8112d124:	d8801c17 	ldw	r2,112(sp)
8112d128:	38c3ad0e 	bge	r7,r3,8112dfe0 <___vfiprintf_internal_r+0x1304>
8112d12c:	02a04574 	movhi	r10,33045
8112d130:	52b14904 	addi	r10,r10,-15068
8112d134:	dc002915 	stw	r16,164(sp)
8112d138:	d9801b17 	ldw	r6,108(sp)
8112d13c:	da802415 	stw	r10,144(sp)
8112d140:	03c001c4 	movi	r15,7
8112d144:	da402515 	stw	r9,148(sp)
8112d148:	db802815 	stw	r14,160(sp)
8112d14c:	1821883a 	mov	r16,r3
8112d150:	00000506 	br	8112d168 <___vfiprintf_internal_r+0x48c>
8112d154:	31400084 	addi	r5,r6,2
8112d158:	42000204 	addi	r8,r8,8
8112d15c:	200d883a 	mov	r6,r4
8112d160:	843ffc04 	addi	r16,r16,-16
8112d164:	3c000d0e 	bge	r7,r16,8112d19c <___vfiprintf_internal_r+0x4c0>
8112d168:	10800404 	addi	r2,r2,16
8112d16c:	31000044 	addi	r4,r6,1
8112d170:	45800015 	stw	r22,0(r8)
8112d174:	41c00115 	stw	r7,4(r8)
8112d178:	d8801c15 	stw	r2,112(sp)
8112d17c:	d9001b15 	stw	r4,108(sp)
8112d180:	793ff40e 	bge	r15,r4,8112d154 <__reset+0xfb10d154>
8112d184:	1001b51e 	bne	r2,zero,8112d85c <___vfiprintf_internal_r+0xb80>
8112d188:	843ffc04 	addi	r16,r16,-16
8112d18c:	000d883a 	mov	r6,zero
8112d190:	01400044 	movi	r5,1
8112d194:	d811883a 	mov	r8,sp
8112d198:	3c3ff316 	blt	r7,r16,8112d168 <__reset+0xfb10d168>
8112d19c:	8007883a 	mov	r3,r16
8112d1a0:	da402517 	ldw	r9,148(sp)
8112d1a4:	db802817 	ldw	r14,160(sp)
8112d1a8:	dc002917 	ldw	r16,164(sp)
8112d1ac:	da802417 	ldw	r10,144(sp)
8112d1b0:	1885883a 	add	r2,r3,r2
8112d1b4:	40c00115 	stw	r3,4(r8)
8112d1b8:	42800015 	stw	r10,0(r8)
8112d1bc:	d8801c15 	stw	r2,112(sp)
8112d1c0:	d9401b15 	stw	r5,108(sp)
8112d1c4:	00c001c4 	movi	r3,7
8112d1c8:	19426016 	blt	r3,r5,8112db4c <___vfiprintf_internal_r+0xe70>
8112d1cc:	d8c01d87 	ldb	r3,118(sp)
8112d1d0:	42000204 	addi	r8,r8,8
8112d1d4:	29000044 	addi	r4,r5,1
8112d1d8:	1801b31e 	bne	r3,zero,8112d8a8 <___vfiprintf_internal_r+0xbcc>
8112d1dc:	7001c026 	beq	r14,zero,8112d8e0 <___vfiprintf_internal_r+0xc04>
8112d1e0:	d8c01d04 	addi	r3,sp,116
8112d1e4:	10800084 	addi	r2,r2,2
8112d1e8:	40c00015 	stw	r3,0(r8)
8112d1ec:	00c00084 	movi	r3,2
8112d1f0:	40c00115 	stw	r3,4(r8)
8112d1f4:	d8801c15 	stw	r2,112(sp)
8112d1f8:	d9001b15 	stw	r4,108(sp)
8112d1fc:	00c001c4 	movi	r3,7
8112d200:	1902650e 	bge	r3,r4,8112db98 <___vfiprintf_internal_r+0xebc>
8112d204:	10029a1e 	bne	r2,zero,8112dc70 <___vfiprintf_internal_r+0xf94>
8112d208:	00c02004 	movi	r3,128
8112d20c:	01000044 	movi	r4,1
8112d210:	000b883a 	mov	r5,zero
8112d214:	d811883a 	mov	r8,sp
8112d218:	e0c1b31e 	bne	fp,r3,8112d8e8 <___vfiprintf_internal_r+0xc0c>
8112d21c:	8cb9c83a 	sub	fp,r17,r18
8112d220:	0701b10e 	bge	zero,fp,8112d8e8 <___vfiprintf_internal_r+0xc0c>
8112d224:	01c00404 	movi	r7,16
8112d228:	3f03890e 	bge	r7,fp,8112e050 <___vfiprintf_internal_r+0x1374>
8112d22c:	00e04574 	movhi	r3,33045
8112d230:	18f14504 	addi	r3,r3,-15084
8112d234:	d8c02415 	stw	r3,144(sp)
8112d238:	8007883a 	mov	r3,r16
8112d23c:	034001c4 	movi	r13,7
8112d240:	e021883a 	mov	r16,fp
8112d244:	da402515 	stw	r9,148(sp)
8112d248:	1839883a 	mov	fp,r3
8112d24c:	00000506 	br	8112d264 <___vfiprintf_internal_r+0x588>
8112d250:	29800084 	addi	r6,r5,2
8112d254:	42000204 	addi	r8,r8,8
8112d258:	180b883a 	mov	r5,r3
8112d25c:	843ffc04 	addi	r16,r16,-16
8112d260:	3c000d0e 	bge	r7,r16,8112d298 <___vfiprintf_internal_r+0x5bc>
8112d264:	10800404 	addi	r2,r2,16
8112d268:	28c00044 	addi	r3,r5,1
8112d26c:	45c00015 	stw	r23,0(r8)
8112d270:	41c00115 	stw	r7,4(r8)
8112d274:	d8801c15 	stw	r2,112(sp)
8112d278:	d8c01b15 	stw	r3,108(sp)
8112d27c:	68fff40e 	bge	r13,r3,8112d250 <__reset+0xfb10d250>
8112d280:	1002241e 	bne	r2,zero,8112db14 <___vfiprintf_internal_r+0xe38>
8112d284:	843ffc04 	addi	r16,r16,-16
8112d288:	01800044 	movi	r6,1
8112d28c:	000b883a 	mov	r5,zero
8112d290:	d811883a 	mov	r8,sp
8112d294:	3c3ff316 	blt	r7,r16,8112d264 <__reset+0xfb10d264>
8112d298:	da402517 	ldw	r9,148(sp)
8112d29c:	e007883a 	mov	r3,fp
8112d2a0:	8039883a 	mov	fp,r16
8112d2a4:	1821883a 	mov	r16,r3
8112d2a8:	d8c02417 	ldw	r3,144(sp)
8112d2ac:	1705883a 	add	r2,r2,fp
8112d2b0:	47000115 	stw	fp,4(r8)
8112d2b4:	40c00015 	stw	r3,0(r8)
8112d2b8:	d8801c15 	stw	r2,112(sp)
8112d2bc:	d9801b15 	stw	r6,108(sp)
8112d2c0:	00c001c4 	movi	r3,7
8112d2c4:	19827616 	blt	r3,r6,8112dca0 <___vfiprintf_internal_r+0xfc4>
8112d2c8:	4cf9c83a 	sub	fp,r9,r19
8112d2cc:	42000204 	addi	r8,r8,8
8112d2d0:	31000044 	addi	r4,r6,1
8112d2d4:	300b883a 	mov	r5,r6
8112d2d8:	07018516 	blt	zero,fp,8112d8f0 <___vfiprintf_internal_r+0xc14>
8112d2dc:	9885883a 	add	r2,r19,r2
8112d2e0:	45400015 	stw	r21,0(r8)
8112d2e4:	44c00115 	stw	r19,4(r8)
8112d2e8:	d8801c15 	stw	r2,112(sp)
8112d2ec:	d9001b15 	stw	r4,108(sp)
8112d2f0:	00c001c4 	movi	r3,7
8112d2f4:	1901dd0e 	bge	r3,r4,8112da6c <___vfiprintf_internal_r+0xd90>
8112d2f8:	1002401e 	bne	r2,zero,8112dbfc <___vfiprintf_internal_r+0xf20>
8112d2fc:	d8001b15 	stw	zero,108(sp)
8112d300:	a2c0010c 	andi	r11,r20,4
8112d304:	58000226 	beq	r11,zero,8112d310 <___vfiprintf_internal_r+0x634>
8112d308:	8ca7c83a 	sub	r19,r17,r18
8112d30c:	04c2f216 	blt	zero,r19,8112ded8 <___vfiprintf_internal_r+0x11fc>
8112d310:	8c80010e 	bge	r17,r18,8112d318 <___vfiprintf_internal_r+0x63c>
8112d314:	9023883a 	mov	r17,r18
8112d318:	da802317 	ldw	r10,140(sp)
8112d31c:	5455883a 	add	r10,r10,r17
8112d320:	da802315 	stw	r10,140(sp)
8112d324:	d8001b15 	stw	zero,108(sp)
8112d328:	d811883a 	mov	r8,sp
8112d32c:	003ea206 	br	8112cdb8 <__reset+0xfb10cdb8>
8112d330:	a5000814 	ori	r20,r20,32
8112d334:	80c00007 	ldb	r3,0(r16)
8112d338:	003ec906 	br	8112ce60 <__reset+0xfb10ce60>
8112d33c:	80c00007 	ldb	r3,0(r16)
8112d340:	1b030926 	beq	r3,r12,8112df68 <___vfiprintf_internal_r+0x128c>
8112d344:	a5000414 	ori	r20,r20,16
8112d348:	003ec506 	br	8112ce60 <__reset+0xfb10ce60>
8112d34c:	21003fcc 	andi	r4,r4,255
8112d350:	20035e1e 	bne	r4,zero,8112e0cc <___vfiprintf_internal_r+0x13f0>
8112d354:	a080080c 	andi	r2,r20,32
8112d358:	1002a526 	beq	r2,zero,8112ddf0 <___vfiprintf_internal_r+0x1114>
8112d35c:	da802217 	ldw	r10,136(sp)
8112d360:	50800017 	ldw	r2,0(r10)
8112d364:	da802317 	ldw	r10,140(sp)
8112d368:	5007d7fa 	srai	r3,r10,31
8112d36c:	da802217 	ldw	r10,136(sp)
8112d370:	10c00115 	stw	r3,4(r2)
8112d374:	52800104 	addi	r10,r10,4
8112d378:	da802215 	stw	r10,136(sp)
8112d37c:	da802317 	ldw	r10,140(sp)
8112d380:	12800015 	stw	r10,0(r2)
8112d384:	003e8c06 	br	8112cdb8 <__reset+0xfb10cdb8>
8112d388:	21003fcc 	andi	r4,r4,255
8112d38c:	2003511e 	bne	r4,zero,8112e0d4 <___vfiprintf_internal_r+0x13f8>
8112d390:	a080080c 	andi	r2,r20,32
8112d394:	1000a126 	beq	r2,zero,8112d61c <___vfiprintf_internal_r+0x940>
8112d398:	da802217 	ldw	r10,136(sp)
8112d39c:	d8001d85 	stb	zero,118(sp)
8112d3a0:	50800204 	addi	r2,r10,8
8112d3a4:	54800017 	ldw	r18,0(r10)
8112d3a8:	54c00117 	ldw	r19,4(r10)
8112d3ac:	4802b416 	blt	r9,zero,8112de80 <___vfiprintf_internal_r+0x11a4>
8112d3b0:	013fdfc4 	movi	r4,-129
8112d3b4:	94c6b03a 	or	r3,r18,r19
8112d3b8:	d8802215 	stw	r2,136(sp)
8112d3bc:	a128703a 	and	r20,r20,r4
8112d3c0:	1800a226 	beq	r3,zero,8112d64c <___vfiprintf_internal_r+0x970>
8112d3c4:	0039883a 	mov	fp,zero
8112d3c8:	dd401a04 	addi	r21,sp,104
8112d3cc:	9006d0fa 	srli	r3,r18,3
8112d3d0:	9808977a 	slli	r4,r19,29
8112d3d4:	9826d0fa 	srli	r19,r19,3
8112d3d8:	948001cc 	andi	r18,r18,7
8112d3dc:	90800c04 	addi	r2,r18,48
8112d3e0:	ad7fffc4 	addi	r21,r21,-1
8112d3e4:	20e4b03a 	or	r18,r4,r3
8112d3e8:	a8800005 	stb	r2,0(r21)
8112d3ec:	94c6b03a 	or	r3,r18,r19
8112d3f0:	183ff61e 	bne	r3,zero,8112d3cc <__reset+0xfb10d3cc>
8112d3f4:	a0c0004c 	andi	r3,r20,1
8112d3f8:	18005926 	beq	r3,zero,8112d560 <___vfiprintf_internal_r+0x884>
8112d3fc:	10803fcc 	andi	r2,r2,255
8112d400:	1080201c 	xori	r2,r2,128
8112d404:	10bfe004 	addi	r2,r2,-128
8112d408:	00c00c04 	movi	r3,48
8112d40c:	10c05426 	beq	r2,r3,8112d560 <___vfiprintf_internal_r+0x884>
8112d410:	da801e17 	ldw	r10,120(sp)
8112d414:	a8bfffc4 	addi	r2,r21,-1
8112d418:	a8ffffc5 	stb	r3,-1(r21)
8112d41c:	50a7c83a 	sub	r19,r10,r2
8112d420:	102b883a 	mov	r21,r2
8112d424:	003f2f06 	br	8112d0e4 <__reset+0xfb10d0e4>
8112d428:	21003fcc 	andi	r4,r4,255
8112d42c:	2003421e 	bne	r4,zero,8112e138 <___vfiprintf_internal_r+0x145c>
8112d430:	00a04574 	movhi	r2,33045
8112d434:	10b0b304 	addi	r2,r2,-15668
8112d438:	d8802615 	stw	r2,152(sp)
8112d43c:	a080080c 	andi	r2,r20,32
8112d440:	1000aa26 	beq	r2,zero,8112d6ec <___vfiprintf_internal_r+0xa10>
8112d444:	da802217 	ldw	r10,136(sp)
8112d448:	54800017 	ldw	r18,0(r10)
8112d44c:	54c00117 	ldw	r19,4(r10)
8112d450:	52800204 	addi	r10,r10,8
8112d454:	da802215 	stw	r10,136(sp)
8112d458:	a080004c 	andi	r2,r20,1
8112d45c:	1001d226 	beq	r2,zero,8112dba8 <___vfiprintf_internal_r+0xecc>
8112d460:	94c4b03a 	or	r2,r18,r19
8112d464:	1002351e 	bne	r2,zero,8112dd3c <___vfiprintf_internal_r+0x1060>
8112d468:	d8001d85 	stb	zero,118(sp)
8112d46c:	48022216 	blt	r9,zero,8112dcf8 <___vfiprintf_internal_r+0x101c>
8112d470:	00bfdfc4 	movi	r2,-129
8112d474:	a0a8703a 	and	r20,r20,r2
8112d478:	003f1506 	br	8112d0d0 <__reset+0xfb10d0d0>
8112d47c:	da802217 	ldw	r10,136(sp)
8112d480:	04800044 	movi	r18,1
8112d484:	d8001d85 	stb	zero,118(sp)
8112d488:	50800017 	ldw	r2,0(r10)
8112d48c:	52800104 	addi	r10,r10,4
8112d490:	da802215 	stw	r10,136(sp)
8112d494:	d8801005 	stb	r2,64(sp)
8112d498:	9027883a 	mov	r19,r18
8112d49c:	dd401004 	addi	r21,sp,64
8112d4a0:	0013883a 	mov	r9,zero
8112d4a4:	003f1706 	br	8112d104 <__reset+0xfb10d104>
8112d4a8:	21003fcc 	andi	r4,r4,255
8112d4ac:	2003201e 	bne	r4,zero,8112e130 <___vfiprintf_internal_r+0x1454>
8112d4b0:	a080080c 	andi	r2,r20,32
8112d4b4:	10004b26 	beq	r2,zero,8112d5e4 <___vfiprintf_internal_r+0x908>
8112d4b8:	da802217 	ldw	r10,136(sp)
8112d4bc:	50800117 	ldw	r2,4(r10)
8112d4c0:	54800017 	ldw	r18,0(r10)
8112d4c4:	52800204 	addi	r10,r10,8
8112d4c8:	da802215 	stw	r10,136(sp)
8112d4cc:	1027883a 	mov	r19,r2
8112d4d0:	10022c16 	blt	r2,zero,8112dd84 <___vfiprintf_internal_r+0x10a8>
8112d4d4:	df001d83 	ldbu	fp,118(sp)
8112d4d8:	48007216 	blt	r9,zero,8112d6a4 <___vfiprintf_internal_r+0x9c8>
8112d4dc:	00ffdfc4 	movi	r3,-129
8112d4e0:	94c4b03a 	or	r2,r18,r19
8112d4e4:	a0e8703a 	and	r20,r20,r3
8112d4e8:	1000cc26 	beq	r2,zero,8112d81c <___vfiprintf_internal_r+0xb40>
8112d4ec:	98021026 	beq	r19,zero,8112dd30 <___vfiprintf_internal_r+0x1054>
8112d4f0:	dc402415 	stw	r17,144(sp)
8112d4f4:	dc002515 	stw	r16,148(sp)
8112d4f8:	9823883a 	mov	r17,r19
8112d4fc:	9021883a 	mov	r16,r18
8112d500:	dd401a04 	addi	r21,sp,104
8112d504:	4825883a 	mov	r18,r9
8112d508:	4027883a 	mov	r19,r8
8112d50c:	8009883a 	mov	r4,r16
8112d510:	880b883a 	mov	r5,r17
8112d514:	01800284 	movi	r6,10
8112d518:	000f883a 	mov	r7,zero
8112d51c:	112fa780 	call	8112fa78 <__umoddi3>
8112d520:	10800c04 	addi	r2,r2,48
8112d524:	ad7fffc4 	addi	r21,r21,-1
8112d528:	8009883a 	mov	r4,r16
8112d52c:	880b883a 	mov	r5,r17
8112d530:	a8800005 	stb	r2,0(r21)
8112d534:	01800284 	movi	r6,10
8112d538:	000f883a 	mov	r7,zero
8112d53c:	112f4f80 	call	8112f4f8 <__udivdi3>
8112d540:	1021883a 	mov	r16,r2
8112d544:	10c4b03a 	or	r2,r2,r3
8112d548:	1823883a 	mov	r17,r3
8112d54c:	103fef1e 	bne	r2,zero,8112d50c <__reset+0xfb10d50c>
8112d550:	dc402417 	ldw	r17,144(sp)
8112d554:	dc002517 	ldw	r16,148(sp)
8112d558:	9013883a 	mov	r9,r18
8112d55c:	9811883a 	mov	r8,r19
8112d560:	da801e17 	ldw	r10,120(sp)
8112d564:	5567c83a 	sub	r19,r10,r21
8112d568:	003ede06 	br	8112d0e4 <__reset+0xfb10d0e4>
8112d56c:	38803fcc 	andi	r2,r7,255
8112d570:	1080201c 	xori	r2,r2,128
8112d574:	10bfe004 	addi	r2,r2,-128
8112d578:	1002371e 	bne	r2,zero,8112de58 <___vfiprintf_internal_r+0x117c>
8112d57c:	01000044 	movi	r4,1
8112d580:	01c00804 	movi	r7,32
8112d584:	80c00007 	ldb	r3,0(r16)
8112d588:	003e3506 	br	8112ce60 <__reset+0xfb10ce60>
8112d58c:	a5000054 	ori	r20,r20,1
8112d590:	80c00007 	ldb	r3,0(r16)
8112d594:	003e3206 	br	8112ce60 <__reset+0xfb10ce60>
8112d598:	a5002014 	ori	r20,r20,128
8112d59c:	80c00007 	ldb	r3,0(r16)
8112d5a0:	003e2f06 	br	8112ce60 <__reset+0xfb10ce60>
8112d5a4:	8015883a 	mov	r10,r16
8112d5a8:	0023883a 	mov	r17,zero
8112d5ac:	18bff404 	addi	r2,r3,-48
8112d5b0:	50c00007 	ldb	r3,0(r10)
8112d5b4:	8c4002a4 	muli	r17,r17,10
8112d5b8:	84000044 	addi	r16,r16,1
8112d5bc:	8015883a 	mov	r10,r16
8112d5c0:	1463883a 	add	r17,r2,r17
8112d5c4:	18bff404 	addi	r2,r3,-48
8112d5c8:	30bff92e 	bgeu	r6,r2,8112d5b0 <__reset+0xfb10d5b0>
8112d5cc:	003e2506 	br	8112ce64 <__reset+0xfb10ce64>
8112d5d0:	21003fcc 	andi	r4,r4,255
8112d5d4:	2002d41e 	bne	r4,zero,8112e128 <___vfiprintf_internal_r+0x144c>
8112d5d8:	a5000414 	ori	r20,r20,16
8112d5dc:	a080080c 	andi	r2,r20,32
8112d5e0:	103fb51e 	bne	r2,zero,8112d4b8 <__reset+0xfb10d4b8>
8112d5e4:	a080040c 	andi	r2,r20,16
8112d5e8:	1001f826 	beq	r2,zero,8112ddcc <___vfiprintf_internal_r+0x10f0>
8112d5ec:	da802217 	ldw	r10,136(sp)
8112d5f0:	54800017 	ldw	r18,0(r10)
8112d5f4:	52800104 	addi	r10,r10,4
8112d5f8:	da802215 	stw	r10,136(sp)
8112d5fc:	9027d7fa 	srai	r19,r18,31
8112d600:	9805883a 	mov	r2,r19
8112d604:	003fb206 	br	8112d4d0 <__reset+0xfb10d4d0>
8112d608:	21003fcc 	andi	r4,r4,255
8112d60c:	2002c41e 	bne	r4,zero,8112e120 <___vfiprintf_internal_r+0x1444>
8112d610:	a5000414 	ori	r20,r20,16
8112d614:	a080080c 	andi	r2,r20,32
8112d618:	103f5f1e 	bne	r2,zero,8112d398 <__reset+0xfb10d398>
8112d61c:	a080040c 	andi	r2,r20,16
8112d620:	10020f26 	beq	r2,zero,8112de60 <___vfiprintf_internal_r+0x1184>
8112d624:	da802217 	ldw	r10,136(sp)
8112d628:	d8001d85 	stb	zero,118(sp)
8112d62c:	0027883a 	mov	r19,zero
8112d630:	50800104 	addi	r2,r10,4
8112d634:	54800017 	ldw	r18,0(r10)
8112d638:	48021116 	blt	r9,zero,8112de80 <___vfiprintf_internal_r+0x11a4>
8112d63c:	00ffdfc4 	movi	r3,-129
8112d640:	d8802215 	stw	r2,136(sp)
8112d644:	a0e8703a 	and	r20,r20,r3
8112d648:	903f5e1e 	bne	r18,zero,8112d3c4 <__reset+0xfb10d3c4>
8112d64c:	0039883a 	mov	fp,zero
8112d650:	4802a626 	beq	r9,zero,8112e0ec <___vfiprintf_internal_r+0x1410>
8112d654:	0025883a 	mov	r18,zero
8112d658:	0027883a 	mov	r19,zero
8112d65c:	003f5a06 	br	8112d3c8 <__reset+0xfb10d3c8>
8112d660:	21003fcc 	andi	r4,r4,255
8112d664:	20029f1e 	bne	r4,zero,8112e0e4 <___vfiprintf_internal_r+0x1408>
8112d668:	a5000414 	ori	r20,r20,16
8112d66c:	a080080c 	andi	r2,r20,32
8112d670:	10005e1e 	bne	r2,zero,8112d7ec <___vfiprintf_internal_r+0xb10>
8112d674:	a080040c 	andi	r2,r20,16
8112d678:	1001a21e 	bne	r2,zero,8112dd04 <___vfiprintf_internal_r+0x1028>
8112d67c:	a080100c 	andi	r2,r20,64
8112d680:	d8001d85 	stb	zero,118(sp)
8112d684:	da802217 	ldw	r10,136(sp)
8112d688:	1002231e 	bne	r2,zero,8112df18 <___vfiprintf_internal_r+0x123c>
8112d68c:	50800104 	addi	r2,r10,4
8112d690:	54800017 	ldw	r18,0(r10)
8112d694:	0027883a 	mov	r19,zero
8112d698:	4801a00e 	bge	r9,zero,8112dd1c <___vfiprintf_internal_r+0x1040>
8112d69c:	d8802215 	stw	r2,136(sp)
8112d6a0:	0039883a 	mov	fp,zero
8112d6a4:	94c4b03a 	or	r2,r18,r19
8112d6a8:	103f901e 	bne	r2,zero,8112d4ec <__reset+0xfb10d4ec>
8112d6ac:	00800044 	movi	r2,1
8112d6b0:	10803fcc 	andi	r2,r2,255
8112d6b4:	00c00044 	movi	r3,1
8112d6b8:	10c05926 	beq	r2,r3,8112d820 <___vfiprintf_internal_r+0xb44>
8112d6bc:	00c00084 	movi	r3,2
8112d6c0:	10ffe41e 	bne	r2,r3,8112d654 <__reset+0xfb10d654>
8112d6c4:	0025883a 	mov	r18,zero
8112d6c8:	0027883a 	mov	r19,zero
8112d6cc:	00013d06 	br	8112dbc4 <___vfiprintf_internal_r+0xee8>
8112d6d0:	21003fcc 	andi	r4,r4,255
8112d6d4:	2002811e 	bne	r4,zero,8112e0dc <___vfiprintf_internal_r+0x1400>
8112d6d8:	00a04574 	movhi	r2,33045
8112d6dc:	10b0ae04 	addi	r2,r2,-15688
8112d6e0:	d8802615 	stw	r2,152(sp)
8112d6e4:	a080080c 	andi	r2,r20,32
8112d6e8:	103f561e 	bne	r2,zero,8112d444 <__reset+0xfb10d444>
8112d6ec:	a080040c 	andi	r2,r20,16
8112d6f0:	1001d126 	beq	r2,zero,8112de38 <___vfiprintf_internal_r+0x115c>
8112d6f4:	da802217 	ldw	r10,136(sp)
8112d6f8:	0027883a 	mov	r19,zero
8112d6fc:	54800017 	ldw	r18,0(r10)
8112d700:	52800104 	addi	r10,r10,4
8112d704:	da802215 	stw	r10,136(sp)
8112d708:	003f5306 	br	8112d458 <__reset+0xfb10d458>
8112d70c:	da802217 	ldw	r10,136(sp)
8112d710:	d8001d85 	stb	zero,118(sp)
8112d714:	55400017 	ldw	r21,0(r10)
8112d718:	50c00104 	addi	r3,r10,4
8112d71c:	a8024226 	beq	r21,zero,8112e028 <___vfiprintf_internal_r+0x134c>
8112d720:	48021816 	blt	r9,zero,8112df84 <___vfiprintf_internal_r+0x12a8>
8112d724:	480d883a 	mov	r6,r9
8112d728:	000b883a 	mov	r5,zero
8112d72c:	a809883a 	mov	r4,r21
8112d730:	d8c02a15 	stw	r3,168(sp)
8112d734:	da002b15 	stw	r8,172(sp)
8112d738:	da402c15 	stw	r9,176(sp)
8112d73c:	1127ab80 	call	81127ab8 <memchr>
8112d740:	d8c02a17 	ldw	r3,168(sp)
8112d744:	da002b17 	ldw	r8,172(sp)
8112d748:	da402c17 	ldw	r9,176(sp)
8112d74c:	10024826 	beq	r2,zero,8112e070 <___vfiprintf_internal_r+0x1394>
8112d750:	1567c83a 	sub	r19,r2,r21
8112d754:	df001d83 	ldbu	fp,118(sp)
8112d758:	d8c02215 	stw	r3,136(sp)
8112d75c:	0013883a 	mov	r9,zero
8112d760:	003e6006 	br	8112d0e4 <__reset+0xfb10d0e4>
8112d764:	21003fcc 	andi	r4,r4,255
8112d768:	203fc026 	beq	r4,zero,8112d66c <__reset+0xfb10d66c>
8112d76c:	d9c01d85 	stb	r7,118(sp)
8112d770:	003fbe06 	br	8112d66c <__reset+0xfb10d66c>
8112d774:	da802217 	ldw	r10,136(sp)
8112d778:	54400017 	ldw	r17,0(r10)
8112d77c:	50800104 	addi	r2,r10,4
8112d780:	883e3b16 	blt	r17,zero,8112d070 <__reset+0xfb10d070>
8112d784:	d8802215 	stw	r2,136(sp)
8112d788:	80c00007 	ldb	r3,0(r16)
8112d78c:	003db406 	br	8112ce60 <__reset+0xfb10ce60>
8112d790:	01000044 	movi	r4,1
8112d794:	01c00ac4 	movi	r7,43
8112d798:	80c00007 	ldb	r3,0(r16)
8112d79c:	003db006 	br	8112ce60 <__reset+0xfb10ce60>
8112d7a0:	80c00007 	ldb	r3,0(r16)
8112d7a4:	82800044 	addi	r10,r16,1
8112d7a8:	1b423c26 	beq	r3,r13,8112e09c <___vfiprintf_internal_r+0x13c0>
8112d7ac:	18bff404 	addi	r2,r3,-48
8112d7b0:	0013883a 	mov	r9,zero
8112d7b4:	30822b36 	bltu	r6,r2,8112e064 <___vfiprintf_internal_r+0x1388>
8112d7b8:	50c00007 	ldb	r3,0(r10)
8112d7bc:	4a4002a4 	muli	r9,r9,10
8112d7c0:	54000044 	addi	r16,r10,1
8112d7c4:	8015883a 	mov	r10,r16
8112d7c8:	4893883a 	add	r9,r9,r2
8112d7cc:	18bff404 	addi	r2,r3,-48
8112d7d0:	30bff92e 	bgeu	r6,r2,8112d7b8 <__reset+0xfb10d7b8>
8112d7d4:	483da30e 	bge	r9,zero,8112ce64 <__reset+0xfb10ce64>
8112d7d8:	027fffc4 	movi	r9,-1
8112d7dc:	003da106 	br	8112ce64 <__reset+0xfb10ce64>
8112d7e0:	a5001014 	ori	r20,r20,64
8112d7e4:	80c00007 	ldb	r3,0(r16)
8112d7e8:	003d9d06 	br	8112ce60 <__reset+0xfb10ce60>
8112d7ec:	da802217 	ldw	r10,136(sp)
8112d7f0:	d8001d85 	stb	zero,118(sp)
8112d7f4:	50c00204 	addi	r3,r10,8
8112d7f8:	54800017 	ldw	r18,0(r10)
8112d7fc:	54c00117 	ldw	r19,4(r10)
8112d800:	4801ca16 	blt	r9,zero,8112df2c <___vfiprintf_internal_r+0x1250>
8112d804:	013fdfc4 	movi	r4,-129
8112d808:	94c4b03a 	or	r2,r18,r19
8112d80c:	d8c02215 	stw	r3,136(sp)
8112d810:	a128703a 	and	r20,r20,r4
8112d814:	0039883a 	mov	fp,zero
8112d818:	103f341e 	bne	r2,zero,8112d4ec <__reset+0xfb10d4ec>
8112d81c:	483e2e26 	beq	r9,zero,8112d0d8 <__reset+0xfb10d0d8>
8112d820:	0025883a 	mov	r18,zero
8112d824:	94800c04 	addi	r18,r18,48
8112d828:	dc8019c5 	stb	r18,103(sp)
8112d82c:	dcc02717 	ldw	r19,156(sp)
8112d830:	dd4019c4 	addi	r21,sp,103
8112d834:	003e2b06 	br	8112d0e4 <__reset+0xfb10d0e4>
8112d838:	21003fcc 	andi	r4,r4,255
8112d83c:	2002361e 	bne	r4,zero,8112e118 <___vfiprintf_internal_r+0x143c>
8112d840:	1801c126 	beq	r3,zero,8112df48 <___vfiprintf_internal_r+0x126c>
8112d844:	04800044 	movi	r18,1
8112d848:	d8c01005 	stb	r3,64(sp)
8112d84c:	d8001d85 	stb	zero,118(sp)
8112d850:	9027883a 	mov	r19,r18
8112d854:	dd401004 	addi	r21,sp,64
8112d858:	003f1106 	br	8112d4a0 <__reset+0xfb10d4a0>
8112d85c:	d9402117 	ldw	r5,132(sp)
8112d860:	d9002017 	ldw	r4,128(sp)
8112d864:	d9801a04 	addi	r6,sp,104
8112d868:	d9c02b15 	stw	r7,172(sp)
8112d86c:	dbc02a15 	stw	r15,168(sp)
8112d870:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112d874:	d9c02b17 	ldw	r7,172(sp)
8112d878:	dbc02a17 	ldw	r15,168(sp)
8112d87c:	10006d1e 	bne	r2,zero,8112da34 <___vfiprintf_internal_r+0xd58>
8112d880:	d9801b17 	ldw	r6,108(sp)
8112d884:	d8801c17 	ldw	r2,112(sp)
8112d888:	d811883a 	mov	r8,sp
8112d88c:	31400044 	addi	r5,r6,1
8112d890:	003e3306 	br	8112d160 <__reset+0xfb10d160>
8112d894:	d9401b17 	ldw	r5,108(sp)
8112d898:	d8801c17 	ldw	r2,112(sp)
8112d89c:	29000044 	addi	r4,r5,1
8112d8a0:	d8c01d87 	ldb	r3,118(sp)
8112d8a4:	183e4d26 	beq	r3,zero,8112d1dc <__reset+0xfb10d1dc>
8112d8a8:	00c00044 	movi	r3,1
8112d8ac:	d9401d84 	addi	r5,sp,118
8112d8b0:	10c5883a 	add	r2,r2,r3
8112d8b4:	41400015 	stw	r5,0(r8)
8112d8b8:	40c00115 	stw	r3,4(r8)
8112d8bc:	d8801c15 	stw	r2,112(sp)
8112d8c0:	d9001b15 	stw	r4,108(sp)
8112d8c4:	014001c4 	movi	r5,7
8112d8c8:	2900a90e 	bge	r5,r4,8112db70 <___vfiprintf_internal_r+0xe94>
8112d8cc:	1000da1e 	bne	r2,zero,8112dc38 <___vfiprintf_internal_r+0xf5c>
8112d8d0:	7000ab1e 	bne	r14,zero,8112db80 <___vfiprintf_internal_r+0xea4>
8112d8d4:	000b883a 	mov	r5,zero
8112d8d8:	1809883a 	mov	r4,r3
8112d8dc:	d811883a 	mov	r8,sp
8112d8e0:	00c02004 	movi	r3,128
8112d8e4:	e0fe4d26 	beq	fp,r3,8112d21c <__reset+0xfb10d21c>
8112d8e8:	4cf9c83a 	sub	fp,r9,r19
8112d8ec:	073e7b0e 	bge	zero,fp,8112d2dc <__reset+0xfb10d2dc>
8112d8f0:	01c00404 	movi	r7,16
8112d8f4:	3f01900e 	bge	r7,fp,8112df38 <___vfiprintf_internal_r+0x125c>
8112d8f8:	00e04574 	movhi	r3,33045
8112d8fc:	18f14504 	addi	r3,r3,-15084
8112d900:	d8c02415 	stw	r3,144(sp)
8112d904:	034001c4 	movi	r13,7
8112d908:	00000506 	br	8112d920 <___vfiprintf_internal_r+0xc44>
8112d90c:	29000084 	addi	r4,r5,2
8112d910:	42000204 	addi	r8,r8,8
8112d914:	180b883a 	mov	r5,r3
8112d918:	e73ffc04 	addi	fp,fp,-16
8112d91c:	3f000d0e 	bge	r7,fp,8112d954 <___vfiprintf_internal_r+0xc78>
8112d920:	10800404 	addi	r2,r2,16
8112d924:	28c00044 	addi	r3,r5,1
8112d928:	45c00015 	stw	r23,0(r8)
8112d92c:	41c00115 	stw	r7,4(r8)
8112d930:	d8801c15 	stw	r2,112(sp)
8112d934:	d8c01b15 	stw	r3,108(sp)
8112d938:	68fff40e 	bge	r13,r3,8112d90c <__reset+0xfb10d90c>
8112d93c:	1000101e 	bne	r2,zero,8112d980 <___vfiprintf_internal_r+0xca4>
8112d940:	e73ffc04 	addi	fp,fp,-16
8112d944:	01000044 	movi	r4,1
8112d948:	000b883a 	mov	r5,zero
8112d94c:	d811883a 	mov	r8,sp
8112d950:	3f3ff316 	blt	r7,fp,8112d920 <__reset+0xfb10d920>
8112d954:	da802417 	ldw	r10,144(sp)
8112d958:	1705883a 	add	r2,r2,fp
8112d95c:	47000115 	stw	fp,4(r8)
8112d960:	42800015 	stw	r10,0(r8)
8112d964:	d8801c15 	stw	r2,112(sp)
8112d968:	d9001b15 	stw	r4,108(sp)
8112d96c:	00c001c4 	movi	r3,7
8112d970:	19003616 	blt	r3,r4,8112da4c <___vfiprintf_internal_r+0xd70>
8112d974:	42000204 	addi	r8,r8,8
8112d978:	21000044 	addi	r4,r4,1
8112d97c:	003e5706 	br	8112d2dc <__reset+0xfb10d2dc>
8112d980:	d9402117 	ldw	r5,132(sp)
8112d984:	d9002017 	ldw	r4,128(sp)
8112d988:	d9801a04 	addi	r6,sp,104
8112d98c:	d9c02b15 	stw	r7,172(sp)
8112d990:	db402a15 	stw	r13,168(sp)
8112d994:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112d998:	d9c02b17 	ldw	r7,172(sp)
8112d99c:	db402a17 	ldw	r13,168(sp)
8112d9a0:	1000241e 	bne	r2,zero,8112da34 <___vfiprintf_internal_r+0xd58>
8112d9a4:	d9401b17 	ldw	r5,108(sp)
8112d9a8:	d8801c17 	ldw	r2,112(sp)
8112d9ac:	d811883a 	mov	r8,sp
8112d9b0:	29000044 	addi	r4,r5,1
8112d9b4:	003fd806 	br	8112d918 <__reset+0xfb10d918>
8112d9b8:	d9401b17 	ldw	r5,108(sp)
8112d9bc:	00e04574 	movhi	r3,33045
8112d9c0:	18f14904 	addi	r3,r3,-15068
8112d9c4:	d8c02415 	stw	r3,144(sp)
8112d9c8:	29400044 	addi	r5,r5,1
8112d9cc:	d8c02417 	ldw	r3,144(sp)
8112d9d0:	14c5883a 	add	r2,r2,r19
8112d9d4:	44c00115 	stw	r19,4(r8)
8112d9d8:	40c00015 	stw	r3,0(r8)
8112d9dc:	d8801c15 	stw	r2,112(sp)
8112d9e0:	d9401b15 	stw	r5,108(sp)
8112d9e4:	00c001c4 	movi	r3,7
8112d9e8:	1940070e 	bge	r3,r5,8112da08 <___vfiprintf_internal_r+0xd2c>
8112d9ec:	103e4826 	beq	r2,zero,8112d310 <__reset+0xfb10d310>
8112d9f0:	d9402117 	ldw	r5,132(sp)
8112d9f4:	d9002017 	ldw	r4,128(sp)
8112d9f8:	d9801a04 	addi	r6,sp,104
8112d9fc:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112da00:	10000c1e 	bne	r2,zero,8112da34 <___vfiprintf_internal_r+0xd58>
8112da04:	d8801c17 	ldw	r2,112(sp)
8112da08:	8c80010e 	bge	r17,r18,8112da10 <___vfiprintf_internal_r+0xd34>
8112da0c:	9023883a 	mov	r17,r18
8112da10:	da802317 	ldw	r10,140(sp)
8112da14:	5455883a 	add	r10,r10,r17
8112da18:	da802315 	stw	r10,140(sp)
8112da1c:	103e4126 	beq	r2,zero,8112d324 <__reset+0xfb10d324>
8112da20:	d9402117 	ldw	r5,132(sp)
8112da24:	d9002017 	ldw	r4,128(sp)
8112da28:	d9801a04 	addi	r6,sp,104
8112da2c:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112da30:	103e3c26 	beq	r2,zero,8112d324 <__reset+0xfb10d324>
8112da34:	dd002117 	ldw	r20,132(sp)
8112da38:	a080030b 	ldhu	r2,12(r20)
8112da3c:	1080100c 	andi	r2,r2,64
8112da40:	1001231e 	bne	r2,zero,8112ded0 <___vfiprintf_internal_r+0x11f4>
8112da44:	d8802317 	ldw	r2,140(sp)
8112da48:	003d7b06 	br	8112d038 <__reset+0xfb10d038>
8112da4c:	1000991e 	bne	r2,zero,8112dcb4 <___vfiprintf_internal_r+0xfd8>
8112da50:	00c00044 	movi	r3,1
8112da54:	9805883a 	mov	r2,r19
8112da58:	dd400015 	stw	r21,0(sp)
8112da5c:	dcc00115 	stw	r19,4(sp)
8112da60:	dcc01c15 	stw	r19,112(sp)
8112da64:	d8c01b15 	stw	r3,108(sp)
8112da68:	d811883a 	mov	r8,sp
8112da6c:	42000204 	addi	r8,r8,8
8112da70:	a2c0010c 	andi	r11,r20,4
8112da74:	583fe426 	beq	r11,zero,8112da08 <__reset+0xfb10da08>
8112da78:	8ca7c83a 	sub	r19,r17,r18
8112da7c:	04ffe20e 	bge	zero,r19,8112da08 <__reset+0xfb10da08>
8112da80:	01c00404 	movi	r7,16
8112da84:	3cffcc0e 	bge	r7,r19,8112d9b8 <__reset+0xfb10d9b8>
8112da88:	02a04574 	movhi	r10,33045
8112da8c:	52b14904 	addi	r10,r10,-15068
8112da90:	d9001b17 	ldw	r4,108(sp)
8112da94:	da802415 	stw	r10,144(sp)
8112da98:	382b883a 	mov	r21,r7
8112da9c:	050001c4 	movi	r20,7
8112daa0:	df002017 	ldw	fp,128(sp)
8112daa4:	00000506 	br	8112dabc <___vfiprintf_internal_r+0xde0>
8112daa8:	21400084 	addi	r5,r4,2
8112daac:	42000204 	addi	r8,r8,8
8112dab0:	1809883a 	mov	r4,r3
8112dab4:	9cfffc04 	addi	r19,r19,-16
8112dab8:	acffc40e 	bge	r21,r19,8112d9cc <__reset+0xfb10d9cc>
8112dabc:	10800404 	addi	r2,r2,16
8112dac0:	20c00044 	addi	r3,r4,1
8112dac4:	45800015 	stw	r22,0(r8)
8112dac8:	45400115 	stw	r21,4(r8)
8112dacc:	d8801c15 	stw	r2,112(sp)
8112dad0:	d8c01b15 	stw	r3,108(sp)
8112dad4:	a0fff40e 	bge	r20,r3,8112daa8 <__reset+0xfb10daa8>
8112dad8:	1000041e 	bne	r2,zero,8112daec <___vfiprintf_internal_r+0xe10>
8112dadc:	01400044 	movi	r5,1
8112dae0:	0009883a 	mov	r4,zero
8112dae4:	d811883a 	mov	r8,sp
8112dae8:	003ff206 	br	8112dab4 <__reset+0xfb10dab4>
8112daec:	d9402117 	ldw	r5,132(sp)
8112daf0:	d9801a04 	addi	r6,sp,104
8112daf4:	e009883a 	mov	r4,fp
8112daf8:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dafc:	103fcd1e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112db00:	d9001b17 	ldw	r4,108(sp)
8112db04:	d8801c17 	ldw	r2,112(sp)
8112db08:	d811883a 	mov	r8,sp
8112db0c:	21400044 	addi	r5,r4,1
8112db10:	003fe806 	br	8112dab4 <__reset+0xfb10dab4>
8112db14:	d9402117 	ldw	r5,132(sp)
8112db18:	d9002017 	ldw	r4,128(sp)
8112db1c:	d9801a04 	addi	r6,sp,104
8112db20:	d9c02b15 	stw	r7,172(sp)
8112db24:	db402a15 	stw	r13,168(sp)
8112db28:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112db2c:	d9c02b17 	ldw	r7,172(sp)
8112db30:	db402a17 	ldw	r13,168(sp)
8112db34:	103fbf1e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112db38:	d9401b17 	ldw	r5,108(sp)
8112db3c:	d8801c17 	ldw	r2,112(sp)
8112db40:	d811883a 	mov	r8,sp
8112db44:	29800044 	addi	r6,r5,1
8112db48:	003dc406 	br	8112d25c <__reset+0xfb10d25c>
8112db4c:	1000d21e 	bne	r2,zero,8112de98 <___vfiprintf_internal_r+0x11bc>
8112db50:	d8c01d87 	ldb	r3,118(sp)
8112db54:	18009526 	beq	r3,zero,8112ddac <___vfiprintf_internal_r+0x10d0>
8112db58:	00800044 	movi	r2,1
8112db5c:	d8c01d84 	addi	r3,sp,118
8112db60:	1009883a 	mov	r4,r2
8112db64:	d8c00015 	stw	r3,0(sp)
8112db68:	d8800115 	stw	r2,4(sp)
8112db6c:	d811883a 	mov	r8,sp
8112db70:	200b883a 	mov	r5,r4
8112db74:	42000204 	addi	r8,r8,8
8112db78:	21000044 	addi	r4,r4,1
8112db7c:	003d9706 	br	8112d1dc <__reset+0xfb10d1dc>
8112db80:	d9001d04 	addi	r4,sp,116
8112db84:	00800084 	movi	r2,2
8112db88:	d9000015 	stw	r4,0(sp)
8112db8c:	d8800115 	stw	r2,4(sp)
8112db90:	1809883a 	mov	r4,r3
8112db94:	d811883a 	mov	r8,sp
8112db98:	200b883a 	mov	r5,r4
8112db9c:	42000204 	addi	r8,r8,8
8112dba0:	21000044 	addi	r4,r4,1
8112dba4:	003f4e06 	br	8112d8e0 <__reset+0xfb10d8e0>
8112dba8:	d8001d85 	stb	zero,118(sp)
8112dbac:	48005016 	blt	r9,zero,8112dcf0 <___vfiprintf_internal_r+0x1014>
8112dbb0:	00ffdfc4 	movi	r3,-129
8112dbb4:	94c4b03a 	or	r2,r18,r19
8112dbb8:	a0e8703a 	and	r20,r20,r3
8112dbbc:	103d4426 	beq	r2,zero,8112d0d0 <__reset+0xfb10d0d0>
8112dbc0:	0039883a 	mov	fp,zero
8112dbc4:	d9002617 	ldw	r4,152(sp)
8112dbc8:	dd401a04 	addi	r21,sp,104
8112dbcc:	908003cc 	andi	r2,r18,15
8112dbd0:	9806973a 	slli	r3,r19,28
8112dbd4:	2085883a 	add	r2,r4,r2
8112dbd8:	9024d13a 	srli	r18,r18,4
8112dbdc:	10800003 	ldbu	r2,0(r2)
8112dbe0:	9826d13a 	srli	r19,r19,4
8112dbe4:	ad7fffc4 	addi	r21,r21,-1
8112dbe8:	1ca4b03a 	or	r18,r3,r18
8112dbec:	a8800005 	stb	r2,0(r21)
8112dbf0:	94c4b03a 	or	r2,r18,r19
8112dbf4:	103ff51e 	bne	r2,zero,8112dbcc <__reset+0xfb10dbcc>
8112dbf8:	003e5906 	br	8112d560 <__reset+0xfb10d560>
8112dbfc:	d9402117 	ldw	r5,132(sp)
8112dc00:	d9002017 	ldw	r4,128(sp)
8112dc04:	d9801a04 	addi	r6,sp,104
8112dc08:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dc0c:	103f891e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112dc10:	d8801c17 	ldw	r2,112(sp)
8112dc14:	d811883a 	mov	r8,sp
8112dc18:	003f9506 	br	8112da70 <__reset+0xfb10da70>
8112dc1c:	d9402117 	ldw	r5,132(sp)
8112dc20:	d9002017 	ldw	r4,128(sp)
8112dc24:	d9801a04 	addi	r6,sp,104
8112dc28:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dc2c:	103f811e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112dc30:	d811883a 	mov	r8,sp
8112dc34:	003ced06 	br	8112cfec <__reset+0xfb10cfec>
8112dc38:	d9402117 	ldw	r5,132(sp)
8112dc3c:	d9002017 	ldw	r4,128(sp)
8112dc40:	d9801a04 	addi	r6,sp,104
8112dc44:	da402c15 	stw	r9,176(sp)
8112dc48:	db802a15 	stw	r14,168(sp)
8112dc4c:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dc50:	da402c17 	ldw	r9,176(sp)
8112dc54:	db802a17 	ldw	r14,168(sp)
8112dc58:	103f761e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112dc5c:	d9401b17 	ldw	r5,108(sp)
8112dc60:	d8801c17 	ldw	r2,112(sp)
8112dc64:	d811883a 	mov	r8,sp
8112dc68:	29000044 	addi	r4,r5,1
8112dc6c:	003d5b06 	br	8112d1dc <__reset+0xfb10d1dc>
8112dc70:	d9402117 	ldw	r5,132(sp)
8112dc74:	d9002017 	ldw	r4,128(sp)
8112dc78:	d9801a04 	addi	r6,sp,104
8112dc7c:	da402c15 	stw	r9,176(sp)
8112dc80:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dc84:	da402c17 	ldw	r9,176(sp)
8112dc88:	103f6a1e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112dc8c:	d9401b17 	ldw	r5,108(sp)
8112dc90:	d8801c17 	ldw	r2,112(sp)
8112dc94:	d811883a 	mov	r8,sp
8112dc98:	29000044 	addi	r4,r5,1
8112dc9c:	003f1006 	br	8112d8e0 <__reset+0xfb10d8e0>
8112dca0:	1000c31e 	bne	r2,zero,8112dfb0 <___vfiprintf_internal_r+0x12d4>
8112dca4:	01000044 	movi	r4,1
8112dca8:	000b883a 	mov	r5,zero
8112dcac:	d811883a 	mov	r8,sp
8112dcb0:	003f0d06 	br	8112d8e8 <__reset+0xfb10d8e8>
8112dcb4:	d9402117 	ldw	r5,132(sp)
8112dcb8:	d9002017 	ldw	r4,128(sp)
8112dcbc:	d9801a04 	addi	r6,sp,104
8112dcc0:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dcc4:	103f5b1e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112dcc8:	d9001b17 	ldw	r4,108(sp)
8112dccc:	d8801c17 	ldw	r2,112(sp)
8112dcd0:	d811883a 	mov	r8,sp
8112dcd4:	21000044 	addi	r4,r4,1
8112dcd8:	003d8006 	br	8112d2dc <__reset+0xfb10d2dc>
8112dcdc:	01204574 	movhi	r4,33045
8112dce0:	2130b304 	addi	r4,r4,-15668
8112dce4:	d9002615 	stw	r4,152(sp)
8112dce8:	d8c02215 	stw	r3,136(sp)
8112dcec:	1029883a 	mov	r20,r2
8112dcf0:	94c4b03a 	or	r2,r18,r19
8112dcf4:	103fb21e 	bne	r2,zero,8112dbc0 <__reset+0xfb10dbc0>
8112dcf8:	0039883a 	mov	fp,zero
8112dcfc:	00800084 	movi	r2,2
8112dd00:	003e6b06 	br	8112d6b0 <__reset+0xfb10d6b0>
8112dd04:	da802217 	ldw	r10,136(sp)
8112dd08:	d8001d85 	stb	zero,118(sp)
8112dd0c:	0027883a 	mov	r19,zero
8112dd10:	50800104 	addi	r2,r10,4
8112dd14:	54800017 	ldw	r18,0(r10)
8112dd18:	483e6016 	blt	r9,zero,8112d69c <__reset+0xfb10d69c>
8112dd1c:	00ffdfc4 	movi	r3,-129
8112dd20:	d8802215 	stw	r2,136(sp)
8112dd24:	a0e8703a 	and	r20,r20,r3
8112dd28:	0039883a 	mov	fp,zero
8112dd2c:	903ebb26 	beq	r18,zero,8112d81c <__reset+0xfb10d81c>
8112dd30:	00800244 	movi	r2,9
8112dd34:	14bdee36 	bltu	r2,r18,8112d4f0 <__reset+0xfb10d4f0>
8112dd38:	003eba06 	br	8112d824 <__reset+0xfb10d824>
8112dd3c:	00800c04 	movi	r2,48
8112dd40:	d8c01d45 	stb	r3,117(sp)
8112dd44:	d8801d05 	stb	r2,116(sp)
8112dd48:	d8001d85 	stb	zero,118(sp)
8112dd4c:	a0c00094 	ori	r3,r20,2
8112dd50:	4800a916 	blt	r9,zero,8112dff8 <___vfiprintf_internal_r+0x131c>
8112dd54:	00bfdfc4 	movi	r2,-129
8112dd58:	a096703a 	and	r11,r20,r2
8112dd5c:	5d000094 	ori	r20,r11,2
8112dd60:	0039883a 	mov	fp,zero
8112dd64:	003f9706 	br	8112dbc4 <__reset+0xfb10dbc4>
8112dd68:	8025883a 	mov	r18,r16
8112dd6c:	003c2e06 	br	8112ce28 <__reset+0xfb10ce28>
8112dd70:	00a04574 	movhi	r2,33045
8112dd74:	10b0b304 	addi	r2,r2,-15668
8112dd78:	0039883a 	mov	fp,zero
8112dd7c:	d8802615 	stw	r2,152(sp)
8112dd80:	003f9006 	br	8112dbc4 <__reset+0xfb10dbc4>
8112dd84:	04a5c83a 	sub	r18,zero,r18
8112dd88:	07000b44 	movi	fp,45
8112dd8c:	9004c03a 	cmpne	r2,r18,zero
8112dd90:	04e7c83a 	sub	r19,zero,r19
8112dd94:	df001d85 	stb	fp,118(sp)
8112dd98:	98a7c83a 	sub	r19,r19,r2
8112dd9c:	48009f16 	blt	r9,zero,8112e01c <___vfiprintf_internal_r+0x1340>
8112dda0:	00bfdfc4 	movi	r2,-129
8112dda4:	a0a8703a 	and	r20,r20,r2
8112dda8:	003dd006 	br	8112d4ec <__reset+0xfb10d4ec>
8112ddac:	70004c26 	beq	r14,zero,8112dee0 <___vfiprintf_internal_r+0x1204>
8112ddb0:	00800084 	movi	r2,2
8112ddb4:	d8c01d04 	addi	r3,sp,116
8112ddb8:	d8c00015 	stw	r3,0(sp)
8112ddbc:	d8800115 	stw	r2,4(sp)
8112ddc0:	01000044 	movi	r4,1
8112ddc4:	d811883a 	mov	r8,sp
8112ddc8:	003f7306 	br	8112db98 <__reset+0xfb10db98>
8112ddcc:	a080100c 	andi	r2,r20,64
8112ddd0:	da802217 	ldw	r10,136(sp)
8112ddd4:	103e0626 	beq	r2,zero,8112d5f0 <__reset+0xfb10d5f0>
8112ddd8:	5480000f 	ldh	r18,0(r10)
8112dddc:	52800104 	addi	r10,r10,4
8112dde0:	da802215 	stw	r10,136(sp)
8112dde4:	9027d7fa 	srai	r19,r18,31
8112dde8:	9805883a 	mov	r2,r19
8112ddec:	003db806 	br	8112d4d0 <__reset+0xfb10d4d0>
8112ddf0:	a080040c 	andi	r2,r20,16
8112ddf4:	1000091e 	bne	r2,zero,8112de1c <___vfiprintf_internal_r+0x1140>
8112ddf8:	a2c0100c 	andi	r11,r20,64
8112ddfc:	58000726 	beq	r11,zero,8112de1c <___vfiprintf_internal_r+0x1140>
8112de00:	da802217 	ldw	r10,136(sp)
8112de04:	50800017 	ldw	r2,0(r10)
8112de08:	52800104 	addi	r10,r10,4
8112de0c:	da802215 	stw	r10,136(sp)
8112de10:	da802317 	ldw	r10,140(sp)
8112de14:	1280000d 	sth	r10,0(r2)
8112de18:	003be706 	br	8112cdb8 <__reset+0xfb10cdb8>
8112de1c:	da802217 	ldw	r10,136(sp)
8112de20:	50800017 	ldw	r2,0(r10)
8112de24:	52800104 	addi	r10,r10,4
8112de28:	da802215 	stw	r10,136(sp)
8112de2c:	da802317 	ldw	r10,140(sp)
8112de30:	12800015 	stw	r10,0(r2)
8112de34:	003be006 	br	8112cdb8 <__reset+0xfb10cdb8>
8112de38:	a080100c 	andi	r2,r20,64
8112de3c:	da802217 	ldw	r10,136(sp)
8112de40:	10003026 	beq	r2,zero,8112df04 <___vfiprintf_internal_r+0x1228>
8112de44:	5480000b 	ldhu	r18,0(r10)
8112de48:	52800104 	addi	r10,r10,4
8112de4c:	0027883a 	mov	r19,zero
8112de50:	da802215 	stw	r10,136(sp)
8112de54:	003d8006 	br	8112d458 <__reset+0xfb10d458>
8112de58:	80c00007 	ldb	r3,0(r16)
8112de5c:	003c0006 	br	8112ce60 <__reset+0xfb10ce60>
8112de60:	a080100c 	andi	r2,r20,64
8112de64:	d8001d85 	stb	zero,118(sp)
8112de68:	da802217 	ldw	r10,136(sp)
8112de6c:	1000201e 	bne	r2,zero,8112def0 <___vfiprintf_internal_r+0x1214>
8112de70:	50800104 	addi	r2,r10,4
8112de74:	54800017 	ldw	r18,0(r10)
8112de78:	0027883a 	mov	r19,zero
8112de7c:	483def0e 	bge	r9,zero,8112d63c <__reset+0xfb10d63c>
8112de80:	94c6b03a 	or	r3,r18,r19
8112de84:	d8802215 	stw	r2,136(sp)
8112de88:	183d4e1e 	bne	r3,zero,8112d3c4 <__reset+0xfb10d3c4>
8112de8c:	0039883a 	mov	fp,zero
8112de90:	0005883a 	mov	r2,zero
8112de94:	003e0606 	br	8112d6b0 <__reset+0xfb10d6b0>
8112de98:	d9402117 	ldw	r5,132(sp)
8112de9c:	d9002017 	ldw	r4,128(sp)
8112dea0:	d9801a04 	addi	r6,sp,104
8112dea4:	da402c15 	stw	r9,176(sp)
8112dea8:	db802a15 	stw	r14,168(sp)
8112deac:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112deb0:	da402c17 	ldw	r9,176(sp)
8112deb4:	db802a17 	ldw	r14,168(sp)
8112deb8:	103ede1e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112debc:	d9401b17 	ldw	r5,108(sp)
8112dec0:	d8801c17 	ldw	r2,112(sp)
8112dec4:	d811883a 	mov	r8,sp
8112dec8:	29000044 	addi	r4,r5,1
8112decc:	003e7406 	br	8112d8a0 <__reset+0xfb10d8a0>
8112ded0:	00bfffc4 	movi	r2,-1
8112ded4:	003c5806 	br	8112d038 <__reset+0xfb10d038>
8112ded8:	d811883a 	mov	r8,sp
8112dedc:	003ee806 	br	8112da80 <__reset+0xfb10da80>
8112dee0:	000b883a 	mov	r5,zero
8112dee4:	01000044 	movi	r4,1
8112dee8:	d811883a 	mov	r8,sp
8112deec:	003e7c06 	br	8112d8e0 <__reset+0xfb10d8e0>
8112def0:	50800104 	addi	r2,r10,4
8112def4:	5480000b 	ldhu	r18,0(r10)
8112def8:	0027883a 	mov	r19,zero
8112defc:	483dcf0e 	bge	r9,zero,8112d63c <__reset+0xfb10d63c>
8112df00:	003fdf06 	br	8112de80 <__reset+0xfb10de80>
8112df04:	54800017 	ldw	r18,0(r10)
8112df08:	52800104 	addi	r10,r10,4
8112df0c:	0027883a 	mov	r19,zero
8112df10:	da802215 	stw	r10,136(sp)
8112df14:	003d5006 	br	8112d458 <__reset+0xfb10d458>
8112df18:	50800104 	addi	r2,r10,4
8112df1c:	5480000b 	ldhu	r18,0(r10)
8112df20:	0027883a 	mov	r19,zero
8112df24:	483f7d0e 	bge	r9,zero,8112dd1c <__reset+0xfb10dd1c>
8112df28:	003ddc06 	br	8112d69c <__reset+0xfb10d69c>
8112df2c:	d8c02215 	stw	r3,136(sp)
8112df30:	0039883a 	mov	fp,zero
8112df34:	003ddb06 	br	8112d6a4 <__reset+0xfb10d6a4>
8112df38:	02a04574 	movhi	r10,33045
8112df3c:	52b14504 	addi	r10,r10,-15084
8112df40:	da802415 	stw	r10,144(sp)
8112df44:	003e8306 	br	8112d954 <__reset+0xfb10d954>
8112df48:	d8801c17 	ldw	r2,112(sp)
8112df4c:	dd002117 	ldw	r20,132(sp)
8112df50:	103eb926 	beq	r2,zero,8112da38 <__reset+0xfb10da38>
8112df54:	d9002017 	ldw	r4,128(sp)
8112df58:	d9801a04 	addi	r6,sp,104
8112df5c:	a00b883a 	mov	r5,r20
8112df60:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112df64:	003eb406 	br	8112da38 <__reset+0xfb10da38>
8112df68:	80c00043 	ldbu	r3,1(r16)
8112df6c:	a5000814 	ori	r20,r20,32
8112df70:	84000044 	addi	r16,r16,1
8112df74:	18c03fcc 	andi	r3,r3,255
8112df78:	18c0201c 	xori	r3,r3,128
8112df7c:	18ffe004 	addi	r3,r3,-128
8112df80:	003bb706 	br	8112ce60 <__reset+0xfb10ce60>
8112df84:	a809883a 	mov	r4,r21
8112df88:	d8c02a15 	stw	r3,168(sp)
8112df8c:	da002b15 	stw	r8,172(sp)
8112df90:	111e5bc0 	call	8111e5bc <strlen>
8112df94:	d8c02a17 	ldw	r3,168(sp)
8112df98:	1027883a 	mov	r19,r2
8112df9c:	df001d83 	ldbu	fp,118(sp)
8112dfa0:	d8c02215 	stw	r3,136(sp)
8112dfa4:	0013883a 	mov	r9,zero
8112dfa8:	da002b17 	ldw	r8,172(sp)
8112dfac:	003c4d06 	br	8112d0e4 <__reset+0xfb10d0e4>
8112dfb0:	d9402117 	ldw	r5,132(sp)
8112dfb4:	d9002017 	ldw	r4,128(sp)
8112dfb8:	d9801a04 	addi	r6,sp,104
8112dfbc:	da402c15 	stw	r9,176(sp)
8112dfc0:	112cbc00 	call	8112cbc0 <__sprint_r.part.0>
8112dfc4:	da402c17 	ldw	r9,176(sp)
8112dfc8:	103e9a1e 	bne	r2,zero,8112da34 <__reset+0xfb10da34>
8112dfcc:	d9401b17 	ldw	r5,108(sp)
8112dfd0:	d8801c17 	ldw	r2,112(sp)
8112dfd4:	d811883a 	mov	r8,sp
8112dfd8:	29000044 	addi	r4,r5,1
8112dfdc:	003e4206 	br	8112d8e8 <__reset+0xfb10d8e8>
8112dfe0:	d9401b17 	ldw	r5,108(sp)
8112dfe4:	01204574 	movhi	r4,33045
8112dfe8:	21314904 	addi	r4,r4,-15068
8112dfec:	d9002415 	stw	r4,144(sp)
8112dff0:	29400044 	addi	r5,r5,1
8112dff4:	003c6d06 	br	8112d1ac <__reset+0xfb10d1ac>
8112dff8:	0039883a 	mov	fp,zero
8112dffc:	00800084 	movi	r2,2
8112e000:	10803fcc 	andi	r2,r2,255
8112e004:	01000044 	movi	r4,1
8112e008:	11001e26 	beq	r2,r4,8112e084 <___vfiprintf_internal_r+0x13a8>
8112e00c:	01000084 	movi	r4,2
8112e010:	11001e1e 	bne	r2,r4,8112e08c <___vfiprintf_internal_r+0x13b0>
8112e014:	1829883a 	mov	r20,r3
8112e018:	003eea06 	br	8112dbc4 <__reset+0xfb10dbc4>
8112e01c:	a007883a 	mov	r3,r20
8112e020:	00800044 	movi	r2,1
8112e024:	003ff606 	br	8112e000 <__reset+0xfb10e000>
8112e028:	00800184 	movi	r2,6
8112e02c:	1240012e 	bgeu	r2,r9,8112e034 <___vfiprintf_internal_r+0x1358>
8112e030:	1013883a 	mov	r9,r2
8112e034:	4827883a 	mov	r19,r9
8112e038:	4825883a 	mov	r18,r9
8112e03c:	48001516 	blt	r9,zero,8112e094 <___vfiprintf_internal_r+0x13b8>
8112e040:	05604574 	movhi	r21,33045
8112e044:	d8c02215 	stw	r3,136(sp)
8112e048:	ad70b804 	addi	r21,r21,-15648
8112e04c:	003d1406 	br	8112d4a0 <__reset+0xfb10d4a0>
8112e050:	02a04574 	movhi	r10,33045
8112e054:	52b14504 	addi	r10,r10,-15084
8112e058:	da802415 	stw	r10,144(sp)
8112e05c:	200d883a 	mov	r6,r4
8112e060:	003c9106 	br	8112d2a8 <__reset+0xfb10d2a8>
8112e064:	5021883a 	mov	r16,r10
8112e068:	0013883a 	mov	r9,zero
8112e06c:	003b7d06 	br	8112ce64 <__reset+0xfb10ce64>
8112e070:	4827883a 	mov	r19,r9
8112e074:	df001d83 	ldbu	fp,118(sp)
8112e078:	d8c02215 	stw	r3,136(sp)
8112e07c:	0013883a 	mov	r9,zero
8112e080:	003c1806 	br	8112d0e4 <__reset+0xfb10d0e4>
8112e084:	1829883a 	mov	r20,r3
8112e088:	003d1806 	br	8112d4ec <__reset+0xfb10d4ec>
8112e08c:	1829883a 	mov	r20,r3
8112e090:	003ccd06 	br	8112d3c8 <__reset+0xfb10d3c8>
8112e094:	0025883a 	mov	r18,zero
8112e098:	003fe906 	br	8112e040 <__reset+0xfb10e040>
8112e09c:	d8802217 	ldw	r2,136(sp)
8112e0a0:	80c00043 	ldbu	r3,1(r16)
8112e0a4:	5021883a 	mov	r16,r10
8112e0a8:	12400017 	ldw	r9,0(r2)
8112e0ac:	10800104 	addi	r2,r2,4
8112e0b0:	d8802215 	stw	r2,136(sp)
8112e0b4:	483faf0e 	bge	r9,zero,8112df74 <__reset+0xfb10df74>
8112e0b8:	18c03fcc 	andi	r3,r3,255
8112e0bc:	18c0201c 	xori	r3,r3,128
8112e0c0:	027fffc4 	movi	r9,-1
8112e0c4:	18ffe004 	addi	r3,r3,-128
8112e0c8:	003b6506 	br	8112ce60 <__reset+0xfb10ce60>
8112e0cc:	d9c01d85 	stb	r7,118(sp)
8112e0d0:	003ca006 	br	8112d354 <__reset+0xfb10d354>
8112e0d4:	d9c01d85 	stb	r7,118(sp)
8112e0d8:	003cad06 	br	8112d390 <__reset+0xfb10d390>
8112e0dc:	d9c01d85 	stb	r7,118(sp)
8112e0e0:	003d7d06 	br	8112d6d8 <__reset+0xfb10d6d8>
8112e0e4:	d9c01d85 	stb	r7,118(sp)
8112e0e8:	003d5f06 	br	8112d668 <__reset+0xfb10d668>
8112e0ec:	a080004c 	andi	r2,r20,1
8112e0f0:	0039883a 	mov	fp,zero
8112e0f4:	10000526 	beq	r2,zero,8112e10c <___vfiprintf_internal_r+0x1430>
8112e0f8:	00800c04 	movi	r2,48
8112e0fc:	d88019c5 	stb	r2,103(sp)
8112e100:	dcc02717 	ldw	r19,156(sp)
8112e104:	dd4019c4 	addi	r21,sp,103
8112e108:	003bf606 	br	8112d0e4 <__reset+0xfb10d0e4>
8112e10c:	0027883a 	mov	r19,zero
8112e110:	dd401a04 	addi	r21,sp,104
8112e114:	003bf306 	br	8112d0e4 <__reset+0xfb10d0e4>
8112e118:	d9c01d85 	stb	r7,118(sp)
8112e11c:	003dc806 	br	8112d840 <__reset+0xfb10d840>
8112e120:	d9c01d85 	stb	r7,118(sp)
8112e124:	003d3a06 	br	8112d610 <__reset+0xfb10d610>
8112e128:	d9c01d85 	stb	r7,118(sp)
8112e12c:	003d2a06 	br	8112d5d8 <__reset+0xfb10d5d8>
8112e130:	d9c01d85 	stb	r7,118(sp)
8112e134:	003cde06 	br	8112d4b0 <__reset+0xfb10d4b0>
8112e138:	d9c01d85 	stb	r7,118(sp)
8112e13c:	003cbc06 	br	8112d430 <__reset+0xfb10d430>

8112e140 <__vfiprintf_internal>:
8112e140:	00a04574 	movhi	r2,33045
8112e144:	10ba8204 	addi	r2,r2,-5624
8112e148:	300f883a 	mov	r7,r6
8112e14c:	280d883a 	mov	r6,r5
8112e150:	200b883a 	mov	r5,r4
8112e154:	11000017 	ldw	r4,0(r2)
8112e158:	112ccdc1 	jmpi	8112ccdc <___vfiprintf_internal_r>

8112e15c <__sbprintf>:
8112e15c:	defee204 	addi	sp,sp,-1144
8112e160:	de00012e 	bgeu	sp,et,8112e168 <__sbprintf+0xc>
8112e164:	003b68fa 	trap	3
8112e168:	2880030b 	ldhu	r2,12(r5)
8112e16c:	2ac01917 	ldw	r11,100(r5)
8112e170:	2a80038b 	ldhu	r10,14(r5)
8112e174:	2a400717 	ldw	r9,28(r5)
8112e178:	2a000917 	ldw	r8,36(r5)
8112e17c:	00c10004 	movi	r3,1024
8112e180:	dc011a15 	stw	r16,1128(sp)
8112e184:	10bfff4c 	andi	r2,r2,65533
8112e188:	2821883a 	mov	r16,r5
8112e18c:	d8cb883a 	add	r5,sp,r3
8112e190:	dc811c15 	stw	r18,1136(sp)
8112e194:	dc411b15 	stw	r17,1132(sp)
8112e198:	dfc11d15 	stw	ra,1140(sp)
8112e19c:	2025883a 	mov	r18,r4
8112e1a0:	d881030d 	sth	r2,1036(sp)
8112e1a4:	dac11915 	stw	r11,1124(sp)
8112e1a8:	da81038d 	sth	r10,1038(sp)
8112e1ac:	da410715 	stw	r9,1052(sp)
8112e1b0:	da010915 	stw	r8,1060(sp)
8112e1b4:	dec10015 	stw	sp,1024(sp)
8112e1b8:	dec10415 	stw	sp,1040(sp)
8112e1bc:	d8c10215 	stw	r3,1032(sp)
8112e1c0:	d8c10515 	stw	r3,1044(sp)
8112e1c4:	d8010615 	stw	zero,1048(sp)
8112e1c8:	112ccdc0 	call	8112ccdc <___vfiprintf_internal_r>
8112e1cc:	1023883a 	mov	r17,r2
8112e1d0:	10000416 	blt	r2,zero,8112e1e4 <__sbprintf+0x88>
8112e1d4:	d9410004 	addi	r5,sp,1024
8112e1d8:	9009883a 	mov	r4,r18
8112e1dc:	11264940 	call	81126494 <_fflush_r>
8112e1e0:	10000d1e 	bne	r2,zero,8112e218 <__sbprintf+0xbc>
8112e1e4:	d881030b 	ldhu	r2,1036(sp)
8112e1e8:	1080100c 	andi	r2,r2,64
8112e1ec:	10000326 	beq	r2,zero,8112e1fc <__sbprintf+0xa0>
8112e1f0:	8080030b 	ldhu	r2,12(r16)
8112e1f4:	10801014 	ori	r2,r2,64
8112e1f8:	8080030d 	sth	r2,12(r16)
8112e1fc:	8805883a 	mov	r2,r17
8112e200:	dfc11d17 	ldw	ra,1140(sp)
8112e204:	dc811c17 	ldw	r18,1136(sp)
8112e208:	dc411b17 	ldw	r17,1132(sp)
8112e20c:	dc011a17 	ldw	r16,1128(sp)
8112e210:	dec11e04 	addi	sp,sp,1144
8112e214:	f800283a 	ret
8112e218:	047fffc4 	movi	r17,-1
8112e21c:	003ff106 	br	8112e1e4 <__reset+0xfb10e1e4>

8112e220 <_calloc_r>:
8112e220:	298b383a 	mul	r5,r5,r6
8112e224:	defffe04 	addi	sp,sp,-8
8112e228:	de00012e 	bgeu	sp,et,8112e230 <_calloc_r+0x10>
8112e22c:	003b68fa 	trap	3
8112e230:	dfc00115 	stw	ra,4(sp)
8112e234:	dc000015 	stw	r16,0(sp)
8112e238:	111d2b40 	call	8111d2b4 <_malloc_r>
8112e23c:	10002926 	beq	r2,zero,8112e2e4 <_calloc_r+0xc4>
8112e240:	11bfff17 	ldw	r6,-4(r2)
8112e244:	1021883a 	mov	r16,r2
8112e248:	00bfff04 	movi	r2,-4
8112e24c:	308c703a 	and	r6,r6,r2
8112e250:	00c00904 	movi	r3,36
8112e254:	308d883a 	add	r6,r6,r2
8112e258:	19801636 	bltu	r3,r6,8112e2b4 <_calloc_r+0x94>
8112e25c:	008004c4 	movi	r2,19
8112e260:	11800b2e 	bgeu	r2,r6,8112e290 <_calloc_r+0x70>
8112e264:	80000015 	stw	zero,0(r16)
8112e268:	80000115 	stw	zero,4(r16)
8112e26c:	008006c4 	movi	r2,27
8112e270:	11801a2e 	bgeu	r2,r6,8112e2dc <_calloc_r+0xbc>
8112e274:	80000215 	stw	zero,8(r16)
8112e278:	80000315 	stw	zero,12(r16)
8112e27c:	30c0151e 	bne	r6,r3,8112e2d4 <_calloc_r+0xb4>
8112e280:	80000415 	stw	zero,16(r16)
8112e284:	80800604 	addi	r2,r16,24
8112e288:	80000515 	stw	zero,20(r16)
8112e28c:	00000106 	br	8112e294 <_calloc_r+0x74>
8112e290:	8005883a 	mov	r2,r16
8112e294:	10000015 	stw	zero,0(r2)
8112e298:	10000115 	stw	zero,4(r2)
8112e29c:	10000215 	stw	zero,8(r2)
8112e2a0:	8005883a 	mov	r2,r16
8112e2a4:	dfc00117 	ldw	ra,4(sp)
8112e2a8:	dc000017 	ldw	r16,0(sp)
8112e2ac:	dec00204 	addi	sp,sp,8
8112e2b0:	f800283a 	ret
8112e2b4:	000b883a 	mov	r5,zero
8112e2b8:	8009883a 	mov	r4,r16
8112e2bc:	111dc180 	call	8111dc18 <memset>
8112e2c0:	8005883a 	mov	r2,r16
8112e2c4:	dfc00117 	ldw	ra,4(sp)
8112e2c8:	dc000017 	ldw	r16,0(sp)
8112e2cc:	dec00204 	addi	sp,sp,8
8112e2d0:	f800283a 	ret
8112e2d4:	80800404 	addi	r2,r16,16
8112e2d8:	003fee06 	br	8112e294 <__reset+0xfb10e294>
8112e2dc:	80800204 	addi	r2,r16,8
8112e2e0:	003fec06 	br	8112e294 <__reset+0xfb10e294>
8112e2e4:	0005883a 	mov	r2,zero
8112e2e8:	003fee06 	br	8112e2a4 <__reset+0xfb10e2a4>

8112e2ec <_fclose_r>:
8112e2ec:	28003b26 	beq	r5,zero,8112e3dc <_fclose_r+0xf0>
8112e2f0:	defffc04 	addi	sp,sp,-16
8112e2f4:	de00012e 	bgeu	sp,et,8112e2fc <_fclose_r+0x10>
8112e2f8:	003b68fa 	trap	3
8112e2fc:	dc400115 	stw	r17,4(sp)
8112e300:	dc000015 	stw	r16,0(sp)
8112e304:	dfc00315 	stw	ra,12(sp)
8112e308:	dc800215 	stw	r18,8(sp)
8112e30c:	2023883a 	mov	r17,r4
8112e310:	2821883a 	mov	r16,r5
8112e314:	20000226 	beq	r4,zero,8112e320 <_fclose_r+0x34>
8112e318:	20800e17 	ldw	r2,56(r4)
8112e31c:	10002726 	beq	r2,zero,8112e3bc <_fclose_r+0xd0>
8112e320:	8080030f 	ldh	r2,12(r16)
8112e324:	1000071e 	bne	r2,zero,8112e344 <_fclose_r+0x58>
8112e328:	0005883a 	mov	r2,zero
8112e32c:	dfc00317 	ldw	ra,12(sp)
8112e330:	dc800217 	ldw	r18,8(sp)
8112e334:	dc400117 	ldw	r17,4(sp)
8112e338:	dc000017 	ldw	r16,0(sp)
8112e33c:	dec00404 	addi	sp,sp,16
8112e340:	f800283a 	ret
8112e344:	800b883a 	mov	r5,r16
8112e348:	8809883a 	mov	r4,r17
8112e34c:	11262700 	call	81126270 <__sflush_r>
8112e350:	1025883a 	mov	r18,r2
8112e354:	80800b17 	ldw	r2,44(r16)
8112e358:	10000426 	beq	r2,zero,8112e36c <_fclose_r+0x80>
8112e35c:	81400717 	ldw	r5,28(r16)
8112e360:	8809883a 	mov	r4,r17
8112e364:	103ee83a 	callr	r2
8112e368:	10001616 	blt	r2,zero,8112e3c4 <_fclose_r+0xd8>
8112e36c:	8080030b 	ldhu	r2,12(r16)
8112e370:	1080200c 	andi	r2,r2,128
8112e374:	1000151e 	bne	r2,zero,8112e3cc <_fclose_r+0xe0>
8112e378:	81400c17 	ldw	r5,48(r16)
8112e37c:	28000526 	beq	r5,zero,8112e394 <_fclose_r+0xa8>
8112e380:	80801004 	addi	r2,r16,64
8112e384:	28800226 	beq	r5,r2,8112e390 <_fclose_r+0xa4>
8112e388:	8809883a 	mov	r4,r17
8112e38c:	1126d280 	call	81126d28 <_free_r>
8112e390:	80000c15 	stw	zero,48(r16)
8112e394:	81401117 	ldw	r5,68(r16)
8112e398:	28000326 	beq	r5,zero,8112e3a8 <_fclose_r+0xbc>
8112e39c:	8809883a 	mov	r4,r17
8112e3a0:	1126d280 	call	81126d28 <_free_r>
8112e3a4:	80001115 	stw	zero,68(r16)
8112e3a8:	11268a00 	call	811268a0 <__sfp_lock_acquire>
8112e3ac:	8000030d 	sth	zero,12(r16)
8112e3b0:	11268a40 	call	811268a4 <__sfp_lock_release>
8112e3b4:	9005883a 	mov	r2,r18
8112e3b8:	003fdc06 	br	8112e32c <__reset+0xfb10e32c>
8112e3bc:	11268900 	call	81126890 <__sinit>
8112e3c0:	003fd706 	br	8112e320 <__reset+0xfb10e320>
8112e3c4:	04bfffc4 	movi	r18,-1
8112e3c8:	003fe806 	br	8112e36c <__reset+0xfb10e36c>
8112e3cc:	81400417 	ldw	r5,16(r16)
8112e3d0:	8809883a 	mov	r4,r17
8112e3d4:	1126d280 	call	81126d28 <_free_r>
8112e3d8:	003fe706 	br	8112e378 <__reset+0xfb10e378>
8112e3dc:	0005883a 	mov	r2,zero
8112e3e0:	f800283a 	ret

8112e3e4 <fclose>:
8112e3e4:	00a04574 	movhi	r2,33045
8112e3e8:	10ba8204 	addi	r2,r2,-5624
8112e3ec:	200b883a 	mov	r5,r4
8112e3f0:	11000017 	ldw	r4,0(r2)
8112e3f4:	112e2ec1 	jmpi	8112e2ec <_fclose_r>

8112e3f8 <__fputwc>:
8112e3f8:	defff804 	addi	sp,sp,-32
8112e3fc:	de00012e 	bgeu	sp,et,8112e404 <__fputwc+0xc>
8112e400:	003b68fa 	trap	3
8112e404:	dcc00415 	stw	r19,16(sp)
8112e408:	dc800315 	stw	r18,12(sp)
8112e40c:	dc000115 	stw	r16,4(sp)
8112e410:	dfc00715 	stw	ra,28(sp)
8112e414:	dd400615 	stw	r21,24(sp)
8112e418:	dd000515 	stw	r20,20(sp)
8112e41c:	dc400215 	stw	r17,8(sp)
8112e420:	2027883a 	mov	r19,r4
8112e424:	2825883a 	mov	r18,r5
8112e428:	3021883a 	mov	r16,r6
8112e42c:	11277b80 	call	811277b8 <__locale_mb_cur_max>
8112e430:	00c00044 	movi	r3,1
8112e434:	10c03e26 	beq	r2,r3,8112e530 <__fputwc+0x138>
8112e438:	81c01704 	addi	r7,r16,92
8112e43c:	900d883a 	mov	r6,r18
8112e440:	d80b883a 	mov	r5,sp
8112e444:	9809883a 	mov	r4,r19
8112e448:	112f27c0 	call	8112f27c <_wcrtomb_r>
8112e44c:	1029883a 	mov	r20,r2
8112e450:	00bfffc4 	movi	r2,-1
8112e454:	a0802026 	beq	r20,r2,8112e4d8 <__fputwc+0xe0>
8112e458:	d9400003 	ldbu	r5,0(sp)
8112e45c:	a0001c26 	beq	r20,zero,8112e4d0 <__fputwc+0xd8>
8112e460:	0023883a 	mov	r17,zero
8112e464:	05400284 	movi	r21,10
8112e468:	00000906 	br	8112e490 <__fputwc+0x98>
8112e46c:	80800017 	ldw	r2,0(r16)
8112e470:	11400005 	stb	r5,0(r2)
8112e474:	80c00017 	ldw	r3,0(r16)
8112e478:	18c00044 	addi	r3,r3,1
8112e47c:	80c00015 	stw	r3,0(r16)
8112e480:	8c400044 	addi	r17,r17,1
8112e484:	dc45883a 	add	r2,sp,r17
8112e488:	8d00112e 	bgeu	r17,r20,8112e4d0 <__fputwc+0xd8>
8112e48c:	11400003 	ldbu	r5,0(r2)
8112e490:	80c00217 	ldw	r3,8(r16)
8112e494:	18ffffc4 	addi	r3,r3,-1
8112e498:	80c00215 	stw	r3,8(r16)
8112e49c:	183ff30e 	bge	r3,zero,8112e46c <__reset+0xfb10e46c>
8112e4a0:	80800617 	ldw	r2,24(r16)
8112e4a4:	18801916 	blt	r3,r2,8112e50c <__fputwc+0x114>
8112e4a8:	80800017 	ldw	r2,0(r16)
8112e4ac:	11400005 	stb	r5,0(r2)
8112e4b0:	80800017 	ldw	r2,0(r16)
8112e4b4:	10c00003 	ldbu	r3,0(r2)
8112e4b8:	10800044 	addi	r2,r2,1
8112e4bc:	1d402326 	beq	r3,r21,8112e54c <__fputwc+0x154>
8112e4c0:	80800015 	stw	r2,0(r16)
8112e4c4:	8c400044 	addi	r17,r17,1
8112e4c8:	dc45883a 	add	r2,sp,r17
8112e4cc:	8d3fef36 	bltu	r17,r20,8112e48c <__reset+0xfb10e48c>
8112e4d0:	9005883a 	mov	r2,r18
8112e4d4:	00000406 	br	8112e4e8 <__fputwc+0xf0>
8112e4d8:	80c0030b 	ldhu	r3,12(r16)
8112e4dc:	a005883a 	mov	r2,r20
8112e4e0:	18c01014 	ori	r3,r3,64
8112e4e4:	80c0030d 	sth	r3,12(r16)
8112e4e8:	dfc00717 	ldw	ra,28(sp)
8112e4ec:	dd400617 	ldw	r21,24(sp)
8112e4f0:	dd000517 	ldw	r20,20(sp)
8112e4f4:	dcc00417 	ldw	r19,16(sp)
8112e4f8:	dc800317 	ldw	r18,12(sp)
8112e4fc:	dc400217 	ldw	r17,8(sp)
8112e500:	dc000117 	ldw	r16,4(sp)
8112e504:	dec00804 	addi	sp,sp,32
8112e508:	f800283a 	ret
8112e50c:	800d883a 	mov	r6,r16
8112e510:	29403fcc 	andi	r5,r5,255
8112e514:	9809883a 	mov	r4,r19
8112e518:	11246580 	call	81124658 <__swbuf_r>
8112e51c:	10bfffe0 	cmpeqi	r2,r2,-1
8112e520:	10803fcc 	andi	r2,r2,255
8112e524:	103fd626 	beq	r2,zero,8112e480 <__reset+0xfb10e480>
8112e528:	00bfffc4 	movi	r2,-1
8112e52c:	003fee06 	br	8112e4e8 <__reset+0xfb10e4e8>
8112e530:	90ffffc4 	addi	r3,r18,-1
8112e534:	01003f84 	movi	r4,254
8112e538:	20ffbf36 	bltu	r4,r3,8112e438 <__reset+0xfb10e438>
8112e53c:	900b883a 	mov	r5,r18
8112e540:	dc800005 	stb	r18,0(sp)
8112e544:	1029883a 	mov	r20,r2
8112e548:	003fc506 	br	8112e460 <__reset+0xfb10e460>
8112e54c:	800d883a 	mov	r6,r16
8112e550:	a80b883a 	mov	r5,r21
8112e554:	9809883a 	mov	r4,r19
8112e558:	11246580 	call	81124658 <__swbuf_r>
8112e55c:	10bfffe0 	cmpeqi	r2,r2,-1
8112e560:	003fef06 	br	8112e520 <__reset+0xfb10e520>

8112e564 <_fputwc_r>:
8112e564:	3080030b 	ldhu	r2,12(r6)
8112e568:	10c8000c 	andi	r3,r2,8192
8112e56c:	1800051e 	bne	r3,zero,8112e584 <_fputwc_r+0x20>
8112e570:	30c01917 	ldw	r3,100(r6)
8112e574:	10880014 	ori	r2,r2,8192
8112e578:	3080030d 	sth	r2,12(r6)
8112e57c:	18880014 	ori	r2,r3,8192
8112e580:	30801915 	stw	r2,100(r6)
8112e584:	112e3f81 	jmpi	8112e3f8 <__fputwc>

8112e588 <fputwc>:
8112e588:	00a04574 	movhi	r2,33045
8112e58c:	defffc04 	addi	sp,sp,-16
8112e590:	10ba8204 	addi	r2,r2,-5624
8112e594:	de00012e 	bgeu	sp,et,8112e59c <fputwc+0x14>
8112e598:	003b68fa 	trap	3
8112e59c:	dc000115 	stw	r16,4(sp)
8112e5a0:	14000017 	ldw	r16,0(r2)
8112e5a4:	dc400215 	stw	r17,8(sp)
8112e5a8:	dfc00315 	stw	ra,12(sp)
8112e5ac:	2023883a 	mov	r17,r4
8112e5b0:	80000226 	beq	r16,zero,8112e5bc <fputwc+0x34>
8112e5b4:	80800e17 	ldw	r2,56(r16)
8112e5b8:	10001026 	beq	r2,zero,8112e5fc <fputwc+0x74>
8112e5bc:	2880030b 	ldhu	r2,12(r5)
8112e5c0:	10c8000c 	andi	r3,r2,8192
8112e5c4:	1800051e 	bne	r3,zero,8112e5dc <fputwc+0x54>
8112e5c8:	28c01917 	ldw	r3,100(r5)
8112e5cc:	10880014 	ori	r2,r2,8192
8112e5d0:	2880030d 	sth	r2,12(r5)
8112e5d4:	18880014 	ori	r2,r3,8192
8112e5d8:	28801915 	stw	r2,100(r5)
8112e5dc:	280d883a 	mov	r6,r5
8112e5e0:	8009883a 	mov	r4,r16
8112e5e4:	880b883a 	mov	r5,r17
8112e5e8:	dfc00317 	ldw	ra,12(sp)
8112e5ec:	dc400217 	ldw	r17,8(sp)
8112e5f0:	dc000117 	ldw	r16,4(sp)
8112e5f4:	dec00404 	addi	sp,sp,16
8112e5f8:	112e3f81 	jmpi	8112e3f8 <__fputwc>
8112e5fc:	8009883a 	mov	r4,r16
8112e600:	d9400015 	stw	r5,0(sp)
8112e604:	11268900 	call	81126890 <__sinit>
8112e608:	d9400017 	ldw	r5,0(sp)
8112e60c:	003feb06 	br	8112e5bc <__reset+0xfb10e5bc>

8112e610 <rshift>:
8112e610:	2807d17a 	srai	r3,r5,5
8112e614:	20800417 	ldw	r2,16(r4)
8112e618:	22000504 	addi	r8,r4,20
8112e61c:	1880250e 	bge	r3,r2,8112e6b4 <rshift+0xa4>
8112e620:	1085883a 	add	r2,r2,r2
8112e624:	18c7883a 	add	r3,r3,r3
8112e628:	1085883a 	add	r2,r2,r2
8112e62c:	18c7883a 	add	r3,r3,r3
8112e630:	294007cc 	andi	r5,r5,31
8112e634:	4085883a 	add	r2,r8,r2
8112e638:	40c7883a 	add	r3,r8,r3
8112e63c:	28002026 	beq	r5,zero,8112e6c0 <rshift+0xb0>
8112e640:	19800017 	ldw	r6,0(r3)
8112e644:	02c00804 	movi	r11,32
8112e648:	19c00104 	addi	r7,r3,4
8112e64c:	5957c83a 	sub	r11,r11,r5
8112e650:	314cd83a 	srl	r6,r6,r5
8112e654:	38802c2e 	bgeu	r7,r2,8112e708 <rshift+0xf8>
8112e658:	4015883a 	mov	r10,r8
8112e65c:	3a400017 	ldw	r9,0(r7)
8112e660:	52800104 	addi	r10,r10,4
8112e664:	39c00104 	addi	r7,r7,4
8112e668:	4ad2983a 	sll	r9,r9,r11
8112e66c:	498cb03a 	or	r6,r9,r6
8112e670:	51bfff15 	stw	r6,-4(r10)
8112e674:	39bfff17 	ldw	r6,-4(r7)
8112e678:	314cd83a 	srl	r6,r6,r5
8112e67c:	38bff736 	bltu	r7,r2,8112e65c <__reset+0xfb10e65c>
8112e680:	10c7c83a 	sub	r3,r2,r3
8112e684:	18fffec4 	addi	r3,r3,-5
8112e688:	1806d0ba 	srli	r3,r3,2
8112e68c:	18c00044 	addi	r3,r3,1
8112e690:	18c7883a 	add	r3,r3,r3
8112e694:	18c7883a 	add	r3,r3,r3
8112e698:	40c7883a 	add	r3,r8,r3
8112e69c:	19800015 	stw	r6,0(r3)
8112e6a0:	30000126 	beq	r6,zero,8112e6a8 <rshift+0x98>
8112e6a4:	18c00104 	addi	r3,r3,4
8112e6a8:	1a05c83a 	sub	r2,r3,r8
8112e6ac:	1005d0ba 	srai	r2,r2,2
8112e6b0:	00001206 	br	8112e6fc <rshift+0xec>
8112e6b4:	20000415 	stw	zero,16(r4)
8112e6b8:	20000515 	stw	zero,20(r4)
8112e6bc:	f800283a 	ret
8112e6c0:	18bffc2e 	bgeu	r3,r2,8112e6b4 <__reset+0xfb10e6b4>
8112e6c4:	180d883a 	mov	r6,r3
8112e6c8:	400b883a 	mov	r5,r8
8112e6cc:	31c00017 	ldw	r7,0(r6)
8112e6d0:	29400104 	addi	r5,r5,4
8112e6d4:	31800104 	addi	r6,r6,4
8112e6d8:	29ffff15 	stw	r7,-4(r5)
8112e6dc:	30bffb36 	bltu	r6,r2,8112e6cc <__reset+0xfb10e6cc>
8112e6e0:	00c6303a 	nor	r3,zero,r3
8112e6e4:	1885883a 	add	r2,r3,r2
8112e6e8:	1004d0ba 	srli	r2,r2,2
8112e6ec:	10800044 	addi	r2,r2,1
8112e6f0:	1085883a 	add	r2,r2,r2
8112e6f4:	1085883a 	add	r2,r2,r2
8112e6f8:	1005d0ba 	srai	r2,r2,2
8112e6fc:	20800415 	stw	r2,16(r4)
8112e700:	103fed26 	beq	r2,zero,8112e6b8 <__reset+0xfb10e6b8>
8112e704:	f800283a 	ret
8112e708:	4007883a 	mov	r3,r8
8112e70c:	003fe306 	br	8112e69c <__reset+0xfb10e69c>

8112e710 <__gethex>:
8112e710:	deffeb04 	addi	sp,sp,-84
8112e714:	de00012e 	bgeu	sp,et,8112e71c <__gethex+0xc>
8112e718:	003b68fa 	trap	3
8112e71c:	dfc01415 	stw	ra,80(sp)
8112e720:	dd801115 	stw	r22,68(sp)
8112e724:	dcc00e15 	stw	r19,56(sp)
8112e728:	dc800d15 	stw	r18,52(sp)
8112e72c:	2827883a 	mov	r19,r5
8112e730:	d9000115 	stw	r4,4(sp)
8112e734:	d9800015 	stw	r6,0(sp)
8112e738:	d9c00415 	stw	r7,16(sp)
8112e73c:	df001315 	stw	fp,76(sp)
8112e740:	ddc01215 	stw	r23,72(sp)
8112e744:	dd401015 	stw	r21,64(sp)
8112e748:	dd000f15 	stw	r20,60(sp)
8112e74c:	dc400c15 	stw	r17,48(sp)
8112e750:	dc000b15 	stw	r16,44(sp)
8112e754:	11277dc0 	call	811277dc <_localeconv_r>
8112e758:	14800017 	ldw	r18,0(r2)
8112e75c:	9009883a 	mov	r4,r18
8112e760:	111e5bc0 	call	8111e5bc <strlen>
8112e764:	98c00017 	ldw	r3,0(r19)
8112e768:	102d883a 	mov	r22,r2
8112e76c:	9085883a 	add	r2,r18,r2
8112e770:	10bfffc3 	ldbu	r2,-1(r2)
8112e774:	19000083 	ldbu	r4,2(r3)
8112e778:	d8800305 	stb	r2,12(sp)
8112e77c:	00800c04 	movi	r2,48
8112e780:	2081521e 	bne	r4,r2,8112eccc <__gethex+0x5bc>
8112e784:	017fff84 	movi	r5,-2
8112e788:	188000c4 	addi	r2,r3,3
8112e78c:	28cbc83a 	sub	r5,r5,r3
8112e790:	200d883a 	mov	r6,r4
8112e794:	28a3883a 	add	r17,r5,r2
8112e798:	102b883a 	mov	r21,r2
8112e79c:	10800044 	addi	r2,r2,1
8112e7a0:	113fffc3 	ldbu	r4,-1(r2)
8112e7a4:	21bffb26 	beq	r4,r6,8112e794 <__reset+0xfb10e794>
8112e7a8:	05204574 	movhi	r20,33045
8112e7ac:	a5314d04 	addi	r20,r20,-15052
8112e7b0:	a109883a 	add	r4,r20,r4
8112e7b4:	20800003 	ldbu	r2,0(r4)
8112e7b8:	10008826 	beq	r2,zero,8112e9dc <__gethex+0x2cc>
8112e7bc:	a8800003 	ldbu	r2,0(r21)
8112e7c0:	0015883a 	mov	r10,zero
8112e7c4:	002f883a 	mov	r23,zero
8112e7c8:	a085883a 	add	r2,r20,r2
8112e7cc:	10800003 	ldbu	r2,0(r2)
8112e7d0:	a821883a 	mov	r16,r21
8112e7d4:	10000526 	beq	r2,zero,8112e7ec <__gethex+0xdc>
8112e7d8:	84000044 	addi	r16,r16,1
8112e7dc:	80800003 	ldbu	r2,0(r16)
8112e7e0:	a085883a 	add	r2,r20,r2
8112e7e4:	10800003 	ldbu	r2,0(r2)
8112e7e8:	103ffb1e 	bne	r2,zero,8112e7d8 <__reset+0xfb10e7d8>
8112e7ec:	b00d883a 	mov	r6,r22
8112e7f0:	900b883a 	mov	r5,r18
8112e7f4:	8009883a 	mov	r4,r16
8112e7f8:	da800a15 	stw	r10,40(sp)
8112e7fc:	112f1ac0 	call	8112f1ac <strncmp>
8112e800:	da800a17 	ldw	r10,40(sp)
8112e804:	1000031e 	bne	r2,zero,8112e814 <__gethex+0x104>
8112e808:	b8015226 	beq	r23,zero,8112ed54 <__gethex+0x644>
8112e80c:	80800003 	ldbu	r2,0(r16)
8112e810:	00000206 	br	8112e81c <__gethex+0x10c>
8112e814:	80800003 	ldbu	r2,0(r16)
8112e818:	b8011f26 	beq	r23,zero,8112ec98 <__gethex+0x588>
8112e81c:	85efc83a 	sub	r23,r16,r23
8112e820:	bdef883a 	add	r23,r23,r23
8112e824:	bdef883a 	add	r23,r23,r23
8112e828:	05efc83a 	sub	r23,zero,r23
8112e82c:	10803fcc 	andi	r2,r2,255
8112e830:	01001404 	movi	r4,80
8112e834:	11008626 	beq	r2,r4,8112ea50 <__gethex+0x340>
8112e838:	01001c04 	movi	r4,112
8112e83c:	11008426 	beq	r2,r4,8112ea50 <__gethex+0x340>
8112e840:	8039883a 	mov	fp,r16
8112e844:	9c000015 	stw	r16,0(r19)
8112e848:	5000711e 	bne	r10,zero,8112ea10 <__gethex+0x300>
8112e84c:	e545c83a 	sub	r2,fp,r21
8112e850:	10bfffc4 	addi	r2,r2,-1
8112e854:	010001c4 	movi	r4,7
8112e858:	000b883a 	mov	r5,zero
8112e85c:	2080030e 	bge	r4,r2,8112e86c <__gethex+0x15c>
8112e860:	1005d07a 	srai	r2,r2,1
8112e864:	29400044 	addi	r5,r5,1
8112e868:	20bffd16 	blt	r4,r2,8112e860 <__reset+0xfb10e860>
8112e86c:	d9000117 	ldw	r4,4(sp)
8112e870:	1127cf80 	call	81127cf8 <_Balloc>
8112e874:	10c00504 	addi	r3,r2,20
8112e878:	d8c00215 	stw	r3,8(sp)
8112e87c:	1021883a 	mov	r16,r2
8112e880:	af01732e 	bgeu	r21,fp,8112ee50 <__gethex+0x740>
8112e884:	dc400303 	ldbu	r17,12(sp)
8112e888:	03400044 	movi	r13,1
8112e88c:	1815883a 	mov	r10,r3
8112e890:	0013883a 	mov	r9,zero
8112e894:	0027883a 	mov	r19,zero
8112e898:	6d9bc83a 	sub	r13,r13,r22
8112e89c:	02c00804 	movi	r11,32
8112e8a0:	e0bfffc3 	ldbu	r2,-1(fp)
8112e8a4:	e3bfffc4 	addi	r14,fp,-1
8112e8a8:	88803026 	beq	r17,r2,8112e96c <__gethex+0x25c>
8112e8ac:	9ac04526 	beq	r19,r11,8112e9c4 <__gethex+0x2b4>
8112e8b0:	980b883a 	mov	r5,r19
8112e8b4:	9cc00104 	addi	r19,r19,4
8112e8b8:	e13fffc3 	ldbu	r4,-1(fp)
8112e8bc:	7039883a 	mov	fp,r14
8112e8c0:	a109883a 	add	r4,r20,r4
8112e8c4:	20800003 	ldbu	r2,0(r4)
8112e8c8:	108003cc 	andi	r2,r2,15
8112e8cc:	1144983a 	sll	r2,r2,r5
8112e8d0:	4892b03a 	or	r9,r9,r2
8112e8d4:	af3ff236 	bltu	r21,fp,8112e8a0 <__reset+0xfb10e8a0>
8112e8d8:	d8c00217 	ldw	r3,8(sp)
8112e8dc:	50800104 	addi	r2,r10,4
8112e8e0:	52400015 	stw	r9,0(r10)
8112e8e4:	10c5c83a 	sub	r2,r2,r3
8112e8e8:	1005d0ba 	srai	r2,r2,2
8112e8ec:	4809883a 	mov	r4,r9
8112e8f0:	80800415 	stw	r2,16(r16)
8112e8f4:	1022917a 	slli	r17,r2,5
8112e8f8:	11280040 	call	81128004 <__hi0bits>
8112e8fc:	d8c00017 	ldw	r3,0(sp)
8112e900:	8885c83a 	sub	r2,r17,r2
8112e904:	1c800017 	ldw	r18,0(r3)
8112e908:	9080c716 	blt	r18,r2,8112ec28 <__gethex+0x518>
8112e90c:	1480e416 	blt	r2,r18,8112eca0 <__gethex+0x590>
8112e910:	0027883a 	mov	r19,zero
8112e914:	d8c00017 	ldw	r3,0(sp)
8112e918:	18800217 	ldw	r2,8(r3)
8112e91c:	15c08d16 	blt	r2,r23,8112eb54 <__gethex+0x444>
8112e920:	d8c00017 	ldw	r3,0(sp)
8112e924:	18800117 	ldw	r2,4(r3)
8112e928:	b880aa0e 	bge	r23,r2,8112ebd4 <__gethex+0x4c4>
8112e92c:	15efc83a 	sub	r23,r2,r23
8112e930:	bc80ed16 	blt	r23,r18,8112ece8 <__gethex+0x5d8>
8112e934:	18c00317 	ldw	r3,12(r3)
8112e938:	01000084 	movi	r4,2
8112e93c:	19014926 	beq	r3,r4,8112ee64 <__gethex+0x754>
8112e940:	010000c4 	movi	r4,3
8112e944:	19012e26 	beq	r3,r4,8112ee00 <__gethex+0x6f0>
8112e948:	01000044 	movi	r4,1
8112e94c:	19014826 	beq	r3,r4,8112ee70 <__gethex+0x760>
8112e950:	d9000117 	ldw	r4,4(sp)
8112e954:	800b883a 	mov	r5,r16
8112e958:	1127da80 	call	81127da8 <_Bfree>
8112e95c:	d8801517 	ldw	r2,84(sp)
8112e960:	10000015 	stw	zero,0(r2)
8112e964:	00801404 	movi	r2,80
8112e968:	00002b06 	br	8112ea18 <__gethex+0x308>
8112e96c:	735f883a 	add	r15,r14,r13
8112e970:	7d7fce36 	bltu	r15,r21,8112e8ac <__reset+0xfb10e8ac>
8112e974:	7809883a 	mov	r4,r15
8112e978:	b00d883a 	mov	r6,r22
8112e97c:	900b883a 	mov	r5,r18
8112e980:	da400515 	stw	r9,20(sp)
8112e984:	da800a15 	stw	r10,40(sp)
8112e988:	dac00915 	stw	r11,36(sp)
8112e98c:	db400815 	stw	r13,32(sp)
8112e990:	db800615 	stw	r14,24(sp)
8112e994:	dbc00715 	stw	r15,28(sp)
8112e998:	112f1ac0 	call	8112f1ac <strncmp>
8112e99c:	da400517 	ldw	r9,20(sp)
8112e9a0:	da800a17 	ldw	r10,40(sp)
8112e9a4:	dac00917 	ldw	r11,36(sp)
8112e9a8:	db400817 	ldw	r13,32(sp)
8112e9ac:	db800617 	ldw	r14,24(sp)
8112e9b0:	dbc00717 	ldw	r15,28(sp)
8112e9b4:	103fbd1e 	bne	r2,zero,8112e8ac <__reset+0xfb10e8ac>
8112e9b8:	7839883a 	mov	fp,r15
8112e9bc:	af3fb836 	bltu	r21,fp,8112e8a0 <__reset+0xfb10e8a0>
8112e9c0:	003fc506 	br	8112e8d8 <__reset+0xfb10e8d8>
8112e9c4:	04c00104 	movi	r19,4
8112e9c8:	52400015 	stw	r9,0(r10)
8112e9cc:	000b883a 	mov	r5,zero
8112e9d0:	54d5883a 	add	r10,r10,r19
8112e9d4:	0013883a 	mov	r9,zero
8112e9d8:	003fb706 	br	8112e8b8 <__reset+0xfb10e8b8>
8112e9dc:	b00d883a 	mov	r6,r22
8112e9e0:	900b883a 	mov	r5,r18
8112e9e4:	a809883a 	mov	r4,r21
8112e9e8:	112f1ac0 	call	8112f1ac <strncmp>
8112e9ec:	10006426 	beq	r2,zero,8112eb80 <__gethex+0x470>
8112e9f0:	a8800003 	ldbu	r2,0(r21)
8112e9f4:	a821883a 	mov	r16,r21
8112e9f8:	10803fcc 	andi	r2,r2,255
8112e9fc:	01001404 	movi	r4,80
8112ea00:	11001126 	beq	r2,r4,8112ea48 <__gethex+0x338>
8112ea04:	01001c04 	movi	r4,112
8112ea08:	11000f26 	beq	r2,r4,8112ea48 <__gethex+0x338>
8112ea0c:	9c000015 	stw	r16,0(r19)
8112ea10:	8800831e 	bne	r17,zero,8112ec20 <__gethex+0x510>
8112ea14:	00800184 	movi	r2,6
8112ea18:	dfc01417 	ldw	ra,80(sp)
8112ea1c:	df001317 	ldw	fp,76(sp)
8112ea20:	ddc01217 	ldw	r23,72(sp)
8112ea24:	dd801117 	ldw	r22,68(sp)
8112ea28:	dd401017 	ldw	r21,64(sp)
8112ea2c:	dd000f17 	ldw	r20,60(sp)
8112ea30:	dcc00e17 	ldw	r19,56(sp)
8112ea34:	dc800d17 	ldw	r18,52(sp)
8112ea38:	dc400c17 	ldw	r17,48(sp)
8112ea3c:	dc000b17 	ldw	r16,44(sp)
8112ea40:	dec01504 	addi	sp,sp,84
8112ea44:	f800283a 	ret
8112ea48:	002f883a 	mov	r23,zero
8112ea4c:	02800044 	movi	r10,1
8112ea50:	80800043 	ldbu	r2,1(r16)
8112ea54:	01400ac4 	movi	r5,43
8112ea58:	11003fcc 	andi	r4,r2,255
8112ea5c:	21406e26 	beq	r4,r5,8112ec18 <__gethex+0x508>
8112ea60:	01400b44 	movi	r5,45
8112ea64:	21404226 	beq	r4,r5,8112eb70 <__gethex+0x460>
8112ea68:	81400044 	addi	r5,r16,1
8112ea6c:	000d883a 	mov	r6,zero
8112ea70:	10803fcc 	andi	r2,r2,255
8112ea74:	a085883a 	add	r2,r20,r2
8112ea78:	11000003 	ldbu	r4,0(r2)
8112ea7c:	03000604 	movi	r12,24
8112ea80:	20bfffc4 	addi	r2,r4,-1
8112ea84:	10803fcc 	andi	r2,r2,255
8112ea88:	60bf6d36 	bltu	r12,r2,8112e840 <__reset+0xfb10e840>
8112ea8c:	2ac00043 	ldbu	r11,1(r5)
8112ea90:	20803fcc 	andi	r2,r4,255
8112ea94:	01204574 	movhi	r4,33045
8112ea98:	21314d04 	addi	r4,r4,-15052
8112ea9c:	22c9883a 	add	r4,r4,r11
8112eaa0:	23400003 	ldbu	r13,0(r4)
8112eaa4:	10bffc04 	addi	r2,r2,-16
8112eaa8:	29400044 	addi	r5,r5,1
8112eaac:	693fffc4 	addi	r4,r13,-1
8112eab0:	21003fcc 	andi	r4,r4,255
8112eab4:	6b403fcc 	andi	r13,r13,255
8112eab8:	61000b36 	bltu	r12,r4,8112eae8 <__gethex+0x3d8>
8112eabc:	29400044 	addi	r5,r5,1
8112eac0:	29000003 	ldbu	r4,0(r5)
8112eac4:	108002a4 	muli	r2,r2,10
8112eac8:	a109883a 	add	r4,r20,r4
8112eacc:	22c00003 	ldbu	r11,0(r4)
8112ead0:	1345883a 	add	r2,r2,r13
8112ead4:	10bffc04 	addi	r2,r2,-16
8112ead8:	593fffc4 	addi	r4,r11,-1
8112eadc:	21003fcc 	andi	r4,r4,255
8112eae0:	5b403fcc 	andi	r13,r11,255
8112eae4:	613ff52e 	bgeu	r12,r4,8112eabc <__reset+0xfb10eabc>
8112eae8:	30000126 	beq	r6,zero,8112eaf0 <__gethex+0x3e0>
8112eaec:	0085c83a 	sub	r2,zero,r2
8112eaf0:	8039883a 	mov	fp,r16
8112eaf4:	b8af883a 	add	r23,r23,r2
8112eaf8:	2821883a 	mov	r16,r5
8112eafc:	003f5106 	br	8112e844 <__reset+0xfb10e844>
8112eb00:	80800217 	ldw	r2,8(r16)
8112eb04:	e080f00e 	bge	fp,r2,8112eec8 <__gethex+0x7b8>
8112eb08:	e007883a 	mov	r3,fp
8112eb0c:	18800144 	addi	r2,r3,5
8112eb10:	1085883a 	add	r2,r2,r2
8112eb14:	18c00044 	addi	r3,r3,1
8112eb18:	1085883a 	add	r2,r2,r2
8112eb1c:	8085883a 	add	r2,r16,r2
8112eb20:	80c00415 	stw	r3,16(r16)
8112eb24:	01000044 	movi	r4,1
8112eb28:	11000015 	stw	r4,0(r2)
8112eb2c:	00800084 	movi	r2,2
8112eb30:	8880d826 	beq	r17,r2,8112ee94 <__gethex+0x784>
8112eb34:	e0c0ac0e 	bge	fp,r3,8112ede8 <__gethex+0x6d8>
8112eb38:	01400044 	movi	r5,1
8112eb3c:	8009883a 	mov	r4,r16
8112eb40:	112e6100 	call	8112e610 <rshift>
8112eb44:	d8c00017 	ldw	r3,0(sp)
8112eb48:	bdc00044 	addi	r23,r23,1
8112eb4c:	18800217 	ldw	r2,8(r3)
8112eb50:	15c0a70e 	bge	r2,r23,8112edf0 <__gethex+0x6e0>
8112eb54:	d9000117 	ldw	r4,4(sp)
8112eb58:	800b883a 	mov	r5,r16
8112eb5c:	1127da80 	call	81127da8 <_Bfree>
8112eb60:	d9001517 	ldw	r4,84(sp)
8112eb64:	008028c4 	movi	r2,163
8112eb68:	20000015 	stw	zero,0(r4)
8112eb6c:	003faa06 	br	8112ea18 <__reset+0xfb10ea18>
8112eb70:	01800044 	movi	r6,1
8112eb74:	80800083 	ldbu	r2,2(r16)
8112eb78:	81400084 	addi	r5,r16,2
8112eb7c:	003fbc06 	br	8112ea70 <__reset+0xfb10ea70>
8112eb80:	ada1883a 	add	r16,r21,r22
8112eb84:	81000003 	ldbu	r4,0(r16)
8112eb88:	21403fcc 	andi	r5,r4,255
8112eb8c:	a145883a 	add	r2,r20,r5
8112eb90:	10800003 	ldbu	r2,0(r2)
8112eb94:	11803fcc 	andi	r6,r2,255
8112eb98:	30004f26 	beq	r6,zero,8112ecd8 <__gethex+0x5c8>
8112eb9c:	00c00c04 	movi	r3,48
8112eba0:	802b883a 	mov	r21,r16
8112eba4:	28c0061e 	bne	r5,r3,8112ebc0 <__gethex+0x4b0>
8112eba8:	2809883a 	mov	r4,r5
8112ebac:	ad400044 	addi	r21,r21,1
8112ebb0:	a8800003 	ldbu	r2,0(r21)
8112ebb4:	113ffd26 	beq	r2,r4,8112ebac <__reset+0xfb10ebac>
8112ebb8:	a085883a 	add	r2,r20,r2
8112ebbc:	10800003 	ldbu	r2,0(r2)
8112ebc0:	10803fcc 	andi	r2,r2,255
8112ebc4:	1015003a 	cmpeq	r10,r2,zero
8112ebc8:	802f883a 	mov	r23,r16
8112ebcc:	04400044 	movi	r17,1
8112ebd0:	003eff06 	br	8112e7d0 <__reset+0xfb10e7d0>
8112ebd4:	04400044 	movi	r17,1
8112ebd8:	98000926 	beq	r19,zero,8112ec00 <__gethex+0x4f0>
8112ebdc:	d8c00017 	ldw	r3,0(sp)
8112ebe0:	18800317 	ldw	r2,12(r3)
8112ebe4:	00c00084 	movi	r3,2
8112ebe8:	10c06826 	beq	r2,r3,8112ed8c <__gethex+0x67c>
8112ebec:	00c000c4 	movi	r3,3
8112ebf0:	10c06a26 	beq	r2,r3,8112ed9c <__gethex+0x68c>
8112ebf4:	00c00044 	movi	r3,1
8112ebf8:	10c08d26 	beq	r2,r3,8112ee30 <__gethex+0x720>
8112ebfc:	8c400414 	ori	r17,r17,16
8112ec00:	d9001517 	ldw	r4,84(sp)
8112ec04:	d8c00417 	ldw	r3,16(sp)
8112ec08:	8805883a 	mov	r2,r17
8112ec0c:	24000015 	stw	r16,0(r4)
8112ec10:	1dc00015 	stw	r23,0(r3)
8112ec14:	003f8006 	br	8112ea18 <__reset+0xfb10ea18>
8112ec18:	000d883a 	mov	r6,zero
8112ec1c:	003fd506 	br	8112eb74 <__reset+0xfb10eb74>
8112ec20:	0005883a 	mov	r2,zero
8112ec24:	003f7c06 	br	8112ea18 <__reset+0xfb10ea18>
8112ec28:	14a3c83a 	sub	r17,r2,r18
8112ec2c:	880b883a 	mov	r5,r17
8112ec30:	8009883a 	mov	r4,r16
8112ec34:	1128cc80 	call	81128cc8 <__any_on>
8112ec38:	10002926 	beq	r2,zero,8112ece0 <__gethex+0x5d0>
8112ec3c:	897fffc4 	addi	r5,r17,-1
8112ec40:	2807d17a 	srai	r3,r5,5
8112ec44:	d8800217 	ldw	r2,8(sp)
8112ec48:	290007cc 	andi	r4,r5,31
8112ec4c:	18c7883a 	add	r3,r3,r3
8112ec50:	18c7883a 	add	r3,r3,r3
8112ec54:	04c00044 	movi	r19,1
8112ec58:	10c7883a 	add	r3,r2,r3
8112ec5c:	9908983a 	sll	r4,r19,r4
8112ec60:	18c00017 	ldw	r3,0(r3)
8112ec64:	20c6703a 	and	r3,r4,r3
8112ec68:	18000626 	beq	r3,zero,8112ec84 <__gethex+0x574>
8112ec6c:	99407b0e 	bge	r19,r5,8112ee5c <__gethex+0x74c>
8112ec70:	897fff84 	addi	r5,r17,-2
8112ec74:	8009883a 	mov	r4,r16
8112ec78:	1128cc80 	call	81128cc8 <__any_on>
8112ec7c:	10007726 	beq	r2,zero,8112ee5c <__gethex+0x74c>
8112ec80:	04c000c4 	movi	r19,3
8112ec84:	880b883a 	mov	r5,r17
8112ec88:	8009883a 	mov	r4,r16
8112ec8c:	112e6100 	call	8112e610 <rshift>
8112ec90:	bc6f883a 	add	r23,r23,r17
8112ec94:	003f1f06 	br	8112e914 <__reset+0xfb10e914>
8112ec98:	002f883a 	mov	r23,zero
8112ec9c:	003ee306 	br	8112e82c <__reset+0xfb10e82c>
8112eca0:	d9000117 	ldw	r4,4(sp)
8112eca4:	90a3c83a 	sub	r17,r18,r2
8112eca8:	800b883a 	mov	r5,r16
8112ecac:	880d883a 	mov	r6,r17
8112ecb0:	11284a80 	call	811284a8 <__lshift>
8112ecb4:	10c00504 	addi	r3,r2,20
8112ecb8:	1021883a 	mov	r16,r2
8112ecbc:	bc6fc83a 	sub	r23,r23,r17
8112ecc0:	d8c00215 	stw	r3,8(sp)
8112ecc4:	0027883a 	mov	r19,zero
8112ecc8:	003f1206 	br	8112e914 <__reset+0xfb10e914>
8112eccc:	1d400084 	addi	r21,r3,2
8112ecd0:	0023883a 	mov	r17,zero
8112ecd4:	003eb406 	br	8112e7a8 <__reset+0xfb10e7a8>
8112ecd8:	2005883a 	mov	r2,r4
8112ecdc:	003f4606 	br	8112e9f8 <__reset+0xfb10e9f8>
8112ece0:	0027883a 	mov	r19,zero
8112ece4:	003fe706 	br	8112ec84 <__reset+0xfb10ec84>
8112ece8:	bc7fffc4 	addi	r17,r23,-1
8112ecec:	9800421e 	bne	r19,zero,8112edf8 <__gethex+0x6e8>
8112ecf0:	88000426 	beq	r17,zero,8112ed04 <__gethex+0x5f4>
8112ecf4:	880b883a 	mov	r5,r17
8112ecf8:	8009883a 	mov	r4,r16
8112ecfc:	1128cc80 	call	81128cc8 <__any_on>
8112ed00:	1027883a 	mov	r19,r2
8112ed04:	8805d17a 	srai	r2,r17,5
8112ed08:	d8c00217 	ldw	r3,8(sp)
8112ed0c:	8c4007cc 	andi	r17,r17,31
8112ed10:	1085883a 	add	r2,r2,r2
8112ed14:	1085883a 	add	r2,r2,r2
8112ed18:	1885883a 	add	r2,r3,r2
8112ed1c:	00c00044 	movi	r3,1
8112ed20:	1c62983a 	sll	r17,r3,r17
8112ed24:	10800017 	ldw	r2,0(r2)
8112ed28:	8884703a 	and	r2,r17,r2
8112ed2c:	10000126 	beq	r2,zero,8112ed34 <__gethex+0x624>
8112ed30:	9cc00094 	ori	r19,r19,2
8112ed34:	b80b883a 	mov	r5,r23
8112ed38:	8009883a 	mov	r4,r16
8112ed3c:	112e6100 	call	8112e610 <rshift>
8112ed40:	d8c00017 	ldw	r3,0(sp)
8112ed44:	95e5c83a 	sub	r18,r18,r23
8112ed48:	04400084 	movi	r17,2
8112ed4c:	1dc00117 	ldw	r23,4(r3)
8112ed50:	003fa106 	br	8112ebd8 <__reset+0xfb10ebd8>
8112ed54:	85af883a 	add	r23,r16,r22
8112ed58:	b8800003 	ldbu	r2,0(r23)
8112ed5c:	b821883a 	mov	r16,r23
8112ed60:	11003fcc 	andi	r4,r2,255
8112ed64:	a109883a 	add	r4,r20,r4
8112ed68:	21000003 	ldbu	r4,0(r4)
8112ed6c:	203eaa26 	beq	r4,zero,8112e818 <__reset+0xfb10e818>
8112ed70:	84000044 	addi	r16,r16,1
8112ed74:	80800003 	ldbu	r2,0(r16)
8112ed78:	11003fcc 	andi	r4,r2,255
8112ed7c:	a109883a 	add	r4,r20,r4
8112ed80:	21000003 	ldbu	r4,0(r4)
8112ed84:	203ffa1e 	bne	r4,zero,8112ed70 <__reset+0xfb10ed70>
8112ed88:	003ea306 	br	8112e818 <__reset+0xfb10e818>
8112ed8c:	d9001617 	ldw	r4,88(sp)
8112ed90:	00800044 	movi	r2,1
8112ed94:	1109c83a 	sub	r4,r2,r4
8112ed98:	d9001615 	stw	r4,88(sp)
8112ed9c:	d8801617 	ldw	r2,88(sp)
8112eda0:	103f9626 	beq	r2,zero,8112ebfc <__reset+0xfb10ebfc>
8112eda4:	87000417 	ldw	fp,16(r16)
8112eda8:	d9800217 	ldw	r6,8(sp)
8112edac:	013fffc4 	movi	r4,-1
8112edb0:	e727883a 	add	r19,fp,fp
8112edb4:	9ce7883a 	add	r19,r19,r19
8112edb8:	3005883a 	mov	r2,r6
8112edbc:	34cb883a 	add	r5,r6,r19
8112edc0:	00000306 	br	8112edd0 <__gethex+0x6c0>
8112edc4:	10000015 	stw	zero,0(r2)
8112edc8:	10800104 	addi	r2,r2,4
8112edcc:	117f4c2e 	bgeu	r2,r5,8112eb00 <__reset+0xfb10eb00>
8112edd0:	10c00017 	ldw	r3,0(r2)
8112edd4:	193ffb26 	beq	r3,r4,8112edc4 <__reset+0xfb10edc4>
8112edd8:	18c00044 	addi	r3,r3,1
8112eddc:	10c00015 	stw	r3,0(r2)
8112ede0:	00800084 	movi	r2,2
8112ede4:	88802b26 	beq	r17,r2,8112ee94 <__gethex+0x784>
8112ede8:	948007cc 	andi	r18,r18,31
8112edec:	90002f1e 	bne	r18,zero,8112eeac <__gethex+0x79c>
8112edf0:	04400844 	movi	r17,33
8112edf4:	003f8206 	br	8112ec00 <__reset+0xfb10ec00>
8112edf8:	04c00044 	movi	r19,1
8112edfc:	003fc106 	br	8112ed04 <__reset+0xfb10ed04>
8112ee00:	d8c01617 	ldw	r3,88(sp)
8112ee04:	183ed226 	beq	r3,zero,8112e950 <__reset+0xfb10e950>
8112ee08:	d8c00417 	ldw	r3,16(sp)
8112ee0c:	d9001517 	ldw	r4,84(sp)
8112ee10:	18800015 	stw	r2,0(r3)
8112ee14:	d8c00217 	ldw	r3,8(sp)
8112ee18:	00800044 	movi	r2,1
8112ee1c:	80800415 	stw	r2,16(r16)
8112ee20:	18800015 	stw	r2,0(r3)
8112ee24:	24000015 	stw	r16,0(r4)
8112ee28:	00801884 	movi	r2,98
8112ee2c:	003efa06 	br	8112ea18 <__reset+0xfb10ea18>
8112ee30:	9880008c 	andi	r2,r19,2
8112ee34:	103f7126 	beq	r2,zero,8112ebfc <__reset+0xfb10ebfc>
8112ee38:	d8c00217 	ldw	r3,8(sp)
8112ee3c:	18800017 	ldw	r2,0(r3)
8112ee40:	9884b03a 	or	r2,r19,r2
8112ee44:	1080004c 	andi	r2,r2,1
8112ee48:	103fd61e 	bne	r2,zero,8112eda4 <__reset+0xfb10eda4>
8112ee4c:	003f6b06 	br	8112ebfc <__reset+0xfb10ebfc>
8112ee50:	da800217 	ldw	r10,8(sp)
8112ee54:	0013883a 	mov	r9,zero
8112ee58:	003e9f06 	br	8112e8d8 <__reset+0xfb10e8d8>
8112ee5c:	04c00084 	movi	r19,2
8112ee60:	003f8806 	br	8112ec84 <__reset+0xfb10ec84>
8112ee64:	d9001617 	ldw	r4,88(sp)
8112ee68:	203fe726 	beq	r4,zero,8112ee08 <__reset+0xfb10ee08>
8112ee6c:	003eb806 	br	8112e950 <__reset+0xfb10e950>
8112ee70:	95feb71e 	bne	r18,r23,8112e950 <__reset+0xfb10e950>
8112ee74:	1cbfe40e 	bge	r3,r18,8112ee08 <__reset+0xfb10ee08>
8112ee78:	917fffc4 	addi	r5,r18,-1
8112ee7c:	8009883a 	mov	r4,r16
8112ee80:	1128cc80 	call	81128cc8 <__any_on>
8112ee84:	103eb226 	beq	r2,zero,8112e950 <__reset+0xfb10e950>
8112ee88:	d8c00017 	ldw	r3,0(sp)
8112ee8c:	18800117 	ldw	r2,4(r3)
8112ee90:	003fdd06 	br	8112ee08 <__reset+0xfb10ee08>
8112ee94:	d8c00017 	ldw	r3,0(sp)
8112ee98:	18800017 	ldw	r2,0(r3)
8112ee9c:	10bfffc4 	addi	r2,r2,-1
8112eea0:	90801c26 	beq	r18,r2,8112ef14 <__gethex+0x804>
8112eea4:	04400884 	movi	r17,34
8112eea8:	003f5506 	br	8112ec00 <__reset+0xfb10ec00>
8112eeac:	34c5883a 	add	r2,r6,r19
8112eeb0:	113fff17 	ldw	r4,-4(r2)
8112eeb4:	11280040 	call	81128004 <__hi0bits>
8112eeb8:	00c00804 	movi	r3,32
8112eebc:	1ca5c83a 	sub	r18,r3,r18
8112eec0:	14bfcb0e 	bge	r2,r18,8112edf0 <__reset+0xfb10edf0>
8112eec4:	003f1c06 	br	8112eb38 <__reset+0xfb10eb38>
8112eec8:	81400117 	ldw	r5,4(r16)
8112eecc:	d9000117 	ldw	r4,4(sp)
8112eed0:	29400044 	addi	r5,r5,1
8112eed4:	1127cf80 	call	81127cf8 <_Balloc>
8112eed8:	81800417 	ldw	r6,16(r16)
8112eedc:	81400304 	addi	r5,r16,12
8112eee0:	11000304 	addi	r4,r2,12
8112eee4:	31800084 	addi	r6,r6,2
8112eee8:	318d883a 	add	r6,r6,r6
8112eeec:	318d883a 	add	r6,r6,r6
8112eef0:	1029883a 	mov	r20,r2
8112eef4:	111dac80 	call	8111dac8 <memcpy>
8112eef8:	d9000117 	ldw	r4,4(sp)
8112eefc:	800b883a 	mov	r5,r16
8112ef00:	a021883a 	mov	r16,r20
8112ef04:	1127da80 	call	81127da8 <_Bfree>
8112ef08:	a0c00417 	ldw	r3,16(r20)
8112ef0c:	a1800504 	addi	r6,r20,20
8112ef10:	003efe06 	br	8112eb0c <__reset+0xfb10eb0c>
8112ef14:	9005d17a 	srai	r2,r18,5
8112ef18:	944007cc 	andi	r17,r18,31
8112ef1c:	1085883a 	add	r2,r2,r2
8112ef20:	1085883a 	add	r2,r2,r2
8112ef24:	3087883a 	add	r3,r6,r2
8112ef28:	00800044 	movi	r2,1
8112ef2c:	1462983a 	sll	r17,r2,r17
8112ef30:	18800017 	ldw	r2,0(r3)
8112ef34:	8884703a 	and	r2,r17,r2
8112ef38:	1022c03a 	cmpne	r17,r2,zero
8112ef3c:	00800884 	movi	r2,34
8112ef40:	1463c83a 	sub	r17,r2,r17
8112ef44:	003f2e06 	br	8112ec00 <__reset+0xfb10ec00>

8112ef48 <__hexnan>:
8112ef48:	defff904 	addi	sp,sp,-28
8112ef4c:	de00012e 	bgeu	sp,et,8112ef54 <__hexnan+0xc>
8112ef50:	003b68fa 	trap	3
8112ef54:	dc800215 	stw	r18,8(sp)
8112ef58:	2c800017 	ldw	r18,0(r5)
8112ef5c:	dfc00615 	stw	ra,24(sp)
8112ef60:	dd400515 	stw	r21,20(sp)
8112ef64:	901fd17a 	srai	r15,r18,5
8112ef68:	dd000415 	stw	r20,16(sp)
8112ef6c:	dcc00315 	stw	r19,12(sp)
8112ef70:	7bdf883a 	add	r15,r15,r15
8112ef74:	7bdf883a 	add	r15,r15,r15
8112ef78:	dc400115 	stw	r17,4(sp)
8112ef7c:	dc000015 	stw	r16,0(sp)
8112ef80:	948007cc 	andi	r18,r18,31
8112ef84:	33df883a 	add	r15,r6,r15
8112ef88:	90000126 	beq	r18,zero,8112ef90 <__hexnan+0x48>
8112ef8c:	7bc00104 	addi	r15,r15,4
8112ef90:	22000017 	ldw	r8,0(r4)
8112ef94:	7affff04 	addi	r11,r15,-4
8112ef98:	03a04574 	movhi	r14,33045
8112ef9c:	783fff15 	stw	zero,-4(r15)
8112efa0:	581b883a 	mov	r13,r11
8112efa4:	580b883a 	mov	r5,r11
8112efa8:	000f883a 	mov	r7,zero
8112efac:	003f883a 	mov	ra,zero
8112efb0:	0019883a 	mov	r12,zero
8112efb4:	73b14d04 	addi	r14,r14,-15052
8112efb8:	04400204 	movi	r17,8
8112efbc:	04000804 	movi	r16,32
8112efc0:	04c001c4 	movi	r19,7
8112efc4:	42000044 	addi	r8,r8,1
8112efc8:	40c00003 	ldbu	r3,0(r8)
8112efcc:	18001d26 	beq	r3,zero,8112f044 <__hexnan+0xfc>
8112efd0:	70c5883a 	add	r2,r14,r3
8112efd4:	10800003 	ldbu	r2,0(r2)
8112efd8:	12403fcc 	andi	r9,r2,255
8112efdc:	4800301e 	bne	r9,zero,8112f0a0 <__hexnan+0x158>
8112efe0:	80c04236 	bltu	r16,r3,8112f0ec <__hexnan+0x1a4>
8112efe4:	fb3ff70e 	bge	ra,r12,8112efc4 <__reset+0xfb10efc4>
8112efe8:	2b40112e 	bgeu	r5,r13,8112f030 <__hexnan+0xe8>
8112efec:	99c01016 	blt	r19,r7,8112f030 <__hexnan+0xe8>
8112eff0:	89e9c83a 	sub	r20,r17,r7
8112eff4:	a529883a 	add	r20,r20,r20
8112eff8:	2a800017 	ldw	r10,0(r5)
8112effc:	a529883a 	add	r20,r20,r20
8112f000:	852bc83a 	sub	r21,r16,r20
8112f004:	28c00104 	addi	r3,r5,4
8112f008:	2805883a 	mov	r2,r5
8112f00c:	19c00017 	ldw	r7,0(r3)
8112f010:	10800104 	addi	r2,r2,4
8112f014:	18c00104 	addi	r3,r3,4
8112f018:	3d52983a 	sll	r9,r7,r21
8112f01c:	4a92b03a 	or	r9,r9,r10
8112f020:	3d14d83a 	srl	r10,r7,r20
8112f024:	127fff15 	stw	r9,-4(r2)
8112f028:	1abfff15 	stw	r10,-4(r3)
8112f02c:	137ff736 	bltu	r2,r13,8112f00c <__reset+0xfb10f00c>
8112f030:	31402836 	bltu	r6,r5,8112f0d4 <__hexnan+0x18c>
8112f034:	42000044 	addi	r8,r8,1
8112f038:	40c00003 	ldbu	r3,0(r8)
8112f03c:	01c00204 	movi	r7,8
8112f040:	183fe31e 	bne	r3,zero,8112efd0 <__reset+0xfb10efd0>
8112f044:	60002b26 	beq	r12,zero,8112f0f4 <__hexnan+0x1ac>
8112f048:	2b40022e 	bgeu	r5,r13,8112f054 <__hexnan+0x10c>
8112f04c:	008001c4 	movi	r2,7
8112f050:	11c0430e 	bge	r2,r7,8112f160 <__hexnan+0x218>
8112f054:	3140312e 	bgeu	r6,r5,8112f11c <__hexnan+0x1d4>
8112f058:	3007883a 	mov	r3,r6
8112f05c:	29000017 	ldw	r4,0(r5)
8112f060:	18800104 	addi	r2,r3,4
8112f064:	29400104 	addi	r5,r5,4
8112f068:	19000015 	stw	r4,0(r3)
8112f06c:	1007883a 	mov	r3,r2
8112f070:	597ffa2e 	bgeu	r11,r5,8112f05c <__reset+0xfb10f05c>
8112f074:	10000015 	stw	zero,0(r2)
8112f078:	10800104 	addi	r2,r2,4
8112f07c:	58bffd2e 	bgeu	r11,r2,8112f074 <__reset+0xfb10f074>
8112f080:	78bfff17 	ldw	r2,-4(r15)
8112f084:	1000041e 	bne	r2,zero,8112f098 <__hexnan+0x150>
8112f088:	32c02d26 	beq	r6,r11,8112f140 <__hexnan+0x1f8>
8112f08c:	5affff04 	addi	r11,r11,-4
8112f090:	58800017 	ldw	r2,0(r11)
8112f094:	103ffc26 	beq	r2,zero,8112f088 <__reset+0xfb10f088>
8112f098:	00800144 	movi	r2,5
8112f09c:	00001606 	br	8112f0f8 <__hexnan+0x1b0>
8112f0a0:	39c00044 	addi	r7,r7,1
8112f0a4:	63000044 	addi	r12,r12,1
8112f0a8:	89c0040e 	bge	r17,r7,8112f0bc <__hexnan+0x174>
8112f0ac:	317fc52e 	bgeu	r6,r5,8112efc4 <__reset+0xfb10efc4>
8112f0b0:	283fff15 	stw	zero,-4(r5)
8112f0b4:	01c00044 	movi	r7,1
8112f0b8:	297fff04 	addi	r5,r5,-4
8112f0bc:	28c00017 	ldw	r3,0(r5)
8112f0c0:	108003cc 	andi	r2,r2,15
8112f0c4:	1806913a 	slli	r3,r3,4
8112f0c8:	1884b03a 	or	r2,r3,r2
8112f0cc:	28800015 	stw	r2,0(r5)
8112f0d0:	003fbc06 	br	8112efc4 <__reset+0xfb10efc4>
8112f0d4:	2b7fff04 	addi	r13,r5,-4
8112f0d8:	283fff15 	stw	zero,-4(r5)
8112f0dc:	603f883a 	mov	ra,r12
8112f0e0:	680b883a 	mov	r5,r13
8112f0e4:	000f883a 	mov	r7,zero
8112f0e8:	003fb606 	br	8112efc4 <__reset+0xfb10efc4>
8112f0ec:	00800a44 	movi	r2,41
8112f0f0:	18801726 	beq	r3,r2,8112f150 <__hexnan+0x208>
8112f0f4:	00800104 	movi	r2,4
8112f0f8:	dfc00617 	ldw	ra,24(sp)
8112f0fc:	dd400517 	ldw	r21,20(sp)
8112f100:	dd000417 	ldw	r20,16(sp)
8112f104:	dcc00317 	ldw	r19,12(sp)
8112f108:	dc800217 	ldw	r18,8(sp)
8112f10c:	dc400117 	ldw	r17,4(sp)
8112f110:	dc000017 	ldw	r16,0(sp)
8112f114:	dec00704 	addi	sp,sp,28
8112f118:	f800283a 	ret
8112f11c:	903fd826 	beq	r18,zero,8112f080 <__reset+0xfb10f080>
8112f120:	00c00804 	movi	r3,32
8112f124:	1ca5c83a 	sub	r18,r3,r18
8112f128:	00ffffc4 	movi	r3,-1
8112f12c:	78bfff17 	ldw	r2,-4(r15)
8112f130:	1c86d83a 	srl	r3,r3,r18
8112f134:	1884703a 	and	r2,r3,r2
8112f138:	78bfff15 	stw	r2,-4(r15)
8112f13c:	003fd106 	br	8112f084 <__reset+0xfb10f084>
8112f140:	00800044 	movi	r2,1
8112f144:	58800015 	stw	r2,0(r11)
8112f148:	00800144 	movi	r2,5
8112f14c:	003fea06 	br	8112f0f8 <__reset+0xfb10f0f8>
8112f150:	42000044 	addi	r8,r8,1
8112f154:	22000015 	stw	r8,0(r4)
8112f158:	603fbb1e 	bne	r12,zero,8112f048 <__reset+0xfb10f048>
8112f15c:	003fe506 	br	8112f0f4 <__reset+0xfb10f0f4>
8112f160:	02400204 	movi	r9,8
8112f164:	49d3c83a 	sub	r9,r9,r7
8112f168:	4a53883a 	add	r9,r9,r9
8112f16c:	2a000017 	ldw	r8,0(r5)
8112f170:	4a53883a 	add	r9,r9,r9
8112f174:	02800804 	movi	r10,32
8112f178:	5255c83a 	sub	r10,r10,r9
8112f17c:	28c00104 	addi	r3,r5,4
8112f180:	2805883a 	mov	r2,r5
8112f184:	19c00017 	ldw	r7,0(r3)
8112f188:	10800104 	addi	r2,r2,4
8112f18c:	18c00104 	addi	r3,r3,4
8112f190:	3a88983a 	sll	r4,r7,r10
8112f194:	2208b03a 	or	r4,r4,r8
8112f198:	3a50d83a 	srl	r8,r7,r9
8112f19c:	113fff15 	stw	r4,-4(r2)
8112f1a0:	1a3fff15 	stw	r8,-4(r3)
8112f1a4:	137ff736 	bltu	r2,r13,8112f184 <__reset+0xfb10f184>
8112f1a8:	003faa06 	br	8112f054 <__reset+0xfb10f054>

8112f1ac <strncmp>:
8112f1ac:	30003126 	beq	r6,zero,8112f274 <strncmp+0xc8>
8112f1b0:	2144b03a 	or	r2,r4,r5
8112f1b4:	108000cc 	andi	r2,r2,3
8112f1b8:	10001e1e 	bne	r2,zero,8112f234 <strncmp+0x88>
8112f1bc:	024000c4 	movi	r9,3
8112f1c0:	49801c2e 	bgeu	r9,r6,8112f234 <strncmp+0x88>
8112f1c4:	20800017 	ldw	r2,0(r4)
8112f1c8:	28c00017 	ldw	r3,0(r5)
8112f1cc:	10c0191e 	bne	r2,r3,8112f234 <strncmp+0x88>
8112f1d0:	31bfff04 	addi	r6,r6,-4
8112f1d4:	30002726 	beq	r6,zero,8112f274 <strncmp+0xc8>
8112f1d8:	02ffbff4 	movhi	r11,65279
8112f1dc:	5affbfc4 	addi	r11,r11,-257
8112f1e0:	0086303a 	nor	r3,zero,r2
8112f1e4:	02a02074 	movhi	r10,32897
8112f1e8:	12c5883a 	add	r2,r2,r11
8112f1ec:	52a02004 	addi	r10,r10,-32640
8112f1f0:	10c4703a 	and	r2,r2,r3
8112f1f4:	1284703a 	and	r2,r2,r10
8112f1f8:	10000b26 	beq	r2,zero,8112f228 <strncmp+0x7c>
8112f1fc:	00001d06 	br	8112f274 <strncmp+0xc8>
8112f200:	20c00017 	ldw	r3,0(r4)
8112f204:	29c00017 	ldw	r7,0(r5)
8112f208:	1ad1883a 	add	r8,r3,r11
8112f20c:	00c4303a 	nor	r2,zero,r3
8112f210:	4084703a 	and	r2,r8,r2
8112f214:	1284703a 	and	r2,r2,r10
8112f218:	19c0061e 	bne	r3,r7,8112f234 <strncmp+0x88>
8112f21c:	31bfff04 	addi	r6,r6,-4
8112f220:	30001426 	beq	r6,zero,8112f274 <strncmp+0xc8>
8112f224:	1000131e 	bne	r2,zero,8112f274 <strncmp+0xc8>
8112f228:	21000104 	addi	r4,r4,4
8112f22c:	29400104 	addi	r5,r5,4
8112f230:	49bff336 	bltu	r9,r6,8112f200 <__reset+0xfb10f200>
8112f234:	28800007 	ldb	r2,0(r5)
8112f238:	20c00007 	ldb	r3,0(r4)
8112f23c:	31bfffc4 	addi	r6,r6,-1
8112f240:	10c0081e 	bne	r2,r3,8112f264 <strncmp+0xb8>
8112f244:	30000b26 	beq	r6,zero,8112f274 <strncmp+0xc8>
8112f248:	10000a26 	beq	r2,zero,8112f274 <strncmp+0xc8>
8112f24c:	21000044 	addi	r4,r4,1
8112f250:	29400044 	addi	r5,r5,1
8112f254:	20800007 	ldb	r2,0(r4)
8112f258:	28c00007 	ldb	r3,0(r5)
8112f25c:	31bfffc4 	addi	r6,r6,-1
8112f260:	10fff826 	beq	r2,r3,8112f244 <__reset+0xfb10f244>
8112f264:	20800003 	ldbu	r2,0(r4)
8112f268:	28c00003 	ldbu	r3,0(r5)
8112f26c:	10c5c83a 	sub	r2,r2,r3
8112f270:	f800283a 	ret
8112f274:	0005883a 	mov	r2,zero
8112f278:	f800283a 	ret

8112f27c <_wcrtomb_r>:
8112f27c:	defff604 	addi	sp,sp,-40
8112f280:	00a04574 	movhi	r2,33045
8112f284:	de00012e 	bgeu	sp,et,8112f28c <_wcrtomb_r+0x10>
8112f288:	003b68fa 	trap	3
8112f28c:	10ba8704 	addi	r2,r2,-5604
8112f290:	dc800815 	stw	r18,32(sp)
8112f294:	dc400715 	stw	r17,28(sp)
8112f298:	dc000615 	stw	r16,24(sp)
8112f29c:	dfc00915 	stw	ra,36(sp)
8112f2a0:	2021883a 	mov	r16,r4
8112f2a4:	3823883a 	mov	r17,r7
8112f2a8:	14800017 	ldw	r18,0(r2)
8112f2ac:	28001426 	beq	r5,zero,8112f300 <_wcrtomb_r+0x84>
8112f2b0:	d9400415 	stw	r5,16(sp)
8112f2b4:	d9800515 	stw	r6,20(sp)
8112f2b8:	11277ac0 	call	811277ac <__locale_charset>
8112f2bc:	d9800517 	ldw	r6,20(sp)
8112f2c0:	d9400417 	ldw	r5,16(sp)
8112f2c4:	100f883a 	mov	r7,r2
8112f2c8:	dc400015 	stw	r17,0(sp)
8112f2cc:	8009883a 	mov	r4,r16
8112f2d0:	903ee83a 	callr	r18
8112f2d4:	00ffffc4 	movi	r3,-1
8112f2d8:	10c0031e 	bne	r2,r3,8112f2e8 <_wcrtomb_r+0x6c>
8112f2dc:	88000015 	stw	zero,0(r17)
8112f2e0:	00c02284 	movi	r3,138
8112f2e4:	80c00015 	stw	r3,0(r16)
8112f2e8:	dfc00917 	ldw	ra,36(sp)
8112f2ec:	dc800817 	ldw	r18,32(sp)
8112f2f0:	dc400717 	ldw	r17,28(sp)
8112f2f4:	dc000617 	ldw	r16,24(sp)
8112f2f8:	dec00a04 	addi	sp,sp,40
8112f2fc:	f800283a 	ret
8112f300:	11277ac0 	call	811277ac <__locale_charset>
8112f304:	100f883a 	mov	r7,r2
8112f308:	dc400015 	stw	r17,0(sp)
8112f30c:	000d883a 	mov	r6,zero
8112f310:	d9400104 	addi	r5,sp,4
8112f314:	8009883a 	mov	r4,r16
8112f318:	903ee83a 	callr	r18
8112f31c:	003fed06 	br	8112f2d4 <__reset+0xfb10f2d4>

8112f320 <wcrtomb>:
8112f320:	defff604 	addi	sp,sp,-40
8112f324:	00a04574 	movhi	r2,33045
8112f328:	de00012e 	bgeu	sp,et,8112f330 <wcrtomb+0x10>
8112f32c:	003b68fa 	trap	3
8112f330:	10ba8204 	addi	r2,r2,-5624
8112f334:	dc800615 	stw	r18,24(sp)
8112f338:	dc400515 	stw	r17,20(sp)
8112f33c:	dfc00915 	stw	ra,36(sp)
8112f340:	dd000815 	stw	r20,32(sp)
8112f344:	dcc00715 	stw	r19,28(sp)
8112f348:	dc000415 	stw	r16,16(sp)
8112f34c:	3025883a 	mov	r18,r6
8112f350:	14400017 	ldw	r17,0(r2)
8112f354:	20001926 	beq	r4,zero,8112f3bc <wcrtomb+0x9c>
8112f358:	00a04574 	movhi	r2,33045
8112f35c:	10ba8704 	addi	r2,r2,-5604
8112f360:	15000017 	ldw	r20,0(r2)
8112f364:	2021883a 	mov	r16,r4
8112f368:	2827883a 	mov	r19,r5
8112f36c:	11277ac0 	call	811277ac <__locale_charset>
8112f370:	100f883a 	mov	r7,r2
8112f374:	dc800015 	stw	r18,0(sp)
8112f378:	980d883a 	mov	r6,r19
8112f37c:	800b883a 	mov	r5,r16
8112f380:	8809883a 	mov	r4,r17
8112f384:	a03ee83a 	callr	r20
8112f388:	00ffffc4 	movi	r3,-1
8112f38c:	10c0031e 	bne	r2,r3,8112f39c <wcrtomb+0x7c>
8112f390:	90000015 	stw	zero,0(r18)
8112f394:	00c02284 	movi	r3,138
8112f398:	88c00015 	stw	r3,0(r17)
8112f39c:	dfc00917 	ldw	ra,36(sp)
8112f3a0:	dd000817 	ldw	r20,32(sp)
8112f3a4:	dcc00717 	ldw	r19,28(sp)
8112f3a8:	dc800617 	ldw	r18,24(sp)
8112f3ac:	dc400517 	ldw	r17,20(sp)
8112f3b0:	dc000417 	ldw	r16,16(sp)
8112f3b4:	dec00a04 	addi	sp,sp,40
8112f3b8:	f800283a 	ret
8112f3bc:	00a04574 	movhi	r2,33045
8112f3c0:	10ba8704 	addi	r2,r2,-5604
8112f3c4:	14000017 	ldw	r16,0(r2)
8112f3c8:	11277ac0 	call	811277ac <__locale_charset>
8112f3cc:	100f883a 	mov	r7,r2
8112f3d0:	dc800015 	stw	r18,0(sp)
8112f3d4:	000d883a 	mov	r6,zero
8112f3d8:	d9400104 	addi	r5,sp,4
8112f3dc:	8809883a 	mov	r4,r17
8112f3e0:	803ee83a 	callr	r16
8112f3e4:	003fe806 	br	8112f388 <__reset+0xfb10f388>

8112f3e8 <__ascii_wctomb>:
8112f3e8:	28000526 	beq	r5,zero,8112f400 <__ascii_wctomb+0x18>
8112f3ec:	00803fc4 	movi	r2,255
8112f3f0:	11800536 	bltu	r2,r6,8112f408 <__ascii_wctomb+0x20>
8112f3f4:	29800005 	stb	r6,0(r5)
8112f3f8:	00800044 	movi	r2,1
8112f3fc:	f800283a 	ret
8112f400:	0005883a 	mov	r2,zero
8112f404:	f800283a 	ret
8112f408:	00802284 	movi	r2,138
8112f40c:	20800015 	stw	r2,0(r4)
8112f410:	00bfffc4 	movi	r2,-1
8112f414:	f800283a 	ret

8112f418 <_wctomb_r>:
8112f418:	00a04574 	movhi	r2,33045
8112f41c:	defff904 	addi	sp,sp,-28
8112f420:	10ba8704 	addi	r2,r2,-5604
8112f424:	de00012e 	bgeu	sp,et,8112f42c <_wctomb_r+0x14>
8112f428:	003b68fa 	trap	3
8112f42c:	dfc00615 	stw	ra,24(sp)
8112f430:	dc400515 	stw	r17,20(sp)
8112f434:	dc000415 	stw	r16,16(sp)
8112f438:	3823883a 	mov	r17,r7
8112f43c:	14000017 	ldw	r16,0(r2)
8112f440:	d9000115 	stw	r4,4(sp)
8112f444:	d9400215 	stw	r5,8(sp)
8112f448:	d9800315 	stw	r6,12(sp)
8112f44c:	11277ac0 	call	811277ac <__locale_charset>
8112f450:	d9800317 	ldw	r6,12(sp)
8112f454:	d9400217 	ldw	r5,8(sp)
8112f458:	d9000117 	ldw	r4,4(sp)
8112f45c:	100f883a 	mov	r7,r2
8112f460:	dc400015 	stw	r17,0(sp)
8112f464:	803ee83a 	callr	r16
8112f468:	dfc00617 	ldw	ra,24(sp)
8112f46c:	dc400517 	ldw	r17,20(sp)
8112f470:	dc000417 	ldw	r16,16(sp)
8112f474:	dec00704 	addi	sp,sp,28
8112f478:	f800283a 	ret

8112f47c <__fixunsdfsi>:
8112f47c:	defffd04 	addi	sp,sp,-12
8112f480:	000d883a 	mov	r6,zero
8112f484:	01d07834 	movhi	r7,16864
8112f488:	de00012e 	bgeu	sp,et,8112f490 <__fixunsdfsi+0x14>
8112f48c:	003b68fa 	trap	3
8112f490:	dc400115 	stw	r17,4(sp)
8112f494:	dc000015 	stw	r16,0(sp)
8112f498:	dfc00215 	stw	ra,8(sp)
8112f49c:	2023883a 	mov	r17,r4
8112f4a0:	2821883a 	mov	r16,r5
8112f4a4:	11315940 	call	81131594 <__gedf2>
8112f4a8:	1000080e 	bge	r2,zero,8112f4cc <__fixunsdfsi+0x50>
8112f4ac:	8809883a 	mov	r4,r17
8112f4b0:	800b883a 	mov	r5,r16
8112f4b4:	11320680 	call	81132068 <__fixdfsi>
8112f4b8:	dfc00217 	ldw	ra,8(sp)
8112f4bc:	dc400117 	ldw	r17,4(sp)
8112f4c0:	dc000017 	ldw	r16,0(sp)
8112f4c4:	dec00304 	addi	sp,sp,12
8112f4c8:	f800283a 	ret
8112f4cc:	000d883a 	mov	r6,zero
8112f4d0:	01d07834 	movhi	r7,16864
8112f4d4:	8809883a 	mov	r4,r17
8112f4d8:	800b883a 	mov	r5,r16
8112f4dc:	11317640 	call	81131764 <__subdf3>
8112f4e0:	180b883a 	mov	r5,r3
8112f4e4:	1009883a 	mov	r4,r2
8112f4e8:	11320680 	call	81132068 <__fixdfsi>
8112f4ec:	00e00034 	movhi	r3,32768
8112f4f0:	10c5883a 	add	r2,r2,r3
8112f4f4:	003ff006 	br	8112f4b8 <__reset+0xfb10f4b8>

8112f4f8 <__udivdi3>:
8112f4f8:	defff504 	addi	sp,sp,-44
8112f4fc:	de00012e 	bgeu	sp,et,8112f504 <__udivdi3+0xc>
8112f500:	003b68fa 	trap	3
8112f504:	dcc00415 	stw	r19,16(sp)
8112f508:	dc000115 	stw	r16,4(sp)
8112f50c:	dfc00a15 	stw	ra,40(sp)
8112f510:	df000915 	stw	fp,36(sp)
8112f514:	ddc00815 	stw	r23,32(sp)
8112f518:	dd800715 	stw	r22,28(sp)
8112f51c:	dd400615 	stw	r21,24(sp)
8112f520:	dd000515 	stw	r20,20(sp)
8112f524:	dc800315 	stw	r18,12(sp)
8112f528:	dc400215 	stw	r17,8(sp)
8112f52c:	2027883a 	mov	r19,r4
8112f530:	2821883a 	mov	r16,r5
8112f534:	3800411e 	bne	r7,zero,8112f63c <__udivdi3+0x144>
8112f538:	3023883a 	mov	r17,r6
8112f53c:	2025883a 	mov	r18,r4
8112f540:	2980522e 	bgeu	r5,r6,8112f68c <__udivdi3+0x194>
8112f544:	00bfffd4 	movui	r2,65535
8112f548:	282d883a 	mov	r22,r5
8112f54c:	1180a836 	bltu	r2,r6,8112f7f0 <__udivdi3+0x2f8>
8112f550:	00803fc4 	movi	r2,255
8112f554:	1185803a 	cmpltu	r2,r2,r6
8112f558:	100490fa 	slli	r2,r2,3
8112f55c:	3086d83a 	srl	r3,r6,r2
8112f560:	01204574 	movhi	r4,33045
8112f564:	212fc704 	addi	r4,r4,-16612
8112f568:	20c7883a 	add	r3,r4,r3
8112f56c:	18c00003 	ldbu	r3,0(r3)
8112f570:	1885883a 	add	r2,r3,r2
8112f574:	00c00804 	movi	r3,32
8112f578:	1887c83a 	sub	r3,r3,r2
8112f57c:	18000526 	beq	r3,zero,8112f594 <__udivdi3+0x9c>
8112f580:	80e0983a 	sll	r16,r16,r3
8112f584:	9884d83a 	srl	r2,r19,r2
8112f588:	30e2983a 	sll	r17,r6,r3
8112f58c:	98e4983a 	sll	r18,r19,r3
8112f590:	142cb03a 	or	r22,r2,r16
8112f594:	882ad43a 	srli	r21,r17,16
8112f598:	b009883a 	mov	r4,r22
8112f59c:	8d3fffcc 	andi	r20,r17,65535
8112f5a0:	a80b883a 	mov	r5,r21
8112f5a4:	11301140 	call	81130114 <__umodsi3>
8112f5a8:	b009883a 	mov	r4,r22
8112f5ac:	a80b883a 	mov	r5,r21
8112f5b0:	1027883a 	mov	r19,r2
8112f5b4:	11300b00 	call	811300b0 <__udivsi3>
8112f5b8:	102d883a 	mov	r22,r2
8112f5bc:	9826943a 	slli	r19,r19,16
8112f5c0:	9004d43a 	srli	r2,r18,16
8112f5c4:	a5a1383a 	mul	r16,r20,r22
8112f5c8:	14c4b03a 	or	r2,r2,r19
8112f5cc:	1400052e 	bgeu	r2,r16,8112f5e4 <__udivdi3+0xec>
8112f5d0:	1445883a 	add	r2,r2,r17
8112f5d4:	b0ffffc4 	addi	r3,r22,-1
8112f5d8:	14400136 	bltu	r2,r17,8112f5e0 <__udivdi3+0xe8>
8112f5dc:	14012336 	bltu	r2,r16,8112fa6c <__udivdi3+0x574>
8112f5e0:	182d883a 	mov	r22,r3
8112f5e4:	1421c83a 	sub	r16,r2,r16
8112f5e8:	a80b883a 	mov	r5,r21
8112f5ec:	8009883a 	mov	r4,r16
8112f5f0:	11301140 	call	81130114 <__umodsi3>
8112f5f4:	1027883a 	mov	r19,r2
8112f5f8:	a80b883a 	mov	r5,r21
8112f5fc:	8009883a 	mov	r4,r16
8112f600:	11300b00 	call	811300b0 <__udivsi3>
8112f604:	9826943a 	slli	r19,r19,16
8112f608:	a0a9383a 	mul	r20,r20,r2
8112f60c:	94bfffcc 	andi	r18,r18,65535
8112f610:	94e4b03a 	or	r18,r18,r19
8112f614:	9500052e 	bgeu	r18,r20,8112f62c <__udivdi3+0x134>
8112f618:	8ca5883a 	add	r18,r17,r18
8112f61c:	10ffffc4 	addi	r3,r2,-1
8112f620:	9440f136 	bltu	r18,r17,8112f9e8 <__udivdi3+0x4f0>
8112f624:	9500f02e 	bgeu	r18,r20,8112f9e8 <__udivdi3+0x4f0>
8112f628:	10bfff84 	addi	r2,r2,-2
8112f62c:	b00c943a 	slli	r6,r22,16
8112f630:	0007883a 	mov	r3,zero
8112f634:	3084b03a 	or	r2,r6,r2
8112f638:	00005906 	br	8112f7a0 <__udivdi3+0x2a8>
8112f63c:	29c05636 	bltu	r5,r7,8112f798 <__udivdi3+0x2a0>
8112f640:	00bfffd4 	movui	r2,65535
8112f644:	11c0622e 	bgeu	r2,r7,8112f7d0 <__udivdi3+0x2d8>
8112f648:	00804034 	movhi	r2,256
8112f64c:	10bfffc4 	addi	r2,r2,-1
8112f650:	11c0ee36 	bltu	r2,r7,8112fa0c <__udivdi3+0x514>
8112f654:	00800404 	movi	r2,16
8112f658:	3886d83a 	srl	r3,r7,r2
8112f65c:	01204574 	movhi	r4,33045
8112f660:	212fc704 	addi	r4,r4,-16612
8112f664:	20c7883a 	add	r3,r4,r3
8112f668:	18c00003 	ldbu	r3,0(r3)
8112f66c:	05400804 	movi	r21,32
8112f670:	1885883a 	add	r2,r3,r2
8112f674:	a8abc83a 	sub	r21,r21,r2
8112f678:	a800621e 	bne	r21,zero,8112f804 <__udivdi3+0x30c>
8112f67c:	3c00e936 	bltu	r7,r16,8112fa24 <__udivdi3+0x52c>
8112f680:	9985403a 	cmpgeu	r2,r19,r6
8112f684:	0007883a 	mov	r3,zero
8112f688:	00004506 	br	8112f7a0 <__udivdi3+0x2a8>
8112f68c:	3000041e 	bne	r6,zero,8112f6a0 <__udivdi3+0x1a8>
8112f690:	000b883a 	mov	r5,zero
8112f694:	01000044 	movi	r4,1
8112f698:	11300b00 	call	811300b0 <__udivsi3>
8112f69c:	1023883a 	mov	r17,r2
8112f6a0:	00bfffd4 	movui	r2,65535
8112f6a4:	14404e2e 	bgeu	r2,r17,8112f7e0 <__udivdi3+0x2e8>
8112f6a8:	00804034 	movhi	r2,256
8112f6ac:	10bfffc4 	addi	r2,r2,-1
8112f6b0:	1440d836 	bltu	r2,r17,8112fa14 <__udivdi3+0x51c>
8112f6b4:	00800404 	movi	r2,16
8112f6b8:	8886d83a 	srl	r3,r17,r2
8112f6bc:	01204574 	movhi	r4,33045
8112f6c0:	212fc704 	addi	r4,r4,-16612
8112f6c4:	20c7883a 	add	r3,r4,r3
8112f6c8:	18c00003 	ldbu	r3,0(r3)
8112f6cc:	1885883a 	add	r2,r3,r2
8112f6d0:	00c00804 	movi	r3,32
8112f6d4:	1887c83a 	sub	r3,r3,r2
8112f6d8:	18008f1e 	bne	r3,zero,8112f918 <__udivdi3+0x420>
8112f6dc:	882ad43a 	srli	r21,r17,16
8112f6e0:	8461c83a 	sub	r16,r16,r17
8112f6e4:	8d3fffcc 	andi	r20,r17,65535
8112f6e8:	00c00044 	movi	r3,1
8112f6ec:	8009883a 	mov	r4,r16
8112f6f0:	a80b883a 	mov	r5,r21
8112f6f4:	d8c00015 	stw	r3,0(sp)
8112f6f8:	11301140 	call	81130114 <__umodsi3>
8112f6fc:	8009883a 	mov	r4,r16
8112f700:	a80b883a 	mov	r5,r21
8112f704:	1027883a 	mov	r19,r2
8112f708:	11300b00 	call	811300b0 <__udivsi3>
8112f70c:	9826943a 	slli	r19,r19,16
8112f710:	9008d43a 	srli	r4,r18,16
8112f714:	1521383a 	mul	r16,r2,r20
8112f718:	102d883a 	mov	r22,r2
8112f71c:	24c8b03a 	or	r4,r4,r19
8112f720:	d8c00017 	ldw	r3,0(sp)
8112f724:	2400052e 	bgeu	r4,r16,8112f73c <__udivdi3+0x244>
8112f728:	2449883a 	add	r4,r4,r17
8112f72c:	b0bfffc4 	addi	r2,r22,-1
8112f730:	24400136 	bltu	r4,r17,8112f738 <__udivdi3+0x240>
8112f734:	2400ca36 	bltu	r4,r16,8112fa60 <__udivdi3+0x568>
8112f738:	102d883a 	mov	r22,r2
8112f73c:	2421c83a 	sub	r16,r4,r16
8112f740:	a80b883a 	mov	r5,r21
8112f744:	8009883a 	mov	r4,r16
8112f748:	d8c00015 	stw	r3,0(sp)
8112f74c:	11301140 	call	81130114 <__umodsi3>
8112f750:	1027883a 	mov	r19,r2
8112f754:	a80b883a 	mov	r5,r21
8112f758:	8009883a 	mov	r4,r16
8112f75c:	11300b00 	call	811300b0 <__udivsi3>
8112f760:	9826943a 	slli	r19,r19,16
8112f764:	1529383a 	mul	r20,r2,r20
8112f768:	94bfffcc 	andi	r18,r18,65535
8112f76c:	94e4b03a 	or	r18,r18,r19
8112f770:	d8c00017 	ldw	r3,0(sp)
8112f774:	9500052e 	bgeu	r18,r20,8112f78c <__udivdi3+0x294>
8112f778:	8ca5883a 	add	r18,r17,r18
8112f77c:	113fffc4 	addi	r4,r2,-1
8112f780:	94409736 	bltu	r18,r17,8112f9e0 <__udivdi3+0x4e8>
8112f784:	9500962e 	bgeu	r18,r20,8112f9e0 <__udivdi3+0x4e8>
8112f788:	10bfff84 	addi	r2,r2,-2
8112f78c:	b00c943a 	slli	r6,r22,16
8112f790:	3084b03a 	or	r2,r6,r2
8112f794:	00000206 	br	8112f7a0 <__udivdi3+0x2a8>
8112f798:	0007883a 	mov	r3,zero
8112f79c:	0005883a 	mov	r2,zero
8112f7a0:	dfc00a17 	ldw	ra,40(sp)
8112f7a4:	df000917 	ldw	fp,36(sp)
8112f7a8:	ddc00817 	ldw	r23,32(sp)
8112f7ac:	dd800717 	ldw	r22,28(sp)
8112f7b0:	dd400617 	ldw	r21,24(sp)
8112f7b4:	dd000517 	ldw	r20,20(sp)
8112f7b8:	dcc00417 	ldw	r19,16(sp)
8112f7bc:	dc800317 	ldw	r18,12(sp)
8112f7c0:	dc400217 	ldw	r17,8(sp)
8112f7c4:	dc000117 	ldw	r16,4(sp)
8112f7c8:	dec00b04 	addi	sp,sp,44
8112f7cc:	f800283a 	ret
8112f7d0:	00803fc4 	movi	r2,255
8112f7d4:	11c5803a 	cmpltu	r2,r2,r7
8112f7d8:	100490fa 	slli	r2,r2,3
8112f7dc:	003f9e06 	br	8112f658 <__reset+0xfb10f658>
8112f7e0:	00803fc4 	movi	r2,255
8112f7e4:	1445803a 	cmpltu	r2,r2,r17
8112f7e8:	100490fa 	slli	r2,r2,3
8112f7ec:	003fb206 	br	8112f6b8 <__reset+0xfb10f6b8>
8112f7f0:	00804034 	movhi	r2,256
8112f7f4:	10bfffc4 	addi	r2,r2,-1
8112f7f8:	11808836 	bltu	r2,r6,8112fa1c <__udivdi3+0x524>
8112f7fc:	00800404 	movi	r2,16
8112f800:	003f5606 	br	8112f55c <__reset+0xfb10f55c>
8112f804:	30aed83a 	srl	r23,r6,r2
8112f808:	3d4e983a 	sll	r7,r7,r21
8112f80c:	80acd83a 	srl	r22,r16,r2
8112f810:	9884d83a 	srl	r2,r19,r2
8112f814:	3deeb03a 	or	r23,r7,r23
8112f818:	b824d43a 	srli	r18,r23,16
8112f81c:	8560983a 	sll	r16,r16,r21
8112f820:	b009883a 	mov	r4,r22
8112f824:	900b883a 	mov	r5,r18
8112f828:	3568983a 	sll	r20,r6,r21
8112f82c:	1420b03a 	or	r16,r2,r16
8112f830:	11301140 	call	81130114 <__umodsi3>
8112f834:	b009883a 	mov	r4,r22
8112f838:	900b883a 	mov	r5,r18
8112f83c:	1023883a 	mov	r17,r2
8112f840:	11300b00 	call	811300b0 <__udivsi3>
8112f844:	8808943a 	slli	r4,r17,16
8112f848:	bf3fffcc 	andi	fp,r23,65535
8112f84c:	8006d43a 	srli	r3,r16,16
8112f850:	e0a3383a 	mul	r17,fp,r2
8112f854:	100d883a 	mov	r6,r2
8112f858:	1906b03a 	or	r3,r3,r4
8112f85c:	1c40042e 	bgeu	r3,r17,8112f870 <__udivdi3+0x378>
8112f860:	1dc7883a 	add	r3,r3,r23
8112f864:	10bfffc4 	addi	r2,r2,-1
8112f868:	1dc0752e 	bgeu	r3,r23,8112fa40 <__udivdi3+0x548>
8112f86c:	100d883a 	mov	r6,r2
8112f870:	1c63c83a 	sub	r17,r3,r17
8112f874:	900b883a 	mov	r5,r18
8112f878:	8809883a 	mov	r4,r17
8112f87c:	d9800015 	stw	r6,0(sp)
8112f880:	11301140 	call	81130114 <__umodsi3>
8112f884:	102d883a 	mov	r22,r2
8112f888:	8809883a 	mov	r4,r17
8112f88c:	900b883a 	mov	r5,r18
8112f890:	11300b00 	call	811300b0 <__udivsi3>
8112f894:	b02c943a 	slli	r22,r22,16
8112f898:	e089383a 	mul	r4,fp,r2
8112f89c:	843fffcc 	andi	r16,r16,65535
8112f8a0:	85a0b03a 	or	r16,r16,r22
8112f8a4:	d9800017 	ldw	r6,0(sp)
8112f8a8:	8100042e 	bgeu	r16,r4,8112f8bc <__udivdi3+0x3c4>
8112f8ac:	85e1883a 	add	r16,r16,r23
8112f8b0:	10ffffc4 	addi	r3,r2,-1
8112f8b4:	85c05e2e 	bgeu	r16,r23,8112fa30 <__udivdi3+0x538>
8112f8b8:	1805883a 	mov	r2,r3
8112f8bc:	300c943a 	slli	r6,r6,16
8112f8c0:	a17fffcc 	andi	r5,r20,65535
8112f8c4:	a028d43a 	srli	r20,r20,16
8112f8c8:	3084b03a 	or	r2,r6,r2
8112f8cc:	10ffffcc 	andi	r3,r2,65535
8112f8d0:	100cd43a 	srli	r6,r2,16
8112f8d4:	194f383a 	mul	r7,r3,r5
8112f8d8:	1d07383a 	mul	r3,r3,r20
8112f8dc:	314b383a 	mul	r5,r6,r5
8112f8e0:	3810d43a 	srli	r8,r7,16
8112f8e4:	8121c83a 	sub	r16,r16,r4
8112f8e8:	1947883a 	add	r3,r3,r5
8112f8ec:	40c7883a 	add	r3,r8,r3
8112f8f0:	350d383a 	mul	r6,r6,r20
8112f8f4:	1940022e 	bgeu	r3,r5,8112f900 <__udivdi3+0x408>
8112f8f8:	01000074 	movhi	r4,1
8112f8fc:	310d883a 	add	r6,r6,r4
8112f900:	1828d43a 	srli	r20,r3,16
8112f904:	a18d883a 	add	r6,r20,r6
8112f908:	81803e36 	bltu	r16,r6,8112fa04 <__udivdi3+0x50c>
8112f90c:	81803826 	beq	r16,r6,8112f9f0 <__udivdi3+0x4f8>
8112f910:	0007883a 	mov	r3,zero
8112f914:	003fa206 	br	8112f7a0 <__reset+0xfb10f7a0>
8112f918:	88e2983a 	sll	r17,r17,r3
8112f91c:	80a8d83a 	srl	r20,r16,r2
8112f920:	80e0983a 	sll	r16,r16,r3
8112f924:	882ad43a 	srli	r21,r17,16
8112f928:	9884d83a 	srl	r2,r19,r2
8112f92c:	a009883a 	mov	r4,r20
8112f930:	a80b883a 	mov	r5,r21
8112f934:	142eb03a 	or	r23,r2,r16
8112f938:	98e4983a 	sll	r18,r19,r3
8112f93c:	11301140 	call	81130114 <__umodsi3>
8112f940:	a009883a 	mov	r4,r20
8112f944:	a80b883a 	mov	r5,r21
8112f948:	1021883a 	mov	r16,r2
8112f94c:	11300b00 	call	811300b0 <__udivsi3>
8112f950:	1039883a 	mov	fp,r2
8112f954:	8d3fffcc 	andi	r20,r17,65535
8112f958:	8020943a 	slli	r16,r16,16
8112f95c:	b804d43a 	srli	r2,r23,16
8112f960:	a72d383a 	mul	r22,r20,fp
8112f964:	1404b03a 	or	r2,r2,r16
8112f968:	1580062e 	bgeu	r2,r22,8112f984 <__udivdi3+0x48c>
8112f96c:	1445883a 	add	r2,r2,r17
8112f970:	e0ffffc4 	addi	r3,fp,-1
8112f974:	14403836 	bltu	r2,r17,8112fa58 <__udivdi3+0x560>
8112f978:	1580372e 	bgeu	r2,r22,8112fa58 <__udivdi3+0x560>
8112f97c:	e73fff84 	addi	fp,fp,-2
8112f980:	1445883a 	add	r2,r2,r17
8112f984:	15adc83a 	sub	r22,r2,r22
8112f988:	a80b883a 	mov	r5,r21
8112f98c:	b009883a 	mov	r4,r22
8112f990:	11301140 	call	81130114 <__umodsi3>
8112f994:	1027883a 	mov	r19,r2
8112f998:	b009883a 	mov	r4,r22
8112f99c:	a80b883a 	mov	r5,r21
8112f9a0:	11300b00 	call	811300b0 <__udivsi3>
8112f9a4:	9826943a 	slli	r19,r19,16
8112f9a8:	a0a1383a 	mul	r16,r20,r2
8112f9ac:	b93fffcc 	andi	r4,r23,65535
8112f9b0:	24c8b03a 	or	r4,r4,r19
8112f9b4:	2400062e 	bgeu	r4,r16,8112f9d0 <__udivdi3+0x4d8>
8112f9b8:	2449883a 	add	r4,r4,r17
8112f9bc:	10ffffc4 	addi	r3,r2,-1
8112f9c0:	24402336 	bltu	r4,r17,8112fa50 <__udivdi3+0x558>
8112f9c4:	2400222e 	bgeu	r4,r16,8112fa50 <__udivdi3+0x558>
8112f9c8:	10bfff84 	addi	r2,r2,-2
8112f9cc:	2449883a 	add	r4,r4,r17
8112f9d0:	e038943a 	slli	fp,fp,16
8112f9d4:	2421c83a 	sub	r16,r4,r16
8112f9d8:	e086b03a 	or	r3,fp,r2
8112f9dc:	003f4306 	br	8112f6ec <__reset+0xfb10f6ec>
8112f9e0:	2005883a 	mov	r2,r4
8112f9e4:	003f6906 	br	8112f78c <__reset+0xfb10f78c>
8112f9e8:	1805883a 	mov	r2,r3
8112f9ec:	003f0f06 	br	8112f62c <__reset+0xfb10f62c>
8112f9f0:	1806943a 	slli	r3,r3,16
8112f9f4:	9d66983a 	sll	r19,r19,r21
8112f9f8:	39ffffcc 	andi	r7,r7,65535
8112f9fc:	19c7883a 	add	r3,r3,r7
8112fa00:	98ffc32e 	bgeu	r19,r3,8112f910 <__reset+0xfb10f910>
8112fa04:	10bfffc4 	addi	r2,r2,-1
8112fa08:	003fc106 	br	8112f910 <__reset+0xfb10f910>
8112fa0c:	00800604 	movi	r2,24
8112fa10:	003f1106 	br	8112f658 <__reset+0xfb10f658>
8112fa14:	00800604 	movi	r2,24
8112fa18:	003f2706 	br	8112f6b8 <__reset+0xfb10f6b8>
8112fa1c:	00800604 	movi	r2,24
8112fa20:	003ece06 	br	8112f55c <__reset+0xfb10f55c>
8112fa24:	0007883a 	mov	r3,zero
8112fa28:	00800044 	movi	r2,1
8112fa2c:	003f5c06 	br	8112f7a0 <__reset+0xfb10f7a0>
8112fa30:	813fa12e 	bgeu	r16,r4,8112f8b8 <__reset+0xfb10f8b8>
8112fa34:	10bfff84 	addi	r2,r2,-2
8112fa38:	85e1883a 	add	r16,r16,r23
8112fa3c:	003f9f06 	br	8112f8bc <__reset+0xfb10f8bc>
8112fa40:	1c7f8a2e 	bgeu	r3,r17,8112f86c <__reset+0xfb10f86c>
8112fa44:	31bfff84 	addi	r6,r6,-2
8112fa48:	1dc7883a 	add	r3,r3,r23
8112fa4c:	003f8806 	br	8112f870 <__reset+0xfb10f870>
8112fa50:	1805883a 	mov	r2,r3
8112fa54:	003fde06 	br	8112f9d0 <__reset+0xfb10f9d0>
8112fa58:	1839883a 	mov	fp,r3
8112fa5c:	003fc906 	br	8112f984 <__reset+0xfb10f984>
8112fa60:	b5bfff84 	addi	r22,r22,-2
8112fa64:	2449883a 	add	r4,r4,r17
8112fa68:	003f3406 	br	8112f73c <__reset+0xfb10f73c>
8112fa6c:	b5bfff84 	addi	r22,r22,-2
8112fa70:	1445883a 	add	r2,r2,r17
8112fa74:	003edb06 	br	8112f5e4 <__reset+0xfb10f5e4>

8112fa78 <__umoddi3>:
8112fa78:	defff404 	addi	sp,sp,-48
8112fa7c:	de00012e 	bgeu	sp,et,8112fa84 <__umoddi3+0xc>
8112fa80:	003b68fa 	trap	3
8112fa84:	df000a15 	stw	fp,40(sp)
8112fa88:	dc400315 	stw	r17,12(sp)
8112fa8c:	dc000215 	stw	r16,8(sp)
8112fa90:	dfc00b15 	stw	ra,44(sp)
8112fa94:	ddc00915 	stw	r23,36(sp)
8112fa98:	dd800815 	stw	r22,32(sp)
8112fa9c:	dd400715 	stw	r21,28(sp)
8112faa0:	dd000615 	stw	r20,24(sp)
8112faa4:	dcc00515 	stw	r19,20(sp)
8112faa8:	dc800415 	stw	r18,16(sp)
8112faac:	2021883a 	mov	r16,r4
8112fab0:	2823883a 	mov	r17,r5
8112fab4:	2839883a 	mov	fp,r5
8112fab8:	38003c1e 	bne	r7,zero,8112fbac <__umoddi3+0x134>
8112fabc:	3027883a 	mov	r19,r6
8112fac0:	2029883a 	mov	r20,r4
8112fac4:	2980512e 	bgeu	r5,r6,8112fc0c <__umoddi3+0x194>
8112fac8:	00bfffd4 	movui	r2,65535
8112facc:	11809a36 	bltu	r2,r6,8112fd38 <__umoddi3+0x2c0>
8112fad0:	01003fc4 	movi	r4,255
8112fad4:	2189803a 	cmpltu	r4,r4,r6
8112fad8:	200890fa 	slli	r4,r4,3
8112fadc:	3104d83a 	srl	r2,r6,r4
8112fae0:	00e04574 	movhi	r3,33045
8112fae4:	18efc704 	addi	r3,r3,-16612
8112fae8:	1885883a 	add	r2,r3,r2
8112faec:	10c00003 	ldbu	r3,0(r2)
8112faf0:	00800804 	movi	r2,32
8112faf4:	1909883a 	add	r4,r3,r4
8112faf8:	1125c83a 	sub	r18,r2,r4
8112fafc:	90000526 	beq	r18,zero,8112fb14 <__umoddi3+0x9c>
8112fb00:	8ca2983a 	sll	r17,r17,r18
8112fb04:	8108d83a 	srl	r4,r16,r4
8112fb08:	34a6983a 	sll	r19,r6,r18
8112fb0c:	84a8983a 	sll	r20,r16,r18
8112fb10:	2478b03a 	or	fp,r4,r17
8112fb14:	982ed43a 	srli	r23,r19,16
8112fb18:	e009883a 	mov	r4,fp
8112fb1c:	9dbfffcc 	andi	r22,r19,65535
8112fb20:	b80b883a 	mov	r5,r23
8112fb24:	11301140 	call	81130114 <__umodsi3>
8112fb28:	e009883a 	mov	r4,fp
8112fb2c:	b80b883a 	mov	r5,r23
8112fb30:	102b883a 	mov	r21,r2
8112fb34:	11300b00 	call	811300b0 <__udivsi3>
8112fb38:	a806943a 	slli	r3,r21,16
8112fb3c:	a008d43a 	srli	r4,r20,16
8112fb40:	b085383a 	mul	r2,r22,r2
8112fb44:	20c8b03a 	or	r4,r4,r3
8112fb48:	2080032e 	bgeu	r4,r2,8112fb58 <__umoddi3+0xe0>
8112fb4c:	24c9883a 	add	r4,r4,r19
8112fb50:	24c00136 	bltu	r4,r19,8112fb58 <__umoddi3+0xe0>
8112fb54:	20811036 	bltu	r4,r2,8112ff98 <__umoddi3+0x520>
8112fb58:	20abc83a 	sub	r21,r4,r2
8112fb5c:	b80b883a 	mov	r5,r23
8112fb60:	a809883a 	mov	r4,r21
8112fb64:	11301140 	call	81130114 <__umodsi3>
8112fb68:	1023883a 	mov	r17,r2
8112fb6c:	b80b883a 	mov	r5,r23
8112fb70:	a809883a 	mov	r4,r21
8112fb74:	11300b00 	call	811300b0 <__udivsi3>
8112fb78:	8822943a 	slli	r17,r17,16
8112fb7c:	b085383a 	mul	r2,r22,r2
8112fb80:	a0ffffcc 	andi	r3,r20,65535
8112fb84:	1c46b03a 	or	r3,r3,r17
8112fb88:	1880042e 	bgeu	r3,r2,8112fb9c <__umoddi3+0x124>
8112fb8c:	1cc7883a 	add	r3,r3,r19
8112fb90:	1cc00236 	bltu	r3,r19,8112fb9c <__umoddi3+0x124>
8112fb94:	1880012e 	bgeu	r3,r2,8112fb9c <__umoddi3+0x124>
8112fb98:	1cc7883a 	add	r3,r3,r19
8112fb9c:	1885c83a 	sub	r2,r3,r2
8112fba0:	1484d83a 	srl	r2,r2,r18
8112fba4:	0007883a 	mov	r3,zero
8112fba8:	00004f06 	br	8112fce8 <__umoddi3+0x270>
8112fbac:	29c04c36 	bltu	r5,r7,8112fce0 <__umoddi3+0x268>
8112fbb0:	00bfffd4 	movui	r2,65535
8112fbb4:	11c0582e 	bgeu	r2,r7,8112fd18 <__umoddi3+0x2a0>
8112fbb8:	00804034 	movhi	r2,256
8112fbbc:	10bfffc4 	addi	r2,r2,-1
8112fbc0:	11c0e736 	bltu	r2,r7,8112ff60 <__umoddi3+0x4e8>
8112fbc4:	01000404 	movi	r4,16
8112fbc8:	3904d83a 	srl	r2,r7,r4
8112fbcc:	00e04574 	movhi	r3,33045
8112fbd0:	18efc704 	addi	r3,r3,-16612
8112fbd4:	1885883a 	add	r2,r3,r2
8112fbd8:	14c00003 	ldbu	r19,0(r2)
8112fbdc:	00c00804 	movi	r3,32
8112fbe0:	9927883a 	add	r19,r19,r4
8112fbe4:	1ce9c83a 	sub	r20,r3,r19
8112fbe8:	a000581e 	bne	r20,zero,8112fd4c <__umoddi3+0x2d4>
8112fbec:	3c400136 	bltu	r7,r17,8112fbf4 <__umoddi3+0x17c>
8112fbf0:	8180eb36 	bltu	r16,r6,8112ffa0 <__umoddi3+0x528>
8112fbf4:	8185c83a 	sub	r2,r16,r6
8112fbf8:	89e3c83a 	sub	r17,r17,r7
8112fbfc:	8089803a 	cmpltu	r4,r16,r2
8112fc00:	8939c83a 	sub	fp,r17,r4
8112fc04:	e007883a 	mov	r3,fp
8112fc08:	00003706 	br	8112fce8 <__umoddi3+0x270>
8112fc0c:	3000041e 	bne	r6,zero,8112fc20 <__umoddi3+0x1a8>
8112fc10:	000b883a 	mov	r5,zero
8112fc14:	01000044 	movi	r4,1
8112fc18:	11300b00 	call	811300b0 <__udivsi3>
8112fc1c:	1027883a 	mov	r19,r2
8112fc20:	00bfffd4 	movui	r2,65535
8112fc24:	14c0402e 	bgeu	r2,r19,8112fd28 <__umoddi3+0x2b0>
8112fc28:	00804034 	movhi	r2,256
8112fc2c:	10bfffc4 	addi	r2,r2,-1
8112fc30:	14c0cd36 	bltu	r2,r19,8112ff68 <__umoddi3+0x4f0>
8112fc34:	00800404 	movi	r2,16
8112fc38:	9886d83a 	srl	r3,r19,r2
8112fc3c:	01204574 	movhi	r4,33045
8112fc40:	212fc704 	addi	r4,r4,-16612
8112fc44:	20c7883a 	add	r3,r4,r3
8112fc48:	18c00003 	ldbu	r3,0(r3)
8112fc4c:	1887883a 	add	r3,r3,r2
8112fc50:	00800804 	movi	r2,32
8112fc54:	10e5c83a 	sub	r18,r2,r3
8112fc58:	9000901e 	bne	r18,zero,8112fe9c <__umoddi3+0x424>
8112fc5c:	982cd43a 	srli	r22,r19,16
8112fc60:	8ce3c83a 	sub	r17,r17,r19
8112fc64:	9d7fffcc 	andi	r21,r19,65535
8112fc68:	b00b883a 	mov	r5,r22
8112fc6c:	8809883a 	mov	r4,r17
8112fc70:	11301140 	call	81130114 <__umodsi3>
8112fc74:	8809883a 	mov	r4,r17
8112fc78:	b00b883a 	mov	r5,r22
8112fc7c:	1021883a 	mov	r16,r2
8112fc80:	11300b00 	call	811300b0 <__udivsi3>
8112fc84:	8006943a 	slli	r3,r16,16
8112fc88:	a008d43a 	srli	r4,r20,16
8112fc8c:	1545383a 	mul	r2,r2,r21
8112fc90:	20c8b03a 	or	r4,r4,r3
8112fc94:	2080042e 	bgeu	r4,r2,8112fca8 <__umoddi3+0x230>
8112fc98:	24c9883a 	add	r4,r4,r19
8112fc9c:	24c00236 	bltu	r4,r19,8112fca8 <__umoddi3+0x230>
8112fca0:	2080012e 	bgeu	r4,r2,8112fca8 <__umoddi3+0x230>
8112fca4:	24c9883a 	add	r4,r4,r19
8112fca8:	20a1c83a 	sub	r16,r4,r2
8112fcac:	b00b883a 	mov	r5,r22
8112fcb0:	8009883a 	mov	r4,r16
8112fcb4:	11301140 	call	81130114 <__umodsi3>
8112fcb8:	1023883a 	mov	r17,r2
8112fcbc:	b00b883a 	mov	r5,r22
8112fcc0:	8009883a 	mov	r4,r16
8112fcc4:	11300b00 	call	811300b0 <__udivsi3>
8112fcc8:	8822943a 	slli	r17,r17,16
8112fccc:	1545383a 	mul	r2,r2,r21
8112fcd0:	a53fffcc 	andi	r20,r20,65535
8112fcd4:	a446b03a 	or	r3,r20,r17
8112fcd8:	18bfb02e 	bgeu	r3,r2,8112fb9c <__reset+0xfb10fb9c>
8112fcdc:	003fab06 	br	8112fb8c <__reset+0xfb10fb8c>
8112fce0:	2005883a 	mov	r2,r4
8112fce4:	2807883a 	mov	r3,r5
8112fce8:	dfc00b17 	ldw	ra,44(sp)
8112fcec:	df000a17 	ldw	fp,40(sp)
8112fcf0:	ddc00917 	ldw	r23,36(sp)
8112fcf4:	dd800817 	ldw	r22,32(sp)
8112fcf8:	dd400717 	ldw	r21,28(sp)
8112fcfc:	dd000617 	ldw	r20,24(sp)
8112fd00:	dcc00517 	ldw	r19,20(sp)
8112fd04:	dc800417 	ldw	r18,16(sp)
8112fd08:	dc400317 	ldw	r17,12(sp)
8112fd0c:	dc000217 	ldw	r16,8(sp)
8112fd10:	dec00c04 	addi	sp,sp,48
8112fd14:	f800283a 	ret
8112fd18:	04c03fc4 	movi	r19,255
8112fd1c:	99c9803a 	cmpltu	r4,r19,r7
8112fd20:	200890fa 	slli	r4,r4,3
8112fd24:	003fa806 	br	8112fbc8 <__reset+0xfb10fbc8>
8112fd28:	00803fc4 	movi	r2,255
8112fd2c:	14c5803a 	cmpltu	r2,r2,r19
8112fd30:	100490fa 	slli	r2,r2,3
8112fd34:	003fc006 	br	8112fc38 <__reset+0xfb10fc38>
8112fd38:	00804034 	movhi	r2,256
8112fd3c:	10bfffc4 	addi	r2,r2,-1
8112fd40:	11808b36 	bltu	r2,r6,8112ff70 <__umoddi3+0x4f8>
8112fd44:	01000404 	movi	r4,16
8112fd48:	003f6406 	br	8112fadc <__reset+0xfb10fadc>
8112fd4c:	34c4d83a 	srl	r2,r6,r19
8112fd50:	3d0e983a 	sll	r7,r7,r20
8112fd54:	8cf8d83a 	srl	fp,r17,r19
8112fd58:	8d10983a 	sll	r8,r17,r20
8112fd5c:	38aab03a 	or	r21,r7,r2
8112fd60:	a82cd43a 	srli	r22,r21,16
8112fd64:	84e2d83a 	srl	r17,r16,r19
8112fd68:	e009883a 	mov	r4,fp
8112fd6c:	b00b883a 	mov	r5,r22
8112fd70:	8a22b03a 	or	r17,r17,r8
8112fd74:	3524983a 	sll	r18,r6,r20
8112fd78:	11301140 	call	81130114 <__umodsi3>
8112fd7c:	e009883a 	mov	r4,fp
8112fd80:	b00b883a 	mov	r5,r22
8112fd84:	102f883a 	mov	r23,r2
8112fd88:	11300b00 	call	811300b0 <__udivsi3>
8112fd8c:	100d883a 	mov	r6,r2
8112fd90:	b808943a 	slli	r4,r23,16
8112fd94:	aa3fffcc 	andi	r8,r21,65535
8112fd98:	8804d43a 	srli	r2,r17,16
8112fd9c:	41af383a 	mul	r23,r8,r6
8112fda0:	8520983a 	sll	r16,r16,r20
8112fda4:	1104b03a 	or	r2,r2,r4
8112fda8:	15c0042e 	bgeu	r2,r23,8112fdbc <__umoddi3+0x344>
8112fdac:	1545883a 	add	r2,r2,r21
8112fdb0:	30ffffc4 	addi	r3,r6,-1
8112fdb4:	1540742e 	bgeu	r2,r21,8112ff88 <__umoddi3+0x510>
8112fdb8:	180d883a 	mov	r6,r3
8112fdbc:	15efc83a 	sub	r23,r2,r23
8112fdc0:	b00b883a 	mov	r5,r22
8112fdc4:	b809883a 	mov	r4,r23
8112fdc8:	d9800115 	stw	r6,4(sp)
8112fdcc:	da000015 	stw	r8,0(sp)
8112fdd0:	11301140 	call	81130114 <__umodsi3>
8112fdd4:	b00b883a 	mov	r5,r22
8112fdd8:	b809883a 	mov	r4,r23
8112fddc:	1039883a 	mov	fp,r2
8112fde0:	11300b00 	call	811300b0 <__udivsi3>
8112fde4:	da000017 	ldw	r8,0(sp)
8112fde8:	e038943a 	slli	fp,fp,16
8112fdec:	100b883a 	mov	r5,r2
8112fdf0:	4089383a 	mul	r4,r8,r2
8112fdf4:	8a3fffcc 	andi	r8,r17,65535
8112fdf8:	4710b03a 	or	r8,r8,fp
8112fdfc:	d9800117 	ldw	r6,4(sp)
8112fe00:	4100042e 	bgeu	r8,r4,8112fe14 <__umoddi3+0x39c>
8112fe04:	4551883a 	add	r8,r8,r21
8112fe08:	10bfffc4 	addi	r2,r2,-1
8112fe0c:	45405a2e 	bgeu	r8,r21,8112ff78 <__umoddi3+0x500>
8112fe10:	100b883a 	mov	r5,r2
8112fe14:	300c943a 	slli	r6,r6,16
8112fe18:	91ffffcc 	andi	r7,r18,65535
8112fe1c:	9004d43a 	srli	r2,r18,16
8112fe20:	314cb03a 	or	r6,r6,r5
8112fe24:	317fffcc 	andi	r5,r6,65535
8112fe28:	300cd43a 	srli	r6,r6,16
8112fe2c:	29d3383a 	mul	r9,r5,r7
8112fe30:	288b383a 	mul	r5,r5,r2
8112fe34:	31cf383a 	mul	r7,r6,r7
8112fe38:	4806d43a 	srli	r3,r9,16
8112fe3c:	4111c83a 	sub	r8,r8,r4
8112fe40:	29cb883a 	add	r5,r5,r7
8112fe44:	194b883a 	add	r5,r3,r5
8112fe48:	3085383a 	mul	r2,r6,r2
8112fe4c:	29c0022e 	bgeu	r5,r7,8112fe58 <__umoddi3+0x3e0>
8112fe50:	00c00074 	movhi	r3,1
8112fe54:	10c5883a 	add	r2,r2,r3
8112fe58:	2808d43a 	srli	r4,r5,16
8112fe5c:	280a943a 	slli	r5,r5,16
8112fe60:	4a7fffcc 	andi	r9,r9,65535
8112fe64:	2085883a 	add	r2,r4,r2
8112fe68:	2a4b883a 	add	r5,r5,r9
8112fe6c:	40803636 	bltu	r8,r2,8112ff48 <__umoddi3+0x4d0>
8112fe70:	40804d26 	beq	r8,r2,8112ffa8 <__umoddi3+0x530>
8112fe74:	4089c83a 	sub	r4,r8,r2
8112fe78:	280f883a 	mov	r7,r5
8112fe7c:	81cfc83a 	sub	r7,r16,r7
8112fe80:	81c7803a 	cmpltu	r3,r16,r7
8112fe84:	20c7c83a 	sub	r3,r4,r3
8112fe88:	1cc4983a 	sll	r2,r3,r19
8112fe8c:	3d0ed83a 	srl	r7,r7,r20
8112fe90:	1d06d83a 	srl	r3,r3,r20
8112fe94:	11c4b03a 	or	r2,r2,r7
8112fe98:	003f9306 	br	8112fce8 <__reset+0xfb10fce8>
8112fe9c:	9ca6983a 	sll	r19,r19,r18
8112fea0:	88e8d83a 	srl	r20,r17,r3
8112fea4:	80c4d83a 	srl	r2,r16,r3
8112fea8:	982cd43a 	srli	r22,r19,16
8112feac:	8ca2983a 	sll	r17,r17,r18
8112feb0:	a009883a 	mov	r4,r20
8112feb4:	b00b883a 	mov	r5,r22
8112feb8:	1478b03a 	or	fp,r2,r17
8112febc:	11301140 	call	81130114 <__umodsi3>
8112fec0:	a009883a 	mov	r4,r20
8112fec4:	b00b883a 	mov	r5,r22
8112fec8:	1023883a 	mov	r17,r2
8112fecc:	11300b00 	call	811300b0 <__udivsi3>
8112fed0:	9d7fffcc 	andi	r21,r19,65535
8112fed4:	880a943a 	slli	r5,r17,16
8112fed8:	e008d43a 	srli	r4,fp,16
8112fedc:	a885383a 	mul	r2,r21,r2
8112fee0:	84a8983a 	sll	r20,r16,r18
8112fee4:	2148b03a 	or	r4,r4,r5
8112fee8:	2080042e 	bgeu	r4,r2,8112fefc <__umoddi3+0x484>
8112feec:	24c9883a 	add	r4,r4,r19
8112fef0:	24c00236 	bltu	r4,r19,8112fefc <__umoddi3+0x484>
8112fef4:	2080012e 	bgeu	r4,r2,8112fefc <__umoddi3+0x484>
8112fef8:	24c9883a 	add	r4,r4,r19
8112fefc:	20a3c83a 	sub	r17,r4,r2
8112ff00:	b00b883a 	mov	r5,r22
8112ff04:	8809883a 	mov	r4,r17
8112ff08:	11301140 	call	81130114 <__umodsi3>
8112ff0c:	102f883a 	mov	r23,r2
8112ff10:	8809883a 	mov	r4,r17
8112ff14:	b00b883a 	mov	r5,r22
8112ff18:	11300b00 	call	811300b0 <__udivsi3>
8112ff1c:	b82e943a 	slli	r23,r23,16
8112ff20:	a885383a 	mul	r2,r21,r2
8112ff24:	e13fffcc 	andi	r4,fp,65535
8112ff28:	25c8b03a 	or	r4,r4,r23
8112ff2c:	2080042e 	bgeu	r4,r2,8112ff40 <__umoddi3+0x4c8>
8112ff30:	24c9883a 	add	r4,r4,r19
8112ff34:	24c00236 	bltu	r4,r19,8112ff40 <__umoddi3+0x4c8>
8112ff38:	2080012e 	bgeu	r4,r2,8112ff40 <__umoddi3+0x4c8>
8112ff3c:	24c9883a 	add	r4,r4,r19
8112ff40:	20a3c83a 	sub	r17,r4,r2
8112ff44:	003f4806 	br	8112fc68 <__reset+0xfb10fc68>
8112ff48:	2c8fc83a 	sub	r7,r5,r18
8112ff4c:	1545c83a 	sub	r2,r2,r21
8112ff50:	29cb803a 	cmpltu	r5,r5,r7
8112ff54:	1145c83a 	sub	r2,r2,r5
8112ff58:	4089c83a 	sub	r4,r8,r2
8112ff5c:	003fc706 	br	8112fe7c <__reset+0xfb10fe7c>
8112ff60:	01000604 	movi	r4,24
8112ff64:	003f1806 	br	8112fbc8 <__reset+0xfb10fbc8>
8112ff68:	00800604 	movi	r2,24
8112ff6c:	003f3206 	br	8112fc38 <__reset+0xfb10fc38>
8112ff70:	01000604 	movi	r4,24
8112ff74:	003ed906 	br	8112fadc <__reset+0xfb10fadc>
8112ff78:	413fa52e 	bgeu	r8,r4,8112fe10 <__reset+0xfb10fe10>
8112ff7c:	297fff84 	addi	r5,r5,-2
8112ff80:	4551883a 	add	r8,r8,r21
8112ff84:	003fa306 	br	8112fe14 <__reset+0xfb10fe14>
8112ff88:	15ff8b2e 	bgeu	r2,r23,8112fdb8 <__reset+0xfb10fdb8>
8112ff8c:	31bfff84 	addi	r6,r6,-2
8112ff90:	1545883a 	add	r2,r2,r21
8112ff94:	003f8906 	br	8112fdbc <__reset+0xfb10fdbc>
8112ff98:	24c9883a 	add	r4,r4,r19
8112ff9c:	003eee06 	br	8112fb58 <__reset+0xfb10fb58>
8112ffa0:	8005883a 	mov	r2,r16
8112ffa4:	003f1706 	br	8112fc04 <__reset+0xfb10fc04>
8112ffa8:	817fe736 	bltu	r16,r5,8112ff48 <__reset+0xfb10ff48>
8112ffac:	280f883a 	mov	r7,r5
8112ffb0:	0009883a 	mov	r4,zero
8112ffb4:	003fb106 	br	8112fe7c <__reset+0xfb10fe7c>

8112ffb8 <__divsi3>:
8112ffb8:	20001b16 	blt	r4,zero,81130028 <__divsi3+0x70>
8112ffbc:	000f883a 	mov	r7,zero
8112ffc0:	28001616 	blt	r5,zero,8113001c <__divsi3+0x64>
8112ffc4:	200d883a 	mov	r6,r4
8112ffc8:	29001a2e 	bgeu	r5,r4,81130034 <__divsi3+0x7c>
8112ffcc:	00800804 	movi	r2,32
8112ffd0:	00c00044 	movi	r3,1
8112ffd4:	00000106 	br	8112ffdc <__divsi3+0x24>
8112ffd8:	10000d26 	beq	r2,zero,81130010 <__divsi3+0x58>
8112ffdc:	294b883a 	add	r5,r5,r5
8112ffe0:	10bfffc4 	addi	r2,r2,-1
8112ffe4:	18c7883a 	add	r3,r3,r3
8112ffe8:	293ffb36 	bltu	r5,r4,8112ffd8 <__reset+0xfb10ffd8>
8112ffec:	0005883a 	mov	r2,zero
8112fff0:	18000726 	beq	r3,zero,81130010 <__divsi3+0x58>
8112fff4:	0005883a 	mov	r2,zero
8112fff8:	31400236 	bltu	r6,r5,81130004 <__divsi3+0x4c>
8112fffc:	314dc83a 	sub	r6,r6,r5
81130000:	10c4b03a 	or	r2,r2,r3
81130004:	1806d07a 	srli	r3,r3,1
81130008:	280ad07a 	srli	r5,r5,1
8113000c:	183ffa1e 	bne	r3,zero,8112fff8 <__reset+0xfb10fff8>
81130010:	38000126 	beq	r7,zero,81130018 <__divsi3+0x60>
81130014:	0085c83a 	sub	r2,zero,r2
81130018:	f800283a 	ret
8113001c:	014bc83a 	sub	r5,zero,r5
81130020:	39c0005c 	xori	r7,r7,1
81130024:	003fe706 	br	8112ffc4 <__reset+0xfb10ffc4>
81130028:	0109c83a 	sub	r4,zero,r4
8113002c:	01c00044 	movi	r7,1
81130030:	003fe306 	br	8112ffc0 <__reset+0xfb10ffc0>
81130034:	00c00044 	movi	r3,1
81130038:	003fee06 	br	8112fff4 <__reset+0xfb10fff4>

8113003c <__modsi3>:
8113003c:	20001716 	blt	r4,zero,8113009c <__modsi3+0x60>
81130040:	000f883a 	mov	r7,zero
81130044:	2005883a 	mov	r2,r4
81130048:	28001216 	blt	r5,zero,81130094 <__modsi3+0x58>
8113004c:	2900162e 	bgeu	r5,r4,811300a8 <__modsi3+0x6c>
81130050:	01800804 	movi	r6,32
81130054:	00c00044 	movi	r3,1
81130058:	00000106 	br	81130060 <__modsi3+0x24>
8113005c:	30000a26 	beq	r6,zero,81130088 <__modsi3+0x4c>
81130060:	294b883a 	add	r5,r5,r5
81130064:	31bfffc4 	addi	r6,r6,-1
81130068:	18c7883a 	add	r3,r3,r3
8113006c:	293ffb36 	bltu	r5,r4,8113005c <__reset+0xfb11005c>
81130070:	18000526 	beq	r3,zero,81130088 <__modsi3+0x4c>
81130074:	1806d07a 	srli	r3,r3,1
81130078:	11400136 	bltu	r2,r5,81130080 <__modsi3+0x44>
8113007c:	1145c83a 	sub	r2,r2,r5
81130080:	280ad07a 	srli	r5,r5,1
81130084:	183ffb1e 	bne	r3,zero,81130074 <__reset+0xfb110074>
81130088:	38000126 	beq	r7,zero,81130090 <__modsi3+0x54>
8113008c:	0085c83a 	sub	r2,zero,r2
81130090:	f800283a 	ret
81130094:	014bc83a 	sub	r5,zero,r5
81130098:	003fec06 	br	8113004c <__reset+0xfb11004c>
8113009c:	0109c83a 	sub	r4,zero,r4
811300a0:	01c00044 	movi	r7,1
811300a4:	003fe706 	br	81130044 <__reset+0xfb110044>
811300a8:	00c00044 	movi	r3,1
811300ac:	003ff106 	br	81130074 <__reset+0xfb110074>

811300b0 <__udivsi3>:
811300b0:	200d883a 	mov	r6,r4
811300b4:	2900152e 	bgeu	r5,r4,8113010c <__udivsi3+0x5c>
811300b8:	28001416 	blt	r5,zero,8113010c <__udivsi3+0x5c>
811300bc:	00800804 	movi	r2,32
811300c0:	00c00044 	movi	r3,1
811300c4:	00000206 	br	811300d0 <__udivsi3+0x20>
811300c8:	10000e26 	beq	r2,zero,81130104 <__udivsi3+0x54>
811300cc:	28000516 	blt	r5,zero,811300e4 <__udivsi3+0x34>
811300d0:	294b883a 	add	r5,r5,r5
811300d4:	10bfffc4 	addi	r2,r2,-1
811300d8:	18c7883a 	add	r3,r3,r3
811300dc:	293ffa36 	bltu	r5,r4,811300c8 <__reset+0xfb1100c8>
811300e0:	18000826 	beq	r3,zero,81130104 <__udivsi3+0x54>
811300e4:	0005883a 	mov	r2,zero
811300e8:	31400236 	bltu	r6,r5,811300f4 <__udivsi3+0x44>
811300ec:	314dc83a 	sub	r6,r6,r5
811300f0:	10c4b03a 	or	r2,r2,r3
811300f4:	1806d07a 	srli	r3,r3,1
811300f8:	280ad07a 	srli	r5,r5,1
811300fc:	183ffa1e 	bne	r3,zero,811300e8 <__reset+0xfb1100e8>
81130100:	f800283a 	ret
81130104:	0005883a 	mov	r2,zero
81130108:	f800283a 	ret
8113010c:	00c00044 	movi	r3,1
81130110:	003ff406 	br	811300e4 <__reset+0xfb1100e4>

81130114 <__umodsi3>:
81130114:	2005883a 	mov	r2,r4
81130118:	2900122e 	bgeu	r5,r4,81130164 <__umodsi3+0x50>
8113011c:	28001116 	blt	r5,zero,81130164 <__umodsi3+0x50>
81130120:	01800804 	movi	r6,32
81130124:	00c00044 	movi	r3,1
81130128:	00000206 	br	81130134 <__umodsi3+0x20>
8113012c:	30000c26 	beq	r6,zero,81130160 <__umodsi3+0x4c>
81130130:	28000516 	blt	r5,zero,81130148 <__umodsi3+0x34>
81130134:	294b883a 	add	r5,r5,r5
81130138:	31bfffc4 	addi	r6,r6,-1
8113013c:	18c7883a 	add	r3,r3,r3
81130140:	293ffa36 	bltu	r5,r4,8113012c <__reset+0xfb11012c>
81130144:	18000626 	beq	r3,zero,81130160 <__umodsi3+0x4c>
81130148:	1806d07a 	srli	r3,r3,1
8113014c:	11400136 	bltu	r2,r5,81130154 <__umodsi3+0x40>
81130150:	1145c83a 	sub	r2,r2,r5
81130154:	280ad07a 	srli	r5,r5,1
81130158:	183ffb1e 	bne	r3,zero,81130148 <__reset+0xfb110148>
8113015c:	f800283a 	ret
81130160:	f800283a 	ret
81130164:	00c00044 	movi	r3,1
81130168:	003ff706 	br	81130148 <__reset+0xfb110148>

8113016c <__eqsf2>:
8113016c:	2006d5fa 	srli	r3,r4,23
81130170:	280cd5fa 	srli	r6,r5,23
81130174:	01c02034 	movhi	r7,128
81130178:	39ffffc4 	addi	r7,r7,-1
8113017c:	18c03fcc 	andi	r3,r3,255
81130180:	02003fc4 	movi	r8,255
81130184:	3904703a 	and	r2,r7,r4
81130188:	31803fcc 	andi	r6,r6,255
8113018c:	394e703a 	and	r7,r7,r5
81130190:	2008d7fa 	srli	r4,r4,31
81130194:	280ad7fa 	srli	r5,r5,31
81130198:	1a000d26 	beq	r3,r8,811301d0 <__eqsf2+0x64>
8113019c:	02003fc4 	movi	r8,255
811301a0:	32000826 	beq	r6,r8,811301c4 <__eqsf2+0x58>
811301a4:	19800226 	beq	r3,r6,811301b0 <__eqsf2+0x44>
811301a8:	00800044 	movi	r2,1
811301ac:	f800283a 	ret
811301b0:	11fffd1e 	bne	r2,r7,811301a8 <__reset+0xfb1101a8>
811301b4:	21400926 	beq	r4,r5,811301dc <__eqsf2+0x70>
811301b8:	183ffb1e 	bne	r3,zero,811301a8 <__reset+0xfb1101a8>
811301bc:	1004c03a 	cmpne	r2,r2,zero
811301c0:	f800283a 	ret
811301c4:	383ff726 	beq	r7,zero,811301a4 <__reset+0xfb1101a4>
811301c8:	00800044 	movi	r2,1
811301cc:	f800283a 	ret
811301d0:	103ff226 	beq	r2,zero,8113019c <__reset+0xfb11019c>
811301d4:	00800044 	movi	r2,1
811301d8:	f800283a 	ret
811301dc:	0005883a 	mov	r2,zero
811301e0:	f800283a 	ret

811301e4 <__gesf2>:
811301e4:	2004d5fa 	srli	r2,r4,23
811301e8:	2806d5fa 	srli	r3,r5,23
811301ec:	01802034 	movhi	r6,128
811301f0:	31bfffc4 	addi	r6,r6,-1
811301f4:	10803fcc 	andi	r2,r2,255
811301f8:	01c03fc4 	movi	r7,255
811301fc:	3110703a 	and	r8,r6,r4
81130200:	18c03fcc 	andi	r3,r3,255
81130204:	314c703a 	and	r6,r6,r5
81130208:	2008d7fa 	srli	r4,r4,31
8113020c:	280ad7fa 	srli	r5,r5,31
81130210:	11c01926 	beq	r2,r7,81130278 <__gesf2+0x94>
81130214:	01c03fc4 	movi	r7,255
81130218:	19c00f26 	beq	r3,r7,81130258 <__gesf2+0x74>
8113021c:	1000061e 	bne	r2,zero,81130238 <__gesf2+0x54>
81130220:	400f003a 	cmpeq	r7,r8,zero
81130224:	1800071e 	bne	r3,zero,81130244 <__gesf2+0x60>
81130228:	3000061e 	bne	r6,zero,81130244 <__gesf2+0x60>
8113022c:	0005883a 	mov	r2,zero
81130230:	40000e1e 	bne	r8,zero,8113026c <__gesf2+0x88>
81130234:	f800283a 	ret
81130238:	18000a1e 	bne	r3,zero,81130264 <__gesf2+0x80>
8113023c:	30000b26 	beq	r6,zero,8113026c <__gesf2+0x88>
81130240:	000f883a 	mov	r7,zero
81130244:	29403fcc 	andi	r5,r5,255
81130248:	38000726 	beq	r7,zero,81130268 <__gesf2+0x84>
8113024c:	28000826 	beq	r5,zero,81130270 <__gesf2+0x8c>
81130250:	00800044 	movi	r2,1
81130254:	f800283a 	ret
81130258:	303ff026 	beq	r6,zero,8113021c <__reset+0xfb11021c>
8113025c:	00bfff84 	movi	r2,-2
81130260:	f800283a 	ret
81130264:	29403fcc 	andi	r5,r5,255
81130268:	21400526 	beq	r4,r5,81130280 <__gesf2+0x9c>
8113026c:	203ff826 	beq	r4,zero,81130250 <__reset+0xfb110250>
81130270:	00bfffc4 	movi	r2,-1
81130274:	f800283a 	ret
81130278:	403fe626 	beq	r8,zero,81130214 <__reset+0xfb110214>
8113027c:	003ff706 	br	8113025c <__reset+0xfb11025c>
81130280:	18bffa16 	blt	r3,r2,8113026c <__reset+0xfb11026c>
81130284:	10c00216 	blt	r2,r3,81130290 <__gesf2+0xac>
81130288:	323ff836 	bltu	r6,r8,8113026c <__reset+0xfb11026c>
8113028c:	4180022e 	bgeu	r8,r6,81130298 <__gesf2+0xb4>
81130290:	203fef1e 	bne	r4,zero,81130250 <__reset+0xfb110250>
81130294:	003ff606 	br	81130270 <__reset+0xfb110270>
81130298:	0005883a 	mov	r2,zero
8113029c:	f800283a 	ret

811302a0 <__lesf2>:
811302a0:	2004d5fa 	srli	r2,r4,23
811302a4:	280cd5fa 	srli	r6,r5,23
811302a8:	00c02034 	movhi	r3,128
811302ac:	18ffffc4 	addi	r3,r3,-1
811302b0:	10803fcc 	andi	r2,r2,255
811302b4:	01c03fc4 	movi	r7,255
811302b8:	1910703a 	and	r8,r3,r4
811302bc:	31803fcc 	andi	r6,r6,255
811302c0:	1946703a 	and	r3,r3,r5
811302c4:	2008d7fa 	srli	r4,r4,31
811302c8:	280ad7fa 	srli	r5,r5,31
811302cc:	11c01b26 	beq	r2,r7,8113033c <__lesf2+0x9c>
811302d0:	01c03fc4 	movi	r7,255
811302d4:	31c01126 	beq	r6,r7,8113031c <__lesf2+0x7c>
811302d8:	1000071e 	bne	r2,zero,811302f8 <__lesf2+0x58>
811302dc:	400f003a 	cmpeq	r7,r8,zero
811302e0:	21003fcc 	andi	r4,r4,255
811302e4:	3000081e 	bne	r6,zero,81130308 <__lesf2+0x68>
811302e8:	1800071e 	bne	r3,zero,81130308 <__lesf2+0x68>
811302ec:	0005883a 	mov	r2,zero
811302f0:	40000f1e 	bne	r8,zero,81130330 <__lesf2+0x90>
811302f4:	f800283a 	ret
811302f8:	21003fcc 	andi	r4,r4,255
811302fc:	30000a1e 	bne	r6,zero,81130328 <__lesf2+0x88>
81130300:	18000b26 	beq	r3,zero,81130330 <__lesf2+0x90>
81130304:	000f883a 	mov	r7,zero
81130308:	29403fcc 	andi	r5,r5,255
8113030c:	38000726 	beq	r7,zero,8113032c <__lesf2+0x8c>
81130310:	28000826 	beq	r5,zero,81130334 <__lesf2+0x94>
81130314:	00800044 	movi	r2,1
81130318:	f800283a 	ret
8113031c:	183fee26 	beq	r3,zero,811302d8 <__reset+0xfb1102d8>
81130320:	00800084 	movi	r2,2
81130324:	f800283a 	ret
81130328:	29403fcc 	andi	r5,r5,255
8113032c:	21400626 	beq	r4,r5,81130348 <__lesf2+0xa8>
81130330:	203ff826 	beq	r4,zero,81130314 <__reset+0xfb110314>
81130334:	00bfffc4 	movi	r2,-1
81130338:	f800283a 	ret
8113033c:	403fe426 	beq	r8,zero,811302d0 <__reset+0xfb1102d0>
81130340:	00800084 	movi	r2,2
81130344:	f800283a 	ret
81130348:	30bff916 	blt	r6,r2,81130330 <__reset+0xfb110330>
8113034c:	11800216 	blt	r2,r6,81130358 <__lesf2+0xb8>
81130350:	1a3ff736 	bltu	r3,r8,81130330 <__reset+0xfb110330>
81130354:	40c0022e 	bgeu	r8,r3,81130360 <__lesf2+0xc0>
81130358:	203fee1e 	bne	r4,zero,81130314 <__reset+0xfb110314>
8113035c:	003ff506 	br	81130334 <__reset+0xfb110334>
81130360:	0005883a 	mov	r2,zero
81130364:	f800283a 	ret

81130368 <__adddf3>:
81130368:	02c00434 	movhi	r11,16
8113036c:	5affffc4 	addi	r11,r11,-1
81130370:	2806d7fa 	srli	r3,r5,31
81130374:	2ad4703a 	and	r10,r5,r11
81130378:	3ad2703a 	and	r9,r7,r11
8113037c:	3804d53a 	srli	r2,r7,20
81130380:	3018d77a 	srli	r12,r6,29
81130384:	280ad53a 	srli	r5,r5,20
81130388:	501490fa 	slli	r10,r10,3
8113038c:	2010d77a 	srli	r8,r4,29
81130390:	481290fa 	slli	r9,r9,3
81130394:	380ed7fa 	srli	r7,r7,31
81130398:	defffb04 	addi	sp,sp,-20
8113039c:	de00012e 	bgeu	sp,et,811303a4 <__adddf3+0x3c>
811303a0:	003b68fa 	trap	3
811303a4:	dc800215 	stw	r18,8(sp)
811303a8:	dc400115 	stw	r17,4(sp)
811303ac:	dc000015 	stw	r16,0(sp)
811303b0:	dfc00415 	stw	ra,16(sp)
811303b4:	dcc00315 	stw	r19,12(sp)
811303b8:	1c803fcc 	andi	r18,r3,255
811303bc:	2c01ffcc 	andi	r16,r5,2047
811303c0:	5210b03a 	or	r8,r10,r8
811303c4:	202290fa 	slli	r17,r4,3
811303c8:	1081ffcc 	andi	r2,r2,2047
811303cc:	4b12b03a 	or	r9,r9,r12
811303d0:	300c90fa 	slli	r6,r6,3
811303d4:	91c07526 	beq	r18,r7,811305ac <__adddf3+0x244>
811303d8:	8087c83a 	sub	r3,r16,r2
811303dc:	00c0ab0e 	bge	zero,r3,8113068c <__adddf3+0x324>
811303e0:	10002a1e 	bne	r2,zero,8113048c <__adddf3+0x124>
811303e4:	4984b03a 	or	r2,r9,r6
811303e8:	1000961e 	bne	r2,zero,81130644 <__adddf3+0x2dc>
811303ec:	888001cc 	andi	r2,r17,7
811303f0:	10000726 	beq	r2,zero,81130410 <__adddf3+0xa8>
811303f4:	888003cc 	andi	r2,r17,15
811303f8:	00c00104 	movi	r3,4
811303fc:	10c00426 	beq	r2,r3,81130410 <__adddf3+0xa8>
81130400:	88c7883a 	add	r3,r17,r3
81130404:	1c63803a 	cmpltu	r17,r3,r17
81130408:	4451883a 	add	r8,r8,r17
8113040c:	1823883a 	mov	r17,r3
81130410:	4080202c 	andhi	r2,r8,128
81130414:	10005926 	beq	r2,zero,8113057c <__adddf3+0x214>
81130418:	84000044 	addi	r16,r16,1
8113041c:	0081ffc4 	movi	r2,2047
81130420:	8080ba26 	beq	r16,r2,8113070c <__adddf3+0x3a4>
81130424:	00bfe034 	movhi	r2,65408
81130428:	10bfffc4 	addi	r2,r2,-1
8113042c:	4090703a 	and	r8,r8,r2
81130430:	4004977a 	slli	r2,r8,29
81130434:	4010927a 	slli	r8,r8,9
81130438:	8822d0fa 	srli	r17,r17,3
8113043c:	8401ffcc 	andi	r16,r16,2047
81130440:	4010d33a 	srli	r8,r8,12
81130444:	9007883a 	mov	r3,r18
81130448:	1444b03a 	or	r2,r2,r17
8113044c:	8401ffcc 	andi	r16,r16,2047
81130450:	8020953a 	slli	r16,r16,20
81130454:	18c03fcc 	andi	r3,r3,255
81130458:	01000434 	movhi	r4,16
8113045c:	213fffc4 	addi	r4,r4,-1
81130460:	180697fa 	slli	r3,r3,31
81130464:	4110703a 	and	r8,r8,r4
81130468:	4410b03a 	or	r8,r8,r16
8113046c:	40c6b03a 	or	r3,r8,r3
81130470:	dfc00417 	ldw	ra,16(sp)
81130474:	dcc00317 	ldw	r19,12(sp)
81130478:	dc800217 	ldw	r18,8(sp)
8113047c:	dc400117 	ldw	r17,4(sp)
81130480:	dc000017 	ldw	r16,0(sp)
81130484:	dec00504 	addi	sp,sp,20
81130488:	f800283a 	ret
8113048c:	0081ffc4 	movi	r2,2047
81130490:	80bfd626 	beq	r16,r2,811303ec <__reset+0xfb1103ec>
81130494:	4a402034 	orhi	r9,r9,128
81130498:	00800e04 	movi	r2,56
8113049c:	10c09f16 	blt	r2,r3,8113071c <__adddf3+0x3b4>
811304a0:	008007c4 	movi	r2,31
811304a4:	10c0c216 	blt	r2,r3,811307b0 <__adddf3+0x448>
811304a8:	00800804 	movi	r2,32
811304ac:	10c5c83a 	sub	r2,r2,r3
811304b0:	488a983a 	sll	r5,r9,r2
811304b4:	30c8d83a 	srl	r4,r6,r3
811304b8:	3084983a 	sll	r2,r6,r2
811304bc:	48c6d83a 	srl	r3,r9,r3
811304c0:	290cb03a 	or	r6,r5,r4
811304c4:	1004c03a 	cmpne	r2,r2,zero
811304c8:	308cb03a 	or	r6,r6,r2
811304cc:	898dc83a 	sub	r6,r17,r6
811304d0:	89a3803a 	cmpltu	r17,r17,r6
811304d4:	40d1c83a 	sub	r8,r8,r3
811304d8:	4451c83a 	sub	r8,r8,r17
811304dc:	3023883a 	mov	r17,r6
811304e0:	4080202c 	andhi	r2,r8,128
811304e4:	10002326 	beq	r2,zero,81130574 <__adddf3+0x20c>
811304e8:	04c02034 	movhi	r19,128
811304ec:	9cffffc4 	addi	r19,r19,-1
811304f0:	44e6703a 	and	r19,r8,r19
811304f4:	98007626 	beq	r19,zero,811306d0 <__adddf3+0x368>
811304f8:	9809883a 	mov	r4,r19
811304fc:	111c8580 	call	8111c858 <__clzsi2>
81130500:	10fffe04 	addi	r3,r2,-8
81130504:	010007c4 	movi	r4,31
81130508:	20c07716 	blt	r4,r3,811306e8 <__adddf3+0x380>
8113050c:	00800804 	movi	r2,32
81130510:	10c5c83a 	sub	r2,r2,r3
81130514:	8884d83a 	srl	r2,r17,r2
81130518:	98d0983a 	sll	r8,r19,r3
8113051c:	88e2983a 	sll	r17,r17,r3
81130520:	1204b03a 	or	r2,r2,r8
81130524:	1c007416 	blt	r3,r16,811306f8 <__adddf3+0x390>
81130528:	1c21c83a 	sub	r16,r3,r16
8113052c:	82000044 	addi	r8,r16,1
81130530:	00c007c4 	movi	r3,31
81130534:	1a009116 	blt	r3,r8,8113077c <__adddf3+0x414>
81130538:	00c00804 	movi	r3,32
8113053c:	1a07c83a 	sub	r3,r3,r8
81130540:	8a08d83a 	srl	r4,r17,r8
81130544:	88e2983a 	sll	r17,r17,r3
81130548:	10c6983a 	sll	r3,r2,r3
8113054c:	1210d83a 	srl	r8,r2,r8
81130550:	8804c03a 	cmpne	r2,r17,zero
81130554:	1906b03a 	or	r3,r3,r4
81130558:	18a2b03a 	or	r17,r3,r2
8113055c:	0021883a 	mov	r16,zero
81130560:	003fa206 	br	811303ec <__reset+0xfb1103ec>
81130564:	1890b03a 	or	r8,r3,r2
81130568:	40017d26 	beq	r8,zero,81130b60 <__adddf3+0x7f8>
8113056c:	1011883a 	mov	r8,r2
81130570:	1823883a 	mov	r17,r3
81130574:	888001cc 	andi	r2,r17,7
81130578:	103f9e1e 	bne	r2,zero,811303f4 <__reset+0xfb1103f4>
8113057c:	4004977a 	slli	r2,r8,29
81130580:	8822d0fa 	srli	r17,r17,3
81130584:	4010d0fa 	srli	r8,r8,3
81130588:	9007883a 	mov	r3,r18
8113058c:	1444b03a 	or	r2,r2,r17
81130590:	0101ffc4 	movi	r4,2047
81130594:	81002426 	beq	r16,r4,81130628 <__adddf3+0x2c0>
81130598:	8120703a 	and	r16,r16,r4
8113059c:	01000434 	movhi	r4,16
811305a0:	213fffc4 	addi	r4,r4,-1
811305a4:	4110703a 	and	r8,r8,r4
811305a8:	003fa806 	br	8113044c <__reset+0xfb11044c>
811305ac:	8089c83a 	sub	r4,r16,r2
811305b0:	01005e0e 	bge	zero,r4,8113072c <__adddf3+0x3c4>
811305b4:	10002b26 	beq	r2,zero,81130664 <__adddf3+0x2fc>
811305b8:	0081ffc4 	movi	r2,2047
811305bc:	80bf8b26 	beq	r16,r2,811303ec <__reset+0xfb1103ec>
811305c0:	4a402034 	orhi	r9,r9,128
811305c4:	00800e04 	movi	r2,56
811305c8:	1100a40e 	bge	r2,r4,8113085c <__adddf3+0x4f4>
811305cc:	498cb03a 	or	r6,r9,r6
811305d0:	300ac03a 	cmpne	r5,r6,zero
811305d4:	0013883a 	mov	r9,zero
811305d8:	2c4b883a 	add	r5,r5,r17
811305dc:	2c63803a 	cmpltu	r17,r5,r17
811305e0:	4a11883a 	add	r8,r9,r8
811305e4:	8a11883a 	add	r8,r17,r8
811305e8:	2823883a 	mov	r17,r5
811305ec:	4080202c 	andhi	r2,r8,128
811305f0:	103fe026 	beq	r2,zero,81130574 <__reset+0xfb110574>
811305f4:	84000044 	addi	r16,r16,1
811305f8:	0081ffc4 	movi	r2,2047
811305fc:	8080d226 	beq	r16,r2,81130948 <__adddf3+0x5e0>
81130600:	00bfe034 	movhi	r2,65408
81130604:	10bfffc4 	addi	r2,r2,-1
81130608:	4090703a 	and	r8,r8,r2
8113060c:	880ad07a 	srli	r5,r17,1
81130610:	400897fa 	slli	r4,r8,31
81130614:	88c0004c 	andi	r3,r17,1
81130618:	28e2b03a 	or	r17,r5,r3
8113061c:	4010d07a 	srli	r8,r8,1
81130620:	2462b03a 	or	r17,r4,r17
81130624:	003f7106 	br	811303ec <__reset+0xfb1103ec>
81130628:	4088b03a 	or	r4,r8,r2
8113062c:	20014526 	beq	r4,zero,81130b44 <__adddf3+0x7dc>
81130630:	01000434 	movhi	r4,16
81130634:	42000234 	orhi	r8,r8,8
81130638:	213fffc4 	addi	r4,r4,-1
8113063c:	4110703a 	and	r8,r8,r4
81130640:	003f8206 	br	8113044c <__reset+0xfb11044c>
81130644:	18ffffc4 	addi	r3,r3,-1
81130648:	1800491e 	bne	r3,zero,81130770 <__adddf3+0x408>
8113064c:	898bc83a 	sub	r5,r17,r6
81130650:	8963803a 	cmpltu	r17,r17,r5
81130654:	4251c83a 	sub	r8,r8,r9
81130658:	4451c83a 	sub	r8,r8,r17
8113065c:	2823883a 	mov	r17,r5
81130660:	003f9f06 	br	811304e0 <__reset+0xfb1104e0>
81130664:	4984b03a 	or	r2,r9,r6
81130668:	103f6026 	beq	r2,zero,811303ec <__reset+0xfb1103ec>
8113066c:	213fffc4 	addi	r4,r4,-1
81130670:	2000931e 	bne	r4,zero,811308c0 <__adddf3+0x558>
81130674:	898d883a 	add	r6,r17,r6
81130678:	3463803a 	cmpltu	r17,r6,r17
8113067c:	4251883a 	add	r8,r8,r9
81130680:	8a11883a 	add	r8,r17,r8
81130684:	3023883a 	mov	r17,r6
81130688:	003fd806 	br	811305ec <__reset+0xfb1105ec>
8113068c:	1800541e 	bne	r3,zero,811307e0 <__adddf3+0x478>
81130690:	80800044 	addi	r2,r16,1
81130694:	1081ffcc 	andi	r2,r2,2047
81130698:	00c00044 	movi	r3,1
8113069c:	1880a00e 	bge	r3,r2,81130920 <__adddf3+0x5b8>
811306a0:	8989c83a 	sub	r4,r17,r6
811306a4:	8905803a 	cmpltu	r2,r17,r4
811306a8:	4267c83a 	sub	r19,r8,r9
811306ac:	98a7c83a 	sub	r19,r19,r2
811306b0:	9880202c 	andhi	r2,r19,128
811306b4:	10006326 	beq	r2,zero,81130844 <__adddf3+0x4dc>
811306b8:	3463c83a 	sub	r17,r6,r17
811306bc:	4a07c83a 	sub	r3,r9,r8
811306c0:	344d803a 	cmpltu	r6,r6,r17
811306c4:	19a7c83a 	sub	r19,r3,r6
811306c8:	3825883a 	mov	r18,r7
811306cc:	983f8a1e 	bne	r19,zero,811304f8 <__reset+0xfb1104f8>
811306d0:	8809883a 	mov	r4,r17
811306d4:	111c8580 	call	8111c858 <__clzsi2>
811306d8:	10800804 	addi	r2,r2,32
811306dc:	10fffe04 	addi	r3,r2,-8
811306e0:	010007c4 	movi	r4,31
811306e4:	20ff890e 	bge	r4,r3,8113050c <__reset+0xfb11050c>
811306e8:	10bff604 	addi	r2,r2,-40
811306ec:	8884983a 	sll	r2,r17,r2
811306f0:	0023883a 	mov	r17,zero
811306f4:	1c3f8c0e 	bge	r3,r16,81130528 <__reset+0xfb110528>
811306f8:	023fe034 	movhi	r8,65408
811306fc:	423fffc4 	addi	r8,r8,-1
81130700:	80e1c83a 	sub	r16,r16,r3
81130704:	1210703a 	and	r8,r2,r8
81130708:	003f3806 	br	811303ec <__reset+0xfb1103ec>
8113070c:	9007883a 	mov	r3,r18
81130710:	0011883a 	mov	r8,zero
81130714:	0005883a 	mov	r2,zero
81130718:	003f4c06 	br	8113044c <__reset+0xfb11044c>
8113071c:	498cb03a 	or	r6,r9,r6
81130720:	300cc03a 	cmpne	r6,r6,zero
81130724:	0007883a 	mov	r3,zero
81130728:	003f6806 	br	811304cc <__reset+0xfb1104cc>
8113072c:	20009c1e 	bne	r4,zero,811309a0 <__adddf3+0x638>
81130730:	80800044 	addi	r2,r16,1
81130734:	1141ffcc 	andi	r5,r2,2047
81130738:	01000044 	movi	r4,1
8113073c:	2140670e 	bge	r4,r5,811308dc <__adddf3+0x574>
81130740:	0101ffc4 	movi	r4,2047
81130744:	11007f26 	beq	r2,r4,81130944 <__adddf3+0x5dc>
81130748:	898d883a 	add	r6,r17,r6
8113074c:	4247883a 	add	r3,r8,r9
81130750:	3451803a 	cmpltu	r8,r6,r17
81130754:	40d1883a 	add	r8,r8,r3
81130758:	402297fa 	slli	r17,r8,31
8113075c:	300cd07a 	srli	r6,r6,1
81130760:	4010d07a 	srli	r8,r8,1
81130764:	1021883a 	mov	r16,r2
81130768:	89a2b03a 	or	r17,r17,r6
8113076c:	003f1f06 	br	811303ec <__reset+0xfb1103ec>
81130770:	0081ffc4 	movi	r2,2047
81130774:	80bf481e 	bne	r16,r2,81130498 <__reset+0xfb110498>
81130778:	003f1c06 	br	811303ec <__reset+0xfb1103ec>
8113077c:	843ff844 	addi	r16,r16,-31
81130780:	01000804 	movi	r4,32
81130784:	1406d83a 	srl	r3,r2,r16
81130788:	41005026 	beq	r8,r4,811308cc <__adddf3+0x564>
8113078c:	01001004 	movi	r4,64
81130790:	2211c83a 	sub	r8,r4,r8
81130794:	1204983a 	sll	r2,r2,r8
81130798:	88a2b03a 	or	r17,r17,r2
8113079c:	8822c03a 	cmpne	r17,r17,zero
811307a0:	1c62b03a 	or	r17,r3,r17
811307a4:	0011883a 	mov	r8,zero
811307a8:	0021883a 	mov	r16,zero
811307ac:	003f7106 	br	81130574 <__reset+0xfb110574>
811307b0:	193ff804 	addi	r4,r3,-32
811307b4:	00800804 	movi	r2,32
811307b8:	4908d83a 	srl	r4,r9,r4
811307bc:	18804526 	beq	r3,r2,811308d4 <__adddf3+0x56c>
811307c0:	00801004 	movi	r2,64
811307c4:	10c5c83a 	sub	r2,r2,r3
811307c8:	4886983a 	sll	r3,r9,r2
811307cc:	198cb03a 	or	r6,r3,r6
811307d0:	300cc03a 	cmpne	r6,r6,zero
811307d4:	218cb03a 	or	r6,r4,r6
811307d8:	0007883a 	mov	r3,zero
811307dc:	003f3b06 	br	811304cc <__reset+0xfb1104cc>
811307e0:	80002a26 	beq	r16,zero,8113088c <__adddf3+0x524>
811307e4:	0101ffc4 	movi	r4,2047
811307e8:	11006826 	beq	r2,r4,8113098c <__adddf3+0x624>
811307ec:	00c7c83a 	sub	r3,zero,r3
811307f0:	42002034 	orhi	r8,r8,128
811307f4:	01000e04 	movi	r4,56
811307f8:	20c07c16 	blt	r4,r3,811309ec <__adddf3+0x684>
811307fc:	010007c4 	movi	r4,31
81130800:	20c0da16 	blt	r4,r3,81130b6c <__adddf3+0x804>
81130804:	01000804 	movi	r4,32
81130808:	20c9c83a 	sub	r4,r4,r3
8113080c:	4114983a 	sll	r10,r8,r4
81130810:	88cad83a 	srl	r5,r17,r3
81130814:	8908983a 	sll	r4,r17,r4
81130818:	40c6d83a 	srl	r3,r8,r3
8113081c:	5162b03a 	or	r17,r10,r5
81130820:	2008c03a 	cmpne	r4,r4,zero
81130824:	8922b03a 	or	r17,r17,r4
81130828:	3463c83a 	sub	r17,r6,r17
8113082c:	48c7c83a 	sub	r3,r9,r3
81130830:	344d803a 	cmpltu	r6,r6,r17
81130834:	1991c83a 	sub	r8,r3,r6
81130838:	1021883a 	mov	r16,r2
8113083c:	3825883a 	mov	r18,r7
81130840:	003f2706 	br	811304e0 <__reset+0xfb1104e0>
81130844:	24d0b03a 	or	r8,r4,r19
81130848:	40001b1e 	bne	r8,zero,811308b8 <__adddf3+0x550>
8113084c:	0005883a 	mov	r2,zero
81130850:	0007883a 	mov	r3,zero
81130854:	0021883a 	mov	r16,zero
81130858:	003f4d06 	br	81130590 <__reset+0xfb110590>
8113085c:	008007c4 	movi	r2,31
81130860:	11003c16 	blt	r2,r4,81130954 <__adddf3+0x5ec>
81130864:	00800804 	movi	r2,32
81130868:	1105c83a 	sub	r2,r2,r4
8113086c:	488e983a 	sll	r7,r9,r2
81130870:	310ad83a 	srl	r5,r6,r4
81130874:	3084983a 	sll	r2,r6,r2
81130878:	4912d83a 	srl	r9,r9,r4
8113087c:	394ab03a 	or	r5,r7,r5
81130880:	1004c03a 	cmpne	r2,r2,zero
81130884:	288ab03a 	or	r5,r5,r2
81130888:	003f5306 	br	811305d8 <__reset+0xfb1105d8>
8113088c:	4448b03a 	or	r4,r8,r17
81130890:	20003e26 	beq	r4,zero,8113098c <__adddf3+0x624>
81130894:	00c6303a 	nor	r3,zero,r3
81130898:	18003a1e 	bne	r3,zero,81130984 <__adddf3+0x61c>
8113089c:	3463c83a 	sub	r17,r6,r17
811308a0:	4a07c83a 	sub	r3,r9,r8
811308a4:	344d803a 	cmpltu	r6,r6,r17
811308a8:	1991c83a 	sub	r8,r3,r6
811308ac:	1021883a 	mov	r16,r2
811308b0:	3825883a 	mov	r18,r7
811308b4:	003f0a06 	br	811304e0 <__reset+0xfb1104e0>
811308b8:	2023883a 	mov	r17,r4
811308bc:	003f0d06 	br	811304f4 <__reset+0xfb1104f4>
811308c0:	0081ffc4 	movi	r2,2047
811308c4:	80bf3f1e 	bne	r16,r2,811305c4 <__reset+0xfb1105c4>
811308c8:	003ec806 	br	811303ec <__reset+0xfb1103ec>
811308cc:	0005883a 	mov	r2,zero
811308d0:	003fb106 	br	81130798 <__reset+0xfb110798>
811308d4:	0007883a 	mov	r3,zero
811308d8:	003fbc06 	br	811307cc <__reset+0xfb1107cc>
811308dc:	4444b03a 	or	r2,r8,r17
811308e0:	8000871e 	bne	r16,zero,81130b00 <__adddf3+0x798>
811308e4:	1000ba26 	beq	r2,zero,81130bd0 <__adddf3+0x868>
811308e8:	4984b03a 	or	r2,r9,r6
811308ec:	103ebf26 	beq	r2,zero,811303ec <__reset+0xfb1103ec>
811308f0:	8985883a 	add	r2,r17,r6
811308f4:	4247883a 	add	r3,r8,r9
811308f8:	1451803a 	cmpltu	r8,r2,r17
811308fc:	40d1883a 	add	r8,r8,r3
81130900:	40c0202c 	andhi	r3,r8,128
81130904:	1023883a 	mov	r17,r2
81130908:	183f1a26 	beq	r3,zero,81130574 <__reset+0xfb110574>
8113090c:	00bfe034 	movhi	r2,65408
81130910:	10bfffc4 	addi	r2,r2,-1
81130914:	2021883a 	mov	r16,r4
81130918:	4090703a 	and	r8,r8,r2
8113091c:	003eb306 	br	811303ec <__reset+0xfb1103ec>
81130920:	4444b03a 	or	r2,r8,r17
81130924:	8000291e 	bne	r16,zero,811309cc <__adddf3+0x664>
81130928:	10004b1e 	bne	r2,zero,81130a58 <__adddf3+0x6f0>
8113092c:	4990b03a 	or	r8,r9,r6
81130930:	40008b26 	beq	r8,zero,81130b60 <__adddf3+0x7f8>
81130934:	4811883a 	mov	r8,r9
81130938:	3023883a 	mov	r17,r6
8113093c:	3825883a 	mov	r18,r7
81130940:	003eaa06 	br	811303ec <__reset+0xfb1103ec>
81130944:	1021883a 	mov	r16,r2
81130948:	0011883a 	mov	r8,zero
8113094c:	0005883a 	mov	r2,zero
81130950:	003f0f06 	br	81130590 <__reset+0xfb110590>
81130954:	217ff804 	addi	r5,r4,-32
81130958:	00800804 	movi	r2,32
8113095c:	494ad83a 	srl	r5,r9,r5
81130960:	20807d26 	beq	r4,r2,81130b58 <__adddf3+0x7f0>
81130964:	00801004 	movi	r2,64
81130968:	1109c83a 	sub	r4,r2,r4
8113096c:	4912983a 	sll	r9,r9,r4
81130970:	498cb03a 	or	r6,r9,r6
81130974:	300cc03a 	cmpne	r6,r6,zero
81130978:	298ab03a 	or	r5,r5,r6
8113097c:	0013883a 	mov	r9,zero
81130980:	003f1506 	br	811305d8 <__reset+0xfb1105d8>
81130984:	0101ffc4 	movi	r4,2047
81130988:	113f9a1e 	bne	r2,r4,811307f4 <__reset+0xfb1107f4>
8113098c:	4811883a 	mov	r8,r9
81130990:	3023883a 	mov	r17,r6
81130994:	1021883a 	mov	r16,r2
81130998:	3825883a 	mov	r18,r7
8113099c:	003e9306 	br	811303ec <__reset+0xfb1103ec>
811309a0:	8000161e 	bne	r16,zero,811309fc <__adddf3+0x694>
811309a4:	444ab03a 	or	r5,r8,r17
811309a8:	28005126 	beq	r5,zero,81130af0 <__adddf3+0x788>
811309ac:	0108303a 	nor	r4,zero,r4
811309b0:	20004d1e 	bne	r4,zero,81130ae8 <__adddf3+0x780>
811309b4:	89a3883a 	add	r17,r17,r6
811309b8:	4253883a 	add	r9,r8,r9
811309bc:	898d803a 	cmpltu	r6,r17,r6
811309c0:	3251883a 	add	r8,r6,r9
811309c4:	1021883a 	mov	r16,r2
811309c8:	003f0806 	br	811305ec <__reset+0xfb1105ec>
811309cc:	1000301e 	bne	r2,zero,81130a90 <__adddf3+0x728>
811309d0:	4984b03a 	or	r2,r9,r6
811309d4:	10007126 	beq	r2,zero,81130b9c <__adddf3+0x834>
811309d8:	4811883a 	mov	r8,r9
811309dc:	3023883a 	mov	r17,r6
811309e0:	3825883a 	mov	r18,r7
811309e4:	0401ffc4 	movi	r16,2047
811309e8:	003e8006 	br	811303ec <__reset+0xfb1103ec>
811309ec:	4462b03a 	or	r17,r8,r17
811309f0:	8822c03a 	cmpne	r17,r17,zero
811309f4:	0007883a 	mov	r3,zero
811309f8:	003f8b06 	br	81130828 <__reset+0xfb110828>
811309fc:	0141ffc4 	movi	r5,2047
81130a00:	11403b26 	beq	r2,r5,81130af0 <__adddf3+0x788>
81130a04:	0109c83a 	sub	r4,zero,r4
81130a08:	42002034 	orhi	r8,r8,128
81130a0c:	01400e04 	movi	r5,56
81130a10:	29006716 	blt	r5,r4,81130bb0 <__adddf3+0x848>
81130a14:	014007c4 	movi	r5,31
81130a18:	29007016 	blt	r5,r4,81130bdc <__adddf3+0x874>
81130a1c:	01400804 	movi	r5,32
81130a20:	290bc83a 	sub	r5,r5,r4
81130a24:	4154983a 	sll	r10,r8,r5
81130a28:	890ed83a 	srl	r7,r17,r4
81130a2c:	894a983a 	sll	r5,r17,r5
81130a30:	4108d83a 	srl	r4,r8,r4
81130a34:	51e2b03a 	or	r17,r10,r7
81130a38:	280ac03a 	cmpne	r5,r5,zero
81130a3c:	8962b03a 	or	r17,r17,r5
81130a40:	89a3883a 	add	r17,r17,r6
81130a44:	2253883a 	add	r9,r4,r9
81130a48:	898d803a 	cmpltu	r6,r17,r6
81130a4c:	3251883a 	add	r8,r6,r9
81130a50:	1021883a 	mov	r16,r2
81130a54:	003ee506 	br	811305ec <__reset+0xfb1105ec>
81130a58:	4984b03a 	or	r2,r9,r6
81130a5c:	103e6326 	beq	r2,zero,811303ec <__reset+0xfb1103ec>
81130a60:	8987c83a 	sub	r3,r17,r6
81130a64:	88c9803a 	cmpltu	r4,r17,r3
81130a68:	4245c83a 	sub	r2,r8,r9
81130a6c:	1105c83a 	sub	r2,r2,r4
81130a70:	1100202c 	andhi	r4,r2,128
81130a74:	203ebb26 	beq	r4,zero,81130564 <__reset+0xfb110564>
81130a78:	3463c83a 	sub	r17,r6,r17
81130a7c:	4a07c83a 	sub	r3,r9,r8
81130a80:	344d803a 	cmpltu	r6,r6,r17
81130a84:	1991c83a 	sub	r8,r3,r6
81130a88:	3825883a 	mov	r18,r7
81130a8c:	003e5706 	br	811303ec <__reset+0xfb1103ec>
81130a90:	4984b03a 	or	r2,r9,r6
81130a94:	10002e26 	beq	r2,zero,81130b50 <__adddf3+0x7e8>
81130a98:	4004d0fa 	srli	r2,r8,3
81130a9c:	8822d0fa 	srli	r17,r17,3
81130aa0:	4010977a 	slli	r8,r8,29
81130aa4:	10c0022c 	andhi	r3,r2,8
81130aa8:	4462b03a 	or	r17,r8,r17
81130aac:	18000826 	beq	r3,zero,81130ad0 <__adddf3+0x768>
81130ab0:	4808d0fa 	srli	r4,r9,3
81130ab4:	20c0022c 	andhi	r3,r4,8
81130ab8:	1800051e 	bne	r3,zero,81130ad0 <__adddf3+0x768>
81130abc:	300cd0fa 	srli	r6,r6,3
81130ac0:	4806977a 	slli	r3,r9,29
81130ac4:	2005883a 	mov	r2,r4
81130ac8:	3825883a 	mov	r18,r7
81130acc:	19a2b03a 	or	r17,r3,r6
81130ad0:	8810d77a 	srli	r8,r17,29
81130ad4:	100490fa 	slli	r2,r2,3
81130ad8:	882290fa 	slli	r17,r17,3
81130adc:	0401ffc4 	movi	r16,2047
81130ae0:	4090b03a 	or	r8,r8,r2
81130ae4:	003e4106 	br	811303ec <__reset+0xfb1103ec>
81130ae8:	0141ffc4 	movi	r5,2047
81130aec:	117fc71e 	bne	r2,r5,81130a0c <__reset+0xfb110a0c>
81130af0:	4811883a 	mov	r8,r9
81130af4:	3023883a 	mov	r17,r6
81130af8:	1021883a 	mov	r16,r2
81130afc:	003e3b06 	br	811303ec <__reset+0xfb1103ec>
81130b00:	10002f26 	beq	r2,zero,81130bc0 <__adddf3+0x858>
81130b04:	4984b03a 	or	r2,r9,r6
81130b08:	10001126 	beq	r2,zero,81130b50 <__adddf3+0x7e8>
81130b0c:	4004d0fa 	srli	r2,r8,3
81130b10:	8822d0fa 	srli	r17,r17,3
81130b14:	4010977a 	slli	r8,r8,29
81130b18:	10c0022c 	andhi	r3,r2,8
81130b1c:	4462b03a 	or	r17,r8,r17
81130b20:	183feb26 	beq	r3,zero,81130ad0 <__reset+0xfb110ad0>
81130b24:	4808d0fa 	srli	r4,r9,3
81130b28:	20c0022c 	andhi	r3,r4,8
81130b2c:	183fe81e 	bne	r3,zero,81130ad0 <__reset+0xfb110ad0>
81130b30:	300cd0fa 	srli	r6,r6,3
81130b34:	4806977a 	slli	r3,r9,29
81130b38:	2005883a 	mov	r2,r4
81130b3c:	19a2b03a 	or	r17,r3,r6
81130b40:	003fe306 	br	81130ad0 <__reset+0xfb110ad0>
81130b44:	0011883a 	mov	r8,zero
81130b48:	0005883a 	mov	r2,zero
81130b4c:	003e3f06 	br	8113044c <__reset+0xfb11044c>
81130b50:	0401ffc4 	movi	r16,2047
81130b54:	003e2506 	br	811303ec <__reset+0xfb1103ec>
81130b58:	0013883a 	mov	r9,zero
81130b5c:	003f8406 	br	81130970 <__reset+0xfb110970>
81130b60:	0005883a 	mov	r2,zero
81130b64:	0007883a 	mov	r3,zero
81130b68:	003e8906 	br	81130590 <__reset+0xfb110590>
81130b6c:	197ff804 	addi	r5,r3,-32
81130b70:	01000804 	movi	r4,32
81130b74:	414ad83a 	srl	r5,r8,r5
81130b78:	19002426 	beq	r3,r4,81130c0c <__adddf3+0x8a4>
81130b7c:	01001004 	movi	r4,64
81130b80:	20c7c83a 	sub	r3,r4,r3
81130b84:	40c6983a 	sll	r3,r8,r3
81130b88:	1c46b03a 	or	r3,r3,r17
81130b8c:	1806c03a 	cmpne	r3,r3,zero
81130b90:	28e2b03a 	or	r17,r5,r3
81130b94:	0007883a 	mov	r3,zero
81130b98:	003f2306 	br	81130828 <__reset+0xfb110828>
81130b9c:	0007883a 	mov	r3,zero
81130ba0:	5811883a 	mov	r8,r11
81130ba4:	00bfffc4 	movi	r2,-1
81130ba8:	0401ffc4 	movi	r16,2047
81130bac:	003e7806 	br	81130590 <__reset+0xfb110590>
81130bb0:	4462b03a 	or	r17,r8,r17
81130bb4:	8822c03a 	cmpne	r17,r17,zero
81130bb8:	0009883a 	mov	r4,zero
81130bbc:	003fa006 	br	81130a40 <__reset+0xfb110a40>
81130bc0:	4811883a 	mov	r8,r9
81130bc4:	3023883a 	mov	r17,r6
81130bc8:	0401ffc4 	movi	r16,2047
81130bcc:	003e0706 	br	811303ec <__reset+0xfb1103ec>
81130bd0:	4811883a 	mov	r8,r9
81130bd4:	3023883a 	mov	r17,r6
81130bd8:	003e0406 	br	811303ec <__reset+0xfb1103ec>
81130bdc:	21fff804 	addi	r7,r4,-32
81130be0:	01400804 	movi	r5,32
81130be4:	41ced83a 	srl	r7,r8,r7
81130be8:	21400a26 	beq	r4,r5,81130c14 <__adddf3+0x8ac>
81130bec:	01401004 	movi	r5,64
81130bf0:	2909c83a 	sub	r4,r5,r4
81130bf4:	4108983a 	sll	r4,r8,r4
81130bf8:	2448b03a 	or	r4,r4,r17
81130bfc:	2008c03a 	cmpne	r4,r4,zero
81130c00:	3922b03a 	or	r17,r7,r4
81130c04:	0009883a 	mov	r4,zero
81130c08:	003f8d06 	br	81130a40 <__reset+0xfb110a40>
81130c0c:	0007883a 	mov	r3,zero
81130c10:	003fdd06 	br	81130b88 <__reset+0xfb110b88>
81130c14:	0009883a 	mov	r4,zero
81130c18:	003ff706 	br	81130bf8 <__reset+0xfb110bf8>

81130c1c <__divdf3>:
81130c1c:	defff204 	addi	sp,sp,-56
81130c20:	de00012e 	bgeu	sp,et,81130c28 <__divdf3+0xc>
81130c24:	003b68fa 	trap	3
81130c28:	dd400915 	stw	r21,36(sp)
81130c2c:	282ad53a 	srli	r21,r5,20
81130c30:	dd000815 	stw	r20,32(sp)
81130c34:	2828d7fa 	srli	r20,r5,31
81130c38:	dc000415 	stw	r16,16(sp)
81130c3c:	04000434 	movhi	r16,16
81130c40:	df000c15 	stw	fp,48(sp)
81130c44:	843fffc4 	addi	r16,r16,-1
81130c48:	dfc00d15 	stw	ra,52(sp)
81130c4c:	ddc00b15 	stw	r23,44(sp)
81130c50:	dd800a15 	stw	r22,40(sp)
81130c54:	dcc00715 	stw	r19,28(sp)
81130c58:	dc800615 	stw	r18,24(sp)
81130c5c:	dc400515 	stw	r17,20(sp)
81130c60:	ad41ffcc 	andi	r21,r21,2047
81130c64:	2c20703a 	and	r16,r5,r16
81130c68:	a7003fcc 	andi	fp,r20,255
81130c6c:	a8006126 	beq	r21,zero,81130df4 <__divdf3+0x1d8>
81130c70:	0081ffc4 	movi	r2,2047
81130c74:	2025883a 	mov	r18,r4
81130c78:	a8803726 	beq	r21,r2,81130d58 <__divdf3+0x13c>
81130c7c:	80800434 	orhi	r2,r16,16
81130c80:	100490fa 	slli	r2,r2,3
81130c84:	2020d77a 	srli	r16,r4,29
81130c88:	202490fa 	slli	r18,r4,3
81130c8c:	ad7f0044 	addi	r21,r21,-1023
81130c90:	80a0b03a 	or	r16,r16,r2
81130c94:	0027883a 	mov	r19,zero
81130c98:	0013883a 	mov	r9,zero
81130c9c:	3804d53a 	srli	r2,r7,20
81130ca0:	382cd7fa 	srli	r22,r7,31
81130ca4:	04400434 	movhi	r17,16
81130ca8:	8c7fffc4 	addi	r17,r17,-1
81130cac:	1081ffcc 	andi	r2,r2,2047
81130cb0:	3011883a 	mov	r8,r6
81130cb4:	3c62703a 	and	r17,r7,r17
81130cb8:	b5c03fcc 	andi	r23,r22,255
81130cbc:	10006c26 	beq	r2,zero,81130e70 <__divdf3+0x254>
81130cc0:	00c1ffc4 	movi	r3,2047
81130cc4:	10c06426 	beq	r2,r3,81130e58 <__divdf3+0x23c>
81130cc8:	88c00434 	orhi	r3,r17,16
81130ccc:	180690fa 	slli	r3,r3,3
81130cd0:	3022d77a 	srli	r17,r6,29
81130cd4:	301090fa 	slli	r8,r6,3
81130cd8:	10bf0044 	addi	r2,r2,-1023
81130cdc:	88e2b03a 	or	r17,r17,r3
81130ce0:	000f883a 	mov	r7,zero
81130ce4:	a58cf03a 	xor	r6,r20,r22
81130ce8:	3cc8b03a 	or	r4,r7,r19
81130cec:	a8abc83a 	sub	r21,r21,r2
81130cf0:	008003c4 	movi	r2,15
81130cf4:	3007883a 	mov	r3,r6
81130cf8:	34c03fcc 	andi	r19,r6,255
81130cfc:	11009036 	bltu	r2,r4,81130f40 <__divdf3+0x324>
81130d00:	200890ba 	slli	r4,r4,2
81130d04:	00a044f4 	movhi	r2,33043
81130d08:	10834604 	addi	r2,r2,3352
81130d0c:	2089883a 	add	r4,r4,r2
81130d10:	20800017 	ldw	r2,0(r4)
81130d14:	1000683a 	jmp	r2
81130d18:	81130f40 	call	881130f4 <__reset+0x20f30f4>
81130d1c:	81130d90 	cmplti	r4,r16,19510
81130d20:	81130f30 	cmpltui	r4,r16,19516
81130d24:	81130d84 	addi	r4,r16,19510
81130d28:	81130f30 	cmpltui	r4,r16,19516
81130d2c:	81130f04 	addi	r4,r16,19516
81130d30:	81130f30 	cmpltui	r4,r16,19516
81130d34:	81130d84 	addi	r4,r16,19510
81130d38:	81130d90 	cmplti	r4,r16,19510
81130d3c:	81130d90 	cmplti	r4,r16,19510
81130d40:	81130f04 	addi	r4,r16,19516
81130d44:	81130d84 	addi	r4,r16,19510
81130d48:	81130d74 	orhi	r4,r16,19509
81130d4c:	81130d74 	orhi	r4,r16,19509
81130d50:	81130d74 	orhi	r4,r16,19509
81130d54:	81131224 	muli	r4,r16,19528
81130d58:	2404b03a 	or	r2,r4,r16
81130d5c:	1000661e 	bne	r2,zero,81130ef8 <__divdf3+0x2dc>
81130d60:	04c00204 	movi	r19,8
81130d64:	0021883a 	mov	r16,zero
81130d68:	0025883a 	mov	r18,zero
81130d6c:	02400084 	movi	r9,2
81130d70:	003fca06 	br	81130c9c <__reset+0xfb110c9c>
81130d74:	8023883a 	mov	r17,r16
81130d78:	9011883a 	mov	r8,r18
81130d7c:	e02f883a 	mov	r23,fp
81130d80:	480f883a 	mov	r7,r9
81130d84:	00800084 	movi	r2,2
81130d88:	3881311e 	bne	r7,r2,81131250 <__divdf3+0x634>
81130d8c:	b827883a 	mov	r19,r23
81130d90:	98c0004c 	andi	r3,r19,1
81130d94:	0081ffc4 	movi	r2,2047
81130d98:	000b883a 	mov	r5,zero
81130d9c:	0025883a 	mov	r18,zero
81130da0:	1004953a 	slli	r2,r2,20
81130da4:	18c03fcc 	andi	r3,r3,255
81130da8:	04400434 	movhi	r17,16
81130dac:	8c7fffc4 	addi	r17,r17,-1
81130db0:	180697fa 	slli	r3,r3,31
81130db4:	2c4a703a 	and	r5,r5,r17
81130db8:	288ab03a 	or	r5,r5,r2
81130dbc:	28c6b03a 	or	r3,r5,r3
81130dc0:	9005883a 	mov	r2,r18
81130dc4:	dfc00d17 	ldw	ra,52(sp)
81130dc8:	df000c17 	ldw	fp,48(sp)
81130dcc:	ddc00b17 	ldw	r23,44(sp)
81130dd0:	dd800a17 	ldw	r22,40(sp)
81130dd4:	dd400917 	ldw	r21,36(sp)
81130dd8:	dd000817 	ldw	r20,32(sp)
81130ddc:	dcc00717 	ldw	r19,28(sp)
81130de0:	dc800617 	ldw	r18,24(sp)
81130de4:	dc400517 	ldw	r17,20(sp)
81130de8:	dc000417 	ldw	r16,16(sp)
81130dec:	dec00e04 	addi	sp,sp,56
81130df0:	f800283a 	ret
81130df4:	2404b03a 	or	r2,r4,r16
81130df8:	2027883a 	mov	r19,r4
81130dfc:	10003926 	beq	r2,zero,81130ee4 <__divdf3+0x2c8>
81130e00:	80012e26 	beq	r16,zero,811312bc <__divdf3+0x6a0>
81130e04:	8009883a 	mov	r4,r16
81130e08:	d9800315 	stw	r6,12(sp)
81130e0c:	d9c00215 	stw	r7,8(sp)
81130e10:	111c8580 	call	8111c858 <__clzsi2>
81130e14:	d9800317 	ldw	r6,12(sp)
81130e18:	d9c00217 	ldw	r7,8(sp)
81130e1c:	113ffd44 	addi	r4,r2,-11
81130e20:	00c00704 	movi	r3,28
81130e24:	19012116 	blt	r3,r4,811312ac <__divdf3+0x690>
81130e28:	00c00744 	movi	r3,29
81130e2c:	147ffe04 	addi	r17,r2,-8
81130e30:	1907c83a 	sub	r3,r3,r4
81130e34:	8460983a 	sll	r16,r16,r17
81130e38:	98c6d83a 	srl	r3,r19,r3
81130e3c:	9c64983a 	sll	r18,r19,r17
81130e40:	1c20b03a 	or	r16,r3,r16
81130e44:	1080fcc4 	addi	r2,r2,1011
81130e48:	00abc83a 	sub	r21,zero,r2
81130e4c:	0027883a 	mov	r19,zero
81130e50:	0013883a 	mov	r9,zero
81130e54:	003f9106 	br	81130c9c <__reset+0xfb110c9c>
81130e58:	3446b03a 	or	r3,r6,r17
81130e5c:	18001f1e 	bne	r3,zero,81130edc <__divdf3+0x2c0>
81130e60:	0023883a 	mov	r17,zero
81130e64:	0011883a 	mov	r8,zero
81130e68:	01c00084 	movi	r7,2
81130e6c:	003f9d06 	br	81130ce4 <__reset+0xfb110ce4>
81130e70:	3446b03a 	or	r3,r6,r17
81130e74:	18001526 	beq	r3,zero,81130ecc <__divdf3+0x2b0>
81130e78:	88011b26 	beq	r17,zero,811312e8 <__divdf3+0x6cc>
81130e7c:	8809883a 	mov	r4,r17
81130e80:	d9800315 	stw	r6,12(sp)
81130e84:	da400115 	stw	r9,4(sp)
81130e88:	111c8580 	call	8111c858 <__clzsi2>
81130e8c:	d9800317 	ldw	r6,12(sp)
81130e90:	da400117 	ldw	r9,4(sp)
81130e94:	113ffd44 	addi	r4,r2,-11
81130e98:	00c00704 	movi	r3,28
81130e9c:	19010e16 	blt	r3,r4,811312d8 <__divdf3+0x6bc>
81130ea0:	00c00744 	movi	r3,29
81130ea4:	123ffe04 	addi	r8,r2,-8
81130ea8:	1907c83a 	sub	r3,r3,r4
81130eac:	8a22983a 	sll	r17,r17,r8
81130eb0:	30c6d83a 	srl	r3,r6,r3
81130eb4:	3210983a 	sll	r8,r6,r8
81130eb8:	1c62b03a 	or	r17,r3,r17
81130ebc:	1080fcc4 	addi	r2,r2,1011
81130ec0:	0085c83a 	sub	r2,zero,r2
81130ec4:	000f883a 	mov	r7,zero
81130ec8:	003f8606 	br	81130ce4 <__reset+0xfb110ce4>
81130ecc:	0023883a 	mov	r17,zero
81130ed0:	0011883a 	mov	r8,zero
81130ed4:	01c00044 	movi	r7,1
81130ed8:	003f8206 	br	81130ce4 <__reset+0xfb110ce4>
81130edc:	01c000c4 	movi	r7,3
81130ee0:	003f8006 	br	81130ce4 <__reset+0xfb110ce4>
81130ee4:	04c00104 	movi	r19,4
81130ee8:	0021883a 	mov	r16,zero
81130eec:	0025883a 	mov	r18,zero
81130ef0:	02400044 	movi	r9,1
81130ef4:	003f6906 	br	81130c9c <__reset+0xfb110c9c>
81130ef8:	04c00304 	movi	r19,12
81130efc:	024000c4 	movi	r9,3
81130f00:	003f6606 	br	81130c9c <__reset+0xfb110c9c>
81130f04:	01400434 	movhi	r5,16
81130f08:	0007883a 	mov	r3,zero
81130f0c:	297fffc4 	addi	r5,r5,-1
81130f10:	04bfffc4 	movi	r18,-1
81130f14:	0081ffc4 	movi	r2,2047
81130f18:	003fa106 	br	81130da0 <__reset+0xfb110da0>
81130f1c:	00c00044 	movi	r3,1
81130f20:	1887c83a 	sub	r3,r3,r2
81130f24:	01000e04 	movi	r4,56
81130f28:	20c1210e 	bge	r4,r3,811313b0 <__divdf3+0x794>
81130f2c:	98c0004c 	andi	r3,r19,1
81130f30:	0005883a 	mov	r2,zero
81130f34:	000b883a 	mov	r5,zero
81130f38:	0025883a 	mov	r18,zero
81130f3c:	003f9806 	br	81130da0 <__reset+0xfb110da0>
81130f40:	8c00fd36 	bltu	r17,r16,81131338 <__divdf3+0x71c>
81130f44:	8440fb26 	beq	r16,r17,81131334 <__divdf3+0x718>
81130f48:	8007883a 	mov	r3,r16
81130f4c:	ad7fffc4 	addi	r21,r21,-1
81130f50:	0021883a 	mov	r16,zero
81130f54:	4004d63a 	srli	r2,r8,24
81130f58:	8822923a 	slli	r17,r17,8
81130f5c:	1809883a 	mov	r4,r3
81130f60:	402c923a 	slli	r22,r8,8
81130f64:	88b8b03a 	or	fp,r17,r2
81130f68:	e028d43a 	srli	r20,fp,16
81130f6c:	d8c00015 	stw	r3,0(sp)
81130f70:	e5ffffcc 	andi	r23,fp,65535
81130f74:	a00b883a 	mov	r5,r20
81130f78:	11300b00 	call	811300b0 <__udivsi3>
81130f7c:	d8c00017 	ldw	r3,0(sp)
81130f80:	a00b883a 	mov	r5,r20
81130f84:	d8800315 	stw	r2,12(sp)
81130f88:	1809883a 	mov	r4,r3
81130f8c:	11301140 	call	81130114 <__umodsi3>
81130f90:	d9800317 	ldw	r6,12(sp)
81130f94:	1006943a 	slli	r3,r2,16
81130f98:	9004d43a 	srli	r2,r18,16
81130f9c:	b9a3383a 	mul	r17,r23,r6
81130fa0:	10c4b03a 	or	r2,r2,r3
81130fa4:	1440062e 	bgeu	r2,r17,81130fc0 <__divdf3+0x3a4>
81130fa8:	1705883a 	add	r2,r2,fp
81130fac:	30ffffc4 	addi	r3,r6,-1
81130fb0:	1700ee36 	bltu	r2,fp,8113136c <__divdf3+0x750>
81130fb4:	1440ed2e 	bgeu	r2,r17,8113136c <__divdf3+0x750>
81130fb8:	31bfff84 	addi	r6,r6,-2
81130fbc:	1705883a 	add	r2,r2,fp
81130fc0:	1463c83a 	sub	r17,r2,r17
81130fc4:	a00b883a 	mov	r5,r20
81130fc8:	8809883a 	mov	r4,r17
81130fcc:	d9800315 	stw	r6,12(sp)
81130fd0:	11300b00 	call	811300b0 <__udivsi3>
81130fd4:	a00b883a 	mov	r5,r20
81130fd8:	8809883a 	mov	r4,r17
81130fdc:	d8800215 	stw	r2,8(sp)
81130fe0:	11301140 	call	81130114 <__umodsi3>
81130fe4:	d9c00217 	ldw	r7,8(sp)
81130fe8:	1004943a 	slli	r2,r2,16
81130fec:	94bfffcc 	andi	r18,r18,65535
81130ff0:	b9d1383a 	mul	r8,r23,r7
81130ff4:	90a4b03a 	or	r18,r18,r2
81130ff8:	d9800317 	ldw	r6,12(sp)
81130ffc:	9200062e 	bgeu	r18,r8,81131018 <__divdf3+0x3fc>
81131000:	9725883a 	add	r18,r18,fp
81131004:	38bfffc4 	addi	r2,r7,-1
81131008:	9700d636 	bltu	r18,fp,81131364 <__divdf3+0x748>
8113100c:	9200d52e 	bgeu	r18,r8,81131364 <__divdf3+0x748>
81131010:	39ffff84 	addi	r7,r7,-2
81131014:	9725883a 	add	r18,r18,fp
81131018:	3004943a 	slli	r2,r6,16
8113101c:	b012d43a 	srli	r9,r22,16
81131020:	b1bfffcc 	andi	r6,r22,65535
81131024:	11e2b03a 	or	r17,r2,r7
81131028:	8806d43a 	srli	r3,r17,16
8113102c:	893fffcc 	andi	r4,r17,65535
81131030:	218b383a 	mul	r5,r4,r6
81131034:	30c5383a 	mul	r2,r6,r3
81131038:	2249383a 	mul	r4,r4,r9
8113103c:	280ed43a 	srli	r7,r5,16
81131040:	9225c83a 	sub	r18,r18,r8
81131044:	2089883a 	add	r4,r4,r2
81131048:	3909883a 	add	r4,r7,r4
8113104c:	1a47383a 	mul	r3,r3,r9
81131050:	2080022e 	bgeu	r4,r2,8113105c <__divdf3+0x440>
81131054:	00800074 	movhi	r2,1
81131058:	1887883a 	add	r3,r3,r2
8113105c:	2004d43a 	srli	r2,r4,16
81131060:	2008943a 	slli	r4,r4,16
81131064:	297fffcc 	andi	r5,r5,65535
81131068:	10c7883a 	add	r3,r2,r3
8113106c:	2149883a 	add	r4,r4,r5
81131070:	90c0a536 	bltu	r18,r3,81131308 <__divdf3+0x6ec>
81131074:	90c0bf26 	beq	r18,r3,81131374 <__divdf3+0x758>
81131078:	90c7c83a 	sub	r3,r18,r3
8113107c:	810fc83a 	sub	r7,r16,r4
81131080:	81e5803a 	cmpltu	r18,r16,r7
81131084:	1ca5c83a 	sub	r18,r3,r18
81131088:	e480c126 	beq	fp,r18,81131390 <__divdf3+0x774>
8113108c:	a00b883a 	mov	r5,r20
81131090:	9009883a 	mov	r4,r18
81131094:	d9800315 	stw	r6,12(sp)
81131098:	d9c00215 	stw	r7,8(sp)
8113109c:	da400115 	stw	r9,4(sp)
811310a0:	11300b00 	call	811300b0 <__udivsi3>
811310a4:	a00b883a 	mov	r5,r20
811310a8:	9009883a 	mov	r4,r18
811310ac:	d8800015 	stw	r2,0(sp)
811310b0:	11301140 	call	81130114 <__umodsi3>
811310b4:	d9c00217 	ldw	r7,8(sp)
811310b8:	da000017 	ldw	r8,0(sp)
811310bc:	1006943a 	slli	r3,r2,16
811310c0:	3804d43a 	srli	r2,r7,16
811310c4:	ba21383a 	mul	r16,r23,r8
811310c8:	d9800317 	ldw	r6,12(sp)
811310cc:	10c4b03a 	or	r2,r2,r3
811310d0:	da400117 	ldw	r9,4(sp)
811310d4:	1400062e 	bgeu	r2,r16,811310f0 <__divdf3+0x4d4>
811310d8:	1705883a 	add	r2,r2,fp
811310dc:	40ffffc4 	addi	r3,r8,-1
811310e0:	1700ad36 	bltu	r2,fp,81131398 <__divdf3+0x77c>
811310e4:	1400ac2e 	bgeu	r2,r16,81131398 <__divdf3+0x77c>
811310e8:	423fff84 	addi	r8,r8,-2
811310ec:	1705883a 	add	r2,r2,fp
811310f0:	1421c83a 	sub	r16,r2,r16
811310f4:	a00b883a 	mov	r5,r20
811310f8:	8009883a 	mov	r4,r16
811310fc:	d9800315 	stw	r6,12(sp)
81131100:	d9c00215 	stw	r7,8(sp)
81131104:	da000015 	stw	r8,0(sp)
81131108:	da400115 	stw	r9,4(sp)
8113110c:	11300b00 	call	811300b0 <__udivsi3>
81131110:	8009883a 	mov	r4,r16
81131114:	a00b883a 	mov	r5,r20
81131118:	1025883a 	mov	r18,r2
8113111c:	11301140 	call	81130114 <__umodsi3>
81131120:	d9c00217 	ldw	r7,8(sp)
81131124:	1004943a 	slli	r2,r2,16
81131128:	bcaf383a 	mul	r23,r23,r18
8113112c:	393fffcc 	andi	r4,r7,65535
81131130:	2088b03a 	or	r4,r4,r2
81131134:	d9800317 	ldw	r6,12(sp)
81131138:	da000017 	ldw	r8,0(sp)
8113113c:	da400117 	ldw	r9,4(sp)
81131140:	25c0062e 	bgeu	r4,r23,8113115c <__divdf3+0x540>
81131144:	2709883a 	add	r4,r4,fp
81131148:	90bfffc4 	addi	r2,r18,-1
8113114c:	27009436 	bltu	r4,fp,811313a0 <__divdf3+0x784>
81131150:	25c0932e 	bgeu	r4,r23,811313a0 <__divdf3+0x784>
81131154:	94bfff84 	addi	r18,r18,-2
81131158:	2709883a 	add	r4,r4,fp
8113115c:	4004943a 	slli	r2,r8,16
81131160:	25efc83a 	sub	r23,r4,r23
81131164:	1490b03a 	or	r8,r2,r18
81131168:	4008d43a 	srli	r4,r8,16
8113116c:	40ffffcc 	andi	r3,r8,65535
81131170:	30c5383a 	mul	r2,r6,r3
81131174:	1a47383a 	mul	r3,r3,r9
81131178:	310d383a 	mul	r6,r6,r4
8113117c:	100ad43a 	srli	r5,r2,16
81131180:	4913383a 	mul	r9,r9,r4
81131184:	1987883a 	add	r3,r3,r6
81131188:	28c7883a 	add	r3,r5,r3
8113118c:	1980022e 	bgeu	r3,r6,81131198 <__divdf3+0x57c>
81131190:	01000074 	movhi	r4,1
81131194:	4913883a 	add	r9,r9,r4
81131198:	1808d43a 	srli	r4,r3,16
8113119c:	1806943a 	slli	r3,r3,16
811311a0:	10bfffcc 	andi	r2,r2,65535
811311a4:	2253883a 	add	r9,r4,r9
811311a8:	1887883a 	add	r3,r3,r2
811311ac:	ba403836 	bltu	r23,r9,81131290 <__divdf3+0x674>
811311b0:	ba403626 	beq	r23,r9,8113128c <__divdf3+0x670>
811311b4:	42000054 	ori	r8,r8,1
811311b8:	a880ffc4 	addi	r2,r21,1023
811311bc:	00bf570e 	bge	zero,r2,81130f1c <__reset+0xfb110f1c>
811311c0:	40c001cc 	andi	r3,r8,7
811311c4:	18000726 	beq	r3,zero,811311e4 <__divdf3+0x5c8>
811311c8:	40c003cc 	andi	r3,r8,15
811311cc:	01000104 	movi	r4,4
811311d0:	19000426 	beq	r3,r4,811311e4 <__divdf3+0x5c8>
811311d4:	4107883a 	add	r3,r8,r4
811311d8:	1a11803a 	cmpltu	r8,r3,r8
811311dc:	8a23883a 	add	r17,r17,r8
811311e0:	1811883a 	mov	r8,r3
811311e4:	88c0402c 	andhi	r3,r17,256
811311e8:	18000426 	beq	r3,zero,811311fc <__divdf3+0x5e0>
811311ec:	00ffc034 	movhi	r3,65280
811311f0:	18ffffc4 	addi	r3,r3,-1
811311f4:	a8810004 	addi	r2,r21,1024
811311f8:	88e2703a 	and	r17,r17,r3
811311fc:	00c1ff84 	movi	r3,2046
81131200:	18bee316 	blt	r3,r2,81130d90 <__reset+0xfb110d90>
81131204:	8824977a 	slli	r18,r17,29
81131208:	4010d0fa 	srli	r8,r8,3
8113120c:	8822927a 	slli	r17,r17,9
81131210:	1081ffcc 	andi	r2,r2,2047
81131214:	9224b03a 	or	r18,r18,r8
81131218:	880ad33a 	srli	r5,r17,12
8113121c:	98c0004c 	andi	r3,r19,1
81131220:	003edf06 	br	81130da0 <__reset+0xfb110da0>
81131224:	8080022c 	andhi	r2,r16,8
81131228:	10001226 	beq	r2,zero,81131274 <__divdf3+0x658>
8113122c:	8880022c 	andhi	r2,r17,8
81131230:	1000101e 	bne	r2,zero,81131274 <__divdf3+0x658>
81131234:	00800434 	movhi	r2,16
81131238:	89400234 	orhi	r5,r17,8
8113123c:	10bfffc4 	addi	r2,r2,-1
81131240:	b007883a 	mov	r3,r22
81131244:	288a703a 	and	r5,r5,r2
81131248:	4025883a 	mov	r18,r8
8113124c:	003f3106 	br	81130f14 <__reset+0xfb110f14>
81131250:	008000c4 	movi	r2,3
81131254:	3880a626 	beq	r7,r2,811314f0 <__divdf3+0x8d4>
81131258:	00800044 	movi	r2,1
8113125c:	3880521e 	bne	r7,r2,811313a8 <__divdf3+0x78c>
81131260:	b807883a 	mov	r3,r23
81131264:	0005883a 	mov	r2,zero
81131268:	000b883a 	mov	r5,zero
8113126c:	0025883a 	mov	r18,zero
81131270:	003ecb06 	br	81130da0 <__reset+0xfb110da0>
81131274:	00800434 	movhi	r2,16
81131278:	81400234 	orhi	r5,r16,8
8113127c:	10bfffc4 	addi	r2,r2,-1
81131280:	a007883a 	mov	r3,r20
81131284:	288a703a 	and	r5,r5,r2
81131288:	003f2206 	br	81130f14 <__reset+0xfb110f14>
8113128c:	183fca26 	beq	r3,zero,811311b8 <__reset+0xfb1111b8>
81131290:	e5ef883a 	add	r23,fp,r23
81131294:	40bfffc4 	addi	r2,r8,-1
81131298:	bf00392e 	bgeu	r23,fp,81131380 <__divdf3+0x764>
8113129c:	1011883a 	mov	r8,r2
811312a0:	ba7fc41e 	bne	r23,r9,811311b4 <__reset+0xfb1111b4>
811312a4:	b0ffc31e 	bne	r22,r3,811311b4 <__reset+0xfb1111b4>
811312a8:	003fc306 	br	811311b8 <__reset+0xfb1111b8>
811312ac:	143ff604 	addi	r16,r2,-40
811312b0:	9c20983a 	sll	r16,r19,r16
811312b4:	0025883a 	mov	r18,zero
811312b8:	003ee206 	br	81130e44 <__reset+0xfb110e44>
811312bc:	d9800315 	stw	r6,12(sp)
811312c0:	d9c00215 	stw	r7,8(sp)
811312c4:	111c8580 	call	8111c858 <__clzsi2>
811312c8:	10800804 	addi	r2,r2,32
811312cc:	d9c00217 	ldw	r7,8(sp)
811312d0:	d9800317 	ldw	r6,12(sp)
811312d4:	003ed106 	br	81130e1c <__reset+0xfb110e1c>
811312d8:	147ff604 	addi	r17,r2,-40
811312dc:	3462983a 	sll	r17,r6,r17
811312e0:	0011883a 	mov	r8,zero
811312e4:	003ef506 	br	81130ebc <__reset+0xfb110ebc>
811312e8:	3009883a 	mov	r4,r6
811312ec:	d9800315 	stw	r6,12(sp)
811312f0:	da400115 	stw	r9,4(sp)
811312f4:	111c8580 	call	8111c858 <__clzsi2>
811312f8:	10800804 	addi	r2,r2,32
811312fc:	da400117 	ldw	r9,4(sp)
81131300:	d9800317 	ldw	r6,12(sp)
81131304:	003ee306 	br	81130e94 <__reset+0xfb110e94>
81131308:	85a1883a 	add	r16,r16,r22
8113130c:	8585803a 	cmpltu	r2,r16,r22
81131310:	1705883a 	add	r2,r2,fp
81131314:	14a5883a 	add	r18,r2,r18
81131318:	88bfffc4 	addi	r2,r17,-1
8113131c:	e4800c2e 	bgeu	fp,r18,81131350 <__divdf3+0x734>
81131320:	90c03e36 	bltu	r18,r3,8113141c <__divdf3+0x800>
81131324:	1c806926 	beq	r3,r18,811314cc <__divdf3+0x8b0>
81131328:	90c7c83a 	sub	r3,r18,r3
8113132c:	1023883a 	mov	r17,r2
81131330:	003f5206 	br	8113107c <__reset+0xfb11107c>
81131334:	923f0436 	bltu	r18,r8,81130f48 <__reset+0xfb110f48>
81131338:	800897fa 	slli	r4,r16,31
8113133c:	9004d07a 	srli	r2,r18,1
81131340:	8006d07a 	srli	r3,r16,1
81131344:	902097fa 	slli	r16,r18,31
81131348:	20a4b03a 	or	r18,r4,r2
8113134c:	003f0106 	br	81130f54 <__reset+0xfb110f54>
81131350:	e4bff51e 	bne	fp,r18,81131328 <__reset+0xfb111328>
81131354:	85bff22e 	bgeu	r16,r22,81131320 <__reset+0xfb111320>
81131358:	e0c7c83a 	sub	r3,fp,r3
8113135c:	1023883a 	mov	r17,r2
81131360:	003f4606 	br	8113107c <__reset+0xfb11107c>
81131364:	100f883a 	mov	r7,r2
81131368:	003f2b06 	br	81131018 <__reset+0xfb111018>
8113136c:	180d883a 	mov	r6,r3
81131370:	003f1306 	br	81130fc0 <__reset+0xfb110fc0>
81131374:	813fe436 	bltu	r16,r4,81131308 <__reset+0xfb111308>
81131378:	0007883a 	mov	r3,zero
8113137c:	003f3f06 	br	8113107c <__reset+0xfb11107c>
81131380:	ba402c36 	bltu	r23,r9,81131434 <__divdf3+0x818>
81131384:	4dc05426 	beq	r9,r23,811314d8 <__divdf3+0x8bc>
81131388:	1011883a 	mov	r8,r2
8113138c:	003f8906 	br	811311b4 <__reset+0xfb1111b4>
81131390:	023fffc4 	movi	r8,-1
81131394:	003f8806 	br	811311b8 <__reset+0xfb1111b8>
81131398:	1811883a 	mov	r8,r3
8113139c:	003f5406 	br	811310f0 <__reset+0xfb1110f0>
811313a0:	1025883a 	mov	r18,r2
811313a4:	003f6d06 	br	8113115c <__reset+0xfb11115c>
811313a8:	b827883a 	mov	r19,r23
811313ac:	003f8206 	br	811311b8 <__reset+0xfb1111b8>
811313b0:	010007c4 	movi	r4,31
811313b4:	20c02616 	blt	r4,r3,81131450 <__divdf3+0x834>
811313b8:	00800804 	movi	r2,32
811313bc:	10c5c83a 	sub	r2,r2,r3
811313c0:	888a983a 	sll	r5,r17,r2
811313c4:	40c8d83a 	srl	r4,r8,r3
811313c8:	4084983a 	sll	r2,r8,r2
811313cc:	88e2d83a 	srl	r17,r17,r3
811313d0:	2906b03a 	or	r3,r5,r4
811313d4:	1004c03a 	cmpne	r2,r2,zero
811313d8:	1886b03a 	or	r3,r3,r2
811313dc:	188001cc 	andi	r2,r3,7
811313e0:	10000726 	beq	r2,zero,81131400 <__divdf3+0x7e4>
811313e4:	188003cc 	andi	r2,r3,15
811313e8:	01000104 	movi	r4,4
811313ec:	11000426 	beq	r2,r4,81131400 <__divdf3+0x7e4>
811313f0:	1805883a 	mov	r2,r3
811313f4:	10c00104 	addi	r3,r2,4
811313f8:	1885803a 	cmpltu	r2,r3,r2
811313fc:	88a3883a 	add	r17,r17,r2
81131400:	8880202c 	andhi	r2,r17,128
81131404:	10002726 	beq	r2,zero,811314a4 <__divdf3+0x888>
81131408:	98c0004c 	andi	r3,r19,1
8113140c:	00800044 	movi	r2,1
81131410:	000b883a 	mov	r5,zero
81131414:	0025883a 	mov	r18,zero
81131418:	003e6106 	br	81130da0 <__reset+0xfb110da0>
8113141c:	85a1883a 	add	r16,r16,r22
81131420:	8585803a 	cmpltu	r2,r16,r22
81131424:	1705883a 	add	r2,r2,fp
81131428:	14a5883a 	add	r18,r2,r18
8113142c:	8c7fff84 	addi	r17,r17,-2
81131430:	003f1106 	br	81131078 <__reset+0xfb111078>
81131434:	b589883a 	add	r4,r22,r22
81131438:	25ad803a 	cmpltu	r22,r4,r22
8113143c:	b739883a 	add	fp,r22,fp
81131440:	40bfff84 	addi	r2,r8,-2
81131444:	bf2f883a 	add	r23,r23,fp
81131448:	202d883a 	mov	r22,r4
8113144c:	003f9306 	br	8113129c <__reset+0xfb11129c>
81131450:	013ff844 	movi	r4,-31
81131454:	2085c83a 	sub	r2,r4,r2
81131458:	8888d83a 	srl	r4,r17,r2
8113145c:	00800804 	movi	r2,32
81131460:	18802126 	beq	r3,r2,811314e8 <__divdf3+0x8cc>
81131464:	00801004 	movi	r2,64
81131468:	10c5c83a 	sub	r2,r2,r3
8113146c:	8884983a 	sll	r2,r17,r2
81131470:	1204b03a 	or	r2,r2,r8
81131474:	1004c03a 	cmpne	r2,r2,zero
81131478:	2084b03a 	or	r2,r4,r2
8113147c:	144001cc 	andi	r17,r2,7
81131480:	88000d1e 	bne	r17,zero,811314b8 <__divdf3+0x89c>
81131484:	000b883a 	mov	r5,zero
81131488:	1024d0fa 	srli	r18,r2,3
8113148c:	98c0004c 	andi	r3,r19,1
81131490:	0005883a 	mov	r2,zero
81131494:	9464b03a 	or	r18,r18,r17
81131498:	003e4106 	br	81130da0 <__reset+0xfb110da0>
8113149c:	1007883a 	mov	r3,r2
811314a0:	0023883a 	mov	r17,zero
811314a4:	880a927a 	slli	r5,r17,9
811314a8:	1805883a 	mov	r2,r3
811314ac:	8822977a 	slli	r17,r17,29
811314b0:	280ad33a 	srli	r5,r5,12
811314b4:	003ff406 	br	81131488 <__reset+0xfb111488>
811314b8:	10c003cc 	andi	r3,r2,15
811314bc:	01000104 	movi	r4,4
811314c0:	193ff626 	beq	r3,r4,8113149c <__reset+0xfb11149c>
811314c4:	0023883a 	mov	r17,zero
811314c8:	003fca06 	br	811313f4 <__reset+0xfb1113f4>
811314cc:	813fd336 	bltu	r16,r4,8113141c <__reset+0xfb11141c>
811314d0:	1023883a 	mov	r17,r2
811314d4:	003fa806 	br	81131378 <__reset+0xfb111378>
811314d8:	b0ffd636 	bltu	r22,r3,81131434 <__reset+0xfb111434>
811314dc:	1011883a 	mov	r8,r2
811314e0:	b0ff341e 	bne	r22,r3,811311b4 <__reset+0xfb1111b4>
811314e4:	003f3406 	br	811311b8 <__reset+0xfb1111b8>
811314e8:	0005883a 	mov	r2,zero
811314ec:	003fe006 	br	81131470 <__reset+0xfb111470>
811314f0:	00800434 	movhi	r2,16
811314f4:	89400234 	orhi	r5,r17,8
811314f8:	10bfffc4 	addi	r2,r2,-1
811314fc:	b807883a 	mov	r3,r23
81131500:	288a703a 	and	r5,r5,r2
81131504:	4025883a 	mov	r18,r8
81131508:	003e8206 	br	81130f14 <__reset+0xfb110f14>

8113150c <__eqdf2>:
8113150c:	2804d53a 	srli	r2,r5,20
81131510:	3806d53a 	srli	r3,r7,20
81131514:	02000434 	movhi	r8,16
81131518:	423fffc4 	addi	r8,r8,-1
8113151c:	1081ffcc 	andi	r2,r2,2047
81131520:	0281ffc4 	movi	r10,2047
81131524:	2a12703a 	and	r9,r5,r8
81131528:	18c1ffcc 	andi	r3,r3,2047
8113152c:	3a10703a 	and	r8,r7,r8
81131530:	280ad7fa 	srli	r5,r5,31
81131534:	380ed7fa 	srli	r7,r7,31
81131538:	12801026 	beq	r2,r10,8113157c <__eqdf2+0x70>
8113153c:	0281ffc4 	movi	r10,2047
81131540:	1a800a26 	beq	r3,r10,8113156c <__eqdf2+0x60>
81131544:	10c00226 	beq	r2,r3,81131550 <__eqdf2+0x44>
81131548:	00800044 	movi	r2,1
8113154c:	f800283a 	ret
81131550:	4a3ffd1e 	bne	r9,r8,81131548 <__reset+0xfb111548>
81131554:	21bffc1e 	bne	r4,r6,81131548 <__reset+0xfb111548>
81131558:	29c00c26 	beq	r5,r7,8113158c <__eqdf2+0x80>
8113155c:	103ffa1e 	bne	r2,zero,81131548 <__reset+0xfb111548>
81131560:	2244b03a 	or	r2,r4,r9
81131564:	1004c03a 	cmpne	r2,r2,zero
81131568:	f800283a 	ret
8113156c:	3214b03a 	or	r10,r6,r8
81131570:	503ff426 	beq	r10,zero,81131544 <__reset+0xfb111544>
81131574:	00800044 	movi	r2,1
81131578:	f800283a 	ret
8113157c:	2254b03a 	or	r10,r4,r9
81131580:	503fee26 	beq	r10,zero,8113153c <__reset+0xfb11153c>
81131584:	00800044 	movi	r2,1
81131588:	f800283a 	ret
8113158c:	0005883a 	mov	r2,zero
81131590:	f800283a 	ret

81131594 <__gedf2>:
81131594:	2804d53a 	srli	r2,r5,20
81131598:	3806d53a 	srli	r3,r7,20
8113159c:	02000434 	movhi	r8,16
811315a0:	423fffc4 	addi	r8,r8,-1
811315a4:	1081ffcc 	andi	r2,r2,2047
811315a8:	0241ffc4 	movi	r9,2047
811315ac:	2a14703a 	and	r10,r5,r8
811315b0:	18c1ffcc 	andi	r3,r3,2047
811315b4:	3a10703a 	and	r8,r7,r8
811315b8:	280ad7fa 	srli	r5,r5,31
811315bc:	380ed7fa 	srli	r7,r7,31
811315c0:	12401d26 	beq	r2,r9,81131638 <__gedf2+0xa4>
811315c4:	0241ffc4 	movi	r9,2047
811315c8:	1a401226 	beq	r3,r9,81131614 <__gedf2+0x80>
811315cc:	1000081e 	bne	r2,zero,811315f0 <__gedf2+0x5c>
811315d0:	2296b03a 	or	r11,r4,r10
811315d4:	5813003a 	cmpeq	r9,r11,zero
811315d8:	1800091e 	bne	r3,zero,81131600 <__gedf2+0x6c>
811315dc:	3218b03a 	or	r12,r6,r8
811315e0:	6000071e 	bne	r12,zero,81131600 <__gedf2+0x6c>
811315e4:	0005883a 	mov	r2,zero
811315e8:	5800101e 	bne	r11,zero,8113162c <__gedf2+0x98>
811315ec:	f800283a 	ret
811315f0:	18000c1e 	bne	r3,zero,81131624 <__gedf2+0x90>
811315f4:	3212b03a 	or	r9,r6,r8
811315f8:	48000c26 	beq	r9,zero,8113162c <__gedf2+0x98>
811315fc:	0013883a 	mov	r9,zero
81131600:	39c03fcc 	andi	r7,r7,255
81131604:	48000826 	beq	r9,zero,81131628 <__gedf2+0x94>
81131608:	38000926 	beq	r7,zero,81131630 <__gedf2+0x9c>
8113160c:	00800044 	movi	r2,1
81131610:	f800283a 	ret
81131614:	3212b03a 	or	r9,r6,r8
81131618:	483fec26 	beq	r9,zero,811315cc <__reset+0xfb1115cc>
8113161c:	00bfff84 	movi	r2,-2
81131620:	f800283a 	ret
81131624:	39c03fcc 	andi	r7,r7,255
81131628:	29c00626 	beq	r5,r7,81131644 <__gedf2+0xb0>
8113162c:	283ff726 	beq	r5,zero,8113160c <__reset+0xfb11160c>
81131630:	00bfffc4 	movi	r2,-1
81131634:	f800283a 	ret
81131638:	2292b03a 	or	r9,r4,r10
8113163c:	483fe126 	beq	r9,zero,811315c4 <__reset+0xfb1115c4>
81131640:	003ff606 	br	8113161c <__reset+0xfb11161c>
81131644:	18bff916 	blt	r3,r2,8113162c <__reset+0xfb11162c>
81131648:	10c00316 	blt	r2,r3,81131658 <__gedf2+0xc4>
8113164c:	42bff736 	bltu	r8,r10,8113162c <__reset+0xfb11162c>
81131650:	52000326 	beq	r10,r8,81131660 <__gedf2+0xcc>
81131654:	5200042e 	bgeu	r10,r8,81131668 <__gedf2+0xd4>
81131658:	283fec1e 	bne	r5,zero,8113160c <__reset+0xfb11160c>
8113165c:	003ff406 	br	81131630 <__reset+0xfb111630>
81131660:	313ff236 	bltu	r6,r4,8113162c <__reset+0xfb11162c>
81131664:	21bffc36 	bltu	r4,r6,81131658 <__reset+0xfb111658>
81131668:	0005883a 	mov	r2,zero
8113166c:	f800283a 	ret

81131670 <__ledf2>:
81131670:	2804d53a 	srli	r2,r5,20
81131674:	3810d53a 	srli	r8,r7,20
81131678:	00c00434 	movhi	r3,16
8113167c:	18ffffc4 	addi	r3,r3,-1
81131680:	1081ffcc 	andi	r2,r2,2047
81131684:	0241ffc4 	movi	r9,2047
81131688:	28d4703a 	and	r10,r5,r3
8113168c:	4201ffcc 	andi	r8,r8,2047
81131690:	38c6703a 	and	r3,r7,r3
81131694:	280ad7fa 	srli	r5,r5,31
81131698:	380ed7fa 	srli	r7,r7,31
8113169c:	12401f26 	beq	r2,r9,8113171c <__ledf2+0xac>
811316a0:	0241ffc4 	movi	r9,2047
811316a4:	42401426 	beq	r8,r9,811316f8 <__ledf2+0x88>
811316a8:	1000091e 	bne	r2,zero,811316d0 <__ledf2+0x60>
811316ac:	2296b03a 	or	r11,r4,r10
811316b0:	5813003a 	cmpeq	r9,r11,zero
811316b4:	29403fcc 	andi	r5,r5,255
811316b8:	40000a1e 	bne	r8,zero,811316e4 <__ledf2+0x74>
811316bc:	30d8b03a 	or	r12,r6,r3
811316c0:	6000081e 	bne	r12,zero,811316e4 <__ledf2+0x74>
811316c4:	0005883a 	mov	r2,zero
811316c8:	5800111e 	bne	r11,zero,81131710 <__ledf2+0xa0>
811316cc:	f800283a 	ret
811316d0:	29403fcc 	andi	r5,r5,255
811316d4:	40000c1e 	bne	r8,zero,81131708 <__ledf2+0x98>
811316d8:	30d2b03a 	or	r9,r6,r3
811316dc:	48000c26 	beq	r9,zero,81131710 <__ledf2+0xa0>
811316e0:	0013883a 	mov	r9,zero
811316e4:	39c03fcc 	andi	r7,r7,255
811316e8:	48000826 	beq	r9,zero,8113170c <__ledf2+0x9c>
811316ec:	38001126 	beq	r7,zero,81131734 <__ledf2+0xc4>
811316f0:	00800044 	movi	r2,1
811316f4:	f800283a 	ret
811316f8:	30d2b03a 	or	r9,r6,r3
811316fc:	483fea26 	beq	r9,zero,811316a8 <__reset+0xfb1116a8>
81131700:	00800084 	movi	r2,2
81131704:	f800283a 	ret
81131708:	39c03fcc 	andi	r7,r7,255
8113170c:	39400726 	beq	r7,r5,8113172c <__ledf2+0xbc>
81131710:	2800081e 	bne	r5,zero,81131734 <__ledf2+0xc4>
81131714:	00800044 	movi	r2,1
81131718:	f800283a 	ret
8113171c:	2292b03a 	or	r9,r4,r10
81131720:	483fdf26 	beq	r9,zero,811316a0 <__reset+0xfb1116a0>
81131724:	00800084 	movi	r2,2
81131728:	f800283a 	ret
8113172c:	4080030e 	bge	r8,r2,8113173c <__ledf2+0xcc>
81131730:	383fef26 	beq	r7,zero,811316f0 <__reset+0xfb1116f0>
81131734:	00bfffc4 	movi	r2,-1
81131738:	f800283a 	ret
8113173c:	123feb16 	blt	r2,r8,811316ec <__reset+0xfb1116ec>
81131740:	1abff336 	bltu	r3,r10,81131710 <__reset+0xfb111710>
81131744:	50c00326 	beq	r10,r3,81131754 <__ledf2+0xe4>
81131748:	50c0042e 	bgeu	r10,r3,8113175c <__ledf2+0xec>
8113174c:	283fe81e 	bne	r5,zero,811316f0 <__reset+0xfb1116f0>
81131750:	003ff806 	br	81131734 <__reset+0xfb111734>
81131754:	313fee36 	bltu	r6,r4,81131710 <__reset+0xfb111710>
81131758:	21bffc36 	bltu	r4,r6,8113174c <__reset+0xfb11174c>
8113175c:	0005883a 	mov	r2,zero
81131760:	f800283a 	ret

81131764 <__subdf3>:
81131764:	02000434 	movhi	r8,16
81131768:	423fffc4 	addi	r8,r8,-1
8113176c:	defffb04 	addi	sp,sp,-20
81131770:	2a14703a 	and	r10,r5,r8
81131774:	3812d53a 	srli	r9,r7,20
81131778:	3a10703a 	and	r8,r7,r8
8113177c:	de00012e 	bgeu	sp,et,81131784 <__subdf3+0x20>
81131780:	003b68fa 	trap	3
81131784:	2006d77a 	srli	r3,r4,29
81131788:	3004d77a 	srli	r2,r6,29
8113178c:	dc000015 	stw	r16,0(sp)
81131790:	501490fa 	slli	r10,r10,3
81131794:	2820d53a 	srli	r16,r5,20
81131798:	401090fa 	slli	r8,r8,3
8113179c:	dc800215 	stw	r18,8(sp)
811317a0:	dc400115 	stw	r17,4(sp)
811317a4:	dfc00415 	stw	ra,16(sp)
811317a8:	202290fa 	slli	r17,r4,3
811317ac:	dcc00315 	stw	r19,12(sp)
811317b0:	4a41ffcc 	andi	r9,r9,2047
811317b4:	0101ffc4 	movi	r4,2047
811317b8:	2824d7fa 	srli	r18,r5,31
811317bc:	8401ffcc 	andi	r16,r16,2047
811317c0:	50c6b03a 	or	r3,r10,r3
811317c4:	380ed7fa 	srli	r7,r7,31
811317c8:	408ab03a 	or	r5,r8,r2
811317cc:	300c90fa 	slli	r6,r6,3
811317d0:	49009626 	beq	r9,r4,81131a2c <__subdf3+0x2c8>
811317d4:	39c0005c 	xori	r7,r7,1
811317d8:	8245c83a 	sub	r2,r16,r9
811317dc:	3c807426 	beq	r7,r18,811319b0 <__subdf3+0x24c>
811317e0:	0080af0e 	bge	zero,r2,81131aa0 <__subdf3+0x33c>
811317e4:	48002a1e 	bne	r9,zero,81131890 <__subdf3+0x12c>
811317e8:	2988b03a 	or	r4,r5,r6
811317ec:	20009a1e 	bne	r4,zero,81131a58 <__subdf3+0x2f4>
811317f0:	888001cc 	andi	r2,r17,7
811317f4:	10000726 	beq	r2,zero,81131814 <__subdf3+0xb0>
811317f8:	888003cc 	andi	r2,r17,15
811317fc:	01000104 	movi	r4,4
81131800:	11000426 	beq	r2,r4,81131814 <__subdf3+0xb0>
81131804:	890b883a 	add	r5,r17,r4
81131808:	2c63803a 	cmpltu	r17,r5,r17
8113180c:	1c47883a 	add	r3,r3,r17
81131810:	2823883a 	mov	r17,r5
81131814:	1880202c 	andhi	r2,r3,128
81131818:	10005926 	beq	r2,zero,81131980 <__subdf3+0x21c>
8113181c:	84000044 	addi	r16,r16,1
81131820:	0081ffc4 	movi	r2,2047
81131824:	8080be26 	beq	r16,r2,81131b20 <__subdf3+0x3bc>
81131828:	017fe034 	movhi	r5,65408
8113182c:	297fffc4 	addi	r5,r5,-1
81131830:	1946703a 	and	r3,r3,r5
81131834:	1804977a 	slli	r2,r3,29
81131838:	1806927a 	slli	r3,r3,9
8113183c:	8822d0fa 	srli	r17,r17,3
81131840:	8401ffcc 	andi	r16,r16,2047
81131844:	180ad33a 	srli	r5,r3,12
81131848:	9100004c 	andi	r4,r18,1
8113184c:	1444b03a 	or	r2,r2,r17
81131850:	80c1ffcc 	andi	r3,r16,2047
81131854:	1820953a 	slli	r16,r3,20
81131858:	20c03fcc 	andi	r3,r4,255
8113185c:	180897fa 	slli	r4,r3,31
81131860:	00c00434 	movhi	r3,16
81131864:	18ffffc4 	addi	r3,r3,-1
81131868:	28c6703a 	and	r3,r5,r3
8113186c:	1c06b03a 	or	r3,r3,r16
81131870:	1906b03a 	or	r3,r3,r4
81131874:	dfc00417 	ldw	ra,16(sp)
81131878:	dcc00317 	ldw	r19,12(sp)
8113187c:	dc800217 	ldw	r18,8(sp)
81131880:	dc400117 	ldw	r17,4(sp)
81131884:	dc000017 	ldw	r16,0(sp)
81131888:	dec00504 	addi	sp,sp,20
8113188c:	f800283a 	ret
81131890:	0101ffc4 	movi	r4,2047
81131894:	813fd626 	beq	r16,r4,811317f0 <__reset+0xfb1117f0>
81131898:	29402034 	orhi	r5,r5,128
8113189c:	01000e04 	movi	r4,56
811318a0:	2080a316 	blt	r4,r2,81131b30 <__subdf3+0x3cc>
811318a4:	010007c4 	movi	r4,31
811318a8:	2080c616 	blt	r4,r2,81131bc4 <__subdf3+0x460>
811318ac:	01000804 	movi	r4,32
811318b0:	2089c83a 	sub	r4,r4,r2
811318b4:	2910983a 	sll	r8,r5,r4
811318b8:	308ed83a 	srl	r7,r6,r2
811318bc:	3108983a 	sll	r4,r6,r4
811318c0:	2884d83a 	srl	r2,r5,r2
811318c4:	41ccb03a 	or	r6,r8,r7
811318c8:	2008c03a 	cmpne	r4,r4,zero
811318cc:	310cb03a 	or	r6,r6,r4
811318d0:	898dc83a 	sub	r6,r17,r6
811318d4:	89a3803a 	cmpltu	r17,r17,r6
811318d8:	1887c83a 	sub	r3,r3,r2
811318dc:	1c47c83a 	sub	r3,r3,r17
811318e0:	3023883a 	mov	r17,r6
811318e4:	1880202c 	andhi	r2,r3,128
811318e8:	10002326 	beq	r2,zero,81131978 <__subdf3+0x214>
811318ec:	04c02034 	movhi	r19,128
811318f0:	9cffffc4 	addi	r19,r19,-1
811318f4:	1ce6703a 	and	r19,r3,r19
811318f8:	98007a26 	beq	r19,zero,81131ae4 <__subdf3+0x380>
811318fc:	9809883a 	mov	r4,r19
81131900:	111c8580 	call	8111c858 <__clzsi2>
81131904:	113ffe04 	addi	r4,r2,-8
81131908:	00c007c4 	movi	r3,31
8113190c:	19007b16 	blt	r3,r4,81131afc <__subdf3+0x398>
81131910:	00800804 	movi	r2,32
81131914:	1105c83a 	sub	r2,r2,r4
81131918:	8884d83a 	srl	r2,r17,r2
8113191c:	9906983a 	sll	r3,r19,r4
81131920:	8922983a 	sll	r17,r17,r4
81131924:	10c4b03a 	or	r2,r2,r3
81131928:	24007816 	blt	r4,r16,81131b0c <__subdf3+0x3a8>
8113192c:	2421c83a 	sub	r16,r4,r16
81131930:	80c00044 	addi	r3,r16,1
81131934:	010007c4 	movi	r4,31
81131938:	20c09516 	blt	r4,r3,81131b90 <__subdf3+0x42c>
8113193c:	01400804 	movi	r5,32
81131940:	28cbc83a 	sub	r5,r5,r3
81131944:	88c8d83a 	srl	r4,r17,r3
81131948:	8962983a 	sll	r17,r17,r5
8113194c:	114a983a 	sll	r5,r2,r5
81131950:	10c6d83a 	srl	r3,r2,r3
81131954:	8804c03a 	cmpne	r2,r17,zero
81131958:	290ab03a 	or	r5,r5,r4
8113195c:	28a2b03a 	or	r17,r5,r2
81131960:	0021883a 	mov	r16,zero
81131964:	003fa206 	br	811317f0 <__reset+0xfb1117f0>
81131968:	2090b03a 	or	r8,r4,r2
8113196c:	40018e26 	beq	r8,zero,81131fa8 <__subdf3+0x844>
81131970:	1007883a 	mov	r3,r2
81131974:	2023883a 	mov	r17,r4
81131978:	888001cc 	andi	r2,r17,7
8113197c:	103f9e1e 	bne	r2,zero,811317f8 <__reset+0xfb1117f8>
81131980:	1804977a 	slli	r2,r3,29
81131984:	8822d0fa 	srli	r17,r17,3
81131988:	1810d0fa 	srli	r8,r3,3
8113198c:	9100004c 	andi	r4,r18,1
81131990:	1444b03a 	or	r2,r2,r17
81131994:	00c1ffc4 	movi	r3,2047
81131998:	80c02826 	beq	r16,r3,81131a3c <__subdf3+0x2d8>
8113199c:	01400434 	movhi	r5,16
811319a0:	297fffc4 	addi	r5,r5,-1
811319a4:	80e0703a 	and	r16,r16,r3
811319a8:	414a703a 	and	r5,r8,r5
811319ac:	003fa806 	br	81131850 <__reset+0xfb111850>
811319b0:	0080630e 	bge	zero,r2,81131b40 <__subdf3+0x3dc>
811319b4:	48003026 	beq	r9,zero,81131a78 <__subdf3+0x314>
811319b8:	0101ffc4 	movi	r4,2047
811319bc:	813f8c26 	beq	r16,r4,811317f0 <__reset+0xfb1117f0>
811319c0:	29402034 	orhi	r5,r5,128
811319c4:	01000e04 	movi	r4,56
811319c8:	2080a90e 	bge	r4,r2,81131c70 <__subdf3+0x50c>
811319cc:	298cb03a 	or	r6,r5,r6
811319d0:	3012c03a 	cmpne	r9,r6,zero
811319d4:	0005883a 	mov	r2,zero
811319d8:	4c53883a 	add	r9,r9,r17
811319dc:	4c63803a 	cmpltu	r17,r9,r17
811319e0:	10c7883a 	add	r3,r2,r3
811319e4:	88c7883a 	add	r3,r17,r3
811319e8:	4823883a 	mov	r17,r9
811319ec:	1880202c 	andhi	r2,r3,128
811319f0:	1000d026 	beq	r2,zero,81131d34 <__subdf3+0x5d0>
811319f4:	84000044 	addi	r16,r16,1
811319f8:	0081ffc4 	movi	r2,2047
811319fc:	8080fe26 	beq	r16,r2,81131df8 <__subdf3+0x694>
81131a00:	00bfe034 	movhi	r2,65408
81131a04:	10bfffc4 	addi	r2,r2,-1
81131a08:	1886703a 	and	r3,r3,r2
81131a0c:	880ad07a 	srli	r5,r17,1
81131a10:	180497fa 	slli	r2,r3,31
81131a14:	8900004c 	andi	r4,r17,1
81131a18:	2922b03a 	or	r17,r5,r4
81131a1c:	1806d07a 	srli	r3,r3,1
81131a20:	1462b03a 	or	r17,r2,r17
81131a24:	3825883a 	mov	r18,r7
81131a28:	003f7106 	br	811317f0 <__reset+0xfb1117f0>
81131a2c:	2984b03a 	or	r2,r5,r6
81131a30:	103f6826 	beq	r2,zero,811317d4 <__reset+0xfb1117d4>
81131a34:	39c03fcc 	andi	r7,r7,255
81131a38:	003f6706 	br	811317d8 <__reset+0xfb1117d8>
81131a3c:	4086b03a 	or	r3,r8,r2
81131a40:	18015226 	beq	r3,zero,81131f8c <__subdf3+0x828>
81131a44:	00c00434 	movhi	r3,16
81131a48:	41400234 	orhi	r5,r8,8
81131a4c:	18ffffc4 	addi	r3,r3,-1
81131a50:	28ca703a 	and	r5,r5,r3
81131a54:	003f7e06 	br	81131850 <__reset+0xfb111850>
81131a58:	10bfffc4 	addi	r2,r2,-1
81131a5c:	1000491e 	bne	r2,zero,81131b84 <__subdf3+0x420>
81131a60:	898fc83a 	sub	r7,r17,r6
81131a64:	89e3803a 	cmpltu	r17,r17,r7
81131a68:	1947c83a 	sub	r3,r3,r5
81131a6c:	1c47c83a 	sub	r3,r3,r17
81131a70:	3823883a 	mov	r17,r7
81131a74:	003f9b06 	br	811318e4 <__reset+0xfb1118e4>
81131a78:	2988b03a 	or	r4,r5,r6
81131a7c:	203f5c26 	beq	r4,zero,811317f0 <__reset+0xfb1117f0>
81131a80:	10bfffc4 	addi	r2,r2,-1
81131a84:	1000931e 	bne	r2,zero,81131cd4 <__subdf3+0x570>
81131a88:	898d883a 	add	r6,r17,r6
81131a8c:	3463803a 	cmpltu	r17,r6,r17
81131a90:	1947883a 	add	r3,r3,r5
81131a94:	88c7883a 	add	r3,r17,r3
81131a98:	3023883a 	mov	r17,r6
81131a9c:	003fd306 	br	811319ec <__reset+0xfb1119ec>
81131aa0:	1000541e 	bne	r2,zero,81131bf4 <__subdf3+0x490>
81131aa4:	80800044 	addi	r2,r16,1
81131aa8:	1081ffcc 	andi	r2,r2,2047
81131aac:	01000044 	movi	r4,1
81131ab0:	2080a20e 	bge	r4,r2,81131d3c <__subdf3+0x5d8>
81131ab4:	8989c83a 	sub	r4,r17,r6
81131ab8:	8905803a 	cmpltu	r2,r17,r4
81131abc:	1967c83a 	sub	r19,r3,r5
81131ac0:	98a7c83a 	sub	r19,r19,r2
81131ac4:	9880202c 	andhi	r2,r19,128
81131ac8:	10006326 	beq	r2,zero,81131c58 <__subdf3+0x4f4>
81131acc:	3463c83a 	sub	r17,r6,r17
81131ad0:	28c7c83a 	sub	r3,r5,r3
81131ad4:	344d803a 	cmpltu	r6,r6,r17
81131ad8:	19a7c83a 	sub	r19,r3,r6
81131adc:	3825883a 	mov	r18,r7
81131ae0:	983f861e 	bne	r19,zero,811318fc <__reset+0xfb1118fc>
81131ae4:	8809883a 	mov	r4,r17
81131ae8:	111c8580 	call	8111c858 <__clzsi2>
81131aec:	10800804 	addi	r2,r2,32
81131af0:	113ffe04 	addi	r4,r2,-8
81131af4:	00c007c4 	movi	r3,31
81131af8:	193f850e 	bge	r3,r4,81131910 <__reset+0xfb111910>
81131afc:	10bff604 	addi	r2,r2,-40
81131b00:	8884983a 	sll	r2,r17,r2
81131b04:	0023883a 	mov	r17,zero
81131b08:	243f880e 	bge	r4,r16,8113192c <__reset+0xfb11192c>
81131b0c:	00ffe034 	movhi	r3,65408
81131b10:	18ffffc4 	addi	r3,r3,-1
81131b14:	8121c83a 	sub	r16,r16,r4
81131b18:	10c6703a 	and	r3,r2,r3
81131b1c:	003f3406 	br	811317f0 <__reset+0xfb1117f0>
81131b20:	9100004c 	andi	r4,r18,1
81131b24:	000b883a 	mov	r5,zero
81131b28:	0005883a 	mov	r2,zero
81131b2c:	003f4806 	br	81131850 <__reset+0xfb111850>
81131b30:	298cb03a 	or	r6,r5,r6
81131b34:	300cc03a 	cmpne	r6,r6,zero
81131b38:	0005883a 	mov	r2,zero
81131b3c:	003f6406 	br	811318d0 <__reset+0xfb1118d0>
81131b40:	10009a1e 	bne	r2,zero,81131dac <__subdf3+0x648>
81131b44:	82400044 	addi	r9,r16,1
81131b48:	4881ffcc 	andi	r2,r9,2047
81131b4c:	02800044 	movi	r10,1
81131b50:	5080670e 	bge	r10,r2,81131cf0 <__subdf3+0x58c>
81131b54:	0081ffc4 	movi	r2,2047
81131b58:	4880af26 	beq	r9,r2,81131e18 <__subdf3+0x6b4>
81131b5c:	898d883a 	add	r6,r17,r6
81131b60:	1945883a 	add	r2,r3,r5
81131b64:	3447803a 	cmpltu	r3,r6,r17
81131b68:	1887883a 	add	r3,r3,r2
81131b6c:	182297fa 	slli	r17,r3,31
81131b70:	300cd07a 	srli	r6,r6,1
81131b74:	1806d07a 	srli	r3,r3,1
81131b78:	4821883a 	mov	r16,r9
81131b7c:	89a2b03a 	or	r17,r17,r6
81131b80:	003f1b06 	br	811317f0 <__reset+0xfb1117f0>
81131b84:	0101ffc4 	movi	r4,2047
81131b88:	813f441e 	bne	r16,r4,8113189c <__reset+0xfb11189c>
81131b8c:	003f1806 	br	811317f0 <__reset+0xfb1117f0>
81131b90:	843ff844 	addi	r16,r16,-31
81131b94:	01400804 	movi	r5,32
81131b98:	1408d83a 	srl	r4,r2,r16
81131b9c:	19405026 	beq	r3,r5,81131ce0 <__subdf3+0x57c>
81131ba0:	01401004 	movi	r5,64
81131ba4:	28c7c83a 	sub	r3,r5,r3
81131ba8:	10c4983a 	sll	r2,r2,r3
81131bac:	88a2b03a 	or	r17,r17,r2
81131bb0:	8822c03a 	cmpne	r17,r17,zero
81131bb4:	2462b03a 	or	r17,r4,r17
81131bb8:	0007883a 	mov	r3,zero
81131bbc:	0021883a 	mov	r16,zero
81131bc0:	003f6d06 	br	81131978 <__reset+0xfb111978>
81131bc4:	11fff804 	addi	r7,r2,-32
81131bc8:	01000804 	movi	r4,32
81131bcc:	29ced83a 	srl	r7,r5,r7
81131bd0:	11004526 	beq	r2,r4,81131ce8 <__subdf3+0x584>
81131bd4:	01001004 	movi	r4,64
81131bd8:	2089c83a 	sub	r4,r4,r2
81131bdc:	2904983a 	sll	r2,r5,r4
81131be0:	118cb03a 	or	r6,r2,r6
81131be4:	300cc03a 	cmpne	r6,r6,zero
81131be8:	398cb03a 	or	r6,r7,r6
81131bec:	0005883a 	mov	r2,zero
81131bf0:	003f3706 	br	811318d0 <__reset+0xfb1118d0>
81131bf4:	80002a26 	beq	r16,zero,81131ca0 <__subdf3+0x53c>
81131bf8:	0101ffc4 	movi	r4,2047
81131bfc:	49006626 	beq	r9,r4,81131d98 <__subdf3+0x634>
81131c00:	0085c83a 	sub	r2,zero,r2
81131c04:	18c02034 	orhi	r3,r3,128
81131c08:	01000e04 	movi	r4,56
81131c0c:	20807e16 	blt	r4,r2,81131e08 <__subdf3+0x6a4>
81131c10:	010007c4 	movi	r4,31
81131c14:	2080e716 	blt	r4,r2,81131fb4 <__subdf3+0x850>
81131c18:	01000804 	movi	r4,32
81131c1c:	2089c83a 	sub	r4,r4,r2
81131c20:	1914983a 	sll	r10,r3,r4
81131c24:	8890d83a 	srl	r8,r17,r2
81131c28:	8908983a 	sll	r4,r17,r4
81131c2c:	1884d83a 	srl	r2,r3,r2
81131c30:	5222b03a 	or	r17,r10,r8
81131c34:	2006c03a 	cmpne	r3,r4,zero
81131c38:	88e2b03a 	or	r17,r17,r3
81131c3c:	3463c83a 	sub	r17,r6,r17
81131c40:	2885c83a 	sub	r2,r5,r2
81131c44:	344d803a 	cmpltu	r6,r6,r17
81131c48:	1187c83a 	sub	r3,r2,r6
81131c4c:	4821883a 	mov	r16,r9
81131c50:	3825883a 	mov	r18,r7
81131c54:	003f2306 	br	811318e4 <__reset+0xfb1118e4>
81131c58:	24d0b03a 	or	r8,r4,r19
81131c5c:	40001b1e 	bne	r8,zero,81131ccc <__subdf3+0x568>
81131c60:	0005883a 	mov	r2,zero
81131c64:	0009883a 	mov	r4,zero
81131c68:	0021883a 	mov	r16,zero
81131c6c:	003f4906 	br	81131994 <__reset+0xfb111994>
81131c70:	010007c4 	movi	r4,31
81131c74:	20803a16 	blt	r4,r2,81131d60 <__subdf3+0x5fc>
81131c78:	01000804 	movi	r4,32
81131c7c:	2089c83a 	sub	r4,r4,r2
81131c80:	2912983a 	sll	r9,r5,r4
81131c84:	3090d83a 	srl	r8,r6,r2
81131c88:	3108983a 	sll	r4,r6,r4
81131c8c:	2884d83a 	srl	r2,r5,r2
81131c90:	4a12b03a 	or	r9,r9,r8
81131c94:	2008c03a 	cmpne	r4,r4,zero
81131c98:	4912b03a 	or	r9,r9,r4
81131c9c:	003f4e06 	br	811319d8 <__reset+0xfb1119d8>
81131ca0:	1c48b03a 	or	r4,r3,r17
81131ca4:	20003c26 	beq	r4,zero,81131d98 <__subdf3+0x634>
81131ca8:	0084303a 	nor	r2,zero,r2
81131cac:	1000381e 	bne	r2,zero,81131d90 <__subdf3+0x62c>
81131cb0:	3463c83a 	sub	r17,r6,r17
81131cb4:	28c5c83a 	sub	r2,r5,r3
81131cb8:	344d803a 	cmpltu	r6,r6,r17
81131cbc:	1187c83a 	sub	r3,r2,r6
81131cc0:	4821883a 	mov	r16,r9
81131cc4:	3825883a 	mov	r18,r7
81131cc8:	003f0606 	br	811318e4 <__reset+0xfb1118e4>
81131ccc:	2023883a 	mov	r17,r4
81131cd0:	003f0906 	br	811318f8 <__reset+0xfb1118f8>
81131cd4:	0101ffc4 	movi	r4,2047
81131cd8:	813f3a1e 	bne	r16,r4,811319c4 <__reset+0xfb1119c4>
81131cdc:	003ec406 	br	811317f0 <__reset+0xfb1117f0>
81131ce0:	0005883a 	mov	r2,zero
81131ce4:	003fb106 	br	81131bac <__reset+0xfb111bac>
81131ce8:	0005883a 	mov	r2,zero
81131cec:	003fbc06 	br	81131be0 <__reset+0xfb111be0>
81131cf0:	1c44b03a 	or	r2,r3,r17
81131cf4:	80008e1e 	bne	r16,zero,81131f30 <__subdf3+0x7cc>
81131cf8:	1000c826 	beq	r2,zero,8113201c <__subdf3+0x8b8>
81131cfc:	2984b03a 	or	r2,r5,r6
81131d00:	103ebb26 	beq	r2,zero,811317f0 <__reset+0xfb1117f0>
81131d04:	8989883a 	add	r4,r17,r6
81131d08:	1945883a 	add	r2,r3,r5
81131d0c:	2447803a 	cmpltu	r3,r4,r17
81131d10:	1887883a 	add	r3,r3,r2
81131d14:	1880202c 	andhi	r2,r3,128
81131d18:	2023883a 	mov	r17,r4
81131d1c:	103f1626 	beq	r2,zero,81131978 <__reset+0xfb111978>
81131d20:	00bfe034 	movhi	r2,65408
81131d24:	10bfffc4 	addi	r2,r2,-1
81131d28:	5021883a 	mov	r16,r10
81131d2c:	1886703a 	and	r3,r3,r2
81131d30:	003eaf06 	br	811317f0 <__reset+0xfb1117f0>
81131d34:	3825883a 	mov	r18,r7
81131d38:	003f0f06 	br	81131978 <__reset+0xfb111978>
81131d3c:	1c44b03a 	or	r2,r3,r17
81131d40:	8000251e 	bne	r16,zero,81131dd8 <__subdf3+0x674>
81131d44:	1000661e 	bne	r2,zero,81131ee0 <__subdf3+0x77c>
81131d48:	2990b03a 	or	r8,r5,r6
81131d4c:	40009626 	beq	r8,zero,81131fa8 <__subdf3+0x844>
81131d50:	2807883a 	mov	r3,r5
81131d54:	3023883a 	mov	r17,r6
81131d58:	3825883a 	mov	r18,r7
81131d5c:	003ea406 	br	811317f0 <__reset+0xfb1117f0>
81131d60:	127ff804 	addi	r9,r2,-32
81131d64:	01000804 	movi	r4,32
81131d68:	2a52d83a 	srl	r9,r5,r9
81131d6c:	11008c26 	beq	r2,r4,81131fa0 <__subdf3+0x83c>
81131d70:	01001004 	movi	r4,64
81131d74:	2085c83a 	sub	r2,r4,r2
81131d78:	2884983a 	sll	r2,r5,r2
81131d7c:	118cb03a 	or	r6,r2,r6
81131d80:	300cc03a 	cmpne	r6,r6,zero
81131d84:	4992b03a 	or	r9,r9,r6
81131d88:	0005883a 	mov	r2,zero
81131d8c:	003f1206 	br	811319d8 <__reset+0xfb1119d8>
81131d90:	0101ffc4 	movi	r4,2047
81131d94:	493f9c1e 	bne	r9,r4,81131c08 <__reset+0xfb111c08>
81131d98:	2807883a 	mov	r3,r5
81131d9c:	3023883a 	mov	r17,r6
81131da0:	4821883a 	mov	r16,r9
81131da4:	3825883a 	mov	r18,r7
81131da8:	003e9106 	br	811317f0 <__reset+0xfb1117f0>
81131dac:	80001f1e 	bne	r16,zero,81131e2c <__subdf3+0x6c8>
81131db0:	1c48b03a 	or	r4,r3,r17
81131db4:	20005a26 	beq	r4,zero,81131f20 <__subdf3+0x7bc>
81131db8:	0084303a 	nor	r2,zero,r2
81131dbc:	1000561e 	bne	r2,zero,81131f18 <__subdf3+0x7b4>
81131dc0:	89a3883a 	add	r17,r17,r6
81131dc4:	1945883a 	add	r2,r3,r5
81131dc8:	898d803a 	cmpltu	r6,r17,r6
81131dcc:	3087883a 	add	r3,r6,r2
81131dd0:	4821883a 	mov	r16,r9
81131dd4:	003f0506 	br	811319ec <__reset+0xfb1119ec>
81131dd8:	10002b1e 	bne	r2,zero,81131e88 <__subdf3+0x724>
81131ddc:	2984b03a 	or	r2,r5,r6
81131de0:	10008026 	beq	r2,zero,81131fe4 <__subdf3+0x880>
81131de4:	2807883a 	mov	r3,r5
81131de8:	3023883a 	mov	r17,r6
81131dec:	3825883a 	mov	r18,r7
81131df0:	0401ffc4 	movi	r16,2047
81131df4:	003e7e06 	br	811317f0 <__reset+0xfb1117f0>
81131df8:	3809883a 	mov	r4,r7
81131dfc:	0011883a 	mov	r8,zero
81131e00:	0005883a 	mov	r2,zero
81131e04:	003ee306 	br	81131994 <__reset+0xfb111994>
81131e08:	1c62b03a 	or	r17,r3,r17
81131e0c:	8822c03a 	cmpne	r17,r17,zero
81131e10:	0005883a 	mov	r2,zero
81131e14:	003f8906 	br	81131c3c <__reset+0xfb111c3c>
81131e18:	3809883a 	mov	r4,r7
81131e1c:	4821883a 	mov	r16,r9
81131e20:	0011883a 	mov	r8,zero
81131e24:	0005883a 	mov	r2,zero
81131e28:	003eda06 	br	81131994 <__reset+0xfb111994>
81131e2c:	0101ffc4 	movi	r4,2047
81131e30:	49003b26 	beq	r9,r4,81131f20 <__subdf3+0x7bc>
81131e34:	0085c83a 	sub	r2,zero,r2
81131e38:	18c02034 	orhi	r3,r3,128
81131e3c:	01000e04 	movi	r4,56
81131e40:	20806e16 	blt	r4,r2,81131ffc <__subdf3+0x898>
81131e44:	010007c4 	movi	r4,31
81131e48:	20807716 	blt	r4,r2,81132028 <__subdf3+0x8c4>
81131e4c:	01000804 	movi	r4,32
81131e50:	2089c83a 	sub	r4,r4,r2
81131e54:	1914983a 	sll	r10,r3,r4
81131e58:	8890d83a 	srl	r8,r17,r2
81131e5c:	8908983a 	sll	r4,r17,r4
81131e60:	1884d83a 	srl	r2,r3,r2
81131e64:	5222b03a 	or	r17,r10,r8
81131e68:	2006c03a 	cmpne	r3,r4,zero
81131e6c:	88e2b03a 	or	r17,r17,r3
81131e70:	89a3883a 	add	r17,r17,r6
81131e74:	1145883a 	add	r2,r2,r5
81131e78:	898d803a 	cmpltu	r6,r17,r6
81131e7c:	3087883a 	add	r3,r6,r2
81131e80:	4821883a 	mov	r16,r9
81131e84:	003ed906 	br	811319ec <__reset+0xfb1119ec>
81131e88:	2984b03a 	or	r2,r5,r6
81131e8c:	10004226 	beq	r2,zero,81131f98 <__subdf3+0x834>
81131e90:	1808d0fa 	srli	r4,r3,3
81131e94:	8822d0fa 	srli	r17,r17,3
81131e98:	1806977a 	slli	r3,r3,29
81131e9c:	2080022c 	andhi	r2,r4,8
81131ea0:	1c62b03a 	or	r17,r3,r17
81131ea4:	10000826 	beq	r2,zero,81131ec8 <__subdf3+0x764>
81131ea8:	2812d0fa 	srli	r9,r5,3
81131eac:	4880022c 	andhi	r2,r9,8
81131eb0:	1000051e 	bne	r2,zero,81131ec8 <__subdf3+0x764>
81131eb4:	300cd0fa 	srli	r6,r6,3
81131eb8:	2804977a 	slli	r2,r5,29
81131ebc:	4809883a 	mov	r4,r9
81131ec0:	3825883a 	mov	r18,r7
81131ec4:	11a2b03a 	or	r17,r2,r6
81131ec8:	8806d77a 	srli	r3,r17,29
81131ecc:	200890fa 	slli	r4,r4,3
81131ed0:	882290fa 	slli	r17,r17,3
81131ed4:	0401ffc4 	movi	r16,2047
81131ed8:	1906b03a 	or	r3,r3,r4
81131edc:	003e4406 	br	811317f0 <__reset+0xfb1117f0>
81131ee0:	2984b03a 	or	r2,r5,r6
81131ee4:	103e4226 	beq	r2,zero,811317f0 <__reset+0xfb1117f0>
81131ee8:	8989c83a 	sub	r4,r17,r6
81131eec:	8911803a 	cmpltu	r8,r17,r4
81131ef0:	1945c83a 	sub	r2,r3,r5
81131ef4:	1205c83a 	sub	r2,r2,r8
81131ef8:	1200202c 	andhi	r8,r2,128
81131efc:	403e9a26 	beq	r8,zero,81131968 <__reset+0xfb111968>
81131f00:	3463c83a 	sub	r17,r6,r17
81131f04:	28c5c83a 	sub	r2,r5,r3
81131f08:	344d803a 	cmpltu	r6,r6,r17
81131f0c:	1187c83a 	sub	r3,r2,r6
81131f10:	3825883a 	mov	r18,r7
81131f14:	003e3606 	br	811317f0 <__reset+0xfb1117f0>
81131f18:	0101ffc4 	movi	r4,2047
81131f1c:	493fc71e 	bne	r9,r4,81131e3c <__reset+0xfb111e3c>
81131f20:	2807883a 	mov	r3,r5
81131f24:	3023883a 	mov	r17,r6
81131f28:	4821883a 	mov	r16,r9
81131f2c:	003e3006 	br	811317f0 <__reset+0xfb1117f0>
81131f30:	10003626 	beq	r2,zero,8113200c <__subdf3+0x8a8>
81131f34:	2984b03a 	or	r2,r5,r6
81131f38:	10001726 	beq	r2,zero,81131f98 <__subdf3+0x834>
81131f3c:	1808d0fa 	srli	r4,r3,3
81131f40:	8822d0fa 	srli	r17,r17,3
81131f44:	1806977a 	slli	r3,r3,29
81131f48:	2080022c 	andhi	r2,r4,8
81131f4c:	1c62b03a 	or	r17,r3,r17
81131f50:	10000726 	beq	r2,zero,81131f70 <__subdf3+0x80c>
81131f54:	2812d0fa 	srli	r9,r5,3
81131f58:	4880022c 	andhi	r2,r9,8
81131f5c:	1000041e 	bne	r2,zero,81131f70 <__subdf3+0x80c>
81131f60:	300cd0fa 	srli	r6,r6,3
81131f64:	2804977a 	slli	r2,r5,29
81131f68:	4809883a 	mov	r4,r9
81131f6c:	11a2b03a 	or	r17,r2,r6
81131f70:	8806d77a 	srli	r3,r17,29
81131f74:	200890fa 	slli	r4,r4,3
81131f78:	882290fa 	slli	r17,r17,3
81131f7c:	3825883a 	mov	r18,r7
81131f80:	1906b03a 	or	r3,r3,r4
81131f84:	0401ffc4 	movi	r16,2047
81131f88:	003e1906 	br	811317f0 <__reset+0xfb1117f0>
81131f8c:	000b883a 	mov	r5,zero
81131f90:	0005883a 	mov	r2,zero
81131f94:	003e2e06 	br	81131850 <__reset+0xfb111850>
81131f98:	0401ffc4 	movi	r16,2047
81131f9c:	003e1406 	br	811317f0 <__reset+0xfb1117f0>
81131fa0:	0005883a 	mov	r2,zero
81131fa4:	003f7506 	br	81131d7c <__reset+0xfb111d7c>
81131fa8:	0005883a 	mov	r2,zero
81131fac:	0009883a 	mov	r4,zero
81131fb0:	003e7806 	br	81131994 <__reset+0xfb111994>
81131fb4:	123ff804 	addi	r8,r2,-32
81131fb8:	01000804 	movi	r4,32
81131fbc:	1a10d83a 	srl	r8,r3,r8
81131fc0:	11002526 	beq	r2,r4,81132058 <__subdf3+0x8f4>
81131fc4:	01001004 	movi	r4,64
81131fc8:	2085c83a 	sub	r2,r4,r2
81131fcc:	1884983a 	sll	r2,r3,r2
81131fd0:	1444b03a 	or	r2,r2,r17
81131fd4:	1004c03a 	cmpne	r2,r2,zero
81131fd8:	40a2b03a 	or	r17,r8,r2
81131fdc:	0005883a 	mov	r2,zero
81131fe0:	003f1606 	br	81131c3c <__reset+0xfb111c3c>
81131fe4:	02000434 	movhi	r8,16
81131fe8:	0009883a 	mov	r4,zero
81131fec:	423fffc4 	addi	r8,r8,-1
81131ff0:	00bfffc4 	movi	r2,-1
81131ff4:	0401ffc4 	movi	r16,2047
81131ff8:	003e6606 	br	81131994 <__reset+0xfb111994>
81131ffc:	1c62b03a 	or	r17,r3,r17
81132000:	8822c03a 	cmpne	r17,r17,zero
81132004:	0005883a 	mov	r2,zero
81132008:	003f9906 	br	81131e70 <__reset+0xfb111e70>
8113200c:	2807883a 	mov	r3,r5
81132010:	3023883a 	mov	r17,r6
81132014:	0401ffc4 	movi	r16,2047
81132018:	003df506 	br	811317f0 <__reset+0xfb1117f0>
8113201c:	2807883a 	mov	r3,r5
81132020:	3023883a 	mov	r17,r6
81132024:	003df206 	br	811317f0 <__reset+0xfb1117f0>
81132028:	123ff804 	addi	r8,r2,-32
8113202c:	01000804 	movi	r4,32
81132030:	1a10d83a 	srl	r8,r3,r8
81132034:	11000a26 	beq	r2,r4,81132060 <__subdf3+0x8fc>
81132038:	01001004 	movi	r4,64
8113203c:	2085c83a 	sub	r2,r4,r2
81132040:	1884983a 	sll	r2,r3,r2
81132044:	1444b03a 	or	r2,r2,r17
81132048:	1004c03a 	cmpne	r2,r2,zero
8113204c:	40a2b03a 	or	r17,r8,r2
81132050:	0005883a 	mov	r2,zero
81132054:	003f8606 	br	81131e70 <__reset+0xfb111e70>
81132058:	0005883a 	mov	r2,zero
8113205c:	003fdc06 	br	81131fd0 <__reset+0xfb111fd0>
81132060:	0005883a 	mov	r2,zero
81132064:	003ff706 	br	81132044 <__reset+0xfb112044>

81132068 <__fixdfsi>:
81132068:	280cd53a 	srli	r6,r5,20
8113206c:	00c00434 	movhi	r3,16
81132070:	18ffffc4 	addi	r3,r3,-1
81132074:	3181ffcc 	andi	r6,r6,2047
81132078:	01c0ff84 	movi	r7,1022
8113207c:	28c6703a 	and	r3,r5,r3
81132080:	280ad7fa 	srli	r5,r5,31
81132084:	3980120e 	bge	r7,r6,811320d0 <__fixdfsi+0x68>
81132088:	00810744 	movi	r2,1053
8113208c:	11800c16 	blt	r2,r6,811320c0 <__fixdfsi+0x58>
81132090:	00810cc4 	movi	r2,1075
81132094:	1185c83a 	sub	r2,r2,r6
81132098:	01c007c4 	movi	r7,31
8113209c:	18c00434 	orhi	r3,r3,16
811320a0:	38800d16 	blt	r7,r2,811320d8 <__fixdfsi+0x70>
811320a4:	31befb44 	addi	r6,r6,-1043
811320a8:	2084d83a 	srl	r2,r4,r2
811320ac:	1986983a 	sll	r3,r3,r6
811320b0:	1884b03a 	or	r2,r3,r2
811320b4:	28000726 	beq	r5,zero,811320d4 <__fixdfsi+0x6c>
811320b8:	0085c83a 	sub	r2,zero,r2
811320bc:	f800283a 	ret
811320c0:	00a00034 	movhi	r2,32768
811320c4:	10bfffc4 	addi	r2,r2,-1
811320c8:	2885883a 	add	r2,r5,r2
811320cc:	f800283a 	ret
811320d0:	0005883a 	mov	r2,zero
811320d4:	f800283a 	ret
811320d8:	008104c4 	movi	r2,1043
811320dc:	1185c83a 	sub	r2,r2,r6
811320e0:	1884d83a 	srl	r2,r3,r2
811320e4:	003ff306 	br	811320b4 <__reset+0xfb1120b4>

811320e8 <__floatsidf>:
811320e8:	defffd04 	addi	sp,sp,-12
811320ec:	de00012e 	bgeu	sp,et,811320f4 <__floatsidf+0xc>
811320f0:	003b68fa 	trap	3
811320f4:	dfc00215 	stw	ra,8(sp)
811320f8:	dc400115 	stw	r17,4(sp)
811320fc:	dc000015 	stw	r16,0(sp)
81132100:	20002b26 	beq	r4,zero,811321b0 <__floatsidf+0xc8>
81132104:	2023883a 	mov	r17,r4
81132108:	2020d7fa 	srli	r16,r4,31
8113210c:	20002d16 	blt	r4,zero,811321c4 <__floatsidf+0xdc>
81132110:	8809883a 	mov	r4,r17
81132114:	111c8580 	call	8111c858 <__clzsi2>
81132118:	01410784 	movi	r5,1054
8113211c:	288bc83a 	sub	r5,r5,r2
81132120:	01010cc4 	movi	r4,1075
81132124:	2149c83a 	sub	r4,r4,r5
81132128:	00c007c4 	movi	r3,31
8113212c:	1900160e 	bge	r3,r4,81132188 <__floatsidf+0xa0>
81132130:	00c104c4 	movi	r3,1043
81132134:	1947c83a 	sub	r3,r3,r5
81132138:	88c6983a 	sll	r3,r17,r3
8113213c:	00800434 	movhi	r2,16
81132140:	10bfffc4 	addi	r2,r2,-1
81132144:	1886703a 	and	r3,r3,r2
81132148:	2941ffcc 	andi	r5,r5,2047
8113214c:	800d883a 	mov	r6,r16
81132150:	0005883a 	mov	r2,zero
81132154:	280a953a 	slli	r5,r5,20
81132158:	31803fcc 	andi	r6,r6,255
8113215c:	01000434 	movhi	r4,16
81132160:	300c97fa 	slli	r6,r6,31
81132164:	213fffc4 	addi	r4,r4,-1
81132168:	1906703a 	and	r3,r3,r4
8113216c:	1946b03a 	or	r3,r3,r5
81132170:	1986b03a 	or	r3,r3,r6
81132174:	dfc00217 	ldw	ra,8(sp)
81132178:	dc400117 	ldw	r17,4(sp)
8113217c:	dc000017 	ldw	r16,0(sp)
81132180:	dec00304 	addi	sp,sp,12
81132184:	f800283a 	ret
81132188:	00c002c4 	movi	r3,11
8113218c:	1887c83a 	sub	r3,r3,r2
81132190:	88c6d83a 	srl	r3,r17,r3
81132194:	8904983a 	sll	r2,r17,r4
81132198:	01000434 	movhi	r4,16
8113219c:	213fffc4 	addi	r4,r4,-1
811321a0:	2941ffcc 	andi	r5,r5,2047
811321a4:	1906703a 	and	r3,r3,r4
811321a8:	800d883a 	mov	r6,r16
811321ac:	003fe906 	br	81132154 <__reset+0xfb112154>
811321b0:	000d883a 	mov	r6,zero
811321b4:	000b883a 	mov	r5,zero
811321b8:	0007883a 	mov	r3,zero
811321bc:	0005883a 	mov	r2,zero
811321c0:	003fe406 	br	81132154 <__reset+0xfb112154>
811321c4:	0123c83a 	sub	r17,zero,r4
811321c8:	003fd106 	br	81132110 <__reset+0xfb112110>

811321cc <__floatunsidf>:
811321cc:	defffe04 	addi	sp,sp,-8
811321d0:	de00012e 	bgeu	sp,et,811321d8 <__floatunsidf+0xc>
811321d4:	003b68fa 	trap	3
811321d8:	dc000015 	stw	r16,0(sp)
811321dc:	dfc00115 	stw	ra,4(sp)
811321e0:	2021883a 	mov	r16,r4
811321e4:	20002226 	beq	r4,zero,81132270 <__floatunsidf+0xa4>
811321e8:	111c8580 	call	8111c858 <__clzsi2>
811321ec:	01010784 	movi	r4,1054
811321f0:	2089c83a 	sub	r4,r4,r2
811321f4:	01810cc4 	movi	r6,1075
811321f8:	310dc83a 	sub	r6,r6,r4
811321fc:	00c007c4 	movi	r3,31
81132200:	1980120e 	bge	r3,r6,8113224c <__floatunsidf+0x80>
81132204:	00c104c4 	movi	r3,1043
81132208:	1907c83a 	sub	r3,r3,r4
8113220c:	80ca983a 	sll	r5,r16,r3
81132210:	00800434 	movhi	r2,16
81132214:	10bfffc4 	addi	r2,r2,-1
81132218:	2101ffcc 	andi	r4,r4,2047
8113221c:	0021883a 	mov	r16,zero
81132220:	288a703a 	and	r5,r5,r2
81132224:	2008953a 	slli	r4,r4,20
81132228:	00c00434 	movhi	r3,16
8113222c:	18ffffc4 	addi	r3,r3,-1
81132230:	28c6703a 	and	r3,r5,r3
81132234:	8005883a 	mov	r2,r16
81132238:	1906b03a 	or	r3,r3,r4
8113223c:	dfc00117 	ldw	ra,4(sp)
81132240:	dc000017 	ldw	r16,0(sp)
81132244:	dec00204 	addi	sp,sp,8
81132248:	f800283a 	ret
8113224c:	00c002c4 	movi	r3,11
81132250:	188bc83a 	sub	r5,r3,r2
81132254:	814ad83a 	srl	r5,r16,r5
81132258:	00c00434 	movhi	r3,16
8113225c:	18ffffc4 	addi	r3,r3,-1
81132260:	81a0983a 	sll	r16,r16,r6
81132264:	2101ffcc 	andi	r4,r4,2047
81132268:	28ca703a 	and	r5,r5,r3
8113226c:	003fed06 	br	81132224 <__reset+0xfb112224>
81132270:	0009883a 	mov	r4,zero
81132274:	000b883a 	mov	r5,zero
81132278:	003fea06 	br	81132224 <__reset+0xfb112224>

8113227c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
8113227c:	defffb04 	addi	sp,sp,-20
81132280:	de00012e 	bgeu	sp,et,81132288 <alt_busy_sleep+0xc>
81132284:	003b68fa 	trap	3
81132288:	df000415 	stw	fp,16(sp)
8113228c:	df000404 	addi	fp,sp,16
81132290:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
81132294:	008000c4 	movi	r2,3
81132298:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
8113229c:	e0fffd17 	ldw	r3,-12(fp)
811322a0:	008003f4 	movhi	r2,15
811322a4:	10909004 	addi	r2,r2,16960
811322a8:	1887383a 	mul	r3,r3,r2
811322ac:	00817db4 	movhi	r2,1526
811322b0:	10b84004 	addi	r2,r2,-7936
811322b4:	10c7203a 	divu	r3,r2,r3
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
811322b8:	00a00034 	movhi	r2,32768
811322bc:	10bfffc4 	addi	r2,r2,-1
811322c0:	10c5203a 	divu	r2,r2,r3
811322c4:	e0ffff17 	ldw	r3,-4(fp)
811322c8:	1885203a 	divu	r2,r3,r2
811322cc:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
811322d0:	e0bffe17 	ldw	r2,-8(fp)
811322d4:	10002526 	beq	r2,zero,8113236c <alt_busy_sleep+0xf0>
  {
    for(i=0;i<big_loops;i++)
811322d8:	e03ffc15 	stw	zero,-16(fp)
811322dc:	00001406 	br	81132330 <alt_busy_sleep+0xb4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
811322e0:	00a00034 	movhi	r2,32768
811322e4:	10bfffc4 	addi	r2,r2,-1
811322e8:	10bfffc4 	addi	r2,r2,-1
811322ec:	103ffe1e 	bne	r2,zero,811322e8 <__reset+0xfb1122e8>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
811322f0:	e0fffd17 	ldw	r3,-12(fp)
811322f4:	008003f4 	movhi	r2,15
811322f8:	10909004 	addi	r2,r2,16960
811322fc:	1887383a 	mul	r3,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
81132300:	00817db4 	movhi	r2,1526
81132304:	10b84004 	addi	r2,r2,-7936
81132308:	10c7203a 	divu	r3,r2,r3
8113230c:	00a00034 	movhi	r2,32768
81132310:	10bfffc4 	addi	r2,r2,-1
81132314:	10c5203a 	divu	r2,r2,r3
81132318:	e0ffff17 	ldw	r3,-4(fp)
8113231c:	1885c83a 	sub	r2,r3,r2
81132320:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
81132324:	e0bffc17 	ldw	r2,-16(fp)
81132328:	10800044 	addi	r2,r2,1
8113232c:	e0bffc15 	stw	r2,-16(fp)
81132330:	e0fffc17 	ldw	r3,-16(fp)
81132334:	e0bffe17 	ldw	r2,-8(fp)
81132338:	18bfe916 	blt	r3,r2,811322e0 <__reset+0xfb1122e0>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8113233c:	e0fffd17 	ldw	r3,-12(fp)
81132340:	008003f4 	movhi	r2,15
81132344:	10909004 	addi	r2,r2,16960
81132348:	1887383a 	mul	r3,r3,r2
8113234c:	00817db4 	movhi	r2,1526
81132350:	10b84004 	addi	r2,r2,-7936
81132354:	10c7203a 	divu	r3,r2,r3
81132358:	e0bfff17 	ldw	r2,-4(fp)
8113235c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81132360:	10bfffc4 	addi	r2,r2,-1
81132364:	103ffe1e 	bne	r2,zero,81132360 <__reset+0xfb112360>
81132368:	00000b06 	br	81132398 <alt_busy_sleep+0x11c>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
8113236c:	e0fffd17 	ldw	r3,-12(fp)
81132370:	008003f4 	movhi	r2,15
81132374:	10909004 	addi	r2,r2,16960
81132378:	1887383a 	mul	r3,r3,r2
8113237c:	00817db4 	movhi	r2,1526
81132380:	10b84004 	addi	r2,r2,-7936
81132384:	10c7203a 	divu	r3,r2,r3
81132388:	e0bfff17 	ldw	r2,-4(fp)
8113238c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
81132390:	10bfffc4 	addi	r2,r2,-1
81132394:	00bffe16 	blt	zero,r2,81132390 <__reset+0xfb112390>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
81132398:	0005883a 	mov	r2,zero
}
8113239c:	e037883a 	mov	sp,fp
811323a0:	df000017 	ldw	fp,0(sp)
811323a4:	dec00104 	addi	sp,sp,4
811323a8:	f800283a 	ret

811323ac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811323ac:	defffe04 	addi	sp,sp,-8
811323b0:	de00012e 	bgeu	sp,et,811323b8 <alt_get_errno+0xc>
811323b4:	003b68fa 	trap	3
811323b8:	dfc00115 	stw	ra,4(sp)
811323bc:	df000015 	stw	fp,0(sp)
811323c0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811323c4:	d0a01017 	ldw	r2,-32704(gp)
811323c8:	10000326 	beq	r2,zero,811323d8 <alt_get_errno+0x2c>
811323cc:	d0a01017 	ldw	r2,-32704(gp)
811323d0:	103ee83a 	callr	r2
811323d4:	00000106 	br	811323dc <alt_get_errno+0x30>
811323d8:	d0a07404 	addi	r2,gp,-32304
}
811323dc:	e037883a 	mov	sp,fp
811323e0:	dfc00117 	ldw	ra,4(sp)
811323e4:	df000017 	ldw	fp,0(sp)
811323e8:	dec00204 	addi	sp,sp,8
811323ec:	f800283a 	ret

811323f0 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
811323f0:	defffb04 	addi	sp,sp,-20
811323f4:	de00012e 	bgeu	sp,et,811323fc <close+0xc>
811323f8:	003b68fa 	trap	3
811323fc:	dfc00415 	stw	ra,16(sp)
81132400:	df000315 	stw	fp,12(sp)
81132404:	df000304 	addi	fp,sp,12
81132408:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
8113240c:	e0bfff17 	ldw	r2,-4(fp)
81132410:	10000616 	blt	r2,zero,8113242c <close+0x3c>
81132414:	e0bfff17 	ldw	r2,-4(fp)
81132418:	10c00324 	muli	r3,r2,12
8113241c:	00a04574 	movhi	r2,33045
81132420:	10b56a04 	addi	r2,r2,-10840
81132424:	1885883a 	add	r2,r3,r2
81132428:	00000106 	br	81132430 <close+0x40>
8113242c:	0005883a 	mov	r2,zero
81132430:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
81132434:	e0bffd17 	ldw	r2,-12(fp)
81132438:	10001926 	beq	r2,zero,811324a0 <close+0xb0>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
8113243c:	e0bffd17 	ldw	r2,-12(fp)
81132440:	10800017 	ldw	r2,0(r2)
81132444:	10800417 	ldw	r2,16(r2)
81132448:	10000626 	beq	r2,zero,81132464 <close+0x74>
8113244c:	e0bffd17 	ldw	r2,-12(fp)
81132450:	10800017 	ldw	r2,0(r2)
81132454:	10800417 	ldw	r2,16(r2)
81132458:	e13ffd17 	ldw	r4,-12(fp)
8113245c:	103ee83a 	callr	r2
81132460:	00000106 	br	81132468 <close+0x78>
81132464:	0005883a 	mov	r2,zero
81132468:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
8113246c:	e13fff17 	ldw	r4,-4(fp)
81132470:	11339d40 	call	811339d4 <alt_release_fd>
    if (rval < 0)
81132474:	e0bffe17 	ldw	r2,-8(fp)
81132478:	1000070e 	bge	r2,zero,81132498 <close+0xa8>
    {
      ALT_ERRNO = -rval;
8113247c:	11323ac0 	call	811323ac <alt_get_errno>
81132480:	1007883a 	mov	r3,r2
81132484:	e0bffe17 	ldw	r2,-8(fp)
81132488:	0085c83a 	sub	r2,zero,r2
8113248c:	18800015 	stw	r2,0(r3)
      return -1;
81132490:	00bfffc4 	movi	r2,-1
81132494:	00000706 	br	811324b4 <close+0xc4>
    }
    return 0;
81132498:	0005883a 	mov	r2,zero
8113249c:	00000506 	br	811324b4 <close+0xc4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
811324a0:	11323ac0 	call	811323ac <alt_get_errno>
811324a4:	1007883a 	mov	r3,r2
811324a8:	00801444 	movi	r2,81
811324ac:	18800015 	stw	r2,0(r3)
    return -1;
811324b0:	00bfffc4 	movi	r2,-1
  }
}
811324b4:	e037883a 	mov	sp,fp
811324b8:	dfc00117 	ldw	ra,4(sp)
811324bc:	df000017 	ldw	fp,0(sp)
811324c0:	dec00204 	addi	sp,sp,8
811324c4:	f800283a 	ret

811324c8 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
811324c8:	deffff04 	addi	sp,sp,-4
811324cc:	de00012e 	bgeu	sp,et,811324d4 <alt_dcache_flush_all+0xc>
811324d0:	003b68fa 	trap	3
811324d4:	df000015 	stw	fp,0(sp)
811324d8:	d839883a 	mov	fp,sp
  for (i = (char*) 0; i < (char*) NIOS2_DCACHE_SIZE; i+= NIOS2_DCACHE_LINE_SIZE)
  { 
    __asm__ volatile ("flushd (%0)" :: "r" (i));
  }
#endif /* NIOS2_DCACHE_SIZE > 0 */
}
811324dc:	0001883a 	nop
811324e0:	e037883a 	mov	sp,fp
811324e4:	df000017 	ldw	fp,0(sp)
811324e8:	dec00104 	addi	sp,sp,4
811324ec:	f800283a 	ret

811324f0 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
811324f0:	defffc04 	addi	sp,sp,-16
811324f4:	de00012e 	bgeu	sp,et,811324fc <alt_dev_null_write+0xc>
811324f8:	003b68fa 	trap	3
811324fc:	df000315 	stw	fp,12(sp)
81132500:	df000304 	addi	fp,sp,12
81132504:	e13ffd15 	stw	r4,-12(fp)
81132508:	e17ffe15 	stw	r5,-8(fp)
8113250c:	e1bfff15 	stw	r6,-4(fp)
  return len;
81132510:	e0bfff17 	ldw	r2,-4(fp)
}
81132514:	e037883a 	mov	sp,fp
81132518:	df000017 	ldw	fp,0(sp)
8113251c:	dec00104 	addi	sp,sp,4
81132520:	f800283a 	ret

81132524 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81132524:	defffe04 	addi	sp,sp,-8
81132528:	de00012e 	bgeu	sp,et,81132530 <alt_get_errno+0xc>
8113252c:	003b68fa 	trap	3
81132530:	dfc00115 	stw	ra,4(sp)
81132534:	df000015 	stw	fp,0(sp)
81132538:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
8113253c:	d0a01017 	ldw	r2,-32704(gp)
81132540:	10000326 	beq	r2,zero,81132550 <alt_get_errno+0x2c>
81132544:	d0a01017 	ldw	r2,-32704(gp)
81132548:	103ee83a 	callr	r2
8113254c:	00000106 	br	81132554 <alt_get_errno+0x30>
81132550:	d0a07404 	addi	r2,gp,-32304
}
81132554:	e037883a 	mov	sp,fp
81132558:	dfc00117 	ldw	ra,4(sp)
8113255c:	df000017 	ldw	fp,0(sp)
81132560:	dec00204 	addi	sp,sp,8
81132564:	f800283a 	ret

81132568 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
81132568:	defffb04 	addi	sp,sp,-20
8113256c:	de00012e 	bgeu	sp,et,81132574 <fstat+0xc>
81132570:	003b68fa 	trap	3
81132574:	dfc00415 	stw	ra,16(sp)
81132578:	df000315 	stw	fp,12(sp)
8113257c:	df000304 	addi	fp,sp,12
81132580:	e13ffe15 	stw	r4,-8(fp)
81132584:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132588:	e0bffe17 	ldw	r2,-8(fp)
8113258c:	10000616 	blt	r2,zero,811325a8 <fstat+0x40>
81132590:	e0bffe17 	ldw	r2,-8(fp)
81132594:	10c00324 	muli	r3,r2,12
81132598:	00a04574 	movhi	r2,33045
8113259c:	10b56a04 	addi	r2,r2,-10840
811325a0:	1885883a 	add	r2,r3,r2
811325a4:	00000106 	br	811325ac <fstat+0x44>
811325a8:	0005883a 	mov	r2,zero
811325ac:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
811325b0:	e0bffd17 	ldw	r2,-12(fp)
811325b4:	10001026 	beq	r2,zero,811325f8 <fstat+0x90>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
811325b8:	e0bffd17 	ldw	r2,-12(fp)
811325bc:	10800017 	ldw	r2,0(r2)
811325c0:	10800817 	ldw	r2,32(r2)
811325c4:	10000726 	beq	r2,zero,811325e4 <fstat+0x7c>
    {
      return fd->dev->fstat(fd, st);
811325c8:	e0bffd17 	ldw	r2,-12(fp)
811325cc:	10800017 	ldw	r2,0(r2)
811325d0:	10800817 	ldw	r2,32(r2)
811325d4:	e17fff17 	ldw	r5,-4(fp)
811325d8:	e13ffd17 	ldw	r4,-12(fp)
811325dc:	103ee83a 	callr	r2
811325e0:	00000a06 	br	8113260c <fstat+0xa4>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
811325e4:	e0bfff17 	ldw	r2,-4(fp)
811325e8:	00c80004 	movi	r3,8192
811325ec:	10c00115 	stw	r3,4(r2)
      return 0;
811325f0:	0005883a 	mov	r2,zero
811325f4:	00000506 	br	8113260c <fstat+0xa4>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
811325f8:	11325240 	call	81132524 <alt_get_errno>
811325fc:	1007883a 	mov	r3,r2
81132600:	00801444 	movi	r2,81
81132604:	18800015 	stw	r2,0(r3)
    return -1;
81132608:	00bfffc4 	movi	r2,-1
  }
}
8113260c:	e037883a 	mov	sp,fp
81132610:	dfc00117 	ldw	ra,4(sp)
81132614:	df000017 	ldw	fp,0(sp)
81132618:	dec00204 	addi	sp,sp,8
8113261c:	f800283a 	ret

81132620 <alt_irq_register>:
 */
 
int alt_irq_register (alt_u32 id, 
                      void* context, 
                      alt_isr_func handler)
{
81132620:	defff004 	addi	sp,sp,-64
81132624:	de00012e 	bgeu	sp,et,8113262c <alt_irq_register+0xc>
81132628:	003b68fa 	trap	3
8113262c:	df000f15 	stw	fp,60(sp)
81132630:	df000f04 	addi	fp,sp,60
81132634:	e13ffd15 	stw	r4,-12(fp)
81132638:	e17ffe15 	stw	r5,-8(fp)
8113263c:	e1bfff15 	stw	r6,-4(fp)
  int rc = -EINVAL;  
81132640:	00bffa84 	movi	r2,-22
81132644:	e0bff115 	stw	r2,-60(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
81132648:	e0bffd17 	ldw	r2,-12(fp)
8113264c:	10800828 	cmpgeui	r2,r2,32
81132650:	1000501e 	bne	r2,zero,81132794 <alt_irq_register+0x174>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132654:	0005303a 	rdctl	r2,status
81132658:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113265c:	e0fff617 	ldw	r3,-40(fp)
81132660:	00bfff84 	movi	r2,-2
81132664:	1884703a 	and	r2,r3,r2
81132668:	1001703a 	wrctl	status,r2
  
  return context;
8113266c:	e0bff617 	ldw	r2,-40(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all ();
81132670:	e0bff315 	stw	r2,-52(fp)

    alt_irq[id].handler = handler;
81132674:	00a045f4 	movhi	r2,33047
81132678:	10a28504 	addi	r2,r2,-30188
8113267c:	e0fffd17 	ldw	r3,-12(fp)
81132680:	180690fa 	slli	r3,r3,3
81132684:	10c5883a 	add	r2,r2,r3
81132688:	e0ffff17 	ldw	r3,-4(fp)
8113268c:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = context;
81132690:	00a045f4 	movhi	r2,33047
81132694:	10a28504 	addi	r2,r2,-30188
81132698:	e0fffd17 	ldw	r3,-12(fp)
8113269c:	180690fa 	slli	r3,r3,3
811326a0:	10c5883a 	add	r2,r2,r3
811326a4:	10800104 	addi	r2,r2,4
811326a8:	e0fffe17 	ldw	r3,-8(fp)
811326ac:	10c00015 	stw	r3,0(r2)

    rc = (handler) ? alt_irq_enable (id): alt_irq_disable (id);
811326b0:	e0bfff17 	ldw	r2,-4(fp)
811326b4:	10001926 	beq	r2,zero,8113271c <alt_irq_register+0xfc>
811326b8:	e0bffd17 	ldw	r2,-12(fp)
811326bc:	e0bff215 	stw	r2,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811326c0:	0005303a 	rdctl	r2,status
811326c4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811326c8:	e0fff717 	ldw	r3,-36(fp)
811326cc:	00bfff84 	movi	r2,-2
811326d0:	1884703a 	and	r2,r3,r2
811326d4:	1001703a 	wrctl	status,r2
  
  return context;
811326d8:	e0bff717 	ldw	r2,-36(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811326dc:	e0bff815 	stw	r2,-32(fp)

  alt_irq_active |= (1 << id);
811326e0:	00c00044 	movi	r3,1
811326e4:	e0bff217 	ldw	r2,-56(fp)
811326e8:	1884983a 	sll	r2,r3,r2
811326ec:	1007883a 	mov	r3,r2
811326f0:	d0a07c17 	ldw	r2,-32272(gp)
811326f4:	1884b03a 	or	r2,r3,r2
811326f8:	d0a07c15 	stw	r2,-32272(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
811326fc:	d0a07c17 	ldw	r2,-32272(gp)
81132700:	100170fa 	wrctl	ienable,r2
81132704:	e0bff817 	ldw	r2,-32(fp)
81132708:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113270c:	e0bff917 	ldw	r2,-28(fp)
81132710:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81132714:	0005883a 	mov	r2,zero
81132718:	00001906 	br	81132780 <alt_irq_register+0x160>
8113271c:	e0bffd17 	ldw	r2,-12(fp)
81132720:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81132724:	0005303a 	rdctl	r2,status
81132728:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113272c:	e0fffa17 	ldw	r3,-24(fp)
81132730:	00bfff84 	movi	r2,-2
81132734:	1884703a 	and	r2,r3,r2
81132738:	1001703a 	wrctl	status,r2
  
  return context;
8113273c:	e0bffa17 	ldw	r2,-24(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81132740:	e0bffb15 	stw	r2,-20(fp)

  alt_irq_active &= ~(1 << id);
81132744:	00c00044 	movi	r3,1
81132748:	e0bff417 	ldw	r2,-48(fp)
8113274c:	1884983a 	sll	r2,r3,r2
81132750:	0084303a 	nor	r2,zero,r2
81132754:	1007883a 	mov	r3,r2
81132758:	d0a07c17 	ldw	r2,-32272(gp)
8113275c:	1884703a 	and	r2,r3,r2
81132760:	d0a07c15 	stw	r2,-32272(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81132764:	d0a07c17 	ldw	r2,-32272(gp)
81132768:	100170fa 	wrctl	ienable,r2
8113276c:	e0bffb17 	ldw	r2,-20(fp)
81132770:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81132774:	e0bffc17 	ldw	r2,-16(fp)
81132778:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8113277c:	0005883a 	mov	r2,zero
81132780:	e0bff115 	stw	r2,-60(fp)
81132784:	e0bff317 	ldw	r2,-52(fp)
81132788:	e0bff515 	stw	r2,-44(fp)
8113278c:	e0bff517 	ldw	r2,-44(fp)
81132790:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }
  return rc; 
81132794:	e0bff117 	ldw	r2,-60(fp)
}
81132798:	e037883a 	mov	sp,fp
8113279c:	df000017 	ldw	fp,0(sp)
811327a0:	dec00104 	addi	sp,sp,4
811327a4:	f800283a 	ret

811327a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811327a8:	defffe04 	addi	sp,sp,-8
811327ac:	de00012e 	bgeu	sp,et,811327b4 <alt_get_errno+0xc>
811327b0:	003b68fa 	trap	3
811327b4:	dfc00115 	stw	ra,4(sp)
811327b8:	df000015 	stw	fp,0(sp)
811327bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811327c0:	d0a01017 	ldw	r2,-32704(gp)
811327c4:	10000326 	beq	r2,zero,811327d4 <alt_get_errno+0x2c>
811327c8:	d0a01017 	ldw	r2,-32704(gp)
811327cc:	103ee83a 	callr	r2
811327d0:	00000106 	br	811327d8 <alt_get_errno+0x30>
811327d4:	d0a07404 	addi	r2,gp,-32304
}
811327d8:	e037883a 	mov	sp,fp
811327dc:	dfc00117 	ldw	ra,4(sp)
811327e0:	df000017 	ldw	fp,0(sp)
811327e4:	dec00204 	addi	sp,sp,8
811327e8:	f800283a 	ret

811327ec <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
811327ec:	deffed04 	addi	sp,sp,-76
811327f0:	de00012e 	bgeu	sp,et,811327f8 <isatty+0xc>
811327f4:	003b68fa 	trap	3
811327f8:	dfc01215 	stw	ra,72(sp)
811327fc:	df001115 	stw	fp,68(sp)
81132800:	df001104 	addi	fp,sp,68
81132804:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81132808:	e0bfff17 	ldw	r2,-4(fp)
8113280c:	10000616 	blt	r2,zero,81132828 <isatty+0x3c>
81132810:	e0bfff17 	ldw	r2,-4(fp)
81132814:	10c00324 	muli	r3,r2,12
81132818:	00a04574 	movhi	r2,33045
8113281c:	10b56a04 	addi	r2,r2,-10840
81132820:	1885883a 	add	r2,r3,r2
81132824:	00000106 	br	8113282c <isatty+0x40>
81132828:	0005883a 	mov	r2,zero
8113282c:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
81132830:	e0bfef17 	ldw	r2,-68(fp)
81132834:	10000e26 	beq	r2,zero,81132870 <isatty+0x84>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
81132838:	e0bfef17 	ldw	r2,-68(fp)
8113283c:	10800017 	ldw	r2,0(r2)
81132840:	10800817 	ldw	r2,32(r2)
81132844:	1000021e 	bne	r2,zero,81132850 <isatty+0x64>
    {
      return 1;
81132848:	00800044 	movi	r2,1
8113284c:	00000d06 	br	81132884 <isatty+0x98>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
81132850:	e0bff004 	addi	r2,fp,-64
81132854:	100b883a 	mov	r5,r2
81132858:	e13fff17 	ldw	r4,-4(fp)
8113285c:	11325680 	call	81132568 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
81132860:	e0bff117 	ldw	r2,-60(fp)
81132864:	10880020 	cmpeqi	r2,r2,8192
81132868:	10803fcc 	andi	r2,r2,255
8113286c:	00000506 	br	81132884 <isatty+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
81132870:	11327a80 	call	811327a8 <alt_get_errno>
81132874:	1007883a 	mov	r3,r2
81132878:	00801444 	movi	r2,81
8113287c:	18800015 	stw	r2,0(r3)
    return 0;
81132880:	0005883a 	mov	r2,zero
  }
}
81132884:	e037883a 	mov	sp,fp
81132888:	dfc00117 	ldw	ra,4(sp)
8113288c:	df000017 	ldw	fp,0(sp)
81132890:	dec00204 	addi	sp,sp,8
81132894:	f800283a 	ret

81132898 <tx_log_str>:
	#include "sys/alt_log_printf.h"

        .global tx_log_str
tx_log_str:
	/* load base uart / jtag uart address into r6 */
	movhi r6, %hiadj(ALT_LOG_PORT_BASE)
81132898:	01a04834 	movhi	r6,33056
	addi r6, r6, %lo(ALT_LOG_PORT_BASE)
8113289c:	318c2404 	addi	r6,r6,12432

811328a0 <tx_next_char>:
tx_next_char:
        /* if pointer points to null, return 
         * r4 is the pointer to the str to be printed, set by ALT_LOG_PUTS */
	ldb r7, (r4)
811328a0:	21c00007 	ldb	r7,0(r4)
	beq r0, r7, end_tx
811328a4:	01c00826 	beq	zero,r7,811328c8 <end_tx>

811328a8 <wait_tx_ready_loop>:

	/* check device transmit ready  */
wait_tx_ready_loop:
        ldwio   r8, ALT_LOG_PRINT_REG_OFFSET(r6)
811328a8:	32000137 	ldwio	r8,4(r6)
        /*UART, ALT_LOG_PRINT_MSK == 0x40
          JTAG UART, ALT_LOG_PRINT_MSK == 0xFFFF0000 */
        andhi   r5, r8, %hi(ALT_LOG_PRINT_MSK)
811328ac:	417fffec 	andhi	r5,r8,65535
        andi    r8, r8, %lo(ALT_LOG_PRINT_MSK)
811328b0:	4200000c 	andi	r8,r8,0
        or      r5, r5, r8
811328b4:	2a0ab03a 	or	r5,r5,r8
        beq     r5, r0, wait_tx_ready_loop	
811328b8:	283ffb26 	beq	r5,zero,811328a8 <__reset+0xfb1128a8>
	/* write char */
	stwio   r7, ALT_LOG_PRINT_TXDATA_REG_OFFSET (r6)		
811328bc:	31c00035 	stwio	r7,0(r6)
	/* advance string pointer */
	addi r4, r4, 1
811328c0:	21000044 	addi	r4,r4,1
	br tx_next_char
811328c4:	003ff606 	br	811328a0 <__reset+0xfb1128a0>

811328c8 <end_tx>:
end_tx:	
        ret
811328c8:	f800283a 	ret

811328cc <alt_log_txchar>:



/* Function to put one char onto the UART/JTAG UART txdata register. */
void alt_log_txchar(int c,char *base)
{
811328cc:	defffd04 	addi	sp,sp,-12
811328d0:	de00012e 	bgeu	sp,et,811328d8 <alt_log_txchar+0xc>
811328d4:	003b68fa 	trap	3
811328d8:	df000215 	stw	fp,8(sp)
811328dc:	df000204 	addi	fp,sp,8
811328e0:	e13ffe15 	stw	r4,-8(fp)
811328e4:	e17fff15 	stw	r5,-4(fp)
  /* Wait until the device is ready for a character */
  while((ALT_LOG_PRINT_REG_RD(base) & ALT_LOG_PRINT_MSK) == 0)
811328e8:	0001883a 	nop
811328ec:	e0bfff17 	ldw	r2,-4(fp)
811328f0:	10800104 	addi	r2,r2,4
811328f4:	10800037 	ldwio	r2,0(r2)
811328f8:	10bfffec 	andhi	r2,r2,65535
811328fc:	103ffb26 	beq	r2,zero,811328ec <__reset+0xfb1128ec>
    ;
  /* And pop the character into the register */
  ALT_LOG_PRINT_TXDATA_WR(base,c);
81132900:	e0bfff17 	ldw	r2,-4(fp)
81132904:	e0fffe17 	ldw	r3,-8(fp)
81132908:	10c00035 	stwio	r3,0(r2)
}
8113290c:	0001883a 	nop
81132910:	e037883a 	mov	sp,fp
81132914:	df000017 	ldw	fp,0(sp)
81132918:	dec00104 	addi	sp,sp,4
8113291c:	f800283a 	ret

81132920 <alt_log_repchar>:


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
81132920:	defffb04 	addi	sp,sp,-20
81132924:	de00012e 	bgeu	sp,et,8113292c <alt_log_repchar+0xc>
81132928:	003b68fa 	trap	3
8113292c:	dfc00415 	stw	ra,16(sp)
81132930:	df000315 	stw	fp,12(sp)
81132934:	df000304 	addi	fp,sp,12
81132938:	2005883a 	mov	r2,r4
8113293c:	e17ffe15 	stw	r5,-8(fp)
81132940:	e1bfff15 	stw	r6,-4(fp)
81132944:	e0bffd05 	stb	r2,-12(fp)
  while(r-- > 0)
81132948:	00000506 	br	81132960 <alt_log_repchar+0x40>
    alt_log_txchar(c,(char*) base);
8113294c:	e0bffd07 	ldb	r2,-12(fp)
81132950:	e0ffff17 	ldw	r3,-4(fp)
81132954:	180b883a 	mov	r5,r3
81132958:	1009883a 	mov	r4,r2
8113295c:	11328cc0 	call	811328cc <alt_log_txchar>


/* Called by alt_log_private_printf to print out characters repeatedly */
void alt_log_repchar(char c,int r,int base)
{
  while(r-- > 0)
81132960:	e0bffe17 	ldw	r2,-8(fp)
81132964:	10ffffc4 	addi	r3,r2,-1
81132968:	e0fffe15 	stw	r3,-8(fp)
8113296c:	00bff716 	blt	zero,r2,8113294c <__reset+0xfb11294c>
    alt_log_txchar(c,(char*) base);
}
81132970:	0001883a 	nop
81132974:	e037883a 	mov	sp,fp
81132978:	dfc00117 	ldw	ra,4(sp)
8113297c:	df000017 	ldw	fp,0(sp)
81132980:	dec00204 	addi	sp,sp,8
81132984:	f800283a 	ret

81132988 <alt_log_private_printf>:


/* Stripped down printf function */
void alt_log_private_printf(const char *fmt,int base,va_list args)
  {
81132988:	deffe904 	addi	sp,sp,-92
8113298c:	de00012e 	bgeu	sp,et,81132994 <alt_log_private_printf+0xc>
81132990:	003b68fa 	trap	3
81132994:	dfc01615 	stw	ra,88(sp)
81132998:	df001515 	stw	fp,84(sp)
8113299c:	dc001415 	stw	r16,80(sp)
811329a0:	df001504 	addi	fp,sp,84
811329a4:	e13ffc15 	stw	r4,-16(fp)
811329a8:	e17ffd15 	stw	r5,-12(fp)
811329ac:	e1bffe15 	stw	r6,-8(fp)
  const char *w;
  char c;
  int state;
  int fmtLeadingZero = 0; /* init these all to 0 for -W warnings. */
811329b0:	e03fed15 	stw	zero,-76(fp)
  int fmtLong = 0;
811329b4:	e03fee15 	stw	zero,-72(fp)
  int fmtBeforeDecimal = 0;
811329b8:	e03fef15 	stw	zero,-68(fp)
  int fmtAfterDecimal = 0;
811329bc:	e03ff015 	stw	zero,-64(fp)
  int fmtBase = 0;
811329c0:	e03ff115 	stw	zero,-60(fp)
  int fmtSigned = 0;
811329c4:	e03ff215 	stw	zero,-56(fp)
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */
811329c8:	e03ff315 	stw	zero,-52(fp)

  w = fmt;
811329cc:	e0bffc17 	ldw	r2,-16(fp)
811329d0:	e0bfeb15 	stw	r2,-84(fp)
  state = pfState_chars;
811329d4:	e03fec15 	stw	zero,-80(fp)

  while(0 != (c = *w++))
811329d8:	00014b06 	br	81132f08 <alt_log_private_printf+0x580>
    {
    switch(state)
811329dc:	e0bfec17 	ldw	r2,-80(fp)
811329e0:	10c00060 	cmpeqi	r3,r2,1
811329e4:	18001b1e 	bne	r3,zero,81132a54 <alt_log_private_printf+0xcc>
811329e8:	10c000a0 	cmpeqi	r3,r2,2
811329ec:	18002d1e 	bne	r3,zero,81132aa4 <alt_log_private_printf+0x11c>
811329f0:	10000126 	beq	r2,zero,811329f8 <alt_log_private_printf+0x70>
811329f4:	00014406 	br	81132f08 <alt_log_private_printf+0x580>
      {
      case pfState_chars:
        if(c == '%')
811329f8:	e0bffb07 	ldb	r2,-20(fp)
811329fc:	10800958 	cmpnei	r2,r2,37
81132a00:	10000e1e 	bne	r2,zero,81132a3c <alt_log_private_printf+0xb4>
        {
          fmtLeadingZero = 0;
81132a04:	e03fed15 	stw	zero,-76(fp)
          fmtLong = 0;
81132a08:	e03fee15 	stw	zero,-72(fp)
          fmtBase = 10;
81132a0c:	00800284 	movi	r2,10
81132a10:	e0bff115 	stw	r2,-60(fp)
          fmtSigned = 1;
81132a14:	00800044 	movi	r2,1
81132a18:	e0bff215 	stw	r2,-56(fp)
          fmtCase = 0; /* Only %X sets this. */
81132a1c:	e03ff315 	stw	zero,-52(fp)
          fmtBeforeDecimal = -1;
81132a20:	00bfffc4 	movi	r2,-1
81132a24:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = -1;
81132a28:	00bfffc4 	movi	r2,-1
81132a2c:	e0bff015 	stw	r2,-64(fp)
          state = pfState_firstFmtChar;
81132a30:	00800044 	movi	r2,1
81132a34:	e0bfec15 	stw	r2,-80(fp)
81132a38:	00013306 	br	81132f08 <alt_log_private_printf+0x580>
        }
        else
        {
          alt_log_txchar(c,(char*)base);
81132a3c:	e0bffb07 	ldb	r2,-20(fp)
81132a40:	e0fffd17 	ldw	r3,-12(fp)
81132a44:	180b883a 	mov	r5,r3
81132a48:	1009883a 	mov	r4,r2
81132a4c:	11328cc0 	call	811328cc <alt_log_txchar>
        }
        break;
81132a50:	00012d06 	br	81132f08 <alt_log_private_printf+0x580>

      case pfState_firstFmtChar:
        if(c == '0')
81132a54:	e0bffb07 	ldb	r2,-20(fp)
81132a58:	10800c18 	cmpnei	r2,r2,48
81132a5c:	1000051e 	bne	r2,zero,81132a74 <alt_log_private_printf+0xec>
        {
          fmtLeadingZero = 1;
81132a60:	00800044 	movi	r2,1
81132a64:	e0bfed15 	stw	r2,-76(fp)
          state = pfState_otherFmtChar;
81132a68:	00800084 	movi	r2,2
81132a6c:	e0bfec15 	stw	r2,-80(fp)
81132a70:	00012506 	br	81132f08 <alt_log_private_printf+0x580>
        }
        else if(c == '%')
81132a74:	e0bffb07 	ldb	r2,-20(fp)
81132a78:	10800958 	cmpnei	r2,r2,37
81132a7c:	1000071e 	bne	r2,zero,81132a9c <alt_log_private_printf+0x114>
        {
          alt_log_txchar(c,(char*)base);
81132a80:	e0bffb07 	ldb	r2,-20(fp)
81132a84:	e0fffd17 	ldw	r3,-12(fp)
81132a88:	180b883a 	mov	r5,r3
81132a8c:	1009883a 	mov	r4,r2
81132a90:	11328cc0 	call	811328cc <alt_log_txchar>
          state = pfState_chars;
81132a94:	e03fec15 	stw	zero,-80(fp)
81132a98:	00011b06 	br	81132f08 <alt_log_private_printf+0x580>
        }
        else
        {
          state = pfState_otherFmtChar;
81132a9c:	00800084 	movi	r2,2
81132aa0:	e0bfec15 	stw	r2,-80(fp)
        }
        break;

      case pfState_otherFmtChar:
otherFmtChar:
        if(c == '.')
81132aa4:	e0bffb07 	ldb	r2,-20(fp)
81132aa8:	10800b98 	cmpnei	r2,r2,46
81132aac:	1000021e 	bne	r2,zero,81132ab8 <alt_log_private_printf+0x130>
        {
          fmtAfterDecimal = 0;
81132ab0:	e03ff015 	stw	zero,-64(fp)
81132ab4:	00011306 	br	81132f04 <alt_log_private_printf+0x57c>
        }
        else if('0' <= c && c <= '9')
81132ab8:	e0bffb07 	ldb	r2,-20(fp)
81132abc:	10800c10 	cmplti	r2,r2,48
81132ac0:	10001a1e 	bne	r2,zero,81132b2c <alt_log_private_printf+0x1a4>
81132ac4:	e0bffb07 	ldb	r2,-20(fp)
81132ac8:	10800e88 	cmpgei	r2,r2,58
81132acc:	1000171e 	bne	r2,zero,81132b2c <alt_log_private_printf+0x1a4>
        {
          c -= '0';
81132ad0:	e0bffb03 	ldbu	r2,-20(fp)
81132ad4:	10bff404 	addi	r2,r2,-48
81132ad8:	e0bffb05 	stb	r2,-20(fp)
          if(fmtAfterDecimal < 0)     /* still before decimal */
81132adc:	e0bff017 	ldw	r2,-64(fp)
81132ae0:	10000c0e 	bge	r2,zero,81132b14 <alt_log_private_printf+0x18c>
          {
            if(fmtBeforeDecimal < 0)
81132ae4:	e0bfef17 	ldw	r2,-68(fp)
81132ae8:	1000020e 	bge	r2,zero,81132af4 <alt_log_private_printf+0x16c>
            {
              fmtBeforeDecimal = 0;
81132aec:	e03fef15 	stw	zero,-68(fp)
81132af0:	00000306 	br	81132b00 <alt_log_private_printf+0x178>
            }
            else
            {
              fmtBeforeDecimal *= 10;
81132af4:	e0bfef17 	ldw	r2,-68(fp)
81132af8:	108002a4 	muli	r2,r2,10
81132afc:	e0bfef15 	stw	r2,-68(fp)
            }
            fmtBeforeDecimal += c;
81132b00:	e0bffb07 	ldb	r2,-20(fp)
81132b04:	e0ffef17 	ldw	r3,-68(fp)
81132b08:	1885883a 	add	r2,r3,r2
81132b0c:	e0bfef15 	stw	r2,-68(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81132b10:	0000fc06 	br	81132f04 <alt_log_private_printf+0x57c>
            }
            fmtBeforeDecimal += c;
          }
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
81132b14:	e0bff017 	ldw	r2,-64(fp)
81132b18:	10c002a4 	muli	r3,r2,10
81132b1c:	e0bffb07 	ldb	r2,-20(fp)
81132b20:	1885883a 	add	r2,r3,r2
81132b24:	e0bff015 	stw	r2,-64(fp)
          fmtAfterDecimal = 0;
        }
        else if('0' <= c && c <= '9')
        {
          c -= '0';
          if(fmtAfterDecimal < 0)     /* still before decimal */
81132b28:	0000f606 	br	81132f04 <alt_log_private_printf+0x57c>
          else
          {
            fmtAfterDecimal = (fmtAfterDecimal * 10) + c;
          }
        }
        else if(c == 'l')
81132b2c:	e0bffb07 	ldb	r2,-20(fp)
81132b30:	10801b18 	cmpnei	r2,r2,108
81132b34:	1000031e 	bne	r2,zero,81132b44 <alt_log_private_printf+0x1bc>
        {
          fmtLong = 1;
81132b38:	00800044 	movi	r2,1
81132b3c:	e0bfee15 	stw	r2,-72(fp)
81132b40:	0000f006 	br	81132f04 <alt_log_private_printf+0x57c>
        }
        else                  /* we're up to the letter which determines type */
        {
          switch(c)
81132b44:	e0bffb07 	ldb	r2,-20(fp)
81132b48:	10bfea04 	addi	r2,r2,-88
81132b4c:	10c00868 	cmpgeui	r3,r2,33
81132b50:	1800eb1e 	bne	r3,zero,81132f00 <alt_log_private_printf+0x578>
81132b54:	100690ba 	slli	r3,r2,2
81132b58:	00a044f4 	movhi	r2,33043
81132b5c:	108adb04 	addi	r2,r2,11116
81132b60:	1885883a 	add	r2,r3,r2
81132b64:	10800017 	ldw	r2,0(r2)
81132b68:	1000683a 	jmp	r2
81132b6c:	81132e2c 	andhi	r4,r16,19640
81132b70:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b74:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b78:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b7c:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b80:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b84:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b88:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b8c:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b90:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b94:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132b98:	81132e44 	addi	r4,r16,19641
81132b9c:	81132bf0 	cmpltui	r4,r16,19631
81132ba0:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132ba4:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132ba8:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bac:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bb0:	81132bf0 	cmpltui	r4,r16,19631
81132bb4:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bb8:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bbc:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bc0:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bc4:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bc8:	81132e0c 	andi	r4,r16,19640
81132bcc:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bd0:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bd4:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bd8:	81132e80 	call	881132e8 <__reset+0x20f32e8>
81132bdc:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132be0:	81132e04 	addi	r4,r16,19640
81132be4:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132be8:	81132f00 	call	881132f0 <__reset+0x20f32f0>
81132bec:	81132e1c 	xori	r4,r16,19640
                unsigned long vShrink;  /* used to count digits */
                int sign;
                int digitCount;

                /* Get the value */
                if(fmtLong)
81132bf0:	e0bfee17 	ldw	r2,-72(fp)
81132bf4:	10000e26 	beq	r2,zero,81132c30 <alt_log_private_printf+0x2a8>
                {
                  if (fmtSigned)
81132bf8:	e0bff217 	ldw	r2,-56(fp)
81132bfc:	10000626 	beq	r2,zero,81132c18 <alt_log_private_printf+0x290>
                  {
                    v = va_arg(args,long);
81132c00:	e0bffe17 	ldw	r2,-8(fp)
81132c04:	10c00104 	addi	r3,r2,4
81132c08:	e0fffe15 	stw	r3,-8(fp)
81132c0c:	10800017 	ldw	r2,0(r2)
81132c10:	e0bff415 	stw	r2,-48(fp)
81132c14:	00001306 	br	81132c64 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned long);
81132c18:	e0bffe17 	ldw	r2,-8(fp)
81132c1c:	10c00104 	addi	r3,r2,4
81132c20:	e0fffe15 	stw	r3,-8(fp)
81132c24:	10800017 	ldw	r2,0(r2)
81132c28:	e0bff415 	stw	r2,-48(fp)
81132c2c:	00000d06 	br	81132c64 <alt_log_private_printf+0x2dc>
                  }
                }
                else
                {
                  if (fmtSigned)
81132c30:	e0bff217 	ldw	r2,-56(fp)
81132c34:	10000626 	beq	r2,zero,81132c50 <alt_log_private_printf+0x2c8>
                  {
                    v = va_arg(args,int);
81132c38:	e0bffe17 	ldw	r2,-8(fp)
81132c3c:	10c00104 	addi	r3,r2,4
81132c40:	e0fffe15 	stw	r3,-8(fp)
81132c44:	10800017 	ldw	r2,0(r2)
81132c48:	e0bff415 	stw	r2,-48(fp)
81132c4c:	00000506 	br	81132c64 <alt_log_private_printf+0x2dc>
                  }
                  else
                  {
                    v = va_arg(args,unsigned int);
81132c50:	e0bffe17 	ldw	r2,-8(fp)
81132c54:	10c00104 	addi	r3,r2,4
81132c58:	e0fffe15 	stw	r3,-8(fp)
81132c5c:	10800017 	ldw	r2,0(r2)
81132c60:	e0bff415 	stw	r2,-48(fp)
                  }
                }

                /* Strip sign */
                sign = 0;
81132c64:	e03ff715 	stw	zero,-36(fp)
                  /* (assumes sign bit is #31) */
                if( fmtSigned && (v & (0x80000000)) )
81132c68:	e0bff217 	ldw	r2,-56(fp)
81132c6c:	10000726 	beq	r2,zero,81132c8c <alt_log_private_printf+0x304>
81132c70:	e0bff417 	ldw	r2,-48(fp)
81132c74:	1000050e 	bge	r2,zero,81132c8c <alt_log_private_printf+0x304>
                  {
                  v = ~v + 1;
81132c78:	e0bff417 	ldw	r2,-48(fp)
81132c7c:	0085c83a 	sub	r2,zero,r2
81132c80:	e0bff415 	stw	r2,-48(fp)
                  sign = 1;
81132c84:	00800044 	movi	r2,1
81132c88:	e0bff715 	stw	r2,-36(fp)
                  }

                /* Count digits, and get largest place value */
                vShrink = v;
81132c8c:	e0bff417 	ldw	r2,-48(fp)
81132c90:	e0bff615 	stw	r2,-40(fp)
                p = 1;
81132c94:	00800044 	movi	r2,1
81132c98:	e0bff515 	stw	r2,-44(fp)
                digitCount = 1;
81132c9c:	00800044 	movi	r2,1
81132ca0:	e0bff815 	stw	r2,-32(fp)
                while( (vShrink = vShrink / fmtBase) > 0 )
81132ca4:	00000706 	br	81132cc4 <alt_log_private_printf+0x33c>
                  {
                  digitCount++;
81132ca8:	e0bff817 	ldw	r2,-32(fp)
81132cac:	10800044 	addi	r2,r2,1
81132cb0:	e0bff815 	stw	r2,-32(fp)
                  p *= fmtBase;
81132cb4:	e0bff117 	ldw	r2,-60(fp)
81132cb8:	e0fff517 	ldw	r3,-44(fp)
81132cbc:	1885383a 	mul	r2,r3,r2
81132cc0:	e0bff515 	stw	r2,-44(fp)

                /* Count digits, and get largest place value */
                vShrink = v;
                p = 1;
                digitCount = 1;
                while( (vShrink = vShrink / fmtBase) > 0 )
81132cc4:	e0bff117 	ldw	r2,-60(fp)
81132cc8:	e0fff617 	ldw	r3,-40(fp)
81132ccc:	1885203a 	divu	r2,r3,r2
81132cd0:	e0bff615 	stw	r2,-40(fp)
81132cd4:	e0bff617 	ldw	r2,-40(fp)
81132cd8:	103ff31e 	bne	r2,zero,81132ca8 <__reset+0xfb112ca8>
                  digitCount++;
                  p *= fmtBase;
                  }

                /* Print leading characters & sign */
                fmtBeforeDecimal -= digitCount;
81132cdc:	e0ffef17 	ldw	r3,-68(fp)
81132ce0:	e0bff817 	ldw	r2,-32(fp)
81132ce4:	1885c83a 	sub	r2,r3,r2
81132ce8:	e0bfef15 	stw	r2,-68(fp)
                if(fmtLeadingZero)
81132cec:	e0bfed17 	ldw	r2,-76(fp)
81132cf0:	10000e26 	beq	r2,zero,81132d2c <alt_log_private_printf+0x3a4>
                  {
                  if(sign)
81132cf4:	e0bff717 	ldw	r2,-36(fp)
81132cf8:	10000726 	beq	r2,zero,81132d18 <alt_log_private_printf+0x390>
                    {
                    alt_log_txchar('-',(char*)base);
81132cfc:	e0bffd17 	ldw	r2,-12(fp)
81132d00:	100b883a 	mov	r5,r2
81132d04:	01000b44 	movi	r4,45
81132d08:	11328cc0 	call	811328cc <alt_log_txchar>
                    fmtBeforeDecimal--;
81132d0c:	e0bfef17 	ldw	r2,-68(fp)
81132d10:	10bfffc4 	addi	r2,r2,-1
81132d14:	e0bfef15 	stw	r2,-68(fp)
                    }
                  alt_log_repchar('0',fmtBeforeDecimal,base);
81132d18:	e1bffd17 	ldw	r6,-12(fp)
81132d1c:	e17fef17 	ldw	r5,-68(fp)
81132d20:	01000c04 	movi	r4,48
81132d24:	11329200 	call	81132920 <alt_log_repchar>
81132d28:	00003206 	br	81132df4 <alt_log_private_printf+0x46c>
                  }
                else
                  {
                    if(sign)
81132d2c:	e0bff717 	ldw	r2,-36(fp)
81132d30:	10000326 	beq	r2,zero,81132d40 <alt_log_private_printf+0x3b8>
                    {
                      fmtBeforeDecimal--;
81132d34:	e0bfef17 	ldw	r2,-68(fp)
81132d38:	10bfffc4 	addi	r2,r2,-1
81132d3c:	e0bfef15 	stw	r2,-68(fp)
                    }
                    alt_log_repchar(' ',fmtBeforeDecimal,base);
81132d40:	e1bffd17 	ldw	r6,-12(fp)
81132d44:	e17fef17 	ldw	r5,-68(fp)
81132d48:	01000804 	movi	r4,32
81132d4c:	11329200 	call	81132920 <alt_log_repchar>
                    if(sign)
81132d50:	e0bff717 	ldw	r2,-36(fp)
81132d54:	10002726 	beq	r2,zero,81132df4 <alt_log_private_printf+0x46c>
                    {
                      alt_log_txchar('-',(char*)base);
81132d58:	e0bffd17 	ldw	r2,-12(fp)
81132d5c:	100b883a 	mov	r5,r2
81132d60:	01000b44 	movi	r4,45
81132d64:	11328cc0 	call	811328cc <alt_log_txchar>
                    }
                  }

                /* Print numbery parts */
                while(p)
81132d68:	00002206 	br	81132df4 <alt_log_private_printf+0x46c>
                  {
                  unsigned char d;

                  d = v / p;
81132d6c:	e0fff417 	ldw	r3,-48(fp)
81132d70:	e0bff517 	ldw	r2,-44(fp)
81132d74:	1885203a 	divu	r2,r3,r2
81132d78:	e0bff905 	stb	r2,-28(fp)
                  d += '0';
81132d7c:	e0bff903 	ldbu	r2,-28(fp)
81132d80:	10800c04 	addi	r2,r2,48
81132d84:	e0bff905 	stb	r2,-28(fp)
                  if(d > '9')
81132d88:	e0bff903 	ldbu	r2,-28(fp)
81132d8c:	10800eb0 	cmpltui	r2,r2,58
81132d90:	1000081e 	bne	r2,zero,81132db4 <alt_log_private_printf+0x42c>
                  {
                    d += (fmtCase ? 'A' : 'a') - '0' - 10;
81132d94:	e0bff317 	ldw	r2,-52(fp)
81132d98:	10000226 	beq	r2,zero,81132da4 <alt_log_private_printf+0x41c>
81132d9c:	008001c4 	movi	r2,7
81132da0:	00000106 	br	81132da8 <alt_log_private_printf+0x420>
81132da4:	008009c4 	movi	r2,39
81132da8:	e0fff903 	ldbu	r3,-28(fp)
81132dac:	10c5883a 	add	r2,r2,r3
81132db0:	e0bff905 	stb	r2,-28(fp)
                  }
                  alt_log_txchar(d,(char*)base);
81132db4:	e0bff903 	ldbu	r2,-28(fp)
81132db8:	e0fffd17 	ldw	r3,-12(fp)
81132dbc:	180b883a 	mov	r5,r3
81132dc0:	1009883a 	mov	r4,r2
81132dc4:	11328cc0 	call	811328cc <alt_log_txchar>

                  v = v % p;
81132dc8:	e0bff417 	ldw	r2,-48(fp)
81132dcc:	e0fff517 	ldw	r3,-44(fp)
81132dd0:	10c9203a 	divu	r4,r2,r3
81132dd4:	e0fff517 	ldw	r3,-44(fp)
81132dd8:	20c7383a 	mul	r3,r4,r3
81132ddc:	10c5c83a 	sub	r2,r2,r3
81132de0:	e0bff415 	stw	r2,-48(fp)
                  p = p / fmtBase;
81132de4:	e0bff117 	ldw	r2,-60(fp)
81132de8:	e0fff517 	ldw	r3,-44(fp)
81132dec:	1885203a 	divu	r2,r3,r2
81132df0:	e0bff515 	stw	r2,-44(fp)
                      alt_log_txchar('-',(char*)base);
                    }
                  }

                /* Print numbery parts */
                while(p)
81132df4:	e0bff517 	ldw	r2,-44(fp)
81132df8:	103fdc1e 	bne	r2,zero,81132d6c <__reset+0xfb112d6c>
                  v = v % p;
                  p = p / fmtBase;
                  }
                }

              state = pfState_chars;
81132dfc:	e03fec15 	stw	zero,-80(fp)
              break;
81132e00:	00003f06 	br	81132f00 <alt_log_private_printf+0x578>

            case 'u':
              fmtSigned = 0;
81132e04:	e03ff215 	stw	zero,-56(fp)
              goto doIntegerPrint;
81132e08:	003f7906 	br	81132bf0 <__reset+0xfb112bf0>
            case 'o':
              fmtSigned = 0;
81132e0c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 8;
81132e10:	00800204 	movi	r2,8
81132e14:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81132e18:	003f7506 	br	81132bf0 <__reset+0xfb112bf0>
            case 'x':
              fmtSigned = 0;
81132e1c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81132e20:	00800404 	movi	r2,16
81132e24:	e0bff115 	stw	r2,-60(fp)
              goto doIntegerPrint;
81132e28:	003f7106 	br	81132bf0 <__reset+0xfb112bf0>
            case 'X':
              fmtSigned = 0;
81132e2c:	e03ff215 	stw	zero,-56(fp)
              fmtBase = 16;
81132e30:	00800404 	movi	r2,16
81132e34:	e0bff115 	stw	r2,-60(fp)
              fmtCase = 1;
81132e38:	00800044 	movi	r2,1
81132e3c:	e0bff315 	stw	r2,-52(fp)
              goto doIntegerPrint;
81132e40:	003f6b06 	br	81132bf0 <__reset+0xfb112bf0>

            case 'c':
              alt_log_repchar(' ',fmtBeforeDecimal-1,base);
81132e44:	e0bfef17 	ldw	r2,-68(fp)
81132e48:	10bfffc4 	addi	r2,r2,-1
81132e4c:	e1bffd17 	ldw	r6,-12(fp)
81132e50:	100b883a 	mov	r5,r2
81132e54:	01000804 	movi	r4,32
81132e58:	11329200 	call	81132920 <alt_log_repchar>
              alt_log_txchar(va_arg(args,int),(char*)base);
81132e5c:	e0bffe17 	ldw	r2,-8(fp)
81132e60:	10c00104 	addi	r3,r2,4
81132e64:	e0fffe15 	stw	r3,-8(fp)
81132e68:	10800017 	ldw	r2,0(r2)
81132e6c:	e0fffd17 	ldw	r3,-12(fp)
81132e70:	180b883a 	mov	r5,r3
81132e74:	1009883a 	mov	r4,r2
81132e78:	11328cc0 	call	811328cc <alt_log_txchar>
              break;
81132e7c:	00002006 	br	81132f00 <alt_log_private_printf+0x578>

            case 's':
                {
                char *s;

                s = va_arg(args,char *);
81132e80:	e0bffe17 	ldw	r2,-8(fp)
81132e84:	10c00104 	addi	r3,r2,4
81132e88:	e0fffe15 	stw	r3,-8(fp)
81132e8c:	10800017 	ldw	r2,0(r2)
81132e90:	e0bffa15 	stw	r2,-24(fp)
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);
81132e94:	e43fef17 	ldw	r16,-68(fp)
81132e98:	e13ffa17 	ldw	r4,-24(fp)
81132e9c:	111e5bc0 	call	8111e5bc <strlen>
81132ea0:	8085c83a 	sub	r2,r16,r2
81132ea4:	e1bffd17 	ldw	r6,-12(fp)
81132ea8:	100b883a 	mov	r5,r2
81132eac:	01000804 	movi	r4,32
81132eb0:	11329200 	call	81132920 <alt_log_repchar>

                while(*s)
81132eb4:	00000b06 	br	81132ee4 <alt_log_private_printf+0x55c>
                  alt_log_txchar(*s++,(char*)base);
81132eb8:	e0bffa17 	ldw	r2,-24(fp)
81132ebc:	10c00044 	addi	r3,r2,1
81132ec0:	e0fffa15 	stw	r3,-24(fp)
81132ec4:	10800003 	ldbu	r2,0(r2)
81132ec8:	10803fcc 	andi	r2,r2,255
81132ecc:	1080201c 	xori	r2,r2,128
81132ed0:	10bfe004 	addi	r2,r2,-128
81132ed4:	e0fffd17 	ldw	r3,-12(fp)
81132ed8:	180b883a 	mov	r5,r3
81132edc:	1009883a 	mov	r4,r2
81132ee0:	11328cc0 	call	811328cc <alt_log_txchar>
                char *s;

                s = va_arg(args,char *);
                alt_log_repchar(' ',fmtBeforeDecimal-strlen(s),base);

                while(*s)
81132ee4:	e0bffa17 	ldw	r2,-24(fp)
81132ee8:	10800003 	ldbu	r2,0(r2)
81132eec:	10803fcc 	andi	r2,r2,255
81132ef0:	1080201c 	xori	r2,r2,128
81132ef4:	10bfe004 	addi	r2,r2,-128
81132ef8:	103fef1e 	bne	r2,zero,81132eb8 <__reset+0xfb112eb8>
                  alt_log_txchar(*s++,(char*)base);
                }
              break;
81132efc:	0001883a 	nop
            } /* switch last letter of fmt */
          state=pfState_chars;
81132f00:	e03fec15 	stw	zero,-80(fp)
          }
        break;
81132f04:	0001883a 	nop
  int fmtCase = 0; /* For hex format, if 1, A-F, else a-f. */

  w = fmt;
  state = pfState_chars;

  while(0 != (c = *w++))
81132f08:	e0bfeb17 	ldw	r2,-84(fp)
81132f0c:	10c00044 	addi	r3,r2,1
81132f10:	e0ffeb15 	stw	r3,-84(fp)
81132f14:	10800003 	ldbu	r2,0(r2)
81132f18:	e0bffb05 	stb	r2,-20(fp)
81132f1c:	e0bffb07 	ldb	r2,-20(fp)
81132f20:	103eae1e 	bne	r2,zero,811329dc <__reset+0xfb1129dc>
          state=pfState_chars;
          }
        break;
      } /* switch */
    } /* while chars left */
  } /* printf */
81132f24:	0001883a 	nop
81132f28:	e6ffff04 	addi	sp,fp,-4
81132f2c:	dfc00217 	ldw	ra,8(sp)
81132f30:	df000117 	ldw	fp,4(sp)
81132f34:	dc000017 	ldw	r16,0(sp)
81132f38:	dec00304 	addi	sp,sp,12
81132f3c:	f800283a 	ret

81132f40 <alt_log_printf_proc>:

/* Main logging printf function */
int alt_log_printf_proc(const char *fmt, ... )
{
81132f40:	defff904 	addi	sp,sp,-28
81132f44:	de00012e 	bgeu	sp,et,81132f4c <alt_log_printf_proc+0xc>
81132f48:	003b68fa 	trap	3
81132f4c:	dfc00315 	stw	ra,12(sp)
81132f50:	df000215 	stw	fp,8(sp)
81132f54:	df000204 	addi	fp,sp,8
81132f58:	e13fff15 	stw	r4,-4(fp)
81132f5c:	e1400215 	stw	r5,8(fp)
81132f60:	e1800315 	stw	r6,12(fp)
81132f64:	e1c00415 	stw	r7,16(fp)
    va_list args;

    va_start (args, fmt);
81132f68:	e0800204 	addi	r2,fp,8
81132f6c:	e0bffe15 	stw	r2,-8(fp)
    alt_log_private_printf(fmt,ALT_LOG_PORT_BASE,args);
81132f70:	e0bffe17 	ldw	r2,-8(fp)
81132f74:	100d883a 	mov	r6,r2
81132f78:	01604834 	movhi	r5,33056
81132f7c:	294c2404 	addi	r5,r5,12432
81132f80:	e13fff17 	ldw	r4,-4(fp)
81132f84:	11329880 	call	81132988 <alt_log_private_printf>
    return (0);
81132f88:	0005883a 	mov	r2,zero
}
81132f8c:	e037883a 	mov	sp,fp
81132f90:	dfc00117 	ldw	ra,4(sp)
81132f94:	df000017 	ldw	fp,0(sp)
81132f98:	dec00504 	addi	sp,sp,20
81132f9c:	f800283a 	ret

81132fa0 <altera_avalon_jtag_uart_report_log>:
 * This function, when turned on, prints out the status
 * of the JTAG UART Control register, every ALT_LOG_JTAG_UART_TICKS.
 * If the flag is off, the alarm should never be registered, and this
 * function should never run */
alt_u32 altera_avalon_jtag_uart_report_log(void * context)
{
81132fa0:	defff904 	addi	sp,sp,-28
81132fa4:	de00012e 	bgeu	sp,et,81132fac <altera_avalon_jtag_uart_report_log+0xc>
81132fa8:	003b68fa 	trap	3
81132fac:	dfc00615 	stw	ra,24(sp)
81132fb0:	df000515 	stw	fp,20(sp)
81132fb4:	dc400415 	stw	r17,16(sp)
81132fb8:	dc000315 	stw	r16,12(sp)
81132fbc:	df000504 	addi	fp,sp,20
81132fc0:	e13ffd15 	stw	r4,-12(fp)
    if (alt_log_jtag_uart_alarm_on_flag) {
81132fc4:	d0a07d83 	ldbu	r2,-32266(gp)
81132fc8:	10803fcc 	andi	r2,r2,255
81132fcc:	10001426 	beq	r2,zero,81133020 <altera_avalon_jtag_uart_report_log+0x80>
    altera_avalon_jtag_uart_state* dev = (altera_avalon_jtag_uart_state*) context;
81132fd0:	e0bffd17 	ldw	r2,-12(fp)
81132fd4:	e0bffb15 	stw	r2,-20(fp)
        const char* header="JTAG Alarm:";
81132fd8:	00a04574 	movhi	r2,33045
81132fdc:	10b19004 	addi	r2,r2,-14784
81132fe0:	e0bffc15 	stw	r2,-16(fp)
        alt_log_jtag_uart_print_control_reg(dev, dev->base, header);
81132fe4:	e0bffb17 	ldw	r2,-20(fp)
81132fe8:	10800017 	ldw	r2,0(r2)
81132fec:	e1bffc17 	ldw	r6,-16(fp)
81132ff0:	100b883a 	mov	r5,r2
81132ff4:	e13ffb17 	ldw	r4,-20(fp)
81132ff8:	11330400 	call	81133040 <alt_log_jtag_uart_print_control_reg>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81132ffc:	d0e08417 	ldw	r3,-32240(gp)
        return ALT_LOG_JTAG_UART_TICKS;
81133000:	00b33374 	movhi	r2,52429
81133004:	10b33344 	addi	r2,r2,-13107
81133008:	1888383a 	mulxuu	r4,r3,r2
8113300c:	1885383a 	mul	r2,r3,r2
81133010:	1021883a 	mov	r16,r2
81133014:	2023883a 	mov	r17,r4
81133018:	8804d0fa 	srli	r2,r17,3
8113301c:	00000106 	br	81133024 <altera_avalon_jtag_uart_report_log+0x84>
    }
    else 
    {  
        /* If flag is not on, return 0 to disable future alarms.
        * Should never be here, alarm should not be enabled at all. */
        return 0;
81133020:	0005883a 	mov	r2,zero
    }
}
81133024:	e6fffe04 	addi	sp,fp,-8
81133028:	dfc00317 	ldw	ra,12(sp)
8113302c:	df000217 	ldw	fp,8(sp)
81133030:	dc400117 	ldw	r17,4(sp)
81133034:	dc000017 	ldw	r16,0(sp)
81133038:	dec00404 	addi	sp,sp,16
8113303c:	f800283a 	ret

81133040 <alt_log_jtag_uart_print_control_reg>:

void alt_log_jtag_uart_print_control_reg(altera_avalon_jtag_uart_state* dev, int base, const char* header)
{
81133040:	deffef04 	addi	sp,sp,-68
81133044:	de00012e 	bgeu	sp,et,8113304c <alt_log_jtag_uart_print_control_reg+0xc>
81133048:	003b68fa 	trap	3
8113304c:	dfc01015 	stw	ra,64(sp)
81133050:	df000f15 	stw	fp,60(sp)
81133054:	df000f04 	addi	fp,sp,60
81133058:	e13ffd15 	stw	r4,-12(fp)
8113305c:	e17ffe15 	stw	r5,-8(fp)
81133060:	e1bfff15 	stw	r6,-4(fp)
     unsigned int control, space, ac, wi, ri, we, re;
     control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81133064:	e0bffe17 	ldw	r2,-8(fp)
81133068:	10800104 	addi	r2,r2,4
8113306c:	10800037 	ldwio	r2,0(r2)
81133070:	e0bff615 	stw	r2,-40(fp)
     space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >>
81133074:	e0bff617 	ldw	r2,-40(fp)
81133078:	1004d43a 	srli	r2,r2,16
8113307c:	e0bff715 	stw	r2,-36(fp)
             ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
     we= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK) >>
81133080:	e0bff617 	ldw	r2,-40(fp)
81133084:	1080008c 	andi	r2,r2,2
81133088:	1004d07a 	srli	r2,r2,1
8113308c:	e0bff815 	stw	r2,-32(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WE_OFST;
     re= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK) >>
81133090:	e0bff617 	ldw	r2,-40(fp)
81133094:	1080004c 	andi	r2,r2,1
81133098:	e0bff915 	stw	r2,-28(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RE_OFST;
     ri= (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK) >>
8113309c:	e0bff617 	ldw	r2,-40(fp)
811330a0:	1080400c 	andi	r2,r2,256
811330a4:	1004d23a 	srli	r2,r2,8
811330a8:	e0bffa15 	stw	r2,-24(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_RI_OFST;
     wi= (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK) >>
811330ac:	e0bff617 	ldw	r2,-40(fp)
811330b0:	1080800c 	andi	r2,r2,512
811330b4:	1004d27a 	srli	r2,r2,9
811330b8:	e0bffb15 	stw	r2,-20(fp)
         ALTERA_AVALON_JTAG_UART_CONTROL_WI_OFST;
     ac= (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK) >>
811330bc:	e0bff617 	ldw	r2,-40(fp)
811330c0:	1081000c 	andi	r2,r2,1024
811330c4:	1004d2ba 	srli	r2,r2,10
811330c8:	e0bffc15 	stw	r2,-16(fp)
#ifdef ALTERA_AVALON_JTAG_UART_SMALL
    ALT_LOG_PRINTF(
     "%s HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,space,ac,wi,ri,we,re);
#else
    ALT_LOG_PRINTF(
811330cc:	e0bffd17 	ldw	r2,-12(fp)
811330d0:	10c01017 	ldw	r3,64(r2)
811330d4:	e0bffd17 	ldw	r2,-12(fp)
811330d8:	10800f17 	ldw	r2,60(r2)
811330dc:	1887c83a 	sub	r3,r3,r2
811330e0:	e0bff917 	ldw	r2,-28(fp)
811330e4:	d8800415 	stw	r2,16(sp)
811330e8:	e0bff817 	ldw	r2,-32(fp)
811330ec:	d8800315 	stw	r2,12(sp)
811330f0:	e0bffa17 	ldw	r2,-24(fp)
811330f4:	d8800215 	stw	r2,8(sp)
811330f8:	e0bffb17 	ldw	r2,-20(fp)
811330fc:	d8800115 	stw	r2,4(sp)
81133100:	e0bffc17 	ldw	r2,-16(fp)
81133104:	d8800015 	stw	r2,0(sp)
81133108:	e1fff717 	ldw	r7,-36(fp)
8113310c:	180d883a 	mov	r6,r3
81133110:	e17fff17 	ldw	r5,-4(fp)
81133114:	01204574 	movhi	r4,33045
81133118:	21319304 	addi	r4,r4,-14772
8113311c:	1132f400 	call	81132f40 <alt_log_printf_proc>
     "%s SW CirBuf = %d, HW FIFO wspace=%d AC=%d WI=%d RI=%d WE=%d RE=%d\r\n",
         header,(dev->tx_out-dev->tx_in),space,ac,wi,ri,we,re);
#endif   
         
     return;
81133120:	0001883a 	nop

}
81133124:	e037883a 	mov	sp,fp
81133128:	dfc00117 	ldw	ra,4(sp)
8113312c:	df000017 	ldw	fp,0(sp)
81133130:	dec00204 	addi	sp,sp,8
81133134:	f800283a 	ret

81133138 <alt_log_jtag_uart_startup_info>:
/* In altera_avalon_jtag_uart.c
 * Same output as the alarm function above, but this is called in the driver
 * init function.  Hence, it gives the status of the JTAG UART control register
 * right at the initialization of the driver */ 
void alt_log_jtag_uart_startup_info(altera_avalon_jtag_uart_state* dev, int base)
{
81133138:	defffb04 	addi	sp,sp,-20
8113313c:	de00012e 	bgeu	sp,et,81133144 <alt_log_jtag_uart_startup_info+0xc>
81133140:	003b68fa 	trap	3
81133144:	dfc00415 	stw	ra,16(sp)
81133148:	df000315 	stw	fp,12(sp)
8113314c:	df000304 	addi	fp,sp,12
81133150:	e13ffe15 	stw	r4,-8(fp)
81133154:	e17fff15 	stw	r5,-4(fp)
     const char* header="JTAG Startup Info:";
81133158:	00a04574 	movhi	r2,33045
8113315c:	10b1a504 	addi	r2,r2,-14700
81133160:	e0bffd15 	stw	r2,-12(fp)
     alt_log_jtag_uart_print_control_reg(dev, base, header);
81133164:	e1bffd17 	ldw	r6,-12(fp)
81133168:	e17fff17 	ldw	r5,-4(fp)
8113316c:	e13ffe17 	ldw	r4,-8(fp)
81133170:	11330400 	call	81133040 <alt_log_jtag_uart_print_control_reg>
     return;
81133174:	0001883a 	nop
}
81133178:	e037883a 	mov	sp,fp
8113317c:	dfc00117 	ldw	ra,4(sp)
81133180:	df000017 	ldw	fp,0(sp)
81133184:	dec00204 	addi	sp,sp,8
81133188:	f800283a 	ret

8113318c <alt_log_jtag_uart_isr_proc>:

/* In altera_avalon_jtag_uart.c
 * When turned on, this function will print out the status of the jtag uart
 * control register every time there is a jtag uart "almost-empty" interrupt. */
void alt_log_jtag_uart_isr_proc(int base, altera_avalon_jtag_uart_state* dev) 
{
8113318c:	defffb04 	addi	sp,sp,-20
81133190:	de00012e 	bgeu	sp,et,81133198 <alt_log_jtag_uart_isr_proc+0xc>
81133194:	003b68fa 	trap	3
81133198:	dfc00415 	stw	ra,16(sp)
8113319c:	df000315 	stw	fp,12(sp)
811331a0:	df000304 	addi	fp,sp,12
811331a4:	e13ffe15 	stw	r4,-8(fp)
811331a8:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_jtag_uart_isr_on_flag) {
811331ac:	d0a07dc3 	ldbu	r2,-32265(gp)
811331b0:	10803fcc 	andi	r2,r2,255
811331b4:	10000826 	beq	r2,zero,811331d8 <alt_log_jtag_uart_isr_proc+0x4c>
        const char* header="JTAG IRQ:";
811331b8:	00a04574 	movhi	r2,33045
811331bc:	10b1aa04 	addi	r2,r2,-14680
811331c0:	e0bffd15 	stw	r2,-12(fp)
        alt_log_jtag_uart_print_control_reg(dev, base, header);
811331c4:	e1bffd17 	ldw	r6,-12(fp)
811331c8:	e17ffe17 	ldw	r5,-8(fp)
811331cc:	e13fff17 	ldw	r4,-4(fp)
811331d0:	11330400 	call	81133040 <alt_log_jtag_uart_print_control_reg>
    }
    return;
811331d4:	0001883a 	nop
811331d8:	0001883a 	nop
}
811331dc:	e037883a 	mov	sp,fp
811331e0:	dfc00117 	ldw	ra,4(sp)
811331e4:	df000017 	ldw	fp,0(sp)
811331e8:	dec00204 	addi	sp,sp,8
811331ec:	f800283a 	ret

811331f0 <alt_log_write>:
 * When the alt_log_write_on_flag is turned on, this function gets called
 * every time alt_write gets called.  The first 
 * ALT_LOG_WRITE_ECHO_LEN characters of every printf command (or any command
 * that eventually calls write()) gets echoed to the alt_log output. */
void alt_log_write(const void *ptr, size_t len)
{
811331f0:	defffa04 	addi	sp,sp,-24
811331f4:	de00012e 	bgeu	sp,et,811331fc <alt_log_write+0xc>
811331f8:	003b68fa 	trap	3
811331fc:	dfc00515 	stw	ra,20(sp)
81133200:	df000415 	stw	fp,16(sp)
81133204:	df000404 	addi	fp,sp,16
81133208:	e13ffe15 	stw	r4,-8(fp)
8113320c:	e17fff15 	stw	r5,-4(fp)
    if (alt_log_write_on_flag) {
81133210:	d0a07d03 	ldbu	r2,-32268(gp)
81133214:	10803fcc 	andi	r2,r2,255
81133218:	10004026 	beq	r2,zero,8113331c <alt_log_write+0x12c>
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;
8113321c:	e0bfff17 	ldw	r2,-4(fp)
81133220:	10c00430 	cmpltui	r3,r2,16
81133224:	1800011e 	bne	r3,zero,8113322c <alt_log_write+0x3c>
81133228:	008003c4 	movi	r2,15
8113322c:	e0bffd15 	stw	r2,-12(fp)

        if (length < 2) return;
81133230:	e0bffd17 	ldw	r2,-12(fp)
81133234:	10800088 	cmpgei	r2,r2,2
81133238:	10003726 	beq	r2,zero,81133318 <alt_log_write+0x128>

        strncpy (alt_log_write_buf,ptr,length);
8113323c:	e0bffd17 	ldw	r2,-12(fp)
81133240:	100d883a 	mov	r6,r2
81133244:	e17ffe17 	ldw	r5,-8(fp)
81133248:	012045b4 	movhi	r4,33046
8113324c:	2108ff04 	addi	r4,r4,9212
81133250:	11471bc0 	call	811471bc <strncpy>
    alt_log_write_buf[length-1]='\n';
81133254:	e0bffd17 	ldw	r2,-12(fp)
81133258:	10ffffc4 	addi	r3,r2,-1
8113325c:	00a045b4 	movhi	r2,33046
81133260:	1088ff04 	addi	r2,r2,9212
81133264:	10c5883a 	add	r2,r2,r3
81133268:	00c00284 	movi	r3,10
8113326c:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
81133270:	00a045b4 	movhi	r2,33046
81133274:	1088ff04 	addi	r2,r2,9212
81133278:	e0fffd17 	ldw	r3,-12(fp)
8113327c:	10c5883a 	add	r2,r2,r3
81133280:	00c00344 	movi	r3,13
81133284:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length+1]='\0';
81133288:	e0bffd17 	ldw	r2,-12(fp)
8113328c:	10c00044 	addi	r3,r2,1
81133290:	00a045b4 	movhi	r2,33046
81133294:	1088ff04 	addi	r2,r2,9212
81133298:	10c5883a 	add	r2,r2,r3
8113329c:	10000005 	stb	zero,0(r2)

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811332a0:	e03ffc15 	stw	zero,-16(fp)
811332a4:	00001306 	br	811332f4 <alt_log_write+0x104>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
811332a8:	00a045b4 	movhi	r2,33046
811332ac:	1088ff04 	addi	r2,r2,9212
811332b0:	e0fffc17 	ldw	r3,-16(fp)
811332b4:	10c5883a 	add	r2,r2,r3
811332b8:	10800003 	ldbu	r2,0(r2)
811332bc:	10803fcc 	andi	r2,r2,255
811332c0:	1080201c 	xori	r2,r2,128
811332c4:	10bfe004 	addi	r2,r2,-128
811332c8:	10800118 	cmpnei	r2,r2,4
811332cc:	1000061e 	bne	r2,zero,811332e8 <alt_log_write+0xf8>
            alt_log_write_buf[temp_cnt]='D';
811332d0:	00a045b4 	movhi	r2,33046
811332d4:	1088ff04 	addi	r2,r2,9212
811332d8:	e0fffc17 	ldw	r3,-16(fp)
811332dc:	10c5883a 	add	r2,r2,r3
811332e0:	00c01104 	movi	r3,68
811332e4:	10c00005 	stb	r3,0(r2)
    alt_log_write_buf[length]='\r';
    alt_log_write_buf[length+1]='\0';

    /* Escape Ctrl-D's. If the Ctrl-D gets sent it might kill the terminal
         * connection of alt_log. It will get replaced by 'D'. */
        for (temp_cnt=0;temp_cnt < length; temp_cnt++) {
811332e8:	e0bffc17 	ldw	r2,-16(fp)
811332ec:	10800044 	addi	r2,r2,1
811332f0:	e0bffc15 	stw	r2,-16(fp)
811332f4:	e0fffc17 	ldw	r3,-16(fp)
811332f8:	e0bffd17 	ldw	r2,-12(fp)
811332fc:	18bfea16 	blt	r3,r2,811332a8 <__reset+0xfb1132a8>
        if (alt_log_write_buf[temp_cnt]== 0x4) {
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
81133300:	016045b4 	movhi	r5,33046
81133304:	2948ff04 	addi	r5,r5,9212
81133308:	01204574 	movhi	r4,33045
8113330c:	2131ad04 	addi	r4,r4,-14668
81133310:	1132f400 	call	81132f40 <alt_log_printf_proc>
81133314:	00000106 	br	8113331c <alt_log_write+0x12c>
{
    if (alt_log_write_on_flag) {
    int temp_cnt;
        int length=(ALT_LOG_WRITE_ECHO_LEN>len) ? len : ALT_LOG_WRITE_ECHO_LEN;

        if (length < 2) return;
81133318:	0001883a 	nop
            alt_log_write_buf[temp_cnt]='D';
        }
    }
        ALT_LOG_PRINTF("Write Echo: %s",alt_log_write_buf);
    }
}
8113331c:	e037883a 	mov	sp,fp
81133320:	dfc00117 	ldw	ra,4(sp)
81133324:	df000017 	ldw	fp,0(sp)
81133328:	dec00204 	addi	sp,sp,8
8113332c:	f800283a 	ret

81133330 <alt_log_system_clock>:

/* In altera_avalon_timer_sc
 * This function prints out a system clock is alive message
 * every ALT_LOG_SYS_CLK_INTERVAL (in ticks).  */
void alt_log_system_clock()
{
81133330:	defffe04 	addi	sp,sp,-8
81133334:	de00012e 	bgeu	sp,et,8113333c <alt_log_system_clock+0xc>
81133338:	003b68fa 	trap	3
8113333c:	dfc00115 	stw	ra,4(sp)
81133340:	df000015 	stw	fp,0(sp)
81133344:	d839883a 	mov	fp,sp
    if (alt_log_sys_clk_on_flag) {
81133348:	d0a07d43 	ldbu	r2,-32267(gp)
8113334c:	10803fcc 	andi	r2,r2,255
81133350:	10000e26 	beq	r2,zero,8113338c <alt_log_system_clock+0x5c>
    alt_log_sys_clk_count++;
81133354:	d0a08017 	ldw	r2,-32256(gp)
81133358:	10800044 	addi	r2,r2,1
8113335c:	d0a08015 	stw	r2,-32256(gp)
81133360:	d0a08417 	ldw	r2,-32240(gp)
        if (alt_log_sys_clk_count > ALT_LOG_SYS_CLK_INTERVAL) {
81133364:	d0e08017 	ldw	r3,-32256(gp)
81133368:	10c0082e 	bgeu	r2,r3,8113338c <alt_log_system_clock+0x5c>
            alt_log_sys_clk_count = 0;
8113336c:	d0208015 	stw	zero,-32256(gp)
            ALT_LOG_PRINTF("System Clock On %u\r\n",alt_system_clock_in_sec++);
81133370:	d0a07f17 	ldw	r2,-32260(gp)
81133374:	10c00044 	addi	r3,r2,1
81133378:	d0e07f15 	stw	r3,-32260(gp)
8113337c:	100b883a 	mov	r5,r2
81133380:	01204574 	movhi	r4,33045
81133384:	2131b104 	addi	r4,r4,-14652
81133388:	1132f400 	call	81132f40 <alt_log_printf_proc>
        }
    }
}
8113338c:	0001883a 	nop
81133390:	e037883a 	mov	sp,fp
81133394:	dfc00117 	ldw	ra,4(sp)
81133398:	df000017 	ldw	fp,0(sp)
8113339c:	dec00204 	addi	sp,sp,8
811333a0:	f800283a 	ret

811333a4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
811333a4:	defffe04 	addi	sp,sp,-8
811333a8:	de00012e 	bgeu	sp,et,811333b0 <alt_get_errno+0xc>
811333ac:	003b68fa 	trap	3
811333b0:	dfc00115 	stw	ra,4(sp)
811333b4:	df000015 	stw	fp,0(sp)
811333b8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811333bc:	d0a01017 	ldw	r2,-32704(gp)
811333c0:	10000326 	beq	r2,zero,811333d0 <alt_get_errno+0x2c>
811333c4:	d0a01017 	ldw	r2,-32704(gp)
811333c8:	103ee83a 	callr	r2
811333cc:	00000106 	br	811333d4 <alt_get_errno+0x30>
811333d0:	d0a07404 	addi	r2,gp,-32304
}
811333d4:	e037883a 	mov	sp,fp
811333d8:	dfc00117 	ldw	ra,4(sp)
811333dc:	df000017 	ldw	fp,0(sp)
811333e0:	dec00204 	addi	sp,sp,8
811333e4:	f800283a 	ret

811333e8 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
811333e8:	defff904 	addi	sp,sp,-28
811333ec:	de00012e 	bgeu	sp,et,811333f4 <lseek+0xc>
811333f0:	003b68fa 	trap	3
811333f4:	dfc00615 	stw	ra,24(sp)
811333f8:	df000515 	stw	fp,20(sp)
811333fc:	df000504 	addi	fp,sp,20
81133400:	e13ffd15 	stw	r4,-12(fp)
81133404:	e17ffe15 	stw	r5,-8(fp)
81133408:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
8113340c:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81133410:	e0bffd17 	ldw	r2,-12(fp)
81133414:	10000616 	blt	r2,zero,81133430 <lseek+0x48>
81133418:	e0bffd17 	ldw	r2,-12(fp)
8113341c:	10c00324 	muli	r3,r2,12
81133420:	00a04574 	movhi	r2,33045
81133424:	10b56a04 	addi	r2,r2,-10840
81133428:	1885883a 	add	r2,r3,r2
8113342c:	00000106 	br	81133434 <lseek+0x4c>
81133430:	0005883a 	mov	r2,zero
81133434:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
81133438:	e0bffc17 	ldw	r2,-16(fp)
8113343c:	10001026 	beq	r2,zero,81133480 <lseek+0x98>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
81133440:	e0bffc17 	ldw	r2,-16(fp)
81133444:	10800017 	ldw	r2,0(r2)
81133448:	10800717 	ldw	r2,28(r2)
8113344c:	10000926 	beq	r2,zero,81133474 <lseek+0x8c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
81133450:	e0bffc17 	ldw	r2,-16(fp)
81133454:	10800017 	ldw	r2,0(r2)
81133458:	10800717 	ldw	r2,28(r2)
8113345c:	e1bfff17 	ldw	r6,-4(fp)
81133460:	e17ffe17 	ldw	r5,-8(fp)
81133464:	e13ffc17 	ldw	r4,-16(fp)
81133468:	103ee83a 	callr	r2
8113346c:	e0bffb15 	stw	r2,-20(fp)
81133470:	00000506 	br	81133488 <lseek+0xa0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
81133474:	00bfde84 	movi	r2,-134
81133478:	e0bffb15 	stw	r2,-20(fp)
8113347c:	00000206 	br	81133488 <lseek+0xa0>
    }
  }
  else  
  {
    rc = -EBADFD;
81133480:	00bfebc4 	movi	r2,-81
81133484:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
81133488:	e0bffb17 	ldw	r2,-20(fp)
8113348c:	1000070e 	bge	r2,zero,811334ac <lseek+0xc4>
  {
    ALT_ERRNO = -rc;
81133490:	11333a40 	call	811333a4 <alt_get_errno>
81133494:	1007883a 	mov	r3,r2
81133498:	e0bffb17 	ldw	r2,-20(fp)
8113349c:	0085c83a 	sub	r2,zero,r2
811334a0:	18800015 	stw	r2,0(r3)
    rc = -1;
811334a4:	00bfffc4 	movi	r2,-1
811334a8:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
811334ac:	e0bffb17 	ldw	r2,-20(fp)
}
811334b0:	e037883a 	mov	sp,fp
811334b4:	dfc00117 	ldw	ra,4(sp)
811334b8:	df000017 	ldw	fp,0(sp)
811334bc:	dec00204 	addi	sp,sp,8
811334c0:	f800283a 	ret

811334c4 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
811334c4:	defff904 	addi	sp,sp,-28
811334c8:	de00012e 	bgeu	sp,et,811334d0 <alt_main+0xc>
811334cc:	003b68fa 	trap	3
811334d0:	dfc00615 	stw	ra,24(sp)
811334d4:	df000515 	stw	fp,20(sp)
811334d8:	df000504 	addi	fp,sp,20
#ifndef ALT_NO_EXIT    
  int result;
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
811334dc:	d0a01217 	ldw	r2,-32696(gp)
811334e0:	10800058 	cmpnei	r2,r2,1
811334e4:	1000031e 	bne	r2,zero,811334f4 <alt_main+0x30>
811334e8:	01204574 	movhi	r4,33045
811334ec:	2131b704 	addi	r4,r4,-14628
811334f0:	1132f400 	call	81132f40 <alt_log_printf_proc>
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
811334f4:	0009883a 	mov	r4,zero
811334f8:	113e01c0 	call	8113e01c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
811334fc:	d0a01217 	ldw	r2,-32696(gp)
81133500:	10800058 	cmpnei	r2,r2,1
81133504:	1000031e 	bne	r2,zero,81133514 <alt_main+0x50>
81133508:	01204574 	movhi	r4,33045
8113350c:	2131c504 	addi	r4,r4,-14572
81133510:	1132f400 	call	81132f40 <alt_log_printf_proc>
  ALT_OS_INIT();
81133514:	1134ab00 	call	81134ab0 <OSInit>
81133518:	01000044 	movi	r4,1
8113351c:	113a7cc0 	call	8113a7cc <OSSemCreate>
81133520:	d0a08715 	stw	r2,-32228(gp)
81133524:	01000044 	movi	r4,1
81133528:	113a7cc0 	call	8113a7cc <OSSemCreate>
8113352c:	d0a08915 	stw	r2,-32220(gp)
  /*
   * Initialize the semaphore used to control access to the file descriptor
   * list.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
81133530:	d0a01217 	ldw	r2,-32696(gp)
81133534:	10800058 	cmpnei	r2,r2,1
81133538:	1000031e 	bne	r2,zero,81133548 <alt_main+0x84>
8113353c:	01204574 	movhi	r4,33045
81133540:	2131d304 	addi	r4,r4,-14516
81133544:	1132f400 	call	81132f40 <alt_log_printf_proc>
81133548:	d0a07b04 	addi	r2,gp,-32276
8113354c:	e0bffc15 	stw	r2,-16(fp)
81133550:	00800044 	movi	r2,1
81133554:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81133558:	e0bffd0b 	ldhu	r2,-12(fp)
8113355c:	1009883a 	mov	r4,r2
81133560:	113a7cc0 	call	8113a7cc <OSSemCreate>
81133564:	1007883a 	mov	r3,r2
81133568:	e0bffc17 	ldw	r2,-16(fp)
8113356c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
81133570:	d0a01217 	ldw	r2,-32696(gp)
81133574:	10800058 	cmpnei	r2,r2,1
81133578:	1000031e 	bne	r2,zero,81133588 <alt_main+0xc4>
8113357c:	01204574 	movhi	r4,33045
81133580:	2131e104 	addi	r4,r4,-14460
81133584:	1132f400 	call	81132f40 <alt_log_printf_proc>
  alt_sys_init();
81133588:	113e05c0 	call	8113e05c <alt_sys_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_sys_init.\r\n");
8113358c:	d0a01217 	ldw	r2,-32696(gp)
81133590:	10800058 	cmpnei	r2,r2,1
81133594:	1000031e 	bne	r2,zero,811335a4 <alt_main+0xe0>
81133598:	01204574 	movhi	r4,33045
8113359c:	2131eb04 	addi	r4,r4,-14420
811335a0:	1132f400 	call	81132f40 <alt_log_printf_proc>
   * been initialized. This is only done if the user has requested these
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
811335a4:	d0a01217 	ldw	r2,-32696(gp)
811335a8:	10800058 	cmpnei	r2,r2,1
811335ac:	1000031e 	bne	r2,zero,811335bc <alt_main+0xf8>
811335b0:	01204574 	movhi	r4,33045
811335b4:	2131f404 	addi	r4,r4,-14384
811335b8:	1132f400 	call	81132f40 <alt_log_printf_proc>
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
811335bc:	01a04574 	movhi	r6,33045
811335c0:	31b1fc04 	addi	r6,r6,-14352
811335c4:	01604574 	movhi	r5,33045
811335c8:	29720104 	addi	r5,r5,-14332
811335cc:	01204574 	movhi	r4,33045
811335d0:	21320104 	addi	r4,r4,-14332
811335d4:	114694c0 	call	8114694c <alt_io_redirect>
  /*
   * Finally, call main(). The return code is then passed to a subsequent
   * call to exit() unless the application is never supposed to exit.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");
811335d8:	d0a01217 	ldw	r2,-32696(gp)
811335dc:	10800058 	cmpnei	r2,r2,1
811335e0:	1000031e 	bne	r2,zero,811335f0 <alt_main+0x12c>
811335e4:	01204574 	movhi	r4,33045
811335e8:	21320504 	addi	r4,r4,-14316
811335ec:	1132f400 	call	81132f40 <alt_log_printf_proc>

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
811335f0:	d0a08117 	ldw	r2,-32252(gp)
811335f4:	d0e08217 	ldw	r3,-32248(gp)
811335f8:	d1208317 	ldw	r4,-32244(gp)
811335fc:	200d883a 	mov	r6,r4
81133600:	180b883a 	mov	r5,r3
81133604:	1009883a 	mov	r4,r2
81133608:	111506c0 	call	8111506c <main>
8113360c:	e0bffb15 	stw	r2,-20(fp)
  close(STDOUT_FILENO);
81133610:	01000044 	movi	r4,1
81133614:	11323f00 	call	811323f0 <close>
  exit (result);
81133618:	e13ffb17 	ldw	r4,-20(fp)
8113361c:	11471000 	call	81147100 <exit>

81133620 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81133620:	defffe04 	addi	sp,sp,-8
81133624:	de00012e 	bgeu	sp,et,8113362c <alt_get_errno+0xc>
81133628:	003b68fa 	trap	3
8113362c:	dfc00115 	stw	ra,4(sp)
81133630:	df000015 	stw	fp,0(sp)
81133634:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81133638:	d0a01017 	ldw	r2,-32704(gp)
8113363c:	10000326 	beq	r2,zero,8113364c <alt_get_errno+0x2c>
81133640:	d0a01017 	ldw	r2,-32704(gp)
81133644:	103ee83a 	callr	r2
81133648:	00000106 	br	81133650 <alt_get_errno+0x30>
8113364c:	d0a07404 	addi	r2,gp,-32304
}
81133650:	e037883a 	mov	sp,fp
81133654:	dfc00117 	ldw	ra,4(sp)
81133658:	df000017 	ldw	fp,0(sp)
8113365c:	dec00204 	addi	sp,sp,8
81133660:	f800283a 	ret

81133664 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
81133664:	defffd04 	addi	sp,sp,-12
81133668:	de00012e 	bgeu	sp,et,81133670 <alt_file_locked+0xc>
8113366c:	003b68fa 	trap	3
81133670:	df000215 	stw	fp,8(sp)
81133674:	df000204 	addi	fp,sp,8
81133678:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
8113367c:	e0bfff17 	ldw	r2,-4(fp)
81133680:	10800217 	ldw	r2,8(r2)
81133684:	10d00034 	orhi	r3,r2,16384
81133688:	e0bfff17 	ldw	r2,-4(fp)
8113368c:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81133690:	e03ffe15 	stw	zero,-8(fp)
81133694:	00001d06 	br	8113370c <alt_file_locked+0xa8>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
81133698:	00a04574 	movhi	r2,33045
8113369c:	10b56a04 	addi	r2,r2,-10840
811336a0:	e0fffe17 	ldw	r3,-8(fp)
811336a4:	18c00324 	muli	r3,r3,12
811336a8:	10c5883a 	add	r2,r2,r3
811336ac:	10c00017 	ldw	r3,0(r2)
811336b0:	e0bfff17 	ldw	r2,-4(fp)
811336b4:	10800017 	ldw	r2,0(r2)
811336b8:	1880111e 	bne	r3,r2,81133700 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811336bc:	00a04574 	movhi	r2,33045
811336c0:	10b56a04 	addi	r2,r2,-10840
811336c4:	e0fffe17 	ldw	r3,-8(fp)
811336c8:	18c00324 	muli	r3,r3,12
811336cc:	10c5883a 	add	r2,r2,r3
811336d0:	10800204 	addi	r2,r2,8
811336d4:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
811336d8:	1000090e 	bge	r2,zero,81133700 <alt_file_locked+0x9c>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
811336dc:	e0bffe17 	ldw	r2,-8(fp)
811336e0:	10c00324 	muli	r3,r2,12
811336e4:	00a04574 	movhi	r2,33045
811336e8:	10b56a04 	addi	r2,r2,-10840
811336ec:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
811336f0:	e0bfff17 	ldw	r2,-4(fp)
811336f4:	18800226 	beq	r3,r2,81133700 <alt_file_locked+0x9c>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
811336f8:	00bffcc4 	movi	r2,-13
811336fc:	00000806 	br	81133720 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
81133700:	e0bffe17 	ldw	r2,-8(fp)
81133704:	10800044 	addi	r2,r2,1
81133708:	e0bffe15 	stw	r2,-8(fp)
8113370c:	d0a00f17 	ldw	r2,-32708(gp)
81133710:	1007883a 	mov	r3,r2
81133714:	e0bffe17 	ldw	r2,-8(fp)
81133718:	18bfdf2e 	bgeu	r3,r2,81133698 <__reset+0xfb113698>
    }
  }
  
  /* The device is not locked */
 
  return 0;
8113371c:	0005883a 	mov	r2,zero
}
81133720:	e037883a 	mov	sp,fp
81133724:	df000017 	ldw	fp,0(sp)
81133728:	dec00104 	addi	sp,sp,4
8113372c:	f800283a 	ret

81133730 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
81133730:	defff604 	addi	sp,sp,-40
81133734:	de00012e 	bgeu	sp,et,8113373c <open+0xc>
81133738:	003b68fa 	trap	3
8113373c:	dfc00915 	stw	ra,36(sp)
81133740:	df000815 	stw	fp,32(sp)
81133744:	df000804 	addi	fp,sp,32
81133748:	e13ffd15 	stw	r4,-12(fp)
8113374c:	e17ffe15 	stw	r5,-8(fp)
81133750:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
81133754:	00bfffc4 	movi	r2,-1
81133758:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
8113375c:	00bffb44 	movi	r2,-19
81133760:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
81133764:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
81133768:	d1600d04 	addi	r5,gp,-32716
8113376c:	e13ffd17 	ldw	r4,-12(fp)
81133770:	114632c0 	call	8114632c <alt_find_dev>
81133774:	e0bff815 	stw	r2,-32(fp)
81133778:	e0bff817 	ldw	r2,-32(fp)
8113377c:	1000051e 	bne	r2,zero,81133794 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
81133780:	e13ffd17 	ldw	r4,-12(fp)
81133784:	11463c40 	call	811463c4 <alt_find_file>
81133788:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
8113378c:	00800044 	movi	r2,1
81133790:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
81133794:	e0bff817 	ldw	r2,-32(fp)
81133798:	10002926 	beq	r2,zero,81133840 <open+0x110>
  {
    if ((index = alt_get_fd (dev)) < 0)
8113379c:	e13ff817 	ldw	r4,-32(fp)
811337a0:	11464d40 	call	811464d4 <alt_get_fd>
811337a4:	e0bff915 	stw	r2,-28(fp)
811337a8:	e0bff917 	ldw	r2,-28(fp)
811337ac:	1000030e 	bge	r2,zero,811337bc <open+0x8c>
    {
      status = index;
811337b0:	e0bff917 	ldw	r2,-28(fp)
811337b4:	e0bffa15 	stw	r2,-24(fp)
811337b8:	00002306 	br	81133848 <open+0x118>
    }
    else
    {
      fd = &alt_fd_list[index];
811337bc:	e0bff917 	ldw	r2,-28(fp)
811337c0:	10c00324 	muli	r3,r2,12
811337c4:	00a04574 	movhi	r2,33045
811337c8:	10b56a04 	addi	r2,r2,-10840
811337cc:	1885883a 	add	r2,r3,r2
811337d0:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
811337d4:	e0fffe17 	ldw	r3,-8(fp)
811337d8:	00900034 	movhi	r2,16384
811337dc:	10bfffc4 	addi	r2,r2,-1
811337e0:	1886703a 	and	r3,r3,r2
811337e4:	e0bffc17 	ldw	r2,-16(fp)
811337e8:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
811337ec:	e0bffb17 	ldw	r2,-20(fp)
811337f0:	1000051e 	bne	r2,zero,81133808 <open+0xd8>
811337f4:	e13ffc17 	ldw	r4,-16(fp)
811337f8:	11336640 	call	81133664 <alt_file_locked>
811337fc:	e0bffa15 	stw	r2,-24(fp)
81133800:	e0bffa17 	ldw	r2,-24(fp)
81133804:	10001016 	blt	r2,zero,81133848 <open+0x118>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
81133808:	e0bff817 	ldw	r2,-32(fp)
8113380c:	10800317 	ldw	r2,12(r2)
81133810:	10000826 	beq	r2,zero,81133834 <open+0x104>
81133814:	e0bff817 	ldw	r2,-32(fp)
81133818:	10800317 	ldw	r2,12(r2)
8113381c:	e1ffff17 	ldw	r7,-4(fp)
81133820:	e1bffe17 	ldw	r6,-8(fp)
81133824:	e17ffd17 	ldw	r5,-12(fp)
81133828:	e13ffc17 	ldw	r4,-16(fp)
8113382c:	103ee83a 	callr	r2
81133830:	00000106 	br	81133838 <open+0x108>
81133834:	0005883a 	mov	r2,zero
81133838:	e0bffa15 	stw	r2,-24(fp)
8113383c:	00000206 	br	81133848 <open+0x118>
      }
    }
  }
  else
  {
    status = -ENODEV;
81133840:	00bffb44 	movi	r2,-19
81133844:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
81133848:	e0bffa17 	ldw	r2,-24(fp)
8113384c:	1000090e 	bge	r2,zero,81133874 <open+0x144>
  {
    alt_release_fd (index);  
81133850:	e13ff917 	ldw	r4,-28(fp)
81133854:	11339d40 	call	811339d4 <alt_release_fd>
    ALT_ERRNO = -status;
81133858:	11336200 	call	81133620 <alt_get_errno>
8113385c:	1007883a 	mov	r3,r2
81133860:	e0bffa17 	ldw	r2,-24(fp)
81133864:	0085c83a 	sub	r2,zero,r2
81133868:	18800015 	stw	r2,0(r3)
    return -1;
8113386c:	00bfffc4 	movi	r2,-1
81133870:	00000106 	br	81133878 <open+0x148>
  }
  
  /* return the reference upon success */

  return index;
81133874:	e0bff917 	ldw	r2,-28(fp)
}
81133878:	e037883a 	mov	sp,fp
8113387c:	dfc00117 	ldw	ra,4(sp)
81133880:	df000017 	ldw	fp,0(sp)
81133884:	dec00204 	addi	sp,sp,8
81133888:	f800283a 	ret

8113388c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8113388c:	defffe04 	addi	sp,sp,-8
81133890:	de00012e 	bgeu	sp,et,81133898 <alt_get_errno+0xc>
81133894:	003b68fa 	trap	3
81133898:	dfc00115 	stw	ra,4(sp)
8113389c:	df000015 	stw	fp,0(sp)
811338a0:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
811338a4:	d0a01017 	ldw	r2,-32704(gp)
811338a8:	10000326 	beq	r2,zero,811338b8 <alt_get_errno+0x2c>
811338ac:	d0a01017 	ldw	r2,-32704(gp)
811338b0:	103ee83a 	callr	r2
811338b4:	00000106 	br	811338bc <alt_get_errno+0x30>
811338b8:	d0a07404 	addi	r2,gp,-32304
}
811338bc:	e037883a 	mov	sp,fp
811338c0:	dfc00117 	ldw	ra,4(sp)
811338c4:	df000017 	ldw	fp,0(sp)
811338c8:	dec00204 	addi	sp,sp,8
811338cc:	f800283a 	ret

811338d0 <read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
811338d0:	defff904 	addi	sp,sp,-28
811338d4:	de00012e 	bgeu	sp,et,811338dc <read+0xc>
811338d8:	003b68fa 	trap	3
811338dc:	dfc00615 	stw	ra,24(sp)
811338e0:	df000515 	stw	fp,20(sp)
811338e4:	df000504 	addi	fp,sp,20
811338e8:	e13ffd15 	stw	r4,-12(fp)
811338ec:	e17ffe15 	stw	r5,-8(fp)
811338f0:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
811338f4:	e0bffd17 	ldw	r2,-12(fp)
811338f8:	10000616 	blt	r2,zero,81133914 <read+0x44>
811338fc:	e0bffd17 	ldw	r2,-12(fp)
81133900:	10c00324 	muli	r3,r2,12
81133904:	00a04574 	movhi	r2,33045
81133908:	10b56a04 	addi	r2,r2,-10840
8113390c:	1885883a 	add	r2,r3,r2
81133910:	00000106 	br	81133918 <read+0x48>
81133914:	0005883a 	mov	r2,zero
81133918:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
8113391c:	e0bffb17 	ldw	r2,-20(fp)
81133920:	10002226 	beq	r2,zero,811339ac <read+0xdc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81133924:	e0bffb17 	ldw	r2,-20(fp)
81133928:	10800217 	ldw	r2,8(r2)
8113392c:	108000cc 	andi	r2,r2,3
81133930:	10800060 	cmpeqi	r2,r2,1
81133934:	1000181e 	bne	r2,zero,81133998 <read+0xc8>
        (fd->dev->read))
81133938:	e0bffb17 	ldw	r2,-20(fp)
8113393c:	10800017 	ldw	r2,0(r2)
81133940:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
81133944:	10001426 	beq	r2,zero,81133998 <read+0xc8>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
81133948:	e0bffb17 	ldw	r2,-20(fp)
8113394c:	10800017 	ldw	r2,0(r2)
81133950:	10800517 	ldw	r2,20(r2)
81133954:	e0ffff17 	ldw	r3,-4(fp)
81133958:	180d883a 	mov	r6,r3
8113395c:	e17ffe17 	ldw	r5,-8(fp)
81133960:	e13ffb17 	ldw	r4,-20(fp)
81133964:	103ee83a 	callr	r2
81133968:	e0bffc15 	stw	r2,-16(fp)
8113396c:	e0bffc17 	ldw	r2,-16(fp)
81133970:	1000070e 	bge	r2,zero,81133990 <read+0xc0>
        {
          ALT_ERRNO = -rval;
81133974:	113388c0 	call	8113388c <alt_get_errno>
81133978:	1007883a 	mov	r3,r2
8113397c:	e0bffc17 	ldw	r2,-16(fp)
81133980:	0085c83a 	sub	r2,zero,r2
81133984:	18800015 	stw	r2,0(r3)
          return -1;
81133988:	00bfffc4 	movi	r2,-1
8113398c:	00000c06 	br	811339c0 <read+0xf0>
        }
        return rval;
81133990:	e0bffc17 	ldw	r2,-16(fp)
81133994:	00000a06 	br	811339c0 <read+0xf0>
      }
      else
      {
        ALT_ERRNO = EACCES;
81133998:	113388c0 	call	8113388c <alt_get_errno>
8113399c:	1007883a 	mov	r3,r2
811339a0:	00800344 	movi	r2,13
811339a4:	18800015 	stw	r2,0(r3)
811339a8:	00000406 	br	811339bc <read+0xec>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
811339ac:	113388c0 	call	8113388c <alt_get_errno>
811339b0:	1007883a 	mov	r3,r2
811339b4:	00801444 	movi	r2,81
811339b8:	18800015 	stw	r2,0(r3)
  }
  return -1;
811339bc:	00bfffc4 	movi	r2,-1
}
811339c0:	e037883a 	mov	sp,fp
811339c4:	dfc00117 	ldw	ra,4(sp)
811339c8:	df000017 	ldw	fp,0(sp)
811339cc:	dec00204 	addi	sp,sp,8
811339d0:	f800283a 	ret

811339d4 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
811339d4:	defffe04 	addi	sp,sp,-8
811339d8:	de00012e 	bgeu	sp,et,811339e0 <alt_release_fd+0xc>
811339dc:	003b68fa 	trap	3
811339e0:	df000115 	stw	fp,4(sp)
811339e4:	df000104 	addi	fp,sp,4
811339e8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
811339ec:	e0bfff17 	ldw	r2,-4(fp)
811339f0:	108000d0 	cmplti	r2,r2,3
811339f4:	10000d1e 	bne	r2,zero,81133a2c <alt_release_fd+0x58>
  {
    alt_fd_list[fd].fd_flags = 0;
811339f8:	00a04574 	movhi	r2,33045
811339fc:	10b56a04 	addi	r2,r2,-10840
81133a00:	e0ffff17 	ldw	r3,-4(fp)
81133a04:	18c00324 	muli	r3,r3,12
81133a08:	10c5883a 	add	r2,r2,r3
81133a0c:	10800204 	addi	r2,r2,8
81133a10:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
81133a14:	00a04574 	movhi	r2,33045
81133a18:	10b56a04 	addi	r2,r2,-10840
81133a1c:	e0ffff17 	ldw	r3,-4(fp)
81133a20:	18c00324 	muli	r3,r3,12
81133a24:	10c5883a 	add	r2,r2,r3
81133a28:	10000015 	stw	zero,0(r2)
  }
}
81133a2c:	0001883a 	nop
81133a30:	e037883a 	mov	sp,fp
81133a34:	df000017 	ldw	fp,0(sp)
81133a38:	dec00104 	addi	sp,sp,4
81133a3c:	f800283a 	ret

81133a40 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
81133a40:	defff604 	addi	sp,sp,-40
81133a44:	de00012e 	bgeu	sp,et,81133a4c <sbrk+0xc>
81133a48:	003b68fa 	trap	3
81133a4c:	df000915 	stw	fp,36(sp)
81133a50:	df000904 	addi	fp,sp,36
81133a54:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133a58:	0005303a 	rdctl	r2,status
81133a5c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133a60:	e0fffe17 	ldw	r3,-8(fp)
81133a64:	00bfff84 	movi	r2,-2
81133a68:	1884703a 	and	r2,r3,r2
81133a6c:	1001703a 	wrctl	status,r2
  
  return context;
81133a70:	e0bffe17 	ldw	r2,-8(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
81133a74:	e0bff815 	stw	r2,-32(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
81133a78:	d0a01317 	ldw	r2,-32692(gp)
81133a7c:	10c000c4 	addi	r3,r2,3
81133a80:	00bfff04 	movi	r2,-4
81133a84:	1884703a 	and	r2,r3,r2
81133a88:	d0a01315 	stw	r2,-32692(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
81133a8c:	d0e01317 	ldw	r3,-32692(gp)
81133a90:	e0bfff17 	ldw	r2,-4(fp)
81133a94:	1887883a 	add	r3,r3,r2
81133a98:	00a04834 	movhi	r2,33056
81133a9c:	10a80004 	addi	r2,r2,-24576
81133aa0:	10c0062e 	bgeu	r2,r3,81133abc <sbrk+0x7c>
81133aa4:	e0bff817 	ldw	r2,-32(fp)
81133aa8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133aac:	e0bff717 	ldw	r2,-36(fp)
81133ab0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
81133ab4:	00bfffc4 	movi	r2,-1
81133ab8:	00001c06 	br	81133b2c <sbrk+0xec>
  }
#endif

  prev_heap_end = heap_end; 
81133abc:	d0a01317 	ldw	r2,-32692(gp)
81133ac0:	e0bffa15 	stw	r2,-24(fp)
  heap_end += incr; 
81133ac4:	d0e01317 	ldw	r3,-32692(gp)
81133ac8:	e0bfff17 	ldw	r2,-4(fp)
81133acc:	1885883a 	add	r2,r3,r2
81133ad0:	d0a01315 	stw	r2,-32692(gp)
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_limit (void)
{
  char * limit;
  NIOS2_READ_ET(limit);
81133ad4:	c005883a 	mov	r2,et
81133ad8:	e0bff915 	stw	r2,-28(fp)

  return limit; 
81133adc:	e0fff917 	ldw	r3,-28(fp)
   * pointer overflow. 
   * If the stack limit isn't pointing at the top of the heap then the code
   * is using a different stack so none of this needs to be done.
   */

  if (alt_stack_limit() == prev_heap_end)
81133ae0:	e0bffa17 	ldw	r2,-24(fp)
81133ae4:	18800c1e 	bne	r3,r2,81133b18 <sbrk+0xd8>
 */

static ALT_INLINE char * ALT_ALWAYS_INLINE alt_stack_pointer (void)
{
  char * pointer;
  NIOS2_READ_SP(pointer);
81133ae8:	d805883a 	mov	r2,sp
81133aec:	e0bffb15 	stw	r2,-20(fp)

  return pointer; 
81133af0:	e0bffb17 	ldw	r2,-20(fp)
  {
    if (alt_stack_pointer() <= heap_end)
81133af4:	d0e01317 	ldw	r3,-32692(gp)
81133af8:	18800136 	bltu	r3,r2,81133b00 <sbrk+0xc0>
 * alt_report_stack_overflow reports that a stack overflow happened.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_report_stack_overflow (void)
{
  NIOS2_REPORT_STACK_OVERFLOW();
81133afc:	003da0fa 	break	3
      alt_report_stack_overflow();

    alt_set_stack_limit(heap_end);
81133b00:	d0a01317 	ldw	r2,-32692(gp)
81133b04:	e0bffc15 	stw	r2,-16(fp)
 * limit register.
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_set_stack_limit (char * limit)
{
  alt_stack_limit_value = limit;
81133b08:	e0bffc17 	ldw	r2,-16(fp)
81133b0c:	d0a00015 	stw	r2,-32768(gp)
  NIOS2_WRITE_ET(limit);
81133b10:	e0bffc17 	ldw	r2,-16(fp)
81133b14:	1031883a 	mov	et,r2
81133b18:	e0bff817 	ldw	r2,-32(fp)
81133b1c:	e0bffd15 	stw	r2,-12(fp)
81133b20:	e0bffd17 	ldw	r2,-12(fp)
81133b24:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
81133b28:	e0bffa17 	ldw	r2,-24(fp)
} 
81133b2c:	e037883a 	mov	sp,fp
81133b30:	df000017 	ldw	fp,0(sp)
81133b34:	dec00104 	addi	sp,sp,4
81133b38:	f800283a 	ret

81133b3c <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
81133b3c:	defffa04 	addi	sp,sp,-24
81133b40:	de00012e 	bgeu	sp,et,81133b48 <alt_alarm_stop+0xc>
81133b44:	003b68fa 	trap	3
81133b48:	df000515 	stw	fp,20(sp)
81133b4c:	df000504 	addi	fp,sp,20
81133b50:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81133b54:	0005303a 	rdctl	r2,status
81133b58:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81133b5c:	e0fffc17 	ldw	r3,-16(fp)
81133b60:	00bfff84 	movi	r2,-2
81133b64:	1884703a 	and	r2,r3,r2
81133b68:	1001703a 	wrctl	status,r2
  
  return context;
81133b6c:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
81133b70:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
81133b74:	e0bfff17 	ldw	r2,-4(fp)
81133b78:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
81133b7c:	e0bffd17 	ldw	r2,-12(fp)
81133b80:	10800017 	ldw	r2,0(r2)
81133b84:	e0fffd17 	ldw	r3,-12(fp)
81133b88:	18c00117 	ldw	r3,4(r3)
81133b8c:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
81133b90:	e0bffd17 	ldw	r2,-12(fp)
81133b94:	10800117 	ldw	r2,4(r2)
81133b98:	e0fffd17 	ldw	r3,-12(fp)
81133b9c:	18c00017 	ldw	r3,0(r3)
81133ba0:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
81133ba4:	e0bffd17 	ldw	r2,-12(fp)
81133ba8:	e0fffd17 	ldw	r3,-12(fp)
81133bac:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
81133bb0:	e0bffd17 	ldw	r2,-12(fp)
81133bb4:	e0fffd17 	ldw	r3,-12(fp)
81133bb8:	10c00015 	stw	r3,0(r2)
81133bbc:	e0bffb17 	ldw	r2,-20(fp)
81133bc0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81133bc4:	e0bffe17 	ldw	r2,-8(fp)
81133bc8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
81133bcc:	0001883a 	nop
81133bd0:	e037883a 	mov	sp,fp
81133bd4:	df000017 	ldw	fp,0(sp)
81133bd8:	dec00104 	addi	sp,sp,4
81133bdc:	f800283a 	ret

81133be0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
81133be0:	defffb04 	addi	sp,sp,-20
81133be4:	de00012e 	bgeu	sp,et,81133bec <alt_tick+0xc>
81133be8:	003b68fa 	trap	3
81133bec:	dfc00415 	stw	ra,16(sp)
81133bf0:	df000315 	stw	fp,12(sp)
81133bf4:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
81133bf8:	d0a01417 	ldw	r2,-32688(gp)
81133bfc:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
81133c00:	d0a08517 	ldw	r2,-32236(gp)
81133c04:	10800044 	addi	r2,r2,1
81133c08:	d0a08515 	stw	r2,-32236(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81133c0c:	00002e06 	br	81133cc8 <alt_tick+0xe8>
  {
    next = (alt_alarm*) alarm->llist.next;
81133c10:	e0bffd17 	ldw	r2,-12(fp)
81133c14:	10800017 	ldw	r2,0(r2)
81133c18:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
81133c1c:	e0bffd17 	ldw	r2,-12(fp)
81133c20:	10800403 	ldbu	r2,16(r2)
81133c24:	10803fcc 	andi	r2,r2,255
81133c28:	10000426 	beq	r2,zero,81133c3c <alt_tick+0x5c>
81133c2c:	d0a08517 	ldw	r2,-32236(gp)
81133c30:	1000021e 	bne	r2,zero,81133c3c <alt_tick+0x5c>
    {
      alarm->rollover = 0;
81133c34:	e0bffd17 	ldw	r2,-12(fp)
81133c38:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
81133c3c:	e0bffd17 	ldw	r2,-12(fp)
81133c40:	10800217 	ldw	r2,8(r2)
81133c44:	d0e08517 	ldw	r3,-32236(gp)
81133c48:	18801d36 	bltu	r3,r2,81133cc0 <alt_tick+0xe0>
81133c4c:	e0bffd17 	ldw	r2,-12(fp)
81133c50:	10800403 	ldbu	r2,16(r2)
81133c54:	10803fcc 	andi	r2,r2,255
81133c58:	1000191e 	bne	r2,zero,81133cc0 <alt_tick+0xe0>
    {
      next_callback = alarm->callback (alarm->context);
81133c5c:	e0bffd17 	ldw	r2,-12(fp)
81133c60:	10800317 	ldw	r2,12(r2)
81133c64:	e0fffd17 	ldw	r3,-12(fp)
81133c68:	18c00517 	ldw	r3,20(r3)
81133c6c:	1809883a 	mov	r4,r3
81133c70:	103ee83a 	callr	r2
81133c74:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
81133c78:	e0bfff17 	ldw	r2,-4(fp)
81133c7c:	1000031e 	bne	r2,zero,81133c8c <alt_tick+0xac>
      {
        alt_alarm_stop (alarm);
81133c80:	e13ffd17 	ldw	r4,-12(fp)
81133c84:	1133b3c0 	call	81133b3c <alt_alarm_stop>
81133c88:	00000d06 	br	81133cc0 <alt_tick+0xe0>
      }
      else
      {
        alarm->time += next_callback;
81133c8c:	e0bffd17 	ldw	r2,-12(fp)
81133c90:	10c00217 	ldw	r3,8(r2)
81133c94:	e0bfff17 	ldw	r2,-4(fp)
81133c98:	1887883a 	add	r3,r3,r2
81133c9c:	e0bffd17 	ldw	r2,-12(fp)
81133ca0:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
81133ca4:	e0bffd17 	ldw	r2,-12(fp)
81133ca8:	10c00217 	ldw	r3,8(r2)
81133cac:	d0a08517 	ldw	r2,-32236(gp)
81133cb0:	1880032e 	bgeu	r3,r2,81133cc0 <alt_tick+0xe0>
        {
          alarm->rollover = 1;
81133cb4:	e0bffd17 	ldw	r2,-12(fp)
81133cb8:	00c00044 	movi	r3,1
81133cbc:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
81133cc0:	e0bffe17 	ldw	r2,-8(fp)
81133cc4:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
81133cc8:	e0fffd17 	ldw	r3,-12(fp)
81133ccc:	d0a01404 	addi	r2,gp,-32688
81133cd0:	18bfcf1e 	bne	r3,r2,81133c10 <__reset+0xfb113c10>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
81133cd4:	1134f100 	call	81134f10 <OSTimeTick>
}
81133cd8:	0001883a 	nop
81133cdc:	e037883a 	mov	sp,fp
81133ce0:	dfc00117 	ldw	ra,4(sp)
81133ce4:	df000017 	ldw	fp,0(sp)
81133ce8:	dec00204 	addi	sp,sp,8
81133cec:	f800283a 	ret

81133cf0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
81133cf0:	defffb04 	addi	sp,sp,-20
81133cf4:	de00012e 	bgeu	sp,et,81133cfc <usleep+0xc>
81133cf8:	003b68fa 	trap	3
81133cfc:	dfc00415 	stw	ra,16(sp)
81133d00:	df000315 	stw	fp,12(sp)
81133d04:	df000304 	addi	fp,sp,12
81133d08:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
81133d0c:	d0a08d03 	ldbu	r2,-32204(gp)
81133d10:	10803fcc 	andi	r2,r2,255
81133d14:	1000031e 	bne	r2,zero,81133d24 <usleep+0x34>
  {
    return alt_busy_sleep (us);
81133d18:	e13fff17 	ldw	r4,-4(fp)
81133d1c:	113227c0 	call	8113227c <alt_busy_sleep>
81133d20:	00003d06 	br	81133e18 <usleep+0x128>
81133d24:	d0a08417 	ldw	r2,-32240(gp)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
81133d28:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
81133d2c:	e0ffff17 	ldw	r3,-4(fp)
81133d30:	0090c734 	movhi	r2,17180
81133d34:	10b7a0c4 	addi	r2,r2,-8573
81133d38:	1888383a 	mulxuu	r4,r3,r2
81133d3c:	1885383a 	mul	r2,r3,r2
81133d40:	1013883a 	mov	r9,r2
81133d44:	2015883a 	mov	r10,r4
81133d48:	5006d4ba 	srli	r3,r10,18
81133d4c:	e0bffe17 	ldw	r2,-8(fp)
81133d50:	1893383a 	mul	r9,r3,r2
81133d54:	e0ffff17 	ldw	r3,-4(fp)
81133d58:	0090c734 	movhi	r2,17180
81133d5c:	10b7a0c4 	addi	r2,r2,-8573
81133d60:	1888383a 	mulxuu	r4,r3,r2
81133d64:	1885383a 	mul	r2,r3,r2
81133d68:	100f883a 	mov	r7,r2
81133d6c:	2011883a 	mov	r8,r4
81133d70:	4004d4ba 	srli	r2,r8,18
81133d74:	010003f4 	movhi	r4,15
81133d78:	21109004 	addi	r4,r4,16960
81133d7c:	1105383a 	mul	r2,r2,r4
81133d80:	1885c83a 	sub	r2,r3,r2
81133d84:	e0fffe17 	ldw	r3,-8(fp)
81133d88:	10c7383a 	mul	r3,r2,r3
81133d8c:	0090c734 	movhi	r2,17180
81133d90:	10b7a0c4 	addi	r2,r2,-8573
81133d94:	1888383a 	mulxuu	r4,r3,r2
81133d98:	1885383a 	mul	r2,r3,r2
81133d9c:	100b883a 	mov	r5,r2
81133da0:	200d883a 	mov	r6,r4
81133da4:	3004d4ba 	srli	r2,r6,18
81133da8:	4885883a 	add	r2,r9,r2
81133dac:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81133db0:	00000706 	br	81133dd0 <usleep+0xe0>
  {
    OSTimeDly(0xffff);
81133db4:	013fffd4 	movui	r4,65535
81133db8:	113c9800 	call	8113c980 <OSTimeDly>
    ticks -= 0xffff;
81133dbc:	e0fffd17 	ldw	r3,-12(fp)
81133dc0:	00bffff4 	movhi	r2,65535
81133dc4:	10800044 	addi	r2,r2,1
81133dc8:	1885883a 	add	r2,r3,r2
81133dcc:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
81133dd0:	e0bffd17 	ldw	r2,-12(fp)
81133dd4:	00ffffd4 	movui	r3,65535
81133dd8:	18bff636 	bltu	r3,r2,81133db4 <__reset+0xfb113db4>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
81133ddc:	e0bffd17 	ldw	r2,-12(fp)
81133de0:	10bfffcc 	andi	r2,r2,65535
81133de4:	1009883a 	mov	r4,r2
81133de8:	113c9800 	call	8113c980 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
81133dec:	008003f4 	movhi	r2,15
81133df0:	10909004 	addi	r2,r2,16960
81133df4:	e0fffe17 	ldw	r3,-8(fp)
81133df8:	10c7203a 	divu	r3,r2,r3
81133dfc:	e0bfff17 	ldw	r2,-4(fp)
81133e00:	10c9203a 	divu	r4,r2,r3
81133e04:	20c7383a 	mul	r3,r4,r3
81133e08:	10c5c83a 	sub	r2,r2,r3
81133e0c:	1009883a 	mov	r4,r2
81133e10:	113227c0 	call	8113227c <alt_busy_sleep>

  return 0;  
81133e14:	0005883a 	mov	r2,zero
}
81133e18:	e037883a 	mov	sp,fp
81133e1c:	dfc00117 	ldw	ra,4(sp)
81133e20:	df000017 	ldw	fp,0(sp)
81133e24:	dec00204 	addi	sp,sp,8
81133e28:	f800283a 	ret

81133e2c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81133e2c:	defffe04 	addi	sp,sp,-8
81133e30:	de00012e 	bgeu	sp,et,81133e38 <alt_get_errno+0xc>
81133e34:	003b68fa 	trap	3
81133e38:	dfc00115 	stw	ra,4(sp)
81133e3c:	df000015 	stw	fp,0(sp)
81133e40:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81133e44:	d0a01017 	ldw	r2,-32704(gp)
81133e48:	10000326 	beq	r2,zero,81133e58 <alt_get_errno+0x2c>
81133e4c:	d0a01017 	ldw	r2,-32704(gp)
81133e50:	103ee83a 	callr	r2
81133e54:	00000106 	br	81133e5c <alt_get_errno+0x30>
81133e58:	d0a07404 	addi	r2,gp,-32304
}
81133e5c:	e037883a 	mov	sp,fp
81133e60:	dfc00117 	ldw	ra,4(sp)
81133e64:	df000017 	ldw	fp,0(sp)
81133e68:	dec00204 	addi	sp,sp,8
81133e6c:	f800283a 	ret

81133e70 <write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
81133e70:	defff904 	addi	sp,sp,-28
81133e74:	de00012e 	bgeu	sp,et,81133e7c <write+0xc>
81133e78:	003b68fa 	trap	3
81133e7c:	dfc00615 	stw	ra,24(sp)
81133e80:	df000515 	stw	fp,20(sp)
81133e84:	df000504 	addi	fp,sp,20
81133e88:	e13ffd15 	stw	r4,-12(fp)
81133e8c:	e17ffe15 	stw	r5,-8(fp)
81133e90:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
81133e94:	e0bffd17 	ldw	r2,-12(fp)
81133e98:	10000616 	blt	r2,zero,81133eb4 <write+0x44>
81133e9c:	e0bffd17 	ldw	r2,-12(fp)
81133ea0:	10c00324 	muli	r3,r2,12
81133ea4:	00a04574 	movhi	r2,33045
81133ea8:	10b56a04 	addi	r2,r2,-10840
81133eac:	1885883a 	add	r2,r3,r2
81133eb0:	00000106 	br	81133eb8 <write+0x48>
81133eb4:	0005883a 	mov	r2,zero
81133eb8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
81133ebc:	e0bffb17 	ldw	r2,-20(fp)
81133ec0:	10002426 	beq	r2,zero,81133f54 <write+0xe4>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
81133ec4:	e0bffb17 	ldw	r2,-20(fp)
81133ec8:	10800217 	ldw	r2,8(r2)
81133ecc:	108000cc 	andi	r2,r2,3
81133ed0:	10001b26 	beq	r2,zero,81133f40 <write+0xd0>
81133ed4:	e0bffb17 	ldw	r2,-20(fp)
81133ed8:	10800017 	ldw	r2,0(r2)
81133edc:	10800617 	ldw	r2,24(r2)
81133ee0:	10001726 	beq	r2,zero,81133f40 <write+0xd0>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);
81133ee4:	e17fff17 	ldw	r5,-4(fp)
81133ee8:	e13ffe17 	ldw	r4,-8(fp)
81133eec:	11331f00 	call	811331f0 <alt_log_write>

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
81133ef0:	e0bffb17 	ldw	r2,-20(fp)
81133ef4:	10800017 	ldw	r2,0(r2)
81133ef8:	10800617 	ldw	r2,24(r2)
81133efc:	e0ffff17 	ldw	r3,-4(fp)
81133f00:	180d883a 	mov	r6,r3
81133f04:	e17ffe17 	ldw	r5,-8(fp)
81133f08:	e13ffb17 	ldw	r4,-20(fp)
81133f0c:	103ee83a 	callr	r2
81133f10:	e0bffc15 	stw	r2,-16(fp)
81133f14:	e0bffc17 	ldw	r2,-16(fp)
81133f18:	1000070e 	bge	r2,zero,81133f38 <write+0xc8>
      {
        ALT_ERRNO = -rval;
81133f1c:	1133e2c0 	call	81133e2c <alt_get_errno>
81133f20:	1007883a 	mov	r3,r2
81133f24:	e0bffc17 	ldw	r2,-16(fp)
81133f28:	0085c83a 	sub	r2,zero,r2
81133f2c:	18800015 	stw	r2,0(r3)
        return -1;
81133f30:	00bfffc4 	movi	r2,-1
81133f34:	00000c06 	br	81133f68 <write+0xf8>
      }
      return rval;
81133f38:	e0bffc17 	ldw	r2,-16(fp)
81133f3c:	00000a06 	br	81133f68 <write+0xf8>
    }
    else
    {
      ALT_ERRNO = EACCES;
81133f40:	1133e2c0 	call	81133e2c <alt_get_errno>
81133f44:	1007883a 	mov	r3,r2
81133f48:	00800344 	movi	r2,13
81133f4c:	18800015 	stw	r2,0(r3)
81133f50:	00000406 	br	81133f64 <write+0xf4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
81133f54:	1133e2c0 	call	81133e2c <alt_get_errno>
81133f58:	1007883a 	mov	r3,r2
81133f5c:	00801444 	movi	r2,81
81133f60:	18800015 	stw	r2,0(r3)
  }
  return -1;
81133f64:	00bfffc4 	movi	r2,-1
}
81133f68:	e037883a 	mov	sp,fp
81133f6c:	dfc00117 	ldw	ra,4(sp)
81133f70:	df000017 	ldw	fp,0(sp)
81133f74:	dec00204 	addi	sp,sp,8
81133f78:	f800283a 	ret

81133f7c <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
81133f7c:	deffde04 	addi	sp,sp,-136
81133f80:	de00012e 	bgeu	sp,et,81133f88 <__env_lock+0xc>
81133f84:	003b68fa 	trap	3
81133f88:	dfc02115 	stw	ra,132(sp)
81133f8c:	df002015 	stw	fp,128(sp)
81133f90:	df002004 	addi	fp,sp,128
81133f94:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
81133f98:	e0bfe104 	addi	r2,fp,-124
81133f9c:	100b883a 	mov	r5,r2
81133fa0:	01003fc4 	movi	r4,255
81133fa4:	113c7dc0 	call	8113c7dc <OSTaskQuery>
81133fa8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
81133fac:	e0bffe83 	ldbu	r2,-6(fp)
81133fb0:	10803fcc 	andi	r2,r2,255
81133fb4:	10001e1e 	bne	r2,zero,81134030 <__env_lock+0xb4>
    return;

  id = tcb.OSTCBPrio;
81133fb8:	e0bfed83 	ldbu	r2,-74(fp)
81133fbc:	10803fcc 	andi	r2,r2,255
81133fc0:	e0bfe015 	stw	r2,-128(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
81133fc4:	d0a08717 	ldw	r2,-32228(gp)
81133fc8:	e0fffc04 	addi	r3,fp,-16
81133fcc:	180b883a 	mov	r5,r3
81133fd0:	1009883a 	mov	r4,r2
81133fd4:	113af940 	call	8113af94 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
81133fd8:	e0bffe03 	ldbu	r2,-8(fp)
81133fdc:	10803fcc 	andi	r2,r2,255
81133fe0:	10000726 	beq	r2,zero,81134000 <__env_lock+0x84>
81133fe4:	d0a01617 	ldw	r2,-32680(gp)
81133fe8:	e0ffe017 	ldw	r3,-128(fp)
81133fec:	1880041e 	bne	r3,r2,81134000 <__env_lock+0x84>
  {
    /* we do; just count the recursion */

    locks++;
81133ff0:	d0a08617 	ldw	r2,-32232(gp)
81133ff4:	10800044 	addi	r2,r2,1
81133ff8:	d0a08615 	stw	r2,-32232(gp)
81133ffc:	00000a06 	br	81134028 <__env_lock+0xac>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
81134000:	d0a08717 	ldw	r2,-32228(gp)
81134004:	e0fffe84 	addi	r3,fp,-6
81134008:	180d883a 	mov	r6,r3
8113400c:	000b883a 	mov	r5,zero
81134010:	1009883a 	mov	r4,r2
81134014:	113aaf40 	call	8113aaf4 <OSSemPend>
    locks  = 1;
81134018:	00800044 	movi	r2,1
8113401c:	d0a08615 	stw	r2,-32232(gp)
    lockid = id;
81134020:	e0bfe017 	ldw	r2,-128(fp)
81134024:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
81134028:	0001883a 	nop
8113402c:	00000106 	br	81134034 <__env_lock+0xb8>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
81134030:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
81134034:	e037883a 	mov	sp,fp
81134038:	dfc00117 	ldw	ra,4(sp)
8113403c:	df000017 	ldw	fp,0(sp)
81134040:	dec00204 	addi	sp,sp,8
81134044:	f800283a 	ret

81134048 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
81134048:	defffd04 	addi	sp,sp,-12
8113404c:	de00012e 	bgeu	sp,et,81134054 <__env_unlock+0xc>
81134050:	003b68fa 	trap	3
81134054:	dfc00215 	stw	ra,8(sp)
81134058:	df000115 	stw	fp,4(sp)
8113405c:	df000104 	addi	fp,sp,4
81134060:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
81134064:	d0a08617 	ldw	r2,-32232(gp)
81134068:	10000b26 	beq	r2,zero,81134098 <__env_unlock+0x50>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
8113406c:	d0a08617 	ldw	r2,-32232(gp)
81134070:	10bfffc4 	addi	r2,r2,-1
81134074:	d0a08615 	stw	r2,-32232(gp)
81134078:	d0a08617 	ldw	r2,-32232(gp)
8113407c:	1000071e 	bne	r2,zero,8113409c <__env_unlock+0x54>
  {
    lockid = -1;
81134080:	00bfffc4 	movi	r2,-1
81134084:	d0a01615 	stw	r2,-32680(gp)
    OSSemPost( alt_envsem );
81134088:	d0a08717 	ldw	r2,-32228(gp)
8113408c:	1009883a 	mov	r4,r2
81134090:	113ae7c0 	call	8113ae7c <OSSemPost>
81134094:	00000106 	br	8113409c <__env_unlock+0x54>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
81134098:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
8113409c:	e037883a 	mov	sp,fp
811340a0:	dfc00117 	ldw	ra,4(sp)
811340a4:	df000017 	ldw	fp,0(sp)
811340a8:	dec00204 	addi	sp,sp,8
811340ac:	f800283a 	ret

811340b0 <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
811340b0:	deffda04 	addi	sp,sp,-152
811340b4:	de00012e 	bgeu	sp,et,811340bc <__malloc_lock+0xc>
811340b8:	003b68fa 	trap	3
811340bc:	dfc02515 	stw	ra,148(sp)
811340c0:	df002415 	stw	fp,144(sp)
811340c4:	df002404 	addi	fp,sp,144
811340c8:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811340cc:	e03fdc15 	stw	zero,-144(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
811340d0:	d0a08d03 	ldbu	r2,-32204(gp)
811340d4:	10803fcc 	andi	r2,r2,255
811340d8:	10800060 	cmpeqi	r2,r2,1
811340dc:	10003626 	beq	r2,zero,811341b8 <__malloc_lock+0x108>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
811340e0:	e0bfe104 	addi	r2,fp,-124
811340e4:	100b883a 	mov	r5,r2
811340e8:	01003fc4 	movi	r4,255
811340ec:	113c7dc0 	call	8113c7dc <OSTaskQuery>
811340f0:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
811340f4:	e0bffe83 	ldbu	r2,-6(fp)
811340f8:	10803fcc 	andi	r2,r2,255
811340fc:	1000301e 	bne	r2,zero,811341c0 <__malloc_lock+0x110>
    return;

  id = tcb.OSTCBPrio;
81134100:	e0bfed83 	ldbu	r2,-74(fp)
81134104:	10803fcc 	andi	r2,r2,255
81134108:	e0bfdd15 	stw	r2,-140(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
8113410c:	d0a08917 	ldw	r2,-32220(gp)
81134110:	e0fffc04 	addi	r3,fp,-16
81134114:	180b883a 	mov	r5,r3
81134118:	1009883a 	mov	r4,r2
8113411c:	113af940 	call	8113af94 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134120:	0005303a 	rdctl	r2,status
81134124:	e0bfe015 	stw	r2,-128(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134128:	e0ffe017 	ldw	r3,-128(fp)
8113412c:	00bfff84 	movi	r2,-2
81134130:	1884703a 	and	r2,r3,r2
81134134:	1001703a 	wrctl	status,r2
  
  return context;
81134138:	e0bfe017 	ldw	r2,-128(fp)
  
  OS_ENTER_CRITICAL();
8113413c:	e0bfdc15 	stw	r2,-144(fp)

  if( !semdata.OSCnt && id == lockid ) 
81134140:	e0bffc0b 	ldhu	r2,-16(fp)
81134144:	10bfffcc 	andi	r2,r2,65535
81134148:	10000b1e 	bne	r2,zero,81134178 <__malloc_lock+0xc8>
8113414c:	d0a01717 	ldw	r2,-32676(gp)
81134150:	e0ffdd17 	ldw	r3,-140(fp)
81134154:	1880081e 	bne	r3,r2,81134178 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
81134158:	d0a08817 	ldw	r2,-32224(gp)
8113415c:	10800044 	addi	r2,r2,1
81134160:	d0a08815 	stw	r2,-32224(gp)
81134164:	e0bfdc17 	ldw	r2,-144(fp)
81134168:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113416c:	e0bfde17 	ldw	r2,-136(fp)
81134170:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
81134174:	00000e06 	br	811341b0 <__malloc_lock+0x100>
81134178:	e0bfdc17 	ldw	r2,-144(fp)
8113417c:	e0bfdf15 	stw	r2,-132(fp)
81134180:	e0bfdf17 	ldw	r2,-132(fp)
81134184:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
81134188:	d0a08917 	ldw	r2,-32220(gp)
8113418c:	e0fffe84 	addi	r3,fp,-6
81134190:	180d883a 	mov	r6,r3
81134194:	000b883a 	mov	r5,zero
81134198:	1009883a 	mov	r4,r2
8113419c:	113aaf40 	call	8113aaf4 <OSSemPend>
    locks  = 1;
811341a0:	00800044 	movi	r2,1
811341a4:	d0a08815 	stw	r2,-32224(gp)
    lockid = id;
811341a8:	e0bfdd17 	ldw	r2,-140(fp)
811341ac:	d0a01715 	stw	r2,-32676(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
811341b0:	0001883a 	nop
811341b4:	00000306 	br	811341c4 <__malloc_lock+0x114>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif  
  
  if (OSRunning != OS_TRUE)
      return;
811341b8:	0001883a 	nop
811341bc:	00000106 	br	811341c4 <__malloc_lock+0x114>

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
  if (err != OS_NO_ERR)
    return;
811341c0:	0001883a 	nop
    lockid = id;
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
811341c4:	e037883a 	mov	sp,fp
811341c8:	dfc00117 	ldw	ra,4(sp)
811341cc:	df000017 	ldw	fp,0(sp)
811341d0:	dec00204 	addi	sp,sp,8
811341d4:	f800283a 	ret

811341d8 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
811341d8:	defff804 	addi	sp,sp,-32
811341dc:	de00012e 	bgeu	sp,et,811341e4 <__malloc_unlock+0xc>
811341e0:	003b68fa 	trap	3
811341e4:	dfc00715 	stw	ra,28(sp)
811341e8:	df000615 	stw	fp,24(sp)
811341ec:	df000604 	addi	fp,sp,24
811341f0:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811341f4:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
811341f8:	d0a08d03 	ldbu	r2,-32204(gp)
811341fc:	10803fcc 	andi	r2,r2,255
81134200:	10800060 	cmpeqi	r2,r2,1
81134204:	10002326 	beq	r2,zero,81134294 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134208:	0005303a 	rdctl	r2,status
8113420c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134210:	e0fffe17 	ldw	r3,-8(fp)
81134214:	00bfff84 	movi	r2,-2
81134218:	1884703a 	and	r2,r3,r2
8113421c:	1001703a 	wrctl	status,r2
  
  return context;
81134220:	e0bffe17 	ldw	r2,-8(fp)
      return;

  OS_ENTER_CRITICAL();
81134224:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
81134228:	d0a08817 	ldw	r2,-32224(gp)
8113422c:	1000051e 	bne	r2,zero,81134244 <__malloc_unlock+0x6c>
81134230:	e0bffa17 	ldw	r2,-24(fp)
81134234:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134238:	e0bffb17 	ldw	r2,-20(fp)
8113423c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
81134240:	00001506 	br	81134298 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
81134244:	d0a08817 	ldw	r2,-32224(gp)
81134248:	10bfffc4 	addi	r2,r2,-1
8113424c:	d0a08815 	stw	r2,-32224(gp)
81134250:	d0a08817 	ldw	r2,-32224(gp)
81134254:	10000a1e 	bne	r2,zero,81134280 <__malloc_unlock+0xa8>
  {
    lockid = -1;
81134258:	00bfffc4 	movi	r2,-1
8113425c:	d0a01715 	stw	r2,-32676(gp)
81134260:	e0bffa17 	ldw	r2,-24(fp)
81134264:	e0bffc15 	stw	r2,-16(fp)
81134268:	e0bffc17 	ldw	r2,-16(fp)
8113426c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
81134270:	d0a08917 	ldw	r2,-32220(gp)
81134274:	1009883a 	mov	r4,r2
81134278:	113ae7c0 	call	8113ae7c <OSSemPost>
8113427c:	00000606 	br	81134298 <__malloc_unlock+0xc0>
81134280:	e0bffa17 	ldw	r2,-24(fp)
81134284:	e0bffd15 	stw	r2,-12(fp)
81134288:	e0bffd17 	ldw	r2,-12(fp)
8113428c:	1001703a 	wrctl	status,r2
81134290:	00000106 	br	81134298 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
81134294:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
81134298:	e037883a 	mov	sp,fp
8113429c:	dfc00117 	ldw	ra,4(sp)
811342a0:	df000017 	ldw	fp,0(sp)
811342a4:	dec00204 	addi	sp,sp,8
811342a8:	f800283a 	ret

811342ac <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811342ac:	defff704 	addi	sp,sp,-36
811342b0:	de00012e 	bgeu	sp,et,811342b8 <OSEventNameGet+0xc>
811342b4:	003b68fa 	trap	3
811342b8:	dfc00815 	stw	ra,32(sp)
811342bc:	df000715 	stw	fp,28(sp)
811342c0:	df000704 	addi	fp,sp,28
811342c4:	e13ffd15 	stw	r4,-12(fp)
811342c8:	e17ffe15 	stw	r5,-8(fp)
811342cc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811342d0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811342d4:	e0bfff17 	ldw	r2,-4(fp)
811342d8:	1000021e 	bne	r2,zero,811342e4 <OSEventNameGet+0x38>
        return (0);
811342dc:	0005883a 	mov	r2,zero
811342e0:	00003706 	br	811343c0 <OSEventNameGet+0x114>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
811342e4:	e0bffd17 	ldw	r2,-12(fp)
811342e8:	1000051e 	bne	r2,zero,81134300 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
811342ec:	e0bfff17 	ldw	r2,-4(fp)
811342f0:	00c00104 	movi	r3,4
811342f4:	10c00005 	stb	r3,0(r2)
        return (0);
811342f8:	0005883a 	mov	r2,zero
811342fc:	00003006 	br	811343c0 <OSEventNameGet+0x114>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81134300:	e0bffe17 	ldw	r2,-8(fp)
81134304:	1000051e 	bne	r2,zero,8113431c <OSEventNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81134308:	e0bfff17 	ldw	r2,-4(fp)
8113430c:	00c00304 	movi	r3,12
81134310:	10c00005 	stb	r3,0(r2)
        return (0);
81134314:	0005883a 	mov	r2,zero
81134318:	00002906 	br	811343c0 <OSEventNameGet+0x114>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113431c:	d0a09d03 	ldbu	r2,-32140(gp)
81134320:	10803fcc 	andi	r2,r2,255
81134324:	10000526 	beq	r2,zero,8113433c <OSEventNameGet+0x90>
        *perr  = OS_ERR_NAME_GET_ISR;
81134328:	e0bfff17 	ldw	r2,-4(fp)
8113432c:	00c00444 	movi	r3,17
81134330:	10c00005 	stb	r3,0(r2)
        return (0);
81134334:	0005883a 	mov	r2,zero
81134338:	00002106 	br	811343c0 <OSEventNameGet+0x114>
    }
    switch (pevent->OSEventType) {
8113433c:	e0bffd17 	ldw	r2,-12(fp)
81134340:	10800003 	ldbu	r2,0(r2)
81134344:	10803fcc 	andi	r2,r2,255
81134348:	10bfffc4 	addi	r2,r2,-1
8113434c:	10800128 	cmpgeui	r2,r2,4
81134350:	10000526 	beq	r2,zero,81134368 <OSEventNameGet+0xbc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81134354:	e0bfff17 	ldw	r2,-4(fp)
81134358:	00c00044 	movi	r3,1
8113435c:	10c00005 	stb	r3,0(r2)
             return (0);
81134360:	0005883a 	mov	r2,zero
81134364:	00001606 	br	811343c0 <OSEventNameGet+0x114>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81134368:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113436c:	0005303a 	rdctl	r2,status
81134370:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134374:	e0fffb17 	ldw	r3,-20(fp)
81134378:	00bfff84 	movi	r2,-2
8113437c:	1884703a 	and	r2,r3,r2
81134380:	1001703a 	wrctl	status,r2
  
  return context;
81134384:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
81134388:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
8113438c:	e0bffd17 	ldw	r2,-12(fp)
81134390:	10800444 	addi	r2,r2,17
81134394:	100b883a 	mov	r5,r2
81134398:	e13ffe17 	ldw	r4,-8(fp)
8113439c:	1135d980 	call	81135d98 <OS_StrCopy>
811343a0:	e0bffa05 	stb	r2,-24(fp)
811343a4:	e0bff917 	ldw	r2,-28(fp)
811343a8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811343ac:	e0bffc17 	ldw	r2,-16(fp)
811343b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811343b4:	e0bfff17 	ldw	r2,-4(fp)
811343b8:	10000005 	stb	zero,0(r2)
    return (len);
811343bc:	e0bffa03 	ldbu	r2,-24(fp)
}
811343c0:	e037883a 	mov	sp,fp
811343c4:	dfc00117 	ldw	ra,4(sp)
811343c8:	df000017 	ldw	fp,0(sp)
811343cc:	dec00204 	addi	sp,sp,8
811343d0:	f800283a 	ret

811343d4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
811343d4:	defff604 	addi	sp,sp,-40
811343d8:	de00012e 	bgeu	sp,et,811343e0 <OSEventNameSet+0xc>
811343dc:	003b68fa 	trap	3
811343e0:	dfc00915 	stw	ra,36(sp)
811343e4:	df000815 	stw	fp,32(sp)
811343e8:	df000804 	addi	fp,sp,32
811343ec:	e13ffd15 	stw	r4,-12(fp)
811343f0:	e17ffe15 	stw	r5,-8(fp)
811343f4:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811343f8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811343fc:	e0bfff17 	ldw	r2,-4(fp)
81134400:	10004026 	beq	r2,zero,81134504 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
81134404:	e0bffd17 	ldw	r2,-12(fp)
81134408:	1000041e 	bne	r2,zero,8113441c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113440c:	e0bfff17 	ldw	r2,-4(fp)
81134410:	00c00104 	movi	r3,4
81134414:	10c00005 	stb	r3,0(r2)
        return;
81134418:	00003b06 	br	81134508 <OSEventNameSet+0x134>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
8113441c:	e0bffe17 	ldw	r2,-8(fp)
81134420:	1000041e 	bne	r2,zero,81134434 <OSEventNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81134424:	e0bfff17 	ldw	r2,-4(fp)
81134428:	00c00304 	movi	r3,12
8113442c:	10c00005 	stb	r3,0(r2)
        return;
81134430:	00003506 	br	81134508 <OSEventNameSet+0x134>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81134434:	d0a09d03 	ldbu	r2,-32140(gp)
81134438:	10803fcc 	andi	r2,r2,255
8113443c:	10000426 	beq	r2,zero,81134450 <OSEventNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81134440:	e0bfff17 	ldw	r2,-4(fp)
81134444:	00c00484 	movi	r3,18
81134448:	10c00005 	stb	r3,0(r2)
        return;
8113444c:	00002e06 	br	81134508 <OSEventNameSet+0x134>
    }
    switch (pevent->OSEventType) {
81134450:	e0bffd17 	ldw	r2,-12(fp)
81134454:	10800003 	ldbu	r2,0(r2)
81134458:	10803fcc 	andi	r2,r2,255
8113445c:	10bfffc4 	addi	r2,r2,-1
81134460:	10800128 	cmpgeui	r2,r2,4
81134464:	10000426 	beq	r2,zero,81134478 <OSEventNameSet+0xa4>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
81134468:	e0bfff17 	ldw	r2,-4(fp)
8113446c:	00c00044 	movi	r3,1
81134470:	10c00005 	stb	r3,0(r2)
             return;
81134474:	00002406 	br	81134508 <OSEventNameSet+0x134>
    switch (pevent->OSEventType) {
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
81134478:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113447c:	0005303a 	rdctl	r2,status
81134480:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134484:	e0fffc17 	ldw	r3,-16(fp)
81134488:	00bfff84 	movi	r2,-2
8113448c:	1884703a 	and	r2,r3,r2
81134490:	1001703a 	wrctl	status,r2
  
  return context;
81134494:	e0bffc17 	ldw	r2,-16(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
81134498:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
8113449c:	e13ffe17 	ldw	r4,-8(fp)
811344a0:	1135e140 	call	81135e14 <OS_StrLen>
811344a4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
811344a8:	e0bffa03 	ldbu	r2,-24(fp)
811344ac:	10800830 	cmpltui	r2,r2,32
811344b0:	1000081e 	bne	r2,zero,811344d4 <OSEventNameSet+0x100>
811344b4:	e0bff817 	ldw	r2,-32(fp)
811344b8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811344bc:	e0bff917 	ldw	r2,-28(fp)
811344c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
811344c4:	e0bfff17 	ldw	r2,-4(fp)
811344c8:	00c002c4 	movi	r3,11
811344cc:	10c00005 	stb	r3,0(r2)
        return;
811344d0:	00000d06 	br	81134508 <OSEventNameSet+0x134>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
811344d4:	e0bffd17 	ldw	r2,-12(fp)
811344d8:	10800444 	addi	r2,r2,17
811344dc:	e17ffe17 	ldw	r5,-8(fp)
811344e0:	1009883a 	mov	r4,r2
811344e4:	1135d980 	call	81135d98 <OS_StrCopy>
811344e8:	e0bff817 	ldw	r2,-32(fp)
811344ec:	e0bffb15 	stw	r2,-20(fp)
811344f0:	e0bffb17 	ldw	r2,-20(fp)
811344f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811344f8:	e0bfff17 	ldw	r2,-4(fp)
811344fc:	10000005 	stb	zero,0(r2)
81134500:	00000106 	br	81134508 <OSEventNameSet+0x134>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81134504:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
81134508:	e037883a 	mov	sp,fp
8113450c:	dfc00117 	ldw	ra,4(sp)
81134510:	df000017 	ldw	fp,0(sp)
81134514:	dec00204 	addi	sp,sp,8
81134518:	f800283a 	ret

8113451c <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
8113451c:	deffed04 	addi	sp,sp,-76
81134520:	de00012e 	bgeu	sp,et,81134528 <OSEventPendMulti+0xc>
81134524:	003b68fa 	trap	3
81134528:	dfc01215 	stw	ra,72(sp)
8113452c:	df001115 	stw	fp,68(sp)
81134530:	df001104 	addi	fp,sp,68
81134534:	e13ffc15 	stw	r4,-16(fp)
81134538:	e17ffd15 	stw	r5,-12(fp)
8113453c:	e1bffe15 	stw	r6,-8(fp)
81134540:	3805883a 	mov	r2,r7
81134544:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
81134548:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
8113454c:	e0800217 	ldw	r2,8(fp)
81134550:	1000021e 	bne	r2,zero,8113455c <OSEventPendMulti+0x40>
        return (0);
81134554:	0005883a 	mov	r2,zero
81134558:	00015006 	br	81134a9c <OSEventPendMulti+0x580>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
8113455c:	e0bffc17 	ldw	r2,-16(fp)
81134560:	1000051e 	bne	r2,zero,81134578 <OSEventPendMulti+0x5c>
       *perr =  OS_ERR_PEVENT_NULL;
81134564:	e0800217 	ldw	r2,8(fp)
81134568:	00c00104 	movi	r3,4
8113456c:	10c00005 	stb	r3,0(r2)
        return (0);
81134570:	0005883a 	mov	r2,zero
81134574:	00014906 	br	81134a9c <OSEventPendMulti+0x580>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
81134578:	e0bffd17 	ldw	r2,-12(fp)
8113457c:	1000051e 	bne	r2,zero,81134594 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
81134580:	e0800217 	ldw	r2,8(fp)
81134584:	00c00104 	movi	r3,4
81134588:	10c00005 	stb	r3,0(r2)
        return (0);
8113458c:	0005883a 	mov	r2,zero
81134590:	00014206 	br	81134a9c <OSEventPendMulti+0x580>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
81134594:	e0bffe17 	ldw	r2,-8(fp)
81134598:	1000051e 	bne	r2,zero,811345b0 <OSEventPendMulti+0x94>
       *perr =  OS_ERR_PEVENT_NULL;
8113459c:	e0800217 	ldw	r2,8(fp)
811345a0:	00c00104 	movi	r3,4
811345a4:	10c00005 	stb	r3,0(r2)
        return (0);
811345a8:	0005883a 	mov	r2,zero
811345ac:	00013b06 	br	81134a9c <OSEventPendMulti+0x580>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
811345b0:	e0bffd17 	ldw	r2,-12(fp)
811345b4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
811345b8:	e0bffc17 	ldw	r2,-16(fp)
811345bc:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
811345c0:	e0bfef17 	ldw	r2,-68(fp)
811345c4:	10800017 	ldw	r2,0(r2)
811345c8:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
811345cc:	00001506 	br	81134624 <OSEventPendMulti+0x108>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
811345d0:	e0bff017 	ldw	r2,-64(fp)
811345d4:	10800003 	ldbu	r2,0(r2)
811345d8:	10803fcc 	andi	r2,r2,255
811345dc:	10c000a0 	cmpeqi	r3,r2,2
811345e0:	1800071e 	bne	r3,zero,81134600 <OSEventPendMulti+0xe4>
811345e4:	108000e0 	cmpeqi	r2,r2,3
811345e8:	1000071e 	bne	r2,zero,81134608 <OSEventPendMulti+0xec>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
811345ec:	e0800217 	ldw	r2,8(fp)
811345f0:	00c00044 	movi	r3,1
811345f4:	10c00005 	stb	r3,0(r2)
                 return (0);
811345f8:	0005883a 	mov	r2,zero
811345fc:	00012706 	br	81134a9c <OSEventPendMulti+0x580>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
81134600:	0001883a 	nop
81134604:	00000106 	br	8113460c <OSEventPendMulti+0xf0>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
81134608:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
8113460c:	e0bfef17 	ldw	r2,-68(fp)
81134610:	10800104 	addi	r2,r2,4
81134614:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81134618:	e0bfef17 	ldw	r2,-68(fp)
8113461c:	10800017 	ldw	r2,0(r2)
81134620:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
81134624:	e0bff017 	ldw	r2,-64(fp)
81134628:	103fe91e 	bne	r2,zero,811345d0 <__reset+0xfb1145d0>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
8113462c:	d0a09d03 	ldbu	r2,-32140(gp)
81134630:	10803fcc 	andi	r2,r2,255
81134634:	10000526 	beq	r2,zero,8113464c <OSEventPendMulti+0x130>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
81134638:	e0800217 	ldw	r2,8(fp)
8113463c:	00c00084 	movi	r3,2
81134640:	10c00005 	stb	r3,0(r2)
        return (0);
81134644:	0005883a 	mov	r2,zero
81134648:	00011406 	br	81134a9c <OSEventPendMulti+0x580>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
8113464c:	d0a08b03 	ldbu	r2,-32212(gp)
81134650:	10803fcc 	andi	r2,r2,255
81134654:	10000526 	beq	r2,zero,8113466c <OSEventPendMulti+0x150>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
81134658:	e0800217 	ldw	r2,8(fp)
8113465c:	00c00344 	movi	r3,13
81134660:	10c00005 	stb	r3,0(r2)
        return (0);
81134664:	0005883a 	mov	r2,zero
81134668:	00010c06 	br	81134a9c <OSEventPendMulti+0x580>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113466c:	0005303a 	rdctl	r2,status
81134670:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134674:	e0fffb17 	ldw	r3,-20(fp)
81134678:	00bfff84 	movi	r2,-2
8113467c:	1884703a 	and	r2,r3,r2
81134680:	1001703a 	wrctl	status,r2
  
  return context;
81134684:	e0bffb17 	ldw	r2,-20(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
81134688:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
8113468c:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
81134690:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
81134694:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
81134698:	e0bffc17 	ldw	r2,-16(fp)
8113469c:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
811346a0:	e0bfef17 	ldw	r2,-68(fp)
811346a4:	10800017 	ldw	r2,0(r2)
811346a8:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
811346ac:	00006406 	br	81134840 <OSEventPendMulti+0x324>
        switch (pevent->OSEventType) {
811346b0:	e0bff017 	ldw	r2,-64(fp)
811346b4:	10800003 	ldbu	r2,0(r2)
811346b8:	10803fcc 	andi	r2,r2,255
811346bc:	10c000a0 	cmpeqi	r3,r2,2
811346c0:	18001f1e 	bne	r3,zero,81134740 <OSEventPendMulti+0x224>
811346c4:	108000e0 	cmpeqi	r2,r2,3
811346c8:	10004c26 	beq	r2,zero,811347fc <OSEventPendMulti+0x2e0>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
811346cc:	e0bff017 	ldw	r2,-64(fp)
811346d0:	1080020b 	ldhu	r2,8(r2)
811346d4:	10bfffcc 	andi	r2,r2,65535
811346d8:	10001526 	beq	r2,zero,81134730 <OSEventPendMulti+0x214>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
811346dc:	e0bff017 	ldw	r2,-64(fp)
811346e0:	1080020b 	ldhu	r2,8(r2)
811346e4:	10bfffc4 	addi	r2,r2,-1
811346e8:	1007883a 	mov	r3,r2
811346ec:	e0bff017 	ldw	r2,-64(fp)
811346f0:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
811346f4:	e0bffd17 	ldw	r2,-12(fp)
811346f8:	10c00104 	addi	r3,r2,4
811346fc:	e0fffd15 	stw	r3,-12(fp)
81134700:	e0fff017 	ldw	r3,-64(fp)
81134704:	10c00015 	stw	r3,0(r2)
                      events_rdy   =  OS_TRUE;
81134708:	00800044 	movi	r2,1
8113470c:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
81134710:	e0bffe17 	ldw	r2,-8(fp)
81134714:	10c00104 	addi	r3,r2,4
81134718:	e0fffe15 	stw	r3,-8(fp)
8113471c:	10000015 	stw	zero,0(r2)
                      events_rdy_nbr++;
81134720:	e0bff18b 	ldhu	r2,-58(fp)
81134724:	10800044 	addi	r2,r2,1
81134728:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
8113472c:	00003e06 	br	81134828 <OSEventPendMulti+0x30c>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
81134730:	e0bff203 	ldbu	r2,-56(fp)
81134734:	10800054 	ori	r2,r2,1
81134738:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
8113473c:	00003a06 	br	81134828 <OSEventPendMulti+0x30c>
                 break;
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
81134740:	e0bff017 	ldw	r2,-64(fp)
81134744:	10800117 	ldw	r2,4(r2)
81134748:	e0bff515 	stw	r2,-44(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
8113474c:	e0bff517 	ldw	r2,-44(fp)
81134750:	1080058b 	ldhu	r2,22(r2)
81134754:	10bfffcc 	andi	r2,r2,65535
81134758:	10002426 	beq	r2,zero,811347ec <OSEventPendMulti+0x2d0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
8113475c:	e0bffe17 	ldw	r2,-8(fp)
81134760:	10c00104 	addi	r3,r2,4
81134764:	e0fffe15 	stw	r3,-8(fp)
81134768:	e0fff517 	ldw	r3,-44(fp)
8113476c:	18c00417 	ldw	r3,16(r3)
81134770:	19400104 	addi	r5,r3,4
81134774:	e13ff517 	ldw	r4,-44(fp)
81134778:	21400415 	stw	r5,16(r4)
8113477c:	18c00017 	ldw	r3,0(r3)
81134780:	10c00015 	stw	r3,0(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
81134784:	e0bff517 	ldw	r2,-44(fp)
81134788:	10c00417 	ldw	r3,16(r2)
8113478c:	e0bff517 	ldw	r2,-44(fp)
81134790:	10800217 	ldw	r2,8(r2)
81134794:	1880041e 	bne	r3,r2,811347a8 <OSEventPendMulti+0x28c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
81134798:	e0bff517 	ldw	r2,-44(fp)
8113479c:	10c00117 	ldw	r3,4(r2)
811347a0:	e0bff517 	ldw	r2,-44(fp)
811347a4:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
811347a8:	e0bff517 	ldw	r2,-44(fp)
811347ac:	1080058b 	ldhu	r2,22(r2)
811347b0:	10bfffc4 	addi	r2,r2,-1
811347b4:	1007883a 	mov	r3,r2
811347b8:	e0bff517 	ldw	r2,-44(fp)
811347bc:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
811347c0:	e0bffd17 	ldw	r2,-12(fp)
811347c4:	10c00104 	addi	r3,r2,4
811347c8:	e0fffd15 	stw	r3,-12(fp)
811347cc:	e0fff017 	ldw	r3,-64(fp)
811347d0:	10c00015 	stw	r3,0(r2)
                      events_rdy   = OS_TRUE;
811347d4:	00800044 	movi	r2,1
811347d8:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
811347dc:	e0bff18b 	ldhu	r2,-58(fp)
811347e0:	10800044 	addi	r2,r2,1
811347e4:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
811347e8:	00000f06 	br	81134828 <OSEventPendMulti+0x30c>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
811347ec:	e0bff203 	ldbu	r2,-56(fp)
811347f0:	10800114 	ori	r2,r2,4
811347f4:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
811347f8:	00000b06 	br	81134828 <OSEventPendMulti+0x30c>
811347fc:	e0bff317 	ldw	r2,-52(fp)
81134800:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134804:	e0bff417 	ldw	r2,-48(fp)
81134808:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
8113480c:	e0bffd17 	ldw	r2,-12(fp)
81134810:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
81134814:	e0800217 	ldw	r2,8(fp)
81134818:	00c00044 	movi	r3,1
8113481c:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
81134820:	e0bff18b 	ldhu	r2,-58(fp)
81134824:	00009d06 	br	81134a9c <OSEventPendMulti+0x580>
        }
        pevents++;
81134828:	e0bfef17 	ldw	r2,-68(fp)
8113482c:	10800104 	addi	r2,r2,4
81134830:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
81134834:	e0bfef17 	ldw	r2,-68(fp)
81134838:	10800017 	ldw	r2,0(r2)
8113483c:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
81134840:	e0bff017 	ldw	r2,-64(fp)
81134844:	103f9a1e 	bne	r2,zero,811346b0 <__reset+0xfb1146b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
81134848:	e0bff103 	ldbu	r2,-60(fp)
8113484c:	10800058 	cmpnei	r2,r2,1
81134850:	10000a1e 	bne	r2,zero,8113487c <OSEventPendMulti+0x360>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
81134854:	e0bffd17 	ldw	r2,-12(fp)
81134858:	10000015 	stw	zero,0(r2)
8113485c:	e0bff317 	ldw	r2,-52(fp)
81134860:	e0bff615 	stw	r2,-40(fp)
81134864:	e0bff617 	ldw	r2,-40(fp)
81134868:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
8113486c:	e0800217 	ldw	r2,8(fp)
81134870:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
81134874:	e0bff18b 	ldhu	r2,-58(fp)
81134878:	00008806 	br	81134a9c <OSEventPendMulti+0x580>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
8113487c:	d0a09e17 	ldw	r2,-32136(gp)
81134880:	d0e09e17 	ldw	r3,-32136(gp)
81134884:	19000c03 	ldbu	r4,48(r3)
81134888:	e0fff203 	ldbu	r3,-56(fp)
8113488c:	20c6b03a 	or	r3,r4,r3
81134890:	1809883a 	mov	r4,r3
81134894:	00ffe004 	movi	r3,-128
81134898:	20c6b03a 	or	r3,r4,r3
8113489c:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811348a0:	d0a09e17 	ldw	r2,-32136(gp)
811348a4:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
811348a8:	d0a09e17 	ldw	r2,-32136(gp)
811348ac:	e0ffff0b 	ldhu	r3,-4(fp)
811348b0:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
811348b4:	e13ffc17 	ldw	r4,-16(fp)
811348b8:	11354400 	call	81135440 <OS_EventTaskWaitMulti>
811348bc:	e0bff317 	ldw	r2,-52(fp)
811348c0:	e0bff915 	stw	r2,-28(fp)
811348c4:	e0bff917 	ldw	r2,-28(fp)
811348c8:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
811348cc:	1135c440 	call	81135c44 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811348d0:	0005303a 	rdctl	r2,status
811348d4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811348d8:	e0fff717 	ldw	r3,-36(fp)
811348dc:	00bfff84 	movi	r2,-2
811348e0:	1884703a 	and	r2,r3,r2
811348e4:	1001703a 	wrctl	status,r2
  
  return context;
811348e8:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
811348ec:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
811348f0:	d0a09e17 	ldw	r2,-32136(gp)
811348f4:	10800c43 	ldbu	r2,49(r2)
811348f8:	10803fcc 	andi	r2,r2,255
811348fc:	10000226 	beq	r2,zero,81134908 <OSEventPendMulti+0x3ec>
81134900:	108000a0 	cmpeqi	r2,r2,2
81134904:	10001826 	beq	r2,zero,81134968 <OSEventPendMulti+0x44c>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
81134908:	d0a09e17 	ldw	r2,-32136(gp)
8113490c:	10800717 	ldw	r2,28(r2)
81134910:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
81134914:	e0bff017 	ldw	r2,-64(fp)
81134918:	10000b26 	beq	r2,zero,81134948 <OSEventPendMulti+0x42c>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
8113491c:	e0bffd17 	ldw	r2,-12(fp)
81134920:	10c00104 	addi	r3,r2,4
81134924:	e0fffd15 	stw	r3,-12(fp)
81134928:	e0fff017 	ldw	r3,-64(fp)
8113492c:	10c00015 	stw	r3,0(r2)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
81134930:	e0bffd17 	ldw	r2,-12(fp)
81134934:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
81134938:	e0bff18b 	ldhu	r2,-58(fp)
8113493c:	10800044 	addi	r2,r2,1
81134940:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
81134944:	00000d06 	br	8113497c <OSEventPendMulti+0x460>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
81134948:	d0a09e17 	ldw	r2,-32136(gp)
8113494c:	00c00044 	movi	r3,1
81134950:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81134954:	d0a09e17 	ldw	r2,-32136(gp)
81134958:	e17ffc17 	ldw	r5,-16(fp)
8113495c:	1009883a 	mov	r4,r2
81134960:	11356580 	call	81135658 <OS_EventTaskRemoveMulti>
             }
			 break;
81134964:	00000506 	br	8113497c <OSEventPendMulti+0x460>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
81134968:	d0a09e17 	ldw	r2,-32136(gp)
8113496c:	e17ffc17 	ldw	r5,-16(fp)
81134970:	1009883a 	mov	r4,r2
81134974:	11356580 	call	81135658 <OS_EventTaskRemoveMulti>
             break;
81134978:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
8113497c:	d0a09e17 	ldw	r2,-32136(gp)
81134980:	10800c43 	ldbu	r2,49(r2)
81134984:	10803fcc 	andi	r2,r2,255
81134988:	10000326 	beq	r2,zero,81134998 <OSEventPendMulti+0x47c>
8113498c:	108000a0 	cmpeqi	r2,r2,2
81134990:	1000231e 	bne	r2,zero,81134a20 <OSEventPendMulti+0x504>
81134994:	00002a06 	br	81134a40 <OSEventPendMulti+0x524>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
81134998:	e0bff017 	ldw	r2,-64(fp)
8113499c:	10800003 	ldbu	r2,0(r2)
811349a0:	10803fcc 	andi	r2,r2,255
811349a4:	0080100e 	bge	zero,r2,811349e8 <OSEventPendMulti+0x4cc>
811349a8:	10c000d0 	cmplti	r3,r2,3
811349ac:	1800071e 	bne	r3,zero,811349cc <OSEventPendMulti+0x4b0>
811349b0:	108000e0 	cmpeqi	r2,r2,3
811349b4:	10000c26 	beq	r2,zero,811349e8 <OSEventPendMulti+0x4cc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
811349b8:	e0bffe17 	ldw	r2,-8(fp)
811349bc:	10c00104 	addi	r3,r2,4
811349c0:	e0fffe15 	stw	r3,-8(fp)
811349c4:	10000015 	stw	zero,0(r2)
                      break;
811349c8:	00001206 	br	81134a14 <OSEventPendMulti+0x4f8>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
811349cc:	e0bffe17 	ldw	r2,-8(fp)
811349d0:	10c00104 	addi	r3,r2,4
811349d4:	e0fffe15 	stw	r3,-8(fp)
811349d8:	d0e09e17 	ldw	r3,-32136(gp)
811349dc:	18c00917 	ldw	r3,36(r3)
811349e0:	10c00015 	stw	r3,0(r2)
                      break;
811349e4:	00000b06 	br	81134a14 <OSEventPendMulti+0x4f8>
811349e8:	e0bff317 	ldw	r2,-52(fp)
811349ec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811349f0:	e0bff817 	ldw	r2,-32(fp)
811349f4:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
811349f8:	e0bffd17 	ldw	r2,-12(fp)
811349fc:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
81134a00:	e0800217 	ldw	r2,8(fp)
81134a04:	00c00044 	movi	r3,1
81134a08:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
81134a0c:	e0bff18b 	ldhu	r2,-58(fp)
81134a10:	00002206 	br	81134a9c <OSEventPendMulti+0x580>
             }
            *perr = OS_ERR_NONE;
81134a14:	e0800217 	ldw	r2,8(fp)
81134a18:	10000005 	stb	zero,0(r2)
             break;
81134a1c:	00001006 	br	81134a60 <OSEventPendMulti+0x544>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
81134a20:	e0bffe17 	ldw	r2,-8(fp)
81134a24:	10c00104 	addi	r3,r2,4
81134a28:	e0fffe15 	stw	r3,-8(fp)
81134a2c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
81134a30:	e0800217 	ldw	r2,8(fp)
81134a34:	00c00384 	movi	r3,14
81134a38:	10c00005 	stb	r3,0(r2)
             break;
81134a3c:	00000806 	br	81134a60 <OSEventPendMulti+0x544>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
81134a40:	e0bffe17 	ldw	r2,-8(fp)
81134a44:	10c00104 	addi	r3,r2,4
81134a48:	e0fffe15 	stw	r3,-8(fp)
81134a4c:	10000015 	stw	zero,0(r2)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
81134a50:	e0800217 	ldw	r2,8(fp)
81134a54:	00c00284 	movi	r3,10
81134a58:	10c00005 	stb	r3,0(r2)
             break;
81134a5c:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
81134a60:	d0a09e17 	ldw	r2,-32136(gp)
81134a64:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
81134a68:	d0a09e17 	ldw	r2,-32136(gp)
81134a6c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
81134a70:	d0a09e17 	ldw	r2,-32136(gp)
81134a74:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81134a78:	d0a09e17 	ldw	r2,-32136(gp)
81134a7c:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
81134a80:	d0a09e17 	ldw	r2,-32136(gp)
81134a84:	10000915 	stw	zero,36(r2)
81134a88:	e0bff317 	ldw	r2,-52(fp)
81134a8c:	e0bffa15 	stw	r2,-24(fp)
81134a90:	e0bffa17 	ldw	r2,-24(fp)
81134a94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
81134a98:	e0bff18b 	ldhu	r2,-58(fp)
}
81134a9c:	e037883a 	mov	sp,fp
81134aa0:	dfc00117 	ldw	ra,4(sp)
81134aa4:	df000017 	ldw	fp,0(sp)
81134aa8:	dec00204 	addi	sp,sp,8
81134aac:	f800283a 	ret

81134ab0 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
81134ab0:	defffe04 	addi	sp,sp,-8
81134ab4:	de00012e 	bgeu	sp,et,81134abc <OSInit+0xc>
81134ab8:	003b68fa 	trap	3
81134abc:	dfc00115 	stw	ra,4(sp)
81134ac0:	df000015 	stw	fp,0(sp)
81134ac4:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
81134ac8:	1146fb40 	call	81146fb4 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
81134acc:	11358b80 	call	811358b8 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
81134ad0:	11359080 	call	81135908 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
81134ad4:	1135a8c0 	call	81135a8c <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
81134ad8:	11357d00 	call	811357d0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
81134adc:	1137a4c0 	call	81137a4c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
81134ae0:	11383940 	call	81138394 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
81134ae4:	113a6640 	call	8113a664 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
81134ae8:	113597c0 	call	8113597c <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
81134aec:	1135a040 	call	81135a04 <OS_InitTaskStat>
#endif

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
81134af0:	113da080 	call	8113da08 <OSTmr_Init>
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
81134af4:	1146fe00 	call	81146fe0 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
81134af8:	11363680 	call	81136368 <OSDebugInit>
#endif
}
81134afc:	0001883a 	nop
81134b00:	e037883a 	mov	sp,fp
81134b04:	dfc00117 	ldw	ra,4(sp)
81134b08:	df000017 	ldw	fp,0(sp)
81134b0c:	dec00204 	addi	sp,sp,8
81134b10:	f800283a 	ret

81134b14 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
81134b14:	deffff04 	addi	sp,sp,-4
81134b18:	de00012e 	bgeu	sp,et,81134b20 <OSIntEnter+0xc>
81134b1c:	003b68fa 	trap	3
81134b20:	df000015 	stw	fp,0(sp)
81134b24:	d839883a 	mov	fp,sp
    if (OSRunning == OS_TRUE) {
81134b28:	d0a08d03 	ldbu	r2,-32204(gp)
81134b2c:	10803fcc 	andi	r2,r2,255
81134b30:	10800058 	cmpnei	r2,r2,1
81134b34:	1000071e 	bne	r2,zero,81134b54 <OSIntEnter+0x40>
        if (OSIntNesting < 255u) {
81134b38:	d0a09d03 	ldbu	r2,-32140(gp)
81134b3c:	10803fcc 	andi	r2,r2,255
81134b40:	10803fe0 	cmpeqi	r2,r2,255
81134b44:	1000031e 	bne	r2,zero,81134b54 <OSIntEnter+0x40>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
81134b48:	d0a09d03 	ldbu	r2,-32140(gp)
81134b4c:	10800044 	addi	r2,r2,1
81134b50:	d0a09d05 	stb	r2,-32140(gp)
        }
    }
}
81134b54:	0001883a 	nop
81134b58:	e037883a 	mov	sp,fp
81134b5c:	df000017 	ldw	fp,0(sp)
81134b60:	dec00104 	addi	sp,sp,4
81134b64:	f800283a 	ret

81134b68 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
81134b68:	defffb04 	addi	sp,sp,-20
81134b6c:	de00012e 	bgeu	sp,et,81134b74 <OSIntExit+0xc>
81134b70:	003b68fa 	trap	3
81134b74:	dfc00415 	stw	ra,16(sp)
81134b78:	df000315 	stw	fp,12(sp)
81134b7c:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134b80:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
81134b84:	d0a08d03 	ldbu	r2,-32204(gp)
81134b88:	10803fcc 	andi	r2,r2,255
81134b8c:	10800058 	cmpnei	r2,r2,1
81134b90:	10002f1e 	bne	r2,zero,81134c50 <OSIntExit+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134b94:	0005303a 	rdctl	r2,status
81134b98:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134b9c:	e0ffff17 	ldw	r3,-4(fp)
81134ba0:	00bfff84 	movi	r2,-2
81134ba4:	1884703a 	and	r2,r3,r2
81134ba8:	1001703a 	wrctl	status,r2
  
  return context;
81134bac:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81134bb0:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
81134bb4:	d0a09d03 	ldbu	r2,-32140(gp)
81134bb8:	10803fcc 	andi	r2,r2,255
81134bbc:	10000326 	beq	r2,zero,81134bcc <OSIntExit+0x64>
            OSIntNesting--;
81134bc0:	d0a09d03 	ldbu	r2,-32140(gp)
81134bc4:	10bfffc4 	addi	r2,r2,-1
81134bc8:	d0a09d05 	stb	r2,-32140(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
81134bcc:	d0a09d03 	ldbu	r2,-32140(gp)
81134bd0:	10803fcc 	andi	r2,r2,255
81134bd4:	10001a1e 	bne	r2,zero,81134c40 <OSIntExit+0xd8>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
81134bd8:	d0a08b03 	ldbu	r2,-32212(gp)
81134bdc:	10803fcc 	andi	r2,r2,255
81134be0:	1000171e 	bne	r2,zero,81134c40 <OSIntExit+0xd8>
                OS_SchedNew();
81134be4:	1135d1c0 	call	81135d1c <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
81134be8:	d0e08f83 	ldbu	r3,-32194(gp)
81134bec:	d0a08fc3 	ldbu	r2,-32193(gp)
81134bf0:	18c03fcc 	andi	r3,r3,255
81134bf4:	10803fcc 	andi	r2,r2,255
81134bf8:	18801126 	beq	r3,r2,81134c40 <OSIntExit+0xd8>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
81134bfc:	d0a08f83 	ldbu	r2,-32194(gp)
81134c00:	10c03fcc 	andi	r3,r2,255
81134c04:	00a045f4 	movhi	r2,33047
81134c08:	10a10004 	addi	r2,r2,-31744
81134c0c:	18c7883a 	add	r3,r3,r3
81134c10:	18c7883a 	add	r3,r3,r3
81134c14:	10c5883a 	add	r2,r2,r3
81134c18:	10800017 	ldw	r2,0(r2)
81134c1c:	d0a09815 	stw	r2,-32160(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
81134c20:	d0a09817 	ldw	r2,-32160(gp)
81134c24:	10c00e17 	ldw	r3,56(r2)
81134c28:	18c00044 	addi	r3,r3,1
81134c2c:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
81134c30:	d0a09217 	ldw	r2,-32184(gp)
81134c34:	10800044 	addi	r2,r2,1
81134c38:	d0a09215 	stw	r2,-32184(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
81134c3c:	1146c740 	call	81146c74 <OSCtxSw>
81134c40:	e0bffd17 	ldw	r2,-12(fp)
81134c44:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134c48:	e0bffe17 	ldw	r2,-8(fp)
81134c4c:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81134c50:	0001883a 	nop
81134c54:	e037883a 	mov	sp,fp
81134c58:	dfc00117 	ldw	ra,4(sp)
81134c5c:	df000017 	ldw	fp,0(sp)
81134c60:	dec00204 	addi	sp,sp,8
81134c64:	f800283a 	ret

81134c68 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
81134c68:	defffc04 	addi	sp,sp,-16
81134c6c:	de00012e 	bgeu	sp,et,81134c74 <OSSchedLock+0xc>
81134c70:	003b68fa 	trap	3
81134c74:	df000315 	stw	fp,12(sp)
81134c78:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134c7c:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
81134c80:	d0a08d03 	ldbu	r2,-32204(gp)
81134c84:	10803fcc 	andi	r2,r2,255
81134c88:	10800058 	cmpnei	r2,r2,1
81134c8c:	1000161e 	bne	r2,zero,81134ce8 <OSSchedLock+0x80>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134c90:	0005303a 	rdctl	r2,status
81134c94:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134c98:	e0ffff17 	ldw	r3,-4(fp)
81134c9c:	00bfff84 	movi	r2,-2
81134ca0:	1884703a 	and	r2,r3,r2
81134ca4:	1001703a 	wrctl	status,r2
  
  return context;
81134ca8:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81134cac:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
81134cb0:	d0a09d03 	ldbu	r2,-32140(gp)
81134cb4:	10803fcc 	andi	r2,r2,255
81134cb8:	1000071e 	bne	r2,zero,81134cd8 <OSSchedLock+0x70>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
81134cbc:	d0a08b03 	ldbu	r2,-32212(gp)
81134cc0:	10803fcc 	andi	r2,r2,255
81134cc4:	10803fe0 	cmpeqi	r2,r2,255
81134cc8:	1000031e 	bne	r2,zero,81134cd8 <OSSchedLock+0x70>
                OSLockNesting++;                 /* Increment lock nesting level                       */
81134ccc:	d0a08b03 	ldbu	r2,-32212(gp)
81134cd0:	10800044 	addi	r2,r2,1
81134cd4:	d0a08b05 	stb	r2,-32212(gp)
81134cd8:	e0bffd17 	ldw	r2,-12(fp)
81134cdc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134ce0:	e0bffe17 	ldw	r2,-8(fp)
81134ce4:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
81134ce8:	0001883a 	nop
81134cec:	e037883a 	mov	sp,fp
81134cf0:	df000017 	ldw	fp,0(sp)
81134cf4:	dec00104 	addi	sp,sp,4
81134cf8:	f800283a 	ret

81134cfc <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
81134cfc:	defff804 	addi	sp,sp,-32
81134d00:	de00012e 	bgeu	sp,et,81134d08 <OSSchedUnlock+0xc>
81134d04:	003b68fa 	trap	3
81134d08:	dfc00715 	stw	ra,28(sp)
81134d0c:	df000615 	stw	fp,24(sp)
81134d10:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81134d14:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
81134d18:	d0a08d03 	ldbu	r2,-32204(gp)
81134d1c:	10803fcc 	andi	r2,r2,255
81134d20:	10800058 	cmpnei	r2,r2,1
81134d24:	1000281e 	bne	r2,zero,81134dc8 <OSSchedUnlock+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134d28:	0005303a 	rdctl	r2,status
81134d2c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134d30:	e0ffff17 	ldw	r3,-4(fp)
81134d34:	00bfff84 	movi	r2,-2
81134d38:	1884703a 	and	r2,r3,r2
81134d3c:	1001703a 	wrctl	status,r2
  
  return context;
81134d40:	e0bfff17 	ldw	r2,-4(fp)
        OS_ENTER_CRITICAL();
81134d44:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
81134d48:	d0a08b03 	ldbu	r2,-32212(gp)
81134d4c:	10803fcc 	andi	r2,r2,255
81134d50:	10001926 	beq	r2,zero,81134db8 <OSSchedUnlock+0xbc>
            OSLockNesting--;                               /* Decrement lock nesting level             */
81134d54:	d0a08b03 	ldbu	r2,-32212(gp)
81134d58:	10bfffc4 	addi	r2,r2,-1
81134d5c:	d0a08b05 	stb	r2,-32212(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
81134d60:	d0a08b03 	ldbu	r2,-32212(gp)
81134d64:	10803fcc 	andi	r2,r2,255
81134d68:	10000e1e 	bne	r2,zero,81134da4 <OSSchedUnlock+0xa8>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
81134d6c:	d0a09d03 	ldbu	r2,-32140(gp)
81134d70:	10803fcc 	andi	r2,r2,255
81134d74:	1000061e 	bne	r2,zero,81134d90 <OSSchedUnlock+0x94>
81134d78:	e0bffa17 	ldw	r2,-24(fp)
81134d7c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134d80:	e0bffb17 	ldw	r2,-20(fp)
81134d84:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
81134d88:	1135c440 	call	81135c44 <OS_Sched>
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
81134d8c:	00000e06 	br	81134dc8 <OSSchedUnlock+0xcc>
81134d90:	e0bffa17 	ldw	r2,-24(fp)
81134d94:	e0bffc15 	stw	r2,-16(fp)
81134d98:	e0bffc17 	ldw	r2,-16(fp)
81134d9c:	1001703a 	wrctl	status,r2
81134da0:	00000906 	br	81134dc8 <OSSchedUnlock+0xcc>
81134da4:	e0bffa17 	ldw	r2,-24(fp)
81134da8:	e0bffd15 	stw	r2,-12(fp)
81134dac:	e0bffd17 	ldw	r2,-12(fp)
81134db0:	1001703a 	wrctl	status,r2
81134db4:	00000406 	br	81134dc8 <OSSchedUnlock+0xcc>
81134db8:	e0bffa17 	ldw	r2,-24(fp)
81134dbc:	e0bffe15 	stw	r2,-8(fp)
81134dc0:	e0bffe17 	ldw	r2,-8(fp)
81134dc4:	1001703a 	wrctl	status,r2
81134dc8:	0001883a 	nop
81134dcc:	e037883a 	mov	sp,fp
81134dd0:	dfc00117 	ldw	ra,4(sp)
81134dd4:	df000017 	ldw	fp,0(sp)
81134dd8:	dec00204 	addi	sp,sp,8
81134ddc:	f800283a 	ret

81134de0 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
81134de0:	defffe04 	addi	sp,sp,-8
81134de4:	de00012e 	bgeu	sp,et,81134dec <OSStart+0xc>
81134de8:	003b68fa 	trap	3
81134dec:	dfc00115 	stw	ra,4(sp)
81134df0:	df000015 	stw	fp,0(sp)
81134df4:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
81134df8:	d0a08d03 	ldbu	r2,-32204(gp)
81134dfc:	10803fcc 	andi	r2,r2,255
81134e00:	10000f1e 	bne	r2,zero,81134e40 <OSStart+0x60>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
81134e04:	1135d1c0 	call	81135d1c <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
81134e08:	d0a08f83 	ldbu	r2,-32194(gp)
81134e0c:	d0a08fc5 	stb	r2,-32193(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
81134e10:	d0a08f83 	ldbu	r2,-32194(gp)
81134e14:	10c03fcc 	andi	r3,r2,255
81134e18:	00a045f4 	movhi	r2,33047
81134e1c:	10a10004 	addi	r2,r2,-31744
81134e20:	18c7883a 	add	r3,r3,r3
81134e24:	18c7883a 	add	r3,r3,r3
81134e28:	10c5883a 	add	r2,r2,r3
81134e2c:	10800017 	ldw	r2,0(r2)
81134e30:	d0a09815 	stw	r2,-32160(gp)
        OSTCBCur      = OSTCBHighRdy;
81134e34:	d0a09817 	ldw	r2,-32160(gp)
81134e38:	d0a09e15 	stw	r2,-32136(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
81134e3c:	1146d100 	call	81146d10 <OSStartHighRdy>
    }
}
81134e40:	0001883a 	nop
81134e44:	e037883a 	mov	sp,fp
81134e48:	dfc00117 	ldw	ra,4(sp)
81134e4c:	df000017 	ldw	fp,0(sp)
81134e50:	dec00204 	addi	sp,sp,8
81134e54:	f800283a 	ret

81134e58 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
81134e58:	defff904 	addi	sp,sp,-28
81134e5c:	de00012e 	bgeu	sp,et,81134e64 <OSStatInit+0xc>
81134e60:	003b68fa 	trap	3
81134e64:	dfc00615 	stw	ra,24(sp)
81134e68:	df000515 	stw	fp,20(sp)
81134e6c:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81134e70:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
81134e74:	01000084 	movi	r4,2
81134e78:	113c9800 	call	8113c980 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134e7c:	0005303a 	rdctl	r2,status
81134e80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134e84:	e0fffc17 	ldw	r3,-16(fp)
81134e88:	00bfff84 	movi	r2,-2
81134e8c:	1884703a 	and	r2,r3,r2
81134e90:	1001703a 	wrctl	status,r2
  
  return context;
81134e94:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
81134e98:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
81134e9c:	d0208e15 	stw	zero,-32200(gp)
81134ea0:	e0bffb17 	ldw	r2,-20(fp)
81134ea4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134ea8:	e0bffd17 	ldw	r2,-12(fp)
81134eac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
81134eb0:	01001904 	movi	r4,100
81134eb4:	113c9800 	call	8113c980 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134eb8:	0005303a 	rdctl	r2,status
81134ebc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134ec0:	e0fffe17 	ldw	r3,-8(fp)
81134ec4:	00bfff84 	movi	r2,-2
81134ec8:	1884703a 	and	r2,r3,r2
81134ecc:	1001703a 	wrctl	status,r2
  
  return context;
81134ed0:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
81134ed4:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
81134ed8:	d0a08e17 	ldw	r2,-32200(gp)
81134edc:	d0a09415 	stw	r2,-32176(gp)
    OSStatRdy    = OS_TRUE;
81134ee0:	00800044 	movi	r2,1
81134ee4:	d0a0a305 	stb	r2,-32116(gp)
81134ee8:	e0bffb17 	ldw	r2,-20(fp)
81134eec:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134ef0:	e0bfff17 	ldw	r2,-4(fp)
81134ef4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
81134ef8:	0001883a 	nop
81134efc:	e037883a 	mov	sp,fp
81134f00:	dfc00117 	ldw	ra,4(sp)
81134f04:	df000017 	ldw	fp,0(sp)
81134f08:	dec00204 	addi	sp,sp,8
81134f0c:	f800283a 	ret

81134f10 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
81134f10:	defff704 	addi	sp,sp,-36
81134f14:	de00012e 	bgeu	sp,et,81134f1c <OSTimeTick+0xc>
81134f18:	003b68fa 	trap	3
81134f1c:	dfc00815 	stw	ra,32(sp)
81134f20:	df000715 	stw	fp,28(sp)
81134f24:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81134f28:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
81134f2c:	1146f600 	call	81146f60 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134f30:	0005303a 	rdctl	r2,status
81134f34:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134f38:	e0fffd17 	ldw	r3,-12(fp)
81134f3c:	00bfff84 	movi	r2,-2
81134f40:	1884703a 	and	r2,r3,r2
81134f44:	1001703a 	wrctl	status,r2
  
  return context;
81134f48:	e0bffd17 	ldw	r2,-12(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
81134f4c:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
81134f50:	d0a0a017 	ldw	r2,-32128(gp)
81134f54:	10800044 	addi	r2,r2,1
81134f58:	d0a0a015 	stw	r2,-32128(gp)
81134f5c:	e0bffb17 	ldw	r2,-20(fp)
81134f60:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81134f64:	e0bfff17 	ldw	r2,-4(fp)
81134f68:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
81134f6c:	d0a08d03 	ldbu	r2,-32204(gp)
81134f70:	10803fcc 	andi	r2,r2,255
81134f74:	10800058 	cmpnei	r2,r2,1
81134f78:	10006a1e 	bne	r2,zero,81135124 <OSTimeTick+0x214>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
81134f7c:	d0a09103 	ldbu	r2,-32188(gp)
81134f80:	10803fcc 	andi	r2,r2,255
81134f84:	10c00060 	cmpeqi	r3,r2,1
81134f88:	1800061e 	bne	r3,zero,81134fa4 <OSTimeTick+0x94>
81134f8c:	10c000a0 	cmpeqi	r3,r2,2
81134f90:	1800061e 	bne	r3,zero,81134fac <OSTimeTick+0x9c>
81134f94:	10000a1e 	bne	r2,zero,81134fc0 <OSTimeTick+0xb0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
81134f98:	00800044 	movi	r2,1
81134f9c:	e0bffa05 	stb	r2,-24(fp)
                 break;
81134fa0:	00000b06 	br	81134fd0 <OSTimeTick+0xc0>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
81134fa4:	e03ffa05 	stb	zero,-24(fp)
                 break;
81134fa8:	00000906 	br	81134fd0 <OSTimeTick+0xc0>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
81134fac:	00800044 	movi	r2,1
81134fb0:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
81134fb4:	00800044 	movi	r2,1
81134fb8:	d0a09105 	stb	r2,-32188(gp)
                 break;
81134fbc:	00000406 	br	81134fd0 <OSTimeTick+0xc0>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
81134fc0:	00800044 	movi	r2,1
81134fc4:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
81134fc8:	d0209105 	stb	zero,-32188(gp)
                 break;
81134fcc:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
81134fd0:	e0bffa03 	ldbu	r2,-24(fp)
81134fd4:	10005226 	beq	r2,zero,81135120 <OSTimeTick+0x210>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
81134fd8:	d0a09017 	ldw	r2,-32192(gp)
81134fdc:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81134fe0:	00004906 	br	81135108 <OSTimeTick+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81134fe4:	0005303a 	rdctl	r2,status
81134fe8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81134fec:	e0fffc17 	ldw	r3,-16(fp)
81134ff0:	00bfff84 	movi	r2,-2
81134ff4:	1884703a 	and	r2,r3,r2
81134ff8:	1001703a 	wrctl	status,r2
  
  return context;
81134ffc:	e0bffc17 	ldw	r2,-16(fp)
            OS_ENTER_CRITICAL();
81135000:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
81135004:	e0bff917 	ldw	r2,-28(fp)
81135008:	10800b8b 	ldhu	r2,46(r2)
8113500c:	10bfffcc 	andi	r2,r2,65535
81135010:	10003626 	beq	r2,zero,811350ec <OSTimeTick+0x1dc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
81135014:	e0bff917 	ldw	r2,-28(fp)
81135018:	10800b8b 	ldhu	r2,46(r2)
8113501c:	10bfffc4 	addi	r2,r2,-1
81135020:	1007883a 	mov	r3,r2
81135024:	e0bff917 	ldw	r2,-28(fp)
81135028:	10c00b8d 	sth	r3,46(r2)
8113502c:	e0bff917 	ldw	r2,-28(fp)
81135030:	10800b8b 	ldhu	r2,46(r2)
81135034:	10bfffcc 	andi	r2,r2,65535
81135038:	10002c1e 	bne	r2,zero,811350ec <OSTimeTick+0x1dc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113503c:	e0bff917 	ldw	r2,-28(fp)
81135040:	10800c03 	ldbu	r2,48(r2)
81135044:	10803fcc 	andi	r2,r2,255
81135048:	10800dcc 	andi	r2,r2,55
8113504c:	10000b26 	beq	r2,zero,8113507c <OSTimeTick+0x16c>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
81135050:	e0bff917 	ldw	r2,-28(fp)
81135054:	10c00c03 	ldbu	r3,48(r2)
81135058:	00bff204 	movi	r2,-56
8113505c:	1884703a 	and	r2,r3,r2
81135060:	1007883a 	mov	r3,r2
81135064:	e0bff917 	ldw	r2,-28(fp)
81135068:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
8113506c:	e0bff917 	ldw	r2,-28(fp)
81135070:	00c00044 	movi	r3,1
81135074:	10c00c45 	stb	r3,49(r2)
81135078:	00000206 	br	81135084 <OSTimeTick+0x174>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113507c:	e0bff917 	ldw	r2,-28(fp)
81135080:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
81135084:	e0bff917 	ldw	r2,-28(fp)
81135088:	10800c03 	ldbu	r2,48(r2)
8113508c:	10803fcc 	andi	r2,r2,255
81135090:	1080020c 	andi	r2,r2,8
81135094:	1000151e 	bne	r2,zero,811350ec <OSTimeTick+0x1dc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
81135098:	e0bff917 	ldw	r2,-28(fp)
8113509c:	10c00d83 	ldbu	r3,54(r2)
811350a0:	d0a09a03 	ldbu	r2,-32152(gp)
811350a4:	1884b03a 	or	r2,r3,r2
811350a8:	d0a09a05 	stb	r2,-32152(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811350ac:	e0bff917 	ldw	r2,-28(fp)
811350b0:	10800d03 	ldbu	r2,52(r2)
811350b4:	10c03fcc 	andi	r3,r2,255
811350b8:	e0bff917 	ldw	r2,-28(fp)
811350bc:	10800d03 	ldbu	r2,52(r2)
811350c0:	11003fcc 	andi	r4,r2,255
811350c4:	d0a09a44 	addi	r2,gp,-32151
811350c8:	2085883a 	add	r2,r4,r2
811350cc:	11000003 	ldbu	r4,0(r2)
811350d0:	e0bff917 	ldw	r2,-28(fp)
811350d4:	10800d43 	ldbu	r2,53(r2)
811350d8:	2084b03a 	or	r2,r4,r2
811350dc:	1009883a 	mov	r4,r2
811350e0:	d0a09a44 	addi	r2,gp,-32151
811350e4:	1885883a 	add	r2,r3,r2
811350e8:	11000005 	stb	r4,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
811350ec:	e0bff917 	ldw	r2,-28(fp)
811350f0:	10800517 	ldw	r2,20(r2)
811350f4:	e0bff915 	stw	r2,-28(fp)
811350f8:	e0bffb17 	ldw	r2,-20(fp)
811350fc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135100:	e0bffe17 	ldw	r2,-8(fp)
81135104:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
81135108:	e0bff917 	ldw	r2,-28(fp)
8113510c:	10800c83 	ldbu	r2,50(r2)
81135110:	10803fcc 	andi	r2,r2,255
81135114:	10800a98 	cmpnei	r2,r2,42
81135118:	103fb21e 	bne	r2,zero,81134fe4 <__reset+0xfb114fe4>
8113511c:	00000106 	br	81135124 <OSTimeTick+0x214>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
81135120:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
81135124:	e037883a 	mov	sp,fp
81135128:	dfc00117 	ldw	ra,4(sp)
8113512c:	df000017 	ldw	fp,0(sp)
81135130:	dec00204 	addi	sp,sp,8
81135134:	f800283a 	ret

81135138 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
81135138:	deffff04 	addi	sp,sp,-4
8113513c:	de00012e 	bgeu	sp,et,81135144 <OSVersion+0xc>
81135140:	003b68fa 	trap	3
81135144:	df000015 	stw	fp,0(sp)
81135148:	d839883a 	mov	fp,sp
    return (OS_VERSION);
8113514c:	00804784 	movi	r2,286
}
81135150:	e037883a 	mov	sp,fp
81135154:	df000017 	ldw	fp,0(sp)
81135158:	dec00104 	addi	sp,sp,4
8113515c:	f800283a 	ret

81135160 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
81135160:	deffff04 	addi	sp,sp,-4
81135164:	de00012e 	bgeu	sp,et,8113516c <OS_Dummy+0xc>
81135168:	003b68fa 	trap	3
8113516c:	df000015 	stw	fp,0(sp)
81135170:	d839883a 	mov	fp,sp
}
81135174:	0001883a 	nop
81135178:	e037883a 	mov	sp,fp
8113517c:	df000017 	ldw	fp,0(sp)
81135180:	dec00104 	addi	sp,sp,4
81135184:	f800283a 	ret

81135188 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
81135188:	defff804 	addi	sp,sp,-32
8113518c:	de00012e 	bgeu	sp,et,81135194 <OS_EventTaskRdy+0xc>
81135190:	003b68fa 	trap	3
81135194:	dfc00715 	stw	ra,28(sp)
81135198:	df000615 	stw	fp,24(sp)
8113519c:	df000604 	addi	fp,sp,24
811351a0:	e13ffc15 	stw	r4,-16(fp)
811351a4:	e17ffd15 	stw	r5,-12(fp)
811351a8:	3007883a 	mov	r3,r6
811351ac:	3805883a 	mov	r2,r7
811351b0:	e0fffe05 	stb	r3,-8(fp)
811351b4:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
811351b8:	e0bffc17 	ldw	r2,-16(fp)
811351bc:	10800283 	ldbu	r2,10(r2)
811351c0:	10c03fcc 	andi	r3,r2,255
811351c4:	00a04574 	movhi	r2,33045
811351c8:	10b20d04 	addi	r2,r2,-14284
811351cc:	10c5883a 	add	r2,r2,r3
811351d0:	10800003 	ldbu	r2,0(r2)
811351d4:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
811351d8:	e0bffa03 	ldbu	r2,-24(fp)
811351dc:	e0fffc17 	ldw	r3,-16(fp)
811351e0:	1885883a 	add	r2,r3,r2
811351e4:	108002c4 	addi	r2,r2,11
811351e8:	10800003 	ldbu	r2,0(r2)
811351ec:	10c03fcc 	andi	r3,r2,255
811351f0:	00a04574 	movhi	r2,33045
811351f4:	10b20d04 	addi	r2,r2,-14284
811351f8:	10c5883a 	add	r2,r2,r3
811351fc:	10800003 	ldbu	r2,0(r2)
81135200:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
81135204:	e0bffa03 	ldbu	r2,-24(fp)
81135208:	100490fa 	slli	r2,r2,3
8113520c:	1007883a 	mov	r3,r2
81135210:	e0bffa43 	ldbu	r2,-23(fp)
81135214:	1885883a 	add	r2,r3,r2
81135218:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
8113521c:	e0fffa83 	ldbu	r3,-22(fp)
81135220:	00a045f4 	movhi	r2,33047
81135224:	10a10004 	addi	r2,r2,-31744
81135228:	18c7883a 	add	r3,r3,r3
8113522c:	18c7883a 	add	r3,r3,r3
81135230:	10c5883a 	add	r2,r2,r3
81135234:	10800017 	ldw	r2,0(r2)
81135238:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
8113523c:	e0bffb17 	ldw	r2,-20(fp)
81135240:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
81135244:	e0bffb17 	ldw	r2,-20(fp)
81135248:	e0fffd17 	ldw	r3,-12(fp)
8113524c:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
81135250:	e0bffb17 	ldw	r2,-20(fp)
81135254:	10800c03 	ldbu	r2,48(r2)
81135258:	1007883a 	mov	r3,r2
8113525c:	e0bffe03 	ldbu	r2,-8(fp)
81135260:	0084303a 	nor	r2,zero,r2
81135264:	1884703a 	and	r2,r3,r2
81135268:	1007883a 	mov	r3,r2
8113526c:	e0bffb17 	ldw	r2,-20(fp)
81135270:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
81135274:	e0bffb17 	ldw	r2,-20(fp)
81135278:	e0ffff03 	ldbu	r3,-4(fp)
8113527c:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
81135280:	e0bffb17 	ldw	r2,-20(fp)
81135284:	10800c03 	ldbu	r2,48(r2)
81135288:	10803fcc 	andi	r2,r2,255
8113528c:	1080020c 	andi	r2,r2,8
81135290:	1000111e 	bne	r2,zero,811352d8 <OS_EventTaskRdy+0x150>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
81135294:	e0bffb17 	ldw	r2,-20(fp)
81135298:	10c00d83 	ldbu	r3,54(r2)
8113529c:	d0a09a03 	ldbu	r2,-32152(gp)
811352a0:	1884b03a 	or	r2,r3,r2
811352a4:	d0a09a05 	stb	r2,-32152(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
811352a8:	e0fffa03 	ldbu	r3,-24(fp)
811352ac:	e13ffa03 	ldbu	r4,-24(fp)
811352b0:	d0a09a44 	addi	r2,gp,-32151
811352b4:	2085883a 	add	r2,r4,r2
811352b8:	11000003 	ldbu	r4,0(r2)
811352bc:	e0bffb17 	ldw	r2,-20(fp)
811352c0:	10800d43 	ldbu	r2,53(r2)
811352c4:	2084b03a 	or	r2,r4,r2
811352c8:	1009883a 	mov	r4,r2
811352cc:	d0a09a44 	addi	r2,gp,-32151
811352d0:	1885883a 	add	r2,r3,r2
811352d4:	11000005 	stb	r4,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
811352d8:	e17ffc17 	ldw	r5,-16(fp)
811352dc:	e13ffb17 	ldw	r4,-20(fp)
811352e0:	11355980 	call	81135598 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
811352e4:	e0bffb17 	ldw	r2,-20(fp)
811352e8:	10800817 	ldw	r2,32(r2)
811352ec:	10000826 	beq	r2,zero,81135310 <OS_EventTaskRdy+0x188>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
811352f0:	e0bffb17 	ldw	r2,-20(fp)
811352f4:	10800817 	ldw	r2,32(r2)
811352f8:	100b883a 	mov	r5,r2
811352fc:	e13ffb17 	ldw	r4,-20(fp)
81135300:	11356580 	call	81135658 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
81135304:	e0bffb17 	ldw	r2,-20(fp)
81135308:	e0fffc17 	ldw	r3,-16(fp)
8113530c:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
81135310:	e0bffa83 	ldbu	r2,-22(fp)
}
81135314:	e037883a 	mov	sp,fp
81135318:	dfc00117 	ldw	ra,4(sp)
8113531c:	df000017 	ldw	fp,0(sp)
81135320:	dec00204 	addi	sp,sp,8
81135324:	f800283a 	ret

81135328 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
81135328:	defffd04 	addi	sp,sp,-12
8113532c:	de00012e 	bgeu	sp,et,81135334 <OS_EventTaskWait+0xc>
81135330:	003b68fa 	trap	3
81135334:	df000215 	stw	fp,8(sp)
81135338:	df000204 	addi	fp,sp,8
8113533c:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
81135340:	d0a09e17 	ldw	r2,-32136(gp)
81135344:	e0ffff17 	ldw	r3,-4(fp)
81135348:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
8113534c:	d0a09e17 	ldw	r2,-32136(gp)
81135350:	10800d03 	ldbu	r2,52(r2)
81135354:	10803fcc 	andi	r2,r2,255
81135358:	d0e09e17 	ldw	r3,-32136(gp)
8113535c:	18c00d03 	ldbu	r3,52(r3)
81135360:	18c03fcc 	andi	r3,r3,255
81135364:	e13fff17 	ldw	r4,-4(fp)
81135368:	20c7883a 	add	r3,r4,r3
8113536c:	18c002c4 	addi	r3,r3,11
81135370:	19000003 	ldbu	r4,0(r3)
81135374:	d0e09e17 	ldw	r3,-32136(gp)
81135378:	18c00d43 	ldbu	r3,53(r3)
8113537c:	20c6b03a 	or	r3,r4,r3
81135380:	1809883a 	mov	r4,r3
81135384:	e0ffff17 	ldw	r3,-4(fp)
81135388:	1885883a 	add	r2,r3,r2
8113538c:	108002c4 	addi	r2,r2,11
81135390:	11000005 	stb	r4,0(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
81135394:	e0bfff17 	ldw	r2,-4(fp)
81135398:	10c00283 	ldbu	r3,10(r2)
8113539c:	d0a09e17 	ldw	r2,-32136(gp)
811353a0:	10800d83 	ldbu	r2,54(r2)
811353a4:	1884b03a 	or	r2,r3,r2
811353a8:	1007883a 	mov	r3,r2
811353ac:	e0bfff17 	ldw	r2,-4(fp)
811353b0:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
811353b4:	d0a09e17 	ldw	r2,-32136(gp)
811353b8:	10800d03 	ldbu	r2,52(r2)
811353bc:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
811353c0:	e0fffe03 	ldbu	r3,-8(fp)
811353c4:	e13ffe03 	ldbu	r4,-8(fp)
811353c8:	d0a09a44 	addi	r2,gp,-32151
811353cc:	2085883a 	add	r2,r4,r2
811353d0:	10800003 	ldbu	r2,0(r2)
811353d4:	1009883a 	mov	r4,r2
811353d8:	d0a09e17 	ldw	r2,-32136(gp)
811353dc:	10800d43 	ldbu	r2,53(r2)
811353e0:	0084303a 	nor	r2,zero,r2
811353e4:	2084703a 	and	r2,r4,r2
811353e8:	1009883a 	mov	r4,r2
811353ec:	d0a09a44 	addi	r2,gp,-32151
811353f0:	1885883a 	add	r2,r3,r2
811353f4:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
811353f8:	e0fffe03 	ldbu	r3,-8(fp)
811353fc:	d0a09a44 	addi	r2,gp,-32151
81135400:	1885883a 	add	r2,r3,r2
81135404:	10800003 	ldbu	r2,0(r2)
81135408:	10803fcc 	andi	r2,r2,255
8113540c:	1000071e 	bne	r2,zero,8113542c <OS_EventTaskWait+0x104>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81135410:	d0a09e17 	ldw	r2,-32136(gp)
81135414:	10800d83 	ldbu	r2,54(r2)
81135418:	0084303a 	nor	r2,zero,r2
8113541c:	1007883a 	mov	r3,r2
81135420:	d0a09a03 	ldbu	r2,-32152(gp)
81135424:	1884703a 	and	r2,r3,r2
81135428:	d0a09a05 	stb	r2,-32152(gp)
    }
}
8113542c:	0001883a 	nop
81135430:	e037883a 	mov	sp,fp
81135434:	df000017 	ldw	fp,0(sp)
81135438:	dec00104 	addi	sp,sp,4
8113543c:	f800283a 	ret

81135440 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
81135440:	defffb04 	addi	sp,sp,-20
81135444:	de00012e 	bgeu	sp,et,8113544c <OS_EventTaskWaitMulti+0xc>
81135448:	003b68fa 	trap	3
8113544c:	df000415 	stw	fp,16(sp)
81135450:	df000404 	addi	fp,sp,16
81135454:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
81135458:	d0a09e17 	ldw	r2,-32136(gp)
8113545c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
81135460:	d0a09e17 	ldw	r2,-32136(gp)
81135464:	e0ffff17 	ldw	r3,-4(fp)
81135468:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
8113546c:	e0bfff17 	ldw	r2,-4(fp)
81135470:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
81135474:	e0bffc17 	ldw	r2,-16(fp)
81135478:	10800017 	ldw	r2,0(r2)
8113547c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81135480:	00002006 	br	81135504 <OS_EventTaskWaitMulti+0xc4>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
81135484:	d0a09e17 	ldw	r2,-32136(gp)
81135488:	10800d03 	ldbu	r2,52(r2)
8113548c:	10803fcc 	andi	r2,r2,255
81135490:	d0e09e17 	ldw	r3,-32136(gp)
81135494:	18c00d03 	ldbu	r3,52(r3)
81135498:	18c03fcc 	andi	r3,r3,255
8113549c:	e13ffd17 	ldw	r4,-12(fp)
811354a0:	20c7883a 	add	r3,r4,r3
811354a4:	18c002c4 	addi	r3,r3,11
811354a8:	19000003 	ldbu	r4,0(r3)
811354ac:	d0e09e17 	ldw	r3,-32136(gp)
811354b0:	18c00d43 	ldbu	r3,53(r3)
811354b4:	20c6b03a 	or	r3,r4,r3
811354b8:	1809883a 	mov	r4,r3
811354bc:	e0fffd17 	ldw	r3,-12(fp)
811354c0:	1885883a 	add	r2,r3,r2
811354c4:	108002c4 	addi	r2,r2,11
811354c8:	11000005 	stb	r4,0(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
811354cc:	e0bffd17 	ldw	r2,-12(fp)
811354d0:	10c00283 	ldbu	r3,10(r2)
811354d4:	d0a09e17 	ldw	r2,-32136(gp)
811354d8:	10800d83 	ldbu	r2,54(r2)
811354dc:	1884b03a 	or	r2,r3,r2
811354e0:	1007883a 	mov	r3,r2
811354e4:	e0bffd17 	ldw	r2,-12(fp)
811354e8:	10c00285 	stb	r3,10(r2)
        pevents++;
811354ec:	e0bffc17 	ldw	r2,-16(fp)
811354f0:	10800104 	addi	r2,r2,4
811354f4:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
811354f8:	e0bffc17 	ldw	r2,-16(fp)
811354fc:	10800017 	ldw	r2,0(r2)
81135500:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
81135504:	e0bffd17 	ldw	r2,-12(fp)
81135508:	103fde1e 	bne	r2,zero,81135484 <__reset+0xfb115484>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
8113550c:	d0a09e17 	ldw	r2,-32136(gp)
81135510:	10800d03 	ldbu	r2,52(r2)
81135514:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
81135518:	e0fffe03 	ldbu	r3,-8(fp)
8113551c:	e13ffe03 	ldbu	r4,-8(fp)
81135520:	d0a09a44 	addi	r2,gp,-32151
81135524:	2085883a 	add	r2,r4,r2
81135528:	10800003 	ldbu	r2,0(r2)
8113552c:	1009883a 	mov	r4,r2
81135530:	d0a09e17 	ldw	r2,-32136(gp)
81135534:	10800d43 	ldbu	r2,53(r2)
81135538:	0084303a 	nor	r2,zero,r2
8113553c:	2084703a 	and	r2,r4,r2
81135540:	1009883a 	mov	r4,r2
81135544:	d0a09a44 	addi	r2,gp,-32151
81135548:	1885883a 	add	r2,r3,r2
8113554c:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81135550:	e0fffe03 	ldbu	r3,-8(fp)
81135554:	d0a09a44 	addi	r2,gp,-32151
81135558:	1885883a 	add	r2,r3,r2
8113555c:	10800003 	ldbu	r2,0(r2)
81135560:	10803fcc 	andi	r2,r2,255
81135564:	1000071e 	bne	r2,zero,81135584 <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
81135568:	d0a09e17 	ldw	r2,-32136(gp)
8113556c:	10800d83 	ldbu	r2,54(r2)
81135570:	0084303a 	nor	r2,zero,r2
81135574:	1007883a 	mov	r3,r2
81135578:	d0a09a03 	ldbu	r2,-32152(gp)
8113557c:	1884703a 	and	r2,r3,r2
81135580:	d0a09a05 	stb	r2,-32152(gp)
    }
}
81135584:	0001883a 	nop
81135588:	e037883a 	mov	sp,fp
8113558c:	df000017 	ldw	fp,0(sp)
81135590:	dec00104 	addi	sp,sp,4
81135594:	f800283a 	ret

81135598 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
81135598:	defffc04 	addi	sp,sp,-16
8113559c:	de00012e 	bgeu	sp,et,811355a4 <OS_EventTaskRemove+0xc>
811355a0:	003b68fa 	trap	3
811355a4:	df000315 	stw	fp,12(sp)
811355a8:	df000304 	addi	fp,sp,12
811355ac:	e13ffe15 	stw	r4,-8(fp)
811355b0:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
811355b4:	e0bffe17 	ldw	r2,-8(fp)
811355b8:	10800d03 	ldbu	r2,52(r2)
811355bc:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
811355c0:	e0bffd03 	ldbu	r2,-12(fp)
811355c4:	e0fffd03 	ldbu	r3,-12(fp)
811355c8:	e13fff17 	ldw	r4,-4(fp)
811355cc:	20c7883a 	add	r3,r4,r3
811355d0:	18c002c4 	addi	r3,r3,11
811355d4:	18c00003 	ldbu	r3,0(r3)
811355d8:	1809883a 	mov	r4,r3
811355dc:	e0fffe17 	ldw	r3,-8(fp)
811355e0:	18c00d43 	ldbu	r3,53(r3)
811355e4:	00c6303a 	nor	r3,zero,r3
811355e8:	20c6703a 	and	r3,r4,r3
811355ec:	1809883a 	mov	r4,r3
811355f0:	e0ffff17 	ldw	r3,-4(fp)
811355f4:	1885883a 	add	r2,r3,r2
811355f8:	108002c4 	addi	r2,r2,11
811355fc:	11000005 	stb	r4,0(r2)
    if (pevent->OSEventTbl[y] == 0) {
81135600:	e0bffd03 	ldbu	r2,-12(fp)
81135604:	e0ffff17 	ldw	r3,-4(fp)
81135608:	1885883a 	add	r2,r3,r2
8113560c:	108002c4 	addi	r2,r2,11
81135610:	10800003 	ldbu	r2,0(r2)
81135614:	10803fcc 	andi	r2,r2,255
81135618:	10000a1e 	bne	r2,zero,81135644 <OS_EventTaskRemove+0xac>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
8113561c:	e0bfff17 	ldw	r2,-4(fp)
81135620:	10800283 	ldbu	r2,10(r2)
81135624:	1007883a 	mov	r3,r2
81135628:	e0bffe17 	ldw	r2,-8(fp)
8113562c:	10800d83 	ldbu	r2,54(r2)
81135630:	0084303a 	nor	r2,zero,r2
81135634:	1884703a 	and	r2,r3,r2
81135638:	1007883a 	mov	r3,r2
8113563c:	e0bfff17 	ldw	r2,-4(fp)
81135640:	10c00285 	stb	r3,10(r2)
    }
}
81135644:	0001883a 	nop
81135648:	e037883a 	mov	sp,fp
8113564c:	df000017 	ldw	fp,0(sp)
81135650:	dec00104 	addi	sp,sp,4
81135654:	f800283a 	ret

81135658 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
81135658:	defffa04 	addi	sp,sp,-24
8113565c:	de00012e 	bgeu	sp,et,81135664 <OS_EventTaskRemoveMulti+0xc>
81135660:	003b68fa 	trap	3
81135664:	df000515 	stw	fp,20(sp)
81135668:	df000504 	addi	fp,sp,20
8113566c:	e13ffe15 	stw	r4,-8(fp)
81135670:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
81135674:	e0bffe17 	ldw	r2,-8(fp)
81135678:	10800d03 	ldbu	r2,52(r2)
8113567c:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
81135680:	e0bffe17 	ldw	r2,-8(fp)
81135684:	10800d83 	ldbu	r2,54(r2)
81135688:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
8113568c:	e0bffe17 	ldw	r2,-8(fp)
81135690:	10800d43 	ldbu	r2,53(r2)
81135694:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
81135698:	e0bfff17 	ldw	r2,-4(fp)
8113569c:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
811356a0:	e0bffb17 	ldw	r2,-20(fp)
811356a4:	10800017 	ldw	r2,0(r2)
811356a8:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
811356ac:	00002506 	br	81135744 <OS_EventTaskRemoveMulti+0xec>
        pevent->OSEventTbl[y]  &= ~bitx;
811356b0:	e0bffd03 	ldbu	r2,-12(fp)
811356b4:	e0fffd03 	ldbu	r3,-12(fp)
811356b8:	e13ffc17 	ldw	r4,-16(fp)
811356bc:	20c7883a 	add	r3,r4,r3
811356c0:	18c002c4 	addi	r3,r3,11
811356c4:	18c00003 	ldbu	r3,0(r3)
811356c8:	1809883a 	mov	r4,r3
811356cc:	e0fffd83 	ldbu	r3,-10(fp)
811356d0:	00c6303a 	nor	r3,zero,r3
811356d4:	20c6703a 	and	r3,r4,r3
811356d8:	1809883a 	mov	r4,r3
811356dc:	e0fffc17 	ldw	r3,-16(fp)
811356e0:	1885883a 	add	r2,r3,r2
811356e4:	108002c4 	addi	r2,r2,11
811356e8:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y] == 0) {
811356ec:	e0bffd03 	ldbu	r2,-12(fp)
811356f0:	e0fffc17 	ldw	r3,-16(fp)
811356f4:	1885883a 	add	r2,r3,r2
811356f8:	108002c4 	addi	r2,r2,11
811356fc:	10800003 	ldbu	r2,0(r2)
81135700:	10803fcc 	andi	r2,r2,255
81135704:	1000091e 	bne	r2,zero,8113572c <OS_EventTaskRemoveMulti+0xd4>
            pevent->OSEventGrp &= ~bity;
81135708:	e0bffc17 	ldw	r2,-16(fp)
8113570c:	10800283 	ldbu	r2,10(r2)
81135710:	1007883a 	mov	r3,r2
81135714:	e0bffd43 	ldbu	r2,-11(fp)
81135718:	0084303a 	nor	r2,zero,r2
8113571c:	1884703a 	and	r2,r3,r2
81135720:	1007883a 	mov	r3,r2
81135724:	e0bffc17 	ldw	r2,-16(fp)
81135728:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
8113572c:	e0bffb17 	ldw	r2,-20(fp)
81135730:	10800104 	addi	r2,r2,4
81135734:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
81135738:	e0bffb17 	ldw	r2,-20(fp)
8113573c:	10800017 	ldw	r2,0(r2)
81135740:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
81135744:	e0bffc17 	ldw	r2,-16(fp)
81135748:	103fd91e 	bne	r2,zero,811356b0 <__reset+0xfb1156b0>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
8113574c:	0001883a 	nop
81135750:	e037883a 	mov	sp,fp
81135754:	df000017 	ldw	fp,0(sp)
81135758:	dec00104 	addi	sp,sp,4
8113575c:	f800283a 	ret

81135760 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
81135760:	defffc04 	addi	sp,sp,-16
81135764:	de00012e 	bgeu	sp,et,8113576c <OS_EventWaitListInit+0xc>
81135768:	003b68fa 	trap	3
8113576c:	df000315 	stw	fp,12(sp)
81135770:	df000304 	addi	fp,sp,12
81135774:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
81135778:	e0bfff17 	ldw	r2,-4(fp)
8113577c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
81135780:	e0bfff17 	ldw	r2,-4(fp)
81135784:	108002c4 	addi	r2,r2,11
81135788:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113578c:	e03ffe05 	stb	zero,-8(fp)
81135790:	00000706 	br	811357b0 <OS_EventWaitListInit+0x50>
        *ptbl++ = 0;
81135794:	e0bffd17 	ldw	r2,-12(fp)
81135798:	10c00044 	addi	r3,r2,1
8113579c:	e0fffd15 	stw	r3,-12(fp)
811357a0:	10000005 	stb	zero,0(r2)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811357a4:	e0bffe03 	ldbu	r2,-8(fp)
811357a8:	10800044 	addi	r2,r2,1
811357ac:	e0bffe05 	stb	r2,-8(fp)
811357b0:	e0bffe03 	ldbu	r2,-8(fp)
811357b4:	108001b0 	cmpltui	r2,r2,6
811357b8:	103ff61e 	bne	r2,zero,81135794 <__reset+0xfb115794>
        *ptbl++ = 0;
    }
}
811357bc:	0001883a 	nop
811357c0:	e037883a 	mov	sp,fp
811357c4:	df000017 	ldw	fp,0(sp)
811357c8:	dec00104 	addi	sp,sp,4
811357cc:	f800283a 	ret

811357d0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
811357d0:	defffb04 	addi	sp,sp,-20
811357d4:	de00012e 	bgeu	sp,et,811357dc <OS_InitEventList+0xc>
811357d8:	003b68fa 	trap	3
811357dc:	dfc00415 	stw	ra,16(sp)
811357e0:	df000315 	stw	fp,12(sp)
811357e4:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
811357e8:	01434004 	movi	r5,3328
811357ec:	012045b4 	movhi	r4,33046
811357f0:	21195204 	addi	r4,r4,25928
811357f4:	1135b780 	call	81135b78 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
811357f8:	00a045b4 	movhi	r2,33046
811357fc:	10995204 	addi	r2,r2,25928
81135800:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
81135804:	00a045b4 	movhi	r2,33046
81135808:	10995f04 	addi	r2,r2,25980
8113580c:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81135810:	e03ffd0d 	sth	zero,-12(fp)
81135814:	00001306 	br	81135864 <OS_InitEventList+0x94>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
81135818:	e0bffe17 	ldw	r2,-8(fp)
8113581c:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
81135820:	e0bffe17 	ldw	r2,-8(fp)
81135824:	e0ffff17 	ldw	r3,-4(fp)
81135828:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
8113582c:	e0bffe17 	ldw	r2,-8(fp)
81135830:	00c00fc4 	movi	r3,63
81135834:	10c00445 	stb	r3,17(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
81135838:	e0bffe17 	ldw	r2,-8(fp)
8113583c:	10000485 	stb	zero,18(r2)
#endif
        pevent1++;
81135840:	e0bffe17 	ldw	r2,-8(fp)
81135844:	10800d04 	addi	r2,r2,52
81135848:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
8113584c:	e0bfff17 	ldw	r2,-4(fp)
81135850:	10800d04 	addi	r2,r2,52
81135854:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
81135858:	e0bffd0b 	ldhu	r2,-12(fp)
8113585c:	10800044 	addi	r2,r2,1
81135860:	e0bffd0d 	sth	r2,-12(fp)
81135864:	e0bffd0b 	ldhu	r2,-12(fp)
81135868:	10800ff0 	cmpltui	r2,r2,63
8113586c:	103fea1e 	bne	r2,zero,81135818 <__reset+0xfb115818>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
81135870:	e0bffe17 	ldw	r2,-8(fp)
81135874:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
81135878:	e0bffe17 	ldw	r2,-8(fp)
8113587c:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
81135880:	e0bffe17 	ldw	r2,-8(fp)
81135884:	00c00fc4 	movi	r3,63
81135888:	10c00445 	stb	r3,17(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
8113588c:	e0bffe17 	ldw	r2,-8(fp)
81135890:	10000485 	stb	zero,18(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
81135894:	00a045b4 	movhi	r2,33046
81135898:	10995204 	addi	r2,r2,25928
8113589c:	d0a09c15 	stw	r2,-32144(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
811358a0:	0001883a 	nop
811358a4:	e037883a 	mov	sp,fp
811358a8:	dfc00117 	ldw	ra,4(sp)
811358ac:	df000017 	ldw	fp,0(sp)
811358b0:	dec00204 	addi	sp,sp,8
811358b4:	f800283a 	ret

811358b8 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
811358b8:	deffff04 	addi	sp,sp,-4
811358bc:	de00012e 	bgeu	sp,et,811358c4 <OS_InitMisc+0xc>
811358c0:	003b68fa 	trap	3
811358c4:	df000015 	stw	fp,0(sp)
811358c8:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
811358cc:	d020a015 	stw	zero,-32128(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
811358d0:	d0209d05 	stb	zero,-32140(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
811358d4:	d0208b05 	stb	zero,-32212(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
811358d8:	d0209645 	stb	zero,-32167(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
811358dc:	d0208d05 	stb	zero,-32204(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
811358e0:	d0209215 	stw	zero,-32184(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
811358e4:	d0208e15 	stw	zero,-32200(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
811358e8:	d020a415 	stw	zero,-32112(gp)
    OSIdleCtrMax  = 0L;
811358ec:	d0209415 	stw	zero,-32176(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
811358f0:	d020a305 	stb	zero,-32116(gp)
#endif
}
811358f4:	0001883a 	nop
811358f8:	e037883a 	mov	sp,fp
811358fc:	df000017 	ldw	fp,0(sp)
81135900:	dec00104 	addi	sp,sp,4
81135904:	f800283a 	ret

81135908 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
81135908:	defffd04 	addi	sp,sp,-12
8113590c:	de00012e 	bgeu	sp,et,81135914 <OS_InitRdyList+0xc>
81135910:	003b68fa 	trap	3
81135914:	df000215 	stw	fp,8(sp)
81135918:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
8113591c:	d0209a05 	stb	zero,-32152(gp)
    prdytbl       = &OSRdyTbl[0];
81135920:	d0a09a44 	addi	r2,gp,-32151
81135924:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81135928:	e03ffe05 	stb	zero,-8(fp)
8113592c:	00000706 	br	8113594c <OS_InitRdyList+0x44>
        *prdytbl++ = 0;
81135930:	e0bfff17 	ldw	r2,-4(fp)
81135934:	10c00044 	addi	r3,r2,1
81135938:	e0ffff15 	stw	r3,-4(fp)
8113593c:	10000005 	stb	zero,0(r2)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
81135940:	e0bffe03 	ldbu	r2,-8(fp)
81135944:	10800044 	addi	r2,r2,1
81135948:	e0bffe05 	stb	r2,-8(fp)
8113594c:	e0bffe03 	ldbu	r2,-8(fp)
81135950:	108001b0 	cmpltui	r2,r2,6
81135954:	103ff61e 	bne	r2,zero,81135930 <__reset+0xfb115930>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
81135958:	d0208fc5 	stb	zero,-32193(gp)
    OSPrioHighRdy = 0;
8113595c:	d0208f85 	stb	zero,-32194(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
81135960:	d0209815 	stw	zero,-32160(gp)
    OSTCBCur      = (OS_TCB *)0;
81135964:	d0209e15 	stw	zero,-32136(gp)
}
81135968:	0001883a 	nop
8113596c:	e037883a 	mov	sp,fp
81135970:	df000017 	ldw	fp,0(sp)
81135974:	dec00104 	addi	sp,sp,4
81135978:	f800283a 	ret

8113597c <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
8113597c:	defff804 	addi	sp,sp,-32
81135980:	de00012e 	bgeu	sp,et,81135988 <OS_InitTaskIdle+0xc>
81135984:	003b68fa 	trap	3
81135988:	dfc00715 	stw	ra,28(sp)
8113598c:	df000615 	stw	fp,24(sp)
81135990:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
81135994:	008000c4 	movi	r2,3
81135998:	d8800415 	stw	r2,16(sp)
8113599c:	d8000315 	stw	zero,12(sp)
811359a0:	00810004 	movi	r2,1024
811359a4:	d8800215 	stw	r2,8(sp)
811359a8:	00a045b4 	movhi	r2,33046
811359ac:	10955204 	addi	r2,r2,21832
811359b0:	d8800115 	stw	r2,4(sp)
811359b4:	00bfffd4 	movui	r2,65535
811359b8:	d8800015 	stw	r2,0(sp)
811359bc:	01c00a84 	movi	r7,42
811359c0:	01a045b4 	movhi	r6,33046
811359c4:	31995104 	addi	r6,r6,25924
811359c8:	000b883a 	mov	r5,zero
811359cc:	012044f4 	movhi	r4,33043
811359d0:	21179c04 	addi	r4,r4,24176
811359d4:	113b8600 	call	8113b860 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
811359d8:	e1bfff04 	addi	r6,fp,-4
811359dc:	01604574 	movhi	r5,33045
811359e0:	29724d04 	addi	r5,r5,-14028
811359e4:	01000a84 	movi	r4,42
811359e8:	113c0900 	call	8113c090 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
811359ec:	0001883a 	nop
811359f0:	e037883a 	mov	sp,fp
811359f4:	dfc00117 	ldw	ra,4(sp)
811359f8:	df000017 	ldw	fp,0(sp)
811359fc:	dec00204 	addi	sp,sp,8
81135a00:	f800283a 	ret

81135a04 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
81135a04:	defff804 	addi	sp,sp,-32
81135a08:	de00012e 	bgeu	sp,et,81135a10 <OS_InitTaskStat+0xc>
81135a0c:	003b68fa 	trap	3
81135a10:	dfc00715 	stw	ra,28(sp)
81135a14:	df000615 	stw	fp,24(sp)
81135a18:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
81135a1c:	008000c4 	movi	r2,3
81135a20:	d8800415 	stw	r2,16(sp)
81135a24:	d8000315 	stw	zero,12(sp)
81135a28:	00810004 	movi	r2,1024
81135a2c:	d8800215 	stw	r2,8(sp)
81135a30:	00a045b4 	movhi	r2,33046
81135a34:	108e9204 	addi	r2,r2,14920
81135a38:	d8800115 	stw	r2,4(sp)
81135a3c:	00bfff94 	movui	r2,65534
81135a40:	d8800015 	stw	r2,0(sp)
81135a44:	01c00a44 	movi	r7,41
81135a48:	01a045b4 	movhi	r6,33046
81135a4c:	31929104 	addi	r6,r6,19012
81135a50:	000b883a 	mov	r5,zero
81135a54:	012044f4 	movhi	r4,33043
81135a58:	2117b504 	addi	r4,r4,24276
81135a5c:	113b8600 	call	8113b860 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
81135a60:	e1bfff04 	addi	r6,fp,-4
81135a64:	01604574 	movhi	r5,33045
81135a68:	29725104 	addi	r5,r5,-14012
81135a6c:	01000a44 	movi	r4,41
81135a70:	113c0900 	call	8113c090 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
81135a74:	0001883a 	nop
81135a78:	e037883a 	mov	sp,fp
81135a7c:	dfc00117 	ldw	ra,4(sp)
81135a80:	df000017 	ldw	fp,0(sp)
81135a84:	dec00204 	addi	sp,sp,8
81135a88:	f800283a 	ret

81135a8c <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
81135a8c:	defffb04 	addi	sp,sp,-20
81135a90:	de00012e 	bgeu	sp,et,81135a98 <OS_InitTCBList+0xc>
81135a94:	003b68fa 	trap	3
81135a98:	dfc00415 	stw	ra,16(sp)
81135a9c:	df000315 	stw	fp,12(sp)
81135aa0:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
81135aa4:	01446e04 	movi	r5,4536
81135aa8:	012045b4 	movhi	r4,33046
81135aac:	211c9204 	addi	r4,r4,29256
81135ab0:	1135b780 	call	81135b78 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
81135ab4:	01402b04 	movi	r5,172
81135ab8:	012045f4 	movhi	r4,33047
81135abc:	21210004 	addi	r4,r4,-31744
81135ac0:	1135b780 	call	81135b78 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
81135ac4:	00a045b4 	movhi	r2,33046
81135ac8:	109c9204 	addi	r2,r2,29256
81135acc:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
81135ad0:	00a045b4 	movhi	r2,33046
81135ad4:	109cad04 	addi	r2,r2,29364
81135ad8:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81135adc:	e03ffd05 	stb	zero,-12(fp)
81135ae0:	00001106 	br	81135b28 <OS_InitTCBList+0x9c>
        ptcb1->OSTCBNext = ptcb2;
81135ae4:	e0bffe17 	ldw	r2,-8(fp)
81135ae8:	e0ffff17 	ldw	r3,-4(fp)
81135aec:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
81135af0:	e0bffe17 	ldw	r2,-8(fp)
81135af4:	00c00fc4 	movi	r3,63
81135af8:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81135afc:	e0bffe17 	ldw	r2,-8(fp)
81135b00:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
81135b04:	e0bffe17 	ldw	r2,-8(fp)
81135b08:	10801b04 	addi	r2,r2,108
81135b0c:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
81135b10:	e0bfff17 	ldw	r2,-4(fp)
81135b14:	10801b04 	addi	r2,r2,108
81135b18:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
81135b1c:	e0bffd03 	ldbu	r2,-12(fp)
81135b20:	10800044 	addi	r2,r2,1
81135b24:	e0bffd05 	stb	r2,-12(fp)
81135b28:	e0bffd03 	ldbu	r2,-12(fp)
81135b2c:	10800a70 	cmpltui	r2,r2,41
81135b30:	103fec1e 	bne	r2,zero,81135ae4 <__reset+0xfb115ae4>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
81135b34:	e0bffe17 	ldw	r2,-8(fp)
81135b38:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
81135b3c:	e0bffe17 	ldw	r2,-8(fp)
81135b40:	00c00fc4 	movi	r3,63
81135b44:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
81135b48:	e0bffe17 	ldw	r2,-8(fp)
81135b4c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
81135b50:	d0209015 	stw	zero,-32192(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
81135b54:	00a045b4 	movhi	r2,33046
81135b58:	109c9204 	addi	r2,r2,29256
81135b5c:	d0a09515 	stw	r2,-32172(gp)
}
81135b60:	0001883a 	nop
81135b64:	e037883a 	mov	sp,fp
81135b68:	dfc00117 	ldw	ra,4(sp)
81135b6c:	df000017 	ldw	fp,0(sp)
81135b70:	dec00204 	addi	sp,sp,8
81135b74:	f800283a 	ret

81135b78 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
81135b78:	defffd04 	addi	sp,sp,-12
81135b7c:	de00012e 	bgeu	sp,et,81135b84 <OS_MemClr+0xc>
81135b80:	003b68fa 	trap	3
81135b84:	df000215 	stw	fp,8(sp)
81135b88:	df000204 	addi	fp,sp,8
81135b8c:	e13ffe15 	stw	r4,-8(fp)
81135b90:	2805883a 	mov	r2,r5
81135b94:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81135b98:	00000706 	br	81135bb8 <OS_MemClr+0x40>
        *pdest++ = (INT8U)0;
81135b9c:	e0bffe17 	ldw	r2,-8(fp)
81135ba0:	10c00044 	addi	r3,r2,1
81135ba4:	e0fffe15 	stw	r3,-8(fp)
81135ba8:	10000005 	stb	zero,0(r2)
        size--;
81135bac:	e0bfff0b 	ldhu	r2,-4(fp)
81135bb0:	10bfffc4 	addi	r2,r2,-1
81135bb4:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
81135bb8:	e0bfff0b 	ldhu	r2,-4(fp)
81135bbc:	103ff71e 	bne	r2,zero,81135b9c <__reset+0xfb115b9c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
81135bc0:	0001883a 	nop
81135bc4:	e037883a 	mov	sp,fp
81135bc8:	df000017 	ldw	fp,0(sp)
81135bcc:	dec00104 	addi	sp,sp,4
81135bd0:	f800283a 	ret

81135bd4 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
81135bd4:	defffc04 	addi	sp,sp,-16
81135bd8:	de00012e 	bgeu	sp,et,81135be0 <OS_MemCopy+0xc>
81135bdc:	003b68fa 	trap	3
81135be0:	df000315 	stw	fp,12(sp)
81135be4:	df000304 	addi	fp,sp,12
81135be8:	e13ffd15 	stw	r4,-12(fp)
81135bec:	e17ffe15 	stw	r5,-8(fp)
81135bf0:	3005883a 	mov	r2,r6
81135bf4:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
81135bf8:	00000b06 	br	81135c28 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
81135bfc:	e0bffd17 	ldw	r2,-12(fp)
81135c00:	10c00044 	addi	r3,r2,1
81135c04:	e0fffd15 	stw	r3,-12(fp)
81135c08:	e0fffe17 	ldw	r3,-8(fp)
81135c0c:	19000044 	addi	r4,r3,1
81135c10:	e13ffe15 	stw	r4,-8(fp)
81135c14:	18c00003 	ldbu	r3,0(r3)
81135c18:	10c00005 	stb	r3,0(r2)
        size--;
81135c1c:	e0bfff0b 	ldhu	r2,-4(fp)
81135c20:	10bfffc4 	addi	r2,r2,-1
81135c24:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
81135c28:	e0bfff0b 	ldhu	r2,-4(fp)
81135c2c:	103ff31e 	bne	r2,zero,81135bfc <__reset+0xfb115bfc>
        *pdest++ = *psrc++;
        size--;
    }
}
81135c30:	0001883a 	nop
81135c34:	e037883a 	mov	sp,fp
81135c38:	df000017 	ldw	fp,0(sp)
81135c3c:	dec00104 	addi	sp,sp,4
81135c40:	f800283a 	ret

81135c44 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
81135c44:	defffb04 	addi	sp,sp,-20
81135c48:	de00012e 	bgeu	sp,et,81135c50 <OS_Sched+0xc>
81135c4c:	003b68fa 	trap	3
81135c50:	dfc00415 	stw	ra,16(sp)
81135c54:	df000315 	stw	fp,12(sp)
81135c58:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81135c5c:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135c60:	0005303a 	rdctl	r2,status
81135c64:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135c68:	e0ffff17 	ldw	r3,-4(fp)
81135c6c:	00bfff84 	movi	r2,-2
81135c70:	1884703a 	and	r2,r3,r2
81135c74:	1001703a 	wrctl	status,r2
  
  return context;
81135c78:	e0bfff17 	ldw	r2,-4(fp)
#endif



    OS_ENTER_CRITICAL();
81135c7c:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
81135c80:	d0a09d03 	ldbu	r2,-32140(gp)
81135c84:	10803fcc 	andi	r2,r2,255
81135c88:	10001a1e 	bne	r2,zero,81135cf4 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
81135c8c:	d0a08b03 	ldbu	r2,-32212(gp)
81135c90:	10803fcc 	andi	r2,r2,255
81135c94:	1000171e 	bne	r2,zero,81135cf4 <OS_Sched+0xb0>
            OS_SchedNew();
81135c98:	1135d1c0 	call	81135d1c <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
81135c9c:	d0e08f83 	ldbu	r3,-32194(gp)
81135ca0:	d0a08fc3 	ldbu	r2,-32193(gp)
81135ca4:	18c03fcc 	andi	r3,r3,255
81135ca8:	10803fcc 	andi	r2,r2,255
81135cac:	18801126 	beq	r3,r2,81135cf4 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
81135cb0:	d0a08f83 	ldbu	r2,-32194(gp)
81135cb4:	10c03fcc 	andi	r3,r2,255
81135cb8:	00a045f4 	movhi	r2,33047
81135cbc:	10a10004 	addi	r2,r2,-31744
81135cc0:	18c7883a 	add	r3,r3,r3
81135cc4:	18c7883a 	add	r3,r3,r3
81135cc8:	10c5883a 	add	r2,r2,r3
81135ccc:	10800017 	ldw	r2,0(r2)
81135cd0:	d0a09815 	stw	r2,-32160(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
81135cd4:	d0a09817 	ldw	r2,-32160(gp)
81135cd8:	10c00e17 	ldw	r3,56(r2)
81135cdc:	18c00044 	addi	r3,r3,1
81135ce0:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
81135ce4:	d0a09217 	ldw	r2,-32184(gp)
81135ce8:	10800044 	addi	r2,r2,1
81135cec:	d0a09215 	stw	r2,-32184(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
81135cf0:	1146c740 	call	81146c74 <OSCtxSw>
81135cf4:	e0bffd17 	ldw	r2,-12(fp)
81135cf8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135cfc:	e0bffe17 	ldw	r2,-8(fp)
81135d00:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
81135d04:	0001883a 	nop
81135d08:	e037883a 	mov	sp,fp
81135d0c:	dfc00117 	ldw	ra,4(sp)
81135d10:	df000017 	ldw	fp,0(sp)
81135d14:	dec00204 	addi	sp,sp,8
81135d18:	f800283a 	ret

81135d1c <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
81135d1c:	defffe04 	addi	sp,sp,-8
81135d20:	de00012e 	bgeu	sp,et,81135d28 <OS_SchedNew+0xc>
81135d24:	003b68fa 	trap	3
81135d28:	df000115 	stw	fp,4(sp)
81135d2c:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
81135d30:	d0a09a03 	ldbu	r2,-32152(gp)
81135d34:	10c03fcc 	andi	r3,r2,255
81135d38:	00a04574 	movhi	r2,33045
81135d3c:	10b20d04 	addi	r2,r2,-14284
81135d40:	10c5883a 	add	r2,r2,r3
81135d44:	10800003 	ldbu	r2,0(r2)
81135d48:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
81135d4c:	e0bfff03 	ldbu	r2,-4(fp)
81135d50:	100490fa 	slli	r2,r2,3
81135d54:	1009883a 	mov	r4,r2
81135d58:	e0ffff03 	ldbu	r3,-4(fp)
81135d5c:	d0a09a44 	addi	r2,gp,-32151
81135d60:	1885883a 	add	r2,r3,r2
81135d64:	10800003 	ldbu	r2,0(r2)
81135d68:	10c03fcc 	andi	r3,r2,255
81135d6c:	00a04574 	movhi	r2,33045
81135d70:	10b20d04 	addi	r2,r2,-14284
81135d74:	10c5883a 	add	r2,r2,r3
81135d78:	10800003 	ldbu	r2,0(r2)
81135d7c:	2085883a 	add	r2,r4,r2
81135d80:	d0a08f85 	stb	r2,-32194(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
81135d84:	0001883a 	nop
81135d88:	e037883a 	mov	sp,fp
81135d8c:	df000017 	ldw	fp,0(sp)
81135d90:	dec00104 	addi	sp,sp,4
81135d94:	f800283a 	ret

81135d98 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
81135d98:	defffc04 	addi	sp,sp,-16
81135d9c:	de00012e 	bgeu	sp,et,81135da4 <OS_StrCopy+0xc>
81135da0:	003b68fa 	trap	3
81135da4:	df000315 	stw	fp,12(sp)
81135da8:	df000304 	addi	fp,sp,12
81135dac:	e13ffe15 	stw	r4,-8(fp)
81135db0:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
81135db4:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
81135db8:	00000b06 	br	81135de8 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
81135dbc:	e0bffe17 	ldw	r2,-8(fp)
81135dc0:	10c00044 	addi	r3,r2,1
81135dc4:	e0fffe15 	stw	r3,-8(fp)
81135dc8:	e0ffff17 	ldw	r3,-4(fp)
81135dcc:	19000044 	addi	r4,r3,1
81135dd0:	e13fff15 	stw	r4,-4(fp)
81135dd4:	18c00003 	ldbu	r3,0(r3)
81135dd8:	10c00005 	stb	r3,0(r2)
        len++;
81135ddc:	e0bffd03 	ldbu	r2,-12(fp)
81135de0:	10800044 	addi	r2,r2,1
81135de4:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81135de8:	e0bfff17 	ldw	r2,-4(fp)
81135dec:	10800003 	ldbu	r2,0(r2)
81135df0:	10803fcc 	andi	r2,r2,255
81135df4:	103ff11e 	bne	r2,zero,81135dbc <__reset+0xfb115dbc>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
81135df8:	e0bffe17 	ldw	r2,-8(fp)
81135dfc:	10000005 	stb	zero,0(r2)
    return (len);
81135e00:	e0bffd03 	ldbu	r2,-12(fp)
}
81135e04:	e037883a 	mov	sp,fp
81135e08:	df000017 	ldw	fp,0(sp)
81135e0c:	dec00104 	addi	sp,sp,4
81135e10:	f800283a 	ret

81135e14 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
81135e14:	defffd04 	addi	sp,sp,-12
81135e18:	de00012e 	bgeu	sp,et,81135e20 <OS_StrLen+0xc>
81135e1c:	003b68fa 	trap	3
81135e20:	df000215 	stw	fp,8(sp)
81135e24:	df000204 	addi	fp,sp,8
81135e28:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
81135e2c:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
81135e30:	00000606 	br	81135e4c <OS_StrLen+0x38>
        psrc++;
81135e34:	e0bfff17 	ldw	r2,-4(fp)
81135e38:	10800044 	addi	r2,r2,1
81135e3c:	e0bfff15 	stw	r2,-4(fp)
        len++;
81135e40:	e0bffe03 	ldbu	r2,-8(fp)
81135e44:	10800044 	addi	r2,r2,1
81135e48:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
81135e4c:	e0bfff17 	ldw	r2,-4(fp)
81135e50:	10800003 	ldbu	r2,0(r2)
81135e54:	10803fcc 	andi	r2,r2,255
81135e58:	103ff61e 	bne	r2,zero,81135e34 <__reset+0xfb115e34>
        psrc++;
        len++;
    }
    return (len);
81135e5c:	e0bffe03 	ldbu	r2,-8(fp)
}
81135e60:	e037883a 	mov	sp,fp
81135e64:	df000017 	ldw	fp,0(sp)
81135e68:	dec00104 	addi	sp,sp,4
81135e6c:	f800283a 	ret

81135e70 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
81135e70:	defffa04 	addi	sp,sp,-24
81135e74:	de00012e 	bgeu	sp,et,81135e7c <OS_TaskIdle+0xc>
81135e78:	003b68fa 	trap	3
81135e7c:	dfc00515 	stw	ra,20(sp)
81135e80:	df000415 	stw	fp,16(sp)
81135e84:	df000404 	addi	fp,sp,16
81135e88:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135e8c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135e90:	0005303a 	rdctl	r2,status
81135e94:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135e98:	e0fffd17 	ldw	r3,-12(fp)
81135e9c:	00bfff84 	movi	r2,-2
81135ea0:	1884703a 	and	r2,r3,r2
81135ea4:	1001703a 	wrctl	status,r2
  
  return context;
81135ea8:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
81135eac:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
81135eb0:	d0a08e17 	ldw	r2,-32200(gp)
81135eb4:	10800044 	addi	r2,r2,1
81135eb8:	d0a08e15 	stw	r2,-32200(gp)
81135ebc:	e0bffc17 	ldw	r2,-16(fp)
81135ec0:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135ec4:	e0bffe17 	ldw	r2,-8(fp)
81135ec8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
81135ecc:	11470080 	call	81147008 <OSTaskIdleHook>
    }
81135ed0:	003fef06 	br	81135e90 <__reset+0xfb115e90>

81135ed4 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
81135ed4:	defff804 	addi	sp,sp,-32
81135ed8:	de00012e 	bgeu	sp,et,81135ee0 <OS_TaskStat+0xc>
81135edc:	003b68fa 	trap	3
81135ee0:	dfc00715 	stw	ra,28(sp)
81135ee4:	df000615 	stw	fp,24(sp)
81135ee8:	dc400515 	stw	r17,20(sp)
81135eec:	dc000415 	stw	r16,16(sp)
81135ef0:	df000604 	addi	fp,sp,24
81135ef4:	e13ffd15 	stw	r4,-12(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81135ef8:	e03ffa15 	stw	zero,-24(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81135efc:	00000206 	br	81135f08 <OS_TaskStat+0x34>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
81135f00:	01003204 	movi	r4,200
81135f04:	113c9800 	call	8113c980 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
81135f08:	d0a0a303 	ldbu	r2,-32116(gp)
81135f0c:	10803fcc 	andi	r2,r2,255
81135f10:	103ffb26 	beq	r2,zero,81135f00 <__reset+0xfb115f00>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
81135f14:	d0e09417 	ldw	r3,-32176(gp)
81135f18:	00947b34 	movhi	r2,20972
81135f1c:	10a147c4 	addi	r2,r2,-31457
81135f20:	1888383a 	mulxuu	r4,r3,r2
81135f24:	1885383a 	mul	r2,r3,r2
81135f28:	1021883a 	mov	r16,r2
81135f2c:	2023883a 	mov	r17,r4
81135f30:	8804d17a 	srli	r2,r17,5
81135f34:	d0a09415 	stw	r2,-32176(gp)
    if (OSIdleCtrMax == 0L) {
81135f38:	d0a09417 	ldw	r2,-32176(gp)
81135f3c:	1000031e 	bne	r2,zero,81135f4c <OS_TaskStat+0x78>
        OSCPUUsage = 0;
81135f40:	d0209605 	stb	zero,-32168(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
81135f44:	01003fc4 	movi	r4,255
81135f48:	113c5f00 	call	8113c5f0 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81135f4c:	0005303a 	rdctl	r2,status
81135f50:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81135f54:	e0fffb17 	ldw	r3,-20(fp)
81135f58:	00bfff84 	movi	r2,-2
81135f5c:	1884703a 	and	r2,r3,r2
81135f60:	1001703a 	wrctl	status,r2
  
  return context;
81135f64:	e0bffb17 	ldw	r2,-20(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
81135f68:	e0bffa15 	stw	r2,-24(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
81135f6c:	d0a08e17 	ldw	r2,-32200(gp)
81135f70:	d0a0a415 	stw	r2,-32112(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
81135f74:	d0208e15 	stw	zero,-32200(gp)
81135f78:	e0bffa17 	ldw	r2,-24(fp)
81135f7c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81135f80:	e0bffc17 	ldw	r2,-16(fp)
81135f84:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
81135f88:	d0e0a417 	ldw	r3,-32112(gp)
81135f8c:	d0a09417 	ldw	r2,-32176(gp)
81135f90:	1885203a 	divu	r2,r3,r2
81135f94:	1007883a 	mov	r3,r2
81135f98:	00801904 	movi	r2,100
81135f9c:	10c5c83a 	sub	r2,r2,r3
81135fa0:	d0a09605 	stb	r2,-32168(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
81135fa4:	1146f380 	call	81146f38 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
81135fa8:	1135fb80 	call	81135fb8 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
81135fac:	01001904 	movi	r4,100
81135fb0:	113c9800 	call	8113c980 <OSTimeDly>
    }
81135fb4:	003fe506 	br	81135f4c <__reset+0xfb115f4c>

81135fb8 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
81135fb8:	defffa04 	addi	sp,sp,-24
81135fbc:	de00012e 	bgeu	sp,et,81135fc4 <OS_TaskStatStkChk+0xc>
81135fc0:	003b68fa 	trap	3
81135fc4:	dfc00515 	stw	ra,20(sp)
81135fc8:	df000415 	stw	fp,16(sp)
81135fcc:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
81135fd0:	e03ffc05 	stb	zero,-16(fp)
81135fd4:	00002406 	br	81136068 <OS_TaskStatStkChk+0xb0>
        err = OSTaskStkChk(prio, &stk_data);
81135fd8:	e0bffc03 	ldbu	r2,-16(fp)
81135fdc:	e0fffe04 	addi	r3,fp,-8
81135fe0:	180b883a 	mov	r5,r3
81135fe4:	1009883a 	mov	r4,r2
81135fe8:	113c4280 	call	8113c428 <OSTaskStkChk>
81135fec:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
81135ff0:	e0bffc43 	ldbu	r2,-15(fp)
81135ff4:	1000191e 	bne	r2,zero,8113605c <OS_TaskStatStkChk+0xa4>
            ptcb = OSTCBPrioTbl[prio];
81135ff8:	e0fffc03 	ldbu	r3,-16(fp)
81135ffc:	00a045f4 	movhi	r2,33047
81136000:	10a10004 	addi	r2,r2,-31744
81136004:	18c7883a 	add	r3,r3,r3
81136008:	18c7883a 	add	r3,r3,r3
8113600c:	10c5883a 	add	r2,r2,r3
81136010:	10800017 	ldw	r2,0(r2)
81136014:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
81136018:	e0bffd17 	ldw	r2,-12(fp)
8113601c:	10000f26 	beq	r2,zero,8113605c <OS_TaskStatStkChk+0xa4>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
81136020:	e0bffd17 	ldw	r2,-12(fp)
81136024:	10800060 	cmpeqi	r2,r2,1
81136028:	10000c1e 	bne	r2,zero,8113605c <OS_TaskStatStkChk+0xa4>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
8113602c:	e0bffd17 	ldw	r2,-12(fp)
81136030:	10c00217 	ldw	r3,8(r2)
81136034:	e0bffd17 	ldw	r2,-12(fp)
81136038:	10800317 	ldw	r2,12(r2)
8113603c:	1085883a 	add	r2,r2,r2
81136040:	1085883a 	add	r2,r2,r2
81136044:	1887883a 	add	r3,r3,r2
81136048:	e0bffd17 	ldw	r2,-12(fp)
8113604c:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
81136050:	e0ffff17 	ldw	r3,-4(fp)
81136054:	e0bffd17 	ldw	r2,-12(fp)
81136058:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
8113605c:	e0bffc03 	ldbu	r2,-16(fp)
81136060:	10800044 	addi	r2,r2,1
81136064:	e0bffc05 	stb	r2,-16(fp)
81136068:	e0bffc03 	ldbu	r2,-16(fp)
8113606c:	10800af0 	cmpltui	r2,r2,43
81136070:	103fd91e 	bne	r2,zero,81135fd8 <__reset+0xfb115fd8>
#endif
                }
            }
        }
    }
}
81136074:	0001883a 	nop
81136078:	e037883a 	mov	sp,fp
8113607c:	dfc00117 	ldw	ra,4(sp)
81136080:	df000017 	ldw	fp,0(sp)
81136084:	dec00204 	addi	sp,sp,8
81136088:	f800283a 	ret

8113608c <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
8113608c:	defff204 	addi	sp,sp,-56
81136090:	de00012e 	bgeu	sp,et,81136098 <OS_TCBInit+0xc>
81136094:	003b68fa 	trap	3
81136098:	dfc00d15 	stw	ra,52(sp)
8113609c:	df000c15 	stw	fp,48(sp)
811360a0:	df000c04 	addi	fp,sp,48
811360a4:	e17ffc15 	stw	r5,-16(fp)
811360a8:	e1bffd15 	stw	r6,-12(fp)
811360ac:	3807883a 	mov	r3,r7
811360b0:	e0800417 	ldw	r2,16(fp)
811360b4:	e13ffb05 	stb	r4,-20(fp)
811360b8:	e0fffe0d 	sth	r3,-8(fp)
811360bc:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811360c0:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811360c4:	0005303a 	rdctl	r2,status
811360c8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811360cc:	e0fffa17 	ldw	r3,-24(fp)
811360d0:	00bfff84 	movi	r2,-2
811360d4:	1884703a 	and	r2,r3,r2
811360d8:	1001703a 	wrctl	status,r2
  
  return context;
811360dc:	e0bffa17 	ldw	r2,-24(fp)
#endif



    OS_ENTER_CRITICAL();
811360e0:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
811360e4:	d0a09517 	ldw	r2,-32172(gp)
811360e8:	e0bff615 	stw	r2,-40(fp)
    if (ptcb != (OS_TCB *)0) {
811360ec:	e0bff617 	ldw	r2,-40(fp)
811360f0:	10009326 	beq	r2,zero,81136340 <OS_TCBInit+0x2b4>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
811360f4:	e0bff617 	ldw	r2,-40(fp)
811360f8:	10800517 	ldw	r2,20(r2)
811360fc:	d0a09515 	stw	r2,-32172(gp)
81136100:	e0bff417 	ldw	r2,-48(fp)
81136104:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136108:	e0bff817 	ldw	r2,-32(fp)
8113610c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
81136110:	e0bff617 	ldw	r2,-40(fp)
81136114:	e0fffc17 	ldw	r3,-16(fp)
81136118:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
8113611c:	e0bff617 	ldw	r2,-40(fp)
81136120:	e0fffb03 	ldbu	r3,-20(fp)
81136124:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
81136128:	e0bff617 	ldw	r2,-40(fp)
8113612c:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
81136130:	e0bff617 	ldw	r2,-40(fp)
81136134:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
81136138:	e0bff617 	ldw	r2,-40(fp)
8113613c:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
81136140:	e0bff617 	ldw	r2,-40(fp)
81136144:	e0c00317 	ldw	r3,12(fp)
81136148:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
8113614c:	e0bff617 	ldw	r2,-40(fp)
81136150:	e0c00217 	ldw	r3,8(fp)
81136154:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
81136158:	e0bff617 	ldw	r2,-40(fp)
8113615c:	e0fffd17 	ldw	r3,-12(fp)
81136160:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
81136164:	e0bff617 	ldw	r2,-40(fp)
81136168:	e0ffff0b 	ldhu	r3,-4(fp)
8113616c:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
81136170:	e0bff617 	ldw	r2,-40(fp)
81136174:	e0fffe0b 	ldhu	r3,-8(fp)
81136178:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
8113617c:	e0bff617 	ldw	r2,-40(fp)
81136180:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
81136184:	e0bffb03 	ldbu	r2,-20(fp)
81136188:	1004d0fa 	srli	r2,r2,3
8113618c:	1007883a 	mov	r3,r2
81136190:	e0bff617 	ldw	r2,-40(fp)
81136194:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
81136198:	e0bffb03 	ldbu	r2,-20(fp)
8113619c:	108001cc 	andi	r2,r2,7
811361a0:	1007883a 	mov	r3,r2
811361a4:	e0bff617 	ldw	r2,-40(fp)
811361a8:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
811361ac:	e0bff617 	ldw	r2,-40(fp)
811361b0:	10800d03 	ldbu	r2,52(r2)
811361b4:	10803fcc 	andi	r2,r2,255
811361b8:	00c00044 	movi	r3,1
811361bc:	1884983a 	sll	r2,r3,r2
811361c0:	1007883a 	mov	r3,r2
811361c4:	e0bff617 	ldw	r2,-40(fp)
811361c8:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
811361cc:	e0bff617 	ldw	r2,-40(fp)
811361d0:	10800cc3 	ldbu	r2,51(r2)
811361d4:	10803fcc 	andi	r2,r2,255
811361d8:	00c00044 	movi	r3,1
811361dc:	1884983a 	sll	r2,r3,r2
811361e0:	1007883a 	mov	r3,r2
811361e4:	e0bff617 	ldw	r2,-40(fp)
811361e8:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
811361ec:	e0bff617 	ldw	r2,-40(fp)
811361f0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
811361f4:	e0bff617 	ldw	r2,-40(fp)
811361f8:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
811361fc:	e0bff617 	ldw	r2,-40(fp)
81136200:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
81136204:	e0bff617 	ldw	r2,-40(fp)
81136208:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
8113620c:	e0bff617 	ldw	r2,-40(fp)
81136210:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
81136214:	e0bff617 	ldw	r2,-40(fp)
81136218:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
8113621c:	e0bff617 	ldw	r2,-40(fp)
81136220:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
81136224:	e0bff617 	ldw	r2,-40(fp)
81136228:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
8113622c:	e0bff617 	ldw	r2,-40(fp)
81136230:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
81136234:	e0bff617 	ldw	r2,-40(fp)
81136238:	00c00fc4 	movi	r3,63
8113623c:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
81136240:	e0bff617 	ldw	r2,-40(fp)
81136244:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
81136248:	e13ff617 	ldw	r4,-40(fp)
8113624c:	11470300 	call	81147030 <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
81136250:	e13ff617 	ldw	r4,-40(fp)
81136254:	1146eb80 	call	81146eb8 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136258:	0005303a 	rdctl	r2,status
8113625c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136260:	e0fff517 	ldw	r3,-44(fp)
81136264:	00bfff84 	movi	r2,-2
81136268:	1884703a 	and	r2,r3,r2
8113626c:	1001703a 	wrctl	status,r2
  
  return context;
81136270:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
81136274:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
81136278:	e0fffb03 	ldbu	r3,-20(fp)
8113627c:	00a045f4 	movhi	r2,33047
81136280:	10a10004 	addi	r2,r2,-31744
81136284:	18c7883a 	add	r3,r3,r3
81136288:	18c7883a 	add	r3,r3,r3
8113628c:	10c5883a 	add	r2,r2,r3
81136290:	e0fff617 	ldw	r3,-40(fp)
81136294:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
81136298:	d0e09017 	ldw	r3,-32192(gp)
8113629c:	e0bff617 	ldw	r2,-40(fp)
811362a0:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
811362a4:	e0bff617 	ldw	r2,-40(fp)
811362a8:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
811362ac:	d0a09017 	ldw	r2,-32192(gp)
811362b0:	10000326 	beq	r2,zero,811362c0 <OS_TCBInit+0x234>
            OSTCBList->OSTCBPrev = ptcb;
811362b4:	d0a09017 	ldw	r2,-32192(gp)
811362b8:	e0fff617 	ldw	r3,-40(fp)
811362bc:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
811362c0:	e0bff617 	ldw	r2,-40(fp)
811362c4:	d0a09015 	stw	r2,-32192(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
811362c8:	e0bff617 	ldw	r2,-40(fp)
811362cc:	10c00d83 	ldbu	r3,54(r2)
811362d0:	d0a09a03 	ldbu	r2,-32152(gp)
811362d4:	1884b03a 	or	r2,r3,r2
811362d8:	d0a09a05 	stb	r2,-32152(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
811362dc:	e0bff617 	ldw	r2,-40(fp)
811362e0:	10800d03 	ldbu	r2,52(r2)
811362e4:	10c03fcc 	andi	r3,r2,255
811362e8:	e0bff617 	ldw	r2,-40(fp)
811362ec:	10800d03 	ldbu	r2,52(r2)
811362f0:	11003fcc 	andi	r4,r2,255
811362f4:	d0a09a44 	addi	r2,gp,-32151
811362f8:	2085883a 	add	r2,r4,r2
811362fc:	11000003 	ldbu	r4,0(r2)
81136300:	e0bff617 	ldw	r2,-40(fp)
81136304:	10800d43 	ldbu	r2,53(r2)
81136308:	2084b03a 	or	r2,r4,r2
8113630c:	1009883a 	mov	r4,r2
81136310:	d0a09a44 	addi	r2,gp,-32151
81136314:	1885883a 	add	r2,r3,r2
81136318:	11000005 	stb	r4,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
8113631c:	d0a09643 	ldbu	r2,-32167(gp)
81136320:	10800044 	addi	r2,r2,1
81136324:	d0a09645 	stb	r2,-32167(gp)
81136328:	e0bff417 	ldw	r2,-48(fp)
8113632c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136330:	e0bff717 	ldw	r2,-36(fp)
81136334:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
81136338:	0005883a 	mov	r2,zero
8113633c:	00000506 	br	81136354 <OS_TCBInit+0x2c8>
81136340:	e0bff417 	ldw	r2,-48(fp)
81136344:	e0bff915 	stw	r2,-28(fp)
81136348:	e0bff917 	ldw	r2,-28(fp)
8113634c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
81136350:	00801084 	movi	r2,66
}
81136354:	e037883a 	mov	sp,fp
81136358:	dfc00117 	ldw	ra,4(sp)
8113635c:	df000017 	ldw	fp,0(sp)
81136360:	dec00204 	addi	sp,sp,8
81136364:	f800283a 	ret

81136368 <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
81136368:	defffe04 	addi	sp,sp,-8
8113636c:	de00012e 	bgeu	sp,et,81136374 <OSDebugInit+0xc>
81136370:	003b68fa 	trap	3
81136374:	df000115 	stw	fp,4(sp)
81136378:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
8113637c:	d0a01804 	addi	r2,gp,-32672
81136380:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
81136384:	d0a01904 	addi	r2,gp,-32668
81136388:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
8113638c:	d0a01a84 	addi	r2,gp,-32662
81136390:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
81136394:	d0a01b04 	addi	r2,gp,-32660
81136398:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
8113639c:	d0a01a04 	addi	r2,gp,-32664
811363a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
811363a4:	d0a01b84 	addi	r2,gp,-32658
811363a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
811363ac:	d0a01c04 	addi	r2,gp,-32656
811363b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
811363b4:	d0a01c84 	addi	r2,gp,-32654
811363b8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
811363bc:	d0a01d04 	addi	r2,gp,-32652
811363c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
811363c4:	d0a01d84 	addi	r2,gp,-32650
811363c8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
811363cc:	d0a01e04 	addi	r2,gp,-32648
811363d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
811363d4:	d0a01e84 	addi	r2,gp,-32646
811363d8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
811363dc:	d0a01f04 	addi	r2,gp,-32644
811363e0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
811363e4:	d0a01f84 	addi	r2,gp,-32642
811363e8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
811363ec:	d0a02004 	addi	r2,gp,-32640
811363f0:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
811363f4:	d0a02084 	addi	r2,gp,-32638
811363f8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
811363fc:	d0a02104 	addi	r2,gp,-32636
81136400:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
81136404:	d0a02184 	addi	r2,gp,-32634
81136408:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
8113640c:	d0a02204 	addi	r2,gp,-32632
81136410:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
81136414:	d0a02284 	addi	r2,gp,-32630
81136418:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
8113641c:	d0a02304 	addi	r2,gp,-32628
81136420:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
81136424:	d0a02384 	addi	r2,gp,-32626
81136428:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
8113642c:	d0a02404 	addi	r2,gp,-32624
81136430:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
81136434:	d0a02484 	addi	r2,gp,-32622
81136438:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
8113643c:	d0a02504 	addi	r2,gp,-32620
81136440:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
81136444:	d0a02584 	addi	r2,gp,-32618
81136448:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
8113644c:	d0a02604 	addi	r2,gp,-32616
81136450:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
81136454:	d0a02684 	addi	r2,gp,-32614
81136458:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
8113645c:	d0a02704 	addi	r2,gp,-32612
81136460:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
81136464:	d0a02784 	addi	r2,gp,-32610
81136468:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
8113646c:	d0a02804 	addi	r2,gp,-32608
81136470:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
81136474:	d0a02884 	addi	r2,gp,-32606
81136478:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
8113647c:	d0a02904 	addi	r2,gp,-32604
81136480:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
81136484:	d0a02984 	addi	r2,gp,-32602
81136488:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
8113648c:	d0a02a04 	addi	r2,gp,-32600
81136490:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
81136494:	d0a02a84 	addi	r2,gp,-32598
81136498:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
8113649c:	d0a02b04 	addi	r2,gp,-32596
811364a0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
811364a4:	d0a02b84 	addi	r2,gp,-32594
811364a8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
811364ac:	d0a02c04 	addi	r2,gp,-32592
811364b0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
811364b4:	d0a02c84 	addi	r2,gp,-32590
811364b8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
811364bc:	d0a02d04 	addi	r2,gp,-32588
811364c0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
811364c4:	d0a02d84 	addi	r2,gp,-32586
811364c8:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
811364cc:	d0a02e04 	addi	r2,gp,-32584
811364d0:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
811364d4:	d0a02e84 	addi	r2,gp,-32582
811364d8:	e0bfff15 	stw	r2,-4(fp)

#if OS_TMR_EN > 0
    ptemp = (void *)&OSTmrTbl[0];
811364dc:	00a045b4 	movhi	r2,33046
811364e0:	108b1e04 	addi	r2,r2,11384
811364e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTbl[0];
811364e8:	00a045b4 	movhi	r2,33046
811364ec:	10890a04 	addi	r2,r2,9256
811364f0:	e0bfff15 	stw	r2,-4(fp)
    
    ptemp = (void *)&OSTmrEn;
811364f4:	d0a02f84 	addi	r2,gp,-32578
811364f8:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgMax;
811364fc:	d0a03004 	addi	r2,gp,-32576
81136500:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgNameSize;
81136504:	d0a03084 	addi	r2,gp,-32574
81136508:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgWheelSize;
8113650c:	d0a03104 	addi	r2,gp,-32572
81136510:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrCfgTicksPerSec;
81136514:	d0a03184 	addi	r2,gp,-32570
81136518:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrSize;
8113651c:	d0a03204 	addi	r2,gp,-32568
81136520:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrTblSize;
81136524:	d0a03284 	addi	r2,gp,-32566
81136528:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
8113652c:	d0a03304 	addi	r2,gp,-32564
81136530:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTmrWheelTblSize;
81136534:	d0a03384 	addi	r2,gp,-32562
81136538:	e0bfff15 	stw	r2,-4(fp)
#endif

    ptemp = (void *)&OSVersionNbr;
8113653c:	d0a02f04 	addi	r2,gp,-32580
81136540:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
81136544:	d0a03404 	addi	r2,gp,-32560
81136548:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
8113654c:	0001883a 	nop
81136550:	e037883a 	mov	sp,fp
81136554:	df000017 	ldw	fp,0(sp)
81136558:	dec00104 	addi	sp,sp,4
8113655c:	f800283a 	ret

81136560 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
81136560:	defff204 	addi	sp,sp,-56
81136564:	de00012e 	bgeu	sp,et,8113656c <OSFlagAccept+0xc>
81136568:	003b68fa 	trap	3
8113656c:	df000d15 	stw	fp,52(sp)
81136570:	df000d04 	addi	fp,sp,52
81136574:	e13ffc15 	stw	r4,-16(fp)
81136578:	2807883a 	mov	r3,r5
8113657c:	3005883a 	mov	r2,r6
81136580:	e1ffff15 	stw	r7,-4(fp)
81136584:	e0fffd0d 	sth	r3,-12(fp)
81136588:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
8113658c:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136590:	e0bfff17 	ldw	r2,-4(fp)
81136594:	1000021e 	bne	r2,zero,811365a0 <OSFlagAccept+0x40>
        return ((OS_FLAGS)0);
81136598:	0005883a 	mov	r2,zero
8113659c:	0000b006 	br	81136860 <OSFlagAccept+0x300>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811365a0:	e0bffc17 	ldw	r2,-16(fp)
811365a4:	1000051e 	bne	r2,zero,811365bc <OSFlagAccept+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811365a8:	e0bfff17 	ldw	r2,-4(fp)
811365ac:	00c01b84 	movi	r3,110
811365b0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811365b4:	0005883a 	mov	r2,zero
811365b8:	0000a906 	br	81136860 <OSFlagAccept+0x300>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
811365bc:	e0bffc17 	ldw	r2,-16(fp)
811365c0:	10800003 	ldbu	r2,0(r2)
811365c4:	10803fcc 	andi	r2,r2,255
811365c8:	10800160 	cmpeqi	r2,r2,5
811365cc:	1000051e 	bne	r2,zero,811365e4 <OSFlagAccept+0x84>
        *perr = OS_ERR_EVENT_TYPE;
811365d0:	e0bfff17 	ldw	r2,-4(fp)
811365d4:	00c00044 	movi	r3,1
811365d8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811365dc:	0005883a 	mov	r2,zero
811365e0:	00009f06 	br	81136860 <OSFlagAccept+0x300>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
811365e4:	e0fffe03 	ldbu	r3,-8(fp)
811365e8:	00bfe004 	movi	r2,-128
811365ec:	1884703a 	and	r2,r3,r2
811365f0:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
811365f4:	e0bff503 	ldbu	r2,-44(fp)
811365f8:	10000626 	beq	r2,zero,81136614 <OSFlagAccept+0xb4>
        wait_type &= ~OS_FLAG_CONSUME;
811365fc:	e0bffe03 	ldbu	r2,-8(fp)
81136600:	10801fcc 	andi	r2,r2,127
81136604:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81136608:	00800044 	movi	r2,1
8113660c:	e0bff385 	stb	r2,-50(fp)
81136610:	00000106 	br	81136618 <OSFlagAccept+0xb8>
    } else {
        consume    = OS_FALSE;
81136614:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
81136618:	e0bfff17 	ldw	r2,-4(fp)
8113661c:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136620:	0005303a 	rdctl	r2,status
81136624:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136628:	e0fffb17 	ldw	r3,-20(fp)
8113662c:	00bfff84 	movi	r2,-2
81136630:	1884703a 	and	r2,r3,r2
81136634:	1001703a 	wrctl	status,r2
  
  return context;
81136638:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
8113663c:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
81136640:	e0bffe03 	ldbu	r2,-8(fp)
81136644:	10c00060 	cmpeqi	r3,r2,1
81136648:	18005f1e 	bne	r3,zero,811367c8 <OSFlagAccept+0x268>
8113664c:	10c00088 	cmpgei	r3,r2,2
81136650:	1800021e 	bne	r3,zero,8113665c <OSFlagAccept+0xfc>
81136654:	10003f26 	beq	r2,zero,81136754 <OSFlagAccept+0x1f4>
81136658:	00007706 	br	81136838 <OSFlagAccept+0x2d8>
8113665c:	10c000a0 	cmpeqi	r3,r2,2
81136660:	1800031e 	bne	r3,zero,81136670 <OSFlagAccept+0x110>
81136664:	108000e0 	cmpeqi	r2,r2,3
81136668:	10001e1e 	bne	r2,zero,811366e4 <OSFlagAccept+0x184>
8113666c:	00007206 	br	81136838 <OSFlagAccept+0x2d8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
81136670:	e0bffc17 	ldw	r2,-16(fp)
81136674:	10c0020b 	ldhu	r3,8(r2)
81136678:	e0bffd0b 	ldhu	r2,-12(fp)
8113667c:	1884703a 	and	r2,r3,r2
81136680:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81136684:	e0fff30b 	ldhu	r3,-52(fp)
81136688:	e0bffd0b 	ldhu	r2,-12(fp)
8113668c:	18800d1e 	bne	r3,r2,811366c4 <OSFlagAccept+0x164>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81136690:	e0bff383 	ldbu	r2,-50(fp)
81136694:	10800058 	cmpnei	r2,r2,1
81136698:	10000d1e 	bne	r2,zero,811366d0 <OSFlagAccept+0x170>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
8113669c:	e0bffc17 	ldw	r2,-16(fp)
811366a0:	1080020b 	ldhu	r2,8(r2)
811366a4:	1007883a 	mov	r3,r2
811366a8:	e0bff30b 	ldhu	r2,-52(fp)
811366ac:	0084303a 	nor	r2,zero,r2
811366b0:	1884703a 	and	r2,r3,r2
811366b4:	1007883a 	mov	r3,r2
811366b8:	e0bffc17 	ldw	r2,-16(fp)
811366bc:	10c0020d 	sth	r3,8(r2)
811366c0:	00000306 	br	811366d0 <OSFlagAccept+0x170>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811366c4:	e0bfff17 	ldw	r2,-4(fp)
811366c8:	00c01c04 	movi	r3,112
811366cc:	10c00005 	stb	r3,0(r2)
811366d0:	e0bff417 	ldw	r2,-48(fp)
811366d4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811366d8:	e0bff617 	ldw	r2,-40(fp)
811366dc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811366e0:	00005e06 	br	8113685c <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
811366e4:	e0bffc17 	ldw	r2,-16(fp)
811366e8:	10c0020b 	ldhu	r3,8(r2)
811366ec:	e0bffd0b 	ldhu	r2,-12(fp)
811366f0:	1884703a 	and	r2,r3,r2
811366f4:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
811366f8:	e0bff30b 	ldhu	r2,-52(fp)
811366fc:	10000d26 	beq	r2,zero,81136734 <OSFlagAccept+0x1d4>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81136700:	e0bff383 	ldbu	r2,-50(fp)
81136704:	10800058 	cmpnei	r2,r2,1
81136708:	10000d1e 	bne	r2,zero,81136740 <OSFlagAccept+0x1e0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
8113670c:	e0bffc17 	ldw	r2,-16(fp)
81136710:	1080020b 	ldhu	r2,8(r2)
81136714:	1007883a 	mov	r3,r2
81136718:	e0bff30b 	ldhu	r2,-52(fp)
8113671c:	0084303a 	nor	r2,zero,r2
81136720:	1884703a 	and	r2,r3,r2
81136724:	1007883a 	mov	r3,r2
81136728:	e0bffc17 	ldw	r2,-16(fp)
8113672c:	10c0020d 	sth	r3,8(r2)
81136730:	00000306 	br	81136740 <OSFlagAccept+0x1e0>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81136734:	e0bfff17 	ldw	r2,-4(fp)
81136738:	00c01c04 	movi	r3,112
8113673c:	10c00005 	stb	r3,0(r2)
81136740:	e0bff417 	ldw	r2,-48(fp)
81136744:	e0bff715 	stw	r2,-36(fp)
81136748:	e0bff717 	ldw	r2,-36(fp)
8113674c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81136750:	00004206 	br	8113685c <OSFlagAccept+0x2fc>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81136754:	e0bffc17 	ldw	r2,-16(fp)
81136758:	1080020b 	ldhu	r2,8(r2)
8113675c:	0084303a 	nor	r2,zero,r2
81136760:	1007883a 	mov	r3,r2
81136764:	e0bffd0b 	ldhu	r2,-12(fp)
81136768:	1884703a 	and	r2,r3,r2
8113676c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81136770:	e0fff30b 	ldhu	r3,-52(fp)
81136774:	e0bffd0b 	ldhu	r2,-12(fp)
81136778:	18800b1e 	bne	r3,r2,811367a8 <OSFlagAccept+0x248>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
8113677c:	e0bff383 	ldbu	r2,-50(fp)
81136780:	10800058 	cmpnei	r2,r2,1
81136784:	10000b1e 	bne	r2,zero,811367b4 <OSFlagAccept+0x254>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81136788:	e0bffc17 	ldw	r2,-16(fp)
8113678c:	10c0020b 	ldhu	r3,8(r2)
81136790:	e0bff30b 	ldhu	r2,-52(fp)
81136794:	1884b03a 	or	r2,r3,r2
81136798:	1007883a 	mov	r3,r2
8113679c:	e0bffc17 	ldw	r2,-16(fp)
811367a0:	10c0020d 	sth	r3,8(r2)
811367a4:	00000306 	br	811367b4 <OSFlagAccept+0x254>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
811367a8:	e0bfff17 	ldw	r2,-4(fp)
811367ac:	00c01c04 	movi	r3,112
811367b0:	10c00005 	stb	r3,0(r2)
811367b4:	e0bff417 	ldw	r2,-48(fp)
811367b8:	e0bff815 	stw	r2,-32(fp)
811367bc:	e0bff817 	ldw	r2,-32(fp)
811367c0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
811367c4:	00002506 	br	8113685c <OSFlagAccept+0x2fc>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811367c8:	e0bffc17 	ldw	r2,-16(fp)
811367cc:	1080020b 	ldhu	r2,8(r2)
811367d0:	0084303a 	nor	r2,zero,r2
811367d4:	1007883a 	mov	r3,r2
811367d8:	e0bffd0b 	ldhu	r2,-12(fp)
811367dc:	1884703a 	and	r2,r3,r2
811367e0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811367e4:	e0bff30b 	ldhu	r2,-52(fp)
811367e8:	10000b26 	beq	r2,zero,81136818 <OSFlagAccept+0x2b8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811367ec:	e0bff383 	ldbu	r2,-50(fp)
811367f0:	10800058 	cmpnei	r2,r2,1
811367f4:	10000b1e 	bne	r2,zero,81136824 <OSFlagAccept+0x2c4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811367f8:	e0bffc17 	ldw	r2,-16(fp)
811367fc:	10c0020b 	ldhu	r3,8(r2)
81136800:	e0bff30b 	ldhu	r2,-52(fp)
81136804:	1884b03a 	or	r2,r3,r2
81136808:	1007883a 	mov	r3,r2
8113680c:	e0bffc17 	ldw	r2,-16(fp)
81136810:	10c0020d 	sth	r3,8(r2)
81136814:	00000306 	br	81136824 <OSFlagAccept+0x2c4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
81136818:	e0bfff17 	ldw	r2,-4(fp)
8113681c:	00c01c04 	movi	r3,112
81136820:	10c00005 	stb	r3,0(r2)
81136824:	e0bff417 	ldw	r2,-48(fp)
81136828:	e0bff915 	stw	r2,-28(fp)
8113682c:	e0bff917 	ldw	r2,-28(fp)
81136830:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
81136834:	00000906 	br	8113685c <OSFlagAccept+0x2fc>
81136838:	e0bff417 	ldw	r2,-48(fp)
8113683c:	e0bffa15 	stw	r2,-24(fp)
81136840:	e0bffa17 	ldw	r2,-24(fp)
81136844:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
81136848:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
8113684c:	e0bfff17 	ldw	r2,-4(fp)
81136850:	00c01bc4 	movi	r3,111
81136854:	10c00005 	stb	r3,0(r2)
             break;
81136858:	0001883a 	nop
    }
    return (flags_rdy);
8113685c:	e0bff30b 	ldhu	r2,-52(fp)
}
81136860:	e037883a 	mov	sp,fp
81136864:	df000017 	ldw	fp,0(sp)
81136868:	dec00104 	addi	sp,sp,4
8113686c:	f800283a 	ret

81136870 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
81136870:	defff804 	addi	sp,sp,-32
81136874:	de00012e 	bgeu	sp,et,8113687c <OSFlagCreate+0xc>
81136878:	003b68fa 	trap	3
8113687c:	df000715 	stw	fp,28(sp)
81136880:	df000704 	addi	fp,sp,28
81136884:	2005883a 	mov	r2,r4
81136888:	e17fff15 	stw	r5,-4(fp)
8113688c:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
81136890:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
81136894:	e0bfff17 	ldw	r2,-4(fp)
81136898:	1000021e 	bne	r2,zero,811368a4 <OSFlagCreate+0x34>
        return ((OS_FLAG_GRP *)0);
8113689c:	0005883a 	mov	r2,zero
811368a0:	00003306 	br	81136970 <OSFlagCreate+0x100>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
811368a4:	d0a09d03 	ldbu	r2,-32140(gp)
811368a8:	10803fcc 	andi	r2,r2,255
811368ac:	10000526 	beq	r2,zero,811368c4 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
811368b0:	e0bfff17 	ldw	r2,-4(fp)
811368b4:	00c00404 	movi	r3,16
811368b8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
811368bc:	0005883a 	mov	r2,zero
811368c0:	00002b06 	br	81136970 <OSFlagCreate+0x100>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811368c4:	0005303a 	rdctl	r2,status
811368c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811368cc:	e0fffd17 	ldw	r3,-12(fp)
811368d0:	00bfff84 	movi	r2,-2
811368d4:	1884703a 	and	r2,r3,r2
811368d8:	1001703a 	wrctl	status,r2
  
  return context;
811368dc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811368e0:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
811368e4:	d0a0a217 	ldw	r2,-32120(gp)
811368e8:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
811368ec:	e0bffb17 	ldw	r2,-20(fp)
811368f0:	10001726 	beq	r2,zero,81136950 <OSFlagCreate+0xe0>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
811368f4:	d0a0a217 	ldw	r2,-32120(gp)
811368f8:	10800117 	ldw	r2,4(r2)
811368fc:	d0a0a215 	stw	r2,-32120(gp)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
81136900:	e0bffb17 	ldw	r2,-20(fp)
81136904:	00c00144 	movi	r3,5
81136908:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
8113690c:	e0bffb17 	ldw	r2,-20(fp)
81136910:	e0fffe0b 	ldhu	r3,-8(fp)
81136914:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
81136918:	e0bffb17 	ldw	r2,-20(fp)
8113691c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
81136920:	e0bffb17 	ldw	r2,-20(fp)
81136924:	00c00fc4 	movi	r3,63
81136928:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
8113692c:	e0bffb17 	ldw	r2,-20(fp)
81136930:	100002c5 	stb	zero,11(r2)
81136934:	e0bff917 	ldw	r2,-28(fp)
81136938:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113693c:	e0bffa17 	ldw	r2,-24(fp)
81136940:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
81136944:	e0bfff17 	ldw	r2,-4(fp)
81136948:	10000005 	stb	zero,0(r2)
8113694c:	00000706 	br	8113696c <OSFlagCreate+0xfc>
81136950:	e0bff917 	ldw	r2,-28(fp)
81136954:	e0bffc15 	stw	r2,-16(fp)
81136958:	e0bffc17 	ldw	r2,-16(fp)
8113695c:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
81136960:	e0bfff17 	ldw	r2,-4(fp)
81136964:	00c01c84 	movi	r3,114
81136968:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
8113696c:	e0bffb17 	ldw	r2,-20(fp)
}
81136970:	e037883a 	mov	sp,fp
81136974:	df000017 	ldw	fp,0(sp)
81136978:	dec00104 	addi	sp,sp,4
8113697c:	f800283a 	ret

81136980 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
81136980:	defff204 	addi	sp,sp,-56
81136984:	de00012e 	bgeu	sp,et,8113698c <OSFlagDel+0xc>
81136988:	003b68fa 	trap	3
8113698c:	dfc00d15 	stw	ra,52(sp)
81136990:	df000c15 	stw	fp,48(sp)
81136994:	df000c04 	addi	fp,sp,48
81136998:	e13ffd15 	stw	r4,-12(fp)
8113699c:	2805883a 	mov	r2,r5
811369a0:	e1bfff15 	stw	r6,-4(fp)
811369a4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
811369a8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811369ac:	e0bfff17 	ldw	r2,-4(fp)
811369b0:	1000021e 	bne	r2,zero,811369bc <OSFlagDel+0x3c>
        return (pgrp);
811369b4:	e0bffd17 	ldw	r2,-12(fp)
811369b8:	00008006 	br	81136bbc <OSFlagDel+0x23c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
811369bc:	e0bffd17 	ldw	r2,-12(fp)
811369c0:	1000051e 	bne	r2,zero,811369d8 <OSFlagDel+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811369c4:	e0bfff17 	ldw	r2,-4(fp)
811369c8:	00c01b84 	movi	r3,110
811369cc:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811369d0:	e0bffd17 	ldw	r2,-12(fp)
811369d4:	00007906 	br	81136bbc <OSFlagDel+0x23c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811369d8:	d0a09d03 	ldbu	r2,-32140(gp)
811369dc:	10803fcc 	andi	r2,r2,255
811369e0:	10000526 	beq	r2,zero,811369f8 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
811369e4:	e0bfff17 	ldw	r2,-4(fp)
811369e8:	00c003c4 	movi	r3,15
811369ec:	10c00005 	stb	r3,0(r2)
        return (pgrp);
811369f0:	e0bffd17 	ldw	r2,-12(fp)
811369f4:	00007106 	br	81136bbc <OSFlagDel+0x23c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
811369f8:	e0bffd17 	ldw	r2,-12(fp)
811369fc:	10800003 	ldbu	r2,0(r2)
81136a00:	10803fcc 	andi	r2,r2,255
81136a04:	10800160 	cmpeqi	r2,r2,5
81136a08:	1000051e 	bne	r2,zero,81136a20 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
81136a0c:	e0bfff17 	ldw	r2,-4(fp)
81136a10:	00c00044 	movi	r3,1
81136a14:	10c00005 	stb	r3,0(r2)
        return (pgrp);
81136a18:	e0bffd17 	ldw	r2,-12(fp)
81136a1c:	00006706 	br	81136bbc <OSFlagDel+0x23c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136a20:	0005303a 	rdctl	r2,status
81136a24:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136a28:	e0fffc17 	ldw	r3,-16(fp)
81136a2c:	00bfff84 	movi	r2,-2
81136a30:	1884703a 	and	r2,r3,r2
81136a34:	1001703a 	wrctl	status,r2
  
  return context;
81136a38:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136a3c:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
81136a40:	e0bffd17 	ldw	r2,-12(fp)
81136a44:	10800117 	ldw	r2,4(r2)
81136a48:	10000326 	beq	r2,zero,81136a58 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81136a4c:	00800044 	movi	r2,1
81136a50:	e0bff405 	stb	r2,-48(fp)
81136a54:	00000106 	br	81136a5c <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81136a58:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81136a5c:	e0bffe03 	ldbu	r2,-8(fp)
81136a60:	10000326 	beq	r2,zero,81136a70 <OSFlagDel+0xf0>
81136a64:	10800060 	cmpeqi	r2,r2,1
81136a68:	1000231e 	bne	r2,zero,81136af8 <OSFlagDel+0x178>
81136a6c:	00004806 	br	81136b90 <OSFlagDel+0x210>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
81136a70:	e0bff403 	ldbu	r2,-48(fp)
81136a74:	1000161e 	bne	r2,zero,81136ad0 <OSFlagDel+0x150>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
81136a78:	e0bffd17 	ldw	r2,-12(fp)
81136a7c:	00c00fc4 	movi	r3,63
81136a80:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81136a84:	e0bffd17 	ldw	r2,-12(fp)
81136a88:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136a8c:	e0bffd17 	ldw	r2,-12(fp)
81136a90:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
81136a94:	d0e0a217 	ldw	r3,-32120(gp)
81136a98:	e0bffd17 	ldw	r2,-12(fp)
81136a9c:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
81136aa0:	e0bffd17 	ldw	r2,-12(fp)
81136aa4:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
81136aa8:	e0bffd17 	ldw	r2,-12(fp)
81136aac:	d0a0a215 	stw	r2,-32120(gp)
81136ab0:	e0bff717 	ldw	r2,-36(fp)
81136ab4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136ab8:	e0bff817 	ldw	r2,-32(fp)
81136abc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
81136ac0:	e0bfff17 	ldw	r2,-4(fp)
81136ac4:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
81136ac8:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
81136acc:	00003a06 	br	81136bb8 <OSFlagDel+0x238>
81136ad0:	e0bff717 	ldw	r2,-36(fp)
81136ad4:	e0bff915 	stw	r2,-28(fp)
81136ad8:	e0bff917 	ldw	r2,-28(fp)
81136adc:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
81136ae0:	e0bfff17 	ldw	r2,-4(fp)
81136ae4:	00c01244 	movi	r3,73
81136ae8:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
81136aec:	e0bffd17 	ldw	r2,-12(fp)
81136af0:	e0bff615 	stw	r2,-40(fp)
             }
             break;
81136af4:	00003006 	br	81136bb8 <OSFlagDel+0x238>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81136af8:	e0bffd17 	ldw	r2,-12(fp)
81136afc:	10800117 	ldw	r2,4(r2)
81136b00:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81136b04:	00000606 	br	81136b20 <OSFlagDel+0x1a0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
81136b08:	000b883a 	mov	r5,zero
81136b0c:	e13ff517 	ldw	r4,-44(fp)
81136b10:	1137b340 	call	81137b34 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81136b14:	e0bff517 	ldw	r2,-44(fp)
81136b18:	10800017 	ldw	r2,0(r2)
81136b1c:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
81136b20:	e0bff517 	ldw	r2,-44(fp)
81136b24:	103ff81e 	bne	r2,zero,81136b08 <__reset+0xfb116b08>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
81136b28:	e0bffd17 	ldw	r2,-12(fp)
81136b2c:	00c00fc4 	movi	r3,63
81136b30:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
81136b34:	e0bffd17 	ldw	r2,-12(fp)
81136b38:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81136b3c:	e0bffd17 	ldw	r2,-12(fp)
81136b40:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
81136b44:	d0e0a217 	ldw	r3,-32120(gp)
81136b48:	e0bffd17 	ldw	r2,-12(fp)
81136b4c:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
81136b50:	e0bffd17 	ldw	r2,-12(fp)
81136b54:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
81136b58:	e0bffd17 	ldw	r2,-12(fp)
81136b5c:	d0a0a215 	stw	r2,-32120(gp)
81136b60:	e0bff717 	ldw	r2,-36(fp)
81136b64:	e0bffa15 	stw	r2,-24(fp)
81136b68:	e0bffa17 	ldw	r2,-24(fp)
81136b6c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81136b70:	e0bff403 	ldbu	r2,-48(fp)
81136b74:	10800058 	cmpnei	r2,r2,1
81136b78:	1000011e 	bne	r2,zero,81136b80 <OSFlagDel+0x200>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81136b7c:	1135c440 	call	81135c44 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
81136b80:	e0bfff17 	ldw	r2,-4(fp)
81136b84:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
81136b88:	e03ff615 	stw	zero,-40(fp)
             break;
81136b8c:	00000a06 	br	81136bb8 <OSFlagDel+0x238>
81136b90:	e0bff717 	ldw	r2,-36(fp)
81136b94:	e0bffb15 	stw	r2,-20(fp)
81136b98:	e0bffb17 	ldw	r2,-20(fp)
81136b9c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
81136ba0:	e0bfff17 	ldw	r2,-4(fp)
81136ba4:	00c001c4 	movi	r3,7
81136ba8:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
81136bac:	e0bffd17 	ldw	r2,-12(fp)
81136bb0:	e0bff615 	stw	r2,-40(fp)
             break;
81136bb4:	0001883a 	nop
    }
    return (pgrp_return);
81136bb8:	e0bff617 	ldw	r2,-40(fp)
}
81136bbc:	e037883a 	mov	sp,fp
81136bc0:	dfc00117 	ldw	ra,4(sp)
81136bc4:	df000017 	ldw	fp,0(sp)
81136bc8:	dec00204 	addi	sp,sp,8
81136bcc:	f800283a 	ret

81136bd0 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81136bd0:	defff604 	addi	sp,sp,-40
81136bd4:	de00012e 	bgeu	sp,et,81136bdc <OSFlagNameGet+0xc>
81136bd8:	003b68fa 	trap	3
81136bdc:	dfc00915 	stw	ra,36(sp)
81136be0:	df000815 	stw	fp,32(sp)
81136be4:	df000804 	addi	fp,sp,32
81136be8:	e13ffd15 	stw	r4,-12(fp)
81136bec:	e17ffe15 	stw	r5,-8(fp)
81136bf0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136bf4:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81136bf8:	e0bfff17 	ldw	r2,-4(fp)
81136bfc:	1000021e 	bne	r2,zero,81136c08 <OSFlagNameGet+0x38>
        return (0);
81136c00:	0005883a 	mov	r2,zero
81136c04:	00003906 	br	81136cec <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81136c08:	e0bffd17 	ldw	r2,-12(fp)
81136c0c:	1000051e 	bne	r2,zero,81136c24 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81136c10:	e0bfff17 	ldw	r2,-4(fp)
81136c14:	00c01b84 	movi	r3,110
81136c18:	10c00005 	stb	r3,0(r2)
        return (0);
81136c1c:	0005883a 	mov	r2,zero
81136c20:	00003206 	br	81136cec <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136c24:	e0bffe17 	ldw	r2,-8(fp)
81136c28:	1000051e 	bne	r2,zero,81136c40 <OSFlagNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
81136c2c:	e0bfff17 	ldw	r2,-4(fp)
81136c30:	00c00304 	movi	r3,12
81136c34:	10c00005 	stb	r3,0(r2)
        return (0);
81136c38:	0005883a 	mov	r2,zero
81136c3c:	00002b06 	br	81136cec <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136c40:	d0a09d03 	ldbu	r2,-32140(gp)
81136c44:	10803fcc 	andi	r2,r2,255
81136c48:	10000526 	beq	r2,zero,81136c60 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
81136c4c:	e0bfff17 	ldw	r2,-4(fp)
81136c50:	00c00444 	movi	r3,17
81136c54:	10c00005 	stb	r3,0(r2)
        return (0);
81136c58:	0005883a 	mov	r2,zero
81136c5c:	00002306 	br	81136cec <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136c60:	0005303a 	rdctl	r2,status
81136c64:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136c68:	e0fffc17 	ldw	r3,-16(fp)
81136c6c:	00bfff84 	movi	r2,-2
81136c70:	1884703a 	and	r2,r3,r2
81136c74:	1001703a 	wrctl	status,r2
  
  return context;
81136c78:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136c7c:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81136c80:	e0bffd17 	ldw	r2,-12(fp)
81136c84:	10800003 	ldbu	r2,0(r2)
81136c88:	10803fcc 	andi	r2,r2,255
81136c8c:	10800160 	cmpeqi	r2,r2,5
81136c90:	1000091e 	bne	r2,zero,81136cb8 <OSFlagNameGet+0xe8>
81136c94:	e0bff817 	ldw	r2,-32(fp)
81136c98:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136c9c:	e0bff917 	ldw	r2,-28(fp)
81136ca0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81136ca4:	e0bfff17 	ldw	r2,-4(fp)
81136ca8:	00c00044 	movi	r3,1
81136cac:	10c00005 	stb	r3,0(r2)
        return (0);
81136cb0:	0005883a 	mov	r2,zero
81136cb4:	00000d06 	br	81136cec <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
81136cb8:	e0bffd17 	ldw	r2,-12(fp)
81136cbc:	10800284 	addi	r2,r2,10
81136cc0:	100b883a 	mov	r5,r2
81136cc4:	e13ffe17 	ldw	r4,-8(fp)
81136cc8:	1135d980 	call	81135d98 <OS_StrCopy>
81136ccc:	e0bffb05 	stb	r2,-20(fp)
81136cd0:	e0bff817 	ldw	r2,-32(fp)
81136cd4:	e0bffa15 	stw	r2,-24(fp)
81136cd8:	e0bffa17 	ldw	r2,-24(fp)
81136cdc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136ce0:	e0bfff17 	ldw	r2,-4(fp)
81136ce4:	10000005 	stb	zero,0(r2)
    return (len);
81136ce8:	e0bffb03 	ldbu	r2,-20(fp)
}
81136cec:	e037883a 	mov	sp,fp
81136cf0:	dfc00117 	ldw	ra,4(sp)
81136cf4:	df000017 	ldw	fp,0(sp)
81136cf8:	dec00204 	addi	sp,sp,8
81136cfc:	f800283a 	ret

81136d00 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
81136d00:	defff504 	addi	sp,sp,-44
81136d04:	de00012e 	bgeu	sp,et,81136d0c <OSFlagNameSet+0xc>
81136d08:	003b68fa 	trap	3
81136d0c:	dfc00a15 	stw	ra,40(sp)
81136d10:	df000915 	stw	fp,36(sp)
81136d14:	df000904 	addi	fp,sp,36
81136d18:	e13ffd15 	stw	r4,-12(fp)
81136d1c:	e17ffe15 	stw	r5,-8(fp)
81136d20:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81136d24:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81136d28:	e0bfff17 	ldw	r2,-4(fp)
81136d2c:	10004326 	beq	r2,zero,81136e3c <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
81136d30:	e0bffd17 	ldw	r2,-12(fp)
81136d34:	1000041e 	bne	r2,zero,81136d48 <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81136d38:	e0bfff17 	ldw	r2,-4(fp)
81136d3c:	00c01b84 	movi	r3,110
81136d40:	10c00005 	stb	r3,0(r2)
        return;
81136d44:	00003e06 	br	81136e40 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81136d48:	e0bffe17 	ldw	r2,-8(fp)
81136d4c:	1000041e 	bne	r2,zero,81136d60 <OSFlagNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
81136d50:	e0bfff17 	ldw	r2,-4(fp)
81136d54:	00c00304 	movi	r3,12
81136d58:	10c00005 	stb	r3,0(r2)
        return;
81136d5c:	00003806 	br	81136e40 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81136d60:	d0a09d03 	ldbu	r2,-32140(gp)
81136d64:	10803fcc 	andi	r2,r2,255
81136d68:	10000426 	beq	r2,zero,81136d7c <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81136d6c:	e0bfff17 	ldw	r2,-4(fp)
81136d70:	00c00484 	movi	r3,18
81136d74:	10c00005 	stb	r3,0(r2)
        return;
81136d78:	00003106 	br	81136e40 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136d7c:	0005303a 	rdctl	r2,status
81136d80:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136d84:	e0fffc17 	ldw	r3,-16(fp)
81136d88:	00bfff84 	movi	r2,-2
81136d8c:	1884703a 	and	r2,r3,r2
81136d90:	1001703a 	wrctl	status,r2
  
  return context;
81136d94:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81136d98:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
81136d9c:	e0bffd17 	ldw	r2,-12(fp)
81136da0:	10800003 	ldbu	r2,0(r2)
81136da4:	10803fcc 	andi	r2,r2,255
81136da8:	10800160 	cmpeqi	r2,r2,5
81136dac:	1000081e 	bne	r2,zero,81136dd0 <OSFlagNameSet+0xd0>
81136db0:	e0bff717 	ldw	r2,-36(fp)
81136db4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81136db8:	e0bff817 	ldw	r2,-32(fp)
81136dbc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
81136dc0:	e0bfff17 	ldw	r2,-4(fp)
81136dc4:	00c00044 	movi	r3,1
81136dc8:	10c00005 	stb	r3,0(r2)
        return;
81136dcc:	00001c06 	br	81136e40 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81136dd0:	e13ffe17 	ldw	r4,-8(fp)
81136dd4:	1135e140 	call	81135e14 <OS_StrLen>
81136dd8:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
81136ddc:	e0bffa03 	ldbu	r2,-24(fp)
81136de0:	10800830 	cmpltui	r2,r2,32
81136de4:	1000081e 	bne	r2,zero,81136e08 <OSFlagNameSet+0x108>
81136de8:	e0bff717 	ldw	r2,-36(fp)
81136dec:	e0bff915 	stw	r2,-28(fp)
81136df0:	e0bff917 	ldw	r2,-28(fp)
81136df4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
81136df8:	e0bfff17 	ldw	r2,-4(fp)
81136dfc:	00c01cc4 	movi	r3,115
81136e00:	10c00005 	stb	r3,0(r2)
        return;
81136e04:	00000e06 	br	81136e40 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
81136e08:	e0bffd17 	ldw	r2,-12(fp)
81136e0c:	10800284 	addi	r2,r2,10
81136e10:	e17ffe17 	ldw	r5,-8(fp)
81136e14:	1009883a 	mov	r4,r2
81136e18:	1135d980 	call	81135d98 <OS_StrCopy>
81136e1c:	e0bff717 	ldw	r2,-36(fp)
81136e20:	e0bffb15 	stw	r2,-20(fp)
81136e24:	e0bffb17 	ldw	r2,-20(fp)
81136e28:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81136e2c:	e0bfff17 	ldw	r2,-4(fp)
81136e30:	10000005 	stb	zero,0(r2)
    return;
81136e34:	0001883a 	nop
81136e38:	00000106 	br	81136e40 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
81136e3c:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
81136e40:	e037883a 	mov	sp,fp
81136e44:	dfc00117 	ldw	ra,4(sp)
81136e48:	df000017 	ldw	fp,0(sp)
81136e4c:	dec00204 	addi	sp,sp,8
81136e50:	f800283a 	ret

81136e54 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
81136e54:	deffe104 	addi	sp,sp,-124
81136e58:	de00012e 	bgeu	sp,et,81136e60 <OSFlagPend+0xc>
81136e5c:	003b68fa 	trap	3
81136e60:	dfc01e15 	stw	ra,120(sp)
81136e64:	df001d15 	stw	fp,116(sp)
81136e68:	df001d04 	addi	fp,sp,116
81136e6c:	e13ffc15 	stw	r4,-16(fp)
81136e70:	2809883a 	mov	r4,r5
81136e74:	3007883a 	mov	r3,r6
81136e78:	3805883a 	mov	r2,r7
81136e7c:	e13ffd0d 	sth	r4,-12(fp)
81136e80:	e0fffe05 	stb	r3,-8(fp)
81136e84:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81136e88:	e03fe515 	stw	zero,-108(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81136e8c:	e0800217 	ldw	r2,8(fp)
81136e90:	1000021e 	bne	r2,zero,81136e9c <OSFlagPend+0x48>
        return ((OS_FLAGS)0);
81136e94:	0005883a 	mov	r2,zero
81136e98:	00015906 	br	81137400 <OSFlagPend+0x5ac>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
81136e9c:	e0bffc17 	ldw	r2,-16(fp)
81136ea0:	1000051e 	bne	r2,zero,81136eb8 <OSFlagPend+0x64>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81136ea4:	e0800217 	ldw	r2,8(fp)
81136ea8:	00c01b84 	movi	r3,110
81136eac:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136eb0:	0005883a 	mov	r2,zero
81136eb4:	00015206 	br	81137400 <OSFlagPend+0x5ac>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81136eb8:	d0a09d03 	ldbu	r2,-32140(gp)
81136ebc:	10803fcc 	andi	r2,r2,255
81136ec0:	10000526 	beq	r2,zero,81136ed8 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81136ec4:	e0800217 	ldw	r2,8(fp)
81136ec8:	00c00084 	movi	r3,2
81136ecc:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136ed0:	0005883a 	mov	r2,zero
81136ed4:	00014a06 	br	81137400 <OSFlagPend+0x5ac>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81136ed8:	d0a08b03 	ldbu	r2,-32212(gp)
81136edc:	10803fcc 	andi	r2,r2,255
81136ee0:	10000526 	beq	r2,zero,81136ef8 <OSFlagPend+0xa4>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81136ee4:	e0800217 	ldw	r2,8(fp)
81136ee8:	00c00344 	movi	r3,13
81136eec:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136ef0:	0005883a 	mov	r2,zero
81136ef4:	00014206 	br	81137400 <OSFlagPend+0x5ac>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
81136ef8:	e0bffc17 	ldw	r2,-16(fp)
81136efc:	10800003 	ldbu	r2,0(r2)
81136f00:	10803fcc 	andi	r2,r2,255
81136f04:	10800160 	cmpeqi	r2,r2,5
81136f08:	1000051e 	bne	r2,zero,81136f20 <OSFlagPend+0xcc>
        *perr = OS_ERR_EVENT_TYPE;
81136f0c:	e0800217 	ldw	r2,8(fp)
81136f10:	00c00044 	movi	r3,1
81136f14:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81136f18:	0005883a 	mov	r2,zero
81136f1c:	00013806 	br	81137400 <OSFlagPend+0x5ac>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
81136f20:	e0fffe03 	ldbu	r3,-8(fp)
81136f24:	00bfe004 	movi	r2,-128
81136f28:	1884703a 	and	r2,r3,r2
81136f2c:	e0bfe605 	stb	r2,-104(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
81136f30:	e0bfe603 	ldbu	r2,-104(fp)
81136f34:	10000626 	beq	r2,zero,81136f50 <OSFlagPend+0xfc>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
81136f38:	e0bffe03 	ldbu	r2,-8(fp)
81136f3c:	10801fcc 	andi	r2,r2,127
81136f40:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
81136f44:	00800044 	movi	r2,1
81136f48:	e0bfe405 	stb	r2,-112(fp)
81136f4c:	00000106 	br	81136f54 <OSFlagPend+0x100>
    } else {
        consume    = OS_FALSE;
81136f50:	e03fe405 	stb	zero,-112(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81136f54:	0005303a 	rdctl	r2,status
81136f58:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81136f5c:	e0fff617 	ldw	r3,-40(fp)
81136f60:	00bfff84 	movi	r2,-2
81136f64:	1884703a 	and	r2,r3,r2
81136f68:	1001703a 	wrctl	status,r2
  
  return context;
81136f6c:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81136f70:	e0bfe515 	stw	r2,-108(fp)
    switch (wait_type) {
81136f74:	e0bffe03 	ldbu	r2,-8(fp)
81136f78:	10c00060 	cmpeqi	r3,r2,1
81136f7c:	1800921e 	bne	r3,zero,811371c8 <OSFlagPend+0x374>
81136f80:	10c00088 	cmpgei	r3,r2,2
81136f84:	1800021e 	bne	r3,zero,81136f90 <OSFlagPend+0x13c>
81136f88:	10006126 	beq	r2,zero,81137110 <OSFlagPend+0x2bc>
81136f8c:	0000bb06 	br	8113727c <OSFlagPend+0x428>
81136f90:	10c000a0 	cmpeqi	r3,r2,2
81136f94:	1800031e 	bne	r3,zero,81136fa4 <OSFlagPend+0x150>
81136f98:	108000e0 	cmpeqi	r2,r2,3
81136f9c:	10002f1e 	bne	r2,zero,8113705c <OSFlagPend+0x208>
81136fa0:	0000b606 	br	8113727c <OSFlagPend+0x428>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
81136fa4:	e0bffc17 	ldw	r2,-16(fp)
81136fa8:	10c0020b 	ldhu	r3,8(r2)
81136fac:	e0bffd0b 	ldhu	r2,-12(fp)
81136fb0:	1884703a 	and	r2,r3,r2
81136fb4:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
81136fb8:	e0ffe80b 	ldhu	r3,-96(fp)
81136fbc:	e0bffd0b 	ldhu	r2,-12(fp)
81136fc0:	1880171e 	bne	r3,r2,81137020 <OSFlagPend+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81136fc4:	e0bfe403 	ldbu	r2,-112(fp)
81136fc8:	10800058 	cmpnei	r2,r2,1
81136fcc:	1000091e 	bne	r2,zero,81136ff4 <OSFlagPend+0x1a0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
81136fd0:	e0bffc17 	ldw	r2,-16(fp)
81136fd4:	1080020b 	ldhu	r2,8(r2)
81136fd8:	1007883a 	mov	r3,r2
81136fdc:	e0bfe80b 	ldhu	r2,-96(fp)
81136fe0:	0084303a 	nor	r2,zero,r2
81136fe4:	1884703a 	and	r2,r3,r2
81136fe8:	1007883a 	mov	r3,r2
81136fec:	e0bffc17 	ldw	r2,-16(fp)
81136ff0:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81136ff4:	d0a09e17 	ldw	r2,-32136(gp)
81136ff8:	e0ffe80b 	ldhu	r3,-96(fp)
81136ffc:	10c00b0d 	sth	r3,44(r2)
81137000:	e0bfe517 	ldw	r2,-108(fp)
81137004:	e0bfe715 	stw	r2,-100(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137008:	e0bfe717 	ldw	r2,-100(fp)
8113700c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81137010:	e0800217 	ldw	r2,8(fp)
81137014:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137018:	e0bfe80b 	ldhu	r2,-96(fp)
8113701c:	0000f806 	br	81137400 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81137020:	e13ffd0b 	ldhu	r4,-12(fp)
81137024:	e17ffe03 	ldbu	r5,-8(fp)
81137028:	e0bfff0b 	ldhu	r2,-4(fp)
8113702c:	e0fff704 	addi	r3,fp,-36
81137030:	d8800015 	stw	r2,0(sp)
81137034:	280f883a 	mov	r7,r5
81137038:	200d883a 	mov	r6,r4
8113703c:	180b883a 	mov	r5,r3
81137040:	e13ffc17 	ldw	r4,-16(fp)
81137044:	11378e40 	call	811378e4 <OS_FlagBlock>
81137048:	e0bfe517 	ldw	r2,-108(fp)
8113704c:	e0bfe915 	stw	r2,-92(fp)
81137050:	e0bfe917 	ldw	r2,-92(fp)
81137054:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81137058:	00009206 	br	811372a4 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
8113705c:	e0bffc17 	ldw	r2,-16(fp)
81137060:	10c0020b 	ldhu	r3,8(r2)
81137064:	e0bffd0b 	ldhu	r2,-12(fp)
81137068:	1884703a 	and	r2,r3,r2
8113706c:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
81137070:	e0bfe80b 	ldhu	r2,-96(fp)
81137074:	10001726 	beq	r2,zero,811370d4 <OSFlagPend+0x280>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137078:	e0bfe403 	ldbu	r2,-112(fp)
8113707c:	10800058 	cmpnei	r2,r2,1
81137080:	1000091e 	bne	r2,zero,811370a8 <OSFlagPend+0x254>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
81137084:	e0bffc17 	ldw	r2,-16(fp)
81137088:	1080020b 	ldhu	r2,8(r2)
8113708c:	1007883a 	mov	r3,r2
81137090:	e0bfe80b 	ldhu	r2,-96(fp)
81137094:	0084303a 	nor	r2,zero,r2
81137098:	1884703a 	and	r2,r3,r2
8113709c:	1007883a 	mov	r3,r2
811370a0:	e0bffc17 	ldw	r2,-16(fp)
811370a4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
811370a8:	d0a09e17 	ldw	r2,-32136(gp)
811370ac:	e0ffe80b 	ldhu	r3,-96(fp)
811370b0:	10c00b0d 	sth	r3,44(r2)
811370b4:	e0bfe517 	ldw	r2,-108(fp)
811370b8:	e0bfea15 	stw	r2,-88(fp)
811370bc:	e0bfea17 	ldw	r2,-88(fp)
811370c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
811370c4:	e0800217 	ldw	r2,8(fp)
811370c8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
811370cc:	e0bfe80b 	ldhu	r2,-96(fp)
811370d0:	0000cb06 	br	81137400 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
811370d4:	e13ffd0b 	ldhu	r4,-12(fp)
811370d8:	e17ffe03 	ldbu	r5,-8(fp)
811370dc:	e0bfff0b 	ldhu	r2,-4(fp)
811370e0:	e0fff704 	addi	r3,fp,-36
811370e4:	d8800015 	stw	r2,0(sp)
811370e8:	280f883a 	mov	r7,r5
811370ec:	200d883a 	mov	r6,r4
811370f0:	180b883a 	mov	r5,r3
811370f4:	e13ffc17 	ldw	r4,-16(fp)
811370f8:	11378e40 	call	811378e4 <OS_FlagBlock>
811370fc:	e0bfe517 	ldw	r2,-108(fp)
81137100:	e0bfeb15 	stw	r2,-84(fp)
81137104:	e0bfeb17 	ldw	r2,-84(fp)
81137108:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
8113710c:	00006506 	br	811372a4 <OSFlagPend+0x450>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
81137110:	e0bffc17 	ldw	r2,-16(fp)
81137114:	1080020b 	ldhu	r2,8(r2)
81137118:	0084303a 	nor	r2,zero,r2
8113711c:	1007883a 	mov	r3,r2
81137120:	e0bffd0b 	ldhu	r2,-12(fp)
81137124:	1884703a 	and	r2,r3,r2
81137128:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
8113712c:	e0ffe80b 	ldhu	r3,-96(fp)
81137130:	e0bffd0b 	ldhu	r2,-12(fp)
81137134:	1880151e 	bne	r3,r2,8113718c <OSFlagPend+0x338>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
81137138:	e0bfe403 	ldbu	r2,-112(fp)
8113713c:	10800058 	cmpnei	r2,r2,1
81137140:	1000071e 	bne	r2,zero,81137160 <OSFlagPend+0x30c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
81137144:	e0bffc17 	ldw	r2,-16(fp)
81137148:	10c0020b 	ldhu	r3,8(r2)
8113714c:	e0bfe80b 	ldhu	r2,-96(fp)
81137150:	1884b03a 	or	r2,r3,r2
81137154:	1007883a 	mov	r3,r2
81137158:	e0bffc17 	ldw	r2,-16(fp)
8113715c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81137160:	d0a09e17 	ldw	r2,-32136(gp)
81137164:	e0ffe80b 	ldhu	r3,-96(fp)
81137168:	10c00b0d 	sth	r3,44(r2)
8113716c:	e0bfe517 	ldw	r2,-108(fp)
81137170:	e0bfec15 	stw	r2,-80(fp)
81137174:	e0bfec17 	ldw	r2,-80(fp)
81137178:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
8113717c:	e0800217 	ldw	r2,8(fp)
81137180:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137184:	e0bfe80b 	ldhu	r2,-96(fp)
81137188:	00009d06 	br	81137400 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
8113718c:	e13ffd0b 	ldhu	r4,-12(fp)
81137190:	e17ffe03 	ldbu	r5,-8(fp)
81137194:	e0bfff0b 	ldhu	r2,-4(fp)
81137198:	e0fff704 	addi	r3,fp,-36
8113719c:	d8800015 	stw	r2,0(sp)
811371a0:	280f883a 	mov	r7,r5
811371a4:	200d883a 	mov	r6,r4
811371a8:	180b883a 	mov	r5,r3
811371ac:	e13ffc17 	ldw	r4,-16(fp)
811371b0:	11378e40 	call	811378e4 <OS_FlagBlock>
811371b4:	e0bfe517 	ldw	r2,-108(fp)
811371b8:	e0bfed15 	stw	r2,-76(fp)
811371bc:	e0bfed17 	ldw	r2,-76(fp)
811371c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
811371c4:	00003706 	br	811372a4 <OSFlagPend+0x450>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
811371c8:	e0bffc17 	ldw	r2,-16(fp)
811371cc:	1080020b 	ldhu	r2,8(r2)
811371d0:	0084303a 	nor	r2,zero,r2
811371d4:	1007883a 	mov	r3,r2
811371d8:	e0bffd0b 	ldhu	r2,-12(fp)
811371dc:	1884703a 	and	r2,r3,r2
811371e0:	e0bfe80d 	sth	r2,-96(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
811371e4:	e0bfe80b 	ldhu	r2,-96(fp)
811371e8:	10001526 	beq	r2,zero,81137240 <OSFlagPend+0x3ec>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
811371ec:	e0bfe403 	ldbu	r2,-112(fp)
811371f0:	10800058 	cmpnei	r2,r2,1
811371f4:	1000071e 	bne	r2,zero,81137214 <OSFlagPend+0x3c0>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
811371f8:	e0bffc17 	ldw	r2,-16(fp)
811371fc:	10c0020b 	ldhu	r3,8(r2)
81137200:	e0bfe80b 	ldhu	r2,-96(fp)
81137204:	1884b03a 	or	r2,r3,r2
81137208:	1007883a 	mov	r3,r2
8113720c:	e0bffc17 	ldw	r2,-16(fp)
81137210:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
81137214:	d0a09e17 	ldw	r2,-32136(gp)
81137218:	e0ffe80b 	ldhu	r3,-96(fp)
8113721c:	10c00b0d 	sth	r3,44(r2)
81137220:	e0bfe517 	ldw	r2,-108(fp)
81137224:	e0bfee15 	stw	r2,-72(fp)
81137228:	e0bfee17 	ldw	r2,-72(fp)
8113722c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
81137230:	e0800217 	ldw	r2,8(fp)
81137234:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
81137238:	e0bfe80b 	ldhu	r2,-96(fp)
8113723c:	00007006 	br	81137400 <OSFlagPend+0x5ac>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
81137240:	e13ffd0b 	ldhu	r4,-12(fp)
81137244:	e17ffe03 	ldbu	r5,-8(fp)
81137248:	e0bfff0b 	ldhu	r2,-4(fp)
8113724c:	e0fff704 	addi	r3,fp,-36
81137250:	d8800015 	stw	r2,0(sp)
81137254:	280f883a 	mov	r7,r5
81137258:	200d883a 	mov	r6,r4
8113725c:	180b883a 	mov	r5,r3
81137260:	e13ffc17 	ldw	r4,-16(fp)
81137264:	11378e40 	call	811378e4 <OS_FlagBlock>
81137268:	e0bfe517 	ldw	r2,-108(fp)
8113726c:	e0bfef15 	stw	r2,-68(fp)
81137270:	e0bfef17 	ldw	r2,-68(fp)
81137274:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
81137278:	00000a06 	br	811372a4 <OSFlagPend+0x450>
8113727c:	e0bfe517 	ldw	r2,-108(fp)
81137280:	e0bff015 	stw	r2,-64(fp)
81137284:	e0bff017 	ldw	r2,-64(fp)
81137288:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
8113728c:	e03fe80d 	sth	zero,-96(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
81137290:	e0800217 	ldw	r2,8(fp)
81137294:	00c01bc4 	movi	r3,111
81137298:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
8113729c:	e0bfe80b 	ldhu	r2,-96(fp)
811372a0:	00005706 	br	81137400 <OSFlagPend+0x5ac>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
811372a4:	1135c440 	call	81135c44 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811372a8:	0005303a 	rdctl	r2,status
811372ac:	e0bff115 	stw	r2,-60(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811372b0:	e0fff117 	ldw	r3,-60(fp)
811372b4:	00bfff84 	movi	r2,-2
811372b8:	1884703a 	and	r2,r3,r2
811372bc:	1001703a 	wrctl	status,r2
  
  return context;
811372c0:	e0bff117 	ldw	r2,-60(fp)
    OS_ENTER_CRITICAL();
811372c4:	e0bfe515 	stw	r2,-108(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
811372c8:	d0a09e17 	ldw	r2,-32136(gp)
811372cc:	10800c43 	ldbu	r2,49(r2)
811372d0:	10803fcc 	andi	r2,r2,255
811372d4:	10001c26 	beq	r2,zero,81137348 <OSFlagPend+0x4f4>
        pend_stat                = OSTCBCur->OSTCBStatPend;
811372d8:	d0a09e17 	ldw	r2,-32136(gp)
811372dc:	10800c43 	ldbu	r2,49(r2)
811372e0:	e0bff305 	stb	r2,-52(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
811372e4:	d0a09e17 	ldw	r2,-32136(gp)
811372e8:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
811372ec:	e0bff704 	addi	r2,fp,-36
811372f0:	1009883a 	mov	r4,r2
811372f4:	1137c300 	call	81137c30 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
811372f8:	d0a09e17 	ldw	r2,-32136(gp)
811372fc:	10000c05 	stb	zero,48(r2)
81137300:	e0bfe517 	ldw	r2,-108(fp)
81137304:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137308:	e0bff217 	ldw	r2,-56(fp)
8113730c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
81137310:	e03fe80d 	sth	zero,-96(fp)
        switch (pend_stat) {
81137314:	e0bff303 	ldbu	r2,-52(fp)
81137318:	108000a0 	cmpeqi	r2,r2,2
8113731c:	10000426 	beq	r2,zero,81137330 <OSFlagPend+0x4dc>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
81137320:	e0800217 	ldw	r2,8(fp)
81137324:	00c00384 	movi	r3,14
81137328:	10c00005 	stb	r3,0(r2)
                 break;
8113732c:	00000406 	br	81137340 <OSFlagPend+0x4ec>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
81137330:	e0800217 	ldw	r2,8(fp)
81137334:	00c00284 	movi	r3,10
81137338:	10c00005 	stb	r3,0(r2)
                 break;
8113733c:	0001883a 	nop
        }
        return (flags_rdy);
81137340:	e0bfe80b 	ldhu	r2,-96(fp)
81137344:	00002e06 	br	81137400 <OSFlagPend+0x5ac>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
81137348:	d0a09e17 	ldw	r2,-32136(gp)
8113734c:	10800b0b 	ldhu	r2,44(r2)
81137350:	e0bfe80d 	sth	r2,-96(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
81137354:	e0bfe403 	ldbu	r2,-112(fp)
81137358:	10800058 	cmpnei	r2,r2,1
8113735c:	1000211e 	bne	r2,zero,811373e4 <OSFlagPend+0x590>
        switch (wait_type) {
81137360:	e0bffe03 	ldbu	r2,-8(fp)
81137364:	10001616 	blt	r2,zero,811373c0 <OSFlagPend+0x56c>
81137368:	10c00090 	cmplti	r3,r2,2
8113736c:	18000c1e 	bne	r3,zero,811373a0 <OSFlagPend+0x54c>
81137370:	10800108 	cmpgei	r2,r2,4
81137374:	1000121e 	bne	r2,zero,811373c0 <OSFlagPend+0x56c>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
81137378:	e0bffc17 	ldw	r2,-16(fp)
8113737c:	1080020b 	ldhu	r2,8(r2)
81137380:	1007883a 	mov	r3,r2
81137384:	e0bfe80b 	ldhu	r2,-96(fp)
81137388:	0084303a 	nor	r2,zero,r2
8113738c:	1884703a 	and	r2,r3,r2
81137390:	1007883a 	mov	r3,r2
81137394:	e0bffc17 	ldw	r2,-16(fp)
81137398:	10c0020d 	sth	r3,8(r2)
                 break;
8113739c:	00001106 	br	811373e4 <OSFlagPend+0x590>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
811373a0:	e0bffc17 	ldw	r2,-16(fp)
811373a4:	10c0020b 	ldhu	r3,8(r2)
811373a8:	e0bfe80b 	ldhu	r2,-96(fp)
811373ac:	1884b03a 	or	r2,r3,r2
811373b0:	1007883a 	mov	r3,r2
811373b4:	e0bffc17 	ldw	r2,-16(fp)
811373b8:	10c0020d 	sth	r3,8(r2)
                 break;
811373bc:	00000906 	br	811373e4 <OSFlagPend+0x590>
811373c0:	e0bfe517 	ldw	r2,-108(fp)
811373c4:	e0bff415 	stw	r2,-48(fp)
811373c8:	e0bff417 	ldw	r2,-48(fp)
811373cc:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
811373d0:	e0800217 	ldw	r2,8(fp)
811373d4:	00c01bc4 	movi	r3,111
811373d8:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
811373dc:	0005883a 	mov	r2,zero
811373e0:	00000706 	br	81137400 <OSFlagPend+0x5ac>
811373e4:	e0bfe517 	ldw	r2,-108(fp)
811373e8:	e0bff515 	stw	r2,-44(fp)
811373ec:	e0bff517 	ldw	r2,-44(fp)
811373f0:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
811373f4:	e0800217 	ldw	r2,8(fp)
811373f8:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
811373fc:	e0bfe80b 	ldhu	r2,-96(fp)
}
81137400:	e037883a 	mov	sp,fp
81137404:	dfc00117 	ldw	ra,4(sp)
81137408:	df000017 	ldw	fp,0(sp)
8113740c:	dec00204 	addi	sp,sp,8
81137410:	f800283a 	ret

81137414 <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
81137414:	defffb04 	addi	sp,sp,-20
81137418:	de00012e 	bgeu	sp,et,81137420 <OSFlagPendGetFlagsRdy+0xc>
8113741c:	003b68fa 	trap	3
81137420:	df000415 	stw	fp,16(sp)
81137424:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
81137428:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113742c:	0005303a 	rdctl	r2,status
81137430:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137434:	e0fffe17 	ldw	r3,-8(fp)
81137438:	00bfff84 	movi	r2,-2
8113743c:	1884703a 	and	r2,r3,r2
81137440:	1001703a 	wrctl	status,r2
  
  return context;
81137444:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
81137448:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
8113744c:	d0a09e17 	ldw	r2,-32136(gp)
81137450:	10800b0b 	ldhu	r2,44(r2)
81137454:	e0bffd0d 	sth	r2,-12(fp)
81137458:	e0bffc17 	ldw	r2,-16(fp)
8113745c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137460:	e0bfff17 	ldw	r2,-4(fp)
81137464:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
81137468:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113746c:	e037883a 	mov	sp,fp
81137470:	df000017 	ldw	fp,0(sp)
81137474:	dec00104 	addi	sp,sp,4
81137478:	f800283a 	ret

8113747c <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
8113747c:	deffef04 	addi	sp,sp,-68
81137480:	de00012e 	bgeu	sp,et,81137488 <OSFlagPost+0xc>
81137484:	003b68fa 	trap	3
81137488:	dfc01015 	stw	ra,64(sp)
8113748c:	df000f15 	stw	fp,60(sp)
81137490:	df000f04 	addi	fp,sp,60
81137494:	e13ffc15 	stw	r4,-16(fp)
81137498:	2807883a 	mov	r3,r5
8113749c:	3005883a 	mov	r2,r6
811374a0:	e1ffff15 	stw	r7,-4(fp)
811374a4:	e0fffd0d 	sth	r3,-12(fp)
811374a8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
811374ac:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
811374b0:	e0bfff17 	ldw	r2,-4(fp)
811374b4:	1000021e 	bne	r2,zero,811374c0 <OSFlagPost+0x44>
        return ((OS_FLAGS)0);
811374b8:	0005883a 	mov	r2,zero
811374bc:	0000d106 	br	81137804 <OSFlagPost+0x388>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
811374c0:	e0bffc17 	ldw	r2,-16(fp)
811374c4:	1000051e 	bne	r2,zero,811374dc <OSFlagPost+0x60>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
811374c8:	e0bfff17 	ldw	r2,-4(fp)
811374cc:	00c01b84 	movi	r3,110
811374d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811374d4:	0005883a 	mov	r2,zero
811374d8:	0000ca06 	br	81137804 <OSFlagPost+0x388>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
811374dc:	e0bffc17 	ldw	r2,-16(fp)
811374e0:	10800003 	ldbu	r2,0(r2)
811374e4:	10803fcc 	andi	r2,r2,255
811374e8:	10800160 	cmpeqi	r2,r2,5
811374ec:	1000051e 	bne	r2,zero,81137504 <OSFlagPost+0x88>
        *perr = OS_ERR_EVENT_TYPE;
811374f0:	e0bfff17 	ldw	r2,-4(fp)
811374f4:	00c00044 	movi	r3,1
811374f8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
811374fc:	0005883a 	mov	r2,zero
81137500:	0000c006 	br	81137804 <OSFlagPost+0x388>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137504:	0005303a 	rdctl	r2,status
81137508:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113750c:	e0fffb17 	ldw	r3,-20(fp)
81137510:	00bfff84 	movi	r2,-2
81137514:	1884703a 	and	r2,r3,r2
81137518:	1001703a 	wrctl	status,r2
  
  return context;
8113751c:	e0bffb17 	ldw	r2,-20(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81137520:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
81137524:	e0bffe03 	ldbu	r2,-8(fp)
81137528:	10000326 	beq	r2,zero,81137538 <OSFlagPost+0xbc>
8113752c:	10800060 	cmpeqi	r2,r2,1
81137530:	10000b1e 	bne	r2,zero,81137560 <OSFlagPost+0xe4>
81137534:	00001206 	br	81137580 <OSFlagPost+0x104>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
81137538:	e0bffc17 	ldw	r2,-16(fp)
8113753c:	1080020b 	ldhu	r2,8(r2)
81137540:	1007883a 	mov	r3,r2
81137544:	e0bffd0b 	ldhu	r2,-12(fp)
81137548:	0084303a 	nor	r2,zero,r2
8113754c:	1884703a 	and	r2,r3,r2
81137550:	1007883a 	mov	r3,r2
81137554:	e0bffc17 	ldw	r2,-16(fp)
81137558:	10c0020d 	sth	r3,8(r2)
             break;
8113755c:	00001106 	br	811375a4 <OSFlagPost+0x128>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
81137560:	e0bffc17 	ldw	r2,-16(fp)
81137564:	10c0020b 	ldhu	r3,8(r2)
81137568:	e0bffd0b 	ldhu	r2,-12(fp)
8113756c:	1884b03a 	or	r2,r3,r2
81137570:	1007883a 	mov	r3,r2
81137574:	e0bffc17 	ldw	r2,-16(fp)
81137578:	10c0020d 	sth	r3,8(r2)
             break;
8113757c:	00000906 	br	811375a4 <OSFlagPost+0x128>
81137580:	e0bff317 	ldw	r2,-52(fp)
81137584:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137588:	e0bff417 	ldw	r2,-48(fp)
8113758c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
81137590:	e0bfff17 	ldw	r2,-4(fp)
81137594:	00c01c44 	movi	r3,113
81137598:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
8113759c:	0005883a 	mov	r2,zero
811375a0:	00009806 	br	81137804 <OSFlagPost+0x388>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
811375a4:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
811375a8:	e0bffc17 	ldw	r2,-16(fp)
811375ac:	10800117 	ldw	r2,4(r2)
811375b0:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
811375b4:	00007706 	br	81137794 <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
811375b8:	e0bff117 	ldw	r2,-60(fp)
811375bc:	10800483 	ldbu	r2,18(r2)
811375c0:	10803fcc 	andi	r2,r2,255
811375c4:	10c00060 	cmpeqi	r3,r2,1
811375c8:	18004a1e 	bne	r3,zero,811376f4 <OSFlagPost+0x278>
811375cc:	10c00088 	cmpgei	r3,r2,2
811375d0:	1800021e 	bne	r3,zero,811375dc <OSFlagPost+0x160>
811375d4:	10002f26 	beq	r2,zero,81137694 <OSFlagPost+0x218>
811375d8:	00005b06 	br	81137748 <OSFlagPost+0x2cc>
811375dc:	10c000a0 	cmpeqi	r3,r2,2
811375e0:	1800031e 	bne	r3,zero,811375f0 <OSFlagPost+0x174>
811375e4:	108000e0 	cmpeqi	r2,r2,3
811375e8:	1000171e 	bne	r2,zero,81137648 <OSFlagPost+0x1cc>
811375ec:	00005606 	br	81137748 <OSFlagPost+0x2cc>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811375f0:	e0bffc17 	ldw	r2,-16(fp)
811375f4:	10c0020b 	ldhu	r3,8(r2)
811375f8:	e0bff117 	ldw	r2,-60(fp)
811375fc:	1080040b 	ldhu	r2,16(r2)
81137600:	1884703a 	and	r2,r3,r2
81137604:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
81137608:	e0bff117 	ldw	r2,-60(fp)
8113760c:	1080040b 	ldhu	r2,16(r2)
81137610:	10ffffcc 	andi	r3,r2,65535
81137614:	e0bff60b 	ldhu	r2,-40(fp)
81137618:	1880541e 	bne	r3,r2,8113776c <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113761c:	e0bff60b 	ldhu	r2,-40(fp)
81137620:	100b883a 	mov	r5,r2
81137624:	e13ff117 	ldw	r4,-60(fp)
81137628:	1137b340 	call	81137b34 <OS_FlagTaskRdy>
8113762c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81137630:	e0bff683 	ldbu	r2,-38(fp)
81137634:	10800058 	cmpnei	r2,r2,1
81137638:	10004c1e 	bne	r2,zero,8113776c <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113763c:	00800044 	movi	r2,1
81137640:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81137644:	00004906 	br	8113776c <OSFlagPost+0x2f0>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81137648:	e0bffc17 	ldw	r2,-16(fp)
8113764c:	10c0020b 	ldhu	r3,8(r2)
81137650:	e0bff117 	ldw	r2,-60(fp)
81137654:	1080040b 	ldhu	r2,16(r2)
81137658:	1884703a 	and	r2,r3,r2
8113765c:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81137660:	e0bff60b 	ldhu	r2,-40(fp)
81137664:	10004326 	beq	r2,zero,81137774 <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
81137668:	e0bff60b 	ldhu	r2,-40(fp)
8113766c:	100b883a 	mov	r5,r2
81137670:	e13ff117 	ldw	r4,-60(fp)
81137674:	1137b340 	call	81137b34 <OS_FlagTaskRdy>
81137678:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
8113767c:	e0bff683 	ldbu	r2,-38(fp)
81137680:	10800058 	cmpnei	r2,r2,1
81137684:	10003b1e 	bne	r2,zero,81137774 <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
81137688:	00800044 	movi	r2,1
8113768c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81137690:	00003806 	br	81137774 <OSFlagPost+0x2f8>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
81137694:	e0bffc17 	ldw	r2,-16(fp)
81137698:	1080020b 	ldhu	r2,8(r2)
8113769c:	0084303a 	nor	r2,zero,r2
811376a0:	1007883a 	mov	r3,r2
811376a4:	e0bff117 	ldw	r2,-60(fp)
811376a8:	1080040b 	ldhu	r2,16(r2)
811376ac:	1884703a 	and	r2,r3,r2
811376b0:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
811376b4:	e0bff117 	ldw	r2,-60(fp)
811376b8:	1080040b 	ldhu	r2,16(r2)
811376bc:	10ffffcc 	andi	r3,r2,65535
811376c0:	e0bff60b 	ldhu	r2,-40(fp)
811376c4:	18802d1e 	bne	r3,r2,8113777c <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
811376c8:	e0bff60b 	ldhu	r2,-40(fp)
811376cc:	100b883a 	mov	r5,r2
811376d0:	e13ff117 	ldw	r4,-60(fp)
811376d4:	1137b340 	call	81137b34 <OS_FlagTaskRdy>
811376d8:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
811376dc:	e0bff683 	ldbu	r2,-38(fp)
811376e0:	10800058 	cmpnei	r2,r2,1
811376e4:	1000251e 	bne	r2,zero,8113777c <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
811376e8:	00800044 	movi	r2,1
811376ec:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
811376f0:	00002206 	br	8113777c <OSFlagPost+0x300>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
811376f4:	e0bffc17 	ldw	r2,-16(fp)
811376f8:	1080020b 	ldhu	r2,8(r2)
811376fc:	0084303a 	nor	r2,zero,r2
81137700:	1007883a 	mov	r3,r2
81137704:	e0bff117 	ldw	r2,-60(fp)
81137708:	1080040b 	ldhu	r2,16(r2)
8113770c:	1884703a 	and	r2,r3,r2
81137710:	e0bff60d 	sth	r2,-40(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
81137714:	e0bff60b 	ldhu	r2,-40(fp)
81137718:	10001a26 	beq	r2,zero,81137784 <OSFlagPost+0x308>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
8113771c:	e0bff60b 	ldhu	r2,-40(fp)
81137720:	100b883a 	mov	r5,r2
81137724:	e13ff117 	ldw	r4,-60(fp)
81137728:	1137b340 	call	81137b34 <OS_FlagTaskRdy>
8113772c:	e0bff685 	stb	r2,-38(fp)
                     if (rdy == OS_TRUE) {
81137730:	e0bff683 	ldbu	r2,-38(fp)
81137734:	10800058 	cmpnei	r2,r2,1
81137738:	1000121e 	bne	r2,zero,81137784 <OSFlagPost+0x308>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
8113773c:	00800044 	movi	r2,1
81137740:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
81137744:	00000f06 	br	81137784 <OSFlagPost+0x308>
81137748:	e0bff317 	ldw	r2,-52(fp)
8113774c:	e0bff515 	stw	r2,-44(fp)
81137750:	e0bff517 	ldw	r2,-44(fp)
81137754:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
81137758:	e0bfff17 	ldw	r2,-4(fp)
8113775c:	00c01bc4 	movi	r3,111
81137760:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
81137764:	0005883a 	mov	r2,zero
81137768:	00002606 	br	81137804 <OSFlagPost+0x388>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113776c:	0001883a 	nop
81137770:	00000506 	br	81137788 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81137774:	0001883a 	nop
81137778:	00000306 	br	81137788 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
8113777c:	0001883a 	nop
81137780:	00000106 	br	81137788 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
81137784:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
81137788:	e0bff117 	ldw	r2,-60(fp)
8113778c:	10800017 	ldw	r2,0(r2)
81137790:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
81137794:	e0bff117 	ldw	r2,-60(fp)
81137798:	103f871e 	bne	r2,zero,811375b8 <__reset+0xfb1175b8>
8113779c:	e0bff317 	ldw	r2,-52(fp)
811377a0:	e0bff715 	stw	r2,-36(fp)
811377a4:	e0bff717 	ldw	r2,-36(fp)
811377a8:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
811377ac:	e0bff203 	ldbu	r2,-56(fp)
811377b0:	10800058 	cmpnei	r2,r2,1
811377b4:	1000011e 	bne	r2,zero,811377bc <OSFlagPost+0x340>
        OS_Sched();
811377b8:	1135c440 	call	81135c44 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811377bc:	0005303a 	rdctl	r2,status
811377c0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811377c4:	e0fffa17 	ldw	r3,-24(fp)
811377c8:	00bfff84 	movi	r2,-2
811377cc:	1884703a 	and	r2,r3,r2
811377d0:	1001703a 	wrctl	status,r2
  
  return context;
811377d4:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
811377d8:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
811377dc:	e0bffc17 	ldw	r2,-16(fp)
811377e0:	1080020b 	ldhu	r2,8(r2)
811377e4:	e0bff90d 	sth	r2,-28(fp)
811377e8:	e0bff317 	ldw	r2,-52(fp)
811377ec:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811377f0:	e0bff817 	ldw	r2,-32(fp)
811377f4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
811377f8:	e0bfff17 	ldw	r2,-4(fp)
811377fc:	10000005 	stb	zero,0(r2)
    return (flags_cur);
81137800:	e0bff90b 	ldhu	r2,-28(fp)
}
81137804:	e037883a 	mov	sp,fp
81137808:	dfc00117 	ldw	ra,4(sp)
8113780c:	df000017 	ldw	fp,0(sp)
81137810:	dec00204 	addi	sp,sp,8
81137814:	f800283a 	ret

81137818 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
81137818:	defff904 	addi	sp,sp,-28
8113781c:	de00012e 	bgeu	sp,et,81137824 <OSFlagQuery+0xc>
81137820:	003b68fa 	trap	3
81137824:	df000615 	stw	fp,24(sp)
81137828:	df000604 	addi	fp,sp,24
8113782c:	e13ffe15 	stw	r4,-8(fp)
81137830:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
81137834:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
81137838:	e0bfff17 	ldw	r2,-4(fp)
8113783c:	1000021e 	bne	r2,zero,81137848 <OSFlagQuery+0x30>
        return ((OS_FLAGS)0);
81137840:	0005883a 	mov	r2,zero
81137844:	00002306 	br	811378d4 <OSFlagQuery+0xbc>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
81137848:	e0bffe17 	ldw	r2,-8(fp)
8113784c:	1000051e 	bne	r2,zero,81137864 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
81137850:	e0bfff17 	ldw	r2,-4(fp)
81137854:	00c01b84 	movi	r3,110
81137858:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
8113785c:	0005883a 	mov	r2,zero
81137860:	00001c06 	br	811378d4 <OSFlagQuery+0xbc>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
81137864:	e0bffe17 	ldw	r2,-8(fp)
81137868:	10800003 	ldbu	r2,0(r2)
8113786c:	10803fcc 	andi	r2,r2,255
81137870:	10800160 	cmpeqi	r2,r2,5
81137874:	1000051e 	bne	r2,zero,8113788c <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81137878:	e0bfff17 	ldw	r2,-4(fp)
8113787c:	00c00044 	movi	r3,1
81137880:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
81137884:	0005883a 	mov	r2,zero
81137888:	00001206 	br	811378d4 <OSFlagQuery+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113788c:	0005303a 	rdctl	r2,status
81137890:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137894:	e0fffc17 	ldw	r3,-16(fp)
81137898:	00bfff84 	movi	r2,-2
8113789c:	1884703a 	and	r2,r3,r2
811378a0:	1001703a 	wrctl	status,r2
  
  return context;
811378a4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811378a8:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
811378ac:	e0bffe17 	ldw	r2,-8(fp)
811378b0:	1080020b 	ldhu	r2,8(r2)
811378b4:	e0bffb0d 	sth	r2,-20(fp)
811378b8:	e0bffa17 	ldw	r2,-24(fp)
811378bc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811378c0:	e0bffd17 	ldw	r2,-12(fp)
811378c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811378c8:	e0bfff17 	ldw	r2,-4(fp)
811378cc:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
811378d0:	e0bffb0b 	ldhu	r2,-20(fp)
}
811378d4:	e037883a 	mov	sp,fp
811378d8:	df000017 	ldw	fp,0(sp)
811378dc:	dec00104 	addi	sp,sp,4
811378e0:	f800283a 	ret

811378e4 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
811378e4:	defff804 	addi	sp,sp,-32
811378e8:	de00012e 	bgeu	sp,et,811378f0 <OS_FlagBlock+0xc>
811378ec:	003b68fa 	trap	3
811378f0:	df000715 	stw	fp,28(sp)
811378f4:	df000704 	addi	fp,sp,28
811378f8:	e13ffb15 	stw	r4,-20(fp)
811378fc:	e17ffc15 	stw	r5,-16(fp)
81137900:	3009883a 	mov	r4,r6
81137904:	3807883a 	mov	r3,r7
81137908:	e0800117 	ldw	r2,4(fp)
8113790c:	e13ffd0d 	sth	r4,-12(fp)
81137910:	e0fffe05 	stb	r3,-8(fp)
81137914:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
81137918:	d0a09e17 	ldw	r2,-32136(gp)
8113791c:	d0e09e17 	ldw	r3,-32136(gp)
81137920:	18c00c03 	ldbu	r3,48(r3)
81137924:	18c00814 	ori	r3,r3,32
81137928:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
8113792c:	d0a09e17 	ldw	r2,-32136(gp)
81137930:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
81137934:	d0a09e17 	ldw	r2,-32136(gp)
81137938:	e0ffff0b 	ldhu	r3,-4(fp)
8113793c:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
81137940:	d0a09e17 	ldw	r2,-32136(gp)
81137944:	e0fffc17 	ldw	r3,-16(fp)
81137948:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
8113794c:	e0bffc17 	ldw	r2,-16(fp)
81137950:	e0fffd0b 	ldhu	r3,-12(fp)
81137954:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
81137958:	e0bffc17 	ldw	r2,-16(fp)
8113795c:	e0fffe03 	ldbu	r3,-8(fp)
81137960:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
81137964:	d0e09e17 	ldw	r3,-32136(gp)
81137968:	e0bffc17 	ldw	r2,-16(fp)
8113796c:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
81137970:	e0bffb17 	ldw	r2,-20(fp)
81137974:	10c00117 	ldw	r3,4(r2)
81137978:	e0bffc17 	ldw	r2,-16(fp)
8113797c:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
81137980:	e0bffc17 	ldw	r2,-16(fp)
81137984:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
81137988:	e0bffc17 	ldw	r2,-16(fp)
8113798c:	e0fffb17 	ldw	r3,-20(fp)
81137990:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
81137994:	e0bffb17 	ldw	r2,-20(fp)
81137998:	10800117 	ldw	r2,4(r2)
8113799c:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
811379a0:	e0bff917 	ldw	r2,-28(fp)
811379a4:	10000326 	beq	r2,zero,811379b4 <OS_FlagBlock+0xd0>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
811379a8:	e0bff917 	ldw	r2,-28(fp)
811379ac:	e0fffc17 	ldw	r3,-16(fp)
811379b0:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
811379b4:	e0bffb17 	ldw	r2,-20(fp)
811379b8:	e0fffc17 	ldw	r3,-16(fp)
811379bc:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
811379c0:	d0a09e17 	ldw	r2,-32136(gp)
811379c4:	10800d03 	ldbu	r2,52(r2)
811379c8:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
811379cc:	e0fffa03 	ldbu	r3,-24(fp)
811379d0:	e13ffa03 	ldbu	r4,-24(fp)
811379d4:	d0a09a44 	addi	r2,gp,-32151
811379d8:	2085883a 	add	r2,r4,r2
811379dc:	10800003 	ldbu	r2,0(r2)
811379e0:	1009883a 	mov	r4,r2
811379e4:	d0a09e17 	ldw	r2,-32136(gp)
811379e8:	10800d43 	ldbu	r2,53(r2)
811379ec:	0084303a 	nor	r2,zero,r2
811379f0:	2084703a 	and	r2,r4,r2
811379f4:	1009883a 	mov	r4,r2
811379f8:	d0a09a44 	addi	r2,gp,-32151
811379fc:	1885883a 	add	r2,r3,r2
81137a00:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0x00) {
81137a04:	e0fffa03 	ldbu	r3,-24(fp)
81137a08:	d0a09a44 	addi	r2,gp,-32151
81137a0c:	1885883a 	add	r2,r3,r2
81137a10:	10800003 	ldbu	r2,0(r2)
81137a14:	10803fcc 	andi	r2,r2,255
81137a18:	1000071e 	bne	r2,zero,81137a38 <OS_FlagBlock+0x154>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
81137a1c:	d0a09e17 	ldw	r2,-32136(gp)
81137a20:	10800d83 	ldbu	r2,54(r2)
81137a24:	0084303a 	nor	r2,zero,r2
81137a28:	1007883a 	mov	r3,r2
81137a2c:	d0a09a03 	ldbu	r2,-32152(gp)
81137a30:	1884703a 	and	r2,r3,r2
81137a34:	d0a09a05 	stb	r2,-32152(gp)
    }
}
81137a38:	0001883a 	nop
81137a3c:	e037883a 	mov	sp,fp
81137a40:	df000017 	ldw	fp,0(sp)
81137a44:	dec00104 	addi	sp,sp,4
81137a48:	f800283a 	ret

81137a4c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
81137a4c:	defffb04 	addi	sp,sp,-20
81137a50:	de00012e 	bgeu	sp,et,81137a58 <OS_FlagInit+0xc>
81137a54:	003b68fa 	trap	3
81137a58:	dfc00415 	stw	ra,16(sp)
81137a5c:	df000315 	stw	fp,12(sp)
81137a60:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
81137a64:	01421004 	movi	r5,2112
81137a68:	012045b4 	movhi	r4,33046
81137a6c:	21090e04 	addi	r4,r4,9272
81137a70:	1135b780 	call	81135b78 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
81137a74:	00a045b4 	movhi	r2,33046
81137a78:	10890e04 	addi	r2,r2,9272
81137a7c:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
81137a80:	00a045b4 	movhi	r2,33046
81137a84:	10891904 	addi	r2,r2,9316
81137a88:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81137a8c:	e03ffd0d 	sth	zero,-12(fp)
81137a90:	00001306 	br	81137ae0 <OS_FlagInit+0x94>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81137a94:	e0bffe17 	ldw	r2,-8(fp)
81137a98:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
81137a9c:	e0bffe17 	ldw	r2,-8(fp)
81137aa0:	e0ffff17 	ldw	r3,-4(fp)
81137aa4:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
81137aa8:	e0bffe17 	ldw	r2,-8(fp)
81137aac:	00c00fc4 	movi	r3,63
81137ab0:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81137ab4:	e0bffe17 	ldw	r2,-8(fp)
81137ab8:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
81137abc:	e0bffe17 	ldw	r2,-8(fp)
81137ac0:	10800b04 	addi	r2,r2,44
81137ac4:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
81137ac8:	e0bfff17 	ldw	r2,-4(fp)
81137acc:	10800b04 	addi	r2,r2,44
81137ad0:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
81137ad4:	e0bffd0b 	ldhu	r2,-12(fp)
81137ad8:	10800044 	addi	r2,r2,1
81137adc:	e0bffd0d 	sth	r2,-12(fp)
81137ae0:	e0bffd0b 	ldhu	r2,-12(fp)
81137ae4:	10800bf0 	cmpltui	r2,r2,47
81137ae8:	103fea1e 	bne	r2,zero,81137a94 <__reset+0xfb117a94>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
81137aec:	e0bffe17 	ldw	r2,-8(fp)
81137af0:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
81137af4:	e0bffe17 	ldw	r2,-8(fp)
81137af8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
81137afc:	e0bffe17 	ldw	r2,-8(fp)
81137b00:	00c00fc4 	movi	r3,63
81137b04:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
81137b08:	e0bffe17 	ldw	r2,-8(fp)
81137b0c:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
81137b10:	00a045b4 	movhi	r2,33046
81137b14:	10890e04 	addi	r2,r2,9272
81137b18:	d0a0a215 	stw	r2,-32120(gp)
#endif
}
81137b1c:	0001883a 	nop
81137b20:	e037883a 	mov	sp,fp
81137b24:	dfc00117 	ldw	ra,4(sp)
81137b28:	df000017 	ldw	fp,0(sp)
81137b2c:	dec00204 	addi	sp,sp,8
81137b30:	f800283a 	ret

81137b34 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
81137b34:	defffa04 	addi	sp,sp,-24
81137b38:	de00012e 	bgeu	sp,et,81137b40 <OS_FlagTaskRdy+0xc>
81137b3c:	003b68fa 	trap	3
81137b40:	dfc00515 	stw	ra,20(sp)
81137b44:	df000415 	stw	fp,16(sp)
81137b48:	df000404 	addi	fp,sp,16
81137b4c:	e13ffe15 	stw	r4,-8(fp)
81137b50:	2805883a 	mov	r2,r5
81137b54:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
81137b58:	e0bffe17 	ldw	r2,-8(fp)
81137b5c:	10800217 	ldw	r2,8(r2)
81137b60:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
81137b64:	e0bffd17 	ldw	r2,-12(fp)
81137b68:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
81137b6c:	e0bffd17 	ldw	r2,-12(fp)
81137b70:	e0ffff0b 	ldhu	r3,-4(fp)
81137b74:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
81137b78:	e0bffd17 	ldw	r2,-12(fp)
81137b7c:	10c00c03 	ldbu	r3,48(r2)
81137b80:	00bff7c4 	movi	r2,-33
81137b84:	1884703a 	and	r2,r3,r2
81137b88:	1007883a 	mov	r3,r2
81137b8c:	e0bffd17 	ldw	r2,-12(fp)
81137b90:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
81137b94:	e0bffd17 	ldw	r2,-12(fp)
81137b98:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
81137b9c:	e0bffd17 	ldw	r2,-12(fp)
81137ba0:	10800c03 	ldbu	r2,48(r2)
81137ba4:	10803fcc 	andi	r2,r2,255
81137ba8:	1000181e 	bne	r2,zero,81137c0c <OS_FlagTaskRdy+0xd8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
81137bac:	e0bffd17 	ldw	r2,-12(fp)
81137bb0:	10c00d83 	ldbu	r3,54(r2)
81137bb4:	d0a09a03 	ldbu	r2,-32152(gp)
81137bb8:	1884b03a 	or	r2,r3,r2
81137bbc:	d0a09a05 	stb	r2,-32152(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81137bc0:	e0bffd17 	ldw	r2,-12(fp)
81137bc4:	10800d03 	ldbu	r2,52(r2)
81137bc8:	10c03fcc 	andi	r3,r2,255
81137bcc:	e0bffd17 	ldw	r2,-12(fp)
81137bd0:	10800d03 	ldbu	r2,52(r2)
81137bd4:	11003fcc 	andi	r4,r2,255
81137bd8:	d0a09a44 	addi	r2,gp,-32151
81137bdc:	2085883a 	add	r2,r4,r2
81137be0:	11000003 	ldbu	r4,0(r2)
81137be4:	e0bffd17 	ldw	r2,-12(fp)
81137be8:	10800d43 	ldbu	r2,53(r2)
81137bec:	2084b03a 	or	r2,r4,r2
81137bf0:	1009883a 	mov	r4,r2
81137bf4:	d0a09a44 	addi	r2,gp,-32151
81137bf8:	1885883a 	add	r2,r3,r2
81137bfc:	11000005 	stb	r4,0(r2)
        sched                   = OS_TRUE;
81137c00:	00800044 	movi	r2,1
81137c04:	e0bffc05 	stb	r2,-16(fp)
81137c08:	00000106 	br	81137c10 <OS_FlagTaskRdy+0xdc>
    } else {
        sched                   = OS_FALSE;
81137c0c:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
81137c10:	e13ffe17 	ldw	r4,-8(fp)
81137c14:	1137c300 	call	81137c30 <OS_FlagUnlink>
    return (sched);
81137c18:	e0bffc03 	ldbu	r2,-16(fp)
}
81137c1c:	e037883a 	mov	sp,fp
81137c20:	dfc00117 	ldw	ra,4(sp)
81137c24:	df000017 	ldw	fp,0(sp)
81137c28:	dec00204 	addi	sp,sp,8
81137c2c:	f800283a 	ret

81137c30 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
81137c30:	defffa04 	addi	sp,sp,-24
81137c34:	de00012e 	bgeu	sp,et,81137c3c <OS_FlagUnlink+0xc>
81137c38:	003b68fa 	trap	3
81137c3c:	df000515 	stw	fp,20(sp)
81137c40:	df000504 	addi	fp,sp,20
81137c44:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
81137c48:	e0bfff17 	ldw	r2,-4(fp)
81137c4c:	10800117 	ldw	r2,4(r2)
81137c50:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
81137c54:	e0bfff17 	ldw	r2,-4(fp)
81137c58:	10800017 	ldw	r2,0(r2)
81137c5c:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
81137c60:	e0bffb17 	ldw	r2,-20(fp)
81137c64:	10000b1e 	bne	r2,zero,81137c94 <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
81137c68:	e0bfff17 	ldw	r2,-4(fp)
81137c6c:	10800317 	ldw	r2,12(r2)
81137c70:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
81137c74:	e0bffd17 	ldw	r2,-12(fp)
81137c78:	e0fffc17 	ldw	r3,-16(fp)
81137c7c:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
81137c80:	e0bffc17 	ldw	r2,-16(fp)
81137c84:	10000b26 	beq	r2,zero,81137cb4 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
81137c88:	e0bffc17 	ldw	r2,-16(fp)
81137c8c:	10000115 	stw	zero,4(r2)
81137c90:	00000806 	br	81137cb4 <OS_FlagUnlink+0x84>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
81137c94:	e0bffb17 	ldw	r2,-20(fp)
81137c98:	e0fffc17 	ldw	r3,-16(fp)
81137c9c:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
81137ca0:	e0bffc17 	ldw	r2,-16(fp)
81137ca4:	10000326 	beq	r2,zero,81137cb4 <OS_FlagUnlink+0x84>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
81137ca8:	e0bffc17 	ldw	r2,-16(fp)
81137cac:	e0fffb17 	ldw	r3,-20(fp)
81137cb0:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
81137cb4:	e0bfff17 	ldw	r2,-4(fp)
81137cb8:	10800217 	ldw	r2,8(r2)
81137cbc:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
81137cc0:	e0bffe17 	ldw	r2,-8(fp)
81137cc4:	10000a15 	stw	zero,40(r2)
#endif
}
81137cc8:	0001883a 	nop
81137ccc:	e037883a 	mov	sp,fp
81137cd0:	df000017 	ldw	fp,0(sp)
81137cd4:	dec00104 	addi	sp,sp,4
81137cd8:	f800283a 	ret

81137cdc <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
81137cdc:	defff404 	addi	sp,sp,-48
81137ce0:	de00012e 	bgeu	sp,et,81137ce8 <OSMemCreate+0xc>
81137ce4:	003b68fa 	trap	3
81137ce8:	df000b15 	stw	fp,44(sp)
81137cec:	df000b04 	addi	fp,sp,44
81137cf0:	e13ffc15 	stw	r4,-16(fp)
81137cf4:	e17ffd15 	stw	r5,-12(fp)
81137cf8:	e1bffe15 	stw	r6,-8(fp)
81137cfc:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81137d00:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81137d04:	e0bfff17 	ldw	r2,-4(fp)
81137d08:	1000021e 	bne	r2,zero,81137d14 <OSMemCreate+0x38>
        return ((OS_MEM *)0);
81137d0c:	0005883a 	mov	r2,zero
81137d10:	00006506 	br	81137ea8 <OSMemCreate+0x1cc>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
81137d14:	e0bffc17 	ldw	r2,-16(fp)
81137d18:	1000051e 	bne	r2,zero,81137d30 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81137d1c:	e0bfff17 	ldw	r2,-4(fp)
81137d20:	00c01884 	movi	r3,98
81137d24:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81137d28:	0005883a 	mov	r2,zero
81137d2c:	00005e06 	br	81137ea8 <OSMemCreate+0x1cc>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
81137d30:	e0bffc17 	ldw	r2,-16(fp)
81137d34:	108000cc 	andi	r2,r2,3
81137d38:	10000526 	beq	r2,zero,81137d50 <OSMemCreate+0x74>
        *perr = OS_ERR_MEM_INVALID_ADDR;
81137d3c:	e0bfff17 	ldw	r2,-4(fp)
81137d40:	00c01884 	movi	r3,98
81137d44:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81137d48:	0005883a 	mov	r2,zero
81137d4c:	00005606 	br	81137ea8 <OSMemCreate+0x1cc>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
81137d50:	e0bffd17 	ldw	r2,-12(fp)
81137d54:	108000a8 	cmpgeui	r2,r2,2
81137d58:	1000051e 	bne	r2,zero,81137d70 <OSMemCreate+0x94>
        *perr = OS_ERR_MEM_INVALID_BLKS;
81137d5c:	e0bfff17 	ldw	r2,-4(fp)
81137d60:	00c016c4 	movi	r3,91
81137d64:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81137d68:	0005883a 	mov	r2,zero
81137d6c:	00004e06 	br	81137ea8 <OSMemCreate+0x1cc>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
81137d70:	e0bffe17 	ldw	r2,-8(fp)
81137d74:	10800128 	cmpgeui	r2,r2,4
81137d78:	1000051e 	bne	r2,zero,81137d90 <OSMemCreate+0xb4>
        *perr = OS_ERR_MEM_INVALID_SIZE;
81137d7c:	e0bfff17 	ldw	r2,-4(fp)
81137d80:	00c01704 	movi	r3,92
81137d84:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81137d88:	0005883a 	mov	r2,zero
81137d8c:	00004606 	br	81137ea8 <OSMemCreate+0x1cc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137d90:	0005303a 	rdctl	r2,status
81137d94:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137d98:	e0fffb17 	ldw	r3,-20(fp)
81137d9c:	00bfff84 	movi	r2,-2
81137da0:	1884703a 	and	r2,r3,r2
81137da4:	1001703a 	wrctl	status,r2
  
  return context;
81137da8:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137dac:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
81137db0:	d0a09717 	ldw	r2,-32164(gp)
81137db4:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
81137db8:	d0a09717 	ldw	r2,-32164(gp)
81137dbc:	10000326 	beq	r2,zero,81137dcc <OSMemCreate+0xf0>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
81137dc0:	d0a09717 	ldw	r2,-32164(gp)
81137dc4:	10800117 	ldw	r2,4(r2)
81137dc8:	d0a09715 	stw	r2,-32164(gp)
81137dcc:	e0bff817 	ldw	r2,-32(fp)
81137dd0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137dd4:	e0bff917 	ldw	r2,-28(fp)
81137dd8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
81137ddc:	e0bffa17 	ldw	r2,-24(fp)
81137de0:	1000051e 	bne	r2,zero,81137df8 <OSMemCreate+0x11c>
        *perr = OS_ERR_MEM_INVALID_PART;
81137de4:	e0bfff17 	ldw	r2,-4(fp)
81137de8:	00c01684 	movi	r3,90
81137dec:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
81137df0:	0005883a 	mov	r2,zero
81137df4:	00002c06 	br	81137ea8 <OSMemCreate+0x1cc>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
81137df8:	e0bffc17 	ldw	r2,-16(fp)
81137dfc:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
81137e00:	e0fffc17 	ldw	r3,-16(fp)
81137e04:	e0bffe17 	ldw	r2,-8(fp)
81137e08:	1885883a 	add	r2,r3,r2
81137e0c:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
81137e10:	e03ff715 	stw	zero,-36(fp)
81137e14:	00000c06 	br	81137e48 <OSMemCreate+0x16c>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
81137e18:	e0bff617 	ldw	r2,-40(fp)
81137e1c:	e0fff517 	ldw	r3,-44(fp)
81137e20:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
81137e24:	e0bff517 	ldw	r2,-44(fp)
81137e28:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
81137e2c:	e0fff517 	ldw	r3,-44(fp)
81137e30:	e0bffe17 	ldw	r2,-8(fp)
81137e34:	1885883a 	add	r2,r3,r2
81137e38:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
81137e3c:	e0bff717 	ldw	r2,-36(fp)
81137e40:	10800044 	addi	r2,r2,1
81137e44:	e0bff715 	stw	r2,-36(fp)
81137e48:	e0bffd17 	ldw	r2,-12(fp)
81137e4c:	10bfffc4 	addi	r2,r2,-1
81137e50:	e0fff717 	ldw	r3,-36(fp)
81137e54:	18bff036 	bltu	r3,r2,81137e18 <__reset+0xfb117e18>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
81137e58:	e0bff617 	ldw	r2,-40(fp)
81137e5c:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
81137e60:	e0bffa17 	ldw	r2,-24(fp)
81137e64:	e0fffc17 	ldw	r3,-16(fp)
81137e68:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
81137e6c:	e0bffa17 	ldw	r2,-24(fp)
81137e70:	e0fffc17 	ldw	r3,-16(fp)
81137e74:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
81137e78:	e0bffa17 	ldw	r2,-24(fp)
81137e7c:	e0fffd17 	ldw	r3,-12(fp)
81137e80:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
81137e84:	e0bffa17 	ldw	r2,-24(fp)
81137e88:	e0fffd17 	ldw	r3,-12(fp)
81137e8c:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
81137e90:	e0bffa17 	ldw	r2,-24(fp)
81137e94:	e0fffe17 	ldw	r3,-8(fp)
81137e98:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
81137e9c:	e0bfff17 	ldw	r2,-4(fp)
81137ea0:	10000005 	stb	zero,0(r2)
    return (pmem);
81137ea4:	e0bffa17 	ldw	r2,-24(fp)
}
81137ea8:	e037883a 	mov	sp,fp
81137eac:	df000017 	ldw	fp,0(sp)
81137eb0:	dec00104 	addi	sp,sp,4
81137eb4:	f800283a 	ret

81137eb8 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
81137eb8:	defff804 	addi	sp,sp,-32
81137ebc:	de00012e 	bgeu	sp,et,81137ec4 <OSMemGet+0xc>
81137ec0:	003b68fa 	trap	3
81137ec4:	df000715 	stw	fp,28(sp)
81137ec8:	df000704 	addi	fp,sp,28
81137ecc:	e13ffe15 	stw	r4,-8(fp)
81137ed0:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81137ed4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
81137ed8:	e0bfff17 	ldw	r2,-4(fp)
81137edc:	1000021e 	bne	r2,zero,81137ee8 <OSMemGet+0x30>
        return ((void *)0);
81137ee0:	0005883a 	mov	r2,zero
81137ee4:	00002e06 	br	81137fa0 <OSMemGet+0xe8>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
81137ee8:	e0bffe17 	ldw	r2,-8(fp)
81137eec:	1000051e 	bne	r2,zero,81137f04 <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81137ef0:	e0bfff17 	ldw	r2,-4(fp)
81137ef4:	00c01804 	movi	r3,96
81137ef8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81137efc:	0005883a 	mov	r2,zero
81137f00:	00002706 	br	81137fa0 <OSMemGet+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81137f04:	0005303a 	rdctl	r2,status
81137f08:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81137f0c:	e0fffd17 	ldw	r3,-12(fp)
81137f10:	00bfff84 	movi	r2,-2
81137f14:	1884703a 	and	r2,r3,r2
81137f18:	1001703a 	wrctl	status,r2
  
  return context;
81137f1c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81137f20:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
81137f24:	e0bffe17 	ldw	r2,-8(fp)
81137f28:	10800417 	ldw	r2,16(r2)
81137f2c:	10001426 	beq	r2,zero,81137f80 <OSMemGet+0xc8>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
81137f30:	e0bffe17 	ldw	r2,-8(fp)
81137f34:	10800117 	ldw	r2,4(r2)
81137f38:	e0bffb15 	stw	r2,-20(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
81137f3c:	e0bffb17 	ldw	r2,-20(fp)
81137f40:	10c00017 	ldw	r3,0(r2)
81137f44:	e0bffe17 	ldw	r2,-8(fp)
81137f48:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
81137f4c:	e0bffe17 	ldw	r2,-8(fp)
81137f50:	10800417 	ldw	r2,16(r2)
81137f54:	10ffffc4 	addi	r3,r2,-1
81137f58:	e0bffe17 	ldw	r2,-8(fp)
81137f5c:	10c00415 	stw	r3,16(r2)
81137f60:	e0bff917 	ldw	r2,-28(fp)
81137f64:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81137f68:	e0bffa17 	ldw	r2,-24(fp)
81137f6c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
81137f70:	e0bfff17 	ldw	r2,-4(fp)
81137f74:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
81137f78:	e0bffb17 	ldw	r2,-20(fp)
81137f7c:	00000806 	br	81137fa0 <OSMemGet+0xe8>
81137f80:	e0bff917 	ldw	r2,-28(fp)
81137f84:	e0bffc15 	stw	r2,-16(fp)
81137f88:	e0bffc17 	ldw	r2,-16(fp)
81137f8c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
81137f90:	e0bfff17 	ldw	r2,-4(fp)
81137f94:	00c01744 	movi	r3,93
81137f98:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
81137f9c:	0005883a 	mov	r2,zero
}
81137fa0:	e037883a 	mov	sp,fp
81137fa4:	df000017 	ldw	fp,0(sp)
81137fa8:	dec00104 	addi	sp,sp,4
81137fac:	f800283a 	ret

81137fb0 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
81137fb0:	defff704 	addi	sp,sp,-36
81137fb4:	de00012e 	bgeu	sp,et,81137fbc <OSMemNameGet+0xc>
81137fb8:	003b68fa 	trap	3
81137fbc:	dfc00815 	stw	ra,32(sp)
81137fc0:	df000715 	stw	fp,28(sp)
81137fc4:	df000704 	addi	fp,sp,28
81137fc8:	e13ffd15 	stw	r4,-12(fp)
81137fcc:	e17ffe15 	stw	r5,-8(fp)
81137fd0:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81137fd4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81137fd8:	e0bfff17 	ldw	r2,-4(fp)
81137fdc:	1000021e 	bne	r2,zero,81137fe8 <OSMemNameGet+0x38>
        return (0);
81137fe0:	0005883a 	mov	r2,zero
81137fe4:	00002b06 	br	81138094 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
81137fe8:	e0bffd17 	ldw	r2,-12(fp)
81137fec:	1000051e 	bne	r2,zero,81138004 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
81137ff0:	e0bfff17 	ldw	r2,-4(fp)
81137ff4:	00c01804 	movi	r3,96
81137ff8:	10c00005 	stb	r3,0(r2)
        return (0);
81137ffc:	0005883a 	mov	r2,zero
81138000:	00002406 	br	81138094 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
81138004:	e0bffe17 	ldw	r2,-8(fp)
81138008:	1000051e 	bne	r2,zero,81138020 <OSMemNameGet+0x70>
        *perr = OS_ERR_PNAME_NULL;
8113800c:	e0bfff17 	ldw	r2,-4(fp)
81138010:	00c00304 	movi	r3,12
81138014:	10c00005 	stb	r3,0(r2)
        return (0);
81138018:	0005883a 	mov	r2,zero
8113801c:	00001d06 	br	81138094 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138020:	d0a09d03 	ldbu	r2,-32140(gp)
81138024:	10803fcc 	andi	r2,r2,255
81138028:	10000526 	beq	r2,zero,81138040 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
8113802c:	e0bfff17 	ldw	r2,-4(fp)
81138030:	00c00444 	movi	r3,17
81138034:	10c00005 	stb	r3,0(r2)
        return (0);
81138038:	0005883a 	mov	r2,zero
8113803c:	00001506 	br	81138094 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138040:	0005303a 	rdctl	r2,status
81138044:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138048:	e0fffb17 	ldw	r3,-20(fp)
8113804c:	00bfff84 	movi	r2,-2
81138050:	1884703a 	and	r2,r3,r2
81138054:	1001703a 	wrctl	status,r2
  
  return context;
81138058:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
8113805c:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
81138060:	e0bffd17 	ldw	r2,-12(fp)
81138064:	10800504 	addi	r2,r2,20
81138068:	100b883a 	mov	r5,r2
8113806c:	e13ffe17 	ldw	r4,-8(fp)
81138070:	1135d980 	call	81135d98 <OS_StrCopy>
81138074:	e0bffa05 	stb	r2,-24(fp)
81138078:	e0bff917 	ldw	r2,-28(fp)
8113807c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138080:	e0bffc17 	ldw	r2,-16(fp)
81138084:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81138088:	e0bfff17 	ldw	r2,-4(fp)
8113808c:	10000005 	stb	zero,0(r2)
    return (len);
81138090:	e0bffa03 	ldbu	r2,-24(fp)
}
81138094:	e037883a 	mov	sp,fp
81138098:	dfc00117 	ldw	ra,4(sp)
8113809c:	df000017 	ldw	fp,0(sp)
811380a0:	dec00204 	addi	sp,sp,8
811380a4:	f800283a 	ret

811380a8 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
811380a8:	defff604 	addi	sp,sp,-40
811380ac:	de00012e 	bgeu	sp,et,811380b4 <OSMemNameSet+0xc>
811380b0:	003b68fa 	trap	3
811380b4:	dfc00915 	stw	ra,36(sp)
811380b8:	df000815 	stw	fp,32(sp)
811380bc:	df000804 	addi	fp,sp,32
811380c0:	e13ffd15 	stw	r4,-12(fp)
811380c4:	e17ffe15 	stw	r5,-8(fp)
811380c8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811380cc:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811380d0:	e0bfff17 	ldw	r2,-4(fp)
811380d4:	10003526 	beq	r2,zero,811381ac <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
811380d8:	e0bffd17 	ldw	r2,-12(fp)
811380dc:	1000041e 	bne	r2,zero,811380f0 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
811380e0:	e0bfff17 	ldw	r2,-4(fp)
811380e4:	00c01804 	movi	r3,96
811380e8:	10c00005 	stb	r3,0(r2)
        return;
811380ec:	00003006 	br	811381b0 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
811380f0:	e0bffe17 	ldw	r2,-8(fp)
811380f4:	1000041e 	bne	r2,zero,81138108 <OSMemNameSet+0x60>
        *perr = OS_ERR_PNAME_NULL;
811380f8:	e0bfff17 	ldw	r2,-4(fp)
811380fc:	00c00304 	movi	r3,12
81138100:	10c00005 	stb	r3,0(r2)
        return;
81138104:	00002a06 	br	811381b0 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
81138108:	d0a09d03 	ldbu	r2,-32140(gp)
8113810c:	10803fcc 	andi	r2,r2,255
81138110:	10000426 	beq	r2,zero,81138124 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
81138114:	e0bfff17 	ldw	r2,-4(fp)
81138118:	00c00484 	movi	r3,18
8113811c:	10c00005 	stb	r3,0(r2)
        return;
81138120:	00002306 	br	811381b0 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138124:	0005303a 	rdctl	r2,status
81138128:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113812c:	e0fffc17 	ldw	r3,-16(fp)
81138130:	00bfff84 	movi	r2,-2
81138134:	1884703a 	and	r2,r3,r2
81138138:	1001703a 	wrctl	status,r2
  
  return context;
8113813c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81138140:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
81138144:	e13ffe17 	ldw	r4,-8(fp)
81138148:	1135e140 	call	81135e14 <OS_StrLen>
8113814c:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
81138150:	e0bffa03 	ldbu	r2,-24(fp)
81138154:	10800830 	cmpltui	r2,r2,32
81138158:	1000081e 	bne	r2,zero,8113817c <OSMemNameSet+0xd4>
8113815c:	e0bff817 	ldw	r2,-32(fp)
81138160:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138164:	e0bff917 	ldw	r2,-28(fp)
81138168:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
8113816c:	e0bfff17 	ldw	r2,-4(fp)
81138170:	00c018c4 	movi	r3,99
81138174:	10c00005 	stb	r3,0(r2)
        return;
81138178:	00000d06 	br	811381b0 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
8113817c:	e0bffd17 	ldw	r2,-12(fp)
81138180:	10800504 	addi	r2,r2,20
81138184:	e17ffe17 	ldw	r5,-8(fp)
81138188:	1009883a 	mov	r4,r2
8113818c:	1135d980 	call	81135d98 <OS_StrCopy>
81138190:	e0bff817 	ldw	r2,-32(fp)
81138194:	e0bffb15 	stw	r2,-20(fp)
81138198:	e0bffb17 	ldw	r2,-20(fp)
8113819c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811381a0:	e0bfff17 	ldw	r2,-4(fp)
811381a4:	10000005 	stb	zero,0(r2)
811381a8:	00000106 	br	811381b0 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
811381ac:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
811381b0:	e037883a 	mov	sp,fp
811381b4:	dfc00117 	ldw	ra,4(sp)
811381b8:	df000017 	ldw	fp,0(sp)
811381bc:	dec00204 	addi	sp,sp,8
811381c0:	f800283a 	ret

811381c4 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
811381c4:	defff904 	addi	sp,sp,-28
811381c8:	de00012e 	bgeu	sp,et,811381d0 <OSMemPut+0xc>
811381cc:	003b68fa 	trap	3
811381d0:	df000615 	stw	fp,24(sp)
811381d4:	df000604 	addi	fp,sp,24
811381d8:	e13ffe15 	stw	r4,-8(fp)
811381dc:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811381e0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
811381e4:	e0bffe17 	ldw	r2,-8(fp)
811381e8:	1000021e 	bne	r2,zero,811381f4 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
811381ec:	00801804 	movi	r2,96
811381f0:	00002806 	br	81138294 <OSMemPut+0xd0>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
811381f4:	e0bfff17 	ldw	r2,-4(fp)
811381f8:	1000021e 	bne	r2,zero,81138204 <OSMemPut+0x40>
        return (OS_ERR_MEM_INVALID_PBLK);
811381fc:	008017c4 	movi	r2,95
81138200:	00002406 	br	81138294 <OSMemPut+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138204:	0005303a 	rdctl	r2,status
81138208:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113820c:	e0fffd17 	ldw	r3,-12(fp)
81138210:	00bfff84 	movi	r2,-2
81138214:	1884703a 	and	r2,r3,r2
81138218:	1001703a 	wrctl	status,r2
  
  return context;
8113821c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138220:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
81138224:	e0bffe17 	ldw	r2,-8(fp)
81138228:	10c00417 	ldw	r3,16(r2)
8113822c:	e0bffe17 	ldw	r2,-8(fp)
81138230:	10800317 	ldw	r2,12(r2)
81138234:	18800636 	bltu	r3,r2,81138250 <OSMemPut+0x8c>
81138238:	e0bffa17 	ldw	r2,-24(fp)
8113823c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138240:	e0bffb17 	ldw	r2,-20(fp)
81138244:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
81138248:	00801784 	movi	r2,94
8113824c:	00001106 	br	81138294 <OSMemPut+0xd0>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
81138250:	e0bffe17 	ldw	r2,-8(fp)
81138254:	10c00117 	ldw	r3,4(r2)
81138258:	e0bfff17 	ldw	r2,-4(fp)
8113825c:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
81138260:	e0bffe17 	ldw	r2,-8(fp)
81138264:	e0ffff17 	ldw	r3,-4(fp)
81138268:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
8113826c:	e0bffe17 	ldw	r2,-8(fp)
81138270:	10800417 	ldw	r2,16(r2)
81138274:	10c00044 	addi	r3,r2,1
81138278:	e0bffe17 	ldw	r2,-8(fp)
8113827c:	10c00415 	stw	r3,16(r2)
81138280:	e0bffa17 	ldw	r2,-24(fp)
81138284:	e0bffc15 	stw	r2,-16(fp)
81138288:	e0bffc17 	ldw	r2,-16(fp)
8113828c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
81138290:	0005883a 	mov	r2,zero
}
81138294:	e037883a 	mov	sp,fp
81138298:	df000017 	ldw	fp,0(sp)
8113829c:	dec00104 	addi	sp,sp,4
811382a0:	f800283a 	ret

811382a4 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
811382a4:	defffa04 	addi	sp,sp,-24
811382a8:	de00012e 	bgeu	sp,et,811382b0 <OSMemQuery+0xc>
811382ac:	003b68fa 	trap	3
811382b0:	df000515 	stw	fp,20(sp)
811382b4:	df000504 	addi	fp,sp,20
811382b8:	e13ffe15 	stw	r4,-8(fp)
811382bc:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811382c0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
811382c4:	e0bffe17 	ldw	r2,-8(fp)
811382c8:	1000021e 	bne	r2,zero,811382d4 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
811382cc:	00801804 	movi	r2,96
811382d0:	00002c06 	br	81138384 <OSMemQuery+0xe0>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
811382d4:	e0bfff17 	ldw	r2,-4(fp)
811382d8:	1000021e 	bne	r2,zero,811382e4 <OSMemQuery+0x40>
        return (OS_ERR_MEM_INVALID_PDATA);
811382dc:	00801844 	movi	r2,97
811382e0:	00002806 	br	81138384 <OSMemQuery+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811382e4:	0005303a 	rdctl	r2,status
811382e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811382ec:	e0fffc17 	ldw	r3,-16(fp)
811382f0:	00bfff84 	movi	r2,-2
811382f4:	1884703a 	and	r2,r3,r2
811382f8:	1001703a 	wrctl	status,r2
  
  return context;
811382fc:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81138300:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
81138304:	e0bffe17 	ldw	r2,-8(fp)
81138308:	10c00017 	ldw	r3,0(r2)
8113830c:	e0bfff17 	ldw	r2,-4(fp)
81138310:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
81138314:	e0bffe17 	ldw	r2,-8(fp)
81138318:	10c00117 	ldw	r3,4(r2)
8113831c:	e0bfff17 	ldw	r2,-4(fp)
81138320:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
81138324:	e0bffe17 	ldw	r2,-8(fp)
81138328:	10c00217 	ldw	r3,8(r2)
8113832c:	e0bfff17 	ldw	r2,-4(fp)
81138330:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
81138334:	e0bffe17 	ldw	r2,-8(fp)
81138338:	10c00317 	ldw	r3,12(r2)
8113833c:	e0bfff17 	ldw	r2,-4(fp)
81138340:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
81138344:	e0bffe17 	ldw	r2,-8(fp)
81138348:	10c00417 	ldw	r3,16(r2)
8113834c:	e0bfff17 	ldw	r2,-4(fp)
81138350:	10c00415 	stw	r3,16(r2)
81138354:	e0bffb17 	ldw	r2,-20(fp)
81138358:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113835c:	e0bffd17 	ldw	r2,-12(fp)
81138360:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
81138364:	e0bfff17 	ldw	r2,-4(fp)
81138368:	10c00317 	ldw	r3,12(r2)
8113836c:	e0bfff17 	ldw	r2,-4(fp)
81138370:	10800417 	ldw	r2,16(r2)
81138374:	1887c83a 	sub	r3,r3,r2
81138378:	e0bfff17 	ldw	r2,-4(fp)
8113837c:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
81138380:	0005883a 	mov	r2,zero
}
81138384:	e037883a 	mov	sp,fp
81138388:	df000017 	ldw	fp,0(sp)
8113838c:	dec00104 	addi	sp,sp,4
81138390:	f800283a 	ret

81138394 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
81138394:	defffc04 	addi	sp,sp,-16
81138398:	de00012e 	bgeu	sp,et,811383a0 <OS_MemInit+0xc>
8113839c:	003b68fa 	trap	3
811383a0:	dfc00315 	stw	ra,12(sp)
811383a4:	df000215 	stw	fp,8(sp)
811383a8:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
811383ac:	01430c04 	movi	r5,3120
811383b0:	012045b4 	movhi	r4,33046
811383b4:	210b8604 	addi	r4,r4,11800
811383b8:	1135b780 	call	81135b78 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
811383bc:	00a045b4 	movhi	r2,33046
811383c0:	108b8604 	addi	r2,r2,11800
811383c4:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
811383c8:	e03fff0d 	sth	zero,-4(fp)
811383cc:	00001306 	br	8113841c <OS_MemInit+0x88>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
811383d0:	e0bfff0b 	ldhu	r2,-4(fp)
811383d4:	10800044 	addi	r2,r2,1
811383d8:	10c00d24 	muli	r3,r2,52
811383dc:	00a045b4 	movhi	r2,33046
811383e0:	108b8604 	addi	r2,r2,11800
811383e4:	1887883a 	add	r3,r3,r2
811383e8:	e0bffe17 	ldw	r2,-8(fp)
811383ec:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
811383f0:	e0bffe17 	ldw	r2,-8(fp)
811383f4:	00c00fc4 	movi	r3,63
811383f8:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
811383fc:	e0bffe17 	ldw	r2,-8(fp)
81138400:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
81138404:	e0bffe17 	ldw	r2,-8(fp)
81138408:	10800d04 	addi	r2,r2,52
8113840c:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
81138410:	e0bfff0b 	ldhu	r2,-4(fp)
81138414:	10800044 	addi	r2,r2,1
81138418:	e0bfff0d 	sth	r2,-4(fp)
8113841c:	e0bfff0b 	ldhu	r2,-4(fp)
81138420:	10800ef0 	cmpltui	r2,r2,59
81138424:	103fea1e 	bne	r2,zero,811383d0 <__reset+0xfb1183d0>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
81138428:	e0bffe17 	ldw	r2,-8(fp)
8113842c:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
81138430:	e0bffe17 	ldw	r2,-8(fp)
81138434:	00c00fc4 	movi	r3,63
81138438:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
8113843c:	e0bffe17 	ldw	r2,-8(fp)
81138440:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
81138444:	00a045b4 	movhi	r2,33046
81138448:	108b8604 	addi	r2,r2,11800
8113844c:	d0a09715 	stw	r2,-32164(gp)
#endif
}
81138450:	0001883a 	nop
81138454:	e037883a 	mov	sp,fp
81138458:	dfc00117 	ldw	ra,4(sp)
8113845c:	df000017 	ldw	fp,0(sp)
81138460:	dec00204 	addi	sp,sp,8
81138464:	f800283a 	ret

81138468 <OSMutexAccept>:
*********************************************************************************************************
*/

#if OS_MUTEX_ACCEPT_EN > 0
BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
{
81138468:	defff704 	addi	sp,sp,-36
8113846c:	de00012e 	bgeu	sp,et,81138474 <OSMutexAccept+0xc>
81138470:	003b68fa 	trap	3
81138474:	df000815 	stw	fp,32(sp)
81138478:	df000804 	addi	fp,sp,32
8113847c:	e13ffe15 	stw	r4,-8(fp)
81138480:	e17fff15 	stw	r5,-4(fp)
    INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
81138484:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
81138488:	e0bfff17 	ldw	r2,-4(fp)
8113848c:	1000021e 	bne	r2,zero,81138498 <OSMutexAccept+0x30>
        return (OS_FALSE);
81138490:	0005883a 	mov	r2,zero
81138494:	00005b06 	br	81138604 <OSMutexAccept+0x19c>
    }
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
81138498:	e0bffe17 	ldw	r2,-8(fp)
8113849c:	1000051e 	bne	r2,zero,811384b4 <OSMutexAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811384a0:	e0bfff17 	ldw	r2,-4(fp)
811384a4:	00c00104 	movi	r3,4
811384a8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811384ac:	0005883a 	mov	r2,zero
811384b0:	00005406 	br	81138604 <OSMutexAccept+0x19c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
811384b4:	e0bffe17 	ldw	r2,-8(fp)
811384b8:	10800003 	ldbu	r2,0(r2)
811384bc:	10803fcc 	andi	r2,r2,255
811384c0:	10800120 	cmpeqi	r2,r2,4
811384c4:	1000051e 	bne	r2,zero,811384dc <OSMutexAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
811384c8:	e0bfff17 	ldw	r2,-4(fp)
811384cc:	00c00044 	movi	r3,1
811384d0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811384d4:	0005883a 	mov	r2,zero
811384d8:	00004a06 	br	81138604 <OSMutexAccept+0x19c>
    }
    if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
811384dc:	d0a09d03 	ldbu	r2,-32140(gp)
811384e0:	10803fcc 	andi	r2,r2,255
811384e4:	10000526 	beq	r2,zero,811384fc <OSMutexAccept+0x94>
        *perr = OS_ERR_PEND_ISR;
811384e8:	e0bfff17 	ldw	r2,-4(fp)
811384ec:	00c00084 	movi	r3,2
811384f0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
811384f4:	0005883a 	mov	r2,zero
811384f8:	00004206 	br	81138604 <OSMutexAccept+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811384fc:	0005303a 	rdctl	r2,status
81138500:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138504:	e0fffd17 	ldw	r3,-12(fp)
81138508:	00bfff84 	movi	r2,-2
8113850c:	1884703a 	and	r2,r3,r2
81138510:	1001703a 	wrctl	status,r2
  
  return context;
81138514:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
81138518:	e0bff815 	stw	r2,-32(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
8113851c:	e0bffe17 	ldw	r2,-8(fp)
81138520:	1080020b 	ldhu	r2,8(r2)
81138524:	10bfffcc 	andi	r2,r2,65535
81138528:	1004d23a 	srli	r2,r2,8
8113852c:	e0bffa05 	stb	r2,-24(fp)
    if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81138530:	e0bffe17 	ldw	r2,-8(fp)
81138534:	1080020b 	ldhu	r2,8(r2)
81138538:	10bfffcc 	andi	r2,r2,65535
8113853c:	10803fcc 	andi	r2,r2,255
81138540:	10803fd8 	cmpnei	r2,r2,255
81138544:	1000281e 	bne	r2,zero,811385e8 <OSMutexAccept+0x180>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
81138548:	e0bffe17 	ldw	r2,-8(fp)
8113854c:	10c0020b 	ldhu	r3,8(r2)
81138550:	00bfc004 	movi	r2,-256
81138554:	1884703a 	and	r2,r3,r2
81138558:	1007883a 	mov	r3,r2
8113855c:	e0bffe17 	ldw	r2,-8(fp)
81138560:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
81138564:	e0bffe17 	ldw	r2,-8(fp)
81138568:	10c0020b 	ldhu	r3,8(r2)
8113856c:	d0a09e17 	ldw	r2,-32136(gp)
81138570:	10800c83 	ldbu	r2,50(r2)
81138574:	10803fcc 	andi	r2,r2,255
81138578:	1884b03a 	or	r2,r3,r2
8113857c:	1007883a 	mov	r3,r2
81138580:	e0bffe17 	ldw	r2,-8(fp)
81138584:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
81138588:	d0e09e17 	ldw	r3,-32136(gp)
8113858c:	e0bffe17 	ldw	r2,-8(fp)
81138590:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
81138594:	d0a09e17 	ldw	r2,-32136(gp)
81138598:	10800c83 	ldbu	r2,50(r2)
8113859c:	10803fcc 	andi	r2,r2,255
811385a0:	e0fffa03 	ldbu	r3,-24(fp)
811385a4:	18800836 	bltu	r3,r2,811385c8 <OSMutexAccept+0x160>
811385a8:	e0bff817 	ldw	r2,-32(fp)
811385ac:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811385b0:	e0bff917 	ldw	r2,-28(fp)
811385b4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
            *perr = OS_ERR_PIP_LOWER;
811385b8:	e0bfff17 	ldw	r2,-4(fp)
811385bc:	00c01e04 	movi	r3,120
811385c0:	10c00005 	stb	r3,0(r2)
811385c4:	00000606 	br	811385e0 <OSMutexAccept+0x178>
811385c8:	e0bff817 	ldw	r2,-32(fp)
811385cc:	e0bffb15 	stw	r2,-20(fp)
811385d0:	e0bffb17 	ldw	r2,-20(fp)
811385d4:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
811385d8:	e0bfff17 	ldw	r2,-4(fp)
811385dc:	10000005 	stb	zero,0(r2)
        }
        return (OS_TRUE);
811385e0:	00800044 	movi	r2,1
811385e4:	00000706 	br	81138604 <OSMutexAccept+0x19c>
811385e8:	e0bff817 	ldw	r2,-32(fp)
811385ec:	e0bffc15 	stw	r2,-16(fp)
811385f0:	e0bffc17 	ldw	r2,-16(fp)
811385f4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
811385f8:	e0bfff17 	ldw	r2,-4(fp)
811385fc:	10000005 	stb	zero,0(r2)
    return (OS_FALSE);
81138600:	0005883a 	mov	r2,zero
}
81138604:	e037883a 	mov	sp,fp
81138608:	df000017 	ldw	fp,0(sp)
8113860c:	dec00104 	addi	sp,sp,4
81138610:	f800283a 	ret

81138614 <OSMutexCreate>:
*                 to use to reduce priority inversion.
*********************************************************************************************************
*/

OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
{
81138614:	defff604 	addi	sp,sp,-40
81138618:	de00012e 	bgeu	sp,et,81138620 <OSMutexCreate+0xc>
8113861c:	003b68fa 	trap	3
81138620:	dfc00915 	stw	ra,36(sp)
81138624:	df000815 	stw	fp,32(sp)
81138628:	df000804 	addi	fp,sp,32
8113862c:	2005883a 	mov	r2,r4
81138630:	e17fff15 	stw	r5,-4(fp)
81138634:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138638:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113863c:	e0bfff17 	ldw	r2,-4(fp)
81138640:	1000021e 	bne	r2,zero,8113864c <OSMutexCreate+0x38>
        return ((OS_EVENT *)0);
81138644:	0005883a 	mov	r2,zero
81138648:	00006106 	br	811387d0 <OSMutexCreate+0x1bc>
    }
    if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
8113864c:	e0bffe03 	ldbu	r2,-8(fp)
81138650:	10800ab0 	cmpltui	r2,r2,42
81138654:	1000051e 	bne	r2,zero,8113866c <OSMutexCreate+0x58>
        *perr = OS_ERR_PRIO_INVALID;
81138658:	e0bfff17 	ldw	r2,-4(fp)
8113865c:	00c00a84 	movi	r3,42
81138660:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81138664:	0005883a 	mov	r2,zero
81138668:	00005906 	br	811387d0 <OSMutexCreate+0x1bc>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113866c:	d0a09d03 	ldbu	r2,-32140(gp)
81138670:	10803fcc 	andi	r2,r2,255
81138674:	10000526 	beq	r2,zero,8113868c <OSMutexCreate+0x78>
        *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
81138678:	e0bfff17 	ldw	r2,-4(fp)
8113867c:	00c00404 	movi	r3,16
81138680:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
81138684:	0005883a 	mov	r2,zero
81138688:	00005106 	br	811387d0 <OSMutexCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113868c:	0005303a 	rdctl	r2,status
81138690:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138694:	e0fffd17 	ldw	r3,-12(fp)
81138698:	00bfff84 	movi	r2,-2
8113869c:	1884703a 	and	r2,r3,r2
811386a0:	1001703a 	wrctl	status,r2
  
  return context;
811386a4:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
811386a8:	e0bff815 	stw	r2,-32(fp)
    if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
811386ac:	e0fffe03 	ldbu	r3,-8(fp)
811386b0:	00a045f4 	movhi	r2,33047
811386b4:	10a10004 	addi	r2,r2,-31744
811386b8:	18c7883a 	add	r3,r3,r3
811386bc:	18c7883a 	add	r3,r3,r3
811386c0:	10c5883a 	add	r2,r2,r3
811386c4:	10800017 	ldw	r2,0(r2)
811386c8:	10000926 	beq	r2,zero,811386f0 <OSMutexCreate+0xdc>
811386cc:	e0bff817 	ldw	r2,-32(fp)
811386d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811386d4:	e0bff917 	ldw	r2,-28(fp)
811386d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
        *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
811386dc:	e0bfff17 	ldw	r2,-4(fp)
811386e0:	00c00a04 	movi	r3,40
811386e4:	10c00005 	stb	r3,0(r2)
        return ((OS_EVENT *)0);
811386e8:	0005883a 	mov	r2,zero
811386ec:	00003806 	br	811387d0 <OSMutexCreate+0x1bc>
    }
    OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
811386f0:	e0fffe03 	ldbu	r3,-8(fp)
811386f4:	00a045f4 	movhi	r2,33047
811386f8:	10a10004 	addi	r2,r2,-31744
811386fc:	18c7883a 	add	r3,r3,r3
81138700:	18c7883a 	add	r3,r3,r3
81138704:	10c5883a 	add	r2,r2,r3
81138708:	00c00044 	movi	r3,1
8113870c:	10c00015 	stw	r3,0(r2)
    pevent             = OSEventFreeList;                  /* Get next free event control block        */
81138710:	d0a09c17 	ldw	r2,-32144(gp)
81138714:	e0bffb15 	stw	r2,-20(fp)
    if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
81138718:	e0bffb17 	ldw	r2,-20(fp)
8113871c:	1000101e 	bne	r2,zero,81138760 <OSMutexCreate+0x14c>
        OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
81138720:	e0fffe03 	ldbu	r3,-8(fp)
81138724:	00a045f4 	movhi	r2,33047
81138728:	10a10004 	addi	r2,r2,-31744
8113872c:	18c7883a 	add	r3,r3,r3
81138730:	18c7883a 	add	r3,r3,r3
81138734:	10c5883a 	add	r2,r2,r3
81138738:	10000015 	stw	zero,0(r2)
8113873c:	e0bff817 	ldw	r2,-32(fp)
81138740:	e0bffa15 	stw	r2,-24(fp)
81138744:	e0bffa17 	ldw	r2,-24(fp)
81138748:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
8113874c:	e0bfff17 	ldw	r2,-4(fp)
81138750:	00c00104 	movi	r3,4
81138754:	10c00005 	stb	r3,0(r2)
        return (pevent);
81138758:	e0bffb17 	ldw	r2,-20(fp)
8113875c:	00001c06 	br	811387d0 <OSMutexCreate+0x1bc>
    }
    OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
81138760:	d0a09c17 	ldw	r2,-32144(gp)
81138764:	10800117 	ldw	r2,4(r2)
81138768:	d0a09c15 	stw	r2,-32144(gp)
8113876c:	e0bff817 	ldw	r2,-32(fp)
81138770:	e0bffc15 	stw	r2,-16(fp)
81138774:	e0bffc17 	ldw	r2,-16(fp)
81138778:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
8113877c:	e0bffb17 	ldw	r2,-20(fp)
81138780:	00c00104 	movi	r3,4
81138784:	10c00005 	stb	r3,0(r2)
    pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
81138788:	e0bffe03 	ldbu	r2,-8(fp)
8113878c:	1004923a 	slli	r2,r2,8
81138790:	10803fd4 	ori	r2,r2,255
81138794:	1007883a 	mov	r3,r2
81138798:	e0bffb17 	ldw	r2,-20(fp)
8113879c:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
811387a0:	e0bffb17 	ldw	r2,-20(fp)
811387a4:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent->OSEventName[0] = '?';
811387a8:	e0bffb17 	ldw	r2,-20(fp)
811387ac:	00c00fc4 	movi	r3,63
811387b0:	10c00445 	stb	r3,17(r2)
    pevent->OSEventName[1] = OS_ASCII_NUL;
811387b4:	e0bffb17 	ldw	r2,-20(fp)
811387b8:	10000485 	stb	zero,18(r2)
#endif
    OS_EventWaitListInit(pevent);
811387bc:	e13ffb17 	ldw	r4,-20(fp)
811387c0:	11357600 	call	81135760 <OS_EventWaitListInit>
    *perr                  = OS_ERR_NONE;
811387c4:	e0bfff17 	ldw	r2,-4(fp)
811387c8:	10000005 	stb	zero,0(r2)
    return (pevent);
811387cc:	e0bffb17 	ldw	r2,-20(fp)
}
811387d0:	e037883a 	mov	sp,fp
811387d4:	dfc00117 	ldw	ra,4(sp)
811387d8:	df000017 	ldw	fp,0(sp)
811387dc:	dec00204 	addi	sp,sp,8
811387e0:	f800283a 	ret

811387e4 <OSMutexDel>:
*********************************************************************************************************
*/

#if OS_MUTEX_DEL_EN
OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811387e4:	defff004 	addi	sp,sp,-64
811387e8:	de00012e 	bgeu	sp,et,811387f0 <OSMutexDel+0xc>
811387ec:	003b68fa 	trap	3
811387f0:	dfc00f15 	stw	ra,60(sp)
811387f4:	df000e15 	stw	fp,56(sp)
811387f8:	df000e04 	addi	fp,sp,56
811387fc:	e13ffd15 	stw	r4,-12(fp)
81138800:	2805883a 	mov	r2,r5
81138804:	e1bfff15 	stw	r6,-4(fp)
81138808:	e0bffe05 	stb	r2,-8(fp)
    OS_EVENT  *pevent_return;
    INT8U      pip;                                        /* Priority inheritance priority            */
    INT8U      prio;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113880c:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138810:	e0bfff17 	ldw	r2,-4(fp)
81138814:	1000021e 	bne	r2,zero,81138820 <OSMutexDel+0x3c>
        return (pevent);
81138818:	e0bffd17 	ldw	r2,-12(fp)
8113881c:	0000ad06 	br	81138ad4 <OSMutexDel+0x2f0>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138820:	e0bffd17 	ldw	r2,-12(fp)
81138824:	1000051e 	bne	r2,zero,8113883c <OSMutexDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81138828:	e0bfff17 	ldw	r2,-4(fp)
8113882c:	00c00104 	movi	r3,4
81138830:	10c00005 	stb	r3,0(r2)
        return (pevent);
81138834:	e0bffd17 	ldw	r2,-12(fp)
81138838:	0000a606 	br	81138ad4 <OSMutexDel+0x2f0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
8113883c:	e0bffd17 	ldw	r2,-12(fp)
81138840:	10800003 	ldbu	r2,0(r2)
81138844:	10803fcc 	andi	r2,r2,255
81138848:	10800120 	cmpeqi	r2,r2,4
8113884c:	1000051e 	bne	r2,zero,81138864 <OSMutexDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81138850:	e0bfff17 	ldw	r2,-4(fp)
81138854:	00c00044 	movi	r3,1
81138858:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113885c:	e0bffd17 	ldw	r2,-12(fp)
81138860:	00009c06 	br	81138ad4 <OSMutexDel+0x2f0>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81138864:	d0a09d03 	ldbu	r2,-32140(gp)
81138868:	10803fcc 	andi	r2,r2,255
8113886c:	10000526 	beq	r2,zero,81138884 <OSMutexDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
81138870:	e0bfff17 	ldw	r2,-4(fp)
81138874:	00c003c4 	movi	r3,15
81138878:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113887c:	e0bffd17 	ldw	r2,-12(fp)
81138880:	00009406 	br	81138ad4 <OSMutexDel+0x2f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138884:	0005303a 	rdctl	r2,status
81138888:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113888c:	e0fffc17 	ldw	r3,-16(fp)
81138890:	00bfff84 	movi	r2,-2
81138894:	1884703a 	and	r2,r3,r2
81138898:	1001703a 	wrctl	status,r2
  
  return context;
8113889c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
811388a0:	e0bff415 	stw	r2,-48(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
811388a4:	e0bffd17 	ldw	r2,-12(fp)
811388a8:	10800283 	ldbu	r2,10(r2)
811388ac:	10803fcc 	andi	r2,r2,255
811388b0:	10000326 	beq	r2,zero,811388c0 <OSMutexDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
811388b4:	00800044 	movi	r2,1
811388b8:	e0bff205 	stb	r2,-56(fp)
811388bc:	00000106 	br	811388c4 <OSMutexDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
811388c0:	e03ff205 	stb	zero,-56(fp)
    }
    switch (opt) {
811388c4:	e0bffe03 	ldbu	r2,-8(fp)
811388c8:	10000326 	beq	r2,zero,811388d8 <OSMutexDel+0xf4>
811388cc:	10800060 	cmpeqi	r2,r2,1
811388d0:	10002f1e 	bne	r2,zero,81138990 <OSMutexDel+0x1ac>
811388d4:	00007406 	br	81138aa8 <OSMutexDel+0x2c4>
        case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
             if (tasks_waiting == OS_FALSE) {
811388d8:	e0bff203 	ldbu	r2,-56(fp)
811388dc:	1000221e 	bne	r2,zero,81138968 <OSMutexDel+0x184>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811388e0:	e0bffd17 	ldw	r2,-12(fp)
811388e4:	00c00fc4 	movi	r3,63
811388e8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
811388ec:	e0bffd17 	ldw	r2,-12(fp)
811388f0:	10000485 	stb	zero,18(r2)
#endif
                 pip                 = (INT8U)(pevent->OSEventCnt >> 8);
811388f4:	e0bffd17 	ldw	r2,-12(fp)
811388f8:	1080020b 	ldhu	r2,8(r2)
811388fc:	10bfffcc 	andi	r2,r2,65535
81138900:	1004d23a 	srli	r2,r2,8
81138904:	e0bff605 	stb	r2,-40(fp)
                 OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
81138908:	e0fff603 	ldbu	r3,-40(fp)
8113890c:	00a045f4 	movhi	r2,33047
81138910:	10a10004 	addi	r2,r2,-31744
81138914:	18c7883a 	add	r3,r3,r3
81138918:	18c7883a 	add	r3,r3,r3
8113891c:	10c5883a 	add	r2,r2,r3
81138920:	10000015 	stw	zero,0(r2)
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81138924:	e0bffd17 	ldw	r2,-12(fp)
81138928:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
8113892c:	d0e09c17 	ldw	r3,-32144(gp)
81138930:	e0bffd17 	ldw	r2,-12(fp)
81138934:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
81138938:	e0bffd17 	ldw	r2,-12(fp)
8113893c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;
81138940:	e0bffd17 	ldw	r2,-12(fp)
81138944:	d0a09c15 	stw	r2,-32144(gp)
81138948:	e0bff417 	ldw	r2,-48(fp)
8113894c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138950:	e0bff517 	ldw	r2,-44(fp)
81138954:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
81138958:	e0bfff17 	ldw	r2,-4(fp)
8113895c:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
81138960:	e03ff315 	stw	zero,-52(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
81138964:	00005a06 	br	81138ad0 <OSMutexDel+0x2ec>
81138968:	e0bff417 	ldw	r2,-48(fp)
8113896c:	e0bff715 	stw	r2,-36(fp)
81138970:	e0bff717 	ldw	r2,-36(fp)
81138974:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
81138978:	e0bfff17 	ldw	r2,-4(fp)
8113897c:	00c01244 	movi	r3,73
81138980:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
81138984:	e0bffd17 	ldw	r2,-12(fp)
81138988:	e0bff315 	stw	r2,-52(fp)
             }
             break;
8113898c:	00005006 	br	81138ad0 <OSMutexDel+0x2ec>

        case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
             pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
81138990:	e0bffd17 	ldw	r2,-12(fp)
81138994:	1080020b 	ldhu	r2,8(r2)
81138998:	10bfffcc 	andi	r2,r2,65535
8113899c:	1004d23a 	srli	r2,r2,8
811389a0:	e0bff605 	stb	r2,-40(fp)
             prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
811389a4:	e0bffd17 	ldw	r2,-12(fp)
811389a8:	1080020b 	ldhu	r2,8(r2)
811389ac:	e0bff905 	stb	r2,-28(fp)
             ptcb = (OS_TCB *)pevent->OSEventPtr;
811389b0:	e0bffd17 	ldw	r2,-12(fp)
811389b4:	10800117 	ldw	r2,4(r2)
811389b8:	e0bffa15 	stw	r2,-24(fp)
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
811389bc:	e0bffa17 	ldw	r2,-24(fp)
811389c0:	10000f26 	beq	r2,zero,81138a00 <OSMutexDel+0x21c>
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
811389c4:	e0bffa17 	ldw	r2,-24(fp)
811389c8:	10800c83 	ldbu	r2,50(r2)
811389cc:	10c03fcc 	andi	r3,r2,255
811389d0:	e0bff603 	ldbu	r2,-40(fp)
811389d4:	18800a1e 	bne	r3,r2,81138a00 <OSMutexDel+0x21c>
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
811389d8:	e0bff903 	ldbu	r2,-28(fp)
811389dc:	100b883a 	mov	r5,r2
811389e0:	e13ffa17 	ldw	r4,-24(fp)
811389e4:	11394200 	call	81139420 <OSMutex_RdyAtPrio>
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
811389e8:	00000506 	br	81138a00 <OSMutexDel+0x21c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811389ec:	000f883a 	mov	r7,zero
811389f0:	01800404 	movi	r6,16
811389f4:	000b883a 	mov	r5,zero
811389f8:	e13ffd17 	ldw	r4,-12(fp)
811389fc:	11351880 	call	81135188 <OS_EventTaskRdy>
             if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
                 if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
                     OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
                 }
             }
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
81138a00:	e0bffd17 	ldw	r2,-12(fp)
81138a04:	10800283 	ldbu	r2,10(r2)
81138a08:	10803fcc 	andi	r2,r2,255
81138a0c:	103ff71e 	bne	r2,zero,811389ec <__reset+0xfb1189ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81138a10:	e0bffd17 	ldw	r2,-12(fp)
81138a14:	00c00fc4 	movi	r3,63
81138a18:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81138a1c:	e0bffd17 	ldw	r2,-12(fp)
81138a20:	10000485 	stb	zero,18(r2)
#endif
             pip                 = (INT8U)(pevent->OSEventCnt >> 8);
81138a24:	e0bffd17 	ldw	r2,-12(fp)
81138a28:	1080020b 	ldhu	r2,8(r2)
81138a2c:	10bfffcc 	andi	r2,r2,65535
81138a30:	1004d23a 	srli	r2,r2,8
81138a34:	e0bff605 	stb	r2,-40(fp)
             OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
81138a38:	e0fff603 	ldbu	r3,-40(fp)
81138a3c:	00a045f4 	movhi	r2,33047
81138a40:	10a10004 	addi	r2,r2,-31744
81138a44:	18c7883a 	add	r3,r3,r3
81138a48:	18c7883a 	add	r3,r3,r3
81138a4c:	10c5883a 	add	r2,r2,r3
81138a50:	10000015 	stw	zero,0(r2)
             pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
81138a54:	e0bffd17 	ldw	r2,-12(fp)
81138a58:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
81138a5c:	d0e09c17 	ldw	r3,-32144(gp)
81138a60:	e0bffd17 	ldw	r2,-12(fp)
81138a64:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt  = 0;
81138a68:	e0bffd17 	ldw	r2,-12(fp)
81138a6c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList     = pevent;                 /* Get next free event control block        */
81138a70:	e0bffd17 	ldw	r2,-12(fp)
81138a74:	d0a09c15 	stw	r2,-32144(gp)
81138a78:	e0bff417 	ldw	r2,-48(fp)
81138a7c:	e0bff815 	stw	r2,-32(fp)
81138a80:	e0bff817 	ldw	r2,-32(fp)
81138a84:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81138a88:	e0bff203 	ldbu	r2,-56(fp)
81138a8c:	10800058 	cmpnei	r2,r2,1
81138a90:	1000011e 	bne	r2,zero,81138a98 <OSMutexDel+0x2b4>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81138a94:	1135c440 	call	81135c44 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
81138a98:	e0bfff17 	ldw	r2,-4(fp)
81138a9c:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
81138aa0:	e03ff315 	stw	zero,-52(fp)
             break;
81138aa4:	00000a06 	br	81138ad0 <OSMutexDel+0x2ec>
81138aa8:	e0bff417 	ldw	r2,-48(fp)
81138aac:	e0bffb15 	stw	r2,-20(fp)
81138ab0:	e0bffb17 	ldw	r2,-20(fp)
81138ab4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
81138ab8:	e0bfff17 	ldw	r2,-4(fp)
81138abc:	00c001c4 	movi	r3,7
81138ac0:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
81138ac4:	e0bffd17 	ldw	r2,-12(fp)
81138ac8:	e0bff315 	stw	r2,-52(fp)
             break;
81138acc:	0001883a 	nop
    }
    return (pevent_return);
81138ad0:	e0bff317 	ldw	r2,-52(fp)
}
81138ad4:	e037883a 	mov	sp,fp
81138ad8:	dfc00117 	ldw	ra,4(sp)
81138adc:	df000017 	ldw	fp,0(sp)
81138ae0:	dec00204 	addi	sp,sp,8
81138ae4:	f800283a 	ret

81138ae8 <OSMutexPend>:
*              2) You MUST NOT change the priority of the task that owns the mutex
*********************************************************************************************************
*/

void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81138ae8:	deffee04 	addi	sp,sp,-72
81138aec:	de00012e 	bgeu	sp,et,81138af4 <OSMutexPend+0xc>
81138af0:	003b68fa 	trap	3
81138af4:	dfc01115 	stw	ra,68(sp)
81138af8:	df001015 	stw	fp,64(sp)
81138afc:	df001004 	addi	fp,sp,64
81138b00:	e13ffd15 	stw	r4,-12(fp)
81138b04:	2805883a 	mov	r2,r5
81138b08:	e1bfff15 	stw	r6,-4(fp)
81138b0c:	e0bffe0d 	sth	r2,-8(fp)
    BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    OS_TCB    *ptcb;
    OS_EVENT  *pevent2;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81138b10:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81138b14:	e0bfff17 	ldw	r2,-4(fp)
81138b18:	10015626 	beq	r2,zero,81139074 <OSMutexPend+0x58c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81138b1c:	e0bffd17 	ldw	r2,-12(fp)
81138b20:	1000041e 	bne	r2,zero,81138b34 <OSMutexPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
81138b24:	e0bfff17 	ldw	r2,-4(fp)
81138b28:	00c00104 	movi	r3,4
81138b2c:	10c00005 	stb	r3,0(r2)
        return;
81138b30:	00015106 	br	81139078 <OSMutexPend+0x590>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81138b34:	e0bffd17 	ldw	r2,-12(fp)
81138b38:	10800003 	ldbu	r2,0(r2)
81138b3c:	10803fcc 	andi	r2,r2,255
81138b40:	10800120 	cmpeqi	r2,r2,4
81138b44:	1000041e 	bne	r2,zero,81138b58 <OSMutexPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
81138b48:	e0bfff17 	ldw	r2,-4(fp)
81138b4c:	00c00044 	movi	r3,1
81138b50:	10c00005 	stb	r3,0(r2)
        return;
81138b54:	00014806 	br	81139078 <OSMutexPend+0x590>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81138b58:	d0a09d03 	ldbu	r2,-32140(gp)
81138b5c:	10803fcc 	andi	r2,r2,255
81138b60:	10000426 	beq	r2,zero,81138b74 <OSMutexPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
81138b64:	e0bfff17 	ldw	r2,-4(fp)
81138b68:	00c00084 	movi	r3,2
81138b6c:	10c00005 	stb	r3,0(r2)
        return;
81138b70:	00014106 	br	81139078 <OSMutexPend+0x590>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
81138b74:	d0a08b03 	ldbu	r2,-32212(gp)
81138b78:	10803fcc 	andi	r2,r2,255
81138b7c:	10000426 	beq	r2,zero,81138b90 <OSMutexPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
81138b80:	e0bfff17 	ldw	r2,-4(fp)
81138b84:	00c00344 	movi	r3,13
81138b88:	10c00005 	stb	r3,0(r2)
        return;
81138b8c:	00013a06 	br	81139078 <OSMutexPend+0x590>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138b90:	0005303a 	rdctl	r2,status
81138b94:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138b98:	e0fffc17 	ldw	r3,-16(fp)
81138b9c:	00bfff84 	movi	r2,-2
81138ba0:	1884703a 	and	r2,r3,r2
81138ba4:	1001703a 	wrctl	status,r2
  
  return context;
81138ba8:	e0bffc17 	ldw	r2,-16(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
81138bac:	e0bff115 	stw	r2,-60(fp)
    pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
81138bb0:	e0bffd17 	ldw	r2,-12(fp)
81138bb4:	1080020b 	ldhu	r2,8(r2)
81138bb8:	10bfffcc 	andi	r2,r2,65535
81138bbc:	1004d23a 	srli	r2,r2,8
81138bc0:	e0bff305 	stb	r2,-52(fp)
                                                           /* Is Mutex available?                      */
    if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
81138bc4:	e0bffd17 	ldw	r2,-12(fp)
81138bc8:	1080020b 	ldhu	r2,8(r2)
81138bcc:	10803fcc 	andi	r2,r2,255
81138bd0:	10803fd8 	cmpnei	r2,r2,255
81138bd4:	1000271e 	bne	r2,zero,81138c74 <OSMutexPend+0x18c>
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
81138bd8:	e0bffd17 	ldw	r2,-12(fp)
81138bdc:	10c0020b 	ldhu	r3,8(r2)
81138be0:	00bfc004 	movi	r2,-256
81138be4:	1884703a 	and	r2,r3,r2
81138be8:	1007883a 	mov	r3,r2
81138bec:	e0bffd17 	ldw	r2,-12(fp)
81138bf0:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
81138bf4:	e0bffd17 	ldw	r2,-12(fp)
81138bf8:	10c0020b 	ldhu	r3,8(r2)
81138bfc:	d0a09e17 	ldw	r2,-32136(gp)
81138c00:	10800c83 	ldbu	r2,50(r2)
81138c04:	10803fcc 	andi	r2,r2,255
81138c08:	1884b03a 	or	r2,r3,r2
81138c0c:	1007883a 	mov	r3,r2
81138c10:	e0bffd17 	ldw	r2,-12(fp)
81138c14:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
81138c18:	d0e09e17 	ldw	r3,-32136(gp)
81138c1c:	e0bffd17 	ldw	r2,-12(fp)
81138c20:	10c00115 	stw	r3,4(r2)
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
81138c24:	d0a09e17 	ldw	r2,-32136(gp)
81138c28:	10800c83 	ldbu	r2,50(r2)
81138c2c:	10803fcc 	andi	r2,r2,255
81138c30:	e0fff303 	ldbu	r3,-52(fp)
81138c34:	18800836 	bltu	r3,r2,81138c58 <OSMutexPend+0x170>
81138c38:	e0bff117 	ldw	r2,-60(fp)
81138c3c:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81138c40:	e0bff217 	ldw	r2,-56(fp)
81138c44:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
81138c48:	e0bfff17 	ldw	r2,-4(fp)
81138c4c:	00c01e04 	movi	r3,120
81138c50:	10c00005 	stb	r3,0(r2)
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
        }
        return;
81138c54:	00010806 	br	81139078 <OSMutexPend+0x590>
81138c58:	e0bff117 	ldw	r2,-60(fp)
81138c5c:	e0bff415 	stw	r2,-48(fp)
81138c60:	e0bff417 	ldw	r2,-48(fp)
81138c64:	1001703a 	wrctl	status,r2
        if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
            OS_EXIT_CRITICAL();                            /*      ... than current task!              */
            *perr = OS_ERR_PIP_LOWER;
        } else {
            OS_EXIT_CRITICAL();
            *perr = OS_ERR_NONE;
81138c68:	e0bfff17 	ldw	r2,-4(fp)
81138c6c:	10000005 	stb	zero,0(r2)
        }
        return;
81138c70:	00010106 	br	81139078 <OSMutexPend+0x590>
    }
    mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
81138c74:	e0bffd17 	ldw	r2,-12(fp)
81138c78:	1080020b 	ldhu	r2,8(r2)
81138c7c:	e0bff605 	stb	r2,-40(fp)
    ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
81138c80:	e0bffd17 	ldw	r2,-12(fp)
81138c84:	10800117 	ldw	r2,4(r2)
81138c88:	e0bff715 	stw	r2,-36(fp)
    if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
81138c8c:	e0bff717 	ldw	r2,-36(fp)
81138c90:	10800c83 	ldbu	r2,50(r2)
81138c94:	10803fcc 	andi	r2,r2,255
81138c98:	e0fff303 	ldbu	r3,-52(fp)
81138c9c:	1880b92e 	bgeu	r3,r2,81138f84 <OSMutexPend+0x49c>
        if (mprio > OSTCBCur->OSTCBPrio) {
81138ca0:	d0a09e17 	ldw	r2,-32136(gp)
81138ca4:	10800c83 	ldbu	r2,50(r2)
81138ca8:	10c03fcc 	andi	r3,r2,255
81138cac:	e0bff603 	ldbu	r2,-40(fp)
81138cb0:	1880b42e 	bgeu	r3,r2,81138f84 <OSMutexPend+0x49c>
            y = ptcb->OSTCBY;
81138cb4:	e0bff717 	ldw	r2,-36(fp)
81138cb8:	10800d03 	ldbu	r2,52(r2)
81138cbc:	e0bff805 	stb	r2,-32(fp)
            if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
81138cc0:	e0fff803 	ldbu	r3,-32(fp)
81138cc4:	d0a09a44 	addi	r2,gp,-32151
81138cc8:	1885883a 	add	r2,r3,r2
81138ccc:	10c00003 	ldbu	r3,0(r2)
81138cd0:	e0bff717 	ldw	r2,-36(fp)
81138cd4:	10800d43 	ldbu	r2,53(r2)
81138cd8:	1884703a 	and	r2,r3,r2
81138cdc:	10803fcc 	andi	r2,r2,255
81138ce0:	10001e26 	beq	r2,zero,81138d5c <OSMutexPend+0x274>
                OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
81138ce4:	e0fff803 	ldbu	r3,-32(fp)
81138ce8:	e13ff803 	ldbu	r4,-32(fp)
81138cec:	d0a09a44 	addi	r2,gp,-32151
81138cf0:	2085883a 	add	r2,r4,r2
81138cf4:	10800003 	ldbu	r2,0(r2)
81138cf8:	1009883a 	mov	r4,r2
81138cfc:	e0bff717 	ldw	r2,-36(fp)
81138d00:	10800d43 	ldbu	r2,53(r2)
81138d04:	0084303a 	nor	r2,zero,r2
81138d08:	2084703a 	and	r2,r4,r2
81138d0c:	1009883a 	mov	r4,r2
81138d10:	d0a09a44 	addi	r2,gp,-32151
81138d14:	1885883a 	add	r2,r3,r2
81138d18:	11000005 	stb	r4,0(r2)
                if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
81138d1c:	e0fff803 	ldbu	r3,-32(fp)
81138d20:	d0a09a44 	addi	r2,gp,-32151
81138d24:	1885883a 	add	r2,r3,r2
81138d28:	10800003 	ldbu	r2,0(r2)
81138d2c:	10803fcc 	andi	r2,r2,255
81138d30:	1000071e 	bne	r2,zero,81138d50 <OSMutexPend+0x268>
                    OSRdyGrp &= ~ptcb->OSTCBBitY;
81138d34:	e0bff717 	ldw	r2,-36(fp)
81138d38:	10800d83 	ldbu	r2,54(r2)
81138d3c:	0084303a 	nor	r2,zero,r2
81138d40:	1007883a 	mov	r3,r2
81138d44:	d0a09a03 	ldbu	r2,-32152(gp)
81138d48:	1884703a 	and	r2,r3,r2
81138d4c:	d0a09a05 	stb	r2,-32152(gp)
                }
                rdy = OS_TRUE;
81138d50:	00800044 	movi	r2,1
81138d54:	e0bff005 	stb	r2,-64(fp)
81138d58:	00002a06 	br	81138e04 <OSMutexPend+0x31c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81138d5c:	e0bff717 	ldw	r2,-36(fp)
81138d60:	10800717 	ldw	r2,28(r2)
81138d64:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
81138d68:	e0bff917 	ldw	r2,-28(fp)
81138d6c:	10002426 	beq	r2,zero,81138e00 <OSMutexPend+0x318>
                    if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
81138d70:	e0bff717 	ldw	r2,-36(fp)
81138d74:	10800d03 	ldbu	r2,52(r2)
81138d78:	10803fcc 	andi	r2,r2,255
81138d7c:	e0fff717 	ldw	r3,-36(fp)
81138d80:	18c00d03 	ldbu	r3,52(r3)
81138d84:	18c03fcc 	andi	r3,r3,255
81138d88:	e13ff917 	ldw	r4,-28(fp)
81138d8c:	20c7883a 	add	r3,r4,r3
81138d90:	18c002c4 	addi	r3,r3,11
81138d94:	18c00003 	ldbu	r3,0(r3)
81138d98:	1809883a 	mov	r4,r3
81138d9c:	e0fff717 	ldw	r3,-36(fp)
81138da0:	18c00d43 	ldbu	r3,53(r3)
81138da4:	00c6303a 	nor	r3,zero,r3
81138da8:	20c6703a 	and	r3,r4,r3
81138dac:	1809883a 	mov	r4,r3
81138db0:	e0fff917 	ldw	r3,-28(fp)
81138db4:	1887883a 	add	r3,r3,r2
81138db8:	18c002c4 	addi	r3,r3,11
81138dbc:	19000005 	stb	r4,0(r3)
81138dc0:	e0fff917 	ldw	r3,-28(fp)
81138dc4:	1885883a 	add	r2,r3,r2
81138dc8:	108002c4 	addi	r2,r2,11
81138dcc:	10800003 	ldbu	r2,0(r2)
81138dd0:	10803fcc 	andi	r2,r2,255
81138dd4:	10000a1e 	bne	r2,zero,81138e00 <OSMutexPend+0x318>
                        pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
81138dd8:	e0bff917 	ldw	r2,-28(fp)
81138ddc:	10800283 	ldbu	r2,10(r2)
81138de0:	1007883a 	mov	r3,r2
81138de4:	e0bff717 	ldw	r2,-36(fp)
81138de8:	10800d83 	ldbu	r2,54(r2)
81138dec:	0084303a 	nor	r2,zero,r2
81138df0:	1884703a 	and	r2,r3,r2
81138df4:	1007883a 	mov	r3,r2
81138df8:	e0bff917 	ldw	r2,-28(fp)
81138dfc:	10c00285 	stb	r3,10(r2)
                    }
                }
                rdy = OS_FALSE;                            /* No                                       */
81138e00:	e03ff005 	stb	zero,-64(fp)
            }
            ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
81138e04:	e0bff717 	ldw	r2,-36(fp)
81138e08:	e0fff303 	ldbu	r3,-52(fp)
81138e0c:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
            ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
81138e10:	e0bff717 	ldw	r2,-36(fp)
81138e14:	10800c83 	ldbu	r2,50(r2)
81138e18:	10803fcc 	andi	r2,r2,255
81138e1c:	1004d0fa 	srli	r2,r2,3
81138e20:	1007883a 	mov	r3,r2
81138e24:	e0bff717 	ldw	r2,-36(fp)
81138e28:	10c00d05 	stb	r3,52(r2)
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
81138e2c:	e0bff717 	ldw	r2,-36(fp)
81138e30:	10800c83 	ldbu	r2,50(r2)
81138e34:	108001cc 	andi	r2,r2,7
81138e38:	1007883a 	mov	r3,r2
81138e3c:	e0bff717 	ldw	r2,-36(fp)
81138e40:	10c00cc5 	stb	r3,51(r2)
            ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
81138e44:	e0bff717 	ldw	r2,-36(fp)
81138e48:	10800d03 	ldbu	r2,52(r2)
81138e4c:	10803fcc 	andi	r2,r2,255
81138e50:	00c00044 	movi	r3,1
81138e54:	1884983a 	sll	r2,r3,r2
81138e58:	1007883a 	mov	r3,r2
81138e5c:	e0bff717 	ldw	r2,-36(fp)
81138e60:	10c00d85 	stb	r3,54(r2)
            ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
81138e64:	e0bff717 	ldw	r2,-36(fp)
81138e68:	10800cc3 	ldbu	r2,51(r2)
81138e6c:	10803fcc 	andi	r2,r2,255
81138e70:	00c00044 	movi	r3,1
81138e74:	1884983a 	sll	r2,r3,r2
81138e78:	1007883a 	mov	r3,r2
81138e7c:	e0bff717 	ldw	r2,-36(fp)
81138e80:	10c00d45 	stb	r3,53(r2)
            ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
            ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
            ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
            ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
#endif
            if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
81138e84:	e0bff003 	ldbu	r2,-64(fp)
81138e88:	10800058 	cmpnei	r2,r2,1
81138e8c:	1000161e 	bne	r2,zero,81138ee8 <OSMutexPend+0x400>
                OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
81138e90:	e0bff717 	ldw	r2,-36(fp)
81138e94:	10c00d83 	ldbu	r3,54(r2)
81138e98:	d0a09a03 	ldbu	r2,-32152(gp)
81138e9c:	1884b03a 	or	r2,r3,r2
81138ea0:	d0a09a05 	stb	r2,-32152(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138ea4:	e0bff717 	ldw	r2,-36(fp)
81138ea8:	10800d03 	ldbu	r2,52(r2)
81138eac:	10c03fcc 	andi	r3,r2,255
81138eb0:	e0bff717 	ldw	r2,-36(fp)
81138eb4:	10800d03 	ldbu	r2,52(r2)
81138eb8:	11003fcc 	andi	r4,r2,255
81138ebc:	d0a09a44 	addi	r2,gp,-32151
81138ec0:	2085883a 	add	r2,r4,r2
81138ec4:	11000003 	ldbu	r4,0(r2)
81138ec8:	e0bff717 	ldw	r2,-36(fp)
81138ecc:	10800d43 	ldbu	r2,53(r2)
81138ed0:	2084b03a 	or	r2,r4,r2
81138ed4:	1009883a 	mov	r4,r2
81138ed8:	d0a09a44 	addi	r2,gp,-32151
81138edc:	1885883a 	add	r2,r3,r2
81138ee0:	11000005 	stb	r4,0(r2)
81138ee4:	00001f06 	br	81138f64 <OSMutexPend+0x47c>
            } else {
                pevent2 = ptcb->OSTCBEventPtr;
81138ee8:	e0bff717 	ldw	r2,-36(fp)
81138eec:	10800717 	ldw	r2,28(r2)
81138ef0:	e0bff915 	stw	r2,-28(fp)
                if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
81138ef4:	e0bff917 	ldw	r2,-28(fp)
81138ef8:	10001a26 	beq	r2,zero,81138f64 <OSMutexPend+0x47c>
                    pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
81138efc:	e0bff917 	ldw	r2,-28(fp)
81138f00:	10c00283 	ldbu	r3,10(r2)
81138f04:	e0bff717 	ldw	r2,-36(fp)
81138f08:	10800d83 	ldbu	r2,54(r2)
81138f0c:	1884b03a 	or	r2,r3,r2
81138f10:	1007883a 	mov	r3,r2
81138f14:	e0bff917 	ldw	r2,-28(fp)
81138f18:	10c00285 	stb	r3,10(r2)
                    pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81138f1c:	e0bff717 	ldw	r2,-36(fp)
81138f20:	10800d03 	ldbu	r2,52(r2)
81138f24:	10803fcc 	andi	r2,r2,255
81138f28:	e0fff717 	ldw	r3,-36(fp)
81138f2c:	18c00d03 	ldbu	r3,52(r3)
81138f30:	18c03fcc 	andi	r3,r3,255
81138f34:	e13ff917 	ldw	r4,-28(fp)
81138f38:	20c7883a 	add	r3,r4,r3
81138f3c:	18c002c4 	addi	r3,r3,11
81138f40:	19000003 	ldbu	r4,0(r3)
81138f44:	e0fff717 	ldw	r3,-36(fp)
81138f48:	18c00d43 	ldbu	r3,53(r3)
81138f4c:	20c6b03a 	or	r3,r4,r3
81138f50:	1809883a 	mov	r4,r3
81138f54:	e0fff917 	ldw	r3,-28(fp)
81138f58:	1885883a 	add	r2,r3,r2
81138f5c:	108002c4 	addi	r2,r2,11
81138f60:	11000005 	stb	r4,0(r2)
                }
            }
            OSTCBPrioTbl[pip] = ptcb;
81138f64:	e0fff303 	ldbu	r3,-52(fp)
81138f68:	00a045f4 	movhi	r2,33047
81138f6c:	10a10004 	addi	r2,r2,-31744
81138f70:	18c7883a 	add	r3,r3,r3
81138f74:	18c7883a 	add	r3,r3,r3
81138f78:	10c5883a 	add	r2,r2,r3
81138f7c:	e0fff717 	ldw	r3,-36(fp)
81138f80:	10c00015 	stw	r3,0(r2)
        }
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
81138f84:	d0a09e17 	ldw	r2,-32136(gp)
81138f88:	d0e09e17 	ldw	r3,-32136(gp)
81138f8c:	18c00c03 	ldbu	r3,48(r3)
81138f90:	18c00414 	ori	r3,r3,16
81138f94:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81138f98:	d0a09e17 	ldw	r2,-32136(gp)
81138f9c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
81138fa0:	d0a09e17 	ldw	r2,-32136(gp)
81138fa4:	e0fffe0b 	ldhu	r3,-8(fp)
81138fa8:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
81138fac:	e13ffd17 	ldw	r4,-12(fp)
81138fb0:	11353280 	call	81135328 <OS_EventTaskWait>
81138fb4:	e0bff117 	ldw	r2,-60(fp)
81138fb8:	e0bffb15 	stw	r2,-20(fp)
81138fbc:	e0bffb17 	ldw	r2,-20(fp)
81138fc0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
81138fc4:	1135c440 	call	81135c44 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81138fc8:	0005303a 	rdctl	r2,status
81138fcc:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81138fd0:	e0fff517 	ldw	r3,-44(fp)
81138fd4:	00bfff84 	movi	r2,-2
81138fd8:	1884703a 	and	r2,r3,r2
81138fdc:	1001703a 	wrctl	status,r2
  
  return context;
81138fe0:	e0bff517 	ldw	r2,-44(fp)
    OS_ENTER_CRITICAL();
81138fe4:	e0bff115 	stw	r2,-60(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81138fe8:	d0a09e17 	ldw	r2,-32136(gp)
81138fec:	10800c43 	ldbu	r2,49(r2)
81138ff0:	10803fcc 	andi	r2,r2,255
81138ff4:	10000326 	beq	r2,zero,81139004 <OSMutexPend+0x51c>
81138ff8:	108000a0 	cmpeqi	r2,r2,2
81138ffc:	1000041e 	bne	r2,zero,81139010 <OSMutexPend+0x528>
81139000:	00000706 	br	81139020 <OSMutexPend+0x538>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
81139004:	e0bfff17 	ldw	r2,-4(fp)
81139008:	10000005 	stb	zero,0(r2)
             break;
8113900c:	00000c06 	br	81139040 <OSMutexPend+0x558>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
81139010:	e0bfff17 	ldw	r2,-4(fp)
81139014:	00c00384 	movi	r3,14
81139018:	10c00005 	stb	r3,0(r2)
             break;
8113901c:	00000806 	br	81139040 <OSMutexPend+0x558>
             
        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81139020:	d0a09e17 	ldw	r2,-32136(gp)
81139024:	e17ffd17 	ldw	r5,-12(fp)
81139028:	1009883a 	mov	r4,r2
8113902c:	11355980 	call	81135598 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
81139030:	e0bfff17 	ldw	r2,-4(fp)
81139034:	00c00284 	movi	r3,10
81139038:	10c00005 	stb	r3,0(r2)
             break;
8113903c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81139040:	d0a09e17 	ldw	r2,-32136(gp)
81139044:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81139048:	d0a09e17 	ldw	r2,-32136(gp)
8113904c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81139050:	d0a09e17 	ldw	r2,-32136(gp)
81139054:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81139058:	d0a09e17 	ldw	r2,-32136(gp)
8113905c:	10000815 	stw	zero,32(r2)
81139060:	e0bff117 	ldw	r2,-60(fp)
81139064:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139068:	e0bffa17 	ldw	r2,-24(fp)
8113906c:	1001703a 	wrctl	status,r2
81139070:	00000106 	br	81139078 <OSMutexPend+0x590>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
        return;
81139074:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
81139078:	e037883a 	mov	sp,fp
8113907c:	dfc00117 	ldw	ra,4(sp)
81139080:	df000017 	ldw	fp,0(sp)
81139084:	dec00204 	addi	sp,sp,8
81139088:	f800283a 	ret

8113908c <OSMutexPost>:
*                                      what tasks will be using the Mutex.
*********************************************************************************************************
*/

INT8U  OSMutexPost (OS_EVENT *pevent)
{
8113908c:	defff604 	addi	sp,sp,-40
81139090:	de00012e 	bgeu	sp,et,81139098 <OSMutexPost+0xc>
81139094:	003b68fa 	trap	3
81139098:	dfc00915 	stw	ra,36(sp)
8113909c:	df000815 	stw	fp,32(sp)
811390a0:	df000804 	addi	fp,sp,32
811390a4:	e13fff15 	stw	r4,-4(fp)
    INT8U      pip;                                   /* Priority inheritance priority                 */
    INT8U      prio;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
811390a8:	e03ff815 	stw	zero,-32(fp)
#endif



    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
811390ac:	d0a09d03 	ldbu	r2,-32140(gp)
811390b0:	10803fcc 	andi	r2,r2,255
811390b4:	10000226 	beq	r2,zero,811390c0 <OSMutexPost+0x34>
        return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
811390b8:	00800144 	movi	r2,5
811390bc:	00007606 	br	81139298 <OSMutexPost+0x20c>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
811390c0:	e0bfff17 	ldw	r2,-4(fp)
811390c4:	1000021e 	bne	r2,zero,811390d0 <OSMutexPost+0x44>
        return (OS_ERR_PEVENT_NULL);
811390c8:	00800104 	movi	r2,4
811390cc:	00007206 	br	81139298 <OSMutexPost+0x20c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
811390d0:	e0bfff17 	ldw	r2,-4(fp)
811390d4:	10800003 	ldbu	r2,0(r2)
811390d8:	10803fcc 	andi	r2,r2,255
811390dc:	10800120 	cmpeqi	r2,r2,4
811390e0:	1000021e 	bne	r2,zero,811390ec <OSMutexPost+0x60>
        return (OS_ERR_EVENT_TYPE);
811390e4:	00800044 	movi	r2,1
811390e8:	00006b06 	br	81139298 <OSMutexPost+0x20c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811390ec:	0005303a 	rdctl	r2,status
811390f0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811390f4:	e0fffe17 	ldw	r3,-8(fp)
811390f8:	00bfff84 	movi	r2,-2
811390fc:	1884703a 	and	r2,r3,r2
81139100:	1001703a 	wrctl	status,r2
  
  return context;
81139104:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
81139108:	e0bff815 	stw	r2,-32(fp)
    pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
8113910c:	e0bfff17 	ldw	r2,-4(fp)
81139110:	1080020b 	ldhu	r2,8(r2)
81139114:	10bfffcc 	andi	r2,r2,65535
81139118:	1004d23a 	srli	r2,r2,8
8113911c:	e0bffa05 	stb	r2,-24(fp)
    prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
81139120:	e0bfff17 	ldw	r2,-4(fp)
81139124:	1080020b 	ldhu	r2,8(r2)
81139128:	e0bffa45 	stb	r2,-23(fp)
    if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
8113912c:	e0bfff17 	ldw	r2,-4(fp)
81139130:	10c00117 	ldw	r3,4(r2)
81139134:	d0a09e17 	ldw	r2,-32136(gp)
81139138:	18800626 	beq	r3,r2,81139154 <OSMutexPost+0xc8>
8113913c:	e0bff817 	ldw	r2,-32(fp)
81139140:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139144:	e0bff917 	ldw	r2,-28(fp)
81139148:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NOT_MUTEX_OWNER);
8113914c:	00801904 	movi	r2,100
81139150:	00005106 	br	81139298 <OSMutexPost+0x20c>
    }
    if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
81139154:	d0a09e17 	ldw	r2,-32136(gp)
81139158:	10800c83 	ldbu	r2,50(r2)
8113915c:	10c03fcc 	andi	r3,r2,255
81139160:	e0bffa03 	ldbu	r2,-24(fp)
81139164:	1880051e 	bne	r3,r2,8113917c <OSMutexPost+0xf0>
        OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
81139168:	d0a09e17 	ldw	r2,-32136(gp)
8113916c:	e0fffa43 	ldbu	r3,-23(fp)
81139170:	180b883a 	mov	r5,r3
81139174:	1009883a 	mov	r4,r2
81139178:	11394200 	call	81139420 <OSMutex_RdyAtPrio>
    }
    OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
8113917c:	e0fffa03 	ldbu	r3,-24(fp)
81139180:	00a045f4 	movhi	r2,33047
81139184:	10a10004 	addi	r2,r2,-31744
81139188:	18c7883a 	add	r3,r3,r3
8113918c:	18c7883a 	add	r3,r3,r3
81139190:	10c5883a 	add	r2,r2,r3
81139194:	00c00044 	movi	r3,1
81139198:	10c00015 	stw	r3,0(r2)
    if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
8113919c:	e0bfff17 	ldw	r2,-4(fp)
811391a0:	10800283 	ldbu	r2,10(r2)
811391a4:	10803fcc 	andi	r2,r2,255
811391a8:	10002e26 	beq	r2,zero,81139264 <OSMutexPost+0x1d8>
                                                      /* Yes, Make HPT waiting for mutex ready         */
        prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
811391ac:	000f883a 	mov	r7,zero
811391b0:	01800404 	movi	r6,16
811391b4:	000b883a 	mov	r5,zero
811391b8:	e13fff17 	ldw	r4,-4(fp)
811391bc:	11351880 	call	81135188 <OS_EventTaskRdy>
811391c0:	e0bffa45 	stb	r2,-23(fp)
        pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
811391c4:	e0bfff17 	ldw	r2,-4(fp)
811391c8:	10c0020b 	ldhu	r3,8(r2)
811391cc:	00bfc004 	movi	r2,-256
811391d0:	1884703a 	and	r2,r3,r2
811391d4:	1007883a 	mov	r3,r2
811391d8:	e0bfff17 	ldw	r2,-4(fp)
811391dc:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventCnt |= prio;
811391e0:	e0bfff17 	ldw	r2,-4(fp)
811391e4:	10c0020b 	ldhu	r3,8(r2)
811391e8:	e0bffa43 	ldbu	r2,-23(fp)
811391ec:	1884b03a 	or	r2,r3,r2
811391f0:	1007883a 	mov	r3,r2
811391f4:	e0bfff17 	ldw	r2,-4(fp)
811391f8:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
811391fc:	e0fffa43 	ldbu	r3,-23(fp)
81139200:	00a045f4 	movhi	r2,33047
81139204:	10a10004 	addi	r2,r2,-31744
81139208:	18c7883a 	add	r3,r3,r3
8113920c:	18c7883a 	add	r3,r3,r3
81139210:	10c5883a 	add	r2,r2,r3
81139214:	10c00017 	ldw	r3,0(r2)
81139218:	e0bfff17 	ldw	r2,-4(fp)
8113921c:	10c00115 	stw	r3,4(r2)
        if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
81139220:	e0bffa43 	ldbu	r2,-23(fp)
81139224:	e0fffa03 	ldbu	r3,-24(fp)
81139228:	18800736 	bltu	r3,r2,81139248 <OSMutexPost+0x1bc>
8113922c:	e0bff817 	ldw	r2,-32(fp)
81139230:	e0bffb15 	stw	r2,-20(fp)
81139234:	e0bffb17 	ldw	r2,-20(fp)
81139238:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
            OS_Sched();                               /*      Find highest priority task ready to run  */
8113923c:	1135c440 	call	81135c44 <OS_Sched>
            return (OS_ERR_PIP_LOWER);
81139240:	00801e04 	movi	r2,120
81139244:	00001406 	br	81139298 <OSMutexPost+0x20c>
81139248:	e0bff817 	ldw	r2,-32(fp)
8113924c:	e0bffc15 	stw	r2,-16(fp)
81139250:	e0bffc17 	ldw	r2,-16(fp)
81139254:	1001703a 	wrctl	status,r2
        } else {
            OS_EXIT_CRITICAL();
            OS_Sched();                               /*      Find highest priority task ready to run  */
81139258:	1135c440 	call	81135c44 <OS_Sched>
            return (OS_ERR_NONE);
8113925c:	0005883a 	mov	r2,zero
81139260:	00000d06 	br	81139298 <OSMutexPost+0x20c>
        }
    }
    pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
81139264:	e0bfff17 	ldw	r2,-4(fp)
81139268:	1080020b 	ldhu	r2,8(r2)
8113926c:	10803fd4 	ori	r2,r2,255
81139270:	1007883a 	mov	r3,r2
81139274:	e0bfff17 	ldw	r2,-4(fp)
81139278:	10c0020d 	sth	r3,8(r2)
    pevent->OSEventPtr  = (void *)0;
8113927c:	e0bfff17 	ldw	r2,-4(fp)
81139280:	10000115 	stw	zero,4(r2)
81139284:	e0bff817 	ldw	r2,-32(fp)
81139288:	e0bffd15 	stw	r2,-12(fp)
8113928c:	e0bffd17 	ldw	r2,-12(fp)
81139290:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139294:	0005883a 	mov	r2,zero
}
81139298:	e037883a 	mov	sp,fp
8113929c:	dfc00117 	ldw	ra,4(sp)
811392a0:	df000017 	ldw	fp,0(sp)
811392a4:	dec00204 	addi	sp,sp,8
811392a8:	f800283a 	ret

811392ac <OSMutexQuery>:
*********************************************************************************************************
*/

#if OS_MUTEX_QUERY_EN > 0
INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
{
811392ac:	defff704 	addi	sp,sp,-36
811392b0:	de00012e 	bgeu	sp,et,811392b8 <OSMutexQuery+0xc>
811392b4:	003b68fa 	trap	3
811392b8:	df000815 	stw	fp,32(sp)
811392bc:	df000804 	addi	fp,sp,32
811392c0:	e13ffe15 	stw	r4,-8(fp)
811392c4:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811392c8:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
811392cc:	d0a09d03 	ldbu	r2,-32140(gp)
811392d0:	10803fcc 	andi	r2,r2,255
811392d4:	10000226 	beq	r2,zero,811392e0 <OSMutexQuery+0x34>
        return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
811392d8:	00800184 	movi	r2,6
811392dc:	00004c06 	br	81139410 <OSMutexQuery+0x164>
    }
#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811392e0:	e0bffe17 	ldw	r2,-8(fp)
811392e4:	1000021e 	bne	r2,zero,811392f0 <OSMutexQuery+0x44>
        return (OS_ERR_PEVENT_NULL);
811392e8:	00800104 	movi	r2,4
811392ec:	00004806 	br	81139410 <OSMutexQuery+0x164>
    }
    if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
811392f0:	e0bfff17 	ldw	r2,-4(fp)
811392f4:	1000021e 	bne	r2,zero,81139300 <OSMutexQuery+0x54>
        return (OS_ERR_PDATA_NULL);
811392f8:	00800244 	movi	r2,9
811392fc:	00004406 	br	81139410 <OSMutexQuery+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
81139300:	e0bffe17 	ldw	r2,-8(fp)
81139304:	10800003 	ldbu	r2,0(r2)
81139308:	10803fcc 	andi	r2,r2,255
8113930c:	10800120 	cmpeqi	r2,r2,4
81139310:	1000021e 	bne	r2,zero,8113931c <OSMutexQuery+0x70>
        return (OS_ERR_EVENT_TYPE);
81139314:	00800044 	movi	r2,1
81139318:	00003d06 	br	81139410 <OSMutexQuery+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113931c:	0005303a 	rdctl	r2,status
81139320:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139324:	e0fffd17 	ldw	r3,-12(fp)
81139328:	00bfff84 	movi	r2,-2
8113932c:	1884703a 	and	r2,r3,r2
81139330:	1001703a 	wrctl	status,r2
  
  return context;
81139334:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139338:	e0bffb15 	stw	r2,-20(fp)
    p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
8113933c:	e0bffe17 	ldw	r2,-8(fp)
81139340:	1080020b 	ldhu	r2,8(r2)
81139344:	10bfffcc 	andi	r2,r2,65535
81139348:	1004d23a 	srli	r2,r2,8
8113934c:	1007883a 	mov	r3,r2
81139350:	e0bfff17 	ldw	r2,-4(fp)
81139354:	10c00245 	stb	r3,9(r2)
    p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
81139358:	e0bffe17 	ldw	r2,-8(fp)
8113935c:	1080020b 	ldhu	r2,8(r2)
81139360:	1007883a 	mov	r3,r2
81139364:	e0bfff17 	ldw	r2,-4(fp)
81139368:	10c00205 	stb	r3,8(r2)
    if (p_mutex_data->OSOwnerPrio == 0xFF) {
8113936c:	e0bfff17 	ldw	r2,-4(fp)
81139370:	10800203 	ldbu	r2,8(r2)
81139374:	10803fcc 	andi	r2,r2,255
81139378:	10803fd8 	cmpnei	r2,r2,255
8113937c:	1000041e 	bne	r2,zero,81139390 <OSMutexQuery+0xe4>
        p_mutex_data->OSValue = OS_TRUE;
81139380:	e0bfff17 	ldw	r2,-4(fp)
81139384:	00c00044 	movi	r3,1
81139388:	10c001c5 	stb	r3,7(r2)
8113938c:	00000206 	br	81139398 <OSMutexQuery+0xec>
    } else {
        p_mutex_data->OSValue = OS_FALSE;
81139390:	e0bfff17 	ldw	r2,-4(fp)
81139394:	100001c5 	stb	zero,7(r2)
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
81139398:	e0bffe17 	ldw	r2,-8(fp)
8113939c:	10c00283 	ldbu	r3,10(r2)
811393a0:	e0bfff17 	ldw	r2,-4(fp)
811393a4:	10c00185 	stb	r3,6(r2)
    psrc                      = &pevent->OSEventTbl[0];
811393a8:	e0bffe17 	ldw	r2,-8(fp)
811393ac:	108002c4 	addi	r2,r2,11
811393b0:	e0bff915 	stw	r2,-28(fp)
    pdest                     = &p_mutex_data->OSEventTbl[0];
811393b4:	e0bfff17 	ldw	r2,-4(fp)
811393b8:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811393bc:	e03ff805 	stb	zero,-32(fp)
811393c0:	00000b06 	br	811393f0 <OSMutexQuery+0x144>
        *pdest++ = *psrc++;
811393c4:	e0bffa17 	ldw	r2,-24(fp)
811393c8:	10c00044 	addi	r3,r2,1
811393cc:	e0fffa15 	stw	r3,-24(fp)
811393d0:	e0fff917 	ldw	r3,-28(fp)
811393d4:	19000044 	addi	r4,r3,1
811393d8:	e13ff915 	stw	r4,-28(fp)
811393dc:	18c00003 	ldbu	r3,0(r3)
811393e0:	10c00005 	stb	r3,0(r2)
        p_mutex_data->OSValue = OS_FALSE;
    }
    p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
    psrc                      = &pevent->OSEventTbl[0];
    pdest                     = &p_mutex_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
811393e4:	e0bff803 	ldbu	r2,-32(fp)
811393e8:	10800044 	addi	r2,r2,1
811393ec:	e0bff805 	stb	r2,-32(fp)
811393f0:	e0bff803 	ldbu	r2,-32(fp)
811393f4:	108001b0 	cmpltui	r2,r2,6
811393f8:	103ff21e 	bne	r2,zero,811393c4 <__reset+0xfb1193c4>
811393fc:	e0bffb17 	ldw	r2,-20(fp)
81139400:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139404:	e0bffc17 	ldw	r2,-16(fp)
81139408:	1001703a 	wrctl	status,r2
        *pdest++ = *psrc++;
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113940c:	0005883a 	mov	r2,zero
}
81139410:	e037883a 	mov	sp,fp
81139414:	df000017 	ldw	fp,0(sp)
81139418:	dec00104 	addi	sp,sp,4
8113941c:	f800283a 	ret

81139420 <OSMutex_RdyAtPrio>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
{
81139420:	defffc04 	addi	sp,sp,-16
81139424:	de00012e 	bgeu	sp,et,8113942c <OSMutex_RdyAtPrio+0xc>
81139428:	003b68fa 	trap	3
8113942c:	df000315 	stw	fp,12(sp)
81139430:	df000304 	addi	fp,sp,12
81139434:	e13ffe15 	stw	r4,-8(fp)
81139438:	2805883a 	mov	r2,r5
8113943c:	e0bfff05 	stb	r2,-4(fp)
    INT8U   y;


    y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
81139440:	e0bffe17 	ldw	r2,-8(fp)
81139444:	10800d03 	ldbu	r2,52(r2)
81139448:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
8113944c:	e0fffd03 	ldbu	r3,-12(fp)
81139450:	e13ffd03 	ldbu	r4,-12(fp)
81139454:	d0a09a44 	addi	r2,gp,-32151
81139458:	2085883a 	add	r2,r4,r2
8113945c:	10800003 	ldbu	r2,0(r2)
81139460:	1009883a 	mov	r4,r2
81139464:	e0bffe17 	ldw	r2,-8(fp)
81139468:	10800d43 	ldbu	r2,53(r2)
8113946c:	0084303a 	nor	r2,zero,r2
81139470:	2084703a 	and	r2,r4,r2
81139474:	1009883a 	mov	r4,r2
81139478:	d0a09a44 	addi	r2,gp,-32151
8113947c:	1885883a 	add	r2,r3,r2
81139480:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
81139484:	e0fffd03 	ldbu	r3,-12(fp)
81139488:	d0a09a44 	addi	r2,gp,-32151
8113948c:	1885883a 	add	r2,r3,r2
81139490:	10800003 	ldbu	r2,0(r2)
81139494:	10803fcc 	andi	r2,r2,255
81139498:	1000071e 	bne	r2,zero,811394b8 <OSMutex_RdyAtPrio+0x98>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113949c:	e0bffe17 	ldw	r2,-8(fp)
811394a0:	10800d83 	ldbu	r2,54(r2)
811394a4:	0084303a 	nor	r2,zero,r2
811394a8:	1007883a 	mov	r3,r2
811394ac:	d0a09a03 	ldbu	r2,-32152(gp)
811394b0:	1884703a 	and	r2,r3,r2
811394b4:	d0a09a05 	stb	r2,-32152(gp)
    }
    ptcb->OSTCBPrio         = prio;
811394b8:	e0bffe17 	ldw	r2,-8(fp)
811394bc:	e0ffff03 	ldbu	r3,-4(fp)
811394c0:	10c00c85 	stb	r3,50(r2)
#if OS_LOWEST_PRIO <= 63
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
811394c4:	e0bfff03 	ldbu	r2,-4(fp)
811394c8:	1004d0fa 	srli	r2,r2,3
811394cc:	108001cc 	andi	r2,r2,7
811394d0:	1007883a 	mov	r3,r2
811394d4:	e0bffe17 	ldw	r2,-8(fp)
811394d8:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
811394dc:	e0bfff03 	ldbu	r2,-4(fp)
811394e0:	108001cc 	andi	r2,r2,7
811394e4:	1007883a 	mov	r3,r2
811394e8:	e0bffe17 	ldw	r2,-8(fp)
811394ec:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
811394f0:	e0bffe17 	ldw	r2,-8(fp)
811394f4:	10800d03 	ldbu	r2,52(r2)
811394f8:	10803fcc 	andi	r2,r2,255
811394fc:	00c00044 	movi	r3,1
81139500:	1884983a 	sll	r2,r3,r2
81139504:	1007883a 	mov	r3,r2
81139508:	e0bffe17 	ldw	r2,-8(fp)
8113950c:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
81139510:	e0bffe17 	ldw	r2,-8(fp)
81139514:	10800cc3 	ldbu	r2,51(r2)
81139518:	10803fcc 	andi	r2,r2,255
8113951c:	00c00044 	movi	r3,1
81139520:	1884983a 	sll	r2,r3,r2
81139524:	1007883a 	mov	r3,r2
81139528:	e0bffe17 	ldw	r2,-8(fp)
8113952c:	10c00d45 	stb	r3,53(r2)
    ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
#endif
    OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
81139530:	e0bffe17 	ldw	r2,-8(fp)
81139534:	10c00d83 	ldbu	r3,54(r2)
81139538:	d0a09a03 	ldbu	r2,-32152(gp)
8113953c:	1884b03a 	or	r2,r3,r2
81139540:	d0a09a05 	stb	r2,-32152(gp)
    OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
81139544:	e0bffe17 	ldw	r2,-8(fp)
81139548:	10800d03 	ldbu	r2,52(r2)
8113954c:	10c03fcc 	andi	r3,r2,255
81139550:	e0bffe17 	ldw	r2,-8(fp)
81139554:	10800d03 	ldbu	r2,52(r2)
81139558:	11003fcc 	andi	r4,r2,255
8113955c:	d0a09a44 	addi	r2,gp,-32151
81139560:	2085883a 	add	r2,r4,r2
81139564:	11000003 	ldbu	r4,0(r2)
81139568:	e0bffe17 	ldw	r2,-8(fp)
8113956c:	10800d43 	ldbu	r2,53(r2)
81139570:	2084b03a 	or	r2,r4,r2
81139574:	1009883a 	mov	r4,r2
81139578:	d0a09a44 	addi	r2,gp,-32151
8113957c:	1885883a 	add	r2,r3,r2
81139580:	11000005 	stb	r4,0(r2)
    OSTCBPrioTbl[prio]      = ptcb;
81139584:	e0ffff03 	ldbu	r3,-4(fp)
81139588:	00a045f4 	movhi	r2,33047
8113958c:	10a10004 	addi	r2,r2,-31744
81139590:	18c7883a 	add	r3,r3,r3
81139594:	18c7883a 	add	r3,r3,r3
81139598:	10c5883a 	add	r2,r2,r3
8113959c:	e0fffe17 	ldw	r3,-8(fp)
811395a0:	10c00015 	stw	r3,0(r2)
}
811395a4:	0001883a 	nop
811395a8:	e037883a 	mov	sp,fp
811395ac:	df000017 	ldw	fp,0(sp)
811395b0:	dec00104 	addi	sp,sp,4
811395b4:	f800283a 	ret

811395b8 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
811395b8:	defff804 	addi	sp,sp,-32
811395bc:	de00012e 	bgeu	sp,et,811395c4 <OSQAccept+0xc>
811395c0:	003b68fa 	trap	3
811395c4:	df000715 	stw	fp,28(sp)
811395c8:	df000704 	addi	fp,sp,28
811395cc:	e13ffe15 	stw	r4,-8(fp)
811395d0:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
811395d4:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
811395d8:	e0bfff17 	ldw	r2,-4(fp)
811395dc:	1000021e 	bne	r2,zero,811395e8 <OSQAccept+0x30>
        return ((void *)0);
811395e0:	0005883a 	mov	r2,zero
811395e4:	00004206 	br	811396f0 <OSQAccept+0x138>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
811395e8:	e0bffe17 	ldw	r2,-8(fp)
811395ec:	1000051e 	bne	r2,zero,81139604 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
811395f0:	e0bfff17 	ldw	r2,-4(fp)
811395f4:	00c00104 	movi	r3,4
811395f8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
811395fc:	0005883a 	mov	r2,zero
81139600:	00003b06 	br	811396f0 <OSQAccept+0x138>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81139604:	e0bffe17 	ldw	r2,-8(fp)
81139608:	10800003 	ldbu	r2,0(r2)
8113960c:	10803fcc 	andi	r2,r2,255
81139610:	108000a0 	cmpeqi	r2,r2,2
81139614:	1000051e 	bne	r2,zero,8113962c <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
81139618:	e0bfff17 	ldw	r2,-4(fp)
8113961c:	00c00044 	movi	r3,1
81139620:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139624:	0005883a 	mov	r2,zero
81139628:	00003106 	br	811396f0 <OSQAccept+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113962c:	0005303a 	rdctl	r2,status
81139630:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139634:	e0fffd17 	ldw	r3,-12(fp)
81139638:	00bfff84 	movi	r2,-2
8113963c:	1884703a 	and	r2,r3,r2
81139640:	1001703a 	wrctl	status,r2
  
  return context;
81139644:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139648:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
8113964c:	e0bffe17 	ldw	r2,-8(fp)
81139650:	10800117 	ldw	r2,4(r2)
81139654:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81139658:	e0bffc17 	ldw	r2,-16(fp)
8113965c:	1080058b 	ldhu	r2,22(r2)
81139660:	10bfffcc 	andi	r2,r2,65535
81139664:	10001926 	beq	r2,zero,811396cc <OSQAccept+0x114>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81139668:	e0bffc17 	ldw	r2,-16(fp)
8113966c:	10800417 	ldw	r2,16(r2)
81139670:	11000104 	addi	r4,r2,4
81139674:	e0fffc17 	ldw	r3,-16(fp)
81139678:	19000415 	stw	r4,16(r3)
8113967c:	10800017 	ldw	r2,0(r2)
81139680:	e0bff915 	stw	r2,-28(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81139684:	e0bffc17 	ldw	r2,-16(fp)
81139688:	1080058b 	ldhu	r2,22(r2)
8113968c:	10bfffc4 	addi	r2,r2,-1
81139690:	1007883a 	mov	r3,r2
81139694:	e0bffc17 	ldw	r2,-16(fp)
81139698:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
8113969c:	e0bffc17 	ldw	r2,-16(fp)
811396a0:	10c00417 	ldw	r3,16(r2)
811396a4:	e0bffc17 	ldw	r2,-16(fp)
811396a8:	10800217 	ldw	r2,8(r2)
811396ac:	1880041e 	bne	r3,r2,811396c0 <OSQAccept+0x108>
            pq->OSQOut = pq->OSQStart;
811396b0:	e0bffc17 	ldw	r2,-16(fp)
811396b4:	10c00117 	ldw	r3,4(r2)
811396b8:	e0bffc17 	ldw	r2,-16(fp)
811396bc:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
811396c0:	e0bfff17 	ldw	r2,-4(fp)
811396c4:	10000005 	stb	zero,0(r2)
811396c8:	00000406 	br	811396dc <OSQAccept+0x124>
    } else {
        *perr = OS_ERR_Q_EMPTY;
811396cc:	e0bfff17 	ldw	r2,-4(fp)
811396d0:	00c007c4 	movi	r3,31
811396d4:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
811396d8:	e03ff915 	stw	zero,-28(fp)
811396dc:	e0bffa17 	ldw	r2,-24(fp)
811396e0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811396e4:	e0bffb17 	ldw	r2,-20(fp)
811396e8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
811396ec:	e0bff917 	ldw	r2,-28(fp)
}
811396f0:	e037883a 	mov	sp,fp
811396f4:	df000017 	ldw	fp,0(sp)
811396f8:	dec00104 	addi	sp,sp,4
811396fc:	f800283a 	ret

81139700 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
81139700:	defff404 	addi	sp,sp,-48
81139704:	de00012e 	bgeu	sp,et,8113970c <OSQCreate+0xc>
81139708:	003b68fa 	trap	3
8113970c:	dfc00b15 	stw	ra,44(sp)
81139710:	df000a15 	stw	fp,40(sp)
81139714:	df000a04 	addi	fp,sp,40
81139718:	e13ffe15 	stw	r4,-8(fp)
8113971c:	2805883a 	mov	r2,r5
81139720:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139724:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81139728:	d0a09d03 	ldbu	r2,-32140(gp)
8113972c:	10803fcc 	andi	r2,r2,255
81139730:	10000226 	beq	r2,zero,8113973c <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
81139734:	0005883a 	mov	r2,zero
81139738:	00005906 	br	811398a0 <OSQCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113973c:	0005303a 	rdctl	r2,status
81139740:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139744:	e0fffd17 	ldw	r3,-12(fp)
81139748:	00bfff84 	movi	r2,-2
8113974c:	1884703a 	and	r2,r3,r2
81139750:	1001703a 	wrctl	status,r2
  
  return context;
81139754:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
81139758:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
8113975c:	d0a09c17 	ldw	r2,-32144(gp)
81139760:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
81139764:	d0a09c17 	ldw	r2,-32144(gp)
81139768:	10000326 	beq	r2,zero,81139778 <OSQCreate+0x78>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113976c:	d0a09c17 	ldw	r2,-32144(gp)
81139770:	10800117 	ldw	r2,4(r2)
81139774:	d0a09c15 	stw	r2,-32144(gp)
81139778:	e0bff717 	ldw	r2,-36(fp)
8113977c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139780:	e0bff817 	ldw	r2,-32(fp)
81139784:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
81139788:	e0bff617 	ldw	r2,-40(fp)
8113978c:	10004326 	beq	r2,zero,8113989c <OSQCreate+0x19c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139790:	0005303a 	rdctl	r2,status
81139794:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139798:	e0fff917 	ldw	r3,-28(fp)
8113979c:	00bfff84 	movi	r2,-2
811397a0:	1884703a 	and	r2,r3,r2
811397a4:	1001703a 	wrctl	status,r2
  
  return context;
811397a8:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();
811397ac:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
811397b0:	d0a09917 	ldw	r2,-32156(gp)
811397b4:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
811397b8:	e0bffb17 	ldw	r2,-20(fp)
811397bc:	10002d26 	beq	r2,zero,81139874 <OSQCreate+0x174>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
811397c0:	d0a09917 	ldw	r2,-32156(gp)
811397c4:	10800017 	ldw	r2,0(r2)
811397c8:	d0a09915 	stw	r2,-32156(gp)
811397cc:	e0bff717 	ldw	r2,-36(fp)
811397d0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
811397d4:	e0bffa17 	ldw	r2,-24(fp)
811397d8:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
811397dc:	e0bffb17 	ldw	r2,-20(fp)
811397e0:	e0fffe17 	ldw	r3,-8(fp)
811397e4:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
811397e8:	e0bfff0b 	ldhu	r2,-4(fp)
811397ec:	1085883a 	add	r2,r2,r2
811397f0:	1085883a 	add	r2,r2,r2
811397f4:	1007883a 	mov	r3,r2
811397f8:	e0bffe17 	ldw	r2,-8(fp)
811397fc:	10c7883a 	add	r3,r2,r3
81139800:	e0bffb17 	ldw	r2,-20(fp)
81139804:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
81139808:	e0bffb17 	ldw	r2,-20(fp)
8113980c:	e0fffe17 	ldw	r3,-8(fp)
81139810:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
81139814:	e0bffb17 	ldw	r2,-20(fp)
81139818:	e0fffe17 	ldw	r3,-8(fp)
8113981c:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
81139820:	e0bffb17 	ldw	r2,-20(fp)
81139824:	e0ffff0b 	ldhu	r3,-4(fp)
81139828:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
8113982c:	e0bffb17 	ldw	r2,-20(fp)
81139830:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
81139834:	e0bff617 	ldw	r2,-40(fp)
81139838:	00c00084 	movi	r3,2
8113983c:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
81139840:	e0bff617 	ldw	r2,-40(fp)
81139844:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
81139848:	e0bff617 	ldw	r2,-40(fp)
8113984c:	e0fffb17 	ldw	r3,-20(fp)
81139850:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
81139854:	e0bff617 	ldw	r2,-40(fp)
81139858:	00c00fc4 	movi	r3,63
8113985c:	10c00445 	stb	r3,17(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
81139860:	e0bff617 	ldw	r2,-40(fp)
81139864:	10000485 	stb	zero,18(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
81139868:	e13ff617 	ldw	r4,-40(fp)
8113986c:	11357600 	call	81135760 <OS_EventWaitListInit>
81139870:	00000a06 	br	8113989c <OSQCreate+0x19c>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
81139874:	d0e09c17 	ldw	r3,-32144(gp)
81139878:	e0bff617 	ldw	r2,-40(fp)
8113987c:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
81139880:	e0bff617 	ldw	r2,-40(fp)
81139884:	d0a09c15 	stw	r2,-32144(gp)
81139888:	e0bff717 	ldw	r2,-36(fp)
8113988c:	e0bffc15 	stw	r2,-16(fp)
81139890:	e0bffc17 	ldw	r2,-16(fp)
81139894:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
81139898:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
8113989c:	e0bff617 	ldw	r2,-40(fp)
}
811398a0:	e037883a 	mov	sp,fp
811398a4:	dfc00117 	ldw	ra,4(sp)
811398a8:	df000017 	ldw	fp,0(sp)
811398ac:	dec00204 	addi	sp,sp,8
811398b0:	f800283a 	ret

811398b4 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
811398b4:	defff204 	addi	sp,sp,-56
811398b8:	de00012e 	bgeu	sp,et,811398c0 <OSQDel+0xc>
811398bc:	003b68fa 	trap	3
811398c0:	dfc00d15 	stw	ra,52(sp)
811398c4:	df000c15 	stw	fp,48(sp)
811398c8:	df000c04 	addi	fp,sp,48
811398cc:	e13ffd15 	stw	r4,-12(fp)
811398d0:	2805883a 	mov	r2,r5
811398d4:	e1bfff15 	stw	r6,-4(fp)
811398d8:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
811398dc:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
811398e0:	e0bfff17 	ldw	r2,-4(fp)
811398e4:	1000021e 	bne	r2,zero,811398f0 <OSQDel+0x3c>
        return (pevent);
811398e8:	e0bffd17 	ldw	r2,-12(fp)
811398ec:	00008e06 	br	81139b28 <OSQDel+0x274>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
811398f0:	e0bffd17 	ldw	r2,-12(fp)
811398f4:	1000051e 	bne	r2,zero,8113990c <OSQDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
811398f8:	e0bfff17 	ldw	r2,-4(fp)
811398fc:	00c00104 	movi	r3,4
81139900:	10c00005 	stb	r3,0(r2)
        return (pevent);
81139904:	e0bffd17 	ldw	r2,-12(fp)
81139908:	00008706 	br	81139b28 <OSQDel+0x274>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
8113990c:	e0bffd17 	ldw	r2,-12(fp)
81139910:	10800003 	ldbu	r2,0(r2)
81139914:	10803fcc 	andi	r2,r2,255
81139918:	108000a0 	cmpeqi	r2,r2,2
8113991c:	1000051e 	bne	r2,zero,81139934 <OSQDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139920:	e0bfff17 	ldw	r2,-4(fp)
81139924:	00c00044 	movi	r3,1
81139928:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113992c:	e0bffd17 	ldw	r2,-12(fp)
81139930:	00007d06 	br	81139b28 <OSQDel+0x274>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
81139934:	d0a09d03 	ldbu	r2,-32140(gp)
81139938:	10803fcc 	andi	r2,r2,255
8113993c:	10000526 	beq	r2,zero,81139954 <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
81139940:	e0bfff17 	ldw	r2,-4(fp)
81139944:	00c003c4 	movi	r3,15
81139948:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113994c:	e0bffd17 	ldw	r2,-12(fp)
81139950:	00007506 	br	81139b28 <OSQDel+0x274>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139954:	0005303a 	rdctl	r2,status
81139958:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113995c:	e0fffc17 	ldw	r3,-16(fp)
81139960:	00bfff84 	movi	r2,-2
81139964:	1884703a 	and	r2,r3,r2
81139968:	1001703a 	wrctl	status,r2
  
  return context;
8113996c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139970:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
81139974:	e0bffd17 	ldw	r2,-12(fp)
81139978:	10800283 	ldbu	r2,10(r2)
8113997c:	10803fcc 	andi	r2,r2,255
81139980:	10000326 	beq	r2,zero,81139990 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
81139984:	00800044 	movi	r2,1
81139988:	e0bff405 	stb	r2,-48(fp)
8113998c:	00000106 	br	81139994 <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
81139990:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
81139994:	e0bffe03 	ldbu	r2,-8(fp)
81139998:	10000326 	beq	r2,zero,811399a8 <OSQDel+0xf4>
8113999c:	10800060 	cmpeqi	r2,r2,1
811399a0:	1000301e 	bne	r2,zero,81139a64 <OSQDel+0x1b0>
811399a4:	00005506 	br	81139afc <OSQDel+0x248>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
811399a8:	e0bff403 	ldbu	r2,-48(fp)
811399ac:	10001e1e 	bne	r2,zero,81139a28 <OSQDel+0x174>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
811399b0:	e0bffd17 	ldw	r2,-12(fp)
811399b4:	00c00fc4 	movi	r3,63
811399b8:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
811399bc:	e0bffd17 	ldw	r2,-12(fp)
811399c0:	10000485 	stb	zero,18(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
811399c4:	e0bffd17 	ldw	r2,-12(fp)
811399c8:	10800117 	ldw	r2,4(r2)
811399cc:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
811399d0:	d0e09917 	ldw	r3,-32156(gp)
811399d4:	e0bff817 	ldw	r2,-32(fp)
811399d8:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
811399dc:	e0bff817 	ldw	r2,-32(fp)
811399e0:	d0a09915 	stw	r2,-32156(gp)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
811399e4:	e0bffd17 	ldw	r2,-12(fp)
811399e8:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
811399ec:	d0e09c17 	ldw	r3,-32144(gp)
811399f0:	e0bffd17 	ldw	r2,-12(fp)
811399f4:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
811399f8:	e0bffd17 	ldw	r2,-12(fp)
811399fc:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
81139a00:	e0bffd17 	ldw	r2,-12(fp)
81139a04:	d0a09c15 	stw	r2,-32144(gp)
81139a08:	e0bff617 	ldw	r2,-40(fp)
81139a0c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139a10:	e0bff717 	ldw	r2,-36(fp)
81139a14:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
81139a18:	e0bfff17 	ldw	r2,-4(fp)
81139a1c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
81139a20:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
81139a24:	00003f06 	br	81139b24 <OSQDel+0x270>
81139a28:	e0bff617 	ldw	r2,-40(fp)
81139a2c:	e0bff915 	stw	r2,-28(fp)
81139a30:	e0bff917 	ldw	r2,-28(fp)
81139a34:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
81139a38:	e0bfff17 	ldw	r2,-4(fp)
81139a3c:	00c01244 	movi	r3,73
81139a40:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
81139a44:	e0bffd17 	ldw	r2,-12(fp)
81139a48:	e0bff515 	stw	r2,-44(fp)
             }
             break;
81139a4c:	00003506 	br	81139b24 <OSQDel+0x270>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
81139a50:	000f883a 	mov	r7,zero
81139a54:	01800104 	movi	r6,4
81139a58:	000b883a 	mov	r5,zero
81139a5c:	e13ffd17 	ldw	r4,-12(fp)
81139a60:	11351880 	call	81135188 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
81139a64:	e0bffd17 	ldw	r2,-12(fp)
81139a68:	10800283 	ldbu	r2,10(r2)
81139a6c:	10803fcc 	andi	r2,r2,255
81139a70:	103ff71e 	bne	r2,zero,81139a50 <__reset+0xfb119a50>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
81139a74:	e0bffd17 	ldw	r2,-12(fp)
81139a78:	00c00fc4 	movi	r3,63
81139a7c:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
81139a80:	e0bffd17 	ldw	r2,-12(fp)
81139a84:	10000485 	stb	zero,18(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
81139a88:	e0bffd17 	ldw	r2,-12(fp)
81139a8c:	10800117 	ldw	r2,4(r2)
81139a90:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
81139a94:	d0e09917 	ldw	r3,-32156(gp)
81139a98:	e0bff817 	ldw	r2,-32(fp)
81139a9c:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
81139aa0:	e0bff817 	ldw	r2,-32(fp)
81139aa4:	d0a09915 	stw	r2,-32156(gp)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
81139aa8:	e0bffd17 	ldw	r2,-12(fp)
81139aac:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
81139ab0:	d0e09c17 	ldw	r3,-32144(gp)
81139ab4:	e0bffd17 	ldw	r2,-12(fp)
81139ab8:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
81139abc:	e0bffd17 	ldw	r2,-12(fp)
81139ac0:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
81139ac4:	e0bffd17 	ldw	r2,-12(fp)
81139ac8:	d0a09c15 	stw	r2,-32144(gp)
81139acc:	e0bff617 	ldw	r2,-40(fp)
81139ad0:	e0bffa15 	stw	r2,-24(fp)
81139ad4:	e0bffa17 	ldw	r2,-24(fp)
81139ad8:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
81139adc:	e0bff403 	ldbu	r2,-48(fp)
81139ae0:	10800058 	cmpnei	r2,r2,1
81139ae4:	1000011e 	bne	r2,zero,81139aec <OSQDel+0x238>
                 OS_Sched();                               /* Find highest priority task ready to run  */
81139ae8:	1135c440 	call	81135c44 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
81139aec:	e0bfff17 	ldw	r2,-4(fp)
81139af0:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
81139af4:	e03ff515 	stw	zero,-44(fp)
             break;
81139af8:	00000a06 	br	81139b24 <OSQDel+0x270>
81139afc:	e0bff617 	ldw	r2,-40(fp)
81139b00:	e0bffb15 	stw	r2,-20(fp)
81139b04:	e0bffb17 	ldw	r2,-20(fp)
81139b08:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
81139b0c:	e0bfff17 	ldw	r2,-4(fp)
81139b10:	00c001c4 	movi	r3,7
81139b14:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
81139b18:	e0bffd17 	ldw	r2,-12(fp)
81139b1c:	e0bff515 	stw	r2,-44(fp)
             break;
81139b20:	0001883a 	nop
    }
    return (pevent_return);
81139b24:	e0bff517 	ldw	r2,-44(fp)
}
81139b28:	e037883a 	mov	sp,fp
81139b2c:	dfc00117 	ldw	ra,4(sp)
81139b30:	df000017 	ldw	fp,0(sp)
81139b34:	dec00204 	addi	sp,sp,8
81139b38:	f800283a 	ret

81139b3c <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
81139b3c:	defffa04 	addi	sp,sp,-24
81139b40:	de00012e 	bgeu	sp,et,81139b48 <OSQFlush+0xc>
81139b44:	003b68fa 	trap	3
81139b48:	df000515 	stw	fp,20(sp)
81139b4c:	df000504 	addi	fp,sp,20
81139b50:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
81139b54:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
81139b58:	e0bfff17 	ldw	r2,-4(fp)
81139b5c:	1000021e 	bne	r2,zero,81139b68 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
81139b60:	00800104 	movi	r2,4
81139b64:	00002106 	br	81139bec <OSQFlush+0xb0>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
81139b68:	e0bfff17 	ldw	r2,-4(fp)
81139b6c:	10800003 	ldbu	r2,0(r2)
81139b70:	10803fcc 	andi	r2,r2,255
81139b74:	108000a0 	cmpeqi	r2,r2,2
81139b78:	1000021e 	bne	r2,zero,81139b84 <OSQFlush+0x48>
        return (OS_ERR_EVENT_TYPE);
81139b7c:	00800044 	movi	r2,1
81139b80:	00001a06 	br	81139bec <OSQFlush+0xb0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139b84:	0005303a 	rdctl	r2,status
81139b88:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139b8c:	e0fffd17 	ldw	r3,-12(fp)
81139b90:	00bfff84 	movi	r2,-2
81139b94:	1884703a 	and	r2,r3,r2
81139b98:	1001703a 	wrctl	status,r2
  
  return context;
81139b9c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
81139ba0:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
81139ba4:	e0bfff17 	ldw	r2,-4(fp)
81139ba8:	10800117 	ldw	r2,4(r2)
81139bac:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
81139bb0:	e0bffc17 	ldw	r2,-16(fp)
81139bb4:	10c00117 	ldw	r3,4(r2)
81139bb8:	e0bffc17 	ldw	r2,-16(fp)
81139bbc:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
81139bc0:	e0bffc17 	ldw	r2,-16(fp)
81139bc4:	10c00117 	ldw	r3,4(r2)
81139bc8:	e0bffc17 	ldw	r2,-16(fp)
81139bcc:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
81139bd0:	e0bffc17 	ldw	r2,-16(fp)
81139bd4:	1000058d 	sth	zero,22(r2)
81139bd8:	e0bffb17 	ldw	r2,-20(fp)
81139bdc:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139be0:	e0bffe17 	ldw	r2,-8(fp)
81139be4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
81139be8:	0005883a 	mov	r2,zero
}
81139bec:	e037883a 	mov	sp,fp
81139bf0:	df000017 	ldw	fp,0(sp)
81139bf4:	dec00104 	addi	sp,sp,4
81139bf8:	f800283a 	ret

81139bfc <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
81139bfc:	defff304 	addi	sp,sp,-52
81139c00:	de00012e 	bgeu	sp,et,81139c08 <OSQPend+0xc>
81139c04:	003b68fa 	trap	3
81139c08:	dfc00c15 	stw	ra,48(sp)
81139c0c:	df000b15 	stw	fp,44(sp)
81139c10:	df000b04 	addi	fp,sp,44
81139c14:	e13ffd15 	stw	r4,-12(fp)
81139c18:	2805883a 	mov	r2,r5
81139c1c:	e1bfff15 	stw	r6,-4(fp)
81139c20:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
81139c24:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
81139c28:	e0bfff17 	ldw	r2,-4(fp)
81139c2c:	1000021e 	bne	r2,zero,81139c38 <OSQPend+0x3c>
        return ((void *)0);
81139c30:	0005883a 	mov	r2,zero
81139c34:	00009106 	br	81139e7c <OSQPend+0x280>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
81139c38:	e0bffd17 	ldw	r2,-12(fp)
81139c3c:	1000051e 	bne	r2,zero,81139c54 <OSQPend+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139c40:	e0bfff17 	ldw	r2,-4(fp)
81139c44:	00c00104 	movi	r3,4
81139c48:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139c4c:	0005883a 	mov	r2,zero
81139c50:	00008a06 	br	81139e7c <OSQPend+0x280>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
81139c54:	e0bffd17 	ldw	r2,-12(fp)
81139c58:	10800003 	ldbu	r2,0(r2)
81139c5c:	10803fcc 	andi	r2,r2,255
81139c60:	108000a0 	cmpeqi	r2,r2,2
81139c64:	1000051e 	bne	r2,zero,81139c7c <OSQPend+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139c68:	e0bfff17 	ldw	r2,-4(fp)
81139c6c:	00c00044 	movi	r3,1
81139c70:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139c74:	0005883a 	mov	r2,zero
81139c78:	00008006 	br	81139e7c <OSQPend+0x280>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
81139c7c:	d0a09d03 	ldbu	r2,-32140(gp)
81139c80:	10803fcc 	andi	r2,r2,255
81139c84:	10000526 	beq	r2,zero,81139c9c <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
81139c88:	e0bfff17 	ldw	r2,-4(fp)
81139c8c:	00c00084 	movi	r3,2
81139c90:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139c94:	0005883a 	mov	r2,zero
81139c98:	00007806 	br	81139e7c <OSQPend+0x280>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
81139c9c:	d0a08b03 	ldbu	r2,-32212(gp)
81139ca0:	10803fcc 	andi	r2,r2,255
81139ca4:	10000526 	beq	r2,zero,81139cbc <OSQPend+0xc0>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
81139ca8:	e0bfff17 	ldw	r2,-4(fp)
81139cac:	00c00344 	movi	r3,13
81139cb0:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
81139cb4:	0005883a 	mov	r2,zero
81139cb8:	00007006 	br	81139e7c <OSQPend+0x280>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139cbc:	0005303a 	rdctl	r2,status
81139cc0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139cc4:	e0fffc17 	ldw	r3,-16(fp)
81139cc8:	00bfff84 	movi	r2,-2
81139ccc:	1884703a 	and	r2,r3,r2
81139cd0:	1001703a 	wrctl	status,r2
  
  return context;
81139cd4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139cd8:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
81139cdc:	e0bffd17 	ldw	r2,-12(fp)
81139ce0:	10800117 	ldw	r2,4(r2)
81139ce4:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
81139ce8:	e0bff817 	ldw	r2,-32(fp)
81139cec:	1080058b 	ldhu	r2,22(r2)
81139cf0:	10bfffcc 	andi	r2,r2,65535
81139cf4:	10001e26 	beq	r2,zero,81139d70 <OSQPend+0x174>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
81139cf8:	e0bff817 	ldw	r2,-32(fp)
81139cfc:	10800417 	ldw	r2,16(r2)
81139d00:	11000104 	addi	r4,r2,4
81139d04:	e0fff817 	ldw	r3,-32(fp)
81139d08:	19000415 	stw	r4,16(r3)
81139d0c:	10800017 	ldw	r2,0(r2)
81139d10:	e0bff515 	stw	r2,-44(fp)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
81139d14:	e0bff817 	ldw	r2,-32(fp)
81139d18:	1080058b 	ldhu	r2,22(r2)
81139d1c:	10bfffc4 	addi	r2,r2,-1
81139d20:	1007883a 	mov	r3,r2
81139d24:	e0bff817 	ldw	r2,-32(fp)
81139d28:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
81139d2c:	e0bff817 	ldw	r2,-32(fp)
81139d30:	10c00417 	ldw	r3,16(r2)
81139d34:	e0bff817 	ldw	r2,-32(fp)
81139d38:	10800217 	ldw	r2,8(r2)
81139d3c:	1880041e 	bne	r3,r2,81139d50 <OSQPend+0x154>
            pq->OSQOut = pq->OSQStart;
81139d40:	e0bff817 	ldw	r2,-32(fp)
81139d44:	10c00117 	ldw	r3,4(r2)
81139d48:	e0bff817 	ldw	r2,-32(fp)
81139d4c:	10c00415 	stw	r3,16(r2)
81139d50:	e0bff617 	ldw	r2,-40(fp)
81139d54:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139d58:	e0bff717 	ldw	r2,-36(fp)
81139d5c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
81139d60:	e0bfff17 	ldw	r2,-4(fp)
81139d64:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
81139d68:	e0bff517 	ldw	r2,-44(fp)
81139d6c:	00004306 	br	81139e7c <OSQPend+0x280>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
81139d70:	d0a09e17 	ldw	r2,-32136(gp)
81139d74:	d0e09e17 	ldw	r3,-32136(gp)
81139d78:	18c00c03 	ldbu	r3,48(r3)
81139d7c:	18c00114 	ori	r3,r3,4
81139d80:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
81139d84:	d0a09e17 	ldw	r2,-32136(gp)
81139d88:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
81139d8c:	d0a09e17 	ldw	r2,-32136(gp)
81139d90:	e0fffe0b 	ldhu	r3,-8(fp)
81139d94:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
81139d98:	e13ffd17 	ldw	r4,-12(fp)
81139d9c:	11353280 	call	81135328 <OS_EventTaskWait>
81139da0:	e0bff617 	ldw	r2,-40(fp)
81139da4:	e0bffb15 	stw	r2,-20(fp)
81139da8:	e0bffb17 	ldw	r2,-20(fp)
81139dac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
81139db0:	1135c440 	call	81135c44 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139db4:	0005303a 	rdctl	r2,status
81139db8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139dbc:	e0fff917 	ldw	r3,-28(fp)
81139dc0:	00bfff84 	movi	r2,-2
81139dc4:	1884703a 	and	r2,r3,r2
81139dc8:	1001703a 	wrctl	status,r2
  
  return context;
81139dcc:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
81139dd0:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
81139dd4:	d0a09e17 	ldw	r2,-32136(gp)
81139dd8:	10800c43 	ldbu	r2,49(r2)
81139ddc:	10803fcc 	andi	r2,r2,255
81139de0:	10000326 	beq	r2,zero,81139df0 <OSQPend+0x1f4>
81139de4:	108000a0 	cmpeqi	r2,r2,2
81139de8:	1000071e 	bne	r2,zero,81139e08 <OSQPend+0x20c>
81139dec:	00000b06 	br	81139e1c <OSQPend+0x220>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
81139df0:	d0a09e17 	ldw	r2,-32136(gp)
81139df4:	10800917 	ldw	r2,36(r2)
81139df8:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
81139dfc:	e0bfff17 	ldw	r2,-4(fp)
81139e00:	10000005 	stb	zero,0(r2)
             break;
81139e04:	00000e06 	br	81139e40 <OSQPend+0x244>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
81139e08:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
81139e0c:	e0bfff17 	ldw	r2,-4(fp)
81139e10:	00c00384 	movi	r3,14
81139e14:	10c00005 	stb	r3,0(r2)
             break;
81139e18:	00000906 	br	81139e40 <OSQPend+0x244>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
81139e1c:	d0a09e17 	ldw	r2,-32136(gp)
81139e20:	e17ffd17 	ldw	r5,-12(fp)
81139e24:	1009883a 	mov	r4,r2
81139e28:	11355980 	call	81135598 <OS_EventTaskRemove>
             pmsg = (void *)0;
81139e2c:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
81139e30:	e0bfff17 	ldw	r2,-4(fp)
81139e34:	00c00284 	movi	r3,10
81139e38:	10c00005 	stb	r3,0(r2)
             break;
81139e3c:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
81139e40:	d0a09e17 	ldw	r2,-32136(gp)
81139e44:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
81139e48:	d0a09e17 	ldw	r2,-32136(gp)
81139e4c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
81139e50:	d0a09e17 	ldw	r2,-32136(gp)
81139e54:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
81139e58:	d0a09e17 	ldw	r2,-32136(gp)
81139e5c:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
81139e60:	d0a09e17 	ldw	r2,-32136(gp)
81139e64:	10000915 	stw	zero,36(r2)
81139e68:	e0bff617 	ldw	r2,-40(fp)
81139e6c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139e70:	e0bffa17 	ldw	r2,-24(fp)
81139e74:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
81139e78:	e0bff517 	ldw	r2,-44(fp)
}
81139e7c:	e037883a 	mov	sp,fp
81139e80:	dfc00117 	ldw	ra,4(sp)
81139e84:	df000017 	ldw	fp,0(sp)
81139e88:	dec00204 	addi	sp,sp,8
81139e8c:	f800283a 	ret

81139e90 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
81139e90:	defff604 	addi	sp,sp,-40
81139e94:	de00012e 	bgeu	sp,et,81139e9c <OSQPendAbort+0xc>
81139e98:	003b68fa 	trap	3
81139e9c:	dfc00915 	stw	ra,36(sp)
81139ea0:	df000815 	stw	fp,32(sp)
81139ea4:	df000804 	addi	fp,sp,32
81139ea8:	e13ffd15 	stw	r4,-12(fp)
81139eac:	2805883a 	mov	r2,r5
81139eb0:	e1bfff15 	stw	r6,-4(fp)
81139eb4:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
81139eb8:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
81139ebc:	e0bfff17 	ldw	r2,-4(fp)
81139ec0:	1000021e 	bne	r2,zero,81139ecc <OSQPendAbort+0x3c>
        return (0);
81139ec4:	0005883a 	mov	r2,zero
81139ec8:	00004906 	br	81139ff0 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
81139ecc:	e0bffd17 	ldw	r2,-12(fp)
81139ed0:	1000051e 	bne	r2,zero,81139ee8 <OSQPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
81139ed4:	e0bfff17 	ldw	r2,-4(fp)
81139ed8:	00c00104 	movi	r3,4
81139edc:	10c00005 	stb	r3,0(r2)
        return (0);
81139ee0:	0005883a 	mov	r2,zero
81139ee4:	00004206 	br	81139ff0 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
81139ee8:	e0bffd17 	ldw	r2,-12(fp)
81139eec:	10800003 	ldbu	r2,0(r2)
81139ef0:	10803fcc 	andi	r2,r2,255
81139ef4:	108000a0 	cmpeqi	r2,r2,2
81139ef8:	1000051e 	bne	r2,zero,81139f10 <OSQPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
81139efc:	e0bfff17 	ldw	r2,-4(fp)
81139f00:	00c00044 	movi	r3,1
81139f04:	10c00005 	stb	r3,0(r2)
        return (0);
81139f08:	0005883a 	mov	r2,zero
81139f0c:	00003806 	br	81139ff0 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81139f10:	0005303a 	rdctl	r2,status
81139f14:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81139f18:	e0fffc17 	ldw	r3,-16(fp)
81139f1c:	00bfff84 	movi	r2,-2
81139f20:	1884703a 	and	r2,r3,r2
81139f24:	1001703a 	wrctl	status,r2
  
  return context;
81139f28:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
81139f2c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
81139f30:	e0bffd17 	ldw	r2,-12(fp)
81139f34:	10800283 	ldbu	r2,10(r2)
81139f38:	10803fcc 	andi	r2,r2,255
81139f3c:	10002526 	beq	r2,zero,81139fd4 <OSQPendAbort+0x144>
        nbr_tasks = 0;
81139f40:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
81139f44:	e0bffe03 	ldbu	r2,-8(fp)
81139f48:	10800060 	cmpeqi	r2,r2,1
81139f4c:	10000e26 	beq	r2,zero,81139f88 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81139f50:	00000806 	br	81139f74 <OSQPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81139f54:	01c00084 	movi	r7,2
81139f58:	01800104 	movi	r6,4
81139f5c:	000b883a 	mov	r5,zero
81139f60:	e13ffd17 	ldw	r4,-12(fp)
81139f64:	11351880 	call	81135188 <OS_EventTaskRdy>
                     nbr_tasks++;
81139f68:	e0bff803 	ldbu	r2,-32(fp)
81139f6c:	10800044 	addi	r2,r2,1
81139f70:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
81139f74:	e0bffd17 	ldw	r2,-12(fp)
81139f78:	10800283 	ldbu	r2,10(r2)
81139f7c:	10803fcc 	andi	r2,r2,255
81139f80:	103ff41e 	bne	r2,zero,81139f54 <__reset+0xfb119f54>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
81139f84:	00000906 	br	81139fac <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
81139f88:	01c00084 	movi	r7,2
81139f8c:	01800104 	movi	r6,4
81139f90:	000b883a 	mov	r5,zero
81139f94:	e13ffd17 	ldw	r4,-12(fp)
81139f98:	11351880 	call	81135188 <OS_EventTaskRdy>
                 nbr_tasks++;
81139f9c:	e0bff803 	ldbu	r2,-32(fp)
81139fa0:	10800044 	addi	r2,r2,1
81139fa4:	e0bff805 	stb	r2,-32(fp)
                 break;
81139fa8:	0001883a 	nop
81139fac:	e0bff917 	ldw	r2,-28(fp)
81139fb0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81139fb4:	e0bffa17 	ldw	r2,-24(fp)
81139fb8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
81139fbc:	1135c440 	call	81135c44 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
81139fc0:	e0bfff17 	ldw	r2,-4(fp)
81139fc4:	00c00384 	movi	r3,14
81139fc8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
81139fcc:	e0bff803 	ldbu	r2,-32(fp)
81139fd0:	00000706 	br	81139ff0 <OSQPendAbort+0x160>
81139fd4:	e0bff917 	ldw	r2,-28(fp)
81139fd8:	e0bffb15 	stw	r2,-20(fp)
81139fdc:	e0bffb17 	ldw	r2,-20(fp)
81139fe0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
81139fe4:	e0bfff17 	ldw	r2,-4(fp)
81139fe8:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
81139fec:	0005883a 	mov	r2,zero
}
81139ff0:	e037883a 	mov	sp,fp
81139ff4:	dfc00117 	ldw	ra,4(sp)
81139ff8:	df000017 	ldw	fp,0(sp)
81139ffc:	dec00204 	addi	sp,sp,8
8113a000:	f800283a 	ret

8113a004 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
8113a004:	defff604 	addi	sp,sp,-40
8113a008:	de00012e 	bgeu	sp,et,8113a010 <OSQPost+0xc>
8113a00c:	003b68fa 	trap	3
8113a010:	dfc00915 	stw	ra,36(sp)
8113a014:	df000815 	stw	fp,32(sp)
8113a018:	df000804 	addi	fp,sp,32
8113a01c:	e13ffe15 	stw	r4,-8(fp)
8113a020:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113a024:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113a028:	e0bffe17 	ldw	r2,-8(fp)
8113a02c:	1000021e 	bne	r2,zero,8113a038 <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
8113a030:	00800104 	movi	r2,4
8113a034:	00004a06 	br	8113a160 <OSQPost+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113a038:	e0bffe17 	ldw	r2,-8(fp)
8113a03c:	10800003 	ldbu	r2,0(r2)
8113a040:	10803fcc 	andi	r2,r2,255
8113a044:	108000a0 	cmpeqi	r2,r2,2
8113a048:	1000021e 	bne	r2,zero,8113a054 <OSQPost+0x50>
        return (OS_ERR_EVENT_TYPE);
8113a04c:	00800044 	movi	r2,1
8113a050:	00004306 	br	8113a160 <OSQPost+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a054:	0005303a 	rdctl	r2,status
8113a058:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a05c:	e0fffd17 	ldw	r3,-12(fp)
8113a060:	00bfff84 	movi	r2,-2
8113a064:	1884703a 	and	r2,r3,r2
8113a068:	1001703a 	wrctl	status,r2
  
  return context;
8113a06c:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a070:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
8113a074:	e0bffe17 	ldw	r2,-8(fp)
8113a078:	10800283 	ldbu	r2,10(r2)
8113a07c:	10803fcc 	andi	r2,r2,255
8113a080:	10000c26 	beq	r2,zero,8113a0b4 <OSQPost+0xb0>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113a084:	000f883a 	mov	r7,zero
8113a088:	01800104 	movi	r6,4
8113a08c:	e17fff17 	ldw	r5,-4(fp)
8113a090:	e13ffe17 	ldw	r4,-8(fp)
8113a094:	11351880 	call	81135188 <OS_EventTaskRdy>
8113a098:	e0bff817 	ldw	r2,-32(fp)
8113a09c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a0a0:	e0bff917 	ldw	r2,-28(fp)
8113a0a4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
8113a0a8:	1135c440 	call	81135c44 <OS_Sched>
        return (OS_ERR_NONE);
8113a0ac:	0005883a 	mov	r2,zero
8113a0b0:	00002b06 	br	8113a160 <OSQPost+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
8113a0b4:	e0bffe17 	ldw	r2,-8(fp)
8113a0b8:	10800117 	ldw	r2,4(r2)
8113a0bc:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
8113a0c0:	e0bffb17 	ldw	r2,-20(fp)
8113a0c4:	10c0058b 	ldhu	r3,22(r2)
8113a0c8:	e0bffb17 	ldw	r2,-20(fp)
8113a0cc:	1080050b 	ldhu	r2,20(r2)
8113a0d0:	18ffffcc 	andi	r3,r3,65535
8113a0d4:	10bfffcc 	andi	r2,r2,65535
8113a0d8:	18800636 	bltu	r3,r2,8113a0f4 <OSQPost+0xf0>
8113a0dc:	e0bff817 	ldw	r2,-32(fp)
8113a0e0:	e0bffa15 	stw	r2,-24(fp)
8113a0e4:	e0bffa17 	ldw	r2,-24(fp)
8113a0e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113a0ec:	00800784 	movi	r2,30
8113a0f0:	00001b06 	br	8113a160 <OSQPost+0x15c>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
8113a0f4:	e0bffb17 	ldw	r2,-20(fp)
8113a0f8:	10800317 	ldw	r2,12(r2)
8113a0fc:	11000104 	addi	r4,r2,4
8113a100:	e0fffb17 	ldw	r3,-20(fp)
8113a104:	19000315 	stw	r4,12(r3)
8113a108:	e0ffff17 	ldw	r3,-4(fp)
8113a10c:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
8113a110:	e0bffb17 	ldw	r2,-20(fp)
8113a114:	1080058b 	ldhu	r2,22(r2)
8113a118:	10800044 	addi	r2,r2,1
8113a11c:	1007883a 	mov	r3,r2
8113a120:	e0bffb17 	ldw	r2,-20(fp)
8113a124:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
8113a128:	e0bffb17 	ldw	r2,-20(fp)
8113a12c:	10c00317 	ldw	r3,12(r2)
8113a130:	e0bffb17 	ldw	r2,-20(fp)
8113a134:	10800217 	ldw	r2,8(r2)
8113a138:	1880041e 	bne	r3,r2,8113a14c <OSQPost+0x148>
        pq->OSQIn = pq->OSQStart;
8113a13c:	e0bffb17 	ldw	r2,-20(fp)
8113a140:	10c00117 	ldw	r3,4(r2)
8113a144:	e0bffb17 	ldw	r2,-20(fp)
8113a148:	10c00315 	stw	r3,12(r2)
8113a14c:	e0bff817 	ldw	r2,-32(fp)
8113a150:	e0bffc15 	stw	r2,-16(fp)
8113a154:	e0bffc17 	ldw	r2,-16(fp)
8113a158:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a15c:	0005883a 	mov	r2,zero
}
8113a160:	e037883a 	mov	sp,fp
8113a164:	dfc00117 	ldw	ra,4(sp)
8113a168:	df000017 	ldw	fp,0(sp)
8113a16c:	dec00204 	addi	sp,sp,8
8113a170:	f800283a 	ret

8113a174 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
8113a174:	defff604 	addi	sp,sp,-40
8113a178:	de00012e 	bgeu	sp,et,8113a180 <OSQPostFront+0xc>
8113a17c:	003b68fa 	trap	3
8113a180:	dfc00915 	stw	ra,36(sp)
8113a184:	df000815 	stw	fp,32(sp)
8113a188:	df000804 	addi	fp,sp,32
8113a18c:	e13ffe15 	stw	r4,-8(fp)
8113a190:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a194:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a198:	e0bffe17 	ldw	r2,-8(fp)
8113a19c:	1000021e 	bne	r2,zero,8113a1a8 <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
8113a1a0:	00800104 	movi	r2,4
8113a1a4:	00004c06 	br	8113a2d8 <OSQPostFront+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113a1a8:	e0bffe17 	ldw	r2,-8(fp)
8113a1ac:	10800003 	ldbu	r2,0(r2)
8113a1b0:	10803fcc 	andi	r2,r2,255
8113a1b4:	108000a0 	cmpeqi	r2,r2,2
8113a1b8:	1000021e 	bne	r2,zero,8113a1c4 <OSQPostFront+0x50>
        return (OS_ERR_EVENT_TYPE);
8113a1bc:	00800044 	movi	r2,1
8113a1c0:	00004506 	br	8113a2d8 <OSQPostFront+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a1c4:	0005303a 	rdctl	r2,status
8113a1c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a1cc:	e0fffd17 	ldw	r3,-12(fp)
8113a1d0:	00bfff84 	movi	r2,-2
8113a1d4:	1884703a 	and	r2,r3,r2
8113a1d8:	1001703a 	wrctl	status,r2
  
  return context;
8113a1dc:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a1e0:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
8113a1e4:	e0bffe17 	ldw	r2,-8(fp)
8113a1e8:	10800283 	ldbu	r2,10(r2)
8113a1ec:	10803fcc 	andi	r2,r2,255
8113a1f0:	10000c26 	beq	r2,zero,8113a224 <OSQPostFront+0xb0>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113a1f4:	000f883a 	mov	r7,zero
8113a1f8:	01800104 	movi	r6,4
8113a1fc:	e17fff17 	ldw	r5,-4(fp)
8113a200:	e13ffe17 	ldw	r4,-8(fp)
8113a204:	11351880 	call	81135188 <OS_EventTaskRdy>
8113a208:	e0bff817 	ldw	r2,-32(fp)
8113a20c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a210:	e0bff917 	ldw	r2,-28(fp)
8113a214:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
8113a218:	1135c440 	call	81135c44 <OS_Sched>
        return (OS_ERR_NONE);
8113a21c:	0005883a 	mov	r2,zero
8113a220:	00002d06 	br	8113a2d8 <OSQPostFront+0x164>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113a224:	e0bffe17 	ldw	r2,-8(fp)
8113a228:	10800117 	ldw	r2,4(r2)
8113a22c:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113a230:	e0bffb17 	ldw	r2,-20(fp)
8113a234:	10c0058b 	ldhu	r3,22(r2)
8113a238:	e0bffb17 	ldw	r2,-20(fp)
8113a23c:	1080050b 	ldhu	r2,20(r2)
8113a240:	18ffffcc 	andi	r3,r3,65535
8113a244:	10bfffcc 	andi	r2,r2,65535
8113a248:	18800636 	bltu	r3,r2,8113a264 <OSQPostFront+0xf0>
8113a24c:	e0bff817 	ldw	r2,-32(fp)
8113a250:	e0bffa15 	stw	r2,-24(fp)
8113a254:	e0bffa17 	ldw	r2,-24(fp)
8113a258:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113a25c:	00800784 	movi	r2,30
8113a260:	00001d06 	br	8113a2d8 <OSQPostFront+0x164>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
8113a264:	e0bffb17 	ldw	r2,-20(fp)
8113a268:	10c00417 	ldw	r3,16(r2)
8113a26c:	e0bffb17 	ldw	r2,-20(fp)
8113a270:	10800117 	ldw	r2,4(r2)
8113a274:	1880041e 	bne	r3,r2,8113a288 <OSQPostFront+0x114>
        pq->OSQOut = pq->OSQEnd;
8113a278:	e0bffb17 	ldw	r2,-20(fp)
8113a27c:	10c00217 	ldw	r3,8(r2)
8113a280:	e0bffb17 	ldw	r2,-20(fp)
8113a284:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
8113a288:	e0bffb17 	ldw	r2,-20(fp)
8113a28c:	10800417 	ldw	r2,16(r2)
8113a290:	10ffff04 	addi	r3,r2,-4
8113a294:	e0bffb17 	ldw	r2,-20(fp)
8113a298:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
8113a29c:	e0bffb17 	ldw	r2,-20(fp)
8113a2a0:	10800417 	ldw	r2,16(r2)
8113a2a4:	e0ffff17 	ldw	r3,-4(fp)
8113a2a8:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113a2ac:	e0bffb17 	ldw	r2,-20(fp)
8113a2b0:	1080058b 	ldhu	r2,22(r2)
8113a2b4:	10800044 	addi	r2,r2,1
8113a2b8:	1007883a 	mov	r3,r2
8113a2bc:	e0bffb17 	ldw	r2,-20(fp)
8113a2c0:	10c0058d 	sth	r3,22(r2)
8113a2c4:	e0bff817 	ldw	r2,-32(fp)
8113a2c8:	e0bffc15 	stw	r2,-16(fp)
8113a2cc:	e0bffc17 	ldw	r2,-16(fp)
8113a2d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a2d4:	0005883a 	mov	r2,zero
}
8113a2d8:	e037883a 	mov	sp,fp
8113a2dc:	dfc00117 	ldw	ra,4(sp)
8113a2e0:	df000017 	ldw	fp,0(sp)
8113a2e4:	dec00204 	addi	sp,sp,8
8113a2e8:	f800283a 	ret

8113a2ec <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
8113a2ec:	defff504 	addi	sp,sp,-44
8113a2f0:	de00012e 	bgeu	sp,et,8113a2f8 <OSQPostOpt+0xc>
8113a2f4:	003b68fa 	trap	3
8113a2f8:	dfc00a15 	stw	ra,40(sp)
8113a2fc:	df000915 	stw	fp,36(sp)
8113a300:	df000904 	addi	fp,sp,36
8113a304:	e13ffd15 	stw	r4,-12(fp)
8113a308:	e17ffe15 	stw	r5,-8(fp)
8113a30c:	3005883a 	mov	r2,r6
8113a310:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a314:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a318:	e0bffd17 	ldw	r2,-12(fp)
8113a31c:	1000021e 	bne	r2,zero,8113a328 <OSQPostOpt+0x3c>
        return (OS_ERR_PEVENT_NULL);
8113a320:	00800104 	movi	r2,4
8113a324:	00007106 	br	8113a4ec <OSQPostOpt+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
8113a328:	e0bffd17 	ldw	r2,-12(fp)
8113a32c:	10800003 	ldbu	r2,0(r2)
8113a330:	10803fcc 	andi	r2,r2,255
8113a334:	108000a0 	cmpeqi	r2,r2,2
8113a338:	1000021e 	bne	r2,zero,8113a344 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
8113a33c:	00800044 	movi	r2,1
8113a340:	00006a06 	br	8113a4ec <OSQPostOpt+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a344:	0005303a 	rdctl	r2,status
8113a348:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a34c:	e0fffc17 	ldw	r3,-16(fp)
8113a350:	00bfff84 	movi	r2,-2
8113a354:	1884703a 	and	r2,r3,r2
8113a358:	1001703a 	wrctl	status,r2
  
  return context;
8113a35c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a360:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
8113a364:	e0bffd17 	ldw	r2,-12(fp)
8113a368:	10800283 	ldbu	r2,10(r2)
8113a36c:	10803fcc 	andi	r2,r2,255
8113a370:	10001d26 	beq	r2,zero,8113a3e8 <OSQPostOpt+0xfc>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
8113a374:	e0bfff03 	ldbu	r2,-4(fp)
8113a378:	1080004c 	andi	r2,r2,1
8113a37c:	10000b26 	beq	r2,zero,8113a3ac <OSQPostOpt+0xc0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113a380:	00000506 	br	8113a398 <OSQPostOpt+0xac>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113a384:	000f883a 	mov	r7,zero
8113a388:	01800104 	movi	r6,4
8113a38c:	e17ffe17 	ldw	r5,-8(fp)
8113a390:	e13ffd17 	ldw	r4,-12(fp)
8113a394:	11351880 	call	81135188 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
8113a398:	e0bffd17 	ldw	r2,-12(fp)
8113a39c:	10800283 	ldbu	r2,10(r2)
8113a3a0:	10803fcc 	andi	r2,r2,255
8113a3a4:	103ff71e 	bne	r2,zero,8113a384 <__reset+0xfb11a384>
8113a3a8:	00000506 	br	8113a3c0 <OSQPostOpt+0xd4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
8113a3ac:	000f883a 	mov	r7,zero
8113a3b0:	01800104 	movi	r6,4
8113a3b4:	e17ffe17 	ldw	r5,-8(fp)
8113a3b8:	e13ffd17 	ldw	r4,-12(fp)
8113a3bc:	11351880 	call	81135188 <OS_EventTaskRdy>
8113a3c0:	e0bff717 	ldw	r2,-36(fp)
8113a3c4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a3c8:	e0bff817 	ldw	r2,-32(fp)
8113a3cc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
8113a3d0:	e0bfff03 	ldbu	r2,-4(fp)
8113a3d4:	1080010c 	andi	r2,r2,4
8113a3d8:	1000011e 	bne	r2,zero,8113a3e0 <OSQPostOpt+0xf4>
            OS_Sched();                               /* Find highest priority task ready to run       */
8113a3dc:	1135c440 	call	81135c44 <OS_Sched>
        }
        return (OS_ERR_NONE);
8113a3e0:	0005883a 	mov	r2,zero
8113a3e4:	00004106 	br	8113a4ec <OSQPostOpt+0x200>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
8113a3e8:	e0bffd17 	ldw	r2,-12(fp)
8113a3ec:	10800117 	ldw	r2,4(r2)
8113a3f0:	e0bffa15 	stw	r2,-24(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
8113a3f4:	e0bffa17 	ldw	r2,-24(fp)
8113a3f8:	10c0058b 	ldhu	r3,22(r2)
8113a3fc:	e0bffa17 	ldw	r2,-24(fp)
8113a400:	1080050b 	ldhu	r2,20(r2)
8113a404:	18ffffcc 	andi	r3,r3,65535
8113a408:	10bfffcc 	andi	r2,r2,65535
8113a40c:	18800636 	bltu	r3,r2,8113a428 <OSQPostOpt+0x13c>
8113a410:	e0bff717 	ldw	r2,-36(fp)
8113a414:	e0bff915 	stw	r2,-28(fp)
8113a418:	e0bff917 	ldw	r2,-28(fp)
8113a41c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
8113a420:	00800784 	movi	r2,30
8113a424:	00003106 	br	8113a4ec <OSQPostOpt+0x200>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
8113a428:	e0bfff03 	ldbu	r2,-4(fp)
8113a42c:	1080008c 	andi	r2,r2,2
8113a430:	10001326 	beq	r2,zero,8113a480 <OSQPostOpt+0x194>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
8113a434:	e0bffa17 	ldw	r2,-24(fp)
8113a438:	10c00417 	ldw	r3,16(r2)
8113a43c:	e0bffa17 	ldw	r2,-24(fp)
8113a440:	10800117 	ldw	r2,4(r2)
8113a444:	1880041e 	bne	r3,r2,8113a458 <OSQPostOpt+0x16c>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
8113a448:	e0bffa17 	ldw	r2,-24(fp)
8113a44c:	10c00217 	ldw	r3,8(r2)
8113a450:	e0bffa17 	ldw	r2,-24(fp)
8113a454:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
8113a458:	e0bffa17 	ldw	r2,-24(fp)
8113a45c:	10800417 	ldw	r2,16(r2)
8113a460:	10ffff04 	addi	r3,r2,-4
8113a464:	e0bffa17 	ldw	r2,-24(fp)
8113a468:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
8113a46c:	e0bffa17 	ldw	r2,-24(fp)
8113a470:	10800417 	ldw	r2,16(r2)
8113a474:	e0fffe17 	ldw	r3,-8(fp)
8113a478:	10c00015 	stw	r3,0(r2)
8113a47c:	00001006 	br	8113a4c0 <OSQPostOpt+0x1d4>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
8113a480:	e0bffa17 	ldw	r2,-24(fp)
8113a484:	10800317 	ldw	r2,12(r2)
8113a488:	11000104 	addi	r4,r2,4
8113a48c:	e0fffa17 	ldw	r3,-24(fp)
8113a490:	19000315 	stw	r4,12(r3)
8113a494:	e0fffe17 	ldw	r3,-8(fp)
8113a498:	10c00015 	stw	r3,0(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
8113a49c:	e0bffa17 	ldw	r2,-24(fp)
8113a4a0:	10c00317 	ldw	r3,12(r2)
8113a4a4:	e0bffa17 	ldw	r2,-24(fp)
8113a4a8:	10800217 	ldw	r2,8(r2)
8113a4ac:	1880041e 	bne	r3,r2,8113a4c0 <OSQPostOpt+0x1d4>
            pq->OSQIn = pq->OSQStart;
8113a4b0:	e0bffa17 	ldw	r2,-24(fp)
8113a4b4:	10c00117 	ldw	r3,4(r2)
8113a4b8:	e0bffa17 	ldw	r2,-24(fp)
8113a4bc:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
8113a4c0:	e0bffa17 	ldw	r2,-24(fp)
8113a4c4:	1080058b 	ldhu	r2,22(r2)
8113a4c8:	10800044 	addi	r2,r2,1
8113a4cc:	1007883a 	mov	r3,r2
8113a4d0:	e0bffa17 	ldw	r2,-24(fp)
8113a4d4:	10c0058d 	sth	r3,22(r2)
8113a4d8:	e0bff717 	ldw	r2,-36(fp)
8113a4dc:	e0bffb15 	stw	r2,-20(fp)
8113a4e0:	e0bffb17 	ldw	r2,-20(fp)
8113a4e4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a4e8:	0005883a 	mov	r2,zero
}
8113a4ec:	e037883a 	mov	sp,fp
8113a4f0:	dfc00117 	ldw	ra,4(sp)
8113a4f4:	df000017 	ldw	fp,0(sp)
8113a4f8:	dec00204 	addi	sp,sp,8
8113a4fc:	f800283a 	ret

8113a500 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
8113a500:	defff604 	addi	sp,sp,-40
8113a504:	de00012e 	bgeu	sp,et,8113a50c <OSQQuery+0xc>
8113a508:	003b68fa 	trap	3
8113a50c:	df000915 	stw	fp,36(sp)
8113a510:	df000904 	addi	fp,sp,36
8113a514:	e13ffe15 	stw	r4,-8(fp)
8113a518:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113a51c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
8113a520:	e0bffe17 	ldw	r2,-8(fp)
8113a524:	1000021e 	bne	r2,zero,8113a530 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113a528:	00800104 	movi	r2,4
8113a52c:	00004906 	br	8113a654 <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
8113a530:	e0bfff17 	ldw	r2,-4(fp)
8113a534:	1000021e 	bne	r2,zero,8113a540 <OSQQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113a538:	00800244 	movi	r2,9
8113a53c:	00004506 	br	8113a654 <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
8113a540:	e0bffe17 	ldw	r2,-8(fp)
8113a544:	10800003 	ldbu	r2,0(r2)
8113a548:	10803fcc 	andi	r2,r2,255
8113a54c:	108000a0 	cmpeqi	r2,r2,2
8113a550:	1000021e 	bne	r2,zero,8113a55c <OSQQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113a554:	00800044 	movi	r2,1
8113a558:	00003e06 	br	8113a654 <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a55c:	0005303a 	rdctl	r2,status
8113a560:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a564:	e0fffd17 	ldw	r3,-12(fp)
8113a568:	00bfff84 	movi	r2,-2
8113a56c:	1884703a 	and	r2,r3,r2
8113a570:	1001703a 	wrctl	status,r2
  
  return context;
8113a574:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113a578:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
8113a57c:	e0bffe17 	ldw	r2,-8(fp)
8113a580:	10c00283 	ldbu	r3,10(r2)
8113a584:	e0bfff17 	ldw	r2,-4(fp)
8113a588:	10c00385 	stb	r3,14(r2)
    psrc                 = &pevent->OSEventTbl[0];
8113a58c:	e0bffe17 	ldw	r2,-8(fp)
8113a590:	108002c4 	addi	r2,r2,11
8113a594:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
8113a598:	e0bfff17 	ldw	r2,-4(fp)
8113a59c:	10800204 	addi	r2,r2,8
8113a5a0:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113a5a4:	e03ff705 	stb	zero,-36(fp)
8113a5a8:	00000b06 	br	8113a5d8 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
8113a5ac:	e0bff917 	ldw	r2,-28(fp)
8113a5b0:	10c00044 	addi	r3,r2,1
8113a5b4:	e0fff915 	stw	r3,-28(fp)
8113a5b8:	e0fff817 	ldw	r3,-32(fp)
8113a5bc:	19000044 	addi	r4,r3,1
8113a5c0:	e13ff815 	stw	r4,-32(fp)
8113a5c4:	18c00003 	ldbu	r3,0(r3)
8113a5c8:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113a5cc:	e0bff703 	ldbu	r2,-36(fp)
8113a5d0:	10800044 	addi	r2,r2,1
8113a5d4:	e0bff705 	stb	r2,-36(fp)
8113a5d8:	e0bff703 	ldbu	r2,-36(fp)
8113a5dc:	108001b0 	cmpltui	r2,r2,6
8113a5e0:	103ff21e 	bne	r2,zero,8113a5ac <__reset+0xfb11a5ac>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
8113a5e4:	e0bffe17 	ldw	r2,-8(fp)
8113a5e8:	10800117 	ldw	r2,4(r2)
8113a5ec:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
8113a5f0:	e0bffc17 	ldw	r2,-16(fp)
8113a5f4:	1080058b 	ldhu	r2,22(r2)
8113a5f8:	10bfffcc 	andi	r2,r2,65535
8113a5fc:	10000626 	beq	r2,zero,8113a618 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
8113a600:	e0bffc17 	ldw	r2,-16(fp)
8113a604:	10800417 	ldw	r2,16(r2)
8113a608:	10c00017 	ldw	r3,0(r2)
8113a60c:	e0bfff17 	ldw	r2,-4(fp)
8113a610:	10c00015 	stw	r3,0(r2)
8113a614:	00000206 	br	8113a620 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
8113a618:	e0bfff17 	ldw	r2,-4(fp)
8113a61c:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
8113a620:	e0bffc17 	ldw	r2,-16(fp)
8113a624:	10c0058b 	ldhu	r3,22(r2)
8113a628:	e0bfff17 	ldw	r2,-4(fp)
8113a62c:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
8113a630:	e0bffc17 	ldw	r2,-16(fp)
8113a634:	10c0050b 	ldhu	r3,20(r2)
8113a638:	e0bfff17 	ldw	r2,-4(fp)
8113a63c:	10c0018d 	sth	r3,6(r2)
8113a640:	e0bffa17 	ldw	r2,-24(fp)
8113a644:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a648:	e0bffb17 	ldw	r2,-20(fp)
8113a64c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113a650:	0005883a 	mov	r2,zero
}
8113a654:	e037883a 	mov	sp,fp
8113a658:	df000017 	ldw	fp,0(sp)
8113a65c:	dec00104 	addi	sp,sp,4
8113a660:	f800283a 	ret

8113a664 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
8113a664:	defffb04 	addi	sp,sp,-20
8113a668:	de00012e 	bgeu	sp,et,8113a670 <OS_QInit+0xc>
8113a66c:	003b68fa 	trap	3
8113a670:	dfc00415 	stw	ra,16(sp)
8113a674:	df000315 	stw	fp,12(sp)
8113a678:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
8113a67c:	0140c004 	movi	r5,768
8113a680:	012045b4 	movhi	r4,33046
8113a684:	21129204 	addi	r4,r4,19016
8113a688:	1135b780 	call	81135b78 <OS_MemClr>
    pq1 = &OSQTbl[0];
8113a68c:	00a045b4 	movhi	r2,33046
8113a690:	10929204 	addi	r2,r2,19016
8113a694:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
8113a698:	00a045b4 	movhi	r2,33046
8113a69c:	10929804 	addi	r2,r2,19040
8113a6a0:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113a6a4:	e03ffd0d 	sth	zero,-12(fp)
8113a6a8:	00000c06 	br	8113a6dc <OS_QInit+0x78>
        pq1->OSQPtr = pq2;
8113a6ac:	e0bffe17 	ldw	r2,-8(fp)
8113a6b0:	e0ffff17 	ldw	r3,-4(fp)
8113a6b4:	10c00015 	stw	r3,0(r2)
        pq1++;
8113a6b8:	e0bffe17 	ldw	r2,-8(fp)
8113a6bc:	10800604 	addi	r2,r2,24
8113a6c0:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
8113a6c4:	e0bfff17 	ldw	r2,-4(fp)
8113a6c8:	10800604 	addi	r2,r2,24
8113a6cc:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
8113a6d0:	e0bffd0b 	ldhu	r2,-12(fp)
8113a6d4:	10800044 	addi	r2,r2,1
8113a6d8:	e0bffd0d 	sth	r2,-12(fp)
8113a6dc:	e0bffd0b 	ldhu	r2,-12(fp)
8113a6e0:	108007f0 	cmpltui	r2,r2,31
8113a6e4:	103ff11e 	bne	r2,zero,8113a6ac <__reset+0xfb11a6ac>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
8113a6e8:	e0bffe17 	ldw	r2,-8(fp)
8113a6ec:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
8113a6f0:	00a045b4 	movhi	r2,33046
8113a6f4:	10929204 	addi	r2,r2,19016
8113a6f8:	d0a09915 	stw	r2,-32156(gp)
#endif
}
8113a6fc:	0001883a 	nop
8113a700:	e037883a 	mov	sp,fp
8113a704:	dfc00117 	ldw	ra,4(sp)
8113a708:	df000017 	ldw	fp,0(sp)
8113a70c:	dec00204 	addi	sp,sp,8
8113a710:	f800283a 	ret

8113a714 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
8113a714:	defffa04 	addi	sp,sp,-24
8113a718:	de00012e 	bgeu	sp,et,8113a720 <OSSemAccept+0xc>
8113a71c:	003b68fa 	trap	3
8113a720:	df000515 	stw	fp,20(sp)
8113a724:	df000504 	addi	fp,sp,20
8113a728:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113a72c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113a730:	e0bfff17 	ldw	r2,-4(fp)
8113a734:	1000021e 	bne	r2,zero,8113a740 <OSSemAccept+0x2c>
        return (0);
8113a738:	0005883a 	mov	r2,zero
8113a73c:	00001f06 	br	8113a7bc <OSSemAccept+0xa8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113a740:	e0bfff17 	ldw	r2,-4(fp)
8113a744:	10800003 	ldbu	r2,0(r2)
8113a748:	10803fcc 	andi	r2,r2,255
8113a74c:	108000e0 	cmpeqi	r2,r2,3
8113a750:	1000021e 	bne	r2,zero,8113a75c <OSSemAccept+0x48>
        return (0);
8113a754:	0005883a 	mov	r2,zero
8113a758:	00001806 	br	8113a7bc <OSSemAccept+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a75c:	0005303a 	rdctl	r2,status
8113a760:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a764:	e0fffe17 	ldw	r3,-8(fp)
8113a768:	00bfff84 	movi	r2,-2
8113a76c:	1884703a 	and	r2,r3,r2
8113a770:	1001703a 	wrctl	status,r2
  
  return context;
8113a774:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113a778:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
8113a77c:	e0bfff17 	ldw	r2,-4(fp)
8113a780:	1080020b 	ldhu	r2,8(r2)
8113a784:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
8113a788:	e0bffd0b 	ldhu	r2,-12(fp)
8113a78c:	10000626 	beq	r2,zero,8113a7a8 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
8113a790:	e0bfff17 	ldw	r2,-4(fp)
8113a794:	1080020b 	ldhu	r2,8(r2)
8113a798:	10bfffc4 	addi	r2,r2,-1
8113a79c:	1007883a 	mov	r3,r2
8113a7a0:	e0bfff17 	ldw	r2,-4(fp)
8113a7a4:	10c0020d 	sth	r3,8(r2)
8113a7a8:	e0bffb17 	ldw	r2,-20(fp)
8113a7ac:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a7b0:	e0bffc17 	ldw	r2,-16(fp)
8113a7b4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
8113a7b8:	e0bffd0b 	ldhu	r2,-12(fp)
}
8113a7bc:	e037883a 	mov	sp,fp
8113a7c0:	df000017 	ldw	fp,0(sp)
8113a7c4:	dec00104 	addi	sp,sp,4
8113a7c8:	f800283a 	ret

8113a7cc <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
8113a7cc:	defff904 	addi	sp,sp,-28
8113a7d0:	de00012e 	bgeu	sp,et,8113a7d8 <OSSemCreate+0xc>
8113a7d4:	003b68fa 	trap	3
8113a7d8:	dfc00615 	stw	ra,24(sp)
8113a7dc:	df000515 	stw	fp,20(sp)
8113a7e0:	df000504 	addi	fp,sp,20
8113a7e4:	2005883a 	mov	r2,r4
8113a7e8:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a7ec:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a7f0:	d0a09d03 	ldbu	r2,-32140(gp)
8113a7f4:	10803fcc 	andi	r2,r2,255
8113a7f8:	10000226 	beq	r2,zero,8113a804 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
8113a7fc:	0005883a 	mov	r2,zero
8113a800:	00002506 	br	8113a898 <OSSemCreate+0xcc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a804:	0005303a 	rdctl	r2,status
8113a808:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a80c:	e0fffe17 	ldw	r3,-8(fp)
8113a810:	00bfff84 	movi	r2,-2
8113a814:	1884703a 	and	r2,r3,r2
8113a818:	1001703a 	wrctl	status,r2
  
  return context;
8113a81c:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113a820:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
8113a824:	d0a09c17 	ldw	r2,-32144(gp)
8113a828:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
8113a82c:	d0a09c17 	ldw	r2,-32144(gp)
8113a830:	10000326 	beq	r2,zero,8113a840 <OSSemCreate+0x74>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
8113a834:	d0a09c17 	ldw	r2,-32144(gp)
8113a838:	10800117 	ldw	r2,4(r2)
8113a83c:	d0a09c15 	stw	r2,-32144(gp)
8113a840:	e0bffb17 	ldw	r2,-20(fp)
8113a844:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a848:	e0bffc17 	ldw	r2,-16(fp)
8113a84c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
8113a850:	e0bffd17 	ldw	r2,-12(fp)
8113a854:	10000f26 	beq	r2,zero,8113a894 <OSSemCreate+0xc8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
8113a858:	e0bffd17 	ldw	r2,-12(fp)
8113a85c:	00c000c4 	movi	r3,3
8113a860:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
8113a864:	e0bffd17 	ldw	r2,-12(fp)
8113a868:	e0ffff0b 	ldhu	r3,-4(fp)
8113a86c:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
8113a870:	e0bffd17 	ldw	r2,-12(fp)
8113a874:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
8113a878:	e0bffd17 	ldw	r2,-12(fp)
8113a87c:	00c00fc4 	movi	r3,63
8113a880:	10c00445 	stb	r3,17(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
8113a884:	e0bffd17 	ldw	r2,-12(fp)
8113a888:	10000485 	stb	zero,18(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
8113a88c:	e13ffd17 	ldw	r4,-12(fp)
8113a890:	11357600 	call	81135760 <OS_EventWaitListInit>
    }
    return (pevent);
8113a894:	e0bffd17 	ldw	r2,-12(fp)
}
8113a898:	e037883a 	mov	sp,fp
8113a89c:	dfc00117 	ldw	ra,4(sp)
8113a8a0:	df000017 	ldw	fp,0(sp)
8113a8a4:	dec00204 	addi	sp,sp,8
8113a8a8:	f800283a 	ret

8113a8ac <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113a8ac:	defff304 	addi	sp,sp,-52
8113a8b0:	de00012e 	bgeu	sp,et,8113a8b8 <OSSemDel+0xc>
8113a8b4:	003b68fa 	trap	3
8113a8b8:	dfc00c15 	stw	ra,48(sp)
8113a8bc:	df000b15 	stw	fp,44(sp)
8113a8c0:	df000b04 	addi	fp,sp,44
8113a8c4:	e13ffd15 	stw	r4,-12(fp)
8113a8c8:	2805883a 	mov	r2,r5
8113a8cc:	e1bfff15 	stw	r6,-4(fp)
8113a8d0:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113a8d4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
8113a8d8:	e0bfff17 	ldw	r2,-4(fp)
8113a8dc:	1000021e 	bne	r2,zero,8113a8e8 <OSSemDel+0x3c>
        return (pevent);
8113a8e0:	e0bffd17 	ldw	r2,-12(fp)
8113a8e4:	00007e06 	br	8113aae0 <OSSemDel+0x234>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113a8e8:	e0bffd17 	ldw	r2,-12(fp)
8113a8ec:	1000051e 	bne	r2,zero,8113a904 <OSSemDel+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113a8f0:	e0bfff17 	ldw	r2,-4(fp)
8113a8f4:	00c00104 	movi	r3,4
8113a8f8:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a8fc:	e0bffd17 	ldw	r2,-12(fp)
8113a900:	00007706 	br	8113aae0 <OSSemDel+0x234>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113a904:	e0bffd17 	ldw	r2,-12(fp)
8113a908:	10800003 	ldbu	r2,0(r2)
8113a90c:	10803fcc 	andi	r2,r2,255
8113a910:	108000e0 	cmpeqi	r2,r2,3
8113a914:	1000051e 	bne	r2,zero,8113a92c <OSSemDel+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113a918:	e0bfff17 	ldw	r2,-4(fp)
8113a91c:	00c00044 	movi	r3,1
8113a920:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a924:	e0bffd17 	ldw	r2,-12(fp)
8113a928:	00006d06 	br	8113aae0 <OSSemDel+0x234>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
8113a92c:	d0a09d03 	ldbu	r2,-32140(gp)
8113a930:	10803fcc 	andi	r2,r2,255
8113a934:	10000526 	beq	r2,zero,8113a94c <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
8113a938:	e0bfff17 	ldw	r2,-4(fp)
8113a93c:	00c003c4 	movi	r3,15
8113a940:	10c00005 	stb	r3,0(r2)
        return (pevent);
8113a944:	e0bffd17 	ldw	r2,-12(fp)
8113a948:	00006506 	br	8113aae0 <OSSemDel+0x234>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113a94c:	0005303a 	rdctl	r2,status
8113a950:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113a954:	e0fffc17 	ldw	r3,-16(fp)
8113a958:	00bfff84 	movi	r2,-2
8113a95c:	1884703a 	and	r2,r3,r2
8113a960:	1001703a 	wrctl	status,r2
  
  return context;
8113a964:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113a968:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
8113a96c:	e0bffd17 	ldw	r2,-12(fp)
8113a970:	10800283 	ldbu	r2,10(r2)
8113a974:	10803fcc 	andi	r2,r2,255
8113a978:	10000326 	beq	r2,zero,8113a988 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
8113a97c:	00800044 	movi	r2,1
8113a980:	e0bff505 	stb	r2,-44(fp)
8113a984:	00000106 	br	8113a98c <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
8113a988:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
8113a98c:	e0bffe03 	ldbu	r2,-8(fp)
8113a990:	10000326 	beq	r2,zero,8113a9a0 <OSSemDel+0xf4>
8113a994:	10800060 	cmpeqi	r2,r2,1
8113a998:	1000281e 	bne	r2,zero,8113aa3c <OSSemDel+0x190>
8113a99c:	00004506 	br	8113aab4 <OSSemDel+0x208>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
8113a9a0:	e0bff503 	ldbu	r2,-44(fp)
8113a9a4:	1000161e 	bne	r2,zero,8113aa00 <OSSemDel+0x154>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
8113a9a8:	e0bffd17 	ldw	r2,-12(fp)
8113a9ac:	00c00fc4 	movi	r3,63
8113a9b0:	10c00445 	stb	r3,17(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
8113a9b4:	e0bffd17 	ldw	r2,-12(fp)
8113a9b8:	10000485 	stb	zero,18(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113a9bc:	e0bffd17 	ldw	r2,-12(fp)
8113a9c0:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
8113a9c4:	d0e09c17 	ldw	r3,-32144(gp)
8113a9c8:	e0bffd17 	ldw	r2,-12(fp)
8113a9cc:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
8113a9d0:	e0bffd17 	ldw	r2,-12(fp)
8113a9d4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
8113a9d8:	e0bffd17 	ldw	r2,-12(fp)
8113a9dc:	d0a09c15 	stw	r2,-32144(gp)
8113a9e0:	e0bff717 	ldw	r2,-36(fp)
8113a9e4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113a9e8:	e0bff817 	ldw	r2,-32(fp)
8113a9ec:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
8113a9f0:	e0bfff17 	ldw	r2,-4(fp)
8113a9f4:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
8113a9f8:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
8113a9fc:	00003706 	br	8113aadc <OSSemDel+0x230>
8113aa00:	e0bff717 	ldw	r2,-36(fp)
8113aa04:	e0bff915 	stw	r2,-28(fp)
8113aa08:	e0bff917 	ldw	r2,-28(fp)
8113aa0c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
8113aa10:	e0bfff17 	ldw	r2,-4(fp)
8113aa14:	00c01244 	movi	r3,73
8113aa18:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
8113aa1c:	e0bffd17 	ldw	r2,-12(fp)
8113aa20:	e0bff615 	stw	r2,-40(fp)
             }
             break;
8113aa24:	00002d06 	br	8113aadc <OSSemDel+0x230>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113aa28:	000f883a 	mov	r7,zero
8113aa2c:	01800044 	movi	r6,1
8113aa30:	000b883a 	mov	r5,zero
8113aa34:	e13ffd17 	ldw	r4,-12(fp)
8113aa38:	11351880 	call	81135188 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
8113aa3c:	e0bffd17 	ldw	r2,-12(fp)
8113aa40:	10800283 	ldbu	r2,10(r2)
8113aa44:	10803fcc 	andi	r2,r2,255
8113aa48:	103ff71e 	bne	r2,zero,8113aa28 <__reset+0xfb11aa28>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
8113aa4c:	e0bffd17 	ldw	r2,-12(fp)
8113aa50:	00c00fc4 	movi	r3,63
8113aa54:	10c00445 	stb	r3,17(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
8113aa58:	e0bffd17 	ldw	r2,-12(fp)
8113aa5c:	10000485 	stb	zero,18(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
8113aa60:	e0bffd17 	ldw	r2,-12(fp)
8113aa64:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
8113aa68:	d0e09c17 	ldw	r3,-32144(gp)
8113aa6c:	e0bffd17 	ldw	r2,-12(fp)
8113aa70:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
8113aa74:	e0bffd17 	ldw	r2,-12(fp)
8113aa78:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
8113aa7c:	e0bffd17 	ldw	r2,-12(fp)
8113aa80:	d0a09c15 	stw	r2,-32144(gp)
8113aa84:	e0bff717 	ldw	r2,-36(fp)
8113aa88:	e0bffa15 	stw	r2,-24(fp)
8113aa8c:	e0bffa17 	ldw	r2,-24(fp)
8113aa90:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
8113aa94:	e0bff503 	ldbu	r2,-44(fp)
8113aa98:	10800058 	cmpnei	r2,r2,1
8113aa9c:	1000011e 	bne	r2,zero,8113aaa4 <OSSemDel+0x1f8>
                 OS_Sched();                               /* Find highest priority task ready to run  */
8113aaa0:	1135c440 	call	81135c44 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
8113aaa4:	e0bfff17 	ldw	r2,-4(fp)
8113aaa8:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
8113aaac:	e03ff615 	stw	zero,-40(fp)
             break;
8113aab0:	00000a06 	br	8113aadc <OSSemDel+0x230>
8113aab4:	e0bff717 	ldw	r2,-36(fp)
8113aab8:	e0bffb15 	stw	r2,-20(fp)
8113aabc:	e0bffb17 	ldw	r2,-20(fp)
8113aac0:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
8113aac4:	e0bfff17 	ldw	r2,-4(fp)
8113aac8:	00c001c4 	movi	r3,7
8113aacc:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
8113aad0:	e0bffd17 	ldw	r2,-12(fp)
8113aad4:	e0bff615 	stw	r2,-40(fp)
             break;
8113aad8:	0001883a 	nop
    }
    return (pevent_return);
8113aadc:	e0bff617 	ldw	r2,-40(fp)
}
8113aae0:	e037883a 	mov	sp,fp
8113aae4:	dfc00117 	ldw	ra,4(sp)
8113aae8:	df000017 	ldw	fp,0(sp)
8113aaec:	dec00204 	addi	sp,sp,8
8113aaf0:	f800283a 	ret

8113aaf4 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
8113aaf4:	defff504 	addi	sp,sp,-44
8113aaf8:	de00012e 	bgeu	sp,et,8113ab00 <OSSemPend+0xc>
8113aafc:	003b68fa 	trap	3
8113ab00:	dfc00a15 	stw	ra,40(sp)
8113ab04:	df000915 	stw	fp,36(sp)
8113ab08:	df000904 	addi	fp,sp,36
8113ab0c:	e13ffd15 	stw	r4,-12(fp)
8113ab10:	2805883a 	mov	r2,r5
8113ab14:	e1bfff15 	stw	r6,-4(fp)
8113ab18:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ab1c:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113ab20:	e0bfff17 	ldw	r2,-4(fp)
8113ab24:	10007226 	beq	r2,zero,8113acf0 <OSSemPend+0x1fc>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ab28:	e0bffd17 	ldw	r2,-12(fp)
8113ab2c:	1000041e 	bne	r2,zero,8113ab40 <OSSemPend+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
8113ab30:	e0bfff17 	ldw	r2,-4(fp)
8113ab34:	00c00104 	movi	r3,4
8113ab38:	10c00005 	stb	r3,0(r2)
        return;
8113ab3c:	00006d06 	br	8113acf4 <OSSemPend+0x200>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113ab40:	e0bffd17 	ldw	r2,-12(fp)
8113ab44:	10800003 	ldbu	r2,0(r2)
8113ab48:	10803fcc 	andi	r2,r2,255
8113ab4c:	108000e0 	cmpeqi	r2,r2,3
8113ab50:	1000041e 	bne	r2,zero,8113ab64 <OSSemPend+0x70>
        *perr = OS_ERR_EVENT_TYPE;
8113ab54:	e0bfff17 	ldw	r2,-4(fp)
8113ab58:	00c00044 	movi	r3,1
8113ab5c:	10c00005 	stb	r3,0(r2)
        return;
8113ab60:	00006406 	br	8113acf4 <OSSemPend+0x200>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
8113ab64:	d0a09d03 	ldbu	r2,-32140(gp)
8113ab68:	10803fcc 	andi	r2,r2,255
8113ab6c:	10000426 	beq	r2,zero,8113ab80 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
8113ab70:	e0bfff17 	ldw	r2,-4(fp)
8113ab74:	00c00084 	movi	r3,2
8113ab78:	10c00005 	stb	r3,0(r2)
        return;
8113ab7c:	00005d06 	br	8113acf4 <OSSemPend+0x200>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
8113ab80:	d0a08b03 	ldbu	r2,-32212(gp)
8113ab84:	10803fcc 	andi	r2,r2,255
8113ab88:	10000426 	beq	r2,zero,8113ab9c <OSSemPend+0xa8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
8113ab8c:	e0bfff17 	ldw	r2,-4(fp)
8113ab90:	00c00344 	movi	r3,13
8113ab94:	10c00005 	stb	r3,0(r2)
        return;
8113ab98:	00005606 	br	8113acf4 <OSSemPend+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ab9c:	0005303a 	rdctl	r2,status
8113aba0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aba4:	e0fffc17 	ldw	r3,-16(fp)
8113aba8:	00bfff84 	movi	r2,-2
8113abac:	1884703a 	and	r2,r3,r2
8113abb0:	1001703a 	wrctl	status,r2
  
  return context;
8113abb4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113abb8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
8113abbc:	e0bffd17 	ldw	r2,-12(fp)
8113abc0:	1080020b 	ldhu	r2,8(r2)
8113abc4:	10bfffcc 	andi	r2,r2,65535
8113abc8:	10000d26 	beq	r2,zero,8113ac00 <OSSemPend+0x10c>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
8113abcc:	e0bffd17 	ldw	r2,-12(fp)
8113abd0:	1080020b 	ldhu	r2,8(r2)
8113abd4:	10bfffc4 	addi	r2,r2,-1
8113abd8:	1007883a 	mov	r3,r2
8113abdc:	e0bffd17 	ldw	r2,-12(fp)
8113abe0:	10c0020d 	sth	r3,8(r2)
8113abe4:	e0bff717 	ldw	r2,-36(fp)
8113abe8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113abec:	e0bff817 	ldw	r2,-32(fp)
8113abf0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
8113abf4:	e0bfff17 	ldw	r2,-4(fp)
8113abf8:	10000005 	stb	zero,0(r2)
        return;
8113abfc:	00003d06 	br	8113acf4 <OSSemPend+0x200>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
8113ac00:	d0a09e17 	ldw	r2,-32136(gp)
8113ac04:	d0e09e17 	ldw	r3,-32136(gp)
8113ac08:	18c00c03 	ldbu	r3,48(r3)
8113ac0c:	18c00054 	ori	r3,r3,1
8113ac10:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
8113ac14:	d0a09e17 	ldw	r2,-32136(gp)
8113ac18:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
8113ac1c:	d0a09e17 	ldw	r2,-32136(gp)
8113ac20:	e0fffe0b 	ldhu	r3,-8(fp)
8113ac24:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
8113ac28:	e13ffd17 	ldw	r4,-12(fp)
8113ac2c:	11353280 	call	81135328 <OS_EventTaskWait>
8113ac30:	e0bff717 	ldw	r2,-36(fp)
8113ac34:	e0bffb15 	stw	r2,-20(fp)
8113ac38:	e0bffb17 	ldw	r2,-20(fp)
8113ac3c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
8113ac40:	1135c440 	call	81135c44 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ac44:	0005303a 	rdctl	r2,status
8113ac48:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ac4c:	e0fff917 	ldw	r3,-28(fp)
8113ac50:	00bfff84 	movi	r2,-2
8113ac54:	1884703a 	and	r2,r3,r2
8113ac58:	1001703a 	wrctl	status,r2
  
  return context;
8113ac5c:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
8113ac60:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
8113ac64:	d0a09e17 	ldw	r2,-32136(gp)
8113ac68:	10800c43 	ldbu	r2,49(r2)
8113ac6c:	10803fcc 	andi	r2,r2,255
8113ac70:	10000326 	beq	r2,zero,8113ac80 <OSSemPend+0x18c>
8113ac74:	108000a0 	cmpeqi	r2,r2,2
8113ac78:	1000041e 	bne	r2,zero,8113ac8c <OSSemPend+0x198>
8113ac7c:	00000706 	br	8113ac9c <OSSemPend+0x1a8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
8113ac80:	e0bfff17 	ldw	r2,-4(fp)
8113ac84:	10000005 	stb	zero,0(r2)
             break;
8113ac88:	00000c06 	br	8113acbc <OSSemPend+0x1c8>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
8113ac8c:	e0bfff17 	ldw	r2,-4(fp)
8113ac90:	00c00384 	movi	r3,14
8113ac94:	10c00005 	stb	r3,0(r2)
             break;
8113ac98:	00000806 	br	8113acbc <OSSemPend+0x1c8>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
8113ac9c:	d0a09e17 	ldw	r2,-32136(gp)
8113aca0:	e17ffd17 	ldw	r5,-12(fp)
8113aca4:	1009883a 	mov	r4,r2
8113aca8:	11355980 	call	81135598 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
8113acac:	e0bfff17 	ldw	r2,-4(fp)
8113acb0:	00c00284 	movi	r3,10
8113acb4:	10c00005 	stb	r3,0(r2)
             break;
8113acb8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
8113acbc:	d0a09e17 	ldw	r2,-32136(gp)
8113acc0:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
8113acc4:	d0a09e17 	ldw	r2,-32136(gp)
8113acc8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
8113accc:	d0a09e17 	ldw	r2,-32136(gp)
8113acd0:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
8113acd4:	d0a09e17 	ldw	r2,-32136(gp)
8113acd8:	10000815 	stw	zero,32(r2)
8113acdc:	e0bff717 	ldw	r2,-36(fp)
8113ace0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ace4:	e0bffa17 	ldw	r2,-24(fp)
8113ace8:	1001703a 	wrctl	status,r2
8113acec:	00000106 	br	8113acf4 <OSSemPend+0x200>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113acf0:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
8113acf4:	e037883a 	mov	sp,fp
8113acf8:	dfc00117 	ldw	ra,4(sp)
8113acfc:	df000017 	ldw	fp,0(sp)
8113ad00:	dec00204 	addi	sp,sp,8
8113ad04:	f800283a 	ret

8113ad08 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
8113ad08:	defff604 	addi	sp,sp,-40
8113ad0c:	de00012e 	bgeu	sp,et,8113ad14 <OSSemPendAbort+0xc>
8113ad10:	003b68fa 	trap	3
8113ad14:	dfc00915 	stw	ra,36(sp)
8113ad18:	df000815 	stw	fp,32(sp)
8113ad1c:	df000804 	addi	fp,sp,32
8113ad20:	e13ffd15 	stw	r4,-12(fp)
8113ad24:	2805883a 	mov	r2,r5
8113ad28:	e1bfff15 	stw	r6,-4(fp)
8113ad2c:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ad30:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113ad34:	e0bfff17 	ldw	r2,-4(fp)
8113ad38:	1000021e 	bne	r2,zero,8113ad44 <OSSemPendAbort+0x3c>
        return (0);
8113ad3c:	0005883a 	mov	r2,zero
8113ad40:	00004906 	br	8113ae68 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ad44:	e0bffd17 	ldw	r2,-12(fp)
8113ad48:	1000051e 	bne	r2,zero,8113ad60 <OSSemPendAbort+0x58>
        *perr = OS_ERR_PEVENT_NULL;
8113ad4c:	e0bfff17 	ldw	r2,-4(fp)
8113ad50:	00c00104 	movi	r3,4
8113ad54:	10c00005 	stb	r3,0(r2)
        return (0);
8113ad58:	0005883a 	mov	r2,zero
8113ad5c:	00004206 	br	8113ae68 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113ad60:	e0bffd17 	ldw	r2,-12(fp)
8113ad64:	10800003 	ldbu	r2,0(r2)
8113ad68:	10803fcc 	andi	r2,r2,255
8113ad6c:	108000e0 	cmpeqi	r2,r2,3
8113ad70:	1000051e 	bne	r2,zero,8113ad88 <OSSemPendAbort+0x80>
        *perr = OS_ERR_EVENT_TYPE;
8113ad74:	e0bfff17 	ldw	r2,-4(fp)
8113ad78:	00c00044 	movi	r3,1
8113ad7c:	10c00005 	stb	r3,0(r2)
        return (0);
8113ad80:	0005883a 	mov	r2,zero
8113ad84:	00003806 	br	8113ae68 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ad88:	0005303a 	rdctl	r2,status
8113ad8c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ad90:	e0fffc17 	ldw	r3,-16(fp)
8113ad94:	00bfff84 	movi	r2,-2
8113ad98:	1884703a 	and	r2,r3,r2
8113ad9c:	1001703a 	wrctl	status,r2
  
  return context;
8113ada0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113ada4:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
8113ada8:	e0bffd17 	ldw	r2,-12(fp)
8113adac:	10800283 	ldbu	r2,10(r2)
8113adb0:	10803fcc 	andi	r2,r2,255
8113adb4:	10002526 	beq	r2,zero,8113ae4c <OSSemPendAbort+0x144>
        nbr_tasks = 0;
8113adb8:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
8113adbc:	e0bffe03 	ldbu	r2,-8(fp)
8113adc0:	10800060 	cmpeqi	r2,r2,1
8113adc4:	10000e26 	beq	r2,zero,8113ae00 <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113adc8:	00000806 	br	8113adec <OSSemPendAbort+0xe4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113adcc:	01c00084 	movi	r7,2
8113add0:	01800044 	movi	r6,1
8113add4:	000b883a 	mov	r5,zero
8113add8:	e13ffd17 	ldw	r4,-12(fp)
8113addc:	11351880 	call	81135188 <OS_EventTaskRdy>
                     nbr_tasks++;
8113ade0:	e0bff803 	ldbu	r2,-32(fp)
8113ade4:	10800044 	addi	r2,r2,1
8113ade8:	e0bff805 	stb	r2,-32(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
8113adec:	e0bffd17 	ldw	r2,-12(fp)
8113adf0:	10800283 	ldbu	r2,10(r2)
8113adf4:	10803fcc 	andi	r2,r2,255
8113adf8:	103ff41e 	bne	r2,zero,8113adcc <__reset+0xfb11adcc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
8113adfc:	00000906 	br	8113ae24 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
8113ae00:	01c00084 	movi	r7,2
8113ae04:	01800044 	movi	r6,1
8113ae08:	000b883a 	mov	r5,zero
8113ae0c:	e13ffd17 	ldw	r4,-12(fp)
8113ae10:	11351880 	call	81135188 <OS_EventTaskRdy>
                 nbr_tasks++;
8113ae14:	e0bff803 	ldbu	r2,-32(fp)
8113ae18:	10800044 	addi	r2,r2,1
8113ae1c:	e0bff805 	stb	r2,-32(fp)
                 break;
8113ae20:	0001883a 	nop
8113ae24:	e0bff917 	ldw	r2,-28(fp)
8113ae28:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ae2c:	e0bffa17 	ldw	r2,-24(fp)
8113ae30:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113ae34:	1135c440 	call	81135c44 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
8113ae38:	e0bfff17 	ldw	r2,-4(fp)
8113ae3c:	00c00384 	movi	r3,14
8113ae40:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
8113ae44:	e0bff803 	ldbu	r2,-32(fp)
8113ae48:	00000706 	br	8113ae68 <OSSemPendAbort+0x160>
8113ae4c:	e0bff917 	ldw	r2,-28(fp)
8113ae50:	e0bffb15 	stw	r2,-20(fp)
8113ae54:	e0bffb17 	ldw	r2,-20(fp)
8113ae58:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113ae5c:	e0bfff17 	ldw	r2,-4(fp)
8113ae60:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
8113ae64:	0005883a 	mov	r2,zero
}
8113ae68:	e037883a 	mov	sp,fp
8113ae6c:	dfc00117 	ldw	ra,4(sp)
8113ae70:	df000017 	ldw	fp,0(sp)
8113ae74:	dec00204 	addi	sp,sp,8
8113ae78:	f800283a 	ret

8113ae7c <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
8113ae7c:	defff804 	addi	sp,sp,-32
8113ae80:	de00012e 	bgeu	sp,et,8113ae88 <OSSemPost+0xc>
8113ae84:	003b68fa 	trap	3
8113ae88:	dfc00715 	stw	ra,28(sp)
8113ae8c:	df000615 	stw	fp,24(sp)
8113ae90:	df000604 	addi	fp,sp,24
8113ae94:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113ae98:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113ae9c:	e0bfff17 	ldw	r2,-4(fp)
8113aea0:	1000021e 	bne	r2,zero,8113aeac <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
8113aea4:	00800104 	movi	r2,4
8113aea8:	00003506 	br	8113af80 <OSSemPost+0x104>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113aeac:	e0bfff17 	ldw	r2,-4(fp)
8113aeb0:	10800003 	ldbu	r2,0(r2)
8113aeb4:	10803fcc 	andi	r2,r2,255
8113aeb8:	108000e0 	cmpeqi	r2,r2,3
8113aebc:	1000021e 	bne	r2,zero,8113aec8 <OSSemPost+0x4c>
        return (OS_ERR_EVENT_TYPE);
8113aec0:	00800044 	movi	r2,1
8113aec4:	00002e06 	br	8113af80 <OSSemPost+0x104>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aec8:	0005303a 	rdctl	r2,status
8113aecc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aed0:	e0fffe17 	ldw	r3,-8(fp)
8113aed4:	00bfff84 	movi	r2,-2
8113aed8:	1884703a 	and	r2,r3,r2
8113aedc:	1001703a 	wrctl	status,r2
  
  return context;
8113aee0:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113aee4:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
8113aee8:	e0bfff17 	ldw	r2,-4(fp)
8113aeec:	10800283 	ldbu	r2,10(r2)
8113aef0:	10803fcc 	andi	r2,r2,255
8113aef4:	10000c26 	beq	r2,zero,8113af28 <OSSemPost+0xac>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
8113aef8:	000f883a 	mov	r7,zero
8113aefc:	01800044 	movi	r6,1
8113af00:	000b883a 	mov	r5,zero
8113af04:	e13fff17 	ldw	r4,-4(fp)
8113af08:	11351880 	call	81135188 <OS_EventTaskRdy>
8113af0c:	e0bffa17 	ldw	r2,-24(fp)
8113af10:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113af14:	e0bffb17 	ldw	r2,-20(fp)
8113af18:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
8113af1c:	1135c440 	call	81135c44 <OS_Sched>
        return (OS_ERR_NONE);
8113af20:	0005883a 	mov	r2,zero
8113af24:	00001606 	br	8113af80 <OSSemPost+0x104>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
8113af28:	e0bfff17 	ldw	r2,-4(fp)
8113af2c:	1080020b 	ldhu	r2,8(r2)
8113af30:	10ffffcc 	andi	r3,r2,65535
8113af34:	00bfffd4 	movui	r2,65535
8113af38:	18800c26 	beq	r3,r2,8113af6c <OSSemPost+0xf0>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
8113af3c:	e0bfff17 	ldw	r2,-4(fp)
8113af40:	1080020b 	ldhu	r2,8(r2)
8113af44:	10800044 	addi	r2,r2,1
8113af48:	1007883a 	mov	r3,r2
8113af4c:	e0bfff17 	ldw	r2,-4(fp)
8113af50:	10c0020d 	sth	r3,8(r2)
8113af54:	e0bffa17 	ldw	r2,-24(fp)
8113af58:	e0bffc15 	stw	r2,-16(fp)
8113af5c:	e0bffc17 	ldw	r2,-16(fp)
8113af60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
8113af64:	0005883a 	mov	r2,zero
8113af68:	00000506 	br	8113af80 <OSSemPost+0x104>
8113af6c:	e0bffa17 	ldw	r2,-24(fp)
8113af70:	e0bffd15 	stw	r2,-12(fp)
8113af74:	e0bffd17 	ldw	r2,-12(fp)
8113af78:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
8113af7c:	00800c84 	movi	r2,50
}
8113af80:	e037883a 	mov	sp,fp
8113af84:	dfc00117 	ldw	ra,4(sp)
8113af88:	df000017 	ldw	fp,0(sp)
8113af8c:	dec00204 	addi	sp,sp,8
8113af90:	f800283a 	ret

8113af94 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
8113af94:	defff704 	addi	sp,sp,-36
8113af98:	de00012e 	bgeu	sp,et,8113afa0 <OSSemQuery+0xc>
8113af9c:	003b68fa 	trap	3
8113afa0:	df000815 	stw	fp,32(sp)
8113afa4:	df000804 	addi	fp,sp,32
8113afa8:	e13ffe15 	stw	r4,-8(fp)
8113afac:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
8113afb0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
8113afb4:	e0bffe17 	ldw	r2,-8(fp)
8113afb8:	1000021e 	bne	r2,zero,8113afc4 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
8113afbc:	00800104 	movi	r2,4
8113afc0:	00003606 	br	8113b09c <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
8113afc4:	e0bfff17 	ldw	r2,-4(fp)
8113afc8:	1000021e 	bne	r2,zero,8113afd4 <OSSemQuery+0x40>
        return (OS_ERR_PDATA_NULL);
8113afcc:	00800244 	movi	r2,9
8113afd0:	00003206 	br	8113b09c <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
8113afd4:	e0bffe17 	ldw	r2,-8(fp)
8113afd8:	10800003 	ldbu	r2,0(r2)
8113afdc:	10803fcc 	andi	r2,r2,255
8113afe0:	108000e0 	cmpeqi	r2,r2,3
8113afe4:	1000021e 	bne	r2,zero,8113aff0 <OSSemQuery+0x5c>
        return (OS_ERR_EVENT_TYPE);
8113afe8:	00800044 	movi	r2,1
8113afec:	00002b06 	br	8113b09c <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113aff0:	0005303a 	rdctl	r2,status
8113aff4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113aff8:	e0fffd17 	ldw	r3,-12(fp)
8113affc:	00bfff84 	movi	r2,-2
8113b000:	1884703a 	and	r2,r3,r2
8113b004:	1001703a 	wrctl	status,r2
  
  return context;
8113b008:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
8113b00c:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
8113b010:	e0bffe17 	ldw	r2,-8(fp)
8113b014:	10c00283 	ldbu	r3,10(r2)
8113b018:	e0bfff17 	ldw	r2,-4(fp)
8113b01c:	10c00205 	stb	r3,8(r2)
    psrc                   = &pevent->OSEventTbl[0];
8113b020:	e0bffe17 	ldw	r2,-8(fp)
8113b024:	108002c4 	addi	r2,r2,11
8113b028:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
8113b02c:	e0bfff17 	ldw	r2,-4(fp)
8113b030:	10800084 	addi	r2,r2,2
8113b034:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b038:	e03ffa05 	stb	zero,-24(fp)
8113b03c:	00000b06 	br	8113b06c <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
8113b040:	e0bff917 	ldw	r2,-28(fp)
8113b044:	10c00044 	addi	r3,r2,1
8113b048:	e0fff915 	stw	r3,-28(fp)
8113b04c:	e0fff817 	ldw	r3,-32(fp)
8113b050:	19000044 	addi	r4,r3,1
8113b054:	e13ff815 	stw	r4,-32(fp)
8113b058:	18c00003 	ldbu	r3,0(r3)
8113b05c:	10c00005 	stb	r3,0(r2)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
8113b060:	e0bffa03 	ldbu	r2,-24(fp)
8113b064:	10800044 	addi	r2,r2,1
8113b068:	e0bffa05 	stb	r2,-24(fp)
8113b06c:	e0bffa03 	ldbu	r2,-24(fp)
8113b070:	108001b0 	cmpltui	r2,r2,6
8113b074:	103ff21e 	bne	r2,zero,8113b040 <__reset+0xfb11b040>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
8113b078:	e0bffe17 	ldw	r2,-8(fp)
8113b07c:	10c0020b 	ldhu	r3,8(r2)
8113b080:	e0bfff17 	ldw	r2,-4(fp)
8113b084:	10c0000d 	sth	r3,0(r2)
8113b088:	e0bffb17 	ldw	r2,-20(fp)
8113b08c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b090:	e0bffc17 	ldw	r2,-16(fp)
8113b094:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113b098:	0005883a 	mov	r2,zero
}
8113b09c:	e037883a 	mov	sp,fp
8113b0a0:	df000017 	ldw	fp,0(sp)
8113b0a4:	dec00104 	addi	sp,sp,4
8113b0a8:	f800283a 	ret

8113b0ac <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
8113b0ac:	defff904 	addi	sp,sp,-28
8113b0b0:	de00012e 	bgeu	sp,et,8113b0b8 <OSSemSet+0xc>
8113b0b4:	003b68fa 	trap	3
8113b0b8:	df000615 	stw	fp,24(sp)
8113b0bc:	df000604 	addi	fp,sp,24
8113b0c0:	e13ffd15 	stw	r4,-12(fp)
8113b0c4:	2805883a 	mov	r2,r5
8113b0c8:	e1bfff15 	stw	r6,-4(fp)
8113b0cc:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113b0d0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
8113b0d4:	e0bfff17 	ldw	r2,-4(fp)
8113b0d8:	10003126 	beq	r2,zero,8113b1a0 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
8113b0dc:	e0bffd17 	ldw	r2,-12(fp)
8113b0e0:	1000041e 	bne	r2,zero,8113b0f4 <OSSemSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
8113b0e4:	e0bfff17 	ldw	r2,-4(fp)
8113b0e8:	00c00104 	movi	r3,4
8113b0ec:	10c00005 	stb	r3,0(r2)
        return;
8113b0f0:	00002c06 	br	8113b1a4 <OSSemSet+0xf8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
8113b0f4:	e0bffd17 	ldw	r2,-12(fp)
8113b0f8:	10800003 	ldbu	r2,0(r2)
8113b0fc:	10803fcc 	andi	r2,r2,255
8113b100:	108000e0 	cmpeqi	r2,r2,3
8113b104:	1000041e 	bne	r2,zero,8113b118 <OSSemSet+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
8113b108:	e0bfff17 	ldw	r2,-4(fp)
8113b10c:	00c00044 	movi	r3,1
8113b110:	10c00005 	stb	r3,0(r2)
        return;
8113b114:	00002306 	br	8113b1a4 <OSSemSet+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b118:	0005303a 	rdctl	r2,status
8113b11c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b120:	e0fffc17 	ldw	r3,-16(fp)
8113b124:	00bfff84 	movi	r2,-2
8113b128:	1884703a 	and	r2,r3,r2
8113b12c:	1001703a 	wrctl	status,r2
  
  return context;
8113b130:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113b134:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
8113b138:	e0bfff17 	ldw	r2,-4(fp)
8113b13c:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
8113b140:	e0bffd17 	ldw	r2,-12(fp)
8113b144:	1080020b 	ldhu	r2,8(r2)
8113b148:	10bfffcc 	andi	r2,r2,65535
8113b14c:	10000426 	beq	r2,zero,8113b160 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
8113b150:	e0bffd17 	ldw	r2,-12(fp)
8113b154:	e0fffe0b 	ldhu	r3,-8(fp)
8113b158:	10c0020d 	sth	r3,8(r2)
8113b15c:	00000b06 	br	8113b18c <OSSemSet+0xe0>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
8113b160:	e0bffd17 	ldw	r2,-12(fp)
8113b164:	10800283 	ldbu	r2,10(r2)
8113b168:	10803fcc 	andi	r2,r2,255
8113b16c:	1000041e 	bne	r2,zero,8113b180 <OSSemSet+0xd4>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
8113b170:	e0bffd17 	ldw	r2,-12(fp)
8113b174:	e0fffe0b 	ldhu	r3,-8(fp)
8113b178:	10c0020d 	sth	r3,8(r2)
8113b17c:	00000306 	br	8113b18c <OSSemSet+0xe0>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
8113b180:	e0bfff17 	ldw	r2,-4(fp)
8113b184:	00c01244 	movi	r3,73
8113b188:	10c00005 	stb	r3,0(r2)
8113b18c:	e0bffa17 	ldw	r2,-24(fp)
8113b190:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b194:	e0bffb17 	ldw	r2,-20(fp)
8113b198:	1001703a 	wrctl	status,r2
8113b19c:	00000106 	br	8113b1a4 <OSSemSet+0xf8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
8113b1a0:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
8113b1a4:	e037883a 	mov	sp,fp
8113b1a8:	df000017 	ldw	fp,0(sp)
8113b1ac:	dec00104 	addi	sp,sp,4
8113b1b0:	f800283a 	ret

8113b1b4 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
8113b1b4:	defff104 	addi	sp,sp,-60
8113b1b8:	de00012e 	bgeu	sp,et,8113b1c0 <OSTaskChangePrio+0xc>
8113b1bc:	003b68fa 	trap	3
8113b1c0:	dfc00e15 	stw	ra,56(sp)
8113b1c4:	df000d15 	stw	fp,52(sp)
8113b1c8:	df000d04 	addi	fp,sp,52
8113b1cc:	2007883a 	mov	r3,r4
8113b1d0:	2805883a 	mov	r2,r5
8113b1d4:	e0fffe05 	stb	r3,-8(fp)
8113b1d8:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
8113b1dc:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
8113b1e0:	e0bffe03 	ldbu	r2,-8(fp)
8113b1e4:	10800ab0 	cmpltui	r2,r2,42
8113b1e8:	1000051e 	bne	r2,zero,8113b200 <OSTaskChangePrio+0x4c>
        if (oldprio != OS_PRIO_SELF) {
8113b1ec:	e0bffe03 	ldbu	r2,-8(fp)
8113b1f0:	10803fe0 	cmpeqi	r2,r2,255
8113b1f4:	1000021e 	bne	r2,zero,8113b200 <OSTaskChangePrio+0x4c>
            return (OS_ERR_PRIO_INVALID);
8113b1f8:	00800a84 	movi	r2,42
8113b1fc:	00012606 	br	8113b698 <OSTaskChangePrio+0x4e4>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
8113b200:	e0bfff03 	ldbu	r2,-4(fp)
8113b204:	10800ab0 	cmpltui	r2,r2,42
8113b208:	1000021e 	bne	r2,zero,8113b214 <OSTaskChangePrio+0x60>
        return (OS_ERR_PRIO_INVALID);
8113b20c:	00800a84 	movi	r2,42
8113b210:	00012106 	br	8113b698 <OSTaskChangePrio+0x4e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b214:	0005303a 	rdctl	r2,status
8113b218:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b21c:	e0fffd17 	ldw	r3,-12(fp)
8113b220:	00bfff84 	movi	r2,-2
8113b224:	1884703a 	and	r2,r3,r2
8113b228:	1001703a 	wrctl	status,r2
  
  return context;
8113b22c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b230:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
8113b234:	e0ffff03 	ldbu	r3,-4(fp)
8113b238:	00a045f4 	movhi	r2,33047
8113b23c:	10a10004 	addi	r2,r2,-31744
8113b240:	18c7883a 	add	r3,r3,r3
8113b244:	18c7883a 	add	r3,r3,r3
8113b248:	10c5883a 	add	r2,r2,r3
8113b24c:	10800017 	ldw	r2,0(r2)
8113b250:	10000626 	beq	r2,zero,8113b26c <OSTaskChangePrio+0xb8>
8113b254:	e0bff517 	ldw	r2,-44(fp)
8113b258:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b25c:	e0bff617 	ldw	r2,-40(fp)
8113b260:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
8113b264:	00800a04 	movi	r2,40
8113b268:	00010b06 	br	8113b698 <OSTaskChangePrio+0x4e4>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
8113b26c:	e0bffe03 	ldbu	r2,-8(fp)
8113b270:	10803fd8 	cmpnei	r2,r2,255
8113b274:	1000031e 	bne	r2,zero,8113b284 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
8113b278:	d0a09e17 	ldw	r2,-32136(gp)
8113b27c:	10800c83 	ldbu	r2,50(r2)
8113b280:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
8113b284:	e0fffe03 	ldbu	r3,-8(fp)
8113b288:	00a045f4 	movhi	r2,33047
8113b28c:	10a10004 	addi	r2,r2,-31744
8113b290:	18c7883a 	add	r3,r3,r3
8113b294:	18c7883a 	add	r3,r3,r3
8113b298:	10c5883a 	add	r2,r2,r3
8113b29c:	10800017 	ldw	r2,0(r2)
8113b2a0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
8113b2a4:	e0bff817 	ldw	r2,-32(fp)
8113b2a8:	1000061e 	bne	r2,zero,8113b2c4 <OSTaskChangePrio+0x110>
8113b2ac:	e0bff517 	ldw	r2,-44(fp)
8113b2b0:	e0bff715 	stw	r2,-36(fp)
8113b2b4:	e0bff717 	ldw	r2,-36(fp)
8113b2b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
8113b2bc:	00800a44 	movi	r2,41
8113b2c0:	0000f506 	br	8113b698 <OSTaskChangePrio+0x4e4>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
8113b2c4:	e0bff817 	ldw	r2,-32(fp)
8113b2c8:	10800058 	cmpnei	r2,r2,1
8113b2cc:	1000061e 	bne	r2,zero,8113b2e8 <OSTaskChangePrio+0x134>
8113b2d0:	e0bff517 	ldw	r2,-44(fp)
8113b2d4:	e0bff915 	stw	r2,-28(fp)
8113b2d8:	e0bff917 	ldw	r2,-28(fp)
8113b2dc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
8113b2e0:	008010c4 	movi	r2,67
8113b2e4:	0000ec06 	br	8113b698 <OSTaskChangePrio+0x4e4>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
8113b2e8:	e0bfff03 	ldbu	r2,-4(fp)
8113b2ec:	1004d0fa 	srli	r2,r2,3
8113b2f0:	e0bffb05 	stb	r2,-20(fp)
    x_new                 = (INT8U)(newprio & 0x07);
8113b2f4:	e0bfff03 	ldbu	r2,-4(fp)
8113b2f8:	108001cc 	andi	r2,r2,7
8113b2fc:	e0bffb45 	stb	r2,-19(fp)
    bity_new              = (INT8U)(1 << y_new);
8113b300:	e0bffb03 	ldbu	r2,-20(fp)
8113b304:	00c00044 	movi	r3,1
8113b308:	1884983a 	sll	r2,r3,r2
8113b30c:	e0bffb85 	stb	r2,-18(fp)
    bitx_new              = (INT8U)(1 << x_new);
8113b310:	e0bffb43 	ldbu	r2,-19(fp)
8113b314:	00c00044 	movi	r3,1
8113b318:	1884983a 	sll	r2,r3,r2
8113b31c:	e0bffbc5 	stb	r2,-17(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
8113b320:	e0fffe03 	ldbu	r3,-8(fp)
8113b324:	00a045f4 	movhi	r2,33047
8113b328:	10a10004 	addi	r2,r2,-31744
8113b32c:	18c7883a 	add	r3,r3,r3
8113b330:	18c7883a 	add	r3,r3,r3
8113b334:	10c5883a 	add	r2,r2,r3
8113b338:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
8113b33c:	e0ffff03 	ldbu	r3,-4(fp)
8113b340:	00a045f4 	movhi	r2,33047
8113b344:	10a10004 	addi	r2,r2,-31744
8113b348:	18c7883a 	add	r3,r3,r3
8113b34c:	18c7883a 	add	r3,r3,r3
8113b350:	10c5883a 	add	r2,r2,r3
8113b354:	e0fff817 	ldw	r3,-32(fp)
8113b358:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
8113b35c:	e0bff817 	ldw	r2,-32(fp)
8113b360:	10800d03 	ldbu	r2,52(r2)
8113b364:	e0bffc05 	stb	r2,-16(fp)
    bity_old              =  ptcb->OSTCBBitY;
8113b368:	e0bff817 	ldw	r2,-32(fp)
8113b36c:	10800d83 	ldbu	r2,54(r2)
8113b370:	e0bffc45 	stb	r2,-15(fp)
    bitx_old              =  ptcb->OSTCBBitX;
8113b374:	e0bff817 	ldw	r2,-32(fp)
8113b378:	10800d43 	ldbu	r2,53(r2)
8113b37c:	e0bffc85 	stb	r2,-14(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
8113b380:	e0fffc03 	ldbu	r3,-16(fp)
8113b384:	d0a09a44 	addi	r2,gp,-32151
8113b388:	1885883a 	add	r2,r3,r2
8113b38c:	10c00003 	ldbu	r3,0(r2)
8113b390:	e0bffc83 	ldbu	r2,-14(fp)
8113b394:	1884703a 	and	r2,r3,r2
8113b398:	10803fcc 	andi	r2,r2,255
8113b39c:	10002826 	beq	r2,zero,8113b440 <OSTaskChangePrio+0x28c>
         OSRdyTbl[y_old] &= ~bitx_old;
8113b3a0:	e0fffc03 	ldbu	r3,-16(fp)
8113b3a4:	e13ffc03 	ldbu	r4,-16(fp)
8113b3a8:	d0a09a44 	addi	r2,gp,-32151
8113b3ac:	2085883a 	add	r2,r4,r2
8113b3b0:	10800003 	ldbu	r2,0(r2)
8113b3b4:	1009883a 	mov	r4,r2
8113b3b8:	e0bffc83 	ldbu	r2,-14(fp)
8113b3bc:	0084303a 	nor	r2,zero,r2
8113b3c0:	2084703a 	and	r2,r4,r2
8113b3c4:	1009883a 	mov	r4,r2
8113b3c8:	d0a09a44 	addi	r2,gp,-32151
8113b3cc:	1885883a 	add	r2,r3,r2
8113b3d0:	11000005 	stb	r4,0(r2)
         if (OSRdyTbl[y_old] == 0) {
8113b3d4:	e0fffc03 	ldbu	r3,-16(fp)
8113b3d8:	d0a09a44 	addi	r2,gp,-32151
8113b3dc:	1885883a 	add	r2,r3,r2
8113b3e0:	10800003 	ldbu	r2,0(r2)
8113b3e4:	10803fcc 	andi	r2,r2,255
8113b3e8:	1000061e 	bne	r2,zero,8113b404 <OSTaskChangePrio+0x250>
             OSRdyGrp &= ~bity_old;
8113b3ec:	e0bffc43 	ldbu	r2,-15(fp)
8113b3f0:	0084303a 	nor	r2,zero,r2
8113b3f4:	1007883a 	mov	r3,r2
8113b3f8:	d0a09a03 	ldbu	r2,-32152(gp)
8113b3fc:	1884703a 	and	r2,r3,r2
8113b400:	d0a09a05 	stb	r2,-32152(gp)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
8113b404:	d0e09a03 	ldbu	r3,-32152(gp)
8113b408:	e0bffb83 	ldbu	r2,-18(fp)
8113b40c:	1884b03a 	or	r2,r3,r2
8113b410:	d0a09a05 	stb	r2,-32152(gp)
         OSRdyTbl[y_new] |= bitx_new;
8113b414:	e0fffb03 	ldbu	r3,-20(fp)
8113b418:	e13ffb03 	ldbu	r4,-20(fp)
8113b41c:	d0a09a44 	addi	r2,gp,-32151
8113b420:	2085883a 	add	r2,r4,r2
8113b424:	11000003 	ldbu	r4,0(r2)
8113b428:	e0bffbc3 	ldbu	r2,-17(fp)
8113b42c:	2084b03a 	or	r2,r4,r2
8113b430:	1009883a 	mov	r4,r2
8113b434:	d0a09a44 	addi	r2,gp,-32151
8113b438:	1885883a 	add	r2,r3,r2
8113b43c:	11000005 	stb	r4,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
8113b440:	e0bff817 	ldw	r2,-32(fp)
8113b444:	10800717 	ldw	r2,28(r2)
8113b448:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
8113b44c:	e0bff317 	ldw	r2,-52(fp)
8113b450:	10003326 	beq	r2,zero,8113b520 <OSTaskChangePrio+0x36c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
8113b454:	e0bffc03 	ldbu	r2,-16(fp)
8113b458:	e0fffc03 	ldbu	r3,-16(fp)
8113b45c:	e13ff317 	ldw	r4,-52(fp)
8113b460:	20c7883a 	add	r3,r4,r3
8113b464:	18c002c4 	addi	r3,r3,11
8113b468:	18c00003 	ldbu	r3,0(r3)
8113b46c:	1809883a 	mov	r4,r3
8113b470:	e0fffc83 	ldbu	r3,-14(fp)
8113b474:	00c6303a 	nor	r3,zero,r3
8113b478:	20c6703a 	and	r3,r4,r3
8113b47c:	1809883a 	mov	r4,r3
8113b480:	e0fff317 	ldw	r3,-52(fp)
8113b484:	1885883a 	add	r2,r3,r2
8113b488:	108002c4 	addi	r2,r2,11
8113b48c:	11000005 	stb	r4,0(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
8113b490:	e0bffc03 	ldbu	r2,-16(fp)
8113b494:	e0fff317 	ldw	r3,-52(fp)
8113b498:	1885883a 	add	r2,r3,r2
8113b49c:	108002c4 	addi	r2,r2,11
8113b4a0:	10800003 	ldbu	r2,0(r2)
8113b4a4:	10803fcc 	andi	r2,r2,255
8113b4a8:	1000091e 	bne	r2,zero,8113b4d0 <OSTaskChangePrio+0x31c>
            pevent->OSEventGrp    &= ~bity_old;
8113b4ac:	e0bff317 	ldw	r2,-52(fp)
8113b4b0:	10800283 	ldbu	r2,10(r2)
8113b4b4:	1007883a 	mov	r3,r2
8113b4b8:	e0bffc43 	ldbu	r2,-15(fp)
8113b4bc:	0084303a 	nor	r2,zero,r2
8113b4c0:	1884703a 	and	r2,r3,r2
8113b4c4:	1007883a 	mov	r3,r2
8113b4c8:	e0bff317 	ldw	r2,-52(fp)
8113b4cc:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
8113b4d0:	e0bff317 	ldw	r2,-52(fp)
8113b4d4:	10c00283 	ldbu	r3,10(r2)
8113b4d8:	e0bffb83 	ldbu	r2,-18(fp)
8113b4dc:	1884b03a 	or	r2,r3,r2
8113b4e0:	1007883a 	mov	r3,r2
8113b4e4:	e0bff317 	ldw	r2,-52(fp)
8113b4e8:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
8113b4ec:	e0bffb03 	ldbu	r2,-20(fp)
8113b4f0:	e0fffb03 	ldbu	r3,-20(fp)
8113b4f4:	e13ff317 	ldw	r4,-52(fp)
8113b4f8:	20c7883a 	add	r3,r4,r3
8113b4fc:	18c002c4 	addi	r3,r3,11
8113b500:	19000003 	ldbu	r4,0(r3)
8113b504:	e0fffbc3 	ldbu	r3,-17(fp)
8113b508:	20c6b03a 	or	r3,r4,r3
8113b50c:	1809883a 	mov	r4,r3
8113b510:	e0fff317 	ldw	r3,-52(fp)
8113b514:	1885883a 	add	r2,r3,r2
8113b518:	108002c4 	addi	r2,r2,11
8113b51c:	11000005 	stb	r4,0(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
8113b520:	e0bff817 	ldw	r2,-32(fp)
8113b524:	10800817 	ldw	r2,32(r2)
8113b528:	10004226 	beq	r2,zero,8113b634 <OSTaskChangePrio+0x480>
        pevents =  ptcb->OSTCBEventMultiPtr;
8113b52c:	e0bff817 	ldw	r2,-32(fp)
8113b530:	10800817 	ldw	r2,32(r2)
8113b534:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
8113b538:	e0bff417 	ldw	r2,-48(fp)
8113b53c:	10800017 	ldw	r2,0(r2)
8113b540:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
8113b544:	00003906 	br	8113b62c <OSTaskChangePrio+0x478>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
8113b548:	e0bffc03 	ldbu	r2,-16(fp)
8113b54c:	e0fffc03 	ldbu	r3,-16(fp)
8113b550:	e13ff317 	ldw	r4,-52(fp)
8113b554:	20c7883a 	add	r3,r4,r3
8113b558:	18c002c4 	addi	r3,r3,11
8113b55c:	18c00003 	ldbu	r3,0(r3)
8113b560:	1809883a 	mov	r4,r3
8113b564:	e0fffc83 	ldbu	r3,-14(fp)
8113b568:	00c6303a 	nor	r3,zero,r3
8113b56c:	20c6703a 	and	r3,r4,r3
8113b570:	1809883a 	mov	r4,r3
8113b574:	e0fff317 	ldw	r3,-52(fp)
8113b578:	1885883a 	add	r2,r3,r2
8113b57c:	108002c4 	addi	r2,r2,11
8113b580:	11000005 	stb	r4,0(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
8113b584:	e0bffc03 	ldbu	r2,-16(fp)
8113b588:	e0fff317 	ldw	r3,-52(fp)
8113b58c:	1885883a 	add	r2,r3,r2
8113b590:	108002c4 	addi	r2,r2,11
8113b594:	10800003 	ldbu	r2,0(r2)
8113b598:	10803fcc 	andi	r2,r2,255
8113b59c:	1000091e 	bne	r2,zero,8113b5c4 <OSTaskChangePrio+0x410>
                pevent->OSEventGrp    &= ~bity_old;
8113b5a0:	e0bff317 	ldw	r2,-52(fp)
8113b5a4:	10800283 	ldbu	r2,10(r2)
8113b5a8:	1007883a 	mov	r3,r2
8113b5ac:	e0bffc43 	ldbu	r2,-15(fp)
8113b5b0:	0084303a 	nor	r2,zero,r2
8113b5b4:	1884703a 	and	r2,r3,r2
8113b5b8:	1007883a 	mov	r3,r2
8113b5bc:	e0bff317 	ldw	r2,-52(fp)
8113b5c0:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
8113b5c4:	e0bff317 	ldw	r2,-52(fp)
8113b5c8:	10c00283 	ldbu	r3,10(r2)
8113b5cc:	e0bffb83 	ldbu	r2,-18(fp)
8113b5d0:	1884b03a 	or	r2,r3,r2
8113b5d4:	1007883a 	mov	r3,r2
8113b5d8:	e0bff317 	ldw	r2,-52(fp)
8113b5dc:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
8113b5e0:	e0bffb03 	ldbu	r2,-20(fp)
8113b5e4:	e0fffb03 	ldbu	r3,-20(fp)
8113b5e8:	e13ff317 	ldw	r4,-52(fp)
8113b5ec:	20c7883a 	add	r3,r4,r3
8113b5f0:	18c002c4 	addi	r3,r3,11
8113b5f4:	19000003 	ldbu	r4,0(r3)
8113b5f8:	e0fffbc3 	ldbu	r3,-17(fp)
8113b5fc:	20c6b03a 	or	r3,r4,r3
8113b600:	1809883a 	mov	r4,r3
8113b604:	e0fff317 	ldw	r3,-52(fp)
8113b608:	1885883a 	add	r2,r3,r2
8113b60c:	108002c4 	addi	r2,r2,11
8113b610:	11000005 	stb	r4,0(r2)
            pevents++;
8113b614:	e0bff417 	ldw	r2,-48(fp)
8113b618:	10800104 	addi	r2,r2,4
8113b61c:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
8113b620:	e0bff417 	ldw	r2,-48(fp)
8113b624:	10800017 	ldw	r2,0(r2)
8113b628:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
8113b62c:	e0bff317 	ldw	r2,-52(fp)
8113b630:	103fc51e 	bne	r2,zero,8113b548 <__reset+0xfb11b548>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
8113b634:	e0bff817 	ldw	r2,-32(fp)
8113b638:	e0ffff03 	ldbu	r3,-4(fp)
8113b63c:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
8113b640:	e0bff817 	ldw	r2,-32(fp)
8113b644:	e0fffb03 	ldbu	r3,-20(fp)
8113b648:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
8113b64c:	e0bff817 	ldw	r2,-32(fp)
8113b650:	e0fffb43 	ldbu	r3,-19(fp)
8113b654:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
8113b658:	e0bff817 	ldw	r2,-32(fp)
8113b65c:	e0fffb83 	ldbu	r3,-18(fp)
8113b660:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
8113b664:	e0bff817 	ldw	r2,-32(fp)
8113b668:	e0fffbc3 	ldbu	r3,-17(fp)
8113b66c:	10c00d45 	stb	r3,53(r2)
8113b670:	e0bff517 	ldw	r2,-44(fp)
8113b674:	e0bffa15 	stw	r2,-24(fp)
8113b678:	e0bffa17 	ldw	r2,-24(fp)
8113b67c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113b680:	d0a08d03 	ldbu	r2,-32204(gp)
8113b684:	10803fcc 	andi	r2,r2,255
8113b688:	10800058 	cmpnei	r2,r2,1
8113b68c:	1000011e 	bne	r2,zero,8113b694 <OSTaskChangePrio+0x4e0>
        OS_Sched();                                         /* Find new highest priority task          */
8113b690:	1135c440 	call	81135c44 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113b694:	0005883a 	mov	r2,zero
}
8113b698:	e037883a 	mov	sp,fp
8113b69c:	dfc00117 	ldw	ra,4(sp)
8113b6a0:	df000017 	ldw	fp,0(sp)
8113b6a4:	dec00204 	addi	sp,sp,8
8113b6a8:	f800283a 	ret

8113b6ac <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
8113b6ac:	deffee04 	addi	sp,sp,-72
8113b6b0:	de00012e 	bgeu	sp,et,8113b6b8 <OSTaskCreate+0xc>
8113b6b4:	003b68fa 	trap	3
8113b6b8:	dfc01115 	stw	ra,68(sp)
8113b6bc:	df001015 	stw	fp,64(sp)
8113b6c0:	df001004 	addi	fp,sp,64
8113b6c4:	e13ffc15 	stw	r4,-16(fp)
8113b6c8:	e17ffd15 	stw	r5,-12(fp)
8113b6cc:	e1bffe15 	stw	r6,-8(fp)
8113b6d0:	3805883a 	mov	r2,r7
8113b6d4:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113b6d8:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113b6dc:	e0bfff03 	ldbu	r2,-4(fp)
8113b6e0:	10800af0 	cmpltui	r2,r2,43
8113b6e4:	1000021e 	bne	r2,zero,8113b6f0 <OSTaskCreate+0x44>
        return (OS_ERR_PRIO_INVALID);
8113b6e8:	00800a84 	movi	r2,42
8113b6ec:	00005706 	br	8113b84c <OSTaskCreate+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b6f0:	0005303a 	rdctl	r2,status
8113b6f4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b6f8:	e0fffb17 	ldw	r3,-20(fp)
8113b6fc:	00bfff84 	movi	r2,-2
8113b700:	1884703a 	and	r2,r3,r2
8113b704:	1001703a 	wrctl	status,r2
  
  return context;
8113b708:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b70c:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113b710:	d0a09d03 	ldbu	r2,-32140(gp)
8113b714:	10803fcc 	andi	r2,r2,255
8113b718:	10000626 	beq	r2,zero,8113b734 <OSTaskCreate+0x88>
8113b71c:	e0bff317 	ldw	r2,-52(fp)
8113b720:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b724:	e0bff417 	ldw	r2,-48(fp)
8113b728:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113b72c:	00800f04 	movi	r2,60
8113b730:	00004606 	br	8113b84c <OSTaskCreate+0x1a0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113b734:	e0ffff03 	ldbu	r3,-4(fp)
8113b738:	00a045f4 	movhi	r2,33047
8113b73c:	10a10004 	addi	r2,r2,-31744
8113b740:	18c7883a 	add	r3,r3,r3
8113b744:	18c7883a 	add	r3,r3,r3
8113b748:	10c5883a 	add	r2,r2,r3
8113b74c:	10800017 	ldw	r2,0(r2)
8113b750:	1000391e 	bne	r2,zero,8113b838 <OSTaskCreate+0x18c>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113b754:	e0ffff03 	ldbu	r3,-4(fp)
8113b758:	00a045f4 	movhi	r2,33047
8113b75c:	10a10004 	addi	r2,r2,-31744
8113b760:	18c7883a 	add	r3,r3,r3
8113b764:	18c7883a 	add	r3,r3,r3
8113b768:	10c5883a 	add	r2,r2,r3
8113b76c:	00c00044 	movi	r3,1
8113b770:	10c00015 	stw	r3,0(r2)
8113b774:	e0bff317 	ldw	r2,-52(fp)
8113b778:	e0bff515 	stw	r2,-44(fp)
8113b77c:	e0bff517 	ldw	r2,-44(fp)
8113b780:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
8113b784:	000f883a 	mov	r7,zero
8113b788:	e1bffe17 	ldw	r6,-8(fp)
8113b78c:	e17ffd17 	ldw	r5,-12(fp)
8113b790:	e13ffc17 	ldw	r4,-16(fp)
8113b794:	1146d540 	call	81146d54 <OSTaskStkInit>
8113b798:	e0bff715 	stw	r2,-36(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
8113b79c:	e0bfff03 	ldbu	r2,-4(fp)
8113b7a0:	d8000215 	stw	zero,8(sp)
8113b7a4:	d8000115 	stw	zero,4(sp)
8113b7a8:	d8000015 	stw	zero,0(sp)
8113b7ac:	000f883a 	mov	r7,zero
8113b7b0:	000d883a 	mov	r6,zero
8113b7b4:	e17ff717 	ldw	r5,-36(fp)
8113b7b8:	1009883a 	mov	r4,r2
8113b7bc:	113608c0 	call	8113608c <OS_TCBInit>
8113b7c0:	e0bff805 	stb	r2,-32(fp)
        if (err == OS_ERR_NONE) {
8113b7c4:	e0bff803 	ldbu	r2,-32(fp)
8113b7c8:	1000061e 	bne	r2,zero,8113b7e4 <OSTaskCreate+0x138>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
8113b7cc:	d0a08d03 	ldbu	r2,-32204(gp)
8113b7d0:	10803fcc 	andi	r2,r2,255
8113b7d4:	10800058 	cmpnei	r2,r2,1
8113b7d8:	1000151e 	bne	r2,zero,8113b830 <OSTaskCreate+0x184>
                OS_Sched();
8113b7dc:	1135c440 	call	81135c44 <OS_Sched>
8113b7e0:	00001306 	br	8113b830 <OSTaskCreate+0x184>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b7e4:	0005303a 	rdctl	r2,status
8113b7e8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b7ec:	e0fffa17 	ldw	r3,-24(fp)
8113b7f0:	00bfff84 	movi	r2,-2
8113b7f4:	1884703a 	and	r2,r3,r2
8113b7f8:	1001703a 	wrctl	status,r2
  
  return context;
8113b7fc:	e0bffa17 	ldw	r2,-24(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113b800:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
8113b804:	e0ffff03 	ldbu	r3,-4(fp)
8113b808:	00a045f4 	movhi	r2,33047
8113b80c:	10a10004 	addi	r2,r2,-31744
8113b810:	18c7883a 	add	r3,r3,r3
8113b814:	18c7883a 	add	r3,r3,r3
8113b818:	10c5883a 	add	r2,r2,r3
8113b81c:	10000015 	stw	zero,0(r2)
8113b820:	e0bff317 	ldw	r2,-52(fp)
8113b824:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b828:	e0bff617 	ldw	r2,-40(fp)
8113b82c:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113b830:	e0bff803 	ldbu	r2,-32(fp)
8113b834:	00000506 	br	8113b84c <OSTaskCreate+0x1a0>
8113b838:	e0bff317 	ldw	r2,-52(fp)
8113b83c:	e0bff915 	stw	r2,-28(fp)
8113b840:	e0bff917 	ldw	r2,-28(fp)
8113b844:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113b848:	00800a04 	movi	r2,40
}
8113b84c:	e037883a 	mov	sp,fp
8113b850:	dfc00117 	ldw	ra,4(sp)
8113b854:	df000017 	ldw	fp,0(sp)
8113b858:	dec00204 	addi	sp,sp,8
8113b85c:	f800283a 	ret

8113b860 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
8113b860:	deffec04 	addi	sp,sp,-80
8113b864:	de00012e 	bgeu	sp,et,8113b86c <OSTaskCreateExt+0xc>
8113b868:	003b68fa 	trap	3
8113b86c:	dfc01315 	stw	ra,76(sp)
8113b870:	df001215 	stw	fp,72(sp)
8113b874:	df001204 	addi	fp,sp,72
8113b878:	e13ffa15 	stw	r4,-24(fp)
8113b87c:	e17ffb15 	stw	r5,-20(fp)
8113b880:	e1bffc15 	stw	r6,-16(fp)
8113b884:	3809883a 	mov	r4,r7
8113b888:	e0c00217 	ldw	r3,8(fp)
8113b88c:	e0800617 	ldw	r2,24(fp)
8113b890:	e13ffd05 	stb	r4,-12(fp)
8113b894:	e0fffe0d 	sth	r3,-8(fp)
8113b898:	e0bfff0d 	sth	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
8113b89c:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
8113b8a0:	e0bffd03 	ldbu	r2,-12(fp)
8113b8a4:	10800af0 	cmpltui	r2,r2,43
8113b8a8:	1000021e 	bne	r2,zero,8113b8b4 <OSTaskCreateExt+0x54>
        return (OS_ERR_PRIO_INVALID);
8113b8ac:	00800a84 	movi	r2,42
8113b8b0:	00006106 	br	8113ba38 <OSTaskCreateExt+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b8b4:	0005303a 	rdctl	r2,status
8113b8b8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b8bc:	e0fff917 	ldw	r3,-28(fp)
8113b8c0:	00bfff84 	movi	r2,-2
8113b8c4:	1884703a 	and	r2,r3,r2
8113b8c8:	1001703a 	wrctl	status,r2
  
  return context;
8113b8cc:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113b8d0:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
8113b8d4:	d0a09d03 	ldbu	r2,-32140(gp)
8113b8d8:	10803fcc 	andi	r2,r2,255
8113b8dc:	10000626 	beq	r2,zero,8113b8f8 <OSTaskCreateExt+0x98>
8113b8e0:	e0bff117 	ldw	r2,-60(fp)
8113b8e4:	e0bff215 	stw	r2,-56(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113b8e8:	e0bff217 	ldw	r2,-56(fp)
8113b8ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
8113b8f0:	00800f04 	movi	r2,60
8113b8f4:	00005006 	br	8113ba38 <OSTaskCreateExt+0x1d8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
8113b8f8:	e0fffd03 	ldbu	r3,-12(fp)
8113b8fc:	00a045f4 	movhi	r2,33047
8113b900:	10a10004 	addi	r2,r2,-31744
8113b904:	18c7883a 	add	r3,r3,r3
8113b908:	18c7883a 	add	r3,r3,r3
8113b90c:	10c5883a 	add	r2,r2,r3
8113b910:	10800017 	ldw	r2,0(r2)
8113b914:	1000431e 	bne	r2,zero,8113ba24 <OSTaskCreateExt+0x1c4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
8113b918:	e0fffd03 	ldbu	r3,-12(fp)
8113b91c:	00a045f4 	movhi	r2,33047
8113b920:	10a10004 	addi	r2,r2,-31744
8113b924:	18c7883a 	add	r3,r3,r3
8113b928:	18c7883a 	add	r3,r3,r3
8113b92c:	10c5883a 	add	r2,r2,r3
8113b930:	00c00044 	movi	r3,1
8113b934:	10c00015 	stw	r3,0(r2)
8113b938:	e0bff117 	ldw	r2,-60(fp)
8113b93c:	e0bff315 	stw	r2,-52(fp)
8113b940:	e0bff317 	ldw	r2,-52(fp)
8113b944:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
8113b948:	e0bfff0b 	ldhu	r2,-4(fp)
8113b94c:	100d883a 	mov	r6,r2
8113b950:	e1400417 	ldw	r5,16(fp)
8113b954:	e1000317 	ldw	r4,12(fp)
8113b958:	113c9080 	call	8113c908 <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
8113b95c:	e0bfff0b 	ldhu	r2,-4(fp)
8113b960:	100f883a 	mov	r7,r2
8113b964:	e1bffc17 	ldw	r6,-16(fp)
8113b968:	e17ffb17 	ldw	r5,-20(fp)
8113b96c:	e13ffa17 	ldw	r4,-24(fp)
8113b970:	1146d540 	call	81146d54 <OSTaskStkInit>
8113b974:	e0bff515 	stw	r2,-44(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
8113b978:	e0fffd03 	ldbu	r3,-12(fp)
8113b97c:	e13ffe0b 	ldhu	r4,-8(fp)
8113b980:	e0bfff0b 	ldhu	r2,-4(fp)
8113b984:	d8800215 	stw	r2,8(sp)
8113b988:	e0800517 	ldw	r2,20(fp)
8113b98c:	d8800115 	stw	r2,4(sp)
8113b990:	e0800417 	ldw	r2,16(fp)
8113b994:	d8800015 	stw	r2,0(sp)
8113b998:	200f883a 	mov	r7,r4
8113b99c:	e1800317 	ldw	r6,12(fp)
8113b9a0:	e17ff517 	ldw	r5,-44(fp)
8113b9a4:	1809883a 	mov	r4,r3
8113b9a8:	113608c0 	call	8113608c <OS_TCBInit>
8113b9ac:	e0bff605 	stb	r2,-40(fp)
        if (err == OS_ERR_NONE) {
8113b9b0:	e0bff603 	ldbu	r2,-40(fp)
8113b9b4:	1000061e 	bne	r2,zero,8113b9d0 <OSTaskCreateExt+0x170>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
8113b9b8:	d0a08d03 	ldbu	r2,-32204(gp)
8113b9bc:	10803fcc 	andi	r2,r2,255
8113b9c0:	10800058 	cmpnei	r2,r2,1
8113b9c4:	1000151e 	bne	r2,zero,8113ba1c <OSTaskCreateExt+0x1bc>
                OS_Sched();
8113b9c8:	1135c440 	call	81135c44 <OS_Sched>
8113b9cc:	00001306 	br	8113ba1c <OSTaskCreateExt+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113b9d0:	0005303a 	rdctl	r2,status
8113b9d4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113b9d8:	e0fff817 	ldw	r3,-32(fp)
8113b9dc:	00bfff84 	movi	r2,-2
8113b9e0:	1884703a 	and	r2,r3,r2
8113b9e4:	1001703a 	wrctl	status,r2
  
  return context;
8113b9e8:	e0bff817 	ldw	r2,-32(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
8113b9ec:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
8113b9f0:	e0fffd03 	ldbu	r3,-12(fp)
8113b9f4:	00a045f4 	movhi	r2,33047
8113b9f8:	10a10004 	addi	r2,r2,-31744
8113b9fc:	18c7883a 	add	r3,r3,r3
8113ba00:	18c7883a 	add	r3,r3,r3
8113ba04:	10c5883a 	add	r2,r2,r3
8113ba08:	10000015 	stw	zero,0(r2)
8113ba0c:	e0bff117 	ldw	r2,-60(fp)
8113ba10:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ba14:	e0bff417 	ldw	r2,-48(fp)
8113ba18:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
8113ba1c:	e0bff603 	ldbu	r2,-40(fp)
8113ba20:	00000506 	br	8113ba38 <OSTaskCreateExt+0x1d8>
8113ba24:	e0bff117 	ldw	r2,-60(fp)
8113ba28:	e0bff715 	stw	r2,-36(fp)
8113ba2c:	e0bff717 	ldw	r2,-36(fp)
8113ba30:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
8113ba34:	00800a04 	movi	r2,40
}
8113ba38:	e037883a 	mov	sp,fp
8113ba3c:	dfc00117 	ldw	ra,4(sp)
8113ba40:	df000017 	ldw	fp,0(sp)
8113ba44:	dec00204 	addi	sp,sp,8
8113ba48:	f800283a 	ret

8113ba4c <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
8113ba4c:	defff404 	addi	sp,sp,-48
8113ba50:	de00012e 	bgeu	sp,et,8113ba58 <OSTaskDel+0xc>
8113ba54:	003b68fa 	trap	3
8113ba58:	dfc00b15 	stw	ra,44(sp)
8113ba5c:	df000a15 	stw	fp,40(sp)
8113ba60:	df000a04 	addi	fp,sp,40
8113ba64:	2005883a 	mov	r2,r4
8113ba68:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
8113ba6c:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
8113ba70:	d0a09d03 	ldbu	r2,-32140(gp)
8113ba74:	10803fcc 	andi	r2,r2,255
8113ba78:	10000226 	beq	r2,zero,8113ba84 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
8113ba7c:	00801004 	movi	r2,64
8113ba80:	0000c006 	br	8113bd84 <OSTaskDel+0x338>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
8113ba84:	e0bfff03 	ldbu	r2,-4(fp)
8113ba88:	10800a98 	cmpnei	r2,r2,42
8113ba8c:	1000021e 	bne	r2,zero,8113ba98 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
8113ba90:	00800f84 	movi	r2,62
8113ba94:	0000bb06 	br	8113bd84 <OSTaskDel+0x338>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
8113ba98:	e0bfff03 	ldbu	r2,-4(fp)
8113ba9c:	10800ab0 	cmpltui	r2,r2,42
8113baa0:	1000051e 	bne	r2,zero,8113bab8 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
8113baa4:	e0bfff03 	ldbu	r2,-4(fp)
8113baa8:	10803fe0 	cmpeqi	r2,r2,255
8113baac:	1000021e 	bne	r2,zero,8113bab8 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
8113bab0:	00800a84 	movi	r2,42
8113bab4:	0000b306 	br	8113bd84 <OSTaskDel+0x338>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bab8:	0005303a 	rdctl	r2,status
8113babc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bac0:	e0fffe17 	ldw	r3,-8(fp)
8113bac4:	00bfff84 	movi	r2,-2
8113bac8:	1884703a 	and	r2,r3,r2
8113bacc:	1001703a 	wrctl	status,r2
  
  return context;
8113bad0:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
8113bad4:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
8113bad8:	e0bfff03 	ldbu	r2,-4(fp)
8113badc:	10803fd8 	cmpnei	r2,r2,255
8113bae0:	1000031e 	bne	r2,zero,8113baf0 <OSTaskDel+0xa4>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
8113bae4:	d0a09e17 	ldw	r2,-32136(gp)
8113bae8:	10800c83 	ldbu	r2,50(r2)
8113baec:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113baf0:	e0ffff03 	ldbu	r3,-4(fp)
8113baf4:	00a045f4 	movhi	r2,33047
8113baf8:	10a10004 	addi	r2,r2,-31744
8113bafc:	18c7883a 	add	r3,r3,r3
8113bb00:	18c7883a 	add	r3,r3,r3
8113bb04:	10c5883a 	add	r2,r2,r3
8113bb08:	10800017 	ldw	r2,0(r2)
8113bb0c:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
8113bb10:	e0bff817 	ldw	r2,-32(fp)
8113bb14:	1000061e 	bne	r2,zero,8113bb30 <OSTaskDel+0xe4>
8113bb18:	e0bff617 	ldw	r2,-40(fp)
8113bb1c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bb20:	e0bff717 	ldw	r2,-36(fp)
8113bb24:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113bb28:	008010c4 	movi	r2,67
8113bb2c:	00009506 	br	8113bd84 <OSTaskDel+0x338>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
8113bb30:	e0bff817 	ldw	r2,-32(fp)
8113bb34:	10800058 	cmpnei	r2,r2,1
8113bb38:	1000061e 	bne	r2,zero,8113bb54 <OSTaskDel+0x108>
8113bb3c:	e0bff617 	ldw	r2,-40(fp)
8113bb40:	e0bff915 	stw	r2,-28(fp)
8113bb44:	e0bff917 	ldw	r2,-28(fp)
8113bb48:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113bb4c:	00800f44 	movi	r2,61
8113bb50:	00008c06 	br	8113bd84 <OSTaskDel+0x338>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
8113bb54:	e0bff817 	ldw	r2,-32(fp)
8113bb58:	10800d03 	ldbu	r2,52(r2)
8113bb5c:	10c03fcc 	andi	r3,r2,255
8113bb60:	e0bff817 	ldw	r2,-32(fp)
8113bb64:	10800d03 	ldbu	r2,52(r2)
8113bb68:	11003fcc 	andi	r4,r2,255
8113bb6c:	d0a09a44 	addi	r2,gp,-32151
8113bb70:	2085883a 	add	r2,r4,r2
8113bb74:	10800003 	ldbu	r2,0(r2)
8113bb78:	1009883a 	mov	r4,r2
8113bb7c:	e0bff817 	ldw	r2,-32(fp)
8113bb80:	10800d43 	ldbu	r2,53(r2)
8113bb84:	0084303a 	nor	r2,zero,r2
8113bb88:	2084703a 	and	r2,r4,r2
8113bb8c:	1009883a 	mov	r4,r2
8113bb90:	d0a09a44 	addi	r2,gp,-32151
8113bb94:	1885883a 	add	r2,r3,r2
8113bb98:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
8113bb9c:	e0bff817 	ldw	r2,-32(fp)
8113bba0:	10800d03 	ldbu	r2,52(r2)
8113bba4:	10c03fcc 	andi	r3,r2,255
8113bba8:	d0a09a44 	addi	r2,gp,-32151
8113bbac:	1885883a 	add	r2,r3,r2
8113bbb0:	10800003 	ldbu	r2,0(r2)
8113bbb4:	10803fcc 	andi	r2,r2,255
8113bbb8:	1000071e 	bne	r2,zero,8113bbd8 <OSTaskDel+0x18c>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
8113bbbc:	e0bff817 	ldw	r2,-32(fp)
8113bbc0:	10800d83 	ldbu	r2,54(r2)
8113bbc4:	0084303a 	nor	r2,zero,r2
8113bbc8:	1007883a 	mov	r3,r2
8113bbcc:	d0a09a03 	ldbu	r2,-32152(gp)
8113bbd0:	1884703a 	and	r2,r3,r2
8113bbd4:	d0a09a05 	stb	r2,-32152(gp)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
8113bbd8:	e0bff817 	ldw	r2,-32(fp)
8113bbdc:	10800717 	ldw	r2,28(r2)
8113bbe0:	10000526 	beq	r2,zero,8113bbf8 <OSTaskDel+0x1ac>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
8113bbe4:	e0bff817 	ldw	r2,-32(fp)
8113bbe8:	10800717 	ldw	r2,28(r2)
8113bbec:	100b883a 	mov	r5,r2
8113bbf0:	e13ff817 	ldw	r4,-32(fp)
8113bbf4:	11355980 	call	81135598 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
8113bbf8:	e0bff817 	ldw	r2,-32(fp)
8113bbfc:	10800817 	ldw	r2,32(r2)
8113bc00:	10000526 	beq	r2,zero,8113bc18 <OSTaskDel+0x1cc>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
8113bc04:	e0bff817 	ldw	r2,-32(fp)
8113bc08:	10800817 	ldw	r2,32(r2)
8113bc0c:	100b883a 	mov	r5,r2
8113bc10:	e13ff817 	ldw	r4,-32(fp)
8113bc14:	11356580 	call	81135658 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
8113bc18:	e0bff817 	ldw	r2,-32(fp)
8113bc1c:	10800a17 	ldw	r2,40(r2)
8113bc20:	e0bffb15 	stw	r2,-20(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
8113bc24:	e0bffb17 	ldw	r2,-20(fp)
8113bc28:	10000226 	beq	r2,zero,8113bc34 <OSTaskDel+0x1e8>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
8113bc2c:	e13ffb17 	ldw	r4,-20(fp)
8113bc30:	1137c300 	call	81137c30 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
8113bc34:	e0bff817 	ldw	r2,-32(fp)
8113bc38:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
8113bc3c:	e0bff817 	ldw	r2,-32(fp)
8113bc40:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
8113bc44:	e0bff817 	ldw	r2,-32(fp)
8113bc48:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
8113bc4c:	d0a08b03 	ldbu	r2,-32212(gp)
8113bc50:	10803fcc 	andi	r2,r2,255
8113bc54:	10803fe0 	cmpeqi	r2,r2,255
8113bc58:	1000031e 	bne	r2,zero,8113bc68 <OSTaskDel+0x21c>
        OSLockNesting++;
8113bc5c:	d0a08b03 	ldbu	r2,-32212(gp)
8113bc60:	10800044 	addi	r2,r2,1
8113bc64:	d0a08b05 	stb	r2,-32212(gp)
8113bc68:	e0bff617 	ldw	r2,-40(fp)
8113bc6c:	e0bffd15 	stw	r2,-12(fp)
8113bc70:	e0bffd17 	ldw	r2,-12(fp)
8113bc74:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
8113bc78:	11351600 	call	81135160 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bc7c:	0005303a 	rdctl	r2,status
8113bc80:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bc84:	e0fffa17 	ldw	r3,-24(fp)
8113bc88:	00bfff84 	movi	r2,-2
8113bc8c:	1884703a 	and	r2,r3,r2
8113bc90:	1001703a 	wrctl	status,r2
  
  return context;
8113bc94:	e0bffa17 	ldw	r2,-24(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
8113bc98:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
8113bc9c:	d0a08b03 	ldbu	r2,-32212(gp)
8113bca0:	10803fcc 	andi	r2,r2,255
8113bca4:	10000326 	beq	r2,zero,8113bcb4 <OSTaskDel+0x268>
        OSLockNesting--;
8113bca8:	d0a08b03 	ldbu	r2,-32212(gp)
8113bcac:	10bfffc4 	addi	r2,r2,-1
8113bcb0:	d0a08b05 	stb	r2,-32212(gp)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
8113bcb4:	e13ff817 	ldw	r4,-32(fp)
8113bcb8:	1146ee40 	call	81146ee4 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
8113bcbc:	d0a09643 	ldbu	r2,-32167(gp)
8113bcc0:	10bfffc4 	addi	r2,r2,-1
8113bcc4:	d0a09645 	stb	r2,-32167(gp)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
8113bcc8:	e0ffff03 	ldbu	r3,-4(fp)
8113bccc:	00a045f4 	movhi	r2,33047
8113bcd0:	10a10004 	addi	r2,r2,-31744
8113bcd4:	18c7883a 	add	r3,r3,r3
8113bcd8:	18c7883a 	add	r3,r3,r3
8113bcdc:	10c5883a 	add	r2,r2,r3
8113bce0:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
8113bce4:	e0bff817 	ldw	r2,-32(fp)
8113bce8:	10800617 	ldw	r2,24(r2)
8113bcec:	1000071e 	bne	r2,zero,8113bd0c <OSTaskDel+0x2c0>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
8113bcf0:	e0bff817 	ldw	r2,-32(fp)
8113bcf4:	10800517 	ldw	r2,20(r2)
8113bcf8:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
8113bcfc:	e0bff817 	ldw	r2,-32(fp)
8113bd00:	10800517 	ldw	r2,20(r2)
8113bd04:	d0a09015 	stw	r2,-32192(gp)
8113bd08:	00000a06 	br	8113bd34 <OSTaskDel+0x2e8>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
8113bd0c:	e0bff817 	ldw	r2,-32(fp)
8113bd10:	10800617 	ldw	r2,24(r2)
8113bd14:	e0fff817 	ldw	r3,-32(fp)
8113bd18:	18c00517 	ldw	r3,20(r3)
8113bd1c:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
8113bd20:	e0bff817 	ldw	r2,-32(fp)
8113bd24:	10800517 	ldw	r2,20(r2)
8113bd28:	e0fff817 	ldw	r3,-32(fp)
8113bd2c:	18c00617 	ldw	r3,24(r3)
8113bd30:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
8113bd34:	d0e09517 	ldw	r3,-32172(gp)
8113bd38:	e0bff817 	ldw	r2,-32(fp)
8113bd3c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
8113bd40:	e0bff817 	ldw	r2,-32(fp)
8113bd44:	d0a09515 	stw	r2,-32172(gp)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
8113bd48:	e0bff817 	ldw	r2,-32(fp)
8113bd4c:	00c00fc4 	movi	r3,63
8113bd50:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
8113bd54:	e0bff817 	ldw	r2,-32(fp)
8113bd58:	10001345 	stb	zero,77(r2)
8113bd5c:	e0bff617 	ldw	r2,-40(fp)
8113bd60:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bd64:	e0bffc17 	ldw	r2,-16(fp)
8113bd68:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
8113bd6c:	d0a08d03 	ldbu	r2,-32204(gp)
8113bd70:	10803fcc 	andi	r2,r2,255
8113bd74:	10800058 	cmpnei	r2,r2,1
8113bd78:	1000011e 	bne	r2,zero,8113bd80 <OSTaskDel+0x334>
        OS_Sched();                                     /* Find new highest priority task              */
8113bd7c:	1135c440 	call	81135c44 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113bd80:	0005883a 	mov	r2,zero
}
8113bd84:	e037883a 	mov	sp,fp
8113bd88:	dfc00117 	ldw	ra,4(sp)
8113bd8c:	df000017 	ldw	fp,0(sp)
8113bd90:	dec00204 	addi	sp,sp,8
8113bd94:	f800283a 	ret

8113bd98 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
8113bd98:	defff504 	addi	sp,sp,-44
8113bd9c:	de00012e 	bgeu	sp,et,8113bda4 <OSTaskDelReq+0xc>
8113bda0:	003b68fa 	trap	3
8113bda4:	df000a15 	stw	fp,40(sp)
8113bda8:	df000a04 	addi	fp,sp,40
8113bdac:	2005883a 	mov	r2,r4
8113bdb0:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113bdb4:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
8113bdb8:	e0bfff03 	ldbu	r2,-4(fp)
8113bdbc:	10800a98 	cmpnei	r2,r2,42
8113bdc0:	1000021e 	bne	r2,zero,8113bdcc <OSTaskDelReq+0x34>
        return (OS_ERR_TASK_DEL_IDLE);
8113bdc4:	00800f84 	movi	r2,62
8113bdc8:	00004506 	br	8113bee0 <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113bdcc:	e0bfff03 	ldbu	r2,-4(fp)
8113bdd0:	10800ab0 	cmpltui	r2,r2,42
8113bdd4:	1000051e 	bne	r2,zero,8113bdec <OSTaskDelReq+0x54>
        if (prio != OS_PRIO_SELF) {
8113bdd8:	e0bfff03 	ldbu	r2,-4(fp)
8113bddc:	10803fe0 	cmpeqi	r2,r2,255
8113bde0:	1000021e 	bne	r2,zero,8113bdec <OSTaskDelReq+0x54>
            return (OS_ERR_PRIO_INVALID);
8113bde4:	00800a84 	movi	r2,42
8113bde8:	00003d06 	br	8113bee0 <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
8113bdec:	e0bfff03 	ldbu	r2,-4(fp)
8113bdf0:	10803fd8 	cmpnei	r2,r2,255
8113bdf4:	1000111e 	bne	r2,zero,8113be3c <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bdf8:	0005303a 	rdctl	r2,status
8113bdfc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113be00:	e0fff917 	ldw	r3,-28(fp)
8113be04:	00bfff84 	movi	r2,-2
8113be08:	1884703a 	and	r2,r3,r2
8113be0c:	1001703a 	wrctl	status,r2
  
  return context;
8113be10:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
8113be14:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
8113be18:	d0a09e17 	ldw	r2,-32136(gp)
8113be1c:	10800dc3 	ldbu	r2,55(r2)
8113be20:	e0bff805 	stb	r2,-32(fp)
8113be24:	e0bff617 	ldw	r2,-40(fp)
8113be28:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be2c:	e0bffe17 	ldw	r2,-8(fp)
8113be30:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
8113be34:	e0bff803 	ldbu	r2,-32(fp)
8113be38:	00002906 	br	8113bee0 <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113be3c:	0005303a 	rdctl	r2,status
8113be40:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113be44:	e0fff717 	ldw	r3,-36(fp)
8113be48:	00bfff84 	movi	r2,-2
8113be4c:	1884703a 	and	r2,r3,r2
8113be50:	1001703a 	wrctl	status,r2
  
  return context;
8113be54:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
8113be58:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113be5c:	e0ffff03 	ldbu	r3,-4(fp)
8113be60:	00a045f4 	movhi	r2,33047
8113be64:	10a10004 	addi	r2,r2,-31744
8113be68:	18c7883a 	add	r3,r3,r3
8113be6c:	18c7883a 	add	r3,r3,r3
8113be70:	10c5883a 	add	r2,r2,r3
8113be74:	10800017 	ldw	r2,0(r2)
8113be78:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
8113be7c:	e0bffb17 	ldw	r2,-20(fp)
8113be80:	1000061e 	bne	r2,zero,8113be9c <OSTaskDelReq+0x104>
8113be84:	e0bff617 	ldw	r2,-40(fp)
8113be88:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113be8c:	e0bffa17 	ldw	r2,-24(fp)
8113be90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
8113be94:	008010c4 	movi	r2,67
8113be98:	00001106 	br	8113bee0 <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
8113be9c:	e0bffb17 	ldw	r2,-20(fp)
8113bea0:	10800058 	cmpnei	r2,r2,1
8113bea4:	1000061e 	bne	r2,zero,8113bec0 <OSTaskDelReq+0x128>
8113bea8:	e0bff617 	ldw	r2,-40(fp)
8113beac:	e0bffc15 	stw	r2,-16(fp)
8113beb0:	e0bffc17 	ldw	r2,-16(fp)
8113beb4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
8113beb8:	00800f44 	movi	r2,61
8113bebc:	00000806 	br	8113bee0 <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
8113bec0:	e0bffb17 	ldw	r2,-20(fp)
8113bec4:	00c00fc4 	movi	r3,63
8113bec8:	10c00dc5 	stb	r3,55(r2)
8113becc:	e0bff617 	ldw	r2,-40(fp)
8113bed0:	e0bffd15 	stw	r2,-12(fp)
8113bed4:	e0bffd17 	ldw	r2,-12(fp)
8113bed8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113bedc:	0005883a 	mov	r2,zero
}
8113bee0:	e037883a 	mov	sp,fp
8113bee4:	df000017 	ldw	fp,0(sp)
8113bee8:	dec00104 	addi	sp,sp,4
8113beec:	f800283a 	ret

8113bef0 <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113bef0:	defff404 	addi	sp,sp,-48
8113bef4:	de00012e 	bgeu	sp,et,8113befc <OSTaskNameGet+0xc>
8113bef8:	003b68fa 	trap	3
8113befc:	dfc00b15 	stw	ra,44(sp)
8113bf00:	df000a15 	stw	fp,40(sp)
8113bf04:	df000a04 	addi	fp,sp,40
8113bf08:	2005883a 	mov	r2,r4
8113bf0c:	e17ffe15 	stw	r5,-8(fp)
8113bf10:	e1bfff15 	stw	r6,-4(fp)
8113bf14:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
8113bf18:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
8113bf1c:	e0bfff17 	ldw	r2,-4(fp)
8113bf20:	1000021e 	bne	r2,zero,8113bf2c <OSTaskNameGet+0x3c>
        return (0);
8113bf24:	0005883a 	mov	r2,zero
8113bf28:	00005406 	br	8113c07c <OSTaskNameGet+0x18c>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
8113bf2c:	e0bffd03 	ldbu	r2,-12(fp)
8113bf30:	10800af0 	cmpltui	r2,r2,43
8113bf34:	1000081e 	bne	r2,zero,8113bf58 <OSTaskNameGet+0x68>
        if (prio != OS_PRIO_SELF) {
8113bf38:	e0bffd03 	ldbu	r2,-12(fp)
8113bf3c:	10803fe0 	cmpeqi	r2,r2,255
8113bf40:	1000051e 	bne	r2,zero,8113bf58 <OSTaskNameGet+0x68>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
8113bf44:	e0bfff17 	ldw	r2,-4(fp)
8113bf48:	00c00a84 	movi	r3,42
8113bf4c:	10c00005 	stb	r3,0(r2)
            return (0);
8113bf50:	0005883a 	mov	r2,zero
8113bf54:	00004906 	br	8113c07c <OSTaskNameGet+0x18c>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
8113bf58:	e0bffe17 	ldw	r2,-8(fp)
8113bf5c:	1000051e 	bne	r2,zero,8113bf74 <OSTaskNameGet+0x84>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
8113bf60:	e0bfff17 	ldw	r2,-4(fp)
8113bf64:	00c00304 	movi	r3,12
8113bf68:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf6c:	0005883a 	mov	r2,zero
8113bf70:	00004206 	br	8113c07c <OSTaskNameGet+0x18c>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
8113bf74:	d0a09d03 	ldbu	r2,-32140(gp)
8113bf78:	10803fcc 	andi	r2,r2,255
8113bf7c:	10000526 	beq	r2,zero,8113bf94 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
8113bf80:	e0bfff17 	ldw	r2,-4(fp)
8113bf84:	00c00444 	movi	r3,17
8113bf88:	10c00005 	stb	r3,0(r2)
        return (0);
8113bf8c:	0005883a 	mov	r2,zero
8113bf90:	00003a06 	br	8113c07c <OSTaskNameGet+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113bf94:	0005303a 	rdctl	r2,status
8113bf98:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113bf9c:	e0fffc17 	ldw	r3,-16(fp)
8113bfa0:	00bfff84 	movi	r2,-2
8113bfa4:	1884703a 	and	r2,r3,r2
8113bfa8:	1001703a 	wrctl	status,r2
  
  return context;
8113bfac:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113bfb0:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
8113bfb4:	e0bffd03 	ldbu	r2,-12(fp)
8113bfb8:	10803fd8 	cmpnei	r2,r2,255
8113bfbc:	1000031e 	bne	r2,zero,8113bfcc <OSTaskNameGet+0xdc>
        prio = OSTCBCur->OSTCBPrio;
8113bfc0:	d0a09e17 	ldw	r2,-32136(gp)
8113bfc4:	10800c83 	ldbu	r2,50(r2)
8113bfc8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113bfcc:	e0fffd03 	ldbu	r3,-12(fp)
8113bfd0:	00a045f4 	movhi	r2,33047
8113bfd4:	10a10004 	addi	r2,r2,-31744
8113bfd8:	18c7883a 	add	r3,r3,r3
8113bfdc:	18c7883a 	add	r3,r3,r3
8113bfe0:	10c5883a 	add	r2,r2,r3
8113bfe4:	10800017 	ldw	r2,0(r2)
8113bfe8:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
8113bfec:	e0bff817 	ldw	r2,-32(fp)
8113bff0:	1000091e 	bne	r2,zero,8113c018 <OSTaskNameGet+0x128>
8113bff4:	e0bff617 	ldw	r2,-40(fp)
8113bff8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113bffc:	e0bff717 	ldw	r2,-36(fp)
8113c000:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113c004:	e0bfff17 	ldw	r2,-4(fp)
8113c008:	00c010c4 	movi	r3,67
8113c00c:	10c00005 	stb	r3,0(r2)
        return (0);
8113c010:	0005883a 	mov	r2,zero
8113c014:	00001906 	br	8113c07c <OSTaskNameGet+0x18c>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
8113c018:	e0bff817 	ldw	r2,-32(fp)
8113c01c:	10800058 	cmpnei	r2,r2,1
8113c020:	1000091e 	bne	r2,zero,8113c048 <OSTaskNameGet+0x158>
8113c024:	e0bff617 	ldw	r2,-40(fp)
8113c028:	e0bff915 	stw	r2,-28(fp)
8113c02c:	e0bff917 	ldw	r2,-28(fp)
8113c030:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113c034:	e0bfff17 	ldw	r2,-4(fp)
8113c038:	00c010c4 	movi	r3,67
8113c03c:	10c00005 	stb	r3,0(r2)
        return (0);
8113c040:	0005883a 	mov	r2,zero
8113c044:	00000d06 	br	8113c07c <OSTaskNameGet+0x18c>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
8113c048:	e0bff817 	ldw	r2,-32(fp)
8113c04c:	10801304 	addi	r2,r2,76
8113c050:	100b883a 	mov	r5,r2
8113c054:	e13ffe17 	ldw	r4,-8(fp)
8113c058:	1135d980 	call	81135d98 <OS_StrCopy>
8113c05c:	e0bffb05 	stb	r2,-20(fp)
8113c060:	e0bff617 	ldw	r2,-40(fp)
8113c064:	e0bffa15 	stw	r2,-24(fp)
8113c068:	e0bffa17 	ldw	r2,-24(fp)
8113c06c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c070:	e0bfff17 	ldw	r2,-4(fp)
8113c074:	10000005 	stb	zero,0(r2)
    return (len);
8113c078:	e0bffb03 	ldbu	r2,-20(fp)
}
8113c07c:	e037883a 	mov	sp,fp
8113c080:	dfc00117 	ldw	ra,4(sp)
8113c084:	df000017 	ldw	fp,0(sp)
8113c088:	dec00204 	addi	sp,sp,8
8113c08c:	f800283a 	ret

8113c090 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
8113c090:	defff304 	addi	sp,sp,-52
8113c094:	de00012e 	bgeu	sp,et,8113c09c <OSTaskNameSet+0xc>
8113c098:	003b68fa 	trap	3
8113c09c:	dfc00c15 	stw	ra,48(sp)
8113c0a0:	df000b15 	stw	fp,44(sp)
8113c0a4:	df000b04 	addi	fp,sp,44
8113c0a8:	2005883a 	mov	r2,r4
8113c0ac:	e17ffe15 	stw	r5,-8(fp)
8113c0b0:	e1bfff15 	stw	r6,-4(fp)
8113c0b4:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113c0b8:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
8113c0bc:	e0bfff17 	ldw	r2,-4(fp)
8113c0c0:	10005c26 	beq	r2,zero,8113c234 <OSTaskNameSet+0x1a4>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
8113c0c4:	e0bffd03 	ldbu	r2,-12(fp)
8113c0c8:	10800af0 	cmpltui	r2,r2,43
8113c0cc:	1000071e 	bne	r2,zero,8113c0ec <OSTaskNameSet+0x5c>
        if (prio != OS_PRIO_SELF) {
8113c0d0:	e0bffd03 	ldbu	r2,-12(fp)
8113c0d4:	10803fe0 	cmpeqi	r2,r2,255
8113c0d8:	1000041e 	bne	r2,zero,8113c0ec <OSTaskNameSet+0x5c>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
8113c0dc:	e0bfff17 	ldw	r2,-4(fp)
8113c0e0:	00c00a84 	movi	r3,42
8113c0e4:	10c00005 	stb	r3,0(r2)
            return;
8113c0e8:	00005306 	br	8113c238 <OSTaskNameSet+0x1a8>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
8113c0ec:	e0bffe17 	ldw	r2,-8(fp)
8113c0f0:	1000041e 	bne	r2,zero,8113c104 <OSTaskNameSet+0x74>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
8113c0f4:	e0bfff17 	ldw	r2,-4(fp)
8113c0f8:	00c00304 	movi	r3,12
8113c0fc:	10c00005 	stb	r3,0(r2)
        return;
8113c100:	00004d06 	br	8113c238 <OSTaskNameSet+0x1a8>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
8113c104:	d0a09d03 	ldbu	r2,-32140(gp)
8113c108:	10803fcc 	andi	r2,r2,255
8113c10c:	10000426 	beq	r2,zero,8113c120 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
8113c110:	e0bfff17 	ldw	r2,-4(fp)
8113c114:	00c00484 	movi	r3,18
8113c118:	10c00005 	stb	r3,0(r2)
        return;
8113c11c:	00004606 	br	8113c238 <OSTaskNameSet+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c120:	0005303a 	rdctl	r2,status
8113c124:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c128:	e0fffc17 	ldw	r3,-16(fp)
8113c12c:	00bfff84 	movi	r2,-2
8113c130:	1884703a 	and	r2,r3,r2
8113c134:	1001703a 	wrctl	status,r2
  
  return context;
8113c138:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
8113c13c:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
8113c140:	e0bffd03 	ldbu	r2,-12(fp)
8113c144:	10803fd8 	cmpnei	r2,r2,255
8113c148:	1000031e 	bne	r2,zero,8113c158 <OSTaskNameSet+0xc8>
        prio = OSTCBCur->OSTCBPrio;
8113c14c:	d0a09e17 	ldw	r2,-32136(gp)
8113c150:	10800c83 	ldbu	r2,50(r2)
8113c154:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113c158:	e0fffd03 	ldbu	r3,-12(fp)
8113c15c:	00a045f4 	movhi	r2,33047
8113c160:	10a10004 	addi	r2,r2,-31744
8113c164:	18c7883a 	add	r3,r3,r3
8113c168:	18c7883a 	add	r3,r3,r3
8113c16c:	10c5883a 	add	r2,r2,r3
8113c170:	10800017 	ldw	r2,0(r2)
8113c174:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
8113c178:	e0bff717 	ldw	r2,-36(fp)
8113c17c:	1000081e 	bne	r2,zero,8113c1a0 <OSTaskNameSet+0x110>
8113c180:	e0bff517 	ldw	r2,-44(fp)
8113c184:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c188:	e0bff617 	ldw	r2,-40(fp)
8113c18c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113c190:	e0bfff17 	ldw	r2,-4(fp)
8113c194:	00c010c4 	movi	r3,67
8113c198:	10c00005 	stb	r3,0(r2)
        return;
8113c19c:	00002606 	br	8113c238 <OSTaskNameSet+0x1a8>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
8113c1a0:	e0bff717 	ldw	r2,-36(fp)
8113c1a4:	10800058 	cmpnei	r2,r2,1
8113c1a8:	1000081e 	bne	r2,zero,8113c1cc <OSTaskNameSet+0x13c>
8113c1ac:	e0bff517 	ldw	r2,-44(fp)
8113c1b0:	e0bff815 	stw	r2,-32(fp)
8113c1b4:	e0bff817 	ldw	r2,-32(fp)
8113c1b8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
8113c1bc:	e0bfff17 	ldw	r2,-4(fp)
8113c1c0:	00c010c4 	movi	r3,67
8113c1c4:	10c00005 	stb	r3,0(r2)
        return;
8113c1c8:	00001b06 	br	8113c238 <OSTaskNameSet+0x1a8>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
8113c1cc:	e13ffe17 	ldw	r4,-8(fp)
8113c1d0:	1135e140 	call	81135e14 <OS_StrLen>
8113c1d4:	e0bffa05 	stb	r2,-24(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
8113c1d8:	e0bffa03 	ldbu	r2,-24(fp)
8113c1dc:	10800830 	cmpltui	r2,r2,32
8113c1e0:	1000081e 	bne	r2,zero,8113c204 <OSTaskNameSet+0x174>
8113c1e4:	e0bff517 	ldw	r2,-44(fp)
8113c1e8:	e0bff915 	stw	r2,-28(fp)
8113c1ec:	e0bff917 	ldw	r2,-28(fp)
8113c1f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
8113c1f4:	e0bfff17 	ldw	r2,-4(fp)
8113c1f8:	00c01044 	movi	r3,65
8113c1fc:	10c00005 	stb	r3,0(r2)
        return;
8113c200:	00000d06 	br	8113c238 <OSTaskNameSet+0x1a8>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
8113c204:	e0bff717 	ldw	r2,-36(fp)
8113c208:	10801304 	addi	r2,r2,76
8113c20c:	e17ffe17 	ldw	r5,-8(fp)
8113c210:	1009883a 	mov	r4,r2
8113c214:	1135d980 	call	81135d98 <OS_StrCopy>
8113c218:	e0bff517 	ldw	r2,-44(fp)
8113c21c:	e0bffb15 	stw	r2,-20(fp)
8113c220:	e0bffb17 	ldw	r2,-20(fp)
8113c224:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
8113c228:	e0bfff17 	ldw	r2,-4(fp)
8113c22c:	10000005 	stb	zero,0(r2)
8113c230:	00000106 	br	8113c238 <OSTaskNameSet+0x1a8>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
8113c234:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
8113c238:	e037883a 	mov	sp,fp
8113c23c:	dfc00117 	ldw	ra,4(sp)
8113c240:	df000017 	ldw	fp,0(sp)
8113c244:	dec00204 	addi	sp,sp,8
8113c248:	f800283a 	ret

8113c24c <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
8113c24c:	defff404 	addi	sp,sp,-48
8113c250:	de00012e 	bgeu	sp,et,8113c258 <OSTaskResume+0xc>
8113c254:	003b68fa 	trap	3
8113c258:	dfc00b15 	stw	ra,44(sp)
8113c25c:	df000a15 	stw	fp,40(sp)
8113c260:	df000a04 	addi	fp,sp,40
8113c264:	2005883a 	mov	r2,r4
8113c268:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
8113c26c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
8113c270:	e0bfff03 	ldbu	r2,-4(fp)
8113c274:	10800ab0 	cmpltui	r2,r2,42
8113c278:	1000021e 	bne	r2,zero,8113c284 <OSTaskResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113c27c:	00800a84 	movi	r2,42
8113c280:	00006406 	br	8113c414 <OSTaskResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c284:	0005303a 	rdctl	r2,status
8113c288:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c28c:	e0fffe17 	ldw	r3,-8(fp)
8113c290:	00bfff84 	movi	r2,-2
8113c294:	1884703a 	and	r2,r3,r2
8113c298:	1001703a 	wrctl	status,r2
  
  return context;
8113c29c:	e0bffe17 	ldw	r2,-8(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c2a0:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
8113c2a4:	e0ffff03 	ldbu	r3,-4(fp)
8113c2a8:	00a045f4 	movhi	r2,33047
8113c2ac:	10a10004 	addi	r2,r2,-31744
8113c2b0:	18c7883a 	add	r3,r3,r3
8113c2b4:	18c7883a 	add	r3,r3,r3
8113c2b8:	10c5883a 	add	r2,r2,r3
8113c2bc:	10800017 	ldw	r2,0(r2)
8113c2c0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
8113c2c4:	e0bff817 	ldw	r2,-32(fp)
8113c2c8:	1000061e 	bne	r2,zero,8113c2e4 <OSTaskResume+0x98>
8113c2cc:	e0bff617 	ldw	r2,-40(fp)
8113c2d0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c2d4:	e0bff717 	ldw	r2,-36(fp)
8113c2d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
8113c2dc:	00801184 	movi	r2,70
8113c2e0:	00004c06 	br	8113c414 <OSTaskResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
8113c2e4:	e0bff817 	ldw	r2,-32(fp)
8113c2e8:	10800058 	cmpnei	r2,r2,1
8113c2ec:	1000061e 	bne	r2,zero,8113c308 <OSTaskResume+0xbc>
8113c2f0:	e0bff617 	ldw	r2,-40(fp)
8113c2f4:	e0bff915 	stw	r2,-28(fp)
8113c2f8:	e0bff917 	ldw	r2,-28(fp)
8113c2fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113c300:	008010c4 	movi	r2,67
8113c304:	00004306 	br	8113c414 <OSTaskResume+0x1c8>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
8113c308:	e0bff817 	ldw	r2,-32(fp)
8113c30c:	10800c03 	ldbu	r2,48(r2)
8113c310:	10803fcc 	andi	r2,r2,255
8113c314:	1080020c 	andi	r2,r2,8
8113c318:	10003926 	beq	r2,zero,8113c400 <OSTaskResume+0x1b4>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
8113c31c:	e0bff817 	ldw	r2,-32(fp)
8113c320:	10c00c03 	ldbu	r3,48(r2)
8113c324:	00bffdc4 	movi	r2,-9
8113c328:	1884703a 	and	r2,r3,r2
8113c32c:	1007883a 	mov	r3,r2
8113c330:	e0bff817 	ldw	r2,-32(fp)
8113c334:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
8113c338:	e0bff817 	ldw	r2,-32(fp)
8113c33c:	10800c03 	ldbu	r2,48(r2)
8113c340:	10803fcc 	andi	r2,r2,255
8113c344:	1000281e 	bne	r2,zero,8113c3e8 <OSTaskResume+0x19c>
            if (ptcb->OSTCBDly == 0) {
8113c348:	e0bff817 	ldw	r2,-32(fp)
8113c34c:	10800b8b 	ldhu	r2,46(r2)
8113c350:	10bfffcc 	andi	r2,r2,65535
8113c354:	10001f1e 	bne	r2,zero,8113c3d4 <OSTaskResume+0x188>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
8113c358:	e0bff817 	ldw	r2,-32(fp)
8113c35c:	10c00d83 	ldbu	r3,54(r2)
8113c360:	d0a09a03 	ldbu	r2,-32152(gp)
8113c364:	1884b03a 	or	r2,r3,r2
8113c368:	d0a09a05 	stb	r2,-32152(gp)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113c36c:	e0bff817 	ldw	r2,-32(fp)
8113c370:	10800d03 	ldbu	r2,52(r2)
8113c374:	10c03fcc 	andi	r3,r2,255
8113c378:	e0bff817 	ldw	r2,-32(fp)
8113c37c:	10800d03 	ldbu	r2,52(r2)
8113c380:	11003fcc 	andi	r4,r2,255
8113c384:	d0a09a44 	addi	r2,gp,-32151
8113c388:	2085883a 	add	r2,r4,r2
8113c38c:	11000003 	ldbu	r4,0(r2)
8113c390:	e0bff817 	ldw	r2,-32(fp)
8113c394:	10800d43 	ldbu	r2,53(r2)
8113c398:	2084b03a 	or	r2,r4,r2
8113c39c:	1009883a 	mov	r4,r2
8113c3a0:	d0a09a44 	addi	r2,gp,-32151
8113c3a4:	1885883a 	add	r2,r3,r2
8113c3a8:	11000005 	stb	r4,0(r2)
8113c3ac:	e0bff617 	ldw	r2,-40(fp)
8113c3b0:	e0bffa15 	stw	r2,-24(fp)
8113c3b4:	e0bffa17 	ldw	r2,-24(fp)
8113c3b8:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
8113c3bc:	d0a08d03 	ldbu	r2,-32204(gp)
8113c3c0:	10803fcc 	andi	r2,r2,255
8113c3c4:	10800058 	cmpnei	r2,r2,1
8113c3c8:	10000b1e 	bne	r2,zero,8113c3f8 <OSTaskResume+0x1ac>
                    OS_Sched();                               /* Find new highest priority task        */
8113c3cc:	1135c440 	call	81135c44 <OS_Sched>
8113c3d0:	00000906 	br	8113c3f8 <OSTaskResume+0x1ac>
8113c3d4:	e0bff617 	ldw	r2,-40(fp)
8113c3d8:	e0bffb15 	stw	r2,-20(fp)
8113c3dc:	e0bffb17 	ldw	r2,-20(fp)
8113c3e0:	1001703a 	wrctl	status,r2
8113c3e4:	00000406 	br	8113c3f8 <OSTaskResume+0x1ac>
8113c3e8:	e0bff617 	ldw	r2,-40(fp)
8113c3ec:	e0bffc15 	stw	r2,-16(fp)
8113c3f0:	e0bffc17 	ldw	r2,-16(fp)
8113c3f4:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
8113c3f8:	0005883a 	mov	r2,zero
8113c3fc:	00000506 	br	8113c414 <OSTaskResume+0x1c8>
8113c400:	e0bff617 	ldw	r2,-40(fp)
8113c404:	e0bffd15 	stw	r2,-12(fp)
8113c408:	e0bffd17 	ldw	r2,-12(fp)
8113c40c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
8113c410:	00801104 	movi	r2,68
}
8113c414:	e037883a 	mov	sp,fp
8113c418:	dfc00117 	ldw	ra,4(sp)
8113c41c:	df000017 	ldw	fp,0(sp)
8113c420:	dec00204 	addi	sp,sp,8
8113c424:	f800283a 	ret

8113c428 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
8113c428:	defff304 	addi	sp,sp,-52
8113c42c:	de00012e 	bgeu	sp,et,8113c434 <OSTaskStkChk+0xc>
8113c430:	003b68fa 	trap	3
8113c434:	df000c15 	stw	fp,48(sp)
8113c438:	df000c04 	addi	fp,sp,48
8113c43c:	2005883a 	mov	r2,r4
8113c440:	e17fff15 	stw	r5,-4(fp)
8113c444:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
8113c448:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
8113c44c:	e0bffe03 	ldbu	r2,-8(fp)
8113c450:	10800af0 	cmpltui	r2,r2,43
8113c454:	1000051e 	bne	r2,zero,8113c46c <OSTaskStkChk+0x44>
        if (prio != OS_PRIO_SELF) {
8113c458:	e0bffe03 	ldbu	r2,-8(fp)
8113c45c:	10803fe0 	cmpeqi	r2,r2,255
8113c460:	1000021e 	bne	r2,zero,8113c46c <OSTaskStkChk+0x44>
            return (OS_ERR_PRIO_INVALID);
8113c464:	00800a84 	movi	r2,42
8113c468:	00005d06 	br	8113c5e0 <OSTaskStkChk+0x1b8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
8113c46c:	e0bfff17 	ldw	r2,-4(fp)
8113c470:	1000021e 	bne	r2,zero,8113c47c <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
8113c474:	00800244 	movi	r2,9
8113c478:	00005906 	br	8113c5e0 <OSTaskStkChk+0x1b8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
8113c47c:	e0bfff17 	ldw	r2,-4(fp)
8113c480:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
8113c484:	e0bfff17 	ldw	r2,-4(fp)
8113c488:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c48c:	0005303a 	rdctl	r2,status
8113c490:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c494:	e0fffd17 	ldw	r3,-12(fp)
8113c498:	00bfff84 	movi	r2,-2
8113c49c:	1884703a 	and	r2,r3,r2
8113c4a0:	1001703a 	wrctl	status,r2
  
  return context;
8113c4a4:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();
8113c4a8:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
8113c4ac:	e0bffe03 	ldbu	r2,-8(fp)
8113c4b0:	10803fd8 	cmpnei	r2,r2,255
8113c4b4:	1000031e 	bne	r2,zero,8113c4c4 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113c4b8:	d0a09e17 	ldw	r2,-32136(gp)
8113c4bc:	10800c83 	ldbu	r2,50(r2)
8113c4c0:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113c4c4:	e0fffe03 	ldbu	r3,-8(fp)
8113c4c8:	00a045f4 	movhi	r2,33047
8113c4cc:	10a10004 	addi	r2,r2,-31744
8113c4d0:	18c7883a 	add	r3,r3,r3
8113c4d4:	18c7883a 	add	r3,r3,r3
8113c4d8:	10c5883a 	add	r2,r2,r3
8113c4dc:	10800017 	ldw	r2,0(r2)
8113c4e0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
8113c4e4:	e0bff817 	ldw	r2,-32(fp)
8113c4e8:	1000061e 	bne	r2,zero,8113c504 <OSTaskStkChk+0xdc>
8113c4ec:	e0bff617 	ldw	r2,-40(fp)
8113c4f0:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c4f4:	e0bff717 	ldw	r2,-36(fp)
8113c4f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113c4fc:	008010c4 	movi	r2,67
8113c500:	00003706 	br	8113c5e0 <OSTaskStkChk+0x1b8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113c504:	e0bff817 	ldw	r2,-32(fp)
8113c508:	10800058 	cmpnei	r2,r2,1
8113c50c:	1000061e 	bne	r2,zero,8113c528 <OSTaskStkChk+0x100>
8113c510:	e0bff617 	ldw	r2,-40(fp)
8113c514:	e0bff915 	stw	r2,-28(fp)
8113c518:	e0bff917 	ldw	r2,-28(fp)
8113c51c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113c520:	008010c4 	movi	r2,67
8113c524:	00002e06 	br	8113c5e0 <OSTaskStkChk+0x1b8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
8113c528:	e0bff817 	ldw	r2,-32(fp)
8113c52c:	1080040b 	ldhu	r2,16(r2)
8113c530:	10bfffcc 	andi	r2,r2,65535
8113c534:	1080004c 	andi	r2,r2,1
8113c538:	1000061e 	bne	r2,zero,8113c554 <OSTaskStkChk+0x12c>
8113c53c:	e0bff617 	ldw	r2,-40(fp)
8113c540:	e0bffa15 	stw	r2,-24(fp)
8113c544:	e0bffa17 	ldw	r2,-24(fp)
8113c548:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
8113c54c:	00801144 	movi	r2,69
8113c550:	00002306 	br	8113c5e0 <OSTaskStkChk+0x1b8>
    }
    nfree = 0;
8113c554:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
8113c558:	e0bff817 	ldw	r2,-32(fp)
8113c55c:	10800317 	ldw	r2,12(r2)
8113c560:	e0bffc15 	stw	r2,-16(fp)
    pchk  = ptcb->OSTCBStkBottom;
8113c564:	e0bff817 	ldw	r2,-32(fp)
8113c568:	10800217 	ldw	r2,8(r2)
8113c56c:	e0bff415 	stw	r2,-48(fp)
8113c570:	e0bff617 	ldw	r2,-40(fp)
8113c574:	e0bffb15 	stw	r2,-20(fp)
8113c578:	e0bffb17 	ldw	r2,-20(fp)
8113c57c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113c580:	00000306 	br	8113c590 <OSTaskStkChk+0x168>
        nfree++;
8113c584:	e0bff517 	ldw	r2,-44(fp)
8113c588:	10800044 	addi	r2,r2,1
8113c58c:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
8113c590:	e0bff417 	ldw	r2,-48(fp)
8113c594:	10c00104 	addi	r3,r2,4
8113c598:	e0fff415 	stw	r3,-48(fp)
8113c59c:	10800017 	ldw	r2,0(r2)
8113c5a0:	103ff826 	beq	r2,zero,8113c584 <__reset+0xfb11c584>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
8113c5a4:	e0bff517 	ldw	r2,-44(fp)
8113c5a8:	1085883a 	add	r2,r2,r2
8113c5ac:	1085883a 	add	r2,r2,r2
8113c5b0:	1007883a 	mov	r3,r2
8113c5b4:	e0bfff17 	ldw	r2,-4(fp)
8113c5b8:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
8113c5bc:	e0fffc17 	ldw	r3,-16(fp)
8113c5c0:	e0bff517 	ldw	r2,-44(fp)
8113c5c4:	1885c83a 	sub	r2,r3,r2
8113c5c8:	1085883a 	add	r2,r2,r2
8113c5cc:	1085883a 	add	r2,r2,r2
8113c5d0:	1007883a 	mov	r3,r2
8113c5d4:	e0bfff17 	ldw	r2,-4(fp)
8113c5d8:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
8113c5dc:	0005883a 	mov	r2,zero
}
8113c5e0:	e037883a 	mov	sp,fp
8113c5e4:	df000017 	ldw	fp,0(sp)
8113c5e8:	dec00104 	addi	sp,sp,4
8113c5ec:	f800283a 	ret

8113c5f0 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
8113c5f0:	defff504 	addi	sp,sp,-44
8113c5f4:	de00012e 	bgeu	sp,et,8113c5fc <OSTaskSuspend+0xc>
8113c5f8:	003b68fa 	trap	3
8113c5fc:	dfc00a15 	stw	ra,40(sp)
8113c600:	df000915 	stw	fp,36(sp)
8113c604:	df000904 	addi	fp,sp,36
8113c608:	2005883a 	mov	r2,r4
8113c60c:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c610:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
8113c614:	e0bfff03 	ldbu	r2,-4(fp)
8113c618:	10800a98 	cmpnei	r2,r2,42
8113c61c:	1000021e 	bne	r2,zero,8113c628 <OSTaskSuspend+0x38>
        return (OS_ERR_TASK_SUSPEND_IDLE);
8113c620:	008011c4 	movi	r2,71
8113c624:	00006806 	br	8113c7c8 <OSTaskSuspend+0x1d8>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
8113c628:	e0bfff03 	ldbu	r2,-4(fp)
8113c62c:	10800ab0 	cmpltui	r2,r2,42
8113c630:	1000051e 	bne	r2,zero,8113c648 <OSTaskSuspend+0x58>
        if (prio != OS_PRIO_SELF) {
8113c634:	e0bfff03 	ldbu	r2,-4(fp)
8113c638:	10803fe0 	cmpeqi	r2,r2,255
8113c63c:	1000021e 	bne	r2,zero,8113c648 <OSTaskSuspend+0x58>
            return (OS_ERR_PRIO_INVALID);
8113c640:	00800a84 	movi	r2,42
8113c644:	00006006 	br	8113c7c8 <OSTaskSuspend+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c648:	0005303a 	rdctl	r2,status
8113c64c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c650:	e0fffe17 	ldw	r3,-8(fp)
8113c654:	00bfff84 	movi	r2,-2
8113c658:	1884703a 	and	r2,r3,r2
8113c65c:	1001703a 	wrctl	status,r2
  
  return context;
8113c660:	e0bffe17 	ldw	r2,-8(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
8113c664:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
8113c668:	e0bfff03 	ldbu	r2,-4(fp)
8113c66c:	10803fd8 	cmpnei	r2,r2,255
8113c670:	1000061e 	bne	r2,zero,8113c68c <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
8113c674:	d0a09e17 	ldw	r2,-32136(gp)
8113c678:	10800c83 	ldbu	r2,50(r2)
8113c67c:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
8113c680:	00800044 	movi	r2,1
8113c684:	e0bff705 	stb	r2,-36(fp)
8113c688:	00000906 	br	8113c6b0 <OSTaskSuspend+0xc0>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
8113c68c:	d0a09e17 	ldw	r2,-32136(gp)
8113c690:	10800c83 	ldbu	r2,50(r2)
8113c694:	10c03fcc 	andi	r3,r2,255
8113c698:	e0bfff03 	ldbu	r2,-4(fp)
8113c69c:	1880031e 	bne	r3,r2,8113c6ac <OSTaskSuspend+0xbc>
        self = OS_TRUE;
8113c6a0:	00800044 	movi	r2,1
8113c6a4:	e0bff705 	stb	r2,-36(fp)
8113c6a8:	00000106 	br	8113c6b0 <OSTaskSuspend+0xc0>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
8113c6ac:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113c6b0:	e0ffff03 	ldbu	r3,-4(fp)
8113c6b4:	00a045f4 	movhi	r2,33047
8113c6b8:	10a10004 	addi	r2,r2,-31744
8113c6bc:	18c7883a 	add	r3,r3,r3
8113c6c0:	18c7883a 	add	r3,r3,r3
8113c6c4:	10c5883a 	add	r2,r2,r3
8113c6c8:	10800017 	ldw	r2,0(r2)
8113c6cc:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
8113c6d0:	e0bffa17 	ldw	r2,-24(fp)
8113c6d4:	1000061e 	bne	r2,zero,8113c6f0 <OSTaskSuspend+0x100>
8113c6d8:	e0bff817 	ldw	r2,-32(fp)
8113c6dc:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c6e0:	e0bff917 	ldw	r2,-28(fp)
8113c6e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
8113c6e8:	00801204 	movi	r2,72
8113c6ec:	00003606 	br	8113c7c8 <OSTaskSuspend+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
8113c6f0:	e0bffa17 	ldw	r2,-24(fp)
8113c6f4:	10800058 	cmpnei	r2,r2,1
8113c6f8:	1000061e 	bne	r2,zero,8113c714 <OSTaskSuspend+0x124>
8113c6fc:	e0bff817 	ldw	r2,-32(fp)
8113c700:	e0bffb15 	stw	r2,-20(fp)
8113c704:	e0bffb17 	ldw	r2,-20(fp)
8113c708:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113c70c:	008010c4 	movi	r2,67
8113c710:	00002d06 	br	8113c7c8 <OSTaskSuspend+0x1d8>
    }
    y            = ptcb->OSTCBY;
8113c714:	e0bffa17 	ldw	r2,-24(fp)
8113c718:	10800d03 	ldbu	r2,52(r2)
8113c71c:	e0bffd05 	stb	r2,-12(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
8113c720:	e0fffd03 	ldbu	r3,-12(fp)
8113c724:	e13ffd03 	ldbu	r4,-12(fp)
8113c728:	d0a09a44 	addi	r2,gp,-32151
8113c72c:	2085883a 	add	r2,r4,r2
8113c730:	10800003 	ldbu	r2,0(r2)
8113c734:	1009883a 	mov	r4,r2
8113c738:	e0bffa17 	ldw	r2,-24(fp)
8113c73c:	10800d43 	ldbu	r2,53(r2)
8113c740:	0084303a 	nor	r2,zero,r2
8113c744:	2084703a 	and	r2,r4,r2
8113c748:	1009883a 	mov	r4,r2
8113c74c:	d0a09a44 	addi	r2,gp,-32151
8113c750:	1885883a 	add	r2,r3,r2
8113c754:	11000005 	stb	r4,0(r2)
    if (OSRdyTbl[y] == 0) {
8113c758:	e0fffd03 	ldbu	r3,-12(fp)
8113c75c:	d0a09a44 	addi	r2,gp,-32151
8113c760:	1885883a 	add	r2,r3,r2
8113c764:	10800003 	ldbu	r2,0(r2)
8113c768:	10803fcc 	andi	r2,r2,255
8113c76c:	1000071e 	bne	r2,zero,8113c78c <OSTaskSuspend+0x19c>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
8113c770:	e0bffa17 	ldw	r2,-24(fp)
8113c774:	10800d83 	ldbu	r2,54(r2)
8113c778:	0084303a 	nor	r2,zero,r2
8113c77c:	1007883a 	mov	r3,r2
8113c780:	d0a09a03 	ldbu	r2,-32152(gp)
8113c784:	1884703a 	and	r2,r3,r2
8113c788:	d0a09a05 	stb	r2,-32152(gp)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
8113c78c:	e0bffa17 	ldw	r2,-24(fp)
8113c790:	10800c03 	ldbu	r2,48(r2)
8113c794:	10800214 	ori	r2,r2,8
8113c798:	1007883a 	mov	r3,r2
8113c79c:	e0bffa17 	ldw	r2,-24(fp)
8113c7a0:	10c00c05 	stb	r3,48(r2)
8113c7a4:	e0bff817 	ldw	r2,-32(fp)
8113c7a8:	e0bffc15 	stw	r2,-16(fp)
8113c7ac:	e0bffc17 	ldw	r2,-16(fp)
8113c7b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
8113c7b4:	e0bff703 	ldbu	r2,-36(fp)
8113c7b8:	10800058 	cmpnei	r2,r2,1
8113c7bc:	1000011e 	bne	r2,zero,8113c7c4 <OSTaskSuspend+0x1d4>
        OS_Sched();                                             /* Find new highest priority task      */
8113c7c0:	1135c440 	call	81135c44 <OS_Sched>
    }
    return (OS_ERR_NONE);
8113c7c4:	0005883a 	mov	r2,zero
}
8113c7c8:	e037883a 	mov	sp,fp
8113c7cc:	dfc00117 	ldw	ra,4(sp)
8113c7d0:	df000017 	ldw	fp,0(sp)
8113c7d4:	dec00204 	addi	sp,sp,8
8113c7d8:	f800283a 	ret

8113c7dc <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
8113c7dc:	defff604 	addi	sp,sp,-40
8113c7e0:	de00012e 	bgeu	sp,et,8113c7e8 <OSTaskQuery+0xc>
8113c7e4:	003b68fa 	trap	3
8113c7e8:	dfc00915 	stw	ra,36(sp)
8113c7ec:	df000815 	stw	fp,32(sp)
8113c7f0:	df000804 	addi	fp,sp,32
8113c7f4:	2005883a 	mov	r2,r4
8113c7f8:	e17fff15 	stw	r5,-4(fp)
8113c7fc:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c800:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
8113c804:	e0bffe03 	ldbu	r2,-8(fp)
8113c808:	10800af0 	cmpltui	r2,r2,43
8113c80c:	1000051e 	bne	r2,zero,8113c824 <OSTaskQuery+0x48>
        if (prio != OS_PRIO_SELF) {
8113c810:	e0bffe03 	ldbu	r2,-8(fp)
8113c814:	10803fe0 	cmpeqi	r2,r2,255
8113c818:	1000021e 	bne	r2,zero,8113c824 <OSTaskQuery+0x48>
            return (OS_ERR_PRIO_INVALID);
8113c81c:	00800a84 	movi	r2,42
8113c820:	00003406 	br	8113c8f4 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
8113c824:	e0bfff17 	ldw	r2,-4(fp)
8113c828:	1000021e 	bne	r2,zero,8113c834 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
8113c82c:	00800244 	movi	r2,9
8113c830:	00003006 	br	8113c8f4 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c834:	0005303a 	rdctl	r2,status
8113c838:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c83c:	e0fffd17 	ldw	r3,-12(fp)
8113c840:	00bfff84 	movi	r2,-2
8113c844:	1884703a 	and	r2,r3,r2
8113c848:	1001703a 	wrctl	status,r2
  
  return context;
8113c84c:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
8113c850:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
8113c854:	e0bffe03 	ldbu	r2,-8(fp)
8113c858:	10803fd8 	cmpnei	r2,r2,255
8113c85c:	1000031e 	bne	r2,zero,8113c86c <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
8113c860:	d0a09e17 	ldw	r2,-32136(gp)
8113c864:	10800c83 	ldbu	r2,50(r2)
8113c868:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
8113c86c:	e0fffe03 	ldbu	r3,-8(fp)
8113c870:	00a045f4 	movhi	r2,33047
8113c874:	10a10004 	addi	r2,r2,-31744
8113c878:	18c7883a 	add	r3,r3,r3
8113c87c:	18c7883a 	add	r3,r3,r3
8113c880:	10c5883a 	add	r2,r2,r3
8113c884:	10800017 	ldw	r2,0(r2)
8113c888:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
8113c88c:	e0bffa17 	ldw	r2,-24(fp)
8113c890:	1000061e 	bne	r2,zero,8113c8ac <OSTaskQuery+0xd0>
8113c894:	e0bff817 	ldw	r2,-32(fp)
8113c898:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113c89c:	e0bff917 	ldw	r2,-28(fp)
8113c8a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
8113c8a4:	00800a44 	movi	r2,41
8113c8a8:	00001206 	br	8113c8f4 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
8113c8ac:	e0bffa17 	ldw	r2,-24(fp)
8113c8b0:	10800058 	cmpnei	r2,r2,1
8113c8b4:	1000061e 	bne	r2,zero,8113c8d0 <OSTaskQuery+0xf4>
8113c8b8:	e0bff817 	ldw	r2,-32(fp)
8113c8bc:	e0bffb15 	stw	r2,-20(fp)
8113c8c0:	e0bffb17 	ldw	r2,-20(fp)
8113c8c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
8113c8c8:	008010c4 	movi	r2,67
8113c8cc:	00000906 	br	8113c8f4 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
8113c8d0:	01801b04 	movi	r6,108
8113c8d4:	e17ffa17 	ldw	r5,-24(fp)
8113c8d8:	e13fff17 	ldw	r4,-4(fp)
8113c8dc:	1135bd40 	call	81135bd4 <OS_MemCopy>
8113c8e0:	e0bff817 	ldw	r2,-32(fp)
8113c8e4:	e0bffc15 	stw	r2,-16(fp)
8113c8e8:	e0bffc17 	ldw	r2,-16(fp)
8113c8ec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
8113c8f0:	0005883a 	mov	r2,zero
}
8113c8f4:	e037883a 	mov	sp,fp
8113c8f8:	dfc00117 	ldw	ra,4(sp)
8113c8fc:	df000017 	ldw	fp,0(sp)
8113c900:	dec00204 	addi	sp,sp,8
8113c904:	f800283a 	ret

8113c908 <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
8113c908:	defffc04 	addi	sp,sp,-16
8113c90c:	de00012e 	bgeu	sp,et,8113c914 <OS_TaskStkClr+0xc>
8113c910:	003b68fa 	trap	3
8113c914:	df000315 	stw	fp,12(sp)
8113c918:	df000304 	addi	fp,sp,12
8113c91c:	e13ffd15 	stw	r4,-12(fp)
8113c920:	e17ffe15 	stw	r5,-8(fp)
8113c924:	3005883a 	mov	r2,r6
8113c928:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
8113c92c:	e0bfff0b 	ldhu	r2,-4(fp)
8113c930:	1080004c 	andi	r2,r2,1
8113c934:	10000d26 	beq	r2,zero,8113c96c <OS_TaskStkClr+0x64>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
8113c938:	e0bfff0b 	ldhu	r2,-4(fp)
8113c93c:	1080008c 	andi	r2,r2,2
8113c940:	10000a26 	beq	r2,zero,8113c96c <OS_TaskStkClr+0x64>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113c944:	00000706 	br	8113c964 <OS_TaskStkClr+0x5c>
                size--;
8113c948:	e0bffe17 	ldw	r2,-8(fp)
8113c94c:	10bfffc4 	addi	r2,r2,-1
8113c950:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
8113c954:	e0bffd17 	ldw	r2,-12(fp)
8113c958:	10c00104 	addi	r3,r2,4
8113c95c:	e0fffd15 	stw	r3,-12(fp)
8113c960:	10000015 	stw	zero,0(r2)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
8113c964:	e0bffe17 	ldw	r2,-8(fp)
8113c968:	103ff71e 	bne	r2,zero,8113c948 <__reset+0xfb11c948>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
8113c96c:	0001883a 	nop
8113c970:	e037883a 	mov	sp,fp
8113c974:	df000017 	ldw	fp,0(sp)
8113c978:	dec00104 	addi	sp,sp,4
8113c97c:	f800283a 	ret

8113c980 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
8113c980:	defff904 	addi	sp,sp,-28
8113c984:	de00012e 	bgeu	sp,et,8113c98c <OSTimeDly+0xc>
8113c988:	003b68fa 	trap	3
8113c98c:	dfc00615 	stw	ra,24(sp)
8113c990:	df000515 	stw	fp,20(sp)
8113c994:	df000504 	addi	fp,sp,20
8113c998:	2005883a 	mov	r2,r4
8113c99c:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113c9a0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113c9a4:	d0a09d03 	ldbu	r2,-32140(gp)
8113c9a8:	10803fcc 	andi	r2,r2,255
8113c9ac:	1000311e 	bne	r2,zero,8113ca74 <OSTimeDly+0xf4>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
8113c9b0:	e0bfff0b 	ldhu	r2,-4(fp)
8113c9b4:	10003026 	beq	r2,zero,8113ca78 <OSTimeDly+0xf8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113c9b8:	0005303a 	rdctl	r2,status
8113c9bc:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113c9c0:	e0fffe17 	ldw	r3,-8(fp)
8113c9c4:	00bfff84 	movi	r2,-2
8113c9c8:	1884703a 	and	r2,r3,r2
8113c9cc:	1001703a 	wrctl	status,r2
  
  return context;
8113c9d0:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
8113c9d4:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
8113c9d8:	d0a09e17 	ldw	r2,-32136(gp)
8113c9dc:	10800d03 	ldbu	r2,52(r2)
8113c9e0:	e0bffd05 	stb	r2,-12(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
8113c9e4:	e0fffd03 	ldbu	r3,-12(fp)
8113c9e8:	e13ffd03 	ldbu	r4,-12(fp)
8113c9ec:	d0a09a44 	addi	r2,gp,-32151
8113c9f0:	2085883a 	add	r2,r4,r2
8113c9f4:	10800003 	ldbu	r2,0(r2)
8113c9f8:	1009883a 	mov	r4,r2
8113c9fc:	d0a09e17 	ldw	r2,-32136(gp)
8113ca00:	10800d43 	ldbu	r2,53(r2)
8113ca04:	0084303a 	nor	r2,zero,r2
8113ca08:	2084703a 	and	r2,r4,r2
8113ca0c:	1009883a 	mov	r4,r2
8113ca10:	d0a09a44 	addi	r2,gp,-32151
8113ca14:	1885883a 	add	r2,r3,r2
8113ca18:	11000005 	stb	r4,0(r2)
        if (OSRdyTbl[y] == 0) {
8113ca1c:	e0fffd03 	ldbu	r3,-12(fp)
8113ca20:	d0a09a44 	addi	r2,gp,-32151
8113ca24:	1885883a 	add	r2,r3,r2
8113ca28:	10800003 	ldbu	r2,0(r2)
8113ca2c:	10803fcc 	andi	r2,r2,255
8113ca30:	1000071e 	bne	r2,zero,8113ca50 <OSTimeDly+0xd0>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
8113ca34:	d0a09e17 	ldw	r2,-32136(gp)
8113ca38:	10800d83 	ldbu	r2,54(r2)
8113ca3c:	0084303a 	nor	r2,zero,r2
8113ca40:	1007883a 	mov	r3,r2
8113ca44:	d0a09a03 	ldbu	r2,-32152(gp)
8113ca48:	1884703a 	and	r2,r3,r2
8113ca4c:	d0a09a05 	stb	r2,-32152(gp)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
8113ca50:	d0a09e17 	ldw	r2,-32136(gp)
8113ca54:	e0ffff0b 	ldhu	r3,-4(fp)
8113ca58:	10c00b8d 	sth	r3,46(r2)
8113ca5c:	e0bffb17 	ldw	r2,-20(fp)
8113ca60:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ca64:	e0bffc17 	ldw	r2,-16(fp)
8113ca68:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
8113ca6c:	1135c440 	call	81135c44 <OS_Sched>
8113ca70:	00000106 	br	8113ca78 <OSTimeDly+0xf8>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
8113ca74:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
8113ca78:	e037883a 	mov	sp,fp
8113ca7c:	dfc00117 	ldw	ra,4(sp)
8113ca80:	df000017 	ldw	fp,0(sp)
8113ca84:	dec00204 	addi	sp,sp,8
8113ca88:	f800283a 	ret

8113ca8c <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
8113ca8c:	defff804 	addi	sp,sp,-32
8113ca90:	de00012e 	bgeu	sp,et,8113ca98 <OSTimeDlyHMSM+0xc>
8113ca94:	003b68fa 	trap	3
8113ca98:	dfc00715 	stw	ra,28(sp)
8113ca9c:	df000615 	stw	fp,24(sp)
8113caa0:	df000604 	addi	fp,sp,24
8113caa4:	2015883a 	mov	r10,r4
8113caa8:	2809883a 	mov	r4,r5
8113caac:	3007883a 	mov	r3,r6
8113cab0:	3805883a 	mov	r2,r7
8113cab4:	e2bffc05 	stb	r10,-16(fp)
8113cab8:	e13ffd05 	stb	r4,-12(fp)
8113cabc:	e0fffe05 	stb	r3,-8(fp)
8113cac0:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
8113cac4:	d0a09d03 	ldbu	r2,-32140(gp)
8113cac8:	10803fcc 	andi	r2,r2,255
8113cacc:	10000226 	beq	r2,zero,8113cad8 <OSTimeDlyHMSM+0x4c>
        return (OS_ERR_TIME_DLY_ISR);
8113cad0:	00801544 	movi	r2,85
8113cad4:	00004106 	br	8113cbdc <OSTimeDlyHMSM+0x150>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
8113cad8:	e0bffc03 	ldbu	r2,-16(fp)
8113cadc:	1000081e 	bne	r2,zero,8113cb00 <OSTimeDlyHMSM+0x74>
        if (minutes == 0) {
8113cae0:	e0bffd03 	ldbu	r2,-12(fp)
8113cae4:	1000061e 	bne	r2,zero,8113cb00 <OSTimeDlyHMSM+0x74>
            if (seconds == 0) {
8113cae8:	e0bffe03 	ldbu	r2,-8(fp)
8113caec:	1000041e 	bne	r2,zero,8113cb00 <OSTimeDlyHMSM+0x74>
                if (ms == 0) {
8113caf0:	e0bfff0b 	ldhu	r2,-4(fp)
8113caf4:	1000021e 	bne	r2,zero,8113cb00 <OSTimeDlyHMSM+0x74>
                    return (OS_ERR_TIME_ZERO_DLY);
8113caf8:	00801504 	movi	r2,84
8113cafc:	00003706 	br	8113cbdc <OSTimeDlyHMSM+0x150>
                }
            }
        }
    }
    if (minutes > 59) {
8113cb00:	e0bffd03 	ldbu	r2,-12(fp)
8113cb04:	10800f30 	cmpltui	r2,r2,60
8113cb08:	1000021e 	bne	r2,zero,8113cb14 <OSTimeDlyHMSM+0x88>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
8113cb0c:	00801444 	movi	r2,81
8113cb10:	00003206 	br	8113cbdc <OSTimeDlyHMSM+0x150>
    }
    if (seconds > 59) {
8113cb14:	e0bffe03 	ldbu	r2,-8(fp)
8113cb18:	10800f30 	cmpltui	r2,r2,60
8113cb1c:	1000021e 	bne	r2,zero,8113cb28 <OSTimeDlyHMSM+0x9c>
        return (OS_ERR_TIME_INVALID_SECONDS);
8113cb20:	00801484 	movi	r2,82
8113cb24:	00002d06 	br	8113cbdc <OSTimeDlyHMSM+0x150>
    }
    if (ms > 999) {
8113cb28:	e0bfff0b 	ldhu	r2,-4(fp)
8113cb2c:	1080fa30 	cmpltui	r2,r2,1000
8113cb30:	1000021e 	bne	r2,zero,8113cb3c <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_MS);
8113cb34:	008014c4 	movi	r2,83
8113cb38:	00002806 	br	8113cbdc <OSTimeDlyHMSM+0x150>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113cb3c:	e0bffc03 	ldbu	r2,-16(fp)
8113cb40:	10c38424 	muli	r3,r2,3600
8113cb44:	e0bffd03 	ldbu	r2,-12(fp)
8113cb48:	10800f24 	muli	r2,r2,60
8113cb4c:	1887883a 	add	r3,r3,r2
8113cb50:	e0bffe03 	ldbu	r2,-8(fp)
8113cb54:	1885883a 	add	r2,r3,r2
8113cb58:	1100fa24 	muli	r4,r2,1000
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
8113cb5c:	e0bfff0b 	ldhu	r2,-4(fp)
8113cb60:	10c0fa24 	muli	r3,r2,1000
8113cb64:	008418b4 	movhi	r2,4194
8113cb68:	109374c4 	addi	r2,r2,19923
8113cb6c:	188a383a 	mulxuu	r5,r3,r2
8113cb70:	1885383a 	mul	r2,r3,r2
8113cb74:	1011883a 	mov	r8,r2
8113cb78:	2813883a 	mov	r9,r5
8113cb7c:	4804d1ba 	srli	r2,r9,6
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
8113cb80:	2085883a 	add	r2,r4,r2
8113cb84:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
8113cb88:	e0bffb17 	ldw	r2,-20(fp)
8113cb8c:	1004d43a 	srli	r2,r2,16
8113cb90:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
8113cb94:	e0bffb17 	ldw	r2,-20(fp)
8113cb98:	10bfffcc 	andi	r2,r2,65535
8113cb9c:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
8113cba0:	e0bffb17 	ldw	r2,-20(fp)
8113cba4:	10bfffcc 	andi	r2,r2,65535
8113cba8:	1009883a 	mov	r4,r2
8113cbac:	113c9800 	call	8113c980 <OSTimeDly>
    while (loops > 0) {
8113cbb0:	00000706 	br	8113cbd0 <OSTimeDlyHMSM+0x144>
        OSTimeDly((INT16U)32768u);
8113cbb4:	01200014 	movui	r4,32768
8113cbb8:	113c9800 	call	8113c980 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
8113cbbc:	01200014 	movui	r4,32768
8113cbc0:	113c9800 	call	8113c980 <OSTimeDly>
        loops--;
8113cbc4:	e0bffa0b 	ldhu	r2,-24(fp)
8113cbc8:	10bfffc4 	addi	r2,r2,-1
8113cbcc:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
8113cbd0:	e0bffa0b 	ldhu	r2,-24(fp)
8113cbd4:	103ff71e 	bne	r2,zero,8113cbb4 <__reset+0xfb11cbb4>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
8113cbd8:	0005883a 	mov	r2,zero
}
8113cbdc:	e037883a 	mov	sp,fp
8113cbe0:	dfc00117 	ldw	ra,4(sp)
8113cbe4:	df000017 	ldw	fp,0(sp)
8113cbe8:	dec00204 	addi	sp,sp,8
8113cbec:	f800283a 	ret

8113cbf0 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
8113cbf0:	defff504 	addi	sp,sp,-44
8113cbf4:	de00012e 	bgeu	sp,et,8113cbfc <OSTimeDlyResume+0xc>
8113cbf8:	003b68fa 	trap	3
8113cbfc:	dfc00a15 	stw	ra,40(sp)
8113cc00:	df000915 	stw	fp,36(sp)
8113cc04:	df000904 	addi	fp,sp,36
8113cc08:	2005883a 	mov	r2,r4
8113cc0c:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
8113cc10:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
8113cc14:	e0bfff03 	ldbu	r2,-4(fp)
8113cc18:	10800ab0 	cmpltui	r2,r2,42
8113cc1c:	1000021e 	bne	r2,zero,8113cc28 <OSTimeDlyResume+0x38>
        return (OS_ERR_PRIO_INVALID);
8113cc20:	00800a84 	movi	r2,42
8113cc24:	00006406 	br	8113cdb8 <OSTimeDlyResume+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cc28:	0005303a 	rdctl	r2,status
8113cc2c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cc30:	e0fffe17 	ldw	r3,-8(fp)
8113cc34:	00bfff84 	movi	r2,-2
8113cc38:	1884703a 	and	r2,r3,r2
8113cc3c:	1001703a 	wrctl	status,r2
  
  return context;
8113cc40:	e0bffe17 	ldw	r2,-8(fp)
    }
    OS_ENTER_CRITICAL();
8113cc44:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
8113cc48:	e0ffff03 	ldbu	r3,-4(fp)
8113cc4c:	00a045f4 	movhi	r2,33047
8113cc50:	10a10004 	addi	r2,r2,-31744
8113cc54:	18c7883a 	add	r3,r3,r3
8113cc58:	18c7883a 	add	r3,r3,r3
8113cc5c:	10c5883a 	add	r2,r2,r3
8113cc60:	10800017 	ldw	r2,0(r2)
8113cc64:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {
8113cc68:	e0bff917 	ldw	r2,-28(fp)
8113cc6c:	1000061e 	bne	r2,zero,8113cc88 <OSTimeDlyResume+0x98>
8113cc70:	e0bff717 	ldw	r2,-36(fp)
8113cc74:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113cc78:	e0bff817 	ldw	r2,-32(fp)
8113cc7c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113cc80:	008010c4 	movi	r2,67
8113cc84:	00004c06 	br	8113cdb8 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb == OS_TCB_RESERVED) {
8113cc88:	e0bff917 	ldw	r2,-28(fp)
8113cc8c:	10800058 	cmpnei	r2,r2,1
8113cc90:	1000061e 	bne	r2,zero,8113ccac <OSTimeDlyResume+0xbc>
8113cc94:	e0bff717 	ldw	r2,-36(fp)
8113cc98:	e0bffa15 	stw	r2,-24(fp)
8113cc9c:	e0bffa17 	ldw	r2,-24(fp)
8113cca0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
8113cca4:	008010c4 	movi	r2,67
8113cca8:	00004306 	br	8113cdb8 <OSTimeDlyResume+0x1c8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
8113ccac:	e0bff917 	ldw	r2,-28(fp)
8113ccb0:	10800b8b 	ldhu	r2,46(r2)
8113ccb4:	10bfffcc 	andi	r2,r2,65535
8113ccb8:	1000061e 	bne	r2,zero,8113ccd4 <OSTimeDlyResume+0xe4>
8113ccbc:	e0bff717 	ldw	r2,-36(fp)
8113ccc0:	e0bffb15 	stw	r2,-20(fp)
8113ccc4:	e0bffb17 	ldw	r2,-20(fp)
8113ccc8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
8113cccc:	00801404 	movi	r2,80
8113ccd0:	00003906 	br	8113cdb8 <OSTimeDlyResume+0x1c8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
8113ccd4:	e0bff917 	ldw	r2,-28(fp)
8113ccd8:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
8113ccdc:	e0bff917 	ldw	r2,-28(fp)
8113cce0:	10800c03 	ldbu	r2,48(r2)
8113cce4:	10803fcc 	andi	r2,r2,255
8113cce8:	10800dcc 	andi	r2,r2,55
8113ccec:	10000b26 	beq	r2,zero,8113cd1c <OSTimeDlyResume+0x12c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
8113ccf0:	e0bff917 	ldw	r2,-28(fp)
8113ccf4:	10c00c03 	ldbu	r3,48(r2)
8113ccf8:	00bff204 	movi	r2,-56
8113ccfc:	1884703a 	and	r2,r3,r2
8113cd00:	1007883a 	mov	r3,r2
8113cd04:	e0bff917 	ldw	r2,-28(fp)
8113cd08:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
8113cd0c:	e0bff917 	ldw	r2,-28(fp)
8113cd10:	00c00044 	movi	r3,1
8113cd14:	10c00c45 	stb	r3,49(r2)
8113cd18:	00000206 	br	8113cd24 <OSTimeDlyResume+0x134>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
8113cd1c:	e0bff917 	ldw	r2,-28(fp)
8113cd20:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
8113cd24:	e0bff917 	ldw	r2,-28(fp)
8113cd28:	10800c03 	ldbu	r2,48(r2)
8113cd2c:	10803fcc 	andi	r2,r2,255
8113cd30:	1080020c 	andi	r2,r2,8
8113cd34:	10001b1e 	bne	r2,zero,8113cda4 <OSTimeDlyResume+0x1b4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
8113cd38:	e0bff917 	ldw	r2,-28(fp)
8113cd3c:	10c00d83 	ldbu	r3,54(r2)
8113cd40:	d0a09a03 	ldbu	r2,-32152(gp)
8113cd44:	1884b03a 	or	r2,r3,r2
8113cd48:	d0a09a05 	stb	r2,-32152(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
8113cd4c:	e0bff917 	ldw	r2,-28(fp)
8113cd50:	10800d03 	ldbu	r2,52(r2)
8113cd54:	10c03fcc 	andi	r3,r2,255
8113cd58:	e0bff917 	ldw	r2,-28(fp)
8113cd5c:	10800d03 	ldbu	r2,52(r2)
8113cd60:	11003fcc 	andi	r4,r2,255
8113cd64:	d0a09a44 	addi	r2,gp,-32151
8113cd68:	2085883a 	add	r2,r4,r2
8113cd6c:	11000003 	ldbu	r4,0(r2)
8113cd70:	e0bff917 	ldw	r2,-28(fp)
8113cd74:	10800d43 	ldbu	r2,53(r2)
8113cd78:	2084b03a 	or	r2,r4,r2
8113cd7c:	1009883a 	mov	r4,r2
8113cd80:	d0a09a44 	addi	r2,gp,-32151
8113cd84:	1885883a 	add	r2,r3,r2
8113cd88:	11000005 	stb	r4,0(r2)
8113cd8c:	e0bff717 	ldw	r2,-36(fp)
8113cd90:	e0bffc15 	stw	r2,-16(fp)
8113cd94:	e0bffc17 	ldw	r2,-16(fp)
8113cd98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
8113cd9c:	1135c440 	call	81135c44 <OS_Sched>
8113cda0:	00000406 	br	8113cdb4 <OSTimeDlyResume+0x1c4>
8113cda4:	e0bff717 	ldw	r2,-36(fp)
8113cda8:	e0bffd15 	stw	r2,-12(fp)
8113cdac:	e0bffd17 	ldw	r2,-12(fp)
8113cdb0:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
8113cdb4:	0005883a 	mov	r2,zero
}
8113cdb8:	e037883a 	mov	sp,fp
8113cdbc:	dfc00117 	ldw	ra,4(sp)
8113cdc0:	df000017 	ldw	fp,0(sp)
8113cdc4:	dec00204 	addi	sp,sp,8
8113cdc8:	f800283a 	ret

8113cdcc <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
8113cdcc:	defffb04 	addi	sp,sp,-20
8113cdd0:	de00012e 	bgeu	sp,et,8113cdd8 <OSTimeGet+0xc>
8113cdd4:	003b68fa 	trap	3
8113cdd8:	df000415 	stw	fp,16(sp)
8113cddc:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113cde0:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113cde4:	0005303a 	rdctl	r2,status
8113cde8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113cdec:	e0fffe17 	ldw	r3,-8(fp)
8113cdf0:	00bfff84 	movi	r2,-2
8113cdf4:	1884703a 	and	r2,r3,r2
8113cdf8:	1001703a 	wrctl	status,r2
  
  return context;
8113cdfc:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
8113ce00:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
8113ce04:	d0a0a017 	ldw	r2,-32128(gp)
8113ce08:	e0bffd15 	stw	r2,-12(fp)
8113ce0c:	e0bffc17 	ldw	r2,-16(fp)
8113ce10:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ce14:	e0bfff17 	ldw	r2,-4(fp)
8113ce18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
8113ce1c:	e0bffd17 	ldw	r2,-12(fp)
}
8113ce20:	e037883a 	mov	sp,fp
8113ce24:	df000017 	ldw	fp,0(sp)
8113ce28:	dec00104 	addi	sp,sp,4
8113ce2c:	f800283a 	ret

8113ce30 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
8113ce30:	defffb04 	addi	sp,sp,-20
8113ce34:	de00012e 	bgeu	sp,et,8113ce3c <OSTimeSet+0xc>
8113ce38:	003b68fa 	trap	3
8113ce3c:	df000415 	stw	fp,16(sp)
8113ce40:	df000404 	addi	fp,sp,16
8113ce44:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
8113ce48:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
8113ce4c:	0005303a 	rdctl	r2,status
8113ce50:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8113ce54:	e0fffd17 	ldw	r3,-12(fp)
8113ce58:	00bfff84 	movi	r2,-2
8113ce5c:	1884703a 	and	r2,r3,r2
8113ce60:	1001703a 	wrctl	status,r2
  
  return context;
8113ce64:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
8113ce68:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
8113ce6c:	e0bfff17 	ldw	r2,-4(fp)
8113ce70:	d0a0a015 	stw	r2,-32128(gp)
8113ce74:	e0bffc17 	ldw	r2,-16(fp)
8113ce78:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8113ce7c:	e0bffe17 	ldw	r2,-8(fp)
8113ce80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
8113ce84:	0001883a 	nop
8113ce88:	e037883a 	mov	sp,fp
8113ce8c:	df000017 	ldw	fp,0(sp)
8113ce90:	dec00104 	addi	sp,sp,4
8113ce94:	f800283a 	ret

8113ce98 <OSTmrCreate>:
                      INT8U            opt,
                      OS_TMR_CALLBACK  callback,
                      void            *callback_arg,
                      INT8U           *pname,
                      INT8U           *perr)
{
8113ce98:	defff804 	addi	sp,sp,-32
8113ce9c:	de00012e 	bgeu	sp,et,8113cea4 <OSTmrCreate+0xc>
8113cea0:	003b68fa 	trap	3
8113cea4:	dfc00715 	stw	ra,28(sp)
8113cea8:	df000615 	stw	fp,24(sp)
8113ceac:	df000604 	addi	fp,sp,24
8113ceb0:	e13ffc15 	stw	r4,-16(fp)
8113ceb4:	e17ffd15 	stw	r5,-12(fp)
8113ceb8:	3005883a 	mov	r2,r6
8113cebc:	e1ffff15 	stw	r7,-4(fp)
8113cec0:	e0bffe05 	stb	r2,-8(fp)
    INT8U     len;
#endif


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113cec4:	e0800417 	ldw	r2,16(fp)
8113cec8:	1000021e 	bne	r2,zero,8113ced4 <OSTmrCreate+0x3c>
        return ((OS_TMR *)0);
8113cecc:	0005883a 	mov	r2,zero
8113ced0:	00005d06 	br	8113d048 <OSTmrCreate+0x1b0>
    }
    switch (opt) {
8113ced4:	e0bffe03 	ldbu	r2,-8(fp)
8113ced8:	10c00060 	cmpeqi	r3,r2,1
8113cedc:	1800091e 	bne	r3,zero,8113cf04 <OSTmrCreate+0x6c>
8113cee0:	108000a0 	cmpeqi	r2,r2,2
8113cee4:	10000e26 	beq	r2,zero,8113cf20 <OSTmrCreate+0x88>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
8113cee8:	e0bffd17 	ldw	r2,-12(fp)
8113ceec:	1000111e 	bne	r2,zero,8113cf34 <OSTmrCreate+0x9c>
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
8113cef0:	e0800417 	ldw	r2,16(fp)
8113cef4:	00ffe0c4 	movi	r3,-125
8113cef8:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113cefc:	0005883a 	mov	r2,zero
8113cf00:	00005106 	br	8113d048 <OSTmrCreate+0x1b0>
             }
             break;

        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
8113cf04:	e0bffc17 	ldw	r2,-16(fp)
8113cf08:	10000c1e 	bne	r2,zero,8113cf3c <OSTmrCreate+0xa4>
                 *perr = OS_ERR_TMR_INVALID_DLY;
8113cf0c:	e0800417 	ldw	r2,16(fp)
8113cf10:	00ffe084 	movi	r3,-126
8113cf14:	10c00005 	stb	r3,0(r2)
                 return ((OS_TMR *)0);
8113cf18:	0005883a 	mov	r2,zero
8113cf1c:	00004a06 	br	8113d048 <OSTmrCreate+0x1b0>
             }
             break;

        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
8113cf20:	e0800417 	ldw	r2,16(fp)
8113cf24:	00ffe104 	movi	r3,-124
8113cf28:	10c00005 	stb	r3,0(r2)
             return ((OS_TMR *)0);
8113cf2c:	0005883a 	mov	r2,zero
8113cf30:	00004506 	br	8113d048 <OSTmrCreate+0x1b0>
        case OS_TMR_OPT_PERIODIC:
             if (period == 0) {
                 *perr = OS_ERR_TMR_INVALID_PERIOD;
                 return ((OS_TMR *)0);
             }
             break;
8113cf34:	0001883a 	nop
8113cf38:	00000106 	br	8113cf40 <OSTmrCreate+0xa8>
        case OS_TMR_OPT_ONE_SHOT:
             if (dly == 0) {
                 *perr = OS_ERR_TMR_INVALID_DLY;
                 return ((OS_TMR *)0);
             }
             break;
8113cf3c:	0001883a 	nop
        default:
             *perr = OS_ERR_TMR_INVALID_OPT;
             return ((OS_TMR *)0);
    }
#endif
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113cf40:	d0a09d03 	ldbu	r2,-32140(gp)
8113cf44:	10803fcc 	andi	r2,r2,255
8113cf48:	10000526 	beq	r2,zero,8113cf60 <OSTmrCreate+0xc8>
        *perr  = OS_ERR_TMR_ISR;
8113cf4c:	e0800417 	ldw	r2,16(fp)
8113cf50:	00ffe2c4 	movi	r3,-117
8113cf54:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113cf58:	0005883a 	mov	r2,zero
8113cf5c:	00003a06 	br	8113d048 <OSTmrCreate+0x1b0>
    }
    OSTmr_Lock();
8113cf60:	113de500 	call	8113de50 <OSTmr_Lock>
    ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
8113cf64:	113d8f00 	call	8113d8f0 <OSTmr_Alloc>
8113cf68:	e0bffa15 	stw	r2,-24(fp)
    if (ptmr == (OS_TMR *)0) {
8113cf6c:	e0bffa17 	ldw	r2,-24(fp)
8113cf70:	1000061e 	bne	r2,zero,8113cf8c <OSTmrCreate+0xf4>
        OSTmr_Unlock();
8113cf74:	113de940 	call	8113de94 <OSTmr_Unlock>
        *perr = OS_ERR_TMR_NON_AVAIL;
8113cf78:	e0800417 	ldw	r2,16(fp)
8113cf7c:	00ffe184 	movi	r3,-122
8113cf80:	10c00005 	stb	r3,0(r2)
        return ((OS_TMR *)0);
8113cf84:	0005883a 	mov	r2,zero
8113cf88:	00002f06 	br	8113d048 <OSTmrCreate+0x1b0>
    }
    ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
8113cf8c:	e0bffa17 	ldw	r2,-24(fp)
8113cf90:	00c00044 	movi	r3,1
8113cf94:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrDly         = dly;
8113cf98:	e0bffa17 	ldw	r2,-24(fp)
8113cf9c:	e0fffc17 	ldw	r3,-16(fp)
8113cfa0:	10c00615 	stw	r3,24(r2)
    ptmr->OSTmrPeriod      = period;
8113cfa4:	e0bffa17 	ldw	r2,-24(fp)
8113cfa8:	e0fffd17 	ldw	r3,-12(fp)
8113cfac:	10c00715 	stw	r3,28(r2)
    ptmr->OSTmrOpt         = opt;
8113cfb0:	e0bffa17 	ldw	r2,-24(fp)
8113cfb4:	e0fffe03 	ldbu	r3,-8(fp)
8113cfb8:	10c00c05 	stb	r3,48(r2)
    ptmr->OSTmrCallback    = callback;
8113cfbc:	e0bffa17 	ldw	r2,-24(fp)
8113cfc0:	e0ffff17 	ldw	r3,-4(fp)
8113cfc4:	10c00115 	stw	r3,4(r2)
    ptmr->OSTmrCallbackArg = callback_arg;
8113cfc8:	e0bffa17 	ldw	r2,-24(fp)
8113cfcc:	e0c00217 	ldw	r3,8(fp)
8113cfd0:	10c00215 	stw	r3,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 0
    if (pname !=(INT8U *)0) {
8113cfd4:	e0800317 	ldw	r2,12(fp)
8113cfd8:	10001726 	beq	r2,zero,8113d038 <OSTmrCreate+0x1a0>
        len = OS_StrLen(pname);                             /* Copy timer name                                        */
8113cfdc:	e1000317 	ldw	r4,12(fp)
8113cfe0:	1135e140 	call	81135e14 <OS_StrLen>
8113cfe4:	e0bffb05 	stb	r2,-20(fp)
        if (len < OS_TMR_CFG_NAME_SIZE) {
8113cfe8:	e0bffb03 	ldbu	r2,-20(fp)
8113cfec:	10800428 	cmpgeui	r2,r2,16
8113cff0:	1000061e 	bne	r2,zero,8113d00c <OSTmrCreate+0x174>
            (void)OS_StrCopy(ptmr->OSTmrName, pname);
8113cff4:	e0bffa17 	ldw	r2,-24(fp)
8113cff8:	10800804 	addi	r2,r2,32
8113cffc:	e1400317 	ldw	r5,12(fp)
8113d000:	1009883a 	mov	r4,r2
8113d004:	1135d980 	call	81135d98 <OS_StrCopy>
8113d008:	00000b06 	br	8113d038 <OSTmrCreate+0x1a0>
        } else {
#if OS_TMR_CFG_NAME_SIZE > 1
            ptmr->OSTmrName[0] = '#';                       /* Invalid size specified                                 */
8113d00c:	e0bffa17 	ldw	r2,-24(fp)
8113d010:	00c008c4 	movi	r3,35
8113d014:	10c00805 	stb	r3,32(r2)
            ptmr->OSTmrName[1] = OS_ASCII_NUL;
8113d018:	e0bffa17 	ldw	r2,-24(fp)
8113d01c:	10000845 	stb	zero,33(r2)
#endif
            *perr              = OS_ERR_TMR_NAME_TOO_LONG;
8113d020:	e0800417 	ldw	r2,16(fp)
8113d024:	00ffe304 	movi	r3,-116
8113d028:	10c00005 	stb	r3,0(r2)
            OSTmr_Unlock();
8113d02c:	113de940 	call	8113de94 <OSTmr_Unlock>
            return (ptmr);
8113d030:	e0bffa17 	ldw	r2,-24(fp)
8113d034:	00000406 	br	8113d048 <OSTmrCreate+0x1b0>
        }
    }
#endif
    OSTmr_Unlock();
8113d038:	113de940 	call	8113de94 <OSTmr_Unlock>
    *perr = OS_ERR_NONE;
8113d03c:	e0800417 	ldw	r2,16(fp)
8113d040:	10000005 	stb	zero,0(r2)
    return (ptmr);
8113d044:	e0bffa17 	ldw	r2,-24(fp)
}
8113d048:	e037883a 	mov	sp,fp
8113d04c:	dfc00117 	ldw	ra,4(sp)
8113d050:	df000017 	ldw	fp,0(sp)
8113d054:	dec00204 	addi	sp,sp,8
8113d058:	f800283a 	ret

8113d05c <OSTmrDel>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
                   INT8U   *perr)
{
8113d05c:	defffc04 	addi	sp,sp,-16
8113d060:	de00012e 	bgeu	sp,et,8113d068 <OSTmrDel+0xc>
8113d064:	003b68fa 	trap	3
8113d068:	dfc00315 	stw	ra,12(sp)
8113d06c:	df000215 	stw	fp,8(sp)
8113d070:	df000204 	addi	fp,sp,8
8113d074:	e13ffe15 	stw	r4,-8(fp)
8113d078:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113d07c:	e0bfff17 	ldw	r2,-4(fp)
8113d080:	1000021e 	bne	r2,zero,8113d08c <OSTmrDel+0x30>
        return (OS_FALSE);
8113d084:	0005883a 	mov	r2,zero
8113d088:	00003f06 	br	8113d188 <OSTmrDel+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113d08c:	e0bffe17 	ldw	r2,-8(fp)
8113d090:	1000051e 	bne	r2,zero,8113d0a8 <OSTmrDel+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113d094:	e0bfff17 	ldw	r2,-4(fp)
8113d098:	00ffe284 	movi	r3,-118
8113d09c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d0a0:	0005883a 	mov	r2,zero
8113d0a4:	00003806 	br	8113d188 <OSTmrDel+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113d0a8:	e0bffe17 	ldw	r2,-8(fp)
8113d0ac:	10800003 	ldbu	r2,0(r2)
8113d0b0:	10803fcc 	andi	r2,r2,255
8113d0b4:	10801920 	cmpeqi	r2,r2,100
8113d0b8:	1000051e 	bne	r2,zero,8113d0d0 <OSTmrDel+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113d0bc:	e0bfff17 	ldw	r2,-4(fp)
8113d0c0:	00ffe244 	movi	r3,-119
8113d0c4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d0c8:	0005883a 	mov	r2,zero
8113d0cc:	00002e06 	br	8113d188 <OSTmrDel+0x12c>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113d0d0:	d0a09d03 	ldbu	r2,-32140(gp)
8113d0d4:	10803fcc 	andi	r2,r2,255
8113d0d8:	10000526 	beq	r2,zero,8113d0f0 <OSTmrDel+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113d0dc:	e0bfff17 	ldw	r2,-4(fp)
8113d0e0:	00ffe2c4 	movi	r3,-117
8113d0e4:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d0e8:	0005883a 	mov	r2,zero
8113d0ec:	00002606 	br	8113d188 <OSTmrDel+0x12c>
    }
    OSTmr_Lock();
8113d0f0:	113de500 	call	8113de50 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113d0f4:	e0bffe17 	ldw	r2,-8(fp)
8113d0f8:	10800c43 	ldbu	r2,49(r2)
8113d0fc:	10803fcc 	andi	r2,r2,255
8113d100:	10c000c8 	cmpgei	r3,r2,3
8113d104:	1800031e 	bne	r3,zero,8113d114 <OSTmrDel+0xb8>
8113d108:	00800d16 	blt	zero,r2,8113d140 <OSTmrDel+0xe4>
8113d10c:	10001326 	beq	r2,zero,8113d15c <OSTmrDel+0x100>
8113d110:	00001806 	br	8113d174 <OSTmrDel+0x118>
8113d114:	108000e0 	cmpeqi	r2,r2,3
8113d118:	10001626 	beq	r2,zero,8113d174 <OSTmrDel+0x118>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
8113d11c:	e13ffe17 	ldw	r4,-8(fp)
8113d120:	113dd540 	call	8113dd54 <OSTmr_Unlink>
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113d124:	e13ffe17 	ldw	r4,-8(fp)
8113d128:	113d9640 	call	8113d964 <OSTmr_Free>
             OSTmr_Unlock();
8113d12c:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113d130:	e0bfff17 	ldw	r2,-4(fp)
8113d134:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113d138:	00800044 	movi	r2,1
8113d13c:	00001206 	br	8113d188 <OSTmrDel+0x12c>

        case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
        case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
             OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
8113d140:	e13ffe17 	ldw	r4,-8(fp)
8113d144:	113d9640 	call	8113d964 <OSTmr_Free>
             OSTmr_Unlock();
8113d148:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113d14c:	e0bfff17 	ldw	r2,-4(fp)
8113d150:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113d154:	00800044 	movi	r2,1
8113d158:	00000b06 	br	8113d188 <OSTmrDel+0x12c>

        case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
             OSTmr_Unlock();
8113d15c:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113d160:	e0bfff17 	ldw	r2,-4(fp)
8113d164:	00ffe1c4 	movi	r3,-121
8113d168:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113d16c:	0005883a 	mov	r2,zero
8113d170:	00000506 	br	8113d188 <OSTmrDel+0x12c>

        default:
             OSTmr_Unlock();
8113d174:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113d178:	e0bfff17 	ldw	r2,-4(fp)
8113d17c:	00ffe344 	movi	r3,-115
8113d180:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113d184:	0005883a 	mov	r2,zero
    }
}
8113d188:	e037883a 	mov	sp,fp
8113d18c:	dfc00117 	ldw	ra,4(sp)
8113d190:	df000017 	ldw	fp,0(sp)
8113d194:	dec00204 	addi	sp,sp,8
8113d198:	f800283a 	ret

8113d19c <OSTmrNameGet>:

#if OS_TMR_EN > 0 && OS_TMR_CFG_NAME_SIZE > 0
INT8U  OSTmrNameGet (OS_TMR  *ptmr,
                     INT8U   *pdest,
                     INT8U   *perr)
{
8113d19c:	defffa04 	addi	sp,sp,-24
8113d1a0:	de00012e 	bgeu	sp,et,8113d1a8 <OSTmrNameGet+0xc>
8113d1a4:	003b68fa 	trap	3
8113d1a8:	dfc00515 	stw	ra,20(sp)
8113d1ac:	df000415 	stw	fp,16(sp)
8113d1b0:	df000404 	addi	fp,sp,16
8113d1b4:	e13ffd15 	stw	r4,-12(fp)
8113d1b8:	e17ffe15 	stw	r5,-8(fp)
8113d1bc:	e1bfff15 	stw	r6,-4(fp)
    INT8U  len;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113d1c0:	e0bfff17 	ldw	r2,-4(fp)
8113d1c4:	1000021e 	bne	r2,zero,8113d1d0 <OSTmrNameGet+0x34>
        return (0);
8113d1c8:	0005883a 	mov	r2,zero
8113d1cc:	00003e06 	br	8113d2c8 <OSTmrNameGet+0x12c>
    }
    if (pdest == (INT8U *)0) {
8113d1d0:	e0bffe17 	ldw	r2,-8(fp)
8113d1d4:	1000051e 	bne	r2,zero,8113d1ec <OSTmrNameGet+0x50>
        *perr = OS_ERR_TMR_INVALID_DEST;
8113d1d8:	e0bfff17 	ldw	r2,-4(fp)
8113d1dc:	00ffe204 	movi	r3,-120
8113d1e0:	10c00005 	stb	r3,0(r2)
        return (0);
8113d1e4:	0005883a 	mov	r2,zero
8113d1e8:	00003706 	br	8113d2c8 <OSTmrNameGet+0x12c>
    }
    if (ptmr == (OS_TMR *)0) {
8113d1ec:	e0bffd17 	ldw	r2,-12(fp)
8113d1f0:	1000051e 	bne	r2,zero,8113d208 <OSTmrNameGet+0x6c>
        *perr = OS_ERR_TMR_INVALID;
8113d1f4:	e0bfff17 	ldw	r2,-4(fp)
8113d1f8:	00ffe284 	movi	r3,-118
8113d1fc:	10c00005 	stb	r3,0(r2)
        return (0);
8113d200:	0005883a 	mov	r2,zero
8113d204:	00003006 	br	8113d2c8 <OSTmrNameGet+0x12c>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113d208:	e0bffd17 	ldw	r2,-12(fp)
8113d20c:	10800003 	ldbu	r2,0(r2)
8113d210:	10803fcc 	andi	r2,r2,255
8113d214:	10801920 	cmpeqi	r2,r2,100
8113d218:	1000051e 	bne	r2,zero,8113d230 <OSTmrNameGet+0x94>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113d21c:	e0bfff17 	ldw	r2,-4(fp)
8113d220:	00ffe244 	movi	r3,-119
8113d224:	10c00005 	stb	r3,0(r2)
        return (0);
8113d228:	0005883a 	mov	r2,zero
8113d22c:	00002606 	br	8113d2c8 <OSTmrNameGet+0x12c>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113d230:	d0a09d03 	ldbu	r2,-32140(gp)
8113d234:	10803fcc 	andi	r2,r2,255
8113d238:	10000526 	beq	r2,zero,8113d250 <OSTmrNameGet+0xb4>
        *perr = OS_ERR_NAME_GET_ISR;
8113d23c:	e0bfff17 	ldw	r2,-4(fp)
8113d240:	00c00444 	movi	r3,17
8113d244:	10c00005 	stb	r3,0(r2)
        return (0);
8113d248:	0005883a 	mov	r2,zero
8113d24c:	00001e06 	br	8113d2c8 <OSTmrNameGet+0x12c>
    }
    OSTmr_Lock();
8113d250:	113de500 	call	8113de50 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113d254:	e0bffd17 	ldw	r2,-12(fp)
8113d258:	10800c43 	ldbu	r2,49(r2)
8113d25c:	10803fcc 	andi	r2,r2,255
8113d260:	10000e26 	beq	r2,zero,8113d29c <OSTmrNameGet+0x100>
8113d264:	10001316 	blt	r2,zero,8113d2b4 <OSTmrNameGet+0x118>
8113d268:	10800108 	cmpgei	r2,r2,4
8113d26c:	1000111e 	bne	r2,zero,8113d2b4 <OSTmrNameGet+0x118>
        case OS_TMR_STATE_RUNNING:
        case OS_TMR_STATE_STOPPED:
        case OS_TMR_STATE_COMPLETED:
             len   = OS_StrCopy(pdest, ptmr->OSTmrName);
8113d270:	e0bffd17 	ldw	r2,-12(fp)
8113d274:	10800804 	addi	r2,r2,32
8113d278:	100b883a 	mov	r5,r2
8113d27c:	e13ffe17 	ldw	r4,-8(fp)
8113d280:	1135d980 	call	81135d98 <OS_StrCopy>
8113d284:	e0bffc05 	stb	r2,-16(fp)
             OSTmr_Unlock();
8113d288:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113d28c:	e0bfff17 	ldw	r2,-4(fp)
8113d290:	10000005 	stb	zero,0(r2)
             return (len);
8113d294:	e0bffc03 	ldbu	r2,-16(fp)
8113d298:	00000b06 	br	8113d2c8 <OSTmrNameGet+0x12c>

        case OS_TMR_STATE_UNUSED:                      /* Timer is not allocated                                      */
             OSTmr_Unlock();
8113d29c:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113d2a0:	e0bfff17 	ldw	r2,-4(fp)
8113d2a4:	00ffe1c4 	movi	r3,-121
8113d2a8:	10c00005 	stb	r3,0(r2)
             return (0);
8113d2ac:	0005883a 	mov	r2,zero
8113d2b0:	00000506 	br	8113d2c8 <OSTmrNameGet+0x12c>

        default:
             OSTmr_Unlock();
8113d2b4:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113d2b8:	e0bfff17 	ldw	r2,-4(fp)
8113d2bc:	00ffe344 	movi	r3,-115
8113d2c0:	10c00005 	stb	r3,0(r2)
             return (0);
8113d2c4:	0005883a 	mov	r2,zero
    }
}
8113d2c8:	e037883a 	mov	sp,fp
8113d2cc:	dfc00117 	ldw	ra,4(sp)
8113d2d0:	df000017 	ldw	fp,0(sp)
8113d2d4:	dec00204 	addi	sp,sp,8
8113d2d8:	f800283a 	ret

8113d2dc <OSTmrRemainGet>:
*/

#if OS_TMR_EN > 0
INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
                        INT8U   *perr)
{
8113d2dc:	defffb04 	addi	sp,sp,-20
8113d2e0:	de00012e 	bgeu	sp,et,8113d2e8 <OSTmrRemainGet+0xc>
8113d2e4:	003b68fa 	trap	3
8113d2e8:	dfc00415 	stw	ra,16(sp)
8113d2ec:	df000315 	stw	fp,12(sp)
8113d2f0:	df000304 	addi	fp,sp,12
8113d2f4:	e13ffe15 	stw	r4,-8(fp)
8113d2f8:	e17fff15 	stw	r5,-4(fp)
    INT32U  remain;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113d2fc:	e0bfff17 	ldw	r2,-4(fp)
8113d300:	1000021e 	bne	r2,zero,8113d30c <OSTmrRemainGet+0x30>
        return (0);
8113d304:	0005883a 	mov	r2,zero
8113d308:	00005d06 	br	8113d480 <OSTmrRemainGet+0x1a4>
    }
    if (ptmr == (OS_TMR *)0) {
8113d30c:	e0bffe17 	ldw	r2,-8(fp)
8113d310:	1000051e 	bne	r2,zero,8113d328 <OSTmrRemainGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113d314:	e0bfff17 	ldw	r2,-4(fp)
8113d318:	00ffe284 	movi	r3,-118
8113d31c:	10c00005 	stb	r3,0(r2)
        return (0);
8113d320:	0005883a 	mov	r2,zero
8113d324:	00005606 	br	8113d480 <OSTmrRemainGet+0x1a4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113d328:	e0bffe17 	ldw	r2,-8(fp)
8113d32c:	10800003 	ldbu	r2,0(r2)
8113d330:	10803fcc 	andi	r2,r2,255
8113d334:	10801920 	cmpeqi	r2,r2,100
8113d338:	1000051e 	bne	r2,zero,8113d350 <OSTmrRemainGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113d33c:	e0bfff17 	ldw	r2,-4(fp)
8113d340:	00ffe244 	movi	r3,-119
8113d344:	10c00005 	stb	r3,0(r2)
        return (0);
8113d348:	0005883a 	mov	r2,zero
8113d34c:	00004c06 	br	8113d480 <OSTmrRemainGet+0x1a4>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113d350:	d0a09d03 	ldbu	r2,-32140(gp)
8113d354:	10803fcc 	andi	r2,r2,255
8113d358:	10000526 	beq	r2,zero,8113d370 <OSTmrRemainGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113d35c:	e0bfff17 	ldw	r2,-4(fp)
8113d360:	00ffe2c4 	movi	r3,-117
8113d364:	10c00005 	stb	r3,0(r2)
        return (0);
8113d368:	0005883a 	mov	r2,zero
8113d36c:	00004406 	br	8113d480 <OSTmrRemainGet+0x1a4>
    }
    OSTmr_Lock();
8113d370:	113de500 	call	8113de50 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113d374:	e0bffe17 	ldw	r2,-8(fp)
8113d378:	10800c43 	ldbu	r2,49(r2)
8113d37c:	10803fcc 	andi	r2,r2,255
8113d380:	10c00060 	cmpeqi	r3,r2,1
8113d384:	1800121e 	bne	r3,zero,8113d3d0 <OSTmrRemainGet+0xf4>
8113d388:	10c00088 	cmpgei	r3,r2,2
8113d38c:	1800021e 	bne	r3,zero,8113d398 <OSTmrRemainGet+0xbc>
8113d390:	10003026 	beq	r2,zero,8113d454 <OSTmrRemainGet+0x178>
8113d394:	00003506 	br	8113d46c <OSTmrRemainGet+0x190>
8113d398:	10c000a0 	cmpeqi	r3,r2,2
8113d39c:	1800281e 	bne	r3,zero,8113d440 <OSTmrRemainGet+0x164>
8113d3a0:	108000e0 	cmpeqi	r2,r2,3
8113d3a4:	10003126 	beq	r2,zero,8113d46c <OSTmrRemainGet+0x190>
        case OS_TMR_STATE_RUNNING:
             remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
8113d3a8:	e0bffe17 	ldw	r2,-8(fp)
8113d3ac:	10c00517 	ldw	r3,20(r2)
8113d3b0:	d0a09f17 	ldw	r2,-32132(gp)
8113d3b4:	1885c83a 	sub	r2,r3,r2
8113d3b8:	e0bffd15 	stw	r2,-12(fp)
             OSTmr_Unlock();
8113d3bc:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr  = OS_ERR_NONE;
8113d3c0:	e0bfff17 	ldw	r2,-4(fp)
8113d3c4:	10000005 	stb	zero,0(r2)
             return (remain);
8113d3c8:	e0bffd17 	ldw	r2,-12(fp)
8113d3cc:	00002c06 	br	8113d480 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
             switch (ptmr->OSTmrOpt) {
8113d3d0:	e0bffe17 	ldw	r2,-8(fp)
8113d3d4:	10800c03 	ldbu	r2,48(r2)
8113d3d8:	10803fcc 	andi	r2,r2,255
8113d3dc:	108000a0 	cmpeqi	r2,r2,2
8113d3e0:	10000e26 	beq	r2,zero,8113d41c <OSTmrRemainGet+0x140>
                 case OS_TMR_OPT_PERIODIC:
                      if (ptmr->OSTmrDly == 0) {
8113d3e4:	e0bffe17 	ldw	r2,-8(fp)
8113d3e8:	10800617 	ldw	r2,24(r2)
8113d3ec:	1000041e 	bne	r2,zero,8113d400 <OSTmrRemainGet+0x124>
                          remain = ptmr->OSTmrPeriod;
8113d3f0:	e0bffe17 	ldw	r2,-8(fp)
8113d3f4:	10800717 	ldw	r2,28(r2)
8113d3f8:	e0bffd15 	stw	r2,-12(fp)
8113d3fc:	00000306 	br	8113d40c <OSTmrRemainGet+0x130>
                      } else {
                          remain = ptmr->OSTmrDly;
8113d400:	e0bffe17 	ldw	r2,-8(fp)
8113d404:	10800617 	ldw	r2,24(r2)
8113d408:	e0bffd15 	stw	r2,-12(fp)
                      }
                      OSTmr_Unlock();
8113d40c:	113de940 	call	8113de94 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113d410:	e0bfff17 	ldw	r2,-4(fp)
8113d414:	10000005 	stb	zero,0(r2)
                      break;
8113d418:	00000706 	br	8113d438 <OSTmrRemainGet+0x15c>

                 case OS_TMR_OPT_ONE_SHOT:
                 default:
                      remain = ptmr->OSTmrDly;
8113d41c:	e0bffe17 	ldw	r2,-8(fp)
8113d420:	10800617 	ldw	r2,24(r2)
8113d424:	e0bffd15 	stw	r2,-12(fp)
                      OSTmr_Unlock();
8113d428:	113de940 	call	8113de94 <OSTmr_Unlock>
                      *perr  = OS_ERR_NONE;
8113d42c:	e0bfff17 	ldw	r2,-4(fp)
8113d430:	10000005 	stb	zero,0(r2)
                      break;
8113d434:	0001883a 	nop
             }
             return (remain);
8113d438:	e0bffd17 	ldw	r2,-12(fp)
8113d43c:	00001006 	br	8113d480 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
             OSTmr_Unlock();
8113d440:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113d444:	e0bfff17 	ldw	r2,-4(fp)
8113d448:	10000005 	stb	zero,0(r2)
             return (0);
8113d44c:	0005883a 	mov	r2,zero
8113d450:	00000b06 	br	8113d480 <OSTmrRemainGet+0x1a4>

        case OS_TMR_STATE_UNUSED:
             OSTmr_Unlock();
8113d454:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113d458:	e0bfff17 	ldw	r2,-4(fp)
8113d45c:	00ffe1c4 	movi	r3,-121
8113d460:	10c00005 	stb	r3,0(r2)
             return (0);
8113d464:	0005883a 	mov	r2,zero
8113d468:	00000506 	br	8113d480 <OSTmrRemainGet+0x1a4>

        default:
             OSTmr_Unlock();
8113d46c:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113d470:	e0bfff17 	ldw	r2,-4(fp)
8113d474:	00ffe344 	movi	r3,-115
8113d478:	10c00005 	stb	r3,0(r2)
             return (0);
8113d47c:	0005883a 	mov	r2,zero
    }
}
8113d480:	e037883a 	mov	sp,fp
8113d484:	dfc00117 	ldw	ra,4(sp)
8113d488:	df000017 	ldw	fp,0(sp)
8113d48c:	dec00204 	addi	sp,sp,8
8113d490:	f800283a 	ret

8113d494 <OSTmrStateGet>:
*/

#if OS_TMR_EN > 0
INT8U  OSTmrStateGet (OS_TMR  *ptmr,
                      INT8U   *perr)
{
8113d494:	defffb04 	addi	sp,sp,-20
8113d498:	de00012e 	bgeu	sp,et,8113d4a0 <OSTmrStateGet+0xc>
8113d49c:	003b68fa 	trap	3
8113d4a0:	dfc00415 	stw	ra,16(sp)
8113d4a4:	df000315 	stw	fp,12(sp)
8113d4a8:	df000304 	addi	fp,sp,12
8113d4ac:	e13ffe15 	stw	r4,-8(fp)
8113d4b0:	e17fff15 	stw	r5,-4(fp)
    INT8U  state;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {
8113d4b4:	e0bfff17 	ldw	r2,-4(fp)
8113d4b8:	1000021e 	bne	r2,zero,8113d4c4 <OSTmrStateGet+0x30>
        return (0);
8113d4bc:	0005883a 	mov	r2,zero
8113d4c0:	00002a06 	br	8113d56c <OSTmrStateGet+0xd8>
    }
    if (ptmr == (OS_TMR *)0) {
8113d4c4:	e0bffe17 	ldw	r2,-8(fp)
8113d4c8:	1000051e 	bne	r2,zero,8113d4e0 <OSTmrStateGet+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113d4cc:	e0bfff17 	ldw	r2,-4(fp)
8113d4d0:	00ffe284 	movi	r3,-118
8113d4d4:	10c00005 	stb	r3,0(r2)
        return (0);
8113d4d8:	0005883a 	mov	r2,zero
8113d4dc:	00002306 	br	8113d56c <OSTmrStateGet+0xd8>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
8113d4e0:	e0bffe17 	ldw	r2,-8(fp)
8113d4e4:	10800003 	ldbu	r2,0(r2)
8113d4e8:	10803fcc 	andi	r2,r2,255
8113d4ec:	10801920 	cmpeqi	r2,r2,100
8113d4f0:	1000051e 	bne	r2,zero,8113d508 <OSTmrStateGet+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113d4f4:	e0bfff17 	ldw	r2,-4(fp)
8113d4f8:	00ffe244 	movi	r3,-119
8113d4fc:	10c00005 	stb	r3,0(r2)
        return (0);
8113d500:	0005883a 	mov	r2,zero
8113d504:	00001906 	br	8113d56c <OSTmrStateGet+0xd8>
    }
    if (OSIntNesting > 0) {                            /* See if trying to call from an ISR                           */
8113d508:	d0a09d03 	ldbu	r2,-32140(gp)
8113d50c:	10803fcc 	andi	r2,r2,255
8113d510:	10000526 	beq	r2,zero,8113d528 <OSTmrStateGet+0x94>
        *perr = OS_ERR_TMR_ISR;
8113d514:	e0bfff17 	ldw	r2,-4(fp)
8113d518:	00ffe2c4 	movi	r3,-117
8113d51c:	10c00005 	stb	r3,0(r2)
        return (0);
8113d520:	0005883a 	mov	r2,zero
8113d524:	00001106 	br	8113d56c <OSTmrStateGet+0xd8>
    }
    OSTmr_Lock();
8113d528:	113de500 	call	8113de50 <OSTmr_Lock>
    state = ptmr->OSTmrState;
8113d52c:	e0bffe17 	ldw	r2,-8(fp)
8113d530:	10800c43 	ldbu	r2,49(r2)
8113d534:	e0bffd05 	stb	r2,-12(fp)
    switch (state) {
8113d538:	e0bffd03 	ldbu	r2,-12(fp)
8113d53c:	1005883a 	mov	r2,r2
8113d540:	10800128 	cmpgeui	r2,r2,4
8113d544:	1000031e 	bne	r2,zero,8113d554 <OSTmrStateGet+0xc0>
        case OS_TMR_STATE_UNUSED:   
        case OS_TMR_STATE_STOPPED:  
        case OS_TMR_STATE_COMPLETED:
        case OS_TMR_STATE_RUNNING:  
             *perr = OS_ERR_NONE;
8113d548:	e0bfff17 	ldw	r2,-4(fp)
8113d54c:	10000005 	stb	zero,0(r2)
             break;
8113d550:	00000406 	br	8113d564 <OSTmrStateGet+0xd0>
             
        default:
             *perr = OS_ERR_TMR_INVALID_STATE;
8113d554:	e0bfff17 	ldw	r2,-4(fp)
8113d558:	00ffe344 	movi	r3,-115
8113d55c:	10c00005 	stb	r3,0(r2)
             break;
8113d560:	0001883a 	nop
    }
    OSTmr_Unlock();
8113d564:	113de940 	call	8113de94 <OSTmr_Unlock>
    return (state);
8113d568:	e0bffd03 	ldbu	r2,-12(fp)
}
8113d56c:	e037883a 	mov	sp,fp
8113d570:	dfc00117 	ldw	ra,4(sp)
8113d574:	df000017 	ldw	fp,0(sp)
8113d578:	dec00204 	addi	sp,sp,8
8113d57c:	f800283a 	ret

8113d580 <OSTmrStart>:
*/

#if OS_TMR_EN > 0
BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
                     INT8U    *perr)
{
8113d580:	defffc04 	addi	sp,sp,-16
8113d584:	de00012e 	bgeu	sp,et,8113d58c <OSTmrStart+0xc>
8113d588:	003b68fa 	trap	3
8113d58c:	dfc00315 	stw	ra,12(sp)
8113d590:	df000215 	stw	fp,8(sp)
8113d594:	df000204 	addi	fp,sp,8
8113d598:	e13ffe15 	stw	r4,-8(fp)
8113d59c:	e17fff15 	stw	r5,-4(fp)
#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                               /* Validate arguments                                     */
8113d5a0:	e0bfff17 	ldw	r2,-4(fp)
8113d5a4:	1000021e 	bne	r2,zero,8113d5b0 <OSTmrStart+0x30>
        return (OS_FALSE);
8113d5a8:	0005883a 	mov	r2,zero
8113d5ac:	00004106 	br	8113d6b4 <OSTmrStart+0x134>
    }
    if (ptmr == (OS_TMR *)0) {
8113d5b0:	e0bffe17 	ldw	r2,-8(fp)
8113d5b4:	1000051e 	bne	r2,zero,8113d5cc <OSTmrStart+0x4c>
        *perr = OS_ERR_TMR_INVALID;
8113d5b8:	e0bfff17 	ldw	r2,-4(fp)
8113d5bc:	00ffe284 	movi	r3,-118
8113d5c0:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d5c4:	0005883a 	mov	r2,zero
8113d5c8:	00003a06 	br	8113d6b4 <OSTmrStart+0x134>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
8113d5cc:	e0bffe17 	ldw	r2,-8(fp)
8113d5d0:	10800003 	ldbu	r2,0(r2)
8113d5d4:	10803fcc 	andi	r2,r2,255
8113d5d8:	10801920 	cmpeqi	r2,r2,100
8113d5dc:	1000051e 	bne	r2,zero,8113d5f4 <OSTmrStart+0x74>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113d5e0:	e0bfff17 	ldw	r2,-4(fp)
8113d5e4:	00ffe244 	movi	r3,-119
8113d5e8:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d5ec:	0005883a 	mov	r2,zero
8113d5f0:	00003006 	br	8113d6b4 <OSTmrStart+0x134>
    }
    if (OSIntNesting > 0) {                                 /* See if trying to call from an ISR                      */
8113d5f4:	d0a09d03 	ldbu	r2,-32140(gp)
8113d5f8:	10803fcc 	andi	r2,r2,255
8113d5fc:	10000526 	beq	r2,zero,8113d614 <OSTmrStart+0x94>
        *perr  = OS_ERR_TMR_ISR;
8113d600:	e0bfff17 	ldw	r2,-4(fp)
8113d604:	00ffe2c4 	movi	r3,-117
8113d608:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d60c:	0005883a 	mov	r2,zero
8113d610:	00002806 	br	8113d6b4 <OSTmrStart+0x134>
    }
    OSTmr_Lock();
8113d614:	113de500 	call	8113de50 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113d618:	e0bffe17 	ldw	r2,-8(fp)
8113d61c:	10800c43 	ldbu	r2,49(r2)
8113d620:	10803fcc 	andi	r2,r2,255
8113d624:	10c000c8 	cmpgei	r3,r2,3
8113d628:	1800031e 	bne	r3,zero,8113d638 <OSTmrStart+0xb8>
8113d62c:	00800e16 	blt	zero,r2,8113d668 <OSTmrStart+0xe8>
8113d630:	10001526 	beq	r2,zero,8113d688 <OSTmrStart+0x108>
8113d634:	00001a06 	br	8113d6a0 <OSTmrStart+0x120>
8113d638:	108000e0 	cmpeqi	r2,r2,3
8113d63c:	10001826 	beq	r2,zero,8113d6a0 <OSTmrStart+0x120>
        case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
             OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
8113d640:	e13ffe17 	ldw	r4,-8(fp)
8113d644:	113dd540 	call	8113dd54 <OSTmr_Unlink>
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113d648:	000b883a 	mov	r5,zero
8113d64c:	e13ffe17 	ldw	r4,-8(fp)
8113d650:	113dc040 	call	8113dc04 <OSTmr_Link>
             OSTmr_Unlock();
8113d654:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113d658:	e0bfff17 	ldw	r2,-4(fp)
8113d65c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113d660:	00800044 	movi	r2,1
8113d664:	00001306 	br	8113d6b4 <OSTmrStart+0x134>

        case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
        case OS_TMR_STATE_COMPLETED:
             OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
8113d668:	000b883a 	mov	r5,zero
8113d66c:	e13ffe17 	ldw	r4,-8(fp)
8113d670:	113dc040 	call	8113dc04 <OSTmr_Link>
             OSTmr_Unlock();
8113d674:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_NONE;
8113d678:	e0bfff17 	ldw	r2,-4(fp)
8113d67c:	10000005 	stb	zero,0(r2)
             return (OS_TRUE);
8113d680:	00800044 	movi	r2,1
8113d684:	00000b06 	br	8113d6b4 <OSTmrStart+0x134>

        case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
             OSTmr_Unlock();
8113d688:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113d68c:	e0bfff17 	ldw	r2,-4(fp)
8113d690:	00ffe1c4 	movi	r3,-121
8113d694:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113d698:	0005883a 	mov	r2,zero
8113d69c:	00000506 	br	8113d6b4 <OSTmrStart+0x134>

        default:
             OSTmr_Unlock();
8113d6a0:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113d6a4:	e0bfff17 	ldw	r2,-4(fp)
8113d6a8:	00ffe344 	movi	r3,-115
8113d6ac:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113d6b0:	0005883a 	mov	r2,zero
    }
}
8113d6b4:	e037883a 	mov	sp,fp
8113d6b8:	dfc00117 	ldw	ra,4(sp)
8113d6bc:	df000017 	ldw	fp,0(sp)
8113d6c0:	dec00204 	addi	sp,sp,8
8113d6c4:	f800283a 	ret

8113d6c8 <OSTmrStop>:
#if OS_TMR_EN > 0
BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
                    INT8U    opt,
                    void    *callback_arg,
                    INT8U   *perr)
{
8113d6c8:	defff904 	addi	sp,sp,-28
8113d6cc:	de00012e 	bgeu	sp,et,8113d6d4 <OSTmrStop+0xc>
8113d6d0:	003b68fa 	trap	3
8113d6d4:	dfc00615 	stw	ra,24(sp)
8113d6d8:	df000515 	stw	fp,20(sp)
8113d6dc:	df000504 	addi	fp,sp,20
8113d6e0:	e13ffc15 	stw	r4,-16(fp)
8113d6e4:	2805883a 	mov	r2,r5
8113d6e8:	e1bffe15 	stw	r6,-8(fp)
8113d6ec:	e1ffff15 	stw	r7,-4(fp)
8113d6f0:	e0bffd05 	stb	r2,-12(fp)
    OS_TMR_CALLBACK  pfnct;


#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                                     /* Validate arguments                               */
8113d6f4:	e0bfff17 	ldw	r2,-4(fp)
8113d6f8:	1000021e 	bne	r2,zero,8113d704 <OSTmrStop+0x3c>
        return (OS_FALSE);
8113d6fc:	0005883a 	mov	r2,zero
8113d700:	00006606 	br	8113d89c <OSTmrStop+0x1d4>
    }
    if (ptmr == (OS_TMR *)0) {
8113d704:	e0bffc17 	ldw	r2,-16(fp)
8113d708:	1000051e 	bne	r2,zero,8113d720 <OSTmrStop+0x58>
        *perr = OS_ERR_TMR_INVALID;
8113d70c:	e0bfff17 	ldw	r2,-4(fp)
8113d710:	00ffe284 	movi	r3,-118
8113d714:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d718:	0005883a 	mov	r2,zero
8113d71c:	00005f06 	br	8113d89c <OSTmrStop+0x1d4>
    }
#endif
    if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
8113d720:	e0bffc17 	ldw	r2,-16(fp)
8113d724:	10800003 	ldbu	r2,0(r2)
8113d728:	10803fcc 	andi	r2,r2,255
8113d72c:	10801920 	cmpeqi	r2,r2,100
8113d730:	1000051e 	bne	r2,zero,8113d748 <OSTmrStop+0x80>
        *perr = OS_ERR_TMR_INVALID_TYPE;
8113d734:	e0bfff17 	ldw	r2,-4(fp)
8113d738:	00ffe244 	movi	r3,-119
8113d73c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d740:	0005883a 	mov	r2,zero
8113d744:	00005506 	br	8113d89c <OSTmrStop+0x1d4>
    }
    if (OSIntNesting > 0) {                                       /* See if trying to call from an ISR                */
8113d748:	d0a09d03 	ldbu	r2,-32140(gp)
8113d74c:	10803fcc 	andi	r2,r2,255
8113d750:	10000526 	beq	r2,zero,8113d768 <OSTmrStop+0xa0>
        *perr  = OS_ERR_TMR_ISR;
8113d754:	e0bfff17 	ldw	r2,-4(fp)
8113d758:	00ffe2c4 	movi	r3,-117
8113d75c:	10c00005 	stb	r3,0(r2)
        return (OS_FALSE);
8113d760:	0005883a 	mov	r2,zero
8113d764:	00004d06 	br	8113d89c <OSTmrStop+0x1d4>
    }
    OSTmr_Lock();
8113d768:	113de500 	call	8113de50 <OSTmr_Lock>
    switch (ptmr->OSTmrState) {
8113d76c:	e0bffc17 	ldw	r2,-16(fp)
8113d770:	10800c43 	ldbu	r2,49(r2)
8113d774:	10803fcc 	andi	r2,r2,255
8113d778:	10c000c8 	cmpgei	r3,r2,3
8113d77c:	1800031e 	bne	r3,zero,8113d78c <OSTmrStop+0xc4>
8113d780:	00803516 	blt	zero,r2,8113d858 <OSTmrStop+0x190>
8113d784:	10003a26 	beq	r2,zero,8113d870 <OSTmrStop+0x1a8>
8113d788:	00003f06 	br	8113d888 <OSTmrStop+0x1c0>
8113d78c:	108000e0 	cmpeqi	r2,r2,3
8113d790:	10003d26 	beq	r2,zero,8113d888 <OSTmrStop+0x1c0>
        case OS_TMR_STATE_RUNNING:
             OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
8113d794:	e13ffc17 	ldw	r4,-16(fp)
8113d798:	113dd540 	call	8113dd54 <OSTmr_Unlink>
             *perr = OS_ERR_NONE;
8113d79c:	e0bfff17 	ldw	r2,-4(fp)
8113d7a0:	10000005 	stb	zero,0(r2)
             switch (opt) {
8113d7a4:	e0bffd03 	ldbu	r2,-12(fp)
8113d7a8:	10c000e0 	cmpeqi	r3,r2,3
8113d7ac:	1800041e 	bne	r3,zero,8113d7c0 <OSTmrStop+0xf8>
8113d7b0:	10c00120 	cmpeqi	r3,r2,4
8113d7b4:	1800121e 	bne	r3,zero,8113d800 <OSTmrStop+0x138>
8113d7b8:	10002326 	beq	r2,zero,8113d848 <OSTmrStop+0x180>
8113d7bc:	00001e06 	br	8113d838 <OSTmrStop+0x170>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113d7c0:	e0bffc17 	ldw	r2,-16(fp)
8113d7c4:	10800117 	ldw	r2,4(r2)
8113d7c8:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113d7cc:	e0bffb17 	ldw	r2,-20(fp)
8113d7d0:	10000726 	beq	r2,zero,8113d7f0 <OSTmrStop+0x128>
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
8113d7d4:	e0bffc17 	ldw	r2,-16(fp)
8113d7d8:	10c00217 	ldw	r3,8(r2)
8113d7dc:	e0bffb17 	ldw	r2,-20(fp)
8113d7e0:	180b883a 	mov	r5,r3
8113d7e4:	e13ffc17 	ldw	r4,-16(fp)
8113d7e8:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113d7ec:	00001706 	br	8113d84c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113d7f0:	e0bfff17 	ldw	r2,-4(fp)
8113d7f4:	00ffe3c4 	movi	r3,-113
8113d7f8:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113d7fc:	00001306 	br	8113d84c <OSTmrStop+0x184>

                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
8113d800:	e0bffc17 	ldw	r2,-16(fp)
8113d804:	10800117 	ldw	r2,4(r2)
8113d808:	e0bffb15 	stw	r2,-20(fp)
                      if (pfnct != (OS_TMR_CALLBACK)0) {
8113d80c:	e0bffb17 	ldw	r2,-20(fp)
8113d810:	10000526 	beq	r2,zero,8113d828 <OSTmrStop+0x160>
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
8113d814:	e0bffb17 	ldw	r2,-20(fp)
8113d818:	e17ffe17 	ldw	r5,-8(fp)
8113d81c:	e13ffc17 	ldw	r4,-16(fp)
8113d820:	103ee83a 	callr	r2
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;
8113d824:	00000906 	br	8113d84c <OSTmrStop+0x184>
                 case OS_TMR_OPT_CALLBACK_ARG:
                      pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
                      if (pfnct != (OS_TMR_CALLBACK)0) {
                          (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
                      } else {
                          *perr = OS_ERR_TMR_NO_CALLBACK;
8113d828:	e0bfff17 	ldw	r2,-4(fp)
8113d82c:	00ffe3c4 	movi	r3,-113
8113d830:	10c00005 	stb	r3,0(r2)
                      }
                      break;
8113d834:	00000506 	br	8113d84c <OSTmrStop+0x184>

                 case OS_TMR_OPT_NONE:
                      break;

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
8113d838:	e0bfff17 	ldw	r2,-4(fp)
8113d83c:	00ffe104 	movi	r3,-124
8113d840:	10c00005 	stb	r3,0(r2)
                     break;
8113d844:	00000106 	br	8113d84c <OSTmrStop+0x184>
                          *perr = OS_ERR_TMR_NO_CALLBACK;
                      }
                      break;

                 case OS_TMR_OPT_NONE:
                      break;
8113d848:	0001883a 	nop

                 default:
                     *perr = OS_ERR_TMR_INVALID_OPT;
                     break;
             }
             OSTmr_Unlock();
8113d84c:	113de940 	call	8113de94 <OSTmr_Unlock>
             return (OS_TRUE);
8113d850:	00800044 	movi	r2,1
8113d854:	00001106 	br	8113d89c <OSTmrStop+0x1d4>

        case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
        case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
             OSTmr_Unlock();
8113d858:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_STOPPED;
8113d85c:	e0bfff17 	ldw	r2,-4(fp)
8113d860:	00ffe384 	movi	r3,-114
8113d864:	10c00005 	stb	r3,0(r2)
             return (OS_TRUE);
8113d868:	00800044 	movi	r2,1
8113d86c:	00000b06 	br	8113d89c <OSTmrStop+0x1d4>

        case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
             OSTmr_Unlock();
8113d870:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INACTIVE;
8113d874:	e0bfff17 	ldw	r2,-4(fp)
8113d878:	00ffe1c4 	movi	r3,-121
8113d87c:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113d880:	0005883a 	mov	r2,zero
8113d884:	00000506 	br	8113d89c <OSTmrStop+0x1d4>

        default:
             OSTmr_Unlock();
8113d888:	113de940 	call	8113de94 <OSTmr_Unlock>
             *perr = OS_ERR_TMR_INVALID_STATE;
8113d88c:	e0bfff17 	ldw	r2,-4(fp)
8113d890:	00ffe344 	movi	r3,-115
8113d894:	10c00005 	stb	r3,0(r2)
             return (OS_FALSE);
8113d898:	0005883a 	mov	r2,zero
    }
}
8113d89c:	e037883a 	mov	sp,fp
8113d8a0:	dfc00117 	ldw	ra,4(sp)
8113d8a4:	df000017 	ldw	fp,0(sp)
8113d8a8:	dec00204 	addi	sp,sp,8
8113d8ac:	f800283a 	ret

8113d8b0 <OSTmrSignal>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
INT8U  OSTmrSignal (void)
{
8113d8b0:	defffd04 	addi	sp,sp,-12
8113d8b4:	de00012e 	bgeu	sp,et,8113d8bc <OSTmrSignal+0xc>
8113d8b8:	003b68fa 	trap	3
8113d8bc:	dfc00215 	stw	ra,8(sp)
8113d8c0:	df000115 	stw	fp,4(sp)
8113d8c4:	df000104 	addi	fp,sp,4
    INT8U  err;


    err = OSSemPost(OSTmrSemSignal);
8113d8c8:	d0a08c17 	ldw	r2,-32208(gp)
8113d8cc:	1009883a 	mov	r4,r2
8113d8d0:	113ae7c0 	call	8113ae7c <OSSemPost>
8113d8d4:	e0bfff05 	stb	r2,-4(fp)
    return (err);
8113d8d8:	e0bfff03 	ldbu	r2,-4(fp)
}
8113d8dc:	e037883a 	mov	sp,fp
8113d8e0:	dfc00117 	ldw	ra,4(sp)
8113d8e4:	df000017 	ldw	fp,0(sp)
8113d8e8:	dec00204 	addi	sp,sp,8
8113d8ec:	f800283a 	ret

8113d8f0 <OSTmr_Alloc>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  OS_TMR  *OSTmr_Alloc (void)
{
8113d8f0:	defffe04 	addi	sp,sp,-8
8113d8f4:	de00012e 	bgeu	sp,et,8113d8fc <OSTmr_Alloc+0xc>
8113d8f8:	003b68fa 	trap	3
8113d8fc:	df000115 	stw	fp,4(sp)
8113d900:	df000104 	addi	fp,sp,4
    OS_TMR *ptmr;


    if (OSTmrFreeList == (OS_TMR *)0) {
8113d904:	d0a08a17 	ldw	r2,-32216(gp)
8113d908:	1000021e 	bne	r2,zero,8113d914 <OSTmr_Alloc+0x24>
        return ((OS_TMR *)0);
8113d90c:	0005883a 	mov	r2,zero
8113d910:	00001006 	br	8113d954 <OSTmr_Alloc+0x64>
    }
    ptmr            = (OS_TMR *)OSTmrFreeList;
8113d914:	d0a08a17 	ldw	r2,-32216(gp)
8113d918:	e0bfff15 	stw	r2,-4(fp)
    OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
8113d91c:	e0bfff17 	ldw	r2,-4(fp)
8113d920:	10800317 	ldw	r2,12(r2)
8113d924:	d0a08a15 	stw	r2,-32216(gp)
    ptmr->OSTmrNext = (OS_TCB *)0;
8113d928:	e0bfff17 	ldw	r2,-4(fp)
8113d92c:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev = (OS_TCB *)0;
8113d930:	e0bfff17 	ldw	r2,-4(fp)
8113d934:	10000415 	stw	zero,16(r2)
    OSTmrUsed++;
8113d938:	d0a08f0b 	ldhu	r2,-32196(gp)
8113d93c:	10800044 	addi	r2,r2,1
8113d940:	d0a08f0d 	sth	r2,-32196(gp)
    OSTmrFree--;
8113d944:	d0a0930b 	ldhu	r2,-32180(gp)
8113d948:	10bfffc4 	addi	r2,r2,-1
8113d94c:	d0a0930d 	sth	r2,-32180(gp)
    return (ptmr);
8113d950:	e0bfff17 	ldw	r2,-4(fp)
}
8113d954:	e037883a 	mov	sp,fp
8113d958:	df000017 	ldw	fp,0(sp)
8113d95c:	dec00104 	addi	sp,sp,4
8113d960:	f800283a 	ret

8113d964 <OSTmr_Free>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Free (OS_TMR *ptmr)
{
8113d964:	defffe04 	addi	sp,sp,-8
8113d968:	de00012e 	bgeu	sp,et,8113d970 <OSTmr_Free+0xc>
8113d96c:	003b68fa 	trap	3
8113d970:	df000115 	stw	fp,4(sp)
8113d974:	df000104 	addi	fp,sp,4
8113d978:	e13fff15 	stw	r4,-4(fp)
    ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
8113d97c:	e0bfff17 	ldw	r2,-4(fp)
8113d980:	10000c45 	stb	zero,49(r2)
    ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
8113d984:	e0bfff17 	ldw	r2,-4(fp)
8113d988:	10000c05 	stb	zero,48(r2)
    ptmr->OSTmrPeriod      = 0;
8113d98c:	e0bfff17 	ldw	r2,-4(fp)
8113d990:	10000715 	stw	zero,28(r2)
    ptmr->OSTmrMatch       = 0;
8113d994:	e0bfff17 	ldw	r2,-4(fp)
8113d998:	10000515 	stw	zero,20(r2)
    ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
8113d99c:	e0bfff17 	ldw	r2,-4(fp)
8113d9a0:	10000115 	stw	zero,4(r2)
    ptmr->OSTmrCallbackArg = (void *)0;
8113d9a4:	e0bfff17 	ldw	r2,-4(fp)
8113d9a8:	10000215 	stw	zero,8(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr->OSTmrName[0]     = '?';                      /* Unknown name                                                */
8113d9ac:	e0bfff17 	ldw	r2,-4(fp)
8113d9b0:	00c00fc4 	movi	r3,63
8113d9b4:	10c00805 	stb	r3,32(r2)
    ptmr->OSTmrName[1]     = OS_ASCII_NUL;
8113d9b8:	e0bfff17 	ldw	r2,-4(fp)
8113d9bc:	10000845 	stb	zero,33(r2)
#endif

    ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
8113d9c0:	e0bfff17 	ldw	r2,-4(fp)
8113d9c4:	10000415 	stw	zero,16(r2)
    ptmr->OSTmrNext        = OSTmrFreeList;
8113d9c8:	d0e08a17 	ldw	r3,-32216(gp)
8113d9cc:	e0bfff17 	ldw	r2,-4(fp)
8113d9d0:	10c00315 	stw	r3,12(r2)
    OSTmrFreeList          = ptmr;
8113d9d4:	e0bfff17 	ldw	r2,-4(fp)
8113d9d8:	d0a08a15 	stw	r2,-32216(gp)

    OSTmrUsed--;                                       /* Update timer object statistics                              */
8113d9dc:	d0a08f0b 	ldhu	r2,-32196(gp)
8113d9e0:	10bfffc4 	addi	r2,r2,-1
8113d9e4:	d0a08f0d 	sth	r2,-32196(gp)
    OSTmrFree++;
8113d9e8:	d0a0930b 	ldhu	r2,-32180(gp)
8113d9ec:	10800044 	addi	r2,r2,1
8113d9f0:	d0a0930d 	sth	r2,-32180(gp)
}
8113d9f4:	0001883a 	nop
8113d9f8:	e037883a 	mov	sp,fp
8113d9fc:	df000017 	ldw	fp,0(sp)
8113da00:	dec00104 	addi	sp,sp,4
8113da04:	f800283a 	ret

8113da08 <OSTmr_Init>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
void  OSTmr_Init (void)
{
8113da08:	defffa04 	addi	sp,sp,-24
8113da0c:	de00012e 	bgeu	sp,et,8113da14 <OSTmr_Init+0xc>
8113da10:	003b68fa 	trap	3
8113da14:	dfc00515 	stw	ra,20(sp)
8113da18:	df000415 	stw	fp,16(sp)
8113da1c:	df000404 	addi	fp,sp,16
    INT16U   i;
    OS_TMR  *ptmr1;
    OS_TMR  *ptmr2;


    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
8113da20:	01406804 	movi	r5,416
8113da24:	012045b4 	movhi	r4,33046
8113da28:	210b1e04 	addi	r4,r4,11384
8113da2c:	1135b780 	call	81135b78 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
8113da30:	01400404 	movi	r5,16
8113da34:	012045b4 	movhi	r4,33046
8113da38:	21090a04 	addi	r4,r4,9256
8113da3c:	1135b780 	call	81135b78 <OS_MemClr>

    ptmr1 = &OSTmrTbl[0];
8113da40:	00a045b4 	movhi	r2,33046
8113da44:	108b1e04 	addi	r2,r2,11384
8113da48:	e0bffd15 	stw	r2,-12(fp)
    ptmr2 = &OSTmrTbl[1];
8113da4c:	00a045b4 	movhi	r2,33046
8113da50:	108b2b04 	addi	r2,r2,11436
8113da54:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113da58:	e03ffc0d 	sth	zero,-16(fp)
8113da5c:	00001606 	br	8113dab8 <OSTmr_Init+0xb0>
        ptmr1->OSTmrType    = OS_TMR_TYPE;
8113da60:	e0bffd17 	ldw	r2,-12(fp)
8113da64:	00c01904 	movi	r3,100
8113da68:	10c00005 	stb	r3,0(r2)
        ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
8113da6c:	e0bffd17 	ldw	r2,-12(fp)
8113da70:	10000c45 	stb	zero,49(r2)
        ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
8113da74:	e0bffd17 	ldw	r2,-12(fp)
8113da78:	e0fffe17 	ldw	r3,-8(fp)
8113da7c:	10c00315 	stw	r3,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
        ptmr1->OSTmrName[0] = '?';                                      /* Unknown name                               */
8113da80:	e0bffd17 	ldw	r2,-12(fp)
8113da84:	00c00fc4 	movi	r3,63
8113da88:	10c00805 	stb	r3,32(r2)
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113da8c:	e0bffd17 	ldw	r2,-12(fp)
8113da90:	10000845 	stb	zero,33(r2)
#endif
        ptmr1++;
8113da94:	e0bffd17 	ldw	r2,-12(fp)
8113da98:	10800d04 	addi	r2,r2,52
8113da9c:	e0bffd15 	stw	r2,-12(fp)
        ptmr2++;
8113daa0:	e0bffe17 	ldw	r2,-8(fp)
8113daa4:	10800d04 	addi	r2,r2,52
8113daa8:	e0bffe15 	stw	r2,-8(fp)
    OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
    OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */

    ptmr1 = &OSTmrTbl[0];
    ptmr2 = &OSTmrTbl[1];
    for (i = 0; i < (OS_TMR_CFG_MAX - 1); i++) {                        /* Init. list of free TMRs                    */
8113daac:	e0bffc0b 	ldhu	r2,-16(fp)
8113dab0:	10800044 	addi	r2,r2,1
8113dab4:	e0bffc0d 	sth	r2,-16(fp)
8113dab8:	e0bffc0b 	ldhu	r2,-16(fp)
8113dabc:	108001f0 	cmpltui	r2,r2,7
8113dac0:	103fe71e 	bne	r2,zero,8113da60 <__reset+0xfb11da60>
        ptmr1->OSTmrName[1] = OS_ASCII_NUL;
#endif
        ptmr1++;
        ptmr2++;
    }
    ptmr1->OSTmrType    = OS_TMR_TYPE;
8113dac4:	e0bffd17 	ldw	r2,-12(fp)
8113dac8:	00c01904 	movi	r3,100
8113dacc:	10c00005 	stb	r3,0(r2)
    ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
8113dad0:	e0bffd17 	ldw	r2,-12(fp)
8113dad4:	10000c45 	stb	zero,49(r2)
    ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
8113dad8:	e0bffd17 	ldw	r2,-12(fp)
8113dadc:	10000315 	stw	zero,12(r2)
#if OS_TMR_CFG_NAME_SIZE > 1
    ptmr1->OSTmrName[0] = '?';                                          /* Unknown name                               */
8113dae0:	e0bffd17 	ldw	r2,-12(fp)
8113dae4:	00c00fc4 	movi	r3,63
8113dae8:	10c00805 	stb	r3,32(r2)
    ptmr1->OSTmrName[1] = OS_ASCII_NUL;
8113daec:	e0bffd17 	ldw	r2,-12(fp)
8113daf0:	10000845 	stb	zero,33(r2)
#endif
    OSTmrTime           = 0;
8113daf4:	d0209f15 	stw	zero,-32132(gp)
    OSTmrUsed           = 0;
8113daf8:	d0208f0d 	sth	zero,-32196(gp)
    OSTmrFree           = OS_TMR_CFG_MAX;
8113dafc:	00800204 	movi	r2,8
8113db00:	d0a0930d 	sth	r2,-32180(gp)
    OSTmrFreeList       = &OSTmrTbl[0];
8113db04:	00a045b4 	movhi	r2,33046
8113db08:	108b1e04 	addi	r2,r2,11384
8113db0c:	d0a08a15 	stw	r2,-32216(gp)
    OSTmrSem            = OSSemCreate(1);
8113db10:	01000044 	movi	r4,1
8113db14:	113a7cc0 	call	8113a7cc <OSSemCreate>
8113db18:	d0a0a115 	stw	r2,-32124(gp)
    OSTmrSemSignal      = OSSemCreate(0);
8113db1c:	0009883a 	mov	r4,zero
8113db20:	113a7cc0 	call	8113a7cc <OSSemCreate>
8113db24:	d0a08c15 	stw	r2,-32208(gp)

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSem,       (INT8U *)"uC/OS-II TmrLock",   &err);/* Assign names to semaphores                 */
8113db28:	d0a0a117 	ldw	r2,-32124(gp)
8113db2c:	e0ffff04 	addi	r3,fp,-4
8113db30:	180d883a 	mov	r6,r3
8113db34:	01604574 	movhi	r5,33045
8113db38:	29725504 	addi	r5,r5,-13996
8113db3c:	1009883a 	mov	r4,r2
8113db40:	11343d40 	call	811343d4 <OSEventNameSet>
    OSEventNameSet(OSTmrSem,       (INT8U *)"OS-TmrLock",         &err);
#endif
#endif

#if OS_EVENT_NAME_SIZE > 18
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"uC/OS-II TmrSignal", &err);
8113db44:	d0a08c17 	ldw	r2,-32208(gp)
8113db48:	e0ffff04 	addi	r3,fp,-4
8113db4c:	180d883a 	mov	r6,r3
8113db50:	01604574 	movhi	r5,33045
8113db54:	29725a04 	addi	r5,r5,-13976
8113db58:	1009883a 	mov	r4,r2
8113db5c:	11343d40 	call	811343d4 <OSEventNameSet>
#if OS_EVENT_NAME_SIZE > 10
    OSEventNameSet(OSTmrSemSignal, (INT8U *)"OS-TmrSig",          &err);
#endif
#endif

    OSTmr_InitTask();
8113db60:	113db7c0 	call	8113db7c <OSTmr_InitTask>
}
8113db64:	0001883a 	nop
8113db68:	e037883a 	mov	sp,fp
8113db6c:	dfc00117 	ldw	ra,4(sp)
8113db70:	df000017 	ldw	fp,0(sp)
8113db74:	dec00204 	addi	sp,sp,8
8113db78:	f800283a 	ret

8113db7c <OSTmr_InitTask>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_InitTask (void)
{
8113db7c:	defff804 	addi	sp,sp,-32
8113db80:	de00012e 	bgeu	sp,et,8113db88 <OSTmr_InitTask+0xc>
8113db84:	003b68fa 	trap	3
8113db88:	dfc00715 	stw	ra,28(sp)
8113db8c:	df000615 	stw	fp,24(sp)
8113db90:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OSTmr_Task,
8113db94:	008000c4 	movi	r2,3
8113db98:	d8800415 	stw	r2,16(sp)
8113db9c:	d8000315 	stw	zero,12(sp)
8113dba0:	00808004 	movi	r2,512
8113dba4:	d8800215 	stw	r2,8(sp)
8113dba8:	00a045b4 	movhi	r2,33046
8113dbac:	10935204 	addi	r2,r2,19784
8113dbb0:	d8800115 	stw	r2,4(sp)
8113dbb4:	00bfff54 	movui	r2,65533
8113dbb8:	d8800015 	stw	r2,0(sp)
8113dbbc:	01c00744 	movi	r7,29
8113dbc0:	01a045b4 	movhi	r6,33046
8113dbc4:	31955104 	addi	r6,r6,21828
8113dbc8:	000b883a 	mov	r5,zero
8113dbcc:	01204534 	movhi	r4,33044
8113dbd0:	2137b404 	addi	r4,r4,-8496
8113dbd4:	113b8600 	call	8113b860 <OSTaskCreateExt>
                       OS_TASK_TMR_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 12
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"uC/OS-II Tmr", &err);
8113dbd8:	e1bfff04 	addi	r6,fp,-4
8113dbdc:	01604574 	movhi	r5,33045
8113dbe0:	29725f04 	addi	r5,r5,-13956
8113dbe4:	01000744 	movi	r4,29
8113dbe8:	113c0900 	call	8113c090 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 6
    OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)"OS-Tmr", &err);
#endif
#endif
}
8113dbec:	0001883a 	nop
8113dbf0:	e037883a 	mov	sp,fp
8113dbf4:	dfc00117 	ldw	ra,4(sp)
8113dbf8:	df000017 	ldw	fp,0(sp)
8113dbfc:	dec00204 	addi	sp,sp,8
8113dc00:	f800283a 	ret

8113dc04 <OSTmr_Link>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Link (OS_TMR *ptmr, INT8U type)
{
8113dc04:	defffa04 	addi	sp,sp,-24
8113dc08:	de00012e 	bgeu	sp,et,8113dc10 <OSTmr_Link+0xc>
8113dc0c:	003b68fa 	trap	3
8113dc10:	df000515 	stw	fp,20(sp)
8113dc14:	df000504 	addi	fp,sp,20
8113dc18:	e13ffe15 	stw	r4,-8(fp)
8113dc1c:	2805883a 	mov	r2,r5
8113dc20:	e0bfff05 	stb	r2,-4(fp)
    OS_TMR       *ptmr1;
    OS_TMR_WHEEL *pspoke;
    INT16U        spoke;


    ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
8113dc24:	e0bffe17 	ldw	r2,-8(fp)
8113dc28:	00c000c4 	movi	r3,3
8113dc2c:	10c00c45 	stb	r3,49(r2)
    if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
8113dc30:	e0bfff03 	ldbu	r2,-4(fp)
8113dc34:	10800058 	cmpnei	r2,r2,1
8113dc38:	1000071e 	bne	r2,zero,8113dc58 <OSTmr_Link+0x54>
        ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113dc3c:	e0bffe17 	ldw	r2,-8(fp)
8113dc40:	10c00717 	ldw	r3,28(r2)
8113dc44:	d0a09f17 	ldw	r2,-32132(gp)
8113dc48:	1887883a 	add	r3,r3,r2
8113dc4c:	e0bffe17 	ldw	r2,-8(fp)
8113dc50:	10c00515 	stw	r3,20(r2)
8113dc54:	00001006 	br	8113dc98 <OSTmr_Link+0x94>
    } else {
        if (ptmr->OSTmrDly == 0) {
8113dc58:	e0bffe17 	ldw	r2,-8(fp)
8113dc5c:	10800617 	ldw	r2,24(r2)
8113dc60:	1000071e 	bne	r2,zero,8113dc80 <OSTmr_Link+0x7c>
            ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
8113dc64:	e0bffe17 	ldw	r2,-8(fp)
8113dc68:	10c00717 	ldw	r3,28(r2)
8113dc6c:	d0a09f17 	ldw	r2,-32132(gp)
8113dc70:	1887883a 	add	r3,r3,r2
8113dc74:	e0bffe17 	ldw	r2,-8(fp)
8113dc78:	10c00515 	stw	r3,20(r2)
8113dc7c:	00000606 	br	8113dc98 <OSTmr_Link+0x94>
        } else {
            ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
8113dc80:	e0bffe17 	ldw	r2,-8(fp)
8113dc84:	10c00617 	ldw	r3,24(r2)
8113dc88:	d0a09f17 	ldw	r2,-32132(gp)
8113dc8c:	1887883a 	add	r3,r3,r2
8113dc90:	e0bffe17 	ldw	r2,-8(fp)
8113dc94:	10c00515 	stw	r3,20(r2)
        }
    }
    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113dc98:	e0bffe17 	ldw	r2,-8(fp)
8113dc9c:	10800517 	ldw	r2,20(r2)
8113dca0:	1080004c 	andi	r2,r2,1
8113dca4:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113dca8:	e0bffb0b 	ldhu	r2,-20(fp)
8113dcac:	100690fa 	slli	r3,r2,3
8113dcb0:	00a045b4 	movhi	r2,33046
8113dcb4:	10890a04 	addi	r2,r2,9256
8113dcb8:	1885883a 	add	r2,r3,r2
8113dcbc:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
8113dcc0:	e0bffc17 	ldw	r2,-16(fp)
8113dcc4:	10800017 	ldw	r2,0(r2)
8113dcc8:	1000091e 	bne	r2,zero,8113dcf0 <OSTmr_Link+0xec>
        pspoke->OSTmrFirst   = ptmr;
8113dccc:	e0bffc17 	ldw	r2,-16(fp)
8113dcd0:	e0fffe17 	ldw	r3,-8(fp)
8113dcd4:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (OS_TMR *)0;
8113dcd8:	e0bffe17 	ldw	r2,-8(fp)
8113dcdc:	10000315 	stw	zero,12(r2)
        pspoke->OSTmrEntries = 1;
8113dce0:	e0bffc17 	ldw	r2,-16(fp)
8113dce4:	00c00044 	movi	r3,1
8113dce8:	10c0010d 	sth	r3,4(r2)
8113dcec:	00001206 	br	8113dd38 <OSTmr_Link+0x134>
    } else {
        ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
8113dcf0:	e0bffc17 	ldw	r2,-16(fp)
8113dcf4:	10800017 	ldw	r2,0(r2)
8113dcf8:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst   = ptmr;
8113dcfc:	e0bffc17 	ldw	r2,-16(fp)
8113dd00:	e0fffe17 	ldw	r3,-8(fp)
8113dd04:	10c00015 	stw	r3,0(r2)
        ptmr->OSTmrNext      = (void *)ptmr1;
8113dd08:	e0bffe17 	ldw	r2,-8(fp)
8113dd0c:	e0fffd17 	ldw	r3,-12(fp)
8113dd10:	10c00315 	stw	r3,12(r2)
        ptmr1->OSTmrPrev     = (void *)ptmr;
8113dd14:	e0bffd17 	ldw	r2,-12(fp)
8113dd18:	e0fffe17 	ldw	r3,-8(fp)
8113dd1c:	10c00415 	stw	r3,16(r2)
        pspoke->OSTmrEntries++;
8113dd20:	e0bffc17 	ldw	r2,-16(fp)
8113dd24:	1080010b 	ldhu	r2,4(r2)
8113dd28:	10800044 	addi	r2,r2,1
8113dd2c:	1007883a 	mov	r3,r2
8113dd30:	e0bffc17 	ldw	r2,-16(fp)
8113dd34:	10c0010d 	sth	r3,4(r2)
    }
    ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
8113dd38:	e0bffe17 	ldw	r2,-8(fp)
8113dd3c:	10000415 	stw	zero,16(r2)
}
8113dd40:	0001883a 	nop
8113dd44:	e037883a 	mov	sp,fp
8113dd48:	df000017 	ldw	fp,0(sp)
8113dd4c:	dec00104 	addi	sp,sp,4
8113dd50:	f800283a 	ret

8113dd54 <OSTmr_Unlink>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Unlink (OS_TMR *ptmr)
{
8113dd54:	defffa04 	addi	sp,sp,-24
8113dd58:	de00012e 	bgeu	sp,et,8113dd60 <OSTmr_Unlink+0xc>
8113dd5c:	003b68fa 	trap	3
8113dd60:	df000515 	stw	fp,20(sp)
8113dd64:	df000504 	addi	fp,sp,20
8113dd68:	e13fff15 	stw	r4,-4(fp)
    OS_TMR        *ptmr2;
    OS_TMR_WHEEL  *pspoke;
    INT16U         spoke;


    spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
8113dd6c:	e0bfff17 	ldw	r2,-4(fp)
8113dd70:	10800517 	ldw	r2,20(r2)
8113dd74:	1080004c 	andi	r2,r2,1
8113dd78:	e0bffb0d 	sth	r2,-20(fp)
    pspoke = &OSTmrWheelTbl[spoke];
8113dd7c:	e0bffb0b 	ldhu	r2,-20(fp)
8113dd80:	100690fa 	slli	r3,r2,3
8113dd84:	00a045b4 	movhi	r2,33046
8113dd88:	10890a04 	addi	r2,r2,9256
8113dd8c:	1885883a 	add	r2,r3,r2
8113dd90:	e0bffc15 	stw	r2,-16(fp)

    if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
8113dd94:	e0bffc17 	ldw	r2,-16(fp)
8113dd98:	10c00017 	ldw	r3,0(r2)
8113dd9c:	e0bfff17 	ldw	r2,-4(fp)
8113dda0:	18800b1e 	bne	r3,r2,8113ddd0 <OSTmr_Unlink+0x7c>
        ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
8113dda4:	e0bfff17 	ldw	r2,-4(fp)
8113dda8:	10800317 	ldw	r2,12(r2)
8113ddac:	e0bffd15 	stw	r2,-12(fp)
        pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
8113ddb0:	e0bffc17 	ldw	r2,-16(fp)
8113ddb4:	e0fffd17 	ldw	r3,-12(fp)
8113ddb8:	10c00015 	stw	r3,0(r2)
        if (ptmr1 != (OS_TMR *)0) {
8113ddbc:	e0bffd17 	ldw	r2,-12(fp)
8113ddc0:	10001126 	beq	r2,zero,8113de08 <OSTmr_Unlink+0xb4>
            ptmr1->OSTmrPrev = (void *)0;
8113ddc4:	e0bffd17 	ldw	r2,-12(fp)
8113ddc8:	10000415 	stw	zero,16(r2)
8113ddcc:	00000e06 	br	8113de08 <OSTmr_Unlink+0xb4>
        }
    } else {
        ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
8113ddd0:	e0bfff17 	ldw	r2,-4(fp)
8113ddd4:	10800417 	ldw	r2,16(r2)
8113ddd8:	e0bffd15 	stw	r2,-12(fp)
        ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
8113dddc:	e0bfff17 	ldw	r2,-4(fp)
8113dde0:	10800317 	ldw	r2,12(r2)
8113dde4:	e0bffe15 	stw	r2,-8(fp)
        ptmr1->OSTmrNext = ptmr2;
8113dde8:	e0bffd17 	ldw	r2,-12(fp)
8113ddec:	e0fffe17 	ldw	r3,-8(fp)
8113ddf0:	10c00315 	stw	r3,12(r2)
        if (ptmr2 != (OS_TMR *)0) {
8113ddf4:	e0bffe17 	ldw	r2,-8(fp)
8113ddf8:	10000326 	beq	r2,zero,8113de08 <OSTmr_Unlink+0xb4>
            ptmr2->OSTmrPrev = (void *)ptmr1;
8113ddfc:	e0bffe17 	ldw	r2,-8(fp)
8113de00:	e0fffd17 	ldw	r3,-12(fp)
8113de04:	10c00415 	stw	r3,16(r2)
        }
    }
    ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
8113de08:	e0bfff17 	ldw	r2,-4(fp)
8113de0c:	00c00044 	movi	r3,1
8113de10:	10c00c45 	stb	r3,49(r2)
    ptmr->OSTmrNext  = (void *)0;
8113de14:	e0bfff17 	ldw	r2,-4(fp)
8113de18:	10000315 	stw	zero,12(r2)
    ptmr->OSTmrPrev  = (void *)0;
8113de1c:	e0bfff17 	ldw	r2,-4(fp)
8113de20:	10000415 	stw	zero,16(r2)
    pspoke->OSTmrEntries--;
8113de24:	e0bffc17 	ldw	r2,-16(fp)
8113de28:	1080010b 	ldhu	r2,4(r2)
8113de2c:	10bfffc4 	addi	r2,r2,-1
8113de30:	1007883a 	mov	r3,r2
8113de34:	e0bffc17 	ldw	r2,-16(fp)
8113de38:	10c0010d 	sth	r3,4(r2)
}
8113de3c:	0001883a 	nop
8113de40:	e037883a 	mov	sp,fp
8113de44:	df000017 	ldw	fp,0(sp)
8113de48:	dec00104 	addi	sp,sp,4
8113de4c:	f800283a 	ret

8113de50 <OSTmr_Lock>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Lock (void)
{
8113de50:	defffd04 	addi	sp,sp,-12
8113de54:	de00012e 	bgeu	sp,et,8113de5c <OSTmr_Lock+0xc>
8113de58:	003b68fa 	trap	3
8113de5c:	dfc00215 	stw	ra,8(sp)
8113de60:	df000115 	stw	fp,4(sp)
8113de64:	df000104 	addi	fp,sp,4
    INT8U  err;


    OSSemPend(OSTmrSem, 0, &err);
8113de68:	d0a0a117 	ldw	r2,-32124(gp)
8113de6c:	e1bfff04 	addi	r6,fp,-4
8113de70:	000b883a 	mov	r5,zero
8113de74:	1009883a 	mov	r4,r2
8113de78:	113aaf40 	call	8113aaf4 <OSSemPend>
    (void)err;
}
8113de7c:	0001883a 	nop
8113de80:	e037883a 	mov	sp,fp
8113de84:	dfc00117 	ldw	ra,4(sp)
8113de88:	df000017 	ldw	fp,0(sp)
8113de8c:	dec00204 	addi	sp,sp,8
8113de90:	f800283a 	ret

8113de94 <OSTmr_Unlock>:



#if OS_TMR_EN > 0
static  void  OSTmr_Unlock (void)
{
8113de94:	defffe04 	addi	sp,sp,-8
8113de98:	de00012e 	bgeu	sp,et,8113dea0 <OSTmr_Unlock+0xc>
8113de9c:	003b68fa 	trap	3
8113dea0:	dfc00115 	stw	ra,4(sp)
8113dea4:	df000015 	stw	fp,0(sp)
8113dea8:	d839883a 	mov	fp,sp
    (void)OSSemPost(OSTmrSem);
8113deac:	d0a0a117 	ldw	r2,-32124(gp)
8113deb0:	1009883a 	mov	r4,r2
8113deb4:	113ae7c0 	call	8113ae7c <OSSemPost>
}
8113deb8:	0001883a 	nop
8113debc:	e037883a 	mov	sp,fp
8113dec0:	dfc00117 	ldw	ra,4(sp)
8113dec4:	df000017 	ldw	fp,0(sp)
8113dec8:	dec00204 	addi	sp,sp,8
8113decc:	f800283a 	ret

8113ded0 <OSTmr_Task>:
************************************************************************************************************************
*/

#if OS_TMR_EN > 0
static  void  OSTmr_Task (void *p_arg)
{
8113ded0:	defff704 	addi	sp,sp,-36
8113ded4:	de00012e 	bgeu	sp,et,8113dedc <OSTmr_Task+0xc>
8113ded8:	003b68fa 	trap	3
8113dedc:	dfc00815 	stw	ra,32(sp)
8113dee0:	df000715 	stw	fp,28(sp)
8113dee4:	df000704 	addi	fp,sp,28
8113dee8:	e13fff15 	stw	r4,-4(fp)
    INT16U           spoke;


    (void)p_arg;                                                 /* Not using 'p_arg', prevent compiler warning       */
    for (;;) {
        OSSemPend(OSTmrSemSignal, 0, &err);                      /* Wait for signal indicating time to update timers  */
8113deec:	d0a08c17 	ldw	r2,-32208(gp)
8113def0:	e0fffe04 	addi	r3,fp,-8
8113def4:	180d883a 	mov	r6,r3
8113def8:	000b883a 	mov	r5,zero
8113defc:	1009883a 	mov	r4,r2
8113df00:	113aaf40 	call	8113aaf4 <OSSemPend>
        OSTmr_Lock();
8113df04:	113de500 	call	8113de50 <OSTmr_Lock>
        OSTmrTime++;                                             /* Increment the current time                        */
8113df08:	d0a09f17 	ldw	r2,-32132(gp)
8113df0c:	10800044 	addi	r2,r2,1
8113df10:	d0a09f15 	stw	r2,-32132(gp)
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
8113df14:	d0a09f17 	ldw	r2,-32132(gp)
8113df18:	1080004c 	andi	r2,r2,1
8113df1c:	e0bffa0d 	sth	r2,-24(fp)
        pspoke = &OSTmrWheelTbl[spoke];
8113df20:	e0bffa0b 	ldhu	r2,-24(fp)
8113df24:	100690fa 	slli	r3,r2,3
8113df28:	00a045b4 	movhi	r2,33046
8113df2c:	10890a04 	addi	r2,r2,9256
8113df30:	1885883a 	add	r2,r3,r2
8113df34:	e0bffb15 	stw	r2,-20(fp)
        ptmr   = pspoke->OSTmrFirst;
8113df38:	e0bffb17 	ldw	r2,-20(fp)
8113df3c:	10800017 	ldw	r2,0(r2)
8113df40:	e0bff915 	stw	r2,-28(fp)
        while (ptmr != (OS_TMR *)0) {
8113df44:	00002206 	br	8113dfd0 <OSTmr_Task+0x100>
            ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
8113df48:	e0bff917 	ldw	r2,-28(fp)
8113df4c:	10800317 	ldw	r2,12(r2)
8113df50:	e0bffc15 	stw	r2,-16(fp)
                                                                 /* ... timer could get unlinked from the wheel.      */
            if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
8113df54:	e0bff917 	ldw	r2,-28(fp)
8113df58:	10c00517 	ldw	r3,20(r2)
8113df5c:	d0a09f17 	ldw	r2,-32132(gp)
8113df60:	1880191e 	bne	r3,r2,8113dfc8 <OSTmr_Task+0xf8>
                pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
8113df64:	e0bff917 	ldw	r2,-28(fp)
8113df68:	10800117 	ldw	r2,4(r2)
8113df6c:	e0bffd15 	stw	r2,-12(fp)
                if (pfnct != (OS_TMR_CALLBACK)0) {
8113df70:	e0bffd17 	ldw	r2,-12(fp)
8113df74:	10000626 	beq	r2,zero,8113df90 <OSTmr_Task+0xc0>
                    (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
8113df78:	e0bff917 	ldw	r2,-28(fp)
8113df7c:	10c00217 	ldw	r3,8(r2)
8113df80:	e0bffd17 	ldw	r2,-12(fp)
8113df84:	180b883a 	mov	r5,r3
8113df88:	e13ff917 	ldw	r4,-28(fp)
8113df8c:	103ee83a 	callr	r2
                }
                OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
8113df90:	e13ff917 	ldw	r4,-28(fp)
8113df94:	113dd540 	call	8113dd54 <OSTmr_Unlink>
                if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
8113df98:	e0bff917 	ldw	r2,-28(fp)
8113df9c:	10800c03 	ldbu	r2,48(r2)
8113dfa0:	10803fcc 	andi	r2,r2,255
8113dfa4:	10800098 	cmpnei	r2,r2,2
8113dfa8:	1000041e 	bne	r2,zero,8113dfbc <OSTmr_Task+0xec>
                    OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
8113dfac:	01400044 	movi	r5,1
8113dfb0:	e13ff917 	ldw	r4,-28(fp)
8113dfb4:	113dc040 	call	8113dc04 <OSTmr_Link>
8113dfb8:	00000306 	br	8113dfc8 <OSTmr_Task+0xf8>
                } else {
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
8113dfbc:	e0bff917 	ldw	r2,-28(fp)
8113dfc0:	00c00084 	movi	r3,2
8113dfc4:	10c00c45 	stb	r3,49(r2)
                }
            }
            ptmr = ptmr_next;
8113dfc8:	e0bffc17 	ldw	r2,-16(fp)
8113dfcc:	e0bff915 	stw	r2,-28(fp)
        OSTmr_Lock();
        OSTmrTime++;                                             /* Increment the current time                        */
        spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
        pspoke = &OSTmrWheelTbl[spoke];
        ptmr   = pspoke->OSTmrFirst;
        while (ptmr != (OS_TMR *)0) {
8113dfd0:	e0bff917 	ldw	r2,-28(fp)
8113dfd4:	103fdc1e 	bne	r2,zero,8113df48 <__reset+0xfb11df48>
                    ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
                }
            }
            ptmr = ptmr_next;
        }
        OSTmr_Unlock();
8113dfd8:	113de940 	call	8113de94 <OSTmr_Unlock>
    }
8113dfdc:	003fc306 	br	8113deec <__reset+0xfb11deec>

8113dfe0 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
8113dfe0:	defffd04 	addi	sp,sp,-12
8113dfe4:	de00012e 	bgeu	sp,et,8113dfec <alt_dev_reg+0xc>
8113dfe8:	003b68fa 	trap	3
8113dfec:	dfc00215 	stw	ra,8(sp)
8113dff0:	df000115 	stw	fp,4(sp)
8113dff4:	df000104 	addi	fp,sp,4
8113dff8:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
8113dffc:	d1600d04 	addi	r5,gp,-32716
8113e000:	e13fff17 	ldw	r4,-4(fp)
8113e004:	11462800 	call	81146280 <alt_dev_llist_insert>
}
8113e008:	e037883a 	mov	sp,fp
8113e00c:	dfc00117 	ldw	ra,4(sp)
8113e010:	df000017 	ldw	fp,0(sp)
8113e014:	dec00204 	addi	sp,sp,8
8113e018:	f800283a 	ret

8113e01c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
8113e01c:	defffd04 	addi	sp,sp,-12
8113e020:	de00012e 	bgeu	sp,et,8113e028 <alt_irq_init+0xc>
8113e024:	003b68fa 	trap	3
8113e028:	dfc00215 	stw	ra,8(sp)
8113e02c:	df000115 	stw	fp,4(sp)
8113e030:	df000104 	addi	fp,sp,4
8113e034:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
8113e038:	1146c480 	call	81146c48 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
8113e03c:	00800044 	movi	r2,1
8113e040:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
8113e044:	0001883a 	nop
8113e048:	e037883a 	mov	sp,fp
8113e04c:	dfc00117 	ldw	ra,4(sp)
8113e050:	df000017 	ldw	fp,0(sp)
8113e054:	dec00204 	addi	sp,sp,8
8113e058:	f800283a 	ret

8113e05c <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
8113e05c:	defffe04 	addi	sp,sp,-8
8113e060:	de00012e 	bgeu	sp,et,8113e068 <alt_sys_init+0xc>
8113e064:	003b68fa 	trap	3
8113e068:	dfc00115 	stw	ra,4(sp)
8113e06c:	df000015 	stw	fp,0(sp)
8113e070:	d839883a 	mov	fp,sp
    ALTERA_AVALON_TIMER_INIT ( TIMER_1MS, timer_1ms);
8113e074:	01c0fa04 	movi	r7,1000
8113e078:	01800304 	movi	r6,12
8113e07c:	000b883a 	mov	r5,zero
8113e080:	01200034 	movhi	r4,32768
8113e084:	21022004 	addi	r4,r4,2176
8113e088:	11433b40 	call	811433b4 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_TIMER_INIT ( TIMER_1US, timer_1us);
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART_0, jtag_uart_0);
8113e08c:	018002c4 	movi	r6,11
8113e090:	000b883a 	mov	r5,zero
8113e094:	01204574 	movhi	r4,33045
8113e098:	2135fb04 	addi	r4,r4,-10260
8113e09c:	11426a00 	call	811426a0 <altera_avalon_jtag_uart_init>
8113e0a0:	01204574 	movhi	r4,33045
8113e0a4:	2135f104 	addi	r4,r4,-10300
8113e0a8:	113dfe00 	call	8113dfe0 <alt_dev_reg>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
8113e0ac:	0001883a 	nop
    ALTERA_AVALON_UART_INIT ( RS232_UART, rs232_uart);
8113e0b0:	018003c4 	movi	r6,15
8113e0b4:	000b883a 	mov	r5,zero
8113e0b8:	01204574 	movhi	r4,33045
8113e0bc:	213a1604 	addi	r4,r4,-6056
8113e0c0:	11435600 	call	81143560 <altera_avalon_uart_init>
8113e0c4:	01204574 	movhi	r4,33045
8113e0c8:	213a0c04 	addi	r4,r4,-6096
8113e0cc:	113dfe00 	call	8113dfe0 <alt_dev_reg>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M1, dma_DDR_M1);
8113e0d0:	00a04574 	movhi	r2,33045
8113e0d4:	10ba4004 	addi	r2,r2,-5888
8113e0d8:	10c00717 	ldw	r3,28(r2)
8113e0dc:	00a04574 	movhi	r2,33045
8113e0e0:	10ba4004 	addi	r2,r2,-5888
8113e0e4:	10800817 	ldw	r2,32(r2)
8113e0e8:	100d883a 	mov	r6,r2
8113e0ec:	180b883a 	mov	r5,r3
8113e0f0:	01204574 	movhi	r4,33045
8113e0f4:	213a4004 	addi	r4,r4,-5888
8113e0f8:	1145de80 	call	81145de8 <alt_msgdma_init>
    ALTERA_MSGDMA_INIT ( DMA_DDR_M2, dma_DDR_M2);
8113e0fc:	00a04574 	movhi	r2,33045
8113e100:	10ba5904 	addi	r2,r2,-5788
8113e104:	10c00717 	ldw	r3,28(r2)
8113e108:	00a04574 	movhi	r2,33045
8113e10c:	10ba5904 	addi	r2,r2,-5788
8113e110:	10800817 	ldw	r2,32(r2)
8113e114:	100d883a 	mov	r6,r2
8113e118:	180b883a 	mov	r5,r3
8113e11c:	01204574 	movhi	r4,33045
8113e120:	213a5904 	addi	r4,r4,-5788
8113e124:	1145de80 	call	81145de8 <alt_msgdma_init>
    ALTERA_UP_SD_CARD_AVALON_INTERFACE_INIT ( ALTERA_UP_SD_CARD_AVALON_INTERFACE_0, Altera_UP_SD_Card_Avalon_Interface_0);
8113e128:	01204574 	movhi	r4,33045
8113e12c:	213a7204 	addi	r4,r4,-5688
8113e130:	113dfe00 	call	8113dfe0 <alt_dev_reg>
}
8113e134:	0001883a 	nop
8113e138:	e037883a 	mov	sp,fp
8113e13c:	dfc00117 	ldw	ra,4(sp)
8113e140:	df000017 	ldw	fp,0(sp)
8113e144:	dec00204 	addi	sp,sp,8
8113e148:	f800283a 	ret

8113e14c <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
8113e14c:	defffa04 	addi	sp,sp,-24
8113e150:	de00012e 	bgeu	sp,et,8113e158 <Write_Sector_Data+0xc>
8113e154:	003b68fa 	trap	3
8113e158:	dfc00515 	stw	ra,20(sp)
8113e15c:	df000415 	stw	fp,16(sp)
8113e160:	df000404 	addi	fp,sp,16
8113e164:	e13ffe15 	stw	r4,-8(fp)
8113e168:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113e16c:	e03ffc15 	stw	zero,-16(fp)
    
    if (alt_up_sd_card_is_Present())
8113e170:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
8113e174:	10001e26 	beq	r2,zero,8113e1f0 <Write_Sector_Data+0xa4>
    {
        short int reg_state = 0xff;
8113e178:	00803fc4 	movi	r2,255
8113e17c:	e0bffd0d 	sth	r2,-12(fp)

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113e180:	d0a0ab17 	ldw	r2,-32084(gp)
8113e184:	e13ffe17 	ldw	r4,-8(fp)
8113e188:	e0ffff17 	ldw	r3,-4(fp)
8113e18c:	20c7883a 	add	r3,r4,r3
8113e190:	1806927a 	slli	r3,r3,9
8113e194:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
8113e198:	d0a0aa17 	ldw	r2,-32088(gp)
8113e19c:	00c00604 	movi	r3,24
8113e1a0:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113e1a4:	d0a0a717 	ldw	r2,-32100(gp)
8113e1a8:	1080002b 	ldhuio	r2,0(r2)
8113e1ac:	10bfffcc 	andi	r2,r2,65535
8113e1b0:	e0bffd0d 	sth	r2,-12(fp)
        } while ((reg_state & 0x04)!=0);
8113e1b4:	e0bffd0b 	ldhu	r2,-12(fp)
8113e1b8:	10bfffcc 	andi	r2,r2,65535
8113e1bc:	1080010c 	andi	r2,r2,4
8113e1c0:	103ff81e 	bne	r2,zero,8113e1a4 <__reset+0xfb11e1a4>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
8113e1c4:	e0bffd0b 	ldhu	r2,-12(fp)
8113e1c8:	10bfffcc 	andi	r2,r2,65535
8113e1cc:	1080040c 	andi	r2,r2,16
8113e1d0:	1000071e 	bne	r2,zero,8113e1f0 <Write_Sector_Data+0xa4>
        {
            result = true;
8113e1d4:	00800044 	movi	r2,1
8113e1d8:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113e1dc:	d020b015 	stw	zero,-32064(gp)
            current_sector_index = sector_index+partition_offset;
8113e1e0:	e0fffe17 	ldw	r3,-8(fp)
8113e1e4:	e0bfff17 	ldw	r2,-4(fp)
8113e1e8:	1885883a 	add	r2,r3,r2
8113e1ec:	d0a0b115 	stw	r2,-32060(gp)
        }
    }
    return result;
8113e1f0:	e0bffc17 	ldw	r2,-16(fp)
}
8113e1f4:	e037883a 	mov	sp,fp
8113e1f8:	dfc00117 	ldw	ra,4(sp)
8113e1fc:	df000017 	ldw	fp,0(sp)
8113e200:	dec00204 	addi	sp,sp,8
8113e204:	f800283a 	ret

8113e208 <Save_Modified_Sector>:


bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
8113e208:	defffd04 	addi	sp,sp,-12
8113e20c:	de00012e 	bgeu	sp,et,8113e214 <Save_Modified_Sector+0xc>
8113e210:	003b68fa 	trap	3
8113e214:	dfc00215 	stw	ra,8(sp)
8113e218:	df000115 	stw	fp,4(sp)
8113e21c:	df000104 	addi	fp,sp,4
    bool result = true;
8113e220:	00800044 	movi	r2,1
8113e224:	e0bfff15 	stw	r2,-4(fp)
    if (current_sector_modified)
8113e228:	d0a0b017 	ldw	r2,-32064(gp)
8113e22c:	10000526 	beq	r2,zero,8113e244 <Save_Modified_Sector+0x3c>
    {
        result = Write_Sector_Data(current_sector_index, 0);
8113e230:	d0a0b117 	ldw	r2,-32060(gp)
8113e234:	000b883a 	mov	r5,zero
8113e238:	1009883a 	mov	r4,r2
8113e23c:	113e14c0 	call	8113e14c <Write_Sector_Data>
8113e240:	e0bfff15 	stw	r2,-4(fp)
    }
    return result;
8113e244:	e0bfff17 	ldw	r2,-4(fp)
}
8113e248:	e037883a 	mov	sp,fp
8113e24c:	dfc00117 	ldw	ra,4(sp)
8113e250:	df000017 	ldw	fp,0(sp)
8113e254:	dec00204 	addi	sp,sp,8
8113e258:	f800283a 	ret

8113e25c <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
8113e25c:	defffa04 	addi	sp,sp,-24
8113e260:	de00012e 	bgeu	sp,et,8113e268 <Read_Sector_Data+0xc>
8113e264:	003b68fa 	trap	3
8113e268:	dfc00515 	stw	ra,20(sp)
8113e26c:	df000415 	stw	fp,16(sp)
8113e270:	df000404 	addi	fp,sp,16
8113e274:	e13ffe15 	stw	r4,-8(fp)
8113e278:	e17fff15 	stw	r5,-4(fp)
	bool result = false;
8113e27c:	e03ffc15 	stw	zero,-16(fp)
    
	if (alt_up_sd_card_is_Present())
8113e280:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
8113e284:	10002726 	beq	r2,zero,8113e324 <Read_Sector_Data+0xc8>
	{
		short int reg_state = 0xff;
8113e288:	00803fc4 	movi	r2,255
8113e28c:	e0bffd0d 	sth	r2,-12(fp)
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
8113e290:	d0a0b017 	ldw	r2,-32064(gp)
8113e294:	10000726 	beq	r2,zero,8113e2b4 <Read_Sector_Data+0x58>
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
8113e298:	d0a0b117 	ldw	r2,-32060(gp)
8113e29c:	000b883a 	mov	r5,zero
8113e2a0:	1009883a 	mov	r4,r2
8113e2a4:	113e14c0 	call	8113e14c <Write_Sector_Data>
8113e2a8:	1000021e 	bne	r2,zero,8113e2b4 <Read_Sector_Data+0x58>
            {
                return false;
8113e2ac:	0005883a 	mov	r2,zero
8113e2b0:	00001d06 	br	8113e328 <Read_Sector_Data+0xcc>
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
8113e2b4:	d0a0ab17 	ldw	r2,-32084(gp)
8113e2b8:	e13ffe17 	ldw	r4,-8(fp)
8113e2bc:	e0ffff17 	ldw	r3,-4(fp)
8113e2c0:	20c7883a 	add	r3,r4,r3
8113e2c4:	1806927a 	slli	r3,r3,9
8113e2c8:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
8113e2cc:	d0a0aa17 	ldw	r2,-32088(gp)
8113e2d0:	00c00444 	movi	r3,17
8113e2d4:	10c0002d 	sthio	r3,0(r2)
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
8113e2d8:	d0a0a717 	ldw	r2,-32100(gp)
8113e2dc:	1080002b 	ldhuio	r2,0(r2)
8113e2e0:	10bfffcc 	andi	r2,r2,65535
8113e2e4:	e0bffd0d 	sth	r2,-12(fp)
		} while ((reg_state & 0x04)!=0);
8113e2e8:	e0bffd0b 	ldhu	r2,-12(fp)
8113e2ec:	10bfffcc 	andi	r2,r2,65535
8113e2f0:	1080010c 	andi	r2,r2,4
8113e2f4:	103ff81e 	bne	r2,zero,8113e2d8 <__reset+0xfb11e2d8>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
8113e2f8:	e0bffd0b 	ldhu	r2,-12(fp)
8113e2fc:	10bfffcc 	andi	r2,r2,65535
8113e300:	1080040c 	andi	r2,r2,16
8113e304:	1000071e 	bne	r2,zero,8113e324 <Read_Sector_Data+0xc8>
		{
			result = true;
8113e308:	00800044 	movi	r2,1
8113e30c:	e0bffc15 	stw	r2,-16(fp)
            current_sector_modified = false;
8113e310:	d020b015 	stw	zero,-32064(gp)
            current_sector_index = sector_index+partition_offset;
8113e314:	e0fffe17 	ldw	r3,-8(fp)
8113e318:	e0bfff17 	ldw	r2,-4(fp)
8113e31c:	1885883a 	add	r2,r3,r2
8113e320:	d0a0b115 	stw	r2,-32060(gp)
		}
	}
	return result;
8113e324:	e0bffc17 	ldw	r2,-16(fp)
}
8113e328:	e037883a 	mov	sp,fp
8113e32c:	dfc00117 	ldw	ra,4(sp)
8113e330:	df000017 	ldw	fp,0(sp)
8113e334:	dec00204 	addi	sp,sp,8
8113e338:	f800283a 	ret

8113e33c <get_cluster_flag>:


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
8113e33c:	defffb04 	addi	sp,sp,-20
8113e340:	de00012e 	bgeu	sp,et,8113e348 <get_cluster_flag+0xc>
8113e344:	003b68fa 	trap	3
8113e348:	dfc00415 	stw	ra,16(sp)
8113e34c:	df000315 	stw	fp,12(sp)
8113e350:	df000304 	addi	fp,sp,12
8113e354:	e13ffe15 	stw	r4,-8(fp)
8113e358:	e17fff15 	stw	r5,-4(fp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
8113e35c:	e0bffe17 	ldw	r2,-8(fp)
8113e360:	1004d23a 	srli	r2,r2,8
8113e364:	d0e0ad17 	ldw	r3,-32076(gp)
8113e368:	10c5883a 	add	r2,r2,r3
8113e36c:	e0bffd15 	stw	r2,-12(fp)
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113e370:	00a045f4 	movhi	r2,33047
8113e374:	10a13004 	addi	r2,r2,-31552
8113e378:	10801117 	ldw	r2,68(r2)
8113e37c:	e0fffd17 	ldw	r3,-12(fp)
8113e380:	1885883a 	add	r2,r3,r2
8113e384:	e0bffd15 	stw	r2,-12(fp)
     
    if (sector_index != current_sector_index)
8113e388:	d0a0b117 	ldw	r2,-32060(gp)
8113e38c:	e0fffd17 	ldw	r3,-12(fp)
8113e390:	18800726 	beq	r3,r2,8113e3b0 <get_cluster_flag+0x74>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113e394:	e0bffd17 	ldw	r2,-12(fp)
8113e398:	000b883a 	mov	r5,zero
8113e39c:	1009883a 	mov	r4,r2
8113e3a0:	113e25c0 	call	8113e25c <Read_Sector_Data>
8113e3a4:	1000021e 	bne	r2,zero,8113e3b0 <get_cluster_flag+0x74>
        {
            return false;
8113e3a8:	0005883a 	mov	r2,zero
8113e3ac:	00000d06 	br	8113e3e4 <get_cluster_flag+0xa8>
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
8113e3b0:	e0bffe17 	ldw	r2,-8(fp)
8113e3b4:	10803fcc 	andi	r2,r2,255
8113e3b8:	1085883a 	add	r2,r2,r2
8113e3bc:	1007883a 	mov	r3,r2
8113e3c0:	d0a0af17 	ldw	r2,-32068(gp)
8113e3c4:	10800a17 	ldw	r2,40(r2)
8113e3c8:	1885883a 	add	r2,r3,r2
8113e3cc:	1080002b 	ldhuio	r2,0(r2)
8113e3d0:	10bfffcc 	andi	r2,r2,65535
8113e3d4:	1007883a 	mov	r3,r2
8113e3d8:	e0bfff17 	ldw	r2,-4(fp)
8113e3dc:	10c0000d 	sth	r3,0(r2)
    return true;
8113e3e0:	00800044 	movi	r2,1
}
8113e3e4:	e037883a 	mov	sp,fp
8113e3e8:	dfc00117 	ldw	ra,4(sp)
8113e3ec:	df000017 	ldw	fp,0(sp)
8113e3f0:	dec00204 	addi	sp,sp,8
8113e3f4:	f800283a 	ret

8113e3f8 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
8113e3f8:	defffa04 	addi	sp,sp,-24
8113e3fc:	de00012e 	bgeu	sp,et,8113e404 <mark_cluster+0xc>
8113e400:	003b68fa 	trap	3
8113e404:	dfc00515 	stw	ra,20(sp)
8113e408:	df000415 	stw	fp,16(sp)
8113e40c:	df000404 	addi	fp,sp,16
8113e410:	e13ffd15 	stw	r4,-12(fp)
8113e414:	2805883a 	mov	r2,r5
8113e418:	e1bfff15 	stw	r6,-4(fp)
8113e41c:	e0bffe0d 	sth	r2,-8(fp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
8113e420:	e0bffd17 	ldw	r2,-12(fp)
8113e424:	1004d23a 	srli	r2,r2,8
8113e428:	d0e0ad17 	ldw	r3,-32076(gp)
8113e42c:	10c5883a 	add	r2,r2,r3
8113e430:	e0bffc15 	stw	r2,-16(fp)
    
    if (first_fat)
8113e434:	e0bfff17 	ldw	r2,-4(fp)
8113e438:	10000726 	beq	r2,zero,8113e458 <mark_cluster+0x60>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
8113e43c:	00a045f4 	movhi	r2,33047
8113e440:	10a13004 	addi	r2,r2,-31552
8113e444:	10801117 	ldw	r2,68(r2)
8113e448:	e0fffc17 	ldw	r3,-16(fp)
8113e44c:	1885883a 	add	r2,r3,r2
8113e450:	e0bffc15 	stw	r2,-16(fp)
8113e454:	00000606 	br	8113e470 <mark_cluster+0x78>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
8113e458:	00a045f4 	movhi	r2,33047
8113e45c:	10a13004 	addi	r2,r2,-31552
8113e460:	10801217 	ldw	r2,72(r2)
8113e464:	e0fffc17 	ldw	r3,-16(fp)
8113e468:	1885883a 	add	r2,r3,r2
8113e46c:	e0bffc15 	stw	r2,-16(fp)
    }
     
    if (sector_index != current_sector_index)
8113e470:	d0a0b117 	ldw	r2,-32060(gp)
8113e474:	e0fffc17 	ldw	r3,-16(fp)
8113e478:	18800726 	beq	r3,r2,8113e498 <mark_cluster+0xa0>
    {
        if (Read_Sector_Data(sector_index, 0) == false)
8113e47c:	e0bffc17 	ldw	r2,-16(fp)
8113e480:	000b883a 	mov	r5,zero
8113e484:	1009883a 	mov	r4,r2
8113e488:	113e25c0 	call	8113e25c <Read_Sector_Data>
8113e48c:	1000021e 	bne	r2,zero,8113e498 <mark_cluster+0xa0>
        {
            return false;
8113e490:	0005883a 	mov	r2,zero
8113e494:	00000d06 	br	8113e4cc <mark_cluster+0xd4>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
8113e498:	e0bffd17 	ldw	r2,-12(fp)
8113e49c:	10803fcc 	andi	r2,r2,255
8113e4a0:	1085883a 	add	r2,r2,r2
8113e4a4:	1007883a 	mov	r3,r2
8113e4a8:	d0a0af17 	ldw	r2,-32068(gp)
8113e4ac:	10800a17 	ldw	r2,40(r2)
8113e4b0:	1885883a 	add	r2,r3,r2
8113e4b4:	1007883a 	mov	r3,r2
8113e4b8:	e0bffe0f 	ldh	r2,-8(fp)
8113e4bc:	1880002d 	sthio	r2,0(r3)
    current_sector_modified = true;
8113e4c0:	00800044 	movi	r2,1
8113e4c4:	d0a0b015 	stw	r2,-32064(gp)
    return true;
8113e4c8:	00800044 	movi	r2,1
}
8113e4cc:	e037883a 	mov	sp,fp
8113e4d0:	dfc00117 	ldw	ra,4(sp)
8113e4d4:	df000017 	ldw	fp,0(sp)
8113e4d8:	dec00204 	addi	sp,sp,8
8113e4dc:	f800283a 	ret

8113e4e0 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
8113e4e0:	defff704 	addi	sp,sp,-36
8113e4e4:	de00012e 	bgeu	sp,et,8113e4ec <Check_for_Master_Boot_Record+0xc>
8113e4e8:	003b68fa 	trap	3
8113e4ec:	dfc00815 	stw	ra,32(sp)
8113e4f0:	df000715 	stw	fp,28(sp)
8113e4f4:	df000704 	addi	fp,sp,28
	bool result = false;
8113e4f8:	e03ff915 	stw	zero,-28(fp)
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
8113e4fc:	000b883a 	mov	r5,zero
8113e500:	0009883a 	mov	r4,zero
8113e504:	113e25c0 	call	8113e25c <Read_Sector_Data>
8113e508:	10005a26 	beq	r2,zero,8113e674 <Check_for_Master_Boot_Record+0x194>
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
8113e50c:	d0a0af17 	ldw	r2,-32068(gp)
8113e510:	10800a17 	ldw	r2,40(r2)
8113e514:	10807f84 	addi	r2,r2,510
8113e518:	1080002b 	ldhuio	r2,0(r2)
8113e51c:	10bfffcc 	andi	r2,r2,65535
8113e520:	10bfffcc 	andi	r2,r2,65535
8113e524:	10a0001c 	xori	r2,r2,32768
8113e528:	10a00004 	addi	r2,r2,-32768
8113e52c:	e0bffb15 	stw	r2,-20(fp)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
8113e530:	e0bffb17 	ldw	r2,-20(fp)
8113e534:	10ffffcc 	andi	r3,r2,65535
8113e538:	00aa9554 	movui	r2,43605
8113e53c:	18804d1e 	bne	r3,r2,8113e674 <Check_for_Master_Boot_Record+0x194>
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113e540:	e03ffa15 	stw	zero,-24(fp)
8113e544:	00004806 	br	8113e668 <Check_for_Master_Boot_Record+0x188>
			{
				int partition_data_offset = (index * 16) + 0x01be;
8113e548:	e0bffa17 	ldw	r2,-24(fp)
8113e54c:	1004913a 	slli	r2,r2,4
8113e550:	10806f84 	addi	r2,r2,446
8113e554:	e0bffc15 	stw	r2,-16(fp)
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
8113e558:	d0a0af17 	ldw	r2,-32068(gp)
8113e55c:	10c00a17 	ldw	r3,40(r2)
8113e560:	e0bffc17 	ldw	r2,-16(fp)
8113e564:	1885883a 	add	r2,r3,r2
8113e568:	10800104 	addi	r2,r2,4
8113e56c:	10800023 	ldbuio	r2,0(r2)
8113e570:	10803fcc 	andi	r2,r2,255
8113e574:	e0bffd05 	stb	r2,-12(fp)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
8113e578:	e0bffd07 	ldb	r2,-12(fp)
8113e57c:	10800060 	cmpeqi	r2,r2,1
8113e580:	1000091e 	bne	r2,zero,8113e5a8 <Check_for_Master_Boot_Record+0xc8>
8113e584:	e0bffd07 	ldb	r2,-12(fp)
8113e588:	10800120 	cmpeqi	r2,r2,4
8113e58c:	1000061e 	bne	r2,zero,8113e5a8 <Check_for_Master_Boot_Record+0xc8>
8113e590:	e0bffd07 	ldb	r2,-12(fp)
8113e594:	108001a0 	cmpeqi	r2,r2,6
8113e598:	1000031e 	bne	r2,zero,8113e5a8 <Check_for_Master_Boot_Record+0xc8>
8113e59c:	e0bffd07 	ldb	r2,-12(fp)
8113e5a0:	10800398 	cmpnei	r2,r2,14
8113e5a4:	10002d1e 	bne	r2,zero,8113e65c <Check_for_Master_Boot_Record+0x17c>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
8113e5a8:	d0a0af17 	ldw	r2,-32068(gp)
8113e5ac:	10c00a17 	ldw	r3,40(r2)
8113e5b0:	e0bffc17 	ldw	r2,-16(fp)
8113e5b4:	1885883a 	add	r2,r3,r2
8113e5b8:	10800284 	addi	r2,r2,10
8113e5bc:	1080002b 	ldhuio	r2,0(r2)
8113e5c0:	10bfffcc 	andi	r2,r2,65535
8113e5c4:	1006943a 	slli	r3,r2,16
8113e5c8:	d0a0af17 	ldw	r2,-32068(gp)
8113e5cc:	11000a17 	ldw	r4,40(r2)
8113e5d0:	e0bffc17 	ldw	r2,-16(fp)
8113e5d4:	2085883a 	add	r2,r4,r2
8113e5d8:	10800204 	addi	r2,r2,8
8113e5dc:	1080002b 	ldhuio	r2,0(r2)
8113e5e0:	10bfffcc 	andi	r2,r2,65535
8113e5e4:	10bfffcc 	andi	r2,r2,65535
8113e5e8:	1884b03a 	or	r2,r3,r2
8113e5ec:	e0bffe15 	stw	r2,-8(fp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
8113e5f0:	d0a0af17 	ldw	r2,-32068(gp)
8113e5f4:	10c00a17 	ldw	r3,40(r2)
8113e5f8:	e0bffc17 	ldw	r2,-16(fp)
8113e5fc:	1885883a 	add	r2,r3,r2
8113e600:	10800384 	addi	r2,r2,14
8113e604:	1080002b 	ldhuio	r2,0(r2)
8113e608:	10bfffcc 	andi	r2,r2,65535
8113e60c:	1006943a 	slli	r3,r2,16
8113e610:	d0a0af17 	ldw	r2,-32068(gp)
8113e614:	11000a17 	ldw	r4,40(r2)
8113e618:	e0bffc17 	ldw	r2,-16(fp)
8113e61c:	2085883a 	add	r2,r4,r2
8113e620:	10800304 	addi	r2,r2,12
8113e624:	1080002b 	ldhuio	r2,0(r2)
8113e628:	10bfffcc 	andi	r2,r2,65535
8113e62c:	10bfffcc 	andi	r2,r2,65535
8113e630:	1884b03a 	or	r2,r3,r2
8113e634:	e0bfff15 	stw	r2,-4(fp)
		            
					// Check if the partition is valid
					if (partition_size > 0)
8113e638:	e0bfff17 	ldw	r2,-4(fp)
8113e63c:	0080070e 	bge	zero,r2,8113e65c <Check_for_Master_Boot_Record+0x17c>
					{
						result = true;
8113e640:	00800044 	movi	r2,1
8113e644:	e0bff915 	stw	r2,-28(fp)
						fat_partition_size_in_512_byte_sectors = partition_size;
8113e648:	e0bfff17 	ldw	r2,-4(fp)
8113e64c:	d0a0ae15 	stw	r2,-32072(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
8113e650:	e0bffe17 	ldw	r2,-8(fp)
8113e654:	d0a0ad15 	stw	r2,-32076(gp)
						break;
8113e658:	00000606 	br	8113e674 <Check_for_Master_Boot_Record+0x194>

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
8113e65c:	e0bffa17 	ldw	r2,-24(fp)
8113e660:	10800044 	addi	r2,r2,1
8113e664:	e0bffa15 	stw	r2,-24(fp)
8113e668:	e0bffa17 	ldw	r2,-24(fp)
8113e66c:	10800110 	cmplti	r2,r2,4
8113e670:	103fb51e 	bne	r2,zero,8113e548 <__reset+0xfb11e548>
				}
			}
		}
	}

	return result;
8113e674:	e0bff917 	ldw	r2,-28(fp)
}
8113e678:	e037883a 	mov	sp,fp
8113e67c:	dfc00117 	ldw	ra,4(sp)
8113e680:	df000017 	ldw	fp,0(sp)
8113e684:	dec00204 	addi	sp,sp,8
8113e688:	f800283a 	ret

8113e68c <Read_File_Record_At_Offset>:


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
8113e68c:	defff804 	addi	sp,sp,-32
8113e690:	de00012e 	bgeu	sp,et,8113e698 <Read_File_Record_At_Offset+0xc>
8113e694:	003b68fa 	trap	3
8113e698:	dfc00715 	stw	ra,28(sp)
8113e69c:	df000615 	stw	fp,24(sp)
8113e6a0:	df000604 	addi	fp,sp,24
8113e6a4:	e13ffc15 	stw	r4,-16(fp)
8113e6a8:	e17ffd15 	stw	r5,-12(fp)
8113e6ac:	e1bffe15 	stw	r6,-8(fp)
8113e6b0:	e1ffff15 	stw	r7,-4(fp)
	bool result = false;
8113e6b4:	e03ffa15 	stw	zero,-24(fp)
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113e6b8:	e0bffc17 	ldw	r2,-16(fp)
8113e6bc:	108007cc 	andi	r2,r2,31
8113e6c0:	10008d1e 	bne	r2,zero,8113e8f8 <Read_File_Record_At_Offset+0x26c>
8113e6c4:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
8113e6c8:	10008b26 	beq	r2,zero,8113e8f8 <Read_File_Record_At_Offset+0x26c>
8113e6cc:	d0a0a617 	ldw	r2,-32104(gp)
8113e6d0:	10008926 	beq	r2,zero,8113e8f8 <Read_File_Record_At_Offset+0x26c>
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113e6d4:	e03ffb15 	stw	zero,-20(fp)
8113e6d8:	00001106 	br	8113e720 <Read_File_Record_At_Offset+0x94>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
8113e6dc:	e0fffc17 	ldw	r3,-16(fp)
8113e6e0:	e0bffb17 	ldw	r2,-20(fp)
8113e6e4:	1885883a 	add	r2,r3,r2
8113e6e8:	1007883a 	mov	r3,r2
8113e6ec:	d0a0af17 	ldw	r2,-32068(gp)
8113e6f0:	10800a17 	ldw	r2,40(r2)
8113e6f4:	1885883a 	add	r2,r3,r2
8113e6f8:	10800023 	ldbuio	r2,0(r2)
8113e6fc:	10803fcc 	andi	r2,r2,255
8113e700:	1009883a 	mov	r4,r2
8113e704:	e0fffd17 	ldw	r3,-12(fp)
8113e708:	e0bffb17 	ldw	r2,-20(fp)
8113e70c:	1885883a 	add	r2,r3,r2
8113e710:	11000005 	stb	r4,0(r2)
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
8113e714:	e0bffb17 	ldw	r2,-20(fp)
8113e718:	10800044 	addi	r2,r2,1
8113e71c:	e0bffb15 	stw	r2,-20(fp)
8113e720:	e0bffb17 	ldw	r2,-20(fp)
8113e724:	10800210 	cmplti	r2,r2,8
8113e728:	103fec1e 	bne	r2,zero,8113e6dc <__reset+0xfb11e6dc>
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113e72c:	e03ffb15 	stw	zero,-20(fp)
8113e730:	00001306 	br	8113e780 <Read_File_Record_At_Offset+0xf4>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
8113e734:	e0fffc17 	ldw	r3,-16(fp)
8113e738:	e0bffb17 	ldw	r2,-20(fp)
8113e73c:	1885883a 	add	r2,r3,r2
8113e740:	1007883a 	mov	r3,r2
8113e744:	d0a0af17 	ldw	r2,-32068(gp)
8113e748:	10800a17 	ldw	r2,40(r2)
8113e74c:	1885883a 	add	r2,r3,r2
8113e750:	10800204 	addi	r2,r2,8
8113e754:	10800023 	ldbuio	r2,0(r2)
8113e758:	10803fcc 	andi	r2,r2,255
8113e75c:	1009883a 	mov	r4,r2
8113e760:	e0fffd17 	ldw	r3,-12(fp)
8113e764:	e0bffb17 	ldw	r2,-20(fp)
8113e768:	1885883a 	add	r2,r3,r2
8113e76c:	10800204 	addi	r2,r2,8
8113e770:	11000005 	stb	r4,0(r2)

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
8113e774:	e0bffb17 	ldw	r2,-20(fp)
8113e778:	10800044 	addi	r2,r2,1
8113e77c:	e0bffb15 	stw	r2,-20(fp)
8113e780:	e0bffb17 	ldw	r2,-20(fp)
8113e784:	108000d0 	cmplti	r2,r2,3
8113e788:	103fea1e 	bne	r2,zero,8113e734 <__reset+0xfb11e734>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
8113e78c:	d0a0af17 	ldw	r2,-32068(gp)
8113e790:	10c00a17 	ldw	r3,40(r2)
8113e794:	e0bffc17 	ldw	r2,-16(fp)
8113e798:	1885883a 	add	r2,r3,r2
8113e79c:	108002c4 	addi	r2,r2,11
8113e7a0:	10800023 	ldbuio	r2,0(r2)
8113e7a4:	10803fcc 	andi	r2,r2,255
8113e7a8:	1007883a 	mov	r3,r2
8113e7ac:	e0bffd17 	ldw	r2,-12(fp)
8113e7b0:	10c002c5 	stb	r3,11(r2)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
8113e7b4:	d0a0af17 	ldw	r2,-32068(gp)
8113e7b8:	10c00a17 	ldw	r3,40(r2)
8113e7bc:	e0bffc17 	ldw	r2,-16(fp)
8113e7c0:	1885883a 	add	r2,r3,r2
8113e7c4:	10800384 	addi	r2,r2,14
8113e7c8:	1080002b 	ldhuio	r2,0(r2)
8113e7cc:	10bfffcc 	andi	r2,r2,65535
8113e7d0:	1007883a 	mov	r3,r2
8113e7d4:	e0bffd17 	ldw	r2,-12(fp)
8113e7d8:	10c0030d 	sth	r3,12(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
8113e7dc:	d0a0af17 	ldw	r2,-32068(gp)
8113e7e0:	10c00a17 	ldw	r3,40(r2)
8113e7e4:	e0bffc17 	ldw	r2,-16(fp)
8113e7e8:	1885883a 	add	r2,r3,r2
8113e7ec:	10800404 	addi	r2,r2,16
8113e7f0:	1080002b 	ldhuio	r2,0(r2)
8113e7f4:	10bfffcc 	andi	r2,r2,65535
8113e7f8:	1007883a 	mov	r3,r2
8113e7fc:	e0bffd17 	ldw	r2,-12(fp)
8113e800:	10c0038d 	sth	r3,14(r2)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
8113e804:	d0a0af17 	ldw	r2,-32068(gp)
8113e808:	10c00a17 	ldw	r3,40(r2)
8113e80c:	e0bffc17 	ldw	r2,-16(fp)
8113e810:	1885883a 	add	r2,r3,r2
8113e814:	10800484 	addi	r2,r2,18
8113e818:	1080002b 	ldhuio	r2,0(r2)
8113e81c:	10bfffcc 	andi	r2,r2,65535
8113e820:	1007883a 	mov	r3,r2
8113e824:	e0bffd17 	ldw	r2,-12(fp)
8113e828:	10c0040d 	sth	r3,16(r2)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
8113e82c:	d0a0af17 	ldw	r2,-32068(gp)
8113e830:	10c00a17 	ldw	r3,40(r2)
8113e834:	e0bffc17 	ldw	r2,-16(fp)
8113e838:	1885883a 	add	r2,r3,r2
8113e83c:	10800584 	addi	r2,r2,22
8113e840:	1080002b 	ldhuio	r2,0(r2)
8113e844:	10bfffcc 	andi	r2,r2,65535
8113e848:	1007883a 	mov	r3,r2
8113e84c:	e0bffd17 	ldw	r2,-12(fp)
8113e850:	10c0048d 	sth	r3,18(r2)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
8113e854:	d0a0af17 	ldw	r2,-32068(gp)
8113e858:	10c00a17 	ldw	r3,40(r2)
8113e85c:	e0bffc17 	ldw	r2,-16(fp)
8113e860:	1885883a 	add	r2,r3,r2
8113e864:	10800604 	addi	r2,r2,24
8113e868:	1080002b 	ldhuio	r2,0(r2)
8113e86c:	10bfffcc 	andi	r2,r2,65535
8113e870:	1007883a 	mov	r3,r2
8113e874:	e0bffd17 	ldw	r2,-12(fp)
8113e878:	10c0050d 	sth	r3,20(r2)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
8113e87c:	d0a0af17 	ldw	r2,-32068(gp)
8113e880:	10c00a17 	ldw	r3,40(r2)
8113e884:	e0bffc17 	ldw	r2,-16(fp)
8113e888:	1885883a 	add	r2,r3,r2
8113e88c:	10800684 	addi	r2,r2,26
8113e890:	1080002b 	ldhuio	r2,0(r2)
8113e894:	10bfffcc 	andi	r2,r2,65535
8113e898:	1007883a 	mov	r3,r2
8113e89c:	e0bffd17 	ldw	r2,-12(fp)
8113e8a0:	10c0058d 	sth	r3,22(r2)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
8113e8a4:	d0a0af17 	ldw	r2,-32068(gp)
8113e8a8:	10c00a17 	ldw	r3,40(r2)
8113e8ac:	e0bffc17 	ldw	r2,-16(fp)
8113e8b0:	1885883a 	add	r2,r3,r2
8113e8b4:	10800704 	addi	r2,r2,28
8113e8b8:	10800037 	ldwio	r2,0(r2)
8113e8bc:	1007883a 	mov	r3,r2
8113e8c0:	e0bffd17 	ldw	r2,-12(fp)
8113e8c4:	10c00615 	stw	r3,24(r2)
		record->file_record_cluster = cluster_index;
8113e8c8:	e0bffd17 	ldw	r2,-12(fp)
8113e8cc:	e0fffe17 	ldw	r3,-8(fp)
8113e8d0:	10c00a15 	stw	r3,40(r2)
		record->file_record_sector_in_cluster = sector_in_cluster;
8113e8d4:	e0bffd17 	ldw	r2,-12(fp)
8113e8d8:	e0ffff17 	ldw	r3,-4(fp)
8113e8dc:	10c00b15 	stw	r3,44(r2)
		record->file_record_offset = offset;
8113e8e0:	e0bffc17 	ldw	r2,-16(fp)
8113e8e4:	1007883a 	mov	r3,r2
8113e8e8:	e0bffd17 	ldw	r2,-12(fp)
8113e8ec:	10c00c0d 	sth	r3,48(r2)
		result = true;
8113e8f0:	00800044 	movi	r2,1
8113e8f4:	e0bffa15 	stw	r2,-24(fp)
	}
	return result;
8113e8f8:	e0bffa17 	ldw	r2,-24(fp)
}
8113e8fc:	e037883a 	mov	sp,fp
8113e900:	dfc00117 	ldw	ra,4(sp)
8113e904:	df000017 	ldw	fp,0(sp)
8113e908:	dec00204 	addi	sp,sp,8
8113e90c:	f800283a 	ret

8113e910 <Write_File_Record_At_Offset>:


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
8113e910:	defff904 	addi	sp,sp,-28
8113e914:	de00012e 	bgeu	sp,et,8113e91c <Write_File_Record_At_Offset+0xc>
8113e918:	003b68fa 	trap	3
8113e91c:	dfc00615 	stw	ra,24(sp)
8113e920:	df000515 	stw	fp,20(sp)
8113e924:	df000504 	addi	fp,sp,20
8113e928:	e13ffe15 	stw	r4,-8(fp)
8113e92c:	e17fff15 	stw	r5,-4(fp)
    bool result = false;
8113e930:	e03ffb15 	stw	zero,-20(fp)
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8113e934:	e0bffe17 	ldw	r2,-8(fp)
8113e938:	108007cc 	andi	r2,r2,31
8113e93c:	1000931e 	bne	r2,zero,8113eb8c <Write_File_Record_At_Offset+0x27c>
8113e940:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
8113e944:	10009126 	beq	r2,zero,8113eb8c <Write_File_Record_At_Offset+0x27c>
8113e948:	d0a0a617 	ldw	r2,-32104(gp)
8113e94c:	10008f26 	beq	r2,zero,8113eb8c <Write_File_Record_At_Offset+0x27c>
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113e950:	e03ffc15 	stw	zero,-16(fp)
8113e954:	00001f06 	br	8113e9d4 <Write_File_Record_At_Offset+0xc4>
        {
            short int two_chars = (short int) record->name[counter+1];
8113e958:	e0bffc17 	ldw	r2,-16(fp)
8113e95c:	10800044 	addi	r2,r2,1
8113e960:	e0ffff17 	ldw	r3,-4(fp)
8113e964:	1885883a 	add	r2,r3,r2
8113e968:	10800003 	ldbu	r2,0(r2)
8113e96c:	10803fcc 	andi	r2,r2,255
8113e970:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars << 8;
8113e974:	e0bffd0f 	ldh	r2,-12(fp)
8113e978:	1004923a 	slli	r2,r2,8
8113e97c:	e0bffd0d 	sth	r2,-12(fp)
            two_chars = two_chars | record->name[counter];
8113e980:	e0ffff17 	ldw	r3,-4(fp)
8113e984:	e0bffc17 	ldw	r2,-16(fp)
8113e988:	1885883a 	add	r2,r3,r2
8113e98c:	10800003 	ldbu	r2,0(r2)
8113e990:	10c03fcc 	andi	r3,r2,255
8113e994:	e0bffd0b 	ldhu	r2,-12(fp)
8113e998:	1884b03a 	or	r2,r3,r2
8113e99c:	e0bffd0d 	sth	r2,-12(fp)
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
8113e9a0:	e0fffe17 	ldw	r3,-8(fp)
8113e9a4:	e0bffc17 	ldw	r2,-16(fp)
8113e9a8:	1885883a 	add	r2,r3,r2
8113e9ac:	1007883a 	mov	r3,r2
8113e9b0:	d0a0af17 	ldw	r2,-32068(gp)
8113e9b4:	10800a17 	ldw	r2,40(r2)
8113e9b8:	1885883a 	add	r2,r3,r2
8113e9bc:	1007883a 	mov	r3,r2
8113e9c0:	e0bffd0f 	ldh	r2,-12(fp)
8113e9c4:	1880002d 	sthio	r2,0(r3)
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
8113e9c8:	e0bffc17 	ldw	r2,-16(fp)
8113e9cc:	10800084 	addi	r2,r2,2
8113e9d0:	e0bffc15 	stw	r2,-16(fp)
8113e9d4:	e0bffc17 	ldw	r2,-16(fp)
8113e9d8:	10800210 	cmplti	r2,r2,8
8113e9dc:	103fde1e 	bne	r2,zero,8113e958 <__reset+0xfb11e958>
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113e9e0:	e03ffc15 	stw	zero,-16(fp)
8113e9e4:	00001306 	br	8113ea34 <Write_File_Record_At_Offset+0x124>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
8113e9e8:	e0fffe17 	ldw	r3,-8(fp)
8113e9ec:	e0bffc17 	ldw	r2,-16(fp)
8113e9f0:	1885883a 	add	r2,r3,r2
8113e9f4:	1007883a 	mov	r3,r2
8113e9f8:	d0a0af17 	ldw	r2,-32068(gp)
8113e9fc:	10800a17 	ldw	r2,40(r2)
8113ea00:	1885883a 	add	r2,r3,r2
8113ea04:	10800204 	addi	r2,r2,8
8113ea08:	1009883a 	mov	r4,r2
8113ea0c:	e0ffff17 	ldw	r3,-4(fp)
8113ea10:	e0bffc17 	ldw	r2,-16(fp)
8113ea14:	1885883a 	add	r2,r3,r2
8113ea18:	10800204 	addi	r2,r2,8
8113ea1c:	10800003 	ldbu	r2,0(r2)
8113ea20:	10803fcc 	andi	r2,r2,255
8113ea24:	20800025 	stbio	r2,0(r4)
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
8113ea28:	e0bffc17 	ldw	r2,-16(fp)
8113ea2c:	10800044 	addi	r2,r2,1
8113ea30:	e0bffc15 	stw	r2,-16(fp)
8113ea34:	e0bffc17 	ldw	r2,-16(fp)
8113ea38:	108000d0 	cmplti	r2,r2,3
8113ea3c:	103fea1e 	bne	r2,zero,8113e9e8 <__reset+0xfb11e9e8>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
8113ea40:	d0a0af17 	ldw	r2,-32068(gp)
8113ea44:	10c00a17 	ldw	r3,40(r2)
8113ea48:	e0bffe17 	ldw	r2,-8(fp)
8113ea4c:	1885883a 	add	r2,r3,r2
8113ea50:	108002c4 	addi	r2,r2,11
8113ea54:	1007883a 	mov	r3,r2
8113ea58:	e0bfff17 	ldw	r2,-4(fp)
8113ea5c:	108002c3 	ldbu	r2,11(r2)
8113ea60:	10803fcc 	andi	r2,r2,255
8113ea64:	18800025 	stbio	r2,0(r3)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
8113ea68:	d0a0af17 	ldw	r2,-32068(gp)
8113ea6c:	10c00a17 	ldw	r3,40(r2)
8113ea70:	e0bffe17 	ldw	r2,-8(fp)
8113ea74:	1885883a 	add	r2,r3,r2
8113ea78:	10800384 	addi	r2,r2,14
8113ea7c:	1007883a 	mov	r3,r2
8113ea80:	e0bfff17 	ldw	r2,-4(fp)
8113ea84:	1080030b 	ldhu	r2,12(r2)
8113ea88:	10bfffcc 	andi	r2,r2,65535
8113ea8c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
8113ea90:	d0a0af17 	ldw	r2,-32068(gp)
8113ea94:	10c00a17 	ldw	r3,40(r2)
8113ea98:	e0bffe17 	ldw	r2,-8(fp)
8113ea9c:	1885883a 	add	r2,r3,r2
8113eaa0:	10800404 	addi	r2,r2,16
8113eaa4:	1007883a 	mov	r3,r2
8113eaa8:	e0bfff17 	ldw	r2,-4(fp)
8113eaac:	1080038b 	ldhu	r2,14(r2)
8113eab0:	10bfffcc 	andi	r2,r2,65535
8113eab4:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
8113eab8:	d0a0af17 	ldw	r2,-32068(gp)
8113eabc:	10c00a17 	ldw	r3,40(r2)
8113eac0:	e0bffe17 	ldw	r2,-8(fp)
8113eac4:	1885883a 	add	r2,r3,r2
8113eac8:	10800484 	addi	r2,r2,18
8113eacc:	1007883a 	mov	r3,r2
8113ead0:	e0bfff17 	ldw	r2,-4(fp)
8113ead4:	1080040b 	ldhu	r2,16(r2)
8113ead8:	10bfffcc 	andi	r2,r2,65535
8113eadc:	1880002d 	sthio	r2,0(r3)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
8113eae0:	d0a0af17 	ldw	r2,-32068(gp)
8113eae4:	10c00a17 	ldw	r3,40(r2)
8113eae8:	e0bffe17 	ldw	r2,-8(fp)
8113eaec:	1885883a 	add	r2,r3,r2
8113eaf0:	10800584 	addi	r2,r2,22
8113eaf4:	1007883a 	mov	r3,r2
8113eaf8:	e0bfff17 	ldw	r2,-4(fp)
8113eafc:	1080048b 	ldhu	r2,18(r2)
8113eb00:	10bfffcc 	andi	r2,r2,65535
8113eb04:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
8113eb08:	d0a0af17 	ldw	r2,-32068(gp)
8113eb0c:	10c00a17 	ldw	r3,40(r2)
8113eb10:	e0bffe17 	ldw	r2,-8(fp)
8113eb14:	1885883a 	add	r2,r3,r2
8113eb18:	10800604 	addi	r2,r2,24
8113eb1c:	1007883a 	mov	r3,r2
8113eb20:	e0bfff17 	ldw	r2,-4(fp)
8113eb24:	1080050b 	ldhu	r2,20(r2)
8113eb28:	10bfffcc 	andi	r2,r2,65535
8113eb2c:	1880002d 	sthio	r2,0(r3)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
8113eb30:	d0a0af17 	ldw	r2,-32068(gp)
8113eb34:	10c00a17 	ldw	r3,40(r2)
8113eb38:	e0bffe17 	ldw	r2,-8(fp)
8113eb3c:	1885883a 	add	r2,r3,r2
8113eb40:	10800684 	addi	r2,r2,26
8113eb44:	1007883a 	mov	r3,r2
8113eb48:	e0bfff17 	ldw	r2,-4(fp)
8113eb4c:	1080058b 	ldhu	r2,22(r2)
8113eb50:	10bfffcc 	andi	r2,r2,65535
8113eb54:	1880002d 	sthio	r2,0(r3)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
8113eb58:	d0a0af17 	ldw	r2,-32068(gp)
8113eb5c:	10c00a17 	ldw	r3,40(r2)
8113eb60:	e0bffe17 	ldw	r2,-8(fp)
8113eb64:	1885883a 	add	r2,r3,r2
8113eb68:	10800704 	addi	r2,r2,28
8113eb6c:	1007883a 	mov	r3,r2
8113eb70:	e0bfff17 	ldw	r2,-4(fp)
8113eb74:	10800617 	ldw	r2,24(r2)
8113eb78:	18800035 	stwio	r2,0(r3)
        current_sector_modified = true;                  
8113eb7c:	00800044 	movi	r2,1
8113eb80:	d0a0b015 	stw	r2,-32064(gp)
        result = true;
8113eb84:	00800044 	movi	r2,1
8113eb88:	e0bffb15 	stw	r2,-20(fp)
    }
    return result;
8113eb8c:	e0bffb17 	ldw	r2,-20(fp)
}
8113eb90:	e037883a 	mov	sp,fp
8113eb94:	dfc00117 	ldw	ra,4(sp)
8113eb98:	df000017 	ldw	fp,0(sp)
8113eb9c:	dec00204 	addi	sp,sp,8
8113eba0:	f800283a 	ret

8113eba4 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
8113eba4:	defff904 	addi	sp,sp,-28
8113eba8:	de00012e 	bgeu	sp,et,8113ebb0 <Check_for_DOS_FAT+0xc>
8113ebac:	003b68fa 	trap	3
8113ebb0:	dfc00615 	stw	ra,24(sp)
8113ebb4:	df000515 	stw	fp,20(sp)
8113ebb8:	df000504 	addi	fp,sp,20
8113ebbc:	e13fff15 	stw	r4,-4(fp)
	bool result = false;
8113ebc0:	e03ffb15 	stw	zero,-20(fp)
	int counter = 0;
8113ebc4:	e03ffc15 	stw	zero,-16(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
8113ebc8:	e17fff17 	ldw	r5,-4(fp)
8113ebcc:	0009883a 	mov	r4,zero
8113ebd0:	113e25c0 	call	8113e25c <Read_Sector_Data>
8113ebd4:	e0bffb15 	stw	r2,-20(fp)
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
8113ebd8:	d0a0af17 	ldw	r2,-32068(gp)
8113ebdc:	10800a17 	ldw	r2,40(r2)
8113ebe0:	10807f84 	addi	r2,r2,510
8113ebe4:	1080002b 	ldhuio	r2,0(r2)
8113ebe8:	10bfffcc 	andi	r2,r2,65535
8113ebec:	e0bffe0d 	sth	r2,-8(fp)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
8113ebf0:	e0bffe0f 	ldh	r2,-8(fp)
8113ebf4:	10ffffcc 	andi	r3,r2,65535
8113ebf8:	00aa9554 	movui	r2,43605
8113ebfc:	1881841e 	bne	r3,r2,8113f210 <Check_for_DOS_FAT+0x66c>
8113ec00:	e0bffb17 	ldw	r2,-20(fp)
8113ec04:	10018226 	beq	r2,zero,8113f210 <Check_for_DOS_FAT+0x66c>
	{
		int num_clusters = 0;
8113ec08:	e03ffd15 	stw	zero,-12(fp)

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
8113ec0c:	d0a0af17 	ldw	r2,-32068(gp)
8113ec10:	10800a17 	ldw	r2,40(r2)
8113ec14:	10800023 	ldbuio	r2,0(r2)
8113ec18:	10803fcc 	andi	r2,r2,255
8113ec1c:	1007883a 	mov	r3,r2
8113ec20:	00a045f4 	movhi	r2,33047
8113ec24:	10a13004 	addi	r2,r2,-31552
8113ec28:	10c00005 	stb	r3,0(r2)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
8113ec2c:	d0a0af17 	ldw	r2,-32068(gp)
8113ec30:	10800a17 	ldw	r2,40(r2)
8113ec34:	10800044 	addi	r2,r2,1
8113ec38:	10800023 	ldbuio	r2,0(r2)
8113ec3c:	10803fcc 	andi	r2,r2,255
8113ec40:	1007883a 	mov	r3,r2
8113ec44:	00a045f4 	movhi	r2,33047
8113ec48:	10a13004 	addi	r2,r2,-31552
8113ec4c:	10c00045 	stb	r3,1(r2)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
8113ec50:	d0a0af17 	ldw	r2,-32068(gp)
8113ec54:	10800a17 	ldw	r2,40(r2)
8113ec58:	10800084 	addi	r2,r2,2
8113ec5c:	10800023 	ldbuio	r2,0(r2)
8113ec60:	10803fcc 	andi	r2,r2,255
8113ec64:	1007883a 	mov	r3,r2
8113ec68:	00a045f4 	movhi	r2,33047
8113ec6c:	10a13004 	addi	r2,r2,-31552
8113ec70:	10c00085 	stb	r3,2(r2)
		for (counter = 0; counter < 8; counter++)
8113ec74:	e03ffc15 	stw	zero,-16(fp)
8113ec78:	00001106 	br	8113ecc0 <Check_for_DOS_FAT+0x11c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
8113ec7c:	d0a0af17 	ldw	r2,-32068(gp)
8113ec80:	10c00a17 	ldw	r3,40(r2)
8113ec84:	e0bffc17 	ldw	r2,-16(fp)
8113ec88:	1885883a 	add	r2,r3,r2
8113ec8c:	108000c4 	addi	r2,r2,3
8113ec90:	10800023 	ldbuio	r2,0(r2)
8113ec94:	10803fcc 	andi	r2,r2,255
8113ec98:	1009883a 	mov	r4,r2
8113ec9c:	00a045f4 	movhi	r2,33047
8113eca0:	10a13004 	addi	r2,r2,-31552
8113eca4:	e0fffc17 	ldw	r3,-16(fp)
8113eca8:	10c5883a 	add	r2,r2,r3
8113ecac:	108000c4 	addi	r2,r2,3
8113ecb0:	11000005 	stb	r4,0(r2)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
8113ecb4:	e0bffc17 	ldw	r2,-16(fp)
8113ecb8:	10800044 	addi	r2,r2,1
8113ecbc:	e0bffc15 	stw	r2,-16(fp)
8113ecc0:	e0bffc17 	ldw	r2,-16(fp)
8113ecc4:	10800210 	cmplti	r2,r2,8
8113ecc8:	103fec1e 	bne	r2,zero,8113ec7c <__reset+0xfb11ec7c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
8113eccc:	d0a0af17 	ldw	r2,-32068(gp)
8113ecd0:	10800a17 	ldw	r2,40(r2)
8113ecd4:	10800304 	addi	r2,r2,12
8113ecd8:	10800023 	ldbuio	r2,0(r2)
8113ecdc:	10803fcc 	andi	r2,r2,255
8113ece0:	1004923a 	slli	r2,r2,8
8113ece4:	1007883a 	mov	r3,r2
8113ece8:	d0a0af17 	ldw	r2,-32068(gp)
8113ecec:	10800a17 	ldw	r2,40(r2)
8113ecf0:	108002c4 	addi	r2,r2,11
8113ecf4:	10800023 	ldbuio	r2,0(r2)
8113ecf8:	10803fcc 	andi	r2,r2,255
8113ecfc:	10803fcc 	andi	r2,r2,255
8113ed00:	1080201c 	xori	r2,r2,128
8113ed04:	10bfe004 	addi	r2,r2,-128
8113ed08:	1884b03a 	or	r2,r3,r2
8113ed0c:	1007883a 	mov	r3,r2
8113ed10:	00a045f4 	movhi	r2,33047
8113ed14:	10a13004 	addi	r2,r2,-31552
8113ed18:	10c0030d 	sth	r3,12(r2)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
8113ed1c:	d0a0af17 	ldw	r2,-32068(gp)
8113ed20:	10800a17 	ldw	r2,40(r2)
8113ed24:	10800344 	addi	r2,r2,13
8113ed28:	10800023 	ldbuio	r2,0(r2)
8113ed2c:	10803fcc 	andi	r2,r2,255
8113ed30:	1007883a 	mov	r3,r2
8113ed34:	00a045f4 	movhi	r2,33047
8113ed38:	10a13004 	addi	r2,r2,-31552
8113ed3c:	10c00385 	stb	r3,14(r2)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
8113ed40:	d0a0af17 	ldw	r2,-32068(gp)
8113ed44:	10800a17 	ldw	r2,40(r2)
8113ed48:	10800384 	addi	r2,r2,14
8113ed4c:	1080002b 	ldhuio	r2,0(r2)
8113ed50:	10bfffcc 	andi	r2,r2,65535
8113ed54:	1007883a 	mov	r3,r2
8113ed58:	00a045f4 	movhi	r2,33047
8113ed5c:	10a13004 	addi	r2,r2,-31552
8113ed60:	10c0040d 	sth	r3,16(r2)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
8113ed64:	d0a0af17 	ldw	r2,-32068(gp)
8113ed68:	10800a17 	ldw	r2,40(r2)
8113ed6c:	10800404 	addi	r2,r2,16
8113ed70:	10800023 	ldbuio	r2,0(r2)
8113ed74:	10803fcc 	andi	r2,r2,255
8113ed78:	1007883a 	mov	r3,r2
8113ed7c:	00a045f4 	movhi	r2,33047
8113ed80:	10a13004 	addi	r2,r2,-31552
8113ed84:	10c00485 	stb	r3,18(r2)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
8113ed88:	d0a0af17 	ldw	r2,-32068(gp)
8113ed8c:	10800a17 	ldw	r2,40(r2)
8113ed90:	10800484 	addi	r2,r2,18
8113ed94:	10800023 	ldbuio	r2,0(r2)
8113ed98:	10803fcc 	andi	r2,r2,255
8113ed9c:	1004923a 	slli	r2,r2,8
8113eda0:	1007883a 	mov	r3,r2
8113eda4:	d0a0af17 	ldw	r2,-32068(gp)
8113eda8:	10800a17 	ldw	r2,40(r2)
8113edac:	10800444 	addi	r2,r2,17
8113edb0:	10800023 	ldbuio	r2,0(r2)
8113edb4:	10803fcc 	andi	r2,r2,255
8113edb8:	10803fcc 	andi	r2,r2,255
8113edbc:	1884b03a 	or	r2,r3,r2
8113edc0:	1007883a 	mov	r3,r2
8113edc4:	00a045f4 	movhi	r2,33047
8113edc8:	10a13004 	addi	r2,r2,-31552
8113edcc:	10c0050d 	sth	r3,20(r2)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
8113edd0:	d0a0af17 	ldw	r2,-32068(gp)
8113edd4:	10800a17 	ldw	r2,40(r2)
8113edd8:	10800504 	addi	r2,r2,20
8113eddc:	10800023 	ldbuio	r2,0(r2)
8113ede0:	10803fcc 	andi	r2,r2,255
8113ede4:	1004923a 	slli	r2,r2,8
8113ede8:	1007883a 	mov	r3,r2
8113edec:	d0a0af17 	ldw	r2,-32068(gp)
8113edf0:	10800a17 	ldw	r2,40(r2)
8113edf4:	108004c4 	addi	r2,r2,19
8113edf8:	10800023 	ldbuio	r2,0(r2)
8113edfc:	10803fcc 	andi	r2,r2,255
8113ee00:	10803fcc 	andi	r2,r2,255
8113ee04:	1884b03a 	or	r2,r3,r2
8113ee08:	1007883a 	mov	r3,r2
8113ee0c:	00a045f4 	movhi	r2,33047
8113ee10:	10a13004 	addi	r2,r2,-31552
8113ee14:	10c0058d 	sth	r3,22(r2)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
8113ee18:	d0a0af17 	ldw	r2,-32068(gp)
8113ee1c:	10800a17 	ldw	r2,40(r2)
8113ee20:	10800544 	addi	r2,r2,21
8113ee24:	10800023 	ldbuio	r2,0(r2)
8113ee28:	10803fcc 	andi	r2,r2,255
8113ee2c:	1007883a 	mov	r3,r2
8113ee30:	00a045f4 	movhi	r2,33047
8113ee34:	10a13004 	addi	r2,r2,-31552
8113ee38:	10c00605 	stb	r3,24(r2)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
8113ee3c:	d0a0af17 	ldw	r2,-32068(gp)
8113ee40:	10800a17 	ldw	r2,40(r2)
8113ee44:	10800584 	addi	r2,r2,22
8113ee48:	1080002b 	ldhuio	r2,0(r2)
8113ee4c:	10bfffcc 	andi	r2,r2,65535
8113ee50:	1007883a 	mov	r3,r2
8113ee54:	00a045f4 	movhi	r2,33047
8113ee58:	10a13004 	addi	r2,r2,-31552
8113ee5c:	10c0068d 	sth	r3,26(r2)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
8113ee60:	d0a0af17 	ldw	r2,-32068(gp)
8113ee64:	10800a17 	ldw	r2,40(r2)
8113ee68:	10800604 	addi	r2,r2,24
8113ee6c:	1080002b 	ldhuio	r2,0(r2)
8113ee70:	10bfffcc 	andi	r2,r2,65535
8113ee74:	1007883a 	mov	r3,r2
8113ee78:	00a045f4 	movhi	r2,33047
8113ee7c:	10a13004 	addi	r2,r2,-31552
8113ee80:	10c0070d 	sth	r3,28(r2)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
8113ee84:	d0a0af17 	ldw	r2,-32068(gp)
8113ee88:	10800a17 	ldw	r2,40(r2)
8113ee8c:	10800684 	addi	r2,r2,26
8113ee90:	1080002b 	ldhuio	r2,0(r2)
8113ee94:	10bfffcc 	andi	r2,r2,65535
8113ee98:	1007883a 	mov	r3,r2
8113ee9c:	00a045f4 	movhi	r2,33047
8113eea0:	10a13004 	addi	r2,r2,-31552
8113eea4:	10c0078d 	sth	r3,30(r2)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
8113eea8:	d0a0af17 	ldw	r2,-32068(gp)
8113eeac:	10800a17 	ldw	r2,40(r2)
8113eeb0:	10800704 	addi	r2,r2,28
8113eeb4:	10800037 	ldwio	r2,0(r2)
8113eeb8:	1007883a 	mov	r3,r2
8113eebc:	00a045f4 	movhi	r2,33047
8113eec0:	10a13004 	addi	r2,r2,-31552
8113eec4:	10c00815 	stw	r3,32(r2)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
8113eec8:	d0a0af17 	ldw	r2,-32068(gp)
8113eecc:	10800a17 	ldw	r2,40(r2)
8113eed0:	10800804 	addi	r2,r2,32
8113eed4:	10800037 	ldwio	r2,0(r2)
8113eed8:	1007883a 	mov	r3,r2
8113eedc:	00a045f4 	movhi	r2,33047
8113eee0:	10a13004 	addi	r2,r2,-31552
8113eee4:	10c00915 	stw	r3,36(r2)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
8113eee8:	d0a0af17 	ldw	r2,-32068(gp)
8113eeec:	10800a17 	ldw	r2,40(r2)
8113eef0:	10800904 	addi	r2,r2,36
8113eef4:	10800023 	ldbuio	r2,0(r2)
8113eef8:	10803fcc 	andi	r2,r2,255
8113eefc:	1007883a 	mov	r3,r2
8113ef00:	00a045f4 	movhi	r2,33047
8113ef04:	10a13004 	addi	r2,r2,-31552
8113ef08:	10c00a05 	stb	r3,40(r2)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
8113ef0c:	d0a0af17 	ldw	r2,-32068(gp)
8113ef10:	10800a17 	ldw	r2,40(r2)
8113ef14:	10800944 	addi	r2,r2,37
8113ef18:	10800023 	ldbuio	r2,0(r2)
8113ef1c:	10803fcc 	andi	r2,r2,255
8113ef20:	1007883a 	mov	r3,r2
8113ef24:	00a045f4 	movhi	r2,33047
8113ef28:	10a13004 	addi	r2,r2,-31552
8113ef2c:	10c00a45 	stb	r3,41(r2)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
8113ef30:	d0a0af17 	ldw	r2,-32068(gp)
8113ef34:	10800a17 	ldw	r2,40(r2)
8113ef38:	10800984 	addi	r2,r2,38
8113ef3c:	10800023 	ldbuio	r2,0(r2)
8113ef40:	10803fcc 	andi	r2,r2,255
8113ef44:	1007883a 	mov	r3,r2
8113ef48:	00a045f4 	movhi	r2,33047
8113ef4c:	10a13004 	addi	r2,r2,-31552
8113ef50:	10c00a85 	stb	r3,42(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
8113ef54:	00a045f4 	movhi	r2,33047
8113ef58:	10a13004 	addi	r2,r2,-31552
8113ef5c:	1080040b 	ldhu	r2,16(r2)
8113ef60:	10ffffcc 	andi	r3,r2,65535
8113ef64:	00a045f4 	movhi	r2,33047
8113ef68:	10a13004 	addi	r2,r2,-31552
8113ef6c:	10c01115 	stw	r3,68(r2)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
8113ef70:	00a045f4 	movhi	r2,33047
8113ef74:	10a13004 	addi	r2,r2,-31552
8113ef78:	10c01117 	ldw	r3,68(r2)
8113ef7c:	00a045f4 	movhi	r2,33047
8113ef80:	10a13004 	addi	r2,r2,-31552
8113ef84:	1080068b 	ldhu	r2,26(r2)
8113ef88:	10bfffcc 	andi	r2,r2,65535
8113ef8c:	1887883a 	add	r3,r3,r2
8113ef90:	00a045f4 	movhi	r2,33047
8113ef94:	10a13004 	addi	r2,r2,-31552
8113ef98:	10c01215 	stw	r3,72(r2)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
8113ef9c:	00a045f4 	movhi	r2,33047
8113efa0:	10a13004 	addi	r2,r2,-31552
8113efa4:	10c01217 	ldw	r3,72(r2)
8113efa8:	00a045f4 	movhi	r2,33047
8113efac:	10a13004 	addi	r2,r2,-31552
8113efb0:	1080068b 	ldhu	r2,26(r2)
8113efb4:	10bfffcc 	andi	r2,r2,65535
8113efb8:	1887883a 	add	r3,r3,r2
8113efbc:	00a045f4 	movhi	r2,33047
8113efc0:	10a13004 	addi	r2,r2,-31552
8113efc4:	10c01315 	stw	r3,76(r2)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
8113efc8:	00a045f4 	movhi	r2,33047
8113efcc:	10a13004 	addi	r2,r2,-31552
8113efd0:	10c01317 	ldw	r3,76(r2)
8113efd4:	00a045f4 	movhi	r2,33047
8113efd8:	10a13004 	addi	r2,r2,-31552
8113efdc:	1080050b 	ldhu	r2,20(r2)
8113efe0:	10bfffcc 	andi	r2,r2,65535
8113efe4:	1008917a 	slli	r4,r2,5
8113efe8:	00a045f4 	movhi	r2,33047
8113efec:	10a13004 	addi	r2,r2,-31552
8113eff0:	1080030b 	ldhu	r2,12(r2)
8113eff4:	10bfffcc 	andi	r2,r2,65535
8113eff8:	2085283a 	div	r2,r4,r2
8113effc:	1887883a 	add	r3,r3,r2
8113f000:	00a045f4 	movhi	r2,33047
8113f004:	10a13004 	addi	r2,r2,-31552
8113f008:	10c01415 	stw	r3,80(r2)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
8113f00c:	00a045f4 	movhi	r2,33047
8113f010:	10a13004 	addi	r2,r2,-31552
8113f014:	1080058b 	ldhu	r2,22(r2)
8113f018:	10bfffcc 	andi	r2,r2,65535
8113f01c:	10000b26 	beq	r2,zero,8113f04c <Check_for_DOS_FAT+0x4a8>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
8113f020:	00a045f4 	movhi	r2,33047
8113f024:	10a13004 	addi	r2,r2,-31552
8113f028:	1080058b 	ldhu	r2,22(r2)
8113f02c:	10ffffcc 	andi	r3,r2,65535
8113f030:	00a045f4 	movhi	r2,33047
8113f034:	10a13004 	addi	r2,r2,-31552
8113f038:	10800383 	ldbu	r2,14(r2)
8113f03c:	10803fcc 	andi	r2,r2,255
8113f040:	1885283a 	div	r2,r3,r2
8113f044:	e0bffd15 	stw	r2,-12(fp)
8113f048:	00000906 	br	8113f070 <Check_for_DOS_FAT+0x4cc>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
8113f04c:	00a045f4 	movhi	r2,33047
8113f050:	10a13004 	addi	r2,r2,-31552
8113f054:	10c00917 	ldw	r3,36(r2)
8113f058:	00a045f4 	movhi	r2,33047
8113f05c:	10a13004 	addi	r2,r2,-31552
8113f060:	10800383 	ldbu	r2,14(r2)
8113f064:	10803fcc 	andi	r2,r2,255
8113f068:	1885203a 	divu	r2,r3,r2
8113f06c:	e0bffd15 	stw	r2,-12(fp)
		}
		if (num_clusters < 4087)
8113f070:	e0bffd17 	ldw	r2,-12(fp)
8113f074:	1083fdc8 	cmpgei	r2,r2,4087
8113f078:	1000051e 	bne	r2,zero,8113f090 <Check_for_DOS_FAT+0x4ec>
		{
			boot_sector_data.bits_for_cluster_index = 12;
8113f07c:	00a045f4 	movhi	r2,33047
8113f080:	10a13004 	addi	r2,r2,-31552
8113f084:	00c00304 	movi	r3,12
8113f088:	10c01085 	stb	r3,66(r2)
8113f08c:	00000c06 	br	8113f0c0 <Check_for_DOS_FAT+0x51c>
		}
		else if (num_clusters <= 65517)
8113f090:	e0bffd17 	ldw	r2,-12(fp)
8113f094:	00fffb54 	movui	r3,65517
8113f098:	18800516 	blt	r3,r2,8113f0b0 <Check_for_DOS_FAT+0x50c>
		{
			boot_sector_data.bits_for_cluster_index = 16;
8113f09c:	00a045f4 	movhi	r2,33047
8113f0a0:	10a13004 	addi	r2,r2,-31552
8113f0a4:	00c00404 	movi	r3,16
8113f0a8:	10c01085 	stb	r3,66(r2)
8113f0ac:	00000406 	br	8113f0c0 <Check_for_DOS_FAT+0x51c>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
8113f0b0:	00a045f4 	movhi	r2,33047
8113f0b4:	10a13004 	addi	r2,r2,-31552
8113f0b8:	00c00804 	movi	r3,32
8113f0bc:	10c01085 	stb	r3,66(r2)
		}
	    
		for (counter = 0; counter < 4; counter++)
8113f0c0:	e03ffc15 	stw	zero,-16(fp)
8113f0c4:	00001106 	br	8113f10c <Check_for_DOS_FAT+0x568>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
8113f0c8:	d0a0af17 	ldw	r2,-32068(gp)
8113f0cc:	10c00a17 	ldw	r3,40(r2)
8113f0d0:	e0bffc17 	ldw	r2,-16(fp)
8113f0d4:	1885883a 	add	r2,r3,r2
8113f0d8:	108009c4 	addi	r2,r2,39
8113f0dc:	10800023 	ldbuio	r2,0(r2)
8113f0e0:	10803fcc 	andi	r2,r2,255
8113f0e4:	1009883a 	mov	r4,r2
8113f0e8:	00a045f4 	movhi	r2,33047
8113f0ec:	10a13004 	addi	r2,r2,-31552
8113f0f0:	e0fffc17 	ldw	r3,-16(fp)
8113f0f4:	10c5883a 	add	r2,r2,r3
8113f0f8:	10800ac4 	addi	r2,r2,43
8113f0fc:	11000005 	stb	r4,0(r2)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
8113f100:	e0bffc17 	ldw	r2,-16(fp)
8113f104:	10800044 	addi	r2,r2,1
8113f108:	e0bffc15 	stw	r2,-16(fp)
8113f10c:	e0bffc17 	ldw	r2,-16(fp)
8113f110:	10800110 	cmplti	r2,r2,4
8113f114:	103fec1e 	bne	r2,zero,8113f0c8 <__reset+0xfb11f0c8>
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113f118:	e03ffc15 	stw	zero,-16(fp)
8113f11c:	00001106 	br	8113f164 <Check_for_DOS_FAT+0x5c0>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
8113f120:	d0a0af17 	ldw	r2,-32068(gp)
8113f124:	10c00a17 	ldw	r3,40(r2)
8113f128:	e0bffc17 	ldw	r2,-16(fp)
8113f12c:	1885883a 	add	r2,r3,r2
8113f130:	10800ac4 	addi	r2,r2,43
8113f134:	10800023 	ldbuio	r2,0(r2)
8113f138:	10803fcc 	andi	r2,r2,255
8113f13c:	1009883a 	mov	r4,r2
8113f140:	00a045f4 	movhi	r2,33047
8113f144:	10a13004 	addi	r2,r2,-31552
8113f148:	e0fffc17 	ldw	r3,-16(fp)
8113f14c:	10c5883a 	add	r2,r2,r3
8113f150:	10800bc4 	addi	r2,r2,47
8113f154:	11000005 	stb	r4,0(r2)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
8113f158:	e0bffc17 	ldw	r2,-16(fp)
8113f15c:	10800044 	addi	r2,r2,1
8113f160:	e0bffc15 	stw	r2,-16(fp)
8113f164:	e0bffc17 	ldw	r2,-16(fp)
8113f168:	108002d0 	cmplti	r2,r2,11
8113f16c:	103fec1e 	bne	r2,zero,8113f120 <__reset+0xfb11f120>
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113f170:	e03ffc15 	stw	zero,-16(fp)
8113f174:	00001106 	br	8113f1bc <Check_for_DOS_FAT+0x618>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
8113f178:	d0a0af17 	ldw	r2,-32068(gp)
8113f17c:	10c00a17 	ldw	r3,40(r2)
8113f180:	e0bffc17 	ldw	r2,-16(fp)
8113f184:	1885883a 	add	r2,r3,r2
8113f188:	10800d84 	addi	r2,r2,54
8113f18c:	10800023 	ldbuio	r2,0(r2)
8113f190:	10803fcc 	andi	r2,r2,255
8113f194:	1009883a 	mov	r4,r2
8113f198:	00a045f4 	movhi	r2,33047
8113f19c:	10a13004 	addi	r2,r2,-31552
8113f1a0:	e0fffc17 	ldw	r3,-16(fp)
8113f1a4:	10c5883a 	add	r2,r2,r3
8113f1a8:	10800e84 	addi	r2,r2,58
8113f1ac:	11000005 	stb	r4,0(r2)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
8113f1b0:	e0bffc17 	ldw	r2,-16(fp)
8113f1b4:	10800044 	addi	r2,r2,1
8113f1b8:	e0bffc15 	stw	r2,-16(fp)
8113f1bc:	e0bffc17 	ldw	r2,-16(fp)
8113f1c0:	10800210 	cmplti	r2,r2,8
8113f1c4:	103fec1e 	bne	r2,zero,8113f178 <__reset+0xfb11f178>
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113f1c8:	e03ffc15 	stw	zero,-16(fp)
8113f1cc:	00000a06 	br	8113f1f8 <Check_for_DOS_FAT+0x654>
		{
			active_files[counter].in_use = false;
8113f1d0:	00a045f4 	movhi	r2,33047
8113f1d4:	10a14504 	addi	r2,r2,-31468
8113f1d8:	e0fffc17 	ldw	r3,-16(fp)
8113f1dc:	180691ba 	slli	r3,r3,6
8113f1e0:	10c5883a 	add	r2,r2,r3
8113f1e4:	10800f04 	addi	r2,r2,60
8113f1e8:	10000015 	stw	zero,0(r2)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
8113f1ec:	e0bffc17 	ldw	r2,-16(fp)
8113f1f0:	10800044 	addi	r2,r2,1
8113f1f4:	e0bffc15 	stw	r2,-16(fp)
8113f1f8:	e0bffc17 	ldw	r2,-16(fp)
8113f1fc:	10800510 	cmplti	r2,r2,20
8113f200:	103ff31e 	bne	r2,zero,8113f1d0 <__reset+0xfb11f1d0>
		{
			active_files[counter].in_use = false;
		}
		result = true;
8113f204:	00800044 	movi	r2,1
8113f208:	e0bffb15 	stw	r2,-20(fp)
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
	{
8113f20c:	00000106 	br	8113f214 <Check_for_DOS_FAT+0x670>
		}
		result = true;
	}
    else
    {
        result = false;
8113f210:	e03ffb15 	stw	zero,-20(fp)
    }
	return result;
8113f214:	e0bffb17 	ldw	r2,-20(fp)
}
8113f218:	e037883a 	mov	sp,fp
8113f21c:	dfc00117 	ldw	ra,4(sp)
8113f220:	df000017 	ldw	fp,0(sp)
8113f224:	dec00204 	addi	sp,sp,8
8113f228:	f800283a 	ret

8113f22c <Look_for_FAT16>:


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
8113f22c:	defffc04 	addi	sp,sp,-16
8113f230:	de00012e 	bgeu	sp,et,8113f238 <Look_for_FAT16+0xc>
8113f234:	003b68fa 	trap	3
8113f238:	dfc00315 	stw	ra,12(sp)
8113f23c:	df000215 	stw	fp,8(sp)
8113f240:	df000204 	addi	fp,sp,8
	bool result = false;
8113f244:	e03ffe15 	stw	zero,-8(fp)

	if (alt_up_sd_card_is_Present())
8113f248:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
8113f24c:	10002e26 	beq	r2,zero,8113f308 <Look_for_FAT16+0xdc>
	{
		short int csd_file_format = *CSD_register_w0;
8113f250:	d0a0a917 	ldw	r2,-32092(gp)
8113f254:	1080000b 	ldhu	r2,0(r2)
8113f258:	e0bfff0d 	sth	r2,-4(fp)
        
		fat_partition_offset_in_512_byte_sectors = 0;
8113f25c:	d020ad15 	stw	zero,-32076(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
8113f260:	d020ae15 	stw	zero,-32072(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
8113f264:	e0bfff0f 	ldh	r2,-4(fp)
8113f268:	10002716 	blt	r2,zero,8113f308 <Look_for_FAT16+0xdc>
8113f26c:	e0bfff0b 	ldhu	r2,-4(fp)
8113f270:	10bfffcc 	andi	r2,r2,65535
8113f274:	1083000c 	andi	r2,r2,3072
8113f278:	10830020 	cmpeqi	r2,r2,3072
8113f27c:	1000221e 	bne	r2,zero,8113f308 <Look_for_FAT16+0xdc>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
8113f280:	e0bfff0b 	ldhu	r2,-4(fp)
8113f284:	10bfffcc 	andi	r2,r2,65535
8113f288:	1083000c 	andi	r2,r2,3072
8113f28c:	10810018 	cmpnei	r2,r2,1024
8113f290:	1000031e 	bne	r2,zero,8113f2a0 <Look_for_FAT16+0x74>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
8113f294:	0009883a 	mov	r4,zero
8113f298:	113eba40 	call	8113eba4 <Check_for_DOS_FAT>
8113f29c:	e0bffe15 	stw	r2,-8(fp)
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
8113f2a0:	e0bfff0b 	ldhu	r2,-4(fp)
8113f2a4:	10bfffcc 	andi	r2,r2,65535
8113f2a8:	1083000c 	andi	r2,r2,3072
8113f2ac:	1000061e 	bne	r2,zero,8113f2c8 <Look_for_FAT16+0x9c>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
8113f2b0:	113e4e00 	call	8113e4e0 <Check_for_Master_Boot_Record>
8113f2b4:	10000426 	beq	r2,zero,8113f2c8 <Look_for_FAT16+0x9c>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
8113f2b8:	d0a0ad17 	ldw	r2,-32076(gp)
8113f2bc:	1009883a 	mov	r4,r2
8113f2c0:	113eba40 	call	8113eba4 <Check_for_DOS_FAT>
8113f2c4:	e0bffe15 	stw	r2,-8(fp)
				}                        
			}
			if (result == true)
8113f2c8:	e0bffe17 	ldw	r2,-8(fp)
8113f2cc:	10800058 	cmpnei	r2,r2,1
8113f2d0:	10000d1e 	bne	r2,zero,8113f308 <Look_for_FAT16+0xdc>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
8113f2d4:	00a045f4 	movhi	r2,33047
8113f2d8:	10a13004 	addi	r2,r2,-31552
8113f2dc:	10801083 	ldbu	r2,66(r2)
8113f2e0:	10803fcc 	andi	r2,r2,255
8113f2e4:	10800420 	cmpeqi	r2,r2,16
8113f2e8:	1000021e 	bne	r2,zero,8113f2f4 <Look_for_FAT16+0xc8>
				{
					result = false;
8113f2ec:	e03ffe15 	stw	zero,-8(fp)
8113f2f0:	00000506 	br	8113f308 <Look_for_FAT16+0xdc>
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
8113f2f4:	00a045f4 	movhi	r2,33047
8113f2f8:	10a13004 	addi	r2,r2,-31552
8113f2fc:	1080058b 	ldhu	r2,22(r2)
8113f300:	10bfffcc 	andi	r2,r2,65535
8113f304:	d0a0ae15 	stw	r2,-32072(gp)
				}
			}
		}
	}
	return result;
8113f308:	e0bffe17 	ldw	r2,-8(fp)
}
8113f30c:	e037883a 	mov	sp,fp
8113f310:	dfc00117 	ldw	ra,4(sp)
8113f314:	df000017 	ldw	fp,0(sp)
8113f318:	dec00204 	addi	sp,sp,8
8113f31c:	f800283a 	ret

8113f320 <filename_to_upper_case>:
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
8113f320:	defffb04 	addi	sp,sp,-20
8113f324:	de00012e 	bgeu	sp,et,8113f32c <filename_to_upper_case+0xc>
8113f328:	003b68fa 	trap	3
8113f32c:	dfc00415 	stw	ra,16(sp)
8113f330:	df000315 	stw	fp,12(sp)
8113f334:	df000304 	addi	fp,sp,12
8113f338:	e13fff15 	stw	r4,-4(fp)
    int index;
    int length = strlen(file_name);
8113f33c:	e13fff17 	ldw	r4,-4(fp)
8113f340:	111e5bc0 	call	8111e5bc <strlen>
8113f344:	e0bffe15 	stw	r2,-8(fp)
    
    for (index = 0; index < length; index++)
8113f348:	e03ffd15 	stw	zero,-12(fp)
8113f34c:	00001e06 	br	8113f3c8 <filename_to_upper_case+0xa8>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
8113f350:	e0bffd17 	ldw	r2,-12(fp)
8113f354:	e0ffff17 	ldw	r3,-4(fp)
8113f358:	1885883a 	add	r2,r3,r2
8113f35c:	10800003 	ldbu	r2,0(r2)
8113f360:	10803fcc 	andi	r2,r2,255
8113f364:	1080201c 	xori	r2,r2,128
8113f368:	10bfe004 	addi	r2,r2,-128
8113f36c:	10801850 	cmplti	r2,r2,97
8113f370:	1000121e 	bne	r2,zero,8113f3bc <filename_to_upper_case+0x9c>
8113f374:	e0bffd17 	ldw	r2,-12(fp)
8113f378:	e0ffff17 	ldw	r3,-4(fp)
8113f37c:	1885883a 	add	r2,r3,r2
8113f380:	10800003 	ldbu	r2,0(r2)
8113f384:	10803fcc 	andi	r2,r2,255
8113f388:	1080201c 	xori	r2,r2,128
8113f38c:	10bfe004 	addi	r2,r2,-128
8113f390:	10801ec8 	cmpgei	r2,r2,123
8113f394:	1000091e 	bne	r2,zero,8113f3bc <filename_to_upper_case+0x9c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
8113f398:	e0bffd17 	ldw	r2,-12(fp)
8113f39c:	e0ffff17 	ldw	r3,-4(fp)
8113f3a0:	1885883a 	add	r2,r3,r2
8113f3a4:	e0fffd17 	ldw	r3,-12(fp)
8113f3a8:	e13fff17 	ldw	r4,-4(fp)
8113f3ac:	20c7883a 	add	r3,r4,r3
8113f3b0:	18c00003 	ldbu	r3,0(r3)
8113f3b4:	18fff804 	addi	r3,r3,-32
8113f3b8:	10c00005 	stb	r3,0(r2)
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
8113f3bc:	e0bffd17 	ldw	r2,-12(fp)
8113f3c0:	10800044 	addi	r2,r2,1
8113f3c4:	e0bffd15 	stw	r2,-12(fp)
8113f3c8:	e0fffd17 	ldw	r3,-12(fp)
8113f3cc:	e0bffe17 	ldw	r2,-8(fp)
8113f3d0:	18bfdf16 	blt	r3,r2,8113f350 <__reset+0xfb11f350>
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
        }
    }
}
8113f3d4:	0001883a 	nop
8113f3d8:	e037883a 	mov	sp,fp
8113f3dc:	dfc00117 	ldw	ra,4(sp)
8113f3e0:	df000017 	ldw	fp,0(sp)
8113f3e4:	dec00204 	addi	sp,sp,8
8113f3e8:	f800283a 	ret

8113f3ec <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
8113f3ec:	defff804 	addi	sp,sp,-32
8113f3f0:	de00012e 	bgeu	sp,et,8113f3f8 <check_file_name_for_FAT16_compliance+0xc>
8113f3f4:	003b68fa 	trap	3
8113f3f8:	dfc00715 	stw	ra,28(sp)
8113f3fc:	df000615 	stw	fp,24(sp)
8113f400:	df000604 	addi	fp,sp,24
8113f404:	e13fff15 	stw	r4,-4(fp)
    int length = strlen(file_name);
8113f408:	e13fff17 	ldw	r4,-4(fp)
8113f40c:	111e5bc0 	call	8111e5bc <strlen>
8113f410:	e0bffe15 	stw	r2,-8(fp)
    int index;
    int last_dir_break_position = -1;
8113f414:	00bfffc4 	movi	r2,-1
8113f418:	e0bffb15 	stw	r2,-20(fp)
    int last_period = -1;
8113f41c:	00bfffc4 	movi	r2,-1
8113f420:	e0bffc15 	stw	r2,-16(fp)
    bool result = true;
8113f424:	00800044 	movi	r2,1
8113f428:	e0bffd15 	stw	r2,-12(fp)
    
    for(index = 0; index < length; index++)
8113f42c:	e03ffa15 	stw	zero,-24(fp)
8113f430:	00006d06 	br	8113f5e8 <check_file_name_for_FAT16_compliance+0x1fc>
    {
        if ((file_name[index] == ' ') ||
8113f434:	e0bffa17 	ldw	r2,-24(fp)
8113f438:	e0ffff17 	ldw	r3,-4(fp)
8113f43c:	1885883a 	add	r2,r3,r2
8113f440:	10800003 	ldbu	r2,0(r2)
8113f444:	10803fcc 	andi	r2,r2,255
8113f448:	1080201c 	xori	r2,r2,128
8113f44c:	10bfe004 	addi	r2,r2,-128
8113f450:	10800820 	cmpeqi	r2,r2,32
8113f454:	10003e1e 	bne	r2,zero,8113f550 <check_file_name_for_FAT16_compliance+0x164>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113f458:	e0bffa17 	ldw	r2,-24(fp)
8113f45c:	10ffffc4 	addi	r3,r2,-1
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
8113f460:	e0bffb17 	ldw	r2,-20(fp)
8113f464:	1880121e 	bne	r3,r2,8113f4b0 <check_file_name_for_FAT16_compliance+0xc4>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113f468:	e0bffa17 	ldw	r2,-24(fp)
8113f46c:	e0ffff17 	ldw	r3,-4(fp)
8113f470:	1885883a 	add	r2,r3,r2
8113f474:	10800003 	ldbu	r2,0(r2)
8113f478:	10803fcc 	andi	r2,r2,255
8113f47c:	1080201c 	xori	r2,r2,128
8113f480:	10bfe004 	addi	r2,r2,-128
8113f484:	10801720 	cmpeqi	r2,r2,92
8113f488:	1000311e 	bne	r2,zero,8113f550 <check_file_name_for_FAT16_compliance+0x164>
8113f48c:	e0bffa17 	ldw	r2,-24(fp)
8113f490:	e0ffff17 	ldw	r3,-4(fp)
8113f494:	1885883a 	add	r2,r3,r2
8113f498:	10800003 	ldbu	r2,0(r2)
8113f49c:	10803fcc 	andi	r2,r2,255
8113f4a0:	1080201c 	xori	r2,r2,128
8113f4a4:	10bfe004 	addi	r2,r2,-128
8113f4a8:	10800be0 	cmpeqi	r2,r2,47
8113f4ac:	1000281e 	bne	r2,zero,8113f550 <check_file_name_for_FAT16_compliance+0x164>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113f4b0:	e0fffa17 	ldw	r3,-24(fp)
8113f4b4:	e0bffc17 	ldw	r2,-16(fp)
8113f4b8:	1885c83a 	sub	r2,r3,r2
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
8113f4bc:	10800258 	cmpnei	r2,r2,9
8113f4c0:	1000091e 	bne	r2,zero,8113f4e8 <check_file_name_for_FAT16_compliance+0xfc>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
8113f4c4:	e0bffa17 	ldw	r2,-24(fp)
8113f4c8:	e0ffff17 	ldw	r3,-4(fp)
8113f4cc:	1885883a 	add	r2,r3,r2
8113f4d0:	10800003 	ldbu	r2,0(r2)
8113f4d4:	10803fcc 	andi	r2,r2,255
8113f4d8:	1080201c 	xori	r2,r2,128
8113f4dc:	10bfe004 	addi	r2,r2,-128
8113f4e0:	10800b98 	cmpnei	r2,r2,46
8113f4e4:	10001a1e 	bne	r2,zero,8113f550 <check_file_name_for_FAT16_compliance+0x164>
8113f4e8:	e0fffb17 	ldw	r3,-20(fp)
8113f4ec:	e0bffc17 	ldw	r2,-16(fp)
8113f4f0:	18801926 	beq	r3,r2,8113f558 <check_file_name_for_FAT16_compliance+0x16c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113f4f4:	e0fffa17 	ldw	r3,-24(fp)
8113f4f8:	e0bffc17 	ldw	r2,-16(fp)
8113f4fc:	1885c83a 	sub	r2,r3,r2
8113f500:	10800110 	cmplti	r2,r2,4
8113f504:	1000141e 	bne	r2,zero,8113f558 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113f508:	e0bffa17 	ldw	r2,-24(fp)
8113f50c:	e0ffff17 	ldw	r3,-4(fp)
8113f510:	1885883a 	add	r2,r3,r2
8113f514:	10800003 	ldbu	r2,0(r2)
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
8113f518:	10803fcc 	andi	r2,r2,255
8113f51c:	1080201c 	xori	r2,r2,128
8113f520:	10bfe004 	addi	r2,r2,-128
8113f524:	10801720 	cmpeqi	r2,r2,92
8113f528:	10000b1e 	bne	r2,zero,8113f558 <check_file_name_for_FAT16_compliance+0x16c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
8113f52c:	e0bffa17 	ldw	r2,-24(fp)
8113f530:	e0ffff17 	ldw	r3,-4(fp)
8113f534:	1885883a 	add	r2,r3,r2
8113f538:	10800003 	ldbu	r2,0(r2)
8113f53c:	10803fcc 	andi	r2,r2,255
8113f540:	1080201c 	xori	r2,r2,128
8113f544:	10bfe004 	addi	r2,r2,-128
8113f548:	10800be0 	cmpeqi	r2,r2,47
8113f54c:	1000021e 	bne	r2,zero,8113f558 <check_file_name_for_FAT16_compliance+0x16c>
           )
        {
            result = false;
8113f550:	e03ffd15 	stw	zero,-12(fp)
            break;
8113f554:	00002706 	br	8113f5f4 <check_file_name_for_FAT16_compliance+0x208>
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
8113f558:	e0bffa17 	ldw	r2,-24(fp)
8113f55c:	e0ffff17 	ldw	r3,-4(fp)
8113f560:	1885883a 	add	r2,r3,r2
8113f564:	10800003 	ldbu	r2,0(r2)
8113f568:	10803fcc 	andi	r2,r2,255
8113f56c:	1080201c 	xori	r2,r2,128
8113f570:	10bfe004 	addi	r2,r2,-128
8113f574:	10801720 	cmpeqi	r2,r2,92
8113f578:	1000091e 	bne	r2,zero,8113f5a0 <check_file_name_for_FAT16_compliance+0x1b4>
8113f57c:	e0bffa17 	ldw	r2,-24(fp)
8113f580:	e0ffff17 	ldw	r3,-4(fp)
8113f584:	1885883a 	add	r2,r3,r2
8113f588:	10800003 	ldbu	r2,0(r2)
8113f58c:	10803fcc 	andi	r2,r2,255
8113f590:	1080201c 	xori	r2,r2,128
8113f594:	10bfe004 	addi	r2,r2,-128
8113f598:	10800bd8 	cmpnei	r2,r2,47
8113f59c:	1000041e 	bne	r2,zero,8113f5b0 <check_file_name_for_FAT16_compliance+0x1c4>
        {
            last_period = index;
8113f5a0:	e0bffa17 	ldw	r2,-24(fp)
8113f5a4:	e0bffc15 	stw	r2,-16(fp)
            last_dir_break_position = index;
8113f5a8:	e0bffa17 	ldw	r2,-24(fp)
8113f5ac:	e0bffb15 	stw	r2,-20(fp)
        }
        if (file_name[index] == '.')
8113f5b0:	e0bffa17 	ldw	r2,-24(fp)
8113f5b4:	e0ffff17 	ldw	r3,-4(fp)
8113f5b8:	1885883a 	add	r2,r3,r2
8113f5bc:	10800003 	ldbu	r2,0(r2)
8113f5c0:	10803fcc 	andi	r2,r2,255
8113f5c4:	1080201c 	xori	r2,r2,128
8113f5c8:	10bfe004 	addi	r2,r2,-128
8113f5cc:	10800b98 	cmpnei	r2,r2,46
8113f5d0:	1000021e 	bne	r2,zero,8113f5dc <check_file_name_for_FAT16_compliance+0x1f0>
        {
            last_period = index;
8113f5d4:	e0bffa17 	ldw	r2,-24(fp)
8113f5d8:	e0bffc15 	stw	r2,-16(fp)
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
8113f5dc:	e0bffa17 	ldw	r2,-24(fp)
8113f5e0:	10800044 	addi	r2,r2,1
8113f5e4:	e0bffa15 	stw	r2,-24(fp)
8113f5e8:	e0fffa17 	ldw	r3,-24(fp)
8113f5ec:	e0bffe17 	ldw	r2,-8(fp)
8113f5f0:	18bf9016 	blt	r3,r2,8113f434 <__reset+0xfb11f434>
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
8113f5f4:	e0bffe17 	ldw	r2,-8(fp)
8113f5f8:	10bfffc4 	addi	r2,r2,-1
8113f5fc:	e0ffff17 	ldw	r3,-4(fp)
8113f600:	1885883a 	add	r2,r3,r2
8113f604:	10800003 	ldbu	r2,0(r2)
8113f608:	10803fcc 	andi	r2,r2,255
8113f60c:	1080201c 	xori	r2,r2,128
8113f610:	10bfe004 	addi	r2,r2,-128
8113f614:	10801720 	cmpeqi	r2,r2,92
8113f618:	10000a1e 	bne	r2,zero,8113f644 <check_file_name_for_FAT16_compliance+0x258>
8113f61c:	e0bffe17 	ldw	r2,-8(fp)
8113f620:	10bfffc4 	addi	r2,r2,-1
8113f624:	e0ffff17 	ldw	r3,-4(fp)
8113f628:	1885883a 	add	r2,r3,r2
8113f62c:	10800003 	ldbu	r2,0(r2)
8113f630:	10803fcc 	andi	r2,r2,255
8113f634:	1080201c 	xori	r2,r2,128
8113f638:	10bfe004 	addi	r2,r2,-128
8113f63c:	10800bd8 	cmpnei	r2,r2,47
8113f640:	1000011e 	bne	r2,zero,8113f648 <check_file_name_for_FAT16_compliance+0x25c>
    {
        result = false;
8113f644:	e03ffd15 	stw	zero,-12(fp)
    }
    return result;
8113f648:	e0bffd17 	ldw	r2,-12(fp)
}
8113f64c:	e037883a 	mov	sp,fp
8113f650:	dfc00117 	ldw	ra,4(sp)
8113f654:	df000017 	ldw	fp,0(sp)
8113f658:	dec00204 	addi	sp,sp,8
8113f65c:	f800283a 	ret

8113f660 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
8113f660:	defffb04 	addi	sp,sp,-20
8113f664:	de00012e 	bgeu	sp,et,8113f66c <get_dir_divider_location+0xc>
8113f668:	003b68fa 	trap	3
8113f66c:	dfc00415 	stw	ra,16(sp)
8113f670:	df000315 	stw	fp,12(sp)
8113f674:	df000304 	addi	fp,sp,12
8113f678:	e13fff15 	stw	r4,-4(fp)
    int index = 0;
8113f67c:	e03ffd15 	stw	zero,-12(fp)
    int length = strlen(name);
8113f680:	e13fff17 	ldw	r4,-4(fp)
8113f684:	111e5bc0 	call	8111e5bc <strlen>
8113f688:	e0bffe15 	stw	r2,-8(fp)
    
    for(index = 0; index < length; index++)
8113f68c:	e03ffd15 	stw	zero,-12(fp)
8113f690:	00001506 	br	8113f6e8 <get_dir_divider_location+0x88>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
8113f694:	e0bffd17 	ldw	r2,-12(fp)
8113f698:	e0ffff17 	ldw	r3,-4(fp)
8113f69c:	1885883a 	add	r2,r3,r2
8113f6a0:	10800003 	ldbu	r2,0(r2)
8113f6a4:	10803fcc 	andi	r2,r2,255
8113f6a8:	1080201c 	xori	r2,r2,128
8113f6ac:	10bfe004 	addi	r2,r2,-128
8113f6b0:	10801720 	cmpeqi	r2,r2,92
8113f6b4:	10000f1e 	bne	r2,zero,8113f6f4 <get_dir_divider_location+0x94>
8113f6b8:	e0bffd17 	ldw	r2,-12(fp)
8113f6bc:	e0ffff17 	ldw	r3,-4(fp)
8113f6c0:	1885883a 	add	r2,r3,r2
8113f6c4:	10800003 	ldbu	r2,0(r2)
8113f6c8:	10803fcc 	andi	r2,r2,255
8113f6cc:	1080201c 	xori	r2,r2,128
8113f6d0:	10bfe004 	addi	r2,r2,-128
8113f6d4:	10800be0 	cmpeqi	r2,r2,47
8113f6d8:	1000061e 	bne	r2,zero,8113f6f4 <get_dir_divider_location+0x94>
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
8113f6dc:	e0bffd17 	ldw	r2,-12(fp)
8113f6e0:	10800044 	addi	r2,r2,1
8113f6e4:	e0bffd15 	stw	r2,-12(fp)
8113f6e8:	e0fffd17 	ldw	r3,-12(fp)
8113f6ec:	e0bffe17 	ldw	r2,-8(fp)
8113f6f0:	18bfe816 	blt	r3,r2,8113f694 <__reset+0xfb11f694>
        {
            break;
        }
    }
    
    if (index == length)
8113f6f4:	e0fffd17 	ldw	r3,-12(fp)
8113f6f8:	e0bffe17 	ldw	r2,-8(fp)
8113f6fc:	1880021e 	bne	r3,r2,8113f708 <get_dir_divider_location+0xa8>
    {
        index = -1;
8113f700:	00bfffc4 	movi	r2,-1
8113f704:	e0bffd15 	stw	r2,-12(fp)
    }
    
    return index;
8113f708:	e0bffd17 	ldw	r2,-12(fp)
}
8113f70c:	e037883a 	mov	sp,fp
8113f710:	dfc00117 	ldw	ra,4(sp)
8113f714:	df000017 	ldw	fp,0(sp)
8113f718:	dec00204 	addi	sp,sp,8
8113f71c:	f800283a 	ret

8113f720 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
8113f720:	defffa04 	addi	sp,sp,-24
8113f724:	de00012e 	bgeu	sp,et,8113f72c <match_file_record_to_name_ext+0xc>
8113f728:	003b68fa 	trap	3
8113f72c:	df000515 	stw	fp,20(sp)
8113f730:	df000504 	addi	fp,sp,20
8113f734:	e13ffd15 	stw	r4,-12(fp)
8113f738:	e17ffe15 	stw	r5,-8(fp)
8113f73c:	e1bfff15 	stw	r6,-4(fp)
    bool match = true;
8113f740:	00800044 	movi	r2,1
8113f744:	e0bffb15 	stw	r2,-20(fp)
	int index;

    for (index = 0; index < 8; index++)
8113f748:	e03ffc15 	stw	zero,-16(fp)
8113f74c:	00004606 	br	8113f868 <match_file_record_to_name_ext+0x148>
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
8113f750:	e0fffd17 	ldw	r3,-12(fp)
8113f754:	e0bffc17 	ldw	r2,-16(fp)
8113f758:	1885883a 	add	r2,r3,r2
8113f75c:	10800003 	ldbu	r2,0(r2)
8113f760:	10803fcc 	andi	r2,r2,255
8113f764:	10801870 	cmpltui	r2,r2,97
8113f768:	1000101e 	bne	r2,zero,8113f7ac <match_file_record_to_name_ext+0x8c>
8113f76c:	e0fffd17 	ldw	r3,-12(fp)
8113f770:	e0bffc17 	ldw	r2,-16(fp)
8113f774:	1885883a 	add	r2,r3,r2
8113f778:	10800003 	ldbu	r2,0(r2)
8113f77c:	10803fcc 	andi	r2,r2,255
8113f780:	10801ee8 	cmpgeui	r2,r2,123
8113f784:	1000091e 	bne	r2,zero,8113f7ac <match_file_record_to_name_ext+0x8c>
8113f788:	e0fffd17 	ldw	r3,-12(fp)
8113f78c:	e0bffc17 	ldw	r2,-16(fp)
8113f790:	1885883a 	add	r2,r3,r2
8113f794:	10800003 	ldbu	r2,0(r2)
8113f798:	10bff804 	addi	r2,r2,-32
8113f79c:	10c03fcc 	andi	r3,r2,255
8113f7a0:	18c0201c 	xori	r3,r3,128
8113f7a4:	18ffe004 	addi	r3,r3,-128
8113f7a8:	00000706 	br	8113f7c8 <match_file_record_to_name_ext+0xa8>
8113f7ac:	e0fffd17 	ldw	r3,-12(fp)
8113f7b0:	e0bffc17 	ldw	r2,-16(fp)
8113f7b4:	1885883a 	add	r2,r3,r2
8113f7b8:	10800003 	ldbu	r2,0(r2)
8113f7bc:	10c03fcc 	andi	r3,r2,255
8113f7c0:	18c0201c 	xori	r3,r3,128
8113f7c4:	18ffe004 	addi	r3,r3,-128
8113f7c8:	e0bffc17 	ldw	r2,-16(fp)
8113f7cc:	e13ffe17 	ldw	r4,-8(fp)
8113f7d0:	2085883a 	add	r2,r4,r2
8113f7d4:	10800003 	ldbu	r2,0(r2)
8113f7d8:	10803fcc 	andi	r2,r2,255
8113f7dc:	1080201c 	xori	r2,r2,128
8113f7e0:	10bfe004 	addi	r2,r2,-128
8113f7e4:	10801850 	cmplti	r2,r2,97
8113f7e8:	1000121e 	bne	r2,zero,8113f834 <match_file_record_to_name_ext+0x114>
8113f7ec:	e0bffc17 	ldw	r2,-16(fp)
8113f7f0:	e13ffe17 	ldw	r4,-8(fp)
8113f7f4:	2085883a 	add	r2,r4,r2
8113f7f8:	10800003 	ldbu	r2,0(r2)
8113f7fc:	10803fcc 	andi	r2,r2,255
8113f800:	1080201c 	xori	r2,r2,128
8113f804:	10bfe004 	addi	r2,r2,-128
8113f808:	10801ec8 	cmpgei	r2,r2,123
8113f80c:	1000091e 	bne	r2,zero,8113f834 <match_file_record_to_name_ext+0x114>
8113f810:	e0bffc17 	ldw	r2,-16(fp)
8113f814:	e13ffe17 	ldw	r4,-8(fp)
8113f818:	2085883a 	add	r2,r4,r2
8113f81c:	10800003 	ldbu	r2,0(r2)
8113f820:	10bff804 	addi	r2,r2,-32
8113f824:	10803fcc 	andi	r2,r2,255
8113f828:	1080201c 	xori	r2,r2,128
8113f82c:	10bfe004 	addi	r2,r2,-128
8113f830:	00000706 	br	8113f850 <match_file_record_to_name_ext+0x130>
8113f834:	e0bffc17 	ldw	r2,-16(fp)
8113f838:	e13ffe17 	ldw	r4,-8(fp)
8113f83c:	2085883a 	add	r2,r4,r2
8113f840:	10800003 	ldbu	r2,0(r2)
8113f844:	10803fcc 	andi	r2,r2,255
8113f848:	1080201c 	xori	r2,r2,128
8113f84c:	10bfe004 	addi	r2,r2,-128
8113f850:	18800226 	beq	r3,r2,8113f85c <match_file_record_to_name_ext+0x13c>
        {
            match = false;
8113f854:	e03ffb15 	stw	zero,-20(fp)
			break;
8113f858:	00000606 	br	8113f874 <match_file_record_to_name_ext+0x154>
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
8113f85c:	e0bffc17 	ldw	r2,-16(fp)
8113f860:	10800044 	addi	r2,r2,1
8113f864:	e0bffc15 	stw	r2,-16(fp)
8113f868:	e0bffc17 	ldw	r2,-16(fp)
8113f86c:	10800210 	cmplti	r2,r2,8
8113f870:	103fb71e 	bne	r2,zero,8113f750 <__reset+0xfb11f750>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113f874:	e03ffc15 	stw	zero,-16(fp)
8113f878:	00004a06 	br	8113f9a4 <match_file_record_to_name_ext+0x284>
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
8113f87c:	e0fffd17 	ldw	r3,-12(fp)
8113f880:	e0bffc17 	ldw	r2,-16(fp)
8113f884:	1885883a 	add	r2,r3,r2
8113f888:	10800204 	addi	r2,r2,8
8113f88c:	10800003 	ldbu	r2,0(r2)
8113f890:	10803fcc 	andi	r2,r2,255
8113f894:	10801870 	cmpltui	r2,r2,97
8113f898:	1000121e 	bne	r2,zero,8113f8e4 <match_file_record_to_name_ext+0x1c4>
8113f89c:	e0fffd17 	ldw	r3,-12(fp)
8113f8a0:	e0bffc17 	ldw	r2,-16(fp)
8113f8a4:	1885883a 	add	r2,r3,r2
8113f8a8:	10800204 	addi	r2,r2,8
8113f8ac:	10800003 	ldbu	r2,0(r2)
8113f8b0:	10803fcc 	andi	r2,r2,255
8113f8b4:	10801ee8 	cmpgeui	r2,r2,123
8113f8b8:	10000a1e 	bne	r2,zero,8113f8e4 <match_file_record_to_name_ext+0x1c4>
8113f8bc:	e0fffd17 	ldw	r3,-12(fp)
8113f8c0:	e0bffc17 	ldw	r2,-16(fp)
8113f8c4:	1885883a 	add	r2,r3,r2
8113f8c8:	10800204 	addi	r2,r2,8
8113f8cc:	10800003 	ldbu	r2,0(r2)
8113f8d0:	10bff804 	addi	r2,r2,-32
8113f8d4:	10c03fcc 	andi	r3,r2,255
8113f8d8:	18c0201c 	xori	r3,r3,128
8113f8dc:	18ffe004 	addi	r3,r3,-128
8113f8e0:	00000806 	br	8113f904 <match_file_record_to_name_ext+0x1e4>
8113f8e4:	e0fffd17 	ldw	r3,-12(fp)
8113f8e8:	e0bffc17 	ldw	r2,-16(fp)
8113f8ec:	1885883a 	add	r2,r3,r2
8113f8f0:	10800204 	addi	r2,r2,8
8113f8f4:	10800003 	ldbu	r2,0(r2)
8113f8f8:	10c03fcc 	andi	r3,r2,255
8113f8fc:	18c0201c 	xori	r3,r3,128
8113f900:	18ffe004 	addi	r3,r3,-128
8113f904:	e0bffc17 	ldw	r2,-16(fp)
8113f908:	e13fff17 	ldw	r4,-4(fp)
8113f90c:	2085883a 	add	r2,r4,r2
8113f910:	10800003 	ldbu	r2,0(r2)
8113f914:	10803fcc 	andi	r2,r2,255
8113f918:	1080201c 	xori	r2,r2,128
8113f91c:	10bfe004 	addi	r2,r2,-128
8113f920:	10801850 	cmplti	r2,r2,97
8113f924:	1000121e 	bne	r2,zero,8113f970 <match_file_record_to_name_ext+0x250>
8113f928:	e0bffc17 	ldw	r2,-16(fp)
8113f92c:	e13fff17 	ldw	r4,-4(fp)
8113f930:	2085883a 	add	r2,r4,r2
8113f934:	10800003 	ldbu	r2,0(r2)
8113f938:	10803fcc 	andi	r2,r2,255
8113f93c:	1080201c 	xori	r2,r2,128
8113f940:	10bfe004 	addi	r2,r2,-128
8113f944:	10801ec8 	cmpgei	r2,r2,123
8113f948:	1000091e 	bne	r2,zero,8113f970 <match_file_record_to_name_ext+0x250>
8113f94c:	e0bffc17 	ldw	r2,-16(fp)
8113f950:	e13fff17 	ldw	r4,-4(fp)
8113f954:	2085883a 	add	r2,r4,r2
8113f958:	10800003 	ldbu	r2,0(r2)
8113f95c:	10bff804 	addi	r2,r2,-32
8113f960:	10803fcc 	andi	r2,r2,255
8113f964:	1080201c 	xori	r2,r2,128
8113f968:	10bfe004 	addi	r2,r2,-128
8113f96c:	00000706 	br	8113f98c <match_file_record_to_name_ext+0x26c>
8113f970:	e0bffc17 	ldw	r2,-16(fp)
8113f974:	e13fff17 	ldw	r4,-4(fp)
8113f978:	2085883a 	add	r2,r4,r2
8113f97c:	10800003 	ldbu	r2,0(r2)
8113f980:	10803fcc 	andi	r2,r2,255
8113f984:	1080201c 	xori	r2,r2,128
8113f988:	10bfe004 	addi	r2,r2,-128
8113f98c:	18800226 	beq	r3,r2,8113f998 <match_file_record_to_name_ext+0x278>
        {
            match = false;
8113f990:	e03ffb15 	stw	zero,-20(fp)
			break;
8113f994:	00000606 	br	8113f9b0 <match_file_record_to_name_ext+0x290>
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
8113f998:	e0bffc17 	ldw	r2,-16(fp)
8113f99c:	10800044 	addi	r2,r2,1
8113f9a0:	e0bffc15 	stw	r2,-16(fp)
8113f9a4:	e0bffc17 	ldw	r2,-16(fp)
8113f9a8:	108000d0 	cmplti	r2,r2,3
8113f9ac:	103fb31e 	bne	r2,zero,8113f87c <__reset+0xfb11f87c>
        {
            match = false;
			break;
        }
    }
	return match;
8113f9b0:	e0bffb17 	ldw	r2,-20(fp)
}
8113f9b4:	e037883a 	mov	sp,fp
8113f9b8:	df000017 	ldw	fp,0(sp)
8113f9bc:	dec00104 	addi	sp,sp,4
8113f9c0:	f800283a 	ret

8113f9c4 <get_home_directory_cluster_for_file>:


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
8113f9c4:	deffe704 	addi	sp,sp,-100
8113f9c8:	de00012e 	bgeu	sp,et,8113f9d0 <get_home_directory_cluster_for_file+0xc>
8113f9cc:	003b68fa 	trap	3
8113f9d0:	dfc01815 	stw	ra,96(sp)
8113f9d4:	df001715 	stw	fp,92(sp)
8113f9d8:	df001704 	addi	fp,sp,92
8113f9dc:	e13ffd15 	stw	r4,-12(fp)
8113f9e0:	e17ffe15 	stw	r5,-8(fp)
8113f9e4:	e1bfff15 	stw	r6,-4(fp)
    bool result = false;
8113f9e8:	e03fe915 	stw	zero,-92(fp)
    int home_dir_cluster = 0;
8113f9ec:	e03fea15 	stw	zero,-88(fp)
    int location, index;
    int start_location = 0;
8113f9f0:	e03fed15 	stw	zero,-76(fp)
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
8113f9f4:	e13ffd17 	ldw	r4,-12(fp)
8113f9f8:	113f6600 	call	8113f660 <get_dir_divider_location>
8113f9fc:	e0bfeb15 	stw	r2,-84(fp)
    while (location > 0)
8113fa00:	00012f06 	br	8113fec0 <get_home_directory_cluster_for_file+0x4fc>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113fa04:	00800804 	movi	r2,32
8113fa08:	e0bff905 	stb	r2,-28(fp)
8113fa0c:	00800804 	movi	r2,32
8113fa10:	e0bff945 	stb	r2,-27(fp)
8113fa14:	00800804 	movi	r2,32
8113fa18:	e0bff985 	stb	r2,-26(fp)
8113fa1c:	00800804 	movi	r2,32
8113fa20:	e0bff9c5 	stb	r2,-25(fp)
8113fa24:	00800804 	movi	r2,32
8113fa28:	e0bffa05 	stb	r2,-24(fp)
8113fa2c:	00800804 	movi	r2,32
8113fa30:	e0bffa45 	stb	r2,-23(fp)
8113fa34:	00800804 	movi	r2,32
8113fa38:	e0bffa85 	stb	r2,-22(fp)
8113fa3c:	00800804 	movi	r2,32
8113fa40:	e0bffac5 	stb	r2,-21(fp)
        char extension[3] = { ' ', ' ', ' ' };
8113fa44:	00800804 	movi	r2,32
8113fa48:	e0bffb05 	stb	r2,-20(fp)
8113fa4c:	00800804 	movi	r2,32
8113fa50:	e0bffb45 	stb	r2,-19(fp)
8113fa54:	00800804 	movi	r2,32
8113fa58:	e0bffb85 	stb	r2,-18(fp)
        int ext_index = -1;
8113fa5c:	00bfffc4 	movi	r2,-1
8113fa60:	e0bfee15 	stw	r2,-72(fp)
        int new_cluster = home_dir_cluster;
8113fa64:	e0bfea17 	ldw	r2,-88(fp)
8113fa68:	e0bfef15 	stw	r2,-68(fp)
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113fa6c:	e03fec15 	stw	zero,-80(fp)
8113fa70:	00002d06 	br	8113fb28 <get_home_directory_cluster_for_file+0x164>
        {
            if (file_name[index+start_location] == '.')
8113fa74:	e0ffec17 	ldw	r3,-80(fp)
8113fa78:	e0bfed17 	ldw	r2,-76(fp)
8113fa7c:	1885883a 	add	r2,r3,r2
8113fa80:	1007883a 	mov	r3,r2
8113fa84:	e0bffd17 	ldw	r2,-12(fp)
8113fa88:	10c5883a 	add	r2,r2,r3
8113fa8c:	10800003 	ldbu	r2,0(r2)
8113fa90:	10803fcc 	andi	r2,r2,255
8113fa94:	1080201c 	xori	r2,r2,128
8113fa98:	10bfe004 	addi	r2,r2,-128
8113fa9c:	10800b98 	cmpnei	r2,r2,46
8113faa0:	1000031e 	bne	r2,zero,8113fab0 <get_home_directory_cluster_for_file+0xec>
            {
                ext_index = index;
8113faa4:	e0bfec17 	ldw	r2,-80(fp)
8113faa8:	e0bfee15 	stw	r2,-72(fp)
8113faac:	00001b06 	br	8113fb1c <get_home_directory_cluster_for_file+0x158>
            }
            else if (ext_index < 0)
8113fab0:	e0bfee17 	ldw	r2,-72(fp)
8113fab4:	10000c0e 	bge	r2,zero,8113fae8 <get_home_directory_cluster_for_file+0x124>
            {
                name[index] = file_name[index+start_location];
8113fab8:	e0ffec17 	ldw	r3,-80(fp)
8113fabc:	e0bfed17 	ldw	r2,-76(fp)
8113fac0:	1885883a 	add	r2,r3,r2
8113fac4:	1007883a 	mov	r3,r2
8113fac8:	e0bffd17 	ldw	r2,-12(fp)
8113facc:	10c5883a 	add	r2,r2,r3
8113fad0:	10c00003 	ldbu	r3,0(r2)
8113fad4:	e13ff904 	addi	r4,fp,-28
8113fad8:	e0bfec17 	ldw	r2,-80(fp)
8113fadc:	2085883a 	add	r2,r4,r2
8113fae0:	10c00005 	stb	r3,0(r2)
8113fae4:	00000d06 	br	8113fb1c <get_home_directory_cluster_for_file+0x158>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
8113fae8:	e0ffec17 	ldw	r3,-80(fp)
8113faec:	e0bfee17 	ldw	r2,-72(fp)
8113faf0:	1885c83a 	sub	r2,r3,r2
8113faf4:	e13fec17 	ldw	r4,-80(fp)
8113faf8:	e0ffed17 	ldw	r3,-76(fp)
8113fafc:	20c7883a 	add	r3,r4,r3
8113fb00:	1809883a 	mov	r4,r3
8113fb04:	e0fffd17 	ldw	r3,-12(fp)
8113fb08:	1907883a 	add	r3,r3,r4
8113fb0c:	18c00003 	ldbu	r3,0(r3)
8113fb10:	e13ffb04 	addi	r4,fp,-20
8113fb14:	2085883a 	add	r2,r4,r2
8113fb18:	10c00005 	stb	r3,0(r2)
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
8113fb1c:	e0bfec17 	ldw	r2,-80(fp)
8113fb20:	10800044 	addi	r2,r2,1
8113fb24:	e0bfec15 	stw	r2,-80(fp)
8113fb28:	e0ffec17 	ldw	r3,-80(fp)
8113fb2c:	e0bfeb17 	ldw	r2,-84(fp)
8113fb30:	18bfd016 	blt	r3,r2,8113fa74 <__reset+0xfb11fa74>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
8113fb34:	e0bfea17 	ldw	r2,-88(fp)
8113fb38:	10005c1e 	bne	r2,zero,8113fcac <get_home_directory_cluster_for_file+0x2e8>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
8113fb3c:	00a045f4 	movhi	r2,33047
8113fb40:	10a13004 	addi	r2,r2,-31552
8113fb44:	1080050b 	ldhu	r2,20(r2)
8113fb48:	10bfffcc 	andi	r2,r2,65535
8113fb4c:	1006917a 	slli	r3,r2,5
8113fb50:	00a045f4 	movhi	r2,33047
8113fb54:	10a13004 	addi	r2,r2,-31552
8113fb58:	1080030b 	ldhu	r2,12(r2)
8113fb5c:	10bfffcc 	andi	r2,r2,65535
8113fb60:	1885283a 	div	r2,r3,r2
8113fb64:	e0bff715 	stw	r2,-36(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113fb68:	e03ff015 	stw	zero,-64(fp)
8113fb6c:	00003b06 	br	8113fc5c <get_home_directory_cluster_for_file+0x298>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
8113fb70:	00a045f4 	movhi	r2,33047
8113fb74:	10a13004 	addi	r2,r2,-31552
8113fb78:	10c01317 	ldw	r3,76(r2)
8113fb7c:	e0bff017 	ldw	r2,-64(fp)
8113fb80:	1885883a 	add	r2,r3,r2
8113fb84:	1007883a 	mov	r3,r2
8113fb88:	d0a0ad17 	ldw	r2,-32076(gp)
8113fb8c:	100b883a 	mov	r5,r2
8113fb90:	1809883a 	mov	r4,r3
8113fb94:	113e25c0 	call	8113e25c <Read_Sector_Data>
8113fb98:	10003426 	beq	r2,zero,8113fc6c <get_home_directory_cluster_for_file+0x2a8>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113fb9c:	e03ff115 	stw	zero,-60(fp)
8113fba0:	00002506 	br	8113fc38 <get_home_directory_cluster_for_file+0x274>
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8113fba4:	e0bff117 	ldw	r2,-60(fp)
8113fba8:	1004917a 	slli	r2,r2,5
8113fbac:	e0fff017 	ldw	r3,-64(fp)
8113fbb0:	180f883a 	mov	r7,r3
8113fbb4:	000d883a 	mov	r6,zero
8113fbb8:	e17fff17 	ldw	r5,-4(fp)
8113fbbc:	1009883a 	mov	r4,r2
8113fbc0:	113e68c0 	call	8113e68c <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113fbc4:	e0bfff17 	ldw	r2,-4(fp)
8113fbc8:	10800003 	ldbu	r2,0(r2)
8113fbcc:	10803fcc 	andi	r2,r2,255
8113fbd0:	10803960 	cmpeqi	r2,r2,229
8113fbd4:	1000151e 	bne	r2,zero,8113fc2c <get_home_directory_cluster_for_file+0x268>
8113fbd8:	e0bfff17 	ldw	r2,-4(fp)
8113fbdc:	10800003 	ldbu	r2,0(r2)
8113fbe0:	10803fcc 	andi	r2,r2,255
8113fbe4:	10001126 	beq	r2,zero,8113fc2c <get_home_directory_cluster_for_file+0x268>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
8113fbe8:	e0fffb04 	addi	r3,fp,-20
8113fbec:	e0bff904 	addi	r2,fp,-28
8113fbf0:	180d883a 	mov	r6,r3
8113fbf4:	100b883a 	mov	r5,r2
8113fbf8:	e13fff17 	ldw	r4,-4(fp)
8113fbfc:	113f7200 	call	8113f720 <match_file_record_to_name_ext>
8113fc00:	e0bff815 	stw	r2,-32(fp)
                            if (match)
8113fc04:	e0bff817 	ldw	r2,-32(fp)
8113fc08:	10000826 	beq	r2,zero,8113fc2c <get_home_directory_cluster_for_file+0x268>
                            {
                                new_cluster = file_record->start_cluster_index;
8113fc0c:	e0bfff17 	ldw	r2,-4(fp)
8113fc10:	1080058b 	ldhu	r2,22(r2)
8113fc14:	10bfffcc 	andi	r2,r2,65535
8113fc18:	e0bfef15 	stw	r2,-68(fp)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
8113fc1c:	e0bfff17 	ldw	r2,-4(fp)
8113fc20:	00c00044 	movi	r3,1
8113fc24:	10c00a15 	stw	r3,40(r2)
                                break;
8113fc28:	00000606 	br	8113fc44 <get_home_directory_cluster_for_file+0x280>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
8113fc2c:	e0bff117 	ldw	r2,-60(fp)
8113fc30:	10800044 	addi	r2,r2,1
8113fc34:	e0bff115 	stw	r2,-60(fp)
8113fc38:	e0bff117 	ldw	r2,-60(fp)
8113fc3c:	10800410 	cmplti	r2,r2,16
8113fc40:	103fd81e 	bne	r2,zero,8113fba4 <__reset+0xfb11fba4>
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
8113fc44:	e0ffef17 	ldw	r3,-68(fp)
8113fc48:	e0bfea17 	ldw	r2,-88(fp)
8113fc4c:	1880091e 	bne	r3,r2,8113fc74 <get_home_directory_cluster_for_file+0x2b0>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
8113fc50:	e0bff017 	ldw	r2,-64(fp)
8113fc54:	10800044 	addi	r2,r2,1
8113fc58:	e0bff015 	stw	r2,-64(fp)
8113fc5c:	e0fff017 	ldw	r3,-64(fp)
8113fc60:	e0bff717 	ldw	r2,-36(fp)
8113fc64:	18bfc216 	blt	r3,r2,8113fb70 <__reset+0xfb11fb70>
8113fc68:	00000306 	br	8113fc78 <get_home_directory_cluster_for_file+0x2b4>
                        }
                    }
                }
                else
                {
                    break;
8113fc6c:	0001883a 	nop
8113fc70:	00000106 	br	8113fc78 <get_home_directory_cluster_for_file+0x2b4>
                }
                if (new_cluster != home_dir_cluster)
                {
                    break;
8113fc74:	0001883a 	nop
                }
            }
            if (new_cluster != home_dir_cluster)
8113fc78:	e0ffef17 	ldw	r3,-68(fp)
8113fc7c:	e0bfea17 	ldw	r2,-88(fp)
8113fc80:	18800826 	beq	r3,r2,8113fca4 <get_home_directory_cluster_for_file+0x2e0>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113fc84:	e0bfef17 	ldw	r2,-68(fp)
8113fc88:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113fc8c:	e0ffed17 	ldw	r3,-76(fp)
8113fc90:	e0bfeb17 	ldw	r2,-84(fp)
8113fc94:	1885883a 	add	r2,r3,r2
8113fc98:	10800044 	addi	r2,r2,1
8113fc9c:	e0bfed15 	stw	r2,-76(fp)
8113fca0:	00007d06 	br	8113fe98 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113fca4:	0005883a 	mov	r2,zero
8113fca8:	00009106 	br	8113fef0 <get_home_directory_cluster_for_file+0x52c>
            }
        } else {
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
8113fcac:	e0bfea17 	ldw	r2,-88(fp)
8113fcb0:	e0bff415 	stw	r2,-48(fp)
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
8113fcb4:	e0bff417 	ldw	r2,-48(fp)
8113fcb8:	10ffff84 	addi	r3,r2,-2
8113fcbc:	00a045f4 	movhi	r2,33047
8113fcc0:	10a13004 	addi	r2,r2,-31552
8113fcc4:	10800383 	ldbu	r2,14(r2)
8113fcc8:	10803fcc 	andi	r2,r2,255
8113fccc:	1885383a 	mul	r2,r3,r2
8113fcd0:	1007883a 	mov	r3,r2
8113fcd4:	00a045f4 	movhi	r2,33047
8113fcd8:	10a13004 	addi	r2,r2,-31552
8113fcdc:	10801417 	ldw	r2,80(r2)
8113fce0:	1885883a 	add	r2,r3,r2
8113fce4:	e0bff515 	stw	r2,-44(fp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113fce8:	e03ff215 	stw	zero,-56(fp)
8113fcec:	00003606 	br	8113fdc8 <get_home_directory_cluster_for_file+0x404>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8113fcf0:	e0fff217 	ldw	r3,-56(fp)
8113fcf4:	e0bff517 	ldw	r2,-44(fp)
8113fcf8:	1885883a 	add	r2,r3,r2
8113fcfc:	d0e0ad17 	ldw	r3,-32076(gp)
8113fd00:	180b883a 	mov	r5,r3
8113fd04:	1009883a 	mov	r4,r2
8113fd08:	113e25c0 	call	8113e25c <Read_Sector_Data>
8113fd0c:	10003526 	beq	r2,zero,8113fde4 <get_home_directory_cluster_for_file+0x420>
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113fd10:	e03ff315 	stw	zero,-52(fp)
8113fd14:	00002306 	br	8113fda4 <get_home_directory_cluster_for_file+0x3e0>
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
8113fd18:	e0bff317 	ldw	r2,-52(fp)
8113fd1c:	1004917a 	slli	r2,r2,5
8113fd20:	e0fff417 	ldw	r3,-48(fp)
8113fd24:	e13ff217 	ldw	r4,-56(fp)
8113fd28:	200f883a 	mov	r7,r4
8113fd2c:	180d883a 	mov	r6,r3
8113fd30:	e17fff17 	ldw	r5,-4(fp)
8113fd34:	1009883a 	mov	r4,r2
8113fd38:	113e68c0 	call	8113e68c <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8113fd3c:	e0bfff17 	ldw	r2,-4(fp)
8113fd40:	10800003 	ldbu	r2,0(r2)
8113fd44:	10803fcc 	andi	r2,r2,255
8113fd48:	10803960 	cmpeqi	r2,r2,229
8113fd4c:	1000121e 	bne	r2,zero,8113fd98 <get_home_directory_cluster_for_file+0x3d4>
8113fd50:	e0bfff17 	ldw	r2,-4(fp)
8113fd54:	10800003 	ldbu	r2,0(r2)
8113fd58:	10803fcc 	andi	r2,r2,255
8113fd5c:	10000e26 	beq	r2,zero,8113fd98 <get_home_directory_cluster_for_file+0x3d4>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
8113fd60:	e0fffb04 	addi	r3,fp,-20
8113fd64:	e0bff904 	addi	r2,fp,-28
8113fd68:	180d883a 	mov	r6,r3
8113fd6c:	100b883a 	mov	r5,r2
8113fd70:	e13fff17 	ldw	r4,-4(fp)
8113fd74:	113f7200 	call	8113f720 <match_file_record_to_name_ext>
8113fd78:	e0bff615 	stw	r2,-40(fp)
                                if (match)
8113fd7c:	e0bff617 	ldw	r2,-40(fp)
8113fd80:	10000526 	beq	r2,zero,8113fd98 <get_home_directory_cluster_for_file+0x3d4>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
8113fd84:	e0bfff17 	ldw	r2,-4(fp)
8113fd88:	1080058b 	ldhu	r2,22(r2)
8113fd8c:	10bfffcc 	andi	r2,r2,65535
8113fd90:	e0bfef15 	stw	r2,-68(fp)
                                    break;
8113fd94:	00000606 	br	8113fdb0 <get_home_directory_cluster_for_file+0x3ec>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
8113fd98:	e0bff317 	ldw	r2,-52(fp)
8113fd9c:	10800044 	addi	r2,r2,1
8113fda0:	e0bff315 	stw	r2,-52(fp)
8113fda4:	e0bff317 	ldw	r2,-52(fp)
8113fda8:	10800410 	cmplti	r2,r2,16
8113fdac:	103fda1e 	bne	r2,zero,8113fd18 <__reset+0xfb11fd18>
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
8113fdb0:	e0ffef17 	ldw	r3,-68(fp)
8113fdb4:	e0bfea17 	ldw	r2,-88(fp)
8113fdb8:	18800c1e 	bne	r3,r2,8113fdec <get_home_directory_cluster_for_file+0x428>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8113fdbc:	e0bff217 	ldw	r2,-56(fp)
8113fdc0:	10800044 	addi	r2,r2,1
8113fdc4:	e0bff215 	stw	r2,-56(fp)
8113fdc8:	00a045f4 	movhi	r2,33047
8113fdcc:	10a13004 	addi	r2,r2,-31552
8113fdd0:	10800383 	ldbu	r2,14(r2)
8113fdd4:	10803fcc 	andi	r2,r2,255
8113fdd8:	e0fff217 	ldw	r3,-56(fp)
8113fddc:	18bfc416 	blt	r3,r2,8113fcf0 <__reset+0xfb11fcf0>
8113fde0:	00000306 	br	8113fdf0 <get_home_directory_cluster_for_file+0x42c>
                            }
                        }
                    }
                    else
                    {
                        break;
8113fde4:	0001883a 	nop
8113fde8:	00000106 	br	8113fdf0 <get_home_directory_cluster_for_file+0x42c>
                    }
                    if (new_cluster != home_dir_cluster)
                    {
                        break;
8113fdec:	0001883a 	nop
                    }
                }
                // If this is the end of the cluster and the directory has not been found, then see if there is another cluster
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
8113fdf0:	e0ffef17 	ldw	r3,-68(fp)
8113fdf4:	e0bfea17 	ldw	r2,-88(fp)
8113fdf8:	1880141e 	bne	r3,r2,8113fe4c <get_home_directory_cluster_for_file+0x488>
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
8113fdfc:	e0bfef17 	ldw	r2,-68(fp)
8113fe00:	e0fffc04 	addi	r3,fp,-16
8113fe04:	180b883a 	mov	r5,r3
8113fe08:	1009883a 	mov	r4,r2
8113fe0c:	113e33c0 	call	8113e33c <get_cluster_flag>
8113fe10:	10000c26 	beq	r2,zero,8113fe44 <get_home_directory_cluster_for_file+0x480>
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
8113fe14:	e0bffc0b 	ldhu	r2,-16(fp)
8113fe18:	10bfffcc 	andi	r2,r2,65535
8113fe1c:	10fffe0c 	andi	r3,r2,65528
8113fe20:	00bffe14 	movui	r2,65528
8113fe24:	1880021e 	bne	r3,r2,8113fe30 <get_home_directory_cluster_for_file+0x46c>
						{
							return false;
8113fe28:	0005883a 	mov	r2,zero
8113fe2c:	00003006 	br	8113fef0 <get_home_directory_cluster_for_file+0x52c>
						}
						new_cluster = (next_cluster & 0x0000fff8);
8113fe30:	e0bffc0b 	ldhu	r2,-16(fp)
8113fe34:	10bfffcc 	andi	r2,r2,65535
8113fe38:	10bffe0c 	andi	r2,r2,65528
8113fe3c:	e0bfef15 	stw	r2,-68(fp)
8113fe40:	00000206 	br	8113fe4c <get_home_directory_cluster_for_file+0x488>
					}
					else
					{
						// Directory path is invalid.                 
						return false;
8113fe44:	0005883a 	mov	r2,zero
8113fe48:	00002906 	br	8113fef0 <get_home_directory_cluster_for_file+0x52c>
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
8113fe4c:	e0bff417 	ldw	r2,-48(fp)
8113fe50:	00fffdd4 	movui	r3,65527
8113fe54:	18800316 	blt	r3,r2,8113fe64 <get_home_directory_cluster_for_file+0x4a0>
8113fe58:	e0ffef17 	ldw	r3,-68(fp)
8113fe5c:	e0bfea17 	ldw	r2,-88(fp)
8113fe60:	18bf9426 	beq	r3,r2,8113fcb4 <__reset+0xfb11fcb4>
            if (new_cluster != home_dir_cluster)
8113fe64:	e0ffef17 	ldw	r3,-68(fp)
8113fe68:	e0bfea17 	ldw	r2,-88(fp)
8113fe6c:	18800826 	beq	r3,r2,8113fe90 <get_home_directory_cluster_for_file+0x4cc>
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
8113fe70:	e0bfef17 	ldw	r2,-68(fp)
8113fe74:	e0bfea15 	stw	r2,-88(fp)
                start_location = start_location+location+1;
8113fe78:	e0ffed17 	ldw	r3,-76(fp)
8113fe7c:	e0bfeb17 	ldw	r2,-84(fp)
8113fe80:	1885883a 	add	r2,r3,r2
8113fe84:	10800044 	addi	r2,r2,1
8113fe88:	e0bfed15 	stw	r2,-76(fp)
8113fe8c:	00000206 	br	8113fe98 <get_home_directory_cluster_for_file+0x4d4>
            }
            else
            {
                // Directory path is invalid. 
                return false;
8113fe90:	0005883a 	mov	r2,zero
8113fe94:	00001606 	br	8113fef0 <get_home_directory_cluster_for_file+0x52c>
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
8113fe98:	e0bfed17 	ldw	r2,-76(fp)
8113fe9c:	e0fffd17 	ldw	r3,-12(fp)
8113fea0:	1885883a 	add	r2,r3,r2
8113fea4:	1009883a 	mov	r4,r2
8113fea8:	113f6600 	call	8113f660 <get_dir_divider_location>
8113feac:	e0bfeb15 	stw	r2,-84(fp)
        if (location < 0)
8113feb0:	e0bfeb17 	ldw	r2,-84(fp)
8113feb4:	1000020e 	bge	r2,zero,8113fec0 <get_home_directory_cluster_for_file+0x4fc>
        {
            // Directory has been located.
            result = true;
8113feb8:	00800044 	movi	r2,1
8113febc:	e0bfe915 	stw	r2,-92(fp)
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
8113fec0:	e0bfeb17 	ldw	r2,-84(fp)
8113fec4:	00becf16 	blt	zero,r2,8113fa04 <__reset+0xfb11fa04>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
8113fec8:	e0bffe17 	ldw	r2,-8(fp)
8113fecc:	e0ffea17 	ldw	r3,-88(fp)
8113fed0:	10c00015 	stw	r3,0(r2)
    if (home_dir_cluster == 0)
8113fed4:	e0bfea17 	ldw	r2,-88(fp)
8113fed8:	1000041e 	bne	r2,zero,8113feec <get_home_directory_cluster_for_file+0x528>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
8113fedc:	e0bfff17 	ldw	r2,-4(fp)
8113fee0:	10000a15 	stw	zero,40(r2)
		result = true;
8113fee4:	00800044 	movi	r2,1
8113fee8:	e0bfe915 	stw	r2,-92(fp)
    }
    return result;
8113feec:	e0bfe917 	ldw	r2,-92(fp)
}
8113fef0:	e037883a 	mov	sp,fp
8113fef4:	dfc00117 	ldw	ra,4(sp)
8113fef8:	df000017 	ldw	fp,0(sp)
8113fefc:	dec00204 	addi	sp,sp,8
8113ff00:	f800283a 	ret

8113ff04 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
8113ff04:	deffe804 	addi	sp,sp,-96
8113ff08:	de00012e 	bgeu	sp,et,8113ff10 <find_file_in_directory+0xc>
8113ff0c:	003b68fa 	trap	3
8113ff10:	dfc01715 	stw	ra,92(sp)
8113ff14:	df001615 	stw	fp,88(sp)
8113ff18:	df001604 	addi	fp,sp,88
8113ff1c:	e13ffd15 	stw	r4,-12(fp)
8113ff20:	e17ffe15 	stw	r5,-8(fp)
8113ff24:	e1bfff15 	stw	r6,-4(fp)
    int location = get_dir_divider_location( file_name );
8113ff28:	e13ffe17 	ldw	r4,-8(fp)
8113ff2c:	113f6600 	call	8113f660 <get_dir_divider_location>
8113ff30:	e0bfea15 	stw	r2,-88(fp)
    int last_dir_separator = 0;
8113ff34:	e03feb15 	stw	zero,-84(fp)
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
8113ff38:	00800804 	movi	r2,32
8113ff3c:	e0bff905 	stb	r2,-28(fp)
8113ff40:	00800804 	movi	r2,32
8113ff44:	e0bff945 	stb	r2,-27(fp)
8113ff48:	00800804 	movi	r2,32
8113ff4c:	e0bff985 	stb	r2,-26(fp)
8113ff50:	00800804 	movi	r2,32
8113ff54:	e0bff9c5 	stb	r2,-25(fp)
8113ff58:	00800804 	movi	r2,32
8113ff5c:	e0bffa05 	stb	r2,-24(fp)
8113ff60:	00800804 	movi	r2,32
8113ff64:	e0bffa45 	stb	r2,-23(fp)
8113ff68:	00800804 	movi	r2,32
8113ff6c:	e0bffa85 	stb	r2,-22(fp)
8113ff70:	00800804 	movi	r2,32
8113ff74:	e0bffac5 	stb	r2,-21(fp)
    char extension[3] = { ' ', ' ', ' ' };
8113ff78:	00800804 	movi	r2,32
8113ff7c:	e0bffb05 	stb	r2,-20(fp)
8113ff80:	00800804 	movi	r2,32
8113ff84:	e0bffb45 	stb	r2,-19(fp)
8113ff88:	00800804 	movi	r2,32
8113ff8c:	e0bffb85 	stb	r2,-18(fp)
    int ext_index = -1;
8113ff90:	00bfffc4 	movi	r2,-1
8113ff94:	e0bfec15 	stw	r2,-80(fp)
    int cluster = directory_start_cluster;
8113ff98:	e0bffd17 	ldw	r2,-12(fp)
8113ff9c:	e0bfed15 	stw	r2,-76(fp)
    int index;
	int length = strlen(file_name);
8113ffa0:	e13ffe17 	ldw	r4,-8(fp)
8113ffa4:	111e5bc0 	call	8111e5bc <strlen>
8113ffa8:	e0bff415 	stw	r2,-48(fp)
    bool result = false;
8113ffac:	e03fef15 	stw	zero,-68(fp)
    
    // Skip through all directory separators.
    while (location > 0)
8113ffb0:	00000b06 	br	8113ffe0 <find_file_in_directory+0xdc>
    {
        last_dir_separator = last_dir_separator+location+1;
8113ffb4:	e0ffeb17 	ldw	r3,-84(fp)
8113ffb8:	e0bfea17 	ldw	r2,-88(fp)
8113ffbc:	1885883a 	add	r2,r3,r2
8113ffc0:	10800044 	addi	r2,r2,1
8113ffc4:	e0bfeb15 	stw	r2,-84(fp)
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
8113ffc8:	e0bfeb17 	ldw	r2,-84(fp)
8113ffcc:	e0fffe17 	ldw	r3,-8(fp)
8113ffd0:	1885883a 	add	r2,r3,r2
8113ffd4:	1009883a 	mov	r4,r2
8113ffd8:	113f6600 	call	8113f660 <get_dir_divider_location>
8113ffdc:	e0bfea15 	stw	r2,-88(fp)
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
8113ffe0:	e0bfea17 	ldw	r2,-88(fp)
8113ffe4:	00bff316 	blt	zero,r2,8113ffb4 <__reset+0xfb11ffb4>
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
8113ffe8:	e0bfeb17 	ldw	r2,-84(fp)
8113ffec:	e0bfee15 	stw	r2,-72(fp)
8113fff0:	00002706 	br	81140090 <find_file_in_directory+0x18c>
    {
        if (file_name[index] == '.')
8113fff4:	e0bfee17 	ldw	r2,-72(fp)
8113fff8:	e0fffe17 	ldw	r3,-8(fp)
8113fffc:	1885883a 	add	r2,r3,r2
81140000:	10800003 	ldbu	r2,0(r2)
81140004:	10803fcc 	andi	r2,r2,255
81140008:	1080201c 	xori	r2,r2,128
8114000c:	10bfe004 	addi	r2,r2,-128
81140010:	10800b98 	cmpnei	r2,r2,46
81140014:	1000031e 	bne	r2,zero,81140024 <find_file_in_directory+0x120>
        {
            ext_index = index;
81140018:	e0bfee17 	ldw	r2,-72(fp)
8114001c:	e0bfec15 	stw	r2,-80(fp)
81140020:	00001806 	br	81140084 <find_file_in_directory+0x180>
        }
        else if (ext_index < 0)
81140024:	e0bfec17 	ldw	r2,-80(fp)
81140028:	10000b0e 	bge	r2,zero,81140058 <find_file_in_directory+0x154>
        {
            name[index-last_dir_separator] = file_name[index];
8114002c:	e0ffee17 	ldw	r3,-72(fp)
81140030:	e0bfeb17 	ldw	r2,-84(fp)
81140034:	1885c83a 	sub	r2,r3,r2
81140038:	e0ffee17 	ldw	r3,-72(fp)
8114003c:	e13ffe17 	ldw	r4,-8(fp)
81140040:	20c7883a 	add	r3,r4,r3
81140044:	18c00003 	ldbu	r3,0(r3)
81140048:	e13ff904 	addi	r4,fp,-28
8114004c:	2085883a 	add	r2,r4,r2
81140050:	10c00005 	stb	r3,0(r2)
81140054:	00000b06 	br	81140084 <find_file_in_directory+0x180>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
81140058:	e0ffee17 	ldw	r3,-72(fp)
8114005c:	e0bfec17 	ldw	r2,-80(fp)
81140060:	1885c83a 	sub	r2,r3,r2
81140064:	10bfffc4 	addi	r2,r2,-1
81140068:	e0ffee17 	ldw	r3,-72(fp)
8114006c:	e13ffe17 	ldw	r4,-8(fp)
81140070:	20c7883a 	add	r3,r4,r3
81140074:	18c00003 	ldbu	r3,0(r3)
81140078:	e13ffb04 	addi	r4,fp,-20
8114007c:	2085883a 	add	r2,r4,r2
81140080:	10c00005 	stb	r3,0(r2)
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
81140084:	e0bfee17 	ldw	r2,-72(fp)
81140088:	10800044 	addi	r2,r2,1
8114008c:	e0bfee15 	stw	r2,-72(fp)
81140090:	e0ffee17 	ldw	r3,-72(fp)
81140094:	e0bff417 	ldw	r2,-48(fp)
81140098:	18bfd616 	blt	r3,r2,8113fff4 <__reset+0xfb11fff4>
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
8114009c:	e0bffd17 	ldw	r2,-12(fp)
811400a0:	1000461e 	bne	r2,zero,811401bc <find_file_in_directory+0x2b8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811400a4:	00a045f4 	movhi	r2,33047
811400a8:	10a13004 	addi	r2,r2,-31552
811400ac:	1080050b 	ldhu	r2,20(r2)
811400b0:	10bfffcc 	andi	r2,r2,65535
811400b4:	1006917a 	slli	r3,r2,5
811400b8:	00a045f4 	movhi	r2,33047
811400bc:	10a13004 	addi	r2,r2,-31552
811400c0:	1080030b 	ldhu	r2,12(r2)
811400c4:	10bfffcc 	andi	r2,r2,65535
811400c8:	1885283a 	div	r2,r3,r2
811400cc:	e0bff715 	stw	r2,-36(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811400d0:	e03ff015 	stw	zero,-64(fp)
811400d4:	00003506 	br	811401ac <find_file_in_directory+0x2a8>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811400d8:	00a045f4 	movhi	r2,33047
811400dc:	10a13004 	addi	r2,r2,-31552
811400e0:	10c01317 	ldw	r3,76(r2)
811400e4:	e0bff017 	ldw	r2,-64(fp)
811400e8:	1885883a 	add	r2,r3,r2
811400ec:	1007883a 	mov	r3,r2
811400f0:	d0a0ad17 	ldw	r2,-32076(gp)
811400f4:	100b883a 	mov	r5,r2
811400f8:	1809883a 	mov	r4,r3
811400fc:	113e25c0 	call	8113e25c <Read_Sector_Data>
81140100:	10009626 	beq	r2,zero,8114035c <find_file_in_directory+0x458>
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81140104:	e03ff115 	stw	zero,-60(fp)
81140108:	00002006 	br	8114018c <find_file_in_directory+0x288>
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
8114010c:	e0bff117 	ldw	r2,-60(fp)
81140110:	1004917a 	slli	r2,r2,5
81140114:	e0fff017 	ldw	r3,-64(fp)
81140118:	180f883a 	mov	r7,r3
8114011c:	000d883a 	mov	r6,zero
81140120:	e17fff17 	ldw	r5,-4(fp)
81140124:	1009883a 	mov	r4,r2
81140128:	113e68c0 	call	8113e68c <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
8114012c:	e0bfff17 	ldw	r2,-4(fp)
81140130:	10800003 	ldbu	r2,0(r2)
81140134:	10803fcc 	andi	r2,r2,255
81140138:	10803960 	cmpeqi	r2,r2,229
8114013c:	1000101e 	bne	r2,zero,81140180 <find_file_in_directory+0x27c>
81140140:	e0bfff17 	ldw	r2,-4(fp)
81140144:	10800003 	ldbu	r2,0(r2)
81140148:	10803fcc 	andi	r2,r2,255
8114014c:	10000c26 	beq	r2,zero,81140180 <find_file_in_directory+0x27c>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
81140150:	e0fffb04 	addi	r3,fp,-20
81140154:	e0bff904 	addi	r2,fp,-28
81140158:	180d883a 	mov	r6,r3
8114015c:	100b883a 	mov	r5,r2
81140160:	e13fff17 	ldw	r4,-4(fp)
81140164:	113f7200 	call	8113f720 <match_file_record_to_name_ext>
81140168:	e0bff815 	stw	r2,-32(fp)

                        if (match)
8114016c:	e0bff817 	ldw	r2,-32(fp)
81140170:	10000326 	beq	r2,zero,81140180 <find_file_in_directory+0x27c>
                        {
                            result = true;
81140174:	00800044 	movi	r2,1
81140178:	e0bfef15 	stw	r2,-68(fp)
                            break;
8114017c:	00000606 	br	81140198 <find_file_in_directory+0x294>
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81140180:	e0bff117 	ldw	r2,-60(fp)
81140184:	10800044 	addi	r2,r2,1
81140188:	e0bff115 	stw	r2,-60(fp)
8114018c:	e0bff117 	ldw	r2,-60(fp)
81140190:	10800410 	cmplti	r2,r2,16
81140194:	103fdd1e 	bne	r2,zero,8114010c <__reset+0xfb12010c>
            }
            else
            {
                break;
            }
            if (result)
81140198:	e0bfef17 	ldw	r2,-68(fp)
8114019c:	1000711e 	bne	r2,zero,81140364 <find_file_in_directory+0x460>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811401a0:	e0bff017 	ldw	r2,-64(fp)
811401a4:	10800044 	addi	r2,r2,1
811401a8:	e0bff015 	stw	r2,-64(fp)
811401ac:	e0fff017 	ldw	r3,-64(fp)
811401b0:	e0bff717 	ldw	r2,-36(fp)
811401b4:	18bfc816 	blt	r3,r2,811400d8 <__reset+0xfb1200d8>
811401b8:	00006b06 	br	81140368 <find_file_in_directory+0x464>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
811401bc:	e0bfed17 	ldw	r2,-76(fp)
811401c0:	10ffff84 	addi	r3,r2,-2
811401c4:	00a045f4 	movhi	r2,33047
811401c8:	10a13004 	addi	r2,r2,-31552
811401cc:	10800383 	ldbu	r2,14(r2)
811401d0:	10803fcc 	andi	r2,r2,255
811401d4:	1885383a 	mul	r2,r3,r2
811401d8:	1007883a 	mov	r3,r2
811401dc:	00a045f4 	movhi	r2,33047
811401e0:	10a13004 	addi	r2,r2,-31552
811401e4:	10801417 	ldw	r2,80(r2)
811401e8:	1885883a 	add	r2,r3,r2
811401ec:	e0bff515 	stw	r2,-44(fp)
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811401f0:	e03ff215 	stw	zero,-56(fp)
811401f4:	00003306 	br	811402c4 <find_file_in_directory+0x3c0>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
811401f8:	e0fff217 	ldw	r3,-56(fp)
811401fc:	e0bff517 	ldw	r2,-44(fp)
81140200:	1885883a 	add	r2,r3,r2
81140204:	d0e0ad17 	ldw	r3,-32076(gp)
81140208:	180b883a 	mov	r5,r3
8114020c:	1009883a 	mov	r4,r2
81140210:	113e25c0 	call	8113e25c <Read_Sector_Data>
81140214:	10003226 	beq	r2,zero,811402e0 <find_file_in_directory+0x3dc>
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81140218:	e03ff315 	stw	zero,-52(fp)
8114021c:	00002106 	br	811402a4 <find_file_in_directory+0x3a0>
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
81140220:	e0bff317 	ldw	r2,-52(fp)
81140224:	1004917a 	slli	r2,r2,5
81140228:	e0ffed17 	ldw	r3,-76(fp)
8114022c:	e13ff217 	ldw	r4,-56(fp)
81140230:	200f883a 	mov	r7,r4
81140234:	180d883a 	mov	r6,r3
81140238:	e17fff17 	ldw	r5,-4(fp)
8114023c:	1009883a 	mov	r4,r2
81140240:	113e68c0 	call	8113e68c <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
81140244:	e0bfff17 	ldw	r2,-4(fp)
81140248:	10800003 	ldbu	r2,0(r2)
8114024c:	10803fcc 	andi	r2,r2,255
81140250:	10803960 	cmpeqi	r2,r2,229
81140254:	1000101e 	bne	r2,zero,81140298 <find_file_in_directory+0x394>
81140258:	e0bfff17 	ldw	r2,-4(fp)
8114025c:	10800003 	ldbu	r2,0(r2)
81140260:	10803fcc 	andi	r2,r2,255
81140264:	10000c26 	beq	r2,zero,81140298 <find_file_in_directory+0x394>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
81140268:	e0fffb04 	addi	r3,fp,-20
8114026c:	e0bff904 	addi	r2,fp,-28
81140270:	180d883a 	mov	r6,r3
81140274:	100b883a 	mov	r5,r2
81140278:	e13fff17 	ldw	r4,-4(fp)
8114027c:	113f7200 	call	8113f720 <match_file_record_to_name_ext>
81140280:	e0bff615 	stw	r2,-40(fp)

                            if (match)
81140284:	e0bff617 	ldw	r2,-40(fp)
81140288:	10000326 	beq	r2,zero,81140298 <find_file_in_directory+0x394>
                            {                               
                                result = true;
8114028c:	00800044 	movi	r2,1
81140290:	e0bfef15 	stw	r2,-68(fp)
                                break;
81140294:	00000606 	br	811402b0 <find_file_in_directory+0x3ac>
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
81140298:	e0bff317 	ldw	r2,-52(fp)
8114029c:	10800044 	addi	r2,r2,1
811402a0:	e0bff315 	stw	r2,-52(fp)
811402a4:	e0bff317 	ldw	r2,-52(fp)
811402a8:	10800410 	cmplti	r2,r2,16
811402ac:	103fdc1e 	bne	r2,zero,81140220 <__reset+0xfb120220>
                }
                else
                {
                    break;
                }
                if (result)
811402b0:	e0bfef17 	ldw	r2,-68(fp)
811402b4:	10000c1e 	bne	r2,zero,811402e8 <find_file_in_directory+0x3e4>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
811402b8:	e0bff217 	ldw	r2,-56(fp)
811402bc:	10800044 	addi	r2,r2,1
811402c0:	e0bff215 	stw	r2,-56(fp)
811402c4:	00a045f4 	movhi	r2,33047
811402c8:	10a13004 	addi	r2,r2,-31552
811402cc:	10800383 	ldbu	r2,14(r2)
811402d0:	10803fcc 	andi	r2,r2,255
811402d4:	e0fff217 	ldw	r3,-56(fp)
811402d8:	18bfc716 	blt	r3,r2,811401f8 <__reset+0xfb1201f8>
811402dc:	00000306 	br	811402ec <find_file_in_directory+0x3e8>
                        }
                    }
                }
                else
                {
                    break;
811402e0:	0001883a 	nop
811402e4:	00000106 	br	811402ec <find_file_in_directory+0x3e8>
                }
                if (result)
                {
                    break;
811402e8:	0001883a 	nop
                }
            }
            // If this is the end of the cluster and the file has not been found, then see if there is another cluster
            // that holds data for the current directory.
            if (result == false)
811402ec:	e0bfef17 	ldw	r2,-68(fp)
811402f0:	1000141e 	bne	r2,zero,81140344 <find_file_in_directory+0x440>
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
811402f4:	e0bfed17 	ldw	r2,-76(fp)
811402f8:	e0fffc04 	addi	r3,fp,-16
811402fc:	180b883a 	mov	r5,r3
81140300:	1009883a 	mov	r4,r2
81140304:	113e33c0 	call	8113e33c <get_cluster_flag>
81140308:	10000c26 	beq	r2,zero,8114033c <find_file_in_directory+0x438>
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8114030c:	e0bffc0b 	ldhu	r2,-16(fp)
81140310:	10bfffcc 	andi	r2,r2,65535
81140314:	10fffe0c 	andi	r3,r2,65528
81140318:	00bffe14 	movui	r2,65528
8114031c:	1880021e 	bne	r3,r2,81140328 <find_file_in_directory+0x424>
					{
						return false;
81140320:	0005883a 	mov	r2,zero
81140324:	00001106 	br	8114036c <find_file_in_directory+0x468>
					}
					cluster = (new_cluster & 0x0000fff8);
81140328:	e0bffc0b 	ldhu	r2,-16(fp)
8114032c:	10bfffcc 	andi	r2,r2,65535
81140330:	10bffe0c 	andi	r2,r2,65528
81140334:	e0bfed15 	stw	r2,-76(fp)
81140338:	00000206 	br	81140344 <find_file_in_directory+0x440>
				}
				else
                {
                    // Directory path is invalid.                 
                    return false;
8114033c:	0005883a 	mov	r2,zero
81140340:	00000a06 	br	8114036c <find_file_in_directory+0x468>
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
81140344:	e0bfed17 	ldw	r2,-76(fp)
81140348:	00fffdd4 	movui	r3,65527
8114034c:	18800616 	blt	r3,r2,81140368 <find_file_in_directory+0x464>
81140350:	e0bfef17 	ldw	r2,-68(fp)
81140354:	103f9926 	beq	r2,zero,811401bc <__reset+0xfb1201bc>
81140358:	00000306 	br	81140368 <find_file_in_directory+0x464>
                    }
                }
            }
            else
            {
                break;
8114035c:	0001883a 	nop
81140360:	00000106 	br	81140368 <find_file_in_directory+0x464>
            }
            if (result)
            {
                break;
81140364:	0001883a 	nop
                }
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
81140368:	e0bfef17 	ldw	r2,-68(fp)
}
8114036c:	e037883a 	mov	sp,fp
81140370:	dfc00117 	ldw	ra,4(sp)
81140374:	df000017 	ldw	fp,0(sp)
81140378:	dec00204 	addi	sp,sp,8
8114037c:	f800283a 	ret

81140380 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
81140380:	defff504 	addi	sp,sp,-44
81140384:	de00012e 	bgeu	sp,et,8114038c <find_first_empty_cluster+0xc>
81140388:	003b68fa 	trap	3
8114038c:	dfc00a15 	stw	ra,40(sp)
81140390:	df000915 	stw	fp,36(sp)
81140394:	df000904 	addi	fp,sp,36
81140398:	e13fff15 	stw	r4,-4(fp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
8114039c:	00a045f4 	movhi	r2,33047
811403a0:	10a13004 	addi	r2,r2,-31552
811403a4:	10801117 	ldw	r2,68(r2)
811403a8:	e0bff715 	stw	r2,-36(fp)
    unsigned int cluster_index = 2;
811403ac:	00800084 	movi	r2,2
811403b0:	e0bff815 	stw	r2,-32(fp)
    short int cluster = -1;
811403b4:	00bfffc4 	movi	r2,-1
811403b8:	e0bff90d 	sth	r2,-28(fp)
    bool result = false;
811403bc:	e03ffa15 	stw	zero,-24(fp)
	unsigned max_cluster_index = 0;
811403c0:	e03ffb15 	stw	zero,-20(fp)
	unsigned int non_data_sectors = boot_sector_data.data_sector_offset;
811403c4:	00a045f4 	movhi	r2,33047
811403c8:	10a13004 	addi	r2,r2,-31552
811403cc:	10801417 	ldw	r2,80(r2)
811403d0:	e0bffc15 	stw	r2,-16(fp)
	unsigned int less_than_32 = boot_sector_data.number_of_sectors_in_partition;
811403d4:	00a045f4 	movhi	r2,33047
811403d8:	10a13004 	addi	r2,r2,-31552
811403dc:	1080058b 	ldhu	r2,22(r2)
811403e0:	10bfffcc 	andi	r2,r2,65535
811403e4:	e0bffd15 	stw	r2,-12(fp)
	unsigned int greater_than_32 = boot_sector_data.total_sector_count_if_above_32MB;
811403e8:	00a045f4 	movhi	r2,33047
811403ec:	10a13004 	addi	r2,r2,-31552
811403f0:	10800917 	ldw	r2,36(r2)
811403f4:	e0bffe15 	stw	r2,-8(fp)

	if (less_than_32 > greater_than_32)
811403f8:	e0bffd17 	ldw	r2,-12(fp)
811403fc:	e0fffe17 	ldw	r3,-8(fp)
81140400:	18800b2e 	bgeu	r3,r2,81140430 <find_first_empty_cluster+0xb0>
	{
		max_cluster_index = ((less_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81140404:	e0fffd17 	ldw	r3,-12(fp)
81140408:	e0bffc17 	ldw	r2,-16(fp)
8114040c:	1887c83a 	sub	r3,r3,r2
81140410:	00a045f4 	movhi	r2,33047
81140414:	10a13004 	addi	r2,r2,-31552
81140418:	10800383 	ldbu	r2,14(r2)
8114041c:	10803fcc 	andi	r2,r2,255
81140420:	1885203a 	divu	r2,r3,r2
81140424:	10800044 	addi	r2,r2,1
81140428:	e0bffb15 	stw	r2,-20(fp)
8114042c:	00002a06 	br	811404d8 <find_first_empty_cluster+0x158>
	}
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
81140430:	e0fffe17 	ldw	r3,-8(fp)
81140434:	e0bffc17 	ldw	r2,-16(fp)
81140438:	1887c83a 	sub	r3,r3,r2
8114043c:	00a045f4 	movhi	r2,33047
81140440:	10a13004 	addi	r2,r2,-31552
81140444:	10800383 	ldbu	r2,14(r2)
81140448:	10803fcc 	andi	r2,r2,255
8114044c:	1885203a 	divu	r2,r3,r2
81140450:	10800044 	addi	r2,r2,1
81140454:	e0bffb15 	stw	r2,-20(fp)
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
81140458:	00001f06 	br	811404d8 <find_first_empty_cluster+0x158>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
8114045c:	e0bff717 	ldw	r2,-36(fp)
81140460:	d0e0ad17 	ldw	r3,-32076(gp)
81140464:	180b883a 	mov	r5,r3
81140468:	1009883a 	mov	r4,r2
8114046c:	113e25c0 	call	8113e25c <Read_Sector_Data>
81140470:	10001426 	beq	r2,zero,811404c4 <find_first_empty_cluster+0x144>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
81140474:	e0bff817 	ldw	r2,-32(fp)
81140478:	10803fcc 	andi	r2,r2,255
8114047c:	1085883a 	add	r2,r2,r2
81140480:	1007883a 	mov	r3,r2
81140484:	d0a0af17 	ldw	r2,-32068(gp)
81140488:	10800a17 	ldw	r2,40(r2)
8114048c:	1885883a 	add	r2,r3,r2
81140490:	1080002b 	ldhuio	r2,0(r2)
81140494:	10bfffcc 	andi	r2,r2,65535
81140498:	e0bff90d 	sth	r2,-28(fp)
                if (cluster == 0)
8114049c:	e0bff90f 	ldh	r2,-28(fp)
811404a0:	10000726 	beq	r2,zero,811404c0 <find_first_empty_cluster+0x140>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
811404a4:	e0bff817 	ldw	r2,-32(fp)
811404a8:	10800044 	addi	r2,r2,1
811404ac:	e0bff815 	stw	r2,-32(fp)
                } 
            } while ((cluster_index % 256) != 0);
811404b0:	e0bff817 	ldw	r2,-32(fp)
811404b4:	10803fcc 	andi	r2,r2,255
811404b8:	103fee1e 	bne	r2,zero,81140474 <__reset+0xfb120474>
811404bc:	00000106 	br	811404c4 <find_first_empty_cluster+0x144>
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
                if (cluster == 0)
                {
                    // Free cluster found.
                    break;
811404c0:	0001883a 	nop
                {
                    cluster_index++;
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
811404c4:	e0bff90f 	ldh	r2,-28(fp)
811404c8:	10000926 	beq	r2,zero,811404f0 <find_first_empty_cluster+0x170>
        {
            break;
        }
        sector++;
811404cc:	e0bff717 	ldw	r2,-36(fp)
811404d0:	10800044 	addi	r2,r2,1
811404d4:	e0bff715 	stw	r2,-36(fp)
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
811404d8:	00a045f4 	movhi	r2,33047
811404dc:	10a13004 	addi	r2,r2,-31552
811404e0:	10c01217 	ldw	r3,72(r2)
811404e4:	e0bff717 	ldw	r2,-36(fp)
811404e8:	18bfdc1e 	bne	r3,r2,8114045c <__reset+0xfb12045c>
811404ec:	00000106 	br	811404f4 <find_first_empty_cluster+0x174>
                } 
            } while ((cluster_index % 256) != 0);
        }
        if (cluster == 0)
        {
            break;
811404f0:	0001883a 	nop
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
811404f4:	e0bff90f 	ldh	r2,-28(fp)
811404f8:	1000081e 	bne	r2,zero,8114051c <find_first_empty_cluster+0x19c>
811404fc:	e0bff90f 	ldh	r2,-28(fp)
81140500:	e0fffb17 	ldw	r3,-20(fp)
81140504:	18800536 	bltu	r3,r2,8114051c <find_first_empty_cluster+0x19c>
    {
        *cluster_number = cluster_index;
81140508:	e0bfff17 	ldw	r2,-4(fp)
8114050c:	e0fff817 	ldw	r3,-32(fp)
81140510:	10c00015 	stw	r3,0(r2)
		result = true;
81140514:	00800044 	movi	r2,1
81140518:	e0bffa15 	stw	r2,-24(fp)
    }
    return result;
8114051c:	e0bffa17 	ldw	r2,-24(fp)
}
81140520:	e037883a 	mov	sp,fp
81140524:	dfc00117 	ldw	ra,4(sp)
81140528:	df000017 	ldw	fp,0(sp)
8114052c:	dec00204 	addi	sp,sp,8
81140530:	f800283a 	ret

81140534 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
81140534:	defff604 	addi	sp,sp,-40
81140538:	de00012e 	bgeu	sp,et,81140540 <find_first_empty_record_in_a_subdirectory+0xc>
8114053c:	003b68fa 	trap	3
81140540:	dfc00915 	stw	ra,36(sp)
81140544:	df000815 	stw	fp,32(sp)
81140548:	df000804 	addi	fp,sp,32
8114054c:	e13fff15 	stw	r4,-4(fp)
    int result = -1;
81140550:	00bfffc4 	movi	r2,-1
81140554:	e0bff815 	stw	r2,-32(fp)
    int cluster = start_cluster_index;
81140558:	e0bfff17 	ldw	r2,-4(fp)
8114055c:	e0bff915 	stw	r2,-28(fp)
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81140560:	e0bff917 	ldw	r2,-28(fp)
81140564:	10ffff84 	addi	r3,r2,-2
81140568:	00a045f4 	movhi	r2,33047
8114056c:	10a13004 	addi	r2,r2,-31552
81140570:	10800383 	ldbu	r2,14(r2)
81140574:	10803fcc 	andi	r2,r2,255
81140578:	1885383a 	mul	r2,r3,r2
8114057c:	1007883a 	mov	r3,r2
81140580:	00a045f4 	movhi	r2,33047
81140584:	10a13004 	addi	r2,r2,-31552
81140588:	10801417 	ldw	r2,80(r2)
8114058c:	1885883a 	add	r2,r3,r2
81140590:	e0bffc15 	stw	r2,-16(fp)
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140594:	e03ffa15 	stw	zero,-24(fp)
81140598:	00002c06 	br	8114064c <find_first_empty_record_in_a_subdirectory+0x118>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
8114059c:	e0fffa17 	ldw	r3,-24(fp)
811405a0:	e0bffc17 	ldw	r2,-16(fp)
811405a4:	1885883a 	add	r2,r3,r2
811405a8:	d0e0ad17 	ldw	r3,-32076(gp)
811405ac:	180b883a 	mov	r5,r3
811405b0:	1009883a 	mov	r4,r2
811405b4:	113e25c0 	call	8113e25c <Read_Sector_Data>
811405b8:	10002b26 	beq	r2,zero,81140668 <find_first_empty_record_in_a_subdirectory+0x134>
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
811405bc:	e03ffb15 	stw	zero,-20(fp)
811405c0:	00001c06 	br	81140634 <find_first_empty_record_in_a_subdirectory+0x100>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
811405c4:	e0bffb17 	ldw	r2,-20(fp)
811405c8:	1004917a 	slli	r2,r2,5
811405cc:	1007883a 	mov	r3,r2
811405d0:	d0a0af17 	ldw	r2,-32068(gp)
811405d4:	10800a17 	ldw	r2,40(r2)
811405d8:	1885883a 	add	r2,r3,r2
811405dc:	10800023 	ldbuio	r2,0(r2)
811405e0:	10803fcc 	andi	r2,r2,255
811405e4:	10803fcc 	andi	r2,r2,255
811405e8:	e0bffd0d 	sth	r2,-12(fp)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
811405ec:	e0bffd0b 	ldhu	r2,-12(fp)
811405f0:	10803960 	cmpeqi	r2,r2,229
811405f4:	1000021e 	bne	r2,zero,81140600 <find_first_empty_record_in_a_subdirectory+0xcc>
811405f8:	e0bffd0b 	ldhu	r2,-12(fp)
811405fc:	10000a1e 	bne	r2,zero,81140628 <find_first_empty_record_in_a_subdirectory+0xf4>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
81140600:	e0bffa17 	ldw	r2,-24(fp)
81140604:	1006913a 	slli	r3,r2,4
81140608:	e0bffb17 	ldw	r2,-20(fp)
8114060c:	1885883a 	add	r2,r3,r2
81140610:	1006943a 	slli	r3,r2,16
81140614:	e0bff917 	ldw	r2,-28(fp)
81140618:	1884b03a 	or	r2,r3,r2
8114061c:	e0bff815 	stw	r2,-32(fp)
                        return result;
81140620:	e0bff817 	ldw	r2,-32(fp)
81140624:	00005306 	br	81140774 <find_first_empty_record_in_a_subdirectory+0x240>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
81140628:	e0bffb17 	ldw	r2,-20(fp)
8114062c:	10800044 	addi	r2,r2,1
81140630:	e0bffb15 	stw	r2,-20(fp)
81140634:	e0bffb17 	ldw	r2,-20(fp)
81140638:	10800410 	cmplti	r2,r2,16
8114063c:	103fe11e 	bne	r2,zero,811405c4 <__reset+0xfb1205c4>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81140640:	e0bffa17 	ldw	r2,-24(fp)
81140644:	10800044 	addi	r2,r2,1
81140648:	e0bffa15 	stw	r2,-24(fp)
8114064c:	00a045f4 	movhi	r2,33047
81140650:	10a13004 	addi	r2,r2,-31552
81140654:	10800383 	ldbu	r2,14(r2)
81140658:	10803fcc 	andi	r2,r2,255
8114065c:	e0fffa17 	ldw	r3,-24(fp)
81140660:	18bfce16 	blt	r3,r2,8114059c <__reset+0xfb12059c>
81140664:	00000106 	br	8114066c <find_first_empty_record_in_a_subdirectory+0x138>
                    }
                }
            }
            else
            {
                break;
81140668:	0001883a 	nop
            }
        }
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
8114066c:	e0bff817 	ldw	r2,-32(fp)
81140670:	1000390e 	bge	r2,zero,81140758 <find_first_empty_record_in_a_subdirectory+0x224>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
81140674:	e0bff917 	ldw	r2,-28(fp)
81140678:	e0fffd84 	addi	r3,fp,-10
8114067c:	180b883a 	mov	r5,r3
81140680:	1009883a 	mov	r4,r2
81140684:	113e33c0 	call	8113e33c <get_cluster_flag>
81140688:	10003126 	beq	r2,zero,81140750 <find_first_empty_record_in_a_subdirectory+0x21c>
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
8114068c:	e0bffd8b 	ldhu	r2,-10(fp)
81140690:	10bfffcc 	andi	r2,r2,65535
81140694:	10fffe0c 	andi	r3,r2,65528
81140698:	00bffe14 	movui	r2,65528
8114069c:	18802e1e 	bne	r3,r2,81140758 <find_first_empty_record_in_a_subdirectory+0x224>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
811406a0:	e0bffe04 	addi	r2,fp,-8
811406a4:	1009883a 	mov	r4,r2
811406a8:	11403800 	call	81140380 <find_first_empty_cluster>
811406ac:	10002326 	beq	r2,zero,8114073c <find_first_empty_record_in_a_subdirectory+0x208>
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811406b0:	e0bff917 	ldw	r2,-28(fp)
811406b4:	e0fffe17 	ldw	r3,-8(fp)
811406b8:	18ffffcc 	andi	r3,r3,65535
811406bc:	18e0001c 	xori	r3,r3,32768
811406c0:	18e00004 	addi	r3,r3,-32768
811406c4:	01800044 	movi	r6,1
811406c8:	180b883a 	mov	r5,r3
811406cc:	1009883a 	mov	r4,r2
811406d0:	113e3f80 	call	8113e3f8 <mark_cluster>
811406d4:	10001926 	beq	r2,zero,8114073c <find_first_empty_record_in_a_subdirectory+0x208>
811406d8:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
811406dc:	01800044 	movi	r6,1
811406e0:	017fffc4 	movi	r5,-1
811406e4:	1009883a 	mov	r4,r2
811406e8:	113e3f80 	call	8113e3f8 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
811406ec:	10001326 	beq	r2,zero,8114073c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
811406f0:	e0bff917 	ldw	r2,-28(fp)
811406f4:	e0fffe17 	ldw	r3,-8(fp)
811406f8:	18ffffcc 	andi	r3,r3,65535
811406fc:	18e0001c 	xori	r3,r3,32768
81140700:	18e00004 	addi	r3,r3,-32768
81140704:	000d883a 	mov	r6,zero
81140708:	180b883a 	mov	r5,r3
8114070c:	1009883a 	mov	r4,r2
81140710:	113e3f80 	call	8113e3f8 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
81140714:	10000926 	beq	r2,zero,8114073c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
81140718:	e0bffe17 	ldw	r2,-8(fp)
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
8114071c:	000d883a 	mov	r6,zero
81140720:	017fffc4 	movi	r5,-1
81140724:	1009883a 	mov	r4,r2
81140728:	113e3f80 	call	8113e3f8 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
8114072c:	10000326 	beq	r2,zero,8114073c <find_first_empty_record_in_a_subdirectory+0x208>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
81140730:	113e2080 	call	8113e208 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
81140734:	e0bffe17 	ldw	r2,-8(fp)
81140738:	e0bff815 	stw	r2,-32(fp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
8114073c:	e0bffd8b 	ldhu	r2,-10(fp)
81140740:	10bfffcc 	andi	r2,r2,65535
81140744:	10bffe0c 	andi	r2,r2,65528
81140748:	e0bff915 	stw	r2,-28(fp)
8114074c:	00000206 	br	81140758 <find_first_empty_record_in_a_subdirectory+0x224>
				}
			}
			else
			{
				// Error encountered.                 
				result = -1;
81140750:	00bfffc4 	movi	r2,-1
81140754:	e0bff815 	stw	r2,-32(fp)
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
81140758:	e0bff917 	ldw	r2,-28(fp)
8114075c:	00fffdd4 	movui	r3,65527
81140760:	18800316 	blt	r3,r2,81140770 <find_first_empty_record_in_a_subdirectory+0x23c>
81140764:	e0bff817 	ldw	r2,-32(fp)
81140768:	10bfffe0 	cmpeqi	r2,r2,-1
8114076c:	103f7c1e 	bne	r2,zero,81140560 <__reset+0xfb120560>
    return result; 
81140770:	e0bff817 	ldw	r2,-32(fp)
}
81140774:	e037883a 	mov	sp,fp
81140778:	dfc00117 	ldw	ra,4(sp)
8114077c:	df000017 	ldw	fp,0(sp)
81140780:	dec00204 	addi	sp,sp,8
81140784:	f800283a 	ret

81140788 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
81140788:	defff904 	addi	sp,sp,-28
8114078c:	de00012e 	bgeu	sp,et,81140794 <find_first_empty_record_in_root_directory+0xc>
81140790:	003b68fa 	trap	3
81140794:	dfc00615 	stw	ra,24(sp)
81140798:	df000515 	stw	fp,20(sp)
8114079c:	df000504 	addi	fp,sp,20
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811407a0:	00a045f4 	movhi	r2,33047
811407a4:	10a13004 	addi	r2,r2,-31552
811407a8:	1080050b 	ldhu	r2,20(r2)
811407ac:	10bfffcc 	andi	r2,r2,65535
811407b0:	1006917a 	slli	r3,r2,5
811407b4:	00a045f4 	movhi	r2,33047
811407b8:	10a13004 	addi	r2,r2,-31552
811407bc:	1080030b 	ldhu	r2,12(r2)
811407c0:	10bfffcc 	andi	r2,r2,65535
811407c4:	1885283a 	div	r2,r3,r2
811407c8:	e0bffd15 	stw	r2,-12(fp)
    int sector_index;
    int result = -1;
811407cc:	00bfffc4 	movi	r2,-1
811407d0:	e0bffe15 	stw	r2,-8(fp)
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
811407d4:	e03ffb15 	stw	zero,-20(fp)
811407d8:	00002d06 	br	81140890 <find_first_empty_record_in_root_directory+0x108>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
811407dc:	00a045f4 	movhi	r2,33047
811407e0:	10a13004 	addi	r2,r2,-31552
811407e4:	10c01317 	ldw	r3,76(r2)
811407e8:	e0bffb17 	ldw	r2,-20(fp)
811407ec:	1885883a 	add	r2,r3,r2
811407f0:	1007883a 	mov	r3,r2
811407f4:	d0a0ad17 	ldw	r2,-32076(gp)
811407f8:	100b883a 	mov	r5,r2
811407fc:	1809883a 	mov	r4,r3
81140800:	113e25c0 	call	8113e25c <Read_Sector_Data>
81140804:	10002626 	beq	r2,zero,811408a0 <find_first_empty_record_in_root_directory+0x118>
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
81140808:	e03ffc15 	stw	zero,-16(fp)
8114080c:	00001a06 	br	81140878 <find_first_empty_record_in_root_directory+0xf0>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
81140810:	e0bffc17 	ldw	r2,-16(fp)
81140814:	1004917a 	slli	r2,r2,5
81140818:	1007883a 	mov	r3,r2
8114081c:	d0a0af17 	ldw	r2,-32068(gp)
81140820:	10800a17 	ldw	r2,40(r2)
81140824:	1885883a 	add	r2,r3,r2
81140828:	10800023 	ldbuio	r2,0(r2)
8114082c:	10803fcc 	andi	r2,r2,255
81140830:	10803fcc 	andi	r2,r2,255
81140834:	e0bfff0d 	sth	r2,-4(fp)
                if ((leading_char == 0x00e5) || (leading_char == 0))
81140838:	e0bfff0b 	ldhu	r2,-4(fp)
8114083c:	10803960 	cmpeqi	r2,r2,229
81140840:	1000021e 	bne	r2,zero,8114084c <find_first_empty_record_in_root_directory+0xc4>
81140844:	e0bfff0b 	ldhu	r2,-4(fp)
81140848:	1000081e 	bne	r2,zero,8114086c <find_first_empty_record_in_root_directory+0xe4>
                {
                    result = (sector_index*16 + file_counter) << 16;
8114084c:	e0bffb17 	ldw	r2,-20(fp)
81140850:	1006913a 	slli	r3,r2,4
81140854:	e0bffc17 	ldw	r2,-16(fp)
81140858:	1885883a 	add	r2,r3,r2
8114085c:	1004943a 	slli	r2,r2,16
81140860:	e0bffe15 	stw	r2,-8(fp)
                    return result;
81140864:	e0bffe17 	ldw	r2,-8(fp)
81140868:	00000f06 	br	811408a8 <find_first_empty_record_in_root_directory+0x120>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
8114086c:	e0bffc17 	ldw	r2,-16(fp)
81140870:	10800044 	addi	r2,r2,1
81140874:	e0bffc15 	stw	r2,-16(fp)
81140878:	e0bffc17 	ldw	r2,-16(fp)
8114087c:	10800410 	cmplti	r2,r2,16
81140880:	103fe31e 	bne	r2,zero,81140810 <__reset+0xfb120810>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
81140884:	e0bffb17 	ldw	r2,-20(fp)
81140888:	10800044 	addi	r2,r2,1
8114088c:	e0bffb15 	stw	r2,-20(fp)
81140890:	e0fffb17 	ldw	r3,-20(fp)
81140894:	e0bffd17 	ldw	r2,-12(fp)
81140898:	18bfd016 	blt	r3,r2,811407dc <__reset+0xfb1207dc>
8114089c:	00000106 	br	811408a4 <find_first_empty_record_in_root_directory+0x11c>
                }
            }
        }
        else
        {
            break;
811408a0:	0001883a 	nop
        }
    }
    return result;
811408a4:	e0bffe17 	ldw	r2,-8(fp)
}
811408a8:	e037883a 	mov	sp,fp
811408ac:	dfc00117 	ldw	ra,4(sp)
811408b0:	df000017 	ldw	fp,0(sp)
811408b4:	dec00204 	addi	sp,sp,8
811408b8:	f800283a 	ret

811408bc <convert_filename_to_name_extension>:

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
811408bc:	defffa04 	addi	sp,sp,-24
811408c0:	de00012e 	bgeu	sp,et,811408c8 <convert_filename_to_name_extension+0xc>
811408c4:	003b68fa 	trap	3
811408c8:	df000515 	stw	fp,20(sp)
811408cc:	df000504 	addi	fp,sp,20
811408d0:	e13ffd15 	stw	r4,-12(fp)
811408d4:	e17ffe15 	stw	r5,-8(fp)
811408d8:	e1bfff15 	stw	r6,-4(fp)
    int counter;
    int local = 0;
811408dc:	e03ffc15 	stw	zero,-16(fp)
    
    for(counter = 0; counter < 8; counter++)
811408e0:	e03ffb15 	stw	zero,-20(fp)
811408e4:	00002506 	br	8114097c <convert_filename_to_name_extension+0xc0>
    {
        if (filename[local] != '.')
811408e8:	e0bffc17 	ldw	r2,-16(fp)
811408ec:	e0fffd17 	ldw	r3,-12(fp)
811408f0:	1885883a 	add	r2,r3,r2
811408f4:	10800003 	ldbu	r2,0(r2)
811408f8:	10803fcc 	andi	r2,r2,255
811408fc:	1080201c 	xori	r2,r2,128
81140900:	10bfe004 	addi	r2,r2,-128
81140904:	10800ba0 	cmpeqi	r2,r2,46
81140908:	1000141e 	bne	r2,zero,8114095c <convert_filename_to_name_extension+0xa0>
        {
            name[counter] = filename[local];
8114090c:	e0bffb17 	ldw	r2,-20(fp)
81140910:	e0fffe17 	ldw	r3,-8(fp)
81140914:	1885883a 	add	r2,r3,r2
81140918:	e0fffc17 	ldw	r3,-16(fp)
8114091c:	e13ffd17 	ldw	r4,-12(fp)
81140920:	20c7883a 	add	r3,r4,r3
81140924:	18c00003 	ldbu	r3,0(r3)
81140928:	10c00005 	stb	r3,0(r2)
            if (filename[local] != 0) local++;
8114092c:	e0bffc17 	ldw	r2,-16(fp)
81140930:	e0fffd17 	ldw	r3,-12(fp)
81140934:	1885883a 	add	r2,r3,r2
81140938:	10800003 	ldbu	r2,0(r2)
8114093c:	10803fcc 	andi	r2,r2,255
81140940:	1080201c 	xori	r2,r2,128
81140944:	10bfe004 	addi	r2,r2,-128
81140948:	10000926 	beq	r2,zero,81140970 <convert_filename_to_name_extension+0xb4>
8114094c:	e0bffc17 	ldw	r2,-16(fp)
81140950:	10800044 	addi	r2,r2,1
81140954:	e0bffc15 	stw	r2,-16(fp)
81140958:	00000506 	br	81140970 <convert_filename_to_name_extension+0xb4>
        }
        else
        {
            name[counter] = ' ';
8114095c:	e0bffb17 	ldw	r2,-20(fp)
81140960:	e0fffe17 	ldw	r3,-8(fp)
81140964:	1885883a 	add	r2,r3,r2
81140968:	00c00804 	movi	r3,32
8114096c:	10c00005 	stb	r3,0(r2)
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
81140970:	e0bffb17 	ldw	r2,-20(fp)
81140974:	10800044 	addi	r2,r2,1
81140978:	e0bffb15 	stw	r2,-20(fp)
8114097c:	e0bffb17 	ldw	r2,-20(fp)
81140980:	10800210 	cmplti	r2,r2,8
81140984:	103fd81e 	bne	r2,zero,811408e8 <__reset+0xfb1208e8>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
81140988:	e0bffc17 	ldw	r2,-16(fp)
8114098c:	e0fffd17 	ldw	r3,-12(fp)
81140990:	1885883a 	add	r2,r3,r2
81140994:	10800003 	ldbu	r2,0(r2)
81140998:	10803fcc 	andi	r2,r2,255
8114099c:	1080201c 	xori	r2,r2,128
811409a0:	10bfe004 	addi	r2,r2,-128
811409a4:	10800b98 	cmpnei	r2,r2,46
811409a8:	1000031e 	bne	r2,zero,811409b8 <convert_filename_to_name_extension+0xfc>
811409ac:	e0bffc17 	ldw	r2,-16(fp)
811409b0:	10800044 	addi	r2,r2,1
811409b4:	e0bffc15 	stw	r2,-16(fp)
    for(counter = 0; counter < 3; counter++)
811409b8:	e03ffb15 	stw	zero,-20(fp)
811409bc:	00001c06 	br	81140a30 <convert_filename_to_name_extension+0x174>
    {
        if (filename[local] != 0)
811409c0:	e0bffc17 	ldw	r2,-16(fp)
811409c4:	e0fffd17 	ldw	r3,-12(fp)
811409c8:	1885883a 	add	r2,r3,r2
811409cc:	10800003 	ldbu	r2,0(r2)
811409d0:	10803fcc 	andi	r2,r2,255
811409d4:	1080201c 	xori	r2,r2,128
811409d8:	10bfe004 	addi	r2,r2,-128
811409dc:	10000c26 	beq	r2,zero,81140a10 <convert_filename_to_name_extension+0x154>
        {
            extension[counter] = filename[local];
811409e0:	e0bffb17 	ldw	r2,-20(fp)
811409e4:	e0ffff17 	ldw	r3,-4(fp)
811409e8:	1885883a 	add	r2,r3,r2
811409ec:	e0fffc17 	ldw	r3,-16(fp)
811409f0:	e13ffd17 	ldw	r4,-12(fp)
811409f4:	20c7883a 	add	r3,r4,r3
811409f8:	18c00003 	ldbu	r3,0(r3)
811409fc:	10c00005 	stb	r3,0(r2)
            local++;
81140a00:	e0bffc17 	ldw	r2,-16(fp)
81140a04:	10800044 	addi	r2,r2,1
81140a08:	e0bffc15 	stw	r2,-16(fp)
81140a0c:	00000506 	br	81140a24 <convert_filename_to_name_extension+0x168>
        }
        else
        {
            extension[counter] = ' ';
81140a10:	e0bffb17 	ldw	r2,-20(fp)
81140a14:	e0ffff17 	ldw	r3,-4(fp)
81140a18:	1885883a 	add	r2,r3,r2
81140a1c:	00c00804 	movi	r3,32
81140a20:	10c00005 	stb	r3,0(r2)
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
81140a24:	e0bffb17 	ldw	r2,-20(fp)
81140a28:	10800044 	addi	r2,r2,1
81140a2c:	e0bffb15 	stw	r2,-20(fp)
81140a30:	e0bffb17 	ldw	r2,-20(fp)
81140a34:	108000d0 	cmplti	r2,r2,3
81140a38:	103fe11e 	bne	r2,zero,811409c0 <__reset+0xfb1209c0>
        {
            extension[counter] = ' ';
        }
    }

}
81140a3c:	0001883a 	nop
81140a40:	e037883a 	mov	sp,fp
81140a44:	df000017 	ldw	fp,0(sp)
81140a48:	dec00104 	addi	sp,sp,4
81140a4c:	f800283a 	ret

81140a50 <create_file>:

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
81140a50:	defff504 	addi	sp,sp,-44
81140a54:	de00012e 	bgeu	sp,et,81140a5c <create_file+0xc>
81140a58:	003b68fa 	trap	3
81140a5c:	dfc00a15 	stw	ra,40(sp)
81140a60:	df000915 	stw	fp,36(sp)
81140a64:	df000904 	addi	fp,sp,36
81140a68:	e13ffd15 	stw	r4,-12(fp)
81140a6c:	e17ffe15 	stw	r5,-8(fp)
81140a70:	e1bfff15 	stw	r6,-4(fp)
    unsigned int cluster_number;
    bool result = false;
81140a74:	e03ff715 	stw	zero,-36(fp)
    
    if (find_first_empty_cluster(&cluster_number))
81140a78:	e0bffc04 	addi	r2,fp,-16
81140a7c:	1009883a 	mov	r4,r2
81140a80:	11403800 	call	81140380 <find_first_empty_cluster>
81140a84:	1000a026 	beq	r2,zero,81140d08 <create_file+0x2b8>
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
81140a88:	e0bfff17 	ldw	r2,-4(fp)
81140a8c:	10800a17 	ldw	r2,40(r2)
81140a90:	1000031e 	bne	r2,zero,81140aa0 <create_file+0x50>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
81140a94:	11407880 	call	81140788 <find_first_empty_record_in_root_directory>
81140a98:	e0bff815 	stw	r2,-32(fp)
81140a9c:	00000606 	br	81140ab8 <create_file+0x68>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
81140aa0:	e0bfff17 	ldw	r2,-4(fp)
81140aa4:	1080058b 	ldhu	r2,22(r2)
81140aa8:	10bfffcc 	andi	r2,r2,65535
81140aac:	1009883a 	mov	r4,r2
81140ab0:	11405340 	call	81140534 <find_first_empty_record_in_a_subdirectory>
81140ab4:	e0bff815 	stw	r2,-32(fp)
        }
        if (record_index >= 0)
81140ab8:	e0bff817 	ldw	r2,-32(fp)
81140abc:	10009216 	blt	r2,zero,81140d08 <create_file+0x2b8>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
81140ac0:	e13ffd17 	ldw	r4,-12(fp)
81140ac4:	113f6600 	call	8113f660 <get_dir_divider_location>
81140ac8:	e0bff915 	stw	r2,-28(fp)
            int last_dir_separator = 0;
81140acc:	e03ffa15 	stw	zero,-24(fp)

            // Skip through all directory separators.
            while (location > 0)
81140ad0:	00000b06 	br	81140b00 <create_file+0xb0>
            {
                last_dir_separator = last_dir_separator+location+1;
81140ad4:	e0fffa17 	ldw	r3,-24(fp)
81140ad8:	e0bff917 	ldw	r2,-28(fp)
81140adc:	1885883a 	add	r2,r3,r2
81140ae0:	10800044 	addi	r2,r2,1
81140ae4:	e0bffa15 	stw	r2,-24(fp)
                location = get_dir_divider_location( &(name[last_dir_separator]) );
81140ae8:	e0bffa17 	ldw	r2,-24(fp)
81140aec:	e0fffd17 	ldw	r3,-12(fp)
81140af0:	1885883a 	add	r2,r3,r2
81140af4:	1009883a 	mov	r4,r2
81140af8:	113f6600 	call	8113f660 <get_dir_divider_location>
81140afc:	e0bff915 	stw	r2,-28(fp)
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
            int last_dir_separator = 0;

            // Skip through all directory separators.
            while (location > 0)
81140b00:	e0bff917 	ldw	r2,-28(fp)
81140b04:	00bff316 	blt	zero,r2,81140ad4 <__reset+0xfb120ad4>
            {
                last_dir_separator = last_dir_separator+location+1;
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
81140b08:	e0bffa17 	ldw	r2,-24(fp)
81140b0c:	e0fffd17 	ldw	r3,-12(fp)
81140b10:	1887883a 	add	r3,r3,r2
81140b14:	e13ffe17 	ldw	r4,-8(fp)
81140b18:	e0bffe17 	ldw	r2,-8(fp)
81140b1c:	10800204 	addi	r2,r2,8
81140b20:	100d883a 	mov	r6,r2
81140b24:	200b883a 	mov	r5,r4
81140b28:	1809883a 	mov	r4,r3
81140b2c:	11408bc0 	call	811408bc <convert_filename_to_name_extension>
                         
            file_record->attributes = 0;
81140b30:	e0bffe17 	ldw	r2,-8(fp)
81140b34:	100002c5 	stb	zero,11(r2)
            file_record->create_time = 0;
81140b38:	e0bffe17 	ldw	r2,-8(fp)
81140b3c:	1000030d 	sth	zero,12(r2)
            file_record->create_date = 0;
81140b40:	e0bffe17 	ldw	r2,-8(fp)
81140b44:	1000038d 	sth	zero,14(r2)
            file_record->last_access_date = 0;
81140b48:	e0bffe17 	ldw	r2,-8(fp)
81140b4c:	1000040d 	sth	zero,16(r2)
            file_record->last_modified_time = 0;
81140b50:	e0bffe17 	ldw	r2,-8(fp)
81140b54:	1000048d 	sth	zero,18(r2)
            file_record->last_modified_date = 0;
81140b58:	e0bffe17 	ldw	r2,-8(fp)
81140b5c:	1000050d 	sth	zero,20(r2)
            file_record->start_cluster_index = cluster_number;
81140b60:	e0bffc17 	ldw	r2,-16(fp)
81140b64:	1007883a 	mov	r3,r2
81140b68:	e0bffe17 	ldw	r2,-8(fp)
81140b6c:	10c0058d 	sth	r3,22(r2)
            file_record->file_size_in_bytes = 0;
81140b70:	e0bffe17 	ldw	r2,-8(fp)
81140b74:	10000615 	stw	zero,24(r2)
            file_record->current_cluster_index = cluster_number;
81140b78:	e0fffc17 	ldw	r3,-16(fp)
81140b7c:	e0bffe17 	ldw	r2,-8(fp)
81140b80:	10c00715 	stw	r3,28(r2)
            file_record->current_sector_in_cluster = 0;
81140b84:	e0bffe17 	ldw	r2,-8(fp)
81140b88:	10000815 	stw	zero,32(r2)
            file_record->current_byte_position = 0;
81140b8c:	e0bffe17 	ldw	r2,-8(fp)
81140b90:	10000915 	stw	zero,36(r2)
            file_record->file_record_cluster = record_index & 0x0000ffff;
81140b94:	e0bff817 	ldw	r2,-32(fp)
81140b98:	10ffffcc 	andi	r3,r2,65535
81140b9c:	e0bffe17 	ldw	r2,-8(fp)
81140ba0:	10c00a15 	stw	r3,40(r2)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
81140ba4:	e0bff817 	ldw	r2,-32(fp)
81140ba8:	1004d43a 	srli	r2,r2,16
81140bac:	1000010e 	bge	r2,zero,81140bb4 <create_file+0x164>
81140bb0:	108003c4 	addi	r2,r2,15
81140bb4:	1005d13a 	srai	r2,r2,4
81140bb8:	1007883a 	mov	r3,r2
81140bbc:	e0bffe17 	ldw	r2,-8(fp)
81140bc0:	10c00b15 	stw	r3,44(r2)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
81140bc4:	e0bff817 	ldw	r2,-32(fp)
81140bc8:	1004d43a 	srli	r2,r2,16
81140bcc:	1007883a 	mov	r3,r2
81140bd0:	00a00034 	movhi	r2,32768
81140bd4:	108003c4 	addi	r2,r2,15
81140bd8:	1884703a 	and	r2,r3,r2
81140bdc:	1000040e 	bge	r2,zero,81140bf0 <create_file+0x1a0>
81140be0:	10bfffc4 	addi	r2,r2,-1
81140be4:	00fffc04 	movi	r3,-16
81140be8:	10c4b03a 	or	r2,r2,r3
81140bec:	10800044 	addi	r2,r2,1
81140bf0:	1004917a 	slli	r2,r2,5
81140bf4:	1007883a 	mov	r3,r2
81140bf8:	e0bffe17 	ldw	r2,-8(fp)
81140bfc:	10c00c0d 	sth	r3,48(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
81140c00:	e0bfff17 	ldw	r2,-4(fp)
81140c04:	1080058b 	ldhu	r2,22(r2)
81140c08:	10ffffcc 	andi	r3,r2,65535
81140c0c:	e0bffe17 	ldw	r2,-8(fp)
81140c10:	10c00d15 	stw	r3,52(r2)
            file_record->in_use = true;
81140c14:	e0bffe17 	ldw	r2,-8(fp)
81140c18:	00c00044 	movi	r3,1
81140c1c:	10c00f15 	stw	r3,60(r2)
            file_record->modified = true;
81140c20:	e0bffe17 	ldw	r2,-8(fp)
81140c24:	00c00044 	movi	r3,1
81140c28:	10c00e15 	stw	r3,56(r2)
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81140c2c:	e0bffe17 	ldw	r2,-8(fp)
81140c30:	10800a17 	ldw	r2,40(r2)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81140c34:	1000071e 	bne	r2,zero,81140c54 <create_file+0x204>
81140c38:	00a045f4 	movhi	r2,33047
81140c3c:	10a13004 	addi	r2,r2,-31552
81140c40:	10c01317 	ldw	r3,76(r2)
81140c44:	e0bffe17 	ldw	r2,-8(fp)
81140c48:	10800b17 	ldw	r2,44(r2)
81140c4c:	1885883a 	add	r2,r3,r2
81140c50:	00000f06 	br	81140c90 <create_file+0x240>
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
81140c54:	00a045f4 	movhi	r2,33047
81140c58:	10a13004 	addi	r2,r2,-31552
81140c5c:	10c01417 	ldw	r3,80(r2)
81140c60:	e0bffe17 	ldw	r2,-8(fp)
81140c64:	10800a17 	ldw	r2,40(r2)
81140c68:	113fff84 	addi	r4,r2,-2
81140c6c:	00a045f4 	movhi	r2,33047
81140c70:	10a13004 	addi	r2,r2,-31552
81140c74:	10800383 	ldbu	r2,14(r2)
81140c78:	10803fcc 	andi	r2,r2,255
81140c7c:	2085383a 	mul	r2,r4,r2
81140c80:	1887883a 	add	r3,r3,r2
                                     file_record->file_record_sector_in_cluster);
81140c84:	e0bffe17 	ldw	r2,-8(fp)
81140c88:	10800b17 	ldw	r2,44(r2)
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
81140c8c:	1885883a 	add	r2,r3,r2
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
            file_record->modified = true;
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
81140c90:	e0bffb15 	stw	r2,-20(fp)
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
81140c94:	e0bffb17 	ldw	r2,-20(fp)
81140c98:	d0e0ad17 	ldw	r3,-32076(gp)
81140c9c:	180b883a 	mov	r5,r3
81140ca0:	1009883a 	mov	r4,r2
81140ca4:	113e25c0 	call	8113e25c <Read_Sector_Data>
81140ca8:	10001726 	beq	r2,zero,81140d08 <create_file+0x2b8>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
81140cac:	e0bffe17 	ldw	r2,-8(fp)
81140cb0:	10800c0b 	ldhu	r2,48(r2)
81140cb4:	10bfffcc 	andi	r2,r2,65535
81140cb8:	10a0001c 	xori	r2,r2,32768
81140cbc:	10a00004 	addi	r2,r2,-32768
81140cc0:	e17ffe17 	ldw	r5,-8(fp)
81140cc4:	1009883a 	mov	r4,r2
81140cc8:	113e9100 	call	8113e910 <Write_File_Record_At_Offset>
81140ccc:	10000e26 	beq	r2,zero,81140d08 <create_file+0x2b8>
                {
                    Save_Modified_Sector();
81140cd0:	113e2080 	call	8113e208 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
81140cd4:	e0bffc17 	ldw	r2,-16(fp)
81140cd8:	01800044 	movi	r6,1
81140cdc:	017fffc4 	movi	r5,-1
81140ce0:	1009883a 	mov	r4,r2
81140ce4:	113e3f80 	call	8113e3f8 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
81140ce8:	e0bffc17 	ldw	r2,-16(fp)
81140cec:	000d883a 	mov	r6,zero
81140cf0:	017fffc4 	movi	r5,-1
81140cf4:	1009883a 	mov	r4,r2
81140cf8:	113e3f80 	call	8113e3f8 <mark_cluster>
81140cfc:	10000226 	beq	r2,zero,81140d08 <create_file+0x2b8>
                    {
                        result = true;
81140d00:	00800044 	movi	r2,1
81140d04:	e0bff715 	stw	r2,-36(fp)
                }
            }
        }

    }
    return result;           
81140d08:	e0bff717 	ldw	r2,-36(fp)
}
81140d0c:	e037883a 	mov	sp,fp
81140d10:	dfc00117 	ldw	ra,4(sp)
81140d14:	df000017 	ldw	fp,0(sp)
81140d18:	dec00204 	addi	sp,sp,8
81140d1c:	f800283a 	ret

81140d20 <copy_file_record_name_to_string>:


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
81140d20:	defffb04 	addi	sp,sp,-20
81140d24:	de00012e 	bgeu	sp,et,81140d2c <copy_file_record_name_to_string+0xc>
81140d28:	003b68fa 	trap	3
81140d2c:	df000415 	stw	fp,16(sp)
81140d30:	df000404 	addi	fp,sp,16
81140d34:	e13ffe15 	stw	r4,-8(fp)
81140d38:	e17fff15 	stw	r5,-4(fp)
	int index;
	int flength = 0;
81140d3c:	e03ffd15 	stw	zero,-12(fp)

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81140d40:	e03ffc15 	stw	zero,-16(fp)
81140d44:	00001506 	br	81140d9c <copy_file_record_name_to_string+0x7c>
	{
		if (file_record->name[index] != ' ')
81140d48:	e0fffe17 	ldw	r3,-8(fp)
81140d4c:	e0bffc17 	ldw	r2,-16(fp)
81140d50:	1885883a 	add	r2,r3,r2
81140d54:	10800003 	ldbu	r2,0(r2)
81140d58:	10803fcc 	andi	r2,r2,255
81140d5c:	10800820 	cmpeqi	r2,r2,32
81140d60:	10000b1e 	bne	r2,zero,81140d90 <copy_file_record_name_to_string+0x70>
		{
			file_name[flength] = file_record->name[index];
81140d64:	e0bffd17 	ldw	r2,-12(fp)
81140d68:	e0ffff17 	ldw	r3,-4(fp)
81140d6c:	1885883a 	add	r2,r3,r2
81140d70:	e13ffe17 	ldw	r4,-8(fp)
81140d74:	e0fffc17 	ldw	r3,-16(fp)
81140d78:	20c7883a 	add	r3,r4,r3
81140d7c:	18c00003 	ldbu	r3,0(r3)
81140d80:	10c00005 	stb	r3,0(r2)
			flength = flength + 1;
81140d84:	e0bffd17 	ldw	r2,-12(fp)
81140d88:	10800044 	addi	r2,r2,1
81140d8c:	e0bffd15 	stw	r2,-12(fp)
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
81140d90:	e0bffc17 	ldw	r2,-16(fp)
81140d94:	10800044 	addi	r2,r2,1
81140d98:	e0bffc15 	stw	r2,-16(fp)
81140d9c:	e0bffc17 	ldw	r2,-16(fp)
81140da0:	10800210 	cmplti	r2,r2,8
81140da4:	103fe81e 	bne	r2,zero,81140d48 <__reset+0xfb120d48>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
81140da8:	e0bffe17 	ldw	r2,-8(fp)
81140dac:	10800203 	ldbu	r2,8(r2)
81140db0:	10803fcc 	andi	r2,r2,255
81140db4:	10800820 	cmpeqi	r2,r2,32
81140db8:	1000241e 	bne	r2,zero,81140e4c <copy_file_record_name_to_string+0x12c>
	{
		file_name[flength] = '.';
81140dbc:	e0bffd17 	ldw	r2,-12(fp)
81140dc0:	e0ffff17 	ldw	r3,-4(fp)
81140dc4:	1885883a 	add	r2,r3,r2
81140dc8:	00c00b84 	movi	r3,46
81140dcc:	10c00005 	stb	r3,0(r2)
		flength = flength + 1;
81140dd0:	e0bffd17 	ldw	r2,-12(fp)
81140dd4:	10800044 	addi	r2,r2,1
81140dd8:	e0bffd15 	stw	r2,-12(fp)
		for (index = 0; index < 3; index++)
81140ddc:	e03ffc15 	stw	zero,-16(fp)
81140de0:	00001706 	br	81140e40 <copy_file_record_name_to_string+0x120>
		{
			if (file_record->extension[index] != ' ')
81140de4:	e0fffe17 	ldw	r3,-8(fp)
81140de8:	e0bffc17 	ldw	r2,-16(fp)
81140dec:	1885883a 	add	r2,r3,r2
81140df0:	10800204 	addi	r2,r2,8
81140df4:	10800003 	ldbu	r2,0(r2)
81140df8:	10803fcc 	andi	r2,r2,255
81140dfc:	10800820 	cmpeqi	r2,r2,32
81140e00:	10000c1e 	bne	r2,zero,81140e34 <copy_file_record_name_to_string+0x114>
			{
				file_name[flength] = file_record->extension[index];
81140e04:	e0bffd17 	ldw	r2,-12(fp)
81140e08:	e0ffff17 	ldw	r3,-4(fp)
81140e0c:	1885883a 	add	r2,r3,r2
81140e10:	e13ffe17 	ldw	r4,-8(fp)
81140e14:	e0fffc17 	ldw	r3,-16(fp)
81140e18:	20c7883a 	add	r3,r4,r3
81140e1c:	18c00204 	addi	r3,r3,8
81140e20:	18c00003 	ldbu	r3,0(r3)
81140e24:	10c00005 	stb	r3,0(r2)
				flength = flength + 1;
81140e28:	e0bffd17 	ldw	r2,-12(fp)
81140e2c:	10800044 	addi	r2,r2,1
81140e30:	e0bffd15 	stw	r2,-12(fp)
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
81140e34:	e0bffc17 	ldw	r2,-16(fp)
81140e38:	10800044 	addi	r2,r2,1
81140e3c:	e0bffc15 	stw	r2,-16(fp)
81140e40:	e0bffc17 	ldw	r2,-16(fp)
81140e44:	108000d0 	cmplti	r2,r2,3
81140e48:	103fe61e 	bne	r2,zero,81140de4 <__reset+0xfb120de4>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
81140e4c:	e0bffd17 	ldw	r2,-12(fp)
81140e50:	e0ffff17 	ldw	r3,-4(fp)
81140e54:	1885883a 	add	r2,r3,r2
81140e58:	10000005 	stb	zero,0(r2)
}
81140e5c:	0001883a 	nop
81140e60:	e037883a 	mov	sp,fp
81140e64:	df000017 	ldw	fp,0(sp)
81140e68:	dec00104 	addi	sp,sp,4
81140e6c:	f800283a 	ret

81140e70 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
81140e70:	defffc04 	addi	sp,sp,-16
81140e74:	de00012e 	bgeu	sp,et,81140e7c <alt_up_sd_card_open_dev+0xc>
81140e78:	003b68fa 	trap	3
81140e7c:	dfc00315 	stw	ra,12(sp)
81140e80:	df000215 	stw	fp,8(sp)
81140e84:	df000204 	addi	fp,sp,8
81140e88:	e13fff15 	stw	r4,-4(fp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
81140e8c:	d1600d04 	addi	r5,gp,-32716
81140e90:	e13fff17 	ldw	r4,-4(fp)
81140e94:	114632c0 	call	8114632c <alt_find_dev>
81140e98:	e0bffe15 	stw	r2,-8(fp)

	if (dev != NULL)
81140e9c:	e0bffe17 	ldw	r2,-8(fp)
81140ea0:	10001e26 	beq	r2,zero,81140f1c <alt_up_sd_card_open_dev+0xac>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
81140ea4:	e0bffe17 	ldw	r2,-8(fp)
81140ea8:	10800a17 	ldw	r2,40(r2)
81140eac:	10808d04 	addi	r2,r2,564
81140eb0:	d0a0a715 	stw	r2,-32100(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
81140eb4:	e0bffe17 	ldw	r2,-8(fp)
81140eb8:	10800a17 	ldw	r2,40(r2)
81140ebc:	10808904 	addi	r2,r2,548
81140ec0:	d0a0a815 	stw	r2,-32096(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
81140ec4:	e0bffe17 	ldw	r2,-8(fp)
81140ec8:	10800a17 	ldw	r2,40(r2)
81140ecc:	10808404 	addi	r2,r2,528
81140ed0:	d0a0a915 	stw	r2,-32092(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
81140ed4:	e0bffe17 	ldw	r2,-8(fp)
81140ed8:	10800a17 	ldw	r2,40(r2)
81140edc:	10808c04 	addi	r2,r2,560
81140ee0:	d0a0aa15 	stw	r2,-32088(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
81140ee4:	e0bffe17 	ldw	r2,-8(fp)
81140ee8:	10800a17 	ldw	r2,40(r2)
81140eec:	10808b04 	addi	r2,r2,556
81140ef0:	d0a0ab15 	stw	r2,-32084(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
81140ef4:	e0bffe17 	ldw	r2,-8(fp)
81140ef8:	10800a17 	ldw	r2,40(r2)
81140efc:	d0a0ac15 	stw	r2,-32080(gp)
		device_pointer = dev;
81140f00:	e0bffe17 	ldw	r2,-8(fp)
81140f04:	d0a0af15 	stw	r2,-32068(gp)
		initialized = false;
81140f08:	d020a515 	stw	zero,-32108(gp)
		is_sd_card_formated_as_FAT16 = false;
81140f0c:	d020a615 	stw	zero,-32104(gp)
		search_data.valid = false;
81140f10:	00a045f4 	movhi	r2,33047
81140f14:	10a12b04 	addi	r2,r2,-31572
81140f18:	10000415 	stw	zero,16(r2)
	}
	return dev;
81140f1c:	e0bffe17 	ldw	r2,-8(fp)
}
81140f20:	e037883a 	mov	sp,fp
81140f24:	dfc00117 	ldw	ra,4(sp)
81140f28:	df000017 	ldw	fp,0(sp)
81140f2c:	dec00204 	addi	sp,sp,8
81140f30:	f800283a 	ret

81140f34 <alt_up_sd_card_is_Present>:


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
81140f34:	defffd04 	addi	sp,sp,-12
81140f38:	de00012e 	bgeu	sp,et,81140f40 <alt_up_sd_card_is_Present+0xc>
81140f3c:	003b68fa 	trap	3
81140f40:	df000215 	stw	fp,8(sp)
81140f44:	df000204 	addi	fp,sp,8
    bool result = false;
81140f48:	e03ffe15 	stw	zero,-8(fp)

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
81140f4c:	d0a0af17 	ldw	r2,-32068(gp)
81140f50:	10000826 	beq	r2,zero,81140f74 <alt_up_sd_card_is_Present+0x40>
81140f54:	d0a0a717 	ldw	r2,-32100(gp)
81140f58:	1080002b 	ldhuio	r2,0(r2)
81140f5c:	10bfffcc 	andi	r2,r2,65535
81140f60:	1080008c 	andi	r2,r2,2
81140f64:	10000326 	beq	r2,zero,81140f74 <alt_up_sd_card_is_Present+0x40>
    {
        result = true;
81140f68:	00800044 	movi	r2,1
81140f6c:	e0bffe15 	stw	r2,-8(fp)
81140f70:	00001e06 	br	81140fec <alt_up_sd_card_is_Present+0xb8>
    }
	else if (initialized == true)
81140f74:	d0a0a517 	ldw	r2,-32108(gp)
81140f78:	10800058 	cmpnei	r2,r2,1
81140f7c:	10001b1e 	bne	r2,zero,81140fec <alt_up_sd_card_is_Present+0xb8>
	{
		int index;

		initialized = false;
81140f80:	d020a515 	stw	zero,-32108(gp)
		search_data.valid = false;
81140f84:	00a045f4 	movhi	r2,33047
81140f88:	10a12b04 	addi	r2,r2,-31572
81140f8c:	10000415 	stw	zero,16(r2)
		is_sd_card_formated_as_FAT16 = false;
81140f90:	d020a615 	stw	zero,-32104(gp)

		for(index = 0; index < MAX_FILES_OPENED; index++)
81140f94:	e03fff15 	stw	zero,-4(fp)
81140f98:	00001106 	br	81140fe0 <alt_up_sd_card_is_Present+0xac>
		{
			active_files[index].in_use = false;
81140f9c:	00a045f4 	movhi	r2,33047
81140fa0:	10a14504 	addi	r2,r2,-31468
81140fa4:	e0ffff17 	ldw	r3,-4(fp)
81140fa8:	180691ba 	slli	r3,r3,6
81140fac:	10c5883a 	add	r2,r2,r3
81140fb0:	10800f04 	addi	r2,r2,60
81140fb4:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
81140fb8:	00a045f4 	movhi	r2,33047
81140fbc:	10a14504 	addi	r2,r2,-31468
81140fc0:	e0ffff17 	ldw	r3,-4(fp)
81140fc4:	180691ba 	slli	r3,r3,6
81140fc8:	10c5883a 	add	r2,r2,r3
81140fcc:	10800e04 	addi	r2,r2,56
81140fd0:	10000015 	stw	zero,0(r2)

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
81140fd4:	e0bfff17 	ldw	r2,-4(fp)
81140fd8:	10800044 	addi	r2,r2,1
81140fdc:	e0bfff15 	stw	r2,-4(fp)
81140fe0:	e0bfff17 	ldw	r2,-4(fp)
81140fe4:	10800510 	cmplti	r2,r2,20
81140fe8:	103fec1e 	bne	r2,zero,81140f9c <__reset+0xfb120f9c>
		{
			active_files[index].in_use = false;
			active_files[index].modified = false;
		}
	}
    return result;
81140fec:	e0bffe17 	ldw	r2,-8(fp)
}
81140ff0:	e037883a 	mov	sp,fp
81140ff4:	df000017 	ldw	fp,0(sp)
81140ff8:	dec00104 	addi	sp,sp,4
81140ffc:	f800283a 	ret

81141000 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
81141000:	defffd04 	addi	sp,sp,-12
81141004:	de00012e 	bgeu	sp,et,8114100c <alt_up_sd_card_is_FAT16+0xc>
81141008:	003b68fa 	trap	3
8114100c:	dfc00215 	stw	ra,8(sp)
81141010:	df000115 	stw	fp,4(sp)
81141014:	df000104 	addi	fp,sp,4
	bool result = false;
81141018:	e03fff15 	stw	zero,-4(fp)

	if (alt_up_sd_card_is_Present())
8114101c:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
81141020:	10000c26 	beq	r2,zero,81141054 <alt_up_sd_card_is_FAT16+0x54>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
81141024:	d0a0a517 	ldw	r2,-32108(gp)
81141028:	1000071e 	bne	r2,zero,81141048 <alt_up_sd_card_is_FAT16+0x48>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
8114102c:	113f22c0 	call	8113f22c <Look_for_FAT16>
81141030:	d0a0a615 	stw	r2,-32104(gp)
			initialized = is_sd_card_formated_as_FAT16;
81141034:	d0a0a617 	ldw	r2,-32104(gp)
81141038:	d0a0a515 	stw	r2,-32108(gp)
			search_data.valid = false;
8114103c:	00a045f4 	movhi	r2,33047
81141040:	10a12b04 	addi	r2,r2,-31572
81141044:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
81141048:	d0a0a617 	ldw	r2,-32104(gp)
8114104c:	e0bfff15 	stw	r2,-4(fp)
81141050:	00000206 	br	8114105c <alt_up_sd_card_is_FAT16+0x5c>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
81141054:	d020a515 	stw	zero,-32108(gp)
		is_sd_card_formated_as_FAT16 = false;
81141058:	d020a615 	stw	zero,-32104(gp)
	}

	return result;
8114105c:	e0bfff17 	ldw	r2,-4(fp)
}
81141060:	e037883a 	mov	sp,fp
81141064:	dfc00117 	ldw	ra,4(sp)
81141068:	df000017 	ldw	fp,0(sp)
8114106c:	dec00204 	addi	sp,sp,8
81141070:	f800283a 	ret

81141074 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
81141074:	deffea04 	addi	sp,sp,-88
81141078:	de00012e 	bgeu	sp,et,81141080 <alt_up_sd_card_find_first+0xc>
8114107c:	003b68fa 	trap	3
81141080:	dfc01515 	stw	ra,84(sp)
81141084:	df001415 	stw	fp,80(sp)
81141088:	df001404 	addi	fp,sp,80
8114108c:	e13ffe15 	stw	r4,-8(fp)
81141090:	e17fff15 	stw	r5,-4(fp)
	short int result = 2;
81141094:	00800084 	movi	r2,2
81141098:	e0bfec0d 	sth	r2,-80(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114109c:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
811410a0:	10002426 	beq	r2,zero,81141134 <alt_up_sd_card_find_first+0xc0>
811410a4:	d0a0a617 	ldw	r2,-32104(gp)
811410a8:	10002226 	beq	r2,zero,81141134 <alt_up_sd_card_find_first+0xc0>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
811410ac:	e0ffee04 	addi	r3,fp,-72
811410b0:	e0bfed04 	addi	r2,fp,-76
811410b4:	180d883a 	mov	r6,r3
811410b8:	100b883a 	mov	r5,r2
811410bc:	e13ffe17 	ldw	r4,-8(fp)
811410c0:	113f9c40 	call	8113f9c4 <get_home_directory_cluster_for_file>
811410c4:	10001926 	beq	r2,zero,8114112c <alt_up_sd_card_find_first+0xb8>
		{
			search_data.directory_root_cluster = home_directory_cluster;
811410c8:	e0bfed17 	ldw	r2,-76(fp)
811410cc:	1007883a 	mov	r3,r2
811410d0:	00a045f4 	movhi	r2,33047
811410d4:	10a12b04 	addi	r2,r2,-31572
811410d8:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
811410dc:	e0bfed17 	ldw	r2,-76(fp)
811410e0:	1007883a 	mov	r3,r2
811410e4:	00a045f4 	movhi	r2,33047
811410e8:	10a12b04 	addi	r2,r2,-31572
811410ec:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
811410f0:	00a045f4 	movhi	r2,33047
811410f4:	10a12b04 	addi	r2,r2,-31572
811410f8:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
811410fc:	00a045f4 	movhi	r2,33047
81141100:	10a12b04 	addi	r2,r2,-31572
81141104:	00ffffc4 	movi	r3,-1
81141108:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
8114110c:	00a045f4 	movhi	r2,33047
81141110:	10a12b04 	addi	r2,r2,-31572
81141114:	00c00044 	movi	r3,1
81141118:	10c00415 	stw	r3,16(r2)
			result = alt_up_sd_card_find_next(file_name);
8114111c:	e13fff17 	ldw	r4,-4(fp)
81141120:	114114c0 	call	8114114c <alt_up_sd_card_find_next>
81141124:	e0bfec0d 	sth	r2,-80(fp)
81141128:	00000206 	br	81141134 <alt_up_sd_card_find_first+0xc0>
		}
		else
		{
			result = 1;
8114112c:	00800044 	movi	r2,1
81141130:	e0bfec0d 	sth	r2,-80(fp)
		}
	}
	return result;
81141134:	e0bfec0b 	ldhu	r2,-80(fp)
}
81141138:	e037883a 	mov	sp,fp
8114113c:	dfc00117 	ldw	ra,4(sp)
81141140:	df000017 	ldw	fp,0(sp)
81141144:	dec00204 	addi	sp,sp,8
81141148:	f800283a 	ret

8114114c <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
8114114c:	deffe404 	addi	sp,sp,-112
81141150:	de00012e 	bgeu	sp,et,81141158 <alt_up_sd_card_find_next+0xc>
81141154:	003b68fa 	trap	3
81141158:	dfc01b15 	stw	ra,108(sp)
8114115c:	df001a15 	stw	fp,104(sp)
81141160:	df001a04 	addi	fp,sp,104
81141164:	e13fff15 	stw	r4,-4(fp)
	short int result = 2;
81141168:	00800084 	movi	r2,2
8114116c:	e0bfe60d 	sth	r2,-104(fp)
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141170:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
81141174:	1000df26 	beq	r2,zero,811414f4 <alt_up_sd_card_find_next+0x3a8>
81141178:	d0a0a617 	ldw	r2,-32104(gp)
8114117c:	1000dd26 	beq	r2,zero,811414f4 <alt_up_sd_card_find_next+0x3a8>
	{
		if (search_data.valid)
81141180:	00a045f4 	movhi	r2,33047
81141184:	10a12b04 	addi	r2,r2,-31572
81141188:	10800417 	ldw	r2,16(r2)
8114118c:	1000d726 	beq	r2,zero,811414ec <alt_up_sd_card_find_next+0x3a0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
81141190:	00a045f4 	movhi	r2,33047
81141194:	10a12b04 	addi	r2,r2,-31572
81141198:	10800117 	ldw	r2,4(r2)
8114119c:	e0bfe715 	stw	r2,-100(fp)

			if (cluster == 0)
811411a0:	e0bfe717 	ldw	r2,-100(fp)
811411a4:	1000561e 	bne	r2,zero,81141300 <alt_up_sd_card_find_next+0x1b4>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
811411a8:	00a045f4 	movhi	r2,33047
811411ac:	10a13004 	addi	r2,r2,-31552
811411b0:	1080050b 	ldhu	r2,20(r2)
811411b4:	10bfffcc 	andi	r2,r2,65535
811411b8:	1006917a 	slli	r3,r2,5
811411bc:	00a045f4 	movhi	r2,33047
811411c0:	10a13004 	addi	r2,r2,-31552
811411c4:	1080030b 	ldhu	r2,12(r2)
811411c8:	10bfffcc 	andi	r2,r2,65535
811411cc:	1885283a 	div	r2,r3,r2
811411d0:	e0bfec15 	stw	r2,-80(fp)
				int sector_index = search_data.current_sector_in_cluster;
811411d4:	00a045f4 	movhi	r2,33047
811411d8:	10a12b04 	addi	r2,r2,-31572
811411dc:	10800217 	ldw	r2,8(r2)
811411e0:	e0bfe815 	stw	r2,-96(fp)
				int file_counter = search_data.file_index_in_sector+1;
811411e4:	00a045f4 	movhi	r2,33047
811411e8:	10a12b04 	addi	r2,r2,-31572
811411ec:	1080030b 	ldhu	r2,12(r2)
811411f0:	10bfffcc 	andi	r2,r2,65535
811411f4:	10a0001c 	xori	r2,r2,32768
811411f8:	10a00004 	addi	r2,r2,-32768
811411fc:	10800044 	addi	r2,r2,1
81141200:	e0bfe915 	stw	r2,-92(fp)
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
81141204:	00003606 	br	811412e0 <alt_up_sd_card_find_next+0x194>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
81141208:	00a045f4 	movhi	r2,33047
8114120c:	10a13004 	addi	r2,r2,-31552
81141210:	10c01317 	ldw	r3,76(r2)
81141214:	e0bfe817 	ldw	r2,-96(fp)
81141218:	1885883a 	add	r2,r3,r2
8114121c:	1007883a 	mov	r3,r2
81141220:	d0a0ad17 	ldw	r2,-32076(gp)
81141224:	100b883a 	mov	r5,r2
81141228:	1809883a 	mov	r4,r3
8114122c:	113e25c0 	call	8113e25c <Read_Sector_Data>
81141230:	10002f26 	beq	r2,zero,811412f0 <alt_up_sd_card_find_next+0x1a4>
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
81141234:	00002306 	br	811412c4 <alt_up_sd_card_find_next+0x178>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
81141238:	e0bfe917 	ldw	r2,-92(fp)
8114123c:	1004917a 	slli	r2,r2,5
81141240:	e13fe817 	ldw	r4,-96(fp)
81141244:	e0ffef04 	addi	r3,fp,-68
81141248:	200f883a 	mov	r7,r4
8114124c:	000d883a 	mov	r6,zero
81141250:	180b883a 	mov	r5,r3
81141254:	1009883a 	mov	r4,r2
81141258:	113e68c0 	call	8113e68c <Read_File_Record_At_Offset>
8114125c:	10001626 	beq	r2,zero,811412b8 <alt_up_sd_card_find_next+0x16c>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
81141260:	e0bfef03 	ldbu	r2,-68(fp)
81141264:	10803fcc 	andi	r2,r2,255
81141268:	10001326 	beq	r2,zero,811412b8 <alt_up_sd_card_find_next+0x16c>
8114126c:	e0bfef03 	ldbu	r2,-68(fp)
81141270:	10803fcc 	andi	r2,r2,255
81141274:	10803960 	cmpeqi	r2,r2,229
81141278:	10000f1e 	bne	r2,zero,811412b8 <alt_up_sd_card_find_next+0x16c>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
8114127c:	e0bfe917 	ldw	r2,-92(fp)
81141280:	1007883a 	mov	r3,r2
81141284:	00a045f4 	movhi	r2,33047
81141288:	10a12b04 	addi	r2,r2,-31572
8114128c:	10c0030d 	sth	r3,12(r2)
									search_data.current_sector_in_cluster = sector_index;
81141290:	e0ffe817 	ldw	r3,-96(fp)
81141294:	00a045f4 	movhi	r2,33047
81141298:	10a12b04 	addi	r2,r2,-31572
8114129c:	10c00215 	stw	r3,8(r2)

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
811412a0:	e0bfef04 	addi	r2,fp,-68
811412a4:	e17fff17 	ldw	r5,-4(fp)
811412a8:	1009883a 	mov	r4,r2
811412ac:	1140d200 	call	81140d20 <copy_file_record_name_to_string>
									return 0;
811412b0:	0005883a 	mov	r2,zero
811412b4:	00009006 	br	811414f8 <alt_up_sd_card_find_next+0x3ac>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
811412b8:	e0bfe917 	ldw	r2,-92(fp)
811412bc:	10800044 	addi	r2,r2,1
811412c0:	e0bfe915 	stw	r2,-92(fp)
811412c4:	e0bfe917 	ldw	r2,-92(fp)
811412c8:	10800410 	cmplti	r2,r2,16
811412cc:	103fda1e 	bne	r2,zero,81141238 <__reset+0xfb121238>
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
811412d0:	e03fe915 	stw	zero,-92(fp)
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
811412d4:	e0bfe817 	ldw	r2,-96(fp)
811412d8:	10800044 	addi	r2,r2,1
811412dc:	e0bfe815 	stw	r2,-96(fp)
811412e0:	e0ffe817 	ldw	r3,-96(fp)
811412e4:	e0bfec17 	ldw	r2,-80(fp)
811412e8:	18bfc716 	blt	r3,r2,81141208 <__reset+0xfb121208>
811412ec:	00000106 	br	811412f4 <alt_up_sd_card_find_next+0x1a8>
						}
						file_counter = 0;
					}
					else
					{
						break;
811412f0:	0001883a 	nop
					}
				}
				result = -1;
811412f4:	00bfffc4 	movi	r2,-1
811412f8:	e0bfe60d 	sth	r2,-104(fp)
811412fc:	00007d06 	br	811414f4 <alt_up_sd_card_find_next+0x3a8>
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
81141300:	00a045f4 	movhi	r2,33047
81141304:	10a12b04 	addi	r2,r2,-31572
81141308:	1080030b 	ldhu	r2,12(r2)
8114130c:	10bfffcc 	andi	r2,r2,65535
81141310:	10a0001c 	xori	r2,r2,32768
81141314:	10a00004 	addi	r2,r2,-32768
81141318:	10800044 	addi	r2,r2,1
8114131c:	e0bfea15 	stw	r2,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
81141320:	e0bfe717 	ldw	r2,-100(fp)
81141324:	10ffff84 	addi	r3,r2,-2
81141328:	00a045f4 	movhi	r2,33047
8114132c:	10a13004 	addi	r2,r2,-31552
81141330:	10800383 	ldbu	r2,14(r2)
81141334:	10803fcc 	andi	r2,r2,255
81141338:	1885383a 	mul	r2,r3,r2
8114133c:	1007883a 	mov	r3,r2
81141340:	00a045f4 	movhi	r2,33047
81141344:	10a13004 	addi	r2,r2,-31552
81141348:	10801417 	ldw	r2,80(r2)
8114134c:	1885883a 	add	r2,r3,r2
81141350:	e0bfed15 	stw	r2,-76(fp)
					int sector_index = search_data.current_sector_in_cluster;
81141354:	00a045f4 	movhi	r2,33047
81141358:	10a12b04 	addi	r2,r2,-31572
8114135c:	10800217 	ldw	r2,8(r2)
81141360:	e0bfeb15 	stw	r2,-84(fp)
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
81141364:	00003806 	br	81141448 <alt_up_sd_card_find_next+0x2fc>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
81141368:	e0ffeb17 	ldw	r3,-84(fp)
8114136c:	e0bfed17 	ldw	r2,-76(fp)
81141370:	1885883a 	add	r2,r3,r2
81141374:	d0e0ad17 	ldw	r3,-32076(gp)
81141378:	180b883a 	mov	r5,r3
8114137c:	1009883a 	mov	r4,r2
81141380:	113e25c0 	call	8113e25c <Read_Sector_Data>
81141384:	10003726 	beq	r2,zero,81141464 <alt_up_sd_card_find_next+0x318>
						{        
							for (; file_counter < 16; file_counter++)
81141388:	00002806 	br	8114142c <alt_up_sd_card_find_next+0x2e0>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
8114138c:	e0bfea17 	ldw	r2,-88(fp)
81141390:	1004917a 	slli	r2,r2,5
81141394:	e13fe717 	ldw	r4,-100(fp)
81141398:	e17feb17 	ldw	r5,-84(fp)
8114139c:	e0ffef04 	addi	r3,fp,-68
811413a0:	280f883a 	mov	r7,r5
811413a4:	200d883a 	mov	r6,r4
811413a8:	180b883a 	mov	r5,r3
811413ac:	1009883a 	mov	r4,r2
811413b0:	113e68c0 	call	8113e68c <Read_File_Record_At_Offset>
811413b4:	10001a26 	beq	r2,zero,81141420 <alt_up_sd_card_find_next+0x2d4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
811413b8:	e0bfef03 	ldbu	r2,-68(fp)
811413bc:	10803fcc 	andi	r2,r2,255
811413c0:	10001726 	beq	r2,zero,81141420 <alt_up_sd_card_find_next+0x2d4>
811413c4:	e0bfef03 	ldbu	r2,-68(fp)
811413c8:	10803fcc 	andi	r2,r2,255
811413cc:	10803960 	cmpeqi	r2,r2,229
811413d0:	1000131e 	bne	r2,zero,81141420 <alt_up_sd_card_find_next+0x2d4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
811413d4:	e0ffe717 	ldw	r3,-100(fp)
811413d8:	00a045f4 	movhi	r2,33047
811413dc:	10a12b04 	addi	r2,r2,-31572
811413e0:	10c00115 	stw	r3,4(r2)
										search_data.file_index_in_sector = file_counter;
811413e4:	e0bfea17 	ldw	r2,-88(fp)
811413e8:	1007883a 	mov	r3,r2
811413ec:	00a045f4 	movhi	r2,33047
811413f0:	10a12b04 	addi	r2,r2,-31572
811413f4:	10c0030d 	sth	r3,12(r2)
										search_data.current_sector_in_cluster = sector_index;
811413f8:	e0ffeb17 	ldw	r3,-84(fp)
811413fc:	00a045f4 	movhi	r2,33047
81141400:	10a12b04 	addi	r2,r2,-31572
81141404:	10c00215 	stw	r3,8(r2)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
81141408:	e0bfef04 	addi	r2,fp,-68
8114140c:	e17fff17 	ldw	r5,-4(fp)
81141410:	1009883a 	mov	r4,r2
81141414:	1140d200 	call	81140d20 <copy_file_record_name_to_string>
										return 0;
81141418:	0005883a 	mov	r2,zero
8114141c:	00003606 	br	811414f8 <alt_up_sd_card_find_next+0x3ac>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
81141420:	e0bfea17 	ldw	r2,-88(fp)
81141424:	10800044 	addi	r2,r2,1
81141428:	e0bfea15 	stw	r2,-88(fp)
8114142c:	e0bfea17 	ldw	r2,-88(fp)
81141430:	10800410 	cmplti	r2,r2,16
81141434:	103fd51e 	bne	r2,zero,8114138c <__reset+0xfb12138c>
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
81141438:	e03fea15 	stw	zero,-88(fp)
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
8114143c:	e0bfeb17 	ldw	r2,-84(fp)
81141440:	10800044 	addi	r2,r2,1
81141444:	e0bfeb15 	stw	r2,-84(fp)
81141448:	00a045f4 	movhi	r2,33047
8114144c:	10a13004 	addi	r2,r2,-31552
81141450:	10800383 	ldbu	r2,14(r2)
81141454:	10803fcc 	andi	r2,r2,255
81141458:	e0ffeb17 	ldw	r3,-84(fp)
8114145c:	18bfc216 	blt	r3,r2,81141368 <__reset+0xfb121368>
81141460:	00000106 	br	81141468 <alt_up_sd_card_find_next+0x31c>
							}
							file_counter = 0;
						}
						else
						{
							break;
81141464:	0001883a 	nop
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
81141468:	00a045f4 	movhi	r2,33047
8114146c:	10a13004 	addi	r2,r2,-31552
81141470:	10800383 	ldbu	r2,14(r2)
81141474:	10803fcc 	andi	r2,r2,255
81141478:	e0ffeb17 	ldw	r3,-84(fp)
8114147c:	18801716 	blt	r3,r2,811414dc <alt_up_sd_card_find_next+0x390>
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
81141480:	e0bfe717 	ldw	r2,-100(fp)
81141484:	e0ffee04 	addi	r3,fp,-72
81141488:	180b883a 	mov	r5,r3
8114148c:	1009883a 	mov	r4,r2
81141490:	113e33c0 	call	8113e33c <get_cluster_flag>
81141494:	10000f26 	beq	r2,zero,811414d4 <alt_up_sd_card_find_next+0x388>
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
81141498:	e0bfee0b 	ldhu	r2,-72(fp)
8114149c:	10bfffcc 	andi	r2,r2,65535
811414a0:	10fffe0c 	andi	r3,r2,65528
811414a4:	00bffe14 	movui	r2,65528
811414a8:	1880051e 	bne	r3,r2,811414c0 <alt_up_sd_card_find_next+0x374>
							{
								result = -1;
811414ac:	00bfffc4 	movi	r2,-1
811414b0:	e0bfe60d 	sth	r2,-104(fp)
								search_data.valid = false;
811414b4:	00a045f4 	movhi	r2,33047
811414b8:	10a12b04 	addi	r2,r2,-31572
811414bc:	10000415 	stw	zero,16(r2)
							}
							cluster = ((new_cluster) & 0x0000fff8);
811414c0:	e0bfee0b 	ldhu	r2,-72(fp)
811414c4:	10bfffcc 	andi	r2,r2,65535
811414c8:	10bffe0c 	andi	r2,r2,65528
811414cc:	e0bfe715 	stw	r2,-100(fp)
811414d0:	00000206 	br	811414dc <alt_up_sd_card_find_next+0x390>
						}
						else
						{
							// Error encountered.                 
							result = -1;
811414d4:	00bfffc4 	movi	r2,-1
811414d8:	e0bfe60d 	sth	r2,-104(fp)
						}
					}              
				} while (cluster < 0x0000fff8);
811414dc:	e0bfe717 	ldw	r2,-100(fp)
811414e0:	00fffdd4 	movui	r3,65527
811414e4:	18bf8e0e 	bge	r3,r2,81141320 <__reset+0xfb121320>
811414e8:	00000206 	br	811414f4 <alt_up_sd_card_find_next+0x3a8>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
811414ec:	008000c4 	movi	r2,3
811414f0:	e0bfe60d 	sth	r2,-104(fp)
		}
	}
	return result;
811414f4:	e0bfe60b 	ldhu	r2,-104(fp)
}
811414f8:	e037883a 	mov	sp,fp
811414fc:	dfc00117 	ldw	ra,4(sp)
81141500:	df000017 	ldw	fp,0(sp)
81141504:	dec00204 	addi	sp,sp,8
81141508:	f800283a 	ret

8114150c <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
8114150c:	deffe904 	addi	sp,sp,-92
81141510:	de00012e 	bgeu	sp,et,81141518 <alt_up_sd_card_fopen+0xc>
81141514:	003b68fa 	trap	3
81141518:	dfc01615 	stw	ra,88(sp)
8114151c:	df001515 	stw	fp,84(sp)
81141520:	df001504 	addi	fp,sp,84
81141524:	e13ffe15 	stw	r4,-8(fp)
81141528:	e17fff15 	stw	r5,-4(fp)
	short int file_record_index = -1;
8114152c:	00bfffc4 	movi	r2,-1
81141530:	e0bfeb0d 	sth	r2,-84(fp)

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
81141534:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
81141538:	1000cf26 	beq	r2,zero,81141878 <alt_up_sd_card_fopen+0x36c>
8114153c:	d0a0a617 	ldw	r2,-32104(gp)
81141540:	1000cd26 	beq	r2,zero,81141878 <alt_up_sd_card_fopen+0x36c>
	{
        unsigned int home_directory_cluster = 0;
81141544:	e03fed15 	stw	zero,-76(fp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
81141548:	e13ffe17 	ldw	r4,-8(fp)
8114154c:	113f3200 	call	8113f320 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
81141550:	e13ffe17 	ldw	r4,-8(fp)
81141554:	113f3ec0 	call	8113f3ec <check_file_name_for_FAT16_compliance>
81141558:	1000c726 	beq	r2,zero,81141878 <alt_up_sd_card_fopen+0x36c>
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
8114155c:	e0ffee04 	addi	r3,fp,-72
81141560:	e0bfed04 	addi	r2,fp,-76
81141564:	180d883a 	mov	r6,r3
81141568:	100b883a 	mov	r5,r2
8114156c:	e13ffe17 	ldw	r4,-8(fp)
81141570:	113f9c40 	call	8113f9c4 <get_home_directory_cluster_for_file>
81141574:	1000021e 	bne	r2,zero,81141580 <alt_up_sd_card_fopen+0x74>
            {
                return file_record_index;
81141578:	e0bfeb0b 	ldhu	r2,-84(fp)
8114157c:	0000bf06 	br	8114187c <alt_up_sd_card_fopen+0x370>
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
81141580:	e03fec15 	stw	zero,-80(fp)
81141584:	00000e06 	br	811415c0 <alt_up_sd_card_fopen+0xb4>
    		{
    			if (active_files[index].in_use == false)
81141588:	00a045f4 	movhi	r2,33047
8114158c:	10a14504 	addi	r2,r2,-31468
81141590:	e0ffec17 	ldw	r3,-80(fp)
81141594:	180691ba 	slli	r3,r3,6
81141598:	10c5883a 	add	r2,r2,r3
8114159c:	10800f04 	addi	r2,r2,60
811415a0:	10800017 	ldw	r2,0(r2)
811415a4:	1000031e 	bne	r2,zero,811415b4 <alt_up_sd_card_fopen+0xa8>
    			{
    				file_record_index = index;
811415a8:	e0bfec17 	ldw	r2,-80(fp)
811415ac:	e0bfeb0d 	sth	r2,-84(fp)
    				break;
811415b0:	00000606 	br	811415cc <alt_up_sd_card_fopen+0xc0>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
811415b4:	e0bfec17 	ldw	r2,-80(fp)
811415b8:	10800044 	addi	r2,r2,1
811415bc:	e0bfec15 	stw	r2,-80(fp)
811415c0:	e0bfec17 	ldw	r2,-80(fp)
811415c4:	10800510 	cmplti	r2,r2,20
811415c8:	103fef1e 	bne	r2,zero,81141588 <__reset+0xfb121588>
    			{
    				file_record_index = index;
    				break;
    			}
    		}
    		if (file_record_index >= 0)
811415cc:	e0bfeb0f 	ldh	r2,-84(fp)
811415d0:	1000a916 	blt	r2,zero,81141878 <alt_up_sd_card_fopen+0x36c>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
811415d4:	e0bfed17 	ldw	r2,-76(fp)
811415d8:	1009883a 	mov	r4,r2
811415dc:	e0bfeb0f 	ldh	r2,-84(fp)
811415e0:	100691ba 	slli	r3,r2,6
811415e4:	00a045f4 	movhi	r2,33047
811415e8:	10a14504 	addi	r2,r2,-31468
811415ec:	1885883a 	add	r2,r3,r2
811415f0:	100d883a 	mov	r6,r2
811415f4:	e17ffe17 	ldw	r5,-8(fp)
811415f8:	113ff040 	call	8113ff04 <find_file_in_directory>
811415fc:	10007b26 	beq	r2,zero,811417ec <alt_up_sd_card_fopen+0x2e0>
                {
                    if (create)
81141600:	e0bfff17 	ldw	r2,-4(fp)
81141604:	10000226 	beq	r2,zero,81141610 <alt_up_sd_card_fopen+0x104>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
81141608:	00bfffc4 	movi	r2,-1
8114160c:	00009b06 	br	8114187c <alt_up_sd_card_fopen+0x370>
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
81141610:	e13feb0f 	ldh	r4,-84(fp)
81141614:	e0ffeb0f 	ldh	r3,-84(fp)
81141618:	00a045f4 	movhi	r2,33047
8114161c:	10a14504 	addi	r2,r2,-31468
81141620:	180691ba 	slli	r3,r3,6
81141624:	10c5883a 	add	r2,r2,r3
81141628:	10800584 	addi	r2,r2,22
8114162c:	1080000b 	ldhu	r2,0(r2)
81141630:	10ffffcc 	andi	r3,r2,65535
81141634:	00a045f4 	movhi	r2,33047
81141638:	10a14504 	addi	r2,r2,-31468
8114163c:	200891ba 	slli	r4,r4,6
81141640:	1105883a 	add	r2,r2,r4
81141644:	10800704 	addi	r2,r2,28
81141648:	10c00015 	stw	r3,0(r2)
                    active_files[file_record_index].current_sector_in_cluster = 0;
8114164c:	e0ffeb0f 	ldh	r3,-84(fp)
81141650:	00a045f4 	movhi	r2,33047
81141654:	10a14504 	addi	r2,r2,-31468
81141658:	180691ba 	slli	r3,r3,6
8114165c:	10c5883a 	add	r2,r2,r3
81141660:	10800804 	addi	r2,r2,32
81141664:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].current_byte_position = 0;
81141668:	e0ffeb0f 	ldh	r3,-84(fp)
8114166c:	00a045f4 	movhi	r2,33047
81141670:	10a14504 	addi	r2,r2,-31468
81141674:	180691ba 	slli	r3,r3,6
81141678:	10c5883a 	add	r2,r2,r3
8114167c:	10800904 	addi	r2,r2,36
81141680:	10000015 	stw	zero,0(r2)
                    active_files[file_record_index].in_use = true;
81141684:	e0ffeb0f 	ldh	r3,-84(fp)
81141688:	00a045f4 	movhi	r2,33047
8114168c:	10a14504 	addi	r2,r2,-31468
81141690:	180691ba 	slli	r3,r3,6
81141694:	10c5883a 	add	r2,r2,r3
81141698:	10800f04 	addi	r2,r2,60
8114169c:	00c00044 	movi	r3,1
811416a0:	10c00015 	stw	r3,0(r2)
    				active_files[file_record_index].modified = false;
811416a4:	e0ffeb0f 	ldh	r3,-84(fp)
811416a8:	00a045f4 	movhi	r2,33047
811416ac:	10a14504 	addi	r2,r2,-31468
811416b0:	180691ba 	slli	r3,r3,6
811416b4:	10c5883a 	add	r2,r2,r3
811416b8:	10800e04 	addi	r2,r2,56
811416bc:	10000015 	stw	zero,0(r2)

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811416c0:	e03fec15 	stw	zero,-80(fp)
811416c4:	00004506 	br	811417dc <alt_up_sd_card_fopen+0x2d0>
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
811416c8:	e0ffeb0f 	ldh	r3,-84(fp)
811416cc:	e0bfec17 	ldw	r2,-80(fp)
811416d0:	18803f26 	beq	r3,r2,811417d0 <alt_up_sd_card_fopen+0x2c4>
811416d4:	00a045f4 	movhi	r2,33047
811416d8:	10a14504 	addi	r2,r2,-31468
811416dc:	e0ffec17 	ldw	r3,-80(fp)
811416e0:	180691ba 	slli	r3,r3,6
811416e4:	10c5883a 	add	r2,r2,r3
811416e8:	10800f04 	addi	r2,r2,60
811416ec:	10800017 	ldw	r2,0(r2)
811416f0:	10800058 	cmpnei	r2,r2,1
811416f4:	1000361e 	bne	r2,zero,811417d0 <alt_up_sd_card_fopen+0x2c4>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
811416f8:	e0ffeb0f 	ldh	r3,-84(fp)
811416fc:	00a045f4 	movhi	r2,33047
81141700:	10a14504 	addi	r2,r2,-31468
81141704:	180691ba 	slli	r3,r3,6
81141708:	10c5883a 	add	r2,r2,r3
8114170c:	10800a04 	addi	r2,r2,40
81141710:	10c00017 	ldw	r3,0(r2)
81141714:	00a045f4 	movhi	r2,33047
81141718:	10a14504 	addi	r2,r2,-31468
8114171c:	e13fec17 	ldw	r4,-80(fp)
81141720:	200891ba 	slli	r4,r4,6
81141724:	1105883a 	add	r2,r2,r4
81141728:	10800a04 	addi	r2,r2,40
8114172c:	10800017 	ldw	r2,0(r2)
81141730:	1880271e 	bne	r3,r2,811417d0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
81141734:	e0ffeb0f 	ldh	r3,-84(fp)
81141738:	00a045f4 	movhi	r2,33047
8114173c:	10a14504 	addi	r2,r2,-31468
81141740:	180691ba 	slli	r3,r3,6
81141744:	10c5883a 	add	r2,r2,r3
81141748:	10800b04 	addi	r2,r2,44
8114174c:	10c00017 	ldw	r3,0(r2)
81141750:	00a045f4 	movhi	r2,33047
81141754:	10a14504 	addi	r2,r2,-31468
81141758:	e13fec17 	ldw	r4,-80(fp)
8114175c:	200891ba 	slli	r4,r4,6
81141760:	1105883a 	add	r2,r2,r4
81141764:	10800b04 	addi	r2,r2,44
81141768:	10800017 	ldw	r2,0(r2)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
8114176c:	1880181e 	bne	r3,r2,811417d0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
81141770:	e0ffeb0f 	ldh	r3,-84(fp)
81141774:	00a045f4 	movhi	r2,33047
81141778:	10a14504 	addi	r2,r2,-31468
8114177c:	180691ba 	slli	r3,r3,6
81141780:	10c5883a 	add	r2,r2,r3
81141784:	10800c04 	addi	r2,r2,48
81141788:	1100000b 	ldhu	r4,0(r2)
8114178c:	00a045f4 	movhi	r2,33047
81141790:	10a14504 	addi	r2,r2,-31468
81141794:	e0ffec17 	ldw	r3,-80(fp)
81141798:	180691ba 	slli	r3,r3,6
8114179c:	10c5883a 	add	r2,r2,r3
811417a0:	10800c04 	addi	r2,r2,48
811417a4:	1080000b 	ldhu	r2,0(r2)
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
811417a8:	20ffffcc 	andi	r3,r4,65535
811417ac:	18e0001c 	xori	r3,r3,32768
811417b0:	18e00004 	addi	r3,r3,-32768
811417b4:	10bfffcc 	andi	r2,r2,65535
811417b8:	10a0001c 	xori	r2,r2,32768
811417bc:	10a00004 	addi	r2,r2,-32768
811417c0:	1880031e 	bne	r3,r2,811417d0 <alt_up_sd_card_fopen+0x2c4>
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
811417c4:	00bfff84 	movi	r2,-2
811417c8:	e0bfeb0d 	sth	r2,-84(fp)
								break;
811417cc:	00002a06 	br	81141878 <alt_up_sd_card_fopen+0x36c>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
811417d0:	e0bfec17 	ldw	r2,-80(fp)
811417d4:	10800044 	addi	r2,r2,1
811417d8:	e0bfec15 	stw	r2,-80(fp)
811417dc:	e0bfec17 	ldw	r2,-80(fp)
811417e0:	10800510 	cmplti	r2,r2,20
811417e4:	103fb81e 	bne	r2,zero,811416c8 <__reset+0xfb1216c8>
811417e8:	00002306 	br	81141878 <alt_up_sd_card_fopen+0x36c>
							}
						}
					}

                }
                else if (create)
811417ec:	e0bfff17 	ldw	r2,-4(fp)
811417f0:	10001f26 	beq	r2,zero,81141870 <alt_up_sd_card_fopen+0x364>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
811417f4:	e0bfeb0f 	ldh	r2,-84(fp)
811417f8:	100691ba 	slli	r3,r2,6
811417fc:	00a045f4 	movhi	r2,33047
81141800:	10a14504 	addi	r2,r2,-31468
81141804:	1885883a 	add	r2,r3,r2
81141808:	e0ffee04 	addi	r3,fp,-72
8114180c:	180d883a 	mov	r6,r3
81141810:	100b883a 	mov	r5,r2
81141814:	e13ffe17 	ldw	r4,-8(fp)
81141818:	1140a500 	call	81140a50 <create_file>
8114181c:	10001126 	beq	r2,zero,81141864 <alt_up_sd_card_fopen+0x358>
                    {
                        active_files[file_record_index].in_use = true;
81141820:	e0ffeb0f 	ldh	r3,-84(fp)
81141824:	00a045f4 	movhi	r2,33047
81141828:	10a14504 	addi	r2,r2,-31468
8114182c:	180691ba 	slli	r3,r3,6
81141830:	10c5883a 	add	r2,r2,r3
81141834:	10800f04 	addi	r2,r2,60
81141838:	00c00044 	movi	r3,1
8114183c:	10c00015 	stw	r3,0(r2)
    					active_files[file_record_index].modified = true;
81141840:	e0ffeb0f 	ldh	r3,-84(fp)
81141844:	00a045f4 	movhi	r2,33047
81141848:	10a14504 	addi	r2,r2,-31468
8114184c:	180691ba 	slli	r3,r3,6
81141850:	10c5883a 	add	r2,r2,r3
81141854:	10800e04 	addi	r2,r2,56
81141858:	00c00044 	movi	r3,1
8114185c:	10c00015 	stw	r3,0(r2)
81141860:	00000506 	br	81141878 <alt_up_sd_card_fopen+0x36c>
                    }
                    else
                    {
                        /* If file creation fails then return an invalid file handle. */
                        file_record_index = -1;
81141864:	00bfffc4 	movi	r2,-1
81141868:	e0bfeb0d 	sth	r2,-84(fp)
8114186c:	00000206 	br	81141878 <alt_up_sd_card_fopen+0x36c>
                    }                
                }
                else
                {
                    /* Otherwise the file could not be opened.*/
                    file_record_index = -1;
81141870:	00bfffc4 	movi	r2,-1
81141874:	e0bfeb0d 	sth	r2,-84(fp)
                }
    		}
        }
	}

	return file_record_index;
81141878:	e0bfeb0b 	ldhu	r2,-84(fp)
}
8114187c:	e037883a 	mov	sp,fp
81141880:	dfc00117 	ldw	ra,4(sp)
81141884:	df000017 	ldw	fp,0(sp)
81141888:	dec00204 	addi	sp,sp,8
8114188c:	f800283a 	ret

81141890 <alt_up_sd_card_set_attributes>:


void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81141890:	defffd04 	addi	sp,sp,-12
81141894:	de00012e 	bgeu	sp,et,8114189c <alt_up_sd_card_set_attributes+0xc>
81141898:	003b68fa 	trap	3
8114189c:	df000215 	stw	fp,8(sp)
811418a0:	df000204 	addi	fp,sp,8
811418a4:	2007883a 	mov	r3,r4
811418a8:	2805883a 	mov	r2,r5
811418ac:	e0fffe0d 	sth	r3,-8(fp)
811418b0:	e0bfff0d 	sth	r2,-4(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811418b4:	e0bffe0f 	ldh	r2,-8(fp)
811418b8:	10001416 	blt	r2,zero,8114190c <alt_up_sd_card_set_attributes+0x7c>
811418bc:	e0bffe0f 	ldh	r2,-8(fp)
811418c0:	10800508 	cmpgei	r2,r2,20
811418c4:	1000111e 	bne	r2,zero,8114190c <alt_up_sd_card_set_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
811418c8:	e0fffe0f 	ldh	r3,-8(fp)
811418cc:	00a045f4 	movhi	r2,33047
811418d0:	10a14504 	addi	r2,r2,-31468
811418d4:	180691ba 	slli	r3,r3,6
811418d8:	10c5883a 	add	r2,r2,r3
811418dc:	10800f04 	addi	r2,r2,60
811418e0:	10800017 	ldw	r2,0(r2)
811418e4:	10000926 	beq	r2,zero,8114190c <alt_up_sd_card_set_attributes+0x7c>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
811418e8:	e0fffe0f 	ldh	r3,-8(fp)
811418ec:	e0bfff0b 	ldhu	r2,-4(fp)
811418f0:	1009883a 	mov	r4,r2
811418f4:	00a045f4 	movhi	r2,33047
811418f8:	10a14504 	addi	r2,r2,-31468
811418fc:	180691ba 	slli	r3,r3,6
81141900:	10c5883a 	add	r2,r2,r3
81141904:	108002c4 	addi	r2,r2,11
81141908:	11000005 	stb	r4,0(r2)
        }
    }
}
8114190c:	0001883a 	nop
81141910:	e037883a 	mov	sp,fp
81141914:	df000017 	ldw	fp,0(sp)
81141918:	dec00104 	addi	sp,sp,4
8114191c:	f800283a 	ret

81141920 <alt_up_sd_card_get_attributes>:


short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
81141920:	defffd04 	addi	sp,sp,-12
81141924:	de00012e 	bgeu	sp,et,8114192c <alt_up_sd_card_get_attributes+0xc>
81141928:	003b68fa 	trap	3
8114192c:	df000215 	stw	fp,8(sp)
81141930:	df000204 	addi	fp,sp,8
81141934:	2005883a 	mov	r2,r4
81141938:	e0bfff0d 	sth	r2,-4(fp)
	short int result = -1;
8114193c:	00bfffc4 	movi	r2,-1
81141940:	e0bffe0d 	sth	r2,-8(fp)
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81141944:	e0bfff0f 	ldh	r2,-4(fp)
81141948:	10001416 	blt	r2,zero,8114199c <alt_up_sd_card_get_attributes+0x7c>
8114194c:	e0bfff0f 	ldh	r2,-4(fp)
81141950:	10800508 	cmpgei	r2,r2,20
81141954:	1000111e 	bne	r2,zero,8114199c <alt_up_sd_card_get_attributes+0x7c>
    {
        if (active_files[file_handle].in_use)
81141958:	e0ffff0f 	ldh	r3,-4(fp)
8114195c:	00a045f4 	movhi	r2,33047
81141960:	10a14504 	addi	r2,r2,-31468
81141964:	180691ba 	slli	r3,r3,6
81141968:	10c5883a 	add	r2,r2,r3
8114196c:	10800f04 	addi	r2,r2,60
81141970:	10800017 	ldw	r2,0(r2)
81141974:	10000926 	beq	r2,zero,8114199c <alt_up_sd_card_get_attributes+0x7c>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
81141978:	e0ffff0f 	ldh	r3,-4(fp)
8114197c:	00a045f4 	movhi	r2,33047
81141980:	10a14504 	addi	r2,r2,-31468
81141984:	180691ba 	slli	r3,r3,6
81141988:	10c5883a 	add	r2,r2,r3
8114198c:	108002c4 	addi	r2,r2,11
81141990:	10800003 	ldbu	r2,0(r2)
81141994:	10803fcc 	andi	r2,r2,255
81141998:	e0bffe0d 	sth	r2,-8(fp)
		}
	}
	return result;
8114199c:	e0bffe0b 	ldhu	r2,-8(fp)
}
811419a0:	e037883a 	mov	sp,fp
811419a4:	df000017 	ldw	fp,0(sp)
811419a8:	dec00104 	addi	sp,sp,4
811419ac:	f800283a 	ret

811419b0 <alt_up_sd_card_read>:

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
811419b0:	defffa04 	addi	sp,sp,-24
811419b4:	de00012e 	bgeu	sp,et,811419bc <alt_up_sd_card_read+0xc>
811419b8:	003b68fa 	trap	3
811419bc:	dfc00515 	stw	ra,20(sp)
811419c0:	df000415 	stw	fp,16(sp)
811419c4:	df000404 	addi	fp,sp,16
811419c8:	2005883a 	mov	r2,r4
811419cc:	e0bfff0d 	sth	r2,-4(fp)
    short int ch = -1;
811419d0:	00bfffc4 	movi	r2,-1
811419d4:	e0bffc0d 	sth	r2,-16(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
811419d8:	e0bfff0f 	ldh	r2,-4(fp)
811419dc:	1000ce16 	blt	r2,zero,81141d18 <alt_up_sd_card_read+0x368>
811419e0:	e0bfff0f 	ldh	r2,-4(fp)
811419e4:	10800508 	cmpgei	r2,r2,20
811419e8:	1000cb1e 	bne	r2,zero,81141d18 <alt_up_sd_card_read+0x368>
    {
        if (active_files[file_handle].in_use)
811419ec:	e0ffff0f 	ldh	r3,-4(fp)
811419f0:	00a045f4 	movhi	r2,33047
811419f4:	10a14504 	addi	r2,r2,-31468
811419f8:	180691ba 	slli	r3,r3,6
811419fc:	10c5883a 	add	r2,r2,r3
81141a00:	10800f04 	addi	r2,r2,60
81141a04:	10800017 	ldw	r2,0(r2)
81141a08:	1000c326 	beq	r2,zero,81141d18 <alt_up_sd_card_read+0x368>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81141a0c:	e0ffff0f 	ldh	r3,-4(fp)
81141a10:	00a045f4 	movhi	r2,33047
81141a14:	10a14504 	addi	r2,r2,-31468
81141a18:	180691ba 	slli	r3,r3,6
81141a1c:	10c5883a 	add	r2,r2,r3
81141a20:	10800904 	addi	r2,r2,36
81141a24:	10c00017 	ldw	r3,0(r2)
81141a28:	e13fff0f 	ldh	r4,-4(fp)
81141a2c:	00a045f4 	movhi	r2,33047
81141a30:	10a14504 	addi	r2,r2,-31468
81141a34:	200891ba 	slli	r4,r4,6
81141a38:	1105883a 	add	r2,r2,r4
81141a3c:	10800604 	addi	r2,r2,24
81141a40:	10800017 	ldw	r2,0(r2)
81141a44:	1880b42e 	bgeu	r3,r2,81141d18 <alt_up_sd_card_read+0x368>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141a48:	00a045f4 	movhi	r2,33047
81141a4c:	10a13004 	addi	r2,r2,-31552
81141a50:	10c01417 	ldw	r3,80(r2)
81141a54:	e13fff0f 	ldh	r4,-4(fp)
81141a58:	00a045f4 	movhi	r2,33047
81141a5c:	10a14504 	addi	r2,r2,-31468
81141a60:	200891ba 	slli	r4,r4,6
81141a64:	1105883a 	add	r2,r2,r4
81141a68:	10800704 	addi	r2,r2,28
81141a6c:	10800017 	ldw	r2,0(r2)
81141a70:	113fff84 	addi	r4,r2,-2
81141a74:	00a045f4 	movhi	r2,33047
81141a78:	10a13004 	addi	r2,r2,-31552
81141a7c:	10800383 	ldbu	r2,14(r2)
81141a80:	10803fcc 	andi	r2,r2,255
81141a84:	2085383a 	mul	r2,r4,r2
81141a88:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;
81141a8c:	e13fff0f 	ldh	r4,-4(fp)
81141a90:	00a045f4 	movhi	r2,33047
81141a94:	10a14504 	addi	r2,r2,-31468
81141a98:	200891ba 	slli	r4,r4,6
81141a9c:	1105883a 	add	r2,r2,r4
81141aa0:	10800804 	addi	r2,r2,32
81141aa4:	10800017 	ldw	r2,0(r2)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141aa8:	1885883a 	add	r2,r3,r2
81141aac:	e0bffd15 	stw	r2,-12(fp)
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
81141ab0:	e0ffff0f 	ldh	r3,-4(fp)
81141ab4:	00a045f4 	movhi	r2,33047
81141ab8:	10a14504 	addi	r2,r2,-31468
81141abc:	180691ba 	slli	r3,r3,6
81141ac0:	10c5883a 	add	r2,r2,r3
81141ac4:	10800904 	addi	r2,r2,36
81141ac8:	10800017 	ldw	r2,0(r2)
81141acc:	10006826 	beq	r2,zero,81141c70 <alt_up_sd_card_read+0x2c0>
81141ad0:	e0ffff0f 	ldh	r3,-4(fp)
81141ad4:	00a045f4 	movhi	r2,33047
81141ad8:	10a14504 	addi	r2,r2,-31468
81141adc:	180691ba 	slli	r3,r3,6
81141ae0:	10c5883a 	add	r2,r2,r3
81141ae4:	10800904 	addi	r2,r2,36
81141ae8:	10800017 	ldw	r2,0(r2)
81141aec:	10807fcc 	andi	r2,r2,511
81141af0:	10005f1e 	bne	r2,zero,81141c70 <alt_up_sd_card_read+0x2c0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81141af4:	e0ffff0f 	ldh	r3,-4(fp)
81141af8:	00a045f4 	movhi	r2,33047
81141afc:	10a14504 	addi	r2,r2,-31468
81141b00:	180691ba 	slli	r3,r3,6
81141b04:	10c5883a 	add	r2,r2,r3
81141b08:	10800804 	addi	r2,r2,32
81141b0c:	10c00017 	ldw	r3,0(r2)
81141b10:	00a045f4 	movhi	r2,33047
81141b14:	10a13004 	addi	r2,r2,-31552
81141b18:	10800383 	ldbu	r2,14(r2)
81141b1c:	10803fcc 	andi	r2,r2,255
81141b20:	10bfffc4 	addi	r2,r2,-1
81141b24:	1880401e 	bne	r3,r2,81141c28 <alt_up_sd_card_read+0x278>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81141b28:	e0ffff0f 	ldh	r3,-4(fp)
81141b2c:	00a045f4 	movhi	r2,33047
81141b30:	10a14504 	addi	r2,r2,-31468
81141b34:	180691ba 	slli	r3,r3,6
81141b38:	10c5883a 	add	r2,r2,r3
81141b3c:	10800704 	addi	r2,r2,28
81141b40:	10800017 	ldw	r2,0(r2)
81141b44:	e0fffe04 	addi	r3,fp,-8
81141b48:	180b883a 	mov	r5,r3
81141b4c:	1009883a 	mov	r4,r2
81141b50:	113e33c0 	call	8113e33c <get_cluster_flag>
81141b54:	10003226 	beq	r2,zero,81141c20 <alt_up_sd_card_read+0x270>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
81141b58:	e0bffe0b 	ldhu	r2,-8(fp)
81141b5c:	10bfffcc 	andi	r2,r2,65535
81141b60:	10fffe0c 	andi	r3,r2,65528
81141b64:	00bffe14 	movui	r2,65528
81141b68:	1880021e 	bne	r3,r2,81141b74 <alt_up_sd_card_read+0x1c4>
                            {
                                /* End of file */
                                return -1;
81141b6c:	00bfffc4 	movi	r2,-1
81141b70:	00006a06 	br	81141d1c <alt_up_sd_card_read+0x36c>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81141b74:	e13fff0f 	ldh	r4,-4(fp)
81141b78:	e0bffe0b 	ldhu	r2,-8(fp)
81141b7c:	10ffffcc 	andi	r3,r2,65535
81141b80:	00a045f4 	movhi	r2,33047
81141b84:	10a14504 	addi	r2,r2,-31468
81141b88:	200891ba 	slli	r4,r4,6
81141b8c:	1105883a 	add	r2,r2,r4
81141b90:	10800704 	addi	r2,r2,28
81141b94:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81141b98:	e0ffff0f 	ldh	r3,-4(fp)
81141b9c:	00a045f4 	movhi	r2,33047
81141ba0:	10a14504 	addi	r2,r2,-31468
81141ba4:	180691ba 	slli	r3,r3,6
81141ba8:	10c5883a 	add	r2,r2,r3
81141bac:	10800804 	addi	r2,r2,32
81141bb0:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141bb4:	00a045f4 	movhi	r2,33047
81141bb8:	10a13004 	addi	r2,r2,-31552
81141bbc:	10c01417 	ldw	r3,80(r2)
81141bc0:	e13fff0f 	ldh	r4,-4(fp)
81141bc4:	00a045f4 	movhi	r2,33047
81141bc8:	10a14504 	addi	r2,r2,-31468
81141bcc:	200891ba 	slli	r4,r4,6
81141bd0:	1105883a 	add	r2,r2,r4
81141bd4:	10800704 	addi	r2,r2,28
81141bd8:	10800017 	ldw	r2,0(r2)
81141bdc:	113fff84 	addi	r4,r2,-2
81141be0:	00a045f4 	movhi	r2,33047
81141be4:	10a13004 	addi	r2,r2,-31552
81141be8:	10800383 	ldbu	r2,14(r2)
81141bec:	10803fcc 	andi	r2,r2,255
81141bf0:	2085383a 	mul	r2,r4,r2
81141bf4:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81141bf8:	e13fff0f 	ldh	r4,-4(fp)
81141bfc:	00a045f4 	movhi	r2,33047
81141c00:	10a14504 	addi	r2,r2,-31468
81141c04:	200891ba 	slli	r4,r4,6
81141c08:	1105883a 	add	r2,r2,r4
81141c0c:	10800804 	addi	r2,r2,32
81141c10:	10800017 	ldw	r2,0(r2)
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141c14:	1885883a 	add	r2,r3,r2
81141c18:	e0bffd15 	stw	r2,-12(fp)
81141c1c:	00001406 	br	81141c70 <alt_up_sd_card_read+0x2c0>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return -2;
81141c20:	00bfff84 	movi	r2,-2
81141c24:	00003d06 	br	81141d1c <alt_up_sd_card_read+0x36c>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81141c28:	e13fff0f 	ldh	r4,-4(fp)
81141c2c:	e0ffff0f 	ldh	r3,-4(fp)
81141c30:	00a045f4 	movhi	r2,33047
81141c34:	10a14504 	addi	r2,r2,-31468
81141c38:	180691ba 	slli	r3,r3,6
81141c3c:	10c5883a 	add	r2,r2,r3
81141c40:	10800804 	addi	r2,r2,32
81141c44:	10800017 	ldw	r2,0(r2)
81141c48:	10c00044 	addi	r3,r2,1
81141c4c:	00a045f4 	movhi	r2,33047
81141c50:	10a14504 	addi	r2,r2,-31468
81141c54:	200891ba 	slli	r4,r4,6
81141c58:	1105883a 	add	r2,r2,r4
81141c5c:	10800804 	addi	r2,r2,32
81141c60:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81141c64:	e0bffd17 	ldw	r2,-12(fp)
81141c68:	10800044 	addi	r2,r2,1
81141c6c:	e0bffd15 	stw	r2,-12(fp)
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
81141c70:	d0e0ad17 	ldw	r3,-32076(gp)
81141c74:	e0bffd17 	ldw	r2,-12(fp)
81141c78:	1885883a 	add	r2,r3,r2
81141c7c:	1007883a 	mov	r3,r2
81141c80:	d0a0b117 	ldw	r2,-32060(gp)
81141c84:	18800726 	beq	r3,r2,81141ca4 <alt_up_sd_card_read+0x2f4>
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
81141c88:	d0a0ad17 	ldw	r2,-32076(gp)
81141c8c:	100b883a 	mov	r5,r2
81141c90:	e13ffd17 	ldw	r4,-12(fp)
81141c94:	113e25c0 	call	8113e25c <Read_Sector_Data>
81141c98:	1000021e 	bne	r2,zero,81141ca4 <alt_up_sd_card_read+0x2f4>
                    {
						return -2;
81141c9c:	00bfff84 	movi	r2,-2
81141ca0:	00001e06 	br	81141d1c <alt_up_sd_card_read+0x36c>
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
81141ca4:	d0e0ac17 	ldw	r3,-32080(gp)
81141ca8:	e13fff0f 	ldh	r4,-4(fp)
81141cac:	00a045f4 	movhi	r2,33047
81141cb0:	10a14504 	addi	r2,r2,-31468
81141cb4:	200891ba 	slli	r4,r4,6
81141cb8:	1105883a 	add	r2,r2,r4
81141cbc:	10800904 	addi	r2,r2,36
81141cc0:	10800017 	ldw	r2,0(r2)
81141cc4:	10807fcc 	andi	r2,r2,511
81141cc8:	1885883a 	add	r2,r3,r2
81141ccc:	10800023 	ldbuio	r2,0(r2)
81141cd0:	10803fcc 	andi	r2,r2,255
81141cd4:	10803fcc 	andi	r2,r2,255
81141cd8:	e0bffc0d 	sth	r2,-16(fp)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
81141cdc:	e13fff0f 	ldh	r4,-4(fp)
81141ce0:	e0ffff0f 	ldh	r3,-4(fp)
81141ce4:	00a045f4 	movhi	r2,33047
81141ce8:	10a14504 	addi	r2,r2,-31468
81141cec:	180691ba 	slli	r3,r3,6
81141cf0:	10c5883a 	add	r2,r2,r3
81141cf4:	10800904 	addi	r2,r2,36
81141cf8:	10800017 	ldw	r2,0(r2)
81141cfc:	10c00044 	addi	r3,r2,1
81141d00:	00a045f4 	movhi	r2,33047
81141d04:	10a14504 	addi	r2,r2,-31468
81141d08:	200891ba 	slli	r4,r4,6
81141d0c:	1105883a 	add	r2,r2,r4
81141d10:	10800904 	addi	r2,r2,36
81141d14:	10c00015 	stw	r3,0(r2)
            }
        }
    }
    
    return ch;
81141d18:	e0bffc0b 	ldhu	r2,-16(fp)
}
81141d1c:	e037883a 	mov	sp,fp
81141d20:	dfc00117 	ldw	ra,4(sp)
81141d24:	df000017 	ldw	fp,0(sp)
81141d28:	dec00204 	addi	sp,sp,8
81141d2c:	f800283a 	ret

81141d30 <alt_up_sd_card_write>:


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
81141d30:	defff804 	addi	sp,sp,-32
81141d34:	de00012e 	bgeu	sp,et,81141d3c <alt_up_sd_card_write+0xc>
81141d38:	003b68fa 	trap	3
81141d3c:	dfc00715 	stw	ra,28(sp)
81141d40:	df000615 	stw	fp,24(sp)
81141d44:	df000604 	addi	fp,sp,24
81141d48:	2007883a 	mov	r3,r4
81141d4c:	2805883a 	mov	r2,r5
81141d50:	e0fffe0d 	sth	r3,-8(fp)
81141d54:	e0bfff05 	stb	r2,-4(fp)
    bool result = false;
81141d58:	e03ffa15 	stw	zero,-24(fp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
81141d5c:	e0bffe0f 	ldh	r2,-8(fp)
81141d60:	10017716 	blt	r2,zero,81142340 <alt_up_sd_card_write+0x610>
81141d64:	e0bffe0f 	ldh	r2,-8(fp)
81141d68:	10800508 	cmpgei	r2,r2,20
81141d6c:	1001741e 	bne	r2,zero,81142340 <alt_up_sd_card_write+0x610>
    {
        if (active_files[file_handle].in_use)
81141d70:	e0fffe0f 	ldh	r3,-8(fp)
81141d74:	00a045f4 	movhi	r2,33047
81141d78:	10a14504 	addi	r2,r2,-31468
81141d7c:	180691ba 	slli	r3,r3,6
81141d80:	10c5883a 	add	r2,r2,r3
81141d84:	10800f04 	addi	r2,r2,60
81141d88:	10800017 	ldw	r2,0(r2)
81141d8c:	10016c26 	beq	r2,zero,81142340 <alt_up_sd_card_write+0x610>
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141d90:	00a045f4 	movhi	r2,33047
81141d94:	10a13004 	addi	r2,r2,-31552
81141d98:	10c01417 	ldw	r3,80(r2)
81141d9c:	e13ffe0f 	ldh	r4,-8(fp)
81141da0:	00a045f4 	movhi	r2,33047
81141da4:	10a14504 	addi	r2,r2,-31468
81141da8:	200891ba 	slli	r4,r4,6
81141dac:	1105883a 	add	r2,r2,r4
81141db0:	10800704 	addi	r2,r2,28
81141db4:	10800017 	ldw	r2,0(r2)
81141db8:	113fff84 	addi	r4,r2,-2
81141dbc:	00a045f4 	movhi	r2,33047
81141dc0:	10a13004 	addi	r2,r2,-31552
81141dc4:	10800383 	ldbu	r2,14(r2)
81141dc8:	10803fcc 	andi	r2,r2,255
81141dcc:	2085383a 	mul	r2,r4,r2
81141dd0:	1887883a 	add	r3,r3,r2
                              active_files[file_handle].current_sector_in_cluster;
81141dd4:	e13ffe0f 	ldh	r4,-8(fp)
81141dd8:	00a045f4 	movhi	r2,33047
81141ddc:	10a14504 	addi	r2,r2,-31468
81141de0:	200891ba 	slli	r4,r4,6
81141de4:	1105883a 	add	r2,r2,r4
81141de8:	10800804 	addi	r2,r2,32
81141dec:	10800017 	ldw	r2,0(r2)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141df0:	1885883a 	add	r2,r3,r2
81141df4:	e0bffb15 	stw	r2,-20(fp)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
81141df8:	e0fffe0f 	ldh	r3,-8(fp)
81141dfc:	00a045f4 	movhi	r2,33047
81141e00:	10a14504 	addi	r2,r2,-31468
81141e04:	180691ba 	slli	r3,r3,6
81141e08:	10c5883a 	add	r2,r2,r3
81141e0c:	10800904 	addi	r2,r2,36
81141e10:	10c00017 	ldw	r3,0(r2)
81141e14:	00a045f4 	movhi	r2,33047
81141e18:	10a13004 	addi	r2,r2,-31552
81141e1c:	1080030b 	ldhu	r2,12(r2)
81141e20:	10bfffcc 	andi	r2,r2,65535
81141e24:	1889203a 	divu	r4,r3,r2
81141e28:	2085383a 	mul	r2,r4,r2
81141e2c:	1885c83a 	sub	r2,r3,r2
81141e30:	e0bffc0d 	sth	r2,-16(fp)

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
81141e34:	e0fffe0f 	ldh	r3,-8(fp)
81141e38:	00a045f4 	movhi	r2,33047
81141e3c:	10a14504 	addi	r2,r2,-31468
81141e40:	180691ba 	slli	r3,r3,6
81141e44:	10c5883a 	add	r2,r2,r3
81141e48:	10800904 	addi	r2,r2,36
81141e4c:	10c00017 	ldw	r3,0(r2)
81141e50:	e13ffe0f 	ldh	r4,-8(fp)
81141e54:	00a045f4 	movhi	r2,33047
81141e58:	10a14504 	addi	r2,r2,-31468
81141e5c:	200891ba 	slli	r4,r4,6
81141e60:	1105883a 	add	r2,r2,r4
81141e64:	10800604 	addi	r2,r2,24
81141e68:	10800017 	ldw	r2,0(r2)
81141e6c:	1880672e 	bgeu	r3,r2,8114200c <alt_up_sd_card_write+0x2dc>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
81141e70:	e0fffe0f 	ldh	r3,-8(fp)
81141e74:	00a045f4 	movhi	r2,33047
81141e78:	10a14504 	addi	r2,r2,-31468
81141e7c:	180691ba 	slli	r3,r3,6
81141e80:	10c5883a 	add	r2,r2,r3
81141e84:	10800904 	addi	r2,r2,36
81141e88:	10800017 	ldw	r2,0(r2)
81141e8c:	1000e126 	beq	r2,zero,81142214 <alt_up_sd_card_write+0x4e4>
81141e90:	e0bffc0f 	ldh	r2,-16(fp)
81141e94:	1000df1e 	bne	r2,zero,81142214 <alt_up_sd_card_write+0x4e4>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81141e98:	e0fffe0f 	ldh	r3,-8(fp)
81141e9c:	00a045f4 	movhi	r2,33047
81141ea0:	10a14504 	addi	r2,r2,-31468
81141ea4:	180691ba 	slli	r3,r3,6
81141ea8:	10c5883a 	add	r2,r2,r3
81141eac:	10800804 	addi	r2,r2,32
81141eb0:	10c00017 	ldw	r3,0(r2)
81141eb4:	00a045f4 	movhi	r2,33047
81141eb8:	10a13004 	addi	r2,r2,-31552
81141ebc:	10800383 	ldbu	r2,14(r2)
81141ec0:	10803fcc 	andi	r2,r2,255
81141ec4:	10bfffc4 	addi	r2,r2,-1
81141ec8:	18803d1e 	bne	r3,r2,81141fc0 <alt_up_sd_card_write+0x290>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
81141ecc:	e0fffe0f 	ldh	r3,-8(fp)
81141ed0:	00a045f4 	movhi	r2,33047
81141ed4:	10a14504 	addi	r2,r2,-31468
81141ed8:	180691ba 	slli	r3,r3,6
81141edc:	10c5883a 	add	r2,r2,r3
81141ee0:	10800704 	addi	r2,r2,28
81141ee4:	10800017 	ldw	r2,0(r2)
81141ee8:	e0fffc84 	addi	r3,fp,-14
81141eec:	180b883a 	mov	r5,r3
81141ef0:	1009883a 	mov	r4,r2
81141ef4:	113e33c0 	call	8113e33c <get_cluster_flag>
81141ef8:	10002f26 	beq	r2,zero,81141fb8 <alt_up_sd_card_write+0x288>
                        {
                            if (next_cluster < 0x0000fff8)
81141efc:	e0bffc8b 	ldhu	r2,-14(fp)
81141f00:	10bfffcc 	andi	r2,r2,65535
81141f04:	10bffe28 	cmpgeui	r2,r2,65528
81141f08:	1000c21e 	bne	r2,zero,81142214 <alt_up_sd_card_write+0x4e4>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
81141f0c:	e13ffe0f 	ldh	r4,-8(fp)
81141f10:	e0bffc8b 	ldhu	r2,-14(fp)
81141f14:	10ffffcc 	andi	r3,r2,65535
81141f18:	00a045f4 	movhi	r2,33047
81141f1c:	10a14504 	addi	r2,r2,-31468
81141f20:	200891ba 	slli	r4,r4,6
81141f24:	1105883a 	add	r2,r2,r4
81141f28:	10800704 	addi	r2,r2,28
81141f2c:	10c00015 	stw	r3,0(r2)
								active_files[file_handle].current_sector_in_cluster = 0;
81141f30:	e0fffe0f 	ldh	r3,-8(fp)
81141f34:	00a045f4 	movhi	r2,33047
81141f38:	10a14504 	addi	r2,r2,-31468
81141f3c:	180691ba 	slli	r3,r3,6
81141f40:	10c5883a 	add	r2,r2,r3
81141f44:	10800804 	addi	r2,r2,32
81141f48:	10000015 	stw	zero,0(r2)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141f4c:	00a045f4 	movhi	r2,33047
81141f50:	10a13004 	addi	r2,r2,-31552
81141f54:	10c01417 	ldw	r3,80(r2)
81141f58:	e13ffe0f 	ldh	r4,-8(fp)
81141f5c:	00a045f4 	movhi	r2,33047
81141f60:	10a14504 	addi	r2,r2,-31468
81141f64:	200891ba 	slli	r4,r4,6
81141f68:	1105883a 	add	r2,r2,r4
81141f6c:	10800704 	addi	r2,r2,28
81141f70:	10800017 	ldw	r2,0(r2)
81141f74:	113fff84 	addi	r4,r2,-2
81141f78:	00a045f4 	movhi	r2,33047
81141f7c:	10a13004 	addi	r2,r2,-31552
81141f80:	10800383 	ldbu	r2,14(r2)
81141f84:	10803fcc 	andi	r2,r2,255
81141f88:	2085383a 	mul	r2,r4,r2
81141f8c:	1887883a 	add	r3,r3,r2
                                  active_files[file_handle].current_sector_in_cluster;                                
81141f90:	e13ffe0f 	ldh	r4,-8(fp)
81141f94:	00a045f4 	movhi	r2,33047
81141f98:	10a14504 	addi	r2,r2,-31468
81141f9c:	200891ba 	slli	r4,r4,6
81141fa0:	1105883a 	add	r2,r2,r4
81141fa4:	10800804 	addi	r2,r2,32
81141fa8:	10800017 	ldw	r2,0(r2)
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
81141fac:	1885883a 	add	r2,r3,r2
81141fb0:	e0bffb15 	stw	r2,-20(fp)
81141fb4:	00009706 	br	81142214 <alt_up_sd_card_write+0x4e4>
                                  active_files[file_handle].current_sector_in_cluster;                                
                            }
                        }
                        else
                        {
                            return false;
81141fb8:	0005883a 	mov	r2,zero
81141fbc:	0000e106 	br	81142344 <alt_up_sd_card_write+0x614>
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
81141fc0:	e13ffe0f 	ldh	r4,-8(fp)
81141fc4:	e0fffe0f 	ldh	r3,-8(fp)
81141fc8:	00a045f4 	movhi	r2,33047
81141fcc:	10a14504 	addi	r2,r2,-31468
81141fd0:	180691ba 	slli	r3,r3,6
81141fd4:	10c5883a 	add	r2,r2,r3
81141fd8:	10800804 	addi	r2,r2,32
81141fdc:	10800017 	ldw	r2,0(r2)
81141fe0:	10c00044 	addi	r3,r2,1
81141fe4:	00a045f4 	movhi	r2,33047
81141fe8:	10a14504 	addi	r2,r2,-31468
81141fec:	200891ba 	slli	r4,r4,6
81141ff0:	1105883a 	add	r2,r2,r4
81141ff4:	10800804 	addi	r2,r2,32
81141ff8:	10c00015 	stw	r3,0(r2)
                        data_sector = data_sector + 1;
81141ffc:	e0bffb17 	ldw	r2,-20(fp)
81142000:	10800044 	addi	r2,r2,1
81142004:	e0bffb15 	stw	r2,-20(fp)
81142008:	00008206 	br	81142214 <alt_up_sd_card_write+0x4e4>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
8114200c:	e0fffe0f 	ldh	r3,-8(fp)
81142010:	00a045f4 	movhi	r2,33047
81142014:	10a14504 	addi	r2,r2,-31468
81142018:	180691ba 	slli	r3,r3,6
8114201c:	10c5883a 	add	r2,r2,r3
81142020:	10800904 	addi	r2,r2,36
81142024:	10800017 	ldw	r2,0(r2)
81142028:	10007a26 	beq	r2,zero,81142214 <alt_up_sd_card_write+0x4e4>
8114202c:	e0bffc0f 	ldh	r2,-16(fp)
81142030:	1000781e 	bne	r2,zero,81142214 <alt_up_sd_card_write+0x4e4>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
81142034:	e0fffe0f 	ldh	r3,-8(fp)
81142038:	00a045f4 	movhi	r2,33047
8114203c:	10a14504 	addi	r2,r2,-31468
81142040:	180691ba 	slli	r3,r3,6
81142044:	10c5883a 	add	r2,r2,r3
81142048:	10800804 	addi	r2,r2,32
8114204c:	10c00017 	ldw	r3,0(r2)
81142050:	00a045f4 	movhi	r2,33047
81142054:	10a13004 	addi	r2,r2,-31552
81142058:	10800383 	ldbu	r2,14(r2)
8114205c:	10803fcc 	andi	r2,r2,255
81142060:	10bfffc4 	addi	r2,r2,-1
81142064:	18803e1e 	bne	r3,r2,81142160 <alt_up_sd_card_write+0x430>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
81142068:	e0bffd04 	addi	r2,fp,-12
8114206c:	1009883a 	mov	r4,r2
81142070:	11403800 	call	81140380 <find_first_empty_cluster>
81142074:	10003826 	beq	r2,zero,81142158 <alt_up_sd_card_write+0x428>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
81142078:	e0fffe0f 	ldh	r3,-8(fp)
8114207c:	00a045f4 	movhi	r2,33047
81142080:	10a14504 	addi	r2,r2,-31468
81142084:	180691ba 	slli	r3,r3,6
81142088:	10c5883a 	add	r2,r2,r3
8114208c:	10800704 	addi	r2,r2,28
81142090:	10800017 	ldw	r2,0(r2)
81142094:	e0fffd17 	ldw	r3,-12(fp)
81142098:	18ffffcc 	andi	r3,r3,65535
8114209c:	18e0001c 	xori	r3,r3,32768
811420a0:	18e00004 	addi	r3,r3,-32768
811420a4:	01800044 	movi	r6,1
811420a8:	180b883a 	mov	r5,r3
811420ac:	1009883a 	mov	r4,r2
811420b0:	113e3f80 	call	8113e3f8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
811420b4:	e0bffd17 	ldw	r2,-12(fp)
811420b8:	01800044 	movi	r6,1
811420bc:	017fffc4 	movi	r5,-1
811420c0:	1009883a 	mov	r4,r2
811420c4:	113e3f80 	call	8113e3f8 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
811420c8:	e0fffe0f 	ldh	r3,-8(fp)
811420cc:	00a045f4 	movhi	r2,33047
811420d0:	10a14504 	addi	r2,r2,-31468
811420d4:	180691ba 	slli	r3,r3,6
811420d8:	10c5883a 	add	r2,r2,r3
811420dc:	10800704 	addi	r2,r2,28
811420e0:	10800017 	ldw	r2,0(r2)
811420e4:	e0fffd17 	ldw	r3,-12(fp)
811420e8:	18ffffcc 	andi	r3,r3,65535
811420ec:	18e0001c 	xori	r3,r3,32768
811420f0:	18e00004 	addi	r3,r3,-32768
811420f4:	000d883a 	mov	r6,zero
811420f8:	180b883a 	mov	r5,r3
811420fc:	1009883a 	mov	r4,r2
81142100:	113e3f80 	call	8113e3f8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
81142104:	e0bffd17 	ldw	r2,-12(fp)
81142108:	000d883a 	mov	r6,zero
8114210c:	017fffc4 	movi	r5,-1
81142110:	1009883a 	mov	r4,r2
81142114:	113e3f80 	call	8113e3f8 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
81142118:	e13ffe0f 	ldh	r4,-8(fp)
8114211c:	e0fffd17 	ldw	r3,-12(fp)
81142120:	00a045f4 	movhi	r2,33047
81142124:	10a14504 	addi	r2,r2,-31468
81142128:	200891ba 	slli	r4,r4,6
8114212c:	1105883a 	add	r2,r2,r4
81142130:	10800704 	addi	r2,r2,28
81142134:	10c00015 	stw	r3,0(r2)
							active_files[file_handle].current_sector_in_cluster = 0;
81142138:	e0fffe0f 	ldh	r3,-8(fp)
8114213c:	00a045f4 	movhi	r2,33047
81142140:	10a14504 	addi	r2,r2,-31468
81142144:	180691ba 	slli	r3,r3,6
81142148:	10c5883a 	add	r2,r2,r3
8114214c:	10800804 	addi	r2,r2,32
81142150:	10000015 	stw	zero,0(r2)
81142154:	00001506 	br	811421ac <alt_up_sd_card_write+0x47c>
						}
						else
						{
							return false;
81142158:	0005883a 	mov	r2,zero
8114215c:	00007906 	br	81142344 <alt_up_sd_card_write+0x614>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
81142160:	e13ffe0f 	ldh	r4,-8(fp)
81142164:	e0fffe0f 	ldh	r3,-8(fp)
81142168:	00a045f4 	movhi	r2,33047
8114216c:	10a14504 	addi	r2,r2,-31468
81142170:	180691ba 	slli	r3,r3,6
81142174:	10c5883a 	add	r2,r2,r3
81142178:	10800904 	addi	r2,r2,36
8114217c:	10c00017 	ldw	r3,0(r2)
81142180:	00a045f4 	movhi	r2,33047
81142184:	10a13004 	addi	r2,r2,-31552
81142188:	1080030b 	ldhu	r2,12(r2)
8114218c:	10bfffcc 	andi	r2,r2,65535
81142190:	1887203a 	divu	r3,r3,r2
81142194:	00a045f4 	movhi	r2,33047
81142198:	10a14504 	addi	r2,r2,-31468
8114219c:	200891ba 	slli	r4,r4,6
811421a0:	1105883a 	add	r2,r2,r4
811421a4:	10800804 	addi	r2,r2,32
811421a8:	10c00015 	stw	r3,0(r2)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
811421ac:	00a045f4 	movhi	r2,33047
811421b0:	10a13004 	addi	r2,r2,-31552
811421b4:	10c01417 	ldw	r3,80(r2)
811421b8:	e13ffe0f 	ldh	r4,-8(fp)
811421bc:	00a045f4 	movhi	r2,33047
811421c0:	10a14504 	addi	r2,r2,-31468
811421c4:	200891ba 	slli	r4,r4,6
811421c8:	1105883a 	add	r2,r2,r4
811421cc:	10800704 	addi	r2,r2,28
811421d0:	10800017 	ldw	r2,0(r2)
811421d4:	113fff84 	addi	r4,r2,-2
811421d8:	00a045f4 	movhi	r2,33047
811421dc:	10a13004 	addi	r2,r2,-31552
811421e0:	10800383 	ldbu	r2,14(r2)
811421e4:	10803fcc 	andi	r2,r2,255
811421e8:	2085383a 	mul	r2,r4,r2
811421ec:	1887883a 	add	r3,r3,r2
                          active_files[file_handle].current_sector_in_cluster;
811421f0:	e13ffe0f 	ldh	r4,-8(fp)
811421f4:	00a045f4 	movhi	r2,33047
811421f8:	10a14504 	addi	r2,r2,-31468
811421fc:	200891ba 	slli	r4,r4,6
81142200:	1105883a 	add	r2,r2,r4
81142204:	10800804 	addi	r2,r2,32
81142208:	10800017 	ldw	r2,0(r2)
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
8114220c:	1885883a 	add	r2,r3,r2
81142210:	e0bffb15 	stw	r2,-20(fp)
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
81142214:	d0e0ad17 	ldw	r3,-32076(gp)
81142218:	e0bffb17 	ldw	r2,-20(fp)
8114221c:	1885883a 	add	r2,r3,r2
81142220:	1007883a 	mov	r3,r2
81142224:	d0a0b117 	ldw	r2,-32060(gp)
81142228:	18800726 	beq	r3,r2,81142248 <alt_up_sd_card_write+0x518>
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
8114222c:	d0a0ad17 	ldw	r2,-32076(gp)
81142230:	100b883a 	mov	r5,r2
81142234:	e13ffb17 	ldw	r4,-20(fp)
81142238:	113e25c0 	call	8113e25c <Read_Sector_Data>
8114223c:	1000021e 	bne	r2,zero,81142248 <alt_up_sd_card_write+0x518>
                {
					return false;
81142240:	0005883a 	mov	r2,zero
81142244:	00003f06 	br	81142344 <alt_up_sd_card_write+0x614>
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
81142248:	d0e0ac17 	ldw	r3,-32080(gp)
8114224c:	e0bffc0f 	ldh	r2,-16(fp)
81142250:	1885883a 	add	r2,r3,r2
81142254:	e0ffff07 	ldb	r3,-4(fp)
81142258:	10c00025 	stbio	r3,0(r2)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
8114225c:	e13ffe0f 	ldh	r4,-8(fp)
81142260:	e0fffe0f 	ldh	r3,-8(fp)
81142264:	00a045f4 	movhi	r2,33047
81142268:	10a14504 	addi	r2,r2,-31468
8114226c:	180691ba 	slli	r3,r3,6
81142270:	10c5883a 	add	r2,r2,r3
81142274:	10800904 	addi	r2,r2,36
81142278:	10800017 	ldw	r2,0(r2)
8114227c:	10c00044 	addi	r3,r2,1
81142280:	00a045f4 	movhi	r2,33047
81142284:	10a14504 	addi	r2,r2,-31468
81142288:	200891ba 	slli	r4,r4,6
8114228c:	1105883a 	add	r2,r2,r4
81142290:	10800904 	addi	r2,r2,36
81142294:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
81142298:	e0fffe0f 	ldh	r3,-8(fp)
8114229c:	00a045f4 	movhi	r2,33047
811422a0:	10a14504 	addi	r2,r2,-31468
811422a4:	180691ba 	slli	r3,r3,6
811422a8:	10c5883a 	add	r2,r2,r3
811422ac:	10800904 	addi	r2,r2,36
811422b0:	10c00017 	ldw	r3,0(r2)
811422b4:	e13ffe0f 	ldh	r4,-8(fp)
811422b8:	00a045f4 	movhi	r2,33047
811422bc:	10a14504 	addi	r2,r2,-31468
811422c0:	200891ba 	slli	r4,r4,6
811422c4:	1105883a 	add	r2,r2,r4
811422c8:	10800604 	addi	r2,r2,24
811422cc:	10800017 	ldw	r2,0(r2)
811422d0:	18801736 	bltu	r3,r2,81142330 <alt_up_sd_card_write+0x600>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
811422d4:	e13ffe0f 	ldh	r4,-8(fp)
811422d8:	e0fffe0f 	ldh	r3,-8(fp)
811422dc:	00a045f4 	movhi	r2,33047
811422e0:	10a14504 	addi	r2,r2,-31468
811422e4:	180691ba 	slli	r3,r3,6
811422e8:	10c5883a 	add	r2,r2,r3
811422ec:	10800604 	addi	r2,r2,24
811422f0:	10800017 	ldw	r2,0(r2)
811422f4:	10c00044 	addi	r3,r2,1
811422f8:	00a045f4 	movhi	r2,33047
811422fc:	10a14504 	addi	r2,r2,-31468
81142300:	200891ba 	slli	r4,r4,6
81142304:	1105883a 	add	r2,r2,r4
81142308:	10800604 	addi	r2,r2,24
8114230c:	10c00015 	stw	r3,0(r2)
				active_files[file_handle].modified = true;
81142310:	e0fffe0f 	ldh	r3,-8(fp)
81142314:	00a045f4 	movhi	r2,33047
81142318:	10a14504 	addi	r2,r2,-31468
8114231c:	180691ba 	slli	r3,r3,6
81142320:	10c5883a 	add	r2,r2,r3
81142324:	10800e04 	addi	r2,r2,56
81142328:	00c00044 	movi	r3,1
8114232c:	10c00015 	stw	r3,0(r2)
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
81142330:	00800044 	movi	r2,1
81142334:	d0a0b015 	stw	r2,-32064(gp)
			result = true;
81142338:	00800044 	movi	r2,1
8114233c:	e0bffa15 	stw	r2,-24(fp)
		}
    }
    
    return result;
81142340:	e0bffa17 	ldw	r2,-24(fp)
}
81142344:	e037883a 	mov	sp,fp
81142348:	dfc00117 	ldw	ra,4(sp)
8114234c:	df000017 	ldw	fp,0(sp)
81142350:	dec00204 	addi	sp,sp,8
81142354:	f800283a 	ret

81142358 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
81142358:	defffb04 	addi	sp,sp,-20
8114235c:	de00012e 	bgeu	sp,et,81142364 <alt_up_sd_card_fclose+0xc>
81142360:	003b68fa 	trap	3
81142364:	dfc00415 	stw	ra,16(sp)
81142368:	df000315 	stw	fp,12(sp)
8114236c:	df000304 	addi	fp,sp,12
81142370:	2005883a 	mov	r2,r4
81142374:	e0bfff0d 	sth	r2,-4(fp)
    bool result = false;
81142378:	e03ffd15 	stw	zero,-12(fp)
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
8114237c:	1140f340 	call	81140f34 <alt_up_sd_card_is_Present>
81142380:	10006026 	beq	r2,zero,81142504 <alt_up_sd_card_fclose+0x1ac>
81142384:	d0a0a617 	ldw	r2,-32104(gp)
81142388:	10005e26 	beq	r2,zero,81142504 <alt_up_sd_card_fclose+0x1ac>
    {
        if (active_files[file_handle].in_use) 
8114238c:	e0ffff0f 	ldh	r3,-4(fp)
81142390:	00a045f4 	movhi	r2,33047
81142394:	10a14504 	addi	r2,r2,-31468
81142398:	180691ba 	slli	r3,r3,6
8114239c:	10c5883a 	add	r2,r2,r3
811423a0:	10800f04 	addi	r2,r2,60
811423a4:	10800017 	ldw	r2,0(r2)
811423a8:	10005626 	beq	r2,zero,81142504 <alt_up_sd_card_fclose+0x1ac>
        {
			if (active_files[file_handle].modified)
811423ac:	e0ffff0f 	ldh	r3,-4(fp)
811423b0:	00a045f4 	movhi	r2,33047
811423b4:	10a14504 	addi	r2,r2,-31468
811423b8:	180691ba 	slli	r3,r3,6
811423bc:	10c5883a 	add	r2,r2,r3
811423c0:	10800e04 	addi	r2,r2,56
811423c4:	10800017 	ldw	r2,0(r2)
811423c8:	10004526 	beq	r2,zero,811424e0 <alt_up_sd_card_fclose+0x188>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
811423cc:	e0ffff0f 	ldh	r3,-4(fp)
811423d0:	00a045f4 	movhi	r2,33047
811423d4:	10a14504 	addi	r2,r2,-31468
811423d8:	180691ba 	slli	r3,r3,6
811423dc:	10c5883a 	add	r2,r2,r3
811423e0:	10800b04 	addi	r2,r2,44
811423e4:	10800017 	ldw	r2,0(r2)
811423e8:	e0bffe15 	stw	r2,-8(fp)
				if (active_files[file_handle].file_record_cluster == 0)
811423ec:	e0ffff0f 	ldh	r3,-4(fp)
811423f0:	00a045f4 	movhi	r2,33047
811423f4:	10a14504 	addi	r2,r2,-31468
811423f8:	180691ba 	slli	r3,r3,6
811423fc:	10c5883a 	add	r2,r2,r3
81142400:	10800a04 	addi	r2,r2,40
81142404:	10800017 	ldw	r2,0(r2)
81142408:	1000071e 	bne	r2,zero,81142428 <alt_up_sd_card_fclose+0xd0>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
8114240c:	00a045f4 	movhi	r2,33047
81142410:	10a13004 	addi	r2,r2,-31552
81142414:	10801317 	ldw	r2,76(r2)
81142418:	e0fffe17 	ldw	r3,-8(fp)
8114241c:	1885883a 	add	r2,r3,r2
81142420:	e0bffe15 	stw	r2,-8(fp)
81142424:	00001406 	br	81142478 <alt_up_sd_card_fclose+0x120>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81142428:	00a045f4 	movhi	r2,33047
8114242c:	10a13004 	addi	r2,r2,-31552
81142430:	10c01417 	ldw	r3,80(r2)
81142434:	e0bffe17 	ldw	r2,-8(fp)
81142438:	1887883a 	add	r3,r3,r2
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
8114243c:	e13fff0f 	ldh	r4,-4(fp)
81142440:	00a045f4 	movhi	r2,33047
81142444:	10a14504 	addi	r2,r2,-31468
81142448:	200891ba 	slli	r4,r4,6
8114244c:	1105883a 	add	r2,r2,r4
81142450:	10800a04 	addi	r2,r2,40
81142454:	10800017 	ldw	r2,0(r2)
81142458:	113fff84 	addi	r4,r2,-2
8114245c:	00a045f4 	movhi	r2,33047
81142460:	10a13004 	addi	r2,r2,-31552
81142464:	10800383 	ldbu	r2,14(r2)
81142468:	10803fcc 	andi	r2,r2,255
8114246c:	2085383a 	mul	r2,r4,r2
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
81142470:	1885883a 	add	r2,r3,r2
81142474:	e0bffe15 	stw	r2,-8(fp)
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
81142478:	e0bffe17 	ldw	r2,-8(fp)
8114247c:	d0e0ad17 	ldw	r3,-32076(gp)
81142480:	180b883a 	mov	r5,r3
81142484:	1009883a 	mov	r4,r2
81142488:	113e25c0 	call	8113e25c <Read_Sector_Data>
8114248c:	10001426 	beq	r2,zero,811424e0 <alt_up_sd_card_fclose+0x188>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
81142490:	e0ffff0f 	ldh	r3,-4(fp)
81142494:	00a045f4 	movhi	r2,33047
81142498:	10a14504 	addi	r2,r2,-31468
8114249c:	180691ba 	slli	r3,r3,6
811424a0:	10c5883a 	add	r2,r2,r3
811424a4:	10800c04 	addi	r2,r2,48
811424a8:	1080000b 	ldhu	r2,0(r2)
811424ac:	113fffcc 	andi	r4,r2,65535
811424b0:	2120001c 	xori	r4,r4,32768
811424b4:	21200004 	addi	r4,r4,-32768
811424b8:	e0bfff0f 	ldh	r2,-4(fp)
811424bc:	100691ba 	slli	r3,r2,6
811424c0:	00a045f4 	movhi	r2,33047
811424c4:	10a14504 	addi	r2,r2,-31468
811424c8:	1885883a 	add	r2,r3,r2
811424cc:	100b883a 	mov	r5,r2
811424d0:	113e9100 	call	8113e910 <Write_File_Record_At_Offset>
811424d4:	10000226 	beq	r2,zero,811424e0 <alt_up_sd_card_fclose+0x188>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
811424d8:	113e2080 	call	8113e208 <Save_Modified_Sector>
811424dc:	e0bffd15 	stw	r2,-12(fp)
					}
				}
			}
			active_files[file_handle].in_use = false;
811424e0:	e0ffff0f 	ldh	r3,-4(fp)
811424e4:	00a045f4 	movhi	r2,33047
811424e8:	10a14504 	addi	r2,r2,-31468
811424ec:	180691ba 	slli	r3,r3,6
811424f0:	10c5883a 	add	r2,r2,r3
811424f4:	10800f04 	addi	r2,r2,60
811424f8:	10000015 	stw	zero,0(r2)
			result = true;
811424fc:	00800044 	movi	r2,1
81142500:	e0bffd15 	stw	r2,-12(fp)
        }
    }
    
    return result;
81142504:	e0bffd17 	ldw	r2,-12(fp)
}
81142508:	e037883a 	mov	sp,fp
8114250c:	dfc00117 	ldw	ra,4(sp)
81142510:	df000017 	ldw	fp,0(sp)
81142514:	dec00204 	addi	sp,sp,8
81142518:	f800283a 	ret

8114251c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
8114251c:	defffa04 	addi	sp,sp,-24
81142520:	de00012e 	bgeu	sp,et,81142528 <altera_avalon_jtag_uart_read_fd+0xc>
81142524:	003b68fa 	trap	3
81142528:	dfc00515 	stw	ra,20(sp)
8114252c:	df000415 	stw	fp,16(sp)
81142530:	df000404 	addi	fp,sp,16
81142534:	e13ffd15 	stw	r4,-12(fp)
81142538:	e17ffe15 	stw	r5,-8(fp)
8114253c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81142540:	e0bffd17 	ldw	r2,-12(fp)
81142544:	10800017 	ldw	r2,0(r2)
81142548:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
8114254c:	e0bffc17 	ldw	r2,-16(fp)
81142550:	10c00a04 	addi	r3,r2,40
81142554:	e0bffd17 	ldw	r2,-12(fp)
81142558:	10800217 	ldw	r2,8(r2)
8114255c:	100f883a 	mov	r7,r2
81142560:	e1bfff17 	ldw	r6,-4(fp)
81142564:	e17ffe17 	ldw	r5,-8(fp)
81142568:	1809883a 	mov	r4,r3
8114256c:	1142da00 	call	81142da0 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
81142570:	e037883a 	mov	sp,fp
81142574:	dfc00117 	ldw	ra,4(sp)
81142578:	df000017 	ldw	fp,0(sp)
8114257c:	dec00204 	addi	sp,sp,8
81142580:	f800283a 	ret

81142584 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
81142584:	defffa04 	addi	sp,sp,-24
81142588:	de00012e 	bgeu	sp,et,81142590 <altera_avalon_jtag_uart_write_fd+0xc>
8114258c:	003b68fa 	trap	3
81142590:	dfc00515 	stw	ra,20(sp)
81142594:	df000415 	stw	fp,16(sp)
81142598:	df000404 	addi	fp,sp,16
8114259c:	e13ffd15 	stw	r4,-12(fp)
811425a0:	e17ffe15 	stw	r5,-8(fp)
811425a4:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
811425a8:	e0bffd17 	ldw	r2,-12(fp)
811425ac:	10800017 	ldw	r2,0(r2)
811425b0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
811425b4:	e0bffc17 	ldw	r2,-16(fp)
811425b8:	10c00a04 	addi	r3,r2,40
811425bc:	e0bffd17 	ldw	r2,-12(fp)
811425c0:	10800217 	ldw	r2,8(r2)
811425c4:	100f883a 	mov	r7,r2
811425c8:	e1bfff17 	ldw	r6,-4(fp)
811425cc:	e17ffe17 	ldw	r5,-8(fp)
811425d0:	1809883a 	mov	r4,r3
811425d4:	11430640 	call	81143064 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
811425d8:	e037883a 	mov	sp,fp
811425dc:	dfc00117 	ldw	ra,4(sp)
811425e0:	df000017 	ldw	fp,0(sp)
811425e4:	dec00204 	addi	sp,sp,8
811425e8:	f800283a 	ret

811425ec <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
811425ec:	defffc04 	addi	sp,sp,-16
811425f0:	de00012e 	bgeu	sp,et,811425f8 <altera_avalon_jtag_uart_close_fd+0xc>
811425f4:	003b68fa 	trap	3
811425f8:	dfc00315 	stw	ra,12(sp)
811425fc:	df000215 	stw	fp,8(sp)
81142600:	df000204 	addi	fp,sp,8
81142604:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
81142608:	e0bfff17 	ldw	r2,-4(fp)
8114260c:	10800017 	ldw	r2,0(r2)
81142610:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
81142614:	e0bffe17 	ldw	r2,-8(fp)
81142618:	10c00a04 	addi	r3,r2,40
8114261c:	e0bfff17 	ldw	r2,-4(fp)
81142620:	10800217 	ldw	r2,8(r2)
81142624:	100b883a 	mov	r5,r2
81142628:	1809883a 	mov	r4,r3
8114262c:	1142c380 	call	81142c38 <altera_avalon_jtag_uart_close>
}
81142630:	e037883a 	mov	sp,fp
81142634:	dfc00117 	ldw	ra,4(sp)
81142638:	df000017 	ldw	fp,0(sp)
8114263c:	dec00204 	addi	sp,sp,8
81142640:	f800283a 	ret

81142644 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
81142644:	defffa04 	addi	sp,sp,-24
81142648:	de00012e 	bgeu	sp,et,81142650 <altera_avalon_jtag_uart_ioctl_fd+0xc>
8114264c:	003b68fa 	trap	3
81142650:	dfc00515 	stw	ra,20(sp)
81142654:	df000415 	stw	fp,16(sp)
81142658:	df000404 	addi	fp,sp,16
8114265c:	e13ffd15 	stw	r4,-12(fp)
81142660:	e17ffe15 	stw	r5,-8(fp)
81142664:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
81142668:	e0bffd17 	ldw	r2,-12(fp)
8114266c:	10800017 	ldw	r2,0(r2)
81142670:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
81142674:	e0bffc17 	ldw	r2,-16(fp)
81142678:	10800a04 	addi	r2,r2,40
8114267c:	e1bfff17 	ldw	r6,-4(fp)
81142680:	e17ffe17 	ldw	r5,-8(fp)
81142684:	1009883a 	mov	r4,r2
81142688:	1142ca80 	call	81142ca8 <altera_avalon_jtag_uart_ioctl>
}
8114268c:	e037883a 	mov	sp,fp
81142690:	dfc00117 	ldw	ra,4(sp)
81142694:	df000017 	ldw	fp,0(sp)
81142698:	dec00204 	addi	sp,sp,8
8114269c:	f800283a 	ret

811426a0 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
811426a0:	deffef04 	addi	sp,sp,-68
811426a4:	de00012e 	bgeu	sp,et,811426ac <altera_avalon_jtag_uart_init+0xc>
811426a8:	003b68fa 	trap	3
811426ac:	dfc01015 	stw	ra,64(sp)
811426b0:	df000f15 	stw	fp,60(sp)
811426b4:	dc400e15 	stw	r17,56(sp)
811426b8:	dc000d15 	stw	r16,52(sp)
811426bc:	df000f04 	addi	fp,sp,60
811426c0:	e13ff715 	stw	r4,-36(fp)
811426c4:	e17ff815 	stw	r5,-32(fp)
811426c8:	e1bff915 	stw	r6,-28(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
811426cc:	e0bff717 	ldw	r2,-36(fp)
811426d0:	10800c04 	addi	r2,r2,48
811426d4:	e0bff215 	stw	r2,-56(fp)
811426d8:	e03ff60d 	sth	zero,-40(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811426dc:	e0bff60b 	ldhu	r2,-40(fp)
811426e0:	e0fff684 	addi	r3,fp,-38
811426e4:	180b883a 	mov	r5,r3
811426e8:	1009883a 	mov	r4,r2
811426ec:	11368700 	call	81136870 <OSFlagCreate>
811426f0:	1007883a 	mov	r3,r2
811426f4:	e0bff217 	ldw	r2,-56(fp)
811426f8:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
811426fc:	e0bff717 	ldw	r2,-36(fp)
81142700:	10800a04 	addi	r2,r2,40
81142704:	e0bff315 	stw	r2,-52(fp)
81142708:	00800044 	movi	r2,1
8114270c:	e0bff58d 	sth	r2,-42(fp)
81142710:	e0bff58b 	ldhu	r2,-42(fp)
81142714:	1009883a 	mov	r4,r2
81142718:	113a7cc0 	call	8113a7cc <OSSemCreate>
8114271c:	1007883a 	mov	r3,r2
81142720:	e0bff317 	ldw	r2,-52(fp)
81142724:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
81142728:	e0bff717 	ldw	r2,-36(fp)
8114272c:	10800b04 	addi	r2,r2,44
81142730:	e0bff415 	stw	r2,-48(fp)
81142734:	00800044 	movi	r2,1
81142738:	e0bff50d 	sth	r2,-44(fp)
8114273c:	e0bff50b 	ldhu	r2,-44(fp)
81142740:	1009883a 	mov	r4,r2
81142744:	113a7cc0 	call	8113a7cc <OSSemCreate>
81142748:	1007883a 	mov	r3,r2
8114274c:	e0bff417 	ldw	r2,-48(fp)
81142750:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81142754:	e0bff717 	ldw	r2,-36(fp)
81142758:	00c00044 	movi	r3,1
8114275c:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
81142760:	e0bff717 	ldw	r2,-36(fp)
81142764:	10800017 	ldw	r2,0(r2)
81142768:	10800104 	addi	r2,r2,4
8114276c:	1007883a 	mov	r3,r2
81142770:	e0bff717 	ldw	r2,-36(fp)
81142774:	10800817 	ldw	r2,32(r2)
81142778:	18800035 	stwio	r2,0(r3)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
8114277c:	e0bff817 	ldw	r2,-32(fp)
81142780:	e0fff917 	ldw	r3,-28(fp)
81142784:	d8000015 	stw	zero,0(sp)
81142788:	e1fff717 	ldw	r7,-36(fp)
8114278c:	01a04534 	movhi	r6,33044
81142790:	318a1c04 	addi	r6,r6,10352
81142794:	180b883a 	mov	r5,r3
81142798:	1009883a 	mov	r4,r2
8114279c:	11465b80 	call	811465b8 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
811427a0:	e0bff717 	ldw	r2,-36(fp)
811427a4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
811427a8:	e0bff717 	ldw	r2,-36(fp)
811427ac:	10800204 	addi	r2,r2,8
811427b0:	d0e08417 	ldw	r3,-32240(gp)
811427b4:	e1fff717 	ldw	r7,-36(fp)
811427b8:	01a04534 	movhi	r6,33044
811427bc:	318acb04 	addi	r6,r6,11052
811427c0:	180b883a 	mov	r5,r3
811427c4:	1009883a 	mov	r4,r2
811427c8:	11461080 	call	81146108 <alt_alarm_start>
811427cc:	1000040e 	bge	r2,zero,811427e0 <altera_avalon_jtag_uart_init+0x140>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
811427d0:	e0fff717 	ldw	r3,-36(fp)
811427d4:	00a00034 	movhi	r2,32768
811427d8:	10bfffc4 	addi	r2,r2,-1
811427dc:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
811427e0:	d0a07d83 	ldbu	r2,-32266(gp)
811427e4:	10803fcc 	andi	r2,r2,255
811427e8:	10800058 	cmpnei	r2,r2,1
811427ec:	10000f1e 	bne	r2,zero,8114282c <altera_avalon_jtag_uart_init+0x18c>
811427f0:	d0e08417 	ldw	r3,-32240(gp)
811427f4:	00b33374 	movhi	r2,52429
811427f8:	10b33344 	addi	r2,r2,-13107
811427fc:	1888383a 	mulxuu	r4,r3,r2
81142800:	1885383a 	mul	r2,r3,r2
81142804:	1021883a 	mov	r16,r2
81142808:	2023883a 	mov	r17,r4
8114280c:	8804d0fa 	srli	r2,r17,3
81142810:	e1fff717 	ldw	r7,-36(fp)
81142814:	01a044f4 	movhi	r6,33043
81142818:	318be804 	addi	r6,r6,12192
8114281c:	100b883a 	mov	r5,r2
81142820:	012045b4 	movhi	r4,33046
81142824:	21090404 	addi	r4,r4,9232
81142828:	11461080 	call	81146108 <alt_alarm_start>
8114282c:	d0a07e03 	ldbu	r2,-32264(gp)
81142830:	10803fcc 	andi	r2,r2,255
81142834:	10800058 	cmpnei	r2,r2,1
81142838:	1000051e 	bne	r2,zero,81142850 <altera_avalon_jtag_uart_init+0x1b0>
8114283c:	e0bff717 	ldw	r2,-36(fp)
81142840:	10800017 	ldw	r2,0(r2)
81142844:	100b883a 	mov	r5,r2
81142848:	e13ff717 	ldw	r4,-36(fp)
8114284c:	11331380 	call	81133138 <alt_log_jtag_uart_startup_info>
}
81142850:	0001883a 	nop
81142854:	e6fffe04 	addi	sp,fp,-8
81142858:	dfc00317 	ldw	ra,12(sp)
8114285c:	df000217 	ldw	fp,8(sp)
81142860:	dc400117 	ldw	r17,4(sp)
81142864:	dc000017 	ldw	r16,0(sp)
81142868:	dec00404 	addi	sp,sp,16
8114286c:	f800283a 	ret

81142870 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
81142870:	defff204 	addi	sp,sp,-56
81142874:	de00012e 	bgeu	sp,et,8114287c <altera_avalon_jtag_uart_irq+0xc>
81142878:	003b68fa 	trap	3
8114287c:	dfc00d15 	stw	ra,52(sp)
81142880:	df000c15 	stw	fp,48(sp)
81142884:	df000c04 	addi	fp,sp,48
81142888:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
8114288c:	e0bfff17 	ldw	r2,-4(fp)
81142890:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
81142894:	e0bff617 	ldw	r2,-40(fp)
81142898:	10800017 	ldw	r2,0(r2)
8114289c:	e0bff715 	stw	r2,-36(fp)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);
811428a0:	e0bff717 	ldw	r2,-36(fp)
811428a4:	e17ff617 	ldw	r5,-40(fp)
811428a8:	1009883a 	mov	r4,r2
811428ac:	113318c0 	call	8113318c <alt_log_jtag_uart_isr_proc>

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811428b0:	e0bff717 	ldw	r2,-36(fp)
811428b4:	10800104 	addi	r2,r2,4
811428b8:	10800037 	ldwio	r2,0(r2)
811428bc:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
811428c0:	e0bff817 	ldw	r2,-32(fp)
811428c4:	1080c00c 	andi	r2,r2,768
811428c8:	10009126 	beq	r2,zero,81142b10 <altera_avalon_jtag_uart_irq+0x2a0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
811428cc:	e0bff817 	ldw	r2,-32(fp)
811428d0:	1080400c 	andi	r2,r2,256
811428d4:	10004726 	beq	r2,zero,811429f4 <altera_avalon_jtag_uart_irq+0x184>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
811428d8:	00800074 	movhi	r2,1
811428dc:	e0bff415 	stw	r2,-48(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
811428e0:	e0bff617 	ldw	r2,-40(fp)
811428e4:	10800d17 	ldw	r2,52(r2)
811428e8:	10800044 	addi	r2,r2,1
811428ec:	1081ffcc 	andi	r2,r2,2047
811428f0:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
811428f4:	e0bff617 	ldw	r2,-40(fp)
811428f8:	10c00e17 	ldw	r3,56(r2)
811428fc:	e0bff917 	ldw	r2,-28(fp)
81142900:	18802726 	beq	r3,r2,811429a0 <altera_avalon_jtag_uart_irq+0x130>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
81142904:	e0bff717 	ldw	r2,-36(fp)
81142908:	10800037 	ldwio	r2,0(r2)
8114290c:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
81142910:	e0bff417 	ldw	r2,-48(fp)
81142914:	10a0000c 	andi	r2,r2,32768
81142918:	10002326 	beq	r2,zero,811429a8 <altera_avalon_jtag_uart_irq+0x138>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
8114291c:	e0bff617 	ldw	r2,-40(fp)
81142920:	10800d17 	ldw	r2,52(r2)
81142924:	e0fff417 	ldw	r3,-48(fp)
81142928:	1809883a 	mov	r4,r3
8114292c:	e0fff617 	ldw	r3,-40(fp)
81142930:	1885883a 	add	r2,r3,r2
81142934:	10801104 	addi	r2,r2,68
81142938:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
8114293c:	e0bff617 	ldw	r2,-40(fp)
81142940:	10800d17 	ldw	r2,52(r2)
81142944:	10800044 	addi	r2,r2,1
81142948:	10c1ffcc 	andi	r3,r2,2047
8114294c:	e0bff617 	ldw	r2,-40(fp)
81142950:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
81142954:	e0bff617 	ldw	r2,-40(fp)
81142958:	10800c17 	ldw	r2,48(r2)
8114295c:	e0bffb15 	stw	r2,-20(fp)
81142960:	00800044 	movi	r2,1
81142964:	e0bffc0d 	sth	r2,-16(fp)
81142968:	00800044 	movi	r2,1
8114296c:	e0bffc85 	stb	r2,-14(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142970:	d0a08d03 	ldbu	r2,-32204(gp)
81142974:	10803fcc 	andi	r2,r2,255
81142978:	103fd926 	beq	r2,zero,811428e0 <__reset+0xfb1228e0>
  {
    OSFlagPost (group, flags, opt, &err);
8114297c:	e0bffc0b 	ldhu	r2,-16(fp)
81142980:	e0fffc83 	ldbu	r3,-14(fp)
81142984:	e13ffdc4 	addi	r4,fp,-9
81142988:	200f883a 	mov	r7,r4
8114298c:	180d883a 	mov	r6,r3
81142990:	100b883a 	mov	r5,r2
81142994:	e13ffb17 	ldw	r4,-20(fp)
81142998:	113747c0 	call	8113747c <OSFlagPost>
      }
8114299c:	003fd006 	br	811428e0 <__reset+0xfb1228e0>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
811429a0:	0001883a 	nop
811429a4:	00000106 	br	811429ac <altera_avalon_jtag_uart_irq+0x13c>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
811429a8:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
811429ac:	e0bff417 	ldw	r2,-48(fp)
811429b0:	10bfffec 	andhi	r2,r2,65535
811429b4:	10000f26 	beq	r2,zero,811429f4 <altera_avalon_jtag_uart_irq+0x184>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
811429b8:	e0bff617 	ldw	r2,-40(fp)
811429bc:	10c00817 	ldw	r3,32(r2)
811429c0:	00bfff84 	movi	r2,-2
811429c4:	1886703a 	and	r3,r3,r2
811429c8:	e0bff617 	ldw	r2,-40(fp)
811429cc:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
811429d0:	e0bff717 	ldw	r2,-36(fp)
811429d4:	10800104 	addi	r2,r2,4
811429d8:	1007883a 	mov	r3,r2
811429dc:	e0bff617 	ldw	r2,-40(fp)
811429e0:	10800817 	ldw	r2,32(r2)
811429e4:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
811429e8:	e0bff717 	ldw	r2,-36(fp)
811429ec:	10800104 	addi	r2,r2,4
811429f0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
811429f4:	e0bff817 	ldw	r2,-32(fp)
811429f8:	1080800c 	andi	r2,r2,512
811429fc:	103fac26 	beq	r2,zero,811428b0 <__reset+0xfb1228b0>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
81142a00:	e0bff817 	ldw	r2,-32(fp)
81142a04:	1004d43a 	srli	r2,r2,16
81142a08:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
81142a0c:	00002606 	br	81142aa8 <altera_avalon_jtag_uart_irq+0x238>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
81142a10:	e0bff717 	ldw	r2,-36(fp)
81142a14:	e0fff617 	ldw	r3,-40(fp)
81142a18:	18c01017 	ldw	r3,64(r3)
81142a1c:	e13ff617 	ldw	r4,-40(fp)
81142a20:	20c7883a 	add	r3,r4,r3
81142a24:	18c21104 	addi	r3,r3,2116
81142a28:	18c00003 	ldbu	r3,0(r3)
81142a2c:	18c03fcc 	andi	r3,r3,255
81142a30:	18c0201c 	xori	r3,r3,128
81142a34:	18ffe004 	addi	r3,r3,-128
81142a38:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81142a3c:	e0bff617 	ldw	r2,-40(fp)
81142a40:	10801017 	ldw	r2,64(r2)
81142a44:	10800044 	addi	r2,r2,1
81142a48:	10c1ffcc 	andi	r3,r2,2047
81142a4c:	e0bff617 	ldw	r2,-40(fp)
81142a50:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
81142a54:	e0bff617 	ldw	r2,-40(fp)
81142a58:	10800c17 	ldw	r2,48(r2)
81142a5c:	e0bffa15 	stw	r2,-24(fp)
81142a60:	00800084 	movi	r2,2
81142a64:	e0bffd0d 	sth	r2,-12(fp)
81142a68:	00800044 	movi	r2,1
81142a6c:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142a70:	d0a08d03 	ldbu	r2,-32204(gp)
81142a74:	10803fcc 	andi	r2,r2,255
81142a78:	10000826 	beq	r2,zero,81142a9c <altera_avalon_jtag_uart_irq+0x22c>
  {
    OSFlagPost (group, flags, opt, &err);
81142a7c:	e0bffd0b 	ldhu	r2,-12(fp)
81142a80:	e0fffd83 	ldbu	r3,-10(fp)
81142a84:	e13ffe04 	addi	r4,fp,-8
81142a88:	200f883a 	mov	r7,r4
81142a8c:	180d883a 	mov	r6,r3
81142a90:	100b883a 	mov	r5,r2
81142a94:	e13ffa17 	ldw	r4,-24(fp)
81142a98:	113747c0 	call	8113747c <OSFlagPost>

        space--;
81142a9c:	e0bff517 	ldw	r2,-44(fp)
81142aa0:	10bfffc4 	addi	r2,r2,-1
81142aa4:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
81142aa8:	e0bff517 	ldw	r2,-44(fp)
81142aac:	10000526 	beq	r2,zero,81142ac4 <altera_avalon_jtag_uart_irq+0x254>
81142ab0:	e0bff617 	ldw	r2,-40(fp)
81142ab4:	10c01017 	ldw	r3,64(r2)
81142ab8:	e0bff617 	ldw	r2,-40(fp)
81142abc:	10800f17 	ldw	r2,60(r2)
81142ac0:	18bfd31e 	bne	r3,r2,81142a10 <__reset+0xfb122a10>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
81142ac4:	e0bff517 	ldw	r2,-44(fp)
81142ac8:	103f7926 	beq	r2,zero,811428b0 <__reset+0xfb1228b0>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
81142acc:	e0bff617 	ldw	r2,-40(fp)
81142ad0:	10c00817 	ldw	r3,32(r2)
81142ad4:	00bfff44 	movi	r2,-3
81142ad8:	1886703a 	and	r3,r3,r2
81142adc:	e0bff617 	ldw	r2,-40(fp)
81142ae0:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81142ae4:	e0bff617 	ldw	r2,-40(fp)
81142ae8:	10800017 	ldw	r2,0(r2)
81142aec:	10800104 	addi	r2,r2,4
81142af0:	1007883a 	mov	r3,r2
81142af4:	e0bff617 	ldw	r2,-40(fp)
81142af8:	10800817 	ldw	r2,32(r2)
81142afc:	18800035 	stwio	r2,0(r3)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
81142b00:	e0bff717 	ldw	r2,-36(fp)
81142b04:	10800104 	addi	r2,r2,4
81142b08:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
81142b0c:	003f6806 	br	811428b0 <__reset+0xfb1228b0>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
81142b10:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
81142b14:	0001883a 	nop
81142b18:	e037883a 	mov	sp,fp
81142b1c:	dfc00117 	ldw	ra,4(sp)
81142b20:	df000017 	ldw	fp,0(sp)
81142b24:	dec00204 	addi	sp,sp,8
81142b28:	f800283a 	ret

81142b2c <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
81142b2c:	defff904 	addi	sp,sp,-28
81142b30:	de00012e 	bgeu	sp,et,81142b38 <altera_avalon_jtag_uart_timeout+0xc>
81142b34:	003b68fa 	trap	3
81142b38:	dfc00615 	stw	ra,24(sp)
81142b3c:	df000515 	stw	fp,20(sp)
81142b40:	df000504 	addi	fp,sp,20
81142b44:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
81142b48:	e0bfff17 	ldw	r2,-4(fp)
81142b4c:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
81142b50:	e0bffb17 	ldw	r2,-20(fp)
81142b54:	10800017 	ldw	r2,0(r2)
81142b58:	10800104 	addi	r2,r2,4
81142b5c:	10800037 	ldwio	r2,0(r2)
81142b60:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
81142b64:	e0bffc17 	ldw	r2,-16(fp)
81142b68:	1081000c 	andi	r2,r2,1024
81142b6c:	10000b26 	beq	r2,zero,81142b9c <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
81142b70:	e0bffb17 	ldw	r2,-20(fp)
81142b74:	10800017 	ldw	r2,0(r2)
81142b78:	10800104 	addi	r2,r2,4
81142b7c:	1007883a 	mov	r3,r2
81142b80:	e0bffb17 	ldw	r2,-20(fp)
81142b84:	10800817 	ldw	r2,32(r2)
81142b88:	10810014 	ori	r2,r2,1024
81142b8c:	18800035 	stwio	r2,0(r3)
    sp->host_inactive = 0;
81142b90:	e0bffb17 	ldw	r2,-20(fp)
81142b94:	10000915 	stw	zero,36(r2)
81142b98:	00002106 	br	81142c20 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
81142b9c:	e0bffb17 	ldw	r2,-20(fp)
81142ba0:	10c00917 	ldw	r3,36(r2)
81142ba4:	00a00034 	movhi	r2,32768
81142ba8:	10bfff04 	addi	r2,r2,-4
81142bac:	10c01c36 	bltu	r2,r3,81142c20 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
81142bb0:	e0bffb17 	ldw	r2,-20(fp)
81142bb4:	10800917 	ldw	r2,36(r2)
81142bb8:	10c00044 	addi	r3,r2,1
81142bbc:	e0bffb17 	ldw	r2,-20(fp)
81142bc0:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
81142bc4:	e0bffb17 	ldw	r2,-20(fp)
81142bc8:	10c00917 	ldw	r3,36(r2)
81142bcc:	e0bffb17 	ldw	r2,-20(fp)
81142bd0:	10800117 	ldw	r2,4(r2)
81142bd4:	18801236 	bltu	r3,r2,81142c20 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
81142bd8:	e0bffb17 	ldw	r2,-20(fp)
81142bdc:	10800c17 	ldw	r2,48(r2)
81142be0:	e0bffd15 	stw	r2,-12(fp)
81142be4:	00800104 	movi	r2,4
81142be8:	e0bffe0d 	sth	r2,-8(fp)
81142bec:	00800044 	movi	r2,1
81142bf0:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81142bf4:	d0a08d03 	ldbu	r2,-32204(gp)
81142bf8:	10803fcc 	andi	r2,r2,255
81142bfc:	10000826 	beq	r2,zero,81142c20 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
81142c00:	e0bffe0b 	ldhu	r2,-8(fp)
81142c04:	e0fffe83 	ldbu	r3,-6(fp)
81142c08:	e13ffec4 	addi	r4,fp,-5
81142c0c:	200f883a 	mov	r7,r4
81142c10:	180d883a 	mov	r6,r3
81142c14:	100b883a 	mov	r5,r2
81142c18:	e13ffd17 	ldw	r4,-12(fp)
81142c1c:	113747c0 	call	8113747c <OSFlagPost>
81142c20:	d0a08417 	ldw	r2,-32240(gp)
    }
  }

  return alt_ticks_per_second();
}
81142c24:	e037883a 	mov	sp,fp
81142c28:	dfc00117 	ldw	ra,4(sp)
81142c2c:	df000017 	ldw	fp,0(sp)
81142c30:	dec00204 	addi	sp,sp,8
81142c34:	f800283a 	ret

81142c38 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
81142c38:	defffd04 	addi	sp,sp,-12
81142c3c:	de00012e 	bgeu	sp,et,81142c44 <altera_avalon_jtag_uart_close+0xc>
81142c40:	003b68fa 	trap	3
81142c44:	df000215 	stw	fp,8(sp)
81142c48:	df000204 	addi	fp,sp,8
81142c4c:	e13ffe15 	stw	r4,-8(fp)
81142c50:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81142c54:	00000506 	br	81142c6c <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81142c58:	e0bfff17 	ldw	r2,-4(fp)
81142c5c:	1090000c 	andi	r2,r2,16384
81142c60:	10000226 	beq	r2,zero,81142c6c <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
81142c64:	00bffd44 	movi	r2,-11
81142c68:	00000b06 	br	81142c98 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
81142c6c:	e0bffe17 	ldw	r2,-8(fp)
81142c70:	10c01017 	ldw	r3,64(r2)
81142c74:	e0bffe17 	ldw	r2,-8(fp)
81142c78:	10800f17 	ldw	r2,60(r2)
81142c7c:	18800526 	beq	r3,r2,81142c94 <altera_avalon_jtag_uart_close+0x5c>
81142c80:	e0bffe17 	ldw	r2,-8(fp)
81142c84:	10c00917 	ldw	r3,36(r2)
81142c88:	e0bffe17 	ldw	r2,-8(fp)
81142c8c:	10800117 	ldw	r2,4(r2)
81142c90:	18bff136 	bltu	r3,r2,81142c58 <__reset+0xfb122c58>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81142c94:	0005883a 	mov	r2,zero
}
81142c98:	e037883a 	mov	sp,fp
81142c9c:	df000017 	ldw	fp,0(sp)
81142ca0:	dec00104 	addi	sp,sp,4
81142ca4:	f800283a 	ret

81142ca8 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
81142ca8:	defffa04 	addi	sp,sp,-24
81142cac:	de00012e 	bgeu	sp,et,81142cb4 <altera_avalon_jtag_uart_ioctl+0xc>
81142cb0:	003b68fa 	trap	3
81142cb4:	df000515 	stw	fp,20(sp)
81142cb8:	df000504 	addi	fp,sp,20
81142cbc:	e13ffd15 	stw	r4,-12(fp)
81142cc0:	e17ffe15 	stw	r5,-8(fp)
81142cc4:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
81142cc8:	00bff9c4 	movi	r2,-25
81142ccc:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
81142cd0:	e0bffe17 	ldw	r2,-8(fp)
81142cd4:	10da8060 	cmpeqi	r3,r2,27137
81142cd8:	1800031e 	bne	r3,zero,81142ce8 <altera_avalon_jtag_uart_ioctl+0x40>
81142cdc:	109a80a0 	cmpeqi	r2,r2,27138
81142ce0:	1000181e 	bne	r2,zero,81142d44 <altera_avalon_jtag_uart_ioctl+0x9c>
      rc = 0;
    }
    break;

  default:
    break;
81142ce4:	00002906 	br	81142d8c <altera_avalon_jtag_uart_ioctl+0xe4>

  switch (req)
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
81142ce8:	e0bffd17 	ldw	r2,-12(fp)
81142cec:	10c00117 	ldw	r3,4(r2)
81142cf0:	00a00034 	movhi	r2,32768
81142cf4:	10bfffc4 	addi	r2,r2,-1
81142cf8:	18802126 	beq	r3,r2,81142d80 <altera_avalon_jtag_uart_ioctl+0xd8>
    {
      int timeout = *((int *)arg);
81142cfc:	e0bfff17 	ldw	r2,-4(fp)
81142d00:	10800017 	ldw	r2,0(r2)
81142d04:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
81142d08:	e0bffc17 	ldw	r2,-16(fp)
81142d0c:	10800090 	cmplti	r2,r2,2
81142d10:	1000061e 	bne	r2,zero,81142d2c <altera_avalon_jtag_uart_ioctl+0x84>
81142d14:	e0fffc17 	ldw	r3,-16(fp)
81142d18:	00a00034 	movhi	r2,32768
81142d1c:	10bfffc4 	addi	r2,r2,-1
81142d20:	18800226 	beq	r3,r2,81142d2c <altera_avalon_jtag_uart_ioctl+0x84>
81142d24:	e0bffc17 	ldw	r2,-16(fp)
81142d28:	00000206 	br	81142d34 <altera_avalon_jtag_uart_ioctl+0x8c>
81142d2c:	00a00034 	movhi	r2,32768
81142d30:	10bfff84 	addi	r2,r2,-2
81142d34:	e0fffd17 	ldw	r3,-12(fp)
81142d38:	18800115 	stw	r2,4(r3)
      rc = 0;
81142d3c:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81142d40:	00000f06 	br	81142d80 <altera_avalon_jtag_uart_ioctl+0xd8>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
81142d44:	e0bffd17 	ldw	r2,-12(fp)
81142d48:	10c00117 	ldw	r3,4(r2)
81142d4c:	00a00034 	movhi	r2,32768
81142d50:	10bfffc4 	addi	r2,r2,-1
81142d54:	18800c26 	beq	r3,r2,81142d88 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
81142d58:	e0bffd17 	ldw	r2,-12(fp)
81142d5c:	10c00917 	ldw	r3,36(r2)
81142d60:	e0bffd17 	ldw	r2,-12(fp)
81142d64:	10800117 	ldw	r2,4(r2)
81142d68:	1885803a 	cmpltu	r2,r3,r2
81142d6c:	10c03fcc 	andi	r3,r2,255
81142d70:	e0bfff17 	ldw	r2,-4(fp)
81142d74:	10c00015 	stw	r3,0(r2)
      rc = 0;
81142d78:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
81142d7c:	00000206 	br	81142d88 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
81142d80:	0001883a 	nop
81142d84:	00000106 	br	81142d8c <altera_avalon_jtag_uart_ioctl+0xe4>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
81142d88:	0001883a 	nop

  default:
    break;
  }

  return rc;
81142d8c:	e0bffb17 	ldw	r2,-20(fp)
}
81142d90:	e037883a 	mov	sp,fp
81142d94:	df000017 	ldw	fp,0(sp)
81142d98:	dec00104 	addi	sp,sp,4
81142d9c:	f800283a 	ret

81142da0 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
81142da0:	deffed04 	addi	sp,sp,-76
81142da4:	de00012e 	bgeu	sp,et,81142dac <altera_avalon_jtag_uart_read+0xc>
81142da8:	003b68fa 	trap	3
81142dac:	dfc01215 	stw	ra,72(sp)
81142db0:	df001115 	stw	fp,68(sp)
81142db4:	df001104 	addi	fp,sp,68
81142db8:	e13ffc15 	stw	r4,-16(fp)
81142dbc:	e17ffd15 	stw	r5,-12(fp)
81142dc0:	e1bffe15 	stw	r6,-8(fp)
81142dc4:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
81142dc8:	e0bffd17 	ldw	r2,-12(fp)
81142dcc:	e0bff015 	stw	r2,-64(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
81142dd0:	e0bffc17 	ldw	r2,-16(fp)
81142dd4:	10800a17 	ldw	r2,40(r2)
81142dd8:	e0bff815 	stw	r2,-32(fp)
81142ddc:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81142de0:	e0bff90b 	ldhu	r2,-28(fp)
81142de4:	e0fffb04 	addi	r3,fp,-20
81142de8:	180d883a 	mov	r6,r3
81142dec:	100b883a 	mov	r5,r2
81142df0:	e13ff817 	ldw	r4,-32(fp)
81142df4:	113aaf40 	call	8113aaf4 <OSSemPend>

  while (space > 0)
81142df8:	00006106 	br	81142f80 <altera_avalon_jtag_uart_read+0x1e0>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
81142dfc:	e0bffc17 	ldw	r2,-16(fp)
81142e00:	10800d17 	ldw	r2,52(r2)
81142e04:	e0bff315 	stw	r2,-52(fp)
      out = sp->rx_out;
81142e08:	e0bffc17 	ldw	r2,-16(fp)
81142e0c:	10800e17 	ldw	r2,56(r2)
81142e10:	e0bff415 	stw	r2,-48(fp)

      if (in >= out)
81142e14:	e0fff317 	ldw	r3,-52(fp)
81142e18:	e0bff417 	ldw	r2,-48(fp)
81142e1c:	18800536 	bltu	r3,r2,81142e34 <altera_avalon_jtag_uart_read+0x94>
        n = in - out;
81142e20:	e0fff317 	ldw	r3,-52(fp)
81142e24:	e0bff417 	ldw	r2,-48(fp)
81142e28:	1885c83a 	sub	r2,r3,r2
81142e2c:	e0bff115 	stw	r2,-60(fp)
81142e30:	00000406 	br	81142e44 <altera_avalon_jtag_uart_read+0xa4>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
81142e34:	00c20004 	movi	r3,2048
81142e38:	e0bff417 	ldw	r2,-48(fp)
81142e3c:	1885c83a 	sub	r2,r3,r2
81142e40:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
81142e44:	e0bff117 	ldw	r2,-60(fp)
81142e48:	10001e26 	beq	r2,zero,81142ec4 <altera_avalon_jtag_uart_read+0x124>
        break; /* No more data available */

      if (n > space)
81142e4c:	e0fffe17 	ldw	r3,-8(fp)
81142e50:	e0bff117 	ldw	r2,-60(fp)
81142e54:	1880022e 	bgeu	r3,r2,81142e60 <altera_avalon_jtag_uart_read+0xc0>
        n = space;
81142e58:	e0bffe17 	ldw	r2,-8(fp)
81142e5c:	e0bff115 	stw	r2,-60(fp)

      memcpy(ptr, sp->rx_buf + out, n);
81142e60:	e0bffc17 	ldw	r2,-16(fp)
81142e64:	10c01104 	addi	r3,r2,68
81142e68:	e0bff417 	ldw	r2,-48(fp)
81142e6c:	1885883a 	add	r2,r3,r2
81142e70:	e1bff117 	ldw	r6,-60(fp)
81142e74:	100b883a 	mov	r5,r2
81142e78:	e13ff017 	ldw	r4,-64(fp)
81142e7c:	111dac80 	call	8111dac8 <memcpy>
      ptr   += n;
81142e80:	e0fff017 	ldw	r3,-64(fp)
81142e84:	e0bff117 	ldw	r2,-60(fp)
81142e88:	1885883a 	add	r2,r3,r2
81142e8c:	e0bff015 	stw	r2,-64(fp)
      space -= n;
81142e90:	e0fffe17 	ldw	r3,-8(fp)
81142e94:	e0bff117 	ldw	r2,-60(fp)
81142e98:	1885c83a 	sub	r2,r3,r2
81142e9c:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81142ea0:	e0fff417 	ldw	r3,-48(fp)
81142ea4:	e0bff117 	ldw	r2,-60(fp)
81142ea8:	1885883a 	add	r2,r3,r2
81142eac:	10c1ffcc 	andi	r3,r2,2047
81142eb0:	e0bffc17 	ldw	r2,-16(fp)
81142eb4:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
81142eb8:	e0bffe17 	ldw	r2,-8(fp)
81142ebc:	00bfcf16 	blt	zero,r2,81142dfc <__reset+0xfb122dfc>
81142ec0:	00000106 	br	81142ec8 <altera_avalon_jtag_uart_read+0x128>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
81142ec4:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
81142ec8:	e0fff017 	ldw	r3,-64(fp)
81142ecc:	e0bffd17 	ldw	r2,-12(fp)
81142ed0:	18802e1e 	bne	r3,r2,81142f8c <altera_avalon_jtag_uart_read+0x1ec>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
81142ed4:	e0bfff17 	ldw	r2,-4(fp)
81142ed8:	1090000c 	andi	r2,r2,16384
81142edc:	10002d1e 	bne	r2,zero,81142f94 <altera_avalon_jtag_uart_read+0x1f4>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
81142ee0:	d0a08d03 	ldbu	r2,-32204(gp)
81142ee4:	10803fcc 	andi	r2,r2,255
81142ee8:	10800058 	cmpnei	r2,r2,1
81142eec:	1000161e 	bne	r2,zero,81142f48 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
81142ef0:	e0bffc17 	ldw	r2,-16(fp)
81142ef4:	10800c17 	ldw	r2,48(r2)
81142ef8:	e0bff215 	stw	r2,-56(fp)
81142efc:	00800144 	movi	r2,5
81142f00:	e0bff98d 	sth	r2,-26(fp)
81142f04:	00bfe0c4 	movi	r2,-125
81142f08:	e0bffa05 	stb	r2,-24(fp)
81142f0c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81142f10:	d0a08d03 	ldbu	r2,-32204(gp)
81142f14:	10803fcc 	andi	r2,r2,255
81142f18:	10001526 	beq	r2,zero,81142f70 <altera_avalon_jtag_uart_read+0x1d0>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81142f1c:	e0fff98b 	ldhu	r3,-26(fp)
81142f20:	e13ffa03 	ldbu	r4,-24(fp)
81142f24:	e17ffa8b 	ldhu	r5,-22(fp)
81142f28:	e0bffb44 	addi	r2,fp,-19
81142f2c:	d8800015 	stw	r2,0(sp)
81142f30:	280f883a 	mov	r7,r5
81142f34:	200d883a 	mov	r6,r4
81142f38:	180b883a 	mov	r5,r3
81142f3c:	e13ff217 	ldw	r4,-56(fp)
81142f40:	1136e540 	call	81136e54 <OSFlagPend>
81142f44:	00000a06 	br	81142f70 <altera_avalon_jtag_uart_read+0x1d0>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
81142f48:	0001883a 	nop
81142f4c:	e0bffc17 	ldw	r2,-16(fp)
81142f50:	10c00d17 	ldw	r3,52(r2)
81142f54:	e0bff317 	ldw	r2,-52(fp)
81142f58:	1880051e 	bne	r3,r2,81142f70 <altera_avalon_jtag_uart_read+0x1d0>
81142f5c:	e0bffc17 	ldw	r2,-16(fp)
81142f60:	10c00917 	ldw	r3,36(r2)
81142f64:	e0bffc17 	ldw	r2,-16(fp)
81142f68:	10800117 	ldw	r2,4(r2)
81142f6c:	18bff736 	bltu	r3,r2,81142f4c <__reset+0xfb122f4c>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
81142f70:	e0bffc17 	ldw	r2,-16(fp)
81142f74:	10c00d17 	ldw	r3,52(r2)
81142f78:	e0bff317 	ldw	r2,-52(fp)
81142f7c:	18800726 	beq	r3,r2,81142f9c <altera_avalon_jtag_uart_read+0x1fc>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
81142f80:	e0bffe17 	ldw	r2,-8(fp)
81142f84:	00bf9d16 	blt	zero,r2,81142dfc <__reset+0xfb122dfc>
81142f88:	00000506 	br	81142fa0 <altera_avalon_jtag_uart_read+0x200>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
81142f8c:	0001883a 	nop
81142f90:	00000306 	br	81142fa0 <altera_avalon_jtag_uart_read+0x200>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
81142f94:	0001883a 	nop
81142f98:	00000106 	br	81142fa0 <altera_avalon_jtag_uart_read+0x200>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
81142f9c:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81142fa0:	e0bffc17 	ldw	r2,-16(fp)
81142fa4:	10800a17 	ldw	r2,40(r2)
81142fa8:	1009883a 	mov	r4,r2
81142fac:	113ae7c0 	call	8113ae7c <OSSemPost>

  if (ptr != buffer)
81142fb0:	e0fff017 	ldw	r3,-64(fp)
81142fb4:	e0bffd17 	ldw	r2,-12(fp)
81142fb8:	18801826 	beq	r3,r2,8114301c <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81142fbc:	0005303a 	rdctl	r2,status
81142fc0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81142fc4:	e0fff717 	ldw	r3,-36(fp)
81142fc8:	00bfff84 	movi	r2,-2
81142fcc:	1884703a 	and	r2,r3,r2
81142fd0:	1001703a 	wrctl	status,r2
  
  return context;
81142fd4:	e0bff717 	ldw	r2,-36(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
81142fd8:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
81142fdc:	e0bffc17 	ldw	r2,-16(fp)
81142fe0:	10800817 	ldw	r2,32(r2)
81142fe4:	10c00054 	ori	r3,r2,1
81142fe8:	e0bffc17 	ldw	r2,-16(fp)
81142fec:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
81142ff0:	e0bffc17 	ldw	r2,-16(fp)
81142ff4:	10800017 	ldw	r2,0(r2)
81142ff8:	10800104 	addi	r2,r2,4
81142ffc:	1007883a 	mov	r3,r2
81143000:	e0bffc17 	ldw	r2,-16(fp)
81143004:	10800817 	ldw	r2,32(r2)
81143008:	18800035 	stwio	r2,0(r3)
8114300c:	e0bff617 	ldw	r2,-40(fp)
81143010:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143014:	e0bff517 	ldw	r2,-44(fp)
81143018:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
8114301c:	e0fff017 	ldw	r3,-64(fp)
81143020:	e0bffd17 	ldw	r2,-12(fp)
81143024:	18800426 	beq	r3,r2,81143038 <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
81143028:	e0fff017 	ldw	r3,-64(fp)
8114302c:	e0bffd17 	ldw	r2,-12(fp)
81143030:	1885c83a 	sub	r2,r3,r2
81143034:	00000606 	br	81143050 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
81143038:	e0bfff17 	ldw	r2,-4(fp)
8114303c:	1090000c 	andi	r2,r2,16384
81143040:	10000226 	beq	r2,zero,8114304c <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
81143044:	00bffd44 	movi	r2,-11
81143048:	00000106 	br	81143050 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
8114304c:	00bffec4 	movi	r2,-5
}
81143050:	e037883a 	mov	sp,fp
81143054:	dfc00117 	ldw	ra,4(sp)
81143058:	df000017 	ldw	fp,0(sp)
8114305c:	dec00204 	addi	sp,sp,8
81143060:	f800283a 	ret

81143064 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
81143064:	deffed04 	addi	sp,sp,-76
81143068:	de00012e 	bgeu	sp,et,81143070 <altera_avalon_jtag_uart_write+0xc>
8114306c:	003b68fa 	trap	3
81143070:	dfc01215 	stw	ra,72(sp)
81143074:	df001115 	stw	fp,68(sp)
81143078:	df001104 	addi	fp,sp,68
8114307c:	e13ffc15 	stw	r4,-16(fp)
81143080:	e17ffd15 	stw	r5,-12(fp)
81143084:	e1bffe15 	stw	r6,-8(fp)
81143088:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
8114308c:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
81143090:	e0bffd17 	ldw	r2,-12(fp)
81143094:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
81143098:	e0bffc17 	ldw	r2,-16(fp)
8114309c:	10800b17 	ldw	r2,44(r2)
811430a0:	e0bff815 	stw	r2,-32(fp)
811430a4:	e03ff90d 	sth	zero,-28(fp)
811430a8:	e0bff90b 	ldhu	r2,-28(fp)
811430ac:	e0fffb44 	addi	r3,fp,-19
811430b0:	180d883a 	mov	r6,r3
811430b4:	100b883a 	mov	r5,r2
811430b8:	e13ff817 	ldw	r4,-32(fp)
811430bc:	113aaf40 	call	8113aaf4 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811430c0:	00003706 	br	811431a0 <altera_avalon_jtag_uart_write+0x13c>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
811430c4:	e0bffc17 	ldw	r2,-16(fp)
811430c8:	10800f17 	ldw	r2,60(r2)
811430cc:	e0bff415 	stw	r2,-48(fp)
      out = sp->tx_out;
811430d0:	e0bffc17 	ldw	r2,-16(fp)
811430d4:	10801017 	ldw	r2,64(r2)
811430d8:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
811430dc:	e0fff417 	ldw	r3,-48(fp)
811430e0:	e0bff017 	ldw	r2,-64(fp)
811430e4:	1880062e 	bgeu	r3,r2,81143100 <altera_avalon_jtag_uart_write+0x9c>
        n = out - 1 - in;
811430e8:	e0fff017 	ldw	r3,-64(fp)
811430ec:	e0bff417 	ldw	r2,-48(fp)
811430f0:	1885c83a 	sub	r2,r3,r2
811430f4:	10bfffc4 	addi	r2,r2,-1
811430f8:	e0bff115 	stw	r2,-60(fp)
811430fc:	00000b06 	br	8114312c <altera_avalon_jtag_uart_write+0xc8>
      else if (out > 0)
81143100:	e0bff017 	ldw	r2,-64(fp)
81143104:	10000526 	beq	r2,zero,8114311c <altera_avalon_jtag_uart_write+0xb8>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
81143108:	00c20004 	movi	r3,2048
8114310c:	e0bff417 	ldw	r2,-48(fp)
81143110:	1885c83a 	sub	r2,r3,r2
81143114:	e0bff115 	stw	r2,-60(fp)
81143118:	00000406 	br	8114312c <altera_avalon_jtag_uart_write+0xc8>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
8114311c:	00c1ffc4 	movi	r3,2047
81143120:	e0bff417 	ldw	r2,-48(fp)
81143124:	1885c83a 	sub	r2,r3,r2
81143128:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
8114312c:	e0bff117 	ldw	r2,-60(fp)
81143130:	10001e26 	beq	r2,zero,811431ac <altera_avalon_jtag_uart_write+0x148>
        break;

      if (n > count)
81143134:	e0fffe17 	ldw	r3,-8(fp)
81143138:	e0bff117 	ldw	r2,-60(fp)
8114313c:	1880022e 	bgeu	r3,r2,81143148 <altera_avalon_jtag_uart_write+0xe4>
        n = count;
81143140:	e0bffe17 	ldw	r2,-8(fp)
81143144:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
81143148:	e0bffc17 	ldw	r2,-16(fp)
8114314c:	10c21104 	addi	r3,r2,2116
81143150:	e0bff417 	ldw	r2,-48(fp)
81143154:	1885883a 	add	r2,r3,r2
81143158:	e1bff117 	ldw	r6,-60(fp)
8114315c:	e17ffd17 	ldw	r5,-12(fp)
81143160:	1009883a 	mov	r4,r2
81143164:	111dac80 	call	8111dac8 <memcpy>
      ptr   += n;
81143168:	e0fffd17 	ldw	r3,-12(fp)
8114316c:	e0bff117 	ldw	r2,-60(fp)
81143170:	1885883a 	add	r2,r3,r2
81143174:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
81143178:	e0fffe17 	ldw	r3,-8(fp)
8114317c:	e0bff117 	ldw	r2,-60(fp)
81143180:	1885c83a 	sub	r2,r3,r2
81143184:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
81143188:	e0fff417 	ldw	r3,-48(fp)
8114318c:	e0bff117 	ldw	r2,-60(fp)
81143190:	1885883a 	add	r2,r3,r2
81143194:	10c1ffcc 	andi	r3,r2,2047
81143198:	e0bffc17 	ldw	r2,-16(fp)
8114319c:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
811431a0:	e0bffe17 	ldw	r2,-8(fp)
811431a4:	00bfc716 	blt	zero,r2,811430c4 <__reset+0xfb1230c4>
811431a8:	00000106 	br	811431b0 <altera_avalon_jtag_uart_write+0x14c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
811431ac:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811431b0:	0005303a 	rdctl	r2,status
811431b4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811431b8:	e0fff717 	ldw	r3,-36(fp)
811431bc:	00bfff84 	movi	r2,-2
811431c0:	1884703a 	and	r2,r3,r2
811431c4:	1001703a 	wrctl	status,r2
  
  return context;
811431c8:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
811431cc:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
811431d0:	e0bffc17 	ldw	r2,-16(fp)
811431d4:	10800817 	ldw	r2,32(r2)
811431d8:	10c00094 	ori	r3,r2,2
811431dc:	e0bffc17 	ldw	r2,-16(fp)
811431e0:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
811431e4:	e0bffc17 	ldw	r2,-16(fp)
811431e8:	10800017 	ldw	r2,0(r2)
811431ec:	10800104 	addi	r2,r2,4
811431f0:	1007883a 	mov	r3,r2
811431f4:	e0bffc17 	ldw	r2,-16(fp)
811431f8:	10800817 	ldw	r2,32(r2)
811431fc:	18800035 	stwio	r2,0(r3)
81143200:	e0bff617 	ldw	r2,-40(fp)
81143204:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143208:	e0bff317 	ldw	r2,-52(fp)
8114320c:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
81143210:	e0bffe17 	ldw	r2,-8(fp)
81143214:	00802a0e 	bge	zero,r2,811432c0 <altera_avalon_jtag_uart_write+0x25c>
    {
      if (flags & O_NONBLOCK)
81143218:	e0bfff17 	ldw	r2,-4(fp)
8114321c:	1090000c 	andi	r2,r2,16384
81143220:	10002a1e 	bne	r2,zero,811432cc <altera_avalon_jtag_uart_write+0x268>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
81143224:	d0a08d03 	ldbu	r2,-32204(gp)
81143228:	10803fcc 	andi	r2,r2,255
8114322c:	10800058 	cmpnei	r2,r2,1
81143230:	1000161e 	bne	r2,zero,8114328c <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
81143234:	e0bffc17 	ldw	r2,-16(fp)
81143238:	10800c17 	ldw	r2,48(r2)
8114323c:	e0bff515 	stw	r2,-44(fp)
81143240:	00800184 	movi	r2,6
81143244:	e0bff98d 	sth	r2,-26(fp)
81143248:	00bfe0c4 	movi	r2,-125
8114324c:	e0bffa05 	stb	r2,-24(fp)
81143250:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81143254:	d0a08d03 	ldbu	r2,-32204(gp)
81143258:	10803fcc 	andi	r2,r2,255
8114325c:	10001526 	beq	r2,zero,811432b4 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81143260:	e0fff98b 	ldhu	r3,-26(fp)
81143264:	e13ffa03 	ldbu	r4,-24(fp)
81143268:	e17ffa8b 	ldhu	r5,-22(fp)
8114326c:	e0bffb04 	addi	r2,fp,-20
81143270:	d8800015 	stw	r2,0(sp)
81143274:	280f883a 	mov	r7,r5
81143278:	200d883a 	mov	r6,r4
8114327c:	180b883a 	mov	r5,r3
81143280:	e13ff517 	ldw	r4,-44(fp)
81143284:	1136e540 	call	81136e54 <OSFlagPend>
81143288:	00000a06 	br	811432b4 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
8114328c:	0001883a 	nop
81143290:	e0bffc17 	ldw	r2,-16(fp)
81143294:	10c01017 	ldw	r3,64(r2)
81143298:	e0bff017 	ldw	r2,-64(fp)
8114329c:	1880051e 	bne	r3,r2,811432b4 <altera_avalon_jtag_uart_write+0x250>
811432a0:	e0bffc17 	ldw	r2,-16(fp)
811432a4:	10c00917 	ldw	r3,36(r2)
811432a8:	e0bffc17 	ldw	r2,-16(fp)
811432ac:	10800117 	ldw	r2,4(r2)
811432b0:	18bff736 	bltu	r3,r2,81143290 <__reset+0xfb123290>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
811432b4:	e0bffc17 	ldw	r2,-16(fp)
811432b8:	10800917 	ldw	r2,36(r2)
811432bc:	1000051e 	bne	r2,zero,811432d4 <altera_avalon_jtag_uart_write+0x270>
         break;
    }
  }
  while (count > 0);
811432c0:	e0bffe17 	ldw	r2,-8(fp)
811432c4:	00bfb616 	blt	zero,r2,811431a0 <__reset+0xfb1231a0>
811432c8:	00000306 	br	811432d8 <altera_avalon_jtag_uart_write+0x274>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
811432cc:	0001883a 	nop
811432d0:	00000106 	br	811432d8 <altera_avalon_jtag_uart_write+0x274>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if  (sp->host_inactive)
         break;
811432d4:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
811432d8:	e0bffc17 	ldw	r2,-16(fp)
811432dc:	10800b17 	ldw	r2,44(r2)
811432e0:	1009883a 	mov	r4,r2
811432e4:	113ae7c0 	call	8113ae7c <OSSemPost>

  if (ptr != start)
811432e8:	e0fffd17 	ldw	r3,-12(fp)
811432ec:	e0bff217 	ldw	r2,-56(fp)
811432f0:	18800426 	beq	r3,r2,81143304 <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
811432f4:	e0fffd17 	ldw	r3,-12(fp)
811432f8:	e0bff217 	ldw	r2,-56(fp)
811432fc:	1885c83a 	sub	r2,r3,r2
81143300:	00000606 	br	8114331c <altera_avalon_jtag_uart_write+0x2b8>
  else if (flags & O_NONBLOCK)
81143304:	e0bfff17 	ldw	r2,-4(fp)
81143308:	1090000c 	andi	r2,r2,16384
8114330c:	10000226 	beq	r2,zero,81143318 <altera_avalon_jtag_uart_write+0x2b4>
    return -EWOULDBLOCK;
81143310:	00bffd44 	movi	r2,-11
81143314:	00000106 	br	8114331c <altera_avalon_jtag_uart_write+0x2b8>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
81143318:	00bffec4 	movi	r2,-5
}
8114331c:	e037883a 	mov	sp,fp
81143320:	dfc00117 	ldw	ra,4(sp)
81143324:	df000017 	ldw	fp,0(sp)
81143328:	dec00204 	addi	sp,sp,8
8114332c:	f800283a 	ret

81143330 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
81143330:	defffa04 	addi	sp,sp,-24
81143334:	de00012e 	bgeu	sp,et,8114333c <alt_avalon_timer_sc_irq+0xc>
81143338:	003b68fa 	trap	3
8114333c:	dfc00515 	stw	ra,20(sp)
81143340:	df000415 	stw	fp,16(sp)
81143344:	df000404 	addi	fp,sp,16
81143348:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
8114334c:	0007883a 	mov	r3,zero
81143350:	e0bfff17 	ldw	r2,-4(fp)
81143354:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
81143358:	e0bfff17 	ldw	r2,-4(fp)
8114335c:	10800104 	addi	r2,r2,4
81143360:	10800037 	ldwio	r2,0(r2)

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
  ALT_LOG_SYS_CLK_HEARTBEAT();
81143364:	11333300 	call	81133330 <alt_log_system_clock>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143368:	0005303a 	rdctl	r2,status
8114336c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143370:	e0fffd17 	ldw	r3,-12(fp)
81143374:	00bfff84 	movi	r2,-2
81143378:	1884703a 	and	r2,r3,r2
8114337c:	1001703a 	wrctl	status,r2
  
  return context;
81143380:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
81143384:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
81143388:	1133be00 	call	81133be0 <alt_tick>
8114338c:	e0bffc17 	ldw	r2,-16(fp)
81143390:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143394:	e0bffe17 	ldw	r2,-8(fp)
81143398:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
8114339c:	0001883a 	nop
811433a0:	e037883a 	mov	sp,fp
811433a4:	dfc00117 	ldw	ra,4(sp)
811433a8:	df000017 	ldw	fp,0(sp)
811433ac:	dec00204 	addi	sp,sp,8
811433b0:	f800283a 	ret

811433b4 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
811433b4:	defff804 	addi	sp,sp,-32
811433b8:	de00012e 	bgeu	sp,et,811433c0 <alt_avalon_timer_sc_init+0xc>
811433bc:	003b68fa 	trap	3
811433c0:	dfc00715 	stw	ra,28(sp)
811433c4:	df000615 	stw	fp,24(sp)
811433c8:	df000604 	addi	fp,sp,24
811433cc:	e13ffc15 	stw	r4,-16(fp)
811433d0:	e17ffd15 	stw	r5,-12(fp)
811433d4:	e1bffe15 	stw	r6,-8(fp)
811433d8:	e1ffff15 	stw	r7,-4(fp)
811433dc:	e0bfff17 	ldw	r2,-4(fp)
811433e0:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
811433e4:	d0a08417 	ldw	r2,-32240(gp)
811433e8:	1000021e 	bne	r2,zero,811433f4 <alt_avalon_timer_sc_init+0x40>
  {
    _alt_tick_rate = nticks;
811433ec:	e0bffb17 	ldw	r2,-20(fp)
811433f0:	d0a08415 	stw	r2,-32240(gp)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
811433f4:	e0bffc17 	ldw	r2,-16(fp)
811433f8:	10800104 	addi	r2,r2,4
811433fc:	00c001c4 	movi	r3,7
81143400:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
81143404:	d8000015 	stw	zero,0(sp)
81143408:	e1fffc17 	ldw	r7,-16(fp)
8114340c:	01a04534 	movhi	r6,33044
81143410:	318ccc04 	addi	r6,r6,13104
81143414:	e17ffe17 	ldw	r5,-8(fp)
81143418:	e13ffd17 	ldw	r4,-12(fp)
8114341c:	11465b80 	call	811465b8 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
81143420:	0001883a 	nop
81143424:	e037883a 	mov	sp,fp
81143428:	dfc00117 	ldw	ra,4(sp)
8114342c:	df000017 	ldw	fp,0(sp)
81143430:	dec00204 	addi	sp,sp,8
81143434:	f800283a 	ret

81143438 <altera_avalon_uart_read_fd>:
 *
 */

int 
altera_avalon_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
81143438:	defffa04 	addi	sp,sp,-24
8114343c:	de00012e 	bgeu	sp,et,81143444 <altera_avalon_uart_read_fd+0xc>
81143440:	003b68fa 	trap	3
81143444:	dfc00515 	stw	ra,20(sp)
81143448:	df000415 	stw	fp,16(sp)
8114344c:	df000404 	addi	fp,sp,16
81143450:	e13ffd15 	stw	r4,-12(fp)
81143454:	e17ffe15 	stw	r5,-8(fp)
81143458:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
8114345c:	e0bffd17 	ldw	r2,-12(fp)
81143460:	10800017 	ldw	r2,0(r2)
81143464:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_read(&dev->state, buffer, space,
81143468:	e0bffc17 	ldw	r2,-16(fp)
8114346c:	10c00a04 	addi	r3,r2,40
81143470:	e0bffd17 	ldw	r2,-12(fp)
81143474:	10800217 	ldw	r2,8(r2)
81143478:	100f883a 	mov	r7,r2
8114347c:	e1bfff17 	ldw	r6,-4(fp)
81143480:	e17ffe17 	ldw	r5,-8(fp)
81143484:	1809883a 	mov	r4,r3
81143488:	1143af80 	call	81143af8 <altera_avalon_uart_read>
      fd->fd_flags);
}
8114348c:	e037883a 	mov	sp,fp
81143490:	dfc00117 	ldw	ra,4(sp)
81143494:	df000017 	ldw	fp,0(sp)
81143498:	dec00204 	addi	sp,sp,8
8114349c:	f800283a 	ret

811434a0 <altera_avalon_uart_write_fd>:

int 
altera_avalon_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
811434a0:	defffa04 	addi	sp,sp,-24
811434a4:	de00012e 	bgeu	sp,et,811434ac <altera_avalon_uart_write_fd+0xc>
811434a8:	003b68fa 	trap	3
811434ac:	dfc00515 	stw	ra,20(sp)
811434b0:	df000415 	stw	fp,16(sp)
811434b4:	df000404 	addi	fp,sp,16
811434b8:	e13ffd15 	stw	r4,-12(fp)
811434bc:	e17ffe15 	stw	r5,-8(fp)
811434c0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
811434c4:	e0bffd17 	ldw	r2,-12(fp)
811434c8:	10800017 	ldw	r2,0(r2)
811434cc:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_uart_write(&dev->state, buffer, space,
811434d0:	e0bffc17 	ldw	r2,-16(fp)
811434d4:	10c00a04 	addi	r3,r2,40
811434d8:	e0bffd17 	ldw	r2,-12(fp)
811434dc:	10800217 	ldw	r2,8(r2)
811434e0:	100f883a 	mov	r7,r2
811434e4:	e1bfff17 	ldw	r6,-4(fp)
811434e8:	e17ffe17 	ldw	r5,-8(fp)
811434ec:	1809883a 	mov	r4,r3
811434f0:	1143dac0 	call	81143dac <altera_avalon_uart_write>
      fd->fd_flags);
}
811434f4:	e037883a 	mov	sp,fp
811434f8:	dfc00117 	ldw	ra,4(sp)
811434fc:	df000017 	ldw	fp,0(sp)
81143500:	dec00204 	addi	sp,sp,8
81143504:	f800283a 	ret

81143508 <altera_avalon_uart_close_fd>:

#endif /* ALTERA_AVALON_UART_USE_IOCTL */

int 
altera_avalon_uart_close_fd(alt_fd* fd)
{
81143508:	defffc04 	addi	sp,sp,-16
8114350c:	de00012e 	bgeu	sp,et,81143514 <altera_avalon_uart_close_fd+0xc>
81143510:	003b68fa 	trap	3
81143514:	dfc00315 	stw	ra,12(sp)
81143518:	df000215 	stw	fp,8(sp)
8114351c:	df000204 	addi	fp,sp,8
81143520:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_uart_dev* dev = (altera_avalon_uart_dev*) fd->dev; 
81143524:	e0bfff17 	ldw	r2,-4(fp)
81143528:	10800017 	ldw	r2,0(r2)
8114352c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_uart_close(&dev->state, fd->fd_flags);
81143530:	e0bffe17 	ldw	r2,-8(fp)
81143534:	10c00a04 	addi	r3,r2,40
81143538:	e0bfff17 	ldw	r2,-4(fp)
8114353c:	10800217 	ldw	r2,8(r2)
81143540:	100b883a 	mov	r5,r2
81143544:	1809883a 	mov	r4,r3
81143548:	1143a580 	call	81143a58 <altera_avalon_uart_close>
}
8114354c:	e037883a 	mov	sp,fp
81143550:	dfc00117 	ldw	ra,4(sp)
81143554:	df000017 	ldw	fp,0(sp)
81143558:	dec00204 	addi	sp,sp,8
8114355c:	f800283a 	ret

81143560 <altera_avalon_uart_init>:
  alt_u32 status);

void 
altera_avalon_uart_init(altera_avalon_uart_state* sp, 
  alt_u32 irq_controller_id,  alt_u32 irq)
{
81143560:	defff304 	addi	sp,sp,-52
81143564:	de00012e 	bgeu	sp,et,8114356c <altera_avalon_uart_init+0xc>
81143568:	003b68fa 	trap	3
8114356c:	dfc00c15 	stw	ra,48(sp)
81143570:	df000b15 	stw	fp,44(sp)
81143574:	df000b04 	addi	fp,sp,44
81143578:	e13ffd15 	stw	r4,-12(fp)
8114357c:	e17ffe15 	stw	r5,-8(fp)
81143580:	e1bfff15 	stw	r6,-4(fp)
  void* base = sp->base;
81143584:	e0bffd17 	ldw	r2,-12(fp)
81143588:	10800017 	ldw	r2,0(r2)
8114358c:	e0bff615 	stw	r2,-40(fp)
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81143590:	e0bffd17 	ldw	r2,-12(fp)
81143594:	10800704 	addi	r2,r2,28
81143598:	e0bffa15 	stw	r2,-24(fp)
8114359c:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
811435a0:	e0bffb0b 	ldhu	r2,-20(fp)
811435a4:	e0fffc84 	addi	r3,fp,-14
811435a8:	180b883a 	mov	r5,r3
811435ac:	1009883a 	mov	r4,r2
811435b0:	11368700 	call	81136870 <OSFlagCreate>
811435b4:	1007883a 	mov	r3,r2
811435b8:	e0bffa17 	ldw	r2,-24(fp)
811435bc:	10c00015 	stw	r3,0(r2)
  return err;
811435c0:	e0bffc83 	ldbu	r2,-14(fp)
811435c4:	10803fcc 	andi	r2,r2,255
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
811435c8:	1000241e 	bne	r2,zero,8114365c <altera_avalon_uart_init+0xfc>
811435cc:	e0bffd17 	ldw	r2,-12(fp)
811435d0:	10800804 	addi	r2,r2,32
811435d4:	e0bff715 	stw	r2,-36(fp)
811435d8:	00800044 	movi	r2,1
811435dc:	e0bffb8d 	sth	r2,-18(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
811435e0:	e0bffb8b 	ldhu	r2,-18(fp)
811435e4:	1009883a 	mov	r4,r2
811435e8:	113a7cc0 	call	8113a7cc <OSSemCreate>
811435ec:	1007883a 	mov	r3,r2
811435f0:	e0bff717 	ldw	r2,-36(fp)
811435f4:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
811435f8:	e0bff717 	ldw	r2,-36(fp)
811435fc:	10800017 	ldw	r2,0(r2)
81143600:	10000226 	beq	r2,zero,8114360c <altera_avalon_uart_init+0xac>
81143604:	0005883a 	mov	r2,zero
81143608:	00000106 	br	81143610 <altera_avalon_uart_init+0xb0>
8114360c:	00bfffc4 	movi	r2,-1
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81143610:	1000121e 	bne	r2,zero,8114365c <altera_avalon_uart_init+0xfc>
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);
81143614:	e0bffd17 	ldw	r2,-12(fp)
81143618:	10800904 	addi	r2,r2,36
8114361c:	e0bff815 	stw	r2,-32(fp)
81143620:	00800044 	movi	r2,1
81143624:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81143628:	e0bffc0b 	ldhu	r2,-16(fp)
8114362c:	1009883a 	mov	r4,r2
81143630:	113a7cc0 	call	8113a7cc <OSSemCreate>
81143634:	1007883a 	mov	r3,r2
81143638:	e0bff817 	ldw	r2,-32(fp)
8114363c:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81143640:	e0bff817 	ldw	r2,-32(fp)
81143644:	10800017 	ldw	r2,0(r2)
81143648:	10000226 	beq	r2,zero,81143654 <altera_avalon_uart_init+0xf4>
8114364c:	0005883a 	mov	r2,zero
81143650:	00000106 	br	81143658 <altera_avalon_uart_init+0xf8>
81143654:	00bfffc4 	movi	r2,-1
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
81143658:	10000226 	beq	r2,zero,81143664 <altera_avalon_uart_init+0x104>
8114365c:	00800044 	movi	r2,1
81143660:	00000106 	br	81143668 <altera_avalon_uart_init+0x108>
81143664:	0005883a 	mov	r2,zero
  /* 
   * Initialise the read and write flags and the semaphores used to 
   * protect access to the circular buffers when running in a multi-threaded
   * environment.
   */
  error = ALT_FLAG_CREATE (&sp->events, 0)    || 
81143668:	e0bff915 	stw	r2,-28(fp)
          ALT_SEM_CREATE (&sp->read_lock, 1)  ||
          ALT_SEM_CREATE (&sp->write_lock, 1);

  if (!error)
8114366c:	e0bff917 	ldw	r2,-28(fp)
81143670:	10000f1e 	bne	r2,zero,811436b0 <altera_avalon_uart_init+0x150>
  {
    /* enable interrupts at the device */
    sp->ctrl = ALTERA_AVALON_UART_CONTROL_RTS_MSK  |
81143674:	e0bffd17 	ldw	r2,-12(fp)
81143678:	00c32004 	movi	r3,3200
8114367c:	10c00115 	stw	r3,4(r2)
                ALTERA_AVALON_UART_CONTROL_RRDY_MSK |
                ALTERA_AVALON_UART_CONTROL_DCTS_MSK;

    IOWR_ALTERA_AVALON_UART_CONTROL(base, sp->ctrl); 
81143680:	e0bff617 	ldw	r2,-40(fp)
81143684:	10800304 	addi	r2,r2,12
81143688:	e0fffd17 	ldw	r3,-12(fp)
8114368c:	18c00117 	ldw	r3,4(r3)
81143690:	10c00035 	stwio	r3,0(r2)
  
    /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
    alt_ic_isr_register(irq_controller_id, irq, altera_avalon_uart_irq, sp, 
81143694:	d8000015 	stw	zero,0(sp)
81143698:	e1fffd17 	ldw	r7,-12(fp)
8114369c:	01a04534 	movhi	r6,33044
811436a0:	318db204 	addi	r6,r6,14024
811436a4:	e17fff17 	ldw	r5,-4(fp)
811436a8:	e13ffe17 	ldw	r4,-8(fp)
811436ac:	11465b80 	call	811465b8 <alt_ic_isr_register>
      0x0);
#else
    alt_irq_register (irq, sp, altera_avalon_uart_irq);
#endif  
  }
}
811436b0:	0001883a 	nop
811436b4:	e037883a 	mov	sp,fp
811436b8:	dfc00117 	ldw	ra,4(sp)
811436bc:	df000017 	ldw	fp,0(sp)
811436c0:	dec00204 	addi	sp,sp,8
811436c4:	f800283a 	ret

811436c8 <altera_avalon_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_uart_irq(void* context)
#else
static void altera_avalon_uart_irq(void* context, alt_u32 id)
#endif
{
811436c8:	defffa04 	addi	sp,sp,-24
811436cc:	de00012e 	bgeu	sp,et,811436d4 <altera_avalon_uart_irq+0xc>
811436d0:	003b68fa 	trap	3
811436d4:	dfc00515 	stw	ra,20(sp)
811436d8:	df000415 	stw	fp,16(sp)
811436dc:	df000404 	addi	fp,sp,16
811436e0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 status;

  altera_avalon_uart_state* sp = (altera_avalon_uart_state*) context;
811436e4:	e0bfff17 	ldw	r2,-4(fp)
811436e8:	e0bffc15 	stw	r2,-16(fp)
  void* base               = sp->base;
811436ec:	e0bffc17 	ldw	r2,-16(fp)
811436f0:	10800017 	ldw	r2,0(r2)
811436f4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Read the status register in order to determine the cause of the
   * interrupt.
   */

  status = IORD_ALTERA_AVALON_UART_STATUS(base);
811436f8:	e0bffd17 	ldw	r2,-12(fp)
811436fc:	10800204 	addi	r2,r2,8
81143700:	10800037 	ldwio	r2,0(r2)
81143704:	e0bffe15 	stw	r2,-8(fp)

  /* Clear any error flags set at the device */
  IOWR_ALTERA_AVALON_UART_STATUS(base, 0);
81143708:	e0bffd17 	ldw	r2,-12(fp)
8114370c:	10800204 	addi	r2,r2,8
81143710:	0007883a 	mov	r3,zero
81143714:	10c00035 	stwio	r3,0(r2)

  /* Dummy read to ensure IRQ is negated before ISR returns */
  IORD_ALTERA_AVALON_UART_STATUS(base);
81143718:	e0bffd17 	ldw	r2,-12(fp)
8114371c:	10800204 	addi	r2,r2,8
81143720:	10800037 	ldwio	r2,0(r2)
  
  /* process a read irq */
  if (status & ALTERA_AVALON_UART_STATUS_RRDY_MSK)
81143724:	e0bffe17 	ldw	r2,-8(fp)
81143728:	1080200c 	andi	r2,r2,128
8114372c:	10000326 	beq	r2,zero,8114373c <altera_avalon_uart_irq+0x74>
  {
    altera_avalon_uart_rxirq(sp, status);
81143730:	e17ffe17 	ldw	r5,-8(fp)
81143734:	e13ffc17 	ldw	r4,-16(fp)
81143738:	114376c0 	call	8114376c <altera_avalon_uart_rxirq>
  }

  /* process a write irq */
  if (status & (ALTERA_AVALON_UART_STATUS_TRDY_MSK | 
8114373c:	e0bffe17 	ldw	r2,-8(fp)
81143740:	1081100c 	andi	r2,r2,1088
81143744:	10000326 	beq	r2,zero,81143754 <altera_avalon_uart_irq+0x8c>
                  ALTERA_AVALON_UART_STATUS_DCTS_MSK))
  {
    altera_avalon_uart_txirq(sp, status);
81143748:	e17ffe17 	ldw	r5,-8(fp)
8114374c:	e13ffc17 	ldw	r4,-16(fp)
81143750:	11438ac0 	call	811438ac <altera_avalon_uart_txirq>
  }
  

}
81143754:	0001883a 	nop
81143758:	e037883a 	mov	sp,fp
8114375c:	dfc00117 	ldw	ra,4(sp)
81143760:	df000017 	ldw	fp,0(sp)
81143764:	dec00204 	addi	sp,sp,8
81143768:	f800283a 	ret

8114376c <altera_avalon_uart_rxirq>:
 * the receive circular buffer, and sets the apropriate flags to indicate 
 * that there is data ready to be processed.
 */
static void 
altera_avalon_uart_rxirq(altera_avalon_uart_state* sp, alt_u32 status)
{
8114376c:	defff904 	addi	sp,sp,-28
81143770:	de00012e 	bgeu	sp,et,81143778 <altera_avalon_uart_rxirq+0xc>
81143774:	003b68fa 	trap	3
81143778:	dfc00615 	stw	ra,24(sp)
8114377c:	df000515 	stw	fp,20(sp)
81143780:	df000504 	addi	fp,sp,20
81143784:	e13ffe15 	stw	r4,-8(fp)
81143788:	e17fff15 	stw	r5,-4(fp)
  alt_u32 next;
  
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
8114378c:	e0bfff17 	ldw	r2,-4(fp)
81143790:	108000cc 	andi	r2,r2,3
81143794:	10003f1e 	bne	r2,zero,81143894 <altera_avalon_uart_rxirq+0x128>
   * In a multi-threaded environment, set the read event flag to indicate
   * that there is data ready. This is only done if the circular buffer was
   * previously empty.
   */

  if (sp->rx_end == sp->rx_start)
81143798:	e0bffe17 	ldw	r2,-8(fp)
8114379c:	10c00317 	ldw	r3,12(r2)
811437a0:	e0bffe17 	ldw	r2,-8(fp)
811437a4:	10800217 	ldw	r2,8(r2)
811437a8:	1880121e 	bne	r3,r2,811437f4 <altera_avalon_uart_rxirq+0x88>
  {
    ALT_FLAG_POST (sp->events, ALT_UART_READ_RDY, OS_FLAG_SET);
811437ac:	e0bffe17 	ldw	r2,-8(fp)
811437b0:	10800717 	ldw	r2,28(r2)
811437b4:	e0bffc15 	stw	r2,-16(fp)
811437b8:	00800044 	movi	r2,1
811437bc:	e0bffd0d 	sth	r2,-12(fp)
811437c0:	00800044 	movi	r2,1
811437c4:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
811437c8:	d0a08d03 	ldbu	r2,-32204(gp)
811437cc:	10803fcc 	andi	r2,r2,255
811437d0:	10000826 	beq	r2,zero,811437f4 <altera_avalon_uart_rxirq+0x88>
  {
    OSFlagPost (group, flags, opt, &err);
811437d4:	e0bffd0b 	ldhu	r2,-12(fp)
811437d8:	e0fffd83 	ldbu	r3,-10(fp)
811437dc:	e13ffdc4 	addi	r4,fp,-9
811437e0:	200f883a 	mov	r7,r4
811437e4:	180d883a 	mov	r6,r3
811437e8:	100b883a 	mov	r5,r2
811437ec:	e13ffc17 	ldw	r4,-16(fp)
811437f0:	113747c0 	call	8113747c <OSFlagPost>
  }

  /* Determine which slot to use next in the circular buffer */

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
811437f4:	e0bffe17 	ldw	r2,-8(fp)
811437f8:	10800317 	ldw	r2,12(r2)
811437fc:	10800044 	addi	r2,r2,1
81143800:	10800fcc 	andi	r2,r2,63
81143804:	e0bffb15 	stw	r2,-20(fp)

  /* Transfer data from the device to the circular buffer */

  sp->rx_buf[sp->rx_end] = IORD_ALTERA_AVALON_UART_RXDATA(sp->base);
81143808:	e0bffe17 	ldw	r2,-8(fp)
8114380c:	10800317 	ldw	r2,12(r2)
81143810:	e0fffe17 	ldw	r3,-8(fp)
81143814:	18c00017 	ldw	r3,0(r3)
81143818:	18c00037 	ldwio	r3,0(r3)
8114381c:	1809883a 	mov	r4,r3
81143820:	e0fffe17 	ldw	r3,-8(fp)
81143824:	1885883a 	add	r2,r3,r2
81143828:	10800a04 	addi	r2,r2,40
8114382c:	11000005 	stb	r4,0(r2)

  sp->rx_end = next;
81143830:	e0bffe17 	ldw	r2,-8(fp)
81143834:	e0fffb17 	ldw	r3,-20(fp)
81143838:	10c00315 	stw	r3,12(r2)

  next = (sp->rx_end + 1) & ALT_AVALON_UART_BUF_MSK;
8114383c:	e0bffe17 	ldw	r2,-8(fp)
81143840:	10800317 	ldw	r2,12(r2)
81143844:	10800044 	addi	r2,r2,1
81143848:	10800fcc 	andi	r2,r2,63
8114384c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * If the cicular buffer was full, disable interrupts. Interrupts will be
   * re-enabled when data is removed from the buffer.
   */

  if (next == sp->rx_start)
81143850:	e0bffe17 	ldw	r2,-8(fp)
81143854:	10c00217 	ldw	r3,8(r2)
81143858:	e0bffb17 	ldw	r2,-20(fp)
8114385c:	18800e1e 	bne	r3,r2,81143898 <altera_avalon_uart_rxirq+0x12c>
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81143860:	e0bffe17 	ldw	r2,-8(fp)
81143864:	10c00117 	ldw	r3,4(r2)
81143868:	00bfdfc4 	movi	r2,-129
8114386c:	1886703a 	and	r3,r3,r2
81143870:	e0bffe17 	ldw	r2,-8(fp)
81143874:	10c00115 	stw	r3,4(r2)
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
81143878:	e0bffe17 	ldw	r2,-8(fp)
8114387c:	10800017 	ldw	r2,0(r2)
81143880:	10800304 	addi	r2,r2,12
81143884:	e0fffe17 	ldw	r3,-8(fp)
81143888:	18c00117 	ldw	r3,4(r3)
8114388c:	10c00035 	stwio	r3,0(r2)
81143890:	00000106 	br	81143898 <altera_avalon_uart_rxirq+0x12c>
  /* If there was an error, discard the data */

  if (status & (ALTERA_AVALON_UART_STATUS_PE_MSK | 
                  ALTERA_AVALON_UART_STATUS_FE_MSK))
  {
    return;
81143894:	0001883a 	nop
  if (next == sp->rx_start)
  {
    sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
    IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl); 
  }   
}
81143898:	e037883a 	mov	sp,fp
8114389c:	dfc00117 	ldw	ra,4(sp)
811438a0:	df000017 	ldw	fp,0(sp)
811438a4:	dec00204 	addi	sp,sp,8
811438a8:	f800283a 	ret

811438ac <altera_avalon_uart_txirq>:
 * buffer to the device, and sets the apropriate flags to indicate that 
 * there is data ready to be processed.
 */
static void 
altera_avalon_uart_txirq(altera_avalon_uart_state* sp, alt_u32 status)
{
811438ac:	defffa04 	addi	sp,sp,-24
811438b0:	de00012e 	bgeu	sp,et,811438b8 <altera_avalon_uart_txirq+0xc>
811438b4:	003b68fa 	trap	3
811438b8:	dfc00515 	stw	ra,20(sp)
811438bc:	df000415 	stw	fp,16(sp)
811438c0:	df000404 	addi	fp,sp,16
811438c4:	e13ffe15 	stw	r4,-8(fp)
811438c8:	e17fff15 	stw	r5,-4(fp)
  /* Transfer data if there is some ready to be transfered */

  if (sp->tx_start != sp->tx_end)
811438cc:	e0bffe17 	ldw	r2,-8(fp)
811438d0:	10c00417 	ldw	r3,16(r2)
811438d4:	e0bffe17 	ldw	r2,-8(fp)
811438d8:	10800517 	ldw	r2,20(r2)
811438dc:	18804726 	beq	r3,r2,811439fc <altera_avalon_uart_txirq+0x150>
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811438e0:	e0bffe17 	ldw	r2,-8(fp)
811438e4:	10800617 	ldw	r2,24(r2)
811438e8:	1080008c 	andi	r2,r2,2
811438ec:	10000326 	beq	r2,zero,811438fc <altera_avalon_uart_txirq+0x50>
      (status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811438f0:	e0bfff17 	ldw	r2,-4(fp)
811438f4:	1082000c 	andi	r2,r2,2048
    /* 
     * If the device is using flow control (i.e. RTS/CTS), then the
     * transmitter is required to throttle if CTS is high.
     */

    if (!(sp->flags & ALT_AVALON_UART_FC) ||
811438f8:	10003226 	beq	r2,zero,811439c4 <altera_avalon_uart_txirq+0x118>
       * In a multi-threaded environment, set the write event flag to indicate
       * that there is space in the circular buffer. This is only done if the
       * buffer was previously empty.
       */

      if (sp->tx_start == ((sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK))
811438fc:	e0bffe17 	ldw	r2,-8(fp)
81143900:	10c00417 	ldw	r3,16(r2)
81143904:	e0bffe17 	ldw	r2,-8(fp)
81143908:	10800517 	ldw	r2,20(r2)
8114390c:	10800044 	addi	r2,r2,1
81143910:	10800fcc 	andi	r2,r2,63
81143914:	1880121e 	bne	r3,r2,81143960 <altera_avalon_uart_txirq+0xb4>
      { 
        ALT_FLAG_POST (sp->events, 
81143918:	e0bffe17 	ldw	r2,-8(fp)
8114391c:	10800717 	ldw	r2,28(r2)
81143920:	e0bffc15 	stw	r2,-16(fp)
81143924:	00800084 	movi	r2,2
81143928:	e0bffd0d 	sth	r2,-12(fp)
8114392c:	00800044 	movi	r2,1
81143930:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
81143934:	d0a08d03 	ldbu	r2,-32204(gp)
81143938:	10803fcc 	andi	r2,r2,255
8114393c:	10000826 	beq	r2,zero,81143960 <altera_avalon_uart_txirq+0xb4>
  {
    OSFlagPost (group, flags, opt, &err);
81143940:	e0bffd0b 	ldhu	r2,-12(fp)
81143944:	e0fffd83 	ldbu	r3,-10(fp)
81143948:	e13ffdc4 	addi	r4,fp,-9
8114394c:	200f883a 	mov	r7,r4
81143950:	180d883a 	mov	r6,r3
81143954:	100b883a 	mov	r5,r2
81143958:	e13ffc17 	ldw	r4,-16(fp)
8114395c:	113747c0 	call	8113747c <OSFlagPost>
                       OS_FLAG_SET);
      }

      /* Write the data to the device */

      IOWR_ALTERA_AVALON_UART_TXDATA(sp->base, sp->tx_buf[sp->tx_start]);
81143960:	e0bffe17 	ldw	r2,-8(fp)
81143964:	10800017 	ldw	r2,0(r2)
81143968:	10800104 	addi	r2,r2,4
8114396c:	e0fffe17 	ldw	r3,-8(fp)
81143970:	18c00417 	ldw	r3,16(r3)
81143974:	e13ffe17 	ldw	r4,-8(fp)
81143978:	20c7883a 	add	r3,r4,r3
8114397c:	18c01a04 	addi	r3,r3,104
81143980:	18c00003 	ldbu	r3,0(r3)
81143984:	18c03fcc 	andi	r3,r3,255
81143988:	10c00035 	stwio	r3,0(r2)

      sp->tx_start = (++sp->tx_start) & ALT_AVALON_UART_BUF_MSK;
8114398c:	e0bffe17 	ldw	r2,-8(fp)
81143990:	10800417 	ldw	r2,16(r2)
81143994:	10800044 	addi	r2,r2,1
81143998:	e0fffe17 	ldw	r3,-8(fp)
8114399c:	18800415 	stw	r2,16(r3)
811439a0:	10c00fcc 	andi	r3,r2,63
811439a4:	e0bffe17 	ldw	r2,-8(fp)
811439a8:	10c00415 	stw	r3,16(r2)
      /*
       * In case the tranmit interrupt had previously been disabled by 
       * detecting a low value on CTS, it is reenabled here.
       */ 

      sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811439ac:	e0bffe17 	ldw	r2,-8(fp)
811439b0:	10800117 	ldw	r2,4(r2)
811439b4:	10c01014 	ori	r3,r2,64
811439b8:	e0bffe17 	ldw	r2,-8(fp)
811439bc:	10c00115 	stw	r3,4(r2)
811439c0:	00000e06 	br	811439fc <altera_avalon_uart_txirq+0x150>
       * the last write to the status register. To avoid this resulting in
       * deadlock, it's necessary to re-check the status register here
       * before throttling.
       */
 
      status = IORD_ALTERA_AVALON_UART_STATUS(sp->base); 
811439c4:	e0bffe17 	ldw	r2,-8(fp)
811439c8:	10800017 	ldw	r2,0(r2)
811439cc:	10800204 	addi	r2,r2,8
811439d0:	10800037 	ldwio	r2,0(r2)
811439d4:	e0bfff15 	stw	r2,-4(fp)

      if (!(status & ALTERA_AVALON_UART_STATUS_CTS_MSK))
811439d8:	e0bfff17 	ldw	r2,-4(fp)
811439dc:	1082000c 	andi	r2,r2,2048
811439e0:	1000061e 	bne	r2,zero,811439fc <altera_avalon_uart_txirq+0x150>
      {
        sp->ctrl &= ~ALTERA_AVALON_UART_CONTROL_TRDY_MSK;
811439e4:	e0bffe17 	ldw	r2,-8(fp)
811439e8:	10c00117 	ldw	r3,4(r2)
811439ec:	00bfefc4 	movi	r2,-65
811439f0:	1886703a 	and	r3,r3,r2
811439f4:	e0bffe17 	ldw	r2,-8(fp)
811439f8:	10c00115 	stw	r3,4(r2)
  /*
   * If the circular buffer is empty, disable the interrupt. This will be
   * re-enabled when new data is placed in the buffer.
   */

  if (sp->tx_start == sp->tx_end)
811439fc:	e0bffe17 	ldw	r2,-8(fp)
81143a00:	10c00417 	ldw	r3,16(r2)
81143a04:	e0bffe17 	ldw	r2,-8(fp)
81143a08:	10800517 	ldw	r2,20(r2)
81143a0c:	1880061e 	bne	r3,r2,81143a28 <altera_avalon_uart_txirq+0x17c>
  {
    sp->ctrl &= ~(ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81143a10:	e0bffe17 	ldw	r2,-8(fp)
81143a14:	10c00117 	ldw	r3,4(r2)
81143a18:	00beefc4 	movi	r2,-1089
81143a1c:	1886703a 	and	r3,r3,r2
81143a20:	e0bffe17 	ldw	r2,-8(fp)
81143a24:	10c00115 	stw	r3,4(r2)
                    ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
  }

  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81143a28:	e0bffe17 	ldw	r2,-8(fp)
81143a2c:	10800017 	ldw	r2,0(r2)
81143a30:	10800304 	addi	r2,r2,12
81143a34:	e0fffe17 	ldw	r3,-8(fp)
81143a38:	18c00117 	ldw	r3,4(r3)
81143a3c:	10c00035 	stwio	r3,0(r2)
}
81143a40:	0001883a 	nop
81143a44:	e037883a 	mov	sp,fp
81143a48:	dfc00117 	ldw	ra,4(sp)
81143a4c:	df000017 	ldw	fp,0(sp)
81143a50:	dec00204 	addi	sp,sp,8
81143a54:	f800283a 	ret

81143a58 <altera_avalon_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
81143a58:	defffd04 	addi	sp,sp,-12
81143a5c:	de00012e 	bgeu	sp,et,81143a64 <altera_avalon_uart_close+0xc>
81143a60:	003b68fa 	trap	3
81143a64:	df000215 	stw	fp,8(sp)
81143a68:	df000204 	addi	fp,sp,8
81143a6c:	e13ffe15 	stw	r4,-8(fp)
81143a70:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81143a74:	00000506 	br	81143a8c <altera_avalon_uart_close+0x34>
    if (flags & O_NONBLOCK) {
81143a78:	e0bfff17 	ldw	r2,-4(fp)
81143a7c:	1090000c 	andi	r2,r2,16384
81143a80:	10000226 	beq	r2,zero,81143a8c <altera_avalon_uart_close+0x34>
      return -EWOULDBLOCK; 
81143a84:	00bffd44 	movi	r2,-11
81143a88:	00000606 	br	81143aa4 <altera_avalon_uart_close+0x4c>
int altera_avalon_uart_close(altera_avalon_uart_state* sp, int flags)
{
  /* 
   * Wait for all transmit data to be emptied by the UART ISR.
   */
  while (sp->tx_start != sp->tx_end) {
81143a8c:	e0bffe17 	ldw	r2,-8(fp)
81143a90:	10c00417 	ldw	r3,16(r2)
81143a94:	e0bffe17 	ldw	r2,-8(fp)
81143a98:	10800517 	ldw	r2,20(r2)
81143a9c:	18bff61e 	bne	r3,r2,81143a78 <__reset+0xfb123a78>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
81143aa0:	0005883a 	mov	r2,zero
}
81143aa4:	e037883a 	mov	sp,fp
81143aa8:	df000017 	ldw	fp,0(sp)
81143aac:	dec00104 	addi	sp,sp,4
81143ab0:	f800283a 	ret

81143ab4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81143ab4:	defffe04 	addi	sp,sp,-8
81143ab8:	de00012e 	bgeu	sp,et,81143ac0 <alt_get_errno+0xc>
81143abc:	003b68fa 	trap	3
81143ac0:	dfc00115 	stw	ra,4(sp)
81143ac4:	df000015 	stw	fp,0(sp)
81143ac8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81143acc:	d0a01017 	ldw	r2,-32704(gp)
81143ad0:	10000326 	beq	r2,zero,81143ae0 <alt_get_errno+0x2c>
81143ad4:	d0a01017 	ldw	r2,-32704(gp)
81143ad8:	103ee83a 	callr	r2
81143adc:	00000106 	br	81143ae4 <alt_get_errno+0x30>
81143ae0:	d0a07404 	addi	r2,gp,-32304
}
81143ae4:	e037883a 	mov	sp,fp
81143ae8:	dfc00117 	ldw	ra,4(sp)
81143aec:	df000017 	ldw	fp,0(sp)
81143af0:	dec00204 	addi	sp,sp,8
81143af4:	f800283a 	ret

81143af8 <altera_avalon_uart_read>:
 */

int 
altera_avalon_uart_read(altera_avalon_uart_state* sp, char* ptr, int len,
  int flags)
{
81143af8:	deffec04 	addi	sp,sp,-80
81143afc:	de00012e 	bgeu	sp,et,81143b04 <altera_avalon_uart_read+0xc>
81143b00:	003b68fa 	trap	3
81143b04:	dfc01315 	stw	ra,76(sp)
81143b08:	df001215 	stw	fp,72(sp)
81143b0c:	df001204 	addi	fp,sp,72
81143b10:	e13ffc15 	stw	r4,-16(fp)
81143b14:	e17ffd15 	stw	r5,-12(fp)
81143b18:	e1bffe15 	stw	r6,-8(fp)
81143b1c:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             block;
  alt_u8          read_would_block = 0;
81143b20:	e03fef05 	stb	zero,-68(fp)
  int             count = 0;
81143b24:	e03ff015 	stw	zero,-64(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  block = !(flags & O_NONBLOCK);
81143b28:	e0bfff17 	ldw	r2,-4(fp)
81143b2c:	1090000c 	andi	r2,r2,16384
81143b30:	1005003a 	cmpeq	r2,r2,zero
81143b34:	10803fcc 	andi	r2,r2,255
81143b38:	e0bff115 	stw	r2,-60(fp)
  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */

  ALT_SEM_PEND (sp->read_lock, 0);
81143b3c:	e0bffc17 	ldw	r2,-16(fp)
81143b40:	10800817 	ldw	r2,32(r2)
81143b44:	e0bff815 	stw	r2,-32(fp)
81143b48:	e03ff90d 	sth	zero,-28(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81143b4c:	e0bff90b 	ldhu	r2,-28(fp)
81143b50:	e0fffb44 	addi	r3,fp,-19
81143b54:	180d883a 	mov	r6,r3
81143b58:	100b883a 	mov	r5,r2
81143b5c:	e13ff817 	ldw	r4,-32(fp)
81143b60:	113aaf40 	call	8113aaf4 <OSSemPend>
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81143b64:	00001306 	br	81143bb4 <altera_avalon_uart_read+0xbc>
    {
      count++;
81143b68:	e0bff017 	ldw	r2,-64(fp)
81143b6c:	10800044 	addi	r2,r2,1
81143b70:	e0bff015 	stw	r2,-64(fp)
      *ptr++ = sp->rx_buf[sp->rx_start];
81143b74:	e0bffd17 	ldw	r2,-12(fp)
81143b78:	10c00044 	addi	r3,r2,1
81143b7c:	e0fffd15 	stw	r3,-12(fp)
81143b80:	e0fffc17 	ldw	r3,-16(fp)
81143b84:	18c00217 	ldw	r3,8(r3)
81143b88:	e13ffc17 	ldw	r4,-16(fp)
81143b8c:	20c7883a 	add	r3,r4,r3
81143b90:	18c00a04 	addi	r3,r3,40
81143b94:	18c00003 	ldbu	r3,0(r3)
81143b98:	10c00005 	stb	r3,0(r2)
      
      sp->rx_start = (sp->rx_start+1) & ALT_AVALON_UART_BUF_MSK;
81143b9c:	e0bffc17 	ldw	r2,-16(fp)
81143ba0:	10800217 	ldw	r2,8(r2)
81143ba4:	10800044 	addi	r2,r2,1
81143ba8:	10c00fcc 	andi	r3,r2,63
81143bac:	e0bffc17 	ldw	r2,-16(fp)
81143bb0:	10c00215 	stw	r3,8(r2)
    /*
     * Read the required amount of data, until the circular buffer runs
     * empty
     */

    while ((count < len) && (sp->rx_start != sp->rx_end))
81143bb4:	e0fff017 	ldw	r3,-64(fp)
81143bb8:	e0bffe17 	ldw	r2,-8(fp)
81143bbc:	1880050e 	bge	r3,r2,81143bd4 <altera_avalon_uart_read+0xdc>
81143bc0:	e0bffc17 	ldw	r2,-16(fp)
81143bc4:	10c00217 	ldw	r3,8(r2)
81143bc8:	e0bffc17 	ldw	r2,-16(fp)
81143bcc:	10800317 	ldw	r2,12(r2)
81143bd0:	18bfe51e 	bne	r3,r2,81143b68 <__reset+0xfb123b68>
    /*
     * If no data has been transferred, the circular buffer is empty, and
     * this is not a non-blocking access, block waiting for data to arrive.
     */

    if (!count && (sp->rx_start == sp->rx_end))
81143bd4:	e0bff017 	ldw	r2,-64(fp)
81143bd8:	10003a1e 	bne	r2,zero,81143cc4 <altera_avalon_uart_read+0x1cc>
81143bdc:	e0bffc17 	ldw	r2,-16(fp)
81143be0:	10c00217 	ldw	r3,8(r2)
81143be4:	e0bffc17 	ldw	r2,-16(fp)
81143be8:	10800317 	ldw	r2,12(r2)
81143bec:	1880351e 	bne	r3,r2,81143cc4 <altera_avalon_uart_read+0x1cc>
    {
      if (!block)
81143bf0:	e0bff117 	ldw	r2,-60(fp)
81143bf4:	1000071e 	bne	r2,zero,81143c14 <altera_avalon_uart_read+0x11c>
      {
        /* Set errno to indicate the reason we're not returning any data */

        ALT_ERRNO = EWOULDBLOCK;
81143bf8:	1143ab40 	call	81143ab4 <alt_get_errno>
81143bfc:	1007883a 	mov	r3,r2
81143c00:	008002c4 	movi	r2,11
81143c04:	18800015 	stw	r2,0(r3)
        read_would_block = 1;
81143c08:	00800044 	movi	r2,1
81143c0c:	e0bfef05 	stb	r2,-68(fp)
        break;
81143c10:	00003006 	br	81143cd4 <altera_avalon_uart_read+0x1dc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143c14:	0005303a 	rdctl	r2,status
81143c18:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143c1c:	e0fff517 	ldw	r3,-44(fp)
81143c20:	00bfff84 	movi	r2,-2
81143c24:	1884703a 	and	r2,r3,r2
81143c28:	1001703a 	wrctl	status,r2
  
  return context;
81143c2c:	e0bff517 	ldw	r2,-44(fp)
      {
       /* Block waiting for some data to arrive */

       /* First, ensure read interrupts are enabled to avoid deadlock */

       context = alt_irq_disable_all ();
81143c30:	e0bff415 	stw	r2,-48(fp)
       sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81143c34:	e0bffc17 	ldw	r2,-16(fp)
81143c38:	10800117 	ldw	r2,4(r2)
81143c3c:	10c02014 	ori	r3,r2,128
81143c40:	e0bffc17 	ldw	r2,-16(fp)
81143c44:	10c00115 	stw	r3,4(r2)
       IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81143c48:	e0bffc17 	ldw	r2,-16(fp)
81143c4c:	10800017 	ldw	r2,0(r2)
81143c50:	10800304 	addi	r2,r2,12
81143c54:	e0fffc17 	ldw	r3,-16(fp)
81143c58:	18c00117 	ldw	r3,4(r3)
81143c5c:	10c00035 	stwio	r3,0(r2)
81143c60:	e0bff417 	ldw	r2,-48(fp)
81143c64:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143c68:	e0bff617 	ldw	r2,-40(fp)
81143c6c:	1001703a 	wrctl	status,r2
        * flag set in the interrupt service routine. This avoids wasting CPU
        * cycles waiting in this thread, when we could be doing something more 
        * profitable elsewhere.
        */

       ALT_FLAG_PEND (sp->events, 
81143c70:	e0bffc17 	ldw	r2,-16(fp)
81143c74:	10800717 	ldw	r2,28(r2)
81143c78:	e0bff215 	stw	r2,-56(fp)
81143c7c:	00800044 	movi	r2,1
81143c80:	e0bff98d 	sth	r2,-26(fp)
81143c84:	00bfe0c4 	movi	r2,-125
81143c88:	e0bffa05 	stb	r2,-24(fp)
81143c8c:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81143c90:	d0a08d03 	ldbu	r2,-32204(gp)
81143c94:	10803fcc 	andi	r2,r2,255
81143c98:	10000a26 	beq	r2,zero,81143cc4 <altera_avalon_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81143c9c:	e0fff98b 	ldhu	r3,-26(fp)
81143ca0:	e13ffa03 	ldbu	r4,-24(fp)
81143ca4:	e17ffa8b 	ldhu	r5,-22(fp)
81143ca8:	e0bffb04 	addi	r2,fp,-20
81143cac:	d8800015 	stw	r2,0(sp)
81143cb0:	280f883a 	mov	r7,r5
81143cb4:	200d883a 	mov	r6,r4
81143cb8:	180b883a 	mov	r5,r3
81143cbc:	e13ff217 	ldw	r4,-56(fp)
81143cc0:	1136e540 	call	81136e54 <OSFlagPend>
                      OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                      0);
      }
    }
  }
  while (!count && len);
81143cc4:	e0bff017 	ldw	r2,-64(fp)
81143cc8:	1000021e 	bne	r2,zero,81143cd4 <altera_avalon_uart_read+0x1dc>
81143ccc:	e0bffe17 	ldw	r2,-8(fp)
81143cd0:	103fb81e 	bne	r2,zero,81143bb4 <__reset+0xfb123bb4>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
81143cd4:	e0bffc17 	ldw	r2,-16(fp)
81143cd8:	10800817 	ldw	r2,32(r2)
81143cdc:	1009883a 	mov	r4,r2
81143ce0:	113ae7c0 	call	8113ae7c <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143ce4:	0005303a 	rdctl	r2,status
81143ce8:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143cec:	e0fff717 	ldw	r3,-36(fp)
81143cf0:	00bfff84 	movi	r2,-2
81143cf4:	1884703a 	and	r2,r3,r2
81143cf8:	1001703a 	wrctl	status,r2
  
  return context;
81143cfc:	e0bff717 	ldw	r2,-36(fp)
  /*
   * Ensure that interrupts are enabled, so that the circular buffer can
   * re-fill.
   */

  context = alt_irq_disable_all ();
81143d00:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_RRDY_MSK;
81143d04:	e0bffc17 	ldw	r2,-16(fp)
81143d08:	10800117 	ldw	r2,4(r2)
81143d0c:	10c02014 	ori	r3,r2,128
81143d10:	e0bffc17 	ldw	r2,-16(fp)
81143d14:	10c00115 	stw	r3,4(r2)
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81143d18:	e0bffc17 	ldw	r2,-16(fp)
81143d1c:	10800017 	ldw	r2,0(r2)
81143d20:	10800304 	addi	r2,r2,12
81143d24:	e0fffc17 	ldw	r3,-16(fp)
81143d28:	18c00117 	ldw	r3,4(r3)
81143d2c:	10c00035 	stwio	r3,0(r2)
81143d30:	e0bff417 	ldw	r2,-48(fp)
81143d34:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143d38:	e0bff317 	ldw	r2,-52(fp)
81143d3c:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* Return the number of bytes read */
  if(read_would_block) {
81143d40:	e0bfef03 	ldbu	r2,-68(fp)
81143d44:	10000226 	beq	r2,zero,81143d50 <altera_avalon_uart_read+0x258>
    return -EWOULDBLOCK;
81143d48:	00bffd44 	movi	r2,-11
81143d4c:	00000106 	br	81143d54 <altera_avalon_uart_read+0x25c>
  }
  else {
    return count;
81143d50:	e0bff017 	ldw	r2,-64(fp)
  }
}
81143d54:	e037883a 	mov	sp,fp
81143d58:	dfc00117 	ldw	ra,4(sp)
81143d5c:	df000017 	ldw	fp,0(sp)
81143d60:	dec00204 	addi	sp,sp,8
81143d64:	f800283a 	ret

81143d68 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81143d68:	defffe04 	addi	sp,sp,-8
81143d6c:	de00012e 	bgeu	sp,et,81143d74 <alt_get_errno+0xc>
81143d70:	003b68fa 	trap	3
81143d74:	dfc00115 	stw	ra,4(sp)
81143d78:	df000015 	stw	fp,0(sp)
81143d7c:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81143d80:	d0a01017 	ldw	r2,-32704(gp)
81143d84:	10000326 	beq	r2,zero,81143d94 <alt_get_errno+0x2c>
81143d88:	d0a01017 	ldw	r2,-32704(gp)
81143d8c:	103ee83a 	callr	r2
81143d90:	00000106 	br	81143d98 <alt_get_errno+0x30>
81143d94:	d0a07404 	addi	r2,gp,-32304
}
81143d98:	e037883a 	mov	sp,fp
81143d9c:	dfc00117 	ldw	ra,4(sp)
81143da0:	df000017 	ldw	fp,0(sp)
81143da4:	dec00204 	addi	sp,sp,8
81143da8:	f800283a 	ret

81143dac <altera_avalon_uart_write>:
 */

int
altera_avalon_uart_write(altera_avalon_uart_state* sp, const char* ptr, int len,
  int flags)
{
81143dac:	deffec04 	addi	sp,sp,-80
81143db0:	de00012e 	bgeu	sp,et,81143db8 <altera_avalon_uart_write+0xc>
81143db4:	003b68fa 	trap	3
81143db8:	dfc01315 	stw	ra,76(sp)
81143dbc:	df001215 	stw	fp,72(sp)
81143dc0:	df001204 	addi	fp,sp,72
81143dc4:	e13ffc15 	stw	r4,-16(fp)
81143dc8:	e17ffd15 	stw	r5,-12(fp)
81143dcc:	e1bffe15 	stw	r6,-8(fp)
81143dd0:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context context;
  int             no_block;
  alt_u32         next;
  int             count = len;
81143dd4:	e0bffe17 	ldw	r2,-8(fp)
81143dd8:	e0bfef15 	stw	r2,-68(fp)
  /* 
   * Construct a flag to indicate whether the device is being accessed in
   * blocking or non-blocking mode.
   */

  no_block = (flags & O_NONBLOCK);
81143ddc:	e0bfff17 	ldw	r2,-4(fp)
81143de0:	1090000c 	andi	r2,r2,16384
81143de4:	e0bff015 	stw	r2,-64(fp)
  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
81143de8:	e0bffc17 	ldw	r2,-16(fp)
81143dec:	10800917 	ldw	r2,36(r2)
81143df0:	e0bff815 	stw	r2,-32(fp)
81143df4:	e03ff90d 	sth	zero,-28(fp)
81143df8:	e0bff90b 	ldhu	r2,-28(fp)
81143dfc:	e0fffb44 	addi	r3,fp,-19
81143e00:	180d883a 	mov	r6,r3
81143e04:	100b883a 	mov	r5,r2
81143e08:	e13ff817 	ldw	r4,-32(fp)
81143e0c:	113aaf40 	call	8113aaf4 <OSSemPend>
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81143e10:	00005106 	br	81143f58 <altera_avalon_uart_write+0x1ac>
  {
    /* Determine the next slot in the buffer to access */

    next = (sp->tx_end + 1) & ALT_AVALON_UART_BUF_MSK;
81143e14:	e0bffc17 	ldw	r2,-16(fp)
81143e18:	10800517 	ldw	r2,20(r2)
81143e1c:	10800044 	addi	r2,r2,1
81143e20:	10800fcc 	andi	r2,r2,63
81143e24:	e0bff215 	stw	r2,-56(fp)

    /* block waiting for space if necessary */

    if (next == sp->tx_start)
81143e28:	e0bffc17 	ldw	r2,-16(fp)
81143e2c:	10c00417 	ldw	r3,16(r2)
81143e30:	e0bff217 	ldw	r2,-56(fp)
81143e34:	1880371e 	bne	r3,r2,81143f14 <altera_avalon_uart_write+0x168>
    {
      if (no_block)
81143e38:	e0bff017 	ldw	r2,-64(fp)
81143e3c:	10000526 	beq	r2,zero,81143e54 <altera_avalon_uart_write+0xa8>
      {
        /* Set errno to indicate why this function returned early */
 
        ALT_ERRNO = EWOULDBLOCK;
81143e40:	1143d680 	call	81143d68 <alt_get_errno>
81143e44:	1007883a 	mov	r3,r2
81143e48:	008002c4 	movi	r2,11
81143e4c:	18800015 	stw	r2,0(r3)
        break;
81143e50:	00004306 	br	81143f60 <altera_avalon_uart_write+0x1b4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143e54:	0005303a 	rdctl	r2,status
81143e58:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143e5c:	e0fff517 	ldw	r3,-44(fp)
81143e60:	00bfff84 	movi	r2,-2
81143e64:	1884703a 	and	r2,r3,r2
81143e68:	1001703a 	wrctl	status,r2
  
  return context;
81143e6c:	e0bff517 	ldw	r2,-44(fp)
      {
        /* Block waiting for space in the circular buffer */

        /* First, ensure transmit interrupts are enabled to avoid deadlock */

        context = alt_irq_disable_all ();
81143e70:	e0bff415 	stw	r2,-48(fp)
        sp->ctrl |= (ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81143e74:	e0bffc17 	ldw	r2,-16(fp)
81143e78:	10800117 	ldw	r2,4(r2)
81143e7c:	10c11014 	ori	r3,r2,1088
81143e80:	e0bffc17 	ldw	r2,-16(fp)
81143e84:	10c00115 	stw	r3,4(r2)
                        ALTERA_AVALON_UART_CONTROL_DCTS_MSK);
        IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81143e88:	e0bffc17 	ldw	r2,-16(fp)
81143e8c:	10800017 	ldw	r2,0(r2)
81143e90:	10800304 	addi	r2,r2,12
81143e94:	e0fffc17 	ldw	r3,-16(fp)
81143e98:	18c00117 	ldw	r3,4(r3)
81143e9c:	10c00035 	stwio	r3,0(r2)
81143ea0:	e0bff417 	ldw	r2,-48(fp)
81143ea4:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143ea8:	e0bff117 	ldw	r2,-60(fp)
81143eac:	1001703a 	wrctl	status,r2
           * flag set in the interrupt service routine. This avoids wasting CPU
           * cycles waiting in this thread, when we could be doing something
           * more profitable elsewhere.
           */

          ALT_FLAG_PEND (sp->events, 
81143eb0:	e0bffc17 	ldw	r2,-16(fp)
81143eb4:	10800717 	ldw	r2,28(r2)
81143eb8:	e0bff315 	stw	r2,-52(fp)
81143ebc:	00800084 	movi	r2,2
81143ec0:	e0bff98d 	sth	r2,-26(fp)
81143ec4:	00bfe0c4 	movi	r2,-125
81143ec8:	e0bffa05 	stb	r2,-24(fp)
81143ecc:	e03ffa8d 	sth	zero,-22(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
81143ed0:	d0a08d03 	ldbu	r2,-32204(gp)
81143ed4:	10803fcc 	andi	r2,r2,255
81143ed8:	10000a26 	beq	r2,zero,81143f04 <altera_avalon_uart_write+0x158>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
81143edc:	e0fff98b 	ldhu	r3,-26(fp)
81143ee0:	e13ffa03 	ldbu	r4,-24(fp)
81143ee4:	e17ffa8b 	ldhu	r5,-22(fp)
81143ee8:	e0bffb04 	addi	r2,fp,-20
81143eec:	d8800015 	stw	r2,0(sp)
81143ef0:	280f883a 	mov	r7,r5
81143ef4:	200d883a 	mov	r6,r4
81143ef8:	180b883a 	mov	r5,r3
81143efc:	e13ff317 	ldw	r4,-52(fp)
81143f00:	1136e540 	call	81136e54 <OSFlagPend>
                         ALT_UART_WRITE_RDY,
                         OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                         0);
        }
        while ((next == sp->tx_start));
81143f04:	e0bffc17 	ldw	r2,-16(fp)
81143f08:	10c00417 	ldw	r3,16(r2)
81143f0c:	e0bff217 	ldw	r2,-56(fp)
81143f10:	18bfe726 	beq	r3,r2,81143eb0 <__reset+0xfb123eb0>
      }
    }

    count--;
81143f14:	e0bfef17 	ldw	r2,-68(fp)
81143f18:	10bfffc4 	addi	r2,r2,-1
81143f1c:	e0bfef15 	stw	r2,-68(fp)

    /* Add the next character to the transmit buffer */

    sp->tx_buf[sp->tx_end] = *ptr++;
81143f20:	e0bffc17 	ldw	r2,-16(fp)
81143f24:	10c00517 	ldw	r3,20(r2)
81143f28:	e0bffd17 	ldw	r2,-12(fp)
81143f2c:	11000044 	addi	r4,r2,1
81143f30:	e13ffd15 	stw	r4,-12(fp)
81143f34:	10800003 	ldbu	r2,0(r2)
81143f38:	1009883a 	mov	r4,r2
81143f3c:	e0bffc17 	ldw	r2,-16(fp)
81143f40:	10c5883a 	add	r2,r2,r3
81143f44:	10801a04 	addi	r2,r2,104
81143f48:	11000005 	stb	r4,0(r2)
    sp->tx_end = next;
81143f4c:	e0bffc17 	ldw	r2,-16(fp)
81143f50:	e0fff217 	ldw	r3,-56(fp)
81143f54:	10c00515 	stw	r3,20(r2)
   * Loop transferring data from the input buffer to the transmit circular
   * buffer. The loop is terminated once all the data has been transferred,
   * or, (if in non-blocking mode) the buffer becomes full.
   */

  while (count)
81143f58:	e0bfef17 	ldw	r2,-68(fp)
81143f5c:	103fad1e 	bne	r2,zero,81143e14 <__reset+0xfb123e14>
  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
81143f60:	e0bffc17 	ldw	r2,-16(fp)
81143f64:	10800917 	ldw	r2,36(r2)
81143f68:	1009883a 	mov	r4,r2
81143f6c:	113ae7c0 	call	8113ae7c <OSSemPost>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81143f70:	0005303a 	rdctl	r2,status
81143f74:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81143f78:	e0fff717 	ldw	r3,-36(fp)
81143f7c:	00bfff84 	movi	r2,-2
81143f80:	1884703a 	and	r2,r3,r2
81143f84:	1001703a 	wrctl	status,r2
  
  return context;
81143f88:	e0bff717 	ldw	r2,-36(fp)
  /* 
   * Ensure that interrupts are enabled, so that the circular buffer can 
   * drain.
   */

  context = alt_irq_disable_all ();
81143f8c:	e0bff415 	stw	r2,-48(fp)
  sp->ctrl |= ALTERA_AVALON_UART_CONTROL_TRDY_MSK |
81143f90:	e0bffc17 	ldw	r2,-16(fp)
81143f94:	10800117 	ldw	r2,4(r2)
81143f98:	10c11014 	ori	r3,r2,1088
81143f9c:	e0bffc17 	ldw	r2,-16(fp)
81143fa0:	10c00115 	stw	r3,4(r2)
                 ALTERA_AVALON_UART_CONTROL_DCTS_MSK;
  IOWR_ALTERA_AVALON_UART_CONTROL(sp->base, sp->ctrl);
81143fa4:	e0bffc17 	ldw	r2,-16(fp)
81143fa8:	10800017 	ldw	r2,0(r2)
81143fac:	10800304 	addi	r2,r2,12
81143fb0:	e0fffc17 	ldw	r3,-16(fp)
81143fb4:	18c00117 	ldw	r3,4(r3)
81143fb8:	10c00035 	stwio	r3,0(r2)
81143fbc:	e0bff417 	ldw	r2,-48(fp)
81143fc0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81143fc4:	e0bff617 	ldw	r2,-40(fp)
81143fc8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (context);

  /* return the number of bytes written */

  return (len - count);
81143fcc:	e0fffe17 	ldw	r3,-8(fp)
81143fd0:	e0bfef17 	ldw	r2,-68(fp)
81143fd4:	1885c83a 	sub	r2,r3,r2
}
81143fd8:	e037883a 	mov	sp,fp
81143fdc:	dfc00117 	ldw	ra,4(sp)
81143fe0:	df000017 	ldw	fp,0(sp)
81143fe4:	dec00204 	addi	sp,sp,8
81143fe8:	f800283a 	ret

81143fec <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
81143fec:	defffe04 	addi	sp,sp,-8
81143ff0:	de00012e 	bgeu	sp,et,81143ff8 <alt_get_errno+0xc>
81143ff4:	003b68fa 	trap	3
81143ff8:	dfc00115 	stw	ra,4(sp)
81143ffc:	df000015 	stw	fp,0(sp)
81144000:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81144004:	d0a01017 	ldw	r2,-32704(gp)
81144008:	10000326 	beq	r2,zero,81144018 <alt_get_errno+0x2c>
8114400c:	d0a01017 	ldw	r2,-32704(gp)
81144010:	103ee83a 	callr	r2
81144014:	00000106 	br	8114401c <alt_get_errno+0x30>
81144018:	d0a07404 	addi	r2,gp,-32304
}
8114401c:	e037883a 	mov	sp,fp
81144020:	dfc00117 	ldw	ra,4(sp)
81144024:	df000017 	ldw	fp,0(sp)
81144028:	dec00204 	addi	sp,sp,8
8114402c:	f800283a 	ret

81144030 <alt_msgdma_write_standard_descriptor>:
 */
static int alt_msgdma_write_standard_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_standard_descriptor *descriptor)
{
81144030:	defffc04 	addi	sp,sp,-16
81144034:	de00012e 	bgeu	sp,et,8114403c <alt_msgdma_write_standard_descriptor+0xc>
81144038:	003b68fa 	trap	3
8114403c:	df000315 	stw	fp,12(sp)
81144040:	df000304 	addi	fp,sp,12
81144044:	e13ffd15 	stw	r4,-12(fp)
81144048:	e17ffe15 	stw	r5,-8(fp)
8114404c:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
81144050:	e0bffd17 	ldw	r2,-12(fp)
81144054:	10800037 	ldwio	r2,0(r2)
81144058:	1080010c 	andi	r2,r2,4
8114405c:	10000226 	beq	r2,zero,81144068 <alt_msgdma_write_standard_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
		is non-blocking*/
        return -ENOSPC;
81144060:	00bff904 	movi	r2,-28
81144064:	00001506 	br	811440bc <alt_msgdma_write_standard_descriptor+0x8c>
    }

	IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(descriptor_base, 
81144068:	e0bfff17 	ldw	r2,-4(fp)
8114406c:	10800017 	ldw	r2,0(r2)
81144070:	1007883a 	mov	r3,r2
81144074:	e0bffe17 	ldw	r2,-8(fp)
81144078:	10c00035 	stwio	r3,0(r2)
		(alt_u32)descriptor->read_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(descriptor_base, 
8114407c:	e0bffe17 	ldw	r2,-8(fp)
81144080:	10800104 	addi	r2,r2,4
81144084:	e0ffff17 	ldw	r3,-4(fp)
81144088:	18c00117 	ldw	r3,4(r3)
8114408c:	10c00035 	stwio	r3,0(r2)
	(	alt_u32)descriptor->write_address);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(descriptor_base, 
81144090:	e0bffe17 	ldw	r2,-8(fp)
81144094:	10800204 	addi	r2,r2,8
81144098:	e0ffff17 	ldw	r3,-4(fp)
8114409c:	18c00217 	ldw	r3,8(r3)
811440a0:	10c00035 	stwio	r3,0(r2)
		descriptor->transfer_length);
	IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_STANDARD(descriptor_base, 
811440a4:	e0bffe17 	ldw	r2,-8(fp)
811440a8:	10800304 	addi	r2,r2,12
811440ac:	e0ffff17 	ldw	r3,-4(fp)
811440b0:	18c00317 	ldw	r3,12(r3)
811440b4:	10c00035 	stwio	r3,0(r2)
		descriptor->control);
        return 0;
811440b8:	0005883a 	mov	r2,zero
}
811440bc:	e037883a 	mov	sp,fp
811440c0:	df000017 	ldw	fp,0(sp)
811440c4:	dec00104 	addi	sp,sp,4
811440c8:	f800283a 	ret

811440cc <alt_msgdma_write_extended_descriptor>:
 */
static int alt_msgdma_write_extended_descriptor (
	alt_u32 *csr_base, 
	alt_u32 *descriptor_base,
	alt_msgdma_extended_descriptor *descriptor)
{
811440cc:	defffc04 	addi	sp,sp,-16
811440d0:	de00012e 	bgeu	sp,et,811440d8 <alt_msgdma_write_extended_descriptor+0xc>
811440d4:	003b68fa 	trap	3
811440d8:	df000315 	stw	fp,12(sp)
811440dc:	df000304 	addi	fp,sp,12
811440e0:	e13ffd15 	stw	r4,-12(fp)
811440e4:	e17ffe15 	stw	r5,-8(fp)
811440e8:	e1bfff15 	stw	r6,-4(fp)
    if (0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(csr_base) & 
811440ec:	e0bffd17 	ldw	r2,-12(fp)
811440f0:	10800037 	ldwio	r2,0(r2)
811440f4:	1080010c 	andi	r2,r2,4
811440f8:	10000226 	beq	r2,zero,81144104 <alt_msgdma_write_extended_descriptor+0x38>
    	ALTERA_MSGDMA_CSR_DESCRIPTOR_BUFFER_FULL_MASK))
    {
      /*at least one descriptor buffer is full, returning so that this function 
	is non-blocking*/
        return -ENOSPC;
811440fc:	00bff904 	movi	r2,-28
81144100:	00003b06 	br	811441f0 <alt_msgdma_write_extended_descriptor+0x124>
    }

    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS(
81144104:	e0bfff17 	ldw	r2,-4(fp)
81144108:	10800017 	ldw	r2,0(r2)
8114410c:	1007883a 	mov	r3,r2
81144110:	e0bffe17 	ldw	r2,-8(fp)
81144114:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	(alt_u32)descriptor->read_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS(
81144118:	e0bffe17 	ldw	r2,-8(fp)
8114411c:	10800104 	addi	r2,r2,4
81144120:	e0ffff17 	ldw	r3,-4(fp)
81144124:	18c00117 	ldw	r3,4(r3)
81144128:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
		(alt_u32)descriptor->write_address_low);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_LENGTH(
8114412c:	e0bffe17 	ldw	r2,-8(fp)
81144130:	10800204 	addi	r2,r2,8
81144134:	e0ffff17 	ldw	r3,-4(fp)
81144138:	18c00217 	ldw	r3,8(r3)
8114413c:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->transfer_length);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_SEQUENCE_NUMBER(
81144140:	e0bffe17 	ldw	r2,-8(fp)
81144144:	10800304 	addi	r2,r2,12
81144148:	e0ffff17 	ldw	r3,-4(fp)
8114414c:	18c0030b 	ldhu	r3,12(r3)
81144150:	18ffffcc 	andi	r3,r3,65535
81144154:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->sequence_number);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_BURST(
81144158:	e0bffe17 	ldw	r2,-8(fp)
8114415c:	10800384 	addi	r2,r2,14
81144160:	e0ffff17 	ldw	r3,-4(fp)
81144164:	18c00383 	ldbu	r3,14(r3)
81144168:	18c03fcc 	andi	r3,r3,255
8114416c:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_BURST(
81144170:	e0bffe17 	ldw	r2,-8(fp)
81144174:	108003c4 	addi	r2,r2,15
81144178:	e0ffff17 	ldw	r3,-4(fp)
8114417c:	18c003c3 	ldbu	r3,15(r3)
81144180:	18c03fcc 	andi	r3,r3,255
81144184:	10c00025 	stbio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_burst_count);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_STRIDE(
81144188:	e0bffe17 	ldw	r2,-8(fp)
8114418c:	10800404 	addi	r2,r2,16
81144190:	e0ffff17 	ldw	r3,-4(fp)
81144194:	18c0040b 	ldhu	r3,16(r3)
81144198:	18ffffcc 	andi	r3,r3,65535
8114419c:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->read_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_STRIDE(
811441a0:	e0bffe17 	ldw	r2,-8(fp)
811441a4:	10800484 	addi	r2,r2,18
811441a8:	e0ffff17 	ldw	r3,-4(fp)
811441ac:	18c0048b 	ldhu	r3,18(r3)
811441b0:	18ffffcc 	andi	r3,r3,65535
811441b4:	10c0002d 	sthio	r3,0(r2)
		descriptor_base, 
    	descriptor->write_stride);
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_READ_ADDRESS_HIGH(descriptor_base, 0);
811441b8:	e0bffe17 	ldw	r2,-8(fp)
811441bc:	10800504 	addi	r2,r2,20
811441c0:	0007883a 	mov	r3,zero
811441c4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_WRITE_ADDRESS_HIGH(descriptor_base, 0);
811441c8:	e0bffe17 	ldw	r2,-8(fp)
811441cc:	10800604 	addi	r2,r2,24
811441d0:	0007883a 	mov	r3,zero
811441d4:	10c00035 	stwio	r3,0(r2)
    IOWR_ALTERA_MSGDMA_DESCRIPTOR_CONTROL_ENHANCED(
811441d8:	e0bffe17 	ldw	r2,-8(fp)
811441dc:	10800704 	addi	r2,r2,28
811441e0:	e0ffff17 	ldw	r3,-4(fp)
811441e4:	18c00717 	ldw	r3,28(r3)
811441e8:	10c00035 	stwio	r3,0(r2)
		descriptor_base, 
    	descriptor->control);
    return 0;
811441ec:	0005883a 	mov	r2,zero
}
811441f0:	e037883a 	mov	sp,fp
811441f4:	df000017 	ldw	fp,0(sp)
811441f8:	dec00104 	addi	sp,sp,4
811441fc:	f800283a 	ret

81144200 <alt_msgdma_irq>:
 * alt_msgdma_irq()
 *
 * Interrupt handler for the Modular Scatter-Gather DMA controller.
 */
static void alt_msgdma_irq(void *context)
{
81144200:	defff804 	addi	sp,sp,-32
81144204:	de00012e 	bgeu	sp,et,8114420c <alt_msgdma_irq+0xc>
81144208:	003b68fa 	trap	3
8114420c:	dfc00715 	stw	ra,28(sp)
81144210:	df000615 	stw	fp,24(sp)
81144214:	df000604 	addi	fp,sp,24
81144218:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev *dev = (alt_msgdma_dev *) context;
8114421c:	e0bfff17 	ldw	r2,-4(fp)
81144220:	e0bffa15 	stw	r2,-24(fp)
    alt_irq_context cpu_sr;
    alt_u32 temporary_control;

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
81144224:	e0bffa17 	ldw	r2,-24(fp)
81144228:	10801783 	ldbu	r2,94(r2)
8114422c:	10803fcc 	andi	r2,r2,255
81144230:	10001126 	beq	r2,zero,81144278 <alt_msgdma_irq+0x78>
    {
        temporary_control = 
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81144234:	e0bffa17 	ldw	r2,-24(fp)
81144238:	10800617 	ldw	r2,24(r2)
8114423c:	10800037 	ldwio	r2,0(r2)

    
    /* disable global interrupt*/
    if (dev->prefetcher_enable)
    {
        temporary_control = 
81144240:	1007883a 	mov	r3,r2
81144244:	00bffdc4 	movi	r2,-9
81144248:	1884703a 	and	r2,r3,r2
8114424c:	e0bffb15 	stw	r2,-20(fp)
        		IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				& ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
        
        IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81144250:	e0bffa17 	ldw	r2,-24(fp)
81144254:	10800617 	ldw	r2,24(r2)
81144258:	e0fffb17 	ldw	r3,-20(fp)
8114425c:	10c00035 	stwio	r3,0(r2)
        		temporary_control);
        
        /* clear the IRQ status- W1C */
        IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base,
81144260:	e0bffa17 	ldw	r2,-24(fp)
81144264:	10800617 	ldw	r2,24(r2)
81144268:	10800404 	addi	r2,r2,16
8114426c:	00c00044 	movi	r3,1
81144270:	10c00035 	stwio	r3,0(r2)
81144274:	00001106 	br	811442bc <alt_msgdma_irq+0xbc>
        		ALT_MSGDMA_PREFETCHER_STATUS_IRQ_SET_MASK);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81144278:	e0bffa17 	ldw	r2,-24(fp)
8114427c:	10800317 	ldw	r2,12(r2)
81144280:	10800104 	addi	r2,r2,4
81144284:	10800037 	ldwio	r2,0(r2)
81144288:	1007883a 	mov	r3,r2
8114428c:	00bffbc4 	movi	r2,-17
81144290:	1884703a 	and	r2,r3,r2
81144294:	e0bffb15 	stw	r2,-20(fp)
    			& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81144298:	e0bffa17 	ldw	r2,-24(fp)
8114429c:	10800317 	ldw	r2,12(r2)
811442a0:	10800104 	addi	r2,r2,4
811442a4:	e0fffb17 	ldw	r3,-20(fp)
811442a8:	10c00035 	stwio	r3,0(r2)
    	/* clear the IRQ status */
    	IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base,
811442ac:	e0bffa17 	ldw	r2,-24(fp)
811442b0:	10800317 	ldw	r2,12(r2)
811442b4:	00c08004 	movi	r3,512
811442b8:	10c00035 	stwio	r3,0(r2)
    * Other interrupts are explicitly disabled if callbacks
    * are registered because there is no guarantee that they are 
    * pre-emption-safe. This allows the driver to support 
    * interrupt pre-emption.
    */
    if(dev->callback) 
811442bc:	e0bffa17 	ldw	r2,-24(fp)
811442c0:	10800b17 	ldw	r2,44(r2)
811442c4:	10001226 	beq	r2,zero,81144310 <alt_msgdma_irq+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811442c8:	0005303a 	rdctl	r2,status
811442cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811442d0:	e0fffd17 	ldw	r3,-12(fp)
811442d4:	00bfff84 	movi	r2,-2
811442d8:	1884703a 	and	r2,r3,r2
811442dc:	1001703a 	wrctl	status,r2
  
  return context;
811442e0:	e0bffd17 	ldw	r2,-12(fp)
    {
        cpu_sr = alt_irq_disable_all();
811442e4:	e0bffc15 	stw	r2,-16(fp)
        dev->callback (dev->callback_context);
811442e8:	e0bffa17 	ldw	r2,-24(fp)
811442ec:	10800b17 	ldw	r2,44(r2)
811442f0:	e0fffa17 	ldw	r3,-24(fp)
811442f4:	18c00c17 	ldw	r3,48(r3)
811442f8:	1809883a 	mov	r4,r3
811442fc:	103ee83a 	callr	r2
81144300:	e0bffc17 	ldw	r2,-16(fp)
81144304:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144308:	e0bffe17 	ldw	r2,-8(fp)
8114430c:	1001703a 	wrctl	status,r2
        alt_irq_enable_all(cpu_sr);
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
81144310:	e0bffa17 	ldw	r2,-24(fp)
81144314:	10801783 	ldbu	r2,94(r2)
81144318:	10803fcc 	andi	r2,r2,255
8114431c:	10000a26 	beq	r2,zero,81144348 <alt_msgdma_irq+0x148>
    {
    	temporary_control = 
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
81144320:	e0bffa17 	ldw	r2,-24(fp)
81144324:	10800617 	ldw	r2,24(r2)
81144328:	10800037 	ldwio	r2,0(r2)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
8114432c:	10800214 	ori	r2,r2,8
    }

    /* enable global interrupt */
    if (dev->prefetcher_enable)
    {
    	temporary_control = 
81144330:	e0bffb15 	stw	r2,-20(fp)
    			IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base)
				| ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
    	
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
81144334:	e0bffa17 	ldw	r2,-24(fp)
81144338:	10800617 	ldw	r2,24(r2)
8114433c:	e0fffb17 	ldw	r3,-20(fp)
81144340:	10c00035 	stwio	r3,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
    }

    return;
81144344:	00000c06 	br	81144378 <alt_msgdma_irq+0x178>
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
81144348:	e0bffa17 	ldw	r2,-24(fp)
8114434c:	10800317 	ldw	r2,12(r2)
81144350:	10800104 	addi	r2,r2,4
81144354:	10800037 	ldwio	r2,0(r2)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
81144358:	10800414 	ori	r2,r2,16
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base,
    			temporary_control);
    }
    else
    {
    	temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) 
8114435c:	e0bffb15 	stw	r2,-20(fp)
    			| (ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    	
    	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81144360:	e0bffa17 	ldw	r2,-24(fp)
81144364:	10800317 	ldw	r2,12(r2)
81144368:	10800104 	addi	r2,r2,4
8114436c:	e0fffb17 	ldw	r3,-20(fp)
81144370:	10c00035 	stwio	r3,0(r2)
    }

    return;
81144374:	0001883a 	nop
}
81144378:	e037883a 	mov	sp,fp
8114437c:	dfc00117 	ldw	ra,4(sp)
81144380:	df000017 	ldw	fp,0(sp)
81144384:	dec00204 	addi	sp,sp,8
81144388:	f800283a 	ret

8114438c <alt_msgdma_construct_standard_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114438c:	defffb04 	addi	sp,sp,-20
81144390:	de00012e 	bgeu	sp,et,81144398 <alt_msgdma_construct_standard_descriptor+0xc>
81144394:	003b68fa 	trap	3
81144398:	df000415 	stw	fp,16(sp)
8114439c:	df000404 	addi	fp,sp,16
811443a0:	e13ffc15 	stw	r4,-16(fp)
811443a4:	e17ffd15 	stw	r5,-12(fp)
811443a8:	e1bffe15 	stw	r6,-8(fp)
811443ac:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
811443b0:	e0bffc17 	ldw	r2,-16(fp)
811443b4:	10c01217 	ldw	r3,72(r2)
811443b8:	e0800117 	ldw	r2,4(fp)
811443bc:	18800436 	bltu	r3,r2,811443d0 <alt_msgdma_construct_standard_descriptor+0x44>
       dev->enhanced_features != 0
811443c0:	e0bffc17 	ldw	r2,-16(fp)
811443c4:	10801703 	ldbu	r2,92(r2)
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
811443c8:	10803fcc 	andi	r2,r2,255
811443cc:	10000226 	beq	r2,zero,811443d8 <alt_msgdma_construct_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
811443d0:	00bffa84 	movi	r2,-22
811443d4:	00000e06 	br	81144410 <alt_msgdma_construct_standard_descriptor+0x84>
    }
    descriptor->read_address = read_address;
811443d8:	e0bffd17 	ldw	r2,-12(fp)
811443dc:	e0fffe17 	ldw	r3,-8(fp)
811443e0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
811443e4:	e0bffd17 	ldw	r2,-12(fp)
811443e8:	e0ffff17 	ldw	r3,-4(fp)
811443ec:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
811443f0:	e0bffd17 	ldw	r2,-12(fp)
811443f4:	e0c00117 	ldw	r3,4(fp)
811443f8:	10c00215 	stw	r3,8(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811443fc:	e0800217 	ldw	r2,8(fp)
81144400:	10e00034 	orhi	r3,r2,32768
81144404:	e0bffd17 	ldw	r2,-12(fp)
81144408:	10c00315 	stw	r3,12(r2)
    
    return 0;
8114440c:	0005883a 	mov	r2,zero
}
81144410:	e037883a 	mov	sp,fp
81144414:	df000017 	ldw	fp,0(sp)
81144418:	dec00104 	addi	sp,sp,4
8114441c:	f800283a 	ret

81144420 <alt_msgdma_construct_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81144420:	defff604 	addi	sp,sp,-40
81144424:	de00012e 	bgeu	sp,et,8114442c <alt_msgdma_construct_extended_descriptor+0xc>
81144428:	003b68fa 	trap	3
8114442c:	df000915 	stw	fp,36(sp)
81144430:	df000904 	addi	fp,sp,36
81144434:	e13ff715 	stw	r4,-36(fp)
81144438:	e17ff815 	stw	r5,-32(fp)
8114443c:	e1bff915 	stw	r6,-28(fp)
81144440:	e1fffa15 	stw	r7,-24(fp)
81144444:	e1800317 	ldw	r6,12(fp)
81144448:	e1400417 	ldw	r5,16(fp)
8114444c:	e1000517 	ldw	r4,20(fp)
81144450:	e0c00617 	ldw	r3,24(fp)
81144454:	e0800717 	ldw	r2,28(fp)
81144458:	e1bffb0d 	sth	r6,-20(fp)
8114445c:	e17ffc05 	stb	r5,-16(fp)
81144460:	e13ffd05 	stb	r4,-12(fp)
81144464:	e0fffe0d 	sth	r3,-8(fp)
81144468:	e0bfff0d 	sth	r2,-4(fp)
    if(dev->max_byte < length ||
8114446c:	e0bff717 	ldw	r2,-36(fp)
81144470:	10c01217 	ldw	r3,72(r2)
81144474:	e0800117 	ldw	r2,4(fp)
81144478:	18801936 	bltu	r3,r2,811444e0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
8114447c:	e13ff717 	ldw	r4,-36(fp)
81144480:	20801317 	ldw	r2,76(r4)
81144484:	20c01417 	ldw	r3,80(r4)
81144488:	e13ffe0b 	ldhu	r4,-8(fp)
8114448c:	213fffcc 	andi	r4,r4,65535
81144490:	2015883a 	mov	r10,r4
81144494:	0017883a 	mov	r11,zero
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
81144498:	1ac01136 	bltu	r3,r11,811444e0 <alt_msgdma_construct_extended_descriptor+0xc0>
8114449c:	58c0011e 	bne	r11,r3,811444a4 <alt_msgdma_construct_extended_descriptor+0x84>
811444a0:	12800f36 	bltu	r2,r10,811444e0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811444a4:	e13ff717 	ldw	r4,-36(fp)
811444a8:	20801317 	ldw	r2,76(r4)
811444ac:	20c01417 	ldw	r3,80(r4)
811444b0:	e13fff0b 	ldhu	r4,-4(fp)
811444b4:	213fffcc 	andi	r4,r4,65535
811444b8:	2011883a 	mov	r8,r4
811444bc:	0013883a 	mov	r9,zero
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
811444c0:	1a400736 	bltu	r3,r9,811444e0 <alt_msgdma_construct_extended_descriptor+0xc0>
811444c4:	48c0011e 	bne	r9,r3,811444cc <alt_msgdma_construct_extended_descriptor+0xac>
811444c8:	12000536 	bltu	r2,r8,811444e0 <alt_msgdma_construct_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
811444cc:	e0bff717 	ldw	r2,-36(fp)
811444d0:	10801703 	ldbu	r2,92(r2)
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
    if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811444d4:	10803fcc 	andi	r2,r2,255
811444d8:	10800060 	cmpeqi	r2,r2,1
811444dc:	1000021e 	bne	r2,zero,811444e8 <alt_msgdma_construct_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
811444e0:	00bffa84 	movi	r2,-22
811444e4:	00002106 	br	8114456c <alt_msgdma_construct_extended_descriptor+0x14c>
    }
    
    descriptor->read_address_low = read_address;
811444e8:	e0bff817 	ldw	r2,-32(fp)
811444ec:	e0fff917 	ldw	r3,-28(fp)
811444f0:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_low = write_address;
811444f4:	e0bff817 	ldw	r2,-32(fp)
811444f8:	e0fffa17 	ldw	r3,-24(fp)
811444fc:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81144500:	e0bff817 	ldw	r2,-32(fp)
81144504:	e0c00117 	ldw	r3,4(fp)
81144508:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
8114450c:	e0bff817 	ldw	r2,-32(fp)
81144510:	e0fffb0b 	ldhu	r3,-20(fp)
81144514:	10c0030d 	sth	r3,12(r2)
    descriptor->read_burst_count = read_burst_count;
81144518:	e0bff817 	ldw	r2,-32(fp)
8114451c:	e0fffc03 	ldbu	r3,-16(fp)
81144520:	10c00385 	stb	r3,14(r2)
    descriptor->write_burst_count = write_burst_count;
81144524:	e0bff817 	ldw	r2,-32(fp)
81144528:	e0fffd03 	ldbu	r3,-12(fp)
8114452c:	10c003c5 	stb	r3,15(r2)
    descriptor->read_stride = read_stride;
81144530:	e0bff817 	ldw	r2,-32(fp)
81144534:	e0fffe0b 	ldhu	r3,-8(fp)
81144538:	10c0040d 	sth	r3,16(r2)
    descriptor->write_stride = write_stride;
8114453c:	e0bff817 	ldw	r2,-32(fp)
81144540:	e0ffff0b 	ldhu	r3,-4(fp)
81144544:	10c0048d 	sth	r3,18(r2)
    descriptor->read_address_high = NULL;
81144548:	e0bff817 	ldw	r2,-32(fp)
8114454c:	10000515 	stw	zero,20(r2)
    descriptor->write_address_high = NULL;
81144550:	e0bff817 	ldw	r2,-32(fp)
81144554:	10000615 	stw	zero,24(r2)
    descriptor->control = control | ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81144558:	e0800217 	ldw	r2,8(fp)
8114455c:	10e00034 	orhi	r3,r2,32768
81144560:	e0bff817 	ldw	r2,-32(fp)
81144564:	10c00715 	stw	r3,28(r2)

  return 0 ;
81144568:	0005883a 	mov	r2,zero

}
8114456c:	e037883a 	mov	sp,fp
81144570:	df000017 	ldw	fp,0(sp)
81144574:	dec00104 	addi	sp,sp,4
81144578:	f800283a 	ret

8114457c <alt_msgdma_descriptor_async_transfer>:
 */
static int alt_msgdma_descriptor_async_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
8114457c:	deffee04 	addi	sp,sp,-72
81144580:	de00012e 	bgeu	sp,et,81144588 <alt_msgdma_descriptor_async_transfer+0xc>
81144584:	003b68fa 	trap	3
81144588:	dfc01115 	stw	ra,68(sp)
8114458c:	df001015 	stw	fp,64(sp)
81144590:	df001004 	addi	fp,sp,64
81144594:	e13ffd15 	stw	r4,-12(fp)
81144598:	e17ffe15 	stw	r5,-8(fp)
8114459c:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control = 0;
811445a0:	e03ff115 	stw	zero,-60(fp)
    alt_irq_context context = 0;
811445a4:	e03ff215 	stw	zero,-56(fp)
    alt_u16 counter = 0;
811445a8:	e03ff00d 	sth	zero,-64(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811445ac:	e0bffd17 	ldw	r2,-12(fp)
811445b0:	10800317 	ldw	r2,12(r2)
811445b4:	10800204 	addi	r2,r2,8
811445b8:	10800037 	ldwio	r2,0(r2)
	alt_msgdma_extended_descriptor *extended_desc)
{
    alt_u32 control = 0;
    alt_irq_context context = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
811445bc:	10bfffcc 	andi	r2,r2,65535
811445c0:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811445c4:	e0bffd17 	ldw	r2,-12(fp)
811445c8:	10800317 	ldw	r2,12(r2)
811445cc:	10800204 	addi	r2,r2,8
811445d0:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
811445d4:	1004d43a 	srli	r2,r2,16
811445d8:	e0bff415 	stw	r2,-48(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811445dc:	e0bffd17 	ldw	r2,-12(fp)
811445e0:	10800917 	ldw	r2,36(r2)
811445e4:	e0fff417 	ldw	r3,-48(fp)
811445e8:	1880042e 	bgeu	r3,r2,811445fc <alt_msgdma_descriptor_async_transfer+0x80>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811445ec:	e0bffd17 	ldw	r2,-12(fp)
811445f0:	10800917 	ldw	r2,36(r2)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;

	/* Return with error immediately if one of read/write buffer is full */
	if((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811445f4:	e0fff317 	ldw	r3,-52(fp)
811445f8:	18800236 	bltu	r3,r2,81144604 <alt_msgdma_descriptor_async_transfer+0x88>
		(dev->descriptor_fifo_depth <= fifo_read_fill_level))
	{
		/*at least one write or read FIFO descriptor buffer is full,
		returning so that this function is non-blocking*/
		return -ENOSPC;
811445fc:	00bff904 	movi	r2,-28
81144600:	0000a906 	br	811448a8 <alt_msgdma_descriptor_async_transfer+0x32c>
	
	/*
	* When running in a multi threaded environment, obtain the "regs_lock"
	* semaphore. This ensures that accessing registers is thread-safe.
	*/
	ALT_SEM_PEND (dev->regs_lock, 0);
81144604:	e0bffd17 	ldw	r2,-12(fp)
81144608:	10801817 	ldw	r2,96(r2)
8114460c:	e0bff615 	stw	r2,-40(fp)
81144610:	e03ffc0d 	sth	zero,-16(fp)
81144614:	e0bffc0b 	ldhu	r2,-16(fp)
81144618:	e0fffc84 	addi	r3,fp,-14
8114461c:	180d883a 	mov	r6,r3
81144620:	100b883a 	mov	r5,r2
81144624:	e13ff617 	ldw	r4,-40(fp)
81144628:	113aaf40 	call	8113aaf4 <OSSemPend>
	
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	read or write masters  */
	/* stop issuing more descriptors */
	control = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
8114462c:	00800804 	movi	r2,32
81144630:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144634:	0005303a 	rdctl	r2,status
81144638:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114463c:	e0fff717 	ldw	r3,-36(fp)
81144640:	00bfff84 	movi	r2,-2
81144644:	1884703a 	and	r2,r3,r2
81144648:	1001703a 	wrctl	status,r2
  
  return context;
8114464c:	e0bff717 	ldw	r2,-36(fp)
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81144650:	e0bff215 	stw	r2,-56(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81144654:	e0bffd17 	ldw	r2,-12(fp)
81144658:	10800317 	ldw	r2,12(r2)
8114465c:	10800104 	addi	r2,r2,4
81144660:	e0fff117 	ldw	r3,-60(fp)
81144664:	10c00035 	stwio	r3,0(r2)
	/*
	* Clear any (previous) status register information
	* that might occlude our error checking later.
	*/
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
81144668:	e0bffd17 	ldw	r2,-12(fp)
8114466c:	10800317 	ldw	r2,12(r2)
81144670:	e0fffd17 	ldw	r3,-12(fp)
81144674:	18c00317 	ldw	r3,12(r3)
81144678:	18c00037 	ldwio	r3,0(r3)
8114467c:	10c00035 	stwio	r3,0(r2)
81144680:	e0bff217 	ldw	r2,-56(fp)
81144684:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144688:	e0bffb17 	ldw	r2,-20(fp)
8114468c:	1001703a 	wrctl	status,r2
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
81144690:	e0bffe17 	ldw	r2,-8(fp)
81144694:	10001e26 	beq	r2,zero,81144710 <alt_msgdma_descriptor_async_transfer+0x194>
81144698:	e0bfff17 	ldw	r2,-4(fp)
8114469c:	10001c1e 	bne	r2,zero,81144710 <alt_msgdma_descriptor_async_transfer+0x194>
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811446a0:	00001106 	br	811446e8 <alt_msgdma_descriptor_async_transfer+0x16c>
		dev->csr_base, dev->descriptor_base, standard_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
811446a4:	01000044 	movi	r4,1
811446a8:	113227c0 	call	8113227c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
811446ac:	e0bff00b 	ldhu	r2,-64(fp)
811446b0:	1084e230 	cmpltui	r2,r2,5000
811446b4:	1000091e 	bne	r2,zero,811446dc <alt_msgdma_descriptor_async_transfer+0x160>
            {
                alt_printf("time out after 5 msec while waiting" 
811446b8:	01204574 	movhi	r4,33045
811446bc:	21328704 	addi	r4,r4,-13796
811446c0:	11469d00 	call	811469d0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
811446c4:	e0bffd17 	ldw	r2,-12(fp)
811446c8:	10801817 	ldw	r2,96(r2)
811446cc:	1009883a 	mov	r4,r2
811446d0:	113ae7c0 	call	8113ae7c <OSSemPost>
				
                return -ETIME;
811446d4:	00bff084 	movi	r2,-62
811446d8:	00007306 	br	811448a8 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
811446dc:	e0bff00b 	ldhu	r2,-64(fp)
811446e0:	10800044 	addi	r2,r2,1
811446e4:	e0bff00d 	sth	r2,-64(fp)

    if (NULL != standard_desc && NULL == extended_desc)
    {
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
811446e8:	e0bffd17 	ldw	r2,-12(fp)
811446ec:	10c00317 	ldw	r3,12(r2)
811446f0:	e0bffd17 	ldw	r2,-12(fp)
811446f4:	10800417 	ldw	r2,16(r2)
811446f8:	e1bffe17 	ldw	r6,-8(fp)
811446fc:	100b883a 	mov	r5,r2
81144700:	1809883a 	mov	r4,r3
81144704:	11440300 	call	81144030 <alt_msgdma_write_standard_descriptor>
81144708:	103fe61e 	bne	r2,zero,811446a4 <__reset+0xfb1246a4>
	IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
	alt_irq_enable_all(context);

    if (NULL != standard_desc && NULL == extended_desc)
8114470c:	00002706 	br	811447ac <alt_msgdma_descriptor_async_transfer+0x230>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81144710:	e0bffe17 	ldw	r2,-8(fp)
81144714:	10001f1e 	bne	r2,zero,81144794 <alt_msgdma_descriptor_async_transfer+0x218>
81144718:	e0bfff17 	ldw	r2,-4(fp)
8114471c:	10001d26 	beq	r2,zero,81144794 <alt_msgdma_descriptor_async_transfer+0x218>
    {
        counter = 0; /* reset counter */
81144720:	e03ff00d 	sth	zero,-64(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81144724:	00001106 	br	8114476c <alt_msgdma_descriptor_async_transfer+0x1f0>
		dev->csr_base, 
		dev->descriptor_base, 
		extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81144728:	01000044 	movi	r4,1
8114472c:	113227c0 	call	8113227c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144730:	e0bff00b 	ldhu	r2,-64(fp)
81144734:	1084e230 	cmpltui	r2,r2,5000
81144738:	1000091e 	bne	r2,zero,81144760 <alt_msgdma_descriptor_async_transfer+0x1e4>
            {
                alt_printf("time out after 5 msec while waiting free FIFO buffer" 
8114473c:	01204574 	movhi	r4,33045
81144740:	21329d04 	addi	r4,r4,-13708
81144744:	11469d00 	call	811469d0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81144748:	e0bffd17 	ldw	r2,-12(fp)
8114474c:	10801817 	ldw	r2,96(r2)
81144750:	1009883a 	mov	r4,r2
81144754:	113ae7c0 	call	8113ae7c <OSSemPost>
				
                return -ETIME;
81144758:	00bff084 	movi	r2,-62
8114475c:	00005206 	br	811448a8 <alt_msgdma_descriptor_async_transfer+0x32c>
            }
            counter++; 
81144760:	e0bff00b 	ldhu	r2,-64(fp)
81144764:	10800044 	addi	r2,r2,1
81144768:	e0bff00d 	sth	r2,-64(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
8114476c:	e0bffd17 	ldw	r2,-12(fp)
81144770:	10c00317 	ldw	r3,12(r2)
81144774:	e0bffd17 	ldw	r2,-12(fp)
81144778:	10800417 	ldw	r2,16(r2)
8114477c:	e1bfff17 	ldw	r6,-4(fp)
81144780:	100b883a 	mov	r5,r2
81144784:	1809883a 	mov	r4,r3
81144788:	11440cc0 	call	811440cc <alt_msgdma_write_extended_descriptor>
8114478c:	103fe61e 	bne	r2,zero,81144728 <__reset+0xfb124728>
                return -ETIME;
            }
            counter++; 
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81144790:	00000606 	br	811447ac <alt_msgdma_descriptor_async_transfer+0x230>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81144794:	e0bffd17 	ldw	r2,-12(fp)
81144798:	10801817 	ldw	r2,96(r2)
8114479c:	1009883a 	mov	r4,r2
811447a0:	113ae7c0 	call	8113ae7c <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
811447a4:	00bfffc4 	movi	r2,-1
811447a8:	00003f06 	br	811448a8 <alt_msgdma_descriptor_async_transfer+0x32c>
    * If a callback routine has been previously registered which will be
    * called from the msgdma ISR. Set up controller to:
    *  - Run
    *  - Stop on an error with any particular descriptor
    */
    if(dev->callback)
811447ac:	e0bffd17 	ldw	r2,-12(fp)
811447b0:	10800b17 	ldw	r2,44(r2)
811447b4:	10001c26 	beq	r2,zero,81144828 <alt_msgdma_descriptor_async_transfer+0x2ac>
    {

        control |= (dev->control |
811447b8:	e0bffd17 	ldw	r2,-12(fp)
811447bc:	10c00d17 	ldw	r3,52(r2)
811447c0:	e0bff117 	ldw	r2,-60(fp)
811447c4:	1884b03a 	or	r2,r3,r2
811447c8:	10800514 	ori	r2,r2,20
811447cc:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK |
                    ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
        control &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
811447d0:	e0fff117 	ldw	r3,-60(fp)
811447d4:	00bff7c4 	movi	r2,-33
811447d8:	1884703a 	and	r2,r3,r2
811447dc:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811447e0:	0005303a 	rdctl	r2,status
811447e4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811447e8:	e0fff917 	ldw	r3,-28(fp)
811447ec:	00bfff84 	movi	r2,-2
811447f0:	1884703a 	and	r2,r3,r2
811447f4:	1001703a 	wrctl	status,r2
  
  return context;
811447f8:	e0bff917 	ldw	r2,-28(fp)
    /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all(); 
811447fc:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81144800:	e0bffd17 	ldw	r2,-12(fp)
81144804:	10800317 	ldw	r2,12(r2)
81144808:	10800104 	addi	r2,r2,4
8114480c:	e0fff117 	ldw	r3,-60(fp)
81144810:	10c00035 	stwio	r3,0(r2)
81144814:	e0bff217 	ldw	r2,-56(fp)
81144818:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114481c:	e0bff517 	ldw	r2,-44(fp)
81144820:	1001703a 	wrctl	status,r2
81144824:	00001b06 	br	81144894 <alt_msgdma_descriptor_async_transfer+0x318>
    *   - Stop on an error with any particular descriptor
    *   - Disable interrupt generation
    */
    else
    {
        control |= (dev->control |
81144828:	e0bffd17 	ldw	r2,-12(fp)
8114482c:	10c00d17 	ldw	r3,52(r2)
81144830:	e0bff117 	ldw	r2,-60(fp)
81144834:	1884b03a 	or	r2,r3,r2
81144838:	10800114 	ori	r2,r2,4
8114483c:	e0bff115 	stw	r2,-60(fp)
                    ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK );
        control &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
81144840:	e0fff117 	ldw	r3,-60(fp)
81144844:	00bff3c4 	movi	r2,-49
81144848:	1884703a 	and	r2,r3,r2
8114484c:	e0bff115 	stw	r2,-60(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144850:	0005303a 	rdctl	r2,status
81144854:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144858:	e0fffa17 	ldw	r3,-24(fp)
8114485c:	00bfff84 	movi	r2,-2
81144860:	1884703a 	and	r2,r3,r2
81144864:	1001703a 	wrctl	status,r2
  
  return context;
81144868:	e0bffa17 	ldw	r2,-24(fp)
                   (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
        /* making sure the read-modify-write below can't be pre-empted */
        context = alt_irq_disable_all();
8114486c:	e0bff215 	stw	r2,-56(fp)
        IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81144870:	e0bffd17 	ldw	r2,-12(fp)
81144874:	10800317 	ldw	r2,12(r2)
81144878:	10800104 	addi	r2,r2,4
8114487c:	e0fff117 	ldw	r3,-60(fp)
81144880:	10c00035 	stwio	r3,0(r2)
81144884:	e0bff217 	ldw	r2,-56(fp)
81144888:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
8114488c:	e0bff817 	ldw	r2,-32(fp)
81144890:	1001703a 	wrctl	status,r2

    /*
	 * Now that access to the registers is complete, release the registers
     * semaphore so that other threads can access the registers.
     */
    ALT_SEM_POST (dev->regs_lock);
81144894:	e0bffd17 	ldw	r2,-12(fp)
81144898:	10801817 	ldw	r2,96(r2)
8114489c:	1009883a 	mov	r4,r2
811448a0:	113ae7c0 	call	8113ae7c <OSSemPost>
    
    return 0;
811448a4:	0005883a 	mov	r2,zero
}
811448a8:	e037883a 	mov	sp,fp
811448ac:	dfc00117 	ldw	ra,4(sp)
811448b0:	df000017 	ldw	fp,0(sp)
811448b4:	dec00204 	addi	sp,sp,8
811448b8:	f800283a 	ret

811448bc <alt_msgdma_descriptor_sync_transfer>:
 */
static int alt_msgdma_descriptor_sync_transfer (
	alt_msgdma_dev *dev, 
	alt_msgdma_standard_descriptor *standard_desc, 
	alt_msgdma_extended_descriptor *extended_desc)
{
811448bc:	deffee04 	addi	sp,sp,-72
811448c0:	de00012e 	bgeu	sp,et,811448c8 <alt_msgdma_descriptor_sync_transfer+0xc>
811448c4:	003b68fa 	trap	3
811448c8:	dfc01115 	stw	ra,68(sp)
811448cc:	df001015 	stw	fp,64(sp)
811448d0:	df001004 	addi	fp,sp,64
811448d4:	e13ffd15 	stw	r4,-12(fp)
811448d8:	e17ffe15 	stw	r5,-8(fp)
811448dc:	e1bfff15 	stw	r6,-4(fp)
    alt_u32 control=0;
811448e0:	e03ff415 	stw	zero,-48(fp)
    alt_irq_context context=0;
811448e4:	e03ff515 	stw	zero,-44(fp)
    alt_u32 csr_status = 0;
811448e8:	e03ff015 	stw	zero,-64(fp)
    alt_u16 counter = 0;
811448ec:	e03ff10d 	sth	zero,-60(fp)
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
811448f0:	e0bffd17 	ldw	r2,-12(fp)
811448f4:	10800317 	ldw	r2,12(r2)
811448f8:	10800204 	addi	r2,r2,8
811448fc:	10800037 	ldwio	r2,0(r2)
{
    alt_u32 control=0;
    alt_irq_context context=0;
    alt_u32 csr_status = 0;
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
81144900:	10bfffcc 	andi	r2,r2,65535
81144904:	e0bff215 	stw	r2,-56(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81144908:	e0bffd17 	ldw	r2,-12(fp)
8114490c:	10800317 	ldw	r2,12(r2)
81144910:	10800204 	addi	r2,r2,8
81144914:	10800037 	ldwio	r2,0(r2)
    alt_u16 counter = 0;
    alt_u32 fifo_read_fill_level = (
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
    alt_u32 fifo_write_fill_level = (
81144918:	1004d43a 	srli	r2,r2,16
8114491c:	e0bff315 	stw	r2,-52(fp)
		IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_MASK) >> 
		ALTERA_MSGDMA_CSR_WRITE_FILL_LEVEL_OFFSET;
    alt_u32 error = ALTERA_MSGDMA_CSR_STOPPED_ON_ERROR_MASK | 
81144920:	00807804 	movi	r2,480
81144924:	e0bff615 	stw	r2,-40(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81144928:	00001906 	br	81144990 <alt_msgdma_descriptor_sync_transfer+0xd4>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
    { 
        alt_busy_sleep(1); /* delay 1us */
8114492c:	01000044 	movi	r4,1
81144930:	113227c0 	call	8113227c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144934:	e0bff10b 	ldhu	r2,-60(fp)
81144938:	1084e230 	cmpltui	r2,r2,5000
8114493c:	1000051e 	bne	r2,zero,81144954 <alt_msgdma_descriptor_sync_transfer+0x98>
        {
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
81144940:	01204574 	movhi	r4,33045
81144944:	2132b304 	addi	r4,r4,-13620
81144948:	11469d00 	call	811469d0 <alt_printf>
				" for storing descriptor\n");
            return -ETIME;
8114494c:	00bff084 	movi	r2,-62
81144950:	0000d706 	br	81144cb0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;  
81144954:	e0bff10b 	ldhu	r2,-60(fp)
81144958:	10800044 	addi	r2,r2,1
8114495c:	e0bff10d 	sth	r2,-60(fp)
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81144960:	e0bffd17 	ldw	r2,-12(fp)
81144964:	10800317 	ldw	r2,12(r2)
81144968:	10800204 	addi	r2,r2,8
8114496c:	10800037 	ldwio	r2,0(r2)
            alt_printf("time out after 5 msec while waiting free FIFO buffer"
				" for storing descriptor\n");
            return -ETIME;
        }
        counter++;  
        fifo_read_fill_level = (
81144970:	10bfffcc 	andi	r2,r2,65535
81144974:	e0bff215 	stw	r2,-56(fp)
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
81144978:	e0bffd17 	ldw	r2,-12(fp)
8114497c:	10800317 	ldw	r2,12(r2)
81144980:	10800204 	addi	r2,r2,8
81144984:	10800037 	ldwio	r2,0(r2)
        counter++;  
        fifo_read_fill_level = (
			IORD_ALTERA_MSGDMA_CSR_DESCRIPTOR_FILL_LEVEL(dev->csr_base) & 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_MASK) >> 
			ALTERA_MSGDMA_CSR_READ_FILL_LEVEL_OFFSET;
        fifo_write_fill_level = (
81144988:	1004d43a 	srli	r2,r2,16
8114498c:	e0bff315 	stw	r2,-52(fp)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
81144990:	e0bffd17 	ldw	r2,-12(fp)
81144994:	10800917 	ldw	r2,36(r2)
81144998:	e0fff317 	ldw	r3,-52(fp)
8114499c:	18bfe32e 	bgeu	r3,r2,8114492c <__reset+0xfb12492c>
    	(dev->descriptor_fifo_depth <= fifo_read_fill_level))
811449a0:	e0bffd17 	ldw	r2,-12(fp)
811449a4:	10800917 	ldw	r2,36(r2)
                    ALTERA_MSGDMA_CSR_STOPPED_ON_EARLY_TERMINATION_MASK |
                    ALTERA_MSGDMA_CSR_STOP_STATE_MASK |
                    ALTERA_MSGDMA_CSR_RESET_STATE_MASK;
    
    /* Wait for available FIFO buffer to store new descriptor*/
    while ((dev->descriptor_fifo_depth <= fifo_write_fill_level) || 
811449a8:	e0fff217 	ldw	r3,-56(fp)
811449ac:	18bfdf2e 	bgeu	r3,r2,8114492c <__reset+0xfb12492c>

     /*
     * When running in a multi threaded environment, obtain the "regs_lock"
     * semaphore. This ensures that accessing registers is thread-safe.
     */
	ALT_SEM_PEND (dev->regs_lock, 0);
811449b0:	e0bffd17 	ldw	r2,-12(fp)
811449b4:	10801817 	ldw	r2,96(r2)
811449b8:	e0bff815 	stw	r2,-32(fp)
811449bc:	e03ffc0d 	sth	zero,-16(fp)
811449c0:	e0bffc0b 	ldhu	r2,-16(fp)
811449c4:	e0fffc84 	addi	r3,fp,-14
811449c8:	180d883a 	mov	r6,r3
811449cc:	100b883a 	mov	r5,r2
811449d0:	e13ff817 	ldw	r4,-32(fp)
811449d4:	113aaf40 	call	8113aaf4 <OSSemPend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811449d8:	0005303a 	rdctl	r2,status
811449dc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811449e0:	e0fffb17 	ldw	r3,-20(fp)
811449e4:	00bfff84 	movi	r2,-2
811449e8:	1884703a 	and	r2,r3,r2
811449ec:	1001703a 	wrctl	status,r2
  
  return context;
811449f0:	e0bffb17 	ldw	r2,-20(fp)
    
    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();
811449f4:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
811449f8:	e0bffd17 	ldw	r2,-12(fp)
811449fc:	10800317 	ldw	r2,12(r2)
81144a00:	10800104 	addi	r2,r2,4
81144a04:	00c00804 	movi	r3,32
81144a08:	10c00035 	stwio	r3,0(r2)
        ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81144a0c:	e0bffd17 	ldw	r2,-12(fp)
81144a10:	10800317 	ldw	r2,12(r2)
81144a14:	e0fffd17 	ldw	r3,-12(fp)
81144a18:	18c00317 	ldw	r3,12(r3)
81144a1c:	18c00037 	ldwio	r3,0(r3)
81144a20:	10c00035 	stwio	r3,0(r2)
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81144a24:	e0bffe17 	ldw	r2,-8(fp)
81144a28:	10001f26 	beq	r2,zero,81144aa8 <alt_msgdma_descriptor_sync_transfer+0x1ec>
81144a2c:	e0bfff17 	ldw	r2,-4(fp)
81144a30:	10001d1e 	bne	r2,zero,81144aa8 <alt_msgdma_descriptor_sync_transfer+0x1ec>
    {
        counter = 0; /* reset counter */
81144a34:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81144a38:	00001106 	br	81144a80 <alt_msgdma_descriptor_sync_transfer+0x1c4>
			dev->csr_base, dev->descriptor_base, standard_desc))
        {     
            alt_busy_sleep(1); /* delay 1us */
81144a3c:	01000044 	movi	r4,1
81144a40:	113227c0 	call	8113227c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144a44:	e0bff10b 	ldhu	r2,-60(fp)
81144a48:	1084e230 	cmpltui	r2,r2,5000
81144a4c:	1000091e 	bne	r2,zero,81144a74 <alt_msgdma_descriptor_sync_transfer+0x1b8>
            {
                alt_printf("time out after 5 msec while writing standard" 
81144a50:	01204574 	movhi	r4,33045
81144a54:	2132c704 	addi	r4,r4,-13540
81144a58:	11469d00 	call	811469d0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81144a5c:	e0bffd17 	ldw	r2,-12(fp)
81144a60:	10801817 	ldw	r2,96(r2)
81144a64:	1009883a 	mov	r4,r2
81144a68:	113ae7c0 	call	8113ae7c <OSSemPost>
				
                return -ETIME;
81144a6c:	00bff084 	movi	r2,-62
81144a70:	00008f06 	br	81144cb0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;    
81144a74:	e0bff10b 	ldhu	r2,-60(fp)
81144a78:	10800044 	addi	r2,r2,1
81144a7c:	e0bff10d 	sth	r2,-60(fp)
    if (NULL != standard_desc && NULL == extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_standard_descriptor (
81144a80:	e0bffd17 	ldw	r2,-12(fp)
81144a84:	10c00317 	ldw	r3,12(r2)
81144a88:	e0bffd17 	ldw	r2,-12(fp)
81144a8c:	10800417 	ldw	r2,16(r2)
81144a90:	e1bffe17 	ldw	r6,-8(fp)
81144a94:	100b883a 	mov	r5,r2
81144a98:	1809883a 	mov	r4,r3
81144a9c:	11440300 	call	81144030 <alt_msgdma_write_standard_descriptor>
81144aa0:	103fe61e 	bne	r2,zero,81144a3c <__reset+0xfb124a3c>
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
		dev->csr_base, 
		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));

    if (NULL != standard_desc && NULL == extended_desc)
81144aa4:	00002706 	br	81144b44 <alt_msgdma_descriptor_sync_transfer+0x288>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81144aa8:	e0bffe17 	ldw	r2,-8(fp)
81144aac:	10001f1e 	bne	r2,zero,81144b2c <alt_msgdma_descriptor_sync_transfer+0x270>
81144ab0:	e0bfff17 	ldw	r2,-4(fp)
81144ab4:	10001d26 	beq	r2,zero,81144b2c <alt_msgdma_descriptor_sync_transfer+0x270>
    {
        counter = 0; /* reset counter */
81144ab8:	e03ff10d 	sth	zero,-60(fp)
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81144abc:	00001106 	br	81144b04 <alt_msgdma_descriptor_sync_transfer+0x248>
			dev->csr_base, dev->descriptor_base, extended_desc))
        {
            alt_busy_sleep(1); /* delay 1us */
81144ac0:	01000044 	movi	r4,1
81144ac4:	113227c0 	call	8113227c <alt_busy_sleep>
            if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144ac8:	e0bff10b 	ldhu	r2,-60(fp)
81144acc:	1084e230 	cmpltui	r2,r2,5000
81144ad0:	1000091e 	bne	r2,zero,81144af8 <alt_msgdma_descriptor_sync_transfer+0x23c>
            {
                alt_printf("time out after 5 msec while writing extended" 
81144ad4:	01204574 	movhi	r4,33045
81144ad8:	2132d804 	addi	r4,r4,-13472
81144adc:	11469d00 	call	811469d0 <alt_printf>
				/*
				* Now that access to the registers is complete, release the 
				* registers semaphore so that other threads can access the 
				* registers.
				*/
				ALT_SEM_POST (dev->regs_lock);
81144ae0:	e0bffd17 	ldw	r2,-12(fp)
81144ae4:	10801817 	ldw	r2,96(r2)
81144ae8:	1009883a 	mov	r4,r2
81144aec:	113ae7c0 	call	8113ae7c <OSSemPost>
				
                return -ETIME;
81144af0:	00bff084 	movi	r2,-62
81144af4:	00006e06 	br	81144cb0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
            }
            counter++;
81144af8:	e0bff10b 	ldhu	r2,-60(fp)
81144afc:	10800044 	addi	r2,r2,1
81144b00:	e0bff10d 	sth	r2,-60(fp)
    else if (NULL == standard_desc && NULL != extended_desc)
    {
        counter = 0; /* reset counter */
        /*writing descriptor structure to the dispatcher, wait until descriptor 
	  	write is succeed*/
        while(0 != alt_msgdma_write_extended_descriptor (
81144b04:	e0bffd17 	ldw	r2,-12(fp)
81144b08:	10c00317 	ldw	r3,12(r2)
81144b0c:	e0bffd17 	ldw	r2,-12(fp)
81144b10:	10800417 	ldw	r2,16(r2)
81144b14:	e1bfff17 	ldw	r6,-4(fp)
81144b18:	100b883a 	mov	r5,r2
81144b1c:	1809883a 	mov	r4,r3
81144b20:	11440cc0 	call	811440cc <alt_msgdma_write_extended_descriptor>
81144b24:	103fe61e 	bne	r2,zero,81144ac0 <__reset+0xfb124ac0>
                return -ETIME;
            }
            counter++;    
        }
    }
    else if (NULL == standard_desc && NULL != extended_desc)
81144b28:	00000606 	br	81144b44 <alt_msgdma_descriptor_sync_transfer+0x288>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81144b2c:	e0bffd17 	ldw	r2,-12(fp)
81144b30:	10801817 	ldw	r2,96(r2)
81144b34:	1009883a 	mov	r4,r2
81144b38:	113ae7c0 	call	8113ae7c <OSSemPost>
		
        /* operation not permitted due to descriptor type conflict */
        return -EPERM; 
81144b3c:	00bfffc4 	movi	r2,-1
81144b40:	00005b06 	br	81144cb0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    * Set up msgdma controller to:
    * - Disable interrupt generation
    * - Run once a valid descriptor is written to controller
    * - Stop on an error with any particular descriptor
    */
     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base,
81144b44:	e0bffd17 	ldw	r2,-12(fp)
81144b48:	10800317 	ldw	r2,12(r2)
81144b4c:	10800104 	addi	r2,r2,4
81144b50:	e0fffd17 	ldw	r3,-12(fp)
81144b54:	19000d17 	ldw	r4,52(r3)
81144b58:	00fff2c4 	movi	r3,-53
81144b5c:	20c6703a 	and	r3,r4,r3
81144b60:	18c00114 	ori	r3,r3,4
81144b64:	10c00035 	stwio	r3,0(r2)
81144b68:	e0bff517 	ldw	r2,-44(fp)
81144b6c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144b70:	e0bff717 	ldw	r2,-36(fp)
81144b74:	1001703a 	wrctl	status,r2
		(~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) &
		(~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK)) ;
	 
	alt_irq_enable_all(context);
     
    counter = 0; /* reset counter */ 
81144b78:	e03ff10d 	sth	zero,-60(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81144b7c:	e0bffd17 	ldw	r2,-12(fp)
81144b80:	10800317 	ldw	r2,12(r2)
81144b84:	10800037 	ldwio	r2,0(r2)
81144b88:	e0bff015 	stw	r2,-64(fp)
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81144b8c:	00001506 	br	81144be4 <alt_msgdma_descriptor_sync_transfer+0x328>
    {
        alt_busy_sleep(1); /* delay 1us */
81144b90:	01000044 	movi	r4,1
81144b94:	113227c0 	call	8113227c <alt_busy_sleep>
        if(5000 <= counter) /* time_out if waiting longer than 5 msec */
81144b98:	e0bff10b 	ldhu	r2,-60(fp)
81144b9c:	1084e230 	cmpltui	r2,r2,5000
81144ba0:	1000091e 	bne	r2,zero,81144bc8 <alt_msgdma_descriptor_sync_transfer+0x30c>
        {
            alt_printf("time out after 5 msec while waiting for any pending" 
81144ba4:	01204574 	movhi	r4,33045
81144ba8:	2132e904 	addi	r4,r4,-13404
81144bac:	11469d00 	call	811469d0 <alt_printf>
			
			/*
			* Now that access to the registers is complete, release the registers
			* semaphore so that other threads can access the registers.
			*/
			ALT_SEM_POST (dev->regs_lock);
81144bb0:	e0bffd17 	ldw	r2,-12(fp)
81144bb4:	10801817 	ldw	r2,96(r2)
81144bb8:	1009883a 	mov	r4,r2
81144bbc:	113ae7c0 	call	8113ae7c <OSSemPost>
			
            return -ETIME;
81144bc0:	00bff084 	movi	r2,-62
81144bc4:	00003a06 	br	81144cb0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
        }
        counter++;
81144bc8:	e0bff10b 	ldhu	r2,-60(fp)
81144bcc:	10800044 	addi	r2,r2,1
81144bd0:	e0bff10d 	sth	r2,-60(fp)
        csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
81144bd4:	e0bffd17 	ldw	r2,-12(fp)
81144bd8:	10800317 	ldw	r2,12(r2)
81144bdc:	10800037 	ldwio	r2,0(r2)
81144be0:	e0bff015 	stw	r2,-64(fp)
	
	csr_status = IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base);
	
    /* Wait for any pending transfers to complete or checking any errors or 
    conditions causing descriptor to stop dispatching */
    while (!(csr_status & error) && (csr_status & ALTERA_MSGDMA_CSR_BUSY_MASK))
81144be4:	e0fff017 	ldw	r3,-64(fp)
81144be8:	e0bff617 	ldw	r2,-40(fp)
81144bec:	1884703a 	and	r2,r3,r2
81144bf0:	1000031e 	bne	r2,zero,81144c00 <alt_msgdma_descriptor_sync_transfer+0x344>
81144bf4:	e0bff017 	ldw	r2,-64(fp)
81144bf8:	1080004c 	andi	r2,r2,1
81144bfc:	103fe41e 	bne	r2,zero,81144b90 <__reset+0xfb124b90>
    }
    

    /*Errors or conditions causing the dispatcher stopping issuing read/write 
      commands to masters*/
    if(0 != (csr_status & error))
81144c00:	e0fff017 	ldw	r3,-64(fp)
81144c04:	e0bff617 	ldw	r2,-40(fp)
81144c08:	1884703a 	and	r2,r3,r2
81144c0c:	10000626 	beq	r2,zero,81144c28 <alt_msgdma_descriptor_sync_transfer+0x36c>
    {
		/*
		* Now that access to the registers is complete, release the registers
		* semaphore so that other threads can access the registers.
		*/
		ALT_SEM_POST (dev->regs_lock);
81144c10:	e0bffd17 	ldw	r2,-12(fp)
81144c14:	10801817 	ldw	r2,96(r2)
81144c18:	1009883a 	mov	r4,r2
81144c1c:	113ae7c0 	call	8113ae7c <OSSemPost>
		
        return error;
81144c20:	e0bff617 	ldw	r2,-40(fp)
81144c24:	00002206 	br	81144cb0 <alt_msgdma_descriptor_sync_transfer+0x3f4>
    }

    /* Stop the msgdma dispatcher from issuing more descriptors to the
    read or write masters  */
    /* stop issuing more descriptors */
    control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base) | 
81144c28:	e0bffd17 	ldw	r2,-12(fp)
81144c2c:	10800317 	ldw	r2,12(r2)
81144c30:	10800104 	addi	r2,r2,4
81144c34:	10800037 	ldwio	r2,0(r2)
81144c38:	10800814 	ori	r2,r2,32
81144c3c:	e0bff415 	stw	r2,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81144c40:	0005303a 	rdctl	r2,status
81144c44:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81144c48:	e0fffa17 	ldw	r3,-24(fp)
81144c4c:	00bfff84 	movi	r2,-2
81144c50:	1884703a 	and	r2,r3,r2
81144c54:	1001703a 	wrctl	status,r2
  
  return context;
81144c58:	e0bffa17 	ldw	r2,-24(fp)
	ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
    /* making sure the read-modify-write below can't be pre-empted */
    context = alt_irq_disable_all();  
81144c5c:	e0bff515 	stw	r2,-44(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, control);
81144c60:	e0bffd17 	ldw	r2,-12(fp)
81144c64:	10800317 	ldw	r2,12(r2)
81144c68:	10800104 	addi	r2,r2,4
81144c6c:	e0fff417 	ldw	r3,-48(fp)
81144c70:	10c00035 	stwio	r3,0(r2)
    /*
    * Clear any (previous) status register information
    * that might occlude our error checking later.
    */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(
81144c74:	e0bffd17 	ldw	r2,-12(fp)
81144c78:	10800317 	ldw	r2,12(r2)
81144c7c:	e0fffd17 	ldw	r3,-12(fp)
81144c80:	18c00317 	ldw	r3,12(r3)
81144c84:	18c00037 	ldwio	r3,0(r3)
81144c88:	10c00035 	stwio	r3,0(r2)
81144c8c:	e0bff517 	ldw	r2,-44(fp)
81144c90:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81144c94:	e0bff917 	ldw	r2,-28(fp)
81144c98:	1001703a 	wrctl	status,r2

	/*
	* Now that access to the registers is complete, release the registers
	* semaphore so that other threads can access the registers.
	*/
    ALT_SEM_POST (dev->regs_lock);
81144c9c:	e0bffd17 	ldw	r2,-12(fp)
81144ca0:	10801817 	ldw	r2,96(r2)
81144ca4:	1009883a 	mov	r4,r2
81144ca8:	113ae7c0 	call	8113ae7c <OSSemPost>
    
    return 0;
81144cac:	0005883a 	mov	r2,zero

}
81144cb0:	e037883a 	mov	sp,fp
81144cb4:	dfc00117 	ldw	ra,4(sp)
81144cb8:	df000017 	ldw	fp,0(sp)
81144cbc:	dec00204 	addi	sp,sp,8
81144cc0:	f800283a 	ret

81144cc4 <alt_msgdma_construct_standard_st_to_mm_descriptor>:
 */
int alt_msgdma_construct_standard_st_to_mm_descriptor (
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *write_address, alt_u32 length, alt_u32 control)
{
81144cc4:	defff804 	addi	sp,sp,-32
81144cc8:	de00012e 	bgeu	sp,et,81144cd0 <alt_msgdma_construct_standard_st_to_mm_descriptor+0xc>
81144ccc:	003b68fa 	trap	3
81144cd0:	dfc00715 	stw	ra,28(sp)
81144cd4:	df000615 	stw	fp,24(sp)
81144cd8:	df000604 	addi	fp,sp,24
81144cdc:	e13ffc15 	stw	r4,-16(fp)
81144ce0:	e17ffd15 	stw	r5,-12(fp)
81144ce4:	e1bffe15 	stw	r6,-8(fp)
81144ce8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, NULL, 
81144cec:	e0800217 	ldw	r2,8(fp)
81144cf0:	d8800115 	stw	r2,4(sp)
81144cf4:	e0bfff17 	ldw	r2,-4(fp)
81144cf8:	d8800015 	stw	r2,0(sp)
81144cfc:	e1fffe17 	ldw	r7,-8(fp)
81144d00:	000d883a 	mov	r6,zero
81144d04:	e17ffd17 	ldw	r5,-12(fp)
81144d08:	e13ffc17 	ldw	r4,-16(fp)
81144d0c:	114438c0 	call	8114438c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81144d10:	e037883a 	mov	sp,fp
81144d14:	dfc00117 	ldw	ra,4(sp)
81144d18:	df000017 	ldw	fp,0(sp)
81144d1c:	dec00204 	addi	sp,sp,8
81144d20:	f800283a 	ret

81144d24 <alt_msgdma_construct_standard_mm_to_st_descriptor>:
    alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address,
	alt_u32 length,
	alt_u32 control)
{
81144d24:	defff804 	addi	sp,sp,-32
81144d28:	de00012e 	bgeu	sp,et,81144d30 <alt_msgdma_construct_standard_mm_to_st_descriptor+0xc>
81144d2c:	003b68fa 	trap	3
81144d30:	dfc00715 	stw	ra,28(sp)
81144d34:	df000615 	stw	fp,24(sp)
81144d38:	df000604 	addi	fp,sp,24
81144d3c:	e13ffc15 	stw	r4,-16(fp)
81144d40:	e17ffd15 	stw	r5,-12(fp)
81144d44:	e1bffe15 	stw	r6,-8(fp)
81144d48:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81144d4c:	e0800217 	ldw	r2,8(fp)
81144d50:	d8800115 	stw	r2,4(sp)
81144d54:	e0bfff17 	ldw	r2,-4(fp)
81144d58:	d8800015 	stw	r2,0(sp)
81144d5c:	000f883a 	mov	r7,zero
81144d60:	e1bffe17 	ldw	r6,-8(fp)
81144d64:	e17ffd17 	ldw	r5,-12(fp)
81144d68:	e13ffc17 	ldw	r4,-16(fp)
81144d6c:	114438c0 	call	8114438c <alt_msgdma_construct_standard_descriptor>
            NULL, length, control);

}
81144d70:	e037883a 	mov	sp,fp
81144d74:	dfc00117 	ldw	ra,4(sp)
81144d78:	df000017 	ldw	fp,0(sp)
81144d7c:	dec00204 	addi	sp,sp,8
81144d80:	f800283a 	ret

81144d84 <alt_msgdma_construct_standard_mm_to_mm_descriptor>:
	alt_msgdma_standard_descriptor *descriptor,
	alt_u32 *read_address, 
	alt_u32 *write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81144d84:	defff804 	addi	sp,sp,-32
81144d88:	de00012e 	bgeu	sp,et,81144d90 <alt_msgdma_construct_standard_mm_to_mm_descriptor+0xc>
81144d8c:	003b68fa 	trap	3
81144d90:	dfc00715 	stw	ra,28(sp)
81144d94:	df000615 	stw	fp,24(sp)
81144d98:	df000604 	addi	fp,sp,24
81144d9c:	e13ffc15 	stw	r4,-16(fp)
81144da0:	e17ffd15 	stw	r5,-12(fp)
81144da4:	e1bffe15 	stw	r6,-8(fp)
81144da8:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_standard_descriptor(dev, descriptor, read_address, 
81144dac:	e0800317 	ldw	r2,12(fp)
81144db0:	d8800115 	stw	r2,4(sp)
81144db4:	e0800217 	ldw	r2,8(fp)
81144db8:	d8800015 	stw	r2,0(sp)
81144dbc:	e1ffff17 	ldw	r7,-4(fp)
81144dc0:	e1bffe17 	ldw	r6,-8(fp)
81144dc4:	e17ffd17 	ldw	r5,-12(fp)
81144dc8:	e13ffc17 	ldw	r4,-16(fp)
81144dcc:	114438c0 	call	8114438c <alt_msgdma_construct_standard_descriptor>
            write_address, length, control);
}
81144dd0:	e037883a 	mov	sp,fp
81144dd4:	dfc00117 	ldw	ra,4(sp)
81144dd8:	df000017 	ldw	fp,0(sp)
81144ddc:	dec00204 	addi	sp,sp,8
81144de0:	f800283a 	ret

81144de4 <alt_msgdma_construct_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 write_burst_count, 
	alt_u16 write_stride)
{
81144de4:	defff004 	addi	sp,sp,-64
81144de8:	de00012e 	bgeu	sp,et,81144df0 <alt_msgdma_construct_extended_st_to_mm_descriptor+0xc>
81144dec:	003b68fa 	trap	3
81144df0:	dfc00f15 	stw	ra,60(sp)
81144df4:	df000e15 	stw	fp,56(sp)
81144df8:	df000e04 	addi	fp,sp,56
81144dfc:	e13ff915 	stw	r4,-28(fp)
81144e00:	e17ffa15 	stw	r5,-24(fp)
81144e04:	e1bffb15 	stw	r6,-20(fp)
81144e08:	e1fffc15 	stw	r7,-16(fp)
81144e0c:	e1000317 	ldw	r4,12(fp)
81144e10:	e0c00417 	ldw	r3,16(fp)
81144e14:	e0800517 	ldw	r2,20(fp)
81144e18:	e13ffd0d 	sth	r4,-12(fp)
81144e1c:	e0fffe05 	stb	r3,-8(fp)
81144e20:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81144e24:	e0bffd0b 	ldhu	r2,-12(fp)
81144e28:	e0fffe03 	ldbu	r3,-8(fp)
81144e2c:	e13fff0b 	ldhu	r4,-4(fp)
81144e30:	d9000615 	stw	r4,24(sp)
81144e34:	d8000515 	stw	zero,20(sp)
81144e38:	d8c00415 	stw	r3,16(sp)
81144e3c:	d8000315 	stw	zero,12(sp)
81144e40:	d8800215 	stw	r2,8(sp)
81144e44:	e0800217 	ldw	r2,8(fp)
81144e48:	d8800115 	stw	r2,4(sp)
81144e4c:	e0bffc17 	ldw	r2,-16(fp)
81144e50:	d8800015 	stw	r2,0(sp)
81144e54:	e1fffb17 	ldw	r7,-20(fp)
81144e58:	000d883a 	mov	r6,zero
81144e5c:	e17ffa17 	ldw	r5,-24(fp)
81144e60:	e13ff917 	ldw	r4,-28(fp)
81144e64:	11444200 	call	81144420 <alt_msgdma_construct_extended_descriptor>
            NULL, write_address, length, control, sequence_number, 0, 
            write_burst_count, 0, write_stride);
}
81144e68:	e037883a 	mov	sp,fp
81144e6c:	dfc00117 	ldw	ra,4(sp)
81144e70:	df000017 	ldw	fp,0(sp)
81144e74:	dec00204 	addi	sp,sp,8
81144e78:	f800283a 	ret

81144e7c <alt_msgdma_construct_extended_mm_to_st_descriptor>:
	alt_u32 length,
	alt_u32 control,
	alt_u16 sequence_number,
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
81144e7c:	defff004 	addi	sp,sp,-64
81144e80:	de00012e 	bgeu	sp,et,81144e88 <alt_msgdma_construct_extended_mm_to_st_descriptor+0xc>
81144e84:	003b68fa 	trap	3
81144e88:	dfc00f15 	stw	ra,60(sp)
81144e8c:	df000e15 	stw	fp,56(sp)
81144e90:	df000e04 	addi	fp,sp,56
81144e94:	e13ff915 	stw	r4,-28(fp)
81144e98:	e17ffa15 	stw	r5,-24(fp)
81144e9c:	e1bffb15 	stw	r6,-20(fp)
81144ea0:	e1fffc15 	stw	r7,-16(fp)
81144ea4:	e1000317 	ldw	r4,12(fp)
81144ea8:	e0c00417 	ldw	r3,16(fp)
81144eac:	e0800517 	ldw	r2,20(fp)
81144eb0:	e13ffd0d 	sth	r4,-12(fp)
81144eb4:	e0fffe05 	stb	r3,-8(fp)
81144eb8:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, read_address, 
81144ebc:	e0bffd0b 	ldhu	r2,-12(fp)
81144ec0:	e0fffe03 	ldbu	r3,-8(fp)
81144ec4:	e13fff0b 	ldhu	r4,-4(fp)
81144ec8:	d8000615 	stw	zero,24(sp)
81144ecc:	d9000515 	stw	r4,20(sp)
81144ed0:	d8000415 	stw	zero,16(sp)
81144ed4:	d8c00315 	stw	r3,12(sp)
81144ed8:	d8800215 	stw	r2,8(sp)
81144edc:	e0800217 	ldw	r2,8(fp)
81144ee0:	d8800115 	stw	r2,4(sp)
81144ee4:	e0bffc17 	ldw	r2,-16(fp)
81144ee8:	d8800015 	stw	r2,0(sp)
81144eec:	000f883a 	mov	r7,zero
81144ef0:	e1bffb17 	ldw	r6,-20(fp)
81144ef4:	e17ffa17 	ldw	r5,-24(fp)
81144ef8:	e13ff917 	ldw	r4,-28(fp)
81144efc:	11444200 	call	81144420 <alt_msgdma_construct_extended_descriptor>
            NULL, length, control, sequence_number, read_burst_count, 0, 
            read_stride, 0);

}
81144f00:	e037883a 	mov	sp,fp
81144f04:	dfc00117 	ldw	ra,4(sp)
81144f08:	df000017 	ldw	fp,0(sp)
81144f0c:	dec00204 	addi	sp,sp,8
81144f10:	f800283a 	ret

81144f14 <alt_msgdma_construct_extended_mm_to_mm_descriptor>:
    alt_u16 sequence_number, 
    alt_u8 read_burst_count, 
    alt_u8 write_burst_count,
    alt_u16 read_stride, 
    alt_u16 write_stride)
{
81144f14:	deffee04 	addi	sp,sp,-72
81144f18:	de00012e 	bgeu	sp,et,81144f20 <alt_msgdma_construct_extended_mm_to_mm_descriptor+0xc>
81144f1c:	003b68fa 	trap	3
81144f20:	dfc01115 	stw	ra,68(sp)
81144f24:	df001015 	stw	fp,64(sp)
81144f28:	df001004 	addi	fp,sp,64
81144f2c:	e13ff715 	stw	r4,-36(fp)
81144f30:	e17ff815 	stw	r5,-32(fp)
81144f34:	e1bff915 	stw	r6,-28(fp)
81144f38:	e1fffa15 	stw	r7,-24(fp)
81144f3c:	e1800417 	ldw	r6,16(fp)
81144f40:	e1400517 	ldw	r5,20(fp)
81144f44:	e1000617 	ldw	r4,24(fp)
81144f48:	e0c00717 	ldw	r3,28(fp)
81144f4c:	e0800817 	ldw	r2,32(fp)
81144f50:	e1bffb0d 	sth	r6,-20(fp)
81144f54:	e17ffc05 	stb	r5,-16(fp)
81144f58:	e13ffd05 	stb	r4,-12(fp)
81144f5c:	e0fffe0d 	sth	r3,-8(fp)
81144f60:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_extended_descriptor(dev, descriptor, 
81144f64:	e0bffb0b 	ldhu	r2,-20(fp)
81144f68:	e0fffc03 	ldbu	r3,-16(fp)
81144f6c:	e13ffd03 	ldbu	r4,-12(fp)
81144f70:	e17ffe0b 	ldhu	r5,-8(fp)
81144f74:	e1bfff0b 	ldhu	r6,-4(fp)
81144f78:	d9800615 	stw	r6,24(sp)
81144f7c:	d9400515 	stw	r5,20(sp)
81144f80:	d9000415 	stw	r4,16(sp)
81144f84:	d8c00315 	stw	r3,12(sp)
81144f88:	d8800215 	stw	r2,8(sp)
81144f8c:	e0800317 	ldw	r2,12(fp)
81144f90:	d8800115 	stw	r2,4(sp)
81144f94:	e0800217 	ldw	r2,8(fp)
81144f98:	d8800015 	stw	r2,0(sp)
81144f9c:	e1fffa17 	ldw	r7,-24(fp)
81144fa0:	e1bff917 	ldw	r6,-28(fp)
81144fa4:	e17ff817 	ldw	r5,-32(fp)
81144fa8:	e13ff717 	ldw	r4,-36(fp)
81144fac:	11444200 	call	81144420 <alt_msgdma_construct_extended_descriptor>
            read_address, write_address, length, control, sequence_number, 
            read_burst_count, write_burst_count, read_stride, write_stride);

}
81144fb0:	e037883a 	mov	sp,fp
81144fb4:	dfc00117 	ldw	ra,4(sp)
81144fb8:	df000017 	ldw	fp,0(sp)
81144fbc:	dec00204 	addi	sp,sp,8
81144fc0:	f800283a 	ret

81144fc4 <alt_msgdma_construct_prefetcher_standard_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
81144fc4:	defffb04 	addi	sp,sp,-20
81144fc8:	de00012e 	bgeu	sp,et,81144fd0 <alt_msgdma_construct_prefetcher_standard_descriptor+0xc>
81144fcc:	003b68fa 	trap	3
81144fd0:	df000415 	stw	fp,16(sp)
81144fd4:	df000404 	addi	fp,sp,16
81144fd8:	e13ffc15 	stw	r4,-16(fp)
81144fdc:	e17ffd15 	stw	r5,-12(fp)
81144fe0:	e1bffe15 	stw	r6,-8(fp)
81144fe4:	e1ffff15 	stw	r7,-4(fp)
    if(dev->max_byte < length ||
81144fe8:	e0bffc17 	ldw	r2,-16(fp)
81144fec:	10c01217 	ldw	r3,72(r2)
81144ff0:	e0800117 	ldw	r2,4(fp)
81144ff4:	18800436 	bltu	r3,r2,81145008 <alt_msgdma_construct_prefetcher_standard_descriptor+0x44>
       dev->enhanced_features != 0
81144ff8:	e0bffc17 	ldw	r2,-16(fp)
81144ffc:	10801703 	ldbu	r2,92(r2)
	alt_u32 read_address, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
    if(dev->max_byte < length ||
81145000:	10803fcc 	andi	r2,r2,255
81145004:	10000226 	beq	r2,zero,81145010 <alt_msgdma_construct_prefetcher_standard_descriptor+0x4c>
       dev->enhanced_features != 0
      )
    {
        return -EINVAL;
81145008:	00bffa84 	movi	r2,-22
8114500c:	00001406 	br	81145060 <alt_msgdma_construct_prefetcher_standard_descriptor+0x9c>
    }
    descriptor->read_address = read_address;
81145010:	e0bffd17 	ldw	r2,-12(fp)
81145014:	e0fffe17 	ldw	r3,-8(fp)
81145018:	10c00015 	stw	r3,0(r2)
    descriptor->write_address = write_address;
8114501c:	e0bffd17 	ldw	r2,-12(fp)
81145020:	e0ffff17 	ldw	r3,-4(fp)
81145024:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81145028:	e0bffd17 	ldw	r2,-12(fp)
8114502c:	e0c00117 	ldw	r3,4(fp)
81145030:	10c00215 	stw	r3,8(r2)
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
81145034:	e0fffd17 	ldw	r3,-12(fp)
81145038:	e0bffd17 	ldw	r2,-12(fp)
8114503c:	10c00315 	stw	r3,12(r2)
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
81145040:	e0c00217 	ldw	r3,8(fp)
81145044:	00900034 	movhi	r2,16384
81145048:	10bfffc4 	addi	r2,r2,-1
8114504c:	1884703a 	and	r2,r3,r2
81145050:	10e00034 	orhi	r3,r2,32768
    descriptor->transfer_length = length;
    /* have descriptor point to itself for park_mode */
    descriptor->next_desc_ptr = (alt_u32)descriptor;  
    
    /* clear control own_by_hw bit field (SW owns this descriptor)*/
    descriptor->control = (control 
81145054:	e0bffd17 	ldw	r2,-12(fp)
81145058:	10c00715 	stw	r3,28(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
    
    return 0;
8114505c:	0005883a 	mov	r2,zero
}
81145060:	e037883a 	mov	sp,fp
81145064:	df000017 	ldw	fp,0(sp)
81145068:	dec00104 	addi	sp,sp,4
8114506c:	f800283a 	ret

81145070 <alt_msgdma_construct_prefetcher_extended_descriptor>:
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u8 write_burst_count,
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81145070:	defff404 	addi	sp,sp,-48
81145074:	de00012e 	bgeu	sp,et,8114507c <alt_msgdma_construct_prefetcher_extended_descriptor+0xc>
81145078:	003b68fa 	trap	3
8114507c:	df000b15 	stw	fp,44(sp)
81145080:	df000b04 	addi	fp,sp,44
81145084:	e13ff715 	stw	r4,-36(fp)
81145088:	e17ff815 	stw	r5,-32(fp)
8114508c:	e1bff915 	stw	r6,-28(fp)
81145090:	e1fffa15 	stw	r7,-24(fp)
81145094:	e1800517 	ldw	r6,20(fp)
81145098:	e1400617 	ldw	r5,24(fp)
8114509c:	e1000717 	ldw	r4,28(fp)
811450a0:	e0c00817 	ldw	r3,32(fp)
811450a4:	e0800917 	ldw	r2,36(fp)
811450a8:	e1bffb0d 	sth	r6,-20(fp)
811450ac:	e17ffc05 	stb	r5,-16(fp)
811450b0:	e13ffd05 	stb	r4,-12(fp)
811450b4:	e0fffe0d 	sth	r3,-8(fp)
811450b8:	e0bfff0d 	sth	r2,-4(fp)
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811450bc:	e0bff717 	ldw	r2,-36(fp)
811450c0:	10c01217 	ldw	r3,72(r2)
811450c4:	e0800317 	ldw	r2,12(fp)
811450c8:	18801936 	bltu	r3,r2,81145130 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
811450cc:	e13ff717 	ldw	r4,-36(fp)
811450d0:	20801317 	ldw	r2,76(r4)
811450d4:	20c01417 	ldw	r3,80(r4)
811450d8:	e13ffe0b 	ldhu	r4,-8(fp)
811450dc:	213fffcc 	andi	r4,r4,65535
811450e0:	2015883a 	mov	r10,r4
811450e4:	0017883a 	mov	r11,zero
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
811450e8:	1ac01136 	bltu	r3,r11,81145130 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
811450ec:	58c0011e 	bne	r11,r3,811450f4 <alt_msgdma_construct_prefetcher_extended_descriptor+0x84>
811450f0:	12800f36 	bltu	r2,r10,81145130 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
811450f4:	e13ff717 	ldw	r4,-36(fp)
811450f8:	20801317 	ldw	r2,76(r4)
811450fc:	20c01417 	ldw	r3,80(r4)
81145100:	e13fff0b 	ldhu	r4,-4(fp)
81145104:	213fffcc 	andi	r4,r4,65535
81145108:	2011883a 	mov	r8,r4
8114510c:	0013883a 	mov	r9,zero
	alt_u16 write_stride)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
81145110:	1a400736 	bltu	r3,r9,81145130 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
81145114:	48c0011e 	bne	r9,r3,8114511c <alt_msgdma_construct_prefetcher_extended_descriptor+0xac>
81145118:	12000536 	bltu	r2,r8,81145130 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc0>
       dev->max_stride < write_stride ||
       dev->enhanced_features != 1 
8114511c:	e0bff717 	ldw	r2,-36(fp)
81145120:	10801703 	ldbu	r2,92(r2)
{
	msgdma_addr64 node_addr;
	
	if(dev->max_byte < length ||
       dev->max_stride < read_stride ||
       dev->max_stride < write_stride ||
81145124:	10803fcc 	andi	r2,r2,255
81145128:	10800060 	cmpeqi	r2,r2,1
8114512c:	1000021e 	bne	r2,zero,81145138 <alt_msgdma_construct_prefetcher_extended_descriptor+0xc8>
       dev->enhanced_features != 1 
      )
    {
        return -EINVAL;
81145130:	00bffa84 	movi	r2,-22
81145134:	00003106 	br	811451fc <alt_msgdma_construct_prefetcher_extended_descriptor+0x18c>
    }
    
    descriptor->read_address_high = read_address_high;
81145138:	e0bff817 	ldw	r2,-32(fp)
8114513c:	e0fff917 	ldw	r3,-28(fp)
81145140:	10c00915 	stw	r3,36(r2)
    descriptor->read_address_low = read_address_low;
81145144:	e0bff817 	ldw	r2,-32(fp)
81145148:	e0fffa17 	ldw	r3,-24(fp)
8114514c:	10c00015 	stw	r3,0(r2)
    descriptor->write_address_high = write_address_high;
81145150:	e0bff817 	ldw	r2,-32(fp)
81145154:	e0c00117 	ldw	r3,4(fp)
81145158:	10c00a15 	stw	r3,40(r2)
    descriptor->write_address_low = write_address_low;
8114515c:	e0bff817 	ldw	r2,-32(fp)
81145160:	e0c00217 	ldw	r3,8(fp)
81145164:	10c00115 	stw	r3,4(r2)
    descriptor->transfer_length = length;
81145168:	e0bff817 	ldw	r2,-32(fp)
8114516c:	e0c00317 	ldw	r3,12(fp)
81145170:	10c00215 	stw	r3,8(r2)
    descriptor->sequence_number = sequence_number;
81145174:	e0bff817 	ldw	r2,-32(fp)
81145178:	e0fffb0b 	ldhu	r3,-20(fp)
8114517c:	10c0070d 	sth	r3,28(r2)
    descriptor->read_burst_count = read_burst_count;
81145180:	e0bff817 	ldw	r2,-32(fp)
81145184:	e0fffc03 	ldbu	r3,-16(fp)
81145188:	10c00785 	stb	r3,30(r2)
    descriptor->write_burst_count = write_burst_count;
8114518c:	e0bff817 	ldw	r2,-32(fp)
81145190:	e0fffd03 	ldbu	r3,-12(fp)
81145194:	10c007c5 	stb	r3,31(r2)
    descriptor->read_stride = read_stride;
81145198:	e0bff817 	ldw	r2,-32(fp)
8114519c:	e0fffe0b 	ldhu	r3,-8(fp)
811451a0:	10c0080d 	sth	r3,32(r2)
    descriptor->write_stride = write_stride;
811451a4:	e0bff817 	ldw	r2,-32(fp)
811451a8:	e0ffff0b 	ldhu	r3,-4(fp)
811451ac:	10c0088d 	sth	r3,34(r2)
    /* have descriptor point to itself */
	node_addr.u64 = (uintptr_t)descriptor;
811451b0:	e0bff817 	ldw	r2,-32(fp)
811451b4:	1019883a 	mov	r12,r2
811451b8:	001b883a 	mov	r13,zero
811451bc:	e33ff515 	stw	r12,-44(fp)
811451c0:	e37ff615 	stw	r13,-40(fp)
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
811451c4:	e0fff517 	ldw	r3,-44(fp)
811451c8:	e0bff817 	ldw	r2,-32(fp)
811451cc:	10c00315 	stw	r3,12(r2)
    descriptor->next_desc_ptr_high = node_addr.u32[1];
811451d0:	e0fff617 	ldw	r3,-40(fp)
811451d4:	e0bff817 	ldw	r2,-32(fp)
811451d8:	10c00b15 	stw	r3,44(r2)
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;
811451dc:	e0c00417 	ldw	r3,16(fp)
811451e0:	00900034 	movhi	r2,16384
811451e4:	10bfffc4 	addi	r2,r2,-1
811451e8:	1884703a 	and	r2,r3,r2
811451ec:	10e00034 	orhi	r3,r2,32768
	node_addr.u64 = (uintptr_t)descriptor;
    descriptor->next_desc_ptr_low = node_addr.u32[0];  
    descriptor->next_desc_ptr_high = node_addr.u32[1];
    
    /* clear control own_by_hw bit field (SW still owns this descriptor). */
    descriptor->control = (control 
811451f0:	e0bff817 	ldw	r2,-32(fp)
811451f4:	10c00f15 	stw	r3,60(r2)
    		& ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_CLR_MASK) 
    		| ALTERA_MSGDMA_DESCRIPTOR_CONTROL_GO_MASK;

  return 0 ;
811451f8:	0005883a 	mov	r2,zero
}
811451fc:	e037883a 	mov	sp,fp
81145200:	df000017 	ldw	fp,0(sp)
81145204:	dec00104 	addi	sp,sp,4
81145208:	f800283a 	ret

8114520c <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor>:
	alt_msgdma_prefetcher_standard_descriptor *descriptor,
	alt_u32 read_address,
	alt_u32 write_address,
	alt_u32 length,
	alt_u32 control)
{
8114520c:	defff804 	addi	sp,sp,-32
81145210:	de00012e 	bgeu	sp,et,81145218 <alt_msgdma_construct_prefetcher_standard_mm_to_mm_descriptor+0xc>
81145214:	003b68fa 	trap	3
81145218:	dfc00715 	stw	ra,28(sp)
8114521c:	df000615 	stw	fp,24(sp)
81145220:	df000604 	addi	fp,sp,24
81145224:	e13ffc15 	stw	r4,-16(fp)
81145228:	e17ffd15 	stw	r5,-12(fp)
8114522c:	e1bffe15 	stw	r6,-8(fp)
81145230:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81145234:	e0800317 	ldw	r2,12(fp)
81145238:	d8800115 	stw	r2,4(sp)
8114523c:	e0800217 	ldw	r2,8(fp)
81145240:	d8800015 	stw	r2,0(sp)
81145244:	e1ffff17 	ldw	r7,-4(fp)
81145248:	e1bffe17 	ldw	r6,-8(fp)
8114524c:	e17ffd17 	ldw	r5,-12(fp)
81145250:	e13ffc17 	ldw	r4,-16(fp)
81145254:	1144fc40 	call	81144fc4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, write_address, length, control);
}
81145258:	e037883a 	mov	sp,fp
8114525c:	dfc00117 	ldw	ra,4(sp)
81145260:	df000017 	ldw	fp,0(sp)
81145264:	dec00204 	addi	sp,sp,8
81145268:	f800283a 	ret

8114526c <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 write_address, 
	alt_u32 length, 
	alt_u32 control)
{
8114526c:	defff804 	addi	sp,sp,-32
81145270:	de00012e 	bgeu	sp,et,81145278 <alt_msgdma_construct_prefetcher_standard_st_to_mm_descriptor+0xc>
81145274:	003b68fa 	trap	3
81145278:	dfc00715 	stw	ra,28(sp)
8114527c:	df000615 	stw	fp,24(sp)
81145280:	df000604 	addi	fp,sp,24
81145284:	e13ffc15 	stw	r4,-16(fp)
81145288:	e17ffd15 	stw	r5,-12(fp)
8114528c:	e1bffe15 	stw	r6,-8(fp)
81145290:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
81145294:	e0800217 	ldw	r2,8(fp)
81145298:	d8800115 	stw	r2,4(sp)
8114529c:	e0bfff17 	ldw	r2,-4(fp)
811452a0:	d8800015 	stw	r2,0(sp)
811452a4:	e1fffe17 	ldw	r7,-8(fp)
811452a8:	000d883a 	mov	r6,zero
811452ac:	e17ffd17 	ldw	r5,-12(fp)
811452b0:	e13ffc17 	ldw	r4,-16(fp)
811452b4:	1144fc40 	call	81144fc4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		0, write_address, length, control);
}
811452b8:	e037883a 	mov	sp,fp
811452bc:	dfc00117 	ldw	ra,4(sp)
811452c0:	df000017 	ldw	fp,0(sp)
811452c4:	dec00204 	addi	sp,sp,8
811452c8:	f800283a 	ret

811452cc <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor>:
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *descriptor, 
	alt_u32 read_address, 
	alt_u32 length, 
	alt_u32 control)
{
811452cc:	defff804 	addi	sp,sp,-32
811452d0:	de00012e 	bgeu	sp,et,811452d8 <alt_msgdma_construct_prefetcher_standard_mm_to_st_descriptor+0xc>
811452d4:	003b68fa 	trap	3
811452d8:	dfc00715 	stw	ra,28(sp)
811452dc:	df000615 	stw	fp,24(sp)
811452e0:	df000604 	addi	fp,sp,24
811452e4:	e13ffc15 	stw	r4,-16(fp)
811452e8:	e17ffd15 	stw	r5,-12(fp)
811452ec:	e1bffe15 	stw	r6,-8(fp)
811452f0:	e1ffff15 	stw	r7,-4(fp)
    return alt_msgdma_construct_prefetcher_standard_descriptor(dev, descriptor,
811452f4:	e0800217 	ldw	r2,8(fp)
811452f8:	d8800115 	stw	r2,4(sp)
811452fc:	e0bfff17 	ldw	r2,-4(fp)
81145300:	d8800015 	stw	r2,0(sp)
81145304:	000f883a 	mov	r7,zero
81145308:	e1bffe17 	ldw	r6,-8(fp)
8114530c:	e17ffd17 	ldw	r5,-12(fp)
81145310:	e13ffc17 	ldw	r4,-16(fp)
81145314:	1144fc40 	call	81144fc4 <alt_msgdma_construct_prefetcher_standard_descriptor>
    		read_address, 0, length, control);
}
81145318:	e037883a 	mov	sp,fp
8114531c:	dfc00117 	ldw	ra,4(sp)
81145320:	df000017 	ldw	fp,0(sp)
81145324:	dec00204 	addi	sp,sp,8
81145328:	f800283a 	ret

8114532c <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number,
	alt_u8 write_burst_count,
	alt_u16 write_stride)
{
8114532c:	deffee04 	addi	sp,sp,-72
81145330:	de00012e 	bgeu	sp,et,81145338 <alt_msgdma_construct_prefetcher_extended_st_to_mm_descriptor+0xc>
81145334:	003b68fa 	trap	3
81145338:	dfc01115 	stw	ra,68(sp)
8114533c:	df001015 	stw	fp,64(sp)
81145340:	df001004 	addi	fp,sp,64
81145344:	e13ff915 	stw	r4,-28(fp)
81145348:	e17ffa15 	stw	r5,-24(fp)
8114534c:	e1bffb15 	stw	r6,-20(fp)
81145350:	e1fffc15 	stw	r7,-16(fp)
81145354:	e1000417 	ldw	r4,16(fp)
81145358:	e0c00517 	ldw	r3,20(fp)
8114535c:	e0800617 	ldw	r2,24(fp)
81145360:	e13ffd0d 	sth	r4,-12(fp)
81145364:	e0fffe05 	stb	r3,-8(fp)
81145368:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor, 
8114536c:	e0bffd0b 	ldhu	r2,-12(fp)
81145370:	e0fffe03 	ldbu	r3,-8(fp)
81145374:	e13fff0b 	ldhu	r4,-4(fp)
81145378:	d9000815 	stw	r4,32(sp)
8114537c:	d8000715 	stw	zero,28(sp)
81145380:	d8c00615 	stw	r3,24(sp)
81145384:	d8000515 	stw	zero,20(sp)
81145388:	d8800415 	stw	r2,16(sp)
8114538c:	e0800317 	ldw	r2,12(fp)
81145390:	d8800315 	stw	r2,12(sp)
81145394:	e0800217 	ldw	r2,8(fp)
81145398:	d8800215 	stw	r2,8(sp)
8114539c:	e0bffc17 	ldw	r2,-16(fp)
811453a0:	d8800115 	stw	r2,4(sp)
811453a4:	e0bffb17 	ldw	r2,-20(fp)
811453a8:	d8800015 	stw	r2,0(sp)
811453ac:	000f883a 	mov	r7,zero
811453b0:	000d883a 	mov	r6,zero
811453b4:	e17ffa17 	ldw	r5,-24(fp)
811453b8:	e13ff917 	ldw	r4,-28(fp)
811453bc:	11450700 	call	81145070 <alt_msgdma_construct_prefetcher_extended_descriptor>
            0, 0, write_address_high, write_address_low, length, control, 
			sequence_number, 0, write_burst_count, 0, write_stride);
}
811453c0:	e037883a 	mov	sp,fp
811453c4:	dfc00117 	ldw	ra,4(sp)
811453c8:	df000017 	ldw	fp,0(sp)
811453cc:	dec00204 	addi	sp,sp,8
811453d0:	f800283a 	ret

811453d4 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor>:
	alt_u32 length, 
	alt_u32 control, 
	alt_u16 sequence_number, 
	alt_u8 read_burst_count, 
	alt_u16 read_stride)
{
811453d4:	deffee04 	addi	sp,sp,-72
811453d8:	de00012e 	bgeu	sp,et,811453e0 <alt_msgdma_construct_prefetcher_extended_mm_to_st_descriptor+0xc>
811453dc:	003b68fa 	trap	3
811453e0:	dfc01115 	stw	ra,68(sp)
811453e4:	df001015 	stw	fp,64(sp)
811453e8:	df001004 	addi	fp,sp,64
811453ec:	e13ff915 	stw	r4,-28(fp)
811453f0:	e17ffa15 	stw	r5,-24(fp)
811453f4:	e1bffb15 	stw	r6,-20(fp)
811453f8:	e1fffc15 	stw	r7,-16(fp)
811453fc:	e1000417 	ldw	r4,16(fp)
81145400:	e0c00517 	ldw	r3,20(fp)
81145404:	e0800617 	ldw	r2,24(fp)
81145408:	e13ffd0d 	sth	r4,-12(fp)
8114540c:	e0fffe05 	stb	r3,-8(fp)
81145410:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
81145414:	e0bffd0b 	ldhu	r2,-12(fp)
81145418:	e0fffe03 	ldbu	r3,-8(fp)
8114541c:	e13fff0b 	ldhu	r4,-4(fp)
81145420:	d8000815 	stw	zero,32(sp)
81145424:	d9000715 	stw	r4,28(sp)
81145428:	d8000615 	stw	zero,24(sp)
8114542c:	d8c00515 	stw	r3,20(sp)
81145430:	d8800415 	stw	r2,16(sp)
81145434:	e0800317 	ldw	r2,12(fp)
81145438:	d8800315 	stw	r2,12(sp)
8114543c:	e0800217 	ldw	r2,8(fp)
81145440:	d8800215 	stw	r2,8(sp)
81145444:	d8000115 	stw	zero,4(sp)
81145448:	d8000015 	stw	zero,0(sp)
8114544c:	e1fffc17 	ldw	r7,-16(fp)
81145450:	e1bffb17 	ldw	r6,-20(fp)
81145454:	e17ffa17 	ldw	r5,-24(fp)
81145458:	e13ff917 	ldw	r4,-28(fp)
8114545c:	11450700 	call	81145070 <alt_msgdma_construct_prefetcher_extended_descriptor>
    		read_address_high, read_address_low, 0, 0, length, control, 
			sequence_number, read_burst_count, 0, read_stride, 0);
}
81145460:	e037883a 	mov	sp,fp
81145464:	dfc00117 	ldw	ra,4(sp)
81145468:	df000017 	ldw	fp,0(sp)
8114546c:	dec00204 	addi	sp,sp,8
81145470:	f800283a 	ret

81145474 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor>:
	alt_u16 sequence_number,
	alt_u8 read_burst_count,
	alt_u8 write_burst_count, 
	alt_u16 read_stride, 
	alt_u16 write_stride)
{
81145474:	deffec04 	addi	sp,sp,-80
81145478:	de00012e 	bgeu	sp,et,81145480 <alt_msgdma_construct_prefetcher_extended_mm_to_mm_descriptor+0xc>
8114547c:	003b68fa 	trap	3
81145480:	dfc01315 	stw	ra,76(sp)
81145484:	df001215 	stw	fp,72(sp)
81145488:	df001204 	addi	fp,sp,72
8114548c:	e13ff715 	stw	r4,-36(fp)
81145490:	e17ff815 	stw	r5,-32(fp)
81145494:	e1bff915 	stw	r6,-28(fp)
81145498:	e1fffa15 	stw	r7,-24(fp)
8114549c:	e1800617 	ldw	r6,24(fp)
811454a0:	e1400717 	ldw	r5,28(fp)
811454a4:	e1000817 	ldw	r4,32(fp)
811454a8:	e0c00917 	ldw	r3,36(fp)
811454ac:	e0800a17 	ldw	r2,40(fp)
811454b0:	e1bffb0d 	sth	r6,-20(fp)
811454b4:	e17ffc05 	stb	r5,-16(fp)
811454b8:	e13ffd05 	stb	r4,-12(fp)
811454bc:	e0fffe0d 	sth	r3,-8(fp)
811454c0:	e0bfff0d 	sth	r2,-4(fp)
    return alt_msgdma_construct_prefetcher_extended_descriptor(dev, descriptor,
811454c4:	e0bffb0b 	ldhu	r2,-20(fp)
811454c8:	e0fffc03 	ldbu	r3,-16(fp)
811454cc:	e13ffd03 	ldbu	r4,-12(fp)
811454d0:	e17ffe0b 	ldhu	r5,-8(fp)
811454d4:	e1bfff0b 	ldhu	r6,-4(fp)
811454d8:	d9800815 	stw	r6,32(sp)
811454dc:	d9400715 	stw	r5,28(sp)
811454e0:	d9000615 	stw	r4,24(sp)
811454e4:	d8c00515 	stw	r3,20(sp)
811454e8:	d8800415 	stw	r2,16(sp)
811454ec:	e0800517 	ldw	r2,20(fp)
811454f0:	d8800315 	stw	r2,12(sp)
811454f4:	e0800417 	ldw	r2,16(fp)
811454f8:	d8800215 	stw	r2,8(sp)
811454fc:	e0800317 	ldw	r2,12(fp)
81145500:	d8800115 	stw	r2,4(sp)
81145504:	e0800217 	ldw	r2,8(fp)
81145508:	d8800015 	stw	r2,0(sp)
8114550c:	e1fffa17 	ldw	r7,-24(fp)
81145510:	e1bff917 	ldw	r6,-28(fp)
81145514:	e17ff817 	ldw	r5,-32(fp)
81145518:	e13ff717 	ldw	r4,-36(fp)
8114551c:	11450700 	call	81145070 <alt_msgdma_construct_prefetcher_extended_descriptor>
            read_address_high, read_address_low, write_address_high, 
			write_address_low, length, control, sequence_number, 
			read_burst_count, write_burst_count, read_stride, write_stride);

}
81145520:	e037883a 	mov	sp,fp
81145524:	dfc00117 	ldw	ra,4(sp)
81145528:	df000017 	ldw	fp,0(sp)
8114552c:	dec00204 	addi	sp,sp,8
81145530:	f800283a 	ret

81145534 <alt_msgdma_prefetcher_add_standard_desc_to_list>:
 *           descriptor.next_ptr not pointing back to itslef)
 */
int alt_msgdma_prefetcher_add_standard_desc_to_list (
	alt_msgdma_prefetcher_standard_descriptor** list,
	alt_msgdma_prefetcher_standard_descriptor* descriptor)
{
81145534:	defffc04 	addi	sp,sp,-16
81145538:	de00012e 	bgeu	sp,et,81145540 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xc>
8114553c:	003b68fa 	trap	3
81145540:	df000315 	stw	fp,12(sp)
81145544:	df000304 	addi	fp,sp,12
81145548:	e13ffe15 	stw	r4,-8(fp)
8114554c:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	
	if (descriptor == NULL)
81145550:	e0bfff17 	ldw	r2,-4(fp)
81145554:	1000021e 	bne	r2,zero,81145560 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81145558:	00bffa84 	movi	r2,-22
8114555c:	00002f06 	br	8114561c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (descriptor->next_desc_ptr != (alt_u32)descriptor)
81145560:	e0bfff17 	ldw	r2,-4(fp)
81145564:	10c00317 	ldw	r3,12(r2)
81145568:	e0bfff17 	ldw	r2,-4(fp)
8114556c:	18800226 	beq	r3,r2,81145578 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x44>
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
81145570:	00bffa84 	movi	r2,-22
81145574:	00002906 	br	8114561c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == NULL)
81145578:	e0bffe17 	ldw	r2,-8(fp)
8114557c:	10800017 	ldw	r2,0(r2)
81145580:	1000051e 	bne	r2,zero,81145598 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x64>
	{
		*list = descriptor;  /* make this root-node if list is empty */
81145584:	e0bffe17 	ldw	r2,-8(fp)
81145588:	e0ffff17 	ldw	r3,-4(fp)
8114558c:	10c00015 	stw	r3,0(r2)
		return 0;  /* successfully added */
81145590:	0005883a 	mov	r2,zero
81145594:	00002106 	br	8114561c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	if (*list == descriptor)
81145598:	e0bffe17 	ldw	r2,-8(fp)
8114559c:	10c00017 	ldw	r3,0(r2)
811455a0:	e0bfff17 	ldw	r2,-4(fp)
811455a4:	1880021e 	bne	r3,r2,811455b0 <alt_msgdma_prefetcher_add_standard_desc_to_list+0x7c>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811455a8:	00bffa84 	movi	r2,-22
811455ac:	00001b06 	br	8114561c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811455b0:	e0bffe17 	ldw	r2,-8(fp)
811455b4:	10800017 	ldw	r2,0(r2)
811455b8:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811455bc:	00000906 	br	811455e4 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xb0>
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
811455c0:	e0bffd17 	ldw	r2,-12(fp)
811455c4:	10c00317 	ldw	r3,12(r2)
811455c8:	e0bfff17 	ldw	r2,-4(fp)
811455cc:	1880021e 	bne	r3,r2,811455d8 <alt_msgdma_prefetcher_add_standard_desc_to_list+0xa4>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
811455d0:	00bffa84 	movi	r2,-22
811455d4:	00001106 	br	8114561c <alt_msgdma_prefetcher_add_standard_desc_to_list+0xe8>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
811455d8:	e0bffd17 	ldw	r2,-12(fp)
811455dc:	10800317 	ldw	r2,12(r2)
	{
		if (last_descr_ptr->next_desc_ptr == (alt_u32)descriptor)
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		last_descr_ptr = 
811455e0:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
	/* traverse list until you get the last node */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)*list)  
811455e4:	e0bffd17 	ldw	r2,-12(fp)
811455e8:	10800317 	ldw	r2,12(r2)
811455ec:	e0fffe17 	ldw	r3,-8(fp)
811455f0:	18c00017 	ldw	r3,0(r3)
811455f4:	10fff21e 	bne	r2,r3,811455c0 <__reset+0xfb1255c0>
		}
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* add this descriptor to end of list */
	last_descr_ptr->next_desc_ptr = (alt_u32)((uintptr_t)descriptor);
811455f8:	e0ffff17 	ldw	r3,-4(fp)
811455fc:	e0bffd17 	ldw	r2,-12(fp)
81145600:	10c00315 	stw	r3,12(r2)
	/* ensure new last pointer points the start of the list */
	descriptor->next_desc_ptr = (alt_u32)((uintptr_t)*list);  
81145604:	e0bffe17 	ldw	r2,-8(fp)
81145608:	10800017 	ldw	r2,0(r2)
8114560c:	1007883a 	mov	r3,r2
81145610:	e0bfff17 	ldw	r2,-4(fp)
81145614:	10c00315 	stw	r3,12(r2)
	return 0; /* successfully added */
81145618:	0005883a 	mov	r2,zero
}
8114561c:	e037883a 	mov	sp,fp
81145620:	df000017 	ldw	fp,0(sp)
81145624:	dec00104 	addi	sp,sp,4
81145628:	f800283a 	ret

8114562c <alt_msgdma_prefetcher_add_extended_desc_to_list>:

int alt_msgdma_prefetcher_add_extended_desc_to_list (
	alt_msgdma_prefetcher_extended_descriptor** list,
	alt_msgdma_prefetcher_extended_descriptor* descriptor)
{
8114562c:	defff804 	addi	sp,sp,-32
81145630:	de00012e 	bgeu	sp,et,81145638 <alt_msgdma_prefetcher_add_extended_desc_to_list+0xc>
81145634:	003b68fa 	trap	3
81145638:	df000715 	stw	fp,28(sp)
8114563c:	df000704 	addi	fp,sp,28
81145640:	e13ffe15 	stw	r4,-8(fp)
81145644:	e17fff15 	stw	r5,-4(fp)
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	msgdma_addr64 root_node_addr, next_node_addr;
	
	if (descriptor == NULL)
81145648:	e13fff17 	ldw	r4,-4(fp)
8114564c:	2000021e 	bne	r4,zero,81145658 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x2c>
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
81145650:	00bffa84 	movi	r2,-22
81145654:	00005906 	br	811457bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
81145658:	e13fff17 	ldw	r4,-4(fp)
8114565c:	2015883a 	mov	r10,r4
81145660:	0017883a 	mov	r11,zero
81145664:	e2bffc15 	stw	r10,-16(fp)
81145668:	e2fffd15 	stw	r11,-12(fp)
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
8114566c:	e13fff17 	ldw	r4,-4(fp)
81145670:	21400317 	ldw	r5,12(r4)
81145674:	e13ffc17 	ldw	r4,-16(fp)
81145678:	29000626 	beq	r5,r4,81145694 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
8114567c:	e13fff17 	ldw	r4,-4(fp)
81145680:	21400b17 	ldw	r5,44(r4)
81145684:	e13ffd17 	ldw	r4,-12(fp)
	{
		return -EINVAL;  /* this descriptor cannot be NULL */
	}
	
	next_node_addr.u64 = (uintptr_t)descriptor;
	if( (descriptor->next_desc_ptr_low != next_node_addr.u32[0]) &&
81145688:	29000226 	beq	r5,r4,81145694 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x68>
		(descriptor->next_desc_ptr_high != next_node_addr.u32[1]))
	{
		return -EINVAL;  /* descriptor.next_ptr must point to itself */
8114568c:	00bffa84 	movi	r2,-22
81145690:	00004a06 	br	811457bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	if (*list == NULL)
81145694:	e13ffe17 	ldw	r4,-8(fp)
81145698:	21000017 	ldw	r4,0(r4)
8114569c:	2000051e 	bne	r4,zero,811456b4 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x88>
	{
		*list = descriptor;  /* make this the root-node if list is empty */
811456a0:	e0bffe17 	ldw	r2,-8(fp)
811456a4:	e0ffff17 	ldw	r3,-4(fp)
811456a8:	10c00015 	stw	r3,0(r2)
		return 0;
811456ac:	0005883a 	mov	r2,zero
811456b0:	00004206 	br	811457bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	if (*list == descriptor)
811456b4:	e13ffe17 	ldw	r4,-8(fp)
811456b8:	21400017 	ldw	r5,0(r4)
811456bc:	e13fff17 	ldw	r4,-4(fp)
811456c0:	2900021e 	bne	r5,r4,811456cc <alt_msgdma_prefetcher_add_extended_desc_to_list+0xa0>
	{
		return -EINVAL;  /* this descriptor cannot already be root-node */
811456c4:	00bffa84 	movi	r2,-22
811456c8:	00003c06 	br	811457bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
	}
	
	/* get to last node in the list */
	last_descr_ptr = *list; /* start at list root-node */
811456cc:	e13ffe17 	ldw	r4,-8(fp)
811456d0:	21000017 	ldw	r4,0(r4)
811456d4:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
811456d8:	e13ffe17 	ldw	r4,-8(fp)
811456dc:	21000017 	ldw	r4,0(r4)
811456e0:	2011883a 	mov	r8,r4
811456e4:	0013883a 	mov	r9,zero
811456e8:	e23ffa15 	stw	r8,-24(fp)
811456ec:	e27ffb15 	stw	r9,-20(fp)
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811456f0:	00001806 	br	81145754 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x128>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* first check if descriptor already in the list */
		next_node_addr.u64 = (uintptr_t)descriptor;
811456f4:	e13fff17 	ldw	r4,-4(fp)
811456f8:	200d883a 	mov	r6,r4
811456fc:	000f883a 	mov	r7,zero
81145700:	e1bffc15 	stw	r6,-16(fp)
81145704:	e1fffd15 	stw	r7,-12(fp)
		if ((last_descr_ptr->next_desc_ptr_low == next_node_addr.u32[0])
81145708:	e13ff917 	ldw	r4,-28(fp)
8114570c:	21400317 	ldw	r5,12(r4)
81145710:	e13ffc17 	ldw	r4,-16(fp)
81145714:	2900061e 	bne	r5,r4,81145730 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
			&& (last_descr_ptr->next_desc_ptr_high == next_node_addr.u32[1]))
81145718:	e13ff917 	ldw	r4,-28(fp)
8114571c:	21400b17 	ldw	r5,44(r4)
81145720:	e13ffd17 	ldw	r4,-12(fp)
81145724:	2900021e 	bne	r5,r4,81145730 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x104>
		{
			return -EINVAL;  /* descriptor cannot already be in the list */
81145728:	00bffa84 	movi	r2,-22
8114572c:	00002306 	br	811457bc <alt_msgdma_prefetcher_add_extended_desc_to_list+0x190>
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
81145730:	e13ff917 	ldw	r4,-28(fp)
81145734:	21000317 	ldw	r4,12(r4)
81145738:	e13ffc15 	stw	r4,-16(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
8114573c:	e13ff917 	ldw	r4,-28(fp)
81145740:	21000b17 	ldw	r4,44(r4)
81145744:	e13ffd15 	stw	r4,-12(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
81145748:	e13ffc17 	ldw	r4,-16(fp)
8114574c:	e17ffd17 	ldw	r5,-12(fp)
			return -EINVAL;  /* descriptor cannot already be in the list */
		}
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
81145750:	e13ff915 	stw	r4,-28(fp)
	last_descr_ptr = *list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)*list;
	
	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
81145754:	e13ff917 	ldw	r4,-28(fp)
81145758:	21400317 	ldw	r5,12(r4)
8114575c:	e13ffa17 	ldw	r4,-24(fp)
81145760:	29000426 	beq	r5,r4,81145774 <alt_msgdma_prefetcher_add_extended_desc_to_list+0x148>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81145764:	e13ff917 	ldw	r4,-28(fp)
81145768:	21400b17 	ldw	r5,44(r4)
8114576c:	e13ffb17 	ldw	r4,-20(fp)
81145770:	293fe01e 	bne	r5,r4,811456f4 <__reset+0xfb1256f4>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* add this descriptor to end of list */
	next_node_addr.u64 = (uintptr_t)descriptor;
81145774:	e13fff17 	ldw	r4,-4(fp)
81145778:	2005883a 	mov	r2,r4
8114577c:	0007883a 	mov	r3,zero
81145780:	e0bffc15 	stw	r2,-16(fp)
81145784:	e0fffd15 	stw	r3,-12(fp)
	last_descr_ptr->next_desc_ptr_low = next_node_addr.u32[0];
81145788:	e0fffc17 	ldw	r3,-16(fp)
8114578c:	e0bff917 	ldw	r2,-28(fp)
81145790:	10c00315 	stw	r3,12(r2)
	last_descr_ptr->next_desc_ptr_high = next_node_addr.u32[1];
81145794:	e0fffd17 	ldw	r3,-12(fp)
81145798:	e0bff917 	ldw	r2,-28(fp)
8114579c:	10c00b15 	stw	r3,44(r2)
	/* ensure new last pointer points the beginning of the list */
	descriptor->next_desc_ptr_low = root_node_addr.u32[0];
811457a0:	e0fffa17 	ldw	r3,-24(fp)
811457a4:	e0bfff17 	ldw	r2,-4(fp)
811457a8:	10c00315 	stw	r3,12(r2)
	descriptor->next_desc_ptr_high = root_node_addr.u32[1];
811457ac:	e0fffb17 	ldw	r3,-20(fp)
811457b0:	e0bfff17 	ldw	r2,-4(fp)
811457b4:	10c00b15 	stw	r3,44(r2)
	return 0;
811457b8:	0005883a 	mov	r2,zero
}
811457bc:	e037883a 	mov	sp,fp
811457c0:	df000017 	ldw	fp,0(sp)
811457c4:	dec00104 	addi	sp,sp,4
811457c8:	f800283a 	ret

811457cc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_std_list_own_by_hw_bits (
	alt_msgdma_prefetcher_standard_descriptor *list)
{
811457cc:	defffc04 	addi	sp,sp,-16
811457d0:	de00012e 	bgeu	sp,et,811457d8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0xc>
811457d4:	003b68fa 	trap	3
811457d8:	df000315 	stw	fp,12(sp)
811457dc:	df000304 	addi	fp,sp,12
811457e0:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
811457e4:	e03ffe15 	stw	zero,-8(fp)
	alt_msgdma_prefetcher_standard_descriptor *last_descr_ptr;
	if (list == NULL)
811457e8:	e0bfff17 	ldw	r2,-4(fp)
811457ec:	1000021e 	bne	r2,zero,811457f8 <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
811457f0:	00bffa84 	movi	r2,-22
811457f4:	00001906 	br	8114585c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x90>
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
811457f8:	e0bfff17 	ldw	r2,-4(fp)
811457fc:	e0bffd15 	stw	r2,-12(fp)
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
81145800:	00000a06 	br	8114582c <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits+0x60>
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
81145804:	e0bffd17 	ldw	r2,-12(fp)
81145808:	10800717 	ldw	r2,28(r2)
8114580c:	e0bffe15 	stw	r2,-8(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81145810:	e0bffe17 	ldw	r2,-8(fp)
81145814:	10d00034 	orhi	r3,r2,16384
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
	{
		/* get current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
81145818:	e0bffd17 	ldw	r2,-12(fp)
8114581c:	10c00715 	stw	r3,28(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
81145820:	e0bffd17 	ldw	r2,-12(fp)
81145824:	10800317 	ldw	r2,12(r2)
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list */
		last_descr_ptr = 
81145828:	e0bffd15 	stw	r2,-12(fp)
	}

	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
	/* traverse list to update all of the nodes */
	while (last_descr_ptr->next_desc_ptr != (alt_u32)list)  
8114582c:	e0bffd17 	ldw	r2,-12(fp)
81145830:	10c00317 	ldw	r3,12(r2)
81145834:	e0bfff17 	ldw	r2,-4(fp)
81145838:	18bff21e 	bne	r3,r2,81145804 <__reset+0xfb125804>
		/* go to next node in list */
		last_descr_ptr = 
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
8114583c:	e0bffd17 	ldw	r2,-12(fp)
81145840:	10800717 	ldw	r2,28(r2)
81145844:	e0bffe15 	stw	r2,-8(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81145848:	e0bffe17 	ldw	r2,-8(fp)
8114584c:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_standard_descriptor*)(last_descr_ptr->next_desc_ptr);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* get current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
81145850:	e0bffd17 	ldw	r2,-12(fp)
81145854:	10c00715 	stw	r3,28(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	
	return 0;
81145858:	0005883a 	mov	r2,zero
}
8114585c:	e037883a 	mov	sp,fp
81145860:	df000017 	ldw	fp,0(sp)
81145864:	dec00104 	addi	sp,sp,4
81145868:	f800283a 	ret

8114586c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>:
 * prefetcher since if used the create descriptor APIs the set_by_hw bits are
 * still set to SW owned. 
 */
int alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits (
	alt_msgdma_prefetcher_extended_descriptor *list)
{
8114586c:	defff804 	addi	sp,sp,-32
81145870:	de00012e 	bgeu	sp,et,81145878 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xc>
81145874:	003b68fa 	trap	3
81145878:	df000715 	stw	fp,28(sp)
8114587c:	df000704 	addi	fp,sp,28
81145880:	e13fff15 	stw	r4,-4(fp)
	alt_u32 descriptor_control_field = 0;
81145884:	e03ffa15 	stw	zero,-24(fp)
	msgdma_addr64 root_node_addr, next_node_addr;
	alt_msgdma_prefetcher_extended_descriptor *last_descr_ptr;
	
	if (list == NULL)
81145888:	e13fff17 	ldw	r4,-4(fp)
8114588c:	2000021e 	bne	r4,zero,81145898 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x2c>
	{
		return -EINVAL;  /* this list cannot be empty */
81145890:	00bffa84 	movi	r2,-22
81145894:	00002806 	br	81145938 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xcc>
	}
	
	/* update all nodes in the list */
	last_descr_ptr = list; /* start at list root-node */
81145898:	e13fff17 	ldw	r4,-4(fp)
8114589c:	e13ff915 	stw	r4,-28(fp)
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;
811458a0:	e13fff17 	ldw	r4,-4(fp)
811458a4:	2005883a 	mov	r2,r4
811458a8:	0007883a 	mov	r3,zero
811458ac:	e0bffb15 	stw	r2,-20(fp)
811458b0:	e0fffc15 	stw	r3,-16(fp)

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811458b4:	00001006 	br	811458f8 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0x8c>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
811458b8:	e0bff917 	ldw	r2,-28(fp)
811458bc:	10800f17 	ldw	r2,60(r2)
811458c0:	e0bffa15 	stw	r2,-24(fp)
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
811458c4:	e0bffa17 	ldw	r2,-24(fp)
811458c8:	10d00034 	orhi	r3,r2,16384
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
	{
		/* start with current value */
		descriptor_control_field = last_descr_ptr->control;
		/* update own_by_hw bit only */
		last_descr_ptr->control = descriptor_control_field 
811458cc:	e0bff917 	ldw	r2,-28(fp)
811458d0:	10c00f15 	stw	r3,60(r2)
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
811458d4:	e0bff917 	ldw	r2,-28(fp)
811458d8:	10800317 	ldw	r2,12(r2)
811458dc:	e0bffd15 	stw	r2,-12(fp)
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
811458e0:	e0bff917 	ldw	r2,-28(fp)
811458e4:	10800b17 	ldw	r2,44(r2)
811458e8:	e0bffe15 	stw	r2,-8(fp)
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
811458ec:	e0bffd17 	ldw	r2,-12(fp)
811458f0:	e0fffe17 	ldw	r3,-8(fp)
		last_descr_ptr->control = descriptor_control_field 
				| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
		/* go to next node in list, using 64 bit address */
		next_node_addr.u32[0] = last_descr_ptr->next_desc_ptr_low;
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
811458f4:	e0bff915 	stw	r2,-28(fp)
	last_descr_ptr = list; /* start at list root-node */
	/* the last nodes next ptr should point to the root node*/
	root_node_addr.u64 = (uintptr_t)list;

	/* traverse list until you get the last node */
	while ((last_descr_ptr->next_desc_ptr_low != root_node_addr.u32[0]) 
811458f8:	e0bff917 	ldw	r2,-28(fp)
811458fc:	10c00317 	ldw	r3,12(r2)
81145900:	e0bffb17 	ldw	r2,-20(fp)
81145904:	18800426 	beq	r3,r2,81145918 <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits+0xac>
		&& (last_descr_ptr->next_desc_ptr_high != root_node_addr.u32[1]))
81145908:	e0bff917 	ldw	r2,-28(fp)
8114590c:	10c00b17 	ldw	r3,44(r2)
81145910:	e0bffc17 	ldw	r2,-16(fp)
81145914:	18bfe81e 	bne	r3,r2,811458b8 <__reset+0xfb1258b8>
		next_node_addr.u32[1] = last_descr_ptr->next_desc_ptr_high;
		last_descr_ptr = 
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
81145918:	e0bff917 	ldw	r2,-28(fp)
8114591c:	10800f17 	ldw	r2,60(r2)
81145920:	e0bffa15 	stw	r2,-24(fp)
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
81145924:	e0bffa17 	ldw	r2,-24(fp)
81145928:	10d00034 	orhi	r3,r2,16384
			(alt_msgdma_prefetcher_extended_descriptor*)((uintptr_t)next_node_addr.u64);
	}
	/* update the last node in the list, currently last_descr_ptr after while loop */
	descriptor_control_field = last_descr_ptr->control;    /* start with current value */
	/* update own_by_hw bit only */
	last_descr_ptr->control = descriptor_control_field 
8114592c:	e0bff917 	ldw	r2,-28(fp)
81145930:	10c00f15 	stw	r3,60(r2)
		| ALT_MSGDMA_PREFETCHER_DESCRIPTOR_CTRL_OWN_BY_HW_SET_MASK;
	return 0;
81145934:	0005883a 	mov	r2,zero
}
81145938:	e037883a 	mov	sp,fp
8114593c:	df000017 	ldw	fp,0(sp)
81145940:	dec00104 	addi	sp,sp,4
81145944:	f800283a 	ret

81145948 <alt_msgdma_start_prefetcher_with_list_addr>:
int alt_msgdma_start_prefetcher_with_list_addr (
	alt_msgdma_dev *dev,
	alt_u64  list_addr,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81145948:	deffeb04 	addi	sp,sp,-84
8114594c:	de00012e 	bgeu	sp,et,81145954 <alt_msgdma_start_prefetcher_with_list_addr+0xc>
81145950:	003b68fa 	trap	3
81145954:	dfc01415 	stw	ra,80(sp)
81145958:	df001315 	stw	fp,76(sp)
8114595c:	df001304 	addi	fp,sp,76
81145960:	e13ffb15 	stw	r4,-20(fp)
81145964:	e17ffc15 	stw	r5,-16(fp)
81145968:	e1bffd15 	stw	r6,-12(fp)
8114596c:	3807883a 	mov	r3,r7
81145970:	e0800217 	ldw	r2,8(fp)
81145974:	e0fffe05 	stb	r3,-8(fp)
81145978:	e0bfff05 	stb	r2,-4(fp)
	alt_u32 prefetcher_ctl = 0;
8114597c:	e03fed15 	stw	zero,-76(fp)
	alt_u32 dispatcher_ctl = 0;
81145980:	e03fee15 	stw	zero,-72(fp)
	alt_irq_context context = 0;
81145984:	e03fef15 	stw	zero,-68(fp)
	
	/* use helper struct to get easy access to hi/low address */
	msgdma_addr64 root_node_addr;
	root_node_addr.u64 = list_addr;  
81145988:	e0bffc17 	ldw	r2,-16(fp)
8114598c:	e0bff815 	stw	r2,-32(fp)
81145990:	e0bffd17 	ldw	r2,-12(fp)
81145994:	e0bff915 	stw	r2,-28(fp)
	
	/*
	 * When running in a multi threaded environment, obtain the "regs_lock"
	 * semaphore. This ensures that accessing registers is thread-safe.
	 */
	ALT_SEM_PEND (dev->regs_lock, 0);
81145998:	e0bffb17 	ldw	r2,-20(fp)
8114599c:	10801817 	ldw	r2,96(r2)
811459a0:	e0bff615 	stw	r2,-40(fp)
811459a4:	e03ff70d 	sth	zero,-36(fp)
811459a8:	e0bff70b 	ldhu	r2,-36(fp)
811459ac:	e0fffa04 	addi	r3,fp,-24
811459b0:	180d883a 	mov	r6,r3
811459b4:	100b883a 	mov	r5,r2
811459b8:	e13ff617 	ldw	r4,-40(fp)
811459bc:	113aaf40 	call	8113aaf4 <OSSemPend>
	
	/* case where prefetcher already started, return busy error */ 
	prefetcher_ctl = IORD_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base);
811459c0:	e0bffb17 	ldw	r2,-20(fp)
811459c4:	10800617 	ldw	r2,24(r2)
811459c8:	10800037 	ldwio	r2,0(r2)
811459cc:	e0bfed15 	stw	r2,-76(fp)
	if(ALT_MSGDMA_PREFETCHER_CTRL_RUN_GET(prefetcher_ctl)){
811459d0:	e0bfed17 	ldw	r2,-76(fp)
811459d4:	1080004c 	andi	r2,r2,1
811459d8:	10000626 	beq	r2,zero,811459f4 <alt_msgdma_start_prefetcher_with_list_addr+0xac>
		/* release the registers semaphore */
		ALT_SEM_POST (dev->regs_lock);
811459dc:	e0bffb17 	ldw	r2,-20(fp)
811459e0:	10801817 	ldw	r2,96(r2)
811459e4:	1009883a 	mov	r4,r2
811459e8:	113ae7c0 	call	8113ae7c <OSSemPost>
		return -EBUSY;
811459ec:	00bffc04 	movi	r2,-16
811459f0:	00009606 	br	81145c4c <alt_msgdma_start_prefetcher_with_list_addr+0x304>
	}
		
	/* Stop the msgdma dispatcher from issuing more descriptors to the
	   read or write masters  */
	/* stop issuing more descriptors */
	dispatcher_ctl = ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
811459f4:	00800804 	movi	r2,32
811459f8:	e0bfee15 	stw	r2,-72(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811459fc:	0005303a 	rdctl	r2,status
81145a00:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145a04:	e0fff217 	ldw	r3,-56(fp)
81145a08:	00bfff84 	movi	r2,-2
81145a0c:	1884703a 	and	r2,r3,r2
81145a10:	1001703a 	wrctl	status,r2
  
  return context;
81145a14:	e0bff217 	ldw	r2,-56(fp)
	
	/* making sure the read-modify-write below can't be pre-empted */
	context = alt_irq_disable_all();
81145a18:	e0bfef15 	stw	r2,-68(fp)
	IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81145a1c:	e0bffb17 	ldw	r2,-20(fp)
81145a20:	10800317 	ldw	r2,12(r2)
81145a24:	10800104 	addi	r2,r2,4
81145a28:	e0ffee17 	ldw	r3,-72(fp)
81145a2c:	10c00035 	stwio	r3,0(r2)
	/*
	 * Clear any (previous) status register information
	 * that might occlude our error checking later.
	 */
	IOWR_ALTERA_MSGDMA_CSR_STATUS( dev->csr_base, 
81145a30:	e0bffb17 	ldw	r2,-20(fp)
81145a34:	10800317 	ldw	r2,12(r2)
81145a38:	e0fffb17 	ldw	r3,-20(fp)
81145a3c:	18c00317 	ldw	r3,12(r3)
81145a40:	18c00037 	ldwio	r3,0(r3)
81145a44:	10c00035 	stwio	r3,0(r2)
81145a48:	e0bfef17 	ldw	r2,-68(fp)
81145a4c:	e0bff015 	stw	r2,-64(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145a50:	e0bff017 	ldw	r2,-64(fp)
81145a54:	1001703a 	wrctl	status,r2
	 * If a callback routine has been previously registered which will be
	 * called from the msgdma ISR. Set up dispatcher to:
	 *  - Run
	 *  - Stop on an error with any particular descriptor
	 */
	if(dev->callback)
81145a58:	e0bffb17 	ldw	r2,-20(fp)
81145a5c:	10800b17 	ldw	r2,44(r2)
81145a60:	10002326 	beq	r2,zero,81145af0 <alt_msgdma_start_prefetcher_with_list_addr+0x1a8>
	{
		dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK 
81145a64:	e0bffb17 	ldw	r2,-20(fp)
81145a68:	10c00d17 	ldw	r3,52(r2)
81145a6c:	e0bfee17 	ldw	r2,-72(fp)
81145a70:	1884b03a 	or	r2,r3,r2
81145a74:	10800514 	ori	r2,r2,20
81145a78:	e0bfee15 	stw	r2,-72(fp)
				| ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK );
		dispatcher_ctl &=  (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK);
81145a7c:	e0ffee17 	ldw	r3,-72(fp)
81145a80:	00bff7c4 	movi	r2,-33
81145a84:	1884703a 	and	r2,r3,r2
81145a88:	e0bfee15 	stw	r2,-72(fp)
		
		prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_SET_MASK;
81145a8c:	e0bfed17 	ldw	r2,-76(fp)
81145a90:	10800214 	ori	r2,r2,8
81145a94:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145a98:	0005303a 	rdctl	r2,status
81145a9c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145aa0:	e0fff417 	ldw	r3,-48(fp)
81145aa4:	00bfff84 	movi	r2,-2
81145aa8:	1884703a 	and	r2,r3,r2
81145aac:	1001703a 	wrctl	status,r2
  
  return context;
81145ab0:	e0bff417 	ldw	r2,-48(fp)
	    /* making sure the read-modify-write below can't be pre-empted */
	    context = alt_irq_disable_all(); 
81145ab4:	e0bfef15 	stw	r2,-68(fp)
	    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81145ab8:	e0bffb17 	ldw	r2,-20(fp)
81145abc:	10800317 	ldw	r2,12(r2)
81145ac0:	10800104 	addi	r2,r2,4
81145ac4:	e0ffee17 	ldw	r3,-72(fp)
81145ac8:	10c00035 	stwio	r3,0(r2)
		IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81145acc:	e0bffb17 	ldw	r2,-20(fp)
81145ad0:	10800617 	ldw	r2,24(r2)
81145ad4:	e0ffed17 	ldw	r3,-76(fp)
81145ad8:	10c00035 	stwio	r3,0(r2)
81145adc:	e0bfef17 	ldw	r2,-68(fp)
81145ae0:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145ae4:	e0bff117 	ldw	r2,-60(fp)
81145ae8:	1001703a 	wrctl	status,r2
81145aec:	00002306 	br	81145b7c <alt_msgdma_start_prefetcher_with_list_addr+0x234>
	  *   - Stop on an error with any particular descriptor
	  *   - Disable interrupt generation
	  */
	 else
	 {
		 dispatcher_ctl |= (dev->control | ALTERA_MSGDMA_CSR_STOP_ON_ERROR_MASK);
81145af0:	e0bffb17 	ldw	r2,-20(fp)
81145af4:	10c00d17 	ldw	r3,52(r2)
81145af8:	e0bfee17 	ldw	r2,-72(fp)
81145afc:	1884b03a 	or	r2,r3,r2
81145b00:	10800114 	ori	r2,r2,4
81145b04:	e0bfee15 	stw	r2,-72(fp)
		 dispatcher_ctl &= (~ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK) 
81145b08:	e0ffee17 	ldw	r3,-72(fp)
81145b0c:	00bff3c4 	movi	r2,-49
81145b10:	1884703a 	and	r2,r3,r2
81145b14:	e0bfee15 	stw	r2,-72(fp)
				 & (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_GLOBAL_INTR_EN_CLR_MASK;
81145b18:	e0ffed17 	ldw	r3,-76(fp)
81145b1c:	00bffdc4 	movi	r2,-9
81145b20:	1884703a 	and	r2,r3,r2
81145b24:	e0bfed15 	stw	r2,-76(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81145b28:	0005303a 	rdctl	r2,status
81145b2c:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81145b30:	e0fff517 	ldw	r3,-44(fp)
81145b34:	00bfff84 	movi	r2,-2
81145b38:	1884703a 	and	r2,r3,r2
81145b3c:	1001703a 	wrctl	status,r2
  
  return context;
81145b40:	e0bff517 	ldw	r2,-44(fp)
	     /* making sure the read-modify-write below can't be pre-empted */
	     context = alt_irq_disable_all();
81145b44:	e0bfef15 	stw	r2,-68(fp)
	     IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, dispatcher_ctl);
81145b48:	e0bffb17 	ldw	r2,-20(fp)
81145b4c:	10800317 	ldw	r2,12(r2)
81145b50:	10800104 	addi	r2,r2,4
81145b54:	e0ffee17 	ldw	r3,-72(fp)
81145b58:	10c00035 	stwio	r3,0(r2)
	     IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81145b5c:	e0bffb17 	ldw	r2,-20(fp)
81145b60:	10800617 	ldw	r2,24(r2)
81145b64:	e0ffed17 	ldw	r3,-76(fp)
81145b68:	10c00035 	stwio	r3,0(r2)
81145b6c:	e0bfef17 	ldw	r2,-68(fp)
81145b70:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81145b74:	e0bff317 	ldw	r2,-52(fp)
81145b78:	1001703a 	wrctl	status,r2
	     alt_irq_enable_all(context);
	 }   
	
	 /* set next descriptor registers to point to the list root-node */
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_LOW(dev->prefetcher_base,
81145b7c:	e0bffb17 	ldw	r2,-20(fp)
81145b80:	10800617 	ldw	r2,24(r2)
81145b84:	10800104 	addi	r2,r2,4
81145b88:	e0fff817 	ldw	r3,-32(fp)
81145b8c:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[0]);
	 IOWR_ALT_MSGDMA_PREFETCHER_NEXT_DESCRIPTOR_PTR_HIGH(dev->prefetcher_base,
81145b90:	e0bffb17 	ldw	r2,-20(fp)
81145b94:	10800617 	ldw	r2,24(r2)
81145b98:	10800204 	addi	r2,r2,8
81145b9c:	e0fff917 	ldw	r3,-28(fp)
81145ba0:	10c00035 	stwio	r3,0(r2)
			 root_node_addr.u32[1]);
		
	 /* set park-mode */
	 if (park_mode_en){
81145ba4:	e0bffe03 	ldbu	r2,-8(fp)
81145ba8:	10000426 	beq	r2,zero,81145bbc <alt_msgdma_start_prefetcher_with_list_addr+0x274>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_SET_MASK;
81145bac:	e0bfed17 	ldw	r2,-76(fp)
81145bb0:	10800414 	ori	r2,r2,16
81145bb4:	e0bfed15 	stw	r2,-76(fp)
81145bb8:	00000406 	br	81145bcc <alt_msgdma_start_prefetcher_with_list_addr+0x284>
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_PARK_MODE_CLR_MASK;
81145bbc:	e0ffed17 	ldw	r3,-76(fp)
81145bc0:	00bffbc4 	movi	r2,-17
81145bc4:	1884703a 	and	r2,r3,r2
81145bc8:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set poll-en */
	 if (poll_en){
81145bcc:	e0bfff03 	ldbu	r2,-4(fp)
81145bd0:	10000e26 	beq	r2,zero,81145c0c <alt_msgdma_start_prefetcher_with_list_addr+0x2c4>
		 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_MASK; 
81145bd4:	e0bfed17 	ldw	r2,-76(fp)
81145bd8:	10800094 	ori	r2,r2,2
81145bdc:	e0bfed15 	stw	r2,-76(fp)
		 if(IORD_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81145be0:	e0bffb17 	ldw	r2,-20(fp)
81145be4:	10800617 	ldw	r2,24(r2)
81145be8:	10800304 	addi	r2,r2,12
81145bec:	10800037 	ldwio	r2,0(r2)
81145bf0:	10000a1e 	bne	r2,zero,81145c1c <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
				 dev->prefetcher_base) == 0){
			 /* set poll frequency to some non-zero default value */
			 IOWR_ALT_MSGDMA_PREFETCHER_DESCRIPTOR_POLLING_FREQ(
81145bf4:	e0bffb17 	ldw	r2,-20(fp)
81145bf8:	10800617 	ldw	r2,24(r2)
81145bfc:	10800304 	addi	r2,r2,12
81145c00:	00c03fc4 	movi	r3,255
81145c04:	10c00035 	stwio	r3,0(r2)
81145c08:	00000406 	br	81145c1c <alt_msgdma_start_prefetcher_with_list_addr+0x2d4>
					 dev->prefetcher_base, 0xFF);
		 }
	 }
	 else {
		 prefetcher_ctl &= ALT_MSGDMA_PREFETCHER_CTRL_DESC_POLL_EN_CLR_MASK; 
81145c0c:	e0ffed17 	ldw	r3,-76(fp)
81145c10:	00bfff44 	movi	r2,-3
81145c14:	1884703a 	and	r2,r3,r2
81145c18:	e0bfed15 	stw	r2,-76(fp)
	 }
	 
	 /* set the prefetcher run bit */
	 prefetcher_ctl |= ALT_MSGDMA_PREFETCHER_CTRL_RUN_SET_MASK;
81145c1c:	e0bfed17 	ldw	r2,-76(fp)
81145c20:	10800054 	ori	r2,r2,1
81145c24:	e0bfed15 	stw	r2,-76(fp)
	 /* start the dma since run bit is set */
	 IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, prefetcher_ctl);
81145c28:	e0bffb17 	ldw	r2,-20(fp)
81145c2c:	10800617 	ldw	r2,24(r2)
81145c30:	e0ffed17 	ldw	r3,-76(fp)
81145c34:	10c00035 	stwio	r3,0(r2)
	 
	 /*
	  * Now that access to the registers is complete, release the registers
	  * semaphore so that other threads can access the registers.
	  */
	 ALT_SEM_POST (dev->regs_lock);
81145c38:	e0bffb17 	ldw	r2,-20(fp)
81145c3c:	10801817 	ldw	r2,96(r2)
81145c40:	1009883a 	mov	r4,r2
81145c44:	113ae7c0 	call	8113ae7c <OSSemPost>
	 
	 return 0;
81145c48:	0005883a 	mov	r2,zero
}
81145c4c:	e037883a 	mov	sp,fp
81145c50:	dfc00117 	ldw	ra,4(sp)
81145c54:	df000017 	ldw	fp,0(sp)
81145c58:	dec00204 	addi	sp,sp,8
81145c5c:	f800283a 	ret

81145c60 <alt_msgdma_start_prefetcher_with_std_desc_list>:
int alt_msgdma_start_prefetcher_with_std_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_standard_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{	
81145c60:	defff704 	addi	sp,sp,-36
81145c64:	de00012e 	bgeu	sp,et,81145c6c <alt_msgdma_start_prefetcher_with_std_desc_list+0xc>
81145c68:	003b68fa 	trap	3
81145c6c:	dfc00815 	stw	ra,32(sp)
81145c70:	df000715 	stw	fp,28(sp)
81145c74:	dc400615 	stw	r17,24(sp)
81145c78:	dc000515 	stw	r16,20(sp)
81145c7c:	df000704 	addi	fp,sp,28
81145c80:	e13ffa15 	stw	r4,-24(fp)
81145c84:	e17ffb15 	stw	r5,-20(fp)
81145c88:	3007883a 	mov	r3,r6
81145c8c:	3805883a 	mov	r2,r7
81145c90:	e0fffc05 	stb	r3,-16(fp)
81145c94:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_std_list_own_by_hw_bits(list) != 0){
81145c98:	e13ffb17 	ldw	r4,-20(fp)
81145c9c:	11457cc0 	call	811457cc <alt_msgdma_prefetcher_set_std_list_own_by_hw_bits>
81145ca0:	10000226 	beq	r2,zero,81145cac <alt_msgdma_start_prefetcher_with_std_desc_list+0x4c>
		return -EINVAL;
81145ca4:	00bffa84 	movi	r2,-22
81145ca8:	00000b06 	br	81145cd8 <alt_msgdma_start_prefetcher_with_std_desc_list+0x78>
	}
	
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list,
81145cac:	e0bffb17 	ldw	r2,-20(fp)
81145cb0:	1021883a 	mov	r16,r2
81145cb4:	0023883a 	mov	r17,zero
81145cb8:	e0fffc03 	ldbu	r3,-16(fp)
81145cbc:	e0bffd03 	ldbu	r2,-12(fp)
81145cc0:	d8800015 	stw	r2,0(sp)
81145cc4:	180f883a 	mov	r7,r3
81145cc8:	800b883a 	mov	r5,r16
81145ccc:	880d883a 	mov	r6,r17
81145cd0:	e13ffa17 	ldw	r4,-24(fp)
81145cd4:	11459480 	call	81145948 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81145cd8:	e6fffe04 	addi	sp,fp,-8
81145cdc:	dfc00317 	ldw	ra,12(sp)
81145ce0:	df000217 	ldw	fp,8(sp)
81145ce4:	dc400117 	ldw	r17,4(sp)
81145ce8:	dc000017 	ldw	r16,0(sp)
81145cec:	dec00404 	addi	sp,sp,16
81145cf0:	f800283a 	ret

81145cf4 <alt_msgdma_start_prefetcher_with_extd_desc_list>:
int alt_msgdma_start_prefetcher_with_extd_desc_list (
	alt_msgdma_dev *dev,
	alt_msgdma_prefetcher_extended_descriptor *list,
	alt_u8 park_mode_en,
	alt_u8 poll_en)
{
81145cf4:	defff704 	addi	sp,sp,-36
81145cf8:	de00012e 	bgeu	sp,et,81145d00 <alt_msgdma_start_prefetcher_with_extd_desc_list+0xc>
81145cfc:	003b68fa 	trap	3
81145d00:	dfc00815 	stw	ra,32(sp)
81145d04:	df000715 	stw	fp,28(sp)
81145d08:	dc400615 	stw	r17,24(sp)
81145d0c:	dc000515 	stw	r16,20(sp)
81145d10:	df000704 	addi	fp,sp,28
81145d14:	e13ffa15 	stw	r4,-24(fp)
81145d18:	e17ffb15 	stw	r5,-20(fp)
81145d1c:	3007883a 	mov	r3,r6
81145d20:	3805883a 	mov	r2,r7
81145d24:	e0fffc05 	stb	r3,-16(fp)
81145d28:	e0bffd05 	stb	r2,-12(fp)
	if (alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits(list) != 0){
81145d2c:	e13ffb17 	ldw	r4,-20(fp)
81145d30:	114586c0 	call	8114586c <alt_msgdma_prefetcher_set_extd_list_own_by_hw_bits>
81145d34:	10000226 	beq	r2,zero,81145d40 <alt_msgdma_start_prefetcher_with_extd_desc_list+0x4c>
		return -EINVAL;
81145d38:	00bffa84 	movi	r2,-22
81145d3c:	00000b06 	br	81145d6c <alt_msgdma_start_prefetcher_with_extd_desc_list+0x78>
	}
	return alt_msgdma_start_prefetcher_with_list_addr (dev, (uintptr_t)list, 
81145d40:	e0bffb17 	ldw	r2,-20(fp)
81145d44:	1021883a 	mov	r16,r2
81145d48:	0023883a 	mov	r17,zero
81145d4c:	e0fffc03 	ldbu	r3,-16(fp)
81145d50:	e0bffd03 	ldbu	r2,-12(fp)
81145d54:	d8800015 	stw	r2,0(sp)
81145d58:	180f883a 	mov	r7,r3
81145d5c:	800b883a 	mov	r5,r16
81145d60:	880d883a 	mov	r6,r17
81145d64:	e13ffa17 	ldw	r4,-24(fp)
81145d68:	11459480 	call	81145948 <alt_msgdma_start_prefetcher_with_list_addr>
			park_mode_en, poll_en);
}
81145d6c:	e6fffe04 	addi	sp,fp,-8
81145d70:	dfc00317 	ldw	ra,12(sp)
81145d74:	df000217 	ldw	fp,8(sp)
81145d78:	dc400117 	ldw	r17,4(sp)
81145d7c:	dc000017 	ldw	r16,0(sp)
81145d80:	dec00404 	addi	sp,sp,16
81145d84:	f800283a 	ret

81145d88 <alt_msgdma_open>:
 * Returns:
 * - Pointer to msgdma device instance structure, or null if the device
 *   could not be opened.
 */
alt_msgdma_dev* alt_msgdma_open (const char* name)
{
81145d88:	defffc04 	addi	sp,sp,-16
81145d8c:	de00012e 	bgeu	sp,et,81145d94 <alt_msgdma_open+0xc>
81145d90:	003b68fa 	trap	3
81145d94:	dfc00315 	stw	ra,12(sp)
81145d98:	df000215 	stw	fp,8(sp)
81145d9c:	df000204 	addi	fp,sp,8
81145da0:	e13fff15 	stw	r4,-4(fp)
    alt_msgdma_dev* dev = NULL;
81145da4:	e03ffe15 	stw	zero,-8(fp)

    dev = (alt_msgdma_dev*) alt_find_dev (name, &alt_msgdma_list);
81145da8:	d1603504 	addi	r5,gp,-32556
81145dac:	e13fff17 	ldw	r4,-4(fp)
81145db0:	114632c0 	call	8114632c <alt_find_dev>
81145db4:	e0bffe15 	stw	r2,-8(fp)

    if (NULL == dev)
81145db8:	e0bffe17 	ldw	r2,-8(fp)
81145dbc:	1000041e 	bne	r2,zero,81145dd0 <alt_msgdma_open+0x48>
    {
        ALT_ERRNO = ENODEV;
81145dc0:	1143fec0 	call	81143fec <alt_get_errno>
81145dc4:	1007883a 	mov	r3,r2
81145dc8:	008004c4 	movi	r2,19
81145dcc:	18800015 	stw	r2,0(r3)
    }

    return dev;
81145dd0:	e0bffe17 	ldw	r2,-8(fp)
}
81145dd4:	e037883a 	mov	sp,fp
81145dd8:	dfc00117 	ldw	ra,4(sp)
81145ddc:	df000017 	ldw	fp,0(sp)
81145de0:	dec00204 	addi	sp,sp,8
81145de4:	f800283a 	ret

81145de8 <alt_msgdma_init>:
 * This routine disables interrupts, descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_msgdma_init (alt_msgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
81145de8:	defff604 	addi	sp,sp,-40
81145dec:	de00012e 	bgeu	sp,et,81145df4 <alt_msgdma_init+0xc>
81145df0:	003b68fa 	trap	3
81145df4:	dfc00915 	stw	ra,36(sp)
81145df8:	df000815 	stw	fp,32(sp)
81145dfc:	df000804 	addi	fp,sp,32
81145e00:	e13ffd15 	stw	r4,-12(fp)
81145e04:	e17ffe15 	stw	r5,-8(fp)
81145e08:	e1bfff15 	stw	r6,-4(fp)
    extern alt_llist alt_msgdma_list;
    alt_u32 temporary_control;
    int error;

    if (dev->prefetcher_enable)
81145e0c:	e0bffd17 	ldw	r2,-12(fp)
81145e10:	10801783 	ldbu	r2,94(r2)
81145e14:	10803fcc 	andi	r2,r2,255
81145e18:	10000b26 	beq	r2,zero,81145e48 <alt_msgdma_init+0x60>
    {
    	/* start prefetcher reset sequence */
    	IOWR_ALT_MSGDMA_PREFETCHER_CONTROL(dev->prefetcher_base, 
81145e1c:	e0bffd17 	ldw	r2,-12(fp)
81145e20:	10800617 	ldw	r2,24(r2)
81145e24:	00c00104 	movi	r3,4
81145e28:	10c00035 	stwio	r3,0(r2)
    			ALT_MSGDMA_PREFETCHER_CTRL_RESET_SET_MASK);
    	/* wait until hw clears the bit */
    	while(ALT_MSGDMA_PREFETCHER_CTRL_RESET_GET(
81145e2c:	0001883a 	nop
81145e30:	e0bffd17 	ldw	r2,-12(fp)
81145e34:	10800617 	ldw	r2,24(r2)
81145e38:	10800037 	ldwio	r2,0(r2)
81145e3c:	1080010c 	andi	r2,r2,4
81145e40:	1005d0ba 	srai	r2,r2,2
81145e44:	103ffa1e 	bne	r2,zero,81145e30 <__reset+0xfb125e30>
    }    
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
81145e48:	e0bffd17 	ldw	r2,-12(fp)
81145e4c:	10800317 	ldw	r2,12(r2)
81145e50:	10800104 	addi	r2,r2,4
81145e54:	00c00084 	movi	r3,2
81145e58:	10c00035 	stwio	r3,0(r2)
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81145e5c:	0001883a 	nop
81145e60:	e0bffd17 	ldw	r2,-12(fp)
81145e64:	10800317 	ldw	r2,12(r2)
81145e68:	10800037 	ldwio	r2,0(r2)
    		& ALTERA_MSGDMA_CSR_RESET_STATE_MASK));
81145e6c:	1080100c 	andi	r2,r2,64
    
    /* Reset the registers and FIFOs of the dispatcher and master modules */
    /* set the reset bit, no need to read the control register first since 
    this write is going to clear it out */
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, ALTERA_MSGDMA_CSR_RESET_MASK);
    while(0 != (IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base)
81145e70:	103ffb1e 	bne	r2,zero,81145e60 <__reset+0xfb125e60>
    * Disable interrupts, halt descriptor processing,
    * and clear status register content
    */

    /* disable global interrupt */
    temporary_control = IORD_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base)
81145e74:	e0bffd17 	ldw	r2,-12(fp)
81145e78:	10800317 	ldw	r2,12(r2)
81145e7c:	10800104 	addi	r2,r2,4
81145e80:	10800037 	ldwio	r2,0(r2)
81145e84:	1007883a 	mov	r3,r2
81145e88:	00bffbc4 	movi	r2,-17
81145e8c:	1884703a 	and	r2,r3,r2
81145e90:	e0bff915 	stw	r2,-28(fp)
    		& (~ALTERA_MSGDMA_CSR_GLOBAL_INTERRUPT_MASK);
    /* stopping descriptor */
    temporary_control |= ALTERA_MSGDMA_CSR_STOP_DESCRIPTORS_MASK;
81145e94:	e0bff917 	ldw	r2,-28(fp)
81145e98:	10800814 	ori	r2,r2,32
81145e9c:	e0bff915 	stw	r2,-28(fp)
    IOWR_ALTERA_MSGDMA_CSR_CONTROL(dev->csr_base, temporary_control);
81145ea0:	e0bffd17 	ldw	r2,-12(fp)
81145ea4:	10800317 	ldw	r2,12(r2)
81145ea8:	10800104 	addi	r2,r2,4
81145eac:	e0fff917 	ldw	r3,-28(fp)
81145eb0:	10c00035 	stwio	r3,0(r2)

    /* clear the CSR status register */
    IOWR_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base, 
81145eb4:	e0bffd17 	ldw	r2,-12(fp)
81145eb8:	10800317 	ldw	r2,12(r2)
81145ebc:	e0fffd17 	ldw	r3,-12(fp)
81145ec0:	18c00317 	ldw	r3,12(r3)
81145ec4:	18c00037 	ldwio	r3,0(r3)
81145ec8:	10c00035 	stwio	r3,0(r2)
    		IORD_ALTERA_MSGDMA_CSR_STATUS(dev->csr_base));
    
    if (dev->prefetcher_enable)
81145ecc:	e0bffd17 	ldw	r2,-12(fp)
81145ed0:	10801783 	ldbu	r2,94(r2)
81145ed4:	10803fcc 	andi	r2,r2,255
81145ed8:	10000826 	beq	r2,zero,81145efc <alt_msgdma_init+0x114>
    {
    	/* clear all status bits that are set, since theyre W1C */
    	IOWR_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base, 
81145edc:	e0bffd17 	ldw	r2,-12(fp)
81145ee0:	10800617 	ldw	r2,24(r2)
81145ee4:	10800404 	addi	r2,r2,16
81145ee8:	e0fffd17 	ldw	r3,-12(fp)
81145eec:	18c00617 	ldw	r3,24(r3)
81145ef0:	18c00404 	addi	r3,r3,16
81145ef4:	18c00037 	ldwio	r3,0(r3)
81145ef8:	10c00035 	stwio	r3,0(r2)
    			IORD_ALT_MSGDMA_PREFETCHER_STATUS(dev->prefetcher_base));
    }

    /* Register this instance of the msgdma controller with HAL */
    alt_dev_llist_insert((alt_dev_llist*) dev, &alt_msgdma_list);
81145efc:	d1603504 	addi	r5,gp,-32556
81145f00:	e13ffd17 	ldw	r4,-12(fp)
81145f04:	11462800 	call	81146280 <alt_dev_llist_insert>

    /*
     * Creating semaphores used to protect access to the registers 
     * when running in a multi-threaded environment.
     */
    error = ALT_SEM_CREATE (&dev->regs_lock, 1);
81145f08:	e0bffd17 	ldw	r2,-12(fp)
81145f0c:	10801804 	addi	r2,r2,96
81145f10:	e0bffb15 	stw	r2,-20(fp)
81145f14:	00800044 	movi	r2,1
81145f18:	e0bffc0d 	sth	r2,-16(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
81145f1c:	e0bffc0b 	ldhu	r2,-16(fp)
81145f20:	1009883a 	mov	r4,r2
81145f24:	113a7cc0 	call	8113a7cc <OSSemCreate>
81145f28:	1007883a 	mov	r3,r2
81145f2c:	e0bffb17 	ldw	r2,-20(fp)
81145f30:	10c00015 	stw	r3,0(r2)
  return *sem ? 0 : -1;
81145f34:	e0bffb17 	ldw	r2,-20(fp)
81145f38:	10800017 	ldw	r2,0(r2)
81145f3c:	10000226 	beq	r2,zero,81145f48 <alt_msgdma_init+0x160>
81145f40:	0005883a 	mov	r2,zero
81145f44:	00000106 	br	81145f4c <alt_msgdma_init+0x164>
81145f48:	00bfffc4 	movi	r2,-1
81145f4c:	e0bffa15 	stw	r2,-24(fp)
            
    if (!error)
81145f50:	e0bffa17 	ldw	r2,-24(fp)
81145f54:	1000081e 	bne	r2,zero,81145f78 <alt_msgdma_init+0x190>
    {        
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
81145f58:	d8000015 	stw	zero,0(sp)
81145f5c:	e1fffd17 	ldw	r7,-12(fp)
81145f60:	01a04534 	movhi	r6,33044
81145f64:	31908004 	addi	r6,r6,16896
81145f68:	e17fff17 	ldw	r5,-4(fp)
81145f6c:	e13ffe17 	ldw	r4,-8(fp)
81145f70:	11465b80 	call	811465b8 <alt_ic_isr_register>
    else
    {
        alt_printf("failed to create semaphores\n");
    }
    
    return;
81145f74:	00000406 	br	81145f88 <alt_msgdma_init+0x1a0>
        /* Install IRQ handler */
        alt_ic_isr_register(ic_id, irq, alt_msgdma_irq, dev, 0x0);
    }
    else
    {
        alt_printf("failed to create semaphores\n");
81145f78:	01204574 	movhi	r4,33045
81145f7c:	2132fb04 	addi	r4,r4,-13332
81145f80:	11469d00 	call	811469d0 <alt_printf>
    }
    
    return;
81145f84:	0001883a 	nop

}
81145f88:	e037883a 	mov	sp,fp
81145f8c:	dfc00117 	ldw	ra,4(sp)
81145f90:	df000017 	ldw	fp,0(sp)
81145f94:	dec00204 	addi	sp,sp,8
81145f98:	f800283a 	ret

81145f9c <alt_msgdma_register_callback>:
void alt_msgdma_register_callback(
	alt_msgdma_dev *dev,
	alt_msgdma_callback callback,
	alt_u32 control,
	void *context)
{
81145f9c:	defffb04 	addi	sp,sp,-20
81145fa0:	de00012e 	bgeu	sp,et,81145fa8 <alt_msgdma_register_callback+0xc>
81145fa4:	003b68fa 	trap	3
81145fa8:	df000415 	stw	fp,16(sp)
81145fac:	df000404 	addi	fp,sp,16
81145fb0:	e13ffc15 	stw	r4,-16(fp)
81145fb4:	e17ffd15 	stw	r5,-12(fp)
81145fb8:	e1bffe15 	stw	r6,-8(fp)
81145fbc:	e1ffff15 	stw	r7,-4(fp)
    dev->callback         = callback;
81145fc0:	e0bffc17 	ldw	r2,-16(fp)
81145fc4:	e0fffd17 	ldw	r3,-12(fp)
81145fc8:	10c00b15 	stw	r3,44(r2)
    dev->callback_context = context;
81145fcc:	e0bffc17 	ldw	r2,-16(fp)
81145fd0:	e0ffff17 	ldw	r3,-4(fp)
81145fd4:	10c00c15 	stw	r3,48(r2)
    dev->control          = control;
81145fd8:	e0bffc17 	ldw	r2,-16(fp)
81145fdc:	e0fffe17 	ldw	r3,-8(fp)
81145fe0:	10c00d15 	stw	r3,52(r2)

    return ;
81145fe4:	0001883a 	nop
}
81145fe8:	e037883a 	mov	sp,fp
81145fec:	df000017 	ldw	fp,0(sp)
81145ff0:	dec00104 	addi	sp,sp,4
81145ff4:	f800283a 	ret

81145ff8 <alt_msgdma_standard_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_standard_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81145ff8:	defffc04 	addi	sp,sp,-16
81145ffc:	de00012e 	bgeu	sp,et,81146004 <alt_msgdma_standard_descriptor_async_transfer+0xc>
81146000:	003b68fa 	trap	3
81146004:	dfc00315 	stw	ra,12(sp)
81146008:	df000215 	stw	fp,8(sp)
8114600c:	df000204 	addi	fp,sp,8
81146010:	e13ffe15 	stw	r4,-8(fp)
81146014:	e17fff15 	stw	r5,-4(fp)
   /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
    return alt_msgdma_descriptor_async_transfer(dev, desc, NULL);
81146018:	000d883a 	mov	r6,zero
8114601c:	e17fff17 	ldw	r5,-4(fp)
81146020:	e13ffe17 	ldw	r4,-8(fp)
81146024:	114457c0 	call	8114457c <alt_msgdma_descriptor_async_transfer>

}
81146028:	e037883a 	mov	sp,fp
8114602c:	dfc00117 	ldw	ra,4(sp)
81146030:	df000017 	ldw	fp,0(sp)
81146034:	dec00204 	addi	sp,sp,8
81146038:	f800283a 	ret

8114603c <alt_msgdma_extended_descriptor_async_transfer>:
 * -ETIME -> Time out and skipping the looping after 5 msec.
 */
int alt_msgdma_extended_descriptor_async_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
8114603c:	defffc04 	addi	sp,sp,-16
81146040:	de00012e 	bgeu	sp,et,81146048 <alt_msgdma_extended_descriptor_async_transfer+0xc>
81146044:	003b68fa 	trap	3
81146048:	dfc00315 	stw	ra,12(sp)
8114604c:	df000215 	stw	fp,8(sp)
81146050:	df000204 	addi	fp,sp,8
81146054:	e13ffe15 	stw	r4,-8(fp)
81146058:	e17fff15 	stw	r5,-4(fp)
    /*
    * Error detection/handling should be performed at the application
    * or callback level as appropriate.
    */
    return alt_msgdma_descriptor_async_transfer(dev, NULL, desc);
8114605c:	e1bfff17 	ldw	r6,-4(fp)
81146060:	000b883a 	mov	r5,zero
81146064:	e13ffe17 	ldw	r4,-8(fp)
81146068:	114457c0 	call	8114457c <alt_msgdma_descriptor_async_transfer>
}
8114606c:	e037883a 	mov	sp,fp
81146070:	dfc00117 	ldw	ra,4(sp)
81146074:	df000017 	ldw	fp,0(sp)
81146078:	dec00204 	addi	sp,sp,8
8114607c:	f800283a 	ret

81146080 <alt_msgdma_standard_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_standard_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_standard_descriptor *desc)
{
81146080:	defffc04 	addi	sp,sp,-16
81146084:	de00012e 	bgeu	sp,et,8114608c <alt_msgdma_standard_descriptor_sync_transfer+0xc>
81146088:	003b68fa 	trap	3
8114608c:	dfc00315 	stw	ra,12(sp)
81146090:	df000215 	stw	fp,8(sp)
81146094:	df000204 	addi	fp,sp,8
81146098:	e13ffe15 	stw	r4,-8(fp)
8114609c:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, desc, NULL);
811460a0:	000d883a 	mov	r6,zero
811460a4:	e17fff17 	ldw	r5,-4(fp)
811460a8:	e13ffe17 	ldw	r4,-8(fp)
811460ac:	11448bc0 	call	811448bc <alt_msgdma_descriptor_sync_transfer>
}
811460b0:	e037883a 	mov	sp,fp
811460b4:	dfc00117 	ldw	ra,4(sp)
811460b8:	df000017 	ldw	fp,0(sp)
811460bc:	dec00204 	addi	sp,sp,8
811460c0:	f800283a 	ret

811460c4 <alt_msgdma_extended_descriptor_sync_transfer>:
 *           return -ETIME (Time out and skipping the looping after 5 msec)
 */
int alt_msgdma_extended_descriptor_sync_transfer(
	alt_msgdma_dev *dev,
	alt_msgdma_extended_descriptor *desc)
{
811460c4:	defffc04 	addi	sp,sp,-16
811460c8:	de00012e 	bgeu	sp,et,811460d0 <alt_msgdma_extended_descriptor_sync_transfer+0xc>
811460cc:	003b68fa 	trap	3
811460d0:	dfc00315 	stw	ra,12(sp)
811460d4:	df000215 	stw	fp,8(sp)
811460d8:	df000204 	addi	fp,sp,8
811460dc:	e13ffe15 	stw	r4,-8(fp)
811460e0:	e17fff15 	stw	r5,-4(fp)
    return alt_msgdma_descriptor_sync_transfer(dev, NULL, desc);
811460e4:	e1bfff17 	ldw	r6,-4(fp)
811460e8:	000b883a 	mov	r5,zero
811460ec:	e13ffe17 	ldw	r4,-8(fp)
811460f0:	11448bc0 	call	811448bc <alt_msgdma_descriptor_sync_transfer>
}
811460f4:	e037883a 	mov	sp,fp
811460f8:	dfc00117 	ldw	ra,4(sp)
811460fc:	df000017 	ldw	fp,0(sp)
81146100:	dec00204 	addi	sp,sp,8
81146104:	f800283a 	ret

81146108 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
81146108:	defff504 	addi	sp,sp,-44
8114610c:	de00012e 	bgeu	sp,et,81146114 <alt_alarm_start+0xc>
81146110:	003b68fa 	trap	3
81146114:	df000a15 	stw	fp,40(sp)
81146118:	df000a04 	addi	fp,sp,40
8114611c:	e13ffc15 	stw	r4,-16(fp)
81146120:	e17ffd15 	stw	r5,-12(fp)
81146124:	e1bffe15 	stw	r6,-8(fp)
81146128:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
8114612c:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
81146130:	d0a08417 	ldw	r2,-32240(gp)
  
  if (alt_ticks_per_second ())
81146134:	10003c26 	beq	r2,zero,81146228 <alt_alarm_start+0x120>
  {
    if (alarm)
81146138:	e0bffc17 	ldw	r2,-16(fp)
8114613c:	10003826 	beq	r2,zero,81146220 <alt_alarm_start+0x118>
    {
      alarm->callback = callback;
81146140:	e0bffc17 	ldw	r2,-16(fp)
81146144:	e0fffe17 	ldw	r3,-8(fp)
81146148:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
8114614c:	e0bffc17 	ldw	r2,-16(fp)
81146150:	e0ffff17 	ldw	r3,-4(fp)
81146154:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146158:	0005303a 	rdctl	r2,status
8114615c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
81146160:	e0fff917 	ldw	r3,-28(fp)
81146164:	00bfff84 	movi	r2,-2
81146168:	1884703a 	and	r2,r3,r2
8114616c:	1001703a 	wrctl	status,r2
  
  return context;
81146170:	e0bff917 	ldw	r2,-28(fp)
 
      irq_context = alt_irq_disable_all ();
81146174:	e0bff815 	stw	r2,-32(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
81146178:	d0a08517 	ldw	r2,-32236(gp)
      
      current_nticks = alt_nticks();
8114617c:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
81146180:	e0fffd17 	ldw	r3,-12(fp)
81146184:	e0bff617 	ldw	r2,-40(fp)
81146188:	1885883a 	add	r2,r3,r2
8114618c:	10c00044 	addi	r3,r2,1
81146190:	e0bffc17 	ldw	r2,-16(fp)
81146194:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
81146198:	e0bffc17 	ldw	r2,-16(fp)
8114619c:	10c00217 	ldw	r3,8(r2)
811461a0:	e0bff617 	ldw	r2,-40(fp)
811461a4:	1880042e 	bgeu	r3,r2,811461b8 <alt_alarm_start+0xb0>
      {
        alarm->rollover = 1;
811461a8:	e0bffc17 	ldw	r2,-16(fp)
811461ac:	00c00044 	movi	r3,1
811461b0:	10c00405 	stb	r3,16(r2)
811461b4:	00000206 	br	811461c0 <alt_alarm_start+0xb8>
      }
      else
      {
        alarm->rollover = 0;
811461b8:	e0bffc17 	ldw	r2,-16(fp)
811461bc:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
811461c0:	e0bffc17 	ldw	r2,-16(fp)
811461c4:	d0e01404 	addi	r3,gp,-32688
811461c8:	e0fffa15 	stw	r3,-24(fp)
811461cc:	e0bffb15 	stw	r2,-20(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811461d0:	e0bffb17 	ldw	r2,-20(fp)
811461d4:	e0fffa17 	ldw	r3,-24(fp)
811461d8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811461dc:	e0bffa17 	ldw	r2,-24(fp)
811461e0:	10c00017 	ldw	r3,0(r2)
811461e4:	e0bffb17 	ldw	r2,-20(fp)
811461e8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811461ec:	e0bffa17 	ldw	r2,-24(fp)
811461f0:	10800017 	ldw	r2,0(r2)
811461f4:	e0fffb17 	ldw	r3,-20(fp)
811461f8:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
811461fc:	e0bffa17 	ldw	r2,-24(fp)
81146200:	e0fffb17 	ldw	r3,-20(fp)
81146204:	10c00015 	stw	r3,0(r2)
81146208:	e0bff817 	ldw	r2,-32(fp)
8114620c:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146210:	e0bff717 	ldw	r2,-36(fp)
81146214:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
81146218:	0005883a 	mov	r2,zero
8114621c:	00000306 	br	8114622c <alt_alarm_start+0x124>
    }
    else
    {
      return -EINVAL;
81146220:	00bffa84 	movi	r2,-22
81146224:	00000106 	br	8114622c <alt_alarm_start+0x124>
    }
  }
  else
  {
    return -ENOTSUP;
81146228:	00bfde84 	movi	r2,-134
  }
}
8114622c:	e037883a 	mov	sp,fp
81146230:	df000017 	ldw	fp,0(sp)
81146234:	dec00104 	addi	sp,sp,4
81146238:	f800283a 	ret

8114623c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
8114623c:	defffe04 	addi	sp,sp,-8
81146240:	de00012e 	bgeu	sp,et,81146248 <alt_get_errno+0xc>
81146244:	003b68fa 	trap	3
81146248:	dfc00115 	stw	ra,4(sp)
8114624c:	df000015 	stw	fp,0(sp)
81146250:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
81146254:	d0a01017 	ldw	r2,-32704(gp)
81146258:	10000326 	beq	r2,zero,81146268 <alt_get_errno+0x2c>
8114625c:	d0a01017 	ldw	r2,-32704(gp)
81146260:	103ee83a 	callr	r2
81146264:	00000106 	br	8114626c <alt_get_errno+0x30>
81146268:	d0a07404 	addi	r2,gp,-32304
}
8114626c:	e037883a 	mov	sp,fp
81146270:	dfc00117 	ldw	ra,4(sp)
81146274:	df000017 	ldw	fp,0(sp)
81146278:	dec00204 	addi	sp,sp,8
8114627c:	f800283a 	ret

81146280 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
81146280:	defffa04 	addi	sp,sp,-24
81146284:	de00012e 	bgeu	sp,et,8114628c <alt_dev_llist_insert+0xc>
81146288:	003b68fa 	trap	3
8114628c:	dfc00515 	stw	ra,20(sp)
81146290:	df000415 	stw	fp,16(sp)
81146294:	df000404 	addi	fp,sp,16
81146298:	e13ffe15 	stw	r4,-8(fp)
8114629c:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
811462a0:	e0bffe17 	ldw	r2,-8(fp)
811462a4:	10000326 	beq	r2,zero,811462b4 <alt_dev_llist_insert+0x34>
811462a8:	e0bffe17 	ldw	r2,-8(fp)
811462ac:	10800217 	ldw	r2,8(r2)
811462b0:	1000061e 	bne	r2,zero,811462cc <alt_dev_llist_insert+0x4c>
  {
    ALT_ERRNO = EINVAL;
811462b4:	114623c0 	call	8114623c <alt_get_errno>
811462b8:	1007883a 	mov	r3,r2
811462bc:	00800584 	movi	r2,22
811462c0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
811462c4:	00bffa84 	movi	r2,-22
811462c8:	00001306 	br	81146318 <alt_dev_llist_insert+0x98>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
811462cc:	e0bffe17 	ldw	r2,-8(fp)
811462d0:	e0ffff17 	ldw	r3,-4(fp)
811462d4:	e0fffc15 	stw	r3,-16(fp)
811462d8:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
811462dc:	e0bffd17 	ldw	r2,-12(fp)
811462e0:	e0fffc17 	ldw	r3,-16(fp)
811462e4:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
811462e8:	e0bffc17 	ldw	r2,-16(fp)
811462ec:	10c00017 	ldw	r3,0(r2)
811462f0:	e0bffd17 	ldw	r2,-12(fp)
811462f4:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
811462f8:	e0bffc17 	ldw	r2,-16(fp)
811462fc:	10800017 	ldw	r2,0(r2)
81146300:	e0fffd17 	ldw	r3,-12(fp)
81146304:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
81146308:	e0bffc17 	ldw	r2,-16(fp)
8114630c:	e0fffd17 	ldw	r3,-12(fp)
81146310:	10c00015 	stw	r3,0(r2)

  return 0;  
81146314:	0005883a 	mov	r2,zero
}
81146318:	e037883a 	mov	sp,fp
8114631c:	dfc00117 	ldw	ra,4(sp)
81146320:	df000017 	ldw	fp,0(sp)
81146324:	dec00204 	addi	sp,sp,8
81146328:	f800283a 	ret

8114632c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
8114632c:	defffa04 	addi	sp,sp,-24
81146330:	de00012e 	bgeu	sp,et,81146338 <alt_find_dev+0xc>
81146334:	003b68fa 	trap	3
81146338:	dfc00515 	stw	ra,20(sp)
8114633c:	df000415 	stw	fp,16(sp)
81146340:	df000404 	addi	fp,sp,16
81146344:	e13ffe15 	stw	r4,-8(fp)
81146348:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
8114634c:	e0bfff17 	ldw	r2,-4(fp)
81146350:	10800017 	ldw	r2,0(r2)
81146354:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
81146358:	e13ffe17 	ldw	r4,-8(fp)
8114635c:	111e5bc0 	call	8111e5bc <strlen>
81146360:	10800044 	addi	r2,r2,1
81146364:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
81146368:	00000d06 	br	811463a0 <alt_find_dev+0x74>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
8114636c:	e0bffc17 	ldw	r2,-16(fp)
81146370:	10800217 	ldw	r2,8(r2)
81146374:	e0fffd17 	ldw	r3,-12(fp)
81146378:	180d883a 	mov	r6,r3
8114637c:	e17ffe17 	ldw	r5,-8(fp)
81146380:	1009883a 	mov	r4,r2
81146384:	11471400 	call	81147140 <memcmp>
81146388:	1000021e 	bne	r2,zero,81146394 <alt_find_dev+0x68>
    {
      /* match found */

      return next;
8114638c:	e0bffc17 	ldw	r2,-16(fp)
81146390:	00000706 	br	811463b0 <alt_find_dev+0x84>
    }
    next = (alt_dev*) next->llist.next;
81146394:	e0bffc17 	ldw	r2,-16(fp)
81146398:	10800017 	ldw	r2,0(r2)
8114639c:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
811463a0:	e0fffc17 	ldw	r3,-16(fp)
811463a4:	e0bfff17 	ldw	r2,-4(fp)
811463a8:	18bff01e 	bne	r3,r2,8114636c <__reset+0xfb12636c>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
811463ac:	0005883a 	mov	r2,zero
}
811463b0:	e037883a 	mov	sp,fp
811463b4:	dfc00117 	ldw	ra,4(sp)
811463b8:	df000017 	ldw	fp,0(sp)
811463bc:	dec00204 	addi	sp,sp,8
811463c0:	f800283a 	ret

811463c4 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
811463c4:	defffb04 	addi	sp,sp,-20
811463c8:	de00012e 	bgeu	sp,et,811463d0 <alt_find_file+0xc>
811463cc:	003b68fa 	trap	3
811463d0:	dfc00415 	stw	ra,16(sp)
811463d4:	df000315 	stw	fp,12(sp)
811463d8:	df000304 	addi	fp,sp,12
811463dc:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
811463e0:	d0a00b17 	ldw	r2,-32724(gp)
811463e4:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
811463e8:	00003106 	br	811464b0 <alt_find_file+0xec>
  {
    len = strlen(next->name);
811463ec:	e0bffd17 	ldw	r2,-12(fp)
811463f0:	10800217 	ldw	r2,8(r2)
811463f4:	1009883a 	mov	r4,r2
811463f8:	111e5bc0 	call	8111e5bc <strlen>
811463fc:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
81146400:	e0bffd17 	ldw	r2,-12(fp)
81146404:	10c00217 	ldw	r3,8(r2)
81146408:	e0bffe17 	ldw	r2,-8(fp)
8114640c:	10bfffc4 	addi	r2,r2,-1
81146410:	1885883a 	add	r2,r3,r2
81146414:	10800003 	ldbu	r2,0(r2)
81146418:	10803fcc 	andi	r2,r2,255
8114641c:	1080201c 	xori	r2,r2,128
81146420:	10bfe004 	addi	r2,r2,-128
81146424:	10800bd8 	cmpnei	r2,r2,47
81146428:	1000031e 	bne	r2,zero,81146438 <alt_find_file+0x74>
    {
      len -= 1;
8114642c:	e0bffe17 	ldw	r2,-8(fp)
81146430:	10bfffc4 	addi	r2,r2,-1
81146434:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81146438:	e0bffe17 	ldw	r2,-8(fp)
8114643c:	e0ffff17 	ldw	r3,-4(fp)
81146440:	1885883a 	add	r2,r3,r2
81146444:	10800003 	ldbu	r2,0(r2)
81146448:	10803fcc 	andi	r2,r2,255
8114644c:	1080201c 	xori	r2,r2,128
81146450:	10bfe004 	addi	r2,r2,-128
81146454:	10800be0 	cmpeqi	r2,r2,47
81146458:	1000081e 	bne	r2,zero,8114647c <alt_find_file+0xb8>
8114645c:	e0bffe17 	ldw	r2,-8(fp)
81146460:	e0ffff17 	ldw	r3,-4(fp)
81146464:	1885883a 	add	r2,r3,r2
81146468:	10800003 	ldbu	r2,0(r2)
8114646c:	10803fcc 	andi	r2,r2,255
81146470:	1080201c 	xori	r2,r2,128
81146474:	10bfe004 	addi	r2,r2,-128
81146478:	10000a1e 	bne	r2,zero,811464a4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
8114647c:	e0bffd17 	ldw	r2,-12(fp)
81146480:	10800217 	ldw	r2,8(r2)
81146484:	e0fffe17 	ldw	r3,-8(fp)
81146488:	180d883a 	mov	r6,r3
8114648c:	e17fff17 	ldw	r5,-4(fp)
81146490:	1009883a 	mov	r4,r2
81146494:	11471400 	call	81147140 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
81146498:	1000021e 	bne	r2,zero,811464a4 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
8114649c:	e0bffd17 	ldw	r2,-12(fp)
811464a0:	00000706 	br	811464c0 <alt_find_file+0xfc>
    }
    next = (alt_dev*) next->llist.next;
811464a4:	e0bffd17 	ldw	r2,-12(fp)
811464a8:	10800017 	ldw	r2,0(r2)
811464ac:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
811464b0:	e0fffd17 	ldw	r3,-12(fp)
811464b4:	d0a00b04 	addi	r2,gp,-32724
811464b8:	18bfcc1e 	bne	r3,r2,811463ec <__reset+0xfb1263ec>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
811464bc:	0005883a 	mov	r2,zero
}
811464c0:	e037883a 	mov	sp,fp
811464c4:	dfc00117 	ldw	ra,4(sp)
811464c8:	df000017 	ldw	fp,0(sp)
811464cc:	dec00204 	addi	sp,sp,8
811464d0:	f800283a 	ret

811464d4 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
811464d4:	defff904 	addi	sp,sp,-28
811464d8:	de00012e 	bgeu	sp,et,811464e0 <alt_get_fd+0xc>
811464dc:	003b68fa 	trap	3
811464e0:	dfc00615 	stw	ra,24(sp)
811464e4:	df000515 	stw	fp,20(sp)
811464e8:	df000504 	addi	fp,sp,20
811464ec:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
811464f0:	00bffa04 	movi	r2,-24
811464f4:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
811464f8:	d0a07b17 	ldw	r2,-32276(gp)
811464fc:	e0bffd15 	stw	r2,-12(fp)
81146500:	e03ffe0d 	sth	zero,-8(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
81146504:	e0bffe0b 	ldhu	r2,-8(fp)
81146508:	e0fffe84 	addi	r3,fp,-6
8114650c:	180d883a 	mov	r6,r3
81146510:	100b883a 	mov	r5,r2
81146514:	e13ffd17 	ldw	r4,-12(fp)
81146518:	113aaf40 	call	8113aaf4 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114651c:	e03ffb15 	stw	zero,-20(fp)
81146520:	00001906 	br	81146588 <alt_get_fd+0xb4>
  {
    if (!alt_fd_list[i].dev)
81146524:	00a04574 	movhi	r2,33045
81146528:	10b56a04 	addi	r2,r2,-10840
8114652c:	e0fffb17 	ldw	r3,-20(fp)
81146530:	18c00324 	muli	r3,r3,12
81146534:	10c5883a 	add	r2,r2,r3
81146538:	10800017 	ldw	r2,0(r2)
8114653c:	10000f1e 	bne	r2,zero,8114657c <alt_get_fd+0xa8>
    {
      alt_fd_list[i].dev = dev;
81146540:	00a04574 	movhi	r2,33045
81146544:	10b56a04 	addi	r2,r2,-10840
81146548:	e0fffb17 	ldw	r3,-20(fp)
8114654c:	18c00324 	muli	r3,r3,12
81146550:	10c5883a 	add	r2,r2,r3
81146554:	e0ffff17 	ldw	r3,-4(fp)
81146558:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
8114655c:	d0e00f17 	ldw	r3,-32708(gp)
81146560:	e0bffb17 	ldw	r2,-20(fp)
81146564:	1880020e 	bge	r3,r2,81146570 <alt_get_fd+0x9c>
      {
        alt_max_fd = i;
81146568:	e0bffb17 	ldw	r2,-20(fp)
8114656c:	d0a00f15 	stw	r2,-32708(gp)
      }
      rc = i;
81146570:	e0bffb17 	ldw	r2,-20(fp)
81146574:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
81146578:	00000606 	br	81146594 <alt_get_fd+0xc0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
8114657c:	e0bffb17 	ldw	r2,-20(fp)
81146580:	10800044 	addi	r2,r2,1
81146584:	e0bffb15 	stw	r2,-20(fp)
81146588:	e0bffb17 	ldw	r2,-20(fp)
8114658c:	10800810 	cmplti	r2,r2,32
81146590:	103fe41e 	bne	r2,zero,81146524 <__reset+0xfb126524>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
81146594:	d0a07b17 	ldw	r2,-32276(gp)
81146598:	1009883a 	mov	r4,r2
8114659c:	113ae7c0 	call	8113ae7c <OSSemPost>

  return rc;
811465a0:	e0bffc17 	ldw	r2,-16(fp)
}
811465a4:	e037883a 	mov	sp,fp
811465a8:	dfc00117 	ldw	ra,4(sp)
811465ac:	df000017 	ldw	fp,0(sp)
811465b0:	dec00204 	addi	sp,sp,8
811465b4:	f800283a 	ret

811465b8 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
811465b8:	defff904 	addi	sp,sp,-28
811465bc:	de00012e 	bgeu	sp,et,811465c4 <alt_ic_isr_register+0xc>
811465c0:	003b68fa 	trap	3
811465c4:	dfc00615 	stw	ra,24(sp)
811465c8:	df000515 	stw	fp,20(sp)
811465cc:	df000504 	addi	fp,sp,20
811465d0:	e13ffc15 	stw	r4,-16(fp)
811465d4:	e17ffd15 	stw	r5,-12(fp)
811465d8:	e1bffe15 	stw	r6,-8(fp)
811465dc:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
811465e0:	e0800217 	ldw	r2,8(fp)
811465e4:	d8800015 	stw	r2,0(sp)
811465e8:	e1ffff17 	ldw	r7,-4(fp)
811465ec:	e1bffe17 	ldw	r6,-8(fp)
811465f0:	e17ffd17 	ldw	r5,-12(fp)
811465f4:	e13ffc17 	ldw	r4,-16(fp)
811465f8:	11467880 	call	81146788 <alt_iic_isr_register>
}  
811465fc:	e037883a 	mov	sp,fp
81146600:	dfc00117 	ldw	ra,4(sp)
81146604:	df000017 	ldw	fp,0(sp)
81146608:	dec00204 	addi	sp,sp,8
8114660c:	f800283a 	ret

81146610 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
81146610:	defff904 	addi	sp,sp,-28
81146614:	de00012e 	bgeu	sp,et,8114661c <alt_ic_irq_enable+0xc>
81146618:	003b68fa 	trap	3
8114661c:	df000615 	stw	fp,24(sp)
81146620:	df000604 	addi	fp,sp,24
81146624:	e13ffe15 	stw	r4,-8(fp)
81146628:	e17fff15 	stw	r5,-4(fp)
8114662c:	e0bfff17 	ldw	r2,-4(fp)
81146630:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
81146634:	0005303a 	rdctl	r2,status
81146638:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
8114663c:	e0fffb17 	ldw	r3,-20(fp)
81146640:	00bfff84 	movi	r2,-2
81146644:	1884703a 	and	r2,r3,r2
81146648:	1001703a 	wrctl	status,r2
  
  return context;
8114664c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
81146650:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
81146654:	00c00044 	movi	r3,1
81146658:	e0bffa17 	ldw	r2,-24(fp)
8114665c:	1884983a 	sll	r2,r3,r2
81146660:	1007883a 	mov	r3,r2
81146664:	d0a07c17 	ldw	r2,-32272(gp)
81146668:	1884b03a 	or	r2,r3,r2
8114666c:	d0a07c15 	stw	r2,-32272(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81146670:	d0a07c17 	ldw	r2,-32272(gp)
81146674:	100170fa 	wrctl	ienable,r2
81146678:	e0bffc17 	ldw	r2,-16(fp)
8114667c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146680:	e0bffd17 	ldw	r2,-12(fp)
81146684:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
81146688:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
8114668c:	0001883a 	nop
}
81146690:	e037883a 	mov	sp,fp
81146694:	df000017 	ldw	fp,0(sp)
81146698:	dec00104 	addi	sp,sp,4
8114669c:	f800283a 	ret

811466a0 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
811466a0:	defff904 	addi	sp,sp,-28
811466a4:	de00012e 	bgeu	sp,et,811466ac <alt_ic_irq_disable+0xc>
811466a8:	003b68fa 	trap	3
811466ac:	df000615 	stw	fp,24(sp)
811466b0:	df000604 	addi	fp,sp,24
811466b4:	e13ffe15 	stw	r4,-8(fp)
811466b8:	e17fff15 	stw	r5,-4(fp)
811466bc:	e0bfff17 	ldw	r2,-4(fp)
811466c0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811466c4:	0005303a 	rdctl	r2,status
811466c8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811466cc:	e0fffb17 	ldw	r3,-20(fp)
811466d0:	00bfff84 	movi	r2,-2
811466d4:	1884703a 	and	r2,r3,r2
811466d8:	1001703a 	wrctl	status,r2
  
  return context;
811466dc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
811466e0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
811466e4:	00c00044 	movi	r3,1
811466e8:	e0bffa17 	ldw	r2,-24(fp)
811466ec:	1884983a 	sll	r2,r3,r2
811466f0:	0084303a 	nor	r2,zero,r2
811466f4:	1007883a 	mov	r3,r2
811466f8:	d0a07c17 	ldw	r2,-32272(gp)
811466fc:	1884703a 	and	r2,r3,r2
81146700:	d0a07c15 	stw	r2,-32272(gp)
  NIOS2_WRITE_IENABLE (alt_irq_active);
81146704:	d0a07c17 	ldw	r2,-32272(gp)
81146708:	100170fa 	wrctl	ienable,r2
8114670c:	e0bffc17 	ldw	r2,-16(fp)
81146710:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146714:	e0bffd17 	ldw	r2,-12(fp)
81146718:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
8114671c:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
81146720:	0001883a 	nop
}
81146724:	e037883a 	mov	sp,fp
81146728:	df000017 	ldw	fp,0(sp)
8114672c:	dec00104 	addi	sp,sp,4
81146730:	f800283a 	ret

81146734 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
81146734:	defffc04 	addi	sp,sp,-16
81146738:	de00012e 	bgeu	sp,et,81146740 <alt_ic_irq_enabled+0xc>
8114673c:	003b68fa 	trap	3
81146740:	df000315 	stw	fp,12(sp)
81146744:	df000304 	addi	fp,sp,12
81146748:	e13ffe15 	stw	r4,-8(fp)
8114674c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
81146750:	000530fa 	rdctl	r2,ienable
81146754:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
81146758:	00c00044 	movi	r3,1
8114675c:	e0bfff17 	ldw	r2,-4(fp)
81146760:	1884983a 	sll	r2,r3,r2
81146764:	1007883a 	mov	r3,r2
81146768:	e0bffd17 	ldw	r2,-12(fp)
8114676c:	1884703a 	and	r2,r3,r2
81146770:	1004c03a 	cmpne	r2,r2,zero
81146774:	10803fcc 	andi	r2,r2,255
}
81146778:	e037883a 	mov	sp,fp
8114677c:	df000017 	ldw	fp,0(sp)
81146780:	dec00104 	addi	sp,sp,4
81146784:	f800283a 	ret

81146788 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
81146788:	defff504 	addi	sp,sp,-44
8114678c:	de00012e 	bgeu	sp,et,81146794 <alt_iic_isr_register+0xc>
81146790:	003b68fa 	trap	3
81146794:	dfc00a15 	stw	ra,40(sp)
81146798:	df000915 	stw	fp,36(sp)
8114679c:	df000904 	addi	fp,sp,36
811467a0:	e13ffc15 	stw	r4,-16(fp)
811467a4:	e17ffd15 	stw	r5,-12(fp)
811467a8:	e1bffe15 	stw	r6,-8(fp)
811467ac:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
811467b0:	00bffa84 	movi	r2,-22
811467b4:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
811467b8:	e0bffd17 	ldw	r2,-12(fp)
811467bc:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
811467c0:	e0bff817 	ldw	r2,-32(fp)
811467c4:	10800808 	cmpgei	r2,r2,32
811467c8:	1000271e 	bne	r2,zero,81146868 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
811467cc:	0005303a 	rdctl	r2,status
811467d0:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
811467d4:	e0fffb17 	ldw	r3,-20(fp)
811467d8:	00bfff84 	movi	r2,-2
811467dc:	1884703a 	and	r2,r3,r2
811467e0:	1001703a 	wrctl	status,r2
  
  return context;
811467e4:	e0bffb17 	ldw	r2,-20(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
811467e8:	e0bffa15 	stw	r2,-24(fp)

    alt_irq[id].handler = isr;
811467ec:	00a045f4 	movhi	r2,33047
811467f0:	10a28504 	addi	r2,r2,-30188
811467f4:	e0fff817 	ldw	r3,-32(fp)
811467f8:	180690fa 	slli	r3,r3,3
811467fc:	10c5883a 	add	r2,r2,r3
81146800:	e0fffe17 	ldw	r3,-8(fp)
81146804:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
81146808:	00a045f4 	movhi	r2,33047
8114680c:	10a28504 	addi	r2,r2,-30188
81146810:	e0fff817 	ldw	r3,-32(fp)
81146814:	180690fa 	slli	r3,r3,3
81146818:	10c5883a 	add	r2,r2,r3
8114681c:	10800104 	addi	r2,r2,4
81146820:	e0ffff17 	ldw	r3,-4(fp)
81146824:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
81146828:	e0bffe17 	ldw	r2,-8(fp)
8114682c:	10000526 	beq	r2,zero,81146844 <alt_iic_isr_register+0xbc>
81146830:	e0bff817 	ldw	r2,-32(fp)
81146834:	100b883a 	mov	r5,r2
81146838:	e13ffc17 	ldw	r4,-16(fp)
8114683c:	11466100 	call	81146610 <alt_ic_irq_enable>
81146840:	00000406 	br	81146854 <alt_iic_isr_register+0xcc>
81146844:	e0bff817 	ldw	r2,-32(fp)
81146848:	100b883a 	mov	r5,r2
8114684c:	e13ffc17 	ldw	r4,-16(fp)
81146850:	11466a00 	call	811466a0 <alt_ic_irq_disable>
81146854:	e0bff715 	stw	r2,-36(fp)
81146858:	e0bffa17 	ldw	r2,-24(fp)
8114685c:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
81146860:	e0bff917 	ldw	r2,-28(fp)
81146864:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
81146868:	e0bff717 	ldw	r2,-36(fp)
}
8114686c:	e037883a 	mov	sp,fp
81146870:	dfc00117 	ldw	ra,4(sp)
81146874:	df000017 	ldw	fp,0(sp)
81146878:	dec00204 	addi	sp,sp,8
8114687c:	f800283a 	ret

81146880 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
81146880:	defff904 	addi	sp,sp,-28
81146884:	de00012e 	bgeu	sp,et,8114688c <alt_open_fd+0xc>
81146888:	003b68fa 	trap	3
8114688c:	dfc00615 	stw	ra,24(sp)
81146890:	df000515 	stw	fp,20(sp)
81146894:	df000504 	addi	fp,sp,20
81146898:	e13ffc15 	stw	r4,-16(fp)
8114689c:	e17ffd15 	stw	r5,-12(fp)
811468a0:	e1bffe15 	stw	r6,-8(fp)
811468a4:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
811468a8:	e1bfff17 	ldw	r6,-4(fp)
811468ac:	e17ffe17 	ldw	r5,-8(fp)
811468b0:	e13ffd17 	ldw	r4,-12(fp)
811468b4:	11337300 	call	81133730 <open>
811468b8:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
811468bc:	e0bffb17 	ldw	r2,-20(fp)
811468c0:	10001c16 	blt	r2,zero,81146934 <alt_open_fd+0xb4>
  {
    fd->dev      = alt_fd_list[old].dev;
811468c4:	00a04574 	movhi	r2,33045
811468c8:	10b56a04 	addi	r2,r2,-10840
811468cc:	e0fffb17 	ldw	r3,-20(fp)
811468d0:	18c00324 	muli	r3,r3,12
811468d4:	10c5883a 	add	r2,r2,r3
811468d8:	10c00017 	ldw	r3,0(r2)
811468dc:	e0bffc17 	ldw	r2,-16(fp)
811468e0:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
811468e4:	00a04574 	movhi	r2,33045
811468e8:	10b56a04 	addi	r2,r2,-10840
811468ec:	e0fffb17 	ldw	r3,-20(fp)
811468f0:	18c00324 	muli	r3,r3,12
811468f4:	10c5883a 	add	r2,r2,r3
811468f8:	10800104 	addi	r2,r2,4
811468fc:	10c00017 	ldw	r3,0(r2)
81146900:	e0bffc17 	ldw	r2,-16(fp)
81146904:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
81146908:	00a04574 	movhi	r2,33045
8114690c:	10b56a04 	addi	r2,r2,-10840
81146910:	e0fffb17 	ldw	r3,-20(fp)
81146914:	18c00324 	muli	r3,r3,12
81146918:	10c5883a 	add	r2,r2,r3
8114691c:	10800204 	addi	r2,r2,8
81146920:	10c00017 	ldw	r3,0(r2)
81146924:	e0bffc17 	ldw	r2,-16(fp)
81146928:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
8114692c:	e13ffb17 	ldw	r4,-20(fp)
81146930:	11339d40 	call	811339d4 <alt_release_fd>
  }
} 
81146934:	0001883a 	nop
81146938:	e037883a 	mov	sp,fp
8114693c:	dfc00117 	ldw	ra,4(sp)
81146940:	df000017 	ldw	fp,0(sp)
81146944:	dec00204 	addi	sp,sp,8
81146948:	f800283a 	ret

8114694c <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
8114694c:	defffb04 	addi	sp,sp,-20
81146950:	de00012e 	bgeu	sp,et,81146958 <alt_io_redirect+0xc>
81146954:	003b68fa 	trap	3
81146958:	dfc00415 	stw	ra,16(sp)
8114695c:	df000315 	stw	fp,12(sp)
81146960:	df000304 	addi	fp,sp,12
81146964:	e13ffd15 	stw	r4,-12(fp)
81146968:	e17ffe15 	stw	r5,-8(fp)
8114696c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
81146970:	01c07fc4 	movi	r7,511
81146974:	01800044 	movi	r6,1
81146978:	e17ffd17 	ldw	r5,-12(fp)
8114697c:	01204574 	movhi	r4,33045
81146980:	21356d04 	addi	r4,r4,-10828
81146984:	11468800 	call	81146880 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
81146988:	01c07fc4 	movi	r7,511
8114698c:	000d883a 	mov	r6,zero
81146990:	e17ffe17 	ldw	r5,-8(fp)
81146994:	01204574 	movhi	r4,33045
81146998:	21356a04 	addi	r4,r4,-10840
8114699c:	11468800 	call	81146880 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
811469a0:	01c07fc4 	movi	r7,511
811469a4:	01800044 	movi	r6,1
811469a8:	e17fff17 	ldw	r5,-4(fp)
811469ac:	01204574 	movhi	r4,33045
811469b0:	21357004 	addi	r4,r4,-10816
811469b4:	11468800 	call	81146880 <alt_open_fd>
}  
811469b8:	0001883a 	nop
811469bc:	e037883a 	mov	sp,fp
811469c0:	dfc00117 	ldw	ra,4(sp)
811469c4:	df000017 	ldw	fp,0(sp)
811469c8:	dec00204 	addi	sp,sp,8
811469cc:	f800283a 	ret

811469d0 <alt_printf>:
/* 
 * ALT printf function 
 */
void 
alt_printf(const char* fmt, ... )
{
811469d0:	defff204 	addi	sp,sp,-56
811469d4:	de00012e 	bgeu	sp,et,811469dc <alt_printf+0xc>
811469d8:	003b68fa 	trap	3
811469dc:	dfc00a15 	stw	ra,40(sp)
811469e0:	df000915 	stw	fp,36(sp)
811469e4:	df000904 	addi	fp,sp,36
811469e8:	e13fff15 	stw	r4,-4(fp)
811469ec:	e1400215 	stw	r5,8(fp)
811469f0:	e1800315 	stw	r6,12(fp)
811469f4:	e1c00415 	stw	r7,16(fp)
	va_list args;
	va_start(args, fmt);
811469f8:	e0800204 	addi	r2,fp,8
811469fc:	e0bffe15 	stw	r2,-8(fp)
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
81146a00:	e0bfff17 	ldw	r2,-4(fp)
81146a04:	e0bff715 	stw	r2,-36(fp)
    while ((c = *w++) != 0)
81146a08:	00006f06 	br	81146bc8 <alt_printf+0x1f8>
    {
        /* If not a format escape character, just print  */
        /* character.  Otherwise, process format string. */
        if (c != '%')
81146a0c:	e0bff807 	ldb	r2,-32(fp)
81146a10:	10800960 	cmpeqi	r2,r2,37
81146a14:	1000041e 	bne	r2,zero,81146a28 <alt_printf+0x58>
        {
            alt_putchar(c);
81146a18:	e0bff807 	ldb	r2,-32(fp)
81146a1c:	1009883a 	mov	r4,r2
81146a20:	1146c040 	call	81146c04 <alt_putchar>
81146a24:	00006806 	br	81146bc8 <alt_printf+0x1f8>
        }
        else
        {
            /* Get format character.  If none     */
            /* available, processing is complete. */
            if ((c = *w++) != 0)
81146a28:	e0bff717 	ldw	r2,-36(fp)
81146a2c:	10c00044 	addi	r3,r2,1
81146a30:	e0fff715 	stw	r3,-36(fp)
81146a34:	10800003 	ldbu	r2,0(r2)
81146a38:	e0bff805 	stb	r2,-32(fp)
81146a3c:	e0bff807 	ldb	r2,-32(fp)
81146a40:	10006926 	beq	r2,zero,81146be8 <alt_printf+0x218>
            {
                if (c == '%')
81146a44:	e0bff807 	ldb	r2,-32(fp)
81146a48:	10800958 	cmpnei	r2,r2,37
81146a4c:	1000041e 	bne	r2,zero,81146a60 <alt_printf+0x90>
                {
                    /* Process "%" escape sequence. */
                    alt_putchar(c);
81146a50:	e0bff807 	ldb	r2,-32(fp)
81146a54:	1009883a 	mov	r4,r2
81146a58:	1146c040 	call	81146c04 <alt_putchar>
81146a5c:	00005a06 	br	81146bc8 <alt_printf+0x1f8>
                } 
                else if (c == 'c')
81146a60:	e0bff807 	ldb	r2,-32(fp)
81146a64:	108018d8 	cmpnei	r2,r2,99
81146a68:	1000081e 	bne	r2,zero,81146a8c <alt_printf+0xbc>
                {
                    int v = va_arg(args, int);
81146a6c:	e0bffe17 	ldw	r2,-8(fp)
81146a70:	10c00104 	addi	r3,r2,4
81146a74:	e0fffe15 	stw	r3,-8(fp)
81146a78:	10800017 	ldw	r2,0(r2)
81146a7c:	e0bffd15 	stw	r2,-12(fp)
                    alt_putchar(v);
81146a80:	e13ffd17 	ldw	r4,-12(fp)
81146a84:	1146c040 	call	81146c04 <alt_putchar>
81146a88:	00004f06 	br	81146bc8 <alt_printf+0x1f8>
                }
                else if (c == 'x')
81146a8c:	e0bff807 	ldb	r2,-32(fp)
81146a90:	10801e18 	cmpnei	r2,r2,120
81146a94:	1000341e 	bne	r2,zero,81146b68 <alt_printf+0x198>
                {
                    /* Process hexadecimal number format. */
                    unsigned long v = va_arg(args, unsigned long);
81146a98:	e0bffe17 	ldw	r2,-8(fp)
81146a9c:	10c00104 	addi	r3,r2,4
81146aa0:	e0fffe15 	stw	r3,-8(fp)
81146aa4:	10800017 	ldw	r2,0(r2)
81146aa8:	e0bffb15 	stw	r2,-20(fp)
                    unsigned long digit;
                    int digit_shift;

                    /* If the number value is zero, just print and continue. */
                    if (v == 0)
81146aac:	e0bffb17 	ldw	r2,-20(fp)
81146ab0:	1000031e 	bne	r2,zero,81146ac0 <alt_printf+0xf0>
                    {
                        alt_putchar('0');
81146ab4:	01000c04 	movi	r4,48
81146ab8:	1146c040 	call	81146c04 <alt_putchar>
                        continue;
81146abc:	00004206 	br	81146bc8 <alt_printf+0x1f8>
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
81146ac0:	00800704 	movi	r2,28
81146ac4:	e0bff915 	stw	r2,-28(fp)
                    while (!(v & (0xF << digit_shift)))
81146ac8:	00000306 	br	81146ad8 <alt_printf+0x108>
                        digit_shift -= 4;
81146acc:	e0bff917 	ldw	r2,-28(fp)
81146ad0:	10bfff04 	addi	r2,r2,-4
81146ad4:	e0bff915 	stw	r2,-28(fp)
                        continue;
                    }

                    /* Find first non-zero digit. */
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
81146ad8:	00c003c4 	movi	r3,15
81146adc:	e0bff917 	ldw	r2,-28(fp)
81146ae0:	1884983a 	sll	r2,r3,r2
81146ae4:	1007883a 	mov	r3,r2
81146ae8:	e0bffb17 	ldw	r2,-20(fp)
81146aec:	1884703a 	and	r2,r3,r2
81146af0:	103ff626 	beq	r2,zero,81146acc <__reset+0xfb126acc>
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81146af4:	00001906 	br	81146b5c <alt_printf+0x18c>
                    {
                        digit = (v & (0xF << digit_shift)) >> digit_shift;
81146af8:	00c003c4 	movi	r3,15
81146afc:	e0bff917 	ldw	r2,-28(fp)
81146b00:	1884983a 	sll	r2,r3,r2
81146b04:	1007883a 	mov	r3,r2
81146b08:	e0bffb17 	ldw	r2,-20(fp)
81146b0c:	1886703a 	and	r3,r3,r2
81146b10:	e0bff917 	ldw	r2,-28(fp)
81146b14:	1884d83a 	srl	r2,r3,r2
81146b18:	e0bffc15 	stw	r2,-16(fp)
                        if (digit <= 9)
81146b1c:	e0bffc17 	ldw	r2,-16(fp)
81146b20:	108002a8 	cmpgeui	r2,r2,10
81146b24:	1000041e 	bne	r2,zero,81146b38 <alt_printf+0x168>
                            c = '0' + digit;
81146b28:	e0bffc17 	ldw	r2,-16(fp)
81146b2c:	10800c04 	addi	r2,r2,48
81146b30:	e0bff805 	stb	r2,-32(fp)
81146b34:	00000306 	br	81146b44 <alt_printf+0x174>
                        else
                            c = 'a' + digit - 10;
81146b38:	e0bffc17 	ldw	r2,-16(fp)
81146b3c:	108015c4 	addi	r2,r2,87
81146b40:	e0bff805 	stb	r2,-32(fp)
                        alt_putchar(c);
81146b44:	e0bff807 	ldb	r2,-32(fp)
81146b48:	1009883a 	mov	r4,r2
81146b4c:	1146c040 	call	81146c04 <alt_putchar>
                    digit_shift = 28;
                    while (!(v & (0xF << digit_shift)))
                        digit_shift -= 4;

                    /* Print digits. */
                    for (; digit_shift >= 0; digit_shift -= 4)
81146b50:	e0bff917 	ldw	r2,-28(fp)
81146b54:	10bfff04 	addi	r2,r2,-4
81146b58:	e0bff915 	stw	r2,-28(fp)
81146b5c:	e0bff917 	ldw	r2,-28(fp)
81146b60:	103fe50e 	bge	r2,zero,81146af8 <__reset+0xfb126af8>
81146b64:	00001806 	br	81146bc8 <alt_printf+0x1f8>
                        else
                            c = 'a' + digit - 10;
                        alt_putchar(c);
                    }
                }
                else if (c == 's')
81146b68:	e0bff807 	ldb	r2,-32(fp)
81146b6c:	10801cd8 	cmpnei	r2,r2,115
81146b70:	1000151e 	bne	r2,zero,81146bc8 <alt_printf+0x1f8>
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);
81146b74:	e0bffe17 	ldw	r2,-8(fp)
81146b78:	10c00104 	addi	r3,r2,4
81146b7c:	e0fffe15 	stw	r3,-8(fp)
81146b80:	10800017 	ldw	r2,0(r2)
81146b84:	e0bffa15 	stw	r2,-24(fp)

                    while(*s)
81146b88:	00000906 	br	81146bb0 <alt_printf+0x1e0>
                      alt_putchar(*s++);
81146b8c:	e0bffa17 	ldw	r2,-24(fp)
81146b90:	10c00044 	addi	r3,r2,1
81146b94:	e0fffa15 	stw	r3,-24(fp)
81146b98:	10800003 	ldbu	r2,0(r2)
81146b9c:	10803fcc 	andi	r2,r2,255
81146ba0:	1080201c 	xori	r2,r2,128
81146ba4:	10bfe004 	addi	r2,r2,-128
81146ba8:	1009883a 	mov	r4,r2
81146bac:	1146c040 	call	81146c04 <alt_putchar>
                else if (c == 's')
                {
                    /* Process string format. */
                    char *s = va_arg(args, char *);

                    while(*s)
81146bb0:	e0bffa17 	ldw	r2,-24(fp)
81146bb4:	10800003 	ldbu	r2,0(r2)
81146bb8:	10803fcc 	andi	r2,r2,255
81146bbc:	1080201c 	xori	r2,r2,128
81146bc0:	10bfe004 	addi	r2,r2,-128
81146bc4:	103ff11e 	bne	r2,zero,81146b8c <__reset+0xfb126b8c>
    const char *w;
    char c;

    /* Process format string. */
    w = fmt;
    while ((c = *w++) != 0)
81146bc8:	e0bff717 	ldw	r2,-36(fp)
81146bcc:	10c00044 	addi	r3,r2,1
81146bd0:	e0fff715 	stw	r3,-36(fp)
81146bd4:	10800003 	ldbu	r2,0(r2)
81146bd8:	e0bff805 	stb	r2,-32(fp)
81146bdc:	e0bff807 	ldb	r2,-32(fp)
81146be0:	103f8a1e 	bne	r2,zero,81146a0c <__reset+0xfb126a0c>
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81146be4:	00000106 	br	81146bec <alt_printf+0x21c>
                      alt_putchar(*s++);
                }
            }
            else
            {
                break;
81146be8:	0001883a 	nop
        }
    }
#ifdef ALT_SEMIHOSTING
    alt_putbufflush();
#endif
}
81146bec:	0001883a 	nop
81146bf0:	e037883a 	mov	sp,fp
81146bf4:	dfc00117 	ldw	ra,4(sp)
81146bf8:	df000017 	ldw	fp,0(sp)
81146bfc:	dec00504 	addi	sp,sp,20
81146c00:	f800283a 	ret

81146c04 <alt_putchar>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided putchar() routine.
 */
int 
alt_putchar(int c)
{
81146c04:	defffd04 	addi	sp,sp,-12
81146c08:	de00012e 	bgeu	sp,et,81146c10 <alt_putchar+0xc>
81146c0c:	003b68fa 	trap	3
81146c10:	dfc00215 	stw	ra,8(sp)
81146c14:	df000115 	stw	fp,4(sp)
81146c18:	df000104 	addi	fp,sp,4
81146c1c:	e13fff15 	stw	r4,-4(fp)
    if (ALT_DRIVER_WRITE(ALT_STDOUT_DEV, &c1, 1, 0) == -1) {
        return -1;
    }
    return c;
#else
    return putchar(c);
81146c20:	d0a00517 	ldw	r2,-32748(gp)
81146c24:	10800217 	ldw	r2,8(r2)
81146c28:	100b883a 	mov	r5,r2
81146c2c:	e13fff17 	ldw	r4,-4(fp)
81146c30:	111decc0 	call	8111decc <putc>
#endif
#endif
}
81146c34:	e037883a 	mov	sp,fp
81146c38:	dfc00117 	ldw	ra,4(sp)
81146c3c:	df000017 	ldw	fp,0(sp)
81146c40:	dec00204 	addi	sp,sp,8
81146c44:	f800283a 	ret

81146c48 <altera_nios2_gen2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
81146c48:	deffff04 	addi	sp,sp,-4
81146c4c:	de00012e 	bgeu	sp,et,81146c54 <altera_nios2_gen2_irq_init+0xc>
81146c50:	003b68fa 	trap	3
81146c54:	df000015 	stw	fp,0(sp)
81146c58:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
81146c5c:	000170fa 	wrctl	ienable,zero
}
81146c60:	0001883a 	nop
81146c64:	e037883a 	mov	sp,fp
81146c68:	df000017 	ldw	fp,0(sp)
81146c6c:	dec00104 	addi	sp,sp,4
81146c70:	f800283a 	ret

81146c74 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
81146c74:	defff504 	addi	sp,sp,-44

#ifdef ALT_STACK_CHECK

      bltu  sp, et, .Lstack_overflow
81146c78:	de002436 	bltu	sp,et,81146d0c <OSCtxSw+0x98>

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
81146c7c:	d0e00517 	ldw	r3,-32748(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
81146c80:	d1209e17 	ldw	r4,-32136(gp)

      stw ra,  0(sp)
81146c84:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
81146c88:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
81146c8c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
81146c90:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
81146c94:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
81146c98:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
81146c9c:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
81146ca0:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
81146ca4:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
81146ca8:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
81146cac:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
81146cb0:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81146cb4:	1146f100 	call	81146f10 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
81146cb8:	d1209817 	ldw	r4,-32160(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
81146cbc:	d1608f87 	ldb	r5,-32194(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
81146cc0:	d1209e15 	stw	r4,-32136(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
81146cc4:	d1608fc5 	stb	r5,-32193(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
81146cc8:	26c00017 	ldw	sp,0(r4)
      
#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      ldw et, 8(r4)                  /* load the new stack limit */
81146ccc:	26000217 	ldw	et,8(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
81146cd0:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
81146cd4:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
81146cd8:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
81146cdc:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
81146ce0:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
81146ce4:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
81146ce8:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
81146cec:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
81146cf0:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
81146cf4:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
81146cf8:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
81146cfc:	d0e00515 	stw	r3,-32748(gp)

#endif /* OS_THREAD_SAFE_NEWLIB */

#if defined(ALT_STACK_CHECK) && (OS_TASK_CREATE_EXT_EN > 0)

      stw et, %gprel(alt_stack_limit_value)(gp)
81146d00:	d6200015 	stw	et,-32768(gp)

#endif

      addi sp, sp, 44
81146d04:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
81146d08:	f800283a 	ret

#ifdef ALT_STACK_CHECK

.Lstack_overflow:
        break 3
81146d0c:	003da0fa 	break	3

81146d10 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
81146d10:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
81146d14:	047fff84 	movi	r17,-2
      and   r18, r18, r17
81146d18:	9464703a 	and	r18,r18,r17
      wrctl status, r18
81146d1c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
81146d20:	1146f100 	call	81146f10 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
81146d24:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
81146d28:	d4a08d05 	stb	r18,-32204(gp)

      /*
       * start execution of the new task.
       */

      br 9b
81146d2c:	003fe206 	br	81146cb8 <__reset+0xfb126cb8>

81146d30 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
81146d30:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
81146d34:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
81146d38:	10800054 	ori	r2,r2,1
      wrctl status, r2
81146d3c:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
81146d40:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
81146d44:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
81146d48:	dec00204 	addi	sp,sp,8

      callr r2
81146d4c:	103ee83a 	callr	r2

      nop
81146d50:	0001883a 	nop

81146d54 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
81146d54:	defff704 	addi	sp,sp,-36
81146d58:	de00012e 	bgeu	sp,et,81146d60 <OSTaskStkInit+0xc>
81146d5c:	003b68fa 	trap	3
81146d60:	dfc00815 	stw	ra,32(sp)
81146d64:	df000715 	stw	fp,28(sp)
81146d68:	df000704 	addi	fp,sp,28
81146d6c:	e13ffc15 	stw	r4,-16(fp)
81146d70:	e17ffd15 	stw	r5,-12(fp)
81146d74:	e1bffe15 	stw	r6,-8(fp)
81146d78:	3805883a 	mov	r2,r7
81146d7c:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
81146d80:	e0fffe17 	ldw	r3,-8(fp)
81146d84:	00bfff04 	movi	r2,-4
81146d88:	1884703a 	and	r2,r3,r2
81146d8c:	10bef704 	addi	r2,r2,-1060
81146d90:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
81146d94:	01810904 	movi	r6,1060
81146d98:	000b883a 	mov	r5,zero
81146d9c:	e13ff917 	ldw	r4,-28(fp)
81146da0:	111dc180 	call	8111dc18 <memset>
81146da4:	e0bff917 	ldw	r2,-28(fp)
81146da8:	10c0bb04 	addi	r3,r2,748
81146dac:	e0bff917 	ldw	r2,-28(fp)
81146db0:	10c00115 	stw	r3,4(r2)
81146db4:	e0bff917 	ldw	r2,-28(fp)
81146db8:	10c0d504 	addi	r3,r2,852
81146dbc:	e0bff917 	ldw	r2,-28(fp)
81146dc0:	10c00215 	stw	r3,8(r2)
81146dc4:	e0bff917 	ldw	r2,-28(fp)
81146dc8:	10c0ef04 	addi	r3,r2,956
81146dcc:	e0bff917 	ldw	r2,-28(fp)
81146dd0:	10c00315 	stw	r3,12(r2)
81146dd4:	e0fff917 	ldw	r3,-28(fp)
81146dd8:	00a04574 	movhi	r2,33045
81146ddc:	10b30304 	addi	r2,r2,-13300
81146de0:	18800d15 	stw	r2,52(r3)
81146de4:	e0bff917 	ldw	r2,-28(fp)
81146de8:	00c00044 	movi	r3,1
81146dec:	10c02915 	stw	r3,164(r2)
81146df0:	10002a15 	stw	zero,168(r2)
81146df4:	e0bff917 	ldw	r2,-28(fp)
81146df8:	00ccc384 	movi	r3,13070
81146dfc:	10c02b0d 	sth	r3,172(r2)
81146e00:	e0bff917 	ldw	r2,-28(fp)
81146e04:	00eaf344 	movi	r3,-21555
81146e08:	10c02b8d 	sth	r3,174(r2)
81146e0c:	e0bff917 	ldw	r2,-28(fp)
81146e10:	00c48d04 	movi	r3,4660
81146e14:	10c02c0d 	sth	r3,176(r2)
81146e18:	e0bff917 	ldw	r2,-28(fp)
81146e1c:	00f99b44 	movi	r3,-6547
81146e20:	10c02c8d 	sth	r3,178(r2)
81146e24:	e0bff917 	ldw	r2,-28(fp)
81146e28:	00f7bb04 	movi	r3,-8468
81146e2c:	10c02d0d 	sth	r3,180(r2)
81146e30:	e0bff917 	ldw	r2,-28(fp)
81146e34:	00c00144 	movi	r3,5
81146e38:	10c02d8d 	sth	r3,182(r2)
81146e3c:	e0bff917 	ldw	r2,-28(fp)
81146e40:	00c002c4 	movi	r3,11
81146e44:	10c02e0d 	sth	r3,184(r2)
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
81146e48:	e0bff917 	ldw	r2,-28(fp)
81146e4c:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
81146e50:	e0bffa17 	ldw	r2,-24(fp)
81146e54:	10bff304 	addi	r2,r2,-52
81146e58:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
81146e5c:	e0bffb17 	ldw	r2,-20(fp)
81146e60:	10800c04 	addi	r2,r2,48
81146e64:	e0fffc17 	ldw	r3,-16(fp)
81146e68:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
81146e6c:	e0bffb17 	ldw	r2,-20(fp)
81146e70:	10800b04 	addi	r2,r2,44
81146e74:	e0fffd17 	ldw	r3,-12(fp)
81146e78:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
81146e7c:	e0bffb17 	ldw	r2,-20(fp)
81146e80:	10800a04 	addi	r2,r2,40
81146e84:	e0fff917 	ldw	r3,-28(fp)
81146e88:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
81146e8c:	00a04534 	movhi	r2,33044
81146e90:	109b4c04 	addi	r2,r2,27952
81146e94:	10c00104 	addi	r3,r2,4
81146e98:	e0bffb17 	ldw	r2,-20(fp)
81146e9c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
81146ea0:	e0bffb17 	ldw	r2,-20(fp)
}
81146ea4:	e037883a 	mov	sp,fp
81146ea8:	dfc00117 	ldw	ra,4(sp)
81146eac:	df000017 	ldw	fp,0(sp)
81146eb0:	dec00204 	addi	sp,sp,8
81146eb4:	f800283a 	ret

81146eb8 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
81146eb8:	defffe04 	addi	sp,sp,-8
81146ebc:	de00012e 	bgeu	sp,et,81146ec4 <OSTaskCreateHook+0xc>
81146ec0:	003b68fa 	trap	3
81146ec4:	df000115 	stw	fp,4(sp)
81146ec8:	df000104 	addi	fp,sp,4
81146ecc:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
81146ed0:	0001883a 	nop
81146ed4:	e037883a 	mov	sp,fp
81146ed8:	df000017 	ldw	fp,0(sp)
81146edc:	dec00104 	addi	sp,sp,4
81146ee0:	f800283a 	ret

81146ee4 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
81146ee4:	defffe04 	addi	sp,sp,-8
81146ee8:	de00012e 	bgeu	sp,et,81146ef0 <OSTaskDelHook+0xc>
81146eec:	003b68fa 	trap	3
81146ef0:	df000115 	stw	fp,4(sp)
81146ef4:	df000104 	addi	fp,sp,4
81146ef8:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
81146efc:	0001883a 	nop
81146f00:	e037883a 	mov	sp,fp
81146f04:	df000017 	ldw	fp,0(sp)
81146f08:	dec00104 	addi	sp,sp,4
81146f0c:	f800283a 	ret

81146f10 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
81146f10:	deffff04 	addi	sp,sp,-4
81146f14:	de00012e 	bgeu	sp,et,81146f1c <OSTaskSwHook+0xc>
81146f18:	003b68fa 	trap	3
81146f1c:	df000015 	stw	fp,0(sp)
81146f20:	d839883a 	mov	fp,sp
}
81146f24:	0001883a 	nop
81146f28:	e037883a 	mov	sp,fp
81146f2c:	df000017 	ldw	fp,0(sp)
81146f30:	dec00104 	addi	sp,sp,4
81146f34:	f800283a 	ret

81146f38 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
81146f38:	deffff04 	addi	sp,sp,-4
81146f3c:	de00012e 	bgeu	sp,et,81146f44 <OSTaskStatHook+0xc>
81146f40:	003b68fa 	trap	3
81146f44:	df000015 	stw	fp,0(sp)
81146f48:	d839883a 	mov	fp,sp
}
81146f4c:	0001883a 	nop
81146f50:	e037883a 	mov	sp,fp
81146f54:	df000017 	ldw	fp,0(sp)
81146f58:	dec00104 	addi	sp,sp,4
81146f5c:	f800283a 	ret

81146f60 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
81146f60:	defffe04 	addi	sp,sp,-8
81146f64:	de00012e 	bgeu	sp,et,81146f6c <OSTimeTickHook+0xc>
81146f68:	003b68fa 	trap	3
81146f6c:	dfc00115 	stw	ra,4(sp)
81146f70:	df000015 	stw	fp,0(sp)
81146f74:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr++;
81146f78:	d0a0b20b 	ldhu	r2,-32056(gp)
81146f7c:	10800044 	addi	r2,r2,1
81146f80:	d0a0b20d 	sth	r2,-32056(gp)
    if (OSTmrCtr >= (OS_TICKS_PER_SEC / OS_TMR_CFG_TICKS_PER_SEC)) {
81146f84:	d0a0b20b 	ldhu	r2,-32056(gp)
81146f88:	10bfffcc 	andi	r2,r2,65535
81146f8c:	10807d30 	cmpltui	r2,r2,500
81146f90:	1000021e 	bne	r2,zero,81146f9c <OSTimeTickHook+0x3c>
        OSTmrCtr = 0;
81146f94:	d020b20d 	sth	zero,-32056(gp)
        OSTmrSignal();
81146f98:	113d8b00 	call	8113d8b0 <OSTmrSignal>
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
#endif
}
81146f9c:	0001883a 	nop
81146fa0:	e037883a 	mov	sp,fp
81146fa4:	dfc00117 	ldw	ra,4(sp)
81146fa8:	df000017 	ldw	fp,0(sp)
81146fac:	dec00204 	addi	sp,sp,8
81146fb0:	f800283a 	ret

81146fb4 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
81146fb4:	deffff04 	addi	sp,sp,-4
81146fb8:	de00012e 	bgeu	sp,et,81146fc0 <OSInitHookBegin+0xc>
81146fbc:	003b68fa 	trap	3
81146fc0:	df000015 	stw	fp,0(sp)
81146fc4:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
81146fc8:	d020b20d 	sth	zero,-32056(gp)
#endif
}
81146fcc:	0001883a 	nop
81146fd0:	e037883a 	mov	sp,fp
81146fd4:	df000017 	ldw	fp,0(sp)
81146fd8:	dec00104 	addi	sp,sp,4
81146fdc:	f800283a 	ret

81146fe0 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
81146fe0:	deffff04 	addi	sp,sp,-4
81146fe4:	de00012e 	bgeu	sp,et,81146fec <OSInitHookEnd+0xc>
81146fe8:	003b68fa 	trap	3
81146fec:	df000015 	stw	fp,0(sp)
81146ff0:	d839883a 	mov	fp,sp
}
81146ff4:	0001883a 	nop
81146ff8:	e037883a 	mov	sp,fp
81146ffc:	df000017 	ldw	fp,0(sp)
81147000:	dec00104 	addi	sp,sp,4
81147004:	f800283a 	ret

81147008 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
81147008:	deffff04 	addi	sp,sp,-4
8114700c:	de00012e 	bgeu	sp,et,81147014 <OSTaskIdleHook+0xc>
81147010:	003b68fa 	trap	3
81147014:	df000015 	stw	fp,0(sp)
81147018:	d839883a 	mov	fp,sp
}
8114701c:	0001883a 	nop
81147020:	e037883a 	mov	sp,fp
81147024:	df000017 	ldw	fp,0(sp)
81147028:	dec00104 	addi	sp,sp,4
8114702c:	f800283a 	ret

81147030 <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
81147030:	defffe04 	addi	sp,sp,-8
81147034:	de00012e 	bgeu	sp,et,8114703c <OSTCBInitHook+0xc>
81147038:	003b68fa 	trap	3
8114703c:	df000115 	stw	fp,4(sp)
81147040:	df000104 	addi	fp,sp,4
81147044:	e13fff15 	stw	r4,-4(fp)
}
81147048:	0001883a 	nop
8114704c:	e037883a 	mov	sp,fp
81147050:	df000017 	ldw	fp,0(sp)
81147054:	dec00104 	addi	sp,sp,4
81147058:	f800283a 	ret

8114705c <alt_exception_cause_generated_bad_addr>:
 * Return: 1: BADADDR (bad_addr argument to handler) is valid
 *         0: BADADDR is not valid
 */
int 
alt_exception_cause_generated_bad_addr(alt_exception_cause cause)
{
8114705c:	defffe04 	addi	sp,sp,-8
81147060:	de00012e 	bgeu	sp,et,81147068 <alt_exception_cause_generated_bad_addr+0xc>
81147064:	003b68fa 	trap	3
81147068:	df000115 	stw	fp,4(sp)
8114706c:	df000104 	addi	fp,sp,4
81147070:	e13fff15 	stw	r4,-4(fp)
  switch (cause) {
81147074:	e0bfff17 	ldw	r2,-4(fp)
81147078:	10bffe84 	addi	r2,r2,-6
8114707c:	10c00428 	cmpgeui	r3,r2,16
81147080:	18001a1e 	bne	r3,zero,811470ec <alt_exception_cause_generated_bad_addr+0x90>
81147084:	100690ba 	slli	r3,r2,2
81147088:	00a04534 	movhi	r2,33044
8114708c:	109c2704 	addi	r2,r2,28828
81147090:	1885883a 	add	r2,r3,r2
81147094:	10800017 	ldw	r2,0(r2)
81147098:	1000683a 	jmp	r2
8114709c:	811470dc 	xori	r4,r16,20931
811470a0:	811470dc 	xori	r4,r16,20931
811470a4:	811470ec 	andhi	r4,r16,20931
811470a8:	811470ec 	andhi	r4,r16,20931
811470ac:	811470ec 	andhi	r4,r16,20931
811470b0:	811470dc 	xori	r4,r16,20931
811470b4:	811470e4 	muli	r4,r16,20931
811470b8:	811470ec 	andhi	r4,r16,20931
811470bc:	811470dc 	xori	r4,r16,20931
811470c0:	811470dc 	xori	r4,r16,20931
811470c4:	811470ec 	andhi	r4,r16,20931
811470c8:	811470dc 	xori	r4,r16,20931
811470cc:	811470e4 	muli	r4,r16,20931
811470d0:	811470ec 	andhi	r4,r16,20931
811470d4:	811470ec 	andhi	r4,r16,20931
811470d8:	811470dc 	xori	r4,r16,20931
  case NIOS2_EXCEPTION_MISALIGNED_TARGET_PC:
  case NIOS2_EXCEPTION_TLB_READ_PERM_VIOLATION:
  case NIOS2_EXCEPTION_TLB_WRITE_PERM_VIOLATION:
  case NIOS2_EXCEPTION_MPU_DATA_REGION_VIOLATION:
  case NIOS2_EXCEPTION_ECC_DATA_ERR:
    return 1;
811470dc:	00800044 	movi	r2,1
811470e0:	00000306 	br	811470f0 <alt_exception_cause_generated_bad_addr+0x94>

  case NIOS2_EXCEPTION_TLB_MISS:
  case NIOS2_EXCEPTION_ECC_TLB_ERR:
    return 0;
811470e4:	0005883a 	mov	r2,zero
811470e8:	00000106 	br	811470f0 <alt_exception_cause_generated_bad_addr+0x94>

  default:
    return 0;
811470ec:	0005883a 	mov	r2,zero
  }
}
811470f0:	e037883a 	mov	sp,fp
811470f4:	df000017 	ldw	fp,0(sp)
811470f8:	dec00104 	addi	sp,sp,4
811470fc:	f800283a 	ret

81147100 <exit>:
81147100:	defffe04 	addi	sp,sp,-8
81147104:	000b883a 	mov	r5,zero
81147108:	de00012e 	bgeu	sp,et,81147110 <exit+0x10>
8114710c:	003b68fa 	trap	3
81147110:	dc000015 	stw	r16,0(sp)
81147114:	dfc00115 	stw	ra,4(sp)
81147118:	2021883a 	mov	r16,r4
8114711c:	11472a80 	call	811472a8 <__call_exitprocs>
81147120:	00a04574 	movhi	r2,33045
81147124:	10ba8104 	addi	r2,r2,-5628
81147128:	11000017 	ldw	r4,0(r2)
8114712c:	20800f17 	ldw	r2,60(r4)
81147130:	10000126 	beq	r2,zero,81147138 <exit+0x38>
81147134:	103ee83a 	callr	r2
81147138:	8009883a 	mov	r4,r16
8114713c:	11474300 	call	81147430 <_exit>

81147140 <memcmp>:
81147140:	01c000c4 	movi	r7,3
81147144:	3980192e 	bgeu	r7,r6,811471ac <memcmp+0x6c>
81147148:	2144b03a 	or	r2,r4,r5
8114714c:	11c4703a 	and	r2,r2,r7
81147150:	10000f26 	beq	r2,zero,81147190 <memcmp+0x50>
81147154:	20800003 	ldbu	r2,0(r4)
81147158:	28c00003 	ldbu	r3,0(r5)
8114715c:	10c0151e 	bne	r2,r3,811471b4 <memcmp+0x74>
81147160:	31bfff84 	addi	r6,r6,-2
81147164:	01ffffc4 	movi	r7,-1
81147168:	00000406 	br	8114717c <memcmp+0x3c>
8114716c:	20800003 	ldbu	r2,0(r4)
81147170:	28c00003 	ldbu	r3,0(r5)
81147174:	31bfffc4 	addi	r6,r6,-1
81147178:	10c00e1e 	bne	r2,r3,811471b4 <memcmp+0x74>
8114717c:	21000044 	addi	r4,r4,1
81147180:	29400044 	addi	r5,r5,1
81147184:	31fff91e 	bne	r6,r7,8114716c <__reset+0xfb12716c>
81147188:	0005883a 	mov	r2,zero
8114718c:	f800283a 	ret
81147190:	20c00017 	ldw	r3,0(r4)
81147194:	28800017 	ldw	r2,0(r5)
81147198:	18bfee1e 	bne	r3,r2,81147154 <__reset+0xfb127154>
8114719c:	31bfff04 	addi	r6,r6,-4
811471a0:	21000104 	addi	r4,r4,4
811471a4:	29400104 	addi	r5,r5,4
811471a8:	39bff936 	bltu	r7,r6,81147190 <__reset+0xfb127190>
811471ac:	303fe91e 	bne	r6,zero,81147154 <__reset+0xfb127154>
811471b0:	003ff506 	br	81147188 <__reset+0xfb127188>
811471b4:	10c5c83a 	sub	r2,r2,r3
811471b8:	f800283a 	ret

811471bc <strncpy>:
811471bc:	2906b03a 	or	r3,r5,r4
811471c0:	18c000cc 	andi	r3,r3,3
811471c4:	2005883a 	mov	r2,r4
811471c8:	18002c1e 	bne	r3,zero,8114727c <strncpy+0xc0>
811471cc:	010000c4 	movi	r4,3
811471d0:	21802a2e 	bgeu	r4,r6,8114727c <strncpy+0xc0>
811471d4:	033fbff4 	movhi	r12,65279
811471d8:	02e02074 	movhi	r11,32897
811471dc:	633fbfc4 	addi	r12,r12,-257
811471e0:	5ae02004 	addi	r11,r11,-32640
811471e4:	100f883a 	mov	r7,r2
811471e8:	2a000017 	ldw	r8,0(r5)
811471ec:	3815883a 	mov	r10,r7
811471f0:	4313883a 	add	r9,r8,r12
811471f4:	0206303a 	nor	r3,zero,r8
811471f8:	48c6703a 	and	r3,r9,r3
811471fc:	1ac6703a 	and	r3,r3,r11
81147200:	1800261e 	bne	r3,zero,8114729c <strncpy+0xe0>
81147204:	39c00104 	addi	r7,r7,4
81147208:	52000015 	stw	r8,0(r10)
8114720c:	31bfff04 	addi	r6,r6,-4
81147210:	3811883a 	mov	r8,r7
81147214:	29400104 	addi	r5,r5,4
81147218:	21bff336 	bltu	r4,r6,811471e8 <__reset+0xfb1271e8>
8114721c:	30001e26 	beq	r6,zero,81147298 <strncpy+0xdc>
81147220:	29c00003 	ldbu	r7,0(r5)
81147224:	31bfffc4 	addi	r6,r6,-1
81147228:	40c00044 	addi	r3,r8,1
8114722c:	41c00005 	stb	r7,0(r8)
81147230:	39c03fcc 	andi	r7,r7,255
81147234:	39c0201c 	xori	r7,r7,128
81147238:	39ffe004 	addi	r7,r7,-128
8114723c:	29400044 	addi	r5,r5,1
81147240:	38001026 	beq	r7,zero,81147284 <strncpy+0xc8>
81147244:	1811883a 	mov	r8,r3
81147248:	00000906 	br	81147270 <strncpy+0xb4>
8114724c:	29c00003 	ldbu	r7,0(r5)
81147250:	31bfffc4 	addi	r6,r6,-1
81147254:	29400044 	addi	r5,r5,1
81147258:	41c00005 	stb	r7,0(r8)
8114725c:	39c03fcc 	andi	r7,r7,255
81147260:	39c0201c 	xori	r7,r7,128
81147264:	39ffe004 	addi	r7,r7,-128
81147268:	1811883a 	mov	r8,r3
8114726c:	38000526 	beq	r7,zero,81147284 <strncpy+0xc8>
81147270:	18c00044 	addi	r3,r3,1
81147274:	303ff51e 	bne	r6,zero,8114724c <__reset+0xfb12724c>
81147278:	f800283a 	ret
8114727c:	1011883a 	mov	r8,r2
81147280:	003fe606 	br	8114721c <__reset+0xfb12721c>
81147284:	30000726 	beq	r6,zero,811472a4 <strncpy+0xe8>
81147288:	198d883a 	add	r6,r3,r6
8114728c:	18000005 	stb	zero,0(r3)
81147290:	18c00044 	addi	r3,r3,1
81147294:	19bffd1e 	bne	r3,r6,8114728c <__reset+0xfb12728c>
81147298:	f800283a 	ret
8114729c:	3811883a 	mov	r8,r7
811472a0:	003fdf06 	br	81147220 <__reset+0xfb127220>
811472a4:	f800283a 	ret

811472a8 <__call_exitprocs>:
811472a8:	defff504 	addi	sp,sp,-44
811472ac:	de00012e 	bgeu	sp,et,811472b4 <__call_exitprocs+0xc>
811472b0:	003b68fa 	trap	3
811472b4:	df000915 	stw	fp,36(sp)
811472b8:	dd400615 	stw	r21,24(sp)
811472bc:	dc800315 	stw	r18,12(sp)
811472c0:	dfc00a15 	stw	ra,40(sp)
811472c4:	ddc00815 	stw	r23,32(sp)
811472c8:	dd800715 	stw	r22,28(sp)
811472cc:	dd000515 	stw	r20,20(sp)
811472d0:	dcc00415 	stw	r19,16(sp)
811472d4:	dc400215 	stw	r17,8(sp)
811472d8:	dc000115 	stw	r16,4(sp)
811472dc:	d9000015 	stw	r4,0(sp)
811472e0:	2839883a 	mov	fp,r5
811472e4:	04800044 	movi	r18,1
811472e8:	057fffc4 	movi	r21,-1
811472ec:	00a04574 	movhi	r2,33045
811472f0:	10ba8104 	addi	r2,r2,-5628
811472f4:	12000017 	ldw	r8,0(r2)
811472f8:	45005217 	ldw	r20,328(r8)
811472fc:	44c05204 	addi	r19,r8,328
81147300:	a0001c26 	beq	r20,zero,81147374 <__call_exitprocs+0xcc>
81147304:	a0800117 	ldw	r2,4(r20)
81147308:	15ffffc4 	addi	r23,r2,-1
8114730c:	b8000d16 	blt	r23,zero,81147344 <__call_exitprocs+0x9c>
81147310:	14000044 	addi	r16,r2,1
81147314:	8421883a 	add	r16,r16,r16
81147318:	8421883a 	add	r16,r16,r16
8114731c:	84402004 	addi	r17,r16,128
81147320:	a463883a 	add	r17,r20,r17
81147324:	a421883a 	add	r16,r20,r16
81147328:	e0001e26 	beq	fp,zero,811473a4 <__call_exitprocs+0xfc>
8114732c:	80804017 	ldw	r2,256(r16)
81147330:	e0801c26 	beq	fp,r2,811473a4 <__call_exitprocs+0xfc>
81147334:	bdffffc4 	addi	r23,r23,-1
81147338:	843fff04 	addi	r16,r16,-4
8114733c:	8c7fff04 	addi	r17,r17,-4
81147340:	bd7ff91e 	bne	r23,r21,81147328 <__reset+0xfb127328>
81147344:	00800034 	movhi	r2,0
81147348:	10800004 	addi	r2,r2,0
8114734c:	10000926 	beq	r2,zero,81147374 <__call_exitprocs+0xcc>
81147350:	a0800117 	ldw	r2,4(r20)
81147354:	1000301e 	bne	r2,zero,81147418 <__call_exitprocs+0x170>
81147358:	a0800017 	ldw	r2,0(r20)
8114735c:	10003226 	beq	r2,zero,81147428 <__call_exitprocs+0x180>
81147360:	a009883a 	mov	r4,r20
81147364:	98800015 	stw	r2,0(r19)
81147368:	00000000 	call	80000000 <OSCtxSw_SWITCH_PC+0x7fffffbc>
8114736c:	9d000017 	ldw	r20,0(r19)
81147370:	a03fe41e 	bne	r20,zero,81147304 <__reset+0xfb127304>
81147374:	dfc00a17 	ldw	ra,40(sp)
81147378:	df000917 	ldw	fp,36(sp)
8114737c:	ddc00817 	ldw	r23,32(sp)
81147380:	dd800717 	ldw	r22,28(sp)
81147384:	dd400617 	ldw	r21,24(sp)
81147388:	dd000517 	ldw	r20,20(sp)
8114738c:	dcc00417 	ldw	r19,16(sp)
81147390:	dc800317 	ldw	r18,12(sp)
81147394:	dc400217 	ldw	r17,8(sp)
81147398:	dc000117 	ldw	r16,4(sp)
8114739c:	dec00b04 	addi	sp,sp,44
811473a0:	f800283a 	ret
811473a4:	a0800117 	ldw	r2,4(r20)
811473a8:	80c00017 	ldw	r3,0(r16)
811473ac:	10bfffc4 	addi	r2,r2,-1
811473b0:	15c01426 	beq	r2,r23,81147404 <__call_exitprocs+0x15c>
811473b4:	80000015 	stw	zero,0(r16)
811473b8:	183fde26 	beq	r3,zero,81147334 <__reset+0xfb127334>
811473bc:	95c8983a 	sll	r4,r18,r23
811473c0:	a0806217 	ldw	r2,392(r20)
811473c4:	a5800117 	ldw	r22,4(r20)
811473c8:	2084703a 	and	r2,r4,r2
811473cc:	10000b26 	beq	r2,zero,811473fc <__call_exitprocs+0x154>
811473d0:	a0806317 	ldw	r2,396(r20)
811473d4:	2088703a 	and	r4,r4,r2
811473d8:	20000c1e 	bne	r4,zero,8114740c <__call_exitprocs+0x164>
811473dc:	89400017 	ldw	r5,0(r17)
811473e0:	d9000017 	ldw	r4,0(sp)
811473e4:	183ee83a 	callr	r3
811473e8:	a0800117 	ldw	r2,4(r20)
811473ec:	15bfbf1e 	bne	r2,r22,811472ec <__reset+0xfb1272ec>
811473f0:	98800017 	ldw	r2,0(r19)
811473f4:	153fcf26 	beq	r2,r20,81147334 <__reset+0xfb127334>
811473f8:	003fbc06 	br	811472ec <__reset+0xfb1272ec>
811473fc:	183ee83a 	callr	r3
81147400:	003ff906 	br	811473e8 <__reset+0xfb1273e8>
81147404:	a5c00115 	stw	r23,4(r20)
81147408:	003feb06 	br	811473b8 <__reset+0xfb1273b8>
8114740c:	89000017 	ldw	r4,0(r17)
81147410:	183ee83a 	callr	r3
81147414:	003ff406 	br	811473e8 <__reset+0xfb1273e8>
81147418:	a0800017 	ldw	r2,0(r20)
8114741c:	a027883a 	mov	r19,r20
81147420:	1029883a 	mov	r20,r2
81147424:	003fb606 	br	81147300 <__reset+0xfb127300>
81147428:	0005883a 	mov	r2,zero
8114742c:	003ffb06 	br	8114741c <__reset+0xfb12741c>

81147430 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
81147430:	defffc04 	addi	sp,sp,-16
81147434:	de00012e 	bgeu	sp,et,8114743c <_exit+0xc>
81147438:	003b68fa 	trap	3
8114743c:	dfc00315 	stw	ra,12(sp)
81147440:	df000215 	stw	fp,8(sp)
81147444:	df000204 	addi	fp,sp,8
81147448:	e13fff15 	stw	r4,-4(fp)
  /* ALT_LOG - please see HAL/inc/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
8114744c:	d0a01217 	ldw	r2,-32696(gp)
81147450:	10800058 	cmpnei	r2,r2,1
81147454:	1000031e 	bne	r2,zero,81147464 <_exit+0x34>
81147458:	01204574 	movhi	r4,33045
8114745c:	21330404 	addi	r4,r4,-13296
81147460:	1132f400 	call	81132f40 <alt_log_printf_proc>
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
81147464:	d0a01217 	ldw	r2,-32696(gp)
81147468:	10800058 	cmpnei	r2,r2,1
8114746c:	1000041e 	bne	r2,zero,81147480 <_exit+0x50>
81147470:	e17fff17 	ldw	r5,-4(fp)
81147474:	01204574 	movhi	r4,33045
81147478:	21330f04 	addi	r4,r4,-13252
8114747c:	1132f400 	call	81132f40 <alt_log_printf_proc>
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
81147480:	d0a01217 	ldw	r2,-32696(gp)
81147484:	10800058 	cmpnei	r2,r2,1
81147488:	1000031e 	bne	r2,zero,81147498 <_exit+0x68>
8114748c:	01204574 	movhi	r4,33045
81147490:	21331a04 	addi	r4,r4,-13208
81147494:	1132f400 	call	81132f40 <alt_log_printf_proc>
  ALT_OS_STOP();
81147498:	d0208d05 	stb	zero,-32204(gp)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
8114749c:	d0a01217 	ldw	r2,-32696(gp)
811474a0:	10800058 	cmpnei	r2,r2,1
811474a4:	1000031e 	bne	r2,zero,811474b4 <_exit+0x84>
811474a8:	01204574 	movhi	r4,33045
811474ac:	21332404 	addi	r4,r4,-13168
811474b0:	1132f400 	call	81132f40 <alt_log_printf_proc>
811474b4:	e0bfff17 	ldw	r2,-4(fp)
811474b8:	e0bffe15 	stw	r2,-8(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  register int r2 asm ("r2") = exit_code;
811474bc:	e0bffe17 	ldw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "r"(r2), "r"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
811474c0:	10000226 	beq	r2,zero,811474cc <_exit+0x9c>
    ALT_SIM_FAIL();
811474c4:	002af070 	cmpltui	zero,zero,43969
811474c8:	00000106 	br	811474d0 <_exit+0xa0>
  } else {
    ALT_SIM_PASS();
811474cc:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
811474d0:	d0a01217 	ldw	r2,-32696(gp)
811474d4:	10800058 	cmpnei	r2,r2,1
811474d8:	1000031e 	bne	r2,zero,811474e8 <_exit+0xb8>
811474dc:	01204574 	movhi	r4,33045
811474e0:	21332e04 	addi	r4,r4,-13128
811474e4:	1132f400 	call	81132f40 <alt_log_printf_proc>
  while (1);
811474e8:	003fff06 	br	811474e8 <__reset+0xfb1274e8>
